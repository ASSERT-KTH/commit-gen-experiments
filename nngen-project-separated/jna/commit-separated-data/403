BLEU SCORE: 0.003976388001785548

TEST MSG: speed up callback lookup
GENERATED MSG: Copy fix for issue # 15 ( callbacks in struct ) from wmeissner - jnalib branch

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 22c2f26 . . 5cb9e4f 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 23 , 6 + 23 , 7 @ @ Features <nl> * [ # 243 ] ( https : / / github . com / twall / jna / issues / 243 ) : Automatically accommodate long library paths on Windows which would otherwise fail - [ @ twall ] ( https : / / github . com / twall ) . <nl> * [ # 241 ] ( https : / / github . com / twall / jna / issues / 241 ) - Added ` com . sun . jna . platform . win32 . Shell32 . SHAppBarMessage ` - [ @ bsorrentino ] ( https : / / github . com / bsorrentino ) . <nl> * Make ` Structure . read / writeField ( ) ` protected to facilitate per - field overrides - [ @ twall ] ( https : / / github . com / twall ) . <nl> + * Speed up callback lookup where large numbers of native function pointers are in use - [ @ twall ] ( https : / / github . com / twall ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java <nl> index 35dfe61 . . c3077b1 100644 <nl> - - - a / src / com / sun / jna / CallbackReference . java <nl> + + + b / src / com / sun / jna / CallbackReference . java <nl> @ @ - 1 , 4 + 1 , 4 @ @ <nl> - / * Copyright ( c ) 2007 - 2008 Timothy Wall , All Rights Reserved <nl> + / * Copyright ( c ) 2007 - 2013 Timothy Wall , All Rights Reserved <nl> * <nl> * This library is free software ; you can redistribute it and / or <nl> * modify it under the terms of the GNU Lesser General Public <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * / <nl> package com . sun . jna ; <nl> <nl> + import java . lang . ref . Reference ; <nl> import java . lang . ref . WeakReference ; <nl> import java . lang . reflect . InvocationHandler ; <nl> import java . lang . reflect . InvocationTargetException ; <nl> @ @ - 37 , 6 + 38 , 7 @ @ class CallbackReference extends WeakReference { <nl> <nl> static final Map callbackMap = new WeakHashMap ( ) ; <nl> static final Map directCallbackMap = new WeakHashMap ( ) ; <nl> + static final Map pointerCallbackMap = new WeakHashMap ( ) ; <nl> static final Map allocations = new WeakHashMap ( ) ; <nl> <nl> private static final Method PROXY _ CALLBACK _ METHOD ; <nl> @ @ - 95 , 7 + 97 , 10 @ @ class CallbackReference extends WeakReference { <nl> <nl> / * * Return a Callback associated with the given function pointer . <nl> * If the pointer refers to a Java callback trampoline , return the original <nl> - * Java Callback . Otherwise , return a proxy to the native function pointer . <nl> + * Java Callback . Otherwise , return a proxy to the native function <nl> + * pointer . <nl> + * @ throw IllegalStateException if the given pointer has already been <nl> + * mapped to a callback of a different type . <nl> * / <nl> public static Callback getCallback ( Class type , Pointer p ) { <nl> return getCallback ( type , p , false ) ; <nl> @ @ - 110 , 29 + 115 , 30 @ @ class CallbackReference extends WeakReference { <nl> throw new IllegalArgumentException ( " Callback type must be an interface " ) ; <nl> Map map = direct ? directCallbackMap : callbackMap ; <nl> synchronized ( callbackMap ) { <nl> - for ( Iterator i = map . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { <nl> - Callback cb = ( Callback ) i . next ( ) ; <nl> - if ( type . isAssignableFrom ( cb . getClass ( ) ) ) { <nl> - CallbackReference cbref = ( CallbackReference ) map . get ( cb ) ; <nl> - Pointer cbp = cbref ! = null <nl> - ? cbref . getTrampoline ( ) : getNativeFunctionPointer ( cb ) ; <nl> - if ( p . equals ( cbp ) ) { <nl> - return cb ; <nl> - } <nl> + Callback cb = null ; <nl> + Reference ref = ( Reference ) pointerCallbackMap . get ( p ) ; <nl> + if ( ref ! = null ) { <nl> + cb = ( Callback ) ref . get ( ) ; <nl> + if ( cb ! = null & & ! type . isAssignableFrom ( cb . getClass ( ) ) ) { <nl> + throw new IllegalStateException ( " Pointer " + p + " already mapped to " + cb ) ; <nl> } <nl> + return cb ; <nl> } <nl> int ctype = AltCallingConvention . class . isAssignableFrom ( type ) <nl> ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; <nl> Map foptions = new HashMap ( Native . getLibraryOptions ( type ) ) ; <nl> foptions . put ( Function . OPTION _ INVOKING _ METHOD , getCallbackMethod ( type ) ) ; <nl> NativeFunctionHandler h = new NativeFunctionHandler ( p , ctype , foptions ) ; <nl> - Callback cb = ( Callback ) Proxy . newProxyInstance ( type . getClassLoader ( ) , new Class [ ] { type } , h ) ; <nl> + cb = ( Callback ) Proxy . newProxyInstance ( type . getClassLoader ( ) , new Class [ ] { type } , h ) ; <nl> + / / No CallbackReference for this callback <nl> map . put ( cb , null ) ; <nl> + pointerCallbackMap . put ( p , new WeakReference ( cb ) ) ; <nl> return cb ; <nl> } <nl> } <nl> <nl> Pointer cbstruct ; <nl> + Pointer trampoline ; <nl> / / Keep a reference to the proxy to avoid premature GC of it <nl> CallbackProxy proxy ; <nl> Method method ; <nl> @ @ - 331 , 7 + 337 , 10 @ @ class CallbackReference extends WeakReference { <nl> <nl> / * * Obtain a pointer to the native glue code for this callback . * / <nl> public Pointer getTrampoline ( ) { <nl> - return cbstruct . getPointer ( 0 ) ; <nl> + if ( trampoline = = null ) { <nl> + trampoline = cbstruct . getPointer ( 0 ) ; <nl> + } <nl> + return trampoline ; <nl> } <nl> <nl> / * * Free native resources associated with this callback when GC ' d . * / <nl> @ @ - 389 , 6 + 398 , 7 @ @ class CallbackReference extends WeakReference { <nl> if ( cbref = = null ) { <nl> cbref = new CallbackReference ( cb , callingConvention , direct ) ; <nl> map . put ( cb , cbref ) ; <nl> + pointerCallbackMap . put ( cbref . getTrampoline ( ) , new WeakReference ( cb ) ) ; <nl> if ( initializers . containsKey ( cb ) ) { <nl> cbref . setCallbackOptions ( Native . CB _ HAS _ INITIALIZER ) ; <nl> } <nl> diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java <nl> index 776d3e7 . . 5ee58db 100644 <nl> - - - a / test / com / sun / jna / CallbacksTest . java <nl> + + + b / test / com / sun / jna / CallbacksTest . java <nl> @ @ - 1 , 4 + 1 , 4 @ @ <nl> - / * Copyright ( c ) 2007 - 2008 Timothy Wall , All Rights Reserved <nl> + / * Copyright ( c ) 2007 - 2013 Timothy Wall , All Rights Reserved <nl> * <nl> * This library is free software ; you can redistribute it and / or <nl> * modify it under the terms of the GNU Lesser General Public <nl> @ @ - 238 , 9 + 238 , 20 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> } <nl> } <nl> <nl> + public void testThrowOnMultiplyMappedCallback ( ) { <nl> + try { <nl> + Pointer p = new Pointer ( getName ( ) . hashCode ( ) ) ; <nl> + CallbackReference . getCallback ( TestLibrary . VoidCallback . class , p ) ; <nl> + CallbackReference . getCallback ( TestLibrary . ByteCallback . class , p ) ; <nl> + fail ( " Multiply - mapped callback should fail " ) ; <nl> + } <nl> + catch ( IllegalStateException e ) { <nl> + } <nl> + } <nl> + <nl> public void testNoMethodCallback ( ) { <nl> try { <nl> - CallbackReference . getCallback ( TestLibrary . NoMethodCallback . class , new Pointer ( 1 ) ) ; <nl> + CallbackReference . getCallback ( TestLibrary . NoMethodCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; <nl> fail ( " Callback with no callback method should fail " ) ; <nl> } <nl> catch ( IllegalArgumentException e ) { <nl> @ @ - 248 , 12 + 259 , 12 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> } <nl> <nl> public void testCustomMethodCallback ( ) { <nl> - CallbackReference . getCallback ( TestLibrary . CustomMethodCallback . class , new Pointer ( 1 ) ) ; <nl> + CallbackReference . getCallback ( TestLibrary . CustomMethodCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; <nl> } <nl> <nl> public void testTooManyMethodsCallback ( ) { <nl> try { <nl> - CallbackReference . getCallback ( TestLibrary . TooManyMethodsCallback . class , new Pointer ( 1 ) ) ; <nl> + CallbackReference . getCallback ( TestLibrary . TooManyMethodsCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; <nl> fail ( " Callback lookup with too many methods should fail " ) ; <nl> } <nl> catch ( IllegalArgumentException e ) { <nl> @ @ - 261 , 19 + 272 , 19 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> } <nl> <nl> public void testMultipleMethodsCallback ( ) { <nl> - CallbackReference . getCallback ( TestLibrary . MultipleMethodsCallback . class , new Pointer ( 1 ) ) ; <nl> + CallbackReference . getCallback ( TestLibrary . MultipleMethodsCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; <nl> } <nl> <nl> public void testNativeFunctionPointerStringValue ( ) { <nl> - Callback cb = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( 1 ) ) ; <nl> + Callback cb = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; <nl> Class cls = CallbackReference . findCallbackClass ( cb . getClass ( ) ) ; <nl> assertTrue ( " toString should include Java Callback type : " + cb + " ( " <nl> + cls + " ) " , cb . toString ( ) . indexOf ( cls . getName ( ) ) ! = - 1 ) ; <nl> } <nl> <nl> public void testLookupSameCallback ( ) { <nl> - Callback cb = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( 1 ) ) ; <nl> - Callback cb2 = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( 1 ) ) ; <nl> + Callback cb = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; <nl> + Callback cb2 = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; <nl> <nl> assertEquals ( " Callback lookups for same pointer should return same Callback object " , cb , cb2 ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / jnalib / src / com / sun / jna / examples / AlphaMaskDemo2 . java b / jnalib / src / com / sun / jna / examples / AlphaMaskDemo2 . java <nl> index 1a65825 . . c15ceb7 100644 <nl> - - - a / jnalib / src / com / sun / jna / examples / AlphaMaskDemo2 . java <nl> + + + b / jnalib / src / com / sun / jna / examples / AlphaMaskDemo2 . java <nl> @ @ - 56 , 11 + 56 , 9 @ @ import javax . swing . event . MouseInputAdapter ; <nl> / / rui @ ruilopes . com <nl> / / http : / / www . codeproject . com / cs / media / perpxalpha _ sharp . asp ? df = 100 & forumid = 3270 & exp = 0 & select = 773155 <nl> public class AlphaMaskDemo2 implements Runnable { <nl> - private static final DataFlavor URL _ FLAVOR = new DataFlavor ( <nl> - " application / x - java - url ; class = java . net . URL " , <nl> + private static final DataFlavor URL _ FLAVOR = new DataFlavor ( " application / x - java - url ; class = java . net . URL " , <nl> " URL " ) ; <nl> - private static final DataFlavor URI _ LIST _ FLAVOR = new DataFlavor ( <nl> - " text / uri - list ; class = java . lang . String " , <nl> + private static final DataFlavor URI _ LIST _ FLAVOR = new DataFlavor ( " text / uri - list ; class = java . lang . String " , <nl> " URI list " ) ; <nl> private JFrame frame ; <nl> private JWindow alphaWindow ; <nl> @ @ - 104 , 8 + 102 , 7 @ @ public class AlphaMaskDemo2 implements Runnable { <nl> <nl> public void run ( ) { <nl> / / Must find a graphics configuration with a depth of 32 bits <nl> - GraphicsConfiguration gconfig = WindowUtils <nl> - . getAlphaCompatibleGraphicsConfiguration ( ) ; <nl> + GraphicsConfiguration gconfig = WindowUtils . getAlphaCompatibleGraphicsConfiguration ( ) ; <nl> frame = new JFrame ( " Alpha Mask Demo " ) ; <nl> alphaWindow = new JWindow ( frame , gconfig ) ; <nl> icon = new JLabel ( ) ; <nl> diff - - git a / jnalib / src / com / sun / jna / examples / WindowUtils . java b / jnalib / src / com / sun / jna / examples / WindowUtils . java <nl> index 9b9efa0 . . 629cefd 100644 <nl> - - - a / jnalib / src / com / sun / jna / examples / WindowUtils . java <nl> + + + b / jnalib / src / com / sun / jna / examples / WindowUtils . java <nl> @ @ - 24 , 6 + 24 , 8 @ @ import java . awt . Graphics2D ; <nl> import java . awt . GraphicsConfiguration ; <nl> import java . awt . GraphicsDevice ; <nl> import java . awt . GraphicsEnvironment ; <nl> + import java . awt . Insets ; <nl> + import java . awt . Point ; <nl> import java . awt . Rectangle ; <nl> import java . awt . Shape ; <nl> import java . awt . Window ; <nl> @ @ - 94 , 6 + 96 , 7 @ @ public class WindowUtils { <nl> public static boolean doPaint ; <nl> private static final String TRANSPARENT _ OLD _ BG = " transparent - old - bg " ; <nl> private static final String TRANSPARENT _ OLD _ OPAQUE = " transparent - old - opaque " ; <nl> + private static final String TRANSPARENT _ ALPHA = " transparent - alpha " ; <nl> / * * Use this to clear a window mask . * / <nl> public static final Shape MASK _ NONE = null ; <nl> <nl> @ @ - 461 , 6 + 464 , 29 @ @ public class WindowUtils { <nl> return false ; <nl> } <nl> <nl> + / * * Keep track of the alpha level , since we can ' t read it from <nl> + * the window itself . <nl> + * / <nl> + private void storeAlpha ( Window w , byte alpha ) { <nl> + if ( w instanceof RootPaneContainer ) { <nl> + JRootPane root = ( ( RootPaneContainer ) w ) . getRootPane ( ) ; <nl> + Byte b = alpha = = ( byte ) 0xFF ? null : new Byte ( alpha ) ; <nl> + root . putClientProperty ( TRANSPARENT _ ALPHA , b ) ; <nl> + } <nl> + } <nl> + <nl> + / * * Return the last alpha level we set on the window . * / <nl> + private byte getAlpha ( Window w ) { <nl> + if ( w instanceof RootPaneContainer ) { <nl> + JRootPane root = ( ( RootPaneContainer ) w ) . getRootPane ( ) ; <nl> + Byte b = ( Byte ) root . getClientProperty ( TRANSPARENT _ ALPHA ) ; <nl> + if ( b ! = null ) { <nl> + return b . byteValue ( ) ; <nl> + } <nl> + } <nl> + return ( byte ) 0xFF ; <nl> + } <nl> + <nl> public void setWindowAlpha ( final Window w , final float alpha ) { <nl> if ( ! isWindowAlphaSupported ( ) ) { <nl> System . err . println ( " Window alpha not supported " ) ; <nl> @ @ - 471 , 9 + 497 , 12 @ @ public class WindowUtils { <nl> Pointer hWnd = getHWnd ( w ) ; <nl> User32 user = User32 . INSTANCE ; <nl> int flags = user . GetWindowLongA ( hWnd , User32 . GWL _ EXSTYLE ) ; <nl> + byte level = ( byte ) ( ( int ) ( 255 * alpha ) & 0xFF ) ; <nl> if ( isTransparent ( w ) ) { <nl> + / / If already using UpdateLayeredWindow , continue to <nl> + / / do so <nl> BLENDFUNCTION blend = new BLENDFUNCTION ( ) ; <nl> - blend . SourceConstantAlpha = ( byte ) ( ( int ) ( alpha * 255 ) & 0xFF ) ; <nl> + blend . SourceConstantAlpha = level ; <nl> blend . AlphaFormat = User32 . AC _ SRC _ ALPHA ; <nl> user . UpdateLayeredWindow ( hWnd , null , null , null , null , <nl> null , 0 , blend , <nl> @ @ - 486 , 11 + 515 , 11 @ @ public class WindowUtils { <nl> else { <nl> flags | = User32 . WS _ EX _ LAYERED ; <nl> user . SetWindowLongA ( hWnd , User32 . GWL _ EXSTYLE , flags ) ; <nl> - byte level = ( byte ) ( ( int ) ( 255 * alpha ) & 0xFF ) ; <nl> user . SetLayeredWindowAttributes ( hWnd , 0 , level , <nl> User32 . LWA _ ALPHA ) ; <nl> } <nl> setForceHeavyweightPopups ( w , alpha ! = 1f ) ; <nl> + storeAlpha ( w , level ) ; <nl> } <nl> } ) ; <nl> } <nl> @ @ - 508 , 13 + 537 , 13 @ @ public class WindowUtils { <nl> public void update ( ) { <nl> GDI32 gdi = GDI32 . INSTANCE ; <nl> User32 user = User32 . INSTANCE ; <nl> - int w = getWidth ( ) ; <nl> - int h = getHeight ( ) ; <nl> + Window win = SwingUtilities . getWindowAncestor ( this ) ; <nl> + int w = win . getWidth ( ) ; <nl> + int h = win . getHeight ( ) ; <nl> Pointer screenDC = user . GetDC ( null ) ; <nl> Pointer memDC = gdi . CreateCompatibleDC ( screenDC ) ; <nl> Pointer hBitmap = null ; <nl> Pointer oldBitmap = null ; <nl> - Window win = SwingUtilities . getWindowAncestor ( this ) ; <nl> try { <nl> BufferedImage buf = <nl> new BufferedImage ( w , h , BufferedImage . TYPE _ INT _ ARGB _ PRE ) ; <nl> @ @ - 522 , 7 + 551 , 9 @ @ public class WindowUtils { <nl> g . setComposite ( AlphaComposite . Clear ) ; <nl> g . fillRect ( 0 , 0 , w , h ) ; <nl> g . setComposite ( AlphaComposite . SrcOver ) ; <nl> - getParent ( ) . paint ( g ) ; <nl> + Point origin = SwingUtilities . convertPoint ( getParent ( ) , 0 , 0 , win ) ; <nl> + getParent ( ) . paint ( g . create ( origin . x , origin . y , <nl> + getWidth ( ) , getHeight ( ) ) ) ; <nl> BITMAPINFO bmi = new BITMAPINFO ( ) ; <nl> bmi . bmiHeader . biWidth = w ; <nl> bmi . bmiHeader . biHeight = h ; <nl> @ @ - 539 , 14 + 570 , 14 @ @ public class WindowUtils { <nl> Raster raster = buf . getData ( ) ; <nl> int [ ] pixel = new int [ 4 ] ; <nl> int [ ] bits = new int [ w * h ] ; <nl> - for ( int y = 0 ; y < h ; y + + ) { <nl> - for ( int x = 0 ; x < w ; x + + ) { <nl> - raster . getPixel ( x , h - y - 1 , pixel ) ; <nl> + for ( int row = 0 ; row < h ; row + + ) { <nl> + for ( int col = 0 ; col < w ; col + + ) { <nl> + raster . getPixel ( col , h - row - 1 , pixel ) ; <nl> int alpha = ( pixel [ 3 ] & 0xFF ) < < 24 ; <nl> int red = ( pixel [ 2 ] & 0xFF ) ; <nl> int green = ( pixel [ 1 ] & 0xFF ) < < 8 ; <nl> int blue = ( pixel [ 0 ] & 0xFF ) < < 16 ; <nl> - bits [ x + y * w ] = alpha | red | green | blue ; <nl> + bits [ col + row * w ] = alpha | red | green | blue ; <nl> } <nl> } <nl> pbits . write ( 0 , bits , 0 , bits . length ) ; <nl> @ @ - 559 , 13 + 590 , 15 @ @ public class WindowUtils { <nl> loc . x = win . getX ( ) ; <nl> loc . y = win . getY ( ) ; <nl> Pointer hWnd = Native . getWindowPointer ( win ) ; <nl> - / / extract current constant alpha setting <nl> + / / extract current constant alpha setting , if possible <nl> ByteByReference bref = new ByteByReference ( ) ; <nl> IntByReference iref = new IntByReference ( ) ; <nl> - user . GetLayeredWindowAttributes ( hWnd , null , bref , iref ) ; <nl> - blend . SourceConstantAlpha = ( iref . getValue ( ) & User32 . LWA _ ALPHA ) ! = 0 <nl> - ? bref . getValue ( ) <nl> - : ( byte ) 0xFF ; <nl> + byte level = getAlpha ( win ) ; <nl> + if ( user . GetLayeredWindowAttributes ( hWnd , null , bref , iref ) <nl> + & & ( iref . getValue ( ) & User32 . LWA _ ALPHA ) ! = 0 ) { <nl> + level = bref . getValue ( ) ; <nl> + } <nl> + blend . SourceConstantAlpha = level ; <nl> blend . AlphaFormat = User32 . AC _ SRC _ ALPHA ; <nl> user . UpdateLayeredWindow ( hWnd , screenDC , loc , size , memDC , <nl> srcLoc , 0 , blend , User32 . ULW _ ALPHA ) ; <nl> diff - - git a / jnalib / src / com / sun / jna / examples / X11AlphaMaskTest . java b / jnalib / src / com / sun / jna / examples / X11AlphaMaskTest . java <nl> index 43a25dd . . e579519 100644 <nl> - - - a / jnalib / src / com / sun / jna / examples / X11AlphaMaskTest . java <nl> + + + b / jnalib / src / com / sun / jna / examples / X11AlphaMaskTest . java <nl> @ @ - 55 , 57 + 55 , 57 @ @ public class X11AlphaMaskTest { <nl> g . setComposite ( AlphaComposite . Clear ) ; <nl> g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; <nl> g . setComposite ( AlphaComposite . SrcOver ) ; <nl> - int w = getWidth ( ) / 10 ; <nl> - int h = getHeight ( ) ; <nl> + int barw = getWidth ( ) / 10 ; <nl> + int barh = getHeight ( ) ; <nl> <nl> g . setColor ( Color . red ) ; <nl> - g . fillRect ( 0 , 0 , w , h ) ; <nl> + g . fillRect ( 0 , 0 , barw , barh ) ; <nl> g . setColor ( new Color ( 255 , 0 , 0 , alpha ) ) ; <nl> - g . fillRect ( w , 0 , w , h / 2 ) ; <nl> + g . fillRect ( barw , 0 , barw , barh / 2 ) ; <nl> g . setColor ( mix ( Color . red , 255 ) ) ; <nl> - g . fillRect ( w , h / 2 , w , h / 4 ) ; <nl> + g . fillRect ( barw , barh / 2 , barw , barh / 4 ) ; <nl> g . setColor ( mix ( Color . red , 0 ) ) ; <nl> - g . fillRect ( w , h * 3 / 4 , w , h / 4 ) ; <nl> + g . fillRect ( barw , barh * 3 / 4 , barw , barh / 4 ) ; <nl> <nl> g . setColor ( Color . green ) ; <nl> - g . fillRect ( 2 * w , 0 , w , h ) ; <nl> + g . fillRect ( 2 * barw , 0 , barw , barh ) ; <nl> g . setColor ( new Color ( 0 , 255 , 0 , alpha ) ) ; <nl> - g . fillRect ( 3 * w , 0 , w , h / 2 ) ; <nl> + g . fillRect ( 3 * barw , 0 , barw , barh / 2 ) ; <nl> g . setColor ( mix ( Color . green , 255 ) ) ; <nl> - g . fillRect ( 3 * w , h / 2 , w , h / 4 ) ; <nl> + g . fillRect ( 3 * barw , barh / 2 , barw , barh / 4 ) ; <nl> g . setColor ( mix ( Color . green , 0 ) ) ; <nl> - g . fillRect ( 3 * w , h * 3 / 4 , w , h / 4 ) ; <nl> + g . fillRect ( 3 * barw , barh * 3 / 4 , barw , barh / 4 ) ; <nl> <nl> g . setColor ( Color . blue ) ; <nl> - g . fillRect ( 4 * w , 0 , w , h ) ; <nl> + g . fillRect ( 4 * barw , 0 , barw , barh ) ; <nl> g . setColor ( new Color ( 0 , 0 , 255 , alpha ) ) ; <nl> - g . fillRect ( 5 * w , 0 , w , h / 2 ) ; <nl> + g . fillRect ( 5 * barw , 0 , barw , barh / 2 ) ; <nl> g . setColor ( mix ( Color . blue , 255 ) ) ; <nl> - g . fillRect ( 5 * w , h / 2 , w , h / 4 ) ; <nl> + g . fillRect ( 5 * barw , barh / 2 , barw , barh / 4 ) ; <nl> g . setColor ( mix ( Color . blue , 0 ) ) ; <nl> - g . fillRect ( 5 * w , h * 3 / 4 , w , h / 4 ) ; <nl> + g . fillRect ( 5 * barw , barh * 3 / 4 , barw , barh / 4 ) ; <nl> <nl> g . setColor ( Color . white ) ; <nl> - g . fillRect ( 6 * w , 0 , w , h ) ; <nl> + g . fillRect ( 6 * barw , 0 , barw , barh ) ; <nl> g . setColor ( new Color ( 255 , 255 , 255 , alpha ) ) ; <nl> - g . fillRect ( 7 * w , 0 , w , h / 2 ) ; <nl> + g . fillRect ( 7 * barw , 0 , barw , barh / 2 ) ; <nl> g . setColor ( mix ( Color . white , 255 ) ) ; <nl> - g . fillRect ( 7 * w , h / 2 , w , h / 4 ) ; <nl> + g . fillRect ( 7 * barw , barh / 2 , barw , barh / 4 ) ; <nl> g . setColor ( mix ( Color . white , 0 ) ) ; <nl> - g . fillRect ( 7 * w , h * 3 / 4 , w , h / 4 ) ; <nl> + g . fillRect ( 7 * barw , barh * 3 / 4 , barw , barh / 4 ) ; <nl> <nl> g . setColor ( Color . black ) ; <nl> - g . fillRect ( 8 * w , 0 , w , h ) ; <nl> + g . fillRect ( 8 * barw , 0 , barw , barh ) ; <nl> g . setColor ( new Color ( 0 , 0 , 0 , alpha ) ) ; <nl> - g . fillRect ( 9 * w , 0 , w , h / 2 ) ; <nl> + g . fillRect ( 9 * barw , 0 , barw , barh / 2 ) ; <nl> g . setColor ( mix ( Color . black , 255 ) ) ; <nl> - g . fillRect ( 9 * w , h / 2 , w , h / 4 ) ; <nl> + g . fillRect ( 9 * barw , barh / 2 , barw , barh / 4 ) ; <nl> g . setColor ( mix ( Color . black , 0 ) ) ; <nl> - g . fillRect ( 9 * w , h * 3 / 4 , w , h / 4 ) ; <nl> + g . fillRect ( 9 * barw , barh * 3 / 4 , barw , barh / 4 ) ; <nl> <nl> / / small bar on top , black 50 % alpha <nl> g . setColor ( new Color ( 0 , 0 , 0 , 128 ) ) ; <nl> - g . fillRect ( 0 , 0 , getWidth ( ) , h / 10 ) ; <nl> + g . fillRect ( 0 , 0 , getWidth ( ) , barh / 10 ) ; <nl> <nl> if ( false ) { <nl> BufferedImage prealpha =

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 22c2f26 . . 5cb9e4f 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 23 , 6 + 23 , 7 @ @ Features 
 * [ # 243 ] ( https : / / github . com / twall / jna / issues / 243 ) : Automatically accommodate long library paths on Windows which would otherwise fail - [ @ twall ] ( https : / / github . com / twall ) . 
 * [ # 241 ] ( https : / / github . com / twall / jna / issues / 241 ) - Added ` com . sun . jna . platform . win32 . Shell32 . SHAppBarMessage ` - [ @ bsorrentino ] ( https : / / github . com / bsorrentino ) . 
 * Make ` Structure . read / writeField ( ) ` protected to facilitate per - field overrides - [ @ twall ] ( https : / / github . com / twall ) . 
 + * Speed up callback lookup where large numbers of native function pointers are in use - [ @ twall ] ( https : / / github . com / twall ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java 
 index 35dfe61 . . c3077b1 100644 
 - - - a / src / com / sun / jna / CallbackReference . java 
 + + + b / src / com / sun / jna / CallbackReference . java 
 @ @ - 1 , 4 + 1 , 4 @ @ 
 - / * Copyright ( c ) 2007 - 2008 Timothy Wall , All Rights Reserved 
 + / * Copyright ( c ) 2007 - 2013 Timothy Wall , All Rights Reserved 
 * 
 * This library is free software ; you can redistribute it and / or 
 * modify it under the terms of the GNU Lesser General Public 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * / 
 package com . sun . jna ; 
 
 + import java . lang . ref . Reference ; 
 import java . lang . ref . WeakReference ; 
 import java . lang . reflect . InvocationHandler ; 
 import java . lang . reflect . InvocationTargetException ; 
 @ @ - 37 , 6 + 38 , 7 @ @ class CallbackReference extends WeakReference { 
 
 static final Map callbackMap = new WeakHashMap ( ) ; 
 static final Map directCallbackMap = new WeakHashMap ( ) ; 
 + static final Map pointerCallbackMap = new WeakHashMap ( ) ; 
 static final Map allocations = new WeakHashMap ( ) ; 
 
 private static final Method PROXY _ CALLBACK _ METHOD ; 
 @ @ - 95 , 7 + 97 , 10 @ @ class CallbackReference extends WeakReference { 
 
 / * * Return a Callback associated with the given function pointer . 
 * If the pointer refers to a Java callback trampoline , return the original 
 - * Java Callback . Otherwise , return a proxy to the native function pointer . 
 + * Java Callback . Otherwise , return a proxy to the native function 
 + * pointer . 
 + * @ throw IllegalStateException if the given pointer has already been 
 + * mapped to a callback of a different type . 
 * / 
 public static Callback getCallback ( Class type , Pointer p ) { 
 return getCallback ( type , p , false ) ; 
 @ @ - 110 , 29 + 115 , 30 @ @ class CallbackReference extends WeakReference { 
 throw new IllegalArgumentException ( " Callback type must be an interface " ) ; 
 Map map = direct ? directCallbackMap : callbackMap ; 
 synchronized ( callbackMap ) { 
 - for ( Iterator i = map . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 - Callback cb = ( Callback ) i . next ( ) ; 
 - if ( type . isAssignableFrom ( cb . getClass ( ) ) ) { 
 - CallbackReference cbref = ( CallbackReference ) map . get ( cb ) ; 
 - Pointer cbp = cbref ! = null 
 - ? cbref . getTrampoline ( ) : getNativeFunctionPointer ( cb ) ; 
 - if ( p . equals ( cbp ) ) { 
 - return cb ; 
 - } 
 + Callback cb = null ; 
 + Reference ref = ( Reference ) pointerCallbackMap . get ( p ) ; 
 + if ( ref ! = null ) { 
 + cb = ( Callback ) ref . get ( ) ; 
 + if ( cb ! = null & & ! type . isAssignableFrom ( cb . getClass ( ) ) ) { 
 + throw new IllegalStateException ( " Pointer " + p + " already mapped to " + cb ) ; 
 } 
 + return cb ; 
 } 
 int ctype = AltCallingConvention . class . isAssignableFrom ( type ) 
 ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; 
 Map foptions = new HashMap ( Native . getLibraryOptions ( type ) ) ; 
 foptions . put ( Function . OPTION _ INVOKING _ METHOD , getCallbackMethod ( type ) ) ; 
 NativeFunctionHandler h = new NativeFunctionHandler ( p , ctype , foptions ) ; 
 - Callback cb = ( Callback ) Proxy . newProxyInstance ( type . getClassLoader ( ) , new Class [ ] { type } , h ) ; 
 + cb = ( Callback ) Proxy . newProxyInstance ( type . getClassLoader ( ) , new Class [ ] { type } , h ) ; 
 + / / No CallbackReference for this callback 
 map . put ( cb , null ) ; 
 + pointerCallbackMap . put ( p , new WeakReference ( cb ) ) ; 
 return cb ; 
 } 
 } 
 
 Pointer cbstruct ; 
 + Pointer trampoline ; 
 / / Keep a reference to the proxy to avoid premature GC of it 
 CallbackProxy proxy ; 
 Method method ; 
 @ @ - 331 , 7 + 337 , 10 @ @ class CallbackReference extends WeakReference { 
 
 / * * Obtain a pointer to the native glue code for this callback . * / 
 public Pointer getTrampoline ( ) { 
 - return cbstruct . getPointer ( 0 ) ; 
 + if ( trampoline = = null ) { 
 + trampoline = cbstruct . getPointer ( 0 ) ; 
 + } 
 + return trampoline ; 
 } 
 
 / * * Free native resources associated with this callback when GC ' d . * / 
 @ @ - 389 , 6 + 398 , 7 @ @ class CallbackReference extends WeakReference { 
 if ( cbref = = null ) { 
 cbref = new CallbackReference ( cb , callingConvention , direct ) ; 
 map . put ( cb , cbref ) ; 
 + pointerCallbackMap . put ( cbref . getTrampoline ( ) , new WeakReference ( cb ) ) ; 
 if ( initializers . containsKey ( cb ) ) { 
 cbref . setCallbackOptions ( Native . CB _ HAS _ INITIALIZER ) ; 
 } 
 diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java 
 index 776d3e7 . . 5ee58db 100644 
 - - - a / test / com / sun / jna / CallbacksTest . java 
 + + + b / test / com / sun / jna / CallbacksTest . java 
 @ @ - 1 , 4 + 1 , 4 @ @ 
 - / * Copyright ( c ) 2007 - 2008 Timothy Wall , All Rights Reserved 
 + / * Copyright ( c ) 2007 - 2013 Timothy Wall , All Rights Reserved 
 * 
 * This library is free software ; you can redistribute it and / or 
 * modify it under the terms of the GNU Lesser General Public 
 @ @ - 238 , 9 + 238 , 20 @ @ public class CallbacksTest extends TestCase implements Paths { 
 } 
 } 
 
 + public void testThrowOnMultiplyMappedCallback ( ) { 
 + try { 
 + Pointer p = new Pointer ( getName ( ) . hashCode ( ) ) ; 
 + CallbackReference . getCallback ( TestLibrary . VoidCallback . class , p ) ; 
 + CallbackReference . getCallback ( TestLibrary . ByteCallback . class , p ) ; 
 + fail ( " Multiply - mapped callback should fail " ) ; 
 + } 
 + catch ( IllegalStateException e ) { 
 + } 
 + } 
 + 
 public void testNoMethodCallback ( ) { 
 try { 
 - CallbackReference . getCallback ( TestLibrary . NoMethodCallback . class , new Pointer ( 1 ) ) ; 
 + CallbackReference . getCallback ( TestLibrary . NoMethodCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; 
 fail ( " Callback with no callback method should fail " ) ; 
 } 
 catch ( IllegalArgumentException e ) { 
 @ @ - 248 , 12 + 259 , 12 @ @ public class CallbacksTest extends TestCase implements Paths { 
 } 
 
 public void testCustomMethodCallback ( ) { 
 - CallbackReference . getCallback ( TestLibrary . CustomMethodCallback . class , new Pointer ( 1 ) ) ; 
 + CallbackReference . getCallback ( TestLibrary . CustomMethodCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; 
 } 
 
 public void testTooManyMethodsCallback ( ) { 
 try { 
 - CallbackReference . getCallback ( TestLibrary . TooManyMethodsCallback . class , new Pointer ( 1 ) ) ; 
 + CallbackReference . getCallback ( TestLibrary . TooManyMethodsCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; 
 fail ( " Callback lookup with too many methods should fail " ) ; 
 } 
 catch ( IllegalArgumentException e ) { 
 @ @ - 261 , 19 + 272 , 19 @ @ public class CallbacksTest extends TestCase implements Paths { 
 } 
 
 public void testMultipleMethodsCallback ( ) { 
 - CallbackReference . getCallback ( TestLibrary . MultipleMethodsCallback . class , new Pointer ( 1 ) ) ; 
 + CallbackReference . getCallback ( TestLibrary . MultipleMethodsCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; 
 } 
 
 public void testNativeFunctionPointerStringValue ( ) { 
 - Callback cb = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( 1 ) ) ; 
 + Callback cb = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; 
 Class cls = CallbackReference . findCallbackClass ( cb . getClass ( ) ) ; 
 assertTrue ( " toString should include Java Callback type : " + cb + " ( " 
 + cls + " ) " , cb . toString ( ) . indexOf ( cls . getName ( ) ) ! = - 1 ) ; 
 } 
 
 public void testLookupSameCallback ( ) { 
 - Callback cb = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( 1 ) ) ; 
 - Callback cb2 = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( 1 ) ) ; 
 + Callback cb = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; 
 + Callback cb2 = CallbackReference . getCallback ( TestLibrary . VoidCallback . class , new Pointer ( getName ( ) . hashCode ( ) ) ) ; 
 
 assertEquals ( " Callback lookups for same pointer should return same Callback object " , cb , cb2 ) ; 
 }

NEAREST DIFF:
diff - - git a / jnalib / src / com / sun / jna / examples / AlphaMaskDemo2 . java b / jnalib / src / com / sun / jna / examples / AlphaMaskDemo2 . java 
 index 1a65825 . . c15ceb7 100644 
 - - - a / jnalib / src / com / sun / jna / examples / AlphaMaskDemo2 . java 
 + + + b / jnalib / src / com / sun / jna / examples / AlphaMaskDemo2 . java 
 @ @ - 56 , 11 + 56 , 9 @ @ import javax . swing . event . MouseInputAdapter ; 
 / / rui @ ruilopes . com 
 / / http : / / www . codeproject . com / cs / media / perpxalpha _ sharp . asp ? df = 100 & forumid = 3270 & exp = 0 & select = 773155 
 public class AlphaMaskDemo2 implements Runnable { 
 - private static final DataFlavor URL _ FLAVOR = new DataFlavor ( 
 - " application / x - java - url ; class = java . net . URL " , 
 + private static final DataFlavor URL _ FLAVOR = new DataFlavor ( " application / x - java - url ; class = java . net . URL " , 
 " URL " ) ; 
 - private static final DataFlavor URI _ LIST _ FLAVOR = new DataFlavor ( 
 - " text / uri - list ; class = java . lang . String " , 
 + private static final DataFlavor URI _ LIST _ FLAVOR = new DataFlavor ( " text / uri - list ; class = java . lang . String " , 
 " URI list " ) ; 
 private JFrame frame ; 
 private JWindow alphaWindow ; 
 @ @ - 104 , 8 + 102 , 7 @ @ public class AlphaMaskDemo2 implements Runnable { 
 
 public void run ( ) { 
 / / Must find a graphics configuration with a depth of 32 bits 
 - GraphicsConfiguration gconfig = WindowUtils 
 - . getAlphaCompatibleGraphicsConfiguration ( ) ; 
 + GraphicsConfiguration gconfig = WindowUtils . getAlphaCompatibleGraphicsConfiguration ( ) ; 
 frame = new JFrame ( " Alpha Mask Demo " ) ; 
 alphaWindow = new JWindow ( frame , gconfig ) ; 
 icon = new JLabel ( ) ; 
 diff - - git a / jnalib / src / com / sun / jna / examples / WindowUtils . java b / jnalib / src / com / sun / jna / examples / WindowUtils . java 
 index 9b9efa0 . . 629cefd 100644 
 - - - a / jnalib / src / com / sun / jna / examples / WindowUtils . java 
 + + + b / jnalib / src / com / sun / jna / examples / WindowUtils . java 
 @ @ - 24 , 6 + 24 , 8 @ @ import java . awt . Graphics2D ; 
 import java . awt . GraphicsConfiguration ; 
 import java . awt . GraphicsDevice ; 
 import java . awt . GraphicsEnvironment ; 
 + import java . awt . Insets ; 
 + import java . awt . Point ; 
 import java . awt . Rectangle ; 
 import java . awt . Shape ; 
 import java . awt . Window ; 
 @ @ - 94 , 6 + 96 , 7 @ @ public class WindowUtils { 
 public static boolean doPaint ; 
 private static final String TRANSPARENT _ OLD _ BG = " transparent - old - bg " ; 
 private static final String TRANSPARENT _ OLD _ OPAQUE = " transparent - old - opaque " ; 
 + private static final String TRANSPARENT _ ALPHA = " transparent - alpha " ; 
 / * * Use this to clear a window mask . * / 
 public static final Shape MASK _ NONE = null ; 
 
 @ @ - 461 , 6 + 464 , 29 @ @ public class WindowUtils { 
 return false ; 
 } 
 
 + / * * Keep track of the alpha level , since we can ' t read it from 
 + * the window itself . 
 + * / 
 + private void storeAlpha ( Window w , byte alpha ) { 
 + if ( w instanceof RootPaneContainer ) { 
 + JRootPane root = ( ( RootPaneContainer ) w ) . getRootPane ( ) ; 
 + Byte b = alpha = = ( byte ) 0xFF ? null : new Byte ( alpha ) ; 
 + root . putClientProperty ( TRANSPARENT _ ALPHA , b ) ; 
 + } 
 + } 
 + 
 + / * * Return the last alpha level we set on the window . * / 
 + private byte getAlpha ( Window w ) { 
 + if ( w instanceof RootPaneContainer ) { 
 + JRootPane root = ( ( RootPaneContainer ) w ) . getRootPane ( ) ; 
 + Byte b = ( Byte ) root . getClientProperty ( TRANSPARENT _ ALPHA ) ; 
 + if ( b ! = null ) { 
 + return b . byteValue ( ) ; 
 + } 
 + } 
 + return ( byte ) 0xFF ; 
 + } 
 + 
 public void setWindowAlpha ( final Window w , final float alpha ) { 
 if ( ! isWindowAlphaSupported ( ) ) { 
 System . err . println ( " Window alpha not supported " ) ; 
 @ @ - 471 , 9 + 497 , 12 @ @ public class WindowUtils { 
 Pointer hWnd = getHWnd ( w ) ; 
 User32 user = User32 . INSTANCE ; 
 int flags = user . GetWindowLongA ( hWnd , User32 . GWL _ EXSTYLE ) ; 
 + byte level = ( byte ) ( ( int ) ( 255 * alpha ) & 0xFF ) ; 
 if ( isTransparent ( w ) ) { 
 + / / If already using UpdateLayeredWindow , continue to 
 + / / do so 
 BLENDFUNCTION blend = new BLENDFUNCTION ( ) ; 
 - blend . SourceConstantAlpha = ( byte ) ( ( int ) ( alpha * 255 ) & 0xFF ) ; 
 + blend . SourceConstantAlpha = level ; 
 blend . AlphaFormat = User32 . AC _ SRC _ ALPHA ; 
 user . UpdateLayeredWindow ( hWnd , null , null , null , null , 
 null , 0 , blend , 
 @ @ - 486 , 11 + 515 , 11 @ @ public class WindowUtils { 
 else { 
 flags | = User32 . WS _ EX _ LAYERED ; 
 user . SetWindowLongA ( hWnd , User32 . GWL _ EXSTYLE , flags ) ; 
 - byte level = ( byte ) ( ( int ) ( 255 * alpha ) & 0xFF ) ; 
 user . SetLayeredWindowAttributes ( hWnd , 0 , level , 
 User32 . LWA _ ALPHA ) ; 
 } 
 setForceHeavyweightPopups ( w , alpha ! = 1f ) ; 
 + storeAlpha ( w , level ) ; 
 } 
 } ) ; 
 } 
 @ @ - 508 , 13 + 537 , 13 @ @ public class WindowUtils { 
 public void update ( ) { 
 GDI32 gdi = GDI32 . INSTANCE ; 
 User32 user = User32 . INSTANCE ; 
 - int w = getWidth ( ) ; 
 - int h = getHeight ( ) ; 
 + Window win = SwingUtilities . getWindowAncestor ( this ) ; 
 + int w = win . getWidth ( ) ; 
 + int h = win . getHeight ( ) ; 
 Pointer screenDC = user . GetDC ( null ) ; 
 Pointer memDC = gdi . CreateCompatibleDC ( screenDC ) ; 
 Pointer hBitmap = null ; 
 Pointer oldBitmap = null ; 
 - Window win = SwingUtilities . getWindowAncestor ( this ) ; 
 try { 
 BufferedImage buf = 
 new BufferedImage ( w , h , BufferedImage . TYPE _ INT _ ARGB _ PRE ) ; 
 @ @ - 522 , 7 + 551 , 9 @ @ public class WindowUtils { 
 g . setComposite ( AlphaComposite . Clear ) ; 
 g . fillRect ( 0 , 0 , w , h ) ; 
 g . setComposite ( AlphaComposite . SrcOver ) ; 
 - getParent ( ) . paint ( g ) ; 
 + Point origin = SwingUtilities . convertPoint ( getParent ( ) , 0 , 0 , win ) ; 
 + getParent ( ) . paint ( g . create ( origin . x , origin . y , 
 + getWidth ( ) , getHeight ( ) ) ) ; 
 BITMAPINFO bmi = new BITMAPINFO ( ) ; 
 bmi . bmiHeader . biWidth = w ; 
 bmi . bmiHeader . biHeight = h ; 
 @ @ - 539 , 14 + 570 , 14 @ @ public class WindowUtils { 
 Raster raster = buf . getData ( ) ; 
 int [ ] pixel = new int [ 4 ] ; 
 int [ ] bits = new int [ w * h ] ; 
 - for ( int y = 0 ; y < h ; y + + ) { 
 - for ( int x = 0 ; x < w ; x + + ) { 
 - raster . getPixel ( x , h - y - 1 , pixel ) ; 
 + for ( int row = 0 ; row < h ; row + + ) { 
 + for ( int col = 0 ; col < w ; col + + ) { 
 + raster . getPixel ( col , h - row - 1 , pixel ) ; 
 int alpha = ( pixel [ 3 ] & 0xFF ) < < 24 ; 
 int red = ( pixel [ 2 ] & 0xFF ) ; 
 int green = ( pixel [ 1 ] & 0xFF ) < < 8 ; 
 int blue = ( pixel [ 0 ] & 0xFF ) < < 16 ; 
 - bits [ x + y * w ] = alpha | red | green | blue ; 
 + bits [ col + row * w ] = alpha | red | green | blue ; 
 } 
 } 
 pbits . write ( 0 , bits , 0 , bits . length ) ; 
 @ @ - 559 , 13 + 590 , 15 @ @ public class WindowUtils { 
 loc . x = win . getX ( ) ; 
 loc . y = win . getY ( ) ; 
 Pointer hWnd = Native . getWindowPointer ( win ) ; 
 - / / extract current constant alpha setting 
 + / / extract current constant alpha setting , if possible 
 ByteByReference bref = new ByteByReference ( ) ; 
 IntByReference iref = new IntByReference ( ) ; 
 - user . GetLayeredWindowAttributes ( hWnd , null , bref , iref ) ; 
 - blend . SourceConstantAlpha = ( iref . getValue ( ) & User32 . LWA _ ALPHA ) ! = 0 
 - ? bref . getValue ( ) 
 - : ( byte ) 0xFF ; 
 + byte level = getAlpha ( win ) ; 
 + if ( user . GetLayeredWindowAttributes ( hWnd , null , bref , iref ) 
 + & & ( iref . getValue ( ) & User32 . LWA _ ALPHA ) ! = 0 ) { 
 + level = bref . getValue ( ) ; 
 + } 
 + blend . SourceConstantAlpha = level ; 
 blend . AlphaFormat = User32 . AC _ SRC _ ALPHA ; 
 user . UpdateLayeredWindow ( hWnd , screenDC , loc , size , memDC , 
 srcLoc , 0 , blend , User32 . ULW _ ALPHA ) ; 
 diff - - git a / jnalib / src / com / sun / jna / examples / X11AlphaMaskTest . java b / jnalib / src / com / sun / jna / examples / X11AlphaMaskTest . java 
 index 43a25dd . . e579519 100644 
 - - - a / jnalib / src / com / sun / jna / examples / X11AlphaMaskTest . java 
 + + + b / jnalib / src / com / sun / jna / examples / X11AlphaMaskTest . java 
 @ @ - 55 , 57 + 55 , 57 @ @ public class X11AlphaMaskTest { 
 g . setComposite ( AlphaComposite . Clear ) ; 
 g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; 
 g . setComposite ( AlphaComposite . SrcOver ) ; 
 - int w = getWidth ( ) / 10 ; 
 - int h = getHeight ( ) ; 
 + int barw = getWidth ( ) / 10 ; 
 + int barh = getHeight ( ) ; 
 
 g . setColor ( Color . red ) ; 
 - g . fillRect ( 0 , 0 , w , h ) ; 
 + g . fillRect ( 0 , 0 , barw , barh ) ; 
 g . setColor ( new Color ( 255 , 0 , 0 , alpha ) ) ; 
 - g . fillRect ( w , 0 , w , h / 2 ) ; 
 + g . fillRect ( barw , 0 , barw , barh / 2 ) ; 
 g . setColor ( mix ( Color . red , 255 ) ) ; 
 - g . fillRect ( w , h / 2 , w , h / 4 ) ; 
 + g . fillRect ( barw , barh / 2 , barw , barh / 4 ) ; 
 g . setColor ( mix ( Color . red , 0 ) ) ; 
 - g . fillRect ( w , h * 3 / 4 , w , h / 4 ) ; 
 + g . fillRect ( barw , barh * 3 / 4 , barw , barh / 4 ) ; 
 
 g . setColor ( Color . green ) ; 
 - g . fillRect ( 2 * w , 0 , w , h ) ; 
 + g . fillRect ( 2 * barw , 0 , barw , barh ) ; 
 g . setColor ( new Color ( 0 , 255 , 0 , alpha ) ) ; 
 - g . fillRect ( 3 * w , 0 , w , h / 2 ) ; 
 + g . fillRect ( 3 * barw , 0 , barw , barh / 2 ) ; 
 g . setColor ( mix ( Color . green , 255 ) ) ; 
 - g . fillRect ( 3 * w , h / 2 , w , h / 4 ) ; 
 + g . fillRect ( 3 * barw , barh / 2 , barw , barh / 4 ) ; 
 g . setColor ( mix ( Color . green , 0 ) ) ; 
 - g . fillRect ( 3 * w , h * 3 / 4 , w , h / 4 ) ; 
 + g . fillRect ( 3 * barw , barh * 3 / 4 , barw , barh / 4 ) ; 
 
 g . setColor ( Color . blue ) ; 
 - g . fillRect ( 4 * w , 0 , w , h ) ; 
 + g . fillRect ( 4 * barw , 0 , barw , barh ) ; 
 g . setColor ( new Color ( 0 , 0 , 255 , alpha ) ) ; 
 - g . fillRect ( 5 * w , 0 , w , h / 2 ) ; 
 + g . fillRect ( 5 * barw , 0 , barw , barh / 2 ) ; 
 g . setColor ( mix ( Color . blue , 255 ) ) ; 
 - g . fillRect ( 5 * w , h / 2 , w , h / 4 ) ; 
 + g . fillRect ( 5 * barw , barh / 2 , barw , barh / 4 ) ; 
 g . setColor ( mix ( Color . blue , 0 ) ) ; 
 - g . fillRect ( 5 * w , h * 3 / 4 , w , h / 4 ) ; 
 + g . fillRect ( 5 * barw , barh * 3 / 4 , barw , barh / 4 ) ; 
 
 g . setColor ( Color . white ) ; 
 - g . fillRect ( 6 * w , 0 , w , h ) ; 
 + g . fillRect ( 6 * barw , 0 , barw , barh ) ; 
 g . setColor ( new Color ( 255 , 255 , 255 , alpha ) ) ; 
 - g . fillRect ( 7 * w , 0 , w , h / 2 ) ; 
 + g . fillRect ( 7 * barw , 0 , barw , barh / 2 ) ; 
 g . setColor ( mix ( Color . white , 255 ) ) ; 
 - g . fillRect ( 7 * w , h / 2 , w , h / 4 ) ; 
 + g . fillRect ( 7 * barw , barh / 2 , barw , barh / 4 ) ; 
 g . setColor ( mix ( Color . white , 0 ) ) ; 
 - g . fillRect ( 7 * w , h * 3 / 4 , w , h / 4 ) ; 
 + g . fillRect ( 7 * barw , barh * 3 / 4 , barw , barh / 4 ) ; 
 
 g . setColor ( Color . black ) ; 
 - g . fillRect ( 8 * w , 0 , w , h ) ; 
 + g . fillRect ( 8 * barw , 0 , barw , barh ) ; 
 g . setColor ( new Color ( 0 , 0 , 0 , alpha ) ) ; 
 - g . fillRect ( 9 * w , 0 , w , h / 2 ) ; 
 + g . fillRect ( 9 * barw , 0 , barw , barh / 2 ) ; 
 g . setColor ( mix ( Color . black , 255 ) ) ; 
 - g . fillRect ( 9 * w , h / 2 , w , h / 4 ) ; 
 + g . fillRect ( 9 * barw , barh / 2 , barw , barh / 4 ) ; 
 g . setColor ( mix ( Color . black , 0 ) ) ; 
 - g . fillRect ( 9 * w , h * 3 / 4 , w , h / 4 ) ; 
 + g . fillRect ( 9 * barw , barh * 3 / 4 , barw , barh / 4 ) ; 
 
 / / small bar on top , black 50 % alpha 
 g . setColor ( new Color ( 0 , 0 , 0 , 128 ) ) ; 
 - g . fillRect ( 0 , 0 , getWidth ( ) , h / 10 ) ; 
 + g . fillRect ( 0 , 0 , getWidth ( ) , barh / 10 ) ; 
 
 if ( false ) { 
 BufferedImage prealpha =
