BLEU SCORE: 0.002124269490650393

TEST MSG: Add CallNTPowerInformation function
GENERATED MSG: Addition win32 api : SendMessage , GetActiveWindow , COPYDATASTRUCT and a few constants + a demo application

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 4ad228d . . f5b209d 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 11 , 6 + 11 , 7 @ @ Features <nl> * [ # 1050 ] ( https : / / github . com / java - native - access / jna / pull / 1050 ) : Add ` c . s . j . p . win32 . VersionHelpers ` and supporting functions - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> * [ # 1061 ] ( https : / / github . com / java - native - access / jna / pull / 1061 ) : replace toArray ( new T [ size ] ) with toArray ( new T [ 0 ] ) for better performance - [ @ hc - codersatlas ] ( https : / / github . com / hc - codersatlas ) . <nl> * [ # 1064 ] ( https : / / github . com / java - native - access / jna / pull / 1064 ) : Add ` c . s . j . p . win32 . Kernel32 . GetLogicalProcessorInformationEx ` function , convenience Util method and supporting structures - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> + * [ # 1065 ] ( https : / / github . com / java - native - access / jna / pull / 1065 ) : Add ` c . s . j . p . win32 . PowrProf # CallNTPowerInformation ` and supporting structures - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / NTStatus . java b / contrib / platform / src / com / sun / jna / platform / win32 / NTStatus . java <nl> index 3711179 . . dac8962 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / NTStatus . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / NTStatus . java <nl> @ @ - 105 , 5 + 105 , 14 @ @ public interface NTStatus { <nl> / / Indicates a particular Security ID may not be assigned as the owner of an object . <nl> / / <nl> int STATUS _ INVALID _ OWNER = 0xC000005A ; <nl> + <nl> + / / MessageId : STATUS _ ACCESS _ DENIED <nl> + / / <nl> + / / MessageText : <nl> + / / <nl> + / / A process has requested access to an object , but has not been granted <nl> + / / those access rights . <nl> + / / <nl> + int STATUS _ ACCESS _ DENIED = 0xC0000022 ; <nl> } <nl> <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / PowrProf . java b / contrib / platform / src / com / sun / jna / platform / win32 / PowrProf . java <nl> new file mode 100644 <nl> index 0000000 . . 46f6ace <nl> - - - / dev / null <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / PowrProf . java <nl> @ @ - 0 , 0 + 1 , 231 @ @ <nl> + / * Copyright ( c ) 2019 Daniel Widdis , All Rights Reserved <nl> + * <nl> + * The contents of this file is dual - licensed under 2 <nl> + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and <nl> + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . <nl> + * <nl> + * You can freely decide which license you want to apply to <nl> + * the project . <nl> + * <nl> + * You may obtain a copy of the LGPL License at : <nl> + * <nl> + * http : / / www . gnu . org / licenses / licenses . html <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " LGPL2 . 1 " . <nl> + * <nl> + * You may obtain a copy of the Apache License at : <nl> + * <nl> + * http : / / www . apache . org / licenses / <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " AL2 . 0 " . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + import com . sun . jna . Library ; <nl> + import com . sun . jna . Native ; <nl> + import com . sun . jna . Pointer ; <nl> + <nl> + / * * <nl> + * Functions used with power management . <nl> + * / <nl> + public interface PowrProf extends Library { <nl> + PowrProf INSTANCE = Native . load ( " PowrProf " , PowrProf . class ) ; <nl> + <nl> + / * * <nl> + * Enum which indicates the power information level requested from <nl> + * { @ link # CallNtPowerInformation ( ) } . This value indicates the specific <nl> + * power information to be set or retrieved . <nl> + * / <nl> + public interface POWER _ INFORMATION _ LEVEL { <nl> + / * * <nl> + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the <nl> + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives a { @ link WinDef # ULONGLONG } <nl> + * that specifies the interrupt - time count , in 100 - nanosecond units , at <nl> + * the last system sleep time . <nl> + * / <nl> + int LastSleepTime = 15 ; <nl> + <nl> + / * * <nl> + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the <nl> + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives a { @ link WinDef # ULONGLONG } <nl> + * that specifies the interrupt - time count , in 100 - nanosecond units , at <nl> + * the last system wake time . <nl> + * / <nl> + int LastWakeTime = 14 ; <nl> + <nl> + / * * <nl> + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the <nl> + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives one <nl> + * { @ link WinNT # PROCESSOR _ POWER _ INFORMATION } structure for each <nl> + * processor that is installed on the system . Use the <nl> + * { @ link Kernel32 # GetSystemInfo ( ) } function to retrieve the number of <nl> + * processors , which will be the number of logical processors on the <nl> + * current Processor Group . <nl> + * / <nl> + int ProcessorInformation = 11 ; <nl> + <nl> + / * * <nl> + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the <nl> + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives a <nl> + * { @ link WinNT # SYSTEM _ BATTERY _ STATE } structure containing information <nl> + * about the current system battery . <nl> + * / <nl> + int SystemBatteryState = 5 ; <nl> + <nl> + / * * <nl> + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the <nl> + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives a { @ link WinDef # ULONG } <nl> + * value containing the system execution state buffer . This value may <nl> + * contain any combination of the following values : <nl> + * { @ link WinBase # ES _ SYSTEM _ REQUIRED } , <nl> + * { @ link WinBase # ES _ DISPLAY _ REQUIRED } , or <nl> + * { @ link WinBase # ES _ USER _ PRESENT } . For more information , see the <nl> + * { @ link { @ link Kernel32 # SetThreadExecutionState ( ) } function . <nl> + * / <nl> + int SystemExecutionState = 16 ; <nl> + <nl> + / * * <nl> + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the <nl> + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives a <nl> + * { @ link WinNT # SYSTEM _ POWER _ CAPABILITIES } structure containing the <nl> + * current system power capabilities . <nl> + * < p > <nl> + * This information represents the currently supported power <nl> + * capabilities . It may change as drivers are installed in the system . <nl> + * For example , installation of legacy device drivers that do not <nl> + * support power management disables all system sleep states . <nl> + * / <nl> + int SystemPowerCapabilities = 4 ; <nl> + <nl> + / * * <nl> + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the <nl> + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives a <nl> + * { @ link WinNT # SYSTEM _ POWER _ INFORMATION } structure . <nl> + * < p > <nl> + * Applications can use this level to retrieve information about the <nl> + * idleness of the system . <nl> + * / <nl> + int SystemPowerInformation = 12 ; <nl> + <nl> + / * * <nl> + * If { @ code lpInBuffer } is not { @ code NULL } , the function applies the <nl> + * { @ link WinNT # SYSTEM _ POWER _ POLICY } values passed in { @ code lpInBuffer } <nl> + * to the current system power policy used while the system is running <nl> + * on AC ( utility ) power . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives a <nl> + * { @ link WinNT # SYSTEM _ POWER _ POLICY } structure containing the current <nl> + * system power policy used while the system is running on AC ( utility ) <nl> + * power . <nl> + * / <nl> + int SystemPowerPolicyAc = 0 ; <nl> + <nl> + / * * <nl> + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the <nl> + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives a <nl> + * { @ link WinNT # SYSTEM _ POWER _ POLICY } structure containing the current <nl> + * system power policy used while the system is running on AC ( utility ) <nl> + * power . <nl> + * / <nl> + int SystemPowerPolicyCurrent = 8 ; <nl> + <nl> + / * * <nl> + * If { @ code lpInBuffer } is not { @ code NULL } , the function applies the <nl> + * { @ link WinNT # SYSTEM _ POWER _ POLICY } values passed in { @ code lpInBuffer } <nl> + * to the current system power policy used while the system is running <nl> + * on battery power . <nl> + * < p > <nl> + * The { @ code lpOutputBuffer } buffer receives a <nl> + * { @ link WinNT # SYSTEM _ POWER _ POLICY } structure containing the current <nl> + * system power policy used while the system is running on battery <nl> + * power . <nl> + * / <nl> + int SystemPowerPolicyDc = 1 ; <nl> + <nl> + / * * <nl> + * If { @ code lpInBuffer } is not { @ code NULL } and the current user has <nl> + * sufficient privileges , the function commits or decommits the storage <nl> + * required to hold the hibernation image on the boot volume . <nl> + * < p > <nl> + * The lpInBuffer parameter must point to a { @ code BOOLEAN } value <nl> + * indicating the desired request . If the value is { @ code TRUE } , the <nl> + * hibernation file is reserved ; if the value is { @ code FALSE } , the <nl> + * hibernation file is removed . <nl> + * / <nl> + int SystemReserveHiberFile = 10 ; <nl> + } <nl> + <nl> + / * * <nl> + * Sets or retrieves power information . <nl> + * < p > <nl> + * Changes made to the current system power policy using <nl> + * { @ link # CallNtPowerInformation ( ) } are immediate , but they are not <nl> + * persistent ; that is , the changes are not stored as part of a power <nl> + * scheme . Any changes to system power policy made with <nl> + * { @ link # CallNtPowerInformation ( ) } may be overwritten by changes to a <nl> + * policy scheme made by the user in the Power Options control panel <nl> + * program , or by subsequent calls to { @ code WritePwrScheme } , <nl> + * { @ code SetActivePwrScheme } , or other power scheme functions . <nl> + * <nl> + * @ param informationLevel <nl> + * The information level requested . This value indicates the <nl> + * specific power information to be set or retrieved . This <nl> + * parameter must be one of the following <nl> + * { @ link POWER _ INFORMATION _ LEVEL } enumeration type values : <nl> + * { @ link POWER _ INFORMATION _ LEVEL # LastSleepTime } , <nl> + * { @ link POWER _ INFORMATION _ LEVEL # LastWakeTime } , <nl> + * { @ link POWER _ INFORMATION _ LEVEL # ProcessorInformation } , <nl> + * { @ link POWER _ INFORMATION _ LEVEL # SystemBatteryState } , <nl> + * { @ link POWER _ INFORMATION _ LEVEL # SystemExecutionState } , <nl> + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerCapabilities } , <nl> + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerInformation } , <nl> + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerPolicyAc } , <nl> + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerPolicyCurrent } , <nl> + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerPolicyDc } , or <nl> + * { @ link POWER _ INFORMATION _ LEVEL # SystemReserveHiberFile } . <nl> + * @ param lpInputBuffer <nl> + * A pointer to an optional input buffer . The data type of this <nl> + * buffer depends on the information level requested in the <nl> + * { @ code informationLevel } parameter . <nl> + * @ param nInputBufferSize <nl> + * The size of the input buffer , in bytes . <nl> + * @ param lpOutputBuffer <nl> + * A pointer to an optional output buffer . The data type of this <nl> + * buffer depends on the information level requested in the <nl> + * { @ code informationLevel } parameter . If the buffer is too small <nl> + * to contain the information , the function returns <nl> + * { @ link NTStatus # STATUS _ BUFFER _ TOO _ SMALL } . <nl> + * @ param nOutputBufferSize <nl> + * The size of the output buffer , in bytes . Depending on the <nl> + * information level requested , this may be a variably sized <nl> + * buffer . <nl> + * @ return If the function succeeds , the return value is <nl> + * { @ link NTStatus # STATUS _ SUCCESS } . If the function fails , the <nl> + * return value can be one the following status codes : <nl> + * { @ link NTStatus # STATUS _ BUFFER _ TOO _ SMALL } if the output buffer is <nl> + * of insufficient size to contain the data to be returned . <nl> + * { @ link NTStatus # STATUS _ ACCESS _ DENIED } if the caller had <nl> + * insufficient access rights to perform the requested action . <nl> + * / <nl> + int CallNtPowerInformation ( int informationLevel , Pointer lpInputBuffer , int nInputBufferSize , <nl> + Pointer lpOutputBuffer , int nOutputBufferSize ) ; <nl> + } <nl> + <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> index ab129b5 . . 5c9bef8 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> @ @ - 3396 , 7 + 3396 , 257 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> } <nl> <nl> / * * <nl> - * Indicates committed pages for which physical storage has been allocated , either in memory or in the paging file on disk . <nl> + * Defines values that are used to specify system power action types . <nl> + * / <nl> + public interface POWER _ ACTION { <nl> + int PowerActionNone = 0 ; <nl> + int PowerActionReserved = 1 ; <nl> + int PowerActionSleep = 2 ; <nl> + int PowerActionHibernate = 3 ; <nl> + int PowerActionShutdown = 4 ; <nl> + int PowerActionShutdownReset = 5 ; <nl> + int PowerActionShutdownOff = 6 ; <nl> + int PowerActionWarmEject = 7 ; <nl> + int PowerActionDisplayOff = 8 ; <nl> + } <nl> + <nl> + / * * <nl> + * Defines values that are used to specify system power states . <nl> + * / <nl> + public interface SYSTEM _ POWER _ STATE { <nl> + int PowerSystemUnspecified = 0 ; <nl> + int PowerSystemWorking = 1 ; <nl> + int PowerSystemSleeping1 = 2 ; <nl> + int PowerSystemSleeping2 = 3 ; <nl> + int PowerSystemSleeping3 = 4 ; <nl> + int PowerSystemHibernate = 5 ; / / S4 <nl> + int PowerSystemShutdown = 6 ; / / S5 <nl> + int PowerSystemMaximum = 7 ; <nl> + } <nl> + <nl> + / * * <nl> + * Contains information about the current state of the system battery . <nl> + * / <nl> + @ FieldOrder ( { " AcOnLine " , " BatteryPresent " , " Charging " , " Discharging " , " Spare1 " , " Tag " , " MaxCapacity " , <nl> + " RemainingCapacity " , " Rate " , " EstimatedTime " , " DefaultAlert1 " , " DefaultAlert2 " } ) <nl> + class SYSTEM _ BATTERY _ STATE extends Structure { <nl> + public byte AcOnLine ; <nl> + public byte BatteryPresent ; <nl> + public byte Charging ; <nl> + public byte Discharging ; <nl> + public byte [ ] Spare1 = new byte [ 3 ] ; <nl> + public byte Tag ; <nl> + public int MaxCapacity ; <nl> + public int RemainingCapacity ; <nl> + public int Rate ; <nl> + public int EstimatedTime ; <nl> + public int DefaultAlert1 ; <nl> + public int DefaultAlert2 ; <nl> + <nl> + public SYSTEM _ BATTERY _ STATE ( Pointer p ) { <nl> + super ( p ) ; <nl> + read ( ) ; <nl> + } <nl> + <nl> + public SYSTEM _ BATTERY _ STATE ( ) { <nl> + super ( ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Contains the granularity of the battery capacity . <nl> + * / <nl> + @ FieldOrder ( { " Granularity " , " Capacity " } ) <nl> + class BATTERY _ REPORTING _ SCALE extends Structure { <nl> + public int Granularity ; <nl> + public int Capacity ; <nl> + } <nl> + <nl> + / * * <nl> + * Contains information about a processor . <nl> + * / <nl> + @ FieldOrder ( { " Number " , " MaxMhz " , " CurrentMhz " , " MhzLimit " , " MaxIdleState " , " CurrentIdleState " } ) <nl> + class PROCESSOR _ POWER _ INFORMATION extends Structure { <nl> + public int Number ; <nl> + public int MaxMhz ; <nl> + public int CurrentMhz ; <nl> + public int MhzLimit ; <nl> + public int MaxIdleState ; <nl> + public int CurrentIdleState ; <nl> + <nl> + public PROCESSOR _ POWER _ INFORMATION ( Pointer p ) { <nl> + super ( p ) ; <nl> + read ( ) ; <nl> + } <nl> + <nl> + public PROCESSOR _ POWER _ INFORMATION ( ) { <nl> + super ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Contains information about the idleness of the system . <nl> + * / <nl> + @ FieldOrder ( { " MaxIdlenessAllowed " , " Idleness " , " TimeRemaining " , " CoolingMode " } ) <nl> + class SYSTEM _ POWER _ INFORMATION extends Structure { <nl> + public int MaxIdlenessAllowed ; <nl> + public int Idleness ; <nl> + public int TimeRemaining ; <nl> + public byte CoolingMode ; <nl> + <nl> + public SYSTEM _ POWER _ INFORMATION ( Pointer p ) { <nl> + super ( p ) ; <nl> + read ( ) ; <nl> + } <nl> + <nl> + public SYSTEM _ POWER _ INFORMATION ( ) { <nl> + super ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Contains information used to set the system power state . <nl> + * / <nl> + @ FieldOrder ( { " Action " , " Flags " , " EventCode " } ) <nl> + class POWER _ ACTION _ POLICY extends Structure { <nl> + public int / * POWER _ ACTION * / Action ; <nl> + public int Flags ; <nl> + public int EventCode ; <nl> + } <nl> + <nl> + / * * <nl> + * Contains information about system battery drain policy settings . <nl> + * / <nl> + @ FieldOrder ( { " Enable " , " Spare " , " BatteryLevel " , " PowerPolicy " , " MinSystemState " } ) <nl> + class SYSTEM _ POWER _ LEVEL extends Structure { <nl> + public byte Enable ; <nl> + public byte [ ] Spare = new byte [ 3 ] ; <nl> + public int BatteryLevel ; <nl> + public POWER _ ACTION _ POLICY PowerPolicy ; <nl> + public int / * SYSTEM _ POWER _ STATE * / MinSystemState ; <nl> + } <nl> + <nl> + int NUM _ DISCHARGE _ POLICIES = 4 ; <nl> + <nl> + / * * <nl> + * Contains information about the current system power policy . <nl> + * / <nl> + @ FieldOrder ( { " Revision " , " PowerButton " , " SleepButton " , " LidClose " , " LidOpenWake " , " Reserved " , " Idle " , <nl> + " IdleTimeout " , " IdleSensitivity " , " DynamicThrottle " , " Spare2 " , " MinSleep " , " MaxSleep " , <nl> + " ReducedLatencySleep " , " WinLogonFlags " , " Spare3 " , " DozeS4Timeout " , " BroadcastCapacityResolution " , <nl> + " DischargePolicy " , " VideoTimeout " , " VideoDimDisplay " , " VideoReserved " , " SpindownTimeout " , <nl> + " OptimizeForPower " , " FanThrottleTolerance " , " ForcedThrottle " , " MinThrottle " , " OverThrottled " } ) <nl> + class SYSTEM _ POWER _ POLICY extends Structure { <nl> + public int Revision ; <nl> + public POWER _ ACTION _ POLICY PowerButton ; <nl> + public POWER _ ACTION _ POLICY SleepButton ; <nl> + public POWER _ ACTION _ POLICY LidClose ; <nl> + public int / * SYSTEM _ POWER _ STATE * / LidOpenWake ; <nl> + public int Reserved ; <nl> + public POWER _ ACTION _ POLICY Idle ; <nl> + public int IdleTimeout ; <nl> + public byte IdleSensitivity ; <nl> + public byte DynamicThrottle ; <nl> + public byte [ ] Spare2 = new byte [ 2 ] ; <nl> + public int / * SYSTEM _ POWER _ STATE * / MinSleep ; <nl> + public int / * SYSTEM _ POWER _ STATE * / MaxSleep ; <nl> + public int / * SYSTEM _ POWER _ STATE * / ReducedLatencySleep ; <nl> + public int WinLogonFlags ; <nl> + public int Spare3 ; <nl> + public int DozeS4Timeout ; <nl> + public int BroadcastCapacityResolution ; <nl> + public SYSTEM _ POWER _ LEVEL [ ] DischargePolicy = new SYSTEM _ POWER _ LEVEL [ NUM _ DISCHARGE _ POLICIES ] ; <nl> + public int VideoTimeout ; <nl> + public byte VideoDimDisplay ; <nl> + public int [ ] VideoReserved = new int [ 3 ] ; <nl> + public int SpindownTimeout ; <nl> + public byte OptimizeForPower ; <nl> + public byte FanThrottleTolerance ; <nl> + public byte ForcedThrottle ; <nl> + public byte MinThrottle ; <nl> + public POWER _ ACTION _ POLICY OverThrottled ; <nl> + <nl> + public SYSTEM _ POWER _ POLICY ( Pointer p ) { <nl> + super ( p ) ; <nl> + read ( ) ; <nl> + } <nl> + <nl> + public SYSTEM _ POWER _ POLICY ( ) { <nl> + super ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Contains information about the power capabilities of the system . <nl> + * / <nl> + @ FieldOrder ( { " PowerButtonPresent " , " SleepButtonPresent " , " LidPresent " , " SystemS1 " , " SystemS2 " , " SystemS3 " , <nl> + " SystemS4 " , " SystemS5 " , " HiberFilePresent " , " FullWake " , " VideoDimPresent " , " ApmPresent " , " UpsPresent " , <nl> + " ThermalControl " , " ProcessorThrottle " , " ProcessorMinThrottle " , " ProcessorMaxThrottle " , " FastSystemS4 " , <nl> + " Hiberboot " , " WakeAlarmPresent " , " AoAc " , " DiskSpinDown " , " HiberFileType " , " AoAcConnectivitySupported " , <nl> + " spare3 " , " SystemBatteriesPresent " , " BatteriesAreShortTerm " , " BatteryScale " , " AcOnLineWake " , " SoftLidWake " , <nl> + " RtcWake " , " MinDeviceWakeState " , " DefaultLowLatencyWake " } ) <nl> + class SYSTEM _ POWER _ CAPABILITIES extends Structure { <nl> + / / Misc supported system features <nl> + public byte PowerButtonPresent ; <nl> + public byte SleepButtonPresent ; <nl> + public byte LidPresent ; <nl> + public byte SystemS1 ; <nl> + public byte SystemS2 ; <nl> + public byte SystemS3 ; <nl> + public byte SystemS4 ; / / hibernate <nl> + public byte SystemS5 ; / / off <nl> + public byte HiberFilePresent ; <nl> + public byte FullWake ; <nl> + public byte VideoDimPresent ; <nl> + public byte ApmPresent ; <nl> + public byte UpsPresent ; <nl> + <nl> + / / Processors <nl> + public byte ThermalControl ; <nl> + public byte ProcessorThrottle ; <nl> + public byte ProcessorMinThrottle ; <nl> + <nl> + / / Prior to WinXP , next 5 bytes are ProcessorThrottleScale <nl> + / / followed by 4 spare bytes <nl> + public byte ProcessorMaxThrottle ; <nl> + public byte FastSystemS4 ; <nl> + public byte Hiberboot ; <nl> + public byte WakeAlarmPresent ; <nl> + public byte AoAc ; <nl> + <nl> + / / Disk <nl> + public byte DiskSpinDown ; <nl> + <nl> + / / HiberFile ( Pre - Win10 next 2 bytes are spare ) <nl> + public byte HiberFileType ; <nl> + public byte AoAcConnectivitySupported ; <nl> + public byte [ ] spare3 = new byte [ 6 ] ; <nl> + <nl> + / / System Battery <nl> + public byte SystemBatteriesPresent ; <nl> + public byte BatteriesAreShortTerm ; <nl> + public BATTERY _ REPORTING _ SCALE [ ] BatteryScale = new BATTERY _ REPORTING _ SCALE [ 3 ] ; <nl> + <nl> + / / Wake <nl> + public int / * SYSTEM _ POWER _ STATE * / AcOnLineWake ; <nl> + public int / * SYSTEM _ POWER _ STATE * / SoftLidWake ; <nl> + public int / * SYSTEM _ POWER _ STATE * / RtcWake ; <nl> + public int / * SYSTEM _ POWER _ STATE * / MinDeviceWakeState ; <nl> + public int / * SYSTEM _ POWER _ STATE * / DefaultLowLatencyWake ; <nl> + <nl> + public SYSTEM _ POWER _ CAPABILITIES ( Pointer p ) { <nl> + super ( p ) ; <nl> + read ( ) ; <nl> + } <nl> + <nl> + public SYSTEM _ POWER _ CAPABILITIES ( ) { <nl> + super ( ) ; <nl> + } <nl> + } <nl> + / * * <nl> + * Indicates committed pages for which physical storage has been allocated , <nl> + * either in memory or in the paging file on disk . <nl> * / <nl> int MEM _ COMMIT = 0x1000 ; <nl> <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / PowrProfTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / PowrProfTest . java <nl> new file mode 100644 <nl> index 0000000 . . 6c3b6f3 <nl> - - - / dev / null <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / PowrProfTest . java <nl> @ @ - 0 , 0 + 1 , 118 @ @ <nl> + / * Copyright ( c ) 2019 Daniel Widdis , All Rights Reserved <nl> + * <nl> + * The contents of this file is dual - licensed under 2 <nl> + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and <nl> + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . <nl> + * <nl> + * You can freely decide which license you want to apply to <nl> + * the project . <nl> + * <nl> + * You may obtain a copy of the LGPL License at : <nl> + * <nl> + * http : / / www . gnu . org / licenses / licenses . html <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " LGPL2 . 1 " . <nl> + * <nl> + * You may obtain a copy of the Apache License at : <nl> + * <nl> + * http : / / www . apache . org / licenses / <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " AL2 . 0 " . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + import com . sun . jna . Memory ; <nl> + import com . sun . jna . platform . win32 . PowrProf . POWER _ INFORMATION _ LEVEL ; <nl> + import com . sun . jna . platform . win32 . WinBase . SYSTEM _ INFO ; <nl> + import com . sun . jna . platform . win32 . WinNT . POWER _ ACTION ; <nl> + import com . sun . jna . platform . win32 . WinNT . PROCESSOR _ POWER _ INFORMATION ; <nl> + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ BATTERY _ STATE ; <nl> + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ POWER _ CAPABILITIES ; <nl> + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ POWER _ INFORMATION ; <nl> + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ POWER _ POLICY ; <nl> + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ POWER _ STATE ; <nl> + <nl> + import junit . framework . TestCase ; <nl> + <nl> + public class PowrProfTest extends TestCase { <nl> + <nl> + public void testProcessorPowerInformation ( ) { <nl> + / / MSDN docs for CallNTPowerInformation specify use of GetSystemInfo to <nl> + / / count logical processors for this InformationLevel . The GetSystemInfo <nl> + / / function and this function only count logical processors on the <nl> + / / current Processor Group , so the array will never have more than 64 <nl> + / / elements <nl> + SYSTEM _ INFO info = new SYSTEM _ INFO ( ) ; <nl> + Kernel32 . INSTANCE . GetSystemInfo ( info ) ; <nl> + int numProcs = info . dwNumberOfProcessors . intValue ( ) ; <nl> + <nl> + / / Try with too small buffer <nl> + int bufferSize = 1 ; <nl> + Memory mem = new Memory ( bufferSize ) ; <nl> + assertEquals ( NTStatus . STATUS _ BUFFER _ TOO _ SMALL , PowrProf . INSTANCE <nl> + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . ProcessorInformation , null , 0 , mem , bufferSize ) ) ; <nl> + <nl> + PROCESSOR _ POWER _ INFORMATION ppi = new PROCESSOR _ POWER _ INFORMATION ( ) ; <nl> + bufferSize = ppi . size ( ) * numProcs ; <nl> + mem = new Memory ( bufferSize ) ; <nl> + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE <nl> + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . ProcessorInformation , null , 0 , mem , bufferSize ) ) ; <nl> + <nl> + long [ ] freqs = new long [ numProcs ] ; <nl> + for ( int i = 0 ; i < freqs . length ; i + + ) { <nl> + ppi = new PROCESSOR _ POWER _ INFORMATION ( mem . share ( i * ( long ) ppi . size ( ) ) ) ; <nl> + assertTrue ( ppi . CurrentMhz < = ppi . MaxMhz ) ; <nl> + } <nl> + } <nl> + <nl> + public void testSystemBatteryStateAndPowerCapabilities ( ) { <nl> + int size = new SYSTEM _ BATTERY _ STATE ( ) . size ( ) ; <nl> + Memory mem = new Memory ( size ) ; <nl> + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE <nl> + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . SystemBatteryState , null , 0 , mem , size ) ) ; <nl> + SYSTEM _ BATTERY _ STATE batteryState = new SYSTEM _ BATTERY _ STATE ( mem ) ; <nl> + if ( batteryState . BatteryPresent > 0 ) { <nl> + if ( batteryState . AcOnLine = = 0 & & batteryState . Charging = = 0 & & batteryState . Discharging > 0 ) { <nl> + assertTrue ( batteryState . EstimatedTime > = 0 ) ; <nl> + } <nl> + assertTrue ( batteryState . RemainingCapacity < = batteryState . MaxCapacity ) ; <nl> + } <nl> + <nl> + size = new SYSTEM _ POWER _ CAPABILITIES ( ) . size ( ) ; <nl> + mem = new Memory ( size ) ; <nl> + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE <nl> + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . SystemPowerCapabilities , null , 0 , mem , size ) ) ; <nl> + SYSTEM _ POWER _ CAPABILITIES powerCapabilities = new SYSTEM _ POWER _ CAPABILITIES ( <nl> + mem ) ; <nl> + assertEquals ( powerCapabilities . SystemBatteriesPresent > 0 , batteryState . BatteryPresent > 0 ) ; <nl> + } <nl> + <nl> + public void testSystemPowerInformation ( ) { <nl> + int size = new SYSTEM _ POWER _ INFORMATION ( ) . size ( ) ; <nl> + Memory mem = new Memory ( size ) ; <nl> + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE <nl> + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . SystemPowerInformation , null , 0 , mem , size ) ) ; <nl> + SYSTEM _ POWER _ INFORMATION powerInfo = new SYSTEM _ POWER _ INFORMATION ( mem ) ; <nl> + assertTrue ( powerInfo . MaxIdlenessAllowed < = 100 ) ; <nl> + assertTrue ( powerInfo . Idleness < = 100 ) ; <nl> + assertTrue ( powerInfo . CoolingMode > = 0 ) ; / / must be 0 , 1 , 2 <nl> + assertTrue ( powerInfo . CoolingMode < = 2 ) ; <nl> + } <nl> + <nl> + public void testSystemPowerPolicy ( ) { <nl> + int size = new SYSTEM _ POWER _ POLICY ( ) . size ( ) ; <nl> + Memory mem = new Memory ( size ) ; <nl> + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE <nl> + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . SystemPowerPolicyCurrent , null , 0 , mem , size ) ) ; <nl> + SYSTEM _ POWER _ POLICY powerPolicy = new SYSTEM _ POWER _ POLICY ( mem ) ; <nl> + <nl> + / / Test selected elements including nested structures <nl> + assertTrue ( powerPolicy . PowerButton . Action > = 0 ) ; <nl> + assertTrue ( powerPolicy . PowerButton . Action < = POWER _ ACTION . PowerActionDisplayOff ) ; / / Max <nl> + assertTrue ( powerPolicy . MinSleep < = powerPolicy . MaxSleep ) ; <nl> + assertTrue ( powerPolicy . MaxSleep < = SYSTEM _ POWER _ STATE . PowerSystemMaximum ) ; <nl> + assertTrue ( powerPolicy . DischargePolicy [ 0 ] . BatteryLevel < = 100 ) ; / / percentage <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 4ad228d . . f5b209d 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 11 , 6 + 11 , 7 @ @ Features 
 * [ # 1050 ] ( https : / / github . com / java - native - access / jna / pull / 1050 ) : Add ` c . s . j . p . win32 . VersionHelpers ` and supporting functions - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 * [ # 1061 ] ( https : / / github . com / java - native - access / jna / pull / 1061 ) : replace toArray ( new T [ size ] ) with toArray ( new T [ 0 ] ) for better performance - [ @ hc - codersatlas ] ( https : / / github . com / hc - codersatlas ) . 
 * [ # 1064 ] ( https : / / github . com / java - native - access / jna / pull / 1064 ) : Add ` c . s . j . p . win32 . Kernel32 . GetLogicalProcessorInformationEx ` function , convenience Util method and supporting structures - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 + * [ # 1065 ] ( https : / / github . com / java - native - access / jna / pull / 1065 ) : Add ` c . s . j . p . win32 . PowrProf # CallNTPowerInformation ` and supporting structures - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / NTStatus . java b / contrib / platform / src / com / sun / jna / platform / win32 / NTStatus . java 
 index 3711179 . . dac8962 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / NTStatus . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / NTStatus . java 
 @ @ - 105 , 5 + 105 , 14 @ @ public interface NTStatus { 
 / / Indicates a particular Security ID may not be assigned as the owner of an object . 
 / / 
 int STATUS _ INVALID _ OWNER = 0xC000005A ; 
 + 
 + / / MessageId : STATUS _ ACCESS _ DENIED 
 + / / 
 + / / MessageText : 
 + / / 
 + / / A process has requested access to an object , but has not been granted 
 + / / those access rights . 
 + / / 
 + int STATUS _ ACCESS _ DENIED = 0xC0000022 ; 
 } 
 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / PowrProf . java b / contrib / platform / src / com / sun / jna / platform / win32 / PowrProf . java 
 new file mode 100644 
 index 0000000 . . 46f6ace 
 - - - / dev / null 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / PowrProf . java 
 @ @ - 0 , 0 + 1 , 231 @ @ 
 + / * Copyright ( c ) 2019 Daniel Widdis , All Rights Reserved 
 + * 
 + * The contents of this file is dual - licensed under 2 
 + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and 
 + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . 
 + * 
 + * You can freely decide which license you want to apply to 
 + * the project . 
 + * 
 + * You may obtain a copy of the LGPL License at : 
 + * 
 + * http : / / www . gnu . org / licenses / licenses . html 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " LGPL2 . 1 " . 
 + * 
 + * You may obtain a copy of the Apache License at : 
 + * 
 + * http : / / www . apache . org / licenses / 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " AL2 . 0 " . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + import com . sun . jna . Library ; 
 + import com . sun . jna . Native ; 
 + import com . sun . jna . Pointer ; 
 + 
 + / * * 
 + * Functions used with power management . 
 + * / 
 + public interface PowrProf extends Library { 
 + PowrProf INSTANCE = Native . load ( " PowrProf " , PowrProf . class ) ; 
 + 
 + / * * 
 + * Enum which indicates the power information level requested from 
 + * { @ link # CallNtPowerInformation ( ) } . This value indicates the specific 
 + * power information to be set or retrieved . 
 + * / 
 + public interface POWER _ INFORMATION _ LEVEL { 
 + / * * 
 + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the 
 + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives a { @ link WinDef # ULONGLONG } 
 + * that specifies the interrupt - time count , in 100 - nanosecond units , at 
 + * the last system sleep time . 
 + * / 
 + int LastSleepTime = 15 ; 
 + 
 + / * * 
 + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the 
 + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives a { @ link WinDef # ULONGLONG } 
 + * that specifies the interrupt - time count , in 100 - nanosecond units , at 
 + * the last system wake time . 
 + * / 
 + int LastWakeTime = 14 ; 
 + 
 + / * * 
 + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the 
 + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives one 
 + * { @ link WinNT # PROCESSOR _ POWER _ INFORMATION } structure for each 
 + * processor that is installed on the system . Use the 
 + * { @ link Kernel32 # GetSystemInfo ( ) } function to retrieve the number of 
 + * processors , which will be the number of logical processors on the 
 + * current Processor Group . 
 + * / 
 + int ProcessorInformation = 11 ; 
 + 
 + / * * 
 + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the 
 + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives a 
 + * { @ link WinNT # SYSTEM _ BATTERY _ STATE } structure containing information 
 + * about the current system battery . 
 + * / 
 + int SystemBatteryState = 5 ; 
 + 
 + / * * 
 + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the 
 + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives a { @ link WinDef # ULONG } 
 + * value containing the system execution state buffer . This value may 
 + * contain any combination of the following values : 
 + * { @ link WinBase # ES _ SYSTEM _ REQUIRED } , 
 + * { @ link WinBase # ES _ DISPLAY _ REQUIRED } , or 
 + * { @ link WinBase # ES _ USER _ PRESENT } . For more information , see the 
 + * { @ link { @ link Kernel32 # SetThreadExecutionState ( ) } function . 
 + * / 
 + int SystemExecutionState = 16 ; 
 + 
 + / * * 
 + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the 
 + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives a 
 + * { @ link WinNT # SYSTEM _ POWER _ CAPABILITIES } structure containing the 
 + * current system power capabilities . 
 + * < p > 
 + * This information represents the currently supported power 
 + * capabilities . It may change as drivers are installed in the system . 
 + * For example , installation of legacy device drivers that do not 
 + * support power management disables all system sleep states . 
 + * / 
 + int SystemPowerCapabilities = 4 ; 
 + 
 + / * * 
 + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the 
 + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives a 
 + * { @ link WinNT # SYSTEM _ POWER _ INFORMATION } structure . 
 + * < p > 
 + * Applications can use this level to retrieve information about the 
 + * idleness of the system . 
 + * / 
 + int SystemPowerInformation = 12 ; 
 + 
 + / * * 
 + * If { @ code lpInBuffer } is not { @ code NULL } , the function applies the 
 + * { @ link WinNT # SYSTEM _ POWER _ POLICY } values passed in { @ code lpInBuffer } 
 + * to the current system power policy used while the system is running 
 + * on AC ( utility ) power . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives a 
 + * { @ link WinNT # SYSTEM _ POWER _ POLICY } structure containing the current 
 + * system power policy used while the system is running on AC ( utility ) 
 + * power . 
 + * / 
 + int SystemPowerPolicyAc = 0 ; 
 + 
 + / * * 
 + * The { @ code lpInBuffer } parameter must be { @ code NULL } ; otherwise , the 
 + * function returns { @ link WinError # ERROR _ INVALID _ PARAMETER } . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives a 
 + * { @ link WinNT # SYSTEM _ POWER _ POLICY } structure containing the current 
 + * system power policy used while the system is running on AC ( utility ) 
 + * power . 
 + * / 
 + int SystemPowerPolicyCurrent = 8 ; 
 + 
 + / * * 
 + * If { @ code lpInBuffer } is not { @ code NULL } , the function applies the 
 + * { @ link WinNT # SYSTEM _ POWER _ POLICY } values passed in { @ code lpInBuffer } 
 + * to the current system power policy used while the system is running 
 + * on battery power . 
 + * < p > 
 + * The { @ code lpOutputBuffer } buffer receives a 
 + * { @ link WinNT # SYSTEM _ POWER _ POLICY } structure containing the current 
 + * system power policy used while the system is running on battery 
 + * power . 
 + * / 
 + int SystemPowerPolicyDc = 1 ; 
 + 
 + / * * 
 + * If { @ code lpInBuffer } is not { @ code NULL } and the current user has 
 + * sufficient privileges , the function commits or decommits the storage 
 + * required to hold the hibernation image on the boot volume . 
 + * < p > 
 + * The lpInBuffer parameter must point to a { @ code BOOLEAN } value 
 + * indicating the desired request . If the value is { @ code TRUE } , the 
 + * hibernation file is reserved ; if the value is { @ code FALSE } , the 
 + * hibernation file is removed . 
 + * / 
 + int SystemReserveHiberFile = 10 ; 
 + } 
 + 
 + / * * 
 + * Sets or retrieves power information . 
 + * < p > 
 + * Changes made to the current system power policy using 
 + * { @ link # CallNtPowerInformation ( ) } are immediate , but they are not 
 + * persistent ; that is , the changes are not stored as part of a power 
 + * scheme . Any changes to system power policy made with 
 + * { @ link # CallNtPowerInformation ( ) } may be overwritten by changes to a 
 + * policy scheme made by the user in the Power Options control panel 
 + * program , or by subsequent calls to { @ code WritePwrScheme } , 
 + * { @ code SetActivePwrScheme } , or other power scheme functions . 
 + * 
 + * @ param informationLevel 
 + * The information level requested . This value indicates the 
 + * specific power information to be set or retrieved . This 
 + * parameter must be one of the following 
 + * { @ link POWER _ INFORMATION _ LEVEL } enumeration type values : 
 + * { @ link POWER _ INFORMATION _ LEVEL # LastSleepTime } , 
 + * { @ link POWER _ INFORMATION _ LEVEL # LastWakeTime } , 
 + * { @ link POWER _ INFORMATION _ LEVEL # ProcessorInformation } , 
 + * { @ link POWER _ INFORMATION _ LEVEL # SystemBatteryState } , 
 + * { @ link POWER _ INFORMATION _ LEVEL # SystemExecutionState } , 
 + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerCapabilities } , 
 + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerInformation } , 
 + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerPolicyAc } , 
 + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerPolicyCurrent } , 
 + * { @ link POWER _ INFORMATION _ LEVEL # SystemPowerPolicyDc } , or 
 + * { @ link POWER _ INFORMATION _ LEVEL # SystemReserveHiberFile } . 
 + * @ param lpInputBuffer 
 + * A pointer to an optional input buffer . The data type of this 
 + * buffer depends on the information level requested in the 
 + * { @ code informationLevel } parameter . 
 + * @ param nInputBufferSize 
 + * The size of the input buffer , in bytes . 
 + * @ param lpOutputBuffer 
 + * A pointer to an optional output buffer . The data type of this 
 + * buffer depends on the information level requested in the 
 + * { @ code informationLevel } parameter . If the buffer is too small 
 + * to contain the information , the function returns 
 + * { @ link NTStatus # STATUS _ BUFFER _ TOO _ SMALL } . 
 + * @ param nOutputBufferSize 
 + * The size of the output buffer , in bytes . Depending on the 
 + * information level requested , this may be a variably sized 
 + * buffer . 
 + * @ return If the function succeeds , the return value is 
 + * { @ link NTStatus # STATUS _ SUCCESS } . If the function fails , the 
 + * return value can be one the following status codes : 
 + * { @ link NTStatus # STATUS _ BUFFER _ TOO _ SMALL } if the output buffer is 
 + * of insufficient size to contain the data to be returned . 
 + * { @ link NTStatus # STATUS _ ACCESS _ DENIED } if the caller had 
 + * insufficient access rights to perform the requested action . 
 + * / 
 + int CallNtPowerInformation ( int informationLevel , Pointer lpInputBuffer , int nInputBufferSize , 
 + Pointer lpOutputBuffer , int nOutputBufferSize ) ; 
 + } 
 + 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 index ab129b5 . . 5c9bef8 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 @ @ - 3396 , 7 + 3396 , 257 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 } 
 
 / * * 
 - * Indicates committed pages for which physical storage has been allocated , either in memory or in the paging file on disk . 
 + * Defines values that are used to specify system power action types . 
 + * / 
 + public interface POWER _ ACTION { 
 + int PowerActionNone = 0 ; 
 + int PowerActionReserved = 1 ; 
 + int PowerActionSleep = 2 ; 
 + int PowerActionHibernate = 3 ; 
 + int PowerActionShutdown = 4 ; 
 + int PowerActionShutdownReset = 5 ; 
 + int PowerActionShutdownOff = 6 ; 
 + int PowerActionWarmEject = 7 ; 
 + int PowerActionDisplayOff = 8 ; 
 + } 
 + 
 + / * * 
 + * Defines values that are used to specify system power states . 
 + * / 
 + public interface SYSTEM _ POWER _ STATE { 
 + int PowerSystemUnspecified = 0 ; 
 + int PowerSystemWorking = 1 ; 
 + int PowerSystemSleeping1 = 2 ; 
 + int PowerSystemSleeping2 = 3 ; 
 + int PowerSystemSleeping3 = 4 ; 
 + int PowerSystemHibernate = 5 ; / / S4 
 + int PowerSystemShutdown = 6 ; / / S5 
 + int PowerSystemMaximum = 7 ; 
 + } 
 + 
 + / * * 
 + * Contains information about the current state of the system battery . 
 + * / 
 + @ FieldOrder ( { " AcOnLine " , " BatteryPresent " , " Charging " , " Discharging " , " Spare1 " , " Tag " , " MaxCapacity " , 
 + " RemainingCapacity " , " Rate " , " EstimatedTime " , " DefaultAlert1 " , " DefaultAlert2 " } ) 
 + class SYSTEM _ BATTERY _ STATE extends Structure { 
 + public byte AcOnLine ; 
 + public byte BatteryPresent ; 
 + public byte Charging ; 
 + public byte Discharging ; 
 + public byte [ ] Spare1 = new byte [ 3 ] ; 
 + public byte Tag ; 
 + public int MaxCapacity ; 
 + public int RemainingCapacity ; 
 + public int Rate ; 
 + public int EstimatedTime ; 
 + public int DefaultAlert1 ; 
 + public int DefaultAlert2 ; 
 + 
 + public SYSTEM _ BATTERY _ STATE ( Pointer p ) { 
 + super ( p ) ; 
 + read ( ) ; 
 + } 
 + 
 + public SYSTEM _ BATTERY _ STATE ( ) { 
 + super ( ) ; 
 + } 
 + } 
 + 
 + 
 + / * * 
 + * Contains the granularity of the battery capacity . 
 + * / 
 + @ FieldOrder ( { " Granularity " , " Capacity " } ) 
 + class BATTERY _ REPORTING _ SCALE extends Structure { 
 + public int Granularity ; 
 + public int Capacity ; 
 + } 
 + 
 + / * * 
 + * Contains information about a processor . 
 + * / 
 + @ FieldOrder ( { " Number " , " MaxMhz " , " CurrentMhz " , " MhzLimit " , " MaxIdleState " , " CurrentIdleState " } ) 
 + class PROCESSOR _ POWER _ INFORMATION extends Structure { 
 + public int Number ; 
 + public int MaxMhz ; 
 + public int CurrentMhz ; 
 + public int MhzLimit ; 
 + public int MaxIdleState ; 
 + public int CurrentIdleState ; 
 + 
 + public PROCESSOR _ POWER _ INFORMATION ( Pointer p ) { 
 + super ( p ) ; 
 + read ( ) ; 
 + } 
 + 
 + public PROCESSOR _ POWER _ INFORMATION ( ) { 
 + super ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Contains information about the idleness of the system . 
 + * / 
 + @ FieldOrder ( { " MaxIdlenessAllowed " , " Idleness " , " TimeRemaining " , " CoolingMode " } ) 
 + class SYSTEM _ POWER _ INFORMATION extends Structure { 
 + public int MaxIdlenessAllowed ; 
 + public int Idleness ; 
 + public int TimeRemaining ; 
 + public byte CoolingMode ; 
 + 
 + public SYSTEM _ POWER _ INFORMATION ( Pointer p ) { 
 + super ( p ) ; 
 + read ( ) ; 
 + } 
 + 
 + public SYSTEM _ POWER _ INFORMATION ( ) { 
 + super ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Contains information used to set the system power state . 
 + * / 
 + @ FieldOrder ( { " Action " , " Flags " , " EventCode " } ) 
 + class POWER _ ACTION _ POLICY extends Structure { 
 + public int / * POWER _ ACTION * / Action ; 
 + public int Flags ; 
 + public int EventCode ; 
 + } 
 + 
 + / * * 
 + * Contains information about system battery drain policy settings . 
 + * / 
 + @ FieldOrder ( { " Enable " , " Spare " , " BatteryLevel " , " PowerPolicy " , " MinSystemState " } ) 
 + class SYSTEM _ POWER _ LEVEL extends Structure { 
 + public byte Enable ; 
 + public byte [ ] Spare = new byte [ 3 ] ; 
 + public int BatteryLevel ; 
 + public POWER _ ACTION _ POLICY PowerPolicy ; 
 + public int / * SYSTEM _ POWER _ STATE * / MinSystemState ; 
 + } 
 + 
 + int NUM _ DISCHARGE _ POLICIES = 4 ; 
 + 
 + / * * 
 + * Contains information about the current system power policy . 
 + * / 
 + @ FieldOrder ( { " Revision " , " PowerButton " , " SleepButton " , " LidClose " , " LidOpenWake " , " Reserved " , " Idle " , 
 + " IdleTimeout " , " IdleSensitivity " , " DynamicThrottle " , " Spare2 " , " MinSleep " , " MaxSleep " , 
 + " ReducedLatencySleep " , " WinLogonFlags " , " Spare3 " , " DozeS4Timeout " , " BroadcastCapacityResolution " , 
 + " DischargePolicy " , " VideoTimeout " , " VideoDimDisplay " , " VideoReserved " , " SpindownTimeout " , 
 + " OptimizeForPower " , " FanThrottleTolerance " , " ForcedThrottle " , " MinThrottle " , " OverThrottled " } ) 
 + class SYSTEM _ POWER _ POLICY extends Structure { 
 + public int Revision ; 
 + public POWER _ ACTION _ POLICY PowerButton ; 
 + public POWER _ ACTION _ POLICY SleepButton ; 
 + public POWER _ ACTION _ POLICY LidClose ; 
 + public int / * SYSTEM _ POWER _ STATE * / LidOpenWake ; 
 + public int Reserved ; 
 + public POWER _ ACTION _ POLICY Idle ; 
 + public int IdleTimeout ; 
 + public byte IdleSensitivity ; 
 + public byte DynamicThrottle ; 
 + public byte [ ] Spare2 = new byte [ 2 ] ; 
 + public int / * SYSTEM _ POWER _ STATE * / MinSleep ; 
 + public int / * SYSTEM _ POWER _ STATE * / MaxSleep ; 
 + public int / * SYSTEM _ POWER _ STATE * / ReducedLatencySleep ; 
 + public int WinLogonFlags ; 
 + public int Spare3 ; 
 + public int DozeS4Timeout ; 
 + public int BroadcastCapacityResolution ; 
 + public SYSTEM _ POWER _ LEVEL [ ] DischargePolicy = new SYSTEM _ POWER _ LEVEL [ NUM _ DISCHARGE _ POLICIES ] ; 
 + public int VideoTimeout ; 
 + public byte VideoDimDisplay ; 
 + public int [ ] VideoReserved = new int [ 3 ] ; 
 + public int SpindownTimeout ; 
 + public byte OptimizeForPower ; 
 + public byte FanThrottleTolerance ; 
 + public byte ForcedThrottle ; 
 + public byte MinThrottle ; 
 + public POWER _ ACTION _ POLICY OverThrottled ; 
 + 
 + public SYSTEM _ POWER _ POLICY ( Pointer p ) { 
 + super ( p ) ; 
 + read ( ) ; 
 + } 
 + 
 + public SYSTEM _ POWER _ POLICY ( ) { 
 + super ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Contains information about the power capabilities of the system . 
 + * / 
 + @ FieldOrder ( { " PowerButtonPresent " , " SleepButtonPresent " , " LidPresent " , " SystemS1 " , " SystemS2 " , " SystemS3 " , 
 + " SystemS4 " , " SystemS5 " , " HiberFilePresent " , " FullWake " , " VideoDimPresent " , " ApmPresent " , " UpsPresent " , 
 + " ThermalControl " , " ProcessorThrottle " , " ProcessorMinThrottle " , " ProcessorMaxThrottle " , " FastSystemS4 " , 
 + " Hiberboot " , " WakeAlarmPresent " , " AoAc " , " DiskSpinDown " , " HiberFileType " , " AoAcConnectivitySupported " , 
 + " spare3 " , " SystemBatteriesPresent " , " BatteriesAreShortTerm " , " BatteryScale " , " AcOnLineWake " , " SoftLidWake " , 
 + " RtcWake " , " MinDeviceWakeState " , " DefaultLowLatencyWake " } ) 
 + class SYSTEM _ POWER _ CAPABILITIES extends Structure { 
 + / / Misc supported system features 
 + public byte PowerButtonPresent ; 
 + public byte SleepButtonPresent ; 
 + public byte LidPresent ; 
 + public byte SystemS1 ; 
 + public byte SystemS2 ; 
 + public byte SystemS3 ; 
 + public byte SystemS4 ; / / hibernate 
 + public byte SystemS5 ; / / off 
 + public byte HiberFilePresent ; 
 + public byte FullWake ; 
 + public byte VideoDimPresent ; 
 + public byte ApmPresent ; 
 + public byte UpsPresent ; 
 + 
 + / / Processors 
 + public byte ThermalControl ; 
 + public byte ProcessorThrottle ; 
 + public byte ProcessorMinThrottle ; 
 + 
 + / / Prior to WinXP , next 5 bytes are ProcessorThrottleScale 
 + / / followed by 4 spare bytes 
 + public byte ProcessorMaxThrottle ; 
 + public byte FastSystemS4 ; 
 + public byte Hiberboot ; 
 + public byte WakeAlarmPresent ; 
 + public byte AoAc ; 
 + 
 + / / Disk 
 + public byte DiskSpinDown ; 
 + 
 + / / HiberFile ( Pre - Win10 next 2 bytes are spare ) 
 + public byte HiberFileType ; 
 + public byte AoAcConnectivitySupported ; 
 + public byte [ ] spare3 = new byte [ 6 ] ; 
 + 
 + / / System Battery 
 + public byte SystemBatteriesPresent ; 
 + public byte BatteriesAreShortTerm ; 
 + public BATTERY _ REPORTING _ SCALE [ ] BatteryScale = new BATTERY _ REPORTING _ SCALE [ 3 ] ; 
 + 
 + / / Wake 
 + public int / * SYSTEM _ POWER _ STATE * / AcOnLineWake ; 
 + public int / * SYSTEM _ POWER _ STATE * / SoftLidWake ; 
 + public int / * SYSTEM _ POWER _ STATE * / RtcWake ; 
 + public int / * SYSTEM _ POWER _ STATE * / MinDeviceWakeState ; 
 + public int / * SYSTEM _ POWER _ STATE * / DefaultLowLatencyWake ; 
 + 
 + public SYSTEM _ POWER _ CAPABILITIES ( Pointer p ) { 
 + super ( p ) ; 
 + read ( ) ; 
 + } 
 + 
 + public SYSTEM _ POWER _ CAPABILITIES ( ) { 
 + super ( ) ; 
 + } 
 + } 
 + / * * 
 + * Indicates committed pages for which physical storage has been allocated , 
 + * either in memory or in the paging file on disk . 
 * / 
 int MEM _ COMMIT = 0x1000 ; 
 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / PowrProfTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / PowrProfTest . java 
 new file mode 100644 
 index 0000000 . . 6c3b6f3 
 - - - / dev / null 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / PowrProfTest . java 
 @ @ - 0 , 0 + 1 , 118 @ @ 
 + / * Copyright ( c ) 2019 Daniel Widdis , All Rights Reserved 
 + * 
 + * The contents of this file is dual - licensed under 2 
 + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and 
 + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . 
 + * 
 + * You can freely decide which license you want to apply to 
 + * the project . 
 + * 
 + * You may obtain a copy of the LGPL License at : 
 + * 
 + * http : / / www . gnu . org / licenses / licenses . html 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " LGPL2 . 1 " . 
 + * 
 + * You may obtain a copy of the Apache License at : 
 + * 
 + * http : / / www . apache . org / licenses / 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " AL2 . 0 " . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + import com . sun . jna . Memory ; 
 + import com . sun . jna . platform . win32 . PowrProf . POWER _ INFORMATION _ LEVEL ; 
 + import com . sun . jna . platform . win32 . WinBase . SYSTEM _ INFO ; 
 + import com . sun . jna . platform . win32 . WinNT . POWER _ ACTION ; 
 + import com . sun . jna . platform . win32 . WinNT . PROCESSOR _ POWER _ INFORMATION ; 
 + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ BATTERY _ STATE ; 
 + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ POWER _ CAPABILITIES ; 
 + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ POWER _ INFORMATION ; 
 + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ POWER _ POLICY ; 
 + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ POWER _ STATE ; 
 + 
 + import junit . framework . TestCase ; 
 + 
 + public class PowrProfTest extends TestCase { 
 + 
 + public void testProcessorPowerInformation ( ) { 
 + / / MSDN docs for CallNTPowerInformation specify use of GetSystemInfo to 
 + / / count logical processors for this InformationLevel . The GetSystemInfo 
 + / / function and this function only count logical processors on the 
 + / / current Processor Group , so the array will never have more than 64 
 + / / elements 
 + SYSTEM _ INFO info = new SYSTEM _ INFO ( ) ; 
 + Kernel32 . INSTANCE . GetSystemInfo ( info ) ; 
 + int numProcs = info . dwNumberOfProcessors . intValue ( ) ; 
 + 
 + / / Try with too small buffer 
 + int bufferSize = 1 ; 
 + Memory mem = new Memory ( bufferSize ) ; 
 + assertEquals ( NTStatus . STATUS _ BUFFER _ TOO _ SMALL , PowrProf . INSTANCE 
 + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . ProcessorInformation , null , 0 , mem , bufferSize ) ) ; 
 + 
 + PROCESSOR _ POWER _ INFORMATION ppi = new PROCESSOR _ POWER _ INFORMATION ( ) ; 
 + bufferSize = ppi . size ( ) * numProcs ; 
 + mem = new Memory ( bufferSize ) ; 
 + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE 
 + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . ProcessorInformation , null , 0 , mem , bufferSize ) ) ; 
 + 
 + long [ ] freqs = new long [ numProcs ] ; 
 + for ( int i = 0 ; i < freqs . length ; i + + ) { 
 + ppi = new PROCESSOR _ POWER _ INFORMATION ( mem . share ( i * ( long ) ppi . size ( ) ) ) ; 
 + assertTrue ( ppi . CurrentMhz < = ppi . MaxMhz ) ; 
 + } 
 + } 
 + 
 + public void testSystemBatteryStateAndPowerCapabilities ( ) { 
 + int size = new SYSTEM _ BATTERY _ STATE ( ) . size ( ) ; 
 + Memory mem = new Memory ( size ) ; 
 + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE 
 + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . SystemBatteryState , null , 0 , mem , size ) ) ; 
 + SYSTEM _ BATTERY _ STATE batteryState = new SYSTEM _ BATTERY _ STATE ( mem ) ; 
 + if ( batteryState . BatteryPresent > 0 ) { 
 + if ( batteryState . AcOnLine = = 0 & & batteryState . Charging = = 0 & & batteryState . Discharging > 0 ) { 
 + assertTrue ( batteryState . EstimatedTime > = 0 ) ; 
 + } 
 + assertTrue ( batteryState . RemainingCapacity < = batteryState . MaxCapacity ) ; 
 + } 
 + 
 + size = new SYSTEM _ POWER _ CAPABILITIES ( ) . size ( ) ; 
 + mem = new Memory ( size ) ; 
 + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE 
 + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . SystemPowerCapabilities , null , 0 , mem , size ) ) ; 
 + SYSTEM _ POWER _ CAPABILITIES powerCapabilities = new SYSTEM _ POWER _ CAPABILITIES ( 
 + mem ) ; 
 + assertEquals ( powerCapabilities . SystemBatteriesPresent > 0 , batteryState . BatteryPresent > 0 ) ; 
 + } 
 + 
 + public void testSystemPowerInformation ( ) { 
 + int size = new SYSTEM _ POWER _ INFORMATION ( ) . size ( ) ; 
 + Memory mem = new Memory ( size ) ; 
 + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE 
 + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . SystemPowerInformation , null , 0 , mem , size ) ) ; 
 + SYSTEM _ POWER _ INFORMATION powerInfo = new SYSTEM _ POWER _ INFORMATION ( mem ) ; 
 + assertTrue ( powerInfo . MaxIdlenessAllowed < = 100 ) ; 
 + assertTrue ( powerInfo . Idleness < = 100 ) ; 
 + assertTrue ( powerInfo . CoolingMode > = 0 ) ; / / must be 0 , 1 , 2 
 + assertTrue ( powerInfo . CoolingMode < = 2 ) ; 
 + } 
 + 
 + public void testSystemPowerPolicy ( ) { 
 + int size = new SYSTEM _ POWER _ POLICY ( ) . size ( ) ; 
 + Memory mem = new Memory ( size ) ; 
 + assertEquals ( NTStatus . STATUS _ SUCCESS , PowrProf . INSTANCE 
 + . CallNtPowerInformation ( POWER _ INFORMATION _ LEVEL . SystemPowerPolicyCurrent , null , 0 , mem , size ) ) ; 
 + SYSTEM _ POWER _ POLICY powerPolicy = new SYSTEM _ POWER _ POLICY ( mem ) ; 
 + 
 + / / Test selected elements including nested structures 
 + assertTrue ( powerPolicy . PowerButton . Action > = 0 ) ; 
 + assertTrue ( powerPolicy . PowerButton . Action < = POWER _ ACTION . PowerActionDisplayOff ) ; / / Max 
 + assertTrue ( powerPolicy . MinSleep < = powerPolicy . MaxSleep ) ; 
 + assertTrue ( powerPolicy . MaxSleep < = SYSTEM _ POWER _ STATE . PowerSystemMaximum ) ; 
 + assertTrue ( powerPolicy . DischargePolicy [ 0 ] . BatteryLevel < = 100 ) ; / / percentage 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
