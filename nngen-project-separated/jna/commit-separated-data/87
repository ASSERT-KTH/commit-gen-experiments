BLEU SCORE: 0.013139808552042212

TEST MSG: Fix ELFAnalyserTest for java 6 ( remove usage of post - java6 NIO code )
GENERATED MSG: increase JWS timeout

TEST DIFF (one line): diff - - git a / test / com / sun / jna / ELFAnalyserTest . java b / test / com / sun / jna / ELFAnalyserTest . java <nl> index b1ce5c6 . . fb65a21 100644 <nl> - - - a / test / com / sun / jna / ELFAnalyserTest . java <nl> + + + b / test / com / sun / jna / ELFAnalyserTest . java <nl> @ @ - 2 , 9 + 2 , 6 @ @ <nl> package com . sun . jna ; <nl> <nl> import java . io . * ; <nl> - import java . nio . file . CopyOption ; <nl> - import java . nio . file . Files ; <nl> - import java . nio . file . StandardCopyOption ; <nl> import java . util . zip . ZipEntry ; <nl> import java . util . zip . ZipFile ; <nl> import org . junit . AfterClass ; <nl> @ @ - 15 , 14 + 12 , 13 @ @ import org . junit . Test ; <nl> <nl> <nl> public class ELFAnalyserTest { <nl> - <nl> <nl> - private static File testResources = new File ( " build / test - resources " ) ; <nl> - private static File win32Lib = new File ( testResources , " win32 - x86 - 64 . dll " ) ; <nl> - private static File linuxArmelLib = new File ( testResources , " linux - armel . so " ) ; <nl> - private static File linuxArmelNoflagLib = new File ( testResources , " linux - armel - noflag . so " ) ; <nl> - private static File linuxArmhfLib = new File ( testResources , " linux - armhf . so " ) ; <nl> - private static File linuxAmd64Lib = new File ( testResources , " linux - amd64 . so " ) ; <nl> + private static final File TEST _ RESOURCES = new File ( " build / test - resources " ) ; <nl> + private static final File WIN32 _ LIB = new File ( TEST _ RESOURCES , " win32 - x86 - 64 . dll " ) ; <nl> + private static final File LINUX _ ARMEL _ LIB = new File ( TEST _ RESOURCES , " linux - armel . so " ) ; <nl> + private static final File LINUX _ ARMEL _ NOFLAG _ LIG = new File ( TEST _ RESOURCES , " linux - armel - noflag . so " ) ; <nl> + private static final File LINUX _ ARMHF _ LIB = new File ( TEST _ RESOURCES , " linux - armhf . so " ) ; <nl> + private static final File LINUX _ AMD64 _ LIB = new File ( TEST _ RESOURCES , " linux - amd64 . so " ) ; <nl> <nl> @ BeforeClass <nl> public static void initClass ( ) throws IOException { <nl> @ @ - 31 , 24 + 27 , 24 @ @ public class ELFAnalyserTest { <nl> File linuxArmhfZip = new File ( " dist / linux - arm . jar " ) ; <nl> File linuxAmd64Zip = new File ( " dist / linux - x86 - 64 . jar " ) ; <nl> <nl> - testResources . mkdirs ( ) ; <nl> + TEST _ RESOURCES . mkdirs ( ) ; <nl> <nl> - extractFileFromZip ( win32Zip , " jnidispatch . dll " , win32Lib ) ; <nl> - extractFileFromZip ( linuxArmelZip , " libjnidispatch . so " , linuxArmelLib ) ; <nl> - extractFileFromZip ( linuxArmhfZip , " libjnidispatch . so " , linuxArmhfLib ) ; <nl> - extractFileFromZip ( linuxAmd64Zip , " libjnidispatch . so " , linuxAmd64Lib ) ; <nl> - makeLinuxArmelNoflagLib ( linuxArmelLib , linuxArmelNoflagLib ) ; <nl> + extractFileFromZip ( win32Zip , " jnidispatch . dll " , WIN32 _ LIB ) ; <nl> + extractFileFromZip ( linuxArmelZip , " libjnidispatch . so " , LINUX _ ARMEL _ LIB ) ; <nl> + extractFileFromZip ( linuxArmhfZip , " libjnidispatch . so " , LINUX _ ARMHF _ LIB ) ; <nl> + extractFileFromZip ( linuxAmd64Zip , " libjnidispatch . so " , LINUX _ AMD64 _ LIB ) ; <nl> + makeLinuxArmelNoflagLib ( LINUX _ ARMEL _ LIB , LINUX _ ARMEL _ NOFLAG _ LIG ) ; <nl> } <nl> <nl> @ Test <nl> public void testNonELF ( ) throws IOException { <nl> - ELFAnalyser ahfd = ELFAnalyser . analyse ( win32Lib . getAbsolutePath ( ) ) ; <nl> + ELFAnalyser ahfd = ELFAnalyser . analyse ( WIN32 _ LIB . getAbsolutePath ( ) ) ; <nl> assertFalse ( ahfd . isELF ( ) ) ; <nl> } <nl> <nl> @ Test <nl> public void testNonArm ( ) throws IOException { <nl> - ELFAnalyser ahfd = ELFAnalyser . analyse ( linuxAmd64Lib . getAbsolutePath ( ) ) ; <nl> + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ AMD64 _ LIB . getAbsolutePath ( ) ) ; <nl> assertTrue ( ahfd . isELF ( ) ) ; <nl> assertFalse ( ahfd . isArm ( ) ) ; <nl> assertTrue ( ahfd . is64Bit ( ) ) ; <nl> @ @ - 56 , 7 + 52 , 7 @ @ public class ELFAnalyserTest { <nl> <nl> @ Test <nl> public void testArmhf ( ) throws IOException { <nl> - ELFAnalyser ahfd = ELFAnalyser . analyse ( linuxArmhfLib . getAbsolutePath ( ) ) ; <nl> + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMHF _ LIB . getAbsolutePath ( ) ) ; <nl> assertTrue ( ahfd . isELF ( ) ) ; <nl> assertTrue ( ahfd . isArm ( ) ) ; <nl> assertFalse ( ahfd . is64Bit ( ) ) ; <nl> @ @ - 66 , 7 + 62 , 7 @ @ public class ELFAnalyserTest { <nl> <nl> @ Test <nl> public void testArmel ( ) throws IOException { <nl> - ELFAnalyser ahfd = ELFAnalyser . analyse ( linuxArmelLib . getAbsolutePath ( ) ) ; <nl> + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMEL _ LIB . getAbsolutePath ( ) ) ; <nl> assertTrue ( ahfd . isELF ( ) ) ; <nl> assertTrue ( ahfd . isArm ( ) ) ; <nl> assertFalse ( ahfd . is64Bit ( ) ) ; <nl> @ @ - 76 , 7 + 72 , 7 @ @ public class ELFAnalyserTest { <nl> <nl> @ Test <nl> public void testArmelNoflag ( ) throws IOException { <nl> - ELFAnalyser ahfd = ELFAnalyser . analyse ( linuxArmelNoflagLib . getAbsolutePath ( ) ) ; <nl> + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMEL _ NOFLAG _ LIG . getAbsolutePath ( ) ) ; <nl> assertTrue ( ahfd . isELF ( ) ) ; <nl> assertTrue ( ahfd . isArm ( ) ) ; <nl> assertFalse ( ahfd . is64Bit ( ) ) ; <nl> @ @ - 86 , 12 + 82 , 12 @ @ public class ELFAnalyserTest { <nl> <nl> @ AfterClass <nl> public static void afterClass ( ) throws IOException { <nl> - linuxAmd64Lib . delete ( ) ; <nl> - linuxArmhfLib . delete ( ) ; <nl> - linuxArmelLib . delete ( ) ; <nl> - win32Lib . delete ( ) ; <nl> - linuxArmelNoflagLib . delete ( ) ; <nl> - testResources . delete ( ) ; <nl> + LINUX _ AMD64 _ LIB . delete ( ) ; <nl> + LINUX _ ARMHF _ LIB . delete ( ) ; <nl> + LINUX _ ARMEL _ LIB . delete ( ) ; <nl> + WIN32 _ LIB . delete ( ) ; <nl> + LINUX _ ARMEL _ NOFLAG _ LIG . delete ( ) ; <nl> + TEST _ RESOURCES . delete ( ) ; <nl> } <nl> <nl> private static void extractFileFromZip ( File zipTarget , String zipEntryName , File outputFile ) throws IOException { <nl> @ @ - 104 , 11 + 100 , 7 @ @ public class ELFAnalyserTest { <nl> InputStream is = zip . getInputStream ( entry ) ; / / Implicitly closed by closing ZipFile <nl> OutputStream os = new FileOutputStream ( outputFile ) ; <nl> try { <nl> - int read ; <nl> - byte [ ] buffer = new byte [ 1024 * 1024 ] ; <nl> - while ( ( read = is . read ( buffer ) ) > 0 ) { <nl> - os . write ( buffer , 0 , read ) ; <nl> - } <nl> + copyStream ( is , os ) ; <nl> } finally { <nl> os . close ( ) ; <nl> } <nl> @ @ - 121 , 7 + 113 , 8 @ @ public class ELFAnalyserTest { <nl> / / The procedure call standard is coded on the second byte . <nl> private static void makeLinuxArmelNoflagLib ( File sourceFile , File outputFile ) throws IOException { <nl> final int POS _ ABI _ FLOAT _ BIT = ( byte ) 0x25 ; <nl> - Files . copy ( sourceFile . toPath ( ) , outputFile . toPath ( ) , StandardCopyOption . REPLACE _ EXISTING ) ; <nl> + copyFile ( sourceFile , outputFile ) ; <nl> + <nl> RandomAccessFile out = new RandomAccessFile ( outputFile , " rw " ) ; <nl> <nl> out . seek ( POS _ ABI _ FLOAT _ BIT ) ; <nl> @ @ - 129 , 5 + 122 , 35 @ @ public class ELFAnalyserTest { <nl> <nl> out . close ( ) ; <nl> } <nl> + <nl> + private static void copyFile ( File sourceFile , File outputFile ) throws IOException { <nl> + InputStream inputStream = null ; <nl> + OutputStream outputStream = null ; <nl> + try { <nl> + inputStream = new FileInputStream ( sourceFile ) ; <nl> + outputStream = new FileOutputStream ( outputFile ) ; <nl> + copyStream ( inputStream , outputStream ) ; <nl> + } finally { <nl> + closeSilently ( inputStream ) ; <nl> + closeSilently ( outputStream ) ; <nl> + } <nl> + } <nl> + <nl> + private static void copyStream ( InputStream is , OutputStream os ) throws IOException { <nl> + int read ; <nl> + byte [ ] buffer = new byte [ 1024 * 1024 ] ; <nl> + while ( ( read = is . read ( buffer ) ) > 0 ) { <nl> + os . write ( buffer , 0 , read ) ; <nl> + } <nl> + } <nl> + <nl> + private static void closeSilently ( Closeable closeable ) { <nl> + if ( closeable = = null ) { <nl> + return ; <nl> + } <nl> + try { <nl> + closeable . close ( ) ; <nl> + } catch ( IOException ex ) { } <nl> + } <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c <nl> index 46e4c5f . . f514986 100644 <nl> - - - a / jnalib / native / dispatch . c <nl> + + + b / jnalib / native / dispatch . c <nl> @ @ - 671 , 7 + 671 , 7 @ @ Java _ com _ sun _ jna _ NativeLibrary _ open ( JNIEnv * env , jclass cls , jstring lib ) { <nl> / * dlopen on Unix allows NULL to mean " current process " * / <nl> if ( lib ! = NULL ) { <nl> if ( ( libname = LIBNAME2CSTR ( env , lib ) ) = = NULL ) { <nl> - return ( jlong ) A2L ( NULL ) ; <nl> + return A2L ( NULL ) ; <nl> } <nl> } <nl> <nl> @ @ - 682 , 7 + 682 , 7 @ @ Java _ com _ sun _ jna _ NativeLibrary _ open ( JNIEnv * env , jclass cls , jstring lib ) { <nl> } <nl> if ( libname ! = NULL ) <nl> free ( ( void * ) libname ) ; <nl> - return ( jlong ) A2L ( handle ) ; <nl> + return A2L ( handle ) ; <nl> } <nl> <nl> / * <nl> diff - - git a / jnalib / src / com / sun / jna / Library . java b / jnalib / src / com / sun / jna / Library . java <nl> index 4f9d79f . . c58d69f 100644 <nl> - - - a / jnalib / src / com / sun / jna / Library . java <nl> + + + b / jnalib / src / com / sun / jna / Library . java <nl> @ @ - 122 , 7 + 122 , 7 @ @ public interface Library { <nl> private final Map functions = new WeakHashMap ( ) ; <nl> public Handler ( String libname , Class interfaceClass , Map options ) { <nl> <nl> - if ( libname = = null | | " " . equals ( libname . trim ( ) ) ) { <nl> + if ( " " . equals ( libname . trim ( ) ) ) { <nl> throw new IllegalArgumentException ( " Invalid library name \ " " <nl> + libname + " \ " " ) ; <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / Native . java b / jnalib / src / com / sun / jna / Native . java <nl> index f164bee . . 85ab838 100644 <nl> - - - a / jnalib / src / com / sun / jna / Native . java <nl> + + + b / jnalib / src / com / sun / jna / Native . java <nl> @ @ - 333 , 6 + 333 , 9 @ @ public final class Native { <nl> <nl> / * * Load a library interface from the given shared library , providing <nl> * the explicit interface class . <nl> + * If < code > name < / code > is null , attempts to map onto the current process . <nl> + * @ param name <nl> + * @ param interfaceClass <nl> * / <nl> public static Object loadLibrary ( String name , Class interfaceClass ) { <nl> return loadLibrary ( name , interfaceClass , Collections . EMPTY _ MAP ) ; <nl> @ @ - 341 , 7 + 344 , 8 @ @ public final class Native { <nl> / * * Load a library interface from the given shared library , providing <nl> * the explicit interface class and a map of options for the library . <nl> * If no library options are detected the map is interpreted as a map <nl> - * of Java method names to native function names . <nl> + * of Java method names to native function names . < p > <nl> + * If < code > name < / code > is null , attempts to map onto the current process . <nl> * @ param name <nl> * @ param interfaceClass <nl> * @ param libOptions Map of library options <nl> diff - - git a / jnalib / src / com / sun / jna / NativeLibrary . java b / jnalib / src / com / sun / jna / NativeLibrary . java <nl> index 7f02d80 . . 1233fe8 100644 <nl> - - - a / jnalib / src / com / sun / jna / NativeLibrary . java <nl> + + + b / jnalib / src / com / sun / jna / NativeLibrary . java <nl> @ @ - 49 , 7 + 49 , 6 @ @ public class NativeLibrary { <nl> final int callFlags ; <nl> final Map options ; <nl> <nl> - private static WeakReference currentProcess ; <nl> private static final Map libraries = new HashMap ( ) ; <nl> private static final Map searchPaths = Collections . synchronizedMap ( new HashMap ( ) ) ; <nl> private static final List librarySearchPath = new LinkedList ( ) ; <nl> @ @ - 114 , 8 + 113 , 8 @ @ public class NativeLibrary { <nl> long handle = 0 ; <nl> / / <nl> / / Only search user specified paths first . This will also fall back <nl> - / / to dlopen / LoadLibrary ( ) since findLibraryPath returns the mapped name <nl> - / / if it cannot find the library . <nl> + / / to dlopen / LoadLibrary ( ) since findLibraryPath returns the mapped <nl> + / / name if it cannot find the library . <nl> / / <nl> try { <nl> handle = open ( libraryPath ) ; <nl> @ @ - 216 , 19 + 215 , 26 @ @ public class NativeLibrary { <nl> options . put ( Library . OPTION _ CALLING _ CONVENTION , new Integer ( Function . C _ CONVENTION ) ) ; <nl> } <nl> <nl> - if ( libraryName = = null ) <nl> - throw new NullPointerException ( " Library name may not be null " ) ; <nl> - <nl> synchronized ( libraries ) { <nl> WeakReference ref = ( WeakReference ) libraries . get ( libraryName + options ) ; <nl> NativeLibrary library = ref ! = null ? ( NativeLibrary ) ref . get ( ) : null ; <nl> <nl> if ( library = = null ) { <nl> - library = loadLibrary ( libraryName , options ) ; <nl> + if ( libraryName = = null ) { <nl> + if ( Platform . isWindows ( ) ) <nl> + throw new UnsatisfiedLinkError ( " getProcess ( ) is not implemented on Windows " ) ; <nl> + library = new NativeLibrary ( " < process > " , null , open ( null ) , options ) ; <nl> + } <nl> + else { <nl> + library = loadLibrary ( libraryName , options ) ; <nl> + } <nl> ref = new WeakReference ( library ) ; <nl> libraries . put ( library . getName ( ) + options , ref ) ; <nl> - libraries . put ( library . getFile ( ) . getAbsolutePath ( ) + options , ref ) ; <nl> - libraries . put ( library . getFile ( ) . getName ( ) + options , ref ) ; <nl> + File file = library . getFile ( ) ; <nl> + if ( file ! = null ) { <nl> + libraries . put ( file . getAbsolutePath ( ) + options , ref ) ; <nl> + libraries . put ( file . getName ( ) + options , ref ) ; <nl> + } <nl> } <nl> return library ; <nl> } <nl> @ @ - 241 , 18 + 247 , 17 @ @ public class NativeLibrary { <nl> * name of the native library . <nl> * / <nl> public static synchronized final NativeLibrary getProcess ( ) { <nl> - NativeLibrary library = null ; <nl> - if ( currentProcess ! = null ) { <nl> - library = ( NativeLibrary ) currentProcess . get ( ) ; <nl> - } <nl> - <nl> - if ( library = = null ) { <nl> - long handle = open ( null ) ; <nl> - library = new NativeLibrary ( " < process > " , null , handle , Collections . EMPTY _ MAP ) ; <nl> - currentProcess = new WeakReference ( library ) ; <nl> - } <nl> + return getInstance ( null ) ; <nl> + } <nl> <nl> - return library ; <nl> + / * * <nl> + * Returns an instance of NativeLibrary which refers to the current process . <nl> + * This is useful for accessing functions which were already mapped by some <nl> + * other mechanism , without having to reference or even know the exact <nl> + * name of the native library . <nl> + * / <nl> + public static synchronized final NativeLibrary getProcess ( Map options ) { <nl> + return getInstance ( null , options ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 390 , 10 + 395 , 10 @ @ public class NativeLibrary { <nl> public void dispose ( ) { <nl> synchronized ( libraries ) { <nl> libraries . remove ( getName ( ) + options ) ; <nl> - File path = getFile ( ) ; <nl> - if ( path ! = null ) { <nl> - libraries . remove ( path . getAbsolutePath ( ) + options ) ; <nl> - libraries . remove ( path . getName ( ) + options ) ; <nl> + File file = getFile ( ) ; <nl> + if ( file ! = null ) { <nl> + libraries . remove ( file . getAbsolutePath ( ) + options ) ; <nl> + libraries . remove ( file . getName ( ) + options ) ; <nl> } <nl> } <nl> synchronized ( this ) { <nl> diff - - git a / jnalib / test / com / sun / jna / NativeLibraryTest . java b / jnalib / test / com / sun / jna / NativeLibraryTest . java <nl> index ca4551d . . 48d880e 100644 <nl> - - - a / jnalib / test / com / sun / jna / NativeLibraryTest . java <nl> + + + b / jnalib / test / com / sun / jna / NativeLibraryTest . java <nl> @ @ - 182 , 6 + 182 , 18 @ @ public class NativeLibraryTest extends TestCase { <nl> 	 } <nl> } <nl> <nl> + public void testGetProcess ( ) { <nl> + try { <nl> + NativeLibrary process = NativeLibrary . getProcess ( ) ; <nl> + / / Access a common C library function <nl> + process . getFunction ( " printf " ) ; <nl> + } <nl> + catch ( UnsatisfiedLinkError e ) { <nl> + / / Not implemented on windows yet <nl> + if ( ! Platform . isWindows ( ) ) throw e ; <nl> + } <nl> + } <nl> + <nl> public static void main ( String [ ] args ) { <nl> junit . textui . TestRunner . run ( NativeLibraryTest . class ) ; <nl> }

TEST DIFF:
diff - - git a / test / com / sun / jna / ELFAnalyserTest . java b / test / com / sun / jna / ELFAnalyserTest . java 
 index b1ce5c6 . . fb65a21 100644 
 - - - a / test / com / sun / jna / ELFAnalyserTest . java 
 + + + b / test / com / sun / jna / ELFAnalyserTest . java 
 @ @ - 2 , 9 + 2 , 6 @ @ 
 package com . sun . jna ; 
 
 import java . io . * ; 
 - import java . nio . file . CopyOption ; 
 - import java . nio . file . Files ; 
 - import java . nio . file . StandardCopyOption ; 
 import java . util . zip . ZipEntry ; 
 import java . util . zip . ZipFile ; 
 import org . junit . AfterClass ; 
 @ @ - 15 , 14 + 12 , 13 @ @ import org . junit . Test ; 
 
 
 public class ELFAnalyserTest { 
 - 
 
 - private static File testResources = new File ( " build / test - resources " ) ; 
 - private static File win32Lib = new File ( testResources , " win32 - x86 - 64 . dll " ) ; 
 - private static File linuxArmelLib = new File ( testResources , " linux - armel . so " ) ; 
 - private static File linuxArmelNoflagLib = new File ( testResources , " linux - armel - noflag . so " ) ; 
 - private static File linuxArmhfLib = new File ( testResources , " linux - armhf . so " ) ; 
 - private static File linuxAmd64Lib = new File ( testResources , " linux - amd64 . so " ) ; 
 + private static final File TEST _ RESOURCES = new File ( " build / test - resources " ) ; 
 + private static final File WIN32 _ LIB = new File ( TEST _ RESOURCES , " win32 - x86 - 64 . dll " ) ; 
 + private static final File LINUX _ ARMEL _ LIB = new File ( TEST _ RESOURCES , " linux - armel . so " ) ; 
 + private static final File LINUX _ ARMEL _ NOFLAG _ LIG = new File ( TEST _ RESOURCES , " linux - armel - noflag . so " ) ; 
 + private static final File LINUX _ ARMHF _ LIB = new File ( TEST _ RESOURCES , " linux - armhf . so " ) ; 
 + private static final File LINUX _ AMD64 _ LIB = new File ( TEST _ RESOURCES , " linux - amd64 . so " ) ; 
 
 @ BeforeClass 
 public static void initClass ( ) throws IOException { 
 @ @ - 31 , 24 + 27 , 24 @ @ public class ELFAnalyserTest { 
 File linuxArmhfZip = new File ( " dist / linux - arm . jar " ) ; 
 File linuxAmd64Zip = new File ( " dist / linux - x86 - 64 . jar " ) ; 
 
 - testResources . mkdirs ( ) ; 
 + TEST _ RESOURCES . mkdirs ( ) ; 
 
 - extractFileFromZip ( win32Zip , " jnidispatch . dll " , win32Lib ) ; 
 - extractFileFromZip ( linuxArmelZip , " libjnidispatch . so " , linuxArmelLib ) ; 
 - extractFileFromZip ( linuxArmhfZip , " libjnidispatch . so " , linuxArmhfLib ) ; 
 - extractFileFromZip ( linuxAmd64Zip , " libjnidispatch . so " , linuxAmd64Lib ) ; 
 - makeLinuxArmelNoflagLib ( linuxArmelLib , linuxArmelNoflagLib ) ; 
 + extractFileFromZip ( win32Zip , " jnidispatch . dll " , WIN32 _ LIB ) ; 
 + extractFileFromZip ( linuxArmelZip , " libjnidispatch . so " , LINUX _ ARMEL _ LIB ) ; 
 + extractFileFromZip ( linuxArmhfZip , " libjnidispatch . so " , LINUX _ ARMHF _ LIB ) ; 
 + extractFileFromZip ( linuxAmd64Zip , " libjnidispatch . so " , LINUX _ AMD64 _ LIB ) ; 
 + makeLinuxArmelNoflagLib ( LINUX _ ARMEL _ LIB , LINUX _ ARMEL _ NOFLAG _ LIG ) ; 
 } 
 
 @ Test 
 public void testNonELF ( ) throws IOException { 
 - ELFAnalyser ahfd = ELFAnalyser . analyse ( win32Lib . getAbsolutePath ( ) ) ; 
 + ELFAnalyser ahfd = ELFAnalyser . analyse ( WIN32 _ LIB . getAbsolutePath ( ) ) ; 
 assertFalse ( ahfd . isELF ( ) ) ; 
 } 
 
 @ Test 
 public void testNonArm ( ) throws IOException { 
 - ELFAnalyser ahfd = ELFAnalyser . analyse ( linuxAmd64Lib . getAbsolutePath ( ) ) ; 
 + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ AMD64 _ LIB . getAbsolutePath ( ) ) ; 
 assertTrue ( ahfd . isELF ( ) ) ; 
 assertFalse ( ahfd . isArm ( ) ) ; 
 assertTrue ( ahfd . is64Bit ( ) ) ; 
 @ @ - 56 , 7 + 52 , 7 @ @ public class ELFAnalyserTest { 
 
 @ Test 
 public void testArmhf ( ) throws IOException { 
 - ELFAnalyser ahfd = ELFAnalyser . analyse ( linuxArmhfLib . getAbsolutePath ( ) ) ; 
 + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMHF _ LIB . getAbsolutePath ( ) ) ; 
 assertTrue ( ahfd . isELF ( ) ) ; 
 assertTrue ( ahfd . isArm ( ) ) ; 
 assertFalse ( ahfd . is64Bit ( ) ) ; 
 @ @ - 66 , 7 + 62 , 7 @ @ public class ELFAnalyserTest { 
 
 @ Test 
 public void testArmel ( ) throws IOException { 
 - ELFAnalyser ahfd = ELFAnalyser . analyse ( linuxArmelLib . getAbsolutePath ( ) ) ; 
 + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMEL _ LIB . getAbsolutePath ( ) ) ; 
 assertTrue ( ahfd . isELF ( ) ) ; 
 assertTrue ( ahfd . isArm ( ) ) ; 
 assertFalse ( ahfd . is64Bit ( ) ) ; 
 @ @ - 76 , 7 + 72 , 7 @ @ public class ELFAnalyserTest { 
 
 @ Test 
 public void testArmelNoflag ( ) throws IOException { 
 - ELFAnalyser ahfd = ELFAnalyser . analyse ( linuxArmelNoflagLib . getAbsolutePath ( ) ) ; 
 + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMEL _ NOFLAG _ LIG . getAbsolutePath ( ) ) ; 
 assertTrue ( ahfd . isELF ( ) ) ; 
 assertTrue ( ahfd . isArm ( ) ) ; 
 assertFalse ( ahfd . is64Bit ( ) ) ; 
 @ @ - 86 , 12 + 82 , 12 @ @ public class ELFAnalyserTest { 
 
 @ AfterClass 
 public static void afterClass ( ) throws IOException { 
 - linuxAmd64Lib . delete ( ) ; 
 - linuxArmhfLib . delete ( ) ; 
 - linuxArmelLib . delete ( ) ; 
 - win32Lib . delete ( ) ; 
 - linuxArmelNoflagLib . delete ( ) ; 
 - testResources . delete ( ) ; 
 + LINUX _ AMD64 _ LIB . delete ( ) ; 
 + LINUX _ ARMHF _ LIB . delete ( ) ; 
 + LINUX _ ARMEL _ LIB . delete ( ) ; 
 + WIN32 _ LIB . delete ( ) ; 
 + LINUX _ ARMEL _ NOFLAG _ LIG . delete ( ) ; 
 + TEST _ RESOURCES . delete ( ) ; 
 } 
 
 private static void extractFileFromZip ( File zipTarget , String zipEntryName , File outputFile ) throws IOException { 
 @ @ - 104 , 11 + 100 , 7 @ @ public class ELFAnalyserTest { 
 InputStream is = zip . getInputStream ( entry ) ; / / Implicitly closed by closing ZipFile 
 OutputStream os = new FileOutputStream ( outputFile ) ; 
 try { 
 - int read ; 
 - byte [ ] buffer = new byte [ 1024 * 1024 ] ; 
 - while ( ( read = is . read ( buffer ) ) > 0 ) { 
 - os . write ( buffer , 0 , read ) ; 
 - } 
 + copyStream ( is , os ) ; 
 } finally { 
 os . close ( ) ; 
 } 
 @ @ - 121 , 7 + 113 , 8 @ @ public class ELFAnalyserTest { 
 / / The procedure call standard is coded on the second byte . 
 private static void makeLinuxArmelNoflagLib ( File sourceFile , File outputFile ) throws IOException { 
 final int POS _ ABI _ FLOAT _ BIT = ( byte ) 0x25 ; 
 - Files . copy ( sourceFile . toPath ( ) , outputFile . toPath ( ) , StandardCopyOption . REPLACE _ EXISTING ) ; 
 + copyFile ( sourceFile , outputFile ) ; 
 + 
 RandomAccessFile out = new RandomAccessFile ( outputFile , " rw " ) ; 
 
 out . seek ( POS _ ABI _ FLOAT _ BIT ) ; 
 @ @ - 129 , 5 + 122 , 35 @ @ public class ELFAnalyserTest { 
 
 out . close ( ) ; 
 } 
 + 
 + private static void copyFile ( File sourceFile , File outputFile ) throws IOException { 
 + InputStream inputStream = null ; 
 + OutputStream outputStream = null ; 
 + try { 
 + inputStream = new FileInputStream ( sourceFile ) ; 
 + outputStream = new FileOutputStream ( outputFile ) ; 
 + copyStream ( inputStream , outputStream ) ; 
 + } finally { 
 + closeSilently ( inputStream ) ; 
 + closeSilently ( outputStream ) ; 
 + } 
 + } 
 + 
 + private static void copyStream ( InputStream is , OutputStream os ) throws IOException { 
 + int read ; 
 + byte [ ] buffer = new byte [ 1024 * 1024 ] ; 
 + while ( ( read = is . read ( buffer ) ) > 0 ) { 
 + os . write ( buffer , 0 , read ) ; 
 + } 
 + } 
 + 
 + private static void closeSilently ( Closeable closeable ) { 
 + if ( closeable = = null ) { 
 + return ; 
 + } 
 + try { 
 + closeable . close ( ) ; 
 + } catch ( IOException ex ) { } 
 + } 
 } 


NEAREST DIFF:
diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c 
 index 46e4c5f . . f514986 100644 
 - - - a / jnalib / native / dispatch . c 
 + + + b / jnalib / native / dispatch . c 
 @ @ - 671 , 7 + 671 , 7 @ @ Java _ com _ sun _ jna _ NativeLibrary _ open ( JNIEnv * env , jclass cls , jstring lib ) { 
 / * dlopen on Unix allows NULL to mean " current process " * / 
 if ( lib ! = NULL ) { 
 if ( ( libname = LIBNAME2CSTR ( env , lib ) ) = = NULL ) { 
 - return ( jlong ) A2L ( NULL ) ; 
 + return A2L ( NULL ) ; 
 } 
 } 
 
 @ @ - 682 , 7 + 682 , 7 @ @ Java _ com _ sun _ jna _ NativeLibrary _ open ( JNIEnv * env , jclass cls , jstring lib ) { 
 } 
 if ( libname ! = NULL ) 
 free ( ( void * ) libname ) ; 
 - return ( jlong ) A2L ( handle ) ; 
 + return A2L ( handle ) ; 
 } 
 
 / * 
 diff - - git a / jnalib / src / com / sun / jna / Library . java b / jnalib / src / com / sun / jna / Library . java 
 index 4f9d79f . . c58d69f 100644 
 - - - a / jnalib / src / com / sun / jna / Library . java 
 + + + b / jnalib / src / com / sun / jna / Library . java 
 @ @ - 122 , 7 + 122 , 7 @ @ public interface Library { 
 private final Map functions = new WeakHashMap ( ) ; 
 public Handler ( String libname , Class interfaceClass , Map options ) { 
 
 - if ( libname = = null | | " " . equals ( libname . trim ( ) ) ) { 
 + if ( " " . equals ( libname . trim ( ) ) ) { 
 throw new IllegalArgumentException ( " Invalid library name \ " " 
 + libname + " \ " " ) ; 
 } 
 diff - - git a / jnalib / src / com / sun / jna / Native . java b / jnalib / src / com / sun / jna / Native . java 
 index f164bee . . 85ab838 100644 
 - - - a / jnalib / src / com / sun / jna / Native . java 
 + + + b / jnalib / src / com / sun / jna / Native . java 
 @ @ - 333 , 6 + 333 , 9 @ @ public final class Native { 
 
 / * * Load a library interface from the given shared library , providing 
 * the explicit interface class . 
 + * If < code > name < / code > is null , attempts to map onto the current process . 
 + * @ param name 
 + * @ param interfaceClass 
 * / 
 public static Object loadLibrary ( String name , Class interfaceClass ) { 
 return loadLibrary ( name , interfaceClass , Collections . EMPTY _ MAP ) ; 
 @ @ - 341 , 7 + 344 , 8 @ @ public final class Native { 
 / * * Load a library interface from the given shared library , providing 
 * the explicit interface class and a map of options for the library . 
 * If no library options are detected the map is interpreted as a map 
 - * of Java method names to native function names . 
 + * of Java method names to native function names . < p > 
 + * If < code > name < / code > is null , attempts to map onto the current process . 
 * @ param name 
 * @ param interfaceClass 
 * @ param libOptions Map of library options 
 diff - - git a / jnalib / src / com / sun / jna / NativeLibrary . java b / jnalib / src / com / sun / jna / NativeLibrary . java 
 index 7f02d80 . . 1233fe8 100644 
 - - - a / jnalib / src / com / sun / jna / NativeLibrary . java 
 + + + b / jnalib / src / com / sun / jna / NativeLibrary . java 
 @ @ - 49 , 7 + 49 , 6 @ @ public class NativeLibrary { 
 final int callFlags ; 
 final Map options ; 
 
 - private static WeakReference currentProcess ; 
 private static final Map libraries = new HashMap ( ) ; 
 private static final Map searchPaths = Collections . synchronizedMap ( new HashMap ( ) ) ; 
 private static final List librarySearchPath = new LinkedList ( ) ; 
 @ @ - 114 , 8 + 113 , 8 @ @ public class NativeLibrary { 
 long handle = 0 ; 
 / / 
 / / Only search user specified paths first . This will also fall back 
 - / / to dlopen / LoadLibrary ( ) since findLibraryPath returns the mapped name 
 - / / if it cannot find the library . 
 + / / to dlopen / LoadLibrary ( ) since findLibraryPath returns the mapped 
 + / / name if it cannot find the library . 
 / / 
 try { 
 handle = open ( libraryPath ) ; 
 @ @ - 216 , 19 + 215 , 26 @ @ public class NativeLibrary { 
 options . put ( Library . OPTION _ CALLING _ CONVENTION , new Integer ( Function . C _ CONVENTION ) ) ; 
 } 
 
 - if ( libraryName = = null ) 
 - throw new NullPointerException ( " Library name may not be null " ) ; 
 - 
 synchronized ( libraries ) { 
 WeakReference ref = ( WeakReference ) libraries . get ( libraryName + options ) ; 
 NativeLibrary library = ref ! = null ? ( NativeLibrary ) ref . get ( ) : null ; 
 
 if ( library = = null ) { 
 - library = loadLibrary ( libraryName , options ) ; 
 + if ( libraryName = = null ) { 
 + if ( Platform . isWindows ( ) ) 
 + throw new UnsatisfiedLinkError ( " getProcess ( ) is not implemented on Windows " ) ; 
 + library = new NativeLibrary ( " < process > " , null , open ( null ) , options ) ; 
 + } 
 + else { 
 + library = loadLibrary ( libraryName , options ) ; 
 + } 
 ref = new WeakReference ( library ) ; 
 libraries . put ( library . getName ( ) + options , ref ) ; 
 - libraries . put ( library . getFile ( ) . getAbsolutePath ( ) + options , ref ) ; 
 - libraries . put ( library . getFile ( ) . getName ( ) + options , ref ) ; 
 + File file = library . getFile ( ) ; 
 + if ( file ! = null ) { 
 + libraries . put ( file . getAbsolutePath ( ) + options , ref ) ; 
 + libraries . put ( file . getName ( ) + options , ref ) ; 
 + } 
 } 
 return library ; 
 } 
 @ @ - 241 , 18 + 247 , 17 @ @ public class NativeLibrary { 
 * name of the native library . 
 * / 
 public static synchronized final NativeLibrary getProcess ( ) { 
 - NativeLibrary library = null ; 
 - if ( currentProcess ! = null ) { 
 - library = ( NativeLibrary ) currentProcess . get ( ) ; 
 - } 
 - 
 - if ( library = = null ) { 
 - long handle = open ( null ) ; 
 - library = new NativeLibrary ( " < process > " , null , handle , Collections . EMPTY _ MAP ) ; 
 - currentProcess = new WeakReference ( library ) ; 
 - } 
 + return getInstance ( null ) ; 
 + } 
 
 - return library ; 
 + / * * 
 + * Returns an instance of NativeLibrary which refers to the current process . 
 + * This is useful for accessing functions which were already mapped by some 
 + * other mechanism , without having to reference or even know the exact 
 + * name of the native library . 
 + * / 
 + public static synchronized final NativeLibrary getProcess ( Map options ) { 
 + return getInstance ( null , options ) ; 
 } 
 
 / * * 
 @ @ - 390 , 10 + 395 , 10 @ @ public class NativeLibrary { 
 public void dispose ( ) { 
 synchronized ( libraries ) { 
 libraries . remove ( getName ( ) + options ) ; 
 - File path = getFile ( ) ; 
 - if ( path ! = null ) { 
 - libraries . remove ( path . getAbsolutePath ( ) + options ) ; 
 - libraries . remove ( path . getName ( ) + options ) ; 
 + File file = getFile ( ) ; 
 + if ( file ! = null ) { 
 + libraries . remove ( file . getAbsolutePath ( ) + options ) ; 
 + libraries . remove ( file . getName ( ) + options ) ; 
 } 
 } 
 synchronized ( this ) { 
 diff - - git a / jnalib / test / com / sun / jna / NativeLibraryTest . java b / jnalib / test / com / sun / jna / NativeLibraryTest . java 
 index ca4551d . . 48d880e 100644 
 - - - a / jnalib / test / com / sun / jna / NativeLibraryTest . java 
 + + + b / jnalib / test / com / sun / jna / NativeLibraryTest . java 
 @ @ - 182 , 6 + 182 , 18 @ @ public class NativeLibraryTest extends TestCase { 
 	 } 
 } 
 
 + public void testGetProcess ( ) { 
 + try { 
 + NativeLibrary process = NativeLibrary . getProcess ( ) ; 
 + / / Access a common C library function 
 + process . getFunction ( " printf " ) ; 
 + } 
 + catch ( UnsatisfiedLinkError e ) { 
 + / / Not implemented on windows yet 
 + if ( ! Platform . isWindows ( ) ) throw e ; 
 + } 
 + } 
 + 
 public static void main ( String [ ] args ) { 
 junit . textui . TestRunner . run ( NativeLibraryTest . class ) ; 
 }
