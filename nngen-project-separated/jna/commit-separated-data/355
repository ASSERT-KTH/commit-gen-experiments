BLEU SCORE: 0.0379680177759557

TEST MSG: fixed direct - mapping type - mapped pointer result types
GENERATED MSG: Improve error messages when illegal argument / return types are used

TEST DIFF (one line): diff - - git a / native / dispatch . c b / native / dispatch . c <nl> index a79d688 . . 755c231 100644 <nl> - - - a / native / dispatch . c <nl> + + + b / native / dispatch . c <nl> @ @ - 1150 , 6 + 1150 , 9 @ @ fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , void * resp , ffi _ type * typ <nl> if ( type - > type ! = FFI _ TYPE _ POINTER ) { <nl> extract _ value ( env , obj , result , type - > size , JNI _ TRUE ) ; <nl> } <nl> + else { <nl> + * ( jobject * ) result = obj ; <nl> + } <nl> } <nl> } <nl> } <nl> diff - - git a / native / testlib . c b / native / testlib . c <nl> index e407898 . . 24df5a7 100644 <nl> - - - a / native / testlib . c <nl> + + + b / native / testlib . c <nl> @ @ - 158 , 6 + 158 , 14 @ @ returnInt32Argument ( int32 _ t arg ) { <nl> return arg ; <nl> } <nl> <nl> + EXPORT int * <nl> + returnPoint ( int x , int y ) { <nl> + int * p = malloc ( 2 * sizeof ( int ) ) ; <nl> + p [ 0 ] = x ; <nl> + p [ 1 ] = y ; <nl> + return p ; <nl> + } <nl> + <nl> EXPORT int64 _ t <nl> returnInt64Zero ( ) { <nl> int64 _ t value = 0 ; <nl> diff - - git a / src / com / sun / jna / DefaultTypeMapper . java b / src / com / sun / jna / DefaultTypeMapper . java <nl> index 70999bb . . b46311e 100644 <nl> - - - a / src / com / sun / jna / DefaultTypeMapper . java <nl> + + + b / src / com / sun / jna / DefaultTypeMapper . java <nl> @ @ - 117 , 7 + 117 , 7 @ @ public class DefaultTypeMapper implements TypeMapper { <nl> / * * Add a { @ link TypeConverter } to provide bidirectional mapping between <nl> * a native and Java type . <nl> * / <nl> - protected void addTypeConverter ( Class cls , TypeConverter converter ) { <nl> + public void addTypeConverter ( Class cls , TypeConverter converter ) { <nl> addFromNativeConverter ( cls , converter ) ; <nl> addToNativeConverter ( cls , converter ) ; <nl> } <nl> diff - - git a / test / com / sun / jna / DirectTypeMapperTest . java b / test / com / sun / jna / DirectTypeMapperTest . java <nl> index 034b572 . . 704bcdb 100644 <nl> - - - a / test / com / sun / jna / DirectTypeMapperTest . java <nl> + + + b / test / com / sun / jna / DirectTypeMapperTest . java <nl> @ @ - 13 , 10 + 13 , 12 @ @ <nl> <nl> package com . sun . jna ; <nl> <nl> + import java . awt . Point ; <nl> import java . lang . annotation . ElementType ; <nl> import java . lang . annotation . Retention ; <nl> import java . lang . annotation . RetentionPolicy ; <nl> import java . lang . annotation . Target ; <nl> + import java . lang . reflect . Field ; <nl> import java . util . HashMap ; <nl> import java . util . Map ; <nl> import junit . framework . TestCase ; <nl> @ @ - 156 , 6 + 158 , 48 @ @ public class DirectTypeMapperTest extends TestCase { <nl> assertFalse ( " Failed to convert integer return to boolean FALSE " , <nl> lib . returnInt32Argument ( false ) ) ; <nl> } <nl> + public static class DirectTypeMappedResultTypeTestLibrary { <nl> + public native Point returnPoint ( int x , int y ) ; <nl> + static { <nl> + Map options = new HashMap ( ) ; <nl> + DefaultTypeMapper mapper = new DefaultTypeMapper ( ) ; <nl> + mapper . addTypeConverter ( Point . class , new TypeConverter ( ) { <nl> + public Object fromNative ( Object value , FromNativeContext context ) { <nl> + Pointer p = ( Pointer ) value ; <nl> + int x = p . getInt ( 0 ) , y = p . getInt ( 4 ) ; <nl> + Native . free ( Pointer . nativeValue ( p ) ) ; <nl> + return new Point ( x , y ) ; <nl> + } <nl> + public Object toNative ( Object value , ToNativeContext context ) { <nl> + return Pointer . NULL ; / / dummy implementation ( not called ) <nl> + } <nl> + public Class nativeType ( ) { <nl> + return Pointer . class ; <nl> + } <nl> + } ) ; <nl> + options . put ( Library . OPTION _ TYPE _ MAPPER , mapper ) ; <nl> + <nl> + / / Can ' t extend java . awt . Point ; can ' t add : <nl> + / / public final static TypeMapper TYPE _ MAPPER = mapper ; <nl> + / / - > Extend Native . options via reflection : <nl> + try { <nl> + Field f = Native . class . getDeclaredField ( " options " ) ; <nl> + f . setAccessible ( true ) ; <nl> + ( ( Map ) f . get ( null ) ) . put ( Point . class , options ) ; <nl> + } <nl> + catch ( Exception e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + <nl> + Native . register ( NativeLibrary . getInstance ( " testlib " , options ) ) ; <nl> + } <nl> + } <nl> + public void testTypeMapperResultTypeConversion ( ) throws Exception { <nl> + DirectTypeMappedResultTypeTestLibrary lib = new DirectTypeMappedResultTypeTestLibrary ( ) ; <nl> + Point p = lib . returnPoint ( 1234 , 5678 ) ; <nl> + assertEquals ( " Failed to convert int * return to java . awt . Point " , 1234 , p . x ) ; <nl> + assertEquals ( " Failed to convert int * return to java . awt . Point " , 5678 , p . y ) ; <nl> + } <nl> <nl> public static void main ( String [ ] args ) { <nl> junit . textui . TestRunner . run ( DirectTypeMapperTest . class ) ;
NEAREST DIFF (one line): diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html <nl> index 59606ed . . a01e107 100644 <nl> - - - a / jnalib / src / com / sun / jna / overview . html <nl> + + + b / jnalib / src / com / sun / jna / overview . html <nl> @ @ - 430 , 7 + 430 , 9 @ @ class Line2 extends Structure { <nl> } <nl> < / pre > < / code > < / blockquote > <nl> <nl> - The more general case is just a pointer to a buffer : < br > <nl> + The more general case is just a pointer to memory . This allows you to define <nl> + the field without necessarily defining the inner structure itself , similar to <nl> + declaring a struct without defining it in C : < br > <nl> <nl> < blockquote > < code > < pre > <nl> / / Original C code

TEST DIFF:
diff - - git a / native / dispatch . c b / native / dispatch . c 
 index a79d688 . . 755c231 100644 
 - - - a / native / dispatch . c 
 + + + b / native / dispatch . c 
 @ @ - 1150 , 6 + 1150 , 9 @ @ fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , void * resp , ffi _ type * typ 
 if ( type - > type ! = FFI _ TYPE _ POINTER ) { 
 extract _ value ( env , obj , result , type - > size , JNI _ TRUE ) ; 
 } 
 + else { 
 + * ( jobject * ) result = obj ; 
 + } 
 } 
 } 
 } 
 diff - - git a / native / testlib . c b / native / testlib . c 
 index e407898 . . 24df5a7 100644 
 - - - a / native / testlib . c 
 + + + b / native / testlib . c 
 @ @ - 158 , 6 + 158 , 14 @ @ returnInt32Argument ( int32 _ t arg ) { 
 return arg ; 
 } 
 
 + EXPORT int * 
 + returnPoint ( int x , int y ) { 
 + int * p = malloc ( 2 * sizeof ( int ) ) ; 
 + p [ 0 ] = x ; 
 + p [ 1 ] = y ; 
 + return p ; 
 + } 
 + 
 EXPORT int64 _ t 
 returnInt64Zero ( ) { 
 int64 _ t value = 0 ; 
 diff - - git a / src / com / sun / jna / DefaultTypeMapper . java b / src / com / sun / jna / DefaultTypeMapper . java 
 index 70999bb . . b46311e 100644 
 - - - a / src / com / sun / jna / DefaultTypeMapper . java 
 + + + b / src / com / sun / jna / DefaultTypeMapper . java 
 @ @ - 117 , 7 + 117 , 7 @ @ public class DefaultTypeMapper implements TypeMapper { 
 / * * Add a { @ link TypeConverter } to provide bidirectional mapping between 
 * a native and Java type . 
 * / 
 - protected void addTypeConverter ( Class cls , TypeConverter converter ) { 
 + public void addTypeConverter ( Class cls , TypeConverter converter ) { 
 addFromNativeConverter ( cls , converter ) ; 
 addToNativeConverter ( cls , converter ) ; 
 } 
 diff - - git a / test / com / sun / jna / DirectTypeMapperTest . java b / test / com / sun / jna / DirectTypeMapperTest . java 
 index 034b572 . . 704bcdb 100644 
 - - - a / test / com / sun / jna / DirectTypeMapperTest . java 
 + + + b / test / com / sun / jna / DirectTypeMapperTest . java 
 @ @ - 13 , 10 + 13 , 12 @ @ 
 
 package com . sun . jna ; 
 
 + import java . awt . Point ; 
 import java . lang . annotation . ElementType ; 
 import java . lang . annotation . Retention ; 
 import java . lang . annotation . RetentionPolicy ; 
 import java . lang . annotation . Target ; 
 + import java . lang . reflect . Field ; 
 import java . util . HashMap ; 
 import java . util . Map ; 
 import junit . framework . TestCase ; 
 @ @ - 156 , 6 + 158 , 48 @ @ public class DirectTypeMapperTest extends TestCase { 
 assertFalse ( " Failed to convert integer return to boolean FALSE " , 
 lib . returnInt32Argument ( false ) ) ; 
 } 
 + public static class DirectTypeMappedResultTypeTestLibrary { 
 + public native Point returnPoint ( int x , int y ) ; 
 + static { 
 + Map options = new HashMap ( ) ; 
 + DefaultTypeMapper mapper = new DefaultTypeMapper ( ) ; 
 + mapper . addTypeConverter ( Point . class , new TypeConverter ( ) { 
 + public Object fromNative ( Object value , FromNativeContext context ) { 
 + Pointer p = ( Pointer ) value ; 
 + int x = p . getInt ( 0 ) , y = p . getInt ( 4 ) ; 
 + Native . free ( Pointer . nativeValue ( p ) ) ; 
 + return new Point ( x , y ) ; 
 + } 
 + public Object toNative ( Object value , ToNativeContext context ) { 
 + return Pointer . NULL ; / / dummy implementation ( not called ) 
 + } 
 + public Class nativeType ( ) { 
 + return Pointer . class ; 
 + } 
 + } ) ; 
 + options . put ( Library . OPTION _ TYPE _ MAPPER , mapper ) ; 
 + 
 + / / Can ' t extend java . awt . Point ; can ' t add : 
 + / / public final static TypeMapper TYPE _ MAPPER = mapper ; 
 + / / - > Extend Native . options via reflection : 
 + try { 
 + Field f = Native . class . getDeclaredField ( " options " ) ; 
 + f . setAccessible ( true ) ; 
 + ( ( Map ) f . get ( null ) ) . put ( Point . class , options ) ; 
 + } 
 + catch ( Exception e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + 
 + Native . register ( NativeLibrary . getInstance ( " testlib " , options ) ) ; 
 + } 
 + } 
 + public void testTypeMapperResultTypeConversion ( ) throws Exception { 
 + DirectTypeMappedResultTypeTestLibrary lib = new DirectTypeMappedResultTypeTestLibrary ( ) ; 
 + Point p = lib . returnPoint ( 1234 , 5678 ) ; 
 + assertEquals ( " Failed to convert int * return to java . awt . Point " , 1234 , p . x ) ; 
 + assertEquals ( " Failed to convert int * return to java . awt . Point " , 5678 , p . y ) ; 
 + } 
 
 public static void main ( String [ ] args ) { 
 junit . textui . TestRunner . run ( DirectTypeMapperTest . class ) ;

NEAREST DIFF:
diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html 
 index 59606ed . . a01e107 100644 
 - - - a / jnalib / src / com / sun / jna / overview . html 
 + + + b / jnalib / src / com / sun / jna / overview . html 
 @ @ - 430 , 7 + 430 , 9 @ @ class Line2 extends Structure { 
 } 
 < / pre > < / code > < / blockquote > 
 
 - The more general case is just a pointer to a buffer : < br > 
 + The more general case is just a pointer to memory . This allows you to define 
 + the field without necessarily defining the inner structure itself , similar to 
 + declaring a struct without defining it in C : < br > 
 
 < blockquote > < code > < pre > 
 / / Original C code
