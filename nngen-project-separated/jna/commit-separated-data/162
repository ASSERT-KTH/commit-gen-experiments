BLEU SCORE: 0.0011392542366888657

TEST MSG: Added additional security functions
GENERATED MSG: Add platform . win32 . Kernel32 . DeleteFile and com . sun . jna . platform . win32 . deleteFile .

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 8407152 . . 014fb52 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 55 , 6 + 55 , 8 @ @ Features <nl> * [ # 654 ] ( https : / / github . com / java - native - access / jna / pull / 654 ) : Support named arguments for ` com . sun . jna . platform . win32 . COM . util . CallbackProxy ` based callbacks - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> * [ # 659 ] ( https : / / github . com / java - native - access / jna / issues / 659 ) : Enable LCID ( locale ) override for ` com . sun . jna . platform . win32 . COM . util . ProxyObject ` - based COM calls - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> * [ # 665 ] ( https : / / github . com / java - native - access / jna / pull / 665 ) : Added ` XSetWMProtocols ` and ` XGetWMProtocols ` to ` com . sun . jna . platform . unix . X11 ` - [ @ zainab - ali ] ( https : / / github . com / zainab - ali ) . <nl> + * [ # 667 ] ( https : / / github . com / java - native - access / jna / pull / 667 ) : Added SetFileSecurity , GetSecurityInfo and SetSecurityInfo to ` com . sun . jna . platform . win32 . Advapi32 ` - [ @ amarcionek ] ( https : / / github . com / amarcionek ) . <nl> + * [ # 667 ] ( https : / / github . com / java - native - access / jna / pull / 667 ) : Added NtSetSecurityObject and NtQuerySecurityObject to ` com . sun . jna . platform . win32 . NtDll ` - [ @ amarcionek ] ( https : / / github . com / amarcionek ) . <nl> * [ # 680 ] ( https : / / github . com / java - native - access / jna / pull / 680 ) : Added ` SetCurrentProcessExplicitAppUserModelID ` and ` GetCurrentProcessExplicitAppUserModelID ` to ` com . sun . jna . platform . win32 . Shell32 ` for setting the [ System . AppUserModel . ID ] ( https : / / msdn . microsoft . com / en - us / library / windows / desktop / dd391569 . aspx ) of the host process - [ @ rednoah ] ( https : / / github . com / rednoah ) . <nl> <nl> Bug Fixes <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> index 520d2eb . . a086bb2 100755 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> @ @ - 1635 , 6 + 1635 , 144 @ @ public interface Advapi32 extends StdCallLibrary { <nl> IntByReference lpnLengthNeeded ) ; <nl> <nl> / * * <nl> + * The SetFileSecurity function sets the security of a file or directory object . <nl> + * This function is obsolete . Use the SetNamedSecurityInfo function instead . <nl> + * <nl> + * @ param lpFileName <nl> + * A pointer to a null - terminated string that specifies the file or directory for which security is set . <nl> + * Note that security applied to a directory is not inherited by its children . <nl> + * @ param SecurityInformation <nl> + * Specifies a SECURITY _ INFORMATION structure that identifies the contents of the security descriptor <nl> + * pointed to by the pSecurityDescriptor parameter . <nl> + * @ param pSecurityDescriptor <nl> + * A pointer to a SECURITY _ DESCRIPTOR structure . <nl> + * @ return <nl> + * If the function succeeds , the function returns nonzero . If the function fails , it returns zero . To get <nl> + * extended error information , call GetLastError . <nl> + * / <nl> + boolean SetFileSecurity ( String lpFileName , int SecurityInformation , Pointer pSecurityDescriptor ) ; <nl> + <nl> + / * * <nl> + * The GetSecurityInfo function retrieves a copy of the security descriptor for an object specified by a handle . <nl> + * <nl> + * @ param handle [ in ] <nl> + * A handle to the object from which to retrieve security information . <nl> + * @ param ObjectType [ in ] <nl> + * SE _ OBJECT _ TYPE enumeration value that indicates the type of object . <nl> + * @ param SecurityInfo [ in ] <nl> + * A set of bit flags that indicate the type of security information to retrieve . See WinNT * _ SECURITY _ INFORMATION <nl> + * @ param ppsidOwner [ out , optional ] <nl> + * A pointer to a variable that receives a pointer to the owner SID in the security descriptor returned <nl> + * in ppSecurityDescriptor . The returned pointer is valid only if you set the OWNER _ SECURITY _ INFORMATION flag . <nl> + * This parameter can be NULL if you do not need the owner SID . <nl> + * @ param ppsidGroup [ in , optional ] <nl> + * A pointer to a variable that receives a pointer to the primary group SID in the returned security descriptor . <nl> + * The returned pointer is valid only if you set the GROUP _ SECURITY _ INFORMATION flag . This parameter can be NULL <nl> + * if you do not need the group SID . <nl> + * @ param ppDacl [ in , optional ] <nl> + * A pointer to a variable that receives a pointer to the DACL in the returned security descriptor . The returned <nl> + * pointer is valid only if you set the DACL _ SECURITY _ INFORMATION flag . This parameter can be NULL if you do not <nl> + * need the DACL . <nl> + * @ param ppSacl [ in , optional ] <nl> + * A pointer to a variable that receives a pointer to the SACL in the returned security descriptor . The returned <nl> + * pointer is valid only if you set the SACL _ SECURITY _ INFORMATION flag . This parameter can be NULL if you do not <nl> + * need the SACL . <nl> + * @ param ppSecurityDescriptor <nl> + * A pointer to a variable that receives a pointer to the security descriptor of the object . When you have finished <nl> + * using the pointer , free the returned buffer by calling the LocalFree function . <nl> + * This parameter is required if any one of the ppsidOwner , ppsidGroup , ppDacl , or ppSacl parameters is not NULL . <nl> + * @ return whether the call succeeded . A nonzero return is a failure . <nl> + * <nl> + * < p > < b > NOTES : < / b > < / p > <nl> + * < p > 1 . If the ppsidOwner , ppsidGroup , ppDacl , and ppSacl parameters are non - NULL , and the SecurityInfo parameter specifies <nl> + * that they be retrieved from the object , those parameters will point to the corresponding parameters in the security descriptor <nl> + * returned in ppSecurityDescriptor . < / p > <nl> + * < p > 2 . To read the owner , group , or DACL from the object ' s security descriptor , the calling process must have been granted <nl> + * READ _ CONTROL access when the handle was opened . To get READ _ CONTROL access , the caller must be the owner of the object or <nl> + * the object ' s DACL must grant the access . < / p > <nl> + * < p > 3 . To read the SACL from the security descriptor , the calling process must have been granted ACCESS _ SYSTEM _ SECURITY access <nl> + * when the handle was opened . The proper way to get this access is to enable the SE _ SECURITY _ NAME privilege in the caller ' s <nl> + * current token , open the handle for ACCESS _ SYSTEM _ SECURITY access , and then disable the privilege . < / p > <nl> + * < p > 4 . If the supplied handle was opened with an ACCESS _ MASK value of MAXIMUM _ ALLOWED , <nl> + * then the SetSecurityInfo function will not propagate ACEs to children . < / p > <nl> + * / <nl> + int GetSecurityInfo ( HANDLE handle , <nl> + int ObjectType , <nl> + int SecurityInfo , <nl> + PointerByReference ppsidOwner , <nl> + PointerByReference ppsidGroup , <nl> + PointerByReference ppDacl , <nl> + PointerByReference ppSacl , <nl> + PointerByReference ppSecurityDescriptor ) ; <nl> + <nl> + / * * <nl> + * The SetSecurityInfo function sets specified security information in <nl> + * the security descriptor of a specified object . The caller identifies the <nl> + * object by a handle . <nl> + * <nl> + * @ param handle [ in ] <nl> + * A handle to the object for which to set security information . <nl> + * @ param ObjectType [ in ] <nl> + * A value of the SE _ OBJECT _ TYPE enumeration that indicates the type <nl> + * of object named by the pObjectName parameter . <nl> + * @ param SecurityInfo [ in ] <nl> + * A set of bit flags that indicate the type of security <nl> + * information to set . See WinNT * _ SECURITY _ INFORMATION <nl> + * @ param ppsidOwner [ in , optional ] <nl> + * A pointer to a SID structure that identifies the owner of the object . <nl> + * If the caller does not have the SeRestorePrivilege constant <nl> + * ( see Privilege Constants ) , this SID must be contained in the <nl> + * caller ' s token , and must have the SE _ GROUP _ OWNER permission enabled . <nl> + * The SecurityInfo parameter must include the OWNER _ SECURITY _ INFORMATION <nl> + * flag . To set the owner , the caller must have WRITE _ OWNER access to <nl> + * the object or have the SE _ TAKE _ OWNERSHIP _ NAME privilege enabled . <nl> + * If you are not setting the owner SID , this parameter can be NULL . <nl> + * @ param ppsidGroup [ in , optional ] <nl> + * A pointer to a SID that identifies the primary group of the object . <nl> + * The SecurityInfo parameter must include the GROUP _ SECURITY _ INFORMATION <nl> + * flag . If you are not setting the primary group SID , this parameter <nl> + * can be NULL . <nl> + * @ param ppDacl [ in , optional ] <nl> + * A pointer to the new DACL for the object . The SecurityInfo parameter <nl> + * must include the DACL _ SECURITY _ INFORMATION flag . The caller must have <nl> + * WRITE _ DAC access to the object or be the owner of the object . If you <nl> + * are not setting the DACL , this parameter can be NULL . <nl> + * @ param ppSacl [ in , optional ] <nl> + * A pointer to the new SACL for the object . The SecurityInfo parameter <nl> + * must include any of the following flags : SACL _ SECURITY _ INFORMATION , <nl> + * LABEL _ SECURITY _ INFORMATION , ATTRIBUTE _ SECURITY _ INFORMATION , <nl> + * SCOPE _ SECURITY _ INFORMATION , or BACKUP _ SECURITY _ INFORMATION . <nl> + * If setting SACL _ SECURITY _ INFORMATION or SCOPE _ SECURITY _ INFORMATION , <nl> + * the caller must have the SE _ SECURITY _ NAME privilege enabled . If <nl> + * you are not setting the SACL , this parameter can be NULL . <nl> + * @ return whether the call succeeded . A nonzero return is a failure . <nl> + * <nl> + * < p > < b > NOTES : < / b > < / p > <nl> + * < p > 1 . If you are setting the discretionary access control list ( DACL ) or any elements <nl> + * in the system access control list ( SACL ) of an object , the system automatically <nl> + * propagates any inheritable access control entries ( ACEs ) to existing child objects , <nl> + * according to the ACE inheritance rules . < / p > <nl> + * < p > 2 . The SetSecurityInfo function does not reorder access - allowed or access - denied <nl> + * ACEs based on the preferred order . When propagating inheritable ACEs to existing <nl> + * child objects , SetSecurityInfo puts inherited ACEs in order after all of the <nl> + * noninherited ACEs in the DACLs of the child objects . < / p > <nl> + * < p > 3 . If share access to the children of the object is not available , this function <nl> + * will not propagate unprotected ACEs to the children . For example , if a directory <nl> + * is opened with exclusive access , the operating system will not propagate unprotected <nl> + * ACEs to the subdirectories or files of that directory when the security on the <nl> + * directory is changed . < / p > <nl> + * < p > 4 . If the supplied handle was opened with an ACCESS _ MASK value of MAXIMUM _ ALLOWED , <nl> + * then the SetSecurityInfo function will not propagate ACEs to children . < / p > <nl> + * / <nl> + int SetSecurityInfo ( HANDLE handle , <nl> + int ObjectType , <nl> + int SecurityInfo , <nl> + Pointer ppsidOwner , <nl> + Pointer ppsidGroup , <nl> + Pointer ppDacl , <nl> + Pointer ppSacl ) ; <nl> + <nl> + / * * <nl> * The GetNamedSecurityInfo function retrieves a copy of the security <nl> * descriptor for an object specified by name <nl> * <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / NtDll . java b / contrib / platform / src / com / sun / jna / platform / win32 / NtDll . java <nl> index 26b74e1 . . 417f38b 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / NtDll . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / NtDll . java <nl> @ @ - 13 , 6 + 13 , 7 @ @ <nl> package com . sun . jna . platform . win32 ; <nl> <nl> import com . sun . jna . Native ; <nl> + import com . sun . jna . Pointer ; <nl> import com . sun . jna . Structure ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> @ @ - 51 , 4 + 52 , 56 @ @ public interface NtDll extends StdCallLibrary { <nl> 	 * / <nl> 	 public int ZwQueryKey ( HANDLE KeyHandle , int KeyInformationClass , <nl> 	 	 	 Structure KeyInformation , int Length , IntByReference ResultLength ) ; <nl> + <nl> + / * * <nl> + * The NtSetSecurityObject routine sets an object ' s security state . <nl> + * @ param handle [ in ] <nl> + * Handle for the object whose security state is to be set . This handle must have the access <nl> + * specified in the Meaning column of the table shown in the description of the <nl> + * SecurityInformation parameter . <nl> + * @ param SecurityInformation [ in ] <nl> + * SECURITY _ INFORMATION value specifying the information to be set . Can be a combination of <nl> + * one or more of the following : <nl> + * DACL _ SECURITY _ INFORMATION <nl> + * Indicates the discretionary access control list ( DACL ) of the object is to be set . Requires WRITE _ DAC access . <nl> + * GROUP _ SECURITY _ INFORMATION <nl> + * Indicates the primary group identifier of the object is to be set . Requires WRITE _ OWNER access . <nl> + * OWNER _ SECURITY _ INFORMATION <nl> + * Indicates the owner identifier of the object is to be set . Requires WRITE _ OWNER access . <nl> + * SACL _ SECURITY _ INFORMATION <nl> + * Indicates the system ACL ( SACL ) of the object is to be set . Requires ACCESS _ SYSTEM _ SECURITY access . <nl> + * @ param pSecurityDescriptor [ in ] <nl> + * Pointer to the security descriptor to be set for the object . <nl> + * @ return <nl> + * NtSetSecurityObject returns STATUS _ SUCCESS or an appropriate error status . <nl> + * / <nl> + public int NtSetSecurityObject ( HANDLE handle , int SecurityInformation , Pointer pSecurityDescriptor ) ; <nl> + <nl> + / * * <nl> + * The NtQuerySecurityObject routine retrieves a copy of an object ' s security descriptor . <nl> + * <nl> + * @ param handle [ in ] <nl> + * Handle for the object whose security descriptor is to be queried . This handle must have the access specified <nl> + * in the Meaning column of the table shown in the description of the SecurityInformation parameter . <nl> + * @ param SecurityInformation [ in ] <nl> + * Pointer to a SECURITY _ INFORMATION value specifying the information to be queried . Can be a combination of <nl> + * one or more of the following : <nl> + * DACL _ SECURITY _ INFORMATION <nl> + * Indicates the discretionary access control list ( DACL ) of the object is to be set . Requires WRITE _ DAC access . <nl> + * GROUP _ SECURITY _ INFORMATION <nl> + * Indicates the primary group identifier of the object is to be set . Requires WRITE _ OWNER access . <nl> + * OWNER _ SECURITY _ INFORMATION <nl> + * Indicates the owner identifier of the object is to be set . Requires WRITE _ OWNER access . <nl> + * SACL _ SECURITY _ INFORMATION <nl> + * Indicates the system ACL ( SACL ) of the object is to be set . Requires ACCESS _ SYSTEM _ SECURITY access . <nl> + * @ param SecurityDescriptor [ out ] <nl> + * Pointer to the security descriptor to be set for the object . <nl> + * @ param Length [ in ] <nl> + * Size , in bytes , of the buffer pointed to by SecurityDescriptor . <nl> + * @ param LengthNeeded [ in ] <nl> + * Pointer to a caller - allocated variable that receives the number of bytes required to store the copied security descriptor . <nl> + * @ return <nl> + * NtQuerySecurityObject returns STATUS _ SUCCESS or an appropriate error status . <nl> + * / <nl> + public int NtQuerySecurityObject ( HANDLE handle , int SecurityInformation , Pointer SecurityDescriptor , int Length , IntByReference LengthNeeded ) ; <nl> } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> index 02bf241 . . beaeef3 100755 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> @ @ - 1005 , 6 + 1005 , 200 @ @ public class Advapi32Test extends TestCase { <nl> 	 assertTrue ( Advapi32 . INSTANCE . RevertToSelf ( ) ) ; <nl> } <nl> <nl> + public void testGetSetFileSecurityNoSACL ( ) throws Exception { <nl> + int infoType = OWNER _ SECURITY _ INFORMATION <nl> + | GROUP _ SECURITY _ INFORMATION <nl> + | DACL _ SECURITY _ INFORMATION ; <nl> + <nl> + int memSize = 64 * 1024 ; <nl> + Memory memorySecurity = new Memory ( memSize ) ; <nl> + IntByReference sizeNeeded = new IntByReference ( 0 ) ; <nl> + / / create a temp file <nl> + File file = createTempFile ( ) ; <nl> + String filePath = file . getAbsolutePath ( ) ; <nl> + <nl> + try { <nl> + <nl> + assertEquals ( " GetFileSecurity ( " + filePath + " ) " , true , <nl> + Advapi32 . INSTANCE . GetFileSecurity ( <nl> + filePath , <nl> + infoType , <nl> + memorySecurity , <nl> + memSize , <nl> + sizeNeeded ) ) ; <nl> + assertEquals ( " SetFileSecurity ( " + filePath + " ) " , true , <nl> + Advapi32 . INSTANCE . SetFileSecurity ( <nl> + filePath , <nl> + infoType , <nl> + memorySecurity ) ) ; <nl> + } finally { <nl> + file . delete ( ) ; <nl> + } <nl> + } <nl> + <nl> + public void testGetSetSecurityInfoNoSACL ( ) throws Exception { <nl> + int infoType = OWNER _ SECURITY _ INFORMATION <nl> + | GROUP _ SECURITY _ INFORMATION <nl> + | DACL _ SECURITY _ INFORMATION ; <nl> + <nl> + PointerByReference ppsidOwner = new PointerByReference ( ) ; <nl> + PointerByReference ppsidGroup = new PointerByReference ( ) ; <nl> + PointerByReference ppDacl = new PointerByReference ( ) ; <nl> + PointerByReference ppSecurityDescriptor = new PointerByReference ( ) ; <nl> + / / create a temp file <nl> + File file = createTempFile ( ) ; <nl> + String filePath = file . getAbsolutePath ( ) ; <nl> + <nl> + HANDLE hFile = Kernel32 . INSTANCE . CreateFile ( <nl> + filePath , <nl> + WinNT . GENERIC _ ALL | WinNT . WRITE _ OWNER | WinNT . WRITE _ DAC , <nl> + WinNT . FILE _ SHARE _ READ , <nl> + new WinBase . SECURITY _ ATTRIBUTES ( ) , <nl> + WinNT . OPEN _ EXISTING , <nl> + WinNT . FILE _ ATTRIBUTE _ NORMAL , <nl> + null ) ; <nl> + assertFalse ( " Failed to create file handle : " + filePath , WinBase . INVALID _ HANDLE _ VALUE . equals ( hFile ) ) ; <nl> + <nl> + try { <nl> + try { <nl> + <nl> + assertEquals ( " GetSecurityInfo ( " + filePath + " ) " , 0 , <nl> + Advapi32 . INSTANCE . GetSecurityInfo ( <nl> + hFile , <nl> + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , <nl> + infoType , <nl> + ppsidOwner , <nl> + ppsidGroup , <nl> + ppDacl , <nl> + null , <nl> + ppSecurityDescriptor ) ) ; <nl> + <nl> + assertEquals ( " SetSecurityInfo ( " + filePath + " ) " , 0 , <nl> + Advapi32 . INSTANCE . SetSecurityInfo ( <nl> + hFile , <nl> + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , <nl> + infoType , <nl> + ppsidOwner . getValue ( ) , <nl> + ppsidGroup . getValue ( ) , <nl> + ppDacl . getValue ( ) , <nl> + null ) ) ; <nl> + } finally { <nl> + Kernel32 . INSTANCE . CloseHandle ( hFile ) ; <nl> + file . delete ( ) ; <nl> + } <nl> + } finally { <nl> + Kernel32Util . freeLocalMemory ( ppSecurityDescriptor . getValue ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + public void testGetSetSecurityInfoForFileWithSACL ( ) throws Exception { <nl> + boolean impersontating = false ; <nl> + <nl> + HANDLEByReference phToken = new HANDLEByReference ( ) ; <nl> + HANDLEByReference phTokenDuplicate = new HANDLEByReference ( ) ; <nl> + try { <nl> + / / open thread or process token , elevate <nl> + if ( ! Advapi32 . INSTANCE . OpenThreadToken ( <nl> + Kernel32 . INSTANCE . GetCurrentThread ( ) , <nl> + TOKEN _ ADJUST _ PRIVILEGES , <nl> + false , <nl> + phToken ) ) <nl> + { <nl> + assertEquals ( W32Errors . ERROR _ NO _ TOKEN , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + / / OpenThreadToken may fail with W32Errors . ERROR _ NO _ TOKEN if current thread is anonymous . When this happens , <nl> + / / we need to open the process token to duplicate it , then set our thread token . <nl> + assertTrue ( Advapi32 . INSTANCE . OpenProcessToken ( Kernel32 . INSTANCE . GetCurrentProcess ( ) , TOKEN _ DUPLICATE , phToken ) ) ; <nl> + / / Process token opened , now duplicate <nl> + assertTrue ( Advapi32 . INSTANCE . DuplicateTokenEx ( <nl> + phToken . getValue ( ) , <nl> + TOKEN _ ADJUST _ PRIVILEGES | TOKEN _ IMPERSONATE , <nl> + null , <nl> + SECURITY _ IMPERSONATION _ LEVEL . SecurityImpersonation , <nl> + TOKEN _ TYPE . TokenImpersonation , <nl> + phTokenDuplicate ) ) ; <nl> + / / And set thread token . <nl> + assertTrue ( Advapi32 . INSTANCE . SetThreadToken ( null , phTokenDuplicate . getValue ( ) ) ) ; <nl> + impersontating = true ; <nl> + } <nl> + <nl> + / / Which token to adjust depends on whether we had to impersonate or not . <nl> + HANDLE tokenAdjust = impersontating ? phTokenDuplicate . getValue ( ) : phToken . getValue ( ) ; <nl> + <nl> + WinNT . TOKEN _ PRIVILEGES tp = new WinNT . TOKEN _ PRIVILEGES ( 1 ) ; <nl> + WinNT . LUID pLuid = new WinNT . LUID ( ) ; <nl> + <nl> + assertTrue ( Advapi32 . INSTANCE . LookupPrivilegeValue ( null , SE _ SECURITY _ NAME , pLuid ) ) ; <nl> + tp . Privileges [ 0 ] = new WinNT . LUID _ AND _ ATTRIBUTES ( pLuid , new DWORD ( WinNT . SE _ PRIVILEGE _ ENABLED ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . AdjustTokenPrivileges ( tokenAdjust , false , tp , 0 , null , null ) ) ; <nl> + <nl> + assertTrue ( Advapi32 . INSTANCE . LookupPrivilegeValue ( null , SE _ RESTORE _ NAME , pLuid ) ) ; <nl> + tp . Privileges [ 0 ] = new WinNT . LUID _ AND _ ATTRIBUTES ( pLuid , new DWORD ( WinNT . SE _ PRIVILEGE _ ENABLED ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . AdjustTokenPrivileges ( tokenAdjust , false , tp , 0 , null , null ) ) ; <nl> + <nl> + / / create a temp file <nl> + File file = createTempFile ( ) ; <nl> + int infoType = OWNER _ SECURITY _ INFORMATION <nl> + | GROUP _ SECURITY _ INFORMATION <nl> + | DACL _ SECURITY _ INFORMATION <nl> + | SACL _ SECURITY _ INFORMATION ; <nl> + <nl> + PointerByReference ppsidOwner = new PointerByReference ( ) ; <nl> + PointerByReference ppsidGroup = new PointerByReference ( ) ; <nl> + PointerByReference ppDacl = new PointerByReference ( ) ; <nl> + PointerByReference ppSacl = new PointerByReference ( ) ; <nl> + PointerByReference ppSecurityDescriptor = new PointerByReference ( ) ; <nl> + String filePath = file . getAbsolutePath ( ) ; <nl> + HANDLE hFile = WinBase . INVALID _ HANDLE _ VALUE ; <nl> + <nl> + try { <nl> + try { <nl> + hFile = Kernel32 . INSTANCE . CreateFile ( <nl> + filePath , <nl> + WinNT . ACCESS _ SYSTEM _ SECURITY | WinNT . GENERIC _ WRITE | WinNT . WRITE _ OWNER | WinNT . WRITE _ DAC , <nl> + WinNT . FILE _ SHARE _ READ , <nl> + new WinBase . SECURITY _ ATTRIBUTES ( ) , <nl> + WinNT . OPEN _ EXISTING , <nl> + WinNT . FILE _ ATTRIBUTE _ NORMAL , <nl> + null ) ; <nl> + assertEquals ( " GetSecurityInfo ( " + filePath + " ) " , 0 , <nl> + Advapi32 . INSTANCE . GetSecurityInfo ( <nl> + hFile , <nl> + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , <nl> + infoType , <nl> + ppsidOwner , <nl> + ppsidGroup , <nl> + ppDacl , <nl> + ppSacl , <nl> + ppSecurityDescriptor ) ) ; <nl> + assertEquals ( " SetSecurityInfo ( " + filePath + " ) " , 0 , <nl> + Advapi32 . INSTANCE . SetSecurityInfo ( <nl> + hFile , <nl> + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , <nl> + infoType , <nl> + ppsidOwner . getValue ( ) , <nl> + ppsidGroup . getValue ( ) , <nl> + ppDacl . getValue ( ) , <nl> + ppSacl . getValue ( ) ) ) ; <nl> + } finally { <nl> + if ( hFile ! = WinBase . INVALID _ HANDLE _ VALUE ) <nl> + Kernel32 . INSTANCE . CloseHandle ( hFile ) ; <nl> + file . delete ( ) ; <nl> + } <nl> + } finally { <nl> + Kernel32Util . freeLocalMemory ( ppSecurityDescriptor . getValue ( ) ) ; <nl> + } <nl> + <nl> + if ( impersontating ) { <nl> + assertTrue ( " SetThreadToken " , Advapi32 . INSTANCE . SetThreadToken ( null , null ) ) ; <nl> + } <nl> + else { <nl> + tp . Privileges [ 0 ] = new WinNT . LUID _ AND _ ATTRIBUTES ( pLuid , new DWORD ( 0 ) ) ; <nl> + assertTrue ( " AdjustTokenPrivileges " , Advapi32 . INSTANCE . AdjustTokenPrivileges ( tokenAdjust , false , tp , 0 , null , null ) ) ; <nl> + } <nl> + } finally { <nl> + Kernel32Util . closeHandleRefs ( phToken , phTokenDuplicate ) ; <nl> + } <nl> + } <nl> <nl> public void testGetNamedSecurityInfoForFileNoSACL ( ) throws Exception { <nl> int infoType = OWNER _ SECURITY _ INFORMATION <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / NtDllTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / NtDllTest . java <nl> index bf832a2 . . 378e77a 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / NtDllTest . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / NtDllTest . java <nl> @ @ - 12 , 13 + 12 , 22 @ @ <nl> * / <nl> package com . sun . jna . platform . win32 ; <nl> <nl> - import junit . framework . TestCase ; <nl> + import static com . sun . jna . platform . win32 . WinNT . DACL _ SECURITY _ INFORMATION ; <nl> + import static com . sun . jna . platform . win32 . WinNT . GROUP _ SECURITY _ INFORMATION ; <nl> + import static com . sun . jna . platform . win32 . WinNT . OWNER _ SECURITY _ INFORMATION ; <nl> + <nl> + import java . io . File ; <nl> + import java . io . FileWriter ; <nl> <nl> + import com . sun . jna . Memory ; <nl> import com . sun . jna . platform . win32 . Wdm . KEY _ BASIC _ INFORMATION ; <nl> import com . sun . jna . platform . win32 . Wdm . KEY _ INFORMATION _ CLASS ; <nl> + import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> <nl> + import junit . framework . TestCase ; <nl> + <nl> / * * <nl> * @ author dblock [ at ] dblock [ dot ] org <nl> * / <nl> @ @ - 49 , 4 + 58 , 63 @ @ public class NtDllTest extends TestCase { <nl> 	 / / close key <nl> 	 assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . RegCloseKey ( phKey . getValue ( ) ) ) ; 	 	 	 	 <nl> } <nl> + <nl> + public void testNtQuerySetSecurityObjectNoSACL ( ) throws Exception { <nl> + int infoType = OWNER _ SECURITY _ INFORMATION <nl> + | GROUP _ SECURITY _ INFORMATION <nl> + | DACL _ SECURITY _ INFORMATION ; <nl> + <nl> + / / create a temp file <nl> + File file = createTempFile ( ) ; <nl> + String filePath = file . getAbsolutePath ( ) ; <nl> + HANDLE hFile = WinBase . INVALID _ HANDLE _ VALUE ; <nl> + <nl> + try { <nl> + hFile = Kernel32 . INSTANCE . CreateFile ( <nl> + filePath , <nl> + WinNT . GENERIC _ WRITE | WinNT . WRITE _ OWNER | WinNT . WRITE _ DAC , <nl> + WinNT . FILE _ SHARE _ READ , <nl> + new WinBase . SECURITY _ ATTRIBUTES ( ) , <nl> + WinNT . OPEN _ EXISTING , <nl> + WinNT . FILE _ ATTRIBUTE _ NORMAL , <nl> + null ) ; <nl> + assertFalse ( " Failed to create file handle : " + filePath , WinBase . INVALID _ HANDLE _ VALUE . equals ( hFile ) ) ; <nl> + <nl> + int Length = 64 * 1024 ; <nl> + Memory SecurityDescriptor = new Memory ( Length ) ; <nl> + IntByReference LengthNeeded = new IntByReference ( ) ; <nl> + <nl> + assertEquals ( " NtQuerySecurityObject ( " + filePath + " ) " , 0 , <nl> + NtDll . INSTANCE . NtQuerySecurityObject ( <nl> + hFile , <nl> + infoType , <nl> + SecurityDescriptor , <nl> + Length , <nl> + LengthNeeded ) ) ; <nl> + assertTrue ( LengthNeeded . getValue ( ) > 0 ) ; <nl> + assertTrue ( LengthNeeded . getValue ( ) < 64 * 1024 ) ; <nl> + assertEquals ( " NtSetSecurityObject ( " + filePath + " ) " , 0 , <nl> + NtDll . INSTANCE . NtSetSecurityObject ( <nl> + hFile , <nl> + infoType , <nl> + SecurityDescriptor ) ) ; <nl> + } finally { <nl> + if ( hFile ! = WinBase . INVALID _ HANDLE _ VALUE ) <nl> + Kernel32 . INSTANCE . CloseHandle ( hFile ) ; <nl> + file . delete ( ) ; <nl> + } <nl> + } <nl> + <nl> + private File createTempFile ( ) throws Exception { <nl> + String filePath = System . getProperty ( " java . io . tmpdir " ) + System . nanoTime ( ) <nl> + + " . text " ; <nl> + File file = new File ( filePath ) ; <nl> + file . createNewFile ( ) ; <nl> + FileWriter fileWriter = new FileWriter ( file ) ; <nl> + for ( int i = 0 ; i < 1000 ; i + + ) { <nl> + fileWriter . write ( " Sample text " + i + System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> + fileWriter . close ( ) ; <nl> + return file ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c <nl> index 383d49f . . b3450f8 100644 <nl> - - - a / jnalib / native / dispatch . c <nl> + + + b / jnalib / native / dispatch . c <nl> @ @ - 992 , 7 + 992 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1write _ _ J _ 3SII <nl> * Signature : ( JB ) J <nl> * / <nl> JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1indexOf _ _ JB <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> { <nl> jbyte * peer = ( jbyte * ) L2A ( addr ) ; <nl> volatile jlong i = 0 ; <nl> @ @ - 1103 , 7 + 1103 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1read _ _ J _ 3SII <nl> * Signature : ( J ) B <nl> * / <nl> JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jbyte res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1116 , 7 + 1116 , 7 @ @ JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte <nl> * Signature : ( J ) C <nl> * / <nl> JNIEXPORT jchar JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getChar <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> wchar _ t res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1153 , 7 + 1153 , 7 @ @ JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDirectByteBuffer <nl> * Signature : ( J ) D <nl> * / <nl> JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jdouble res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1166 , 7 + 1166 , 7 @ @ JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble <nl> * Signature : ( J ) F <nl> * / <nl> JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jfloat res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1179 , 7 + 1179 , 7 @ @ JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat <nl> * Signature : ( J ) I <nl> * / <nl> JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jint res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1192 , 7 + 1192 , 7 @ @ JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt <nl> * Signature : ( J ) J <nl> * / <nl> JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jlong res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1205 , 7 + 1205 , 7 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong <nl> * Signature : ( J ) S <nl> * / <nl> JNIEXPORT jshort JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getShort <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jshort res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1229 , 7 + 1229 , 7 @ @ JNIEXPORT jstring JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getString <nl> * Signature : ( JJB ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) <nl> { <nl> MEMSET ( L2A ( addr ) , ( int ) value , ( size _ t ) count ) ; <nl> } <nl> @ @ - 1240 , 7 + 1240 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory <nl> * Signature : ( JB ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1251 , 7 + 1251 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte <nl> * Signature : ( JC ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jchar value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jchar value ) <nl> { <nl> wchar _ t ch = value ; <nl> MEMCPY ( L2A ( addr ) , & ch , sizeof ( ch ) ) ; <nl> @ @ - 1263 , 7 + 1263 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar <nl> * Signature : ( JJ ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> { <nl> void * ptr = L2A ( value ) ; <nl> MEMCPY ( L2A ( addr ) , & ptr , sizeof ( void * ) ) ; <nl> @ @ - 1275 , 7 + 1275 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer <nl> * Signature : ( JD ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jdouble value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jdouble value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1286 , 7 + 1286 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble <nl> * Signature : ( JF ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jfloat value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jfloat value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1297 , 7 + 1297 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat <nl> * Signature : ( JI ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jint value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jint value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1308 , 7 + 1308 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt <nl> * Signature : ( JJ ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1319 , 7 + 1319 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong <nl> * Signature : ( JS ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setShort <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jshort value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jshort value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> }

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 8407152 . . 014fb52 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 55 , 6 + 55 , 8 @ @ Features 
 * [ # 654 ] ( https : / / github . com / java - native - access / jna / pull / 654 ) : Support named arguments for ` com . sun . jna . platform . win32 . COM . util . CallbackProxy ` based callbacks - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 * [ # 659 ] ( https : / / github . com / java - native - access / jna / issues / 659 ) : Enable LCID ( locale ) override for ` com . sun . jna . platform . win32 . COM . util . ProxyObject ` - based COM calls - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 * [ # 665 ] ( https : / / github . com / java - native - access / jna / pull / 665 ) : Added ` XSetWMProtocols ` and ` XGetWMProtocols ` to ` com . sun . jna . platform . unix . X11 ` - [ @ zainab - ali ] ( https : / / github . com / zainab - ali ) . 
 + * [ # 667 ] ( https : / / github . com / java - native - access / jna / pull / 667 ) : Added SetFileSecurity , GetSecurityInfo and SetSecurityInfo to ` com . sun . jna . platform . win32 . Advapi32 ` - [ @ amarcionek ] ( https : / / github . com / amarcionek ) . 
 + * [ # 667 ] ( https : / / github . com / java - native - access / jna / pull / 667 ) : Added NtSetSecurityObject and NtQuerySecurityObject to ` com . sun . jna . platform . win32 . NtDll ` - [ @ amarcionek ] ( https : / / github . com / amarcionek ) . 
 * [ # 680 ] ( https : / / github . com / java - native - access / jna / pull / 680 ) : Added ` SetCurrentProcessExplicitAppUserModelID ` and ` GetCurrentProcessExplicitAppUserModelID ` to ` com . sun . jna . platform . win32 . Shell32 ` for setting the [ System . AppUserModel . ID ] ( https : / / msdn . microsoft . com / en - us / library / windows / desktop / dd391569 . aspx ) of the host process - [ @ rednoah ] ( https : / / github . com / rednoah ) . 
 
 Bug Fixes 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 index 520d2eb . . a086bb2 100755 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 @ @ - 1635 , 6 + 1635 , 144 @ @ public interface Advapi32 extends StdCallLibrary { 
 IntByReference lpnLengthNeeded ) ; 
 
 / * * 
 + * The SetFileSecurity function sets the security of a file or directory object . 
 + * This function is obsolete . Use the SetNamedSecurityInfo function instead . 
 + * 
 + * @ param lpFileName 
 + * A pointer to a null - terminated string that specifies the file or directory for which security is set . 
 + * Note that security applied to a directory is not inherited by its children . 
 + * @ param SecurityInformation 
 + * Specifies a SECURITY _ INFORMATION structure that identifies the contents of the security descriptor 
 + * pointed to by the pSecurityDescriptor parameter . 
 + * @ param pSecurityDescriptor 
 + * A pointer to a SECURITY _ DESCRIPTOR structure . 
 + * @ return 
 + * If the function succeeds , the function returns nonzero . If the function fails , it returns zero . To get 
 + * extended error information , call GetLastError . 
 + * / 
 + boolean SetFileSecurity ( String lpFileName , int SecurityInformation , Pointer pSecurityDescriptor ) ; 
 + 
 + / * * 
 + * The GetSecurityInfo function retrieves a copy of the security descriptor for an object specified by a handle . 
 + * 
 + * @ param handle [ in ] 
 + * A handle to the object from which to retrieve security information . 
 + * @ param ObjectType [ in ] 
 + * SE _ OBJECT _ TYPE enumeration value that indicates the type of object . 
 + * @ param SecurityInfo [ in ] 
 + * A set of bit flags that indicate the type of security information to retrieve . See WinNT * _ SECURITY _ INFORMATION 
 + * @ param ppsidOwner [ out , optional ] 
 + * A pointer to a variable that receives a pointer to the owner SID in the security descriptor returned 
 + * in ppSecurityDescriptor . The returned pointer is valid only if you set the OWNER _ SECURITY _ INFORMATION flag . 
 + * This parameter can be NULL if you do not need the owner SID . 
 + * @ param ppsidGroup [ in , optional ] 
 + * A pointer to a variable that receives a pointer to the primary group SID in the returned security descriptor . 
 + * The returned pointer is valid only if you set the GROUP _ SECURITY _ INFORMATION flag . This parameter can be NULL 
 + * if you do not need the group SID . 
 + * @ param ppDacl [ in , optional ] 
 + * A pointer to a variable that receives a pointer to the DACL in the returned security descriptor . The returned 
 + * pointer is valid only if you set the DACL _ SECURITY _ INFORMATION flag . This parameter can be NULL if you do not 
 + * need the DACL . 
 + * @ param ppSacl [ in , optional ] 
 + * A pointer to a variable that receives a pointer to the SACL in the returned security descriptor . The returned 
 + * pointer is valid only if you set the SACL _ SECURITY _ INFORMATION flag . This parameter can be NULL if you do not 
 + * need the SACL . 
 + * @ param ppSecurityDescriptor 
 + * A pointer to a variable that receives a pointer to the security descriptor of the object . When you have finished 
 + * using the pointer , free the returned buffer by calling the LocalFree function . 
 + * This parameter is required if any one of the ppsidOwner , ppsidGroup , ppDacl , or ppSacl parameters is not NULL . 
 + * @ return whether the call succeeded . A nonzero return is a failure . 
 + * 
 + * < p > < b > NOTES : < / b > < / p > 
 + * < p > 1 . If the ppsidOwner , ppsidGroup , ppDacl , and ppSacl parameters are non - NULL , and the SecurityInfo parameter specifies 
 + * that they be retrieved from the object , those parameters will point to the corresponding parameters in the security descriptor 
 + * returned in ppSecurityDescriptor . < / p > 
 + * < p > 2 . To read the owner , group , or DACL from the object ' s security descriptor , the calling process must have been granted 
 + * READ _ CONTROL access when the handle was opened . To get READ _ CONTROL access , the caller must be the owner of the object or 
 + * the object ' s DACL must grant the access . < / p > 
 + * < p > 3 . To read the SACL from the security descriptor , the calling process must have been granted ACCESS _ SYSTEM _ SECURITY access 
 + * when the handle was opened . The proper way to get this access is to enable the SE _ SECURITY _ NAME privilege in the caller ' s 
 + * current token , open the handle for ACCESS _ SYSTEM _ SECURITY access , and then disable the privilege . < / p > 
 + * < p > 4 . If the supplied handle was opened with an ACCESS _ MASK value of MAXIMUM _ ALLOWED , 
 + * then the SetSecurityInfo function will not propagate ACEs to children . < / p > 
 + * / 
 + int GetSecurityInfo ( HANDLE handle , 
 + int ObjectType , 
 + int SecurityInfo , 
 + PointerByReference ppsidOwner , 
 + PointerByReference ppsidGroup , 
 + PointerByReference ppDacl , 
 + PointerByReference ppSacl , 
 + PointerByReference ppSecurityDescriptor ) ; 
 + 
 + / * * 
 + * The SetSecurityInfo function sets specified security information in 
 + * the security descriptor of a specified object . The caller identifies the 
 + * object by a handle . 
 + * 
 + * @ param handle [ in ] 
 + * A handle to the object for which to set security information . 
 + * @ param ObjectType [ in ] 
 + * A value of the SE _ OBJECT _ TYPE enumeration that indicates the type 
 + * of object named by the pObjectName parameter . 
 + * @ param SecurityInfo [ in ] 
 + * A set of bit flags that indicate the type of security 
 + * information to set . See WinNT * _ SECURITY _ INFORMATION 
 + * @ param ppsidOwner [ in , optional ] 
 + * A pointer to a SID structure that identifies the owner of the object . 
 + * If the caller does not have the SeRestorePrivilege constant 
 + * ( see Privilege Constants ) , this SID must be contained in the 
 + * caller ' s token , and must have the SE _ GROUP _ OWNER permission enabled . 
 + * The SecurityInfo parameter must include the OWNER _ SECURITY _ INFORMATION 
 + * flag . To set the owner , the caller must have WRITE _ OWNER access to 
 + * the object or have the SE _ TAKE _ OWNERSHIP _ NAME privilege enabled . 
 + * If you are not setting the owner SID , this parameter can be NULL . 
 + * @ param ppsidGroup [ in , optional ] 
 + * A pointer to a SID that identifies the primary group of the object . 
 + * The SecurityInfo parameter must include the GROUP _ SECURITY _ INFORMATION 
 + * flag . If you are not setting the primary group SID , this parameter 
 + * can be NULL . 
 + * @ param ppDacl [ in , optional ] 
 + * A pointer to the new DACL for the object . The SecurityInfo parameter 
 + * must include the DACL _ SECURITY _ INFORMATION flag . The caller must have 
 + * WRITE _ DAC access to the object or be the owner of the object . If you 
 + * are not setting the DACL , this parameter can be NULL . 
 + * @ param ppSacl [ in , optional ] 
 + * A pointer to the new SACL for the object . The SecurityInfo parameter 
 + * must include any of the following flags : SACL _ SECURITY _ INFORMATION , 
 + * LABEL _ SECURITY _ INFORMATION , ATTRIBUTE _ SECURITY _ INFORMATION , 
 + * SCOPE _ SECURITY _ INFORMATION , or BACKUP _ SECURITY _ INFORMATION . 
 + * If setting SACL _ SECURITY _ INFORMATION or SCOPE _ SECURITY _ INFORMATION , 
 + * the caller must have the SE _ SECURITY _ NAME privilege enabled . If 
 + * you are not setting the SACL , this parameter can be NULL . 
 + * @ return whether the call succeeded . A nonzero return is a failure . 
 + * 
 + * < p > < b > NOTES : < / b > < / p > 
 + * < p > 1 . If you are setting the discretionary access control list ( DACL ) or any elements 
 + * in the system access control list ( SACL ) of an object , the system automatically 
 + * propagates any inheritable access control entries ( ACEs ) to existing child objects , 
 + * according to the ACE inheritance rules . < / p > 
 + * < p > 2 . The SetSecurityInfo function does not reorder access - allowed or access - denied 
 + * ACEs based on the preferred order . When propagating inheritable ACEs to existing 
 + * child objects , SetSecurityInfo puts inherited ACEs in order after all of the 
 + * noninherited ACEs in the DACLs of the child objects . < / p > 
 + * < p > 3 . If share access to the children of the object is not available , this function 
 + * will not propagate unprotected ACEs to the children . For example , if a directory 
 + * is opened with exclusive access , the operating system will not propagate unprotected 
 + * ACEs to the subdirectories or files of that directory when the security on the 
 + * directory is changed . < / p > 
 + * < p > 4 . If the supplied handle was opened with an ACCESS _ MASK value of MAXIMUM _ ALLOWED , 
 + * then the SetSecurityInfo function will not propagate ACEs to children . < / p > 
 + * / 
 + int SetSecurityInfo ( HANDLE handle , 
 + int ObjectType , 
 + int SecurityInfo , 
 + Pointer ppsidOwner , 
 + Pointer ppsidGroup , 
 + Pointer ppDacl , 
 + Pointer ppSacl ) ; 
 + 
 + / * * 
 * The GetNamedSecurityInfo function retrieves a copy of the security 
 * descriptor for an object specified by name 
 * 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / NtDll . java b / contrib / platform / src / com / sun / jna / platform / win32 / NtDll . java 
 index 26b74e1 . . 417f38b 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / NtDll . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / NtDll . java 
 @ @ - 13 , 6 + 13 , 7 @ @ 
 package com . sun . jna . platform . win32 ; 
 
 import com . sun . jna . Native ; 
 + import com . sun . jna . Pointer ; 
 import com . sun . jna . Structure ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 import com . sun . jna . ptr . IntByReference ; 
 @ @ - 51 , 4 + 52 , 56 @ @ public interface NtDll extends StdCallLibrary { 
 	 * / 
 	 public int ZwQueryKey ( HANDLE KeyHandle , int KeyInformationClass , 
 	 	 	 Structure KeyInformation , int Length , IntByReference ResultLength ) ; 
 + 
 + / * * 
 + * The NtSetSecurityObject routine sets an object ' s security state . 
 + * @ param handle [ in ] 
 + * Handle for the object whose security state is to be set . This handle must have the access 
 + * specified in the Meaning column of the table shown in the description of the 
 + * SecurityInformation parameter . 
 + * @ param SecurityInformation [ in ] 
 + * SECURITY _ INFORMATION value specifying the information to be set . Can be a combination of 
 + * one or more of the following : 
 + * DACL _ SECURITY _ INFORMATION 
 + * Indicates the discretionary access control list ( DACL ) of the object is to be set . Requires WRITE _ DAC access . 
 + * GROUP _ SECURITY _ INFORMATION 
 + * Indicates the primary group identifier of the object is to be set . Requires WRITE _ OWNER access . 
 + * OWNER _ SECURITY _ INFORMATION 
 + * Indicates the owner identifier of the object is to be set . Requires WRITE _ OWNER access . 
 + * SACL _ SECURITY _ INFORMATION 
 + * Indicates the system ACL ( SACL ) of the object is to be set . Requires ACCESS _ SYSTEM _ SECURITY access . 
 + * @ param pSecurityDescriptor [ in ] 
 + * Pointer to the security descriptor to be set for the object . 
 + * @ return 
 + * NtSetSecurityObject returns STATUS _ SUCCESS or an appropriate error status . 
 + * / 
 + public int NtSetSecurityObject ( HANDLE handle , int SecurityInformation , Pointer pSecurityDescriptor ) ; 
 + 
 + / * * 
 + * The NtQuerySecurityObject routine retrieves a copy of an object ' s security descriptor . 
 + * 
 + * @ param handle [ in ] 
 + * Handle for the object whose security descriptor is to be queried . This handle must have the access specified 
 + * in the Meaning column of the table shown in the description of the SecurityInformation parameter . 
 + * @ param SecurityInformation [ in ] 
 + * Pointer to a SECURITY _ INFORMATION value specifying the information to be queried . Can be a combination of 
 + * one or more of the following : 
 + * DACL _ SECURITY _ INFORMATION 
 + * Indicates the discretionary access control list ( DACL ) of the object is to be set . Requires WRITE _ DAC access . 
 + * GROUP _ SECURITY _ INFORMATION 
 + * Indicates the primary group identifier of the object is to be set . Requires WRITE _ OWNER access . 
 + * OWNER _ SECURITY _ INFORMATION 
 + * Indicates the owner identifier of the object is to be set . Requires WRITE _ OWNER access . 
 + * SACL _ SECURITY _ INFORMATION 
 + * Indicates the system ACL ( SACL ) of the object is to be set . Requires ACCESS _ SYSTEM _ SECURITY access . 
 + * @ param SecurityDescriptor [ out ] 
 + * Pointer to the security descriptor to be set for the object . 
 + * @ param Length [ in ] 
 + * Size , in bytes , of the buffer pointed to by SecurityDescriptor . 
 + * @ param LengthNeeded [ in ] 
 + * Pointer to a caller - allocated variable that receives the number of bytes required to store the copied security descriptor . 
 + * @ return 
 + * NtQuerySecurityObject returns STATUS _ SUCCESS or an appropriate error status . 
 + * / 
 + public int NtQuerySecurityObject ( HANDLE handle , int SecurityInformation , Pointer SecurityDescriptor , int Length , IntByReference LengthNeeded ) ; 
 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 index 02bf241 . . beaeef3 100755 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 @ @ - 1005 , 6 + 1005 , 200 @ @ public class Advapi32Test extends TestCase { 
 	 assertTrue ( Advapi32 . INSTANCE . RevertToSelf ( ) ) ; 
 } 
 
 + public void testGetSetFileSecurityNoSACL ( ) throws Exception { 
 + int infoType = OWNER _ SECURITY _ INFORMATION 
 + | GROUP _ SECURITY _ INFORMATION 
 + | DACL _ SECURITY _ INFORMATION ; 
 + 
 + int memSize = 64 * 1024 ; 
 + Memory memorySecurity = new Memory ( memSize ) ; 
 + IntByReference sizeNeeded = new IntByReference ( 0 ) ; 
 + / / create a temp file 
 + File file = createTempFile ( ) ; 
 + String filePath = file . getAbsolutePath ( ) ; 
 + 
 + try { 
 + 
 + assertEquals ( " GetFileSecurity ( " + filePath + " ) " , true , 
 + Advapi32 . INSTANCE . GetFileSecurity ( 
 + filePath , 
 + infoType , 
 + memorySecurity , 
 + memSize , 
 + sizeNeeded ) ) ; 
 + assertEquals ( " SetFileSecurity ( " + filePath + " ) " , true , 
 + Advapi32 . INSTANCE . SetFileSecurity ( 
 + filePath , 
 + infoType , 
 + memorySecurity ) ) ; 
 + } finally { 
 + file . delete ( ) ; 
 + } 
 + } 
 + 
 + public void testGetSetSecurityInfoNoSACL ( ) throws Exception { 
 + int infoType = OWNER _ SECURITY _ INFORMATION 
 + | GROUP _ SECURITY _ INFORMATION 
 + | DACL _ SECURITY _ INFORMATION ; 
 + 
 + PointerByReference ppsidOwner = new PointerByReference ( ) ; 
 + PointerByReference ppsidGroup = new PointerByReference ( ) ; 
 + PointerByReference ppDacl = new PointerByReference ( ) ; 
 + PointerByReference ppSecurityDescriptor = new PointerByReference ( ) ; 
 + / / create a temp file 
 + File file = createTempFile ( ) ; 
 + String filePath = file . getAbsolutePath ( ) ; 
 + 
 + HANDLE hFile = Kernel32 . INSTANCE . CreateFile ( 
 + filePath , 
 + WinNT . GENERIC _ ALL | WinNT . WRITE _ OWNER | WinNT . WRITE _ DAC , 
 + WinNT . FILE _ SHARE _ READ , 
 + new WinBase . SECURITY _ ATTRIBUTES ( ) , 
 + WinNT . OPEN _ EXISTING , 
 + WinNT . FILE _ ATTRIBUTE _ NORMAL , 
 + null ) ; 
 + assertFalse ( " Failed to create file handle : " + filePath , WinBase . INVALID _ HANDLE _ VALUE . equals ( hFile ) ) ; 
 + 
 + try { 
 + try { 
 + 
 + assertEquals ( " GetSecurityInfo ( " + filePath + " ) " , 0 , 
 + Advapi32 . INSTANCE . GetSecurityInfo ( 
 + hFile , 
 + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , 
 + infoType , 
 + ppsidOwner , 
 + ppsidGroup , 
 + ppDacl , 
 + null , 
 + ppSecurityDescriptor ) ) ; 
 + 
 + assertEquals ( " SetSecurityInfo ( " + filePath + " ) " , 0 , 
 + Advapi32 . INSTANCE . SetSecurityInfo ( 
 + hFile , 
 + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , 
 + infoType , 
 + ppsidOwner . getValue ( ) , 
 + ppsidGroup . getValue ( ) , 
 + ppDacl . getValue ( ) , 
 + null ) ) ; 
 + } finally { 
 + Kernel32 . INSTANCE . CloseHandle ( hFile ) ; 
 + file . delete ( ) ; 
 + } 
 + } finally { 
 + Kernel32Util . freeLocalMemory ( ppSecurityDescriptor . getValue ( ) ) ; 
 + } 
 + } 
 + 
 + public void testGetSetSecurityInfoForFileWithSACL ( ) throws Exception { 
 + boolean impersontating = false ; 
 + 
 + HANDLEByReference phToken = new HANDLEByReference ( ) ; 
 + HANDLEByReference phTokenDuplicate = new HANDLEByReference ( ) ; 
 + try { 
 + / / open thread or process token , elevate 
 + if ( ! Advapi32 . INSTANCE . OpenThreadToken ( 
 + Kernel32 . INSTANCE . GetCurrentThread ( ) , 
 + TOKEN _ ADJUST _ PRIVILEGES , 
 + false , 
 + phToken ) ) 
 + { 
 + assertEquals ( W32Errors . ERROR _ NO _ TOKEN , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + / / OpenThreadToken may fail with W32Errors . ERROR _ NO _ TOKEN if current thread is anonymous . When this happens , 
 + / / we need to open the process token to duplicate it , then set our thread token . 
 + assertTrue ( Advapi32 . INSTANCE . OpenProcessToken ( Kernel32 . INSTANCE . GetCurrentProcess ( ) , TOKEN _ DUPLICATE , phToken ) ) ; 
 + / / Process token opened , now duplicate 
 + assertTrue ( Advapi32 . INSTANCE . DuplicateTokenEx ( 
 + phToken . getValue ( ) , 
 + TOKEN _ ADJUST _ PRIVILEGES | TOKEN _ IMPERSONATE , 
 + null , 
 + SECURITY _ IMPERSONATION _ LEVEL . SecurityImpersonation , 
 + TOKEN _ TYPE . TokenImpersonation , 
 + phTokenDuplicate ) ) ; 
 + / / And set thread token . 
 + assertTrue ( Advapi32 . INSTANCE . SetThreadToken ( null , phTokenDuplicate . getValue ( ) ) ) ; 
 + impersontating = true ; 
 + } 
 + 
 + / / Which token to adjust depends on whether we had to impersonate or not . 
 + HANDLE tokenAdjust = impersontating ? phTokenDuplicate . getValue ( ) : phToken . getValue ( ) ; 
 + 
 + WinNT . TOKEN _ PRIVILEGES tp = new WinNT . TOKEN _ PRIVILEGES ( 1 ) ; 
 + WinNT . LUID pLuid = new WinNT . LUID ( ) ; 
 + 
 + assertTrue ( Advapi32 . INSTANCE . LookupPrivilegeValue ( null , SE _ SECURITY _ NAME , pLuid ) ) ; 
 + tp . Privileges [ 0 ] = new WinNT . LUID _ AND _ ATTRIBUTES ( pLuid , new DWORD ( WinNT . SE _ PRIVILEGE _ ENABLED ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . AdjustTokenPrivileges ( tokenAdjust , false , tp , 0 , null , null ) ) ; 
 + 
 + assertTrue ( Advapi32 . INSTANCE . LookupPrivilegeValue ( null , SE _ RESTORE _ NAME , pLuid ) ) ; 
 + tp . Privileges [ 0 ] = new WinNT . LUID _ AND _ ATTRIBUTES ( pLuid , new DWORD ( WinNT . SE _ PRIVILEGE _ ENABLED ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . AdjustTokenPrivileges ( tokenAdjust , false , tp , 0 , null , null ) ) ; 
 + 
 + / / create a temp file 
 + File file = createTempFile ( ) ; 
 + int infoType = OWNER _ SECURITY _ INFORMATION 
 + | GROUP _ SECURITY _ INFORMATION 
 + | DACL _ SECURITY _ INFORMATION 
 + | SACL _ SECURITY _ INFORMATION ; 
 + 
 + PointerByReference ppsidOwner = new PointerByReference ( ) ; 
 + PointerByReference ppsidGroup = new PointerByReference ( ) ; 
 + PointerByReference ppDacl = new PointerByReference ( ) ; 
 + PointerByReference ppSacl = new PointerByReference ( ) ; 
 + PointerByReference ppSecurityDescriptor = new PointerByReference ( ) ; 
 + String filePath = file . getAbsolutePath ( ) ; 
 + HANDLE hFile = WinBase . INVALID _ HANDLE _ VALUE ; 
 + 
 + try { 
 + try { 
 + hFile = Kernel32 . INSTANCE . CreateFile ( 
 + filePath , 
 + WinNT . ACCESS _ SYSTEM _ SECURITY | WinNT . GENERIC _ WRITE | WinNT . WRITE _ OWNER | WinNT . WRITE _ DAC , 
 + WinNT . FILE _ SHARE _ READ , 
 + new WinBase . SECURITY _ ATTRIBUTES ( ) , 
 + WinNT . OPEN _ EXISTING , 
 + WinNT . FILE _ ATTRIBUTE _ NORMAL , 
 + null ) ; 
 + assertEquals ( " GetSecurityInfo ( " + filePath + " ) " , 0 , 
 + Advapi32 . INSTANCE . GetSecurityInfo ( 
 + hFile , 
 + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , 
 + infoType , 
 + ppsidOwner , 
 + ppsidGroup , 
 + ppDacl , 
 + ppSacl , 
 + ppSecurityDescriptor ) ) ; 
 + assertEquals ( " SetSecurityInfo ( " + filePath + " ) " , 0 , 
 + Advapi32 . INSTANCE . SetSecurityInfo ( 
 + hFile , 
 + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , 
 + infoType , 
 + ppsidOwner . getValue ( ) , 
 + ppsidGroup . getValue ( ) , 
 + ppDacl . getValue ( ) , 
 + ppSacl . getValue ( ) ) ) ; 
 + } finally { 
 + if ( hFile ! = WinBase . INVALID _ HANDLE _ VALUE ) 
 + Kernel32 . INSTANCE . CloseHandle ( hFile ) ; 
 + file . delete ( ) ; 
 + } 
 + } finally { 
 + Kernel32Util . freeLocalMemory ( ppSecurityDescriptor . getValue ( ) ) ; 
 + } 
 + 
 + if ( impersontating ) { 
 + assertTrue ( " SetThreadToken " , Advapi32 . INSTANCE . SetThreadToken ( null , null ) ) ; 
 + } 
 + else { 
 + tp . Privileges [ 0 ] = new WinNT . LUID _ AND _ ATTRIBUTES ( pLuid , new DWORD ( 0 ) ) ; 
 + assertTrue ( " AdjustTokenPrivileges " , Advapi32 . INSTANCE . AdjustTokenPrivileges ( tokenAdjust , false , tp , 0 , null , null ) ) ; 
 + } 
 + } finally { 
 + Kernel32Util . closeHandleRefs ( phToken , phTokenDuplicate ) ; 
 + } 
 + } 
 
 public void testGetNamedSecurityInfoForFileNoSACL ( ) throws Exception { 
 int infoType = OWNER _ SECURITY _ INFORMATION 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / NtDllTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / NtDllTest . java 
 index bf832a2 . . 378e77a 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / NtDllTest . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / NtDllTest . java 
 @ @ - 12 , 13 + 12 , 22 @ @ 
 * / 
 package com . sun . jna . platform . win32 ; 
 
 - import junit . framework . TestCase ; 
 + import static com . sun . jna . platform . win32 . WinNT . DACL _ SECURITY _ INFORMATION ; 
 + import static com . sun . jna . platform . win32 . WinNT . GROUP _ SECURITY _ INFORMATION ; 
 + import static com . sun . jna . platform . win32 . WinNT . OWNER _ SECURITY _ INFORMATION ; 
 + 
 + import java . io . File ; 
 + import java . io . FileWriter ; 
 
 + import com . sun . jna . Memory ; 
 import com . sun . jna . platform . win32 . Wdm . KEY _ BASIC _ INFORMATION ; 
 import com . sun . jna . platform . win32 . Wdm . KEY _ INFORMATION _ CLASS ; 
 + import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 import com . sun . jna . ptr . IntByReference ; 
 
 + import junit . framework . TestCase ; 
 + 
 / * * 
 * @ author dblock [ at ] dblock [ dot ] org 
 * / 
 @ @ - 49 , 4 + 58 , 63 @ @ public class NtDllTest extends TestCase { 
 	 / / close key 
 	 assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . RegCloseKey ( phKey . getValue ( ) ) ) ; 	 	 	 	 
 } 
 + 
 + public void testNtQuerySetSecurityObjectNoSACL ( ) throws Exception { 
 + int infoType = OWNER _ SECURITY _ INFORMATION 
 + | GROUP _ SECURITY _ INFORMATION 
 + | DACL _ SECURITY _ INFORMATION ; 
 + 
 + / / create a temp file 
 + File file = createTempFile ( ) ; 
 + String filePath = file . getAbsolutePath ( ) ; 
 + HANDLE hFile = WinBase . INVALID _ HANDLE _ VALUE ; 
 + 
 + try { 
 + hFile = Kernel32 . INSTANCE . CreateFile ( 
 + filePath , 
 + WinNT . GENERIC _ WRITE | WinNT . WRITE _ OWNER | WinNT . WRITE _ DAC , 
 + WinNT . FILE _ SHARE _ READ , 
 + new WinBase . SECURITY _ ATTRIBUTES ( ) , 
 + WinNT . OPEN _ EXISTING , 
 + WinNT . FILE _ ATTRIBUTE _ NORMAL , 
 + null ) ; 
 + assertFalse ( " Failed to create file handle : " + filePath , WinBase . INVALID _ HANDLE _ VALUE . equals ( hFile ) ) ; 
 + 
 + int Length = 64 * 1024 ; 
 + Memory SecurityDescriptor = new Memory ( Length ) ; 
 + IntByReference LengthNeeded = new IntByReference ( ) ; 
 + 
 + assertEquals ( " NtQuerySecurityObject ( " + filePath + " ) " , 0 , 
 + NtDll . INSTANCE . NtQuerySecurityObject ( 
 + hFile , 
 + infoType , 
 + SecurityDescriptor , 
 + Length , 
 + LengthNeeded ) ) ; 
 + assertTrue ( LengthNeeded . getValue ( ) > 0 ) ; 
 + assertTrue ( LengthNeeded . getValue ( ) < 64 * 1024 ) ; 
 + assertEquals ( " NtSetSecurityObject ( " + filePath + " ) " , 0 , 
 + NtDll . INSTANCE . NtSetSecurityObject ( 
 + hFile , 
 + infoType , 
 + SecurityDescriptor ) ) ; 
 + } finally { 
 + if ( hFile ! = WinBase . INVALID _ HANDLE _ VALUE ) 
 + Kernel32 . INSTANCE . CloseHandle ( hFile ) ; 
 + file . delete ( ) ; 
 + } 
 + } 
 + 
 + private File createTempFile ( ) throws Exception { 
 + String filePath = System . getProperty ( " java . io . tmpdir " ) + System . nanoTime ( ) 
 + + " . text " ; 
 + File file = new File ( filePath ) ; 
 + file . createNewFile ( ) ; 
 + FileWriter fileWriter = new FileWriter ( file ) ; 
 + for ( int i = 0 ; i < 1000 ; i + + ) { 
 + fileWriter . write ( " Sample text " + i + System . getProperty ( " line . separator " ) ) ; 
 + } 
 + fileWriter . close ( ) ; 
 + return file ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c 
 index 383d49f . . b3450f8 100644 
 - - - a / jnalib / native / dispatch . c 
 + + + b / jnalib / native / dispatch . c 
 @ @ - 992 , 7 + 992 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1write _ _ J _ 3SII 
 * Signature : ( JB ) J 
 * / 
 JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1indexOf _ _ JB 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 { 
 jbyte * peer = ( jbyte * ) L2A ( addr ) ; 
 volatile jlong i = 0 ; 
 @ @ - 1103 , 7 + 1103 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1read _ _ J _ 3SII 
 * Signature : ( J ) B 
 * / 
 JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jbyte res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1116 , 7 + 1116 , 7 @ @ JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte 
 * Signature : ( J ) C 
 * / 
 JNIEXPORT jchar JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getChar 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 wchar _ t res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1153 , 7 + 1153 , 7 @ @ JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDirectByteBuffer 
 * Signature : ( J ) D 
 * / 
 JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jdouble res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1166 , 7 + 1166 , 7 @ @ JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble 
 * Signature : ( J ) F 
 * / 
 JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jfloat res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1179 , 7 + 1179 , 7 @ @ JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat 
 * Signature : ( J ) I 
 * / 
 JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jint res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1192 , 7 + 1192 , 7 @ @ JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt 
 * Signature : ( J ) J 
 * / 
 JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jlong res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1205 , 7 + 1205 , 7 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong 
 * Signature : ( J ) S 
 * / 
 JNIEXPORT jshort JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getShort 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jshort res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1229 , 7 + 1229 , 7 @ @ JNIEXPORT jstring JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getString 
 * Signature : ( JJB ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) 
 { 
 MEMSET ( L2A ( addr ) , ( int ) value , ( size _ t ) count ) ; 
 } 
 @ @ - 1240 , 7 + 1240 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory 
 * Signature : ( JB ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1251 , 7 + 1251 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte 
 * Signature : ( JC ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jchar value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jchar value ) 
 { 
 wchar _ t ch = value ; 
 MEMCPY ( L2A ( addr ) , & ch , sizeof ( ch ) ) ; 
 @ @ - 1263 , 7 + 1263 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar 
 * Signature : ( JJ ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 { 
 void * ptr = L2A ( value ) ; 
 MEMCPY ( L2A ( addr ) , & ptr , sizeof ( void * ) ) ; 
 @ @ - 1275 , 7 + 1275 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer 
 * Signature : ( JD ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jdouble value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jdouble value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1286 , 7 + 1286 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble 
 * Signature : ( JF ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jfloat value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jfloat value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1297 , 7 + 1297 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat 
 * Signature : ( JI ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jint value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jint value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1308 , 7 + 1308 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt 
 * Signature : ( JJ ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1319 , 7 + 1319 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong 
 * Signature : ( JS ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setShort 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jshort value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jshort value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 }
