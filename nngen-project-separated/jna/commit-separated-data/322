BLEU SCORE: 0.02383853510228548

TEST MSG: Dispose of all allocated memory on native library unload
GENERATED MSG: Copy proper varargs handling / test from v3 branch

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 1f71ee0 . . 2c28cb6 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 33 , 6 + 33 , 7 @ @ Bug Fixes <nl> * Fix compiler warnings OSX - [ @ twall ] ( https : / / github . com / twall ) . <nl> * Remove unsupported JAWT from OSX build - [ @ twall ] ( https : / / github . com / twall ) . <nl> * Disable WebStart tests - [ @ twall ] ( https : / / github . com / twall ) . <nl> + * Dispose all native resources when native library is unloaded - [ @ twall ] ( https : / / github . com / twall ) . This fixes a number of seemingly random , sporadic crashes on windows . <nl> <nl> Release 4 . 1 <nl> = = = = = = = = = = = <nl> diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java <nl> index bcf5568 . . f0fd21d 100644 <nl> - - - a / src / com / sun / jna / CallbackReference . java <nl> + + + b / src / com / sun / jna / CallbackReference . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ import java . lang . reflect . InvocationTargetException ; <nl> import java . lang . reflect . Method ; <nl> import java . lang . reflect . Proxy ; <nl> import java . util . Arrays ; <nl> + import java . util . Collections ; <nl> import java . util . HashMap ; <nl> import java . util . HashSet ; <nl> import java . util . Iterator ; <nl> @ @ - 39 , 6 + 40 , 7 @ @ class CallbackReference extends WeakReference { <nl> static final Map directCallbackMap = new WeakHashMap ( ) ; <nl> static final Map pointerCallbackMap = new WeakHashMap ( ) ; <nl> static final Map allocations = new WeakHashMap ( ) ; <nl> + private static final Map allocatedMemory = Collections . synchronizedMap ( new WeakIdentityHashMap ( ) ) ; <nl> <nl> private static final Method PROXY _ CALLBACK _ METHOD ; <nl> <nl> @ @ - 187 , 6 + 189 , 7 @ @ class CallbackReference extends WeakReference { <nl> callingConvention , flags , <nl> encoding ) ; <nl> cbstruct = peer ! = 0 ? new Pointer ( peer ) : null ; <nl> + allocatedMemory . put ( this , this ) ; <nl> } <nl> else { <nl> if ( callback instanceof CallbackProxy ) { <nl> @ @ - 356 , 6 + 359 , 13 @ @ class CallbackReference extends WeakReference { <nl> } <nl> } <nl> <nl> + static void disposeAll ( ) { <nl> + for ( Iterator i = allocatedMemory . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { <nl> + ( ( Memory ) i . next ( ) ) . dispose ( ) ; <nl> + } <nl> + allocatedMemory . clear ( ) ; <nl> + } <nl> + <nl> private Callback getCallback ( ) { <nl> return ( Callback ) get ( ) ; <nl> } <nl> diff - - git a / src / com / sun / jna / Memory . java b / src / com / sun / jna / Memory . java <nl> index 7664c3b . . 5d25b2a 100644 <nl> - - - a / src / com / sun / jna / Memory . java <nl> + + + b / src / com / sun / jna / Memory . java <nl> @ @ - 13 , 6 + 13 , 7 @ @ package com . sun . jna ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . Collections ; <nl> import java . util . HashMap ; <nl> + import java . util . Iterator ; <nl> import java . util . Map ; <nl> <nl> / * * <nl> @ @ - 39 , 11 + 40 , 14 @ @ import java . util . Map ; <nl> public class Memory extends Pointer { <nl> <nl> private static final Map buffers ; <nl> + / * * Keep track of all allocated memory so we can dispose of it before unloading . * / <nl> + private static final Map allocatedMemory ; <nl> <nl> static { <nl> buffers = Collections . synchronizedMap ( Platform . HAS _ BUFFERS <nl> ? ( Map ) new WeakIdentityHashMap ( ) <nl> : ( Map ) new HashMap ( ) ) ; <nl> + allocatedMemory = Collections . synchronizedMap ( new WeakIdentityHashMap ( ) ) ; <nl> } <nl> <nl> / * * Force cleanup of memory that has associated NIO Buffers which have <nl> @ @ - 53 , 6 + 57 , 13 @ @ public class Memory extends Pointer { <nl> buffers . size ( ) ; <nl> } <nl> <nl> + public static void disposeAll ( ) { <nl> + for ( Iterator i = allocatedMemory . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { <nl> + ( ( Memory ) i . next ( ) ) . dispose ( ) ; <nl> + } <nl> + allocatedMemory . clear ( ) ; <nl> + } <nl> + <nl> protected long size ; / / Size of the malloc ' ed space <nl> <nl> / * * Provide a view into the original memory . Keeps an implicit reference <nl> @ @ - 89 , 6 + 100 , 8 @ @ public class Memory extends Pointer { <nl> peer = malloc ( size ) ; <nl> if ( peer = = 0 ) <nl> throw new OutOfMemoryError ( " Cannot allocate " + size + " bytes " ) ; <nl> + <nl> + allocatedMemory . put ( this , this ) ; <nl> } <nl> <nl> protected Memory ( ) { } <nl> @ @ - 151 , 7 + 164 , 7 @ @ public class Memory extends Pointer { <nl> } <nl> <nl> / * * Free the native memory and set peer to zero * / <nl> - protected void dispose ( ) { <nl> + protected synchronized void dispose ( ) { <nl> free ( peer ) ; <nl> peer = 0 ; <nl> } <nl> @ @ - 674 , 7 + 687 , 10 @ @ public class Memory extends Pointer { <nl> } <nl> <nl> protected static void free ( long p ) { <nl> - Native . free ( p ) ; <nl> + / / free ( 0 ) is a no - op , so avoid the overhead of the call <nl> + if ( p ! = 0 ) { <nl> + Native . free ( p ) ; <nl> + } <nl> } <nl> <nl> protected static long malloc ( long size ) { <nl> diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java <nl> index 4ea1f34 . . de909d6 100644 <nl> - - - a / src / com / sun / jna / Native . java <nl> + + + b / src / com / sun / jna / Native . java <nl> @ @ - 154 , 7 + 154 , 7 @ @ public final class Native implements Version { <nl> + " - set jna . boot . library . path to include the path to the version of the " + LS <nl> + " jnidispatch library included with the JNA jar file you are using " + LS ) ; <nl> } <nl> - 	 MAX _ ALIGNMENT = Platform . isSPARC ( ) | | Platform . isWindows ( ) <nl> + MAX _ ALIGNMENT = Platform . isSPARC ( ) | | Platform . isWindows ( ) <nl> | | ( Platform . isLinux ( ) & & ( Platform . isARM ( ) | | Platform . isPPC ( ) ) ) <nl> | | Platform . isAIX ( ) <nl> | | Platform . isAndroid ( ) <nl> @ @ - 162 , 18 + 162 , 22 @ @ public final class Native implements Version { <nl> MAX _ PADDING = ( Platform . isMac ( ) & & Platform . isPPC ( ) ) ? 8 : MAX _ ALIGNMENT ; <nl> } <nl> <nl> - / * * Force a dispose when this class is GC ' d . * / <nl> + / * * Force a dispose when the Native class is GC ' d . * / <nl> private static final Object finalizer = new Object ( ) { <nl> protected void finalize ( ) { <nl> dispose ( ) ; <nl> } <nl> } ; <nl> <nl> - / * * Properly dispose of JNA functionality . Also called from JNI when <nl> + / * * Properly dispose of JNA functionality . <nl> + Called when this class is finalized and also from JNI when <nl> JNA ' s native shared library is unloaded . <nl> * / <nl> private static void dispose ( ) { <nl> + CallbackReference . disposeAll ( ) ; <nl> + Memory . disposeAll ( ) ; <nl> NativeLibrary . disposeAll ( ) ; <nl> + unregisterAll ( ) ; <nl> jnidispatchPath = null ; <nl> } <nl> <nl> @ @ - 667 , 20 + 671 , 20 @ @ public final class Native implements Version { <nl> String dir = dirs . nextToken ( ) ; <nl> File file = new File ( new File ( dir ) , System . mapLibraryName ( libName ) . replace ( " . dylib " , " . jnilib " ) ) ; <nl> String path = file . getAbsolutePath ( ) ; <nl> - 	 	 if ( DEBUG _ JNA _ LOAD ) { <nl> - 	 	 System . out . println ( " Looking in " + path ) ; <nl> - 	 	 } <nl> + if ( DEBUG _ JNA _ LOAD ) { <nl> + System . out . println ( " Looking in " + path ) ; <nl> + } <nl> if ( file . exists ( ) ) { <nl> try { <nl> - 	 	 	 if ( DEBUG _ JNA _ LOAD ) { <nl> - 	 	 	 System . out . println ( " Trying " + path ) ; <nl> - 	 	 	 } <nl> + if ( DEBUG _ JNA _ LOAD ) { <nl> + System . out . println ( " Trying " + path ) ; <nl> + } <nl> System . setProperty ( " jnidispatch . path " , path ) ; <nl> System . load ( path ) ; <nl> jnidispatchPath = path ; <nl> - 	 	 	 if ( DEBUG _ JNA _ LOAD ) { <nl> - 	 	 	 System . out . println ( " Found jnidispatch at " + path ) ; <nl> - 	 	 	 } <nl> + if ( DEBUG _ JNA _ LOAD ) { <nl> + System . out . println ( " Found jnidispatch at " + path ) ; <nl> + } <nl> return ; <nl> } catch ( UnsatisfiedLinkError ex ) { <nl> / / Not a problem if already loaded in anoteher class loader <nl> @ @ - 698 , 14 + 702 , 14 @ @ public final class Native implements Version { <nl> ext = " dylib " ; <nl> } <nl> path = path . substring ( 0 , path . lastIndexOf ( orig ) ) + ext ; <nl> - 	 	 if ( DEBUG _ JNA _ LOAD ) { <nl> - 	 	 	 System . out . println ( " Looking in " + path ) ; <nl> - 	 	 } <nl> + if ( DEBUG _ JNA _ LOAD ) { <nl> + System . out . println ( " Looking in " + path ) ; <nl> + } <nl> if ( new File ( path ) . exists ( ) ) { <nl> try { <nl> - 	 	 	 if ( DEBUG _ JNA _ LOAD ) { <nl> - 	 	 	 	 System . out . println ( " Trying " + path ) ; <nl> - 	 	 	 } <nl> + if ( DEBUG _ JNA _ LOAD ) { <nl> + System . out . println ( " Trying " + path ) ; <nl> + } <nl> System . setProperty ( " jnidispatch . path " , path ) ; <nl> System . load ( path ) ; <nl> jnidispatchPath = path ; <nl> @ @ - 722 , 9 + 726 , 9 @ @ public final class Native implements Version { <nl> } <nl> if ( ! Boolean . getBoolean ( " jna . nosys " ) ) { <nl> try { <nl> - 	 	 if ( DEBUG _ JNA _ LOAD ) { <nl> - 	 	 System . out . println ( " Trying ( via loadLibrary ) " + libName ) ; <nl> - 	 	 } <nl> + if ( DEBUG _ JNA _ LOAD ) { <nl> + System . out . println ( " Trying ( via loadLibrary ) " + libName ) ; <nl> + } <nl> System . loadLibrary ( libName ) ; <nl> if ( DEBUG _ JNA _ LOAD ) { <nl> System . out . println ( " Found jnidispatch on system path " ) ; <nl> @ @ - 756 , 11 + 760 , 11 @ @ public final class Native implements Version { <nl> throw new UnsatisfiedLinkError ( " Could not find JNA native support " ) ; <nl> } <nl> } <nl> - 	 if ( DEBUG _ JNA _ LOAD ) { <nl> - 	 	 System . out . println ( " Trying " + lib . getAbsolutePath ( ) ) ; <nl> - 	 } <nl> + if ( DEBUG _ JNA _ LOAD ) { <nl> + System . out . println ( " Trying " + lib . getAbsolutePath ( ) ) ; <nl> + } <nl> System . setProperty ( " jnidispatch . path " , lib . getAbsolutePath ( ) ) ; <nl> - 	 System . load ( lib . getAbsolutePath ( ) ) ; <nl> + System . load ( lib . getAbsolutePath ( ) ) ; <nl> jnidispatchPath = lib . getAbsolutePath ( ) ; <nl> if ( DEBUG _ JNA _ LOAD ) { <nl> System . out . println ( " Found jnidispatch at " + jnidispatchPath ) ; <nl> @ @ - 821 , 9 + 825 , 9 @ @ public final class Native implements Version { <nl> loader = Native . class . getClassLoader ( ) ; <nl> } <nl> } <nl> - 	 if ( DEBUG ) { <nl> - 	 System . out . println ( " Looking in classpath from " + loader + " for " + name ) ; <nl> - 	 } <nl> + if ( DEBUG ) { <nl> + System . out . println ( " Looking in classpath from " + loader + " for " + name ) ; <nl> + } <nl> String libname = name . startsWith ( " / " ) ? name : NativeLibrary . mapSharedLibraryName ( name ) ; <nl> String resourcePath = name . startsWith ( " / " ) ? name : Platform . RESOURCE _ PREFIX + " / " + libname ; <nl> if ( resourcePath . startsWith ( " / " ) ) { <nl> @ @ - 853 , 9 + 857 , 9 @ @ public final class Native implements Version { <nl> catch ( URISyntaxException e ) { <nl> lib = new File ( url . getPath ( ) ) ; <nl> } <nl> - 	 if ( DEBUG ) { <nl> - 	 	 System . out . println ( " Looking in " + lib . getAbsolutePath ( ) ) ; <nl> - 	 } <nl> + if ( DEBUG ) { <nl> + System . out . println ( " Looking in " + lib . getAbsolutePath ( ) ) ; <nl> + } <nl> if ( ! lib . exists ( ) ) { <nl> throw new IOException ( " File URL " + url + " could not be properly decoded " ) ; <nl> } <nl> @ @ - 1217 , 17 + 1221 , 16 @ @ public final class Native implements Version { <nl> <nl> private static Map registeredClasses = new HashMap ( ) ; <nl> private static Map registeredLibraries = new HashMap ( ) ; <nl> - private static Object unloader = new Object ( ) { <nl> - protected void finalize ( ) { <nl> - synchronized ( registeredClasses ) { <nl> - for ( Iterator i = registeredClasses . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { <nl> - Map . Entry e = ( Map . Entry ) i . next ( ) ; <nl> - unregister ( ( Class ) e . getKey ( ) , ( long [ ] ) e . getValue ( ) ) ; <nl> - i . remove ( ) ; <nl> - } <nl> + <nl> + private static void unregisterAll ( ) { <nl> + synchronized ( registeredClasses ) { <nl> + for ( Iterator i = registeredClasses . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { <nl> + Map . Entry e = ( Map . Entry ) i . next ( ) ; <nl> + unregister ( ( Class ) e . getKey ( ) , ( long [ ] ) e . getValue ( ) ) ; <nl> + i . remove ( ) ; <nl> } <nl> } <nl> - } ; <nl> + } <nl> <nl> / * * Remove all native mappings for the calling class . <nl> Should only be called if the class is no longer referenced and about <nl> @ @ - 1657 , 10 + 1660 , 10 @ @ public final class Native implements Version { <nl> * Call the native function being represented by this object <nl> * @ param fp function pointer <nl> * @ param callFlags calling convention to be used <nl> - * @ param 	 args <nl> - * 	 	 	 Arguments to pass to the native function <nl> + * @ param args <nl> + * Arguments to pass to the native function <nl> * <nl> - * @ return 	 The value returned by the target native function <nl> + * @ return The value returned by the target native function <nl> * / <nl> static native int invokeInt ( long fp , int callFlags , Object [ ] args ) ; <nl> <nl> @ @ - 1668 , 10 + 1671 , 10 @ @ public final class Native implements Version { <nl> * Call the native function being represented by this object <nl> * @ param fp function pointer <nl> * @ param callFlags calling convention to be used <nl> - * @ param 	 args <nl> - * 	 	 	 Arguments to pass to the native function <nl> + * @ param args <nl> + * Arguments to pass to the native function <nl> * <nl> - * @ return 	 The value returned by the target native function <nl> + * @ return The value returned by the target native function <nl> * / <nl> static native long invokeLong ( long fp , int callFlags , Object [ ] args ) ; <nl> <nl> @ @ - 1679 , 8 + 1682 , 8 @ @ public final class Native implements Version { <nl> * Call the native function being represented by this object <nl> * @ param fp function pointer <nl> * @ param callFlags calling convention to be used <nl> - * @ param 	 args <nl> - * 	 	 	 Arguments to pass to the native function <nl> + * @ param args <nl> + * Arguments to pass to the native function <nl> * / <nl> static native void invokeVoid ( long fp , int callFlags , Object [ ] args ) ; <nl> <nl> @ @ - 1688 , 10 + 1691 , 10 @ @ public final class Native implements Version { <nl> * Call the native function being represented by this object <nl> * @ param fp function pointer <nl> * @ param callFlags calling convention to be used <nl> - * @ param 	 args <nl> - * 	 	 	 Arguments to pass to the native function <nl> + * @ param args <nl> + * Arguments to pass to the native function <nl> * <nl> - * @ return 	 The value returned by the target native function <nl> + * @ return The value returned by the target native function <nl> * / <nl> static native float invokeFloat ( long fp , int callFlags , Object [ ] args ) ; <nl> <nl> @ @ - 1699 , 10 + 1702 , 10 @ @ public final class Native implements Version { <nl> * Call the native function being represented by this object <nl> * @ param fp function pointer <nl> * @ param callFlags calling convention to be used <nl> - * @ param 	 args <nl> - * 	 	 	 Arguments to pass to the native function <nl> + * @ param args <nl> + * Arguments to pass to the native function <nl> * <nl> - * @ return 	 The value returned by the target native function <nl> + * @ return The value returned by the target native function <nl> * / <nl> static native double invokeDouble ( long fp , int callFlags , Object [ ] args ) ; <nl> <nl> @ @ - 1710 , 10 + 1713 , 10 @ @ public final class Native implements Version { <nl> * Call the native function being represented by this object <nl> * @ param fp function pointer <nl> * @ param callFlags calling convention to be used <nl> - * @ param 	 args <nl> - * 	 	 	 Arguments to pass to the native function <nl> + * @ param args <nl> + * Arguments to pass to the native function <nl> * <nl> - * @ return 	 The native pointer returned by the target native function <nl> + * @ return The native pointer returned by the target native function <nl> * / <nl> static native long invokePointer ( long fp , int callFlags , Object [ ] args ) ; <nl>
NEAREST DIFF (one line): diff - - git a / jnalib / native / callback . c b / jnalib / native / callback . c <nl> index 32431a5 . . f73b72b 100644 <nl> - - - a / jnalib / native / callback . c <nl> + + + b / jnalib / native / callback . c <nl> @ @ - 397 , 7 + 397 , 7 @ @ callback _ dispatch ( JavaVM * jvm , callback * cb , char * ap ) { <nl> } <nl> else switch ( cb - > return _ jtype ) { <nl> case ' V ' : <nl> - resuilt . i = 0 ; ( * env ) - > CallVoidMethodA ( env , obj , mid , args ) ; break ; <nl> + result . i = 0 ; ( * env ) - > CallVoidMethodA ( env , obj , mid , args ) ; break ; <nl> case ' Z ' : <nl> result . i = ( * env ) - > CallBooleanMethodA ( env , obj , mid , args ) ; break ; <nl> case ' B ' :

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 1f71ee0 . . 2c28cb6 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 33 , 6 + 33 , 7 @ @ Bug Fixes 
 * Fix compiler warnings OSX - [ @ twall ] ( https : / / github . com / twall ) . 
 * Remove unsupported JAWT from OSX build - [ @ twall ] ( https : / / github . com / twall ) . 
 * Disable WebStart tests - [ @ twall ] ( https : / / github . com / twall ) . 
 + * Dispose all native resources when native library is unloaded - [ @ twall ] ( https : / / github . com / twall ) . This fixes a number of seemingly random , sporadic crashes on windows . 
 
 Release 4 . 1 
 = = = = = = = = = = = 
 diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java 
 index bcf5568 . . f0fd21d 100644 
 - - - a / src / com / sun / jna / CallbackReference . java 
 + + + b / src / com / sun / jna / CallbackReference . java 
 @ @ - 19 , 6 + 19 , 7 @ @ import java . lang . reflect . InvocationTargetException ; 
 import java . lang . reflect . Method ; 
 import java . lang . reflect . Proxy ; 
 import java . util . Arrays ; 
 + import java . util . Collections ; 
 import java . util . HashMap ; 
 import java . util . HashSet ; 
 import java . util . Iterator ; 
 @ @ - 39 , 6 + 40 , 7 @ @ class CallbackReference extends WeakReference { 
 static final Map directCallbackMap = new WeakHashMap ( ) ; 
 static final Map pointerCallbackMap = new WeakHashMap ( ) ; 
 static final Map allocations = new WeakHashMap ( ) ; 
 + private static final Map allocatedMemory = Collections . synchronizedMap ( new WeakIdentityHashMap ( ) ) ; 
 
 private static final Method PROXY _ CALLBACK _ METHOD ; 
 
 @ @ - 187 , 6 + 189 , 7 @ @ class CallbackReference extends WeakReference { 
 callingConvention , flags , 
 encoding ) ; 
 cbstruct = peer ! = 0 ? new Pointer ( peer ) : null ; 
 + allocatedMemory . put ( this , this ) ; 
 } 
 else { 
 if ( callback instanceof CallbackProxy ) { 
 @ @ - 356 , 6 + 359 , 13 @ @ class CallbackReference extends WeakReference { 
 } 
 } 
 
 + static void disposeAll ( ) { 
 + for ( Iterator i = allocatedMemory . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 + ( ( Memory ) i . next ( ) ) . dispose ( ) ; 
 + } 
 + allocatedMemory . clear ( ) ; 
 + } 
 + 
 private Callback getCallback ( ) { 
 return ( Callback ) get ( ) ; 
 } 
 diff - - git a / src / com / sun / jna / Memory . java b / src / com / sun / jna / Memory . java 
 index 7664c3b . . 5d25b2a 100644 
 - - - a / src / com / sun / jna / Memory . java 
 + + + b / src / com / sun / jna / Memory . java 
 @ @ - 13 , 6 + 13 , 7 @ @ package com . sun . jna ; 
 import java . nio . ByteBuffer ; 
 import java . util . Collections ; 
 import java . util . HashMap ; 
 + import java . util . Iterator ; 
 import java . util . Map ; 
 
 / * * 
 @ @ - 39 , 11 + 40 , 14 @ @ import java . util . Map ; 
 public class Memory extends Pointer { 
 
 private static final Map buffers ; 
 + / * * Keep track of all allocated memory so we can dispose of it before unloading . * / 
 + private static final Map allocatedMemory ; 
 
 static { 
 buffers = Collections . synchronizedMap ( Platform . HAS _ BUFFERS 
 ? ( Map ) new WeakIdentityHashMap ( ) 
 : ( Map ) new HashMap ( ) ) ; 
 + allocatedMemory = Collections . synchronizedMap ( new WeakIdentityHashMap ( ) ) ; 
 } 
 
 / * * Force cleanup of memory that has associated NIO Buffers which have 
 @ @ - 53 , 6 + 57 , 13 @ @ public class Memory extends Pointer { 
 buffers . size ( ) ; 
 } 
 
 + public static void disposeAll ( ) { 
 + for ( Iterator i = allocatedMemory . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 + ( ( Memory ) i . next ( ) ) . dispose ( ) ; 
 + } 
 + allocatedMemory . clear ( ) ; 
 + } 
 + 
 protected long size ; / / Size of the malloc ' ed space 
 
 / * * Provide a view into the original memory . Keeps an implicit reference 
 @ @ - 89 , 6 + 100 , 8 @ @ public class Memory extends Pointer { 
 peer = malloc ( size ) ; 
 if ( peer = = 0 ) 
 throw new OutOfMemoryError ( " Cannot allocate " + size + " bytes " ) ; 
 + 
 + allocatedMemory . put ( this , this ) ; 
 } 
 
 protected Memory ( ) { } 
 @ @ - 151 , 7 + 164 , 7 @ @ public class Memory extends Pointer { 
 } 
 
 / * * Free the native memory and set peer to zero * / 
 - protected void dispose ( ) { 
 + protected synchronized void dispose ( ) { 
 free ( peer ) ; 
 peer = 0 ; 
 } 
 @ @ - 674 , 7 + 687 , 10 @ @ public class Memory extends Pointer { 
 } 
 
 protected static void free ( long p ) { 
 - Native . free ( p ) ; 
 + / / free ( 0 ) is a no - op , so avoid the overhead of the call 
 + if ( p ! = 0 ) { 
 + Native . free ( p ) ; 
 + } 
 } 
 
 protected static long malloc ( long size ) { 
 diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java 
 index 4ea1f34 . . de909d6 100644 
 - - - a / src / com / sun / jna / Native . java 
 + + + b / src / com / sun / jna / Native . java 
 @ @ - 154 , 7 + 154 , 7 @ @ public final class Native implements Version { 
 + " - set jna . boot . library . path to include the path to the version of the " + LS 
 + " jnidispatch library included with the JNA jar file you are using " + LS ) ; 
 } 
 - 	 MAX _ ALIGNMENT = Platform . isSPARC ( ) | | Platform . isWindows ( ) 
 + MAX _ ALIGNMENT = Platform . isSPARC ( ) | | Platform . isWindows ( ) 
 | | ( Platform . isLinux ( ) & & ( Platform . isARM ( ) | | Platform . isPPC ( ) ) ) 
 | | Platform . isAIX ( ) 
 | | Platform . isAndroid ( ) 
 @ @ - 162 , 18 + 162 , 22 @ @ public final class Native implements Version { 
 MAX _ PADDING = ( Platform . isMac ( ) & & Platform . isPPC ( ) ) ? 8 : MAX _ ALIGNMENT ; 
 } 
 
 - / * * Force a dispose when this class is GC ' d . * / 
 + / * * Force a dispose when the Native class is GC ' d . * / 
 private static final Object finalizer = new Object ( ) { 
 protected void finalize ( ) { 
 dispose ( ) ; 
 } 
 } ; 
 
 - / * * Properly dispose of JNA functionality . Also called from JNI when 
 + / * * Properly dispose of JNA functionality . 
 + Called when this class is finalized and also from JNI when 
 JNA ' s native shared library is unloaded . 
 * / 
 private static void dispose ( ) { 
 + CallbackReference . disposeAll ( ) ; 
 + Memory . disposeAll ( ) ; 
 NativeLibrary . disposeAll ( ) ; 
 + unregisterAll ( ) ; 
 jnidispatchPath = null ; 
 } 
 
 @ @ - 667 , 20 + 671 , 20 @ @ public final class Native implements Version { 
 String dir = dirs . nextToken ( ) ; 
 File file = new File ( new File ( dir ) , System . mapLibraryName ( libName ) . replace ( " . dylib " , " . jnilib " ) ) ; 
 String path = file . getAbsolutePath ( ) ; 
 - 	 	 if ( DEBUG _ JNA _ LOAD ) { 
 - 	 	 System . out . println ( " Looking in " + path ) ; 
 - 	 	 } 
 + if ( DEBUG _ JNA _ LOAD ) { 
 + System . out . println ( " Looking in " + path ) ; 
 + } 
 if ( file . exists ( ) ) { 
 try { 
 - 	 	 	 if ( DEBUG _ JNA _ LOAD ) { 
 - 	 	 	 System . out . println ( " Trying " + path ) ; 
 - 	 	 	 } 
 + if ( DEBUG _ JNA _ LOAD ) { 
 + System . out . println ( " Trying " + path ) ; 
 + } 
 System . setProperty ( " jnidispatch . path " , path ) ; 
 System . load ( path ) ; 
 jnidispatchPath = path ; 
 - 	 	 	 if ( DEBUG _ JNA _ LOAD ) { 
 - 	 	 	 System . out . println ( " Found jnidispatch at " + path ) ; 
 - 	 	 	 } 
 + if ( DEBUG _ JNA _ LOAD ) { 
 + System . out . println ( " Found jnidispatch at " + path ) ; 
 + } 
 return ; 
 } catch ( UnsatisfiedLinkError ex ) { 
 / / Not a problem if already loaded in anoteher class loader 
 @ @ - 698 , 14 + 702 , 14 @ @ public final class Native implements Version { 
 ext = " dylib " ; 
 } 
 path = path . substring ( 0 , path . lastIndexOf ( orig ) ) + ext ; 
 - 	 	 if ( DEBUG _ JNA _ LOAD ) { 
 - 	 	 	 System . out . println ( " Looking in " + path ) ; 
 - 	 	 } 
 + if ( DEBUG _ JNA _ LOAD ) { 
 + System . out . println ( " Looking in " + path ) ; 
 + } 
 if ( new File ( path ) . exists ( ) ) { 
 try { 
 - 	 	 	 if ( DEBUG _ JNA _ LOAD ) { 
 - 	 	 	 	 System . out . println ( " Trying " + path ) ; 
 - 	 	 	 } 
 + if ( DEBUG _ JNA _ LOAD ) { 
 + System . out . println ( " Trying " + path ) ; 
 + } 
 System . setProperty ( " jnidispatch . path " , path ) ; 
 System . load ( path ) ; 
 jnidispatchPath = path ; 
 @ @ - 722 , 9 + 726 , 9 @ @ public final class Native implements Version { 
 } 
 if ( ! Boolean . getBoolean ( " jna . nosys " ) ) { 
 try { 
 - 	 	 if ( DEBUG _ JNA _ LOAD ) { 
 - 	 	 System . out . println ( " Trying ( via loadLibrary ) " + libName ) ; 
 - 	 	 } 
 + if ( DEBUG _ JNA _ LOAD ) { 
 + System . out . println ( " Trying ( via loadLibrary ) " + libName ) ; 
 + } 
 System . loadLibrary ( libName ) ; 
 if ( DEBUG _ JNA _ LOAD ) { 
 System . out . println ( " Found jnidispatch on system path " ) ; 
 @ @ - 756 , 11 + 760 , 11 @ @ public final class Native implements Version { 
 throw new UnsatisfiedLinkError ( " Could not find JNA native support " ) ; 
 } 
 } 
 - 	 if ( DEBUG _ JNA _ LOAD ) { 
 - 	 	 System . out . println ( " Trying " + lib . getAbsolutePath ( ) ) ; 
 - 	 } 
 + if ( DEBUG _ JNA _ LOAD ) { 
 + System . out . println ( " Trying " + lib . getAbsolutePath ( ) ) ; 
 + } 
 System . setProperty ( " jnidispatch . path " , lib . getAbsolutePath ( ) ) ; 
 - 	 System . load ( lib . getAbsolutePath ( ) ) ; 
 + System . load ( lib . getAbsolutePath ( ) ) ; 
 jnidispatchPath = lib . getAbsolutePath ( ) ; 
 if ( DEBUG _ JNA _ LOAD ) { 
 System . out . println ( " Found jnidispatch at " + jnidispatchPath ) ; 
 @ @ - 821 , 9 + 825 , 9 @ @ public final class Native implements Version { 
 loader = Native . class . getClassLoader ( ) ; 
 } 
 } 
 - 	 if ( DEBUG ) { 
 - 	 System . out . println ( " Looking in classpath from " + loader + " for " + name ) ; 
 - 	 } 
 + if ( DEBUG ) { 
 + System . out . println ( " Looking in classpath from " + loader + " for " + name ) ; 
 + } 
 String libname = name . startsWith ( " / " ) ? name : NativeLibrary . mapSharedLibraryName ( name ) ; 
 String resourcePath = name . startsWith ( " / " ) ? name : Platform . RESOURCE _ PREFIX + " / " + libname ; 
 if ( resourcePath . startsWith ( " / " ) ) { 
 @ @ - 853 , 9 + 857 , 9 @ @ public final class Native implements Version { 
 catch ( URISyntaxException e ) { 
 lib = new File ( url . getPath ( ) ) ; 
 } 
 - 	 if ( DEBUG ) { 
 - 	 	 System . out . println ( " Looking in " + lib . getAbsolutePath ( ) ) ; 
 - 	 } 
 + if ( DEBUG ) { 
 + System . out . println ( " Looking in " + lib . getAbsolutePath ( ) ) ; 
 + } 
 if ( ! lib . exists ( ) ) { 
 throw new IOException ( " File URL " + url + " could not be properly decoded " ) ; 
 } 
 @ @ - 1217 , 17 + 1221 , 16 @ @ public final class Native implements Version { 
 
 private static Map registeredClasses = new HashMap ( ) ; 
 private static Map registeredLibraries = new HashMap ( ) ; 
 - private static Object unloader = new Object ( ) { 
 - protected void finalize ( ) { 
 - synchronized ( registeredClasses ) { 
 - for ( Iterator i = registeredClasses . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 - Map . Entry e = ( Map . Entry ) i . next ( ) ; 
 - unregister ( ( Class ) e . getKey ( ) , ( long [ ] ) e . getValue ( ) ) ; 
 - i . remove ( ) ; 
 - } 
 + 
 + private static void unregisterAll ( ) { 
 + synchronized ( registeredClasses ) { 
 + for ( Iterator i = registeredClasses . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 + Map . Entry e = ( Map . Entry ) i . next ( ) ; 
 + unregister ( ( Class ) e . getKey ( ) , ( long [ ] ) e . getValue ( ) ) ; 
 + i . remove ( ) ; 
 } 
 } 
 - } ; 
 + } 
 
 / * * Remove all native mappings for the calling class . 
 Should only be called if the class is no longer referenced and about 
 @ @ - 1657 , 10 + 1660 , 10 @ @ public final class Native implements Version { 
 * Call the native function being represented by this object 
 * @ param fp function pointer 
 * @ param callFlags calling convention to be used 
 - * @ param 	 args 
 - * 	 	 	 Arguments to pass to the native function 
 + * @ param args 
 + * Arguments to pass to the native function 
 * 
 - * @ return 	 The value returned by the target native function 
 + * @ return The value returned by the target native function 
 * / 
 static native int invokeInt ( long fp , int callFlags , Object [ ] args ) ; 
 
 @ @ - 1668 , 10 + 1671 , 10 @ @ public final class Native implements Version { 
 * Call the native function being represented by this object 
 * @ param fp function pointer 
 * @ param callFlags calling convention to be used 
 - * @ param 	 args 
 - * 	 	 	 Arguments to pass to the native function 
 + * @ param args 
 + * Arguments to pass to the native function 
 * 
 - * @ return 	 The value returned by the target native function 
 + * @ return The value returned by the target native function 
 * / 
 static native long invokeLong ( long fp , int callFlags , Object [ ] args ) ; 
 
 @ @ - 1679 , 8 + 1682 , 8 @ @ public final class Native implements Version { 
 * Call the native function being represented by this object 
 * @ param fp function pointer 
 * @ param callFlags calling convention to be used 
 - * @ param 	 args 
 - * 	 	 	 Arguments to pass to the native function 
 + * @ param args 
 + * Arguments to pass to the native function 
 * / 
 static native void invokeVoid ( long fp , int callFlags , Object [ ] args ) ; 
 
 @ @ - 1688 , 10 + 1691 , 10 @ @ public final class Native implements Version { 
 * Call the native function being represented by this object 
 * @ param fp function pointer 
 * @ param callFlags calling convention to be used 
 - * @ param 	 args 
 - * 	 	 	 Arguments to pass to the native function 
 + * @ param args 
 + * Arguments to pass to the native function 
 * 
 - * @ return 	 The value returned by the target native function 
 + * @ return The value returned by the target native function 
 * / 
 static native float invokeFloat ( long fp , int callFlags , Object [ ] args ) ; 
 
 @ @ - 1699 , 10 + 1702 , 10 @ @ public final class Native implements Version { 
 * Call the native function being represented by this object 
 * @ param fp function pointer 
 * @ param callFlags calling convention to be used 
 - * @ param 	 args 
 - * 	 	 	 Arguments to pass to the native function 
 + * @ param args 
 + * Arguments to pass to the native function 
 * 
 - * @ return 	 The value returned by the target native function 
 + * @ return The value returned by the target native function 
 * / 
 static native double invokeDouble ( long fp , int callFlags , Object [ ] args ) ; 
 
 @ @ - 1710 , 10 + 1713 , 10 @ @ public final class Native implements Version { 
 * Call the native function being represented by this object 
 * @ param fp function pointer 
 * @ param callFlags calling convention to be used 
 - * @ param 	 args 
 - * 	 	 	 Arguments to pass to the native function 
 + * @ param args 
 + * Arguments to pass to the native function 
 * 
 - * @ return 	 The native pointer returned by the target native function 
 + * @ return The native pointer returned by the target native function 
 * / 
 static native long invokePointer ( long fp , int callFlags , Object [ ] args ) ; 


NEAREST DIFF:
diff - - git a / jnalib / native / callback . c b / jnalib / native / callback . c 
 index 32431a5 . . f73b72b 100644 
 - - - a / jnalib / native / callback . c 
 + + + b / jnalib / native / callback . c 
 @ @ - 397 , 7 + 397 , 7 @ @ callback _ dispatch ( JavaVM * jvm , callback * cb , char * ap ) { 
 } 
 else switch ( cb - > return _ jtype ) { 
 case ' V ' : 
 - resuilt . i = 0 ; ( * env ) - > CallVoidMethodA ( env , obj , mid , args ) ; break ; 
 + result . i = 0 ; ( * env ) - > CallVoidMethodA ( env , obj , mid , args ) ; break ; 
 case ' Z ' : 
 result . i = ( * env ) - > CallBooleanMethodA ( env , obj , mid , args ) ; break ; 
 case ' B ' :
