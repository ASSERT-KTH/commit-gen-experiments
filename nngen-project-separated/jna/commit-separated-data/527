BLEU SCORE: 0.027611988917697356

TEST MSG: more Structure ( Pointer ) implementations and tests
GENERATED MSG: fixes # 129

TEST DIFF (one line): diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java <nl> index 1f81897 . . 819f536 100644 <nl> - - - a / src / com / sun / jna / CallbackReference . java <nl> + + + b / src / com / sun / jna / CallbackReference . java <nl> @ @ - 231 , 7 + 231 , 7 @ @ class CallbackReference extends WeakReference { <nl> private Class getNativeType ( Class cls ) { <nl> if ( Structure . class . isAssignableFrom ( cls ) ) { <nl> / / Make sure we can instantiate an argument of this type <nl> - Structure . newInstance ( cls ) ; <nl> + Structure . validate ( cls ) ; <nl> if ( ! Structure . ByValue . class . isAssignableFrom ( cls ) ) <nl> return Pointer . class ; <nl> } <nl> diff - - git a / src / com / sun / jna / Function . java b / src / com / sun / jna / Function . java <nl> index 25491a5 . . 7cf8c1b 100644 <nl> - - - a / src / com / sun / jna / Function . java <nl> + + + b / src / com / sun / jna / Function . java <nl> @ @ - 375 , 9 + 375 , 8 @ @ public class Function extends Pointer { <nl> else { <nl> result = invokePointer ( callFlags , args ) ; <nl> if ( result ! = null ) { <nl> - Structure s = Structure . newInstance ( returnType ) ; <nl> - s . useMemory ( ( Pointer ) result ) ; <nl> - s . autoRead ( ) ; <nl> + Structure s = Structure . newInstance ( returnType , ( Pointer ) result ) ; <nl> + s . conditionalRead ( ) ; <nl> result = s ; <nl> } <nl> } <nl> diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java <nl> index 5a3f61f . . 8f1950b 100644 <nl> - - - a / src / com / sun / jna / Native . java <nl> + + + b / src / com / sun / jna / Native . java <nl> @ @ - 1027 , 7 + 1027 , 7 @ @ public final class Native { <nl> if ( cls = = double . class | | cls = = Double . class ) return 8 ; <nl> if ( Structure . class . isAssignableFrom ( cls ) ) { <nl> if ( Structure . ByValue . class . isAssignableFrom ( cls ) ) { <nl> - return Structure . newInstance ( cls ) . size ( ) ; <nl> + return Structure . size ( cls ) ; <nl> } <nl> return POINTER _ SIZE ; <nl> } <nl> diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java <nl> index 1231031 . . fc3bb8e 100644 <nl> - - - a / src / com / sun / jna / Structure . java <nl> + + + b / src / com / sun / jna / Structure . java <nl> @ @ - 1852 , 4 + 1852 , 9 @ @ public abstract class Structure { <nl> private static final Pointer PLACEHOLDER _ MEMORY = new Pointer ( 0 ) { <nl> public Pointer share ( long offset , long sz ) { return this ; } <nl> } ; <nl> + <nl> + / * * Indicate whether the given Structure class can be created by JNA . * / <nl> + static void validate ( Class cls ) { <nl> + Structure . newInstance ( cls , PLACEHOLDER _ MEMORY ) ; <nl> + } <nl> } <nl> diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java <nl> index d9446bb . . 1818a9b 100644 <nl> - - - a / test / com / sun / jna / CallbacksTest . java <nl> + + + b / test / com / sun / jna / CallbacksTest . java <nl> @ @ - 41 , 6 + 41 , 13 @ @ public class CallbacksTest extends TestCase { <nl> <nl> public static class SmallTestStructure extends Structure { <nl> public double value ; <nl> + public static int allocations = 0 ; <nl> + protected void allocateMemory ( int size ) { <nl> + super . allocateMemory ( size ) ; <nl> + + + allocations ; <nl> + } <nl> + public SmallTestStructure ( ) { } <nl> + public SmallTestStructure ( Pointer p ) { super ( p ) ; read ( ) ; } <nl> protected List getFieldOrder ( ) { <nl> return Arrays . asList ( new String [ ] { " value " } ) ; <nl> } <nl> @ @ - 411 , 6 + 418 , 7 @ @ public class CallbacksTest extends TestCase { <nl> return arg ; <nl> } <nl> } ; <nl> + SmallTestStructure . allocations = 0 ; <nl> SmallTestStructure value = lib . callStructureCallback ( cb , s ) ; <nl> assertTrue ( " Callback not called " , called [ 0 ] ) ; <nl> assertEquals ( " Wrong argument passed to callback " , s . getPointer ( ) , cbarg [ 0 ] ) ; <nl> @ @ - 419 , 6 + 427 , 9 @ @ public class CallbacksTest extends TestCase { <nl> assertEquals ( " Wrong structure return " , s . getPointer ( ) , value . getPointer ( ) ) ; <nl> assertEquals ( " Structure return not synched " , <nl> MAGIC , value . value , 0d ) ; <nl> + / / All structures involved should be created from pointers , with no <nl> + / / memory allocation at all <nl> + assertEquals ( " No structure memory should be allocated " , 0 , SmallTestStructure . allocations ) ; <nl> } <nl> <nl> public void testCallStructureArrayCallback ( ) { <nl> diff - - git a / test / com / sun / jna / ReturnTypesTest . java b / test / com / sun / jna / ReturnTypesTest . java <nl> index f35e345 . . c334d94 100644 <nl> - - - a / test / com / sun / jna / ReturnTypesTest . java <nl> + + + b / test / com / sun / jna / ReturnTypesTest . java <nl> @ @ - 36 , 6 + 36 , 13 @ @ public class ReturnTypesTest extends TestCase { <nl> <nl> public static class SimpleStructure extends Structure { <nl> public double value ; <nl> + public static int allocations = 0 ; <nl> + public SimpleStructure ( ) { } <nl> + public SimpleStructure ( Pointer p ) { super ( p ) ; read ( ) ; } <nl> + protected void allocateMemory ( int size ) { <nl> + super . allocateMemory ( size ) ; <nl> + + + allocations ; <nl> + } <nl> protected List getFieldOrder ( ) { <nl> return Arrays . asList ( new String [ ] { " value " } ) ; <nl> } <nl> @ @ - 230 , 8 + 237 , 10 @ @ public class ReturnTypesTest extends TestCase { <nl> } <nl> <nl> public void testInvokeStructure ( ) { <nl> + SimpleStructure . allocations = 0 ; <nl> SimpleStructure s = lib . returnStaticTestStructure ( ) ; <nl> assertEquals ( " Expect test structure magic " , DOUBLE _ MAGIC , s . value , 0d ) ; <nl> + assertEquals ( " Returned Structure should allocate no memory " , 0 , SimpleStructure . allocations ) ; <nl> } <nl> <nl> public void testInvokeNullStructure ( ) { <nl> diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java <nl> index 2c80f8d . . dea5175 100644 <nl> - - - a / test / com / sun / jna / StructureTest . java <nl> + + + b / test / com / sun / jna / StructureTest . java <nl> @ @ - 352 , 8 + 352 , 9 @ @ public class StructureTest extends TestCase { <nl> } <nl> <nl> / / TODO : add ' l newInstance ( Pointer ) tests : <nl> + / / DirectCallbacksTest . testCallStructureCallback <nl> + / / DirectReturnTypesTest . testInvokeStructure <nl> / / getNativeAlignment <nl> - / / callback convert pointer to structure <nl> / / native call ( direct mode ) ( maybe not . . . ) <nl> public void testStructureFieldAvoidsSeparateMemoryAllocation ( ) { <nl> class TestStructure extends Structure {
NEAREST DIFF (one line): diff - - git a / build . xml b / build . xml <nl> index e622c54 . . 2321abf 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 228 , 6 + 228 , 8 @ @ <nl> < echo > java . home = $ { java . home } < / echo > <nl> < echo > java . library . path = $ { java . library . path } < / echo > <nl> < echo > os . prefix = $ { os . prefix } < / echo > <nl> + < echo > os . name = $ { os . name } < / echo > <nl> + < echo > os . arch = $ { os . arch } < / echo > <nl> < echo > build = $ { build } < / echo > <nl> < echo > build . native = $ { build . native } < / echo > <nl> <nl> diff - - git a / src / com / sun / jna / NativeLibrary . java b / src / com / sun / jna / NativeLibrary . java <nl> index b62afa7 . . d0f0afb 100644 <nl> - - - a / src / com / sun / jna / NativeLibrary . java <nl> + + + b / src / com / sun / jna / NativeLibrary . java <nl> @ @ - 683 , 7 + 683 , 8 @ @ public class NativeLibrary { <nl> / / on 64bit machines , so we have to explicitly search the 64bit <nl> / / one when running a 64bit JVM . <nl> / / <nl> - if ( Platform . isLinux ( ) | | Platform . isSolaris ( ) | | Platform . isFreeBSD ( ) ) { <nl> + if ( Platform . isLinux ( ) | | Platform . isSolaris ( ) <nl> + | | Platform . isFreeBSD ( ) | | Platform . iskFreeBSD ( ) ) { <nl> / / Linux & FreeBSD use / usr / lib32 , solaris uses / usr / lib / 32 <nl> archPath = ( Platform . isSolaris ( ) ? " / " : " " ) + Pointer . SIZE * 8 ; <nl> } <nl> @ @ - 693 , 28 + 694 , 13 @ @ public class NativeLibrary { <nl> " / usr / lib " , <nl> " / lib " , <nl> } ; <nl> - / / Fix for multi - arch support on Ubuntu ( and other <nl> + / / Multi - arch support on Ubuntu ( and other <nl> / / multi - arch distributions ) <nl> / / paths is scanned against real directory <nl> / / so for platforms which are not multi - arch <nl> / / this should continue to work . <nl> - if ( Platform . isLinux ( ) ) { <nl> - / / Defaults - overridden below <nl> - String cpu = " " ; <nl> - String kernel = " linux " ; <nl> - String libc = " gnu " ; <nl> - <nl> - if ( Platform . isIntel ( ) ) { <nl> - cpu = ( Platform . is64Bit ( ) ? " x86 _ 64 " : " i386 " ) ; <nl> - } else if ( Platform . isPPC ( ) ) { <nl> - cpu = ( Platform . is64Bit ( ) ? " powerpc64 " : " powerpc " ) ; <nl> - } else if ( Platform . isARM ( ) ) { <nl> - cpu = " arm " ; <nl> - libc = " gnueabi " ; <nl> - } <nl> - <nl> - String multiArchPath = <nl> - cpu + " - " + kernel + " - " + libc ; <nl> + if ( Platform . isLinux ( ) | | Platform . iskFreeBSD ( ) | | Platform . isGNU ( ) ) { <nl> + String multiArchPath = getMultiArchPath ( ) ; <nl> <nl> / / Assemble path with all possible options <nl> paths = new String [ ] { <nl> @ @ - 739 , 4 + 725 , 25 @ @ public class NativeLibrary { <nl> } <nl> librarySearchPath . addAll ( initPaths ( " jna . platform . library . path " ) ) ; <nl> } <nl> + <nl> + private static String getMultiArchPath ( ) { <nl> + String cpu = System . getProperty ( " os . arch " ) . toLowerCase ( ) . trim ( ) ; <nl> + String kernel = Platform . iskFreeBSD ( ) <nl> + ? " - kfreebsd " <nl> + : ( Platform . isGNU ( ) ? " " : " - linux " ) ; <nl> + String libc = " - gnu " ; <nl> + <nl> + if ( Platform . isIntel ( ) ) { <nl> + cpu = ( Platform . is64Bit ( ) ? " x86 _ 64 " : " i386 " ) ; <nl> + } <nl> + else if ( Platform . isPPC ( ) ) { <nl> + cpu = ( Platform . is64Bit ( ) ? " powerpc64 " : " powerpc " ) ; <nl> + } <nl> + else if ( Platform . isARM ( ) ) { <nl> + cpu = " arm " ; <nl> + libc = " - gnueabi " ; <nl> + } <nl> + <nl> + return cpu + kernel + libc ; <nl> + } <nl> } <nl> diff - - git a / src / com / sun / jna / Platform . java b / src / com / sun / jna / Platform . java <nl> index deafc95 . . 1f1adc3 100644 <nl> - - - a / src / com / sun / jna / Platform . java <nl> + + + b / src / com / sun / jna / Platform . java <nl> @ @ - 21 , 6 + 21 , 8 @ @ public final class Platform { <nl> public static final int WINDOWSCE = 6 ; <nl> public static final int AIX = 7 ; <nl> public static final int ANDROID = 8 ; <nl> + public static final int GNU = 9 ; <nl> + public static final int KFREEBSD = 10 ; <nl> <nl> / * * Whether read - only ( final ) fields within Structures are supported . * / <nl> public static final boolean RO _ FIELDS ; <nl> @ @ - 68 , 6 + 70 , 12 @ @ public final class Platform { <nl> else if ( osName . startsWith ( " OpenBSD " ) ) { <nl> osType = OPENBSD ; <nl> } <nl> + else if ( osName . equalsIgnoreCase ( " gnu " ) ) { <nl> + osType = GNU ; <nl> + } <nl> + else if ( osName . equalsIgnoreCase ( " gnu / kfreebsd " ) ) { <nl> + osType = KFREEBSD ; <nl> + } <nl> else { <nl> osType = UNSPECIFIED ; <nl> } <nl> @ @ - 125 , 6 + 133 , 12 @ @ public final class Platform { <nl> public static final boolean isOpenBSD ( ) { <nl> return osType = = OPENBSD ; <nl> } <nl> + public static final boolean isGNU ( ) { <nl> + return osType = = GNU ; <nl> + } <nl> + public static final boolean iskFreeBSD ( ) { <nl> + return osType = = KFREEBSD ; <nl> + } <nl> public static final boolean isX11 ( ) { <nl> / / TODO : check filesystem for / usr / X11 or some other X11 - specific test <nl> return ! Platform . isWindows ( ) & & ! Platform . isMac ( ) ; <nl> @ @ - 155 , 6 + 169 , 7 @ @ public final class Platform { <nl> String arch = <nl> System . getProperty ( " os . arch " ) . toLowerCase ( ) . trim ( ) ; <nl> if ( arch . equals ( " i386 " ) <nl> + | | arch . startsWith ( " i686 " ) <nl> | | arch . equals ( " x86 " ) <nl> | | arch . equals ( " x86 _ 64 " ) <nl> | | arch . equals ( " amd64 " ) ) {

TEST DIFF:
diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java 
 index 1f81897 . . 819f536 100644 
 - - - a / src / com / sun / jna / CallbackReference . java 
 + + + b / src / com / sun / jna / CallbackReference . java 
 @ @ - 231 , 7 + 231 , 7 @ @ class CallbackReference extends WeakReference { 
 private Class getNativeType ( Class cls ) { 
 if ( Structure . class . isAssignableFrom ( cls ) ) { 
 / / Make sure we can instantiate an argument of this type 
 - Structure . newInstance ( cls ) ; 
 + Structure . validate ( cls ) ; 
 if ( ! Structure . ByValue . class . isAssignableFrom ( cls ) ) 
 return Pointer . class ; 
 } 
 diff - - git a / src / com / sun / jna / Function . java b / src / com / sun / jna / Function . java 
 index 25491a5 . . 7cf8c1b 100644 
 - - - a / src / com / sun / jna / Function . java 
 + + + b / src / com / sun / jna / Function . java 
 @ @ - 375 , 9 + 375 , 8 @ @ public class Function extends Pointer { 
 else { 
 result = invokePointer ( callFlags , args ) ; 
 if ( result ! = null ) { 
 - Structure s = Structure . newInstance ( returnType ) ; 
 - s . useMemory ( ( Pointer ) result ) ; 
 - s . autoRead ( ) ; 
 + Structure s = Structure . newInstance ( returnType , ( Pointer ) result ) ; 
 + s . conditionalRead ( ) ; 
 result = s ; 
 } 
 } 
 diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java 
 index 5a3f61f . . 8f1950b 100644 
 - - - a / src / com / sun / jna / Native . java 
 + + + b / src / com / sun / jna / Native . java 
 @ @ - 1027 , 7 + 1027 , 7 @ @ public final class Native { 
 if ( cls = = double . class | | cls = = Double . class ) return 8 ; 
 if ( Structure . class . isAssignableFrom ( cls ) ) { 
 if ( Structure . ByValue . class . isAssignableFrom ( cls ) ) { 
 - return Structure . newInstance ( cls ) . size ( ) ; 
 + return Structure . size ( cls ) ; 
 } 
 return POINTER _ SIZE ; 
 } 
 diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java 
 index 1231031 . . fc3bb8e 100644 
 - - - a / src / com / sun / jna / Structure . java 
 + + + b / src / com / sun / jna / Structure . java 
 @ @ - 1852 , 4 + 1852 , 9 @ @ public abstract class Structure { 
 private static final Pointer PLACEHOLDER _ MEMORY = new Pointer ( 0 ) { 
 public Pointer share ( long offset , long sz ) { return this ; } 
 } ; 
 + 
 + / * * Indicate whether the given Structure class can be created by JNA . * / 
 + static void validate ( Class cls ) { 
 + Structure . newInstance ( cls , PLACEHOLDER _ MEMORY ) ; 
 + } 
 } 
 diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java 
 index d9446bb . . 1818a9b 100644 
 - - - a / test / com / sun / jna / CallbacksTest . java 
 + + + b / test / com / sun / jna / CallbacksTest . java 
 @ @ - 41 , 6 + 41 , 13 @ @ public class CallbacksTest extends TestCase { 
 
 public static class SmallTestStructure extends Structure { 
 public double value ; 
 + public static int allocations = 0 ; 
 + protected void allocateMemory ( int size ) { 
 + super . allocateMemory ( size ) ; 
 + + + allocations ; 
 + } 
 + public SmallTestStructure ( ) { } 
 + public SmallTestStructure ( Pointer p ) { super ( p ) ; read ( ) ; } 
 protected List getFieldOrder ( ) { 
 return Arrays . asList ( new String [ ] { " value " } ) ; 
 } 
 @ @ - 411 , 6 + 418 , 7 @ @ public class CallbacksTest extends TestCase { 
 return arg ; 
 } 
 } ; 
 + SmallTestStructure . allocations = 0 ; 
 SmallTestStructure value = lib . callStructureCallback ( cb , s ) ; 
 assertTrue ( " Callback not called " , called [ 0 ] ) ; 
 assertEquals ( " Wrong argument passed to callback " , s . getPointer ( ) , cbarg [ 0 ] ) ; 
 @ @ - 419 , 6 + 427 , 9 @ @ public class CallbacksTest extends TestCase { 
 assertEquals ( " Wrong structure return " , s . getPointer ( ) , value . getPointer ( ) ) ; 
 assertEquals ( " Structure return not synched " , 
 MAGIC , value . value , 0d ) ; 
 + / / All structures involved should be created from pointers , with no 
 + / / memory allocation at all 
 + assertEquals ( " No structure memory should be allocated " , 0 , SmallTestStructure . allocations ) ; 
 } 
 
 public void testCallStructureArrayCallback ( ) { 
 diff - - git a / test / com / sun / jna / ReturnTypesTest . java b / test / com / sun / jna / ReturnTypesTest . java 
 index f35e345 . . c334d94 100644 
 - - - a / test / com / sun / jna / ReturnTypesTest . java 
 + + + b / test / com / sun / jna / ReturnTypesTest . java 
 @ @ - 36 , 6 + 36 , 13 @ @ public class ReturnTypesTest extends TestCase { 
 
 public static class SimpleStructure extends Structure { 
 public double value ; 
 + public static int allocations = 0 ; 
 + public SimpleStructure ( ) { } 
 + public SimpleStructure ( Pointer p ) { super ( p ) ; read ( ) ; } 
 + protected void allocateMemory ( int size ) { 
 + super . allocateMemory ( size ) ; 
 + + + allocations ; 
 + } 
 protected List getFieldOrder ( ) { 
 return Arrays . asList ( new String [ ] { " value " } ) ; 
 } 
 @ @ - 230 , 8 + 237 , 10 @ @ public class ReturnTypesTest extends TestCase { 
 } 
 
 public void testInvokeStructure ( ) { 
 + SimpleStructure . allocations = 0 ; 
 SimpleStructure s = lib . returnStaticTestStructure ( ) ; 
 assertEquals ( " Expect test structure magic " , DOUBLE _ MAGIC , s . value , 0d ) ; 
 + assertEquals ( " Returned Structure should allocate no memory " , 0 , SimpleStructure . allocations ) ; 
 } 
 
 public void testInvokeNullStructure ( ) { 
 diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java 
 index 2c80f8d . . dea5175 100644 
 - - - a / test / com / sun / jna / StructureTest . java 
 + + + b / test / com / sun / jna / StructureTest . java 
 @ @ - 352 , 8 + 352 , 9 @ @ public class StructureTest extends TestCase { 
 } 
 
 / / TODO : add ' l newInstance ( Pointer ) tests : 
 + / / DirectCallbacksTest . testCallStructureCallback 
 + / / DirectReturnTypesTest . testInvokeStructure 
 / / getNativeAlignment 
 - / / callback convert pointer to structure 
 / / native call ( direct mode ) ( maybe not . . . ) 
 public void testStructureFieldAvoidsSeparateMemoryAllocation ( ) { 
 class TestStructure extends Structure {

NEAREST DIFF:
diff - - git a / build . xml b / build . xml 
 index e622c54 . . 2321abf 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 228 , 6 + 228 , 8 @ @ 
 < echo > java . home = $ { java . home } < / echo > 
 < echo > java . library . path = $ { java . library . path } < / echo > 
 < echo > os . prefix = $ { os . prefix } < / echo > 
 + < echo > os . name = $ { os . name } < / echo > 
 + < echo > os . arch = $ { os . arch } < / echo > 
 < echo > build = $ { build } < / echo > 
 < echo > build . native = $ { build . native } < / echo > 
 
 diff - - git a / src / com / sun / jna / NativeLibrary . java b / src / com / sun / jna / NativeLibrary . java 
 index b62afa7 . . d0f0afb 100644 
 - - - a / src / com / sun / jna / NativeLibrary . java 
 + + + b / src / com / sun / jna / NativeLibrary . java 
 @ @ - 683 , 7 + 683 , 8 @ @ public class NativeLibrary { 
 / / on 64bit machines , so we have to explicitly search the 64bit 
 / / one when running a 64bit JVM . 
 / / 
 - if ( Platform . isLinux ( ) | | Platform . isSolaris ( ) | | Platform . isFreeBSD ( ) ) { 
 + if ( Platform . isLinux ( ) | | Platform . isSolaris ( ) 
 + | | Platform . isFreeBSD ( ) | | Platform . iskFreeBSD ( ) ) { 
 / / Linux & FreeBSD use / usr / lib32 , solaris uses / usr / lib / 32 
 archPath = ( Platform . isSolaris ( ) ? " / " : " " ) + Pointer . SIZE * 8 ; 
 } 
 @ @ - 693 , 28 + 694 , 13 @ @ public class NativeLibrary { 
 " / usr / lib " , 
 " / lib " , 
 } ; 
 - / / Fix for multi - arch support on Ubuntu ( and other 
 + / / Multi - arch support on Ubuntu ( and other 
 / / multi - arch distributions ) 
 / / paths is scanned against real directory 
 / / so for platforms which are not multi - arch 
 / / this should continue to work . 
 - if ( Platform . isLinux ( ) ) { 
 - / / Defaults - overridden below 
 - String cpu = " " ; 
 - String kernel = " linux " ; 
 - String libc = " gnu " ; 
 - 
 - if ( Platform . isIntel ( ) ) { 
 - cpu = ( Platform . is64Bit ( ) ? " x86 _ 64 " : " i386 " ) ; 
 - } else if ( Platform . isPPC ( ) ) { 
 - cpu = ( Platform . is64Bit ( ) ? " powerpc64 " : " powerpc " ) ; 
 - } else if ( Platform . isARM ( ) ) { 
 - cpu = " arm " ; 
 - libc = " gnueabi " ; 
 - } 
 - 
 - String multiArchPath = 
 - cpu + " - " + kernel + " - " + libc ; 
 + if ( Platform . isLinux ( ) | | Platform . iskFreeBSD ( ) | | Platform . isGNU ( ) ) { 
 + String multiArchPath = getMultiArchPath ( ) ; 
 
 / / Assemble path with all possible options 
 paths = new String [ ] { 
 @ @ - 739 , 4 + 725 , 25 @ @ public class NativeLibrary { 
 } 
 librarySearchPath . addAll ( initPaths ( " jna . platform . library . path " ) ) ; 
 } 
 + 
 + private static String getMultiArchPath ( ) { 
 + String cpu = System . getProperty ( " os . arch " ) . toLowerCase ( ) . trim ( ) ; 
 + String kernel = Platform . iskFreeBSD ( ) 
 + ? " - kfreebsd " 
 + : ( Platform . isGNU ( ) ? " " : " - linux " ) ; 
 + String libc = " - gnu " ; 
 + 
 + if ( Platform . isIntel ( ) ) { 
 + cpu = ( Platform . is64Bit ( ) ? " x86 _ 64 " : " i386 " ) ; 
 + } 
 + else if ( Platform . isPPC ( ) ) { 
 + cpu = ( Platform . is64Bit ( ) ? " powerpc64 " : " powerpc " ) ; 
 + } 
 + else if ( Platform . isARM ( ) ) { 
 + cpu = " arm " ; 
 + libc = " - gnueabi " ; 
 + } 
 + 
 + return cpu + kernel + libc ; 
 + } 
 } 
 diff - - git a / src / com / sun / jna / Platform . java b / src / com / sun / jna / Platform . java 
 index deafc95 . . 1f1adc3 100644 
 - - - a / src / com / sun / jna / Platform . java 
 + + + b / src / com / sun / jna / Platform . java 
 @ @ - 21 , 6 + 21 , 8 @ @ public final class Platform { 
 public static final int WINDOWSCE = 6 ; 
 public static final int AIX = 7 ; 
 public static final int ANDROID = 8 ; 
 + public static final int GNU = 9 ; 
 + public static final int KFREEBSD = 10 ; 
 
 / * * Whether read - only ( final ) fields within Structures are supported . * / 
 public static final boolean RO _ FIELDS ; 
 @ @ - 68 , 6 + 70 , 12 @ @ public final class Platform { 
 else if ( osName . startsWith ( " OpenBSD " ) ) { 
 osType = OPENBSD ; 
 } 
 + else if ( osName . equalsIgnoreCase ( " gnu " ) ) { 
 + osType = GNU ; 
 + } 
 + else if ( osName . equalsIgnoreCase ( " gnu / kfreebsd " ) ) { 
 + osType = KFREEBSD ; 
 + } 
 else { 
 osType = UNSPECIFIED ; 
 } 
 @ @ - 125 , 6 + 133 , 12 @ @ public final class Platform { 
 public static final boolean isOpenBSD ( ) { 
 return osType = = OPENBSD ; 
 } 
 + public static final boolean isGNU ( ) { 
 + return osType = = GNU ; 
 + } 
 + public static final boolean iskFreeBSD ( ) { 
 + return osType = = KFREEBSD ; 
 + } 
 public static final boolean isX11 ( ) { 
 / / TODO : check filesystem for / usr / X11 or some other X11 - specific test 
 return ! Platform . isWindows ( ) & & ! Platform . isMac ( ) ; 
 @ @ - 155 , 6 + 169 , 7 @ @ public final class Platform { 
 String arch = 
 System . getProperty ( " os . arch " ) . toLowerCase ( ) . trim ( ) ; 
 if ( arch . equals ( " i386 " ) 
 + | | arch . startsWith ( " i686 " ) 
 | | arch . equals ( " x86 " ) 
 | | arch . equals ( " x86 _ 64 " ) 
 | | arch . equals ( " amd64 " ) ) {
