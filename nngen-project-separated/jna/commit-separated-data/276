BLEU SCORE: 0.05954672553679791

TEST MSG: refactor for readability
GENERATED MSG: fix compilation warnings / errors on win64

TEST DIFF (one line): diff - - git a / native / callback . c b / native / callback . c <nl> index 3ed9f89 . . 546c50b 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 84 , 11 + 84 , 11 @ @ typedef struct _ tls { <nl> / / Contents set to JNI _ TRUE if thread has terminated and detached properly <nl> int * termination _ flag ; <nl> jboolean jvm _ thread ; <nl> - jboolean detach ; <nl> + jboolean needs _ detach ; <nl> char name [ 256 ] ; <nl> } thread _ storage ; <nl> <nl> - static void callback _ dispatch ( ffi _ cif * , void * , void * * , void * ) ; <nl> + static void dispatch _ callback ( ffi _ cif * , void * , void * * , void * ) ; <nl> static jclass classObject ; <nl> <nl> extern void println ( JNIEnv * , const char * ) ; <nl> @ @ - 99 , 7 + 99 , 7 @ @ extern void println ( JNIEnv * , const char * ) ; <nl> <nl> callback * <nl> create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> - jobjectArray param _ types , jclass return _ type , <nl> + jobjectArray arg _ classes , jclass return _ class , <nl> # ifdef HAS _ ALT _ CALLING _ CONVENTION <nl> callconv _ t calling _ convention , <nl> # else <nl> @ @ - 112 , 7 + 112 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> callback * cb ; <nl> ffi _ abi abi = FFI _ DEFAULT _ ABI ; <nl> ffi _ abi java _ abi = FFI _ DEFAULT _ ABI ; <nl> - ffi _ type * ffi _ rtype ; <nl> + ffi _ type * return _ type ; <nl> ffi _ status status ; <nl> jsize argc ; <nl> JavaVM * vm ; <nl> @ @ - 124 , 10 + 124 , 10 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> const char * throw _ msg = NULL ; <nl> <nl> if ( ( * env ) - > GetJavaVM ( env , & vm ) ! = JNI _ OK ) { <nl> - throwByName ( env , EUnsatisfiedLink , " Can ' t get Java VM to create native callback " ) ; <nl> + throwByName ( env , EUnsatisfiedLink , " Couldn ' t obtain Java VM reference when creating native callback " ) ; <nl> return NULL ; <nl> } <nl> - argc = ( * env ) - > GetArrayLength ( env , param _ types ) ; <nl> + argc = ( * env ) - > GetArrayLength ( env , arg _ classes ) ; <nl> <nl> cb = ( callback * ) malloc ( sizeof ( callback ) ) ; <nl> cb - > closure = ffi _ closure _ alloc ( sizeof ( ffi _ closure ) , & cb - > x _ closure ) ; <nl> @ @ - 149 , 7 + 149 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> <nl> for ( i = 0 ; i < argc ; i + + ) { <nl> int jtype ; <nl> - jclass cls = ( * env ) - > GetObjectArrayElement ( env , param _ types , i ) ; <nl> + jclass cls = ( * env ) - > GetObjectArrayElement ( env , arg _ classes , i ) ; <nl> if ( ( cb - > conversion _ flags [ i ] = get _ conversion _ flag ( env , cls ) ) ! = CVT _ DEFAULT ) { <nl> cb - > arg _ classes [ i ] = ( * env ) - > NewWeakGlobalRef ( env , cls ) ; <nl> cvt = 1 ; <nl> @ @ - 158 , 7 + 158 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> cb - > arg _ classes [ i ] = NULL ; <nl> } <nl> <nl> - jtype = get _ jtype ( env , cls ) ; <nl> + jtype = get _ java _ type ( env , cls ) ; <nl> if ( jtype = = - 1 ) { <nl> snprintf ( msg , sizeof ( msg ) , " Unsupported callback argument at index % d " , i ) ; <nl> throw _ type = EIllegalArgument ; <nl> @ @ - 175 , 7 + 175 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> | | cb - > conversion _ flags [ i ] = = CVT _ INTEGER _ TYPE ) { <nl> jclass ncls ; <nl> ncls = getNativeType ( env , cls ) ; <nl> - jtype = get _ jtype ( env , ncls ) ; <nl> + jtype = get _ java _ type ( env , ncls ) ; <nl> if ( jtype = = - 1 ) { <nl> snprintf ( msg , sizeof ( msg ) , " Unsupported NativeMapped callback argument native type at argument % d " , i ) ; <nl> throw _ type = EIllegalArgument ; <nl> @ @ - 209 , 11 + 209 , 11 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> cb - > arg _ classes = NULL ; <nl> } <nl> if ( direct ) { <nl> - cb - > rflag = get _ conversion _ flag ( env , return _ type ) ; <nl> + cb - > rflag = get _ conversion _ flag ( env , return _ class ) ; <nl> if ( cb - > rflag = = CVT _ NATIVE _ MAPPED <nl> | | cb - > rflag = = CVT _ INTEGER _ TYPE <nl> | | cb - > rflag = = CVT _ POINTER _ TYPE ) { <nl> - return _ type = getNativeType ( env , return _ type ) ; <nl> + return _ class = getNativeType ( env , return _ class ) ; <nl> } <nl> } <nl> <nl> @ @ - 222 , 32 + 222 , 32 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> if ( calling _ convention = = CALLCONV _ STDCALL ) { <nl> abi = FFI _ STDCALL ; <nl> } <nl> - / / Calling into Java on win32 * always * uses stdcall <nl> + / / All JNI entry points on win32 use stdcall <nl> java _ abi = FFI _ STDCALL ; <nl> # endif / / _ WIN32 <nl> <nl> - rtype = get _ jtype ( env , return _ type ) ; <nl> + rtype = get _ java _ type ( env , return _ class ) ; <nl> if ( rtype = = - 1 ) { <nl> throw _ type = EIllegalArgument ; <nl> throw _ msg = " Unsupported callback return type " ; <nl> goto failure _ cleanup ; <nl> } <nl> - ffi _ rtype = get _ ffi _ rtype ( env , return _ type , ( char ) rtype ) ; <nl> - if ( ! ffi _ rtype ) { <nl> + return _ type = get _ ffi _ return _ type ( env , return _ class , ( char ) rtype ) ; <nl> + if ( ! return _ type ) { <nl> throw _ type = EIllegalArgument ; <nl> throw _ msg = " Error in callback return type " ; <nl> goto failure _ cleanup ; <nl> } <nl> - status = ffi _ prep _ cif ( & cb - > cif , abi , argc , ffi _ rtype , cb - > arg _ types ) ; <nl> + status = ffi _ prep _ cif ( & cb - > cif , abi , argc , return _ type , cb - > arg _ types ) ; <nl> if ( ! ffi _ error ( env , " callback setup " , status ) ) { <nl> - ffi _ type * java _ ffi _ rtype = ffi _ rtype ; <nl> + ffi _ type * java _ return _ type = return _ type ; <nl> <nl> if ( cb - > rflag = = CVT _ STRUCTURE _ BYVAL <nl> | | cb - > rflag = = CVT _ NATIVE _ MAPPED <nl> | | cb - > rflag = = CVT _ POINTER _ TYPE <nl> | | cb - > rflag = = CVT _ INTEGER _ TYPE ) { <nl> / / Java method returns a jobject , not a struct <nl> - java _ ffi _ rtype = & ffi _ type _ pointer ; <nl> + java _ return _ type = & ffi _ type _ pointer ; <nl> rtype = ' * ' ; <nl> } <nl> switch ( rtype ) { <nl> @ @ - 263 , 9 + 263 , 9 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> case ' D ' : cb - > fptr _ offset = OFFSETOF ( env , CallDoubleMethod ) ; break ; <nl> default : cb - > fptr _ offset = OFFSETOF ( env , CallObjectMethod ) ; break ; <nl> } <nl> - status = ffi _ prep _ cif _ var ( & cb - > java _ cif , java _ abi , 2 , argc + 3 , java _ ffi _ rtype , cb - > java _ arg _ types ) ; <nl> + status = ffi _ prep _ cif _ var ( & cb - > java _ cif , java _ abi , 2 , argc + 3 , java _ return _ type , cb - > java _ arg _ types ) ; <nl> if ( ! ffi _ error ( env , " callback setup ( 2 ) " , status ) ) { <nl> - ffi _ prep _ closure _ loc ( cb - > closure , & cb - > cif , callback _ dispatch , cb , <nl> + ffi _ prep _ closure _ loc ( cb - > closure , & cb - > cif , dispatch _ callback , cb , <nl> cb - > x _ closure ) ; <nl> # ifdef DLL _ FPTRS <nl> / / Find an available function pointer and assign it <nl> @ @ - 358 , 7 + 358 , 7 @ @ handle _ exception ( JNIEnv * env , jobject cb , jthrowable throwable ) { <nl> } <nl> <nl> static void <nl> - callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbargs ) { <nl> + invoke _ callback ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbargs ) { <nl> jobject self ; <nl> void * oldresp = resp ; <nl> <nl> @ @ - 469 , 7 + 469 , 8 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar <nl> case CVT _ CALLBACK : <nl> * ( void * * ) resp = getCallbackAddress ( env , * ( void * * ) resp ) ; <nl> break ; <nl> - default : break ; <nl> + default : <nl> + break ; <nl> } <nl> if ( cb - > conversion _ flags ) { <nl> for ( i = 0 ; i < cif - > nargs ; i + + ) { <nl> @ @ - 481 , 20 + 482 , 20 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar <nl> } <nl> else { <nl> jobject result ; <nl> - jobjectArray array = <nl> + jobjectArray params = <nl> ( * env ) - > NewObjectArray ( env , cif - > nargs , classObject , NULL ) ; <nl> unsigned int i ; <nl> <nl> for ( i = 0 ; i < cif - > nargs ; i + + ) { <nl> jobject arg = new _ object ( env , cb - > arg _ jtypes [ i ] , cbargs [ i ] , JNI _ FALSE ) ; <nl> - ( * env ) - > SetObjectArrayElement ( env , array , i , arg ) ; <nl> + ( * env ) - > SetObjectArrayElement ( env , params , i , arg ) ; <nl> } <nl> - result = ( * env ) - > CallObjectMethod ( env , self , cb - > methodID , array ) ; <nl> + result = ( * env ) - > CallObjectMethod ( env , self , cb - > methodID , params ) ; <nl> if ( ( * env ) - > ExceptionCheck ( env ) ) { <nl> jthrowable throwable = ( * env ) - > ExceptionOccurred ( env ) ; <nl> ( * env ) - > ExceptionClear ( env ) ; <nl> if ( ! handle _ exception ( env , self , throwable ) ) { <nl> - fprintf ( stderr , " JNA : error handling callback exception , continuing \ n " ) ; <nl> + fprintf ( stderr , " JNA : error while handling callback exception , continuing \ n " ) ; <nl> } <nl> if ( cif - > rtype - > type ! = FFI _ TYPE _ VOID ) <nl> memset ( resp , 0 , cif - > rtype - > size ) ; <nl> @ @ - 589 , 12 + 590 , 12 @ @ static void make _ thread _ data _ key ( ) { <nl> <nl> / * * Store the requested detach state for the current thread . * / <nl> void <nl> - JNA _ detach ( JNIEnv * env , jboolean detach , void * termination _ flag ) { <nl> + JNA _ detach ( JNIEnv * env , jboolean needs _ detach , void * termination _ flag ) { <nl> thread _ storage * tls = get _ thread _ storage ( env ) ; <nl> if ( tls ) { <nl> - tls - > detach = detach ; <nl> + tls - > needs _ detach = needs _ detach ; <nl> tls - > termination _ flag = ( int * ) termination _ flag ; <nl> - if ( detach & & tls - > jvm _ thread ) { <nl> + if ( needs _ detach & & tls - > jvm _ thread ) { <nl> throwByName ( env , EIllegalState , " Can not detach from a JVM thread " ) ; <nl> } <nl> } <nl> @ @ - 620 , 12 + 621 , 12 @ @ JNA _ get _ last _ error ( JNIEnv * env ) { <nl> } <nl> <nl> static void <nl> - callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> + dispatch _ callback ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> callback * cb = ( ( callback * ) user _ data ) ; <nl> JavaVM * jvm = cb - > vm ; <nl> JNIEnv * env = NULL ; <nl> int was _ attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; <nl> - jboolean detach = was _ attached ? JNI _ FALSE : JNI _ TRUE ; <nl> + jboolean needs _ detach = was _ attached ? JNI _ FALSE : JNI _ TRUE ; <nl> thread _ storage * tls = was _ attached ? get _ thread _ storage ( env ) : NULL ; <nl> <nl> if ( ! was _ attached ) { <nl> @ @ - 643 , 7 + 644 , 7 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> options . name = NULL ; <nl> args . group = initializeThread ( cb , & options ) ; <nl> daemon = options . daemon ? JNI _ TRUE : JNI _ FALSE ; <nl> - detach = options . detach ? JNI _ TRUE : JNI _ FALSE ; <nl> + needs _ detach = options . detach ? JNI _ TRUE : JNI _ FALSE ; <nl> args . name = options . name ; <nl> } <nl> if ( daemon ) { <nl> @ @ - 655 , 7 + 656 , 7 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> tls = get _ thread _ storage ( env ) ; <nl> if ( tls ) { <nl> snprintf ( tls - > name , sizeof ( tls - > name ) , " % s " , args . name ? args . name : " < unconfigured native thread > " ) ; <nl> - tls - > detach = detach ; <nl> + tls - > needs _ detach = needs _ detach ; <nl> tls - > jvm _ thread = JNI _ FALSE ; <nl> } <nl> / / Dispose of allocated memory <nl> @ @ - 680 , 13 + 681 , 13 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> fprintf ( stderr , " JNA : Out of memory : Can ' t allocate local frame \ n " ) ; <nl> } <nl> else { <nl> - callback _ invoke ( env , cb , cif , resp , cbargs ) ; <nl> + invoke _ callback ( env , cb , cif , resp , cbargs ) ; <nl> / / Make note of whether the callback wants to avoid detach <nl> - detach = tls - > detach & & ! tls - > jvm _ thread ; <nl> + needs _ detach = tls - > needs _ detach & & ! tls - > jvm _ thread ; <nl> ( * env ) - > PopLocalFrame ( env , NULL ) ; <nl> } <nl> <nl> - if ( detach ) { <nl> + if ( needs _ detach ) { <nl> if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { <nl> fprintf ( stderr , " JNA : could not detach thread \ n " ) ; <nl> } <nl> diff - - git a / native / dispatch . c b / native / dispatch . c <nl> index 4a5969e . . 5ae034a 100644 <nl> - - - a / native / dispatch . c <nl> + + + b / native / dispatch . c <nl> @ @ - 414 , 8 + 414 , 8 @ @ ffi _ error ( JNIEnv * env , const char * op , ffi _ status status ) { <nl> <nl> / * invoke the real native function * / <nl> static void <nl> - dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> - ffi _ type * ffi _ return _ type , void * resP ) <nl> + dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray args , <nl> + ffi _ type * return _ type , void * presult ) <nl> { <nl> int i , nargs ; <nl> jvalue * c _ args ; <nl> @ @ - 427 , 8 + 427 , 8 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> } * array _ elements ; <nl> volatile int array _ count = 0 ; <nl> ffi _ cif cif ; <nl> - ffi _ type * * ffi _ types ; <nl> - void * * ffi _ values ; <nl> + ffi _ type * * arg _ types ; <nl> + void * * arg _ values ; <nl> ffi _ abi abi ; <nl> ffi _ status status ; <nl> char msg [ MSG _ SIZE ] ; <nl> @ @ - 436 , 7 + 436 , 7 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> const char * volatile throw _ type = NULL ; <nl> const char * volatile throw _ msg = NULL ; <nl> <nl> - nargs = ( * env ) - > GetArrayLength ( env , arr ) ; <nl> + nargs = ( * env ) - > GetArrayLength ( env , args ) ; <nl> <nl> if ( nargs > MAX _ NARGS ) { <nl> snprintf ( msg , sizeof ( msg ) , " Too many arguments ( max % ld ) " , MAX _ NARGS ) ; <nl> @ @ - 447 , 42 + 447 , 42 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> c _ args = ( jvalue * ) alloca ( nargs * sizeof ( jvalue ) ) ; <nl> array _ elements = ( struct _ array _ elements * ) <nl> alloca ( nargs * sizeof ( struct _ array _ elements ) ) ; <nl> - ffi _ types = ( ffi _ type * * ) alloca ( nargs * sizeof ( ffi _ type * ) ) ; <nl> - ffi _ values = ( void * * ) alloca ( nargs * sizeof ( void * ) ) ; <nl> + arg _ types = ( ffi _ type * * ) alloca ( nargs * sizeof ( ffi _ type * ) ) ; <nl> + arg _ values = ( void * * ) alloca ( nargs * sizeof ( void * ) ) ; <nl> <nl> for ( i = 0 ; i < nargs ; i + + ) { <nl> - jobject arg = ( * env ) - > GetObjectArrayElement ( env , arr , i ) ; <nl> + jobject arg = ( * env ) - > GetObjectArrayElement ( env , args , i ) ; <nl> <nl> if ( arg = = NULL ) { <nl> c _ args [ i ] . l = NULL ; <nl> - ffi _ types [ i ] = & ffi _ type _ pointer ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . l ; <nl> + arg _ types [ i ] = & ffi _ type _ pointer ; <nl> + arg _ values [ i ] = & c _ args [ i ] . l ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classBoolean ) ) { <nl> c _ args [ i ] . i = ( * env ) - > GetBooleanField ( env , arg , FID _ Boolean _ value ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ sint32 ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . i ; <nl> + arg _ types [ i ] = & ffi _ type _ sint32 ; <nl> + arg _ values [ i ] = & c _ args [ i ] . i ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classByte ) ) { <nl> c _ args [ i ] . b = ( * env ) - > GetByteField ( env , arg , FID _ Byte _ value ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ sint8 ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . b ; <nl> + arg _ types [ i ] = & ffi _ type _ sint8 ; <nl> + arg _ values [ i ] = & c _ args [ i ] . b ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classShort ) ) { <nl> c _ args [ i ] . s = ( * env ) - > GetShortField ( env , arg , FID _ Short _ value ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ sint16 ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . s ; <nl> + arg _ types [ i ] = & ffi _ type _ sint16 ; <nl> + arg _ values [ i ] = & c _ args [ i ] . s ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classCharacter ) ) { <nl> if ( sizeof ( wchar _ t ) = = 2 ) { <nl> c _ args [ i ] . c = ( * env ) - > GetCharField ( env , arg , FID _ Character _ value ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ uint16 ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . c ; <nl> + arg _ types [ i ] = & ffi _ type _ uint16 ; <nl> + arg _ values [ i ] = & c _ args [ i ] . c ; <nl> } <nl> else if ( sizeof ( wchar _ t ) = = 4 ) { <nl> c _ args [ i ] . i = ( * env ) - > GetCharField ( env , arg , FID _ Character _ value ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ uint32 ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . i ; <nl> + arg _ types [ i ] = & ffi _ type _ uint32 ; <nl> + arg _ values [ i ] = & c _ args [ i ] . i ; <nl> } <nl> else { <nl> snprintf ( msg , sizeof ( msg ) , " Unsupported wchar _ t size ( % d ) " , ( int ) sizeof ( wchar _ t ) ) ; <nl> @ @ - 493 , 34 + 493 , 34 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classInteger ) ) { <nl> c _ args [ i ] . i = ( * env ) - > GetIntField ( env , arg , FID _ Integer _ value ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ sint32 ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . i ; <nl> + arg _ types [ i ] = & ffi _ type _ sint32 ; <nl> + arg _ values [ i ] = & c _ args [ i ] . i ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classLong ) ) { <nl> c _ args [ i ] . j = ( * env ) - > GetLongField ( env , arg , FID _ Long _ value ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ sint64 ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . j ; <nl> + arg _ types [ i ] = & ffi _ type _ sint64 ; <nl> + arg _ values [ i ] = & c _ args [ i ] . j ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classFloat ) ) { <nl> c _ args [ i ] . f = ( * env ) - > GetFloatField ( env , arg , FID _ Float _ value ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ float ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . f ; <nl> + arg _ types [ i ] = & ffi _ type _ float ; <nl> + arg _ values [ i ] = & c _ args [ i ] . f ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classDouble ) ) { <nl> c _ args [ i ] . d = ( * env ) - > GetDoubleField ( env , arg , FID _ Double _ value ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ double ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . d ; <nl> + arg _ types [ i ] = & ffi _ type _ double ; <nl> + arg _ values [ i ] = & c _ args [ i ] . d ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classPointer ) ) { <nl> c _ args [ i ] . l = getNativeAddress ( env , arg ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ pointer ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . l ; <nl> + arg _ types [ i ] = & ffi _ type _ pointer ; <nl> + arg _ values [ i ] = & c _ args [ i ] . l ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classStructure ) ) { <nl> c _ args [ i ] . l = getStructureAddress ( env , arg ) ; <nl> - ffi _ types [ i ] = getStructureType ( env , arg ) ; <nl> - ffi _ values [ i ] = c _ args [ i ] . l ; <nl> - if ( ! ffi _ types [ i ] ) { <nl> + arg _ types [ i ] = getStructureType ( env , arg ) ; <nl> + arg _ values [ i ] = c _ args [ i ] . l ; <nl> + if ( ! arg _ types [ i ] ) { <nl> snprintf ( msg , sizeof ( msg ) , <nl> " Structure type info not initialized at argument % d " , i ) ; <nl> throw _ type = EIllegalState ; <nl> @ @ - 531 , 8 + 531 , 8 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> # ifndef NO _ NIO _ BUFFERS <nl> else if ( ( * env ) - > IsInstanceOf ( env , arg , classBuffer ) ) { <nl> c _ args [ i ] . l = getDirectBufferAddress ( env , arg ) ; <nl> - ffi _ types [ i ] = & ffi _ type _ pointer ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . l ; <nl> + arg _ types [ i ] = & ffi _ type _ pointer ; <nl> + arg _ values [ i ] = & c _ args [ i ] . l ; <nl> if ( c _ args [ i ] . l = = NULL ) { <nl> c _ args [ i ] . l = <nl> getBufferArray ( env , arg , & array _ elements [ array _ count ] . array , <nl> @ @ - 569 , 8 + 569 , 8 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> goto cleanup ; <nl> } <nl> c _ args [ i ] . l = ptr ; <nl> - ffi _ types [ i ] = & ffi _ type _ pointer ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . l ; <nl> + arg _ types [ i ] = & ffi _ type _ pointer ; <nl> + arg _ values [ i ] = & c _ args [ i ] . l ; <nl> array _ elements [ array _ count ] . array = arg ; <nl> array _ elements [ array _ count ] . elems = ptr ; <nl> array _ elements [ array _ count + + ] . release = release ; <nl> @ @ - 578 , 8 + 578 , 8 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> else { <nl> / / Anything else , pass directly as a pointer <nl> c _ args [ i ] . l = ( void * ) arg ; <nl> - ffi _ types [ i ] = & ffi _ type _ pointer ; <nl> - ffi _ values [ i ] = & c _ args [ i ] . l ; <nl> + arg _ types [ i ] = & ffi _ type _ pointer ; <nl> + arg _ values [ i ] = & c _ args [ i ] . l ; <nl> } <nl> } <nl> <nl> @ @ - 605 , 13 + 605 , 13 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> goto cleanup ; <nl> } <nl> <nl> - status = ffi _ prep _ cif ( & cif , abi , nargs , ffi _ return _ type , ffi _ types ) ; <nl> + status = ffi _ prep _ cif ( & cif , abi , nargs , return _ type , arg _ types ) ; <nl> if ( ! ffi _ error ( env , " Native call setup " , status ) ) { <nl> PSTART ( ) ; <nl> if ( ( flags & THROW _ LAST _ ERROR ) ! = 0 ) { <nl> SET _ LAST _ ERROR ( 0 ) ; <nl> } <nl> - ffi _ call ( & cif , FFI _ FN ( func ) , resP , ffi _ values ) ; <nl> + ffi _ call ( & cif , FFI _ FN ( func ) , presult , arg _ values ) ; <nl> { <nl> int err = GET _ LAST _ ERROR ( ) ; <nl> JNA _ set _ last _ error ( env , err ) ; <nl> @ @ - 926 , 7 + 926 , 7 @ @ getNativeString ( JNIEnv * env , jstring s , jboolean wide ) { <nl> <nl> int <nl> get _ conversion _ flag ( JNIEnv * env , jclass cls ) { <nl> - int type = get _ jtype ( env , cls ) ; <nl> + int type = get _ java _ type ( env , cls ) ; <nl> if ( type = = ' s ' ) { <nl> return CVT _ STRUCTURE _ BYVAL ; <nl> } <nl> @ @ - 960 , 7 + 960 , 7 @ @ get _ conversion _ flag ( JNIEnv * env , jclass cls ) { <nl> } <nl> <nl> int <nl> - get _ jtype _ from _ ffi _ type ( ffi _ type * type ) { <nl> + get _ java _ type _ from _ ffi _ type ( ffi _ type * type ) { <nl> switch ( type - > type ) { <nl> / / FIXME aliases ' C ' on * nix ; this will cause problems if anyone <nl> / / ever installs a type mapper for char / Character ( not a common arg type ) <nl> @ @ - 977 , 7 + 977 , 7 @ @ get _ jtype _ from _ ffi _ type ( ffi _ type * type ) { <nl> } <nl> <nl> int <nl> - get _ jtype ( JNIEnv * env , jclass cls ) { <nl> + get _ java _ type ( JNIEnv * env , jclass cls ) { <nl> <nl> if ( ( * env ) - > IsSameObject ( env , classVoid , cls ) <nl> | | ( * env ) - > IsSameObject ( env , classPrimitiveVoid , cls ) ) <nl> @ @ - 1144 , 7 + 1144 , 7 @ @ fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , <nl> ffi _ type * native _ return _ type , <nl> jclass java _ return _ class , <nl> void * result _ storage ) { <nl> - int jtype = get _ jtype _ from _ ffi _ type ( native _ return _ type ) ; <nl> + int jtype = get _ java _ type _ from _ ffi _ type ( native _ return _ type ) ; <nl> jobject value = new _ object ( env , ( char ) jtype , native _ return _ value , JNI _ TRUE ) ; <nl> if ( ! ( * env ) - > ExceptionCheck ( env ) ) { <nl> jobject obj = ( * env ) - > CallStaticObjectMethod ( env , classNative , <nl> @ @ - 1171 , 7 + 1171 , 7 @ @ fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , <nl> <nl> jobject <nl> fromNative ( JNIEnv * env , jclass javaClass , ffi _ type * type , void * resp , jboolean promote ) { <nl> - int jtype = get _ jtype _ from _ ffi _ type ( type ) ; <nl> + int jtype = get _ java _ type _ from _ ffi _ type ( type ) ; <nl> jobject value = new _ object ( env , ( char ) jtype , resp , promote ) ; <nl> if ( ! ( * env ) - > ExceptionCheck ( env ) ) { <nl> return ( * env ) - > CallStaticObjectMethod ( env , classNative , <nl> @ @ - 1206 , 7 + 1206 , 7 @ @ getArrayComponentType ( JNIEnv * env , jobject obj ) { <nl> jclass cls = ( * env ) - > GetObjectClass ( env , obj ) ; <nl> jclass type = ( * env ) - > CallObjectMethod ( env , cls , MID _ Class _ getComponentType ) ; <nl> if ( type ! = NULL ) { <nl> - return ( char ) get _ jtype ( env , type ) ; <nl> + return ( char ) get _ java _ type ( env , type ) ; <nl> } <nl> return 0 ; <nl> } <nl> @ @ - 1457 , 9 + 1457 , 9 @ @ JNA _ init ( JNIEnv * env ) { <nl> <nl> / * * Copy value from the given Java object into the given storage buffer . * / <nl> void <nl> - extract _ value ( JNIEnv * env , jobject value , void * resp , size _ t size , jboolean promote ) { <nl> + extract _ value ( JNIEnv * env , jobject value , void * buffer , size _ t size , jboolean promote ) { <nl> if ( value = = NULL ) { <nl> - * ( void * * ) resp = NULL ; <nl> + * ( void * * ) buffer = NULL ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classVoid ) ) { <nl> / / nothing to do <nl> @ @ - 1467 , 67 + 1467 , 67 @ @ extract _ value ( JNIEnv * env , jobject value , void * resp , size _ t size , jboolean prom <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classBoolean ) ) { <nl> jboolean b = ( * env ) - > GetBooleanField ( env , value , FID _ Boolean _ value ) ; <nl> if ( promote ) { <nl> - * ( ffi _ arg * ) resp = b ; <nl> + * ( ffi _ arg * ) buffer = b ; <nl> } <nl> else { <nl> - * ( jint * ) resp = b ; <nl> + * ( jint * ) buffer = b ; <nl> } <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classByte ) ) { <nl> jbyte b = ( * env ) - > GetByteField ( env , value , FID _ Byte _ value ) ; <nl> if ( promote ) { <nl> - * ( ffi _ arg * ) resp = b ; <nl> + * ( ffi _ arg * ) buffer = b ; <nl> } <nl> else { <nl> - * ( jbyte * ) resp = b ; <nl> + * ( jbyte * ) buffer = b ; <nl> } <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classShort ) ) { <nl> jshort s = ( * env ) - > GetShortField ( env , value , FID _ Short _ value ) ; <nl> if ( promote ) { <nl> - * ( ffi _ arg * ) resp = s ; <nl> + * ( ffi _ arg * ) buffer = s ; <nl> } <nl> else { <nl> - * ( jshort * ) resp = s ; <nl> + * ( jshort * ) buffer = s ; <nl> } <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classCharacter ) ) { <nl> jchar c = ( * env ) - > GetCharField ( env , value , FID _ Character _ value ) ; <nl> if ( promote ) { <nl> - * ( ffi _ arg * ) resp = c ; <nl> + * ( ffi _ arg * ) buffer = c ; <nl> } <nl> else { <nl> - * ( wchar _ t * ) resp = c ; <nl> + * ( wchar _ t * ) buffer = c ; <nl> } <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classInteger ) ) { <nl> jint i = ( * env ) - > GetIntField ( env , value , FID _ Integer _ value ) ; <nl> if ( promote ) { <nl> - * ( ffi _ arg * ) resp = i ; <nl> + * ( ffi _ arg * ) buffer = i ; <nl> } <nl> else { <nl> - * ( jint * ) resp = i ; <nl> + * ( jint * ) buffer = i ; <nl> } <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classLong ) ) { <nl> - * ( jlong * ) resp = ( * env ) - > GetLongField ( env , value , FID _ Long _ value ) ; <nl> + * ( jlong * ) buffer = ( * env ) - > GetLongField ( env , value , FID _ Long _ value ) ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classFloat ) ) { <nl> - * ( float * ) resp = ( * env ) - > GetFloatField ( env , value , FID _ Float _ value ) ; <nl> + * ( float * ) buffer = ( * env ) - > GetFloatField ( env , value , FID _ Float _ value ) ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classDouble ) ) { <nl> - * ( double * ) resp = ( * env ) - > GetDoubleField ( env , value , FID _ Double _ value ) ; <nl> + * ( double * ) buffer = ( * env ) - > GetDoubleField ( env , value , FID _ Double _ value ) ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classStructure ) ) { <nl> void * ptr = getStructureAddress ( env , value ) ; <nl> - memcpy ( resp , ptr , size ) ; <nl> + memcpy ( buffer , ptr , size ) ; <nl> } <nl> else if ( ( * env ) - > IsInstanceOf ( env , value , classPointer ) ) { <nl> - * ( void * * ) resp = getNativeAddress ( env , value ) ; <nl> + * ( void * * ) buffer = getNativeAddress ( env , value ) ; <nl> } <nl> else { <nl> fprintf ( stderr , " JNA : extract _ value : unrecognized return type , size % d \ n " , ( int ) size ) ; <nl> - memset ( resp , 0 , size ) ; <nl> + memset ( buffer , 0 , size ) ; <nl> throwByName ( env , EError , " Unrecognized return type " ) ; <nl> } <nl> } <nl> @ @ - 1621 , 7 + 1621 , 7 @ @ get _ ffi _ type ( JNIEnv * env , jclass cls , char jtype ) { <nl> / * * Return the FFI type corresponding to the native equivalent of a <nl> callback function ' s return value . * / <nl> ffi _ type * <nl> - get _ ffi _ rtype ( JNIEnv * env , jclass cls , char jtype ) { <nl> + get _ ffi _ return _ type ( JNIEnv * env , jclass cls , char jtype ) { <nl> switch ( jtype ) { <nl> case ' Z ' : <nl> case ' B ' : <nl> @ @ - 1658 , 7 + 1658 , 7 @ @ typedef struct _ method _ data { <nl> native code <nl> * / <nl> static void <nl> - method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { <nl> + dispatch _ direct ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { <nl> JNIEnv * env = ( JNIEnv * ) * ( void * * ) argp [ 0 ] ; <nl> method _ data * data = ( method _ data * ) cdata ; <nl> <nl> @ @ - 1708 , 7 + 1708 , 7 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { <nl> case CVT _ TYPE _ MAPPER : <nl> { <nl> void * valuep = args [ i ] ; <nl> - int jtype = get _ jtype _ from _ ffi _ type ( data - > closure _ cif . arg _ types [ i + 2 ] ) ; <nl> + int jtype = get _ java _ type _ from _ ffi _ type ( data - > closure _ cif . arg _ types [ i + 2 ] ) ; <nl> jobject obj = jtype = = ' * ' <nl> ? * ( void * * ) valuep <nl> : new _ object ( env , ( char ) jtype , valuep , JNI _ FALSE ) ; <nl> @ @ - 2059 , 13 + 2059 , 13 @ @ Java _ com _ sun _ jna _ Native _ createNativeCallback ( JNIEnv * env , <nl> jclass UNUSED ( cls ) , <nl> jobject obj , <nl> jobject method , <nl> - jobjectArray param _ types , <nl> + jobjectArray arg _ types , <nl> jclass return _ type , <nl> jint call _ conv , <nl> jint options , <nl> jstring encoding ) { <nl> callback * cb = <nl> - create _ callback ( env , obj , method , param _ types , return _ type , <nl> + create _ callback ( env , obj , method , arg _ types , return _ type , <nl> call _ conv , options , encoding ) ; <nl> <nl> return A2L ( cb ) ; <nl> @ @ - 3306 , 7 + 3306 , 7 @ @ Java _ com _ sun _ jna _ Native _ registerMethod ( JNIEnv * env , jclass UNUSED ( ncls ) , <nl> } <nl> <nl> closure = ffi _ closure _ alloc ( sizeof ( ffi _ closure ) , & code ) ; <nl> - status = ffi _ prep _ closure _ loc ( closure , closure _ cif , method _ handler , data , code ) ; <nl> + status = ffi _ prep _ closure _ loc ( closure , closure _ cif , dispatch _ direct , data , code ) ; <nl> if ( status ! = FFI _ OK ) { <nl> throwByName ( env , EError , " Native method linkage failed " ) ; <nl> goto cleanup ; <nl> @ @ - 3337 , 10 + 3337 , 10 @ @ Java _ com _ sun _ jna _ Native _ ffi _ 1call ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong <nl> } <nl> <nl> JNIEXPORT jlong JNICALL <nl> - Java _ com _ sun _ jna _ Native _ ffi _ 1prep _ 1cif ( JNIEnv * env , jclass UNUSED ( cls ) , jint abi , jint nargs , jlong ffi _ return _ type , jlong ffi _ types ) <nl> + Java _ com _ sun _ jna _ Native _ ffi _ 1prep _ 1cif ( JNIEnv * env , jclass UNUSED ( cls ) , jint abi , jint nargs , jlong return _ type , jlong arg _ types ) <nl> { <nl> ffi _ cif * cif = malloc ( sizeof ( ffi _ cif ) ) ; <nl> - ffi _ status s = ffi _ prep _ cif ( L2A ( cif ) , abi ? abi : FFI _ DEFAULT _ ABI , nargs , L2A ( ffi _ return _ type ) , L2A ( ffi _ types ) ) ; <nl> + ffi _ status s = ffi _ prep _ cif ( L2A ( cif ) , abi ? abi : FFI _ DEFAULT _ ABI , nargs , L2A ( return _ type ) , L2A ( arg _ types ) ) ; <nl> if ( ffi _ error ( env , " ffi _ prep _ cif " , s ) ) { <nl> return 0 ; <nl> } <nl> diff - - git a / native / dispatch . h b / native / dispatch . h <nl> index d14d6f5 . . 8686b32 100644 <nl> - - - a / native / dispatch . h <nl> + + + b / native / dispatch . h <nl> @ @ - 179 , 9 + 179 , 9 @ @ typedef struct _ callback { <nl> # define ELastError " com / sun / jna / LastErrorException " <nl> <nl> extern void throwByName ( JNIEnv * env , const char * name , const char * msg ) ; <nl> - extern int get _ jtype ( JNIEnv * , jclass ) ; <nl> + extern int get _ java _ type ( JNIEnv * , jclass ) ; <nl> extern ffi _ type * get _ ffi _ type ( JNIEnv * , jclass , char ) ; <nl> - extern ffi _ type * get _ ffi _ rtype ( JNIEnv * , jclass , char ) ; <nl> + extern ffi _ type * get _ ffi _ return _ type ( JNIEnv * , jclass , char ) ; <nl> extern const char * JNA _ callback _ init ( JNIEnv * ) ; <nl> extern void JNA _ set _ last _ error ( JNIEnv * , int ) ; <nl> extern int JNA _ get _ last _ error ( JNIEnv * ) ;
NEAREST DIFF (one line): diff - - git a / jnalib / dist / darwin . jar b / jnalib / dist / darwin . jar <nl> index 3d9342d . . 9daf3df 100644 <nl> Binary files a / jnalib / dist / darwin . jar and b / jnalib / dist / darwin . jar differ <nl> diff - - git a / jnalib / dist / doc . zip b / jnalib / dist / doc . zip <nl> index 26e4c86 . . 9f965f7 100755 <nl> Binary files a / jnalib / dist / doc . zip and b / jnalib / dist / doc . zip differ <nl> diff - - git a / jnalib / dist / examples . jar b / jnalib / dist / examples . jar <nl> index fadf40d . . c29135c 100644 <nl> Binary files a / jnalib / dist / examples . jar and b / jnalib / dist / examples . jar differ <nl> diff - - git a / jnalib / dist / freebsd - amd64 . jar b / jnalib / dist / freebsd - amd64 . jar <nl> index 3c8b301 . . 90747e8 100644 <nl> Binary files a / jnalib / dist / freebsd - amd64 . jar and b / jnalib / dist / freebsd - amd64 . jar differ <nl> diff - - git a / jnalib / dist / jna . jar b / jnalib / dist / jna . jar <nl> index 0b04289 . . 0f1a705 100644 <nl> Binary files a / jnalib / dist / jna . jar and b / jnalib / dist / jna . jar differ <nl> diff - - git a / jnalib / dist / linux - amd64 . jar b / jnalib / dist / linux - amd64 . jar <nl> index f263a4f . . e0b9eb9 100644 <nl> Binary files a / jnalib / dist / linux - amd64 . jar and b / jnalib / dist / linux - amd64 . jar differ <nl> diff - - git a / jnalib / dist / linux - i386 . jar b / jnalib / dist / linux - i386 . jar <nl> index b4c8d5e . . 7a62758 100644 <nl> Binary files a / jnalib / dist / linux - i386 . jar and b / jnalib / dist / linux - i386 . jar differ <nl> diff - - git a / jnalib / dist / src - full . zip b / jnalib / dist / src - full . zip <nl> index 74d8af3 . . 89caa12 100644 <nl> Binary files a / jnalib / dist / src - full . zip and b / jnalib / dist / src - full . zip differ <nl> diff - - git a / jnalib / dist / src . zip b / jnalib / dist / src . zip <nl> index fe66a8a . . 703d82d 100755 <nl> Binary files a / jnalib / dist / src . zip and b / jnalib / dist / src . zip differ <nl> diff - - git a / jnalib / dist / sunos - amd64 . jar b / jnalib / dist / sunos - amd64 . jar <nl> index ffb65bd . . 1f60f88 100644 <nl> Binary files a / jnalib / dist / sunos - amd64 . jar and b / jnalib / dist / sunos - amd64 . jar differ <nl> diff - - git a / jnalib / dist / sunos - sparc . jar b / jnalib / dist / sunos - sparc . jar <nl> index 5f76bc2 . . 52e5e9d 100644 <nl> Binary files a / jnalib / dist / sunos - sparc . jar and b / jnalib / dist / sunos - sparc . jar differ <nl> diff - - git a / jnalib / dist / sunos - sparcv9 . jar b / jnalib / dist / sunos - sparcv9 . jar <nl> index 4690c74 . . acd2bad 100644 <nl> Binary files a / jnalib / dist / sunos - sparcv9 . jar and b / jnalib / dist / sunos - sparcv9 . jar differ <nl> diff - - git a / jnalib / dist / sunos - x86 . jar b / jnalib / dist / sunos - x86 . jar <nl> index 68824f2 . . a497169 100644 <nl> Binary files a / jnalib / dist / sunos - x86 . jar and b / jnalib / dist / sunos - x86 . jar differ <nl> diff - - git a / jnalib / dist / win32 - amd64 . jar b / jnalib / dist / win32 - amd64 . jar <nl> index cf8385a . . 711b3b6 100755 <nl> Binary files a / jnalib / dist / win32 - amd64 . jar and b / jnalib / dist / win32 - amd64 . jar differ <nl> diff - - git a / jnalib / dist / win32 - x86 . jar b / jnalib / dist / win32 - x86 . jar <nl> index 737216c . . a3bd568 100644 <nl> Binary files a / jnalib / dist / win32 - x86 . jar and b / jnalib / dist / win32 - x86 . jar differ

TEST DIFF:
diff - - git a / native / callback . c b / native / callback . c 
 index 3ed9f89 . . 546c50b 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 84 , 11 + 84 , 11 @ @ typedef struct _ tls { 
 / / Contents set to JNI _ TRUE if thread has terminated and detached properly 
 int * termination _ flag ; 
 jboolean jvm _ thread ; 
 - jboolean detach ; 
 + jboolean needs _ detach ; 
 char name [ 256 ] ; 
 } thread _ storage ; 
 
 - static void callback _ dispatch ( ffi _ cif * , void * , void * * , void * ) ; 
 + static void dispatch _ callback ( ffi _ cif * , void * , void * * , void * ) ; 
 static jclass classObject ; 
 
 extern void println ( JNIEnv * , const char * ) ; 
 @ @ - 99 , 7 + 99 , 7 @ @ extern void println ( JNIEnv * , const char * ) ; 
 
 callback * 
 create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 - jobjectArray param _ types , jclass return _ type , 
 + jobjectArray arg _ classes , jclass return _ class , 
 # ifdef HAS _ ALT _ CALLING _ CONVENTION 
 callconv _ t calling _ convention , 
 # else 
 @ @ - 112 , 7 + 112 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 callback * cb ; 
 ffi _ abi abi = FFI _ DEFAULT _ ABI ; 
 ffi _ abi java _ abi = FFI _ DEFAULT _ ABI ; 
 - ffi _ type * ffi _ rtype ; 
 + ffi _ type * return _ type ; 
 ffi _ status status ; 
 jsize argc ; 
 JavaVM * vm ; 
 @ @ - 124 , 10 + 124 , 10 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 const char * throw _ msg = NULL ; 
 
 if ( ( * env ) - > GetJavaVM ( env , & vm ) ! = JNI _ OK ) { 
 - throwByName ( env , EUnsatisfiedLink , " Can ' t get Java VM to create native callback " ) ; 
 + throwByName ( env , EUnsatisfiedLink , " Couldn ' t obtain Java VM reference when creating native callback " ) ; 
 return NULL ; 
 } 
 - argc = ( * env ) - > GetArrayLength ( env , param _ types ) ; 
 + argc = ( * env ) - > GetArrayLength ( env , arg _ classes ) ; 
 
 cb = ( callback * ) malloc ( sizeof ( callback ) ) ; 
 cb - > closure = ffi _ closure _ alloc ( sizeof ( ffi _ closure ) , & cb - > x _ closure ) ; 
 @ @ - 149 , 7 + 149 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 
 for ( i = 0 ; i < argc ; i + + ) { 
 int jtype ; 
 - jclass cls = ( * env ) - > GetObjectArrayElement ( env , param _ types , i ) ; 
 + jclass cls = ( * env ) - > GetObjectArrayElement ( env , arg _ classes , i ) ; 
 if ( ( cb - > conversion _ flags [ i ] = get _ conversion _ flag ( env , cls ) ) ! = CVT _ DEFAULT ) { 
 cb - > arg _ classes [ i ] = ( * env ) - > NewWeakGlobalRef ( env , cls ) ; 
 cvt = 1 ; 
 @ @ - 158 , 7 + 158 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 cb - > arg _ classes [ i ] = NULL ; 
 } 
 
 - jtype = get _ jtype ( env , cls ) ; 
 + jtype = get _ java _ type ( env , cls ) ; 
 if ( jtype = = - 1 ) { 
 snprintf ( msg , sizeof ( msg ) , " Unsupported callback argument at index % d " , i ) ; 
 throw _ type = EIllegalArgument ; 
 @ @ - 175 , 7 + 175 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 | | cb - > conversion _ flags [ i ] = = CVT _ INTEGER _ TYPE ) { 
 jclass ncls ; 
 ncls = getNativeType ( env , cls ) ; 
 - jtype = get _ jtype ( env , ncls ) ; 
 + jtype = get _ java _ type ( env , ncls ) ; 
 if ( jtype = = - 1 ) { 
 snprintf ( msg , sizeof ( msg ) , " Unsupported NativeMapped callback argument native type at argument % d " , i ) ; 
 throw _ type = EIllegalArgument ; 
 @ @ - 209 , 11 + 209 , 11 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 cb - > arg _ classes = NULL ; 
 } 
 if ( direct ) { 
 - cb - > rflag = get _ conversion _ flag ( env , return _ type ) ; 
 + cb - > rflag = get _ conversion _ flag ( env , return _ class ) ; 
 if ( cb - > rflag = = CVT _ NATIVE _ MAPPED 
 | | cb - > rflag = = CVT _ INTEGER _ TYPE 
 | | cb - > rflag = = CVT _ POINTER _ TYPE ) { 
 - return _ type = getNativeType ( env , return _ type ) ; 
 + return _ class = getNativeType ( env , return _ class ) ; 
 } 
 } 
 
 @ @ - 222 , 32 + 222 , 32 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 if ( calling _ convention = = CALLCONV _ STDCALL ) { 
 abi = FFI _ STDCALL ; 
 } 
 - / / Calling into Java on win32 * always * uses stdcall 
 + / / All JNI entry points on win32 use stdcall 
 java _ abi = FFI _ STDCALL ; 
 # endif / / _ WIN32 
 
 - rtype = get _ jtype ( env , return _ type ) ; 
 + rtype = get _ java _ type ( env , return _ class ) ; 
 if ( rtype = = - 1 ) { 
 throw _ type = EIllegalArgument ; 
 throw _ msg = " Unsupported callback return type " ; 
 goto failure _ cleanup ; 
 } 
 - ffi _ rtype = get _ ffi _ rtype ( env , return _ type , ( char ) rtype ) ; 
 - if ( ! ffi _ rtype ) { 
 + return _ type = get _ ffi _ return _ type ( env , return _ class , ( char ) rtype ) ; 
 + if ( ! return _ type ) { 
 throw _ type = EIllegalArgument ; 
 throw _ msg = " Error in callback return type " ; 
 goto failure _ cleanup ; 
 } 
 - status = ffi _ prep _ cif ( & cb - > cif , abi , argc , ffi _ rtype , cb - > arg _ types ) ; 
 + status = ffi _ prep _ cif ( & cb - > cif , abi , argc , return _ type , cb - > arg _ types ) ; 
 if ( ! ffi _ error ( env , " callback setup " , status ) ) { 
 - ffi _ type * java _ ffi _ rtype = ffi _ rtype ; 
 + ffi _ type * java _ return _ type = return _ type ; 
 
 if ( cb - > rflag = = CVT _ STRUCTURE _ BYVAL 
 | | cb - > rflag = = CVT _ NATIVE _ MAPPED 
 | | cb - > rflag = = CVT _ POINTER _ TYPE 
 | | cb - > rflag = = CVT _ INTEGER _ TYPE ) { 
 / / Java method returns a jobject , not a struct 
 - java _ ffi _ rtype = & ffi _ type _ pointer ; 
 + java _ return _ type = & ffi _ type _ pointer ; 
 rtype = ' * ' ; 
 } 
 switch ( rtype ) { 
 @ @ - 263 , 9 + 263 , 9 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 case ' D ' : cb - > fptr _ offset = OFFSETOF ( env , CallDoubleMethod ) ; break ; 
 default : cb - > fptr _ offset = OFFSETOF ( env , CallObjectMethod ) ; break ; 
 } 
 - status = ffi _ prep _ cif _ var ( & cb - > java _ cif , java _ abi , 2 , argc + 3 , java _ ffi _ rtype , cb - > java _ arg _ types ) ; 
 + status = ffi _ prep _ cif _ var ( & cb - > java _ cif , java _ abi , 2 , argc + 3 , java _ return _ type , cb - > java _ arg _ types ) ; 
 if ( ! ffi _ error ( env , " callback setup ( 2 ) " , status ) ) { 
 - ffi _ prep _ closure _ loc ( cb - > closure , & cb - > cif , callback _ dispatch , cb , 
 + ffi _ prep _ closure _ loc ( cb - > closure , & cb - > cif , dispatch _ callback , cb , 
 cb - > x _ closure ) ; 
 # ifdef DLL _ FPTRS 
 / / Find an available function pointer and assign it 
 @ @ - 358 , 7 + 358 , 7 @ @ handle _ exception ( JNIEnv * env , jobject cb , jthrowable throwable ) { 
 } 
 
 static void 
 - callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbargs ) { 
 + invoke _ callback ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbargs ) { 
 jobject self ; 
 void * oldresp = resp ; 
 
 @ @ - 469 , 7 + 469 , 8 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar 
 case CVT _ CALLBACK : 
 * ( void * * ) resp = getCallbackAddress ( env , * ( void * * ) resp ) ; 
 break ; 
 - default : break ; 
 + default : 
 + break ; 
 } 
 if ( cb - > conversion _ flags ) { 
 for ( i = 0 ; i < cif - > nargs ; i + + ) { 
 @ @ - 481 , 20 + 482 , 20 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar 
 } 
 else { 
 jobject result ; 
 - jobjectArray array = 
 + jobjectArray params = 
 ( * env ) - > NewObjectArray ( env , cif - > nargs , classObject , NULL ) ; 
 unsigned int i ; 
 
 for ( i = 0 ; i < cif - > nargs ; i + + ) { 
 jobject arg = new _ object ( env , cb - > arg _ jtypes [ i ] , cbargs [ i ] , JNI _ FALSE ) ; 
 - ( * env ) - > SetObjectArrayElement ( env , array , i , arg ) ; 
 + ( * env ) - > SetObjectArrayElement ( env , params , i , arg ) ; 
 } 
 - result = ( * env ) - > CallObjectMethod ( env , self , cb - > methodID , array ) ; 
 + result = ( * env ) - > CallObjectMethod ( env , self , cb - > methodID , params ) ; 
 if ( ( * env ) - > ExceptionCheck ( env ) ) { 
 jthrowable throwable = ( * env ) - > ExceptionOccurred ( env ) ; 
 ( * env ) - > ExceptionClear ( env ) ; 
 if ( ! handle _ exception ( env , self , throwable ) ) { 
 - fprintf ( stderr , " JNA : error handling callback exception , continuing \ n " ) ; 
 + fprintf ( stderr , " JNA : error while handling callback exception , continuing \ n " ) ; 
 } 
 if ( cif - > rtype - > type ! = FFI _ TYPE _ VOID ) 
 memset ( resp , 0 , cif - > rtype - > size ) ; 
 @ @ - 589 , 12 + 590 , 12 @ @ static void make _ thread _ data _ key ( ) { 
 
 / * * Store the requested detach state for the current thread . * / 
 void 
 - JNA _ detach ( JNIEnv * env , jboolean detach , void * termination _ flag ) { 
 + JNA _ detach ( JNIEnv * env , jboolean needs _ detach , void * termination _ flag ) { 
 thread _ storage * tls = get _ thread _ storage ( env ) ; 
 if ( tls ) { 
 - tls - > detach = detach ; 
 + tls - > needs _ detach = needs _ detach ; 
 tls - > termination _ flag = ( int * ) termination _ flag ; 
 - if ( detach & & tls - > jvm _ thread ) { 
 + if ( needs _ detach & & tls - > jvm _ thread ) { 
 throwByName ( env , EIllegalState , " Can not detach from a JVM thread " ) ; 
 } 
 } 
 @ @ - 620 , 12 + 621 , 12 @ @ JNA _ get _ last _ error ( JNIEnv * env ) { 
 } 
 
 static void 
 - callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 + dispatch _ callback ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 callback * cb = ( ( callback * ) user _ data ) ; 
 JavaVM * jvm = cb - > vm ; 
 JNIEnv * env = NULL ; 
 int was _ attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; 
 - jboolean detach = was _ attached ? JNI _ FALSE : JNI _ TRUE ; 
 + jboolean needs _ detach = was _ attached ? JNI _ FALSE : JNI _ TRUE ; 
 thread _ storage * tls = was _ attached ? get _ thread _ storage ( env ) : NULL ; 
 
 if ( ! was _ attached ) { 
 @ @ - 643 , 7 + 644 , 7 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 options . name = NULL ; 
 args . group = initializeThread ( cb , & options ) ; 
 daemon = options . daemon ? JNI _ TRUE : JNI _ FALSE ; 
 - detach = options . detach ? JNI _ TRUE : JNI _ FALSE ; 
 + needs _ detach = options . detach ? JNI _ TRUE : JNI _ FALSE ; 
 args . name = options . name ; 
 } 
 if ( daemon ) { 
 @ @ - 655 , 7 + 656 , 7 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 tls = get _ thread _ storage ( env ) ; 
 if ( tls ) { 
 snprintf ( tls - > name , sizeof ( tls - > name ) , " % s " , args . name ? args . name : " < unconfigured native thread > " ) ; 
 - tls - > detach = detach ; 
 + tls - > needs _ detach = needs _ detach ; 
 tls - > jvm _ thread = JNI _ FALSE ; 
 } 
 / / Dispose of allocated memory 
 @ @ - 680 , 13 + 681 , 13 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 fprintf ( stderr , " JNA : Out of memory : Can ' t allocate local frame \ n " ) ; 
 } 
 else { 
 - callback _ invoke ( env , cb , cif , resp , cbargs ) ; 
 + invoke _ callback ( env , cb , cif , resp , cbargs ) ; 
 / / Make note of whether the callback wants to avoid detach 
 - detach = tls - > detach & & ! tls - > jvm _ thread ; 
 + needs _ detach = tls - > needs _ detach & & ! tls - > jvm _ thread ; 
 ( * env ) - > PopLocalFrame ( env , NULL ) ; 
 } 
 
 - if ( detach ) { 
 + if ( needs _ detach ) { 
 if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { 
 fprintf ( stderr , " JNA : could not detach thread \ n " ) ; 
 } 
 diff - - git a / native / dispatch . c b / native / dispatch . c 
 index 4a5969e . . 5ae034a 100644 
 - - - a / native / dispatch . c 
 + + + b / native / dispatch . c 
 @ @ - 414 , 8 + 414 , 8 @ @ ffi _ error ( JNIEnv * env , const char * op , ffi _ status status ) { 
 
 / * invoke the real native function * / 
 static void 
 - dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 - ffi _ type * ffi _ return _ type , void * resP ) 
 + dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray args , 
 + ffi _ type * return _ type , void * presult ) 
 { 
 int i , nargs ; 
 jvalue * c _ args ; 
 @ @ - 427 , 8 + 427 , 8 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 } * array _ elements ; 
 volatile int array _ count = 0 ; 
 ffi _ cif cif ; 
 - ffi _ type * * ffi _ types ; 
 - void * * ffi _ values ; 
 + ffi _ type * * arg _ types ; 
 + void * * arg _ values ; 
 ffi _ abi abi ; 
 ffi _ status status ; 
 char msg [ MSG _ SIZE ] ; 
 @ @ - 436 , 7 + 436 , 7 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 const char * volatile throw _ type = NULL ; 
 const char * volatile throw _ msg = NULL ; 
 
 - nargs = ( * env ) - > GetArrayLength ( env , arr ) ; 
 + nargs = ( * env ) - > GetArrayLength ( env , args ) ; 
 
 if ( nargs > MAX _ NARGS ) { 
 snprintf ( msg , sizeof ( msg ) , " Too many arguments ( max % ld ) " , MAX _ NARGS ) ; 
 @ @ - 447 , 42 + 447 , 42 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 c _ args = ( jvalue * ) alloca ( nargs * sizeof ( jvalue ) ) ; 
 array _ elements = ( struct _ array _ elements * ) 
 alloca ( nargs * sizeof ( struct _ array _ elements ) ) ; 
 - ffi _ types = ( ffi _ type * * ) alloca ( nargs * sizeof ( ffi _ type * ) ) ; 
 - ffi _ values = ( void * * ) alloca ( nargs * sizeof ( void * ) ) ; 
 + arg _ types = ( ffi _ type * * ) alloca ( nargs * sizeof ( ffi _ type * ) ) ; 
 + arg _ values = ( void * * ) alloca ( nargs * sizeof ( void * ) ) ; 
 
 for ( i = 0 ; i < nargs ; i + + ) { 
 - jobject arg = ( * env ) - > GetObjectArrayElement ( env , arr , i ) ; 
 + jobject arg = ( * env ) - > GetObjectArrayElement ( env , args , i ) ; 
 
 if ( arg = = NULL ) { 
 c _ args [ i ] . l = NULL ; 
 - ffi _ types [ i ] = & ffi _ type _ pointer ; 
 - ffi _ values [ i ] = & c _ args [ i ] . l ; 
 + arg _ types [ i ] = & ffi _ type _ pointer ; 
 + arg _ values [ i ] = & c _ args [ i ] . l ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classBoolean ) ) { 
 c _ args [ i ] . i = ( * env ) - > GetBooleanField ( env , arg , FID _ Boolean _ value ) ; 
 - ffi _ types [ i ] = & ffi _ type _ sint32 ; 
 - ffi _ values [ i ] = & c _ args [ i ] . i ; 
 + arg _ types [ i ] = & ffi _ type _ sint32 ; 
 + arg _ values [ i ] = & c _ args [ i ] . i ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classByte ) ) { 
 c _ args [ i ] . b = ( * env ) - > GetByteField ( env , arg , FID _ Byte _ value ) ; 
 - ffi _ types [ i ] = & ffi _ type _ sint8 ; 
 - ffi _ values [ i ] = & c _ args [ i ] . b ; 
 + arg _ types [ i ] = & ffi _ type _ sint8 ; 
 + arg _ values [ i ] = & c _ args [ i ] . b ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classShort ) ) { 
 c _ args [ i ] . s = ( * env ) - > GetShortField ( env , arg , FID _ Short _ value ) ; 
 - ffi _ types [ i ] = & ffi _ type _ sint16 ; 
 - ffi _ values [ i ] = & c _ args [ i ] . s ; 
 + arg _ types [ i ] = & ffi _ type _ sint16 ; 
 + arg _ values [ i ] = & c _ args [ i ] . s ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classCharacter ) ) { 
 if ( sizeof ( wchar _ t ) = = 2 ) { 
 c _ args [ i ] . c = ( * env ) - > GetCharField ( env , arg , FID _ Character _ value ) ; 
 - ffi _ types [ i ] = & ffi _ type _ uint16 ; 
 - ffi _ values [ i ] = & c _ args [ i ] . c ; 
 + arg _ types [ i ] = & ffi _ type _ uint16 ; 
 + arg _ values [ i ] = & c _ args [ i ] . c ; 
 } 
 else if ( sizeof ( wchar _ t ) = = 4 ) { 
 c _ args [ i ] . i = ( * env ) - > GetCharField ( env , arg , FID _ Character _ value ) ; 
 - ffi _ types [ i ] = & ffi _ type _ uint32 ; 
 - ffi _ values [ i ] = & c _ args [ i ] . i ; 
 + arg _ types [ i ] = & ffi _ type _ uint32 ; 
 + arg _ values [ i ] = & c _ args [ i ] . i ; 
 } 
 else { 
 snprintf ( msg , sizeof ( msg ) , " Unsupported wchar _ t size ( % d ) " , ( int ) sizeof ( wchar _ t ) ) ; 
 @ @ - 493 , 34 + 493 , 34 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classInteger ) ) { 
 c _ args [ i ] . i = ( * env ) - > GetIntField ( env , arg , FID _ Integer _ value ) ; 
 - ffi _ types [ i ] = & ffi _ type _ sint32 ; 
 - ffi _ values [ i ] = & c _ args [ i ] . i ; 
 + arg _ types [ i ] = & ffi _ type _ sint32 ; 
 + arg _ values [ i ] = & c _ args [ i ] . i ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classLong ) ) { 
 c _ args [ i ] . j = ( * env ) - > GetLongField ( env , arg , FID _ Long _ value ) ; 
 - ffi _ types [ i ] = & ffi _ type _ sint64 ; 
 - ffi _ values [ i ] = & c _ args [ i ] . j ; 
 + arg _ types [ i ] = & ffi _ type _ sint64 ; 
 + arg _ values [ i ] = & c _ args [ i ] . j ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classFloat ) ) { 
 c _ args [ i ] . f = ( * env ) - > GetFloatField ( env , arg , FID _ Float _ value ) ; 
 - ffi _ types [ i ] = & ffi _ type _ float ; 
 - ffi _ values [ i ] = & c _ args [ i ] . f ; 
 + arg _ types [ i ] = & ffi _ type _ float ; 
 + arg _ values [ i ] = & c _ args [ i ] . f ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classDouble ) ) { 
 c _ args [ i ] . d = ( * env ) - > GetDoubleField ( env , arg , FID _ Double _ value ) ; 
 - ffi _ types [ i ] = & ffi _ type _ double ; 
 - ffi _ values [ i ] = & c _ args [ i ] . d ; 
 + arg _ types [ i ] = & ffi _ type _ double ; 
 + arg _ values [ i ] = & c _ args [ i ] . d ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classPointer ) ) { 
 c _ args [ i ] . l = getNativeAddress ( env , arg ) ; 
 - ffi _ types [ i ] = & ffi _ type _ pointer ; 
 - ffi _ values [ i ] = & c _ args [ i ] . l ; 
 + arg _ types [ i ] = & ffi _ type _ pointer ; 
 + arg _ values [ i ] = & c _ args [ i ] . l ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classStructure ) ) { 
 c _ args [ i ] . l = getStructureAddress ( env , arg ) ; 
 - ffi _ types [ i ] = getStructureType ( env , arg ) ; 
 - ffi _ values [ i ] = c _ args [ i ] . l ; 
 - if ( ! ffi _ types [ i ] ) { 
 + arg _ types [ i ] = getStructureType ( env , arg ) ; 
 + arg _ values [ i ] = c _ args [ i ] . l ; 
 + if ( ! arg _ types [ i ] ) { 
 snprintf ( msg , sizeof ( msg ) , 
 " Structure type info not initialized at argument % d " , i ) ; 
 throw _ type = EIllegalState ; 
 @ @ - 531 , 8 + 531 , 8 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 # ifndef NO _ NIO _ BUFFERS 
 else if ( ( * env ) - > IsInstanceOf ( env , arg , classBuffer ) ) { 
 c _ args [ i ] . l = getDirectBufferAddress ( env , arg ) ; 
 - ffi _ types [ i ] = & ffi _ type _ pointer ; 
 - ffi _ values [ i ] = & c _ args [ i ] . l ; 
 + arg _ types [ i ] = & ffi _ type _ pointer ; 
 + arg _ values [ i ] = & c _ args [ i ] . l ; 
 if ( c _ args [ i ] . l = = NULL ) { 
 c _ args [ i ] . l = 
 getBufferArray ( env , arg , & array _ elements [ array _ count ] . array , 
 @ @ - 569 , 8 + 569 , 8 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 goto cleanup ; 
 } 
 c _ args [ i ] . l = ptr ; 
 - ffi _ types [ i ] = & ffi _ type _ pointer ; 
 - ffi _ values [ i ] = & c _ args [ i ] . l ; 
 + arg _ types [ i ] = & ffi _ type _ pointer ; 
 + arg _ values [ i ] = & c _ args [ i ] . l ; 
 array _ elements [ array _ count ] . array = arg ; 
 array _ elements [ array _ count ] . elems = ptr ; 
 array _ elements [ array _ count + + ] . release = release ; 
 @ @ - 578 , 8 + 578 , 8 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 else { 
 / / Anything else , pass directly as a pointer 
 c _ args [ i ] . l = ( void * ) arg ; 
 - ffi _ types [ i ] = & ffi _ type _ pointer ; 
 - ffi _ values [ i ] = & c _ args [ i ] . l ; 
 + arg _ types [ i ] = & ffi _ type _ pointer ; 
 + arg _ values [ i ] = & c _ args [ i ] . l ; 
 } 
 } 
 
 @ @ - 605 , 13 + 605 , 13 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 goto cleanup ; 
 } 
 
 - status = ffi _ prep _ cif ( & cif , abi , nargs , ffi _ return _ type , ffi _ types ) ; 
 + status = ffi _ prep _ cif ( & cif , abi , nargs , return _ type , arg _ types ) ; 
 if ( ! ffi _ error ( env , " Native call setup " , status ) ) { 
 PSTART ( ) ; 
 if ( ( flags & THROW _ LAST _ ERROR ) ! = 0 ) { 
 SET _ LAST _ ERROR ( 0 ) ; 
 } 
 - ffi _ call ( & cif , FFI _ FN ( func ) , resP , ffi _ values ) ; 
 + ffi _ call ( & cif , FFI _ FN ( func ) , presult , arg _ values ) ; 
 { 
 int err = GET _ LAST _ ERROR ( ) ; 
 JNA _ set _ last _ error ( env , err ) ; 
 @ @ - 926 , 7 + 926 , 7 @ @ getNativeString ( JNIEnv * env , jstring s , jboolean wide ) { 
 
 int 
 get _ conversion _ flag ( JNIEnv * env , jclass cls ) { 
 - int type = get _ jtype ( env , cls ) ; 
 + int type = get _ java _ type ( env , cls ) ; 
 if ( type = = ' s ' ) { 
 return CVT _ STRUCTURE _ BYVAL ; 
 } 
 @ @ - 960 , 7 + 960 , 7 @ @ get _ conversion _ flag ( JNIEnv * env , jclass cls ) { 
 } 
 
 int 
 - get _ jtype _ from _ ffi _ type ( ffi _ type * type ) { 
 + get _ java _ type _ from _ ffi _ type ( ffi _ type * type ) { 
 switch ( type - > type ) { 
 / / FIXME aliases ' C ' on * nix ; this will cause problems if anyone 
 / / ever installs a type mapper for char / Character ( not a common arg type ) 
 @ @ - 977 , 7 + 977 , 7 @ @ get _ jtype _ from _ ffi _ type ( ffi _ type * type ) { 
 } 
 
 int 
 - get _ jtype ( JNIEnv * env , jclass cls ) { 
 + get _ java _ type ( JNIEnv * env , jclass cls ) { 
 
 if ( ( * env ) - > IsSameObject ( env , classVoid , cls ) 
 | | ( * env ) - > IsSameObject ( env , classPrimitiveVoid , cls ) ) 
 @ @ - 1144 , 7 + 1144 , 7 @ @ fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , 
 ffi _ type * native _ return _ type , 
 jclass java _ return _ class , 
 void * result _ storage ) { 
 - int jtype = get _ jtype _ from _ ffi _ type ( native _ return _ type ) ; 
 + int jtype = get _ java _ type _ from _ ffi _ type ( native _ return _ type ) ; 
 jobject value = new _ object ( env , ( char ) jtype , native _ return _ value , JNI _ TRUE ) ; 
 if ( ! ( * env ) - > ExceptionCheck ( env ) ) { 
 jobject obj = ( * env ) - > CallStaticObjectMethod ( env , classNative , 
 @ @ - 1171 , 7 + 1171 , 7 @ @ fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , 
 
 jobject 
 fromNative ( JNIEnv * env , jclass javaClass , ffi _ type * type , void * resp , jboolean promote ) { 
 - int jtype = get _ jtype _ from _ ffi _ type ( type ) ; 
 + int jtype = get _ java _ type _ from _ ffi _ type ( type ) ; 
 jobject value = new _ object ( env , ( char ) jtype , resp , promote ) ; 
 if ( ! ( * env ) - > ExceptionCheck ( env ) ) { 
 return ( * env ) - > CallStaticObjectMethod ( env , classNative , 
 @ @ - 1206 , 7 + 1206 , 7 @ @ getArrayComponentType ( JNIEnv * env , jobject obj ) { 
 jclass cls = ( * env ) - > GetObjectClass ( env , obj ) ; 
 jclass type = ( * env ) - > CallObjectMethod ( env , cls , MID _ Class _ getComponentType ) ; 
 if ( type ! = NULL ) { 
 - return ( char ) get _ jtype ( env , type ) ; 
 + return ( char ) get _ java _ type ( env , type ) ; 
 } 
 return 0 ; 
 } 
 @ @ - 1457 , 9 + 1457 , 9 @ @ JNA _ init ( JNIEnv * env ) { 
 
 / * * Copy value from the given Java object into the given storage buffer . * / 
 void 
 - extract _ value ( JNIEnv * env , jobject value , void * resp , size _ t size , jboolean promote ) { 
 + extract _ value ( JNIEnv * env , jobject value , void * buffer , size _ t size , jboolean promote ) { 
 if ( value = = NULL ) { 
 - * ( void * * ) resp = NULL ; 
 + * ( void * * ) buffer = NULL ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classVoid ) ) { 
 / / nothing to do 
 @ @ - 1467 , 67 + 1467 , 67 @ @ extract _ value ( JNIEnv * env , jobject value , void * resp , size _ t size , jboolean prom 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classBoolean ) ) { 
 jboolean b = ( * env ) - > GetBooleanField ( env , value , FID _ Boolean _ value ) ; 
 if ( promote ) { 
 - * ( ffi _ arg * ) resp = b ; 
 + * ( ffi _ arg * ) buffer = b ; 
 } 
 else { 
 - * ( jint * ) resp = b ; 
 + * ( jint * ) buffer = b ; 
 } 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classByte ) ) { 
 jbyte b = ( * env ) - > GetByteField ( env , value , FID _ Byte _ value ) ; 
 if ( promote ) { 
 - * ( ffi _ arg * ) resp = b ; 
 + * ( ffi _ arg * ) buffer = b ; 
 } 
 else { 
 - * ( jbyte * ) resp = b ; 
 + * ( jbyte * ) buffer = b ; 
 } 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classShort ) ) { 
 jshort s = ( * env ) - > GetShortField ( env , value , FID _ Short _ value ) ; 
 if ( promote ) { 
 - * ( ffi _ arg * ) resp = s ; 
 + * ( ffi _ arg * ) buffer = s ; 
 } 
 else { 
 - * ( jshort * ) resp = s ; 
 + * ( jshort * ) buffer = s ; 
 } 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classCharacter ) ) { 
 jchar c = ( * env ) - > GetCharField ( env , value , FID _ Character _ value ) ; 
 if ( promote ) { 
 - * ( ffi _ arg * ) resp = c ; 
 + * ( ffi _ arg * ) buffer = c ; 
 } 
 else { 
 - * ( wchar _ t * ) resp = c ; 
 + * ( wchar _ t * ) buffer = c ; 
 } 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classInteger ) ) { 
 jint i = ( * env ) - > GetIntField ( env , value , FID _ Integer _ value ) ; 
 if ( promote ) { 
 - * ( ffi _ arg * ) resp = i ; 
 + * ( ffi _ arg * ) buffer = i ; 
 } 
 else { 
 - * ( jint * ) resp = i ; 
 + * ( jint * ) buffer = i ; 
 } 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classLong ) ) { 
 - * ( jlong * ) resp = ( * env ) - > GetLongField ( env , value , FID _ Long _ value ) ; 
 + * ( jlong * ) buffer = ( * env ) - > GetLongField ( env , value , FID _ Long _ value ) ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classFloat ) ) { 
 - * ( float * ) resp = ( * env ) - > GetFloatField ( env , value , FID _ Float _ value ) ; 
 + * ( float * ) buffer = ( * env ) - > GetFloatField ( env , value , FID _ Float _ value ) ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classDouble ) ) { 
 - * ( double * ) resp = ( * env ) - > GetDoubleField ( env , value , FID _ Double _ value ) ; 
 + * ( double * ) buffer = ( * env ) - > GetDoubleField ( env , value , FID _ Double _ value ) ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classStructure ) ) { 
 void * ptr = getStructureAddress ( env , value ) ; 
 - memcpy ( resp , ptr , size ) ; 
 + memcpy ( buffer , ptr , size ) ; 
 } 
 else if ( ( * env ) - > IsInstanceOf ( env , value , classPointer ) ) { 
 - * ( void * * ) resp = getNativeAddress ( env , value ) ; 
 + * ( void * * ) buffer = getNativeAddress ( env , value ) ; 
 } 
 else { 
 fprintf ( stderr , " JNA : extract _ value : unrecognized return type , size % d \ n " , ( int ) size ) ; 
 - memset ( resp , 0 , size ) ; 
 + memset ( buffer , 0 , size ) ; 
 throwByName ( env , EError , " Unrecognized return type " ) ; 
 } 
 } 
 @ @ - 1621 , 7 + 1621 , 7 @ @ get _ ffi _ type ( JNIEnv * env , jclass cls , char jtype ) { 
 / * * Return the FFI type corresponding to the native equivalent of a 
 callback function ' s return value . * / 
 ffi _ type * 
 - get _ ffi _ rtype ( JNIEnv * env , jclass cls , char jtype ) { 
 + get _ ffi _ return _ type ( JNIEnv * env , jclass cls , char jtype ) { 
 switch ( jtype ) { 
 case ' Z ' : 
 case ' B ' : 
 @ @ - 1658 , 7 + 1658 , 7 @ @ typedef struct _ method _ data { 
 native code 
 * / 
 static void 
 - method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { 
 + dispatch _ direct ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { 
 JNIEnv * env = ( JNIEnv * ) * ( void * * ) argp [ 0 ] ; 
 method _ data * data = ( method _ data * ) cdata ; 
 
 @ @ - 1708 , 7 + 1708 , 7 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { 
 case CVT _ TYPE _ MAPPER : 
 { 
 void * valuep = args [ i ] ; 
 - int jtype = get _ jtype _ from _ ffi _ type ( data - > closure _ cif . arg _ types [ i + 2 ] ) ; 
 + int jtype = get _ java _ type _ from _ ffi _ type ( data - > closure _ cif . arg _ types [ i + 2 ] ) ; 
 jobject obj = jtype = = ' * ' 
 ? * ( void * * ) valuep 
 : new _ object ( env , ( char ) jtype , valuep , JNI _ FALSE ) ; 
 @ @ - 2059 , 13 + 2059 , 13 @ @ Java _ com _ sun _ jna _ Native _ createNativeCallback ( JNIEnv * env , 
 jclass UNUSED ( cls ) , 
 jobject obj , 
 jobject method , 
 - jobjectArray param _ types , 
 + jobjectArray arg _ types , 
 jclass return _ type , 
 jint call _ conv , 
 jint options , 
 jstring encoding ) { 
 callback * cb = 
 - create _ callback ( env , obj , method , param _ types , return _ type , 
 + create _ callback ( env , obj , method , arg _ types , return _ type , 
 call _ conv , options , encoding ) ; 
 
 return A2L ( cb ) ; 
 @ @ - 3306 , 7 + 3306 , 7 @ @ Java _ com _ sun _ jna _ Native _ registerMethod ( JNIEnv * env , jclass UNUSED ( ncls ) , 
 } 
 
 closure = ffi _ closure _ alloc ( sizeof ( ffi _ closure ) , & code ) ; 
 - status = ffi _ prep _ closure _ loc ( closure , closure _ cif , method _ handler , data , code ) ; 
 + status = ffi _ prep _ closure _ loc ( closure , closure _ cif , dispatch _ direct , data , code ) ; 
 if ( status ! = FFI _ OK ) { 
 throwByName ( env , EError , " Native method linkage failed " ) ; 
 goto cleanup ; 
 @ @ - 3337 , 10 + 3337 , 10 @ @ Java _ com _ sun _ jna _ Native _ ffi _ 1call ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong 
 } 
 
 JNIEXPORT jlong JNICALL 
 - Java _ com _ sun _ jna _ Native _ ffi _ 1prep _ 1cif ( JNIEnv * env , jclass UNUSED ( cls ) , jint abi , jint nargs , jlong ffi _ return _ type , jlong ffi _ types ) 
 + Java _ com _ sun _ jna _ Native _ ffi _ 1prep _ 1cif ( JNIEnv * env , jclass UNUSED ( cls ) , jint abi , jint nargs , jlong return _ type , jlong arg _ types ) 
 { 
 ffi _ cif * cif = malloc ( sizeof ( ffi _ cif ) ) ; 
 - ffi _ status s = ffi _ prep _ cif ( L2A ( cif ) , abi ? abi : FFI _ DEFAULT _ ABI , nargs , L2A ( ffi _ return _ type ) , L2A ( ffi _ types ) ) ; 
 + ffi _ status s = ffi _ prep _ cif ( L2A ( cif ) , abi ? abi : FFI _ DEFAULT _ ABI , nargs , L2A ( return _ type ) , L2A ( arg _ types ) ) ; 
 if ( ffi _ error ( env , " ffi _ prep _ cif " , s ) ) { 
 return 0 ; 
 } 
 diff - - git a / native / dispatch . h b / native / dispatch . h 
 index d14d6f5 . . 8686b32 100644 
 - - - a / native / dispatch . h 
 + + + b / native / dispatch . h 
 @ @ - 179 , 9 + 179 , 9 @ @ typedef struct _ callback { 
 # define ELastError " com / sun / jna / LastErrorException " 
 
 extern void throwByName ( JNIEnv * env , const char * name , const char * msg ) ; 
 - extern int get _ jtype ( JNIEnv * , jclass ) ; 
 + extern int get _ java _ type ( JNIEnv * , jclass ) ; 
 extern ffi _ type * get _ ffi _ type ( JNIEnv * , jclass , char ) ; 
 - extern ffi _ type * get _ ffi _ rtype ( JNIEnv * , jclass , char ) ; 
 + extern ffi _ type * get _ ffi _ return _ type ( JNIEnv * , jclass , char ) ; 
 extern const char * JNA _ callback _ init ( JNIEnv * ) ; 
 extern void JNA _ set _ last _ error ( JNIEnv * , int ) ; 
 extern int JNA _ get _ last _ error ( JNIEnv * ) ;

NEAREST DIFF:
diff - - git a / jnalib / dist / darwin . jar b / jnalib / dist / darwin . jar 
 index 3d9342d . . 9daf3df 100644 
 Binary files a / jnalib / dist / darwin . jar and b / jnalib / dist / darwin . jar differ 
 diff - - git a / jnalib / dist / doc . zip b / jnalib / dist / doc . zip 
 index 26e4c86 . . 9f965f7 100755 
 Binary files a / jnalib / dist / doc . zip and b / jnalib / dist / doc . zip differ 
 diff - - git a / jnalib / dist / examples . jar b / jnalib / dist / examples . jar 
 index fadf40d . . c29135c 100644 
 Binary files a / jnalib / dist / examples . jar and b / jnalib / dist / examples . jar differ 
 diff - - git a / jnalib / dist / freebsd - amd64 . jar b / jnalib / dist / freebsd - amd64 . jar 
 index 3c8b301 . . 90747e8 100644 
 Binary files a / jnalib / dist / freebsd - amd64 . jar and b / jnalib / dist / freebsd - amd64 . jar differ 
 diff - - git a / jnalib / dist / jna . jar b / jnalib / dist / jna . jar 
 index 0b04289 . . 0f1a705 100644 
 Binary files a / jnalib / dist / jna . jar and b / jnalib / dist / jna . jar differ 
 diff - - git a / jnalib / dist / linux - amd64 . jar b / jnalib / dist / linux - amd64 . jar 
 index f263a4f . . e0b9eb9 100644 
 Binary files a / jnalib / dist / linux - amd64 . jar and b / jnalib / dist / linux - amd64 . jar differ 
 diff - - git a / jnalib / dist / linux - i386 . jar b / jnalib / dist / linux - i386 . jar 
 index b4c8d5e . . 7a62758 100644 
 Binary files a / jnalib / dist / linux - i386 . jar and b / jnalib / dist / linux - i386 . jar differ 
 diff - - git a / jnalib / dist / src - full . zip b / jnalib / dist / src - full . zip 
 index 74d8af3 . . 89caa12 100644 
 Binary files a / jnalib / dist / src - full . zip and b / jnalib / dist / src - full . zip differ 
 diff - - git a / jnalib / dist / src . zip b / jnalib / dist / src . zip 
 index fe66a8a . . 703d82d 100755 
 Binary files a / jnalib / dist / src . zip and b / jnalib / dist / src . zip differ 
 diff - - git a / jnalib / dist / sunos - amd64 . jar b / jnalib / dist / sunos - amd64 . jar 
 index ffb65bd . . 1f60f88 100644 
 Binary files a / jnalib / dist / sunos - amd64 . jar and b / jnalib / dist / sunos - amd64 . jar differ 
 diff - - git a / jnalib / dist / sunos - sparc . jar b / jnalib / dist / sunos - sparc . jar 
 index 5f76bc2 . . 52e5e9d 100644 
 Binary files a / jnalib / dist / sunos - sparc . jar and b / jnalib / dist / sunos - sparc . jar differ 
 diff - - git a / jnalib / dist / sunos - sparcv9 . jar b / jnalib / dist / sunos - sparcv9 . jar 
 index 4690c74 . . acd2bad 100644 
 Binary files a / jnalib / dist / sunos - sparcv9 . jar and b / jnalib / dist / sunos - sparcv9 . jar differ 
 diff - - git a / jnalib / dist / sunos - x86 . jar b / jnalib / dist / sunos - x86 . jar 
 index 68824f2 . . a497169 100644 
 Binary files a / jnalib / dist / sunos - x86 . jar and b / jnalib / dist / sunos - x86 . jar differ 
 diff - - git a / jnalib / dist / win32 - amd64 . jar b / jnalib / dist / win32 - amd64 . jar 
 index cf8385a . . 711b3b6 100755 
 Binary files a / jnalib / dist / win32 - amd64 . jar and b / jnalib / dist / win32 - amd64 . jar differ 
 diff - - git a / jnalib / dist / win32 - x86 . jar b / jnalib / dist / win32 - x86 . jar 
 index 737216c . . a3bd568 100644 
 Binary files a / jnalib / dist / win32 - x86 . jar and b / jnalib / dist / win32 - x86 . jar differ
