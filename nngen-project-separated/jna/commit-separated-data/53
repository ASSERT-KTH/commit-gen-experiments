BLEU SCORE: 0.037477767366779206

TEST MSG: Check attach result before using resulting JNIEnv pointer in callback code
GENERATED MSG: auto - cleanup of attached callback threads

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 34f0559 . . 34e5431 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 51 , 6 + 51 , 7 @ @ Bug Fixes <nl> < li > The resulting ` sunos - x86 . jar ` is copied back to the original build system to ` lib / native / sunos - x86 . jar ` < / li > <nl> < / ol > - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> * [ # 958 ] ( https : / / github . com / java - native - access / jna / issues / 958 ) : Update for PR 863 : Old toolchains produce binaries without hard - / softfloat markers . Rasbian is missinng the markers and the oracle JDK is also affected . For hardfloat detection now also the Arm EABI section is also considered - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> + * [ # 974 ] ( https : / / github . com / java - native - access / jna / issues / 974 ) : If the callback code failed to attach to the JVM , this lead to a segfault . The success of attaching to the JVM was checked to late and an invalid ` JNIEnv ` pointer was used to access the JVM - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> <nl> Breaking Changes <nl> - - - - - - - - - - - - - - - - <nl> diff - - git a / native / callback . c b / native / callback . c <nl> index 52c6165 . . a3881fa 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 686 , 6 + 686 , 14 @ @ dispatch _ callback ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> else { <nl> attach _ status = ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , & args ) ; <nl> } <nl> + if ( attach _ status ! = JNI _ OK ) { <nl> + free ( ( void * ) args . name ) ; <nl> + if ( args . group ) { <nl> + ( * env ) - > DeleteWeakGlobalRef ( env , args . group ) ; <nl> + } <nl> + fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback : % d ( check stacksize for callbacks ) \ n " , attach _ status ) ; <nl> + return ; <nl> + } <nl> tls = get _ thread _ storage ( env ) ; <nl> if ( tls ) { <nl> snprintf ( tls - > name , sizeof ( tls - > name ) , " % s " , args . name ? args . name : " < unconfigured native thread > " ) ; <nl> @ @ - 694 , 15 + 702 , 11 @ @ dispatch _ callback ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> } <nl> / / Dispose of allocated memory <nl> free ( ( void * ) args . name ) ; <nl> - if ( attach _ status ! = JNI _ OK ) { <nl> - fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback : % d \ n " , attach _ status ) ; <nl> - return ; <nl> - } <nl> if ( args . group ) { <nl> ( * env ) - > DeleteWeakGlobalRef ( env , args . group ) ; <nl> } <nl> } <nl> - 	 	 	 	 	 	 <nl> + <nl> if ( ! tls ) { <nl> fprintf ( stderr , " JNA : couldn ' t obtain thread - local storage \ n " ) ; <nl> return ; <nl> diff - - git a / native / testlib . c b / native / testlib . c <nl> index 4c8387f . . 575cf01 100644 <nl> - - - a / native / testlib . c <nl> + + + b / native / testlib . c <nl> @ @ - 54 , 7 + 54 , 7 @ @ typedef _ _ int64 int64 _ t ; <nl> # define EXPORT _ _ declspec ( dllexport ) <nl> # define SLEEP ( MS ) Sleep ( MS ) <nl> # define THREAD _ T DWORD <nl> - # define THREAD _ CREATE ( TP , FN , DATA ) CreateThread ( NULL , 0 , FN , DATA , 0 , TP ) <nl> + # define THREAD _ CREATE ( TP , FN , DATA , STACKSIZE ) CreateThread ( NULL , STACKSIZE , FN , DATA , 0 , TP ) <nl> # define THREAD _ EXIT ( ) ExitThread ( 0 ) <nl> # define THREAD _ FUNC ( FN , ARG ) DWORD WINAPI FN ( LPVOID ARG ) <nl> # define THREAD _ CURRENT ( ) GetCurrentThreadId ( ) <nl> @ @ - 69 , 7 + 69 , 15 @ @ typedef _ _ int64 int64 _ t ; <nl> # include < pthread . h > <nl> # define SLEEP ( MS ) usleep ( MS * 1000 ) <nl> # define THREAD _ T pthread _ t <nl> - # define THREAD _ CREATE ( TP , FN , DATA ) pthread _ create ( TP , NULL , FN , DATA ) <nl> + # define THREAD _ CREATE ( TP , FN , DATA , STACKSIZE ) { \ <nl> + pthread _ attr _ t attr ; \ <nl> + pthread _ attr _ init ( & attr ) ; \ <nl> + if ( STACKSIZE > 0 ) { \ <nl> + pthread _ attr _ setstacksize ( & attr , STACKSIZE ) ; \ <nl> + } \ <nl> + pthread _ create ( TP , & attr , FN , DATA ) ; \ <nl> + pthread _ attr _ destroy ( & attr ) ; \ <nl> + } <nl> # define THREAD _ EXIT ( ) pthread _ exit ( NULL ) <nl> # define THREAD _ FUNC ( FN , ARG ) void * FN ( void * ARG ) <nl> # define THREAD _ RETURN return NULL <nl> @ @ - 676 , 7 + 684 , 7 @ @ static THREAD _ FUNC ( thread _ function , arg ) { <nl> } <nl> <nl> EXPORT void <nl> - callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms , const char * name ) { <nl> + callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms , const char * name , int stacksize ) { <nl> THREAD _ T thread ; <nl> thread _ data * data = ( thread _ data * ) malloc ( sizeof ( thread _ data ) ) ; <nl> <nl> @ @ - 684 , 7 + 692 , 7 @ @ callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms , const char * name ) { <nl> data - > sleep _ time = ms ; <nl> data - > func = func ; <nl> snprintf ( data - > name , sizeof ( data - > name ) , " % s " , name ) ; <nl> - THREAD _ CREATE ( & thread , & thread _ function , data ) ; <nl> + THREAD _ CREATE ( & thread , & thread _ function , data , stacksize ) ; <nl> } <nl> <nl> EXPORT int <nl> diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java <nl> index 9aa97fe . . 9348d26 100644 <nl> - - - a / test / com / sun / jna / CallbacksTest . java <nl> + + + b / test / com / sun / jna / CallbacksTest . java <nl> @ @ - 127 , 7 + 127 , 7 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> void callback ( ) ; <nl> } <nl> void callVoidCallback ( VoidCallback c ) ; <nl> - void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name ) ; <nl> + void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name , int stacksize ) ; <nl> interface VoidCallbackCustom extends Callback { <nl> void customMethodName ( ) ; <nl> } <nl> @ @ - 1215 , 7 + 1215 , 7 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> if ( cti ! = null ) { <nl> Native . setCallbackThreadInitializer ( cb , cti ) ; <nl> } <nl> - lib . callVoidCallbackThreaded ( cb , repeat , sleepms , getName ( ) ) ; <nl> + lib . callVoidCallbackThreaded ( cb , repeat , sleepms , getName ( ) , 0 ) ; <nl> <nl> long start = System . currentTimeMillis ( ) ; <nl> while ( called [ 0 ] < returnAfter ) { <nl> @ @ - 1304 , 6 + 1304 , 25 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> waitFor ( t [ 0 ] ) ; <nl> } <nl> <nl> + public void testSmallStackCallback ( ) throws Exception { <nl> + / / This test runs the callback in a thread , that is allocated a very <nl> + / / small size . It was observed on linux amd64 , that a library allocated <nl> + / / a stack size of 64kB , this prevented the JVM to attach to that <nl> + / / thread . The JNIEnv pointer was not checked and this lead to a <nl> + / / hard crash of the JVM . <nl> + TestLibrary . VoidCallback cb = new TestLibrary . VoidCallback ( ) { <nl> + @ Override <nl> + public void callback ( ) { <nl> + System . out . println ( " Callback called " ) ; <nl> + } <nl> + } ; <nl> + <nl> + lib . callVoidCallbackThreaded ( cb , 1 , 0 , " Test Callback " , 64 * 1024 ) ; <nl> + <nl> + / / Give the JVM enough time to run the call back <nl> + Thread . sleep ( 1 * 1000 ) ; <nl> + } <nl> + <nl> / / Detach preference is indicated by the initializer . Thread is attached <nl> / / as daemon to avoid VM having to wait for it . <nl> public void testCallbackThreadPersistence ( ) throws Exception { <nl> diff - - git a / test / com / sun / jna / DirectCallbacksTest . java b / test / com / sun / jna / DirectCallbacksTest . java <nl> index d15e338 . . ec2d277 100644 <nl> - - - a / test / com / sun / jna / DirectCallbacksTest . java <nl> + + + b / test / com / sun / jna / DirectCallbacksTest . java <nl> @ @ - 73 , 7 + 73 , 7 @ @ public class DirectCallbacksTest extends CallbacksTest { <nl> @ Override <nl> public native void callVoidCallback ( VoidCallback c ) ; <nl> @ Override <nl> - public native void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name ) ; <nl> + public native void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name , int stacksize ) ; <nl> <nl> @ Override <nl> public native int callInt32Callback ( CustomCallback cb , int arg1 , int arg2 ) ;
NEAREST DIFF (one line): diff - - git a / native / Makefile b / native / Makefile <nl> index 070dcb6 . . 480979f 100644 <nl> - - - a / native / Makefile <nl> + + + b / native / Makefile <nl> @ @ - 284 , 7 + 284 , 7 @ @ endif <nl> # Unfortunately , we have to use different libffi include files depending on <nl> # the target , so we can ' t do a simple universal build on darwin . Do <nl> # separate builds , then merge the results . <nl> - $ ( BUILD ) / % . o : % . c dispatch . h thread . h protect . h $ ( FFI _ LIB ) <nl> + $ ( BUILD ) / % . o : % . c dispatch . h protect . h $ ( FFI _ LIB ) <nl> 	 @ mkdir - p $ ( BUILD ) <nl> ifneq ( $ ( SDKROOT ) , ) <nl> 	 $ ( CC ) - arch $ ( ARCH ) $ ( CFLAGS ) - c $ < - o $ @ . $ ( ARCH ) <nl> diff - - git a / native / callback . c b / native / callback . c <nl> index b3e6fd0 . . 1e971b1 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 25 , 7 + 25 , 6 @ @ <nl> # include < sys / param . h > <nl> # endif <nl> # include " dispatch . h " <nl> - # include " thread . h " <nl> <nl> # ifdef _ _ cplusplus <nl> extern " C " { <nl> @ @ - 389 , 10 + 388 , 19 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar <nl> } <nl> } <nl> <nl> - # ifdef THREAD _ EXIT _ CLEANUP <nl> - static void <nl> - detach _ thread ( void * data ) { <nl> - THREAD _ EXIT _ CLEANUP ( data ) ; <nl> + # ifndef _ WIN32 <nl> + # include < pthread . h > <nl> + <nl> + static pthread _ key _ t key ; <nl> + static pthread _ once _ t key _ once = PTHREAD _ ONCE _ INIT ; <nl> + <nl> + static void detach _ thread ( void * data ) { <nl> + JavaVM * jvm = ( JavaVM * ) data ; <nl> + ( * jvm ) - > DetachCurrentThread ( jvm ) ; <nl> + } <nl> + <nl> + static void make _ key ( ) { <nl> + pthread _ key _ create ( & key , detach _ thread ) ; <nl> } <nl> # endif <nl> <nl> @ @ - 460 , 8 + 468 , 11 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> ( * jvm ) - > DetachCurrentThread ( jvm ) ; <nl> } <nl> else if ( ! was _ attached ) { <nl> - # ifdef ON _ THREAD _ EXIT <nl> - ON _ THREAD _ EXIT ( detach _ thread , jvm ) ; <nl> + # ifndef _ WIN32 <nl> + pthread _ once ( & key _ once , make _ key ) ; <nl> + if ( pthread _ getspecific ( key ) = = NULL ) { <nl> + pthread _ setspecific ( key , jvm ) ; <nl> + } <nl> # endif <nl> } <nl> } <nl> diff - - git a / native / thread . h b / native / thread . h <nl> deleted file mode 100644 <nl> index 2ab1b18 . . 0000000 <nl> - - - a / native / thread . h <nl> + + + / dev / null <nl> @ @ - 1 , 51 + 0 , 0 @ @ <nl> - / * Copyright ( c ) 20012 Timothy Wall , All Rights Reserved <nl> - * <nl> - * This library is free software ; you can redistribute it and / or <nl> - * modify it under the terms of the GNU Lesser General Public <nl> - * License as published by the Free Software Foundation ; either <nl> - * version 2 . 1 of the License , or ( at your option ) any later version . <nl> - * < p / > <nl> - * This library is distributed in the hope that it will be useful , <nl> - * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> - * / <nl> - # ifndef THREAD _ H <nl> - # define THREAD _ H <nl> - <nl> - # ifndef _ WIN32 <nl> - <nl> - # include < pthread . h > <nl> - <nl> - # ifdef _ _ APPLE _ _ <nl> - struct _ thread _ cleanup _ data { <nl> - struct _ _ darwin _ pthread _ handler _ rec * _ _ handler ; <nl> - JavaVM * _ _ jvm ; <nl> - } ; <nl> - # define THREAD _ EXIT _ CLEANUP ( DATA ) do { \ <nl> - struct _ thread _ cleanup _ data * _ _ data = ( struct _ thread _ cleanup _ data * ) DATA ; \ <nl> - pthread _ t _ _ self = pthread _ self ( ) ; \ <nl> - fprintf ( stderr , " detach thread % p \ n " , _ _ self ) ; \ <nl> - _ _ self - > _ _ cleanup _ stack = _ _ data - > _ _ handler - > _ _ next ; \ <nl> - ( * ( _ _ data - > _ _ jvm ) ) - > DetachCurrentThread ( _ _ data - > _ _ jvm ) ; \ <nl> - / * free ( _ _ data - > _ _ handler ) ; * / \ <nl> - free ( _ _ data ) ; \ <nl> - fprintf ( stderr , " detach thread % p done \ n " , _ _ self ) ; \ <nl> - } while ( 0 ) <nl> - # define ON _ THREAD _ EXIT ( PROC , JVM ) do { \ <nl> - struct _ thread _ cleanup _ data * _ _ data = ( struct _ thread _ cleanup _ data * ) malloc ( sizeof ( struct _ thread _ cleanup _ data ) ) ; \ <nl> - struct _ _ darwin _ pthread _ handler _ rec * _ _ handler = \ <nl> - ( struct _ _ darwin _ pthread _ handler _ rec * ) malloc ( sizeof ( struct _ _ darwin _ pthread _ handler _ rec ) ) ; \ <nl> - pthread _ t _ _ self = pthread _ self ( ) ; \ <nl> - _ _ handler - > _ _ routine = PROC ; \ <nl> - _ _ handler - > _ _ arg = _ _ data ; \ <nl> - _ _ handler - > _ _ next = _ _ self - > _ _ cleanup _ stack ; \ <nl> - _ _ self - > _ _ cleanup _ stack = _ _ handler ; \ <nl> - _ _ data - > _ _ handler = _ _ handler ; \ <nl> - _ _ data - > _ _ jvm = JVM ; \ <nl> - } while ( 0 ) <nl> - # endif / * _ _ APPLE _ _ * / <nl> - <nl> - # endif / * ! _ WIN32 * / <nl> - <nl> - # endif / * THREAD _ H * /

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 34f0559 . . 34e5431 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 51 , 6 + 51 , 7 @ @ Bug Fixes 
 < li > The resulting ` sunos - x86 . jar ` is copied back to the original build system to ` lib / native / sunos - x86 . jar ` < / li > 
 < / ol > - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 * [ # 958 ] ( https : / / github . com / java - native - access / jna / issues / 958 ) : Update for PR 863 : Old toolchains produce binaries without hard - / softfloat markers . Rasbian is missinng the markers and the oracle JDK is also affected . For hardfloat detection now also the Arm EABI section is also considered - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 + * [ # 974 ] ( https : / / github . com / java - native - access / jna / issues / 974 ) : If the callback code failed to attach to the JVM , this lead to a segfault . The success of attaching to the JVM was checked to late and an invalid ` JNIEnv ` pointer was used to access the JVM - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 
 Breaking Changes 
 - - - - - - - - - - - - - - - - 
 diff - - git a / native / callback . c b / native / callback . c 
 index 52c6165 . . a3881fa 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 686 , 6 + 686 , 14 @ @ dispatch _ callback ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 else { 
 attach _ status = ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , & args ) ; 
 } 
 + if ( attach _ status ! = JNI _ OK ) { 
 + free ( ( void * ) args . name ) ; 
 + if ( args . group ) { 
 + ( * env ) - > DeleteWeakGlobalRef ( env , args . group ) ; 
 + } 
 + fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback : % d ( check stacksize for callbacks ) \ n " , attach _ status ) ; 
 + return ; 
 + } 
 tls = get _ thread _ storage ( env ) ; 
 if ( tls ) { 
 snprintf ( tls - > name , sizeof ( tls - > name ) , " % s " , args . name ? args . name : " < unconfigured native thread > " ) ; 
 @ @ - 694 , 15 + 702 , 11 @ @ dispatch _ callback ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 } 
 / / Dispose of allocated memory 
 free ( ( void * ) args . name ) ; 
 - if ( attach _ status ! = JNI _ OK ) { 
 - fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback : % d \ n " , attach _ status ) ; 
 - return ; 
 - } 
 if ( args . group ) { 
 ( * env ) - > DeleteWeakGlobalRef ( env , args . group ) ; 
 } 
 } 
 - 	 	 	 	 	 	 
 + 
 if ( ! tls ) { 
 fprintf ( stderr , " JNA : couldn ' t obtain thread - local storage \ n " ) ; 
 return ; 
 diff - - git a / native / testlib . c b / native / testlib . c 
 index 4c8387f . . 575cf01 100644 
 - - - a / native / testlib . c 
 + + + b / native / testlib . c 
 @ @ - 54 , 7 + 54 , 7 @ @ typedef _ _ int64 int64 _ t ; 
 # define EXPORT _ _ declspec ( dllexport ) 
 # define SLEEP ( MS ) Sleep ( MS ) 
 # define THREAD _ T DWORD 
 - # define THREAD _ CREATE ( TP , FN , DATA ) CreateThread ( NULL , 0 , FN , DATA , 0 , TP ) 
 + # define THREAD _ CREATE ( TP , FN , DATA , STACKSIZE ) CreateThread ( NULL , STACKSIZE , FN , DATA , 0 , TP ) 
 # define THREAD _ EXIT ( ) ExitThread ( 0 ) 
 # define THREAD _ FUNC ( FN , ARG ) DWORD WINAPI FN ( LPVOID ARG ) 
 # define THREAD _ CURRENT ( ) GetCurrentThreadId ( ) 
 @ @ - 69 , 7 + 69 , 15 @ @ typedef _ _ int64 int64 _ t ; 
 # include < pthread . h > 
 # define SLEEP ( MS ) usleep ( MS * 1000 ) 
 # define THREAD _ T pthread _ t 
 - # define THREAD _ CREATE ( TP , FN , DATA ) pthread _ create ( TP , NULL , FN , DATA ) 
 + # define THREAD _ CREATE ( TP , FN , DATA , STACKSIZE ) { \ 
 + pthread _ attr _ t attr ; \ 
 + pthread _ attr _ init ( & attr ) ; \ 
 + if ( STACKSIZE > 0 ) { \ 
 + pthread _ attr _ setstacksize ( & attr , STACKSIZE ) ; \ 
 + } \ 
 + pthread _ create ( TP , & attr , FN , DATA ) ; \ 
 + pthread _ attr _ destroy ( & attr ) ; \ 
 + } 
 # define THREAD _ EXIT ( ) pthread _ exit ( NULL ) 
 # define THREAD _ FUNC ( FN , ARG ) void * FN ( void * ARG ) 
 # define THREAD _ RETURN return NULL 
 @ @ - 676 , 7 + 684 , 7 @ @ static THREAD _ FUNC ( thread _ function , arg ) { 
 } 
 
 EXPORT void 
 - callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms , const char * name ) { 
 + callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms , const char * name , int stacksize ) { 
 THREAD _ T thread ; 
 thread _ data * data = ( thread _ data * ) malloc ( sizeof ( thread _ data ) ) ; 
 
 @ @ - 684 , 7 + 692 , 7 @ @ callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms , const char * name ) { 
 data - > sleep _ time = ms ; 
 data - > func = func ; 
 snprintf ( data - > name , sizeof ( data - > name ) , " % s " , name ) ; 
 - THREAD _ CREATE ( & thread , & thread _ function , data ) ; 
 + THREAD _ CREATE ( & thread , & thread _ function , data , stacksize ) ; 
 } 
 
 EXPORT int 
 diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java 
 index 9aa97fe . . 9348d26 100644 
 - - - a / test / com / sun / jna / CallbacksTest . java 
 + + + b / test / com / sun / jna / CallbacksTest . java 
 @ @ - 127 , 7 + 127 , 7 @ @ public class CallbacksTest extends TestCase implements Paths { 
 void callback ( ) ; 
 } 
 void callVoidCallback ( VoidCallback c ) ; 
 - void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name ) ; 
 + void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name , int stacksize ) ; 
 interface VoidCallbackCustom extends Callback { 
 void customMethodName ( ) ; 
 } 
 @ @ - 1215 , 7 + 1215 , 7 @ @ public class CallbacksTest extends TestCase implements Paths { 
 if ( cti ! = null ) { 
 Native . setCallbackThreadInitializer ( cb , cti ) ; 
 } 
 - lib . callVoidCallbackThreaded ( cb , repeat , sleepms , getName ( ) ) ; 
 + lib . callVoidCallbackThreaded ( cb , repeat , sleepms , getName ( ) , 0 ) ; 
 
 long start = System . currentTimeMillis ( ) ; 
 while ( called [ 0 ] < returnAfter ) { 
 @ @ - 1304 , 6 + 1304 , 25 @ @ public class CallbacksTest extends TestCase implements Paths { 
 waitFor ( t [ 0 ] ) ; 
 } 
 
 + public void testSmallStackCallback ( ) throws Exception { 
 + / / This test runs the callback in a thread , that is allocated a very 
 + / / small size . It was observed on linux amd64 , that a library allocated 
 + / / a stack size of 64kB , this prevented the JVM to attach to that 
 + / / thread . The JNIEnv pointer was not checked and this lead to a 
 + / / hard crash of the JVM . 
 + TestLibrary . VoidCallback cb = new TestLibrary . VoidCallback ( ) { 
 + @ Override 
 + public void callback ( ) { 
 + System . out . println ( " Callback called " ) ; 
 + } 
 + } ; 
 + 
 + lib . callVoidCallbackThreaded ( cb , 1 , 0 , " Test Callback " , 64 * 1024 ) ; 
 + 
 + / / Give the JVM enough time to run the call back 
 + Thread . sleep ( 1 * 1000 ) ; 
 + } 
 + 
 / / Detach preference is indicated by the initializer . Thread is attached 
 / / as daemon to avoid VM having to wait for it . 
 public void testCallbackThreadPersistence ( ) throws Exception { 
 diff - - git a / test / com / sun / jna / DirectCallbacksTest . java b / test / com / sun / jna / DirectCallbacksTest . java 
 index d15e338 . . ec2d277 100644 
 - - - a / test / com / sun / jna / DirectCallbacksTest . java 
 + + + b / test / com / sun / jna / DirectCallbacksTest . java 
 @ @ - 73 , 7 + 73 , 7 @ @ public class DirectCallbacksTest extends CallbacksTest { 
 @ Override 
 public native void callVoidCallback ( VoidCallback c ) ; 
 @ Override 
 - public native void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name ) ; 
 + public native void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name , int stacksize ) ; 
 
 @ Override 
 public native int callInt32Callback ( CustomCallback cb , int arg1 , int arg2 ) ;

NEAREST DIFF:
diff - - git a / native / Makefile b / native / Makefile 
 index 070dcb6 . . 480979f 100644 
 - - - a / native / Makefile 
 + + + b / native / Makefile 
 @ @ - 284 , 7 + 284 , 7 @ @ endif 
 # Unfortunately , we have to use different libffi include files depending on 
 # the target , so we can ' t do a simple universal build on darwin . Do 
 # separate builds , then merge the results . 
 - $ ( BUILD ) / % . o : % . c dispatch . h thread . h protect . h $ ( FFI _ LIB ) 
 + $ ( BUILD ) / % . o : % . c dispatch . h protect . h $ ( FFI _ LIB ) 
 	 @ mkdir - p $ ( BUILD ) 
 ifneq ( $ ( SDKROOT ) , ) 
 	 $ ( CC ) - arch $ ( ARCH ) $ ( CFLAGS ) - c $ < - o $ @ . $ ( ARCH ) 
 diff - - git a / native / callback . c b / native / callback . c 
 index b3e6fd0 . . 1e971b1 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 25 , 7 + 25 , 6 @ @ 
 # include < sys / param . h > 
 # endif 
 # include " dispatch . h " 
 - # include " thread . h " 
 
 # ifdef _ _ cplusplus 
 extern " C " { 
 @ @ - 389 , 10 + 388 , 19 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar 
 } 
 } 
 
 - # ifdef THREAD _ EXIT _ CLEANUP 
 - static void 
 - detach _ thread ( void * data ) { 
 - THREAD _ EXIT _ CLEANUP ( data ) ; 
 + # ifndef _ WIN32 
 + # include < pthread . h > 
 + 
 + static pthread _ key _ t key ; 
 + static pthread _ once _ t key _ once = PTHREAD _ ONCE _ INIT ; 
 + 
 + static void detach _ thread ( void * data ) { 
 + JavaVM * jvm = ( JavaVM * ) data ; 
 + ( * jvm ) - > DetachCurrentThread ( jvm ) ; 
 + } 
 + 
 + static void make _ key ( ) { 
 + pthread _ key _ create ( & key , detach _ thread ) ; 
 } 
 # endif 
 
 @ @ - 460 , 8 + 468 , 11 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 ( * jvm ) - > DetachCurrentThread ( jvm ) ; 
 } 
 else if ( ! was _ attached ) { 
 - # ifdef ON _ THREAD _ EXIT 
 - ON _ THREAD _ EXIT ( detach _ thread , jvm ) ; 
 + # ifndef _ WIN32 
 + pthread _ once ( & key _ once , make _ key ) ; 
 + if ( pthread _ getspecific ( key ) = = NULL ) { 
 + pthread _ setspecific ( key , jvm ) ; 
 + } 
 # endif 
 } 
 } 
 diff - - git a / native / thread . h b / native / thread . h 
 deleted file mode 100644 
 index 2ab1b18 . . 0000000 
 - - - a / native / thread . h 
 + + + / dev / null 
 @ @ - 1 , 51 + 0 , 0 @ @ 
 - / * Copyright ( c ) 20012 Timothy Wall , All Rights Reserved 
 - * 
 - * This library is free software ; you can redistribute it and / or 
 - * modify it under the terms of the GNU Lesser General Public 
 - * License as published by the Free Software Foundation ; either 
 - * version 2 . 1 of the License , or ( at your option ) any later version . 
 - * < p / > 
 - * This library is distributed in the hope that it will be useful , 
 - * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 - * / 
 - # ifndef THREAD _ H 
 - # define THREAD _ H 
 - 
 - # ifndef _ WIN32 
 - 
 - # include < pthread . h > 
 - 
 - # ifdef _ _ APPLE _ _ 
 - struct _ thread _ cleanup _ data { 
 - struct _ _ darwin _ pthread _ handler _ rec * _ _ handler ; 
 - JavaVM * _ _ jvm ; 
 - } ; 
 - # define THREAD _ EXIT _ CLEANUP ( DATA ) do { \ 
 - struct _ thread _ cleanup _ data * _ _ data = ( struct _ thread _ cleanup _ data * ) DATA ; \ 
 - pthread _ t _ _ self = pthread _ self ( ) ; \ 
 - fprintf ( stderr , " detach thread % p \ n " , _ _ self ) ; \ 
 - _ _ self - > _ _ cleanup _ stack = _ _ data - > _ _ handler - > _ _ next ; \ 
 - ( * ( _ _ data - > _ _ jvm ) ) - > DetachCurrentThread ( _ _ data - > _ _ jvm ) ; \ 
 - / * free ( _ _ data - > _ _ handler ) ; * / \ 
 - free ( _ _ data ) ; \ 
 - fprintf ( stderr , " detach thread % p done \ n " , _ _ self ) ; \ 
 - } while ( 0 ) 
 - # define ON _ THREAD _ EXIT ( PROC , JVM ) do { \ 
 - struct _ thread _ cleanup _ data * _ _ data = ( struct _ thread _ cleanup _ data * ) malloc ( sizeof ( struct _ thread _ cleanup _ data ) ) ; \ 
 - struct _ _ darwin _ pthread _ handler _ rec * _ _ handler = \ 
 - ( struct _ _ darwin _ pthread _ handler _ rec * ) malloc ( sizeof ( struct _ _ darwin _ pthread _ handler _ rec ) ) ; \ 
 - pthread _ t _ _ self = pthread _ self ( ) ; \ 
 - _ _ handler - > _ _ routine = PROC ; \ 
 - _ _ handler - > _ _ arg = _ _ data ; \ 
 - _ _ handler - > _ _ next = _ _ self - > _ _ cleanup _ stack ; \ 
 - _ _ self - > _ _ cleanup _ stack = _ _ handler ; \ 
 - _ _ data - > _ _ handler = _ _ handler ; \ 
 - _ _ data - > _ _ jvm = JVM ; \ 
 - } while ( 0 ) 
 - # endif / * _ _ APPLE _ _ * / 
 - 
 - # endif / * ! _ WIN32 * / 
 - 
 - # endif / * THREAD _ H * /
