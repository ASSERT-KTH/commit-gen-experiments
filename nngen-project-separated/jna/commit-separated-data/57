BLEU SCORE: 0.010569482404431722

TEST MSG: Add PDH counter lookup and enumeration functions
GENERATED MSG: Add platform . win32 . Kernel32 . DeleteFile and com . sun . jna . platform . win32 . deleteFile .

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 0df3208 . . c03c1be 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 19 , 6 + 19 , 7 @ @ Features <nl> * [ # 954 ] ( https : / / github . com / java - native - access / jna / pull / 954 ) : Add ` c . s . j . Structure . FieldOrder ` annotation to define the field order of a structures without implementing ` Structure # getFieldOrder ( ) ` - [ @ idosu ] ( https : / / github . com / idosu ) . <nl> * [ # 959 ] ( https : / / github . com / java - native - access / jna / pull / 959 ) : Added ` GetProcessTimes ` and ` GetProcessIoCounters ` to ` com . sun . jna . platform . win32 . Kernel32 ` - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> * [ # 952 ] ( https : / / github . com / java - native - access / jna / issues / 952 ) : Added ` CreateMutex ` , ` OpenMutex ` and ` ReleaseMutex ` to ` com . sun . jna . platform . win32 . Kernel32 ` - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> + * [ # 973 ] ( https : / / github . com / java - native - access / jna / issues / 973 ) : Added ` PdhLookupPerfNameByIndex ` , ` PdhLookupPerfIndexByName ` , and ` PdhEnumObjectItems ` to ` c . s . j . platform . win32 . Pdh ` and a ` c . s . j . platform . win32 . PdhUtil ` class to access them - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java b / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java <nl> index d6bafb0 . . 88a2b7d 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ package com . sun . jna . platform . win32 ; <nl> import java . util . List ; <nl> <nl> import com . sun . jna . Native ; <nl> + import com . sun . jna . Pointer ; <nl> import com . sun . jna . Structure ; <nl> import com . sun . jna . Structure . FieldOrder ; <nl> import com . sun . jna . platform . win32 . BaseTSD . DWORD _ PTR ; <nl> @ @ - 277 , 4 + 278 , 126 @ @ public interface Pdh extends StdCallLibrary { <nl> * @ see < A HREF = " https : / / msdn . microsoft . com / en - us / library / windows / desktop / aa372677 ( v = vs . 85 ) . aspx " > PdhSetQueryTimeRange < / A > <nl> * / <nl> int PdhSetQueryTimeRange ( HANDLE hQuery , PDH _ TIME _ INFO pInfo ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Returns the specified object ' s counter and instance names that exist on <nl> + 	 * the specified computer or in the specified log file . <nl> + 	 * <nl> + 	 * @ param szDataSource <nl> + 	 * String that specifies the name of the log file used to <nl> + 	 * enumerate the counter and instance names . If NULL , the <nl> + 	 * function uses the computer specified in the szMachineName <nl> + 	 * parameter to enumerate the names . <nl> + 	 * @ param szMachineName <nl> + 	 * String that specifies the name of the computer that contains <nl> + 	 * the counter and instance names that you want to enumerate . <nl> + 	 * Include the leading slashes in the computer name , for example , <nl> + 	 * \ \ computername . If the szDataSource parameter is NULL , you can <nl> + 	 * set szMachineName to NULL to specify the local computer . <nl> + 	 * @ param szObjectName <nl> + 	 * String that specifies the name of the object whose counter and <nl> + 	 * instance names you want to enumerate . <nl> + 	 * @ param mszCounterList <nl> + 	 * Caller - allocated buffer that receives a list of <nl> + 	 * null - terminated counter names provided by the specified <nl> + 	 * object . The list contains unique counter names . The list is <nl> + 	 * terminated by two NULL characters . Set to NULL if the <nl> + 	 * pcchCounterListLengthparameter is zero . <nl> + 	 * @ param pcchCounterListLength <nl> + 	 * Size of the mszCounterList buffer , in TCHARs . If zero on input <nl> + 	 * and the object exists , the function returns PDH _ MORE _ DATA and <nl> + 	 * sets this parameter to the required buffer size . If the buffer <nl> + 	 * is larger than the required size , the function sets this <nl> + 	 * parameter to the actual size of the buffer that was used . If <nl> + 	 * the specified size on input is greater than zero but less than <nl> + 	 * the required size , you should not rely on the returned size to <nl> + 	 * reallocate the buffer . <nl> + 	 * @ param mszInstanceList <nl> + 	 * Caller - allocated buffer that receives a list of <nl> + 	 * null - terminated instance names provided by the specified <nl> + 	 * object . The list contains unique instance names . The list is <nl> + 	 * terminated by two NULL characters . Set to NULL if <nl> + 	 * pcchInstanceListLength is zero . <nl> + 	 * @ param pcchInstanceListLength <nl> + 	 * Size of the mszInstanceList buffer , in TCHARs . If zero on <nl> + 	 * input and the object exists , the function returns <nl> + 	 * PDH _ MORE _ DATA and sets this parameter to the required buffer <nl> + 	 * size . If the buffer is larger than the required size , the <nl> + 	 * function sets this parameter to the actual size of the buffer <nl> + 	 * that was used . If the specified size on input is greater than <nl> + 	 * zero but less than the required size , you should not rely on <nl> + 	 * the returned size to reallocate the buffer . If the specified <nl> + 	 * object does not support variable instances , then the returned <nl> + 	 * value will be zero . If the specified object does support <nl> + 	 * variable instances , but does not currently have any instances , <nl> + 	 * then the value returned is 2 , which is the size of an empty <nl> + 	 * MULTI _ SZ list string . <nl> + 	 * @ param dwDetailLevel <nl> + 	 * Detail level of the performance items to return . All items <nl> + 	 * that are of the specified detail level or less will be <nl> + 	 * returned . <nl> + 	 * @ param dwFlags <nl> + 	 * This parameter must be zero . <nl> + 	 * @ return If the function succeeds , it returns ERROR _ SUCCESS . If the <nl> + 	 * function fails , the return value is a system error code or a PDH <nl> + 	 * error code . <nl> + 	 * @ see < A HREF = <nl> + 	 * " https : / / msdn . microsoft . com / en - us / library / windows / desktop / aa372677 ( v = vs . 85 ) . aspx " > PdhEnumObjectItems < / A > <nl> + 	 * / <nl> + 	 int PdhEnumObjectItems ( String szDataSource , String szMachineName , String szObjectName , Pointer mszCounterList , <nl> + 	 	 	 DWORDByReference pcchCounterListLength , Pointer mszInstanceList , DWORDByReference pcchInstanceListLength , <nl> + 	 	 	 int dwDetailLevel , int dwFlags ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Returns the counter index corresponding to the specified counter name . <nl> + 	 * <nl> + 	 * @ param szMachineName <nl> + 	 * Null - terminated string that specifies the name of the computer <nl> + 	 * where the specified counter is located . The computer name can <nl> + 	 * be specified by the DNS name or the IP address . If NULL , the <nl> + 	 * function uses the local computer . <nl> + 	 * @ param szNameBuffer <nl> + 	 * Null - terminated string that contains the counter name . <nl> + 	 * @ param pdwIndex <nl> + 	 * Index of the counter . <nl> + 	 * @ return If the function succeeds , it returns ERROR _ SUCCESS . If the <nl> + 	 * function fails , the return value is a system error code or a PDH <nl> + 	 * error code . <nl> + 	 * @ see < A HREF = <nl> + 	 * " https : / / msdn . microsoft . com / en - us / library / windows / desktop / aa372647 ( v = vs . 85 ) . aspx " > PdhLookupPerfIndexByName < / A > <nl> + 	 * / <nl> + 	 int PdhLookupPerfIndexByName ( String szMachineName , String szNameBuffer , DWORDByReference pdwIndex ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Returns the performance object name or counter name corresponding to the <nl> + 	 * specified index . <nl> + 	 * <nl> + 	 * @ param szMachineName <nl> + 	 * Null - terminated string that specifies the name of the computer <nl> + 	 * where the specified performance object or counter is located . <nl> + 	 * The computer name can be specified by the DNS name or the IP <nl> + 	 * address . If NULL , the function uses the local computer . <nl> + 	 * @ param dwNameIndex <nl> + 	 * Index of the performance object or counter . <nl> + 	 * @ param szNameBuffer <nl> + 	 * Caller - allocated buffer that receives the null - terminated name <nl> + 	 * of the performance object or counter . Set to NULL if <nl> + 	 * pcchNameBufferSize is zero . <nl> + 	 * @ param pcchNameBufferSize <nl> + 	 * Size of the szNameBuffer buffer , in TCHARs . If zero on input , <nl> + 	 * the function returns PDH _ MORE _ DATA and sets this parameter to <nl> + 	 * the required buffer size . If the buffer is larger than the <nl> + 	 * required size , the function sets this parameter to the actual <nl> + 	 * size of the buffer that was used . If the specified size on <nl> + 	 * input is greater than zero but less than the required size , <nl> + 	 * you should not rely on the returned size to reallocate the <nl> + 	 * buffer . <nl> + 	 * @ return If the function succeeds , it returns ERROR _ SUCCESS . If the <nl> + 	 * function fails , the return value is a system error code or a PDH <nl> + 	 * error code . <nl> + 	 * @ see < A HREF = <nl> + 	 * " https : / / msdn . microsoft . com / en - us / library / windows / desktop / aa372648 ( v = vs . 85 ) . aspx " > PdhLookupPerfNameByIndex < / A > <nl> + 	 * / <nl> + 	 int PdhLookupPerfNameByIndex ( String szMachineName , int dwNameIndex , Pointer szNameBuffer , <nl> + 	 	 	 DWORDByReference pcchNameBufferSize ) ; <nl> } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java b / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java <nl> new file mode 100644 <nl> index 0000000 . . 7b8788d <nl> - - - / dev / null <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java <nl> @ @ - 0 , 0 + 1 , 200 @ @ <nl> + / * Copyright ( c ) 2018 Daniel Widdis , All Rights Reserved <nl> + * <nl> + * The contents of this file is dual - licensed under 2 <nl> + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and <nl> + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . <nl> + * <nl> + * You can freely decide which license you want to apply to <nl> + * the project . <nl> + * <nl> + * You may obtain a copy of the LGPL License at : <nl> + * <nl> + * http : / / www . gnu . org / licenses / licenses . html <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " LGPL2 . 1 " . <nl> + * <nl> + * You may obtain a copy of the Apache License at : <nl> + * <nl> + * http : / / www . apache . org / licenses / <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " AL2 . 0 " . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> + <nl> + import com . sun . jna . Memory ; <nl> + import com . sun . jna . Native ; <nl> + import com . sun . jna . platform . win32 . WinDef . DWORD ; <nl> + import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; <nl> + <nl> + / * * <nl> + * Pdh utility API . <nl> + * <nl> + * @ author widdis [ at ] gmail [ dot ] com <nl> + * / <nl> + public abstract class PdhUtil { <nl> + <nl> + / * * <nl> + * Utility method to call Pdh ' s PdhLookupPerfNameByIndex that allocates the <nl> + * required memory for the szNameBuffer parameter based on the type mapping <nl> + * used , calls to PdhLookupPerfNameByIndex , and returns the received string . <nl> + * <nl> + * @ param szMachineName <nl> + * Null - terminated string that specifies the name of the computer <nl> + * where the specified performance object or counter is located . <nl> + * The computer name can be specified by the DNS name or the IP <nl> + * address . If NULL , the function uses the local computer . <nl> + * @ param dwNameIndex <nl> + * Index of the performance object or counter . <nl> + * @ return Returns the name of the performance object or counter . <nl> + * / <nl> + public static String PdhLookupPerfNameByIndex ( String szMachineName , int dwNameIndex ) { <nl> + int charToBytes = Boolean . getBoolean ( " w32 . ascii " ) ? 1 : Native . WCHAR _ SIZE ; <nl> + <nl> + / / Call once to get required buffer size <nl> + DWORDByReference pcchNameBufferSize = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> + Pdh . INSTANCE . PdhLookupPerfNameByIndex ( null , dwNameIndex , null , pcchNameBufferSize ) ; <nl> + <nl> + / / Allocate buffer and call again <nl> + Memory mem = new Memory ( pcchNameBufferSize . getValue ( ) . intValue ( ) * charToBytes ) ; <nl> + Pdh . INSTANCE . PdhLookupPerfNameByIndex ( null , dwNameIndex , mem , pcchNameBufferSize ) ; <nl> + <nl> + / / Convert buffer to Java String <nl> + if ( charToBytes = = 1 ) { <nl> + return mem . getString ( 0 ) ; <nl> + } else { <nl> + return mem . getWideString ( 0 ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Utility method to call Pdh ' s PdhEnumObjectItems that allocates the <nl> + * required memory for the mszCounterList parameter based on the type <nl> + * mapping used , calls to PdhEnumObjectItems , and returns the received lists <nl> + * of strings . <nl> + * <nl> + * @ param szDataSource <nl> + * String that specifies the name of the log file used to <nl> + * enumerate the counter and instance names . If NULL , the <nl> + * function uses the computer specified in the szMachineName <nl> + * parameter to enumerate the names . <nl> + * @ param szMachineName <nl> + * String that specifies the name of the computer that contains <nl> + * the counter and instance names that you want to enumerate . <nl> + * Include the leading slashes in the computer name , for example , <nl> + * \ \ computername . If the szDataSource parameter is NULL , you can <nl> + * set szMachineName to NULL to specify the local computer . <nl> + * @ param szObjectName <nl> + * String that specifies the name of the object whose counter and <nl> + * instance names you want to enumerate . <nl> + * @ param dwDetailLevel <nl> + * Detail level of the performance items to return . All items <nl> + * that are of the specified detail level or less will be <nl> + * returned . <nl> + * @ return Returns a List of Strings of the counters for the object . <nl> + * / <nl> + public static List < String > PdhEnumObjectItemCounters ( String szDataSource , String szMachineName , String szObjectName , <nl> + int dwDetailLevel ) { <nl> + int charToBytes = Boolean . getBoolean ( " w32 . ascii " ) ? 1 : Native . WCHAR _ SIZE ; <nl> + <nl> + / / Call once to get string lengths <nl> + DWORDByReference pcchCounterListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> + DWORDByReference pcchInstanceListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> + Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , <nl> + pcchInstanceListLength , dwDetailLevel , 0 ) ; <nl> + <nl> + / / Allocate memory and call again to populate strings <nl> + Memory mszCounterList = new Memory ( pcchCounterListLength . getValue ( ) . intValue ( ) * charToBytes ) ; <nl> + Memory mszInstanceList = new Memory ( pcchInstanceListLength . getValue ( ) . intValue ( ) * charToBytes ) ; <nl> + Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , mszCounterList , <nl> + pcchCounterListLength , mszInstanceList , pcchInstanceListLength , dwDetailLevel , 0 ) ; <nl> + <nl> + / / Fetch counters <nl> + List < String > counters = new ArrayList < String > ( ) ; <nl> + int offset = 0 ; <nl> + while ( offset < mszCounterList . size ( ) ) { <nl> + String s = null ; <nl> + if ( charToBytes = = 1 ) { <nl> + s = mszCounterList . getString ( offset ) ; <nl> + } else { <nl> + s = mszCounterList . getWideString ( offset ) ; <nl> + } <nl> + / / list ends with double null <nl> + if ( s . isEmpty ( ) ) { <nl> + break ; <nl> + } <nl> + counters . add ( s ) ; <nl> + / / Increment for string + null terminator <nl> + offset + = ( s . length ( ) + 1 ) * charToBytes ; <nl> + } <nl> + <nl> + return counters ; <nl> + } <nl> + <nl> + / * * <nl> + * Utility method to call Pdh ' s PdhEnumObjectItems that allocates the <nl> + * required memory for the mszInstanceList parameters based on the type <nl> + * mapping used , calls to PdhEnumObjectItems , and returns the received lists <nl> + * of strings . <nl> + * <nl> + * @ param szDataSource <nl> + * String that specifies the name of the log file used to <nl> + * enumerate the counter and instance names . If NULL , the <nl> + * function uses the computer specified in the szMachineName <nl> + * parameter to enumerate the names . <nl> + * @ param szMachineName <nl> + * String that specifies the name of the computer that contains <nl> + * the counter and instance names that you want to enumerate . <nl> + * Include the leading slashes in the computer name , for example , <nl> + * \ \ computername . If the szDataSource parameter is NULL , you can <nl> + * set szMachineName to NULL to specify the local computer . <nl> + * @ param szObjectName <nl> + * String that specifies the name of the object whose counter and <nl> + * instance names you want to enumerate . <nl> + * @ param dwDetailLevel <nl> + * Detail level of the performance items to return . All items <nl> + * that are of the specified detail level or less will be <nl> + * returned . <nl> + * @ return Returns a Lists of Strings of the instances of the object . <nl> + * / <nl> + public static List < String > PdhEnumObjectItemInstances ( String szDataSource , String szMachineName , <nl> + String szObjectName , int dwDetailLevel ) { <nl> + int charToBytes = Boolean . getBoolean ( " w32 . ascii " ) ? 1 : Native . WCHAR _ SIZE ; <nl> + <nl> + / / Call once to get string lengths <nl> + DWORDByReference pcchCounterListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> + DWORDByReference pcchInstanceListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> + Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , <nl> + pcchInstanceListLength , dwDetailLevel , 0 ) ; <nl> + <nl> + / / Allocate memory and call again to populate strings <nl> + Memory mszCounterList = new Memory ( pcchCounterListLength . getValue ( ) . intValue ( ) * charToBytes ) ; <nl> + Memory mszInstanceList = new Memory ( pcchInstanceListLength . getValue ( ) . intValue ( ) * charToBytes ) ; <nl> + Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , mszCounterList , <nl> + pcchCounterListLength , mszInstanceList , pcchInstanceListLength , dwDetailLevel , 0 ) ; <nl> + <nl> + List < String > instances = new ArrayList < String > ( ) ; <nl> + int offset = 0 ; <nl> + while ( offset < mszInstanceList . size ( ) ) { <nl> + String s = null ; <nl> + if ( charToBytes = = 1 ) { <nl> + s = mszInstanceList . getString ( offset ) ; <nl> + } else { <nl> + s = mszInstanceList . getWideString ( offset ) ; <nl> + } <nl> + / / list ends with double null <nl> + if ( s . isEmpty ( ) ) { <nl> + break ; <nl> + } <nl> + instances . add ( s ) ; <nl> + / / Increment for string + null terminator <nl> + offset + = ( s . length ( ) + 1 ) * charToBytes ; <nl> + } <nl> + <nl> + return instances ; <nl> + } <nl> + } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java <nl> index 9a073f5 . . 04013eb 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java <nl> @ @ - 16 , 6 + 16 , 7 @ @ import java . io . PrintStream ; <nl> import java . util . Collection ; <nl> import java . util . HashMap ; <nl> import java . util . LinkedList ; <nl> + import java . util . List ; <nl> import java . util . Map ; <nl> <nl> import org . junit . Test ; <nl> @ @ - 155 , 4 + 156 , 44 @ @ public class PdhTest extends AbstractWin32TestSupport { <nl> <nl> return Native . toString ( szFullPathBuffer ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testLookupPerfIndex ( ) { <nl> + int processorIndex = 238 ; <nl> + String processorStr = " Processor " ; / / English locale <nl> + <nl> + / / Test index - to - name <nl> + String testStr = PdhUtil . PdhLookupPerfNameByIndex ( null , processorIndex ) ; <nl> + if ( AbstractWin32TestSupport . isEnglishLocale ) { <nl> + assertEquals ( processorStr , testStr ) ; <nl> + } else { <nl> + assertTrue ( testStr . length ( ) > 0 ) ; <nl> + } <nl> + <nl> + / / Test name - to - index <nl> + DWORDByReference pdwIndex = new DWORDByReference ( ) ; <nl> + Pdh . INSTANCE . PdhLookupPerfIndexByName ( null , testStr , pdwIndex ) ; <nl> + assertEquals ( processorIndex , pdwIndex . getValue ( ) . intValue ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testEnumObjectItems ( ) { <nl> + if ( AbstractWin32TestSupport . isEnglishLocale ) { <nl> + 	 	 	 String processorStr = " Processor " ; <nl> + String processorTimeStr = " % Processor Time " ; <nl> + <nl> + / / Fetch the counter and instance names <nl> + 	 	 	 List < String > instances = PdhUtil . PdhEnumObjectItemInstances ( null , null , processorStr , 100 ) ; <nl> + <nl> + / / Should have at least one processor and total instance <nl> + 	 	 	 assertTrue ( instances . contains ( " 0 " ) ) ; <nl> + 	 	 	 assertTrue ( instances . contains ( " _ Total " ) ) ; <nl> + <nl> + / / Should have a " % Processor Time " counter <nl> + 	 	 	 List < String > counters = PdhUtil . PdhEnumObjectItemCounters ( null , null , processorStr , 100 ) ; <nl> + 	 	 	 assertTrue ( counters . contains ( processorTimeStr ) ) ; <nl> + } else { <nl> + System . err . println ( " testEnumObjectItems test can only be run with english locale . " ) ; <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c <nl> index 383d49f . . b3450f8 100644 <nl> - - - a / jnalib / native / dispatch . c <nl> + + + b / jnalib / native / dispatch . c <nl> @ @ - 992 , 7 + 992 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1write _ _ J _ 3SII <nl> * Signature : ( JB ) J <nl> * / <nl> JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1indexOf _ _ JB <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> { <nl> jbyte * peer = ( jbyte * ) L2A ( addr ) ; <nl> volatile jlong i = 0 ; <nl> @ @ - 1103 , 7 + 1103 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1read _ _ J _ 3SII <nl> * Signature : ( J ) B <nl> * / <nl> JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jbyte res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1116 , 7 + 1116 , 7 @ @ JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte <nl> * Signature : ( J ) C <nl> * / <nl> JNIEXPORT jchar JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getChar <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> wchar _ t res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1153 , 7 + 1153 , 7 @ @ JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDirectByteBuffer <nl> * Signature : ( J ) D <nl> * / <nl> JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jdouble res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1166 , 7 + 1166 , 7 @ @ JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble <nl> * Signature : ( J ) F <nl> * / <nl> JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jfloat res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1179 , 7 + 1179 , 7 @ @ JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat <nl> * Signature : ( J ) I <nl> * / <nl> JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jint res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1192 , 7 + 1192 , 7 @ @ JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt <nl> * Signature : ( J ) J <nl> * / <nl> JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jlong res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1205 , 7 + 1205 , 7 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong <nl> * Signature : ( J ) S <nl> * / <nl> JNIEXPORT jshort JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getShort <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jshort res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1229 , 7 + 1229 , 7 @ @ JNIEXPORT jstring JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getString <nl> * Signature : ( JJB ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) <nl> { <nl> MEMSET ( L2A ( addr ) , ( int ) value , ( size _ t ) count ) ; <nl> } <nl> @ @ - 1240 , 7 + 1240 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory <nl> * Signature : ( JB ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1251 , 7 + 1251 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte <nl> * Signature : ( JC ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jchar value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jchar value ) <nl> { <nl> wchar _ t ch = value ; <nl> MEMCPY ( L2A ( addr ) , & ch , sizeof ( ch ) ) ; <nl> @ @ - 1263 , 7 + 1263 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar <nl> * Signature : ( JJ ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> { <nl> void * ptr = L2A ( value ) ; <nl> MEMCPY ( L2A ( addr ) , & ptr , sizeof ( void * ) ) ; <nl> @ @ - 1275 , 7 + 1275 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer <nl> * Signature : ( JD ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jdouble value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jdouble value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1286 , 7 + 1286 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble <nl> * Signature : ( JF ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jfloat value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jfloat value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1297 , 7 + 1297 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat <nl> * Signature : ( JI ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jint value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jint value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1308 , 7 + 1308 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt <nl> * Signature : ( JJ ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1319 , 7 + 1319 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong <nl> * Signature : ( JS ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setShort <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jshort value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jshort value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> }

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 0df3208 . . c03c1be 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 19 , 6 + 19 , 7 @ @ Features 
 * [ # 954 ] ( https : / / github . com / java - native - access / jna / pull / 954 ) : Add ` c . s . j . Structure . FieldOrder ` annotation to define the field order of a structures without implementing ` Structure # getFieldOrder ( ) ` - [ @ idosu ] ( https : / / github . com / idosu ) . 
 * [ # 959 ] ( https : / / github . com / java - native - access / jna / pull / 959 ) : Added ` GetProcessTimes ` and ` GetProcessIoCounters ` to ` com . sun . jna . platform . win32 . Kernel32 ` - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 * [ # 952 ] ( https : / / github . com / java - native - access / jna / issues / 952 ) : Added ` CreateMutex ` , ` OpenMutex ` and ` ReleaseMutex ` to ` com . sun . jna . platform . win32 . Kernel32 ` - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 + * [ # 973 ] ( https : / / github . com / java - native - access / jna / issues / 973 ) : Added ` PdhLookupPerfNameByIndex ` , ` PdhLookupPerfIndexByName ` , and ` PdhEnumObjectItems ` to ` c . s . j . platform . win32 . Pdh ` and a ` c . s . j . platform . win32 . PdhUtil ` class to access them - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java b / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java 
 index d6bafb0 . . 88a2b7d 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java 
 @ @ - 26 , 6 + 26 , 7 @ @ package com . sun . jna . platform . win32 ; 
 import java . util . List ; 
 
 import com . sun . jna . Native ; 
 + import com . sun . jna . Pointer ; 
 import com . sun . jna . Structure ; 
 import com . sun . jna . Structure . FieldOrder ; 
 import com . sun . jna . platform . win32 . BaseTSD . DWORD _ PTR ; 
 @ @ - 277 , 4 + 278 , 126 @ @ public interface Pdh extends StdCallLibrary { 
 * @ see < A HREF = " https : / / msdn . microsoft . com / en - us / library / windows / desktop / aa372677 ( v = vs . 85 ) . aspx " > PdhSetQueryTimeRange < / A > 
 * / 
 int PdhSetQueryTimeRange ( HANDLE hQuery , PDH _ TIME _ INFO pInfo ) ; 
 + 
 + 	 / * * 
 + 	 * Returns the specified object ' s counter and instance names that exist on 
 + 	 * the specified computer or in the specified log file . 
 + 	 * 
 + 	 * @ param szDataSource 
 + 	 * String that specifies the name of the log file used to 
 + 	 * enumerate the counter and instance names . If NULL , the 
 + 	 * function uses the computer specified in the szMachineName 
 + 	 * parameter to enumerate the names . 
 + 	 * @ param szMachineName 
 + 	 * String that specifies the name of the computer that contains 
 + 	 * the counter and instance names that you want to enumerate . 
 + 	 * Include the leading slashes in the computer name , for example , 
 + 	 * \ \ computername . If the szDataSource parameter is NULL , you can 
 + 	 * set szMachineName to NULL to specify the local computer . 
 + 	 * @ param szObjectName 
 + 	 * String that specifies the name of the object whose counter and 
 + 	 * instance names you want to enumerate . 
 + 	 * @ param mszCounterList 
 + 	 * Caller - allocated buffer that receives a list of 
 + 	 * null - terminated counter names provided by the specified 
 + 	 * object . The list contains unique counter names . The list is 
 + 	 * terminated by two NULL characters . Set to NULL if the 
 + 	 * pcchCounterListLengthparameter is zero . 
 + 	 * @ param pcchCounterListLength 
 + 	 * Size of the mszCounterList buffer , in TCHARs . If zero on input 
 + 	 * and the object exists , the function returns PDH _ MORE _ DATA and 
 + 	 * sets this parameter to the required buffer size . If the buffer 
 + 	 * is larger than the required size , the function sets this 
 + 	 * parameter to the actual size of the buffer that was used . If 
 + 	 * the specified size on input is greater than zero but less than 
 + 	 * the required size , you should not rely on the returned size to 
 + 	 * reallocate the buffer . 
 + 	 * @ param mszInstanceList 
 + 	 * Caller - allocated buffer that receives a list of 
 + 	 * null - terminated instance names provided by the specified 
 + 	 * object . The list contains unique instance names . The list is 
 + 	 * terminated by two NULL characters . Set to NULL if 
 + 	 * pcchInstanceListLength is zero . 
 + 	 * @ param pcchInstanceListLength 
 + 	 * Size of the mszInstanceList buffer , in TCHARs . If zero on 
 + 	 * input and the object exists , the function returns 
 + 	 * PDH _ MORE _ DATA and sets this parameter to the required buffer 
 + 	 * size . If the buffer is larger than the required size , the 
 + 	 * function sets this parameter to the actual size of the buffer 
 + 	 * that was used . If the specified size on input is greater than 
 + 	 * zero but less than the required size , you should not rely on 
 + 	 * the returned size to reallocate the buffer . If the specified 
 + 	 * object does not support variable instances , then the returned 
 + 	 * value will be zero . If the specified object does support 
 + 	 * variable instances , but does not currently have any instances , 
 + 	 * then the value returned is 2 , which is the size of an empty 
 + 	 * MULTI _ SZ list string . 
 + 	 * @ param dwDetailLevel 
 + 	 * Detail level of the performance items to return . All items 
 + 	 * that are of the specified detail level or less will be 
 + 	 * returned . 
 + 	 * @ param dwFlags 
 + 	 * This parameter must be zero . 
 + 	 * @ return If the function succeeds , it returns ERROR _ SUCCESS . If the 
 + 	 * function fails , the return value is a system error code or a PDH 
 + 	 * error code . 
 + 	 * @ see < A HREF = 
 + 	 * " https : / / msdn . microsoft . com / en - us / library / windows / desktop / aa372677 ( v = vs . 85 ) . aspx " > PdhEnumObjectItems < / A > 
 + 	 * / 
 + 	 int PdhEnumObjectItems ( String szDataSource , String szMachineName , String szObjectName , Pointer mszCounterList , 
 + 	 	 	 DWORDByReference pcchCounterListLength , Pointer mszInstanceList , DWORDByReference pcchInstanceListLength , 
 + 	 	 	 int dwDetailLevel , int dwFlags ) ; 
 + 
 + 	 / * * 
 + 	 * Returns the counter index corresponding to the specified counter name . 
 + 	 * 
 + 	 * @ param szMachineName 
 + 	 * Null - terminated string that specifies the name of the computer 
 + 	 * where the specified counter is located . The computer name can 
 + 	 * be specified by the DNS name or the IP address . If NULL , the 
 + 	 * function uses the local computer . 
 + 	 * @ param szNameBuffer 
 + 	 * Null - terminated string that contains the counter name . 
 + 	 * @ param pdwIndex 
 + 	 * Index of the counter . 
 + 	 * @ return If the function succeeds , it returns ERROR _ SUCCESS . If the 
 + 	 * function fails , the return value is a system error code or a PDH 
 + 	 * error code . 
 + 	 * @ see < A HREF = 
 + 	 * " https : / / msdn . microsoft . com / en - us / library / windows / desktop / aa372647 ( v = vs . 85 ) . aspx " > PdhLookupPerfIndexByName < / A > 
 + 	 * / 
 + 	 int PdhLookupPerfIndexByName ( String szMachineName , String szNameBuffer , DWORDByReference pdwIndex ) ; 
 + 
 + 	 / * * 
 + 	 * Returns the performance object name or counter name corresponding to the 
 + 	 * specified index . 
 + 	 * 
 + 	 * @ param szMachineName 
 + 	 * Null - terminated string that specifies the name of the computer 
 + 	 * where the specified performance object or counter is located . 
 + 	 * The computer name can be specified by the DNS name or the IP 
 + 	 * address . If NULL , the function uses the local computer . 
 + 	 * @ param dwNameIndex 
 + 	 * Index of the performance object or counter . 
 + 	 * @ param szNameBuffer 
 + 	 * Caller - allocated buffer that receives the null - terminated name 
 + 	 * of the performance object or counter . Set to NULL if 
 + 	 * pcchNameBufferSize is zero . 
 + 	 * @ param pcchNameBufferSize 
 + 	 * Size of the szNameBuffer buffer , in TCHARs . If zero on input , 
 + 	 * the function returns PDH _ MORE _ DATA and sets this parameter to 
 + 	 * the required buffer size . If the buffer is larger than the 
 + 	 * required size , the function sets this parameter to the actual 
 + 	 * size of the buffer that was used . If the specified size on 
 + 	 * input is greater than zero but less than the required size , 
 + 	 * you should not rely on the returned size to reallocate the 
 + 	 * buffer . 
 + 	 * @ return If the function succeeds , it returns ERROR _ SUCCESS . If the 
 + 	 * function fails , the return value is a system error code or a PDH 
 + 	 * error code . 
 + 	 * @ see < A HREF = 
 + 	 * " https : / / msdn . microsoft . com / en - us / library / windows / desktop / aa372648 ( v = vs . 85 ) . aspx " > PdhLookupPerfNameByIndex < / A > 
 + 	 * / 
 + 	 int PdhLookupPerfNameByIndex ( String szMachineName , int dwNameIndex , Pointer szNameBuffer , 
 + 	 	 	 DWORDByReference pcchNameBufferSize ) ; 
 } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java b / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java 
 new file mode 100644 
 index 0000000 . . 7b8788d 
 - - - / dev / null 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java 
 @ @ - 0 , 0 + 1 , 200 @ @ 
 + / * Copyright ( c ) 2018 Daniel Widdis , All Rights Reserved 
 + * 
 + * The contents of this file is dual - licensed under 2 
 + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and 
 + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . 
 + * 
 + * You can freely decide which license you want to apply to 
 + * the project . 
 + * 
 + * You may obtain a copy of the LGPL License at : 
 + * 
 + * http : / / www . gnu . org / licenses / licenses . html 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " LGPL2 . 1 " . 
 + * 
 + * You may obtain a copy of the Apache License at : 
 + * 
 + * http : / / www . apache . org / licenses / 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " AL2 . 0 " . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . List ; 
 + 
 + import com . sun . jna . Memory ; 
 + import com . sun . jna . Native ; 
 + import com . sun . jna . platform . win32 . WinDef . DWORD ; 
 + import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; 
 + 
 + / * * 
 + * Pdh utility API . 
 + * 
 + * @ author widdis [ at ] gmail [ dot ] com 
 + * / 
 + public abstract class PdhUtil { 
 + 
 + / * * 
 + * Utility method to call Pdh ' s PdhLookupPerfNameByIndex that allocates the 
 + * required memory for the szNameBuffer parameter based on the type mapping 
 + * used , calls to PdhLookupPerfNameByIndex , and returns the received string . 
 + * 
 + * @ param szMachineName 
 + * Null - terminated string that specifies the name of the computer 
 + * where the specified performance object or counter is located . 
 + * The computer name can be specified by the DNS name or the IP 
 + * address . If NULL , the function uses the local computer . 
 + * @ param dwNameIndex 
 + * Index of the performance object or counter . 
 + * @ return Returns the name of the performance object or counter . 
 + * / 
 + public static String PdhLookupPerfNameByIndex ( String szMachineName , int dwNameIndex ) { 
 + int charToBytes = Boolean . getBoolean ( " w32 . ascii " ) ? 1 : Native . WCHAR _ SIZE ; 
 + 
 + / / Call once to get required buffer size 
 + DWORDByReference pcchNameBufferSize = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 + Pdh . INSTANCE . PdhLookupPerfNameByIndex ( null , dwNameIndex , null , pcchNameBufferSize ) ; 
 + 
 + / / Allocate buffer and call again 
 + Memory mem = new Memory ( pcchNameBufferSize . getValue ( ) . intValue ( ) * charToBytes ) ; 
 + Pdh . INSTANCE . PdhLookupPerfNameByIndex ( null , dwNameIndex , mem , pcchNameBufferSize ) ; 
 + 
 + / / Convert buffer to Java String 
 + if ( charToBytes = = 1 ) { 
 + return mem . getString ( 0 ) ; 
 + } else { 
 + return mem . getWideString ( 0 ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Utility method to call Pdh ' s PdhEnumObjectItems that allocates the 
 + * required memory for the mszCounterList parameter based on the type 
 + * mapping used , calls to PdhEnumObjectItems , and returns the received lists 
 + * of strings . 
 + * 
 + * @ param szDataSource 
 + * String that specifies the name of the log file used to 
 + * enumerate the counter and instance names . If NULL , the 
 + * function uses the computer specified in the szMachineName 
 + * parameter to enumerate the names . 
 + * @ param szMachineName 
 + * String that specifies the name of the computer that contains 
 + * the counter and instance names that you want to enumerate . 
 + * Include the leading slashes in the computer name , for example , 
 + * \ \ computername . If the szDataSource parameter is NULL , you can 
 + * set szMachineName to NULL to specify the local computer . 
 + * @ param szObjectName 
 + * String that specifies the name of the object whose counter and 
 + * instance names you want to enumerate . 
 + * @ param dwDetailLevel 
 + * Detail level of the performance items to return . All items 
 + * that are of the specified detail level or less will be 
 + * returned . 
 + * @ return Returns a List of Strings of the counters for the object . 
 + * / 
 + public static List < String > PdhEnumObjectItemCounters ( String szDataSource , String szMachineName , String szObjectName , 
 + int dwDetailLevel ) { 
 + int charToBytes = Boolean . getBoolean ( " w32 . ascii " ) ? 1 : Native . WCHAR _ SIZE ; 
 + 
 + / / Call once to get string lengths 
 + DWORDByReference pcchCounterListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 + DWORDByReference pcchInstanceListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 + Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , 
 + pcchInstanceListLength , dwDetailLevel , 0 ) ; 
 + 
 + / / Allocate memory and call again to populate strings 
 + Memory mszCounterList = new Memory ( pcchCounterListLength . getValue ( ) . intValue ( ) * charToBytes ) ; 
 + Memory mszInstanceList = new Memory ( pcchInstanceListLength . getValue ( ) . intValue ( ) * charToBytes ) ; 
 + Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , mszCounterList , 
 + pcchCounterListLength , mszInstanceList , pcchInstanceListLength , dwDetailLevel , 0 ) ; 
 + 
 + / / Fetch counters 
 + List < String > counters = new ArrayList < String > ( ) ; 
 + int offset = 0 ; 
 + while ( offset < mszCounterList . size ( ) ) { 
 + String s = null ; 
 + if ( charToBytes = = 1 ) { 
 + s = mszCounterList . getString ( offset ) ; 
 + } else { 
 + s = mszCounterList . getWideString ( offset ) ; 
 + } 
 + / / list ends with double null 
 + if ( s . isEmpty ( ) ) { 
 + break ; 
 + } 
 + counters . add ( s ) ; 
 + / / Increment for string + null terminator 
 + offset + = ( s . length ( ) + 1 ) * charToBytes ; 
 + } 
 + 
 + return counters ; 
 + } 
 + 
 + / * * 
 + * Utility method to call Pdh ' s PdhEnumObjectItems that allocates the 
 + * required memory for the mszInstanceList parameters based on the type 
 + * mapping used , calls to PdhEnumObjectItems , and returns the received lists 
 + * of strings . 
 + * 
 + * @ param szDataSource 
 + * String that specifies the name of the log file used to 
 + * enumerate the counter and instance names . If NULL , the 
 + * function uses the computer specified in the szMachineName 
 + * parameter to enumerate the names . 
 + * @ param szMachineName 
 + * String that specifies the name of the computer that contains 
 + * the counter and instance names that you want to enumerate . 
 + * Include the leading slashes in the computer name , for example , 
 + * \ \ computername . If the szDataSource parameter is NULL , you can 
 + * set szMachineName to NULL to specify the local computer . 
 + * @ param szObjectName 
 + * String that specifies the name of the object whose counter and 
 + * instance names you want to enumerate . 
 + * @ param dwDetailLevel 
 + * Detail level of the performance items to return . All items 
 + * that are of the specified detail level or less will be 
 + * returned . 
 + * @ return Returns a Lists of Strings of the instances of the object . 
 + * / 
 + public static List < String > PdhEnumObjectItemInstances ( String szDataSource , String szMachineName , 
 + String szObjectName , int dwDetailLevel ) { 
 + int charToBytes = Boolean . getBoolean ( " w32 . ascii " ) ? 1 : Native . WCHAR _ SIZE ; 
 + 
 + / / Call once to get string lengths 
 + DWORDByReference pcchCounterListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 + DWORDByReference pcchInstanceListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 + Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , 
 + pcchInstanceListLength , dwDetailLevel , 0 ) ; 
 + 
 + / / Allocate memory and call again to populate strings 
 + Memory mszCounterList = new Memory ( pcchCounterListLength . getValue ( ) . intValue ( ) * charToBytes ) ; 
 + Memory mszInstanceList = new Memory ( pcchInstanceListLength . getValue ( ) . intValue ( ) * charToBytes ) ; 
 + Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , mszCounterList , 
 + pcchCounterListLength , mszInstanceList , pcchInstanceListLength , dwDetailLevel , 0 ) ; 
 + 
 + List < String > instances = new ArrayList < String > ( ) ; 
 + int offset = 0 ; 
 + while ( offset < mszInstanceList . size ( ) ) { 
 + String s = null ; 
 + if ( charToBytes = = 1 ) { 
 + s = mszInstanceList . getString ( offset ) ; 
 + } else { 
 + s = mszInstanceList . getWideString ( offset ) ; 
 + } 
 + / / list ends with double null 
 + if ( s . isEmpty ( ) ) { 
 + break ; 
 + } 
 + instances . add ( s ) ; 
 + / / Increment for string + null terminator 
 + offset + = ( s . length ( ) + 1 ) * charToBytes ; 
 + } 
 + 
 + return instances ; 
 + } 
 + } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java 
 index 9a073f5 . . 04013eb 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java 
 @ @ - 16 , 6 + 16 , 7 @ @ import java . io . PrintStream ; 
 import java . util . Collection ; 
 import java . util . HashMap ; 
 import java . util . LinkedList ; 
 + import java . util . List ; 
 import java . util . Map ; 
 
 import org . junit . Test ; 
 @ @ - 155 , 4 + 156 , 44 @ @ public class PdhTest extends AbstractWin32TestSupport { 
 
 return Native . toString ( szFullPathBuffer ) ; 
 } 
 + 
 + @ Test 
 + public void testLookupPerfIndex ( ) { 
 + int processorIndex = 238 ; 
 + String processorStr = " Processor " ; / / English locale 
 + 
 + / / Test index - to - name 
 + String testStr = PdhUtil . PdhLookupPerfNameByIndex ( null , processorIndex ) ; 
 + if ( AbstractWin32TestSupport . isEnglishLocale ) { 
 + assertEquals ( processorStr , testStr ) ; 
 + } else { 
 + assertTrue ( testStr . length ( ) > 0 ) ; 
 + } 
 + 
 + / / Test name - to - index 
 + DWORDByReference pdwIndex = new DWORDByReference ( ) ; 
 + Pdh . INSTANCE . PdhLookupPerfIndexByName ( null , testStr , pdwIndex ) ; 
 + assertEquals ( processorIndex , pdwIndex . getValue ( ) . intValue ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testEnumObjectItems ( ) { 
 + if ( AbstractWin32TestSupport . isEnglishLocale ) { 
 + 	 	 	 String processorStr = " Processor " ; 
 + String processorTimeStr = " % Processor Time " ; 
 + 
 + / / Fetch the counter and instance names 
 + 	 	 	 List < String > instances = PdhUtil . PdhEnumObjectItemInstances ( null , null , processorStr , 100 ) ; 
 + 
 + / / Should have at least one processor and total instance 
 + 	 	 	 assertTrue ( instances . contains ( " 0 " ) ) ; 
 + 	 	 	 assertTrue ( instances . contains ( " _ Total " ) ) ; 
 + 
 + / / Should have a " % Processor Time " counter 
 + 	 	 	 List < String > counters = PdhUtil . PdhEnumObjectItemCounters ( null , null , processorStr , 100 ) ; 
 + 	 	 	 assertTrue ( counters . contains ( processorTimeStr ) ) ; 
 + } else { 
 + System . err . println ( " testEnumObjectItems test can only be run with english locale . " ) ; 
 + } 
 + } 
 }

NEAREST DIFF:
diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c 
 index 383d49f . . b3450f8 100644 
 - - - a / jnalib / native / dispatch . c 
 + + + b / jnalib / native / dispatch . c 
 @ @ - 992 , 7 + 992 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1write _ _ J _ 3SII 
 * Signature : ( JB ) J 
 * / 
 JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1indexOf _ _ JB 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 { 
 jbyte * peer = ( jbyte * ) L2A ( addr ) ; 
 volatile jlong i = 0 ; 
 @ @ - 1103 , 7 + 1103 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1read _ _ J _ 3SII 
 * Signature : ( J ) B 
 * / 
 JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jbyte res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1116 , 7 + 1116 , 7 @ @ JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte 
 * Signature : ( J ) C 
 * / 
 JNIEXPORT jchar JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getChar 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 wchar _ t res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1153 , 7 + 1153 , 7 @ @ JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDirectByteBuffer 
 * Signature : ( J ) D 
 * / 
 JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jdouble res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1166 , 7 + 1166 , 7 @ @ JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble 
 * Signature : ( J ) F 
 * / 
 JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jfloat res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1179 , 7 + 1179 , 7 @ @ JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat 
 * Signature : ( J ) I 
 * / 
 JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jint res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1192 , 7 + 1192 , 7 @ @ JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt 
 * Signature : ( J ) J 
 * / 
 JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jlong res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1205 , 7 + 1205 , 7 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong 
 * Signature : ( J ) S 
 * / 
 JNIEXPORT jshort JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getShort 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jshort res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1229 , 7 + 1229 , 7 @ @ JNIEXPORT jstring JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getString 
 * Signature : ( JJB ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) 
 { 
 MEMSET ( L2A ( addr ) , ( int ) value , ( size _ t ) count ) ; 
 } 
 @ @ - 1240 , 7 + 1240 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory 
 * Signature : ( JB ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1251 , 7 + 1251 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte 
 * Signature : ( JC ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jchar value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jchar value ) 
 { 
 wchar _ t ch = value ; 
 MEMCPY ( L2A ( addr ) , & ch , sizeof ( ch ) ) ; 
 @ @ - 1263 , 7 + 1263 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar 
 * Signature : ( JJ ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 { 
 void * ptr = L2A ( value ) ; 
 MEMCPY ( L2A ( addr ) , & ptr , sizeof ( void * ) ) ; 
 @ @ - 1275 , 7 + 1275 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer 
 * Signature : ( JD ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jdouble value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jdouble value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1286 , 7 + 1286 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble 
 * Signature : ( JF ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jfloat value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jfloat value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1297 , 7 + 1297 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat 
 * Signature : ( JI ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jint value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jint value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1308 , 7 + 1308 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt 
 * Signature : ( JJ ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1319 , 7 + 1319 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong 
 * Signature : ( JS ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setShort 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jshort value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jshort value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 }
