BLEU SCORE: 0.2259005009024612

TEST MSG: consolidate compiler pragmas
GENERATED MSG: Fix solaris build

TEST DIFF (one line): diff - - git a / native / dispatch . c b / native / dispatch . c <nl> index 8b83c12 . . 8205786 100644 <nl> - - - a / native / dispatch . c <nl> + + + b / native / dispatch . c <nl> @ @ - 17 , 9 + 17 , 6 @ @ <nl> * / <nl> <nl> # if defined ( _ WIN32 ) <nl> - # ifdef _ MSC _ VER <nl> - # pragma warning ( disable : 4201 ) / * nameless struct / union ( jni _ md . h ) * / <nl> - # endif <nl> # ifndef UNICODE <nl> # define UNICODE <nl> # endif <nl> diff - - git a / native / dispatch . h b / native / dispatch . h <nl> index cd65853 . . aea2d8d 100644 <nl> - - - a / native / dispatch . h <nl> + + + b / native / dispatch . h <nl> @ @ - 27 , 6 + 27 , 7 @ @ <nl> # pragma warning ( disable : 4055 ) / * cast data pointer to function pointer * / <nl> # pragma warning ( disable : 4204 ) / * structure initializer * / <nl> # pragma warning ( disable : 4710 ) / * swprintf not inlined * / <nl> + # pragma warning ( disable : 4201 ) / * nameless struct / union ( jni _ md . h ) * / <nl> # else <nl> # include < malloc . h > <nl> # endif / * _ MSC _ VER * /
NEAREST DIFF (one line): diff - - git a / jnalib / TODO b / jnalib / TODO <nl> index 15b5fe7 . . 6aed9ef 100644 <nl> - - - a / jnalib / TODO <nl> + + + b / jnalib / TODO <nl> @ @ - 21 , 6 + 21 , 7 @ @ <nl> <nl> # TODO <nl> <nl> + * review / use direct Buffer in more places if it makes sense <nl> * support annotations of parameters and return values w / o breaking <nl> 1 . 4 compatibility , e . g . <nl> <nl> @ @ - 30 , 17 + 31 , 22 @ @ <nl> <nl> my _ function ( 0 ) versus my _ function ( new off _ t ( 0 ) ) <nl> <nl> + this only really applies to NativeLong types that want to use a primitive <nl> + value instead of creating an object instance . <nl> + <nl> * standard types for various platforms : posix / types . h , w32 ( DWORD , HANDLE ) <nl> - * review / use direct Buffer in more places <nl> - * Callback / function pointer as return value ( e . g . signal ( ) ) <nl> * StringBuffer / StringBuilder as mutable char * / wchar _ t * argument <nl> - <nl> - * make Pointer free - able ( system allocates memory , client frees it ) ; actually , <nl> - this should probably be automatic so the user doesn ' t have to think about it . <nl> - Maybe a custom type representing " function - allocated - pointer " or <nl> - " pointer - requiring - free " ( which is just Memory ) . For now , leave it up to <nl> - the user to manage the pointer , since they have to define the free method <nl> - anyway . <nl> + NOTE : byte [ ] / char [ ] is probably better ; it ' s trivial to convert to String <nl> + * flag string ( / wstring ) - returning methods which need to free their result <nl> + to avoid leaking memory whan auto - creating strings from the result <nl> + ( since normally we don ' t take explicit ownership of any returned pointers ) <nl> + this is a special case for returned strings only , since other returned <nl> + pointers are available to the user for later " freeing " <nl> + Use a map on library creation , an iface for the library , or annotation <nl> + NOTE : how many methods actually do this ? strdup . . . <nl> + Maybe make function return " Memory " , which can then be converted to a <nl> + Structure or some other type . Then memory will free itself when no longer <nl> + referenced . <nl> * provide library load / unload hooks ( Runnables in options ? ) . Examples : <nl> o GetLastError in kernel32 ( note : would need to initialize kernel32 from any <nl> other w32 api dll as well ) <nl> @ @ - 56 , 6 + 62 , 12 @ @ <nl> if nonzero ? <nl> o otherwise , need an ExceptionOnZero , ExceptionOnNonZero runtime , from which <nl> derive GetLastError / ErrnoExceptionOnZero / NZ <nl> + * make Pointer free - able ( system allocates memory , client frees it ) ; actually , <nl> + this should probably be automatic so the user doesn ' t have to think about it . <nl> + Maybe a custom type representing " function - allocated - pointer " or <nl> + " pointer - requiring - free " ( which is just Memory ) . For now , leave it up to <nl> + the user to manage the pointer , since they have to define the free method <nl> + anyway . use could always put a finalizer on a PointerType - derived type . <nl> * determine X11 display name from current java program ( if any ) ; null is ok <nl> since it uses getenv ( DISPLAY ) , which is what java would do <nl> note : DISPLAY may be available in GraphicsDevice - > getIDstring <nl> @ @ - 66 , 16 + 78 , 6 @ @ <nl> addressOf ( ) ) ? <nl> * how to do struct value argument ( vs struct pointer ) ( uncommon ) ? <nl> * how to do struct value return ( vs struct pointer ) ( uncommon ) ? <nl> - * flag string ( / wstring ) - returning methods which need to free their result <nl> - to avoid leaking memory whan auto - creating strings from the result <nl> - ( since normally we don ' t take explicit ownership of any returned pointers ) <nl> - this is a special case for returned strings only , since other returned <nl> - pointers are available to the user for later " freeing " <nl> - Use a map on library creation , an iface for the library , or annotation <nl> - NOTE : how many methods actually do this ? strdup . . . <nl> - Maybe make function return " Memory " , which can then be converted to a <nl> - Structure or some other type . Then memory will free itself when no longer <nl> - referenced . <nl> * verify get / set methods vs read / write is for performance ( Pointer ) ? <nl> * bitfields et al . for structs <nl> <nl> @ @ - 83 , 6 + 85 , 7 @ @ <nl> <nl>  <nl> # DONE <nl> + * Callback / function pointer as return value ( e . g . signal ( ) ) <nl> * type safety between returned and passed in pointers ( w32 API ) ; advantage of <nl> deriving from Pointer is that type mapping can be made automatic , without an <nl> explicit type mapping defined . <nl> diff - - git a / jnalib / native / testlib . c b / jnalib / native / testlib . c <nl> index 7b6a44e . . 683051b 100644 <nl> - - - a / jnalib / native / testlib . c <nl> + + + b / jnalib / native / testlib . c <nl> @ @ - 267 , 6 + 267 , 17 @ @ returnNullTestStructure ( ) { <nl> return NULL ; <nl> } <nl> <nl> + typedef int32 ( * callback _ t ) ( int32 ) ; <nl> + EXPORT callback _ t <nl> + returnCallback ( ) { <nl> + return returnInt32Argument ; <nl> + } <nl> + <nl> + EXPORT callback _ t <nl> + returnCallbackArgument ( callback _ t arg ) { <nl> + return arg ; <nl> + } <nl> + <nl> EXPORT void <nl> incrementInt8ByReference ( int8 * arg ) { <nl> nonleaf ( ) ; <nl> diff - - git a / jnalib / src / com / sun / jna / CallbackReference . java b / jnalib / src / com / sun / jna / CallbackReference . java <nl> index 94e27fc . . 6a43345 100644 <nl> - - - a / jnalib / src / com / sun / jna / CallbackReference . java <nl> + + + b / jnalib / src / com / sun / jna / CallbackReference . java <nl> @ @ - 13 , 10 + 13 , 14 @ @ <nl> package com . sun . jna ; <nl> <nl> import java . lang . ref . WeakReference ; <nl> + import java . lang . reflect . InvocationHandler ; <nl> import java . lang . reflect . InvocationTargetException ; <nl> import java . lang . reflect . Method ; <nl> + import java . lang . reflect . Proxy ; <nl> + import java . util . Iterator ; <nl> import java . util . Map ; <nl> import java . util . WeakHashMap ; <nl> + import com . sun . jna . Library . Handler ; <nl> <nl> / * * Provides a reference to an association between a native callback closure <nl> * and a Java { @ link Callback } closure . <nl> @ @ - 24 , 33 + 28 , 42 @ @ import java . util . WeakHashMap ; <nl> <nl> class CallbackReference extends WeakReference { <nl> <nl> + private interface NativeFunctionProxy { } <nl> + <nl> static final Map callbackMap = new WeakHashMap ( ) ; <nl> static final Map altCallbackMap = new WeakHashMap ( ) ; <nl> <nl> - / * * Return a CallbackReference associated with the given callback , using <nl> - * the calling convention appropriate to the given callback . <nl> - * / <nl> - public static CallbackReference getInstance ( Callback callback ) { <nl> - int callingConvention = callback instanceof AltCallingConvention <nl> - ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; <nl> - return getInstance ( callback , callingConvention ) ; <nl> - } <nl> - <nl> - / * * Return a CallbackReference associated with the given callback , using <nl> - * the requested calling convention . <nl> + / * * Return a CallbackReference associated with the given function pointer . <nl> + * If the pointer refers to a Java callback trampoline , return the Java <nl> + * callback . Otherwise , return a proxy to the native function pointer . <nl> * / <nl> - public static CallbackReference getInstance ( Callback callback , int callingConvention ) { <nl> - Map map = callingConvention = = Function . ALT _ CONVENTION <nl> - ? altCallbackMap : callbackMap ; <nl> - synchronized ( map ) { <nl> - CallbackReference cbref = ( CallbackReference ) map . get ( callback ) ; <nl> - if ( cbref = = null ) { <nl> - cbref = new CallbackReference ( callback , callingConvention ) ; <nl> - map . put ( callback , cbref ) ; <nl> - <nl> + public static Callback getCallback ( Class type , Pointer p ) { <nl> + if ( p ! = null ) { <nl> + if ( ! type . isInterface ( ) ) <nl> + throw new IllegalArgumentException ( " Callback type must be an interface " ) ; <nl> + Map map = AltCallingConvention . class . isAssignableFrom ( type ) <nl> + ? altCallbackMap : callbackMap ; <nl> + synchronized ( map ) { <nl> + for ( Iterator i = map . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { <nl> + Callback cb = ( Callback ) i . next ( ) ; <nl> + if ( type . isAssignableFrom ( cb . getClass ( ) ) ) { <nl> + CallbackReference cbref = ( CallbackReference ) map . get ( cb ) ; <nl> + Pointer cbp = cbref ! = null <nl> + ? cbref . getTrampoline ( ) : getNativeFunctionPointer ( cb ) ; <nl> + if ( p . equals ( cbp ) ) { <nl> + return cb ; <nl> + } <nl> + } <nl> + } <nl> + int ctype = AltCallingConvention . class . isAssignableFrom ( type ) <nl> + ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; <nl> + NativeFunctionHandler h = new NativeFunctionHandler ( p , ctype ) ; <nl> + Callback cb = ( Callback ) Proxy . newProxyInstance ( type . getClassLoader ( ) , new Class [ ] { type , NativeFunctionProxy . class } , h ) ; <nl> + map . put ( cb , null ) ; <nl> + return cb ; <nl> } <nl> - return cbref ; <nl> } <nl> + return null ; <nl> } <nl> <nl> Pointer cbstruct ; <nl> @ @ - 159 , 6 + 172 , 38 @ @ class CallbackReference extends WeakReference { <nl> return ( Callback ) get ( ) ; <nl> } <nl> <nl> + private static Pointer getNativeFunctionPointer ( Callback cb ) { <nl> + if ( cb instanceof NativeFunctionProxy ) { <nl> + NativeFunctionHandler handler = <nl> + ( NativeFunctionHandler ) Proxy . getInvocationHandler ( cb ) ; <nl> + return handler . getPointer ( ) ; <nl> + } <nl> + return null ; <nl> + } <nl> + <nl> + / * * Return a { @ link Pointer } to the native function address for the <nl> + * given callback . <nl> + * / <nl> + public static Pointer getFunctionPointer ( Callback cb ) { <nl> + Pointer fp = null ; <nl> + if ( cb = = null ) return null ; <nl> + if ( ( fp = getNativeFunctionPointer ( cb ) ) ! = null ) { <nl> + return fp ; <nl> + } <nl> + int callingConvention = cb instanceof AltCallingConvention <nl> + ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; <nl> + Map map = callingConvention = = Function . ALT _ CONVENTION <nl> + ? altCallbackMap : callbackMap ; <nl> + synchronized ( map ) { <nl> + CallbackReference cbref = ( CallbackReference ) map . get ( cb ) ; <nl> + if ( cbref = = null ) { <nl> + cbref = new CallbackReference ( cb , callingConvention ) ; <nl> + map . put ( cb , cbref ) ; <nl> + } <nl> + return cbref . getTrampoline ( ) ; <nl> + } <nl> + } <nl> + <nl> private class DefaultCallbackProxy implements CallbackProxy { <nl> private Method callbackMethod ; <nl> private ToNativeConverter toNative ; <nl> @ @ - 287 , 6 + 332 , 9 @ @ class CallbackReference extends WeakReference { <nl> / / FIXME : need to prevent GC , but how and for how long ? <nl> return new NativeString ( value . toString ( ) , true ) . getPointer ( ) ; <nl> } <nl> + else if ( Callback . class . isAssignableFrom ( cls ) ) { <nl> + return getFunctionPointer ( ( Callback ) value ) ; <nl> + } <nl> else if ( ! isAllowableNativeType ( cls ) ) { <nl> throw new IllegalArgumentException ( " Return type " + cls + " will be ignored " ) ; <nl> } <nl> @ @ - 300 , 11 + 348 , 46 @ @ class CallbackReference extends WeakReference { <nl> } <nl> } <nl> <nl> + / * * Provide invocation handling for an auto - generated Java interface proxy <nl> + * for a native function pointer . <nl> + * / <nl> + private static class NativeFunctionHandler implements InvocationHandler { <nl> + private Function function ; <nl> + <nl> + public NativeFunctionHandler ( Pointer address , int callingConvention ) { <nl> + this . function = new Function ( address , callingConvention ) ; <nl> + } <nl> + <nl> + / * * Chain invocation to the native function . * / <nl> + public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { <nl> + if ( Library . Handler . OBJECT _ TOSTRING . equals ( method ) ) { <nl> + return " Proxy interface to " + function ; <nl> + } <nl> + else if ( Library . Handler . OBJECT _ HASHCODE . equals ( method ) ) { <nl> + return new Integer ( hashCode ( ) ) ; <nl> + } <nl> + else if ( Library . Handler . OBJECT _ EQUALS . equals ( method ) ) { <nl> + Object o = args [ 0 ] ; <nl> + if ( o ! = null & & Proxy . isProxyClass ( o . getClass ( ) ) ) { <nl> + Boolean . valueOf ( Proxy . getInvocationHandler ( o ) = = this ) ; <nl> + } <nl> + return Boolean . FALSE ; <nl> + } <nl> + if ( Function . isVarArgs ( method ) ) { <nl> + args = Function . concatenateVarArgs ( args ) ; <nl> + } <nl> + return function . invoke ( method . getReturnType ( ) , args ) ; <nl> + } <nl> + <nl> + public Pointer getPointer ( ) { <nl> + return function ; <nl> + } <nl> + } <nl> / * * Returns whether the given class is supported in native code . <nl> * Other types ( String , WString , Structure , arrays , NativeMapped , <nl> * etc ) are supported in the Java library . <nl> * / <nl> - static boolean isAllowableNativeType ( Class cls ) { <nl> + private static boolean isAllowableNativeType ( Class cls ) { <nl> return cls = = boolean . class | | cls = = Boolean . class <nl> | | cls = = byte . class | | cls = = Byte . class <nl> | | cls = = short . class | | cls = = Short . class <nl> @ @ - 316 , 12 + 399 , 13 @ @ class CallbackReference extends WeakReference { <nl> | | Pointer . class . isAssignableFrom ( cls ) ; <nl> } <nl> <nl> - / * * Create a callback function pointer . * / <nl> + / * * Create a native trampoline to delegate execution to the Java callback . <nl> + * / <nl> private static native Pointer createNativeCallback ( CallbackProxy callback , <nl> Method method , <nl> Class [ ] parameterTypes , <nl> Class returnType , <nl> int callingConvention ) ; <nl> - / * * Free the given callback function pointer . * / <nl> + / * * Free the given callback trampoline . * / <nl> private static native void freeNativeCallback ( long ptr ) ; <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / Function . java b / jnalib / src / com / sun / jna / Function . java <nl> index 53ce3f8 . . 8ae28cb 100644 <nl> - - - a / jnalib / src / com / sun / jna / Function . java <nl> + + + b / jnalib / src / com / sun / jna / Function . java <nl> @ @ - 121 , 7 + 121 , 7 @ @ public class Function extends Pointer { <nl> * / <nl> Function ( Pointer functionAddress , int callingConvention ) { <nl> checkCallingConvention ( callingConvention ) ; <nl> - this . functionName = functionAddress . toString ( ) ; <nl> + this . functionName = " < unknown > " ; <nl> this . callingConvention = callingConvention ; <nl> this . peer = functionAddress . peer ; <nl> } <nl> @ @ - 293 , 6 + 293 , 12 @ @ public class Function extends Pointer { <nl> } <nl> } <nl> } <nl> + else if ( Callback . class . isAssignableFrom ( returnType ) ) { <nl> + result = invokePointer ( callingConvention , args ) ; <nl> + if ( result ! = null ) { <nl> + result = CallbackReference . getCallback ( returnType , ( Pointer ) result ) ; <nl> + } <nl> + } <nl> else { <nl> throw new IllegalArgumentException ( " Unsupported return type " <nl> + returnType ) ; <nl> @ @ - 338 , 9 + 344 , 7 @ @ public class Function extends Pointer { <nl> } <nl> / / Convert Callback to Pointer <nl> else if ( arg instanceof Callback ) { <nl> - CallbackReference cbref = CallbackReference . getInstance ( ( Callback ) arg ) ; <nl> - / / Use pointer to trampoline ( see dispatch . h ) <nl> - return cbref . getTrampoline ( ) ; <nl> + return CallbackReference . getFunctionPointer ( ( Callback ) arg ) ; <nl> } <nl> / / String arguments are converted to native pointers here rather <nl> / / than in native code so that the values will be valid until <nl> @ @ - 526 , 9 + 530 , 11 @ @ public class Function extends Pointer { <nl> <nl> / * * Provide a human - readable representation of this object . * / <nl> public String toString ( ) { <nl> - String libName = library ! = null ? library . getName ( ) : " < undefined > " ; <nl> - return " native function " + functionName + " ( " + libName <nl> - + " ) @ 0x " + Long . toHexString ( peer ) ; <nl> + if ( library ! = null ) { <nl> + return " native function " + functionName + " ( " + library . getName ( ) <nl> + + " ) @ 0x " + Long . toHexString ( peer ) ; <nl> + } <nl> + return " native function @ 0x " + Long . toHexString ( peer ) ; <nl> } <nl> <nl> / * * Handle native array of char * type by managing allocation / disposal of <nl> @ @ - 599 , 7 + 605 , 18 @ @ public class Function extends Pointer { <nl> public void invokeVoid ( Object [ ] args ) { <nl> invoke ( Void . class , args ) ; <nl> } <nl> - <nl> + <nl> + / * * Two function pointers are equal if they share the same peer address <nl> + * and calling convention . <nl> + * / <nl> + public boolean equals ( Object o ) { <nl> + if ( o instanceof Function ) { <nl> + Function other = ( Function ) o ; <nl> + return other . callingConvention = = this . callingConvention <nl> + & & other . peer = = this . peer ; <nl> + } <nl> + return false ; <nl> + } <nl> <nl> / * * Concatenate varargs with normal args to obtain a simple argument <nl> * array . <nl> diff - - git a / jnalib / src / com / sun / jna / Structure . java b / jnalib / src / com / sun / jna / Structure . java <nl> index 95595c7 . . 5f66472 100644 <nl> - - - a / jnalib / src / com / sun / jna / Structure . java <nl> + + + b / jnalib / src / com / sun / jna / Structure . java <nl> @ @ - 12 , 10 + 12 , 7 @ @ package com . sun . jna ; <nl> <nl> import java . lang . reflect . Array ; <nl> import java . lang . reflect . Field ; <nl> - import java . lang . reflect . InvocationHandler ; <nl> - import java . lang . reflect . Method ; <nl> import java . lang . reflect . Modifier ; <nl> - import java . lang . reflect . Proxy ; <nl> import java . util . Arrays ; <nl> import java . util . HashMap ; <nl> import java . util . Iterator ; <nl> @ @ - 51 , 6 + 48 , 7 @ @ public abstract class Structure { <nl> <nl> static { <nl> / / IBM and JRockit store fields in reverse order ; check for it <nl> + / / GCJ returns an array created from a set , and needs fixing <nl> Field [ ] fields = MemberOrder . class . getFields ( ) ; <nl> REVERSE _ FIELDS = " last " . equals ( fields [ 0 ] . getName ( ) ) ; <nl> if ( ! " middle " . equals ( fields [ 1 ] . getName ( ) ) ) { <nl> @ @ - 289 , 9 + 287 , 9 @ @ public abstract class Structure { <nl> } <nl> else try { <nl> Callback cb = ( Callback ) structField . field . get ( this ) ; <nl> - Pointer oldfp = getFunctionPointer ( cb ) ; <nl> + Pointer oldfp = CallbackReference . getFunctionPointer ( cb ) ; <nl> if ( ! fp . equals ( oldfp ) ) { <nl> - cb = createNativeCallback ( nativeType , fp ) ; <nl> + cb = CallbackReference . getCallback ( nativeType , fp ) ; <nl> } <nl> result = cb ; <nl> } <nl> @ @ - 506 , 7 + 504 , 7 @ @ public abstract class Structure { <nl> s . write ( ) ; <nl> } <nl> else if ( Callback . class . isAssignableFrom ( nativeType ) ) { <nl> - memory . setPointer ( offset , getFunctionPointer ( ( Callback ) value ) ) ; <nl> + memory . setPointer ( offset , CallbackReference . getFunctionPointer ( ( Callback ) value ) ) ; <nl> } <nl> else { <nl> throw new IllegalArgumentException ( " Field \ " " + structField . name <nl> @ @ - 553 , 6 + 551 , 12 @ @ public abstract class Structure { <nl> structField . field = field ; <nl> structField . name = field . getName ( ) ; <nl> structField . type = type ; <nl> + <nl> + if ( Callback . class . isAssignableFrom ( type ) & & ! type . isInterface ( ) ) { <nl> + throw new IllegalArgumentException ( " Structure Callback field ' " <nl> + + field . getName ( ) <nl> + + " ' must be an interface " ) ; <nl> + } <nl> <nl> int fieldAlignment = 1 ; <nl> try { <nl> @ @ - 806 , 28 + 810 , 6 @ @ public abstract class Structure { <nl> return getPointer ( ) . hashCode ( ) ; <nl> } <nl> <nl> - private Pointer getFunctionPointer ( Callback cb ) { <nl> - if ( cb = = null ) return null ; <nl> - if ( Proxy . isProxyClass ( cb . getClass ( ) ) ) { <nl> - InvocationHandler handler = Proxy . getInvocationHandler ( cb ) ; <nl> - if ( handler instanceof NativeCallbackHandler ) <nl> - return ( ( NativeCallbackHandler ) handler ) . getPointer ( ) ; <nl> - } <nl> - CallbackReference cbref = CallbackReference . getInstance ( cb ) ; <nl> - return cbref . getTrampoline ( ) ; <nl> - } <nl> - <nl> - / * * Create a Callback proxy around a native function pointer . * / <nl> - private Callback createNativeCallback ( Class type , Pointer address ) { <nl> - if ( ! type . isInterface ( ) ) <nl> - throw new IllegalArgumentException ( " Structure Callback field must be an interface " ) ; <nl> - int ctype = AltCallingConvention . class . isAssignableFrom ( type ) <nl> - ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; <nl> - NativeCallbackHandler h = new NativeCallbackHandler ( address , ctype ) ; <nl> - return ( Callback ) Proxy . newProxyInstance ( getClass ( ) . getClassLoader ( ) , <nl> - new Class [ ] { type } , h ) ; <nl> - } <nl> - <nl> class StructField extends Object { <nl> public String name ; <nl> public Class type ; <nl> @ @ - 848 , 40 + 830 , 4 @ @ public abstract class Structure { <nl> + " = " + value ; <nl> } <nl> } <nl> - <nl> - / * * Enable an auto - generated Java interface proxy for a native function <nl> - * pointer . <nl> - * / <nl> - private class NativeCallbackHandler implements InvocationHandler { <nl> - private Function function ; <nl> - <nl> - public NativeCallbackHandler ( Pointer address , int callingConvention ) { <nl> - this . function = new Function ( address , callingConvention ) ; <nl> - } <nl> - <nl> - / * * Chain invocation to the native function . * / <nl> - public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { <nl> - if ( Library . Handler . OBJECT _ TOSTRING . equals ( method ) ) { <nl> - return " Proxy interface to function pointer " + function ; <nl> - } <nl> - else if ( Library . Handler . OBJECT _ HASHCODE . equals ( method ) ) { <nl> - return new Integer ( hashCode ( ) ) ; <nl> - } <nl> - else if ( Library . Handler . OBJECT _ EQUALS . equals ( method ) ) { <nl> - Object o = args [ 0 ] ; <nl> - if ( o ! = null & & Proxy . isProxyClass ( o . getClass ( ) ) ) { <nl> - Boolean . valueOf ( Proxy . getInvocationHandler ( o ) = = this ) ; <nl> - } <nl> - return Boolean . FALSE ; <nl> - } <nl> - if ( Function . isVarArgs ( method ) ) { <nl> - args = Function . concatenateVarArgs ( args ) ; <nl> - } <nl> - return function . invoke ( method . getReturnType ( ) , args ) ; <nl> - } <nl> - <nl> - public Pointer getPointer ( ) { <nl> - return function ; <nl> - } <nl> - } <nl> } <nl> diff - - git a / jnalib / test / com / sun / jna / ReturnTypesTest . java b / jnalib / test / com / sun / jna / ReturnTypesTest . java <nl> index 47f4ac8 . . 2d6f318 100644 <nl> - - - a / jnalib / test / com / sun / jna / ReturnTypesTest . java <nl> + + + b / jnalib / test / com / sun / jna / ReturnTypesTest . java <nl> @ @ - 53 , 6 + 53 , 11 @ @ public class ReturnTypesTest extends TestCase { <nl> WString returnWStringMagic ( ) ; <nl> TestStructure returnStaticTestStructure ( ) ; <nl> TestStructure returnNullTestStructure ( ) ; <nl> + public interface Int32Callback extends Callback { <nl> + public int callback ( int arg ) ; <nl> + } <nl> + Int32Callback returnCallback ( ) ; <nl> + Int32Callback returnCallbackArgument ( Int32Callback cb ) ; <nl> } <nl> <nl> TestLibrary lib ; <nl> @ @ - 161 , 6 + 166 , 22 @ @ public class ReturnTypesTest extends TestCase { <nl> assertNull ( " Expect null structure return " , s ) ; <nl> } <nl> <nl> + public void testInvokeCallback ( ) { <nl> + TestLibrary . Int32Callback cb = lib . returnCallback ( ) ; <nl> + assertNotNull ( " Callback should not be null " , cb ) ; <nl> + assertEquals ( " Callback should be callable " , 1 , cb . callback ( 1 ) ) ; <nl> + <nl> + TestLibrary . Int32Callback cb2 = new TestLibrary . Int32Callback ( ) { <nl> + public int callback ( int arg ) { <nl> + return 0 ; <nl> + } <nl> + } ; <nl> + assertSame ( " Java callback should be looked up " , <nl> + cb2 , lib . returnCallbackArgument ( cb2 ) ) ; <nl> + assertSame ( " Existing native function wrapper should be reused " , <nl> + cb , lib . returnCallbackArgument ( cb ) ) ; <nl> + } <nl> + <nl> public static void main ( java . lang . String [ ] argList ) { <nl> junit . textui . TestRunner . run ( ReturnTypesTest . class ) ; <nl> }

TEST DIFF:
diff - - git a / native / dispatch . c b / native / dispatch . c 
 index 8b83c12 . . 8205786 100644 
 - - - a / native / dispatch . c 
 + + + b / native / dispatch . c 
 @ @ - 17 , 9 + 17 , 6 @ @ 
 * / 
 
 # if defined ( _ WIN32 ) 
 - # ifdef _ MSC _ VER 
 - # pragma warning ( disable : 4201 ) / * nameless struct / union ( jni _ md . h ) * / 
 - # endif 
 # ifndef UNICODE 
 # define UNICODE 
 # endif 
 diff - - git a / native / dispatch . h b / native / dispatch . h 
 index cd65853 . . aea2d8d 100644 
 - - - a / native / dispatch . h 
 + + + b / native / dispatch . h 
 @ @ - 27 , 6 + 27 , 7 @ @ 
 # pragma warning ( disable : 4055 ) / * cast data pointer to function pointer * / 
 # pragma warning ( disable : 4204 ) / * structure initializer * / 
 # pragma warning ( disable : 4710 ) / * swprintf not inlined * / 
 + # pragma warning ( disable : 4201 ) / * nameless struct / union ( jni _ md . h ) * / 
 # else 
 # include < malloc . h > 
 # endif / * _ MSC _ VER * /

NEAREST DIFF:
diff - - git a / jnalib / TODO b / jnalib / TODO 
 index 15b5fe7 . . 6aed9ef 100644 
 - - - a / jnalib / TODO 
 + + + b / jnalib / TODO 
 @ @ - 21 , 6 + 21 , 7 @ @ 
 
 # TODO 
 
 + * review / use direct Buffer in more places if it makes sense 
 * support annotations of parameters and return values w / o breaking 
 1 . 4 compatibility , e . g . 
 
 @ @ - 30 , 17 + 31 , 22 @ @ 
 
 my _ function ( 0 ) versus my _ function ( new off _ t ( 0 ) ) 
 
 + this only really applies to NativeLong types that want to use a primitive 
 + value instead of creating an object instance . 
 + 
 * standard types for various platforms : posix / types . h , w32 ( DWORD , HANDLE ) 
 - * review / use direct Buffer in more places 
 - * Callback / function pointer as return value ( e . g . signal ( ) ) 
 * StringBuffer / StringBuilder as mutable char * / wchar _ t * argument 
 - 
 - * make Pointer free - able ( system allocates memory , client frees it ) ; actually , 
 - this should probably be automatic so the user doesn ' t have to think about it . 
 - Maybe a custom type representing " function - allocated - pointer " or 
 - " pointer - requiring - free " ( which is just Memory ) . For now , leave it up to 
 - the user to manage the pointer , since they have to define the free method 
 - anyway . 
 + NOTE : byte [ ] / char [ ] is probably better ; it ' s trivial to convert to String 
 + * flag string ( / wstring ) - returning methods which need to free their result 
 + to avoid leaking memory whan auto - creating strings from the result 
 + ( since normally we don ' t take explicit ownership of any returned pointers ) 
 + this is a special case for returned strings only , since other returned 
 + pointers are available to the user for later " freeing " 
 + Use a map on library creation , an iface for the library , or annotation 
 + NOTE : how many methods actually do this ? strdup . . . 
 + Maybe make function return " Memory " , which can then be converted to a 
 + Structure or some other type . Then memory will free itself when no longer 
 + referenced . 
 * provide library load / unload hooks ( Runnables in options ? ) . Examples : 
 o GetLastError in kernel32 ( note : would need to initialize kernel32 from any 
 other w32 api dll as well ) 
 @ @ - 56 , 6 + 62 , 12 @ @ 
 if nonzero ? 
 o otherwise , need an ExceptionOnZero , ExceptionOnNonZero runtime , from which 
 derive GetLastError / ErrnoExceptionOnZero / NZ 
 + * make Pointer free - able ( system allocates memory , client frees it ) ; actually , 
 + this should probably be automatic so the user doesn ' t have to think about it . 
 + Maybe a custom type representing " function - allocated - pointer " or 
 + " pointer - requiring - free " ( which is just Memory ) . For now , leave it up to 
 + the user to manage the pointer , since they have to define the free method 
 + anyway . use could always put a finalizer on a PointerType - derived type . 
 * determine X11 display name from current java program ( if any ) ; null is ok 
 since it uses getenv ( DISPLAY ) , which is what java would do 
 note : DISPLAY may be available in GraphicsDevice - > getIDstring 
 @ @ - 66 , 16 + 78 , 6 @ @ 
 addressOf ( ) ) ? 
 * how to do struct value argument ( vs struct pointer ) ( uncommon ) ? 
 * how to do struct value return ( vs struct pointer ) ( uncommon ) ? 
 - * flag string ( / wstring ) - returning methods which need to free their result 
 - to avoid leaking memory whan auto - creating strings from the result 
 - ( since normally we don ' t take explicit ownership of any returned pointers ) 
 - this is a special case for returned strings only , since other returned 
 - pointers are available to the user for later " freeing " 
 - Use a map on library creation , an iface for the library , or annotation 
 - NOTE : how many methods actually do this ? strdup . . . 
 - Maybe make function return " Memory " , which can then be converted to a 
 - Structure or some other type . Then memory will free itself when no longer 
 - referenced . 
 * verify get / set methods vs read / write is for performance ( Pointer ) ? 
 * bitfields et al . for structs 
 
 @ @ - 83 , 6 + 85 , 7 @ @ 
 
  
 # DONE 
 + * Callback / function pointer as return value ( e . g . signal ( ) ) 
 * type safety between returned and passed in pointers ( w32 API ) ; advantage of 
 deriving from Pointer is that type mapping can be made automatic , without an 
 explicit type mapping defined . 
 diff - - git a / jnalib / native / testlib . c b / jnalib / native / testlib . c 
 index 7b6a44e . . 683051b 100644 
 - - - a / jnalib / native / testlib . c 
 + + + b / jnalib / native / testlib . c 
 @ @ - 267 , 6 + 267 , 17 @ @ returnNullTestStructure ( ) { 
 return NULL ; 
 } 
 
 + typedef int32 ( * callback _ t ) ( int32 ) ; 
 + EXPORT callback _ t 
 + returnCallback ( ) { 
 + return returnInt32Argument ; 
 + } 
 + 
 + EXPORT callback _ t 
 + returnCallbackArgument ( callback _ t arg ) { 
 + return arg ; 
 + } 
 + 
 EXPORT void 
 incrementInt8ByReference ( int8 * arg ) { 
 nonleaf ( ) ; 
 diff - - git a / jnalib / src / com / sun / jna / CallbackReference . java b / jnalib / src / com / sun / jna / CallbackReference . java 
 index 94e27fc . . 6a43345 100644 
 - - - a / jnalib / src / com / sun / jna / CallbackReference . java 
 + + + b / jnalib / src / com / sun / jna / CallbackReference . java 
 @ @ - 13 , 10 + 13 , 14 @ @ 
 package com . sun . jna ; 
 
 import java . lang . ref . WeakReference ; 
 + import java . lang . reflect . InvocationHandler ; 
 import java . lang . reflect . InvocationTargetException ; 
 import java . lang . reflect . Method ; 
 + import java . lang . reflect . Proxy ; 
 + import java . util . Iterator ; 
 import java . util . Map ; 
 import java . util . WeakHashMap ; 
 + import com . sun . jna . Library . Handler ; 
 
 / * * Provides a reference to an association between a native callback closure 
 * and a Java { @ link Callback } closure . 
 @ @ - 24 , 33 + 28 , 42 @ @ import java . util . WeakHashMap ; 
 
 class CallbackReference extends WeakReference { 
 
 + private interface NativeFunctionProxy { } 
 + 
 static final Map callbackMap = new WeakHashMap ( ) ; 
 static final Map altCallbackMap = new WeakHashMap ( ) ; 
 
 - / * * Return a CallbackReference associated with the given callback , using 
 - * the calling convention appropriate to the given callback . 
 - * / 
 - public static CallbackReference getInstance ( Callback callback ) { 
 - int callingConvention = callback instanceof AltCallingConvention 
 - ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; 
 - return getInstance ( callback , callingConvention ) ; 
 - } 
 - 
 - / * * Return a CallbackReference associated with the given callback , using 
 - * the requested calling convention . 
 + / * * Return a CallbackReference associated with the given function pointer . 
 + * If the pointer refers to a Java callback trampoline , return the Java 
 + * callback . Otherwise , return a proxy to the native function pointer . 
 * / 
 - public static CallbackReference getInstance ( Callback callback , int callingConvention ) { 
 - Map map = callingConvention = = Function . ALT _ CONVENTION 
 - ? altCallbackMap : callbackMap ; 
 - synchronized ( map ) { 
 - CallbackReference cbref = ( CallbackReference ) map . get ( callback ) ; 
 - if ( cbref = = null ) { 
 - cbref = new CallbackReference ( callback , callingConvention ) ; 
 - map . put ( callback , cbref ) ; 
 - 
 + public static Callback getCallback ( Class type , Pointer p ) { 
 + if ( p ! = null ) { 
 + if ( ! type . isInterface ( ) ) 
 + throw new IllegalArgumentException ( " Callback type must be an interface " ) ; 
 + Map map = AltCallingConvention . class . isAssignableFrom ( type ) 
 + ? altCallbackMap : callbackMap ; 
 + synchronized ( map ) { 
 + for ( Iterator i = map . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 + Callback cb = ( Callback ) i . next ( ) ; 
 + if ( type . isAssignableFrom ( cb . getClass ( ) ) ) { 
 + CallbackReference cbref = ( CallbackReference ) map . get ( cb ) ; 
 + Pointer cbp = cbref ! = null 
 + ? cbref . getTrampoline ( ) : getNativeFunctionPointer ( cb ) ; 
 + if ( p . equals ( cbp ) ) { 
 + return cb ; 
 + } 
 + } 
 + } 
 + int ctype = AltCallingConvention . class . isAssignableFrom ( type ) 
 + ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; 
 + NativeFunctionHandler h = new NativeFunctionHandler ( p , ctype ) ; 
 + Callback cb = ( Callback ) Proxy . newProxyInstance ( type . getClassLoader ( ) , new Class [ ] { type , NativeFunctionProxy . class } , h ) ; 
 + map . put ( cb , null ) ; 
 + return cb ; 
 } 
 - return cbref ; 
 } 
 + return null ; 
 } 
 
 Pointer cbstruct ; 
 @ @ - 159 , 6 + 172 , 38 @ @ class CallbackReference extends WeakReference { 
 return ( Callback ) get ( ) ; 
 } 
 
 + private static Pointer getNativeFunctionPointer ( Callback cb ) { 
 + if ( cb instanceof NativeFunctionProxy ) { 
 + NativeFunctionHandler handler = 
 + ( NativeFunctionHandler ) Proxy . getInvocationHandler ( cb ) ; 
 + return handler . getPointer ( ) ; 
 + } 
 + return null ; 
 + } 
 + 
 + / * * Return a { @ link Pointer } to the native function address for the 
 + * given callback . 
 + * / 
 + public static Pointer getFunctionPointer ( Callback cb ) { 
 + Pointer fp = null ; 
 + if ( cb = = null ) return null ; 
 + if ( ( fp = getNativeFunctionPointer ( cb ) ) ! = null ) { 
 + return fp ; 
 + } 
 + int callingConvention = cb instanceof AltCallingConvention 
 + ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; 
 + Map map = callingConvention = = Function . ALT _ CONVENTION 
 + ? altCallbackMap : callbackMap ; 
 + synchronized ( map ) { 
 + CallbackReference cbref = ( CallbackReference ) map . get ( cb ) ; 
 + if ( cbref = = null ) { 
 + cbref = new CallbackReference ( cb , callingConvention ) ; 
 + map . put ( cb , cbref ) ; 
 + } 
 + return cbref . getTrampoline ( ) ; 
 + } 
 + } 
 + 
 private class DefaultCallbackProxy implements CallbackProxy { 
 private Method callbackMethod ; 
 private ToNativeConverter toNative ; 
 @ @ - 287 , 6 + 332 , 9 @ @ class CallbackReference extends WeakReference { 
 / / FIXME : need to prevent GC , but how and for how long ? 
 return new NativeString ( value . toString ( ) , true ) . getPointer ( ) ; 
 } 
 + else if ( Callback . class . isAssignableFrom ( cls ) ) { 
 + return getFunctionPointer ( ( Callback ) value ) ; 
 + } 
 else if ( ! isAllowableNativeType ( cls ) ) { 
 throw new IllegalArgumentException ( " Return type " + cls + " will be ignored " ) ; 
 } 
 @ @ - 300 , 11 + 348 , 46 @ @ class CallbackReference extends WeakReference { 
 } 
 } 
 
 + / * * Provide invocation handling for an auto - generated Java interface proxy 
 + * for a native function pointer . 
 + * / 
 + private static class NativeFunctionHandler implements InvocationHandler { 
 + private Function function ; 
 + 
 + public NativeFunctionHandler ( Pointer address , int callingConvention ) { 
 + this . function = new Function ( address , callingConvention ) ; 
 + } 
 + 
 + / * * Chain invocation to the native function . * / 
 + public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { 
 + if ( Library . Handler . OBJECT _ TOSTRING . equals ( method ) ) { 
 + return " Proxy interface to " + function ; 
 + } 
 + else if ( Library . Handler . OBJECT _ HASHCODE . equals ( method ) ) { 
 + return new Integer ( hashCode ( ) ) ; 
 + } 
 + else if ( Library . Handler . OBJECT _ EQUALS . equals ( method ) ) { 
 + Object o = args [ 0 ] ; 
 + if ( o ! = null & & Proxy . isProxyClass ( o . getClass ( ) ) ) { 
 + Boolean . valueOf ( Proxy . getInvocationHandler ( o ) = = this ) ; 
 + } 
 + return Boolean . FALSE ; 
 + } 
 + if ( Function . isVarArgs ( method ) ) { 
 + args = Function . concatenateVarArgs ( args ) ; 
 + } 
 + return function . invoke ( method . getReturnType ( ) , args ) ; 
 + } 
 + 
 + public Pointer getPointer ( ) { 
 + return function ; 
 + } 
 + } 
 / * * Returns whether the given class is supported in native code . 
 * Other types ( String , WString , Structure , arrays , NativeMapped , 
 * etc ) are supported in the Java library . 
 * / 
 - static boolean isAllowableNativeType ( Class cls ) { 
 + private static boolean isAllowableNativeType ( Class cls ) { 
 return cls = = boolean . class | | cls = = Boolean . class 
 | | cls = = byte . class | | cls = = Byte . class 
 | | cls = = short . class | | cls = = Short . class 
 @ @ - 316 , 12 + 399 , 13 @ @ class CallbackReference extends WeakReference { 
 | | Pointer . class . isAssignableFrom ( cls ) ; 
 } 
 
 - / * * Create a callback function pointer . * / 
 + / * * Create a native trampoline to delegate execution to the Java callback . 
 + * / 
 private static native Pointer createNativeCallback ( CallbackProxy callback , 
 Method method , 
 Class [ ] parameterTypes , 
 Class returnType , 
 int callingConvention ) ; 
 - / * * Free the given callback function pointer . * / 
 + / * * Free the given callback trampoline . * / 
 private static native void freeNativeCallback ( long ptr ) ; 
 } 
 diff - - git a / jnalib / src / com / sun / jna / Function . java b / jnalib / src / com / sun / jna / Function . java 
 index 53ce3f8 . . 8ae28cb 100644 
 - - - a / jnalib / src / com / sun / jna / Function . java 
 + + + b / jnalib / src / com / sun / jna / Function . java 
 @ @ - 121 , 7 + 121 , 7 @ @ public class Function extends Pointer { 
 * / 
 Function ( Pointer functionAddress , int callingConvention ) { 
 checkCallingConvention ( callingConvention ) ; 
 - this . functionName = functionAddress . toString ( ) ; 
 + this . functionName = " < unknown > " ; 
 this . callingConvention = callingConvention ; 
 this . peer = functionAddress . peer ; 
 } 
 @ @ - 293 , 6 + 293 , 12 @ @ public class Function extends Pointer { 
 } 
 } 
 } 
 + else if ( Callback . class . isAssignableFrom ( returnType ) ) { 
 + result = invokePointer ( callingConvention , args ) ; 
 + if ( result ! = null ) { 
 + result = CallbackReference . getCallback ( returnType , ( Pointer ) result ) ; 
 + } 
 + } 
 else { 
 throw new IllegalArgumentException ( " Unsupported return type " 
 + returnType ) ; 
 @ @ - 338 , 9 + 344 , 7 @ @ public class Function extends Pointer { 
 } 
 / / Convert Callback to Pointer 
 else if ( arg instanceof Callback ) { 
 - CallbackReference cbref = CallbackReference . getInstance ( ( Callback ) arg ) ; 
 - / / Use pointer to trampoline ( see dispatch . h ) 
 - return cbref . getTrampoline ( ) ; 
 + return CallbackReference . getFunctionPointer ( ( Callback ) arg ) ; 
 } 
 / / String arguments are converted to native pointers here rather 
 / / than in native code so that the values will be valid until 
 @ @ - 526 , 9 + 530 , 11 @ @ public class Function extends Pointer { 
 
 / * * Provide a human - readable representation of this object . * / 
 public String toString ( ) { 
 - String libName = library ! = null ? library . getName ( ) : " < undefined > " ; 
 - return " native function " + functionName + " ( " + libName 
 - + " ) @ 0x " + Long . toHexString ( peer ) ; 
 + if ( library ! = null ) { 
 + return " native function " + functionName + " ( " + library . getName ( ) 
 + + " ) @ 0x " + Long . toHexString ( peer ) ; 
 + } 
 + return " native function @ 0x " + Long . toHexString ( peer ) ; 
 } 
 
 / * * Handle native array of char * type by managing allocation / disposal of 
 @ @ - 599 , 7 + 605 , 18 @ @ public class Function extends Pointer { 
 public void invokeVoid ( Object [ ] args ) { 
 invoke ( Void . class , args ) ; 
 } 
 - 
 + 
 + / * * Two function pointers are equal if they share the same peer address 
 + * and calling convention . 
 + * / 
 + public boolean equals ( Object o ) { 
 + if ( o instanceof Function ) { 
 + Function other = ( Function ) o ; 
 + return other . callingConvention = = this . callingConvention 
 + & & other . peer = = this . peer ; 
 + } 
 + return false ; 
 + } 
 
 / * * Concatenate varargs with normal args to obtain a simple argument 
 * array . 
 diff - - git a / jnalib / src / com / sun / jna / Structure . java b / jnalib / src / com / sun / jna / Structure . java 
 index 95595c7 . . 5f66472 100644 
 - - - a / jnalib / src / com / sun / jna / Structure . java 
 + + + b / jnalib / src / com / sun / jna / Structure . java 
 @ @ - 12 , 10 + 12 , 7 @ @ package com . sun . jna ; 
 
 import java . lang . reflect . Array ; 
 import java . lang . reflect . Field ; 
 - import java . lang . reflect . InvocationHandler ; 
 - import java . lang . reflect . Method ; 
 import java . lang . reflect . Modifier ; 
 - import java . lang . reflect . Proxy ; 
 import java . util . Arrays ; 
 import java . util . HashMap ; 
 import java . util . Iterator ; 
 @ @ - 51 , 6 + 48 , 7 @ @ public abstract class Structure { 
 
 static { 
 / / IBM and JRockit store fields in reverse order ; check for it 
 + / / GCJ returns an array created from a set , and needs fixing 
 Field [ ] fields = MemberOrder . class . getFields ( ) ; 
 REVERSE _ FIELDS = " last " . equals ( fields [ 0 ] . getName ( ) ) ; 
 if ( ! " middle " . equals ( fields [ 1 ] . getName ( ) ) ) { 
 @ @ - 289 , 9 + 287 , 9 @ @ public abstract class Structure { 
 } 
 else try { 
 Callback cb = ( Callback ) structField . field . get ( this ) ; 
 - Pointer oldfp = getFunctionPointer ( cb ) ; 
 + Pointer oldfp = CallbackReference . getFunctionPointer ( cb ) ; 
 if ( ! fp . equals ( oldfp ) ) { 
 - cb = createNativeCallback ( nativeType , fp ) ; 
 + cb = CallbackReference . getCallback ( nativeType , fp ) ; 
 } 
 result = cb ; 
 } 
 @ @ - 506 , 7 + 504 , 7 @ @ public abstract class Structure { 
 s . write ( ) ; 
 } 
 else if ( Callback . class . isAssignableFrom ( nativeType ) ) { 
 - memory . setPointer ( offset , getFunctionPointer ( ( Callback ) value ) ) ; 
 + memory . setPointer ( offset , CallbackReference . getFunctionPointer ( ( Callback ) value ) ) ; 
 } 
 else { 
 throw new IllegalArgumentException ( " Field \ " " + structField . name 
 @ @ - 553 , 6 + 551 , 12 @ @ public abstract class Structure { 
 structField . field = field ; 
 structField . name = field . getName ( ) ; 
 structField . type = type ; 
 + 
 + if ( Callback . class . isAssignableFrom ( type ) & & ! type . isInterface ( ) ) { 
 + throw new IllegalArgumentException ( " Structure Callback field ' " 
 + + field . getName ( ) 
 + + " ' must be an interface " ) ; 
 + } 
 
 int fieldAlignment = 1 ; 
 try { 
 @ @ - 806 , 28 + 810 , 6 @ @ public abstract class Structure { 
 return getPointer ( ) . hashCode ( ) ; 
 } 
 
 - private Pointer getFunctionPointer ( Callback cb ) { 
 - if ( cb = = null ) return null ; 
 - if ( Proxy . isProxyClass ( cb . getClass ( ) ) ) { 
 - InvocationHandler handler = Proxy . getInvocationHandler ( cb ) ; 
 - if ( handler instanceof NativeCallbackHandler ) 
 - return ( ( NativeCallbackHandler ) handler ) . getPointer ( ) ; 
 - } 
 - CallbackReference cbref = CallbackReference . getInstance ( cb ) ; 
 - return cbref . getTrampoline ( ) ; 
 - } 
 - 
 - / * * Create a Callback proxy around a native function pointer . * / 
 - private Callback createNativeCallback ( Class type , Pointer address ) { 
 - if ( ! type . isInterface ( ) ) 
 - throw new IllegalArgumentException ( " Structure Callback field must be an interface " ) ; 
 - int ctype = AltCallingConvention . class . isAssignableFrom ( type ) 
 - ? Function . ALT _ CONVENTION : Function . C _ CONVENTION ; 
 - NativeCallbackHandler h = new NativeCallbackHandler ( address , ctype ) ; 
 - return ( Callback ) Proxy . newProxyInstance ( getClass ( ) . getClassLoader ( ) , 
 - new Class [ ] { type } , h ) ; 
 - } 
 - 
 class StructField extends Object { 
 public String name ; 
 public Class type ; 
 @ @ - 848 , 40 + 830 , 4 @ @ public abstract class Structure { 
 + " = " + value ; 
 } 
 } 
 - 
 - / * * Enable an auto - generated Java interface proxy for a native function 
 - * pointer . 
 - * / 
 - private class NativeCallbackHandler implements InvocationHandler { 
 - private Function function ; 
 - 
 - public NativeCallbackHandler ( Pointer address , int callingConvention ) { 
 - this . function = new Function ( address , callingConvention ) ; 
 - } 
 - 
 - / * * Chain invocation to the native function . * / 
 - public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { 
 - if ( Library . Handler . OBJECT _ TOSTRING . equals ( method ) ) { 
 - return " Proxy interface to function pointer " + function ; 
 - } 
 - else if ( Library . Handler . OBJECT _ HASHCODE . equals ( method ) ) { 
 - return new Integer ( hashCode ( ) ) ; 
 - } 
 - else if ( Library . Handler . OBJECT _ EQUALS . equals ( method ) ) { 
 - Object o = args [ 0 ] ; 
 - if ( o ! = null & & Proxy . isProxyClass ( o . getClass ( ) ) ) { 
 - Boolean . valueOf ( Proxy . getInvocationHandler ( o ) = = this ) ; 
 - } 
 - return Boolean . FALSE ; 
 - } 
 - if ( Function . isVarArgs ( method ) ) { 
 - args = Function . concatenateVarArgs ( args ) ; 
 - } 
 - return function . invoke ( method . getReturnType ( ) , args ) ; 
 - } 
 - 
 - public Pointer getPointer ( ) { 
 - return function ; 
 - } 
 - } 
 } 
 diff - - git a / jnalib / test / com / sun / jna / ReturnTypesTest . java b / jnalib / test / com / sun / jna / ReturnTypesTest . java 
 index 47f4ac8 . . 2d6f318 100644 
 - - - a / jnalib / test / com / sun / jna / ReturnTypesTest . java 
 + + + b / jnalib / test / com / sun / jna / ReturnTypesTest . java 
 @ @ - 53 , 6 + 53 , 11 @ @ public class ReturnTypesTest extends TestCase { 
 WString returnWStringMagic ( ) ; 
 TestStructure returnStaticTestStructure ( ) ; 
 TestStructure returnNullTestStructure ( ) ; 
 + public interface Int32Callback extends Callback { 
 + public int callback ( int arg ) ; 
 + } 
 + Int32Callback returnCallback ( ) ; 
 + Int32Callback returnCallbackArgument ( Int32Callback cb ) ; 
 } 
 
 TestLibrary lib ; 
 @ @ - 161 , 6 + 166 , 22 @ @ public class ReturnTypesTest extends TestCase { 
 assertNull ( " Expect null structure return " , s ) ; 
 } 
 
 + public void testInvokeCallback ( ) { 
 + TestLibrary . Int32Callback cb = lib . returnCallback ( ) ; 
 + assertNotNull ( " Callback should not be null " , cb ) ; 
 + assertEquals ( " Callback should be callable " , 1 , cb . callback ( 1 ) ) ; 
 + 
 + TestLibrary . Int32Callback cb2 = new TestLibrary . Int32Callback ( ) { 
 + public int callback ( int arg ) { 
 + return 0 ; 
 + } 
 + } ; 
 + assertSame ( " Java callback should be looked up " , 
 + cb2 , lib . returnCallbackArgument ( cb2 ) ) ; 
 + assertSame ( " Existing native function wrapper should be reused " , 
 + cb , lib . returnCallbackArgument ( cb ) ) ; 
 + } 
 + 
 public static void main ( java . lang . String [ ] argList ) { 
 junit . textui . TestRunner . run ( ReturnTypesTest . class ) ; 
 }
