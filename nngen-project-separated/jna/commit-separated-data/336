BLEU SCORE: 0.05428210647032972

TEST MSG: Pulled varargs test out of the loop to avoid checking on each parameter
GENERATED MSG: Pass the Method of the Library subclass that invoked the Function , to the FromNativeConverter .

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 0b4b1cf . . eb93d1e 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 18 , 6 + 18 , 7 @ @ Features <nl> * [ # 286 ] ( https : / / github . com / twall / jna / pull / 286 ) : Added in com . sun . jna . platform . win32 . Kernel32 : CreateRemoteThread , WritePocessMemory and ReadProcessMemory - [ @ sstokic - tgm ] ( https : / / github . com / sstokic - tgm ) . <nl> * [ # 350 ] ( https : / / github . com / twall / jna / pull / 350 ) : Added ` jnacontrib . x11 . api . X . Window . getSubwindows ` - [ @ rm5248 ] ( https : / / github . com / rm5248 ) . <nl> * Improved ` contrib / msoffice ` sample - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . <nl> + * [ # 352 ] ( https : / / github . com / twall / jna / pull / 352 ) : Performance improvements due to reduced locking in ` com . sun . jna . Library $ Handler ` and fewer vararg checks in ` com . sun . jna . Function ` - [ @ Boereck ] ( https : / / github . com / Boereck ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> diff - - git a / src / com / sun / jna / Function . java b / src / com / sun / jna / Function . java <nl> index dc1410b . . 7bcc68c 100644 <nl> - - - a / src / com / sun / jna / Function . java <nl> + + + b / src / com / sun / jna / Function . java <nl> @ @ - 288 , 9 + 288 , 10 @ @ public class Function extends Pointer { <nl> Method invokingMethod = ( Method ) options . get ( OPTION _ INVOKING _ METHOD ) ; <nl> Class [ ] paramTypes = invokingMethod ! = null ? invokingMethod . getParameterTypes ( ) : null ; <nl> boolean allowObjects = Boolean . TRUE . equals ( options . get ( Library . OPTION _ ALLOW _ OBJECTS ) ) ; <nl> + boolean isVarArgs = args . length > 0 & & invokingMethod ! = null ? isVarArgs ( invokingMethod ) : false ; <nl> for ( int i = 0 ; i < args . length ; i + + ) { <nl> Class paramType = invokingMethod ! = null <nl> - ? ( isVarArgs ( invokingMethod ) & & i > = paramTypes . length - 1 <nl> + ? ( isVarArgs & & i > = paramTypes . length - 1 <nl> ? paramTypes [ paramTypes . length - 1 ] . getComponentType ( ) <nl> : paramTypes [ i ] ) <nl> : null ; <nl> @ @ - 776 , 21 + 777 , 34 @ @ public class Function extends Pointer { <nl> return inArgs ; <nl> } <nl> <nl> - / * * Varargs are only supported on 1 . 5 + . * / <nl> - static boolean isVarArgs ( Method m ) { <nl> + / * * <nl> + * Reference to Method . isVarArgs <nl> + * / <nl> + private static Method isVarArgsMethod = getIsVarArgsMethod ( ) ; <nl> + <nl> + / * * <nl> + * If possible returns the Method . isVarArgs method via reflection <nl> + * @ return Method . isVarArgs method <nl> + * / <nl> + private static Method getIsVarArgsMethod ( ) { <nl> try { <nl> - Method v = m . getClass ( ) . getMethod ( " isVarArgs " , new Class [ 0 ] ) ; <nl> - return Boolean . TRUE . equals ( v . invoke ( m , new Object [ 0 ] ) ) ; <nl> - } <nl> - catch ( SecurityException e ) { <nl> + return Method . class . getMethod ( " isVarArgs " , new Class [ 0 ] ) ; <nl> + } catch ( SecurityException e ) { <nl> + return null ; <nl> + } catch ( NoSuchMethodException e ) { <nl> + return null ; <nl> } <nl> - catch ( NoSuchMethodException e ) { <nl> - } <nl> - catch ( IllegalArgumentException e ) { <nl> - } <nl> - catch ( IllegalAccessException e ) { <nl> - } <nl> - catch ( InvocationTargetException e ) { <nl> + } <nl> + <nl> + / * * Varargs are only supported on 1 . 5 + . * / <nl> + static boolean isVarArgs ( Method m ) { <nl> + if ( isVarArgsMethod ! = null ) { <nl> + try { <nl> + return Boolean . TRUE . equals ( isVarArgsMethod . invoke ( m , new Object [ 0 ] ) ) ; <nl> + } catch ( IllegalArgumentException e ) { <nl> + } catch ( IllegalAccessException e ) { <nl> + } catch ( InvocationTargetException e ) { <nl> + } <nl> } <nl> return false ; <nl> } <nl> diff - - git a / src / com / sun / jna / Library . java b / src / com / sun / jna / Library . java <nl> index 5928e79 . . e4d0f5d 100644 <nl> - - - a / src / com / sun / jna / Library . java <nl> + + + b / src / com / sun / jna / Library . java <nl> @ @ - 160 , 11 + 160 , 25 @ @ public interface Library { <nl> return interfaceClass ; <nl> } <nl> <nl> - private static class FunctionInfo { <nl> - InvocationHandler handler ; <nl> - Function function ; <nl> - boolean isVarArgs ; <nl> - Map options ; <nl> + / * * <nl> + * FunctionInfo has to be immutable to to make the object visible <nl> + * to other threads fully initialized . This is a prerequisite for <nl> + * using the class in the double checked locking scenario of { @ link Handler # invoke ( Object , Method , Object [ ] ) } <nl> + * / <nl> + private static final class FunctionInfo { <nl> + <nl> + FunctionInfo ( InvocationHandler handler , Function function , boolean isVarArgs , Map options ) { <nl> + super ( ) ; <nl> + this . handler = handler ; <nl> + this . function = function ; <nl> + this . isVarArgs = isVarArgs ; <nl> + this . options = options ; <nl> + } <nl> + <nl> + final InvocationHandler handler ; <nl> + final Function function ; <nl> + final boolean isVarArgs ; <nl> + final Map options ; <nl> } <nl> <nl> public Object invoke ( Object proxy , Method method , Object [ ] inArgs ) <nl> @ @ - 185 , 22 + 199 , 28 @ @ public interface Library { <nl> return Boolean . FALSE ; <nl> } <nl> <nl> - FunctionInfo f = null ; <nl> - synchronized ( functions ) { <nl> - f = ( FunctionInfo ) functions . get ( method ) ; <nl> - if ( f = = null ) { <nl> - f = new FunctionInfo ( ) ; <nl> - f . isVarArgs = Function . isVarArgs ( method ) ; <nl> - if ( invocationMapper ! = null ) { <nl> - f . handler = invocationMapper . getInvocationHandler ( nativeLibrary , method ) ; <nl> - } <nl> - if ( f . handler = = null ) { <nl> - / / Find the function to invoke <nl> - f . function = nativeLibrary . getFunction ( method . getName ( ) , method ) ; <nl> - f . options = new HashMap ( this . options ) ; <nl> - f . options . put ( Function . OPTION _ INVOKING _ METHOD , method ) ; <nl> + / / Using the double - checked locking pattern to speed up function calls <nl> + FunctionInfo f = ( FunctionInfo ) functions . get ( method ) ; <nl> + if ( f = = null ) { <nl> + synchronized ( functions ) { <nl> + f = ( FunctionInfo ) functions . get ( method ) ; <nl> + if ( f = = null ) { <nl> + boolean isVarArgs = Function . isVarArgs ( method ) ; <nl> + InvocationHandler handler = null ; <nl> + if ( invocationMapper ! = null ) { <nl> + handler = invocationMapper . getInvocationHandler ( nativeLibrary , method ) ; <nl> + } <nl> + Function function = null ; <nl> + Map options = null ; <nl> + if ( handler = = null ) { <nl> + / / Find the function to invoke <nl> + function = nativeLibrary . getFunction ( method . getName ( ) , method ) ; <nl> + options = new HashMap ( this . options ) ; <nl> + options . put ( Function . OPTION _ INVOKING _ METHOD , method ) ; <nl> + } <nl> + f = new FunctionInfo ( handler , function , isVarArgs , options ) ; <nl> + functions . put ( method , f ) ; <nl> } <nl> - functions . put ( method , f ) ; <nl> } <nl> } <nl> if ( f . isVarArgs ) {
NEAREST DIFF (one line): diff - - git a / jnalib / dist / freebsd - i386 . jar b / jnalib / dist / freebsd - i386 . jar <nl> index 6c8aec2 . . 7eea228 100644 <nl> Binary files a / jnalib / dist / freebsd - i386 . jar and b / jnalib / dist / freebsd - i386 . jar differ <nl> diff - - git a / jnalib / native / dispatch . h b / jnalib / native / dispatch . h <nl> index d1dc381 . . 4c5a20d 100644 <nl> - - - a / jnalib / native / dispatch . h <nl> + + + b / jnalib / native / dispatch . h <nl> @ @ - 47 , 8 + 47 , 12 @ @ typedef long word _ t ; <nl> # define alloca _ alloca <nl> # endif <nl> # else <nl> + # ifdef _ _ FreeBSD _ _ <nl> + # include < stdlib . h > <nl> + # else <nl> # include < alloca . h > <nl> # endif <nl> + # endif <nl> <nl> / * Convenience macros * / <nl> # define LOAD _ REF ( ENV , VAR ) \

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 0b4b1cf . . eb93d1e 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 18 , 6 + 18 , 7 @ @ Features 
 * [ # 286 ] ( https : / / github . com / twall / jna / pull / 286 ) : Added in com . sun . jna . platform . win32 . Kernel32 : CreateRemoteThread , WritePocessMemory and ReadProcessMemory - [ @ sstokic - tgm ] ( https : / / github . com / sstokic - tgm ) . 
 * [ # 350 ] ( https : / / github . com / twall / jna / pull / 350 ) : Added ` jnacontrib . x11 . api . X . Window . getSubwindows ` - [ @ rm5248 ] ( https : / / github . com / rm5248 ) . 
 * Improved ` contrib / msoffice ` sample - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . 
 + * [ # 352 ] ( https : / / github . com / twall / jna / pull / 352 ) : Performance improvements due to reduced locking in ` com . sun . jna . Library $ Handler ` and fewer vararg checks in ` com . sun . jna . Function ` - [ @ Boereck ] ( https : / / github . com / Boereck ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 diff - - git a / src / com / sun / jna / Function . java b / src / com / sun / jna / Function . java 
 index dc1410b . . 7bcc68c 100644 
 - - - a / src / com / sun / jna / Function . java 
 + + + b / src / com / sun / jna / Function . java 
 @ @ - 288 , 9 + 288 , 10 @ @ public class Function extends Pointer { 
 Method invokingMethod = ( Method ) options . get ( OPTION _ INVOKING _ METHOD ) ; 
 Class [ ] paramTypes = invokingMethod ! = null ? invokingMethod . getParameterTypes ( ) : null ; 
 boolean allowObjects = Boolean . TRUE . equals ( options . get ( Library . OPTION _ ALLOW _ OBJECTS ) ) ; 
 + boolean isVarArgs = args . length > 0 & & invokingMethod ! = null ? isVarArgs ( invokingMethod ) : false ; 
 for ( int i = 0 ; i < args . length ; i + + ) { 
 Class paramType = invokingMethod ! = null 
 - ? ( isVarArgs ( invokingMethod ) & & i > = paramTypes . length - 1 
 + ? ( isVarArgs & & i > = paramTypes . length - 1 
 ? paramTypes [ paramTypes . length - 1 ] . getComponentType ( ) 
 : paramTypes [ i ] ) 
 : null ; 
 @ @ - 776 , 21 + 777 , 34 @ @ public class Function extends Pointer { 
 return inArgs ; 
 } 
 
 - / * * Varargs are only supported on 1 . 5 + . * / 
 - static boolean isVarArgs ( Method m ) { 
 + / * * 
 + * Reference to Method . isVarArgs 
 + * / 
 + private static Method isVarArgsMethod = getIsVarArgsMethod ( ) ; 
 + 
 + / * * 
 + * If possible returns the Method . isVarArgs method via reflection 
 + * @ return Method . isVarArgs method 
 + * / 
 + private static Method getIsVarArgsMethod ( ) { 
 try { 
 - Method v = m . getClass ( ) . getMethod ( " isVarArgs " , new Class [ 0 ] ) ; 
 - return Boolean . TRUE . equals ( v . invoke ( m , new Object [ 0 ] ) ) ; 
 - } 
 - catch ( SecurityException e ) { 
 + return Method . class . getMethod ( " isVarArgs " , new Class [ 0 ] ) ; 
 + } catch ( SecurityException e ) { 
 + return null ; 
 + } catch ( NoSuchMethodException e ) { 
 + return null ; 
 } 
 - catch ( NoSuchMethodException e ) { 
 - } 
 - catch ( IllegalArgumentException e ) { 
 - } 
 - catch ( IllegalAccessException e ) { 
 - } 
 - catch ( InvocationTargetException e ) { 
 + } 
 + 
 + / * * Varargs are only supported on 1 . 5 + . * / 
 + static boolean isVarArgs ( Method m ) { 
 + if ( isVarArgsMethod ! = null ) { 
 + try { 
 + return Boolean . TRUE . equals ( isVarArgsMethod . invoke ( m , new Object [ 0 ] ) ) ; 
 + } catch ( IllegalArgumentException e ) { 
 + } catch ( IllegalAccessException e ) { 
 + } catch ( InvocationTargetException e ) { 
 + } 
 } 
 return false ; 
 } 
 diff - - git a / src / com / sun / jna / Library . java b / src / com / sun / jna / Library . java 
 index 5928e79 . . e4d0f5d 100644 
 - - - a / src / com / sun / jna / Library . java 
 + + + b / src / com / sun / jna / Library . java 
 @ @ - 160 , 11 + 160 , 25 @ @ public interface Library { 
 return interfaceClass ; 
 } 
 
 - private static class FunctionInfo { 
 - InvocationHandler handler ; 
 - Function function ; 
 - boolean isVarArgs ; 
 - Map options ; 
 + / * * 
 + * FunctionInfo has to be immutable to to make the object visible 
 + * to other threads fully initialized . This is a prerequisite for 
 + * using the class in the double checked locking scenario of { @ link Handler # invoke ( Object , Method , Object [ ] ) } 
 + * / 
 + private static final class FunctionInfo { 
 + 
 + FunctionInfo ( InvocationHandler handler , Function function , boolean isVarArgs , Map options ) { 
 + super ( ) ; 
 + this . handler = handler ; 
 + this . function = function ; 
 + this . isVarArgs = isVarArgs ; 
 + this . options = options ; 
 + } 
 + 
 + final InvocationHandler handler ; 
 + final Function function ; 
 + final boolean isVarArgs ; 
 + final Map options ; 
 } 
 
 public Object invoke ( Object proxy , Method method , Object [ ] inArgs ) 
 @ @ - 185 , 22 + 199 , 28 @ @ public interface Library { 
 return Boolean . FALSE ; 
 } 
 
 - FunctionInfo f = null ; 
 - synchronized ( functions ) { 
 - f = ( FunctionInfo ) functions . get ( method ) ; 
 - if ( f = = null ) { 
 - f = new FunctionInfo ( ) ; 
 - f . isVarArgs = Function . isVarArgs ( method ) ; 
 - if ( invocationMapper ! = null ) { 
 - f . handler = invocationMapper . getInvocationHandler ( nativeLibrary , method ) ; 
 - } 
 - if ( f . handler = = null ) { 
 - / / Find the function to invoke 
 - f . function = nativeLibrary . getFunction ( method . getName ( ) , method ) ; 
 - f . options = new HashMap ( this . options ) ; 
 - f . options . put ( Function . OPTION _ INVOKING _ METHOD , method ) ; 
 + / / Using the double - checked locking pattern to speed up function calls 
 + FunctionInfo f = ( FunctionInfo ) functions . get ( method ) ; 
 + if ( f = = null ) { 
 + synchronized ( functions ) { 
 + f = ( FunctionInfo ) functions . get ( method ) ; 
 + if ( f = = null ) { 
 + boolean isVarArgs = Function . isVarArgs ( method ) ; 
 + InvocationHandler handler = null ; 
 + if ( invocationMapper ! = null ) { 
 + handler = invocationMapper . getInvocationHandler ( nativeLibrary , method ) ; 
 + } 
 + Function function = null ; 
 + Map options = null ; 
 + if ( handler = = null ) { 
 + / / Find the function to invoke 
 + function = nativeLibrary . getFunction ( method . getName ( ) , method ) ; 
 + options = new HashMap ( this . options ) ; 
 + options . put ( Function . OPTION _ INVOKING _ METHOD , method ) ; 
 + } 
 + f = new FunctionInfo ( handler , function , isVarArgs , options ) ; 
 + functions . put ( method , f ) ; 
 } 
 - functions . put ( method , f ) ; 
 } 
 } 
 if ( f . isVarArgs ) {

NEAREST DIFF:
diff - - git a / jnalib / dist / freebsd - i386 . jar b / jnalib / dist / freebsd - i386 . jar 
 index 6c8aec2 . . 7eea228 100644 
 Binary files a / jnalib / dist / freebsd - i386 . jar and b / jnalib / dist / freebsd - i386 . jar differ 
 diff - - git a / jnalib / native / dispatch . h b / jnalib / native / dispatch . h 
 index d1dc381 . . 4c5a20d 100644 
 - - - a / jnalib / native / dispatch . h 
 + + + b / jnalib / native / dispatch . h 
 @ @ - 47 , 8 + 47 , 12 @ @ typedef long word _ t ; 
 # define alloca _ alloca 
 # endif 
 # else 
 + # ifdef _ _ FreeBSD _ _ 
 + # include < stdlib . h > 
 + # else 
 # include < alloca . h > 
 # endif 
 + # endif 
 
 / * Convenience macros * / 
 # define LOAD _ REF ( ENV , VAR ) \
