BLEU SCORE: 0.020980574531482755

TEST MSG: Ensure XSI - compliant strerror _ r is used .
GENERATED MSG: enable accessing current process on w32

TEST DIFF (one line): diff - - git a / native / dispatch . c b / native / dispatch . c <nl> index 3712e12 . . 735370a 100644 <nl> - - - a / native / dispatch . c <nl> + + + b / native / dispatch . c <nl> @ @ - 16 , 6 + 16 , 10 @ @ <nl> * Lesser General Public License for more details . <nl> * / <nl> <nl> + # include " dispatch . h " <nl> + <nl> + # include < string . h > <nl> + <nl> # if defined ( _ WIN32 ) <nl> # define WIN32 _ LEAN _ AND _ MEAN <nl> # include < windows . h > <nl> @ @ - 45 , 6 + 49 , 7 @ @ <nl> # else <nl> # include < dlfcn . h > <nl> # include < errno . h > <nl> + # include < assert . h > <nl> # define STRTYPE char * <nl> # ifdef USE _ DEFAULT _ LIBNAME _ ENCODING <nl> # define NAME2CSTR ( ENV , JSTR ) newCString ( ENV , JSTR ) <nl> @ @ - 53 , 8 + 58 , 21 @ @ <nl> # endif <nl> # define DEFAULT _ LOAD _ OPTS ( RTLD _ LAZY | RTLD _ GLOBAL ) <nl> # define LOAD _ LIBRARY ( NAME , OPTS ) dlopen ( NAME , OPTS ) <nl> - # define LOAD _ ERROR ( BUF , LEN ) ( snprintf ( BUF , LEN , " % s " , dlerror ( ) ) , BUF ) <nl> - # define STR _ ERROR ( CODE , BUF , LEN ) ( strerror _ r ( CODE , BUF , LEN ) , BUF ) <nl> + static inline char * LOAD _ ERROR ( char * buf , size _ t len ) { <nl> + const size _ t count = snprintf ( buf , len , " % s " , dlerror ( ) ) ; <nl> + assert ( count < = len & & " snprintf ( ) output has been truncated " ) ; <nl> + return buf ; <nl> + } <nl> + static inline char * STR _ ERROR ( int code , char * buf , size _ t len ) { <nl> + / / The conversion will fail if code is not a valid error code . <nl> + int err = strerror _ r ( code , buf , len ) ; <nl> + if ( err ) <nl> + / / Depending on glib version , " Unknown error " error code <nl> + / / may be returned or passed using errno . <nl> + err = strerror _ r ( err > 0 ? err : errno , buf , len ) ; <nl> + assert ( err = = 0 & & " strerror _ r ( ) conversion has failed " ) ; <nl> + return buf ; <nl> + } <nl> # define FREE _ LIBRARY ( HANDLE ) dlclose ( HANDLE ) <nl> # define FIND _ ENTRY ( HANDLE , NAME ) dlsym ( HANDLE , NAME ) <nl> # endif <nl> @ @ - 67 , 16 + 85 , 10 @ @ <nl> # endif <nl> <nl> # include < stdlib . h > <nl> - / / Force XSI - compliant strerror _ r ( http : / / unixhelp . ed . ac . uk / CGI / man - cgi ? strerror ) <nl> - # ifndef _ XOPEN _ SOURCE <nl> - # define _ XOPEN _ SOURCE 600 <nl> - # endif <nl> - # include < string . h > <nl> + # include < alloca . h > <nl> # include < wchar . h > <nl> # include < jni . h > <nl> <nl> - # include " dispatch . h " <nl> - <nl> # ifndef NO _ JAWT <nl> # include < jawt . h > <nl> # include < jawt _ md . h > <nl> diff - - git a / native / dispatch . h b / native / dispatch . h <nl> index 824c3dd . . 9a5b9c0 100644 <nl> - - - a / native / dispatch . h <nl> + + + b / native / dispatch . h <nl> @ @ - 36 , 6 + 36 , 7 @ @ <nl> # define GET _ LAST _ ERROR ( ) GetLastError ( ) <nl> # define SET _ LAST _ ERROR ( CODE ) SetLastError ( CODE ) <nl> # else <nl> + # define _ XOPEN _ SOURCE 600 <nl> # define GET _ LAST _ ERROR ( ) errno <nl> # define SET _ LAST _ ERROR ( CODE ) ( errno = ( CODE ) ) <nl> # endif / * _ WIN32 * /
NEAREST DIFF (one line): diff - - git a / jnalib / native / Makefile b / jnalib / native / Makefile <nl> index b5fff03 . . 8e4c8f9 100644 <nl> - - - a / jnalib / native / Makefile <nl> + + + b / jnalib / native / Makefile <nl> @ @ - 86 , 7 + 86 , 7 @ @ STRIP = strip - x <nl> <nl> ifeq ( $ ( OS ) , win32 ) <nl> ARCH = $ ( shell uname - m | sed ' s / i . 86 / i386 / g ' ) <nl> - CDEFINES = - DHAVE _ PROTECTION <nl> + CDEFINES = - DHAVE _ PROTECTION - DPSAPI _ VERSION = 1 <nl> LIBS = - lpsapi <nl> WINDRES = windres <nl> EXTRAOBJS = $ ( RSRC ) <nl> @ @ - 116 , 6 + 116 , 8 @ @ else <nl> # MSVC ( wrapper scripts ) <nl> CC = $ ( FFI _ SRC ) / . . / cc . sh - m64 <nl> LD = $ ( FFI _ SRC ) / . . / ld . sh - m64 <nl> + COPT = <nl> + LIBS = psapi . lib <nl> ARSFX = . lib <nl> FFI _ CONFIG + = - - host = x86 _ 64 - pc - mingw32 & & rm - f include / ffitarget . h & & cp $ ( FFI _ SRC ) / include / * . h $ ( FFI _ SRC ) / src / x86 / ffitarget . h include <nl> FFI _ ENV + = LD = " $ ( LD ) " CPP = cpp <nl> diff - - git a / jnalib / native / callback . c b / jnalib / native / callback . c <nl> index a90368d . . 45d9678 100644 <nl> - - - a / jnalib / native / callback . c <nl> + + + b / jnalib / native / callback . c <nl> @ @ - 45 , 7 + 45 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> ffi _ status status ; <nl> jsize argc ; <nl> JavaVM * vm ; <nl> - char rtype ; <nl> + int rtype ; <nl> char msg [ 64 ] ; <nl> int i ; <nl> int cvt = 0 ; <nl> @ @ - 81 , 27 + 81 , 28 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> cvt = 1 ; <nl> } <nl> <nl> - cb - > arg _ jtypes [ i ] = jtype = get _ jtype ( env , cls ) ; <nl> + jtype = get _ jtype ( env , cls ) ; <nl> if ( jtype = = - 1 ) { <nl> snprintf ( msg , sizeof ( msg ) , " Unsupported argument at index % d " , i ) ; <nl> throw _ type = EIllegalArgument ; <nl> throw _ msg = msg ; <nl> goto failure _ cleanup ; <nl> } <nl> - <nl> + cb - > arg _ jtypes [ i ] = ( char ) jtype ; <nl> cb - > java _ arg _ types [ i + 3 ] = cb - > arg _ types [ i ] = get _ ffi _ type ( env , cls , cb - > arg _ jtypes [ i ] ) ; <nl> if ( cb - > flags [ i ] = = CVT _ NATIVE _ MAPPED <nl> | | cb - > flags [ i ] = = CVT _ POINTER _ TYPE <nl> | | cb - > flags [ i ] = = CVT _ INTEGER _ TYPE ) { <nl> jclass ncls ; <nl> ncls = getNativeType ( env , cls ) ; <nl> - cb - > arg _ jtypes [ i ] = jtype = get _ jtype ( env , ncls ) ; <nl> + jtype = get _ jtype ( env , ncls ) ; <nl> if ( jtype = = - 1 ) { <nl> snprintf ( msg , sizeof ( msg ) , " Unsupported NativeMapped argument native type at argument % d " , i ) ; <nl> throw _ type = EIllegalArgument ; <nl> throw _ msg = msg ; <nl> goto failure _ cleanup ; <nl> } <nl> + cb - > arg _ jtypes [ i ] = ( char ) jtype ; <nl> cb - > java _ arg _ types [ i + 3 ] = & ffi _ type _ pointer ; <nl> cb - > arg _ types [ i ] = get _ ffi _ type ( env , ncls , cb - > arg _ jtypes [ i ] ) ; <nl> } <nl> @ @ - 140 , 12 + 141 , 12 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> # endif / / _ WIN32 <nl> <nl> rtype = get _ jtype ( env , return _ type ) ; <nl> - if ( ! rtype ) { <nl> + if ( rtype = = - 1 ) { <nl> throw _ type = EIllegalArgument ; <nl> throw _ msg = " Unsupported return type " ; <nl> goto failure _ cleanup ; <nl> } <nl> - ffi _ rtype = get _ ffi _ rtype ( env , return _ type , rtype ) ; <nl> + ffi _ rtype = get _ ffi _ rtype ( env , return _ type , ( char ) rtype ) ; <nl> if ( ! ffi _ rtype ) { <nl> throw _ type = EIllegalArgument ; <nl> throw _ msg = " Error in return type " ; <nl> @ @ - 252 , 7 + 253 , 7 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar <nl> else if ( cb - > direct ) { <nl> unsigned int i ; <nl> void * * args = alloca ( ( cif - > nargs + 3 ) * sizeof ( void * ) ) ; <nl> - args [ 0 ] = & env ; <nl> + args [ 0 ] = ( void * ) & env ; <nl> args [ 1 ] = & self ; <nl> args [ 2 ] = & cb - > methodID ; <nl> memcpy ( & args [ 3 ] , cbargs , cif - > nargs * sizeof ( void * ) ) ; <nl> diff - - git a / jnalib / native / cc . sh b / jnalib / native / cc . sh <nl> index b39b8f5 . . 554e88f 100755 <nl> - - - a / jnalib / native / cc . sh <nl> + + + b / jnalib / native / cc . sh <nl> @ @ - 41 , 7 + 41 , 7 @ @ do <nl> shift 1 <nl> ; ; <nl> - O * ) <nl> - args = " $ args / O1 " <nl> + args = " $ args $ i " <nl> shift 1 <nl> ; ; <nl> - g ) <nl> diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c <nl> index aa978c8 . . ce31cce 100644 <nl> - - - a / jnalib / native / dispatch . c <nl> + + + b / jnalib / native / dispatch . c <nl> @ @ - 22 , 6 + 22 , 9 @ @ <nl> * / <nl> <nl> # if defined ( _ WIN32 ) <nl> + # ifdef _ MSC _ VER <nl> + # pragma warning ( disable : 4201 ) / * nameless struct / union ( jni _ md . h ) * / <nl> + # endif <nl> # ifndef UNICODE <nl> # define UNICODE <nl> # endif <nl> @ @ - 1376 , 9 + 1379 , 11 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Memory _ free <nl> void <nl> throwByName ( JNIEnv * env , const char * name , const char * msg ) <nl> { <nl> + jclass cls ; <nl> + <nl> ( * env ) - > ExceptionClear ( env ) ; <nl> <nl> - jclass cls = ( * env ) - > FindClass ( env , name ) ; <nl> + cls = ( * env ) - > FindClass ( env , name ) ; <nl> <nl> if ( cls ! = NULL ) { / * Otherwise an exception has already been thrown * / <nl> ( * env ) - > ThrowNew ( env , cls , msg ) ; <nl> @ @ - 1749 , 8 + 1754 , 8 @ @ toNativeTypeMapped ( JNIEnv * env , jobject obj , void * valuep , size _ t size , jobject <nl> <nl> static void <nl> fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , void * resp , ffi _ type * type , jclass javaClass , void * result ) { <nl> - char jtype = get _ jtype _ from _ ffi _ type ( type ) ; <nl> - jobject value = new _ object ( env , jtype , resp , JNI _ TRUE ) ; <nl> + int jtype = get _ jtype _ from _ ffi _ type ( type ) ; <nl> + jobject value = new _ object ( env , ( char ) jtype , resp , JNI _ TRUE ) ; <nl> jobject obj = ( * env ) - > CallStaticObjectMethod ( env , classNative , <nl> MID _ Native _ fromNativeTypeMapped , <nl> from _ native , value , javaClass ) ; <nl> @ @ - 1763 , 7 + 1768 , 7 @ @ fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , void * resp , ffi _ type * typ <nl> jobject <nl> fromNative ( JNIEnv * env , jclass javaClass , ffi _ type * type , void * resp , jboolean promote ) { <nl> int jtype = get _ jtype _ from _ ffi _ type ( type ) ; <nl> - jobject value = new _ object ( env , jtype , resp , promote ) ; <nl> + jobject value = new _ object ( env , ( char ) jtype , resp , promote ) ; <nl> return ( * env ) - > CallStaticObjectMethod ( env , classNative , <nl> MID _ Native _ fromNative , <nl> javaClass , value ) ; <nl> @ @ - 1792 , 7 + 1797 , 7 @ @ getArrayComponentType ( JNIEnv * env , jobject obj ) { <nl> jclass cls = ( * env ) - > GetObjectClass ( env , obj ) ; <nl> jclass type = ( * env ) - > CallObjectMethod ( env , cls , MID _ Class _ getComponentType ) ; <nl> if ( type ! = NULL ) { <nl> - return get _ jtype ( env , type ) ; <nl> + return ( char ) get _ jtype ( env , type ) ; <nl> } <nl> return 0 ; <nl> } <nl> @ @ - 2567 , 7 + 2572 , 6 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { <nl> void * * args = argp + 2 ; <nl> void * * volatile objects = NULL ; <nl> release _ t * volatile release = NULL ; <nl> - char * volatile array _ types = NULL ; <nl> void * * volatile elems = NULL ; <nl> unsigned i ; <nl> void * oldresp = resp ; <nl> @ @ - 2604 , 9 + 2608 , 10 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { <nl> case CVT _ TYPE _ MAPPER : <nl> { <nl> void * valuep = args [ i ] ; <nl> - char jtype = get _ jtype _ from _ ffi _ type ( data - > closure _ cif . arg _ types [ i + 2 ] ) ; <nl> + int jtype = get _ jtype _ from _ ffi _ type ( data - > closure _ cif . arg _ types [ i + 2 ] ) ; <nl> jobject obj = jtype = = ' * ' <nl> - ? * ( void * * ) valuep : new _ object ( env , jtype , valuep , JNI _ FALSE ) ; <nl> + ? * ( void * * ) valuep <nl> + : new _ object ( env , ( char ) jtype , valuep , JNI _ FALSE ) ; <nl> if ( cif - > arg _ types [ i + 2 ] - > size < data - > cif . arg _ types [ i ] - > size ) { <nl> args [ i ] = alloca ( data - > cif . arg _ types [ i ] - > size ) ; <nl> } <nl> @ @ - 2827 , 7 + 2832 , 6 @ @ Java _ com _ sun _ jna _ Native _ registerMethod ( JNIEnv * env , jclass ncls , <nl> int status ; <nl> int i ; <nl> int abi = FFI _ DEFAULT _ ABI ; <nl> - char * tmp , msg [ 256 ] ; <nl> ffi _ type * rtype = ( ffi _ type * ) L2A ( return _ type ) ; <nl> ffi _ type * closure _ rtype = ( ffi _ type * ) L2A ( closure _ return _ type ) ; <nl> jlong * types = atypes ? ( * env ) - > GetLongArrayElements ( env , atypes , NULL ) : NULL ; <nl> @ @ - 2886 , 7 + 2890 , 7 @ @ Java _ com _ sun _ jna _ Native _ registerMethod ( JNIEnv * env , jclass ncls , <nl> } <nl> <nl> { <nl> - JNINativeMethod m = { ( char * ) cname , ( char * ) sig , code } ; <nl> + JNINativeMethod m = { ( char * ) cname , ( char * ) sig , code } ; <nl> ( * env ) - > RegisterNatives ( env , cls , & m , 1 ) ; <nl> } <nl> <nl> @ @ - 2997 , 12 + 3001 , 11 @ @ JNIEXPORT jint JNICALL <nl> Java _ com _ sun _ jna _ Native _ initialize _ 1ffi _ 1type ( JNIEnv * env , jclass cls , jlong type _ info ) { <nl> ffi _ type * type = L2A ( type _ info ) ; <nl> ffi _ cif cif ; <nl> - ffi _ type * atypes [ ] = { } ; <nl> - ffi _ status status = ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 0 , type , atypes ) ; <nl> + ffi _ status status = ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 0 , type , NULL ) ; <nl> if ( ffi _ error ( env , " ffi _ prep _ cif " , status ) ) { <nl> return 0 ; <nl> } <nl> - return type - > size ; <nl> + return ( jint ) type - > size ; <nl> } <nl> <nl> # ifdef _ _ cplusplus <nl> diff - - git a / jnalib / native / dispatch . h b / jnalib / native / dispatch . h <nl> index 19bfd64 . . 77bacb3 100644 <nl> - - - a / jnalib / native / dispatch . h <nl> + + + b / jnalib / native / dispatch . h <nl> @ @ - 22 , 6 + 22 , 11 @ @ <nl> # ifdef _ WIN32 <nl> # ifdef _ MSC _ VER <nl> # define alloca _ alloca <nl> + # pragma warning ( disable : 4152 ) / * function / data conversion * / <nl> + # pragma warning ( disable : 4054 ) / * cast function pointer to data pointer * / <nl> + # pragma warning ( disable : 4055 ) / * cast data pointer to function pointer * / <nl> + # pragma warning ( disable : 4204 ) / * structure initializer * / <nl> + # pragma warning ( disable : 4710 ) / * swprintf not inlined * / <nl> # else <nl> # include < malloc . h > <nl> # endif / * _ MSC _ VER * / <nl> diff - - git a / jnalib / test / com / sun / jna / WebStartTest . java b / jnalib / test / com / sun / jna / WebStartTest . java <nl> index e15a672 . . 71001f6 100644 <nl> - - - a / jnalib / test / com / sun / jna / WebStartTest . java <nl> + + + b / jnalib / test / com / sun / jna / WebStartTest . java <nl> @ @ - 136 , 20 + 136 , 7 @ @ public class WebStartTest extends TestCase { <nl> os . write ( contents . getBytes ( ) ) ; <nl> os . close ( ) ; <nl> File keystore = new File ( " jna . keystore " ) ; <nl> - String JAVA _ HOME = System . getProperty ( " java . home " ) ; <nl> - String LIB = new File ( JAVA _ HOME , " / lib " ) . getAbsolutePath ( ) ; <nl> - if ( ! new File ( LIB , " javaws . jar " ) . exists ( ) ) { <nl> - LIB = new File ( " / System / Library / Frameworks / JavaVM . framework / Resources / Deploy . bundle / Contents / Home / lib " ) . getAbsolutePath ( ) ; <nl> - if ( ! new File ( LIB , " javaws . jar " ) . exists ( ) ) { <nl> - throw new IOException ( " javaws . jar not found " ) ; <nl> - } <nl> - } <nl> - String PS = System . getProperty ( " path . separator " ) ; <nl> - String path = System . getProperty ( " java . home " ) + " / bin / javaws " ; <nl> - if ( Platform . isWindows ( ) ) path + = " . exe " ; <nl> - File javaws = new File ( path ) ; <nl> - / / NOTE : OSX puts javaws somewhere else entirely <nl> - if ( ! javaws . exists ( ) ) path = " javaws " ; <nl> + String path = findJWS ( ) ; <nl> String [ ] cmd = { <nl> path , <nl> " - Xnosplash " , <nl> @ @ - 259 , 16 + 246 , 80 @ @ public class WebStartTest extends TestCase { <nl> } <nl> } <nl> <nl> + public interface FolderInfo extends com . sun . jna . win32 . StdCallLibrary { <nl> + int MAX _ PATH = 260 ; <nl> + int SHGFP _ TYPE _ CURRENT = 0 ; <nl> + int SHGFP _ TYPE _ DEFAULT = 1 ; <nl> + int CSIDL _ APPDATA = 26 ; <nl> + int CSIDL _ WINDOWS = 36 ; <nl> + int SHGetFolderPathW ( Pointer owner , int folder , Pointer token , <nl> + int flags , char [ ] path ) ; <nl> + } <nl> + <nl> + private String findJWS ( ) throws IOException { <nl> + String JAVA _ HOME = System . getProperty ( " java . home " ) ; <nl> + String LIB = new File ( JAVA _ HOME , " / lib " ) . getAbsolutePath ( ) ; <nl> + if ( ! new File ( LIB , " javaws . jar " ) . exists ( ) ) { <nl> + LIB = new File ( " / System / Library / Frameworks / JavaVM . framework / Resources / Deploy . bundle / Contents / Home / lib " ) . getAbsolutePath ( ) ; <nl> + if ( ! new File ( LIB , " javaws . jar " ) . exists ( ) ) { <nl> + if ( ! Platform . isWindows ( ) ) <nl> + throw new IOException ( " javaws . jar not found " ) ; <nl> + } <nl> + } <nl> + String PS = System . getProperty ( " path . separator " ) ; <nl> + String path = System . getProperty ( " java . home " ) + " / bin / javaws " ; <nl> + File javaws = new File ( path ) ; <nl> + / / NOTE : OSX puts javaws somewhere else entirely <nl> + / / NOTE : win64 only includes javaws in the system path <nl> + if ( ! javaws . exists ( ) ) { <nl> + if ( Platform . isWindows ( ) ) { <nl> + FolderInfo info = ( FolderInfo ) <nl> + Native . loadLibrary ( " shell32 " , FolderInfo . class ) ; <nl> + char [ ] buf = new char [ FolderInfo . MAX _ PATH ] ; <nl> + int flags = 0 ; <nl> + int result = info . SHGetFolderPathW ( null , FolderInfo . CSIDL _ WINDOWS , null , 0 , buf ) ; <nl> + path = Native . toString ( buf ) ; <nl> + if ( Platform . is64Bit ( ) ) { <nl> + javaws = new File ( path , " SysWOW64 / javaws . exe " ) ; <nl> + } <nl> + else { <nl> + javaws = new File ( path , " system32 / javaws . exe " ) ; <nl> + } <nl> + path = javaws . getAbsolutePath ( ) ; <nl> + } <nl> + else { <nl> + path = javaws . getName ( ) ; <nl> + } <nl> + } <nl> + return path ; <nl> + } <nl> + <nl> private File findDeploymentProperties ( ) { <nl> String path = System . getProperty ( " user . home " ) ; <nl> File deployment ; <nl> if ( Platform . isWindows ( ) ) { <nl> + FolderInfo info = ( FolderInfo ) <nl> + Native . loadLibrary ( " shell32 " , FolderInfo . class ) ; <nl> + char [ ] buf = new char [ FolderInfo . MAX _ PATH ] ; <nl> + int flags = 0 ; <nl> + int result = info . SHGetFolderPathW ( null , FolderInfo . CSIDL _ APPDATA , <nl> + null , 0 , buf ) ; <nl> + path = Native . toString ( buf ) ; <nl> + <nl> / / NOTE : works for Sun and IBM , may not work for others <nl> String vendor = System . getProperty ( " java . vm . vendor " ) ; <nl> if ( vendor . indexOf ( " " ) ! = - 1 ) { <nl> vendor = vendor . substring ( 0 , vendor . indexOf ( " " ) ) ; <nl> } <nl> - deployment = new File ( path + " / Application Data / " + vendor + " / Java / Deployment " ) ; <nl> + deployment = new File ( path + " / " + vendor + " / Java / Deployment " ) ; <nl> + if ( ! deployment . exists ( ) <nl> + & & deployment . getAbsolutePath ( ) . indexOf ( " Roaming " ) ! = - 1 ) { <nl> + deployment = new File ( deployment . getAbsolutePath ( ) . replace ( " Roaming " , " LocalLow " ) ) ; <nl> + if ( ! deployment . exists ( ) ) { <nl> + deployment = new File ( deployment . getAbsolutePath ( ) . replace ( " LocalLow " , " Local " ) ) ; <nl> + } <nl> + } <nl> + <nl> } <nl> else if ( Platform . isMac ( ) ) { <nl> deployment = new File ( path + " / Library / Caches / Java " ) ; <nl> @ @ - 290 , 6 + 341 , 9 @ @ public class WebStartTest extends TestCase { <nl> if ( runningWebStart ( ) ) { <nl> super . runBare ( ) ; <nl> } <nl> + else if ( Platform . isWindows ( ) & & Platform . is64Bit ( ) ) { <nl> + throw new Error ( " Web start launch not supported " ) ; <nl> + } <nl> else if ( ! GraphicsEnvironment . isHeadless ( ) ) { <nl> File policy = File . createTempFile ( getName ( ) , " . policy " ) ; <nl> OutputStream os = new FileOutputStream ( policy ) ;

TEST DIFF:
diff - - git a / native / dispatch . c b / native / dispatch . c 
 index 3712e12 . . 735370a 100644 
 - - - a / native / dispatch . c 
 + + + b / native / dispatch . c 
 @ @ - 16 , 6 + 16 , 10 @ @ 
 * Lesser General Public License for more details . 
 * / 
 
 + # include " dispatch . h " 
 + 
 + # include < string . h > 
 + 
 # if defined ( _ WIN32 ) 
 # define WIN32 _ LEAN _ AND _ MEAN 
 # include < windows . h > 
 @ @ - 45 , 6 + 49 , 7 @ @ 
 # else 
 # include < dlfcn . h > 
 # include < errno . h > 
 + # include < assert . h > 
 # define STRTYPE char * 
 # ifdef USE _ DEFAULT _ LIBNAME _ ENCODING 
 # define NAME2CSTR ( ENV , JSTR ) newCString ( ENV , JSTR ) 
 @ @ - 53 , 8 + 58 , 21 @ @ 
 # endif 
 # define DEFAULT _ LOAD _ OPTS ( RTLD _ LAZY | RTLD _ GLOBAL ) 
 # define LOAD _ LIBRARY ( NAME , OPTS ) dlopen ( NAME , OPTS ) 
 - # define LOAD _ ERROR ( BUF , LEN ) ( snprintf ( BUF , LEN , " % s " , dlerror ( ) ) , BUF ) 
 - # define STR _ ERROR ( CODE , BUF , LEN ) ( strerror _ r ( CODE , BUF , LEN ) , BUF ) 
 + static inline char * LOAD _ ERROR ( char * buf , size _ t len ) { 
 + const size _ t count = snprintf ( buf , len , " % s " , dlerror ( ) ) ; 
 + assert ( count < = len & & " snprintf ( ) output has been truncated " ) ; 
 + return buf ; 
 + } 
 + static inline char * STR _ ERROR ( int code , char * buf , size _ t len ) { 
 + / / The conversion will fail if code is not a valid error code . 
 + int err = strerror _ r ( code , buf , len ) ; 
 + if ( err ) 
 + / / Depending on glib version , " Unknown error " error code 
 + / / may be returned or passed using errno . 
 + err = strerror _ r ( err > 0 ? err : errno , buf , len ) ; 
 + assert ( err = = 0 & & " strerror _ r ( ) conversion has failed " ) ; 
 + return buf ; 
 + } 
 # define FREE _ LIBRARY ( HANDLE ) dlclose ( HANDLE ) 
 # define FIND _ ENTRY ( HANDLE , NAME ) dlsym ( HANDLE , NAME ) 
 # endif 
 @ @ - 67 , 16 + 85 , 10 @ @ 
 # endif 
 
 # include < stdlib . h > 
 - / / Force XSI - compliant strerror _ r ( http : / / unixhelp . ed . ac . uk / CGI / man - cgi ? strerror ) 
 - # ifndef _ XOPEN _ SOURCE 
 - # define _ XOPEN _ SOURCE 600 
 - # endif 
 - # include < string . h > 
 + # include < alloca . h > 
 # include < wchar . h > 
 # include < jni . h > 
 
 - # include " dispatch . h " 
 - 
 # ifndef NO _ JAWT 
 # include < jawt . h > 
 # include < jawt _ md . h > 
 diff - - git a / native / dispatch . h b / native / dispatch . h 
 index 824c3dd . . 9a5b9c0 100644 
 - - - a / native / dispatch . h 
 + + + b / native / dispatch . h 
 @ @ - 36 , 6 + 36 , 7 @ @ 
 # define GET _ LAST _ ERROR ( ) GetLastError ( ) 
 # define SET _ LAST _ ERROR ( CODE ) SetLastError ( CODE ) 
 # else 
 + # define _ XOPEN _ SOURCE 600 
 # define GET _ LAST _ ERROR ( ) errno 
 # define SET _ LAST _ ERROR ( CODE ) ( errno = ( CODE ) ) 
 # endif / * _ WIN32 * /

NEAREST DIFF:
diff - - git a / jnalib / native / Makefile b / jnalib / native / Makefile 
 index b5fff03 . . 8e4c8f9 100644 
 - - - a / jnalib / native / Makefile 
 + + + b / jnalib / native / Makefile 
 @ @ - 86 , 7 + 86 , 7 @ @ STRIP = strip - x 
 
 ifeq ( $ ( OS ) , win32 ) 
 ARCH = $ ( shell uname - m | sed ' s / i . 86 / i386 / g ' ) 
 - CDEFINES = - DHAVE _ PROTECTION 
 + CDEFINES = - DHAVE _ PROTECTION - DPSAPI _ VERSION = 1 
 LIBS = - lpsapi 
 WINDRES = windres 
 EXTRAOBJS = $ ( RSRC ) 
 @ @ - 116 , 6 + 116 , 8 @ @ else 
 # MSVC ( wrapper scripts ) 
 CC = $ ( FFI _ SRC ) / . . / cc . sh - m64 
 LD = $ ( FFI _ SRC ) / . . / ld . sh - m64 
 + COPT = 
 + LIBS = psapi . lib 
 ARSFX = . lib 
 FFI _ CONFIG + = - - host = x86 _ 64 - pc - mingw32 & & rm - f include / ffitarget . h & & cp $ ( FFI _ SRC ) / include / * . h $ ( FFI _ SRC ) / src / x86 / ffitarget . h include 
 FFI _ ENV + = LD = " $ ( LD ) " CPP = cpp 
 diff - - git a / jnalib / native / callback . c b / jnalib / native / callback . c 
 index a90368d . . 45d9678 100644 
 - - - a / jnalib / native / callback . c 
 + + + b / jnalib / native / callback . c 
 @ @ - 45 , 7 + 45 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 ffi _ status status ; 
 jsize argc ; 
 JavaVM * vm ; 
 - char rtype ; 
 + int rtype ; 
 char msg [ 64 ] ; 
 int i ; 
 int cvt = 0 ; 
 @ @ - 81 , 27 + 81 , 28 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 cvt = 1 ; 
 } 
 
 - cb - > arg _ jtypes [ i ] = jtype = get _ jtype ( env , cls ) ; 
 + jtype = get _ jtype ( env , cls ) ; 
 if ( jtype = = - 1 ) { 
 snprintf ( msg , sizeof ( msg ) , " Unsupported argument at index % d " , i ) ; 
 throw _ type = EIllegalArgument ; 
 throw _ msg = msg ; 
 goto failure _ cleanup ; 
 } 
 - 
 + cb - > arg _ jtypes [ i ] = ( char ) jtype ; 
 cb - > java _ arg _ types [ i + 3 ] = cb - > arg _ types [ i ] = get _ ffi _ type ( env , cls , cb - > arg _ jtypes [ i ] ) ; 
 if ( cb - > flags [ i ] = = CVT _ NATIVE _ MAPPED 
 | | cb - > flags [ i ] = = CVT _ POINTER _ TYPE 
 | | cb - > flags [ i ] = = CVT _ INTEGER _ TYPE ) { 
 jclass ncls ; 
 ncls = getNativeType ( env , cls ) ; 
 - cb - > arg _ jtypes [ i ] = jtype = get _ jtype ( env , ncls ) ; 
 + jtype = get _ jtype ( env , ncls ) ; 
 if ( jtype = = - 1 ) { 
 snprintf ( msg , sizeof ( msg ) , " Unsupported NativeMapped argument native type at argument % d " , i ) ; 
 throw _ type = EIllegalArgument ; 
 throw _ msg = msg ; 
 goto failure _ cleanup ; 
 } 
 + cb - > arg _ jtypes [ i ] = ( char ) jtype ; 
 cb - > java _ arg _ types [ i + 3 ] = & ffi _ type _ pointer ; 
 cb - > arg _ types [ i ] = get _ ffi _ type ( env , ncls , cb - > arg _ jtypes [ i ] ) ; 
 } 
 @ @ - 140 , 12 + 141 , 12 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 # endif / / _ WIN32 
 
 rtype = get _ jtype ( env , return _ type ) ; 
 - if ( ! rtype ) { 
 + if ( rtype = = - 1 ) { 
 throw _ type = EIllegalArgument ; 
 throw _ msg = " Unsupported return type " ; 
 goto failure _ cleanup ; 
 } 
 - ffi _ rtype = get _ ffi _ rtype ( env , return _ type , rtype ) ; 
 + ffi _ rtype = get _ ffi _ rtype ( env , return _ type , ( char ) rtype ) ; 
 if ( ! ffi _ rtype ) { 
 throw _ type = EIllegalArgument ; 
 throw _ msg = " Error in return type " ; 
 @ @ - 252 , 7 + 253 , 7 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar 
 else if ( cb - > direct ) { 
 unsigned int i ; 
 void * * args = alloca ( ( cif - > nargs + 3 ) * sizeof ( void * ) ) ; 
 - args [ 0 ] = & env ; 
 + args [ 0 ] = ( void * ) & env ; 
 args [ 1 ] = & self ; 
 args [ 2 ] = & cb - > methodID ; 
 memcpy ( & args [ 3 ] , cbargs , cif - > nargs * sizeof ( void * ) ) ; 
 diff - - git a / jnalib / native / cc . sh b / jnalib / native / cc . sh 
 index b39b8f5 . . 554e88f 100755 
 - - - a / jnalib / native / cc . sh 
 + + + b / jnalib / native / cc . sh 
 @ @ - 41 , 7 + 41 , 7 @ @ do 
 shift 1 
 ; ; 
 - O * ) 
 - args = " $ args / O1 " 
 + args = " $ args $ i " 
 shift 1 
 ; ; 
 - g ) 
 diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c 
 index aa978c8 . . ce31cce 100644 
 - - - a / jnalib / native / dispatch . c 
 + + + b / jnalib / native / dispatch . c 
 @ @ - 22 , 6 + 22 , 9 @ @ 
 * / 
 
 # if defined ( _ WIN32 ) 
 + # ifdef _ MSC _ VER 
 + # pragma warning ( disable : 4201 ) / * nameless struct / union ( jni _ md . h ) * / 
 + # endif 
 # ifndef UNICODE 
 # define UNICODE 
 # endif 
 @ @ - 1376 , 9 + 1379 , 11 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Memory _ free 
 void 
 throwByName ( JNIEnv * env , const char * name , const char * msg ) 
 { 
 + jclass cls ; 
 + 
 ( * env ) - > ExceptionClear ( env ) ; 
 
 - jclass cls = ( * env ) - > FindClass ( env , name ) ; 
 + cls = ( * env ) - > FindClass ( env , name ) ; 
 
 if ( cls ! = NULL ) { / * Otherwise an exception has already been thrown * / 
 ( * env ) - > ThrowNew ( env , cls , msg ) ; 
 @ @ - 1749 , 8 + 1754 , 8 @ @ toNativeTypeMapped ( JNIEnv * env , jobject obj , void * valuep , size _ t size , jobject 
 
 static void 
 fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , void * resp , ffi _ type * type , jclass javaClass , void * result ) { 
 - char jtype = get _ jtype _ from _ ffi _ type ( type ) ; 
 - jobject value = new _ object ( env , jtype , resp , JNI _ TRUE ) ; 
 + int jtype = get _ jtype _ from _ ffi _ type ( type ) ; 
 + jobject value = new _ object ( env , ( char ) jtype , resp , JNI _ TRUE ) ; 
 jobject obj = ( * env ) - > CallStaticObjectMethod ( env , classNative , 
 MID _ Native _ fromNativeTypeMapped , 
 from _ native , value , javaClass ) ; 
 @ @ - 1763 , 7 + 1768 , 7 @ @ fromNativeTypeMapped ( JNIEnv * env , jobject from _ native , void * resp , ffi _ type * typ 
 jobject 
 fromNative ( JNIEnv * env , jclass javaClass , ffi _ type * type , void * resp , jboolean promote ) { 
 int jtype = get _ jtype _ from _ ffi _ type ( type ) ; 
 - jobject value = new _ object ( env , jtype , resp , promote ) ; 
 + jobject value = new _ object ( env , ( char ) jtype , resp , promote ) ; 
 return ( * env ) - > CallStaticObjectMethod ( env , classNative , 
 MID _ Native _ fromNative , 
 javaClass , value ) ; 
 @ @ - 1792 , 7 + 1797 , 7 @ @ getArrayComponentType ( JNIEnv * env , jobject obj ) { 
 jclass cls = ( * env ) - > GetObjectClass ( env , obj ) ; 
 jclass type = ( * env ) - > CallObjectMethod ( env , cls , MID _ Class _ getComponentType ) ; 
 if ( type ! = NULL ) { 
 - return get _ jtype ( env , type ) ; 
 + return ( char ) get _ jtype ( env , type ) ; 
 } 
 return 0 ; 
 } 
 @ @ - 2567 , 7 + 2572 , 6 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { 
 void * * args = argp + 2 ; 
 void * * volatile objects = NULL ; 
 release _ t * volatile release = NULL ; 
 - char * volatile array _ types = NULL ; 
 void * * volatile elems = NULL ; 
 unsigned i ; 
 void * oldresp = resp ; 
 @ @ - 2604 , 9 + 2608 , 10 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { 
 case CVT _ TYPE _ MAPPER : 
 { 
 void * valuep = args [ i ] ; 
 - char jtype = get _ jtype _ from _ ffi _ type ( data - > closure _ cif . arg _ types [ i + 2 ] ) ; 
 + int jtype = get _ jtype _ from _ ffi _ type ( data - > closure _ cif . arg _ types [ i + 2 ] ) ; 
 jobject obj = jtype = = ' * ' 
 - ? * ( void * * ) valuep : new _ object ( env , jtype , valuep , JNI _ FALSE ) ; 
 + ? * ( void * * ) valuep 
 + : new _ object ( env , ( char ) jtype , valuep , JNI _ FALSE ) ; 
 if ( cif - > arg _ types [ i + 2 ] - > size < data - > cif . arg _ types [ i ] - > size ) { 
 args [ i ] = alloca ( data - > cif . arg _ types [ i ] - > size ) ; 
 } 
 @ @ - 2827 , 7 + 2832 , 6 @ @ Java _ com _ sun _ jna _ Native _ registerMethod ( JNIEnv * env , jclass ncls , 
 int status ; 
 int i ; 
 int abi = FFI _ DEFAULT _ ABI ; 
 - char * tmp , msg [ 256 ] ; 
 ffi _ type * rtype = ( ffi _ type * ) L2A ( return _ type ) ; 
 ffi _ type * closure _ rtype = ( ffi _ type * ) L2A ( closure _ return _ type ) ; 
 jlong * types = atypes ? ( * env ) - > GetLongArrayElements ( env , atypes , NULL ) : NULL ; 
 @ @ - 2886 , 7 + 2890 , 7 @ @ Java _ com _ sun _ jna _ Native _ registerMethod ( JNIEnv * env , jclass ncls , 
 } 
 
 { 
 - JNINativeMethod m = { ( char * ) cname , ( char * ) sig , code } ; 
 + JNINativeMethod m = { ( char * ) cname , ( char * ) sig , code } ; 
 ( * env ) - > RegisterNatives ( env , cls , & m , 1 ) ; 
 } 
 
 @ @ - 2997 , 12 + 3001 , 11 @ @ JNIEXPORT jint JNICALL 
 Java _ com _ sun _ jna _ Native _ initialize _ 1ffi _ 1type ( JNIEnv * env , jclass cls , jlong type _ info ) { 
 ffi _ type * type = L2A ( type _ info ) ; 
 ffi _ cif cif ; 
 - ffi _ type * atypes [ ] = { } ; 
 - ffi _ status status = ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 0 , type , atypes ) ; 
 + ffi _ status status = ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 0 , type , NULL ) ; 
 if ( ffi _ error ( env , " ffi _ prep _ cif " , status ) ) { 
 return 0 ; 
 } 
 - return type - > size ; 
 + return ( jint ) type - > size ; 
 } 
 
 # ifdef _ _ cplusplus 
 diff - - git a / jnalib / native / dispatch . h b / jnalib / native / dispatch . h 
 index 19bfd64 . . 77bacb3 100644 
 - - - a / jnalib / native / dispatch . h 
 + + + b / jnalib / native / dispatch . h 
 @ @ - 22 , 6 + 22 , 11 @ @ 
 # ifdef _ WIN32 
 # ifdef _ MSC _ VER 
 # define alloca _ alloca 
 + # pragma warning ( disable : 4152 ) / * function / data conversion * / 
 + # pragma warning ( disable : 4054 ) / * cast function pointer to data pointer * / 
 + # pragma warning ( disable : 4055 ) / * cast data pointer to function pointer * / 
 + # pragma warning ( disable : 4204 ) / * structure initializer * / 
 + # pragma warning ( disable : 4710 ) / * swprintf not inlined * / 
 # else 
 # include < malloc . h > 
 # endif / * _ MSC _ VER * / 
 diff - - git a / jnalib / test / com / sun / jna / WebStartTest . java b / jnalib / test / com / sun / jna / WebStartTest . java 
 index e15a672 . . 71001f6 100644 
 - - - a / jnalib / test / com / sun / jna / WebStartTest . java 
 + + + b / jnalib / test / com / sun / jna / WebStartTest . java 
 @ @ - 136 , 20 + 136 , 7 @ @ public class WebStartTest extends TestCase { 
 os . write ( contents . getBytes ( ) ) ; 
 os . close ( ) ; 
 File keystore = new File ( " jna . keystore " ) ; 
 - String JAVA _ HOME = System . getProperty ( " java . home " ) ; 
 - String LIB = new File ( JAVA _ HOME , " / lib " ) . getAbsolutePath ( ) ; 
 - if ( ! new File ( LIB , " javaws . jar " ) . exists ( ) ) { 
 - LIB = new File ( " / System / Library / Frameworks / JavaVM . framework / Resources / Deploy . bundle / Contents / Home / lib " ) . getAbsolutePath ( ) ; 
 - if ( ! new File ( LIB , " javaws . jar " ) . exists ( ) ) { 
 - throw new IOException ( " javaws . jar not found " ) ; 
 - } 
 - } 
 - String PS = System . getProperty ( " path . separator " ) ; 
 - String path = System . getProperty ( " java . home " ) + " / bin / javaws " ; 
 - if ( Platform . isWindows ( ) ) path + = " . exe " ; 
 - File javaws = new File ( path ) ; 
 - / / NOTE : OSX puts javaws somewhere else entirely 
 - if ( ! javaws . exists ( ) ) path = " javaws " ; 
 + String path = findJWS ( ) ; 
 String [ ] cmd = { 
 path , 
 " - Xnosplash " , 
 @ @ - 259 , 16 + 246 , 80 @ @ public class WebStartTest extends TestCase { 
 } 
 } 
 
 + public interface FolderInfo extends com . sun . jna . win32 . StdCallLibrary { 
 + int MAX _ PATH = 260 ; 
 + int SHGFP _ TYPE _ CURRENT = 0 ; 
 + int SHGFP _ TYPE _ DEFAULT = 1 ; 
 + int CSIDL _ APPDATA = 26 ; 
 + int CSIDL _ WINDOWS = 36 ; 
 + int SHGetFolderPathW ( Pointer owner , int folder , Pointer token , 
 + int flags , char [ ] path ) ; 
 + } 
 + 
 + private String findJWS ( ) throws IOException { 
 + String JAVA _ HOME = System . getProperty ( " java . home " ) ; 
 + String LIB = new File ( JAVA _ HOME , " / lib " ) . getAbsolutePath ( ) ; 
 + if ( ! new File ( LIB , " javaws . jar " ) . exists ( ) ) { 
 + LIB = new File ( " / System / Library / Frameworks / JavaVM . framework / Resources / Deploy . bundle / Contents / Home / lib " ) . getAbsolutePath ( ) ; 
 + if ( ! new File ( LIB , " javaws . jar " ) . exists ( ) ) { 
 + if ( ! Platform . isWindows ( ) ) 
 + throw new IOException ( " javaws . jar not found " ) ; 
 + } 
 + } 
 + String PS = System . getProperty ( " path . separator " ) ; 
 + String path = System . getProperty ( " java . home " ) + " / bin / javaws " ; 
 + File javaws = new File ( path ) ; 
 + / / NOTE : OSX puts javaws somewhere else entirely 
 + / / NOTE : win64 only includes javaws in the system path 
 + if ( ! javaws . exists ( ) ) { 
 + if ( Platform . isWindows ( ) ) { 
 + FolderInfo info = ( FolderInfo ) 
 + Native . loadLibrary ( " shell32 " , FolderInfo . class ) ; 
 + char [ ] buf = new char [ FolderInfo . MAX _ PATH ] ; 
 + int flags = 0 ; 
 + int result = info . SHGetFolderPathW ( null , FolderInfo . CSIDL _ WINDOWS , null , 0 , buf ) ; 
 + path = Native . toString ( buf ) ; 
 + if ( Platform . is64Bit ( ) ) { 
 + javaws = new File ( path , " SysWOW64 / javaws . exe " ) ; 
 + } 
 + else { 
 + javaws = new File ( path , " system32 / javaws . exe " ) ; 
 + } 
 + path = javaws . getAbsolutePath ( ) ; 
 + } 
 + else { 
 + path = javaws . getName ( ) ; 
 + } 
 + } 
 + return path ; 
 + } 
 + 
 private File findDeploymentProperties ( ) { 
 String path = System . getProperty ( " user . home " ) ; 
 File deployment ; 
 if ( Platform . isWindows ( ) ) { 
 + FolderInfo info = ( FolderInfo ) 
 + Native . loadLibrary ( " shell32 " , FolderInfo . class ) ; 
 + char [ ] buf = new char [ FolderInfo . MAX _ PATH ] ; 
 + int flags = 0 ; 
 + int result = info . SHGetFolderPathW ( null , FolderInfo . CSIDL _ APPDATA , 
 + null , 0 , buf ) ; 
 + path = Native . toString ( buf ) ; 
 + 
 / / NOTE : works for Sun and IBM , may not work for others 
 String vendor = System . getProperty ( " java . vm . vendor " ) ; 
 if ( vendor . indexOf ( " " ) ! = - 1 ) { 
 vendor = vendor . substring ( 0 , vendor . indexOf ( " " ) ) ; 
 } 
 - deployment = new File ( path + " / Application Data / " + vendor + " / Java / Deployment " ) ; 
 + deployment = new File ( path + " / " + vendor + " / Java / Deployment " ) ; 
 + if ( ! deployment . exists ( ) 
 + & & deployment . getAbsolutePath ( ) . indexOf ( " Roaming " ) ! = - 1 ) { 
 + deployment = new File ( deployment . getAbsolutePath ( ) . replace ( " Roaming " , " LocalLow " ) ) ; 
 + if ( ! deployment . exists ( ) ) { 
 + deployment = new File ( deployment . getAbsolutePath ( ) . replace ( " LocalLow " , " Local " ) ) ; 
 + } 
 + } 
 + 
 } 
 else if ( Platform . isMac ( ) ) { 
 deployment = new File ( path + " / Library / Caches / Java " ) ; 
 @ @ - 290 , 6 + 341 , 9 @ @ public class WebStartTest extends TestCase { 
 if ( runningWebStart ( ) ) { 
 super . runBare ( ) ; 
 } 
 + else if ( Platform . isWindows ( ) & & Platform . is64Bit ( ) ) { 
 + throw new Error ( " Web start launch not supported " ) ; 
 + } 
 else if ( ! GraphicsEnvironment . isHeadless ( ) ) { 
 File policy = File . createTempFile ( getName ( ) , " . policy " ) ; 
 OutputStream os = new FileOutputStream ( policy ) ;
