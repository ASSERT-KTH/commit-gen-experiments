BLEU SCORE: 0.05341087579952926

TEST MSG: Document the IUnknown methods too
GENERATED MSG: Add documentation to IEnumIDList

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / IEnumIDList . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / IEnumIDList . java <nl> index 0f83cb0 . . 7082d17 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / IEnumIDList . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / IEnumIDList . java <nl> @ @ - 18 , 17 + 18 , 89 @ @ import com . sun . jna . ptr . PointerByReference ; <nl> public interface IEnumIDList { <nl> <nl> / * * <nl> - * The Constant IID _ IDispatch . <nl> + * The interface IID for QueryInterface et al <nl> * / <nl> public final static IID IID _ IEnumIDList = new IID ( <nl> " { 000214F2 - 0000 - 0000 - C000 - 000000000046 } " ) ; <nl> <nl> + / * * <nl> + * <nl> + * Retrieves pointers to the supported interfaces on an object . <nl> + * This method calls IUnknown : : AddRef on the pointer it returns . <nl> + * <nl> + * @ param riid <nl> + * The identifier of the interface being requested . <nl> + * <nl> + * @ param ppvObject <nl> + * The address of a pointer variable that receives the interface pointer requested in the riid parameter . Upon successful <nl> + * return , * ppvObject contains the requested interface pointer to the object . If the object does not support the <nl> + * interface , * ppvObject is set to NULL . <nl> + * <nl> + * @ return <nl> + * This method returns S _ OK if the interface is supported , and E _ NOINTERFACE otherwise . If ppvObject is NULL , this method returns E _ POINTER . <nl> + * For any one object , a specific query for the IUnknown interface on any of the object ' s interfaces must always return the same pointer value . <nl> + * This enables a client to determine whether two pointers point to the same component by calling QueryInterfacewith IID _ IUnknown <nl> + * and comparing the results . It is specifically not the case that queries for interfaces other than IUnknown ( even the same interface <nl> + * through the same pointer ) must return the same pointer value . <nl> + * <nl> + * There are four requirements for implementations of QueryInterface ( In these cases , " must succeed " means " must succeed barring <nl> + * catastrophic failure . " ) : <nl> + * The set of interfaces accessible on an object through QueryInterface must be static , not dynamic . This means that if a call <nl> + * toQueryInterface for a pointer to a specified interface succeeds the first time , it must succeed again , and if it fails <nl> + * the first time , it must fail on all subsequent queries . <nl> <nl> + * <nl> + * It must be reflexive : if a client holds a pointer to an interface on an object , and queries for that interface , the call must succeed . <nl> <nl> + * <nl> + * It must be symmetric : if a client holding a pointer to one interface queries successfully for another , a query through <nl> + * the obtained pointer for the first interface must succeed . <nl> <nl> + * <nl> + * It must be transitive : if a client holding a pointer to one interface queries successfully for a second , and through that <nl> + * pointer queries successfully for a third interface , a query for the first interface through the pointer for the <nl> + * third interface must succeed . <nl> <nl> + * Notes to Implementers <nl> + * Implementations of QueryInterface must never check ACLs . The main reason for this rule is that COM requires that an object supporting a <nl> + * particular interface always return success when queried for that interface . Another reason is that checking ACLs on QueryInterface <nl> + * does not provide any real security because any client who has access to a particular interface can hand it directly to another <nl> + * client without any calls back to the server . Also , because COM caches interface pointers , it does not callQueryInterface on <nl> + * the server every time a client does a query . <nl> + * / <nl> HRESULT QueryInterface ( <nl> Guid . GUID . ByReference riid , <nl> PointerByReference ppvObject ) ; <nl> <nl> + / * * <nl> + * <nl> + * Increments the reference count for an interface on an object . This method should be called for every new copy of a pointer to an interface on an object . <nl> + * @ return <nl> + * The method returns the new reference count . This value is intended to be used only for test purposes . <nl> + * <nl> + * Objects use a reference counting mechanism to ensure that the lifetime of the object includes the lifetime of references to it . You use AddRef <nl> + * to stabilize a copy of an interface pointer . It can also be called when the life of a cloned pointer must extend beyond the <nl> + * lifetime of the original pointer . The cloned pointer must be released by calling IUnknown : : Release . <nl> + * <nl> + * The internal reference counter that AddRef maintains should be a 32 - bit unsigned integer . <nl> + * Notes to Callers <nl> + * Call this method for every new copy of an interface pointer that you make . For example , if you are passing a copy of a pointer <nl> + * back from a method , you must call AddRef on that pointer . You must also call AddRef on a pointer before passing it as an in - out <nl> + * parameter to a method ; the method will call IUnknown : : Release before copying the out - value on top of it . <nl> + * / <nl> int AddRef ( ) ; <nl> <nl> + / * * <nl> + * Decrements the reference count for an interface on an object . <nl> + * <nl> + * @ return <nl> + * The method returns the new reference count . This value is intended to be used only for test purposes . <nl> + * <nl> + * When the reference count on an object reaches zero , Release must cause the interface pointer to free itself . When the released <nl> + * pointer is the only existing reference to an object ( whether the object supports single or multiple interfaces ) , the <nl> + * implementation must free the object . <nl> + * <nl> + * Note that aggregation of objects restricts the ability to recover interface pointers . <nl> + * Notes to Callers <nl> + * Call this method when you no longer need to use an interface pointer . If you are writing a method that takes an in - out <nl> + * parameter , call Release on the pointer you are passing in before copying the out - value on top of it . <nl> + * / <nl> int Release ( ) ; <nl> <nl> / *
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / IEnumIDList . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / IEnumIDList . java 
 index 0f83cb0 . . 7082d17 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / IEnumIDList . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / IEnumIDList . java 
 @ @ - 18 , 17 + 18 , 89 @ @ import com . sun . jna . ptr . PointerByReference ; 
 public interface IEnumIDList { 
 
 / * * 
 - * The Constant IID _ IDispatch . 
 + * The interface IID for QueryInterface et al 
 * / 
 public final static IID IID _ IEnumIDList = new IID ( 
 " { 000214F2 - 0000 - 0000 - C000 - 000000000046 } " ) ; 
 
 + / * * 
 + * 
 + * Retrieves pointers to the supported interfaces on an object . 
 + * This method calls IUnknown : : AddRef on the pointer it returns . 
 + * 
 + * @ param riid 
 + * The identifier of the interface being requested . 
 + * 
 + * @ param ppvObject 
 + * The address of a pointer variable that receives the interface pointer requested in the riid parameter . Upon successful 
 + * return , * ppvObject contains the requested interface pointer to the object . If the object does not support the 
 + * interface , * ppvObject is set to NULL . 
 + * 
 + * @ return 
 + * This method returns S _ OK if the interface is supported , and E _ NOINTERFACE otherwise . If ppvObject is NULL , this method returns E _ POINTER . 
 + * For any one object , a specific query for the IUnknown interface on any of the object ' s interfaces must always return the same pointer value . 
 + * This enables a client to determine whether two pointers point to the same component by calling QueryInterfacewith IID _ IUnknown 
 + * and comparing the results . It is specifically not the case that queries for interfaces other than IUnknown ( even the same interface 
 + * through the same pointer ) must return the same pointer value . 
 + * 
 + * There are four requirements for implementations of QueryInterface ( In these cases , " must succeed " means " must succeed barring 
 + * catastrophic failure . " ) : 
 + * The set of interfaces accessible on an object through QueryInterface must be static , not dynamic . This means that if a call 
 + * toQueryInterface for a pointer to a specified interface succeeds the first time , it must succeed again , and if it fails 
 + * the first time , it must fail on all subsequent queries . 
 
 + * 
 + * It must be reflexive : if a client holds a pointer to an interface on an object , and queries for that interface , the call must succeed . 
 
 + * 
 + * It must be symmetric : if a client holding a pointer to one interface queries successfully for another , a query through 
 + * the obtained pointer for the first interface must succeed . 
 
 + * 
 + * It must be transitive : if a client holding a pointer to one interface queries successfully for a second , and through that 
 + * pointer queries successfully for a third interface , a query for the first interface through the pointer for the 
 + * third interface must succeed . 
 
 + * Notes to Implementers 
 + * Implementations of QueryInterface must never check ACLs . The main reason for this rule is that COM requires that an object supporting a 
 + * particular interface always return success when queried for that interface . Another reason is that checking ACLs on QueryInterface 
 + * does not provide any real security because any client who has access to a particular interface can hand it directly to another 
 + * client without any calls back to the server . Also , because COM caches interface pointers , it does not callQueryInterface on 
 + * the server every time a client does a query . 
 + * / 
 HRESULT QueryInterface ( 
 Guid . GUID . ByReference riid , 
 PointerByReference ppvObject ) ; 
 
 + / * * 
 + * 
 + * Increments the reference count for an interface on an object . This method should be called for every new copy of a pointer to an interface on an object . 
 + * @ return 
 + * The method returns the new reference count . This value is intended to be used only for test purposes . 
 + * 
 + * Objects use a reference counting mechanism to ensure that the lifetime of the object includes the lifetime of references to it . You use AddRef 
 + * to stabilize a copy of an interface pointer . It can also be called when the life of a cloned pointer must extend beyond the 
 + * lifetime of the original pointer . The cloned pointer must be released by calling IUnknown : : Release . 
 + * 
 + * The internal reference counter that AddRef maintains should be a 32 - bit unsigned integer . 
 + * Notes to Callers 
 + * Call this method for every new copy of an interface pointer that you make . For example , if you are passing a copy of a pointer 
 + * back from a method , you must call AddRef on that pointer . You must also call AddRef on a pointer before passing it as an in - out 
 + * parameter to a method ; the method will call IUnknown : : Release before copying the out - value on top of it . 
 + * / 
 int AddRef ( ) ; 
 
 + / * * 
 + * Decrements the reference count for an interface on an object . 
 + * 
 + * @ return 
 + * The method returns the new reference count . This value is intended to be used only for test purposes . 
 + * 
 + * When the reference count on an object reaches zero , Release must cause the interface pointer to free itself . When the released 
 + * pointer is the only existing reference to an object ( whether the object supports single or multiple interfaces ) , the 
 + * implementation must free the object . 
 + * 
 + * Note that aggregation of objects restricts the ability to recover interface pointers . 
 + * Notes to Callers 
 + * Call this method when you no longer need to use an interface pointer . If you are writing a method that takes an in - out 
 + * parameter , call Release on the pointer you are passing in before copying the out - value on top of it . 
 + * / 
 int Release ( ) ; 
 
 / *

NEAREST DIFF:
ELIMINATEDSENTENCE
