BLEU SCORE: 0.05341087579952926

TEST MSG: Remove redundant assignments in Advapi32Util
GENERATED MSG: Documented EVENTLOGRECORD .

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> index abe114c . . d8d410b 100755 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> @ @ - 214 , 7 + 214 , 6 @ @ public abstract class Advapi32Util { <nl> <nl> 	 	 Account account = new Account ( ) ; <nl> 	 	 account . accountType = peUse . getPointer ( ) . getInt ( 0 ) ; <nl> - 	 	 account . name = accountName ; <nl> <nl> 	 	 String [ ] accountNamePartsBs = accountName . split ( " \ \ \ \ " , 2 ) ; <nl> 	 	 String [ ] accountNamePartsAt = accountName . split ( " @ " , 2 ) ; <nl> @ @ - 459 , 7 + 458 , 7 @ @ public abstract class Advapi32Util { <nl> 	 	 ArrayList < Account > userGroups = new ArrayList < Account > ( ) ; <nl> 	 	 / / make array of names <nl> 	 	 for ( SID _ AND _ ATTRIBUTES sidAndAttribute : groups . getGroups ( ) ) { <nl> - 	 	 	 Account group = null ; <nl> + 	 	 	 Account group ; <nl> 	 	 	 try { <nl> 	 	 	 	 group = Advapi32Util . getAccountBySid ( sidAndAttribute . Sid ) ; <nl> 	 	 	 } catch ( Exception e ) { <nl> @ @ - 2329 , 7 + 2328 , 7 @ @ public abstract class Advapi32Util { <nl> 	 * An event log record . <nl> 	 * / <nl> 	 public static class EventLogRecord { <nl> - 	 	 private EVENTLOGRECORD _ record = null ; <nl> + 	 	 private EVENTLOGRECORD _ record ; <nl> 	 	 private String _ source ; <nl> 	 	 private byte [ ] _ data ; <nl> 	 	 private String [ ] _ strings ; <nl> @ @ - 2463 , 14 + 2462 , 14 @ @ public abstract class Advapi32Util { <nl> 	 public static class EventLogIterator implements Iterable < EventLogRecord > , <nl> 	 	 	 Iterator < EventLogRecord > { <nl> <nl> - 	 	 private HANDLE _ h = null ; <nl> + 	 	 private HANDLE _ h ; <nl> 	 	 private Memory _ buffer = new Memory ( 1024 * 64 ) ; / / memory buffer to <nl> 	 	 	 	 	 	 	 	 	 	 	 	 	 	 / / store events <nl> 	 	 private boolean _ done = false ; / / no more events <nl> 	 	 private int _ dwRead = 0 ; / / number of bytes remaining in the current <nl> 	 	 	 	 	 	 	 	 	 / / buffer <nl> 	 	 private Pointer _ pevlr = null ; / / pointer to the current record <nl> - 	 	 private int _ flags = WinNT . EVENTLOG _ FORWARDS _ READ ; <nl> + 	 	 private int _ flags ; <nl> <nl> 	 	 public EventLogIterator ( String sourceName ) { <nl> 	 	 	 this ( null , sourceName , WinNT . EVENTLOG _ FORWARDS _ READ ) ; <nl> @ @ - 2582 , 8 + 2581 , 8 @ @ public abstract class Advapi32Util { <nl> 	 	 	 boolean compact ) { <nl> 	 	 int infoType = WinNT . DACL _ SECURITY _ INFORMATION ; <nl> 	 	 int nLength = 1024 ; <nl> - 	 	 boolean repeat = false ; <nl> - 	 	 Memory memory = null ; <nl> + 	 	 boolean repeat ; <nl> + 	 	 Memory memory ; <nl> <nl> 	 	 do { <nl> 	 	 	 repeat = false ; <nl> @ @ - 2934 , 7 + 2933 , 7 @ @ public abstract class Advapi32Util { <nl> * / <nl> public static SECURITY _ DESCRIPTOR _ RELATIVE getFileSecurityDescriptor ( File file , boolean getSACL ) <nl> { <nl> - 	 SECURITY _ DESCRIPTOR _ RELATIVE sdr = null ; <nl> + 	 SECURITY _ DESCRIPTOR _ RELATIVE sdr ; <nl> 	 Memory securityDesc = getSecurityDescriptorForObject ( file . getAbsolutePath ( ) . replaceAll ( " / " , " \ \ " ) , AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , getSACL ) ; <nl> 	 sdr = new SECURITY _ DESCRIPTOR _ RELATIVE ( securityDesc ) ; <nl> 	 return sdr ;
NEAREST DIFF (one line): diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> index 03ece2a . . 4681ed9 100644 <nl> - - - a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> @ @ - 10 , 7 + 10 , 7 @ @ <nl> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> * Lesser General Public License for more details . <nl> * / <nl> - package com . sun . jna . platform . win32 ; <nl> + package com . sun . jna . platform . win32 ; <nl> <nl> import com . sun . jna . Native ; <nl> import com . sun . jna . Pointer ; <nl> @ @ - 22 , 6 + 22 , 10 @ @ import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; <nl> import com . sun . jna . platform . win32 . WinNT . SECURITY _ ATTRIBUTES ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEY ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> + import com . sun . jna . platform . win32 . Winsvc . SC _ HANDLE ; <nl> + import com . sun . jna . platform . win32 . Winsvc . SC _ STATUS _ TYPE ; <nl> + import com . sun . jna . platform . win32 . Winsvc . SERVICE _ STATUS ; <nl> + import com . sun . jna . platform . win32 . Winsvc . SERVICE _ STATUS _ PROCESS ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> import com . sun . jna . ptr . PointerByReference ; <nl> import com . sun . jna . win32 . StdCallLibrary ; <nl> @ @ - 657 , 7 + 661 , 8 @ @ public interface Advapi32 extends StdCallLibrary { <nl> 	 	 	 IntByReference lpcMaxValueNameLen , IntByReference lpcMaxValueLen , <nl> 	 	 	 IntByReference lpcbSecurityDescriptor , <nl> 	 	 	 WinBase . FILETIME lpftLastWriteTime ) ; <nl> - <nl> + 	 	 	 <nl> + 	 	 	 <nl> 	 / * * <nl> 	 * Retrieves a registered handle to the specified event log . <nl> 	 * @ param lpUNCServerName <nl> @ @ - 839 , 4 + 844 , 169 @ @ public interface Advapi32 extends StdCallLibrary { <nl> 	 * If the function fails , the return value is zero . To get extended error information , call GetLastError . <nl> 	 * / <nl> 	 public boolean GetOldestEventLogRecord ( HANDLE hEventLog , IntByReference OldestRecord ) ; <nl> + 	 <nl> + 	 / * * <nl> + 	 * Retrieves the current status of the specified service based on the specified information level . <nl> + 	 * @ param hService <nl> + 	 * 	 A handle to the service . This handle is returned by the <nl> + 	 * OpenService ( SC _ HANDLE , String , int ) or @ link # CreateService ( ) function , and <nl> + 	 * it must have the SERVICE _ QUERY _ STATUS access right . For more information , see <nl> + 	 * < a href = " http : / / msdn . microsoft . com / en - us / library / ms685981 . aspx " > Service Security and Access Rights < / a > . <nl> + 	 * @ param InfoLevel <nl> + 	 * The service attributes to be returned ( a value from { @ link SC _ STATUS _ TYPE } enumeration ) . <nl> + 	 * Use SC _ STATUS _ PROCESS _ INFO to retrieve the service status information . The lpBuffer <nl> + 	 * parameter is a pointer to a SERVICE _ STATUS _ PROCESS structure . <nl> + 	 * Currently , no other information levels are defined . <nl> + 	 * @ param lpBuffer ( optional ) <nl> + 	 * A pointer to the buffer that receives the status information . The format of this data <nl> + 	 * depends on the value of the InfoLevel parameter . <nl> + 	 * The maximum size of this array is 8K bytes . To determine the required size , specify NULL <nl> + 	 * for this parameter and 0 for the cbBufSize parameter . The function will fail and GetLastError <nl> + 	 * will return ERROR _ INSUFFICIENT _ BUFFER . The pcbBytesNeeded parameter will receive the required size . <nl> + 	 * @ param cbBufSize <nl> + 	 * The size of the buffer pointed to by the lpBuffer parameter , in bytes . <nl> + 	 * @ param pcbBytesNeeded <nl> + 	 * A pointer to a variable that receives the number of bytes needed to store all status <nl> + 	 * information , if the function fails with ERROR _ INSUFFICIENT _ BUFFER . <nl> + 	 * @ return <nl> + 	 * If the function succeeds , the return value is true . <nl> + 	 * If the function fails , the return value is false . To get extended error information , <nl> + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . <nl> + 	 * / <nl> + 	 public boolean QueryServiceStatusEx ( SC _ HANDLE hService , int InfoLevel , <nl> + 	 	 	 SERVICE _ STATUS _ PROCESS lpBuffer , int cbBufSize , IntByReference pcbBytesNeeded ) ; <nl> + 	 <nl> + 	 / * * <nl> + 	 * Sends a control code to a service . <nl> + 	 * To specify additional information when stopping a service , use the <nl> + 	 * ControlServiceEx function . <nl> + 	 * @ param hService <nl> + 	 * A handle to the service . This handle is returned by the <nl> + 	 * OpenService ( SC _ HANDLE , String , int ) or CreateService ( ) <nl> + 	 * function . The access rights required for this handle depend on the <nl> + 	 * dwControl code requested . <nl> + 	 * @ param dwControl <nl> + 	 * This parameter can be one of the following control codes ( found in Winsvc . h ) : <nl> + 	 * SERVICE _ CONTROL _ STOP , SERVICE _ CONTROL _ PAUSE , SERVICE _ CONTROL _ CONTINUE <nl> + 	 * SERVICE _ CONTROL _ INTERROGATE , SERVICE _ CONTROL _ PARAMCHANGE , <nl> + 	 * SERVICE _ CONTROL _ NETBINDADD , SERVICE _ CONTROL _ NETBINDREMOVE , <nl> + 	 * SERVICE _ CONTROL _ NETBINDENABLE , SERVICE _ CONTROL _ NETBINDDISABLE <nl> + 	 * This value can also be a user - defined control code , as described below : <nl> + 	 * Range 128 to 255 - The service defines the action associated with the <nl> + 	 * control code . The hService handle must have the SERVICE _ USER _ DEFINED _ CONTROL <nl> + 	 * access right . <nl> + 	 * @ param lpServiceStatus <nl> + 	 * A pointer to a SERVICE _ STATUS structure that receives the latest <nl> + 	 * service status information . The information returned reflects the most <nl> + 	 * recent status that the service reported to the service control manager . <nl> + 	 * The service control manager fills in the structure only when ControlService <nl> + 	 * returns one of the following error codes : NO _ ERROR , ERROR _ INVALID _ SERVICE _ CONTROL , <nl> + 	 * ERROR _ SERVICE _ CANNOT _ ACCEPT _ CTRL , or ERROR _ SERVICE _ NOT _ ACTIVE . Otherwise , <nl> + 	 * the structure is not filled in . <nl> + 	 * @ return <nl> + 	 * If the function succeeds , the return value is true . <nl> + 	 * If the function fails , the return value is false . To get extended error information , <nl> + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . <nl> + 	 * / <nl> + 	 public boolean ControlService ( SC _ HANDLE hService , int dwControl , <nl> + 	 	 	 SERVICE _ STATUS lpServiceStatus ) ; <nl> + 	 <nl> + 	 <nl> + 	 / * * <nl> + 	 * Starts a service . <nl> + 	 * @ param hService <nl> + 	 * A handle to the service . This handle is returned by the <nl> + 	 * OpenService ( SC _ HANDLE , String , int ) or CreateService ( ) <nl> + 	 * function , and it must have the SERVICE _ START access right . For more <nl> + 	 * information , see < a href = " http : / / msdn . microsoft . com / en - us / library / ms685981 . aspx " > <nl> + 	 * 	 Service Security and Access Rights < / a > . <nl> + 	 * @ param dwNumServiceArgs <nl> + 	 * The number of strings in the lpServiceArgVectors array . If lpServiceArgVectors <nl> + 	 * is NULL , this parameter can be zero . <nl> + 	 * @ param lpServiceArgVectors <nl> + 	 * The null - terminated strings to be passed to the ServiceMain function for the <nl> + 	 * service as arguments . If there are no arguments , this parameter can be null . <nl> + 	 * Otherwise , the first argument ( lpServiceArgVectors [ 0 ] ) is the name of the <nl> + 	 * service , followed by any additional arguments ( lpServiceArgVectors [ 1 ] through <nl> + 	 * lpServiceArgVectors [ dwNumServiceArgs - 1 ] ) . <nl> + 	 * Driver services do not receive these arguments . <nl> + 	 * @ return <nl> + 	 * If the function succeeds , the return value is true . <nl> + 	 * If the function fails , the return value is false . To get extended error information , <nl> + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . <nl> + 	 * / <nl> + 	 public boolean StartService ( SC _ HANDLE hService , int dwNumServiceArgs , <nl> + 	 	 	 String [ ] lpServiceArgVectors ) ; <nl> + 	 <nl> + 	 / * * <nl> + 	 * Closes a handle to a service control manager or service object . <nl> + 	 * @ param hSCObject <nl> + 	 * A handle to the service control manager object or the service object to <nl> + 	 * close . Handles to service control manager objects are returned by the <nl> + 	 * OpenSCManager ( String , String , int ) function , and handles to service <nl> + 	 * objects are returned by either the OpenService ( SC _ HANDLE , String , int ) <nl> + 	 * or CreateService ( ) function . <nl> + 	 * @ return <nl> + 	 * If the function succeeds , the return value is nonzero . <nl> + 	 * If the function fails , the return value is zero . To get extended <nl> + 	 * error information , call GetLastError . This value is a nonzero error code <nl> + 	 * defined in Winerror . h . <nl> + 	 * / <nl> + 	 public boolean CloseServiceHandle ( SC _ HANDLE hSCObject ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Opens an existing service . <nl> + 	 * @ param hSCManager <nl> + 	 * 	 A handle to the service control manager database . The <nl> + 	 * 	 OpenSCManager ( String , String , int ) function returns this handle . <nl> + 	 * @ param lpServiceName <nl> + 	 * 	 The name of the service to be opened . This is the name specified by the <nl> + 	 * 	 lpServiceName parameter of the CreateService function when the service <nl> + 	 * 	 object was created , not the service display name that is shown by user <nl> + 	 * 	 interface applications to identify the service . <nl> + 	 * 	 The maximum string length is 256 characters . The service control manager <nl> + 	 * 	 database preserves the case of the characters , but service name comparisons <nl> + 	 * 	 are always case insensitive . Forward - slash ( / ) and backslash ( \ ) are <nl> + 	 * 	 invalid service name characters . <nl> + 	 * @ param dwDesiredAccess <nl> + 	 * 	 The access to the service . For a list of access rights , see <nl> + 	 * 	 < a href = " http : / / msdn . microsoft . com / en - us / library / ms685981 . aspx " > <nl> + 	 * 	 Service Security and Access Rights < / a > . <nl> + 	 * 	 Before granting the requested access , the system checks the access token <nl> + 	 * of the calling process against the discretionary access - control list of the security descriptor associated with the service object . <nl> + 	 * @ return <nl> + 	 * If the function succeeds , the return value is a handle to the service . <nl> + 	 * If the function fails , the return value is NULL . To get extended error information , <nl> + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . <nl> + 	 * / <nl> + 	 public SC _ HANDLE OpenService ( SC _ HANDLE hSCManager , String lpServiceName , int dwDesiredAccess ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Establishes a connection to the service control manager on the specified <nl> + 	 * computer and opens the specified service control manager database . <nl> + 	 * @ param lpMachineName <nl> + 	 * The name of the target computer . If the pointer is NULL or points to <nl> + 	 * an empty string , the function connects to the service control manager <nl> + 	 * on the local computer . <nl> + 	 * @ param lpDatabaseName <nl> + 	 * The name of the service control manager database . This parameter should <nl> + 	 * be set to SERVICES _ ACTIVE _ DATABASE . If it is NULL , the SERVICES _ ACTIVE _ DATABASE <nl> + 	 * database is opened by default . <nl> + 	 * @ param dwDesiredAccess <nl> + 	 * The access to the service control manager . For a list of access rights , see <nl> + 	 * < a href = " http : / / msdn . microsoft . com / en - us / library / ms685981 . aspx " > <nl> + 	 * Service Security and Access Rights < / a > . <nl> + 	 * Before granting the requested access rights , the system checks the access <nl> + 	 * token of the calling process against the discretionary access - control list <nl> + 	 * of the security descriptor associated with the service control manager . <nl> + 	 * The SC _ MANAGER _ CONNECT access right is implicitly specified by calling this <nl> + 	 * function . <nl> + 	 * @ return <nl> + 	 * If the function succeeds , the return value is a handle to the specified <nl> + 	 * service control manager database . <nl> + 	 * If the function fails , the return value is NULL . To get extended error information , <nl> + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . <nl> + 	 * / <nl> + 	 public SC _ HANDLE OpenSCManager ( String lpMachineName , String lpDatabaseName , int dwDesiredAccess ) ; <nl> + 	 <nl> } <nl> diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> index df01ade . . 587014a 100644 <nl> - - - a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> @ @ - 43 , 7 + 43 , 7 @ @ public interface WinNT extends StdCallLibrary { <nl> 	 public static final int WRITE _ DAC = 0x00040000 ; <nl> 	 public static final int WRITE _ OWNER = 0x00080000 ; <nl> 	 public static final int SYNCHRONIZE = 0x00100000 ; <nl> - <nl> + 	 <nl> 	 public static final int STANDARD _ RIGHTS _ REQUIRED = 0x000F0000 ; <nl> <nl> 	 public static final int STANDARD _ RIGHTS _ READ = READ _ CONTROL ; <nl> @ @ - 439 , 7 + 439 , 20 @ @ public interface WinNT extends StdCallLibrary { <nl> public static final int FILE _ FLAG _ OPEN _ REPARSE _ POINT = 0x00200000 ; <nl> public static final int FILE _ FLAG _ OPEN _ NO _ RECALL = 0x00100000 ; <nl> <nl> - public static final int GENERIC _ WRITE = 0x40000000 ; <nl> + 	 / / <nl> + 	 / / These are the generic rights . <nl> + 	 / / <nl> + <nl> + 	 public static final int GENERIC _ READ 	 	 = 0x80000000 ; <nl> + 	 public static final int GENERIC _ WRITE 	 	 = 0x40000000 ; <nl> + 	 public static final int GENERIC _ EXECUTE 	 	 = 0x20000000 ; <nl> + 	 public static final int GENERIC _ ALL 	 	 	 = 0x10000000 ; <nl> + 	 <nl> + 	 / / <nl> + 	 / / AccessSystemAcl access type <nl> + 	 / / <nl> + <nl> + 	 public static final int ACCESS _ SYSTEM _ SECURITY = 0x01000000 ; <nl> <nl> public static class SECURITY _ ATTRIBUTES extends Structure { <nl> public final int nLength = size ( ) ; <nl> @ @ - 1524 , 4 + 1537 , 26 @ @ public interface WinNT extends StdCallLibrary { <nl> 	 	 	 read ( ) ; <nl> 	 	 } <nl> 	 } ; <nl> + 	 <nl> + 	 / / <nl> + 	 / / Service Types ( Bit Mask ) <nl> + 	 / / <nl> + 	 public static final int SERVICE _ KERNEL _ DRIVER 	 	 = 0x00000001 ; <nl> + 	 public static final int SERVICE _ FILE _ SYSTEM _ DRIVER 	 = 0x00000002 ; <nl> + 	 public static final int SERVICE _ ADAPTER 	 	 	 	 = 0x00000004 ; <nl> + 	 public static final int SERVICE _ RECOGNIZER _ DRIVER 	 = 0x00000008 ; <nl> + 	 <nl> + 	 public static final int SERVICE _ DRIVER = <nl> + 	 	 ( SERVICE _ KERNEL _ DRIVER | SERVICE _ FILE _ SYSTEM _ DRIVER | SERVICE _ RECOGNIZER _ DRIVER ) ; <nl> + 	 <nl> + 	 public static final int SERVICE _ WIN32 _ OWN _ PROCESS 	 = 0x00000010 ; <nl> + 	 public static final int SERVICE _ WIN32 _ SHARE _ PROCESS 	 = 0x00000020 ; <nl> + 	 <nl> + 	 public static final int SERVICE _ WIN32 = <nl> + 	 	 ( SERVICE _ WIN32 _ OWN _ PROCESS | SERVICE _ WIN32 _ SHARE _ PROCESS ) ; <nl> + 	 <nl> + 	 public static final int SERVICE _ INTERACTIVE _ PROCESS = 0x00000100 ; <nl> + 	 <nl> + 	 public static final int SERVICE _ TYPE _ ALL = <nl> + 	 	 ( SERVICE _ WIN32 | SERVICE _ ADAPTER | SERVICE _ DRIVER | SERVICE _ INTERACTIVE _ PROCESS ) ; <nl> } <nl> \ No newline at end of file <nl> diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Winsvc . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Winsvc . java <nl> new file mode 100644 <nl> index 0000000 . . f89d95c <nl> - - - / dev / null <nl> + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Winsvc . java <nl> @ @ - 0 , 0 + 1 , 289 @ @ <nl> + / * Copyright ( c ) 2010 EugineLev , All Rights Reserved <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation ; either <nl> + * version 2 . 1 of the License , or ( at your option ) any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + <nl> + import com . sun . jna . Memory ; <nl> + import com . sun . jna . Structure ; <nl> + import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> + import com . sun . jna . win32 . StdCallLibrary ; <nl> + <nl> + / * * <nl> + * This module defines the 32 - Bit Windows types and constants that are defined <nl> + * by NT , but exposed through the Win32 API . <nl> + * Ported from Winsvc . h . <nl> + * Microsoft Windows SDK 7 . 0A . <nl> + * @ author EugineLev <nl> + * / <nl> + public interface Winsvc extends StdCallLibrary { 	 <nl> + <nl> + 	 / * * <nl> + 	 * Contains status information for a service . The ControlService , EnumDependentServices , <nl> + 	 * EnumServicesStatus , and QueryServiceStatus functions use this structure . A service <nl> + 	 * uses this structure in the SetServiceStatus function to report its current status <nl> + 	 * to the service control manager . <nl> + 	 * / <nl> + 	 public static class SERVICE _ STATUS extends Structure { <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwServiceType - the type of service . This member can be one <nl> + 	 	 * of the following values : <nl> + 	 	 * SERVICE _ KERNEL _ DRIVER , SERVICE _ FILE _ SYSTEM _ DRIVER , <nl> + 	 	 * SERVICE _ WIN32 _ OWN _ PROCESS , SERVICE _ WIN32 _ SHARE _ PROCESS , <nl> + <nl> + 	 	 * If the service type is either SERVICE _ WIN32 _ OWN _ PROCESS or <nl> + 	 	 * SERVICE _ WIN32 _ SHARE _ PROCESS , and the service is running in the <nl> + 	 	 * context of the LocalSystem account , the following type may also <nl> + 	 	 * be specified : <nl> + 	 	 * SERVICE _ INTERACTIVE _ PROCESS <nl> + 	 	 * <nl> + 	 	 * These values can be found in WinNT . h <nl> + 	 	 * / <nl> + 	 	 public int dwServiceType ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwCurrentState - The current state of the service . <nl> + 	 	 * This member can be one of the following values : <nl> + 	 	 * SERVICE _ STOPPED , SERVICE _ START _ PENDING , SERVICE _ STOP _ PENDING , SERVICE _ RUNNING , <nl> + 	 	 * SERVICE _ CONTINUE _ PENDING , SERVICE _ PAUSE _ PENDING , SERVICE _ PAUSED 	 <nl> + 	 	 * / <nl> + 	 	 public int dwCurrentState ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwControlsAccepted - The control codes the service accepts and processes <nl> + 	 	 * in its handler function : <nl> + 	 	 * SERVICE _ ACCEPT _ STOP , SERVICE _ ACCEPT _ PAUSE _ CONTINUE , SERVICE _ ACCEPT _ SHUTDOWN , <nl> + 	 	 * SERVICE _ ACCEPT _ PARAMCHANGE , SERVICE _ ACCEPT _ NETBINDCHANGE , SERVICE _ ACCEPT _ HARDWAREPROFILECHANGE , <nl> + 	 	 * SERVICE _ ACCEPT _ POWEREVENT , SERVICE _ ACCEPT _ SESSIONCHANGE , SERVICE _ ACCEPT _ PRESHUTDOWN , <nl> + 	 	 * SERVICE _ ACCEPT _ TIMECHANGE , SERVICE _ ACCEPT _ TRIGGEREVENT <nl> + 	 	 * / <nl> + 	 	 public int dwControlsAccepted ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwWin32ExitCode - The error code the service uses to report an error that occurs <nl> + 	 	 * when it is starting or stopping . To return an error code specific to the service , <nl> + 	 	 * the service must set this value to ERROR _ SERVICE _ SPECIFIC _ ERROR to indicate that <nl> + 	 	 * the dwServiceSpecificExitCode member contains the error code . The service should <nl> + 	 	 * set this value to NO _ ERROR when it is running and on normal termination . <nl> + 	 	 * / <nl> + 	 	 public int dwWin32ExitCode ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwServiceSpecificExitCode - A service - specific error code that the service returns <nl> + 	 	 * when an error occurs while the service is starting or stopping . This value is <nl> + 	 	 * ignored unless the dwWin32ExitCode member is set to ERROR _ SERVICE _ SPECIFIC _ ERROR . <nl> + 	 	 * / <nl> + 	 	 public int dwServiceSpecificExitCode ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwCheckPoint - The check - point value the service increments periodically to report <nl> + 	 	 * its progress during a lengthy start , stop , pause , or continue operation . <nl> + 	 	 * / <nl> + 	 	 public int dwCheckPoint ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwWaitHint - The estimated time required for a pending start , stop , pause , or continue <nl> + 	 	 * operation , in milliseconds . <nl> + 	 	 * / <nl> + 	 	 public int dwWaitHint ; <nl> + <nl> + 	 	 public SERVICE _ STATUS ( ) { <nl> + 	 	 	 super ( ) ; <nl> + 	 	 } <nl> + <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * Contains process status information for a service . The ControlServiceEx , <nl> + 	 * EnumServicesStatusEx , NotifyServiceStatusChange , and QueryServiceStatusEx <nl> + 	 * functions use this structure . <nl> + 	 * / <nl> + 	 public class SERVICE _ STATUS _ PROCESS extends Structure { <nl> + 	 	 / * * <nl> + 	 	 * dwServiceType - the type of service . This member can be one <nl> + 	 	 * of the following values : <nl> + 	 	 * SERVICE _ KERNEL _ DRIVER , SERVICE _ FILE _ SYSTEM _ DRIVER , <nl> + 	 	 * SERVICE _ WIN32 _ OWN _ PROCESS , SERVICE _ WIN32 _ SHARE _ PROCESS , <nl> + <nl> + 	 	 * If the service type is either SERVICE _ WIN32 _ OWN _ PROCESS or <nl> + 	 	 * SERVICE _ WIN32 _ SHARE _ PROCESS , and the service is running in the <nl> + 	 	 * context of the LocalSystem account , the following type may also <nl> + 	 	 * be specified : <nl> + 	 	 * SERVICE _ INTERACTIVE _ PROCESS <nl> + 	 	 * <nl> + 	 	 * These values can be found in WinNT . h <nl> + 	 	 * / <nl> + 	 	 public int dwServiceType ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwCurrentState - The current state of the service . <nl> + 	 	 * This member can be one of the following values : <nl> + 	 	 * SERVICE _ STOPPED , SERVICE _ START _ PENDING , SERVICE _ STOP _ PENDING , SERVICE _ RUNNING , <nl> + 	 	 * SERVICE _ CONTINUE _ PENDING , SERVICE _ PAUSE _ PENDING , SERVICE _ PAUSED 	 <nl> + 	 	 * / <nl> + 	 	 public int dwCurrentState ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwControlsAccepted - The control codes the service accepts and processes <nl> + 	 	 * in its handler function : <nl> + 	 	 * SERVICE _ ACCEPT _ STOP , SERVICE _ ACCEPT _ PAUSE _ CONTINUE , SERVICE _ ACCEPT _ SHUTDOWN , <nl> + 	 	 * SERVICE _ ACCEPT _ PARAMCHANGE , SERVICE _ ACCEPT _ NETBINDCHANGE , SERVICE _ ACCEPT _ HARDWAREPROFILECHANGE , <nl> + 	 	 * SERVICE _ ACCEPT _ POWEREVENT , SERVICE _ ACCEPT _ SESSIONCHANGE , SERVICE _ ACCEPT _ PRESHUTDOWN , <nl> + 	 	 * SERVICE _ ACCEPT _ TIMECHANGE , SERVICE _ ACCEPT _ TRIGGEREVENT <nl> + 	 	 * / <nl> + 	 	 public int dwControlsAccepted ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwWin32ExitCode - The error code the service uses to report an error that occurs <nl> + 	 	 * when it is starting or stopping . To return an error code specific to the service , <nl> + 	 	 * the service must set this value to ERROR _ SERVICE _ SPECIFIC _ ERROR to indicate that <nl> + 	 	 * the dwServiceSpecificExitCode member contains the error code . The service should <nl> + 	 	 * set this value to NO _ ERROR when it is running and on normal termination . <nl> + 	 	 * / <nl> + 	 	 public int dwWin32ExitCode ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwServiceSpecificExitCode - A service - specific error code that the service returns <nl> + 	 	 * when an error occurs while the service is starting or stopping . This value is <nl> + 	 	 * ignored unless the dwWin32ExitCode member is set to ERROR _ SERVICE _ SPECIFIC _ ERROR . <nl> + 	 	 * / <nl> + 	 	 public int dwServiceSpecificExitCode ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwCheckPoint - The check - point value the service increments periodically to report <nl> + 	 	 * its progress during a lengthy start , stop , pause , or continue operation . <nl> + 	 	 * / <nl> + 	 	 public int dwCheckPoint ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwWaitHint - The estimated time required for a pending start , stop , pause , or continue <nl> + 	 	 * operation , in milliseconds . <nl> + 	 	 * / <nl> + 	 	 public int dwWaitHint ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * dwProcessId - The process identifier of the service . <nl> + 	 	 * / <nl> + 	 	 public int dwProcessId ; <nl> + 	 	 <nl> + 	 	 / * * <nl> + 	 	 * This member can be one of the following values : 0 , or SERVICE _ RUNS _ IN _ SYSTEM _ PROCESS <nl> + 	 	 * / <nl> + 	 	 public int dwServiceFlags ; <nl> + 	 	 <nl> + 	 	 public SERVICE _ STATUS _ PROCESS ( ) { <nl> + 	 	 } <nl> + 	 	 <nl> + 	 	 public SERVICE _ STATUS _ PROCESS ( int size ) { <nl> + 	 	 	 super ( new Memory ( size ) ) ; <nl> + 	 	 } <nl> + 	 } <nl> + 	 <nl> + 	 / / <nl> + 	 / / Service flags for QueryServiceStatusEx <nl> + 	 / / <nl> + 	 public static final int SERVICE _ RUNS _ IN _ SYSTEM _ PROCESS = 0x00000001 ; <nl> + 	 <nl> + 	 public static class SC _ HANDLE extends HANDLE { } <nl> + 	 <nl> + 	 / / <nl> + 	 / / Service Control Manager object specific access types <nl> + 	 / / <nl> + 	 public static final int SC _ MANAGER _ CONNECT 	 	 	 	 = 0x0001 ; <nl> + 	 public static final int SC _ MANAGER _ CREATE _ SERVICE 	 	 = 0x0002 ; <nl> + 	 public static final int SC _ MANAGER _ ENUMERATE _ SERVICE 	 = 0x0004 ; <nl> + 	 public static final int SC _ MANAGER _ LOCK 	 	 	 	 	 = 0x0008 ; <nl> + 	 public static final int SC _ MANAGER _ QUERY _ LOCK _ STATUS 	 = 0x0010 ; <nl> + 	 public static final int SC _ MANAGER _ MODIFY _ BOOT _ CONFIG 	 = 0x0020 ; <nl> + <nl> + 	 public static final int SC _ MANAGER _ ALL _ ACCESS = <nl> + 	 	 WinNT . STANDARD _ RIGHTS _ REQUIRED | SC _ MANAGER _ CONNECT <nl> + 	 	 | SC _ MANAGER _ CREATE _ SERVICE | SC _ MANAGER _ ENUMERATE _ SERVICE <nl> + 	 	 | SC _ MANAGER _ LOCK | SC _ MANAGER _ QUERY _ LOCK _ STATUS <nl> + 	 	 | SC _ MANAGER _ MODIFY _ BOOT _ CONFIG ; <nl> + <nl> + 	 / / <nl> + 	 / / Service object specific access type <nl> + 	 / / <nl> + 	 public static final int SERVICE _ QUERY _ CONFIG 	 	 	 = 0x0001 ; <nl> + 	 public static final int SERVICE _ CHANGE _ CONFIG 	 	 	 = 0x0002 ; <nl> + 	 public static final int SERVICE _ QUERY _ STATUS 	 	 	 = 0x0004 ; <nl> + 	 public static final int SERVICE _ ENUMERATE _ DEPENDENTS 	 = 0x0008 ; <nl> + 	 public static final int SERVICE _ START 	 	 	 	 	 = 0x0010 ; <nl> + 	 public static final int SERVICE _ STOP 	 	 	 	 	 = 0x0020 ; <nl> + 	 public static final int SERVICE _ PAUSE _ CONTINUE 	 	 	 = 0x0040 ; <nl> + 	 public static final int SERVICE _ INTERROGATE 	 	 	 	 = 0x0080 ; <nl> + 	 public static final int SERVICE _ USER _ DEFINED _ CONTROL 	 = 0x0100 ; <nl> + <nl> + 	 public static final int SERVICE _ ALL _ ACCESS = <nl> + 	 	 WinNT . STANDARD _ RIGHTS _ REQUIRED | SERVICE _ QUERY _ CONFIG <nl> + 	 	 | SERVICE _ CHANGE _ CONFIG | SERVICE _ QUERY _ STATUS <nl> + 	 	 | SERVICE _ ENUMERATE _ DEPENDENTS | SERVICE _ START | SERVICE _ STOP <nl> + 	 	 | SERVICE _ PAUSE _ CONTINUE | SERVICE _ INTERROGATE <nl> + 	 	 | SERVICE _ USER _ DEFINED _ CONTROL ; <nl> + <nl> + 	 / / <nl> + 	 / / Controls <nl> + 	 / / <nl> + 	 public static final int SERVICE _ CONTROL _ STOP 	 	 	 = 0x00000001 ; <nl> + 	 public static final int SERVICE _ CONTROL _ PAUSE 	 	 	 = 0x00000002 ; <nl> + 	 public static final int SERVICE _ CONTROL _ CONTINUE 	 	 = 0x00000003 ; <nl> + 	 public static final int SERVICE _ CONTROL _ INTERROGATE 	 = 0x00000004 ; <nl> + / / 	 public static final int SERVICE _ CONTROL _ SHUTDOWN 	 	 = 0x00000005 ; <nl> + 	 public static final int SERVICE _ CONTROL _ PARAMCHANGE 	 = 0x00000006 ; <nl> + 	 public static final int SERVICE _ CONTROL _ NETBINDADD 	 	 = 0x00000007 ; <nl> + 	 public static final int SERVICE _ CONTROL _ NETBINDREMOVE 	 = 0x00000008 ; <nl> + 	 public static final int SERVICE _ CONTROL _ NETBINDENABLE 	 = 0x00000009 ; <nl> + 	 public static final int SERVICE _ CONTROL _ NETBINDDISABLE 	 = 0x0000000A ; <nl> + / / 	 public static final int SERVICE _ CONTROL _ DEVICEEVENT 	 	 = 0x0000000B ; <nl> + / / 	 public static final int SERVICE _ CONTROL _ HARDWAREPROFILECHANGE = 0x0000000C ; <nl> + / / 	 public static final int SERVICE _ CONTROL _ POWEREVENT 	 	 = 0x0000000D ; <nl> + / / 	 public static final int SERVICE _ CONTROL _ SESSIONCHANGE 	 = 0x0000000E ; <nl> + / / 	 public static final int SERVICE _ CONTROL _ PRESHUTDOWN 	 	 = 0x0000000F ; <nl> + / / 	 public static final int SERVICE _ CONTROL _ TIMECHANGE 	 	 = 0x00000010 ; <nl> + / / 	 public static final int SERVICE _ CONTROL _ TRIGGEREVENT 	 = 0x00000020 ; <nl> + 	 <nl> + 	 / / <nl> + 	 / / Service State - - for CurrentState <nl> + 	 / / <nl> + 	 public static final int SERVICE _ STOPPED 	 	 	 	 = 0x00000001 ; <nl> + 	 public static final int SERVICE _ START _ PENDING 	 	 = 0x00000002 ; <nl> + 	 public static final int SERVICE _ STOP _ PENDING 	 	 = 0x00000003 ; <nl> + 	 public static final int SERVICE _ RUNNING 	 	 	 	 = 0x00000004 ; <nl> + 	 public static final int SERVICE _ CONTINUE _ PENDING 	 = 0x00000005 ; <nl> + 	 public static final int SERVICE _ PAUSE _ PENDING 	 	 = 0x00000006 ; <nl> + 	 public static final int SERVICE _ PAUSED 	 	 	 	 = 0x00000007 ; <nl> + <nl> + 	 / / <nl> + 	 / / Controls Accepted ( Bit Mask ) <nl> + 	 / / <nl> + 	 public static final int SERVICE _ ACCEPT _ STOP 	 	 	 	 	 	 = 0x00000001 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ PAUSE _ CONTINUE 	 	 	 = 0x00000002 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ SHUTDOWN 	 	 	 	 	 = 0x00000004 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ PARAMCHANGE 	 	 	 	 = 0x00000008 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ NETBINDCHANGE 	 	 	 = 0x00000010 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ HARDWAREPROFILECHANGE 	 = 0x00000020 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ POWEREVENT 	 	 	 	 = 0x00000040 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ SESSIONCHANGE 	 	 	 = 0x00000080 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ PRESHUTDOWN 	 	 	 	 = 0x00000100 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ TIMECHANGE 	 	 	 	 = 0x00000200 ; <nl> + 	 public static final int SERVICE _ ACCEPT _ TRIGGEREVENT 	 	 	 	 = 0x00000400 ; <nl> + 	 <nl> + 	 / * * <nl> + 	 * The SC _ STATUS _ TYPE enumeration type contains values <nl> + 	 * / <nl> + 	 public abstract class SC _ STATUS _ TYPE { <nl> + 	 	 public static final int SC _ STATUS _ PROCESS _ INFO = 0 ; <nl> + 	 } <nl> + <nl> + } <nl> diff - - git a / jnalib / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / jnalib / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> index bb9a447 . . 867702d 100644 <nl> - - - a / jnalib / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> + + + b / jnalib / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> @ @ - 31 , 6 + 31 , 9 @ @ import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; <nl> import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; <nl> import com . sun . jna . platform . win32 . WinNT . WELL _ KNOWN _ SID _ TYPE ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> + import com . sun . jna . platform . win32 . Winsvc . SC _ HANDLE ; <nl> + import com . sun . jna . platform . win32 . Winsvc . SC _ STATUS _ TYPE ; <nl> + import com . sun . jna . platform . win32 . Winsvc . SERVICE _ STATUS _ PROCESS ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> import com . sun . jna . ptr . PointerByReference ; <nl> <nl> @ @ - 620 , 5 + 623 , 106 @ @ public class Advapi32Test extends TestCase { <nl> 	 assertTrue ( Advapi32 . INSTANCE . GetOldestEventLogRecord ( h , oldestRecord ) ) ; <nl> 	 assertTrue ( oldestRecord . getValue ( ) > = 0 ) ; <nl> 	 assertTrue ( Advapi32 . INSTANCE . CloseEventLog ( h ) ) ; <nl> - } <nl> + } <nl> + <nl> + public void testQueryServiceStatusEx ( ) { <nl> + <nl> + 	 SC _ HANDLE scmHandle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; <nl> + 	 assertNotNull ( scmHandle ) ; <nl> + <nl> + 	 SC _ HANDLE serviceHandle = Advapi32 . INSTANCE . OpenService ( scmHandle , " eventlog " , Winsvc . SERVICE _ QUERY _ STATUS ) ; <nl> + 	 assertNotNull ( serviceHandle ) ; <nl> + <nl> + 	 IntByReference pcbBytesNeeded = new IntByReference ( ) ; <nl> + <nl> + 	 assertFalse ( Advapi32 . INSTANCE . QueryServiceStatusEx ( serviceHandle , SC _ STATUS _ TYPE . SC _ STATUS _ PROCESS _ INFO , <nl> + 	 	 	 null , 0 , pcbBytesNeeded ) ) ; <nl> + 	 assertEquals ( W32Errors . ERROR _ INSUFFICIENT _ BUFFER , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + 	 <nl> + 	 assertTrue ( pcbBytesNeeded . getValue ( ) > 0 ) ; <nl> + <nl> + 	 SERVICE _ STATUS _ PROCESS status = new SERVICE _ STATUS _ PROCESS ( pcbBytesNeeded . getValue ( ) ) ; <nl> + <nl> + 	 assertTrue ( Advapi32 . INSTANCE . QueryServiceStatusEx ( serviceHandle , SC _ STATUS _ TYPE . SC _ STATUS _ PROCESS _ INFO , <nl> + 	 	 	 status , status . size ( ) , pcbBytesNeeded ) ) ; <nl> + <nl> + 	 assertTrue ( status . dwCurrentState = = Winsvc . SERVICE _ STOPPED | | <nl> + 	 	 	 status . dwCurrentState = = Winsvc . SERVICE _ RUNNING ) ; <nl> + <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( serviceHandle ) ) ; <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( scmHandle ) ) ; <nl> + } <nl> + <nl> + <nl> + public void testControlService ( ) { <nl> + 	 SC _ HANDLE scmHandle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; <nl> + 	 assertNotNull ( scmHandle ) ; <nl> + <nl> + 	 SC _ HANDLE serviceHandle = Advapi32 . INSTANCE . OpenService ( scmHandle , " eventlog " , Winsvc . SERVICE _ QUERY _ CONFIG ) ; <nl> + 	 assertNotNull ( serviceHandle ) ; <nl> + <nl> + 	 Winsvc . SERVICE _ STATUS serverStatus = new Winsvc . SERVICE _ STATUS ( ) ; <nl> + <nl> + 	 assertNotNull ( serviceHandle ) ; <nl> + 	 assertFalse ( Advapi32 . INSTANCE . ControlService ( serviceHandle , Winsvc . SERVICE _ CONTROL _ STOP , serverStatus ) ) ; <nl> + 	 assertEquals ( W32Errors . ERROR _ ACCESS _ DENIED , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( serviceHandle ) ) ; <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( scmHandle ) ) ; <nl> + } <nl> + <nl> + public void testStartService ( ) { <nl> + 	 SC _ HANDLE scmHandle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; <nl> + 	 assertNotNull ( scmHandle ) ; <nl> + 	 <nl> + 	 SC _ HANDLE serviceHandle = Advapi32 . INSTANCE . OpenService ( scmHandle , " Wecsvc " , Winsvc . SERVICE _ QUERY _ CONFIG ) ; <nl> + 	 assertNotNull ( serviceHandle ) ; <nl> + 	 <nl> + 	 assertFalse ( Advapi32 . INSTANCE . StartService ( serviceHandle , 0 , null ) ) ; <nl> + 	 assertEquals ( W32Errors . ERROR _ ACCESS _ DENIED , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( serviceHandle ) ) ; <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( scmHandle ) ) ; <nl> + } <nl> + <nl> + public void testOpenService ( ) { <nl> + 	 assertNull ( Advapi32 . INSTANCE . OpenService ( null , " eventlog " , Winsvc . SERVICE _ QUERY _ CONFIG ) ) ; <nl> + 	 assertEquals ( W32Errors . ERROR _ INVALID _ HANDLE , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + <nl> + 	 SC _ HANDLE scmHandle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; <nl> + 	 assertNotNull ( scmHandle ) ; <nl> + 	 <nl> + 	 SC _ HANDLE serviceHandle = Advapi32 . INSTANCE . OpenService ( scmHandle , " eventlog " , Winsvc . SERVICE _ QUERY _ CONFIG ) ; <nl> + 	 assertNotNull ( serviceHandle ) ; <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( serviceHandle ) ) ; <nl> + <nl> + 	 assertNull ( Advapi32 . INSTANCE . OpenService ( scmHandle , " slashesArentValidChars / " , Winsvc . SERVICE _ QUERY _ CONFIG ) ) ; <nl> + 	 assertEquals ( W32Errors . ERROR _ INVALID _ NAME , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + <nl> + 	 assertNull ( Advapi32 . INSTANCE . OpenService ( scmHandle , " serviceDoesNotExist " , Winsvc . SERVICE _ QUERY _ CONFIG ) ) ; <nl> + 	 assertEquals ( W32Errors . ERROR _ SERVICE _ DOES _ NOT _ EXIST , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( scmHandle ) ) ; <nl> + } <nl> + <nl> + public void testOpenSCManager ( ) { <nl> + 	 SC _ HANDLE handle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; <nl> + 	 assertNotNull ( handle ) ; <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( handle ) ) ; <nl> + 	 <nl> + 	 assertNull ( Advapi32 . INSTANCE . OpenSCManager ( " invalidMachineName " , null , Winsvc . SC _ MANAGER _ CONNECT ) ) ; <nl> + 	 assertEquals ( W32Errors . RPC _ S _ SERVER _ UNAVAILABLE , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + <nl> + 	 assertNull ( Advapi32 . INSTANCE . OpenSCManager ( null , " invalidDatabase " , Winsvc . SC _ MANAGER _ CONNECT ) ) ; <nl> + 	 assertEquals ( W32Errors . ERROR _ INVALID _ NAME , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + <nl> + public void testCloseServiceHandle ( ) throws Exception { <nl> + 	 SC _ HANDLE handle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; <nl> + 	 assertNotNull ( handle ) ; <nl> + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( handle ) ) ; <nl> + 	 <nl> + 	 assertFalse ( Advapi32 . INSTANCE . CloseServiceHandle ( null ) ) ; <nl> + 	 assertEquals ( W32Errors . ERROR _ INVALID _ HANDLE , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> } <nl> diff - - git a / jnalib / release - notes . html b / jnalib / release - notes . html <nl> index 5246818 . . 4baaa06 100755 <nl> - - - a / jnalib / release - notes . html <nl> + + + b / jnalib / release - notes . html <nl> @ @ - 3 , 6 + 3 , 7 @ @ <nl> < h3 > Features < / h3 > <nl> < ul > <nl> < li > Add < code > platform . win32 . Kernel32 . DeleteFile < / code > and < code > com . sun . jna . platform . win32 . deleteFile < / code > . <nl> + < li > Add Win32 Service functions to < code > platform . win32 . Advapi32 < / code > . <nl> < li > Add Win32 Event Logging functions to < code > platform . win32 . Advapi32 < / code > and < code > platform . win32 . Advapi32Util . EventLogIterator < / code > . <nl> < li > < code > platform . win32 . Advapi32Util . registryCreateKey < / code > returns < code > true < / code > if key was created , < code > false < / code > if it already exists . <nl> < / ul >

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 index abe114c . . d8d410b 100755 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 @ @ - 214 , 7 + 214 , 6 @ @ public abstract class Advapi32Util { 
 
 	 	 Account account = new Account ( ) ; 
 	 	 account . accountType = peUse . getPointer ( ) . getInt ( 0 ) ; 
 - 	 	 account . name = accountName ; 
 
 	 	 String [ ] accountNamePartsBs = accountName . split ( " \ \ \ \ " , 2 ) ; 
 	 	 String [ ] accountNamePartsAt = accountName . split ( " @ " , 2 ) ; 
 @ @ - 459 , 7 + 458 , 7 @ @ public abstract class Advapi32Util { 
 	 	 ArrayList < Account > userGroups = new ArrayList < Account > ( ) ; 
 	 	 / / make array of names 
 	 	 for ( SID _ AND _ ATTRIBUTES sidAndAttribute : groups . getGroups ( ) ) { 
 - 	 	 	 Account group = null ; 
 + 	 	 	 Account group ; 
 	 	 	 try { 
 	 	 	 	 group = Advapi32Util . getAccountBySid ( sidAndAttribute . Sid ) ; 
 	 	 	 } catch ( Exception e ) { 
 @ @ - 2329 , 7 + 2328 , 7 @ @ public abstract class Advapi32Util { 
 	 * An event log record . 
 	 * / 
 	 public static class EventLogRecord { 
 - 	 	 private EVENTLOGRECORD _ record = null ; 
 + 	 	 private EVENTLOGRECORD _ record ; 
 	 	 private String _ source ; 
 	 	 private byte [ ] _ data ; 
 	 	 private String [ ] _ strings ; 
 @ @ - 2463 , 14 + 2462 , 14 @ @ public abstract class Advapi32Util { 
 	 public static class EventLogIterator implements Iterable < EventLogRecord > , 
 	 	 	 Iterator < EventLogRecord > { 
 
 - 	 	 private HANDLE _ h = null ; 
 + 	 	 private HANDLE _ h ; 
 	 	 private Memory _ buffer = new Memory ( 1024 * 64 ) ; / / memory buffer to 
 	 	 	 	 	 	 	 	 	 	 	 	 	 	 / / store events 
 	 	 private boolean _ done = false ; / / no more events 
 	 	 private int _ dwRead = 0 ; / / number of bytes remaining in the current 
 	 	 	 	 	 	 	 	 	 / / buffer 
 	 	 private Pointer _ pevlr = null ; / / pointer to the current record 
 - 	 	 private int _ flags = WinNT . EVENTLOG _ FORWARDS _ READ ; 
 + 	 	 private int _ flags ; 
 
 	 	 public EventLogIterator ( String sourceName ) { 
 	 	 	 this ( null , sourceName , WinNT . EVENTLOG _ FORWARDS _ READ ) ; 
 @ @ - 2582 , 8 + 2581 , 8 @ @ public abstract class Advapi32Util { 
 	 	 	 boolean compact ) { 
 	 	 int infoType = WinNT . DACL _ SECURITY _ INFORMATION ; 
 	 	 int nLength = 1024 ; 
 - 	 	 boolean repeat = false ; 
 - 	 	 Memory memory = null ; 
 + 	 	 boolean repeat ; 
 + 	 	 Memory memory ; 
 
 	 	 do { 
 	 	 	 repeat = false ; 
 @ @ - 2934 , 7 + 2933 , 7 @ @ public abstract class Advapi32Util { 
 * / 
 public static SECURITY _ DESCRIPTOR _ RELATIVE getFileSecurityDescriptor ( File file , boolean getSACL ) 
 { 
 - 	 SECURITY _ DESCRIPTOR _ RELATIVE sdr = null ; 
 + 	 SECURITY _ DESCRIPTOR _ RELATIVE sdr ; 
 	 Memory securityDesc = getSecurityDescriptorForObject ( file . getAbsolutePath ( ) . replaceAll ( " / " , " \ \ " ) , AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , getSACL ) ; 
 	 sdr = new SECURITY _ DESCRIPTOR _ RELATIVE ( securityDesc ) ; 
 	 return sdr ;

NEAREST DIFF:
diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 index 03ece2a . . 4681ed9 100644 
 - - - a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 @ @ - 10 , 7 + 10 , 7 @ @ 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 * Lesser General Public License for more details . 
 * / 
 - package com . sun . jna . platform . win32 ; 
 + package com . sun . jna . platform . win32 ; 
 
 import com . sun . jna . Native ; 
 import com . sun . jna . Pointer ; 
 @ @ - 22 , 6 + 22 , 10 @ @ import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; 
 import com . sun . jna . platform . win32 . WinNT . SECURITY _ ATTRIBUTES ; 
 import com . sun . jna . platform . win32 . WinReg . HKEY ; 
 import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 + import com . sun . jna . platform . win32 . Winsvc . SC _ HANDLE ; 
 + import com . sun . jna . platform . win32 . Winsvc . SC _ STATUS _ TYPE ; 
 + import com . sun . jna . platform . win32 . Winsvc . SERVICE _ STATUS ; 
 + import com . sun . jna . platform . win32 . Winsvc . SERVICE _ STATUS _ PROCESS ; 
 import com . sun . jna . ptr . IntByReference ; 
 import com . sun . jna . ptr . PointerByReference ; 
 import com . sun . jna . win32 . StdCallLibrary ; 
 @ @ - 657 , 7 + 661 , 8 @ @ public interface Advapi32 extends StdCallLibrary { 
 	 	 	 IntByReference lpcMaxValueNameLen , IntByReference lpcMaxValueLen , 
 	 	 	 IntByReference lpcbSecurityDescriptor , 
 	 	 	 WinBase . FILETIME lpftLastWriteTime ) ; 
 - 
 + 	 	 	 
 + 	 	 	 
 	 / * * 
 	 * Retrieves a registered handle to the specified event log . 
 	 * @ param lpUNCServerName 
 @ @ - 839 , 4 + 844 , 169 @ @ public interface Advapi32 extends StdCallLibrary { 
 	 * If the function fails , the return value is zero . To get extended error information , call GetLastError . 
 	 * / 
 	 public boolean GetOldestEventLogRecord ( HANDLE hEventLog , IntByReference OldestRecord ) ; 
 + 	 
 + 	 / * * 
 + 	 * Retrieves the current status of the specified service based on the specified information level . 
 + 	 * @ param hService 
 + 	 * 	 A handle to the service . This handle is returned by the 
 + 	 * OpenService ( SC _ HANDLE , String , int ) or @ link # CreateService ( ) function , and 
 + 	 * it must have the SERVICE _ QUERY _ STATUS access right . For more information , see 
 + 	 * < a href = " http : / / msdn . microsoft . com / en - us / library / ms685981 . aspx " > Service Security and Access Rights < / a > . 
 + 	 * @ param InfoLevel 
 + 	 * The service attributes to be returned ( a value from { @ link SC _ STATUS _ TYPE } enumeration ) . 
 + 	 * Use SC _ STATUS _ PROCESS _ INFO to retrieve the service status information . The lpBuffer 
 + 	 * parameter is a pointer to a SERVICE _ STATUS _ PROCESS structure . 
 + 	 * Currently , no other information levels are defined . 
 + 	 * @ param lpBuffer ( optional ) 
 + 	 * A pointer to the buffer that receives the status information . The format of this data 
 + 	 * depends on the value of the InfoLevel parameter . 
 + 	 * The maximum size of this array is 8K bytes . To determine the required size , specify NULL 
 + 	 * for this parameter and 0 for the cbBufSize parameter . The function will fail and GetLastError 
 + 	 * will return ERROR _ INSUFFICIENT _ BUFFER . The pcbBytesNeeded parameter will receive the required size . 
 + 	 * @ param cbBufSize 
 + 	 * The size of the buffer pointed to by the lpBuffer parameter , in bytes . 
 + 	 * @ param pcbBytesNeeded 
 + 	 * A pointer to a variable that receives the number of bytes needed to store all status 
 + 	 * information , if the function fails with ERROR _ INSUFFICIENT _ BUFFER . 
 + 	 * @ return 
 + 	 * If the function succeeds , the return value is true . 
 + 	 * If the function fails , the return value is false . To get extended error information , 
 + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . 
 + 	 * / 
 + 	 public boolean QueryServiceStatusEx ( SC _ HANDLE hService , int InfoLevel , 
 + 	 	 	 SERVICE _ STATUS _ PROCESS lpBuffer , int cbBufSize , IntByReference pcbBytesNeeded ) ; 
 + 	 
 + 	 / * * 
 + 	 * Sends a control code to a service . 
 + 	 * To specify additional information when stopping a service , use the 
 + 	 * ControlServiceEx function . 
 + 	 * @ param hService 
 + 	 * A handle to the service . This handle is returned by the 
 + 	 * OpenService ( SC _ HANDLE , String , int ) or CreateService ( ) 
 + 	 * function . The access rights required for this handle depend on the 
 + 	 * dwControl code requested . 
 + 	 * @ param dwControl 
 + 	 * This parameter can be one of the following control codes ( found in Winsvc . h ) : 
 + 	 * SERVICE _ CONTROL _ STOP , SERVICE _ CONTROL _ PAUSE , SERVICE _ CONTROL _ CONTINUE 
 + 	 * SERVICE _ CONTROL _ INTERROGATE , SERVICE _ CONTROL _ PARAMCHANGE , 
 + 	 * SERVICE _ CONTROL _ NETBINDADD , SERVICE _ CONTROL _ NETBINDREMOVE , 
 + 	 * SERVICE _ CONTROL _ NETBINDENABLE , SERVICE _ CONTROL _ NETBINDDISABLE 
 + 	 * This value can also be a user - defined control code , as described below : 
 + 	 * Range 128 to 255 - The service defines the action associated with the 
 + 	 * control code . The hService handle must have the SERVICE _ USER _ DEFINED _ CONTROL 
 + 	 * access right . 
 + 	 * @ param lpServiceStatus 
 + 	 * A pointer to a SERVICE _ STATUS structure that receives the latest 
 + 	 * service status information . The information returned reflects the most 
 + 	 * recent status that the service reported to the service control manager . 
 + 	 * The service control manager fills in the structure only when ControlService 
 + 	 * returns one of the following error codes : NO _ ERROR , ERROR _ INVALID _ SERVICE _ CONTROL , 
 + 	 * ERROR _ SERVICE _ CANNOT _ ACCEPT _ CTRL , or ERROR _ SERVICE _ NOT _ ACTIVE . Otherwise , 
 + 	 * the structure is not filled in . 
 + 	 * @ return 
 + 	 * If the function succeeds , the return value is true . 
 + 	 * If the function fails , the return value is false . To get extended error information , 
 + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . 
 + 	 * / 
 + 	 public boolean ControlService ( SC _ HANDLE hService , int dwControl , 
 + 	 	 	 SERVICE _ STATUS lpServiceStatus ) ; 
 + 	 
 + 	 
 + 	 / * * 
 + 	 * Starts a service . 
 + 	 * @ param hService 
 + 	 * A handle to the service . This handle is returned by the 
 + 	 * OpenService ( SC _ HANDLE , String , int ) or CreateService ( ) 
 + 	 * function , and it must have the SERVICE _ START access right . For more 
 + 	 * information , see < a href = " http : / / msdn . microsoft . com / en - us / library / ms685981 . aspx " > 
 + 	 * 	 Service Security and Access Rights < / a > . 
 + 	 * @ param dwNumServiceArgs 
 + 	 * The number of strings in the lpServiceArgVectors array . If lpServiceArgVectors 
 + 	 * is NULL , this parameter can be zero . 
 + 	 * @ param lpServiceArgVectors 
 + 	 * The null - terminated strings to be passed to the ServiceMain function for the 
 + 	 * service as arguments . If there are no arguments , this parameter can be null . 
 + 	 * Otherwise , the first argument ( lpServiceArgVectors [ 0 ] ) is the name of the 
 + 	 * service , followed by any additional arguments ( lpServiceArgVectors [ 1 ] through 
 + 	 * lpServiceArgVectors [ dwNumServiceArgs - 1 ] ) . 
 + 	 * Driver services do not receive these arguments . 
 + 	 * @ return 
 + 	 * If the function succeeds , the return value is true . 
 + 	 * If the function fails , the return value is false . To get extended error information , 
 + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . 
 + 	 * / 
 + 	 public boolean StartService ( SC _ HANDLE hService , int dwNumServiceArgs , 
 + 	 	 	 String [ ] lpServiceArgVectors ) ; 
 + 	 
 + 	 / * * 
 + 	 * Closes a handle to a service control manager or service object . 
 + 	 * @ param hSCObject 
 + 	 * A handle to the service control manager object or the service object to 
 + 	 * close . Handles to service control manager objects are returned by the 
 + 	 * OpenSCManager ( String , String , int ) function , and handles to service 
 + 	 * objects are returned by either the OpenService ( SC _ HANDLE , String , int ) 
 + 	 * or CreateService ( ) function . 
 + 	 * @ return 
 + 	 * If the function succeeds , the return value is nonzero . 
 + 	 * If the function fails , the return value is zero . To get extended 
 + 	 * error information , call GetLastError . This value is a nonzero error code 
 + 	 * defined in Winerror . h . 
 + 	 * / 
 + 	 public boolean CloseServiceHandle ( SC _ HANDLE hSCObject ) ; 
 + 
 + 	 / * * 
 + 	 * Opens an existing service . 
 + 	 * @ param hSCManager 
 + 	 * 	 A handle to the service control manager database . The 
 + 	 * 	 OpenSCManager ( String , String , int ) function returns this handle . 
 + 	 * @ param lpServiceName 
 + 	 * 	 The name of the service to be opened . This is the name specified by the 
 + 	 * 	 lpServiceName parameter of the CreateService function when the service 
 + 	 * 	 object was created , not the service display name that is shown by user 
 + 	 * 	 interface applications to identify the service . 
 + 	 * 	 The maximum string length is 256 characters . The service control manager 
 + 	 * 	 database preserves the case of the characters , but service name comparisons 
 + 	 * 	 are always case insensitive . Forward - slash ( / ) and backslash ( \ ) are 
 + 	 * 	 invalid service name characters . 
 + 	 * @ param dwDesiredAccess 
 + 	 * 	 The access to the service . For a list of access rights , see 
 + 	 * 	 < a href = " http : / / msdn . microsoft . com / en - us / library / ms685981 . aspx " > 
 + 	 * 	 Service Security and Access Rights < / a > . 
 + 	 * 	 Before granting the requested access , the system checks the access token 
 + 	 * of the calling process against the discretionary access - control list of the security descriptor associated with the service object . 
 + 	 * @ return 
 + 	 * If the function succeeds , the return value is a handle to the service . 
 + 	 * If the function fails , the return value is NULL . To get extended error information , 
 + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . 
 + 	 * / 
 + 	 public SC _ HANDLE OpenService ( SC _ HANDLE hSCManager , String lpServiceName , int dwDesiredAccess ) ; 
 + 
 + 	 / * * 
 + 	 * Establishes a connection to the service control manager on the specified 
 + 	 * computer and opens the specified service control manager database . 
 + 	 * @ param lpMachineName 
 + 	 * The name of the target computer . If the pointer is NULL or points to 
 + 	 * an empty string , the function connects to the service control manager 
 + 	 * on the local computer . 
 + 	 * @ param lpDatabaseName 
 + 	 * The name of the service control manager database . This parameter should 
 + 	 * be set to SERVICES _ ACTIVE _ DATABASE . If it is NULL , the SERVICES _ ACTIVE _ DATABASE 
 + 	 * database is opened by default . 
 + 	 * @ param dwDesiredAccess 
 + 	 * The access to the service control manager . For a list of access rights , see 
 + 	 * < a href = " http : / / msdn . microsoft . com / en - us / library / ms685981 . aspx " > 
 + 	 * Service Security and Access Rights < / a > . 
 + 	 * Before granting the requested access rights , the system checks the access 
 + 	 * token of the calling process against the discretionary access - control list 
 + 	 * of the security descriptor associated with the service control manager . 
 + 	 * The SC _ MANAGER _ CONNECT access right is implicitly specified by calling this 
 + 	 * function . 
 + 	 * @ return 
 + 	 * If the function succeeds , the return value is a handle to the specified 
 + 	 * service control manager database . 
 + 	 * If the function fails , the return value is NULL . To get extended error information , 
 + 	 * call GetLastError . This value is a nonzero error code defined in Winerror . h . 
 + 	 * / 
 + 	 public SC _ HANDLE OpenSCManager ( String lpMachineName , String lpDatabaseName , int dwDesiredAccess ) ; 
 + 	 
 } 
 diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 index df01ade . . 587014a 100644 
 - - - a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 @ @ - 43 , 7 + 43 , 7 @ @ public interface WinNT extends StdCallLibrary { 
 	 public static final int WRITE _ DAC = 0x00040000 ; 
 	 public static final int WRITE _ OWNER = 0x00080000 ; 
 	 public static final int SYNCHRONIZE = 0x00100000 ; 
 - 
 + 	 
 	 public static final int STANDARD _ RIGHTS _ REQUIRED = 0x000F0000 ; 
 
 	 public static final int STANDARD _ RIGHTS _ READ = READ _ CONTROL ; 
 @ @ - 439 , 7 + 439 , 20 @ @ public interface WinNT extends StdCallLibrary { 
 public static final int FILE _ FLAG _ OPEN _ REPARSE _ POINT = 0x00200000 ; 
 public static final int FILE _ FLAG _ OPEN _ NO _ RECALL = 0x00100000 ; 
 
 - public static final int GENERIC _ WRITE = 0x40000000 ; 
 + 	 / / 
 + 	 / / These are the generic rights . 
 + 	 / / 
 + 
 + 	 public static final int GENERIC _ READ 	 	 = 0x80000000 ; 
 + 	 public static final int GENERIC _ WRITE 	 	 = 0x40000000 ; 
 + 	 public static final int GENERIC _ EXECUTE 	 	 = 0x20000000 ; 
 + 	 public static final int GENERIC _ ALL 	 	 	 = 0x10000000 ; 
 + 	 
 + 	 / / 
 + 	 / / AccessSystemAcl access type 
 + 	 / / 
 + 
 + 	 public static final int ACCESS _ SYSTEM _ SECURITY = 0x01000000 ; 
 
 public static class SECURITY _ ATTRIBUTES extends Structure { 
 public final int nLength = size ( ) ; 
 @ @ - 1524 , 4 + 1537 , 26 @ @ public interface WinNT extends StdCallLibrary { 
 	 	 	 read ( ) ; 
 	 	 } 
 	 } ; 
 + 	 
 + 	 / / 
 + 	 / / Service Types ( Bit Mask ) 
 + 	 / / 
 + 	 public static final int SERVICE _ KERNEL _ DRIVER 	 	 = 0x00000001 ; 
 + 	 public static final int SERVICE _ FILE _ SYSTEM _ DRIVER 	 = 0x00000002 ; 
 + 	 public static final int SERVICE _ ADAPTER 	 	 	 	 = 0x00000004 ; 
 + 	 public static final int SERVICE _ RECOGNIZER _ DRIVER 	 = 0x00000008 ; 
 + 	 
 + 	 public static final int SERVICE _ DRIVER = 
 + 	 	 ( SERVICE _ KERNEL _ DRIVER | SERVICE _ FILE _ SYSTEM _ DRIVER | SERVICE _ RECOGNIZER _ DRIVER ) ; 
 + 	 
 + 	 public static final int SERVICE _ WIN32 _ OWN _ PROCESS 	 = 0x00000010 ; 
 + 	 public static final int SERVICE _ WIN32 _ SHARE _ PROCESS 	 = 0x00000020 ; 
 + 	 
 + 	 public static final int SERVICE _ WIN32 = 
 + 	 	 ( SERVICE _ WIN32 _ OWN _ PROCESS | SERVICE _ WIN32 _ SHARE _ PROCESS ) ; 
 + 	 
 + 	 public static final int SERVICE _ INTERACTIVE _ PROCESS = 0x00000100 ; 
 + 	 
 + 	 public static final int SERVICE _ TYPE _ ALL = 
 + 	 	 ( SERVICE _ WIN32 | SERVICE _ ADAPTER | SERVICE _ DRIVER | SERVICE _ INTERACTIVE _ PROCESS ) ; 
 } 
 \ No newline at end of file 
 diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Winsvc . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Winsvc . java 
 new file mode 100644 
 index 0000000 . . f89d95c 
 - - - / dev / null 
 + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Winsvc . java 
 @ @ - 0 , 0 + 1 , 289 @ @ 
 + / * Copyright ( c ) 2010 EugineLev , All Rights Reserved 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation ; either 
 + * version 2 . 1 of the License , or ( at your option ) any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + 
 + import com . sun . jna . Memory ; 
 + import com . sun . jna . Structure ; 
 + import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 + import com . sun . jna . win32 . StdCallLibrary ; 
 + 
 + / * * 
 + * This module defines the 32 - Bit Windows types and constants that are defined 
 + * by NT , but exposed through the Win32 API . 
 + * Ported from Winsvc . h . 
 + * Microsoft Windows SDK 7 . 0A . 
 + * @ author EugineLev 
 + * / 
 + public interface Winsvc extends StdCallLibrary { 	 
 + 
 + 	 / * * 
 + 	 * Contains status information for a service . The ControlService , EnumDependentServices , 
 + 	 * EnumServicesStatus , and QueryServiceStatus functions use this structure . A service 
 + 	 * uses this structure in the SetServiceStatus function to report its current status 
 + 	 * to the service control manager . 
 + 	 * / 
 + 	 public static class SERVICE _ STATUS extends Structure { 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwServiceType - the type of service . This member can be one 
 + 	 	 * of the following values : 
 + 	 	 * SERVICE _ KERNEL _ DRIVER , SERVICE _ FILE _ SYSTEM _ DRIVER , 
 + 	 	 * SERVICE _ WIN32 _ OWN _ PROCESS , SERVICE _ WIN32 _ SHARE _ PROCESS , 
 + 
 + 	 	 * If the service type is either SERVICE _ WIN32 _ OWN _ PROCESS or 
 + 	 	 * SERVICE _ WIN32 _ SHARE _ PROCESS , and the service is running in the 
 + 	 	 * context of the LocalSystem account , the following type may also 
 + 	 	 * be specified : 
 + 	 	 * SERVICE _ INTERACTIVE _ PROCESS 
 + 	 	 * 
 + 	 	 * These values can be found in WinNT . h 
 + 	 	 * / 
 + 	 	 public int dwServiceType ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwCurrentState - The current state of the service . 
 + 	 	 * This member can be one of the following values : 
 + 	 	 * SERVICE _ STOPPED , SERVICE _ START _ PENDING , SERVICE _ STOP _ PENDING , SERVICE _ RUNNING , 
 + 	 	 * SERVICE _ CONTINUE _ PENDING , SERVICE _ PAUSE _ PENDING , SERVICE _ PAUSED 	 
 + 	 	 * / 
 + 	 	 public int dwCurrentState ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwControlsAccepted - The control codes the service accepts and processes 
 + 	 	 * in its handler function : 
 + 	 	 * SERVICE _ ACCEPT _ STOP , SERVICE _ ACCEPT _ PAUSE _ CONTINUE , SERVICE _ ACCEPT _ SHUTDOWN , 
 + 	 	 * SERVICE _ ACCEPT _ PARAMCHANGE , SERVICE _ ACCEPT _ NETBINDCHANGE , SERVICE _ ACCEPT _ HARDWAREPROFILECHANGE , 
 + 	 	 * SERVICE _ ACCEPT _ POWEREVENT , SERVICE _ ACCEPT _ SESSIONCHANGE , SERVICE _ ACCEPT _ PRESHUTDOWN , 
 + 	 	 * SERVICE _ ACCEPT _ TIMECHANGE , SERVICE _ ACCEPT _ TRIGGEREVENT 
 + 	 	 * / 
 + 	 	 public int dwControlsAccepted ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwWin32ExitCode - The error code the service uses to report an error that occurs 
 + 	 	 * when it is starting or stopping . To return an error code specific to the service , 
 + 	 	 * the service must set this value to ERROR _ SERVICE _ SPECIFIC _ ERROR to indicate that 
 + 	 	 * the dwServiceSpecificExitCode member contains the error code . The service should 
 + 	 	 * set this value to NO _ ERROR when it is running and on normal termination . 
 + 	 	 * / 
 + 	 	 public int dwWin32ExitCode ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwServiceSpecificExitCode - A service - specific error code that the service returns 
 + 	 	 * when an error occurs while the service is starting or stopping . This value is 
 + 	 	 * ignored unless the dwWin32ExitCode member is set to ERROR _ SERVICE _ SPECIFIC _ ERROR . 
 + 	 	 * / 
 + 	 	 public int dwServiceSpecificExitCode ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwCheckPoint - The check - point value the service increments periodically to report 
 + 	 	 * its progress during a lengthy start , stop , pause , or continue operation . 
 + 	 	 * / 
 + 	 	 public int dwCheckPoint ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwWaitHint - The estimated time required for a pending start , stop , pause , or continue 
 + 	 	 * operation , in milliseconds . 
 + 	 	 * / 
 + 	 	 public int dwWaitHint ; 
 + 
 + 	 	 public SERVICE _ STATUS ( ) { 
 + 	 	 	 super ( ) ; 
 + 	 	 } 
 + 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * Contains process status information for a service . The ControlServiceEx , 
 + 	 * EnumServicesStatusEx , NotifyServiceStatusChange , and QueryServiceStatusEx 
 + 	 * functions use this structure . 
 + 	 * / 
 + 	 public class SERVICE _ STATUS _ PROCESS extends Structure { 
 + 	 	 / * * 
 + 	 	 * dwServiceType - the type of service . This member can be one 
 + 	 	 * of the following values : 
 + 	 	 * SERVICE _ KERNEL _ DRIVER , SERVICE _ FILE _ SYSTEM _ DRIVER , 
 + 	 	 * SERVICE _ WIN32 _ OWN _ PROCESS , SERVICE _ WIN32 _ SHARE _ PROCESS , 
 + 
 + 	 	 * If the service type is either SERVICE _ WIN32 _ OWN _ PROCESS or 
 + 	 	 * SERVICE _ WIN32 _ SHARE _ PROCESS , and the service is running in the 
 + 	 	 * context of the LocalSystem account , the following type may also 
 + 	 	 * be specified : 
 + 	 	 * SERVICE _ INTERACTIVE _ PROCESS 
 + 	 	 * 
 + 	 	 * These values can be found in WinNT . h 
 + 	 	 * / 
 + 	 	 public int dwServiceType ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwCurrentState - The current state of the service . 
 + 	 	 * This member can be one of the following values : 
 + 	 	 * SERVICE _ STOPPED , SERVICE _ START _ PENDING , SERVICE _ STOP _ PENDING , SERVICE _ RUNNING , 
 + 	 	 * SERVICE _ CONTINUE _ PENDING , SERVICE _ PAUSE _ PENDING , SERVICE _ PAUSED 	 
 + 	 	 * / 
 + 	 	 public int dwCurrentState ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwControlsAccepted - The control codes the service accepts and processes 
 + 	 	 * in its handler function : 
 + 	 	 * SERVICE _ ACCEPT _ STOP , SERVICE _ ACCEPT _ PAUSE _ CONTINUE , SERVICE _ ACCEPT _ SHUTDOWN , 
 + 	 	 * SERVICE _ ACCEPT _ PARAMCHANGE , SERVICE _ ACCEPT _ NETBINDCHANGE , SERVICE _ ACCEPT _ HARDWAREPROFILECHANGE , 
 + 	 	 * SERVICE _ ACCEPT _ POWEREVENT , SERVICE _ ACCEPT _ SESSIONCHANGE , SERVICE _ ACCEPT _ PRESHUTDOWN , 
 + 	 	 * SERVICE _ ACCEPT _ TIMECHANGE , SERVICE _ ACCEPT _ TRIGGEREVENT 
 + 	 	 * / 
 + 	 	 public int dwControlsAccepted ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwWin32ExitCode - The error code the service uses to report an error that occurs 
 + 	 	 * when it is starting or stopping . To return an error code specific to the service , 
 + 	 	 * the service must set this value to ERROR _ SERVICE _ SPECIFIC _ ERROR to indicate that 
 + 	 	 * the dwServiceSpecificExitCode member contains the error code . The service should 
 + 	 	 * set this value to NO _ ERROR when it is running and on normal termination . 
 + 	 	 * / 
 + 	 	 public int dwWin32ExitCode ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwServiceSpecificExitCode - A service - specific error code that the service returns 
 + 	 	 * when an error occurs while the service is starting or stopping . This value is 
 + 	 	 * ignored unless the dwWin32ExitCode member is set to ERROR _ SERVICE _ SPECIFIC _ ERROR . 
 + 	 	 * / 
 + 	 	 public int dwServiceSpecificExitCode ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwCheckPoint - The check - point value the service increments periodically to report 
 + 	 	 * its progress during a lengthy start , stop , pause , or continue operation . 
 + 	 	 * / 
 + 	 	 public int dwCheckPoint ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwWaitHint - The estimated time required for a pending start , stop , pause , or continue 
 + 	 	 * operation , in milliseconds . 
 + 	 	 * / 
 + 	 	 public int dwWaitHint ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * dwProcessId - The process identifier of the service . 
 + 	 	 * / 
 + 	 	 public int dwProcessId ; 
 + 	 	 
 + 	 	 / * * 
 + 	 	 * This member can be one of the following values : 0 , or SERVICE _ RUNS _ IN _ SYSTEM _ PROCESS 
 + 	 	 * / 
 + 	 	 public int dwServiceFlags ; 
 + 	 	 
 + 	 	 public SERVICE _ STATUS _ PROCESS ( ) { 
 + 	 	 } 
 + 	 	 
 + 	 	 public SERVICE _ STATUS _ PROCESS ( int size ) { 
 + 	 	 	 super ( new Memory ( size ) ) ; 
 + 	 	 } 
 + 	 } 
 + 	 
 + 	 / / 
 + 	 / / Service flags for QueryServiceStatusEx 
 + 	 / / 
 + 	 public static final int SERVICE _ RUNS _ IN _ SYSTEM _ PROCESS = 0x00000001 ; 
 + 	 
 + 	 public static class SC _ HANDLE extends HANDLE { } 
 + 	 
 + 	 / / 
 + 	 / / Service Control Manager object specific access types 
 + 	 / / 
 + 	 public static final int SC _ MANAGER _ CONNECT 	 	 	 	 = 0x0001 ; 
 + 	 public static final int SC _ MANAGER _ CREATE _ SERVICE 	 	 = 0x0002 ; 
 + 	 public static final int SC _ MANAGER _ ENUMERATE _ SERVICE 	 = 0x0004 ; 
 + 	 public static final int SC _ MANAGER _ LOCK 	 	 	 	 	 = 0x0008 ; 
 + 	 public static final int SC _ MANAGER _ QUERY _ LOCK _ STATUS 	 = 0x0010 ; 
 + 	 public static final int SC _ MANAGER _ MODIFY _ BOOT _ CONFIG 	 = 0x0020 ; 
 + 
 + 	 public static final int SC _ MANAGER _ ALL _ ACCESS = 
 + 	 	 WinNT . STANDARD _ RIGHTS _ REQUIRED | SC _ MANAGER _ CONNECT 
 + 	 	 | SC _ MANAGER _ CREATE _ SERVICE | SC _ MANAGER _ ENUMERATE _ SERVICE 
 + 	 	 | SC _ MANAGER _ LOCK | SC _ MANAGER _ QUERY _ LOCK _ STATUS 
 + 	 	 | SC _ MANAGER _ MODIFY _ BOOT _ CONFIG ; 
 + 
 + 	 / / 
 + 	 / / Service object specific access type 
 + 	 / / 
 + 	 public static final int SERVICE _ QUERY _ CONFIG 	 	 	 = 0x0001 ; 
 + 	 public static final int SERVICE _ CHANGE _ CONFIG 	 	 	 = 0x0002 ; 
 + 	 public static final int SERVICE _ QUERY _ STATUS 	 	 	 = 0x0004 ; 
 + 	 public static final int SERVICE _ ENUMERATE _ DEPENDENTS 	 = 0x0008 ; 
 + 	 public static final int SERVICE _ START 	 	 	 	 	 = 0x0010 ; 
 + 	 public static final int SERVICE _ STOP 	 	 	 	 	 = 0x0020 ; 
 + 	 public static final int SERVICE _ PAUSE _ CONTINUE 	 	 	 = 0x0040 ; 
 + 	 public static final int SERVICE _ INTERROGATE 	 	 	 	 = 0x0080 ; 
 + 	 public static final int SERVICE _ USER _ DEFINED _ CONTROL 	 = 0x0100 ; 
 + 
 + 	 public static final int SERVICE _ ALL _ ACCESS = 
 + 	 	 WinNT . STANDARD _ RIGHTS _ REQUIRED | SERVICE _ QUERY _ CONFIG 
 + 	 	 | SERVICE _ CHANGE _ CONFIG | SERVICE _ QUERY _ STATUS 
 + 	 	 | SERVICE _ ENUMERATE _ DEPENDENTS | SERVICE _ START | SERVICE _ STOP 
 + 	 	 | SERVICE _ PAUSE _ CONTINUE | SERVICE _ INTERROGATE 
 + 	 	 | SERVICE _ USER _ DEFINED _ CONTROL ; 
 + 
 + 	 / / 
 + 	 / / Controls 
 + 	 / / 
 + 	 public static final int SERVICE _ CONTROL _ STOP 	 	 	 = 0x00000001 ; 
 + 	 public static final int SERVICE _ CONTROL _ PAUSE 	 	 	 = 0x00000002 ; 
 + 	 public static final int SERVICE _ CONTROL _ CONTINUE 	 	 = 0x00000003 ; 
 + 	 public static final int SERVICE _ CONTROL _ INTERROGATE 	 = 0x00000004 ; 
 + / / 	 public static final int SERVICE _ CONTROL _ SHUTDOWN 	 	 = 0x00000005 ; 
 + 	 public static final int SERVICE _ CONTROL _ PARAMCHANGE 	 = 0x00000006 ; 
 + 	 public static final int SERVICE _ CONTROL _ NETBINDADD 	 	 = 0x00000007 ; 
 + 	 public static final int SERVICE _ CONTROL _ NETBINDREMOVE 	 = 0x00000008 ; 
 + 	 public static final int SERVICE _ CONTROL _ NETBINDENABLE 	 = 0x00000009 ; 
 + 	 public static final int SERVICE _ CONTROL _ NETBINDDISABLE 	 = 0x0000000A ; 
 + / / 	 public static final int SERVICE _ CONTROL _ DEVICEEVENT 	 	 = 0x0000000B ; 
 + / / 	 public static final int SERVICE _ CONTROL _ HARDWAREPROFILECHANGE = 0x0000000C ; 
 + / / 	 public static final int SERVICE _ CONTROL _ POWEREVENT 	 	 = 0x0000000D ; 
 + / / 	 public static final int SERVICE _ CONTROL _ SESSIONCHANGE 	 = 0x0000000E ; 
 + / / 	 public static final int SERVICE _ CONTROL _ PRESHUTDOWN 	 	 = 0x0000000F ; 
 + / / 	 public static final int SERVICE _ CONTROL _ TIMECHANGE 	 	 = 0x00000010 ; 
 + / / 	 public static final int SERVICE _ CONTROL _ TRIGGEREVENT 	 = 0x00000020 ; 
 + 	 
 + 	 / / 
 + 	 / / Service State - - for CurrentState 
 + 	 / / 
 + 	 public static final int SERVICE _ STOPPED 	 	 	 	 = 0x00000001 ; 
 + 	 public static final int SERVICE _ START _ PENDING 	 	 = 0x00000002 ; 
 + 	 public static final int SERVICE _ STOP _ PENDING 	 	 = 0x00000003 ; 
 + 	 public static final int SERVICE _ RUNNING 	 	 	 	 = 0x00000004 ; 
 + 	 public static final int SERVICE _ CONTINUE _ PENDING 	 = 0x00000005 ; 
 + 	 public static final int SERVICE _ PAUSE _ PENDING 	 	 = 0x00000006 ; 
 + 	 public static final int SERVICE _ PAUSED 	 	 	 	 = 0x00000007 ; 
 + 
 + 	 / / 
 + 	 / / Controls Accepted ( Bit Mask ) 
 + 	 / / 
 + 	 public static final int SERVICE _ ACCEPT _ STOP 	 	 	 	 	 	 = 0x00000001 ; 
 + 	 public static final int SERVICE _ ACCEPT _ PAUSE _ CONTINUE 	 	 	 = 0x00000002 ; 
 + 	 public static final int SERVICE _ ACCEPT _ SHUTDOWN 	 	 	 	 	 = 0x00000004 ; 
 + 	 public static final int SERVICE _ ACCEPT _ PARAMCHANGE 	 	 	 	 = 0x00000008 ; 
 + 	 public static final int SERVICE _ ACCEPT _ NETBINDCHANGE 	 	 	 = 0x00000010 ; 
 + 	 public static final int SERVICE _ ACCEPT _ HARDWAREPROFILECHANGE 	 = 0x00000020 ; 
 + 	 public static final int SERVICE _ ACCEPT _ POWEREVENT 	 	 	 	 = 0x00000040 ; 
 + 	 public static final int SERVICE _ ACCEPT _ SESSIONCHANGE 	 	 	 = 0x00000080 ; 
 + 	 public static final int SERVICE _ ACCEPT _ PRESHUTDOWN 	 	 	 	 = 0x00000100 ; 
 + 	 public static final int SERVICE _ ACCEPT _ TIMECHANGE 	 	 	 	 = 0x00000200 ; 
 + 	 public static final int SERVICE _ ACCEPT _ TRIGGEREVENT 	 	 	 	 = 0x00000400 ; 
 + 	 
 + 	 / * * 
 + 	 * The SC _ STATUS _ TYPE enumeration type contains values 
 + 	 * / 
 + 	 public abstract class SC _ STATUS _ TYPE { 
 + 	 	 public static final int SC _ STATUS _ PROCESS _ INFO = 0 ; 
 + 	 } 
 + 
 + } 
 diff - - git a / jnalib / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / jnalib / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 index bb9a447 . . 867702d 100644 
 - - - a / jnalib / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 + + + b / jnalib / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 @ @ - 31 , 6 + 31 , 9 @ @ import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; 
 import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; 
 import com . sun . jna . platform . win32 . WinNT . WELL _ KNOWN _ SID _ TYPE ; 
 import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 + import com . sun . jna . platform . win32 . Winsvc . SC _ HANDLE ; 
 + import com . sun . jna . platform . win32 . Winsvc . SC _ STATUS _ TYPE ; 
 + import com . sun . jna . platform . win32 . Winsvc . SERVICE _ STATUS _ PROCESS ; 
 import com . sun . jna . ptr . IntByReference ; 
 import com . sun . jna . ptr . PointerByReference ; 
 
 @ @ - 620 , 5 + 623 , 106 @ @ public class Advapi32Test extends TestCase { 
 	 assertTrue ( Advapi32 . INSTANCE . GetOldestEventLogRecord ( h , oldestRecord ) ) ; 
 	 assertTrue ( oldestRecord . getValue ( ) > = 0 ) ; 
 	 assertTrue ( Advapi32 . INSTANCE . CloseEventLog ( h ) ) ; 
 - } 
 + } 
 + 
 + public void testQueryServiceStatusEx ( ) { 
 + 
 + 	 SC _ HANDLE scmHandle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; 
 + 	 assertNotNull ( scmHandle ) ; 
 + 
 + 	 SC _ HANDLE serviceHandle = Advapi32 . INSTANCE . OpenService ( scmHandle , " eventlog " , Winsvc . SERVICE _ QUERY _ STATUS ) ; 
 + 	 assertNotNull ( serviceHandle ) ; 
 + 
 + 	 IntByReference pcbBytesNeeded = new IntByReference ( ) ; 
 + 
 + 	 assertFalse ( Advapi32 . INSTANCE . QueryServiceStatusEx ( serviceHandle , SC _ STATUS _ TYPE . SC _ STATUS _ PROCESS _ INFO , 
 + 	 	 	 null , 0 , pcbBytesNeeded ) ) ; 
 + 	 assertEquals ( W32Errors . ERROR _ INSUFFICIENT _ BUFFER , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + 	 
 + 	 assertTrue ( pcbBytesNeeded . getValue ( ) > 0 ) ; 
 + 
 + 	 SERVICE _ STATUS _ PROCESS status = new SERVICE _ STATUS _ PROCESS ( pcbBytesNeeded . getValue ( ) ) ; 
 + 
 + 	 assertTrue ( Advapi32 . INSTANCE . QueryServiceStatusEx ( serviceHandle , SC _ STATUS _ TYPE . SC _ STATUS _ PROCESS _ INFO , 
 + 	 	 	 status , status . size ( ) , pcbBytesNeeded ) ) ; 
 + 
 + 	 assertTrue ( status . dwCurrentState = = Winsvc . SERVICE _ STOPPED | | 
 + 	 	 	 status . dwCurrentState = = Winsvc . SERVICE _ RUNNING ) ; 
 + 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( serviceHandle ) ) ; 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( scmHandle ) ) ; 
 + } 
 + 
 + 
 + public void testControlService ( ) { 
 + 	 SC _ HANDLE scmHandle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; 
 + 	 assertNotNull ( scmHandle ) ; 
 + 
 + 	 SC _ HANDLE serviceHandle = Advapi32 . INSTANCE . OpenService ( scmHandle , " eventlog " , Winsvc . SERVICE _ QUERY _ CONFIG ) ; 
 + 	 assertNotNull ( serviceHandle ) ; 
 + 
 + 	 Winsvc . SERVICE _ STATUS serverStatus = new Winsvc . SERVICE _ STATUS ( ) ; 
 + 
 + 	 assertNotNull ( serviceHandle ) ; 
 + 	 assertFalse ( Advapi32 . INSTANCE . ControlService ( serviceHandle , Winsvc . SERVICE _ CONTROL _ STOP , serverStatus ) ) ; 
 + 	 assertEquals ( W32Errors . ERROR _ ACCESS _ DENIED , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( serviceHandle ) ) ; 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( scmHandle ) ) ; 
 + } 
 + 
 + public void testStartService ( ) { 
 + 	 SC _ HANDLE scmHandle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; 
 + 	 assertNotNull ( scmHandle ) ; 
 + 	 
 + 	 SC _ HANDLE serviceHandle = Advapi32 . INSTANCE . OpenService ( scmHandle , " Wecsvc " , Winsvc . SERVICE _ QUERY _ CONFIG ) ; 
 + 	 assertNotNull ( serviceHandle ) ; 
 + 	 
 + 	 assertFalse ( Advapi32 . INSTANCE . StartService ( serviceHandle , 0 , null ) ) ; 
 + 	 assertEquals ( W32Errors . ERROR _ ACCESS _ DENIED , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( serviceHandle ) ) ; 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( scmHandle ) ) ; 
 + } 
 + 
 + public void testOpenService ( ) { 
 + 	 assertNull ( Advapi32 . INSTANCE . OpenService ( null , " eventlog " , Winsvc . SERVICE _ QUERY _ CONFIG ) ) ; 
 + 	 assertEquals ( W32Errors . ERROR _ INVALID _ HANDLE , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + 
 + 	 SC _ HANDLE scmHandle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; 
 + 	 assertNotNull ( scmHandle ) ; 
 + 	 
 + 	 SC _ HANDLE serviceHandle = Advapi32 . INSTANCE . OpenService ( scmHandle , " eventlog " , Winsvc . SERVICE _ QUERY _ CONFIG ) ; 
 + 	 assertNotNull ( serviceHandle ) ; 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( serviceHandle ) ) ; 
 + 
 + 	 assertNull ( Advapi32 . INSTANCE . OpenService ( scmHandle , " slashesArentValidChars / " , Winsvc . SERVICE _ QUERY _ CONFIG ) ) ; 
 + 	 assertEquals ( W32Errors . ERROR _ INVALID _ NAME , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + 
 + 	 assertNull ( Advapi32 . INSTANCE . OpenService ( scmHandle , " serviceDoesNotExist " , Winsvc . SERVICE _ QUERY _ CONFIG ) ) ; 
 + 	 assertEquals ( W32Errors . ERROR _ SERVICE _ DOES _ NOT _ EXIST , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( scmHandle ) ) ; 
 + } 
 + 
 + public void testOpenSCManager ( ) { 
 + 	 SC _ HANDLE handle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; 
 + 	 assertNotNull ( handle ) ; 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( handle ) ) ; 
 + 	 
 + 	 assertNull ( Advapi32 . INSTANCE . OpenSCManager ( " invalidMachineName " , null , Winsvc . SC _ MANAGER _ CONNECT ) ) ; 
 + 	 assertEquals ( W32Errors . RPC _ S _ SERVER _ UNAVAILABLE , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + 
 + 	 assertNull ( Advapi32 . INSTANCE . OpenSCManager ( null , " invalidDatabase " , Winsvc . SC _ MANAGER _ CONNECT ) ) ; 
 + 	 assertEquals ( W32Errors . ERROR _ INVALID _ NAME , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + 
 + public void testCloseServiceHandle ( ) throws Exception { 
 + 	 SC _ HANDLE handle = Advapi32 . INSTANCE . OpenSCManager ( null , null , Winsvc . SC _ MANAGER _ CONNECT ) ; 
 + 	 assertNotNull ( handle ) ; 
 + 	 assertTrue ( Advapi32 . INSTANCE . CloseServiceHandle ( handle ) ) ; 
 + 	 
 + 	 assertFalse ( Advapi32 . INSTANCE . CloseServiceHandle ( null ) ) ; 
 + 	 assertEquals ( W32Errors . ERROR _ INVALID _ HANDLE , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 } 
 diff - - git a / jnalib / release - notes . html b / jnalib / release - notes . html 
 index 5246818 . . 4baaa06 100755 
 - - - a / jnalib / release - notes . html 
 + + + b / jnalib / release - notes . html 
 @ @ - 3 , 6 + 3 , 7 @ @ 
 < h3 > Features < / h3 > 
 < ul > 
 < li > Add < code > platform . win32 . Kernel32 . DeleteFile < / code > and < code > com . sun . jna . platform . win32 . deleteFile < / code > . 
 + < li > Add Win32 Service functions to < code > platform . win32 . Advapi32 < / code > . 
 < li > Add Win32 Event Logging functions to < code > platform . win32 . Advapi32 < / code > and < code > platform . win32 . Advapi32Util . EventLogIterator < / code > . 
 < li > < code > platform . win32 . Advapi32Util . registryCreateKey < / code > returns < code > true < / code > if key was created , < code > false < / code > if it already exists . 
 < / ul >
