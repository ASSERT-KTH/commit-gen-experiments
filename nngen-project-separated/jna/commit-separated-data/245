BLEU SCORE: 0.027611988917697356

TEST MSG: Ensure TLS index is cleared after storage freed
GENERATED MSG: auto - cleanup of attached callback threads

TEST DIFF (one line): diff - - git a / lib / native / win32 - x86 - 64 . jar b / lib / native / win32 - x86 - 64 . jar <nl> index 1594cf5 . . d9f2002 100755 <nl> Binary files a / lib / native / win32 - x86 - 64 . jar and b / lib / native / win32 - x86 - 64 . jar differ <nl> diff - - git a / lib / native / win32 - x86 . jar b / lib / native / win32 - x86 . jar <nl> index eef4f08 . . 7ff3305 100755 <nl> Binary files a / lib / native / win32 - x86 . jar and b / lib / native / win32 - x86 . jar differ <nl> diff - - git a / native / callback . c b / native / callback . c <nl> index a4341c1 . . 057d1bd 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 592 , 6 + 592 , 7 @ @ BOOL WINAPI DllMain ( HINSTANCE hDLL , DWORD fdwReason , LPVOID lpvReserved ) { <nl> thread _ storage * tls = ( thread _ storage * ) TlsGetValue ( tls _ thread _ data _ key ) ; <nl> if ( tls ) { <nl> dispose _ thread _ data ( tls ) ; <nl> + TlsSetValue ( tls _ thread _ data _ key , 0 ) ; <nl> } <nl> break ; <nl> } <nl> diff - - git a / test / com / sun / jna / LastErrorTest . java b / test / com / sun / jna / LastErrorTest . java <nl> index 53e545a . . 064d100 100644 <nl> - - - a / test / com / sun / jna / LastErrorTest . java <nl> + + + b / test / com / sun / jna / LastErrorTest . java <nl> @ @ - 14 , 6 + 14 , 8 @ @ package com . sun . jna ; <nl> <nl> import java . util . Map ; <nl> import java . util . HashMap ; <nl> + import java . util . Set ; <nl> + import java . util . HashSet ; <nl> import java . lang . reflect . Method ; <nl> <nl> import junit . framework . TestCase ; <nl> @ @ - 50 , 22 + 52 , 30 @ @ public class LastErrorTest extends TestCase { <nl> <nl> public void testLastErrorPerThreadStorage ( ) throws Exception { <nl> final TestLibrary lib = ( TestLibrary ) Native . loadLibrary ( " testlib " , TestLibrary . class ) ; <nl> - final int [ ] errors = new int [ 2 ] ; <nl> - Thread t1 = new Thread ( ) { public void run ( ) { <nl> - lib . setLastError ( - 1 ) ; <nl> - errors [ 0 ] = Native . getLastError ( ) ; <nl> - } } ; <nl> - Thread t2 = new Thread ( ) { public void run ( ) { <nl> - lib . setLastError ( - 2 ) ; <nl> - errors [ 1 ] = Native . getLastError ( ) ; <nl> - } } ; <nl> - lib . setLastError ( - 3 ) ; <nl> - <nl> - t1 . start ( ) ; t2 . start ( ) ; <nl> - t1 . join ( ) ; t2 . join ( ) ; <nl> - assertEquals ( " Wrong error on main thread " , - 3 , Native . getLastError ( ) ) ; <nl> - assertEquals ( " Wrong error on first thread " , - 1 , errors [ 0 ] ) ; <nl> - assertEquals ( " Wrong error on second thread " , - 2 , errors [ 1 ] ) ; <nl> + final int NTHREADS = 100 ; <nl> + final int [ ] errors = new int [ NTHREADS ] ; <nl> + Set < Thread > threads = new HashSet < Thread > ( ) ; <nl> + for ( int i = 0 ; i < NTHREADS ; i + + ) { <nl> + final int idx = i ; <nl> + Thread t = new Thread ( ) { public void run ( ) { <nl> + lib . setLastError ( - idx - 1 ) ; <nl> + errors [ idx ] = Native . getLastError ( ) ; <nl> + } } ; <nl> + threads . add ( t ) ; <nl> + } <nl> + int EXPECTED = 42 ; <nl> + lib . setLastError ( EXPECTED ) ; <nl> + assertEquals ( " Wrong error on main thread ( immediate ) " , EXPECTED , Native . getLastError ( ) ) ; <nl> + for ( Thread t : threads ) { <nl> + t . start ( ) ; <nl> + } <nl> + for ( Thread t : threads ) { <nl> + t . join ( ) ; <nl> + } <nl> + assertEquals ( " Wrong error on main thread " , EXPECTED , Native . getLastError ( ) ) ; <nl> + for ( int i = 0 ; i < threads . size ( ) ; i + + ) { <nl> + assertEquals ( " Wrong error on thread " + i , - i - 1 , errors [ i ] ) ; <nl> + } <nl> } <nl> <nl> private final int ERROR = Platform . isWindows ( ) ? 1 : - 1 ;
NEAREST DIFF (one line): diff - - git a / native / Makefile b / native / Makefile <nl> index 070dcb6 . . 480979f 100644 <nl> - - - a / native / Makefile <nl> + + + b / native / Makefile <nl> @ @ - 284 , 7 + 284 , 7 @ @ endif <nl> # Unfortunately , we have to use different libffi include files depending on <nl> # the target , so we can ' t do a simple universal build on darwin . Do <nl> # separate builds , then merge the results . <nl> - $ ( BUILD ) / % . o : % . c dispatch . h thread . h protect . h $ ( FFI _ LIB ) <nl> + $ ( BUILD ) / % . o : % . c dispatch . h protect . h $ ( FFI _ LIB ) <nl> 	 @ mkdir - p $ ( BUILD ) <nl> ifneq ( $ ( SDKROOT ) , ) <nl> 	 $ ( CC ) - arch $ ( ARCH ) $ ( CFLAGS ) - c $ < - o $ @ . $ ( ARCH ) <nl> diff - - git a / native / callback . c b / native / callback . c <nl> index b3e6fd0 . . 1e971b1 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 25 , 7 + 25 , 6 @ @ <nl> # include < sys / param . h > <nl> # endif <nl> # include " dispatch . h " <nl> - # include " thread . h " <nl> <nl> # ifdef _ _ cplusplus <nl> extern " C " { <nl> @ @ - 389 , 10 + 388 , 19 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar <nl> } <nl> } <nl> <nl> - # ifdef THREAD _ EXIT _ CLEANUP <nl> - static void <nl> - detach _ thread ( void * data ) { <nl> - THREAD _ EXIT _ CLEANUP ( data ) ; <nl> + # ifndef _ WIN32 <nl> + # include < pthread . h > <nl> + <nl> + static pthread _ key _ t key ; <nl> + static pthread _ once _ t key _ once = PTHREAD _ ONCE _ INIT ; <nl> + <nl> + static void detach _ thread ( void * data ) { <nl> + JavaVM * jvm = ( JavaVM * ) data ; <nl> + ( * jvm ) - > DetachCurrentThread ( jvm ) ; <nl> + } <nl> + <nl> + static void make _ key ( ) { <nl> + pthread _ key _ create ( & key , detach _ thread ) ; <nl> } <nl> # endif <nl> <nl> @ @ - 460 , 8 + 468 , 11 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> ( * jvm ) - > DetachCurrentThread ( jvm ) ; <nl> } <nl> else if ( ! was _ attached ) { <nl> - # ifdef ON _ THREAD _ EXIT <nl> - ON _ THREAD _ EXIT ( detach _ thread , jvm ) ; <nl> + # ifndef _ WIN32 <nl> + pthread _ once ( & key _ once , make _ key ) ; <nl> + if ( pthread _ getspecific ( key ) = = NULL ) { <nl> + pthread _ setspecific ( key , jvm ) ; <nl> + } <nl> # endif <nl> } <nl> } <nl> diff - - git a / native / thread . h b / native / thread . h <nl> deleted file mode 100644 <nl> index 2ab1b18 . . 0000000 <nl> - - - a / native / thread . h <nl> + + + / dev / null <nl> @ @ - 1 , 51 + 0 , 0 @ @ <nl> - / * Copyright ( c ) 20012 Timothy Wall , All Rights Reserved <nl> - * <nl> - * This library is free software ; you can redistribute it and / or <nl> - * modify it under the terms of the GNU Lesser General Public <nl> - * License as published by the Free Software Foundation ; either <nl> - * version 2 . 1 of the License , or ( at your option ) any later version . <nl> - * < p / > <nl> - * This library is distributed in the hope that it will be useful , <nl> - * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> - * / <nl> - # ifndef THREAD _ H <nl> - # define THREAD _ H <nl> - <nl> - # ifndef _ WIN32 <nl> - <nl> - # include < pthread . h > <nl> - <nl> - # ifdef _ _ APPLE _ _ <nl> - struct _ thread _ cleanup _ data { <nl> - struct _ _ darwin _ pthread _ handler _ rec * _ _ handler ; <nl> - JavaVM * _ _ jvm ; <nl> - } ; <nl> - # define THREAD _ EXIT _ CLEANUP ( DATA ) do { \ <nl> - struct _ thread _ cleanup _ data * _ _ data = ( struct _ thread _ cleanup _ data * ) DATA ; \ <nl> - pthread _ t _ _ self = pthread _ self ( ) ; \ <nl> - fprintf ( stderr , " detach thread % p \ n " , _ _ self ) ; \ <nl> - _ _ self - > _ _ cleanup _ stack = _ _ data - > _ _ handler - > _ _ next ; \ <nl> - ( * ( _ _ data - > _ _ jvm ) ) - > DetachCurrentThread ( _ _ data - > _ _ jvm ) ; \ <nl> - / * free ( _ _ data - > _ _ handler ) ; * / \ <nl> - free ( _ _ data ) ; \ <nl> - fprintf ( stderr , " detach thread % p done \ n " , _ _ self ) ; \ <nl> - } while ( 0 ) <nl> - # define ON _ THREAD _ EXIT ( PROC , JVM ) do { \ <nl> - struct _ thread _ cleanup _ data * _ _ data = ( struct _ thread _ cleanup _ data * ) malloc ( sizeof ( struct _ thread _ cleanup _ data ) ) ; \ <nl> - struct _ _ darwin _ pthread _ handler _ rec * _ _ handler = \ <nl> - ( struct _ _ darwin _ pthread _ handler _ rec * ) malloc ( sizeof ( struct _ _ darwin _ pthread _ handler _ rec ) ) ; \ <nl> - pthread _ t _ _ self = pthread _ self ( ) ; \ <nl> - _ _ handler - > _ _ routine = PROC ; \ <nl> - _ _ handler - > _ _ arg = _ _ data ; \ <nl> - _ _ handler - > _ _ next = _ _ self - > _ _ cleanup _ stack ; \ <nl> - _ _ self - > _ _ cleanup _ stack = _ _ handler ; \ <nl> - _ _ data - > _ _ handler = _ _ handler ; \ <nl> - _ _ data - > _ _ jvm = JVM ; \ <nl> - } while ( 0 ) <nl> - # endif / * _ _ APPLE _ _ * / <nl> - <nl> - # endif / * ! _ WIN32 * / <nl> - <nl> - # endif / * THREAD _ H * /

TEST DIFF:
diff - - git a / lib / native / win32 - x86 - 64 . jar b / lib / native / win32 - x86 - 64 . jar 
 index 1594cf5 . . d9f2002 100755 
 Binary files a / lib / native / win32 - x86 - 64 . jar and b / lib / native / win32 - x86 - 64 . jar differ 
 diff - - git a / lib / native / win32 - x86 . jar b / lib / native / win32 - x86 . jar 
 index eef4f08 . . 7ff3305 100755 
 Binary files a / lib / native / win32 - x86 . jar and b / lib / native / win32 - x86 . jar differ 
 diff - - git a / native / callback . c b / native / callback . c 
 index a4341c1 . . 057d1bd 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 592 , 6 + 592 , 7 @ @ BOOL WINAPI DllMain ( HINSTANCE hDLL , DWORD fdwReason , LPVOID lpvReserved ) { 
 thread _ storage * tls = ( thread _ storage * ) TlsGetValue ( tls _ thread _ data _ key ) ; 
 if ( tls ) { 
 dispose _ thread _ data ( tls ) ; 
 + TlsSetValue ( tls _ thread _ data _ key , 0 ) ; 
 } 
 break ; 
 } 
 diff - - git a / test / com / sun / jna / LastErrorTest . java b / test / com / sun / jna / LastErrorTest . java 
 index 53e545a . . 064d100 100644 
 - - - a / test / com / sun / jna / LastErrorTest . java 
 + + + b / test / com / sun / jna / LastErrorTest . java 
 @ @ - 14 , 6 + 14 , 8 @ @ package com . sun . jna ; 
 
 import java . util . Map ; 
 import java . util . HashMap ; 
 + import java . util . Set ; 
 + import java . util . HashSet ; 
 import java . lang . reflect . Method ; 
 
 import junit . framework . TestCase ; 
 @ @ - 50 , 22 + 52 , 30 @ @ public class LastErrorTest extends TestCase { 
 
 public void testLastErrorPerThreadStorage ( ) throws Exception { 
 final TestLibrary lib = ( TestLibrary ) Native . loadLibrary ( " testlib " , TestLibrary . class ) ; 
 - final int [ ] errors = new int [ 2 ] ; 
 - Thread t1 = new Thread ( ) { public void run ( ) { 
 - lib . setLastError ( - 1 ) ; 
 - errors [ 0 ] = Native . getLastError ( ) ; 
 - } } ; 
 - Thread t2 = new Thread ( ) { public void run ( ) { 
 - lib . setLastError ( - 2 ) ; 
 - errors [ 1 ] = Native . getLastError ( ) ; 
 - } } ; 
 - lib . setLastError ( - 3 ) ; 
 - 
 - t1 . start ( ) ; t2 . start ( ) ; 
 - t1 . join ( ) ; t2 . join ( ) ; 
 - assertEquals ( " Wrong error on main thread " , - 3 , Native . getLastError ( ) ) ; 
 - assertEquals ( " Wrong error on first thread " , - 1 , errors [ 0 ] ) ; 
 - assertEquals ( " Wrong error on second thread " , - 2 , errors [ 1 ] ) ; 
 + final int NTHREADS = 100 ; 
 + final int [ ] errors = new int [ NTHREADS ] ; 
 + Set < Thread > threads = new HashSet < Thread > ( ) ; 
 + for ( int i = 0 ; i < NTHREADS ; i + + ) { 
 + final int idx = i ; 
 + Thread t = new Thread ( ) { public void run ( ) { 
 + lib . setLastError ( - idx - 1 ) ; 
 + errors [ idx ] = Native . getLastError ( ) ; 
 + } } ; 
 + threads . add ( t ) ; 
 + } 
 + int EXPECTED = 42 ; 
 + lib . setLastError ( EXPECTED ) ; 
 + assertEquals ( " Wrong error on main thread ( immediate ) " , EXPECTED , Native . getLastError ( ) ) ; 
 + for ( Thread t : threads ) { 
 + t . start ( ) ; 
 + } 
 + for ( Thread t : threads ) { 
 + t . join ( ) ; 
 + } 
 + assertEquals ( " Wrong error on main thread " , EXPECTED , Native . getLastError ( ) ) ; 
 + for ( int i = 0 ; i < threads . size ( ) ; i + + ) { 
 + assertEquals ( " Wrong error on thread " + i , - i - 1 , errors [ i ] ) ; 
 + } 
 } 
 
 private final int ERROR = Platform . isWindows ( ) ? 1 : - 1 ;

NEAREST DIFF:
diff - - git a / native / Makefile b / native / Makefile 
 index 070dcb6 . . 480979f 100644 
 - - - a / native / Makefile 
 + + + b / native / Makefile 
 @ @ - 284 , 7 + 284 , 7 @ @ endif 
 # Unfortunately , we have to use different libffi include files depending on 
 # the target , so we can ' t do a simple universal build on darwin . Do 
 # separate builds , then merge the results . 
 - $ ( BUILD ) / % . o : % . c dispatch . h thread . h protect . h $ ( FFI _ LIB ) 
 + $ ( BUILD ) / % . o : % . c dispatch . h protect . h $ ( FFI _ LIB ) 
 	 @ mkdir - p $ ( BUILD ) 
 ifneq ( $ ( SDKROOT ) , ) 
 	 $ ( CC ) - arch $ ( ARCH ) $ ( CFLAGS ) - c $ < - o $ @ . $ ( ARCH ) 
 diff - - git a / native / callback . c b / native / callback . c 
 index b3e6fd0 . . 1e971b1 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 25 , 7 + 25 , 6 @ @ 
 # include < sys / param . h > 
 # endif 
 # include " dispatch . h " 
 - # include " thread . h " 
 
 # ifdef _ _ cplusplus 
 extern " C " { 
 @ @ - 389 , 10 + 388 , 19 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar 
 } 
 } 
 
 - # ifdef THREAD _ EXIT _ CLEANUP 
 - static void 
 - detach _ thread ( void * data ) { 
 - THREAD _ EXIT _ CLEANUP ( data ) ; 
 + # ifndef _ WIN32 
 + # include < pthread . h > 
 + 
 + static pthread _ key _ t key ; 
 + static pthread _ once _ t key _ once = PTHREAD _ ONCE _ INIT ; 
 + 
 + static void detach _ thread ( void * data ) { 
 + JavaVM * jvm = ( JavaVM * ) data ; 
 + ( * jvm ) - > DetachCurrentThread ( jvm ) ; 
 + } 
 + 
 + static void make _ key ( ) { 
 + pthread _ key _ create ( & key , detach _ thread ) ; 
 } 
 # endif 
 
 @ @ - 460 , 8 + 468 , 11 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 ( * jvm ) - > DetachCurrentThread ( jvm ) ; 
 } 
 else if ( ! was _ attached ) { 
 - # ifdef ON _ THREAD _ EXIT 
 - ON _ THREAD _ EXIT ( detach _ thread , jvm ) ; 
 + # ifndef _ WIN32 
 + pthread _ once ( & key _ once , make _ key ) ; 
 + if ( pthread _ getspecific ( key ) = = NULL ) { 
 + pthread _ setspecific ( key , jvm ) ; 
 + } 
 # endif 
 } 
 } 
 diff - - git a / native / thread . h b / native / thread . h 
 deleted file mode 100644 
 index 2ab1b18 . . 0000000 
 - - - a / native / thread . h 
 + + + / dev / null 
 @ @ - 1 , 51 + 0 , 0 @ @ 
 - / * Copyright ( c ) 20012 Timothy Wall , All Rights Reserved 
 - * 
 - * This library is free software ; you can redistribute it and / or 
 - * modify it under the terms of the GNU Lesser General Public 
 - * License as published by the Free Software Foundation ; either 
 - * version 2 . 1 of the License , or ( at your option ) any later version . 
 - * < p / > 
 - * This library is distributed in the hope that it will be useful , 
 - * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 - * / 
 - # ifndef THREAD _ H 
 - # define THREAD _ H 
 - 
 - # ifndef _ WIN32 
 - 
 - # include < pthread . h > 
 - 
 - # ifdef _ _ APPLE _ _ 
 - struct _ thread _ cleanup _ data { 
 - struct _ _ darwin _ pthread _ handler _ rec * _ _ handler ; 
 - JavaVM * _ _ jvm ; 
 - } ; 
 - # define THREAD _ EXIT _ CLEANUP ( DATA ) do { \ 
 - struct _ thread _ cleanup _ data * _ _ data = ( struct _ thread _ cleanup _ data * ) DATA ; \ 
 - pthread _ t _ _ self = pthread _ self ( ) ; \ 
 - fprintf ( stderr , " detach thread % p \ n " , _ _ self ) ; \ 
 - _ _ self - > _ _ cleanup _ stack = _ _ data - > _ _ handler - > _ _ next ; \ 
 - ( * ( _ _ data - > _ _ jvm ) ) - > DetachCurrentThread ( _ _ data - > _ _ jvm ) ; \ 
 - / * free ( _ _ data - > _ _ handler ) ; * / \ 
 - free ( _ _ data ) ; \ 
 - fprintf ( stderr , " detach thread % p done \ n " , _ _ self ) ; \ 
 - } while ( 0 ) 
 - # define ON _ THREAD _ EXIT ( PROC , JVM ) do { \ 
 - struct _ thread _ cleanup _ data * _ _ data = ( struct _ thread _ cleanup _ data * ) malloc ( sizeof ( struct _ thread _ cleanup _ data ) ) ; \ 
 - struct _ _ darwin _ pthread _ handler _ rec * _ _ handler = \ 
 - ( struct _ _ darwin _ pthread _ handler _ rec * ) malloc ( sizeof ( struct _ _ darwin _ pthread _ handler _ rec ) ) ; \ 
 - pthread _ t _ _ self = pthread _ self ( ) ; \ 
 - _ _ handler - > _ _ routine = PROC ; \ 
 - _ _ handler - > _ _ arg = _ _ data ; \ 
 - _ _ handler - > _ _ next = _ _ self - > _ _ cleanup _ stack ; \ 
 - _ _ self - > _ _ cleanup _ stack = _ _ handler ; \ 
 - _ _ data - > _ _ handler = _ _ handler ; \ 
 - _ _ data - > _ _ jvm = JVM ; \ 
 - } while ( 0 ) 
 - # endif / * _ _ APPLE _ _ * / 
 - 
 - # endif / * ! _ WIN32 * / 
 - 
 - # endif / * THREAD _ H * /
