BLEU SCORE: 0.018738883683389617

TEST MSG: clean up w32 build w / r / t unused references
GENERATED MSG: Include native bits for previous commit

TEST DIFF (one line): diff - - git a / native / callback . c b / native / callback . c <nl> index c61284e . . 3ed9f89 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 217 , 7 + 217 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> } <nl> } <nl> <nl> - # if HAS _ ALT _ CALLING _ CONVENTION <nl> + # ifdef HAS _ ALT _ CALLING _ CONVENTION <nl> / / Currently only w32 stdcall is supported <nl> if ( calling _ convention = = CALLCONV _ STDCALL ) { <nl> abi = FFI _ STDCALL ;
NEAREST DIFF (one line): diff - - git a / jnalib / src / com / sun / jna / Function . java b / jnalib / src / com / sun / jna / Function . java <nl> index 2bebd2d . . fc8ca0d 100644 <nl> - - - a / jnalib / src / com / sun / jna / Function . java <nl> + + + b / jnalib / src / com / sun / jna / Function . java <nl> @ @ - 152 , 6 + 152 , 7 @ @ public class Function extends Pointer { <nl> continue ; <nl> } <nl> <nl> + Class argClass = arg . getClass ( ) ; <nl> / / Convert Structures to native pointers <nl> if ( arg instanceof Structure ) { <nl> Structure struct = ( Structure ) arg ; <nl> @ @ - 182 , 8 + 183 , 36 @ @ public class Function extends Pointer { <nl> else if ( arg instanceof Boolean ) { <nl> args [ i ] = new Integer ( Boolean . TRUE . equals ( arg ) ? - 1 : 0 ) ; <nl> } <nl> - else if ( arg . getClass ( ) . isArray ( ) ) { <nl> - throw new IllegalArgumentException ( " Unsupported array type : " + arg . getClass ( ) ) ; <nl> + else if ( argClass . isArray ( ) ) { <nl> + / / Initialize uninitialized arrays of Structure to point <nl> + / / to a single block of memory <nl> + if ( Structure . class . isAssignableFrom ( argClass . getComponentType ( ) ) ) { <nl> + Structure [ ] ss = ( Structure [ ] ) arg ; <nl> + if ( ss . length = = 0 ) { <nl> + args [ i ] = null ; <nl> + } <nl> + else if ( ss [ 0 ] = = null ) { <nl> + Class type = argClass . getComponentType ( ) ; <nl> + try { <nl> + Structure struct = ( Structure ) type . newInstance ( ) ; <nl> + int size = struct . size ( ) ; <nl> + Memory m = new Memory ( size * ss . length ) ; <nl> + struct . useMemory ( m ) ; <nl> + Structure [ ] tmp = struct . toArray ( ss . length ) ; <nl> + for ( int si = 0 ; si < ss . length ; si + + ) { <nl> + ss [ si ] = tmp [ si ] ; <nl> + } <nl> + } <nl> + catch ( Exception e ) { <nl> + throw new IllegalArgumentException ( " Can ' t instantiate " <nl> + + type + " : " + e ) ; <nl> + } <nl> + args [ i ] = ss [ 0 ] . getPointer ( ) ; <nl> + } <nl> + } <nl> + else { <nl> + throw new IllegalArgumentException ( " Unsupported array type : " + arg . getClass ( ) ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 242 , 9 + 271 , 19 @ @ public class Function extends Pointer { <nl> if ( inArgs ! = null ) { <nl> for ( int i = 0 ; i < inArgs . length ; i + + ) { <nl> Object arg = inArgs [ i ] ; <nl> + if ( arg = = null ) <nl> + continue ; <nl> + Class argClass = arg . getClass ( ) ; <nl> if ( arg instanceof Structure ) { <nl> ( ( Structure ) arg ) . read ( ) ; <nl> } <nl> + else if ( argClass . isArray ( ) <nl> + & & Structure . class . isAssignableFrom ( argClass . getComponentType ( ) ) ) { <nl> + Structure [ ] ss = ( Structure [ ] ) arg ; <nl> + for ( int si = 0 ; si < ss . length ; si + + ) { <nl> + ss [ si ] . read ( ) ; <nl> + } <nl> + } <nl> } <nl> } <nl> <nl> diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html <nl> index f5b67ab . . ad0b761 100644 <nl> - - - a / jnalib / src / com / sun / jna / overview . html <nl> + + + b / jnalib / src / com / sun / jna / overview . html <nl> @ @ - 76 , 6 + 76 , 8 @ @ default type mappings : < br > <nl> < tr > < td > float < / td > < td > float < / td > <nl> < tr > < td > double < / td > < td > double < / td > <nl> < tr > < td > pointer ( to type or array as pointer ) < / td > < td > { @ link com . sun . jna . Pointer } < / td > <nl> + < tr > < td > struct * ( pointer to struct ) < / td > < td > { @ link com . sun . jna . Structure } < / td > <nl> + < tr > < td > struct [ ] ( array of contiguous structs ) < / td > < td > { @ link com . sun . jna . Structure } [ ] < / td > <nl> < tr > < td > nested arrays < / td > < td > Array of type < / td > <nl> < tr > < td > nested structures < / td > < td > { @ link com . sun . jna . Structure } < / td > <nl> < tr > < td > < i > not yet implemented < / i > < / td > <nl> @ @ - 133 , 6 + 135 , 19 @ @ the structure will be passed to the function and updated when the function <nl> returns . Structures are packed according to the default alignment rules for <nl> the platform ' s native C < code > struct < / code > s . <nl> <nl> + < h4 > Array - of - Structure Arguments < / h4 > <nl> + To pass an array of structures , simply use a Java array of the desired <nl> + structure type . If the array is uninitialized , it will be auto - initialized <nl> + prior to the function call . <nl> + <nl> + < h4 > Returned Pointer is an Array of < code > struct < / code > < / h4 > <nl> + Declare the method as returning a { @ link com . sun . jna . Structure } of the <nl> + appropriate type , then invoke { @ link com . sun . jna . Structure # toArray ( ) } to <nl> + convert to an array initialized structures of the appropriate size . Note that <nl> + your { @ link com . sun . jna . Structure } class must have a no - args constructor , and <nl> + you are responsible for freeing the returned memory if applicable in whatever <nl> + way is appropriate for the called function . <nl> + <nl> < h4 > Nested Structure Definitions < / h4 > <nl> Nested structures are treated as consecutive memory ( as opposed to pointers to <nl> structures ) . For example : < br > <nl> diff - - git a / jnalib / test / com / sun / jna / ArgumentsMarshalTest . java b / jnalib / test / com / sun / jna / ArgumentsMarshalTest . java <nl> index 98bcd25 . . 0fef03a 100644 <nl> - - - a / jnalib / test / com / sun / jna / ArgumentsMarshalTest . java <nl> + + + b / jnalib / test / com / sun / jna / ArgumentsMarshalTest . java <nl> @ @ - 49 , 6 + 49 , 7 @ @ public class ArgumentsMarshalTest extends TestCase { <nl> long checkInt64ArgumentAlignment ( int i , long j , int i2 , long j2 ) ; <nl> double checkDoubleArgumentAlignment ( float i , double j , float i2 , double j2 ) ; <nl> int testSimpleStructurePointerArgument ( CheckFieldAlignment p ) ; <nl> + void modifyStructureArray ( CheckFieldAlignment [ ] p , int length ) ; <nl> int fillInt8Buffer ( byte [ ] buf , int len , byte value ) ; <nl> int fillInt16Buffer ( short [ ] buf , int len , short value ) ; <nl> int fillInt32Buffer ( int [ ] buf , int len , int value ) ; <nl> @ @ - 176 , 6 + 177 , 24 @ @ public class ArgumentsMarshalTest extends TestCase { <nl> aligned . size ( ) , <nl> lib . testSimpleStructurePointerArgument ( aligned ) ) ; <nl> } <nl> + <nl> + public void testStructureArrayArgument ( ) { <nl> + final int LENGTH = 10 ; <nl> + TestLibrary . CheckFieldAlignment [ ] block = <nl> + new TestLibrary . CheckFieldAlignment [ LENGTH ] ; <nl> + lib . modifyStructureArray ( block , block . length ) ; <nl> + for ( int i = 0 ; i < block . length ; i + + ) { <nl> + assertNotNull ( " Structure array not initialized at " + i , block [ i ] ) ; <nl> + assertEquals ( " Wrong value for int32 field of structure at " + i , <nl> + i , block [ i ] . int32Field ) ; <nl> + assertEquals ( " Wrong value for int64 field of structure at " + i , <nl> + i + 1 , block [ i ] . int64Field ) ; <nl> + assertEquals ( " Wrong value for float field of structure at " + i , <nl> + i + 2 , block [ i ] . floatField , 0 ) ; <nl> + assertEquals ( " Wrong value for double field of structure at " + i , <nl> + i + 3 , block [ i ] . doubleField , 0 ) ; <nl> + } <nl> + } <nl> <nl> public void testByteArrayArgument ( ) { <nl> byte [ ] buf = new byte [ 1024 ] ;

TEST DIFF:
diff - - git a / native / callback . c b / native / callback . c 
 index c61284e . . 3ed9f89 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 217 , 7 + 217 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 } 
 } 
 
 - # if HAS _ ALT _ CALLING _ CONVENTION 
 + # ifdef HAS _ ALT _ CALLING _ CONVENTION 
 / / Currently only w32 stdcall is supported 
 if ( calling _ convention = = CALLCONV _ STDCALL ) { 
 abi = FFI _ STDCALL ;

NEAREST DIFF:
diff - - git a / jnalib / src / com / sun / jna / Function . java b / jnalib / src / com / sun / jna / Function . java 
 index 2bebd2d . . fc8ca0d 100644 
 - - - a / jnalib / src / com / sun / jna / Function . java 
 + + + b / jnalib / src / com / sun / jna / Function . java 
 @ @ - 152 , 6 + 152 , 7 @ @ public class Function extends Pointer { 
 continue ; 
 } 
 
 + Class argClass = arg . getClass ( ) ; 
 / / Convert Structures to native pointers 
 if ( arg instanceof Structure ) { 
 Structure struct = ( Structure ) arg ; 
 @ @ - 182 , 8 + 183 , 36 @ @ public class Function extends Pointer { 
 else if ( arg instanceof Boolean ) { 
 args [ i ] = new Integer ( Boolean . TRUE . equals ( arg ) ? - 1 : 0 ) ; 
 } 
 - else if ( arg . getClass ( ) . isArray ( ) ) { 
 - throw new IllegalArgumentException ( " Unsupported array type : " + arg . getClass ( ) ) ; 
 + else if ( argClass . isArray ( ) ) { 
 + / / Initialize uninitialized arrays of Structure to point 
 + / / to a single block of memory 
 + if ( Structure . class . isAssignableFrom ( argClass . getComponentType ( ) ) ) { 
 + Structure [ ] ss = ( Structure [ ] ) arg ; 
 + if ( ss . length = = 0 ) { 
 + args [ i ] = null ; 
 + } 
 + else if ( ss [ 0 ] = = null ) { 
 + Class type = argClass . getComponentType ( ) ; 
 + try { 
 + Structure struct = ( Structure ) type . newInstance ( ) ; 
 + int size = struct . size ( ) ; 
 + Memory m = new Memory ( size * ss . length ) ; 
 + struct . useMemory ( m ) ; 
 + Structure [ ] tmp = struct . toArray ( ss . length ) ; 
 + for ( int si = 0 ; si < ss . length ; si + + ) { 
 + ss [ si ] = tmp [ si ] ; 
 + } 
 + } 
 + catch ( Exception e ) { 
 + throw new IllegalArgumentException ( " Can ' t instantiate " 
 + + type + " : " + e ) ; 
 + } 
 + args [ i ] = ss [ 0 ] . getPointer ( ) ; 
 + } 
 + } 
 + else { 
 + throw new IllegalArgumentException ( " Unsupported array type : " + arg . getClass ( ) ) ; 
 + } 
 } 
 } 
 
 @ @ - 242 , 9 + 271 , 19 @ @ public class Function extends Pointer { 
 if ( inArgs ! = null ) { 
 for ( int i = 0 ; i < inArgs . length ; i + + ) { 
 Object arg = inArgs [ i ] ; 
 + if ( arg = = null ) 
 + continue ; 
 + Class argClass = arg . getClass ( ) ; 
 if ( arg instanceof Structure ) { 
 ( ( Structure ) arg ) . read ( ) ; 
 } 
 + else if ( argClass . isArray ( ) 
 + & & Structure . class . isAssignableFrom ( argClass . getComponentType ( ) ) ) { 
 + Structure [ ] ss = ( Structure [ ] ) arg ; 
 + for ( int si = 0 ; si < ss . length ; si + + ) { 
 + ss [ si ] . read ( ) ; 
 + } 
 + } 
 } 
 } 
 
 diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html 
 index f5b67ab . . ad0b761 100644 
 - - - a / jnalib / src / com / sun / jna / overview . html 
 + + + b / jnalib / src / com / sun / jna / overview . html 
 @ @ - 76 , 6 + 76 , 8 @ @ default type mappings : < br > 
 < tr > < td > float < / td > < td > float < / td > 
 < tr > < td > double < / td > < td > double < / td > 
 < tr > < td > pointer ( to type or array as pointer ) < / td > < td > { @ link com . sun . jna . Pointer } < / td > 
 + < tr > < td > struct * ( pointer to struct ) < / td > < td > { @ link com . sun . jna . Structure } < / td > 
 + < tr > < td > struct [ ] ( array of contiguous structs ) < / td > < td > { @ link com . sun . jna . Structure } [ ] < / td > 
 < tr > < td > nested arrays < / td > < td > Array of type < / td > 
 < tr > < td > nested structures < / td > < td > { @ link com . sun . jna . Structure } < / td > 
 < tr > < td > < i > not yet implemented < / i > < / td > 
 @ @ - 133 , 6 + 135 , 19 @ @ the structure will be passed to the function and updated when the function 
 returns . Structures are packed according to the default alignment rules for 
 the platform ' s native C < code > struct < / code > s . 
 
 + < h4 > Array - of - Structure Arguments < / h4 > 
 + To pass an array of structures , simply use a Java array of the desired 
 + structure type . If the array is uninitialized , it will be auto - initialized 
 + prior to the function call . 
 + 
 + < h4 > Returned Pointer is an Array of < code > struct < / code > < / h4 > 
 + Declare the method as returning a { @ link com . sun . jna . Structure } of the 
 + appropriate type , then invoke { @ link com . sun . jna . Structure # toArray ( ) } to 
 + convert to an array initialized structures of the appropriate size . Note that 
 + your { @ link com . sun . jna . Structure } class must have a no - args constructor , and 
 + you are responsible for freeing the returned memory if applicable in whatever 
 + way is appropriate for the called function . 
 + 
 < h4 > Nested Structure Definitions < / h4 > 
 Nested structures are treated as consecutive memory ( as opposed to pointers to 
 structures ) . For example : < br > 
 diff - - git a / jnalib / test / com / sun / jna / ArgumentsMarshalTest . java b / jnalib / test / com / sun / jna / ArgumentsMarshalTest . java 
 index 98bcd25 . . 0fef03a 100644 
 - - - a / jnalib / test / com / sun / jna / ArgumentsMarshalTest . java 
 + + + b / jnalib / test / com / sun / jna / ArgumentsMarshalTest . java 
 @ @ - 49 , 6 + 49 , 7 @ @ public class ArgumentsMarshalTest extends TestCase { 
 long checkInt64ArgumentAlignment ( int i , long j , int i2 , long j2 ) ; 
 double checkDoubleArgumentAlignment ( float i , double j , float i2 , double j2 ) ; 
 int testSimpleStructurePointerArgument ( CheckFieldAlignment p ) ; 
 + void modifyStructureArray ( CheckFieldAlignment [ ] p , int length ) ; 
 int fillInt8Buffer ( byte [ ] buf , int len , byte value ) ; 
 int fillInt16Buffer ( short [ ] buf , int len , short value ) ; 
 int fillInt32Buffer ( int [ ] buf , int len , int value ) ; 
 @ @ - 176 , 6 + 177 , 24 @ @ public class ArgumentsMarshalTest extends TestCase { 
 aligned . size ( ) , 
 lib . testSimpleStructurePointerArgument ( aligned ) ) ; 
 } 
 + 
 + public void testStructureArrayArgument ( ) { 
 + final int LENGTH = 10 ; 
 + TestLibrary . CheckFieldAlignment [ ] block = 
 + new TestLibrary . CheckFieldAlignment [ LENGTH ] ; 
 + lib . modifyStructureArray ( block , block . length ) ; 
 + for ( int i = 0 ; i < block . length ; i + + ) { 
 + assertNotNull ( " Structure array not initialized at " + i , block [ i ] ) ; 
 + assertEquals ( " Wrong value for int32 field of structure at " + i , 
 + i , block [ i ] . int32Field ) ; 
 + assertEquals ( " Wrong value for int64 field of structure at " + i , 
 + i + 1 , block [ i ] . int64Field ) ; 
 + assertEquals ( " Wrong value for float field of structure at " + i , 
 + i + 2 , block [ i ] . floatField , 0 ) ; 
 + assertEquals ( " Wrong value for double field of structure at " + i , 
 + i + 3 , block [ i ] . doubleField , 0 ) ; 
 + } 
 + } 
 
 public void testByteArrayArgument ( ) { 
 byte [ ] buf = new byte [ 1024 ] ;
