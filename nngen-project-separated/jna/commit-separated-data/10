BLEU SCORE: 0.002964656895382989

TEST MSG: Add GetLogicalProcessorInformationEx function
GENERATED MSG: Initial support for Wininet . dll and enumeration of its ' / IE ' s cache

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 4ab7bcb . . 374d2c9 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 10 , 10 + 10 , 12 @ @ Features <nl> * [ # 1058 ] ( https : / / github . com / java - native - access / jna / pull / 1058 ) : Add selectable timeout to stopService ( ) and improve timeout handling - [ @ keithharp ] ( https : / / github . com / keithharp ) . <nl> * [ # 1050 ] ( https : / / github . com / java - native - access / jna / pull / 1050 ) : Add ` c . s . j . p . win32 . VersionHelpers ` and supporting functions - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> * [ # 1061 ] ( https : / / github . com / java - native - access / jna / pull / 1061 ) : replace toArray ( new T [ size ] ) with toArray ( new T [ 0 ] ) for better performance - [ @ hc - codersatlas ] ( https : / / github . com / hc - codersatlas ) . <nl> + * [ # 1064 ] ( https : / / github . com / java - native - access / jna / pull / 1064 ) : Add ` c . s . j . p . win32 . Kernel32 . GetLogicalProcessorInformationEx ` function , convenience Util method and supporting structures - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> - * [ # 1052 ] ( https : / / github . com / java - native - access / jna / issues / 1052 ) , [ # 1053 ] ( https : / / github . com / java - native - access / jna / issues / 1053 ) : WinXP compatibility for ` c . s . j . p . win32 . PdhUtil ` - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> + * [ # 1052 ] ( https : / / github . com / java - native - access / jna / pull / 1052 ) , [ # 1053 ] ( https : / / github . com / java - native - access / jna / issues / 1053 ) : WinXP compatibility for ` c . s . j . p . win32 . PdhUtil ` - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> + * [ # 1055 ] ( https : / / github . com / java - native - access / jna / pull / 1055 ) : Include ` c . s . j . p . linux ` in OSGi bundle . - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> <nl> Release 5 . 2 . 0 <nl> = = = = = = = = = = = = = <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java <nl> index e012b13 . . 4043616 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ <nl> package com . sun . jna . platform . win32 ; <nl> <nl> import com . sun . jna . LastErrorException ; <nl> + import com . sun . jna . Memory ; <nl> import com . sun . jna . Native ; <nl> import com . sun . jna . Pointer ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> @ @ - 1535 , 6 + 1536 , 45 @ @ public interface Kernel32 extends StdCallLibrary , WinNT , Wincon { <nl> DWORDByReference returnLength ) ; <nl> <nl> / * * <nl> + * Retrieves information about the relationships of logical processors and <nl> + * related hardware . <nl> + * <nl> + * @ param relationshipType <nl> + * The type of relationship to retrieve . This parameter can be <nl> + * one of the following values : <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationCache } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationGroup } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationNumaNode } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , <nl> + * or { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationAll } <nl> + * @ param buffer <nl> + * A pointer to a buffer that receives an array of <nl> + * { @ link WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } <nl> + * structures . If the function fails , the contents of this buffer <nl> + * are undefined . <nl> + * @ param returnedLength <nl> + * On input , specifies the length of the buffer pointed to by <nl> + * Buffer , in bytes . If the buffer is large enough to contain all <nl> + * of the data , this function succeeds and ReturnedLength is set <nl> + * to the number of bytes returned . If the buffer is not large <nl> + * enough to contain all of the data , the function fails , <nl> + * GetLastError returns <nl> + * { @ link WinError # ERROR _ INSUFFICIENT _ BUFFER } , and ReturnedLength <nl> + * is set to the buffer length required to contain all of the <nl> + * data . If the function fails with an error other than <nl> + * { @ link WinError # ERROR _ INSUFFICIENT _ BUFFER } , the value of <nl> + * ReturnedLength is undefined . <nl> + * @ return If the function succeeds , the return value is { @ code TRUE } and at <nl> + * least one { @ link WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } <nl> + * structure is written to the output buffer . <nl> + * < p > <nl> + * If the function fails , the return value is { @ code FALSE } . To get <nl> + * extended error information , call { @ link # GetLastError ( ) } . <nl> + * / <nl> + boolean GetLogicalProcessorInformationEx ( int relationshipType , Pointer buffer , DWORDByReference returnedLength ) ; <nl> + <nl> + / * * <nl> * Retrieves information about the system ' s current usage of both physical <nl> * and virtual memory . <nl> * <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java <nl> index 991e60b . . a04e085 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java <nl> @ @ - 39 , 6 + 39 , 8 @ @ import com . sun . jna . Pointer ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; <nl> import com . sun . jna . platform . win32 . WinNT . HRESULT ; <nl> + import com . sun . jna . platform . win32 . WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP ; <nl> + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> import com . sun . jna . ptr . PointerByReference ; <nl> import com . sun . jna . win32 . W32APITypeMapper ; <nl> @ @ - 671 , 13 + 673 , 53 @ @ public abstract class Kernel32Util implements WinDef { <nl> } <nl> WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION firstInformation = new WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION ( <nl> memory ) ; <nl> - int returnedStructCount = bufferSize . getValue ( ) . intValue ( ) <nl> - / sizePerStruct ; <nl> return ( WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION [ ] ) firstInformation <nl> . toArray ( new WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION [ 0 ] ) ; <nl> } <nl> <nl> / * * <nl> + * Convenience method to get the processor information . Takes care of <nl> + * auto - growing the array and populating variable - length arrays in <nl> + * structures . <nl> + * <nl> + * @ param relationshipType <nl> + * The type of relationship to retrieve . This parameter can be <nl> + * one of the following values : <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationCache } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationGroup } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationNumaNode } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , <nl> + * or { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationAll } <nl> + * @ return the array of processor information . <nl> + * / <nl> + public static final SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX [ ] getLogicalProcessorInformationEx ( <nl> + int relationshipType ) { <nl> + WinDef . DWORDByReference bufferSize = new WinDef . DWORDByReference ( new WinDef . DWORD ( 1 ) ) ; <nl> + Memory memory ; <nl> + while ( true ) { <nl> + memory = new Memory ( bufferSize . getValue ( ) . intValue ( ) ) ; <nl> + if ( ! Kernel32 . INSTANCE . GetLogicalProcessorInformationEx ( relationshipType , memory , bufferSize ) ) { <nl> + int err = Kernel32 . INSTANCE . GetLastError ( ) ; <nl> + if ( err ! = WinError . ERROR _ INSUFFICIENT _ BUFFER ) <nl> + throw new Win32Exception ( err ) ; <nl> + } else { <nl> + break ; <nl> + } <nl> + } <nl> + / / Array elements have variable size ; iterate to populate array <nl> + List < SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX > procInfoList = new ArrayList < SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX > ( ) ; <nl> + int offset = 0 ; <nl> + while ( offset < bufferSize . getValue ( ) . intValue ( ) ) { <nl> + SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX information = SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX <nl> + . fromPointer ( memory . share ( offset ) ) ; <nl> + procInfoList . add ( information ) ; <nl> + offset + = information . size ; <nl> + } <nl> + return procInfoList . toArray ( new SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX [ 0 ] ) ; <nl> + } <nl> + <nl> + / * * <nl> * Retrieves all the keys and values for the specified section of an initialization file . <nl> * <nl> * < p > <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> index 315f8e9 . . ab129b5 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> @ @ - 172 , 6 + 172 , 11 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> int THREAD _ ALL _ ACCESS = STANDARD _ RIGHTS _ REQUIRED | SYNCHRONIZE | 0x3FF ; <nl> <nl> / * * <nl> + * Flag identifying hyperthreading / simultaneous multithreading ( SMT ) <nl> + * / <nl> + int LTP _ PC _ SMT = 0x1 ; <nl> + <nl> + / * * <nl> * The SECURITY _ IMPERSONATION _ LEVEL enumeration type contains values that <nl> * specify security impersonation levels . Security impersonation levels <nl> * govern the degree to which a server process can act on behalf of a client <nl> @ @ - 2902 , 6 + 2907 , 387 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> } <nl> <nl> / * * <nl> + * Contains information about the relationships of logical processors and <nl> + * related hardware . The { @ link Kernel32 # GetLogicalProcessorInformationEx } <nl> + * function uses this structure . <nl> + * < p > <nl> + * The native structure contains a union , which is mapped to JNA as <nl> + * subclasses . <nl> + * / <nl> + @ FieldOrder ( { " relationship " , " size " } ) <nl> + public abstract class SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX extends Structure { <nl> + <nl> + / * * <nl> + * The type of relationship between the logical processors . This <nl> + * parameter can be one of the following values : <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationCache } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationGroup } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationNumaNode } , <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , or <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } . <nl> + * < p > <nl> + * This field identifies which subclass will be instantiated by the <nl> + * { @ link # fromPointer ( Pointer ) } method . <nl> + * / <nl> + public int / * LOGICAL _ PROCESSOR _ RELATIONSHIP * / relationship ; <nl> + <nl> + / * * <nl> + * The size of the structure , in bytes . <nl> + * / <nl> + public int size ; <nl> + <nl> + public SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ( ) { <nl> + super ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * This constructor should only be called by a subclass to ensure memory <nl> + * is properly allocated to the subclass fields . <nl> + * <nl> + * @ param memory <nl> + * A pointer to the allocated native memory . <nl> + * / <nl> + protected SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ( Pointer memory ) { <nl> + super ( memory ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Create a new instance of the appropriate subclass of <nl> + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } from the provided <nl> + * { @ link Pointer } to native memory . Use this method rather than <nl> + * { @ link # SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ( Pointer ) } to properly <nl> + * cast the Pointer to the appropriate subclass and populate variable <nl> + * length arrays . <nl> + * <nl> + * @ param memory <nl> + * A pointer to allocated memory to be cast to this class . <nl> + * @ return An instance of the appropriate subclass depending on the <nl> + * value of the { @ link # relationship } field . If the <nl> + * { @ link # relationship } member is <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } <nl> + * or <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , <nl> + * the return type will be { @ link PROCESSOR _ RELATIONSHIP } . If <nl> + * the { @ link # relationship } member is <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationNumaNode } , the <nl> + * return type will be { @ link NUMA _ NODE _ RELATIONSHIP } . If the <nl> + * { @ link # relationship } member is <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationCache } , the <nl> + * return type will be { @ link CACHE _ RELATIONSHIP } . If the <nl> + * { @ link # relationship } member is <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationGroup } , the <nl> + * return type will be { @ link GROUP _ RELATIONSHIP } . <nl> + * / <nl> + public static SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX fromPointer ( Pointer memory ) { <nl> + int relationship = memory . getInt ( 0 ) ; <nl> + SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX result ; <nl> + switch ( relationship ) { <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorCore : <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorPackage : <nl> + result = new PROCESSOR _ RELATIONSHIP ( memory ) ; <nl> + break ; <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationNumaNode : <nl> + result = new NUMA _ NODE _ RELATIONSHIP ( memory ) ; <nl> + break ; <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationCache : <nl> + result = new CACHE _ RELATIONSHIP ( memory ) ; <nl> + break ; <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationGroup : <nl> + result = new GROUP _ RELATIONSHIP ( memory ) ; <nl> + break ; <nl> + default : <nl> + throw new IllegalStateException ( " Unmapped relationship : " + relationship ) ; <nl> + } <nl> + result . read ( ) ; <nl> + return result ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Describes the logical processors associated with either a processor core <nl> + * or a processor package . <nl> + * / <nl> + @ FieldOrder ( { " flags " , " efficiencyClass " , " reserved " , " groupCount " , " groupMask " } ) <nl> + public static class PROCESSOR _ RELATIONSHIP extends SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX { <nl> + <nl> + / * * <nl> + * If the { @ link # relationship } member of the <nl> + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } structure is <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , this <nl> + * member is { @ link # LTP _ PC _ SMT } if the core has more than one logical <nl> + * processor , or 0 if the core has one logical processor . <nl> + * < p > <nl> + * If the { @ link # relationship } member of the <nl> + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } structure is <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , this <nl> + * member is always 0 . <nl> + * / <nl> + public byte flags ; <nl> + <nl> + / * * <nl> + * If the { @ link # relationship } member of the <nl> + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } structure is <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , <nl> + * EfficiencyClass specifies the intrinsic tradeoff between performance <nl> + * and power for the applicable core . A core with a higher value for the <nl> + * efficiency class has intrinsically greater performance and less <nl> + * efficiency than a core with a lower value for the efficiency class . <nl> + * EfficiencyClass is only nonzero on systems with a heterogeneous set <nl> + * of cores . <nl> + * < p > <nl> + * If the { @ link # relationship } member of the <nl> + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } structure is <nl> + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , <nl> + * EfficiencyClass is always 0 . <nl> + * < p > <nl> + * The minimum operating system version that supports this member is <nl> + * Windows 10 . <nl> + * / <nl> + public byte efficiencyClass ; <nl> + <nl> + / * * <nl> + * This member is reserved . <nl> + * / <nl> + public byte [ ] reserved = new byte [ 20 ] ; <nl> + <nl> + / * * <nl> + * This member specifies the number of entries in the GroupMask array . <nl> + * < p > <nl> + * If the PROCESSOR _ RELATIONSHIP structure represents a processor core , <nl> + * the GroupCount member is always 1 . <nl> + * < p > <nl> + * If the { @ link PROCESSOR _ RELATIONSHIP } structure represents a <nl> + * processor package , the { @ link # groupCount } member is 1 only if all <nl> + * processors are in the same processor group . If the package contains <nl> + * more than one NUMA node , the system might assign different NUMA nodes <nl> + * to different processor groups . In this case , the { @ link # groupCount } <nl> + * member is the number of groups to which NUMA nodes in the package are <nl> + * assigned . <nl> + * / <nl> + public short groupCount ; <nl> + <nl> + / * * <nl> + * An array of { @ link GROUP _ AFFINITY } structures . The <nl> + * { @ link # groupCount } member specifies the number of structures in the <nl> + * array . Each structure in the array specifies a group number and <nl> + * processor affinity within the group . <nl> + * / <nl> + public GROUP _ AFFINITY [ ] groupMask = new GROUP _ AFFINITY [ 1 ] ; <nl> + <nl> + public PROCESSOR _ RELATIONSHIP ( ) { <nl> + } <nl> + <nl> + public PROCESSOR _ RELATIONSHIP ( Pointer memory ) { <nl> + super ( memory ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void read ( ) { <nl> + readField ( " groupCount " ) ; <nl> + groupMask = new GROUP _ AFFINITY [ groupCount ] ; <nl> + super . read ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Represents information about a NUMA node in a processor group . <nl> + * / <nl> + @ FieldOrder ( { " nodeNumber " , " reserved " , " groupMask " } ) <nl> + public static class NUMA _ NODE _ RELATIONSHIP extends SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX { <nl> + <nl> + / * * <nl> + * Identifies the NUMA node . Valid values are { @ code 0 } to the highest <nl> + * NUMA node number inclusive . A non - NUMA multiprocessor system will <nl> + * report that all processors belong to one NUMA node . <nl> + * / <nl> + public int nodeNumber ; <nl> + <nl> + / * * <nl> + * This member is reserved . <nl> + * / <nl> + public byte [ ] reserved = new byte [ 20 ] ; <nl> + <nl> + / * * <nl> + * A { @ link GROUP _ AFFINITY } structure that specifies a group number and <nl> + * processor affinity within the group . <nl> + * / <nl> + public GROUP _ AFFINITY groupMask ; <nl> + <nl> + public NUMA _ NODE _ RELATIONSHIP ( ) { <nl> + } <nl> + <nl> + public NUMA _ NODE _ RELATIONSHIP ( Pointer memory ) { <nl> + super ( memory ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Describes cache attributes . <nl> + * / <nl> + @ FieldOrder ( { " level " , " associativity " , " lineSize " , " cacheSize " , " type " , " reserved " , " groupMask " } ) <nl> + public static class CACHE _ RELATIONSHIP extends SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX { <nl> + <nl> + / * * <nl> + * The cache level . This member can be 1 ( L1 ) , 2 ( L2 ) , 3 ( L3 ) , or 4 <nl> + * ( L4 ) . <nl> + * / <nl> + public byte level ; <nl> + <nl> + / * * <nl> + * The cache associativity . If this member is <nl> + * { @ link # CACHE _ FULLY _ ASSOCIATIVE } , the cache is fully associative . <nl> + * / <nl> + public byte associativity ; <nl> + <nl> + / * * <nl> + * The cache line size , in bytes . <nl> + * / <nl> + public short lineSize ; <nl> + <nl> + / * * <nl> + * The cache size , in bytes . <nl> + * / <nl> + public int cacheSize ; <nl> + <nl> + / * * <nl> + * The cache type . This member is a { @ link PROCESSOR _ CACHE _ TYPE } value . <nl> + * / <nl> + public int / * PROCESSOR _ CACHE _ TYPE * / type ; <nl> + <nl> + / * * <nl> + * This member is reserved . <nl> + * / <nl> + public byte [ ] reserved = new byte [ 20 ] ; <nl> + <nl> + / * * <nl> + * A { @ link GROUP _ AFFINITY } structure that specifies a group number and <nl> + * processor affinity within the group . <nl> + * / <nl> + public GROUP _ AFFINITY groupMask ; <nl> + <nl> + public CACHE _ RELATIONSHIP ( ) { <nl> + } <nl> + <nl> + public CACHE _ RELATIONSHIP ( Pointer memory ) { <nl> + super ( memory ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Represents information about processor groups . <nl> + * / <nl> + @ FieldOrder ( { " maximumGroupCount " , " activeGroupCount " , " reserved " , " groupInfo " } ) <nl> + public static class GROUP _ RELATIONSHIP extends SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX { <nl> + <nl> + / * * <nl> + * The maximum number of processor groups on the system . <nl> + * / <nl> + public short maximumGroupCount ; <nl> + <nl> + / * * <nl> + * The number of active groups on the system . This member indicates the <nl> + * number of { @ link PROCESSOR _ GROUP _ INFO } structures in the GroupInfo <nl> + * array . <nl> + * / <nl> + public short activeGroupCount ; <nl> + <nl> + / * * <nl> + * This member is reserved . <nl> + * / <nl> + public byte [ ] reserved = new byte [ 20 ] ; <nl> + <nl> + / * * <nl> + * An array of { @ link PROCESSOR _ GROUP _ INFO } structures . The <nl> + * { @ link # activeGroupCount } member specifies the number of structures <nl> + * in the array . Each structure in the array specifies the number and <nl> + * affinity of processors in an active group on the system . <nl> + * / <nl> + public PROCESSOR _ GROUP _ INFO [ ] groupInfo = new PROCESSOR _ GROUP _ INFO [ 1 ] ; <nl> + <nl> + public GROUP _ RELATIONSHIP ( ) { <nl> + } <nl> + <nl> + public GROUP _ RELATIONSHIP ( Pointer memory ) { <nl> + super ( memory ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void read ( ) { <nl> + readField ( " activeGroupCount " ) ; <nl> + groupInfo = new PROCESSOR _ GROUP _ INFO [ activeGroupCount ] ; <nl> + super . read ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Represents a processor group - specific affinity , such as the affinity of a <nl> + * thread . <nl> + * / <nl> + @ FieldOrder ( { " mask " , " group " , " reserved " } ) <nl> + public static class GROUP _ AFFINITY extends Structure { <nl> + <nl> + / * * <nl> + * A bitmap that specifies the affinity for zero or more processors <nl> + * within the specified group . <nl> + * / <nl> + public ULONG _ PTR / * KAFFINITY * / mask ; <nl> + <nl> + / * * <nl> + * The processor group number . <nl> + * / <nl> + public short group ; <nl> + <nl> + / * * <nl> + * This member is reserved . <nl> + * / <nl> + public short [ ] reserved = new short [ 3 ] ; <nl> + <nl> + public GROUP _ AFFINITY ( Pointer memory ) { <nl> + super ( memory ) ; <nl> + } <nl> + <nl> + public GROUP _ AFFINITY ( ) { <nl> + super ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Represents the number and affinity of processors in a processor group . <nl> + * / <nl> + @ FieldOrder ( { " maximumProcessorCount " , " activeProcessorCount " , " reserved " , " activeProcessorMask " } ) <nl> + public static class PROCESSOR _ GROUP _ INFO extends Structure { <nl> + <nl> + / * * <nl> + * The maximum number of processors in the group . <nl> + * / <nl> + public byte maximumProcessorCount ; <nl> + <nl> + / * * <nl> + * The number of active processors in the group . <nl> + * / <nl> + public byte activeProcessorCount ; <nl> + <nl> + / * * <nl> + * This member is reserved . <nl> + * / <nl> + public byte [ ] reserved = new byte [ 38 ] ; <nl> + <nl> + / * * <nl> + * A bitmap that specifies the affinity for zero or more active <nl> + * processors within the group . <nl> + * / <nl> + public ULONG _ PTR / * KAFFINITY * / activeProcessorMask ; <nl> + <nl> + public PROCESSOR _ GROUP _ INFO ( Pointer memory ) { <nl> + super ( memory ) ; <nl> + } <nl> + <nl> + public PROCESSOR _ GROUP _ INFO ( ) { <nl> + super ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> * Represents the relationship between the processor set identified in the corresponding <nl> * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION } or < code > SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX < / code > structure . <nl> * / <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java <nl> index 45c33f0 . . 4c8a84c 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java <nl> @ @ - 19 , 15 + 19 , 23 @ @ import java . io . FileReader ; <nl> import java . io . FileWriter ; <nl> import java . io . IOException ; <nl> import java . io . PrintWriter ; <nl> + import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> <nl> import com . sun . jna . Pointer ; <nl> import com . sun . jna . platform . win32 . Tlhelp32 . MODULEENTRY32W ; <nl> + import com . sun . jna . platform . win32 . WinNT . CACHE _ RELATIONSHIP ; <nl> + import com . sun . jna . platform . win32 . WinNT . GROUP _ RELATIONSHIP ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> import com . sun . jna . platform . win32 . WinNT . HRESULT ; <nl> import com . sun . jna . platform . win32 . WinNT . LARGE _ INTEGER ; <nl> + import com . sun . jna . platform . win32 . WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP ; <nl> + import com . sun . jna . platform . win32 . WinNT . NUMA _ NODE _ RELATIONSHIP ; <nl> + import com . sun . jna . platform . win32 . WinNT . PROCESSOR _ CACHE _ TYPE ; <nl> + import com . sun . jna . platform . win32 . WinNT . PROCESSOR _ RELATIONSHIP ; <nl> + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ; <nl> <nl> import junit . framework . TestCase ; <nl> <nl> @ @ - 347 , 4 + 355 , 109 @ @ public class Kernel32UtilTest extends TestCase { <nl> Kernel32 . INSTANCE . SetEnvironmentVariable ( " DemoVariable " , " DemoValue " ) ; <nl> assertEquals ( " DemoValue " , Kernel32Util . expandEnvironmentStrings ( " % DemoVariable % " ) ) ; <nl> } <nl> + <nl> + public void testGetLogicalProcessorInformationEx ( ) { <nl> + SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX [ ] procInfo = Kernel32Util <nl> + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationAll ) ; <nl> + List < GROUP _ RELATIONSHIP > groups = new ArrayList < GROUP _ RELATIONSHIP > ( ) ; <nl> + List < PROCESSOR _ RELATIONSHIP > packages = new ArrayList < PROCESSOR _ RELATIONSHIP > ( ) ; <nl> + List < NUMA _ NODE _ RELATIONSHIP > numaNodes = new ArrayList < NUMA _ NODE _ RELATIONSHIP > ( ) ; <nl> + List < CACHE _ RELATIONSHIP > caches = new ArrayList < CACHE _ RELATIONSHIP > ( ) ; <nl> + List < PROCESSOR _ RELATIONSHIP > cores = new ArrayList < PROCESSOR _ RELATIONSHIP > ( ) ; <nl> + <nl> + for ( int i = 0 ; i < procInfo . length ; i + + ) { <nl> + / / Build list from relationship <nl> + switch ( procInfo [ i ] . relationship ) { <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationGroup : <nl> + groups . add ( ( GROUP _ RELATIONSHIP ) procInfo [ i ] ) ; <nl> + break ; <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorPackage : <nl> + packages . add ( ( PROCESSOR _ RELATIONSHIP ) procInfo [ i ] ) ; <nl> + break ; <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationNumaNode : <nl> + numaNodes . add ( ( NUMA _ NODE _ RELATIONSHIP ) procInfo [ i ] ) ; <nl> + break ; <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationCache : <nl> + caches . add ( ( CACHE _ RELATIONSHIP ) procInfo [ i ] ) ; <nl> + break ; <nl> + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorCore : <nl> + cores . add ( ( PROCESSOR _ RELATIONSHIP ) procInfo [ i ] ) ; <nl> + break ; <nl> + default : <nl> + throw new IllegalStateException ( " Unmapped relationship . " ) ; <nl> + } <nl> + / / Test that native provided size matches JNA structure size <nl> + assertEquals ( procInfo [ i ] . size , procInfo [ i ] . size ( ) ) ; <nl> + } <nl> + <nl> + / / Test that getting all relations matches the same totals as <nl> + / / individuals . <nl> + assertEquals ( groups . size ( ) , Kernel32Util <nl> + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationGroup ) . length ) ; <nl> + assertEquals ( packages . size ( ) , Kernel32Util . getLogicalProcessorInformationEx ( <nl> + WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorPackage ) . length ) ; <nl> + assertEquals ( numaNodes . size ( ) , Kernel32Util <nl> + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationNumaNode ) . length ) ; <nl> + assertEquals ( caches . size ( ) , Kernel32Util <nl> + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationCache ) . length ) ; <nl> + assertEquals ( cores . size ( ) , Kernel32Util <nl> + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorCore ) . length ) ; <nl> + <nl> + / / Test GROUP _ RELATIONSHIP <nl> + assertEquals ( 1 , groups . size ( ) ) ; / / Should only be one group structure <nl> + for ( GROUP _ RELATIONSHIP group : groups ) { <nl> + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationGroup , group . relationship ) ; <nl> + assertTrue ( group . activeGroupCount < = group . maximumGroupCount ) ; <nl> + assertEquals ( group . activeGroupCount , group . groupInfo . length ) ; <nl> + for ( int j = 0 ; j < group . activeGroupCount ; j + + ) { <nl> + assertTrue ( group . groupInfo [ j ] . activeProcessorCount < = group . groupInfo [ j ] . maximumProcessorCount ) ; <nl> + assertEquals ( group . groupInfo [ j ] . activeProcessorCount , <nl> + Long . bitCount ( group . groupInfo [ j ] . activeProcessorMask . longValue ( ) ) ) ; <nl> + assertTrue ( group . groupInfo [ j ] . maximumProcessorCount < = 64 ) ; <nl> + } <nl> + } <nl> + <nl> + / / Test PROCESSOR _ RELATIONSHIP packages <nl> + assertTrue ( cores . size ( ) > = packages . size ( ) ) ; <nl> + for ( PROCESSOR _ RELATIONSHIP pkg : packages ) { <nl> + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorPackage , pkg . relationship ) ; <nl> + assertEquals ( 0 , pkg . flags ) ; / / packages have 0 flags <nl> + assertEquals ( 0 , pkg . efficiencyClass ) ; / / packages have 0 efficiency <nl> + assertEquals ( pkg . groupCount , pkg . groupMask . length ) ; <nl> + } <nl> + <nl> + / / Test PROCESSOR _ RELATIONSHIP cores <nl> + for ( PROCESSOR _ RELATIONSHIP core : cores ) { <nl> + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorCore , core . relationship ) ; <nl> + / / Hyperthreading flag set if at least 2 logical processors <nl> + assertTrue ( Long . bitCount ( core . groupMask [ 0 ] . mask . longValue ( ) ) > 0 ) ; <nl> + if ( Long . bitCount ( core . groupMask [ 0 ] . mask . longValue ( ) ) > 1 ) { <nl> + assertEquals ( WinNT . LTP _ PC _ SMT , core . flags ) ; <nl> + } else { <nl> + assertEquals ( 0 , core . flags ) ; <nl> + } <nl> + / / Cores are always in one group <nl> + assertEquals ( 1 , core . groupCount ) ; <nl> + assertEquals ( 1 , core . groupMask . length ) ; <nl> + } <nl> + <nl> + / / Test NUMA _ NODE _ RELATIONSHIP <nl> + for ( NUMA _ NODE _ RELATIONSHIP numaNode : numaNodes ) { <nl> + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationNumaNode , numaNode . relationship ) ; <nl> + assertTrue ( numaNode . nodeNumber > = 0 ) ; <nl> + } <nl> + <nl> + / / Test CACHE _ RELATIONSHIP <nl> + for ( CACHE _ RELATIONSHIP cache : caches ) { <nl> + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationCache , cache . relationship ) ; <nl> + assertTrue ( cache . level > = 1 ) ; <nl> + assertTrue ( cache . level < = 4 ) ; <nl> + assertTrue ( cache . cacheSize > 0 ) ; <nl> + assertTrue ( cache . lineSize > 0 ) ; <nl> + assertTrue ( cache . type = = PROCESSOR _ CACHE _ TYPE . CacheUnified <nl> + | | cache . type = = PROCESSOR _ CACHE _ TYPE . CacheInstruction <nl> + | | cache . type = = PROCESSOR _ CACHE _ TYPE . CacheData | | cache . type = = PROCESSOR _ CACHE _ TYPE . CacheTrace ) ; <nl> + assertTrue ( cache . associativity = = WinNT . CACHE _ FULLY _ ASSOCIATIVE | | cache . associativity > 0 ) ; <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 4ab7bcb . . 374d2c9 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 10 , 10 + 10 , 12 @ @ Features 
 * [ # 1058 ] ( https : / / github . com / java - native - access / jna / pull / 1058 ) : Add selectable timeout to stopService ( ) and improve timeout handling - [ @ keithharp ] ( https : / / github . com / keithharp ) . 
 * [ # 1050 ] ( https : / / github . com / java - native - access / jna / pull / 1050 ) : Add ` c . s . j . p . win32 . VersionHelpers ` and supporting functions - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 * [ # 1061 ] ( https : / / github . com / java - native - access / jna / pull / 1061 ) : replace toArray ( new T [ size ] ) with toArray ( new T [ 0 ] ) for better performance - [ @ hc - codersatlas ] ( https : / / github . com / hc - codersatlas ) . 
 + * [ # 1064 ] ( https : / / github . com / java - native - access / jna / pull / 1064 ) : Add ` c . s . j . p . win32 . Kernel32 . GetLogicalProcessorInformationEx ` function , convenience Util method and supporting structures - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 - * [ # 1052 ] ( https : / / github . com / java - native - access / jna / issues / 1052 ) , [ # 1053 ] ( https : / / github . com / java - native - access / jna / issues / 1053 ) : WinXP compatibility for ` c . s . j . p . win32 . PdhUtil ` - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 + * [ # 1052 ] ( https : / / github . com / java - native - access / jna / pull / 1052 ) , [ # 1053 ] ( https : / / github . com / java - native - access / jna / issues / 1053 ) : WinXP compatibility for ` c . s . j . p . win32 . PdhUtil ` - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 + * [ # 1055 ] ( https : / / github . com / java - native - access / jna / pull / 1055 ) : Include ` c . s . j . p . linux ` in OSGi bundle . - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 
 Release 5 . 2 . 0 
 = = = = = = = = = = = = = 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java 
 index e012b13 . . 4043616 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java 
 @ @ - 24 , 6 + 24 , 7 @ @ 
 package com . sun . jna . platform . win32 ; 
 
 import com . sun . jna . LastErrorException ; 
 + import com . sun . jna . Memory ; 
 import com . sun . jna . Native ; 
 import com . sun . jna . Pointer ; 
 import com . sun . jna . ptr . IntByReference ; 
 @ @ - 1535 , 6 + 1536 , 45 @ @ public interface Kernel32 extends StdCallLibrary , WinNT , Wincon { 
 DWORDByReference returnLength ) ; 
 
 / * * 
 + * Retrieves information about the relationships of logical processors and 
 + * related hardware . 
 + * 
 + * @ param relationshipType 
 + * The type of relationship to retrieve . This parameter can be 
 + * one of the following values : 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationCache } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationGroup } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationNumaNode } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , 
 + * or { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationAll } 
 + * @ param buffer 
 + * A pointer to a buffer that receives an array of 
 + * { @ link WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } 
 + * structures . If the function fails , the contents of this buffer 
 + * are undefined . 
 + * @ param returnedLength 
 + * On input , specifies the length of the buffer pointed to by 
 + * Buffer , in bytes . If the buffer is large enough to contain all 
 + * of the data , this function succeeds and ReturnedLength is set 
 + * to the number of bytes returned . If the buffer is not large 
 + * enough to contain all of the data , the function fails , 
 + * GetLastError returns 
 + * { @ link WinError # ERROR _ INSUFFICIENT _ BUFFER } , and ReturnedLength 
 + * is set to the buffer length required to contain all of the 
 + * data . If the function fails with an error other than 
 + * { @ link WinError # ERROR _ INSUFFICIENT _ BUFFER } , the value of 
 + * ReturnedLength is undefined . 
 + * @ return If the function succeeds , the return value is { @ code TRUE } and at 
 + * least one { @ link WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } 
 + * structure is written to the output buffer . 
 + * < p > 
 + * If the function fails , the return value is { @ code FALSE } . To get 
 + * extended error information , call { @ link # GetLastError ( ) } . 
 + * / 
 + boolean GetLogicalProcessorInformationEx ( int relationshipType , Pointer buffer , DWORDByReference returnedLength ) ; 
 + 
 + / * * 
 * Retrieves information about the system ' s current usage of both physical 
 * and virtual memory . 
 * 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java 
 index 991e60b . . a04e085 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java 
 @ @ - 39 , 6 + 39 , 8 @ @ import com . sun . jna . Pointer ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; 
 import com . sun . jna . platform . win32 . WinNT . HRESULT ; 
 + import com . sun . jna . platform . win32 . WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP ; 
 + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ; 
 import com . sun . jna . ptr . IntByReference ; 
 import com . sun . jna . ptr . PointerByReference ; 
 import com . sun . jna . win32 . W32APITypeMapper ; 
 @ @ - 671 , 13 + 673 , 53 @ @ public abstract class Kernel32Util implements WinDef { 
 } 
 WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION firstInformation = new WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION ( 
 memory ) ; 
 - int returnedStructCount = bufferSize . getValue ( ) . intValue ( ) 
 - / sizePerStruct ; 
 return ( WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION [ ] ) firstInformation 
 . toArray ( new WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION [ 0 ] ) ; 
 } 
 
 / * * 
 + * Convenience method to get the processor information . Takes care of 
 + * auto - growing the array and populating variable - length arrays in 
 + * structures . 
 + * 
 + * @ param relationshipType 
 + * The type of relationship to retrieve . This parameter can be 
 + * one of the following values : 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationCache } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationGroup } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationNumaNode } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , 
 + * or { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationAll } 
 + * @ return the array of processor information . 
 + * / 
 + public static final SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX [ ] getLogicalProcessorInformationEx ( 
 + int relationshipType ) { 
 + WinDef . DWORDByReference bufferSize = new WinDef . DWORDByReference ( new WinDef . DWORD ( 1 ) ) ; 
 + Memory memory ; 
 + while ( true ) { 
 + memory = new Memory ( bufferSize . getValue ( ) . intValue ( ) ) ; 
 + if ( ! Kernel32 . INSTANCE . GetLogicalProcessorInformationEx ( relationshipType , memory , bufferSize ) ) { 
 + int err = Kernel32 . INSTANCE . GetLastError ( ) ; 
 + if ( err ! = WinError . ERROR _ INSUFFICIENT _ BUFFER ) 
 + throw new Win32Exception ( err ) ; 
 + } else { 
 + break ; 
 + } 
 + } 
 + / / Array elements have variable size ; iterate to populate array 
 + List < SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX > procInfoList = new ArrayList < SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX > ( ) ; 
 + int offset = 0 ; 
 + while ( offset < bufferSize . getValue ( ) . intValue ( ) ) { 
 + SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX information = SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX 
 + . fromPointer ( memory . share ( offset ) ) ; 
 + procInfoList . add ( information ) ; 
 + offset + = information . size ; 
 + } 
 + return procInfoList . toArray ( new SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX [ 0 ] ) ; 
 + } 
 + 
 + / * * 
 * Retrieves all the keys and values for the specified section of an initialization file . 
 * 
 * < p > 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 index 315f8e9 . . ab129b5 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 @ @ - 172 , 6 + 172 , 11 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 int THREAD _ ALL _ ACCESS = STANDARD _ RIGHTS _ REQUIRED | SYNCHRONIZE | 0x3FF ; 
 
 / * * 
 + * Flag identifying hyperthreading / simultaneous multithreading ( SMT ) 
 + * / 
 + int LTP _ PC _ SMT = 0x1 ; 
 + 
 + / * * 
 * The SECURITY _ IMPERSONATION _ LEVEL enumeration type contains values that 
 * specify security impersonation levels . Security impersonation levels 
 * govern the degree to which a server process can act on behalf of a client 
 @ @ - 2902 , 6 + 2907 , 387 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 } 
 
 / * * 
 + * Contains information about the relationships of logical processors and 
 + * related hardware . The { @ link Kernel32 # GetLogicalProcessorInformationEx } 
 + * function uses this structure . 
 + * < p > 
 + * The native structure contains a union , which is mapped to JNA as 
 + * subclasses . 
 + * / 
 + @ FieldOrder ( { " relationship " , " size " } ) 
 + public abstract class SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX extends Structure { 
 + 
 + / * * 
 + * The type of relationship between the logical processors . This 
 + * parameter can be one of the following values : 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationCache } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationGroup } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationNumaNode } , 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , or 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } . 
 + * < p > 
 + * This field identifies which subclass will be instantiated by the 
 + * { @ link # fromPointer ( Pointer ) } method . 
 + * / 
 + public int / * LOGICAL _ PROCESSOR _ RELATIONSHIP * / relationship ; 
 + 
 + / * * 
 + * The size of the structure , in bytes . 
 + * / 
 + public int size ; 
 + 
 + public SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ( ) { 
 + super ( ) ; 
 + } 
 + 
 + / * * 
 + * This constructor should only be called by a subclass to ensure memory 
 + * is properly allocated to the subclass fields . 
 + * 
 + * @ param memory 
 + * A pointer to the allocated native memory . 
 + * / 
 + protected SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ( Pointer memory ) { 
 + super ( memory ) ; 
 + } 
 + 
 + / * * 
 + * Create a new instance of the appropriate subclass of 
 + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } from the provided 
 + * { @ link Pointer } to native memory . Use this method rather than 
 + * { @ link # SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ( Pointer ) } to properly 
 + * cast the Pointer to the appropriate subclass and populate variable 
 + * length arrays . 
 + * 
 + * @ param memory 
 + * A pointer to allocated memory to be cast to this class . 
 + * @ return An instance of the appropriate subclass depending on the 
 + * value of the { @ link # relationship } field . If the 
 + * { @ link # relationship } member is 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } 
 + * or 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , 
 + * the return type will be { @ link PROCESSOR _ RELATIONSHIP } . If 
 + * the { @ link # relationship } member is 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationNumaNode } , the 
 + * return type will be { @ link NUMA _ NODE _ RELATIONSHIP } . If the 
 + * { @ link # relationship } member is 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationCache } , the 
 + * return type will be { @ link CACHE _ RELATIONSHIP } . If the 
 + * { @ link # relationship } member is 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationGroup } , the 
 + * return type will be { @ link GROUP _ RELATIONSHIP } . 
 + * / 
 + public static SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX fromPointer ( Pointer memory ) { 
 + int relationship = memory . getInt ( 0 ) ; 
 + SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX result ; 
 + switch ( relationship ) { 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorCore : 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorPackage : 
 + result = new PROCESSOR _ RELATIONSHIP ( memory ) ; 
 + break ; 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationNumaNode : 
 + result = new NUMA _ NODE _ RELATIONSHIP ( memory ) ; 
 + break ; 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationCache : 
 + result = new CACHE _ RELATIONSHIP ( memory ) ; 
 + break ; 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationGroup : 
 + result = new GROUP _ RELATIONSHIP ( memory ) ; 
 + break ; 
 + default : 
 + throw new IllegalStateException ( " Unmapped relationship : " + relationship ) ; 
 + } 
 + result . read ( ) ; 
 + return result ; 
 + } 
 + } 
 + 
 + / * * 
 + * Describes the logical processors associated with either a processor core 
 + * or a processor package . 
 + * / 
 + @ FieldOrder ( { " flags " , " efficiencyClass " , " reserved " , " groupCount " , " groupMask " } ) 
 + public static class PROCESSOR _ RELATIONSHIP extends SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX { 
 + 
 + / * * 
 + * If the { @ link # relationship } member of the 
 + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } structure is 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , this 
 + * member is { @ link # LTP _ PC _ SMT } if the core has more than one logical 
 + * processor , or 0 if the core has one logical processor . 
 + * < p > 
 + * If the { @ link # relationship } member of the 
 + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } structure is 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , this 
 + * member is always 0 . 
 + * / 
 + public byte flags ; 
 + 
 + / * * 
 + * If the { @ link # relationship } member of the 
 + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } structure is 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorCore } , 
 + * EfficiencyClass specifies the intrinsic tradeoff between performance 
 + * and power for the applicable core . A core with a higher value for the 
 + * efficiency class has intrinsically greater performance and less 
 + * efficiency than a core with a lower value for the efficiency class . 
 + * EfficiencyClass is only nonzero on systems with a heterogeneous set 
 + * of cores . 
 + * < p > 
 + * If the { @ link # relationship } member of the 
 + * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX } structure is 
 + * { @ link LOGICAL _ PROCESSOR _ RELATIONSHIP # RelationProcessorPackage } , 
 + * EfficiencyClass is always 0 . 
 + * < p > 
 + * The minimum operating system version that supports this member is 
 + * Windows 10 . 
 + * / 
 + public byte efficiencyClass ; 
 + 
 + / * * 
 + * This member is reserved . 
 + * / 
 + public byte [ ] reserved = new byte [ 20 ] ; 
 + 
 + / * * 
 + * This member specifies the number of entries in the GroupMask array . 
 + * < p > 
 + * If the PROCESSOR _ RELATIONSHIP structure represents a processor core , 
 + * the GroupCount member is always 1 . 
 + * < p > 
 + * If the { @ link PROCESSOR _ RELATIONSHIP } structure represents a 
 + * processor package , the { @ link # groupCount } member is 1 only if all 
 + * processors are in the same processor group . If the package contains 
 + * more than one NUMA node , the system might assign different NUMA nodes 
 + * to different processor groups . In this case , the { @ link # groupCount } 
 + * member is the number of groups to which NUMA nodes in the package are 
 + * assigned . 
 + * / 
 + public short groupCount ; 
 + 
 + / * * 
 + * An array of { @ link GROUP _ AFFINITY } structures . The 
 + * { @ link # groupCount } member specifies the number of structures in the 
 + * array . Each structure in the array specifies a group number and 
 + * processor affinity within the group . 
 + * / 
 + public GROUP _ AFFINITY [ ] groupMask = new GROUP _ AFFINITY [ 1 ] ; 
 + 
 + public PROCESSOR _ RELATIONSHIP ( ) { 
 + } 
 + 
 + public PROCESSOR _ RELATIONSHIP ( Pointer memory ) { 
 + super ( memory ) ; 
 + } 
 + 
 + @ Override 
 + public void read ( ) { 
 + readField ( " groupCount " ) ; 
 + groupMask = new GROUP _ AFFINITY [ groupCount ] ; 
 + super . read ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Represents information about a NUMA node in a processor group . 
 + * / 
 + @ FieldOrder ( { " nodeNumber " , " reserved " , " groupMask " } ) 
 + public static class NUMA _ NODE _ RELATIONSHIP extends SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX { 
 + 
 + / * * 
 + * Identifies the NUMA node . Valid values are { @ code 0 } to the highest 
 + * NUMA node number inclusive . A non - NUMA multiprocessor system will 
 + * report that all processors belong to one NUMA node . 
 + * / 
 + public int nodeNumber ; 
 + 
 + / * * 
 + * This member is reserved . 
 + * / 
 + public byte [ ] reserved = new byte [ 20 ] ; 
 + 
 + / * * 
 + * A { @ link GROUP _ AFFINITY } structure that specifies a group number and 
 + * processor affinity within the group . 
 + * / 
 + public GROUP _ AFFINITY groupMask ; 
 + 
 + public NUMA _ NODE _ RELATIONSHIP ( ) { 
 + } 
 + 
 + public NUMA _ NODE _ RELATIONSHIP ( Pointer memory ) { 
 + super ( memory ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Describes cache attributes . 
 + * / 
 + @ FieldOrder ( { " level " , " associativity " , " lineSize " , " cacheSize " , " type " , " reserved " , " groupMask " } ) 
 + public static class CACHE _ RELATIONSHIP extends SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX { 
 + 
 + / * * 
 + * The cache level . This member can be 1 ( L1 ) , 2 ( L2 ) , 3 ( L3 ) , or 4 
 + * ( L4 ) . 
 + * / 
 + public byte level ; 
 + 
 + / * * 
 + * The cache associativity . If this member is 
 + * { @ link # CACHE _ FULLY _ ASSOCIATIVE } , the cache is fully associative . 
 + * / 
 + public byte associativity ; 
 + 
 + / * * 
 + * The cache line size , in bytes . 
 + * / 
 + public short lineSize ; 
 + 
 + / * * 
 + * The cache size , in bytes . 
 + * / 
 + public int cacheSize ; 
 + 
 + / * * 
 + * The cache type . This member is a { @ link PROCESSOR _ CACHE _ TYPE } value . 
 + * / 
 + public int / * PROCESSOR _ CACHE _ TYPE * / type ; 
 + 
 + / * * 
 + * This member is reserved . 
 + * / 
 + public byte [ ] reserved = new byte [ 20 ] ; 
 + 
 + / * * 
 + * A { @ link GROUP _ AFFINITY } structure that specifies a group number and 
 + * processor affinity within the group . 
 + * / 
 + public GROUP _ AFFINITY groupMask ; 
 + 
 + public CACHE _ RELATIONSHIP ( ) { 
 + } 
 + 
 + public CACHE _ RELATIONSHIP ( Pointer memory ) { 
 + super ( memory ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Represents information about processor groups . 
 + * / 
 + @ FieldOrder ( { " maximumGroupCount " , " activeGroupCount " , " reserved " , " groupInfo " } ) 
 + public static class GROUP _ RELATIONSHIP extends SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX { 
 + 
 + / * * 
 + * The maximum number of processor groups on the system . 
 + * / 
 + public short maximumGroupCount ; 
 + 
 + / * * 
 + * The number of active groups on the system . This member indicates the 
 + * number of { @ link PROCESSOR _ GROUP _ INFO } structures in the GroupInfo 
 + * array . 
 + * / 
 + public short activeGroupCount ; 
 + 
 + / * * 
 + * This member is reserved . 
 + * / 
 + public byte [ ] reserved = new byte [ 20 ] ; 
 + 
 + / * * 
 + * An array of { @ link PROCESSOR _ GROUP _ INFO } structures . The 
 + * { @ link # activeGroupCount } member specifies the number of structures 
 + * in the array . Each structure in the array specifies the number and 
 + * affinity of processors in an active group on the system . 
 + * / 
 + public PROCESSOR _ GROUP _ INFO [ ] groupInfo = new PROCESSOR _ GROUP _ INFO [ 1 ] ; 
 + 
 + public GROUP _ RELATIONSHIP ( ) { 
 + } 
 + 
 + public GROUP _ RELATIONSHIP ( Pointer memory ) { 
 + super ( memory ) ; 
 + } 
 + 
 + @ Override 
 + public void read ( ) { 
 + readField ( " activeGroupCount " ) ; 
 + groupInfo = new PROCESSOR _ GROUP _ INFO [ activeGroupCount ] ; 
 + super . read ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Represents a processor group - specific affinity , such as the affinity of a 
 + * thread . 
 + * / 
 + @ FieldOrder ( { " mask " , " group " , " reserved " } ) 
 + public static class GROUP _ AFFINITY extends Structure { 
 + 
 + / * * 
 + * A bitmap that specifies the affinity for zero or more processors 
 + * within the specified group . 
 + * / 
 + public ULONG _ PTR / * KAFFINITY * / mask ; 
 + 
 + / * * 
 + * The processor group number . 
 + * / 
 + public short group ; 
 + 
 + / * * 
 + * This member is reserved . 
 + * / 
 + public short [ ] reserved = new short [ 3 ] ; 
 + 
 + public GROUP _ AFFINITY ( Pointer memory ) { 
 + super ( memory ) ; 
 + } 
 + 
 + public GROUP _ AFFINITY ( ) { 
 + super ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Represents the number and affinity of processors in a processor group . 
 + * / 
 + @ FieldOrder ( { " maximumProcessorCount " , " activeProcessorCount " , " reserved " , " activeProcessorMask " } ) 
 + public static class PROCESSOR _ GROUP _ INFO extends Structure { 
 + 
 + / * * 
 + * The maximum number of processors in the group . 
 + * / 
 + public byte maximumProcessorCount ; 
 + 
 + / * * 
 + * The number of active processors in the group . 
 + * / 
 + public byte activeProcessorCount ; 
 + 
 + / * * 
 + * This member is reserved . 
 + * / 
 + public byte [ ] reserved = new byte [ 38 ] ; 
 + 
 + / * * 
 + * A bitmap that specifies the affinity for zero or more active 
 + * processors within the group . 
 + * / 
 + public ULONG _ PTR / * KAFFINITY * / activeProcessorMask ; 
 + 
 + public PROCESSOR _ GROUP _ INFO ( Pointer memory ) { 
 + super ( memory ) ; 
 + } 
 + 
 + public PROCESSOR _ GROUP _ INFO ( ) { 
 + super ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 * Represents the relationship between the processor set identified in the corresponding 
 * { @ link SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION } or < code > SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX < / code > structure . 
 * / 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java 
 index 45c33f0 . . 4c8a84c 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java 
 @ @ - 19 , 15 + 19 , 23 @ @ import java . io . FileReader ; 
 import java . io . FileWriter ; 
 import java . io . IOException ; 
 import java . io . PrintWriter ; 
 + import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . List ; 
 import java . util . Map ; 
 
 import com . sun . jna . Pointer ; 
 import com . sun . jna . platform . win32 . Tlhelp32 . MODULEENTRY32W ; 
 + import com . sun . jna . platform . win32 . WinNT . CACHE _ RELATIONSHIP ; 
 + import com . sun . jna . platform . win32 . WinNT . GROUP _ RELATIONSHIP ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 import com . sun . jna . platform . win32 . WinNT . HRESULT ; 
 import com . sun . jna . platform . win32 . WinNT . LARGE _ INTEGER ; 
 + import com . sun . jna . platform . win32 . WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP ; 
 + import com . sun . jna . platform . win32 . WinNT . NUMA _ NODE _ RELATIONSHIP ; 
 + import com . sun . jna . platform . win32 . WinNT . PROCESSOR _ CACHE _ TYPE ; 
 + import com . sun . jna . platform . win32 . WinNT . PROCESSOR _ RELATIONSHIP ; 
 + import com . sun . jna . platform . win32 . WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX ; 
 
 import junit . framework . TestCase ; 
 
 @ @ - 347 , 4 + 355 , 109 @ @ public class Kernel32UtilTest extends TestCase { 
 Kernel32 . INSTANCE . SetEnvironmentVariable ( " DemoVariable " , " DemoValue " ) ; 
 assertEquals ( " DemoValue " , Kernel32Util . expandEnvironmentStrings ( " % DemoVariable % " ) ) ; 
 } 
 + 
 + public void testGetLogicalProcessorInformationEx ( ) { 
 + SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION _ EX [ ] procInfo = Kernel32Util 
 + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationAll ) ; 
 + List < GROUP _ RELATIONSHIP > groups = new ArrayList < GROUP _ RELATIONSHIP > ( ) ; 
 + List < PROCESSOR _ RELATIONSHIP > packages = new ArrayList < PROCESSOR _ RELATIONSHIP > ( ) ; 
 + List < NUMA _ NODE _ RELATIONSHIP > numaNodes = new ArrayList < NUMA _ NODE _ RELATIONSHIP > ( ) ; 
 + List < CACHE _ RELATIONSHIP > caches = new ArrayList < CACHE _ RELATIONSHIP > ( ) ; 
 + List < PROCESSOR _ RELATIONSHIP > cores = new ArrayList < PROCESSOR _ RELATIONSHIP > ( ) ; 
 + 
 + for ( int i = 0 ; i < procInfo . length ; i + + ) { 
 + / / Build list from relationship 
 + switch ( procInfo [ i ] . relationship ) { 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationGroup : 
 + groups . add ( ( GROUP _ RELATIONSHIP ) procInfo [ i ] ) ; 
 + break ; 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorPackage : 
 + packages . add ( ( PROCESSOR _ RELATIONSHIP ) procInfo [ i ] ) ; 
 + break ; 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationNumaNode : 
 + numaNodes . add ( ( NUMA _ NODE _ RELATIONSHIP ) procInfo [ i ] ) ; 
 + break ; 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationCache : 
 + caches . add ( ( CACHE _ RELATIONSHIP ) procInfo [ i ] ) ; 
 + break ; 
 + case LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorCore : 
 + cores . add ( ( PROCESSOR _ RELATIONSHIP ) procInfo [ i ] ) ; 
 + break ; 
 + default : 
 + throw new IllegalStateException ( " Unmapped relationship . " ) ; 
 + } 
 + / / Test that native provided size matches JNA structure size 
 + assertEquals ( procInfo [ i ] . size , procInfo [ i ] . size ( ) ) ; 
 + } 
 + 
 + / / Test that getting all relations matches the same totals as 
 + / / individuals . 
 + assertEquals ( groups . size ( ) , Kernel32Util 
 + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationGroup ) . length ) ; 
 + assertEquals ( packages . size ( ) , Kernel32Util . getLogicalProcessorInformationEx ( 
 + WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorPackage ) . length ) ; 
 + assertEquals ( numaNodes . size ( ) , Kernel32Util 
 + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationNumaNode ) . length ) ; 
 + assertEquals ( caches . size ( ) , Kernel32Util 
 + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationCache ) . length ) ; 
 + assertEquals ( cores . size ( ) , Kernel32Util 
 + . getLogicalProcessorInformationEx ( WinNT . LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorCore ) . length ) ; 
 + 
 + / / Test GROUP _ RELATIONSHIP 
 + assertEquals ( 1 , groups . size ( ) ) ; / / Should only be one group structure 
 + for ( GROUP _ RELATIONSHIP group : groups ) { 
 + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationGroup , group . relationship ) ; 
 + assertTrue ( group . activeGroupCount < = group . maximumGroupCount ) ; 
 + assertEquals ( group . activeGroupCount , group . groupInfo . length ) ; 
 + for ( int j = 0 ; j < group . activeGroupCount ; j + + ) { 
 + assertTrue ( group . groupInfo [ j ] . activeProcessorCount < = group . groupInfo [ j ] . maximumProcessorCount ) ; 
 + assertEquals ( group . groupInfo [ j ] . activeProcessorCount , 
 + Long . bitCount ( group . groupInfo [ j ] . activeProcessorMask . longValue ( ) ) ) ; 
 + assertTrue ( group . groupInfo [ j ] . maximumProcessorCount < = 64 ) ; 
 + } 
 + } 
 + 
 + / / Test PROCESSOR _ RELATIONSHIP packages 
 + assertTrue ( cores . size ( ) > = packages . size ( ) ) ; 
 + for ( PROCESSOR _ RELATIONSHIP pkg : packages ) { 
 + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorPackage , pkg . relationship ) ; 
 + assertEquals ( 0 , pkg . flags ) ; / / packages have 0 flags 
 + assertEquals ( 0 , pkg . efficiencyClass ) ; / / packages have 0 efficiency 
 + assertEquals ( pkg . groupCount , pkg . groupMask . length ) ; 
 + } 
 + 
 + / / Test PROCESSOR _ RELATIONSHIP cores 
 + for ( PROCESSOR _ RELATIONSHIP core : cores ) { 
 + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationProcessorCore , core . relationship ) ; 
 + / / Hyperthreading flag set if at least 2 logical processors 
 + assertTrue ( Long . bitCount ( core . groupMask [ 0 ] . mask . longValue ( ) ) > 0 ) ; 
 + if ( Long . bitCount ( core . groupMask [ 0 ] . mask . longValue ( ) ) > 1 ) { 
 + assertEquals ( WinNT . LTP _ PC _ SMT , core . flags ) ; 
 + } else { 
 + assertEquals ( 0 , core . flags ) ; 
 + } 
 + / / Cores are always in one group 
 + assertEquals ( 1 , core . groupCount ) ; 
 + assertEquals ( 1 , core . groupMask . length ) ; 
 + } 
 + 
 + / / Test NUMA _ NODE _ RELATIONSHIP 
 + for ( NUMA _ NODE _ RELATIONSHIP numaNode : numaNodes ) { 
 + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationNumaNode , numaNode . relationship ) ; 
 + assertTrue ( numaNode . nodeNumber > = 0 ) ; 
 + } 
 + 
 + / / Test CACHE _ RELATIONSHIP 
 + for ( CACHE _ RELATIONSHIP cache : caches ) { 
 + assertEquals ( LOGICAL _ PROCESSOR _ RELATIONSHIP . RelationCache , cache . relationship ) ; 
 + assertTrue ( cache . level > = 1 ) ; 
 + assertTrue ( cache . level < = 4 ) ; 
 + assertTrue ( cache . cacheSize > 0 ) ; 
 + assertTrue ( cache . lineSize > 0 ) ; 
 + assertTrue ( cache . type = = PROCESSOR _ CACHE _ TYPE . CacheUnified 
 + | | cache . type = = PROCESSOR _ CACHE _ TYPE . CacheInstruction 
 + | | cache . type = = PROCESSOR _ CACHE _ TYPE . CacheData | | cache . type = = PROCESSOR _ CACHE _ TYPE . CacheTrace ) ; 
 + assertTrue ( cache . associativity = = WinNT . CACHE _ FULLY _ ASSOCIATIVE | | cache . associativity > 0 ) ; 
 + } 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
