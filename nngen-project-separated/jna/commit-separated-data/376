BLEU SCORE: 0.07986788803078405

TEST MSG: Added OpenGL32 support .
GENERATED MSG: some changes

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index acd5f9f . . 8f80852 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 1 , 4 + 1 , 4 @ @ <nl> - ï»¿ NOTE : as of JNA 4 . 0 , JNA is now dual - licensed under LGPL and ASL ( see LICENSE ) . <nl> + NOTE : as of JNA 4 . 0 , JNA is now dual - licensed under LGPL and ASL ( see LICENSE ) . <nl> <nl> NOTE : JNI native support is typically incompatible between minor versions , and almost always incompatible between major versions . <nl> <nl> @ @ - 13 , 6 + 13 , 8 @ @ Features <nl> * [ # 226 ] ( https : / / github . com / twall / jna / issues / 226 ) : Added OSGI information to jna - platform . jar - [ @ brettwooldridge ] ( https : / / github . com / brettwooldridge ) . <nl> * [ # 267 ] ( https : / / github . com / twall / jna / pull / 267 ) : Added support for Windows RAS32 API , ` com . sun . jna . platform . win32 . Rasapi32 ` and ` Rasapi32Util ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . <nl> * [ # 101 ] ( https : / / github . com / twall / jna / issues / 101 ) : Modify ` com . sun . jna . platform . win32 . Advapi32Util . registryGet * ` API to support ` KEY _ WOW64 ` option - [ @ falldog ] ( https : / / github . com / falldog ) . <nl> + * [ # 271 ] ( https : / / github . com / twall / jna / pull / 271 ) : Added ` com . sun . jna . platform . win32 . Gdi32 . ChoosePixelFormat ` and ` SetPixelFormat ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . <nl> + * [ # 271 ] ( https : / / github . com / twall / jna / pull / 271 ) : Added ` com . sun . jna . platform . win32 . OpenGL32 ` , ` OpenGL32Util ` and ` WinOpenGL ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> @ @ - 693 , 3 + 695 , 4 @ @ Bug Fixes <nl> * Properly handle NULL when the return value is a Structure <nl> * Proper conversion to wchar _ t on linux <nl> * Copy full length of Java strings to C strings instead of stopping when a NUL character is encountered <nl> + <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / GDI32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / GDI32 . java <nl> index 4173820 . . 2924084 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / GDI32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / GDI32 . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ import com . sun . jna . platform . win32 . WinDef . HDC ; <nl> import com . sun . jna . platform . win32 . WinDef . HRGN ; <nl> import com . sun . jna . platform . win32 . WinGDI . BITMAPINFO ; <nl> import com . sun . jna . platform . win32 . WinGDI . BITMAPINFOHEADER ; <nl> + import com . sun . jna . platform . win32 . WinGDI . PIXELFORMATDESCRIPTOR ; <nl> import com . sun . jna . platform . win32 . WinGDI . RGNDATA ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> import com . sun . jna . ptr . PointerByReference ; <nl> @ @ - 313 , 4 + 314 , 33 @ @ public interface GDI32 extends StdCallLibrary { <nl> * BITMAPINFO } structure . <nl> * / <nl> int GetDIBits ( HDC hdc , HBITMAP hbmp , int uStartScan , int cScanLines , Pointer lpvBits , BITMAPINFO lpbi , int uUsage ) ; <nl> + <nl> + / * * <nl> + * The ChoosePixelFormat function attempts to match an appropriate pixel format supported <nl> + * by a device context to a given pixel format specification . <nl> + * <nl> + * @ param hdc <nl> + * Specifies the device context that the function examines to determine the best <nl> + * match for the pixel format descriptor pointed to by ppfd . <nl> + * @ param ppfd <nl> + * Pointer to a PIXELFORMATDESCRIPTOR structure that specifies the requested pixel format . <nl> + * @ return If the function succeeds , the return value is a pixel format index ( one - based ) that <nl> + * is the closest match to the given pixel format descriptor . <nl> + * / <nl> + public int ChoosePixelFormat ( HDC hdc , PIXELFORMATDESCRIPTOR . ByReference ppfd ) ; <nl> + <nl> + / * * <nl> + * The SetPixelFormat function sets the pixel format of the specified device context to the <nl> + * format specified by the iPixelFormat index . <nl> + * <nl> + * @ param hdc <nl> + * Specifies the device context whose pixel format the function attempts to set . <nl> + * @ param iPixelFormat <nl> + * Index that identifies the pixel format to set . The various pixel formats supported <nl> + * by a device context are identified by one - based indexes . <nl> + * @ param ppfd <nl> + * Pointer to a PIXELFORMATDESCRIPTOR structure that contains the logical pixel format specification . <nl> + * @ return true if successful <nl> + * / <nl> + public boolean SetPixelFormat ( HDC hdc , int iPixelFormat , PIXELFORMATDESCRIPTOR . ByReference ppfd ) ; <nl> } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32 . java <nl> new file mode 100644 <nl> index 0000000 . . 6ae66f6 <nl> - - - / dev / null <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32 . java <nl> @ @ - 0 , 0 + 1 , 86 @ @ <nl> + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation ; either <nl> + * version 2 . 1 of the License , or ( at your option ) any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + import com . sun . jna . Native ; <nl> + import com . sun . jna . Pointer ; <nl> + import com . sun . jna . platform . win32 . WinDef . HDC ; <nl> + import com . sun . jna . platform . win32 . WinOpenGL . HGLRC ; <nl> + import com . sun . jna . win32 . StdCallLibrary ; <nl> + <nl> + / * * <nl> + * opengl32 . dll Interface . <nl> + * / <nl> + public interface OpenGL32 extends StdCallLibrary { <nl> + OpenGL32 INSTANCE = ( OpenGL32 ) Native . loadLibrary ( " opengl32 " , OpenGL32 . class ) ; <nl> + <nl> + / * * <nl> + * The glGetString function returns a string describing the current OpenGL connection . <nl> + * <nl> + * @ param name <nl> + * One of the following symbolic constants . <nl> + * @ return The glGetString function returns a pointer to a static string describing some aspect of the current OpenGL connection . <nl> + * / <nl> + public String glGetString ( int name ) ; <nl> + <nl> + / * * <nl> + * The wglCreateContext function creates a new OpenGL rendering context , which is suitable for drawing on the device <nl> + * referenced by hdc . The rendering context has the same pixel format as the device context . <nl> + * <nl> + * @ param hdc <nl> + * Handle to a device context for which the function creates a suitable OpenGL rendering context . <nl> + * @ return handle to an OpenGL rendering context <nl> + * / <nl> + public HGLRC wglCreateContext ( HDC windowDC ) ; <nl> + <nl> + / * * <nl> + * The wglGetCurrentContext function obtains a handle to the current OpenGL rendering context of the calling thread . <nl> + * <nl> + * @ return If the calling thread has a current OpenGL rendering context , wglGetCurrentContext returns a <nl> + * handle to that rendering context . Otherwise , the return value is NULL . <nl> + * / <nl> + public HGLRC wglGetCurrentContext ( ) ; <nl> + <nl> + / * * <nl> + * The wglMakeCurrent function makes a specified OpenGL rendering context the calling thread ' s current rendering <nl> + * context . All subsequent OpenGL calls made by the thread are drawn on the device identified by hdc . <nl> + * <nl> + * @ param hdc <nl> + * Handle to a device context . Subsequent OpenGL calls made by the calling thread are drawn on the <nl> + * device identified by hdc . <nl> + * @ param hglrc <nl> + * Handle to an OpenGL rendering context that the function sets as the calling thread ' s rendering context . <nl> + * @ return true if successful <nl> + * / <nl> + public boolean wglMakeCurrent ( HDC windowDC , HGLRC hglrc ) ; <nl> + <nl> + / * * <nl> + * The wglDeleteContext function deletes a specified OpenGL rendering context . <nl> + * <nl> + * @ param hglrc <nl> + * Handle to an OpenGL rendering context that the function will delete . <nl> + * @ return true if successful <nl> + * / <nl> + public boolean wglDeleteContext ( HGLRC hglrc ) ; <nl> + <nl> + / * * <nl> + * The wglGetProcAddress function returns the address of an OpenGL extension function for use with the <nl> + * current OpenGL rendering context . <nl> + * <nl> + * @ param lpszProc <nl> + * Points to a null - terminated string that is the name of the extension function . <nl> + * The name of the extension function must be identical to a corresponding function implemented by OpenGL . <nl> + * @ return When the function succeeds , the return value is the address of the extension function . <nl> + * / <nl> + public Pointer wglGetProcAddress ( String lpszProc ) ; <nl> + } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32Util . java <nl> new file mode 100644 <nl> index 0000000 . . 1bf9b30 <nl> - - - / dev / null <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32Util . java <nl> @ @ - 0 , 0 + 1 , 81 @ @ <nl> + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation ; either <nl> + * version 2 . 1 of the License , or ( at your option ) any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + import com . sun . jna . Function ; <nl> + import com . sun . jna . Pointer ; <nl> + import com . sun . jna . platform . win32 . WinDef . HDC ; <nl> + import com . sun . jna . platform . win32 . WinDef . HWND ; <nl> + import com . sun . jna . platform . win32 . WinGDI . PIXELFORMATDESCRIPTOR ; <nl> + import com . sun . jna . platform . win32 . WinOpenGL . HGLRC ; <nl> + import com . sun . jna . platform . win32 . WinOpenGL . HGPUNVByReference ; <nl> + <nl> + / * * <nl> + * opengl32 utility API . <nl> + * / <nl> + public abstract class OpenGL32Util { <nl> + <nl> + / * * <nl> + * Return a procedure function pointer <nl> + * @ param procName the procedure name <nl> + * @ return the function <nl> + * / <nl> + public static Function wglGetProcAddress ( String procName ) { <nl> + Pointer funcPointer = OpenGL32 . INSTANCE . wglGetProcAddress ( " wglEnumGpusNV " ) ; <nl> + return ( funcPointer = = null ) ? null : Function . getFunction ( funcPointer ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Return a RAS connection by name <nl> + * @ param connName the connection name <nl> + * @ return the RAS connection structure <nl> + * / <nl> + public static int countGpusNV ( ) { <nl> + / / create a dummy window <nl> + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; <nl> + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; <nl> + <nl> + / / set a compatible pixel format <nl> + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; <nl> + pfd . nVersion = 1 ; <nl> + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; <nl> + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; <nl> + pfd . cColorBits = 24 ; <nl> + pfd . cDepthBits = 16 ; <nl> + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; <nl> + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; <nl> + <nl> + / / create the OpenGL context to get function address <nl> + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; <nl> + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; <nl> + Pointer funcPointer = OpenGL32 . INSTANCE . wglGetProcAddress ( " wglEnumGpusNV " ) ; <nl> + Function fncEnumGpusNV = ( funcPointer = = null ) ? null : Function . getFunction ( funcPointer ) ; <nl> + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; <nl> + <nl> + / / destroy the window <nl> + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; <nl> + User32Util . destroyWindow ( hWnd ) ; <nl> + <nl> + / / abort if the nVidia extensions are not present <nl> + if ( fncEnumGpusNV = = null ) return 0 ; <nl> + <nl> + / / enumerate nVidia adapters <nl> + HGPUNVByReference hGPU = new HGPUNVByReference ( ) ; <nl> + for ( int i = 0 ; i < 16 ; i + + ) { <nl> + Boolean ok = ( Boolean ) fncEnumGpusNV . invoke ( Boolean . class , new Object [ ] { Integer . valueOf ( i ) , hGPU , } ) ; <nl> + if ( ! ok . booleanValue ( ) ) return i ; <nl> + } <nl> + <nl> + return 0 ; <nl> + } <nl> + } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinGDI . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinGDI . java <nl> index c8bc6df . . b8855ce 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinGDI . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinGDI . java <nl> @ @ - 15 , 6 + 15 , 7 @ @ package com . sun . jna . platform . win32 ; <nl> import java . util . Arrays ; <nl> import java . util . List ; <nl> <nl> + import com . sun . jna . Pointer ; <nl> import com . sun . jna . Structure ; <nl> import com . sun . jna . platform . win32 . WinDef . RECT ; <nl> import com . sun . jna . win32 . StdCallLibrary ; <nl> @ @ - 77 , 6 + 78 , 28 @ @ public interface WinGDI extends StdCallLibrary { <nl> public int BI _ JPEG = 4 ; <nl> public int BI _ PNG = 5 ; <nl> <nl> + public final int PFD _ TYPE _ RGBA = 0 ; <nl> + public final int PFD _ TYPE _ COLORINDEX = 1 ; <nl> + <nl> + public final int PFD _ MAIN _ PLANE = 0 ; <nl> + public final int PFD _ OVERLAY _ PLANE = 1 ; <nl> + public final int PFD _ UNDERLAY _ PLANE = ( - 1 ) ; <nl> + <nl> + public final int PFD _ DOUBLEBUFFER = 0x00000001 ; <nl> + public final int PFD _ STEREO = 0x00000002 ; <nl> + public final int PFD _ DRAW _ TO _ WINDOW = 0x00000004 ; <nl> + public final int PFD _ DRAW _ TO _ BITMAP = 0x00000008 ; <nl> + public final int PFD _ SUPPORT _ GDI = 0x00000010 ; <nl> + public final int PFD _ SUPPORT _ OPENGL = 0x00000020 ; <nl> + public final int PFD _ GENERIC _ FORMAT = 0x00000040 ; <nl> + public final int PFD _ NEED _ PALETTE = 0x00000080 ; <nl> + public final int PFD _ NEED _ SYSTEM _ PALETTE = 0x00000100 ; <nl> + public final int PFD _ SWAP _ EXCHANGE = 0x00000200 ; <nl> + public final int PFD _ SWAP _ COPY = 0x00000400 ; <nl> + public final int PFD _ SWAP _ LAYER _ BUFFERS = 0x00000800 ; <nl> + public final int PFD _ GENERIC _ ACCELERATED = 0x00001000 ; <nl> + public final int PFD _ SUPPORT _ DIRECTDRAW = 0x00002000 ; <nl> + <nl> public class BITMAPINFOHEADER extends Structure { <nl> public int biSize = size ( ) ; <nl> public int biWidth ; <nl> @ @ - 118 , 4 + 141 , 136 @ @ public interface WinGDI extends StdCallLibrary { <nl> <nl> public int DIB _ RGB _ COLORS = 0 ; <nl> public int DIB _ PAL _ COLORS = 1 ; <nl> + <nl> + / * * <nl> + * The PIXELFORMATDESCRIPTOR structure describes the pixel format of a drawing surface . <nl> + * / <nl> + public static class PIXELFORMATDESCRIPTOR extends Structure { <nl> + public PIXELFORMATDESCRIPTOR ( ) { <nl> + super ( ) ; <nl> + nSize = ( short ) size ( ) ; <nl> + } <nl> + <nl> + public PIXELFORMATDESCRIPTOR ( Pointer memory ) { <nl> + super ( memory ) ; <nl> + read ( ) ; <nl> + } <nl> + <nl> + public static class ByReference extends PIXELFORMATDESCRIPTOR implements Structure . ByReference { <nl> + } <nl> + <nl> + / * * <nl> + * Specifies the size of this data structure . This value should be set to sizeof ( PIXELFORMATDESCRIPTOR ) . <nl> + * / <nl> + public short nSize ; <nl> + / * * <nl> + * Specifies the version of this data structure . This value should be set to 1 . <nl> + * / <nl> + public short nVersion ; <nl> + / * * <nl> + * A set of bit flags that specify properties of the pixel buffer . <nl> + * / <nl> + public int dwFlags ; <nl> + / * * <nl> + * Specifies the type of pixel data . <nl> + * / <nl> + public byte iPixelType ; <nl> + / * * <nl> + * Specifies the number of color bitplanes in each color buffer . <nl> + * / <nl> + public byte cColorBits ; <nl> + / * * <nl> + * Specifies the number of red bitplanes in each RGBA color buffer . <nl> + * / <nl> + public byte cRedBits ; <nl> + / * * <nl> + * Specifies the shift count for red bitplanes in each RGBA color buffer . <nl> + * / <nl> + public byte cRedShift ; <nl> + / * * <nl> + * Specifies the number of green bitplanes in each RGBA color buffer . <nl> + * / <nl> + public byte cGreenBits ; <nl> + / * * <nl> + * Specifies the shift count for green bitplanes in each RGBA color buffer . <nl> + * / <nl> + public byte cGreenShift ; <nl> + / * * <nl> + * Specifies the number of blue bitplanes in each RGBA color buffer . <nl> + * / <nl> + public byte cBlueBits ; <nl> + / * * <nl> + * Specifies the shift count for blue bitplanes in each RGBA color buffer . <nl> + * / <nl> + public byte cBlueShift ; <nl> + / * * <nl> + * Specifies the number of alpha bitplanes in each RGBA color buffer . Alpha bitplanes are not supported . <nl> + * / <nl> + public byte cAlphaBits ; <nl> + / * * <nl> + * Specifies the shift count for alpha bitplanes in each RGBA color buffer . Alpha bitplanes are not supported . <nl> + * / <nl> + public byte cAlphaShift ; <nl> + / * * <nl> + * Specifies the total number of bitplanes in the accumulation buffer . <nl> + * / <nl> + public byte cAccumBits ; <nl> + / * * <nl> + * Specifies the number of red bitplanes in the accumulation buffer . <nl> + * / <nl> + public byte cAccumRedBits ; <nl> + / * * <nl> + * Specifies the number of green bitplanes in the accumulation buffer . <nl> + * / <nl> + public byte cAccumGreenBits ; <nl> + / * * <nl> + * Specifies the number of blue bitplanes in the accumulation buffer . <nl> + * / <nl> + public byte cAccumBlueBits ; <nl> + / * * <nl> + * Specifies the number of alpha bitplanes in the accumulation buffer . <nl> + * / <nl> + public byte cAccumAlphaBits ; <nl> + / * * <nl> + * Specifies the depth of the depth ( z - axis ) buffer . <nl> + * / <nl> + public byte cDepthBits ; <nl> + / * * <nl> + * Specifies the depth of the stencil buffer . <nl> + * / <nl> + public byte cStencilBits ; <nl> + / * * <nl> + * Specifies the number of auxiliary buffers . Auxiliary buffers are not supported . <nl> + * / <nl> + public byte cAuxBuffers ; <nl> + / * * <nl> + * Ignored . Earlier implementations of OpenGL used this member , but it is no longer used . <nl> + * / <nl> + public byte iLayerType ; <nl> + / * * <nl> + * Specifies the number of overlay and underlay planes . <nl> + * / <nl> + public byte bReserved ; <nl> + / * * <nl> + * Ignored . Earlier implementations of OpenGL used this member , but it is no longer used . <nl> + * / <nl> + public int dwLayerMask ; <nl> + / * * <nl> + * Specifies the transparent color or index of an underlay plane . <nl> + * / <nl> + public int dwVisibleMask ; <nl> + / * * <nl> + * Ignored . Earlier implementations of OpenGL used this member , but it is no longer used . <nl> + * / <nl> + public int dwDamageMask ; <nl> + <nl> + @ SuppressWarnings ( " rawtypes " ) <nl> + @ Override <nl> + protected List getFieldOrder ( ) { <nl> + return Arrays . asList ( new String [ ] { " nSize " , " nVersion " , " dwFlags " , " iPixelType " , <nl> + " cColorBits " , " cRedBits " , " cRedShift " , " cGreenBits " , " cGreenShift " , " cBlueBits " , " cBlueShift " , " cAlphaBits " , " cAlphaShift " , <nl> + " cAccumBits " , " cAccumRedBits " , " cAccumGreenBits " , " cAccumBlueBits " , " cAccumAlphaBits " , <nl> + " cDepthBits " , " cStencilBits " , " cAuxBuffers " , " iLayerType " , " bReserved " , " dwLayerMask " , " dwVisibleMask " , " dwDamageMask " , } ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinOpenGL . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinOpenGL . java <nl> new file mode 100644 <nl> index 0000000 . . 6b77b22 <nl> - - - / dev / null <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinOpenGL . java <nl> @ @ - 0 , 0 + 1 , 98 @ @ <nl> + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation ; either <nl> + * version 2 . 1 of the License , or ( at your option ) any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + import com . sun . jna . Pointer ; <nl> + import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> + import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; <nl> + import com . sun . jna . win32 . StdCallLibrary ; <nl> + <nl> + / * * <nl> + * Definitions for WinOpenGL <nl> + * / <nl> + public interface WinOpenGL extends StdCallLibrary { <nl> + <nl> + public final int GL _ VENDOR = 0x1F00 ; <nl> + public final int GL _ RENDERER = 0x1F01 ; <nl> + public final int GL _ VERSION = 0x1F02 ; <nl> + public final int GL _ EXTENSIONS = 0x1F03 ; <nl> + <nl> + / * * <nl> + * handle to an OpenGL rendering context <nl> + * / <nl> + public static class HGLRC extends HANDLE { <nl> + <nl> + / * * <nl> + * Instantiates a new HGLRC . <nl> + * / <nl> + public HGLRC ( ) { <nl> + <nl> + } <nl> + <nl> + / * * <nl> + * Instantiates a new HGLRC . <nl> + * <nl> + * @ param p <nl> + * the p <nl> + * / <nl> + public HGLRC ( Pointer p ) { <nl> + super ( p ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * handle to an OpenGL rendering context <nl> + * / <nl> + public static class HGPUNV extends HANDLE { <nl> + <nl> + / * * <nl> + * Instantiates a new HGLRC . <nl> + * / <nl> + public HGPUNV ( ) { <nl> + <nl> + } <nl> + <nl> + / * * <nl> + * Instantiates a new HGLRC . <nl> + * <nl> + * @ param p <nl> + * the p <nl> + * / <nl> + public HGPUNV ( Pointer p ) { <nl> + super ( p ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * handle to an OpenGL rendering context <nl> + * / <nl> + public static class HGPUNVByReference extends HANDLEByReference { <nl> + <nl> + / * * <nl> + * Instantiates a new HGLRC . <nl> + * / <nl> + public HGPUNVByReference ( ) { <nl> + <nl> + } <nl> + <nl> + / * * <nl> + * Instantiates a new HGLRC . <nl> + * <nl> + * @ param p <nl> + * the p <nl> + * / <nl> + public HGPUNVByReference ( HGPUNV h ) { <nl> + super ( h ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinRas . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinRas . java <nl> index ff8a008 . . 13d8142 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinRas . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinRas . java <nl> @ @ - 291 , 7 + 291 , 6 @ @ public interface WinRas extends StdCallLibrary { <nl> 	 	 public RASCONN ( ) { <nl> 	 	 	 super ( ) ; <nl> 	 	 	 dwSize = size ( ) ; <nl> - 	 	 	 System . out . println ( " Size = " + dwSize ) ; <nl> 	 	 } <nl> <nl> 	 	 public RASCONN ( Pointer memory ) { <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32Test . java <nl> new file mode 100644 <nl> index 0000000 . . ddc4784 <nl> - - - / dev / null <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32Test . java <nl> @ @ - 0 , 0 + 1 , 174 @ @ <nl> + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation ; either <nl> + * version 2 . 1 of the License , or ( at your option ) any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + import junit . framework . TestCase ; <nl> + <nl> + import com . sun . jna . platform . win32 . WinDef . HDC ; <nl> + import com . sun . jna . platform . win32 . WinDef . HWND ; <nl> + import com . sun . jna . platform . win32 . WinGDI . PIXELFORMATDESCRIPTOR ; <nl> + import com . sun . jna . platform . win32 . WinOpenGL . HGLRC ; <nl> + <nl> + / * * <nl> + * @ author drrobison @ openroadsconsulting . com <nl> + * / <nl> + public class OpenGL32Test extends TestCase { <nl> + <nl> + public static void main ( String [ ] args ) { <nl> + junit . textui . TestRunner . run ( OpenGL32Test . class ) ; <nl> + } <nl> + <nl> + public void testGetStringGLVersion ( ) { <nl> + / / create a dummy window <nl> + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; <nl> + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; <nl> + <nl> + / / set a compatible pixel format <nl> + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; <nl> + pfd . nVersion = 1 ; <nl> + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; <nl> + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; <nl> + pfd . cColorBits = 24 ; <nl> + pfd . cDepthBits = 16 ; <nl> + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; <nl> + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; <nl> + <nl> + / / create the OpenGL context <nl> + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; <nl> + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; <nl> + String glString = OpenGL32 . INSTANCE . glGetString ( WinOpenGL . GL _ VERSION ) ; <nl> + System . out . println ( " GL _ VERSION = " + glString ) ; <nl> + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; <nl> + <nl> + / / destroy the window <nl> + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; <nl> + User32Util . destroyWindow ( hWnd ) ; <nl> + <nl> + assertNotNull ( " Could not get GL _ VERSION " , glString ) ; <nl> + } <nl> + <nl> + public void testGetStringGLRenderer ( ) { <nl> + / / create a dummy window <nl> + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; <nl> + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; <nl> + <nl> + / / set a compatible pixel format <nl> + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; <nl> + pfd . nVersion = 1 ; <nl> + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; <nl> + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; <nl> + pfd . cColorBits = 24 ; <nl> + pfd . cDepthBits = 16 ; <nl> + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; <nl> + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; <nl> + <nl> + / / create the OpenGL context <nl> + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; <nl> + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; <nl> + String glString = OpenGL32 . INSTANCE . glGetString ( WinOpenGL . GL _ RENDERER ) ; <nl> + System . out . println ( " GL _ RENDERER = " + glString ) ; <nl> + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; <nl> + <nl> + / / destroy the window <nl> + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; <nl> + User32Util . destroyWindow ( hWnd ) ; <nl> + <nl> + assertNotNull ( " Could not get GL _ RENDERER " , glString ) ; <nl> + } <nl> + <nl> + public void testGetStringGLVendor ( ) { <nl> + / / create a dummy window <nl> + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; <nl> + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; <nl> + <nl> + / / set a compatible pixel format <nl> + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; <nl> + pfd . nVersion = 1 ; <nl> + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; <nl> + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; <nl> + pfd . cColorBits = 24 ; <nl> + pfd . cDepthBits = 16 ; <nl> + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; <nl> + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; <nl> + <nl> + / / create the OpenGL context <nl> + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; <nl> + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; <nl> + String glString = OpenGL32 . INSTANCE . glGetString ( WinOpenGL . GL _ VENDOR ) ; <nl> + System . out . println ( " GL _ VENDOR = " + glString ) ; <nl> + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; <nl> + <nl> + / / destroy the window <nl> + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; <nl> + User32Util . destroyWindow ( hWnd ) ; <nl> + <nl> + assertNotNull ( " Could not get GL _ VENDOR " , glString ) ; <nl> + } <nl> + <nl> + public void testGetStringGLExtensions ( ) { <nl> + / / create a dummy window <nl> + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; <nl> + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; <nl> + <nl> + / / set a compatible pixel format <nl> + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; <nl> + pfd . nVersion = 1 ; <nl> + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; <nl> + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; <nl> + pfd . cColorBits = 24 ; <nl> + pfd . cDepthBits = 16 ; <nl> + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; <nl> + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; <nl> + <nl> + / / create the OpenGL context <nl> + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; <nl> + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; <nl> + String glString = OpenGL32 . INSTANCE . glGetString ( WinOpenGL . GL _ EXTENSIONS ) ; <nl> + System . out . println ( " GL _ EXTENSIONS = " + glString ) ; <nl> + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; <nl> + <nl> + / / destroy the window <nl> + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; <nl> + User32Util . destroyWindow ( hWnd ) ; <nl> + <nl> + assertNotNull ( " Could not get GL _ EXTENSIONS " , glString ) ; <nl> + } <nl> + <nl> + public void testGetCurrentContext ( ) { <nl> + / / create a dummy window <nl> + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; <nl> + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; <nl> + <nl> + / / set a compatible pixel format <nl> + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; <nl> + pfd . nVersion = 1 ; <nl> + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; <nl> + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; <nl> + pfd . cColorBits = 24 ; <nl> + pfd . cDepthBits = 16 ; <nl> + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; <nl> + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; <nl> + <nl> + / / create the OpenGL context <nl> + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; <nl> + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; <nl> + HGLRC currentContext = OpenGL32 . INSTANCE . wglGetCurrentContext ( ) ; <nl> + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; <nl> + <nl> + / / destroy the window <nl> + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; <nl> + User32Util . destroyWindow ( hWnd ) ; <nl> + <nl> + assertNotNull ( " Could not get current context " , currentContext ) ; <nl> + } <nl> + } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32UtilTest . java <nl> new file mode 100644 <nl> index 0000000 . . 83157ac <nl> - - - / dev / null <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32UtilTest . java <nl> @ @ - 0 , 0 + 1 , 30 @ @ <nl> + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation ; either <nl> + * version 2 . 1 of the License , or ( at your option ) any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + import junit . framework . TestCase ; <nl> + <nl> + / * * <nl> + * @ author drrobison @ openroadsconsulting . com <nl> + * / <nl> + public class OpenGL32UtilTest extends TestCase { <nl> + <nl> + public static void main ( String [ ] args ) { <nl> + junit . textui . TestRunner . run ( OpenGL32UtilTest . class ) ; <nl> + } <nl> + <nl> + public void testCountGpusNV ( ) { <nl> + int cnt = OpenGL32Util . countGpusNV ( ) ; <nl> + assertTrue ( " Expecting > = 0 " , cnt > = 0 ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / ChangeLog b / ChangeLog <nl> index 289d195 . . ff76645 100644 <nl> - - - a / ChangeLog <nl> + + + b / ChangeLog <nl> @ @ - 1 , 3 + 1 , 13 @ @ <nl> + 2013 - 01 - 10 Anthony Green < green @ moxielogic . com > <nl> + <nl> + 	 * configure . ac : Put local . exp in the right place . <nl> + 	 * configure : Rebuilt . <nl> + <nl> + 	 * src / x86 / ffi . c : Update comment about regparm function attributes . <nl> + 	 * src / x86 / sysv . S ( ffi _ closure _ SYSV ) : The SUNPRO compiler requires <nl> + 	 that all function arguments be passed on the stack ( no regparm <nl> + 	 support ) . <nl> + <nl> 2013 - 01 - 08 Anthony Green < green @ moxielogic . com > <nl> <nl> 	 * configure . ac : Generate local . exp . This sets CC _ FOR _ TARGET <nl> diff - - git a / configure b / configure <nl> index 5876eb7 . . 4a12b96 100755 <nl> - - - a / configure <nl> + + + b / configure <nl> @ @ - 13068 , 10 + 13068 , 10 @ @ ac _ compiler _ gnu = $ ac _ cv _ c _ compiler _ gnu <nl> <nl> if test " x $ GCC " = " xyes " ; then <nl> CFLAGS = " $ CFLAGS - fexceptions " <nl> - touch testsuite / local . exp <nl> + touch local . exp <nl> else <nl> cat > local . exp < < EOF <nl> - set CC _ FOR _ TARGET $ CC <nl> + set CC _ FOR _ TARGET " $ CC " <nl> EOF <nl> fi <nl> <nl> diff - - git a / configure . ac b / configure . ac <nl> index 7ffb36c . . 13d5bc2 100644 <nl> - - - a / configure . ac <nl> + + + b / configure . ac <nl> @ @ - 40 , 10 + 40 , 10 @ @ AX _ CC _ MAXOPT <nl> AX _ CFLAGS _ WARN _ ALL <nl> if test " x $ GCC " = " xyes " ; then <nl> CFLAGS = " $ CFLAGS - fexceptions " <nl> - touch testsuite / local . exp <nl> + touch local . exp <nl> else <nl> cat > local . exp < < EOF <nl> - set CC _ FOR _ TARGET $ CC <nl> + set CC _ FOR _ TARGET " $ CC " <nl> EOF <nl> fi <nl> <nl> diff - - git a / src / x86 / ffi . c b / src / x86 / ffi . c <nl> index 611e221 . . 3f46693 100644 <nl> - - - a / src / x86 / ffi . c <nl> + + + b / src / x86 / ffi . c <nl> @ @ - 424 , 7 + 424 , 7 @ @ void ffi _ call ( ffi _ cif * cif , void ( * fn ) ( void ) , void * rvalue , void * * avalue ) <nl> / * * private members * * / <nl> <nl> / * The following _ _ attribute _ _ ( ( regparm ( 1 ) ) ) decorations will have no effect <nl> - on MSVC - standard cdecl convention applies . * / <nl> + on MSVC or SUNPRO _ C - - standard conventions apply . * / <nl> static void ffi _ prep _ incoming _ args _ SYSV ( char * stack , void * * ret , <nl> void * * args , ffi _ cif * cif ) ; <nl> void FFI _ HIDDEN ffi _ closure _ SYSV ( ffi _ closure * ) <nl> diff - - git a / src / x86 / sysv . S b / src / x86 / sysv . S <nl> index 69e7e8d . . 71502bb 100644 <nl> - - - a / src / x86 / sysv . S <nl> + + + b / src / x86 / sysv . S <nl> @ @ - 182 , 9 + 182 , 19 @ @ ffi _ closure _ SYSV : <nl> 	 leal 	 - 24 ( % ebp ) , % edx <nl> 	 movl 	 % edx , - 12 ( % ebp ) 	 / * resp * / <nl> 	 leal 	 8 ( % ebp ) , % edx <nl> + # ifdef _ _ SUNPRO _ C <nl> + 	 / * The SUNPRO compiler doesn ' t support GCC ' s regparm function <nl> + 	 attribute , so we have to pass all three arguments to <nl> + 	 ffi _ closure _ SYSV _ inner on the stack . * / <nl> + 	 movl 	 % edx , 8 ( % esp ) 	 / * args = _ _ builtin _ dwarf _ cfa ( ) * / <nl> + 	 leal 	 - 12 ( % ebp ) , % edx <nl> + 	 movl 	 % edx , 4 ( % esp ) 	 / * & resp * / <nl> + 	 movl % eax , ( % esp ) / * closure * / <nl> + # else <nl> 	 movl 	 % edx , 4 ( % esp ) 	 / * args = _ _ builtin _ dwarf _ cfa ( ) * / <nl> 	 leal 	 - 12 ( % ebp ) , % edx <nl> 	 movl 	 % edx , ( % esp ) 	 / * & resp * / <nl> + # endif <nl> # if defined HAVE _ HIDDEN _ VISIBILITY _ ATTRIBUTE | | ! defined _ _ PIC _ _ <nl> 	 call 	 ffi _ closure _ SYSV _ inner <nl> # else

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index acd5f9f . . 8f80852 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 1 , 4 + 1 , 4 @ @ 
 - ï»¿ NOTE : as of JNA 4 . 0 , JNA is now dual - licensed under LGPL and ASL ( see LICENSE ) . 
 + NOTE : as of JNA 4 . 0 , JNA is now dual - licensed under LGPL and ASL ( see LICENSE ) . 
 
 NOTE : JNI native support is typically incompatible between minor versions , and almost always incompatible between major versions . 
 
 @ @ - 13 , 6 + 13 , 8 @ @ Features 
 * [ # 226 ] ( https : / / github . com / twall / jna / issues / 226 ) : Added OSGI information to jna - platform . jar - [ @ brettwooldridge ] ( https : / / github . com / brettwooldridge ) . 
 * [ # 267 ] ( https : / / github . com / twall / jna / pull / 267 ) : Added support for Windows RAS32 API , ` com . sun . jna . platform . win32 . Rasapi32 ` and ` Rasapi32Util ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . 
 * [ # 101 ] ( https : / / github . com / twall / jna / issues / 101 ) : Modify ` com . sun . jna . platform . win32 . Advapi32Util . registryGet * ` API to support ` KEY _ WOW64 ` option - [ @ falldog ] ( https : / / github . com / falldog ) . 
 + * [ # 271 ] ( https : / / github . com / twall / jna / pull / 271 ) : Added ` com . sun . jna . platform . win32 . Gdi32 . ChoosePixelFormat ` and ` SetPixelFormat ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . 
 + * [ # 271 ] ( https : / / github . com / twall / jna / pull / 271 ) : Added ` com . sun . jna . platform . win32 . OpenGL32 ` , ` OpenGL32Util ` and ` WinOpenGL ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 @ @ - 693 , 3 + 695 , 4 @ @ Bug Fixes 
 * Properly handle NULL when the return value is a Structure 
 * Proper conversion to wchar _ t on linux 
 * Copy full length of Java strings to C strings instead of stopping when a NUL character is encountered 
 + 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / GDI32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / GDI32 . java 
 index 4173820 . . 2924084 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / GDI32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / GDI32 . java 
 @ @ - 19 , 6 + 19 , 7 @ @ import com . sun . jna . platform . win32 . WinDef . HDC ; 
 import com . sun . jna . platform . win32 . WinDef . HRGN ; 
 import com . sun . jna . platform . win32 . WinGDI . BITMAPINFO ; 
 import com . sun . jna . platform . win32 . WinGDI . BITMAPINFOHEADER ; 
 + import com . sun . jna . platform . win32 . WinGDI . PIXELFORMATDESCRIPTOR ; 
 import com . sun . jna . platform . win32 . WinGDI . RGNDATA ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 import com . sun . jna . ptr . PointerByReference ; 
 @ @ - 313 , 4 + 314 , 33 @ @ public interface GDI32 extends StdCallLibrary { 
 * BITMAPINFO } structure . 
 * / 
 int GetDIBits ( HDC hdc , HBITMAP hbmp , int uStartScan , int cScanLines , Pointer lpvBits , BITMAPINFO lpbi , int uUsage ) ; 
 + 
 + / * * 
 + * The ChoosePixelFormat function attempts to match an appropriate pixel format supported 
 + * by a device context to a given pixel format specification . 
 + * 
 + * @ param hdc 
 + * Specifies the device context that the function examines to determine the best 
 + * match for the pixel format descriptor pointed to by ppfd . 
 + * @ param ppfd 
 + * Pointer to a PIXELFORMATDESCRIPTOR structure that specifies the requested pixel format . 
 + * @ return If the function succeeds , the return value is a pixel format index ( one - based ) that 
 + * is the closest match to the given pixel format descriptor . 
 + * / 
 + public int ChoosePixelFormat ( HDC hdc , PIXELFORMATDESCRIPTOR . ByReference ppfd ) ; 
 + 
 + / * * 
 + * The SetPixelFormat function sets the pixel format of the specified device context to the 
 + * format specified by the iPixelFormat index . 
 + * 
 + * @ param hdc 
 + * Specifies the device context whose pixel format the function attempts to set . 
 + * @ param iPixelFormat 
 + * Index that identifies the pixel format to set . The various pixel formats supported 
 + * by a device context are identified by one - based indexes . 
 + * @ param ppfd 
 + * Pointer to a PIXELFORMATDESCRIPTOR structure that contains the logical pixel format specification . 
 + * @ return true if successful 
 + * / 
 + public boolean SetPixelFormat ( HDC hdc , int iPixelFormat , PIXELFORMATDESCRIPTOR . ByReference ppfd ) ; 
 } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32 . java 
 new file mode 100644 
 index 0000000 . . 6ae66f6 
 - - - / dev / null 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32 . java 
 @ @ - 0 , 0 + 1 , 86 @ @ 
 + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation ; either 
 + * version 2 . 1 of the License , or ( at your option ) any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + import com . sun . jna . Native ; 
 + import com . sun . jna . Pointer ; 
 + import com . sun . jna . platform . win32 . WinDef . HDC ; 
 + import com . sun . jna . platform . win32 . WinOpenGL . HGLRC ; 
 + import com . sun . jna . win32 . StdCallLibrary ; 
 + 
 + / * * 
 + * opengl32 . dll Interface . 
 + * / 
 + public interface OpenGL32 extends StdCallLibrary { 
 + OpenGL32 INSTANCE = ( OpenGL32 ) Native . loadLibrary ( " opengl32 " , OpenGL32 . class ) ; 
 + 
 + / * * 
 + * The glGetString function returns a string describing the current OpenGL connection . 
 + * 
 + * @ param name 
 + * One of the following symbolic constants . 
 + * @ return The glGetString function returns a pointer to a static string describing some aspect of the current OpenGL connection . 
 + * / 
 + public String glGetString ( int name ) ; 
 + 
 + / * * 
 + * The wglCreateContext function creates a new OpenGL rendering context , which is suitable for drawing on the device 
 + * referenced by hdc . The rendering context has the same pixel format as the device context . 
 + * 
 + * @ param hdc 
 + * Handle to a device context for which the function creates a suitable OpenGL rendering context . 
 + * @ return handle to an OpenGL rendering context 
 + * / 
 + public HGLRC wglCreateContext ( HDC windowDC ) ; 
 + 
 + / * * 
 + * The wglGetCurrentContext function obtains a handle to the current OpenGL rendering context of the calling thread . 
 + * 
 + * @ return If the calling thread has a current OpenGL rendering context , wglGetCurrentContext returns a 
 + * handle to that rendering context . Otherwise , the return value is NULL . 
 + * / 
 + public HGLRC wglGetCurrentContext ( ) ; 
 + 
 + / * * 
 + * The wglMakeCurrent function makes a specified OpenGL rendering context the calling thread ' s current rendering 
 + * context . All subsequent OpenGL calls made by the thread are drawn on the device identified by hdc . 
 + * 
 + * @ param hdc 
 + * Handle to a device context . Subsequent OpenGL calls made by the calling thread are drawn on the 
 + * device identified by hdc . 
 + * @ param hglrc 
 + * Handle to an OpenGL rendering context that the function sets as the calling thread ' s rendering context . 
 + * @ return true if successful 
 + * / 
 + public boolean wglMakeCurrent ( HDC windowDC , HGLRC hglrc ) ; 
 + 
 + / * * 
 + * The wglDeleteContext function deletes a specified OpenGL rendering context . 
 + * 
 + * @ param hglrc 
 + * Handle to an OpenGL rendering context that the function will delete . 
 + * @ return true if successful 
 + * / 
 + public boolean wglDeleteContext ( HGLRC hglrc ) ; 
 + 
 + / * * 
 + * The wglGetProcAddress function returns the address of an OpenGL extension function for use with the 
 + * current OpenGL rendering context . 
 + * 
 + * @ param lpszProc 
 + * Points to a null - terminated string that is the name of the extension function . 
 + * The name of the extension function must be identical to a corresponding function implemented by OpenGL . 
 + * @ return When the function succeeds , the return value is the address of the extension function . 
 + * / 
 + public Pointer wglGetProcAddress ( String lpszProc ) ; 
 + } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32Util . java 
 new file mode 100644 
 index 0000000 . . 1bf9b30 
 - - - / dev / null 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / OpenGL32Util . java 
 @ @ - 0 , 0 + 1 , 81 @ @ 
 + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation ; either 
 + * version 2 . 1 of the License , or ( at your option ) any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + import com . sun . jna . Function ; 
 + import com . sun . jna . Pointer ; 
 + import com . sun . jna . platform . win32 . WinDef . HDC ; 
 + import com . sun . jna . platform . win32 . WinDef . HWND ; 
 + import com . sun . jna . platform . win32 . WinGDI . PIXELFORMATDESCRIPTOR ; 
 + import com . sun . jna . platform . win32 . WinOpenGL . HGLRC ; 
 + import com . sun . jna . platform . win32 . WinOpenGL . HGPUNVByReference ; 
 + 
 + / * * 
 + * opengl32 utility API . 
 + * / 
 + public abstract class OpenGL32Util { 
 + 
 + / * * 
 + * Return a procedure function pointer 
 + * @ param procName the procedure name 
 + * @ return the function 
 + * / 
 + public static Function wglGetProcAddress ( String procName ) { 
 + Pointer funcPointer = OpenGL32 . INSTANCE . wglGetProcAddress ( " wglEnumGpusNV " ) ; 
 + return ( funcPointer = = null ) ? null : Function . getFunction ( funcPointer ) ; 
 + } 
 + 
 + / * * 
 + * Return a RAS connection by name 
 + * @ param connName the connection name 
 + * @ return the RAS connection structure 
 + * / 
 + public static int countGpusNV ( ) { 
 + / / create a dummy window 
 + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; 
 + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; 
 + 
 + / / set a compatible pixel format 
 + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; 
 + pfd . nVersion = 1 ; 
 + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; 
 + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; 
 + pfd . cColorBits = 24 ; 
 + pfd . cDepthBits = 16 ; 
 + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; 
 + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; 
 + 
 + / / create the OpenGL context to get function address 
 + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; 
 + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; 
 + Pointer funcPointer = OpenGL32 . INSTANCE . wglGetProcAddress ( " wglEnumGpusNV " ) ; 
 + Function fncEnumGpusNV = ( funcPointer = = null ) ? null : Function . getFunction ( funcPointer ) ; 
 + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; 
 + 
 + / / destroy the window 
 + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; 
 + User32Util . destroyWindow ( hWnd ) ; 
 + 
 + / / abort if the nVidia extensions are not present 
 + if ( fncEnumGpusNV = = null ) return 0 ; 
 + 
 + / / enumerate nVidia adapters 
 + HGPUNVByReference hGPU = new HGPUNVByReference ( ) ; 
 + for ( int i = 0 ; i < 16 ; i + + ) { 
 + Boolean ok = ( Boolean ) fncEnumGpusNV . invoke ( Boolean . class , new Object [ ] { Integer . valueOf ( i ) , hGPU , } ) ; 
 + if ( ! ok . booleanValue ( ) ) return i ; 
 + } 
 + 
 + return 0 ; 
 + } 
 + } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinGDI . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinGDI . java 
 index c8bc6df . . b8855ce 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinGDI . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinGDI . java 
 @ @ - 15 , 6 + 15 , 7 @ @ package com . sun . jna . platform . win32 ; 
 import java . util . Arrays ; 
 import java . util . List ; 
 
 + import com . sun . jna . Pointer ; 
 import com . sun . jna . Structure ; 
 import com . sun . jna . platform . win32 . WinDef . RECT ; 
 import com . sun . jna . win32 . StdCallLibrary ; 
 @ @ - 77 , 6 + 78 , 28 @ @ public interface WinGDI extends StdCallLibrary { 
 public int BI _ JPEG = 4 ; 
 public int BI _ PNG = 5 ; 
 
 + public final int PFD _ TYPE _ RGBA = 0 ; 
 + public final int PFD _ TYPE _ COLORINDEX = 1 ; 
 + 
 + public final int PFD _ MAIN _ PLANE = 0 ; 
 + public final int PFD _ OVERLAY _ PLANE = 1 ; 
 + public final int PFD _ UNDERLAY _ PLANE = ( - 1 ) ; 
 + 
 + public final int PFD _ DOUBLEBUFFER = 0x00000001 ; 
 + public final int PFD _ STEREO = 0x00000002 ; 
 + public final int PFD _ DRAW _ TO _ WINDOW = 0x00000004 ; 
 + public final int PFD _ DRAW _ TO _ BITMAP = 0x00000008 ; 
 + public final int PFD _ SUPPORT _ GDI = 0x00000010 ; 
 + public final int PFD _ SUPPORT _ OPENGL = 0x00000020 ; 
 + public final int PFD _ GENERIC _ FORMAT = 0x00000040 ; 
 + public final int PFD _ NEED _ PALETTE = 0x00000080 ; 
 + public final int PFD _ NEED _ SYSTEM _ PALETTE = 0x00000100 ; 
 + public final int PFD _ SWAP _ EXCHANGE = 0x00000200 ; 
 + public final int PFD _ SWAP _ COPY = 0x00000400 ; 
 + public final int PFD _ SWAP _ LAYER _ BUFFERS = 0x00000800 ; 
 + public final int PFD _ GENERIC _ ACCELERATED = 0x00001000 ; 
 + public final int PFD _ SUPPORT _ DIRECTDRAW = 0x00002000 ; 
 + 
 public class BITMAPINFOHEADER extends Structure { 
 public int biSize = size ( ) ; 
 public int biWidth ; 
 @ @ - 118 , 4 + 141 , 136 @ @ public interface WinGDI extends StdCallLibrary { 
 
 public int DIB _ RGB _ COLORS = 0 ; 
 public int DIB _ PAL _ COLORS = 1 ; 
 + 
 + / * * 
 + * The PIXELFORMATDESCRIPTOR structure describes the pixel format of a drawing surface . 
 + * / 
 + public static class PIXELFORMATDESCRIPTOR extends Structure { 
 + public PIXELFORMATDESCRIPTOR ( ) { 
 + super ( ) ; 
 + nSize = ( short ) size ( ) ; 
 + } 
 + 
 + public PIXELFORMATDESCRIPTOR ( Pointer memory ) { 
 + super ( memory ) ; 
 + read ( ) ; 
 + } 
 + 
 + public static class ByReference extends PIXELFORMATDESCRIPTOR implements Structure . ByReference { 
 + } 
 + 
 + / * * 
 + * Specifies the size of this data structure . This value should be set to sizeof ( PIXELFORMATDESCRIPTOR ) . 
 + * / 
 + public short nSize ; 
 + / * * 
 + * Specifies the version of this data structure . This value should be set to 1 . 
 + * / 
 + public short nVersion ; 
 + / * * 
 + * A set of bit flags that specify properties of the pixel buffer . 
 + * / 
 + public int dwFlags ; 
 + / * * 
 + * Specifies the type of pixel data . 
 + * / 
 + public byte iPixelType ; 
 + / * * 
 + * Specifies the number of color bitplanes in each color buffer . 
 + * / 
 + public byte cColorBits ; 
 + / * * 
 + * Specifies the number of red bitplanes in each RGBA color buffer . 
 + * / 
 + public byte cRedBits ; 
 + / * * 
 + * Specifies the shift count for red bitplanes in each RGBA color buffer . 
 + * / 
 + public byte cRedShift ; 
 + / * * 
 + * Specifies the number of green bitplanes in each RGBA color buffer . 
 + * / 
 + public byte cGreenBits ; 
 + / * * 
 + * Specifies the shift count for green bitplanes in each RGBA color buffer . 
 + * / 
 + public byte cGreenShift ; 
 + / * * 
 + * Specifies the number of blue bitplanes in each RGBA color buffer . 
 + * / 
 + public byte cBlueBits ; 
 + / * * 
 + * Specifies the shift count for blue bitplanes in each RGBA color buffer . 
 + * / 
 + public byte cBlueShift ; 
 + / * * 
 + * Specifies the number of alpha bitplanes in each RGBA color buffer . Alpha bitplanes are not supported . 
 + * / 
 + public byte cAlphaBits ; 
 + / * * 
 + * Specifies the shift count for alpha bitplanes in each RGBA color buffer . Alpha bitplanes are not supported . 
 + * / 
 + public byte cAlphaShift ; 
 + / * * 
 + * Specifies the total number of bitplanes in the accumulation buffer . 
 + * / 
 + public byte cAccumBits ; 
 + / * * 
 + * Specifies the number of red bitplanes in the accumulation buffer . 
 + * / 
 + public byte cAccumRedBits ; 
 + / * * 
 + * Specifies the number of green bitplanes in the accumulation buffer . 
 + * / 
 + public byte cAccumGreenBits ; 
 + / * * 
 + * Specifies the number of blue bitplanes in the accumulation buffer . 
 + * / 
 + public byte cAccumBlueBits ; 
 + / * * 
 + * Specifies the number of alpha bitplanes in the accumulation buffer . 
 + * / 
 + public byte cAccumAlphaBits ; 
 + / * * 
 + * Specifies the depth of the depth ( z - axis ) buffer . 
 + * / 
 + public byte cDepthBits ; 
 + / * * 
 + * Specifies the depth of the stencil buffer . 
 + * / 
 + public byte cStencilBits ; 
 + / * * 
 + * Specifies the number of auxiliary buffers . Auxiliary buffers are not supported . 
 + * / 
 + public byte cAuxBuffers ; 
 + / * * 
 + * Ignored . Earlier implementations of OpenGL used this member , but it is no longer used . 
 + * / 
 + public byte iLayerType ; 
 + / * * 
 + * Specifies the number of overlay and underlay planes . 
 + * / 
 + public byte bReserved ; 
 + / * * 
 + * Ignored . Earlier implementations of OpenGL used this member , but it is no longer used . 
 + * / 
 + public int dwLayerMask ; 
 + / * * 
 + * Specifies the transparent color or index of an underlay plane . 
 + * / 
 + public int dwVisibleMask ; 
 + / * * 
 + * Ignored . Earlier implementations of OpenGL used this member , but it is no longer used . 
 + * / 
 + public int dwDamageMask ; 
 + 
 + @ SuppressWarnings ( " rawtypes " ) 
 + @ Override 
 + protected List getFieldOrder ( ) { 
 + return Arrays . asList ( new String [ ] { " nSize " , " nVersion " , " dwFlags " , " iPixelType " , 
 + " cColorBits " , " cRedBits " , " cRedShift " , " cGreenBits " , " cGreenShift " , " cBlueBits " , " cBlueShift " , " cAlphaBits " , " cAlphaShift " , 
 + " cAccumBits " , " cAccumRedBits " , " cAccumGreenBits " , " cAccumBlueBits " , " cAccumAlphaBits " , 
 + " cDepthBits " , " cStencilBits " , " cAuxBuffers " , " iLayerType " , " bReserved " , " dwLayerMask " , " dwVisibleMask " , " dwDamageMask " , } ) ; 
 + } 
 + } 
 } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinOpenGL . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinOpenGL . java 
 new file mode 100644 
 index 0000000 . . 6b77b22 
 - - - / dev / null 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinOpenGL . java 
 @ @ - 0 , 0 + 1 , 98 @ @ 
 + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation ; either 
 + * version 2 . 1 of the License , or ( at your option ) any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + import com . sun . jna . Pointer ; 
 + import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 + import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; 
 + import com . sun . jna . win32 . StdCallLibrary ; 
 + 
 + / * * 
 + * Definitions for WinOpenGL 
 + * / 
 + public interface WinOpenGL extends StdCallLibrary { 
 + 
 + public final int GL _ VENDOR = 0x1F00 ; 
 + public final int GL _ RENDERER = 0x1F01 ; 
 + public final int GL _ VERSION = 0x1F02 ; 
 + public final int GL _ EXTENSIONS = 0x1F03 ; 
 + 
 + / * * 
 + * handle to an OpenGL rendering context 
 + * / 
 + public static class HGLRC extends HANDLE { 
 + 
 + / * * 
 + * Instantiates a new HGLRC . 
 + * / 
 + public HGLRC ( ) { 
 + 
 + } 
 + 
 + / * * 
 + * Instantiates a new HGLRC . 
 + * 
 + * @ param p 
 + * the p 
 + * / 
 + public HGLRC ( Pointer p ) { 
 + super ( p ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * handle to an OpenGL rendering context 
 + * / 
 + public static class HGPUNV extends HANDLE { 
 + 
 + / * * 
 + * Instantiates a new HGLRC . 
 + * / 
 + public HGPUNV ( ) { 
 + 
 + } 
 + 
 + / * * 
 + * Instantiates a new HGLRC . 
 + * 
 + * @ param p 
 + * the p 
 + * / 
 + public HGPUNV ( Pointer p ) { 
 + super ( p ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * handle to an OpenGL rendering context 
 + * / 
 + public static class HGPUNVByReference extends HANDLEByReference { 
 + 
 + / * * 
 + * Instantiates a new HGLRC . 
 + * / 
 + public HGPUNVByReference ( ) { 
 + 
 + } 
 + 
 + / * * 
 + * Instantiates a new HGLRC . 
 + * 
 + * @ param p 
 + * the p 
 + * / 
 + public HGPUNVByReference ( HGPUNV h ) { 
 + super ( h ) ; 
 + } 
 + } 
 + } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinRas . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinRas . java 
 index ff8a008 . . 13d8142 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinRas . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinRas . java 
 @ @ - 291 , 7 + 291 , 6 @ @ public interface WinRas extends StdCallLibrary { 
 	 	 public RASCONN ( ) { 
 	 	 	 super ( ) ; 
 	 	 	 dwSize = size ( ) ; 
 - 	 	 	 System . out . println ( " Size = " + dwSize ) ; 
 	 	 } 
 
 	 	 public RASCONN ( Pointer memory ) { 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32Test . java 
 new file mode 100644 
 index 0000000 . . ddc4784 
 - - - / dev / null 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32Test . java 
 @ @ - 0 , 0 + 1 , 174 @ @ 
 + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation ; either 
 + * version 2 . 1 of the License , or ( at your option ) any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + import junit . framework . TestCase ; 
 + 
 + import com . sun . jna . platform . win32 . WinDef . HDC ; 
 + import com . sun . jna . platform . win32 . WinDef . HWND ; 
 + import com . sun . jna . platform . win32 . WinGDI . PIXELFORMATDESCRIPTOR ; 
 + import com . sun . jna . platform . win32 . WinOpenGL . HGLRC ; 
 + 
 + / * * 
 + * @ author drrobison @ openroadsconsulting . com 
 + * / 
 + public class OpenGL32Test extends TestCase { 
 + 
 + public static void main ( String [ ] args ) { 
 + junit . textui . TestRunner . run ( OpenGL32Test . class ) ; 
 + } 
 + 
 + public void testGetStringGLVersion ( ) { 
 + / / create a dummy window 
 + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; 
 + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; 
 + 
 + / / set a compatible pixel format 
 + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; 
 + pfd . nVersion = 1 ; 
 + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; 
 + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; 
 + pfd . cColorBits = 24 ; 
 + pfd . cDepthBits = 16 ; 
 + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; 
 + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; 
 + 
 + / / create the OpenGL context 
 + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; 
 + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; 
 + String glString = OpenGL32 . INSTANCE . glGetString ( WinOpenGL . GL _ VERSION ) ; 
 + System . out . println ( " GL _ VERSION = " + glString ) ; 
 + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; 
 + 
 + / / destroy the window 
 + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; 
 + User32Util . destroyWindow ( hWnd ) ; 
 + 
 + assertNotNull ( " Could not get GL _ VERSION " , glString ) ; 
 + } 
 + 
 + public void testGetStringGLRenderer ( ) { 
 + / / create a dummy window 
 + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; 
 + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; 
 + 
 + / / set a compatible pixel format 
 + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; 
 + pfd . nVersion = 1 ; 
 + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; 
 + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; 
 + pfd . cColorBits = 24 ; 
 + pfd . cDepthBits = 16 ; 
 + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; 
 + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; 
 + 
 + / / create the OpenGL context 
 + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; 
 + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; 
 + String glString = OpenGL32 . INSTANCE . glGetString ( WinOpenGL . GL _ RENDERER ) ; 
 + System . out . println ( " GL _ RENDERER = " + glString ) ; 
 + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; 
 + 
 + / / destroy the window 
 + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; 
 + User32Util . destroyWindow ( hWnd ) ; 
 + 
 + assertNotNull ( " Could not get GL _ RENDERER " , glString ) ; 
 + } 
 + 
 + public void testGetStringGLVendor ( ) { 
 + / / create a dummy window 
 + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; 
 + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; 
 + 
 + / / set a compatible pixel format 
 + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; 
 + pfd . nVersion = 1 ; 
 + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; 
 + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; 
 + pfd . cColorBits = 24 ; 
 + pfd . cDepthBits = 16 ; 
 + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; 
 + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; 
 + 
 + / / create the OpenGL context 
 + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; 
 + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; 
 + String glString = OpenGL32 . INSTANCE . glGetString ( WinOpenGL . GL _ VENDOR ) ; 
 + System . out . println ( " GL _ VENDOR = " + glString ) ; 
 + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; 
 + 
 + / / destroy the window 
 + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; 
 + User32Util . destroyWindow ( hWnd ) ; 
 + 
 + assertNotNull ( " Could not get GL _ VENDOR " , glString ) ; 
 + } 
 + 
 + public void testGetStringGLExtensions ( ) { 
 + / / create a dummy window 
 + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; 
 + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; 
 + 
 + / / set a compatible pixel format 
 + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; 
 + pfd . nVersion = 1 ; 
 + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; 
 + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; 
 + pfd . cColorBits = 24 ; 
 + pfd . cDepthBits = 16 ; 
 + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; 
 + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; 
 + 
 + / / create the OpenGL context 
 + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; 
 + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; 
 + String glString = OpenGL32 . INSTANCE . glGetString ( WinOpenGL . GL _ EXTENSIONS ) ; 
 + System . out . println ( " GL _ EXTENSIONS = " + glString ) ; 
 + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; 
 + 
 + / / destroy the window 
 + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; 
 + User32Util . destroyWindow ( hWnd ) ; 
 + 
 + assertNotNull ( " Could not get GL _ EXTENSIONS " , glString ) ; 
 + } 
 + 
 + public void testGetCurrentContext ( ) { 
 + / / create a dummy window 
 + HWND hWnd = User32Util . createWindow ( " Message " , null , 0 , 0 , 0 , 0 , 0 , null , null , null , null ) ; 
 + HDC hdc = User32 . INSTANCE . GetDC ( hWnd ) ; 
 + 
 + / / set a compatible pixel format 
 + PIXELFORMATDESCRIPTOR . ByReference pfd = new PIXELFORMATDESCRIPTOR . ByReference ( ) ; 
 + pfd . nVersion = 1 ; 
 + pfd . dwFlags = WinGDI . PFD _ DRAW _ TO _ WINDOW | WinGDI . PFD _ SUPPORT _ OPENGL | WinGDI . PFD _ DOUBLEBUFFER ; 
 + pfd . iPixelType = WinGDI . PFD _ TYPE _ RGBA ; 
 + pfd . cColorBits = 24 ; 
 + pfd . cDepthBits = 16 ; 
 + pfd . iLayerType = WinGDI . PFD _ MAIN _ PLANE ; 
 + GDI32 . INSTANCE . SetPixelFormat ( hdc , GDI32 . INSTANCE . ChoosePixelFormat ( hdc , pfd ) , pfd ) ; 
 + 
 + / / create the OpenGL context 
 + HGLRC hGLRC = OpenGL32 . INSTANCE . wglCreateContext ( hdc ) ; 
 + OpenGL32 . INSTANCE . wglMakeCurrent ( hdc , hGLRC ) ; 
 + HGLRC currentContext = OpenGL32 . INSTANCE . wglGetCurrentContext ( ) ; 
 + OpenGL32 . INSTANCE . wglDeleteContext ( hGLRC ) ; 
 + 
 + / / destroy the window 
 + User32 . INSTANCE . ReleaseDC ( hWnd , hdc ) ; 
 + User32Util . destroyWindow ( hWnd ) ; 
 + 
 + assertNotNull ( " Could not get current context " , currentContext ) ; 
 + } 
 + } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32UtilTest . java 
 new file mode 100644 
 index 0000000 . . 83157ac 
 - - - / dev / null 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / OpenGL32UtilTest . java 
 @ @ - 0 , 0 + 1 , 30 @ @ 
 + / * Copyright ( c ) 2011 Timothy Wall , All Rights Reserved 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation ; either 
 + * version 2 . 1 of the License , or ( at your option ) any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + import junit . framework . TestCase ; 
 + 
 + / * * 
 + * @ author drrobison @ openroadsconsulting . com 
 + * / 
 + public class OpenGL32UtilTest extends TestCase { 
 + 
 + public static void main ( String [ ] args ) { 
 + junit . textui . TestRunner . run ( OpenGL32UtilTest . class ) ; 
 + } 
 + 
 + public void testCountGpusNV ( ) { 
 + int cnt = OpenGL32Util . countGpusNV ( ) ; 
 + assertTrue ( " Expecting > = 0 " , cnt > = 0 ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / ChangeLog b / ChangeLog 
 index 289d195 . . ff76645 100644 
 - - - a / ChangeLog 
 + + + b / ChangeLog 
 @ @ - 1 , 3 + 1 , 13 @ @ 
 + 2013 - 01 - 10 Anthony Green < green @ moxielogic . com > 
 + 
 + 	 * configure . ac : Put local . exp in the right place . 
 + 	 * configure : Rebuilt . 
 + 
 + 	 * src / x86 / ffi . c : Update comment about regparm function attributes . 
 + 	 * src / x86 / sysv . S ( ffi _ closure _ SYSV ) : The SUNPRO compiler requires 
 + 	 that all function arguments be passed on the stack ( no regparm 
 + 	 support ) . 
 + 
 2013 - 01 - 08 Anthony Green < green @ moxielogic . com > 
 
 	 * configure . ac : Generate local . exp . This sets CC _ FOR _ TARGET 
 diff - - git a / configure b / configure 
 index 5876eb7 . . 4a12b96 100755 
 - - - a / configure 
 + + + b / configure 
 @ @ - 13068 , 10 + 13068 , 10 @ @ ac _ compiler _ gnu = $ ac _ cv _ c _ compiler _ gnu 
 
 if test " x $ GCC " = " xyes " ; then 
 CFLAGS = " $ CFLAGS - fexceptions " 
 - touch testsuite / local . exp 
 + touch local . exp 
 else 
 cat > local . exp < < EOF 
 - set CC _ FOR _ TARGET $ CC 
 + set CC _ FOR _ TARGET " $ CC " 
 EOF 
 fi 
 
 diff - - git a / configure . ac b / configure . ac 
 index 7ffb36c . . 13d5bc2 100644 
 - - - a / configure . ac 
 + + + b / configure . ac 
 @ @ - 40 , 10 + 40 , 10 @ @ AX _ CC _ MAXOPT 
 AX _ CFLAGS _ WARN _ ALL 
 if test " x $ GCC " = " xyes " ; then 
 CFLAGS = " $ CFLAGS - fexceptions " 
 - touch testsuite / local . exp 
 + touch local . exp 
 else 
 cat > local . exp < < EOF 
 - set CC _ FOR _ TARGET $ CC 
 + set CC _ FOR _ TARGET " $ CC " 
 EOF 
 fi 
 
 diff - - git a / src / x86 / ffi . c b / src / x86 / ffi . c 
 index 611e221 . . 3f46693 100644 
 - - - a / src / x86 / ffi . c 
 + + + b / src / x86 / ffi . c 
 @ @ - 424 , 7 + 424 , 7 @ @ void ffi _ call ( ffi _ cif * cif , void ( * fn ) ( void ) , void * rvalue , void * * avalue ) 
 / * * private members * * / 
 
 / * The following _ _ attribute _ _ ( ( regparm ( 1 ) ) ) decorations will have no effect 
 - on MSVC - standard cdecl convention applies . * / 
 + on MSVC or SUNPRO _ C - - standard conventions apply . * / 
 static void ffi _ prep _ incoming _ args _ SYSV ( char * stack , void * * ret , 
 void * * args , ffi _ cif * cif ) ; 
 void FFI _ HIDDEN ffi _ closure _ SYSV ( ffi _ closure * ) 
 diff - - git a / src / x86 / sysv . S b / src / x86 / sysv . S 
 index 69e7e8d . . 71502bb 100644 
 - - - a / src / x86 / sysv . S 
 + + + b / src / x86 / sysv . S 
 @ @ - 182 , 9 + 182 , 19 @ @ ffi _ closure _ SYSV : 
 	 leal 	 - 24 ( % ebp ) , % edx 
 	 movl 	 % edx , - 12 ( % ebp ) 	 / * resp * / 
 	 leal 	 8 ( % ebp ) , % edx 
 + # ifdef _ _ SUNPRO _ C 
 + 	 / * The SUNPRO compiler doesn ' t support GCC ' s regparm function 
 + 	 attribute , so we have to pass all three arguments to 
 + 	 ffi _ closure _ SYSV _ inner on the stack . * / 
 + 	 movl 	 % edx , 8 ( % esp ) 	 / * args = _ _ builtin _ dwarf _ cfa ( ) * / 
 + 	 leal 	 - 12 ( % ebp ) , % edx 
 + 	 movl 	 % edx , 4 ( % esp ) 	 / * & resp * / 
 + 	 movl % eax , ( % esp ) / * closure * / 
 + # else 
 	 movl 	 % edx , 4 ( % esp ) 	 / * args = _ _ builtin _ dwarf _ cfa ( ) * / 
 	 leal 	 - 12 ( % ebp ) , % edx 
 	 movl 	 % edx , ( % esp ) 	 / * & resp * / 
 + # endif 
 # if defined HAVE _ HIDDEN _ VISIBILITY _ ATTRIBUTE | | ! defined _ _ PIC _ _ 
 	 call 	 ffi _ closure _ SYSV _ inner 
 # else
