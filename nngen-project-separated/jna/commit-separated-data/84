BLEU SCORE: 0.027611988917697356

TEST MSG: Tighten the generic bounds for Structure # newInstance
GENERATED MSG: used optimized structure + pointer ctor when possible

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index a8d0f98 . . 7be5836 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 7 , 6 + 7 , 8 @ @ Release 5 . 0 . 0 ( Next release ) <nl> <nl> Features <nl> - - - - - - - - <nl> + * [ # 822 ] ( https : / / github . com / java - native - access / jna / issues / 822 ) : ` Native # loadLibrary ` requires that the interface class passed in is an instance of Library . The runtime check can be enhanced by using a constraint generic . This breaks binary compatibility ( see notes below ) - [ @ d - noll ] ( https : / / github . com / d - noll ) . <nl> + * [ # 889 ] ( https : / / github . com / java - native - access / jna / issues / 889 ) : The ` Structure # newInstance ` receive the target type as a parameter . This adds a limited generic type , so that the return type ist the target type and not a generic structure , removing the necessity to do an explizit cast - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Winevt . java b / contrib / platform / src / com / sun / jna / platform / win32 / Winevt . java <nl> index 9ce7d5c . . 71a46e0 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Winevt . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Winevt . java <nl> @ @ - 488 , 7 + 488 , 7 @ @ public interface Winevt { <nl> return isArray ( ) ? field1 . getPointer ( ) . getPointer ( 0 ) . getWideStringArray ( 0 , Count ) : field1 . getPointer ( ) . getPointer ( 0 ) . getWideString ( 0 ) ; <nl> case EvtVarTypeFileTime : <nl> if ( isArray ( ) ) { <nl> - WinBase . FILETIME resultFirst = ( WinBase . FILETIME ) Structure . newInstance ( WinBase . FILETIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> + WinBase . FILETIME resultFirst = Structure . newInstance ( WinBase . FILETIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> resultFirst . read ( ) ; <nl> return resultFirst . toArray ( Count ) ; <nl> } else { <nl> @ @ - 498 , 11 + 498 , 11 @ @ public interface Winevt { <nl> } <nl> case EvtVarTypeSysTime : <nl> if ( isArray ( ) ) { <nl> - WinBase . SYSTEMTIME resultFirst = ( WinBase . SYSTEMTIME ) Structure . newInstance ( WinBase . SYSTEMTIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> + WinBase . SYSTEMTIME resultFirst = Structure . newInstance ( WinBase . SYSTEMTIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> resultFirst . read ( ) ; <nl> return resultFirst . toArray ( Count ) ; <nl> } else { <nl> - WinBase . SYSTEMTIME result = ( WinBase . SYSTEMTIME ) Structure . newInstance ( WinBase . SYSTEMTIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> + WinBase . SYSTEMTIME result = Structure . newInstance ( WinBase . SYSTEMTIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> result . read ( ) ; <nl> return result ; <nl> } <nl> @ @ - 531 , 21 + 531 , 21 @ @ public interface Winevt { <nl> return null ; <nl> case EvtVarTypeGuid : <nl> if ( isArray ( ) ) { <nl> - Guid . GUID resultFirst = ( Guid . GUID ) Structure . newInstance ( Guid . GUID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> + Guid . GUID resultFirst = Structure . newInstance ( Guid . GUID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> resultFirst . read ( ) ; <nl> return resultFirst . toArray ( Count ) ; <nl> } else { <nl> - Guid . GUID result = ( Guid . GUID ) Structure . newInstance ( Guid . GUID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> + Guid . GUID result = Structure . newInstance ( Guid . GUID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> result . read ( ) ; <nl> return result ; <nl> } <nl> case EvtVarTypeSid : <nl> if ( isArray ( ) ) { <nl> - WinNT . PSID resultFirst = ( WinNT . PSID ) Structure . newInstance ( WinNT . PSID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> + WinNT . PSID resultFirst = Structure . newInstance ( WinNT . PSID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> resultFirst . read ( ) ; <nl> return resultFirst . toArray ( Count ) ; <nl> } else { <nl> - WinNT . PSID result = ( WinNT . PSID ) Structure . newInstance ( WinNT . PSID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> + WinNT . PSID result = Structure . newInstance ( WinNT . PSID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; <nl> result . read ( ) ; <nl> return result ; <nl> } <nl> diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java <nl> index 5c9d62c . . 8fcb347 100644 <nl> - - - a / src / com / sun / jna / CallbackReference . java <nl> + + + b / src / com / sun / jna / CallbackReference . java <nl> @ @ - 272 , 7 + 272 , 7 @ @ public class CallbackReference extends WeakReference < Callback > { <nl> private Class < ? > getNativeType ( Class < ? > cls ) { <nl> if ( Structure . class . isAssignableFrom ( cls ) ) { <nl> / / Make sure we can instantiate an argument of this type <nl> - Structure . validate ( cls ) ; <nl> + Structure . validate ( ( Class < ? extends Structure > ) cls ) ; <nl> if ( ! Structure . ByValue . class . isAssignableFrom ( cls ) ) <nl> return Pointer . class ; <nl> } else if ( NativeMapped . class . isAssignableFrom ( cls ) ) { <nl> @ @ - 580 , 14 + 580 , 14 @ @ public class CallbackReference extends WeakReference < Callback > { <nl> / / If passed by value , don ' t hold onto the pointer , which <nl> / / is only valid for the duration of the callback call <nl> if ( Structure . ByValue . class . isAssignableFrom ( dstType ) ) { <nl> - Structure s = Structure . newInstance ( dstType ) ; <nl> + Structure s = Structure . newInstance ( ( Class < ? extends Structure > ) dstType ) ; <nl> byte [ ] buf = new byte [ s . size ( ) ] ; <nl> ( ( Pointer ) value ) . read ( 0 , buf , 0 , buf . length ) ; <nl> s . getPointer ( ) . write ( 0 , buf , 0 , buf . length ) ; <nl> s . read ( ) ; <nl> value = s ; <nl> } else { <nl> - Structure s = Structure . newInstance ( dstType , ( Pointer ) value ) ; <nl> + Structure s = Structure . newInstance ( ( Class < ? extends Structure > ) dstType , ( Pointer ) value ) ; <nl> s . conditionalAutoRead ( ) ; <nl> value = s ; <nl> } <nl> diff - - git a / src / com / sun / jna / Function . java b / src / com / sun / jna / Function . java <nl> index 795901d . . 2d31827 100644 <nl> - - - a / src / com / sun / jna / Function . java <nl> + + + b / src / com / sun / jna / Function . java <nl> @ @ - 378 , 11 + 378 , 11 @ @ public class Function extends Pointer { <nl> if ( args [ i ] instanceof PointerArray ) { <nl> PointerArray array = ( PointerArray ) args [ i ] ; <nl> if ( Structure . ByReference [ ] . class . isAssignableFrom ( inArg . getClass ( ) ) ) { <nl> - Class < ? > type = inArg . getClass ( ) . getComponentType ( ) ; <nl> + Class < ? extends Structure > type = ( Class < ? extends Structure > ) inArg . getClass ( ) . getComponentType ( ) ; <nl> Structure [ ] ss = ( Structure [ ] ) inArg ; <nl> for ( int si = 0 ; si < ss . length ; si + + ) { <nl> Pointer p = array . getPointer ( Native . POINTER _ SIZE * si ) ; <nl> - ss [ si ] = Structure . updateStructureByReference ( type , ss [ si ] , p ) ; <nl> + ss [ si ] = Structure . updateStructureByReference ( ( Class < Structure > ) type , ss [ si ] , p ) ; <nl> } <nl> } <nl> } <nl> @ @ - 436 , 13 + 436 , 13 @ @ public class Function extends Pointer { <nl> if ( Structure . ByValue . class . isAssignableFrom ( returnType ) ) { <nl> Structure s = <nl> Native . invokeStructure ( this , this . peer , callFlags , args , <nl> - Structure . newInstance ( returnType ) ) ; <nl> + Structure . newInstance ( ( Class < ? extends Structure > ) returnType ) ) ; <nl> s . autoRead ( ) ; <nl> result = s ; <nl> } else { <nl> result = invokePointer ( callFlags , args ) ; <nl> if ( result ! = null ) { <nl> - Structure s = Structure . newInstance ( returnType , ( Pointer ) result ) ; <nl> + Structure s = Structure . newInstance ( ( Class < ? extends Structure > ) returnType , ( Pointer ) result ) ; <nl> s . conditionalAutoRead ( ) ; <nl> result = s ; <nl> } <nl> @ @ - 604 , 7 + 604 , 7 @ @ public class Function extends Pointer { <nl> } else if ( ss . length = = 0 ) { <nl> throw new IllegalArgumentException ( " Structure array must have non - zero length " ) ; <nl> } else if ( ss [ 0 ] = = null ) { <nl> - Structure . newInstance ( type ) . toArray ( ss ) ; <nl> + Structure . newInstance ( ( Class < ? extends Structure > ) type ) . toArray ( ss ) ; <nl> return ss [ 0 ] . getPointer ( ) ; <nl> } else { <nl> Structure . autoWrite ( ss ) ; <nl> diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java <nl> index 33e8e56 . . ae80566 100644 <nl> - - - a / src / com / sun / jna / Native . java <nl> + + + b / src / com / sun / jna / Native . java <nl> @ @ - 1241 , 7 + 1241 , 7 @ @ public final class Native implements Version { <nl> } <nl> if ( Structure . class . isAssignableFrom ( type ) <nl> & & ! Structure . ByReference . class . isAssignableFrom ( type ) ) { <nl> - return Structure . size ( type , ( Structure ) value ) ; <nl> + return Structure . size ( ( Class < Structure > ) type , ( Structure ) value ) ; <nl> } <nl> try { <nl> return getNativeSize ( type ) ; <nl> @ @ - 1276 , 7 + 1276 , 7 @ @ public final class Native implements Version { <nl> if ( cls = = double . class | | cls = = Double . class ) return 8 ; <nl> if ( Structure . class . isAssignableFrom ( cls ) ) { <nl> if ( Structure . ByValue . class . isAssignableFrom ( cls ) ) { <nl> - return Structure . size ( cls ) ; <nl> + return Structure . size ( ( Class < ? extends Structure > ) cls ) ; <nl> } <nl> return POINTER _ SIZE ; <nl> } <nl> diff - - git a / src / com / sun / jna / Pointer . java b / src / com / sun / jna / Pointer . java <nl> index 16ad03f . . c111f9a 100644 <nl> - - - a / src / com / sun / jna / Pointer . java <nl> + + + b / src / com / sun / jna / Pointer . java <nl> @ @ - 363 , 7 + 363 , 7 @ @ public class Pointer { <nl> if ( Structure . class . isAssignableFrom ( type ) ) { <nl> Structure s = ( Structure ) currentValue ; <nl> if ( Structure . ByReference . class . isAssignableFrom ( type ) ) { <nl> - s = Structure . updateStructureByReference ( type , s , getPointer ( offset ) ) ; <nl> + s = Structure . updateStructureByReference ( ( Class < Structure > ) type , s , getPointer ( offset ) ) ; <nl> } else { <nl> s . useMemory ( this , ( int ) offset , true ) ; <nl> s . read ( ) ; <nl> @ @ - 488 , 13 + 488 , 13 @ @ public class Pointer { <nl> if ( Structure . ByReference . class . isAssignableFrom ( cls ) ) { <nl> Pointer [ ] parray = getPointerArray ( offset , sarray . length ) ; <nl> for ( int i = 0 ; i < sarray . length ; i + + ) { <nl> - sarray [ i ] = Structure . updateStructureByReference ( cls , sarray [ i ] , parray [ i ] ) ; <nl> + sarray [ i ] = Structure . updateStructureByReference ( ( Class < Structure > ) cls , sarray [ i ] , parray [ i ] ) ; <nl> } <nl> } <nl> else { <nl> Structure first = sarray [ 0 ] ; <nl> if ( first = = null ) { <nl> - first = Structure . newInstance ( cls , share ( offset ) ) ; <nl> + first = Structure . newInstance ( ( Class < Structure > ) cls , share ( offset ) ) ; <nl> first . conditionalAutoRead ( ) ; <nl> sarray [ 0 ] = first ; <nl> } <nl> @ @ - 940 , 7 + 940 , 7 @ @ public class Pointer { <nl> } else { <nl> Structure first = sbuf [ 0 ] ; <nl> if ( first = = null ) { <nl> - first = Structure . newInstance ( cls , share ( offset ) ) ; <nl> + first = Structure . newInstance ( ( Class < Structure > ) cls , share ( offset ) ) ; <nl> sbuf [ 0 ] = first ; <nl> } else { <nl> first . useMemory ( this , ( int ) offset , true ) ; <nl> diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java <nl> index 5e4b7f7 . . 13f3c14 100644 <nl> - - - a / src / com / sun / jna / Structure . java <nl> + + + b / src / com / sun / jna / Structure . java <nl> @ @ - 662 , 7 + 662 , 7 @ @ public abstract class Structure { <nl> * @ param address the native < code > struct * < / code > <nl> * @ return Updated < code > Structure . ByReference < / code > object <nl> * / <nl> - static Structure updateStructureByReference ( Class < ? > type , Structure s , Pointer address ) { <nl> + static < T extends Structure > T updateStructureByReference ( Class < T > type , T s , Pointer address ) { <nl> if ( address = = null ) { <nl> s = null ; <nl> } <nl> @ @ - 670 , 7 + 670 , 7 @ @ public abstract class Structure { <nl> if ( s = = null | | ! address . equals ( s . getPointer ( ) ) ) { <nl> Structure s1 = reading ( ) . get ( address ) ; <nl> if ( s1 ! = null & & type . equals ( s1 . getClass ( ) ) ) { <nl> - s = s1 ; <nl> + s = ( T ) s1 ; <nl> s . autoRead ( ) ; <nl> } <nl> else { <nl> @ @ - 1042 , 7 + 1042 , 7 @ @ public abstract class Structure { <nl> * @ param type Structure subclass to check <nl> * @ return native size of the given Structure subclass <nl> * / <nl> - static int size ( Class < ? > type ) { <nl> + static int size ( Class < ? extends Structure > type ) { <nl> return size ( type , null ) ; <nl> } <nl> <nl> @ @ - 1051 , 7 + 1051 , 7 @ @ public abstract class Structure { <nl> * @ param value optional instance of the given class <nl> * @ return native size of the Structure subclass <nl> * / <nl> - static int size ( Class < ? > type , Structure value ) { <nl> + static < T extends Structure > int size ( Class < T > type , T value ) { <nl> LayoutInfo info ; <nl> synchronized ( layoutInfo ) { <nl> info = layoutInfo . get ( type ) ; <nl> @ @ - 1329 , 7 + 1329 , 7 @ @ public abstract class Structure { <nl> if ( Structure . class . isAssignableFrom ( type ) <nl> & & ! ( ByReference . class . isAssignableFrom ( type ) ) ) { <nl> try { <nl> - value = newInstance ( type , PLACEHOLDER _ MEMORY ) ; <nl> + value = newInstance ( ( Class < ? extends Structure > ) type , PLACEHOLDER _ MEMORY ) ; <nl> setFieldValue ( field , value ) ; <nl> } <nl> catch ( IllegalArgumentException e ) { <nl> @ @ - 1408 , 7 + 1408 , 7 @ @ public abstract class Structure { <nl> } <nl> else { <nl> if ( value = = null ) <nl> - value = newInstance ( type , PLACEHOLDER _ MEMORY ) ; <nl> + value = newInstance ( ( Class < ? extends Structure > ) type , PLACEHOLDER _ MEMORY ) ; <nl> alignment = ( ( Structure ) value ) . getStructAlignment ( ) ; <nl> } <nl> } <nl> @ @ - 1744 , 9 + 1744 , 9 @ @ public abstract class Structure { <nl> * # newInstance ( Class , Pointer ) } , except that it additionally calls <nl> * { @ link # conditionalAutoRead ( ) } . <nl> * / <nl> - private static Structure newInstance ( Class < ? > type , long init ) { <nl> + private static < T extends Structure > T newInstance ( Class < T > type , long init ) { <nl> try { <nl> - Structure s = newInstance ( type , init = = 0 ? PLACEHOLDER _ MEMORY : new Pointer ( init ) ) ; <nl> + T s = newInstance ( type , init = = 0 ? PLACEHOLDER _ MEMORY : new Pointer ( init ) ) ; <nl> if ( init ! = 0 ) { <nl> s . conditionalAutoRead ( ) ; <nl> } <nl> @ @ - 1765 , 10 + 1765 , 10 @ @ public abstract class Structure { <nl> * @ return the new instance <nl> * @ throws IllegalArgumentException if the instantiation fails <nl> * / <nl> - public static Structure newInstance ( Class < ? > type , Pointer init ) throws IllegalArgumentException { <nl> + public static < T extends Structure > T newInstance ( Class < T > type , Pointer init ) throws IllegalArgumentException { <nl> try { <nl> - Constructor < ? > ctor = type . getConstructor ( Pointer . class ) ; <nl> - return ( Structure ) ctor . newInstance ( init ) ; <nl> + Constructor < T > ctor = type . getConstructor ( Pointer . class ) ; <nl> + return ctor . newInstance ( init ) ; <nl> } <nl> catch ( NoSuchMethodException e ) { <nl> / / Not defined , fall back to the default <nl> @ @ - 1789 , 7 + 1789 , 7 @ @ public abstract class Structure { <nl> e . printStackTrace ( ) ; <nl> throw new IllegalArgumentException ( msg , e ) ; <nl> } <nl> - Structure s = newInstance ( type ) ; <nl> + T s = newInstance ( type ) ; <nl> if ( init ! = PLACEHOLDER _ MEMORY ) { <nl> s . useMemory ( init ) ; <nl> } <nl> @ @ - 1801 , 9 + 1801 , 9 @ @ public abstract class Structure { <nl> * @ return the new instance <nl> * @ throws IllegalArgumentException if the instantiation fails <nl> * / <nl> - public static Structure newInstance ( Class < ? > type ) throws IllegalArgumentException { <nl> + public static < T extends Structure > T newInstance ( Class < T > type ) throws IllegalArgumentException { <nl> try { <nl> - Structure s = ( Structure ) type . newInstance ( ) ; <nl> + T s = type . newInstance ( ) ; <nl> if ( s instanceof ByValue ) { <nl> s . allocateMemory ( ) ; <nl> } <nl> @ @ - 1993 , 7 + 1993 , 7 @ @ public abstract class Structure { <nl> return FFITypes . ffi _ type _ pointer ; <nl> } <nl> if ( Structure . class . isAssignableFrom ( cls ) ) { <nl> - if ( obj = = null ) obj = newInstance ( cls , PLACEHOLDER _ MEMORY ) ; <nl> + if ( obj = = null ) obj = newInstance ( ( Class < ? extends Structure > ) cls , PLACEHOLDER _ MEMORY ) ; <nl> if ( ByReference . class . isAssignableFrom ( cls ) ) { <nl> typeInfoMap . put ( cls , FFITypes . ffi _ type _ pointer ) ; <nl> return FFITypes . ffi _ type _ pointer ; <nl> @ @ - 2124 , 7 + 2124 , 7 @ @ public abstract class Structure { <nl> / * * Indicate whether the given Structure class can be created by JNA . <nl> * @ param cls Structure subclass to check <nl> * / <nl> - static void validate ( Class < ? > cls ) { <nl> + static void validate ( Class < ? extends Structure > cls ) { <nl> Structure . newInstance ( cls , PLACEHOLDER _ MEMORY ) ; <nl> } <nl> } <nl> diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java <nl> index 21f80f6 . . 1752672 100644 <nl> - - - a / test / com / sun / jna / StructureTest . java <nl> + + + b / test / com / sun / jna / StructureTest . java <nl> @ @ - 281 , 7 + 281 , 7 @ @ public class StructureTest extends TestCase { <nl> private void testStructureSize ( int index ) { <nl> try { <nl> SizeTest lib = Native . loadLibrary ( " testlib " , SizeTest . class ) ; <nl> - Class < ? > cls = Class . forName ( getClass ( ) . getName ( ) + " $ TestStructure " + index ) ; <nl> + Class < ? extends Structure > cls = ( Class < ? extends Structure > ) Class . forName ( getClass ( ) . getName ( ) + " $ TestStructure " + index ) ; <nl> Structure s = Structure . newInstance ( cls ) ; <nl> assertEquals ( " Incorrect size for structure " + index + " = > " + s . toString ( true ) , lib . getStructureSize ( index ) , s . size ( ) ) ; <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index a8d0f98 . . 7be5836 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 7 , 6 + 7 , 8 @ @ Release 5 . 0 . 0 ( Next release ) 
 
 Features 
 - - - - - - - - 
 + * [ # 822 ] ( https : / / github . com / java - native - access / jna / issues / 822 ) : ` Native # loadLibrary ` requires that the interface class passed in is an instance of Library . The runtime check can be enhanced by using a constraint generic . This breaks binary compatibility ( see notes below ) - [ @ d - noll ] ( https : / / github . com / d - noll ) . 
 + * [ # 889 ] ( https : / / github . com / java - native - access / jna / issues / 889 ) : The ` Structure # newInstance ` receive the target type as a parameter . This adds a limited generic type , so that the return type ist the target type and not a generic structure , removing the necessity to do an explizit cast - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Winevt . java b / contrib / platform / src / com / sun / jna / platform / win32 / Winevt . java 
 index 9ce7d5c . . 71a46e0 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Winevt . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Winevt . java 
 @ @ - 488 , 7 + 488 , 7 @ @ public interface Winevt { 
 return isArray ( ) ? field1 . getPointer ( ) . getPointer ( 0 ) . getWideStringArray ( 0 , Count ) : field1 . getPointer ( ) . getPointer ( 0 ) . getWideString ( 0 ) ; 
 case EvtVarTypeFileTime : 
 if ( isArray ( ) ) { 
 - WinBase . FILETIME resultFirst = ( WinBase . FILETIME ) Structure . newInstance ( WinBase . FILETIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 + WinBase . FILETIME resultFirst = Structure . newInstance ( WinBase . FILETIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 resultFirst . read ( ) ; 
 return resultFirst . toArray ( Count ) ; 
 } else { 
 @ @ - 498 , 11 + 498 , 11 @ @ public interface Winevt { 
 } 
 case EvtVarTypeSysTime : 
 if ( isArray ( ) ) { 
 - WinBase . SYSTEMTIME resultFirst = ( WinBase . SYSTEMTIME ) Structure . newInstance ( WinBase . SYSTEMTIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 + WinBase . SYSTEMTIME resultFirst = Structure . newInstance ( WinBase . SYSTEMTIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 resultFirst . read ( ) ; 
 return resultFirst . toArray ( Count ) ; 
 } else { 
 - WinBase . SYSTEMTIME result = ( WinBase . SYSTEMTIME ) Structure . newInstance ( WinBase . SYSTEMTIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 + WinBase . SYSTEMTIME result = Structure . newInstance ( WinBase . SYSTEMTIME . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 result . read ( ) ; 
 return result ; 
 } 
 @ @ - 531 , 21 + 531 , 21 @ @ public interface Winevt { 
 return null ; 
 case EvtVarTypeGuid : 
 if ( isArray ( ) ) { 
 - Guid . GUID resultFirst = ( Guid . GUID ) Structure . newInstance ( Guid . GUID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 + Guid . GUID resultFirst = Structure . newInstance ( Guid . GUID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 resultFirst . read ( ) ; 
 return resultFirst . toArray ( Count ) ; 
 } else { 
 - Guid . GUID result = ( Guid . GUID ) Structure . newInstance ( Guid . GUID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 + Guid . GUID result = Structure . newInstance ( Guid . GUID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 result . read ( ) ; 
 return result ; 
 } 
 case EvtVarTypeSid : 
 if ( isArray ( ) ) { 
 - WinNT . PSID resultFirst = ( WinNT . PSID ) Structure . newInstance ( WinNT . PSID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 + WinNT . PSID resultFirst = Structure . newInstance ( WinNT . PSID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 resultFirst . read ( ) ; 
 return resultFirst . toArray ( Count ) ; 
 } else { 
 - WinNT . PSID result = ( WinNT . PSID ) Structure . newInstance ( WinNT . PSID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 + WinNT . PSID result = Structure . newInstance ( WinNT . PSID . class , field1 . getPointer ( ) . getPointer ( 0 ) ) ; 
 result . read ( ) ; 
 return result ; 
 } 
 diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java 
 index 5c9d62c . . 8fcb347 100644 
 - - - a / src / com / sun / jna / CallbackReference . java 
 + + + b / src / com / sun / jna / CallbackReference . java 
 @ @ - 272 , 7 + 272 , 7 @ @ public class CallbackReference extends WeakReference < Callback > { 
 private Class < ? > getNativeType ( Class < ? > cls ) { 
 if ( Structure . class . isAssignableFrom ( cls ) ) { 
 / / Make sure we can instantiate an argument of this type 
 - Structure . validate ( cls ) ; 
 + Structure . validate ( ( Class < ? extends Structure > ) cls ) ; 
 if ( ! Structure . ByValue . class . isAssignableFrom ( cls ) ) 
 return Pointer . class ; 
 } else if ( NativeMapped . class . isAssignableFrom ( cls ) ) { 
 @ @ - 580 , 14 + 580 , 14 @ @ public class CallbackReference extends WeakReference < Callback > { 
 / / If passed by value , don ' t hold onto the pointer , which 
 / / is only valid for the duration of the callback call 
 if ( Structure . ByValue . class . isAssignableFrom ( dstType ) ) { 
 - Structure s = Structure . newInstance ( dstType ) ; 
 + Structure s = Structure . newInstance ( ( Class < ? extends Structure > ) dstType ) ; 
 byte [ ] buf = new byte [ s . size ( ) ] ; 
 ( ( Pointer ) value ) . read ( 0 , buf , 0 , buf . length ) ; 
 s . getPointer ( ) . write ( 0 , buf , 0 , buf . length ) ; 
 s . read ( ) ; 
 value = s ; 
 } else { 
 - Structure s = Structure . newInstance ( dstType , ( Pointer ) value ) ; 
 + Structure s = Structure . newInstance ( ( Class < ? extends Structure > ) dstType , ( Pointer ) value ) ; 
 s . conditionalAutoRead ( ) ; 
 value = s ; 
 } 
 diff - - git a / src / com / sun / jna / Function . java b / src / com / sun / jna / Function . java 
 index 795901d . . 2d31827 100644 
 - - - a / src / com / sun / jna / Function . java 
 + + + b / src / com / sun / jna / Function . java 
 @ @ - 378 , 11 + 378 , 11 @ @ public class Function extends Pointer { 
 if ( args [ i ] instanceof PointerArray ) { 
 PointerArray array = ( PointerArray ) args [ i ] ; 
 if ( Structure . ByReference [ ] . class . isAssignableFrom ( inArg . getClass ( ) ) ) { 
 - Class < ? > type = inArg . getClass ( ) . getComponentType ( ) ; 
 + Class < ? extends Structure > type = ( Class < ? extends Structure > ) inArg . getClass ( ) . getComponentType ( ) ; 
 Structure [ ] ss = ( Structure [ ] ) inArg ; 
 for ( int si = 0 ; si < ss . length ; si + + ) { 
 Pointer p = array . getPointer ( Native . POINTER _ SIZE * si ) ; 
 - ss [ si ] = Structure . updateStructureByReference ( type , ss [ si ] , p ) ; 
 + ss [ si ] = Structure . updateStructureByReference ( ( Class < Structure > ) type , ss [ si ] , p ) ; 
 } 
 } 
 } 
 @ @ - 436 , 13 + 436 , 13 @ @ public class Function extends Pointer { 
 if ( Structure . ByValue . class . isAssignableFrom ( returnType ) ) { 
 Structure s = 
 Native . invokeStructure ( this , this . peer , callFlags , args , 
 - Structure . newInstance ( returnType ) ) ; 
 + Structure . newInstance ( ( Class < ? extends Structure > ) returnType ) ) ; 
 s . autoRead ( ) ; 
 result = s ; 
 } else { 
 result = invokePointer ( callFlags , args ) ; 
 if ( result ! = null ) { 
 - Structure s = Structure . newInstance ( returnType , ( Pointer ) result ) ; 
 + Structure s = Structure . newInstance ( ( Class < ? extends Structure > ) returnType , ( Pointer ) result ) ; 
 s . conditionalAutoRead ( ) ; 
 result = s ; 
 } 
 @ @ - 604 , 7 + 604 , 7 @ @ public class Function extends Pointer { 
 } else if ( ss . length = = 0 ) { 
 throw new IllegalArgumentException ( " Structure array must have non - zero length " ) ; 
 } else if ( ss [ 0 ] = = null ) { 
 - Structure . newInstance ( type ) . toArray ( ss ) ; 
 + Structure . newInstance ( ( Class < ? extends Structure > ) type ) . toArray ( ss ) ; 
 return ss [ 0 ] . getPointer ( ) ; 
 } else { 
 Structure . autoWrite ( ss ) ; 
 diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java 
 index 33e8e56 . . ae80566 100644 
 - - - a / src / com / sun / jna / Native . java 
 + + + b / src / com / sun / jna / Native . java 
 @ @ - 1241 , 7 + 1241 , 7 @ @ public final class Native implements Version { 
 } 
 if ( Structure . class . isAssignableFrom ( type ) 
 & & ! Structure . ByReference . class . isAssignableFrom ( type ) ) { 
 - return Structure . size ( type , ( Structure ) value ) ; 
 + return Structure . size ( ( Class < Structure > ) type , ( Structure ) value ) ; 
 } 
 try { 
 return getNativeSize ( type ) ; 
 @ @ - 1276 , 7 + 1276 , 7 @ @ public final class Native implements Version { 
 if ( cls = = double . class | | cls = = Double . class ) return 8 ; 
 if ( Structure . class . isAssignableFrom ( cls ) ) { 
 if ( Structure . ByValue . class . isAssignableFrom ( cls ) ) { 
 - return Structure . size ( cls ) ; 
 + return Structure . size ( ( Class < ? extends Structure > ) cls ) ; 
 } 
 return POINTER _ SIZE ; 
 } 
 diff - - git a / src / com / sun / jna / Pointer . java b / src / com / sun / jna / Pointer . java 
 index 16ad03f . . c111f9a 100644 
 - - - a / src / com / sun / jna / Pointer . java 
 + + + b / src / com / sun / jna / Pointer . java 
 @ @ - 363 , 7 + 363 , 7 @ @ public class Pointer { 
 if ( Structure . class . isAssignableFrom ( type ) ) { 
 Structure s = ( Structure ) currentValue ; 
 if ( Structure . ByReference . class . isAssignableFrom ( type ) ) { 
 - s = Structure . updateStructureByReference ( type , s , getPointer ( offset ) ) ; 
 + s = Structure . updateStructureByReference ( ( Class < Structure > ) type , s , getPointer ( offset ) ) ; 
 } else { 
 s . useMemory ( this , ( int ) offset , true ) ; 
 s . read ( ) ; 
 @ @ - 488 , 13 + 488 , 13 @ @ public class Pointer { 
 if ( Structure . ByReference . class . isAssignableFrom ( cls ) ) { 
 Pointer [ ] parray = getPointerArray ( offset , sarray . length ) ; 
 for ( int i = 0 ; i < sarray . length ; i + + ) { 
 - sarray [ i ] = Structure . updateStructureByReference ( cls , sarray [ i ] , parray [ i ] ) ; 
 + sarray [ i ] = Structure . updateStructureByReference ( ( Class < Structure > ) cls , sarray [ i ] , parray [ i ] ) ; 
 } 
 } 
 else { 
 Structure first = sarray [ 0 ] ; 
 if ( first = = null ) { 
 - first = Structure . newInstance ( cls , share ( offset ) ) ; 
 + first = Structure . newInstance ( ( Class < Structure > ) cls , share ( offset ) ) ; 
 first . conditionalAutoRead ( ) ; 
 sarray [ 0 ] = first ; 
 } 
 @ @ - 940 , 7 + 940 , 7 @ @ public class Pointer { 
 } else { 
 Structure first = sbuf [ 0 ] ; 
 if ( first = = null ) { 
 - first = Structure . newInstance ( cls , share ( offset ) ) ; 
 + first = Structure . newInstance ( ( Class < Structure > ) cls , share ( offset ) ) ; 
 sbuf [ 0 ] = first ; 
 } else { 
 first . useMemory ( this , ( int ) offset , true ) ; 
 diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java 
 index 5e4b7f7 . . 13f3c14 100644 
 - - - a / src / com / sun / jna / Structure . java 
 + + + b / src / com / sun / jna / Structure . java 
 @ @ - 662 , 7 + 662 , 7 @ @ public abstract class Structure { 
 * @ param address the native < code > struct * < / code > 
 * @ return Updated < code > Structure . ByReference < / code > object 
 * / 
 - static Structure updateStructureByReference ( Class < ? > type , Structure s , Pointer address ) { 
 + static < T extends Structure > T updateStructureByReference ( Class < T > type , T s , Pointer address ) { 
 if ( address = = null ) { 
 s = null ; 
 } 
 @ @ - 670 , 7 + 670 , 7 @ @ public abstract class Structure { 
 if ( s = = null | | ! address . equals ( s . getPointer ( ) ) ) { 
 Structure s1 = reading ( ) . get ( address ) ; 
 if ( s1 ! = null & & type . equals ( s1 . getClass ( ) ) ) { 
 - s = s1 ; 
 + s = ( T ) s1 ; 
 s . autoRead ( ) ; 
 } 
 else { 
 @ @ - 1042 , 7 + 1042 , 7 @ @ public abstract class Structure { 
 * @ param type Structure subclass to check 
 * @ return native size of the given Structure subclass 
 * / 
 - static int size ( Class < ? > type ) { 
 + static int size ( Class < ? extends Structure > type ) { 
 return size ( type , null ) ; 
 } 
 
 @ @ - 1051 , 7 + 1051 , 7 @ @ public abstract class Structure { 
 * @ param value optional instance of the given class 
 * @ return native size of the Structure subclass 
 * / 
 - static int size ( Class < ? > type , Structure value ) { 
 + static < T extends Structure > int size ( Class < T > type , T value ) { 
 LayoutInfo info ; 
 synchronized ( layoutInfo ) { 
 info = layoutInfo . get ( type ) ; 
 @ @ - 1329 , 7 + 1329 , 7 @ @ public abstract class Structure { 
 if ( Structure . class . isAssignableFrom ( type ) 
 & & ! ( ByReference . class . isAssignableFrom ( type ) ) ) { 
 try { 
 - value = newInstance ( type , PLACEHOLDER _ MEMORY ) ; 
 + value = newInstance ( ( Class < ? extends Structure > ) type , PLACEHOLDER _ MEMORY ) ; 
 setFieldValue ( field , value ) ; 
 } 
 catch ( IllegalArgumentException e ) { 
 @ @ - 1408 , 7 + 1408 , 7 @ @ public abstract class Structure { 
 } 
 else { 
 if ( value = = null ) 
 - value = newInstance ( type , PLACEHOLDER _ MEMORY ) ; 
 + value = newInstance ( ( Class < ? extends Structure > ) type , PLACEHOLDER _ MEMORY ) ; 
 alignment = ( ( Structure ) value ) . getStructAlignment ( ) ; 
 } 
 } 
 @ @ - 1744 , 9 + 1744 , 9 @ @ public abstract class Structure { 
 * # newInstance ( Class , Pointer ) } , except that it additionally calls 
 * { @ link # conditionalAutoRead ( ) } . 
 * / 
 - private static Structure newInstance ( Class < ? > type , long init ) { 
 + private static < T extends Structure > T newInstance ( Class < T > type , long init ) { 
 try { 
 - Structure s = newInstance ( type , init = = 0 ? PLACEHOLDER _ MEMORY : new Pointer ( init ) ) ; 
 + T s = newInstance ( type , init = = 0 ? PLACEHOLDER _ MEMORY : new Pointer ( init ) ) ; 
 if ( init ! = 0 ) { 
 s . conditionalAutoRead ( ) ; 
 } 
 @ @ - 1765 , 10 + 1765 , 10 @ @ public abstract class Structure { 
 * @ return the new instance 
 * @ throws IllegalArgumentException if the instantiation fails 
 * / 
 - public static Structure newInstance ( Class < ? > type , Pointer init ) throws IllegalArgumentException { 
 + public static < T extends Structure > T newInstance ( Class < T > type , Pointer init ) throws IllegalArgumentException { 
 try { 
 - Constructor < ? > ctor = type . getConstructor ( Pointer . class ) ; 
 - return ( Structure ) ctor . newInstance ( init ) ; 
 + Constructor < T > ctor = type . getConstructor ( Pointer . class ) ; 
 + return ctor . newInstance ( init ) ; 
 } 
 catch ( NoSuchMethodException e ) { 
 / / Not defined , fall back to the default 
 @ @ - 1789 , 7 + 1789 , 7 @ @ public abstract class Structure { 
 e . printStackTrace ( ) ; 
 throw new IllegalArgumentException ( msg , e ) ; 
 } 
 - Structure s = newInstance ( type ) ; 
 + T s = newInstance ( type ) ; 
 if ( init ! = PLACEHOLDER _ MEMORY ) { 
 s . useMemory ( init ) ; 
 } 
 @ @ - 1801 , 9 + 1801 , 9 @ @ public abstract class Structure { 
 * @ return the new instance 
 * @ throws IllegalArgumentException if the instantiation fails 
 * / 
 - public static Structure newInstance ( Class < ? > type ) throws IllegalArgumentException { 
 + public static < T extends Structure > T newInstance ( Class < T > type ) throws IllegalArgumentException { 
 try { 
 - Structure s = ( Structure ) type . newInstance ( ) ; 
 + T s = type . newInstance ( ) ; 
 if ( s instanceof ByValue ) { 
 s . allocateMemory ( ) ; 
 } 
 @ @ - 1993 , 7 + 1993 , 7 @ @ public abstract class Structure { 
 return FFITypes . ffi _ type _ pointer ; 
 } 
 if ( Structure . class . isAssignableFrom ( cls ) ) { 
 - if ( obj = = null ) obj = newInstance ( cls , PLACEHOLDER _ MEMORY ) ; 
 + if ( obj = = null ) obj = newInstance ( ( Class < ? extends Structure > ) cls , PLACEHOLDER _ MEMORY ) ; 
 if ( ByReference . class . isAssignableFrom ( cls ) ) { 
 typeInfoMap . put ( cls , FFITypes . ffi _ type _ pointer ) ; 
 return FFITypes . ffi _ type _ pointer ; 
 @ @ - 2124 , 7 + 2124 , 7 @ @ public abstract class Structure { 
 / * * Indicate whether the given Structure class can be created by JNA . 
 * @ param cls Structure subclass to check 
 * / 
 - static void validate ( Class < ? > cls ) { 
 + static void validate ( Class < ? extends Structure > cls ) { 
 Structure . newInstance ( cls , PLACEHOLDER _ MEMORY ) ; 
 } 
 } 
 diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java 
 index 21f80f6 . . 1752672 100644 
 - - - a / test / com / sun / jna / StructureTest . java 
 + + + b / test / com / sun / jna / StructureTest . java 
 @ @ - 281 , 7 + 281 , 7 @ @ public class StructureTest extends TestCase { 
 private void testStructureSize ( int index ) { 
 try { 
 SizeTest lib = Native . loadLibrary ( " testlib " , SizeTest . class ) ; 
 - Class < ? > cls = Class . forName ( getClass ( ) . getName ( ) + " $ TestStructure " + index ) ; 
 + Class < ? extends Structure > cls = ( Class < ? extends Structure > ) Class . forName ( getClass ( ) . getName ( ) + " $ TestStructure " + index ) ; 
 Structure s = Structure . newInstance ( cls ) ; 
 assertEquals ( " Incorrect size for structure " + index + " = > " + s . toString ( true ) , lib . getStructureSize ( index ) , s . size ( ) ) ; 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
