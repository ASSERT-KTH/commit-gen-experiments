BLEU SCORE: 0.020980574531482755

TEST MSG: Implement binding for extended file attributes handling on Linux .
GENERATED MSG: fixed some changes asked by the jna team

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / linux / XAttr . java b / contrib / platform / src / com / sun / jna / platform / linux / XAttr . java <nl> new file mode 100644 <nl> index 0000000 . . 8d36dae <nl> - - - / dev / null <nl> + + + b / contrib / platform / src / com / sun / jna / platform / linux / XAttr . java <nl> @ @ - 0 , 0 + 1 , 86 @ @ <nl> + / * <nl> + * Copyright ( c ) 2018 V รก clav Haisman , All Rights Reserved <nl> + * <nl> + * The contents of this file is dual - licensed under 2 <nl> + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and <nl> + * Apache License 2 . 0 . <nl> + * <nl> + * You can freely decide which license you want to apply to <nl> + * the project . <nl> + * <nl> + * You may obtain a copy of the LGPL License at : <nl> + * <nl> + * http : / / www . gnu . org / licenses / licenses . html <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " LGPL2 . 1 " . <nl> + * <nl> + * You may obtain a copy of the Apache License at : <nl> + * <nl> + * http : / / www . apache . org / licenses / <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " AL2 . 0 " . <nl> + * / <nl> + package com . sun . jna . platform . linux ; <nl> + <nl> + import com . sun . jna . IntegerType ; <nl> + import com . sun . jna . Library ; <nl> + import com . sun . jna . Native ; <nl> + import com . sun . jna . Pointer ; <nl> + <nl> + public interface XAttr extends Library { <nl> + XAttr INSTANCE = Native . load ( XAttr . class ) ; <nl> + <nl> + class size _ t extends IntegerType { <nl> + public static final size _ t ZERO = new size _ t ( ) ; <nl> + <nl> + private static final long serialVersionUID = 1L ; <nl> + <nl> + public size _ t ( ) { this ( 0 ) ; } <nl> + public size _ t ( long value ) { super ( Native . SIZE _ T _ SIZE , value , true ) ; } <nl> + } <nl> + <nl> + class ssize _ t extends IntegerType { <nl> + public static final ssize _ t ZERO = new ssize _ t ( ) ; <nl> + <nl> + private static final long serialVersionUID = 1L ; <nl> + <nl> + public ssize _ t ( ) { <nl> + this ( 0 ) ; <nl> + } <nl> + <nl> + public ssize _ t ( long value ) { <nl> + super ( Native . SIZE _ T _ SIZE , value , false ) ; <nl> + } <nl> + } <nl> + <nl> + int XATTR _ CREATE = 1 ; <nl> + int XATTR _ REPLACE = 2 ; <nl> + <nl> + int EPERM = 1 ; <nl> + int E2BIG = 7 ; <nl> + int EEXIST = 17 ; <nl> + int ENOSPC = 28 ; <nl> + int ERANGE = 34 ; <nl> + int ENODATA = 61 ; <nl> + int ENOATTR = ENODATA ; <nl> + int ENOTSUP = 95 ; <nl> + int EDQUOT = 122 ; <nl> + <nl> + int setxattr ( String path , String name , Pointer value , size _ t size , int flags ) ; <nl> + int lsetxattr ( String path , String name , Pointer value , size _ t size , int flags ) ; <nl> + int fsetxattr ( int fd , String name , Pointer value , size _ t size , int flags ) ; <nl> + <nl> + ssize _ t getxattr ( String path , String name , Pointer value , size _ t size ) ; <nl> + ssize _ t lgetxattr ( String path , String name , Pointer value , size _ t size ) ; <nl> + ssize _ t fgetxattr ( int fd , String name , Pointer value , size _ t size ) ; <nl> + <nl> + ssize _ t listxattr ( String path , Pointer list , size _ t size ) ; <nl> + ssize _ t llistxattr ( String path , Pointer list , size _ t size ) ; <nl> + ssize _ t flistxattr ( int fd , Pointer list , size _ t size ) ; <nl> + <nl> + int removexattr ( String path , String name ) ; <nl> + int lremovexattr ( String path , String name ) ; <nl> + int fremovexattr ( int fd , String name ) ; <nl> + } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / linux / XAttrUtil . java b / contrib / platform / src / com / sun / jna / platform / linux / XAttrUtil . java <nl> new file mode 100644 <nl> index 0000000 . . b5154ad <nl> - - - / dev / null <nl> + + + b / contrib / platform / src / com / sun / jna / platform / linux / XAttrUtil . java <nl> @ @ - 0 , 0 + 1 , 626 @ @ <nl> + / * <nl> + * Copyright ( c ) 2018 V รก clav Haisman , All Rights Reserved <nl> + * <nl> + * The contents of this file is dual - licensed under 2 <nl> + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and <nl> + * Apache License 2 . 0 . <nl> + * <nl> + * You can freely decide which license you want to apply to <nl> + * the project . <nl> + * <nl> + * You may obtain a copy of the LGPL License at : <nl> + * <nl> + * http : / / www . gnu . org / licenses / licenses . html <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " LGPL2 . 1 " . <nl> + * <nl> + * You may obtain a copy of the Apache License at : <nl> + * <nl> + * http : / / www . apache . org / licenses / <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " AL2 . 0 " . <nl> + * / <nl> + package com . sun . jna . platform . linux ; <nl> + <nl> + import com . sun . jna . Memory ; <nl> + import com . sun . jna . Native ; <nl> + import com . sun . jna . platform . linux . XAttr . size _ t ; <nl> + import com . sun . jna . platform . linux . XAttr . ssize _ t ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . nio . charset . Charset ; <nl> + import java . util . Collection ; <nl> + import java . util . LinkedHashSet ; <nl> + import java . util . Set ; <nl> + <nl> + / * * <nl> + * Utility functions class for handling file extended attributes on Linux . <nl> + * / <nl> + public abstract class XAttrUtil { <nl> + <nl> + private XAttrUtil ( ) { <nl> + } <nl> + <nl> + / * * <nl> + * Set or replace value of extended attribute . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ param value value to set <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void setXAttr ( String path , String name , String value ) throws IOException { <nl> + setXAttr ( path , name , value , Native . getDefaultStringEncoding ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Set or replace value of extended attribute . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ param value value to set <nl> + * @ param encoding character encoding to be used for stored value <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void setXAttr ( String path , String name , String value , String encoding ) <nl> + throws IOException { <nl> + setXAttr ( path , name , value . getBytes ( encoding ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Set or replace value of extended attribute . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ param value value to set <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void setXAttr ( String path , String name , byte [ ] value ) throws IOException { <nl> + Memory valueMem = bytesToMemory ( value ) ; <nl> + int retval = XAttr . INSTANCE . setxattr ( path , name , valueMem , new size _ t ( valueMem . size ( ) ) , 0 ) ; <nl> + if ( retval ! = 0 ) { <nl> + final int eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Set or replace value of extended attribute but in case of symbolic link set the extended <nl> + * attribute on the link itself instead linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ param value value to set <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void lSetXAttr ( String path , String name , String value ) throws IOException { <nl> + lSetXAttr ( path , name , value , Native . getDefaultStringEncoding ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Set or replace value of extended attribute but in case of symbolic link set the extended <nl> + * attribute on the link itself instead linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ param value value to set <nl> + * @ param encoding character encoding to be used for stored value <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void lSetXAttr ( String path , String name , String value , String encoding ) <nl> + throws IOException { <nl> + lSetXAttr ( path , name , value . getBytes ( encoding ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Set or replace value of extended attribute but in case of symbolic link set the extended <nl> + * attribute on the link itself instead linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ param value value to set <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void lSetXAttr ( String path , String name , byte [ ] value ) throws IOException { <nl> + Memory valueMem = bytesToMemory ( value ) ; <nl> + final int retval = XAttr . INSTANCE . lsetxattr ( path , name , valueMem , <nl> + new size _ t ( valueMem . size ( ) ) , 0 ) ; <nl> + if ( retval ! = 0 ) { <nl> + final int eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Set or replace value of extended attribute . <nl> + * <nl> + * @ param fd file handle <nl> + * @ param name extended attribute name <nl> + * @ param value value to set <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void fSetXAttr ( int fd , String name , String value ) throws IOException { <nl> + fSetXAttr ( fd , name , value , Native . getDefaultStringEncoding ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Set or replace value of extended attribute . <nl> + * <nl> + * @ param fd file handle <nl> + * @ param name extended attribute name <nl> + * @ param value value to set <nl> + * @ param encoding character encoding to be used for stored value <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void fSetXAttr ( int fd , String name , String value , String encoding ) <nl> + throws IOException { <nl> + fSetXAttr ( fd , name , value . getBytes ( encoding ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Set or replace value of extended attribute . <nl> + * <nl> + * @ param fd file handle <nl> + * @ param name extended attribute name <nl> + * @ param value value to set <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void fSetXAttr ( int fd , String name , byte [ ] value ) throws IOException { <nl> + Memory valueMem = bytesToMemory ( value ) ; <nl> + final int retval = XAttr . INSTANCE . fsetxattr ( fd , name , valueMem , new size _ t ( valueMem . size ( ) ) , <nl> + 0 ) ; <nl> + if ( retval ! = 0 ) { <nl> + final int eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Get extended attribute value . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static String getXAttr ( String path , String name ) throws IOException { <nl> + return getXAttr ( path , name , Native . getDefaultStringEncoding ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get extended attribute value . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ param encoding character encoding to be used to decode stored extended attribute value <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static String getXAttr ( String path , String name , String encoding ) throws IOException { <nl> + Memory valueMem = getXAttrAsMemory ( path , name ) ; <nl> + return Charset . forName ( encoding ) <nl> + . decode ( valueMem . getByteBuffer ( 0 , valueMem . size ( ) ) ) <nl> + . toString ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get extended attribute value . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static byte [ ] getXAttrBytes ( String path , String name ) throws IOException { <nl> + Memory valueMem = getXAttrAsMemory ( path , name ) ; <nl> + return valueMem . getByteArray ( 0 , ( int ) valueMem . size ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get extended attribute value . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static Memory getXAttrAsMemory ( String path , String name ) throws IOException { <nl> + ssize _ t retval ; <nl> + Memory valueMem ; <nl> + int eno = 0 ; <nl> + <nl> + do { <nl> + retval = XAttr . INSTANCE . getxattr ( path , name , null , size _ t . ZERO ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + <nl> + valueMem = new Memory ( retval . longValue ( ) ) ; <nl> + retval = XAttr . INSTANCE . getxattr ( path , name , valueMem , new size _ t ( valueMem . size ( ) ) ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + if ( eno ! = XAttr . ERANGE ) { <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; <nl> + <nl> + return valueMem ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Get extended attribute value but in case of symbolic link get the value from the link <nl> + * itself instead of linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static String lGetXAttr ( String path , String name ) throws IOException { <nl> + return lGetXAttr ( path , name , Native . getDefaultStringEncoding ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get extended attribute value but in case of symbolic link get the value from the link <nl> + * itself instead of linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ param encoding character encoding to be used to decode stored extended attribute value <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static String lGetXAttr ( String path , String name , String encoding ) throws IOException { <nl> + Memory valueMem = lGetXAttrAsMemory ( path , name ) ; <nl> + return Charset . forName ( encoding ) <nl> + . decode ( valueMem . getByteBuffer ( 0 , valueMem . size ( ) ) ) <nl> + . toString ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get extended attribute value but in case of symbolic link get the value from the link <nl> + * itself instead of linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static byte [ ] lGetXAttrBytes ( String path , String name ) throws IOException { <nl> + Memory valueMem = lGetXAttrAsMemory ( path , name ) ; <nl> + return valueMem . getByteArray ( 0 , ( int ) valueMem . size ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get extended attribute value but in case of symbolic link get the value from the link <nl> + * itself instead of linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static Memory lGetXAttrAsMemory ( String path , String name ) throws IOException { <nl> + ssize _ t retval ; <nl> + Memory valueMem ; <nl> + int eno = 0 ; <nl> + <nl> + do { <nl> + retval = XAttr . INSTANCE . lgetxattr ( path , name , null , size _ t . ZERO ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + <nl> + valueMem = new Memory ( retval . longValue ( ) ) ; <nl> + retval = XAttr . INSTANCE . lgetxattr ( path , name , valueMem , new size _ t ( valueMem . size ( ) ) ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + if ( eno ! = XAttr . ERANGE ) { <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; <nl> + <nl> + return valueMem ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Get extended attribute value . <nl> + * <nl> + * @ param fd file handle <nl> + * @ param name extended attribute name <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static String fGetXAttr ( int fd , String name ) throws IOException { <nl> + return fGetXAttr ( fd , name , Native . getDefaultStringEncoding ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get extended attribute value . <nl> + * <nl> + * @ param fd file handle <nl> + * @ param name extended attribute name <nl> + * @ param encoding character encoding to be used to decode stored extended attribute value <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static String fGetXAttr ( int fd , String name , String encoding ) throws IOException { <nl> + Memory valueMem = fGetXAttrAsMemory ( fd , name ) ; <nl> + return Charset . forName ( encoding ) <nl> + . decode ( valueMem . getByteBuffer ( 0 , valueMem . size ( ) ) ) <nl> + . toString ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get extended attribute value . <nl> + * <nl> + * @ param fd file handle <nl> + * @ param name extended attribute name <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static byte [ ] fGetXAttrBytes ( int fd , String name ) throws IOException { <nl> + Memory valueMem = fGetXAttrAsMemory ( fd , name ) ; <nl> + return valueMem . getByteArray ( 0 , ( int ) valueMem . size ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get extended attribute value . <nl> + * <nl> + * @ param fd file handle <nl> + * @ param name extended attribute name <nl> + * @ return extended attribute value <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static Memory fGetXAttrAsMemory ( int fd , String name ) throws IOException { <nl> + ssize _ t retval ; <nl> + Memory valueMem ; <nl> + int eno = 0 ; <nl> + <nl> + do { <nl> + retval = XAttr . INSTANCE . fgetxattr ( fd , name , null , size _ t . ZERO ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + <nl> + valueMem = new Memory ( retval . longValue ( ) ) ; <nl> + retval = XAttr . INSTANCE . fgetxattr ( fd , name , valueMem , new size _ t ( valueMem . size ( ) ) ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + if ( eno ! = XAttr . ERANGE ) { <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; <nl> + <nl> + return valueMem ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * List extended attributes on file . <nl> + * <nl> + * @ param path file path <nl> + * @ return collection of extended attributes ' names <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static Collection < String > listXAttr ( String path ) throws IOException { <nl> + return listXAttr ( path , Native . getDefaultStringEncoding ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * List extended attributes on file . <nl> + * <nl> + * @ param path file path <nl> + * @ param encoding character encoding use to decode extended attributes ' names <nl> + * @ return collection of extended attributes ' names <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static Collection < String > listXAttr ( String path , String encoding ) throws IOException { <nl> + ssize _ t retval ; <nl> + Memory listMem ; <nl> + int eno = 0 ; <nl> + <nl> + do { <nl> + retval = XAttr . INSTANCE . listxattr ( path , null , size _ t . ZERO ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + <nl> + listMem = new Memory ( retval . longValue ( ) ) ; <nl> + retval = XAttr . INSTANCE . listxattr ( path , listMem , new size _ t ( listMem . size ( ) ) ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + if ( eno ! = XAttr . ERANGE ) { <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; <nl> + <nl> + return splitBufferToStrings ( listMem , encoding ) ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * List extended attributes on file but in case of symbolic link get extended attributes of <nl> + * the link itself instead of linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ return collection of extended attributes ' names <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static Collection < String > lListXAttr ( String path ) throws IOException { <nl> + return lListXAttr ( path , Native . getDefaultStringEncoding ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * List extended attributes on file but in case of symbolic link get extended attributes of <nl> + * the link itself instead of linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ param encoding character encoding use to decode extended attributes ' names <nl> + * @ return collection of extended attributes ' names <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static Collection < String > lListXAttr ( String path , String encoding ) throws IOException { <nl> + ssize _ t retval ; <nl> + Memory listMem ; <nl> + int eno = 0 ; <nl> + <nl> + do { <nl> + retval = XAttr . INSTANCE . llistxattr ( path , null , size _ t . ZERO ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + <nl> + listMem = new Memory ( retval . longValue ( ) ) ; <nl> + retval = XAttr . INSTANCE . llistxattr ( path , listMem , new size _ t ( listMem . size ( ) ) ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + if ( eno ! = XAttr . ERANGE ) { <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; <nl> + <nl> + return splitBufferToStrings ( listMem , encoding ) ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * List extended attributes on file . <nl> + * <nl> + * @ param fd file handle <nl> + * @ return collection of extended attributes ' names <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static Collection < String > fListXAttr ( int fd ) throws IOException { <nl> + return fListXAttr ( fd , Native . getDefaultStringEncoding ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * List extended attributes on file . <nl> + * <nl> + * @ param fd file handle <nl> + * @ param encoding character encoding use to decode extended attributes ' names <nl> + * @ return collection of extended attributes ' names <nl> + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally <nl> + * / <nl> + public static Collection < String > fListXAttr ( int fd , String encoding ) throws IOException { <nl> + ssize _ t retval ; <nl> + Memory listMem ; <nl> + int eno = 0 ; <nl> + <nl> + do { <nl> + retval = XAttr . INSTANCE . flistxattr ( fd , null , size _ t . ZERO ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + <nl> + listMem = new Memory ( retval . longValue ( ) ) ; <nl> + retval = XAttr . INSTANCE . flistxattr ( fd , listMem , new size _ t ( listMem . size ( ) ) ) ; <nl> + if ( retval . longValue ( ) < 0 ) { <nl> + eno = Native . getLastError ( ) ; <nl> + if ( eno ! = XAttr . ERANGE ) { <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; <nl> + <nl> + return splitBufferToStrings ( listMem , encoding ) ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Remove extended attribute from file . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void removeXAttr ( String path , String name ) throws IOException { <nl> + final int retval = XAttr . INSTANCE . removexattr ( path , name ) ; <nl> + if ( retval ! = 0 ) { <nl> + final int eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Remove extended attribute from file but in case of symbolic link remove extended attribute <nl> + * from the link itself instead of linked file . <nl> + * <nl> + * @ param path file path <nl> + * @ param name extended attribute name <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void lRemoveXAttr ( String path , String name ) throws IOException { <nl> + final int retval = XAttr . INSTANCE . lremovexattr ( path , name ) ; <nl> + if ( retval ! = 0 ) { <nl> + final int eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Remove extended attribute from file . <nl> + * <nl> + * @ param fd file handle <nl> + * @ param name extended attribute name <nl> + * @ throws IOException on any error <nl> + * / <nl> + public static void fRemoveXAttr ( int fd , String name ) throws IOException { <nl> + final int retval = XAttr . INSTANCE . fremovexattr ( fd , name ) ; <nl> + if ( retval ! = 0 ) { <nl> + final int eno = Native . getLastError ( ) ; <nl> + throw new IOException ( " errno : " + eno ) ; <nl> + } <nl> + } <nl> + <nl> + private static Memory bytesToMemory ( byte [ ] value ) { <nl> + Memory valueMem = new Memory ( value . length ) ; <nl> + valueMem . write ( 0 , value , 0 , value . length ) ; <nl> + return valueMem ; <nl> + } <nl> + <nl> + private static Collection < String > splitBufferToStrings ( Memory valueMem , String encoding ) <nl> + throws IOException { <nl> + final Charset charset = Charset . forName ( encoding ) ; <nl> + final Set < String > attributesList = new LinkedHashSet < String > ( 1 ) ; <nl> + long offset = 0 ; <nl> + while ( offset ! = valueMem . size ( ) ) { <nl> + / / Find terminating NUL character . <nl> + long nulOffset = valueMem . indexOf ( offset , ( byte ) 0 ) ; <nl> + if ( nulOffset = = - 1 ) { <nl> + throw new IOException ( " Expected NUL character not found . " ) ; <nl> + } <nl> + <nl> + / / Duplicate buffer with limit at end of name . <nl> + final ByteBuffer nameBuffer = valueMem . getByteBuffer ( offset , nulOffset ) ; <nl> + <nl> + / / Convert bytes of the name to String . <nl> + final String name = charset . decode ( nameBuffer ) . toString ( ) ; <nl> + attributesList . add ( name ) ; <nl> + <nl> + / / Move past NUL . <nl> + offset + = nulOffset + 1 ; <nl> + } <nl> + return attributesList ; <nl> + } <nl> + } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / linux / XAttrUtilTest . java b / contrib / platform / test / com / sun / jna / platform / linux / XAttrUtilTest . java <nl> new file mode 100644 <nl> index 0000000 . . c4a074b <nl> - - - / dev / null <nl> + + + b / contrib / platform / test / com / sun / jna / platform / linux / XAttrUtilTest . java <nl> @ @ - 0 , 0 + 1 , 70 @ @ <nl> + / * <nl> + * Copyright ( c ) 2018 V รก clav Haisman , All Rights Reserved <nl> + * <nl> + * The contents of this file is dual - licensed under 2 <nl> + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and <nl> + * Apache License 2 . 0 . <nl> + * <nl> + * You can freely decide which license you want to apply to <nl> + * the project . <nl> + * <nl> + * You may obtain a copy of the LGPL License at : <nl> + * <nl> + * http : / / www . gnu . org / licenses / licenses . html <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " LGPL2 . 1 " . <nl> + * <nl> + * You may obtain a copy of the Apache License at : <nl> + * <nl> + * http : / / www . apache . org / licenses / <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " AL2 . 0 " . <nl> + * / <nl> + package com . sun . jna . platform . linux ; <nl> + <nl> + import java . io . File ; <nl> + import java . io . IOException ; <nl> + import java . util . Collection ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + public class XAttrUtilTest { <nl> + private static final String TEST _ STRING = " ลฝ lu ลฅ ou ฤ k รฝ k ลฏ ล รบ p ฤ l nebo tak n ฤ co . " ; <nl> + private static final String TEST _ STRING _ 2 = " P ล รญ li ลก ลพ lu ลฅ ou ฤ k รฝ k ลฏ ล รบ p ฤ l ฤ รก belsk รฉ รณ dy . " ; <nl> + private static final String TEST _ ATTRIBUTE = " user . test " ; <nl> + private static final String TEST _ ATTRIBUTE _ FOO = TEST _ ATTRIBUTE + " . foo " ; <nl> + <nl> + @ Test <nl> + public void setXAttr ( ) throws IOException { <nl> + File file = File . createTempFile ( " xattr " , " test " ) ; <nl> + file . deleteOnExit ( ) ; <nl> + <nl> + XAttrUtil . setXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE , TEST _ STRING ) ; <nl> + XAttrUtil . setXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE _ FOO , TEST _ STRING _ 2 ) ; <nl> + <nl> + String retrievedValue = XAttrUtil . getXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE ) ; <nl> + assertEquals ( TEST _ STRING , retrievedValue ) ; <nl> + <nl> + retrievedValue = XAttrUtil . getXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE _ FOO ) ; <nl> + assertEquals ( TEST _ STRING _ 2 , retrievedValue ) ; <nl> + <nl> + XAttrUtil . setXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE , TEST _ STRING _ 2 ) ; <nl> + retrievedValue = XAttrUtil . lGetXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE ) ; <nl> + assertEquals ( TEST _ STRING _ 2 , retrievedValue ) ; <nl> + <nl> + Collection < String > xattrs = XAttrUtil . listXAttr ( file . getAbsolutePath ( ) ) ; <nl> + assertTrue ( xattrs . contains ( TEST _ ATTRIBUTE ) ) ; <nl> + assertTrue ( xattrs . contains ( TEST _ ATTRIBUTE _ FOO ) ) ; <nl> + <nl> + XAttrUtil . removeXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE ) ; <nl> + xattrs = XAttrUtil . lListXAttr ( file . getAbsolutePath ( ) ) ; <nl> + assertFalse ( xattrs . contains ( TEST _ ATTRIBUTE ) ) ; <nl> + assertTrue ( xattrs . contains ( TEST _ ATTRIBUTE _ FOO ) ) ; <nl> + } <nl> + } <nl> \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Guid . java b / contrib / platform / src / com / sun / jna / platform / win32 / Guid . java <nl> index 5f378fc . . 6c04a2f 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Guid . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Guid . java <nl> @ @ - 1 , 17 + 1 , 18 @ @ <nl> / * Copyright ( c ) 2010 Daniel Doubrovkine , All Rights Reserved <nl> - * <nl> + * <nl> * This library is free software ; you can redistribute it and / or <nl> * modify it under the terms of the GNU Lesser General Public <nl> * License as published by the Free Software Foundation ; either <nl> * version 2 . 1 of the License , or ( at your option ) any later version . <nl> - * <nl> + * <nl> * This library is distributed in the hope that it will be useful , <nl> * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> + * Lesser General Public License for more details . <nl> * / <nl> package com . sun . jna . platform . win32 ; <nl> <nl> + import java . security . SecureRandom ; <nl> import java . util . Arrays ; <nl> import java . util . List ; <nl> <nl> @ @ - 21 , 7 + 22 , 7 @ @ import com . sun . jna . Structure ; <nl> / / TODO : Auto - generated Javadoc <nl> / * * <nl> * Ported from Guid . h . Microsoft Windows SDK 6 . 0A . <nl> - * <nl> + * <nl> * @ author dblock [ at ] dblock . org <nl> * / <nl> public interface Guid { <nl> @ @ - 45 , 7 + 46 , 7 @ @ public interface Guid { <nl> <nl> 	 	 	 / * * <nl> 	 	 	 * Instantiates a new by reference . <nl> - 	 	 	 * <nl> + 	 	 	 * <nl> 	 	 	 * @ param guid <nl> 	 	 	 * the guid <nl> 	 	 	 * / <nl> @ @ - 60 , 7 + 61 , 7 @ @ public interface Guid { <nl> <nl> 	 	 	 / * * <nl> 	 	 	 * Instantiates a new by reference . <nl> - 	 	 	 * <nl> + 	 	 	 * <nl> 	 	 	 * @ param memory <nl> 	 	 	 * the memory <nl> 	 	 	 * / <nl> @ @ - 89 , 7 + 90 , 7 @ @ public interface Guid { <nl> <nl> 	 	 / * * <nl> 	 	 * Instantiates a new guid . <nl> - 	 	 * <nl> + 	 	 * <nl> 	 	 * @ param guid <nl> 	 	 * the guid <nl> 	 	 * / <nl> @ @ - 98 , 13 + 99 , 13 @ @ public interface Guid { <nl> 	 	 	 this . Data2 = guid . Data2 ; <nl> 	 	 	 this . Data3 = guid . Data3 ; <nl> 	 	 	 this . Data4 = guid . Data4 ; <nl> - 	 	 	 <nl> + <nl> 	 	 	 this . writeFieldsToMemory ( ) ; <nl> 	 	 } <nl> <nl> 	 	 / * * <nl> 	 	 * Instantiates a new guid . <nl> - 	 	 * <nl> + 	 	 * <nl> 	 	 * @ param guid <nl> 	 	 * the guid <nl> 	 	 * / <nl> @ @ - 114 , 7 + 115 , 7 @ @ public interface Guid { <nl> <nl> 	 	 / * * <nl> 	 	 * Instantiates a new guid . <nl> - 	 	 * <nl> + 	 	 * <nl> 	 	 * @ param data <nl> 	 	 * the data <nl> 	 	 * / <nl> @ @ - 124 , 7 + 125 , 7 @ @ public interface Guid { <nl> <nl> 	 	 / * * <nl> 	 	 * Instantiates a new guid . <nl> - 	 	 * <nl> + 	 	 * <nl> 	 	 * @ param memory <nl> 	 	 * the memory <nl> 	 	 * / <nl> @ @ - 135 , 7 + 136 , 7 @ @ public interface Guid { <nl> <nl> 	 	 / * * <nl> 	 	 * From binary . <nl> - 	 	 * <nl> + 	 	 * <nl> 	 	 * @ param data <nl> 	 	 * the data <nl> 	 	 * @ return the guid <nl> @ @ - 174 , 15 + 175 , 15 @ @ public interface Guid { <nl> 	 	 	 newGuid . Data4 [ 5 ] = data [ 13 ] ; <nl> 	 	 	 newGuid . Data4 [ 6 ] = data [ 14 ] ; <nl> 	 	 	 newGuid . Data4 [ 7 ] = data [ 15 ] ; <nl> - 	 	 	 <nl> + <nl> 	 	 	 newGuid . writeFieldsToMemory ( ) ; <nl> - 	 	 	 <nl> + <nl> 	 	 	 return newGuid ; <nl> 	 	 } <nl> <nl> 	 	 / * * <nl> 	 	 * From string . <nl> - 	 	 * <nl> + 	 	 * <nl> 	 	 * @ param guid <nl> 	 	 * the guid <nl> 	 	 * @ return the guid <nl> @ @ - 193 , 30 + 194 , 31 @ @ public interface Guid { <nl> 	 	 	 char [ ] _ cguid = guid . toCharArray ( ) ; <nl> 	 	 	 byte [ ] bdata = new byte [ 16 ] ; <nl> 	 	 	 GUID newGuid = new GUID ( ) ; <nl> - 	 	 	 <nl> + <nl> 	 	 	 / / we not accept a string longer than 38 chars <nl> 	 	 	 if ( guid . length ( ) > 38 ) { <nl> 	 	 	 	 throw new IllegalArgumentException ( " Invalid guid length : " <nl> 	 	 	 	 	 	 + guid . length ( ) ) ; <nl> 	 	 	 } <nl> - 	 	 	 <nl> + <nl> 	 	 	 / / remove ' { ' , ' } ' and ' - ' from guid string <nl> 	 	 	 for ( int i = 0 ; i < _ cguid . length ; i + + ) { <nl> - 	 	 	 	 if ( ( _ cguid [ i ] ! = ' { ' ) & & ( _ cguid [ i ] ! = ' - ' ) & & ( _ cguid [ i ] ! = ' } ' ) ) <nl> + 	 	 	 	 if ( ( _ cguid [ i ] ! = ' { ' ) & & ( _ cguid [ i ] ! = ' - ' ) <nl> + 	 	 	 	 	 	 & & ( _ cguid [ i ] ! = ' } ' ) ) <nl> 	 	 	 	 	 _ cnewguid [ y + + ] = _ cguid [ i ] ; <nl> 	 	 	 } <nl> - 	 	 	 <nl> + <nl> 	 	 	 / / convert char to byte <nl> 	 	 	 for ( int i = 0 ; i < 32 ; i + = 2 ) { <nl> - 	 	 	 	 bdata [ i / 2 ] = ( byte ) ( ( Character . digit ( _ cnewguid [ i ] , 16 ) < < 4 ) + Character <nl> - 	 	 	 	 	 	 . digit ( _ cnewguid [ i + 1 ] , 16 ) & 0xff ) ; <nl> + 	 	 	 	 bdata [ i / 2 ] = ( byte ) ( ( Character . digit ( _ cnewguid [ i ] , 16 ) < < 4 ) <nl> + 	 	 	 	 	 	 + Character . digit ( _ cnewguid [ i + 1 ] , 16 ) & 0xff ) ; <nl> 	 	 	 } <nl> - 	 	 	 <nl> + <nl> 	 	 	 if ( bdata . length ! = 16 ) { <nl> 	 	 	 	 throw new IllegalArgumentException ( " Invalid data length : " <nl> 	 	 	 	 	 	 + bdata . length ) ; <nl> 	 	 	 } <nl> - 	 	 	 <nl> + <nl> 	 	 	 long data1Temp = bdata [ 0 ] & 0xff ; <nl> 	 	 	 data1Temp < < = 8 ; <nl> 	 	 	 data1Temp | = bdata [ 1 ] & 0xff ; <nl> @ @ - 243 , 14 + 245 , 35 @ @ public interface Guid { <nl> 	 	 	 newGuid . Data4 [ 4 ] = bdata [ 12 ] ; <nl> 	 	 	 newGuid . Data4 [ 5 ] = bdata [ 13 ] ; <nl> 	 	 	 newGuid . Data4 [ 6 ] = bdata [ 14 ] ; <nl> - 	 	 	 newGuid . Data4 [ 7 ] = bdata [ 15 ] ; <nl> - 	 	 	 <nl> + 	 	 	 newGuid . Data4 [ 7 ] = bdata [ 15 ] ; <nl> + <nl> 	 	 	 newGuid . writeFieldsToMemory ( ) ; <nl> - 	 	 	 <nl> + <nl> 	 	 	 return newGuid ; <nl> 	 	 } <nl> <nl> 	 	 / * * <nl> + 	 	 * Generates a new guid . Code taken from the standard jdk <nl> + 	 	 * implementation ( see UUID class ) . <nl> + 	 	 * <nl> + 	 	 * @ param guid <nl> + 	 	 * the guid <nl> + 	 	 * @ return the guid <nl> + 	 	 * / <nl> + 	 	 public static GUID newGuid ( ) { <nl> + 	 	 	 SecureRandom ng = new SecureRandom ( ) ; <nl> + 	 	 	 byte [ ] randomBytes = new byte [ 16 ] ; <nl> + <nl> + 	 	 	 ng . nextBytes ( randomBytes ) ; <nl> + 	 	 	 randomBytes [ 6 ] & = 0x0f ; <nl> + 	 	 	 randomBytes [ 6 ] | = 0x40 ; <nl> + 	 	 	 randomBytes [ 8 ] & = 0x3f ; <nl> + 	 	 	 randomBytes [ 8 ] | = 0x80 ; <nl> + <nl> + 	 	 	 return new GUID ( randomBytes ) ; <nl> + 	 	 } <nl> + <nl> + 	 	 / * * <nl> 	 	 * To byte array . <nl> 	 	 * <nl> 	 	 * @ return the byte [ ] <nl> @ @ - 287 , 7 + 310 , 7 @ @ public interface Guid { <nl> 	 	 / * * <nl> 	 	 * The value of this Guid , formatted as follows : <nl> 	 	 * xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx . <nl> - 	 	 * <nl> + 	 	 * <nl> 	 	 * @ return the string <nl> 	 	 * / <nl> 	 	 public String toGuidString ( ) { <nl> @ @ - 298 , 18 + 321 , 18 @ @ public interface Guid { <nl> 	 	 	 hexStr . append ( " { " ) ; <nl> <nl> 	 	 	 for ( int i = 0 ; i < bGuid . length ; i + + ) { <nl> - 	 	 	 	 char ch1 = HEXES . charAt ( ( bGuid [ i ] & 0xF0 ) > > 4 ) ; <nl> + 	 	 	 	 char ch1 = HEXES . charAt ( ( bGuid [ i ] & 0xF0 ) > > 4 ) ; <nl> 	 	 	 	 char ch2 = HEXES . charAt ( bGuid [ i ] & 0x0F ) ; <nl> 	 	 	 	 hexStr . append ( ch1 ) . append ( ch2 ) ; <nl> - 	 	 	 	 <nl> - 	 	 	 	 if ( ( i = = 3 ) | | ( i = = 5 ) | | ( i = = 7 ) | | ( i = = 9 ) ) <nl> + <nl> + 	 	 	 	 if ( ( i = = 3 ) | | ( i = = 5 ) | | ( i = = 7 ) | | ( i = = 9 ) ) <nl> 	 	 	 	 	 hexStr . append ( " - " ) ; <nl> 	 	 	 } <nl> - 	 	 	 <nl> + <nl> 	 	 	 hexStr . append ( " } " ) ; <nl> 	 	 	 return hexStr . toString ( ) ; <nl> 	 	 } <nl> - 	 	 <nl> + <nl> 	 	 / * * <nl> 	 	 * Write fields to backing memory . <nl> 	 	 * / <nl> @ @ - 319 , 10 + 342 , 10 @ @ public interface Guid { <nl> 	 	 	 this . writeField ( " Data3 " ) ; <nl> 	 	 	 this . writeField ( " Data4 " ) ; <nl> 	 	 } <nl> - 	 	 <nl> + <nl> 	 	 / * <nl> 	 	 * ( non - Javadoc ) <nl> - 	 	 * <nl> + 	 	 * <nl> 	 	 * @ see com . sun . jna . Structure # getFieldOrder ( ) <nl> 	 	 * / <nl> 	 	 protected List getFieldOrder ( ) { <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / GuidTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / GuidTest . java <nl> index dc02bd1 . . 0699a5d 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / GuidTest . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / GuidTest . java <nl> @ @ - 3 , 28 + 3 , 127 @ @ package com . sun . jna . platform . win32 ; <nl> import junit . framework . TestCase ; <nl> <nl> import com . sun . jna . platform . win32 . Guid . GUID ; <nl> - import com . sun . jna . platform . win32 . WinDef . HWND ; <nl> <nl> + / / TODO : Auto - generated Javadoc <nl> + / * * <nl> + * The Class GuidTest . <nl> + * / <nl> public class GuidTest extends TestCase { <nl> <nl> + 	 / * * <nl> + 	 * The main method . <nl> + 	 * <nl> + 	 * @ param args <nl> + 	 * the arguments <nl> + 	 * / <nl> 	 public static void main ( String [ ] args ) { <nl> 	 	 junit . textui . TestRunner . run ( GuidTest . class ) ; <nl> 	 } <nl> <nl> + 	 / * * <nl> + 	 * Instantiates a new guid test . <nl> + 	 * / <nl> 	 public GuidTest ( ) { <nl> 	 } <nl> <nl> - 	 public void testGuid ( ) { <nl> - 	 	 System . out . println ( " ref . guid : " + " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; <nl> - 	 	 GUID guid = Ole32Util . getGUIDFromString ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; <nl> - 	 	 System . out . println ( " getGUIDFromString ( ) : " + guid . toGuidString ( ) ) ; <nl> - 	 	 <nl> - 	 	 guid = new GUID ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; <nl> - 	 	 byte [ ] byteArray = guid . toByteArray ( ) ; <nl> - 	 	 guid = new GUID ( byteArray ) ; <nl> - 	 	 System . out . println ( " toGuidString ( ) : " + guid . toGuidString ( ) ) ; <nl> - 	 	 <nl> - 	 	 guid = new GUID ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; <nl> - 	 	 System . out . println ( " getStringFromGUID : " + Ole32Util . getStringFromGUID ( guid ) ) ; <nl> + 	 / * * <nl> + 	 * Loads a GUID from string and verify that the guid returned has the <nl> + 	 * expected values in each byte . <nl> + 	 * / <nl> + 	 public void testGUIDFromString ( ) { <nl> + 	 	 String sourceGuidStr = " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ; <nl> + 	 	 / / test loading via static method <nl> + 	 	 GUID targetGuid = GUID . fromString ( sourceGuidStr ) ; <nl> + <nl> + 	 	 assertEquals ( targetGuid . toGuidString ( ) , sourceGuidStr ) ; <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * Loads a GUID from string via the constructor and verify that the guid <nl> + 	 * returned has the expected values in each byte . <nl> + 	 * / <nl> + 	 public void testGUIDFromString2 ( ) { <nl> + 	 	 String sourceGuidStr = " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ; <nl> + 	 	 / / test loading via constructor <nl> + 	 	 GUID targetGuid = new GUID ( sourceGuidStr ) ; <nl> + <nl> + 	 	 assertEquals ( targetGuid . toGuidString ( ) , sourceGuidStr ) ; <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * Loads a GUID from a byte array and verify that the guid returned has the <nl> + 	 * expected values in each byte . <nl> + 	 * / <nl> + 	 public void testGUIDFromBinary ( ) { <nl> + 	 	 byte [ ] sourceGuidBArr = new byte [ ] { ( byte ) 0xA5 , ( byte ) 0xDC , <nl> + 	 	 	 	 ( byte ) 0xBF , ( byte ) 0x10 , ( byte ) 0x65 , ( byte ) 0x30 , <nl> + 	 	 	 	 ( byte ) 0x11 , ( byte ) 0xD2 , ( byte ) 0x90 , ( byte ) 0x1F , <nl> + 	 	 	 	 ( byte ) 0x00 , ( byte ) 0xC0 , ( byte ) 0x4F , ( byte ) 0xB9 , <nl> + 	 	 	 	 ( byte ) 0x51 , ( byte ) 0xED } ; <nl> + <nl> + 	 	 / / test loading via static method <nl> + 	 	 GUID targetGuid = GUID . fromBinary ( sourceGuidBArr ) ; <nl> + 	 	 byte [ ] targetGuidBArr = targetGuid . toByteArray ( ) ; <nl> + <nl> + 	 	 for ( int i = 0 ; i < sourceGuidBArr . length ; i + + ) { <nl> + 	 	 	 assertEquals ( targetGuidBArr [ i ] , sourceGuidBArr [ i ] ) ; <nl> + 	 	 } <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * Loads a GUID from a byte array via the constructor and verify that the <nl> + 	 * guid returned has the expected values in each byte . <nl> + 	 * / <nl> + 	 public void testGUIDFromBinary2 ( ) { <nl> + 	 	 byte [ ] sourceGuidBArr = new byte [ ] { ( byte ) 0xA5 , ( byte ) 0xDC , <nl> + 	 	 	 	 ( byte ) 0xBF , ( byte ) 0x10 , ( byte ) 0x65 , ( byte ) 0x30 , <nl> + 	 	 	 	 ( byte ) 0x11 , ( byte ) 0xD2 , ( byte ) 0x90 , ( byte ) 0x1F , <nl> + 	 	 	 	 ( byte ) 0x00 , ( byte ) 0xC0 , ( byte ) 0x4F , ( byte ) 0xB9 , <nl> + 	 	 	 	 ( byte ) 0x51 , ( byte ) 0xED } ; <nl> + <nl> + 	 	 / / test loading via constructor <nl> + 	 	 GUID targetGuid = new GUID ( sourceGuidBArr ) ; <nl> + 	 	 byte [ ] targetGuidBArr = targetGuid . toByteArray ( ) ; <nl> + <nl> + 	 	 for ( int i = 0 ; i < sourceGuidBArr . length ; i + + ) { <nl> + 	 	 	 assertEquals ( targetGuidBArr [ i ] , sourceGuidBArr [ i ] ) ; <nl> + 	 	 } <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * Instantiates two guids , one with windows build - in function and one via <nl> + 	 * jna and compares it . <nl> + 	 * / <nl> + 	 public void testBehaviourWithOle32 ( ) { <nl> + 	 	 GUID ole32Guid = Ole32Util . getGUIDFromString ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; <nl> + 	 	 GUID jnaGuid = new GUID ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; <nl> + <nl> + 	 	 assertEquals ( ole32Guid , jnaGuid ) ; <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * Test with the windows build - in function , compares the result of the <nl> + 	 * methods . <nl> + 	 * / <nl> + 	 public void testBehaviourWithOle32 _ 2 ( ) { <nl> + 	 	 GUID ole32Guid = Ole32Util <nl> + 	 	 	 	 . getGUIDFromString ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; <nl> + 	 	 GUID jnaGuid = new GUID ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; <nl> + <nl> + 	 	 String ole32Guidstr = Ole32Util . getStringFromGUID ( ole32Guid ) ; <nl> + 	 	 String jnaGuidStr = jnaGuid . toGuidString ( ) ; <nl> + <nl> + 	 	 assertEquals ( ole32Guidstr , jnaGuidStr ) ; <nl> + 	 } <nl> + <nl> + 	 / * * <nl> + 	 * Tests the new guid with the build - in function coming with windows . <nl> + 	 * / <nl> + 	 public void testNewGuid ( ) { <nl> + 	 	 GUID newGuid = GUID . newGuid ( ) ; <nl> + 	 	 String guidString = newGuid . toGuidString ( ) ; <nl> + 	 	 GUID guidFromString = Ole32Util . getGUIDFromString ( guidString ) ; <nl> + <nl> + 	 	 assertEquals ( guidFromString . toGuidString ( ) , guidString ) ; <nl> 	 } <nl> }

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / linux / XAttr . java b / contrib / platform / src / com / sun / jna / platform / linux / XAttr . java 
 new file mode 100644 
 index 0000000 . . 8d36dae 
 - - - / dev / null 
 + + + b / contrib / platform / src / com / sun / jna / platform / linux / XAttr . java 
 @ @ - 0 , 0 + 1 , 86 @ @ 
 + / * 
 + * Copyright ( c ) 2018 V รก clav Haisman , All Rights Reserved 
 + * 
 + * The contents of this file is dual - licensed under 2 
 + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and 
 + * Apache License 2 . 0 . 
 + * 
 + * You can freely decide which license you want to apply to 
 + * the project . 
 + * 
 + * You may obtain a copy of the LGPL License at : 
 + * 
 + * http : / / www . gnu . org / licenses / licenses . html 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " LGPL2 . 1 " . 
 + * 
 + * You may obtain a copy of the Apache License at : 
 + * 
 + * http : / / www . apache . org / licenses / 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " AL2 . 0 " . 
 + * / 
 + package com . sun . jna . platform . linux ; 
 + 
 + import com . sun . jna . IntegerType ; 
 + import com . sun . jna . Library ; 
 + import com . sun . jna . Native ; 
 + import com . sun . jna . Pointer ; 
 + 
 + public interface XAttr extends Library { 
 + XAttr INSTANCE = Native . load ( XAttr . class ) ; 
 + 
 + class size _ t extends IntegerType { 
 + public static final size _ t ZERO = new size _ t ( ) ; 
 + 
 + private static final long serialVersionUID = 1L ; 
 + 
 + public size _ t ( ) { this ( 0 ) ; } 
 + public size _ t ( long value ) { super ( Native . SIZE _ T _ SIZE , value , true ) ; } 
 + } 
 + 
 + class ssize _ t extends IntegerType { 
 + public static final ssize _ t ZERO = new ssize _ t ( ) ; 
 + 
 + private static final long serialVersionUID = 1L ; 
 + 
 + public ssize _ t ( ) { 
 + this ( 0 ) ; 
 + } 
 + 
 + public ssize _ t ( long value ) { 
 + super ( Native . SIZE _ T _ SIZE , value , false ) ; 
 + } 
 + } 
 + 
 + int XATTR _ CREATE = 1 ; 
 + int XATTR _ REPLACE = 2 ; 
 + 
 + int EPERM = 1 ; 
 + int E2BIG = 7 ; 
 + int EEXIST = 17 ; 
 + int ENOSPC = 28 ; 
 + int ERANGE = 34 ; 
 + int ENODATA = 61 ; 
 + int ENOATTR = ENODATA ; 
 + int ENOTSUP = 95 ; 
 + int EDQUOT = 122 ; 
 + 
 + int setxattr ( String path , String name , Pointer value , size _ t size , int flags ) ; 
 + int lsetxattr ( String path , String name , Pointer value , size _ t size , int flags ) ; 
 + int fsetxattr ( int fd , String name , Pointer value , size _ t size , int flags ) ; 
 + 
 + ssize _ t getxattr ( String path , String name , Pointer value , size _ t size ) ; 
 + ssize _ t lgetxattr ( String path , String name , Pointer value , size _ t size ) ; 
 + ssize _ t fgetxattr ( int fd , String name , Pointer value , size _ t size ) ; 
 + 
 + ssize _ t listxattr ( String path , Pointer list , size _ t size ) ; 
 + ssize _ t llistxattr ( String path , Pointer list , size _ t size ) ; 
 + ssize _ t flistxattr ( int fd , Pointer list , size _ t size ) ; 
 + 
 + int removexattr ( String path , String name ) ; 
 + int lremovexattr ( String path , String name ) ; 
 + int fremovexattr ( int fd , String name ) ; 
 + } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / linux / XAttrUtil . java b / contrib / platform / src / com / sun / jna / platform / linux / XAttrUtil . java 
 new file mode 100644 
 index 0000000 . . b5154ad 
 - - - / dev / null 
 + + + b / contrib / platform / src / com / sun / jna / platform / linux / XAttrUtil . java 
 @ @ - 0 , 0 + 1 , 626 @ @ 
 + / * 
 + * Copyright ( c ) 2018 V รก clav Haisman , All Rights Reserved 
 + * 
 + * The contents of this file is dual - licensed under 2 
 + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and 
 + * Apache License 2 . 0 . 
 + * 
 + * You can freely decide which license you want to apply to 
 + * the project . 
 + * 
 + * You may obtain a copy of the LGPL License at : 
 + * 
 + * http : / / www . gnu . org / licenses / licenses . html 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " LGPL2 . 1 " . 
 + * 
 + * You may obtain a copy of the Apache License at : 
 + * 
 + * http : / / www . apache . org / licenses / 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " AL2 . 0 " . 
 + * / 
 + package com . sun . jna . platform . linux ; 
 + 
 + import com . sun . jna . Memory ; 
 + import com . sun . jna . Native ; 
 + import com . sun . jna . platform . linux . XAttr . size _ t ; 
 + import com . sun . jna . platform . linux . XAttr . ssize _ t ; 
 + 
 + import java . io . IOException ; 
 + import java . nio . ByteBuffer ; 
 + import java . nio . charset . Charset ; 
 + import java . util . Collection ; 
 + import java . util . LinkedHashSet ; 
 + import java . util . Set ; 
 + 
 + / * * 
 + * Utility functions class for handling file extended attributes on Linux . 
 + * / 
 + public abstract class XAttrUtil { 
 + 
 + private XAttrUtil ( ) { 
 + } 
 + 
 + / * * 
 + * Set or replace value of extended attribute . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ param value value to set 
 + * @ throws IOException on any error 
 + * / 
 + public static void setXAttr ( String path , String name , String value ) throws IOException { 
 + setXAttr ( path , name , value , Native . getDefaultStringEncoding ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Set or replace value of extended attribute . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ param value value to set 
 + * @ param encoding character encoding to be used for stored value 
 + * @ throws IOException on any error 
 + * / 
 + public static void setXAttr ( String path , String name , String value , String encoding ) 
 + throws IOException { 
 + setXAttr ( path , name , value . getBytes ( encoding ) ) ; 
 + } 
 + 
 + / * * 
 + * Set or replace value of extended attribute . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ param value value to set 
 + * @ throws IOException on any error 
 + * / 
 + public static void setXAttr ( String path , String name , byte [ ] value ) throws IOException { 
 + Memory valueMem = bytesToMemory ( value ) ; 
 + int retval = XAttr . INSTANCE . setxattr ( path , name , valueMem , new size _ t ( valueMem . size ( ) ) , 0 ) ; 
 + if ( retval ! = 0 ) { 
 + final int eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + 
 + 
 + / * * 
 + * Set or replace value of extended attribute but in case of symbolic link set the extended 
 + * attribute on the link itself instead linked file . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ param value value to set 
 + * @ throws IOException on any error 
 + * / 
 + public static void lSetXAttr ( String path , String name , String value ) throws IOException { 
 + lSetXAttr ( path , name , value , Native . getDefaultStringEncoding ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Set or replace value of extended attribute but in case of symbolic link set the extended 
 + * attribute on the link itself instead linked file . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ param value value to set 
 + * @ param encoding character encoding to be used for stored value 
 + * @ throws IOException on any error 
 + * / 
 + public static void lSetXAttr ( String path , String name , String value , String encoding ) 
 + throws IOException { 
 + lSetXAttr ( path , name , value . getBytes ( encoding ) ) ; 
 + } 
 + 
 + / * * 
 + * Set or replace value of extended attribute but in case of symbolic link set the extended 
 + * attribute on the link itself instead linked file . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ param value value to set 
 + * @ throws IOException on any error 
 + * / 
 + public static void lSetXAttr ( String path , String name , byte [ ] value ) throws IOException { 
 + Memory valueMem = bytesToMemory ( value ) ; 
 + final int retval = XAttr . INSTANCE . lsetxattr ( path , name , valueMem , 
 + new size _ t ( valueMem . size ( ) ) , 0 ) ; 
 + if ( retval ! = 0 ) { 
 + final int eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + 
 + 
 + / * * 
 + * Set or replace value of extended attribute . 
 + * 
 + * @ param fd file handle 
 + * @ param name extended attribute name 
 + * @ param value value to set 
 + * @ throws IOException on any error 
 + * / 
 + public static void fSetXAttr ( int fd , String name , String value ) throws IOException { 
 + fSetXAttr ( fd , name , value , Native . getDefaultStringEncoding ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Set or replace value of extended attribute . 
 + * 
 + * @ param fd file handle 
 + * @ param name extended attribute name 
 + * @ param value value to set 
 + * @ param encoding character encoding to be used for stored value 
 + * @ throws IOException on any error 
 + * / 
 + public static void fSetXAttr ( int fd , String name , String value , String encoding ) 
 + throws IOException { 
 + fSetXAttr ( fd , name , value . getBytes ( encoding ) ) ; 
 + } 
 + 
 + / * * 
 + * Set or replace value of extended attribute . 
 + * 
 + * @ param fd file handle 
 + * @ param name extended attribute name 
 + * @ param value value to set 
 + * @ throws IOException on any error 
 + * / 
 + public static void fSetXAttr ( int fd , String name , byte [ ] value ) throws IOException { 
 + Memory valueMem = bytesToMemory ( value ) ; 
 + final int retval = XAttr . INSTANCE . fsetxattr ( fd , name , valueMem , new size _ t ( valueMem . size ( ) ) , 
 + 0 ) ; 
 + if ( retval ! = 0 ) { 
 + final int eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + 
 + 
 + / * * 
 + * Get extended attribute value . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static String getXAttr ( String path , String name ) throws IOException { 
 + return getXAttr ( path , name , Native . getDefaultStringEncoding ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Get extended attribute value . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ param encoding character encoding to be used to decode stored extended attribute value 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static String getXAttr ( String path , String name , String encoding ) throws IOException { 
 + Memory valueMem = getXAttrAsMemory ( path , name ) ; 
 + return Charset . forName ( encoding ) 
 + . decode ( valueMem . getByteBuffer ( 0 , valueMem . size ( ) ) ) 
 + . toString ( ) ; 
 + } 
 + 
 + / * * 
 + * Get extended attribute value . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static byte [ ] getXAttrBytes ( String path , String name ) throws IOException { 
 + Memory valueMem = getXAttrAsMemory ( path , name ) ; 
 + return valueMem . getByteArray ( 0 , ( int ) valueMem . size ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Get extended attribute value . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static Memory getXAttrAsMemory ( String path , String name ) throws IOException { 
 + ssize _ t retval ; 
 + Memory valueMem ; 
 + int eno = 0 ; 
 + 
 + do { 
 + retval = XAttr . INSTANCE . getxattr ( path , name , null , size _ t . ZERO ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + 
 + valueMem = new Memory ( retval . longValue ( ) ) ; 
 + retval = XAttr . INSTANCE . getxattr ( path , name , valueMem , new size _ t ( valueMem . size ( ) ) ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + if ( eno ! = XAttr . ERANGE ) { 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; 
 + 
 + return valueMem ; 
 + } 
 + 
 + 
 + / * * 
 + * Get extended attribute value but in case of symbolic link get the value from the link 
 + * itself instead of linked file . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static String lGetXAttr ( String path , String name ) throws IOException { 
 + return lGetXAttr ( path , name , Native . getDefaultStringEncoding ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Get extended attribute value but in case of symbolic link get the value from the link 
 + * itself instead of linked file . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ param encoding character encoding to be used to decode stored extended attribute value 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static String lGetXAttr ( String path , String name , String encoding ) throws IOException { 
 + Memory valueMem = lGetXAttrAsMemory ( path , name ) ; 
 + return Charset . forName ( encoding ) 
 + . decode ( valueMem . getByteBuffer ( 0 , valueMem . size ( ) ) ) 
 + . toString ( ) ; 
 + } 
 + 
 + / * * 
 + * Get extended attribute value but in case of symbolic link get the value from the link 
 + * itself instead of linked file . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static byte [ ] lGetXAttrBytes ( String path , String name ) throws IOException { 
 + Memory valueMem = lGetXAttrAsMemory ( path , name ) ; 
 + return valueMem . getByteArray ( 0 , ( int ) valueMem . size ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Get extended attribute value but in case of symbolic link get the value from the link 
 + * itself instead of linked file . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static Memory lGetXAttrAsMemory ( String path , String name ) throws IOException { 
 + ssize _ t retval ; 
 + Memory valueMem ; 
 + int eno = 0 ; 
 + 
 + do { 
 + retval = XAttr . INSTANCE . lgetxattr ( path , name , null , size _ t . ZERO ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + 
 + valueMem = new Memory ( retval . longValue ( ) ) ; 
 + retval = XAttr . INSTANCE . lgetxattr ( path , name , valueMem , new size _ t ( valueMem . size ( ) ) ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + if ( eno ! = XAttr . ERANGE ) { 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; 
 + 
 + return valueMem ; 
 + } 
 + 
 + 
 + / * * 
 + * Get extended attribute value . 
 + * 
 + * @ param fd file handle 
 + * @ param name extended attribute name 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static String fGetXAttr ( int fd , String name ) throws IOException { 
 + return fGetXAttr ( fd , name , Native . getDefaultStringEncoding ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Get extended attribute value . 
 + * 
 + * @ param fd file handle 
 + * @ param name extended attribute name 
 + * @ param encoding character encoding to be used to decode stored extended attribute value 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static String fGetXAttr ( int fd , String name , String encoding ) throws IOException { 
 + Memory valueMem = fGetXAttrAsMemory ( fd , name ) ; 
 + return Charset . forName ( encoding ) 
 + . decode ( valueMem . getByteBuffer ( 0 , valueMem . size ( ) ) ) 
 + . toString ( ) ; 
 + } 
 + 
 + / * * 
 + * Get extended attribute value . 
 + * 
 + * @ param fd file handle 
 + * @ param name extended attribute name 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static byte [ ] fGetXAttrBytes ( int fd , String name ) throws IOException { 
 + Memory valueMem = fGetXAttrAsMemory ( fd , name ) ; 
 + return valueMem . getByteArray ( 0 , ( int ) valueMem . size ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Get extended attribute value . 
 + * 
 + * @ param fd file handle 
 + * @ param name extended attribute name 
 + * @ return extended attribute value 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static Memory fGetXAttrAsMemory ( int fd , String name ) throws IOException { 
 + ssize _ t retval ; 
 + Memory valueMem ; 
 + int eno = 0 ; 
 + 
 + do { 
 + retval = XAttr . INSTANCE . fgetxattr ( fd , name , null , size _ t . ZERO ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + 
 + valueMem = new Memory ( retval . longValue ( ) ) ; 
 + retval = XAttr . INSTANCE . fgetxattr ( fd , name , valueMem , new size _ t ( valueMem . size ( ) ) ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + if ( eno ! = XAttr . ERANGE ) { 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; 
 + 
 + return valueMem ; 
 + } 
 + 
 + 
 + / * * 
 + * List extended attributes on file . 
 + * 
 + * @ param path file path 
 + * @ return collection of extended attributes ' names 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static Collection < String > listXAttr ( String path ) throws IOException { 
 + return listXAttr ( path , Native . getDefaultStringEncoding ( ) ) ; 
 + } 
 + 
 + / * * 
 + * List extended attributes on file . 
 + * 
 + * @ param path file path 
 + * @ param encoding character encoding use to decode extended attributes ' names 
 + * @ return collection of extended attributes ' names 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static Collection < String > listXAttr ( String path , String encoding ) throws IOException { 
 + ssize _ t retval ; 
 + Memory listMem ; 
 + int eno = 0 ; 
 + 
 + do { 
 + retval = XAttr . INSTANCE . listxattr ( path , null , size _ t . ZERO ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + 
 + listMem = new Memory ( retval . longValue ( ) ) ; 
 + retval = XAttr . INSTANCE . listxattr ( path , listMem , new size _ t ( listMem . size ( ) ) ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + if ( eno ! = XAttr . ERANGE ) { 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; 
 + 
 + return splitBufferToStrings ( listMem , encoding ) ; 
 + } 
 + 
 + 
 + / * * 
 + * List extended attributes on file but in case of symbolic link get extended attributes of 
 + * the link itself instead of linked file . 
 + * 
 + * @ param path file path 
 + * @ return collection of extended attributes ' names 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static Collection < String > lListXAttr ( String path ) throws IOException { 
 + return lListXAttr ( path , Native . getDefaultStringEncoding ( ) ) ; 
 + } 
 + 
 + / * * 
 + * List extended attributes on file but in case of symbolic link get extended attributes of 
 + * the link itself instead of linked file . 
 + * 
 + * @ param path file path 
 + * @ param encoding character encoding use to decode extended attributes ' names 
 + * @ return collection of extended attributes ' names 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static Collection < String > lListXAttr ( String path , String encoding ) throws IOException { 
 + ssize _ t retval ; 
 + Memory listMem ; 
 + int eno = 0 ; 
 + 
 + do { 
 + retval = XAttr . INSTANCE . llistxattr ( path , null , size _ t . ZERO ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + 
 + listMem = new Memory ( retval . longValue ( ) ) ; 
 + retval = XAttr . INSTANCE . llistxattr ( path , listMem , new size _ t ( listMem . size ( ) ) ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + if ( eno ! = XAttr . ERANGE ) { 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; 
 + 
 + return splitBufferToStrings ( listMem , encoding ) ; 
 + } 
 + 
 + 
 + / * * 
 + * List extended attributes on file . 
 + * 
 + * @ param fd file handle 
 + * @ return collection of extended attributes ' names 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static Collection < String > fListXAttr ( int fd ) throws IOException { 
 + return fListXAttr ( fd , Native . getDefaultStringEncoding ( ) ) ; 
 + } 
 + 
 + / * * 
 + * List extended attributes on file . 
 + * 
 + * @ param fd file handle 
 + * @ param encoding character encoding use to decode extended attributes ' names 
 + * @ return collection of extended attributes ' names 
 + * @ throws IOException on any error except < code > ERANGE < / code > which handled internally 
 + * / 
 + public static Collection < String > fListXAttr ( int fd , String encoding ) throws IOException { 
 + ssize _ t retval ; 
 + Memory listMem ; 
 + int eno = 0 ; 
 + 
 + do { 
 + retval = XAttr . INSTANCE . flistxattr ( fd , null , size _ t . ZERO ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + 
 + listMem = new Memory ( retval . longValue ( ) ) ; 
 + retval = XAttr . INSTANCE . flistxattr ( fd , listMem , new size _ t ( listMem . size ( ) ) ) ; 
 + if ( retval . longValue ( ) < 0 ) { 
 + eno = Native . getLastError ( ) ; 
 + if ( eno ! = XAttr . ERANGE ) { 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + } while ( retval . longValue ( ) < 0 & & eno = = XAttr . ERANGE ) ; 
 + 
 + return splitBufferToStrings ( listMem , encoding ) ; 
 + } 
 + 
 + 
 + / * * 
 + * Remove extended attribute from file . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ throws IOException on any error 
 + * / 
 + public static void removeXAttr ( String path , String name ) throws IOException { 
 + final int retval = XAttr . INSTANCE . removexattr ( path , name ) ; 
 + if ( retval ! = 0 ) { 
 + final int eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Remove extended attribute from file but in case of symbolic link remove extended attribute 
 + * from the link itself instead of linked file . 
 + * 
 + * @ param path file path 
 + * @ param name extended attribute name 
 + * @ throws IOException on any error 
 + * / 
 + public static void lRemoveXAttr ( String path , String name ) throws IOException { 
 + final int retval = XAttr . INSTANCE . lremovexattr ( path , name ) ; 
 + if ( retval ! = 0 ) { 
 + final int eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Remove extended attribute from file . 
 + * 
 + * @ param fd file handle 
 + * @ param name extended attribute name 
 + * @ throws IOException on any error 
 + * / 
 + public static void fRemoveXAttr ( int fd , String name ) throws IOException { 
 + final int retval = XAttr . INSTANCE . fremovexattr ( fd , name ) ; 
 + if ( retval ! = 0 ) { 
 + final int eno = Native . getLastError ( ) ; 
 + throw new IOException ( " errno : " + eno ) ; 
 + } 
 + } 
 + 
 + private static Memory bytesToMemory ( byte [ ] value ) { 
 + Memory valueMem = new Memory ( value . length ) ; 
 + valueMem . write ( 0 , value , 0 , value . length ) ; 
 + return valueMem ; 
 + } 
 + 
 + private static Collection < String > splitBufferToStrings ( Memory valueMem , String encoding ) 
 + throws IOException { 
 + final Charset charset = Charset . forName ( encoding ) ; 
 + final Set < String > attributesList = new LinkedHashSet < String > ( 1 ) ; 
 + long offset = 0 ; 
 + while ( offset ! = valueMem . size ( ) ) { 
 + / / Find terminating NUL character . 
 + long nulOffset = valueMem . indexOf ( offset , ( byte ) 0 ) ; 
 + if ( nulOffset = = - 1 ) { 
 + throw new IOException ( " Expected NUL character not found . " ) ; 
 + } 
 + 
 + / / Duplicate buffer with limit at end of name . 
 + final ByteBuffer nameBuffer = valueMem . getByteBuffer ( offset , nulOffset ) ; 
 + 
 + / / Convert bytes of the name to String . 
 + final String name = charset . decode ( nameBuffer ) . toString ( ) ; 
 + attributesList . add ( name ) ; 
 + 
 + / / Move past NUL . 
 + offset + = nulOffset + 1 ; 
 + } 
 + return attributesList ; 
 + } 
 + } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / linux / XAttrUtilTest . java b / contrib / platform / test / com / sun / jna / platform / linux / XAttrUtilTest . java 
 new file mode 100644 
 index 0000000 . . c4a074b 
 - - - / dev / null 
 + + + b / contrib / platform / test / com / sun / jna / platform / linux / XAttrUtilTest . java 
 @ @ - 0 , 0 + 1 , 70 @ @ 
 + / * 
 + * Copyright ( c ) 2018 V รก clav Haisman , All Rights Reserved 
 + * 
 + * The contents of this file is dual - licensed under 2 
 + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and 
 + * Apache License 2 . 0 . 
 + * 
 + * You can freely decide which license you want to apply to 
 + * the project . 
 + * 
 + * You may obtain a copy of the LGPL License at : 
 + * 
 + * http : / / www . gnu . org / licenses / licenses . html 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " LGPL2 . 1 " . 
 + * 
 + * You may obtain a copy of the Apache License at : 
 + * 
 + * http : / / www . apache . org / licenses / 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " AL2 . 0 " . 
 + * / 
 + package com . sun . jna . platform . linux ; 
 + 
 + import java . io . File ; 
 + import java . io . IOException ; 
 + import java . util . Collection ; 
 + 
 + import org . junit . Test ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + public class XAttrUtilTest { 
 + private static final String TEST _ STRING = " ลฝ lu ลฅ ou ฤ k รฝ k ลฏ ล รบ p ฤ l nebo tak n ฤ co . " ; 
 + private static final String TEST _ STRING _ 2 = " P ล รญ li ลก ลพ lu ลฅ ou ฤ k รฝ k ลฏ ล รบ p ฤ l ฤ รก belsk รฉ รณ dy . " ; 
 + private static final String TEST _ ATTRIBUTE = " user . test " ; 
 + private static final String TEST _ ATTRIBUTE _ FOO = TEST _ ATTRIBUTE + " . foo " ; 
 + 
 + @ Test 
 + public void setXAttr ( ) throws IOException { 
 + File file = File . createTempFile ( " xattr " , " test " ) ; 
 + file . deleteOnExit ( ) ; 
 + 
 + XAttrUtil . setXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE , TEST _ STRING ) ; 
 + XAttrUtil . setXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE _ FOO , TEST _ STRING _ 2 ) ; 
 + 
 + String retrievedValue = XAttrUtil . getXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE ) ; 
 + assertEquals ( TEST _ STRING , retrievedValue ) ; 
 + 
 + retrievedValue = XAttrUtil . getXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE _ FOO ) ; 
 + assertEquals ( TEST _ STRING _ 2 , retrievedValue ) ; 
 + 
 + XAttrUtil . setXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE , TEST _ STRING _ 2 ) ; 
 + retrievedValue = XAttrUtil . lGetXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE ) ; 
 + assertEquals ( TEST _ STRING _ 2 , retrievedValue ) ; 
 + 
 + Collection < String > xattrs = XAttrUtil . listXAttr ( file . getAbsolutePath ( ) ) ; 
 + assertTrue ( xattrs . contains ( TEST _ ATTRIBUTE ) ) ; 
 + assertTrue ( xattrs . contains ( TEST _ ATTRIBUTE _ FOO ) ) ; 
 + 
 + XAttrUtil . removeXAttr ( file . getAbsolutePath ( ) , TEST _ ATTRIBUTE ) ; 
 + xattrs = XAttrUtil . lListXAttr ( file . getAbsolutePath ( ) ) ; 
 + assertFalse ( xattrs . contains ( TEST _ ATTRIBUTE ) ) ; 
 + assertTrue ( xattrs . contains ( TEST _ ATTRIBUTE _ FOO ) ) ; 
 + } 
 + } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Guid . java b / contrib / platform / src / com / sun / jna / platform / win32 / Guid . java 
 index 5f378fc . . 6c04a2f 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Guid . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Guid . java 
 @ @ - 1 , 17 + 1 , 18 @ @ 
 / * Copyright ( c ) 2010 Daniel Doubrovkine , All Rights Reserved 
 - * 
 + * 
 * This library is free software ; you can redistribute it and / or 
 * modify it under the terms of the GNU Lesser General Public 
 * License as published by the Free Software Foundation ; either 
 * version 2 . 1 of the License , or ( at your option ) any later version . 
 - * 
 + * 
 * This library is distributed in the hope that it will be useful , 
 * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 + * Lesser General Public License for more details . 
 * / 
 package com . sun . jna . platform . win32 ; 
 
 + import java . security . SecureRandom ; 
 import java . util . Arrays ; 
 import java . util . List ; 
 
 @ @ - 21 , 7 + 22 , 7 @ @ import com . sun . jna . Structure ; 
 / / TODO : Auto - generated Javadoc 
 / * * 
 * Ported from Guid . h . Microsoft Windows SDK 6 . 0A . 
 - * 
 + * 
 * @ author dblock [ at ] dblock . org 
 * / 
 public interface Guid { 
 @ @ - 45 , 7 + 46 , 7 @ @ public interface Guid { 
 
 	 	 	 / * * 
 	 	 	 * Instantiates a new by reference . 
 - 	 	 	 * 
 + 	 	 	 * 
 	 	 	 * @ param guid 
 	 	 	 * the guid 
 	 	 	 * / 
 @ @ - 60 , 7 + 61 , 7 @ @ public interface Guid { 
 
 	 	 	 / * * 
 	 	 	 * Instantiates a new by reference . 
 - 	 	 	 * 
 + 	 	 	 * 
 	 	 	 * @ param memory 
 	 	 	 * the memory 
 	 	 	 * / 
 @ @ - 89 , 7 + 90 , 7 @ @ public interface Guid { 
 
 	 	 / * * 
 	 	 * Instantiates a new guid . 
 - 	 	 * 
 + 	 	 * 
 	 	 * @ param guid 
 	 	 * the guid 
 	 	 * / 
 @ @ - 98 , 13 + 99 , 13 @ @ public interface Guid { 
 	 	 	 this . Data2 = guid . Data2 ; 
 	 	 	 this . Data3 = guid . Data3 ; 
 	 	 	 this . Data4 = guid . Data4 ; 
 - 	 	 	 
 + 
 	 	 	 this . writeFieldsToMemory ( ) ; 
 	 	 } 
 
 	 	 / * * 
 	 	 * Instantiates a new guid . 
 - 	 	 * 
 + 	 	 * 
 	 	 * @ param guid 
 	 	 * the guid 
 	 	 * / 
 @ @ - 114 , 7 + 115 , 7 @ @ public interface Guid { 
 
 	 	 / * * 
 	 	 * Instantiates a new guid . 
 - 	 	 * 
 + 	 	 * 
 	 	 * @ param data 
 	 	 * the data 
 	 	 * / 
 @ @ - 124 , 7 + 125 , 7 @ @ public interface Guid { 
 
 	 	 / * * 
 	 	 * Instantiates a new guid . 
 - 	 	 * 
 + 	 	 * 
 	 	 * @ param memory 
 	 	 * the memory 
 	 	 * / 
 @ @ - 135 , 7 + 136 , 7 @ @ public interface Guid { 
 
 	 	 / * * 
 	 	 * From binary . 
 - 	 	 * 
 + 	 	 * 
 	 	 * @ param data 
 	 	 * the data 
 	 	 * @ return the guid 
 @ @ - 174 , 15 + 175 , 15 @ @ public interface Guid { 
 	 	 	 newGuid . Data4 [ 5 ] = data [ 13 ] ; 
 	 	 	 newGuid . Data4 [ 6 ] = data [ 14 ] ; 
 	 	 	 newGuid . Data4 [ 7 ] = data [ 15 ] ; 
 - 	 	 	 
 + 
 	 	 	 newGuid . writeFieldsToMemory ( ) ; 
 - 	 	 	 
 + 
 	 	 	 return newGuid ; 
 	 	 } 
 
 	 	 / * * 
 	 	 * From string . 
 - 	 	 * 
 + 	 	 * 
 	 	 * @ param guid 
 	 	 * the guid 
 	 	 * @ return the guid 
 @ @ - 193 , 30 + 194 , 31 @ @ public interface Guid { 
 	 	 	 char [ ] _ cguid = guid . toCharArray ( ) ; 
 	 	 	 byte [ ] bdata = new byte [ 16 ] ; 
 	 	 	 GUID newGuid = new GUID ( ) ; 
 - 	 	 	 
 + 
 	 	 	 / / we not accept a string longer than 38 chars 
 	 	 	 if ( guid . length ( ) > 38 ) { 
 	 	 	 	 throw new IllegalArgumentException ( " Invalid guid length : " 
 	 	 	 	 	 	 + guid . length ( ) ) ; 
 	 	 	 } 
 - 	 	 	 
 + 
 	 	 	 / / remove ' { ' , ' } ' and ' - ' from guid string 
 	 	 	 for ( int i = 0 ; i < _ cguid . length ; i + + ) { 
 - 	 	 	 	 if ( ( _ cguid [ i ] ! = ' { ' ) & & ( _ cguid [ i ] ! = ' - ' ) & & ( _ cguid [ i ] ! = ' } ' ) ) 
 + 	 	 	 	 if ( ( _ cguid [ i ] ! = ' { ' ) & & ( _ cguid [ i ] ! = ' - ' ) 
 + 	 	 	 	 	 	 & & ( _ cguid [ i ] ! = ' } ' ) ) 
 	 	 	 	 	 _ cnewguid [ y + + ] = _ cguid [ i ] ; 
 	 	 	 } 
 - 	 	 	 
 + 
 	 	 	 / / convert char to byte 
 	 	 	 for ( int i = 0 ; i < 32 ; i + = 2 ) { 
 - 	 	 	 	 bdata [ i / 2 ] = ( byte ) ( ( Character . digit ( _ cnewguid [ i ] , 16 ) < < 4 ) + Character 
 - 	 	 	 	 	 	 . digit ( _ cnewguid [ i + 1 ] , 16 ) & 0xff ) ; 
 + 	 	 	 	 bdata [ i / 2 ] = ( byte ) ( ( Character . digit ( _ cnewguid [ i ] , 16 ) < < 4 ) 
 + 	 	 	 	 	 	 + Character . digit ( _ cnewguid [ i + 1 ] , 16 ) & 0xff ) ; 
 	 	 	 } 
 - 	 	 	 
 + 
 	 	 	 if ( bdata . length ! = 16 ) { 
 	 	 	 	 throw new IllegalArgumentException ( " Invalid data length : " 
 	 	 	 	 	 	 + bdata . length ) ; 
 	 	 	 } 
 - 	 	 	 
 + 
 	 	 	 long data1Temp = bdata [ 0 ] & 0xff ; 
 	 	 	 data1Temp < < = 8 ; 
 	 	 	 data1Temp | = bdata [ 1 ] & 0xff ; 
 @ @ - 243 , 14 + 245 , 35 @ @ public interface Guid { 
 	 	 	 newGuid . Data4 [ 4 ] = bdata [ 12 ] ; 
 	 	 	 newGuid . Data4 [ 5 ] = bdata [ 13 ] ; 
 	 	 	 newGuid . Data4 [ 6 ] = bdata [ 14 ] ; 
 - 	 	 	 newGuid . Data4 [ 7 ] = bdata [ 15 ] ; 
 - 	 	 	 
 + 	 	 	 newGuid . Data4 [ 7 ] = bdata [ 15 ] ; 
 + 
 	 	 	 newGuid . writeFieldsToMemory ( ) ; 
 - 	 	 	 
 + 
 	 	 	 return newGuid ; 
 	 	 } 
 
 	 	 / * * 
 + 	 	 * Generates a new guid . Code taken from the standard jdk 
 + 	 	 * implementation ( see UUID class ) . 
 + 	 	 * 
 + 	 	 * @ param guid 
 + 	 	 * the guid 
 + 	 	 * @ return the guid 
 + 	 	 * / 
 + 	 	 public static GUID newGuid ( ) { 
 + 	 	 	 SecureRandom ng = new SecureRandom ( ) ; 
 + 	 	 	 byte [ ] randomBytes = new byte [ 16 ] ; 
 + 
 + 	 	 	 ng . nextBytes ( randomBytes ) ; 
 + 	 	 	 randomBytes [ 6 ] & = 0x0f ; 
 + 	 	 	 randomBytes [ 6 ] | = 0x40 ; 
 + 	 	 	 randomBytes [ 8 ] & = 0x3f ; 
 + 	 	 	 randomBytes [ 8 ] | = 0x80 ; 
 + 
 + 	 	 	 return new GUID ( randomBytes ) ; 
 + 	 	 } 
 + 
 + 	 	 / * * 
 	 	 * To byte array . 
 	 	 * 
 	 	 * @ return the byte [ ] 
 @ @ - 287 , 7 + 310 , 7 @ @ public interface Guid { 
 	 	 / * * 
 	 	 * The value of this Guid , formatted as follows : 
 	 	 * xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx . 
 - 	 	 * 
 + 	 	 * 
 	 	 * @ return the string 
 	 	 * / 
 	 	 public String toGuidString ( ) { 
 @ @ - 298 , 18 + 321 , 18 @ @ public interface Guid { 
 	 	 	 hexStr . append ( " { " ) ; 
 
 	 	 	 for ( int i = 0 ; i < bGuid . length ; i + + ) { 
 - 	 	 	 	 char ch1 = HEXES . charAt ( ( bGuid [ i ] & 0xF0 ) > > 4 ) ; 
 + 	 	 	 	 char ch1 = HEXES . charAt ( ( bGuid [ i ] & 0xF0 ) > > 4 ) ; 
 	 	 	 	 char ch2 = HEXES . charAt ( bGuid [ i ] & 0x0F ) ; 
 	 	 	 	 hexStr . append ( ch1 ) . append ( ch2 ) ; 
 - 	 	 	 	 
 - 	 	 	 	 if ( ( i = = 3 ) | | ( i = = 5 ) | | ( i = = 7 ) | | ( i = = 9 ) ) 
 + 
 + 	 	 	 	 if ( ( i = = 3 ) | | ( i = = 5 ) | | ( i = = 7 ) | | ( i = = 9 ) ) 
 	 	 	 	 	 hexStr . append ( " - " ) ; 
 	 	 	 } 
 - 	 	 	 
 + 
 	 	 	 hexStr . append ( " } " ) ; 
 	 	 	 return hexStr . toString ( ) ; 
 	 	 } 
 - 	 	 
 + 
 	 	 / * * 
 	 	 * Write fields to backing memory . 
 	 	 * / 
 @ @ - 319 , 10 + 342 , 10 @ @ public interface Guid { 
 	 	 	 this . writeField ( " Data3 " ) ; 
 	 	 	 this . writeField ( " Data4 " ) ; 
 	 	 } 
 - 	 	 
 + 
 	 	 / * 
 	 	 * ( non - Javadoc ) 
 - 	 	 * 
 + 	 	 * 
 	 	 * @ see com . sun . jna . Structure # getFieldOrder ( ) 
 	 	 * / 
 	 	 protected List getFieldOrder ( ) { 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / GuidTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / GuidTest . java 
 index dc02bd1 . . 0699a5d 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / GuidTest . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / GuidTest . java 
 @ @ - 3 , 28 + 3 , 127 @ @ package com . sun . jna . platform . win32 ; 
 import junit . framework . TestCase ; 
 
 import com . sun . jna . platform . win32 . Guid . GUID ; 
 - import com . sun . jna . platform . win32 . WinDef . HWND ; 
 
 + / / TODO : Auto - generated Javadoc 
 + / * * 
 + * The Class GuidTest . 
 + * / 
 public class GuidTest extends TestCase { 
 
 + 	 / * * 
 + 	 * The main method . 
 + 	 * 
 + 	 * @ param args 
 + 	 * the arguments 
 + 	 * / 
 	 public static void main ( String [ ] args ) { 
 	 	 junit . textui . TestRunner . run ( GuidTest . class ) ; 
 	 } 
 
 + 	 / * * 
 + 	 * Instantiates a new guid test . 
 + 	 * / 
 	 public GuidTest ( ) { 
 	 } 
 
 - 	 public void testGuid ( ) { 
 - 	 	 System . out . println ( " ref . guid : " + " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; 
 - 	 	 GUID guid = Ole32Util . getGUIDFromString ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; 
 - 	 	 System . out . println ( " getGUIDFromString ( ) : " + guid . toGuidString ( ) ) ; 
 - 	 	 
 - 	 	 guid = new GUID ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; 
 - 	 	 byte [ ] byteArray = guid . toByteArray ( ) ; 
 - 	 	 guid = new GUID ( byteArray ) ; 
 - 	 	 System . out . println ( " toGuidString ( ) : " + guid . toGuidString ( ) ) ; 
 - 	 	 
 - 	 	 guid = new GUID ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; 
 - 	 	 System . out . println ( " getStringFromGUID : " + Ole32Util . getStringFromGUID ( guid ) ) ; 
 + 	 / * * 
 + 	 * Loads a GUID from string and verify that the guid returned has the 
 + 	 * expected values in each byte . 
 + 	 * / 
 + 	 public void testGUIDFromString ( ) { 
 + 	 	 String sourceGuidStr = " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ; 
 + 	 	 / / test loading via static method 
 + 	 	 GUID targetGuid = GUID . fromString ( sourceGuidStr ) ; 
 + 
 + 	 	 assertEquals ( targetGuid . toGuidString ( ) , sourceGuidStr ) ; 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * Loads a GUID from string via the constructor and verify that the guid 
 + 	 * returned has the expected values in each byte . 
 + 	 * / 
 + 	 public void testGUIDFromString2 ( ) { 
 + 	 	 String sourceGuidStr = " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ; 
 + 	 	 / / test loading via constructor 
 + 	 	 GUID targetGuid = new GUID ( sourceGuidStr ) ; 
 + 
 + 	 	 assertEquals ( targetGuid . toGuidString ( ) , sourceGuidStr ) ; 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * Loads a GUID from a byte array and verify that the guid returned has the 
 + 	 * expected values in each byte . 
 + 	 * / 
 + 	 public void testGUIDFromBinary ( ) { 
 + 	 	 byte [ ] sourceGuidBArr = new byte [ ] { ( byte ) 0xA5 , ( byte ) 0xDC , 
 + 	 	 	 	 ( byte ) 0xBF , ( byte ) 0x10 , ( byte ) 0x65 , ( byte ) 0x30 , 
 + 	 	 	 	 ( byte ) 0x11 , ( byte ) 0xD2 , ( byte ) 0x90 , ( byte ) 0x1F , 
 + 	 	 	 	 ( byte ) 0x00 , ( byte ) 0xC0 , ( byte ) 0x4F , ( byte ) 0xB9 , 
 + 	 	 	 	 ( byte ) 0x51 , ( byte ) 0xED } ; 
 + 
 + 	 	 / / test loading via static method 
 + 	 	 GUID targetGuid = GUID . fromBinary ( sourceGuidBArr ) ; 
 + 	 	 byte [ ] targetGuidBArr = targetGuid . toByteArray ( ) ; 
 + 
 + 	 	 for ( int i = 0 ; i < sourceGuidBArr . length ; i + + ) { 
 + 	 	 	 assertEquals ( targetGuidBArr [ i ] , sourceGuidBArr [ i ] ) ; 
 + 	 	 } 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * Loads a GUID from a byte array via the constructor and verify that the 
 + 	 * guid returned has the expected values in each byte . 
 + 	 * / 
 + 	 public void testGUIDFromBinary2 ( ) { 
 + 	 	 byte [ ] sourceGuidBArr = new byte [ ] { ( byte ) 0xA5 , ( byte ) 0xDC , 
 + 	 	 	 	 ( byte ) 0xBF , ( byte ) 0x10 , ( byte ) 0x65 , ( byte ) 0x30 , 
 + 	 	 	 	 ( byte ) 0x11 , ( byte ) 0xD2 , ( byte ) 0x90 , ( byte ) 0x1F , 
 + 	 	 	 	 ( byte ) 0x00 , ( byte ) 0xC0 , ( byte ) 0x4F , ( byte ) 0xB9 , 
 + 	 	 	 	 ( byte ) 0x51 , ( byte ) 0xED } ; 
 + 
 + 	 	 / / test loading via constructor 
 + 	 	 GUID targetGuid = new GUID ( sourceGuidBArr ) ; 
 + 	 	 byte [ ] targetGuidBArr = targetGuid . toByteArray ( ) ; 
 + 
 + 	 	 for ( int i = 0 ; i < sourceGuidBArr . length ; i + + ) { 
 + 	 	 	 assertEquals ( targetGuidBArr [ i ] , sourceGuidBArr [ i ] ) ; 
 + 	 	 } 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * Instantiates two guids , one with windows build - in function and one via 
 + 	 * jna and compares it . 
 + 	 * / 
 + 	 public void testBehaviourWithOle32 ( ) { 
 + 	 	 GUID ole32Guid = Ole32Util . getGUIDFromString ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; 
 + 	 	 GUID jnaGuid = new GUID ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; 
 + 
 + 	 	 assertEquals ( ole32Guid , jnaGuid ) ; 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * Test with the windows build - in function , compares the result of the 
 + 	 * methods . 
 + 	 * / 
 + 	 public void testBehaviourWithOle32 _ 2 ( ) { 
 + 	 	 GUID ole32Guid = Ole32Util 
 + 	 	 	 	 . getGUIDFromString ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; 
 + 	 	 GUID jnaGuid = new GUID ( " { A5DCBF10 - 6530 - 11D2 - 901F - 00C04FB951ED } " ) ; 
 + 
 + 	 	 String ole32Guidstr = Ole32Util . getStringFromGUID ( ole32Guid ) ; 
 + 	 	 String jnaGuidStr = jnaGuid . toGuidString ( ) ; 
 + 
 + 	 	 assertEquals ( ole32Guidstr , jnaGuidStr ) ; 
 + 	 } 
 + 
 + 	 / * * 
 + 	 * Tests the new guid with the build - in function coming with windows . 
 + 	 * / 
 + 	 public void testNewGuid ( ) { 
 + 	 	 GUID newGuid = GUID . newGuid ( ) ; 
 + 	 	 String guidString = newGuid . toGuidString ( ) ; 
 + 	 	 GUID guidFromString = Ole32Util . getGUIDFromString ( guidString ) ; 
 + 
 + 	 	 assertEquals ( guidFromString . toGuidString ( ) , guidString ) ; 
 	 } 
 }
