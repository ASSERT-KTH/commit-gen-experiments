BLEU SCORE: 0.015445276590783498

TEST MSG: A NULL pointer passed to a IntegerType based direct mapping causes JVM crash
GENERATED MSG: Replace WeakIdentityHashMap ( pure AL2 . 0 ) with custom minimal implementation

TEST DIFF (one line): diff - - git a / native / dispatch . c b / native / dispatch . c <nl> index e857206 . . cd97041 100644 <nl> - - - a / native / dispatch . c <nl> + + + b / native / dispatch . c <nl> @ @ - 1060 , 7 + 1060 , 11 @ @ get _ java _ type ( JNIEnv * env , jclass cls ) { <nl> <nl> jlong <nl> getIntegerTypeValue ( JNIEnv * env , jobject obj ) { <nl> - return ( * env ) - > GetLongField ( env , obj , FID _ IntegerType _ value ) ; <nl> + if ( obj = = NULL ) { <nl> + return 0 ; <nl> + } else { <nl> + return ( * env ) - > GetLongField ( env , obj , FID _ IntegerType _ value ) ; <nl> + } <nl> } <nl> <nl> void * <nl> diff - - git a / test / com / sun / jna / ArgumentsMarshalNullableTest . java b / test / com / sun / jna / ArgumentsMarshalNullableTest . java <nl> new file mode 100644 <nl> index 0000000 . . a55b9c5 <nl> - - - / dev / null <nl> + + + b / test / com / sun / jna / ArgumentsMarshalNullableTest . java <nl> @ @ - 0 , 0 + 1 , 227 @ @ <nl> + / * Copyright ( c ) 2018 Matthias Bl ä sing , All Rights Reserved <nl> + * <nl> + * The contents of this file is dual - licensed under 2 <nl> + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and <nl> + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . <nl> + * <nl> + * You can freely decide which license you want to apply to <nl> + * the project . <nl> + * <nl> + * You may obtain a copy of the LGPL License at : <nl> + * <nl> + * http : / / www . gnu . org / licenses / licenses . html <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " LGPL2 . 1 " . <nl> + * <nl> + * You may obtain a copy of the Apache License at : <nl> + * <nl> + * http : / / www . apache . org / licenses / <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " AL2 . 0 " . <nl> + * / <nl> + package com . sun . jna ; <nl> + <nl> + <nl> + import java . util . Collections ; <nl> + import junit . framework . TestCase ; <nl> + <nl> + / * * <nl> + * Test that all method call options for native calls work with NULL values <nl> + * and result in deterministic behaviour and not in a JVM crash . <nl> + * / <nl> + public class ArgumentsMarshalNullableTest extends TestCase { <nl> + public static class Int32Integer extends IntegerType { <nl> + <nl> + public Int32Integer ( ) { <nl> + super ( 4 ) ; <nl> + } <nl> + <nl> + public Int32Integer ( long value ) { <nl> + super ( 4 , value ) ; <nl> + } <nl> + <nl> + } <nl> + <nl> + <nl> + public static class Int32NativeMapped implements NativeMapped { <nl> + private int value ; <nl> + <nl> + public Int32NativeMapped ( ) { } ; <nl> + <nl> + public Int32NativeMapped ( int value ) { <nl> + this . value = value ; <nl> + } <nl> + <nl> + public Object fromNative ( Object nativeValue , FromNativeContext context ) { <nl> + if ( nativeValue instanceof Integer ) { <nl> + return new Int32NativeMapped ( ( Integer ) nativeValue ) ; <nl> + } else { <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + public Object toNative ( ) { <nl> + return value ; <nl> + } <nl> + <nl> + public Class < ? > nativeType ( ) { <nl> + return int . class ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) { <nl> + return " Int32NativeMapped { " + " value = " + value + ' } ' ; <nl> + } <nl> + <nl> + @ Override <nl> + public int hashCode ( ) { <nl> + int hash = 7 ; <nl> + hash = 59 * hash + this . value ; <nl> + return hash ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean equals ( Object obj ) { <nl> + if ( this = = obj ) { <nl> + return true ; <nl> + } <nl> + if ( obj = = null ) { <nl> + return false ; <nl> + } <nl> + if ( getClass ( ) ! = obj . getClass ( ) ) { <nl> + return false ; <nl> + } <nl> + final Int32NativeMapped other = ( Int32NativeMapped ) obj ; <nl> + if ( this . value ! = other . value ) { <nl> + return false ; <nl> + } <nl> + return true ; <nl> + } <nl> + } <nl> + <nl> + public static class Int32 { <nl> + public static final FromNativeConverter fromNative = new FromNativeConverter ( ) { <nl> + public Object fromNative ( Object nativeValue , FromNativeContext context ) { <nl> + if ( nativeValue instanceof Integer ) { <nl> + return new Int32 ( ( Integer ) nativeValue ) ; <nl> + } else { <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + public Class < ? > nativeType ( ) { <nl> + return int . class ; <nl> + } <nl> + } ; <nl> + <nl> + public static final ToNativeConverter toNative = new ToNativeConverter ( ) { <nl> + public Object toNative ( Object value , ToNativeContext context ) { <nl> + if ( value = = null ) { <nl> + return 0 ; <nl> + } else { <nl> + return ( ( Int32 ) value ) . value ; <nl> + } <nl> + } <nl> + <nl> + public Class < ? > nativeType ( ) { <nl> + return int . class ; <nl> + } <nl> + } ; <nl> + <nl> + private int value ; <nl> + <nl> + public Int32 ( ) { <nl> + } <nl> + <nl> + public Int32 ( int value ) { <nl> + this . value = value ; <nl> + } <nl> + <nl> + @ Override <nl> + public int hashCode ( ) { <nl> + int hash = 7 ; <nl> + hash = 53 * hash + this . value ; <nl> + return hash ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean equals ( Object obj ) { <nl> + if ( this = = obj ) { <nl> + return true ; <nl> + } <nl> + if ( obj = = null ) { <nl> + return false ; <nl> + } <nl> + if ( getClass ( ) ! = obj . getClass ( ) ) { <nl> + return false ; <nl> + } <nl> + final Int32 other = ( Int32 ) obj ; <nl> + if ( this . value ! = other . value ) { <nl> + return false ; <nl> + } <nl> + return true ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) { <nl> + return " Int32 { " + " value = " + value + ' } ' ; <nl> + } <nl> + } <nl> + <nl> + public static interface TestLibrary extends Library { <nl> + Int32NativeMapped returnInt32Argument ( Int32NativeMapped i ) ; <nl> + Int32Integer returnInt32Argument ( Int32Integer i ) ; <nl> + Int32 returnInt32Argument ( Int32 i ) ; <nl> + } <nl> + <nl> + TestLibrary lib ; <nl> + @ Override <nl> + protected void setUp ( ) { <nl> + lib = Native . loadLibrary ( " testlib " , TestLibrary . class , <nl> + Collections . singletonMap ( Library . OPTION _ TYPE _ MAPPER , new TypeMapper ( ) { <nl> + public FromNativeConverter getFromNativeConverter ( Class < ? > javaType ) { <nl> + if ( javaType = = Int32 . class ) { <nl> + return Int32 . fromNative ; <nl> + } else { <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + public ToNativeConverter getToNativeConverter ( Class < ? > javaType ) { <nl> + if ( javaType = = Int32 . class ) { <nl> + return Int32 . toNative ; <nl> + } else { <nl> + return null ; <nl> + } <nl> + } <nl> + } ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected void tearDown ( ) { <nl> + lib = null ; <nl> + } <nl> + <nl> + <nl> + public void testNativeMapped ( ) { <nl> + assertEquals ( " Basic non - null call " , new Int32NativeMapped ( 42 ) , lib . returnInt32Argument ( new Int32NativeMapped ( 42 ) ) ) ; <nl> + assertEquals ( " null call " , new Int32NativeMapped ( 0 ) , lib . returnInt32Argument ( ( Int32NativeMapped ) null ) ) ; <nl> + } <nl> + <nl> + public void testIntegerType ( ) { <nl> + assertEquals ( " Basic non - null call " , new Int32Integer ( 42 ) , lib . returnInt32Argument ( new Int32Integer ( 42 ) ) ) ; <nl> + assertEquals ( " null call " , new Int32Integer ( 0 ) , lib . returnInt32Argument ( ( Int32Integer ) null ) ) ; <nl> + } <nl> + <nl> + public void testTypeMapper ( ) { <nl> + assertEquals ( " Basic non - null call " , new Int32 ( 42 ) , lib . returnInt32Argument ( new Int32 ( 42 ) ) ) ; <nl> + assertEquals ( " null call " , new Int32 ( 0 ) , lib . returnInt32Argument ( ( Int32 ) null ) ) ; <nl> + } <nl> + <nl> + public static void main ( java . lang . String [ ] argList ) { <nl> + junit . textui . TestRunner . run ( ArgumentsMarshalNullableTest . class ) ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / test / com / sun / jna / DirectArgumentsMarshalNullableTest . java b / test / com / sun / jna / DirectArgumentsMarshalNullableTest . java <nl> new file mode 100644 <nl> index 0000000 . . bde6b42 <nl> - - - / dev / null <nl> + + + b / test / com / sun / jna / DirectArgumentsMarshalNullableTest . java <nl> @ @ - 0 , 0 + 1 , 73 @ @ <nl> + / * Copyright ( c ) 2018 Matthias Bl ä sing , All Rights Reserved <nl> + * <nl> + * The contents of this file is dual - licensed under 2 <nl> + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and <nl> + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . <nl> + * <nl> + * You can freely decide which license you want to apply to <nl> + * the project . <nl> + * <nl> + * You may obtain a copy of the LGPL License at : <nl> + * <nl> + * http : / / www . gnu . org / licenses / licenses . html <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " LGPL2 . 1 " . <nl> + * <nl> + * You may obtain a copy of the Apache License at : <nl> + * <nl> + * http : / / www . apache . org / licenses / <nl> + * <nl> + * A copy is also included in the downloadable source code package <nl> + * containing JNA , in file " AL2 . 0 " . <nl> + * / <nl> + package com . sun . jna ; <nl> + <nl> + import java . util . Collections ; <nl> + <nl> + / * * <nl> + * Variant of { @ link ArgumentsMarshalNullableTest } for direct mapped interfaces . <nl> + * / <nl> + public class DirectArgumentsMarshalNullableTest extends ArgumentsMarshalNullableTest { <nl> + <nl> + public static class DirectTestLibrary implements TestLibrary { <nl> + <nl> + public native Int32NativeMapped returnInt32Argument ( Int32NativeMapped i ) ; <nl> + <nl> + public native Int32Integer returnInt32Argument ( Int32Integer i ) ; <nl> + <nl> + public native Int32 returnInt32Argument ( Int32 i ) ; <nl> + <nl> + static { <nl> + NativeLibrary library = NativeLibrary . getInstance ( " testlib " , Collections . singletonMap ( Library . OPTION _ TYPE _ MAPPER , new TypeMapper ( ) { <nl> + public FromNativeConverter getFromNativeConverter ( Class < ? > javaType ) { <nl> + if ( javaType = = Int32 . class ) { <nl> + return Int32 . fromNative ; <nl> + } else { <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + public ToNativeConverter getToNativeConverter ( Class < ? > javaType ) { <nl> + if ( javaType = = Int32 . class ) { <nl> + return Int32 . toNative ; <nl> + } else { <nl> + return null ; <nl> + } <nl> + } <nl> + } ) ) ; <nl> + Native . register ( library ) ; <nl> + } <nl> + } <nl> + <nl> + / * Override original . * / <nl> + @ Override <nl> + protected void setUp ( ) { <nl> + lib = new DirectTestLibrary ( ) ; <nl> + } <nl> + <nl> + public static void main ( java . lang . String [ ] argList ) { <nl> + junit . textui . TestRunner . run ( DirectArgumentsMarshalNullableTest . class ) ; <nl> + } <nl> + <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / native / dispatch . c b / native / dispatch . c 
 index e857206 . . cd97041 100644 
 - - - a / native / dispatch . c 
 + + + b / native / dispatch . c 
 @ @ - 1060 , 7 + 1060 , 11 @ @ get _ java _ type ( JNIEnv * env , jclass cls ) { 
 
 jlong 
 getIntegerTypeValue ( JNIEnv * env , jobject obj ) { 
 - return ( * env ) - > GetLongField ( env , obj , FID _ IntegerType _ value ) ; 
 + if ( obj = = NULL ) { 
 + return 0 ; 
 + } else { 
 + return ( * env ) - > GetLongField ( env , obj , FID _ IntegerType _ value ) ; 
 + } 
 } 
 
 void * 
 diff - - git a / test / com / sun / jna / ArgumentsMarshalNullableTest . java b / test / com / sun / jna / ArgumentsMarshalNullableTest . java 
 new file mode 100644 
 index 0000000 . . a55b9c5 
 - - - / dev / null 
 + + + b / test / com / sun / jna / ArgumentsMarshalNullableTest . java 
 @ @ - 0 , 0 + 1 , 227 @ @ 
 + / * Copyright ( c ) 2018 Matthias Bl ä sing , All Rights Reserved 
 + * 
 + * The contents of this file is dual - licensed under 2 
 + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and 
 + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . 
 + * 
 + * You can freely decide which license you want to apply to 
 + * the project . 
 + * 
 + * You may obtain a copy of the LGPL License at : 
 + * 
 + * http : / / www . gnu . org / licenses / licenses . html 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " LGPL2 . 1 " . 
 + * 
 + * You may obtain a copy of the Apache License at : 
 + * 
 + * http : / / www . apache . org / licenses / 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " AL2 . 0 " . 
 + * / 
 + package com . sun . jna ; 
 + 
 + 
 + import java . util . Collections ; 
 + import junit . framework . TestCase ; 
 + 
 + / * * 
 + * Test that all method call options for native calls work with NULL values 
 + * and result in deterministic behaviour and not in a JVM crash . 
 + * / 
 + public class ArgumentsMarshalNullableTest extends TestCase { 
 + public static class Int32Integer extends IntegerType { 
 + 
 + public Int32Integer ( ) { 
 + super ( 4 ) ; 
 + } 
 + 
 + public Int32Integer ( long value ) { 
 + super ( 4 , value ) ; 
 + } 
 + 
 + } 
 + 
 + 
 + public static class Int32NativeMapped implements NativeMapped { 
 + private int value ; 
 + 
 + public Int32NativeMapped ( ) { } ; 
 + 
 + public Int32NativeMapped ( int value ) { 
 + this . value = value ; 
 + } 
 + 
 + public Object fromNative ( Object nativeValue , FromNativeContext context ) { 
 + if ( nativeValue instanceof Integer ) { 
 + return new Int32NativeMapped ( ( Integer ) nativeValue ) ; 
 + } else { 
 + return null ; 
 + } 
 + } 
 + 
 + public Object toNative ( ) { 
 + return value ; 
 + } 
 + 
 + public Class < ? > nativeType ( ) { 
 + return int . class ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) { 
 + return " Int32NativeMapped { " + " value = " + value + ' } ' ; 
 + } 
 + 
 + @ Override 
 + public int hashCode ( ) { 
 + int hash = 7 ; 
 + hash = 59 * hash + this . value ; 
 + return hash ; 
 + } 
 + 
 + @ Override 
 + public boolean equals ( Object obj ) { 
 + if ( this = = obj ) { 
 + return true ; 
 + } 
 + if ( obj = = null ) { 
 + return false ; 
 + } 
 + if ( getClass ( ) ! = obj . getClass ( ) ) { 
 + return false ; 
 + } 
 + final Int32NativeMapped other = ( Int32NativeMapped ) obj ; 
 + if ( this . value ! = other . value ) { 
 + return false ; 
 + } 
 + return true ; 
 + } 
 + } 
 + 
 + public static class Int32 { 
 + public static final FromNativeConverter fromNative = new FromNativeConverter ( ) { 
 + public Object fromNative ( Object nativeValue , FromNativeContext context ) { 
 + if ( nativeValue instanceof Integer ) { 
 + return new Int32 ( ( Integer ) nativeValue ) ; 
 + } else { 
 + return null ; 
 + } 
 + } 
 + 
 + public Class < ? > nativeType ( ) { 
 + return int . class ; 
 + } 
 + } ; 
 + 
 + public static final ToNativeConverter toNative = new ToNativeConverter ( ) { 
 + public Object toNative ( Object value , ToNativeContext context ) { 
 + if ( value = = null ) { 
 + return 0 ; 
 + } else { 
 + return ( ( Int32 ) value ) . value ; 
 + } 
 + } 
 + 
 + public Class < ? > nativeType ( ) { 
 + return int . class ; 
 + } 
 + } ; 
 + 
 + private int value ; 
 + 
 + public Int32 ( ) { 
 + } 
 + 
 + public Int32 ( int value ) { 
 + this . value = value ; 
 + } 
 + 
 + @ Override 
 + public int hashCode ( ) { 
 + int hash = 7 ; 
 + hash = 53 * hash + this . value ; 
 + return hash ; 
 + } 
 + 
 + @ Override 
 + public boolean equals ( Object obj ) { 
 + if ( this = = obj ) { 
 + return true ; 
 + } 
 + if ( obj = = null ) { 
 + return false ; 
 + } 
 + if ( getClass ( ) ! = obj . getClass ( ) ) { 
 + return false ; 
 + } 
 + final Int32 other = ( Int32 ) obj ; 
 + if ( this . value ! = other . value ) { 
 + return false ; 
 + } 
 + return true ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) { 
 + return " Int32 { " + " value = " + value + ' } ' ; 
 + } 
 + } 
 + 
 + public static interface TestLibrary extends Library { 
 + Int32NativeMapped returnInt32Argument ( Int32NativeMapped i ) ; 
 + Int32Integer returnInt32Argument ( Int32Integer i ) ; 
 + Int32 returnInt32Argument ( Int32 i ) ; 
 + } 
 + 
 + TestLibrary lib ; 
 + @ Override 
 + protected void setUp ( ) { 
 + lib = Native . loadLibrary ( " testlib " , TestLibrary . class , 
 + Collections . singletonMap ( Library . OPTION _ TYPE _ MAPPER , new TypeMapper ( ) { 
 + public FromNativeConverter getFromNativeConverter ( Class < ? > javaType ) { 
 + if ( javaType = = Int32 . class ) { 
 + return Int32 . fromNative ; 
 + } else { 
 + return null ; 
 + } 
 + } 
 + 
 + public ToNativeConverter getToNativeConverter ( Class < ? > javaType ) { 
 + if ( javaType = = Int32 . class ) { 
 + return Int32 . toNative ; 
 + } else { 
 + return null ; 
 + } 
 + } 
 + } ) ) ; 
 + } 
 + 
 + @ Override 
 + protected void tearDown ( ) { 
 + lib = null ; 
 + } 
 + 
 + 
 + public void testNativeMapped ( ) { 
 + assertEquals ( " Basic non - null call " , new Int32NativeMapped ( 42 ) , lib . returnInt32Argument ( new Int32NativeMapped ( 42 ) ) ) ; 
 + assertEquals ( " null call " , new Int32NativeMapped ( 0 ) , lib . returnInt32Argument ( ( Int32NativeMapped ) null ) ) ; 
 + } 
 + 
 + public void testIntegerType ( ) { 
 + assertEquals ( " Basic non - null call " , new Int32Integer ( 42 ) , lib . returnInt32Argument ( new Int32Integer ( 42 ) ) ) ; 
 + assertEquals ( " null call " , new Int32Integer ( 0 ) , lib . returnInt32Argument ( ( Int32Integer ) null ) ) ; 
 + } 
 + 
 + public void testTypeMapper ( ) { 
 + assertEquals ( " Basic non - null call " , new Int32 ( 42 ) , lib . returnInt32Argument ( new Int32 ( 42 ) ) ) ; 
 + assertEquals ( " null call " , new Int32 ( 0 ) , lib . returnInt32Argument ( ( Int32 ) null ) ) ; 
 + } 
 + 
 + public static void main ( java . lang . String [ ] argList ) { 
 + junit . textui . TestRunner . run ( ArgumentsMarshalNullableTest . class ) ; 
 + } 
 + 
 + } 
 diff - - git a / test / com / sun / jna / DirectArgumentsMarshalNullableTest . java b / test / com / sun / jna / DirectArgumentsMarshalNullableTest . java 
 new file mode 100644 
 index 0000000 . . bde6b42 
 - - - / dev / null 
 + + + b / test / com / sun / jna / DirectArgumentsMarshalNullableTest . java 
 @ @ - 0 , 0 + 1 , 73 @ @ 
 + / * Copyright ( c ) 2018 Matthias Bl ä sing , All Rights Reserved 
 + * 
 + * The contents of this file is dual - licensed under 2 
 + * alternative Open Source / Free licenses : LGPL 2 . 1 or later and 
 + * Apache License 2 . 0 . ( starting with JNA version 4 . 0 . 0 ) . 
 + * 
 + * You can freely decide which license you want to apply to 
 + * the project . 
 + * 
 + * You may obtain a copy of the LGPL License at : 
 + * 
 + * http : / / www . gnu . org / licenses / licenses . html 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " LGPL2 . 1 " . 
 + * 
 + * You may obtain a copy of the Apache License at : 
 + * 
 + * http : / / www . apache . org / licenses / 
 + * 
 + * A copy is also included in the downloadable source code package 
 + * containing JNA , in file " AL2 . 0 " . 
 + * / 
 + package com . sun . jna ; 
 + 
 + import java . util . Collections ; 
 + 
 + / * * 
 + * Variant of { @ link ArgumentsMarshalNullableTest } for direct mapped interfaces . 
 + * / 
 + public class DirectArgumentsMarshalNullableTest extends ArgumentsMarshalNullableTest { 
 + 
 + public static class DirectTestLibrary implements TestLibrary { 
 + 
 + public native Int32NativeMapped returnInt32Argument ( Int32NativeMapped i ) ; 
 + 
 + public native Int32Integer returnInt32Argument ( Int32Integer i ) ; 
 + 
 + public native Int32 returnInt32Argument ( Int32 i ) ; 
 + 
 + static { 
 + NativeLibrary library = NativeLibrary . getInstance ( " testlib " , Collections . singletonMap ( Library . OPTION _ TYPE _ MAPPER , new TypeMapper ( ) { 
 + public FromNativeConverter getFromNativeConverter ( Class < ? > javaType ) { 
 + if ( javaType = = Int32 . class ) { 
 + return Int32 . fromNative ; 
 + } else { 
 + return null ; 
 + } 
 + } 
 + 
 + public ToNativeConverter getToNativeConverter ( Class < ? > javaType ) { 
 + if ( javaType = = Int32 . class ) { 
 + return Int32 . toNative ; 
 + } else { 
 + return null ; 
 + } 
 + } 
 + } ) ) ; 
 + Native . register ( library ) ; 
 + } 
 + } 
 + 
 + / * Override original . * / 
 + @ Override 
 + protected void setUp ( ) { 
 + lib = new DirectTestLibrary ( ) ; 
 + } 
 + 
 + public static void main ( java . lang . String [ ] argList ) { 
 + junit . textui . TestRunner . run ( DirectArgumentsMarshalNullableTest . class ) ; 
 + } 
 + 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
