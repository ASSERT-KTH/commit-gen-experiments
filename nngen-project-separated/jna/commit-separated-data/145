BLEU SCORE: 0.0011392542366888657

TEST MSG: Added functions to Advapi32
GENERATED MSG: Add platform . win32 . Kernel32 . DeleteFile and com . sun . jna . platform . win32 . deleteFile .

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> index dd2c300 . . f18ea17 100755 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> @ @ - 43 , 6 + 43 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; <nl> import com . sun . jna . platform . win32 . WinNT . PSID ; <nl> import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; <nl> import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR ; <nl> + import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR _ RELATIVE ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEY ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> import com . sun . jna . platform . win32 . Winsvc . ChangeServiceConfig2Info ; <nl> @ @ - 313 , 6 + 314 , 94 @ @ public interface Advapi32 extends StdCallLibrary { <nl> boolean InitializeSecurityDescriptor ( SECURITY _ DESCRIPTOR pSecurityDescriptor , int dwRevision ) ; <nl> <nl> / * * <nl> + * The GetSecurityDescriptorControl function retrieves a security descriptor control and revision information . <nl> + * @ param pSecurityDescriptor <nl> + * A pointer to a SECURITY _ DESCRIPTOR structure whose control and revision <nl> + * information the function retrieves . <nl> + * @ param pControl <nl> + * A pointer to a SECURITY _ DESCRIPTOR _ CONTROL structure that receives the security descriptor ' s <nl> + * control information . <nl> + * @ param lpdwRevision <nl> + * A pointer to a variable that receives the security descriptor ' s revision value . <nl> + * This value is always set , even when GetSecurityDescriptorControl returns an error . <nl> + * @ return If the function succeeds , the return value is nonzero . If the <nl> + * function fails , the return value is zero . For extended error <nl> + * information , call GetLastError . <nl> + * / <nl> + boolean GetSecurityDescriptorControl ( SECURITY _ DESCRIPTOR pSecurityDescriptor , IntByReference pControl , IntByReference lpdwRevision ) ; <nl> + <nl> + / * * <nl> + * The SetSecurityDescriptorControl function sets the control bits of a security descriptor . The function can set only the control <nl> + * bits that relate to automatic inheritance of ACEs . To set the other control bits of a security descriptor , use the functions , <nl> + * such as SetSecurityDescriptorDacl , for modifying the components of a security descriptor . <nl> + * @ param pSecurityDescriptor <nl> + * A pointer to a SECURITY _ DESCRIPTOR structure whose control and revision information are set . <nl> + * @ param ControlBitsOfInterest <nl> + * A SECURITY _ DESCRIPTOR _ CONTROL mask that indicates the control bits to set . <nl> + * @ param ControlBitsToSet <nl> + * SECURITY _ DESCRIPTOR _ CONTROL mask that indicates the new values for the control bits specified by the ControlBitsOfInterest mask . <nl> + * @ return If the function succeeds , the return value is nonzero . If the <nl> + * function fails , the return value is zero . For extended error <nl> + * information , call GetLastError . <nl> + * / <nl> + boolean SetSecurityDescriptorControl ( SECURITY _ DESCRIPTOR pSecurityDescriptor , int ControlBitsOfInterest , int ControlBitsToSet ) ; <nl> + <nl> + / * * <nl> + * The SetSecurityDescriptorDacl function sets information in a discretionary access control list ( DACL ) . <nl> + * If a DACL is already present in the security descriptor , the DACL is replaced . <nl> + * @ param pSecurityDescriptor <nl> + * A pointer to the SECURITY _ DESCRIPTOR structure to which the function adds the DACL . This <nl> + * security descriptor must be in absolute format , meaning that its members must be pointers <nl> + * to other structures , rather than offsets to contiguous data . <nl> + * @ param bDaclPresent <nl> + * A flag that indicates the presence of a DACL in the security descriptor . If this parameter <nl> + * is TRUE , the function sets the SE _ DACL _ PRESENT flag in the SECURITY _ DESCRIPTOR _ CONTROL <nl> + * structure and uses the values in the pDacl and bDaclDefaulted parameters . If this parameter <nl> + * is FALSE , the function clears the SE _ DACL _ PRESENT flag , and pDacl and bDaclDefaulted are ignored . <nl> + * @ param pAcl <nl> + * A pointer to an ACL structure that specifies the DACL for the security descriptor . If this <nl> + * parameter is NULL , a NULL DACL is assigned to the security descriptor , which allows all access <nl> + * to the object . The DACL is referenced by , not copied into , the security descriptor . <nl> + * @ param bDaclDefaulted <nl> + * A flag that indicates the source of the DACL . If this flag is TRUE , the DACL has been retrieved <nl> + * by some default mechanism . If FALSE , the DACL has been explicitly specified by a user . The function <nl> + * stores this value in the SE _ DACL _ DEFAULTED flag of the SECURITY _ DESCRIPTOR _ CONTROL structure . If <nl> + * this parameter is not specified , the SE _ DACL _ DEFAULTED flag is cleared . <nl> + * @ return If the function succeeds , the return value is nonzero . If the <nl> + * function fails , the return value is zero . For extended error <nl> + * information , call GetLastError . <nl> + * / <nl> + boolean SetSecurityDescriptorDacl ( SECURITY _ DESCRIPTOR pSecurityDescriptor , boolean bDaclPresent , ACL pDacl , boolean bDaclDefaulted ) ; <nl> + <nl> + / * * <nl> + * The GetSecurityDescriptorDacl function retrieves a pointer to the discretionary access control list ( DACL ) in <nl> + * a specified security descriptor . <nl> + * @ param pSecurityDescriptor <nl> + * A pointer to the SECURITY _ DESCRIPTOR structure that contains the DACL . The function retrieves a pointer to it . <nl> + * @ param bDaclPresent <nl> + * A pointer to a value that indicates the presence of a DACL in the specified security descriptor . If <nl> + * lpbDaclPresent is TRUE , the security descriptor contains a DACL , and the remaining output parameters in this <nl> + * function receive valid values . If lpbDaclPresent is FALSE , the security descriptor does not contain a DACL , <nl> + * and the remaining output parameters do not receive valid values . A value of TRUE for lpbDaclPresent does not <nl> + * mean that pDacl is not NULL . That is , lpbDaclPresent can be TRUE while pDacl is NULL , meaning that a NULL <nl> + * DACL is in effect . A NULL DACL implicitly allows all access to an object and is not the same as an empty DACL . <nl> + * An empty DACL permits no access to an object . For information about creating a proper DACL , see Creating a DACL . <nl> + * @ param pDacl <nl> + * A pointer to a pointer to an access control list ( ACL ) . If a DACL exists , the function sets the pointer pointed <nl> + * to by pDacl to the address of the security descriptor ' s DACL . If a DACL does not exist , no value is stored . <nl> + * If the function stores a NULL value in the pointer pointed to by pDacl , the security descriptor has a NULL DACL . <nl> + * A NULL DACL implicitly allows all access to an object . <nl> + * If an application expects a non - NULL DACL but encounters a NULL DACL , the application should fail securely and <nl> + * not allow access . <nl> + * @ param bDaclDefaulted <nl> + * A pointer to a flag set to the value of the SE _ DACL _ DEFAULTED flag in the SECURITY _ DESCRIPTOR _ CONTROL structure <nl> + * if a DACL exists for the security descriptor . If this flag is TRUE , the DACL was retrieved by a default mechanism ; <nl> + * if FALSE , the DACL was explicitly specified by a user . <nl> + * @ return <nl> + * / <nl> + boolean GetSecurityDescriptorDacl ( SECURITY _ DESCRIPTOR pSecurityDescriptor , BOOLByReference bDaclPresent , PointerByReference pDacl , BOOLByReference bDaclDefaulted ) ; <nl> + <nl> + / * * <nl> * The InitializeAcl function initializes a new ACL structure . <nl> * @ param pAcl <nl> * A pointer to an ACL structure to be initialized by this function . <nl> @ @ - 2073 , 6 + 2162 , 85 @ @ public interface Advapi32 extends StdCallLibrary { <nl> boolean IsValidSecurityDescriptor ( Pointer ppSecurityDescriptor ) ; <nl> <nl> / * * <nl> + * A pointer to a SECURITY _ DESCRIPTOR structure in absolute format . The function creates a version of this security <nl> + * descriptor in self - relative format without modifying the original . <nl> + * @ param pAbsoluteSD <nl> + * A pointer to a SECURITY _ DESCRIPTOR structure in absolute format . The function creates a version of this <nl> + * security descriptor in self - relative format without modifying the original . <nl> + * @ param pSelfRelativeSD <nl> + * A pointer to a buffer the function fills with a security descriptor in self - relative format . <nl> + * @ param lpdwBufferLength <nl> + * A pointer to a variable specifying the size of the buffer pointed to by the pSelfRelativeSD parameter . <nl> + * If the buffer is not large enough for the security descriptor , the function fails and sets this variable <nl> + * to the minimum required size . <nl> + * @ return If the function succeeds , the function returns nonzero . If the function fails , it returns zero . To get <nl> + * extended error information , call GetLastError . Possible return codes include , but are not limited to , the following : <nl> + * ERROR _ INSUFFICIENT _ BUFFER - One or more of the buffers is too small . <nl> + * / <nl> + boolean MakeSelfRelativeSD ( SECURITY _ DESCRIPTOR pAbsoluteSD , <nl> + SECURITY _ DESCRIPTOR _ RELATIVE pSelfRelativeSD , <nl> + IntByReference lpdwBufferLength ) ; <nl> + <nl> + / * * <nl> + * The MakeAbsoluteSD function creates a security descriptor in absolute format by using a <nl> + * security descriptor in self - relative format as a template . <nl> + * @ param pSelfRelativeSD <nl> + * A pointer to a SECURITY _ DESCRIPTOR structure in self - relative format . The function creates an <nl> + * absolute - format version of this security descriptor without modifying the original security descriptor . <nl> + * @ param pAbsoluteSD <nl> + * A pointer to a buffer that the function fills with the main body of an absolute - format security <nl> + * descriptor . This information is formatted as a SECURITY _ DESCRIPTOR structure . <nl> + * @ param lpdwAbsoluteSDSize <nl> + * A pointer to a variable that specifies the size of the buffer pointed to by the pAbsoluteSD parameter . <nl> + * If the buffer is not large enough for the security descriptor , the function fails and sets this variable <nl> + * to the minimum required size . <nl> + * @ param pDacl <nl> + * A pointer to a buffer the function fills with the discretionary access control list ( DACL ) of the <nl> + * absolute - format security descriptor . The main body of the absolute - format security descriptor references <nl> + * this pointer . <nl> + * @ param lpdwDaclSize <nl> + * A pointer to a variable that specifies the size of the buffer pointed to by the pDacl parameter . If <nl> + * the buffer is not large enough for the access control list ( ACL ) , the function fails and sets this <nl> + * variable to the minimum required size . <nl> + * @ param pSacl <nl> + * A pointer to a buffer the function fills with the system access control list ( SACL ) of the absolute - format <nl> + * security descriptor . The main body of the absolute - format security descriptor references this pointer . <nl> + * @ param lpdwSaclSize <nl> + * A pointer to a variable that specifies the size of the buffer pointed to by the pSacl parameter . If the <nl> + * buffer is not large enough for the ACL , the function fails and sets this variable to the minimum required <nl> + * size . <nl> + * @ param pOwner <nl> + * A pointer to a buffer the function fills with the security identifier ( SID ) of the owner of the <nl> + * absolute - format security descriptor . The main body of the absolute - format security descriptor references <nl> + * this pointer . <nl> + * @ param lpdwOwnerSize <nl> + * A pointer to a variable that specifies the size of the buffer pointed to by the pOwner parameter . <nl> + * If the buffer is not large enough for the SID , the function fails and sets this variable to the minimum <nl> + * required size . <nl> + * @ param pPrimaryGroup <nl> + * A pointer to a buffer the function fills with the SID of the absolute - format security descriptor ' s <nl> + * primary group . The main body of the absolute - format security descriptor references this pointer . <nl> + * @ param lpdwPrimaryGroupSize <nl> + * A pointer to a variable that specifies the size of the buffer pointed to by the pPrimaryGroup parameter . <nl> + * If the buffer is not large enough for the SID , the function fails and sets this variable to the minimum <nl> + * required size . <nl> + * @ return If the function succeeds , the function returns nonzero . If the function fails , it returns zero . To get <nl> + * extended error information , call GetLastError . Possible return codes include , but are not limited to , the following : <nl> + * ERROR _ INSUFFICIENT _ BUFFER - One or more of the buffers is too small . <nl> + * / <nl> + boolean MakeAbsoluteSD ( SECURITY _ DESCRIPTOR _ RELATIVE pSelfRelativeSD , <nl> + SECURITY _ DESCRIPTOR pAbsoluteSD , <nl> + IntByReference lpdwAbsoluteSDSize , <nl> + ACL pDacl , <nl> + IntByReference lpdwDaclSize , <nl> + ACL pSacl , <nl> + IntByReference lpdwSaclSize , <nl> + PSID pOwner , <nl> + IntByReference lpdwOwnerSize , <nl> + PSID pPrimaryGroup , <nl> + IntByReference lpdwPrimaryGroupSize ) ; <nl> + <nl> + / * * <nl> * The IsValidAcl function validates an access control list ( ACL ) . <nl> * <nl> * @ param pAcl [ in ] <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> index b09124c . . 51000ab 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> @ @ - 2486 , 6 + 2486 , 7 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> } <nl> <nl> public SECURITY _ DESCRIPTOR ( byte [ ] data ) { <nl> + super ( ) ; <nl> this . data = data ; <nl> useMemory ( new Memory ( data . length ) ) ; <nl> } <nl> @ @ - 2522 , 6 + 2523 , 12 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> public static class ACL extends Structure { <nl> public static final List < String > FIELDS = createFieldsOrder ( " AclRevision " , " Sbz1 " , " AclSize " , " AceCount " , " Sbz2 " ) ; <nl> <nl> + / * <nl> + * Maximum size chosen based on technet article : <nl> + * https : / / technet . microsoft . com / en - us / library / cc781716 . aspx <nl> + * / <nl> + public static int MAX _ ACL _ SIZE = 64 * 1024 ; <nl> + <nl> public byte AclRevision ; <nl> public byte Sbz1 ; <nl> public short AclSize ; <nl> @ @ - 2589 , 10 + 2596 , 10 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> public int Sacl ; <nl> public int Dacl ; <nl> <nl> - private ACL DACL ; <nl> private PSID OWNER ; <nl> private PSID GROUP ; <nl> private ACL SACL ; <nl> + private ACL DACL ; <nl> <nl> public SECURITY _ DESCRIPTOR _ RELATIVE ( ) { <nl> super ( ) ; <nl> @ @ - 2604 , 6 + 2611 , 10 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> setMembers ( ) ; <nl> } <nl> <nl> + public SECURITY _ DESCRIPTOR _ RELATIVE ( int length ) { <nl> + super ( new Memory ( length ) ) ; <nl> + } <nl> + <nl> public SECURITY _ DESCRIPTOR _ RELATIVE ( Pointer p ) { <nl> super ( p ) ; <nl> setMembers ( ) ; <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> index 78810d3 . . 9df9a5c 100755 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> @ @ - 50 , 12 + 50 , 12 @ @ import com . sun . jna . platform . win32 . WinBase . FE _ IMPORT _ FUNC ; <nl> import com . sun . jna . platform . win32 . WinBase . FILETIME ; <nl> import com . sun . jna . platform . win32 . WinBase . PROCESS _ INFORMATION ; <nl> import com . sun . jna . platform . win32 . WinBase . STARTUPINFO ; <nl> + import com . sun . jna . platform . win32 . WinDef . BOOL ; <nl> import com . sun . jna . platform . win32 . WinDef . BOOLByReference ; <nl> import com . sun . jna . platform . win32 . WinDef . DWORD ; <nl> import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; <nl> import com . sun . jna . platform . win32 . WinDef . ULONG ; <nl> import com . sun . jna . platform . win32 . WinDef . ULONGByReference ; <nl> - import com . sun . jna . platform . win32 . WinNT . ACCESS _ ACEStructure ; <nl> import com . sun . jna . platform . win32 . WinNT . ACCESS _ ALLOWED _ ACE ; <nl> import com . sun . jna . platform . win32 . WinNT . ACL ; <nl> import com . sun . jna . platform . win32 . WinNT . EVENTLOGRECORD ; <nl> @ @ - 66 , 6 + 66 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; <nl> import com . sun . jna . platform . win32 . WinNT . PSID ; <nl> import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; <nl> import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR ; <nl> + import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR _ RELATIVE ; <nl> import com . sun . jna . platform . win32 . WinNT . SECURITY _ IMPERSONATION _ LEVEL ; <nl> import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; <nl> import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; <nl> @ @ - 700 , 6 + 701 , 48 @ @ public class Advapi32Test extends TestCase { <nl> assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( sd , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; <nl> } <nl> <nl> + public void testSetGetSecurityDescriptorControl ( ) { <nl> + SECURITY _ DESCRIPTOR sd = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( sd , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . SetSecurityDescriptorControl ( sd , WinNT . SE _ DACL _ PROTECTED , WinNT . SE _ DACL _ PROTECTED ) ) ; <nl> + IntByReference pControl = new IntByReference ( ) ; <nl> + IntByReference lpdwRevision = new IntByReference ( ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . GetSecurityDescriptorControl ( sd , pControl , lpdwRevision ) ) ; <nl> + assertTrue ( pControl . getValue ( ) = = WinNT . SE _ DACL _ PROTECTED ) ; <nl> + assertTrue ( lpdwRevision . getValue ( ) = = WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ; <nl> + } <nl> + <nl> + public void testSetGetSecurityDescriptorDacl ( ) throws IOException { <nl> + SECURITY _ DESCRIPTOR sd = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( sd , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; <nl> + <nl> + ACL pAcl ; <nl> + int cbAcl = 0 ; <nl> + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + assertTrue ( " Failed to create well - known SID " , <nl> + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; <nl> + <nl> + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; <nl> + cbAcl = Native . getNativeSize ( ACL . class , null ) ; <nl> + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; <nl> + cbAcl + = ( sidLength - DWORD . SIZE ) ; <nl> + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; <nl> + pAcl = new ACL ( cbAcl ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . AddAccessAllowedAce ( pAcl , WinNT . ACL _ REVISION , WinNT . STANDARD _ RIGHTS _ ALL , pSid ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . SetSecurityDescriptorDacl ( sd , true , pAcl , false ) ) ; <nl> + BOOLByReference lpbDaclPresent = new BOOLByReference ( ) ; <nl> + BOOLByReference lpbDaclDefaulted = new BOOLByReference ( ) ; <nl> + PointerByReference pDacl = new PointerByReference ( ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . GetSecurityDescriptorDacl ( sd , lpbDaclPresent , pDacl , lpbDaclDefaulted ) ) ; <nl> + ACL pAclGet = new ACL ( pDacl . getValue ( ) ) ; <nl> + assertEquals ( new BOOL ( true ) , lpbDaclPresent . getValue ( ) ) ; <nl> + assertEquals ( new BOOL ( false ) , lpbDaclDefaulted . getValue ( ) ) ; <nl> + assertEquals ( 1 , pAclGet . AceCount ) ; <nl> + assertEquals ( WinNT . ACL _ REVISION , pAclGet . AclRevision ) ; <nl> + } <nl> + <nl> public void testInitializeAcl ( ) throws IOException { <nl> ACL pAcl ; <nl> int cbAcl = 0 ; <nl> @ @ - 1659 , 6 + 1702 , 60 @ @ public class Advapi32Test extends TestCase { <nl> } <nl> } <nl> <nl> + public void testMakeSelfRelativeSD ( ) { <nl> + SECURITY _ DESCRIPTOR absolute = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( absolute , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; <nl> + SECURITY _ DESCRIPTOR _ RELATIVE relative = new SECURITY _ DESCRIPTOR _ RELATIVE ( 64 * 1024 ) ; <nl> + IntByReference lpdwBufferLength = new IntByReference ( 64 * 1024 ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . MakeSelfRelativeSD ( absolute , relative , lpdwBufferLength ) ) ; <nl> + assertEquals ( WinNT . SECURITY _ DESCRIPTOR _ REVISION , relative . Revision ) ; <nl> + } <nl> + <nl> + public void testMakeAbsoluteSD ( ) throws Exception { <nl> + SECURITY _ DESCRIPTOR absolute = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; <nl> + <nl> + / / Get a SD in self relative form <nl> + int infoType = OWNER _ SECURITY _ INFORMATION <nl> + | GROUP _ SECURITY _ INFORMATION <nl> + | DACL _ SECURITY _ INFORMATION ; <nl> + <nl> + PointerByReference relativeByReference = new PointerByReference ( ) ; <nl> + File file = createTempFile ( ) ; <nl> + try { <nl> + try { <nl> + assertEquals ( " GetNamedSecurityInfo ( " + file + " ) " , <nl> + Advapi32 . INSTANCE . GetNamedSecurityInfo ( <nl> + file . getAbsolutePath ( ) , <nl> + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , <nl> + infoType , <nl> + null , <nl> + null , <nl> + null , <nl> + null , <nl> + relativeByReference ) , 0 ) ; <nl> + <nl> + SECURITY _ DESCRIPTOR _ RELATIVE relative = new SECURITY _ DESCRIPTOR _ RELATIVE ( relativeByReference . getValue ( ) ) ; <nl> + <nl> + PSID pOwner = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + PSID pGroup = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + ACL pDacl = new ACL ( ACL . MAX _ ACL _ SIZE ) ; <nl> + ACL pSacl = new ACL ( ACL . MAX _ ACL _ SIZE ) ; <nl> + <nl> + IntByReference lpdwBufferLength = new IntByReference ( absolute . size ( ) ) ; <nl> + IntByReference lpdwDaclSize = new IntByReference ( ACL . MAX _ ACL _ SIZE ) ; <nl> + IntByReference lpdwSaclSize = new IntByReference ( ACL . MAX _ ACL _ SIZE ) ; <nl> + IntByReference lpdwOwnerSize = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + IntByReference lpdwPrimaryGroupSize = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + <nl> + assertTrue ( Advapi32 . INSTANCE . MakeAbsoluteSD ( relative , absolute , lpdwBufferLength , pDacl , lpdwDaclSize , pSacl , lpdwSaclSize , pOwner , lpdwOwnerSize , pGroup , lpdwPrimaryGroupSize ) ) ; <nl> + } finally { <nl> + file . delete ( ) ; <nl> + } <nl> + } finally { <nl> + Kernel32Util . freeLocalMemory ( relativeByReference . getValue ( ) ) ; <nl> + } <nl> + } <nl> + <nl> public void testMapGenericReadMask ( ) { <nl> final GENERIC _ MAPPING mapping = new GENERIC _ MAPPING ( ) ; <nl> mapping . genericRead = new DWORD ( FILE _ GENERIC _ READ ) ;
NEAREST DIFF (one line): diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c <nl> index 383d49f . . b3450f8 100644 <nl> - - - a / jnalib / native / dispatch . c <nl> + + + b / jnalib / native / dispatch . c <nl> @ @ - 992 , 7 + 992 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1write _ _ J _ 3SII <nl> * Signature : ( JB ) J <nl> * / <nl> JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1indexOf _ _ JB <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> { <nl> jbyte * peer = ( jbyte * ) L2A ( addr ) ; <nl> volatile jlong i = 0 ; <nl> @ @ - 1103 , 7 + 1103 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1read _ _ J _ 3SII <nl> * Signature : ( J ) B <nl> * / <nl> JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jbyte res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1116 , 7 + 1116 , 7 @ @ JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte <nl> * Signature : ( J ) C <nl> * / <nl> JNIEXPORT jchar JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getChar <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> wchar _ t res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1153 , 7 + 1153 , 7 @ @ JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDirectByteBuffer <nl> * Signature : ( J ) D <nl> * / <nl> JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jdouble res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1166 , 7 + 1166 , 7 @ @ JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble <nl> * Signature : ( J ) F <nl> * / <nl> JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jfloat res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1179 , 7 + 1179 , 7 @ @ JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat <nl> * Signature : ( J ) I <nl> * / <nl> JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jint res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1192 , 7 + 1192 , 7 @ @ JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt <nl> * Signature : ( J ) J <nl> * / <nl> JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jlong res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1205 , 7 + 1205 , 7 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong <nl> * Signature : ( J ) S <nl> * / <nl> JNIEXPORT jshort JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getShort <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jshort res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1229 , 7 + 1229 , 7 @ @ JNIEXPORT jstring JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getString <nl> * Signature : ( JJB ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) <nl> { <nl> MEMSET ( L2A ( addr ) , ( int ) value , ( size _ t ) count ) ; <nl> } <nl> @ @ - 1240 , 7 + 1240 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory <nl> * Signature : ( JB ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1251 , 7 + 1251 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte <nl> * Signature : ( JC ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jchar value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jchar value ) <nl> { <nl> wchar _ t ch = value ; <nl> MEMCPY ( L2A ( addr ) , & ch , sizeof ( ch ) ) ; <nl> @ @ - 1263 , 7 + 1263 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar <nl> * Signature : ( JJ ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> { <nl> void * ptr = L2A ( value ) ; <nl> MEMCPY ( L2A ( addr ) , & ptr , sizeof ( void * ) ) ; <nl> @ @ - 1275 , 7 + 1275 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer <nl> * Signature : ( JD ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jdouble value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jdouble value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1286 , 7 + 1286 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble <nl> * Signature : ( JF ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jfloat value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jfloat value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1297 , 7 + 1297 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat <nl> * Signature : ( JI ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jint value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jint value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1308 , 7 + 1308 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt <nl> * Signature : ( JJ ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1319 , 7 + 1319 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong <nl> * Signature : ( JS ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setShort <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jshort value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jshort value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> }

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 index dd2c300 . . f18ea17 100755 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 @ @ - 43 , 6 + 43 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; 
 import com . sun . jna . platform . win32 . WinNT . PSID ; 
 import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; 
 import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR ; 
 + import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR _ RELATIVE ; 
 import com . sun . jna . platform . win32 . WinReg . HKEY ; 
 import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 import com . sun . jna . platform . win32 . Winsvc . ChangeServiceConfig2Info ; 
 @ @ - 313 , 6 + 314 , 94 @ @ public interface Advapi32 extends StdCallLibrary { 
 boolean InitializeSecurityDescriptor ( SECURITY _ DESCRIPTOR pSecurityDescriptor , int dwRevision ) ; 
 
 / * * 
 + * The GetSecurityDescriptorControl function retrieves a security descriptor control and revision information . 
 + * @ param pSecurityDescriptor 
 + * A pointer to a SECURITY _ DESCRIPTOR structure whose control and revision 
 + * information the function retrieves . 
 + * @ param pControl 
 + * A pointer to a SECURITY _ DESCRIPTOR _ CONTROL structure that receives the security descriptor ' s 
 + * control information . 
 + * @ param lpdwRevision 
 + * A pointer to a variable that receives the security descriptor ' s revision value . 
 + * This value is always set , even when GetSecurityDescriptorControl returns an error . 
 + * @ return If the function succeeds , the return value is nonzero . If the 
 + * function fails , the return value is zero . For extended error 
 + * information , call GetLastError . 
 + * / 
 + boolean GetSecurityDescriptorControl ( SECURITY _ DESCRIPTOR pSecurityDescriptor , IntByReference pControl , IntByReference lpdwRevision ) ; 
 + 
 + / * * 
 + * The SetSecurityDescriptorControl function sets the control bits of a security descriptor . The function can set only the control 
 + * bits that relate to automatic inheritance of ACEs . To set the other control bits of a security descriptor , use the functions , 
 + * such as SetSecurityDescriptorDacl , for modifying the components of a security descriptor . 
 + * @ param pSecurityDescriptor 
 + * A pointer to a SECURITY _ DESCRIPTOR structure whose control and revision information are set . 
 + * @ param ControlBitsOfInterest 
 + * A SECURITY _ DESCRIPTOR _ CONTROL mask that indicates the control bits to set . 
 + * @ param ControlBitsToSet 
 + * SECURITY _ DESCRIPTOR _ CONTROL mask that indicates the new values for the control bits specified by the ControlBitsOfInterest mask . 
 + * @ return If the function succeeds , the return value is nonzero . If the 
 + * function fails , the return value is zero . For extended error 
 + * information , call GetLastError . 
 + * / 
 + boolean SetSecurityDescriptorControl ( SECURITY _ DESCRIPTOR pSecurityDescriptor , int ControlBitsOfInterest , int ControlBitsToSet ) ; 
 + 
 + / * * 
 + * The SetSecurityDescriptorDacl function sets information in a discretionary access control list ( DACL ) . 
 + * If a DACL is already present in the security descriptor , the DACL is replaced . 
 + * @ param pSecurityDescriptor 
 + * A pointer to the SECURITY _ DESCRIPTOR structure to which the function adds the DACL . This 
 + * security descriptor must be in absolute format , meaning that its members must be pointers 
 + * to other structures , rather than offsets to contiguous data . 
 + * @ param bDaclPresent 
 + * A flag that indicates the presence of a DACL in the security descriptor . If this parameter 
 + * is TRUE , the function sets the SE _ DACL _ PRESENT flag in the SECURITY _ DESCRIPTOR _ CONTROL 
 + * structure and uses the values in the pDacl and bDaclDefaulted parameters . If this parameter 
 + * is FALSE , the function clears the SE _ DACL _ PRESENT flag , and pDacl and bDaclDefaulted are ignored . 
 + * @ param pAcl 
 + * A pointer to an ACL structure that specifies the DACL for the security descriptor . If this 
 + * parameter is NULL , a NULL DACL is assigned to the security descriptor , which allows all access 
 + * to the object . The DACL is referenced by , not copied into , the security descriptor . 
 + * @ param bDaclDefaulted 
 + * A flag that indicates the source of the DACL . If this flag is TRUE , the DACL has been retrieved 
 + * by some default mechanism . If FALSE , the DACL has been explicitly specified by a user . The function 
 + * stores this value in the SE _ DACL _ DEFAULTED flag of the SECURITY _ DESCRIPTOR _ CONTROL structure . If 
 + * this parameter is not specified , the SE _ DACL _ DEFAULTED flag is cleared . 
 + * @ return If the function succeeds , the return value is nonzero . If the 
 + * function fails , the return value is zero . For extended error 
 + * information , call GetLastError . 
 + * / 
 + boolean SetSecurityDescriptorDacl ( SECURITY _ DESCRIPTOR pSecurityDescriptor , boolean bDaclPresent , ACL pDacl , boolean bDaclDefaulted ) ; 
 + 
 + / * * 
 + * The GetSecurityDescriptorDacl function retrieves a pointer to the discretionary access control list ( DACL ) in 
 + * a specified security descriptor . 
 + * @ param pSecurityDescriptor 
 + * A pointer to the SECURITY _ DESCRIPTOR structure that contains the DACL . The function retrieves a pointer to it . 
 + * @ param bDaclPresent 
 + * A pointer to a value that indicates the presence of a DACL in the specified security descriptor . If 
 + * lpbDaclPresent is TRUE , the security descriptor contains a DACL , and the remaining output parameters in this 
 + * function receive valid values . If lpbDaclPresent is FALSE , the security descriptor does not contain a DACL , 
 + * and the remaining output parameters do not receive valid values . A value of TRUE for lpbDaclPresent does not 
 + * mean that pDacl is not NULL . That is , lpbDaclPresent can be TRUE while pDacl is NULL , meaning that a NULL 
 + * DACL is in effect . A NULL DACL implicitly allows all access to an object and is not the same as an empty DACL . 
 + * An empty DACL permits no access to an object . For information about creating a proper DACL , see Creating a DACL . 
 + * @ param pDacl 
 + * A pointer to a pointer to an access control list ( ACL ) . If a DACL exists , the function sets the pointer pointed 
 + * to by pDacl to the address of the security descriptor ' s DACL . If a DACL does not exist , no value is stored . 
 + * If the function stores a NULL value in the pointer pointed to by pDacl , the security descriptor has a NULL DACL . 
 + * A NULL DACL implicitly allows all access to an object . 
 + * If an application expects a non - NULL DACL but encounters a NULL DACL , the application should fail securely and 
 + * not allow access . 
 + * @ param bDaclDefaulted 
 + * A pointer to a flag set to the value of the SE _ DACL _ DEFAULTED flag in the SECURITY _ DESCRIPTOR _ CONTROL structure 
 + * if a DACL exists for the security descriptor . If this flag is TRUE , the DACL was retrieved by a default mechanism ; 
 + * if FALSE , the DACL was explicitly specified by a user . 
 + * @ return 
 + * / 
 + boolean GetSecurityDescriptorDacl ( SECURITY _ DESCRIPTOR pSecurityDescriptor , BOOLByReference bDaclPresent , PointerByReference pDacl , BOOLByReference bDaclDefaulted ) ; 
 + 
 + / * * 
 * The InitializeAcl function initializes a new ACL structure . 
 * @ param pAcl 
 * A pointer to an ACL structure to be initialized by this function . 
 @ @ - 2073 , 6 + 2162 , 85 @ @ public interface Advapi32 extends StdCallLibrary { 
 boolean IsValidSecurityDescriptor ( Pointer ppSecurityDescriptor ) ; 
 
 / * * 
 + * A pointer to a SECURITY _ DESCRIPTOR structure in absolute format . The function creates a version of this security 
 + * descriptor in self - relative format without modifying the original . 
 + * @ param pAbsoluteSD 
 + * A pointer to a SECURITY _ DESCRIPTOR structure in absolute format . The function creates a version of this 
 + * security descriptor in self - relative format without modifying the original . 
 + * @ param pSelfRelativeSD 
 + * A pointer to a buffer the function fills with a security descriptor in self - relative format . 
 + * @ param lpdwBufferLength 
 + * A pointer to a variable specifying the size of the buffer pointed to by the pSelfRelativeSD parameter . 
 + * If the buffer is not large enough for the security descriptor , the function fails and sets this variable 
 + * to the minimum required size . 
 + * @ return If the function succeeds , the function returns nonzero . If the function fails , it returns zero . To get 
 + * extended error information , call GetLastError . Possible return codes include , but are not limited to , the following : 
 + * ERROR _ INSUFFICIENT _ BUFFER - One or more of the buffers is too small . 
 + * / 
 + boolean MakeSelfRelativeSD ( SECURITY _ DESCRIPTOR pAbsoluteSD , 
 + SECURITY _ DESCRIPTOR _ RELATIVE pSelfRelativeSD , 
 + IntByReference lpdwBufferLength ) ; 
 + 
 + / * * 
 + * The MakeAbsoluteSD function creates a security descriptor in absolute format by using a 
 + * security descriptor in self - relative format as a template . 
 + * @ param pSelfRelativeSD 
 + * A pointer to a SECURITY _ DESCRIPTOR structure in self - relative format . The function creates an 
 + * absolute - format version of this security descriptor without modifying the original security descriptor . 
 + * @ param pAbsoluteSD 
 + * A pointer to a buffer that the function fills with the main body of an absolute - format security 
 + * descriptor . This information is formatted as a SECURITY _ DESCRIPTOR structure . 
 + * @ param lpdwAbsoluteSDSize 
 + * A pointer to a variable that specifies the size of the buffer pointed to by the pAbsoluteSD parameter . 
 + * If the buffer is not large enough for the security descriptor , the function fails and sets this variable 
 + * to the minimum required size . 
 + * @ param pDacl 
 + * A pointer to a buffer the function fills with the discretionary access control list ( DACL ) of the 
 + * absolute - format security descriptor . The main body of the absolute - format security descriptor references 
 + * this pointer . 
 + * @ param lpdwDaclSize 
 + * A pointer to a variable that specifies the size of the buffer pointed to by the pDacl parameter . If 
 + * the buffer is not large enough for the access control list ( ACL ) , the function fails and sets this 
 + * variable to the minimum required size . 
 + * @ param pSacl 
 + * A pointer to a buffer the function fills with the system access control list ( SACL ) of the absolute - format 
 + * security descriptor . The main body of the absolute - format security descriptor references this pointer . 
 + * @ param lpdwSaclSize 
 + * A pointer to a variable that specifies the size of the buffer pointed to by the pSacl parameter . If the 
 + * buffer is not large enough for the ACL , the function fails and sets this variable to the minimum required 
 + * size . 
 + * @ param pOwner 
 + * A pointer to a buffer the function fills with the security identifier ( SID ) of the owner of the 
 + * absolute - format security descriptor . The main body of the absolute - format security descriptor references 
 + * this pointer . 
 + * @ param lpdwOwnerSize 
 + * A pointer to a variable that specifies the size of the buffer pointed to by the pOwner parameter . 
 + * If the buffer is not large enough for the SID , the function fails and sets this variable to the minimum 
 + * required size . 
 + * @ param pPrimaryGroup 
 + * A pointer to a buffer the function fills with the SID of the absolute - format security descriptor ' s 
 + * primary group . The main body of the absolute - format security descriptor references this pointer . 
 + * @ param lpdwPrimaryGroupSize 
 + * A pointer to a variable that specifies the size of the buffer pointed to by the pPrimaryGroup parameter . 
 + * If the buffer is not large enough for the SID , the function fails and sets this variable to the minimum 
 + * required size . 
 + * @ return If the function succeeds , the function returns nonzero . If the function fails , it returns zero . To get 
 + * extended error information , call GetLastError . Possible return codes include , but are not limited to , the following : 
 + * ERROR _ INSUFFICIENT _ BUFFER - One or more of the buffers is too small . 
 + * / 
 + boolean MakeAbsoluteSD ( SECURITY _ DESCRIPTOR _ RELATIVE pSelfRelativeSD , 
 + SECURITY _ DESCRIPTOR pAbsoluteSD , 
 + IntByReference lpdwAbsoluteSDSize , 
 + ACL pDacl , 
 + IntByReference lpdwDaclSize , 
 + ACL pSacl , 
 + IntByReference lpdwSaclSize , 
 + PSID pOwner , 
 + IntByReference lpdwOwnerSize , 
 + PSID pPrimaryGroup , 
 + IntByReference lpdwPrimaryGroupSize ) ; 
 + 
 + / * * 
 * The IsValidAcl function validates an access control list ( ACL ) . 
 * 
 * @ param pAcl [ in ] 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 index b09124c . . 51000ab 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 @ @ - 2486 , 6 + 2486 , 7 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 } 
 
 public SECURITY _ DESCRIPTOR ( byte [ ] data ) { 
 + super ( ) ; 
 this . data = data ; 
 useMemory ( new Memory ( data . length ) ) ; 
 } 
 @ @ - 2522 , 6 + 2523 , 12 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 public static class ACL extends Structure { 
 public static final List < String > FIELDS = createFieldsOrder ( " AclRevision " , " Sbz1 " , " AclSize " , " AceCount " , " Sbz2 " ) ; 
 
 + / * 
 + * Maximum size chosen based on technet article : 
 + * https : / / technet . microsoft . com / en - us / library / cc781716 . aspx 
 + * / 
 + public static int MAX _ ACL _ SIZE = 64 * 1024 ; 
 + 
 public byte AclRevision ; 
 public byte Sbz1 ; 
 public short AclSize ; 
 @ @ - 2589 , 10 + 2596 , 10 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 public int Sacl ; 
 public int Dacl ; 
 
 - private ACL DACL ; 
 private PSID OWNER ; 
 private PSID GROUP ; 
 private ACL SACL ; 
 + private ACL DACL ; 
 
 public SECURITY _ DESCRIPTOR _ RELATIVE ( ) { 
 super ( ) ; 
 @ @ - 2604 , 6 + 2611 , 10 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 setMembers ( ) ; 
 } 
 
 + public SECURITY _ DESCRIPTOR _ RELATIVE ( int length ) { 
 + super ( new Memory ( length ) ) ; 
 + } 
 + 
 public SECURITY _ DESCRIPTOR _ RELATIVE ( Pointer p ) { 
 super ( p ) ; 
 setMembers ( ) ; 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 index 78810d3 . . 9df9a5c 100755 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 @ @ - 50 , 12 + 50 , 12 @ @ import com . sun . jna . platform . win32 . WinBase . FE _ IMPORT _ FUNC ; 
 import com . sun . jna . platform . win32 . WinBase . FILETIME ; 
 import com . sun . jna . platform . win32 . WinBase . PROCESS _ INFORMATION ; 
 import com . sun . jna . platform . win32 . WinBase . STARTUPINFO ; 
 + import com . sun . jna . platform . win32 . WinDef . BOOL ; 
 import com . sun . jna . platform . win32 . WinDef . BOOLByReference ; 
 import com . sun . jna . platform . win32 . WinDef . DWORD ; 
 import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; 
 import com . sun . jna . platform . win32 . WinDef . ULONG ; 
 import com . sun . jna . platform . win32 . WinDef . ULONGByReference ; 
 - import com . sun . jna . platform . win32 . WinNT . ACCESS _ ACEStructure ; 
 import com . sun . jna . platform . win32 . WinNT . ACCESS _ ALLOWED _ ACE ; 
 import com . sun . jna . platform . win32 . WinNT . ACL ; 
 import com . sun . jna . platform . win32 . WinNT . EVENTLOGRECORD ; 
 @ @ - 66 , 6 + 66 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; 
 import com . sun . jna . platform . win32 . WinNT . PSID ; 
 import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; 
 import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR ; 
 + import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR _ RELATIVE ; 
 import com . sun . jna . platform . win32 . WinNT . SECURITY _ IMPERSONATION _ LEVEL ; 
 import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; 
 import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; 
 @ @ - 700 , 6 + 701 , 48 @ @ public class Advapi32Test extends TestCase { 
 assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( sd , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; 
 } 
 
 + public void testSetGetSecurityDescriptorControl ( ) { 
 + SECURITY _ DESCRIPTOR sd = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; 
 + assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( sd , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . SetSecurityDescriptorControl ( sd , WinNT . SE _ DACL _ PROTECTED , WinNT . SE _ DACL _ PROTECTED ) ) ; 
 + IntByReference pControl = new IntByReference ( ) ; 
 + IntByReference lpdwRevision = new IntByReference ( ) ; 
 + assertTrue ( Advapi32 . INSTANCE . GetSecurityDescriptorControl ( sd , pControl , lpdwRevision ) ) ; 
 + assertTrue ( pControl . getValue ( ) = = WinNT . SE _ DACL _ PROTECTED ) ; 
 + assertTrue ( lpdwRevision . getValue ( ) = = WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ; 
 + } 
 + 
 + public void testSetGetSecurityDescriptorDacl ( ) throws IOException { 
 + SECURITY _ DESCRIPTOR sd = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; 
 + assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( sd , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; 
 + 
 + ACL pAcl ; 
 + int cbAcl = 0 ; 
 + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + assertTrue ( " Failed to create well - known SID " , 
 + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; 
 + 
 + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; 
 + cbAcl = Native . getNativeSize ( ACL . class , null ) ; 
 + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; 
 + cbAcl + = ( sidLength - DWORD . SIZE ) ; 
 + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; 
 + pAcl = new ACL ( cbAcl ) ; 
 + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . AddAccessAllowedAce ( pAcl , WinNT . ACL _ REVISION , WinNT . STANDARD _ RIGHTS _ ALL , pSid ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . SetSecurityDescriptorDacl ( sd , true , pAcl , false ) ) ; 
 + BOOLByReference lpbDaclPresent = new BOOLByReference ( ) ; 
 + BOOLByReference lpbDaclDefaulted = new BOOLByReference ( ) ; 
 + PointerByReference pDacl = new PointerByReference ( ) ; 
 + assertTrue ( Advapi32 . INSTANCE . GetSecurityDescriptorDacl ( sd , lpbDaclPresent , pDacl , lpbDaclDefaulted ) ) ; 
 + ACL pAclGet = new ACL ( pDacl . getValue ( ) ) ; 
 + assertEquals ( new BOOL ( true ) , lpbDaclPresent . getValue ( ) ) ; 
 + assertEquals ( new BOOL ( false ) , lpbDaclDefaulted . getValue ( ) ) ; 
 + assertEquals ( 1 , pAclGet . AceCount ) ; 
 + assertEquals ( WinNT . ACL _ REVISION , pAclGet . AclRevision ) ; 
 + } 
 + 
 public void testInitializeAcl ( ) throws IOException { 
 ACL pAcl ; 
 int cbAcl = 0 ; 
 @ @ - 1659 , 6 + 1702 , 60 @ @ public class Advapi32Test extends TestCase { 
 } 
 } 
 
 + public void testMakeSelfRelativeSD ( ) { 
 + SECURITY _ DESCRIPTOR absolute = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; 
 + assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( absolute , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; 
 + SECURITY _ DESCRIPTOR _ RELATIVE relative = new SECURITY _ DESCRIPTOR _ RELATIVE ( 64 * 1024 ) ; 
 + IntByReference lpdwBufferLength = new IntByReference ( 64 * 1024 ) ; 
 + assertTrue ( Advapi32 . INSTANCE . MakeSelfRelativeSD ( absolute , relative , lpdwBufferLength ) ) ; 
 + assertEquals ( WinNT . SECURITY _ DESCRIPTOR _ REVISION , relative . Revision ) ; 
 + } 
 + 
 + public void testMakeAbsoluteSD ( ) throws Exception { 
 + SECURITY _ DESCRIPTOR absolute = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; 
 + 
 + / / Get a SD in self relative form 
 + int infoType = OWNER _ SECURITY _ INFORMATION 
 + | GROUP _ SECURITY _ INFORMATION 
 + | DACL _ SECURITY _ INFORMATION ; 
 + 
 + PointerByReference relativeByReference = new PointerByReference ( ) ; 
 + File file = createTempFile ( ) ; 
 + try { 
 + try { 
 + assertEquals ( " GetNamedSecurityInfo ( " + file + " ) " , 
 + Advapi32 . INSTANCE . GetNamedSecurityInfo ( 
 + file . getAbsolutePath ( ) , 
 + AccCtrl . SE _ OBJECT _ TYPE . SE _ FILE _ OBJECT , 
 + infoType , 
 + null , 
 + null , 
 + null , 
 + null , 
 + relativeByReference ) , 0 ) ; 
 + 
 + SECURITY _ DESCRIPTOR _ RELATIVE relative = new SECURITY _ DESCRIPTOR _ RELATIVE ( relativeByReference . getValue ( ) ) ; 
 + 
 + PSID pOwner = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + PSID pGroup = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + ACL pDacl = new ACL ( ACL . MAX _ ACL _ SIZE ) ; 
 + ACL pSacl = new ACL ( ACL . MAX _ ACL _ SIZE ) ; 
 + 
 + IntByReference lpdwBufferLength = new IntByReference ( absolute . size ( ) ) ; 
 + IntByReference lpdwDaclSize = new IntByReference ( ACL . MAX _ ACL _ SIZE ) ; 
 + IntByReference lpdwSaclSize = new IntByReference ( ACL . MAX _ ACL _ SIZE ) ; 
 + IntByReference lpdwOwnerSize = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + IntByReference lpdwPrimaryGroupSize = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + 
 + assertTrue ( Advapi32 . INSTANCE . MakeAbsoluteSD ( relative , absolute , lpdwBufferLength , pDacl , lpdwDaclSize , pSacl , lpdwSaclSize , pOwner , lpdwOwnerSize , pGroup , lpdwPrimaryGroupSize ) ) ; 
 + } finally { 
 + file . delete ( ) ; 
 + } 
 + } finally { 
 + Kernel32Util . freeLocalMemory ( relativeByReference . getValue ( ) ) ; 
 + } 
 + } 
 + 
 public void testMapGenericReadMask ( ) { 
 final GENERIC _ MAPPING mapping = new GENERIC _ MAPPING ( ) ; 
 mapping . genericRead = new DWORD ( FILE _ GENERIC _ READ ) ;

NEAREST DIFF:
diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c 
 index 383d49f . . b3450f8 100644 
 - - - a / jnalib / native / dispatch . c 
 + + + b / jnalib / native / dispatch . c 
 @ @ - 992 , 7 + 992 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1write _ _ J _ 3SII 
 * Signature : ( JB ) J 
 * / 
 JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1indexOf _ _ JB 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 { 
 jbyte * peer = ( jbyte * ) L2A ( addr ) ; 
 volatile jlong i = 0 ; 
 @ @ - 1103 , 7 + 1103 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1read _ _ J _ 3SII 
 * Signature : ( J ) B 
 * / 
 JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jbyte res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1116 , 7 + 1116 , 7 @ @ JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte 
 * Signature : ( J ) C 
 * / 
 JNIEXPORT jchar JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getChar 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 wchar _ t res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1153 , 7 + 1153 , 7 @ @ JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDirectByteBuffer 
 * Signature : ( J ) D 
 * / 
 JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jdouble res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1166 , 7 + 1166 , 7 @ @ JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble 
 * Signature : ( J ) F 
 * / 
 JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jfloat res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1179 , 7 + 1179 , 7 @ @ JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat 
 * Signature : ( J ) I 
 * / 
 JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jint res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1192 , 7 + 1192 , 7 @ @ JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt 
 * Signature : ( J ) J 
 * / 
 JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jlong res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1205 , 7 + 1205 , 7 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong 
 * Signature : ( J ) S 
 * / 
 JNIEXPORT jshort JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getShort 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jshort res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1229 , 7 + 1229 , 7 @ @ JNIEXPORT jstring JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getString 
 * Signature : ( JJB ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) 
 { 
 MEMSET ( L2A ( addr ) , ( int ) value , ( size _ t ) count ) ; 
 } 
 @ @ - 1240 , 7 + 1240 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory 
 * Signature : ( JB ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1251 , 7 + 1251 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte 
 * Signature : ( JC ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jchar value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jchar value ) 
 { 
 wchar _ t ch = value ; 
 MEMCPY ( L2A ( addr ) , & ch , sizeof ( ch ) ) ; 
 @ @ - 1263 , 7 + 1263 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar 
 * Signature : ( JJ ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 { 
 void * ptr = L2A ( value ) ; 
 MEMCPY ( L2A ( addr ) , & ptr , sizeof ( void * ) ) ; 
 @ @ - 1275 , 7 + 1275 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer 
 * Signature : ( JD ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jdouble value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jdouble value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1286 , 7 + 1286 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble 
 * Signature : ( JF ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jfloat value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jfloat value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1297 , 7 + 1297 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat 
 * Signature : ( JI ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jint value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jint value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1308 , 7 + 1308 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt 
 * Signature : ( JJ ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1319 , 7 + 1319 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong 
 * Signature : ( JS ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setShort 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jshort value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jshort value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 }
