BLEU SCORE: 0.04923026124015933

TEST MSG: fix FP callback args on ARM
GENERATED MSG: ensure proper method selection when java callback returns NativeMapped

TEST DIFF (one line): diff - - git a / native / callback . c b / native / callback . c <nl> index d750c11 . . b787eb9 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 165 , 8 + 165 , 9 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> } <nl> } <nl> <nl> + / / Java callback method is called using varargs , so promote floats to <nl> + / / double where appropriate for the platform <nl> if ( cb - > arg _ types [ i ] - > type = = FFI _ TYPE _ FLOAT ) { <nl> - / / Java method is varargs , so promote floats to double <nl> cb - > java _ arg _ types [ i + 3 ] = & ffi _ type _ double ; <nl> cb - > conversion _ flags [ i ] = CVT _ FLOAT ; <nl> cvt = 1 ; <nl> @ @ - 236 , 7 + 237 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> case ' D ' : cb - > fptr _ offset = OFFSETOF ( env , CallDoubleMethod ) ; break ; <nl> default : cb - > fptr _ offset = OFFSETOF ( env , CallObjectMethod ) ; break ; <nl> } <nl> - status = ffi _ prep _ cif ( & cb - > java _ cif , java _ abi , argc + 3 , java _ ffi _ rtype , cb - > java _ arg _ types ) ; <nl> + status = ffi _ prep _ cif _ var ( & cb - > java _ cif , java _ abi , 2 , argc + 3 , java _ ffi _ rtype , cb - > java _ arg _ types ) ; <nl> if ( ! ffi _ error ( env , " callback setup ( 2 ) " , status ) ) { <nl> ffi _ prep _ closure _ loc ( cb - > closure , & cb - > cif , callback _ dispatch , cb , <nl> cb - > x _ closure ) ;
NEAREST DIFF (one line): diff - - git a / www / index . html b / www / index . html <nl> index 8d92a7f . . ed5ba99 100644 <nl> - - - a / www / index . html <nl> + + + b / www / index . html <nl> @ @ - 3 , 7 + 3 , 7 @ @ <nl> < meta name = " author " content = " Timothy Wall " > <nl> < meta name = " keywords " content = " java , jna , jni , c , c + + , native , method , function , call , ctypes , ffi , foreign function interface , jdirect , jinvoke , pinvoke , platform invoke , native library access , native access , call native from java , java c library , easy jni , call c from java , avoid jni , jni alternative , jni replacement , legacy , call from java , replace jni " > <nl> < meta name = " description " content = " Java Native Access ( JNA ) : access native libraries with pure Java code . " > <nl> - < meta name = " date " content = " 2009 - 07 - 01 " > <nl> + < meta name = " date " content = " 2009 - 07 - 14 " > <nl> < title > Java Native Access ( JNA ) : Pure Java access to native libraries < / title > <nl> < meta http - equiv = " Content - Type " content = " text / html ; charset = iso - 8859 - 1 " > <nl> < / head > <nl> @ @ - 569 , 21 + 569 , 18 @ @ tips < / a > related to different types of type mapping . <nl> < a href = # top > Top < / a > <nl> < a name = direct > < / a > <nl> < h3 > JNA Direct Mapping < / h3 > <nl> - If you don ' t need any special type mappings to convert your function ' s <nl> - arguments into native types , or are willing to do the conversion yourself , JNA <nl> - supports a direct mapping method which can improve performance substantially , <nl> - approaching that of custom JNI . Method signatures are the same as they would <nl> - be in a JNA interface mapping , but they can be any static or object methods . <nl> - You only need register them within the static initializer of the defining <nl> - class , as in the example below . The < code > Native . register ( ) < / code > method <nl> - takes the name of your native library , the same <nl> - as < code > Native . loadLibrary ( ) < / code > would . < p > <nl> + JNA supports a direct mapping method which can improve performance <nl> + substantially , approaching that of custom JNI . Method signatures are the same <nl> + as they would be in a JNA interface mapping , but they can be any static or <nl> + object methods . You only need register them within the static initializer of <nl> + the defining class , as in the example below . <nl> + The < code > Native . register ( ) < / code > method takes the name of your native <nl> + library , the same as < code > Native . loadLibrary ( ) < / code > would . < p > <nl> <nl> < textarea name = " textarea " cols = " 80 " rows = " 20 " readonly = " readonly " > <nl> import com . sun . jna . * ; <nl> <nl> / * * Simple example of JNA direct mapping . <nl> - * Fewer automatic type conversions are supported with this method <nl> * / <nl> public class HelloWorld { <nl> <nl> @ @ - 601 , 9 + 598 , 9 @ @ public class HelloWorld { <nl> } <nl> < / textarea > <nl> < p > <nl> - As of version 3 . 1 . 0 , direct mapping only supports Pointer and primitive type <nl> - arguments ( SVN head supports everything except < code > TypeMapper < / code > s ) . <nl> - Once the full mappings are available , though , you can easily convert from <nl> + As of version 3 . 2 . 0 , direct mapping supports the same type mappings as <nl> + interface mapping , except for arrays of Pointer / String / WString / NativeMapped as <nl> + function arguments . You can easily convert from <nl> interface mapping to direct mapping by creating a direct mapping class which <nl> implements your library interface , with all methods defined as native methods . <nl> Then your library instance variable can be assigned an instance of this new

TEST DIFF:
diff - - git a / native / callback . c b / native / callback . c 
 index d750c11 . . b787eb9 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 165 , 8 + 165 , 9 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 } 
 } 
 
 + / / Java callback method is called using varargs , so promote floats to 
 + / / double where appropriate for the platform 
 if ( cb - > arg _ types [ i ] - > type = = FFI _ TYPE _ FLOAT ) { 
 - / / Java method is varargs , so promote floats to double 
 cb - > java _ arg _ types [ i + 3 ] = & ffi _ type _ double ; 
 cb - > conversion _ flags [ i ] = CVT _ FLOAT ; 
 cvt = 1 ; 
 @ @ - 236 , 7 + 237 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 case ' D ' : cb - > fptr _ offset = OFFSETOF ( env , CallDoubleMethod ) ; break ; 
 default : cb - > fptr _ offset = OFFSETOF ( env , CallObjectMethod ) ; break ; 
 } 
 - status = ffi _ prep _ cif ( & cb - > java _ cif , java _ abi , argc + 3 , java _ ffi _ rtype , cb - > java _ arg _ types ) ; 
 + status = ffi _ prep _ cif _ var ( & cb - > java _ cif , java _ abi , 2 , argc + 3 , java _ ffi _ rtype , cb - > java _ arg _ types ) ; 
 if ( ! ffi _ error ( env , " callback setup ( 2 ) " , status ) ) { 
 ffi _ prep _ closure _ loc ( cb - > closure , & cb - > cif , callback _ dispatch , cb , 
 cb - > x _ closure ) ;

NEAREST DIFF:
diff - - git a / www / index . html b / www / index . html 
 index 8d92a7f . . ed5ba99 100644 
 - - - a / www / index . html 
 + + + b / www / index . html 
 @ @ - 3 , 7 + 3 , 7 @ @ 
 < meta name = " author " content = " Timothy Wall " > 
 < meta name = " keywords " content = " java , jna , jni , c , c + + , native , method , function , call , ctypes , ffi , foreign function interface , jdirect , jinvoke , pinvoke , platform invoke , native library access , native access , call native from java , java c library , easy jni , call c from java , avoid jni , jni alternative , jni replacement , legacy , call from java , replace jni " > 
 < meta name = " description " content = " Java Native Access ( JNA ) : access native libraries with pure Java code . " > 
 - < meta name = " date " content = " 2009 - 07 - 01 " > 
 + < meta name = " date " content = " 2009 - 07 - 14 " > 
 < title > Java Native Access ( JNA ) : Pure Java access to native libraries < / title > 
 < meta http - equiv = " Content - Type " content = " text / html ; charset = iso - 8859 - 1 " > 
 < / head > 
 @ @ - 569 , 21 + 569 , 18 @ @ tips < / a > related to different types of type mapping . 
 < a href = # top > Top < / a > 
 < a name = direct > < / a > 
 < h3 > JNA Direct Mapping < / h3 > 
 - If you don ' t need any special type mappings to convert your function ' s 
 - arguments into native types , or are willing to do the conversion yourself , JNA 
 - supports a direct mapping method which can improve performance substantially , 
 - approaching that of custom JNI . Method signatures are the same as they would 
 - be in a JNA interface mapping , but they can be any static or object methods . 
 - You only need register them within the static initializer of the defining 
 - class , as in the example below . The < code > Native . register ( ) < / code > method 
 - takes the name of your native library , the same 
 - as < code > Native . loadLibrary ( ) < / code > would . < p > 
 + JNA supports a direct mapping method which can improve performance 
 + substantially , approaching that of custom JNI . Method signatures are the same 
 + as they would be in a JNA interface mapping , but they can be any static or 
 + object methods . You only need register them within the static initializer of 
 + the defining class , as in the example below . 
 + The < code > Native . register ( ) < / code > method takes the name of your native 
 + library , the same as < code > Native . loadLibrary ( ) < / code > would . < p > 
 
 < textarea name = " textarea " cols = " 80 " rows = " 20 " readonly = " readonly " > 
 import com . sun . jna . * ; 
 
 / * * Simple example of JNA direct mapping . 
 - * Fewer automatic type conversions are supported with this method 
 * / 
 public class HelloWorld { 
 
 @ @ - 601 , 9 + 598 , 9 @ @ public class HelloWorld { 
 } 
 < / textarea > 
 < p > 
 - As of version 3 . 1 . 0 , direct mapping only supports Pointer and primitive type 
 - arguments ( SVN head supports everything except < code > TypeMapper < / code > s ) . 
 - Once the full mappings are available , though , you can easily convert from 
 + As of version 3 . 2 . 0 , direct mapping supports the same type mappings as 
 + interface mapping , except for arrays of Pointer / String / WString / NativeMapped as 
 + function arguments . You can easily convert from 
 interface mapping to direct mapping by creating a direct mapping class which 
 implements your library interface , with all methods defined as native methods . 
 Then your library instance variable can be assigned an instance of this new
