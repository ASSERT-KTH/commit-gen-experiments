BLEU SCORE: 0.02383853510228548

TEST MSG: fix # 223 , union sizing / layout issue
GENERATED MSG: Fix bug in ByValue structs using NativeMapped

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 93ca4ce . . 0a57637 100755 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 18 , 6 + 18 , 7 @ @ Bug Fixes <nl> * [ # 215 ] ( https : / / github . com / twall / jna / issues / 215 ) : Force use of XSI ` strerror _ r ` on linux - [ LionelCons ] ( https : / / github . com / LionelCons ) . <nl> * [ # 214 ] ( https : / / github . com / twall / jna / issues / 214 ) : Don ' t map library names when an absolute path is provided - [ @ twall ] ( https : / / github . com / twall ) . <nl> * [ # 218 ] ( https : / / github . com / twall / jna / issues / 218 ) : Explicitly handle broken Android SecurityManager implementation - [ @ twall ] ( https : / / github . com / twall ) . <nl> + * [ # 223 ] ( https : / / github . com / twall / jna / issues / 223 ) : Fix layout / size derivation for unions - [ @ twall ] ( https : / / github . com / twall ) . <nl> <nl> Release 3 . 5 . 2 <nl> = = = = = = = = = = = = = <nl> diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java <nl> index 68742f1 . . 8431799 100644 <nl> - - - a / src / com / sun / jna / Structure . java <nl> + + + b / src / com / sun / jna / Structure . java <nl> @ @ - 114 , 7 + 114 , 7 @ @ public abstract class Structure { <nl> String arch = System . getProperty ( " os . arch " ) . toLowerCase ( ) ; <nl> isPPC = " ppc " . equals ( arch ) | | " powerpc " . equals ( arch ) ; <nl> isSPARC = " sparc " . equals ( arch ) ; <nl> - 	 isARM = arch . startsWith ( " arm " ) ; <nl> + isARM = arch . startsWith ( " arm " ) ; <nl> } <nl> <nl> / * * Use the platform default alignment . * / <nl> @ @ - 216 , 7 + 216 , 7 @ @ public abstract class Structure { <nl> return typeMapper ; <nl> } <nl> <nl> - / * * Initialize the type mapper for this structure . <nl> + / * * Initialize the type mapper for this structure . <nl> * If < code > null < / code > , the default mapper for the <nl> * defining class will be used . <nl> * / <nl> @ @ - 871 , 7 + 871 , 7 @ @ public abstract class Structure { <nl> return list ; <nl> } <nl> <nl> - / * * Returns all field names ( sorted ) provided so far by <nl> + / * * Returns all field names ( sorted ) provided so far by <nl> { @ link # getFieldOrder } <nl> @ param force set if results are required immediately <nl> @ return null if not yet able to provide fields , and force is false . <nl> @ @ - 899 , 7 + 899 , 7 @ @ public abstract class Structure { <nl> <nl> Set orderedNames = new HashSet ( fieldOrder ) ; <nl> if ( ! orderedNames . equals ( names ) ) { <nl> - throw new Error ( " Structure . getFieldOrder ( ) on " + getClass ( ) <nl> + throw new Error ( " Structure . getFieldOrder ( ) on " + getClass ( ) <nl> + " returns names ( " <nl> + sort ( fieldOrder ) <nl> + " ) which do not match declared field names ( " <nl> @ @ - 991 , 6 + 991 , 8 @ @ public abstract class Structure { <nl> private int alignType = ALIGN _ DEFAULT ; <nl> private TypeMapper typeMapper ; <nl> private boolean variable ; <nl> + / / For unions only , field on which the union FFI type info is based <nl> + private StructField typeInfoField ; <nl> } <nl> <nl> private void validateField ( String name , Class type ) { <nl> @ @ - 1029 , 7 + 1031 , 6 @ @ public abstract class Structure { <nl> members . <nl> * / <nl> private LayoutInfo deriveLayout ( boolean force , boolean avoidFFIType ) { <nl> - <nl> int calculatedSize = 0 ; <nl> List fields = getFields ( force ) ; <nl> if ( fields = = null ) { <nl> @ @ - 1139 , 11 + 1140 , 24 @ @ public abstract class Structure { <nl> if ( ( calculatedSize % fieldAlignment ) ! = 0 ) { <nl> calculatedSize + = fieldAlignment - ( calculatedSize % fieldAlignment ) ; <nl> } <nl> - structField . offset = calculatedSize ; <nl> - calculatedSize + = structField . size ; <nl> + if ( this instanceof Union ) { <nl> + structField . offset = 0 ; <nl> + calculatedSize = Math . max ( calculatedSize , structField . size ) ; <nl> + } <nl> + else { <nl> + structField . offset = calculatedSize ; <nl> + calculatedSize + = structField . size ; <nl> + } <nl> <nl> / / Save the field in our list <nl> info . fields . put ( structField . name , structField ) ; <nl> + <nl> + if ( info . typeInfoField = = null <nl> + | | info . typeInfoField . size < structField . size <nl> + | | ( info . typeInfoField . size = = structField . size <nl> + & & Structure . class . isAssignableFrom ( structField . type ) ) ) { <nl> + info . typeInfoField = structField ; <nl> + } <nl> } <nl> <nl> if ( calculatedSize > 0 ) { <nl> @ @ - 1504 , 7 + 1518 , 7 @ @ public abstract class Structure { <nl> This is typically most effective when a native call populates a large <nl> structure and you only need a few fields out of it . After the native <nl> call you can call { @ link # readField ( String ) } on only the fields of <nl> - interest . <nl> + interest . <nl> * / <nl> public void setAutoSynch ( boolean auto ) { <nl> setAutoRead ( auto ) ; <nl> @ @ - 1544 , 7 + 1558 , 7 @ @ public abstract class Structure { <nl> return FFIType . get ( obj ) ; <nl> } <nl> <nl> - / * * Called from native code only ; same as { @ link <nl> + / * * Called from native code only ; same as { @ link <nl> * # newInstance ( Class , Pointer ) } , except that it additionally performs <nl> * { @ link # conditionalAutoRead ( ) } . <nl> * / <nl> @ @ - 1619 , 6 + 1633 , 20 @ @ public abstract class Structure { <nl> } <nl> } <nl> <nl> + / * * Keep track of the largest aggregate field of the union to use for <nl> + * FFI type information . <nl> + * / <nl> + StructField typeInfoField ( ) { <nl> + LayoutInfo info ; <nl> + synchronized ( layoutInfo ) { <nl> + info = ( LayoutInfo ) layoutInfo . get ( getClass ( ) ) ; <nl> + } <nl> + if ( info ! = null ) { <nl> + return info . typeInfoField ; <nl> + } <nl> + return null ; <nl> + } <nl> + <nl> static class StructField extends Object { <nl> public String name ; <nl> public Class type ; <nl> @ @ - 1704 , 7 + 1732 , 7 @ @ public abstract class Structure { <nl> ref . ensureAllocated ( true ) ; <nl> <nl> if ( ref instanceof Union ) { <nl> - StructField sf = ( ( Union ) ref ) . biggestField ; <nl> + StructField sf = ( ( Union ) ref ) . typeInfoField ( ) ; <nl> els = new Pointer [ ] { <nl> get ( ref . getFieldValue ( sf . field ) , sf . type ) , <nl> null , <nl> diff - - git a / src / com / sun / jna / Union . java b / src / com / sun / jna / Union . java <nl> index d899e81 . . d08b50d 100644 <nl> - - - a / src / com / sun / jna / Union . java <nl> + + + b / src / com / sun / jna / Union . java <nl> @ @ - 1 , 14 + 1 , 14 @ @ <nl> / * Copyright ( c ) 2007 - 2012 Timothy Wall , All Rights Reserved <nl> - * <nl> + * <nl> * This library is free software ; you can redistribute it and / or <nl> * modify it under the terms of the GNU Lesser General Public <nl> * License as published by the Free Software Foundation ; either <nl> * version 2 . 1 of the License , or ( at your option ) any later version . <nl> - * <nl> + * <nl> * This library is distributed in the hope that it will be useful , <nl> * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> + * Lesser General Public License for more details . <nl> * / <nl> package com . sun . jna ; <nl> <nl> @ @ - 20 , 18 + 20 , 17 @ @ import java . util . List ; <nl> / * * Represents a native union . When writing to native memory , the field <nl> * corresponding to the type passed to { @ link # setType } will be written <nl> * to native memory . Upon reading from native memory , Structure , String , <nl> - * or WString fields will < em > not < / em > be initialized unless they are <nl> + * or WString fields will < em > not < / em > be initialized unless they are <nl> * the current field as identified by a call to { @ link # setType } . The current <nl> * field is always unset by default to avoid accidentally attempting to read <nl> - * a field that is not valid . In the case of a String , for instance , an <nl> + * a field that is not valid . In the case of a String , for instance , an <nl> * invalid pointer may result in a memory fault when attempting to initialize <nl> - * the String . <nl> + * the String . <nl> * / <nl> public abstract class Union extends Structure { <nl> private StructField activeField ; <nl> - StructField biggestField ; <nl> - <nl> - / * * Create a Union whose size and alignment will be calculated <nl> + <nl> + / * * Create a Union whose size and alignment will be calculated <nl> * automatically . <nl> * / <nl> protected Union ( ) { } <nl> @ @ - 65 , 10 + 64 , 10 @ @ public abstract class Union extends Structure { <nl> return list ; <nl> } <nl> <nl> - / * * Indicates by type which field will be used to write to native memory . <nl> + / * * Indicates by type which field will be used to write to native memory . <nl> * If there are multiple fields of the same type , use { @ link <nl> * # setType ( String ) } instead with the field name . <nl> - * @ throws IllegalArgumentException if the type does not correspond to <nl> + * @ throws IllegalArgumentException if the type does not correspond to <nl> * any declared union field . <nl> * / <nl> public void setType ( Class type ) { <nl> @ @ - 82 , 7 + 81 , 7 @ @ public abstract class Union extends Structure { <nl> } <nl> throw new IllegalArgumentException ( " No field of type " + type + " in " + this ) ; <nl> } <nl> - <nl> + <nl> / * * <nl> * Indicates which field will be used to write to native memory . <nl> * @ throws IllegalArgumentException if the name does not correspond to <nl> @ @ - 199 , 11 + 198 , 11 @ @ public abstract class Union extends Structure { <nl> } <nl> <nl> / * * Avoid reading pointer - based fields and structures unless explicitly <nl> - * selected . Structures may contain pointer - based fields which can <nl> + * selected . Structures may contain pointer - based fields which can <nl> * crash the VM if not properly initialized . <nl> * / <nl> Object readField ( StructField field ) { <nl> - if ( field = = activeField <nl> + if ( field = = activeField <nl> | | ( ! Structure . class . isAssignableFrom ( field . type ) <nl> & & ! String . class . isAssignableFrom ( field . type ) <nl> & & ! WString . class . isAssignableFrom ( field . type ) ) ) { <nl> @ @ - 211 , 56 + 210 , 12 @ @ public abstract class Union extends Structure { <nl> } <nl> / / Field not accessible <nl> / / TODO : read structure , to the extent possible ; need a " recursive " <nl> - / / flag to " read " <nl> + / / flag to " read " to indicate we want to avoid pointer - based fields <nl> return null ; <nl> } <nl> - <nl> - / * * Adjust the size to be the size of the largest element , and ensure <nl> - * all fields begin at offset zero . <nl> - * / <nl> - int calculateSize ( boolean force , boolean avoidFFIType ) { <nl> - int size = super . calculateSize ( force , avoidFFIType ) ; <nl> - if ( size ! = CALCULATE _ SIZE ) { <nl> - int fsize = 0 ; <nl> - for ( Iterator i = fields ( ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { <nl> - StructField f = ( StructField ) i . next ( ) ; <nl> - f . offset = 0 ; <nl> - if ( f . size > fsize <nl> - / / Prefer aggregate types to simple types , since they <nl> - / / will have more complex packing rules ( some platforms <nl> - / / have specific methods for packing small structs into <nl> - / / registers , which may not match the packing of bytes <nl> - / / for a primitive type ) . <nl> - | | ( f . size = = fsize <nl> - & & Structure . class . isAssignableFrom ( f . type ) ) ) { <nl> - fsize = f . size ; <nl> - biggestField = f ; <nl> - } <nl> - } <nl> - size = calculateAlignedSize ( fsize ) ; <nl> - if ( size > 0 ) { <nl> - / / Update native FFI type information , if needed <nl> - if ( this instanceof ByValue & & ! avoidFFIType ) { <nl> - getTypeInfo ( ) ; <nl> - } <nl> - } <nl> - } <nl> - return size ; <nl> - } <nl> + <nl> / * * All fields are considered the " first " element . * / <nl> protected int getNativeAlignment ( Class type , Object value , boolean isFirstElement ) { <nl> return super . getNativeAlignment ( type , value , true ) ; <nl> } <nl> - <nl> - / * * Avoid calculating type information until we know our biggest field . <nl> - * Return type information for the largest field to ensure all available <nl> - * bits are used . <nl> - * / <nl> - Pointer getTypeInfo ( ) { <nl> - if ( biggestField = = null ) { <nl> - / / Not calculated yet <nl> - return null ; <nl> - } <nl> - return super . getTypeInfo ( ) ; <nl> - } <nl> } <nl> diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java <nl> index 2c4f21c . . 482e069 100644 <nl> - - - a / test / com / sun / jna / StructureTest . java <nl> + + + b / test / com / sun / jna / StructureTest . java <nl> @ @ - 88 , 7 + 88 , 7 @ @ public class StructureTest extends TestCase { <nl> public int f2 ; <nl> public int f3 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " f0 " , " f1 " , " f2 " , " f3 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " f0 " , " f1 " , " f2 " , " f3 " } ) ; <nl> } <nl> } <nl> <nl> @ @ - 151 , 7 + 151 , 7 @ @ public class StructureTest extends TestCase { <nl> public float f ; <nl> public double d ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " b " , " s " , " i " , " l " , " f " , " d " } ) ; <nl> + return Arrays . asList ( new String [ ] { " b " , " s " , " i " , " l " , " f " , " d " } ) ; <nl> } <nl> } <nl> Structure s = new TestStructure ( ) ; <nl> @ @ - 170 , 7 + 170 , 7 @ @ public class StructureTest extends TestCase { <nl> public float f ; <nl> public double d ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " b " , " s " , " i " , " l " , " f " , " d " } ) ; <nl> + return Arrays . asList ( new String [ ] { " b " , " s " , " i " , " l " , " f " , " d " } ) ; <nl> } <nl> } <nl> Structure s = new TestStructure ( ) ; <nl> @ @ - 195 , 21 + 195 , 21 @ @ public class StructureTest extends TestCase { <nl> public byte field0 = 0x01 ; <nl> public short field1 = 0x0202 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; <nl> } <nl> } <nl> public static class TestStructure1 extends FilledStructure { <nl> public byte field0 = 0x01 ; <nl> public int field1 = 0x02020202 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; <nl> } <nl> } <nl> public static class TestStructure2 extends FilledStructure { <nl> public short field0 = 0x0101 ; <nl> public int field1 = 0x02020202 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; <nl> } <nl> } <nl> public static class TestStructure3 extends FilledStructure { <nl> @ @ - 217 , 7 + 217 , 7 @ @ public class StructureTest extends TestCase { <nl> public short field1 = 0x0202 ; <nl> public int field2 = 0x03030303 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field0 " , " field1 " , " field2 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field0 " , " field1 " , " field2 " } ) ; <nl> } <nl> } <nl> public static class TestStructure4 extends FilledStructure { <nl> @ @ - 226 , 14 + 226 , 14 @ @ public class StructureTest extends TestCase { <nl> public int field2 = 0x03030303 ; <nl> public long field3 = 0x0404040404040404L ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field0 " , " field1 " , " field2 " , " field3 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field0 " , " field1 " , " field2 " , " field3 " } ) ; <nl> } <nl> } <nl> public static class TestStructure5 extends FilledStructure { <nl> public long field0 = 0x0101010101010101L ; <nl> public byte field1 = 0x02 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; <nl> } <nl> } <nl> public interface SizeTest extends Library { <nl> @ @ - 354 , 7 + 354 , 7 @ @ public class StructureTest extends TestCase { <nl> + + allocations ; <nl> } <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " x " , " y " } ) ; <nl> + return Arrays . asList ( new String [ ] { " x " , " y " } ) ; <nl> } <nl> } <nl> public void testStructureField ( ) { <nl> @ @ - 362 , 7 + 362 , 7 @ @ public class StructureTest extends TestCase { <nl> public PublicTestStructure s1 , s2 ; <nl> public int after ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " s1 " , " s2 " , " after " } ) ; <nl> + return Arrays . asList ( new String [ ] { " s1 " , " s2 " , " after " } ) ; <nl> } <nl> } <nl> TestStructure s = new TestStructure ( ) ; <nl> @ @ - 386 , 6 + 386 , 25 @ @ public class StructureTest extends TestCase { <nl> s . s2 . getPointer ( ) ) ; <nl> } <nl> <nl> + static class TestUnion extends Union { <nl> + public int u _ int ; <nl> + public float u _ float ; <nl> + public double u _ double ; <nl> + } <nl> + public void testUnionField ( ) { <nl> + class TestStructure extends Structure { <nl> + public long s _ long ; <nl> + public TestUnion s _ union ; <nl> + public int s _ int ; <nl> + protected List getFieldOrder ( ) { <nl> + return Arrays . asList ( new String [ ] { " s _ long " , " s _ union " , " s _ int " } ) ; <nl> + } <nl> + } <nl> + TestStructure s = new TestStructure ( ) ; <nl> + assertEquals ( " Wrong structure size " , 24 , s . size ( ) ) ; <nl> + assertEquals ( " Wrong union size " , 8 , s . s _ union . size ( ) ) ; <nl> + } <nl> + <nl> public static class NonAllocatingTestStructure extends PublicTestStructure { <nl> public NonAllocatingTestStructure ( ) { } <nl> public NonAllocatingTestStructure ( Pointer p ) { super ( p ) ; read ( ) ; } <nl> @ @ - 394 , 16 + 413 , 16 @ @ public class StructureTest extends TestCase { <nl> } <nl> } <nl> <nl> - / / TODO : add ' l newInstance ( Pointer ) tests : <nl> + / / TODO : add ' l newInstance ( Pointer ) tests : <nl> / / NOTE : ensure structure - by - value respected ( no more flag on newjavastructure ) <nl> - / / native call ( direct mode ) <nl> + / / native call ( direct mode ) <nl> / / getNativeAlignment <nl> public void testStructureFieldAvoidsSeparateMemoryAllocation ( ) { <nl> class TestStructure extends Structure { <nl> public NonAllocatingTestStructure s1 ; <nl> public TestStructure ( ) { } <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " s1 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " s1 " } ) ; <nl> } <nl> } <nl> TestStructure ts = new TestStructure ( ) ; <nl> @ @ - 434 , 8 + 453 , 8 @ @ public class StructureTest extends TestCase { <nl> / / initialized array elements <nl> public PublicTestStructure [ ] inner2 = ( PublicTestStructure [ ] ) <nl> new PublicTestStructure ( ) . toArray ( 2 ) ; <nl> - protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " inner " , " inner2 " } ) ; <nl> + protected List getFieldOrder ( ) { <nl> + return Arrays . asList ( new String [ ] { " inner " , " inner2 " } ) ; <nl> } <nl> } <nl> TestStructure s = new TestStructure ( ) ; <nl> @ @ - 530 , 7 + 549 , 7 @ @ public class StructureTest extends TestCase { <nl> public double [ ] da = new double [ 3 ] ; <nl> public PublicTestStructure nested ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " z " , " b " , " c " , " s " , " i " , " l " , " f " , " d " , " ba " , " ca " , " sa " , " ia " , " la " , " fa " , " da " , " nested " } ) ; <nl> + return Arrays . asList ( new String [ ] { " z " , " b " , " c " , " s " , " i " , " l " , " f " , " d " , " ba " , " ca " , " sa " , " ia " , " la " , " fa " , " da " , " nested " } ) ; <nl> } <nl> } <nl> TestStructure s = new TestStructure ( ) ; <nl> @ @ - 624 , 8 + 643 , 8 @ @ public class StructureTest extends TestCase { <nl> class TestStructure extends Structure { <nl> public int i ; <nl> public NativeLong l ; <nl> - protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " i " , " l " } ) ; <nl> + protected List getFieldOrder ( ) { <nl> + return Arrays . asList ( new String [ ] { " i " , " l " } ) ; <nl> } <nl> } <nl> TestStructure s = new TestStructure ( ) ; <nl> @ @ - 672 , 14 + 691 , 14 @ @ public class StructureTest extends TestCase { <nl> <nl> public static class BadFieldStructure extends Structure { <nl> public Object badField ; <nl> - protected List getFieldOrder ( ) { <nl> + protected List getFieldOrder ( ) { <nl> return Arrays . asList ( new String [ ] { " badField " } ) ; <nl> } <nl> } <nl> public void testUnsupportedField ( ) { <nl> class BadNestedStructure extends Structure { <nl> public BadFieldStructure badStruct = new BadFieldStructure ( ) ; <nl> - protected List getFieldOrder ( ) { <nl> + protected List getFieldOrder ( ) { <nl> return Arrays . asList ( new String [ ] { " badStruct " } ) ; <nl> } <nl> } <nl> @ @ - 881 , 7 + 900 , 7 @ @ public class StructureTest extends TestCase { <nl> assertTrue ( " Read should preserve structure memory " , <nl> inner . getPointer ( ) instanceof Memory ) ; <nl> } <nl> - <nl> + <nl> public static class TestPointer extends PointerType { } <nl> public void testPreservePointerFields ( ) { <nl> class TestStructure extends Structure { <nl> @ @ - 925 , 7 + 944 , 7 @ @ public class StructureTest extends TestCase { <nl> assertEquals ( " String field should not be overwritten " , m2 , s . getPointer ( ) . getPointer ( Pointer . SIZE ) ) ; <nl> } <nl> <nl> - / / Ensure string cacheing doesn ' t interfere with wrapped structure writes . <nl> + / / Ensure string cacheing doesn ' t interfere with wrapped structure writes . <nl> public static class StructureFromNative extends Structure { <nl> public String s ; <nl> protected List getFieldOrder ( ) { <nl> @ @ - 938 , 7 + 957 , 7 @ @ public class StructureTest extends TestCase { <nl> public StructureFromNative ( ) { <nl> } <nl> } <nl> - <nl> + <nl> public void testInitializeStructureFieldWithStrings ( ) { <nl> class ContainingStructure extends Structure { <nl> public StructureFromNative inner ; <nl> @ @ - 1021 , 7 + 1040 , 7 @ @ public class StructureTest extends TestCase { <nl> } <nl> TestStructure s = new TestStructure ( ) ; <nl> s . field = new PublicTestStructure . ByReference ( ) ; <nl> - PublicTestStructure . ByReference [ ] array = <nl> + PublicTestStructure . ByReference [ ] array = <nl> ( PublicTestStructure . ByReference [ ] ) s . field . toArray ( 2 ) ; <nl> final int VALUE = - 1 ; <nl> array [ 1 ] . x = VALUE ; <nl> @ @ - 1066 , 13 + 1085 , 13 @ @ public class StructureTest extends TestCase { <nl> return Arrays . asList ( new String [ ] { " size " , " alignment " , " type " , " elements " } ) ; <nl> } <nl> public TestFFIType ( Pointer p ) { <nl> - super ( p ) ; <nl> + super ( p ) ; <nl> read ( ) ; <nl> assertTrue ( " Test FFIType type not initialized : " + this , this . type ! = 0 ) ; <nl> <nl> / / Force libffi to explicitly calculate the size field of <nl> / / this FFIType object <nl> - int size = Native . initialize _ ffi _ type ( p . peer ) ; <nl> + int size = Native . initialize _ ffi _ type ( p . peer ) ; <nl> read ( ) ; <nl> assertEquals ( " Test FFIType size improperly initialized : " + TestFFIType . this , size , TestFFIType . this . size . intValue ( ) ) ; <nl> } <nl> @ @ - 1123 , 7 + 1142 , 7 @ @ public class StructureTest extends TestCase { <nl> public int intField ; <nl> public PublicTestStructure inner ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " intField " , " inner " } ) ; <nl> + return Arrays . asList ( new String [ ] { " intField " , " inner " } ) ; <nl> } <nl> } <nl> TestStructure s = new TestStructure ( ) ; <nl> @ @ - 1154 , 7 + 1173 , 7 @ @ public class StructureTest extends TestCase { <nl> 	 class TestStructure extends Structure { <nl> public ByteByReference ref ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " ref " } ) ; <nl> + return Arrays . asList ( new String [ ] { " ref " } ) ; <nl> } <nl> 	 } <nl> 	 TestStructure s = new TestStructure ( ) ; <nl> @ @ - 1171 , 7 + 1190 , 7 @ @ public class StructureTest extends TestCase { <nl> 	 class TestStructure extends Structure { <nl> public ByteByReference ref ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " ref " } ) ; <nl> + return Arrays . asList ( new String [ ] { " ref " } ) ; <nl> } <nl> 	 } <nl> 	 TestStructure s = new TestStructure ( ) ; <nl> @ @ - 1191 , 7 + 1210 , 7 @ @ public class StructureTest extends TestCase { <nl> public static class ROStructure extends Structure { <nl> public final int field ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field " } ) ; <nl> } <nl> { <nl> / / Initialize in ctor to avoid compiler replacing <nl> @ @ - 1241 , 7 + 1260 , 7 @ @ public class StructureTest extends TestCase { <nl> class TestStructure extends Structure { <nl> public NativeLong [ ] longs = new NativeLong [ SIZE ] ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " longs " } ) ; <nl> + return Arrays . asList ( new String [ ] { " longs " } ) ; <nl> } <nl> } <nl> TestStructure s = new TestStructure ( ) ; <nl> @ @ - 1277 , 7 + 1296 , 7 @ @ public class StructureTest extends TestCase { <nl> public NativeLong nl = INITIAL ; <nl> public NativeLong uninitialized ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " nl " , " uninitialized " } ) ; <nl> + return Arrays . asList ( new String [ ] { " nl " , " uninitialized " } ) ; <nl> } <nl> } <nl> TestStructure ts = new TestStructure ( ) ; <nl> @ @ - 1300 , 7 + 1319 , 7 @ @ public class StructureTest extends TestCase { <nl> class TestStructure extends Structure { <nl> public int f1 , f2 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " f1 " , " f2 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " f1 " , " f2 " } ) ; <nl> } <nl> } <nl> class TestStructure2 extends TestStructure { <nl> @ @ - 1333 , 7 + 1352 , 7 @ @ public class StructureTest extends TestCase { <nl> class TestStructure extends Structure { <nl> public int f1 , f2 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " f1 " , " f2 " , " f3 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " f1 " , " f2 " , " f3 " } ) ; <nl> } <nl> } <nl> try { <nl> @ @ - 1387 , 7 + 1406 , 7 @ @ public class StructureTest extends TestCase { <nl> return list ; <nl> } <nl> } <nl> - <nl> + <nl> TestStructure s = new TestStructure ( ) ; <nl> assertEquals ( " Wrong field order " , <nl> Arrays . asList ( ORDER ) , s . getFieldOrder ( ) ) ; <nl> @ @ - 1444 , 13 + 1463 , 13 @ @ public class StructureTest extends TestCase { <nl> Structure s = new TestStructure ( ) ; <nl> assertEquals ( " Wrong type mapper : " + s , mapper , s . getTypeMapper ( ) ) ; <nl> } <nl> - <nl> + <nl> public void testWriteWithNullBoxedPrimitives ( ) { <nl> class TestStructure extends Structure { <nl> public Boolean zfield ; <nl> public Integer field ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " zfield " , " field " } ) ; <nl> + return Arrays . asList ( new String [ ] { " zfield " , " field " } ) ; <nl> } <nl> } <nl> TestStructure s = new TestStructure ( ) ; <nl> @ @ - 1465 , 7 + 1484 , 7 @ @ public class StructureTest extends TestCase { <nl> public int [ ] second = new int [ 4 ] ; <nl> public Pointer [ ] third = new Pointer [ 4 ] ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " first " , " second " , " third " } ) ; <nl> + return Arrays . asList ( new String [ ] { " first " , " second " , " third " } ) ; <nl> } <nl> } <nl> class TestStructure extends Structure { <nl> @ @ - 1492 , 7 + 1511 , 7 @ @ public class StructureTest extends TestCase { <nl> assertTrue ( " Equals is not symmetric " , s2 . equals ( s1 ) ) ; <nl> assertTrue ( " Equals is not transitive " , s1 . equals ( s2 ) & & s2 . equals ( s3 ) & & s1 . equals ( s3 ) ) ; <nl> <nl> - <nl> + <nl> } <nl> <nl> public void testStructureEqualsByValueByReference ( ) { <nl> @ @ - 1501 , 7 + 1520 , 7 @ @ public class StructureTest extends TestCase { <nl> public int [ ] second = new int [ 4 ] ; <nl> public Pointer [ ] third = new Pointer [ 4 ] ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " first " , " second " , " third " } ) ; <nl> + return Arrays . asList ( new String [ ] { " first " , " second " , " third " } ) ; <nl> } <nl> } <nl> class ByReference extends TestStructure implements Structure . ByReference { } <nl> @ @ - 1518 , 14 + 1537 , 14 @ @ public class StructureTest extends TestCase { <nl> assertTrue ( " Equals is not symmetric ( ByValue ) " , s3 . equals ( s1 ) ) ; <nl> assertTrue ( " Equals is not transitive ( ByReference / ByValue ) " , s1 . equals ( s2 ) & & s2 . equals ( s3 ) & & s1 . equals ( s3 ) ) ; <nl> <nl> - <nl> + <nl> } <nl> <nl> public void testStructureHashCodeMatchesEqualsTrue ( ) { <nl> class TestStructure extends Structure { <nl> public int first ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " first " } ) ; <nl> + return Arrays . asList ( new String [ ] { " first " } ) ; <nl> } <nl> } <nl> TestStructure s1 = new TestStructure ( ) ; <nl> @ @ - 1540 , 7 + 1559 , 7 @ @ public class StructureTest extends TestCase { <nl> public byte first ; <nl> public int second ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " first " , " second " } ) ; <nl> + return Arrays . asList ( new String [ ] { " first " , " second " } ) ; <nl> } <nl> } <nl> TestStructure s1 = new TestStructure ( ) ; <nl> @ @ - 1559 , 7 + 1578 , 7 @ @ public class StructureTest extends TestCase { <nl> public int unique ; <nl> public TestStructureByRef s ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " unique " , " s " } ) ; <nl> + return Arrays . asList ( new String [ ] { " unique " , " s " } ) ; <nl> } <nl> } <nl> TestStructureByRef s = new TestStructureByRef ( ) ; <nl> @ @ - 1592 , 7 + 1611 , 7 @ @ public class StructureTest extends TestCase { <nl> public CyclicTestStructure ( ) { } <nl> public CyclicTestStructure . ByReference next ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " next " } ) ; <nl> + return Arrays . asList ( new String [ ] { " next " } ) ; <nl> } <nl> } <nl> public void testCyclicRead ( ) { <nl> @ @ - 1618 , 7 + 1637 , 7 @ @ public class StructureTest extends TestCase { <nl> class TestStructure extends Structure { <nl> public int field ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field " } ) ; <nl> } <nl> public TestStructure ( Pointer p ) { <nl> super ( p ) ; <nl> @ @ - 1637 , 7 + 1656 , 7 @ @ public class StructureTest extends TestCase { <nl> public int intField ; <nl> public byte [ ] arrayField = new byte [ 256 ] ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " intField " , " arrayField " } ) ; <nl> + return Arrays . asList ( new String [ ] { " intField " , " arrayField " } ) ; <nl> } <nl> public TestStructure ( Pointer p ) { <nl> super ( p ) ; <nl> @ @ - 1676 , 7 + 1695 , 7 @ @ public class StructureTest extends TestCase { <nl> public ByReference [ ] array = new ByReference [ 13 ] ; <nl> public int value2 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " value1 " , " array " , " value2 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " value1 " , " array " , " value2 " } ) ; <nl> } <nl> <nl> public static class ByReference extends TestByReferenceArrayField implements Structure . ByReference { } <nl> @ @ - 1703 , 7 + 1722 , 7 @ @ public class StructureTest extends TestCase { <nl> class TestStructure extends Structure { <nl> public int field ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field " } ) ; <nl> } <nl> public TestStructure ( ) { } <nl> public TestStructure ( Pointer p ) { super ( p ) ; read ( ) ; } <nl> @ @ - 1720 , 7 + 1739 , 7 @ @ public class StructureTest extends TestCase { <nl> class TestStructure extends Structure { <nl> public int field ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field " } ) ; <nl> } <nl> } <nl> Structure ts = new TestStructure ( ) ; ts . ensureAllocated ( ) ; <nl> @ @ - 1728 , 12 + 1747 , 12 @ @ public class StructureTest extends TestCase { <nl> <nl> assertSame ( " Structure layout not cached " , ts . fields ( ) , ts2 . fields ( ) ) ; <nl> } <nl> - <nl> + <nl> public void testStructureLayoutVariableNoCache ( ) { <nl> class TestStructure extends Structure { <nl> public byte [ ] variable ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " variable " } ) ; <nl> + return Arrays . asList ( new String [ ] { " variable " } ) ; <nl> } <nl> public TestStructure ( int size ) { <nl> this . variable = new byte [ size ] ; <nl> @ @ - 1767 , 7 + 1786 , 7 @ @ public class StructureTest extends TestCase { <nl> class TestStructure extends Structure { <nl> public boolean field ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field " } ) ; <nl> } <nl> public TestStructure ( ) { <nl> super ( m ) ; <nl> @ @ - 1788 , 7 + 1807 , 7 @ @ public class StructureTest extends TestCase { <nl> public byte first ; <nl> public int second ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " first " , " second " } ) ; <nl> + return Arrays . asList ( new String [ ] { " first " , " second " } ) ; <nl> } <nl> public TestStructure ( ) { <nl> setAlignType ( ALIGN _ NONE ) ; <nl> @ @ - 1851 , 7 + 1870 , 7 @ @ public class StructureTest extends TestCase { <nl> super ( mapper ) ; <nl> } <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " b " , " s " , " p0 " , " p1 " , " p2 " , " p3 " , " p4 " , " p5 " , " p6 " , " p7 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " b " , " s " , " p0 " , " p1 " , " p2 " , " p3 " , " p4 " , " p5 " , " p6 " , " p7 " } ) ; <nl> } <nl> } <nl> Structure s = new TestStructure ( ) ; <nl> diff - - git a / test / com / sun / jna / UnionTest . java b / test / com / sun / jna / UnionTest . java <nl> index 579c26c . . 6f2d0d0 100644 <nl> - - - a / test / com / sun / jna / UnionTest . java <nl> + + + b / test / com / sun / jna / UnionTest . java <nl> @ @ - 1 , 14 + 1 , 14 @ @ <nl> / * Copyright ( c ) 2007 Timothy Wall , All Rights Reserved <nl> - * <nl> + * <nl> * This library is free software ; you can redistribute it and / or <nl> * modify it under the terms of the GNU Lesser General Public <nl> * License as published by the Free Software Foundation ; either <nl> * version 2 . 1 of the License , or ( at your option ) any later version . <nl> - * <nl> + * <nl> * This library is distributed in the hope that it will be useful , <nl> * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> + * Lesser General Public License for more details . <nl> * / <nl> package com . sun . jna ; <nl> <nl> @ @ - 23 , 22 + 23 , 22 @ @ public class UnionTest extends TestCase { <nl> public static class TestStructure extends Structure { <nl> public String value ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " value " } ) ; <nl> + return Arrays . asList ( new String [ ] { " value " } ) ; <nl> } <nl> } <nl> - <nl> + <nl> public static class BigTestStructure extends Structure { <nl> public long field1 ; <nl> public long field2 ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " field1 " , " field2 " } ) ; <nl> + return Arrays . asList ( new String [ ] { " field1 " , " field2 " } ) ; <nl> } <nl> } <nl> - <nl> + <nl> public static class IntStructure extends Structure { <nl> public int value ; <nl> protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( new String [ ] { " value " } ) ; <nl> + return Arrays . asList ( new String [ ] { " value " } ) ; <nl> } <nl> } <nl> <nl> @ @ - 59 , 7 + 59 , 7 @ @ public class UnionTest extends TestCase { <nl> public WString wstring ; <nl> public Pointer pointer ; <nl> } <nl> - <nl> + <nl> public static class StructUnion extends Union { <nl> public int intField ; <nl> public TestStructure testStruct ; <nl> @ @ - 69 , 31 + 69 , 33 @ @ public class UnionTest extends TestCase { <nl> <nl> public void testCalculateSize ( ) { <nl> Union u = new SizedUnion ( ) ; <nl> + assertEquals ( " Wrong union size : " + u , 16 , u . size ( ) ) ; <nl> assertEquals ( " Union should be size of largest field " , <nl> new BigTestStructure ( ) . size ( ) , u . size ( ) ) ; <nl> } <nl> <nl> public void testFieldOffsets ( ) { <nl> StructUnion u = new StructUnion ( ) ; <nl> + assertEquals ( " Wrong union size : " + u , Pointer . SIZE , u . size ( ) ) ; <nl> u . setType ( u . testStruct . getClass ( ) ) ; <nl> u . write ( ) ; <nl> - assertEquals ( " Wrong struct member base address " , <nl> + assertEquals ( " Wrong struct member base address " , <nl> u . getPointer ( ) , u . testStruct . getPointer ( ) ) ; <nl> u . setType ( u . intStruct . getClass ( ) ) ; <nl> u . write ( ) ; <nl> - assertEquals ( " Wrong struct member base address ( 2 ) " , <nl> + assertEquals ( " Wrong struct member base address ( 2 ) " , <nl> u . getPointer ( ) , u . intStruct . getPointer ( ) ) ; <nl> } <nl> <nl> public void testWriteUnion ( ) { <nl> SizedUnion u = new SizedUnion ( ) ; <nl> - final int VALUE = 0x12345678 ; <nl> + final int VALUE = 0x12345678 ; <nl> u . intField = VALUE ; <nl> u . setType ( int . class ) ; <nl> u . write ( ) ; <nl> assertEquals ( " Wrong value written " , VALUE , u . getPointer ( ) . getInt ( 0 ) ) ; <nl> } <nl> - <nl> + <nl> public void testReadUnion ( ) { <nl> SizedUnion u = new SizedUnion ( ) ; <nl> final int VALUE = 0x12345678 ; <nl> @ @ - 109 , 11 + 111 , 12 @ @ public class UnionTest extends TestCase { <nl> assertNull ( " Unselected String should be null " , u . string ) ; <nl> assertNull ( " Unselected WString should be null " , u . wstring ) ; <nl> } <nl> - <nl> + <nl> public void testWriteTypedUnion ( ) { <nl> final int VALUE = 0x12345678 ; <nl> / / write an instance of a direct union class to memory <nl> StructUnion u = new StructUnion ( ) ; <nl> + assertEquals ( " Wrong union size : " + u , Pointer . SIZE , u . size ( ) ) ; <nl> IntStructure intStruct = new IntStructure ( ) ; <nl> intStruct . value = VALUE ; <nl> u . setTypedValue ( intStruct ) ; <nl> @ @ - 138 , 6 + 141 , 7 @ @ public class UnionTest extends TestCase { <nl> <nl> public void testReadTypedUnion ( ) { <nl> StructUnion u = new StructUnion ( ) ; <nl> + assertEquals ( " Wrong union size : " + u , Pointer . SIZE , u . size ( ) ) ; <nl> final int VALUE = 0x12345678 ; <nl> u . getPointer ( ) . setInt ( 0 , VALUE ) ; <nl> assertEquals ( " int structure not read properly " , VALUE , ( ( IntStructure ) u . getTypedValue ( IntStructure . class ) ) . value ) ; <nl> @ @ - 145 , 29 + 149 , 34 @ @ public class UnionTest extends TestCase { <nl> <nl> public void testReadTypeInfo ( ) { <nl> SizedUnion u = new SizedUnion ( ) ; <nl> + assertEquals ( " Wrong union size : " + u , 16 , u . size ( ) ) ; <nl> + assertNotNull ( " Type information is missing for union field of type " + BigTestStructure . class , Structure . getTypeInfo ( BigTestStructure . class ) ) ; <nl> + assertNotNull ( " Type information is missing for union instance " , u . getTypeInfo ( ) ) ; <nl> if ( Native . POINTER _ SIZE = = 4 ) { <nl> - assertEquals ( " Type size should be that of longest field if no field active " , <nl> + assertEquals ( " Type size should be that of largest field if no field is active " , <nl> Structure . getTypeInfo ( BigTestStructure . class ) . getInt ( 0 ) , <nl> u . getTypeInfo ( ) . getInt ( 0 ) ) ; <nl> } <nl> else { <nl> - assertEquals ( " Type size should be that of longest field if no field active " , <nl> + assertEquals ( " Type size should be that of largest field if no field is active " , <nl> Structure . getTypeInfo ( BigTestStructure . class ) . getLong ( 0 ) , <nl> u . getTypeInfo ( ) . getLong ( 0 ) ) ; <nl> } <nl> u . setType ( int . class ) ; <nl> + assertNotNull ( " Type information is missing for union field of type " + BigTestStructure . class , Structure . getTypeInfo ( BigTestStructure . class ) ) ; <nl> + assertNotNull ( " Type information is missing for union instance after type set " , u . getTypeInfo ( ) ) ; <nl> if ( Native . POINTER _ SIZE = = 4 ) { <nl> - assertEquals ( " Type size should be that of longest field if field active " , <nl> + assertEquals ( " Type size should be that of largest field if any field is active " , <nl> Structure . getTypeInfo ( BigTestStructure . class ) . getInt ( 0 ) , <nl> u . getTypeInfo ( ) . getInt ( 0 ) ) ; <nl> } <nl> else { <nl> - assertEquals ( " Type size should be that of longest field if field active " , <nl> + assertEquals ( " Type size should be that of largest field if any field is active " , <nl> Structure . getTypeInfo ( BigTestStructure . class ) . getLong ( 0 ) , <nl> u . getTypeInfo ( ) . getLong ( 0 ) ) ; <nl> } <nl> } <nl> - <nl> + <nl> public void testArraysInUnion ( ) { <nl> class TestUnion extends Union { <nl> public byte [ ] bytes = new byte [ 16 ] ; <nl> @ @ - 175 , 6 + 184 , 7 @ @ public class UnionTest extends TestCase { <nl> public int [ ] ints = new int [ 4 ] ; <nl> } <nl> Union u = new TestUnion ( ) ; <nl> + assertEquals ( " Wrong union size : " + u , 16 , u . size ( ) ) ; <nl> u . setType ( byte [ ] . class ) ; <nl> u . setType ( short [ ] . class ) ; <nl> u . setType ( int [ ] . class ) ; <nl> @ @ - 183 , 9 + 193 , 10 @ @ public class UnionTest extends TestCase { <nl> public void testDuplicateFieldTypes ( ) { <nl> class TestUnion extends Union { <nl> public int field1 ; <nl> - public int field2 ; <nl> + public int field2 ; <nl> } <nl> TestUnion u = new TestUnion ( ) ; <nl> + assertEquals ( " Wrong union size : " + u , 4 , u . size ( ) ) ; <nl> u . setType ( " field1 " ) ; <nl> u . field1 = 42 ; <nl> u . write ( ) ;
NEAREST DIFF (one line): diff - - git a / jnalib / release - notes . html b / jnalib / release - notes . html <nl> index f28ff86 . . 5785afa 100755 <nl> - - - a / jnalib / release - notes . html <nl> + + + b / jnalib / release - notes . html <nl> @ @ - 4 , 6 + 4 , 7 @ @ <nl> < ul > <nl> < li > Enable build / run using IBM ' s J9 VM ( leonardo ) . <nl> < li > Make StdCallFunctionMapper attempt a leading underscore if the simpler mapping doesn ' t work . <nl> + < li > Allow Structure . read to overwrite final fields ( may not work on some 1 . 4 VMs ) . <nl> < / ul > <nl> < b > Bug Fixes < / b > < br > <nl> < ul > <nl> diff - - git a / jnalib / src / com / sun / jna / Structure . java b / jnalib / src / com / sun / jna / Structure . java <nl> index bf07e7d . . 70e4912 100644 <nl> - - - a / jnalib / src / com / sun / jna / Structure . java <nl> + + + b / jnalib / src / com / sun / jna / Structure . java <nl> @ @ - 37 , 6 + 37 , 14 @ @ import java . util . WeakHashMap ; <nl> * enclosing interface definition ( if any ) by using <nl> * { @ link Native # getStructureAlignment } and { @ link Native # getTypeMapper } . <nl> * < p > <nl> + * Structure fields corresponding to native fields < em > must < / em > be public . <nl> + * The may additionally have the following modifiers : < br > <nl> + * < ul > <nl> + * < li > < code > volatile < / code > JNA will not write the field unless specifically <nl> + * instructed to do so via { @ link # writeField ( String ) } . <nl> + * < li > < code > final < / code > JNA will overwrite the field via { @ link # read ( ) } , <nl> + * but otherwise the field is not modifiable from Java . <nl> + * < / ul > <nl> * NOTE : Strings are used to represent native C strings because usage of <nl> * < code > char * < / code > is generally more common than < code > wchar _ t * < / code > . <nl> * < p > <nl> @ @ - 689 , 6 + 697 , 9 @ @ public abstract class Structure { <nl> StructField structField = new StructField ( ) ; <nl> structField . isVolatile = Modifier . isVolatile ( modifiers ) ; <nl> structField . field = field ; <nl> + if ( Modifier . isFinal ( modifiers ) ) { <nl> + field . setAccessible ( true ) ; <nl> + } <nl> structField . name = field . getName ( ) ; <nl> structField . type = type ; <nl> <nl> diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html <nl> index 0b853a8 . . 9e03dce 100644 <nl> - - - a / jnalib / src / com / sun / jna / overview . html <nl> + + + b / jnalib / src / com / sun / jna / overview . html <nl> @ @ - 528 , 6 + 528 , 37 @ @ native memory , call { @ link com . sun . jna . Structure # read ( ) } ( to update the entire <nl> structure ) or { @ link com . sun . jna . Structure # readField ( String ) <nl> data . readField ( " refCount " ) } ( to update just the < code > refCount < / code > field ) . <nl> <nl> + < h4 > Read - only fields < / h4 > <nl> + If you want to absolutely prevent Java code from modifying <nl> + a < code > Structure < / code > ' s contents , you may mark its <nl> + fields < code > final < / code > . Structure reads can still overwrite the values <nl> + based on native memory contents , but no Java code will be able to modify any <nl> + of the fields . <nl> + < blockquote > < code > < pre > <nl> + class ReadOnly extends com . sun . jna . Structure { <nl> + / / Do not initialize the field here , or the compiler will inline the value ! <nl> + public final int refCount ; <nl> + { <nl> + / / Initialize fields here , to ensure the values are not inlined <nl> + refCount = - 1 ; <nl> + read ( ) ; <nl> + / / refCount might now have a different value <nl> + } <nl> + } <nl> + . . . <nl> + ReadOnly ro = new ReadOnly ( ) ; <nl> + / / Will not compile ! <nl> + ro . refCount = 0 ; <nl> + < / pre > < / code > < / blockquote > <nl> + <nl> + Make certain you attend to the following : <nl> + < ol > <nl> + < li > All final fields should be initialized in the constructor . <nl> + < li > If you call Structure . read ( ) from anywhere but the constructor , keep in <nl> + mind that the compiler and / or hotspot will be assuming field values will not <nl> + change across that function call . <nl> + < / ol > <nl> + <nl> < a name = " unions " > < / a > <nl> < h3 > Unions < / h3 > <nl> Unions are a special type of Structure . Each declared field within the union <nl> diff - - git a / jnalib / test / com / sun / jna / StructureTest . java b / jnalib / test / com / sun / jna / StructureTest . java <nl> index a2ce566 . . 37738f6 100644 <nl> - - - a / jnalib / test / com / sun / jna / StructureTest . java <nl> + + + b / jnalib / test / com / sun / jna / StructureTest . java <nl> @ @ - 745 , 4 + 745 , 17 @ @ public class StructureTest extends TestCase { <nl> public void testNativeMappedInByValue ( ) { <nl> new TestNativeMappedInStructure . ByValue ( ) ; <nl> } <nl> + <nl> + public static class ROStructure extends Structure { <nl> + public final int field ; <nl> + { <nl> + field = 0 ; <nl> + getPointer ( ) . setInt ( 0 , 42 ) ; <nl> + read ( ) ; <nl> + } <nl> + } <nl> + public void testReadOnlyField ( ) { <nl> + ROStructure s = new ROStructure ( ) ; <nl> + assertEquals ( " Field value should be writable from native " , 42 , s . field ) ; <nl> + } <nl> } <nl> \ No newline at end of file

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 93ca4ce . . 0a57637 100755 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 18 , 6 + 18 , 7 @ @ Bug Fixes 
 * [ # 215 ] ( https : / / github . com / twall / jna / issues / 215 ) : Force use of XSI ` strerror _ r ` on linux - [ LionelCons ] ( https : / / github . com / LionelCons ) . 
 * [ # 214 ] ( https : / / github . com / twall / jna / issues / 214 ) : Don ' t map library names when an absolute path is provided - [ @ twall ] ( https : / / github . com / twall ) . 
 * [ # 218 ] ( https : / / github . com / twall / jna / issues / 218 ) : Explicitly handle broken Android SecurityManager implementation - [ @ twall ] ( https : / / github . com / twall ) . 
 + * [ # 223 ] ( https : / / github . com / twall / jna / issues / 223 ) : Fix layout / size derivation for unions - [ @ twall ] ( https : / / github . com / twall ) . 
 
 Release 3 . 5 . 2 
 = = = = = = = = = = = = = 
 diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java 
 index 68742f1 . . 8431799 100644 
 - - - a / src / com / sun / jna / Structure . java 
 + + + b / src / com / sun / jna / Structure . java 
 @ @ - 114 , 7 + 114 , 7 @ @ public abstract class Structure { 
 String arch = System . getProperty ( " os . arch " ) . toLowerCase ( ) ; 
 isPPC = " ppc " . equals ( arch ) | | " powerpc " . equals ( arch ) ; 
 isSPARC = " sparc " . equals ( arch ) ; 
 - 	 isARM = arch . startsWith ( " arm " ) ; 
 + isARM = arch . startsWith ( " arm " ) ; 
 } 
 
 / * * Use the platform default alignment . * / 
 @ @ - 216 , 7 + 216 , 7 @ @ public abstract class Structure { 
 return typeMapper ; 
 } 
 
 - / * * Initialize the type mapper for this structure . 
 + / * * Initialize the type mapper for this structure . 
 * If < code > null < / code > , the default mapper for the 
 * defining class will be used . 
 * / 
 @ @ - 871 , 7 + 871 , 7 @ @ public abstract class Structure { 
 return list ; 
 } 
 
 - / * * Returns all field names ( sorted ) provided so far by 
 + / * * Returns all field names ( sorted ) provided so far by 
 { @ link # getFieldOrder } 
 @ param force set if results are required immediately 
 @ return null if not yet able to provide fields , and force is false . 
 @ @ - 899 , 7 + 899 , 7 @ @ public abstract class Structure { 
 
 Set orderedNames = new HashSet ( fieldOrder ) ; 
 if ( ! orderedNames . equals ( names ) ) { 
 - throw new Error ( " Structure . getFieldOrder ( ) on " + getClass ( ) 
 + throw new Error ( " Structure . getFieldOrder ( ) on " + getClass ( ) 
 + " returns names ( " 
 + sort ( fieldOrder ) 
 + " ) which do not match declared field names ( " 
 @ @ - 991 , 6 + 991 , 8 @ @ public abstract class Structure { 
 private int alignType = ALIGN _ DEFAULT ; 
 private TypeMapper typeMapper ; 
 private boolean variable ; 
 + / / For unions only , field on which the union FFI type info is based 
 + private StructField typeInfoField ; 
 } 
 
 private void validateField ( String name , Class type ) { 
 @ @ - 1029 , 7 + 1031 , 6 @ @ public abstract class Structure { 
 members . 
 * / 
 private LayoutInfo deriveLayout ( boolean force , boolean avoidFFIType ) { 
 - 
 int calculatedSize = 0 ; 
 List fields = getFields ( force ) ; 
 if ( fields = = null ) { 
 @ @ - 1139 , 11 + 1140 , 24 @ @ public abstract class Structure { 
 if ( ( calculatedSize % fieldAlignment ) ! = 0 ) { 
 calculatedSize + = fieldAlignment - ( calculatedSize % fieldAlignment ) ; 
 } 
 - structField . offset = calculatedSize ; 
 - calculatedSize + = structField . size ; 
 + if ( this instanceof Union ) { 
 + structField . offset = 0 ; 
 + calculatedSize = Math . max ( calculatedSize , structField . size ) ; 
 + } 
 + else { 
 + structField . offset = calculatedSize ; 
 + calculatedSize + = structField . size ; 
 + } 
 
 / / Save the field in our list 
 info . fields . put ( structField . name , structField ) ; 
 + 
 + if ( info . typeInfoField = = null 
 + | | info . typeInfoField . size < structField . size 
 + | | ( info . typeInfoField . size = = structField . size 
 + & & Structure . class . isAssignableFrom ( structField . type ) ) ) { 
 + info . typeInfoField = structField ; 
 + } 
 } 
 
 if ( calculatedSize > 0 ) { 
 @ @ - 1504 , 7 + 1518 , 7 @ @ public abstract class Structure { 
 This is typically most effective when a native call populates a large 
 structure and you only need a few fields out of it . After the native 
 call you can call { @ link # readField ( String ) } on only the fields of 
 - interest . 
 + interest . 
 * / 
 public void setAutoSynch ( boolean auto ) { 
 setAutoRead ( auto ) ; 
 @ @ - 1544 , 7 + 1558 , 7 @ @ public abstract class Structure { 
 return FFIType . get ( obj ) ; 
 } 
 
 - / * * Called from native code only ; same as { @ link 
 + / * * Called from native code only ; same as { @ link 
 * # newInstance ( Class , Pointer ) } , except that it additionally performs 
 * { @ link # conditionalAutoRead ( ) } . 
 * / 
 @ @ - 1619 , 6 + 1633 , 20 @ @ public abstract class Structure { 
 } 
 } 
 
 + / * * Keep track of the largest aggregate field of the union to use for 
 + * FFI type information . 
 + * / 
 + StructField typeInfoField ( ) { 
 + LayoutInfo info ; 
 + synchronized ( layoutInfo ) { 
 + info = ( LayoutInfo ) layoutInfo . get ( getClass ( ) ) ; 
 + } 
 + if ( info ! = null ) { 
 + return info . typeInfoField ; 
 + } 
 + return null ; 
 + } 
 + 
 static class StructField extends Object { 
 public String name ; 
 public Class type ; 
 @ @ - 1704 , 7 + 1732 , 7 @ @ public abstract class Structure { 
 ref . ensureAllocated ( true ) ; 
 
 if ( ref instanceof Union ) { 
 - StructField sf = ( ( Union ) ref ) . biggestField ; 
 + StructField sf = ( ( Union ) ref ) . typeInfoField ( ) ; 
 els = new Pointer [ ] { 
 get ( ref . getFieldValue ( sf . field ) , sf . type ) , 
 null , 
 diff - - git a / src / com / sun / jna / Union . java b / src / com / sun / jna / Union . java 
 index d899e81 . . d08b50d 100644 
 - - - a / src / com / sun / jna / Union . java 
 + + + b / src / com / sun / jna / Union . java 
 @ @ - 1 , 14 + 1 , 14 @ @ 
 / * Copyright ( c ) 2007 - 2012 Timothy Wall , All Rights Reserved 
 - * 
 + * 
 * This library is free software ; you can redistribute it and / or 
 * modify it under the terms of the GNU Lesser General Public 
 * License as published by the Free Software Foundation ; either 
 * version 2 . 1 of the License , or ( at your option ) any later version . 
 - * 
 + * 
 * This library is distributed in the hope that it will be useful , 
 * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 + * Lesser General Public License for more details . 
 * / 
 package com . sun . jna ; 
 
 @ @ - 20 , 18 + 20 , 17 @ @ import java . util . List ; 
 / * * Represents a native union . When writing to native memory , the field 
 * corresponding to the type passed to { @ link # setType } will be written 
 * to native memory . Upon reading from native memory , Structure , String , 
 - * or WString fields will < em > not < / em > be initialized unless they are 
 + * or WString fields will < em > not < / em > be initialized unless they are 
 * the current field as identified by a call to { @ link # setType } . The current 
 * field is always unset by default to avoid accidentally attempting to read 
 - * a field that is not valid . In the case of a String , for instance , an 
 + * a field that is not valid . In the case of a String , for instance , an 
 * invalid pointer may result in a memory fault when attempting to initialize 
 - * the String . 
 + * the String . 
 * / 
 public abstract class Union extends Structure { 
 private StructField activeField ; 
 - StructField biggestField ; 
 - 
 - / * * Create a Union whose size and alignment will be calculated 
 + 
 + / * * Create a Union whose size and alignment will be calculated 
 * automatically . 
 * / 
 protected Union ( ) { } 
 @ @ - 65 , 10 + 64 , 10 @ @ public abstract class Union extends Structure { 
 return list ; 
 } 
 
 - / * * Indicates by type which field will be used to write to native memory . 
 + / * * Indicates by type which field will be used to write to native memory . 
 * If there are multiple fields of the same type , use { @ link 
 * # setType ( String ) } instead with the field name . 
 - * @ throws IllegalArgumentException if the type does not correspond to 
 + * @ throws IllegalArgumentException if the type does not correspond to 
 * any declared union field . 
 * / 
 public void setType ( Class type ) { 
 @ @ - 82 , 7 + 81 , 7 @ @ public abstract class Union extends Structure { 
 } 
 throw new IllegalArgumentException ( " No field of type " + type + " in " + this ) ; 
 } 
 - 
 + 
 / * * 
 * Indicates which field will be used to write to native memory . 
 * @ throws IllegalArgumentException if the name does not correspond to 
 @ @ - 199 , 11 + 198 , 11 @ @ public abstract class Union extends Structure { 
 } 
 
 / * * Avoid reading pointer - based fields and structures unless explicitly 
 - * selected . Structures may contain pointer - based fields which can 
 + * selected . Structures may contain pointer - based fields which can 
 * crash the VM if not properly initialized . 
 * / 
 Object readField ( StructField field ) { 
 - if ( field = = activeField 
 + if ( field = = activeField 
 | | ( ! Structure . class . isAssignableFrom ( field . type ) 
 & & ! String . class . isAssignableFrom ( field . type ) 
 & & ! WString . class . isAssignableFrom ( field . type ) ) ) { 
 @ @ - 211 , 56 + 210 , 12 @ @ public abstract class Union extends Structure { 
 } 
 / / Field not accessible 
 / / TODO : read structure , to the extent possible ; need a " recursive " 
 - / / flag to " read " 
 + / / flag to " read " to indicate we want to avoid pointer - based fields 
 return null ; 
 } 
 - 
 - / * * Adjust the size to be the size of the largest element , and ensure 
 - * all fields begin at offset zero . 
 - * / 
 - int calculateSize ( boolean force , boolean avoidFFIType ) { 
 - int size = super . calculateSize ( force , avoidFFIType ) ; 
 - if ( size ! = CALCULATE _ SIZE ) { 
 - int fsize = 0 ; 
 - for ( Iterator i = fields ( ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
 - StructField f = ( StructField ) i . next ( ) ; 
 - f . offset = 0 ; 
 - if ( f . size > fsize 
 - / / Prefer aggregate types to simple types , since they 
 - / / will have more complex packing rules ( some platforms 
 - / / have specific methods for packing small structs into 
 - / / registers , which may not match the packing of bytes 
 - / / for a primitive type ) . 
 - | | ( f . size = = fsize 
 - & & Structure . class . isAssignableFrom ( f . type ) ) ) { 
 - fsize = f . size ; 
 - biggestField = f ; 
 - } 
 - } 
 - size = calculateAlignedSize ( fsize ) ; 
 - if ( size > 0 ) { 
 - / / Update native FFI type information , if needed 
 - if ( this instanceof ByValue & & ! avoidFFIType ) { 
 - getTypeInfo ( ) ; 
 - } 
 - } 
 - } 
 - return size ; 
 - } 
 + 
 / * * All fields are considered the " first " element . * / 
 protected int getNativeAlignment ( Class type , Object value , boolean isFirstElement ) { 
 return super . getNativeAlignment ( type , value , true ) ; 
 } 
 - 
 - / * * Avoid calculating type information until we know our biggest field . 
 - * Return type information for the largest field to ensure all available 
 - * bits are used . 
 - * / 
 - Pointer getTypeInfo ( ) { 
 - if ( biggestField = = null ) { 
 - / / Not calculated yet 
 - return null ; 
 - } 
 - return super . getTypeInfo ( ) ; 
 - } 
 } 
 diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java 
 index 2c4f21c . . 482e069 100644 
 - - - a / test / com / sun / jna / StructureTest . java 
 + + + b / test / com / sun / jna / StructureTest . java 
 @ @ - 88 , 7 + 88 , 7 @ @ public class StructureTest extends TestCase { 
 public int f2 ; 
 public int f3 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " f0 " , " f1 " , " f2 " , " f3 " } ) ; 
 + return Arrays . asList ( new String [ ] { " f0 " , " f1 " , " f2 " , " f3 " } ) ; 
 } 
 } 
 
 @ @ - 151 , 7 + 151 , 7 @ @ public class StructureTest extends TestCase { 
 public float f ; 
 public double d ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " b " , " s " , " i " , " l " , " f " , " d " } ) ; 
 + return Arrays . asList ( new String [ ] { " b " , " s " , " i " , " l " , " f " , " d " } ) ; 
 } 
 } 
 Structure s = new TestStructure ( ) ; 
 @ @ - 170 , 7 + 170 , 7 @ @ public class StructureTest extends TestCase { 
 public float f ; 
 public double d ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " b " , " s " , " i " , " l " , " f " , " d " } ) ; 
 + return Arrays . asList ( new String [ ] { " b " , " s " , " i " , " l " , " f " , " d " } ) ; 
 } 
 } 
 Structure s = new TestStructure ( ) ; 
 @ @ - 195 , 21 + 195 , 21 @ @ public class StructureTest extends TestCase { 
 public byte field0 = 0x01 ; 
 public short field1 = 0x0202 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; 
 + return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; 
 } 
 } 
 public static class TestStructure1 extends FilledStructure { 
 public byte field0 = 0x01 ; 
 public int field1 = 0x02020202 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; 
 + return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; 
 } 
 } 
 public static class TestStructure2 extends FilledStructure { 
 public short field0 = 0x0101 ; 
 public int field1 = 0x02020202 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; 
 + return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; 
 } 
 } 
 public static class TestStructure3 extends FilledStructure { 
 @ @ - 217 , 7 + 217 , 7 @ @ public class StructureTest extends TestCase { 
 public short field1 = 0x0202 ; 
 public int field2 = 0x03030303 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field0 " , " field1 " , " field2 " } ) ; 
 + return Arrays . asList ( new String [ ] { " field0 " , " field1 " , " field2 " } ) ; 
 } 
 } 
 public static class TestStructure4 extends FilledStructure { 
 @ @ - 226 , 14 + 226 , 14 @ @ public class StructureTest extends TestCase { 
 public int field2 = 0x03030303 ; 
 public long field3 = 0x0404040404040404L ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field0 " , " field1 " , " field2 " , " field3 " } ) ; 
 + return Arrays . asList ( new String [ ] { " field0 " , " field1 " , " field2 " , " field3 " } ) ; 
 } 
 } 
 public static class TestStructure5 extends FilledStructure { 
 public long field0 = 0x0101010101010101L ; 
 public byte field1 = 0x02 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; 
 + return Arrays . asList ( new String [ ] { " field0 " , " field1 " } ) ; 
 } 
 } 
 public interface SizeTest extends Library { 
 @ @ - 354 , 7 + 354 , 7 @ @ public class StructureTest extends TestCase { 
 + + allocations ; 
 } 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " x " , " y " } ) ; 
 + return Arrays . asList ( new String [ ] { " x " , " y " } ) ; 
 } 
 } 
 public void testStructureField ( ) { 
 @ @ - 362 , 7 + 362 , 7 @ @ public class StructureTest extends TestCase { 
 public PublicTestStructure s1 , s2 ; 
 public int after ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " s1 " , " s2 " , " after " } ) ; 
 + return Arrays . asList ( new String [ ] { " s1 " , " s2 " , " after " } ) ; 
 } 
 } 
 TestStructure s = new TestStructure ( ) ; 
 @ @ - 386 , 6 + 386 , 25 @ @ public class StructureTest extends TestCase { 
 s . s2 . getPointer ( ) ) ; 
 } 
 
 + static class TestUnion extends Union { 
 + public int u _ int ; 
 + public float u _ float ; 
 + public double u _ double ; 
 + } 
 + public void testUnionField ( ) { 
 + class TestStructure extends Structure { 
 + public long s _ long ; 
 + public TestUnion s _ union ; 
 + public int s _ int ; 
 + protected List getFieldOrder ( ) { 
 + return Arrays . asList ( new String [ ] { " s _ long " , " s _ union " , " s _ int " } ) ; 
 + } 
 + } 
 + TestStructure s = new TestStructure ( ) ; 
 + assertEquals ( " Wrong structure size " , 24 , s . size ( ) ) ; 
 + assertEquals ( " Wrong union size " , 8 , s . s _ union . size ( ) ) ; 
 + } 
 + 
 public static class NonAllocatingTestStructure extends PublicTestStructure { 
 public NonAllocatingTestStructure ( ) { } 
 public NonAllocatingTestStructure ( Pointer p ) { super ( p ) ; read ( ) ; } 
 @ @ - 394 , 16 + 413 , 16 @ @ public class StructureTest extends TestCase { 
 } 
 } 
 
 - / / TODO : add ' l newInstance ( Pointer ) tests : 
 + / / TODO : add ' l newInstance ( Pointer ) tests : 
 / / NOTE : ensure structure - by - value respected ( no more flag on newjavastructure ) 
 - / / native call ( direct mode ) 
 + / / native call ( direct mode ) 
 / / getNativeAlignment 
 public void testStructureFieldAvoidsSeparateMemoryAllocation ( ) { 
 class TestStructure extends Structure { 
 public NonAllocatingTestStructure s1 ; 
 public TestStructure ( ) { } 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " s1 " } ) ; 
 + return Arrays . asList ( new String [ ] { " s1 " } ) ; 
 } 
 } 
 TestStructure ts = new TestStructure ( ) ; 
 @ @ - 434 , 8 + 453 , 8 @ @ public class StructureTest extends TestCase { 
 / / initialized array elements 
 public PublicTestStructure [ ] inner2 = ( PublicTestStructure [ ] ) 
 new PublicTestStructure ( ) . toArray ( 2 ) ; 
 - protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " inner " , " inner2 " } ) ; 
 + protected List getFieldOrder ( ) { 
 + return Arrays . asList ( new String [ ] { " inner " , " inner2 " } ) ; 
 } 
 } 
 TestStructure s = new TestStructure ( ) ; 
 @ @ - 530 , 7 + 549 , 7 @ @ public class StructureTest extends TestCase { 
 public double [ ] da = new double [ 3 ] ; 
 public PublicTestStructure nested ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " z " , " b " , " c " , " s " , " i " , " l " , " f " , " d " , " ba " , " ca " , " sa " , " ia " , " la " , " fa " , " da " , " nested " } ) ; 
 + return Arrays . asList ( new String [ ] { " z " , " b " , " c " , " s " , " i " , " l " , " f " , " d " , " ba " , " ca " , " sa " , " ia " , " la " , " fa " , " da " , " nested " } ) ; 
 } 
 } 
 TestStructure s = new TestStructure ( ) ; 
 @ @ - 624 , 8 + 643 , 8 @ @ public class StructureTest extends TestCase { 
 class TestStructure extends Structure { 
 public int i ; 
 public NativeLong l ; 
 - protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " i " , " l " } ) ; 
 + protected List getFieldOrder ( ) { 
 + return Arrays . asList ( new String [ ] { " i " , " l " } ) ; 
 } 
 } 
 TestStructure s = new TestStructure ( ) ; 
 @ @ - 672 , 14 + 691 , 14 @ @ public class StructureTest extends TestCase { 
 
 public static class BadFieldStructure extends Structure { 
 public Object badField ; 
 - protected List getFieldOrder ( ) { 
 + protected List getFieldOrder ( ) { 
 return Arrays . asList ( new String [ ] { " badField " } ) ; 
 } 
 } 
 public void testUnsupportedField ( ) { 
 class BadNestedStructure extends Structure { 
 public BadFieldStructure badStruct = new BadFieldStructure ( ) ; 
 - protected List getFieldOrder ( ) { 
 + protected List getFieldOrder ( ) { 
 return Arrays . asList ( new String [ ] { " badStruct " } ) ; 
 } 
 } 
 @ @ - 881 , 7 + 900 , 7 @ @ public class StructureTest extends TestCase { 
 assertTrue ( " Read should preserve structure memory " , 
 inner . getPointer ( ) instanceof Memory ) ; 
 } 
 - 
 + 
 public static class TestPointer extends PointerType { } 
 public void testPreservePointerFields ( ) { 
 class TestStructure extends Structure { 
 @ @ - 925 , 7 + 944 , 7 @ @ public class StructureTest extends TestCase { 
 assertEquals ( " String field should not be overwritten " , m2 , s . getPointer ( ) . getPointer ( Pointer . SIZE ) ) ; 
 } 
 
 - / / Ensure string cacheing doesn ' t interfere with wrapped structure writes . 
 + / / Ensure string cacheing doesn ' t interfere with wrapped structure writes . 
 public static class StructureFromNative extends Structure { 
 public String s ; 
 protected List getFieldOrder ( ) { 
 @ @ - 938 , 7 + 957 , 7 @ @ public class StructureTest extends TestCase { 
 public StructureFromNative ( ) { 
 } 
 } 
 - 
 + 
 public void testInitializeStructureFieldWithStrings ( ) { 
 class ContainingStructure extends Structure { 
 public StructureFromNative inner ; 
 @ @ - 1021 , 7 + 1040 , 7 @ @ public class StructureTest extends TestCase { 
 } 
 TestStructure s = new TestStructure ( ) ; 
 s . field = new PublicTestStructure . ByReference ( ) ; 
 - PublicTestStructure . ByReference [ ] array = 
 + PublicTestStructure . ByReference [ ] array = 
 ( PublicTestStructure . ByReference [ ] ) s . field . toArray ( 2 ) ; 
 final int VALUE = - 1 ; 
 array [ 1 ] . x = VALUE ; 
 @ @ - 1066 , 13 + 1085 , 13 @ @ public class StructureTest extends TestCase { 
 return Arrays . asList ( new String [ ] { " size " , " alignment " , " type " , " elements " } ) ; 
 } 
 public TestFFIType ( Pointer p ) { 
 - super ( p ) ; 
 + super ( p ) ; 
 read ( ) ; 
 assertTrue ( " Test FFIType type not initialized : " + this , this . type ! = 0 ) ; 
 
 / / Force libffi to explicitly calculate the size field of 
 / / this FFIType object 
 - int size = Native . initialize _ ffi _ type ( p . peer ) ; 
 + int size = Native . initialize _ ffi _ type ( p . peer ) ; 
 read ( ) ; 
 assertEquals ( " Test FFIType size improperly initialized : " + TestFFIType . this , size , TestFFIType . this . size . intValue ( ) ) ; 
 } 
 @ @ - 1123 , 7 + 1142 , 7 @ @ public class StructureTest extends TestCase { 
 public int intField ; 
 public PublicTestStructure inner ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " intField " , " inner " } ) ; 
 + return Arrays . asList ( new String [ ] { " intField " , " inner " } ) ; 
 } 
 } 
 TestStructure s = new TestStructure ( ) ; 
 @ @ - 1154 , 7 + 1173 , 7 @ @ public class StructureTest extends TestCase { 
 	 class TestStructure extends Structure { 
 public ByteByReference ref ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " ref " } ) ; 
 + return Arrays . asList ( new String [ ] { " ref " } ) ; 
 } 
 	 } 
 	 TestStructure s = new TestStructure ( ) ; 
 @ @ - 1171 , 7 + 1190 , 7 @ @ public class StructureTest extends TestCase { 
 	 class TestStructure extends Structure { 
 public ByteByReference ref ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " ref " } ) ; 
 + return Arrays . asList ( new String [ ] { " ref " } ) ; 
 } 
 	 } 
 	 TestStructure s = new TestStructure ( ) ; 
 @ @ - 1191 , 7 + 1210 , 7 @ @ public class StructureTest extends TestCase { 
 public static class ROStructure extends Structure { 
 public final int field ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field " } ) ; 
 + return Arrays . asList ( new String [ ] { " field " } ) ; 
 } 
 { 
 / / Initialize in ctor to avoid compiler replacing 
 @ @ - 1241 , 7 + 1260 , 7 @ @ public class StructureTest extends TestCase { 
 class TestStructure extends Structure { 
 public NativeLong [ ] longs = new NativeLong [ SIZE ] ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " longs " } ) ; 
 + return Arrays . asList ( new String [ ] { " longs " } ) ; 
 } 
 } 
 TestStructure s = new TestStructure ( ) ; 
 @ @ - 1277 , 7 + 1296 , 7 @ @ public class StructureTest extends TestCase { 
 public NativeLong nl = INITIAL ; 
 public NativeLong uninitialized ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " nl " , " uninitialized " } ) ; 
 + return Arrays . asList ( new String [ ] { " nl " , " uninitialized " } ) ; 
 } 
 } 
 TestStructure ts = new TestStructure ( ) ; 
 @ @ - 1300 , 7 + 1319 , 7 @ @ public class StructureTest extends TestCase { 
 class TestStructure extends Structure { 
 public int f1 , f2 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " f1 " , " f2 " } ) ; 
 + return Arrays . asList ( new String [ ] { " f1 " , " f2 " } ) ; 
 } 
 } 
 class TestStructure2 extends TestStructure { 
 @ @ - 1333 , 7 + 1352 , 7 @ @ public class StructureTest extends TestCase { 
 class TestStructure extends Structure { 
 public int f1 , f2 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " f1 " , " f2 " , " f3 " } ) ; 
 + return Arrays . asList ( new String [ ] { " f1 " , " f2 " , " f3 " } ) ; 
 } 
 } 
 try { 
 @ @ - 1387 , 7 + 1406 , 7 @ @ public class StructureTest extends TestCase { 
 return list ; 
 } 
 } 
 - 
 + 
 TestStructure s = new TestStructure ( ) ; 
 assertEquals ( " Wrong field order " , 
 Arrays . asList ( ORDER ) , s . getFieldOrder ( ) ) ; 
 @ @ - 1444 , 13 + 1463 , 13 @ @ public class StructureTest extends TestCase { 
 Structure s = new TestStructure ( ) ; 
 assertEquals ( " Wrong type mapper : " + s , mapper , s . getTypeMapper ( ) ) ; 
 } 
 - 
 + 
 public void testWriteWithNullBoxedPrimitives ( ) { 
 class TestStructure extends Structure { 
 public Boolean zfield ; 
 public Integer field ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " zfield " , " field " } ) ; 
 + return Arrays . asList ( new String [ ] { " zfield " , " field " } ) ; 
 } 
 } 
 TestStructure s = new TestStructure ( ) ; 
 @ @ - 1465 , 7 + 1484 , 7 @ @ public class StructureTest extends TestCase { 
 public int [ ] second = new int [ 4 ] ; 
 public Pointer [ ] third = new Pointer [ 4 ] ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " first " , " second " , " third " } ) ; 
 + return Arrays . asList ( new String [ ] { " first " , " second " , " third " } ) ; 
 } 
 } 
 class TestStructure extends Structure { 
 @ @ - 1492 , 7 + 1511 , 7 @ @ public class StructureTest extends TestCase { 
 assertTrue ( " Equals is not symmetric " , s2 . equals ( s1 ) ) ; 
 assertTrue ( " Equals is not transitive " , s1 . equals ( s2 ) & & s2 . equals ( s3 ) & & s1 . equals ( s3 ) ) ; 
 
 - 
 + 
 } 
 
 public void testStructureEqualsByValueByReference ( ) { 
 @ @ - 1501 , 7 + 1520 , 7 @ @ public class StructureTest extends TestCase { 
 public int [ ] second = new int [ 4 ] ; 
 public Pointer [ ] third = new Pointer [ 4 ] ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " first " , " second " , " third " } ) ; 
 + return Arrays . asList ( new String [ ] { " first " , " second " , " third " } ) ; 
 } 
 } 
 class ByReference extends TestStructure implements Structure . ByReference { } 
 @ @ - 1518 , 14 + 1537 , 14 @ @ public class StructureTest extends TestCase { 
 assertTrue ( " Equals is not symmetric ( ByValue ) " , s3 . equals ( s1 ) ) ; 
 assertTrue ( " Equals is not transitive ( ByReference / ByValue ) " , s1 . equals ( s2 ) & & s2 . equals ( s3 ) & & s1 . equals ( s3 ) ) ; 
 
 - 
 + 
 } 
 
 public void testStructureHashCodeMatchesEqualsTrue ( ) { 
 class TestStructure extends Structure { 
 public int first ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " first " } ) ; 
 + return Arrays . asList ( new String [ ] { " first " } ) ; 
 } 
 } 
 TestStructure s1 = new TestStructure ( ) ; 
 @ @ - 1540 , 7 + 1559 , 7 @ @ public class StructureTest extends TestCase { 
 public byte first ; 
 public int second ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " first " , " second " } ) ; 
 + return Arrays . asList ( new String [ ] { " first " , " second " } ) ; 
 } 
 } 
 TestStructure s1 = new TestStructure ( ) ; 
 @ @ - 1559 , 7 + 1578 , 7 @ @ public class StructureTest extends TestCase { 
 public int unique ; 
 public TestStructureByRef s ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " unique " , " s " } ) ; 
 + return Arrays . asList ( new String [ ] { " unique " , " s " } ) ; 
 } 
 } 
 TestStructureByRef s = new TestStructureByRef ( ) ; 
 @ @ - 1592 , 7 + 1611 , 7 @ @ public class StructureTest extends TestCase { 
 public CyclicTestStructure ( ) { } 
 public CyclicTestStructure . ByReference next ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " next " } ) ; 
 + return Arrays . asList ( new String [ ] { " next " } ) ; 
 } 
 } 
 public void testCyclicRead ( ) { 
 @ @ - 1618 , 7 + 1637 , 7 @ @ public class StructureTest extends TestCase { 
 class TestStructure extends Structure { 
 public int field ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field " } ) ; 
 + return Arrays . asList ( new String [ ] { " field " } ) ; 
 } 
 public TestStructure ( Pointer p ) { 
 super ( p ) ; 
 @ @ - 1637 , 7 + 1656 , 7 @ @ public class StructureTest extends TestCase { 
 public int intField ; 
 public byte [ ] arrayField = new byte [ 256 ] ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " intField " , " arrayField " } ) ; 
 + return Arrays . asList ( new String [ ] { " intField " , " arrayField " } ) ; 
 } 
 public TestStructure ( Pointer p ) { 
 super ( p ) ; 
 @ @ - 1676 , 7 + 1695 , 7 @ @ public class StructureTest extends TestCase { 
 public ByReference [ ] array = new ByReference [ 13 ] ; 
 public int value2 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " value1 " , " array " , " value2 " } ) ; 
 + return Arrays . asList ( new String [ ] { " value1 " , " array " , " value2 " } ) ; 
 } 
 
 public static class ByReference extends TestByReferenceArrayField implements Structure . ByReference { } 
 @ @ - 1703 , 7 + 1722 , 7 @ @ public class StructureTest extends TestCase { 
 class TestStructure extends Structure { 
 public int field ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field " } ) ; 
 + return Arrays . asList ( new String [ ] { " field " } ) ; 
 } 
 public TestStructure ( ) { } 
 public TestStructure ( Pointer p ) { super ( p ) ; read ( ) ; } 
 @ @ - 1720 , 7 + 1739 , 7 @ @ public class StructureTest extends TestCase { 
 class TestStructure extends Structure { 
 public int field ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field " } ) ; 
 + return Arrays . asList ( new String [ ] { " field " } ) ; 
 } 
 } 
 Structure ts = new TestStructure ( ) ; ts . ensureAllocated ( ) ; 
 @ @ - 1728 , 12 + 1747 , 12 @ @ public class StructureTest extends TestCase { 
 
 assertSame ( " Structure layout not cached " , ts . fields ( ) , ts2 . fields ( ) ) ; 
 } 
 - 
 + 
 public void testStructureLayoutVariableNoCache ( ) { 
 class TestStructure extends Structure { 
 public byte [ ] variable ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " variable " } ) ; 
 + return Arrays . asList ( new String [ ] { " variable " } ) ; 
 } 
 public TestStructure ( int size ) { 
 this . variable = new byte [ size ] ; 
 @ @ - 1767 , 7 + 1786 , 7 @ @ public class StructureTest extends TestCase { 
 class TestStructure extends Structure { 
 public boolean field ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field " } ) ; 
 + return Arrays . asList ( new String [ ] { " field " } ) ; 
 } 
 public TestStructure ( ) { 
 super ( m ) ; 
 @ @ - 1788 , 7 + 1807 , 7 @ @ public class StructureTest extends TestCase { 
 public byte first ; 
 public int second ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " first " , " second " } ) ; 
 + return Arrays . asList ( new String [ ] { " first " , " second " } ) ; 
 } 
 public TestStructure ( ) { 
 setAlignType ( ALIGN _ NONE ) ; 
 @ @ - 1851 , 7 + 1870 , 7 @ @ public class StructureTest extends TestCase { 
 super ( mapper ) ; 
 } 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " b " , " s " , " p0 " , " p1 " , " p2 " , " p3 " , " p4 " , " p5 " , " p6 " , " p7 " } ) ; 
 + return Arrays . asList ( new String [ ] { " b " , " s " , " p0 " , " p1 " , " p2 " , " p3 " , " p4 " , " p5 " , " p6 " , " p7 " } ) ; 
 } 
 } 
 Structure s = new TestStructure ( ) ; 
 diff - - git a / test / com / sun / jna / UnionTest . java b / test / com / sun / jna / UnionTest . java 
 index 579c26c . . 6f2d0d0 100644 
 - - - a / test / com / sun / jna / UnionTest . java 
 + + + b / test / com / sun / jna / UnionTest . java 
 @ @ - 1 , 14 + 1 , 14 @ @ 
 / * Copyright ( c ) 2007 Timothy Wall , All Rights Reserved 
 - * 
 + * 
 * This library is free software ; you can redistribute it and / or 
 * modify it under the terms of the GNU Lesser General Public 
 * License as published by the Free Software Foundation ; either 
 * version 2 . 1 of the License , or ( at your option ) any later version . 
 - * 
 + * 
 * This library is distributed in the hope that it will be useful , 
 * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 + * Lesser General Public License for more details . 
 * / 
 package com . sun . jna ; 
 
 @ @ - 23 , 22 + 23 , 22 @ @ public class UnionTest extends TestCase { 
 public static class TestStructure extends Structure { 
 public String value ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " value " } ) ; 
 + return Arrays . asList ( new String [ ] { " value " } ) ; 
 } 
 } 
 - 
 + 
 public static class BigTestStructure extends Structure { 
 public long field1 ; 
 public long field2 ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " field1 " , " field2 " } ) ; 
 + return Arrays . asList ( new String [ ] { " field1 " , " field2 " } ) ; 
 } 
 } 
 - 
 + 
 public static class IntStructure extends Structure { 
 public int value ; 
 protected List getFieldOrder ( ) { 
 - return Arrays . asList ( new String [ ] { " value " } ) ; 
 + return Arrays . asList ( new String [ ] { " value " } ) ; 
 } 
 } 
 
 @ @ - 59 , 7 + 59 , 7 @ @ public class UnionTest extends TestCase { 
 public WString wstring ; 
 public Pointer pointer ; 
 } 
 - 
 + 
 public static class StructUnion extends Union { 
 public int intField ; 
 public TestStructure testStruct ; 
 @ @ - 69 , 31 + 69 , 33 @ @ public class UnionTest extends TestCase { 
 
 public void testCalculateSize ( ) { 
 Union u = new SizedUnion ( ) ; 
 + assertEquals ( " Wrong union size : " + u , 16 , u . size ( ) ) ; 
 assertEquals ( " Union should be size of largest field " , 
 new BigTestStructure ( ) . size ( ) , u . size ( ) ) ; 
 } 
 
 public void testFieldOffsets ( ) { 
 StructUnion u = new StructUnion ( ) ; 
 + assertEquals ( " Wrong union size : " + u , Pointer . SIZE , u . size ( ) ) ; 
 u . setType ( u . testStruct . getClass ( ) ) ; 
 u . write ( ) ; 
 - assertEquals ( " Wrong struct member base address " , 
 + assertEquals ( " Wrong struct member base address " , 
 u . getPointer ( ) , u . testStruct . getPointer ( ) ) ; 
 u . setType ( u . intStruct . getClass ( ) ) ; 
 u . write ( ) ; 
 - assertEquals ( " Wrong struct member base address ( 2 ) " , 
 + assertEquals ( " Wrong struct member base address ( 2 ) " , 
 u . getPointer ( ) , u . intStruct . getPointer ( ) ) ; 
 } 
 
 public void testWriteUnion ( ) { 
 SizedUnion u = new SizedUnion ( ) ; 
 - final int VALUE = 0x12345678 ; 
 + final int VALUE = 0x12345678 ; 
 u . intField = VALUE ; 
 u . setType ( int . class ) ; 
 u . write ( ) ; 
 assertEquals ( " Wrong value written " , VALUE , u . getPointer ( ) . getInt ( 0 ) ) ; 
 } 
 - 
 + 
 public void testReadUnion ( ) { 
 SizedUnion u = new SizedUnion ( ) ; 
 final int VALUE = 0x12345678 ; 
 @ @ - 109 , 11 + 111 , 12 @ @ public class UnionTest extends TestCase { 
 assertNull ( " Unselected String should be null " , u . string ) ; 
 assertNull ( " Unselected WString should be null " , u . wstring ) ; 
 } 
 - 
 + 
 public void testWriteTypedUnion ( ) { 
 final int VALUE = 0x12345678 ; 
 / / write an instance of a direct union class to memory 
 StructUnion u = new StructUnion ( ) ; 
 + assertEquals ( " Wrong union size : " + u , Pointer . SIZE , u . size ( ) ) ; 
 IntStructure intStruct = new IntStructure ( ) ; 
 intStruct . value = VALUE ; 
 u . setTypedValue ( intStruct ) ; 
 @ @ - 138 , 6 + 141 , 7 @ @ public class UnionTest extends TestCase { 
 
 public void testReadTypedUnion ( ) { 
 StructUnion u = new StructUnion ( ) ; 
 + assertEquals ( " Wrong union size : " + u , Pointer . SIZE , u . size ( ) ) ; 
 final int VALUE = 0x12345678 ; 
 u . getPointer ( ) . setInt ( 0 , VALUE ) ; 
 assertEquals ( " int structure not read properly " , VALUE , ( ( IntStructure ) u . getTypedValue ( IntStructure . class ) ) . value ) ; 
 @ @ - 145 , 29 + 149 , 34 @ @ public class UnionTest extends TestCase { 
 
 public void testReadTypeInfo ( ) { 
 SizedUnion u = new SizedUnion ( ) ; 
 + assertEquals ( " Wrong union size : " + u , 16 , u . size ( ) ) ; 
 + assertNotNull ( " Type information is missing for union field of type " + BigTestStructure . class , Structure . getTypeInfo ( BigTestStructure . class ) ) ; 
 + assertNotNull ( " Type information is missing for union instance " , u . getTypeInfo ( ) ) ; 
 if ( Native . POINTER _ SIZE = = 4 ) { 
 - assertEquals ( " Type size should be that of longest field if no field active " , 
 + assertEquals ( " Type size should be that of largest field if no field is active " , 
 Structure . getTypeInfo ( BigTestStructure . class ) . getInt ( 0 ) , 
 u . getTypeInfo ( ) . getInt ( 0 ) ) ; 
 } 
 else { 
 - assertEquals ( " Type size should be that of longest field if no field active " , 
 + assertEquals ( " Type size should be that of largest field if no field is active " , 
 Structure . getTypeInfo ( BigTestStructure . class ) . getLong ( 0 ) , 
 u . getTypeInfo ( ) . getLong ( 0 ) ) ; 
 } 
 u . setType ( int . class ) ; 
 + assertNotNull ( " Type information is missing for union field of type " + BigTestStructure . class , Structure . getTypeInfo ( BigTestStructure . class ) ) ; 
 + assertNotNull ( " Type information is missing for union instance after type set " , u . getTypeInfo ( ) ) ; 
 if ( Native . POINTER _ SIZE = = 4 ) { 
 - assertEquals ( " Type size should be that of longest field if field active " , 
 + assertEquals ( " Type size should be that of largest field if any field is active " , 
 Structure . getTypeInfo ( BigTestStructure . class ) . getInt ( 0 ) , 
 u . getTypeInfo ( ) . getInt ( 0 ) ) ; 
 } 
 else { 
 - assertEquals ( " Type size should be that of longest field if field active " , 
 + assertEquals ( " Type size should be that of largest field if any field is active " , 
 Structure . getTypeInfo ( BigTestStructure . class ) . getLong ( 0 ) , 
 u . getTypeInfo ( ) . getLong ( 0 ) ) ; 
 } 
 } 
 - 
 + 
 public void testArraysInUnion ( ) { 
 class TestUnion extends Union { 
 public byte [ ] bytes = new byte [ 16 ] ; 
 @ @ - 175 , 6 + 184 , 7 @ @ public class UnionTest extends TestCase { 
 public int [ ] ints = new int [ 4 ] ; 
 } 
 Union u = new TestUnion ( ) ; 
 + assertEquals ( " Wrong union size : " + u , 16 , u . size ( ) ) ; 
 u . setType ( byte [ ] . class ) ; 
 u . setType ( short [ ] . class ) ; 
 u . setType ( int [ ] . class ) ; 
 @ @ - 183 , 9 + 193 , 10 @ @ public class UnionTest extends TestCase { 
 public void testDuplicateFieldTypes ( ) { 
 class TestUnion extends Union { 
 public int field1 ; 
 - public int field2 ; 
 + public int field2 ; 
 } 
 TestUnion u = new TestUnion ( ) ; 
 + assertEquals ( " Wrong union size : " + u , 4 , u . size ( ) ) ; 
 u . setType ( " field1 " ) ; 
 u . field1 = 42 ; 
 u . write ( ) ;

NEAREST DIFF:
diff - - git a / jnalib / release - notes . html b / jnalib / release - notes . html 
 index f28ff86 . . 5785afa 100755 
 - - - a / jnalib / release - notes . html 
 + + + b / jnalib / release - notes . html 
 @ @ - 4 , 6 + 4 , 7 @ @ 
 < ul > 
 < li > Enable build / run using IBM ' s J9 VM ( leonardo ) . 
 < li > Make StdCallFunctionMapper attempt a leading underscore if the simpler mapping doesn ' t work . 
 + < li > Allow Structure . read to overwrite final fields ( may not work on some 1 . 4 VMs ) . 
 < / ul > 
 < b > Bug Fixes < / b > < br > 
 < ul > 
 diff - - git a / jnalib / src / com / sun / jna / Structure . java b / jnalib / src / com / sun / jna / Structure . java 
 index bf07e7d . . 70e4912 100644 
 - - - a / jnalib / src / com / sun / jna / Structure . java 
 + + + b / jnalib / src / com / sun / jna / Structure . java 
 @ @ - 37 , 6 + 37 , 14 @ @ import java . util . WeakHashMap ; 
 * enclosing interface definition ( if any ) by using 
 * { @ link Native # getStructureAlignment } and { @ link Native # getTypeMapper } . 
 * < p > 
 + * Structure fields corresponding to native fields < em > must < / em > be public . 
 + * The may additionally have the following modifiers : < br > 
 + * < ul > 
 + * < li > < code > volatile < / code > JNA will not write the field unless specifically 
 + * instructed to do so via { @ link # writeField ( String ) } . 
 + * < li > < code > final < / code > JNA will overwrite the field via { @ link # read ( ) } , 
 + * but otherwise the field is not modifiable from Java . 
 + * < / ul > 
 * NOTE : Strings are used to represent native C strings because usage of 
 * < code > char * < / code > is generally more common than < code > wchar _ t * < / code > . 
 * < p > 
 @ @ - 689 , 6 + 697 , 9 @ @ public abstract class Structure { 
 StructField structField = new StructField ( ) ; 
 structField . isVolatile = Modifier . isVolatile ( modifiers ) ; 
 structField . field = field ; 
 + if ( Modifier . isFinal ( modifiers ) ) { 
 + field . setAccessible ( true ) ; 
 + } 
 structField . name = field . getName ( ) ; 
 structField . type = type ; 
 
 diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html 
 index 0b853a8 . . 9e03dce 100644 
 - - - a / jnalib / src / com / sun / jna / overview . html 
 + + + b / jnalib / src / com / sun / jna / overview . html 
 @ @ - 528 , 6 + 528 , 37 @ @ native memory , call { @ link com . sun . jna . Structure # read ( ) } ( to update the entire 
 structure ) or { @ link com . sun . jna . Structure # readField ( String ) 
 data . readField ( " refCount " ) } ( to update just the < code > refCount < / code > field ) . 
 
 + < h4 > Read - only fields < / h4 > 
 + If you want to absolutely prevent Java code from modifying 
 + a < code > Structure < / code > ' s contents , you may mark its 
 + fields < code > final < / code > . Structure reads can still overwrite the values 
 + based on native memory contents , but no Java code will be able to modify any 
 + of the fields . 
 + < blockquote > < code > < pre > 
 + class ReadOnly extends com . sun . jna . Structure { 
 + / / Do not initialize the field here , or the compiler will inline the value ! 
 + public final int refCount ; 
 + { 
 + / / Initialize fields here , to ensure the values are not inlined 
 + refCount = - 1 ; 
 + read ( ) ; 
 + / / refCount might now have a different value 
 + } 
 + } 
 + . . . 
 + ReadOnly ro = new ReadOnly ( ) ; 
 + / / Will not compile ! 
 + ro . refCount = 0 ; 
 + < / pre > < / code > < / blockquote > 
 + 
 + Make certain you attend to the following : 
 + < ol > 
 + < li > All final fields should be initialized in the constructor . 
 + < li > If you call Structure . read ( ) from anywhere but the constructor , keep in 
 + mind that the compiler and / or hotspot will be assuming field values will not 
 + change across that function call . 
 + < / ol > 
 + 
 < a name = " unions " > < / a > 
 < h3 > Unions < / h3 > 
 Unions are a special type of Structure . Each declared field within the union 
 diff - - git a / jnalib / test / com / sun / jna / StructureTest . java b / jnalib / test / com / sun / jna / StructureTest . java 
 index a2ce566 . . 37738f6 100644 
 - - - a / jnalib / test / com / sun / jna / StructureTest . java 
 + + + b / jnalib / test / com / sun / jna / StructureTest . java 
 @ @ - 745 , 4 + 745 , 17 @ @ public class StructureTest extends TestCase { 
 public void testNativeMappedInByValue ( ) { 
 new TestNativeMappedInStructure . ByValue ( ) ; 
 } 
 + 
 + public static class ROStructure extends Structure { 
 + public final int field ; 
 + { 
 + field = 0 ; 
 + getPointer ( ) . setInt ( 0 , 42 ) ; 
 + read ( ) ; 
 + } 
 + } 
 + public void testReadOnlyField ( ) { 
 + ROStructure s = new ROStructure ( ) ; 
 + assertEquals ( " Field value should be writable from native " , 42 , s . field ) ; 
 + } 
 } 
 \ No newline at end of file
