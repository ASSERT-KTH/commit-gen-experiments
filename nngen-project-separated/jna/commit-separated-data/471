BLEU SCORE: 0.05341087579952926

TEST MSG: amd64 / linux pthread investigations
GENERATED MSG: functional detach switch from callback

TEST DIFF (one line): diff - - git a / native / callback . c b / native / callback . c <nl> index 9812dc4 . . 904acb9 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 23 , 12 + 23 , 17 @ @ <nl> # include < windows . h > <nl> # define TLS _ SET ( KEY , VALUE ) TlsSetValue ( KEY , VALUE ) <nl> # define TLS _ GET ( KEY ) TlsGetValue ( KEY ) <nl> + # define TLS _ KEY _ T DWORD <nl> # else <nl> # include < sys / types . h > <nl> # include < sys / param . h > <nl> + # include < pthread . h > <nl> + # define PTHREADS <nl> # define TLS _ SET ( KEY , VALUE ) ( pthread _ setspecific ( KEY , VALUE ) = = 0 ) <nl> # define TLS _ GET ( KEY ) pthread _ getspecific ( KEY ) <nl> + # define TLS _ KEY _ T pthread _ key _ t <nl> # endif <nl> + <nl> # include " dispatch . h " <nl> <nl> # ifdef _ _ cplusplus <nl> @ @ - 74 , 9 + 79 , 18 @ @ static void * const dll _ fptrs [ ] = { <nl> <nl> # endif / * _ WIN32 & & ! _ WIN32 _ WCE * / <nl> <nl> + typedef struct _ tls { <nl> + JavaVM * jvm ; <nl> + jint last _ error ; <nl> + jboolean detach ; <nl> + char name [ 256 ] ; <nl> + } thread _ storage ; <nl> + <nl> static void callback _ dispatch ( ffi _ cif * , void * , void * * , void * ) ; <nl> static jclass classObject ; <nl> <nl> + extern void println ( JNIEnv * , const char * ) ; <nl> + <nl> callback * <nl> create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> jobjectArray param _ types , jclass return _ type , <nl> @ @ - 475 , 43 + 489 , 74 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar <nl> } <nl> } <nl> <nl> - / / Handle automatic thread cleanup <nl> - static void detach _ thread ( void * data ) { <nl> - if ( data ! = NULL ) { <nl> - JavaVM * jvm = ( JavaVM * ) data ; <nl> - ( * jvm ) - > DetachCurrentThread ( jvm ) ; <nl> + static TLS _ KEY _ T tls _ thread _ data _ key ; <nl> + static thread _ storage * get _ thread _ storage ( JNIEnv * env ) { <nl> + thread _ storage * tls = ( thread _ storage * ) TLS _ GET ( tls _ thread _ data _ key ) ; <nl> + if ( tls = = NULL ) { <nl> + tls = ( thread _ storage * ) malloc ( sizeof ( thread _ storage ) ) ; <nl> + if ( ! tls ) { <nl> + throwByName ( env , EOutOfMemory , " JNA : Can ' t allocate thread storage " ) ; <nl> + } <nl> + else { <nl> + snprintf ( tls - > name , sizeof ( tls - > name ) , " < uninitialized thread name > " ) ; <nl> + if ( ( * env ) - > GetJavaVM ( env , & tls - > jvm ) ! = JNI _ OK ) { <nl> + free ( tls ) ; <nl> + throwByName ( env , EIllegalState , " JNA : Could not get JavaVM " ) ; <nl> + tls = NULL ; <nl> + } <nl> + else if ( ! TLS _ SET ( tls _ thread _ data _ key , tls ) ) { <nl> + free ( tls ) ; <nl> + throwByName ( env , EOutOfMemory , " JNA : Internal TLS error " ) ; <nl> + tls = NULL ; <nl> + } <nl> + else { <nl> + fprintf ( stderr , " Created thread storage for % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; <nl> + } <nl> + } <nl> + } <nl> + return tls ; <nl> + } <nl> + <nl> + static void dispose _ thread _ data ( void * data ) { <nl> + thread _ storage * tls = ( thread _ storage * ) data ; <nl> + JavaVM * jvm = tls - > jvm ; <nl> + JNIEnv * env ; <nl> + int is _ attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; <nl> + if ( is _ attached ) { <nl> + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { <nl> + fprintf ( stderr , " JNA : could not detach native thread ( automatic ) \ n " ) ; <nl> + } <nl> + else { <nl> + fprintf ( stderr , " Thread detached : % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; <nl> + } <nl> + fprintf ( stderr , " Dispose thread data % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; <nl> + } <nl> + else { <nl> + fprintf ( stderr , " Thread already detached % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; <nl> } <nl> + free ( data ) ; <nl> } <nl> <nl> # ifdef _ WIN32 <nl> <nl> - static DWORD tls _ thread _ cleanup _ key ; <nl> - static DWORD tls _ errno _ key , tls _ detach _ key ; <nl> BOOL WINAPI DllMain ( HINSTANCE hDLL , DWORD fdwReason , LPVOID lpvReserved ) { <nl> switch ( fdwReason ) { <nl> case DLL _ PROCESS _ ATTACH : <nl> - tls _ thread _ cleanup _ key = TlsAlloc ( ) ; <nl> - if ( tls _ thread _ cleanup _ key = = TLS _ OUT _ OF _ INDEXES ) { <nl> - return FALSE ; <nl> - } <nl> - tls _ detach _ key = TlsAlloc ( ) ; <nl> - if ( tls _ detach _ key = = TLS _ OUT _ OF _ INDEXES ) { <nl> - return FALSE ; <nl> - } <nl> - tls _ errno _ key = TlsAlloc ( ) ; <nl> - if ( tls _ errno _ key = = TLS _ OUT _ OF _ INDEXES ) { <nl> + tls _ thread _ data _ key = TlsAlloc ( ) ; <nl> + if ( tls _ thread _ data _ key = = TLS _ OUT _ OF _ INDEXES ) { <nl> return FALSE ; <nl> } <nl> break ; <nl> case DLL _ PROCESS _ DETACH : <nl> - TlsFree ( tls _ thread _ cleanup _ key ) ; <nl> - TlsFree ( tls _ detach _ key ) ; <nl> - TlsFree ( tls _ errno _ key ) ; <nl> + TlsFree ( tls _ thread _ data _ key ) ; <nl> break ; <nl> case DLL _ THREAD _ ATTACH : <nl> break ; <nl> case DLL _ THREAD _ DETACH : { <nl> - detach _ thread ( TlsGetValue ( tls _ thread _ cleanup _ key ) ) ; <nl> + thread _ storage * tls = ( thread _ storage * ) TlsGetValue ( tls _ thread _ data _ key ) ; <nl> + if ( tls ) { <nl> + dispose _ thread _ data ( tls ) ; <nl> + } <nl> break ; <nl> } <nl> default : <nl> @ @ - 520 , 71 + 565 , 50 @ @ BOOL WINAPI DllMain ( HINSTANCE hDLL , DWORD fdwReason , LPVOID lpvReserved ) { <nl> return TRUE ; <nl> } <nl> <nl> - # else <nl> - <nl> - # include < pthread . h > <nl> + # endif <nl> <nl> - static pthread _ key _ t tls _ thread _ cleanup _ key , tls _ detach _ key ; <nl> - static void make _ thread _ cleanup _ key ( ) { <nl> - pthread _ key _ create ( & tls _ thread _ cleanup _ key , detach _ thread ) ; <nl> + # ifdef PTHREADS <nl> + static void make _ thread _ data _ key ( ) { <nl> + pthread _ key _ create ( & tls _ thread _ data _ key , dispose _ thread _ data ) ; <nl> } <nl> - static pthread _ key _ t tls _ errno _ key ; <nl> - static void make _ thread _ keys ( ) { <nl> - pthread _ key _ create ( & tls _ errno _ key , NULL ) ; <nl> - pthread _ key _ create ( & tls _ detach _ key , NULL ) ; <nl> - } <nl> - <nl> # endif <nl> <nl> / * * Store the requested detach state for the current thread . * / <nl> void <nl> - JNA _ detach ( jboolean d ) { <nl> - if ( ! TLS _ SET ( tls _ detach _ key , L2A ( ( jlong ) ( d ? THREAD _ DETACH : THREAD _ LEAVE _ ATTACHED ) ) ) ) { <nl> - fprintf ( stderr , " JNA : unable to set thread - local detach value \ n " ) ; <nl> + JNA _ detach ( JNIEnv * env , jboolean d ) { <nl> + thread _ storage * tls = get _ thread _ storage ( env ) ; <nl> + if ( tls ) { <nl> + tls - > detach = d ; <nl> } <nl> } <nl> <nl> / * * Store the value of errno / GetLastError in TLS * / <nl> void <nl> - JNA _ set _ last _ error ( int err ) { <nl> - if ( ! TLS _ SET ( tls _ errno _ key , L2A ( ( jlong ) err ) ) ) { <nl> - fprintf ( stderr , " JNA : unable to set thread - local errno value \ n " ) ; <nl> + JNA _ set _ last _ error ( JNIEnv * env , int err ) { <nl> + thread _ storage * tls = get _ thread _ storage ( env ) ; <nl> + if ( tls ) { <nl> + tls - > last _ error = err ; <nl> } <nl> } <nl> <nl> / * * Store the value of errno / GetLastError in TLS * / <nl> int <nl> - JNA _ get _ last _ error ( ) { <nl> - return ( int ) A2L ( TLS _ GET ( tls _ errno _ key ) ) ; <nl> - } <nl> - <nl> - / * * Set up to detach the thread when it exits , or clear any handlers if the <nl> - argument is NULL . <nl> - * / <nl> - static void <nl> - jvm _ detach _ on _ exit ( JavaVM * jvm ) { <nl> - # ifdef _ WIN32 <nl> - if ( ! TlsSetValue ( tls _ thread _ cleanup _ key , ( void * ) jvm ) ) { <nl> - fprintf ( stderr , " JNA : unable to set thread - local JVM value \ n " ) ; <nl> - } <nl> - # else <nl> - static pthread _ once _ t key _ once = PTHREAD _ ONCE _ INIT ; <nl> - pthread _ once ( & key _ once , make _ thread _ cleanup _ key ) ; <nl> - if ( ! jvm | | pthread _ getspecific ( tls _ thread _ cleanup _ key ) = = NULL ) { <nl> - if ( pthread _ setspecific ( tls _ thread _ cleanup _ key , jvm ) ) { <nl> - fprintf ( stderr , " JNA : unable to set thread - local JVM value \ n " ) ; <nl> - } <nl> + JNA _ get _ last _ error ( JNIEnv * env ) { <nl> + thread _ storage * tls = get _ thread _ storage ( env ) ; <nl> + if ( tls ) { <nl> + return tls - > last _ error ; <nl> } <nl> - # endif <nl> + return 0 ; <nl> } <nl> <nl> static void <nl> callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> callback * cb = ( ( callback * ) user _ data ) ; <nl> JavaVM * jvm = cb - > vm ; <nl> - JNIEnv * env ; <nl> + JNIEnv * env = NULL ; <nl> int was _ attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; <nl> jboolean detach = was _ attached ? JNI _ FALSE : JNI _ TRUE ; <nl> + thread _ storage * tls = was _ attached ? get _ thread _ storage ( env ) : NULL ; <nl> <nl> if ( ! was _ attached ) { <nl> int attach _ status = 0 ; <nl> @ @ - 610 , 6 + 634 , 11 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> else { <nl> attach _ status = ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , & args ) ; <nl> } <nl> + tls = get _ thread _ storage ( env ) ; <nl> + if ( tls ) { <nl> + snprintf ( tls - > name , sizeof ( tls - > name ) , <nl> + args . name ? args . name : " < unconfigured thread > " ) ; <nl> + } <nl> if ( attach _ status ! = JNI _ OK ) { <nl> fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback : % d \ n " , attach _ status ) ; <nl> return ; <nl> @ @ - 618 , 37 + 647 , 41 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> ( * env ) - > DeleteWeakGlobalRef ( env , args . group ) ; <nl> } <nl> } <nl> - <nl> + 	 	 	 	 	 	 <nl> + if ( ! tls ) { <nl> + fprintf ( stderr , " JNA : couldn ' t obtain thread - local storage \ n " ) ; <nl> + return ; <nl> + } <nl> + <nl> + fprintf ( stderr , " % p ( % s ) was attached : % d \ n " , pthread _ self ( ) , tls - > name , was _ attached ) ; <nl> + <nl> / / Give the callback glue its own local frame to ensure all local references <nl> / / are properly disposed <nl> if ( ( * env ) - > PushLocalFrame ( env , 16 ) < 0 ) { <nl> fprintf ( stderr , " JNA : Out of memory : Can ' t allocate local frame \ n " ) ; <nl> } <nl> else { <nl> - TLS _ SET ( tls _ detach _ key , L2A ( ( jlong ) THREAD _ NOCHANGE ) ) ; <nl> + tls - > detach = detach ; <nl> callback _ invoke ( env , cb , cif , resp , cbargs ) ; <nl> - switch ( ( int ) A2L ( TLS _ GET ( tls _ detach _ key ) ) ) { <nl> - case THREAD _ LEAVE _ ATTACHED : detach = JNI _ FALSE ; break ; <nl> - case THREAD _ DETACH : detach = JNI _ TRUE ; break ; <nl> - default : break ; / * use default detach behavior * / <nl> - } <nl> + detach = tls - > detach ; <nl> ( * env ) - > PopLocalFrame ( env , NULL ) ; <nl> } <nl> <nl> if ( detach ) { <nl> - ( * jvm ) - > DetachCurrentThread ( jvm ) ; <nl> - jvm _ detach _ on _ exit ( NULL ) ; <nl> + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { <nl> + fprintf ( stderr , " JNA : could not detach thread \ n " ) ; <nl> + } <nl> } <nl> - else if ( ! was _ attached ) { <nl> - jvm _ detach _ on _ exit ( jvm ) ; <nl> + else { <nl> + fprintf ( stderr , " Thread will detach automatically % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; <nl> } <nl> } <nl> <nl> const char * <nl> JNA _ callback _ init ( JNIEnv * env ) { <nl> - # ifndef _ WIN32 <nl> + # ifdef PTHREADS <nl> static pthread _ once _ t key _ once = PTHREAD _ ONCE _ INIT ; <nl> - pthread _ once ( & key _ once , make _ thread _ keys ) ; <nl> + pthread _ once ( & key _ once , make _ thread _ data _ key ) ; <nl> # endif <nl> <nl> if ( ! LOAD _ CREF ( env , Object , " java / lang / Object " ) ) return " java . lang . Object " ; <nl> @ @ - 662 , 10 + 695 , 8 @ @ JNA _ callback _ dispose ( JNIEnv * env ) { <nl> ( * env ) - > DeleteWeakGlobalRef ( env , classObject ) ; <nl> classObject = NULL ; <nl> } <nl> - # ifndef _ WIN32 <nl> - pthread _ key _ delete ( tls _ errno _ key ) ; <nl> - pthread _ key _ delete ( tls _ thread _ cleanup _ key ) ; <nl> - pthread _ key _ delete ( tls _ detach _ key ) ; <nl> + # ifdef PTHREADS <nl> + pthread _ key _ delete ( tls _ thread _ data _ key ) ; <nl> # endif <nl> } <nl> <nl> diff - - git a / native / dispatch . c b / native / dispatch . c <nl> index 8205786 . . 809d666 100644 <nl> - - - a / native / dispatch . c <nl> + + + b / native / dispatch . c <nl> @ @ - 301 , 17 + 301 , 29 @ @ static ffi _ type * getStructureType ( JNIEnv * , jobject ) ; <nl> <nl> typedef void ( JNICALL * release _ t ) ( JNIEnv * , jarray , void * , jint ) ; <nl> <nl> - # if 0 <nl> + # if 1 <nl> / * * Invokes System . err . println ( for debugging only ) . * / <nl> - static void <nl> + void <nl> println ( JNIEnv * env , const char * msg ) { <nl> jclass cls = ( * env ) - > FindClass ( env , " java / lang / System " ) ; <nl> + if ( ! cls ) { <nl> + fprintf ( stderr , " JNA : failed to find java . lang . System \ n " ) ; <nl> + return ; <nl> + } <nl> jfieldID fid = ( * env ) - > GetStaticFieldID ( env , cls , " err " , <nl> - " Ljava / io / PrintStream ; " ) ; <nl> + 	 	 	 	 	 " Ljava / io / PrintStream ; " ) ; <nl> jobject err = ( * env ) - > GetStaticObjectField ( env , cls , fid ) ; <nl> + if ( ! err ) { <nl> + fprintf ( stderr , " JNA : failed to find System . err \ n " ) ; <nl> + return ; <nl> + } <nl> jclass pscls = ( * env ) - > FindClass ( env , " java / io / PrintStream " ) ; <nl> + if ( ! pscls ) { <nl> + fprintf ( stderr , " JNA : failed to find java . io . PrintStream \ n " ) ; <nl> + return ; <nl> + } <nl> jmethodID mid = ( * env ) - > GetMethodID ( env , pscls , " println " , <nl> - " ( Ljava / lang / String ; ) V " ) ; <nl> + 	 	 	 	 " ( Ljava / lang / String ; ) V " ) ; <nl> jstring str = newJavaString ( env , msg , JNI _ FALSE ) ; <nl> ( * env ) - > CallObjectMethod ( env , err , mid , str ) ; <nl> } <nl> @ @ - 568 , 7 + 580 , 7 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , <nl> } <nl> } <nl> else if ( preserve _ last _ error ) { <nl> - JNA _ set _ last _ error ( GET _ LAST _ ERROR ( ) ) ; <nl> + JNA _ set _ last _ error ( env , GET _ LAST _ ERROR ( ) ) ; <nl> } <nl> PROTECTED _ END ( do { throw _ type = EError ; throw _ msg = " Invalid memory access " ; } while ( 0 ) ) ; <nl> } <nl> @ @ - 987 , 10 + 999 , 13 @ @ initializeThread ( callback * cb , AttachOptions * args ) { <nl> JavaVM * jvm = cb - > vm ; <nl> JNIEnv * env ; <nl> jobject group = NULL ; <nl> + int attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; <nl> <nl> - if ( ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , NULL ) ! = JNI _ OK ) { <nl> - fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback thread initialization \ n " ) ; <nl> - return NULL ; <nl> + if ( ! attached ) { <nl> + if ( ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , NULL ) ! = JNI _ OK ) { <nl> + fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback thread initialization \ n " ) ; <nl> + return NULL ; <nl> + } <nl> } <nl> ( * env ) - > PushLocalFrame ( env , 16 ) ; <nl> { <nl> @ @ - 1006 , 7 + 1021 , 11 @ @ initializeThread ( callback * cb , AttachOptions * args ) { <nl> } <nl> } <nl> ( * env ) - > PopLocalFrame ( env , NULL ) ; <nl> - ( * jvm ) - > DetachCurrentThread ( jvm ) ; <nl> + if ( ! attached ) { <nl> + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { <nl> + fprintf ( stderr , " JNA : could not detach thread after callback init \ n " ) ; <nl> + } <nl> + } <nl> <nl> return group ; <nl> } <nl> @ @ - 1715 , 7 + 1734 , 7 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { <nl> } <nl> } <nl> else if ( preserve _ last _ error ) { <nl> - JNA _ set _ last _ error ( GET _ LAST _ ERROR ( ) ) ; <nl> + JNA _ set _ last _ error ( env , GET _ LAST _ ERROR ( ) ) ; <nl> } <nl> PROTECTED _ END ( do { throw _ type = EError ; throw _ msg = " Invalid memory access " ; } while ( 0 ) ) ; <nl> } <nl> @ @ - 1792 , 9 + 1811 , 8 @ @ closure _ handler ( ffi _ cif * cif , void * resp , void * * argp , void * cdata ) <nl> JavaVM * jvm = cb - > vm ; <nl> JNIEnv * env ; <nl> jobject obj ; <nl> - int attached ; <nl> + int attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; <nl> <nl> - attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; <nl> if ( ! attached ) { <nl> if ( ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , NULL ) ! = JNI _ OK ) { <nl> fprintf ( stderr , " JNA : Can ' t attach native thread to VM for closure handler \ n " ) ; <nl> @ @ - 1823 , 7 + 1841 , 9 @ @ closure _ handler ( ffi _ cif * cif , void * resp , void * * argp , void * cdata ) <nl> } <nl> <nl> if ( ! attached ) { <nl> - ( * jvm ) - > DetachCurrentThread ( jvm ) ; <nl> + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { <nl> + fprintf ( stderr , " JNA : could not detach thread after callback handling \ n " ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 2936 , 13 + 2956 , 13 @ @ Java _ com _ sun _ jna _ Native _ getPreserveLastError ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( <nl> <nl> JNIEXPORT void JNICALL <nl> Java _ com _ sun _ jna _ Native _ setLastError ( JNIEnv * env , jclass UNUSED ( classp ) , jint code ) { <nl> - JNA _ set _ last _ error ( code ) ; <nl> + JNA _ set _ last _ error ( env , code ) ; <nl> SET _ LAST _ ERROR ( code ) ; <nl> } <nl> <nl> JNIEXPORT jint JNICALL <nl> Java _ com _ sun _ jna _ Native _ getLastError ( JNIEnv * env , jclass UNUSED ( classp ) ) { <nl> - return JNA _ get _ last _ error ( ) ; <nl> + return JNA _ get _ last _ error ( env ) ; <nl> } <nl> <nl> JNIEXPORT jstring JNICALL <nl> @ @ - 2984 , 7 + 3004 , 9 @ @ JNI _ OnLoad ( JavaVM * jvm , void * UNUSED ( reserved ) ) { <nl> result = 0 ; <nl> } <nl> if ( ! attached ) { <nl> - ( * jvm ) - > DetachCurrentThread ( jvm ) ; <nl> + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { <nl> + fprintf ( stderr , " JNA : could not detach thread on initial load \ n " ) ; <nl> + } <nl> } <nl> <nl> return result ; <nl> @ @ - 3046 , 7 + 3068 , 9 @ @ JNI _ OnUnload ( JavaVM * vm , void * UNUSED ( reserved ) ) { <nl> } <nl> <nl> if ( ! attached ) { <nl> - ( * vm ) - > DetachCurrentThread ( vm ) ; <nl> + if ( ( * vm ) - > DetachCurrentThread ( vm ) ! = 0 ) { <nl> + fprintf ( stderr , " JNA : could not detach thread on unload \ n " ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 3246 , 7 + 3270 , 7 @ @ Java _ com _ sun _ jna _ Native _ initialize _ 1ffi _ 1type ( JNIEnv * env , jclass UNUSED ( cls ) , j <nl> <nl> JNIEXPORT void JNICALL <nl> Java _ com _ sun _ jna _ Native _ detach ( JNIEnv * env , jclass UNUSED ( cls ) , jboolean d ) { <nl> - JNA _ detach ( d ) ; <nl> + JNA _ detach ( env , d ) ; <nl> } <nl> <nl> # ifdef _ _ cplusplus <nl> diff - - git a / native / dispatch . h b / native / dispatch . h <nl> index aea2d8d . . cc98f37 100644 <nl> - - - a / native / dispatch . h <nl> + + + b / native / dispatch . h <nl> @ @ - 94 , 10 + 94 , 6 @ @ enum { <nl> / * callback behavior flags * / <nl> enum { <nl> CB _ HAS _ INITIALIZER = com _ sun _ jna _ Native _ CB _ HAS _ INITIALIZER , <nl> - / / detach options <nl> - THREAD _ NOCHANGE , <nl> - THREAD _ DETACH , <nl> - THREAD _ LEAVE _ ATTACHED , <nl> } ; <nl> <nl> typedef struct _ callback { <nl> @ @ - 176 , 10 + 172 , 10 @ @ extern int get _ jtype ( JNIEnv * , jclass ) ; <nl> extern ffi _ type * get _ ffi _ type ( JNIEnv * , jclass , char ) ; <nl> extern ffi _ type * get _ ffi _ rtype ( JNIEnv * , jclass , char ) ; <nl> extern const char * JNA _ callback _ init ( JNIEnv * ) ; <nl> - extern void JNA _ set _ last _ error ( int ) ; <nl> - extern int JNA _ get _ last _ error ( ) ; <nl> + extern void JNA _ set _ last _ error ( JNIEnv * , int ) ; <nl> + extern int JNA _ get _ last _ error ( JNIEnv * ) ; <nl> extern void JNA _ callback _ dispose ( JNIEnv * ) ; <nl> - extern void JNA _ detach ( jboolean ) ; <nl> + extern void JNA _ detach ( JNIEnv * , jboolean ) ; <nl> extern callback * create _ callback ( JNIEnv * , jobject , jobject , <nl> jobjectArray , jclass , <nl> callconv _ t , jint ) ; <nl> diff - - git a / native / testlib . c b / native / testlib . c <nl> index 60dc1d7 . . 87df97c 100644 <nl> - - - a / native / testlib . c <nl> + + + b / native / testlib . c <nl> @ @ - 19 , 6 + 19 , 7 @ @ extern " C " { <nl> # include < wchar . h > <nl> # include < stdio . h > <nl> # include < stdarg . h > <nl> + # include < stdlib . h > <nl> # if ! defined ( _ WIN32 _ WCE ) <nl> # include < errno . h > <nl> # endif <nl> @ @ - 635 , 29 + 636 , 33 @ @ typedef struct thread _ data { <nl> int repeat _ count ; <nl> int sleep _ time ; <nl> void ( * func ) ( void ) ; <nl> + char name [ 256 ] ; <nl> } thread _ data ; <nl> static THREAD _ FUNC ( thread _ function , arg ) { <nl> - / / make a local copy <nl> thread _ data td = * ( thread _ data * ) arg ; <nl> void ( * func ) ( void ) = td . func ; <nl> int i ; <nl> + fprintf ( stderr , " thread start 0x % p ( % s ) \ n " , THREAD _ CURRENT ( ) , td . name ) ; <nl> <nl> for ( i = 0 ; i < td . repeat _ count ; i + + ) { <nl> func ( ) ; <nl> SLEEP ( td . sleep _ time ) ; <nl> } <nl> + fprintf ( stderr , " thread exiting 0x % p ( % s ) \ n " , THREAD _ CURRENT ( ) , td . name ) ; <nl> + free ( ( void * ) arg ) ; <nl> THREAD _ EXIT ( ) ; <nl> THREAD _ RETURN ; <nl> } <nl> <nl> - static thread _ data data ; <nl> EXPORT void <nl> - callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms ) { <nl> + callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms , const char * name ) { <nl> THREAD _ T thread ; <nl> - data . repeat _ count = n ; <nl> - data . sleep _ time = ms ; <nl> - data . func = func ; <nl> - THREAD _ CREATE ( & thread , & thread _ function , & data ) ; <nl> + thread _ data * data = ( thread _ data * ) malloc ( sizeof ( thread _ data ) ) ; <nl> + data - > repeat _ count = n ; <nl> + data - > sleep _ time = ms ; <nl> + data - > func = func ; <nl> + snprintf ( data - > name , sizeof ( data - > name ) , " % s " , name ) ; <nl> + THREAD _ CREATE ( & thread , & thread _ function , data ) ; <nl> } <nl> <nl> EXPORT int <nl> diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java <nl> index 3061411 . . 84fd206 100644 <nl> - - - a / test / com / sun / jna / CallbacksTest . java <nl> + + + b / test / com / sun / jna / CallbacksTest . java <nl> @ @ - 84 , 7 + 84 , 7 @ @ public class CallbacksTest extends TestCase { <nl> void callback ( ) ; <nl> } <nl> void callVoidCallback ( VoidCallback c ) ; <nl> - void callVoidCallbackThreaded ( VoidCallback c , int count , int ms ) ; <nl> + void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name ) ; <nl> interface VoidCallbackCustom extends Callback { <nl> void customMethodName ( ) ; <nl> } <nl> @ @ - 184 , 6 + 184 , 7 @ @ public class CallbacksTest extends TestCase { <nl> TestLibrary lib ; <nl> protected void setUp ( ) { <nl> lib = ( TestLibrary ) Native . loadLibrary ( " testlib " , TestLibrary . class ) ; <nl> + 	 System . out . println ( " Run " + getName ( ) ) ; <nl> } <nl> <nl> protected void tearDown ( ) { <nl> @ @ - 985 , 13 + 986 , 20 @ @ public class CallbacksTest extends TestCase { <nl> CallbackThreadInitializer cti , <nl> int repeat , int sleepms , <nl> int [ ] called ) throws Exception { <nl> + 	 callThreadedCallback ( cb , cti , repeat , sleepms , called , repeat ) ; <nl> + } <nl> + <nl> + protected void callThreadedCallback ( TestLibrary . VoidCallback cb , <nl> + CallbackThreadInitializer cti , <nl> + int repeat , int sleepms , <nl> + int [ ] called , int returnAfter ) throws Exception { <nl> if ( cti ! = null ) { <nl> Native . setCallbackThreadInitializer ( cb , cti ) ; <nl> } <nl> - lib . callVoidCallbackThreaded ( cb , repeat , sleepms ) ; <nl> + lib . callVoidCallbackThreaded ( cb , repeat , sleepms , getName ( ) ) ; <nl> <nl> long start = System . currentTimeMillis ( ) ; <nl> - while ( called [ 0 ] < repeat ) { <nl> + while ( called [ 0 ] < returnAfter ) { <nl> Thread . sleep ( 10 ) ; <nl> if ( System . currentTimeMillis ( ) - start > 5000 ) { <nl> fail ( " Timed out waiting for callback , invoked " + called [ 0 ] + " times so far " ) ; <nl> @ @ - 1029 , 10 + 1037 , 10 @ @ public class CallbacksTest extends TestCase { <nl> final String [ ] name = { null } ; <nl> final ThreadGroup [ ] group = { null } ; <nl> final Thread [ ] t = { null } ; <nl> - final String tname = getName ( ) + " thread " ; <nl> + final String tname = " Test thread for " + getName ( ) ; <nl> final boolean [ ] alive = { false } ; <nl> <nl> - ThreadGroup testGroup = new ThreadGroup ( getName ( ) + " thread group " ) ; <nl> + ThreadGroup testGroup = new ThreadGroup ( " Thread group for " + getName ( ) ) ; <nl> CallbackThreadInitializer init = new CallbackThreadInitializer ( true , false , tname , testGroup ) ; <nl> TestLibrary . VoidCallback cb = new TestLibrary . VoidCallback ( ) { <nl> public void callback ( ) { <nl> @ @ - 1042 , 7 + 1050 , 7 @ @ public class CallbacksTest extends TestCase { <nl> group [ 0 ] = thread . getThreadGroup ( ) ; <nl> t [ 0 ] = thread ; <nl> if ( thread . isAlive ( ) ) { <nl> - / / NOTE : phoneME incorrectly reports thread " alive " status <nl> + / / NOTE : older phoneME incorrectly reports thread " alive " status <nl> alive [ 0 ] = true ; <nl> } <nl> <nl> @ @ - 1052 , 16 + 1060 , 32 @ @ public class CallbacksTest extends TestCase { <nl> } <nl> } <nl> } ; <nl> - callThreadedCallback ( cb , init , 1 , 5000 , called ) ; <nl> + callThreadedCallback ( cb , init , 2 , 2000 , called , 1 ) ; <nl> <nl> assertTrue ( " Callback thread not attached as daemon " , daemon [ 0 ] ) ; <nl> assertEquals ( " Wrong thread name " , tname , name [ 0 ] ) ; <nl> assertEquals ( " Wrong thread group " , testGroup , group [ 0 ] ) ; <nl> - / / NOTE : phoneME incorrectly reports thread " alive " status <nl> + / / NOTE : older phoneME incorrectly reports thread " alive " status <nl> if ( ! alive [ 0 ] ) { <nl> throw new Error ( " VM incorrectly reports Thread . isAlive ( ) = = false within callback " ) ; <nl> } <nl> assertTrue ( " Thread should still be alive " , t [ 0 ] . isAlive ( ) ) ; <nl> + <nl> + long start = System . currentTimeMillis ( ) ; <nl> + 	 while ( called [ 0 ] < 2 ) { <nl> + 	 Thread . sleep ( 10 ) ; <nl> + 	 if ( System . currentTimeMillis ( ) - start > 5000 ) { <nl> + 	 	 fail ( " Timed out waiting for second callback invocation , which indicates detach " ) ; <nl> + 	 } <nl> + 	 } <nl> + <nl> + start = System . currentTimeMillis ( ) ; <nl> + 	 while ( t [ 0 ] . isAlive ( ) ) { <nl> + 	 Thread . sleep ( 10 ) ; <nl> + 	 if ( System . currentTimeMillis ( ) - start > 5000 ) { <nl> + 	 	 fail ( " Timed out waiting for thread to detach and die " ) ; <nl> + 	 } <nl> + 	 } <nl> } <nl> <nl> / / Detach preference is indicated by the initializer . Thread is attached <nl> @ @ - 1073 , 7 + 1097 , 7 @ @ public class CallbacksTest extends TestCase { <nl> final int COUNT = 5 ; <nl> CallbackThreadInitializer init = new CallbackThreadInitializer ( true , false ) { <nl> public String getName ( Callback cb ) { <nl> - return CallbacksTest . this . getName ( ) + " thread " + called [ 0 ] ; <nl> + return " Test thread for " + CallbacksTest . this . getName ( ) + " ( call count : " + called [ 0 ] + " ) " ; <nl> } <nl> } ; <nl> TestLibrary . VoidCallback cb = new TestLibrary . VoidCallback ( ) { <nl> @ @ - 1096 , 24 + 1120 , 32 @ @ public class CallbacksTest extends TestCase { <nl> public void callback ( ) { <nl> threads . add ( new WeakReference ( Thread . currentThread ( ) ) ) ; <nl> if ( + + called [ 0 ] = = 1 ) { <nl> - Thread . currentThread ( ) . setName ( " Thread to be cleaned up " ) ; <nl> + Thread . currentThread ( ) . setName ( getName ( ) + " ( Thread to be cleaned up ) " ) ; <nl> } <nl> - Native . detach ( false ) ; <nl> + 	 	 Native . detach ( false ) ; <nl> } <nl> } ; <nl> - CallbackThreadInitializer asDaemon = new CallbackThreadInitializer ( true ) ; <nl> - callThreadedCallback ( cb , asDaemon , 1 , 0 , called ) ; <nl> - while ( threads . size ( ) = = 0 ) { <nl> + 	 / / Always attach as daemon to ensure tests will exit <nl> + CallbackThreadInitializer asDaemon = new CallbackThreadInitializer ( true ) { <nl> + 	 public String getName ( Callback cb ) { <nl> + 	 	 return " Test thread for " + CallbacksTest . this . getName ( ) ; <nl> + 	 } <nl> + 	 } ; <nl> + callThreadedCallback ( cb , asDaemon , 2 , 100 , called ) ; <nl> + 	 / / Wait for it to start up <nl> + while ( threads . size ( ) = = 0 & & called [ 0 ] = = 0 ) { <nl> Thread . sleep ( 10 ) ; <nl> } <nl> long start = System . currentTimeMillis ( ) ; <nl> WeakReference ref = ( WeakReference ) threads . iterator ( ) . next ( ) ; <nl> while ( ref . get ( ) ! = null ) { <nl> System . gc ( ) ; <nl> - Thread . sleep ( 10 ) ; <nl> + Thread . sleep ( 1000 ) ; <nl> + 	 Thread [ ] remaining = new Thread [ Thread . activeCount ( ) ] ; <nl> + 	 Thread . enumerate ( remaining ) ; <nl> if ( System . currentTimeMillis ( ) - start > 10000 ) { <nl> Thread t = ( Thread ) ref . get ( ) ; <nl> - fail ( " Timed out waiting for attached thread to be detached on exit and disposed : " + t + " alive : " + t . isAlive ( ) + " daemon " + t . isDaemon ( ) ) ; <nl> + fail ( " Timed out waiting for native attached thread to be GC ' d : " + t + " alive : " + t . isAlive ( ) + " daemon : " + t . isDaemon ( ) + " \ n " + Arrays . asList ( remaining ) ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / test / com / sun / jna / DirectCallbacksTest . java b / test / com / sun / jna / DirectCallbacksTest . java <nl> index e97a449 . . 9e92c9b 100644 <nl> - - - a / test / com / sun / jna / DirectCallbacksTest . java <nl> + + + b / test / com / sun / jna / DirectCallbacksTest . java <nl> @ @ - 42 , 7 + 42 , 7 @ @ public class DirectCallbacksTest extends CallbacksTest { <nl> public native Int32CallbackX returnCallback ( ) ; <nl> public native Int32CallbackX returnCallbackArgument ( Int32CallbackX cb ) ; <nl> public native void callVoidCallback ( VoidCallback c ) ; <nl> - public native void callVoidCallbackThreaded ( VoidCallback c , int count , int ms ) ; <nl> + public native void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name ) ; <nl> <nl> public native int callInt32Callback ( CustomCallback cb , int arg1 , int arg2 ) ; <nl> public native void callCallbackInStruct ( CbStruct s ) ;
NEAREST DIFF (one line): diff - - git a / build . xml b / build . xml <nl> index eb8f38b . . 5ac60dd 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 45 , 7 + 45 , 7 @ @ <nl> < property name = " jni . revision " value = " 0 " / > <nl> < property name = " jni . build " value = " $ { build . number } " / > <nl> < property name = " jni . version " value = " $ { jni . major } . $ { jni . minor } . $ { jni . revision } " / > <nl> - < property name = " jni . md5 " value = " fff3cb3f61b8e1c7748924c5654073ee " / > <nl> + < property name = " jni . md5 " value = " 4c69bcf40b30785215211b5a5dad211e " / > <nl> < property name = " spec . title " value = " Java Native Access ( JNA ) " / > <nl> < property name = " spec . vendor " value = " $ { vendor } " / > <nl> < property name = " spec . version " value = " $ { jna . major } " / > <nl> diff - - git a / native / Makefile b / native / Makefile <nl> index a370c49 . . 1dccb2b 100644 <nl> - - - a / native / Makefile <nl> + + + b / native / Makefile <nl> @ @ - 28 , 7 + 28 , 7 @ @ OS = $ ( shell uname | sed - e ' s / \ ( CYGWIN \ | MINGW32 \ ) . * / win32 / g ' \ <nl> - e ' s / Linux . * / linux / g ' ) <nl> <nl> JNA _ JNI _ VERSION = 3 . 3 . 0 # auto - generated by ant <nl> - CHECKSUM = fff3cb3f61b8e1c7748924c5654073ee # auto - generated by ant <nl> + CHECKSUM = 4c69bcf40b30785215211b5a5dad211e # auto - generated by ant <nl> <nl> JAVA _ INCLUDES = - I " $ ( JAVA _ HOME ) / include " \ <nl> - I " $ ( JAVA _ HOME ) / include / $ ( OS ) " <nl> diff - - git a / native / callback . c b / native / callback . c <nl> index 7e2632b0 . . d940b4a 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 402 , 14 + 402 , 22 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> int attach _ status = 0 ; <nl> JavaVMAttachArgs args ; <nl> jobject group = NULL ; <nl> + int daemon = JNI _ FALSE ; <nl> <nl> args . version = JNI _ VERSION _ 1 _ 2 ; <nl> args . name = NULL ; <nl> args . group = NULL ; <nl> if ( cb - > behavior _ flags & CB _ HAS _ INITIALIZER ) { <nl> - args . group = initializeThread ( cb , & args ) ; <nl> + AttachOptions options ; <nl> + options . daemon = JNI _ FALSE ; <nl> + options . detach = JNI _ TRUE ; <nl> + options . name = NULL ; <nl> + args . group = initializeThread ( cb , & options ) ; <nl> + daemon = options . daemon ; <nl> + detach = detach & & options . detach ; <nl> + args . name = options . name ; <nl> } <nl> - if ( cb - > behavior _ flags & CB _ DAEMON ) { <nl> + if ( daemon ) { <nl> attach _ status = ( * jvm ) - > AttachCurrentThreadAsDaemon ( jvm , ( void * ) & env , & args ) ; <nl> } <nl> else { <nl> @ @ - 430 , 10 + 438 , 16 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { <nl> fprintf ( stderr , " JNA : Out of memory : Can ' t allocate local frame " ) ; <nl> } <nl> else { <nl> + / / Kind of a hack , use last error value rather than setting up our own TLS <nl> + setLastError ( 0 ) ; <nl> callback _ invoke ( env , cb , cif , resp , cbargs ) ; <nl> / / Must be invoked immediately after return to avoid anything <nl> / / stepping on errno / GetLastError <nl> - detach = detachThread ( ) ; <nl> + switch ( lastError ( ) ) { <nl> + case THREAD _ DETACH : detach = JNI _ TRUE ; break ; <nl> + case THREAD _ ATTACH : detach = JNI _ FALSE ; break ; <nl> + default : break ; <nl> + } <nl> ( * env ) - > PopLocalFrame ( env , NULL ) ; <nl> } <nl> <nl> diff - - git a / native / dispatch . c b / native / dispatch . c <nl> index c494438 . . 478a2c4 100644 <nl> - - - a / native / dispatch . c <nl> + + + b / native / dispatch . c <nl> @ @ - 136 , 7 + 136 , 7 @ @ static jclass classStructure ; <nl> static jclass classStructureByValue ; <nl> static jclass classCallback ; <nl> static jclass classCallbackReference ; <nl> - static jclass classJavaVMAttachArgs ; <nl> + static jclass classAttachOptions ; <nl> static jclass classNativeMapped ; <nl> static jclass classIntegerType ; <nl> static jclass classPointerType ; <nl> @ @ - 1133 , 19 + 1133 , 6 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Native _ _ 1getPointer <nl> } <nl> <nl> / * <nl> - * Class : Native <nl> - * Method : getObject <nl> - * Signature : ( J ) Ljava / lang / Object ; <nl> - * / <nl> - JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Native _ getObject <nl> - ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> - { <nl> - jobject obj = NULL ; <nl> - MEMCPY ( & obj , L2A ( addr ) , sizeof ( obj ) ) ; <nl> - return obj ; <nl> - } <nl> - <nl> - / * <nl> * Class : com _ sun _ jna _ Native <nl> * Method : _ getDirectByteBuffer <nl> * Signature : ( JJ ) Ljava / nio / ByteBuffer ; <nl> @ @ - 1360 , 18 + 1347 , 6 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Native _ setString <nl> <nl> / * <nl> * Class : Native <nl> - * Method : setObject <nl> - * Signature : ( JLjava / lang / Object ; Z ) V <nl> - * / <nl> - JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Native _ setObject <nl> - ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jobject value ) <nl> - { <nl> - value = ( * env ) - > NewLocalRef ( env , value ) ; <nl> - MEMCPY ( L2A ( addr ) , & value , sizeof ( jobject ) ) ; <nl> - } <nl> - <nl> - / * <nl> - * Class : Native <nl> * Method : malloc <nl> * Signature : ( J ) J <nl> * / <nl> @ @ - 1746 , 7 + 1721 , 7 @ @ getCallbackAddress ( JNIEnv * env , jobject obj ) { <nl> } <nl> <nl> jobject <nl> - initializeThread ( callback * cb , JavaVMAttachArgs * args ) { <nl> + initializeThread ( callback * cb , AttachOptions * args ) { <nl> JavaVM * jvm = cb - > vm ; <nl> JNIEnv * env ; <nl> jobject group = NULL ; <nl> @ @ - 1759 , 7 + 1734 , 7 @ @ initializeThread ( callback * cb , JavaVMAttachArgs * args ) { <nl> { <nl> jobject cbobj = ( * env ) - > NewLocalRef ( env , cb - > object ) ; <nl> if ( ! ( * env ) - > IsSameObject ( env , cbobj , NULL ) ) { <nl> - jobject argsobj = newJavaStructure ( env , args , classJavaVMAttachArgs , JNI _ FALSE ) ; <nl> + jobject argsobj = newJavaStructure ( env , args , classAttachOptions , JNI _ FALSE ) ; <nl> group = ( * env ) - > CallStaticObjectMethod ( env , classCallbackReference , <nl> MID _ CallbackReference _ initializeThread , <nl> cbobj , argsobj ) ; <nl> @ @ - 2033 , 9 + 2008 , 9 @ @ Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { <nl> throwByName ( env , EUnsatisfiedLink , <nl> " Can ' t obtain class com . sun . jna . Callback " ) ; <nl> } <nl> - else if ( ! LOAD _ CREF ( env , JavaVMAttachArgs , " com / sun / jna / CallbackReference $ JavaVMAttachArgs " ) ) { <nl> + else if ( ! LOAD _ CREF ( env , AttachOptions , " com / sun / jna / CallbackReference $ AttachOptions " ) ) { <nl> throwByName ( env , EUnsatisfiedLink , <nl> - " Can ' t obtain class com . sun . jna . CallbackReference . JavaVMAttachArgs " ) ; <nl> + " Can ' t obtain class com . sun . jna . CallbackReference . AttachOptions " ) ; <nl> } <nl> else if ( ! LOAD _ CREF ( env , CallbackReference , " com / sun / jna / CallbackReference " ) ) { <nl> throwByName ( env , EUnsatisfiedLink , <nl> @ @ - 2061 , 7 + 2036 , 7 @ @ Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { <nl> } <nl> else if ( ! ( MID _ CallbackReference _ initializeThread <nl> = ( * env ) - > GetStaticMethodID ( env , classCallbackReference , <nl> - " initializeThread " , " ( Lcom / sun / jna / Callback ; Lcom / sun / jna / CallbackReference $ JavaVMAttachArgs ; ) Ljava / lang / ThreadGroup ; " ) ) ) { <nl> + " initializeThread " , " ( Lcom / sun / jna / Callback ; Lcom / sun / jna / CallbackReference $ AttachOptions ; ) Ljava / lang / ThreadGroup ; " ) ) ) { <nl> throwByName ( env , EUnsatisfiedLink , <nl> " Can ' t obtain static method initializeThread from class com . sun . jna . CallbackReference " ) ; <nl> } <nl> @ @ - 2523 , 7 + 2498 , 7 @ @ JNI _ OnUnload ( JavaVM * vm , void * UNUSED ( reserved ) ) { <nl> & classDouble , & classPrimitiveDouble , <nl> & classPointer , & classNative , & classWString , <nl> & classStructure , & classStructureByValue , <nl> - & classCallbackReference , & classJavaVMAttachArgs , & classNativeMapped , <nl> + & classCallbackReference , & classAttachOptions , & classNativeMapped , <nl> & classIntegerType , & classPointerType , <nl> } ; <nl> unsigned i ; <nl> @ @ - 3093 , 12 + 3068 , 13 @ @ Java _ com _ sun _ jna _ Native _ initialize _ 1ffi _ 1type ( JNIEnv * env , jclass UNUSED ( cls ) , j <nl> return ( jint ) type - > size ; <nl> } <nl> <nl> - / * * Returns whether the current thread should be detached before return to <nl> - native code . <nl> - * / <nl> - int detachThread ( ) { <nl> - / / Kind of a hack , use last error value rather than setting up our own TLS <nl> - return GET _ LAST _ ERROR ( ) = = THREAD _ DETACH ; <nl> + / * * Returns the last error code . * / <nl> + int lastError ( ) { <nl> + return GET _ LAST _ ERROR ( ) ; <nl> + } <nl> + / * * Set the last error code . * / <nl> + void setLastError ( int err ) { <nl> + SET _ LAST _ ERROR ( err ) ; <nl> } <nl> <nl> # ifdef _ _ cplusplus <nl> diff - - git a / native / dispatch . h b / native / dispatch . h <nl> index 2ebe2d6 . . f72c7ec 100644 <nl> - - - a / native / dispatch . h <nl> + + + b / native / dispatch . h <nl> @ @ - 84 , 8 + 84 , 6 @ @ enum { <nl> <nl> / * callback behavior flags * / <nl> enum { <nl> - CB _ DAEMON = com _ sun _ jna _ Native _ CB _ DAEMON , <nl> - CB _ NODETACH = com _ sun _ jna _ Native _ CB _ NODETACH , <nl> CB _ HAS _ INITIALIZER = com _ sun _ jna _ Native _ CB _ HAS _ INITIALIZER , <nl> THREAD _ ATTACH = com _ sun _ jna _ Native _ THREAD _ ATTACH , <nl> THREAD _ DETACH = com _ sun _ jna _ Native _ THREAD _ DETACH , <nl> @ @ - 187 , 8 + 185 , 15 @ @ extern void writeStructure ( JNIEnv * , jobject ) ; <nl> extern jclass getNativeType ( JNIEnv * , jclass ) ; <nl> extern void toNative ( JNIEnv * , jobject , void * , size _ t , jboolean ) ; <nl> extern jclass fromNative ( JNIEnv * , jclass , ffi _ type * , void * , jboolean ) ; <nl> - extern jobject initializeThread ( callback * , JavaVMAttachArgs * ) ; <nl> - extern int detachThread ( ) ; <nl> + <nl> + typedef struct _ AttachOptions { <nl> + int daemon ; <nl> + int detach ; <nl> + const char * name ; <nl> + } AttachOptions ; <nl> + extern jobject initializeThread ( callback * , AttachOptions * ) ; <nl> + extern int lastError ( ) ; <nl> + extern void setLastError ( int err ) ; <nl> <nl> / * Native memory fault protection * / <nl> # ifdef HAVE _ PROTECTION <nl> diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java <nl> index 4e444b6 . . 161d4eb 100644 <nl> - - - a / src / com / sun / jna / CallbackReference . java <nl> + + + b / src / com / sun / jna / CallbackReference . java <nl> @ @ - 83 , 31 + 83 , 13 @ @ class CallbackReference extends WeakReference { <nl> } <nl> } <nl> <nl> - static class JavaVMAttachArgs extends Structure { <nl> - public int version ; <nl> + static class AttachOptions extends Structure { <nl> + public boolean daemon ; <nl> + public boolean detach ; <nl> public String name ; <nl> - public ThreadGroup group ; <nl> - protected int getNativeSize ( Class type , Object value ) { <nl> - if ( ThreadGroup . class . equals ( type ) ) { <nl> - return Pointer . SIZE ; <nl> - } <nl> - return super . getNativeSize ( type , value ) ; <nl> - } <nl> - protected int getNativeAlignment ( Class type , Object value , boolean isFirstElement ) { <nl> - if ( ThreadGroup . class . equals ( type ) ) { <nl> - type = Pointer . class ; <nl> - } <nl> - return super . getNativeAlignment ( type , value , isFirstElement ) ; <nl> - } <nl> - protected Pointer getFieldTypeInfo ( StructField f ) { <nl> - if ( ThreadGroup . class . equals ( f . type ) ) { <nl> - return getTypeInfo ( Pointer . class ) ; <nl> - } <nl> - return super . getFieldTypeInfo ( f ) ; <nl> - } <nl> } <nl> / * * Called from native code to initialize a callback thread . * / <nl> - private static ThreadGroup initializeThread ( Callback cb , JavaVMAttachArgs args ) { <nl> + private static ThreadGroup initializeThread ( Callback cb , AttachOptions args ) { <nl> CallbackThreadInitializer init = null ; <nl> if ( cb instanceof DefaultCallbackProxy ) { <nl> cb = ( ( DefaultCallbackProxy ) cb ) . getCallback ( ) ; <nl> @ @ - 115 , 32 + 97 , 15 @ @ class CallbackReference extends WeakReference { <nl> synchronized ( initializers ) { <nl> init = ( CallbackThreadInitializer ) initializers . get ( cb ) ; <nl> } <nl> + ThreadGroup group = null ; <nl> if ( init ! = null ) { <nl> - String name = init . getName ( cb ) ; <nl> - if ( name ! = null ) { <nl> - args . name = name ; <nl> - } <nl> - ThreadGroup group = init . getThreadGroup ( cb ) ; <nl> - if ( group ! = null ) { <nl> - args . group = group ; <nl> - } <nl> - int options = getCallbackOptions ( cb ) ; <nl> - if ( init . isDaemon ( cb ) ) { <nl> - options | = Native . CB _ DAEMON ; <nl> - } <nl> - else { <nl> - options & = ~ Native . CB _ DAEMON ; <nl> - } <nl> - if ( init . detach ( cb ) ) { <nl> - options & = ~ Native . CB _ NODETACH ; <nl> - } <nl> - else { <nl> - options | = Native . CB _ NODETACH ; <nl> - } <nl> - setCallbackOptions ( cb , options ) ; <nl> + group = init . getThreadGroup ( cb ) ; <nl> + args . name = init . getName ( cb ) ; <nl> + args . daemon = init . isDaemon ( cb ) ; <nl> + args . detach = init . detach ( cb ) ; <nl> args . write ( ) ; <nl> } <nl> - return args . group ; <nl> + return group ; <nl> } <nl> <nl> / * * Return a Callback associated with the given function pointer . <nl> diff - - git a / src / com / sun / jna / CallbackThreadInitializer . java b / src / com / sun / jna / CallbackThreadInitializer . java <nl> index 6f5a1ff . . a61c0cd 100644 <nl> - - - a / src / com / sun / jna / CallbackThreadInitializer . java <nl> + + + b / src / com / sun / jna / CallbackThreadInitializer . java <nl> @ @ - 11 , 23 + 11 , 51 @ @ package com . sun . jna ; <nl> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> * Lesser General Public License for more details . <nl> * / <nl> + / * * This class provides for customization of the mapping of native threads <nl> + * onto attached Java threads . Use <nl> + * { @ link Native # setCallbackThreadInitializer } to customize the thread context <nl> + * in which a given callback is invoked . < p / > <nl> + * When a JNA callback is invoked on a native thread that is not currently <nl> + * tracked by the VM and a < code > CallbackThreadInitiailizer < / code > is <nl> + * registered for that callback , the initializer object will be used to <nl> + * determine how the thread should be attached to the VM . < p / > . <nl> + * Once attached , the method { @ link Native # detach } may be used from within <nl> + * the callback invocation to alter whether the thread will be detached or not <nl> + * when the callback finishes execution . Typically this functionality is used <nl> + * in situations where you expect a callback to be called repeatedly from the <nl> + * same thread and you want to avoid potential extra thread allocation <nl> + * overhead on each callback invocation , since the VM may or may not re - use <nl> + * the same allocated thread object each time the thread is attached . < p / > <nl> + * A single initializer may be used for multiple callbacks , one initializer <nl> + * per callback , or you may subclass the initializer to provide different <nl> + * initializer settings depending on the callback . < p / > <nl> + * / <nl> public class CallbackThreadInitializer { <nl> private boolean daemon ; <nl> private boolean detach ; <nl> private String name ; <nl> private ThreadGroup group ; <nl> + / * * The default initializer causes the callback thread to remain attached <nl> + as a daemon thread , using the default thread name and group . <nl> + * / <nl> public CallbackThreadInitializer ( ) { <nl> - this ( false ) ; <nl> + this ( true ) ; <nl> } <nl> + / * * Keep the callback thread attached , with the given daemon state , <nl> + using the default thread name and group . <nl> + * / <nl> public CallbackThreadInitializer ( boolean daemon ) { <nl> this ( daemon , true ) ; <nl> } <nl> + / * * Uses the default thread name and group . * / <nl> public CallbackThreadInitializer ( boolean daemon , boolean detach ) { <nl> this ( daemon , detach , null ) ; <nl> } <nl> + / * * Uses the default thread group . * / <nl> public CallbackThreadInitializer ( boolean daemon , boolean detach , String name ) { <nl> this ( daemon , detach , name , null ) ; <nl> } <nl> + / * * Specify all aspects of how the callback thread should be initialized . * / <nl> public CallbackThreadInitializer ( boolean daemon , boolean detach , String name , ThreadGroup group ) { <nl> this . daemon = daemon ; <nl> this . detach = detach ; <nl> diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java <nl> index 7b66a0f . . c7bb5ba 100644 <nl> - - - a / src / com / sun / jna / Native . java <nl> + + + b / src / com / sun / jna / Native . java <nl> @ @ - 114 , 6 + 114 , 7 @ @ public final class Native { <nl> private static final int TYPE _ WCHAR _ T = 2 ; <nl> private static final int TYPE _ SIZE _ T = 3 ; <nl> <nl> + private static final int THREAD _ NOCHANGE = 0 ; <nl> private static final int THREAD _ DETACH = - 1 ; <nl> private static final int THREAD _ ATTACH = - 2 ; <nl> <nl> @ @ - 1053 , 16 + 1054 , 6 @ @ public final class Native { <nl> return context [ 3 ] ; <nl> } <nl> <nl> - / * * Set callback options . * / <nl> - public static void setCallbackOptions ( Callback cb , int options ) { <nl> - CallbackReference . setCallbackOptions ( cb , options ) ; <nl> - } <nl> - <nl> - / * * Get callback options . * / <nl> - public static int getCallbackOptions ( Callback cb ) { <nl> - return CallbackReference . getCallbackOptions ( cb ) ; <nl> - } <nl> - <nl> / * * Set a thread initializer for the given callback . <nl> The thread initializer indicates desired thread configuration when the <nl> given Callback is invoked on a native thread not yet attached to the <nl> @ @ - 1148 , 18 + 1139 , 8 @ @ public final class Native { <nl> return buf . toString ( ) ; <nl> } <nl> <nl> - / * * This callback behavior flag indicates that the native thread on which <nl> - the callback is invoked should be treated as a daemon thread . This is <nl> - only meaningful when used with the { @ link # CB _ NODETACH } . <nl> - * / <nl> - public static final int CB _ DAEMON = 1 ; <nl> - / * * This callback behavior flag indicates that the thread on which the <nl> - * callback is invoked should not be detached from the VM . Use this when <nl> - * you know your callback will be called repeatedly from the same thread . <nl> - * / <nl> - public static final int CB _ NODETACH = 2 ; <nl> / * * Indicates whether the callback has an initializer . * / <nl> - static final int CB _ HAS _ INITIALIZER = 4 ; <nl> + static final int CB _ HAS _ INITIALIZER = 1 ; <nl> <nl> private static final int CVT _ UNSUPPORTED = - 1 ; <nl> private static final int CVT _ DEFAULT = 0 ; <nl> @ @ - 1685 , 10 + 1666 , 6 @ @ public final class Native { <nl> <nl> static native void setString ( long addr , String value , boolean wide ) ; <nl> <nl> - / * * NOTE : no JNI references are created . * / <nl> - static native void setObject ( long addr , Object object ) ; <nl> - static native Object getObject ( long addr ) ; <nl> - <nl> / * * <nl> * Call the real native malloc <nl> * @ param size size of the memory to be allocated <nl> diff - - git a / src / com / sun / jna / Pointer . java b / src / com / sun / jna / Pointer . java <nl> index f422b03 . . 6c30f96 100644 <nl> - - - a / src / com / sun / jna / Pointer . java <nl> + + + b / src / com / sun / jna / Pointer . java <nl> @ @ - 464 , 11 + 464 , 8 @ @ public class Pointer { <nl> getArrayValue ( offset , result , type . getComponentType ( ) ) ; <nl> } <nl> else { <nl> - result = getObject ( offset ) ; <nl> - / * <nl> throw new IllegalArgumentException ( " Reading \ " " <nl> + type + " \ " from memory is not supported " ) ; <nl> - * / <nl> } <nl> return result ; <nl> } <nl> @ @ - 648 , 13 + 645 , 6 @ @ public class Pointer { <nl> } <nl> <nl> / * * <nl> - * Read a native jobject pointer as a Java Object . <nl> - * / <nl> - Object getObject ( long offset ) { <nl> - return Native . getObject ( peer + offset ) ; <nl> - } <nl> - <nl> - / * * <nl> * Get a ByteBuffer mapped to the memory pointed to by the pointer , <nl> * ensuring the buffer uses native byte order . <nl> * <nl> @ @ - 896 , 8 + 886 , 7 @ @ v * @ param wide whether to convert from a wide or standard C string <nl> setArrayValue ( offset , value , type . getComponentType ( ) ) ; <nl> } <nl> else { <nl> - setObject ( offset , value ) ; <nl> - / / throw new IllegalArgumentException ( " Writing " + type + " to memory is not supported " ) ; <nl> + throw new IllegalArgumentException ( " Writing " + type + " to memory is not supported " ) ; <nl> } <nl> } <nl> <nl> @ @ - 1107 , 11 + 1096 , 6 @ @ v * @ param wide whether to convert from a wide or standard C string <nl> Native . setPointer ( peer + offset , value ! = null ? value . peer : 0 ) ; <nl> } <nl> <nl> - / * * Write a Java Object as a native jobject pointer . * / <nl> - void setObject ( long offset , Object value ) { <nl> - Native . setObject ( peer + offset , value ) ; <nl> - } <nl> - <nl> / * * <nl> * Copy string < code > value < / code > to the location being pointed to . Copy <nl> * each element in < code > value < / code > , converted to native encoding , at an <nl> diff - - git a / src / com / sun / jna / overview . html b / src / com / sun / jna / overview . html <nl> index 686021e . . 7afc9fb 100644 <nl> - - - a / src / com / sun / jna / overview . html <nl> + + + b / src / com / sun / jna / overview . html <nl> @ @ - 330 , 8 + 330 , 7 @ @ improves performance if you know you will be getting multiple callbacks on the <nl> same thread , avoiding the need for the VM to generate multiple Java Thread <nl> objects for the same native thread . If you do leave the native thread <nl> attached , you should either ensure you detach it at some later point ( by <nl> - calling { @ link com . sun . jna . Native # setCallbackOptions ( Callback ) } without <nl> - { @ link com . sun . jna . Native # CB _ NODETACH } <nl> + calling { @ link com . sun . jna . Native # detach } from within the callback ) <nl> or return true from your <nl> { @ link com . sun . jna . CallbackThreadInitializer # isDaemon ( Callback ) } method so <nl> that the native thread will not prevent the VM from exiting . < p / > <nl> diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java <nl> index 3bfb210 . . 396d48b 100644 <nl> - - - a / test / com / sun / jna / CallbacksTest . java <nl> + + + b / test / com / sun / jna / CallbacksTest . java <nl> @ @ - 929 , 7 + 929 , 6 @ @ public class CallbacksTest extends TestCase { <nl> final Thread [ ] t = { null } ; <nl> <nl> ThreadGroup testGroup = new ThreadGroup ( getName ( ) ) ; <nl> - CallbackThreadInitializer init = new CallbackThreadInitializer ( ) ; <nl> TestLibrary . VoidCallback cb = new TestLibrary . VoidCallback ( ) { <nl> public void callback ( ) { <nl> Thread thread = Thread . currentThread ( ) ; <nl> @ @ - 940 , 9 + 939 , 10 @ @ public class CallbacksTest extends TestCase { <nl> + + called [ 0 ] ; <nl> } <nl> } ; <nl> - callCallback ( cb , init , 1 , 100 , called ) ; <nl> + callCallback ( cb , null , 1 , 100 , called ) ; <nl> <nl> assertFalse ( " Callback thread default should not be attached as daemon " , daemon [ 0 ] ) ; <nl> + / / thread name and group are not defined <nl> } <nl> <nl> public void testCustomizeCallbackThread ( ) throws Exception {

TEST DIFF:
diff - - git a / native / callback . c b / native / callback . c 
 index 9812dc4 . . 904acb9 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 23 , 12 + 23 , 17 @ @ 
 # include < windows . h > 
 # define TLS _ SET ( KEY , VALUE ) TlsSetValue ( KEY , VALUE ) 
 # define TLS _ GET ( KEY ) TlsGetValue ( KEY ) 
 + # define TLS _ KEY _ T DWORD 
 # else 
 # include < sys / types . h > 
 # include < sys / param . h > 
 + # include < pthread . h > 
 + # define PTHREADS 
 # define TLS _ SET ( KEY , VALUE ) ( pthread _ setspecific ( KEY , VALUE ) = = 0 ) 
 # define TLS _ GET ( KEY ) pthread _ getspecific ( KEY ) 
 + # define TLS _ KEY _ T pthread _ key _ t 
 # endif 
 + 
 # include " dispatch . h " 
 
 # ifdef _ _ cplusplus 
 @ @ - 74 , 9 + 79 , 18 @ @ static void * const dll _ fptrs [ ] = { 
 
 # endif / * _ WIN32 & & ! _ WIN32 _ WCE * / 
 
 + typedef struct _ tls { 
 + JavaVM * jvm ; 
 + jint last _ error ; 
 + jboolean detach ; 
 + char name [ 256 ] ; 
 + } thread _ storage ; 
 + 
 static void callback _ dispatch ( ffi _ cif * , void * , void * * , void * ) ; 
 static jclass classObject ; 
 
 + extern void println ( JNIEnv * , const char * ) ; 
 + 
 callback * 
 create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 jobjectArray param _ types , jclass return _ type , 
 @ @ - 475 , 43 + 489 , 74 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar 
 } 
 } 
 
 - / / Handle automatic thread cleanup 
 - static void detach _ thread ( void * data ) { 
 - if ( data ! = NULL ) { 
 - JavaVM * jvm = ( JavaVM * ) data ; 
 - ( * jvm ) - > DetachCurrentThread ( jvm ) ; 
 + static TLS _ KEY _ T tls _ thread _ data _ key ; 
 + static thread _ storage * get _ thread _ storage ( JNIEnv * env ) { 
 + thread _ storage * tls = ( thread _ storage * ) TLS _ GET ( tls _ thread _ data _ key ) ; 
 + if ( tls = = NULL ) { 
 + tls = ( thread _ storage * ) malloc ( sizeof ( thread _ storage ) ) ; 
 + if ( ! tls ) { 
 + throwByName ( env , EOutOfMemory , " JNA : Can ' t allocate thread storage " ) ; 
 + } 
 + else { 
 + snprintf ( tls - > name , sizeof ( tls - > name ) , " < uninitialized thread name > " ) ; 
 + if ( ( * env ) - > GetJavaVM ( env , & tls - > jvm ) ! = JNI _ OK ) { 
 + free ( tls ) ; 
 + throwByName ( env , EIllegalState , " JNA : Could not get JavaVM " ) ; 
 + tls = NULL ; 
 + } 
 + else if ( ! TLS _ SET ( tls _ thread _ data _ key , tls ) ) { 
 + free ( tls ) ; 
 + throwByName ( env , EOutOfMemory , " JNA : Internal TLS error " ) ; 
 + tls = NULL ; 
 + } 
 + else { 
 + fprintf ( stderr , " Created thread storage for % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; 
 + } 
 + } 
 + } 
 + return tls ; 
 + } 
 + 
 + static void dispose _ thread _ data ( void * data ) { 
 + thread _ storage * tls = ( thread _ storage * ) data ; 
 + JavaVM * jvm = tls - > jvm ; 
 + JNIEnv * env ; 
 + int is _ attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; 
 + if ( is _ attached ) { 
 + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { 
 + fprintf ( stderr , " JNA : could not detach native thread ( automatic ) \ n " ) ; 
 + } 
 + else { 
 + fprintf ( stderr , " Thread detached : % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; 
 + } 
 + fprintf ( stderr , " Dispose thread data % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; 
 + } 
 + else { 
 + fprintf ( stderr , " Thread already detached % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; 
 } 
 + free ( data ) ; 
 } 
 
 # ifdef _ WIN32 
 
 - static DWORD tls _ thread _ cleanup _ key ; 
 - static DWORD tls _ errno _ key , tls _ detach _ key ; 
 BOOL WINAPI DllMain ( HINSTANCE hDLL , DWORD fdwReason , LPVOID lpvReserved ) { 
 switch ( fdwReason ) { 
 case DLL _ PROCESS _ ATTACH : 
 - tls _ thread _ cleanup _ key = TlsAlloc ( ) ; 
 - if ( tls _ thread _ cleanup _ key = = TLS _ OUT _ OF _ INDEXES ) { 
 - return FALSE ; 
 - } 
 - tls _ detach _ key = TlsAlloc ( ) ; 
 - if ( tls _ detach _ key = = TLS _ OUT _ OF _ INDEXES ) { 
 - return FALSE ; 
 - } 
 - tls _ errno _ key = TlsAlloc ( ) ; 
 - if ( tls _ errno _ key = = TLS _ OUT _ OF _ INDEXES ) { 
 + tls _ thread _ data _ key = TlsAlloc ( ) ; 
 + if ( tls _ thread _ data _ key = = TLS _ OUT _ OF _ INDEXES ) { 
 return FALSE ; 
 } 
 break ; 
 case DLL _ PROCESS _ DETACH : 
 - TlsFree ( tls _ thread _ cleanup _ key ) ; 
 - TlsFree ( tls _ detach _ key ) ; 
 - TlsFree ( tls _ errno _ key ) ; 
 + TlsFree ( tls _ thread _ data _ key ) ; 
 break ; 
 case DLL _ THREAD _ ATTACH : 
 break ; 
 case DLL _ THREAD _ DETACH : { 
 - detach _ thread ( TlsGetValue ( tls _ thread _ cleanup _ key ) ) ; 
 + thread _ storage * tls = ( thread _ storage * ) TlsGetValue ( tls _ thread _ data _ key ) ; 
 + if ( tls ) { 
 + dispose _ thread _ data ( tls ) ; 
 + } 
 break ; 
 } 
 default : 
 @ @ - 520 , 71 + 565 , 50 @ @ BOOL WINAPI DllMain ( HINSTANCE hDLL , DWORD fdwReason , LPVOID lpvReserved ) { 
 return TRUE ; 
 } 
 
 - # else 
 - 
 - # include < pthread . h > 
 + # endif 
 
 - static pthread _ key _ t tls _ thread _ cleanup _ key , tls _ detach _ key ; 
 - static void make _ thread _ cleanup _ key ( ) { 
 - pthread _ key _ create ( & tls _ thread _ cleanup _ key , detach _ thread ) ; 
 + # ifdef PTHREADS 
 + static void make _ thread _ data _ key ( ) { 
 + pthread _ key _ create ( & tls _ thread _ data _ key , dispose _ thread _ data ) ; 
 } 
 - static pthread _ key _ t tls _ errno _ key ; 
 - static void make _ thread _ keys ( ) { 
 - pthread _ key _ create ( & tls _ errno _ key , NULL ) ; 
 - pthread _ key _ create ( & tls _ detach _ key , NULL ) ; 
 - } 
 - 
 # endif 
 
 / * * Store the requested detach state for the current thread . * / 
 void 
 - JNA _ detach ( jboolean d ) { 
 - if ( ! TLS _ SET ( tls _ detach _ key , L2A ( ( jlong ) ( d ? THREAD _ DETACH : THREAD _ LEAVE _ ATTACHED ) ) ) ) { 
 - fprintf ( stderr , " JNA : unable to set thread - local detach value \ n " ) ; 
 + JNA _ detach ( JNIEnv * env , jboolean d ) { 
 + thread _ storage * tls = get _ thread _ storage ( env ) ; 
 + if ( tls ) { 
 + tls - > detach = d ; 
 } 
 } 
 
 / * * Store the value of errno / GetLastError in TLS * / 
 void 
 - JNA _ set _ last _ error ( int err ) { 
 - if ( ! TLS _ SET ( tls _ errno _ key , L2A ( ( jlong ) err ) ) ) { 
 - fprintf ( stderr , " JNA : unable to set thread - local errno value \ n " ) ; 
 + JNA _ set _ last _ error ( JNIEnv * env , int err ) { 
 + thread _ storage * tls = get _ thread _ storage ( env ) ; 
 + if ( tls ) { 
 + tls - > last _ error = err ; 
 } 
 } 
 
 / * * Store the value of errno / GetLastError in TLS * / 
 int 
 - JNA _ get _ last _ error ( ) { 
 - return ( int ) A2L ( TLS _ GET ( tls _ errno _ key ) ) ; 
 - } 
 - 
 - / * * Set up to detach the thread when it exits , or clear any handlers if the 
 - argument is NULL . 
 - * / 
 - static void 
 - jvm _ detach _ on _ exit ( JavaVM * jvm ) { 
 - # ifdef _ WIN32 
 - if ( ! TlsSetValue ( tls _ thread _ cleanup _ key , ( void * ) jvm ) ) { 
 - fprintf ( stderr , " JNA : unable to set thread - local JVM value \ n " ) ; 
 - } 
 - # else 
 - static pthread _ once _ t key _ once = PTHREAD _ ONCE _ INIT ; 
 - pthread _ once ( & key _ once , make _ thread _ cleanup _ key ) ; 
 - if ( ! jvm | | pthread _ getspecific ( tls _ thread _ cleanup _ key ) = = NULL ) { 
 - if ( pthread _ setspecific ( tls _ thread _ cleanup _ key , jvm ) ) { 
 - fprintf ( stderr , " JNA : unable to set thread - local JVM value \ n " ) ; 
 - } 
 + JNA _ get _ last _ error ( JNIEnv * env ) { 
 + thread _ storage * tls = get _ thread _ storage ( env ) ; 
 + if ( tls ) { 
 + return tls - > last _ error ; 
 } 
 - # endif 
 + return 0 ; 
 } 
 
 static void 
 callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 callback * cb = ( ( callback * ) user _ data ) ; 
 JavaVM * jvm = cb - > vm ; 
 - JNIEnv * env ; 
 + JNIEnv * env = NULL ; 
 int was _ attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; 
 jboolean detach = was _ attached ? JNI _ FALSE : JNI _ TRUE ; 
 + thread _ storage * tls = was _ attached ? get _ thread _ storage ( env ) : NULL ; 
 
 if ( ! was _ attached ) { 
 int attach _ status = 0 ; 
 @ @ - 610 , 6 + 634 , 11 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 else { 
 attach _ status = ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , & args ) ; 
 } 
 + tls = get _ thread _ storage ( env ) ; 
 + if ( tls ) { 
 + snprintf ( tls - > name , sizeof ( tls - > name ) , 
 + args . name ? args . name : " < unconfigured thread > " ) ; 
 + } 
 if ( attach _ status ! = JNI _ OK ) { 
 fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback : % d \ n " , attach _ status ) ; 
 return ; 
 @ @ - 618 , 37 + 647 , 41 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 ( * env ) - > DeleteWeakGlobalRef ( env , args . group ) ; 
 } 
 } 
 - 
 + 	 	 	 	 	 	 
 + if ( ! tls ) { 
 + fprintf ( stderr , " JNA : couldn ' t obtain thread - local storage \ n " ) ; 
 + return ; 
 + } 
 + 
 + fprintf ( stderr , " % p ( % s ) was attached : % d \ n " , pthread _ self ( ) , tls - > name , was _ attached ) ; 
 + 
 / / Give the callback glue its own local frame to ensure all local references 
 / / are properly disposed 
 if ( ( * env ) - > PushLocalFrame ( env , 16 ) < 0 ) { 
 fprintf ( stderr , " JNA : Out of memory : Can ' t allocate local frame \ n " ) ; 
 } 
 else { 
 - TLS _ SET ( tls _ detach _ key , L2A ( ( jlong ) THREAD _ NOCHANGE ) ) ; 
 + tls - > detach = detach ; 
 callback _ invoke ( env , cb , cif , resp , cbargs ) ; 
 - switch ( ( int ) A2L ( TLS _ GET ( tls _ detach _ key ) ) ) { 
 - case THREAD _ LEAVE _ ATTACHED : detach = JNI _ FALSE ; break ; 
 - case THREAD _ DETACH : detach = JNI _ TRUE ; break ; 
 - default : break ; / * use default detach behavior * / 
 - } 
 + detach = tls - > detach ; 
 ( * env ) - > PopLocalFrame ( env , NULL ) ; 
 } 
 
 if ( detach ) { 
 - ( * jvm ) - > DetachCurrentThread ( jvm ) ; 
 - jvm _ detach _ on _ exit ( NULL ) ; 
 + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { 
 + fprintf ( stderr , " JNA : could not detach thread \ n " ) ; 
 + } 
 } 
 - else if ( ! was _ attached ) { 
 - jvm _ detach _ on _ exit ( jvm ) ; 
 + else { 
 + fprintf ( stderr , " Thread will detach automatically % p ( % s ) \ n " , pthread _ self ( ) , tls - > name ) ; 
 } 
 } 
 
 const char * 
 JNA _ callback _ init ( JNIEnv * env ) { 
 - # ifndef _ WIN32 
 + # ifdef PTHREADS 
 static pthread _ once _ t key _ once = PTHREAD _ ONCE _ INIT ; 
 - pthread _ once ( & key _ once , make _ thread _ keys ) ; 
 + pthread _ once ( & key _ once , make _ thread _ data _ key ) ; 
 # endif 
 
 if ( ! LOAD _ CREF ( env , Object , " java / lang / Object " ) ) return " java . lang . Object " ; 
 @ @ - 662 , 10 + 695 , 8 @ @ JNA _ callback _ dispose ( JNIEnv * env ) { 
 ( * env ) - > DeleteWeakGlobalRef ( env , classObject ) ; 
 classObject = NULL ; 
 } 
 - # ifndef _ WIN32 
 - pthread _ key _ delete ( tls _ errno _ key ) ; 
 - pthread _ key _ delete ( tls _ thread _ cleanup _ key ) ; 
 - pthread _ key _ delete ( tls _ detach _ key ) ; 
 + # ifdef PTHREADS 
 + pthread _ key _ delete ( tls _ thread _ data _ key ) ; 
 # endif 
 } 
 
 diff - - git a / native / dispatch . c b / native / dispatch . c 
 index 8205786 . . 809d666 100644 
 - - - a / native / dispatch . c 
 + + + b / native / dispatch . c 
 @ @ - 301 , 17 + 301 , 29 @ @ static ffi _ type * getStructureType ( JNIEnv * , jobject ) ; 
 
 typedef void ( JNICALL * release _ t ) ( JNIEnv * , jarray , void * , jint ) ; 
 
 - # if 0 
 + # if 1 
 / * * Invokes System . err . println ( for debugging only ) . * / 
 - static void 
 + void 
 println ( JNIEnv * env , const char * msg ) { 
 jclass cls = ( * env ) - > FindClass ( env , " java / lang / System " ) ; 
 + if ( ! cls ) { 
 + fprintf ( stderr , " JNA : failed to find java . lang . System \ n " ) ; 
 + return ; 
 + } 
 jfieldID fid = ( * env ) - > GetStaticFieldID ( env , cls , " err " , 
 - " Ljava / io / PrintStream ; " ) ; 
 + 	 	 	 	 	 " Ljava / io / PrintStream ; " ) ; 
 jobject err = ( * env ) - > GetStaticObjectField ( env , cls , fid ) ; 
 + if ( ! err ) { 
 + fprintf ( stderr , " JNA : failed to find System . err \ n " ) ; 
 + return ; 
 + } 
 jclass pscls = ( * env ) - > FindClass ( env , " java / io / PrintStream " ) ; 
 + if ( ! pscls ) { 
 + fprintf ( stderr , " JNA : failed to find java . io . PrintStream \ n " ) ; 
 + return ; 
 + } 
 jmethodID mid = ( * env ) - > GetMethodID ( env , pscls , " println " , 
 - " ( Ljava / lang / String ; ) V " ) ; 
 + 	 	 	 	 " ( Ljava / lang / String ; ) V " ) ; 
 jstring str = newJavaString ( env , msg , JNI _ FALSE ) ; 
 ( * env ) - > CallObjectMethod ( env , err , mid , str ) ; 
 } 
 @ @ - 568 , 7 + 580 , 7 @ @ dispatch ( JNIEnv * env , void * func , jint flags , jobjectArray arr , 
 } 
 } 
 else if ( preserve _ last _ error ) { 
 - JNA _ set _ last _ error ( GET _ LAST _ ERROR ( ) ) ; 
 + JNA _ set _ last _ error ( env , GET _ LAST _ ERROR ( ) ) ; 
 } 
 PROTECTED _ END ( do { throw _ type = EError ; throw _ msg = " Invalid memory access " ; } while ( 0 ) ) ; 
 } 
 @ @ - 987 , 10 + 999 , 13 @ @ initializeThread ( callback * cb , AttachOptions * args ) { 
 JavaVM * jvm = cb - > vm ; 
 JNIEnv * env ; 
 jobject group = NULL ; 
 + int attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; 
 
 - if ( ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , NULL ) ! = JNI _ OK ) { 
 - fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback thread initialization \ n " ) ; 
 - return NULL ; 
 + if ( ! attached ) { 
 + if ( ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , NULL ) ! = JNI _ OK ) { 
 + fprintf ( stderr , " JNA : Can ' t attach native thread to VM for callback thread initialization \ n " ) ; 
 + return NULL ; 
 + } 
 } 
 ( * env ) - > PushLocalFrame ( env , 16 ) ; 
 { 
 @ @ - 1006 , 7 + 1021 , 11 @ @ initializeThread ( callback * cb , AttachOptions * args ) { 
 } 
 } 
 ( * env ) - > PopLocalFrame ( env , NULL ) ; 
 - ( * jvm ) - > DetachCurrentThread ( jvm ) ; 
 + if ( ! attached ) { 
 + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { 
 + fprintf ( stderr , " JNA : could not detach thread after callback init \ n " ) ; 
 + } 
 + } 
 
 return group ; 
 } 
 @ @ - 1715 , 7 + 1734 , 7 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { 
 } 
 } 
 else if ( preserve _ last _ error ) { 
 - JNA _ set _ last _ error ( GET _ LAST _ ERROR ( ) ) ; 
 + JNA _ set _ last _ error ( env , GET _ LAST _ ERROR ( ) ) ; 
 } 
 PROTECTED _ END ( do { throw _ type = EError ; throw _ msg = " Invalid memory access " ; } while ( 0 ) ) ; 
 } 
 @ @ - 1792 , 9 + 1811 , 8 @ @ closure _ handler ( ffi _ cif * cif , void * resp , void * * argp , void * cdata ) 
 JavaVM * jvm = cb - > vm ; 
 JNIEnv * env ; 
 jobject obj ; 
 - int attached ; 
 + int attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; 
 
 - attached = ( * jvm ) - > GetEnv ( jvm , ( void * ) & env , JNI _ VERSION _ 1 _ 4 ) = = JNI _ OK ; 
 if ( ! attached ) { 
 if ( ( * jvm ) - > AttachCurrentThread ( jvm , ( void * ) & env , NULL ) ! = JNI _ OK ) { 
 fprintf ( stderr , " JNA : Can ' t attach native thread to VM for closure handler \ n " ) ; 
 @ @ - 1823 , 7 + 1841 , 9 @ @ closure _ handler ( ffi _ cif * cif , void * resp , void * * argp , void * cdata ) 
 } 
 
 if ( ! attached ) { 
 - ( * jvm ) - > DetachCurrentThread ( jvm ) ; 
 + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { 
 + fprintf ( stderr , " JNA : could not detach thread after callback handling \ n " ) ; 
 + } 
 } 
 } 
 
 @ @ - 2936 , 13 + 2956 , 13 @ @ Java _ com _ sun _ jna _ Native _ getPreserveLastError ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( 
 
 JNIEXPORT void JNICALL 
 Java _ com _ sun _ jna _ Native _ setLastError ( JNIEnv * env , jclass UNUSED ( classp ) , jint code ) { 
 - JNA _ set _ last _ error ( code ) ; 
 + JNA _ set _ last _ error ( env , code ) ; 
 SET _ LAST _ ERROR ( code ) ; 
 } 
 
 JNIEXPORT jint JNICALL 
 Java _ com _ sun _ jna _ Native _ getLastError ( JNIEnv * env , jclass UNUSED ( classp ) ) { 
 - return JNA _ get _ last _ error ( ) ; 
 + return JNA _ get _ last _ error ( env ) ; 
 } 
 
 JNIEXPORT jstring JNICALL 
 @ @ - 2984 , 7 + 3004 , 9 @ @ JNI _ OnLoad ( JavaVM * jvm , void * UNUSED ( reserved ) ) { 
 result = 0 ; 
 } 
 if ( ! attached ) { 
 - ( * jvm ) - > DetachCurrentThread ( jvm ) ; 
 + if ( ( * jvm ) - > DetachCurrentThread ( jvm ) ! = 0 ) { 
 + fprintf ( stderr , " JNA : could not detach thread on initial load \ n " ) ; 
 + } 
 } 
 
 return result ; 
 @ @ - 3046 , 7 + 3068 , 9 @ @ JNI _ OnUnload ( JavaVM * vm , void * UNUSED ( reserved ) ) { 
 } 
 
 if ( ! attached ) { 
 - ( * vm ) - > DetachCurrentThread ( vm ) ; 
 + if ( ( * vm ) - > DetachCurrentThread ( vm ) ! = 0 ) { 
 + fprintf ( stderr , " JNA : could not detach thread on unload \ n " ) ; 
 + } 
 } 
 } 
 
 @ @ - 3246 , 7 + 3270 , 7 @ @ Java _ com _ sun _ jna _ Native _ initialize _ 1ffi _ 1type ( JNIEnv * env , jclass UNUSED ( cls ) , j 
 
 JNIEXPORT void JNICALL 
 Java _ com _ sun _ jna _ Native _ detach ( JNIEnv * env , jclass UNUSED ( cls ) , jboolean d ) { 
 - JNA _ detach ( d ) ; 
 + JNA _ detach ( env , d ) ; 
 } 
 
 # ifdef _ _ cplusplus 
 diff - - git a / native / dispatch . h b / native / dispatch . h 
 index aea2d8d . . cc98f37 100644 
 - - - a / native / dispatch . h 
 + + + b / native / dispatch . h 
 @ @ - 94 , 10 + 94 , 6 @ @ enum { 
 / * callback behavior flags * / 
 enum { 
 CB _ HAS _ INITIALIZER = com _ sun _ jna _ Native _ CB _ HAS _ INITIALIZER , 
 - / / detach options 
 - THREAD _ NOCHANGE , 
 - THREAD _ DETACH , 
 - THREAD _ LEAVE _ ATTACHED , 
 } ; 
 
 typedef struct _ callback { 
 @ @ - 176 , 10 + 172 , 10 @ @ extern int get _ jtype ( JNIEnv * , jclass ) ; 
 extern ffi _ type * get _ ffi _ type ( JNIEnv * , jclass , char ) ; 
 extern ffi _ type * get _ ffi _ rtype ( JNIEnv * , jclass , char ) ; 
 extern const char * JNA _ callback _ init ( JNIEnv * ) ; 
 - extern void JNA _ set _ last _ error ( int ) ; 
 - extern int JNA _ get _ last _ error ( ) ; 
 + extern void JNA _ set _ last _ error ( JNIEnv * , int ) ; 
 + extern int JNA _ get _ last _ error ( JNIEnv * ) ; 
 extern void JNA _ callback _ dispose ( JNIEnv * ) ; 
 - extern void JNA _ detach ( jboolean ) ; 
 + extern void JNA _ detach ( JNIEnv * , jboolean ) ; 
 extern callback * create _ callback ( JNIEnv * , jobject , jobject , 
 jobjectArray , jclass , 
 callconv _ t , jint ) ; 
 diff - - git a / native / testlib . c b / native / testlib . c 
 index 60dc1d7 . . 87df97c 100644 
 - - - a / native / testlib . c 
 + + + b / native / testlib . c 
 @ @ - 19 , 6 + 19 , 7 @ @ extern " C " { 
 # include < wchar . h > 
 # include < stdio . h > 
 # include < stdarg . h > 
 + # include < stdlib . h > 
 # if ! defined ( _ WIN32 _ WCE ) 
 # include < errno . h > 
 # endif 
 @ @ - 635 , 29 + 636 , 33 @ @ typedef struct thread _ data { 
 int repeat _ count ; 
 int sleep _ time ; 
 void ( * func ) ( void ) ; 
 + char name [ 256 ] ; 
 } thread _ data ; 
 static THREAD _ FUNC ( thread _ function , arg ) { 
 - / / make a local copy 
 thread _ data td = * ( thread _ data * ) arg ; 
 void ( * func ) ( void ) = td . func ; 
 int i ; 
 + fprintf ( stderr , " thread start 0x % p ( % s ) \ n " , THREAD _ CURRENT ( ) , td . name ) ; 
 
 for ( i = 0 ; i < td . repeat _ count ; i + + ) { 
 func ( ) ; 
 SLEEP ( td . sleep _ time ) ; 
 } 
 + fprintf ( stderr , " thread exiting 0x % p ( % s ) \ n " , THREAD _ CURRENT ( ) , td . name ) ; 
 + free ( ( void * ) arg ) ; 
 THREAD _ EXIT ( ) ; 
 THREAD _ RETURN ; 
 } 
 
 - static thread _ data data ; 
 EXPORT void 
 - callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms ) { 
 + callVoidCallbackThreaded ( void ( * func ) ( void ) , int n , int ms , const char * name ) { 
 THREAD _ T thread ; 
 - data . repeat _ count = n ; 
 - data . sleep _ time = ms ; 
 - data . func = func ; 
 - THREAD _ CREATE ( & thread , & thread _ function , & data ) ; 
 + thread _ data * data = ( thread _ data * ) malloc ( sizeof ( thread _ data ) ) ; 
 + data - > repeat _ count = n ; 
 + data - > sleep _ time = ms ; 
 + data - > func = func ; 
 + snprintf ( data - > name , sizeof ( data - > name ) , " % s " , name ) ; 
 + THREAD _ CREATE ( & thread , & thread _ function , data ) ; 
 } 
 
 EXPORT int 
 diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java 
 index 3061411 . . 84fd206 100644 
 - - - a / test / com / sun / jna / CallbacksTest . java 
 + + + b / test / com / sun / jna / CallbacksTest . java 
 @ @ - 84 , 7 + 84 , 7 @ @ public class CallbacksTest extends TestCase { 
 void callback ( ) ; 
 } 
 void callVoidCallback ( VoidCallback c ) ; 
 - void callVoidCallbackThreaded ( VoidCallback c , int count , int ms ) ; 
 + void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name ) ; 
 interface VoidCallbackCustom extends Callback { 
 void customMethodName ( ) ; 
 } 
 @ @ - 184 , 6 + 184 , 7 @ @ public class CallbacksTest extends TestCase { 
 TestLibrary lib ; 
 protected void setUp ( ) { 
 lib = ( TestLibrary ) Native . loadLibrary ( " testlib " , TestLibrary . class ) ; 
 + 	 System . out . println ( " Run " + getName ( ) ) ; 
 } 
 
 protected void tearDown ( ) { 
 @ @ - 985 , 13 + 986 , 20 @ @ public class CallbacksTest extends TestCase { 
 CallbackThreadInitializer cti , 
 int repeat , int sleepms , 
 int [ ] called ) throws Exception { 
 + 	 callThreadedCallback ( cb , cti , repeat , sleepms , called , repeat ) ; 
 + } 
 + 
 + protected void callThreadedCallback ( TestLibrary . VoidCallback cb , 
 + CallbackThreadInitializer cti , 
 + int repeat , int sleepms , 
 + int [ ] called , int returnAfter ) throws Exception { 
 if ( cti ! = null ) { 
 Native . setCallbackThreadInitializer ( cb , cti ) ; 
 } 
 - lib . callVoidCallbackThreaded ( cb , repeat , sleepms ) ; 
 + lib . callVoidCallbackThreaded ( cb , repeat , sleepms , getName ( ) ) ; 
 
 long start = System . currentTimeMillis ( ) ; 
 - while ( called [ 0 ] < repeat ) { 
 + while ( called [ 0 ] < returnAfter ) { 
 Thread . sleep ( 10 ) ; 
 if ( System . currentTimeMillis ( ) - start > 5000 ) { 
 fail ( " Timed out waiting for callback , invoked " + called [ 0 ] + " times so far " ) ; 
 @ @ - 1029 , 10 + 1037 , 10 @ @ public class CallbacksTest extends TestCase { 
 final String [ ] name = { null } ; 
 final ThreadGroup [ ] group = { null } ; 
 final Thread [ ] t = { null } ; 
 - final String tname = getName ( ) + " thread " ; 
 + final String tname = " Test thread for " + getName ( ) ; 
 final boolean [ ] alive = { false } ; 
 
 - ThreadGroup testGroup = new ThreadGroup ( getName ( ) + " thread group " ) ; 
 + ThreadGroup testGroup = new ThreadGroup ( " Thread group for " + getName ( ) ) ; 
 CallbackThreadInitializer init = new CallbackThreadInitializer ( true , false , tname , testGroup ) ; 
 TestLibrary . VoidCallback cb = new TestLibrary . VoidCallback ( ) { 
 public void callback ( ) { 
 @ @ - 1042 , 7 + 1050 , 7 @ @ public class CallbacksTest extends TestCase { 
 group [ 0 ] = thread . getThreadGroup ( ) ; 
 t [ 0 ] = thread ; 
 if ( thread . isAlive ( ) ) { 
 - / / NOTE : phoneME incorrectly reports thread " alive " status 
 + / / NOTE : older phoneME incorrectly reports thread " alive " status 
 alive [ 0 ] = true ; 
 } 
 
 @ @ - 1052 , 16 + 1060 , 32 @ @ public class CallbacksTest extends TestCase { 
 } 
 } 
 } ; 
 - callThreadedCallback ( cb , init , 1 , 5000 , called ) ; 
 + callThreadedCallback ( cb , init , 2 , 2000 , called , 1 ) ; 
 
 assertTrue ( " Callback thread not attached as daemon " , daemon [ 0 ] ) ; 
 assertEquals ( " Wrong thread name " , tname , name [ 0 ] ) ; 
 assertEquals ( " Wrong thread group " , testGroup , group [ 0 ] ) ; 
 - / / NOTE : phoneME incorrectly reports thread " alive " status 
 + / / NOTE : older phoneME incorrectly reports thread " alive " status 
 if ( ! alive [ 0 ] ) { 
 throw new Error ( " VM incorrectly reports Thread . isAlive ( ) = = false within callback " ) ; 
 } 
 assertTrue ( " Thread should still be alive " , t [ 0 ] . isAlive ( ) ) ; 
 + 
 + long start = System . currentTimeMillis ( ) ; 
 + 	 while ( called [ 0 ] < 2 ) { 
 + 	 Thread . sleep ( 10 ) ; 
 + 	 if ( System . currentTimeMillis ( ) - start > 5000 ) { 
 + 	 	 fail ( " Timed out waiting for second callback invocation , which indicates detach " ) ; 
 + 	 } 
 + 	 } 
 + 
 + start = System . currentTimeMillis ( ) ; 
 + 	 while ( t [ 0 ] . isAlive ( ) ) { 
 + 	 Thread . sleep ( 10 ) ; 
 + 	 if ( System . currentTimeMillis ( ) - start > 5000 ) { 
 + 	 	 fail ( " Timed out waiting for thread to detach and die " ) ; 
 + 	 } 
 + 	 } 
 } 
 
 / / Detach preference is indicated by the initializer . Thread is attached 
 @ @ - 1073 , 7 + 1097 , 7 @ @ public class CallbacksTest extends TestCase { 
 final int COUNT = 5 ; 
 CallbackThreadInitializer init = new CallbackThreadInitializer ( true , false ) { 
 public String getName ( Callback cb ) { 
 - return CallbacksTest . this . getName ( ) + " thread " + called [ 0 ] ; 
 + return " Test thread for " + CallbacksTest . this . getName ( ) + " ( call count : " + called [ 0 ] + " ) " ; 
 } 
 } ; 
 TestLibrary . VoidCallback cb = new TestLibrary . VoidCallback ( ) { 
 @ @ - 1096 , 24 + 1120 , 32 @ @ public class CallbacksTest extends TestCase { 
 public void callback ( ) { 
 threads . add ( new WeakReference ( Thread . currentThread ( ) ) ) ; 
 if ( + + called [ 0 ] = = 1 ) { 
 - Thread . currentThread ( ) . setName ( " Thread to be cleaned up " ) ; 
 + Thread . currentThread ( ) . setName ( getName ( ) + " ( Thread to be cleaned up ) " ) ; 
 } 
 - Native . detach ( false ) ; 
 + 	 	 Native . detach ( false ) ; 
 } 
 } ; 
 - CallbackThreadInitializer asDaemon = new CallbackThreadInitializer ( true ) ; 
 - callThreadedCallback ( cb , asDaemon , 1 , 0 , called ) ; 
 - while ( threads . size ( ) = = 0 ) { 
 + 	 / / Always attach as daemon to ensure tests will exit 
 + CallbackThreadInitializer asDaemon = new CallbackThreadInitializer ( true ) { 
 + 	 public String getName ( Callback cb ) { 
 + 	 	 return " Test thread for " + CallbacksTest . this . getName ( ) ; 
 + 	 } 
 + 	 } ; 
 + callThreadedCallback ( cb , asDaemon , 2 , 100 , called ) ; 
 + 	 / / Wait for it to start up 
 + while ( threads . size ( ) = = 0 & & called [ 0 ] = = 0 ) { 
 Thread . sleep ( 10 ) ; 
 } 
 long start = System . currentTimeMillis ( ) ; 
 WeakReference ref = ( WeakReference ) threads . iterator ( ) . next ( ) ; 
 while ( ref . get ( ) ! = null ) { 
 System . gc ( ) ; 
 - Thread . sleep ( 10 ) ; 
 + Thread . sleep ( 1000 ) ; 
 + 	 Thread [ ] remaining = new Thread [ Thread . activeCount ( ) ] ; 
 + 	 Thread . enumerate ( remaining ) ; 
 if ( System . currentTimeMillis ( ) - start > 10000 ) { 
 Thread t = ( Thread ) ref . get ( ) ; 
 - fail ( " Timed out waiting for attached thread to be detached on exit and disposed : " + t + " alive : " + t . isAlive ( ) + " daemon " + t . isDaemon ( ) ) ; 
 + fail ( " Timed out waiting for native attached thread to be GC ' d : " + t + " alive : " + t . isAlive ( ) + " daemon : " + t . isDaemon ( ) + " \ n " + Arrays . asList ( remaining ) ) ; 
 } 
 } 
 } 
 diff - - git a / test / com / sun / jna / DirectCallbacksTest . java b / test / com / sun / jna / DirectCallbacksTest . java 
 index e97a449 . . 9e92c9b 100644 
 - - - a / test / com / sun / jna / DirectCallbacksTest . java 
 + + + b / test / com / sun / jna / DirectCallbacksTest . java 
 @ @ - 42 , 7 + 42 , 7 @ @ public class DirectCallbacksTest extends CallbacksTest { 
 public native Int32CallbackX returnCallback ( ) ; 
 public native Int32CallbackX returnCallbackArgument ( Int32CallbackX cb ) ; 
 public native void callVoidCallback ( VoidCallback c ) ; 
 - public native void callVoidCallbackThreaded ( VoidCallback c , int count , int ms ) ; 
 + public native void callVoidCallbackThreaded ( VoidCallback c , int count , int ms , String name ) ; 
 
 public native int callInt32Callback ( CustomCallback cb , int arg1 , int arg2 ) ; 
 public native void callCallbackInStruct ( CbStruct s ) ;

NEAREST DIFF:
diff - - git a / build . xml b / build . xml 
 index eb8f38b . . 5ac60dd 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 45 , 7 + 45 , 7 @ @ 
 < property name = " jni . revision " value = " 0 " / > 
 < property name = " jni . build " value = " $ { build . number } " / > 
 < property name = " jni . version " value = " $ { jni . major } . $ { jni . minor } . $ { jni . revision } " / > 
 - < property name = " jni . md5 " value = " fff3cb3f61b8e1c7748924c5654073ee " / > 
 + < property name = " jni . md5 " value = " 4c69bcf40b30785215211b5a5dad211e " / > 
 < property name = " spec . title " value = " Java Native Access ( JNA ) " / > 
 < property name = " spec . vendor " value = " $ { vendor } " / > 
 < property name = " spec . version " value = " $ { jna . major } " / > 
 diff - - git a / native / Makefile b / native / Makefile 
 index a370c49 . . 1dccb2b 100644 
 - - - a / native / Makefile 
 + + + b / native / Makefile 
 @ @ - 28 , 7 + 28 , 7 @ @ OS = $ ( shell uname | sed - e ' s / \ ( CYGWIN \ | MINGW32 \ ) . * / win32 / g ' \ 
 - e ' s / Linux . * / linux / g ' ) 
 
 JNA _ JNI _ VERSION = 3 . 3 . 0 # auto - generated by ant 
 - CHECKSUM = fff3cb3f61b8e1c7748924c5654073ee # auto - generated by ant 
 + CHECKSUM = 4c69bcf40b30785215211b5a5dad211e # auto - generated by ant 
 
 JAVA _ INCLUDES = - I " $ ( JAVA _ HOME ) / include " \ 
 - I " $ ( JAVA _ HOME ) / include / $ ( OS ) " 
 diff - - git a / native / callback . c b / native / callback . c 
 index 7e2632b0 . . d940b4a 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 402 , 14 + 402 , 22 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 int attach _ status = 0 ; 
 JavaVMAttachArgs args ; 
 jobject group = NULL ; 
 + int daemon = JNI _ FALSE ; 
 
 args . version = JNI _ VERSION _ 1 _ 2 ; 
 args . name = NULL ; 
 args . group = NULL ; 
 if ( cb - > behavior _ flags & CB _ HAS _ INITIALIZER ) { 
 - args . group = initializeThread ( cb , & args ) ; 
 + AttachOptions options ; 
 + options . daemon = JNI _ FALSE ; 
 + options . detach = JNI _ TRUE ; 
 + options . name = NULL ; 
 + args . group = initializeThread ( cb , & options ) ; 
 + daemon = options . daemon ; 
 + detach = detach & & options . detach ; 
 + args . name = options . name ; 
 } 
 - if ( cb - > behavior _ flags & CB _ DAEMON ) { 
 + if ( daemon ) { 
 attach _ status = ( * jvm ) - > AttachCurrentThreadAsDaemon ( jvm , ( void * ) & env , & args ) ; 
 } 
 else { 
 @ @ - 430 , 10 + 438 , 16 @ @ callback _ dispatch ( ffi _ cif * cif , void * resp , void * * cbargs , void * user _ data ) { 
 fprintf ( stderr , " JNA : Out of memory : Can ' t allocate local frame " ) ; 
 } 
 else { 
 + / / Kind of a hack , use last error value rather than setting up our own TLS 
 + setLastError ( 0 ) ; 
 callback _ invoke ( env , cb , cif , resp , cbargs ) ; 
 / / Must be invoked immediately after return to avoid anything 
 / / stepping on errno / GetLastError 
 - detach = detachThread ( ) ; 
 + switch ( lastError ( ) ) { 
 + case THREAD _ DETACH : detach = JNI _ TRUE ; break ; 
 + case THREAD _ ATTACH : detach = JNI _ FALSE ; break ; 
 + default : break ; 
 + } 
 ( * env ) - > PopLocalFrame ( env , NULL ) ; 
 } 
 
 diff - - git a / native / dispatch . c b / native / dispatch . c 
 index c494438 . . 478a2c4 100644 
 - - - a / native / dispatch . c 
 + + + b / native / dispatch . c 
 @ @ - 136 , 7 + 136 , 7 @ @ static jclass classStructure ; 
 static jclass classStructureByValue ; 
 static jclass classCallback ; 
 static jclass classCallbackReference ; 
 - static jclass classJavaVMAttachArgs ; 
 + static jclass classAttachOptions ; 
 static jclass classNativeMapped ; 
 static jclass classIntegerType ; 
 static jclass classPointerType ; 
 @ @ - 1133 , 19 + 1133 , 6 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Native _ _ 1getPointer 
 } 
 
 / * 
 - * Class : Native 
 - * Method : getObject 
 - * Signature : ( J ) Ljava / lang / Object ; 
 - * / 
 - JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Native _ getObject 
 - ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 - { 
 - jobject obj = NULL ; 
 - MEMCPY ( & obj , L2A ( addr ) , sizeof ( obj ) ) ; 
 - return obj ; 
 - } 
 - 
 - / * 
 * Class : com _ sun _ jna _ Native 
 * Method : _ getDirectByteBuffer 
 * Signature : ( JJ ) Ljava / nio / ByteBuffer ; 
 @ @ - 1360 , 18 + 1347 , 6 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Native _ setString 
 
 / * 
 * Class : Native 
 - * Method : setObject 
 - * Signature : ( JLjava / lang / Object ; Z ) V 
 - * / 
 - JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Native _ setObject 
 - ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jobject value ) 
 - { 
 - value = ( * env ) - > NewLocalRef ( env , value ) ; 
 - MEMCPY ( L2A ( addr ) , & value , sizeof ( jobject ) ) ; 
 - } 
 - 
 - / * 
 - * Class : Native 
 * Method : malloc 
 * Signature : ( J ) J 
 * / 
 @ @ - 1746 , 7 + 1721 , 7 @ @ getCallbackAddress ( JNIEnv * env , jobject obj ) { 
 } 
 
 jobject 
 - initializeThread ( callback * cb , JavaVMAttachArgs * args ) { 
 + initializeThread ( callback * cb , AttachOptions * args ) { 
 JavaVM * jvm = cb - > vm ; 
 JNIEnv * env ; 
 jobject group = NULL ; 
 @ @ - 1759 , 7 + 1734 , 7 @ @ initializeThread ( callback * cb , JavaVMAttachArgs * args ) { 
 { 
 jobject cbobj = ( * env ) - > NewLocalRef ( env , cb - > object ) ; 
 if ( ! ( * env ) - > IsSameObject ( env , cbobj , NULL ) ) { 
 - jobject argsobj = newJavaStructure ( env , args , classJavaVMAttachArgs , JNI _ FALSE ) ; 
 + jobject argsobj = newJavaStructure ( env , args , classAttachOptions , JNI _ FALSE ) ; 
 group = ( * env ) - > CallStaticObjectMethod ( env , classCallbackReference , 
 MID _ CallbackReference _ initializeThread , 
 cbobj , argsobj ) ; 
 @ @ - 2033 , 9 + 2008 , 9 @ @ Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { 
 throwByName ( env , EUnsatisfiedLink , 
 " Can ' t obtain class com . sun . jna . Callback " ) ; 
 } 
 - else if ( ! LOAD _ CREF ( env , JavaVMAttachArgs , " com / sun / jna / CallbackReference $ JavaVMAttachArgs " ) ) { 
 + else if ( ! LOAD _ CREF ( env , AttachOptions , " com / sun / jna / CallbackReference $ AttachOptions " ) ) { 
 throwByName ( env , EUnsatisfiedLink , 
 - " Can ' t obtain class com . sun . jna . CallbackReference . JavaVMAttachArgs " ) ; 
 + " Can ' t obtain class com . sun . jna . CallbackReference . AttachOptions " ) ; 
 } 
 else if ( ! LOAD _ CREF ( env , CallbackReference , " com / sun / jna / CallbackReference " ) ) { 
 throwByName ( env , EUnsatisfiedLink , 
 @ @ - 2061 , 7 + 2036 , 7 @ @ Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { 
 } 
 else if ( ! ( MID _ CallbackReference _ initializeThread 
 = ( * env ) - > GetStaticMethodID ( env , classCallbackReference , 
 - " initializeThread " , " ( Lcom / sun / jna / Callback ; Lcom / sun / jna / CallbackReference $ JavaVMAttachArgs ; ) Ljava / lang / ThreadGroup ; " ) ) ) { 
 + " initializeThread " , " ( Lcom / sun / jna / Callback ; Lcom / sun / jna / CallbackReference $ AttachOptions ; ) Ljava / lang / ThreadGroup ; " ) ) ) { 
 throwByName ( env , EUnsatisfiedLink , 
 " Can ' t obtain static method initializeThread from class com . sun . jna . CallbackReference " ) ; 
 } 
 @ @ - 2523 , 7 + 2498 , 7 @ @ JNI _ OnUnload ( JavaVM * vm , void * UNUSED ( reserved ) ) { 
 & classDouble , & classPrimitiveDouble , 
 & classPointer , & classNative , & classWString , 
 & classStructure , & classStructureByValue , 
 - & classCallbackReference , & classJavaVMAttachArgs , & classNativeMapped , 
 + & classCallbackReference , & classAttachOptions , & classNativeMapped , 
 & classIntegerType , & classPointerType , 
 } ; 
 unsigned i ; 
 @ @ - 3093 , 12 + 3068 , 13 @ @ Java _ com _ sun _ jna _ Native _ initialize _ 1ffi _ 1type ( JNIEnv * env , jclass UNUSED ( cls ) , j 
 return ( jint ) type - > size ; 
 } 
 
 - / * * Returns whether the current thread should be detached before return to 
 - native code . 
 - * / 
 - int detachThread ( ) { 
 - / / Kind of a hack , use last error value rather than setting up our own TLS 
 - return GET _ LAST _ ERROR ( ) = = THREAD _ DETACH ; 
 + / * * Returns the last error code . * / 
 + int lastError ( ) { 
 + return GET _ LAST _ ERROR ( ) ; 
 + } 
 + / * * Set the last error code . * / 
 + void setLastError ( int err ) { 
 + SET _ LAST _ ERROR ( err ) ; 
 } 
 
 # ifdef _ _ cplusplus 
 diff - - git a / native / dispatch . h b / native / dispatch . h 
 index 2ebe2d6 . . f72c7ec 100644 
 - - - a / native / dispatch . h 
 + + + b / native / dispatch . h 
 @ @ - 84 , 8 + 84 , 6 @ @ enum { 
 
 / * callback behavior flags * / 
 enum { 
 - CB _ DAEMON = com _ sun _ jna _ Native _ CB _ DAEMON , 
 - CB _ NODETACH = com _ sun _ jna _ Native _ CB _ NODETACH , 
 CB _ HAS _ INITIALIZER = com _ sun _ jna _ Native _ CB _ HAS _ INITIALIZER , 
 THREAD _ ATTACH = com _ sun _ jna _ Native _ THREAD _ ATTACH , 
 THREAD _ DETACH = com _ sun _ jna _ Native _ THREAD _ DETACH , 
 @ @ - 187 , 8 + 185 , 15 @ @ extern void writeStructure ( JNIEnv * , jobject ) ; 
 extern jclass getNativeType ( JNIEnv * , jclass ) ; 
 extern void toNative ( JNIEnv * , jobject , void * , size _ t , jboolean ) ; 
 extern jclass fromNative ( JNIEnv * , jclass , ffi _ type * , void * , jboolean ) ; 
 - extern jobject initializeThread ( callback * , JavaVMAttachArgs * ) ; 
 - extern int detachThread ( ) ; 
 + 
 + typedef struct _ AttachOptions { 
 + int daemon ; 
 + int detach ; 
 + const char * name ; 
 + } AttachOptions ; 
 + extern jobject initializeThread ( callback * , AttachOptions * ) ; 
 + extern int lastError ( ) ; 
 + extern void setLastError ( int err ) ; 
 
 / * Native memory fault protection * / 
 # ifdef HAVE _ PROTECTION 
 diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java 
 index 4e444b6 . . 161d4eb 100644 
 - - - a / src / com / sun / jna / CallbackReference . java 
 + + + b / src / com / sun / jna / CallbackReference . java 
 @ @ - 83 , 31 + 83 , 13 @ @ class CallbackReference extends WeakReference { 
 } 
 } 
 
 - static class JavaVMAttachArgs extends Structure { 
 - public int version ; 
 + static class AttachOptions extends Structure { 
 + public boolean daemon ; 
 + public boolean detach ; 
 public String name ; 
 - public ThreadGroup group ; 
 - protected int getNativeSize ( Class type , Object value ) { 
 - if ( ThreadGroup . class . equals ( type ) ) { 
 - return Pointer . SIZE ; 
 - } 
 - return super . getNativeSize ( type , value ) ; 
 - } 
 - protected int getNativeAlignment ( Class type , Object value , boolean isFirstElement ) { 
 - if ( ThreadGroup . class . equals ( type ) ) { 
 - type = Pointer . class ; 
 - } 
 - return super . getNativeAlignment ( type , value , isFirstElement ) ; 
 - } 
 - protected Pointer getFieldTypeInfo ( StructField f ) { 
 - if ( ThreadGroup . class . equals ( f . type ) ) { 
 - return getTypeInfo ( Pointer . class ) ; 
 - } 
 - return super . getFieldTypeInfo ( f ) ; 
 - } 
 } 
 / * * Called from native code to initialize a callback thread . * / 
 - private static ThreadGroup initializeThread ( Callback cb , JavaVMAttachArgs args ) { 
 + private static ThreadGroup initializeThread ( Callback cb , AttachOptions args ) { 
 CallbackThreadInitializer init = null ; 
 if ( cb instanceof DefaultCallbackProxy ) { 
 cb = ( ( DefaultCallbackProxy ) cb ) . getCallback ( ) ; 
 @ @ - 115 , 32 + 97 , 15 @ @ class CallbackReference extends WeakReference { 
 synchronized ( initializers ) { 
 init = ( CallbackThreadInitializer ) initializers . get ( cb ) ; 
 } 
 + ThreadGroup group = null ; 
 if ( init ! = null ) { 
 - String name = init . getName ( cb ) ; 
 - if ( name ! = null ) { 
 - args . name = name ; 
 - } 
 - ThreadGroup group = init . getThreadGroup ( cb ) ; 
 - if ( group ! = null ) { 
 - args . group = group ; 
 - } 
 - int options = getCallbackOptions ( cb ) ; 
 - if ( init . isDaemon ( cb ) ) { 
 - options | = Native . CB _ DAEMON ; 
 - } 
 - else { 
 - options & = ~ Native . CB _ DAEMON ; 
 - } 
 - if ( init . detach ( cb ) ) { 
 - options & = ~ Native . CB _ NODETACH ; 
 - } 
 - else { 
 - options | = Native . CB _ NODETACH ; 
 - } 
 - setCallbackOptions ( cb , options ) ; 
 + group = init . getThreadGroup ( cb ) ; 
 + args . name = init . getName ( cb ) ; 
 + args . daemon = init . isDaemon ( cb ) ; 
 + args . detach = init . detach ( cb ) ; 
 args . write ( ) ; 
 } 
 - return args . group ; 
 + return group ; 
 } 
 
 / * * Return a Callback associated with the given function pointer . 
 diff - - git a / src / com / sun / jna / CallbackThreadInitializer . java b / src / com / sun / jna / CallbackThreadInitializer . java 
 index 6f5a1ff . . a61c0cd 100644 
 - - - a / src / com / sun / jna / CallbackThreadInitializer . java 
 + + + b / src / com / sun / jna / CallbackThreadInitializer . java 
 @ @ - 11 , 23 + 11 , 51 @ @ package com . sun . jna ; 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 * Lesser General Public License for more details . 
 * / 
 + / * * This class provides for customization of the mapping of native threads 
 + * onto attached Java threads . Use 
 + * { @ link Native # setCallbackThreadInitializer } to customize the thread context 
 + * in which a given callback is invoked . < p / > 
 + * When a JNA callback is invoked on a native thread that is not currently 
 + * tracked by the VM and a < code > CallbackThreadInitiailizer < / code > is 
 + * registered for that callback , the initializer object will be used to 
 + * determine how the thread should be attached to the VM . < p / > . 
 + * Once attached , the method { @ link Native # detach } may be used from within 
 + * the callback invocation to alter whether the thread will be detached or not 
 + * when the callback finishes execution . Typically this functionality is used 
 + * in situations where you expect a callback to be called repeatedly from the 
 + * same thread and you want to avoid potential extra thread allocation 
 + * overhead on each callback invocation , since the VM may or may not re - use 
 + * the same allocated thread object each time the thread is attached . < p / > 
 + * A single initializer may be used for multiple callbacks , one initializer 
 + * per callback , or you may subclass the initializer to provide different 
 + * initializer settings depending on the callback . < p / > 
 + * / 
 public class CallbackThreadInitializer { 
 private boolean daemon ; 
 private boolean detach ; 
 private String name ; 
 private ThreadGroup group ; 
 + / * * The default initializer causes the callback thread to remain attached 
 + as a daemon thread , using the default thread name and group . 
 + * / 
 public CallbackThreadInitializer ( ) { 
 - this ( false ) ; 
 + this ( true ) ; 
 } 
 + / * * Keep the callback thread attached , with the given daemon state , 
 + using the default thread name and group . 
 + * / 
 public CallbackThreadInitializer ( boolean daemon ) { 
 this ( daemon , true ) ; 
 } 
 + / * * Uses the default thread name and group . * / 
 public CallbackThreadInitializer ( boolean daemon , boolean detach ) { 
 this ( daemon , detach , null ) ; 
 } 
 + / * * Uses the default thread group . * / 
 public CallbackThreadInitializer ( boolean daemon , boolean detach , String name ) { 
 this ( daemon , detach , name , null ) ; 
 } 
 + / * * Specify all aspects of how the callback thread should be initialized . * / 
 public CallbackThreadInitializer ( boolean daemon , boolean detach , String name , ThreadGroup group ) { 
 this . daemon = daemon ; 
 this . detach = detach ; 
 diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java 
 index 7b66a0f . . c7bb5ba 100644 
 - - - a / src / com / sun / jna / Native . java 
 + + + b / src / com / sun / jna / Native . java 
 @ @ - 114 , 6 + 114 , 7 @ @ public final class Native { 
 private static final int TYPE _ WCHAR _ T = 2 ; 
 private static final int TYPE _ SIZE _ T = 3 ; 
 
 + private static final int THREAD _ NOCHANGE = 0 ; 
 private static final int THREAD _ DETACH = - 1 ; 
 private static final int THREAD _ ATTACH = - 2 ; 
 
 @ @ - 1053 , 16 + 1054 , 6 @ @ public final class Native { 
 return context [ 3 ] ; 
 } 
 
 - / * * Set callback options . * / 
 - public static void setCallbackOptions ( Callback cb , int options ) { 
 - CallbackReference . setCallbackOptions ( cb , options ) ; 
 - } 
 - 
 - / * * Get callback options . * / 
 - public static int getCallbackOptions ( Callback cb ) { 
 - return CallbackReference . getCallbackOptions ( cb ) ; 
 - } 
 - 
 / * * Set a thread initializer for the given callback . 
 The thread initializer indicates desired thread configuration when the 
 given Callback is invoked on a native thread not yet attached to the 
 @ @ - 1148 , 18 + 1139 , 8 @ @ public final class Native { 
 return buf . toString ( ) ; 
 } 
 
 - / * * This callback behavior flag indicates that the native thread on which 
 - the callback is invoked should be treated as a daemon thread . This is 
 - only meaningful when used with the { @ link # CB _ NODETACH } . 
 - * / 
 - public static final int CB _ DAEMON = 1 ; 
 - / * * This callback behavior flag indicates that the thread on which the 
 - * callback is invoked should not be detached from the VM . Use this when 
 - * you know your callback will be called repeatedly from the same thread . 
 - * / 
 - public static final int CB _ NODETACH = 2 ; 
 / * * Indicates whether the callback has an initializer . * / 
 - static final int CB _ HAS _ INITIALIZER = 4 ; 
 + static final int CB _ HAS _ INITIALIZER = 1 ; 
 
 private static final int CVT _ UNSUPPORTED = - 1 ; 
 private static final int CVT _ DEFAULT = 0 ; 
 @ @ - 1685 , 10 + 1666 , 6 @ @ public final class Native { 
 
 static native void setString ( long addr , String value , boolean wide ) ; 
 
 - / * * NOTE : no JNI references are created . * / 
 - static native void setObject ( long addr , Object object ) ; 
 - static native Object getObject ( long addr ) ; 
 - 
 / * * 
 * Call the real native malloc 
 * @ param size size of the memory to be allocated 
 diff - - git a / src / com / sun / jna / Pointer . java b / src / com / sun / jna / Pointer . java 
 index f422b03 . . 6c30f96 100644 
 - - - a / src / com / sun / jna / Pointer . java 
 + + + b / src / com / sun / jna / Pointer . java 
 @ @ - 464 , 11 + 464 , 8 @ @ public class Pointer { 
 getArrayValue ( offset , result , type . getComponentType ( ) ) ; 
 } 
 else { 
 - result = getObject ( offset ) ; 
 - / * 
 throw new IllegalArgumentException ( " Reading \ " " 
 + type + " \ " from memory is not supported " ) ; 
 - * / 
 } 
 return result ; 
 } 
 @ @ - 648 , 13 + 645 , 6 @ @ public class Pointer { 
 } 
 
 / * * 
 - * Read a native jobject pointer as a Java Object . 
 - * / 
 - Object getObject ( long offset ) { 
 - return Native . getObject ( peer + offset ) ; 
 - } 
 - 
 - / * * 
 * Get a ByteBuffer mapped to the memory pointed to by the pointer , 
 * ensuring the buffer uses native byte order . 
 * 
 @ @ - 896 , 8 + 886 , 7 @ @ v * @ param wide whether to convert from a wide or standard C string 
 setArrayValue ( offset , value , type . getComponentType ( ) ) ; 
 } 
 else { 
 - setObject ( offset , value ) ; 
 - / / throw new IllegalArgumentException ( " Writing " + type + " to memory is not supported " ) ; 
 + throw new IllegalArgumentException ( " Writing " + type + " to memory is not supported " ) ; 
 } 
 } 
 
 @ @ - 1107 , 11 + 1096 , 6 @ @ v * @ param wide whether to convert from a wide or standard C string 
 Native . setPointer ( peer + offset , value ! = null ? value . peer : 0 ) ; 
 } 
 
 - / * * Write a Java Object as a native jobject pointer . * / 
 - void setObject ( long offset , Object value ) { 
 - Native . setObject ( peer + offset , value ) ; 
 - } 
 - 
 / * * 
 * Copy string < code > value < / code > to the location being pointed to . Copy 
 * each element in < code > value < / code > , converted to native encoding , at an 
 diff - - git a / src / com / sun / jna / overview . html b / src / com / sun / jna / overview . html 
 index 686021e . . 7afc9fb 100644 
 - - - a / src / com / sun / jna / overview . html 
 + + + b / src / com / sun / jna / overview . html 
 @ @ - 330 , 8 + 330 , 7 @ @ improves performance if you know you will be getting multiple callbacks on the 
 same thread , avoiding the need for the VM to generate multiple Java Thread 
 objects for the same native thread . If you do leave the native thread 
 attached , you should either ensure you detach it at some later point ( by 
 - calling { @ link com . sun . jna . Native # setCallbackOptions ( Callback ) } without 
 - { @ link com . sun . jna . Native # CB _ NODETACH } 
 + calling { @ link com . sun . jna . Native # detach } from within the callback ) 
 or return true from your 
 { @ link com . sun . jna . CallbackThreadInitializer # isDaemon ( Callback ) } method so 
 that the native thread will not prevent the VM from exiting . < p / > 
 diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java 
 index 3bfb210 . . 396d48b 100644 
 - - - a / test / com / sun / jna / CallbacksTest . java 
 + + + b / test / com / sun / jna / CallbacksTest . java 
 @ @ - 929 , 7 + 929 , 6 @ @ public class CallbacksTest extends TestCase { 
 final Thread [ ] t = { null } ; 
 
 ThreadGroup testGroup = new ThreadGroup ( getName ( ) ) ; 
 - CallbackThreadInitializer init = new CallbackThreadInitializer ( ) ; 
 TestLibrary . VoidCallback cb = new TestLibrary . VoidCallback ( ) { 
 public void callback ( ) { 
 Thread thread = Thread . currentThread ( ) ; 
 @ @ - 940 , 9 + 939 , 10 @ @ public class CallbacksTest extends TestCase { 
 + + called [ 0 ] ; 
 } 
 } ; 
 - callCallback ( cb , init , 1 , 100 , called ) ; 
 + callCallback ( cb , null , 1 , 100 , called ) ; 
 
 assertFalse ( " Callback thread default should not be attached as daemon " , daemon [ 0 ] ) ; 
 + / / thread name and group are not defined 
 } 
 
 public void testCustomizeCallbackThread ( ) throws Exception {
