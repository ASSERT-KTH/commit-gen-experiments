BLEU SCORE: 0.016932492841722675

TEST MSG: Fix windows builds under MSVC , 32 - and 64 - bit
GENERATED MSG: Moved arm files

TEST DIFF (one line): diff - - git a / native / Makefile b / native / Makefile <nl> index c7600c6 . . d9aac90 100644 <nl> - - - a / native / Makefile <nl> + + + b / native / Makefile <nl> @ @ - 190 , 11 + 190 , 11 @ @ CC + = - m64 <nl> FFI _ CONFIG + = - - host = x86 _ 64 - w64 - mingw32 <nl> endif <nl> FFI _ CONFIG + = & & rm - f include / ffitarget . h & & cp $ ( FFI _ SRC ) / include / * . h $ ( FFI _ SRC ) / src / x86 / ffitarget . h include <nl> - FFI _ ENV + = LD = " $ ( LD ) " CPP = " $ ( CPP ) " <nl> + FFI _ ENV + = LD = " $ ( LD ) " CPP = " $ ( CPP ) " CXXCPP = " $ ( CPP ) " <nl> EXTRAOBJS + = $ ( DLLCB ) <nl> else <nl> - PREFIX = i686 - pc - mingw32 - <nl> - CC = $ ( PREFIX ) gcc <nl> + MINGW _ PREFIX ? = i686 - pc - mingw32 - <nl> + CC = $ ( MINGW _ PREFIX ) gcc <nl> LDFLAGS = - o $ @ - shared - Wl , - - add - stdcall - alias <nl> LIBS = - lpsapi <nl> endif <nl> @ @ - 203 , 7 + 203 , 7 @ @ ifeq ( $ ( ARCH ) , amd64 ) <nl> # Undefine USE _ MSVC to enable mingw64 cross compiler ; ensure $ ( MINGW ) is in <nl> # PATH . Should build properly as of 111121 , but lacks SEH , so MSVC build is <nl> # preferred <nl> - MINGW _ PREFIX ? = x86 _ 64 - pc - mingw32 - <nl> + MINGW _ PREFIX ? = x86 _ 64 - w64 - mingw32 - <nl> MINGW = $ ( MINGW _ PREFIX ) gcc <nl> # Need windres from mingw distribution , even if building with MSVC <nl> WINDRES = $ ( MINGW _ PREFIX ) windres <nl> @ @ - 372 , 8 + 372 , 10 @ @ install : <nl> 	 mkdir $ ( INSTALLDIR ) <nl> 	 cp $ ( LIBRARY ) $ ( INSTALLDIR ) <nl> <nl> + ifeq ( $ ( ARCH ) , amd64 ) <nl> $ ( DLLCB ) : dll - callback . c <nl> 	 $ ( MINGW ) - DDEFINE _ CALLBACKS - c $ < $ ( COUT ) <nl> + endif <nl> <nl> $ ( RSRC ) : $ ( BUILD ) / jnidispatch . rc $ ( BUILD ) / $ ( JNA _ JNI _ VERSION ) . stamp <nl> 	 $ ( WINDRES ) - i $ < - o $ @ \ <nl> diff - - git a / native / libffi / src / x86 / ffi . c b / native / libffi / src / x86 / ffi . c <nl> index d16ec5b . . c7b5dbc 100644 <nl> - - - a / native / libffi / src / x86 / ffi . c <nl> + + + b / native / libffi / src / x86 / ffi . c <nl> @ @ - 99 , 12 + 99 , 12 @ @ unsigned int ffi _ prep _ args ( char * stack , extended _ cif * ecif ) <nl> i ! = 0 ; <nl> i - - , p _ arg + = dir , p _ argv + = dir ) <nl> { <nl> + size _ t z = ( * p _ arg ) - > size ; <nl> + <nl> / * Align if necessary * / <nl> if ( ( sizeof ( void * ) - 1 ) & ( size _ t ) argp ) <nl> argp = ( char * ) ALIGN ( argp , sizeof ( void * ) ) ; <nl> <nl> - size _ t z = ( * p _ arg ) - > size ; <nl> - <nl> # ifdef X86 _ WIN64 <nl> if ( z > FFI _ SIZEOF _ ARG <nl> | | ( ( * p _ arg ) - > type = = FFI _ TYPE _ STRUCT <nl> @ @ - 202 , 6 + 202 , 7 @ @ unsigned int ffi _ prep _ args ( char * stack , extended _ cif * ecif ) <nl> on top of stack , so that those can be moved to registers by call - handler . * / <nl> if ( stack _ args _ count > 0 ) <nl> { <nl> + unsigned i ; <nl> if ( dir < 0 & & stack _ args _ count > 1 ) <nl> { <nl> / * Reverse order if iterating arguments backwards * / <nl> @ @ - 210 , 7 + 211 , 6 @ @ unsigned int ffi _ prep _ args ( char * stack , extended _ cif * ecif ) <nl> * ( ffi _ arg * ) p _ stack _ data [ stack _ args _ count - 1 ] = tmp ; <nl> } <nl> <nl> - int i ; <nl> for ( i = 0 ; i < stack _ args _ count ; i + + ) <nl> { <nl> if ( p _ stack _ data [ i ] ! = argp2 ) <nl> @ @ - 572 , 11 + 572 , 12 @ @ ffi _ prep _ incoming _ args ( char * stack , void * * rvalue , void * * avalue , <nl> i < cif - > nargs & & passed _ regs < max _ stack _ count ; <nl> i + + , p _ arg + + ) <nl> { <nl> + size _ t sz = ( * p _ arg ) - > size ; <nl> + <nl> if ( ( * p _ arg ) - > type = = FFI _ TYPE _ FLOAT <nl> | | ( * p _ arg ) - > type = = FFI _ TYPE _ STRUCT ) <nl> continue ; <nl> <nl> - size _ t sz = ( * p _ arg ) - > size ; <nl> if ( sz = = 0 | | sz > FFI _ SIZEOF _ ARG ) <nl> continue ; <nl> <nl> @ @ - 602 , 12 + 603 , 12 @ @ ffi _ prep _ incoming _ args ( char * stack , void * * rvalue , void * * avalue , <nl> i ! = 0 ; <nl> i - - , p _ arg + = dir , p _ argv + = dir ) <nl> { <nl> + size _ t z = ( * p _ arg ) - > size ; <nl> + <nl> / * Align if necessary * / <nl> if ( ( sizeof ( void * ) - 1 ) & ( size _ t ) argp ) <nl> argp = ( char * ) ALIGN ( argp , sizeof ( void * ) ) ; <nl> <nl> - size _ t z = ( * p _ arg ) - > size ; <nl> - <nl> # ifdef X86 _ WIN64 <nl> if ( z > FFI _ SIZEOF _ ARG <nl> | | ( ( * p _ arg ) - > type = = FFI _ TYPE _ STRUCT <nl> @ @ - 858 , 11 + 859 , 12 @ @ ffi _ prep _ args _ raw ( char * stack , extended _ cif * ecif ) <nl> <nl> for ( i = 0 ; i < cif - > nargs & & passed _ regs < = max _ regs ; i + + ) <nl> { <nl> + size _ t sz = cif - > arg _ types [ i ] - > size ; <nl> + <nl> if ( cif - > arg _ types [ i ] - > type = = FFI _ TYPE _ FLOAT <nl> | | cif - > arg _ types [ i ] - > type = = FFI _ TYPE _ STRUCT ) <nl> continue ; <nl> <nl> - size _ t sz = cif - > arg _ types [ i ] - > size ; <nl> if ( sz = = 0 | | sz > FFI _ SIZEOF _ ARG ) <nl> continue ; <nl> <nl> diff - - git a / native / libffi / src / x86 / ffitarget . h b / native / libffi / src / x86 / ffitarget . h <nl> index a236677 . . ff0f718 100644 <nl> - - - a / native / libffi / src / x86 / ffitarget . h <nl> + + + b / native / libffi / src / x86 / ffitarget . h <nl> @ @ - 50 , 7 + 50 , 9 @ @ <nl> # endif <nl> <nl> # define FFI _ TARGET _ SPECIFIC _ STACK _ SPACE _ ALLOCATION <nl> + # ifndef _ MSC _ VER <nl> # define FFI _ TARGET _ HAS _ COMPLEX _ TYPE <nl> + # endif <nl> <nl> / * - - - - Generic type definitions - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / <nl> <nl> diff - - git a / native / libffi / src / x86 / win64 . S b / native / libffi / src / x86 / win64 . S <nl> index 687f97c . . 3f4981c 100644 <nl> - - - a / native / libffi / src / x86 / win64 . S <nl> + + + b / native / libffi / src / x86 / win64 . S <nl> @ @ - 170 , 7 + 170 , 7 @ @ ret _ uint16 $ : <nl> 	 mov 	 rcx , QWORD PTR RVALUE [ rbp ] <nl> 	 movzx rax , ax <nl> 	 mov 	 QWORD PTR [ rcx ] , rax <nl> - 	 jmp 	 SHORT ret _ void $ <nl> + 	 jmp 	 ret _ void $ ; too far with ' SHORT ' <nl> <nl> ret _ sint16 $ : <nl> 	 cmp 	 DWORD PTR CIF _ FLAGS [ rbp ] , FFI _ TYPE _ SINT16 <nl> @ @ - 179 , 7 + 179 , 7 @ @ ret _ sint16 $ : <nl> 	 mov 	 rcx , QWORD PTR RVALUE [ rbp ] <nl> 	 movsx rax , ax <nl> 	 mov 	 QWORD PTR [ rcx ] , rax <nl> - 	 jmp 	 SHORT ret _ void $ <nl> + 	 jmp 	 ret _ void $ ; too far with ' SHORT ' <nl> <nl> ret _ uint32 $ : <nl> 	 cmp 	 DWORD PTR CIF _ FLAGS [ rbp ] , FFI _ TYPE _ UINT32 <nl> diff - - git a / test / com / sun / jna / win32 / W32StdCallTest . java b / test / com / sun / jna / win32 / W32StdCallTest . java <nl> index 087f3d2 . . 9389de6 100644 <nl> - - - a / test / com / sun / jna / win32 / W32StdCallTest . java <nl> + + + b / test / com / sun / jna / win32 / W32StdCallTest . java <nl> @ @ - 122 , 7 + 122 , 7 @ @ public class W32StdCallTest extends TestCase { <nl> <nl> public void testStdCallReturnStructureByValueArgument ( ) { <nl> TestLibrary . TestStructure . ByValue s = new TestLibrary . TestStructure . ByValue ( ) ; <nl> - assertEquals ( " Wrong value " , s , testlib . returnStructureByValueArgumentStdCall ( s ) ) ; <nl> + assertTrue ( " Wrong struct value " , s . dataEquals ( testlib . returnStructureByValueArgumentStdCall ( s ) ) ) ; <nl> } <nl> <nl> public void testStdCallCallback ( ) { <nl> diff - - git a / www / WindowsDevelopmentEnvironment . md b / www / WindowsDevelopmentEnvironment . md <nl> index 6076cb1 . . 2d237ac 100644 <nl> - - - a / www / WindowsDevelopmentEnvironment . md <nl> + + + b / www / WindowsDevelopmentEnvironment . md <nl> @ @ - 29 , 15 + 29 , 22 @ @ When installing cygwin , include ssh , git , make , autotools , and <nl> mingw64 - gcc - core . Ensure the mingw64 compiler ( i686 - pc - mingw64 - gcc . exe ) is on <nl> your path . <nl> <nl> + MSVC <nl> + - - - - <nl> + <nl> # # # # Visual Studio <nl> <nl> - You can optionally use the free MS Visual Studio C + + Express compiler to compile <nl> - native bits . The MS compiler provides structured event handling ( SEH ) , <nl> - which allows JNA to trap native faults when run in protected mode . <nl> + JNA uses the free MS Visual Studio C + + Express compiler to compile <nl> + native bits if MSVC is set in the environment . The MS compiler provides <nl> + structured event handling ( SEH ) , which allows JNA to trap native faults when <nl> + run in protected mode . <nl> + <nl> + On 64 - bit windows , you will still need to install mingw64 - gcc - core in order to <nl> + compile a small bit of inline assembly . <nl> <nl> - To use the MS compiler , ensure that the 64 - bit versions of <nl> - cl . exe / ml64 . exe / link . exe are in your PATH and that the INCLUDE and LIB <nl> - environment variables are set properly ( as in VCVARS . BAT ) . <nl> + To use the MS compiler , ensure that the appropriate 32 - bit or 64 - bit versions <nl> + of cl . exe / ml . exe / ml64 . exe / link . exe are in your PATH and that the INCLUDE and <nl> + LIB environment variables are set properly ( as in VCVARS . BAT ) . <nl> <nl> Sample configuration setting up INCLUDE / LIB : <nl>
NEAREST DIFF (one line): diff - - git a / libffi / ia64 / ffi . c b / libffi / ia64 / ffi . c <nl> new file mode 100644 <nl> index 0000000 . . bb4fbb7 <nl> - - - / dev / null <nl> + + + b / libffi / ia64 / ffi . c <nl> @ @ - 0 , 0 + 1 , 670 @ @ <nl> + / * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> + ffi . c - Copyright ( c ) 1998 Cygnus Solutions <nl> + 	 Copyright ( c ) 2000 Hewlett Packard Company <nl> + <nl> + IA64 Foreign Function Interface <nl> + <nl> + Permission is hereby granted , free of charge , to any person obtaining <nl> + a copy of this software and associated documentation files ( the <nl> + ` ` Software ' ' ) , to deal in the Software without restriction , including <nl> + without limitation the rights to use , copy , modify , merge , publish , <nl> + distribute , sublicense , and / or sell copies of the Software , and to <nl> + permit persons to whom the Software is furnished to do so , subject to <nl> + the following conditions : <nl> + <nl> + The above copyright notice and this permission notice shall be included <nl> + in all copies or substantial portions of the Software . <nl> + <nl> + THE SOFTWARE IS PROVIDED ` ` AS IS ' ' , WITHOUT WARRANTY OF ANY KIND , EXPRESS <nl> + OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF <nl> + MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . <nl> + IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM , DAMAGES OR <nl> + OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , <nl> + ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR <nl> + OTHER DEALINGS IN THE SOFTWARE . <nl> + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / <nl> + <nl> + # include < ffi . h > <nl> + # include < ffi _ common . h > <nl> + <nl> + # include < stdlib . h > <nl> + <nl> + # include " ia64 _ flags . h " <nl> + <nl> + / * Memory image of fp register contents . Should eventually be an fp 	 * / <nl> + / * type long enough to hold an entire register . For now we use double . 	 * / <nl> + typedef double float80 ; <nl> + <nl> + / * The stack layout at call to ffi _ prep _ regs . Other _ args will remain 	 * / <nl> + / * on the stack for the actual call . Everything else we be transferred 	 * / <nl> + / * to registers and popped by the assembly code . 	 	 	 * / <nl> + <nl> + struct ia64 _ args { <nl> + long scratch [ 2 ] ; 	 / * Two scratch words at top of stack . 	 	 * / <nl> + 	 	 	 / * Allows sp to passed as arg pointer . 	 	 * / <nl> + void * r8 _ contents ; 	 / * Value to be passed in r8 	 	 	 * / <nl> + long spare ; 	 	 / * Not used . 	 	 	 	 	 * / <nl> + float80 fp _ regs [ 8 ] ; / * Contents of 8 floating point argument 	 * / <nl> + 	 	 	 / * registers . 	 	 	 	 	 * / <nl> + long out _ regs [ 8 ] ; 	 / * Contents of the 8 out registers used 	 * / <nl> + 	 	 	 / * for integer parameters . 	 	 	 * / <nl> + long other _ args [ 0 ] ; / * Arguments passed on stack , variable size 	 * / <nl> + 	 	 	 / * Treated as continuation of out _ regs . 	 	 * / <nl> + } ; <nl> + <nl> + static size _ t float _ type _ size ( unsigned short tp ) <nl> + { <nl> + switch ( tp ) { <nl> + case FFI _ TYPE _ FLOAT : <nl> + return sizeof ( float ) ; <nl> + case FFI _ TYPE _ DOUBLE : <nl> + return sizeof ( double ) ; <nl> + # if FFI _ TYPE _ LONGDOUBLE ! = FFI _ TYPE _ DOUBLE <nl> + case FFI _ TYPE _ LONGDOUBLE : <nl> + return sizeof ( long double ) ; <nl> + # endif <nl> + default : <nl> + FFI _ ASSERT ( 0 ) ; <nl> + } <nl> + } <nl> + <nl> + / * <nl> + * Is type a struct containing at most n floats , doubles , or extended <nl> + * doubles , all of the same fp type ? <nl> + * If so , set * element _ type to the fp type . <nl> + * / <nl> + static bool is _ homogeneous _ fp _ aggregate ( ffi _ type * type , int n , <nl> + 	 	 	 	 unsigned short * element _ type ) <nl> + { <nl> + ffi _ type * * ptr ; <nl> + unsigned short element , struct _ element ; <nl> + <nl> + int type _ set = 0 ; <nl> + <nl> + FFI _ ASSERT ( type ! = NULL ) ; <nl> + <nl> + FFI _ ASSERT ( type - > elements ! = NULL ) ; <nl> + <nl> + ptr = & ( type - > elements [ 0 ] ) ; <nl> + <nl> + while ( ( * ptr ) ! = NULL ) <nl> + { <nl> + switch ( ( * ptr ) - > type ) { <nl> + 	 case FFI _ TYPE _ FLOAT : <nl> + 	 if ( type _ set & & element ! = FFI _ TYPE _ FLOAT ) return 0 ; <nl> + 	 if ( - - n < 0 ) return FALSE ; <nl> + 	 type _ set = 1 ; <nl> + 	 element = FFI _ TYPE _ FLOAT ; <nl> + 	 break ; <nl> + 	 case FFI _ TYPE _ DOUBLE : <nl> + 	 if ( type _ set & & element ! = FFI _ TYPE _ DOUBLE ) return 0 ; <nl> + 	 if ( - - n < 0 ) return FALSE ; <nl> + 	 type _ set = 1 ; <nl> + 	 element = FFI _ TYPE _ DOUBLE ; <nl> + 	 break ; <nl> + 	 case FFI _ TYPE _ STRUCT : <nl> + 	 if ( ! is _ homogeneous _ fp _ aggregate ( type , n , & struct _ element ) ) <nl> + 	 return FALSE ; <nl> + 	 if ( type _ set & & struct _ element ! = element ) return FALSE ; <nl> + 	 n - = ( type - > size ) / float _ type _ size ( element ) ; <nl> + 	 element = struct _ element ; <nl> + 	 if ( n < 0 ) return FALSE ; <nl> + 	 break ; <nl> + 	 / * case FFI _ TYPE _ LONGDOUBLE : <nl> + 	 Not yet implemented . 	 * / <nl> + 	 default : <nl> + 	 return FALSE ; <nl> + } <nl> + ptr + + ; <nl> + } <nl> + * element _ type = element ; <nl> + return TRUE ; <nl> + <nl> + } <nl> + <nl> + / * ffi _ prep _ args is called by the assembly routine once stack space <nl> + has been allocated for the function ' s arguments . Returns nonzero <nl> + if fp registers are used for arguments . * / <nl> + <nl> + static bool <nl> + ffi _ prep _ args ( struct ia64 _ args * stack , extended _ cif * ecif , int bytes ) <nl> + { <nl> + register long i , avn ; <nl> + register void * * p _ argv ; <nl> + register long * argp = stack - > out _ regs ; <nl> + register float80 * fp _ argp = stack - > fp _ regs ; <nl> + register ffi _ type * * p _ arg ; <nl> + <nl> + / * For big return structs , r8 needs to contain the target address . 	 * / <nl> + / * Since r8 is otherwise dead , we set it unconditionally . 	 	 * / <nl> + stack - > r8 _ contents = ecif - > rvalue ; <nl> + i = 0 ; <nl> + avn = ecif - > cif - > nargs ; <nl> + p _ arg = ecif - > cif - > arg _ types ; <nl> + p _ argv = ecif - > avalue ; <nl> + while ( i < avn ) <nl> + { <nl> + size _ t z ; / * z is in units of arg slots or words , not bytes . 	 * / <nl> + <nl> + switch ( ( * p _ arg ) - > type ) <nl> + 	 { <nl> + 	 case FFI _ TYPE _ SINT8 : <nl> + 	 z = 1 ; <nl> + 	 * ( SINT64 * ) argp = * ( SINT8 * ) ( * p _ argv ) ; <nl> + 	 break ; <nl> + 	 	 <nl> + 	 case FFI _ TYPE _ UINT8 : <nl> + 	 z = 1 ; <nl> + 	 * ( UINT64 * ) argp = * ( UINT8 * ) ( * p _ argv ) ; <nl> + 	 break ; <nl> + 	 	 <nl> + 	 case FFI _ TYPE _ SINT16 : <nl> + 	 z = 1 ; <nl> + 	 * ( SINT64 * ) argp = * ( SINT16 * ) ( * p _ argv ) ; <nl> + 	 break ; <nl> + 	 	 <nl> + 	 case FFI _ TYPE _ UINT16 : <nl> + 	 z = 1 ; <nl> + 	 * ( UINT64 * ) argp = * ( UINT16 * ) ( * p _ argv ) ; <nl> + 	 break ; <nl> + 	 	 <nl> + 	 case FFI _ TYPE _ SINT32 : <nl> + 	 z = 1 ; <nl> + 	 * ( SINT64 * ) argp = * ( SINT32 * ) ( * p _ argv ) ; <nl> + 	 break ; <nl> + 	 	 <nl> + 	 case FFI _ TYPE _ UINT32 : <nl> + 	 z = 1 ; <nl> + 	 * ( UINT64 * ) argp = * ( UINT32 * ) ( * p _ argv ) ; <nl> + 	 break ; <nl> + <nl> + 	 case FFI _ TYPE _ SINT64 : <nl> + 	 case FFI _ TYPE _ UINT64 : <nl> + 	 case FFI _ TYPE _ POINTER : <nl> + 	 z = 1 ; <nl> + 	 * ( UINT64 * ) argp = * ( UINT64 * ) ( * p _ argv ) ; <nl> + 	 break ; <nl> + <nl> + 	 case FFI _ TYPE _ FLOAT : <nl> + 	 z = 1 ; <nl> + 	 if ( fp _ argp - stack - > fp _ regs < 8 ) <nl> + 	 { <nl> + 	 / * Note the conversion - - all the fp regs are loaded as <nl> + 	 	 doubles . * / <nl> + 	 * fp _ argp + + = * ( float * ) ( * p _ argv ) ; <nl> + 	 } <nl> + 	 / * Also put it into the integer registers or memory : * / <nl> + 	 * ( UINT64 * ) argp = * ( UINT32 * ) ( * p _ argv ) ; <nl> + 	 break ; <nl> + <nl> + 	 case FFI _ TYPE _ DOUBLE : <nl> + 	 z = 1 ; <nl> + 	 if ( fp _ argp - stack - > fp _ regs < 8 ) <nl> + 	 * fp _ argp + + = * ( double * ) ( * p _ argv ) ; <nl> + 	 / * Also put it into the integer registers or memory : * / <nl> + 	 * ( double * ) argp = * ( double * ) ( * p _ argv ) ; <nl> + 	 break ; <nl> + <nl> + 	 case FFI _ TYPE _ STRUCT : <nl> + 	 { <nl> + 	 size _ t sz = ( * p _ arg ) - > size ; <nl> + 	 unsigned short element _ type ; <nl> + z = ( ( * p _ arg ) - > size + SIZEOF _ ARG - 1 ) / SIZEOF _ ARG ; <nl> + 	 if ( is _ homogeneous _ fp _ aggregate ( * p _ arg , 8 , & element _ type ) ) { <nl> + 	 	 int i ; <nl> + 	 	 int nelements = sz / float _ type _ size ( element _ type ) ; <nl> + 	 	 for ( i = 0 ; i < nelements ; + + i ) { <nl> + 	 	 switch ( element _ type ) { <nl> + 	 	 case FFI _ TYPE _ FLOAT : <nl> + 	 	 if ( fp _ argp - stack - > fp _ regs < 8 ) <nl> + 	 	 	 * fp _ argp + + = ( ( float * ) ( * p _ argv ) ) [ i ] ; <nl> + 	 	 break ; <nl> + 	 	 case FFI _ TYPE _ DOUBLE : <nl> + 	 	 if ( fp _ argp - stack - > fp _ regs < 8 ) <nl> + 	 	 	 * fp _ argp + + = ( ( double * ) ( * p _ argv ) ) [ i ] ; <nl> + 	 	 break ; <nl> + 	 	 default : <nl> + 	 	 	 / * Extended precision not yet implemented . * / <nl> + 	 	 	 abort ( ) ; <nl> + 	 	 } <nl> + 	 	 } <nl> + 	 } <nl> + 	 / * And pass it in integer registers as a struct , with 	 * / <nl> + 	 / * its actual field sizes packed into registers . 	 	 * / <nl> + 	 memcpy ( argp , * p _ argv , ( * p _ arg ) - > size ) ; <nl> + 	 } <nl> + 	 break ; <nl> + <nl> + 	 default : <nl> + 	 FFI _ ASSERT ( 0 ) ; <nl> + 	 } <nl> + <nl> + argp + = z ; <nl> + i + + , p _ arg + + , p _ argv + + ; <nl> + } <nl> + return ( fp _ argp ! = stack - > fp _ regs ) ; <nl> + } <nl> + <nl> + / * Perform machine dependent cif processing * / <nl> + ffi _ status <nl> + ffi _ prep _ cif _ machdep ( ffi _ cif * cif ) <nl> + { <nl> + long i , avn ; <nl> + bool is _ simple = TRUE ; <nl> + long simple _ flag = FFI _ SIMPLE _ V ; <nl> + / * Adjust cif - > bytes to include space for the 2 scratch words , <nl> + r8 register contents , spare word , <nl> + the 8 fp register contents , and all 8 integer register contents . <nl> + This will be removed before the call , though 2 scratch words must <nl> + remain . * / <nl> + <nl> + cif - > bytes + = 4 * sizeof ( long ) + 8 * sizeof ( float80 ) ; <nl> + if ( cif - > bytes < sizeof ( struct ia64 _ args ) ) <nl> + cif - > bytes = sizeof ( struct ia64 _ args ) ; <nl> + <nl> + / * The stack must be double word aligned , so round bytes up <nl> + appropriately . * / <nl> + <nl> + cif - > bytes = ALIGN ( cif - > bytes , 2 * sizeof ( void * ) ) ; <nl> + <nl> + avn = cif - > nargs ; <nl> + if ( avn < = 2 ) { <nl> + for ( i = 0 ; i < avn ; + + i ) { <nl> + switch ( cif - > arg _ types [ i ] - > type ) { <nl> + 	 case FFI _ TYPE _ SINT32 : <nl> + 	 simple _ flag = FFI _ ADD _ INT _ ARG ( simple _ flag ) ; <nl> + 	 break ; <nl> + 	 case FFI _ TYPE _ SINT64 : <nl> + 	 case FFI _ TYPE _ UINT64 : <nl> + 	 case FFI _ TYPE _ POINTER : <nl> + 	 simple _ flag = FFI _ ADD _ LONG _ ARG ( simple _ flag ) ; <nl> + 	 break ; <nl> + 	 default : <nl> + 	 is _ simple = FALSE ; <nl> + } <nl> + } <nl> + } else { <nl> + is _ simple = FALSE ; <nl> + } <nl> + <nl> + / * Set the return type flag * / <nl> + switch ( cif - > rtype - > type ) <nl> + { <nl> + case FFI _ TYPE _ VOID : <nl> + cif - > flags = FFI _ TYPE _ VOID ; <nl> + break ; <nl> + <nl> + case FFI _ TYPE _ STRUCT : <nl> + { <nl> + size _ t sz = cif - > rtype - > size ; <nl> + 	 unsigned short element _ type ; <nl> + <nl> + 	 is _ simple = FALSE ; <nl> + 	 if ( is _ homogeneous _ fp _ aggregate ( cif - > rtype , 8 , & element _ type ) ) { <nl> + 	 int nelements = sz / float _ type _ size ( element _ type ) ; <nl> + 	 if ( nelements < = 1 ) { <nl> + 	 if ( 0 = = nelements ) { <nl> + 	 cif - > flags = FFI _ TYPE _ VOID ; <nl> + 	 } else { <nl> + 	 cif - > flags = element _ type ; <nl> + 	 } <nl> + 	 } else { <nl> + 	 switch ( element _ type ) { <nl> + 	 case FFI _ TYPE _ FLOAT : <nl> + 	 cif - > flags = FFI _ IS _ FLOAT _ FP _ AGGREGATE | nelements ; <nl> + 	 	 break ; <nl> + 	 case FFI _ TYPE _ DOUBLE : <nl> + 	 cif - > flags = FFI _ IS _ DOUBLE _ FP _ AGGREGATE | nelements ; <nl> + 	 	 break ; <nl> + 	 default : <nl> + 	 	 / * long double NYI * / <nl> + 	 	 abort ( ) ; <nl> + 	 } <nl> + 	 } <nl> + 	 break ; <nl> + } <nl> + if ( sz < = 32 ) { <nl> + 	 if ( sz < = 8 ) { <nl> + cif - > flags = FFI _ TYPE _ INT ; <nl> + 	 } else if ( sz < = 16 ) { <nl> + cif - > flags = FFI _ IS _ SMALL _ STRUCT2 ; <nl> + 	 } else if ( sz < = 24 ) { <nl> + cif - > flags = FFI _ IS _ SMALL _ STRUCT3 ; <nl> + 	 } else { <nl> + cif - > flags = FFI _ IS _ SMALL _ STRUCT4 ; <nl> + 	 } <nl> + } else { <nl> + cif - > flags = FFI _ TYPE _ STRUCT ; <nl> + 	 } <nl> + } <nl> + break ; <nl> + <nl> + case FFI _ TYPE _ FLOAT : <nl> + is _ simple = FALSE ; <nl> + cif - > flags = FFI _ TYPE _ FLOAT ; <nl> + break ; <nl> + <nl> + case FFI _ TYPE _ DOUBLE : <nl> + is _ simple = FALSE ; <nl> + cif - > flags = FFI _ TYPE _ DOUBLE ; <nl> + break ; <nl> + <nl> + default : <nl> + cif - > flags = FFI _ TYPE _ INT ; <nl> + / * This seems to depend on little endian mode , and the fact that 	 * / <nl> + / * the return pointer always points to at least 8 bytes . But 	 * / <nl> + / * that also seems to be true for other platforms . 	 	 * / <nl> + break ; <nl> + } <nl> + <nl> + if ( is _ simple ) cif - > flags | = simple _ flag ; <nl> + return FFI _ OK ; <nl> + } <nl> + <nl> + extern int ffi _ call _ unix ( bool ( * ) ( struct ia64 _ args * , extended _ cif * , int ) , <nl> + 	 	 	 extended _ cif * , unsigned , <nl> + 	 	 	 unsigned , unsigned * , void ( * ) ( ) ) ; <nl> + <nl> + void <nl> + ffi _ call ( ffi _ cif * cif , void ( * fn ) ( ) , void * rvalue , void * * avalue ) <nl> + { <nl> + extended _ cif ecif ; <nl> + long simple = cif - > flags & FFI _ SIMPLE ; <nl> + <nl> + / * Should this also check for Unix ABI ? * / <nl> + / * This is almost , but not quite , machine independent . Note that 	 * / <nl> + / * we can get away with not caring about length of the result because 	 * / <nl> + / * we assume we are little endian , and the result buffer is large 	 * / <nl> + / * enough . 	 	 	 	 	 	 	 	 * / <nl> + / * This needs work for HP / UX . 	 	 	 	 	 	 * / <nl> + if ( simple ) { <nl> + long ( * lfn ) ( ) = ( long ( * ) ( ) ) fn ; <nl> + long result ; <nl> + switch ( simple ) { <nl> + case FFI _ SIMPLE _ V : <nl> + 	 result = lfn ( ) ; <nl> + 	 break ; <nl> + case FFI _ SIMPLE _ I : <nl> + 	 result = lfn ( * ( int * ) avalue [ 0 ] ) ; <nl> + 	 break ; <nl> + case FFI _ SIMPLE _ L : <nl> + 	 result = lfn ( * ( long * ) avalue [ 0 ] ) ; <nl> + 	 break ; <nl> + case FFI _ SIMPLE _ II : <nl> + 	 result = lfn ( * ( int * ) avalue [ 0 ] , * ( int * ) avalue [ 1 ] ) ; <nl> + 	 break ; <nl> + case FFI _ SIMPLE _ IL : <nl> + 	 result = lfn ( * ( int * ) avalue [ 0 ] , * ( long * ) avalue [ 1 ] ) ; <nl> + 	 break ; <nl> + case FFI _ SIMPLE _ LI : <nl> + 	 result = lfn ( * ( long * ) avalue [ 0 ] , * ( int * ) avalue [ 1 ] ) ; <nl> + 	 break ; <nl> + case FFI _ SIMPLE _ LL : <nl> + 	 result = lfn ( * ( long * ) avalue [ 0 ] , * ( long * ) avalue [ 1 ] ) ; <nl> + 	 break ; <nl> + } <nl> + if ( ( cif - > flags & ~ FFI _ SIMPLE ) ! = FFI _ TYPE _ VOID & & 0 ! = rvalue ) { <nl> + * ( long * ) rvalue = result ; <nl> + } <nl> + return ; <nl> + } <nl> + ecif . cif = cif ; <nl> + ecif . avalue = avalue ; <nl> + <nl> + / * If the return value is a struct and we don ' t have a return <nl> + value address then we need to make one . * / <nl> + <nl> + if ( rvalue = = NULL & & cif - > rtype - > type = = FFI _ TYPE _ STRUCT ) <nl> + ecif . rvalue = alloca ( cif - > rtype - > size ) ; <nl> + else <nl> + ecif . rvalue = rvalue ; <nl> + <nl> + switch ( cif - > abi ) <nl> + { <nl> + case FFI _ UNIX : <nl> + ffi _ call _ unix ( ffi _ prep _ args , & ecif , cif - > bytes , <nl> + 	 	 cif - > flags , rvalue , fn ) ; <nl> + break ; <nl> + <nl> + default : <nl> + FFI _ ASSERT ( 0 ) ; <nl> + break ; <nl> + } <nl> + } <nl> + <nl> + / * <nl> + * Closures represent a pair consisting of a function pointer , and <nl> + * some user data . A closure is invoked by reinterpreting the closure <nl> + * as a function pointer , and branching to it . Thus we can make an <nl> + * interpreted function callable as a C function : We turn the interpreter <nl> + * itself , together with a pointer specifying the interpreted procedure , <nl> + * into a closure . <nl> + * On X86 , the first few words of the closure structure actually contain code , <nl> + * which will do the right thing . On most other architectures , this <nl> + * would raise some Icache / Dcache coherence issues ( which can be solved , but <nl> + * often not cheaply ) . <nl> + * For IA64 , function pointer are already pairs consisting of a code <nl> + * pointer , and a gp pointer . The latter is needed to access global variables . <nl> + * Here we set up such a pair as the first two words of the closure ( in <nl> + * the " trampoline " area ) , but we replace the gp pointer with a pointer <nl> + * to the closure itself . We also add the real gp pointer to the <nl> + * closure . This allows the function entry code to both retrieve the <nl> + * user data , and to restire the correct gp pointer . <nl> + * / <nl> + <nl> + static void <nl> + ffi _ prep _ incoming _ args _ UNIX ( struct ia64 _ args * args , void * * rvalue , <nl> + 	 	 	 void * * avalue , ffi _ cif * cif ) ; <nl> + <nl> + / * This function is entered with the doctored gp ( r1 ) value . <nl> + * This code is extremely gcc specific . There is some argument that <nl> + * it should really be written in assembly code , since it depends on <nl> + * gcc properties that might change over time . <nl> + * / <nl> + <nl> + / * ffi _ closure _ UNIX is an assembly routine , which copies the register 	 * / <nl> + / * state into s struct ia64 _ args , and the invokes 	 	 	 * / <nl> + / * ffi _ closure _ UNIX _ inner . It also recovers the closure pointer 	 * / <nl> + / * from its fake gp pointer . 	 	 	 	 	 	 * / <nl> + void ffi _ closure _ UNIX ( ) ; <nl> + <nl> + # ifndef _ _ GNUC _ _ <nl> + # error This requires gcc <nl> + # endif <nl> + void <nl> + ffi _ closure _ UNIX _ inner ( ffi _ closure * closure , struct ia64 _ args * args ) <nl> + / * Hopefully declarint this as a varargs function will force all args 	 * / <nl> + / * to memory . 	 	 	 	 	 	 	 	 * / <nl> + { <nl> + / / this is our return value storage <nl> + long double res ; <nl> + <nl> + / / our various things . . . <nl> + ffi _ cif * cif ; <nl> + unsigned short rtype ; <nl> + void * resp ; <nl> + void 	 	 * * arg _ area ; <nl> + <nl> + resp = ( void * ) & res ; <nl> + cif = closure - > cif ; <nl> + arg _ area = ( void * * ) alloca ( cif - > nargs * sizeof ( void * ) ) ; <nl> + <nl> + / * this call will initialize ARG _ AREA , such that each <nl> + * element in that array points to the corresponding <nl> + * value on the stack ; and if the function returns <nl> + * a structure , it will re - set RESP to point to the <nl> + * structure return address . * / <nl> + <nl> + ffi _ prep _ incoming _ args _ UNIX ( args , ( void * * ) & resp , arg _ area , cif ) ; <nl> + <nl> + ( closure - > fun ) ( cif , resp , arg _ area , closure - > user _ data ) ; <nl> + <nl> + rtype = cif - > flags ; <nl> + <nl> + / * now , do a generic return based on the value of rtype * / <nl> + if ( rtype = = FFI _ TYPE _ INT ) <nl> + { <nl> + asm volatile ( " ld8 r8 = [ % 0 ] " : : " r " ( resp ) : " r8 " ) ; <nl> + } <nl> + else if ( rtype = = FFI _ TYPE _ FLOAT ) <nl> + { <nl> + asm volatile ( " ldfs f8 = [ % 0 ] " : : " r " ( resp ) : " f8 " ) ; <nl> + } <nl> + else if ( rtype = = FFI _ TYPE _ DOUBLE ) <nl> + { <nl> + asm volatile ( " ldfd f8 = [ % 0 ] " : : " r " ( resp ) : " f8 " ) ; <nl> + } <nl> + else if ( rtype = = FFI _ IS _ SMALL _ STRUCT2 ) <nl> + { <nl> + asm volatile ( " ld8 r8 = [ % 0 ] ; ld8 r9 = [ % 1 ] " <nl> + 	 	 : : " r " ( resp ) , " r " ( resp + 8 ) : " r8 " , " r9 " ) ; <nl> + } <nl> + else if ( rtype = = FFI _ IS _ SMALL _ STRUCT3 ) <nl> + { <nl> + asm volatile ( " ld8 r8 = [ % 0 ] ; ld8 r9 = [ % 1 ] ; ld8 r10 = [ % 2 ] " <nl> + 	 	 : : " r " ( resp ) , " r " ( resp + 8 ) , " r " ( resp + 16 ) <nl> + 	 	 : " r8 " , " r9 " , " r10 " ) ; <nl> + } <nl> + else if ( rtype = = FFI _ IS _ SMALL _ STRUCT4 ) <nl> + { <nl> + asm volatile ( " ld8 r8 = [ % 0 ] ; ld8 r9 = [ % 1 ] ; ld8 r10 = [ % 2 ] ; ld8 r11 = [ % 3 ] " <nl> + 	 	 : : " r " ( resp ) , " r " ( resp + 8 ) , " r " ( resp + 16 ) , " r " ( resp + 24 ) <nl> + 	 	 : " r8 " , " r9 " , " r10 " , " r11 " ) ; <nl> + } <nl> + else if ( rtype ! = FFI _ TYPE _ VOID & & rtype ! = FFI _ TYPE _ STRUCT ) <nl> + { <nl> + / * Can only happen for homogeneous FP aggregates ? 	 * / <nl> + abort ( ) ; <nl> + } <nl> + } <nl> + <nl> + static void <nl> + ffi _ prep _ incoming _ args _ UNIX ( struct ia64 _ args * args , void * * rvalue , <nl> + 	 	 	 void * * avalue , ffi _ cif * cif ) <nl> + { <nl> + register unsigned int i ; <nl> + register unsigned int avn ; <nl> + register void * * p _ argv ; <nl> + register unsigned long * argp = args - > out _ regs ; <nl> + unsigned fp _ reg _ num = 0 ; <nl> + register ffi _ type * * p _ arg ; <nl> + <nl> + avn = cif - > nargs ; <nl> + p _ argv = avalue ; <nl> + <nl> + for ( i = cif - > nargs , p _ arg = cif - > arg _ types ; i ! = 0 ; i - - , p _ arg + + ) <nl> + { <nl> + size _ t z ; / * In units of words or argument slots . 	 * / <nl> + <nl> + switch ( ( * p _ arg ) - > type ) <nl> + 	 { <nl> + 	 case FFI _ TYPE _ SINT8 : <nl> + 	 case FFI _ TYPE _ UINT8 : <nl> + 	 case FFI _ TYPE _ SINT16 : <nl> + 	 case FFI _ TYPE _ UINT16 : <nl> + 	 case FFI _ TYPE _ SINT32 : <nl> + 	 case FFI _ TYPE _ UINT32 : <nl> + 	 case FFI _ TYPE _ SINT64 : <nl> + 	 case FFI _ TYPE _ UINT64 : <nl> + 	 case FFI _ TYPE _ POINTER : <nl> + 	 z = 1 ; <nl> + 	 * p _ argv = ( void * ) argp ; <nl> + 	 break ; <nl> + 	 	 <nl> + 	 case FFI _ TYPE _ FLOAT : <nl> + 	 z = 1 ; <nl> + 	 / * Convert argument back to float in place from the saved value * / <nl> + 	 if ( fp _ reg _ num < 8 ) { <nl> + 	 * ( float * ) argp = args - > fp _ regs [ fp _ reg _ num + + ] ; <nl> + 	 } else { <nl> + 	 * ( float * ) argp = * ( double * ) argp ; <nl> + 	 } <nl> + 	 * p _ argv = ( void * ) argp ; <nl> + 	 break ; <nl> + <nl> + 	 case FFI _ TYPE _ DOUBLE : <nl> + 	 z = 1 ; <nl> + 	 if ( fp _ reg _ num < 8 ) { <nl> + 	 * p _ argv = args - > fp _ regs + fp _ reg _ num + + ; <nl> + 	 } else { <nl> + 	 * p _ argv = ( void * ) argp ; <nl> + 	 } <nl> + 	 break ; <nl> + <nl> + 	 case FFI _ TYPE _ STRUCT : <nl> + 	 { <nl> + 	 size _ t sz = ( * p _ arg ) - > size ; <nl> + 	 unsigned short element _ type ; <nl> + z = ( ( * p _ arg ) - > size + SIZEOF _ ARG - 1 ) / SIZEOF _ ARG ; <nl> + 	 if ( is _ homogeneous _ fp _ aggregate ( * p _ arg , 8 , & element _ type ) ) { <nl> + 	 	 int nelements = sz / float _ type _ size ( element _ type ) ; <nl> + 	 	 if ( nelements + fp _ reg _ num > = 8 ) { <nl> + 	 	 / * hard case NYI . 	 * / <nl> + 	 	 abort ( ) ; <nl> + 	 	 } <nl> + 	 	 if ( element _ type = = FFI _ TYPE _ DOUBLE ) { <nl> + 	 * p _ argv = args - > fp _ regs + fp _ reg _ num ; <nl> + 	 	 fp _ reg _ num + = nelements ; <nl> + 	 	 break ; <nl> + 	 	 } <nl> + 	 	 if ( element _ type = = FFI _ TYPE _ FLOAT ) { <nl> + 	 	 int j ; <nl> + 	 	 for ( j = 0 ; j < nelements ; + + j ) { <nl> + 	 	 ( ( float * ) argp ) [ j ] = args - > fp _ regs [ fp _ reg _ num + j ] ; <nl> + 	 	 } <nl> + 	 * p _ argv = ( void * ) argp ; <nl> + 	 	 fp _ reg _ num + = nelements ; <nl> + 	 	 break ; <nl> + 	 	 } <nl> + 	 	 abort ( ) ; / * Other fp types NYI * / <nl> + 	 } <nl> + 	 } <nl> + 	 break ; <nl> + <nl> + 	 default : <nl> + 	 FFI _ ASSERT ( 0 ) ; <nl> + 	 } <nl> + <nl> + argp + = z ; <nl> + p _ argv + + ; <nl> + <nl> + } <nl> + <nl> + return ; <nl> + } <nl> + <nl> + <nl> + / * Fill in a closure to refer to the specified fun and user _ data . 	 * / <nl> + / * cif specifies the argument and result types for fun . 	 	 	 * / <nl> + / * the cif must already be prep ' ed * / <nl> + <nl> + / * The layout of a function descriptor . A C function pointer really 	 * / <nl> + / * points to one of these . 	 	 	 	 	 	 * / <nl> + typedef struct ia64 _ fd _ struct { <nl> + void * code _ pointer ; <nl> + void * gp ; <nl> + } ia64 _ fd ; <nl> + <nl> + ffi _ status <nl> + ffi _ prep _ closure ( ffi _ closure * closure , <nl> + 	 	 ffi _ cif * cif , <nl> + 	 	 void ( * fun ) ( ffi _ cif * , void * , void * * , void * ) , <nl> + 	 	 void * user _ data ) <nl> + { <nl> + struct ffi _ ia64 _ trampoline _ struct * tramp = <nl> + ( struct ffi _ ia64 _ trampoline _ struct * ) ( closure - > tramp ) ; <nl> + ia64 _ fd * fd = ( ia64 _ fd * ) ( void * ) ffi _ closure _ UNIX ; <nl> + <nl> + FFI _ ASSERT ( cif - > abi = = FFI _ UNIX ) ; <nl> + <nl> + tramp - > code _ pointer = fd - > code _ pointer ; <nl> + tramp - > real _ gp = fd - > gp ; <nl> + tramp - > fake _ gp = closure ; <nl> + closure - > cif = cif ; <nl> + closure - > user _ data = user _ data ; <nl> + closure - > fun = fun ; <nl> + <nl> + return FFI _ OK ; <nl> + } <nl> + <nl> + <nl> diff - - git a / libffi / ia64 / ia64 _ flags . h b / libffi / ia64 / ia64 _ flags . h <nl> new file mode 100644 <nl> index 0000000 . . 23dbd3e <nl> - - - / dev / null <nl> + + + b / libffi / ia64 / ia64 _ flags . h <nl> @ @ - 0 , 0 + 1 , 62 @ @ <nl> + / * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> + ia64 _ flags . h - Copyright ( c ) 2000 Hewlett Packard Company <nl> + <nl> + IA64 / unix Foreign Function Interface <nl> + <nl> + Original author : Hans Boehm , HP Labs <nl> + <nl> + Permission is hereby granted , free of charge , to any person obtaining <nl> + a copy of this software and associated documentation files ( the <nl> + ` ` Software ' ' ) , to deal in the Software without restriction , including <nl> + without limitation the rights to use , copy , modify , merge , publish , <nl> + distribute , sublicense , and / or sell copies of the Software , and to <nl> + permit persons to whom the Software is furnished to do so , subject to <nl> + the following conditions : <nl> + <nl> + The above copyright notice and this permission notice shall be included <nl> + in all copies or substantial portions of the Software . <nl> + <nl> + THE SOFTWARE IS PROVIDED ` ` AS IS ' ' , WITHOUT WARRANTY OF ANY KIND , EXPRESS <nl> + OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF <nl> + MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . <nl> + IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM , DAMAGES OR <nl> + OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , <nl> + ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR <nl> + OTHER DEALINGS IN THE SOFTWARE . <nl> + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / <nl> + <nl> + <nl> + / * Homogeneous Floating Point Aggregates ( HFAs ) which are returned 	 * / <nl> + / * in FP registers . The least significant bits specify the size in 	 * / <nl> + / * words . 	 	 	 	 	 	 	 	 * / <nl> + # define FFI _ IS _ FLOAT _ FP _ AGGREGATE 0x1000 <nl> + # define FFI _ IS _ DOUBLE _ FP _ AGGREGATE 0x0800 <nl> + # define FLOAT _ FP _ AGGREGATE _ BIT 12 <nl> + # define DOUBLE _ FP _ AGGREGATE _ BIT 11 <nl> + <nl> + / * Small structures containing N words . If N = 1 , they are returned 	 * / <nl> + / * as though they were integers . 	 	 	 	 	 * / <nl> + # define FFI _ IS _ SMALL _ STRUCT2 	 0x40 / * Struct > 8 , < = 16 bytes 	 * / <nl> + # define FFI _ IS _ SMALL _ STRUCT3 	 0x41 / * Struct > 16 < = 24 bytes 	 * / <nl> + # define FFI _ IS _ SMALL _ STRUCT4 	 0x42 / * Struct > 24 , < = 32 bytes 	 * / <nl> + <nl> + / * Flag values identifying particularly simple cases , which are 	 * / <nl> + / * handled specially . We treat functions as simple if they take all 	 * / <nl> + / * arguments can be passed as 32 or 64 bit integer quantities , there is 	 * / <nl> + / * either no return value or it can be treated as a 64bit integer , and 	 * / <nl> + / * if there are at most 2 arguments . 	 	 	 	 	 * / <nl> + / * This is OR ' ed with the normal flag values . 	 	 	 	 * / <nl> + # define FFI _ SIMPLE _ V 0x10000 	 / * ( ) - > X 	 * / <nl> + # define FFI _ SIMPLE _ I 0x20000 	 / * ( int ) - > X 	 * / <nl> + # define FFI _ SIMPLE _ L 0x30000 	 / * ( long ) - > X 	 * / <nl> + # define FFI _ SIMPLE _ II 0x40000 	 / * ( int , int ) - > X 	 * / <nl> + # define FFI _ SIMPLE _ IL 0x50000 	 / * ( int , long ) - > X 	 * / <nl> + # define FFI _ SIMPLE _ LI 0x60000 	 / * ( long , int ) - > X 	 * / <nl> + # define FFI _ SIMPLE _ LL 0x70000 	 / * ( long , long ) - > X 	 * / <nl> + <nl> + / * Mask for all of the FFI _ SIMPLE bits : 	 * / <nl> + # define FFI _ SIMPLE 0xf0000 <nl> + <nl> + / * An easy way to build FFI _ SIMPLE flags from FFI _ SIMPLE _ V : 	 * / <nl> + # define FFI _ ADD _ LONG _ ARG ( flag ) ( ( ( flag ) < < 1 ) | 0x10000 ) <nl> + # define FFI _ ADD _ INT _ ARG ( flag ) ( ( flag ) < < 1 ) <nl> diff - - git a / libffi / ia64 / unix . S b / libffi / ia64 / unix . S <nl> new file mode 100644 <nl> index 0000000 . . fdaf8be <nl> - - - / dev / null <nl> + + + b / libffi / ia64 / unix . S <nl> @ @ - 0 , 0 + 1 , 301 @ @ <nl> + / * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> + unix . S - Copyright ( c ) 1998 Cygnus Solutions <nl> + Copyright ( c ) 2000 Hewlett Packard Company <nl> + <nl> + IA64 / unix Foreign Function Interface <nl> + <nl> + Primary author : Hans Boehm , HP Labs <nl> + <nl> + Loosely modeled on Cygnus code for other platforms . <nl> + <nl> + Permission is hereby granted , free of charge , to any person obtaining <nl> + a copy of this software and associated documentation files ( the <nl> + ` ` Software ' ' ) , to deal in the Software without restriction , including <nl> + without limitation the rights to use , copy , modify , merge , publish , <nl> + distribute , sublicense , and / or sell copies of the Software , and to <nl> + permit persons to whom the Software is furnished to do so , subject to <nl> + the following conditions : <nl> + <nl> + The above copyright notice and this permission notice shall be included <nl> + in all copies or substantial portions of the Software . <nl> + <nl> + THE SOFTWARE IS PROVIDED ` ` AS IS ' ' , WITHOUT WARRANTY OF ANY KIND , EXPRESS <nl> + OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF <nl> + MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . <nl> + IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM , DAMAGES OR <nl> + OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , <nl> + ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR <nl> + OTHER DEALINGS IN THE SOFTWARE . <nl> + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / <nl> + <nl> + # define LIBFFI _ ASM 	 <nl> + # include < ffi . h > <nl> + # include " ia64 _ flags . h " <nl> + <nl> + / * parameters : 	 * / <nl> + # define callback 	 in0 <nl> + # define ecifp 	 	 in1 <nl> + # define bytes 	 	 in2 <nl> + # define flags 	 	 in3 <nl> + # define raddr 	 	 in4 <nl> + # define fn 	 	 in5 <nl> + <nl> + # define FLOAT _ SZ 	 8 / * in - memory size of fp operands 	 * / <nl> + <nl> + . text <nl> + . align 16 <nl> + . global ffi _ call _ unix # <nl> + . proc ffi _ call _ unix # <nl> + ffi _ call _ unix : <nl> + 	 alloc loc0 = ar . pfs , 6 , 5 , 8 , 0 <nl> + 	 mov 	 loc1 = b0 ; <nl> + 	 sub 	 sp = sp , bytes <nl> + 	 mov 	 loc4 = r1 	 	 / * Save gp 	 * / <nl> + 	 ld8 	 r8 = [ callback ] , 8 	 / * code address of callback 	 * / <nl> + 	 ; ; <nl> + 	 mov 	 out0 = sp <nl> + 	 mov 	 out1 = ecifp <nl> + 	 mov 	 out2 = bytes <nl> + 	 ld8 	 r1 = [ callback ] 	 / * Set up gp for callback . Unnecessary ? * / <nl> + 	 mov 	 b6 = r8 <nl> + 	 ; ; <nl> + 	 br . call . sptk . many b0 = b6 	 / * call ffi _ prep _ args 	 	 * / <nl> + 	 cmp . eq 	 p6 , p0 = 0 , r8 	 	 / * r8 nonzero = = > need fp regs 	 * / <nl> + 	 ; ; <nl> + ( p6 ) 	 add 	 loc2 = 32 + 8 * FLOAT _ SZ , sp <nl> + ( p6 ) 	 br . cond . dptk . many 	 fp _ done <nl> + 	 ; ; 	 / * Quiets warning ; needed ? 	 * / <nl> + 	 add 	 loc2 = 32 , sp <nl> + 	 add 	 loc3 = 32 + FLOAT _ SZ , sp <nl> + 	 ; ; <nl> + 	 ldfd 	 f8 = [ loc2 ] , 2 * FLOAT _ SZ <nl> + 	 ldfd 	 f9 = [ loc3 ] , 2 * FLOAT _ SZ <nl> + 	 ; ; <nl> + 	 ldfd 	 f10 = [ loc2 ] , 2 * FLOAT _ SZ <nl> + 	 ldfd 	 f11 = [ loc3 ] , 2 * FLOAT _ SZ <nl> + 	 ; ; <nl> + 	 ldfd 	 f12 = [ loc2 ] , 2 * FLOAT _ SZ <nl> + 	 ldfd 	 f13 = [ loc3 ] , 2 * FLOAT _ SZ <nl> + 	 ; ; <nl> + 	 ldfd 	 f14 = [ loc2 ] , 2 * FLOAT _ SZ <nl> + 	 ldfd 	 f15 = [ loc3 ] <nl> + fp _ done : <nl> + 	 add 	 r9 = 16 , sp 	 / * Pointer to r8 _ contents 	 * / <nl> + 	 / * loc2 points at first integer register value . * / <nl> + 	 add 	 loc3 = 8 , loc2 <nl> + 	 ; ; <nl> + 	 ld8 	 r8 = [ r9 ] 	 	 / * Just in case we return large struct * / <nl> + 	 ld8 	 out0 = [ loc2 ] , 16 <nl> + 	 ld8 	 out1 = [ loc3 ] , 16 <nl> + 	 ; ; <nl> + 	 ld8 	 out2 = [ loc2 ] , 16 <nl> + 	 ld8 	 out3 = [ loc3 ] , 16 <nl> + 	 ; ; <nl> + 	 ld8 	 out4 = [ loc2 ] , 16 <nl> + 	 ld8 	 out5 = [ loc3 ] , 16 <nl> + 	 ; ; <nl> + 	 ld8 	 out6 = [ loc2 ] , 16 <nl> + 	 ld8 	 out7 = [ loc3 ] <nl> + 	 / * loc2 points at first stack parameter . Set sp to 16 bytes 	 * / <nl> + 	 / * below that . 	 	 	 	 	 	 	 * / <nl> + 	 add 	 sp = - 16 , loc2 <nl> + 	 <nl> + 	 ld8 	 r8 = [ fn ] , 8 <nl> + 	 ; ; <nl> + 	 ld8 	 r1 = [ fn ] 	 	 / * Set up gp * / <nl> + 	 mov 	 b6 = r8 ; ; <nl> + 	 br . call . sptk . many b0 = b6 	 / * call ffi _ prep _ args 	 * / <nl> + 	 <nl> + 	 / * Handle return value . * / <nl> + 	 cmp . eq 	 p6 , p0 = 0 , raddr <nl> + 	 cmp . eq 	 p7 , p0 = FFI _ TYPE _ INT , flags <nl> + 	 cmp . eq 	 p10 , p0 = FFI _ IS _ SMALL _ STRUCT2 , flags <nl> + 	 cmp . eq 	 p11 , p0 = FFI _ IS _ SMALL _ STRUCT3 , flags <nl> + 	 cmp . eq 	 p12 , p0 = FFI _ IS _ SMALL _ STRUCT4 , flags <nl> + 	 ; ; <nl> + ( p6 ) 	 br . cond . dpnt . few done 	 	 / * Dont copy ret values if raddr = 0 * / <nl> + ( p7 ) 	 br . cond . dptk . few copy1 <nl> + ( p10 ) 	 br . cond . dpnt . few copy2 <nl> + ( p11 ) 	 br . cond . dpnt . few copy3 <nl> + ( p12 ) 	 br . cond . dpnt . few copy4 <nl> + 	 cmp . eq 	 p8 , p0 = FFI _ TYPE _ FLOAT , flags <nl> + 	 cmp . eq 	 p9 , p0 = FFI _ TYPE _ DOUBLE , flags <nl> + 	 tbit . nz 	 p6 , p0 = flags , FLOAT _ FP _ AGGREGATE _ BIT <nl> + 	 tbit . nz 	 p7 , p0 = flags , DOUBLE _ FP _ AGGREGATE _ BIT <nl> + 	 ; ; <nl> + ( p8 ) 	 stfs 	 [ raddr ] = f8 <nl> + ( p9 ) 	 stfd 	 [ raddr ] = f8 <nl> + 	 ; ; <nl> + ( p6 ) 	 br . cond . dpnt . few handle _ float _ hfa <nl> + ( p7 ) 	 br . cond . dpnt . few handle _ double _ hfa <nl> + 	 br done <nl> + <nl> + copy4 : <nl> + 	 add 	 loc3 = 24 , raddr <nl> + 	 ; ; <nl> + 	 st8 	 [ loc3 ] = r11 <nl> + copy3 : <nl> + 	 add 	 loc3 = 16 , raddr <nl> + 	 ; ; <nl> + 	 st8 	 [ loc3 ] = r10 <nl> + copy2 : <nl> + 	 add 	 loc3 = 8 , raddr <nl> + 	 ; ; <nl> + 	 st8 	 [ loc3 ] = r9 <nl> + copy1 : <nl> + 	 st8 	 [ raddr ] = r8 <nl> + 	 / * In the big struct case , raddr was passed as an argument . 	 * / <nl> + 	 / * In the void case there was nothing to do . 	 	 	 * / <nl> + <nl> + done : <nl> + 	 mov 	 r1 = loc4 	 	 / * Restore gp 	 * / <nl> + 	 mov 	 ar . pfs = loc0 <nl> + 	 mov 	 b0 = loc1 <nl> + 	 br . ret . sptk . many b0 <nl> + <nl> + handle _ double _ hfa : <nl> + 	 / * Homogeneous floating point array of doubles is returned in 	 * / <nl> + 	 / * registers f8 - f15 . Save one at a time to return area . 	 * / <nl> + 	 and 	 flags = 0xf , flags 	 / * Retrieve size 	 * / <nl> + 	 ; ; <nl> + 	 cmp . eq 	 p6 , p0 = 2 , flags <nl> + 	 cmp . eq 	 p7 , p0 = 3 , flags <nl> + 	 cmp . eq 	 p8 , p0 = 4 , flags <nl> + 	 cmp . eq 	 p9 , p0 = 5 , flags <nl> + 	 cmp . eq 	 p10 , p0 = 6 , flags <nl> + 	 cmp . eq 	 p11 , p0 = 7 , flags <nl> + 	 cmp . eq 	 p12 , p0 = 8 , flags <nl> + 	 ; ; <nl> + ( p6 ) 	 br . cond . dptk . few 	 dhfa2 <nl> + ( p7 ) 	 br . cond . dptk . few 	 dhfa3 <nl> + ( p8 ) 	 br . cond . dptk . few 	 dhfa4 <nl> + ( p9 ) 	 br . cond . dptk . few 	 dhfa5 <nl> + ( p10 ) 	 br . cond . dptk . few 	 dhfa6 <nl> + ( p11 ) 	 br . cond . dptk . few 	 dhfa7 <nl> + dhfa8 : 	 add 	 loc3 = 7 * 8 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f15 <nl> + dhfa7 : 	 add 	 loc3 = 6 * 8 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f14 <nl> + dhfa6 : 	 add 	 loc3 = 5 * 8 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f13 <nl> + dhfa5 : 	 add 	 loc3 = 4 * 8 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f12 <nl> + dhfa4 : 	 add 	 loc3 = 3 * 8 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f11 <nl> + dhfa3 : 	 add 	 loc3 = 2 * 8 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f10 <nl> + dhfa2 : 	 add 	 loc3 = 1 * 8 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f9 <nl> + 	 stfd 	 [ raddr ] = f8 <nl> + 	 br 	 done <nl> + <nl> + handle _ float _ hfa : <nl> + 	 / * Homogeneous floating point array of floats is returned in 	 * / <nl> + 	 / * registers f8 - f15 . Save one at a time to return area . 	 * / <nl> + 	 and 	 flags = 0xf , flags 	 / * Retrieve size 	 * / <nl> + 	 ; ; <nl> + 	 cmp . eq 	 p6 , p0 = 2 , flags <nl> + 	 cmp . eq 	 p7 , p0 = 3 , flags <nl> + 	 cmp . eq 	 p8 , p0 = 4 , flags <nl> + 	 cmp . eq 	 p9 , p0 = 5 , flags <nl> + 	 cmp . eq 	 p10 , p0 = 6 , flags <nl> + 	 cmp . eq 	 p11 , p0 = 7 , flags <nl> + 	 cmp . eq 	 p12 , p0 = 8 , flags <nl> + 	 ; ; <nl> + ( p6 ) 	 br . cond . dptk . few 	 shfa2 <nl> + ( p7 ) 	 br . cond . dptk . few 	 shfa3 <nl> + ( p8 ) 	 br . cond . dptk . few 	 shfa4 <nl> + ( p9 ) 	 br . cond . dptk . few 	 shfa5 <nl> + ( p10 ) 	 br . cond . dptk . few 	 shfa6 <nl> + ( p11 ) 	 br . cond . dptk . few 	 shfa7 <nl> + shfa8 : 	 add 	 loc3 = 7 * 4 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f15 <nl> + shfa7 : 	 add 	 loc3 = 6 * 4 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f14 <nl> + shfa6 : 	 add 	 loc3 = 5 * 4 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f13 <nl> + shfa5 : 	 add 	 loc3 = 4 * 4 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f12 <nl> + shfa4 : 	 add 	 loc3 = 3 * 4 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f11 <nl> + shfa3 : 	 add 	 loc3 = 2 * 4 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f10 <nl> + shfa2 : 	 add 	 loc3 = 1 * 4 , raddr <nl> + 	 ; ; <nl> + 	 stfd 	 [ loc3 ] = f9 <nl> + 	 stfd 	 [ raddr ] = f8 <nl> + 	 br 	 done <nl> + <nl> + . endp ffi _ call _ unix <nl> + <nl> + <nl> + . text <nl> + . align 16 <nl> + . global ffi _ closure _ UNIX <nl> + . proc ffi _ closure _ UNIX <nl> + ffi _ closure _ UNIX : <nl> + 	 alloc loc0 = ar . pfs , 8 , 2 , 2 , 0 <nl> + 	 mov 	 loc1 = b0 <nl> + 	 / * Retrieve closure pointer and real gp . 	 * / <nl> + 	 mov 	 out0 = gp <nl> + 	 add 	 gp = 16 , gp <nl> + 	 ; ; <nl> + 	 ld8 	 gp = [ gp ] <nl> + 	 / * Reserve a structia64 _ args on the stack such that arguments 	 * / <nl> + 	 / * past the first 8 are automatically placed in the right 	 * / <nl> + 	 / * slot . Note that when we start the sp points at 2 8 - byte 	 * / <nl> + 	 / * scratch words , followed by the extra arguments . 	 	 * / <nl> + # 	 define BASIC _ ARGS _ SZ ( 8 * FLOAT _ SZ + 8 * 8 + 2 * 8 ) <nl> + # 	 define FIRST _ FP _ OFFSET ( 4 * 8 ) <nl> + 	 add 	 r14 = - ( BASIC _ ARGS _ SZ - FIRST _ FP _ OFFSET ) , sp <nl> + 	 add 	 r15 = - ( BASIC _ ARGS _ SZ - FIRST _ FP _ OFFSET - FLOAT _ SZ ) , sp <nl> + 	 add 	 sp = - BASIC _ ARGS _ SZ , sp <nl> + 	 / * r14 points to fp _ regs [ 0 ] , r15 points to fp _ regs [ 1 ] 	 * / <nl> + 	 ; ; <nl> + 	 stfd 	 [ r14 ] = f8 , 2 * FLOAT _ SZ <nl> + 	 stfd 	 [ r15 ] = f9 , 2 * FLOAT _ SZ <nl> + 	 ; ; <nl> + 	 stfd 	 [ r14 ] = f10 , 2 * FLOAT _ SZ <nl> + 	 stfd 	 [ r15 ] = f11 , 2 * FLOAT _ SZ <nl> + 	 ; ; <nl> + 	 stfd 	 [ r14 ] = f12 , 2 * FLOAT _ SZ <nl> + 	 stfd 	 [ r15 ] = f13 , 2 * FLOAT _ SZ <nl> + 	 ; ; <nl> + 	 stfd 	 [ r14 ] = f14 , FLOAT _ SZ + 8 <nl> + 	 stfd 	 [ r15 ] = f15 , 2 * 8 <nl> + 	 ; ; <nl> + 	 / * r14 points to first parameter register area , r15 to second . * / <nl> + 	 st8 	 [ r14 ] = in0 , 2 * 8 <nl> + 	 st8 	 [ r15 ] = in1 , 2 * 8 <nl> + 	 ; ; <nl> + 	 st8 	 [ r14 ] = in2 , 2 * 8 <nl> + 	 st8 	 [ r15 ] = in3 , 2 * 8 <nl> + 	 ; ; <nl> + 	 st8 	 [ r14 ] = in4 , 2 * 8 <nl> + 	 st8 	 [ r15 ] = in5 , 2 * 8 <nl> + 	 ; ; <nl> + 	 st8 	 [ r14 ] = in6 , 2 * 8 <nl> + 	 st8 	 [ r15 ] = in7 , 2 * 8 <nl> + 	 / * Call ffi _ closure _ UNIX _ inner * / <nl> + 	 mov 	 out1 = sp <nl> + 	 br . call . sptk . many b0 = ffi _ closure _ UNIX _ inner <nl> + 	 ; ; <nl> + 	 mov 	 b0 = loc1 <nl> + 	 mov 	 ar . pfs = loc0 <nl> + 	 br . ret . sptk . many b0 <nl> + 	 . endp ffi _ closure _ UNIX <nl> + 	 <nl> +

TEST DIFF:
diff - - git a / native / Makefile b / native / Makefile 
 index c7600c6 . . d9aac90 100644 
 - - - a / native / Makefile 
 + + + b / native / Makefile 
 @ @ - 190 , 11 + 190 , 11 @ @ CC + = - m64 
 FFI _ CONFIG + = - - host = x86 _ 64 - w64 - mingw32 
 endif 
 FFI _ CONFIG + = & & rm - f include / ffitarget . h & & cp $ ( FFI _ SRC ) / include / * . h $ ( FFI _ SRC ) / src / x86 / ffitarget . h include 
 - FFI _ ENV + = LD = " $ ( LD ) " CPP = " $ ( CPP ) " 
 + FFI _ ENV + = LD = " $ ( LD ) " CPP = " $ ( CPP ) " CXXCPP = " $ ( CPP ) " 
 EXTRAOBJS + = $ ( DLLCB ) 
 else 
 - PREFIX = i686 - pc - mingw32 - 
 - CC = $ ( PREFIX ) gcc 
 + MINGW _ PREFIX ? = i686 - pc - mingw32 - 
 + CC = $ ( MINGW _ PREFIX ) gcc 
 LDFLAGS = - o $ @ - shared - Wl , - - add - stdcall - alias 
 LIBS = - lpsapi 
 endif 
 @ @ - 203 , 7 + 203 , 7 @ @ ifeq ( $ ( ARCH ) , amd64 ) 
 # Undefine USE _ MSVC to enable mingw64 cross compiler ; ensure $ ( MINGW ) is in 
 # PATH . Should build properly as of 111121 , but lacks SEH , so MSVC build is 
 # preferred 
 - MINGW _ PREFIX ? = x86 _ 64 - pc - mingw32 - 
 + MINGW _ PREFIX ? = x86 _ 64 - w64 - mingw32 - 
 MINGW = $ ( MINGW _ PREFIX ) gcc 
 # Need windres from mingw distribution , even if building with MSVC 
 WINDRES = $ ( MINGW _ PREFIX ) windres 
 @ @ - 372 , 8 + 372 , 10 @ @ install : 
 	 mkdir $ ( INSTALLDIR ) 
 	 cp $ ( LIBRARY ) $ ( INSTALLDIR ) 
 
 + ifeq ( $ ( ARCH ) , amd64 ) 
 $ ( DLLCB ) : dll - callback . c 
 	 $ ( MINGW ) - DDEFINE _ CALLBACKS - c $ < $ ( COUT ) 
 + endif 
 
 $ ( RSRC ) : $ ( BUILD ) / jnidispatch . rc $ ( BUILD ) / $ ( JNA _ JNI _ VERSION ) . stamp 
 	 $ ( WINDRES ) - i $ < - o $ @ \ 
 diff - - git a / native / libffi / src / x86 / ffi . c b / native / libffi / src / x86 / ffi . c 
 index d16ec5b . . c7b5dbc 100644 
 - - - a / native / libffi / src / x86 / ffi . c 
 + + + b / native / libffi / src / x86 / ffi . c 
 @ @ - 99 , 12 + 99 , 12 @ @ unsigned int ffi _ prep _ args ( char * stack , extended _ cif * ecif ) 
 i ! = 0 ; 
 i - - , p _ arg + = dir , p _ argv + = dir ) 
 { 
 + size _ t z = ( * p _ arg ) - > size ; 
 + 
 / * Align if necessary * / 
 if ( ( sizeof ( void * ) - 1 ) & ( size _ t ) argp ) 
 argp = ( char * ) ALIGN ( argp , sizeof ( void * ) ) ; 
 
 - size _ t z = ( * p _ arg ) - > size ; 
 - 
 # ifdef X86 _ WIN64 
 if ( z > FFI _ SIZEOF _ ARG 
 | | ( ( * p _ arg ) - > type = = FFI _ TYPE _ STRUCT 
 @ @ - 202 , 6 + 202 , 7 @ @ unsigned int ffi _ prep _ args ( char * stack , extended _ cif * ecif ) 
 on top of stack , so that those can be moved to registers by call - handler . * / 
 if ( stack _ args _ count > 0 ) 
 { 
 + unsigned i ; 
 if ( dir < 0 & & stack _ args _ count > 1 ) 
 { 
 / * Reverse order if iterating arguments backwards * / 
 @ @ - 210 , 7 + 211 , 6 @ @ unsigned int ffi _ prep _ args ( char * stack , extended _ cif * ecif ) 
 * ( ffi _ arg * ) p _ stack _ data [ stack _ args _ count - 1 ] = tmp ; 
 } 
 
 - int i ; 
 for ( i = 0 ; i < stack _ args _ count ; i + + ) 
 { 
 if ( p _ stack _ data [ i ] ! = argp2 ) 
 @ @ - 572 , 11 + 572 , 12 @ @ ffi _ prep _ incoming _ args ( char * stack , void * * rvalue , void * * avalue , 
 i < cif - > nargs & & passed _ regs < max _ stack _ count ; 
 i + + , p _ arg + + ) 
 { 
 + size _ t sz = ( * p _ arg ) - > size ; 
 + 
 if ( ( * p _ arg ) - > type = = FFI _ TYPE _ FLOAT 
 | | ( * p _ arg ) - > type = = FFI _ TYPE _ STRUCT ) 
 continue ; 
 
 - size _ t sz = ( * p _ arg ) - > size ; 
 if ( sz = = 0 | | sz > FFI _ SIZEOF _ ARG ) 
 continue ; 
 
 @ @ - 602 , 12 + 603 , 12 @ @ ffi _ prep _ incoming _ args ( char * stack , void * * rvalue , void * * avalue , 
 i ! = 0 ; 
 i - - , p _ arg + = dir , p _ argv + = dir ) 
 { 
 + size _ t z = ( * p _ arg ) - > size ; 
 + 
 / * Align if necessary * / 
 if ( ( sizeof ( void * ) - 1 ) & ( size _ t ) argp ) 
 argp = ( char * ) ALIGN ( argp , sizeof ( void * ) ) ; 
 
 - size _ t z = ( * p _ arg ) - > size ; 
 - 
 # ifdef X86 _ WIN64 
 if ( z > FFI _ SIZEOF _ ARG 
 | | ( ( * p _ arg ) - > type = = FFI _ TYPE _ STRUCT 
 @ @ - 858 , 11 + 859 , 12 @ @ ffi _ prep _ args _ raw ( char * stack , extended _ cif * ecif ) 
 
 for ( i = 0 ; i < cif - > nargs & & passed _ regs < = max _ regs ; i + + ) 
 { 
 + size _ t sz = cif - > arg _ types [ i ] - > size ; 
 + 
 if ( cif - > arg _ types [ i ] - > type = = FFI _ TYPE _ FLOAT 
 | | cif - > arg _ types [ i ] - > type = = FFI _ TYPE _ STRUCT ) 
 continue ; 
 
 - size _ t sz = cif - > arg _ types [ i ] - > size ; 
 if ( sz = = 0 | | sz > FFI _ SIZEOF _ ARG ) 
 continue ; 
 
 diff - - git a / native / libffi / src / x86 / ffitarget . h b / native / libffi / src / x86 / ffitarget . h 
 index a236677 . . ff0f718 100644 
 - - - a / native / libffi / src / x86 / ffitarget . h 
 + + + b / native / libffi / src / x86 / ffitarget . h 
 @ @ - 50 , 7 + 50 , 9 @ @ 
 # endif 
 
 # define FFI _ TARGET _ SPECIFIC _ STACK _ SPACE _ ALLOCATION 
 + # ifndef _ MSC _ VER 
 # define FFI _ TARGET _ HAS _ COMPLEX _ TYPE 
 + # endif 
 
 / * - - - - Generic type definitions - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / 
 
 diff - - git a / native / libffi / src / x86 / win64 . S b / native / libffi / src / x86 / win64 . S 
 index 687f97c . . 3f4981c 100644 
 - - - a / native / libffi / src / x86 / win64 . S 
 + + + b / native / libffi / src / x86 / win64 . S 
 @ @ - 170 , 7 + 170 , 7 @ @ ret _ uint16 $ : 
 	 mov 	 rcx , QWORD PTR RVALUE [ rbp ] 
 	 movzx rax , ax 
 	 mov 	 QWORD PTR [ rcx ] , rax 
 - 	 jmp 	 SHORT ret _ void $ 
 + 	 jmp 	 ret _ void $ ; too far with ' SHORT ' 
 
 ret _ sint16 $ : 
 	 cmp 	 DWORD PTR CIF _ FLAGS [ rbp ] , FFI _ TYPE _ SINT16 
 @ @ - 179 , 7 + 179 , 7 @ @ ret _ sint16 $ : 
 	 mov 	 rcx , QWORD PTR RVALUE [ rbp ] 
 	 movsx rax , ax 
 	 mov 	 QWORD PTR [ rcx ] , rax 
 - 	 jmp 	 SHORT ret _ void $ 
 + 	 jmp 	 ret _ void $ ; too far with ' SHORT ' 
 
 ret _ uint32 $ : 
 	 cmp 	 DWORD PTR CIF _ FLAGS [ rbp ] , FFI _ TYPE _ UINT32 
 diff - - git a / test / com / sun / jna / win32 / W32StdCallTest . java b / test / com / sun / jna / win32 / W32StdCallTest . java 
 index 087f3d2 . . 9389de6 100644 
 - - - a / test / com / sun / jna / win32 / W32StdCallTest . java 
 + + + b / test / com / sun / jna / win32 / W32StdCallTest . java 
 @ @ - 122 , 7 + 122 , 7 @ @ public class W32StdCallTest extends TestCase { 
 
 public void testStdCallReturnStructureByValueArgument ( ) { 
 TestLibrary . TestStructure . ByValue s = new TestLibrary . TestStructure . ByValue ( ) ; 
 - assertEquals ( " Wrong value " , s , testlib . returnStructureByValueArgumentStdCall ( s ) ) ; 
 + assertTrue ( " Wrong struct value " , s . dataEquals ( testlib . returnStructureByValueArgumentStdCall ( s ) ) ) ; 
 } 
 
 public void testStdCallCallback ( ) { 
 diff - - git a / www / WindowsDevelopmentEnvironment . md b / www / WindowsDevelopmentEnvironment . md 
 index 6076cb1 . . 2d237ac 100644 
 - - - a / www / WindowsDevelopmentEnvironment . md 
 + + + b / www / WindowsDevelopmentEnvironment . md 
 @ @ - 29 , 15 + 29 , 22 @ @ When installing cygwin , include ssh , git , make , autotools , and 
 mingw64 - gcc - core . Ensure the mingw64 compiler ( i686 - pc - mingw64 - gcc . exe ) is on 
 your path . 
 
 + MSVC 
 + - - - - 
 + 
 # # # # Visual Studio 
 
 - You can optionally use the free MS Visual Studio C + + Express compiler to compile 
 - native bits . The MS compiler provides structured event handling ( SEH ) , 
 - which allows JNA to trap native faults when run in protected mode . 
 + JNA uses the free MS Visual Studio C + + Express compiler to compile 
 + native bits if MSVC is set in the environment . The MS compiler provides 
 + structured event handling ( SEH ) , which allows JNA to trap native faults when 
 + run in protected mode . 
 + 
 + On 64 - bit windows , you will still need to install mingw64 - gcc - core in order to 
 + compile a small bit of inline assembly . 
 
 - To use the MS compiler , ensure that the 64 - bit versions of 
 - cl . exe / ml64 . exe / link . exe are in your PATH and that the INCLUDE and LIB 
 - environment variables are set properly ( as in VCVARS . BAT ) . 
 + To use the MS compiler , ensure that the appropriate 32 - bit or 64 - bit versions 
 + of cl . exe / ml . exe / ml64 . exe / link . exe are in your PATH and that the INCLUDE and 
 + LIB environment variables are set properly ( as in VCVARS . BAT ) . 
 
 Sample configuration setting up INCLUDE / LIB : 


NEAREST DIFF:
diff - - git a / libffi / ia64 / ffi . c b / libffi / ia64 / ffi . c 
 new file mode 100644 
 index 0000000 . . bb4fbb7 
 - - - / dev / null 
 + + + b / libffi / ia64 / ffi . c 
 @ @ - 0 , 0 + 1 , 670 @ @ 
 + / * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 + ffi . c - Copyright ( c ) 1998 Cygnus Solutions 
 + 	 Copyright ( c ) 2000 Hewlett Packard Company 
 + 
 + IA64 Foreign Function Interface 
 + 
 + Permission is hereby granted , free of charge , to any person obtaining 
 + a copy of this software and associated documentation files ( the 
 + ` ` Software ' ' ) , to deal in the Software without restriction , including 
 + without limitation the rights to use , copy , modify , merge , publish , 
 + distribute , sublicense , and / or sell copies of the Software , and to 
 + permit persons to whom the Software is furnished to do so , subject to 
 + the following conditions : 
 + 
 + The above copyright notice and this permission notice shall be included 
 + in all copies or substantial portions of the Software . 
 + 
 + THE SOFTWARE IS PROVIDED ` ` AS IS ' ' , WITHOUT WARRANTY OF ANY KIND , EXPRESS 
 + OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 + MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . 
 + IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM , DAMAGES OR 
 + OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , 
 + ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
 + OTHER DEALINGS IN THE SOFTWARE . 
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / 
 + 
 + # include < ffi . h > 
 + # include < ffi _ common . h > 
 + 
 + # include < stdlib . h > 
 + 
 + # include " ia64 _ flags . h " 
 + 
 + / * Memory image of fp register contents . Should eventually be an fp 	 * / 
 + / * type long enough to hold an entire register . For now we use double . 	 * / 
 + typedef double float80 ; 
 + 
 + / * The stack layout at call to ffi _ prep _ regs . Other _ args will remain 	 * / 
 + / * on the stack for the actual call . Everything else we be transferred 	 * / 
 + / * to registers and popped by the assembly code . 	 	 	 * / 
 + 
 + struct ia64 _ args { 
 + long scratch [ 2 ] ; 	 / * Two scratch words at top of stack . 	 	 * / 
 + 	 	 	 / * Allows sp to passed as arg pointer . 	 	 * / 
 + void * r8 _ contents ; 	 / * Value to be passed in r8 	 	 	 * / 
 + long spare ; 	 	 / * Not used . 	 	 	 	 	 * / 
 + float80 fp _ regs [ 8 ] ; / * Contents of 8 floating point argument 	 * / 
 + 	 	 	 / * registers . 	 	 	 	 	 * / 
 + long out _ regs [ 8 ] ; 	 / * Contents of the 8 out registers used 	 * / 
 + 	 	 	 / * for integer parameters . 	 	 	 * / 
 + long other _ args [ 0 ] ; / * Arguments passed on stack , variable size 	 * / 
 + 	 	 	 / * Treated as continuation of out _ regs . 	 	 * / 
 + } ; 
 + 
 + static size _ t float _ type _ size ( unsigned short tp ) 
 + { 
 + switch ( tp ) { 
 + case FFI _ TYPE _ FLOAT : 
 + return sizeof ( float ) ; 
 + case FFI _ TYPE _ DOUBLE : 
 + return sizeof ( double ) ; 
 + # if FFI _ TYPE _ LONGDOUBLE ! = FFI _ TYPE _ DOUBLE 
 + case FFI _ TYPE _ LONGDOUBLE : 
 + return sizeof ( long double ) ; 
 + # endif 
 + default : 
 + FFI _ ASSERT ( 0 ) ; 
 + } 
 + } 
 + 
 + / * 
 + * Is type a struct containing at most n floats , doubles , or extended 
 + * doubles , all of the same fp type ? 
 + * If so , set * element _ type to the fp type . 
 + * / 
 + static bool is _ homogeneous _ fp _ aggregate ( ffi _ type * type , int n , 
 + 	 	 	 	 unsigned short * element _ type ) 
 + { 
 + ffi _ type * * ptr ; 
 + unsigned short element , struct _ element ; 
 + 
 + int type _ set = 0 ; 
 + 
 + FFI _ ASSERT ( type ! = NULL ) ; 
 + 
 + FFI _ ASSERT ( type - > elements ! = NULL ) ; 
 + 
 + ptr = & ( type - > elements [ 0 ] ) ; 
 + 
 + while ( ( * ptr ) ! = NULL ) 
 + { 
 + switch ( ( * ptr ) - > type ) { 
 + 	 case FFI _ TYPE _ FLOAT : 
 + 	 if ( type _ set & & element ! = FFI _ TYPE _ FLOAT ) return 0 ; 
 + 	 if ( - - n < 0 ) return FALSE ; 
 + 	 type _ set = 1 ; 
 + 	 element = FFI _ TYPE _ FLOAT ; 
 + 	 break ; 
 + 	 case FFI _ TYPE _ DOUBLE : 
 + 	 if ( type _ set & & element ! = FFI _ TYPE _ DOUBLE ) return 0 ; 
 + 	 if ( - - n < 0 ) return FALSE ; 
 + 	 type _ set = 1 ; 
 + 	 element = FFI _ TYPE _ DOUBLE ; 
 + 	 break ; 
 + 	 case FFI _ TYPE _ STRUCT : 
 + 	 if ( ! is _ homogeneous _ fp _ aggregate ( type , n , & struct _ element ) ) 
 + 	 return FALSE ; 
 + 	 if ( type _ set & & struct _ element ! = element ) return FALSE ; 
 + 	 n - = ( type - > size ) / float _ type _ size ( element ) ; 
 + 	 element = struct _ element ; 
 + 	 if ( n < 0 ) return FALSE ; 
 + 	 break ; 
 + 	 / * case FFI _ TYPE _ LONGDOUBLE : 
 + 	 Not yet implemented . 	 * / 
 + 	 default : 
 + 	 return FALSE ; 
 + } 
 + ptr + + ; 
 + } 
 + * element _ type = element ; 
 + return TRUE ; 
 + 
 + } 
 + 
 + / * ffi _ prep _ args is called by the assembly routine once stack space 
 + has been allocated for the function ' s arguments . Returns nonzero 
 + if fp registers are used for arguments . * / 
 + 
 + static bool 
 + ffi _ prep _ args ( struct ia64 _ args * stack , extended _ cif * ecif , int bytes ) 
 + { 
 + register long i , avn ; 
 + register void * * p _ argv ; 
 + register long * argp = stack - > out _ regs ; 
 + register float80 * fp _ argp = stack - > fp _ regs ; 
 + register ffi _ type * * p _ arg ; 
 + 
 + / * For big return structs , r8 needs to contain the target address . 	 * / 
 + / * Since r8 is otherwise dead , we set it unconditionally . 	 	 * / 
 + stack - > r8 _ contents = ecif - > rvalue ; 
 + i = 0 ; 
 + avn = ecif - > cif - > nargs ; 
 + p _ arg = ecif - > cif - > arg _ types ; 
 + p _ argv = ecif - > avalue ; 
 + while ( i < avn ) 
 + { 
 + size _ t z ; / * z is in units of arg slots or words , not bytes . 	 * / 
 + 
 + switch ( ( * p _ arg ) - > type ) 
 + 	 { 
 + 	 case FFI _ TYPE _ SINT8 : 
 + 	 z = 1 ; 
 + 	 * ( SINT64 * ) argp = * ( SINT8 * ) ( * p _ argv ) ; 
 + 	 break ; 
 + 	 	 
 + 	 case FFI _ TYPE _ UINT8 : 
 + 	 z = 1 ; 
 + 	 * ( UINT64 * ) argp = * ( UINT8 * ) ( * p _ argv ) ; 
 + 	 break ; 
 + 	 	 
 + 	 case FFI _ TYPE _ SINT16 : 
 + 	 z = 1 ; 
 + 	 * ( SINT64 * ) argp = * ( SINT16 * ) ( * p _ argv ) ; 
 + 	 break ; 
 + 	 	 
 + 	 case FFI _ TYPE _ UINT16 : 
 + 	 z = 1 ; 
 + 	 * ( UINT64 * ) argp = * ( UINT16 * ) ( * p _ argv ) ; 
 + 	 break ; 
 + 	 	 
 + 	 case FFI _ TYPE _ SINT32 : 
 + 	 z = 1 ; 
 + 	 * ( SINT64 * ) argp = * ( SINT32 * ) ( * p _ argv ) ; 
 + 	 break ; 
 + 	 	 
 + 	 case FFI _ TYPE _ UINT32 : 
 + 	 z = 1 ; 
 + 	 * ( UINT64 * ) argp = * ( UINT32 * ) ( * p _ argv ) ; 
 + 	 break ; 
 + 
 + 	 case FFI _ TYPE _ SINT64 : 
 + 	 case FFI _ TYPE _ UINT64 : 
 + 	 case FFI _ TYPE _ POINTER : 
 + 	 z = 1 ; 
 + 	 * ( UINT64 * ) argp = * ( UINT64 * ) ( * p _ argv ) ; 
 + 	 break ; 
 + 
 + 	 case FFI _ TYPE _ FLOAT : 
 + 	 z = 1 ; 
 + 	 if ( fp _ argp - stack - > fp _ regs < 8 ) 
 + 	 { 
 + 	 / * Note the conversion - - all the fp regs are loaded as 
 + 	 	 doubles . * / 
 + 	 * fp _ argp + + = * ( float * ) ( * p _ argv ) ; 
 + 	 } 
 + 	 / * Also put it into the integer registers or memory : * / 
 + 	 * ( UINT64 * ) argp = * ( UINT32 * ) ( * p _ argv ) ; 
 + 	 break ; 
 + 
 + 	 case FFI _ TYPE _ DOUBLE : 
 + 	 z = 1 ; 
 + 	 if ( fp _ argp - stack - > fp _ regs < 8 ) 
 + 	 * fp _ argp + + = * ( double * ) ( * p _ argv ) ; 
 + 	 / * Also put it into the integer registers or memory : * / 
 + 	 * ( double * ) argp = * ( double * ) ( * p _ argv ) ; 
 + 	 break ; 
 + 
 + 	 case FFI _ TYPE _ STRUCT : 
 + 	 { 
 + 	 size _ t sz = ( * p _ arg ) - > size ; 
 + 	 unsigned short element _ type ; 
 + z = ( ( * p _ arg ) - > size + SIZEOF _ ARG - 1 ) / SIZEOF _ ARG ; 
 + 	 if ( is _ homogeneous _ fp _ aggregate ( * p _ arg , 8 , & element _ type ) ) { 
 + 	 	 int i ; 
 + 	 	 int nelements = sz / float _ type _ size ( element _ type ) ; 
 + 	 	 for ( i = 0 ; i < nelements ; + + i ) { 
 + 	 	 switch ( element _ type ) { 
 + 	 	 case FFI _ TYPE _ FLOAT : 
 + 	 	 if ( fp _ argp - stack - > fp _ regs < 8 ) 
 + 	 	 	 * fp _ argp + + = ( ( float * ) ( * p _ argv ) ) [ i ] ; 
 + 	 	 break ; 
 + 	 	 case FFI _ TYPE _ DOUBLE : 
 + 	 	 if ( fp _ argp - stack - > fp _ regs < 8 ) 
 + 	 	 	 * fp _ argp + + = ( ( double * ) ( * p _ argv ) ) [ i ] ; 
 + 	 	 break ; 
 + 	 	 default : 
 + 	 	 	 / * Extended precision not yet implemented . * / 
 + 	 	 	 abort ( ) ; 
 + 	 	 } 
 + 	 	 } 
 + 	 } 
 + 	 / * And pass it in integer registers as a struct , with 	 * / 
 + 	 / * its actual field sizes packed into registers . 	 	 * / 
 + 	 memcpy ( argp , * p _ argv , ( * p _ arg ) - > size ) ; 
 + 	 } 
 + 	 break ; 
 + 
 + 	 default : 
 + 	 FFI _ ASSERT ( 0 ) ; 
 + 	 } 
 + 
 + argp + = z ; 
 + i + + , p _ arg + + , p _ argv + + ; 
 + } 
 + return ( fp _ argp ! = stack - > fp _ regs ) ; 
 + } 
 + 
 + / * Perform machine dependent cif processing * / 
 + ffi _ status 
 + ffi _ prep _ cif _ machdep ( ffi _ cif * cif ) 
 + { 
 + long i , avn ; 
 + bool is _ simple = TRUE ; 
 + long simple _ flag = FFI _ SIMPLE _ V ; 
 + / * Adjust cif - > bytes to include space for the 2 scratch words , 
 + r8 register contents , spare word , 
 + the 8 fp register contents , and all 8 integer register contents . 
 + This will be removed before the call , though 2 scratch words must 
 + remain . * / 
 + 
 + cif - > bytes + = 4 * sizeof ( long ) + 8 * sizeof ( float80 ) ; 
 + if ( cif - > bytes < sizeof ( struct ia64 _ args ) ) 
 + cif - > bytes = sizeof ( struct ia64 _ args ) ; 
 + 
 + / * The stack must be double word aligned , so round bytes up 
 + appropriately . * / 
 + 
 + cif - > bytes = ALIGN ( cif - > bytes , 2 * sizeof ( void * ) ) ; 
 + 
 + avn = cif - > nargs ; 
 + if ( avn < = 2 ) { 
 + for ( i = 0 ; i < avn ; + + i ) { 
 + switch ( cif - > arg _ types [ i ] - > type ) { 
 + 	 case FFI _ TYPE _ SINT32 : 
 + 	 simple _ flag = FFI _ ADD _ INT _ ARG ( simple _ flag ) ; 
 + 	 break ; 
 + 	 case FFI _ TYPE _ SINT64 : 
 + 	 case FFI _ TYPE _ UINT64 : 
 + 	 case FFI _ TYPE _ POINTER : 
 + 	 simple _ flag = FFI _ ADD _ LONG _ ARG ( simple _ flag ) ; 
 + 	 break ; 
 + 	 default : 
 + 	 is _ simple = FALSE ; 
 + } 
 + } 
 + } else { 
 + is _ simple = FALSE ; 
 + } 
 + 
 + / * Set the return type flag * / 
 + switch ( cif - > rtype - > type ) 
 + { 
 + case FFI _ TYPE _ VOID : 
 + cif - > flags = FFI _ TYPE _ VOID ; 
 + break ; 
 + 
 + case FFI _ TYPE _ STRUCT : 
 + { 
 + size _ t sz = cif - > rtype - > size ; 
 + 	 unsigned short element _ type ; 
 + 
 + 	 is _ simple = FALSE ; 
 + 	 if ( is _ homogeneous _ fp _ aggregate ( cif - > rtype , 8 , & element _ type ) ) { 
 + 	 int nelements = sz / float _ type _ size ( element _ type ) ; 
 + 	 if ( nelements < = 1 ) { 
 + 	 if ( 0 = = nelements ) { 
 + 	 cif - > flags = FFI _ TYPE _ VOID ; 
 + 	 } else { 
 + 	 cif - > flags = element _ type ; 
 + 	 } 
 + 	 } else { 
 + 	 switch ( element _ type ) { 
 + 	 case FFI _ TYPE _ FLOAT : 
 + 	 cif - > flags = FFI _ IS _ FLOAT _ FP _ AGGREGATE | nelements ; 
 + 	 	 break ; 
 + 	 case FFI _ TYPE _ DOUBLE : 
 + 	 cif - > flags = FFI _ IS _ DOUBLE _ FP _ AGGREGATE | nelements ; 
 + 	 	 break ; 
 + 	 default : 
 + 	 	 / * long double NYI * / 
 + 	 	 abort ( ) ; 
 + 	 } 
 + 	 } 
 + 	 break ; 
 + } 
 + if ( sz < = 32 ) { 
 + 	 if ( sz < = 8 ) { 
 + cif - > flags = FFI _ TYPE _ INT ; 
 + 	 } else if ( sz < = 16 ) { 
 + cif - > flags = FFI _ IS _ SMALL _ STRUCT2 ; 
 + 	 } else if ( sz < = 24 ) { 
 + cif - > flags = FFI _ IS _ SMALL _ STRUCT3 ; 
 + 	 } else { 
 + cif - > flags = FFI _ IS _ SMALL _ STRUCT4 ; 
 + 	 } 
 + } else { 
 + cif - > flags = FFI _ TYPE _ STRUCT ; 
 + 	 } 
 + } 
 + break ; 
 + 
 + case FFI _ TYPE _ FLOAT : 
 + is _ simple = FALSE ; 
 + cif - > flags = FFI _ TYPE _ FLOAT ; 
 + break ; 
 + 
 + case FFI _ TYPE _ DOUBLE : 
 + is _ simple = FALSE ; 
 + cif - > flags = FFI _ TYPE _ DOUBLE ; 
 + break ; 
 + 
 + default : 
 + cif - > flags = FFI _ TYPE _ INT ; 
 + / * This seems to depend on little endian mode , and the fact that 	 * / 
 + / * the return pointer always points to at least 8 bytes . But 	 * / 
 + / * that also seems to be true for other platforms . 	 	 * / 
 + break ; 
 + } 
 + 
 + if ( is _ simple ) cif - > flags | = simple _ flag ; 
 + return FFI _ OK ; 
 + } 
 + 
 + extern int ffi _ call _ unix ( bool ( * ) ( struct ia64 _ args * , extended _ cif * , int ) , 
 + 	 	 	 extended _ cif * , unsigned , 
 + 	 	 	 unsigned , unsigned * , void ( * ) ( ) ) ; 
 + 
 + void 
 + ffi _ call ( ffi _ cif * cif , void ( * fn ) ( ) , void * rvalue , void * * avalue ) 
 + { 
 + extended _ cif ecif ; 
 + long simple = cif - > flags & FFI _ SIMPLE ; 
 + 
 + / * Should this also check for Unix ABI ? * / 
 + / * This is almost , but not quite , machine independent . Note that 	 * / 
 + / * we can get away with not caring about length of the result because 	 * / 
 + / * we assume we are little endian , and the result buffer is large 	 * / 
 + / * enough . 	 	 	 	 	 	 	 	 * / 
 + / * This needs work for HP / UX . 	 	 	 	 	 	 * / 
 + if ( simple ) { 
 + long ( * lfn ) ( ) = ( long ( * ) ( ) ) fn ; 
 + long result ; 
 + switch ( simple ) { 
 + case FFI _ SIMPLE _ V : 
 + 	 result = lfn ( ) ; 
 + 	 break ; 
 + case FFI _ SIMPLE _ I : 
 + 	 result = lfn ( * ( int * ) avalue [ 0 ] ) ; 
 + 	 break ; 
 + case FFI _ SIMPLE _ L : 
 + 	 result = lfn ( * ( long * ) avalue [ 0 ] ) ; 
 + 	 break ; 
 + case FFI _ SIMPLE _ II : 
 + 	 result = lfn ( * ( int * ) avalue [ 0 ] , * ( int * ) avalue [ 1 ] ) ; 
 + 	 break ; 
 + case FFI _ SIMPLE _ IL : 
 + 	 result = lfn ( * ( int * ) avalue [ 0 ] , * ( long * ) avalue [ 1 ] ) ; 
 + 	 break ; 
 + case FFI _ SIMPLE _ LI : 
 + 	 result = lfn ( * ( long * ) avalue [ 0 ] , * ( int * ) avalue [ 1 ] ) ; 
 + 	 break ; 
 + case FFI _ SIMPLE _ LL : 
 + 	 result = lfn ( * ( long * ) avalue [ 0 ] , * ( long * ) avalue [ 1 ] ) ; 
 + 	 break ; 
 + } 
 + if ( ( cif - > flags & ~ FFI _ SIMPLE ) ! = FFI _ TYPE _ VOID & & 0 ! = rvalue ) { 
 + * ( long * ) rvalue = result ; 
 + } 
 + return ; 
 + } 
 + ecif . cif = cif ; 
 + ecif . avalue = avalue ; 
 + 
 + / * If the return value is a struct and we don ' t have a return 
 + value address then we need to make one . * / 
 + 
 + if ( rvalue = = NULL & & cif - > rtype - > type = = FFI _ TYPE _ STRUCT ) 
 + ecif . rvalue = alloca ( cif - > rtype - > size ) ; 
 + else 
 + ecif . rvalue = rvalue ; 
 + 
 + switch ( cif - > abi ) 
 + { 
 + case FFI _ UNIX : 
 + ffi _ call _ unix ( ffi _ prep _ args , & ecif , cif - > bytes , 
 + 	 	 cif - > flags , rvalue , fn ) ; 
 + break ; 
 + 
 + default : 
 + FFI _ ASSERT ( 0 ) ; 
 + break ; 
 + } 
 + } 
 + 
 + / * 
 + * Closures represent a pair consisting of a function pointer , and 
 + * some user data . A closure is invoked by reinterpreting the closure 
 + * as a function pointer , and branching to it . Thus we can make an 
 + * interpreted function callable as a C function : We turn the interpreter 
 + * itself , together with a pointer specifying the interpreted procedure , 
 + * into a closure . 
 + * On X86 , the first few words of the closure structure actually contain code , 
 + * which will do the right thing . On most other architectures , this 
 + * would raise some Icache / Dcache coherence issues ( which can be solved , but 
 + * often not cheaply ) . 
 + * For IA64 , function pointer are already pairs consisting of a code 
 + * pointer , and a gp pointer . The latter is needed to access global variables . 
 + * Here we set up such a pair as the first two words of the closure ( in 
 + * the " trampoline " area ) , but we replace the gp pointer with a pointer 
 + * to the closure itself . We also add the real gp pointer to the 
 + * closure . This allows the function entry code to both retrieve the 
 + * user data , and to restire the correct gp pointer . 
 + * / 
 + 
 + static void 
 + ffi _ prep _ incoming _ args _ UNIX ( struct ia64 _ args * args , void * * rvalue , 
 + 	 	 	 void * * avalue , ffi _ cif * cif ) ; 
 + 
 + / * This function is entered with the doctored gp ( r1 ) value . 
 + * This code is extremely gcc specific . There is some argument that 
 + * it should really be written in assembly code , since it depends on 
 + * gcc properties that might change over time . 
 + * / 
 + 
 + / * ffi _ closure _ UNIX is an assembly routine , which copies the register 	 * / 
 + / * state into s struct ia64 _ args , and the invokes 	 	 	 * / 
 + / * ffi _ closure _ UNIX _ inner . It also recovers the closure pointer 	 * / 
 + / * from its fake gp pointer . 	 	 	 	 	 	 * / 
 + void ffi _ closure _ UNIX ( ) ; 
 + 
 + # ifndef _ _ GNUC _ _ 
 + # error This requires gcc 
 + # endif 
 + void 
 + ffi _ closure _ UNIX _ inner ( ffi _ closure * closure , struct ia64 _ args * args ) 
 + / * Hopefully declarint this as a varargs function will force all args 	 * / 
 + / * to memory . 	 	 	 	 	 	 	 	 * / 
 + { 
 + / / this is our return value storage 
 + long double res ; 
 + 
 + / / our various things . . . 
 + ffi _ cif * cif ; 
 + unsigned short rtype ; 
 + void * resp ; 
 + void 	 	 * * arg _ area ; 
 + 
 + resp = ( void * ) & res ; 
 + cif = closure - > cif ; 
 + arg _ area = ( void * * ) alloca ( cif - > nargs * sizeof ( void * ) ) ; 
 + 
 + / * this call will initialize ARG _ AREA , such that each 
 + * element in that array points to the corresponding 
 + * value on the stack ; and if the function returns 
 + * a structure , it will re - set RESP to point to the 
 + * structure return address . * / 
 + 
 + ffi _ prep _ incoming _ args _ UNIX ( args , ( void * * ) & resp , arg _ area , cif ) ; 
 + 
 + ( closure - > fun ) ( cif , resp , arg _ area , closure - > user _ data ) ; 
 + 
 + rtype = cif - > flags ; 
 + 
 + / * now , do a generic return based on the value of rtype * / 
 + if ( rtype = = FFI _ TYPE _ INT ) 
 + { 
 + asm volatile ( " ld8 r8 = [ % 0 ] " : : " r " ( resp ) : " r8 " ) ; 
 + } 
 + else if ( rtype = = FFI _ TYPE _ FLOAT ) 
 + { 
 + asm volatile ( " ldfs f8 = [ % 0 ] " : : " r " ( resp ) : " f8 " ) ; 
 + } 
 + else if ( rtype = = FFI _ TYPE _ DOUBLE ) 
 + { 
 + asm volatile ( " ldfd f8 = [ % 0 ] " : : " r " ( resp ) : " f8 " ) ; 
 + } 
 + else if ( rtype = = FFI _ IS _ SMALL _ STRUCT2 ) 
 + { 
 + asm volatile ( " ld8 r8 = [ % 0 ] ; ld8 r9 = [ % 1 ] " 
 + 	 	 : : " r " ( resp ) , " r " ( resp + 8 ) : " r8 " , " r9 " ) ; 
 + } 
 + else if ( rtype = = FFI _ IS _ SMALL _ STRUCT3 ) 
 + { 
 + asm volatile ( " ld8 r8 = [ % 0 ] ; ld8 r9 = [ % 1 ] ; ld8 r10 = [ % 2 ] " 
 + 	 	 : : " r " ( resp ) , " r " ( resp + 8 ) , " r " ( resp + 16 ) 
 + 	 	 : " r8 " , " r9 " , " r10 " ) ; 
 + } 
 + else if ( rtype = = FFI _ IS _ SMALL _ STRUCT4 ) 
 + { 
 + asm volatile ( " ld8 r8 = [ % 0 ] ; ld8 r9 = [ % 1 ] ; ld8 r10 = [ % 2 ] ; ld8 r11 = [ % 3 ] " 
 + 	 	 : : " r " ( resp ) , " r " ( resp + 8 ) , " r " ( resp + 16 ) , " r " ( resp + 24 ) 
 + 	 	 : " r8 " , " r9 " , " r10 " , " r11 " ) ; 
 + } 
 + else if ( rtype ! = FFI _ TYPE _ VOID & & rtype ! = FFI _ TYPE _ STRUCT ) 
 + { 
 + / * Can only happen for homogeneous FP aggregates ? 	 * / 
 + abort ( ) ; 
 + } 
 + } 
 + 
 + static void 
 + ffi _ prep _ incoming _ args _ UNIX ( struct ia64 _ args * args , void * * rvalue , 
 + 	 	 	 void * * avalue , ffi _ cif * cif ) 
 + { 
 + register unsigned int i ; 
 + register unsigned int avn ; 
 + register void * * p _ argv ; 
 + register unsigned long * argp = args - > out _ regs ; 
 + unsigned fp _ reg _ num = 0 ; 
 + register ffi _ type * * p _ arg ; 
 + 
 + avn = cif - > nargs ; 
 + p _ argv = avalue ; 
 + 
 + for ( i = cif - > nargs , p _ arg = cif - > arg _ types ; i ! = 0 ; i - - , p _ arg + + ) 
 + { 
 + size _ t z ; / * In units of words or argument slots . 	 * / 
 + 
 + switch ( ( * p _ arg ) - > type ) 
 + 	 { 
 + 	 case FFI _ TYPE _ SINT8 : 
 + 	 case FFI _ TYPE _ UINT8 : 
 + 	 case FFI _ TYPE _ SINT16 : 
 + 	 case FFI _ TYPE _ UINT16 : 
 + 	 case FFI _ TYPE _ SINT32 : 
 + 	 case FFI _ TYPE _ UINT32 : 
 + 	 case FFI _ TYPE _ SINT64 : 
 + 	 case FFI _ TYPE _ UINT64 : 
 + 	 case FFI _ TYPE _ POINTER : 
 + 	 z = 1 ; 
 + 	 * p _ argv = ( void * ) argp ; 
 + 	 break ; 
 + 	 	 
 + 	 case FFI _ TYPE _ FLOAT : 
 + 	 z = 1 ; 
 + 	 / * Convert argument back to float in place from the saved value * / 
 + 	 if ( fp _ reg _ num < 8 ) { 
 + 	 * ( float * ) argp = args - > fp _ regs [ fp _ reg _ num + + ] ; 
 + 	 } else { 
 + 	 * ( float * ) argp = * ( double * ) argp ; 
 + 	 } 
 + 	 * p _ argv = ( void * ) argp ; 
 + 	 break ; 
 + 
 + 	 case FFI _ TYPE _ DOUBLE : 
 + 	 z = 1 ; 
 + 	 if ( fp _ reg _ num < 8 ) { 
 + 	 * p _ argv = args - > fp _ regs + fp _ reg _ num + + ; 
 + 	 } else { 
 + 	 * p _ argv = ( void * ) argp ; 
 + 	 } 
 + 	 break ; 
 + 
 + 	 case FFI _ TYPE _ STRUCT : 
 + 	 { 
 + 	 size _ t sz = ( * p _ arg ) - > size ; 
 + 	 unsigned short element _ type ; 
 + z = ( ( * p _ arg ) - > size + SIZEOF _ ARG - 1 ) / SIZEOF _ ARG ; 
 + 	 if ( is _ homogeneous _ fp _ aggregate ( * p _ arg , 8 , & element _ type ) ) { 
 + 	 	 int nelements = sz / float _ type _ size ( element _ type ) ; 
 + 	 	 if ( nelements + fp _ reg _ num > = 8 ) { 
 + 	 	 / * hard case NYI . 	 * / 
 + 	 	 abort ( ) ; 
 + 	 	 } 
 + 	 	 if ( element _ type = = FFI _ TYPE _ DOUBLE ) { 
 + 	 * p _ argv = args - > fp _ regs + fp _ reg _ num ; 
 + 	 	 fp _ reg _ num + = nelements ; 
 + 	 	 break ; 
 + 	 	 } 
 + 	 	 if ( element _ type = = FFI _ TYPE _ FLOAT ) { 
 + 	 	 int j ; 
 + 	 	 for ( j = 0 ; j < nelements ; + + j ) { 
 + 	 	 ( ( float * ) argp ) [ j ] = args - > fp _ regs [ fp _ reg _ num + j ] ; 
 + 	 	 } 
 + 	 * p _ argv = ( void * ) argp ; 
 + 	 	 fp _ reg _ num + = nelements ; 
 + 	 	 break ; 
 + 	 	 } 
 + 	 	 abort ( ) ; / * Other fp types NYI * / 
 + 	 } 
 + 	 } 
 + 	 break ; 
 + 
 + 	 default : 
 + 	 FFI _ ASSERT ( 0 ) ; 
 + 	 } 
 + 
 + argp + = z ; 
 + p _ argv + + ; 
 + 
 + } 
 + 
 + return ; 
 + } 
 + 
 + 
 + / * Fill in a closure to refer to the specified fun and user _ data . 	 * / 
 + / * cif specifies the argument and result types for fun . 	 	 	 * / 
 + / * the cif must already be prep ' ed * / 
 + 
 + / * The layout of a function descriptor . A C function pointer really 	 * / 
 + / * points to one of these . 	 	 	 	 	 	 * / 
 + typedef struct ia64 _ fd _ struct { 
 + void * code _ pointer ; 
 + void * gp ; 
 + } ia64 _ fd ; 
 + 
 + ffi _ status 
 + ffi _ prep _ closure ( ffi _ closure * closure , 
 + 	 	 ffi _ cif * cif , 
 + 	 	 void ( * fun ) ( ffi _ cif * , void * , void * * , void * ) , 
 + 	 	 void * user _ data ) 
 + { 
 + struct ffi _ ia64 _ trampoline _ struct * tramp = 
 + ( struct ffi _ ia64 _ trampoline _ struct * ) ( closure - > tramp ) ; 
 + ia64 _ fd * fd = ( ia64 _ fd * ) ( void * ) ffi _ closure _ UNIX ; 
 + 
 + FFI _ ASSERT ( cif - > abi = = FFI _ UNIX ) ; 
 + 
 + tramp - > code _ pointer = fd - > code _ pointer ; 
 + tramp - > real _ gp = fd - > gp ; 
 + tramp - > fake _ gp = closure ; 
 + closure - > cif = cif ; 
 + closure - > user _ data = user _ data ; 
 + closure - > fun = fun ; 
 + 
 + return FFI _ OK ; 
 + } 
 + 
 + 
 diff - - git a / libffi / ia64 / ia64 _ flags . h b / libffi / ia64 / ia64 _ flags . h 
 new file mode 100644 
 index 0000000 . . 23dbd3e 
 - - - / dev / null 
 + + + b / libffi / ia64 / ia64 _ flags . h 
 @ @ - 0 , 0 + 1 , 62 @ @ 
 + / * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 + ia64 _ flags . h - Copyright ( c ) 2000 Hewlett Packard Company 
 + 
 + IA64 / unix Foreign Function Interface 
 + 
 + Original author : Hans Boehm , HP Labs 
 + 
 + Permission is hereby granted , free of charge , to any person obtaining 
 + a copy of this software and associated documentation files ( the 
 + ` ` Software ' ' ) , to deal in the Software without restriction , including 
 + without limitation the rights to use , copy , modify , merge , publish , 
 + distribute , sublicense , and / or sell copies of the Software , and to 
 + permit persons to whom the Software is furnished to do so , subject to 
 + the following conditions : 
 + 
 + The above copyright notice and this permission notice shall be included 
 + in all copies or substantial portions of the Software . 
 + 
 + THE SOFTWARE IS PROVIDED ` ` AS IS ' ' , WITHOUT WARRANTY OF ANY KIND , EXPRESS 
 + OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 + MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . 
 + IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM , DAMAGES OR 
 + OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , 
 + ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
 + OTHER DEALINGS IN THE SOFTWARE . 
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / 
 + 
 + 
 + / * Homogeneous Floating Point Aggregates ( HFAs ) which are returned 	 * / 
 + / * in FP registers . The least significant bits specify the size in 	 * / 
 + / * words . 	 	 	 	 	 	 	 	 * / 
 + # define FFI _ IS _ FLOAT _ FP _ AGGREGATE 0x1000 
 + # define FFI _ IS _ DOUBLE _ FP _ AGGREGATE 0x0800 
 + # define FLOAT _ FP _ AGGREGATE _ BIT 12 
 + # define DOUBLE _ FP _ AGGREGATE _ BIT 11 
 + 
 + / * Small structures containing N words . If N = 1 , they are returned 	 * / 
 + / * as though they were integers . 	 	 	 	 	 * / 
 + # define FFI _ IS _ SMALL _ STRUCT2 	 0x40 / * Struct > 8 , < = 16 bytes 	 * / 
 + # define FFI _ IS _ SMALL _ STRUCT3 	 0x41 / * Struct > 16 < = 24 bytes 	 * / 
 + # define FFI _ IS _ SMALL _ STRUCT4 	 0x42 / * Struct > 24 , < = 32 bytes 	 * / 
 + 
 + / * Flag values identifying particularly simple cases , which are 	 * / 
 + / * handled specially . We treat functions as simple if they take all 	 * / 
 + / * arguments can be passed as 32 or 64 bit integer quantities , there is 	 * / 
 + / * either no return value or it can be treated as a 64bit integer , and 	 * / 
 + / * if there are at most 2 arguments . 	 	 	 	 	 * / 
 + / * This is OR ' ed with the normal flag values . 	 	 	 	 * / 
 + # define FFI _ SIMPLE _ V 0x10000 	 / * ( ) - > X 	 * / 
 + # define FFI _ SIMPLE _ I 0x20000 	 / * ( int ) - > X 	 * / 
 + # define FFI _ SIMPLE _ L 0x30000 	 / * ( long ) - > X 	 * / 
 + # define FFI _ SIMPLE _ II 0x40000 	 / * ( int , int ) - > X 	 * / 
 + # define FFI _ SIMPLE _ IL 0x50000 	 / * ( int , long ) - > X 	 * / 
 + # define FFI _ SIMPLE _ LI 0x60000 	 / * ( long , int ) - > X 	 * / 
 + # define FFI _ SIMPLE _ LL 0x70000 	 / * ( long , long ) - > X 	 * / 
 + 
 + / * Mask for all of the FFI _ SIMPLE bits : 	 * / 
 + # define FFI _ SIMPLE 0xf0000 
 + 
 + / * An easy way to build FFI _ SIMPLE flags from FFI _ SIMPLE _ V : 	 * / 
 + # define FFI _ ADD _ LONG _ ARG ( flag ) ( ( ( flag ) < < 1 ) | 0x10000 ) 
 + # define FFI _ ADD _ INT _ ARG ( flag ) ( ( flag ) < < 1 ) 
 diff - - git a / libffi / ia64 / unix . S b / libffi / ia64 / unix . S 
 new file mode 100644 
 index 0000000 . . fdaf8be 
 - - - / dev / null 
 + + + b / libffi / ia64 / unix . S 
 @ @ - 0 , 0 + 1 , 301 @ @ 
 + / * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 + unix . S - Copyright ( c ) 1998 Cygnus Solutions 
 + Copyright ( c ) 2000 Hewlett Packard Company 
 + 
 + IA64 / unix Foreign Function Interface 
 + 
 + Primary author : Hans Boehm , HP Labs 
 + 
 + Loosely modeled on Cygnus code for other platforms . 
 + 
 + Permission is hereby granted , free of charge , to any person obtaining 
 + a copy of this software and associated documentation files ( the 
 + ` ` Software ' ' ) , to deal in the Software without restriction , including 
 + without limitation the rights to use , copy , modify , merge , publish , 
 + distribute , sublicense , and / or sell copies of the Software , and to 
 + permit persons to whom the Software is furnished to do so , subject to 
 + the following conditions : 
 + 
 + The above copyright notice and this permission notice shall be included 
 + in all copies or substantial portions of the Software . 
 + 
 + THE SOFTWARE IS PROVIDED ` ` AS IS ' ' , WITHOUT WARRANTY OF ANY KIND , EXPRESS 
 + OR IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 + MERCHANTABILITY , FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . 
 + IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM , DAMAGES OR 
 + OTHER LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , 
 + ARISING FROM , OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
 + OTHER DEALINGS IN THE SOFTWARE . 
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * / 
 + 
 + # define LIBFFI _ ASM 	 
 + # include < ffi . h > 
 + # include " ia64 _ flags . h " 
 + 
 + / * parameters : 	 * / 
 + # define callback 	 in0 
 + # define ecifp 	 	 in1 
 + # define bytes 	 	 in2 
 + # define flags 	 	 in3 
 + # define raddr 	 	 in4 
 + # define fn 	 	 in5 
 + 
 + # define FLOAT _ SZ 	 8 / * in - memory size of fp operands 	 * / 
 + 
 + . text 
 + . align 16 
 + . global ffi _ call _ unix # 
 + . proc ffi _ call _ unix # 
 + ffi _ call _ unix : 
 + 	 alloc loc0 = ar . pfs , 6 , 5 , 8 , 0 
 + 	 mov 	 loc1 = b0 ; 
 + 	 sub 	 sp = sp , bytes 
 + 	 mov 	 loc4 = r1 	 	 / * Save gp 	 * / 
 + 	 ld8 	 r8 = [ callback ] , 8 	 / * code address of callback 	 * / 
 + 	 ; ; 
 + 	 mov 	 out0 = sp 
 + 	 mov 	 out1 = ecifp 
 + 	 mov 	 out2 = bytes 
 + 	 ld8 	 r1 = [ callback ] 	 / * Set up gp for callback . Unnecessary ? * / 
 + 	 mov 	 b6 = r8 
 + 	 ; ; 
 + 	 br . call . sptk . many b0 = b6 	 / * call ffi _ prep _ args 	 	 * / 
 + 	 cmp . eq 	 p6 , p0 = 0 , r8 	 	 / * r8 nonzero = = > need fp regs 	 * / 
 + 	 ; ; 
 + ( p6 ) 	 add 	 loc2 = 32 + 8 * FLOAT _ SZ , sp 
 + ( p6 ) 	 br . cond . dptk . many 	 fp _ done 
 + 	 ; ; 	 / * Quiets warning ; needed ? 	 * / 
 + 	 add 	 loc2 = 32 , sp 
 + 	 add 	 loc3 = 32 + FLOAT _ SZ , sp 
 + 	 ; ; 
 + 	 ldfd 	 f8 = [ loc2 ] , 2 * FLOAT _ SZ 
 + 	 ldfd 	 f9 = [ loc3 ] , 2 * FLOAT _ SZ 
 + 	 ; ; 
 + 	 ldfd 	 f10 = [ loc2 ] , 2 * FLOAT _ SZ 
 + 	 ldfd 	 f11 = [ loc3 ] , 2 * FLOAT _ SZ 
 + 	 ; ; 
 + 	 ldfd 	 f12 = [ loc2 ] , 2 * FLOAT _ SZ 
 + 	 ldfd 	 f13 = [ loc3 ] , 2 * FLOAT _ SZ 
 + 	 ; ; 
 + 	 ldfd 	 f14 = [ loc2 ] , 2 * FLOAT _ SZ 
 + 	 ldfd 	 f15 = [ loc3 ] 
 + fp _ done : 
 + 	 add 	 r9 = 16 , sp 	 / * Pointer to r8 _ contents 	 * / 
 + 	 / * loc2 points at first integer register value . * / 
 + 	 add 	 loc3 = 8 , loc2 
 + 	 ; ; 
 + 	 ld8 	 r8 = [ r9 ] 	 	 / * Just in case we return large struct * / 
 + 	 ld8 	 out0 = [ loc2 ] , 16 
 + 	 ld8 	 out1 = [ loc3 ] , 16 
 + 	 ; ; 
 + 	 ld8 	 out2 = [ loc2 ] , 16 
 + 	 ld8 	 out3 = [ loc3 ] , 16 
 + 	 ; ; 
 + 	 ld8 	 out4 = [ loc2 ] , 16 
 + 	 ld8 	 out5 = [ loc3 ] , 16 
 + 	 ; ; 
 + 	 ld8 	 out6 = [ loc2 ] , 16 
 + 	 ld8 	 out7 = [ loc3 ] 
 + 	 / * loc2 points at first stack parameter . Set sp to 16 bytes 	 * / 
 + 	 / * below that . 	 	 	 	 	 	 	 * / 
 + 	 add 	 sp = - 16 , loc2 
 + 	 
 + 	 ld8 	 r8 = [ fn ] , 8 
 + 	 ; ; 
 + 	 ld8 	 r1 = [ fn ] 	 	 / * Set up gp * / 
 + 	 mov 	 b6 = r8 ; ; 
 + 	 br . call . sptk . many b0 = b6 	 / * call ffi _ prep _ args 	 * / 
 + 	 
 + 	 / * Handle return value . * / 
 + 	 cmp . eq 	 p6 , p0 = 0 , raddr 
 + 	 cmp . eq 	 p7 , p0 = FFI _ TYPE _ INT , flags 
 + 	 cmp . eq 	 p10 , p0 = FFI _ IS _ SMALL _ STRUCT2 , flags 
 + 	 cmp . eq 	 p11 , p0 = FFI _ IS _ SMALL _ STRUCT3 , flags 
 + 	 cmp . eq 	 p12 , p0 = FFI _ IS _ SMALL _ STRUCT4 , flags 
 + 	 ; ; 
 + ( p6 ) 	 br . cond . dpnt . few done 	 	 / * Dont copy ret values if raddr = 0 * / 
 + ( p7 ) 	 br . cond . dptk . few copy1 
 + ( p10 ) 	 br . cond . dpnt . few copy2 
 + ( p11 ) 	 br . cond . dpnt . few copy3 
 + ( p12 ) 	 br . cond . dpnt . few copy4 
 + 	 cmp . eq 	 p8 , p0 = FFI _ TYPE _ FLOAT , flags 
 + 	 cmp . eq 	 p9 , p0 = FFI _ TYPE _ DOUBLE , flags 
 + 	 tbit . nz 	 p6 , p0 = flags , FLOAT _ FP _ AGGREGATE _ BIT 
 + 	 tbit . nz 	 p7 , p0 = flags , DOUBLE _ FP _ AGGREGATE _ BIT 
 + 	 ; ; 
 + ( p8 ) 	 stfs 	 [ raddr ] = f8 
 + ( p9 ) 	 stfd 	 [ raddr ] = f8 
 + 	 ; ; 
 + ( p6 ) 	 br . cond . dpnt . few handle _ float _ hfa 
 + ( p7 ) 	 br . cond . dpnt . few handle _ double _ hfa 
 + 	 br done 
 + 
 + copy4 : 
 + 	 add 	 loc3 = 24 , raddr 
 + 	 ; ; 
 + 	 st8 	 [ loc3 ] = r11 
 + copy3 : 
 + 	 add 	 loc3 = 16 , raddr 
 + 	 ; ; 
 + 	 st8 	 [ loc3 ] = r10 
 + copy2 : 
 + 	 add 	 loc3 = 8 , raddr 
 + 	 ; ; 
 + 	 st8 	 [ loc3 ] = r9 
 + copy1 : 
 + 	 st8 	 [ raddr ] = r8 
 + 	 / * In the big struct case , raddr was passed as an argument . 	 * / 
 + 	 / * In the void case there was nothing to do . 	 	 	 * / 
 + 
 + done : 
 + 	 mov 	 r1 = loc4 	 	 / * Restore gp 	 * / 
 + 	 mov 	 ar . pfs = loc0 
 + 	 mov 	 b0 = loc1 
 + 	 br . ret . sptk . many b0 
 + 
 + handle _ double _ hfa : 
 + 	 / * Homogeneous floating point array of doubles is returned in 	 * / 
 + 	 / * registers f8 - f15 . Save one at a time to return area . 	 * / 
 + 	 and 	 flags = 0xf , flags 	 / * Retrieve size 	 * / 
 + 	 ; ; 
 + 	 cmp . eq 	 p6 , p0 = 2 , flags 
 + 	 cmp . eq 	 p7 , p0 = 3 , flags 
 + 	 cmp . eq 	 p8 , p0 = 4 , flags 
 + 	 cmp . eq 	 p9 , p0 = 5 , flags 
 + 	 cmp . eq 	 p10 , p0 = 6 , flags 
 + 	 cmp . eq 	 p11 , p0 = 7 , flags 
 + 	 cmp . eq 	 p12 , p0 = 8 , flags 
 + 	 ; ; 
 + ( p6 ) 	 br . cond . dptk . few 	 dhfa2 
 + ( p7 ) 	 br . cond . dptk . few 	 dhfa3 
 + ( p8 ) 	 br . cond . dptk . few 	 dhfa4 
 + ( p9 ) 	 br . cond . dptk . few 	 dhfa5 
 + ( p10 ) 	 br . cond . dptk . few 	 dhfa6 
 + ( p11 ) 	 br . cond . dptk . few 	 dhfa7 
 + dhfa8 : 	 add 	 loc3 = 7 * 8 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f15 
 + dhfa7 : 	 add 	 loc3 = 6 * 8 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f14 
 + dhfa6 : 	 add 	 loc3 = 5 * 8 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f13 
 + dhfa5 : 	 add 	 loc3 = 4 * 8 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f12 
 + dhfa4 : 	 add 	 loc3 = 3 * 8 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f11 
 + dhfa3 : 	 add 	 loc3 = 2 * 8 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f10 
 + dhfa2 : 	 add 	 loc3 = 1 * 8 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f9 
 + 	 stfd 	 [ raddr ] = f8 
 + 	 br 	 done 
 + 
 + handle _ float _ hfa : 
 + 	 / * Homogeneous floating point array of floats is returned in 	 * / 
 + 	 / * registers f8 - f15 . Save one at a time to return area . 	 * / 
 + 	 and 	 flags = 0xf , flags 	 / * Retrieve size 	 * / 
 + 	 ; ; 
 + 	 cmp . eq 	 p6 , p0 = 2 , flags 
 + 	 cmp . eq 	 p7 , p0 = 3 , flags 
 + 	 cmp . eq 	 p8 , p0 = 4 , flags 
 + 	 cmp . eq 	 p9 , p0 = 5 , flags 
 + 	 cmp . eq 	 p10 , p0 = 6 , flags 
 + 	 cmp . eq 	 p11 , p0 = 7 , flags 
 + 	 cmp . eq 	 p12 , p0 = 8 , flags 
 + 	 ; ; 
 + ( p6 ) 	 br . cond . dptk . few 	 shfa2 
 + ( p7 ) 	 br . cond . dptk . few 	 shfa3 
 + ( p8 ) 	 br . cond . dptk . few 	 shfa4 
 + ( p9 ) 	 br . cond . dptk . few 	 shfa5 
 + ( p10 ) 	 br . cond . dptk . few 	 shfa6 
 + ( p11 ) 	 br . cond . dptk . few 	 shfa7 
 + shfa8 : 	 add 	 loc3 = 7 * 4 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f15 
 + shfa7 : 	 add 	 loc3 = 6 * 4 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f14 
 + shfa6 : 	 add 	 loc3 = 5 * 4 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f13 
 + shfa5 : 	 add 	 loc3 = 4 * 4 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f12 
 + shfa4 : 	 add 	 loc3 = 3 * 4 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f11 
 + shfa3 : 	 add 	 loc3 = 2 * 4 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f10 
 + shfa2 : 	 add 	 loc3 = 1 * 4 , raddr 
 + 	 ; ; 
 + 	 stfd 	 [ loc3 ] = f9 
 + 	 stfd 	 [ raddr ] = f8 
 + 	 br 	 done 
 + 
 + . endp ffi _ call _ unix 
 + 
 + 
 + . text 
 + . align 16 
 + . global ffi _ closure _ UNIX 
 + . proc ffi _ closure _ UNIX 
 + ffi _ closure _ UNIX : 
 + 	 alloc loc0 = ar . pfs , 8 , 2 , 2 , 0 
 + 	 mov 	 loc1 = b0 
 + 	 / * Retrieve closure pointer and real gp . 	 * / 
 + 	 mov 	 out0 = gp 
 + 	 add 	 gp = 16 , gp 
 + 	 ; ; 
 + 	 ld8 	 gp = [ gp ] 
 + 	 / * Reserve a structia64 _ args on the stack such that arguments 	 * / 
 + 	 / * past the first 8 are automatically placed in the right 	 * / 
 + 	 / * slot . Note that when we start the sp points at 2 8 - byte 	 * / 
 + 	 / * scratch words , followed by the extra arguments . 	 	 * / 
 + # 	 define BASIC _ ARGS _ SZ ( 8 * FLOAT _ SZ + 8 * 8 + 2 * 8 ) 
 + # 	 define FIRST _ FP _ OFFSET ( 4 * 8 ) 
 + 	 add 	 r14 = - ( BASIC _ ARGS _ SZ - FIRST _ FP _ OFFSET ) , sp 
 + 	 add 	 r15 = - ( BASIC _ ARGS _ SZ - FIRST _ FP _ OFFSET - FLOAT _ SZ ) , sp 
 + 	 add 	 sp = - BASIC _ ARGS _ SZ , sp 
 + 	 / * r14 points to fp _ regs [ 0 ] , r15 points to fp _ regs [ 1 ] 	 * / 
 + 	 ; ; 
 + 	 stfd 	 [ r14 ] = f8 , 2 * FLOAT _ SZ 
 + 	 stfd 	 [ r15 ] = f9 , 2 * FLOAT _ SZ 
 + 	 ; ; 
 + 	 stfd 	 [ r14 ] = f10 , 2 * FLOAT _ SZ 
 + 	 stfd 	 [ r15 ] = f11 , 2 * FLOAT _ SZ 
 + 	 ; ; 
 + 	 stfd 	 [ r14 ] = f12 , 2 * FLOAT _ SZ 
 + 	 stfd 	 [ r15 ] = f13 , 2 * FLOAT _ SZ 
 + 	 ; ; 
 + 	 stfd 	 [ r14 ] = f14 , FLOAT _ SZ + 8 
 + 	 stfd 	 [ r15 ] = f15 , 2 * 8 
 + 	 ; ; 
 + 	 / * r14 points to first parameter register area , r15 to second . * / 
 + 	 st8 	 [ r14 ] = in0 , 2 * 8 
 + 	 st8 	 [ r15 ] = in1 , 2 * 8 
 + 	 ; ; 
 + 	 st8 	 [ r14 ] = in2 , 2 * 8 
 + 	 st8 	 [ r15 ] = in3 , 2 * 8 
 + 	 ; ; 
 + 	 st8 	 [ r14 ] = in4 , 2 * 8 
 + 	 st8 	 [ r15 ] = in5 , 2 * 8 
 + 	 ; ; 
 + 	 st8 	 [ r14 ] = in6 , 2 * 8 
 + 	 st8 	 [ r15 ] = in7 , 2 * 8 
 + 	 / * Call ffi _ closure _ UNIX _ inner * / 
 + 	 mov 	 out1 = sp 
 + 	 br . call . sptk . many b0 = ffi _ closure _ UNIX _ inner 
 + 	 ; ; 
 + 	 mov 	 b0 = loc1 
 + 	 mov 	 ar . pfs = loc0 
 + 	 br . ret . sptk . many b0 
 + 	 . endp ffi _ closure _ UNIX 
 + 	 
 +
