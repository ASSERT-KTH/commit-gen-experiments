BLEU SCORE: 0.015445276590783498

TEST MSG: add support for loading native libraries from classpath ( FS or jar )
GENERATED MSG: merge android branch

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index c2b0c30 . . 9381134 100755 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 5 , 6 + 5 , 7 @ @ Features <nl> - - - - - - - - <nl> * Basic [ COM support ] ( https : / / github . com / twall / jna / blob / master / www / PlatformLibrary . md ) for w32 - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . <nl> * Avoid superfluous Structure memory allocation by using Structure ( Pointer ) ctors if available - [ @ twall ] ( https : / / github . com / twall ) . <nl> + * [ PR # 120 ] ( https : / / github . com / twall / jna / pull / 120 ) : Provide methods for extracting native libraries from the class path for use by JNA - [ @ Zlika ] ( https : / / github . com / Zlika ) . <nl> * [ # 163 ] ( https : / / github . com / twall / jna / pull / 163 ) : The Java ` GUID ` structure can be used directly as alternative to ` Ole32Util . getGUIDFromString ( ) ` - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . <nl> * [ # 163 ] ( https : / / github . com / twall / jna / pull / 163 ) : Ported Win32 ` dbt . h ` - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . <nl> * [ # 163 ] ( https : / / github . com / twall / jna / pull / 163 ) : Added Win32 ` WTSRegisterSessionNotification ( ) ` and ` WTSUnRegisterSessionNotification ( ) ` from ` Wtsapi32 . dll ` - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . <nl> diff - - git a / build . xml b / build . xml <nl> index 19c4030 . . 798ec14 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 264 , 6 + 264 , 7 @ @ <nl> < path id = " test . runpath " > <nl> < pathelement path = " $ { build } / $ { jar } " / > <nl> < pathelement path = " $ { test . classes } " / > <nl> + < pathelement path = " $ { build } / $ { testjar } " / > <nl> < pathelement path = " lib / clover . jar " / > <nl> < path refid = " test . libs " / > <nl> < / path > <nl> @ @ - 708 , 12 + 709 , 28 @ @ osname = macos <nl> < src path = " $ { test . src } " / > <nl> < exclude name = " $ { tests . exclude } " / > <nl> < / javac > <nl> - < ! - - Create a jar for easy movement of tests - - > <nl> + < ! - - Move ( not copy ) embedded testlib to test class folder so that it will be - - > <nl> + < ! - - packaged into the test jar and NOT available in the FS - based class path - - > <nl> + < move todir = " $ { test . classes } / $ { os . prefix } " > <nl> + < fileset dir = " $ { build . native } " > <nl> + < patternset id = " embedded - testlib " > <nl> + < include name = " * * / * embedded - testlib * " / > <nl> + < / patternset > <nl> + < / fileset > <nl> + < / move > <nl> + < ! - - Create a jar for easy movement of tests , and embedded load test - - > <nl> < jar jarfile = " $ { build } / $ { testjar } " > <nl> < fileset dir = " $ { test . classes } " > <nl> < patternset refid = " jar - compiled " / > <nl> + < include name = " * * / * embedded - testlib * " / > <nl> < / fileset > <nl> < / jar > <nl> + < ! - - Ensure embedded library unavailable on FS - based class path - - > <nl> + < delete > <nl> + < fileset dir = " $ { test . classes } " > <nl> + < include name = " * * / * embedded - testlib * " / > <nl> + < / fileset > <nl> + < / delete > <nl> < mkdir dir = " $ { build } / jws " / > <nl> < copy todir = " $ { build } / jws " file = " $ { build } / $ { jar } " / > <nl> < copy todir = " $ { build } / jws " file = " $ { build } / $ { testjar } " / > <nl> diff - - git a / native / Makefile b / native / Makefile <nl> index 03fd09b . . 5a7ca43 100644 <nl> - - - a / native / Makefile <nl> + + + b / native / Makefile <nl> @ @ - 67 , 6 + 67 , 7 @ @ FFI _ CONFIG = - - enable - static - - disable - shared - - with - pic = yes <nl> endif <nl> LIBRARY = $ ( BUILD ) / $ ( LIBPFX ) jnidispatch $ ( JNISFX ) <nl> TESTLIB = $ ( BUILD ) / $ ( LIBPFX ) testlib $ ( LIBSFX ) <nl> + TESTLIB _ EMBEDDED = $ ( BUILD ) / $ ( LIBPFX ) embedded - testlib $ ( LIBSFX ) <nl> TESTLIB2 = $ ( BUILD ) / $ ( LIBPFX ) testlib2 $ ( LIBSFX ) <nl> <nl> # Reasonable defaults based on GCC <nl> @ @ - 308 , 6 + 309 , 7 @ @ LDFLAGS = $ ( ARCHFLAGS ) - dynamiclib - o $ @ - framework JavaVM \ <nl> - compatibility _ version $ ( shell echo $ { JNA _ JNI _ VERSION } | sed ' s / ^ \ ( [ 0 - 9 ] [ 0 - 9 ] * \ ) . * / \ 1 / g ' ) \ <nl> - current _ version $ ( JNA _ JNI _ VERSION ) \ <nl> - mmacosx - version - min = 10 . 3 \ <nl> + - framework Foundation \ <nl> - install _ name $ { @ F } \ <nl> $ ( SYSLIBROOT ) <nl> # JAWT linkage handled by - framework JavaVM <nl> @ @ - 329 , 7 + 331 , 7 @ @ else <nl> 	 $ ( CC ) $ ( CFLAGS ) - c $ < $ ( COUT ) <nl> endif <nl> <nl> - all : $ ( LIBRARY ) $ ( TESTLIB ) $ ( TESTLIB2 ) <nl> + all : $ ( LIBRARY ) $ ( TESTLIB ) $ ( TESTLIB2 ) $ ( TESTLIB _ EMBEDDED ) <nl> <nl> install : <nl> 	 mkdir $ ( INSTALLDIR ) <nl> @ @ - 349 , 6 + 351 , 9 @ @ $ ( LIBRARY ) : $ ( JNIDISPATCH _ OBJS ) $ ( FFI _ LIB ) <nl> $ ( TESTLIB ) : $ ( BUILD ) / testlib . o <nl> 	 $ ( LD ) $ ( LDFLAGS ) $ < $ ( LIBS ) <nl> <nl> + $ ( TESTLIB _ EMBEDDED ) : $ ( BUILD ) / testlib . o <nl> + 	 $ ( LD ) $ ( LDFLAGS ) $ < $ ( LIBS ) <nl> + <nl> ifeq ( $ ( ARSFX ) , . lib ) <nl> TESTDEP = $ ( TESTLIB : . dll = . lib ) <nl> else <nl> diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java <nl> index 8f1950b . . 9be443e 100644 <nl> - - - a / src / com / sun / jna / Native . java <nl> + + + b / src / com / sun / jna / Native . java <nl> @ @ - 16 , 13 + 16 , 9 @ @ import java . awt . Component ; <nl> import java . awt . GraphicsEnvironment ; <nl> import java . awt . HeadlessException ; <nl> import java . awt . Window ; <nl> - <nl> - import java . nio . Buffer ; <nl> - import java . nio . ByteBuffer ; <nl> - <nl> import java . io . File ; <nl> - import java . io . FilenameFilter ; <nl> import java . io . FileOutputStream ; <nl> + import java . io . FilenameFilter ; <nl> import java . io . IOException ; <nl> import java . io . InputStream ; <nl> import java . io . UnsupportedEncodingException ; <nl> @ @ - 36 , 6 + 32 , 8 @ @ import java . lang . reflect . Proxy ; <nl> import java . net . URI ; <nl> import java . net . URISyntaxException ; <nl> import java . net . URL ; <nl> + import java . nio . Buffer ; <nl> + import java . nio . ByteBuffer ; <nl> import java . security . AccessController ; <nl> import java . security . PrivilegedAction ; <nl> import java . util . ArrayList ; <nl> @ @ - 173 , 14 + 171 , 13 @ @ public final class Native { <nl> that introduces issues with cleaning up any extant JNA bits <nl> ( e . g . Memory ) which may still need use of the library before shutdown . <nl> * / <nl> - private static boolean deleteNativeLibrary ( String path ) { <nl> - File flib = new File ( path ) ; <nl> - if ( flib . delete ( ) ) { <nl> + static boolean deleteLibrary ( File lib ) { <nl> + if ( lib . delete ( ) ) { <nl> return true ; <nl> } <nl> <nl> / / Couldn ' t delete it , mark for later deletion <nl> - markTemporaryFile ( flib ) ; <nl> + markTemporaryFile ( lib ) ; <nl> <nl> return false ; <nl> } <nl> @ @ - 594 , 10 + 591 , 20 @ @ public final class Native { <nl> return buf ; <nl> } <nl> <nl> + / * * Generate a canonical String prefix based on the current OS <nl> + type / arch / name . <nl> + * / <nl> + public static String getNativeLibraryResourcePrefix ( ) { <nl> + return getNativeLibraryResourcePrefix ( Platform . getOSType ( ) , System . getProperty ( " os . arch " ) , System . getProperty ( " os . name " ) ) ; <nl> + } <nl> + <nl> / * * Generate a canonical String prefix based on the given OS <nl> type / arch / name . <nl> + @ param osType from { @ link Platform } <nl> + @ param arch from < code > os . arch < / code > System property <nl> + @ param name from < code > os . name < / code > System property <nl> * / <nl> - static String getNativeLibraryResourcePath ( int osType , String arch , String name ) { <nl> + public static String getNativeLibraryResourcePrefix ( int osType , String arch , String name ) { <nl> String osPrefix ; <nl> arch = arch . toLowerCase ( ) ; <nl> if ( " powerpc " . equals ( arch ) ) { <nl> @ @ - 652 , 7 + 659 , 7 @ @ public final class Native { <nl> osPrefix + = " - " + arch ; <nl> break ; <nl> } <nl> - return " / com / sun / jna / " + osPrefix ; <nl> + return osPrefix ; <nl> } <nl> <nl> / * * <nl> @ @ - 727 , 28 + 734 , 76 @ @ public final class Native { <nl> throw new UnsatisfiedLinkError ( " Native jnidispatch library not found " ) ; <nl> } <nl> <nl> + static final String JNA _ TMPLIB _ PREFIX = " jna " ; <nl> / * * <nl> * Attempts to load the native library resource from the filesystem , <nl> * extracting the JNA stub library from jna . jar if not already available . <nl> * / <nl> private static void loadNativeLibraryFromJar ( ) { <nl> - String libname = System . mapLibraryName ( " jnidispatch " ) ; <nl> - String arch = System . getProperty ( " os . arch " ) ; <nl> - String name = System . getProperty ( " os . name " ) ; <nl> - String resourceName = getNativeLibraryResourcePath ( Platform . getOSType ( ) , arch , name ) + " / " + libname ; <nl> - URL url = Native . class . getResource ( resourceName ) ; <nl> - boolean unpacked = false ; <nl> - <nl> - / / Add an ugly hack for OpenJDK ( soylatte ) - JNI libs use the usual <nl> - / / . dylib extension <nl> - if ( url = = null & & Platform . isMac ( ) <nl> - & & resourceName . endsWith ( " . dylib " ) ) { <nl> - resourceName = resourceName . substring ( 0 , resourceName . lastIndexOf ( " . dylib " ) ) + " . jnilib " ; <nl> - url = Native . class . getResource ( resourceName ) ; <nl> + try { <nl> + String prefix = " com / sun / jna / " + getNativeLibraryResourcePrefix ( ) ; <nl> + File lib = extractFromResourcePath ( " jnidispatch " , prefix , Native . class . getClassLoader ( ) ) ; <nl> + System . load ( lib . getAbsolutePath ( ) ) ; <nl> + nativeLibraryPath = lib . getAbsolutePath ( ) ; <nl> + / / Attempt to delete immediately once jnidispatch is successfully <nl> + / / loaded . This avoids the complexity of trying to do so on " exit " , <nl> + / / which point can vary under different circumstances ( native <nl> + / / compilation , dynamically loaded modules , normal application , etc ) . <nl> + if ( isUnpacked ( lib ) ) { <nl> + deleteLibrary ( lib ) ; <nl> + } <nl> + } <nl> + catch ( IOException e ) { <nl> + throw new UnsatisfiedLinkError ( e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * Identify temporary files unpacked from classpath jar files . * / <nl> + static boolean isUnpacked ( File file ) { <nl> + return file . getName ( ) . startsWith ( JNA _ TMPLIB _ PREFIX ) ; <nl> + } <nl> + <nl> + / * * Attempt to extract a native library from the current resource path . <nl> + * Expects native libraries to be stored under <nl> + * the path returned by { @ link # getNativeLibraryResourcePrefix ( ) } , <nl> + * and reachable by the current thread context class loader . <nl> + * @ param name Base name of native library to extract <nl> + * @ return File indicating extracted resource on disk <nl> + * @ throws IOException if resource not found <nl> + * / <nl> + static File extractFromResourcePath ( String name ) throws IOException { <nl> + return extractFromResourcePath ( name , getNativeLibraryResourcePrefix ( ) , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; <nl> + } <nl> + <nl> + / * * Attempt to extract a native library from the current resource path . <nl> + * Expects native libraries to be stored under <nl> + * the path returned by { @ link # getNativeLibraryResourcePath ( int , String , <nl> + * String ) } . <nl> + * @ param name Base name of native library to extract <nl> + * @ param loader Class loader to use to load resources <nl> + * @ param resourcePrefix prefix to use when looking for the resource <nl> + * @ return File indicating extracted resource on disk <nl> + * @ throws IOException if resource not found <nl> + * / <nl> + static File extractFromResourcePath ( String name , String resourcePrefix , ClassLoader loader ) throws IOException { <nl> + String libname = System . mapLibraryName ( name ) ; <nl> + String resourcePath = resourcePrefix + " / " + libname ; <nl> + URL url = loader . getResource ( resourcePath ) ; <nl> + <nl> + / / User libraries will have ' . dylib ' <nl> + if ( url = = null & & Platform . isMac ( ) ) { <nl> + if ( resourcePath . endsWith ( " . jnilib " ) ) { <nl> + resourcePath = resourcePath . substring ( 0 , resourcePath . lastIndexOf ( " . jnilib " ) ) + " . dylib " ; <nl> + } <nl> + / / Ugly hack for OpenJDK ( soylatte ) - JNI libs use the usual <nl> + / / . dylib extension <nl> + else if ( resourcePath . endsWith ( " . dylib " ) ) { <nl> + resourcePath = resourcePath . substring ( 0 , resourcePath . lastIndexOf ( " . dylib " ) ) + " . jnilib " ; <nl> + } <nl> + url = loader . getResource ( resourcePath ) ; <nl> } <nl> if ( url = = null ) { <nl> - throw new UnsatisfiedLinkError ( " JNA native support ( " + resourceName <nl> - + " ) not found in resource path " ) ; <nl> + throw new IOException ( " JNA native support ( " + resourcePath + " ) not found in resource path ( " + System . getProperty ( " java . class . path " ) + " ) " ) ; <nl> } <nl> <nl> File lib = null ; <nl> @ @ - 760 , 13 + 815 , 13 @ @ public final class Native { <nl> lib = new File ( url . getPath ( ) ) ; <nl> } <nl> if ( ! lib . exists ( ) ) { <nl> - throw new Error ( " File URL " + url + " could not be properly decoded " ) ; <nl> + throw new IOException ( " File URL " + url + " could not be properly decoded " ) ; <nl> } <nl> } <nl> else { <nl> - InputStream is = Native . class . getResourceAsStream ( resourceName ) ; <nl> + InputStream is = loader . getResourceAsStream ( resourcePath ) ; <nl> if ( is = = null ) { <nl> - throw new Error ( " Can ' t obtain jnidispatch InputStream " ) ; <nl> + throw new IOException ( " Can ' t obtain InputStream for " + resourcePath ) ; <nl> } <nl> <nl> FileOutputStream fos = null ; <nl> @ @ - 775 , 7 + 830 , 7 @ @ public final class Native { <nl> / / Let Java pick the suffix , except on windows , to avoid <nl> / / problems with Web Start . <nl> File dir = getTempDir ( ) ; <nl> - lib = File . createTempFile ( " jna " , Platform . isWindows ( ) ? " . dll " : null , dir ) ; <nl> + lib = File . createTempFile ( JNA _ TMPLIB _ PREFIX , Platform . isWindows ( ) ? " . dll " : null , dir ) ; <nl> lib . deleteOnExit ( ) ; <nl> fos = new FileOutputStream ( lib ) ; <nl> int count ; <nl> @ @ - 783 , 10 + 838 , 9 @ @ public final class Native { <nl> while ( ( count = is . read ( buf , 0 , buf . length ) ) > 0 ) { <nl> fos . write ( buf , 0 , count ) ; <nl> } <nl> - unpacked = true ; <nl> } <nl> catch ( IOException e ) { <nl> - throw new Error ( " Failed to create temporary file for jnidispatch library " , e ) ; <nl> + throw new IOException ( " Failed to create temporary file for " + name + " library " , e ) ; <nl> } <nl> finally { <nl> try { is . close ( ) ; } catch ( IOException e ) { } <nl> @ @ - 795 , 15 + 849 , 7 @ @ public final class Native { <nl> } <nl> } <nl> } <nl> - System . load ( lib . getAbsolutePath ( ) ) ; <nl> - nativeLibraryPath = lib . getAbsolutePath ( ) ; <nl> - / / Attempt to delete immediately once jnidispatch is successfully <nl> - / / loaded . This avoids the complexity of trying to do so on " exit " , <nl> - / / which point can vary under different circumstances ( native <nl> - / / compilation , dynamically loaded modules , normal application , etc ) . <nl> - if ( unpacked ) { <nl> - deleteNativeLibrary ( lib . getAbsolutePath ( ) ) ; <nl> - } <nl> + return lib ; <nl> } <nl> <nl> / * * <nl> @ @ - 966 , 7 + 1012 , 7 @ @ public final class Native { <nl> File dir = getTempDir ( ) ; <nl> FilenameFilter filter = new FilenameFilter ( ) { <nl> public boolean accept ( File dir , String name ) { <nl> - return name . endsWith ( " . x " ) & & name . indexOf ( " jna " ) ! = - 1 ; <nl> + return name . endsWith ( " . x " ) & & name . startsWith ( JNA _ TMPLIB _ PREFIX ) ; <nl> } <nl> } ; <nl> File [ ] files = dir . listFiles ( filter ) ; <nl> diff - - git a / src / com / sun / jna / NativeLibrary . java b / src / com / sun / jna / NativeLibrary . java <nl> index f871276 . . a68ed3d 100644 <nl> - - - a / src / com / sun / jna / NativeLibrary . java <nl> + + + b / src / com / sun / jna / NativeLibrary . java <nl> @ @ - 16 , 6 + 16 , 7 @ @ package com . sun . jna ; <nl> <nl> import java . io . File ; <nl> import java . io . FilenameFilter ; <nl> + import java . io . IOException ; <nl> import java . lang . ref . WeakReference ; <nl> import java . lang . ref . Reference ; <nl> import java . lang . reflect . Method ; <nl> @ @ - 193 , 6 + 194 , 20 @ @ public class NativeLibrary { <nl> try { handle = Native . open ( libraryPath , openFlags ) ; } <nl> catch ( UnsatisfiedLinkError e2 ) { e = e2 ; } <nl> } <nl> + / / As a last resort , try to extract the library from the class <nl> + / / path , using the current context class loader . <nl> + if ( handle = = 0 ) { <nl> + try { <nl> + File embedded = Native . extractFromResourcePath ( libraryName ) ; <nl> + handle = Native . open ( embedded . getAbsolutePath ( ) ) ; <nl> + / / Don ' t leave temporary files around <nl> + if ( Native . isUnpacked ( embedded ) ) { <nl> + Native . deleteLibrary ( embedded ) ; <nl> + } <nl> + } <nl> + catch ( IOException e2 ) { e = new UnsatisfiedLinkError ( e2 . getMessage ( ) ) ; } <nl> + } <nl> + <nl> if ( handle = = 0 ) { <nl> throw new UnsatisfiedLinkError ( " Unable to load library ' " + libraryName + " ' : " <nl> + e . getMessage ( ) ) ; <nl> diff - - git a / src / com / sun / jna / overview . html b / src / com / sun / jna / overview . html <nl> index 60db18b . . 40a751b 100644 <nl> - - - a / src / com / sun / jna / overview . html <nl> + + + b / src / com / sun / jna / overview . html <nl> @ @ - 715 , 7 + 715 , 8 @ @ NOTE : When protected mode is enabled , you should make use of the jsig library , i <nl> Using < a href = " # direct - mapping " > direct mapping < / a > of methods makes native <nl> calls more efficiently than does interface mapping . Direct mapping does not <nl> support varargs calls or arrays of Pointer , String , or WString as an argument <nl> - or return value . <nl> + or return value . For optimium results , use only primitive arguments and <nl> + return values ; you ' ll have to convert to and from objects yourself explicitly . <nl> < h3 > Avoid type mapping < / h3 > <nl> Type mapping incurs additional overhead on each function call . You can avoid <nl> this by ensuring that your arguments and / or return types are already primitive <nl> diff - - git a / test / com / sun / jna / NativeLibraryTest . java b / test / com / sun / jna / NativeLibraryTest . java <nl> index 73690ad . . 96b592b 100644 <nl> - - - a / test / com / sun / jna / NativeLibraryTest . java <nl> + + + b / test / com / sun / jna / NativeLibraryTest . java <nl> @ @ - 249 , 6 + 249 , 10 @ @ public class NativeLibraryTest extends TestCase { <nl> Native . loadLibrary ( " testlib " , TestLibrary . class , options ) ; <nl> } <nl> <nl> + public void testEmbeddedLibrary ( ) { <nl> + Native . loadLibrary ( " embedded - testlib " , TestLibrary . class ) ; <nl> + } <nl> + <nl> public static void main ( String [ ] args ) { <nl> junit . textui . TestRunner . run ( NativeLibraryTest . class ) ; <nl> } <nl> diff - - git a / test / com / sun / jna / NativeTest . java b / test / com / sun / jna / NativeTest . java <nl> index e567f95 . . d3d7125 100644 <nl> - - - a / test / com / sun / jna / NativeTest . java <nl> + + + b / test / com / sun / jna / NativeTest . java <nl> @ @ - 245 , 50 + 245 , 50 @ @ public class NativeTest extends TestCase { <nl> } <nl> <nl> public void testOSPrefix ( ) { <nl> - assertEquals ( " Wrong resource path " , " / com / sun / jna / win32 - x86 " , <nl> - Native . getNativeLibraryResourcePath ( Platform . WINDOWS , <nl> - " x86 " , " Windows " ) ) ; <nl> - assertEquals ( " Wrong resource path Windows / i386 " , " / com / sun / jna / win32 - x86 " , <nl> - Native . getNativeLibraryResourcePath ( Platform . WINDOWS , <nl> - " i386 " , " Windows " ) ) ; <nl> - assertEquals ( " Wrong resource path Windows CE / arm " , " / com / sun / jna / w32ce - arm " , <nl> - Native . getNativeLibraryResourcePath ( Platform . WINDOWSCE , <nl> - " arm " , " Windows CE " ) ) ; <nl> - assertEquals ( " Wrong resource path Mac / x86 " , " / com / sun / jna / darwin " , <nl> - Native . getNativeLibraryResourcePath ( Platform . MAC , <nl> - " x86 " , " Darwin " ) ) ; <nl> - assertEquals ( " Wrong resource path Mac / x86 _ 64 " , " / com / sun / jna / darwin " , <nl> - Native . getNativeLibraryResourcePath ( Platform . MAC , <nl> - " x86 _ 64 " , " Mac " ) ) ; <nl> - assertEquals ( " Wrong resource path Solaris / sparc " , " / com / sun / jna / sunos - sparc " , <nl> - Native . getNativeLibraryResourcePath ( Platform . SOLARIS , <nl> - " sparc " , " Solaris " ) ) ; <nl> - assertEquals ( " Wrong resource path SunOS / sparcv9 " , " / com / sun / jna / sunos - sparcv9 " , <nl> - Native . getNativeLibraryResourcePath ( Platform . SOLARIS , <nl> - " sparcv9 " , " SunOS " ) ) ; <nl> - assertEquals ( " Wrong resource path Linux / i386 " , " / com / sun / jna / linux - i386 " , <nl> - Native . getNativeLibraryResourcePath ( Platform . LINUX , <nl> - " i386 " , " Linux / Gnu " ) ) ; <nl> - assertEquals ( " Wrong resource path Linux / x86 " , " / com / sun / jna / linux - i386 " , <nl> - Native . getNativeLibraryResourcePath ( Platform . LINUX , <nl> - " x86 " , " Linux " ) ) ; <nl> - assertEquals ( " Wrong resource path Linux / ppc " , " / com / sun / jna / linux - ppc " , <nl> - Native . getNativeLibraryResourcePath ( Platform . LINUX , <nl> - " powerpc " , " Linux " ) ) ; <nl> - assertEquals ( " Wrong resource path OpenBSD / x86 " , " / com / sun / jna / openbsd - i386 " , <nl> - Native . getNativeLibraryResourcePath ( Platform . OPENBSD , <nl> - " x86 " , " OpenBSD " ) ) ; <nl> - assertEquals ( " Wrong resource path FreeBSD / x86 " , " / com / sun / jna / freebsd - i386 " , <nl> - Native . getNativeLibraryResourcePath ( Platform . FREEBSD , <nl> - " x86 " , " FreeBSD " ) ) ; <nl> - assertEquals ( " Wrong resource path Linux / armv7l ( android ) " , " / com / sun / jna / android - arm " , <nl> - Native . getNativeLibraryResourcePath ( Platform . ANDROID , <nl> - " armv7l " , " Linux " ) ) ; <nl> - <nl> - assertEquals ( " Wrong resource path other / other " , " / com / sun / jna / name - ppc " , <nl> - Native . getNativeLibraryResourcePath ( Platform . UNSPECIFIED , <nl> - " PowerPC " , " Name Of System " ) ) ; <nl> - <nl> + assertEquals ( " Wrong resource path " , " win32 - x86 " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . WINDOWS , <nl> + " x86 " , " Windows " ) ) ; <nl> + assertEquals ( " Wrong resource path Windows / i386 " , " win32 - x86 " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . WINDOWS , <nl> + " i386 " , " Windows " ) ) ; <nl> + assertEquals ( " Wrong resource path Windows CE / arm " , " w32ce - arm " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . WINDOWSCE , <nl> + " arm " , " Windows CE " ) ) ; <nl> + assertEquals ( " Wrong resource path Mac / x86 " , " darwin " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . MAC , <nl> + " x86 " , " Darwin " ) ) ; <nl> + assertEquals ( " Wrong resource path Mac / x86 _ 64 " , " darwin " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . MAC , <nl> + " x86 _ 64 " , " Mac " ) ) ; <nl> + assertEquals ( " Wrong resource path Solaris / sparc " , " sunos - sparc " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . SOLARIS , <nl> + " sparc " , " Solaris " ) ) ; <nl> + assertEquals ( " Wrong resource path SunOS / sparcv9 " , " sunos - sparcv9 " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . SOLARIS , <nl> + " sparcv9 " , " SunOS " ) ) ; <nl> + assertEquals ( " Wrong resource path Linux / i386 " , " linux - i386 " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . LINUX , <nl> + " i386 " , " Linux / Gnu " ) ) ; <nl> + assertEquals ( " Wrong resource path Linux / x86 " , " linux - i386 " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . LINUX , <nl> + " x86 " , " Linux " ) ) ; <nl> + assertEquals ( " Wrong resource path Linux / ppc " , " linux - ppc " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . LINUX , <nl> + " powerpc " , " Linux " ) ) ; <nl> + assertEquals ( " Wrong resource path OpenBSD / x86 " , " openbsd - i386 " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . OPENBSD , <nl> + " x86 " , " OpenBSD " ) ) ; <nl> + assertEquals ( " Wrong resource path FreeBSD / x86 " , " freebsd - i386 " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . FREEBSD , <nl> + " x86 " , " FreeBSD " ) ) ; <nl> + assertEquals ( " Wrong resource path Linux / armv7l ( android ) " , " android - arm " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . ANDROID , <nl> + " armv7l " , " Linux " ) ) ; <nl> + <nl> + assertEquals ( " Wrong resource path other / other " , " name - ppc " , <nl> + Native . getNativeLibraryResourcePrefix ( Platform . UNSPECIFIED , <nl> + " PowerPC " , " Name Of System " ) ) ; <nl> + <nl> } <nl> <nl> public static class DirectMapping { <nl> @ @ - 338 , 10 + 338 , 11 @ @ public class NativeTest extends TestCase { <nl> <nl> public void testRemoveTemporaries ( ) throws Exception { <nl> File dir = Native . getTempDir ( ) ; <nl> - File tmp = new File ( dir , " jna " ) ; <nl> + File tmp = new File ( dir , Native . JNA _ TMPLIB _ PREFIX ) ; <nl> tmp . delete ( ) ; <nl> try { <nl> assertTrue ( " Couldn ' t create temporary file " + tmp , tmp . createNewFile ( ) ) ; <nl> + assertTrue ( " File isn ' t recognized as unpacked " , Native . isUnpacked ( tmp ) ) ; <nl> Native . markTemporaryFile ( tmp ) ; <nl> Native . removeTemporaryFiles ( ) ; <nl> assertFalse ( " Temporary file still exists " , tmp . exists ( ) ) ; <nl> diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java <nl> index 8bd7ad3 . . 70a6edf 100644 <nl> - - - a / test / com / sun / jna / StructureTest . java <nl> + + + b / test / com / sun / jna / StructureTest . java <nl> @ @ - 66 , 6 + 66 , 20 @ @ public class StructureTest extends TestCase { <nl> assertNotSame ( " Initial pointer should not be used directly : " + p , p , p1 ) ; <nl> } <nl> <nl> + public void testInitializeWithTypeMapper ( ) { <nl> + class TestStructure extends Structure { <nl> + public int field ; <nl> + protected List getFieldOrder ( ) { <nl> + return Arrays . asList ( new String [ ] { " field " } ) ; <nl> + } <nl> + public TestStructure ( TypeMapper m ) { <nl> + super ( ALIGN _ DEFAULT , m ) ; <nl> + } <nl> + } <nl> + TypeMapper m = new DefaultTypeMapper ( ) ; <nl> + TestStructure s = new TestStructure ( m ) ; <nl> + assertEquals ( " Type mapper not installed " , m , s . getTypeMapper ( ) ) ; <nl> + } <nl> <nl> / / must be public to populate array <nl> public static class TestAllocStructure extends Structure {
NEAREST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index c19c48b . . d0032ee 100755 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 8 , 6 + 8 , 7 @ @ Features <nl> * Automatic cleanup of native threads ( based on suggestions from neil smith ) - [ @ twall ] ( https : / / github . com / twall ) . <nl> * Add android - arm target ( thanks to ochafik for initial work ) . <nl> * Add ` jna . tmpdir ` to override temporary JNA storage location - [ @ twall ] ( https : / / github . com / twall ) . <nl> + * Add EXTRA _ MAKE _ OPTS ant property to override make variables - [ @ twall ] ( https : / / github . com / twall ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> diff - - git a / build . xml b / build . xml <nl> index c87f14c . . 9a3c453 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 622 , 6 + 622 , 10 @ @ osname = macos <nl> < os name = " AIX " / > <nl> < / or > <nl> < / condition > <nl> + < ! - - Allow explicit override of make variables - - > <nl> + < condition property = " make . OPTS " value = " $ { EXTRA _ MAKE _ OPTS } " else = " IGNORE = " > <nl> + < isset property = " EXTRA _ MAKE _ OPTS " / > <nl> + < / condition > <nl> < ! - - Native resource path within jna . jar - - > <nl> < condition property = " native . path " value = " lib / armeabi " else = " com / sun / jna / $ { os . prefix } " > <nl> < equals arg1 = " $ { os . prefix } " arg2 = " android - arm " / > <nl> @ @ - 642 , 6 + 646 , 7 @ @ osname = macos <nl> < arg value = " $ { make . ARCH } " / > <nl> < arg value = " $ { make . PATH } " / > <nl> < arg value = " $ { make . OS } " / > <nl> + < arg line = " $ { make . OPTS } " / > <nl> < arg value = " JNA _ JNI _ VERSION = $ { jni . version } " / > <nl> < arg value = " CHECKSUM = $ { jni . md5 } " / > <nl> < / exec > <nl> diff - - git a / native / Makefile b / native / Makefile <nl> index 4d4f505 . . 17b740c3 100644 <nl> - - - a / native / Makefile <nl> + + + b / native / Makefile <nl> @ @ - 29 , 7 + 29 , 7 @ @ <nl> # The android build requires the android SDK + NDK for cross - compilation ; <nl> # make the tools available on the path and compile with <nl> # " ant - Dos . prefix = android - arm " . Put the NDK tools in the path and adjust <nl> - # NDK _ PLATFORM below . <nl> + # NDK _ PLATFORM below or set it in your environment . <nl> # <nl> <nl> # Systems which support POSIX signals may be able to support VM crash <nl> @ @ - 113 , 7 + 113 , 7 @ @ RANLIB = arm - linux - androideabi - ranlib <nl> STRIP = arm - linux - androideabi - strip - x <nl> CDEFINES = - DNO _ JAWT - DNO _ WEAK _ GLOBALS - DFFI _ MMAP _ EXEC _ WRIT = 1 - DFFI _ MMAP _ EXEC _ SELINUX = 0 <nl> COPT + = - fpic - mthumb - interwork - ffunction - sections - funwind - tables - fstack - protector - fno - short - enums - march = armv5te - mtune = xscale - msoft - float <nl> - NDK _ PLATFORM = / Developer / Applications / android - ndk - r7c / platforms / android - 14 <nl> + NDK _ PLATFORM ? = / Developer / Applications / android - ndk - r7c / platforms / android - 14 <nl> JAVA _ INCLUDES = <nl> CINCLUDES + = - I " $ ( NDK _ PLATFORM ) / arch - arm / usr / include " # - I / usr / include <nl> LIBS = - nostdlib - L " $ ( NDK _ PLATFORM ) / arch - arm / usr / lib / " - lgcc - lc - ldl - lm

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index c2b0c30 . . 9381134 100755 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 5 , 6 + 5 , 7 @ @ Features 
 - - - - - - - - 
 * Basic [ COM support ] ( https : / / github . com / twall / jna / blob / master / www / PlatformLibrary . md ) for w32 - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . 
 * Avoid superfluous Structure memory allocation by using Structure ( Pointer ) ctors if available - [ @ twall ] ( https : / / github . com / twall ) . 
 + * [ PR # 120 ] ( https : / / github . com / twall / jna / pull / 120 ) : Provide methods for extracting native libraries from the class path for use by JNA - [ @ Zlika ] ( https : / / github . com / Zlika ) . 
 * [ # 163 ] ( https : / / github . com / twall / jna / pull / 163 ) : The Java ` GUID ` structure can be used directly as alternative to ` Ole32Util . getGUIDFromString ( ) ` - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . 
 * [ # 163 ] ( https : / / github . com / twall / jna / pull / 163 ) : Ported Win32 ` dbt . h ` - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . 
 * [ # 163 ] ( https : / / github . com / twall / jna / pull / 163 ) : Added Win32 ` WTSRegisterSessionNotification ( ) ` and ` WTSUnRegisterSessionNotification ( ) ` from ` Wtsapi32 . dll ` - [ @ wolftobias ] ( https : / / github . com / wolftobias ) . 
 diff - - git a / build . xml b / build . xml 
 index 19c4030 . . 798ec14 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 264 , 6 + 264 , 7 @ @ 
 < path id = " test . runpath " > 
 < pathelement path = " $ { build } / $ { jar } " / > 
 < pathelement path = " $ { test . classes } " / > 
 + < pathelement path = " $ { build } / $ { testjar } " / > 
 < pathelement path = " lib / clover . jar " / > 
 < path refid = " test . libs " / > 
 < / path > 
 @ @ - 708 , 12 + 709 , 28 @ @ osname = macos 
 < src path = " $ { test . src } " / > 
 < exclude name = " $ { tests . exclude } " / > 
 < / javac > 
 - < ! - - Create a jar for easy movement of tests - - > 
 + < ! - - Move ( not copy ) embedded testlib to test class folder so that it will be - - > 
 + < ! - - packaged into the test jar and NOT available in the FS - based class path - - > 
 + < move todir = " $ { test . classes } / $ { os . prefix } " > 
 + < fileset dir = " $ { build . native } " > 
 + < patternset id = " embedded - testlib " > 
 + < include name = " * * / * embedded - testlib * " / > 
 + < / patternset > 
 + < / fileset > 
 + < / move > 
 + < ! - - Create a jar for easy movement of tests , and embedded load test - - > 
 < jar jarfile = " $ { build } / $ { testjar } " > 
 < fileset dir = " $ { test . classes } " > 
 < patternset refid = " jar - compiled " / > 
 + < include name = " * * / * embedded - testlib * " / > 
 < / fileset > 
 < / jar > 
 + < ! - - Ensure embedded library unavailable on FS - based class path - - > 
 + < delete > 
 + < fileset dir = " $ { test . classes } " > 
 + < include name = " * * / * embedded - testlib * " / > 
 + < / fileset > 
 + < / delete > 
 < mkdir dir = " $ { build } / jws " / > 
 < copy todir = " $ { build } / jws " file = " $ { build } / $ { jar } " / > 
 < copy todir = " $ { build } / jws " file = " $ { build } / $ { testjar } " / > 
 diff - - git a / native / Makefile b / native / Makefile 
 index 03fd09b . . 5a7ca43 100644 
 - - - a / native / Makefile 
 + + + b / native / Makefile 
 @ @ - 67 , 6 + 67 , 7 @ @ FFI _ CONFIG = - - enable - static - - disable - shared - - with - pic = yes 
 endif 
 LIBRARY = $ ( BUILD ) / $ ( LIBPFX ) jnidispatch $ ( JNISFX ) 
 TESTLIB = $ ( BUILD ) / $ ( LIBPFX ) testlib $ ( LIBSFX ) 
 + TESTLIB _ EMBEDDED = $ ( BUILD ) / $ ( LIBPFX ) embedded - testlib $ ( LIBSFX ) 
 TESTLIB2 = $ ( BUILD ) / $ ( LIBPFX ) testlib2 $ ( LIBSFX ) 
 
 # Reasonable defaults based on GCC 
 @ @ - 308 , 6 + 309 , 7 @ @ LDFLAGS = $ ( ARCHFLAGS ) - dynamiclib - o $ @ - framework JavaVM \ 
 - compatibility _ version $ ( shell echo $ { JNA _ JNI _ VERSION } | sed ' s / ^ \ ( [ 0 - 9 ] [ 0 - 9 ] * \ ) . * / \ 1 / g ' ) \ 
 - current _ version $ ( JNA _ JNI _ VERSION ) \ 
 - mmacosx - version - min = 10 . 3 \ 
 + - framework Foundation \ 
 - install _ name $ { @ F } \ 
 $ ( SYSLIBROOT ) 
 # JAWT linkage handled by - framework JavaVM 
 @ @ - 329 , 7 + 331 , 7 @ @ else 
 	 $ ( CC ) $ ( CFLAGS ) - c $ < $ ( COUT ) 
 endif 
 
 - all : $ ( LIBRARY ) $ ( TESTLIB ) $ ( TESTLIB2 ) 
 + all : $ ( LIBRARY ) $ ( TESTLIB ) $ ( TESTLIB2 ) $ ( TESTLIB _ EMBEDDED ) 
 
 install : 
 	 mkdir $ ( INSTALLDIR ) 
 @ @ - 349 , 6 + 351 , 9 @ @ $ ( LIBRARY ) : $ ( JNIDISPATCH _ OBJS ) $ ( FFI _ LIB ) 
 $ ( TESTLIB ) : $ ( BUILD ) / testlib . o 
 	 $ ( LD ) $ ( LDFLAGS ) $ < $ ( LIBS ) 
 
 + $ ( TESTLIB _ EMBEDDED ) : $ ( BUILD ) / testlib . o 
 + 	 $ ( LD ) $ ( LDFLAGS ) $ < $ ( LIBS ) 
 + 
 ifeq ( $ ( ARSFX ) , . lib ) 
 TESTDEP = $ ( TESTLIB : . dll = . lib ) 
 else 
 diff - - git a / src / com / sun / jna / Native . java b / src / com / sun / jna / Native . java 
 index 8f1950b . . 9be443e 100644 
 - - - a / src / com / sun / jna / Native . java 
 + + + b / src / com / sun / jna / Native . java 
 @ @ - 16 , 13 + 16 , 9 @ @ import java . awt . Component ; 
 import java . awt . GraphicsEnvironment ; 
 import java . awt . HeadlessException ; 
 import java . awt . Window ; 
 - 
 - import java . nio . Buffer ; 
 - import java . nio . ByteBuffer ; 
 - 
 import java . io . File ; 
 - import java . io . FilenameFilter ; 
 import java . io . FileOutputStream ; 
 + import java . io . FilenameFilter ; 
 import java . io . IOException ; 
 import java . io . InputStream ; 
 import java . io . UnsupportedEncodingException ; 
 @ @ - 36 , 6 + 32 , 8 @ @ import java . lang . reflect . Proxy ; 
 import java . net . URI ; 
 import java . net . URISyntaxException ; 
 import java . net . URL ; 
 + import java . nio . Buffer ; 
 + import java . nio . ByteBuffer ; 
 import java . security . AccessController ; 
 import java . security . PrivilegedAction ; 
 import java . util . ArrayList ; 
 @ @ - 173 , 14 + 171 , 13 @ @ public final class Native { 
 that introduces issues with cleaning up any extant JNA bits 
 ( e . g . Memory ) which may still need use of the library before shutdown . 
 * / 
 - private static boolean deleteNativeLibrary ( String path ) { 
 - File flib = new File ( path ) ; 
 - if ( flib . delete ( ) ) { 
 + static boolean deleteLibrary ( File lib ) { 
 + if ( lib . delete ( ) ) { 
 return true ; 
 } 
 
 / / Couldn ' t delete it , mark for later deletion 
 - markTemporaryFile ( flib ) ; 
 + markTemporaryFile ( lib ) ; 
 
 return false ; 
 } 
 @ @ - 594 , 10 + 591 , 20 @ @ public final class Native { 
 return buf ; 
 } 
 
 + / * * Generate a canonical String prefix based on the current OS 
 + type / arch / name . 
 + * / 
 + public static String getNativeLibraryResourcePrefix ( ) { 
 + return getNativeLibraryResourcePrefix ( Platform . getOSType ( ) , System . getProperty ( " os . arch " ) , System . getProperty ( " os . name " ) ) ; 
 + } 
 + 
 / * * Generate a canonical String prefix based on the given OS 
 type / arch / name . 
 + @ param osType from { @ link Platform } 
 + @ param arch from < code > os . arch < / code > System property 
 + @ param name from < code > os . name < / code > System property 
 * / 
 - static String getNativeLibraryResourcePath ( int osType , String arch , String name ) { 
 + public static String getNativeLibraryResourcePrefix ( int osType , String arch , String name ) { 
 String osPrefix ; 
 arch = arch . toLowerCase ( ) ; 
 if ( " powerpc " . equals ( arch ) ) { 
 @ @ - 652 , 7 + 659 , 7 @ @ public final class Native { 
 osPrefix + = " - " + arch ; 
 break ; 
 } 
 - return " / com / sun / jna / " + osPrefix ; 
 + return osPrefix ; 
 } 
 
 / * * 
 @ @ - 727 , 28 + 734 , 76 @ @ public final class Native { 
 throw new UnsatisfiedLinkError ( " Native jnidispatch library not found " ) ; 
 } 
 
 + static final String JNA _ TMPLIB _ PREFIX = " jna " ; 
 / * * 
 * Attempts to load the native library resource from the filesystem , 
 * extracting the JNA stub library from jna . jar if not already available . 
 * / 
 private static void loadNativeLibraryFromJar ( ) { 
 - String libname = System . mapLibraryName ( " jnidispatch " ) ; 
 - String arch = System . getProperty ( " os . arch " ) ; 
 - String name = System . getProperty ( " os . name " ) ; 
 - String resourceName = getNativeLibraryResourcePath ( Platform . getOSType ( ) , arch , name ) + " / " + libname ; 
 - URL url = Native . class . getResource ( resourceName ) ; 
 - boolean unpacked = false ; 
 - 
 - / / Add an ugly hack for OpenJDK ( soylatte ) - JNI libs use the usual 
 - / / . dylib extension 
 - if ( url = = null & & Platform . isMac ( ) 
 - & & resourceName . endsWith ( " . dylib " ) ) { 
 - resourceName = resourceName . substring ( 0 , resourceName . lastIndexOf ( " . dylib " ) ) + " . jnilib " ; 
 - url = Native . class . getResource ( resourceName ) ; 
 + try { 
 + String prefix = " com / sun / jna / " + getNativeLibraryResourcePrefix ( ) ; 
 + File lib = extractFromResourcePath ( " jnidispatch " , prefix , Native . class . getClassLoader ( ) ) ; 
 + System . load ( lib . getAbsolutePath ( ) ) ; 
 + nativeLibraryPath = lib . getAbsolutePath ( ) ; 
 + / / Attempt to delete immediately once jnidispatch is successfully 
 + / / loaded . This avoids the complexity of trying to do so on " exit " , 
 + / / which point can vary under different circumstances ( native 
 + / / compilation , dynamically loaded modules , normal application , etc ) . 
 + if ( isUnpacked ( lib ) ) { 
 + deleteLibrary ( lib ) ; 
 + } 
 + } 
 + catch ( IOException e ) { 
 + throw new UnsatisfiedLinkError ( e . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + / * * Identify temporary files unpacked from classpath jar files . * / 
 + static boolean isUnpacked ( File file ) { 
 + return file . getName ( ) . startsWith ( JNA _ TMPLIB _ PREFIX ) ; 
 + } 
 + 
 + / * * Attempt to extract a native library from the current resource path . 
 + * Expects native libraries to be stored under 
 + * the path returned by { @ link # getNativeLibraryResourcePrefix ( ) } , 
 + * and reachable by the current thread context class loader . 
 + * @ param name Base name of native library to extract 
 + * @ return File indicating extracted resource on disk 
 + * @ throws IOException if resource not found 
 + * / 
 + static File extractFromResourcePath ( String name ) throws IOException { 
 + return extractFromResourcePath ( name , getNativeLibraryResourcePrefix ( ) , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; 
 + } 
 + 
 + / * * Attempt to extract a native library from the current resource path . 
 + * Expects native libraries to be stored under 
 + * the path returned by { @ link # getNativeLibraryResourcePath ( int , String , 
 + * String ) } . 
 + * @ param name Base name of native library to extract 
 + * @ param loader Class loader to use to load resources 
 + * @ param resourcePrefix prefix to use when looking for the resource 
 + * @ return File indicating extracted resource on disk 
 + * @ throws IOException if resource not found 
 + * / 
 + static File extractFromResourcePath ( String name , String resourcePrefix , ClassLoader loader ) throws IOException { 
 + String libname = System . mapLibraryName ( name ) ; 
 + String resourcePath = resourcePrefix + " / " + libname ; 
 + URL url = loader . getResource ( resourcePath ) ; 
 + 
 + / / User libraries will have ' . dylib ' 
 + if ( url = = null & & Platform . isMac ( ) ) { 
 + if ( resourcePath . endsWith ( " . jnilib " ) ) { 
 + resourcePath = resourcePath . substring ( 0 , resourcePath . lastIndexOf ( " . jnilib " ) ) + " . dylib " ; 
 + } 
 + / / Ugly hack for OpenJDK ( soylatte ) - JNI libs use the usual 
 + / / . dylib extension 
 + else if ( resourcePath . endsWith ( " . dylib " ) ) { 
 + resourcePath = resourcePath . substring ( 0 , resourcePath . lastIndexOf ( " . dylib " ) ) + " . jnilib " ; 
 + } 
 + url = loader . getResource ( resourcePath ) ; 
 } 
 if ( url = = null ) { 
 - throw new UnsatisfiedLinkError ( " JNA native support ( " + resourceName 
 - + " ) not found in resource path " ) ; 
 + throw new IOException ( " JNA native support ( " + resourcePath + " ) not found in resource path ( " + System . getProperty ( " java . class . path " ) + " ) " ) ; 
 } 
 
 File lib = null ; 
 @ @ - 760 , 13 + 815 , 13 @ @ public final class Native { 
 lib = new File ( url . getPath ( ) ) ; 
 } 
 if ( ! lib . exists ( ) ) { 
 - throw new Error ( " File URL " + url + " could not be properly decoded " ) ; 
 + throw new IOException ( " File URL " + url + " could not be properly decoded " ) ; 
 } 
 } 
 else { 
 - InputStream is = Native . class . getResourceAsStream ( resourceName ) ; 
 + InputStream is = loader . getResourceAsStream ( resourcePath ) ; 
 if ( is = = null ) { 
 - throw new Error ( " Can ' t obtain jnidispatch InputStream " ) ; 
 + throw new IOException ( " Can ' t obtain InputStream for " + resourcePath ) ; 
 } 
 
 FileOutputStream fos = null ; 
 @ @ - 775 , 7 + 830 , 7 @ @ public final class Native { 
 / / Let Java pick the suffix , except on windows , to avoid 
 / / problems with Web Start . 
 File dir = getTempDir ( ) ; 
 - lib = File . createTempFile ( " jna " , Platform . isWindows ( ) ? " . dll " : null , dir ) ; 
 + lib = File . createTempFile ( JNA _ TMPLIB _ PREFIX , Platform . isWindows ( ) ? " . dll " : null , dir ) ; 
 lib . deleteOnExit ( ) ; 
 fos = new FileOutputStream ( lib ) ; 
 int count ; 
 @ @ - 783 , 10 + 838 , 9 @ @ public final class Native { 
 while ( ( count = is . read ( buf , 0 , buf . length ) ) > 0 ) { 
 fos . write ( buf , 0 , count ) ; 
 } 
 - unpacked = true ; 
 } 
 catch ( IOException e ) { 
 - throw new Error ( " Failed to create temporary file for jnidispatch library " , e ) ; 
 + throw new IOException ( " Failed to create temporary file for " + name + " library " , e ) ; 
 } 
 finally { 
 try { is . close ( ) ; } catch ( IOException e ) { } 
 @ @ - 795 , 15 + 849 , 7 @ @ public final class Native { 
 } 
 } 
 } 
 - System . load ( lib . getAbsolutePath ( ) ) ; 
 - nativeLibraryPath = lib . getAbsolutePath ( ) ; 
 - / / Attempt to delete immediately once jnidispatch is successfully 
 - / / loaded . This avoids the complexity of trying to do so on " exit " , 
 - / / which point can vary under different circumstances ( native 
 - / / compilation , dynamically loaded modules , normal application , etc ) . 
 - if ( unpacked ) { 
 - deleteNativeLibrary ( lib . getAbsolutePath ( ) ) ; 
 - } 
 + return lib ; 
 } 
 
 / * * 
 @ @ - 966 , 7 + 1012 , 7 @ @ public final class Native { 
 File dir = getTempDir ( ) ; 
 FilenameFilter filter = new FilenameFilter ( ) { 
 public boolean accept ( File dir , String name ) { 
 - return name . endsWith ( " . x " ) & & name . indexOf ( " jna " ) ! = - 1 ; 
 + return name . endsWith ( " . x " ) & & name . startsWith ( JNA _ TMPLIB _ PREFIX ) ; 
 } 
 } ; 
 File [ ] files = dir . listFiles ( filter ) ; 
 diff - - git a / src / com / sun / jna / NativeLibrary . java b / src / com / sun / jna / NativeLibrary . java 
 index f871276 . . a68ed3d 100644 
 - - - a / src / com / sun / jna / NativeLibrary . java 
 + + + b / src / com / sun / jna / NativeLibrary . java 
 @ @ - 16 , 6 + 16 , 7 @ @ package com . sun . jna ; 
 
 import java . io . File ; 
 import java . io . FilenameFilter ; 
 + import java . io . IOException ; 
 import java . lang . ref . WeakReference ; 
 import java . lang . ref . Reference ; 
 import java . lang . reflect . Method ; 
 @ @ - 193 , 6 + 194 , 20 @ @ public class NativeLibrary { 
 try { handle = Native . open ( libraryPath , openFlags ) ; } 
 catch ( UnsatisfiedLinkError e2 ) { e = e2 ; } 
 } 
 + / / As a last resort , try to extract the library from the class 
 + / / path , using the current context class loader . 
 + if ( handle = = 0 ) { 
 + try { 
 + File embedded = Native . extractFromResourcePath ( libraryName ) ; 
 + handle = Native . open ( embedded . getAbsolutePath ( ) ) ; 
 + / / Don ' t leave temporary files around 
 + if ( Native . isUnpacked ( embedded ) ) { 
 + Native . deleteLibrary ( embedded ) ; 
 + } 
 + } 
 + catch ( IOException e2 ) { e = new UnsatisfiedLinkError ( e2 . getMessage ( ) ) ; } 
 + } 
 + 
 if ( handle = = 0 ) { 
 throw new UnsatisfiedLinkError ( " Unable to load library ' " + libraryName + " ' : " 
 + e . getMessage ( ) ) ; 
 diff - - git a / src / com / sun / jna / overview . html b / src / com / sun / jna / overview . html 
 index 60db18b . . 40a751b 100644 
 - - - a / src / com / sun / jna / overview . html 
 + + + b / src / com / sun / jna / overview . html 
 @ @ - 715 , 7 + 715 , 8 @ @ NOTE : When protected mode is enabled , you should make use of the jsig library , i 
 Using < a href = " # direct - mapping " > direct mapping < / a > of methods makes native 
 calls more efficiently than does interface mapping . Direct mapping does not 
 support varargs calls or arrays of Pointer , String , or WString as an argument 
 - or return value . 
 + or return value . For optimium results , use only primitive arguments and 
 + return values ; you ' ll have to convert to and from objects yourself explicitly . 
 < h3 > Avoid type mapping < / h3 > 
 Type mapping incurs additional overhead on each function call . You can avoid 
 this by ensuring that your arguments and / or return types are already primitive 
 diff - - git a / test / com / sun / jna / NativeLibraryTest . java b / test / com / sun / jna / NativeLibraryTest . java 
 index 73690ad . . 96b592b 100644 
 - - - a / test / com / sun / jna / NativeLibraryTest . java 
 + + + b / test / com / sun / jna / NativeLibraryTest . java 
 @ @ - 249 , 6 + 249 , 10 @ @ public class NativeLibraryTest extends TestCase { 
 Native . loadLibrary ( " testlib " , TestLibrary . class , options ) ; 
 } 
 
 + public void testEmbeddedLibrary ( ) { 
 + Native . loadLibrary ( " embedded - testlib " , TestLibrary . class ) ; 
 + } 
 + 
 public static void main ( String [ ] args ) { 
 junit . textui . TestRunner . run ( NativeLibraryTest . class ) ; 
 } 
 diff - - git a / test / com / sun / jna / NativeTest . java b / test / com / sun / jna / NativeTest . java 
 index e567f95 . . d3d7125 100644 
 - - - a / test / com / sun / jna / NativeTest . java 
 + + + b / test / com / sun / jna / NativeTest . java 
 @ @ - 245 , 50 + 245 , 50 @ @ public class NativeTest extends TestCase { 
 } 
 
 public void testOSPrefix ( ) { 
 - assertEquals ( " Wrong resource path " , " / com / sun / jna / win32 - x86 " , 
 - Native . getNativeLibraryResourcePath ( Platform . WINDOWS , 
 - " x86 " , " Windows " ) ) ; 
 - assertEquals ( " Wrong resource path Windows / i386 " , " / com / sun / jna / win32 - x86 " , 
 - Native . getNativeLibraryResourcePath ( Platform . WINDOWS , 
 - " i386 " , " Windows " ) ) ; 
 - assertEquals ( " Wrong resource path Windows CE / arm " , " / com / sun / jna / w32ce - arm " , 
 - Native . getNativeLibraryResourcePath ( Platform . WINDOWSCE , 
 - " arm " , " Windows CE " ) ) ; 
 - assertEquals ( " Wrong resource path Mac / x86 " , " / com / sun / jna / darwin " , 
 - Native . getNativeLibraryResourcePath ( Platform . MAC , 
 - " x86 " , " Darwin " ) ) ; 
 - assertEquals ( " Wrong resource path Mac / x86 _ 64 " , " / com / sun / jna / darwin " , 
 - Native . getNativeLibraryResourcePath ( Platform . MAC , 
 - " x86 _ 64 " , " Mac " ) ) ; 
 - assertEquals ( " Wrong resource path Solaris / sparc " , " / com / sun / jna / sunos - sparc " , 
 - Native . getNativeLibraryResourcePath ( Platform . SOLARIS , 
 - " sparc " , " Solaris " ) ) ; 
 - assertEquals ( " Wrong resource path SunOS / sparcv9 " , " / com / sun / jna / sunos - sparcv9 " , 
 - Native . getNativeLibraryResourcePath ( Platform . SOLARIS , 
 - " sparcv9 " , " SunOS " ) ) ; 
 - assertEquals ( " Wrong resource path Linux / i386 " , " / com / sun / jna / linux - i386 " , 
 - Native . getNativeLibraryResourcePath ( Platform . LINUX , 
 - " i386 " , " Linux / Gnu " ) ) ; 
 - assertEquals ( " Wrong resource path Linux / x86 " , " / com / sun / jna / linux - i386 " , 
 - Native . getNativeLibraryResourcePath ( Platform . LINUX , 
 - " x86 " , " Linux " ) ) ; 
 - assertEquals ( " Wrong resource path Linux / ppc " , " / com / sun / jna / linux - ppc " , 
 - Native . getNativeLibraryResourcePath ( Platform . LINUX , 
 - " powerpc " , " Linux " ) ) ; 
 - assertEquals ( " Wrong resource path OpenBSD / x86 " , " / com / sun / jna / openbsd - i386 " , 
 - Native . getNativeLibraryResourcePath ( Platform . OPENBSD , 
 - " x86 " , " OpenBSD " ) ) ; 
 - assertEquals ( " Wrong resource path FreeBSD / x86 " , " / com / sun / jna / freebsd - i386 " , 
 - Native . getNativeLibraryResourcePath ( Platform . FREEBSD , 
 - " x86 " , " FreeBSD " ) ) ; 
 - assertEquals ( " Wrong resource path Linux / armv7l ( android ) " , " / com / sun / jna / android - arm " , 
 - Native . getNativeLibraryResourcePath ( Platform . ANDROID , 
 - " armv7l " , " Linux " ) ) ; 
 - 
 - assertEquals ( " Wrong resource path other / other " , " / com / sun / jna / name - ppc " , 
 - Native . getNativeLibraryResourcePath ( Platform . UNSPECIFIED , 
 - " PowerPC " , " Name Of System " ) ) ; 
 - 
 + assertEquals ( " Wrong resource path " , " win32 - x86 " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . WINDOWS , 
 + " x86 " , " Windows " ) ) ; 
 + assertEquals ( " Wrong resource path Windows / i386 " , " win32 - x86 " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . WINDOWS , 
 + " i386 " , " Windows " ) ) ; 
 + assertEquals ( " Wrong resource path Windows CE / arm " , " w32ce - arm " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . WINDOWSCE , 
 + " arm " , " Windows CE " ) ) ; 
 + assertEquals ( " Wrong resource path Mac / x86 " , " darwin " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . MAC , 
 + " x86 " , " Darwin " ) ) ; 
 + assertEquals ( " Wrong resource path Mac / x86 _ 64 " , " darwin " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . MAC , 
 + " x86 _ 64 " , " Mac " ) ) ; 
 + assertEquals ( " Wrong resource path Solaris / sparc " , " sunos - sparc " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . SOLARIS , 
 + " sparc " , " Solaris " ) ) ; 
 + assertEquals ( " Wrong resource path SunOS / sparcv9 " , " sunos - sparcv9 " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . SOLARIS , 
 + " sparcv9 " , " SunOS " ) ) ; 
 + assertEquals ( " Wrong resource path Linux / i386 " , " linux - i386 " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . LINUX , 
 + " i386 " , " Linux / Gnu " ) ) ; 
 + assertEquals ( " Wrong resource path Linux / x86 " , " linux - i386 " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . LINUX , 
 + " x86 " , " Linux " ) ) ; 
 + assertEquals ( " Wrong resource path Linux / ppc " , " linux - ppc " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . LINUX , 
 + " powerpc " , " Linux " ) ) ; 
 + assertEquals ( " Wrong resource path OpenBSD / x86 " , " openbsd - i386 " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . OPENBSD , 
 + " x86 " , " OpenBSD " ) ) ; 
 + assertEquals ( " Wrong resource path FreeBSD / x86 " , " freebsd - i386 " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . FREEBSD , 
 + " x86 " , " FreeBSD " ) ) ; 
 + assertEquals ( " Wrong resource path Linux / armv7l ( android ) " , " android - arm " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . ANDROID , 
 + " armv7l " , " Linux " ) ) ; 
 + 
 + assertEquals ( " Wrong resource path other / other " , " name - ppc " , 
 + Native . getNativeLibraryResourcePrefix ( Platform . UNSPECIFIED , 
 + " PowerPC " , " Name Of System " ) ) ; 
 + 
 } 
 
 public static class DirectMapping { 
 @ @ - 338 , 10 + 338 , 11 @ @ public class NativeTest extends TestCase { 
 
 public void testRemoveTemporaries ( ) throws Exception { 
 File dir = Native . getTempDir ( ) ; 
 - File tmp = new File ( dir , " jna " ) ; 
 + File tmp = new File ( dir , Native . JNA _ TMPLIB _ PREFIX ) ; 
 tmp . delete ( ) ; 
 try { 
 assertTrue ( " Couldn ' t create temporary file " + tmp , tmp . createNewFile ( ) ) ; 
 + assertTrue ( " File isn ' t recognized as unpacked " , Native . isUnpacked ( tmp ) ) ; 
 Native . markTemporaryFile ( tmp ) ; 
 Native . removeTemporaryFiles ( ) ; 
 assertFalse ( " Temporary file still exists " , tmp . exists ( ) ) ; 
 diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java 
 index 8bd7ad3 . . 70a6edf 100644 
 - - - a / test / com / sun / jna / StructureTest . java 
 + + + b / test / com / sun / jna / StructureTest . java 
 @ @ - 66 , 6 + 66 , 20 @ @ public class StructureTest extends TestCase { 
 assertNotSame ( " Initial pointer should not be used directly : " + p , p , p1 ) ; 
 } 
 
 + public void testInitializeWithTypeMapper ( ) { 
 + class TestStructure extends Structure { 
 + public int field ; 
 + protected List getFieldOrder ( ) { 
 + return Arrays . asList ( new String [ ] { " field " } ) ; 
 + } 
 + public TestStructure ( TypeMapper m ) { 
 + super ( ALIGN _ DEFAULT , m ) ; 
 + } 
 + } 
 + TypeMapper m = new DefaultTypeMapper ( ) ; 
 + TestStructure s = new TestStructure ( m ) ; 
 + assertEquals ( " Type mapper not installed " , m , s . getTypeMapper ( ) ) ; 
 + } 
 
 / / must be public to populate array 
 public static class TestAllocStructure extends Structure {

NEAREST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index c19c48b . . d0032ee 100755 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 8 , 6 + 8 , 7 @ @ Features 
 * Automatic cleanup of native threads ( based on suggestions from neil smith ) - [ @ twall ] ( https : / / github . com / twall ) . 
 * Add android - arm target ( thanks to ochafik for initial work ) . 
 * Add ` jna . tmpdir ` to override temporary JNA storage location - [ @ twall ] ( https : / / github . com / twall ) . 
 + * Add EXTRA _ MAKE _ OPTS ant property to override make variables - [ @ twall ] ( https : / / github . com / twall ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 diff - - git a / build . xml b / build . xml 
 index c87f14c . . 9a3c453 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 622 , 6 + 622 , 10 @ @ osname = macos 
 < os name = " AIX " / > 
 < / or > 
 < / condition > 
 + < ! - - Allow explicit override of make variables - - > 
 + < condition property = " make . OPTS " value = " $ { EXTRA _ MAKE _ OPTS } " else = " IGNORE = " > 
 + < isset property = " EXTRA _ MAKE _ OPTS " / > 
 + < / condition > 
 < ! - - Native resource path within jna . jar - - > 
 < condition property = " native . path " value = " lib / armeabi " else = " com / sun / jna / $ { os . prefix } " > 
 < equals arg1 = " $ { os . prefix } " arg2 = " android - arm " / > 
 @ @ - 642 , 6 + 646 , 7 @ @ osname = macos 
 < arg value = " $ { make . ARCH } " / > 
 < arg value = " $ { make . PATH } " / > 
 < arg value = " $ { make . OS } " / > 
 + < arg line = " $ { make . OPTS } " / > 
 < arg value = " JNA _ JNI _ VERSION = $ { jni . version } " / > 
 < arg value = " CHECKSUM = $ { jni . md5 } " / > 
 < / exec > 
 diff - - git a / native / Makefile b / native / Makefile 
 index 4d4f505 . . 17b740c3 100644 
 - - - a / native / Makefile 
 + + + b / native / Makefile 
 @ @ - 29 , 7 + 29 , 7 @ @ 
 # The android build requires the android SDK + NDK for cross - compilation ; 
 # make the tools available on the path and compile with 
 # " ant - Dos . prefix = android - arm " . Put the NDK tools in the path and adjust 
 - # NDK _ PLATFORM below . 
 + # NDK _ PLATFORM below or set it in your environment . 
 # 
 
 # Systems which support POSIX signals may be able to support VM crash 
 @ @ - 113 , 7 + 113 , 7 @ @ RANLIB = arm - linux - androideabi - ranlib 
 STRIP = arm - linux - androideabi - strip - x 
 CDEFINES = - DNO _ JAWT - DNO _ WEAK _ GLOBALS - DFFI _ MMAP _ EXEC _ WRIT = 1 - DFFI _ MMAP _ EXEC _ SELINUX = 0 
 COPT + = - fpic - mthumb - interwork - ffunction - sections - funwind - tables - fstack - protector - fno - short - enums - march = armv5te - mtune = xscale - msoft - float 
 - NDK _ PLATFORM = / Developer / Applications / android - ndk - r7c / platforms / android - 14 
 + NDK _ PLATFORM ? = / Developer / Applications / android - ndk - r7c / platforms / android - 14 
 JAVA _ INCLUDES = 
 CINCLUDES + = - I " $ ( NDK _ PLATFORM ) / arch - arm / usr / include " # - I / usr / include 
 LIBS = - nostdlib - L " $ ( NDK _ PLATFORM ) / arch - arm / usr / lib / " - lgcc - lc - ldl - lm
