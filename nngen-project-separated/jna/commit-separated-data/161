BLEU SCORE: 0.0130429800193758

TEST MSG: Thread Implementation that runs a Windows Message Loop
GENERATED MSG: [ user32 ] added mappings to RegisterHotKey and UnregisterHotKey functions used for Global Hotkeys

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / User32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / User32 . java <nl> index 37dc3c8 . . 0f67e59 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / User32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / User32 . java <nl> @ @ - 789 , 6 + 789 , 46 @ @ public interface User32 extends StdCallLibrary , WinUser , WinNT { <nl> void PostMessage ( HWND hWnd , int msg , WPARAM wParam , LPARAM lParam ) ; <nl> <nl> / * * <nl> + * Posts a message to the message queue of the specified thread . It returns <nl> + * without waiting for the thread to process the message . <nl> + * <nl> + * @ param idThread The identifier of the thread to which the message is to <nl> + * be posted . <nl> + * <nl> + * < p > The function fails if the specified thread does not have a <nl> + * message queue . The system creates a thread ' s message queue when the <nl> + * thread makes its first call to one of the User or GDI functions . < / p > <nl> + * <nl> + * < p > Message posting is subject to UIPI . The thread of a process can post <nl> + * messages only to posted - message queues of threads in processes of lesser <nl> + * or equal integrity level . < / p > <nl> + * <nl> + * < p > This thread must have the SE _ TCB _ NAME privilege to post a message to a <nl> + * thread that belongs to a process with the same locally unique identifier <nl> + * ( LUID ) but is in a different desktop . Otherwise , the function fails <nl> + * and returns ERROR _ INVALID _ THREAD _ ID . < / p > <nl> + * <nl> + * < p > This thread must either belong to the same desktop as the calling <nl> + * thread or to a process with the same LUID . Otherwise , the function <nl> + * fails and returns ERROR _ INVALID _ THREAD _ ID . < / p > <nl> + * <nl> + * @ param Msg The type of message to be posted . <nl> + * <nl> + * @ param wParam Additional message - specific information . <nl> + * <nl> + * @ param lParam Additional message - specific information . <nl> + * <nl> + * @ return If the function succeeds , the return value is nonzero . <nl> + * <nl> + * < p > If the function fails , the return value is zero . To get extended error <nl> + * information , call GetLastError . < / p > < p > GetLastError returns <nl> + * ERROR _ INVALID _ THREAD _ ID if idThread is not a valid thread identifier , or <nl> + * if the thread specified by idThread does not have a message queue . < / p > <nl> + * < p > GetLastError returns ERROR _ NOT _ ENOUGH _ QUOTA when the message limit is hit . < / p > <nl> + * / <nl> + int PostThreadMessage ( int idThread , int Msg , WPARAM wParam , LPARAM lParam ) ; <nl> + <nl> + / * * <nl> * This function indicates to Windows that a thread has made a request to <nl> * terminate ( quit ) . It is typically used in response to a WM _ DESTROY <nl> * message . <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / User32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / User32Util . java <nl> index ef43290 . . f0ebf67 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / User32Util . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / User32Util . java <nl> @ @ - 16 , 8 + 16 , 20 @ @ import com . sun . jna . platform . win32 . WinDef . HINSTANCE ; <nl> import com . sun . jna . platform . win32 . WinDef . HMENU ; <nl> import com . sun . jna . platform . win32 . WinDef . HWND ; <nl> import com . sun . jna . platform . win32 . WinDef . LPVOID ; <nl> + import com . sun . jna . platform . win32 . WinUser . MSG ; <nl> import com . sun . jna . platform . win32 . WinUser . RAWINPUTDEVICELIST ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> + import java . lang . reflect . InvocationHandler ; <nl> + import java . lang . reflect . InvocationTargetException ; <nl> + import java . lang . reflect . Method ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . concurrent . Callable ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + import java . util . concurrent . Future ; <nl> + import java . util . concurrent . FutureTask ; <nl> + import java . util . logging . Level ; <nl> + import java . util . logging . Logger ; <nl> <nl> <nl> / * * <nl> @ @ - 76 , 4 + 88 , 131 @ @ public final class User32Util { <nl> <nl> return Arrays . asList ( records ) ; <nl> } <nl> + <nl> + / * * <nl> + * Helper class , that runs a windows message loop as a seperate thread . <nl> + * <nl> + * This is intended to be used in conjunction with APIs , that need a <nl> + * spinning message loop . One example for this are the DDE functions , that <nl> + * can only be used if a message loop is present . <nl> + * <nl> + * To enable interaction with the mainloop the MessageLoopThread allows to <nl> + * dispatch callables into the mainloop and let these Callables be invoked <nl> + * on the message thread . <nl> + * <nl> + * This implies , that the Callables should block the loop as short as possible . <nl> + * / <nl> + public static class MessageLoopThread extends Thread { <nl> + <nl> + public class Handler implements InvocationHandler { <nl> + <nl> + private final Object delegate ; <nl> + <nl> + public Handler ( Object delegate ) { <nl> + this . delegate = delegate ; <nl> + } <nl> + <nl> + public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { <nl> + try { <nl> + return MessageLoopThread . this . runOnThread ( new Callable < Object > ( ) { <nl> + public Object call ( ) throws Exception { <nl> + return method . invoke ( delegate , args ) ; <nl> + } <nl> + } ) ; <nl> + } catch ( InvocationTargetException ex ) { <nl> + Throwable cause = ex . getCause ( ) ; <nl> + if ( cause instanceof Exception ) { <nl> + StackTraceElement [ ] hiddenStack = cause . getStackTrace ( ) ; <nl> + cause . fillInStackTrace ( ) ; <nl> + StackTraceElement [ ] currentStack = cause . getStackTrace ( ) ; <nl> + StackTraceElement [ ] fullStack = new StackTraceElement [ currentStack . length + hiddenStack . length ] ; <nl> + System . arraycopy ( hiddenStack , 0 , fullStack , 0 , hiddenStack . length ) ; <nl> + System . arraycopy ( currentStack , 0 , fullStack , hiddenStack . length , currentStack . length ) ; <nl> + cause . setStackTrace ( fullStack ) ; <nl> + throw ( Exception ) cause ; <nl> + } else { <nl> + throw ex ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + private volatile int nativeThreadId = 0 ; <nl> + private volatile long javaThreadId = 0 ; <nl> + private final List < FutureTask > workQueue = Collections . synchronizedList ( new ArrayList < FutureTask > ( ) ) ; <nl> + <nl> + @ Override <nl> + public void run ( ) { <nl> + MSG msg = new WinUser . MSG ( ) ; <nl> + <nl> + / / Make sure message loop is prepared <nl> + User32 . INSTANCE . PeekMessage ( msg , null , 0 , 0 , 0 ) ; <nl> + javaThreadId = Thread . currentThread ( ) . getId ( ) ; <nl> + nativeThreadId = Kernel32 . INSTANCE . GetCurrentThreadId ( ) ; <nl> + <nl> + while ( User32 . INSTANCE . GetMessage ( msg , null , 0 , 0 ) ! = 0 ) { <nl> + while ( ! workQueue . isEmpty ( ) ) { <nl> + try { <nl> + FutureTask ft = workQueue . remove ( 0 ) ; <nl> + ft . run ( ) ; <nl> + } catch ( IndexOutOfBoundsException ex ) { <nl> + break ; <nl> + } <nl> + } <nl> + User32 . INSTANCE . TranslateMessage ( msg ) ; <nl> + User32 . INSTANCE . DispatchMessage ( msg ) ; <nl> + } <nl> + <nl> + while ( ! workQueue . isEmpty ( ) ) { <nl> + workQueue . remove ( 0 ) . cancel ( false ) ; <nl> + } <nl> + } <nl> + <nl> + public < V > Future < V > runAsync ( Callable < V > command ) { <nl> + while ( nativeThreadId = = 0 ) { <nl> + try { <nl> + Thread . sleep ( 20 ) ; <nl> + } catch ( InterruptedException ex ) { <nl> + Logger . getLogger ( MessageLoopThread . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; <nl> + } <nl> + } <nl> + FutureTask < V > futureTask = new FutureTask < V > ( command ) ; <nl> + workQueue . add ( futureTask ) ; <nl> + User32 . INSTANCE . PostThreadMessage ( nativeThreadId , WinUser . WM _ USER , null , null ) ; <nl> + return futureTask ; <nl> + } <nl> + <nl> + public < V > V runOnThread ( Callable < V > callable ) throws Exception { <nl> + while ( javaThreadId = = 0 ) { <nl> + try { <nl> + Thread . sleep ( 20 ) ; <nl> + } catch ( InterruptedException ex ) { <nl> + Logger . getLogger ( MessageLoopThread . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; <nl> + } <nl> + } <nl> + <nl> + if ( javaThreadId = = Thread . currentThread ( ) . getId ( ) ) { <nl> + return callable . call ( ) ; <nl> + } else { <nl> + <nl> + Future < V > ft = runAsync ( callable ) ; <nl> + try { <nl> + return ft . get ( ) ; <nl> + } catch ( InterruptedException ex ) { <nl> + throw ex ; <nl> + } catch ( ExecutionException ex ) { <nl> + Throwable cause = ex . getCause ( ) ; <nl> + if ( cause instanceof Exception ) { <nl> + throw ( Exception ) cause ; <nl> + } else { <nl> + throw ex ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + public void exit ( ) { <nl> + User32 . INSTANCE . PostThreadMessage ( nativeThreadId , WinUser . WM _ QUIT , null , null ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinUser . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinUser . java <nl> index df254fd . . cbf0beb 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinUser . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinUser . java <nl> @ @ - 543 , 6 + 543 , 12 @ @ public interface WinUser extends WinDef { <nl> * associated with the thread that registered the hot key . <nl> * / <nl> int WM _ HOTKEY = 0x0312 ; <nl> + <nl> + / * * <nl> + * Used to define private messages for use by private window classes , <nl> + * usually of the form WM _ USER + x , where x is an integer value . <nl> + * / <nl> + int WM _ USER = 0x0400 ; <nl> <nl> int WM _ KEYUP = 257 ; <nl> int WM _ SYSKEYDOWN = 260 ;
NEAREST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / unix / X11 . java b / contrib / platform / src / com / sun / jna / platform / unix / X11 . java <nl> index 42931ca . . 529d018 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / unix / X11 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / unix / X11 . java <nl> @ @ - 12 , 14 + 12 , 7 @ @ <nl> * / <nl> package com . sun . jna . platform . unix ; <nl> <nl> - import com . sun . jna . FromNativeContext ; <nl> - import com . sun . jna . Library ; <nl> - import com . sun . jna . Native ; <nl> - import com . sun . jna . NativeLong ; <nl> - import com . sun . jna . Pointer ; <nl> - import com . sun . jna . PointerType ; <nl> - import com . sun . jna . Structure ; <nl> - import com . sun . jna . Union ; <nl> + import com . sun . jna . * ; <nl> import com . sun . jna . ptr . ByReference ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> import com . sun . jna . ptr . NativeLongByReference ; <nl> @ @ - 1768 , 6 + 1761 , 18 @ @ public interface X11 extends Library { <nl> int width , int height ) ; <nl> int XDestroyImage ( XImage image ) ; <nl> <nl> + / * * <nl> + * Installs an error handler <nl> + * <nl> + * @ param handler Specifies the program ' s supplied error handler <nl> + * @ return The previous error handler <nl> + * / <nl> + XErrorHandler XSetErrorHandler ( XErrorHandler handler ) ; <nl> + <nl> + public interface XErrorHandler extends Callback { <nl> + public int apply ( Display display , XErrorEvent errorEvent ) ; <nl> + } <nl> + <nl> <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> * KeySyms , Keycodes , Keymaps <nl> @ @ - 1778 , 6 + 1783 , 33 @ @ public interface X11 extends Library { <nl> byte XKeysymToKeycode ( Display display , KeySym keysym ) ; <nl> KeySym XKeycodeToKeysym ( Display display , byte keycode , int index ) ; <nl> <nl> + / * * <nl> + * Establishes a passive grab on the keyboard <nl> + * <nl> + * @ param display Specifies the connection to the X server . <nl> + * @ param keyCode Specifies the KeyCode or { @ link # AnyKey } . <nl> + * @ param modifiers Specifies the set of keymasks or { @ link # AnyModifier } . <nl> + * The mask is the bitwise inclusive OR of the valid keymask bits . <nl> + * @ param grab _ window Specifies the grab window . <nl> + * @ param ownerEvents Specifies a Boolean value that indicates whether the keyboard events are to be reported as usual . <nl> + * @ param pointerMode Specifies further processing of pointer events . You can pass { @ link # GrabModeSync } or { @ link # GrabModeAsync } . <nl> + * @ param keyBoardMode Specifies further processing of keyboard events . You can pass { @ link # GrabModeSync } or { @ link # GrabModeAsync } . <nl> + * @ return nothing <nl> + * / <nl> + int XGrabKey ( Display display , int keyCode , int modifiers , Window grab _ window , int ownerEvents , int pointerMode , int keyBoardMode ) ; <nl> + <nl> + / * * <nl> + * The XUngrabKey ( ) function releases the key combination on the specified window if it was grabbed by this client . <nl> + * <nl> + * @ param display Specifies the connection to the X server . <nl> + * @ param keyCode Specifies the KeyCode or { @ link # AnyKey } . <nl> + * @ param modifiers Specifies the set of keymasks or { @ link # AnyModifier } . <nl> + * The mask is the bitwise inclusive OR of the valid keymask bits <nl> + * @ param grab _ window Specifies the grab window . <nl> + * @ return nothing <nl> + * / <nl> + int XUngrabKey ( Display display , int keyCode , int modifiers , Window grab _ window ) ; <nl> + <nl> / / int XChangeKeyboardMapping ( Display display , int first _ keycode , int keysyms _ per _ keycode , KeySym * keysyms , int num _ codes ) ; <nl> / * * Defines the symbols for the specified number of KeyCodes starting with first _ keycode . The symbols for KeyCodes outside this range remain unchanged . The number of elements in keysyms must be : num _ codes * keysyms _ per _ keycode . The specified first _ keycode must be greater than or equal to min _ keycode returned by XDisplayKeycodes , or a BadValue error results . In addition , the following expression must be less than or equal to max _ keycode as returned by XDisplayKeycodes , or a BadValue error results : first _ keycode + num _ codes - 1 . * / <nl> int XChangeKeyboardMapping ( Display display , int first _ keycode , int keysyms _ per _ keycode , KeySym [ ] keysyms , int num _ codes ) ;

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / User32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / User32 . java 
 index 37dc3c8 . . 0f67e59 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / User32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / User32 . java 
 @ @ - 789 , 6 + 789 , 46 @ @ public interface User32 extends StdCallLibrary , WinUser , WinNT { 
 void PostMessage ( HWND hWnd , int msg , WPARAM wParam , LPARAM lParam ) ; 
 
 / * * 
 + * Posts a message to the message queue of the specified thread . It returns 
 + * without waiting for the thread to process the message . 
 + * 
 + * @ param idThread The identifier of the thread to which the message is to 
 + * be posted . 
 + * 
 + * < p > The function fails if the specified thread does not have a 
 + * message queue . The system creates a thread ' s message queue when the 
 + * thread makes its first call to one of the User or GDI functions . < / p > 
 + * 
 + * < p > Message posting is subject to UIPI . The thread of a process can post 
 + * messages only to posted - message queues of threads in processes of lesser 
 + * or equal integrity level . < / p > 
 + * 
 + * < p > This thread must have the SE _ TCB _ NAME privilege to post a message to a 
 + * thread that belongs to a process with the same locally unique identifier 
 + * ( LUID ) but is in a different desktop . Otherwise , the function fails 
 + * and returns ERROR _ INVALID _ THREAD _ ID . < / p > 
 + * 
 + * < p > This thread must either belong to the same desktop as the calling 
 + * thread or to a process with the same LUID . Otherwise , the function 
 + * fails and returns ERROR _ INVALID _ THREAD _ ID . < / p > 
 + * 
 + * @ param Msg The type of message to be posted . 
 + * 
 + * @ param wParam Additional message - specific information . 
 + * 
 + * @ param lParam Additional message - specific information . 
 + * 
 + * @ return If the function succeeds , the return value is nonzero . 
 + * 
 + * < p > If the function fails , the return value is zero . To get extended error 
 + * information , call GetLastError . < / p > < p > GetLastError returns 
 + * ERROR _ INVALID _ THREAD _ ID if idThread is not a valid thread identifier , or 
 + * if the thread specified by idThread does not have a message queue . < / p > 
 + * < p > GetLastError returns ERROR _ NOT _ ENOUGH _ QUOTA when the message limit is hit . < / p > 
 + * / 
 + int PostThreadMessage ( int idThread , int Msg , WPARAM wParam , LPARAM lParam ) ; 
 + 
 + / * * 
 * This function indicates to Windows that a thread has made a request to 
 * terminate ( quit ) . It is typically used in response to a WM _ DESTROY 
 * message . 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / User32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / User32Util . java 
 index ef43290 . . f0ebf67 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / User32Util . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / User32Util . java 
 @ @ - 16 , 8 + 16 , 20 @ @ import com . sun . jna . platform . win32 . WinDef . HINSTANCE ; 
 import com . sun . jna . platform . win32 . WinDef . HMENU ; 
 import com . sun . jna . platform . win32 . WinDef . HWND ; 
 import com . sun . jna . platform . win32 . WinDef . LPVOID ; 
 + import com . sun . jna . platform . win32 . WinUser . MSG ; 
 import com . sun . jna . platform . win32 . WinUser . RAWINPUTDEVICELIST ; 
 import com . sun . jna . ptr . IntByReference ; 
 + import java . lang . reflect . InvocationHandler ; 
 + import java . lang . reflect . InvocationTargetException ; 
 + import java . lang . reflect . Method ; 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . concurrent . Callable ; 
 + import java . util . concurrent . ExecutionException ; 
 + import java . util . concurrent . Future ; 
 + import java . util . concurrent . FutureTask ; 
 + import java . util . logging . Level ; 
 + import java . util . logging . Logger ; 
 
 
 / * * 
 @ @ - 76 , 4 + 88 , 131 @ @ public final class User32Util { 
 
 return Arrays . asList ( records ) ; 
 } 
 + 
 + / * * 
 + * Helper class , that runs a windows message loop as a seperate thread . 
 + * 
 + * This is intended to be used in conjunction with APIs , that need a 
 + * spinning message loop . One example for this are the DDE functions , that 
 + * can only be used if a message loop is present . 
 + * 
 + * To enable interaction with the mainloop the MessageLoopThread allows to 
 + * dispatch callables into the mainloop and let these Callables be invoked 
 + * on the message thread . 
 + * 
 + * This implies , that the Callables should block the loop as short as possible . 
 + * / 
 + public static class MessageLoopThread extends Thread { 
 + 
 + public class Handler implements InvocationHandler { 
 + 
 + private final Object delegate ; 
 + 
 + public Handler ( Object delegate ) { 
 + this . delegate = delegate ; 
 + } 
 + 
 + public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { 
 + try { 
 + return MessageLoopThread . this . runOnThread ( new Callable < Object > ( ) { 
 + public Object call ( ) throws Exception { 
 + return method . invoke ( delegate , args ) ; 
 + } 
 + } ) ; 
 + } catch ( InvocationTargetException ex ) { 
 + Throwable cause = ex . getCause ( ) ; 
 + if ( cause instanceof Exception ) { 
 + StackTraceElement [ ] hiddenStack = cause . getStackTrace ( ) ; 
 + cause . fillInStackTrace ( ) ; 
 + StackTraceElement [ ] currentStack = cause . getStackTrace ( ) ; 
 + StackTraceElement [ ] fullStack = new StackTraceElement [ currentStack . length + hiddenStack . length ] ; 
 + System . arraycopy ( hiddenStack , 0 , fullStack , 0 , hiddenStack . length ) ; 
 + System . arraycopy ( currentStack , 0 , fullStack , hiddenStack . length , currentStack . length ) ; 
 + cause . setStackTrace ( fullStack ) ; 
 + throw ( Exception ) cause ; 
 + } else { 
 + throw ex ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + private volatile int nativeThreadId = 0 ; 
 + private volatile long javaThreadId = 0 ; 
 + private final List < FutureTask > workQueue = Collections . synchronizedList ( new ArrayList < FutureTask > ( ) ) ; 
 + 
 + @ Override 
 + public void run ( ) { 
 + MSG msg = new WinUser . MSG ( ) ; 
 + 
 + / / Make sure message loop is prepared 
 + User32 . INSTANCE . PeekMessage ( msg , null , 0 , 0 , 0 ) ; 
 + javaThreadId = Thread . currentThread ( ) . getId ( ) ; 
 + nativeThreadId = Kernel32 . INSTANCE . GetCurrentThreadId ( ) ; 
 + 
 + while ( User32 . INSTANCE . GetMessage ( msg , null , 0 , 0 ) ! = 0 ) { 
 + while ( ! workQueue . isEmpty ( ) ) { 
 + try { 
 + FutureTask ft = workQueue . remove ( 0 ) ; 
 + ft . run ( ) ; 
 + } catch ( IndexOutOfBoundsException ex ) { 
 + break ; 
 + } 
 + } 
 + User32 . INSTANCE . TranslateMessage ( msg ) ; 
 + User32 . INSTANCE . DispatchMessage ( msg ) ; 
 + } 
 + 
 + while ( ! workQueue . isEmpty ( ) ) { 
 + workQueue . remove ( 0 ) . cancel ( false ) ; 
 + } 
 + } 
 + 
 + public < V > Future < V > runAsync ( Callable < V > command ) { 
 + while ( nativeThreadId = = 0 ) { 
 + try { 
 + Thread . sleep ( 20 ) ; 
 + } catch ( InterruptedException ex ) { 
 + Logger . getLogger ( MessageLoopThread . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; 
 + } 
 + } 
 + FutureTask < V > futureTask = new FutureTask < V > ( command ) ; 
 + workQueue . add ( futureTask ) ; 
 + User32 . INSTANCE . PostThreadMessage ( nativeThreadId , WinUser . WM _ USER , null , null ) ; 
 + return futureTask ; 
 + } 
 + 
 + public < V > V runOnThread ( Callable < V > callable ) throws Exception { 
 + while ( javaThreadId = = 0 ) { 
 + try { 
 + Thread . sleep ( 20 ) ; 
 + } catch ( InterruptedException ex ) { 
 + Logger . getLogger ( MessageLoopThread . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; 
 + } 
 + } 
 + 
 + if ( javaThreadId = = Thread . currentThread ( ) . getId ( ) ) { 
 + return callable . call ( ) ; 
 + } else { 
 + 
 + Future < V > ft = runAsync ( callable ) ; 
 + try { 
 + return ft . get ( ) ; 
 + } catch ( InterruptedException ex ) { 
 + throw ex ; 
 + } catch ( ExecutionException ex ) { 
 + Throwable cause = ex . getCause ( ) ; 
 + if ( cause instanceof Exception ) { 
 + throw ( Exception ) cause ; 
 + } else { 
 + throw ex ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + public void exit ( ) { 
 + User32 . INSTANCE . PostThreadMessage ( nativeThreadId , WinUser . WM _ QUIT , null , null ) ; 
 + } 
 + } 
 } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinUser . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinUser . java 
 index df254fd . . cbf0beb 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinUser . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinUser . java 
 @ @ - 543 , 6 + 543 , 12 @ @ public interface WinUser extends WinDef { 
 * associated with the thread that registered the hot key . 
 * / 
 int WM _ HOTKEY = 0x0312 ; 
 + 
 + / * * 
 + * Used to define private messages for use by private window classes , 
 + * usually of the form WM _ USER + x , where x is an integer value . 
 + * / 
 + int WM _ USER = 0x0400 ; 
 
 int WM _ KEYUP = 257 ; 
 int WM _ SYSKEYDOWN = 260 ;

NEAREST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / unix / X11 . java b / contrib / platform / src / com / sun / jna / platform / unix / X11 . java 
 index 42931ca . . 529d018 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / unix / X11 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / unix / X11 . java 
 @ @ - 12 , 14 + 12 , 7 @ @ 
 * / 
 package com . sun . jna . platform . unix ; 
 
 - import com . sun . jna . FromNativeContext ; 
 - import com . sun . jna . Library ; 
 - import com . sun . jna . Native ; 
 - import com . sun . jna . NativeLong ; 
 - import com . sun . jna . Pointer ; 
 - import com . sun . jna . PointerType ; 
 - import com . sun . jna . Structure ; 
 - import com . sun . jna . Union ; 
 + import com . sun . jna . * ; 
 import com . sun . jna . ptr . ByReference ; 
 import com . sun . jna . ptr . IntByReference ; 
 import com . sun . jna . ptr . NativeLongByReference ; 
 @ @ - 1768 , 6 + 1761 , 18 @ @ public interface X11 extends Library { 
 int width , int height ) ; 
 int XDestroyImage ( XImage image ) ; 
 
 + / * * 
 + * Installs an error handler 
 + * 
 + * @ param handler Specifies the program ' s supplied error handler 
 + * @ return The previous error handler 
 + * / 
 + XErrorHandler XSetErrorHandler ( XErrorHandler handler ) ; 
 + 
 + public interface XErrorHandler extends Callback { 
 + public int apply ( Display display , XErrorEvent errorEvent ) ; 
 + } 
 + 
 
 / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * KeySyms , Keycodes , Keymaps 
 @ @ - 1778 , 6 + 1783 , 33 @ @ public interface X11 extends Library { 
 byte XKeysymToKeycode ( Display display , KeySym keysym ) ; 
 KeySym XKeycodeToKeysym ( Display display , byte keycode , int index ) ; 
 
 + / * * 
 + * Establishes a passive grab on the keyboard 
 + * 
 + * @ param display Specifies the connection to the X server . 
 + * @ param keyCode Specifies the KeyCode or { @ link # AnyKey } . 
 + * @ param modifiers Specifies the set of keymasks or { @ link # AnyModifier } . 
 + * The mask is the bitwise inclusive OR of the valid keymask bits . 
 + * @ param grab _ window Specifies the grab window . 
 + * @ param ownerEvents Specifies a Boolean value that indicates whether the keyboard events are to be reported as usual . 
 + * @ param pointerMode Specifies further processing of pointer events . You can pass { @ link # GrabModeSync } or { @ link # GrabModeAsync } . 
 + * @ param keyBoardMode Specifies further processing of keyboard events . You can pass { @ link # GrabModeSync } or { @ link # GrabModeAsync } . 
 + * @ return nothing 
 + * / 
 + int XGrabKey ( Display display , int keyCode , int modifiers , Window grab _ window , int ownerEvents , int pointerMode , int keyBoardMode ) ; 
 + 
 + / * * 
 + * The XUngrabKey ( ) function releases the key combination on the specified window if it was grabbed by this client . 
 + * 
 + * @ param display Specifies the connection to the X server . 
 + * @ param keyCode Specifies the KeyCode or { @ link # AnyKey } . 
 + * @ param modifiers Specifies the set of keymasks or { @ link # AnyModifier } . 
 + * The mask is the bitwise inclusive OR of the valid keymask bits 
 + * @ param grab _ window Specifies the grab window . 
 + * @ return nothing 
 + * / 
 + int XUngrabKey ( Display display , int keyCode , int modifiers , Window grab _ window ) ; 
 + 
 / / int XChangeKeyboardMapping ( Display display , int first _ keycode , int keysyms _ per _ keycode , KeySym * keysyms , int num _ codes ) ; 
 / * * Defines the symbols for the specified number of KeyCodes starting with first _ keycode . The symbols for KeyCodes outside this range remain unchanged . The number of elements in keysyms must be : num _ codes * keysyms _ per _ keycode . The specified first _ keycode must be greater than or equal to min _ keycode returned by XDisplayKeycodes , or a BadValue error results . In addition , the following expression must be less than or equal to max _ keycode as returned by XDisplayKeycodes , or a BadValue error results : first _ keycode + num _ codes - 1 . * / 
 int XChangeKeyboardMapping ( Display display , int first _ keycode , int keysyms _ per _ keycode , KeySym [ ] keysyms , int num _ codes ) ;
