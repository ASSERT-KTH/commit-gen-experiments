BLEU SCORE: 0.09688464563433238

TEST MSG: Add Ole32 Functions :
GENERATED MSG: Add version docs and test .

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Ole32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Ole32 . java <nl> index 7ce2eb1 . . bb3480a 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Ole32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Ole32 . java <nl> @ @ - 352 , 4 + 352 , 117 @ @ public interface Ole32 extends StdCallLibrary { <nl> * / <nl> boolean CoIsHandlerConnected ( Pointer pUnk ) ; <nl> <nl> + <nl> + / * * <nl> + * Initializes the COM library on the current apartment , identifies the <nl> + * concurrency model as single - thread apartment ( STA ) , and enables <nl> + * additional functionality described in the Remarks section below . <nl> + * Applications must initialize the COM library before they can call COM <nl> + * library functions other than CoGetMalloc and memory allocation functions . <nl> + * @ param pvReserved Reserved ; must be null . <nl> + * @ return { @ link WinError # S _ OK S _ OK } if the COM library and additional functionality were <nl> + * initialized successfully on this apartment . < p > <nl> + * { @ link WinError # S _ FALSE S _ FALSE } if the COM library is already initialized on this apartment . < p > <nl> + * { @ link WinError # OLE _ E _ WRONGCOMPOBJ OLE _ E _ WRONGCOMPOBJ } if the versions of COMPOBJ . DLL and OLE2 . DLL on <nl> + * your machine are incompatible with each other . < p > <nl> + * { @ link WinError # RPC _ E _ CHANGED _ MODE RPC _ E _ CHANGED _ MODE } if a previous call to CoInitializeEx specified <nl> + * the concurrency model for this apartment as <nl> + * multithread apartment ( MTA ) . If running <nl> + * Windows 2000 , this could also mean that a <nl> + * change from neutral threaded apartment to <nl> + * single threaded apartment occurred . <nl> + * / <nl> + HRESULT OleInitialize ( Pointer pvReserved ) ; <nl> + <nl> + / * * <nl> + * Closes the COM library on the apartment , releases any class factories , <nl> + * other COM objects , or servers held by the apartment , disables RPC on the <nl> + * apartment , and frees any resources the apartment maintains . <nl> + * <nl> + * Remarks : <nl> + * Call OleUninitialize on application shutdown , as the last COM library <nl> + * call , if the apartment was initialized with a call to <nl> + * { @ link # OleInitialize } . OleUninitialize calls the CoUninitialize function <nl> + * internally to shut down the OLE Component Object ( COM ) Library . <nl> + * <nl> + * If the COM library was initialized on the apartment with a call to <nl> + * CoInitialize or CoInitializeEx , it must be closed with a call to <nl> + * CoUninitialize . <nl> + * <nl> + * The { @ link # OleInitialize } and OleUninitialize calls must be balanced â€” <nl> + * if there are multiple calls to the { @ link # OleInitialize } function , there <nl> + * must be the same number of calls to OleUninitialize : Only the <nl> + * OleUninitialize call corresponding to the { @ link # OleInitialize } call <nl> + * that actually initialized the library can close it . <nl> + * / <nl> + void OleUninitialize ( ) ; <nl> + <nl> + / * * <nl> + * Carries out the clipboard shutdown sequence . It also releases the <nl> + * IDataObject pointer that was placed on the clipboard by the <nl> + * OleSetClipboard function . <nl> + * @ return { @ link WinError # S _ OK S _ OK } on success . < p > <nl> + * { @ link WinError # CLIPBRD _ E _ CANT _ OPEN CLIPBRD _ E _ CANT _ OPEN } The Windows OpenClipboard function used <nl> + * within OleFlushClipboard failed . < p > <nl> + * { @ link WinError # CLIPBRD _ E _ CANT _ CLOSE CLIPBRD _ E _ CANT _ CLOSE } The Windows CloseClipboard function used <nl> + * within OleFlushClipboard failed . < p > <nl> + * < b > Remarks < / b > < p > <nl> + * OleFlushClipboard renders the data from a data object onto the clipboard <nl> + * and releases the IDataObject pointer to the data object . While the <nl> + * application that put the data object on the clipboard is running , the <nl> + * clipboard holds only a pointer to the data object , thus saving memory . <nl> + * If you are writing an application that acts as the source of a clipboard <nl> + * operation , you can call the OleFlushClipboard function when your <nl> + * application is closed , such as when the user exits from your application . <nl> + * Calling OleFlushClipboard enables pasting and paste - linking of OLE <nl> + * objects after application shutdown . <nl> + * Before calling OleFlushClipboard , you can easily determine if your data <nl> + * is still on the clipboard with a call to the OleIsCurrentClipboard <nl> + * function . <nl> + * <nl> + * OleFlushClipboard leaves all formats offered by the data transfer object , <nl> + * including the OLE 1 compatibility formats , on the clipboard so they are <nl> + * available after application shutdown . In addition to OLE 1 compatibility <nl> + * formats , these include all formats offered on a global handle medium ( all <nl> + * except for TYMED _ FILE ) and formatted with a null target device . For <nl> + * example , if a data - source application offers a particular clipboard <nl> + * format ( say cfFOO ) on an IStorage object , and calls the OleFlushClipboard <nl> + * function , the storage object is copied into memory and the hglobal memory <nl> + * handle is put on the clipboard . <nl> + * <nl> + * To retrieve the information on the clipboard , you can call the <nl> + * OleGetClipboard function from another application , which creates a <nl> + * default data object , and the hglobal from the clipboard again becomes a <nl> + * storage object . Furthermore , the FORMATETC enumerator and the <nl> + * IDataObject : : QueryGetData method would all correctly indicate that the <nl> + * original clipboard format ( cfFOO ) is again available on a TYMED _ ISTORAGE . <nl> + * <nl> + * To empty the clipboard , call the OleSetClipboard function specifying a <nl> + * null value for its parameter . The application should call this when it <nl> + * closes if there is no need to leave data on the clipboard after shutdown , <nl> + * or if data will be placed on the clipboard using the standard Windows <nl> + * clipboard functions . <nl> + * / <nl> + HRESULT OleFlushClipboard ( ) ; <nl> + <nl> + / * * <nl> + * Puts an OLE compound document object into the running state . <nl> + * @ param pUnknown [ in ] Pointer to the { @ link IUnknown IUnknown } interface <nl> + * on the object , with which it will query for a pointer to <nl> + * the IRunnableObject interface , and then call its Run method . <nl> + * @ return This function returns on success . <nl> + * Other possible values include the following . < p > <nl> + * { @ link WinError # OLE _ E _ CLASSDIFF OLE _ E _ CLASSDIFF } The source of an <nl> + * OLE link has been converted to a different class . < p > <nl> + * < B > Remarks < / B > < p > <nl> + * The OleRun function puts an object in the running state . The <nl> + * implementation of OleRun was changed in OLE 2 . 01 to coincide with the <nl> + * publication of the IRunnableObject interface . You can use OleRun and <nl> + * IRunnableObject : : Run interchangeably . OleRun queries the object for a <nl> + * pointer to IRunnableObject . If successful , the function returns the <nl> + * results of calling the IRunnableObject : : Run method . < p > < p > <nl> + * For more information on using this function , see IRunnableObject : : Run . <nl> + * / <nl> + HRESULT OleRun ( Pointer pUnknown ) ; <nl> + <nl> } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Ole32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Ole32Test . java <nl> index 73ce524 . . 3cae808 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Ole32Test . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Ole32Test . java <nl> @ @ - 126 , 4 + 126 , 16 @ @ public class Ole32Test extends TestCase { <nl> <nl> Ole32 . INSTANCE . CoTaskMemFree ( ptr ) ; <nl> } <nl> + <nl> + public void testOleFunctions ( ) { <nl> + HRESULT initResult = Ole32 . INSTANCE . OleInitialize ( Pointer . NULL ) ; <nl> + <nl> + assertTrue ( W32Errors . SUCCEEDED ( initResult ) ) ; <nl> + <nl> + / / For a real test , a test component will be needed <nl> + Ole32 . INSTANCE . OleFlushClipboard ( ) ; <nl> + Ole32 . INSTANCE . OleRun ( Pointer . NULL ) ; <nl> + <nl> + Ole32 . INSTANCE . CoUninitialize ( ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java <nl> index 2393c49 . . ed8ccff 100644 <nl> - - - a / src / com / sun / jna / Structure . java <nl> + + + b / src / com / sun / jna / Structure . java <nl> @ @ - 131 , 7 + 131 , 9 @ @ public abstract class Structure { <nl> / * * Align to an 8 - byte boundary . * / <nl> / / public static final int ALIGN _ 8 = 6 ; <nl> <nl> - private static final int MAX _ GNUC _ ALIGNMENT = isSPARC ? 8 : Native . LONG _ SIZE ; <nl> + static final int MAX _ GNUC _ ALIGNMENT = <nl> + isSPARC | | ( isPPC & & Platform . isLinux ( ) ) <nl> + ? 8 : Native . LONG _ SIZE ; <nl> protected static final int CALCULATE _ SIZE = - 1 ; <nl> <nl> / / This field is accessed by native code <nl> @ @ - 957 , 7 + 959 , 11 @ @ public abstract class Structure { <nl> } <nl> <nl> public String toString ( ) { <nl> - return toString ( 0 , true ) ; <nl> + return toString ( Boolean . getBoolean ( " jna . dump _ memory " ) ) ; <nl> + } <nl> + <nl> + public String toString ( boolean debug ) { <nl> + return toString ( 0 , true , true ) ; <nl> } <nl> <nl> private String format ( Class type ) { <nl> @ @ - 966 , 7 + 972 , 7 @ @ public abstract class Structure { <nl> return s . substring ( dot + 1 ) ; <nl> } <nl> <nl> - private String toString ( int indent , boolean showContents ) { <nl> + private String toString ( int indent , boolean showContents , boolean dumpMemory ) { <nl> String LS = System . getProperty ( " line . separator " ) ; <nl> String name = format ( getClass ( ) ) + " ( " + getPointer ( ) + " ) " ; <nl> if ( ! ( getPointer ( ) instanceof Memory ) ) { <nl> @ @ - 993 , 7 + 999 , 7 @ @ public abstract class Structure { <nl> contents + = " " + type + " " <nl> + sf . name + index + " @ " + Integer . toHexString ( sf . offset ) ; <nl> if ( value instanceof Structure ) { <nl> - value = ( ( Structure ) value ) . toString ( indent + 1 , ! ( value instanceof Structure . ByReference ) ) ; <nl> + value = ( ( Structure ) value ) . toString ( indent + 1 , ! ( value instanceof Structure . ByReference ) , dumpMemory ) ; <nl> } <nl> contents + = " = " ; <nl> if ( value instanceof Long ) { <nl> @ @ - 1015 , 7 + 1021 , 7 @ @ public abstract class Structure { <nl> if ( ! i . hasNext ( ) ) <nl> contents + = prefix + " } " ; <nl> } <nl> - if ( indent = = 0 & & Boolean . getBoolean ( " jna . dump _ memory " ) ) { <nl> + if ( indent = = 0 & & dumpMemory ) { <nl> byte [ ] buf = getPointer ( ) . getByteArray ( 0 , size ( ) ) ; <nl> final int BYTES _ PER _ ROW = 4 ; <nl> contents + = LS + " memory dump " + LS ; <nl> diff - - git a / test / com / sun / jna / ArgumentsMarshalTest . java b / test / com / sun / jna / ArgumentsMarshalTest . java <nl> index da638c4 . . 2f67eab 100644 <nl> - - - a / test / com / sun / jna / ArgumentsMarshalTest . java <nl> + + + b / test / com / sun / jna / ArgumentsMarshalTest . java <nl> @ @ - 341 , 7 + 341 , 7 @ @ public class ArgumentsMarshalTest extends TestCase { <nl> public void testStructureByValueArgument ( ) { <nl> TestLibrary . CheckFieldAlignment . ByValue struct = <nl> new TestLibrary . CheckFieldAlignment . ByValue ( ) ; <nl> - assertEquals ( " Wrong sum of fields " , <nl> + assertEquals ( " Wrong sum of fields for " + struct . toString ( true ) , <nl> 21d , lib . testStructureByValueArgument ( struct ) ) ; <nl> } <nl> <nl> diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java <nl> index 083589e . . 3bdfb38 100644 <nl> - - - a / test / com / sun / jna / StructureTest . java <nl> + + + b / test / com / sun / jna / StructureTest . java <nl> @ @ - 108 , 8 + 108 , 7 @ @ public class StructureTest extends TestCase { <nl> } <nl> TestStructure s = new TestStructure ( ) ; <nl> s . setAlignType ( Structure . ALIGN _ GNUC ) ; <nl> - boolean isSPARC = " sparc " . equals ( System . getProperty ( " os . arch " ) ) ; <nl> - final int SIZE = NativeLong . SIZE = = 4 & & ! isSPARC ? 28 : 32 ; <nl> + final int SIZE = Structure . MAX _ GNUC _ ALIGNMENT = = 8 ? 32 : 28 ; <nl> assertEquals ( " Wrong structure size " , SIZE , s . size ( ) ) ; <nl> } <nl> <nl> @ @ - 171 , 7 + 170 , 7 @ @ public class StructureTest extends TestCase { <nl> SizeTest lib = ( SizeTest ) Native . loadLibrary ( " testlib " , SizeTest . class ) ; <nl> Class cls = Class . forName ( getClass ( ) . getName ( ) + " $ TestStructure " + index ) ; <nl> Structure s = Structure . newInstance ( cls ) ; <nl> - assertEquals ( " Incorrect size : " + s , lib . getStructureSize ( index ) , s . size ( ) ) ; <nl> + assertEquals ( " Incorrect size for structure " + index + " = > " + s . toString ( true ) , lib . getStructureSize ( index ) , s . size ( ) ) ; <nl> } <nl> catch ( Exception e ) { <nl> throw new Error ( e ) ;

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Ole32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Ole32 . java 
 index 7ce2eb1 . . bb3480a 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Ole32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Ole32 . java 
 @ @ - 352 , 4 + 352 , 117 @ @ public interface Ole32 extends StdCallLibrary { 
 * / 
 boolean CoIsHandlerConnected ( Pointer pUnk ) ; 
 
 + 
 + / * * 
 + * Initializes the COM library on the current apartment , identifies the 
 + * concurrency model as single - thread apartment ( STA ) , and enables 
 + * additional functionality described in the Remarks section below . 
 + * Applications must initialize the COM library before they can call COM 
 + * library functions other than CoGetMalloc and memory allocation functions . 
 + * @ param pvReserved Reserved ; must be null . 
 + * @ return { @ link WinError # S _ OK S _ OK } if the COM library and additional functionality were 
 + * initialized successfully on this apartment . < p > 
 + * { @ link WinError # S _ FALSE S _ FALSE } if the COM library is already initialized on this apartment . < p > 
 + * { @ link WinError # OLE _ E _ WRONGCOMPOBJ OLE _ E _ WRONGCOMPOBJ } if the versions of COMPOBJ . DLL and OLE2 . DLL on 
 + * your machine are incompatible with each other . < p > 
 + * { @ link WinError # RPC _ E _ CHANGED _ MODE RPC _ E _ CHANGED _ MODE } if a previous call to CoInitializeEx specified 
 + * the concurrency model for this apartment as 
 + * multithread apartment ( MTA ) . If running 
 + * Windows 2000 , this could also mean that a 
 + * change from neutral threaded apartment to 
 + * single threaded apartment occurred . 
 + * / 
 + HRESULT OleInitialize ( Pointer pvReserved ) ; 
 + 
 + / * * 
 + * Closes the COM library on the apartment , releases any class factories , 
 + * other COM objects , or servers held by the apartment , disables RPC on the 
 + * apartment , and frees any resources the apartment maintains . 
 + * 
 + * Remarks : 
 + * Call OleUninitialize on application shutdown , as the last COM library 
 + * call , if the apartment was initialized with a call to 
 + * { @ link # OleInitialize } . OleUninitialize calls the CoUninitialize function 
 + * internally to shut down the OLE Component Object ( COM ) Library . 
 + * 
 + * If the COM library was initialized on the apartment with a call to 
 + * CoInitialize or CoInitializeEx , it must be closed with a call to 
 + * CoUninitialize . 
 + * 
 + * The { @ link # OleInitialize } and OleUninitialize calls must be balanced â€” 
 + * if there are multiple calls to the { @ link # OleInitialize } function , there 
 + * must be the same number of calls to OleUninitialize : Only the 
 + * OleUninitialize call corresponding to the { @ link # OleInitialize } call 
 + * that actually initialized the library can close it . 
 + * / 
 + void OleUninitialize ( ) ; 
 + 
 + / * * 
 + * Carries out the clipboard shutdown sequence . It also releases the 
 + * IDataObject pointer that was placed on the clipboard by the 
 + * OleSetClipboard function . 
 + * @ return { @ link WinError # S _ OK S _ OK } on success . < p > 
 + * { @ link WinError # CLIPBRD _ E _ CANT _ OPEN CLIPBRD _ E _ CANT _ OPEN } The Windows OpenClipboard function used 
 + * within OleFlushClipboard failed . < p > 
 + * { @ link WinError # CLIPBRD _ E _ CANT _ CLOSE CLIPBRD _ E _ CANT _ CLOSE } The Windows CloseClipboard function used 
 + * within OleFlushClipboard failed . < p > 
 + * < b > Remarks < / b > < p > 
 + * OleFlushClipboard renders the data from a data object onto the clipboard 
 + * and releases the IDataObject pointer to the data object . While the 
 + * application that put the data object on the clipboard is running , the 
 + * clipboard holds only a pointer to the data object , thus saving memory . 
 + * If you are writing an application that acts as the source of a clipboard 
 + * operation , you can call the OleFlushClipboard function when your 
 + * application is closed , such as when the user exits from your application . 
 + * Calling OleFlushClipboard enables pasting and paste - linking of OLE 
 + * objects after application shutdown . 
 + * Before calling OleFlushClipboard , you can easily determine if your data 
 + * is still on the clipboard with a call to the OleIsCurrentClipboard 
 + * function . 
 + * 
 + * OleFlushClipboard leaves all formats offered by the data transfer object , 
 + * including the OLE 1 compatibility formats , on the clipboard so they are 
 + * available after application shutdown . In addition to OLE 1 compatibility 
 + * formats , these include all formats offered on a global handle medium ( all 
 + * except for TYMED _ FILE ) and formatted with a null target device . For 
 + * example , if a data - source application offers a particular clipboard 
 + * format ( say cfFOO ) on an IStorage object , and calls the OleFlushClipboard 
 + * function , the storage object is copied into memory and the hglobal memory 
 + * handle is put on the clipboard . 
 + * 
 + * To retrieve the information on the clipboard , you can call the 
 + * OleGetClipboard function from another application , which creates a 
 + * default data object , and the hglobal from the clipboard again becomes a 
 + * storage object . Furthermore , the FORMATETC enumerator and the 
 + * IDataObject : : QueryGetData method would all correctly indicate that the 
 + * original clipboard format ( cfFOO ) is again available on a TYMED _ ISTORAGE . 
 + * 
 + * To empty the clipboard , call the OleSetClipboard function specifying a 
 + * null value for its parameter . The application should call this when it 
 + * closes if there is no need to leave data on the clipboard after shutdown , 
 + * or if data will be placed on the clipboard using the standard Windows 
 + * clipboard functions . 
 + * / 
 + HRESULT OleFlushClipboard ( ) ; 
 + 
 + / * * 
 + * Puts an OLE compound document object into the running state . 
 + * @ param pUnknown [ in ] Pointer to the { @ link IUnknown IUnknown } interface 
 + * on the object , with which it will query for a pointer to 
 + * the IRunnableObject interface , and then call its Run method . 
 + * @ return This function returns on success . 
 + * Other possible values include the following . < p > 
 + * { @ link WinError # OLE _ E _ CLASSDIFF OLE _ E _ CLASSDIFF } The source of an 
 + * OLE link has been converted to a different class . < p > 
 + * < B > Remarks < / B > < p > 
 + * The OleRun function puts an object in the running state . The 
 + * implementation of OleRun was changed in OLE 2 . 01 to coincide with the 
 + * publication of the IRunnableObject interface . You can use OleRun and 
 + * IRunnableObject : : Run interchangeably . OleRun queries the object for a 
 + * pointer to IRunnableObject . If successful , the function returns the 
 + * results of calling the IRunnableObject : : Run method . < p > < p > 
 + * For more information on using this function , see IRunnableObject : : Run . 
 + * / 
 + HRESULT OleRun ( Pointer pUnknown ) ; 
 + 
 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Ole32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Ole32Test . java 
 index 73ce524 . . 3cae808 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Ole32Test . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Ole32Test . java 
 @ @ - 126 , 4 + 126 , 16 @ @ public class Ole32Test extends TestCase { 
 
 Ole32 . INSTANCE . CoTaskMemFree ( ptr ) ; 
 } 
 + 
 + public void testOleFunctions ( ) { 
 + HRESULT initResult = Ole32 . INSTANCE . OleInitialize ( Pointer . NULL ) ; 
 + 
 + assertTrue ( W32Errors . SUCCEEDED ( initResult ) ) ; 
 + 
 + / / For a real test , a test component will be needed 
 + Ole32 . INSTANCE . OleFlushClipboard ( ) ; 
 + Ole32 . INSTANCE . OleRun ( Pointer . NULL ) ; 
 + 
 + Ole32 . INSTANCE . CoUninitialize ( ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java 
 index 2393c49 . . ed8ccff 100644 
 - - - a / src / com / sun / jna / Structure . java 
 + + + b / src / com / sun / jna / Structure . java 
 @ @ - 131 , 7 + 131 , 9 @ @ public abstract class Structure { 
 / * * Align to an 8 - byte boundary . * / 
 / / public static final int ALIGN _ 8 = 6 ; 
 
 - private static final int MAX _ GNUC _ ALIGNMENT = isSPARC ? 8 : Native . LONG _ SIZE ; 
 + static final int MAX _ GNUC _ ALIGNMENT = 
 + isSPARC | | ( isPPC & & Platform . isLinux ( ) ) 
 + ? 8 : Native . LONG _ SIZE ; 
 protected static final int CALCULATE _ SIZE = - 1 ; 
 
 / / This field is accessed by native code 
 @ @ - 957 , 7 + 959 , 11 @ @ public abstract class Structure { 
 } 
 
 public String toString ( ) { 
 - return toString ( 0 , true ) ; 
 + return toString ( Boolean . getBoolean ( " jna . dump _ memory " ) ) ; 
 + } 
 + 
 + public String toString ( boolean debug ) { 
 + return toString ( 0 , true , true ) ; 
 } 
 
 private String format ( Class type ) { 
 @ @ - 966 , 7 + 972 , 7 @ @ public abstract class Structure { 
 return s . substring ( dot + 1 ) ; 
 } 
 
 - private String toString ( int indent , boolean showContents ) { 
 + private String toString ( int indent , boolean showContents , boolean dumpMemory ) { 
 String LS = System . getProperty ( " line . separator " ) ; 
 String name = format ( getClass ( ) ) + " ( " + getPointer ( ) + " ) " ; 
 if ( ! ( getPointer ( ) instanceof Memory ) ) { 
 @ @ - 993 , 7 + 999 , 7 @ @ public abstract class Structure { 
 contents + = " " + type + " " 
 + sf . name + index + " @ " + Integer . toHexString ( sf . offset ) ; 
 if ( value instanceof Structure ) { 
 - value = ( ( Structure ) value ) . toString ( indent + 1 , ! ( value instanceof Structure . ByReference ) ) ; 
 + value = ( ( Structure ) value ) . toString ( indent + 1 , ! ( value instanceof Structure . ByReference ) , dumpMemory ) ; 
 } 
 contents + = " = " ; 
 if ( value instanceof Long ) { 
 @ @ - 1015 , 7 + 1021 , 7 @ @ public abstract class Structure { 
 if ( ! i . hasNext ( ) ) 
 contents + = prefix + " } " ; 
 } 
 - if ( indent = = 0 & & Boolean . getBoolean ( " jna . dump _ memory " ) ) { 
 + if ( indent = = 0 & & dumpMemory ) { 
 byte [ ] buf = getPointer ( ) . getByteArray ( 0 , size ( ) ) ; 
 final int BYTES _ PER _ ROW = 4 ; 
 contents + = LS + " memory dump " + LS ; 
 diff - - git a / test / com / sun / jna / ArgumentsMarshalTest . java b / test / com / sun / jna / ArgumentsMarshalTest . java 
 index da638c4 . . 2f67eab 100644 
 - - - a / test / com / sun / jna / ArgumentsMarshalTest . java 
 + + + b / test / com / sun / jna / ArgumentsMarshalTest . java 
 @ @ - 341 , 7 + 341 , 7 @ @ public class ArgumentsMarshalTest extends TestCase { 
 public void testStructureByValueArgument ( ) { 
 TestLibrary . CheckFieldAlignment . ByValue struct = 
 new TestLibrary . CheckFieldAlignment . ByValue ( ) ; 
 - assertEquals ( " Wrong sum of fields " , 
 + assertEquals ( " Wrong sum of fields for " + struct . toString ( true ) , 
 21d , lib . testStructureByValueArgument ( struct ) ) ; 
 } 
 
 diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java 
 index 083589e . . 3bdfb38 100644 
 - - - a / test / com / sun / jna / StructureTest . java 
 + + + b / test / com / sun / jna / StructureTest . java 
 @ @ - 108 , 8 + 108 , 7 @ @ public class StructureTest extends TestCase { 
 } 
 TestStructure s = new TestStructure ( ) ; 
 s . setAlignType ( Structure . ALIGN _ GNUC ) ; 
 - boolean isSPARC = " sparc " . equals ( System . getProperty ( " os . arch " ) ) ; 
 - final int SIZE = NativeLong . SIZE = = 4 & & ! isSPARC ? 28 : 32 ; 
 + final int SIZE = Structure . MAX _ GNUC _ ALIGNMENT = = 8 ? 32 : 28 ; 
 assertEquals ( " Wrong structure size " , SIZE , s . size ( ) ) ; 
 } 
 
 @ @ - 171 , 7 + 170 , 7 @ @ public class StructureTest extends TestCase { 
 SizeTest lib = ( SizeTest ) Native . loadLibrary ( " testlib " , SizeTest . class ) ; 
 Class cls = Class . forName ( getClass ( ) . getName ( ) + " $ TestStructure " + index ) ; 
 Structure s = Structure . newInstance ( cls ) ; 
 - assertEquals ( " Incorrect size : " + s , lib . getStructureSize ( index ) , s . size ( ) ) ; 
 + assertEquals ( " Incorrect size for structure " + index + " = > " + s . toString ( true ) , lib . getStructureSize ( index ) , s . size ( ) ) ; 
 } 
 catch ( Exception e ) { 
 throw new Error ( e ) ;
