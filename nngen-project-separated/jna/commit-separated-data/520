BLEU SCORE: 0.5

TEST MSG: some changes
GENERATED MSG: testToScanForGetFieldOrderIssues

TEST DIFF (one line): diff - - git a / contrib / platform / test / com / sun / jna / platform / StructureFieldOrderTest . java b / contrib / platform / test / com / sun / jna / platform / StructureFieldOrderTest . java <nl> deleted file mode 100644 <nl> index ebdd8b2 . . 0000000 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / StructureFieldOrderTest . java <nl> + + + / dev / null <nl> @ @ - 1 , 76 + 0 , 0 @ @ <nl> - / * Copyright ( c ) 2007 - 2008 Timothy Wall , All Rights Reserved <nl> - * <nl> - * This library is free software ; you can redistribute it and / or <nl> - * modify it under the terms of the GNU Lesser General Public <nl> - * License as published by the Free Software Foundation ; either <nl> - * version 2 . 1 of the License , or ( at your option ) any later version . <nl> - * <nl> - * This library is distributed in the hope that it will be useful , <nl> - * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> - * Lesser General Public License for more details . <nl> - * / <nl> - package com . sun . jna . platform ; <nl> - <nl> - <nl> - import com . sun . jna . Platform ; <nl> - import com . sun . jna . platform . unix . X11 ; <nl> - import com . sun . jna . platform . win32 . DBT ; <nl> - import junit . framework . TestCase ; <nl> - <nl> - import com . sun . jna . StructureFieldOrderInspector ; <nl> - <nl> - import java . util . ArrayList ; <nl> - import java . util . List ; <nl> - <nl> - public class StructureFieldOrderTest extends TestCase { <nl> - <nl> - private String origPropJNANoSys ; <nl> - <nl> - protected void setUp ( ) { <nl> - origPropJNANoSys = System . getProperty ( " jna . nosys " ) ; <nl> - System . setProperty ( " jna . nosys " , " true " ) ; / / would be set by ant script , set here for IDE usage <nl> - } <nl> - <nl> - protected void tearDown ( ) { <nl> - if ( origPropJNANoSys = = null ) { <nl> - System . getProperties ( ) . remove ( " jna . nosys " ) ; <nl> - } else { <nl> - System . setProperty ( " jna . nosys " , origPropJNANoSys ) ; <nl> - } <nl> - } <nl> - <nl> - <nl> - public void testMethodGetFieldOrder ( ) { <nl> - final List < String > ignoreConstructorError = new ArrayList < String > ( ) ; <nl> - <nl> - if ( Platform . isWindows ( ) ) { <nl> - ignoreConstructorError . add ( X11 . class . getName ( ) + " $ " ) ; <nl> - } else { <nl> - ignoreConstructorError . add ( com . sun . jna . platform . win32 . Winspool . PRINTER _ INFO _ 1 . class . getName ( ) ) ; <nl> - ignoreConstructorError . add ( com . sun . jna . platform . win32 . Winspool . PRINTER _ INFO _ 4 . class . getName ( ) ) ; <nl> - ignoreConstructorError . add ( com . sun . jna . platform . win32 . SetupApi . SP _ DEVICE _ INTERFACE _ DATA . class . getName ( ) ) ; <nl> - ignoreConstructorError . add ( com . sun . jna . platform . win32 . SetupApi . SP _ DEVINFO _ DATA . class . getName ( ) ) ; <nl> - } <nl> - <nl> - ignoreConstructorError . add ( DBT . DEV _ BROADCAST _ HANDLE . class . getName ( ) ) ; / / manually validated by wolftobias <nl> - ignoreConstructorError . add ( DBT . DEV _ BROADCAST _ PORT . class . getName ( ) ) ; / / manually validated by wolftobias <nl> - <nl> - StructureFieldOrderInspector . batchCheckStructureGetFieldOrder ( FileUtils . class , ignoreConstructorError ) ; <nl> - } <nl> - <nl> - / / test below is helpful when investigating failure cause of a specific Structure class , it shows full causes and traces . <nl> - / * <nl> - public void testMethodGetFieldOrderSingleClass ( ) { <nl> - final List < String > ignoreConstructorError = new ArrayList < String > ( ) ; <nl> - <nl> - if ( Platform . isWindows ( ) ) { <nl> - ignoreConstructorError . add ( X11 . class . getName ( ) + " $ " ) ; <nl> - } <nl> - <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( com . sun . jna . platform . win32 . SetupApi . SP _ DEVICE _ INTERFACE _ DATA . class , ignoreConstructorError ) ; <nl> - } <nl> - / / * / <nl> - <nl> - <nl> - } <nl> diff - - git a / test / com / sun / jna / StructureFieldOrderInspector . java b / test / com / sun / jna / StructureFieldOrderInspector . java <nl> deleted file mode 100644 <nl> index 8591823 . . 0000000 <nl> - - - a / test / com / sun / jna / StructureFieldOrderInspector . java <nl> + + + / dev / null <nl> @ @ - 1 , 196 + 0 , 0 @ @ <nl> - package com . sun . jna ; <nl> - <nl> - import org . reflections . Reflections ; <nl> - import org . reflections . scanners . ResourcesScanner ; <nl> - import org . reflections . scanners . SubTypesScanner ; <nl> - import org . reflections . util . ClasspathHelper ; <nl> - import org . reflections . util . ConfigurationBuilder ; <nl> - <nl> - import java . lang . reflect . * ; <nl> - import java . util . ArrayList ; <nl> - import java . util . List ; <nl> - import java . util . Set ; <nl> - <nl> - / * * <nl> - * Utility class for detecting missing { @ link com . sun . jna . Structure # getFieldOrder ( ) } methods . <nl> - * <nl> - * This class could be moved to the unit test tree , but them reusing it in the ' platform ' project would require <nl> - * publishing this test tree . <nl> - * <nl> - * @ author Dan Rollo <nl> - * Date : 1 / 17 / 13 <nl> - * Time : 4 : 08 PM <nl> - * / <nl> - public final class StructureFieldOrderInspector { <nl> - <nl> - private StructureFieldOrderInspector ( ) { } <nl> - <nl> - / * * <nl> - * Search for Structure sub types in the source tree of the given class , and validate the getFieldOrder ( ) method , <nl> - * and collects all errors into one exception . <nl> - * <nl> - * @ param classDeclaredInSourceTreeToSearch a class who ' s source tree will be searched for Structure sub types . <nl> - * @ param ignoreConstructorError list of classname prefixes for which to ignore construction errors . <nl> - * / <nl> - public static void batchCheckStructureGetFieldOrder ( final Class classDeclaredInSourceTreeToSearch , <nl> - final List < String > ignoreConstructorError ) { <nl> - final Set < Class < ? extends Structure > > classes = StructureFieldOrderInspector . findSubTypesOfStructure ( classDeclaredInSourceTreeToSearch ) ; <nl> - <nl> - final List < Throwable > problems = new ArrayList < Throwable > ( ) ; <nl> - <nl> - for ( final Class < ? extends Structure > structureSubType : classes ) { <nl> - try { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( structureSubType , ignoreConstructorError ) ; <nl> - } catch ( Throwable t ) { <nl> - problems . add ( t ) ; <nl> - } <nl> - } <nl> - <nl> - if ( problems . size ( ) > 0 ) { <nl> - String msg = " " ; <nl> - for ( final Throwable t : problems ) { <nl> - msg + = t . getMessage ( ) + " ; \ n " ; <nl> - } <nl> - <nl> - throw new RuntimeException ( " Some Structure sub types ( " + problems . size ( ) + " ) have problems with getFieldOrder ( ) : \ n " + msg ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Search for Structure sub types in the source tree of the given class , and validate the getFieldOrder ( ) method . <nl> - * <nl> - * @ param classDeclaredInSourceTreeToSearch a class who ' s source tree will be searched for Structure sub types . <nl> - * @ param ignoreConstructorError list of classname prefixes for which to ignore construction errors . <nl> - * / <nl> - public static void checkStructureGetFieldOrder ( final Class classDeclaredInSourceTreeToSearch , <nl> - final List < String > ignoreConstructorError ) { <nl> - final Set < Class < ? extends Structure > > classes = StructureFieldOrderInspector . findSubTypesOfStructure ( classDeclaredInSourceTreeToSearch ) ; <nl> - <nl> - for ( final Class < ? extends Structure > structureSubType : classes ) { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( structureSubType , ignoreConstructorError ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Find all classes that extend { @ link Structure } . <nl> - * / <nl> - public static Set < Class < ? extends Structure > > findSubTypesOfStructure ( final Class classDeclaredInSourceTreeToSearch ) { <nl> - <nl> - / / use : http : / / code . google . com / p / reflections / <nl> - <nl> - final Reflections reflections = new Reflections ( new ConfigurationBuilder ( ) <nl> - . setScanners ( new SubTypesScanner ( false / * don ' t exclude Object . class * / ) , new ResourcesScanner ( ) ) <nl> - . setUrls ( ClasspathHelper . forClass ( classDeclaredInSourceTreeToSearch ) ) <nl> - ) ; <nl> - <nl> - return reflections . getSubTypesOf ( Structure . class ) ; <nl> - } <nl> - <nl> - <nl> - public static void checkMethodGetFieldOrder ( final Class < ? extends Structure > structureSubType , <nl> - final List < String > ignoreConstructorError ) { <nl> - <nl> - if ( Structure . ByValue . class . isAssignableFrom ( structureSubType ) <nl> - | | Structure . ByReference . class . isAssignableFrom ( structureSubType ) ) { <nl> - <nl> - / / ignore tagging interfaces <nl> - return ; <nl> - } <nl> - <nl> - final Method methodGetFieldOrder = getMethodGetFieldOrder ( structureSubType ) ; <nl> - <nl> - <nl> - if ( Modifier . isAbstract ( structureSubType . getModifiers ( ) ) ) { <nl> - / / do not try to construct abstract Structure sub types <nl> - return ; <nl> - } <nl> - final Constructor < ? extends Structure > structConstructor ; <nl> - try { <nl> - structConstructor = structureSubType . getDeclaredConstructor ( ) ; <nl> - } catch ( NoSuchMethodException e ) { <nl> - if ( structureSubType = = Structure . FFIType . class ) { <nl> - / / ignore this case <nl> - / / @ todo Allow user to pass in list of classes for which to skip construction ? <nl> - return ; <nl> - } <nl> - throw new RuntimeException ( " Parameterless constructor failed on Structure sub type : " + structureSubType . getName ( ) ) ; <nl> - } <nl> - <nl> - if ( ! structConstructor . isAccessible ( ) ) { <nl> - structConstructor . setAccessible ( true ) ; <nl> - } <nl> - final Structure structure ; <nl> - try { <nl> - structure = structConstructor . newInstance ( ) ; <nl> - } catch ( InstantiationException e ) { <nl> - throw new RuntimeException ( " Could not instantiate Structure sub type : " + structureSubType . getName ( ) , e ) ; <nl> - } catch ( IllegalAccessException e ) { <nl> - throw new RuntimeException ( " Could not instantiate Structure sub type : " + structureSubType . getName ( ) , e ) ; <nl> - } catch ( InvocationTargetException e ) { <nl> - / / this is triggered by checks in Structure . getFields ( ) , and static loadlibrary ( ) failures <nl> - if ( ignoreConstructorError ! = null ) { <nl> - final String structSubtypeName = structureSubType . getName ( ) ; <nl> - for ( final String classPrefix : ignoreConstructorError ) { <nl> - if ( structSubtypeName . startsWith ( classPrefix ) ) { <nl> - return ; <nl> - } <nl> - } <nl> - } <nl> - throw new RuntimeException ( " Could not instantiate Structure sub type : " + structureSubType . getName ( ) , e ) ; <nl> - } <nl> - <nl> - if ( ! methodGetFieldOrder . isAccessible ( ) ) { <nl> - methodGetFieldOrder . setAccessible ( true ) ; <nl> - } <nl> - final List methodCallFieldList ; <nl> - try { <nl> - methodCallFieldList = ( List ) methodGetFieldOrder . invoke ( structure ) ; <nl> - } catch ( IllegalAccessException e ) { <nl> - throw new RuntimeException ( " Could not invoke getFieldOrder ( ) on Structure sub type : " + structureSubType . getName ( ) , e ) ; <nl> - } catch ( InvocationTargetException e ) { <nl> - throw new RuntimeException ( " Could not invoke getFieldOrder ( ) on Structure sub type : " + structureSubType . getName ( ) , e ) ; <nl> - } <nl> - <nl> - final Field [ ] actualFields = structureSubType . getFields ( ) ; / / include fields from super classes <nl> - final List actualFieldNames = new ArrayList ( actualFields . length ) ; <nl> - for ( final Field field : actualFields ) { <nl> - / / ignore static fields <nl> - if ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) { <nl> - final String actualFieldName = field . getName ( ) ; <nl> - if ( ! methodCallFieldList . contains ( actualFieldName ) ) { <nl> - throw new IllegalArgumentException ( structureSubType . getName ( ) + " . getFieldOrder ( ) [ " + methodCallFieldList <nl> - + " ] does not include declared field : " + actualFieldName ) ; <nl> - } <nl> - actualFieldNames . add ( actualFieldName ) ; <nl> - } <nl> - } <nl> - <nl> - for ( final Object methodCallField : methodCallFieldList ) { <nl> - if ( ! actualFieldNames . contains ( methodCallField ) ) { <nl> - throw new IllegalArgumentException ( structureSubType . getName ( ) + " . getFieldOrder ( ) [ " + methodCallFieldList <nl> - + " ] includes undeclared field : " + methodCallField ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Find the getFieldOrder ( ) method in the given class , or any of it ' s parents . <nl> - * @ param structureSubType a structure sub type <nl> - * @ return the getFieldOrder ( ) method found in the given class , or any of it ' s parents . <nl> - * / <nl> - private static Method getMethodGetFieldOrder ( Class < ? extends Structure > structureSubType ) { <nl> - final Method methodGetFieldOrder ; <nl> - try { <nl> - methodGetFieldOrder = structureSubType . getDeclaredMethod ( " getFieldOrder " , new Class [ ] { } ) ; <nl> - } catch ( NoSuchMethodException e ) { <nl> - if ( structureSubType . getSuperclass ( ) ! = null ) { <nl> - / / look for method in parent <nl> - return getMethodGetFieldOrder ( ( Class < ? extends Structure > ) structureSubType . getSuperclass ( ) ) ; <nl> - } <nl> - throw new IllegalArgumentException ( " The Structure sub type : " + structureSubType . getName ( ) <nl> - + " must define the method : getFieldOrder ( ) . " <nl> - + " See the javadoc for Structure . getFieldOrder ( ) for details . " , e ) ; <nl> - } <nl> - return methodGetFieldOrder ; <nl> - } <nl> - } <nl> diff - - git a / test / com / sun / jna / StructureFieldOrderInspectorTest . java b / test / com / sun / jna / StructureFieldOrderInspectorTest . java <nl> deleted file mode 100644 <nl> index ee973c0 . . 0000000 <nl> - - - a / test / com / sun / jna / StructureFieldOrderInspectorTest . java <nl> + + + / dev / null <nl> @ @ - 1 , 190 + 0 , 0 @ @ <nl> - package com . sun . jna ; <nl> - <nl> - import junit . framework . TestCase ; <nl> - <nl> - import java . util . ArrayList ; <nl> - import java . util . Arrays ; <nl> - import java . util . List ; <nl> - import java . util . Set ; <nl> - <nl> - / * * <nl> - * Test utility class for inspecting { @ link com . sun . jna . Structure # getFieldOrder ( ) } methods . <nl> - * <nl> - * @ author Dan Rollo <nl> - * Date : 1 / 17 / 13 <nl> - * Time : 4 : 29 PM <nl> - * / <nl> - public class StructureFieldOrderInspectorTest extends TestCase { <nl> - <nl> - private String origPropJNANoSys ; <nl> - <nl> - protected void setUp ( ) { <nl> - origPropJNANoSys = System . getProperty ( " jna . nosys " ) ; <nl> - System . setProperty ( " jna . nosys " , " true " ) ; / / would be set by ant script , set here for IDE usage <nl> - } <nl> - <nl> - protected void tearDown ( ) { <nl> - if ( origPropJNANoSys = = null ) { <nl> - System . getProperties ( ) . remove ( " jna . nosys " ) ; <nl> - } else { <nl> - System . setProperty ( " jna . nosys " , origPropJNANoSys ) ; <nl> - } <nl> - } <nl> - <nl> - <nl> - public void testFindStructureSubClasses ( ) { <nl> - <nl> - final Set < Class < ? extends Structure > > classes = StructureFieldOrderInspector . findSubTypesOfStructure ( Platform . class ) ; <nl> - <nl> - assertTrue ( " Found no Structure sub types . " , classes . size ( ) > 0 ) ; <nl> - <nl> - for ( final Class < ? extends Structure > structureSubType : classes ) { <nl> - assertTrue ( structureSubType . getName ( ) , Structure . class . isAssignableFrom ( structureSubType ) ) ; <nl> - } <nl> - } <nl> - <nl> - public void testCheckMethodGetFieldOrderExisting ( ) { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( StructureByValueTest . TestNativeMappedInStructure . class , null ) ; <nl> - } <nl> - <nl> - public void testCheckMethodGetFieldOrderTagInterface ( ) { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( StructureByValueTest . TestNativeMappedInStructure . ByValue . class , null ) ; <nl> - } <nl> - <nl> - <nl> - private static final class MyStructMissingField extends Structure { <nl> - @ SuppressWarnings ( " UnusedDeclaration " ) <nl> - public String missingDeclaredField ; <nl> - <nl> - @ Override <nl> - protected List getFieldOrder ( ) { <nl> - / / noinspection unchecked <nl> - return Arrays . asList ( ) ; <nl> - } <nl> - } <nl> - public void testCheckMethodGetFieldOrderMissingField ( ) throws Exception { <nl> - try { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructMissingField . class , null ) ; <nl> - fail ( " Expected Error : Structure . getFieldOrder ( ) . . . " ) ; <nl> - } catch ( RuntimeException e ) { <nl> - assertTrue ( e . getCause ( ) . getCause ( ) . getMessage ( ) . contains ( " not match declared field names " ) ) ; <nl> - } <nl> - } <nl> - <nl> - private static final class MyStructExtraField extends Structure { <nl> - @ Override <nl> - protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( " extraField " ) ; <nl> - } <nl> - } <nl> - public void testCheckMethodGetFieldOrderExtraField ( ) throws Exception { <nl> - try { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructExtraField . class , null ) ; <nl> - fail ( " Expected Error : Structure . getFieldOrder ( ) . . . " ) ; <nl> - } catch ( RuntimeException e ) { <nl> - assertTrue ( e . getCause ( ) . getCause ( ) . getMessage ( ) . contains ( " not match declared field names " ) ) ; <nl> - } <nl> - } <nl> - <nl> - private static final class MyStructStaticFieldOnlyStatic extends Structure { <nl> - public static long myStaticField = - 1 ; <nl> - <nl> - @ Override <nl> - protected List getFieldOrder ( ) { <nl> - return Arrays . asList ( ) ; <nl> - } <nl> - } <nl> - / * * <nl> - * / / @ todo Seems this may be a bug . Error below occurs if Structure has no instance field ( and only a static field ) , like : MyStructStaticFieldOnlyStatic . <nl> - java . lang . RuntimeException : Could not instantiate Structure sub type : com . sun . jna . StructureFieldOrderInspectorTest $ MyStructStaticFieldOnlyStatic <nl> - at com . sun . jna . StructureFieldOrderInspector . checkMethodGetFieldOrder ( StructureFieldOrderInspector . java : 146 ) <nl> - at com . sun . jna . StructureFieldOrderInspectorTest . testCheckMethodGetFieldOrderStaticFieldOnlyStatic ( StructureFieldOrderInspectorTest . java : 111 ) <nl> - at sun . reflect . NativeMethodAccessorImpl . invoke0 ( Native Method ) <nl> - at sun . reflect . NativeMethodAccessorImpl . invoke ( NativeMethodAccessorImpl . java : 57 ) <nl> - at sun . reflect . DelegatingMethodAccessorImpl . invoke ( DelegatingMethodAccessorImpl . java : 43 ) <nl> - at com . intellij . junit3 . JUnit3IdeaTestRunner . doRun ( JUnit3IdeaTestRunner . java : 139 ) <nl> - at com . intellij . junit3 . JUnit3IdeaTestRunner . startRunnerWithArgs ( JUnit3IdeaTestRunner . java : 52 ) <nl> - at com . intellij . rt . execution . junit . JUnitStarter . prepareStreamsAndStart ( JUnitStarter . java : 195 ) <nl> - at com . intellij . rt . execution . junit . JUnitStarter . main ( JUnitStarter . java : 63 ) <nl> - at sun . reflect . NativeMethodAccessorImpl . invoke0 ( Native Method ) <nl> - at sun . reflect . NativeMethodAccessorImpl . invoke ( NativeMethodAccessorImpl . java : 57 ) <nl> - at com . intellij . rt . execution . application . AppMain . main ( AppMain . java : 120 ) <nl> - Caused by : java . lang . reflect . InvocationTargetException <nl> - at sun . reflect . NativeConstructorAccessorImpl . newInstance0 ( Native Method ) <nl> - at sun . reflect . NativeConstructorAccessorImpl . newInstance ( NativeConstructorAccessorImpl . java : 57 ) <nl> - at sun . reflect . DelegatingConstructorAccessorImpl . newInstance ( DelegatingConstructorAccessorImpl . java : 45 ) <nl> - at java . lang . reflect . Constructor . newInstance ( Constructor . java : 532 ) <nl> - at com . sun . jna . StructureFieldOrderInspector . checkMethodGetFieldOrder ( StructureFieldOrderInspector . java : 131 ) <nl> - . . . 22 more <nl> - Caused by : java . lang . IllegalArgumentException : Structure class com . sun . jna . StructureFieldOrderInspectorTest $ MyStructStaticFieldOnlyStatic has unknown size ( ensure all fields are public ) <nl> - at com . sun . jna . Structure . deriveLayout ( Structure . java : 1108 ) <nl> - at com . sun . jna . Structure . calculateSize ( Structure . java : 908 ) <nl> - at com . sun . jna . Structure . calculateSize ( Structure . java : 896 ) <nl> - at com . sun . jna . Structure . allocateMemory ( Structure . java : 357 ) <nl> - at com . sun . jna . Structure . < init > ( Structure . java : 191 ) <nl> - at com . sun . jna . Structure . < init > ( Structure . java : 180 ) <nl> - at com . sun . jna . Structure . < init > ( Structure . java : 167 ) <nl> - at com . sun . jna . Structure . < init > ( Structure . java : 159 ) <nl> - at com . sun . jna . StructureFieldOrderInspectorTest $ MyStructStaticFieldOnlyStatic . < init > ( StructureFieldOrderInspectorTest . java : 89 ) <nl> - . . . 27 more <nl> - * / <nl> - / * <nl> - public void testCheckMethodGetFieldOrderStaticFieldOnlyStatic ( ) throws Exception { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructStaticFieldOnlyStatic . class , null ) ; <nl> - } <nl> - / / * / <nl> - <nl> - private static final class MyStructStaticField extends Structure { <nl> - public long instanceField ; / / @ todo Why error if at least one instance field does not exist ? see above : MyStructStaticFieldOnlyStatic <nl> - public static long myStaticField = - 1 ; <nl> - <nl> - @ Override <nl> - protected List getFieldOrder ( ) { <nl> - / / return Arrays . asList ( ) ; <nl> - return Arrays . asList ( " instanceField " ) ; <nl> - } <nl> - } <nl> - public void testCheckMethodGetFieldOrderStaticField ( ) throws Exception { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructStaticField . class , null ) ; <nl> - } <nl> - <nl> - <nl> - private static class MyStructSuper extends Structure { <nl> - public long instanceField ; <nl> - <nl> - @ Override <nl> - protected List getFieldOrder ( ) { <nl> - / / return Arrays . asList ( ) ; <nl> - return Arrays . asList ( " instanceField " ) ; <nl> - } <nl> - } <nl> - private static final class MyStructChildEmpty extends MyStructSuper { <nl> - } <nl> - public void testCheckMethodGetFieldOrderSuperImplOnly ( ) throws Exception { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructChildEmpty . class , null ) ; <nl> - } <nl> - <nl> - <nl> - public void testCheckMethodGetFieldOrderWithAbstractSubtype ( ) throws Exception { <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( Union . class , null ) ; <nl> - } <nl> - <nl> - public void testCheckMethodGetFieldOrderWithIgnoreCtorError ( ) throws Exception { <nl> - final List < String > ignoreConstructorError = new ArrayList < String > ( ) ; <nl> - ignoreConstructorError . add ( StructureFieldOrderInspectorTest . class . getName ( ) ) ; <nl> - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructExtraField . class , ignoreConstructorError ) ; <nl> - } <nl> - <nl> - public void testCheckStructureGetFieldOrder ( ) throws Exception { <nl> - StructureFieldOrderInspector . checkStructureGetFieldOrder ( Platform . class , null ) ; <nl> - } <nl> - <nl> - public void testBatchCheckStructureGetFieldOrder ( ) throws Exception { <nl> - try { <nl> - StructureFieldOrderInspector . batchCheckStructureGetFieldOrder ( StructureTest . class , null ) ; <nl> - fail ( " Expected structure failures " ) ; <nl> - } catch ( RuntimeException e ) { <nl> - assertTrue ( e . getMessage ( ) . startsWith ( " Some Structure sub types " ) ) ; <nl> - } <nl> - } <nl> - }
NEAREST DIFF (one line): diff - - git a / test / com / sun / jna / StructureFieldOrderInspector . java b / test / com / sun / jna / StructureFieldOrderInspector . java <nl> index 582cec7 . . d0eff7f 100644 <nl> - - - a / test / com / sun / jna / StructureFieldOrderInspector . java <nl> + + + b / test / com / sun / jna / StructureFieldOrderInspector . java <nl> @ @ - 43 , 7 + 43 , 7 @ @ public final class StructureFieldOrderInspector { <nl> . setUrls ( ClasspathHelper . forClass ( classDeclaredInSourceTreeToSearch ) ) <nl> ) ; <nl> <nl> - return ( Set < Class < ? extends Structure > > ) reflections . getSubTypesOf ( Structure . class ) ; <nl> + return reflections . getSubTypesOf ( Structure . class ) ; <nl> } <nl> <nl>

TEST DIFF:
diff - - git a / contrib / platform / test / com / sun / jna / platform / StructureFieldOrderTest . java b / contrib / platform / test / com / sun / jna / platform / StructureFieldOrderTest . java 
 deleted file mode 100644 
 index ebdd8b2 . . 0000000 
 - - - a / contrib / platform / test / com / sun / jna / platform / StructureFieldOrderTest . java 
 + + + / dev / null 
 @ @ - 1 , 76 + 0 , 0 @ @ 
 - / * Copyright ( c ) 2007 - 2008 Timothy Wall , All Rights Reserved 
 - * 
 - * This library is free software ; you can redistribute it and / or 
 - * modify it under the terms of the GNU Lesser General Public 
 - * License as published by the Free Software Foundation ; either 
 - * version 2 . 1 of the License , or ( at your option ) any later version . 
 - * 
 - * This library is distributed in the hope that it will be useful , 
 - * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 - * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 - * Lesser General Public License for more details . 
 - * / 
 - package com . sun . jna . platform ; 
 - 
 - 
 - import com . sun . jna . Platform ; 
 - import com . sun . jna . platform . unix . X11 ; 
 - import com . sun . jna . platform . win32 . DBT ; 
 - import junit . framework . TestCase ; 
 - 
 - import com . sun . jna . StructureFieldOrderInspector ; 
 - 
 - import java . util . ArrayList ; 
 - import java . util . List ; 
 - 
 - public class StructureFieldOrderTest extends TestCase { 
 - 
 - private String origPropJNANoSys ; 
 - 
 - protected void setUp ( ) { 
 - origPropJNANoSys = System . getProperty ( " jna . nosys " ) ; 
 - System . setProperty ( " jna . nosys " , " true " ) ; / / would be set by ant script , set here for IDE usage 
 - } 
 - 
 - protected void tearDown ( ) { 
 - if ( origPropJNANoSys = = null ) { 
 - System . getProperties ( ) . remove ( " jna . nosys " ) ; 
 - } else { 
 - System . setProperty ( " jna . nosys " , origPropJNANoSys ) ; 
 - } 
 - } 
 - 
 - 
 - public void testMethodGetFieldOrder ( ) { 
 - final List < String > ignoreConstructorError = new ArrayList < String > ( ) ; 
 - 
 - if ( Platform . isWindows ( ) ) { 
 - ignoreConstructorError . add ( X11 . class . getName ( ) + " $ " ) ; 
 - } else { 
 - ignoreConstructorError . add ( com . sun . jna . platform . win32 . Winspool . PRINTER _ INFO _ 1 . class . getName ( ) ) ; 
 - ignoreConstructorError . add ( com . sun . jna . platform . win32 . Winspool . PRINTER _ INFO _ 4 . class . getName ( ) ) ; 
 - ignoreConstructorError . add ( com . sun . jna . platform . win32 . SetupApi . SP _ DEVICE _ INTERFACE _ DATA . class . getName ( ) ) ; 
 - ignoreConstructorError . add ( com . sun . jna . platform . win32 . SetupApi . SP _ DEVINFO _ DATA . class . getName ( ) ) ; 
 - } 
 - 
 - ignoreConstructorError . add ( DBT . DEV _ BROADCAST _ HANDLE . class . getName ( ) ) ; / / manually validated by wolftobias 
 - ignoreConstructorError . add ( DBT . DEV _ BROADCAST _ PORT . class . getName ( ) ) ; / / manually validated by wolftobias 
 - 
 - StructureFieldOrderInspector . batchCheckStructureGetFieldOrder ( FileUtils . class , ignoreConstructorError ) ; 
 - } 
 - 
 - / / test below is helpful when investigating failure cause of a specific Structure class , it shows full causes and traces . 
 - / * 
 - public void testMethodGetFieldOrderSingleClass ( ) { 
 - final List < String > ignoreConstructorError = new ArrayList < String > ( ) ; 
 - 
 - if ( Platform . isWindows ( ) ) { 
 - ignoreConstructorError . add ( X11 . class . getName ( ) + " $ " ) ; 
 - } 
 - 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( com . sun . jna . platform . win32 . SetupApi . SP _ DEVICE _ INTERFACE _ DATA . class , ignoreConstructorError ) ; 
 - } 
 - / / * / 
 - 
 - 
 - } 
 diff - - git a / test / com / sun / jna / StructureFieldOrderInspector . java b / test / com / sun / jna / StructureFieldOrderInspector . java 
 deleted file mode 100644 
 index 8591823 . . 0000000 
 - - - a / test / com / sun / jna / StructureFieldOrderInspector . java 
 + + + / dev / null 
 @ @ - 1 , 196 + 0 , 0 @ @ 
 - package com . sun . jna ; 
 - 
 - import org . reflections . Reflections ; 
 - import org . reflections . scanners . ResourcesScanner ; 
 - import org . reflections . scanners . SubTypesScanner ; 
 - import org . reflections . util . ClasspathHelper ; 
 - import org . reflections . util . ConfigurationBuilder ; 
 - 
 - import java . lang . reflect . * ; 
 - import java . util . ArrayList ; 
 - import java . util . List ; 
 - import java . util . Set ; 
 - 
 - / * * 
 - * Utility class for detecting missing { @ link com . sun . jna . Structure # getFieldOrder ( ) } methods . 
 - * 
 - * This class could be moved to the unit test tree , but them reusing it in the ' platform ' project would require 
 - * publishing this test tree . 
 - * 
 - * @ author Dan Rollo 
 - * Date : 1 / 17 / 13 
 - * Time : 4 : 08 PM 
 - * / 
 - public final class StructureFieldOrderInspector { 
 - 
 - private StructureFieldOrderInspector ( ) { } 
 - 
 - / * * 
 - * Search for Structure sub types in the source tree of the given class , and validate the getFieldOrder ( ) method , 
 - * and collects all errors into one exception . 
 - * 
 - * @ param classDeclaredInSourceTreeToSearch a class who ' s source tree will be searched for Structure sub types . 
 - * @ param ignoreConstructorError list of classname prefixes for which to ignore construction errors . 
 - * / 
 - public static void batchCheckStructureGetFieldOrder ( final Class classDeclaredInSourceTreeToSearch , 
 - final List < String > ignoreConstructorError ) { 
 - final Set < Class < ? extends Structure > > classes = StructureFieldOrderInspector . findSubTypesOfStructure ( classDeclaredInSourceTreeToSearch ) ; 
 - 
 - final List < Throwable > problems = new ArrayList < Throwable > ( ) ; 
 - 
 - for ( final Class < ? extends Structure > structureSubType : classes ) { 
 - try { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( structureSubType , ignoreConstructorError ) ; 
 - } catch ( Throwable t ) { 
 - problems . add ( t ) ; 
 - } 
 - } 
 - 
 - if ( problems . size ( ) > 0 ) { 
 - String msg = " " ; 
 - for ( final Throwable t : problems ) { 
 - msg + = t . getMessage ( ) + " ; \ n " ; 
 - } 
 - 
 - throw new RuntimeException ( " Some Structure sub types ( " + problems . size ( ) + " ) have problems with getFieldOrder ( ) : \ n " + msg ) ; 
 - } 
 - } 
 - 
 - / * * 
 - * Search for Structure sub types in the source tree of the given class , and validate the getFieldOrder ( ) method . 
 - * 
 - * @ param classDeclaredInSourceTreeToSearch a class who ' s source tree will be searched for Structure sub types . 
 - * @ param ignoreConstructorError list of classname prefixes for which to ignore construction errors . 
 - * / 
 - public static void checkStructureGetFieldOrder ( final Class classDeclaredInSourceTreeToSearch , 
 - final List < String > ignoreConstructorError ) { 
 - final Set < Class < ? extends Structure > > classes = StructureFieldOrderInspector . findSubTypesOfStructure ( classDeclaredInSourceTreeToSearch ) ; 
 - 
 - for ( final Class < ? extends Structure > structureSubType : classes ) { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( structureSubType , ignoreConstructorError ) ; 
 - } 
 - } 
 - 
 - / * * 
 - * Find all classes that extend { @ link Structure } . 
 - * / 
 - public static Set < Class < ? extends Structure > > findSubTypesOfStructure ( final Class classDeclaredInSourceTreeToSearch ) { 
 - 
 - / / use : http : / / code . google . com / p / reflections / 
 - 
 - final Reflections reflections = new Reflections ( new ConfigurationBuilder ( ) 
 - . setScanners ( new SubTypesScanner ( false / * don ' t exclude Object . class * / ) , new ResourcesScanner ( ) ) 
 - . setUrls ( ClasspathHelper . forClass ( classDeclaredInSourceTreeToSearch ) ) 
 - ) ; 
 - 
 - return reflections . getSubTypesOf ( Structure . class ) ; 
 - } 
 - 
 - 
 - public static void checkMethodGetFieldOrder ( final Class < ? extends Structure > structureSubType , 
 - final List < String > ignoreConstructorError ) { 
 - 
 - if ( Structure . ByValue . class . isAssignableFrom ( structureSubType ) 
 - | | Structure . ByReference . class . isAssignableFrom ( structureSubType ) ) { 
 - 
 - / / ignore tagging interfaces 
 - return ; 
 - } 
 - 
 - final Method methodGetFieldOrder = getMethodGetFieldOrder ( structureSubType ) ; 
 - 
 - 
 - if ( Modifier . isAbstract ( structureSubType . getModifiers ( ) ) ) { 
 - / / do not try to construct abstract Structure sub types 
 - return ; 
 - } 
 - final Constructor < ? extends Structure > structConstructor ; 
 - try { 
 - structConstructor = structureSubType . getDeclaredConstructor ( ) ; 
 - } catch ( NoSuchMethodException e ) { 
 - if ( structureSubType = = Structure . FFIType . class ) { 
 - / / ignore this case 
 - / / @ todo Allow user to pass in list of classes for which to skip construction ? 
 - return ; 
 - } 
 - throw new RuntimeException ( " Parameterless constructor failed on Structure sub type : " + structureSubType . getName ( ) ) ; 
 - } 
 - 
 - if ( ! structConstructor . isAccessible ( ) ) { 
 - structConstructor . setAccessible ( true ) ; 
 - } 
 - final Structure structure ; 
 - try { 
 - structure = structConstructor . newInstance ( ) ; 
 - } catch ( InstantiationException e ) { 
 - throw new RuntimeException ( " Could not instantiate Structure sub type : " + structureSubType . getName ( ) , e ) ; 
 - } catch ( IllegalAccessException e ) { 
 - throw new RuntimeException ( " Could not instantiate Structure sub type : " + structureSubType . getName ( ) , e ) ; 
 - } catch ( InvocationTargetException e ) { 
 - / / this is triggered by checks in Structure . getFields ( ) , and static loadlibrary ( ) failures 
 - if ( ignoreConstructorError ! = null ) { 
 - final String structSubtypeName = structureSubType . getName ( ) ; 
 - for ( final String classPrefix : ignoreConstructorError ) { 
 - if ( structSubtypeName . startsWith ( classPrefix ) ) { 
 - return ; 
 - } 
 - } 
 - } 
 - throw new RuntimeException ( " Could not instantiate Structure sub type : " + structureSubType . getName ( ) , e ) ; 
 - } 
 - 
 - if ( ! methodGetFieldOrder . isAccessible ( ) ) { 
 - methodGetFieldOrder . setAccessible ( true ) ; 
 - } 
 - final List methodCallFieldList ; 
 - try { 
 - methodCallFieldList = ( List ) methodGetFieldOrder . invoke ( structure ) ; 
 - } catch ( IllegalAccessException e ) { 
 - throw new RuntimeException ( " Could not invoke getFieldOrder ( ) on Structure sub type : " + structureSubType . getName ( ) , e ) ; 
 - } catch ( InvocationTargetException e ) { 
 - throw new RuntimeException ( " Could not invoke getFieldOrder ( ) on Structure sub type : " + structureSubType . getName ( ) , e ) ; 
 - } 
 - 
 - final Field [ ] actualFields = structureSubType . getFields ( ) ; / / include fields from super classes 
 - final List actualFieldNames = new ArrayList ( actualFields . length ) ; 
 - for ( final Field field : actualFields ) { 
 - / / ignore static fields 
 - if ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) { 
 - final String actualFieldName = field . getName ( ) ; 
 - if ( ! methodCallFieldList . contains ( actualFieldName ) ) { 
 - throw new IllegalArgumentException ( structureSubType . getName ( ) + " . getFieldOrder ( ) [ " + methodCallFieldList 
 - + " ] does not include declared field : " + actualFieldName ) ; 
 - } 
 - actualFieldNames . add ( actualFieldName ) ; 
 - } 
 - } 
 - 
 - for ( final Object methodCallField : methodCallFieldList ) { 
 - if ( ! actualFieldNames . contains ( methodCallField ) ) { 
 - throw new IllegalArgumentException ( structureSubType . getName ( ) + " . getFieldOrder ( ) [ " + methodCallFieldList 
 - + " ] includes undeclared field : " + methodCallField ) ; 
 - } 
 - } 
 - } 
 - 
 - / * * 
 - * Find the getFieldOrder ( ) method in the given class , or any of it ' s parents . 
 - * @ param structureSubType a structure sub type 
 - * @ return the getFieldOrder ( ) method found in the given class , or any of it ' s parents . 
 - * / 
 - private static Method getMethodGetFieldOrder ( Class < ? extends Structure > structureSubType ) { 
 - final Method methodGetFieldOrder ; 
 - try { 
 - methodGetFieldOrder = structureSubType . getDeclaredMethod ( " getFieldOrder " , new Class [ ] { } ) ; 
 - } catch ( NoSuchMethodException e ) { 
 - if ( structureSubType . getSuperclass ( ) ! = null ) { 
 - / / look for method in parent 
 - return getMethodGetFieldOrder ( ( Class < ? extends Structure > ) structureSubType . getSuperclass ( ) ) ; 
 - } 
 - throw new IllegalArgumentException ( " The Structure sub type : " + structureSubType . getName ( ) 
 - + " must define the method : getFieldOrder ( ) . " 
 - + " See the javadoc for Structure . getFieldOrder ( ) for details . " , e ) ; 
 - } 
 - return methodGetFieldOrder ; 
 - } 
 - } 
 diff - - git a / test / com / sun / jna / StructureFieldOrderInspectorTest . java b / test / com / sun / jna / StructureFieldOrderInspectorTest . java 
 deleted file mode 100644 
 index ee973c0 . . 0000000 
 - - - a / test / com / sun / jna / StructureFieldOrderInspectorTest . java 
 + + + / dev / null 
 @ @ - 1 , 190 + 0 , 0 @ @ 
 - package com . sun . jna ; 
 - 
 - import junit . framework . TestCase ; 
 - 
 - import java . util . ArrayList ; 
 - import java . util . Arrays ; 
 - import java . util . List ; 
 - import java . util . Set ; 
 - 
 - / * * 
 - * Test utility class for inspecting { @ link com . sun . jna . Structure # getFieldOrder ( ) } methods . 
 - * 
 - * @ author Dan Rollo 
 - * Date : 1 / 17 / 13 
 - * Time : 4 : 29 PM 
 - * / 
 - public class StructureFieldOrderInspectorTest extends TestCase { 
 - 
 - private String origPropJNANoSys ; 
 - 
 - protected void setUp ( ) { 
 - origPropJNANoSys = System . getProperty ( " jna . nosys " ) ; 
 - System . setProperty ( " jna . nosys " , " true " ) ; / / would be set by ant script , set here for IDE usage 
 - } 
 - 
 - protected void tearDown ( ) { 
 - if ( origPropJNANoSys = = null ) { 
 - System . getProperties ( ) . remove ( " jna . nosys " ) ; 
 - } else { 
 - System . setProperty ( " jna . nosys " , origPropJNANoSys ) ; 
 - } 
 - } 
 - 
 - 
 - public void testFindStructureSubClasses ( ) { 
 - 
 - final Set < Class < ? extends Structure > > classes = StructureFieldOrderInspector . findSubTypesOfStructure ( Platform . class ) ; 
 - 
 - assertTrue ( " Found no Structure sub types . " , classes . size ( ) > 0 ) ; 
 - 
 - for ( final Class < ? extends Structure > structureSubType : classes ) { 
 - assertTrue ( structureSubType . getName ( ) , Structure . class . isAssignableFrom ( structureSubType ) ) ; 
 - } 
 - } 
 - 
 - public void testCheckMethodGetFieldOrderExisting ( ) { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( StructureByValueTest . TestNativeMappedInStructure . class , null ) ; 
 - } 
 - 
 - public void testCheckMethodGetFieldOrderTagInterface ( ) { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( StructureByValueTest . TestNativeMappedInStructure . ByValue . class , null ) ; 
 - } 
 - 
 - 
 - private static final class MyStructMissingField extends Structure { 
 - @ SuppressWarnings ( " UnusedDeclaration " ) 
 - public String missingDeclaredField ; 
 - 
 - @ Override 
 - protected List getFieldOrder ( ) { 
 - / / noinspection unchecked 
 - return Arrays . asList ( ) ; 
 - } 
 - } 
 - public void testCheckMethodGetFieldOrderMissingField ( ) throws Exception { 
 - try { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructMissingField . class , null ) ; 
 - fail ( " Expected Error : Structure . getFieldOrder ( ) . . . " ) ; 
 - } catch ( RuntimeException e ) { 
 - assertTrue ( e . getCause ( ) . getCause ( ) . getMessage ( ) . contains ( " not match declared field names " ) ) ; 
 - } 
 - } 
 - 
 - private static final class MyStructExtraField extends Structure { 
 - @ Override 
 - protected List getFieldOrder ( ) { 
 - return Arrays . asList ( " extraField " ) ; 
 - } 
 - } 
 - public void testCheckMethodGetFieldOrderExtraField ( ) throws Exception { 
 - try { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructExtraField . class , null ) ; 
 - fail ( " Expected Error : Structure . getFieldOrder ( ) . . . " ) ; 
 - } catch ( RuntimeException e ) { 
 - assertTrue ( e . getCause ( ) . getCause ( ) . getMessage ( ) . contains ( " not match declared field names " ) ) ; 
 - } 
 - } 
 - 
 - private static final class MyStructStaticFieldOnlyStatic extends Structure { 
 - public static long myStaticField = - 1 ; 
 - 
 - @ Override 
 - protected List getFieldOrder ( ) { 
 - return Arrays . asList ( ) ; 
 - } 
 - } 
 - / * * 
 - * / / @ todo Seems this may be a bug . Error below occurs if Structure has no instance field ( and only a static field ) , like : MyStructStaticFieldOnlyStatic . 
 - java . lang . RuntimeException : Could not instantiate Structure sub type : com . sun . jna . StructureFieldOrderInspectorTest $ MyStructStaticFieldOnlyStatic 
 - at com . sun . jna . StructureFieldOrderInspector . checkMethodGetFieldOrder ( StructureFieldOrderInspector . java : 146 ) 
 - at com . sun . jna . StructureFieldOrderInspectorTest . testCheckMethodGetFieldOrderStaticFieldOnlyStatic ( StructureFieldOrderInspectorTest . java : 111 ) 
 - at sun . reflect . NativeMethodAccessorImpl . invoke0 ( Native Method ) 
 - at sun . reflect . NativeMethodAccessorImpl . invoke ( NativeMethodAccessorImpl . java : 57 ) 
 - at sun . reflect . DelegatingMethodAccessorImpl . invoke ( DelegatingMethodAccessorImpl . java : 43 ) 
 - at com . intellij . junit3 . JUnit3IdeaTestRunner . doRun ( JUnit3IdeaTestRunner . java : 139 ) 
 - at com . intellij . junit3 . JUnit3IdeaTestRunner . startRunnerWithArgs ( JUnit3IdeaTestRunner . java : 52 ) 
 - at com . intellij . rt . execution . junit . JUnitStarter . prepareStreamsAndStart ( JUnitStarter . java : 195 ) 
 - at com . intellij . rt . execution . junit . JUnitStarter . main ( JUnitStarter . java : 63 ) 
 - at sun . reflect . NativeMethodAccessorImpl . invoke0 ( Native Method ) 
 - at sun . reflect . NativeMethodAccessorImpl . invoke ( NativeMethodAccessorImpl . java : 57 ) 
 - at com . intellij . rt . execution . application . AppMain . main ( AppMain . java : 120 ) 
 - Caused by : java . lang . reflect . InvocationTargetException 
 - at sun . reflect . NativeConstructorAccessorImpl . newInstance0 ( Native Method ) 
 - at sun . reflect . NativeConstructorAccessorImpl . newInstance ( NativeConstructorAccessorImpl . java : 57 ) 
 - at sun . reflect . DelegatingConstructorAccessorImpl . newInstance ( DelegatingConstructorAccessorImpl . java : 45 ) 
 - at java . lang . reflect . Constructor . newInstance ( Constructor . java : 532 ) 
 - at com . sun . jna . StructureFieldOrderInspector . checkMethodGetFieldOrder ( StructureFieldOrderInspector . java : 131 ) 
 - . . . 22 more 
 - Caused by : java . lang . IllegalArgumentException : Structure class com . sun . jna . StructureFieldOrderInspectorTest $ MyStructStaticFieldOnlyStatic has unknown size ( ensure all fields are public ) 
 - at com . sun . jna . Structure . deriveLayout ( Structure . java : 1108 ) 
 - at com . sun . jna . Structure . calculateSize ( Structure . java : 908 ) 
 - at com . sun . jna . Structure . calculateSize ( Structure . java : 896 ) 
 - at com . sun . jna . Structure . allocateMemory ( Structure . java : 357 ) 
 - at com . sun . jna . Structure . < init > ( Structure . java : 191 ) 
 - at com . sun . jna . Structure . < init > ( Structure . java : 180 ) 
 - at com . sun . jna . Structure . < init > ( Structure . java : 167 ) 
 - at com . sun . jna . Structure . < init > ( Structure . java : 159 ) 
 - at com . sun . jna . StructureFieldOrderInspectorTest $ MyStructStaticFieldOnlyStatic . < init > ( StructureFieldOrderInspectorTest . java : 89 ) 
 - . . . 27 more 
 - * / 
 - / * 
 - public void testCheckMethodGetFieldOrderStaticFieldOnlyStatic ( ) throws Exception { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructStaticFieldOnlyStatic . class , null ) ; 
 - } 
 - / / * / 
 - 
 - private static final class MyStructStaticField extends Structure { 
 - public long instanceField ; / / @ todo Why error if at least one instance field does not exist ? see above : MyStructStaticFieldOnlyStatic 
 - public static long myStaticField = - 1 ; 
 - 
 - @ Override 
 - protected List getFieldOrder ( ) { 
 - / / return Arrays . asList ( ) ; 
 - return Arrays . asList ( " instanceField " ) ; 
 - } 
 - } 
 - public void testCheckMethodGetFieldOrderStaticField ( ) throws Exception { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructStaticField . class , null ) ; 
 - } 
 - 
 - 
 - private static class MyStructSuper extends Structure { 
 - public long instanceField ; 
 - 
 - @ Override 
 - protected List getFieldOrder ( ) { 
 - / / return Arrays . asList ( ) ; 
 - return Arrays . asList ( " instanceField " ) ; 
 - } 
 - } 
 - private static final class MyStructChildEmpty extends MyStructSuper { 
 - } 
 - public void testCheckMethodGetFieldOrderSuperImplOnly ( ) throws Exception { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructChildEmpty . class , null ) ; 
 - } 
 - 
 - 
 - public void testCheckMethodGetFieldOrderWithAbstractSubtype ( ) throws Exception { 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( Union . class , null ) ; 
 - } 
 - 
 - public void testCheckMethodGetFieldOrderWithIgnoreCtorError ( ) throws Exception { 
 - final List < String > ignoreConstructorError = new ArrayList < String > ( ) ; 
 - ignoreConstructorError . add ( StructureFieldOrderInspectorTest . class . getName ( ) ) ; 
 - StructureFieldOrderInspector . checkMethodGetFieldOrder ( MyStructExtraField . class , ignoreConstructorError ) ; 
 - } 
 - 
 - public void testCheckStructureGetFieldOrder ( ) throws Exception { 
 - StructureFieldOrderInspector . checkStructureGetFieldOrder ( Platform . class , null ) ; 
 - } 
 - 
 - public void testBatchCheckStructureGetFieldOrder ( ) throws Exception { 
 - try { 
 - StructureFieldOrderInspector . batchCheckStructureGetFieldOrder ( StructureTest . class , null ) ; 
 - fail ( " Expected structure failures " ) ; 
 - } catch ( RuntimeException e ) { 
 - assertTrue ( e . getMessage ( ) . startsWith ( " Some Structure sub types " ) ) ; 
 - } 
 - } 
 - }

NEAREST DIFF:
diff - - git a / test / com / sun / jna / StructureFieldOrderInspector . java b / test / com / sun / jna / StructureFieldOrderInspector . java 
 index 582cec7 . . d0eff7f 100644 
 - - - a / test / com / sun / jna / StructureFieldOrderInspector . java 
 + + + b / test / com / sun / jna / StructureFieldOrderInspector . java 
 @ @ - 43 , 7 + 43 , 7 @ @ public final class StructureFieldOrderInspector { 
 . setUrls ( ClasspathHelper . forClass ( classDeclaredInSourceTreeToSearch ) ) 
 ) ; 
 
 - return ( Set < Class < ? extends Structure > > ) reflections . getSubTypesOf ( Structure . class ) ; 
 + return reflections . getSubTypesOf ( Structure . class ) ; 
 } 
 

