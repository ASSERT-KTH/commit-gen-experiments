BLEU SCORE: 0.05341087579952926

TEST MSG: Fix SAFEARRAY ByReference in VARIANT
GENERATED MSG: some changes

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Convert . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Convert . java <nl> index bbd3d18 . . 32d4d91 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Convert . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Convert . java <nl> @ @ - 23 , 8 + 23 , 6 @ @ <nl> * / <nl> package com . sun . jna . platform . win32 . COM . util ; <nl> <nl> - import com . sun . jna . platform . win32 . OaIdl . DATE ; <nl> - import com . sun . jna . platform . win32 . OaIdl . VARIANT _ BOOL ; <nl> import com . sun . jna . platform . win32 . OleAuto ; <nl> import com . sun . jna . platform . win32 . Variant ; <nl> import java . lang . reflect . InvocationHandler ; <nl> @ @ - 36 , 13 + 34 , 7 @ @ import java . util . Date ; <nl> import com . sun . jna . platform . win32 . WinDef ; <nl> import com . sun . jna . platform . win32 . Variant . VARIANT ; <nl> import com . sun . jna . platform . win32 . WTypes . BSTR ; <nl> - import com . sun . jna . platform . win32 . WinDef . BOOL ; <nl> - import com . sun . jna . platform . win32 . WinDef . BYTE ; <nl> - import com . sun . jna . platform . win32 . WinDef . CHAR ; <nl> - import com . sun . jna . platform . win32 . WinDef . LONG ; <nl> - import com . sun . jna . platform . win32 . WinDef . SHORT ; <nl> import com . sun . jna . platform . win32 . OaIdl ; <nl> - import com . sun . jna . platform . win32 . OaIdl . SAFEARRAY ; <nl> import static com . sun . jna . platform . win32 . Variant . VT _ ARRAY ; <nl> import static com . sun . jna . platform . win32 . Variant . VT _ BOOL ; <nl> import static com . sun . jna . platform . win32 . Variant . VT _ BSTR ; <nl> @ @ - 70 , 6 + 62 , 7 @ @ import static com . sun . jna . platform . win32 . Variant . VT _ UINT ; <nl> import static com . sun . jna . platform . win32 . Variant . VT _ UNKNOWN ; <nl> import static com . sun . jna . platform . win32 . Variant . VT _ VARIANT ; <nl> import com . sun . jna . platform . win32 . WinDef . PVOID ; <nl> + import java . lang . reflect . Constructor ; <nl> <nl> / * * <nl> * This class is considered internal to the package . <nl> @ @ - 78 , 42 + 71 , 26 @ @ class Convert { <nl> / * * <nl> * Convert a java value into a VARIANT suitable for passing in a COM <nl> * invocation . <nl> - * <nl> + * <nl> * < p > < i > Implementation notes < / i > < / p > <nl> - * <nl> + * <nl> * < ul > <nl> * < li > VARIANTs are not rewrapped , but passed through unmodified < / li > <nl> * < li > A string is wrapped into a BSTR , that is wrapped into the VARIANT . <nl> * The string is allocated as native memory by the VARIANT constructor . <nl> * The BSTR needs to be freed by { @ link com . sun . jna . platform . win32 . OleAuto # SysFreeString } . < / li > <nl> * < / ul > <nl> - * <nl> + * <nl> * @ param value to be wrapped <nl> * @ return wrapped VARIANT <nl> * / <nl> 	 public static VARIANT toVariant ( Object value ) { <nl> - if ( value instanceof VARIANT ) { <nl> + if ( value instanceof VARIANT ) { <nl> return ( VARIANT ) value ; <nl> - } else if ( value instanceof BSTR ) { <nl> - return new VARIANT ( ( BSTR ) value ) ; <nl> - } else if ( value instanceof VARIANT _ BOOL ) { <nl> - return new VARIANT ( ( VARIANT _ BOOL ) value ) ; <nl> - } else if ( value instanceof BOOL ) { <nl> - return new VARIANT ( ( BOOL ) value ) ; <nl> - } else if ( value instanceof LONG ) { <nl> - return new VARIANT ( ( LONG ) value ) ; <nl> - } else if ( value instanceof SHORT ) { <nl> - return new VARIANT ( ( SHORT ) value ) ; <nl> - } else if ( value instanceof DATE ) { <nl> - return new VARIANT ( ( DATE ) value ) ; <nl> - } else if ( value instanceof BYTE ) { <nl> - return new VARIANT ( ( BYTE ) value ) ; <nl> } else if ( value instanceof Byte ) { <nl> return new VARIANT ( ( Byte ) value ) ; <nl> } else if ( value instanceof Character ) { <nl> return new VARIANT ( ( Character ) value ) ; <nl> - } else if ( value instanceof CHAR ) { <nl> - return new VARIANT ( ( CHAR ) value ) ; <nl> 	 	 } else if ( value instanceof Short ) { <nl> 	 	 	 return new VARIANT ( ( Short ) value ) ; <nl> 	 	 } else if ( value instanceof Integer ) { <nl> @ @ - 132 , 27 + 109 , 42 @ @ class Convert { <nl> 	 	 	 return new VARIANT ( ( com . sun . jna . platform . win32 . COM . IDispatch ) value ) ; <nl> 	 	 } else if ( value instanceof Date ) { <nl> 	 	 	 return new VARIANT ( ( Date ) value ) ; <nl> - 	 	 } else if ( value instanceof Proxy ) { <nl> + } else if ( value instanceof Proxy ) { <nl> 	 	 	 InvocationHandler ih = Proxy . getInvocationHandler ( value ) ; <nl> 	 	 	 ProxyObject pobj = ( ProxyObject ) ih ; <nl> 	 	 	 return new VARIANT ( pobj . getRawDispatch ( ) ) ; <nl> 	 	 } else if ( value instanceof IComEnum ) { <nl> 	 	 	 IComEnum enm = ( IComEnum ) value ; <nl> 	 	 	 return new VARIANT ( new WinDef . LONG ( enm . getValue ( ) ) ) ; <nl> - } else if ( value instanceof SAFEARRAY ) { <nl> - return new VARIANT ( ( SAFEARRAY ) value ) ; <nl> - 	 	 } else { <nl> - 	 	 	 return null ; <nl> - 	 	 } <nl> - 	 } <nl> - 	 <nl> + } else { <nl> + Constructor < VARIANT > constructor = null ; <nl> + if ( value ! = null ) { <nl> + for ( Constructor < VARIANT > m : ( Constructor < VARIANT > [ ] ) VARIANT . class . getConstructors ( ) ) { <nl> + if ( m . getParameterCount ( ) > 0 <nl> + & & m . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( value . getClass ( ) ) ) { <nl> + constructor = m ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + if ( constructor ! = null ) { <nl> + try { <nl> + return constructor . newInstance ( value ) ; <nl> + } catch ( Exception ex ) { <nl> + throw new RuntimeException ( ex ) ; <nl> + } <nl> + } <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> 	 public static Object toJavaObject ( VARIANT value , Class < ? > targetClass , ObjectFactory factory , boolean addReference , boolean freeValue ) { <nl> - 	 	 if ( null = = value <nl> - | | value . getVarType ( ) . intValue ( ) = = VT _ EMPTY <nl> + 	 	 if ( null = = value <nl> + | | value . getVarType ( ) . intValue ( ) = = VT _ EMPTY <nl> | | value . getVarType ( ) . intValue ( ) = = VT _ NULL ) { <nl> return null ; <nl> } <nl> - <nl> + <nl> if ( targetClass ! = null & & ( ! targetClass . isAssignableFrom ( Object . class ) ) ) { <nl> if ( targetClass . isAssignableFrom ( value . getClass ( ) ) ) { <nl> return value ; <nl> @ @ - 163 , 86 + 155 , 67 @ @ class Convert { <nl> return vobj ; <nl> } <nl> } <nl> - <nl> + <nl> VARIANT inputValue = value ; <nl> - <nl> + <nl> if ( value . getVarType ( ) . intValue ( ) = = ( VT _ BYREF | VT _ VARIANT ) ) { <nl> value = ( VARIANT ) value . getValue ( ) ; <nl> } <nl> - <nl> + <nl> / / Passing null or Object . class as targetClass switch to default <nl> / / handling <nl> if ( targetClass = = null | | ( targetClass . isAssignableFrom ( Object . class ) ) ) { <nl> - <nl> + <nl> targetClass = null ; <nl> - <nl> + <nl> int varType = value . getVarType ( ) . intValue ( ) ; <nl> - <nl> + <nl> switch ( value . getVarType ( ) . intValue ( ) ) { <nl> case VT _ UI1 : <nl> case VT _ I1 : <nl> - case VT _ BYREF | VT _ UI1 : <nl> - case VT _ BYREF | VT _ I1 : <nl> targetClass = Byte . class ; <nl> break ; <nl> case VT _ I2 : <nl> - case VT _ BYREF | VT _ I2 : <nl> targetClass = Short . class ; <nl> break ; <nl> case VT _ UI2 : <nl> - case VT _ BYREF | VT _ UI2 : <nl> targetClass = Character . class ; <nl> break ; <nl> case VT _ INT : <nl> case VT _ UINT : <nl> case VT _ UI4 : <nl> case VT _ I4 : <nl> - case VT _ BYREF | VT _ I4 : <nl> - case VT _ BYREF | VT _ UI4 : <nl> - case VT _ BYREF | VT _ INT : <nl> - case VT _ BYREF | VT _ UINT : <nl> targetClass = Integer . class ; <nl> break ; <nl> case VT _ UI8 : <nl> case VT _ I8 : <nl> - case VT _ BYREF | VT _ I8 : <nl> - case VT _ BYREF | VT _ UI8 : <nl> targetClass = Long . class ; <nl> break ; <nl> case VT _ R4 : <nl> - case VT _ BYREF | VT _ R4 : <nl> targetClass = Float . class ; <nl> break ; <nl> case VT _ R8 : <nl> - case VT _ BYREF | VT _ R8 : <nl> targetClass = Double . class ; <nl> break ; <nl> case VT _ BOOL : <nl> - case VT _ BYREF | VT _ BOOL : <nl> targetClass = Boolean . class ; <nl> break ; <nl> case VT _ ERROR : <nl> - case VT _ BYREF | VT _ ERROR : <nl> targetClass = WinDef . SCODE . class ; <nl> break ; <nl> case VT _ CY : <nl> - case VT _ BYREF | VT _ CY : <nl> targetClass = OaIdl . CURRENCY . class ; <nl> break ; <nl> case VT _ DATE : <nl> - case VT _ BYREF | VT _ DATE : <nl> targetClass = Date . class ; <nl> break ; <nl> case VT _ BSTR : <nl> - case VT _ BYREF | VT _ BSTR : <nl> targetClass = String . class ; <nl> break ; <nl> case VT _ UNKNOWN : <nl> - case VT _ BYREF | VT _ UNKNOWN : <nl> targetClass = com . sun . jna . platform . win32 . COM . IUnknown . class ; <nl> break ; <nl> case VT _ DISPATCH : <nl> - case VT _ BYREF | VT _ DISPATCH : <nl> targetClass = IDispatch . class ; <nl> break ; <nl> case VT _ BYREF | VT _ VARIANT : <nl> @ @ - 261 , 7 + 234 , 7 @ @ class Convert { <nl> } <nl> } <nl> } <nl> - <nl> + <nl> Object result ; <nl> if ( Byte . class . equals ( targetClass ) | | byte . class . equals ( targetClass ) ) { <nl> result = value . byteValue ( ) ; <nl> @ @ - 308 , 14 + 281 , 14 @ @ class Convert { <nl> if ( IComEnum . class . isAssignableFrom ( targetClass ) ) { <nl> result = targetClass . cast ( Convert . toComEnum ( ( Class < ? extends IComEnum > ) targetClass , result ) ) ; <nl> } <nl> - <nl> + <nl> if ( freeValue ) { <nl> free ( inputValue , result ) ; <nl> } <nl> - <nl> + <nl> return result ; <nl> 	 } <nl> - 	 <nl> + <nl> 	 public static < T extends IComEnum > T toComEnum ( Class < T > enumType , Object value ) { <nl> 	 	 try { <nl> 	 	 	 Method m = enumType . getMethod ( " values " ) ; <nl> @ @ - 332 , 13 + 305 , 13 @ @ class Convert { <nl> 	 	 } <nl> 	 	 return null ; <nl> 	 } <nl> - <nl> + <nl> / * * <nl> * Free the contents of the supplied VARIANT . <nl> - * <nl> + * <nl> * < p > This method is a companion to { @ link # toVariant } . Primary usage is <nl> * to free BSTRs contained in VARIANTs . < / p > <nl> - * <nl> + * <nl> * @ param variant to be cleared <nl> * @ param javaType type before / after conversion <nl> * / <nl> @ @ - 352 , 13 + 325 , 13 @ @ class Convert { <nl> } <nl> } <nl> } <nl> - <nl> + <nl> / * * <nl> * Free the contents of the supplied VARIANT . <nl> - * <nl> + * <nl> * < p > This method is a companion to { @ link # toVariant } . Primary usage is <nl> * to free BSTRs contained in VARIANTs . < / p > <nl> - * <nl> + * <nl> * @ param variant to be cleared <nl> * @ param value value before / after conversion <nl> * / <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / OaIdl . java b / contrib / platform / src / com / sun / jna / platform / win32 / OaIdl . java <nl> index 908010c . . 2991c57 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / OaIdl . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / OaIdl . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import java . util . List ; <nl> <nl> import com . sun . jna . IntegerType ; <nl> import com . sun . jna . Memory ; <nl> + import com . sun . jna . Native ; <nl> import com . sun . jna . NativeLong ; <nl> import com . sun . jna . Pointer ; <nl> import com . sun . jna . Structure ; <nl> @ @ - 288 , 7 + 289 , 7 @ @ public interface OaIdl { <nl> return FIELDS ; <nl> } <nl> } <nl> - <nl> + <nl> / * * <nl> * The Class DISPID . <nl> * / <nl> @ @ - 631 , 7 + 632 , 7 @ @ public interface OaIdl { <nl> * @ param size array of dimension size <nl> * @ return SAFEARRAYWrapper or { @ code NULL } if creation fails . <nl> * / <nl> - public static SAFEARRAY createSafeArray ( int . . . size ) { <nl> + public static SAFEARRAY . ByReference createSafeArray ( int . . . size ) { <nl> return createSafeArray ( new WTypes . VARTYPE ( Variant . VT _ VARIANT ) , size ) ; <nl> } <nl> <nl> @ @ - 647 , 7 + 648 , 7 @ @ public interface OaIdl { <nl> * @ param size array of dimension size <nl> * @ return SAFEARRAYWrapper or { @ code NULL } if creation fails . <nl> * / <nl> - public static SAFEARRAY createSafeArray ( VARTYPE vartype , int . . . size ) { <nl> + public static SAFEARRAY . ByReference createSafeArray ( VARTYPE vartype , int . . . size ) { <nl> OaIdl . SAFEARRAYBOUND [ ] rgsabound = ( OaIdl . SAFEARRAYBOUND [ ] ) new OaIdl . SAFEARRAYBOUND ( ) . toArray ( size . length ) ; <nl> for ( int i = 0 ; i < size . length ; i + + ) { <nl> rgsabound [ i ] . lLbound = new WinDef . LONG ( 0 ) ; <nl> @ @ - 1042 , 6 + 1043 , 30 @ @ public interface OaIdl { <nl> } <nl> } <nl> <nl> + public static class SAFEARRAYByReference extends Structure implements Structure . ByReference { <nl> + <nl> + public SAFEARRAYByReference ( ) { <nl> + } <nl> + <nl> + public SAFEARRAYByReference ( Pointer p ) { <nl> + super ( p ) ; <nl> + read ( ) ; <nl> + } <nl> + <nl> + public SAFEARRAYByReference ( SAFEARRAY . ByReference safeArray ) { <nl> + pSAFEARRAY = safeArray ; <nl> + } <nl> + <nl> + public static final List < String > FIELDS = createFieldsOrder ( " pSAFEARRAY " ) ; <nl> + <nl> + public SAFEARRAY . ByReference pSAFEARRAY ; <nl> + <nl> + @ Override <nl> + protected List < String > getFieldOrder ( ) { <nl> + return FIELDS ; <nl> + } <nl> + } <nl> + <nl> public static class SAFEARRAYBOUND extends Structure { <nl> public static class ByReference extends SAFEARRAYBOUND implements <nl> Structure . ByReference { <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Variant . java b / contrib / platform / src / com / sun / jna / platform / win32 / Variant . java <nl> index baf43ce . . c45d426 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Variant . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Variant . java <nl> @ @ - 36 , 7 + 36 , 6 @ @ import com . sun . jna . platform . win32 . OaIdl . VARIANT _ BOOL ; <nl> import com . sun . jna . platform . win32 . OaIdl . VARIANT _ BOOLByReference ; <nl> import com . sun . jna . platform . win32 . OaIdl . _ VARIANT _ BOOLByReference ; <nl> import com . sun . jna . platform . win32 . WTypes . BSTR ; <nl> - import com . sun . jna . platform . win32 . WTypes . BSTRByReference ; <nl> import com . sun . jna . platform . win32 . WTypes . VARTYPE ; <nl> import com . sun . jna . platform . win32 . WinDef . BOOL ; <nl> import com . sun . jna . platform . win32 . WinDef . BYTE ; <nl> @ @ - 61 , 6 + 60 , 8 @ @ import com . sun . jna . platform . win32 . WinDef . USHORTByReference ; <nl> import com . sun . jna . platform . win32 . COM . Dispatch ; <nl> import com . sun . jna . platform . win32 . COM . IDispatch ; <nl> import com . sun . jna . platform . win32 . COM . Unknown ; <nl> + import com . sun . jna . platform . win32 . OaIdl . SAFEARRAYByReference ; <nl> + import com . sun . jna . platform . win32 . WTypes . BSTRByReference ; <nl> import com . sun . jna . ptr . ByteByReference ; <nl> import com . sun . jna . ptr . DoubleByReference ; <nl> import com . sun . jna . ptr . FloatByReference ; <nl> @ @ - 186 , 7 + 187 , 7 @ @ public interface Variant { <nl> <nl> public VARIANT ( BSTRByReference value ) { <nl> this ( ) ; <nl> - this . setValue ( VT _ BYREF | VT _ BSTR , value ) ; <nl> + this . setValue ( VT _ BSTR | VT _ BYREF , value ) ; <nl> } <nl> <nl> public VARIANT ( VARIANT _ BOOL value ) { <nl> @ @ - 226 , 7 + 227 , 7 @ @ public interface Variant { <nl> this ( ) ; <nl> this . setValue ( VT _ UI2 , new USHORT ( value ) ) ; <nl> } <nl> - <nl> + <nl> public VARIANT ( CHAR value ) { <nl> this ( ) ; <nl> this . setValue ( Variant . VT _ I1 , value ) ; <nl> @ @ - 236 , 12 + 237 , 17 @ @ public interface Variant { <nl> this ( ) ; <nl> this . setValue ( VT _ I2 , new SHORT ( value ) ) ; <nl> } <nl> - <nl> + <nl> public VARIANT ( int value ) { <nl> this ( ) ; <nl> this . setValue ( VT _ I4 , new LONG ( value ) ) ; <nl> } <nl> <nl> + public VARIANT ( IntByReference value ) { <nl> + this ( ) ; <nl> + this . setValue ( VT _ INT | VT _ BYREF , value ) ; <nl> + } <nl> + <nl> public VARIANT ( long value ) { <nl> this ( ) ; <nl> this . setValue ( VT _ I8 , new LONGLONG ( value ) ) ; <nl> @ @ - 292 , 7 + 298 , 12 @ @ public interface Variant { <nl> this ( ) ; <nl> this . setValue ( array ) ; <nl> } <nl> - <nl> + <nl> + public VARIANT ( SAFEARRAYByReference array ) { <nl> + this ( ) ; <nl> + this . setValue ( array ) ; <nl> + } <nl> + <nl> public VARTYPE getVarType ( ) { <nl> this . read ( ) ; <nl> return _ variant . vt ; <nl> @ @ - 305 , 11 + 316 , 15 @ @ public interface Variant { <nl> public void setValue ( int vt , Object value ) { <nl> this . setValue ( new VARTYPE ( vt ) , value ) ; <nl> } <nl> - <nl> + <nl> public void setValue ( SAFEARRAY array ) { <nl> this . setValue ( array . getVarType ( ) . intValue ( ) | VT _ ARRAY , array ) ; <nl> } <nl> <nl> + public void setValue ( SAFEARRAYByReference array ) { <nl> + this . setValue ( array . pSAFEARRAY . getVarType ( ) . intValue ( ) | VT _ ARRAY | VT _ BYREF , array ) ; <nl> + } <nl> + <nl> public void setValue ( VARTYPE vt , Object value ) { <nl> int varType = vt . intValue ( ) ; <nl> switch ( varType ) { <nl> @ @ - 556 , 7 + 571 , 7 @ @ public interface Variant { <nl> public byte byteValue ( ) { <nl> return ( ( Number ) this . getValue ( ) ) . byteValue ( ) ; <nl> } <nl> - <nl> + <nl> public short shortValue ( ) { <nl> return ( ( Number ) this . getValue ( ) ) . shortValue ( ) ; <nl> } <nl> @ @ - 680 , 13 + 695 , 13 @ @ public interface Variant { <nl> / / DATE * VT _ BYREF | VT _ DATE <nl> public DATE . ByReference pdate ; <nl> / / BSTR * VT _ BYREF | VT _ BSTR <nl> - public BSTR . ByReference pbstrVal ; <nl> + public BSTRByReference pbstrVal ; <nl> / / IUnknown * * VT _ BYREF | VT _ UNKNOWN <nl> public Unknown . ByReference ppunkVal ; <nl> / / IDispatch * * VT _ BYREF | VT _ DISPATCH <nl> public Dispatch . ByReference ppdispVal ; <nl> / / SAFEARRAY * * VT _ BYREF | VT _ ARRAY <nl> - public SAFEARRAY . ByReference pparray ; <nl> + public SAFEARRAYByReference pparray ; <nl> / / VARIANT * VT _ BYREF | VT _ VARIANT <nl> public VARIANT . ByReference pvarVal ; <nl> / / PVOID VT _ BYREF ( Generic ByRef ) <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java b / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java <nl> index a36a05d . . b5e3b76 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java <nl> @ @ - 101 , 10 + 101 , 6 @ @ public interface WTypes { <nl> * as a string containing zero characters . < / p > <nl> * / <nl> public static class BSTR extends PointerType { <nl> - public static class ByReference extends BSTR implements <nl> - Structure . ByReference { <nl> - } <nl> - <nl> public BSTR ( ) { <nl> super ( Pointer . NULL ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / ChangeLog b / ChangeLog <nl> index 289d195 . . ff76645 100644 <nl> - - - a / ChangeLog <nl> + + + b / ChangeLog <nl> @ @ - 1 , 3 + 1 , 13 @ @ <nl> + 2013 - 01 - 10 Anthony Green < green @ moxielogic . com > <nl> + <nl> + 	 * configure . ac : Put local . exp in the right place . <nl> + 	 * configure : Rebuilt . <nl> + <nl> + 	 * src / x86 / ffi . c : Update comment about regparm function attributes . <nl> + 	 * src / x86 / sysv . S ( ffi _ closure _ SYSV ) : The SUNPRO compiler requires <nl> + 	 that all function arguments be passed on the stack ( no regparm <nl> + 	 support ) . <nl> + <nl> 2013 - 01 - 08 Anthony Green < green @ moxielogic . com > <nl> <nl> 	 * configure . ac : Generate local . exp . This sets CC _ FOR _ TARGET <nl> diff - - git a / configure b / configure <nl> index 5876eb7 . . 4a12b96 100755 <nl> - - - a / configure <nl> + + + b / configure <nl> @ @ - 13068 , 10 + 13068 , 10 @ @ ac _ compiler _ gnu = $ ac _ cv _ c _ compiler _ gnu <nl> <nl> if test " x $ GCC " = " xyes " ; then <nl> CFLAGS = " $ CFLAGS - fexceptions " <nl> - touch testsuite / local . exp <nl> + touch local . exp <nl> else <nl> cat > local . exp < < EOF <nl> - set CC _ FOR _ TARGET $ CC <nl> + set CC _ FOR _ TARGET " $ CC " <nl> EOF <nl> fi <nl> <nl> diff - - git a / configure . ac b / configure . ac <nl> index 7ffb36c . . 13d5bc2 100644 <nl> - - - a / configure . ac <nl> + + + b / configure . ac <nl> @ @ - 40 , 10 + 40 , 10 @ @ AX _ CC _ MAXOPT <nl> AX _ CFLAGS _ WARN _ ALL <nl> if test " x $ GCC " = " xyes " ; then <nl> CFLAGS = " $ CFLAGS - fexceptions " <nl> - touch testsuite / local . exp <nl> + touch local . exp <nl> else <nl> cat > local . exp < < EOF <nl> - set CC _ FOR _ TARGET $ CC <nl> + set CC _ FOR _ TARGET " $ CC " <nl> EOF <nl> fi <nl> <nl> diff - - git a / src / x86 / ffi . c b / src / x86 / ffi . c <nl> index 611e221 . . 3f46693 100644 <nl> - - - a / src / x86 / ffi . c <nl> + + + b / src / x86 / ffi . c <nl> @ @ - 424 , 7 + 424 , 7 @ @ void ffi _ call ( ffi _ cif * cif , void ( * fn ) ( void ) , void * rvalue , void * * avalue ) <nl> / * * private members * * / <nl> <nl> / * The following _ _ attribute _ _ ( ( regparm ( 1 ) ) ) decorations will have no effect <nl> - on MSVC - standard cdecl convention applies . * / <nl> + on MSVC or SUNPRO _ C - - standard conventions apply . * / <nl> static void ffi _ prep _ incoming _ args _ SYSV ( char * stack , void * * ret , <nl> void * * args , ffi _ cif * cif ) ; <nl> void FFI _ HIDDEN ffi _ closure _ SYSV ( ffi _ closure * ) <nl> diff - - git a / src / x86 / sysv . S b / src / x86 / sysv . S <nl> index 69e7e8d . . 71502bb 100644 <nl> - - - a / src / x86 / sysv . S <nl> + + + b / src / x86 / sysv . S <nl> @ @ - 182 , 9 + 182 , 19 @ @ ffi _ closure _ SYSV : <nl> 	 leal 	 - 24 ( % ebp ) , % edx <nl> 	 movl 	 % edx , - 12 ( % ebp ) 	 / * resp * / <nl> 	 leal 	 8 ( % ebp ) , % edx <nl> + # ifdef _ _ SUNPRO _ C <nl> + 	 / * The SUNPRO compiler doesn ' t support GCC ' s regparm function <nl> + 	 attribute , so we have to pass all three arguments to <nl> + 	 ffi _ closure _ SYSV _ inner on the stack . * / <nl> + 	 movl 	 % edx , 8 ( % esp ) 	 / * args = _ _ builtin _ dwarf _ cfa ( ) * / <nl> + 	 leal 	 - 12 ( % ebp ) , % edx <nl> + 	 movl 	 % edx , 4 ( % esp ) 	 / * & resp * / <nl> + 	 movl % eax , ( % esp ) / * closure * / <nl> + # else <nl> 	 movl 	 % edx , 4 ( % esp ) 	 / * args = _ _ builtin _ dwarf _ cfa ( ) * / <nl> 	 leal 	 - 12 ( % ebp ) , % edx <nl> 	 movl 	 % edx , ( % esp ) 	 / * & resp * / <nl> + # endif <nl> # if defined HAVE _ HIDDEN _ VISIBILITY _ ATTRIBUTE | | ! defined _ _ PIC _ _ <nl> 	 call 	 ffi _ closure _ SYSV _ inner <nl> # else

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Convert . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Convert . java 
 index bbd3d18 . . 32d4d91 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Convert . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Convert . java 
 @ @ - 23 , 8 + 23 , 6 @ @ 
 * / 
 package com . sun . jna . platform . win32 . COM . util ; 
 
 - import com . sun . jna . platform . win32 . OaIdl . DATE ; 
 - import com . sun . jna . platform . win32 . OaIdl . VARIANT _ BOOL ; 
 import com . sun . jna . platform . win32 . OleAuto ; 
 import com . sun . jna . platform . win32 . Variant ; 
 import java . lang . reflect . InvocationHandler ; 
 @ @ - 36 , 13 + 34 , 7 @ @ import java . util . Date ; 
 import com . sun . jna . platform . win32 . WinDef ; 
 import com . sun . jna . platform . win32 . Variant . VARIANT ; 
 import com . sun . jna . platform . win32 . WTypes . BSTR ; 
 - import com . sun . jna . platform . win32 . WinDef . BOOL ; 
 - import com . sun . jna . platform . win32 . WinDef . BYTE ; 
 - import com . sun . jna . platform . win32 . WinDef . CHAR ; 
 - import com . sun . jna . platform . win32 . WinDef . LONG ; 
 - import com . sun . jna . platform . win32 . WinDef . SHORT ; 
 import com . sun . jna . platform . win32 . OaIdl ; 
 - import com . sun . jna . platform . win32 . OaIdl . SAFEARRAY ; 
 import static com . sun . jna . platform . win32 . Variant . VT _ ARRAY ; 
 import static com . sun . jna . platform . win32 . Variant . VT _ BOOL ; 
 import static com . sun . jna . platform . win32 . Variant . VT _ BSTR ; 
 @ @ - 70 , 6 + 62 , 7 @ @ import static com . sun . jna . platform . win32 . Variant . VT _ UINT ; 
 import static com . sun . jna . platform . win32 . Variant . VT _ UNKNOWN ; 
 import static com . sun . jna . platform . win32 . Variant . VT _ VARIANT ; 
 import com . sun . jna . platform . win32 . WinDef . PVOID ; 
 + import java . lang . reflect . Constructor ; 
 
 / * * 
 * This class is considered internal to the package . 
 @ @ - 78 , 42 + 71 , 26 @ @ class Convert { 
 / * * 
 * Convert a java value into a VARIANT suitable for passing in a COM 
 * invocation . 
 - * 
 + * 
 * < p > < i > Implementation notes < / i > < / p > 
 - * 
 + * 
 * < ul > 
 * < li > VARIANTs are not rewrapped , but passed through unmodified < / li > 
 * < li > A string is wrapped into a BSTR , that is wrapped into the VARIANT . 
 * The string is allocated as native memory by the VARIANT constructor . 
 * The BSTR needs to be freed by { @ link com . sun . jna . platform . win32 . OleAuto # SysFreeString } . < / li > 
 * < / ul > 
 - * 
 + * 
 * @ param value to be wrapped 
 * @ return wrapped VARIANT 
 * / 
 	 public static VARIANT toVariant ( Object value ) { 
 - if ( value instanceof VARIANT ) { 
 + if ( value instanceof VARIANT ) { 
 return ( VARIANT ) value ; 
 - } else if ( value instanceof BSTR ) { 
 - return new VARIANT ( ( BSTR ) value ) ; 
 - } else if ( value instanceof VARIANT _ BOOL ) { 
 - return new VARIANT ( ( VARIANT _ BOOL ) value ) ; 
 - } else if ( value instanceof BOOL ) { 
 - return new VARIANT ( ( BOOL ) value ) ; 
 - } else if ( value instanceof LONG ) { 
 - return new VARIANT ( ( LONG ) value ) ; 
 - } else if ( value instanceof SHORT ) { 
 - return new VARIANT ( ( SHORT ) value ) ; 
 - } else if ( value instanceof DATE ) { 
 - return new VARIANT ( ( DATE ) value ) ; 
 - } else if ( value instanceof BYTE ) { 
 - return new VARIANT ( ( BYTE ) value ) ; 
 } else if ( value instanceof Byte ) { 
 return new VARIANT ( ( Byte ) value ) ; 
 } else if ( value instanceof Character ) { 
 return new VARIANT ( ( Character ) value ) ; 
 - } else if ( value instanceof CHAR ) { 
 - return new VARIANT ( ( CHAR ) value ) ; 
 	 	 } else if ( value instanceof Short ) { 
 	 	 	 return new VARIANT ( ( Short ) value ) ; 
 	 	 } else if ( value instanceof Integer ) { 
 @ @ - 132 , 27 + 109 , 42 @ @ class Convert { 
 	 	 	 return new VARIANT ( ( com . sun . jna . platform . win32 . COM . IDispatch ) value ) ; 
 	 	 } else if ( value instanceof Date ) { 
 	 	 	 return new VARIANT ( ( Date ) value ) ; 
 - 	 	 } else if ( value instanceof Proxy ) { 
 + } else if ( value instanceof Proxy ) { 
 	 	 	 InvocationHandler ih = Proxy . getInvocationHandler ( value ) ; 
 	 	 	 ProxyObject pobj = ( ProxyObject ) ih ; 
 	 	 	 return new VARIANT ( pobj . getRawDispatch ( ) ) ; 
 	 	 } else if ( value instanceof IComEnum ) { 
 	 	 	 IComEnum enm = ( IComEnum ) value ; 
 	 	 	 return new VARIANT ( new WinDef . LONG ( enm . getValue ( ) ) ) ; 
 - } else if ( value instanceof SAFEARRAY ) { 
 - return new VARIANT ( ( SAFEARRAY ) value ) ; 
 - 	 	 } else { 
 - 	 	 	 return null ; 
 - 	 	 } 
 - 	 } 
 - 	 
 + } else { 
 + Constructor < VARIANT > constructor = null ; 
 + if ( value ! = null ) { 
 + for ( Constructor < VARIANT > m : ( Constructor < VARIANT > [ ] ) VARIANT . class . getConstructors ( ) ) { 
 + if ( m . getParameterCount ( ) > 0 
 + & & m . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( value . getClass ( ) ) ) { 
 + constructor = m ; 
 + } 
 + } 
 + } 
 + 
 + if ( constructor ! = null ) { 
 + try { 
 + return constructor . newInstance ( value ) ; 
 + } catch ( Exception ex ) { 
 + throw new RuntimeException ( ex ) ; 
 + } 
 + } 
 + return null ; 
 + } 
 + } 
 + 
 	 public static Object toJavaObject ( VARIANT value , Class < ? > targetClass , ObjectFactory factory , boolean addReference , boolean freeValue ) { 
 - 	 	 if ( null = = value 
 - | | value . getVarType ( ) . intValue ( ) = = VT _ EMPTY 
 + 	 	 if ( null = = value 
 + | | value . getVarType ( ) . intValue ( ) = = VT _ EMPTY 
 | | value . getVarType ( ) . intValue ( ) = = VT _ NULL ) { 
 return null ; 
 } 
 - 
 + 
 if ( targetClass ! = null & & ( ! targetClass . isAssignableFrom ( Object . class ) ) ) { 
 if ( targetClass . isAssignableFrom ( value . getClass ( ) ) ) { 
 return value ; 
 @ @ - 163 , 86 + 155 , 67 @ @ class Convert { 
 return vobj ; 
 } 
 } 
 - 
 + 
 VARIANT inputValue = value ; 
 - 
 + 
 if ( value . getVarType ( ) . intValue ( ) = = ( VT _ BYREF | VT _ VARIANT ) ) { 
 value = ( VARIANT ) value . getValue ( ) ; 
 } 
 - 
 + 
 / / Passing null or Object . class as targetClass switch to default 
 / / handling 
 if ( targetClass = = null | | ( targetClass . isAssignableFrom ( Object . class ) ) ) { 
 - 
 + 
 targetClass = null ; 
 - 
 + 
 int varType = value . getVarType ( ) . intValue ( ) ; 
 - 
 + 
 switch ( value . getVarType ( ) . intValue ( ) ) { 
 case VT _ UI1 : 
 case VT _ I1 : 
 - case VT _ BYREF | VT _ UI1 : 
 - case VT _ BYREF | VT _ I1 : 
 targetClass = Byte . class ; 
 break ; 
 case VT _ I2 : 
 - case VT _ BYREF | VT _ I2 : 
 targetClass = Short . class ; 
 break ; 
 case VT _ UI2 : 
 - case VT _ BYREF | VT _ UI2 : 
 targetClass = Character . class ; 
 break ; 
 case VT _ INT : 
 case VT _ UINT : 
 case VT _ UI4 : 
 case VT _ I4 : 
 - case VT _ BYREF | VT _ I4 : 
 - case VT _ BYREF | VT _ UI4 : 
 - case VT _ BYREF | VT _ INT : 
 - case VT _ BYREF | VT _ UINT : 
 targetClass = Integer . class ; 
 break ; 
 case VT _ UI8 : 
 case VT _ I8 : 
 - case VT _ BYREF | VT _ I8 : 
 - case VT _ BYREF | VT _ UI8 : 
 targetClass = Long . class ; 
 break ; 
 case VT _ R4 : 
 - case VT _ BYREF | VT _ R4 : 
 targetClass = Float . class ; 
 break ; 
 case VT _ R8 : 
 - case VT _ BYREF | VT _ R8 : 
 targetClass = Double . class ; 
 break ; 
 case VT _ BOOL : 
 - case VT _ BYREF | VT _ BOOL : 
 targetClass = Boolean . class ; 
 break ; 
 case VT _ ERROR : 
 - case VT _ BYREF | VT _ ERROR : 
 targetClass = WinDef . SCODE . class ; 
 break ; 
 case VT _ CY : 
 - case VT _ BYREF | VT _ CY : 
 targetClass = OaIdl . CURRENCY . class ; 
 break ; 
 case VT _ DATE : 
 - case VT _ BYREF | VT _ DATE : 
 targetClass = Date . class ; 
 break ; 
 case VT _ BSTR : 
 - case VT _ BYREF | VT _ BSTR : 
 targetClass = String . class ; 
 break ; 
 case VT _ UNKNOWN : 
 - case VT _ BYREF | VT _ UNKNOWN : 
 targetClass = com . sun . jna . platform . win32 . COM . IUnknown . class ; 
 break ; 
 case VT _ DISPATCH : 
 - case VT _ BYREF | VT _ DISPATCH : 
 targetClass = IDispatch . class ; 
 break ; 
 case VT _ BYREF | VT _ VARIANT : 
 @ @ - 261 , 7 + 234 , 7 @ @ class Convert { 
 } 
 } 
 } 
 - 
 + 
 Object result ; 
 if ( Byte . class . equals ( targetClass ) | | byte . class . equals ( targetClass ) ) { 
 result = value . byteValue ( ) ; 
 @ @ - 308 , 14 + 281 , 14 @ @ class Convert { 
 if ( IComEnum . class . isAssignableFrom ( targetClass ) ) { 
 result = targetClass . cast ( Convert . toComEnum ( ( Class < ? extends IComEnum > ) targetClass , result ) ) ; 
 } 
 - 
 + 
 if ( freeValue ) { 
 free ( inputValue , result ) ; 
 } 
 - 
 + 
 return result ; 
 	 } 
 - 	 
 + 
 	 public static < T extends IComEnum > T toComEnum ( Class < T > enumType , Object value ) { 
 	 	 try { 
 	 	 	 Method m = enumType . getMethod ( " values " ) ; 
 @ @ - 332 , 13 + 305 , 13 @ @ class Convert { 
 	 	 } 
 	 	 return null ; 
 	 } 
 - 
 + 
 / * * 
 * Free the contents of the supplied VARIANT . 
 - * 
 + * 
 * < p > This method is a companion to { @ link # toVariant } . Primary usage is 
 * to free BSTRs contained in VARIANTs . < / p > 
 - * 
 + * 
 * @ param variant to be cleared 
 * @ param javaType type before / after conversion 
 * / 
 @ @ - 352 , 13 + 325 , 13 @ @ class Convert { 
 } 
 } 
 } 
 - 
 + 
 / * * 
 * Free the contents of the supplied VARIANT . 
 - * 
 + * 
 * < p > This method is a companion to { @ link # toVariant } . Primary usage is 
 * to free BSTRs contained in VARIANTs . < / p > 
 - * 
 + * 
 * @ param variant to be cleared 
 * @ param value value before / after conversion 
 * / 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / OaIdl . java b / contrib / platform / src / com / sun / jna / platform / win32 / OaIdl . java 
 index 908010c . . 2991c57 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / OaIdl . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / OaIdl . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import java . util . List ; 
 
 import com . sun . jna . IntegerType ; 
 import com . sun . jna . Memory ; 
 + import com . sun . jna . Native ; 
 import com . sun . jna . NativeLong ; 
 import com . sun . jna . Pointer ; 
 import com . sun . jna . Structure ; 
 @ @ - 288 , 7 + 289 , 7 @ @ public interface OaIdl { 
 return FIELDS ; 
 } 
 } 
 - 
 + 
 / * * 
 * The Class DISPID . 
 * / 
 @ @ - 631 , 7 + 632 , 7 @ @ public interface OaIdl { 
 * @ param size array of dimension size 
 * @ return SAFEARRAYWrapper or { @ code NULL } if creation fails . 
 * / 
 - public static SAFEARRAY createSafeArray ( int . . . size ) { 
 + public static SAFEARRAY . ByReference createSafeArray ( int . . . size ) { 
 return createSafeArray ( new WTypes . VARTYPE ( Variant . VT _ VARIANT ) , size ) ; 
 } 
 
 @ @ - 647 , 7 + 648 , 7 @ @ public interface OaIdl { 
 * @ param size array of dimension size 
 * @ return SAFEARRAYWrapper or { @ code NULL } if creation fails . 
 * / 
 - public static SAFEARRAY createSafeArray ( VARTYPE vartype , int . . . size ) { 
 + public static SAFEARRAY . ByReference createSafeArray ( VARTYPE vartype , int . . . size ) { 
 OaIdl . SAFEARRAYBOUND [ ] rgsabound = ( OaIdl . SAFEARRAYBOUND [ ] ) new OaIdl . SAFEARRAYBOUND ( ) . toArray ( size . length ) ; 
 for ( int i = 0 ; i < size . length ; i + + ) { 
 rgsabound [ i ] . lLbound = new WinDef . LONG ( 0 ) ; 
 @ @ - 1042 , 6 + 1043 , 30 @ @ public interface OaIdl { 
 } 
 } 
 
 + public static class SAFEARRAYByReference extends Structure implements Structure . ByReference { 
 + 
 + public SAFEARRAYByReference ( ) { 
 + } 
 + 
 + public SAFEARRAYByReference ( Pointer p ) { 
 + super ( p ) ; 
 + read ( ) ; 
 + } 
 + 
 + public SAFEARRAYByReference ( SAFEARRAY . ByReference safeArray ) { 
 + pSAFEARRAY = safeArray ; 
 + } 
 + 
 + public static final List < String > FIELDS = createFieldsOrder ( " pSAFEARRAY " ) ; 
 + 
 + public SAFEARRAY . ByReference pSAFEARRAY ; 
 + 
 + @ Override 
 + protected List < String > getFieldOrder ( ) { 
 + return FIELDS ; 
 + } 
 + } 
 + 
 public static class SAFEARRAYBOUND extends Structure { 
 public static class ByReference extends SAFEARRAYBOUND implements 
 Structure . ByReference { 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Variant . java b / contrib / platform / src / com / sun / jna / platform / win32 / Variant . java 
 index baf43ce . . c45d426 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Variant . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Variant . java 
 @ @ - 36 , 7 + 36 , 6 @ @ import com . sun . jna . platform . win32 . OaIdl . VARIANT _ BOOL ; 
 import com . sun . jna . platform . win32 . OaIdl . VARIANT _ BOOLByReference ; 
 import com . sun . jna . platform . win32 . OaIdl . _ VARIANT _ BOOLByReference ; 
 import com . sun . jna . platform . win32 . WTypes . BSTR ; 
 - import com . sun . jna . platform . win32 . WTypes . BSTRByReference ; 
 import com . sun . jna . platform . win32 . WTypes . VARTYPE ; 
 import com . sun . jna . platform . win32 . WinDef . BOOL ; 
 import com . sun . jna . platform . win32 . WinDef . BYTE ; 
 @ @ - 61 , 6 + 60 , 8 @ @ import com . sun . jna . platform . win32 . WinDef . USHORTByReference ; 
 import com . sun . jna . platform . win32 . COM . Dispatch ; 
 import com . sun . jna . platform . win32 . COM . IDispatch ; 
 import com . sun . jna . platform . win32 . COM . Unknown ; 
 + import com . sun . jna . platform . win32 . OaIdl . SAFEARRAYByReference ; 
 + import com . sun . jna . platform . win32 . WTypes . BSTRByReference ; 
 import com . sun . jna . ptr . ByteByReference ; 
 import com . sun . jna . ptr . DoubleByReference ; 
 import com . sun . jna . ptr . FloatByReference ; 
 @ @ - 186 , 7 + 187 , 7 @ @ public interface Variant { 
 
 public VARIANT ( BSTRByReference value ) { 
 this ( ) ; 
 - this . setValue ( VT _ BYREF | VT _ BSTR , value ) ; 
 + this . setValue ( VT _ BSTR | VT _ BYREF , value ) ; 
 } 
 
 public VARIANT ( VARIANT _ BOOL value ) { 
 @ @ - 226 , 7 + 227 , 7 @ @ public interface Variant { 
 this ( ) ; 
 this . setValue ( VT _ UI2 , new USHORT ( value ) ) ; 
 } 
 - 
 + 
 public VARIANT ( CHAR value ) { 
 this ( ) ; 
 this . setValue ( Variant . VT _ I1 , value ) ; 
 @ @ - 236 , 12 + 237 , 17 @ @ public interface Variant { 
 this ( ) ; 
 this . setValue ( VT _ I2 , new SHORT ( value ) ) ; 
 } 
 - 
 + 
 public VARIANT ( int value ) { 
 this ( ) ; 
 this . setValue ( VT _ I4 , new LONG ( value ) ) ; 
 } 
 
 + public VARIANT ( IntByReference value ) { 
 + this ( ) ; 
 + this . setValue ( VT _ INT | VT _ BYREF , value ) ; 
 + } 
 + 
 public VARIANT ( long value ) { 
 this ( ) ; 
 this . setValue ( VT _ I8 , new LONGLONG ( value ) ) ; 
 @ @ - 292 , 7 + 298 , 12 @ @ public interface Variant { 
 this ( ) ; 
 this . setValue ( array ) ; 
 } 
 - 
 + 
 + public VARIANT ( SAFEARRAYByReference array ) { 
 + this ( ) ; 
 + this . setValue ( array ) ; 
 + } 
 + 
 public VARTYPE getVarType ( ) { 
 this . read ( ) ; 
 return _ variant . vt ; 
 @ @ - 305 , 11 + 316 , 15 @ @ public interface Variant { 
 public void setValue ( int vt , Object value ) { 
 this . setValue ( new VARTYPE ( vt ) , value ) ; 
 } 
 - 
 + 
 public void setValue ( SAFEARRAY array ) { 
 this . setValue ( array . getVarType ( ) . intValue ( ) | VT _ ARRAY , array ) ; 
 } 
 
 + public void setValue ( SAFEARRAYByReference array ) { 
 + this . setValue ( array . pSAFEARRAY . getVarType ( ) . intValue ( ) | VT _ ARRAY | VT _ BYREF , array ) ; 
 + } 
 + 
 public void setValue ( VARTYPE vt , Object value ) { 
 int varType = vt . intValue ( ) ; 
 switch ( varType ) { 
 @ @ - 556 , 7 + 571 , 7 @ @ public interface Variant { 
 public byte byteValue ( ) { 
 return ( ( Number ) this . getValue ( ) ) . byteValue ( ) ; 
 } 
 - 
 + 
 public short shortValue ( ) { 
 return ( ( Number ) this . getValue ( ) ) . shortValue ( ) ; 
 } 
 @ @ - 680 , 13 + 695 , 13 @ @ public interface Variant { 
 / / DATE * VT _ BYREF | VT _ DATE 
 public DATE . ByReference pdate ; 
 / / BSTR * VT _ BYREF | VT _ BSTR 
 - public BSTR . ByReference pbstrVal ; 
 + public BSTRByReference pbstrVal ; 
 / / IUnknown * * VT _ BYREF | VT _ UNKNOWN 
 public Unknown . ByReference ppunkVal ; 
 / / IDispatch * * VT _ BYREF | VT _ DISPATCH 
 public Dispatch . ByReference ppdispVal ; 
 / / SAFEARRAY * * VT _ BYREF | VT _ ARRAY 
 - public SAFEARRAY . ByReference pparray ; 
 + public SAFEARRAYByReference pparray ; 
 / / VARIANT * VT _ BYREF | VT _ VARIANT 
 public VARIANT . ByReference pvarVal ; 
 / / PVOID VT _ BYREF ( Generic ByRef ) 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java b / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java 
 index a36a05d . . b5e3b76 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java 
 @ @ - 101 , 10 + 101 , 6 @ @ public interface WTypes { 
 * as a string containing zero characters . < / p > 
 * / 
 public static class BSTR extends PointerType { 
 - public static class ByReference extends BSTR implements 
 - Structure . ByReference { 
 - } 
 - 
 public BSTR ( ) { 
 super ( Pointer . NULL ) ; 
 }

NEAREST DIFF:
diff - - git a / ChangeLog b / ChangeLog 
 index 289d195 . . ff76645 100644 
 - - - a / ChangeLog 
 + + + b / ChangeLog 
 @ @ - 1 , 3 + 1 , 13 @ @ 
 + 2013 - 01 - 10 Anthony Green < green @ moxielogic . com > 
 + 
 + 	 * configure . ac : Put local . exp in the right place . 
 + 	 * configure : Rebuilt . 
 + 
 + 	 * src / x86 / ffi . c : Update comment about regparm function attributes . 
 + 	 * src / x86 / sysv . S ( ffi _ closure _ SYSV ) : The SUNPRO compiler requires 
 + 	 that all function arguments be passed on the stack ( no regparm 
 + 	 support ) . 
 + 
 2013 - 01 - 08 Anthony Green < green @ moxielogic . com > 
 
 	 * configure . ac : Generate local . exp . This sets CC _ FOR _ TARGET 
 diff - - git a / configure b / configure 
 index 5876eb7 . . 4a12b96 100755 
 - - - a / configure 
 + + + b / configure 
 @ @ - 13068 , 10 + 13068 , 10 @ @ ac _ compiler _ gnu = $ ac _ cv _ c _ compiler _ gnu 
 
 if test " x $ GCC " = " xyes " ; then 
 CFLAGS = " $ CFLAGS - fexceptions " 
 - touch testsuite / local . exp 
 + touch local . exp 
 else 
 cat > local . exp < < EOF 
 - set CC _ FOR _ TARGET $ CC 
 + set CC _ FOR _ TARGET " $ CC " 
 EOF 
 fi 
 
 diff - - git a / configure . ac b / configure . ac 
 index 7ffb36c . . 13d5bc2 100644 
 - - - a / configure . ac 
 + + + b / configure . ac 
 @ @ - 40 , 10 + 40 , 10 @ @ AX _ CC _ MAXOPT 
 AX _ CFLAGS _ WARN _ ALL 
 if test " x $ GCC " = " xyes " ; then 
 CFLAGS = " $ CFLAGS - fexceptions " 
 - touch testsuite / local . exp 
 + touch local . exp 
 else 
 cat > local . exp < < EOF 
 - set CC _ FOR _ TARGET $ CC 
 + set CC _ FOR _ TARGET " $ CC " 
 EOF 
 fi 
 
 diff - - git a / src / x86 / ffi . c b / src / x86 / ffi . c 
 index 611e221 . . 3f46693 100644 
 - - - a / src / x86 / ffi . c 
 + + + b / src / x86 / ffi . c 
 @ @ - 424 , 7 + 424 , 7 @ @ void ffi _ call ( ffi _ cif * cif , void ( * fn ) ( void ) , void * rvalue , void * * avalue ) 
 / * * private members * * / 
 
 / * The following _ _ attribute _ _ ( ( regparm ( 1 ) ) ) decorations will have no effect 
 - on MSVC - standard cdecl convention applies . * / 
 + on MSVC or SUNPRO _ C - - standard conventions apply . * / 
 static void ffi _ prep _ incoming _ args _ SYSV ( char * stack , void * * ret , 
 void * * args , ffi _ cif * cif ) ; 
 void FFI _ HIDDEN ffi _ closure _ SYSV ( ffi _ closure * ) 
 diff - - git a / src / x86 / sysv . S b / src / x86 / sysv . S 
 index 69e7e8d . . 71502bb 100644 
 - - - a / src / x86 / sysv . S 
 + + + b / src / x86 / sysv . S 
 @ @ - 182 , 9 + 182 , 19 @ @ ffi _ closure _ SYSV : 
 	 leal 	 - 24 ( % ebp ) , % edx 
 	 movl 	 % edx , - 12 ( % ebp ) 	 / * resp * / 
 	 leal 	 8 ( % ebp ) , % edx 
 + # ifdef _ _ SUNPRO _ C 
 + 	 / * The SUNPRO compiler doesn ' t support GCC ' s regparm function 
 + 	 attribute , so we have to pass all three arguments to 
 + 	 ffi _ closure _ SYSV _ inner on the stack . * / 
 + 	 movl 	 % edx , 8 ( % esp ) 	 / * args = _ _ builtin _ dwarf _ cfa ( ) * / 
 + 	 leal 	 - 12 ( % ebp ) , % edx 
 + 	 movl 	 % edx , 4 ( % esp ) 	 / * & resp * / 
 + 	 movl % eax , ( % esp ) / * closure * / 
 + # else 
 	 movl 	 % edx , 4 ( % esp ) 	 / * args = _ _ builtin _ dwarf _ cfa ( ) * / 
 	 leal 	 - 12 ( % ebp ) , % edx 
 	 movl 	 % edx , ( % esp ) 	 / * & resp * / 
 + # endif 
 # if defined HAVE _ HIDDEN _ VISIBILITY _ ATTRIBUTE | | ! defined _ _ PIC _ _ 
 	 call 	 ffi _ closure _ SYSV _ inner 
 # else
