BLEU SCORE: 0.040583489434387374

TEST MSG: use ptr - based structure creation
GENERATED MSG: add callback thread initializer

TEST DIFF (one line): diff - - git a / native / callback . c b / native / callback . c <nl> index e7c59cb . . a1c7e30 100644 <nl> - - - a / native / callback . c <nl> + + + b / native / callback . c <nl> @ @ - 109 , 7 + 109 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> cb - > arg _ types = ( ffi _ type * * ) malloc ( sizeof ( ffi _ type * ) * argc ) ; <nl> cb - > java _ arg _ types = ( ffi _ type * * ) malloc ( sizeof ( ffi _ type * ) * ( argc + 3 ) ) ; <nl> cb - > arg _ jtypes = ( char * ) malloc ( sizeof ( char ) * argc ) ; <nl> - cb - > flags = ( int * ) malloc ( sizeof ( int ) * argc ) ; <nl> + cb - > conversion _ flags = ( int * ) malloc ( sizeof ( int ) * argc ) ; <nl> cb - > rflag = CVT _ DEFAULT ; <nl> cb - > arg _ classes = ( jobject * ) malloc ( sizeof ( jobject ) * argc ) ; <nl> <nl> @ @ - 119 , 7 + 119 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> for ( i = 0 ; i < argc ; i + + ) { <nl> int jtype ; <nl> jclass cls = ( * env ) - > GetObjectArrayElement ( env , param _ types , i ) ; <nl> - if ( ( cb - > flags [ i ] = get _ conversion _ flag ( env , cls ) ) ! = CVT _ DEFAULT ) { <nl> + if ( ( cb - > conversion _ flags [ i ] = get _ conversion _ flag ( env , cls ) ) ! = CVT _ DEFAULT ) { <nl> cb - > arg _ classes [ i ] = ( * env ) - > NewWeakGlobalRef ( env , cls ) ; <nl> cvt = 1 ; <nl> } <nl> @ @ - 139 , 9 + 139 , 9 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> if ( ! cb - > java _ arg _ types [ i + 3 ] ) { <nl> goto failure _ cleanup ; <nl> } <nl> - if ( cb - > flags [ i ] = = CVT _ NATIVE _ MAPPED <nl> - | | cb - > flags [ i ] = = CVT _ POINTER _ TYPE <nl> - | | cb - > flags [ i ] = = CVT _ INTEGER _ TYPE ) { <nl> + if ( cb - > conversion _ flags [ i ] = = CVT _ NATIVE _ MAPPED <nl> + | | cb - > conversion _ flags [ i ] = = CVT _ POINTER _ TYPE <nl> + | | cb - > conversion _ flags [ i ] = = CVT _ INTEGER _ TYPE ) { <nl> jclass ncls ; <nl> ncls = getNativeType ( env , cls ) ; <nl> jtype = get _ jtype ( env , ncls ) ; <nl> @ @ - 162 , 7 + 162 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> if ( cb - > arg _ types [ i ] - > type = = FFI _ TYPE _ FLOAT ) { <nl> / / Java method is varargs , so promote floats to double <nl> cb - > java _ arg _ types [ i + 3 ] = & ffi _ type _ double ; <nl> - cb - > flags [ i ] = CVT _ FLOAT ; <nl> + cb - > conversion _ flags [ i ] = CVT _ FLOAT ; <nl> cvt = 1 ; <nl> } <nl> else if ( cb - > java _ arg _ types [ i + 3 ] - > type = = FFI _ TYPE _ STRUCT ) { <nl> @ @ - 171 , 8 + 171 , 8 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , <nl> } <nl> } <nl> if ( ! direct | | ! cvt ) { <nl> - free ( cb - > flags ) ; <nl> - cb - > flags = NULL ; <nl> + free ( cb - > conversion _ flags ) ; <nl> + cb - > conversion _ flags = NULL ; <nl> free ( cb - > arg _ classes ) ; <nl> cb - > arg _ classes = NULL ; <nl> } <nl> @ @ - 279 , 8 + 279 , 8 @ @ free _ callback ( JNIEnv * env , callback * cb ) { <nl> free ( cb - > arg _ classes ) ; <nl> } <nl> free ( cb - > java _ arg _ types ) ; <nl> - if ( cb - > flags ) { <nl> - free ( cb - > flags ) ; <nl> + if ( cb - > conversion _ flags ) { <nl> + free ( cb - > conversion _ flags ) ; <nl> } <nl> free ( cb - > arg _ jtypes ) ; <nl> # ifdef DLL _ FPTRS <nl> @ @ - 344 , 9 + 344 , 9 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar <nl> args [ 2 ] = & cb - > methodID ; <nl> memcpy ( & args [ 3 ] , cbargs , cif - > nargs * sizeof ( void * ) ) ; <nl> <nl> - if ( cb - > flags ) { <nl> + if ( cb - > conversion _ flags ) { <nl> for ( i = 0 ; i < cif - > nargs ; i + + ) { <nl> - switch ( cb - > flags [ i ] ) { <nl> + switch ( cb - > conversion _ flags [ i ] ) { <nl> case CVT _ INTEGER _ TYPE : <nl> case CVT _ POINTER _ TYPE : <nl> case CVT _ NATIVE _ MAPPED : <nl> @ @ - 364 , 11 + 364 , 11 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar <nl> * ( ( void * * ) args [ i + 3 ] ) = newJavaWString ( env , * ( void * * ) cbargs [ i ] ) ; <nl> break ; <nl> case CVT _ STRUCTURE : <nl> - * ( ( void * * ) args [ i + 3 ] ) = newJavaStructure ( env , * ( void * * ) cbargs [ i ] , cb - > arg _ classes [ i ] , JNI _ FALSE ) ; <nl> + * ( ( void * * ) args [ i + 3 ] ) = newJavaStructure ( env , * ( void * * ) cbargs [ i ] , cb - > arg _ classes [ i ] ) ; <nl> break ; <nl> case CVT _ STRUCTURE _ BYVAL : <nl> 	 args [ i + 3 ] = alloca ( sizeof ( void * ) ) ; <nl> - 	 * ( ( void * * ) args [ i + 3 ] ) = newJavaStructure ( env , cbargs [ i ] , cb - > arg _ classes [ i ] , JNI _ TRUE ) ; <nl> + 	 * ( ( void * * ) args [ i + 3 ] ) = newJavaStructure ( env , cbargs [ i ] , cb - > arg _ classes [ i ] ) ; <nl> break ; <nl> case CVT _ CALLBACK : <nl> * ( ( void * * ) args [ i + 3 ] ) = newJavaCallback ( env , * ( void * * ) cbargs [ i ] , cb - > arg _ classes [ i ] ) ; <nl> @ @ - 437 , 9 + 437 , 9 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar <nl> break ; <nl> default : break ; <nl> } <nl> - if ( cb - > flags ) { <nl> + if ( cb - > conversion _ flags ) { <nl> for ( i = 0 ; i < cif - > nargs ; i + + ) { <nl> - if ( cb - > flags [ i ] = = CVT _ STRUCTURE ) { <nl> + if ( cb - > conversion _ flags [ i ] = = CVT _ STRUCTURE ) { <nl> writeStructure ( env , * ( void * * ) cbargs [ i ] ) ; <nl> } <nl> } <nl> diff - - git a / native / dispatch . c b / native / dispatch . c <nl> index 7f0ecf7 . . ac60b41 100644 <nl> - - - a / native / dispatch . c <nl> + + + b / native / dispatch . c <nl> @ @ - 262 , 7 + 262 , 6 @ @ static jmethodID MID _ Native _ toNativeTypeMapped ; <nl> static jmethodID MID _ Native _ fromNativeTypeMapped ; <nl> static jmethodID MID _ Structure _ getTypeInfo ; <nl> static jmethodID MID _ Structure _ newInstance ; <nl> - static jmethodID MID _ Structure _ useMemory ; <nl> static jmethodID MID _ Structure _ read ; <nl> static jmethodID MID _ Structure _ write ; <nl> static jmethodID MID _ CallbackReference _ getCallback ; <nl> @ @ - 816 , 25 + 815 , 11 @ @ newJavaPointer ( JNIEnv * env , void * p ) <nl> } <nl> <nl> jobject <nl> - newJavaStructure ( JNIEnv * env , void * data , jclass type , jboolean new _ memory ) <nl> + newJavaStructure ( JNIEnv * env , void * data , jclass type ) <nl> { <nl> if ( data ! = NULL ) { <nl> - volatile jobject obj = ( * env ) - > CallStaticObjectMethod ( env , classStructure , MID _ Structure _ newInstance , type ) ; <nl> - if ( obj ! = NULL ) { <nl> - ffi _ type * rtype = getStructureType ( env , obj ) ; <nl> - if ( rtype ) { <nl> - if ( new _ memory ) { <nl> - MEMCPY ( getStructureAddress ( env , obj ) , data , rtype - > size ) ; <nl> - } <nl> - else { <nl> - ( * env ) - > CallVoidMethod ( env , obj , MID _ Structure _ useMemory , newJavaPointer ( env , data ) ) ; <nl> - } <nl> - if ( ! ( * env ) - > ExceptionCheck ( env ) ) { <nl> - ( * env ) - > CallVoidMethod ( env , obj , MID _ Structure _ read ) ; <nl> - } <nl> - } <nl> - } <nl> - else { <nl> + volatile jobject obj = ( * env ) - > CallStaticObjectMethod ( env , classStructure , MID _ Structure _ newInstance , type , A2L ( data ) ) ; <nl> + if ( obj = = NULL ) { <nl> fprintf ( stderr , " JNA : failed to create structure \ n " ) ; <nl> } <nl> return obj ; <nl> @ @ - 1016 , 7 + 1001 , 7 @ @ initializeThread ( callback * cb , AttachOptions * args ) { <nl> { <nl> jobject cbobj = ( * env ) - > NewLocalRef ( env , cb - > object ) ; <nl> if ( ! ( * env ) - > IsSameObject ( env , cbobj , NULL ) ) { <nl> - jobject argsobj = newJavaStructure ( env , args , classAttachOptions , JNI _ FALSE ) ; <nl> + jobject argsobj = newJavaStructure ( env , args , classAttachOptions ) ; <nl> group = ( * env ) - > CallStaticObjectMethod ( env , classCallbackReference , <nl> MID _ CallbackReference _ initializeThread , <nl> cbobj , argsobj ) ; <nl> @ @ - 1530 , 8 + 1515 , 9 @ @ get _ ffi _ type ( JNIEnv * env , jclass cls , char jtype ) { <nl> case ' V ' : <nl> return & ffi _ type _ void ; <nl> case ' s ' : { <nl> + # define PLACEHOLDER _ MEMORY 0 <nl> jobject s = ( * env ) - > CallStaticObjectMethod ( env , classStructure , <nl> - MID _ Structure _ newInstance , cls ) ; <nl> + MID _ Structure _ newInstance , cls , PLACEHOLDER _ MEMORY ) ; <nl> if ( s ) { <nl> return getStructureType ( env , s ) ; <nl> } <nl> @ @ - 1767 , 10 + 1753 , 10 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { <nl> * ( void * * ) resp = newJavaWString ( env , * ( void * * ) resp ) ; <nl> break ; <nl> case CVT _ STRUCTURE : <nl> - * ( void * * ) resp = newJavaStructure ( env , * ( void * * ) resp , data - > closure _ rclass , JNI _ FALSE ) ; <nl> + * ( void * * ) resp = newJavaStructure ( env , * ( void * * ) resp , data - > closure _ rclass ) ; <nl> break ; <nl> case CVT _ STRUCTURE _ BYVAL : <nl> - * ( void * * ) oldresp = newJavaStructure ( env , resp , data - > closure _ rclass , JNI _ TRUE ) ; <nl> + * ( void * * ) oldresp = newJavaStructure ( env , resp , data - > closure _ rclass ) ; <nl> break ; <nl> case CVT _ CALLBACK : <nl> * ( void * * ) resp = newJavaCallback ( env , * ( void * * ) resp , data - > closure _ rclass ) ; <nl> @ @ - 2626 , 15 + 2612 , 10 @ @ Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { <nl> } <nl> else if ( ! ( MID _ Structure _ newInstance <nl> = ( * env ) - > GetStaticMethodID ( env , classStructure , <nl> - " newInstance " , " ( Ljava / lang / Class ; ) Lcom / sun / jna / Structure ; " ) ) ) { <nl> + " newInstance " , " ( Ljava / lang / Class ; J ) Lcom / sun / jna / Structure ; " ) ) ) { <nl> throwByName ( env , EUnsatisfiedLink , <nl> " Can ' t obtain static newInstance method for class com . sun . jna . Structure " ) ; <nl> } <nl> - else if ( ! LOAD _ MID ( env , MID _ Structure _ useMemory , classStructure , <nl> - " useMemory " , " ( Lcom / sun / jna / Pointer ; ) V " ) ) { <nl> - throwByName ( env , EUnsatisfiedLink , <nl> - " Can ' t obtain useMemory method for class com . sun . jna . Structure " ) ; <nl> - } <nl> else if ( ! LOAD _ MID ( env , MID _ Structure _ read , classStructure , <nl> " autoRead " , " ( ) V " ) ) { <nl> throwByName ( env , EUnsatisfiedLink , <nl> diff - - git a / native / dispatch . h b / native / dispatch . h <nl> index 79e071b . . 91e2626 100644 <nl> - - - a / native / dispatch . h <nl> + + + b / native / dispatch . h <nl> @ @ - 103 , 7 + 103 , 7 @ @ typedef struct _ callback { <nl> ffi _ type * * arg _ types ; <nl> ffi _ type * * java _ arg _ types ; <nl> jobject * arg _ classes ; <nl> - int * flags ; <nl> + int * conversion _ flags ; <nl> int rflag ; <nl> JavaVM * vm ; <nl> jobject object ; <nl> @ @ - 184 , 7 + 184 , 7 @ @ extern jboolean ffi _ error ( JNIEnv * , const char * , ffi _ status ) ; <nl> extern jobject newJavaPointer ( JNIEnv * , void * ) ; <nl> extern jstring newJavaString ( JNIEnv * , const char * , jboolean ) ; <nl> extern jobject newJavaWString ( JNIEnv * , const wchar _ t * ) ; <nl> - extern jobject newJavaStructure ( JNIEnv * , void * , jclass , jboolean ) ; <nl> + extern jobject newJavaStructure ( JNIEnv * , void * , jclass ) ; <nl> extern jobject newJavaCallback ( JNIEnv * , void * , jclass ) ; <nl> extern void * getNativeString ( JNIEnv * , jstring , jboolean ) ; <nl> extern void * getNativeAddress ( JNIEnv * , jobject ) ; <nl> diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java <nl> index 864ae5a . . efc6b31 100644 <nl> - - - a / src / com / sun / jna / Structure . java <nl> + + + b / src / com / sun / jna / Structure . java <nl> @ @ - 493 , 12 + 493 , 11 @ @ public abstract class Structure { <nl> * Reads the fields of the struct from native memory <nl> * / <nl> public void read ( ) { <nl> - readCalled = true ; <nl> - <nl> / / Avoid reading from a null pointer <nl> if ( memory = = PLACEHOLDER _ MEMORY ) { <nl> return ; <nl> } <nl> + readCalled = true ; <nl> <nl> / / convenience : allocate memory and / or calculate size if it hasn ' t <nl> / / been already ; this allows structures to do field - based <nl> @ @ - 1536 , 6 + 1535 , 18 @ @ public abstract class Structure { <nl> return FFIType . get ( obj ) ; <nl> } <nl> <nl> + / * * Called from native code only ; same as { @ link <nl> + * # newInstance ( Class , Pointer ) } , except that it additionally performs <nl> + * { @ link # conditionalAutoRead ( ) } . <nl> + * / <nl> + private static Structure newInstance ( Class type , long init ) throws IllegalArgumentException { <nl> + Structure s = newInstance ( type , init = = 0 ? PLACEHOLDER _ MEMORY : new Pointer ( init ) ) ; <nl> + if ( init ! = 0 ) { <nl> + s . conditionalAutoRead ( ) ; <nl> + } <nl> + return s ; <nl> + } <nl> + <nl> / * * Create a new Structure instance of the given type , initialized with <nl> * the given memory . <nl> * @ param type desired Structure type <nl> diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java <nl> index fc0774b . . c127823 100644 <nl> - - - a / test / com / sun / jna / CallbacksTest . java <nl> + + + b / test / com / sun / jna / CallbacksTest . java <nl> @ @ - 260 , 6 + 260 , 11 @ @ public class CallbacksTest extends TestCase { <nl> assertEquals ( " Callback lookups for same pointer should return same Callback object " , cb , cb2 ) ; <nl> } <nl> <nl> + / / Allow direct tests to override <nl> + protected Map callbackCache ( ) { <nl> + return CallbackReference . callbackMap ; <nl> + } <nl> + <nl> / / Fails on OpenJDK ( linux / ppc ) , probably finalize not run <nl> public void testGCCallbackOnFinalize ( ) throws Exception { <nl> final boolean [ ] called = { false } ; <nl> @ @ - 271 , 10 + 276 , 10 @ @ public class CallbacksTest extends TestCase { <nl> lib . callVoidCallback ( cb ) ; <nl> assertTrue ( " Callback not called " , called [ 0 ] ) ; <nl> <nl> - Map refs = new WeakHashMap ( CallbackReference . callbackMap ) ; <nl> + Map refs = new WeakHashMap ( callbackCache ( ) ) ; <nl> assertTrue ( " Callback not cached " , refs . containsKey ( cb ) ) ; <nl> CallbackReference ref = ( CallbackReference ) refs . get ( cb ) ; <nl> - refs = CallbackReference . callbackMap ; <nl> + refs = callbackCache ( ) ; <nl> Pointer cbstruct = ref . cbstruct ; <nl> <nl> cb = null ; <nl> @ @ - 428 , 10 + 433 , 8 @ @ public class CallbacksTest extends TestCase { <nl> assertEquals ( " Structure return not synched " , <nl> MAGIC , value . value , 0d ) ; <nl> / / All structures involved should be created from pointers , with no <nl> - / / memory allocation at all . Not yet implemented for direct callbacks . <nl> - if ( getClass ( ) = = CallbacksTest . class ) { <nl> - assertEquals ( " No structure memory should be allocated " , 0 , SmallTestStructure . allocations ) ; <nl> - } <nl> + / / memory allocation at all . <nl> + assertEquals ( " No structure memory should be allocated " , 0 , SmallTestStructure . allocations ) ; <nl> } <nl> <nl> public void testCallStructureArrayCallback ( ) { <nl> @ @ - 1141 , 10 + 1144 , 10 @ @ public class CallbacksTest extends TestCase { <nl> lib . callVoidCallback ( cb ) ; <nl> assertTrue ( " Callback not called " , called [ 0 ] ) ; <nl> <nl> - Map refs = new WeakHashMap ( CallbackReference . callbackMap ) ; <nl> + Map refs = new WeakHashMap ( callbackCache ( ) ) ; <nl> assertTrue ( " Callback not cached " , refs . containsKey ( cb ) ) ; <nl> CallbackReference ref = ( CallbackReference ) refs . get ( cb ) ; <nl> - refs = CallbackReference . callbackMap ; <nl> + refs = callbackCache ( ) ; <nl> Pointer cbstruct = ref . cbstruct ; <nl> Pointer first _ fptr = cbstruct . getPointer ( 0 ) ; <nl> <nl> diff - - git a / test / com / sun / jna / DirectCallbacksTest . java b / test / com / sun / jna / DirectCallbacksTest . java <nl> index e308900 . . 11347d2 100644 <nl> - - - a / test / com / sun / jna / DirectCallbacksTest . java <nl> + + + b / test / com / sun / jna / DirectCallbacksTest . java <nl> @ @ - 56 , 6 + 56 , 10 @ @ public class DirectCallbacksTest extends CallbacksTest { <nl> lib = new DirectTestLibrary ( ) ; <nl> } <nl> <nl> + protected Map callbackCache ( ) { <nl> + return CallbackReference . directCallbackMap ; <nl> + } <nl> + <nl> public static class DirectCallbackTestLibrary implements CallbackTestLibrary { <nl> public native double callInt32Callback ( DoubleCallback c , double arg , double arg2 ) ; <nl> public native float callInt64Callback ( FloatCallback c , float arg , float arg2 ) ; <nl> diff - - git a / test / com / sun / jna / ReturnTypesTest . java b / test / com / sun / jna / ReturnTypesTest . java <nl> index 8020b3c . . c2ca2c3 100644 <nl> - - - a / test / com / sun / jna / ReturnTypesTest . java <nl> + + + b / test / com / sun / jna / ReturnTypesTest . java <nl> @ @ - 240 , 10 + 240 , 8 @ @ public class ReturnTypesTest extends TestCase { <nl> SimpleStructure . allocations = 0 ; <nl> SimpleStructure s = lib . returnStaticTestStructure ( ) ; <nl> assertEquals ( " Expect test structure magic " , DOUBLE _ MAGIC , s . value , 0d ) ; <nl> - / / Optimized structure allocation not yet implemented for direct mapping <nl> - if ( getClass ( ) = = ReturnTypesTest . class ) { <nl> - assertEquals ( " Returned Structure should allocate no memory " , 0 , SimpleStructure . allocations ) ; <nl> - } <nl> + / / Optimized structure allocation <nl> + assertEquals ( " Returned Structure should allocate no memory " , 0 , SimpleStructure . allocations ) ; <nl> } <nl> <nl> public void testInvokeNullStructure ( ) { <nl> diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java <nl> index 8bd7ad3 . . 108bf22 100644 <nl> - - - a / test / com / sun / jna / StructureTest . java <nl> + + + b / test / com / sun / jna / StructureTest . java <nl> @ @ - 381 , 10 + 381 , 9 @ @ public class StructureTest extends TestCase { <nl> } <nl> <nl> / / TODO : add ' l newInstance ( Pointer ) tests : <nl> - / / DirectCallbacksTest . testCallStructureCallback <nl> - / / DirectReturnTypesTest . testInvokeStructure <nl> + / / NOTE : ensure structure - by - value respected ( no more flag on newjavastructure ) <nl> + / / native call ( direct mode ) <nl> / / getNativeAlignment <nl> - / / native call ( direct mode ) ( maybe not . . . ) <nl> public void testStructureFieldAvoidsSeparateMemoryAllocation ( ) { <nl> class TestStructure extends Structure { <nl> public NonAllocatingTestStructure s1 ;
NEAREST DIFF (one line): diff - - git a / build . xml b / build . xml <nl> index 3dbe75d . . 3ce7453 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 162 , 21 + 162 , 18 @ @ <nl> < / target > <nl> <nl> < target name = " - setup " depends = " - dynamic - properties " > <nl> - 	 < path id = " compile - test . path " > <nl> - < pathelement path = " $ { test . src } " / > <nl> + < path id = " compile - test . path " > <nl> < path id = " test . libs " > <nl> < fileset dir = " lib " > <nl> < include name = " junit . jar " / > <nl> < / fileset > <nl> < pathelement path = " $ { classes } " / > <nl> < / path > <nl> - < path id = " compile . path " > <nl> - < path id = " src . path " > <nl> - < pathelement location = " $ { src } " / > <nl> - < / path > <nl> - < / path > <nl> - < / path > <nl> - <nl> + < / path > <nl> + < path id = " compile . path " / > <nl> + < path id = " src . path " > <nl> + < pathelement location = " $ { src } " / > <nl> + < / path > <nl> < path id = " test . runpath " > <nl> < pathelement path = " $ { build } / $ { jar } " / > <nl> < pathelement path = " $ { test . classes } " / > <nl> @ @ - 193 , 7 + 190 , 7 @ @ <nl> destdir = " $ { classes } " <nl> includeantruntime = " false " <nl> deprecation = " on " debug = " $ { debug } " > <nl> - < src path = " $ { src } " / > <nl> + < src refid = " src . path " / > <nl> < / javac > <nl> < / target > <nl>

TEST DIFF:
diff - - git a / native / callback . c b / native / callback . c 
 index e7c59cb . . a1c7e30 100644 
 - - - a / native / callback . c 
 + + + b / native / callback . c 
 @ @ - 109 , 7 + 109 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 cb - > arg _ types = ( ffi _ type * * ) malloc ( sizeof ( ffi _ type * ) * argc ) ; 
 cb - > java _ arg _ types = ( ffi _ type * * ) malloc ( sizeof ( ffi _ type * ) * ( argc + 3 ) ) ; 
 cb - > arg _ jtypes = ( char * ) malloc ( sizeof ( char ) * argc ) ; 
 - cb - > flags = ( int * ) malloc ( sizeof ( int ) * argc ) ; 
 + cb - > conversion _ flags = ( int * ) malloc ( sizeof ( int ) * argc ) ; 
 cb - > rflag = CVT _ DEFAULT ; 
 cb - > arg _ classes = ( jobject * ) malloc ( sizeof ( jobject ) * argc ) ; 
 
 @ @ - 119 , 7 + 119 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 for ( i = 0 ; i < argc ; i + + ) { 
 int jtype ; 
 jclass cls = ( * env ) - > GetObjectArrayElement ( env , param _ types , i ) ; 
 - if ( ( cb - > flags [ i ] = get _ conversion _ flag ( env , cls ) ) ! = CVT _ DEFAULT ) { 
 + if ( ( cb - > conversion _ flags [ i ] = get _ conversion _ flag ( env , cls ) ) ! = CVT _ DEFAULT ) { 
 cb - > arg _ classes [ i ] = ( * env ) - > NewWeakGlobalRef ( env , cls ) ; 
 cvt = 1 ; 
 } 
 @ @ - 139 , 9 + 139 , 9 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 if ( ! cb - > java _ arg _ types [ i + 3 ] ) { 
 goto failure _ cleanup ; 
 } 
 - if ( cb - > flags [ i ] = = CVT _ NATIVE _ MAPPED 
 - | | cb - > flags [ i ] = = CVT _ POINTER _ TYPE 
 - | | cb - > flags [ i ] = = CVT _ INTEGER _ TYPE ) { 
 + if ( cb - > conversion _ flags [ i ] = = CVT _ NATIVE _ MAPPED 
 + | | cb - > conversion _ flags [ i ] = = CVT _ POINTER _ TYPE 
 + | | cb - > conversion _ flags [ i ] = = CVT _ INTEGER _ TYPE ) { 
 jclass ncls ; 
 ncls = getNativeType ( env , cls ) ; 
 jtype = get _ jtype ( env , ncls ) ; 
 @ @ - 162 , 7 + 162 , 7 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 if ( cb - > arg _ types [ i ] - > type = = FFI _ TYPE _ FLOAT ) { 
 / / Java method is varargs , so promote floats to double 
 cb - > java _ arg _ types [ i + 3 ] = & ffi _ type _ double ; 
 - cb - > flags [ i ] = CVT _ FLOAT ; 
 + cb - > conversion _ flags [ i ] = CVT _ FLOAT ; 
 cvt = 1 ; 
 } 
 else if ( cb - > java _ arg _ types [ i + 3 ] - > type = = FFI _ TYPE _ STRUCT ) { 
 @ @ - 171 , 8 + 171 , 8 @ @ create _ callback ( JNIEnv * env , jobject obj , jobject method , 
 } 
 } 
 if ( ! direct | | ! cvt ) { 
 - free ( cb - > flags ) ; 
 - cb - > flags = NULL ; 
 + free ( cb - > conversion _ flags ) ; 
 + cb - > conversion _ flags = NULL ; 
 free ( cb - > arg _ classes ) ; 
 cb - > arg _ classes = NULL ; 
 } 
 @ @ - 279 , 8 + 279 , 8 @ @ free _ callback ( JNIEnv * env , callback * cb ) { 
 free ( cb - > arg _ classes ) ; 
 } 
 free ( cb - > java _ arg _ types ) ; 
 - if ( cb - > flags ) { 
 - free ( cb - > flags ) ; 
 + if ( cb - > conversion _ flags ) { 
 + free ( cb - > conversion _ flags ) ; 
 } 
 free ( cb - > arg _ jtypes ) ; 
 # ifdef DLL _ FPTRS 
 @ @ - 344 , 9 + 344 , 9 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar 
 args [ 2 ] = & cb - > methodID ; 
 memcpy ( & args [ 3 ] , cbargs , cif - > nargs * sizeof ( void * ) ) ; 
 
 - if ( cb - > flags ) { 
 + if ( cb - > conversion _ flags ) { 
 for ( i = 0 ; i < cif - > nargs ; i + + ) { 
 - switch ( cb - > flags [ i ] ) { 
 + switch ( cb - > conversion _ flags [ i ] ) { 
 case CVT _ INTEGER _ TYPE : 
 case CVT _ POINTER _ TYPE : 
 case CVT _ NATIVE _ MAPPED : 
 @ @ - 364 , 11 + 364 , 11 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar 
 * ( ( void * * ) args [ i + 3 ] ) = newJavaWString ( env , * ( void * * ) cbargs [ i ] ) ; 
 break ; 
 case CVT _ STRUCTURE : 
 - * ( ( void * * ) args [ i + 3 ] ) = newJavaStructure ( env , * ( void * * ) cbargs [ i ] , cb - > arg _ classes [ i ] , JNI _ FALSE ) ; 
 + * ( ( void * * ) args [ i + 3 ] ) = newJavaStructure ( env , * ( void * * ) cbargs [ i ] , cb - > arg _ classes [ i ] ) ; 
 break ; 
 case CVT _ STRUCTURE _ BYVAL : 
 	 args [ i + 3 ] = alloca ( sizeof ( void * ) ) ; 
 - 	 * ( ( void * * ) args [ i + 3 ] ) = newJavaStructure ( env , cbargs [ i ] , cb - > arg _ classes [ i ] , JNI _ TRUE ) ; 
 + 	 * ( ( void * * ) args [ i + 3 ] ) = newJavaStructure ( env , cbargs [ i ] , cb - > arg _ classes [ i ] ) ; 
 break ; 
 case CVT _ CALLBACK : 
 * ( ( void * * ) args [ i + 3 ] ) = newJavaCallback ( env , * ( void * * ) cbargs [ i ] , cb - > arg _ classes [ i ] ) ; 
 @ @ - 437 , 9 + 437 , 9 @ @ callback _ invoke ( JNIEnv * env , callback * cb , ffi _ cif * cif , void * resp , void * * cbar 
 break ; 
 default : break ; 
 } 
 - if ( cb - > flags ) { 
 + if ( cb - > conversion _ flags ) { 
 for ( i = 0 ; i < cif - > nargs ; i + + ) { 
 - if ( cb - > flags [ i ] = = CVT _ STRUCTURE ) { 
 + if ( cb - > conversion _ flags [ i ] = = CVT _ STRUCTURE ) { 
 writeStructure ( env , * ( void * * ) cbargs [ i ] ) ; 
 } 
 } 
 diff - - git a / native / dispatch . c b / native / dispatch . c 
 index 7f0ecf7 . . ac60b41 100644 
 - - - a / native / dispatch . c 
 + + + b / native / dispatch . c 
 @ @ - 262 , 7 + 262 , 6 @ @ static jmethodID MID _ Native _ toNativeTypeMapped ; 
 static jmethodID MID _ Native _ fromNativeTypeMapped ; 
 static jmethodID MID _ Structure _ getTypeInfo ; 
 static jmethodID MID _ Structure _ newInstance ; 
 - static jmethodID MID _ Structure _ useMemory ; 
 static jmethodID MID _ Structure _ read ; 
 static jmethodID MID _ Structure _ write ; 
 static jmethodID MID _ CallbackReference _ getCallback ; 
 @ @ - 816 , 25 + 815 , 11 @ @ newJavaPointer ( JNIEnv * env , void * p ) 
 } 
 
 jobject 
 - newJavaStructure ( JNIEnv * env , void * data , jclass type , jboolean new _ memory ) 
 + newJavaStructure ( JNIEnv * env , void * data , jclass type ) 
 { 
 if ( data ! = NULL ) { 
 - volatile jobject obj = ( * env ) - > CallStaticObjectMethod ( env , classStructure , MID _ Structure _ newInstance , type ) ; 
 - if ( obj ! = NULL ) { 
 - ffi _ type * rtype = getStructureType ( env , obj ) ; 
 - if ( rtype ) { 
 - if ( new _ memory ) { 
 - MEMCPY ( getStructureAddress ( env , obj ) , data , rtype - > size ) ; 
 - } 
 - else { 
 - ( * env ) - > CallVoidMethod ( env , obj , MID _ Structure _ useMemory , newJavaPointer ( env , data ) ) ; 
 - } 
 - if ( ! ( * env ) - > ExceptionCheck ( env ) ) { 
 - ( * env ) - > CallVoidMethod ( env , obj , MID _ Structure _ read ) ; 
 - } 
 - } 
 - } 
 - else { 
 + volatile jobject obj = ( * env ) - > CallStaticObjectMethod ( env , classStructure , MID _ Structure _ newInstance , type , A2L ( data ) ) ; 
 + if ( obj = = NULL ) { 
 fprintf ( stderr , " JNA : failed to create structure \ n " ) ; 
 } 
 return obj ; 
 @ @ - 1016 , 7 + 1001 , 7 @ @ initializeThread ( callback * cb , AttachOptions * args ) { 
 { 
 jobject cbobj = ( * env ) - > NewLocalRef ( env , cb - > object ) ; 
 if ( ! ( * env ) - > IsSameObject ( env , cbobj , NULL ) ) { 
 - jobject argsobj = newJavaStructure ( env , args , classAttachOptions , JNI _ FALSE ) ; 
 + jobject argsobj = newJavaStructure ( env , args , classAttachOptions ) ; 
 group = ( * env ) - > CallStaticObjectMethod ( env , classCallbackReference , 
 MID _ CallbackReference _ initializeThread , 
 cbobj , argsobj ) ; 
 @ @ - 1530 , 8 + 1515 , 9 @ @ get _ ffi _ type ( JNIEnv * env , jclass cls , char jtype ) { 
 case ' V ' : 
 return & ffi _ type _ void ; 
 case ' s ' : { 
 + # define PLACEHOLDER _ MEMORY 0 
 jobject s = ( * env ) - > CallStaticObjectMethod ( env , classStructure , 
 - MID _ Structure _ newInstance , cls ) ; 
 + MID _ Structure _ newInstance , cls , PLACEHOLDER _ MEMORY ) ; 
 if ( s ) { 
 return getStructureType ( env , s ) ; 
 } 
 @ @ - 1767 , 10 + 1753 , 10 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { 
 * ( void * * ) resp = newJavaWString ( env , * ( void * * ) resp ) ; 
 break ; 
 case CVT _ STRUCTURE : 
 - * ( void * * ) resp = newJavaStructure ( env , * ( void * * ) resp , data - > closure _ rclass , JNI _ FALSE ) ; 
 + * ( void * * ) resp = newJavaStructure ( env , * ( void * * ) resp , data - > closure _ rclass ) ; 
 break ; 
 case CVT _ STRUCTURE _ BYVAL : 
 - * ( void * * ) oldresp = newJavaStructure ( env , resp , data - > closure _ rclass , JNI _ TRUE ) ; 
 + * ( void * * ) oldresp = newJavaStructure ( env , resp , data - > closure _ rclass ) ; 
 break ; 
 case CVT _ CALLBACK : 
 * ( void * * ) resp = newJavaCallback ( env , * ( void * * ) resp , data - > closure _ rclass ) ; 
 @ @ - 2626 , 15 + 2612 , 10 @ @ Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { 
 } 
 else if ( ! ( MID _ Structure _ newInstance 
 = ( * env ) - > GetStaticMethodID ( env , classStructure , 
 - " newInstance " , " ( Ljava / lang / Class ; ) Lcom / sun / jna / Structure ; " ) ) ) { 
 + " newInstance " , " ( Ljava / lang / Class ; J ) Lcom / sun / jna / Structure ; " ) ) ) { 
 throwByName ( env , EUnsatisfiedLink , 
 " Can ' t obtain static newInstance method for class com . sun . jna . Structure " ) ; 
 } 
 - else if ( ! LOAD _ MID ( env , MID _ Structure _ useMemory , classStructure , 
 - " useMemory " , " ( Lcom / sun / jna / Pointer ; ) V " ) ) { 
 - throwByName ( env , EUnsatisfiedLink , 
 - " Can ' t obtain useMemory method for class com . sun . jna . Structure " ) ; 
 - } 
 else if ( ! LOAD _ MID ( env , MID _ Structure _ read , classStructure , 
 " autoRead " , " ( ) V " ) ) { 
 throwByName ( env , EUnsatisfiedLink , 
 diff - - git a / native / dispatch . h b / native / dispatch . h 
 index 79e071b . . 91e2626 100644 
 - - - a / native / dispatch . h 
 + + + b / native / dispatch . h 
 @ @ - 103 , 7 + 103 , 7 @ @ typedef struct _ callback { 
 ffi _ type * * arg _ types ; 
 ffi _ type * * java _ arg _ types ; 
 jobject * arg _ classes ; 
 - int * flags ; 
 + int * conversion _ flags ; 
 int rflag ; 
 JavaVM * vm ; 
 jobject object ; 
 @ @ - 184 , 7 + 184 , 7 @ @ extern jboolean ffi _ error ( JNIEnv * , const char * , ffi _ status ) ; 
 extern jobject newJavaPointer ( JNIEnv * , void * ) ; 
 extern jstring newJavaString ( JNIEnv * , const char * , jboolean ) ; 
 extern jobject newJavaWString ( JNIEnv * , const wchar _ t * ) ; 
 - extern jobject newJavaStructure ( JNIEnv * , void * , jclass , jboolean ) ; 
 + extern jobject newJavaStructure ( JNIEnv * , void * , jclass ) ; 
 extern jobject newJavaCallback ( JNIEnv * , void * , jclass ) ; 
 extern void * getNativeString ( JNIEnv * , jstring , jboolean ) ; 
 extern void * getNativeAddress ( JNIEnv * , jobject ) ; 
 diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java 
 index 864ae5a . . efc6b31 100644 
 - - - a / src / com / sun / jna / Structure . java 
 + + + b / src / com / sun / jna / Structure . java 
 @ @ - 493 , 12 + 493 , 11 @ @ public abstract class Structure { 
 * Reads the fields of the struct from native memory 
 * / 
 public void read ( ) { 
 - readCalled = true ; 
 - 
 / / Avoid reading from a null pointer 
 if ( memory = = PLACEHOLDER _ MEMORY ) { 
 return ; 
 } 
 + readCalled = true ; 
 
 / / convenience : allocate memory and / or calculate size if it hasn ' t 
 / / been already ; this allows structures to do field - based 
 @ @ - 1536 , 6 + 1535 , 18 @ @ public abstract class Structure { 
 return FFIType . get ( obj ) ; 
 } 
 
 + / * * Called from native code only ; same as { @ link 
 + * # newInstance ( Class , Pointer ) } , except that it additionally performs 
 + * { @ link # conditionalAutoRead ( ) } . 
 + * / 
 + private static Structure newInstance ( Class type , long init ) throws IllegalArgumentException { 
 + Structure s = newInstance ( type , init = = 0 ? PLACEHOLDER _ MEMORY : new Pointer ( init ) ) ; 
 + if ( init ! = 0 ) { 
 + s . conditionalAutoRead ( ) ; 
 + } 
 + return s ; 
 + } 
 + 
 / * * Create a new Structure instance of the given type , initialized with 
 * the given memory . 
 * @ param type desired Structure type 
 diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java 
 index fc0774b . . c127823 100644 
 - - - a / test / com / sun / jna / CallbacksTest . java 
 + + + b / test / com / sun / jna / CallbacksTest . java 
 @ @ - 260 , 6 + 260 , 11 @ @ public class CallbacksTest extends TestCase { 
 assertEquals ( " Callback lookups for same pointer should return same Callback object " , cb , cb2 ) ; 
 } 
 
 + / / Allow direct tests to override 
 + protected Map callbackCache ( ) { 
 + return CallbackReference . callbackMap ; 
 + } 
 + 
 / / Fails on OpenJDK ( linux / ppc ) , probably finalize not run 
 public void testGCCallbackOnFinalize ( ) throws Exception { 
 final boolean [ ] called = { false } ; 
 @ @ - 271 , 10 + 276 , 10 @ @ public class CallbacksTest extends TestCase { 
 lib . callVoidCallback ( cb ) ; 
 assertTrue ( " Callback not called " , called [ 0 ] ) ; 
 
 - Map refs = new WeakHashMap ( CallbackReference . callbackMap ) ; 
 + Map refs = new WeakHashMap ( callbackCache ( ) ) ; 
 assertTrue ( " Callback not cached " , refs . containsKey ( cb ) ) ; 
 CallbackReference ref = ( CallbackReference ) refs . get ( cb ) ; 
 - refs = CallbackReference . callbackMap ; 
 + refs = callbackCache ( ) ; 
 Pointer cbstruct = ref . cbstruct ; 
 
 cb = null ; 
 @ @ - 428 , 10 + 433 , 8 @ @ public class CallbacksTest extends TestCase { 
 assertEquals ( " Structure return not synched " , 
 MAGIC , value . value , 0d ) ; 
 / / All structures involved should be created from pointers , with no 
 - / / memory allocation at all . Not yet implemented for direct callbacks . 
 - if ( getClass ( ) = = CallbacksTest . class ) { 
 - assertEquals ( " No structure memory should be allocated " , 0 , SmallTestStructure . allocations ) ; 
 - } 
 + / / memory allocation at all . 
 + assertEquals ( " No structure memory should be allocated " , 0 , SmallTestStructure . allocations ) ; 
 } 
 
 public void testCallStructureArrayCallback ( ) { 
 @ @ - 1141 , 10 + 1144 , 10 @ @ public class CallbacksTest extends TestCase { 
 lib . callVoidCallback ( cb ) ; 
 assertTrue ( " Callback not called " , called [ 0 ] ) ; 
 
 - Map refs = new WeakHashMap ( CallbackReference . callbackMap ) ; 
 + Map refs = new WeakHashMap ( callbackCache ( ) ) ; 
 assertTrue ( " Callback not cached " , refs . containsKey ( cb ) ) ; 
 CallbackReference ref = ( CallbackReference ) refs . get ( cb ) ; 
 - refs = CallbackReference . callbackMap ; 
 + refs = callbackCache ( ) ; 
 Pointer cbstruct = ref . cbstruct ; 
 Pointer first _ fptr = cbstruct . getPointer ( 0 ) ; 
 
 diff - - git a / test / com / sun / jna / DirectCallbacksTest . java b / test / com / sun / jna / DirectCallbacksTest . java 
 index e308900 . . 11347d2 100644 
 - - - a / test / com / sun / jna / DirectCallbacksTest . java 
 + + + b / test / com / sun / jna / DirectCallbacksTest . java 
 @ @ - 56 , 6 + 56 , 10 @ @ public class DirectCallbacksTest extends CallbacksTest { 
 lib = new DirectTestLibrary ( ) ; 
 } 
 
 + protected Map callbackCache ( ) { 
 + return CallbackReference . directCallbackMap ; 
 + } 
 + 
 public static class DirectCallbackTestLibrary implements CallbackTestLibrary { 
 public native double callInt32Callback ( DoubleCallback c , double arg , double arg2 ) ; 
 public native float callInt64Callback ( FloatCallback c , float arg , float arg2 ) ; 
 diff - - git a / test / com / sun / jna / ReturnTypesTest . java b / test / com / sun / jna / ReturnTypesTest . java 
 index 8020b3c . . c2ca2c3 100644 
 - - - a / test / com / sun / jna / ReturnTypesTest . java 
 + + + b / test / com / sun / jna / ReturnTypesTest . java 
 @ @ - 240 , 10 + 240 , 8 @ @ public class ReturnTypesTest extends TestCase { 
 SimpleStructure . allocations = 0 ; 
 SimpleStructure s = lib . returnStaticTestStructure ( ) ; 
 assertEquals ( " Expect test structure magic " , DOUBLE _ MAGIC , s . value , 0d ) ; 
 - / / Optimized structure allocation not yet implemented for direct mapping 
 - if ( getClass ( ) = = ReturnTypesTest . class ) { 
 - assertEquals ( " Returned Structure should allocate no memory " , 0 , SimpleStructure . allocations ) ; 
 - } 
 + / / Optimized structure allocation 
 + assertEquals ( " Returned Structure should allocate no memory " , 0 , SimpleStructure . allocations ) ; 
 } 
 
 public void testInvokeNullStructure ( ) { 
 diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java 
 index 8bd7ad3 . . 108bf22 100644 
 - - - a / test / com / sun / jna / StructureTest . java 
 + + + b / test / com / sun / jna / StructureTest . java 
 @ @ - 381 , 10 + 381 , 9 @ @ public class StructureTest extends TestCase { 
 } 
 
 / / TODO : add ' l newInstance ( Pointer ) tests : 
 - / / DirectCallbacksTest . testCallStructureCallback 
 - / / DirectReturnTypesTest . testInvokeStructure 
 + / / NOTE : ensure structure - by - value respected ( no more flag on newjavastructure ) 
 + / / native call ( direct mode ) 
 / / getNativeAlignment 
 - / / native call ( direct mode ) ( maybe not . . . ) 
 public void testStructureFieldAvoidsSeparateMemoryAllocation ( ) { 
 class TestStructure extends Structure { 
 public NonAllocatingTestStructure s1 ;

NEAREST DIFF:
diff - - git a / build . xml b / build . xml 
 index 3dbe75d . . 3ce7453 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 162 , 21 + 162 , 18 @ @ 
 < / target > 
 
 < target name = " - setup " depends = " - dynamic - properties " > 
 - 	 < path id = " compile - test . path " > 
 - < pathelement path = " $ { test . src } " / > 
 + < path id = " compile - test . path " > 
 < path id = " test . libs " > 
 < fileset dir = " lib " > 
 < include name = " junit . jar " / > 
 < / fileset > 
 < pathelement path = " $ { classes } " / > 
 < / path > 
 - < path id = " compile . path " > 
 - < path id = " src . path " > 
 - < pathelement location = " $ { src } " / > 
 - < / path > 
 - < / path > 
 - < / path > 
 - 
 + < / path > 
 + < path id = " compile . path " / > 
 + < path id = " src . path " > 
 + < pathelement location = " $ { src } " / > 
 + < / path > 
 < path id = " test . runpath " > 
 < pathelement path = " $ { build } / $ { jar } " / > 
 < pathelement path = " $ { test . classes } " / > 
 @ @ - 193 , 7 + 190 , 7 @ @ 
 destdir = " $ { classes } " 
 includeantruntime = " false " 
 deprecation = " on " debug = " $ { debug } " > 
 - < src path = " $ { src } " / > 
 + < src refid = " src . path " / > 
 < / javac > 
 < / target > 

