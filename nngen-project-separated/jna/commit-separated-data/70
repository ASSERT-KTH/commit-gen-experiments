BLEU SCORE: 0.009609192670572678

TEST MSG: Guard registry handling against out - of - bounds reads by ensuring all read strings are NULL terminated
GENERATED MSG: Add REG _ BINARY , REG _ EXPAND _ SZ and REG _ MULTI _ SZ support to Advapi32Util .

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index a4dec9f . . 6af79b9 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 27 , 6 + 27 , 7 @ @ Bug Fixes <nl> * [ # 887 ] ( https : / / github . com / java - native - access / jna / issues / 887 ) : MacFileUtils . moveToTrash ( ) doesn ' t work in a sandboxed app fix suggested by [ @ sobakasu ] ( https : / / github . com / sobakasu ) - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> * [ # 894 ] ( https : / / github . com / java - native - access / jna / issues / 894 ) : NullPointerException can be caused by calling ` com . sun . jna . platform . win32 . COM . util . ProxyObject # dispose ` multiple times - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> * [ # 925 ] ( https : / / github . com / java - native - access / jna / issues / 925 ) : Optimize ` Structure # validate ` and prevent ` ArrayIndexOutOfBoundsException ` in ` SAFEARRAY # read ` for zero dimensions - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> + * [ # 340 ] ( https : / / github . com / java - native - access / jna / issues / 340 ) : Guard registry handling against out - of - bounds reads by ensuring all read strings are NULL terminated - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> <nl> Breaking Changes <nl> - - - - - - - - - - - - - - - - <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> index 9462087 . . f9905a8 100755 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> @ @ - 976 , 11 + 976 , 20 @ @ public interface Advapi32 extends StdCallLibrary { <nl> * defined in Winerror . h . <nl> * / <nl> int RegSetValueEx ( HKEY hKey , String lpValueName , int Reserved , <nl> + int dwType , Pointer lpData , int cbData ) ; <nl> + <nl> + / * * <nl> + * See { @ link # RegSetValueEx ( com . sun . jna . platform . win32 . WinReg . HKEY , java . lang . String , int , int , com . sun . jna . Pointer , int ) } <nl> + * / <nl> + int RegSetValueEx ( HKEY hKey , String lpValueName , int Reserved , <nl> int dwType , char [ ] lpData , int cbData ) ; <nl> <nl> + / * * <nl> + * See { @ link # RegSetValueEx ( com . sun . jna . platform . win32 . WinReg . HKEY , java . lang . String , int , int , com . sun . jna . Pointer , int ) } <nl> + * / <nl> int RegSetValueEx ( HKEY hKey , String lpValueName , int Reserved , <nl> int dwType , byte [ ] lpData , int cbData ) ; <nl> - <nl> + <nl> / * * <nl> * <nl> * @ param hKey registry key <nl> @ @ - 1103 , 6 + 1112 , 13 @ @ public interface Advapi32 extends StdCallLibrary { <nl> * / <nl> int RegEnumValue ( HKEY hKey , int dwIndex , char [ ] lpValueName , <nl> IntByReference lpcchValueName , IntByReference reserved , <nl> + IntByReference lpType , Pointer lpData , IntByReference lpcbData ) ; <nl> + <nl> + / * * <nl> + * See { @ link # RegEnumValue ( com . sun . jna . platform . win32 . WinReg . HKEY , int , char [ ] , com . sun . jna . ptr . IntByReference , com . sun . jna . ptr . IntByReference , com . sun . jna . ptr . IntByReference , com . sun . jna . Pointer , com . sun . jna . ptr . IntByReference ) } . <nl> + * / <nl> + int RegEnumValue ( HKEY hKey , int dwIndex , char [ ] lpValueName , <nl> + IntByReference lpcchValueName , IntByReference reserved , <nl> IntByReference lpType , byte [ ] lpData , IntByReference lpcbData ) ; <nl> <nl> / * * <nl> @ @ - 1295 , 9 + 1311 , 16 @ @ public interface Advapi32 extends StdCallLibrary { <nl> * @ return status <nl> * / <nl> int RegGetValue ( HKEY hkey , String lpSubKey , String lpValue , <nl> + int dwFlags , IntByReference pdwType , Pointer pvData , <nl> + IntByReference pcbData ) ; <nl> + <nl> + / * * <nl> + * See { @ link # RegGetValue ( com . sun . jna . platform . win32 . WinReg . HKEY , java . lang . String , java . lang . String , int , com . sun . jna . ptr . IntByReference , com . sun . jna . Pointer , com . sun . jna . ptr . IntByReference ) } . <nl> + * / <nl> + int RegGetValue ( HKEY hkey , String lpSubKey , String lpValue , <nl> int dwFlags , IntByReference pdwType , byte [ ] pvData , <nl> IntByReference pcbData ) ; <nl> - <nl> + <nl> / * * <nl> * Retrieves a registered handle to the specified event log . <nl> * <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> index 4640757 . . afa5985 100755 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> @ @ - 90 , 7 + 90 , 7 @ @ import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> import com . sun . jna . ptr . LongByReference ; <nl> import com . sun . jna . ptr . PointerByReference ; <nl> - <nl> + import com . sun . jna . win32 . W32APITypeMapper ; <nl> <nl> / * * <nl> * Advapi32 utility API . <nl> @ @ - 607 , 7 + 607 , 7 @ @ public abstract class Advapi32Util { <nl> 	 	 	 IntByReference lpcbData = new IntByReference ( ) ; <nl> 	 	 	 IntByReference lpType = new IntByReference ( ) ; <nl> 	 	 	 rc = Advapi32 . INSTANCE . RegQueryValueEx ( phkKey . getValue ( ) , value , 0 , <nl> - 	 	 	 	 	 lpType , ( char [ ] ) null , lpcbData ) ; <nl> + 	 	 	 	 	 lpType , ( Pointer ) null , lpcbData ) ; <nl> 	 	 	 switch ( rc ) { <nl> 	 	 	 case W32Errors . ERROR _ SUCCESS : <nl> 	 	 	 case W32Errors . ERROR _ MORE _ DATA : <nl> @ @ - 670 , 7 + 670 , 7 @ @ public abstract class Advapi32Util { <nl> 	 	 IntByReference lpcbData = new IntByReference ( ) ; <nl> 	 	 IntByReference lpType = new IntByReference ( ) ; <nl> 	 	 int rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , <nl> - 	 	 	 	 lpType , ( char [ ] ) null , lpcbData ) ; <nl> + 	 	 	 	 lpType , ( Pointer ) null , lpcbData ) ; <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS <nl> 	 	 	 	 & & rc ! = W32Errors . ERROR _ INSUFFICIENT _ BUFFER ) { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> @ @ - 681 , 14 + 681 , 23 @ @ public abstract class Advapi32Util { <nl> 	 	 	 	 	 + lpType . getValue ( ) <nl> 	 	 	 	 	 + " , expected REG _ SZ or REG _ EXPAND _ SZ " ) ; <nl> 	 	 } <nl> - 	 	 char [ ] data = new char [ lpcbData . getValue ( ) ] ; <nl> + if ( lpcbData . getValue ( ) = = 0 ) { <nl> + return " " ; <nl> + } <nl> + / / See comment in # registryGetValue <nl> + Memory mem = new Memory ( lpcbData . getValue ( ) + Native . WCHAR _ SIZE ) ; <nl> + mem . clear ( ) ; <nl> 	 	 rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , <nl> - 	 	 	 	 lpType , data , lpcbData ) ; <nl> + 	 	 	 	 lpType , mem , lpcbData ) ; <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS <nl> 	 	 	 	 & & rc ! = W32Errors . ERROR _ INSUFFICIENT _ BUFFER ) { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> 	 	 } <nl> - 	 	 return Native . toString ( data ) ; <nl> + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { <nl> + return mem . getWideString ( 0 ) ; <nl> + } else { <nl> + return mem . getString ( 0 ) ; <nl> + } <nl> 	 } <nl> <nl> 	 / * * <nl> @ @ - 742 , 14 + 751 , 23 @ @ public abstract class Advapi32Util { <nl> 	 	 	 throw new RuntimeException ( " Unexpected registry type " <nl> 	 	 	 	 	 + lpType . getValue ( ) + " , expected REG _ SZ " ) ; <nl> 	 	 } <nl> - 	 	 char [ ] data = new char [ lpcbData . getValue ( ) ] ; <nl> + if ( lpcbData . getValue ( ) = = 0 ) { <nl> + return " " ; <nl> + } <nl> + / / See comment in # registryGetValue <nl> + Memory mem = new Memory ( lpcbData . getValue ( ) + Native . WCHAR _ SIZE ) ; <nl> + mem . clear ( ) ; <nl> 	 	 rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , <nl> - 	 	 	 	 lpType , data , lpcbData ) ; <nl> + 	 	 	 	 lpType , mem , lpcbData ) ; <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS <nl> 	 	 	 	 & & rc ! = W32Errors . ERROR _ INSUFFICIENT _ BUFFER ) { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> 	 	 } <nl> - 	 	 return Native . toString ( data ) ; <nl> + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { <nl> + return mem . getWideString ( 0 ) ; <nl> + } else { <nl> + return mem . getString ( 0 ) ; <nl> + } <nl> 	 } <nl> <nl> 	 / * * <nl> @ @ - 803 , 7 + 821 , 10 @ @ public abstract class Advapi32Util { <nl> 	 	 	 throw new RuntimeException ( " Unexpected registry type " <nl> 	 	 	 	 	 + lpType . getValue ( ) + " , expected REG _ SZ " ) ; <nl> 	 	 } <nl> - 	 	 Memory data = new Memory ( lpcbData . getValue ( ) ) ; <nl> + / / Allocate enougth memroy to hold value and ensure terminating <nl> + / / double NULL chars are present <nl> + 	 	 Memory data = new Memory ( lpcbData . getValue ( ) + 2 * Native . WCHAR _ SIZE ) ; <nl> + data . clear ( ) ; <nl> 	 	 rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , <nl> 	 	 	 	 lpType , data , lpcbData ) ; <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS <nl> @ @ - 813 , 16 + 834 , 27 @ @ public abstract class Advapi32Util { <nl> 	 	 ArrayList < String > result = new ArrayList < String > ( ) ; <nl> 	 	 int offset = 0 ; <nl> 	 	 while ( offset < data . size ( ) ) { <nl> - 	 	 	 String s = data . getWideString ( offset ) ; <nl> - 	 	 	 offset + = s . length ( ) * Native . WCHAR _ SIZE ; <nl> - 	 	 	 offset + = Native . WCHAR _ SIZE ; <nl> - 	 	 	 if ( s . length ( ) = = 0 & & offset = = data . size ( ) ) { <nl> - 	 	 	 	 / / skip the final NULL <nl> + 	 	 	 String s ; <nl> + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { <nl> + s = data . getWideString ( offset ) ; <nl> + offset + = s . length ( ) * Native . WCHAR _ SIZE ; <nl> + offset + = Native . WCHAR _ SIZE ; <nl> + } else { <nl> + s = data . getString ( offset ) ; <nl> + offset + = s . length ( ) ; <nl> + offset + = 1 ; <nl> + } <nl> + <nl> + 	 	 	 if ( s . length ( ) = = 0 ) { <nl> + / / A sequence of null - terminated strings , <nl> + / / terminated by an empty string ( \ 0 ) . <nl> + / / = > The first empty string terminates the <nl> + 	 	 	 	 break ; <nl> 	 	 	 } else { <nl> 	 	 	 	 result . add ( s ) ; <nl> 	 	 	 } <nl> 	 	 } <nl> - 	 	 return result . toArray ( new String [ 0 ] ) ; <nl> + 	 	 return result . toArray ( new String [ result . size ( ) ] ) ; <nl> 	 } <nl> <nl> 	 / * * <nl> @ @ - 867 , 7 + 899 , 7 @ @ public abstract class Advapi32Util { <nl> 	 	 IntByReference lpcbData = new IntByReference ( ) ; <nl> 	 	 IntByReference lpType = new IntByReference ( ) ; <nl> 	 	 int rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , <nl> - 	 	 	 	 lpType , ( char [ ] ) null , lpcbData ) ; <nl> + 	 	 	 	 lpType , ( Pointer ) null , lpcbData ) ; <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS <nl> 	 	 	 	 & & rc ! = W32Errors . ERROR _ INSUFFICIENT _ BUFFER ) { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> @ @ - 1022 , 11 + 1054 , 10 @ @ public abstract class Advapi32Util { <nl> 	 	 	 String lpValueName ) { <nl> 	 	 Object result = null ; <nl> 	 	 IntByReference lpType = new IntByReference ( ) ; <nl> - 	 	 byte [ ] lpData = new byte [ Advapi32 . MAX _ VALUE _ NAME ] ; <nl> - 	 	 IntByReference lpcbData = new IntByReference ( Advapi32 . MAX _ VALUE _ NAME ) ; <nl> + 	 	 IntByReference lpcbData = new IntByReference ( ) ; <nl> <nl> 	 	 int rc = Advapi32 . INSTANCE . RegGetValue ( hkKey , subKey , lpValueName , <nl> - 	 	 	 	 Advapi32 . RRF _ RT _ ANY , lpType , lpData , lpcbData ) ; <nl> + 	 	 	 	 Advapi32 . RRF _ RT _ ANY , lpType , ( Pointer ) null , lpcbData ) ; <nl> <nl> 	 	 / / if lpType = = 0 then the value is empty ( REG _ NONE ) ! <nl> 	 	 if ( lpType . getValue ( ) = = WinNT . REG _ NONE ) <nl> @ @ - 1037 , 18 + 1068 , 33 @ @ public abstract class Advapi32Util { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> 	 	 } <nl> <nl> - 	 	 Memory byteData = new Memory ( lpcbData . getValue ( ) ) ; <nl> - 	 	 byteData . write ( 0 , lpData , 0 , lpcbData . getValue ( ) ) ; <nl> - <nl> + / / Buffer is intentionally allocated larger than <nl> + / / indicated , as function adds terminating NULL char , if it is <nl> + / / missing . WCHAR _ SIZE is added , as returning string can be <nl> + / / char [ ] or wchar [ ] depending on w32 . ascii <nl> + 	 	 Memory byteData = new Memory ( lpcbData . getValue ( ) + Native . WCHAR _ SIZE ) ; <nl> + byteData . clear ( ) ; <nl> + <nl> + 	 	 rc = Advapi32 . INSTANCE . RegGetValue ( hkKey , subKey , lpValueName , <nl> + 	 	 	 	 Advapi32 . RRF _ RT _ ANY , lpType , byteData , lpcbData ) ; <nl> + <nl> + if ( rc ! = W32Errors . ERROR _ SUCCESS ) { <nl> + throw new Win32Exception ( rc ) ; <nl> + } <nl> + <nl> 	 	 if ( lpType . getValue ( ) = = WinNT . REG _ DWORD ) { <nl> - 	 	 	 result = Integer . valueOf ( byteData . getInt ( 0 ) ) ; <nl> + 	 	 	 result = byteData . getInt ( 0 ) ; <nl> 	 	 } else if ( lpType . getValue ( ) = = WinNT . REG _ QWORD ) { <nl> - 	 	 	 result = Long . valueOf ( byteData . getLong ( 0 ) ) ; <nl> + 	 	 	 result = byteData . getLong ( 0 ) ; <nl> 	 	 } else if ( lpType . getValue ( ) = = WinNT . REG _ BINARY ) { <nl> 	 	 	 result = byteData . getByteArray ( 0 , lpcbData . getValue ( ) ) ; <nl> 	 	 } else if ( ( lpType . getValue ( ) = = WinNT . REG _ SZ ) <nl> 	 	 	 	 | | ( lpType . getValue ( ) = = WinNT . REG _ EXPAND _ SZ ) ) { <nl> - 	 	 	 result = byteData . getWideString ( 0 ) ; <nl> + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { <nl> + result = byteData . getWideString ( 0 ) ; <nl> + } else { <nl> + result = byteData . getString ( 0 ) ; <nl> + } <nl> 	 	 } <nl> <nl> 	 	 return result ; <nl> @ @ - 1230 , 9 + 1276 , 19 @ @ public abstract class Advapi32Util { <nl> 	 * / <nl> 	 public static void registrySetStringValue ( HKEY hKey , String name , <nl> 	 	 	 String value ) { <nl> - 	 	 char [ ] data = Native . toCharArray ( value ) ; <nl> + if ( value = = null ) { <nl> + value = " " ; <nl> + } <nl> + Memory data ; <nl> + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { <nl> + data = new Memory ( ( value . length ( ) + 1 ) * Native . WCHAR _ SIZE ) ; <nl> + data . setWideString ( 0 , value ) ; <nl> + } else { <nl> + data = new Memory ( ( value . length ( ) + 1 ) ) ; <nl> + data . setString ( 0 , value ) ; <nl> + } <nl> 	 	 int rc = Advapi32 . INSTANCE . RegSetValueEx ( hKey , name , 0 , WinNT . REG _ SZ , <nl> - 	 	 	 	 data , data . length * Native . WCHAR _ SIZE ) ; <nl> + 	 	 	 	 data , ( int ) data . size ( ) ) ; <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> 	 	 } <nl> @ @ - 1280 , 9 + 1336 , 16 @ @ public abstract class Advapi32Util { <nl> 	 * / <nl> 	 public static void registrySetExpandableStringValue ( HKEY hKey , String name , <nl> 	 	 	 String value ) { <nl> - 	 	 char [ ] data = Native . toCharArray ( value ) ; <nl> + Memory data ; <nl> + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { <nl> + data = new Memory ( ( value . length ( ) + 1 ) * Native . WCHAR _ SIZE ) ; <nl> + data . setWideString ( 0 , value ) ; <nl> + } else { <nl> + data = new Memory ( ( value . length ( ) + 1 ) ) ; <nl> + data . setString ( 0 , value ) ; <nl> + } <nl> 	 	 int rc = Advapi32 . INSTANCE . RegSetValueEx ( hKey , name , 0 , <nl> - 	 	 	 	 WinNT . REG _ EXPAND _ SZ , data , data . length * Native . WCHAR _ SIZE ) ; <nl> + 	 	 	 	 WinNT . REG _ EXPAND _ SZ , data , ( int ) data . size ( ) ) ; <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> 	 	 } <nl> @ @ - 1330 , 26 + 1393 , 31 @ @ public abstract class Advapi32Util { <nl> 	 * / <nl> 	 public static void registrySetStringArray ( HKEY hKey , String name , <nl> 	 	 	 String [ ] arr ) { <nl> + <nl> + int charwidth = W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ? Native . WCHAR _ SIZE : 1 ; <nl> + <nl> 	 	 int size = 0 ; <nl> 	 	 for ( String s : arr ) { <nl> - 	 	 	 size + = s . length ( ) * Native . WCHAR _ SIZE ; <nl> - 	 	 	 size + = Native . WCHAR _ SIZE ; <nl> + 	 	 	 size + = s . length ( ) * charwidth ; <nl> + 	 	 	 size + = charwidth ; <nl> 	 	 } <nl> - 	 	 size + = Native . WCHAR _ SIZE ; <nl> + 	 	 size + = charwidth ; <nl> <nl> 	 	 int offset = 0 ; <nl> 	 	 Memory data = new Memory ( size ) ; <nl> + data . clear ( ) ; <nl> 	 	 for ( String s : arr ) { <nl> - 	 	 	 data . setWideString ( offset , s ) ; <nl> - 	 	 	 offset + = s . length ( ) * Native . WCHAR _ SIZE ; <nl> - 	 	 	 offset + = Native . WCHAR _ SIZE ; <nl> - 	 	 } <nl> - 	 	 for ( int i = 0 ; i < Native . WCHAR _ SIZE ; i + + ) { <nl> - 	 	 	 data . setByte ( offset + + , ( byte ) 0 ) ; <nl> + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { <nl> + data . setWideString ( offset , s ) ; <nl> + } else { <nl> + data . setString ( offset , s ) ; <nl> + } <nl> + 	 	 	 offset + = s . length ( ) * charwidth ; <nl> + 	 	 	 offset + = charwidth ; <nl> 	 	 } <nl> <nl> 	 	 int rc = Advapi32 . INSTANCE . RegSetValueEx ( hKey , name , 0 , <nl> - 	 	 	 	 WinNT . REG _ MULTI _ SZ , data . getByteArray ( 0 , size ) , size ) ; <nl> + 	 	 	 	 WinNT . REG _ MULTI _ SZ , data , size ) ; <nl> <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> @ @ - 1635 , 15 + 1703 , 19 @ @ public abstract class Advapi32Util { <nl> 	 	 } <nl> 	 	 TreeMap < String , Object > keyValues = new TreeMap < String , Object > ( ) ; <nl> 	 	 char [ ] name = new char [ lpcMaxValueNameLen . getValue ( ) + 1 ] ; <nl> - 	 	 byte [ ] data = new byte [ lpcMaxValueLen . getValue ( ) ] ; <nl> + / / Allocate enough memory to hold largest value and two <nl> + / / terminating WCHARs - - the memory is zeroed so after <nl> + / / value request we should not overread when reading strings <nl> + 	 	 Memory byteData = new Memory ( lpcMaxValueLen . getValue ( ) + 2 * Native . WCHAR _ SIZE ) ; <nl> 	 	 for ( int i = 0 ; i < lpcValues . getValue ( ) ; i + + ) { <nl> + byteData . clear ( ) ; <nl> 	 	 	 IntByReference lpcchValueName = new IntByReference ( <nl> 	 	 	 	 	 lpcMaxValueNameLen . getValue ( ) + 1 ) ; <nl> 	 	 	 IntByReference lpcbData = new IntByReference ( <nl> 	 	 	 	 	 lpcMaxValueLen . getValue ( ) ) ; <nl> 	 	 	 IntByReference lpType = new IntByReference ( ) ; <nl> 	 	 	 rc = Advapi32 . INSTANCE . RegEnumValue ( hKey , i , name , lpcchValueName , <nl> - 	 	 	 	 	 null , lpType , data , lpcbData ) ; <nl> + 	 	 	 	 	 null , lpType , byteData , lpcbData ) ; <nl> 	 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { <nl> 	 	 	 	 throw new Win32Exception ( rc ) ; <nl> 	 	 	 } <nl> @ @ - 1676 , 9 + 1748 , 6 @ @ public abstract class Advapi32Util { <nl> 	 	 	 	 continue ; <nl> 	 	 	 } <nl> <nl> - 	 	 	 Memory byteData = new Memory ( lpcbData . getValue ( ) ) ; <nl> - 	 	 	 byteData . write ( 0 , data , 0 , lpcbData . getValue ( ) ) ; <nl> - <nl> 	 	 	 switch ( lpType . getValue ( ) ) { <nl> 	 	 	 case WinNT . REG _ QWORD : { <nl> 	 	 	 	 keyValues . put ( nameString , byteData . getLong ( 0 ) ) ; <nl> @ @ - 1690 , 7 + 1759 , 11 @ @ public abstract class Advapi32Util { <nl> 	 	 	 } <nl> 	 	 	 case WinNT . REG _ SZ : <nl> 	 	 	 case WinNT . REG _ EXPAND _ SZ : { <nl> - 	 	 	 	 keyValues . put ( nameString , byteData . getWideString ( 0 ) ) ; <nl> + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { <nl> + keyValues . put ( nameString , byteData . getWideString ( 0 ) ) ; <nl> + } else { <nl> + keyValues . put ( nameString , byteData . getString ( 0 ) ) ; <nl> + } <nl> 	 	 	 	 break ; <nl> 	 	 	 } <nl> 	 	 	 case WinNT . REG _ BINARY : { <nl> @ @ - 1699 , 20 + 1772 , 29 @ @ public abstract class Advapi32Util { <nl> 	 	 	 	 break ; <nl> 	 	 	 } <nl> 	 	 	 case WinNT . REG _ MULTI _ SZ : { <nl> - 	 	 	 	 Memory stringData = new Memory ( lpcbData . getValue ( ) ) ; <nl> - 	 	 	 	 stringData . write ( 0 , data , 0 , lpcbData . getValue ( ) ) ; <nl> - 	 	 	 	 ArrayList < String > result = new ArrayList < String > ( ) ; <nl> - 	 	 	 	 int offset = 0 ; <nl> - 	 	 	 	 while ( offset < stringData . size ( ) ) { <nl> - 	 	 	 	 	 String s = stringData . getWideString ( offset ) ; <nl> - 	 	 	 	 	 offset + = s . length ( ) * Native . WCHAR _ SIZE ; <nl> - 	 	 	 	 	 offset + = Native . WCHAR _ SIZE ; <nl> - 	 	 	 	 	 if ( s . length ( ) = = 0 & & offset = = stringData . size ( ) ) { <nl> - 	 	 	 	 	 	 / / skip the final NULL <nl> - 	 	 	 	 	 } else { <nl> - 	 	 	 	 	 	 result . add ( s ) ; <nl> - 	 	 	 	 	 } <nl> - 	 	 	 	 } <nl> + ArrayList < String > result = new ArrayList < String > ( ) ; <nl> + int offset = 0 ; <nl> + while ( offset < byteData . size ( ) ) { <nl> + String s ; <nl> + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { <nl> + s = byteData . getWideString ( offset ) ; <nl> + offset + = s . length ( ) * Native . WCHAR _ SIZE ; <nl> + offset + = Native . WCHAR _ SIZE ; <nl> + } else { <nl> + s = byteData . getString ( offset ) ; <nl> + offset + = s . length ( ) ; <nl> + offset + = 1 ; <nl> + } <nl> + <nl> + if ( s . length ( ) = = 0 ) { <nl> + / / A sequence of null - terminated strings , <nl> + / / terminated by an empty string ( \ 0 ) . <nl> + / / = > The first empty string terminates the <nl> + break ; <nl> + } else { <nl> + result . add ( s ) ; <nl> + } <nl> + } <nl> 	 	 	 	 keyValues . put ( nameString , result . toArray ( new String [ 0 ] ) ) ; <nl> 	 	 	 	 break ; <nl> 	 	 	 } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> index 4a42285 . . bc37ecd 100755 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> @ @ - 100 , 10 + 100 , 11 @ @ public class Advapi32Test extends TestCase { <nl> Collection < String > dupSet = AbstractWin32TestSupport . detectDuplicateMethods ( Advapi32 . class ) ; <nl> if ( dupSet . size ( ) > 0 ) { <nl> for ( String name : new String [ ] { <nl> - / / has several overloads by design since the output value can be several types of data <nl> + / / these have several overloads by design since the input / output values can be several types of data <nl> " RegQueryValueEx " , <nl> - / / has several overloads by design since the input value can be several types of data <nl> - " RegSetValueEx " <nl> + " RegSetValueEx " , <nl> + " RegGetValue " , <nl> + " RegEnumValue " <nl> } ) { <nl> dupSet . remove ( name ) ; <nl> } <nl> @ @ - 640 , 7 + 641 , 7 @ @ public class Advapi32Test extends TestCase { <nl> 	 	 IntByReference lpType = new IntByReference ( ) ; <nl> 	 assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . RegEnumValue ( <nl> 	 	 	 phKey . getValue ( ) , i , name , lpcchValueName , null , <nl> - 	 	 	 lpType , null , null ) ) ; <nl> + 	 	 	 lpType , ( Pointer ) null , null ) ) ; <nl> 	 assertEquals ( Native . toString ( name ) . length ( ) , lpcchValueName . getValue ( ) ) ; <nl> 	 } <nl> 	 assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . RegCloseKey ( phKey . getValue ( ) ) ) ;
NEAREST DIFF (one line): diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> index 978578b . . 8766039 100644 <nl> - - - a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> @ @ - 750 , 9 + 750 , 9 @ @ public abstract class Advapi32Util { <nl> 	 * @ param hKey <nl> 	 * Parent key . <nl> 	 * @ param name <nl> - 	 * Name . <nl> + 	 * Value name . <nl> 	 * @ param value <nl> - 	 * Value . <nl> + 	 * Value to write to registry . <nl> 	 * / <nl> 	 public static void registrySetIntValue ( HKEY hKey , String name , int value ) { <nl> byte [ ] data = new byte [ 4 ] ; <nl> @ @ - 773 , 9 + 773 , 9 @ @ public abstract class Advapi32Util { <nl> 	 * @ param keyPath <nl> 	 * Path to an existing registry key . <nl> 	 * @ param name <nl> - 	 * Name . <nl> + 	 * Value name . <nl> 	 * @ param value <nl> - 	 * Value . <nl> + 	 * Value to write to registry . <nl> 	 * / <nl> 	 public static void registrySetIntValue ( HKEY root , String keyPath , String name , int value ) { <nl> 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; <nl> @ @ - 798 , 9 + 798 , 9 @ @ public abstract class Advapi32Util { <nl> 	 * @ param hKey <nl> 	 * Parent key . <nl> 	 * @ param name <nl> - 	 * Name . <nl> + 	 * Value name . <nl> 	 * @ param value <nl> - 	 * Value . <nl> + 	 * Value to write to registry . <nl> 	 * / <nl> 	 public static void registrySetStringValue ( HKEY hKey , String name , String value ) { <nl> 	 char [ ] data = Native . toCharArray ( value ) ; <nl> @ @ - 818 , 9 + 818 , 9 @ @ public abstract class Advapi32Util { <nl> 	 * @ param keyPath <nl> 	 * Path to an existing registry key . <nl> 	 * @ param name <nl> - 	 * Name . <nl> + 	 * Value name . <nl> 	 * @ param value <nl> - 	 * Value . <nl> + 	 * Value to write to registry . <nl> 	 * / <nl> 	 public static void registrySetStringValue ( HKEY root , String keyPath , String name , String value ) { <nl> 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; <nl> @ @ - 843 , 9 + 843 , 9 @ @ public abstract class Advapi32Util { <nl> 	 * @ param hKey <nl> 	 * Parent key . <nl> 	 * @ param name <nl> - 	 * Name . <nl> + 	 * Value name . <nl> 	 * @ param value <nl> - 	 * Value . <nl> + 	 * Value to write to registry . <nl> 	 * / <nl> 	 public static void registrySetExpandableStringValue ( HKEY hKey , String name , String value ) { <nl> 	 char [ ] data = Native . toCharArray ( value ) ; <nl> @ @ - 863 , 9 + 863 , 9 @ @ public abstract class Advapi32Util { <nl> 	 * @ param keyPath <nl> 	 * Path to an existing registry key . <nl> 	 * @ param name <nl> - 	 * Name . <nl> + 	 * Value name . <nl> 	 * @ param value <nl> - 	 * Value . <nl> + 	 * Value to write to registry . <nl> 	 * / <nl> 	 public static void registrySetExpandableStringValue ( HKEY root , String keyPath , String name , String value ) { <nl> 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; <nl> @ @ - 889 , 8 + 889 , 8 @ @ public abstract class Advapi32Util { <nl> 	 * Parent key . <nl> 	 * @ param name <nl> 	 * Name . <nl> - 	 * @ param value <nl> - 	 * Value . <nl> + 	 * @ param arr <nl> + 	 * Array of strings to write to registry . <nl> 	 * / <nl> 	 public static void registrySetStringArray ( HKEY hKey , String name , String [ ] arr ) { <nl> 	 	 int size = 0 ; <nl> @ @ - 922 , 18 + 922 , 18 @ @ public abstract class Advapi32Util { <nl> 	 * @ param keyPath <nl> 	 * Path to an existing registry key . <nl> 	 * @ param name <nl> - 	 * Name . <nl> - 	 * @ param value <nl> - 	 * Value . <nl> + 	 * Value name . <nl> + 	 * @ param arr <nl> + 	 * Array of strings to write to registry . <nl> 	 * / <nl> - 	 public static void registrySetStringArray ( HKEY root , String keyPath , String name , String [ ] value ) { <nl> + 	 public static void registrySetStringArray ( HKEY root , String keyPath , String name , String [ ] arr ) { <nl> 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; <nl> 	 	 int rc = Advapi32 . INSTANCE . RegOpenKeyEx ( root , keyPath , 0 , WinNT . KEY _ READ | WinNT . KEY _ WRITE , phkKey ) ; <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> 	 	 } <nl> 	 	 try { <nl> - 	 	 	 registrySetStringArray ( phkKey . getValue ( ) , name , value ) ; <nl> + 	 	 	 registrySetStringArray ( phkKey . getValue ( ) , name , arr ) ; <nl> 	 	 } finally { <nl> 	 	 	 rc = Advapi32 . INSTANCE . RegCloseKey ( phkKey . getValue ( ) ) ; <nl> 	 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { <nl> @ @ - 947 , 9 + 947 , 9 @ @ public abstract class Advapi32Util { <nl> 	 * @ param hKey <nl> 	 * Parent key . <nl> 	 * @ param name <nl> - 	 * Name . <nl> - 	 * @ param value <nl> - 	 * Value . <nl> + 	 * Value name . <nl> + 	 * @ param data <nl> + 	 * Data to write to registry . <nl> 	 * / <nl> 	 public static void registrySetBinaryValue ( HKEY hKey , String name , byte [ ] data ) { <nl> 	 	 int rc = Advapi32 . INSTANCE . RegSetValueEx ( hKey , name , 0 , WinNT . REG _ BINARY , data , data . length ) ; <nl> @ @ - 965 , 18 + 965 , 18 @ @ public abstract class Advapi32Util { <nl> 	 * @ param keyPath <nl> 	 * Path to an existing registry key . <nl> 	 * @ param name <nl> - 	 * Name . <nl> + 	 * Value name . <nl> 	 * @ param value <nl> - 	 * Value . <nl> + 	 * Data to write to registry . <nl> 	 * / <nl> - 	 public static void registrySetBinaryValue ( HKEY root , String keyPath , String name , byte [ ] value ) { <nl> + 	 public static void registrySetBinaryValue ( HKEY root , String keyPath , String name , byte [ ] data ) { <nl> 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; <nl> 	 	 int rc = Advapi32 . INSTANCE . RegOpenKeyEx ( root , keyPath , 0 , WinNT . KEY _ READ | WinNT . KEY _ WRITE , phkKey ) ; <nl> 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { <nl> 	 	 	 throw new Win32Exception ( rc ) ; <nl> 	 	 } <nl> 	 	 try { <nl> - 	 	 	 registrySetBinaryValue ( phkKey . getValue ( ) , name , value ) ; <nl> + 	 	 	 registrySetBinaryValue ( phkKey . getValue ( ) , name , data ) ; <nl> 	 	 } finally { <nl> 	 	 	 rc = Advapi32 . INSTANCE . RegCloseKey ( phkKey . getValue ( ) ) ; <nl> 	 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { <nl> diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / W32Service . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / W32Service . java <nl> index 83bc754 . . cebfb96 100644 <nl> - - - a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / W32Service . java <nl> + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / W32Service . java <nl> @ @ - 24 , 11 + 24 , 20 @ @ import com . sun . jna . ptr . IntByReference ; <nl> * / <nl> public class W32Service { <nl> 	 SC _ HANDLE _ serviceHandle = null ; <nl> - 	 <nl> + <nl> + 	 / * * <nl> + 	 * Win32 Service <nl> + 	 * @ param serviceHandle <nl> + 	 * A handle to the service . This handle is returned by the CreateService or OpenService <nl> + 	 * function , and it must have the SERVICE _ QUERY _ STATUS access right . <nl> + 	 * / <nl> 	 public W32Service ( SC _ HANDLE serviceHandle ) { <nl> 	 	 _ serviceHandle = serviceHandle ; <nl> 	 } <nl> 	 <nl> + 	 / * * <nl> + 	 * Close service . <nl> + 	 * / <nl> 	 public void close ( ) { <nl> 	 	 if ( _ serviceHandle ! = null ) { <nl> 	 	 	 if ( ! Advapi32 . INSTANCE . CloseServiceHandle ( _ serviceHandle ) ) { <nl> @ @ - 40 , 12 + 49 , 8 @ @ public class W32Service { <nl> 	 <nl> 	 / * * <nl> 	 * Retrieves the current status of the specified service based on the specified information level . <nl> - 	 * @ param serviceHandle <nl> - 	 * A handle to the service . <nl> - 	 * This handle is returned by the CreateService or OpenService function , and <nl> - 	 * it must have the SERVICE _ QUERY _ STATUS access right . <nl> - 	 * @ return Service status information <nl> - 	 * @ throws Win32Exception <nl> + 	 * @ return <nl> + 	 * Service status information <nl> 	 * / <nl> 	 public SERVICE _ STATUS _ PROCESS queryStatus ( ) { <nl> 	 	 IntByReference size = new IntByReference ( ) ; <nl> @ @ - 77 , 6 + 82 , 9 @ @ public class W32Service { <nl> 	 	 } <nl> 	 } <nl> 	 <nl> + 	 / * * <nl> + 	 * Stop service . <nl> + 	 * / <nl> 	 public void stopService ( ) { <nl> 	 	 waitForNonPendingState ( ) ; <nl> 	 	 / / If the service is already stopped - return <nl> @ @ - 92 , 7 + 100 , 10 @ @ public class W32Service { <nl> 	 	 	 throw new RuntimeException ( " Unable to stop the service " ) ; <nl> 	 	 } <nl> 	 } <nl> - 	 <nl> + <nl> + 	 / * * <nl> + 	 * Continue service . <nl> + 	 * / <nl> 	 public void continueService ( ) { <nl> 	 	 waitForNonPendingState ( ) ; <nl> 	 	 / / If the service is already stopped - return <nl> @ @ - 109 , 6 + 120 , 9 @ @ public class W32Service { <nl> 	 	 } <nl> 	 } <nl> 	 <nl> + 	 / * * <nl> + 	 * Pause service . <nl> + 	 * / <nl> 	 public void pauseService ( ) { <nl> 	 	 waitForNonPendingState ( ) ; <nl> 	 	 / / If the service is already paused - return <nl> @ @ - 126 , 7 + 140 , 7 @ @ public class W32Service { <nl> 	 } <nl> <nl> / * * <nl> - * This call waits for the state to change to something other than a pending state <nl> + * Wait for the state to change to something other than a pending state . <nl> * / <nl> 	 public void waitForNonPendingState ( ) { <nl> <nl> @ @ - 137 , 18 + 151 , 18 @ @ public class W32Service { <nl> <nl> 	 	 while ( isPendingState ( status . dwCurrentState ) ) { <nl> <nl> - 	 	 	 / / If the checkpoint advanced , start new tick count <nl> + 	 	 	 / / if the checkpoint advanced , start new tick count <nl> 	 	 	 if ( status . dwCheckPoint > previousCheckPoint ) { <nl> 	 	 	 	 previousCheckPoint = status . dwCheckPoint ; <nl> 	 	 	 	 checkpointStartTickCount = Kernel32 . INSTANCE . GetTickCount ( ) ; <nl> 	 	 	 } 	 	 	 <nl> <nl> - 	 	 	 / / If the time that passed is greater than the wait hint - throw timeout exception <nl> + 	 	 	 / / if the time that passed is greater than the wait hint - throw timeout exception <nl> 	 	 	 if ( Kernel32 . INSTANCE . GetTickCount ( ) - checkpointStartTickCount > status . dwWaitHint ) { <nl> 	 	 	 	 throw new RuntimeException ( " Timeout waiting for service to change to a non - pending state . " ) ; <nl> 	 	 	 } <nl> <nl> - 	 	 	 / / Do not wait longer than the wait hint . A good interval is <nl> + 	 	 	 / / do not wait longer than the wait hint . A good interval is <nl> 	 	 	 / / one - tenth the wait hint , but no less than 1 second and no <nl> 	 	 	 / / more than 10 seconds . <nl> <nl> @ @ - 165 , 7 + 179 , 6 @ @ public class W32Service { <nl> 	 	 	 	 throw new RuntimeException ( e ) ; <nl> 	 	 	 } <nl> <nl> - 	 	 	 / / Check the status again <nl> 	 	 	 status = queryStatus ( ) ; <nl> 	 	 } <nl> 	 }

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index a4dec9f . . 6af79b9 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 27 , 6 + 27 , 7 @ @ Bug Fixes 
 * [ # 887 ] ( https : / / github . com / java - native - access / jna / issues / 887 ) : MacFileUtils . moveToTrash ( ) doesn ' t work in a sandboxed app fix suggested by [ @ sobakasu ] ( https : / / github . com / sobakasu ) - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 * [ # 894 ] ( https : / / github . com / java - native - access / jna / issues / 894 ) : NullPointerException can be caused by calling ` com . sun . jna . platform . win32 . COM . util . ProxyObject # dispose ` multiple times - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 * [ # 925 ] ( https : / / github . com / java - native - access / jna / issues / 925 ) : Optimize ` Structure # validate ` and prevent ` ArrayIndexOutOfBoundsException ` in ` SAFEARRAY # read ` for zero dimensions - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 + * [ # 340 ] ( https : / / github . com / java - native - access / jna / issues / 340 ) : Guard registry handling against out - of - bounds reads by ensuring all read strings are NULL terminated - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 
 Breaking Changes 
 - - - - - - - - - - - - - - - - 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 index 9462087 . . f9905a8 100755 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 @ @ - 976 , 11 + 976 , 20 @ @ public interface Advapi32 extends StdCallLibrary { 
 * defined in Winerror . h . 
 * / 
 int RegSetValueEx ( HKEY hKey , String lpValueName , int Reserved , 
 + int dwType , Pointer lpData , int cbData ) ; 
 + 
 + / * * 
 + * See { @ link # RegSetValueEx ( com . sun . jna . platform . win32 . WinReg . HKEY , java . lang . String , int , int , com . sun . jna . Pointer , int ) } 
 + * / 
 + int RegSetValueEx ( HKEY hKey , String lpValueName , int Reserved , 
 int dwType , char [ ] lpData , int cbData ) ; 
 
 + / * * 
 + * See { @ link # RegSetValueEx ( com . sun . jna . platform . win32 . WinReg . HKEY , java . lang . String , int , int , com . sun . jna . Pointer , int ) } 
 + * / 
 int RegSetValueEx ( HKEY hKey , String lpValueName , int Reserved , 
 int dwType , byte [ ] lpData , int cbData ) ; 
 - 
 + 
 / * * 
 * 
 * @ param hKey registry key 
 @ @ - 1103 , 6 + 1112 , 13 @ @ public interface Advapi32 extends StdCallLibrary { 
 * / 
 int RegEnumValue ( HKEY hKey , int dwIndex , char [ ] lpValueName , 
 IntByReference lpcchValueName , IntByReference reserved , 
 + IntByReference lpType , Pointer lpData , IntByReference lpcbData ) ; 
 + 
 + / * * 
 + * See { @ link # RegEnumValue ( com . sun . jna . platform . win32 . WinReg . HKEY , int , char [ ] , com . sun . jna . ptr . IntByReference , com . sun . jna . ptr . IntByReference , com . sun . jna . ptr . IntByReference , com . sun . jna . Pointer , com . sun . jna . ptr . IntByReference ) } . 
 + * / 
 + int RegEnumValue ( HKEY hKey , int dwIndex , char [ ] lpValueName , 
 + IntByReference lpcchValueName , IntByReference reserved , 
 IntByReference lpType , byte [ ] lpData , IntByReference lpcbData ) ; 
 
 / * * 
 @ @ - 1295 , 9 + 1311 , 16 @ @ public interface Advapi32 extends StdCallLibrary { 
 * @ return status 
 * / 
 int RegGetValue ( HKEY hkey , String lpSubKey , String lpValue , 
 + int dwFlags , IntByReference pdwType , Pointer pvData , 
 + IntByReference pcbData ) ; 
 + 
 + / * * 
 + * See { @ link # RegGetValue ( com . sun . jna . platform . win32 . WinReg . HKEY , java . lang . String , java . lang . String , int , com . sun . jna . ptr . IntByReference , com . sun . jna . Pointer , com . sun . jna . ptr . IntByReference ) } . 
 + * / 
 + int RegGetValue ( HKEY hkey , String lpSubKey , String lpValue , 
 int dwFlags , IntByReference pdwType , byte [ ] pvData , 
 IntByReference pcbData ) ; 
 - 
 + 
 / * * 
 * Retrieves a registered handle to the specified event log . 
 * 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 index 4640757 . . afa5985 100755 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 @ @ - 90 , 7 + 90 , 7 @ @ import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 import com . sun . jna . ptr . IntByReference ; 
 import com . sun . jna . ptr . LongByReference ; 
 import com . sun . jna . ptr . PointerByReference ; 
 - 
 + import com . sun . jna . win32 . W32APITypeMapper ; 
 
 / * * 
 * Advapi32 utility API . 
 @ @ - 607 , 7 + 607 , 7 @ @ public abstract class Advapi32Util { 
 	 	 	 IntByReference lpcbData = new IntByReference ( ) ; 
 	 	 	 IntByReference lpType = new IntByReference ( ) ; 
 	 	 	 rc = Advapi32 . INSTANCE . RegQueryValueEx ( phkKey . getValue ( ) , value , 0 , 
 - 	 	 	 	 	 lpType , ( char [ ] ) null , lpcbData ) ; 
 + 	 	 	 	 	 lpType , ( Pointer ) null , lpcbData ) ; 
 	 	 	 switch ( rc ) { 
 	 	 	 case W32Errors . ERROR _ SUCCESS : 
 	 	 	 case W32Errors . ERROR _ MORE _ DATA : 
 @ @ - 670 , 7 + 670 , 7 @ @ public abstract class Advapi32Util { 
 	 	 IntByReference lpcbData = new IntByReference ( ) ; 
 	 	 IntByReference lpType = new IntByReference ( ) ; 
 	 	 int rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , 
 - 	 	 	 	 lpType , ( char [ ] ) null , lpcbData ) ; 
 + 	 	 	 	 lpType , ( Pointer ) null , lpcbData ) ; 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS 
 	 	 	 	 & & rc ! = W32Errors . ERROR _ INSUFFICIENT _ BUFFER ) { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 @ @ - 681 , 14 + 681 , 23 @ @ public abstract class Advapi32Util { 
 	 	 	 	 	 + lpType . getValue ( ) 
 	 	 	 	 	 + " , expected REG _ SZ or REG _ EXPAND _ SZ " ) ; 
 	 	 } 
 - 	 	 char [ ] data = new char [ lpcbData . getValue ( ) ] ; 
 + if ( lpcbData . getValue ( ) = = 0 ) { 
 + return " " ; 
 + } 
 + / / See comment in # registryGetValue 
 + Memory mem = new Memory ( lpcbData . getValue ( ) + Native . WCHAR _ SIZE ) ; 
 + mem . clear ( ) ; 
 	 	 rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , 
 - 	 	 	 	 lpType , data , lpcbData ) ; 
 + 	 	 	 	 lpType , mem , lpcbData ) ; 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS 
 	 	 	 	 & & rc ! = W32Errors . ERROR _ INSUFFICIENT _ BUFFER ) { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 	 	 } 
 - 	 	 return Native . toString ( data ) ; 
 + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { 
 + return mem . getWideString ( 0 ) ; 
 + } else { 
 + return mem . getString ( 0 ) ; 
 + } 
 	 } 
 
 	 / * * 
 @ @ - 742 , 14 + 751 , 23 @ @ public abstract class Advapi32Util { 
 	 	 	 throw new RuntimeException ( " Unexpected registry type " 
 	 	 	 	 	 + lpType . getValue ( ) + " , expected REG _ SZ " ) ; 
 	 	 } 
 - 	 	 char [ ] data = new char [ lpcbData . getValue ( ) ] ; 
 + if ( lpcbData . getValue ( ) = = 0 ) { 
 + return " " ; 
 + } 
 + / / See comment in # registryGetValue 
 + Memory mem = new Memory ( lpcbData . getValue ( ) + Native . WCHAR _ SIZE ) ; 
 + mem . clear ( ) ; 
 	 	 rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , 
 - 	 	 	 	 lpType , data , lpcbData ) ; 
 + 	 	 	 	 lpType , mem , lpcbData ) ; 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS 
 	 	 	 	 & & rc ! = W32Errors . ERROR _ INSUFFICIENT _ BUFFER ) { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 	 	 } 
 - 	 	 return Native . toString ( data ) ; 
 + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { 
 + return mem . getWideString ( 0 ) ; 
 + } else { 
 + return mem . getString ( 0 ) ; 
 + } 
 	 } 
 
 	 / * * 
 @ @ - 803 , 7 + 821 , 10 @ @ public abstract class Advapi32Util { 
 	 	 	 throw new RuntimeException ( " Unexpected registry type " 
 	 	 	 	 	 + lpType . getValue ( ) + " , expected REG _ SZ " ) ; 
 	 	 } 
 - 	 	 Memory data = new Memory ( lpcbData . getValue ( ) ) ; 
 + / / Allocate enougth memroy to hold value and ensure terminating 
 + / / double NULL chars are present 
 + 	 	 Memory data = new Memory ( lpcbData . getValue ( ) + 2 * Native . WCHAR _ SIZE ) ; 
 + data . clear ( ) ; 
 	 	 rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , 
 	 	 	 	 lpType , data , lpcbData ) ; 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS 
 @ @ - 813 , 16 + 834 , 27 @ @ public abstract class Advapi32Util { 
 	 	 ArrayList < String > result = new ArrayList < String > ( ) ; 
 	 	 int offset = 0 ; 
 	 	 while ( offset < data . size ( ) ) { 
 - 	 	 	 String s = data . getWideString ( offset ) ; 
 - 	 	 	 offset + = s . length ( ) * Native . WCHAR _ SIZE ; 
 - 	 	 	 offset + = Native . WCHAR _ SIZE ; 
 - 	 	 	 if ( s . length ( ) = = 0 & & offset = = data . size ( ) ) { 
 - 	 	 	 	 / / skip the final NULL 
 + 	 	 	 String s ; 
 + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { 
 + s = data . getWideString ( offset ) ; 
 + offset + = s . length ( ) * Native . WCHAR _ SIZE ; 
 + offset + = Native . WCHAR _ SIZE ; 
 + } else { 
 + s = data . getString ( offset ) ; 
 + offset + = s . length ( ) ; 
 + offset + = 1 ; 
 + } 
 + 
 + 	 	 	 if ( s . length ( ) = = 0 ) { 
 + / / A sequence of null - terminated strings , 
 + / / terminated by an empty string ( \ 0 ) . 
 + / / = > The first empty string terminates the 
 + 	 	 	 	 break ; 
 	 	 	 } else { 
 	 	 	 	 result . add ( s ) ; 
 	 	 	 } 
 	 	 } 
 - 	 	 return result . toArray ( new String [ 0 ] ) ; 
 + 	 	 return result . toArray ( new String [ result . size ( ) ] ) ; 
 	 } 
 
 	 / * * 
 @ @ - 867 , 7 + 899 , 7 @ @ public abstract class Advapi32Util { 
 	 	 IntByReference lpcbData = new IntByReference ( ) ; 
 	 	 IntByReference lpType = new IntByReference ( ) ; 
 	 	 int rc = Advapi32 . INSTANCE . RegQueryValueEx ( hKey , value , 0 , 
 - 	 	 	 	 lpType , ( char [ ] ) null , lpcbData ) ; 
 + 	 	 	 	 lpType , ( Pointer ) null , lpcbData ) ; 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS 
 	 	 	 	 & & rc ! = W32Errors . ERROR _ INSUFFICIENT _ BUFFER ) { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 @ @ - 1022 , 11 + 1054 , 10 @ @ public abstract class Advapi32Util { 
 	 	 	 String lpValueName ) { 
 	 	 Object result = null ; 
 	 	 IntByReference lpType = new IntByReference ( ) ; 
 - 	 	 byte [ ] lpData = new byte [ Advapi32 . MAX _ VALUE _ NAME ] ; 
 - 	 	 IntByReference lpcbData = new IntByReference ( Advapi32 . MAX _ VALUE _ NAME ) ; 
 + 	 	 IntByReference lpcbData = new IntByReference ( ) ; 
 
 	 	 int rc = Advapi32 . INSTANCE . RegGetValue ( hkKey , subKey , lpValueName , 
 - 	 	 	 	 Advapi32 . RRF _ RT _ ANY , lpType , lpData , lpcbData ) ; 
 + 	 	 	 	 Advapi32 . RRF _ RT _ ANY , lpType , ( Pointer ) null , lpcbData ) ; 
 
 	 	 / / if lpType = = 0 then the value is empty ( REG _ NONE ) ! 
 	 	 if ( lpType . getValue ( ) = = WinNT . REG _ NONE ) 
 @ @ - 1037 , 18 + 1068 , 33 @ @ public abstract class Advapi32Util { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 	 	 } 
 
 - 	 	 Memory byteData = new Memory ( lpcbData . getValue ( ) ) ; 
 - 	 	 byteData . write ( 0 , lpData , 0 , lpcbData . getValue ( ) ) ; 
 - 
 + / / Buffer is intentionally allocated larger than 
 + / / indicated , as function adds terminating NULL char , if it is 
 + / / missing . WCHAR _ SIZE is added , as returning string can be 
 + / / char [ ] or wchar [ ] depending on w32 . ascii 
 + 	 	 Memory byteData = new Memory ( lpcbData . getValue ( ) + Native . WCHAR _ SIZE ) ; 
 + byteData . clear ( ) ; 
 + 
 + 	 	 rc = Advapi32 . INSTANCE . RegGetValue ( hkKey , subKey , lpValueName , 
 + 	 	 	 	 Advapi32 . RRF _ RT _ ANY , lpType , byteData , lpcbData ) ; 
 + 
 + if ( rc ! = W32Errors . ERROR _ SUCCESS ) { 
 + throw new Win32Exception ( rc ) ; 
 + } 
 + 
 	 	 if ( lpType . getValue ( ) = = WinNT . REG _ DWORD ) { 
 - 	 	 	 result = Integer . valueOf ( byteData . getInt ( 0 ) ) ; 
 + 	 	 	 result = byteData . getInt ( 0 ) ; 
 	 	 } else if ( lpType . getValue ( ) = = WinNT . REG _ QWORD ) { 
 - 	 	 	 result = Long . valueOf ( byteData . getLong ( 0 ) ) ; 
 + 	 	 	 result = byteData . getLong ( 0 ) ; 
 	 	 } else if ( lpType . getValue ( ) = = WinNT . REG _ BINARY ) { 
 	 	 	 result = byteData . getByteArray ( 0 , lpcbData . getValue ( ) ) ; 
 	 	 } else if ( ( lpType . getValue ( ) = = WinNT . REG _ SZ ) 
 	 	 	 	 | | ( lpType . getValue ( ) = = WinNT . REG _ EXPAND _ SZ ) ) { 
 - 	 	 	 result = byteData . getWideString ( 0 ) ; 
 + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { 
 + result = byteData . getWideString ( 0 ) ; 
 + } else { 
 + result = byteData . getString ( 0 ) ; 
 + } 
 	 	 } 
 
 	 	 return result ; 
 @ @ - 1230 , 9 + 1276 , 19 @ @ public abstract class Advapi32Util { 
 	 * / 
 	 public static void registrySetStringValue ( HKEY hKey , String name , 
 	 	 	 String value ) { 
 - 	 	 char [ ] data = Native . toCharArray ( value ) ; 
 + if ( value = = null ) { 
 + value = " " ; 
 + } 
 + Memory data ; 
 + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { 
 + data = new Memory ( ( value . length ( ) + 1 ) * Native . WCHAR _ SIZE ) ; 
 + data . setWideString ( 0 , value ) ; 
 + } else { 
 + data = new Memory ( ( value . length ( ) + 1 ) ) ; 
 + data . setString ( 0 , value ) ; 
 + } 
 	 	 int rc = Advapi32 . INSTANCE . RegSetValueEx ( hKey , name , 0 , WinNT . REG _ SZ , 
 - 	 	 	 	 data , data . length * Native . WCHAR _ SIZE ) ; 
 + 	 	 	 	 data , ( int ) data . size ( ) ) ; 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 	 	 } 
 @ @ - 1280 , 9 + 1336 , 16 @ @ public abstract class Advapi32Util { 
 	 * / 
 	 public static void registrySetExpandableStringValue ( HKEY hKey , String name , 
 	 	 	 String value ) { 
 - 	 	 char [ ] data = Native . toCharArray ( value ) ; 
 + Memory data ; 
 + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { 
 + data = new Memory ( ( value . length ( ) + 1 ) * Native . WCHAR _ SIZE ) ; 
 + data . setWideString ( 0 , value ) ; 
 + } else { 
 + data = new Memory ( ( value . length ( ) + 1 ) ) ; 
 + data . setString ( 0 , value ) ; 
 + } 
 	 	 int rc = Advapi32 . INSTANCE . RegSetValueEx ( hKey , name , 0 , 
 - 	 	 	 	 WinNT . REG _ EXPAND _ SZ , data , data . length * Native . WCHAR _ SIZE ) ; 
 + 	 	 	 	 WinNT . REG _ EXPAND _ SZ , data , ( int ) data . size ( ) ) ; 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 	 	 } 
 @ @ - 1330 , 26 + 1393 , 31 @ @ public abstract class Advapi32Util { 
 	 * / 
 	 public static void registrySetStringArray ( HKEY hKey , String name , 
 	 	 	 String [ ] arr ) { 
 + 
 + int charwidth = W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ? Native . WCHAR _ SIZE : 1 ; 
 + 
 	 	 int size = 0 ; 
 	 	 for ( String s : arr ) { 
 - 	 	 	 size + = s . length ( ) * Native . WCHAR _ SIZE ; 
 - 	 	 	 size + = Native . WCHAR _ SIZE ; 
 + 	 	 	 size + = s . length ( ) * charwidth ; 
 + 	 	 	 size + = charwidth ; 
 	 	 } 
 - 	 	 size + = Native . WCHAR _ SIZE ; 
 + 	 	 size + = charwidth ; 
 
 	 	 int offset = 0 ; 
 	 	 Memory data = new Memory ( size ) ; 
 + data . clear ( ) ; 
 	 	 for ( String s : arr ) { 
 - 	 	 	 data . setWideString ( offset , s ) ; 
 - 	 	 	 offset + = s . length ( ) * Native . WCHAR _ SIZE ; 
 - 	 	 	 offset + = Native . WCHAR _ SIZE ; 
 - 	 	 } 
 - 	 	 for ( int i = 0 ; i < Native . WCHAR _ SIZE ; i + + ) { 
 - 	 	 	 data . setByte ( offset + + , ( byte ) 0 ) ; 
 + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { 
 + data . setWideString ( offset , s ) ; 
 + } else { 
 + data . setString ( offset , s ) ; 
 + } 
 + 	 	 	 offset + = s . length ( ) * charwidth ; 
 + 	 	 	 offset + = charwidth ; 
 	 	 } 
 
 	 	 int rc = Advapi32 . INSTANCE . RegSetValueEx ( hKey , name , 0 , 
 - 	 	 	 	 WinNT . REG _ MULTI _ SZ , data . getByteArray ( 0 , size ) , size ) ; 
 + 	 	 	 	 WinNT . REG _ MULTI _ SZ , data , size ) ; 
 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 @ @ - 1635 , 15 + 1703 , 19 @ @ public abstract class Advapi32Util { 
 	 	 } 
 	 	 TreeMap < String , Object > keyValues = new TreeMap < String , Object > ( ) ; 
 	 	 char [ ] name = new char [ lpcMaxValueNameLen . getValue ( ) + 1 ] ; 
 - 	 	 byte [ ] data = new byte [ lpcMaxValueLen . getValue ( ) ] ; 
 + / / Allocate enough memory to hold largest value and two 
 + / / terminating WCHARs - - the memory is zeroed so after 
 + / / value request we should not overread when reading strings 
 + 	 	 Memory byteData = new Memory ( lpcMaxValueLen . getValue ( ) + 2 * Native . WCHAR _ SIZE ) ; 
 	 	 for ( int i = 0 ; i < lpcValues . getValue ( ) ; i + + ) { 
 + byteData . clear ( ) ; 
 	 	 	 IntByReference lpcchValueName = new IntByReference ( 
 	 	 	 	 	 lpcMaxValueNameLen . getValue ( ) + 1 ) ; 
 	 	 	 IntByReference lpcbData = new IntByReference ( 
 	 	 	 	 	 lpcMaxValueLen . getValue ( ) ) ; 
 	 	 	 IntByReference lpType = new IntByReference ( ) ; 
 	 	 	 rc = Advapi32 . INSTANCE . RegEnumValue ( hKey , i , name , lpcchValueName , 
 - 	 	 	 	 	 null , lpType , data , lpcbData ) ; 
 + 	 	 	 	 	 null , lpType , byteData , lpcbData ) ; 
 	 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { 
 	 	 	 	 throw new Win32Exception ( rc ) ; 
 	 	 	 } 
 @ @ - 1676 , 9 + 1748 , 6 @ @ public abstract class Advapi32Util { 
 	 	 	 	 continue ; 
 	 	 	 } 
 
 - 	 	 	 Memory byteData = new Memory ( lpcbData . getValue ( ) ) ; 
 - 	 	 	 byteData . write ( 0 , data , 0 , lpcbData . getValue ( ) ) ; 
 - 
 	 	 	 switch ( lpType . getValue ( ) ) { 
 	 	 	 case WinNT . REG _ QWORD : { 
 	 	 	 	 keyValues . put ( nameString , byteData . getLong ( 0 ) ) ; 
 @ @ - 1690 , 7 + 1759 , 11 @ @ public abstract class Advapi32Util { 
 	 	 	 } 
 	 	 	 case WinNT . REG _ SZ : 
 	 	 	 case WinNT . REG _ EXPAND _ SZ : { 
 - 	 	 	 	 keyValues . put ( nameString , byteData . getWideString ( 0 ) ) ; 
 + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { 
 + keyValues . put ( nameString , byteData . getWideString ( 0 ) ) ; 
 + } else { 
 + keyValues . put ( nameString , byteData . getString ( 0 ) ) ; 
 + } 
 	 	 	 	 break ; 
 	 	 	 } 
 	 	 	 case WinNT . REG _ BINARY : { 
 @ @ - 1699 , 20 + 1772 , 29 @ @ public abstract class Advapi32Util { 
 	 	 	 	 break ; 
 	 	 	 } 
 	 	 	 case WinNT . REG _ MULTI _ SZ : { 
 - 	 	 	 	 Memory stringData = new Memory ( lpcbData . getValue ( ) ) ; 
 - 	 	 	 	 stringData . write ( 0 , data , 0 , lpcbData . getValue ( ) ) ; 
 - 	 	 	 	 ArrayList < String > result = new ArrayList < String > ( ) ; 
 - 	 	 	 	 int offset = 0 ; 
 - 	 	 	 	 while ( offset < stringData . size ( ) ) { 
 - 	 	 	 	 	 String s = stringData . getWideString ( offset ) ; 
 - 	 	 	 	 	 offset + = s . length ( ) * Native . WCHAR _ SIZE ; 
 - 	 	 	 	 	 offset + = Native . WCHAR _ SIZE ; 
 - 	 	 	 	 	 if ( s . length ( ) = = 0 & & offset = = stringData . size ( ) ) { 
 - 	 	 	 	 	 	 / / skip the final NULL 
 - 	 	 	 	 	 } else { 
 - 	 	 	 	 	 	 result . add ( s ) ; 
 - 	 	 	 	 	 } 
 - 	 	 	 	 } 
 + ArrayList < String > result = new ArrayList < String > ( ) ; 
 + int offset = 0 ; 
 + while ( offset < byteData . size ( ) ) { 
 + String s ; 
 + if ( W32APITypeMapper . DEFAULT = = W32APITypeMapper . UNICODE ) { 
 + s = byteData . getWideString ( offset ) ; 
 + offset + = s . length ( ) * Native . WCHAR _ SIZE ; 
 + offset + = Native . WCHAR _ SIZE ; 
 + } else { 
 + s = byteData . getString ( offset ) ; 
 + offset + = s . length ( ) ; 
 + offset + = 1 ; 
 + } 
 + 
 + if ( s . length ( ) = = 0 ) { 
 + / / A sequence of null - terminated strings , 
 + / / terminated by an empty string ( \ 0 ) . 
 + / / = > The first empty string terminates the 
 + break ; 
 + } else { 
 + result . add ( s ) ; 
 + } 
 + } 
 	 	 	 	 keyValues . put ( nameString , result . toArray ( new String [ 0 ] ) ) ; 
 	 	 	 	 break ; 
 	 	 	 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 index 4a42285 . . bc37ecd 100755 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 @ @ - 100 , 10 + 100 , 11 @ @ public class Advapi32Test extends TestCase { 
 Collection < String > dupSet = AbstractWin32TestSupport . detectDuplicateMethods ( Advapi32 . class ) ; 
 if ( dupSet . size ( ) > 0 ) { 
 for ( String name : new String [ ] { 
 - / / has several overloads by design since the output value can be several types of data 
 + / / these have several overloads by design since the input / output values can be several types of data 
 " RegQueryValueEx " , 
 - / / has several overloads by design since the input value can be several types of data 
 - " RegSetValueEx " 
 + " RegSetValueEx " , 
 + " RegGetValue " , 
 + " RegEnumValue " 
 } ) { 
 dupSet . remove ( name ) ; 
 } 
 @ @ - 640 , 7 + 641 , 7 @ @ public class Advapi32Test extends TestCase { 
 	 	 IntByReference lpType = new IntByReference ( ) ; 
 	 assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . RegEnumValue ( 
 	 	 	 phKey . getValue ( ) , i , name , lpcchValueName , null , 
 - 	 	 	 lpType , null , null ) ) ; 
 + 	 	 	 lpType , ( Pointer ) null , null ) ) ; 
 	 assertEquals ( Native . toString ( name ) . length ( ) , lpcchValueName . getValue ( ) ) ; 
 	 } 
 	 assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . RegCloseKey ( phKey . getValue ( ) ) ) ;

NEAREST DIFF:
diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 index 978578b . . 8766039 100644 
 - - - a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 @ @ - 750 , 9 + 750 , 9 @ @ public abstract class Advapi32Util { 
 	 * @ param hKey 
 	 * Parent key . 
 	 * @ param name 
 - 	 * Name . 
 + 	 * Value name . 
 	 * @ param value 
 - 	 * Value . 
 + 	 * Value to write to registry . 
 	 * / 
 	 public static void registrySetIntValue ( HKEY hKey , String name , int value ) { 
 byte [ ] data = new byte [ 4 ] ; 
 @ @ - 773 , 9 + 773 , 9 @ @ public abstract class Advapi32Util { 
 	 * @ param keyPath 
 	 * Path to an existing registry key . 
 	 * @ param name 
 - 	 * Name . 
 + 	 * Value name . 
 	 * @ param value 
 - 	 * Value . 
 + 	 * Value to write to registry . 
 	 * / 
 	 public static void registrySetIntValue ( HKEY root , String keyPath , String name , int value ) { 
 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; 
 @ @ - 798 , 9 + 798 , 9 @ @ public abstract class Advapi32Util { 
 	 * @ param hKey 
 	 * Parent key . 
 	 * @ param name 
 - 	 * Name . 
 + 	 * Value name . 
 	 * @ param value 
 - 	 * Value . 
 + 	 * Value to write to registry . 
 	 * / 
 	 public static void registrySetStringValue ( HKEY hKey , String name , String value ) { 
 	 char [ ] data = Native . toCharArray ( value ) ; 
 @ @ - 818 , 9 + 818 , 9 @ @ public abstract class Advapi32Util { 
 	 * @ param keyPath 
 	 * Path to an existing registry key . 
 	 * @ param name 
 - 	 * Name . 
 + 	 * Value name . 
 	 * @ param value 
 - 	 * Value . 
 + 	 * Value to write to registry . 
 	 * / 
 	 public static void registrySetStringValue ( HKEY root , String keyPath , String name , String value ) { 
 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; 
 @ @ - 843 , 9 + 843 , 9 @ @ public abstract class Advapi32Util { 
 	 * @ param hKey 
 	 * Parent key . 
 	 * @ param name 
 - 	 * Name . 
 + 	 * Value name . 
 	 * @ param value 
 - 	 * Value . 
 + 	 * Value to write to registry . 
 	 * / 
 	 public static void registrySetExpandableStringValue ( HKEY hKey , String name , String value ) { 
 	 char [ ] data = Native . toCharArray ( value ) ; 
 @ @ - 863 , 9 + 863 , 9 @ @ public abstract class Advapi32Util { 
 	 * @ param keyPath 
 	 * Path to an existing registry key . 
 	 * @ param name 
 - 	 * Name . 
 + 	 * Value name . 
 	 * @ param value 
 - 	 * Value . 
 + 	 * Value to write to registry . 
 	 * / 
 	 public static void registrySetExpandableStringValue ( HKEY root , String keyPath , String name , String value ) { 
 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; 
 @ @ - 889 , 8 + 889 , 8 @ @ public abstract class Advapi32Util { 
 	 * Parent key . 
 	 * @ param name 
 	 * Name . 
 - 	 * @ param value 
 - 	 * Value . 
 + 	 * @ param arr 
 + 	 * Array of strings to write to registry . 
 	 * / 
 	 public static void registrySetStringArray ( HKEY hKey , String name , String [ ] arr ) { 
 	 	 int size = 0 ; 
 @ @ - 922 , 18 + 922 , 18 @ @ public abstract class Advapi32Util { 
 	 * @ param keyPath 
 	 * Path to an existing registry key . 
 	 * @ param name 
 - 	 * Name . 
 - 	 * @ param value 
 - 	 * Value . 
 + 	 * Value name . 
 + 	 * @ param arr 
 + 	 * Array of strings to write to registry . 
 	 * / 
 - 	 public static void registrySetStringArray ( HKEY root , String keyPath , String name , String [ ] value ) { 
 + 	 public static void registrySetStringArray ( HKEY root , String keyPath , String name , String [ ] arr ) { 
 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; 
 	 	 int rc = Advapi32 . INSTANCE . RegOpenKeyEx ( root , keyPath , 0 , WinNT . KEY _ READ | WinNT . KEY _ WRITE , phkKey ) ; 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 	 	 } 
 	 	 try { 
 - 	 	 	 registrySetStringArray ( phkKey . getValue ( ) , name , value ) ; 
 + 	 	 	 registrySetStringArray ( phkKey . getValue ( ) , name , arr ) ; 
 	 	 } finally { 
 	 	 	 rc = Advapi32 . INSTANCE . RegCloseKey ( phkKey . getValue ( ) ) ; 
 	 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { 
 @ @ - 947 , 9 + 947 , 9 @ @ public abstract class Advapi32Util { 
 	 * @ param hKey 
 	 * Parent key . 
 	 * @ param name 
 - 	 * Name . 
 - 	 * @ param value 
 - 	 * Value . 
 + 	 * Value name . 
 + 	 * @ param data 
 + 	 * Data to write to registry . 
 	 * / 
 	 public static void registrySetBinaryValue ( HKEY hKey , String name , byte [ ] data ) { 
 	 	 int rc = Advapi32 . INSTANCE . RegSetValueEx ( hKey , name , 0 , WinNT . REG _ BINARY , data , data . length ) ; 
 @ @ - 965 , 18 + 965 , 18 @ @ public abstract class Advapi32Util { 
 	 * @ param keyPath 
 	 * Path to an existing registry key . 
 	 * @ param name 
 - 	 * Name . 
 + 	 * Value name . 
 	 * @ param value 
 - 	 * Value . 
 + 	 * Data to write to registry . 
 	 * / 
 - 	 public static void registrySetBinaryValue ( HKEY root , String keyPath , String name , byte [ ] value ) { 
 + 	 public static void registrySetBinaryValue ( HKEY root , String keyPath , String name , byte [ ] data ) { 
 	 	 HKEYByReference phkKey = new HKEYByReference ( ) ; 
 	 	 int rc = Advapi32 . INSTANCE . RegOpenKeyEx ( root , keyPath , 0 , WinNT . KEY _ READ | WinNT . KEY _ WRITE , phkKey ) ; 
 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { 
 	 	 	 throw new Win32Exception ( rc ) ; 
 	 	 } 
 	 	 try { 
 - 	 	 	 registrySetBinaryValue ( phkKey . getValue ( ) , name , value ) ; 
 + 	 	 	 registrySetBinaryValue ( phkKey . getValue ( ) , name , data ) ; 
 	 	 } finally { 
 	 	 	 rc = Advapi32 . INSTANCE . RegCloseKey ( phkKey . getValue ( ) ) ; 
 	 	 	 if ( rc ! = W32Errors . ERROR _ SUCCESS ) { 
 diff - - git a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / W32Service . java b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / W32Service . java 
 index 83bc754 . . cebfb96 100644 
 - - - a / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / W32Service . java 
 + + + b / jnalib / contrib / platform / src / com / sun / jna / platform / win32 / W32Service . java 
 @ @ - 24 , 11 + 24 , 20 @ @ import com . sun . jna . ptr . IntByReference ; 
 * / 
 public class W32Service { 
 	 SC _ HANDLE _ serviceHandle = null ; 
 - 	 
 + 
 + 	 / * * 
 + 	 * Win32 Service 
 + 	 * @ param serviceHandle 
 + 	 * A handle to the service . This handle is returned by the CreateService or OpenService 
 + 	 * function , and it must have the SERVICE _ QUERY _ STATUS access right . 
 + 	 * / 
 	 public W32Service ( SC _ HANDLE serviceHandle ) { 
 	 	 _ serviceHandle = serviceHandle ; 
 	 } 
 	 
 + 	 / * * 
 + 	 * Close service . 
 + 	 * / 
 	 public void close ( ) { 
 	 	 if ( _ serviceHandle ! = null ) { 
 	 	 	 if ( ! Advapi32 . INSTANCE . CloseServiceHandle ( _ serviceHandle ) ) { 
 @ @ - 40 , 12 + 49 , 8 @ @ public class W32Service { 
 	 
 	 / * * 
 	 * Retrieves the current status of the specified service based on the specified information level . 
 - 	 * @ param serviceHandle 
 - 	 * A handle to the service . 
 - 	 * This handle is returned by the CreateService or OpenService function , and 
 - 	 * it must have the SERVICE _ QUERY _ STATUS access right . 
 - 	 * @ return Service status information 
 - 	 * @ throws Win32Exception 
 + 	 * @ return 
 + 	 * Service status information 
 	 * / 
 	 public SERVICE _ STATUS _ PROCESS queryStatus ( ) { 
 	 	 IntByReference size = new IntByReference ( ) ; 
 @ @ - 77 , 6 + 82 , 9 @ @ public class W32Service { 
 	 	 } 
 	 } 
 	 
 + 	 / * * 
 + 	 * Stop service . 
 + 	 * / 
 	 public void stopService ( ) { 
 	 	 waitForNonPendingState ( ) ; 
 	 	 / / If the service is already stopped - return 
 @ @ - 92 , 7 + 100 , 10 @ @ public class W32Service { 
 	 	 	 throw new RuntimeException ( " Unable to stop the service " ) ; 
 	 	 } 
 	 } 
 - 	 
 + 
 + 	 / * * 
 + 	 * Continue service . 
 + 	 * / 
 	 public void continueService ( ) { 
 	 	 waitForNonPendingState ( ) ; 
 	 	 / / If the service is already stopped - return 
 @ @ - 109 , 6 + 120 , 9 @ @ public class W32Service { 
 	 	 } 
 	 } 
 	 
 + 	 / * * 
 + 	 * Pause service . 
 + 	 * / 
 	 public void pauseService ( ) { 
 	 	 waitForNonPendingState ( ) ; 
 	 	 / / If the service is already paused - return 
 @ @ - 126 , 7 + 140 , 7 @ @ public class W32Service { 
 	 } 
 
 / * * 
 - * This call waits for the state to change to something other than a pending state 
 + * Wait for the state to change to something other than a pending state . 
 * / 
 	 public void waitForNonPendingState ( ) { 
 
 @ @ - 137 , 18 + 151 , 18 @ @ public class W32Service { 
 
 	 	 while ( isPendingState ( status . dwCurrentState ) ) { 
 
 - 	 	 	 / / If the checkpoint advanced , start new tick count 
 + 	 	 	 / / if the checkpoint advanced , start new tick count 
 	 	 	 if ( status . dwCheckPoint > previousCheckPoint ) { 
 	 	 	 	 previousCheckPoint = status . dwCheckPoint ; 
 	 	 	 	 checkpointStartTickCount = Kernel32 . INSTANCE . GetTickCount ( ) ; 
 	 	 	 } 	 	 	 
 
 - 	 	 	 / / If the time that passed is greater than the wait hint - throw timeout exception 
 + 	 	 	 / / if the time that passed is greater than the wait hint - throw timeout exception 
 	 	 	 if ( Kernel32 . INSTANCE . GetTickCount ( ) - checkpointStartTickCount > status . dwWaitHint ) { 
 	 	 	 	 throw new RuntimeException ( " Timeout waiting for service to change to a non - pending state . " ) ; 
 	 	 	 } 
 
 - 	 	 	 / / Do not wait longer than the wait hint . A good interval is 
 + 	 	 	 / / do not wait longer than the wait hint . A good interval is 
 	 	 	 / / one - tenth the wait hint , but no less than 1 second and no 
 	 	 	 / / more than 10 seconds . 
 
 @ @ - 165 , 7 + 179 , 6 @ @ public class W32Service { 
 	 	 	 	 throw new RuntimeException ( e ) ; 
 	 	 	 } 
 
 - 	 	 	 / / Check the status again 
 	 	 	 status = queryStatus ( ) ; 
 	 	 } 
 	 }
