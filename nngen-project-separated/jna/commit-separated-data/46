BLEU SCORE: 0.010783469846969963

TEST MSG: Fix PdhTest + update PdhEnumObjectItems
GENERATED MSG: Zero - check PDH counter and instance lists , add English index lookup

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java b / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java <nl> index f63fae7 . . 82d13a8 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java <nl> @ @ - 23 , 8 + 23 , 6 @ @ <nl> * / <nl> package com . sun . jna . platform . win32 ; <nl> <nl> - import java . util . List ; <nl> - <nl> import com . sun . jna . Native ; <nl> import com . sun . jna . Pointer ; <nl> import com . sun . jna . Structure ; <nl> @ @ - 55 , 6 + 53 , 12 @ @ public interface Pdh extends StdCallLibrary { <nl> / * * Maximum full counter log name length . * / <nl> int PDH _ MAX _ DATASOURCE _ PATH = 1024 ; <nl> <nl> + int PDH _ MORE _ DATA = 0x800007D2 ; <nl> + int PDH _ INVALID _ ARGUMENT = 0xC0000BBD ; <nl> + int PDH _ MEMORY _ ALLOCATION _ FAILURE = 0xC0000BBB ; <nl> + int PDH _ CSTATUS _ NO _ MACHINE = 0x800007D0 ; <nl> + int PDH _ CSTATUS _ NO _ OBJECT = 0xC0000BB8 ; <nl> + <nl> / * TODO <nl> * LPVOID CALLBACK AllocateMemory ( _ In _ SIZE _ T AllocSize , _ In _ LPVOID pContext ) <nl> * void CALLBACK FreeMemory ( LPVOID pBuffer , LPVOID pContext ) <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java b / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java <nl> index 4143e41 . . b246874 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java <nl> @ @ - 30 , 6 + 30 , 7 @ @ import com . sun . jna . Memory ; <nl> import com . sun . jna . Native ; <nl> import com . sun . jna . platform . win32 . WinDef . DWORD ; <nl> import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; <nl> + import java . util . Collections ; <nl> <nl> / * * <nl> * Pdh utility API . <nl> @ @ - 61 , 16 + 62 , 23 @ @ public abstract class PdhUtil { <nl> public static String PdhLookupPerfNameByIndex ( String szMachineName , int dwNameIndex ) { <nl> / / Call once to get required buffer size <nl> DWORDByReference pcchNameBufferSize = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> - Pdh . INSTANCE . PdhLookupPerfNameByIndex ( szMachineName , dwNameIndex , null , pcchNameBufferSize ) ; <nl> - <nl> + int result = Pdh . INSTANCE . PdhLookupPerfNameByIndex ( szMachineName , dwNameIndex , null , pcchNameBufferSize ) ; <nl> + if ( result ! = WinError . ERROR _ SUCCESS & & result ! = Pdh . PDH _ MORE _ DATA ) { <nl> + throw new PdhException ( result ) ; <nl> + } <nl> + <nl> / / Can ' t allocate 0 memory <nl> if ( pcchNameBufferSize . getValue ( ) . intValue ( ) < 1 ) { <nl> return " " ; <nl> } <nl> / / Allocate buffer and call again <nl> Memory mem = new Memory ( pcchNameBufferSize . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; <nl> - Pdh . INSTANCE . PdhLookupPerfNameByIndex ( szMachineName , dwNameIndex , mem , pcchNameBufferSize ) ; <nl> + result = Pdh . INSTANCE . PdhLookupPerfNameByIndex ( szMachineName , dwNameIndex , mem , pcchNameBufferSize ) ; <nl> <nl> + if ( result ! = WinError . ERROR _ SUCCESS ) { <nl> + throw new PdhException ( result ) ; <nl> + } <nl> + <nl> / / Convert buffer to Java String <nl> if ( CHAR _ TO _ BYTES = = 1 ) { <nl> return mem . getString ( 0 ) ; <nl> @ @ - 113 , 9 + 121 , 8 @ @ public abstract class PdhUtil { <nl> <nl> / * * <nl> * Utility method to call Pdh ' s PdhEnumObjectItems that allocates the <nl> - * required memory for the mszCounterList parameter based on the type <nl> - * mapping used , calls to PdhEnumObjectItems , and returns the received lists <nl> - * of strings . <nl> + * required memory for the lists parameters based on the type mapping used , <nl> + * calls to PdhEnumObjectItems , and returns the received lists of strings . <nl> * <nl> * @ param szDataSource <nl> * String that specifies the name of the log file used to <nl> @ @ - 137 , 113 + 144 , 135 @ @ public abstract class PdhUtil { <nl> * returned . <nl> * @ return Returns a List of Strings of the counters for the object . <nl> * / <nl> - public static List < String > PdhEnumObjectItemCounters ( String szDataSource , String szMachineName , String szObjectName , <nl> + public static PdhEnumObjectItems PdhEnumObjectItems ( String szDataSource , String szMachineName , String szObjectName , <nl> int dwDetailLevel ) { <nl> List < String > counters = new ArrayList < String > ( ) ; <nl> + List < String > instances = new ArrayList < String > ( ) ; <nl> <nl> / / Call once to get string lengths <nl> DWORDByReference pcchCounterListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> DWORDByReference pcchInstanceListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> - Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , <nl> + int result = Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , <nl> pcchInstanceListLength , dwDetailLevel , 0 ) ; <nl> + if ( result ! = WinError . ERROR _ SUCCESS & & result ! = Pdh . PDH _ MORE _ DATA ) { <nl> + throw new PdhException ( result ) ; <nl> + } <nl> <nl> - / / Can ' t allocate 0 memory if no counters <nl> - if ( pcchCounterListLength . getValue ( ) . intValue ( ) < 1 ) { <nl> - return counters ; <nl> + Memory mszCounterList = null ; <nl> + Memory mszInstanceList = null ; <nl> + <nl> + if ( pcchCounterListLength . getValue ( ) . intValue ( ) > 0 ) { <nl> + mszCounterList = new Memory ( pcchCounterListLength . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; <nl> + } <nl> + <nl> + if ( pcchInstanceListLength . getValue ( ) . intValue ( ) > 0 ) { <nl> + mszInstanceList = new Memory ( pcchInstanceListLength . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; <nl> + } <nl> + <nl> + result = Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , mszCounterList , <nl> + pcchCounterListLength , mszInstanceList , pcchInstanceListLength , dwDetailLevel , 0 ) ; <nl> + <nl> + if ( result ! = WinError . ERROR _ SUCCESS ) { <nl> + throw new PdhException ( result ) ; <nl> } <nl> - / / Allocate memory and call again to populate strings <nl> - Memory mszCounterList = new Memory ( pcchCounterListLength . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; <nl> - / / Don ' t need the instances <nl> - pcchInstanceListLength . getValue ( ) . setValue ( 0 ) ; <nl> - Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , mszCounterList , <nl> - pcchCounterListLength , null , pcchInstanceListLength , dwDetailLevel , 0 ) ; <nl> <nl> / / Fetch counters <nl> - int offset = 0 ; <nl> - while ( offset < mszCounterList . size ( ) ) { <nl> - String s = null ; <nl> - if ( CHAR _ TO _ BYTES = = 1 ) { <nl> - s = mszCounterList . getString ( offset ) ; <nl> - } else { <nl> - s = mszCounterList . getWideString ( offset ) ; <nl> + if ( mszCounterList ! = null ) { <nl> + int offset = 0 ; <nl> + while ( offset < mszCounterList . size ( ) ) { <nl> + String s = null ; <nl> + if ( CHAR _ TO _ BYTES = = 1 ) { <nl> + s = mszCounterList . getString ( offset ) ; <nl> + } else { <nl> + s = mszCounterList . getWideString ( offset ) ; <nl> + } <nl> + / / list ends with double null <nl> + if ( s . isEmpty ( ) ) { <nl> + break ; <nl> + } <nl> + counters . add ( s ) ; <nl> + / / Increment for string + null terminator <nl> + offset + = ( s . length ( ) + 1 ) * CHAR _ TO _ BYTES ; <nl> } <nl> - / / list ends with double null <nl> - if ( s . isEmpty ( ) ) { <nl> - break ; <nl> + } <nl> + <nl> + if ( mszInstanceList ! = null ) { <nl> + int offset = 0 ; <nl> + while ( offset < mszInstanceList . size ( ) ) { <nl> + String s = null ; <nl> + if ( CHAR _ TO _ BYTES = = 1 ) { <nl> + s = mszInstanceList . getString ( offset ) ; <nl> + } else { <nl> + s = mszInstanceList . getWideString ( offset ) ; <nl> + } <nl> + / / list ends with double null <nl> + if ( s . isEmpty ( ) ) { <nl> + break ; <nl> + } <nl> + instances . add ( s ) ; <nl> + / / Increment for string + null terminator <nl> + offset + = ( s . length ( ) + 1 ) * CHAR _ TO _ BYTES ; <nl> } <nl> - counters . add ( s ) ; <nl> - / / Increment for string + null terminator <nl> - offset + = ( s . length ( ) + 1 ) * CHAR _ TO _ BYTES ; <nl> } <nl> <nl> - return counters ; <nl> + return new PdhEnumObjectItems ( counters , instances ) ; <nl> } <nl> <nl> + <nl> / * * <nl> - * Utility method to call Pdh ' s PdhEnumObjectItems that allocates the <nl> - * required memory for the mszInstanceList parameters based on the type <nl> - * mapping used , calls to PdhEnumObjectItems , and returns the received lists <nl> - * of strings . <nl> - * <nl> - * @ param szDataSource <nl> - * String that specifies the name of the log file used to <nl> - * enumerate the counter and instance names . If NULL , the <nl> - * function uses the computer specified in the szMachineName <nl> - * parameter to enumerate the names . <nl> - * @ param szMachineName <nl> - * String that specifies the name of the computer that contains <nl> - * the counter and instance names that you want to enumerate . <nl> - * Include the leading slashes in the computer name , for example , <nl> - * \ \ computername . If the szDataSource parameter is NULL , you can <nl> - * set szMachineName to NULL to specify the local computer . <nl> - * @ param szObjectName <nl> - * String that specifies the name of the object whose counter and <nl> - * instance names you want to enumerate . <nl> - * @ param dwDetailLevel <nl> - * Detail level of the performance items to return . All items <nl> - * that are of the specified detail level or less will be <nl> - * returned . <nl> - * @ return Returns a Lists of Strings of the instances of the object . <nl> + * Holder Object for PdhEnumObjectsItems . The embedded lists are modifiable <nl> + * lists and can be accessed through the { @ link # getCounters ( ) } and <nl> + * { @ link # getInstances ( ) } accessors . <nl> * / <nl> - public static List < String > PdhEnumObjectItemInstances ( String szDataSource , String szMachineName , <nl> - String szObjectName , int dwDetailLevel ) { <nl> - List < String > instances = new ArrayList < String > ( ) ; <nl> + public static class PdhEnumObjectItems { <nl> + private final List < String > counters ; <nl> + private final List < String > instances ; <nl> <nl> - / / Call once to get string lengths <nl> - DWORDByReference pcchCounterListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> - DWORDByReference pcchInstanceListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; <nl> - Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , <nl> - pcchInstanceListLength , dwDetailLevel , 0 ) ; <nl> + public PdhEnumObjectItems ( List < String > counters , List < String > instances ) { <nl> + this . counters = copyAndEmptyListForNullList ( counters ) ; <nl> + this . instances = copyAndEmptyListForNullList ( instances ) ; <nl> + } <nl> + <nl> + / * * <nl> + * @ return the embedded counters list , all calls to this function receive <nl> + * the same list and thus share modifications <nl> + * / <nl> + public List < String > getCounters ( ) { <nl> + return counters ; <nl> + } <nl> <nl> - / / Can ' t allocate 0 memory if no instances <nl> - if ( pcchInstanceListLength . getValue ( ) . intValue ( ) < 1 ) { <nl> + / * * <nl> + * @ return the embedded instances list , all calls to this function receive <nl> + * the same list and thus share modifications <nl> + * / <nl> + public List < String > getInstances ( ) { <nl> return instances ; <nl> } <nl> - / / Allocate memory and call again to populate strings <nl> - Memory mszInstanceList = new Memory ( pcchInstanceListLength . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; <nl> - / / Don ' t need the counters <nl> - pcchCounterListLength . getValue ( ) . setValue ( 0 ) ; <nl> - Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , <nl> - mszInstanceList , pcchInstanceListLength , dwDetailLevel , 0 ) ; <nl> - <nl> - / / Fetch instances <nl> - int offset = 0 ; <nl> - while ( offset < mszInstanceList . size ( ) ) { <nl> - String s = null ; <nl> - if ( CHAR _ TO _ BYTES = = 1 ) { <nl> - s = mszInstanceList . getString ( offset ) ; <nl> + <nl> + private List < String > copyAndEmptyListForNullList ( List < String > inputList ) { <nl> + if ( inputList = = null ) { <nl> + return new ArrayList < String > ( ) ; <nl> } else { <nl> - s = mszInstanceList . getWideString ( offset ) ; <nl> - } <nl> - / / list ends with double null <nl> - if ( s . isEmpty ( ) ) { <nl> - break ; <nl> + return new ArrayList < String > ( inputList ) ; <nl> } <nl> - instances . add ( s ) ; <nl> - / / Increment for string + null terminator <nl> - offset + = ( s . length ( ) + 1 ) * CHAR _ TO _ BYTES ; <nl> } <nl> <nl> - return instances ; <nl> + @ Override <nl> + public String toString ( ) { <nl> + return " PdhEnumObjectItems { " + " counters = " + counters + " , instances = " + instances + ' } ' ; <nl> + } <nl> + } <nl> + <nl> + public static final class PdhException extends RuntimeException { <nl> + private final int errorCode ; <nl> + <nl> + public PdhException ( int errorCode ) { <nl> + super ( String . format ( " Pdh call failed with error code 0x % 08X " , errorCode ) ) ; <nl> + this . errorCode = errorCode ; <nl> + } <nl> + <nl> + public int getErrorCode ( ) { <nl> + return errorCode ; <nl> + } <nl> } <nl> } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java <nl> index a3462c7 . . e78f632 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java <nl> @ @ - 16 , 7 + 16 , 6 @ @ import java . io . PrintStream ; <nl> import java . util . Collection ; <nl> import java . util . HashMap ; <nl> import java . util . LinkedList ; <nl> - import java . util . List ; <nl> import java . util . Map ; <nl> <nl> import org . junit . Test ; <nl> @ @ - 24 , 6 + 23 , 8 @ @ import org . junit . Test ; <nl> import com . sun . jna . Native ; <nl> import com . sun . jna . platform . win32 . Pdh . PDH _ COUNTER _ PATH _ ELEMENTS ; <nl> import com . sun . jna . platform . win32 . Pdh . PDH _ RAW _ COUNTER ; <nl> + import com . sun . jna . platform . win32 . PdhUtil . PdhEnumObjectItems ; <nl> + import com . sun . jna . platform . win32 . PdhUtil . PdhException ; <nl> import com . sun . jna . platform . win32 . WinDef . DWORD ; <nl> import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> @ @ - 182 , 21 + 183 , 32 @ @ public class PdhTest extends AbstractWin32TestSupport { <nl> @ Test <nl> public void testEnumObjectItems ( ) { <nl> if ( AbstractWin32TestSupport . isEnglishLocale ) { <nl> - 	 	 	 String processorStr = " Processor " ; <nl> + String processorStr = " Processor " ; <nl> String processorTimeStr = " % Processor Time " ; <nl> <nl> / / Fetch the counter and instance names <nl> - 	 	 	 List < String > instances = PdhUtil . PdhEnumObjectItemInstances ( null , null , processorStr , 100 ) ; <nl> + PdhEnumObjectItems objects = PdhUtil . PdhEnumObjectItems ( null , null , processorStr , 100 ) ; <nl> <nl> - / / Should have at least one processor and total instance <nl> - 	 	 	 assertTrue ( instances . contains ( " 0 " ) ) ; <nl> - 	 	 	 assertTrue ( instances . contains ( " _ Total " ) ) ; <nl> + assertTrue ( objects . getInstances ( ) . contains ( " 0 " ) ) ; <nl> + assertTrue ( objects . getInstances ( ) . contains ( " _ Total " ) ) ; <nl> <nl> / / Should have a " % Processor Time " counter <nl> - 	 	 	 List < String > counters = PdhUtil . PdhEnumObjectItemCounters ( null , null , processorStr , 100 ) ; <nl> - 	 	 	 assertTrue ( counters . contains ( processorTimeStr ) ) ; <nl> + assertTrue ( objects . getCounters ( ) . contains ( processorTimeStr ) ) ; <nl> } else { <nl> System . err . println ( " testEnumObjectItems test can only be run with english locale . " ) ; <nl> } <nl> } <nl> + <nl> + @ Test <nl> + public void testEnumObjectItemsNonExisting ( ) { <nl> + Exception caughtException = null ; <nl> + try { <nl> + PdhUtil . PdhEnumObjectItems ( null , null , " Unknown counter " , 100 ) ; <nl> + } catch ( Exception ex ) { <nl> + caughtException = ex ; <nl> + } <nl> + assertNotNull ( caughtException ) ; <nl> + assertTrue ( caughtException instanceof PdhException ) ; <nl> + assertEquals ( Pdh . PDH _ CSTATUS _ NO _ OBJECT , ( ( PdhException ) caughtException ) . getErrorCode ( ) ) ; <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java b / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java 
 index f63fae7 . . 82d13a8 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Pdh . java 
 @ @ - 23 , 8 + 23 , 6 @ @ 
 * / 
 package com . sun . jna . platform . win32 ; 
 
 - import java . util . List ; 
 - 
 import com . sun . jna . Native ; 
 import com . sun . jna . Pointer ; 
 import com . sun . jna . Structure ; 
 @ @ - 55 , 6 + 53 , 12 @ @ public interface Pdh extends StdCallLibrary { 
 / * * Maximum full counter log name length . * / 
 int PDH _ MAX _ DATASOURCE _ PATH = 1024 ; 
 
 + int PDH _ MORE _ DATA = 0x800007D2 ; 
 + int PDH _ INVALID _ ARGUMENT = 0xC0000BBD ; 
 + int PDH _ MEMORY _ ALLOCATION _ FAILURE = 0xC0000BBB ; 
 + int PDH _ CSTATUS _ NO _ MACHINE = 0x800007D0 ; 
 + int PDH _ CSTATUS _ NO _ OBJECT = 0xC0000BB8 ; 
 + 
 / * TODO 
 * LPVOID CALLBACK AllocateMemory ( _ In _ SIZE _ T AllocSize , _ In _ LPVOID pContext ) 
 * void CALLBACK FreeMemory ( LPVOID pBuffer , LPVOID pContext ) 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java b / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java 
 index 4143e41 . . b246874 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / PdhUtil . java 
 @ @ - 30 , 6 + 30 , 7 @ @ import com . sun . jna . Memory ; 
 import com . sun . jna . Native ; 
 import com . sun . jna . platform . win32 . WinDef . DWORD ; 
 import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; 
 + import java . util . Collections ; 
 
 / * * 
 * Pdh utility API . 
 @ @ - 61 , 16 + 62 , 23 @ @ public abstract class PdhUtil { 
 public static String PdhLookupPerfNameByIndex ( String szMachineName , int dwNameIndex ) { 
 / / Call once to get required buffer size 
 DWORDByReference pcchNameBufferSize = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 - Pdh . INSTANCE . PdhLookupPerfNameByIndex ( szMachineName , dwNameIndex , null , pcchNameBufferSize ) ; 
 - 
 + int result = Pdh . INSTANCE . PdhLookupPerfNameByIndex ( szMachineName , dwNameIndex , null , pcchNameBufferSize ) ; 
 + if ( result ! = WinError . ERROR _ SUCCESS & & result ! = Pdh . PDH _ MORE _ DATA ) { 
 + throw new PdhException ( result ) ; 
 + } 
 + 
 / / Can ' t allocate 0 memory 
 if ( pcchNameBufferSize . getValue ( ) . intValue ( ) < 1 ) { 
 return " " ; 
 } 
 / / Allocate buffer and call again 
 Memory mem = new Memory ( pcchNameBufferSize . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; 
 - Pdh . INSTANCE . PdhLookupPerfNameByIndex ( szMachineName , dwNameIndex , mem , pcchNameBufferSize ) ; 
 + result = Pdh . INSTANCE . PdhLookupPerfNameByIndex ( szMachineName , dwNameIndex , mem , pcchNameBufferSize ) ; 
 
 + if ( result ! = WinError . ERROR _ SUCCESS ) { 
 + throw new PdhException ( result ) ; 
 + } 
 + 
 / / Convert buffer to Java String 
 if ( CHAR _ TO _ BYTES = = 1 ) { 
 return mem . getString ( 0 ) ; 
 @ @ - 113 , 9 + 121 , 8 @ @ public abstract class PdhUtil { 
 
 / * * 
 * Utility method to call Pdh ' s PdhEnumObjectItems that allocates the 
 - * required memory for the mszCounterList parameter based on the type 
 - * mapping used , calls to PdhEnumObjectItems , and returns the received lists 
 - * of strings . 
 + * required memory for the lists parameters based on the type mapping used , 
 + * calls to PdhEnumObjectItems , and returns the received lists of strings . 
 * 
 * @ param szDataSource 
 * String that specifies the name of the log file used to 
 @ @ - 137 , 113 + 144 , 135 @ @ public abstract class PdhUtil { 
 * returned . 
 * @ return Returns a List of Strings of the counters for the object . 
 * / 
 - public static List < String > PdhEnumObjectItemCounters ( String szDataSource , String szMachineName , String szObjectName , 
 + public static PdhEnumObjectItems PdhEnumObjectItems ( String szDataSource , String szMachineName , String szObjectName , 
 int dwDetailLevel ) { 
 List < String > counters = new ArrayList < String > ( ) ; 
 + List < String > instances = new ArrayList < String > ( ) ; 
 
 / / Call once to get string lengths 
 DWORDByReference pcchCounterListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 DWORDByReference pcchInstanceListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 - Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , 
 + int result = Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , 
 pcchInstanceListLength , dwDetailLevel , 0 ) ; 
 + if ( result ! = WinError . ERROR _ SUCCESS & & result ! = Pdh . PDH _ MORE _ DATA ) { 
 + throw new PdhException ( result ) ; 
 + } 
 
 - / / Can ' t allocate 0 memory if no counters 
 - if ( pcchCounterListLength . getValue ( ) . intValue ( ) < 1 ) { 
 - return counters ; 
 + Memory mszCounterList = null ; 
 + Memory mszInstanceList = null ; 
 + 
 + if ( pcchCounterListLength . getValue ( ) . intValue ( ) > 0 ) { 
 + mszCounterList = new Memory ( pcchCounterListLength . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; 
 + } 
 + 
 + if ( pcchInstanceListLength . getValue ( ) . intValue ( ) > 0 ) { 
 + mszInstanceList = new Memory ( pcchInstanceListLength . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; 
 + } 
 + 
 + result = Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , mszCounterList , 
 + pcchCounterListLength , mszInstanceList , pcchInstanceListLength , dwDetailLevel , 0 ) ; 
 + 
 + if ( result ! = WinError . ERROR _ SUCCESS ) { 
 + throw new PdhException ( result ) ; 
 } 
 - / / Allocate memory and call again to populate strings 
 - Memory mszCounterList = new Memory ( pcchCounterListLength . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; 
 - / / Don ' t need the instances 
 - pcchInstanceListLength . getValue ( ) . setValue ( 0 ) ; 
 - Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , mszCounterList , 
 - pcchCounterListLength , null , pcchInstanceListLength , dwDetailLevel , 0 ) ; 
 
 / / Fetch counters 
 - int offset = 0 ; 
 - while ( offset < mszCounterList . size ( ) ) { 
 - String s = null ; 
 - if ( CHAR _ TO _ BYTES = = 1 ) { 
 - s = mszCounterList . getString ( offset ) ; 
 - } else { 
 - s = mszCounterList . getWideString ( offset ) ; 
 + if ( mszCounterList ! = null ) { 
 + int offset = 0 ; 
 + while ( offset < mszCounterList . size ( ) ) { 
 + String s = null ; 
 + if ( CHAR _ TO _ BYTES = = 1 ) { 
 + s = mszCounterList . getString ( offset ) ; 
 + } else { 
 + s = mszCounterList . getWideString ( offset ) ; 
 + } 
 + / / list ends with double null 
 + if ( s . isEmpty ( ) ) { 
 + break ; 
 + } 
 + counters . add ( s ) ; 
 + / / Increment for string + null terminator 
 + offset + = ( s . length ( ) + 1 ) * CHAR _ TO _ BYTES ; 
 } 
 - / / list ends with double null 
 - if ( s . isEmpty ( ) ) { 
 - break ; 
 + } 
 + 
 + if ( mszInstanceList ! = null ) { 
 + int offset = 0 ; 
 + while ( offset < mszInstanceList . size ( ) ) { 
 + String s = null ; 
 + if ( CHAR _ TO _ BYTES = = 1 ) { 
 + s = mszInstanceList . getString ( offset ) ; 
 + } else { 
 + s = mszInstanceList . getWideString ( offset ) ; 
 + } 
 + / / list ends with double null 
 + if ( s . isEmpty ( ) ) { 
 + break ; 
 + } 
 + instances . add ( s ) ; 
 + / / Increment for string + null terminator 
 + offset + = ( s . length ( ) + 1 ) * CHAR _ TO _ BYTES ; 
 } 
 - counters . add ( s ) ; 
 - / / Increment for string + null terminator 
 - offset + = ( s . length ( ) + 1 ) * CHAR _ TO _ BYTES ; 
 } 
 
 - return counters ; 
 + return new PdhEnumObjectItems ( counters , instances ) ; 
 } 
 
 + 
 / * * 
 - * Utility method to call Pdh ' s PdhEnumObjectItems that allocates the 
 - * required memory for the mszInstanceList parameters based on the type 
 - * mapping used , calls to PdhEnumObjectItems , and returns the received lists 
 - * of strings . 
 - * 
 - * @ param szDataSource 
 - * String that specifies the name of the log file used to 
 - * enumerate the counter and instance names . If NULL , the 
 - * function uses the computer specified in the szMachineName 
 - * parameter to enumerate the names . 
 - * @ param szMachineName 
 - * String that specifies the name of the computer that contains 
 - * the counter and instance names that you want to enumerate . 
 - * Include the leading slashes in the computer name , for example , 
 - * \ \ computername . If the szDataSource parameter is NULL , you can 
 - * set szMachineName to NULL to specify the local computer . 
 - * @ param szObjectName 
 - * String that specifies the name of the object whose counter and 
 - * instance names you want to enumerate . 
 - * @ param dwDetailLevel 
 - * Detail level of the performance items to return . All items 
 - * that are of the specified detail level or less will be 
 - * returned . 
 - * @ return Returns a Lists of Strings of the instances of the object . 
 + * Holder Object for PdhEnumObjectsItems . The embedded lists are modifiable 
 + * lists and can be accessed through the { @ link # getCounters ( ) } and 
 + * { @ link # getInstances ( ) } accessors . 
 * / 
 - public static List < String > PdhEnumObjectItemInstances ( String szDataSource , String szMachineName , 
 - String szObjectName , int dwDetailLevel ) { 
 - List < String > instances = new ArrayList < String > ( ) ; 
 + public static class PdhEnumObjectItems { 
 + private final List < String > counters ; 
 + private final List < String > instances ; 
 
 - / / Call once to get string lengths 
 - DWORDByReference pcchCounterListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 - DWORDByReference pcchInstanceListLength = new DWORDByReference ( new DWORD ( 0 ) ) ; 
 - Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , null , 
 - pcchInstanceListLength , dwDetailLevel , 0 ) ; 
 + public PdhEnumObjectItems ( List < String > counters , List < String > instances ) { 
 + this . counters = copyAndEmptyListForNullList ( counters ) ; 
 + this . instances = copyAndEmptyListForNullList ( instances ) ; 
 + } 
 + 
 + / * * 
 + * @ return the embedded counters list , all calls to this function receive 
 + * the same list and thus share modifications 
 + * / 
 + public List < String > getCounters ( ) { 
 + return counters ; 
 + } 
 
 - / / Can ' t allocate 0 memory if no instances 
 - if ( pcchInstanceListLength . getValue ( ) . intValue ( ) < 1 ) { 
 + / * * 
 + * @ return the embedded instances list , all calls to this function receive 
 + * the same list and thus share modifications 
 + * / 
 + public List < String > getInstances ( ) { 
 return instances ; 
 } 
 - / / Allocate memory and call again to populate strings 
 - Memory mszInstanceList = new Memory ( pcchInstanceListLength . getValue ( ) . intValue ( ) * CHAR _ TO _ BYTES ) ; 
 - / / Don ' t need the counters 
 - pcchCounterListLength . getValue ( ) . setValue ( 0 ) ; 
 - Pdh . INSTANCE . PdhEnumObjectItems ( szDataSource , szMachineName , szObjectName , null , pcchCounterListLength , 
 - mszInstanceList , pcchInstanceListLength , dwDetailLevel , 0 ) ; 
 - 
 - / / Fetch instances 
 - int offset = 0 ; 
 - while ( offset < mszInstanceList . size ( ) ) { 
 - String s = null ; 
 - if ( CHAR _ TO _ BYTES = = 1 ) { 
 - s = mszInstanceList . getString ( offset ) ; 
 + 
 + private List < String > copyAndEmptyListForNullList ( List < String > inputList ) { 
 + if ( inputList = = null ) { 
 + return new ArrayList < String > ( ) ; 
 } else { 
 - s = mszInstanceList . getWideString ( offset ) ; 
 - } 
 - / / list ends with double null 
 - if ( s . isEmpty ( ) ) { 
 - break ; 
 + return new ArrayList < String > ( inputList ) ; 
 } 
 - instances . add ( s ) ; 
 - / / Increment for string + null terminator 
 - offset + = ( s . length ( ) + 1 ) * CHAR _ TO _ BYTES ; 
 } 
 
 - return instances ; 
 + @ Override 
 + public String toString ( ) { 
 + return " PdhEnumObjectItems { " + " counters = " + counters + " , instances = " + instances + ' } ' ; 
 + } 
 + } 
 + 
 + public static final class PdhException extends RuntimeException { 
 + private final int errorCode ; 
 + 
 + public PdhException ( int errorCode ) { 
 + super ( String . format ( " Pdh call failed with error code 0x % 08X " , errorCode ) ) ; 
 + this . errorCode = errorCode ; 
 + } 
 + 
 + public int getErrorCode ( ) { 
 + return errorCode ; 
 + } 
 } 
 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java 
 index a3462c7 . . e78f632 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / PdhTest . java 
 @ @ - 16 , 7 + 16 , 6 @ @ import java . io . PrintStream ; 
 import java . util . Collection ; 
 import java . util . HashMap ; 
 import java . util . LinkedList ; 
 - import java . util . List ; 
 import java . util . Map ; 
 
 import org . junit . Test ; 
 @ @ - 24 , 6 + 23 , 8 @ @ import org . junit . Test ; 
 import com . sun . jna . Native ; 
 import com . sun . jna . platform . win32 . Pdh . PDH _ COUNTER _ PATH _ ELEMENTS ; 
 import com . sun . jna . platform . win32 . Pdh . PDH _ RAW _ COUNTER ; 
 + import com . sun . jna . platform . win32 . PdhUtil . PdhEnumObjectItems ; 
 + import com . sun . jna . platform . win32 . PdhUtil . PdhException ; 
 import com . sun . jna . platform . win32 . WinDef . DWORD ; 
 import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 @ @ - 182 , 21 + 183 , 32 @ @ public class PdhTest extends AbstractWin32TestSupport { 
 @ Test 
 public void testEnumObjectItems ( ) { 
 if ( AbstractWin32TestSupport . isEnglishLocale ) { 
 - 	 	 	 String processorStr = " Processor " ; 
 + String processorStr = " Processor " ; 
 String processorTimeStr = " % Processor Time " ; 
 
 / / Fetch the counter and instance names 
 - 	 	 	 List < String > instances = PdhUtil . PdhEnumObjectItemInstances ( null , null , processorStr , 100 ) ; 
 + PdhEnumObjectItems objects = PdhUtil . PdhEnumObjectItems ( null , null , processorStr , 100 ) ; 
 
 - / / Should have at least one processor and total instance 
 - 	 	 	 assertTrue ( instances . contains ( " 0 " ) ) ; 
 - 	 	 	 assertTrue ( instances . contains ( " _ Total " ) ) ; 
 + assertTrue ( objects . getInstances ( ) . contains ( " 0 " ) ) ; 
 + assertTrue ( objects . getInstances ( ) . contains ( " _ Total " ) ) ; 
 
 / / Should have a " % Processor Time " counter 
 - 	 	 	 List < String > counters = PdhUtil . PdhEnumObjectItemCounters ( null , null , processorStr , 100 ) ; 
 - 	 	 	 assertTrue ( counters . contains ( processorTimeStr ) ) ; 
 + assertTrue ( objects . getCounters ( ) . contains ( processorTimeStr ) ) ; 
 } else { 
 System . err . println ( " testEnumObjectItems test can only be run with english locale . " ) ; 
 } 
 } 
 + 
 + @ Test 
 + public void testEnumObjectItemsNonExisting ( ) { 
 + Exception caughtException = null ; 
 + try { 
 + PdhUtil . PdhEnumObjectItems ( null , null , " Unknown counter " , 100 ) ; 
 + } catch ( Exception ex ) { 
 + caughtException = ex ; 
 + } 
 + assertNotNull ( caughtException ) ; 
 + assertTrue ( caughtException instanceof PdhException ) ; 
 + assertEquals ( Pdh . PDH _ CSTATUS _ NO _ OBJECT , ( ( PdhException ) caughtException ) . getErrorCode ( ) ) ; 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
