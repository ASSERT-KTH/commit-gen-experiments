BLEU SCORE: 0.4347208719449915

TEST MSG: Add encryption and decryption helpers to Advapi32Util
GENERATED MSG: Add encryption and decryption functions to Advapi32

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> old mode 100644 <nl> new mode 100755 <nl> index c28e348 . . 6b08e38 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> @ @ - 12 , 7 + 12 , 9 @ @ <nl> * / <nl> package com . sun . jna . platform . win32 ; <nl> <nl> + import java . io . ByteArrayOutputStream ; <nl> import java . io . File ; <nl> + import java . io . IOException ; <nl> import java . util . ArrayList ; <nl> import java . util . HashMap ; <nl> import java . util . Iterator ; <nl> @ @ - 37 , 6 + 39 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; <nl> import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEY ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> + import com . sun . jna . ptr . ByteByReference ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> import com . sun . jna . ptr . LongByReference ; <nl> import com . sun . jna . ptr . PointerByReference ; <nl> @ @ - 2185 , 4 + 2188 , 159 @ @ public abstract class Advapi32Util { <nl> <nl> return hasAccess ; <nl> } <nl> + 	 <nl> + / * * <nl> + * Encrypts a file or directory . <nl> + * <nl> + * @ param file <nl> + * The file or directory to encrypt . <nl> + * / <nl> + public static void encryptFile ( File file ) { <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + if ( ! Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Decrypts an encrypted file or directory . <nl> + * <nl> + * @ param file <nl> + * The file or directory to decrypt . <nl> + * / <nl> + public static void decryptFile ( File file ) { <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + if ( ! Advapi32 . INSTANCE . DecryptFile ( lpFileName , new DWORD ( 0 ) ) ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Checks the encryption status of a file . <nl> + * <nl> + * @ param file <nl> + * The file to check the status for . <nl> + * @ return The status of the file . <nl> + * / <nl> + public static int fileEncryptionStatus ( File file ) { <nl> + DWORDByReference status = new DWORDByReference ( ) ; <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + if ( ! Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , status ) ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + return status . getValue ( ) . intValue ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Disables or enables encryption of the specified directory and the files in <nl> + * it . <nl> + * <nl> + * @ param directory <nl> + * The directory for which to enable or disable encryption . <nl> + * @ param disable <nl> + * TRUE to disable encryption . FALSE to enable it . <nl> + * / <nl> + public static void disableEncryption ( File directory , boolean disable ) { <nl> + WString dirPath = new WString ( directory . getAbsolutePath ( ) ) ; <nl> + if ( ! Advapi32 . INSTANCE . EncryptionDisable ( dirPath , disable ) ) { <nl> + throw new Win32Exception ( Native . getLastError ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Backup an encrypted file or folder without decrypting it . A file named <nl> + * " bar / sample . text " will be backed - up to " destDir / sample . text " . A directory <nl> + * named " bar " will be backed - up to " destDir / bar " . This method is NOT <nl> + * recursive . If you have an encrypted directory with encrypted files , this <nl> + * method must be called once for the directory , and once for each encrypted <nl> + * file to be backed - up . <nl> + * <nl> + * @ param src <nl> + * The encrypted file or directory to backup . <nl> + * @ param destDir <nl> + * The directory where the backup will be saved . <nl> + * / <nl> + public static void backupEncryptedFile ( File src , File destDir ) { <nl> + if ( ! destDir . isDirectory ( ) ) { <nl> + throw new IllegalArgumentException ( " destDir must be a directory . " ) ; <nl> + } <nl> + <nl> + ULONG readFlag = new ULONG ( 0 ) ; / / Open the file for export ( backup ) <nl> + ULONG writeFlag = new ULONG ( CREATE _ FOR _ IMPORT ) ; / / Import ( restore ) file <nl> + <nl> + if ( src . isDirectory ( ) ) { <nl> + writeFlag . setValue ( CREATE _ FOR _ IMPORT | CREATE _ FOR _ DIR ) ; <nl> + } <nl> + <nl> + / / open encrypted file for export <nl> + WString srcFileName = new WString ( src . getAbsolutePath ( ) ) ; <nl> + PointerByReference pvContext = new PointerByReference ( ) ; <nl> + if ( Advapi32 . INSTANCE . OpenEncryptedFileRaw ( srcFileName , readFlag , <nl> + pvContext ) ! = W32Errors . ERROR _ SUCCESS ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + <nl> + / / read encrypted file <nl> + final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; <nl> + FE _ EXPORT _ FUNC pfExportCallback = new FE _ EXPORT _ FUNC ( ) { <nl> + @ Override <nl> + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , <nl> + ULONG ulLength ) { <nl> + byte [ ] arr = pbData . getPointer ( ) . getByteArray ( 0 , ulLength . intValue ( ) ) ; <nl> + try { <nl> + outputStream . write ( arr ) ; <nl> + } catch ( IOException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; <nl> + } <nl> + } ; <nl> + <nl> + if ( Advapi32 . INSTANCE . ReadEncryptedFileRaw ( pfExportCallback , null , <nl> + pvContext . getValue ( ) ) ! = W32Errors . ERROR _ SUCCESS ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + <nl> + / / close <nl> + try { <nl> + outputStream . close ( ) ; <nl> + } catch ( IOException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; <nl> + <nl> + / / open file for import <nl> + WString destFileName = new WString ( destDir . getAbsolutePath ( ) + File . separator <nl> + + src . getName ( ) ) ; <nl> + pvContext = new PointerByReference ( ) ; <nl> + if ( Advapi32 . INSTANCE . OpenEncryptedFileRaw ( destFileName , writeFlag , <nl> + pvContext ) ! = W32Errors . ERROR _ SUCCESS ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + <nl> + / / write encrypted file <nl> + final IntByReference elementsReadWrapper = new IntByReference ( 0 ) ; <nl> + FE _ IMPORT _ FUNC pfImportCallback = new FE _ IMPORT _ FUNC ( ) { <nl> + @ Override <nl> + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , <nl> + ULONGByReference ulLength ) { <nl> + int elementsRead = elementsReadWrapper . getValue ( ) ; <nl> + int remainingElements = outputStream . size ( ) - elementsRead ; <nl> + int length = Math . min ( remainingElements , ulLength . getValue ( ) . intValue ( ) ) ; <nl> + pbData . getPointer ( ) . write ( 0 , outputStream . toByteArray ( ) , elementsRead , <nl> + length ) ; <nl> + elementsReadWrapper . setValue ( elementsRead + length ) ; <nl> + ulLength . setValue ( new ULONG ( length ) ) ; <nl> + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; <nl> + } <nl> + } ; <nl> + <nl> + if ( Advapi32 . INSTANCE . WriteEncryptedFileRaw ( pfImportCallback , null , <nl> + pvContext . getValue ( ) ) ! = W32Errors . ERROR _ SUCCESS ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + <nl> + / / close <nl> + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; <nl> + } <nl> } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java <nl> old mode 100644 <nl> new mode 100755 <nl> index 835c409 . . c8eb531 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java <nl> @ @ - 13 , 6 + 13 , 7 @ @ <nl> package com . sun . jna . platform . win32 ; <nl> <nl> import java . io . File ; <nl> + import java . io . FileWriter ; <nl> import java . util . Map ; <nl> import java . util . TreeMap ; <nl> <nl> @ @ - 30 , 6 + 31 , 8 @ @ import com . sun . jna . platform . win32 . WinNT . WELL _ KNOWN _ SID _ TYPE ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEY ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> <nl> + import static com . sun . jna . platform . win32 . WinBase . * ; <nl> + <nl> / * * <nl> * @ author dblock [ at ] dblock [ dot ] org <nl> * / <nl> @ @ - 483 , 4 + 486 , 89 @ @ public class Advapi32UtilTest extends TestCase { <nl> String block = Advapi32Util . getEnvironmentBlock ( mockEnvironment ) ; <nl> assertEquals ( " Environment block must comprise key = value pairs separated by NUL characters " , expected , block ) ; <nl> } <nl> + 	 <nl> + public void testEncryptFile ( ) throws Exception { <nl> + File file = createTempFile ( ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( file ) ) ; <nl> + Advapi32Util . encryptFile ( file ) ; <nl> + assertEquals ( FILE _ IS _ ENCRYPTED , Advapi32Util . fileEncryptionStatus ( file ) ) ; <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + public void testDecryptFile ( ) throws Exception { <nl> + File file = createTempFile ( ) ; <nl> + Advapi32Util . encryptFile ( file ) ; <nl> + assertEquals ( FILE _ IS _ ENCRYPTED , Advapi32Util . fileEncryptionStatus ( file ) ) ; <nl> + Advapi32Util . decryptFile ( file ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( file ) ) ; <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + public void testDisableEncryption ( ) throws Exception { <nl> + File dir = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator <nl> + + System . nanoTime ( ) ) ; <nl> + dir . mkdir ( ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( dir ) ) ; <nl> + Advapi32Util . disableEncryption ( dir , true ) ; <nl> + assertEquals ( FILE _ DIR _ DISALOWED , Advapi32Util . fileEncryptionStatus ( dir ) ) ; <nl> + Advapi32Util . disableEncryption ( dir , false ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( dir ) ) ; <nl> + for ( File file : dir . listFiles ( ) ) { <nl> + file . delete ( ) ; <nl> + } <nl> + dir . delete ( ) ; <nl> + } <nl> + <nl> + public void testBackupEncryptedFile ( ) throws Exception { <nl> + / / backup an encrypted file <nl> + File srcFile = createTempFile ( ) ; <nl> + Advapi32Util . encryptFile ( srcFile ) ; <nl> + File dest = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator <nl> + + " backup " + System . nanoTime ( ) ) ; <nl> + dest . mkdir ( ) ; <nl> + <nl> + Advapi32Util . backupEncryptedFile ( srcFile , dest ) ; <nl> + <nl> + / / simple check to see if a backup file exist <nl> + File backupFile = new File ( dest . getAbsolutePath ( ) + File . separator + <nl> + srcFile . getName ( ) ) ; <nl> + assertTrue ( backupFile . exists ( ) ) ; <nl> + assertEquals ( srcFile . length ( ) , backupFile . length ( ) ) ; <nl> + <nl> + / / backup an encrypted directory <nl> + File srcDir = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator <nl> + + System . nanoTime ( ) ) ; <nl> + srcDir . mkdir ( ) ; <nl> + Advapi32Util . encryptFile ( srcDir ) ; <nl> + <nl> + Advapi32Util . backupEncryptedFile ( srcDir , dest ) ; <nl> + <nl> + / / Check to see if a backup directory exist <nl> + File backupDir = new File ( dest . getAbsolutePath ( ) + File . separator + srcDir . getName ( ) ) ; <nl> + assertTrue ( backupDir . exists ( ) ) ; <nl> + <nl> + / / clean up <nl> + srcFile . delete ( ) ; <nl> + for ( File file : srcDir . listFiles ( ) ) { <nl> + file . delete ( ) ; <nl> + } <nl> + srcDir . delete ( ) ; <nl> + for ( File file : dest . listFiles ( ) ) { <nl> + file . delete ( ) ; <nl> + } <nl> + dest . delete ( ) ; <nl> + } <nl> + <nl> + private File createTempFile ( ) throws Exception { <nl> + String filePath = System . getProperty ( " java . io . tmpdir " ) + System . nanoTime ( ) <nl> + + " . text " ; <nl> + File file = new File ( filePath ) ; <nl> + file . createNewFile ( ) ; <nl> + FileWriter fileWriter = new FileWriter ( file ) ; <nl> + for ( int i = 0 ; i < 1000 ; i + + ) { <nl> + fileWriter . write ( " Sample text " + i + System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> + fileWriter . close ( ) ; <nl> + return file ; <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 old mode 100644 
 new mode 100755 
 index c28e348 . . 6b08e38 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 @ @ - 12 , 7 + 12 , 9 @ @ 
 * / 
 package com . sun . jna . platform . win32 ; 
 
 + import java . io . ByteArrayOutputStream ; 
 import java . io . File ; 
 + import java . io . IOException ; 
 import java . util . ArrayList ; 
 import java . util . HashMap ; 
 import java . util . Iterator ; 
 @ @ - 37 , 6 + 39 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; 
 import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; 
 import com . sun . jna . platform . win32 . WinReg . HKEY ; 
 import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 + import com . sun . jna . ptr . ByteByReference ; 
 import com . sun . jna . ptr . IntByReference ; 
 import com . sun . jna . ptr . LongByReference ; 
 import com . sun . jna . ptr . PointerByReference ; 
 @ @ - 2185 , 4 + 2188 , 159 @ @ public abstract class Advapi32Util { 
 
 return hasAccess ; 
 } 
 + 	 
 + / * * 
 + * Encrypts a file or directory . 
 + * 
 + * @ param file 
 + * The file or directory to encrypt . 
 + * / 
 + public static void encryptFile ( File file ) { 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + if ( ! Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Decrypts an encrypted file or directory . 
 + * 
 + * @ param file 
 + * The file or directory to decrypt . 
 + * / 
 + public static void decryptFile ( File file ) { 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + if ( ! Advapi32 . INSTANCE . DecryptFile ( lpFileName , new DWORD ( 0 ) ) ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Checks the encryption status of a file . 
 + * 
 + * @ param file 
 + * The file to check the status for . 
 + * @ return The status of the file . 
 + * / 
 + public static int fileEncryptionStatus ( File file ) { 
 + DWORDByReference status = new DWORDByReference ( ) ; 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + if ( ! Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , status ) ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + return status . getValue ( ) . intValue ( ) ; 
 + } 
 + 
 + / * * 
 + * Disables or enables encryption of the specified directory and the files in 
 + * it . 
 + * 
 + * @ param directory 
 + * The directory for which to enable or disable encryption . 
 + * @ param disable 
 + * TRUE to disable encryption . FALSE to enable it . 
 + * / 
 + public static void disableEncryption ( File directory , boolean disable ) { 
 + WString dirPath = new WString ( directory . getAbsolutePath ( ) ) ; 
 + if ( ! Advapi32 . INSTANCE . EncryptionDisable ( dirPath , disable ) ) { 
 + throw new Win32Exception ( Native . getLastError ( ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Backup an encrypted file or folder without decrypting it . A file named 
 + * " bar / sample . text " will be backed - up to " destDir / sample . text " . A directory 
 + * named " bar " will be backed - up to " destDir / bar " . This method is NOT 
 + * recursive . If you have an encrypted directory with encrypted files , this 
 + * method must be called once for the directory , and once for each encrypted 
 + * file to be backed - up . 
 + * 
 + * @ param src 
 + * The encrypted file or directory to backup . 
 + * @ param destDir 
 + * The directory where the backup will be saved . 
 + * / 
 + public static void backupEncryptedFile ( File src , File destDir ) { 
 + if ( ! destDir . isDirectory ( ) ) { 
 + throw new IllegalArgumentException ( " destDir must be a directory . " ) ; 
 + } 
 + 
 + ULONG readFlag = new ULONG ( 0 ) ; / / Open the file for export ( backup ) 
 + ULONG writeFlag = new ULONG ( CREATE _ FOR _ IMPORT ) ; / / Import ( restore ) file 
 + 
 + if ( src . isDirectory ( ) ) { 
 + writeFlag . setValue ( CREATE _ FOR _ IMPORT | CREATE _ FOR _ DIR ) ; 
 + } 
 + 
 + / / open encrypted file for export 
 + WString srcFileName = new WString ( src . getAbsolutePath ( ) ) ; 
 + PointerByReference pvContext = new PointerByReference ( ) ; 
 + if ( Advapi32 . INSTANCE . OpenEncryptedFileRaw ( srcFileName , readFlag , 
 + pvContext ) ! = W32Errors . ERROR _ SUCCESS ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + 
 + / / read encrypted file 
 + final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; 
 + FE _ EXPORT _ FUNC pfExportCallback = new FE _ EXPORT _ FUNC ( ) { 
 + @ Override 
 + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , 
 + ULONG ulLength ) { 
 + byte [ ] arr = pbData . getPointer ( ) . getByteArray ( 0 , ulLength . intValue ( ) ) ; 
 + try { 
 + outputStream . write ( arr ) ; 
 + } catch ( IOException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; 
 + } 
 + } ; 
 + 
 + if ( Advapi32 . INSTANCE . ReadEncryptedFileRaw ( pfExportCallback , null , 
 + pvContext . getValue ( ) ) ! = W32Errors . ERROR _ SUCCESS ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + 
 + / / close 
 + try { 
 + outputStream . close ( ) ; 
 + } catch ( IOException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; 
 + 
 + / / open file for import 
 + WString destFileName = new WString ( destDir . getAbsolutePath ( ) + File . separator 
 + + src . getName ( ) ) ; 
 + pvContext = new PointerByReference ( ) ; 
 + if ( Advapi32 . INSTANCE . OpenEncryptedFileRaw ( destFileName , writeFlag , 
 + pvContext ) ! = W32Errors . ERROR _ SUCCESS ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + 
 + / / write encrypted file 
 + final IntByReference elementsReadWrapper = new IntByReference ( 0 ) ; 
 + FE _ IMPORT _ FUNC pfImportCallback = new FE _ IMPORT _ FUNC ( ) { 
 + @ Override 
 + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , 
 + ULONGByReference ulLength ) { 
 + int elementsRead = elementsReadWrapper . getValue ( ) ; 
 + int remainingElements = outputStream . size ( ) - elementsRead ; 
 + int length = Math . min ( remainingElements , ulLength . getValue ( ) . intValue ( ) ) ; 
 + pbData . getPointer ( ) . write ( 0 , outputStream . toByteArray ( ) , elementsRead , 
 + length ) ; 
 + elementsReadWrapper . setValue ( elementsRead + length ) ; 
 + ulLength . setValue ( new ULONG ( length ) ) ; 
 + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; 
 + } 
 + } ; 
 + 
 + if ( Advapi32 . INSTANCE . WriteEncryptedFileRaw ( pfImportCallback , null , 
 + pvContext . getValue ( ) ) ! = W32Errors . ERROR _ SUCCESS ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + 
 + / / close 
 + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; 
 + } 
 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java 
 old mode 100644 
 new mode 100755 
 index 835c409 . . c8eb531 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java 
 @ @ - 13 , 6 + 13 , 7 @ @ 
 package com . sun . jna . platform . win32 ; 
 
 import java . io . File ; 
 + import java . io . FileWriter ; 
 import java . util . Map ; 
 import java . util . TreeMap ; 
 
 @ @ - 30 , 6 + 31 , 8 @ @ import com . sun . jna . platform . win32 . WinNT . WELL _ KNOWN _ SID _ TYPE ; 
 import com . sun . jna . platform . win32 . WinReg . HKEY ; 
 import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 
 + import static com . sun . jna . platform . win32 . WinBase . * ; 
 + 
 / * * 
 * @ author dblock [ at ] dblock [ dot ] org 
 * / 
 @ @ - 483 , 4 + 486 , 89 @ @ public class Advapi32UtilTest extends TestCase { 
 String block = Advapi32Util . getEnvironmentBlock ( mockEnvironment ) ; 
 assertEquals ( " Environment block must comprise key = value pairs separated by NUL characters " , expected , block ) ; 
 } 
 + 	 
 + public void testEncryptFile ( ) throws Exception { 
 + File file = createTempFile ( ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( file ) ) ; 
 + Advapi32Util . encryptFile ( file ) ; 
 + assertEquals ( FILE _ IS _ ENCRYPTED , Advapi32Util . fileEncryptionStatus ( file ) ) ; 
 + file . delete ( ) ; 
 + } 
 + 
 + public void testDecryptFile ( ) throws Exception { 
 + File file = createTempFile ( ) ; 
 + Advapi32Util . encryptFile ( file ) ; 
 + assertEquals ( FILE _ IS _ ENCRYPTED , Advapi32Util . fileEncryptionStatus ( file ) ) ; 
 + Advapi32Util . decryptFile ( file ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( file ) ) ; 
 + file . delete ( ) ; 
 + } 
 + 
 + public void testDisableEncryption ( ) throws Exception { 
 + File dir = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator 
 + + System . nanoTime ( ) ) ; 
 + dir . mkdir ( ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( dir ) ) ; 
 + Advapi32Util . disableEncryption ( dir , true ) ; 
 + assertEquals ( FILE _ DIR _ DISALOWED , Advapi32Util . fileEncryptionStatus ( dir ) ) ; 
 + Advapi32Util . disableEncryption ( dir , false ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( dir ) ) ; 
 + for ( File file : dir . listFiles ( ) ) { 
 + file . delete ( ) ; 
 + } 
 + dir . delete ( ) ; 
 + } 
 + 
 + public void testBackupEncryptedFile ( ) throws Exception { 
 + / / backup an encrypted file 
 + File srcFile = createTempFile ( ) ; 
 + Advapi32Util . encryptFile ( srcFile ) ; 
 + File dest = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator 
 + + " backup " + System . nanoTime ( ) ) ; 
 + dest . mkdir ( ) ; 
 + 
 + Advapi32Util . backupEncryptedFile ( srcFile , dest ) ; 
 + 
 + / / simple check to see if a backup file exist 
 + File backupFile = new File ( dest . getAbsolutePath ( ) + File . separator + 
 + srcFile . getName ( ) ) ; 
 + assertTrue ( backupFile . exists ( ) ) ; 
 + assertEquals ( srcFile . length ( ) , backupFile . length ( ) ) ; 
 + 
 + / / backup an encrypted directory 
 + File srcDir = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator 
 + + System . nanoTime ( ) ) ; 
 + srcDir . mkdir ( ) ; 
 + Advapi32Util . encryptFile ( srcDir ) ; 
 + 
 + Advapi32Util . backupEncryptedFile ( srcDir , dest ) ; 
 + 
 + / / Check to see if a backup directory exist 
 + File backupDir = new File ( dest . getAbsolutePath ( ) + File . separator + srcDir . getName ( ) ) ; 
 + assertTrue ( backupDir . exists ( ) ) ; 
 + 
 + / / clean up 
 + srcFile . delete ( ) ; 
 + for ( File file : srcDir . listFiles ( ) ) { 
 + file . delete ( ) ; 
 + } 
 + srcDir . delete ( ) ; 
 + for ( File file : dest . listFiles ( ) ) { 
 + file . delete ( ) ; 
 + } 
 + dest . delete ( ) ; 
 + } 
 + 
 + private File createTempFile ( ) throws Exception { 
 + String filePath = System . getProperty ( " java . io . tmpdir " ) + System . nanoTime ( ) 
 + + " . text " ; 
 + File file = new File ( filePath ) ; 
 + file . createNewFile ( ) ; 
 + FileWriter fileWriter = new FileWriter ( file ) ; 
 + for ( int i = 0 ; i < 1000 ; i + + ) { 
 + fileWriter . write ( " Sample text " + i + System . getProperty ( " line . separator " ) ) ; 
 + } 
 + fileWriter . close ( ) ; 
 + return file ; 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
