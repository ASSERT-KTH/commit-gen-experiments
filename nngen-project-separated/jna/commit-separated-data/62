BLEU SCORE: 0.037477767366779206

TEST MSG: Use Arm EABI section to detect hard - / softfloat usage
GENERATED MSG: Add arm softfloat variant as platform armel

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index e46a394 . . c8767e1 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 44 , 6 + 44 , 7 @ @ Bug Fixes <nl> < li > Change into the expanded directory and run ` bash build . sh ` . < / li > <nl> < li > The resulting ` sunos - x86 . jar ` is copied back to the original build system to ` lib / native / sunos - x86 . jar ` < / li > <nl> < / ol > - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> + * [ # 958 ] ( https : / / github . com / java - native - access / jna / issues / 958 ) : Update for PR 863 : Old toolchains produce binaries without hard - / softfloat markers . Rasbian is missinng the markers and the oracle JDK is also affected . For hardfloat detection now also the Arm EABI section is also considered - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . <nl> <nl> Breaking Changes <nl> - - - - - - - - - - - - - - - - <nl> diff - - git a / ant - tools - src / com / sun / jna / BuildArmSoftFloatDetector . java b / ant - tools - src / com / sun / jna / BuildArmSoftFloatDetector . java <nl> index 6fa141d . . fa851e9 100644 <nl> - - - a / ant - tools - src / com / sun / jna / BuildArmSoftFloatDetector . java <nl> + + + b / ant - tools - src / com / sun / jna / BuildArmSoftFloatDetector . java <nl> @ @ - 60 , 7 + 60 , 7 @ @ public class BuildArmSoftFloatDetector { <nl> / / The self . getCanonicalPath ( ) resolves the symblink to the backing <nl> / / realfile and passes that to the detection routines <nl> ELFAnalyser ahfd = ELFAnalyser . analyse ( self . getCanonicalPath ( ) ) ; <nl> - result = ahfd . isArmSoftFloat ( ) ; <nl> + result = ! ahfd . isArmHardFloat ( ) ; <nl> } catch ( IOException ex ) { <nl> result = false ; <nl> } <nl> diff - - git a / src / com / sun / jna / ELFAnalyser . java b / src / com / sun / jna / ELFAnalyser . java <nl> index ba84382 . . 85f4ace 100644 <nl> - - - a / src / com / sun / jna / ELFAnalyser . java <nl> + + + b / src / com / sun / jna / ELFAnalyser . java <nl> @ @ - 1 , 15 + 1 , 25 @ @ <nl> <nl> package com . sun . jna ; <nl> <nl> + import java . io . ByteArrayOutputStream ; <nl> import java . io . IOException ; <nl> import java . io . RandomAccessFile ; <nl> + import java . io . UnsupportedEncodingException ; <nl> + import java . math . BigInteger ; <nl> + import java . nio . Buffer ; <nl> import java . nio . ByteBuffer ; <nl> import java . nio . ByteOrder ; <nl> + import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> + import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> + import java . util . LinkedList ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> <nl> / * * <nl> * Analyse an ELF file for platform specific attributes . <nl> - * <nl> + * <nl> * < p > Primary use - case : Detect whether the java binary is arm hardfloat or softfloat . < / p > <nl> * / <nl> class ELFAnalyser { <nl> @ @ - 30 , 19 + 40 , 20 @ @ class ELFAnalyser { <nl> private static final int EI _ DATA _ BIG _ ENDIAN = 2 ; <nl> private static final int E _ MACHINE _ ARM = 0x28 ; <nl> private static final int EI _ CLASS _ 64BIT = 2 ; <nl> - <nl> + <nl> public static ELFAnalyser analyse ( String filename ) throws IOException { <nl> ELFAnalyser res = new ELFAnalyser ( filename ) ; <nl> res . runDetection ( ) ; <nl> return res ; <nl> } <nl> - <nl> + <nl> private final String filename ; <nl> private boolean ELF = false ; <nl> private boolean _ 64Bit = false ; <nl> private boolean bigEndian = false ; <nl> - private boolean armHardFloat = false ; <nl> - private boolean armSoftFloat = false ; <nl> + private boolean armHardFloatFlag = false ; <nl> + private boolean armSoftFloatFlag = false ; <nl> + private boolean armEabiAapcsVfp = false ; <nl> private boolean arm = false ; <nl> <nl> / * * <nl> @ @ - 75 , 20 + 86 , 32 @ @ class ELFAnalyser { <nl> return filename ; <nl> } <nl> <nl> + public boolean isArmHardFloat ( ) { <nl> + return isArmEabiAapcsVfp ( ) | | isArmHardFloatFlag ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * @ return true if file was detected to specify , that FP parameters / result <nl> + * passing conforms to AAPCS , VFP variant ( hardfloat ) <nl> + * / <nl> + public boolean isArmEabiAapcsVfp ( ) { <nl> + return armEabiAapcsVfp ; <nl> + } <nl> + <nl> / * * <nl> * @ return true if file was detected to conform to the hardware floating - point <nl> - * procedure - call standard <nl> + * procedure - call standard via ELF flags <nl> * / <nl> - public boolean isArmHardFloat ( ) { <nl> - return armHardFloat ; <nl> + public boolean isArmHardFloatFlag ( ) { <nl> + return armHardFloatFlag ; <nl> } <nl> <nl> / * * <nl> * @ return true if file was detected to conform to the software floating - point <nl> - * procedure - call standard <nl> + * procedure - call standard via ELF flags <nl> * / <nl> - public boolean isArmSoftFloat ( ) { <nl> - return armSoftFloat ; <nl> + public boolean isArmSoftFloatFlag ( ) { <nl> + return armSoftFloatFlag ; <nl> } <nl> <nl> / * * <nl> @ @ - 123 , 26 + 146 , 423 @ @ class ELFAnalyser { <nl> / / The total header size depends on the pointer size of the platform <nl> / / so before the header is loaded the pointer size has to be determined <nl> byte sizeIndicator = raf . readByte ( ) ; <nl> + byte endianessIndicator = raf . readByte ( ) ; <nl> _ 64Bit = sizeIndicator = = EI _ CLASS _ 64BIT ; <nl> + bigEndian = endianessIndicator = = EI _ DATA _ BIG _ ENDIAN ; <nl> raf . seek ( 0 ) ; <nl> + / / header length <nl> ByteBuffer headerData = ByteBuffer . allocate ( _ 64Bit ? 64 : 52 ) ; <nl> raf . getChannel ( ) . read ( headerData , 0 ) ; <nl> - bigEndian = headerData . get ( 5 ) = = EI _ DATA _ BIG _ ENDIAN ; <nl> + <nl> headerData . order ( bigEndian ? ByteOrder . BIG _ ENDIAN : ByteOrder . LITTLE _ ENDIAN ) ; <nl> <nl> + / / e _ machine <nl> arm = headerData . get ( 0x12 ) = = E _ MACHINE _ ARM ; <nl> <nl> if ( arm ) { <nl> + / / e _ flags <nl> int flags = headerData . getInt ( _ 64Bit ? 0x30 : 0x24 ) ; <nl> - armHardFloat = ( flags & EF _ ARM _ ABI _ FLOAT _ HARD ) = = EF _ ARM _ ABI _ FLOAT _ HARD ; <nl> - armSoftFloat = ! armHardFloat ; <nl> + armHardFloatFlag = ( flags & EF _ ARM _ ABI _ FLOAT _ HARD ) = = EF _ ARM _ ABI _ FLOAT _ HARD ; <nl> + armSoftFloatFlag = ( flags & EF _ ARM _ ABI _ FLOAT _ SOFT ) = = EF _ ARM _ ABI _ FLOAT _ SOFT ; <nl> + <nl> + parseEabiAapcsVfp ( headerData , raf ) ; <nl> } <nl> } finally { <nl> try { <nl> raf . close ( ) ; <nl> } catch ( IOException ex ) { <nl> - / / Swallow - closing <nl> + / / Swallow - closing <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void parseEabiAapcsVfp ( ByteBuffer headerData , RandomAccessFile raf ) throws IOException { <nl> + ELFSectionHeaders sectionHeaders = new ELFSectionHeaders ( _ 64Bit , bigEndian , headerData , raf ) ; <nl> + <nl> + for ( ELFSectionHeaderEntry eshe : sectionHeaders . getEntries ( ) ) { <nl> + if ( " . ARM . attributes " . equals ( eshe . getName ( ) ) ) { <nl> + ByteBuffer armAttributesBuffer = ByteBuffer . allocate ( eshe . getSize ( ) ) ; <nl> + armAttributesBuffer . order ( bigEndian ? ByteOrder . BIG _ ENDIAN : ByteOrder . LITTLE _ ENDIAN ) ; <nl> + raf . getChannel ( ) . read ( armAttributesBuffer , eshe . getOffset ( ) ) ; <nl> + armAttributesBuffer . rewind ( ) ; <nl> + Map < Integer , Map < ArmAeabiAttributesTag , Object > > armAttributes = parseArmAttributes ( armAttributesBuffer ) ; <nl> + Map < ArmAeabiAttributesTag , Object > fileAttributes = armAttributes . get ( 1 ) ; <nl> + if ( fileAttributes = = null ) { <nl> + continue ; <nl> + } <nl> + / * * <nl> + * Tag _ ABI _ VFP _ args , ( = 28 ) , uleb128 <nl> + * 0 The user intended FP parameter / result passing to conform to AAPCS , base variant <nl> + * 1 The user intended FP parameter / result passing to conform to AAPCS , VFP variant <nl> + * 2 The user intended FP parameter / result passing to conform to tool chain - specific conventions <nl> + * 3 Code is compatible with both the base and VFP variants ; the non - variadic functions to pass FP parameters / results <nl> + * / <nl> + Object abiVFPargValue = fileAttributes . get ( ArmAeabiAttributesTag . ABI _ VFP _ args ) ; <nl> + if ( abiVFPargValue instanceof Integer & & ( ( Integer ) abiVFPargValue ) . equals ( 1 ) ) { <nl> + armEabiAapcsVfp = true ; <nl> + } else if ( abiVFPargValue instanceof BigInteger & & ( ( BigInteger ) abiVFPargValue ) . intValue ( ) = = 1 ) { <nl> + armEabiAapcsVfp = true ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + static class ELFSectionHeaders { <nl> + private final List < ELFSectionHeaderEntry > entries = new ArrayList < ELFSectionHeaderEntry > ( ) ; <nl> + <nl> + public ELFSectionHeaders ( boolean _ 64bit , boolean bigEndian , ByteBuffer headerData , RandomAccessFile raf ) throws IOException { <nl> + long shoff ; <nl> + int shentsize ; <nl> + int shnum ; <nl> + short shstrndx ; <nl> + if ( _ 64bit ) { <nl> + shoff = headerData . getLong ( 0x28 ) ; <nl> + shentsize = headerData . getShort ( 0x3A ) ; <nl> + shnum = headerData . getShort ( 0x3C ) ; <nl> + shstrndx = headerData . getShort ( 0x3E ) ; <nl> + } else { <nl> + shoff = headerData . getInt ( 0x20 ) ; <nl> + shentsize = headerData . getShort ( 0x2E ) ; <nl> + shnum = headerData . getShort ( 0x30 ) ; <nl> + shstrndx = headerData . getShort ( 0x32 ) ; <nl> + } <nl> + <nl> + int tableLength = shnum * shentsize ; <nl> + <nl> + ByteBuffer data = ByteBuffer . allocate ( tableLength ) ; <nl> + data . order ( bigEndian ? ByteOrder . BIG _ ENDIAN : ByteOrder . LITTLE _ ENDIAN ) ; <nl> + raf . getChannel ( ) . read ( data , shoff ) ; <nl> + <nl> + for ( int i = 0 ; i < shnum ; i + + ) { <nl> + data . position ( i * shentsize ) ; <nl> + ByteBuffer header = data . slice ( ) ; <nl> + header . order ( data . order ( ) ) ; <nl> + header . limit ( shentsize ) ; <nl> + entries . add ( new ELFSectionHeaderEntry ( _ 64bit , header ) ) ; <nl> + } <nl> + <nl> + ELFSectionHeaderEntry stringTable = entries . get ( shstrndx ) ; <nl> + ByteBuffer stringBuffer = ByteBuffer . allocate ( stringTable . getSize ( ) ) ; <nl> + stringBuffer . order ( bigEndian ? ByteOrder . BIG _ ENDIAN : ByteOrder . LITTLE _ ENDIAN ) ; <nl> + raf . getChannel ( ) . read ( stringBuffer , stringTable . getOffset ( ) ) ; <nl> + stringBuffer . rewind ( ) ; <nl> + <nl> + ByteArrayOutputStream baos = new ByteArrayOutputStream ( 20 ) ; <nl> + for ( ELFSectionHeaderEntry eshe : entries ) { <nl> + baos . reset ( ) ; <nl> + <nl> + ( ( Buffer ) stringBuffer ) . position ( eshe . getNameOffset ( ) ) ; <nl> + <nl> + while ( stringBuffer . position ( ) < stringBuffer . limit ( ) ) { <nl> + byte b = stringBuffer . get ( ) ; <nl> + if ( b = = 0 ) { <nl> + break ; <nl> + } else { <nl> + baos . write ( b ) ; <nl> + } <nl> + } <nl> + <nl> + eshe . setName ( baos . toString ( " ASCII " ) ) ; <nl> + } <nl> + } <nl> + <nl> + public List < ELFSectionHeaderEntry > getEntries ( ) { <nl> + return entries ; <nl> + } <nl> + } <nl> + <nl> + static class ELFSectionHeaderEntry { <nl> + private final int nameOffset ; <nl> + private String name ; <nl> + private final int type ; <nl> + private final int flags ; <nl> + private final int offset ; <nl> + private final int size ; <nl> + <nl> + public ELFSectionHeaderEntry ( boolean _ 64bit , ByteBuffer sectionHeaderData ) { <nl> + this . nameOffset = sectionHeaderData . getInt ( 0x0 ) ; <nl> + this . type = sectionHeaderData . getInt ( 0x4 ) ; <nl> + this . flags = ( int ) ( _ 64bit ? sectionHeaderData . getLong ( 0x8 ) : sectionHeaderData . getInt ( 0x8 ) ) ; <nl> + this . offset = ( int ) ( _ 64bit ? sectionHeaderData . getLong ( 0x18 ) : sectionHeaderData . getInt ( 0x10 ) ) ; <nl> + this . size = ( int ) ( _ 64bit ? sectionHeaderData . getLong ( 0x20 ) : sectionHeaderData . getInt ( 0x14 ) ) ; <nl> + } <nl> + <nl> + public String getName ( ) { <nl> + return name ; <nl> + } <nl> + <nl> + public void setName ( String name ) { <nl> + this . name = name ; <nl> + } <nl> + <nl> + public int getNameOffset ( ) { <nl> + return nameOffset ; <nl> + } <nl> + <nl> + public int getType ( ) { <nl> + return type ; <nl> + } <nl> + <nl> + public int getFlags ( ) { <nl> + return flags ; <nl> + } <nl> + <nl> + public int getOffset ( ) { <nl> + return offset ; <nl> + } <nl> + <nl> + public int getSize ( ) { <nl> + return size ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) { <nl> + return " ELFSectionHeaderEntry { " + " nameIdx = " + nameOffset + " , name = " + name + " , type = " + type + " , flags = " + flags + " , offset = " + offset + " , size = " + size + ' } ' ; <nl> + } <nl> + } <nl> + <nl> + static class ArmAeabiAttributesTag { <nl> + <nl> + public enum ParameterType { <nl> + UINT32 , NTBS , ULEB128 <nl> + } <nl> + <nl> + private final int value ; <nl> + private final String name ; <nl> + private final ParameterType parameterType ; <nl> + <nl> + public ArmAeabiAttributesTag ( int value , String name , ParameterType parameterType ) { <nl> + this . value = value ; <nl> + this . name = name ; <nl> + this . parameterType = parameterType ; <nl> + } <nl> + <nl> + public int getValue ( ) { <nl> + return value ; <nl> + } <nl> + <nl> + public String getName ( ) { <nl> + return name ; <nl> + } <nl> + <nl> + public ParameterType getParameterType ( ) { <nl> + return parameterType ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) { <nl> + return name + " ( " + value + " ) " ; <nl> + } <nl> + <nl> + @ Override <nl> + public int hashCode ( ) { <nl> + int hash = 7 ; <nl> + hash = 67 * hash + this . value ; <nl> + return hash ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean equals ( Object obj ) { <nl> + if ( this = = obj ) { <nl> + return true ; <nl> + } <nl> + if ( obj = = null ) { <nl> + return false ; <nl> + } <nl> + if ( getClass ( ) ! = obj . getClass ( ) ) { <nl> + return false ; <nl> + } <nl> + final ArmAeabiAttributesTag other = ( ArmAeabiAttributesTag ) obj ; <nl> + if ( this . value ! = other . value ) { <nl> + return false ; <nl> + } <nl> + return true ; <nl> + } <nl> + <nl> + private static final List < ArmAeabiAttributesTag > tags = new LinkedList < ArmAeabiAttributesTag > ( ) ; <nl> + private static final Map < Integer , ArmAeabiAttributesTag > valueMap = new HashMap < Integer , ArmAeabiAttributesTag > ( ) ; <nl> + private static final Map < String , ArmAeabiAttributesTag > nameMap = new HashMap < String , ArmAeabiAttributesTag > ( ) ; <nl> + <nl> + / / Enumerated from ARM IHI 0045E , 2 . 5 Attributes summary and history <nl> + public static final ArmAeabiAttributesTag File = addTag ( 1 , " File " , ParameterType . UINT32 ) ; <nl> + public static final ArmAeabiAttributesTag Section = addTag ( 2 , " Section " , ParameterType . UINT32 ) ; <nl> + public static final ArmAeabiAttributesTag Symbol = addTag ( 3 , " Symbol " , ParameterType . UINT32 ) ; <nl> + public static final ArmAeabiAttributesTag CPU _ raw _ name = addTag ( 4 , " CPU _ raw _ name " , ParameterType . NTBS ) ; <nl> + public static final ArmAeabiAttributesTag CPU _ name = addTag ( 5 , " CPU _ name " , ParameterType . NTBS ) ; <nl> + public static final ArmAeabiAttributesTag CPU _ arch = addTag ( 6 , " CPU _ arch " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag CPU _ arch _ profile = addTag ( 7 , " CPU _ arch _ profile " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ARM _ ISA _ use = addTag ( 8 , " ARM _ ISA _ use " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag THUMB _ ISA _ use = addTag ( 9 , " THUMB _ ISA _ use " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag FP _ arch = addTag ( 10 , " FP _ arch " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag WMMX _ arch = addTag ( 11 , " WMMX _ arch " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag Advanced _ SIMD _ arch = addTag ( 12 , " Advanced _ SIMD _ arch " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag PCS _ config = addTag ( 13 , " PCS _ config " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ PCS _ R9 _ use = addTag ( 14 , " ABI _ PCS _ R9 _ use " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ PCS _ RW _ data = addTag ( 15 , " ABI _ PCS _ RW _ data " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ PCS _ RO _ data = addTag ( 16 , " ABI _ PCS _ RO _ data " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ PCS _ GOT _ use = addTag ( 17 , " ABI _ PCS _ GOT _ use " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ PCS _ wchar _ t = addTag ( 18 , " ABI _ PCS _ wchar _ t " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ FP _ rounding = addTag ( 19 , " ABI _ FP _ rounding " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ FP _ denormal = addTag ( 20 , " ABI _ FP _ denormal " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ FP _ exceptions = addTag ( 21 , " ABI _ FP _ exceptions " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ FP _ user _ exceptions = addTag ( 22 , " ABI _ FP _ user _ exceptions " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ FP _ number _ model = addTag ( 23 , " ABI _ FP _ number _ model " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ align _ needed = addTag ( 24 , " ABI _ align _ needed " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ align8 _ preserved = addTag ( 25 , " ABI _ align8 _ preserved " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ enum _ size = addTag ( 26 , " ABI _ enum _ size " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ HardFP _ use = addTag ( 27 , " ABI _ HardFP _ use " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ VFP _ args = addTag ( 28 , " ABI _ VFP _ args " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ WMMX _ args = addTag ( 29 , " ABI _ WMMX _ args " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ optimization _ goals = addTag ( 30 , " ABI _ optimization _ goals " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ FP _ optimization _ goals = addTag ( 31 , " ABI _ FP _ optimization _ goals " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag compatibility = addTag ( 32 , " compatibility " , ParameterType . NTBS ) ; <nl> + public static final ArmAeabiAttributesTag CPU _ unaligned _ access = addTag ( 34 , " CPU _ unaligned _ access " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag FP _ HP _ extension = addTag ( 36 , " FP _ HP _ extension " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag ABI _ FP _ 16bit _ format = addTag ( 38 , " ABI _ FP _ 16bit _ format " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag MPextension _ use = addTag ( 42 , " MPextension _ use " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag DIV _ use = addTag ( 44 , " DIV _ use " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag nodefaults = addTag ( 64 , " nodefaults " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag also _ compatible _ with = addTag ( 65 , " also _ compatible _ with " , ParameterType . NTBS ) ; <nl> + public static final ArmAeabiAttributesTag conformance = addTag ( 67 , " conformance " , ParameterType . NTBS ) ; <nl> + public static final ArmAeabiAttributesTag T2EE _ use = addTag ( 66 , " T2EE _ use " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag Virtualization _ use = addTag ( 68 , " Virtualization _ use " , ParameterType . ULEB128 ) ; <nl> + public static final ArmAeabiAttributesTag MPextension _ use2 = addTag ( 70 , " MPextension _ use " , ParameterType . ULEB128 ) ; <nl> + <nl> + private static ArmAeabiAttributesTag addTag ( int value , String name , ArmAeabiAttributesTag . ParameterType type ) { <nl> + ArmAeabiAttributesTag tag = new ArmAeabiAttributesTag ( value , name , type ) ; <nl> + <nl> + if ( ! valueMap . containsKey ( tag . getValue ( ) ) ) { <nl> + valueMap . put ( tag . getValue ( ) , tag ) ; <nl> + } <nl> + if ( ! nameMap . containsKey ( tag . getName ( ) ) ) { <nl> + nameMap . put ( tag . getName ( ) , tag ) ; <nl> + } <nl> + tags . add ( tag ) ; <nl> + return tag ; <nl> + } <nl> + <nl> + public static List < ArmAeabiAttributesTag > getTags ( ) { <nl> + return Collections . unmodifiableList ( tags ) ; <nl> + } <nl> + <nl> + public static ArmAeabiAttributesTag getByName ( String name ) { <nl> + return nameMap . get ( name ) ; <nl> + } <nl> + <nl> + public static ArmAeabiAttributesTag getByValue ( int value ) { <nl> + if ( valueMap . containsKey ( value ) ) { <nl> + return valueMap . get ( value ) ; <nl> + } else { <nl> + ArmAeabiAttributesTag pseudoTag = new ArmAeabiAttributesTag ( value , " Unknown " + value , getParameterType ( value ) ) ; <nl> + return pseudoTag ; <nl> + } <nl> + } <nl> + <nl> + private static ArmAeabiAttributesTag . ParameterType getParameterType ( int value ) { <nl> + / / ARM IHI 0045E , 2 . 2 . 6 Coding extensibility and compatibility <nl> + ArmAeabiAttributesTag tag = getByValue ( value ) ; <nl> + if ( tag = = null ) { <nl> + if ( ( value % 2 ) = = 0 ) { <nl> + return ArmAeabiAttributesTag . ParameterType . ULEB128 ; <nl> + } else { <nl> + return ArmAeabiAttributesTag . ParameterType . NTBS ; <nl> + } <nl> + } else { <nl> + return tag . getParameterType ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + <nl> + private static Map < Integer , Map < ArmAeabiAttributesTag , Object > > parseArmAttributes ( ByteBuffer bb ) { <nl> + byte format = bb . get ( ) ; <nl> + if ( format ! = 0x41 ) { <nl> + / / Version A <nl> + / / Not supported <nl> + return Collections . EMPTY _ MAP ; <nl> + } <nl> + while ( bb . position ( ) < bb . limit ( ) ) { <nl> + int posSectionStart = bb . position ( ) ; <nl> + int sectionLength = bb . getInt ( ) ; <nl> + if ( sectionLength < = 0 ) { <nl> + / / Fail ! <nl> + break ; <nl> + } <nl> + String vendorName = readNTBS ( bb , null ) ; <nl> + if ( " aeabi " . equals ( vendorName ) ) { <nl> + return parseAEABI ( bb ) ; <nl> + } <nl> + ( ( Buffer ) bb ) . position ( posSectionStart + sectionLength ) ; <nl> + } <nl> + return Collections . EMPTY _ MAP ; <nl> + } <nl> + <nl> + private static Map < Integer , Map < ArmAeabiAttributesTag , Object > > parseAEABI ( ByteBuffer buffer ) { <nl> + Map < Integer , Map < ArmAeabiAttributesTag , Object > > data = new HashMap < Integer , Map < ArmAeabiAttributesTag , Object > > ( ) ; <nl> + while ( buffer . position ( ) < buffer . limit ( ) ) { <nl> + int pos = buffer . position ( ) ; <nl> + int subsectionTag = readULEB128 ( buffer ) . intValue ( ) ; <nl> + int length = buffer . getInt ( ) ; <nl> + if ( subsectionTag = = ( byte ) 1 ) { <nl> + data . put ( subsectionTag , parseFileAttribute ( buffer ) ) ; <nl> + } <nl> + ( ( Buffer ) buffer ) . position ( pos + length ) ; <nl> + } <nl> + return data ; <nl> + } <nl> + <nl> + private static Map < ArmAeabiAttributesTag , Object > parseFileAttribute ( ByteBuffer bb ) { <nl> + Map < ArmAeabiAttributesTag , Object > result = new HashMap < ArmAeabiAttributesTag , Object > ( ) ; <nl> + while ( bb . position ( ) < bb . limit ( ) ) { <nl> + int tagValue = readULEB128 ( bb ) . intValue ( ) ; <nl> + ArmAeabiAttributesTag tag = ArmAeabiAttributesTag . getByValue ( tagValue ) ; <nl> + switch ( tag . getParameterType ( ) ) { <nl> + case UINT32 : <nl> + result . put ( tag , bb . getInt ( ) ) ; <nl> + break ; <nl> + case NTBS : <nl> + result . put ( tag , readNTBS ( bb , null ) ) ; <nl> + break ; <nl> + case ULEB128 : <nl> + result . put ( tag , readULEB128 ( bb ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + return result ; <nl> + } <nl> + <nl> + private static String readNTBS ( ByteBuffer buffer , Integer position ) { <nl> + if ( position ! = null ) { <nl> + ( ( Buffer ) buffer ) . position ( position ) ; <nl> + } <nl> + int startingPos = buffer . position ( ) ; <nl> + byte currentByte ; <nl> + do { <nl> + currentByte = buffer . get ( ) ; <nl> + } while ( currentByte ! = ' \ 0 ' & & buffer . position ( ) < = buffer . limit ( ) ) ; <nl> + int terminatingPosition = buffer . position ( ) ; <nl> + byte [ ] data = new byte [ terminatingPosition - startingPos - 1 ] ; <nl> + ( ( Buffer ) buffer ) . position ( startingPos ) ; <nl> + buffer . get ( data ) ; <nl> + ( ( Buffer ) buffer ) . position ( buffer . position ( ) + 1 ) ; <nl> + try { <nl> + return new String ( data , " ASCII " ) ; <nl> + } catch ( UnsupportedEncodingException ex ) { <nl> + throw new RuntimeException ( ex ) ; <nl> + } <nl> + } <nl> + <nl> + private static BigInteger readULEB128 ( ByteBuffer buffer ) { <nl> + BigInteger result = BigInteger . ZERO ; <nl> + int shift = 0 ; <nl> + while ( true ) { <nl> + byte b = buffer . get ( ) ; <nl> + result = result . or ( BigInteger . valueOf ( b & 127 ) . shiftLeft ( shift ) ) ; <nl> + if ( ( b & 128 ) = = 0 ) { <nl> + break ; <nl> } <nl> + shift + = 7 ; <nl> } <nl> + return result ; <nl> } <nl> } <nl> diff - - git a / src / com / sun / jna / Platform . java b / src / com / sun / jna / Platform . java <nl> index 7a5a29c . . 7bd9479 100644 <nl> - - - a / src / com / sun / jna / Platform . java <nl> + + + b / src / com / sun / jna / Platform . java <nl> @ @ - 268 , 7 + 268 , 7 @ @ public final class Platform { <nl> File self = new File ( " / proc / self / exe " ) ; <nl> if ( self . exists ( ) ) { <nl> ELFAnalyser ahfd = ELFAnalyser . analyse ( self . getCanonicalPath ( ) ) ; <nl> - return ahfd . isArmSoftFloat ( ) ; <nl> + return ! ahfd . isArmHardFloat ( ) ; <nl> } <nl> } catch ( IOException ex ) { <nl> / / asume hardfloat <nl> diff - - git a / test / com / sun / jna / ELFAnalyserTest . java b / test / com / sun / jna / ELFAnalyserTest . java <nl> index 18c74da . . 29c47bb 100644 <nl> - - - a / test / com / sun / jna / ELFAnalyserTest . java <nl> + + + b / test / com / sun / jna / ELFAnalyserTest . java <nl> @ @ - 10 , 31 + 10 , 33 @ @ import org . junit . Test ; <nl> <nl> <nl> public class ELFAnalyserTest { <nl> - <nl> + <nl> private static final File TEST _ RESOURCES = new File ( " build / test - resources " ) ; <nl> private static final File WIN32 _ LIB = new File ( TEST _ RESOURCES , " win32 - x86 - 64 . dll " ) ; <nl> private static final File LINUX _ ARMEL _ LIB = new File ( TEST _ RESOURCES , " linux - armel . so " ) ; <nl> private static final File LINUX _ ARMEL _ NOFLAG _ LIG = new File ( TEST _ RESOURCES , " linux - armel - noflag . so " ) ; <nl> + private static final File LINUX _ ARMHF _ NOFLAG _ LIG = new File ( TEST _ RESOURCES , " linux - armhf - noflag . so " ) ; <nl> private static final File LINUX _ ARMHF _ LIB = new File ( TEST _ RESOURCES , " linux - armhf . so " ) ; <nl> private static final File LINUX _ AMD64 _ LIB = new File ( TEST _ RESOURCES , " linux - amd64 . so " ) ; <nl> - <nl> + <nl> @ BeforeClass <nl> public static void initClass ( ) throws IOException { <nl> TEST _ RESOURCES . mkdirs ( ) ; <nl> - <nl> + <nl> extractTestFile ( WIN32 _ LIB ) ; <nl> extractTestFile ( LINUX _ ARMEL _ LIB ) ; <nl> extractTestFile ( LINUX _ ARMHF _ LIB ) ; <nl> extractTestFile ( LINUX _ AMD64 _ LIB ) ; <nl> - makeLinuxArmelNoflagLib ( LINUX _ ARMEL _ LIB , LINUX _ ARMEL _ NOFLAG _ LIG ) ; <nl> + makeLinuxArmNoflagLib ( LINUX _ ARMEL _ LIB , LINUX _ ARMEL _ NOFLAG _ LIG ) ; <nl> + makeLinuxArmNoflagLib ( LINUX _ ARMHF _ LIB , LINUX _ ARMHF _ NOFLAG _ LIG ) ; <nl> } <nl> - <nl> + <nl> @ Test <nl> public void testNonELF ( ) throws IOException { <nl> ELFAnalyser ahfd = ELFAnalyser . analyse ( WIN32 _ LIB . getAbsolutePath ( ) ) ; <nl> assertFalse ( ahfd . isELF ( ) ) ; <nl> } <nl> - <nl> + <nl> @ Test <nl> public void testNonArm ( ) throws IOException { <nl> ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ AMD64 _ LIB . getAbsolutePath ( ) ) ; <nl> @ @ - 42 , 24 + 44 , 28 @ @ public class ELFAnalyserTest { <nl> assertFalse ( ahfd . isArm ( ) ) ; <nl> assertTrue ( ahfd . is64Bit ( ) ) ; <nl> } <nl> - <nl> + <nl> @ Test <nl> public void testArmhf ( ) throws IOException { <nl> ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMHF _ LIB . getAbsolutePath ( ) ) ; <nl> assertTrue ( ahfd . isELF ( ) ) ; <nl> assertTrue ( ahfd . isArm ( ) ) ; <nl> assertFalse ( ahfd . is64Bit ( ) ) ; <nl> - assertFalse ( ahfd . isArmSoftFloat ( ) ) ; <nl> + assertFalse ( ahfd . isArmSoftFloatFlag ( ) ) ; <nl> + assertTrue ( ahfd . isArmHardFloatFlag ( ) ) ; <nl> + assertTrue ( ahfd . isArmEabiAapcsVfp ( ) ) ; <nl> assertTrue ( ahfd . isArmHardFloat ( ) ) ; <nl> } <nl> - <nl> + <nl> @ Test <nl> public void testArmel ( ) throws IOException { <nl> ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMEL _ LIB . getAbsolutePath ( ) ) ; <nl> assertTrue ( ahfd . isELF ( ) ) ; <nl> assertTrue ( ahfd . isArm ( ) ) ; <nl> assertFalse ( ahfd . is64Bit ( ) ) ; <nl> - assertTrue ( ahfd . isArmSoftFloat ( ) ) ; <nl> + assertTrue ( ahfd . isArmSoftFloatFlag ( ) ) ; <nl> + assertFalse ( ahfd . isArmHardFloatFlag ( ) ) ; <nl> + assertFalse ( ahfd . isArmEabiAapcsVfp ( ) ) ; <nl> assertFalse ( ahfd . isArmHardFloat ( ) ) ; <nl> } <nl> <nl> @ @ - 69 , 10 + 75 , 24 @ @ public class ELFAnalyserTest { <nl> assertTrue ( ahfd . isELF ( ) ) ; <nl> assertTrue ( ahfd . isArm ( ) ) ; <nl> assertFalse ( ahfd . is64Bit ( ) ) ; <nl> - assertTrue ( ahfd . isArmSoftFloat ( ) ) ; <nl> + assertFalse ( ahfd . isArmSoftFloatFlag ( ) ) ; <nl> + assertFalse ( ahfd . isArmHardFloatFlag ( ) ) ; <nl> + assertFalse ( ahfd . isArmEabiAapcsVfp ( ) ) ; <nl> assertFalse ( ahfd . isArmHardFloat ( ) ) ; <nl> } <nl> - <nl> + <nl> + @ Test <nl> + public void testArmhfNoflag ( ) throws IOException { <nl> + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMHF _ NOFLAG _ LIG . getAbsolutePath ( ) ) ; <nl> + assertTrue ( ahfd . isELF ( ) ) ; <nl> + assertTrue ( ahfd . isArm ( ) ) ; <nl> + assertFalse ( ahfd . is64Bit ( ) ) ; <nl> + assertFalse ( ahfd . isArmSoftFloatFlag ( ) ) ; <nl> + assertFalse ( ahfd . isArmHardFloatFlag ( ) ) ; <nl> + assertTrue ( ahfd . isArmEabiAapcsVfp ( ) ) ; <nl> + assertTrue ( ahfd . isArmHardFloat ( ) ) ; <nl> + } <nl> + <nl> @ AfterClass <nl> public static void afterClass ( ) throws IOException { <nl> LINUX _ AMD64 _ LIB . delete ( ) ; <nl> @ @ - 80 , 9 + 100 , 10 @ @ public class ELFAnalyserTest { <nl> LINUX _ ARMEL _ LIB . delete ( ) ; <nl> WIN32 _ LIB . delete ( ) ; <nl> LINUX _ ARMEL _ NOFLAG _ LIG . delete ( ) ; <nl> + LINUX _ ARMHF _ NOFLAG _ LIG . delete ( ) ; <nl> TEST _ RESOURCES . delete ( ) ; <nl> } <nl> - <nl> + <nl> private static void extractTestFile ( File outputFile ) throws IOException { <nl> String inputPath = " / com / sun / jna / data / " + outputFile . getName ( ) ; <nl> InputStream is = ELFAnalyserTest . class . getResourceAsStream ( inputPath ) ; <nl> @ @ - 100 , 10 + 121 , 10 @ @ public class ELFAnalyserTest { <nl> <nl> / / The e _ flags for elf arm binaries begin at an offset of 0x24 bytes . <nl> / / The procedure call standard is coded on the second byte . <nl> - private static void makeLinuxArmelNoflagLib ( File sourceFile , File outputFile ) throws IOException { <nl> + private static void makeLinuxArmNoflagLib ( File sourceFile , File outputFile ) throws IOException { <nl> final int POS _ ABI _ FLOAT _ BIT = ( byte ) 0x25 ; <nl> copyFile ( sourceFile , outputFile ) ; <nl> - <nl> + <nl> RandomAccessFile out = new RandomAccessFile ( outputFile , " rw " ) ; <nl> <nl> out . seek ( POS _ ABI _ FLOAT _ BIT ) ; <nl> @ @ - 111 , 7 + 132 , 7 @ @ public class ELFAnalyserTest { <nl> <nl> out . close ( ) ; <nl> } <nl> - <nl> + <nl> private static void copyFile ( File sourceFile , File outputFile ) throws IOException { <nl> InputStream inputStream = null ; <nl> OutputStream outputStream = null ; <nl> @ @ - 124 , 7 + 145 , 7 @ @ public class ELFAnalyserTest { <nl> closeSilently ( outputStream ) ; <nl> } <nl> } <nl> - <nl> + <nl> private static void copyStream ( InputStream is , OutputStream os ) throws IOException { <nl> int read ; <nl> byte [ ] buffer = new byte [ 1024 * 1024 ] ; <nl> @ @ - 132 , 7 + 153 , 7 @ @ public class ELFAnalyserTest { <nl> os . write ( buffer , 0 , read ) ; <nl> } <nl> } <nl> - <nl> + <nl> private static void closeSilently ( Closeable closeable ) { <nl> if ( closeable = = null ) { <nl> return ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index e46a394 . . c8767e1 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 44 , 6 + 44 , 7 @ @ Bug Fixes 
 < li > Change into the expanded directory and run ` bash build . sh ` . < / li > 
 < li > The resulting ` sunos - x86 . jar ` is copied back to the original build system to ` lib / native / sunos - x86 . jar ` < / li > 
 < / ol > - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 + * [ # 958 ] ( https : / / github . com / java - native - access / jna / issues / 958 ) : Update for PR 863 : Old toolchains produce binaries without hard - / softfloat markers . Rasbian is missinng the markers and the oracle JDK is also affected . For hardfloat detection now also the Arm EABI section is also considered - [ @ matthiasblaesing ] ( https : / / github . com / matthiasblaesing ) . 
 
 Breaking Changes 
 - - - - - - - - - - - - - - - - 
 diff - - git a / ant - tools - src / com / sun / jna / BuildArmSoftFloatDetector . java b / ant - tools - src / com / sun / jna / BuildArmSoftFloatDetector . java 
 index 6fa141d . . fa851e9 100644 
 - - - a / ant - tools - src / com / sun / jna / BuildArmSoftFloatDetector . java 
 + + + b / ant - tools - src / com / sun / jna / BuildArmSoftFloatDetector . java 
 @ @ - 60 , 7 + 60 , 7 @ @ public class BuildArmSoftFloatDetector { 
 / / The self . getCanonicalPath ( ) resolves the symblink to the backing 
 / / realfile and passes that to the detection routines 
 ELFAnalyser ahfd = ELFAnalyser . analyse ( self . getCanonicalPath ( ) ) ; 
 - result = ahfd . isArmSoftFloat ( ) ; 
 + result = ! ahfd . isArmHardFloat ( ) ; 
 } catch ( IOException ex ) { 
 result = false ; 
 } 
 diff - - git a / src / com / sun / jna / ELFAnalyser . java b / src / com / sun / jna / ELFAnalyser . java 
 index ba84382 . . 85f4ace 100644 
 - - - a / src / com / sun / jna / ELFAnalyser . java 
 + + + b / src / com / sun / jna / ELFAnalyser . java 
 @ @ - 1 , 15 + 1 , 25 @ @ 
 
 package com . sun . jna ; 
 
 + import java . io . ByteArrayOutputStream ; 
 import java . io . IOException ; 
 import java . io . RandomAccessFile ; 
 + import java . io . UnsupportedEncodingException ; 
 + import java . math . BigInteger ; 
 + import java . nio . Buffer ; 
 import java . nio . ByteBuffer ; 
 import java . nio . ByteOrder ; 
 + import java . util . ArrayList ; 
 import java . util . Arrays ; 
 + import java . util . Collections ; 
 + import java . util . HashMap ; 
 + import java . util . LinkedList ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 
 / * * 
 * Analyse an ELF file for platform specific attributes . 
 - * 
 + * 
 * < p > Primary use - case : Detect whether the java binary is arm hardfloat or softfloat . < / p > 
 * / 
 class ELFAnalyser { 
 @ @ - 30 , 19 + 40 , 20 @ @ class ELFAnalyser { 
 private static final int EI _ DATA _ BIG _ ENDIAN = 2 ; 
 private static final int E _ MACHINE _ ARM = 0x28 ; 
 private static final int EI _ CLASS _ 64BIT = 2 ; 
 - 
 + 
 public static ELFAnalyser analyse ( String filename ) throws IOException { 
 ELFAnalyser res = new ELFAnalyser ( filename ) ; 
 res . runDetection ( ) ; 
 return res ; 
 } 
 - 
 + 
 private final String filename ; 
 private boolean ELF = false ; 
 private boolean _ 64Bit = false ; 
 private boolean bigEndian = false ; 
 - private boolean armHardFloat = false ; 
 - private boolean armSoftFloat = false ; 
 + private boolean armHardFloatFlag = false ; 
 + private boolean armSoftFloatFlag = false ; 
 + private boolean armEabiAapcsVfp = false ; 
 private boolean arm = false ; 
 
 / * * 
 @ @ - 75 , 20 + 86 , 32 @ @ class ELFAnalyser { 
 return filename ; 
 } 
 
 + public boolean isArmHardFloat ( ) { 
 + return isArmEabiAapcsVfp ( ) | | isArmHardFloatFlag ( ) ; 
 + } 
 + 
 + / * * 
 + * @ return true if file was detected to specify , that FP parameters / result 
 + * passing conforms to AAPCS , VFP variant ( hardfloat ) 
 + * / 
 + public boolean isArmEabiAapcsVfp ( ) { 
 + return armEabiAapcsVfp ; 
 + } 
 + 
 / * * 
 * @ return true if file was detected to conform to the hardware floating - point 
 - * procedure - call standard 
 + * procedure - call standard via ELF flags 
 * / 
 - public boolean isArmHardFloat ( ) { 
 - return armHardFloat ; 
 + public boolean isArmHardFloatFlag ( ) { 
 + return armHardFloatFlag ; 
 } 
 
 / * * 
 * @ return true if file was detected to conform to the software floating - point 
 - * procedure - call standard 
 + * procedure - call standard via ELF flags 
 * / 
 - public boolean isArmSoftFloat ( ) { 
 - return armSoftFloat ; 
 + public boolean isArmSoftFloatFlag ( ) { 
 + return armSoftFloatFlag ; 
 } 
 
 / * * 
 @ @ - 123 , 26 + 146 , 423 @ @ class ELFAnalyser { 
 / / The total header size depends on the pointer size of the platform 
 / / so before the header is loaded the pointer size has to be determined 
 byte sizeIndicator = raf . readByte ( ) ; 
 + byte endianessIndicator = raf . readByte ( ) ; 
 _ 64Bit = sizeIndicator = = EI _ CLASS _ 64BIT ; 
 + bigEndian = endianessIndicator = = EI _ DATA _ BIG _ ENDIAN ; 
 raf . seek ( 0 ) ; 
 + / / header length 
 ByteBuffer headerData = ByteBuffer . allocate ( _ 64Bit ? 64 : 52 ) ; 
 raf . getChannel ( ) . read ( headerData , 0 ) ; 
 - bigEndian = headerData . get ( 5 ) = = EI _ DATA _ BIG _ ENDIAN ; 
 + 
 headerData . order ( bigEndian ? ByteOrder . BIG _ ENDIAN : ByteOrder . LITTLE _ ENDIAN ) ; 
 
 + / / e _ machine 
 arm = headerData . get ( 0x12 ) = = E _ MACHINE _ ARM ; 
 
 if ( arm ) { 
 + / / e _ flags 
 int flags = headerData . getInt ( _ 64Bit ? 0x30 : 0x24 ) ; 
 - armHardFloat = ( flags & EF _ ARM _ ABI _ FLOAT _ HARD ) = = EF _ ARM _ ABI _ FLOAT _ HARD ; 
 - armSoftFloat = ! armHardFloat ; 
 + armHardFloatFlag = ( flags & EF _ ARM _ ABI _ FLOAT _ HARD ) = = EF _ ARM _ ABI _ FLOAT _ HARD ; 
 + armSoftFloatFlag = ( flags & EF _ ARM _ ABI _ FLOAT _ SOFT ) = = EF _ ARM _ ABI _ FLOAT _ SOFT ; 
 + 
 + parseEabiAapcsVfp ( headerData , raf ) ; 
 } 
 } finally { 
 try { 
 raf . close ( ) ; 
 } catch ( IOException ex ) { 
 - / / Swallow - closing 
 + / / Swallow - closing 
 + } 
 + } 
 + } 
 + 
 + private void parseEabiAapcsVfp ( ByteBuffer headerData , RandomAccessFile raf ) throws IOException { 
 + ELFSectionHeaders sectionHeaders = new ELFSectionHeaders ( _ 64Bit , bigEndian , headerData , raf ) ; 
 + 
 + for ( ELFSectionHeaderEntry eshe : sectionHeaders . getEntries ( ) ) { 
 + if ( " . ARM . attributes " . equals ( eshe . getName ( ) ) ) { 
 + ByteBuffer armAttributesBuffer = ByteBuffer . allocate ( eshe . getSize ( ) ) ; 
 + armAttributesBuffer . order ( bigEndian ? ByteOrder . BIG _ ENDIAN : ByteOrder . LITTLE _ ENDIAN ) ; 
 + raf . getChannel ( ) . read ( armAttributesBuffer , eshe . getOffset ( ) ) ; 
 + armAttributesBuffer . rewind ( ) ; 
 + Map < Integer , Map < ArmAeabiAttributesTag , Object > > armAttributes = parseArmAttributes ( armAttributesBuffer ) ; 
 + Map < ArmAeabiAttributesTag , Object > fileAttributes = armAttributes . get ( 1 ) ; 
 + if ( fileAttributes = = null ) { 
 + continue ; 
 + } 
 + / * * 
 + * Tag _ ABI _ VFP _ args , ( = 28 ) , uleb128 
 + * 0 The user intended FP parameter / result passing to conform to AAPCS , base variant 
 + * 1 The user intended FP parameter / result passing to conform to AAPCS , VFP variant 
 + * 2 The user intended FP parameter / result passing to conform to tool chain - specific conventions 
 + * 3 Code is compatible with both the base and VFP variants ; the non - variadic functions to pass FP parameters / results 
 + * / 
 + Object abiVFPargValue = fileAttributes . get ( ArmAeabiAttributesTag . ABI _ VFP _ args ) ; 
 + if ( abiVFPargValue instanceof Integer & & ( ( Integer ) abiVFPargValue ) . equals ( 1 ) ) { 
 + armEabiAapcsVfp = true ; 
 + } else if ( abiVFPargValue instanceof BigInteger & & ( ( BigInteger ) abiVFPargValue ) . intValue ( ) = = 1 ) { 
 + armEabiAapcsVfp = true ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + static class ELFSectionHeaders { 
 + private final List < ELFSectionHeaderEntry > entries = new ArrayList < ELFSectionHeaderEntry > ( ) ; 
 + 
 + public ELFSectionHeaders ( boolean _ 64bit , boolean bigEndian , ByteBuffer headerData , RandomAccessFile raf ) throws IOException { 
 + long shoff ; 
 + int shentsize ; 
 + int shnum ; 
 + short shstrndx ; 
 + if ( _ 64bit ) { 
 + shoff = headerData . getLong ( 0x28 ) ; 
 + shentsize = headerData . getShort ( 0x3A ) ; 
 + shnum = headerData . getShort ( 0x3C ) ; 
 + shstrndx = headerData . getShort ( 0x3E ) ; 
 + } else { 
 + shoff = headerData . getInt ( 0x20 ) ; 
 + shentsize = headerData . getShort ( 0x2E ) ; 
 + shnum = headerData . getShort ( 0x30 ) ; 
 + shstrndx = headerData . getShort ( 0x32 ) ; 
 + } 
 + 
 + int tableLength = shnum * shentsize ; 
 + 
 + ByteBuffer data = ByteBuffer . allocate ( tableLength ) ; 
 + data . order ( bigEndian ? ByteOrder . BIG _ ENDIAN : ByteOrder . LITTLE _ ENDIAN ) ; 
 + raf . getChannel ( ) . read ( data , shoff ) ; 
 + 
 + for ( int i = 0 ; i < shnum ; i + + ) { 
 + data . position ( i * shentsize ) ; 
 + ByteBuffer header = data . slice ( ) ; 
 + header . order ( data . order ( ) ) ; 
 + header . limit ( shentsize ) ; 
 + entries . add ( new ELFSectionHeaderEntry ( _ 64bit , header ) ) ; 
 + } 
 + 
 + ELFSectionHeaderEntry stringTable = entries . get ( shstrndx ) ; 
 + ByteBuffer stringBuffer = ByteBuffer . allocate ( stringTable . getSize ( ) ) ; 
 + stringBuffer . order ( bigEndian ? ByteOrder . BIG _ ENDIAN : ByteOrder . LITTLE _ ENDIAN ) ; 
 + raf . getChannel ( ) . read ( stringBuffer , stringTable . getOffset ( ) ) ; 
 + stringBuffer . rewind ( ) ; 
 + 
 + ByteArrayOutputStream baos = new ByteArrayOutputStream ( 20 ) ; 
 + for ( ELFSectionHeaderEntry eshe : entries ) { 
 + baos . reset ( ) ; 
 + 
 + ( ( Buffer ) stringBuffer ) . position ( eshe . getNameOffset ( ) ) ; 
 + 
 + while ( stringBuffer . position ( ) < stringBuffer . limit ( ) ) { 
 + byte b = stringBuffer . get ( ) ; 
 + if ( b = = 0 ) { 
 + break ; 
 + } else { 
 + baos . write ( b ) ; 
 + } 
 + } 
 + 
 + eshe . setName ( baos . toString ( " ASCII " ) ) ; 
 + } 
 + } 
 + 
 + public List < ELFSectionHeaderEntry > getEntries ( ) { 
 + return entries ; 
 + } 
 + } 
 + 
 + static class ELFSectionHeaderEntry { 
 + private final int nameOffset ; 
 + private String name ; 
 + private final int type ; 
 + private final int flags ; 
 + private final int offset ; 
 + private final int size ; 
 + 
 + public ELFSectionHeaderEntry ( boolean _ 64bit , ByteBuffer sectionHeaderData ) { 
 + this . nameOffset = sectionHeaderData . getInt ( 0x0 ) ; 
 + this . type = sectionHeaderData . getInt ( 0x4 ) ; 
 + this . flags = ( int ) ( _ 64bit ? sectionHeaderData . getLong ( 0x8 ) : sectionHeaderData . getInt ( 0x8 ) ) ; 
 + this . offset = ( int ) ( _ 64bit ? sectionHeaderData . getLong ( 0x18 ) : sectionHeaderData . getInt ( 0x10 ) ) ; 
 + this . size = ( int ) ( _ 64bit ? sectionHeaderData . getLong ( 0x20 ) : sectionHeaderData . getInt ( 0x14 ) ) ; 
 + } 
 + 
 + public String getName ( ) { 
 + return name ; 
 + } 
 + 
 + public void setName ( String name ) { 
 + this . name = name ; 
 + } 
 + 
 + public int getNameOffset ( ) { 
 + return nameOffset ; 
 + } 
 + 
 + public int getType ( ) { 
 + return type ; 
 + } 
 + 
 + public int getFlags ( ) { 
 + return flags ; 
 + } 
 + 
 + public int getOffset ( ) { 
 + return offset ; 
 + } 
 + 
 + public int getSize ( ) { 
 + return size ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) { 
 + return " ELFSectionHeaderEntry { " + " nameIdx = " + nameOffset + " , name = " + name + " , type = " + type + " , flags = " + flags + " , offset = " + offset + " , size = " + size + ' } ' ; 
 + } 
 + } 
 + 
 + static class ArmAeabiAttributesTag { 
 + 
 + public enum ParameterType { 
 + UINT32 , NTBS , ULEB128 
 + } 
 + 
 + private final int value ; 
 + private final String name ; 
 + private final ParameterType parameterType ; 
 + 
 + public ArmAeabiAttributesTag ( int value , String name , ParameterType parameterType ) { 
 + this . value = value ; 
 + this . name = name ; 
 + this . parameterType = parameterType ; 
 + } 
 + 
 + public int getValue ( ) { 
 + return value ; 
 + } 
 + 
 + public String getName ( ) { 
 + return name ; 
 + } 
 + 
 + public ParameterType getParameterType ( ) { 
 + return parameterType ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) { 
 + return name + " ( " + value + " ) " ; 
 + } 
 + 
 + @ Override 
 + public int hashCode ( ) { 
 + int hash = 7 ; 
 + hash = 67 * hash + this . value ; 
 + return hash ; 
 + } 
 + 
 + @ Override 
 + public boolean equals ( Object obj ) { 
 + if ( this = = obj ) { 
 + return true ; 
 + } 
 + if ( obj = = null ) { 
 + return false ; 
 + } 
 + if ( getClass ( ) ! = obj . getClass ( ) ) { 
 + return false ; 
 + } 
 + final ArmAeabiAttributesTag other = ( ArmAeabiAttributesTag ) obj ; 
 + if ( this . value ! = other . value ) { 
 + return false ; 
 + } 
 + return true ; 
 + } 
 + 
 + private static final List < ArmAeabiAttributesTag > tags = new LinkedList < ArmAeabiAttributesTag > ( ) ; 
 + private static final Map < Integer , ArmAeabiAttributesTag > valueMap = new HashMap < Integer , ArmAeabiAttributesTag > ( ) ; 
 + private static final Map < String , ArmAeabiAttributesTag > nameMap = new HashMap < String , ArmAeabiAttributesTag > ( ) ; 
 + 
 + / / Enumerated from ARM IHI 0045E , 2 . 5 Attributes summary and history 
 + public static final ArmAeabiAttributesTag File = addTag ( 1 , " File " , ParameterType . UINT32 ) ; 
 + public static final ArmAeabiAttributesTag Section = addTag ( 2 , " Section " , ParameterType . UINT32 ) ; 
 + public static final ArmAeabiAttributesTag Symbol = addTag ( 3 , " Symbol " , ParameterType . UINT32 ) ; 
 + public static final ArmAeabiAttributesTag CPU _ raw _ name = addTag ( 4 , " CPU _ raw _ name " , ParameterType . NTBS ) ; 
 + public static final ArmAeabiAttributesTag CPU _ name = addTag ( 5 , " CPU _ name " , ParameterType . NTBS ) ; 
 + public static final ArmAeabiAttributesTag CPU _ arch = addTag ( 6 , " CPU _ arch " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag CPU _ arch _ profile = addTag ( 7 , " CPU _ arch _ profile " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ARM _ ISA _ use = addTag ( 8 , " ARM _ ISA _ use " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag THUMB _ ISA _ use = addTag ( 9 , " THUMB _ ISA _ use " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag FP _ arch = addTag ( 10 , " FP _ arch " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag WMMX _ arch = addTag ( 11 , " WMMX _ arch " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag Advanced _ SIMD _ arch = addTag ( 12 , " Advanced _ SIMD _ arch " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag PCS _ config = addTag ( 13 , " PCS _ config " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ PCS _ R9 _ use = addTag ( 14 , " ABI _ PCS _ R9 _ use " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ PCS _ RW _ data = addTag ( 15 , " ABI _ PCS _ RW _ data " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ PCS _ RO _ data = addTag ( 16 , " ABI _ PCS _ RO _ data " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ PCS _ GOT _ use = addTag ( 17 , " ABI _ PCS _ GOT _ use " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ PCS _ wchar _ t = addTag ( 18 , " ABI _ PCS _ wchar _ t " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ FP _ rounding = addTag ( 19 , " ABI _ FP _ rounding " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ FP _ denormal = addTag ( 20 , " ABI _ FP _ denormal " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ FP _ exceptions = addTag ( 21 , " ABI _ FP _ exceptions " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ FP _ user _ exceptions = addTag ( 22 , " ABI _ FP _ user _ exceptions " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ FP _ number _ model = addTag ( 23 , " ABI _ FP _ number _ model " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ align _ needed = addTag ( 24 , " ABI _ align _ needed " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ align8 _ preserved = addTag ( 25 , " ABI _ align8 _ preserved " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ enum _ size = addTag ( 26 , " ABI _ enum _ size " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ HardFP _ use = addTag ( 27 , " ABI _ HardFP _ use " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ VFP _ args = addTag ( 28 , " ABI _ VFP _ args " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ WMMX _ args = addTag ( 29 , " ABI _ WMMX _ args " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ optimization _ goals = addTag ( 30 , " ABI _ optimization _ goals " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ FP _ optimization _ goals = addTag ( 31 , " ABI _ FP _ optimization _ goals " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag compatibility = addTag ( 32 , " compatibility " , ParameterType . NTBS ) ; 
 + public static final ArmAeabiAttributesTag CPU _ unaligned _ access = addTag ( 34 , " CPU _ unaligned _ access " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag FP _ HP _ extension = addTag ( 36 , " FP _ HP _ extension " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag ABI _ FP _ 16bit _ format = addTag ( 38 , " ABI _ FP _ 16bit _ format " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag MPextension _ use = addTag ( 42 , " MPextension _ use " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag DIV _ use = addTag ( 44 , " DIV _ use " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag nodefaults = addTag ( 64 , " nodefaults " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag also _ compatible _ with = addTag ( 65 , " also _ compatible _ with " , ParameterType . NTBS ) ; 
 + public static final ArmAeabiAttributesTag conformance = addTag ( 67 , " conformance " , ParameterType . NTBS ) ; 
 + public static final ArmAeabiAttributesTag T2EE _ use = addTag ( 66 , " T2EE _ use " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag Virtualization _ use = addTag ( 68 , " Virtualization _ use " , ParameterType . ULEB128 ) ; 
 + public static final ArmAeabiAttributesTag MPextension _ use2 = addTag ( 70 , " MPextension _ use " , ParameterType . ULEB128 ) ; 
 + 
 + private static ArmAeabiAttributesTag addTag ( int value , String name , ArmAeabiAttributesTag . ParameterType type ) { 
 + ArmAeabiAttributesTag tag = new ArmAeabiAttributesTag ( value , name , type ) ; 
 + 
 + if ( ! valueMap . containsKey ( tag . getValue ( ) ) ) { 
 + valueMap . put ( tag . getValue ( ) , tag ) ; 
 + } 
 + if ( ! nameMap . containsKey ( tag . getName ( ) ) ) { 
 + nameMap . put ( tag . getName ( ) , tag ) ; 
 + } 
 + tags . add ( tag ) ; 
 + return tag ; 
 + } 
 + 
 + public static List < ArmAeabiAttributesTag > getTags ( ) { 
 + return Collections . unmodifiableList ( tags ) ; 
 + } 
 + 
 + public static ArmAeabiAttributesTag getByName ( String name ) { 
 + return nameMap . get ( name ) ; 
 + } 
 + 
 + public static ArmAeabiAttributesTag getByValue ( int value ) { 
 + if ( valueMap . containsKey ( value ) ) { 
 + return valueMap . get ( value ) ; 
 + } else { 
 + ArmAeabiAttributesTag pseudoTag = new ArmAeabiAttributesTag ( value , " Unknown " + value , getParameterType ( value ) ) ; 
 + return pseudoTag ; 
 + } 
 + } 
 + 
 + private static ArmAeabiAttributesTag . ParameterType getParameterType ( int value ) { 
 + / / ARM IHI 0045E , 2 . 2 . 6 Coding extensibility and compatibility 
 + ArmAeabiAttributesTag tag = getByValue ( value ) ; 
 + if ( tag = = null ) { 
 + if ( ( value % 2 ) = = 0 ) { 
 + return ArmAeabiAttributesTag . ParameterType . ULEB128 ; 
 + } else { 
 + return ArmAeabiAttributesTag . ParameterType . NTBS ; 
 + } 
 + } else { 
 + return tag . getParameterType ( ) ; 
 + } 
 + } 
 + } 
 + 
 + 
 + private static Map < Integer , Map < ArmAeabiAttributesTag , Object > > parseArmAttributes ( ByteBuffer bb ) { 
 + byte format = bb . get ( ) ; 
 + if ( format ! = 0x41 ) { 
 + / / Version A 
 + / / Not supported 
 + return Collections . EMPTY _ MAP ; 
 + } 
 + while ( bb . position ( ) < bb . limit ( ) ) { 
 + int posSectionStart = bb . position ( ) ; 
 + int sectionLength = bb . getInt ( ) ; 
 + if ( sectionLength < = 0 ) { 
 + / / Fail ! 
 + break ; 
 + } 
 + String vendorName = readNTBS ( bb , null ) ; 
 + if ( " aeabi " . equals ( vendorName ) ) { 
 + return parseAEABI ( bb ) ; 
 + } 
 + ( ( Buffer ) bb ) . position ( posSectionStart + sectionLength ) ; 
 + } 
 + return Collections . EMPTY _ MAP ; 
 + } 
 + 
 + private static Map < Integer , Map < ArmAeabiAttributesTag , Object > > parseAEABI ( ByteBuffer buffer ) { 
 + Map < Integer , Map < ArmAeabiAttributesTag , Object > > data = new HashMap < Integer , Map < ArmAeabiAttributesTag , Object > > ( ) ; 
 + while ( buffer . position ( ) < buffer . limit ( ) ) { 
 + int pos = buffer . position ( ) ; 
 + int subsectionTag = readULEB128 ( buffer ) . intValue ( ) ; 
 + int length = buffer . getInt ( ) ; 
 + if ( subsectionTag = = ( byte ) 1 ) { 
 + data . put ( subsectionTag , parseFileAttribute ( buffer ) ) ; 
 + } 
 + ( ( Buffer ) buffer ) . position ( pos + length ) ; 
 + } 
 + return data ; 
 + } 
 + 
 + private static Map < ArmAeabiAttributesTag , Object > parseFileAttribute ( ByteBuffer bb ) { 
 + Map < ArmAeabiAttributesTag , Object > result = new HashMap < ArmAeabiAttributesTag , Object > ( ) ; 
 + while ( bb . position ( ) < bb . limit ( ) ) { 
 + int tagValue = readULEB128 ( bb ) . intValue ( ) ; 
 + ArmAeabiAttributesTag tag = ArmAeabiAttributesTag . getByValue ( tagValue ) ; 
 + switch ( tag . getParameterType ( ) ) { 
 + case UINT32 : 
 + result . put ( tag , bb . getInt ( ) ) ; 
 + break ; 
 + case NTBS : 
 + result . put ( tag , readNTBS ( bb , null ) ) ; 
 + break ; 
 + case ULEB128 : 
 + result . put ( tag , readULEB128 ( bb ) ) ; 
 + break ; 
 + } 
 + } 
 + return result ; 
 + } 
 + 
 + private static String readNTBS ( ByteBuffer buffer , Integer position ) { 
 + if ( position ! = null ) { 
 + ( ( Buffer ) buffer ) . position ( position ) ; 
 + } 
 + int startingPos = buffer . position ( ) ; 
 + byte currentByte ; 
 + do { 
 + currentByte = buffer . get ( ) ; 
 + } while ( currentByte ! = ' \ 0 ' & & buffer . position ( ) < = buffer . limit ( ) ) ; 
 + int terminatingPosition = buffer . position ( ) ; 
 + byte [ ] data = new byte [ terminatingPosition - startingPos - 1 ] ; 
 + ( ( Buffer ) buffer ) . position ( startingPos ) ; 
 + buffer . get ( data ) ; 
 + ( ( Buffer ) buffer ) . position ( buffer . position ( ) + 1 ) ; 
 + try { 
 + return new String ( data , " ASCII " ) ; 
 + } catch ( UnsupportedEncodingException ex ) { 
 + throw new RuntimeException ( ex ) ; 
 + } 
 + } 
 + 
 + private static BigInteger readULEB128 ( ByteBuffer buffer ) { 
 + BigInteger result = BigInteger . ZERO ; 
 + int shift = 0 ; 
 + while ( true ) { 
 + byte b = buffer . get ( ) ; 
 + result = result . or ( BigInteger . valueOf ( b & 127 ) . shiftLeft ( shift ) ) ; 
 + if ( ( b & 128 ) = = 0 ) { 
 + break ; 
 } 
 + shift + = 7 ; 
 } 
 + return result ; 
 } 
 } 
 diff - - git a / src / com / sun / jna / Platform . java b / src / com / sun / jna / Platform . java 
 index 7a5a29c . . 7bd9479 100644 
 - - - a / src / com / sun / jna / Platform . java 
 + + + b / src / com / sun / jna / Platform . java 
 @ @ - 268 , 7 + 268 , 7 @ @ public final class Platform { 
 File self = new File ( " / proc / self / exe " ) ; 
 if ( self . exists ( ) ) { 
 ELFAnalyser ahfd = ELFAnalyser . analyse ( self . getCanonicalPath ( ) ) ; 
 - return ahfd . isArmSoftFloat ( ) ; 
 + return ! ahfd . isArmHardFloat ( ) ; 
 } 
 } catch ( IOException ex ) { 
 / / asume hardfloat 
 diff - - git a / test / com / sun / jna / ELFAnalyserTest . java b / test / com / sun / jna / ELFAnalyserTest . java 
 index 18c74da . . 29c47bb 100644 
 - - - a / test / com / sun / jna / ELFAnalyserTest . java 
 + + + b / test / com / sun / jna / ELFAnalyserTest . java 
 @ @ - 10 , 31 + 10 , 33 @ @ import org . junit . Test ; 
 
 
 public class ELFAnalyserTest { 
 - 
 + 
 private static final File TEST _ RESOURCES = new File ( " build / test - resources " ) ; 
 private static final File WIN32 _ LIB = new File ( TEST _ RESOURCES , " win32 - x86 - 64 . dll " ) ; 
 private static final File LINUX _ ARMEL _ LIB = new File ( TEST _ RESOURCES , " linux - armel . so " ) ; 
 private static final File LINUX _ ARMEL _ NOFLAG _ LIG = new File ( TEST _ RESOURCES , " linux - armel - noflag . so " ) ; 
 + private static final File LINUX _ ARMHF _ NOFLAG _ LIG = new File ( TEST _ RESOURCES , " linux - armhf - noflag . so " ) ; 
 private static final File LINUX _ ARMHF _ LIB = new File ( TEST _ RESOURCES , " linux - armhf . so " ) ; 
 private static final File LINUX _ AMD64 _ LIB = new File ( TEST _ RESOURCES , " linux - amd64 . so " ) ; 
 - 
 + 
 @ BeforeClass 
 public static void initClass ( ) throws IOException { 
 TEST _ RESOURCES . mkdirs ( ) ; 
 - 
 + 
 extractTestFile ( WIN32 _ LIB ) ; 
 extractTestFile ( LINUX _ ARMEL _ LIB ) ; 
 extractTestFile ( LINUX _ ARMHF _ LIB ) ; 
 extractTestFile ( LINUX _ AMD64 _ LIB ) ; 
 - makeLinuxArmelNoflagLib ( LINUX _ ARMEL _ LIB , LINUX _ ARMEL _ NOFLAG _ LIG ) ; 
 + makeLinuxArmNoflagLib ( LINUX _ ARMEL _ LIB , LINUX _ ARMEL _ NOFLAG _ LIG ) ; 
 + makeLinuxArmNoflagLib ( LINUX _ ARMHF _ LIB , LINUX _ ARMHF _ NOFLAG _ LIG ) ; 
 } 
 - 
 + 
 @ Test 
 public void testNonELF ( ) throws IOException { 
 ELFAnalyser ahfd = ELFAnalyser . analyse ( WIN32 _ LIB . getAbsolutePath ( ) ) ; 
 assertFalse ( ahfd . isELF ( ) ) ; 
 } 
 - 
 + 
 @ Test 
 public void testNonArm ( ) throws IOException { 
 ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ AMD64 _ LIB . getAbsolutePath ( ) ) ; 
 @ @ - 42 , 24 + 44 , 28 @ @ public class ELFAnalyserTest { 
 assertFalse ( ahfd . isArm ( ) ) ; 
 assertTrue ( ahfd . is64Bit ( ) ) ; 
 } 
 - 
 + 
 @ Test 
 public void testArmhf ( ) throws IOException { 
 ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMHF _ LIB . getAbsolutePath ( ) ) ; 
 assertTrue ( ahfd . isELF ( ) ) ; 
 assertTrue ( ahfd . isArm ( ) ) ; 
 assertFalse ( ahfd . is64Bit ( ) ) ; 
 - assertFalse ( ahfd . isArmSoftFloat ( ) ) ; 
 + assertFalse ( ahfd . isArmSoftFloatFlag ( ) ) ; 
 + assertTrue ( ahfd . isArmHardFloatFlag ( ) ) ; 
 + assertTrue ( ahfd . isArmEabiAapcsVfp ( ) ) ; 
 assertTrue ( ahfd . isArmHardFloat ( ) ) ; 
 } 
 - 
 + 
 @ Test 
 public void testArmel ( ) throws IOException { 
 ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMEL _ LIB . getAbsolutePath ( ) ) ; 
 assertTrue ( ahfd . isELF ( ) ) ; 
 assertTrue ( ahfd . isArm ( ) ) ; 
 assertFalse ( ahfd . is64Bit ( ) ) ; 
 - assertTrue ( ahfd . isArmSoftFloat ( ) ) ; 
 + assertTrue ( ahfd . isArmSoftFloatFlag ( ) ) ; 
 + assertFalse ( ahfd . isArmHardFloatFlag ( ) ) ; 
 + assertFalse ( ahfd . isArmEabiAapcsVfp ( ) ) ; 
 assertFalse ( ahfd . isArmHardFloat ( ) ) ; 
 } 
 
 @ @ - 69 , 10 + 75 , 24 @ @ public class ELFAnalyserTest { 
 assertTrue ( ahfd . isELF ( ) ) ; 
 assertTrue ( ahfd . isArm ( ) ) ; 
 assertFalse ( ahfd . is64Bit ( ) ) ; 
 - assertTrue ( ahfd . isArmSoftFloat ( ) ) ; 
 + assertFalse ( ahfd . isArmSoftFloatFlag ( ) ) ; 
 + assertFalse ( ahfd . isArmHardFloatFlag ( ) ) ; 
 + assertFalse ( ahfd . isArmEabiAapcsVfp ( ) ) ; 
 assertFalse ( ahfd . isArmHardFloat ( ) ) ; 
 } 
 - 
 + 
 + @ Test 
 + public void testArmhfNoflag ( ) throws IOException { 
 + ELFAnalyser ahfd = ELFAnalyser . analyse ( LINUX _ ARMHF _ NOFLAG _ LIG . getAbsolutePath ( ) ) ; 
 + assertTrue ( ahfd . isELF ( ) ) ; 
 + assertTrue ( ahfd . isArm ( ) ) ; 
 + assertFalse ( ahfd . is64Bit ( ) ) ; 
 + assertFalse ( ahfd . isArmSoftFloatFlag ( ) ) ; 
 + assertFalse ( ahfd . isArmHardFloatFlag ( ) ) ; 
 + assertTrue ( ahfd . isArmEabiAapcsVfp ( ) ) ; 
 + assertTrue ( ahfd . isArmHardFloat ( ) ) ; 
 + } 
 + 
 @ AfterClass 
 public static void afterClass ( ) throws IOException { 
 LINUX _ AMD64 _ LIB . delete ( ) ; 
 @ @ - 80 , 9 + 100 , 10 @ @ public class ELFAnalyserTest { 
 LINUX _ ARMEL _ LIB . delete ( ) ; 
 WIN32 _ LIB . delete ( ) ; 
 LINUX _ ARMEL _ NOFLAG _ LIG . delete ( ) ; 
 + LINUX _ ARMHF _ NOFLAG _ LIG . delete ( ) ; 
 TEST _ RESOURCES . delete ( ) ; 
 } 
 - 
 + 
 private static void extractTestFile ( File outputFile ) throws IOException { 
 String inputPath = " / com / sun / jna / data / " + outputFile . getName ( ) ; 
 InputStream is = ELFAnalyserTest . class . getResourceAsStream ( inputPath ) ; 
 @ @ - 100 , 10 + 121 , 10 @ @ public class ELFAnalyserTest { 
 
 / / The e _ flags for elf arm binaries begin at an offset of 0x24 bytes . 
 / / The procedure call standard is coded on the second byte . 
 - private static void makeLinuxArmelNoflagLib ( File sourceFile , File outputFile ) throws IOException { 
 + private static void makeLinuxArmNoflagLib ( File sourceFile , File outputFile ) throws IOException { 
 final int POS _ ABI _ FLOAT _ BIT = ( byte ) 0x25 ; 
 copyFile ( sourceFile , outputFile ) ; 
 - 
 + 
 RandomAccessFile out = new RandomAccessFile ( outputFile , " rw " ) ; 
 
 out . seek ( POS _ ABI _ FLOAT _ BIT ) ; 
 @ @ - 111 , 7 + 132 , 7 @ @ public class ELFAnalyserTest { 
 
 out . close ( ) ; 
 } 
 - 
 + 
 private static void copyFile ( File sourceFile , File outputFile ) throws IOException { 
 InputStream inputStream = null ; 
 OutputStream outputStream = null ; 
 @ @ - 124 , 7 + 145 , 7 @ @ public class ELFAnalyserTest { 
 closeSilently ( outputStream ) ; 
 } 
 } 
 - 
 + 
 private static void copyStream ( InputStream is , OutputStream os ) throws IOException { 
 int read ; 
 byte [ ] buffer = new byte [ 1024 * 1024 ] ; 
 @ @ - 132 , 7 + 153 , 7 @ @ public class ELFAnalyserTest { 
 os . write ( buffer , 0 , read ) ; 
 } 
 } 
 - 
 + 
 private static void closeSilently ( Closeable closeable ) { 
 if ( closeable = = null ) { 
 return ;

NEAREST DIFF:
ELIMINATEDSENTENCE
