BLEU SCORE: 0.028465126651392333

TEST MSG: Add functional description , fixes # 519
GENERATED MSG: update main page w / direct calling info

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 62beb90 . . d11fcff 100755 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 11 , 6 + 11 , 7 @ @ Features <nl> * [ # 510 ] ( https : / / github . com / java - native - access / jna / pull / 510 ) : Added ` GetCommState ` , ` GetCommTimeouts ` ` SetCommState ` and ` SetCommTimeouts ` to ` com . sun . jna . platform . win32 . Kernel32 ` . Added ` DCB ` structure to ` com . sun . jna . platform . win32 . WinBase ` - [ @ MBollig ] ( https : / / github . com / MBollig ) . <nl> * [ # 512 ] ( https : / / github . com / java - native - access / jna / pull / 512 ) : Make loading debug flags mutable [ @ lwahonen ] ( https : / / github . com / lwahonen ) . <nl> * [ # 514 ] ( https : / / github . com / java - native - access / jna / pull / 514 ) : Added ` host _ processor _ info ` to ` com . sun . jna . platform . mac . SystemB ` - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . <nl> + * [ # 519 ] ( https : / / github . com / java - native - access / jna / pull / 519 ) : Added JNA functional overview - [ @ twall ] ( https : / / github . com / twall ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> diff - - git a / README . md b / README . md <nl> index a915d4a . . f9df0fa 100644 <nl> - - - a / README . md <nl> + + + b / README . md <nl> @ @ - 11 , 7 + 11 , 7 @ @ JNA provides Java programs easy access to native shared libraries without writin <nl> <nl> JNA allows you to call directly into native functions using natural Java method invocation . The Java call looks just like the call does in native code . Most calls require no special handling or configuration ; no boilerplate or generated code is required . <nl> <nl> - JNA uses a small JNI library stub to dynamically invoke native code . The developer uses a Java interface to describe functions and structures in the target native library . This makes it quite easy to take advantage of native platform features without incurring the high overhead of configuring and building JNI code for multiple platforms . <nl> + JNA uses a small JNI library stub to dynamically invoke native code . The developer uses a Java interface to describe functions and structures in the target native library . This makes it quite easy to take advantage of native platform features without incurring the high overhead of configuring and building JNI code for multiple platforms . Read this [ more in - depth description ] ( https : / / github . com / java - native - access / jna / blob / master / www / FunctionalDescription . md ) . <nl> <nl> While significant attention has been paid to performance , correctness and ease of use take priority . <nl> <nl> @ @ - 112 , 6 + 112 , 7 @ @ Using the Library <nl> = = = = = = = = = = = = = = = = = <nl> <nl> * [ Getting Started ] ( https : / / github . com / java - native - access / jna / blob / master / www / GettingStarted . md ) <nl> + * [ Functional Description ] ( https : / / github . com / java - native - access / jna / blob / master / www / FunctionalDescription . md ) . <nl> * [ Mapping between Java and Native ] ( https : / / github . com / java - native - access / jna / blob / master / www / Mappings . md ) <nl> * [ Using Pointers and Arrays ] ( https : / / github . com / java - native - access / jna / blob / master / www / PointersAndArrays . md ) <nl> * [ Using Structures and Unions ] ( https : / / github . com / java - native - access / jna / blob / master / www / StructuresAndUnions . md ) <nl> diff - - git a / www / FunctionalDescription . md b / www / FunctionalDescription . md <nl> new file mode 100644 <nl> index 0000000 . . 44b28ab <nl> - - - / dev / null <nl> + + + b / www / FunctionalDescription . md <nl> @ @ - 0 , 0 + 1 , 65 @ @ <nl> + Functional Overview <nl> + = = = = = = = = = = = = = = = = = = = <nl> + <nl> + JNA ' s platform - specific functionality is provided by the [ libffi <nl> + library ] ( https : / / github . com / atgreen / libffi ) . Previous to the integration of <nl> + libffi into JNA ( largely performed by wmeissner ) , hand - coded assembly was used <nl> + to support linux , sparc , windows , and Mac OSX ( intel and PPC targets ) . The <nl> + libffi library provides an abstraction for calling arbitrary target addresses <nl> + with an arbitrary set of typed arguments . <nl> + <nl> + The ` ffi _ prep _ cif ( ) ` call describes how the target function wishes to be <nl> + called , while ` ffi _ call ( ) ` actually performs the call , provided the CIF <nl> + structure returned by ` ffi _ prep _ cif ( ) ` , an arguments array , and a buffer for a <nl> + return value . <nl> + <nl> + <nl> + Interface Mapping <nl> + - - - - - - - - - - - - - - - - - <nl> + When you instantiate a native library interface via ` Native . loadLibrary ( ) ` , <nl> + JNA creates a proxy which routes all method invocations through a single <nl> + ` invoke ` function in ` Library . Handler ` . This method looks up an appropriate <nl> + ` Function ` object which represents a function exported by the native library . <nl> + The proxy handler may perform some initial name translation to derive the <nl> + actual native library function name from the invoked proxy function . <nl> + <nl> + Once the ` Function ` object is found , its generic ` invoke ` method is called <nl> + with all available arguments . The proxy function signature is used to figure <nl> + out the types of the incoming arguments and the desired return type . <nl> + <nl> + The ` Function ` object performs any necessary conversion of arguments , <nl> + converting ` NativeMapped ` types into their native representation , or applying <nl> + a ` TypeMapper ` to any incoming types which have registered for ` TypeMapper ` <nl> + conversion . Similar conversion is performed on function return . By default , <nl> + all ` Structure ` objects have their Java fields copied into their native memory <nl> + before the native function call , and copied back out after the call . <nl> + <nl> + All ` Function ` invocations are routed through different native methods based <nl> + on their return type , but all those native methods are dispatched through the <nl> + same ` dispatch ` call in ` native / dispatch . c ` . That function performs any final <nl> + conversions of Java objects into native representations before building a <nl> + function call description for use by libffi . <nl> + <nl> + The libffi library requires a description of the target function ' s arguments <nl> + and return type in order to perform a platform - specific construction of the <nl> + stack suitable for the final native call invocation . Once libffi has <nl> + performed the native call ( via ` ffi _ call ( ) ` ) , it copies the result into a <nl> + buffer provided by JNA , which then converts it back into an appropriate Java <nl> + object . <nl> + <nl> + Direct Mapping <nl> + - - - - - - - - - - - - - - <nl> + JNI provides for registering a native function to be called directly when a <nl> + method marked ` native ` is called from Java . JNA constructs code stubs with <nl> + libffi for each native method registered via the ` Native . register ( ) ` call ( JNA <nl> + uses reflection to identify all methods with the ` native ` qualifier in the <nl> + direct - mapped class ) . Each stub dispatches to the function ` dispatch _ direct ` <nl> + in ` native / dispatch . c ` , and has an associated structure allocated which fully <nl> + describes the function invocation to avoid any reflection costs at runtime . <nl> + <nl> + The central ` dispatch _ direct ` function attempts to pass the Java call stack <nl> + as - is to the native function ( again , using ` ffi _ call ( ) ` from libffi ) . <nl> + The more non - primitive arguments are used , the more the direct dispatch has to <nl> + do extra work to convert Java objects into native representations on the <nl> + stack . Ideal performance is achieved by using only primitive or ` Pointer ` <nl> + arguments . <nl> \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / www / index . html b / www / index . html <nl> index e2055ab . . 3792878 100644 <nl> - - - a / www / index . html <nl> + + + b / www / index . html <nl> @ @ - 566 , 7 + 566 , 8 @ @ If you are interested in paid support , feel free to say so on one of the JNA mai <nl> < h3 > Projects Using JNA < / h3 > <nl> < ul > <nl> < li > < a href = " http : / / jruby . codehaus . org " > JRuby < / a > ( Charles Nutter ) <nl> - < li > < a href = " http : / / rococoa . dev . java . net " > Rococoa < / a > Java bindings to the Mac OS X Cocoa framework <nl> + < li > < a href = " http : / / rococoa . dev . java . net " > Rococoa < / a > Java bindings to the <nl> + Mac OS X Cocoa framework ( Duncan McGregor ) <nl> < li > < a href = " http : / / kenai . com / projects / jna - posix " / > jna - posix < / a > Common POSIX Functions for Java <nl> < li > < a href = " http : / / jnaerator . googlecode . com / " > JNAerator < / a > ( pronounced " generator " ) Autogenerates JNA mappings from C headers ( Olivier Chafik ) <nl> < li > < a href = " http : / / fmj . sf . net " > Freedom for Media in Java ( FMJ ) < / a > ( Ken Larson / Dieter Krachtus ) <nl> @ @ - 591 , 7 + 592 , 6 @ @ If you are interested in paid support , feel free to say so on one of the JNA mai <nl> < h3 > Development Tasks < / h3 > <nl> < p > The library works fairly well now , but there are a number of tasks with which we ' d appreciate help : < / p > <nl> < ul > <nl> - < li > Create a transformer using SWIG or something else that already parses C headers to auto - generate JNA interface definitions . <nl> < li > Build the < code > jnidispatch < / code > library backend on new platforms ( it should mostly work out of the box if we can just get access to the appropriate build platform ) . < / li > <nl> < li > More comprehensive documentation on using JNA , including examples of Java to native conversions of data types , function usage , and proper memory management . < / li > <nl> < li > Tips and recommended usage of JNA : Likely danger areas , failure modes , best practices , multithreading , etc . < / li >

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 62beb90 . . d11fcff 100755 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 11 , 6 + 11 , 7 @ @ Features 
 * [ # 510 ] ( https : / / github . com / java - native - access / jna / pull / 510 ) : Added ` GetCommState ` , ` GetCommTimeouts ` ` SetCommState ` and ` SetCommTimeouts ` to ` com . sun . jna . platform . win32 . Kernel32 ` . Added ` DCB ` structure to ` com . sun . jna . platform . win32 . WinBase ` - [ @ MBollig ] ( https : / / github . com / MBollig ) . 
 * [ # 512 ] ( https : / / github . com / java - native - access / jna / pull / 512 ) : Make loading debug flags mutable [ @ lwahonen ] ( https : / / github . com / lwahonen ) . 
 * [ # 514 ] ( https : / / github . com / java - native - access / jna / pull / 514 ) : Added ` host _ processor _ info ` to ` com . sun . jna . platform . mac . SystemB ` - [ @ dbwiddis ] ( https : / / github . com / dbwiddis ) . 
 + * [ # 519 ] ( https : / / github . com / java - native - access / jna / pull / 519 ) : Added JNA functional overview - [ @ twall ] ( https : / / github . com / twall ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 diff - - git a / README . md b / README . md 
 index a915d4a . . f9df0fa 100644 
 - - - a / README . md 
 + + + b / README . md 
 @ @ - 11 , 7 + 11 , 7 @ @ JNA provides Java programs easy access to native shared libraries without writin 
 
 JNA allows you to call directly into native functions using natural Java method invocation . The Java call looks just like the call does in native code . Most calls require no special handling or configuration ; no boilerplate or generated code is required . 
 
 - JNA uses a small JNI library stub to dynamically invoke native code . The developer uses a Java interface to describe functions and structures in the target native library . This makes it quite easy to take advantage of native platform features without incurring the high overhead of configuring and building JNI code for multiple platforms . 
 + JNA uses a small JNI library stub to dynamically invoke native code . The developer uses a Java interface to describe functions and structures in the target native library . This makes it quite easy to take advantage of native platform features without incurring the high overhead of configuring and building JNI code for multiple platforms . Read this [ more in - depth description ] ( https : / / github . com / java - native - access / jna / blob / master / www / FunctionalDescription . md ) . 
 
 While significant attention has been paid to performance , correctness and ease of use take priority . 
 
 @ @ - 112 , 6 + 112 , 7 @ @ Using the Library 
 = = = = = = = = = = = = = = = = = 
 
 * [ Getting Started ] ( https : / / github . com / java - native - access / jna / blob / master / www / GettingStarted . md ) 
 + * [ Functional Description ] ( https : / / github . com / java - native - access / jna / blob / master / www / FunctionalDescription . md ) . 
 * [ Mapping between Java and Native ] ( https : / / github . com / java - native - access / jna / blob / master / www / Mappings . md ) 
 * [ Using Pointers and Arrays ] ( https : / / github . com / java - native - access / jna / blob / master / www / PointersAndArrays . md ) 
 * [ Using Structures and Unions ] ( https : / / github . com / java - native - access / jna / blob / master / www / StructuresAndUnions . md ) 
 diff - - git a / www / FunctionalDescription . md b / www / FunctionalDescription . md 
 new file mode 100644 
 index 0000000 . . 44b28ab 
 - - - / dev / null 
 + + + b / www / FunctionalDescription . md 
 @ @ - 0 , 0 + 1 , 65 @ @ 
 + Functional Overview 
 + = = = = = = = = = = = = = = = = = = = 
 + 
 + JNA ' s platform - specific functionality is provided by the [ libffi 
 + library ] ( https : / / github . com / atgreen / libffi ) . Previous to the integration of 
 + libffi into JNA ( largely performed by wmeissner ) , hand - coded assembly was used 
 + to support linux , sparc , windows , and Mac OSX ( intel and PPC targets ) . The 
 + libffi library provides an abstraction for calling arbitrary target addresses 
 + with an arbitrary set of typed arguments . 
 + 
 + The ` ffi _ prep _ cif ( ) ` call describes how the target function wishes to be 
 + called , while ` ffi _ call ( ) ` actually performs the call , provided the CIF 
 + structure returned by ` ffi _ prep _ cif ( ) ` , an arguments array , and a buffer for a 
 + return value . 
 + 
 + 
 + Interface Mapping 
 + - - - - - - - - - - - - - - - - - 
 + When you instantiate a native library interface via ` Native . loadLibrary ( ) ` , 
 + JNA creates a proxy which routes all method invocations through a single 
 + ` invoke ` function in ` Library . Handler ` . This method looks up an appropriate 
 + ` Function ` object which represents a function exported by the native library . 
 + The proxy handler may perform some initial name translation to derive the 
 + actual native library function name from the invoked proxy function . 
 + 
 + Once the ` Function ` object is found , its generic ` invoke ` method is called 
 + with all available arguments . The proxy function signature is used to figure 
 + out the types of the incoming arguments and the desired return type . 
 + 
 + The ` Function ` object performs any necessary conversion of arguments , 
 + converting ` NativeMapped ` types into their native representation , or applying 
 + a ` TypeMapper ` to any incoming types which have registered for ` TypeMapper ` 
 + conversion . Similar conversion is performed on function return . By default , 
 + all ` Structure ` objects have their Java fields copied into their native memory 
 + before the native function call , and copied back out after the call . 
 + 
 + All ` Function ` invocations are routed through different native methods based 
 + on their return type , but all those native methods are dispatched through the 
 + same ` dispatch ` call in ` native / dispatch . c ` . That function performs any final 
 + conversions of Java objects into native representations before building a 
 + function call description for use by libffi . 
 + 
 + The libffi library requires a description of the target function ' s arguments 
 + and return type in order to perform a platform - specific construction of the 
 + stack suitable for the final native call invocation . Once libffi has 
 + performed the native call ( via ` ffi _ call ( ) ` ) , it copies the result into a 
 + buffer provided by JNA , which then converts it back into an appropriate Java 
 + object . 
 + 
 + Direct Mapping 
 + - - - - - - - - - - - - - - 
 + JNI provides for registering a native function to be called directly when a 
 + method marked ` native ` is called from Java . JNA constructs code stubs with 
 + libffi for each native method registered via the ` Native . register ( ) ` call ( JNA 
 + uses reflection to identify all methods with the ` native ` qualifier in the 
 + direct - mapped class ) . Each stub dispatches to the function ` dispatch _ direct ` 
 + in ` native / dispatch . c ` , and has an associated structure allocated which fully 
 + describes the function invocation to avoid any reflection costs at runtime . 
 + 
 + The central ` dispatch _ direct ` function attempts to pass the Java call stack 
 + as - is to the native function ( again , using ` ffi _ call ( ) ` from libffi ) . 
 + The more non - primitive arguments are used , the more the direct dispatch has to 
 + do extra work to convert Java objects into native representations on the 
 + stack . Ideal performance is achieved by using only primitive or ` Pointer ` 
 + arguments . 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / www / index . html b / www / index . html 
 index e2055ab . . 3792878 100644 
 - - - a / www / index . html 
 + + + b / www / index . html 
 @ @ - 566 , 7 + 566 , 8 @ @ If you are interested in paid support , feel free to say so on one of the JNA mai 
 < h3 > Projects Using JNA < / h3 > 
 < ul > 
 < li > < a href = " http : / / jruby . codehaus . org " > JRuby < / a > ( Charles Nutter ) 
 - < li > < a href = " http : / / rococoa . dev . java . net " > Rococoa < / a > Java bindings to the Mac OS X Cocoa framework 
 + < li > < a href = " http : / / rococoa . dev . java . net " > Rococoa < / a > Java bindings to the 
 + Mac OS X Cocoa framework ( Duncan McGregor ) 
 < li > < a href = " http : / / kenai . com / projects / jna - posix " / > jna - posix < / a > Common POSIX Functions for Java 
 < li > < a href = " http : / / jnaerator . googlecode . com / " > JNAerator < / a > ( pronounced " generator " ) Autogenerates JNA mappings from C headers ( Olivier Chafik ) 
 < li > < a href = " http : / / fmj . sf . net " > Freedom for Media in Java ( FMJ ) < / a > ( Ken Larson / Dieter Krachtus ) 
 @ @ - 591 , 7 + 592 , 6 @ @ If you are interested in paid support , feel free to say so on one of the JNA mai 
 < h3 > Development Tasks < / h3 > 
 < p > The library works fairly well now , but there are a number of tasks with which we ' d appreciate help : < / p > 
 < ul > 
 - < li > Create a transformer using SWIG or something else that already parses C headers to auto - generate JNA interface definitions . 
 < li > Build the < code > jnidispatch < / code > library backend on new platforms ( it should mostly work out of the box if we can just get access to the appropriate build platform ) . < / li > 
 < li > More comprehensive documentation on using JNA , including examples of Java to native conversions of data types , function usage , and proper memory management . < / li > 
 < li > Tips and recommended usage of JNA : Likely danger areas , failure modes , best practices , multithreading , etc . < / li >
