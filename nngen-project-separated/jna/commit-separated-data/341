BLEU SCORE: 0.037477767366779206

TEST MSG: Use JUnit4 and skip DXVA tests without a physical monitor .
GENERATED MSG: ensure direct library mappings used in direct tests

TEST DIFF (one line): diff - - git a / contrib / platform / nbproject / project . properties b / contrib / platform / nbproject / project . properties <nl> index 6b92f91 . . 142637c 100644 <nl> - - - a / contrib / platform / nbproject / project . properties <nl> + + + b / contrib / platform / nbproject / project . properties <nl> @ @ - 18 , 7 + 18 , 9 @ @ dist . jar = $ { dist . dir } / jna - platform . jar <nl> dist . javadoc . dir = $ { dist . dir } / javadoc <nl> file . reference . jna . jar = . . / . . / build / jna . jar <nl> file . reference . jna - test . jar = . . / . . / build / jna - test . jar <nl> - libs . junit . classpath = . . / . . / lib / junit . jar <nl> + libs . junit . classpath = \ <nl> + 	 . . / . . / lib / junit . jar : \ <nl> + 	 . . / . . / lib / hamcrest - core - 1 . 3 . jar <nl> jar . compress = false <nl> javac . classpath = \ <nl> $ { file . reference . jna . jar } : \ <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Dxva2Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Dxva2Test . java <nl> index 7e41107 . . 1243102 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Dxva2Test . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Dxva2Test . java <nl> @ @ - 16 , 7 + 16 , 9 @ @ <nl> <nl> package com . sun . jna . platform . win32 ; <nl> <nl> - import junit . framework . TestCase ; <nl> + import org . junit . * ; <nl> + import static org . junit . Assert . * ; <nl> + import static org . junit . Assume . * ; <nl> <nl> import com . sun . jna . Memory ; <nl> import com . sun . jna . platform . win32 . Dxva2 ; <nl> @ @ - 41 , 12 + 43 , 12 @ @ import com . sun . jna . platform . win32 . WinUser . HMONITOR ; <nl> / * * <nl> * @ author Martin Steiger <nl> * / <nl> - public class Dxva2Test extends TestCase { <nl> + public class Dxva2Test { <nl> <nl> 	 private int monitorCount ; <nl> 	 private PHYSICAL _ MONITOR [ ] physMons ; <nl> <nl> - @ Override <nl> + @ Before <nl> 	 public void setUp ( ) <nl> { <nl> HMONITOR hMonitor = User32 . INSTANCE . MonitorFromPoint ( new POINT ( 0 , 0 ) , WinUser . MONITOR _ DEFAULTTOPRIMARY ) ; <nl> @ @ - 56 , 15 + 58 , 17 @ @ public class Dxva2Test extends TestCase { <nl> <nl> monitorCount = pdwNumberOfPhysicalMonitors . getValue ( ) . intValue ( ) ; <nl> physMons = new PHYSICAL _ MONITOR [ monitorCount ] ; <nl> - assertTrue ( Dxva2 . INSTANCE . GetPhysicalMonitorsFromHMONITOR ( hMonitor , monitorCount , physMons ) . booleanValue ( ) ) ; <nl> + <nl> + assumeTrue ( Dxva2 . INSTANCE . GetPhysicalMonitorsFromHMONITOR ( hMonitor , monitorCount , physMons ) . booleanValue ( ) ) ; <nl> } <nl> <nl> - @ Override <nl> + @ After <nl> 	 public void tearDown ( ) <nl> { <nl> - assertTrue ( Dxva2 . INSTANCE . DestroyPhysicalMonitors ( monitorCount , physMons ) . booleanValue ( ) ) ; <nl> + Dxva2 . INSTANCE . DestroyPhysicalMonitors ( monitorCount , physMons ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetMonitorTechnologyType ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 75 , 6 + 79 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . GetMonitorTechnologyType ( hPhysicalMonitor , techType ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetMonitorCapabilities ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 86 , 6 + 91 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . GetMonitorCapabilities ( hPhysicalMonitor , caps , temps ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetMonitorBrightness ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 98 , 6 + 104 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . GetMonitorBrightness ( hPhysicalMonitor , pdwMinimumBrightness , pdwCurrentBrightness , pdwMaximumBrightness ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetMonitorContrast ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 110 , 6 + 117 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . GetMonitorContrast ( hPhysicalMonitor , pdwMinimumContrast , pdwCurrentContrast , pdwMaximumContrast ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetMonitorColorTemperature ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 120 , 6 + 128 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . GetMonitorColorTemperature ( hPhysicalMonitor , pctCurrentColorTemperature ) ; <nl> } <nl> <nl> + @ Test <nl> public void testCapabilitiesRequestAndCapabilitiesReply ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 134 , 6 + 143 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . CapabilitiesRequestAndCapabilitiesReply ( hPhysicalMonitor , pszASCIICapabilitiesString , capStrLen ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetMonitorDisplayAreaPosition ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 147 , 6 + 157 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . GetMonitorDisplayAreaPosition ( hPhysicalMonitor , ptPositionType , pdwMinimumPosition , pdwCurrentPosition , pdwMaximumPosition ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetMonitorDisplayAreaSize ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 160 , 6 + 171 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . GetMonitorDisplayAreaSize ( hPhysicalMonitor , ptSizeType , pdwMinimumSize , pdwCurrentSize , pdwMaximumSize ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetMonitorRedGreenOrBlueGain ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 173 , 6 + 185 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . GetMonitorRedGreenOrBlueGain ( hPhysicalMonitor , ptGainType , pdwMinimumGain , pdwCurrentGain , pdwMaximumGain ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetMonitorRedGreenOrBlueDrive ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> @ @ - 186 , 6 + 199 , 7 @ @ public class Dxva2Test extends TestCase { <nl> Dxva2 . INSTANCE . GetMonitorRedGreenOrBlueDrive ( hPhysicalMonitor , ptDriveType , pdwMinimumDrive , pdwCurrentDrive , pdwMaximumDrive ) ; <nl> } <nl> <nl> + @ Test <nl> public void testGetTimingReport ( ) <nl> { <nl> HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; <nl> diff - - git a / lib / hamcrest - core - 1 . 3 . jar b / lib / hamcrest - core - 1 . 3 . jar <nl> new file mode 100644 <nl> index 0000000 . . 9d5fe16 <nl> Binary files / dev / null and b / lib / hamcrest - core - 1 . 3 . jar differ
NEAREST DIFF (one line): diff - - git a / jnalib / release - notes . html b / jnalib / release - notes . html <nl> index da309cd . . ad4efcc 100755 <nl> - - - a / jnalib / release - notes . html <nl> + + + b / jnalib / release - notes . html <nl> @ @ - 5 , 7 + 5 , 8 @ @ <nl> < li > Handle String , Structure , Callback , Buffer , and primitive arrays in direct <nl> mappings . Handle NativeMapped and TypeMapper , with optimized paths for <nl> IntegerType and PointerType . <nl> - < li > Optionally throw errno / GetLastError as an exception . <nl> + < li > Optionally throw errno / GetLastError as an exception . This is preferred to <nl> + ( and more efficient than ) calling Native . getLastError ( ) . <nl> < li > Unload / delete native library unpacked from jna . jar if Native class is garbage collected . Only install shutdown hook if using the system class loader . <nl> < li > Auto - write contiguous Structure arrays when first element is written . <nl> < li > Add option to throw GetLastError / errno as an exception . <nl> diff - - git a / jnalib / src / com / sun / jna / CallbackReference . java b / jnalib / src / com / sun / jna / CallbackReference . java <nl> index aa117ec . . aaa14bf 100644 <nl> - - - a / jnalib / src / com / sun / jna / CallbackReference . java <nl> + + + b / jnalib / src / com / sun / jna / CallbackReference . java <nl> @ @ - 304 , 6 + 304 , 7 @ @ class CallbackReference extends WeakReference { <nl> return getFunctionPointer ( cb , false ) ; <nl> } <nl> <nl> + / * * Native code calls this with direct = true . * / <nl> private static Pointer getFunctionPointer ( Callback cb , boolean direct ) { <nl> Pointer fp = null ; <nl> if ( cb = = null ) { <nl> diff - - git a / jnalib / src / com / sun / jna / Native . java b / jnalib / src / com / sun / jna / Native . java <nl> index e580bf5 . . 07cd381 100644 <nl> - - - a / jnalib / src / com / sun / jna / Native . java <nl> + + + b / jnalib / src / com / sun / jna / Native . java <nl> @ @ - 355 , 15 + 355 , 7 @ @ public final class Native { <nl> Library proxy = ( Library ) <nl> Proxy . newProxyInstance ( loader , new Class [ ] { interfaceClass } , <nl> handler ) ; <nl> - synchronized ( libraries ) { <nl> - if ( ! libOptions . isEmpty ( ) ) <nl> - options . put ( interfaceClass , libOptions ) ; <nl> - if ( libOptions . containsKey ( Library . OPTION _ TYPE _ MAPPER ) ) <nl> - typeMappers . put ( interfaceClass , libOptions . get ( Library . OPTION _ TYPE _ MAPPER ) ) ; <nl> - if ( libOptions . containsKey ( Library . OPTION _ STRUCTURE _ ALIGNMENT ) ) <nl> - alignments . put ( interfaceClass , libOptions . get ( Library . OPTION _ STRUCTURE _ ALIGNMENT ) ) ; <nl> - libraries . put ( interfaceClass , new WeakReference ( proxy ) ) ; <nl> - } <nl> + cacheOptions ( interfaceClass , libOptions , proxy ) ; <nl> return proxy ; <nl> } <nl> <nl> @ @ - 401 , 13 + 393 , 19 @ @ public final class Native { <nl> if ( cls = = null ) { <nl> return null ; <nl> } <nl> + synchronized ( libraries ) { <nl> + if ( options . containsKey ( cls ) ) { <nl> + return cls ; <nl> + } <nl> + } <nl> if ( Library . class . isAssignableFrom ( cls ) ) { <nl> return cls ; <nl> } <nl> if ( Callback . class . isAssignableFrom ( cls ) ) { <nl> cls = CallbackReference . findCallbackClass ( cls ) ; <nl> } <nl> - Class fromDeclaring = findEnclosingLibraryClass ( cls . getDeclaringClass ( ) ) ; <nl> + Class declaring = cls . getDeclaringClass ( ) ; <nl> + Class fromDeclaring = findEnclosingLibraryClass ( declaring ) ; <nl> if ( fromDeclaring ! = null ) { <nl> return fromDeclaring ; <nl> } <nl> @ @ - 1286 , 6 + 1284 , 38 @ @ public final class Native { <nl> registeredClasses . put ( cls , handles ) ; <nl> registeredLibraries . put ( cls , lib ) ; <nl> } <nl> + cacheOptions ( cls , lib . getOptions ( ) , null ) ; <nl> + } <nl> + <nl> + / * * Take note of options used for a given library mapping , to facilitate <nl> + looking them up later . <nl> + * / <nl> + private static void cacheOptions ( Class cls , Map libOptions , Object proxy ) { <nl> + synchronized ( libraries ) { <nl> + if ( ! libOptions . isEmpty ( ) ) <nl> + options . put ( cls , libOptions ) ; <nl> + if ( libOptions . containsKey ( Library . OPTION _ TYPE _ MAPPER ) ) <nl> + typeMappers . put ( cls , libOptions . get ( Library . OPTION _ TYPE _ MAPPER ) ) ; <nl> + if ( libOptions . containsKey ( Library . OPTION _ STRUCTURE _ ALIGNMENT ) ) <nl> + alignments . put ( cls , libOptions . get ( Library . OPTION _ STRUCTURE _ ALIGNMENT ) ) ; <nl> + if ( proxy ! = null ) { <nl> + libraries . put ( cls , new WeakReference ( proxy ) ) ; <nl> + } <nl> + <nl> + / / If it ' s a direct mapping , AND implements a Library interface , <nl> + / / cache the library interface as well , so that any nested <nl> + / / classes get the appropriate associated options <nl> + if ( ! cls . isInterface ( ) <nl> + & & Library . class . isAssignableFrom ( cls ) ) { <nl> + Class ifaces [ ] = cls . getInterfaces ( ) ; <nl> + for ( int i = 0 ; i < ifaces . length ; i + + ) { <nl> + if ( Library . class . isAssignableFrom ( ifaces [ i ] ) ) { <nl> + cacheOptions ( ifaces [ i ] , libOptions , proxy ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> } <nl> <nl> private static native long registerMethod ( Class cls , <nl> diff - - git a / jnalib / test / com / sun / jna / CallbacksTest . java b / jnalib / test / com / sun / jna / CallbacksTest . java <nl> index e43a654 . . b9148c2 100644 <nl> - - - a / jnalib / test / com / sun / jna / CallbacksTest . java <nl> + + + b / jnalib / test / com / sun / jna / CallbacksTest . java <nl> @ @ - 725 , 61 + 725 , 6 @ @ public class CallbacksTest extends TestCase { <nl> Native . getCallbackExceptionHandler ( ) ) ; <nl> } <nl> <nl> - public static interface CallbackTestLibrary extends Library { <nl> - interface Int32Callback extends Callback { <nl> - float callback ( float arg , float arg2 ) ; <nl> - } <nl> - float callInt32Callback ( Int32Callback c , float arg , float arg2 ) ; <nl> - } <nl> - <nl> - protected CallbackTestLibrary loadCallbackTestLibrary ( Map options ) { <nl> - return ( CallbackTestLibrary ) <nl> - Native . loadLibrary ( " testlib " , CallbackTestLibrary . class , options ) ; <nl> - } <nl> - public void testCallbackTypeMappingFromLibrary ( ) throws Exception { <nl> - final DefaultTypeMapper mapper = new DefaultTypeMapper ( ) ; <nl> - Map options = new HashMap ( ) { <nl> - { put ( Library . OPTION _ TYPE _ MAPPER , mapper ) ; } <nl> - } ; <nl> - CallbackTestLibrary lib = loadCallbackTestLibrary ( options ) ; <nl> - <nl> - / / Convert java floats into native integers and back <nl> - TypeConverter converter = new TypeConverter ( ) { <nl> - public Object fromNative ( Object value , FromNativeContext context ) { <nl> - return new Float ( ( ( Integer ) value ) . intValue ( ) ) ; <nl> - } <nl> - public Class nativeType ( ) { <nl> - return Integer . class ; <nl> - } <nl> - public Object toNative ( Object value , ToNativeContext ctx ) { <nl> - return new Integer ( Math . round ( ( ( Float ) value ) . floatValue ( ) ) ) ; <nl> - } <nl> - } ; <nl> - mapper . addTypeConverter ( float . class , converter ) ; <nl> - CallbackTestLibrary . Int32Callback cb = new CallbackTestLibrary . Int32Callback ( ) { <nl> - public float callback ( float arg , float arg2 ) { <nl> - return arg + arg2 ; <nl> - } <nl> - } ; <nl> - assertEquals ( " Wrong type mapper for callback class " , mapper , <nl> - Native . getTypeMapper ( CallbackTestLibrary . Int32Callback . class ) ) ; <nl> - assertEquals ( " Wrong type mapper for callback object " , mapper , <nl> - Native . getTypeMapper ( cb . getClass ( ) ) ) ; <nl> - <nl> - assertEquals ( " Wrong type mapper used in callback invocation " , <nl> - - 2 , lib . callInt32Callback ( cb , - 1 , - 1 ) , 0 ) ; <nl> - } <nl> - <nl> - private static class TestCallback implements Callback { <nl> - public static final TypeMapper TYPE _ MAPPER = new DefaultTypeMapper ( ) ; <nl> - public void callback ( ) { } <nl> - } <nl> - public void testCallbackTypeMappingFromCallback ( ) throws Exception { <nl> - assertEquals ( " Wrong type mapper for callback class " , <nl> - TestCallback . TYPE _ MAPPER , <nl> - Native . getTypeMapper ( TestCallback . class ) ) ; <nl> - } <nl> - <nl> public void testInvokeCallback ( ) { <nl> TestLibrary . Int32CallbackX cb = lib . returnCallback ( ) ; <nl> assertNotNull ( " Callback should not be null " , cb ) ; <nl> @ @ - 829 , 6 + 774 , 68 @ @ public class CallbacksTest extends TestCase { <nl> lib . callVoidCallback ( cb ) ; <nl> } <nl> <nl> + public static interface CallbackTestLibrary extends Library { <nl> + final TypeMapper _ MAPPER = new DefaultTypeMapper ( ) { <nl> + { <nl> + / / Convert java floats into native integers and back <nl> + TypeConverter converter = new TypeConverter ( ) { <nl> + public Object fromNative ( Object value , FromNativeContext context ) { <nl> + return new Float ( ( ( Integer ) value ) . intValue ( ) ) ; <nl> + } <nl> + public Class nativeType ( ) { <nl> + return Integer . class ; <nl> + } <nl> + public Object toNative ( Object value , ToNativeContext ctx ) { <nl> + return new Integer ( Math . round ( ( ( Float ) value ) . floatValue ( ) ) ) ; <nl> + } <nl> + } ; <nl> + addTypeConverter ( float . class , converter ) ; <nl> + } <nl> + } ; <nl> + final Map _ OPTIONS = new HashMap ( ) { <nl> + { <nl> + put ( Library . OPTION _ TYPE _ MAPPER , _ MAPPER ) ; <nl> + } <nl> + } ; <nl> + interface Int32Callback extends Callback { <nl> + float callback ( float arg , float arg2 ) ; <nl> + } <nl> + float callInt32Callback ( Int32Callback c , float arg , float arg2 ) ; <nl> + } <nl> + <nl> + protected CallbackTestLibrary loadCallbackTestLibrary ( ) { <nl> + return ( CallbackTestLibrary ) <nl> + Native . loadLibrary ( " testlib " , CallbackTestLibrary . class , CallbackTestLibrary . _ OPTIONS ) ; <nl> + } <nl> + <nl> + / * * This test is here instead of NativeTest in order to facilitate running <nl> + the exact same test on a direct - mapped library without the tests <nl> + interfering with one another due to persistent / cached state in library <nl> + loading . <nl> + * / <nl> + public void testCallbackUsesTypeMapper ( ) throws Exception { <nl> + CallbackTestLibrary lib = loadCallbackTestLibrary ( ) ; <nl> + <nl> + final float [ ] ARGS = new float [ 2 ] ; <nl> + <nl> + CallbackTestLibrary . Int32Callback cb = new CallbackTestLibrary . Int32Callback ( ) { <nl> + public float callback ( float arg , float arg2 ) { <nl> + ARGS [ 0 ] = arg ; <nl> + ARGS [ 1 ] = arg2 ; <nl> + return arg + arg2 ; <nl> + } <nl> + } ; <nl> + assertEquals ( " Wrong type mapper for callback class " , lib . _ MAPPER , <nl> + Native . getTypeMapper ( CallbackTestLibrary . Int32Callback . class ) ) ; <nl> + assertEquals ( " Wrong type mapper for callback object " , lib . _ MAPPER , <nl> + Native . getTypeMapper ( cb . getClass ( ) ) ) ; <nl> + <nl> + float result = lib . callInt32Callback ( cb , - 1 , - 1 ) ; <nl> + assertEquals ( " Wrong callback argument 1 " , - 1 , ARGS [ 0 ] , 0 ) ; <nl> + assertEquals ( " Wrong callback argument 2 " , - 1 , ARGS [ 1 ] , 0 ) ; <nl> + assertEquals ( " Incorrect result of callback invocation " , - 2 , result , 0 ) ; <nl> + } <nl> + <nl> public static void main ( java . lang . String [ ] argList ) { <nl> junit . textui . TestRunner . run ( CallbacksTest . class ) ; <nl> } <nl> diff - - git a / jnalib / test / com / sun / jna / NativeTest . java b / jnalib / test / com / sun / jna / NativeTest . java <nl> index 67c43c6 . . a7edf16 100644 <nl> - - - a / jnalib / test / com / sun / jna / NativeTest . java <nl> + + + b / jnalib / test / com / sun / jna / NativeTest . java <nl> @ @ - 257 , 8 + 257 , 40 @ @ public class NativeTest extends TestCase { <nl> <nl> } <nl> <nl> - / / TODO test extraction of ( alignment | typemapper ) <nl> - / / from ( variable | options ) <nl> + public static class DirectMapping { <nl> + public static class DirectStructure extends Structure { <nl> + public int field ; <nl> + } <nl> + public static interface DirectCallback extends Callback { <nl> + void invoke ( ) ; <nl> + } <nl> + public DirectMapping ( Map options ) { <nl> + Native . register ( getClass ( ) , NativeLibrary . getInstance ( " testlib " , options ) ) ; <nl> + } <nl> + } <nl> + <nl> + public void testGetTypeMapperForDirectMapping ( ) { <nl> + final TypeMapper mapper = new DefaultTypeMapper ( ) ; <nl> + Map options = new HashMap ( ) ; <nl> + options . put ( Library . OPTION _ TYPE _ MAPPER , mapper ) ; <nl> + DirectMapping lib = new DirectMapping ( options ) ; <nl> + assertEquals ( " Wrong type mapper for direct mapping " , <nl> + mapper , Native . getTypeMapper ( DirectMapping . class ) ) ; <nl> + assertEquals ( " Wrong type mapper for direct mapping nested structure " , <nl> + mapper , Native . getTypeMapper ( DirectMapping . DirectStructure . class ) ) ; <nl> + assertEquals ( " Wrong type mapper for direct mapping nested callback " , <nl> + mapper , Native . getTypeMapper ( DirectMapping . DirectCallback . class ) ) ; <nl> + } <nl> + <nl> + private static class TestCallback implements Callback { <nl> + public static final TypeMapper TYPE _ MAPPER = new DefaultTypeMapper ( ) ; <nl> + public void callback ( ) { } <nl> + } <nl> + public void testGetTypeMapperFromCallbackInterface ( ) throws Exception { <nl> + assertEquals ( " Wrong type mapper for callback class " , <nl> + TestCallback . TYPE _ MAPPER , <nl> + Native . getTypeMapper ( TestCallback . class ) ) ; <nl> + } <nl> <nl> public static void main ( String [ ] args ) { <nl> junit . textui . TestRunner . run ( NativeTest . class ) ; <nl> diff - - git a / jnalib / test / com / sun / jna / RawCallbacksTest . java b / jnalib / test / com / sun / jna / RawCallbacksTest . java <nl> index 667998a . . 97d3515 100644 <nl> - - - a / jnalib / test / com / sun / jna / RawCallbacksTest . java <nl> + + + b / jnalib / test / com / sun / jna / RawCallbacksTest . java <nl> @ @ - 55 , 14 + 55 , 15 @ @ public class RawCallbacksTest extends CallbacksTest { <nl> lib = new RawTestLibrary ( ) ; <nl> } <nl> <nl> - public static class RawCallbackTestLibrary implements CallbackTestLibrary { <nl> - public RawCallbackTestLibrary ( Map options ) { <nl> - Native . register ( getClass ( ) , NativeLibrary . getInstance ( " testlib " , options ) ) ; <nl> - } <nl> + public static class DirectCallbackTestLibrary implements CallbackTestLibrary { <nl> public native float callInt32Callback ( Int32Callback c , float arg , float arg2 ) ; <nl> + static { <nl> + Native . register ( NativeLibrary . getInstance ( " testlib " , _ OPTIONS ) ) ; <nl> + } <nl> } <nl> - protected CallbackTestLibrary loadCallbackTestLibrary ( Map options ) { <nl> - return new RawCallbackTestLibrary ( options ) ; <nl> + <nl> + protected CallbackTestLibrary loadCallbackTestLibrary ( ) { <nl> + return new DirectCallbackTestLibrary ( ) ; <nl> } <nl> <nl> / / Currently unsupported tests

TEST DIFF:
diff - - git a / contrib / platform / nbproject / project . properties b / contrib / platform / nbproject / project . properties 
 index 6b92f91 . . 142637c 100644 
 - - - a / contrib / platform / nbproject / project . properties 
 + + + b / contrib / platform / nbproject / project . properties 
 @ @ - 18 , 7 + 18 , 9 @ @ dist . jar = $ { dist . dir } / jna - platform . jar 
 dist . javadoc . dir = $ { dist . dir } / javadoc 
 file . reference . jna . jar = . . / . . / build / jna . jar 
 file . reference . jna - test . jar = . . / . . / build / jna - test . jar 
 - libs . junit . classpath = . . / . . / lib / junit . jar 
 + libs . junit . classpath = \ 
 + 	 . . / . . / lib / junit . jar : \ 
 + 	 . . / . . / lib / hamcrest - core - 1 . 3 . jar 
 jar . compress = false 
 javac . classpath = \ 
 $ { file . reference . jna . jar } : \ 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Dxva2Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Dxva2Test . java 
 index 7e41107 . . 1243102 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Dxva2Test . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Dxva2Test . java 
 @ @ - 16 , 7 + 16 , 9 @ @ 
 
 package com . sun . jna . platform . win32 ; 
 
 - import junit . framework . TestCase ; 
 + import org . junit . * ; 
 + import static org . junit . Assert . * ; 
 + import static org . junit . Assume . * ; 
 
 import com . sun . jna . Memory ; 
 import com . sun . jna . platform . win32 . Dxva2 ; 
 @ @ - 41 , 12 + 43 , 12 @ @ import com . sun . jna . platform . win32 . WinUser . HMONITOR ; 
 / * * 
 * @ author Martin Steiger 
 * / 
 - public class Dxva2Test extends TestCase { 
 + public class Dxva2Test { 
 
 	 private int monitorCount ; 
 	 private PHYSICAL _ MONITOR [ ] physMons ; 
 
 - @ Override 
 + @ Before 
 	 public void setUp ( ) 
 { 
 HMONITOR hMonitor = User32 . INSTANCE . MonitorFromPoint ( new POINT ( 0 , 0 ) , WinUser . MONITOR _ DEFAULTTOPRIMARY ) ; 
 @ @ - 56 , 15 + 58 , 17 @ @ public class Dxva2Test extends TestCase { 
 
 monitorCount = pdwNumberOfPhysicalMonitors . getValue ( ) . intValue ( ) ; 
 physMons = new PHYSICAL _ MONITOR [ monitorCount ] ; 
 - assertTrue ( Dxva2 . INSTANCE . GetPhysicalMonitorsFromHMONITOR ( hMonitor , monitorCount , physMons ) . booleanValue ( ) ) ; 
 + 
 + assumeTrue ( Dxva2 . INSTANCE . GetPhysicalMonitorsFromHMONITOR ( hMonitor , monitorCount , physMons ) . booleanValue ( ) ) ; 
 } 
 
 - @ Override 
 + @ After 
 	 public void tearDown ( ) 
 { 
 - assertTrue ( Dxva2 . INSTANCE . DestroyPhysicalMonitors ( monitorCount , physMons ) . booleanValue ( ) ) ; 
 + Dxva2 . INSTANCE . DestroyPhysicalMonitors ( monitorCount , physMons ) ; 
 } 
 
 + @ Test 
 public void testGetMonitorTechnologyType ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 75 , 6 + 79 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . GetMonitorTechnologyType ( hPhysicalMonitor , techType ) ; 
 } 
 
 + @ Test 
 public void testGetMonitorCapabilities ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 86 , 6 + 91 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . GetMonitorCapabilities ( hPhysicalMonitor , caps , temps ) ; 
 } 
 
 + @ Test 
 public void testGetMonitorBrightness ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 98 , 6 + 104 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . GetMonitorBrightness ( hPhysicalMonitor , pdwMinimumBrightness , pdwCurrentBrightness , pdwMaximumBrightness ) ; 
 } 
 
 + @ Test 
 public void testGetMonitorContrast ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 110 , 6 + 117 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . GetMonitorContrast ( hPhysicalMonitor , pdwMinimumContrast , pdwCurrentContrast , pdwMaximumContrast ) ; 
 } 
 
 + @ Test 
 public void testGetMonitorColorTemperature ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 120 , 6 + 128 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . GetMonitorColorTemperature ( hPhysicalMonitor , pctCurrentColorTemperature ) ; 
 } 
 
 + @ Test 
 public void testCapabilitiesRequestAndCapabilitiesReply ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 134 , 6 + 143 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . CapabilitiesRequestAndCapabilitiesReply ( hPhysicalMonitor , pszASCIICapabilitiesString , capStrLen ) ; 
 } 
 
 + @ Test 
 public void testGetMonitorDisplayAreaPosition ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 147 , 6 + 157 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . GetMonitorDisplayAreaPosition ( hPhysicalMonitor , ptPositionType , pdwMinimumPosition , pdwCurrentPosition , pdwMaximumPosition ) ; 
 } 
 
 + @ Test 
 public void testGetMonitorDisplayAreaSize ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 160 , 6 + 171 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . GetMonitorDisplayAreaSize ( hPhysicalMonitor , ptSizeType , pdwMinimumSize , pdwCurrentSize , pdwMaximumSize ) ; 
 } 
 
 + @ Test 
 public void testGetMonitorRedGreenOrBlueGain ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 173 , 6 + 185 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . GetMonitorRedGreenOrBlueGain ( hPhysicalMonitor , ptGainType , pdwMinimumGain , pdwCurrentGain , pdwMaximumGain ) ; 
 } 
 
 + @ Test 
 public void testGetMonitorRedGreenOrBlueDrive ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 @ @ - 186 , 6 + 199 , 7 @ @ public class Dxva2Test extends TestCase { 
 Dxva2 . INSTANCE . GetMonitorRedGreenOrBlueDrive ( hPhysicalMonitor , ptDriveType , pdwMinimumDrive , pdwCurrentDrive , pdwMaximumDrive ) ; 
 } 
 
 + @ Test 
 public void testGetTimingReport ( ) 
 { 
 HANDLE hPhysicalMonitor = physMons [ 0 ] . hPhysicalMonitor ; 
 diff - - git a / lib / hamcrest - core - 1 . 3 . jar b / lib / hamcrest - core - 1 . 3 . jar 
 new file mode 100644 
 index 0000000 . . 9d5fe16 
 Binary files / dev / null and b / lib / hamcrest - core - 1 . 3 . jar differ

NEAREST DIFF:
diff - - git a / jnalib / release - notes . html b / jnalib / release - notes . html 
 index da309cd . . ad4efcc 100755 
 - - - a / jnalib / release - notes . html 
 + + + b / jnalib / release - notes . html 
 @ @ - 5 , 7 + 5 , 8 @ @ 
 < li > Handle String , Structure , Callback , Buffer , and primitive arrays in direct 
 mappings . Handle NativeMapped and TypeMapper , with optimized paths for 
 IntegerType and PointerType . 
 - < li > Optionally throw errno / GetLastError as an exception . 
 + < li > Optionally throw errno / GetLastError as an exception . This is preferred to 
 + ( and more efficient than ) calling Native . getLastError ( ) . 
 < li > Unload / delete native library unpacked from jna . jar if Native class is garbage collected . Only install shutdown hook if using the system class loader . 
 < li > Auto - write contiguous Structure arrays when first element is written . 
 < li > Add option to throw GetLastError / errno as an exception . 
 diff - - git a / jnalib / src / com / sun / jna / CallbackReference . java b / jnalib / src / com / sun / jna / CallbackReference . java 
 index aa117ec . . aaa14bf 100644 
 - - - a / jnalib / src / com / sun / jna / CallbackReference . java 
 + + + b / jnalib / src / com / sun / jna / CallbackReference . java 
 @ @ - 304 , 6 + 304 , 7 @ @ class CallbackReference extends WeakReference { 
 return getFunctionPointer ( cb , false ) ; 
 } 
 
 + / * * Native code calls this with direct = true . * / 
 private static Pointer getFunctionPointer ( Callback cb , boolean direct ) { 
 Pointer fp = null ; 
 if ( cb = = null ) { 
 diff - - git a / jnalib / src / com / sun / jna / Native . java b / jnalib / src / com / sun / jna / Native . java 
 index e580bf5 . . 07cd381 100644 
 - - - a / jnalib / src / com / sun / jna / Native . java 
 + + + b / jnalib / src / com / sun / jna / Native . java 
 @ @ - 355 , 15 + 355 , 7 @ @ public final class Native { 
 Library proxy = ( Library ) 
 Proxy . newProxyInstance ( loader , new Class [ ] { interfaceClass } , 
 handler ) ; 
 - synchronized ( libraries ) { 
 - if ( ! libOptions . isEmpty ( ) ) 
 - options . put ( interfaceClass , libOptions ) ; 
 - if ( libOptions . containsKey ( Library . OPTION _ TYPE _ MAPPER ) ) 
 - typeMappers . put ( interfaceClass , libOptions . get ( Library . OPTION _ TYPE _ MAPPER ) ) ; 
 - if ( libOptions . containsKey ( Library . OPTION _ STRUCTURE _ ALIGNMENT ) ) 
 - alignments . put ( interfaceClass , libOptions . get ( Library . OPTION _ STRUCTURE _ ALIGNMENT ) ) ; 
 - libraries . put ( interfaceClass , new WeakReference ( proxy ) ) ; 
 - } 
 + cacheOptions ( interfaceClass , libOptions , proxy ) ; 
 return proxy ; 
 } 
 
 @ @ - 401 , 13 + 393 , 19 @ @ public final class Native { 
 if ( cls = = null ) { 
 return null ; 
 } 
 + synchronized ( libraries ) { 
 + if ( options . containsKey ( cls ) ) { 
 + return cls ; 
 + } 
 + } 
 if ( Library . class . isAssignableFrom ( cls ) ) { 
 return cls ; 
 } 
 if ( Callback . class . isAssignableFrom ( cls ) ) { 
 cls = CallbackReference . findCallbackClass ( cls ) ; 
 } 
 - Class fromDeclaring = findEnclosingLibraryClass ( cls . getDeclaringClass ( ) ) ; 
 + Class declaring = cls . getDeclaringClass ( ) ; 
 + Class fromDeclaring = findEnclosingLibraryClass ( declaring ) ; 
 if ( fromDeclaring ! = null ) { 
 return fromDeclaring ; 
 } 
 @ @ - 1286 , 6 + 1284 , 38 @ @ public final class Native { 
 registeredClasses . put ( cls , handles ) ; 
 registeredLibraries . put ( cls , lib ) ; 
 } 
 + cacheOptions ( cls , lib . getOptions ( ) , null ) ; 
 + } 
 + 
 + / * * Take note of options used for a given library mapping , to facilitate 
 + looking them up later . 
 + * / 
 + private static void cacheOptions ( Class cls , Map libOptions , Object proxy ) { 
 + synchronized ( libraries ) { 
 + if ( ! libOptions . isEmpty ( ) ) 
 + options . put ( cls , libOptions ) ; 
 + if ( libOptions . containsKey ( Library . OPTION _ TYPE _ MAPPER ) ) 
 + typeMappers . put ( cls , libOptions . get ( Library . OPTION _ TYPE _ MAPPER ) ) ; 
 + if ( libOptions . containsKey ( Library . OPTION _ STRUCTURE _ ALIGNMENT ) ) 
 + alignments . put ( cls , libOptions . get ( Library . OPTION _ STRUCTURE _ ALIGNMENT ) ) ; 
 + if ( proxy ! = null ) { 
 + libraries . put ( cls , new WeakReference ( proxy ) ) ; 
 + } 
 + 
 + / / If it ' s a direct mapping , AND implements a Library interface , 
 + / / cache the library interface as well , so that any nested 
 + / / classes get the appropriate associated options 
 + if ( ! cls . isInterface ( ) 
 + & & Library . class . isAssignableFrom ( cls ) ) { 
 + Class ifaces [ ] = cls . getInterfaces ( ) ; 
 + for ( int i = 0 ; i < ifaces . length ; i + + ) { 
 + if ( Library . class . isAssignableFrom ( ifaces [ i ] ) ) { 
 + cacheOptions ( ifaces [ i ] , libOptions , proxy ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 } 
 
 private static native long registerMethod ( Class cls , 
 diff - - git a / jnalib / test / com / sun / jna / CallbacksTest . java b / jnalib / test / com / sun / jna / CallbacksTest . java 
 index e43a654 . . b9148c2 100644 
 - - - a / jnalib / test / com / sun / jna / CallbacksTest . java 
 + + + b / jnalib / test / com / sun / jna / CallbacksTest . java 
 @ @ - 725 , 61 + 725 , 6 @ @ public class CallbacksTest extends TestCase { 
 Native . getCallbackExceptionHandler ( ) ) ; 
 } 
 
 - public static interface CallbackTestLibrary extends Library { 
 - interface Int32Callback extends Callback { 
 - float callback ( float arg , float arg2 ) ; 
 - } 
 - float callInt32Callback ( Int32Callback c , float arg , float arg2 ) ; 
 - } 
 - 
 - protected CallbackTestLibrary loadCallbackTestLibrary ( Map options ) { 
 - return ( CallbackTestLibrary ) 
 - Native . loadLibrary ( " testlib " , CallbackTestLibrary . class , options ) ; 
 - } 
 - public void testCallbackTypeMappingFromLibrary ( ) throws Exception { 
 - final DefaultTypeMapper mapper = new DefaultTypeMapper ( ) ; 
 - Map options = new HashMap ( ) { 
 - { put ( Library . OPTION _ TYPE _ MAPPER , mapper ) ; } 
 - } ; 
 - CallbackTestLibrary lib = loadCallbackTestLibrary ( options ) ; 
 - 
 - / / Convert java floats into native integers and back 
 - TypeConverter converter = new TypeConverter ( ) { 
 - public Object fromNative ( Object value , FromNativeContext context ) { 
 - return new Float ( ( ( Integer ) value ) . intValue ( ) ) ; 
 - } 
 - public Class nativeType ( ) { 
 - return Integer . class ; 
 - } 
 - public Object toNative ( Object value , ToNativeContext ctx ) { 
 - return new Integer ( Math . round ( ( ( Float ) value ) . floatValue ( ) ) ) ; 
 - } 
 - } ; 
 - mapper . addTypeConverter ( float . class , converter ) ; 
 - CallbackTestLibrary . Int32Callback cb = new CallbackTestLibrary . Int32Callback ( ) { 
 - public float callback ( float arg , float arg2 ) { 
 - return arg + arg2 ; 
 - } 
 - } ; 
 - assertEquals ( " Wrong type mapper for callback class " , mapper , 
 - Native . getTypeMapper ( CallbackTestLibrary . Int32Callback . class ) ) ; 
 - assertEquals ( " Wrong type mapper for callback object " , mapper , 
 - Native . getTypeMapper ( cb . getClass ( ) ) ) ; 
 - 
 - assertEquals ( " Wrong type mapper used in callback invocation " , 
 - - 2 , lib . callInt32Callback ( cb , - 1 , - 1 ) , 0 ) ; 
 - } 
 - 
 - private static class TestCallback implements Callback { 
 - public static final TypeMapper TYPE _ MAPPER = new DefaultTypeMapper ( ) ; 
 - public void callback ( ) { } 
 - } 
 - public void testCallbackTypeMappingFromCallback ( ) throws Exception { 
 - assertEquals ( " Wrong type mapper for callback class " , 
 - TestCallback . TYPE _ MAPPER , 
 - Native . getTypeMapper ( TestCallback . class ) ) ; 
 - } 
 - 
 public void testInvokeCallback ( ) { 
 TestLibrary . Int32CallbackX cb = lib . returnCallback ( ) ; 
 assertNotNull ( " Callback should not be null " , cb ) ; 
 @ @ - 829 , 6 + 774 , 68 @ @ public class CallbacksTest extends TestCase { 
 lib . callVoidCallback ( cb ) ; 
 } 
 
 + public static interface CallbackTestLibrary extends Library { 
 + final TypeMapper _ MAPPER = new DefaultTypeMapper ( ) { 
 + { 
 + / / Convert java floats into native integers and back 
 + TypeConverter converter = new TypeConverter ( ) { 
 + public Object fromNative ( Object value , FromNativeContext context ) { 
 + return new Float ( ( ( Integer ) value ) . intValue ( ) ) ; 
 + } 
 + public Class nativeType ( ) { 
 + return Integer . class ; 
 + } 
 + public Object toNative ( Object value , ToNativeContext ctx ) { 
 + return new Integer ( Math . round ( ( ( Float ) value ) . floatValue ( ) ) ) ; 
 + } 
 + } ; 
 + addTypeConverter ( float . class , converter ) ; 
 + } 
 + } ; 
 + final Map _ OPTIONS = new HashMap ( ) { 
 + { 
 + put ( Library . OPTION _ TYPE _ MAPPER , _ MAPPER ) ; 
 + } 
 + } ; 
 + interface Int32Callback extends Callback { 
 + float callback ( float arg , float arg2 ) ; 
 + } 
 + float callInt32Callback ( Int32Callback c , float arg , float arg2 ) ; 
 + } 
 + 
 + protected CallbackTestLibrary loadCallbackTestLibrary ( ) { 
 + return ( CallbackTestLibrary ) 
 + Native . loadLibrary ( " testlib " , CallbackTestLibrary . class , CallbackTestLibrary . _ OPTIONS ) ; 
 + } 
 + 
 + / * * This test is here instead of NativeTest in order to facilitate running 
 + the exact same test on a direct - mapped library without the tests 
 + interfering with one another due to persistent / cached state in library 
 + loading . 
 + * / 
 + public void testCallbackUsesTypeMapper ( ) throws Exception { 
 + CallbackTestLibrary lib = loadCallbackTestLibrary ( ) ; 
 + 
 + final float [ ] ARGS = new float [ 2 ] ; 
 + 
 + CallbackTestLibrary . Int32Callback cb = new CallbackTestLibrary . Int32Callback ( ) { 
 + public float callback ( float arg , float arg2 ) { 
 + ARGS [ 0 ] = arg ; 
 + ARGS [ 1 ] = arg2 ; 
 + return arg + arg2 ; 
 + } 
 + } ; 
 + assertEquals ( " Wrong type mapper for callback class " , lib . _ MAPPER , 
 + Native . getTypeMapper ( CallbackTestLibrary . Int32Callback . class ) ) ; 
 + assertEquals ( " Wrong type mapper for callback object " , lib . _ MAPPER , 
 + Native . getTypeMapper ( cb . getClass ( ) ) ) ; 
 + 
 + float result = lib . callInt32Callback ( cb , - 1 , - 1 ) ; 
 + assertEquals ( " Wrong callback argument 1 " , - 1 , ARGS [ 0 ] , 0 ) ; 
 + assertEquals ( " Wrong callback argument 2 " , - 1 , ARGS [ 1 ] , 0 ) ; 
 + assertEquals ( " Incorrect result of callback invocation " , - 2 , result , 0 ) ; 
 + } 
 + 
 public static void main ( java . lang . String [ ] argList ) { 
 junit . textui . TestRunner . run ( CallbacksTest . class ) ; 
 } 
 diff - - git a / jnalib / test / com / sun / jna / NativeTest . java b / jnalib / test / com / sun / jna / NativeTest . java 
 index 67c43c6 . . a7edf16 100644 
 - - - a / jnalib / test / com / sun / jna / NativeTest . java 
 + + + b / jnalib / test / com / sun / jna / NativeTest . java 
 @ @ - 257 , 8 + 257 , 40 @ @ public class NativeTest extends TestCase { 
 
 } 
 
 - / / TODO test extraction of ( alignment | typemapper ) 
 - / / from ( variable | options ) 
 + public static class DirectMapping { 
 + public static class DirectStructure extends Structure { 
 + public int field ; 
 + } 
 + public static interface DirectCallback extends Callback { 
 + void invoke ( ) ; 
 + } 
 + public DirectMapping ( Map options ) { 
 + Native . register ( getClass ( ) , NativeLibrary . getInstance ( " testlib " , options ) ) ; 
 + } 
 + } 
 + 
 + public void testGetTypeMapperForDirectMapping ( ) { 
 + final TypeMapper mapper = new DefaultTypeMapper ( ) ; 
 + Map options = new HashMap ( ) ; 
 + options . put ( Library . OPTION _ TYPE _ MAPPER , mapper ) ; 
 + DirectMapping lib = new DirectMapping ( options ) ; 
 + assertEquals ( " Wrong type mapper for direct mapping " , 
 + mapper , Native . getTypeMapper ( DirectMapping . class ) ) ; 
 + assertEquals ( " Wrong type mapper for direct mapping nested structure " , 
 + mapper , Native . getTypeMapper ( DirectMapping . DirectStructure . class ) ) ; 
 + assertEquals ( " Wrong type mapper for direct mapping nested callback " , 
 + mapper , Native . getTypeMapper ( DirectMapping . DirectCallback . class ) ) ; 
 + } 
 + 
 + private static class TestCallback implements Callback { 
 + public static final TypeMapper TYPE _ MAPPER = new DefaultTypeMapper ( ) ; 
 + public void callback ( ) { } 
 + } 
 + public void testGetTypeMapperFromCallbackInterface ( ) throws Exception { 
 + assertEquals ( " Wrong type mapper for callback class " , 
 + TestCallback . TYPE _ MAPPER , 
 + Native . getTypeMapper ( TestCallback . class ) ) ; 
 + } 
 
 public static void main ( String [ ] args ) { 
 junit . textui . TestRunner . run ( NativeTest . class ) ; 
 diff - - git a / jnalib / test / com / sun / jna / RawCallbacksTest . java b / jnalib / test / com / sun / jna / RawCallbacksTest . java 
 index 667998a . . 97d3515 100644 
 - - - a / jnalib / test / com / sun / jna / RawCallbacksTest . java 
 + + + b / jnalib / test / com / sun / jna / RawCallbacksTest . java 
 @ @ - 55 , 14 + 55 , 15 @ @ public class RawCallbacksTest extends CallbacksTest { 
 lib = new RawTestLibrary ( ) ; 
 } 
 
 - public static class RawCallbackTestLibrary implements CallbackTestLibrary { 
 - public RawCallbackTestLibrary ( Map options ) { 
 - Native . register ( getClass ( ) , NativeLibrary . getInstance ( " testlib " , options ) ) ; 
 - } 
 + public static class DirectCallbackTestLibrary implements CallbackTestLibrary { 
 public native float callInt32Callback ( Int32Callback c , float arg , float arg2 ) ; 
 + static { 
 + Native . register ( NativeLibrary . getInstance ( " testlib " , _ OPTIONS ) ) ; 
 + } 
 } 
 - protected CallbackTestLibrary loadCallbackTestLibrary ( Map options ) { 
 - return new RawCallbackTestLibrary ( options ) ; 
 + 
 + protected CallbackTestLibrary loadCallbackTestLibrary ( ) { 
 + return new DirectCallbackTestLibrary ( ) ; 
 } 
 
 / / Currently unsupported tests
