BLEU SCORE: 0.00863611899608393

TEST MSG: Move callback invocation in c . s . j . p . w . C . util . CallbackProxy into calling thread
GENERATED MSG: Make ( Un ) marshalling context sensitive

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / CallbackProxy . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / CallbackProxy . java <nl> index 7e0316b . . 4185e6b 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / CallbackProxy . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / CallbackProxy . java <nl> @ @ - 12 , 15 + 12 , 11 @ @ <nl> * / <nl> package com . sun . jna . platform . win32 . COM . util ; <nl> <nl> - import java . lang . Thread . UncaughtExceptionHandler ; <nl> import java . lang . reflect . Method ; <nl> import java . util . ArrayList ; <nl> import java . util . HashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> - import java . util . concurrent . ExecutorService ; <nl> - import java . util . concurrent . Executors ; <nl> - import java . util . concurrent . ThreadFactory ; <nl> <nl> import com . sun . jna . Pointer ; <nl> import com . sun . jna . WString ; <nl> @ @ - 61 , 20 + 57 , 6 @ @ public class CallbackProxy implements IDispatchCallback { <nl> 	 	 this . listenedToRiid = this . createRIID ( comEventCallbackInterface ) ; <nl> 	 	 this . dsipIdMap = this . createDispIdMap ( comEventCallbackInterface ) ; <nl> 	 	 this . dispatchListener = new DispatchListener ( this ) ; <nl> - 	 	 this . executorService = Executors . newSingleThreadExecutor ( new ThreadFactory ( ) { <nl> - 	 	 	 @ Override <nl> - 	 	 	 public Thread newThread ( Runnable r ) { <nl> - 	 	 	 	 Thread thread = new Thread ( r , " COM Event Callback executor " ) ; <nl> - 	 	 	 	 thread . setDaemon ( true ) ; <nl> - 	 	 	 	 thread . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) { <nl> - 	 	 	 	 	 @ Override <nl> - 	 	 	 	 	 public void uncaughtException ( Thread t , Throwable e ) { <nl> - 	 	 	 	 	 	 CallbackProxy . this . factory . comThread . uncaughtExceptionHandler . uncaughtException ( t , e ) ; <nl> - 	 } <nl> - 	 	 	 	 } ) ; <nl> - 	 	 	 	 return thread ; <nl> - 	 	 	 } <nl> - 	 	 } ) ; <nl> 	 } <nl> <nl> 	 Factory factory ; <nl> @ @ - 83 , 7 + 65 , 6 @ @ public class CallbackProxy implements IDispatchCallback { <nl> 	 REFIID listenedToRiid ; <nl> 	 public DispatchListener dispatchListener ; <nl> 	 Map < DISPID , Method > dsipIdMap ; <nl> - 	 ExecutorService executorService ; <nl> <nl> 	 REFIID createRIID ( Class < ? > comEventCallbackInterface ) { <nl> 	 	 ComInterface comInterfaceAnnotation = comEventCallbackInterface . getAnnotation ( ComInterface . class ) ; <nl> @ @ - 138 , 19 + 119 , 23 @ @ public class CallbackProxy implements IDispatchCallback { <nl> return ; <nl> } <nl> <nl> - / / decode arguments <nl> - / / must decode them on this thread , and create a proxy for any COM objects ( IDispatch ) <nl> - / / this will AddRef on the COM object so that it is not cleaned up before we can use it <nl> - / / on the thread that does the java callback . <nl> + / / Arguments are converted to the JAVA side and IDispatch Interfaces <nl> + / / are wrapped into an ProxyObject if so requested . <nl> + / / <nl> + / / Out - Parameter need to be specified as VARIANT , VARIANT args are <nl> + / / not converted , so COM memory allocation rules apply . <nl> final Class < ? > [ ] params = eventMethod . getParameterTypes ( ) ; <nl> List < Object > rjargs = new ArrayList < Object > ( ) ; <nl> if ( pDispParams . cArgs . intValue ( ) > 0 ) { <nl> VariantArg vargs = pDispParams . rgvarg ; <nl> vargs . setArraySize ( pDispParams . cArgs . intValue ( ) ) ; <nl> for ( int i = 0 ; i < vargs . variantArg . length ; i + + ) { <nl> + Class targetClass = params [ vargs . variantArg . length - 1 - i ] ; <nl> Variant . VARIANT varg = vargs . variantArg [ i ] ; <nl> - Object jarg = Convert . toJavaObject ( varg , params [ vargs . variantArg . length - 1 - i ] ) ; <nl> + Object jarg = Convert . toJavaObject ( varg , targetClass ) ; <nl> if ( jarg instanceof IDispatch ) { <nl> + / / If a dispatch is returned try to wrap it into a proxy <nl> + / / helper if the target is ComInterface annotated <nl> IDispatch dispatch = ( IDispatch ) jarg ; <nl> / / get raw IUnknown interface <nl> PointerByReference ppvObject = new PointerByReference ( ) ; <nl> @ @ - 158 , 56 + 143 , 38 @ @ public class CallbackProxy implements IDispatchCallback { <nl> dispatch . QueryInterface ( new REFIID ( iid ) , ppvObject ) ; <nl> Unknown rawUnk = new Unknown ( ppvObject . getValue ( ) ) ; <nl> 	 	 	 	 	 long unknownId = Pointer . nativeValue ( rawUnk . getPointer ( ) ) ; <nl> - int n = rawUnk . Release ( ) ; <nl> - / / Note : unlike in other places , there is currently no COM ref already added for this pointer <nl> IUnknown unk = CallbackProxy . this . factory . createProxy ( IUnknown . class , unknownId , dispatch ) ; <nl> - rjargs . add ( unk ) ; <nl> + if ( targetClass . getAnnotation ( ComInterface . class ) ! = null ) { <nl> + rjargs . add ( unk . queryInterface ( targetClass ) ) ; <nl> + } else { <nl> + rjargs . add ( unk ) ; <nl> + } <nl> } else { <nl> rjargs . add ( jarg ) ; <nl> } <nl> } <nl> } <nl> - final List < Object > jargs = new ArrayList < Object > ( rjargs ) ; <nl> - Runnable invokation = new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - / / need to convert arguments maybe <nl> - List < Object > margs = new ArrayList < Object > ( ) ; <nl> - try { <nl> - / / Reverse order from calling convention <nl> - int lastParamIdx = eventMethod . getParameterTypes ( ) . length - 1 ; <nl> - for ( int i = lastParamIdx ; i > = 0 ; i - - ) { <nl> - Class < ? > paramType = params [ lastParamIdx - i ] ; <nl> - Object jobj = jargs . get ( i ) ; <nl> - if ( jobj ! = null & & paramType . getAnnotation ( ComInterface . class ) ! = null ) { <nl> - if ( jobj instanceof IUnknown ) { <nl> - IUnknown unk = ( IUnknown ) jobj ; <nl> - Object mobj = unk . queryInterface ( paramType ) ; <nl> - margs . add ( mobj ) ; <nl> - } else { <nl> - throw new RuntimeException ( " Cannot convert argument " + jobj . getClass ( ) <nl> - + " to ComInterface " + paramType ) ; <nl> - } <nl> - } else { <nl> - margs . add ( jobj ) ; <nl> - } <nl> - } <nl> - eventMethod . invoke ( comEventCallbackListener , margs . toArray ( ) ) ; <nl> - } catch ( Exception e ) { <nl> - List < String > decodedClassNames = new ArrayList < String > ( margs . size ( ) ) ; <nl> - for ( Object o : margs ) { <nl> - if ( o = = null ) { <nl> - decodedClassNames . add ( " NULL " ) ; <nl> - } else { <nl> - decodedClassNames . add ( o . getClass ( ) . getName ( ) ) ; <nl> - } <nl> - } <nl> - CallbackProxy . this . comEventCallbackListener . errorReceivingCallbackEvent ( <nl> - " Exception invoking method " + eventMethod + " supplied : " + decodedClassNames . toString ( ) , e ) ; <nl> + <nl> + List < Object > margs = new ArrayList < Object > ( ) ; <nl> + try { <nl> + / / Reverse order from calling convention <nl> + int lastParamIdx = eventMethod . getParameterTypes ( ) . length - 1 ; <nl> + for ( int i = lastParamIdx ; i > = 0 ; i - - ) { <nl> + margs . add ( rjargs . get ( i ) ) ; <nl> + } <nl> + eventMethod . invoke ( comEventCallbackListener , margs . toArray ( ) ) ; <nl> + } catch ( Exception e ) { <nl> + List < String > decodedClassNames = new ArrayList < String > ( margs . size ( ) ) ; <nl> + for ( Object o : margs ) { <nl> + if ( o = = null ) { <nl> + decodedClassNames . add ( " NULL " ) ; <nl> + } else { <nl> + decodedClassNames . add ( o . getClass ( ) . getName ( ) ) ; <nl> } <nl> } <nl> - } ; <nl> - 	 	 this . executorService . execute ( invokation ) ; <nl> + CallbackProxy . this . comEventCallbackListener . errorReceivingCallbackEvent ( <nl> + " Exception invoking method " + eventMethod + " supplied : " + decodedClassNames . toString ( ) , e ) ; <nl> + } <nl> } <nl> <nl> 	 @ Override <nl> @ @ - 237 , 7 + 204 , 13 @ @ public class CallbackProxy implements IDispatchCallback { <nl> 	 	 	 DISPPARAMS . ByReference pDispParams , VARIANT . ByReference pVarResult , EXCEPINFO . ByReference pExcepInfo , <nl> 	 	 	 IntByReference puArgErr ) { <nl> <nl> - 	 	 this . invokeOnThread ( dispIdMember , riid , lcid , wFlags , pDispParams ) ; <nl> + assert ( ! ComThread . getCurrentThreadIsCOM ( ) ) : " Assumption about COM threading broken . " ; <nl> + ComThread . setCurrentThreadIsCOM ( true ) ; <nl> + try { <nl> + this . invokeOnThread ( dispIdMember , riid , lcid , wFlags , pDispParams ) ; <nl> + } finally { <nl> + ComThread . setCurrentThreadIsCOM ( false ) ; <nl> + } <nl> <nl> 	 	 return WinError . S _ OK ; <nl> 	 } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ComThread . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ComThread . java <nl> index 3ac5c13 . . 07e6405 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ComThread . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ComThread . java <nl> @ @ - 26 , 7 + 26 , 6 @ @ import com . sun . jna . platform . win32 . WinNT ; <nl> import com . sun . jna . platform . win32 . COM . COMUtils ; <nl> <nl> public class ComThread { <nl> - <nl> 	 ExecutorService executor ; <nl> 	 Runnable firstTask ; <nl> 	 boolean requiresInitialisation ; <nl> @ @ - 44 , 6 + 43 , 8 @ @ public class ComThread { <nl> 	 	 this . firstTask = new Runnable ( ) { <nl> 	 	 	 @ Override <nl> 	 	 	 public void run ( ) { <nl> + / / By definition this is a COM thread <nl> + ComThread . setCurrentThreadIsCOM ( true ) ; <nl> 	 	 	 	 try { <nl> 	 	 	 	 	 / / If we do not use COINIT _ MULTITHREADED , it is necessary to have <nl> 	 	 	 	 	 / / a message loop see - <nl> @ @ - 119 , 11 + 120 , 38 @ @ public class ComThread { <nl> 	 	 } <nl> 	 } <nl> <nl> + / / The currentThreadIsCOM is used if wrapper are used in a callback <nl> + / / the callback is called in a new thread by the JNA runtime . As the <nl> + / / call comes from COM it is asumed , that the thread is correctly <nl> + / / initialized and can be used for COM calls ( see MTA assumption above ) <nl> + private static ThreadLocal < Boolean > currentThreadIsCOM = new ThreadLocal < Boolean > ( ) ; <nl> + <nl> + static void setCurrentThreadIsCOM ( boolean isCOM ) { <nl> + currentThreadIsCOM . set ( isCOM ) ; <nl> + } <nl> + <nl> + static boolean getCurrentThreadIsCOM ( ) { <nl> + Boolean res = currentThreadIsCOM . get ( ) ; <nl> + if ( res = = null ) { <nl> + return false ; <nl> + } else { <nl> + return currentThreadIsCOM . get ( ) ; <nl> + } <nl> + } <nl> + <nl> 	 public < T > T execute ( Callable < T > task ) throws TimeoutException , InterruptedException , ExecutionException { <nl> - 	 	 if ( this . requiresInitialisation ) { <nl> - 	 	 	 executor . execute ( firstTask ) ; <nl> - 	 	 } <nl> - 	 	 return executor . submit ( task ) . get ( this . timeoutMilliseconds , TimeUnit . MILLISECONDS ) ; <nl> + if ( getCurrentThreadIsCOM ( ) ) { <nl> + try { <nl> + return task . call ( ) ; <nl> + } catch ( Exception ex ) { <nl> + throw new ExecutionException ( ex ) ; <nl> + } <nl> + } else { <nl> + if ( this . requiresInitialisation ) { <nl> + executor . execute ( firstTask ) ; <nl> + } <nl> + return executor . submit ( task ) . get ( this . timeoutMilliseconds , TimeUnit . MILLISECONDS ) ; <nl> + } <nl> 	 } <nl> <nl> } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Factory . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Factory . java <nl> index fe5a6e8 . . ba367b1 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Factory . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Factory . java <nl> @ @ - 13 , 9 + 13 , 6 @ @ <nl> package com . sun . jna . platform . win32 . COM . util ; <nl> <nl> import java . lang . reflect . Proxy ; <nl> - import java . util . HashSet ; <nl> - import java . util . Set ; <nl> - import java . util . WeakHashMap ; <nl> import java . util . concurrent . Callable ; <nl> import java . util . concurrent . ExecutionException ; <nl> import java . util . concurrent . TimeoutException ; <nl> @ @ - 33 , 6 + 30 , 11 @ @ import com . sun . jna . platform . win32 . COM . Dispatch ; <nl> import com . sun . jna . platform . win32 . COM . IDispatch ; <nl> import com . sun . jna . platform . win32 . COM . util . annotation . ComObject ; <nl> import com . sun . jna . ptr . PointerByReference ; <nl> + import java . lang . ref . WeakReference ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Iterator ; <nl> + import java . util . LinkedList ; <nl> + import java . util . List ; <nl> <nl> public class Factory { <nl> <nl> @ @ - 52 , 7 + 54 , 6 @ @ public class Factory { <nl> <nl> 	 public Factory ( ComThread comThread ) { <nl> 	 	 this . comThread = comThread ; <nl> - 	 	 this . registeredObjects = new WeakHashMap < ProxyObject , Integer > ( ) ; <nl> 	 } <nl> 	 <nl> 	 @ Override <nl> @ @ - 232 , 47 + 233 , 43 @ @ public class Factory { <nl> 	 	 } <nl> 	 } <nl> <nl> - 	 / / factory needs to keep a register of all handles to COM objects so that it can clean them up properly <nl> - 	 / / ( if java had an out of scope clean up destructor like C + + , this wouldn ' t be needed ) <nl> - 	 WeakHashMap < ProxyObject , Integer > registeredObjects ; <nl> + 	 / / Proxy object release their COM interface reference latest in the <nl> + / / finalize method , which is run when garbadge collection removes the <nl> + / / object . <nl> + / / When the factory is finished , the referenced objects loose their <nl> + / / environment and can ' t be used anymore . registeredObjects is used <nl> + / / to dispose interfaces even if garbadge collection has not yet collected <nl> + / / the proxy objects . <nl> + 	 private final List < WeakReference < ProxyObject > > registeredObjects = new LinkedList < WeakReference < ProxyObject > > ( ) ; <nl> 	 public void register ( ProxyObject proxyObject ) { <nl> - 	 	 synchronized ( this . registeredObjects ) { <nl> - 	 	 	 / / ProxyObject identity resolves to the underlying native pointer value <nl> - 	 	 	 / / different java ProxyObjects will resolve to the same pointer <nl> - 	 	 	 / / thus we need to count the number of references . <nl> - 	 	 	 if ( this . registeredObjects . containsKey ( proxyObject ) ) { <nl> - 	 	 	 	 int r = this . registeredObjects . get ( proxyObject ) ; <nl> - 	 	 	 	 this . registeredObjects . put ( proxyObject , r + 1 ) ; <nl> - 	 	 	 } else { <nl> - 	 	 	 	 this . registeredObjects . put ( proxyObject , 1 ) ; <nl> - 	 	 	 } <nl> - 	 	 } <nl> + synchronized ( this . registeredObjects ) { <nl> + this . registeredObjects . add ( new WeakReference < ProxyObject > ( proxyObject ) ) ; <nl> + } <nl> 	 } <nl> 	 <nl> - 	 public void unregister ( ProxyObject proxyObject , int d ) { <nl> - 	 	 synchronized ( this . registeredObjects ) { <nl> - 	 	 	 if ( this . registeredObjects . containsKey ( proxyObject ) ) { <nl> - 	 	 	 	 int r = this . registeredObjects . get ( proxyObject ) ; <nl> - 	 	 	 	 if ( r > 1 ) { <nl> - 	 	 	 	 	 this . registeredObjects . put ( proxyObject , r - d ) ; <nl> - 	 	 	 	 } else { <nl> - 	 	 	 	 	 this . registeredObjects . remove ( proxyObject ) ; <nl> - 	 	 	 	 } <nl> - 	 	 	 } else { <nl> - 	 	 	 	 throw new RuntimeException ( " Tried to dispose a ProxyObject that is not registered " ) ; <nl> - 	 	 	 } <nl> - 	 	 	 <nl> - 	 	 } <nl> - 	 } <nl> + 	 public void unregister ( ProxyObject proxyObject ) { <nl> + synchronized ( this . registeredObjects ) { <nl> + Iterator < WeakReference < ProxyObject > > iterator = this . registeredObjects . iterator ( ) ; <nl> + while ( iterator . hasNext ( ) ) { <nl> + WeakReference < ProxyObject > weakRef = iterator . next ( ) ; <nl> + ProxyObject po = weakRef . get ( ) ; <nl> + if ( po = = null | | po = = proxyObject ) { <nl> + iterator . remove ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> 	 <nl> 	 public void disposeAll ( ) { <nl> - 	 	 synchronized ( this . registeredObjects ) { <nl> - 	 	 	 Set < ProxyObject > s = new HashSet < ProxyObject > ( this . registeredObjects . keySet ( ) ) ; <nl> - 	 	 	 for ( ProxyObject proxyObject : s ) { <nl> - 	 	 	 	 int r = this . registeredObjects . get ( proxyObject ) ; <nl> - 	 	 	 	 proxyObject . dispose ( r ) ; <nl> - 	 	 	 } <nl> - 	 	 	 this . registeredObjects . clear ( ) ; <nl> - 	 	 } <nl> + synchronized ( this . registeredObjects ) { <nl> + List < WeakReference < ProxyObject > > s = new ArrayList < WeakReference < ProxyObject > > ( this . registeredObjects ) ; <nl> + for ( WeakReference < ProxyObject > weakRef : s ) { <nl> + ProxyObject po = weakRef . get ( ) ; <nl> + if ( po ! = null ) { <nl> + po . dispose ( ) ; <nl> + } <nl> + } <nl> + this . registeredObjects . clear ( ) ; <nl> + } <nl> 	 } <nl> } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ProxyObject . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ProxyObject . java <nl> index a9223fb . . cc47235 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ProxyObject . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ProxyObject . java <nl> @ @ - 60 , 7 + 60 , 7 @ @ import com . sun . jna . ptr . PointerByReference ; <nl> * / <nl> public class ProxyObject implements InvocationHandler , com . sun . jna . platform . win32 . COM . util . IDispatch , <nl> 	 	 IRawDispatchHandle { <nl> - <nl> + <nl> 	 public ProxyObject ( Class < ? > theInterface , IDispatch rawDispatch , Factory factory ) { <nl> 	 	 this . unknownId = - 1 ; <nl> 	 	 this . rawDispatch = rawDispatch ; <nl> @ @ - 95 , 6 + 95 , 7 @ @ public class ProxyObject implements InvocationHandler , com . sun . jna . platform . win3 <nl> 	 	 factory . register ( this ) ; <nl> 	 } <nl> <nl> + <nl> 	 / / cached value of the IUnknown interface pointer <nl> 	 / / Rules of COM state that querying for the IUnknown interface must return <nl> 	 / / an identical pointer value <nl> @ @ - 137 , 20 + 138 , 14 @ @ public class ProxyObject implements InvocationHandler , com . sun . jna . platform . win3 <nl> <nl> 	 @ Override <nl> 	 protected void finalize ( ) throws Throwable { <nl> - 	 	 this . dispose ( 1 ) ; <nl> + 	 	 this . dispose ( ) ; <nl> 	 } <nl> <nl> - 	 public void dispose ( int r ) { <nl> - 	 	 if ( ( ( Dispatch ) this . rawDispatch ) . getPointer ( ) . equals ( Pointer . NULL ) ) { <nl> - 	 	 	 / / do nothing , already disposed <nl> - 	 	 } else { <nl> - 	 	 	 for ( int i = 0 ; i < r ; + + i ) { <nl> - 	 	 	 	 / / catch result to help with debug <nl> - 	 	 	 	 int n = this . rawDispatch . Release ( ) ; <nl> - 	 	 	 	 int n2 = n ; <nl> - 	 	 	 } <nl> - 	 	 	 this . factory . unregister ( this , r ) ; <nl> - 	 	 	 ( ( Dispatch ) this . rawDispatch ) . setPointer ( Pointer . NULL ) ; <nl> + 	 public synchronized void dispose ( ) { <nl> + 	 	 if ( ! ( ( Dispatch ) this . rawDispatch ) . getPointer ( ) . equals ( Pointer . NULL ) ) { <nl> + 	 	 	 this . rawDispatch . Release ( ) ; <nl> + ( ( Dispatch ) this . rawDispatch ) . setPointer ( Pointer . NULL ) ; <nl> + factory . unregister ( this ) ; <nl> 	 	 } <nl> 	 } <nl> <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / COM / util / ComEventCallbacks _ Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / COM / util / ComEventCallbacks _ Test . java <nl> index a49f4b7 . . ea7adc1 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / COM / util / ComEventCallbacks _ Test . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / COM / util / ComEventCallbacks _ Test . java <nl> @ @ - 121 , 11 + 121 , 6 @ @ public class ComEventCallbacks _ Test { <nl> VARIANT . ByReference PostData , <nl> VARIANT . ByReference Headers , <nl> OaIdl . VARIANT _ BOOLByReference Cancel ) { <nl> - / / This is todo : Event is called not on the event creating <nl> - / / thread - there are multiple side effects COM demarshalling <nl> - / / has to happend outside this method and return values <nl> - / / from event don ' t work <nl> - / / <nl> / / The utilizing unittest is adviseBeforeNavigate <nl> if ( blockNavigate ) { <nl> Cancel . setValue ( Variant . VARIANT _ TRUE ) ; <nl> @ @ - 212 , 7 + 207 , 6 @ @ public class ComEventCallbacks _ Test { <nl> 	 } <nl> <nl> 	 @ Test <nl> - @ Ignore ( " Known bug - events are currently dispatched out of the event handler , so this fails because return value not reach IE " ) <nl> 	 public void adviseBeforeNavigate ( ) throws InterruptedException { <nl> 	 	 ComInternetExplorer ieApp = factory . createObject ( ComInternetExplorer . class ) ; <nl> 	 	 ComIWebBrowser2 iWebBrowser2 = ieApp . queryInterface ( ComIWebBrowser2 . class ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / CallbackProxy . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / CallbackProxy . java 
 index 7e0316b . . 4185e6b 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / CallbackProxy . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / CallbackProxy . java 
 @ @ - 12 , 15 + 12 , 11 @ @ 
 * / 
 package com . sun . jna . platform . win32 . COM . util ; 
 
 - import java . lang . Thread . UncaughtExceptionHandler ; 
 import java . lang . reflect . Method ; 
 import java . util . ArrayList ; 
 import java . util . HashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 - import java . util . concurrent . ExecutorService ; 
 - import java . util . concurrent . Executors ; 
 - import java . util . concurrent . ThreadFactory ; 
 
 import com . sun . jna . Pointer ; 
 import com . sun . jna . WString ; 
 @ @ - 61 , 20 + 57 , 6 @ @ public class CallbackProxy implements IDispatchCallback { 
 	 	 this . listenedToRiid = this . createRIID ( comEventCallbackInterface ) ; 
 	 	 this . dsipIdMap = this . createDispIdMap ( comEventCallbackInterface ) ; 
 	 	 this . dispatchListener = new DispatchListener ( this ) ; 
 - 	 	 this . executorService = Executors . newSingleThreadExecutor ( new ThreadFactory ( ) { 
 - 	 	 	 @ Override 
 - 	 	 	 public Thread newThread ( Runnable r ) { 
 - 	 	 	 	 Thread thread = new Thread ( r , " COM Event Callback executor " ) ; 
 - 	 	 	 	 thread . setDaemon ( true ) ; 
 - 	 	 	 	 thread . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) { 
 - 	 	 	 	 	 @ Override 
 - 	 	 	 	 	 public void uncaughtException ( Thread t , Throwable e ) { 
 - 	 	 	 	 	 	 CallbackProxy . this . factory . comThread . uncaughtExceptionHandler . uncaughtException ( t , e ) ; 
 - 	 } 
 - 	 	 	 	 } ) ; 
 - 	 	 	 	 return thread ; 
 - 	 	 	 } 
 - 	 	 } ) ; 
 	 } 
 
 	 Factory factory ; 
 @ @ - 83 , 7 + 65 , 6 @ @ public class CallbackProxy implements IDispatchCallback { 
 	 REFIID listenedToRiid ; 
 	 public DispatchListener dispatchListener ; 
 	 Map < DISPID , Method > dsipIdMap ; 
 - 	 ExecutorService executorService ; 
 
 	 REFIID createRIID ( Class < ? > comEventCallbackInterface ) { 
 	 	 ComInterface comInterfaceAnnotation = comEventCallbackInterface . getAnnotation ( ComInterface . class ) ; 
 @ @ - 138 , 19 + 119 , 23 @ @ public class CallbackProxy implements IDispatchCallback { 
 return ; 
 } 
 
 - / / decode arguments 
 - / / must decode them on this thread , and create a proxy for any COM objects ( IDispatch ) 
 - / / this will AddRef on the COM object so that it is not cleaned up before we can use it 
 - / / on the thread that does the java callback . 
 + / / Arguments are converted to the JAVA side and IDispatch Interfaces 
 + / / are wrapped into an ProxyObject if so requested . 
 + / / 
 + / / Out - Parameter need to be specified as VARIANT , VARIANT args are 
 + / / not converted , so COM memory allocation rules apply . 
 final Class < ? > [ ] params = eventMethod . getParameterTypes ( ) ; 
 List < Object > rjargs = new ArrayList < Object > ( ) ; 
 if ( pDispParams . cArgs . intValue ( ) > 0 ) { 
 VariantArg vargs = pDispParams . rgvarg ; 
 vargs . setArraySize ( pDispParams . cArgs . intValue ( ) ) ; 
 for ( int i = 0 ; i < vargs . variantArg . length ; i + + ) { 
 + Class targetClass = params [ vargs . variantArg . length - 1 - i ] ; 
 Variant . VARIANT varg = vargs . variantArg [ i ] ; 
 - Object jarg = Convert . toJavaObject ( varg , params [ vargs . variantArg . length - 1 - i ] ) ; 
 + Object jarg = Convert . toJavaObject ( varg , targetClass ) ; 
 if ( jarg instanceof IDispatch ) { 
 + / / If a dispatch is returned try to wrap it into a proxy 
 + / / helper if the target is ComInterface annotated 
 IDispatch dispatch = ( IDispatch ) jarg ; 
 / / get raw IUnknown interface 
 PointerByReference ppvObject = new PointerByReference ( ) ; 
 @ @ - 158 , 56 + 143 , 38 @ @ public class CallbackProxy implements IDispatchCallback { 
 dispatch . QueryInterface ( new REFIID ( iid ) , ppvObject ) ; 
 Unknown rawUnk = new Unknown ( ppvObject . getValue ( ) ) ; 
 	 	 	 	 	 long unknownId = Pointer . nativeValue ( rawUnk . getPointer ( ) ) ; 
 - int n = rawUnk . Release ( ) ; 
 - / / Note : unlike in other places , there is currently no COM ref already added for this pointer 
 IUnknown unk = CallbackProxy . this . factory . createProxy ( IUnknown . class , unknownId , dispatch ) ; 
 - rjargs . add ( unk ) ; 
 + if ( targetClass . getAnnotation ( ComInterface . class ) ! = null ) { 
 + rjargs . add ( unk . queryInterface ( targetClass ) ) ; 
 + } else { 
 + rjargs . add ( unk ) ; 
 + } 
 } else { 
 rjargs . add ( jarg ) ; 
 } 
 } 
 } 
 - final List < Object > jargs = new ArrayList < Object > ( rjargs ) ; 
 - Runnable invokation = new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - / / need to convert arguments maybe 
 - List < Object > margs = new ArrayList < Object > ( ) ; 
 - try { 
 - / / Reverse order from calling convention 
 - int lastParamIdx = eventMethod . getParameterTypes ( ) . length - 1 ; 
 - for ( int i = lastParamIdx ; i > = 0 ; i - - ) { 
 - Class < ? > paramType = params [ lastParamIdx - i ] ; 
 - Object jobj = jargs . get ( i ) ; 
 - if ( jobj ! = null & & paramType . getAnnotation ( ComInterface . class ) ! = null ) { 
 - if ( jobj instanceof IUnknown ) { 
 - IUnknown unk = ( IUnknown ) jobj ; 
 - Object mobj = unk . queryInterface ( paramType ) ; 
 - margs . add ( mobj ) ; 
 - } else { 
 - throw new RuntimeException ( " Cannot convert argument " + jobj . getClass ( ) 
 - + " to ComInterface " + paramType ) ; 
 - } 
 - } else { 
 - margs . add ( jobj ) ; 
 - } 
 - } 
 - eventMethod . invoke ( comEventCallbackListener , margs . toArray ( ) ) ; 
 - } catch ( Exception e ) { 
 - List < String > decodedClassNames = new ArrayList < String > ( margs . size ( ) ) ; 
 - for ( Object o : margs ) { 
 - if ( o = = null ) { 
 - decodedClassNames . add ( " NULL " ) ; 
 - } else { 
 - decodedClassNames . add ( o . getClass ( ) . getName ( ) ) ; 
 - } 
 - } 
 - CallbackProxy . this . comEventCallbackListener . errorReceivingCallbackEvent ( 
 - " Exception invoking method " + eventMethod + " supplied : " + decodedClassNames . toString ( ) , e ) ; 
 + 
 + List < Object > margs = new ArrayList < Object > ( ) ; 
 + try { 
 + / / Reverse order from calling convention 
 + int lastParamIdx = eventMethod . getParameterTypes ( ) . length - 1 ; 
 + for ( int i = lastParamIdx ; i > = 0 ; i - - ) { 
 + margs . add ( rjargs . get ( i ) ) ; 
 + } 
 + eventMethod . invoke ( comEventCallbackListener , margs . toArray ( ) ) ; 
 + } catch ( Exception e ) { 
 + List < String > decodedClassNames = new ArrayList < String > ( margs . size ( ) ) ; 
 + for ( Object o : margs ) { 
 + if ( o = = null ) { 
 + decodedClassNames . add ( " NULL " ) ; 
 + } else { 
 + decodedClassNames . add ( o . getClass ( ) . getName ( ) ) ; 
 } 
 } 
 - } ; 
 - 	 	 this . executorService . execute ( invokation ) ; 
 + CallbackProxy . this . comEventCallbackListener . errorReceivingCallbackEvent ( 
 + " Exception invoking method " + eventMethod + " supplied : " + decodedClassNames . toString ( ) , e ) ; 
 + } 
 } 
 
 	 @ Override 
 @ @ - 237 , 7 + 204 , 13 @ @ public class CallbackProxy implements IDispatchCallback { 
 	 	 	 DISPPARAMS . ByReference pDispParams , VARIANT . ByReference pVarResult , EXCEPINFO . ByReference pExcepInfo , 
 	 	 	 IntByReference puArgErr ) { 
 
 - 	 	 this . invokeOnThread ( dispIdMember , riid , lcid , wFlags , pDispParams ) ; 
 + assert ( ! ComThread . getCurrentThreadIsCOM ( ) ) : " Assumption about COM threading broken . " ; 
 + ComThread . setCurrentThreadIsCOM ( true ) ; 
 + try { 
 + this . invokeOnThread ( dispIdMember , riid , lcid , wFlags , pDispParams ) ; 
 + } finally { 
 + ComThread . setCurrentThreadIsCOM ( false ) ; 
 + } 
 
 	 	 return WinError . S _ OK ; 
 	 } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ComThread . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ComThread . java 
 index 3ac5c13 . . 07e6405 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ComThread . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ComThread . java 
 @ @ - 26 , 7 + 26 , 6 @ @ import com . sun . jna . platform . win32 . WinNT ; 
 import com . sun . jna . platform . win32 . COM . COMUtils ; 
 
 public class ComThread { 
 - 
 	 ExecutorService executor ; 
 	 Runnable firstTask ; 
 	 boolean requiresInitialisation ; 
 @ @ - 44 , 6 + 43 , 8 @ @ public class ComThread { 
 	 	 this . firstTask = new Runnable ( ) { 
 	 	 	 @ Override 
 	 	 	 public void run ( ) { 
 + / / By definition this is a COM thread 
 + ComThread . setCurrentThreadIsCOM ( true ) ; 
 	 	 	 	 try { 
 	 	 	 	 	 / / If we do not use COINIT _ MULTITHREADED , it is necessary to have 
 	 	 	 	 	 / / a message loop see - 
 @ @ - 119 , 11 + 120 , 38 @ @ public class ComThread { 
 	 	 } 
 	 } 
 
 + / / The currentThreadIsCOM is used if wrapper are used in a callback 
 + / / the callback is called in a new thread by the JNA runtime . As the 
 + / / call comes from COM it is asumed , that the thread is correctly 
 + / / initialized and can be used for COM calls ( see MTA assumption above ) 
 + private static ThreadLocal < Boolean > currentThreadIsCOM = new ThreadLocal < Boolean > ( ) ; 
 + 
 + static void setCurrentThreadIsCOM ( boolean isCOM ) { 
 + currentThreadIsCOM . set ( isCOM ) ; 
 + } 
 + 
 + static boolean getCurrentThreadIsCOM ( ) { 
 + Boolean res = currentThreadIsCOM . get ( ) ; 
 + if ( res = = null ) { 
 + return false ; 
 + } else { 
 + return currentThreadIsCOM . get ( ) ; 
 + } 
 + } 
 + 
 	 public < T > T execute ( Callable < T > task ) throws TimeoutException , InterruptedException , ExecutionException { 
 - 	 	 if ( this . requiresInitialisation ) { 
 - 	 	 	 executor . execute ( firstTask ) ; 
 - 	 	 } 
 - 	 	 return executor . submit ( task ) . get ( this . timeoutMilliseconds , TimeUnit . MILLISECONDS ) ; 
 + if ( getCurrentThreadIsCOM ( ) ) { 
 + try { 
 + return task . call ( ) ; 
 + } catch ( Exception ex ) { 
 + throw new ExecutionException ( ex ) ; 
 + } 
 + } else { 
 + if ( this . requiresInitialisation ) { 
 + executor . execute ( firstTask ) ; 
 + } 
 + return executor . submit ( task ) . get ( this . timeoutMilliseconds , TimeUnit . MILLISECONDS ) ; 
 + } 
 	 } 
 
 } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Factory . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Factory . java 
 index fe5a6e8 . . ba367b1 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Factory . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / Factory . java 
 @ @ - 13 , 9 + 13 , 6 @ @ 
 package com . sun . jna . platform . win32 . COM . util ; 
 
 import java . lang . reflect . Proxy ; 
 - import java . util . HashSet ; 
 - import java . util . Set ; 
 - import java . util . WeakHashMap ; 
 import java . util . concurrent . Callable ; 
 import java . util . concurrent . ExecutionException ; 
 import java . util . concurrent . TimeoutException ; 
 @ @ - 33 , 6 + 30 , 11 @ @ import com . sun . jna . platform . win32 . COM . Dispatch ; 
 import com . sun . jna . platform . win32 . COM . IDispatch ; 
 import com . sun . jna . platform . win32 . COM . util . annotation . ComObject ; 
 import com . sun . jna . ptr . PointerByReference ; 
 + import java . lang . ref . WeakReference ; 
 + import java . util . ArrayList ; 
 + import java . util . Iterator ; 
 + import java . util . LinkedList ; 
 + import java . util . List ; 
 
 public class Factory { 
 
 @ @ - 52 , 7 + 54 , 6 @ @ public class Factory { 
 
 	 public Factory ( ComThread comThread ) { 
 	 	 this . comThread = comThread ; 
 - 	 	 this . registeredObjects = new WeakHashMap < ProxyObject , Integer > ( ) ; 
 	 } 
 	 
 	 @ Override 
 @ @ - 232 , 47 + 233 , 43 @ @ public class Factory { 
 	 	 } 
 	 } 
 
 - 	 / / factory needs to keep a register of all handles to COM objects so that it can clean them up properly 
 - 	 / / ( if java had an out of scope clean up destructor like C + + , this wouldn ' t be needed ) 
 - 	 WeakHashMap < ProxyObject , Integer > registeredObjects ; 
 + 	 / / Proxy object release their COM interface reference latest in the 
 + / / finalize method , which is run when garbadge collection removes the 
 + / / object . 
 + / / When the factory is finished , the referenced objects loose their 
 + / / environment and can ' t be used anymore . registeredObjects is used 
 + / / to dispose interfaces even if garbadge collection has not yet collected 
 + / / the proxy objects . 
 + 	 private final List < WeakReference < ProxyObject > > registeredObjects = new LinkedList < WeakReference < ProxyObject > > ( ) ; 
 	 public void register ( ProxyObject proxyObject ) { 
 - 	 	 synchronized ( this . registeredObjects ) { 
 - 	 	 	 / / ProxyObject identity resolves to the underlying native pointer value 
 - 	 	 	 / / different java ProxyObjects will resolve to the same pointer 
 - 	 	 	 / / thus we need to count the number of references . 
 - 	 	 	 if ( this . registeredObjects . containsKey ( proxyObject ) ) { 
 - 	 	 	 	 int r = this . registeredObjects . get ( proxyObject ) ; 
 - 	 	 	 	 this . registeredObjects . put ( proxyObject , r + 1 ) ; 
 - 	 	 	 } else { 
 - 	 	 	 	 this . registeredObjects . put ( proxyObject , 1 ) ; 
 - 	 	 	 } 
 - 	 	 } 
 + synchronized ( this . registeredObjects ) { 
 + this . registeredObjects . add ( new WeakReference < ProxyObject > ( proxyObject ) ) ; 
 + } 
 	 } 
 	 
 - 	 public void unregister ( ProxyObject proxyObject , int d ) { 
 - 	 	 synchronized ( this . registeredObjects ) { 
 - 	 	 	 if ( this . registeredObjects . containsKey ( proxyObject ) ) { 
 - 	 	 	 	 int r = this . registeredObjects . get ( proxyObject ) ; 
 - 	 	 	 	 if ( r > 1 ) { 
 - 	 	 	 	 	 this . registeredObjects . put ( proxyObject , r - d ) ; 
 - 	 	 	 	 } else { 
 - 	 	 	 	 	 this . registeredObjects . remove ( proxyObject ) ; 
 - 	 	 	 	 } 
 - 	 	 	 } else { 
 - 	 	 	 	 throw new RuntimeException ( " Tried to dispose a ProxyObject that is not registered " ) ; 
 - 	 	 	 } 
 - 	 	 	 
 - 	 	 } 
 - 	 } 
 + 	 public void unregister ( ProxyObject proxyObject ) { 
 + synchronized ( this . registeredObjects ) { 
 + Iterator < WeakReference < ProxyObject > > iterator = this . registeredObjects . iterator ( ) ; 
 + while ( iterator . hasNext ( ) ) { 
 + WeakReference < ProxyObject > weakRef = iterator . next ( ) ; 
 + ProxyObject po = weakRef . get ( ) ; 
 + if ( po = = null | | po = = proxyObject ) { 
 + iterator . remove ( ) ; 
 + } 
 + } 
 + } 
 + } 
 	 
 	 public void disposeAll ( ) { 
 - 	 	 synchronized ( this . registeredObjects ) { 
 - 	 	 	 Set < ProxyObject > s = new HashSet < ProxyObject > ( this . registeredObjects . keySet ( ) ) ; 
 - 	 	 	 for ( ProxyObject proxyObject : s ) { 
 - 	 	 	 	 int r = this . registeredObjects . get ( proxyObject ) ; 
 - 	 	 	 	 proxyObject . dispose ( r ) ; 
 - 	 	 	 } 
 - 	 	 	 this . registeredObjects . clear ( ) ; 
 - 	 	 } 
 + synchronized ( this . registeredObjects ) { 
 + List < WeakReference < ProxyObject > > s = new ArrayList < WeakReference < ProxyObject > > ( this . registeredObjects ) ; 
 + for ( WeakReference < ProxyObject > weakRef : s ) { 
 + ProxyObject po = weakRef . get ( ) ; 
 + if ( po ! = null ) { 
 + po . dispose ( ) ; 
 + } 
 + } 
 + this . registeredObjects . clear ( ) ; 
 + } 
 	 } 
 } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ProxyObject . java b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ProxyObject . java 
 index a9223fb . . cc47235 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ProxyObject . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / COM / util / ProxyObject . java 
 @ @ - 60 , 7 + 60 , 7 @ @ import com . sun . jna . ptr . PointerByReference ; 
 * / 
 public class ProxyObject implements InvocationHandler , com . sun . jna . platform . win32 . COM . util . IDispatch , 
 	 	 IRawDispatchHandle { 
 - 
 + 
 	 public ProxyObject ( Class < ? > theInterface , IDispatch rawDispatch , Factory factory ) { 
 	 	 this . unknownId = - 1 ; 
 	 	 this . rawDispatch = rawDispatch ; 
 @ @ - 95 , 6 + 95 , 7 @ @ public class ProxyObject implements InvocationHandler , com . sun . jna . platform . win3 
 	 	 factory . register ( this ) ; 
 	 } 
 
 + 
 	 / / cached value of the IUnknown interface pointer 
 	 / / Rules of COM state that querying for the IUnknown interface must return 
 	 / / an identical pointer value 
 @ @ - 137 , 20 + 138 , 14 @ @ public class ProxyObject implements InvocationHandler , com . sun . jna . platform . win3 
 
 	 @ Override 
 	 protected void finalize ( ) throws Throwable { 
 - 	 	 this . dispose ( 1 ) ; 
 + 	 	 this . dispose ( ) ; 
 	 } 
 
 - 	 public void dispose ( int r ) { 
 - 	 	 if ( ( ( Dispatch ) this . rawDispatch ) . getPointer ( ) . equals ( Pointer . NULL ) ) { 
 - 	 	 	 / / do nothing , already disposed 
 - 	 	 } else { 
 - 	 	 	 for ( int i = 0 ; i < r ; + + i ) { 
 - 	 	 	 	 / / catch result to help with debug 
 - 	 	 	 	 int n = this . rawDispatch . Release ( ) ; 
 - 	 	 	 	 int n2 = n ; 
 - 	 	 	 } 
 - 	 	 	 this . factory . unregister ( this , r ) ; 
 - 	 	 	 ( ( Dispatch ) this . rawDispatch ) . setPointer ( Pointer . NULL ) ; 
 + 	 public synchronized void dispose ( ) { 
 + 	 	 if ( ! ( ( Dispatch ) this . rawDispatch ) . getPointer ( ) . equals ( Pointer . NULL ) ) { 
 + 	 	 	 this . rawDispatch . Release ( ) ; 
 + ( ( Dispatch ) this . rawDispatch ) . setPointer ( Pointer . NULL ) ; 
 + factory . unregister ( this ) ; 
 	 	 } 
 	 } 
 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / COM / util / ComEventCallbacks _ Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / COM / util / ComEventCallbacks _ Test . java 
 index a49f4b7 . . ea7adc1 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / COM / util / ComEventCallbacks _ Test . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / COM / util / ComEventCallbacks _ Test . java 
 @ @ - 121 , 11 + 121 , 6 @ @ public class ComEventCallbacks _ Test { 
 VARIANT . ByReference PostData , 
 VARIANT . ByReference Headers , 
 OaIdl . VARIANT _ BOOLByReference Cancel ) { 
 - / / This is todo : Event is called not on the event creating 
 - / / thread - there are multiple side effects COM demarshalling 
 - / / has to happend outside this method and return values 
 - / / from event don ' t work 
 - / / 
 / / The utilizing unittest is adviseBeforeNavigate 
 if ( blockNavigate ) { 
 Cancel . setValue ( Variant . VARIANT _ TRUE ) ; 
 @ @ - 212 , 7 + 207 , 6 @ @ public class ComEventCallbacks _ Test { 
 	 } 
 
 	 @ Test 
 - @ Ignore ( " Known bug - events are currently dispatched out of the event handler , so this fails because return value not reach IE " ) 
 	 public void adviseBeforeNavigate ( ) throws InterruptedException { 
 	 	 ComInternetExplorer ieApp = factory . createObject ( ComInternetExplorer . class ) ; 
 	 	 ComIWebBrowser2 iWebBrowser2 = ieApp . queryInterface ( ComIWebBrowser2 . class ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
