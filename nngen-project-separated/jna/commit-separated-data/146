BLEU SCORE: 0.01080894324815623

TEST MSG: Added functions to Advapi32
GENERATED MSG: Make sure SID related memory is properly released once no longer required

TEST DIFF (one line): diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> index fcbbad8 . . dd2c300 100755 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> @ @ - 35 , 12 + 35 , 14 @ @ import com . sun . jna . platform . win32 . WinDef . BOOLByReference ; <nl> import com . sun . jna . platform . win32 . WinDef . DWORD ; <nl> import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; <nl> import com . sun . jna . platform . win32 . WinDef . ULONG ; <nl> + import com . sun . jna . platform . win32 . WinNT . ACL ; <nl> import com . sun . jna . platform . win32 . WinNT . GENERIC _ MAPPING ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; <nl> import com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; <nl> import com . sun . jna . platform . win32 . WinNT . PSID ; <nl> import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; <nl> + import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEY ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> import com . sun . jna . platform . win32 . Winsvc . ChangeServiceConfig2Info ; <nl> @ @ - 249 , 6 + 251 , 20 @ @ public interface Advapi32 extends StdCallLibrary { <nl> boolean IsValidSid ( PSID pSid ) ; <nl> <nl> / * * <nl> + * he EqualSid function tests two security identifier ( SID ) values for equality . <nl> + * Two SIDs must match exactly to be considered equal . <nl> + * @ param pSid1 <nl> + * A pointer to the first SID structure to compare . This structure is assumed to be valid . <nl> + * @ param pSid2 <nl> + * A pointer to the second SID structure to compare . This structure is assumed to be valid . <nl> + * @ return If the SID structures are equal , the return value is nonzero . <nl> + * If the SID structures are not equal , the return value is zero . To get extended error <nl> + * information , call GetLastError . <nl> + * If either SID structure is not valid , the return value is undefined . <nl> + * / <nl> + boolean EqualSid ( PSID pSid1 , PSID pSid2 ) ; <nl> + <nl> + / * * <nl> * Compares a SID to a well known SID and returns TRUE if they match . <nl> * <nl> * @ param pSid <nl> @ @ - 284 , 6 + 300 , 121 @ @ public interface Advapi32 extends StdCallLibrary { <nl> PSID pSid , IntByReference cbSid ) ; <nl> <nl> / * * <nl> + * The InitializeSecurityDescriptor function initializes a new security descriptor . <nl> + * @ param pSecurityDescriptor <nl> + * A pointer to a SECURITY _ DESCRIPTOR structure that the function initializes . <nl> + * @ param dwRevision <nl> + * The revision level to assign to the security descriptor . This parameter <nl> + * must be SECURITY _ DESCRIPTOR _ REVISION . <nl> + * @ return If the function succeeds , the return value is nonzero . If the <nl> + * function fails , the return value is zero . For extended error <nl> + * information , call GetLastError . <nl> + * / <nl> + boolean InitializeSecurityDescriptor ( SECURITY _ DESCRIPTOR pSecurityDescriptor , int dwRevision ) ; <nl> + <nl> + / * * <nl> + * The InitializeAcl function initializes a new ACL structure . <nl> + * @ param pAcl <nl> + * A pointer to an ACL structure to be initialized by this function . <nl> + * Allocate memory for pAcl before calling this function . <nl> + * @ param nAclLength <nl> + * The length , in bytes , of the buffer pointed to by the pAcl parameter . This value <nl> + * must be large enough to contain the ACL header and all of the access control <nl> + * entries ( ACEs ) to be stored in the ACL . In addition , this value must be <nl> + * DWORD - aligned . For more information about calculating the size of an ACL , <nl> + * see Remarks . <nl> + * @ param dwAclRevision <nl> + * The revision level of the ACL structure being created . This value can be ACL _ REVISION <nl> + * or ACL _ REVISION _ DS . Use ACL _ REVISION _ DS if the access control list ( ACL ) supports <nl> + * object - specific ACEs . <nl> + * @ return If the function succeeds , the return value is nonzero . If the <nl> + * function fails , the return value is zero . For extended error <nl> + * information , call GetLastError . <nl> + * / <nl> + boolean InitializeAcl ( ACL pAcl , int nAclLength , int dwAclRevision ) ; <nl> + <nl> + / * * <nl> + * The AddAce function adds one or more access control entries ( ACEs ) to a specified access control list ( ACL ) . <nl> + * @ param pAcl <nl> + * A pointer to an ACL . This function adds an ACE to this ACL . <nl> + * @ param dwAceRevision <nl> + * Specifies the revision level of the ACL being modified . This value can be ACL _ REVISION or <nl> + * ACL _ REVISION _ DS . Use ACL _ REVISION _ DS if the ACL contains object - specific ACEs . This value <nl> + * must be compatible with the AceType field of all ACEs in pAceList . Otherwise , the function <nl> + * will fail and set the last error to ERROR _ INVALID _ PARAMETER . <nl> + * @ param dwStartingAceIndex <nl> + * Specifies the position in the ACL ' s list of ACEs at which to add new ACEs . A value of zero <nl> + * inserts the ACEs at the beginning of the list . A value of MAXDWORD appends the ACEs to the end <nl> + * of the list . <nl> + * @ param pAceList <nl> + * A pointer to a list of one or more ACEs to be added to the specified ACL . The ACEs in the list <nl> + * must be stored contiguously . <nl> + * @ param nAceListLength <nl> + * Specifies the size , in bytes , of the input buffer pointed to by the pAceList parameter . <nl> + * @ return If the function succeeds , the return value is nonzero . If the <nl> + * function fails , the return value is zero . For extended error <nl> + * information , call GetLastError . <nl> + * / <nl> + boolean AddAce ( ACL pAcl , int dwAceRevision , int dwStartingAceIndex , Pointer pAceList , int nAceListLength ) ; <nl> + <nl> + / * * <nl> + * The AddAce function adds one or more access control entries ( ACEs ) to a specified access control list ( ACL ) . <nl> + * @ param pAcl <nl> + * A pointer to an ACL . This function adds an access - allowed ACE to the end of this ACL . <nl> + * The ACE is in the form of an ACCESS _ ALLOWED _ ACE structure . <nl> + * @ param dwAceRevision <nl> + * Specifies the revision level of the ACL being modified . This value can be ACL _ REVISION or <nl> + * ACL _ REVISION _ DS . Use ACL _ REVISION _ DS if the ACL contains object - specific ACEs . <nl> + * @ param AccessMask <nl> + * Specifies the mask of access rights to be granted to the specified SID . <nl> + * @ param pSid <nl> + * A pointer to the SID representing a user , group , or logon account being granted access . <nl> + * @ return If the function succeeds , the return value is nonzero . If the <nl> + * function fails , the return value is zero . For extended error <nl> + * information , call GetLastError . <nl> + * / <nl> + boolean AddAccessAllowedAce ( ACL pAcl , int dwAceRevision , int AccessMask , PSID pSid ) ; <nl> + <nl> + / * * <nl> + * The AddAce function adds one or more access control entries ( ACEs ) to a specified access control list ( ACL ) . <nl> + * @ param pAcl <nl> + * A pointer to an ACL . This function adds an access - allowed ACE to the end of this ACL . <nl> + * The ACE is in the form of an ACCESS _ ALLOWED _ ACE structure . <nl> + * @ param dwAceRevision <nl> + * Specifies the revision level of the ACL being modified . This value can be ACL _ REVISION or <nl> + * ACL _ REVISION _ DS . Use ACL _ REVISION _ DS if the ACL contains object - specific ACEs . <nl> + * @ param AceFlags <nl> + * A set of bit flags that control ACE inheritance . The function sets these flags in the AceFlags <nl> + * member of the ACE _ HEADER structure of the new ACE . This parameter can be a combination <nl> + * of the following values : CONTAINER _ INHERIT _ ACE , INHERIT _ ONLY _ ACE , INHERITED _ ACE , <nl> + * NO _ PROPAGATE _ INHERIT _ ACE , and OBJECT _ INHERIT _ ACE <nl> + * @ param AccessMask <nl> + * Specifies the mask of access rights to be granted to the specified SID . <nl> + * @ param pSid <nl> + * A pointer to the SID representing a user , group , or logon account being granted access . <nl> + * @ return If the function succeeds , the return value is nonzero . If the <nl> + * function fails , the return value is zero . For extended error <nl> + * information , call GetLastError . <nl> + * / <nl> + boolean AddAccessAllowedAceEx ( ACL pAcl , int dwAceRevision , int AceFlags , int AccessMask , PSID pSid ) ; <nl> + <nl> + / * * <nl> + * The GetAce function obtains a pointer to an access control entry ( ACE ) in an access <nl> + * control list ( ACL ) . <nl> + * @ param pAcl <nl> + * A pointer to an ACL that contains the ACE to be retrieved . <nl> + * @ param dwAceIndex <nl> + * The index of the ACE to be retrieved . A value of zero corresponds to the first ACE in <nl> + * the ACL , a value of one to the second ACE , and so on . <nl> + * @ param pAce <nl> + * A pointer to a pointer that the function sets to the address of the ACE . <nl> + * @ return If the function succeeds , the return value is nonzero . If the <nl> + * function fails , the return value is zero . For extended error <nl> + * information , call GetLastError . <nl> + * / <nl> + boolean GetAce ( ACL pAcl , int dwAceIndex , PointerByReference pAce ) ; <nl> + <nl> + / * * <nl> * The LogonUser function attempts to log a user on to the local computer . <nl> * The local computer is the computer from which LogonUser was called . You <nl> * cannot use LogonUser to log on to a remote computer . You specify the user <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> index 7715451 . . ff317e6 100755 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> @ @ - 47 , 7 + 47 , 9 @ @ import static com . sun . jna . platform . win32 . WinNT . TOKEN _ QUERY ; <nl> import static com . sun . jna . platform . win32 . WinNT . UNPROTECTED _ DACL _ SECURITY _ INFORMATION ; <nl> import static com . sun . jna . platform . win32 . WinNT . UNPROTECTED _ SACL _ SECURITY _ INFORMATION ; <nl> <nl> + import java . io . ByteArrayInputStream ; <nl> import java . io . ByteArrayOutputStream ; <nl> + import java . io . DataInputStream ; <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> import java . util . ArrayList ; <nl> @ @ - 69 , 6 + 71 , 7 @ @ import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; <nl> import com . sun . jna . platform . win32 . WinDef . ULONG ; <nl> import com . sun . jna . platform . win32 . WinDef . ULONGByReference ; <nl> import com . sun . jna . platform . win32 . WinNT . ACCESS _ ACEStructure ; <nl> + import com . sun . jna . platform . win32 . WinNT . ACCESS _ ALLOWED _ ACE ; <nl> import com . sun . jna . platform . win32 . WinNT . ACL ; <nl> import com . sun . jna . platform . win32 . WinNT . EVENTLOGRECORD ; <nl> import com . sun . jna . platform . win32 . WinNT . GENERIC _ MAPPING ; <nl> @ @ - 377 , 6 + 380 , 38 @ @ public abstract class Advapi32Util { <nl> 	 	 return Advapi32 . INSTANCE . IsWellKnownSid ( pSID , wellKnownSidType ) ; <nl> 	 } <nl> <nl> + / * * <nl> + * Align cbAcl on a DWORD <nl> + * @ param cbAcl size to align <nl> + * @ return the aligned size <nl> + * / <nl> + public static int alignOnDWORD ( int cbAcl ) { <nl> + return ( cbAcl + ( DWORD . SIZE - 1 ) ) & 0xfffffffc ; <nl> + } <nl> + <nl> + 	 / * * <nl> + * Helper function to calculate the size of an ACE for a given PSID size <nl> + * @ param pSid the PSID <nl> + * @ return size of the ACE <nl> + * / <nl> + public static int getAceSize ( int sidLength ) { <nl> + return Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) <nl> + + sidLength <nl> + - DWORD . SIZE ; <nl> + } <nl> + <nl> + / * * <nl> + * Get the first 4 bytes of the PSID for a SidStart <nl> + * @ param psid the PSID <nl> + * @ return the SidStart <nl> + * @ throws IOException <nl> + * / <nl> + public static int getSidStart ( PSID psid ) throws IOException { <nl> + byte [ ] sidStart = psid . getBytes ( ) ; <nl> + DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( sidStart ) ) ; <nl> + return dis . readInt ( ) ; <nl> + } <nl> + <nl> 	 / * * <nl> 	 * Get an account name from a string SID on the local machine . <nl> 	 * <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> index 8290369 . . b09124c 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java <nl> @ @ - 50 , 6 + 50 , 15 @ @ import com . sun . jna . win32 . StdCallLibrary . StdCallCallback ; <nl> @ SuppressWarnings ( " serial " ) <nl> public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> <nl> + int MINCHAR = 0x80 ; <nl> + int MAXCHAR = 0x7f ; <nl> + int MINSHORT = 0x8000 ; <nl> + int MAXSHORT = 0x7fff ; <nl> + int MINLONG = 0x80000000 ; <nl> + int MAXLONG = 0x7fffffff ; <nl> + int MAXBYTE = 0xff ; <nl> + int MAXWORD = 0xffff ; <nl> + int MAXDWORD = 0xffffffff ; <nl> / / <nl> / / The following are masks for the predefined standard access types <nl> / / <nl> @ @ - 2462 , 6 + 2471 , 7 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> int SE _ RM _ CONTROL _ VALID = 0x00004000 ; <nl> int SE _ SELF _ RELATIVE = 0x00008000 ; <nl> <nl> + int SECURITY _ DESCRIPTOR _ REVISION = 0x00000001 ; <nl> <nl> public static class SECURITY _ DESCRIPTOR extends Structure { <nl> public static class ByReference extends SECURITY _ DESCRIPTOR implements <nl> @ @ - 2480 , 6 + 2490 , 12 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> useMemory ( new Memory ( data . length ) ) ; <nl> } <nl> <nl> + public SECURITY _ DESCRIPTOR ( int size ) { <nl> + super ( ) ; <nl> + useMemory ( new Memory ( size ) ) ; <nl> + data = new byte [ size ] ; <nl> + } <nl> + <nl> public SECURITY _ DESCRIPTOR ( Pointer memory ) { <nl> super ( memory ) ; <nl> read ( ) ; <nl> @ @ - 2491 , 6 + 2507 , 18 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> } <nl> } <nl> <nl> + int ACL _ REVISION = 2 ; <nl> + int ACL _ REVISION _ DS = 4 ; <nl> + <nl> + / / This is the history of ACL revisions . Add a new one whenever <nl> + / / ACL _ REVISION is updated <nl> + int ACL _ REVISION1 = 1 ; <nl> + int ACL _ REVISION2 = 2 ; <nl> + int ACL _ REVISION3 = 3 ; <nl> + int ACL _ REVISION4 = 4 ; <nl> + int MIN _ ACL _ REVISION = ACL _ REVISION2 ; <nl> + int MAX _ ACL _ REVISION = ACL _ REVISION4 ; <nl> + <nl> public static class ACL extends Structure { <nl> public static final List < String > FIELDS = createFieldsOrder ( " AclRevision " , " Sbz1 " , " AclSize " , " AceCount " , " Sbz2 " ) ; <nl> <nl> @ @ - 2506 , 6 + 2534 , 11 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> super ( ) ; <nl> } <nl> <nl> + public ACL ( int size ) { <nl> + super ( ) ; <nl> + useMemory ( new Memory ( size ) ) ; <nl> + } <nl> + <nl> public ACL ( Pointer pointer ) { <nl> super ( pointer ) ; <nl> read ( ) ; <nl> @ @ - 2631 , 6 + 2664 , 15 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> super ( p ) ; <nl> } <nl> <nl> + public ACEStructure ( byte AceType , byte AceFlags , short AceSize , PSID psid ) { <nl> + super ( ) ; <nl> + this . AceType = AceType ; <nl> + this . AceFlags = AceFlags ; <nl> + this . AceSize = AceSize ; <nl> + this . psid = psid ; <nl> + write ( ) ; <nl> + } <nl> + <nl> public String getSidString ( ) { <nl> return Advapi32Util . convertSidToStringSid ( psid ) ; <nl> } <nl> @ @ - 2686 , 16 + 2728 , 49 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> super ( ) ; <nl> } <nl> <nl> + public ACCESS _ ACEStructure ( int Mask , int SidStart , byte AceType , byte AceFlags , short AceSize , PSID psid ) { <nl> + super ( ) ; <nl> + this . allocateMemory ( AceSize ) ; <nl> + this . AceType = AceType ; <nl> + this . AceFlags = AceFlags ; <nl> + this . AceSize = AceSize ; <nl> + this . psid = psid ; <nl> + this . Mask = Mask ; <nl> + this . SidStart = new DWORD ( SidStart ) ; <nl> + write ( ) ; <nl> + } <nl> + <nl> public ACCESS _ ACEStructure ( Pointer p ) { <nl> super ( p ) ; <nl> read ( ) ; <nl> - / / AceSize - size of public members of the structure + size of DWORD <nl> - / / ( SidStart ) <nl> + / / Check for AceSize being zero , can happen on empty memory <nl> + if ( AceSize ! = 0 ) { <nl> int sizeOfSID = super . AceSize - size ( ) + 4 ; <nl> - / / ACE _ HEADER + size of int ( Mask ) <nl> + / / ACE _ HEADER + size of int ( Mask ) <nl> + int offsetOfSID = 4 + 4 ; <nl> + byte [ ] data = p . getByteArray ( offsetOfSID , sizeOfSID ) ; <nl> + psid = new PSID ( data ) ; <nl> + } <nl> + else { <nl> + psid = null ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Write override due to psid not being a managed field <nl> + * / <nl> + @ Override <nl> + public void write ( ) { <nl> + int sizeOfSID = super . AceSize - 8 ; <nl> int offsetOfSID = 4 + 4 ; <nl> - byte [ ] data = p . getByteArray ( offsetOfSID , sizeOfSID ) ; <nl> - psid = new PSID ( data ) ; <nl> + super . writeField ( " AceType " ) ; <nl> + super . writeField ( " AceFlags " ) ; <nl> + super . writeField ( " AceSize " ) ; <nl> + super . writeField ( " Mask " ) ; <nl> + / / Get bytes from the PSID <nl> + byte [ ] psidWrite = psid . getPointer ( ) . getByteArray ( 0 , sizeOfSID ) ; <nl> + / / Write those bytes to native memory <nl> + super . getPointer ( ) . write ( offsetOfSID , psidWrite , 0 , sizeOfSID ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 2713 , 6 + 2788 , 10 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { <nl> public ACCESS _ ALLOWED _ ACE ( Pointer p ) { <nl> super ( p ) ; <nl> } <nl> + <nl> + public ACCESS _ ALLOWED _ ACE ( int Mask , int SidStart , byte AceFlags , short AceSize , PSID psid ) { <nl> + super ( Mask , SidStart , ACCESS _ ALLOWED _ ACE _ TYPE , AceFlags , AceSize , psid ) ; <nl> + } <nl> } <nl> <nl> / * Access denied ACE * / <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> index beaeef3 . . 78810d3 100755 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> @ @ - 55 , 6 + 55 , 9 @ @ import com . sun . jna . platform . win32 . WinDef . DWORD ; <nl> import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; <nl> import com . sun . jna . platform . win32 . WinDef . ULONG ; <nl> import com . sun . jna . platform . win32 . WinDef . ULONGByReference ; <nl> + import com . sun . jna . platform . win32 . WinNT . ACCESS _ ACEStructure ; <nl> + import com . sun . jna . platform . win32 . WinNT . ACCESS _ ALLOWED _ ACE ; <nl> + import com . sun . jna . platform . win32 . WinNT . ACL ; <nl> import com . sun . jna . platform . win32 . WinNT . EVENTLOGRECORD ; <nl> import com . sun . jna . platform . win32 . WinNT . GENERIC _ MAPPING ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> @ @ - 62 , 6 + 65 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; <nl> import com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; <nl> import com . sun . jna . platform . win32 . WinNT . PSID ; <nl> import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; <nl> + import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR ; <nl> import com . sun . jna . platform . win32 . WinNT . SECURITY _ IMPERSONATION _ LEVEL ; <nl> import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; <nl> import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; <nl> @ @ - 149 , 6 + 153 , 23 @ @ public class Advapi32Test extends TestCase { <nl> 	 } <nl> } <nl> <nl> + public void testEqualSid ( ) { <nl> + String sidString = EVERYONE ; <nl> + PSIDByReference sid1 = new PSIDByReference ( ) ; <nl> + PSIDByReference sid2 = new PSIDByReference ( ) ; <nl> + assertTrue ( " SID1 conversion failed " , Advapi32 . INSTANCE . ConvertStringSidToSid ( sidString , sid1 ) ) ; <nl> + assertTrue ( " SID2 conversion failed " , Advapi32 . INSTANCE . ConvertStringSidToSid ( sidString , sid2 ) ) ; <nl> + <nl> + try { <nl> + assertTrue ( " Converted SID1 not valid " , Advapi32 . INSTANCE . IsValidSid ( sid1 . getValue ( ) ) ) ; <nl> + assertTrue ( " Converted SID2 not valid " , Advapi32 . INSTANCE . IsValidSid ( sid2 . getValue ( ) ) ) ; <nl> + assertTrue ( " Invalid sid " , Advapi32 . INSTANCE . EqualSid ( sid1 . getValue ( ) , sid2 . getValue ( ) ) ) ; <nl> + } finally { <nl> + Kernel32Util . freeLocalMemory ( sid1 . getValue ( ) . getPointer ( ) ) ; <nl> + Kernel32Util . freeLocalMemory ( sid2 . getValue ( ) . getPointer ( ) ) ; <nl> + } <nl> + } <nl> + <nl> public void testGetSidLength ( ) { <nl> 	 String sidString = EVERYONE ; <nl> 	 PSIDByReference sid = new PSIDByReference ( ) ; <nl> @ @ - 674 , 6 + 695 , 131 @ @ public class Advapi32Test extends TestCase { <nl> 	 } <nl> } <nl> <nl> + public void testInitializeSecurityDescriptor ( ) { <nl> + SECURITY _ DESCRIPTOR sd = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( sd , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; <nl> + } <nl> + <nl> + public void testInitializeAcl ( ) throws IOException { <nl> + ACL pAcl ; <nl> + int cbAcl = 0 ; <nl> + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + assertTrue ( " Failed to create well - known SID " , <nl> + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; <nl> + <nl> + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; <nl> + cbAcl = Native . getNativeSize ( ACL . class , null ) ; <nl> + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; <nl> + cbAcl + = ( sidLength - DWORD . SIZE ) ; <nl> + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; <nl> + pAcl = new ACL ( cbAcl ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; <nl> + } <nl> + <nl> + public void testGetAce ( ) throws IOException { <nl> + ACL pAcl ; <nl> + int cbAcl = 0 ; <nl> + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + assertTrue ( " Failed to create well - known SID " , <nl> + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; <nl> + <nl> + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; <nl> + cbAcl = Native . getNativeSize ( ACL . class , null ) ; <nl> + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; <nl> + cbAcl + = ( sidLength - DWORD . SIZE ) ; <nl> + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; <nl> + pAcl = new ACL ( cbAcl ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . AddAccessAllowedAce ( pAcl , WinNT . ACL _ REVISION , WinNT . STANDARD _ RIGHTS _ ALL , pSid ) ) ; <nl> + <nl> + PointerByReference pAce = new PointerByReference ( new Memory ( 16 ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . GetAce ( pAcl , 0 , pAce ) ) ; <nl> + ACCESS _ ALLOWED _ ACE pAceGet = new ACCESS _ ALLOWED _ ACE ( pAce . getValue ( ) ) ; <nl> + assertTrue ( pAceGet . Mask = = WinNT . STANDARD _ RIGHTS _ ALL ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EqualSid ( pAceGet . psid , pSid ) ) ; <nl> + } <nl> + <nl> + public void testAddAce ( ) throws IOException { <nl> + ACL pAcl ; <nl> + int cbAcl = 0 ; <nl> + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + assertTrue ( " Failed to create well - known SID " , <nl> + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; <nl> + <nl> + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; <nl> + cbAcl = Native . getNativeSize ( ACL . class , null ) ; <nl> + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; <nl> + cbAcl + = ( sidLength - DWORD . SIZE ) ; <nl> + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; <nl> + pAcl = new ACL ( cbAcl ) ; <nl> + int cbAce = Advapi32Util . getAceSize ( sidLength ) ; <nl> + ACCESS _ ALLOWED _ ACE pace = new ACCESS _ ALLOWED _ ACE ( WinNT . STANDARD _ RIGHTS _ ALL , <nl> + Advapi32Util . getSidStart ( pSid ) , <nl> + WinNT . INHERITED _ ACE , <nl> + ( short ) cbAce , <nl> + pSid ) ; <nl> + <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . AddAce ( pAcl , WinNT . ACL _ REVISION , WinNT . MAXDWORD , pace . getPointer ( ) , cbAce ) ) ; <nl> + <nl> + PointerByReference pAce = new PointerByReference ( new Memory ( 16 ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . GetAce ( pAcl , 0 , pAce ) ) ; <nl> + ACCESS _ ALLOWED _ ACE pAceGet = new ACCESS _ ALLOWED _ ACE ( pAce . getValue ( ) ) ; <nl> + assertTrue ( pAceGet . Mask = = WinNT . STANDARD _ RIGHTS _ ALL ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EqualSid ( pAceGet . psid , pSid ) ) ; <nl> + } <nl> + <nl> + public void testAddAccessAllowedAce ( ) throws IOException { <nl> + ACL pAcl ; <nl> + int cbAcl = 0 ; <nl> + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + assertTrue ( " Failed to create well - known SID " , <nl> + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; <nl> + <nl> + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; <nl> + cbAcl = Native . getNativeSize ( ACL . class , null ) ; <nl> + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; <nl> + cbAcl + = ( sidLength - DWORD . SIZE ) ; <nl> + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; <nl> + pAcl = new ACL ( cbAcl ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . AddAccessAllowedAce ( pAcl , WinNT . ACL _ REVISION , WinNT . STANDARD _ RIGHTS _ ALL , pSid ) ) ; <nl> + <nl> + PointerByReference pAce = new PointerByReference ( new Memory ( 16 ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . GetAce ( pAcl , 0 , pAce ) ) ; <nl> + ACCESS _ ALLOWED _ ACE pAceGet = new ACCESS _ ALLOWED _ ACE ( pAce . getValue ( ) ) ; <nl> + assertTrue ( pAceGet . Mask = = WinNT . STANDARD _ RIGHTS _ ALL ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EqualSid ( pAceGet . psid , pSid ) ) ; <nl> + } <nl> + <nl> + public void testAddAccessAllowedAceEx ( ) throws IOException { <nl> + ACL pAcl ; <nl> + int cbAcl = 0 ; <nl> + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; <nl> + assertTrue ( " Failed to create well - known SID " , <nl> + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; <nl> + <nl> + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; <nl> + cbAcl = Native . getNativeSize ( ACL . class , null ) ; <nl> + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; <nl> + cbAcl + = ( sidLength - DWORD . SIZE ) ; <nl> + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; <nl> + pAcl = new ACL ( cbAcl ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . AddAccessAllowedAceEx ( pAcl , WinNT . ACL _ REVISION , WinNT . INHERIT _ ONLY _ ACE , WinNT . STANDARD _ RIGHTS _ ALL , pSid ) ) ; <nl> + <nl> + PointerByReference pAce = new PointerByReference ( new Memory ( 16 ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . GetAce ( pAcl , 0 , pAce ) ) ; <nl> + ACCESS _ ALLOWED _ ACE pAceGet = new ACCESS _ ALLOWED _ ACE ( pAce . getValue ( ) ) ; <nl> + assertTrue ( pAceGet . Mask = = WinNT . STANDARD _ RIGHTS _ ALL ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EqualSid ( pAceGet . psid , pSid ) ) ; <nl> + } <nl> + <nl> public void testOpenEventLog ( ) { <nl> 	 HANDLE h = Advapi32 . INSTANCE . OpenEventLog ( null , " Application " ) ; <nl> 	 assertNotNull ( h ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 index fcbbad8 . . dd2c300 100755 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 @ @ - 35 , 12 + 35 , 14 @ @ import com . sun . jna . platform . win32 . WinDef . BOOLByReference ; 
 import com . sun . jna . platform . win32 . WinDef . DWORD ; 
 import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; 
 import com . sun . jna . platform . win32 . WinDef . ULONG ; 
 + import com . sun . jna . platform . win32 . WinNT . ACL ; 
 import com . sun . jna . platform . win32 . WinNT . GENERIC _ MAPPING ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; 
 import com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; 
 import com . sun . jna . platform . win32 . WinNT . PSID ; 
 import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; 
 + import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR ; 
 import com . sun . jna . platform . win32 . WinReg . HKEY ; 
 import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 import com . sun . jna . platform . win32 . Winsvc . ChangeServiceConfig2Info ; 
 @ @ - 249 , 6 + 251 , 20 @ @ public interface Advapi32 extends StdCallLibrary { 
 boolean IsValidSid ( PSID pSid ) ; 
 
 / * * 
 + * he EqualSid function tests two security identifier ( SID ) values for equality . 
 + * Two SIDs must match exactly to be considered equal . 
 + * @ param pSid1 
 + * A pointer to the first SID structure to compare . This structure is assumed to be valid . 
 + * @ param pSid2 
 + * A pointer to the second SID structure to compare . This structure is assumed to be valid . 
 + * @ return If the SID structures are equal , the return value is nonzero . 
 + * If the SID structures are not equal , the return value is zero . To get extended error 
 + * information , call GetLastError . 
 + * If either SID structure is not valid , the return value is undefined . 
 + * / 
 + boolean EqualSid ( PSID pSid1 , PSID pSid2 ) ; 
 + 
 + / * * 
 * Compares a SID to a well known SID and returns TRUE if they match . 
 * 
 * @ param pSid 
 @ @ - 284 , 6 + 300 , 121 @ @ public interface Advapi32 extends StdCallLibrary { 
 PSID pSid , IntByReference cbSid ) ; 
 
 / * * 
 + * The InitializeSecurityDescriptor function initializes a new security descriptor . 
 + * @ param pSecurityDescriptor 
 + * A pointer to a SECURITY _ DESCRIPTOR structure that the function initializes . 
 + * @ param dwRevision 
 + * The revision level to assign to the security descriptor . This parameter 
 + * must be SECURITY _ DESCRIPTOR _ REVISION . 
 + * @ return If the function succeeds , the return value is nonzero . If the 
 + * function fails , the return value is zero . For extended error 
 + * information , call GetLastError . 
 + * / 
 + boolean InitializeSecurityDescriptor ( SECURITY _ DESCRIPTOR pSecurityDescriptor , int dwRevision ) ; 
 + 
 + / * * 
 + * The InitializeAcl function initializes a new ACL structure . 
 + * @ param pAcl 
 + * A pointer to an ACL structure to be initialized by this function . 
 + * Allocate memory for pAcl before calling this function . 
 + * @ param nAclLength 
 + * The length , in bytes , of the buffer pointed to by the pAcl parameter . This value 
 + * must be large enough to contain the ACL header and all of the access control 
 + * entries ( ACEs ) to be stored in the ACL . In addition , this value must be 
 + * DWORD - aligned . For more information about calculating the size of an ACL , 
 + * see Remarks . 
 + * @ param dwAclRevision 
 + * The revision level of the ACL structure being created . This value can be ACL _ REVISION 
 + * or ACL _ REVISION _ DS . Use ACL _ REVISION _ DS if the access control list ( ACL ) supports 
 + * object - specific ACEs . 
 + * @ return If the function succeeds , the return value is nonzero . If the 
 + * function fails , the return value is zero . For extended error 
 + * information , call GetLastError . 
 + * / 
 + boolean InitializeAcl ( ACL pAcl , int nAclLength , int dwAclRevision ) ; 
 + 
 + / * * 
 + * The AddAce function adds one or more access control entries ( ACEs ) to a specified access control list ( ACL ) . 
 + * @ param pAcl 
 + * A pointer to an ACL . This function adds an ACE to this ACL . 
 + * @ param dwAceRevision 
 + * Specifies the revision level of the ACL being modified . This value can be ACL _ REVISION or 
 + * ACL _ REVISION _ DS . Use ACL _ REVISION _ DS if the ACL contains object - specific ACEs . This value 
 + * must be compatible with the AceType field of all ACEs in pAceList . Otherwise , the function 
 + * will fail and set the last error to ERROR _ INVALID _ PARAMETER . 
 + * @ param dwStartingAceIndex 
 + * Specifies the position in the ACL ' s list of ACEs at which to add new ACEs . A value of zero 
 + * inserts the ACEs at the beginning of the list . A value of MAXDWORD appends the ACEs to the end 
 + * of the list . 
 + * @ param pAceList 
 + * A pointer to a list of one or more ACEs to be added to the specified ACL . The ACEs in the list 
 + * must be stored contiguously . 
 + * @ param nAceListLength 
 + * Specifies the size , in bytes , of the input buffer pointed to by the pAceList parameter . 
 + * @ return If the function succeeds , the return value is nonzero . If the 
 + * function fails , the return value is zero . For extended error 
 + * information , call GetLastError . 
 + * / 
 + boolean AddAce ( ACL pAcl , int dwAceRevision , int dwStartingAceIndex , Pointer pAceList , int nAceListLength ) ; 
 + 
 + / * * 
 + * The AddAce function adds one or more access control entries ( ACEs ) to a specified access control list ( ACL ) . 
 + * @ param pAcl 
 + * A pointer to an ACL . This function adds an access - allowed ACE to the end of this ACL . 
 + * The ACE is in the form of an ACCESS _ ALLOWED _ ACE structure . 
 + * @ param dwAceRevision 
 + * Specifies the revision level of the ACL being modified . This value can be ACL _ REVISION or 
 + * ACL _ REVISION _ DS . Use ACL _ REVISION _ DS if the ACL contains object - specific ACEs . 
 + * @ param AccessMask 
 + * Specifies the mask of access rights to be granted to the specified SID . 
 + * @ param pSid 
 + * A pointer to the SID representing a user , group , or logon account being granted access . 
 + * @ return If the function succeeds , the return value is nonzero . If the 
 + * function fails , the return value is zero . For extended error 
 + * information , call GetLastError . 
 + * / 
 + boolean AddAccessAllowedAce ( ACL pAcl , int dwAceRevision , int AccessMask , PSID pSid ) ; 
 + 
 + / * * 
 + * The AddAce function adds one or more access control entries ( ACEs ) to a specified access control list ( ACL ) . 
 + * @ param pAcl 
 + * A pointer to an ACL . This function adds an access - allowed ACE to the end of this ACL . 
 + * The ACE is in the form of an ACCESS _ ALLOWED _ ACE structure . 
 + * @ param dwAceRevision 
 + * Specifies the revision level of the ACL being modified . This value can be ACL _ REVISION or 
 + * ACL _ REVISION _ DS . Use ACL _ REVISION _ DS if the ACL contains object - specific ACEs . 
 + * @ param AceFlags 
 + * A set of bit flags that control ACE inheritance . The function sets these flags in the AceFlags 
 + * member of the ACE _ HEADER structure of the new ACE . This parameter can be a combination 
 + * of the following values : CONTAINER _ INHERIT _ ACE , INHERIT _ ONLY _ ACE , INHERITED _ ACE , 
 + * NO _ PROPAGATE _ INHERIT _ ACE , and OBJECT _ INHERIT _ ACE 
 + * @ param AccessMask 
 + * Specifies the mask of access rights to be granted to the specified SID . 
 + * @ param pSid 
 + * A pointer to the SID representing a user , group , or logon account being granted access . 
 + * @ return If the function succeeds , the return value is nonzero . If the 
 + * function fails , the return value is zero . For extended error 
 + * information , call GetLastError . 
 + * / 
 + boolean AddAccessAllowedAceEx ( ACL pAcl , int dwAceRevision , int AceFlags , int AccessMask , PSID pSid ) ; 
 + 
 + / * * 
 + * The GetAce function obtains a pointer to an access control entry ( ACE ) in an access 
 + * control list ( ACL ) . 
 + * @ param pAcl 
 + * A pointer to an ACL that contains the ACE to be retrieved . 
 + * @ param dwAceIndex 
 + * The index of the ACE to be retrieved . A value of zero corresponds to the first ACE in 
 + * the ACL , a value of one to the second ACE , and so on . 
 + * @ param pAce 
 + * A pointer to a pointer that the function sets to the address of the ACE . 
 + * @ return If the function succeeds , the return value is nonzero . If the 
 + * function fails , the return value is zero . For extended error 
 + * information , call GetLastError . 
 + * / 
 + boolean GetAce ( ACL pAcl , int dwAceIndex , PointerByReference pAce ) ; 
 + 
 + / * * 
 * The LogonUser function attempts to log a user on to the local computer . 
 * The local computer is the computer from which LogonUser was called . You 
 * cannot use LogonUser to log on to a remote computer . You specify the user 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 index 7715451 . . ff317e6 100755 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 @ @ - 47 , 7 + 47 , 9 @ @ import static com . sun . jna . platform . win32 . WinNT . TOKEN _ QUERY ; 
 import static com . sun . jna . platform . win32 . WinNT . UNPROTECTED _ DACL _ SECURITY _ INFORMATION ; 
 import static com . sun . jna . platform . win32 . WinNT . UNPROTECTED _ SACL _ SECURITY _ INFORMATION ; 
 
 + import java . io . ByteArrayInputStream ; 
 import java . io . ByteArrayOutputStream ; 
 + import java . io . DataInputStream ; 
 import java . io . File ; 
 import java . io . IOException ; 
 import java . util . ArrayList ; 
 @ @ - 69 , 6 + 71 , 7 @ @ import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; 
 import com . sun . jna . platform . win32 . WinDef . ULONG ; 
 import com . sun . jna . platform . win32 . WinDef . ULONGByReference ; 
 import com . sun . jna . platform . win32 . WinNT . ACCESS _ ACEStructure ; 
 + import com . sun . jna . platform . win32 . WinNT . ACCESS _ ALLOWED _ ACE ; 
 import com . sun . jna . platform . win32 . WinNT . ACL ; 
 import com . sun . jna . platform . win32 . WinNT . EVENTLOGRECORD ; 
 import com . sun . jna . platform . win32 . WinNT . GENERIC _ MAPPING ; 
 @ @ - 377 , 6 + 380 , 38 @ @ public abstract class Advapi32Util { 
 	 	 return Advapi32 . INSTANCE . IsWellKnownSid ( pSID , wellKnownSidType ) ; 
 	 } 
 
 + / * * 
 + * Align cbAcl on a DWORD 
 + * @ param cbAcl size to align 
 + * @ return the aligned size 
 + * / 
 + public static int alignOnDWORD ( int cbAcl ) { 
 + return ( cbAcl + ( DWORD . SIZE - 1 ) ) & 0xfffffffc ; 
 + } 
 + 
 + 	 / * * 
 + * Helper function to calculate the size of an ACE for a given PSID size 
 + * @ param pSid the PSID 
 + * @ return size of the ACE 
 + * / 
 + public static int getAceSize ( int sidLength ) { 
 + return Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) 
 + + sidLength 
 + - DWORD . SIZE ; 
 + } 
 + 
 + / * * 
 + * Get the first 4 bytes of the PSID for a SidStart 
 + * @ param psid the PSID 
 + * @ return the SidStart 
 + * @ throws IOException 
 + * / 
 + public static int getSidStart ( PSID psid ) throws IOException { 
 + byte [ ] sidStart = psid . getBytes ( ) ; 
 + DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( sidStart ) ) ; 
 + return dis . readInt ( ) ; 
 + } 
 + 
 	 / * * 
 	 * Get an account name from a string SID on the local machine . 
 	 * 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 index 8290369 . . b09124c 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinNT . java 
 @ @ - 50 , 6 + 50 , 15 @ @ import com . sun . jna . win32 . StdCallLibrary . StdCallCallback ; 
 @ SuppressWarnings ( " serial " ) 
 public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 
 + int MINCHAR = 0x80 ; 
 + int MAXCHAR = 0x7f ; 
 + int MINSHORT = 0x8000 ; 
 + int MAXSHORT = 0x7fff ; 
 + int MINLONG = 0x80000000 ; 
 + int MAXLONG = 0x7fffffff ; 
 + int MAXBYTE = 0xff ; 
 + int MAXWORD = 0xffff ; 
 + int MAXDWORD = 0xffffffff ; 
 / / 
 / / The following are masks for the predefined standard access types 
 / / 
 @ @ - 2462 , 6 + 2471 , 7 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 int SE _ RM _ CONTROL _ VALID = 0x00004000 ; 
 int SE _ SELF _ RELATIVE = 0x00008000 ; 
 
 + int SECURITY _ DESCRIPTOR _ REVISION = 0x00000001 ; 
 
 public static class SECURITY _ DESCRIPTOR extends Structure { 
 public static class ByReference extends SECURITY _ DESCRIPTOR implements 
 @ @ - 2480 , 6 + 2490 , 12 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 useMemory ( new Memory ( data . length ) ) ; 
 } 
 
 + public SECURITY _ DESCRIPTOR ( int size ) { 
 + super ( ) ; 
 + useMemory ( new Memory ( size ) ) ; 
 + data = new byte [ size ] ; 
 + } 
 + 
 public SECURITY _ DESCRIPTOR ( Pointer memory ) { 
 super ( memory ) ; 
 read ( ) ; 
 @ @ - 2491 , 6 + 2507 , 18 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 } 
 } 
 
 + int ACL _ REVISION = 2 ; 
 + int ACL _ REVISION _ DS = 4 ; 
 + 
 + / / This is the history of ACL revisions . Add a new one whenever 
 + / / ACL _ REVISION is updated 
 + int ACL _ REVISION1 = 1 ; 
 + int ACL _ REVISION2 = 2 ; 
 + int ACL _ REVISION3 = 3 ; 
 + int ACL _ REVISION4 = 4 ; 
 + int MIN _ ACL _ REVISION = ACL _ REVISION2 ; 
 + int MAX _ ACL _ REVISION = ACL _ REVISION4 ; 
 + 
 public static class ACL extends Structure { 
 public static final List < String > FIELDS = createFieldsOrder ( " AclRevision " , " Sbz1 " , " AclSize " , " AceCount " , " Sbz2 " ) ; 
 
 @ @ - 2506 , 6 + 2534 , 11 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 super ( ) ; 
 } 
 
 + public ACL ( int size ) { 
 + super ( ) ; 
 + useMemory ( new Memory ( size ) ) ; 
 + } 
 + 
 public ACL ( Pointer pointer ) { 
 super ( pointer ) ; 
 read ( ) ; 
 @ @ - 2631 , 6 + 2664 , 15 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 super ( p ) ; 
 } 
 
 + public ACEStructure ( byte AceType , byte AceFlags , short AceSize , PSID psid ) { 
 + super ( ) ; 
 + this . AceType = AceType ; 
 + this . AceFlags = AceFlags ; 
 + this . AceSize = AceSize ; 
 + this . psid = psid ; 
 + write ( ) ; 
 + } 
 + 
 public String getSidString ( ) { 
 return Advapi32Util . convertSidToStringSid ( psid ) ; 
 } 
 @ @ - 2686 , 16 + 2728 , 49 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 super ( ) ; 
 } 
 
 + public ACCESS _ ACEStructure ( int Mask , int SidStart , byte AceType , byte AceFlags , short AceSize , PSID psid ) { 
 + super ( ) ; 
 + this . allocateMemory ( AceSize ) ; 
 + this . AceType = AceType ; 
 + this . AceFlags = AceFlags ; 
 + this . AceSize = AceSize ; 
 + this . psid = psid ; 
 + this . Mask = Mask ; 
 + this . SidStart = new DWORD ( SidStart ) ; 
 + write ( ) ; 
 + } 
 + 
 public ACCESS _ ACEStructure ( Pointer p ) { 
 super ( p ) ; 
 read ( ) ; 
 - / / AceSize - size of public members of the structure + size of DWORD 
 - / / ( SidStart ) 
 + / / Check for AceSize being zero , can happen on empty memory 
 + if ( AceSize ! = 0 ) { 
 int sizeOfSID = super . AceSize - size ( ) + 4 ; 
 - / / ACE _ HEADER + size of int ( Mask ) 
 + / / ACE _ HEADER + size of int ( Mask ) 
 + int offsetOfSID = 4 + 4 ; 
 + byte [ ] data = p . getByteArray ( offsetOfSID , sizeOfSID ) ; 
 + psid = new PSID ( data ) ; 
 + } 
 + else { 
 + psid = null ; 
 + } 
 + } 
 + 
 + / * * 
 + * Write override due to psid not being a managed field 
 + * / 
 + @ Override 
 + public void write ( ) { 
 + int sizeOfSID = super . AceSize - 8 ; 
 int offsetOfSID = 4 + 4 ; 
 - byte [ ] data = p . getByteArray ( offsetOfSID , sizeOfSID ) ; 
 - psid = new PSID ( data ) ; 
 + super . writeField ( " AceType " ) ; 
 + super . writeField ( " AceFlags " ) ; 
 + super . writeField ( " AceSize " ) ; 
 + super . writeField ( " Mask " ) ; 
 + / / Get bytes from the PSID 
 + byte [ ] psidWrite = psid . getPointer ( ) . getByteArray ( 0 , sizeOfSID ) ; 
 + / / Write those bytes to native memory 
 + super . getPointer ( ) . write ( offsetOfSID , psidWrite , 0 , sizeOfSID ) ; 
 } 
 
 @ Override 
 @ @ - 2713 , 6 + 2788 , 10 @ @ public interface WinNT extends WinError , WinDef , WinBase , BaseTSD { 
 public ACCESS _ ALLOWED _ ACE ( Pointer p ) { 
 super ( p ) ; 
 } 
 + 
 + public ACCESS _ ALLOWED _ ACE ( int Mask , int SidStart , byte AceFlags , short AceSize , PSID psid ) { 
 + super ( Mask , SidStart , ACCESS _ ALLOWED _ ACE _ TYPE , AceFlags , AceSize , psid ) ; 
 + } 
 } 
 
 / * Access denied ACE * / 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 index beaeef3 . . 78810d3 100755 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 @ @ - 55 , 6 + 55 , 9 @ @ import com . sun . jna . platform . win32 . WinDef . DWORD ; 
 import com . sun . jna . platform . win32 . WinDef . DWORDByReference ; 
 import com . sun . jna . platform . win32 . WinDef . ULONG ; 
 import com . sun . jna . platform . win32 . WinDef . ULONGByReference ; 
 + import com . sun . jna . platform . win32 . WinNT . ACCESS _ ACEStructure ; 
 + import com . sun . jna . platform . win32 . WinNT . ACCESS _ ALLOWED _ ACE ; 
 + import com . sun . jna . platform . win32 . WinNT . ACL ; 
 import com . sun . jna . platform . win32 . WinNT . EVENTLOGRECORD ; 
 import com . sun . jna . platform . win32 . WinNT . GENERIC _ MAPPING ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 @ @ - 62 , 6 + 65 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; 
 import com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; 
 import com . sun . jna . platform . win32 . WinNT . PSID ; 
 import com . sun . jna . platform . win32 . WinNT . PSIDByReference ; 
 + import com . sun . jna . platform . win32 . WinNT . SECURITY _ DESCRIPTOR ; 
 import com . sun . jna . platform . win32 . WinNT . SECURITY _ IMPERSONATION _ LEVEL ; 
 import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; 
 import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; 
 @ @ - 149 , 6 + 153 , 23 @ @ public class Advapi32Test extends TestCase { 
 	 } 
 } 
 
 + public void testEqualSid ( ) { 
 + String sidString = EVERYONE ; 
 + PSIDByReference sid1 = new PSIDByReference ( ) ; 
 + PSIDByReference sid2 = new PSIDByReference ( ) ; 
 + assertTrue ( " SID1 conversion failed " , Advapi32 . INSTANCE . ConvertStringSidToSid ( sidString , sid1 ) ) ; 
 + assertTrue ( " SID2 conversion failed " , Advapi32 . INSTANCE . ConvertStringSidToSid ( sidString , sid2 ) ) ; 
 + 
 + try { 
 + assertTrue ( " Converted SID1 not valid " , Advapi32 . INSTANCE . IsValidSid ( sid1 . getValue ( ) ) ) ; 
 + assertTrue ( " Converted SID2 not valid " , Advapi32 . INSTANCE . IsValidSid ( sid2 . getValue ( ) ) ) ; 
 + assertTrue ( " Invalid sid " , Advapi32 . INSTANCE . EqualSid ( sid1 . getValue ( ) , sid2 . getValue ( ) ) ) ; 
 + } finally { 
 + Kernel32Util . freeLocalMemory ( sid1 . getValue ( ) . getPointer ( ) ) ; 
 + Kernel32Util . freeLocalMemory ( sid2 . getValue ( ) . getPointer ( ) ) ; 
 + } 
 + } 
 + 
 public void testGetSidLength ( ) { 
 	 String sidString = EVERYONE ; 
 	 PSIDByReference sid = new PSIDByReference ( ) ; 
 @ @ - 674 , 6 + 695 , 131 @ @ public class Advapi32Test extends TestCase { 
 	 } 
 } 
 
 + public void testInitializeSecurityDescriptor ( ) { 
 + SECURITY _ DESCRIPTOR sd = new SECURITY _ DESCRIPTOR ( 64 * 1024 ) ; 
 + assertTrue ( Advapi32 . INSTANCE . InitializeSecurityDescriptor ( sd , WinNT . SECURITY _ DESCRIPTOR _ REVISION ) ) ; 
 + } 
 + 
 + public void testInitializeAcl ( ) throws IOException { 
 + ACL pAcl ; 
 + int cbAcl = 0 ; 
 + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + assertTrue ( " Failed to create well - known SID " , 
 + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; 
 + 
 + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; 
 + cbAcl = Native . getNativeSize ( ACL . class , null ) ; 
 + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; 
 + cbAcl + = ( sidLength - DWORD . SIZE ) ; 
 + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; 
 + pAcl = new ACL ( cbAcl ) ; 
 + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; 
 + } 
 + 
 + public void testGetAce ( ) throws IOException { 
 + ACL pAcl ; 
 + int cbAcl = 0 ; 
 + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + assertTrue ( " Failed to create well - known SID " , 
 + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; 
 + 
 + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; 
 + cbAcl = Native . getNativeSize ( ACL . class , null ) ; 
 + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; 
 + cbAcl + = ( sidLength - DWORD . SIZE ) ; 
 + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; 
 + pAcl = new ACL ( cbAcl ) ; 
 + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . AddAccessAllowedAce ( pAcl , WinNT . ACL _ REVISION , WinNT . STANDARD _ RIGHTS _ ALL , pSid ) ) ; 
 + 
 + PointerByReference pAce = new PointerByReference ( new Memory ( 16 ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . GetAce ( pAcl , 0 , pAce ) ) ; 
 + ACCESS _ ALLOWED _ ACE pAceGet = new ACCESS _ ALLOWED _ ACE ( pAce . getValue ( ) ) ; 
 + assertTrue ( pAceGet . Mask = = WinNT . STANDARD _ RIGHTS _ ALL ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EqualSid ( pAceGet . psid , pSid ) ) ; 
 + } 
 + 
 + public void testAddAce ( ) throws IOException { 
 + ACL pAcl ; 
 + int cbAcl = 0 ; 
 + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + assertTrue ( " Failed to create well - known SID " , 
 + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; 
 + 
 + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; 
 + cbAcl = Native . getNativeSize ( ACL . class , null ) ; 
 + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; 
 + cbAcl + = ( sidLength - DWORD . SIZE ) ; 
 + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; 
 + pAcl = new ACL ( cbAcl ) ; 
 + int cbAce = Advapi32Util . getAceSize ( sidLength ) ; 
 + ACCESS _ ALLOWED _ ACE pace = new ACCESS _ ALLOWED _ ACE ( WinNT . STANDARD _ RIGHTS _ ALL , 
 + Advapi32Util . getSidStart ( pSid ) , 
 + WinNT . INHERITED _ ACE , 
 + ( short ) cbAce , 
 + pSid ) ; 
 + 
 + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . AddAce ( pAcl , WinNT . ACL _ REVISION , WinNT . MAXDWORD , pace . getPointer ( ) , cbAce ) ) ; 
 + 
 + PointerByReference pAce = new PointerByReference ( new Memory ( 16 ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . GetAce ( pAcl , 0 , pAce ) ) ; 
 + ACCESS _ ALLOWED _ ACE pAceGet = new ACCESS _ ALLOWED _ ACE ( pAce . getValue ( ) ) ; 
 + assertTrue ( pAceGet . Mask = = WinNT . STANDARD _ RIGHTS _ ALL ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EqualSid ( pAceGet . psid , pSid ) ) ; 
 + } 
 + 
 + public void testAddAccessAllowedAce ( ) throws IOException { 
 + ACL pAcl ; 
 + int cbAcl = 0 ; 
 + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + assertTrue ( " Failed to create well - known SID " , 
 + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; 
 + 
 + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; 
 + cbAcl = Native . getNativeSize ( ACL . class , null ) ; 
 + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; 
 + cbAcl + = ( sidLength - DWORD . SIZE ) ; 
 + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; 
 + pAcl = new ACL ( cbAcl ) ; 
 + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . AddAccessAllowedAce ( pAcl , WinNT . ACL _ REVISION , WinNT . STANDARD _ RIGHTS _ ALL , pSid ) ) ; 
 + 
 + PointerByReference pAce = new PointerByReference ( new Memory ( 16 ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . GetAce ( pAcl , 0 , pAce ) ) ; 
 + ACCESS _ ALLOWED _ ACE pAceGet = new ACCESS _ ALLOWED _ ACE ( pAce . getValue ( ) ) ; 
 + assertTrue ( pAceGet . Mask = = WinNT . STANDARD _ RIGHTS _ ALL ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EqualSid ( pAceGet . psid , pSid ) ) ; 
 + } 
 + 
 + public void testAddAccessAllowedAceEx ( ) throws IOException { 
 + ACL pAcl ; 
 + int cbAcl = 0 ; 
 + PSID pSid = new PSID ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + IntByReference cbSid = new IntByReference ( WinNT . SECURITY _ MAX _ SID _ SIZE ) ; 
 + assertTrue ( " Failed to create well - known SID " , 
 + Advapi32 . INSTANCE . CreateWellKnownSid ( WELL _ KNOWN _ SID _ TYPE . WinBuiltinAdministratorsSid , null , pSid , cbSid ) ) ; 
 + 
 + int sidLength = Advapi32 . INSTANCE . GetLengthSid ( pSid ) ; 
 + cbAcl = Native . getNativeSize ( ACL . class , null ) ; 
 + cbAcl + = Native . getNativeSize ( ACCESS _ ALLOWED _ ACE . class , null ) ; 
 + cbAcl + = ( sidLength - DWORD . SIZE ) ; 
 + cbAcl = Advapi32Util . alignOnDWORD ( cbAcl ) ; 
 + pAcl = new ACL ( cbAcl ) ; 
 + assertTrue ( Advapi32 . INSTANCE . InitializeAcl ( pAcl , cbAcl , WinNT . ACL _ REVISION ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . AddAccessAllowedAceEx ( pAcl , WinNT . ACL _ REVISION , WinNT . INHERIT _ ONLY _ ACE , WinNT . STANDARD _ RIGHTS _ ALL , pSid ) ) ; 
 + 
 + PointerByReference pAce = new PointerByReference ( new Memory ( 16 ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . GetAce ( pAcl , 0 , pAce ) ) ; 
 + ACCESS _ ALLOWED _ ACE pAceGet = new ACCESS _ ALLOWED _ ACE ( pAce . getValue ( ) ) ; 
 + assertTrue ( pAceGet . Mask = = WinNT . STANDARD _ RIGHTS _ ALL ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EqualSid ( pAceGet . psid , pSid ) ) ; 
 + } 
 + 
 public void testOpenEventLog ( ) { 
 	 HANDLE h = Advapi32 . INSTANCE . OpenEventLog ( null , " Application " ) ; 
 	 assertNotNull ( h ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
