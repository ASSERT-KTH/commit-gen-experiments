BLEU SCORE: 0.07986788803078405

TEST MSG: Update FrequentlyAskedQuestions . md
GENERATED MSG: update front page

TEST DIFF (one line): diff - - git a / www / FrequentlyAskedQuestions . md b / www / FrequentlyAskedQuestions . md <nl> index 2ed4d47 . . f41a5d6 100644 <nl> - - - a / www / FrequentlyAskedQuestions . md <nl> + + + b / www / FrequentlyAskedQuestions . md <nl> @ @ - 169 , 3 + 169 , 6 @ @ The calling overhead for a single native call using JNA interface mapping can be <nl> <nl> You might expect a speedup of about an order of magnitude moving to JNA direct mapping , and a factor of two or three moving from there to custom JNI . The actual difference will vary depending on usage and function signatures . As with any optimization process , you should determine first where you need a speed increase , and then see how much difference there is by performing targeted optimizations . The ease of programming everything in Java usually outweighs small performance gains when using custom JNI . <nl> <nl> + JNA COM support <nl> + - - - - - - - - - - - - - - - <nl> + There is a new implementation to support COM in conjunction with JNA directly . The development is relatively young , honestly the development has been finished just end of February ' 13 . Please note that fact if you use the COM support in JNA , there could be things missing or not absolutely tested or still not working . Please use the jna user group to report your experience with the JNA Com support .
NEAREST DIFF (one line): diff - - git a / libffi / ChangeLog . libffi b / libffi / ChangeLog . libffi <nl> index 6bbdfb6 . . f4d8c13 100644 <nl> - - - a / libffi / ChangeLog . libffi <nl> + + + b / libffi / ChangeLog . libffi <nl> @ @ - 1 , 5 + 1 , 9 @ @ <nl> 2009 - 06 - 04 Andrew Haley < aph @ redhat . com > <nl> <nl> + 	 * src / powerpc / ffitarget . h : Fix misapplied merge from gcc . <nl> + <nl> + 2009 - 06 - 04 Andrew Haley < aph @ redhat . com > <nl> + <nl> 	 * src / mips / o32 . S , <nl> 	 src / mips / n32 . S : Fix licence formatting . <nl> <nl> diff - - git a / libffi / src / powerpc / ffitarget . h b / libffi / src / powerpc / ffitarget . h <nl> index 38b7820 . . 269f573 100644 <nl> - - - a / libffi / src / powerpc / ffitarget . h <nl> + + + b / libffi / src / powerpc / ffitarget . h <nl> @ @ - 95 , 12 + 95 , 12 @ @ typedef enum ffi _ abi { <nl> / * For additional types like the below , take care about the order in <nl> ppc _ closures . S . They must follow after the FFI _ TYPE _ LAST . * / <nl> <nl> + / * Needed for soft - float long - double - 128 support . * / <nl> + # define FFI _ TYPE _ UINT128 ( FFI _ TYPE _ LAST + 1 ) <nl> + <nl> / * Needed for FFI _ SYSV small structure returns . <nl> We use two flag bits , ( FLAG _ SYSV _ SMST _ R3 , FLAG _ SYSV _ SMST _ R4 ) which are <nl> defined in ffi . c , to determine the exact return type and its size . * / <nl> - # define FFI _ TYPE _ UINT128 ( FFI _ TYPE _ LAST + 1 ) <nl> - <nl> - / * Needed for FFI _ SYSV small structure returns . * / <nl> # define FFI _ SYSV _ TYPE _ SMALL _ STRUCT ( FFI _ TYPE _ LAST + 2 ) <nl> <nl> # if defined ( POWERPC64 ) | | defined ( POWERPC _ AIX )

TEST DIFF:
diff - - git a / www / FrequentlyAskedQuestions . md b / www / FrequentlyAskedQuestions . md 
 index 2ed4d47 . . f41a5d6 100644 
 - - - a / www / FrequentlyAskedQuestions . md 
 + + + b / www / FrequentlyAskedQuestions . md 
 @ @ - 169 , 3 + 169 , 6 @ @ The calling overhead for a single native call using JNA interface mapping can be 
 
 You might expect a speedup of about an order of magnitude moving to JNA direct mapping , and a factor of two or three moving from there to custom JNI . The actual difference will vary depending on usage and function signatures . As with any optimization process , you should determine first where you need a speed increase , and then see how much difference there is by performing targeted optimizations . The ease of programming everything in Java usually outweighs small performance gains when using custom JNI . 
 
 + JNA COM support 
 + - - - - - - - - - - - - - - - 
 + There is a new implementation to support COM in conjunction with JNA directly . The development is relatively young , honestly the development has been finished just end of February ' 13 . Please note that fact if you use the COM support in JNA , there could be things missing or not absolutely tested or still not working . Please use the jna user group to report your experience with the JNA Com support .

NEAREST DIFF:
diff - - git a / libffi / ChangeLog . libffi b / libffi / ChangeLog . libffi 
 index 6bbdfb6 . . f4d8c13 100644 
 - - - a / libffi / ChangeLog . libffi 
 + + + b / libffi / ChangeLog . libffi 
 @ @ - 1 , 5 + 1 , 9 @ @ 
 2009 - 06 - 04 Andrew Haley < aph @ redhat . com > 
 
 + 	 * src / powerpc / ffitarget . h : Fix misapplied merge from gcc . 
 + 
 + 2009 - 06 - 04 Andrew Haley < aph @ redhat . com > 
 + 
 	 * src / mips / o32 . S , 
 	 src / mips / n32 . S : Fix licence formatting . 
 
 diff - - git a / libffi / src / powerpc / ffitarget . h b / libffi / src / powerpc / ffitarget . h 
 index 38b7820 . . 269f573 100644 
 - - - a / libffi / src / powerpc / ffitarget . h 
 + + + b / libffi / src / powerpc / ffitarget . h 
 @ @ - 95 , 12 + 95 , 12 @ @ typedef enum ffi _ abi { 
 / * For additional types like the below , take care about the order in 
 ppc _ closures . S . They must follow after the FFI _ TYPE _ LAST . * / 
 
 + / * Needed for soft - float long - double - 128 support . * / 
 + # define FFI _ TYPE _ UINT128 ( FFI _ TYPE _ LAST + 1 ) 
 + 
 / * Needed for FFI _ SYSV small structure returns . 
 We use two flag bits , ( FLAG _ SYSV _ SMST _ R3 , FLAG _ SYSV _ SMST _ R4 ) which are 
 defined in ffi . c , to determine the exact return type and its size . * / 
 - # define FFI _ TYPE _ UINT128 ( FFI _ TYPE _ LAST + 1 ) 
 - 
 - / * Needed for FFI _ SYSV small structure returns . * / 
 # define FFI _ SYSV _ TYPE _ SMALL _ STRUCT ( FFI _ TYPE _ LAST + 2 ) 
 
 # if defined ( POWERPC64 ) | | defined ( POWERPC _ AIX )
