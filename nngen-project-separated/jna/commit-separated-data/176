BLEU SCORE: 0.016932492841722675

TEST MSG: Ensure all tests pass when Native . DEFAULT _ ENCODING is Cp1252
GENERATED MSG: fix issue 111

TEST DIFF (one line): diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java <nl> index 4bcc773 . . e5b3436 100644 <nl> - - - a / test / com / sun / jna / CallbacksTest . java <nl> + + + b / test / com / sun / jna / CallbacksTest . java <nl> @ @ - 16 , 6 + 16 , 7 @ @ import java . io . ByteArrayOutputStream ; <nl> import java . io . PrintStream ; <nl> import java . lang . ref . Reference ; <nl> import java . lang . ref . WeakReference ; <nl> + import java . nio . charset . Charset ; <nl> import java . util . Arrays ; <nl> import java . util . Collections ; <nl> import java . util . HashSet ; <nl> @ @ - 652 , 8 + 653 , 9 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> return arg + arg2 ; <nl> } <nl> } ; <nl> - final String VALUE = " value " + UNICODE ; <nl> - final String VALUE2 = getName ( ) + UNICODE ; <nl> + Charset charset = Charset . forName ( Native . getDefaultStringEncoding ( ) ) ; <nl> + final String VALUE = " value " + charset . decode ( charset . encode ( UNICODE ) ) ; <nl> + final String VALUE2 = getName ( ) + charset . decode ( charset . encode ( UNICODE ) ) ; <nl> String value = lib . callStringCallback ( cb , VALUE , VALUE2 ) ; <nl> assertTrue ( " Callback not called " , called [ 0 ] ) ; <nl> assertEquals ( " Wrong String callback argument 0 " , VALUE , cbargs [ 0 ] ) ; <nl> @ @ - 673 , 8 + 675 , 9 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> Map < ? , ? > m = CallbackReference . allocations ; <nl> m . clear ( ) ; <nl> <nl> - String arg = getName ( ) + " 1 " + UNICODE ; <nl> - String arg2 = getName ( ) + " 2 " + UNICODE ; <nl> + Charset charset = Charset . forName ( Native . getDefaultStringEncoding ( ) ) ; <nl> + String arg = getName ( ) + " 1 " + charset . decode ( charset . encode ( UNICODE ) ) ; <nl> + String arg2 = getName ( ) + " 2 " + charset . decode ( charset . encode ( UNICODE ) ) ; <nl> String value = lib . callStringCallback ( cb , arg , arg2 ) ; <nl> WeakReference < Object > ref = new WeakReference < Object > ( value ) ; <nl> <nl> @ @ - 723 , 7 + 726 , 8 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> return arg ; <nl> } <nl> } ; <nl> - final String VALUE = " value " + UNICODE ; <nl> + Charset charset = Charset . forName ( Native . getDefaultStringEncoding ( ) ) ; <nl> + final String VALUE = " value " + charset . decode ( charset . encode ( UNICODE ) ) ; <nl> final String [ ] VALUE _ ARRAY = { VALUE , null } ; <nl> Pointer value = lib . callStringArrayCallback ( cb , VALUE _ ARRAY ) ; <nl> assertTrue ( " Callback not called " , called [ 0 ] ) ; <nl> @ @ - 795 , 7 + 799 , 8 @ @ public class CallbacksTest extends TestCase implements Paths { <nl> public void testUnionByValueCallbackArgument ( ) throws Exception { <nl> TestLibrary . TestUnion arg = new TestLibrary . TestUnion ( ) ; <nl> arg . setType ( String . class ) ; <nl> - final String VALUE = getName ( ) + UNICODE ; <nl> + Charset charset = Charset . forName ( arg . getStringEncoding ( ) ) ; <nl> + final String VALUE = getName ( ) + charset . decode ( charset . encode ( UNICODE ) ) ; <nl> arg . f1 = VALUE ; <nl> final boolean [ ] called = { false } ; <nl> final TestLibrary . TestUnion [ ] cbvalue = { null } ; <nl> diff - - git a / test / com / sun / jna / ReturnTypesTest . java b / test / com / sun / jna / ReturnTypesTest . java <nl> index 646ee22 . . 6afbd58 100644 <nl> - - - a / test / com / sun / jna / ReturnTypesTest . java <nl> + + + b / test / com / sun / jna / ReturnTypesTest . java <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * / <nl> package com . sun . jna ; <nl> <nl> + import java . nio . charset . Charset ; <nl> import java . util . Collections ; <nl> import java . util . List ; <nl> import junit . framework . TestCase ; <nl> @ @ - 314 , 7 + 315 , 8 @ @ public class ReturnTypesTest extends TestCase { <nl> } <nl> <nl> public void testReturnStringArray ( ) { <nl> - final String VALUE = getName ( ) + UNICODE ; <nl> + Charset charset = Charset . forName ( Native . getDefaultStringEncoding ( ) ) ; <nl> + final String VALUE = getName ( ) + charset . decode ( charset . encode ( UNICODE ) ) ; <nl> String [ ] input = { <nl> VALUE , null , <nl> } ; <nl> diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java <nl> index f2ef9a3 . . 833d057 100644 <nl> - - - a / test / com / sun / jna / StructureTest . java <nl> + + + b / test / com / sun / jna / StructureTest . java <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * / <nl> package com . sun . jna ; <nl> <nl> + import java . nio . charset . Charset ; <nl> import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> import java . util . Collections ; <nl> @ @ - 1084 , 9 + 1085 , 10 @ @ public class StructureTest extends TestCase { <nl> return Arrays . asList ( " inner " ) ; <nl> } <nl> } <nl> - final String VALUE = getName ( ) + UNICODE ; <nl> - final WString WVALUE = new WString ( VALUE ) ; <nl> StructureFromPointer o = new StructureFromPointer ( ) ; <nl> + Charset charset = Charset . forName ( o . getStringEncoding ( ) ) ; <nl> + final String VALUE = getName ( ) + charset . decode ( charset . encode ( UNICODE ) ) ; <nl> + final WString WVALUE = new WString ( VALUE ) ; <nl> o . s = VALUE ; <nl> o . ws = WVALUE ; <nl> o . write ( ) ;
NEAREST DIFF (one line): diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c <nl> index 2ffa5a1 . . 94eec01 100644 <nl> - - - a / jnalib / native / dispatch . c <nl> + + + b / jnalib / native / dispatch . c <nl> @ @ - 347 , 6 + 347 , 7 @ @ dispatch ( JNIEnv * env , jobject self , jint callconv , jobjectArray arr , <nl> else if ( ( array _ pt = getArrayComponentType ( env , arg ) ) ! = 0 <nl> & & array _ pt ! = ' L ' ) { <nl> void * ptr = NULL ; <nl> + <nl> switch ( array _ pt ) { <nl> case ' Z ' : ptr = ( * env ) - > GetBooleanArrayElements ( env , arg , NULL ) ; break ; <nl> case ' B ' : ptr = ( * env ) - > GetByteArrayElements ( env , arg , NULL ) ; break ; <nl> @ @ - 370 , 9 + 371 , 10 @ @ dispatch ( JNIEnv * env , jobject self , jint callconv , jobjectArray arr , <nl> array _ elements [ array _ count + + ] . elems = ptr ; <nl> } <nl> else { <nl> - snprintf ( msg , sizeof ( msg ) , " Unsupported type at parameter % d " , i ) ; <nl> - throwByName ( env , EIllegalArgument , msg ) ; <nl> - goto cleanup ; <nl> + / / Anything else , pass directly as a pointer <nl> + c _ args [ i ] . l = ( void * ) arg ; <nl> + ffi _ types [ i ] = & ffi _ type _ pointer ; <nl> + ffi _ values [ i ] = & c _ args [ i ] . l ; <nl> } <nl> } <nl> <nl> @ @ - 515 , 6 + 517 , 21 @ @ Java _ com _ sun _ jna _ Function _ invokePointer ( JNIEnv * env , jobject self , <nl> <nl> / * <nl> * Class : Function <nl> + * Method : invokeObject <nl> + * Signature : ( I [ Ljava / lang / Object ; ) Ljava / lang / Object ; <nl> + * / <nl> + JNIEXPORT jobject JNICALL <nl> + Java _ com _ sun _ jna _ Function _ invokeObject ( JNIEnv * env , jobject self , <nl> + jint callconv , jobjectArray arr ) <nl> + { <nl> + jvalue result ; <nl> + dispatch ( env , self , callconv , arr , & ffi _ type _ pointer , & result ) ; <nl> + return result . l ; <nl> + } <nl> + <nl> + <nl> + / * <nl> + * Class : Function <nl> * Method : invokeStructure <nl> * Signature : ( I [ Ljava / lang / Object ; Lcom / sun / jna / Structure ) LStructure ; <nl> * / <nl> diff - - git a / jnalib / native / testlib . c b / jnalib / native / testlib . c <nl> index 2ad3b6f . . 3e789e7 100644 <nl> - - - a / jnalib / native / testlib . c <nl> + + + b / jnalib / native / testlib . c <nl> @ @ - 201 , 6 + 201 , 11 @ @ returnStringArgument ( char * arg ) { <nl> return arg ; <nl> } <nl> <nl> + EXPORT void * <nl> + returnObjectArgument ( void * arg ) { <nl> + return arg ; <nl> + } <nl> + <nl> EXPORT wchar _ t * <nl> returnWStringMagic ( ) { <nl> return MAGICWSTRING ; <nl> @ @ - 757 , 6 + 762 , 7 @ @ callInt32StdCallCallback ( int32 _ t ( _ _ stdcall * func ) ( int32 _ t arg , int32 _ t arg2 ) , <nl> } <nl> return value ; <nl> } <nl> + <nl> # endif / * _ WIN32 & & ! _ WIN64 * / <nl> <nl> # ifdef _ _ cplusplus <nl> diff - - git a / jnalib / release - notes . html b / jnalib / release - notes . html <nl> index 3ad4e16 . . 0f6e2cc 100755 <nl> - - - a / jnalib / release - notes . html <nl> + + + b / jnalib / release - notes . html <nl> @ @ - 2 , 6 + 2 , 7 @ @ <nl> < h2 > Release 3 . 1 . x < / h2 > <nl> < b > Features < / b > < br > <nl> < ul > <nl> + < li > Add library option to allow passing / return of Java Objects . <nl> < li > Allow handling of uncaught callback exceptions ( < a href = " https : / / jna . dev . java . net / issues / show _ bug . cgi ? id = 63 " > Issue 63 ) < / a > . <nl> < li > Object oriented interface to X server ( see contrib / x11 ) <nl> < li > Make Memory class more accessible . <nl> diff - - git a / jnalib / src / com / sun / jna / Function . java b / jnalib / src / com / sun / jna / Function . java <nl> index dda06c5 . . 78410bd 100644 <nl> - - - a / jnalib / src / com / sun / jna / Function . java <nl> + + + b / jnalib / src / com / sun / jna / Function . java <nl> @ @ - 13 , 7 + 13 , 6 @ @ package com . sun . jna ; <nl> import java . lang . reflect . InvocationTargetException ; <nl> import java . lang . reflect . Method ; <nl> import java . util . Collections ; <nl> - import java . util . HashMap ; <nl> import java . util . Map ; <nl> <nl> / * * <nl> @ @ - 92 , 8 + 91 , 8 @ @ public class Function extends Pointer { <nl> / / Keep a reference to the NativeLibrary so it does not get garbage collected <nl> / / until the function is <nl> private NativeLibrary library ; <nl> - private String functionName ; <nl> - private int callingConvention ; <nl> + private final String functionName ; <nl> + private final int callingConvention ; <nl> <nl> / * * For internal JNA use . * / <nl> static final String OPTION _ INVOKING _ METHOD = " invoking - method " ; <nl> @ @ - 202 , 8 + 201 , 10 @ @ public class Function extends Pointer { <nl> TypeMapper mapper = <nl> ( TypeMapper ) options . get ( Library . OPTION _ TYPE _ MAPPER ) ; <nl> Method invokingMethod = ( Method ) options . get ( OPTION _ INVOKING _ METHOD ) ; <nl> + boolean allowObjects = Boolean . TRUE . equals ( options . get ( Library . OPTION _ ALLOW _ OBJECTS ) ) ; <nl> for ( int i = 0 ; i < args . length ; i + + ) { <nl> - args [ i ] = convertArgument ( args , i , invokingMethod , mapper ) ; <nl> + args [ i ] = convertArgument ( args , i , invokingMethod , <nl> + mapper , allowObjects ) ; <nl> } <nl> <nl> Class nativeType = returnType ; <nl> @ @ - 220 , 7 + 221 , 7 @ @ public class Function extends Pointer { <nl> } <nl> } <nl> <nl> - Object result = invoke ( args , nativeType ) ; <nl> + Object result = invoke ( args , nativeType , allowObjects ) ; <nl> <nl> / / Convert the result to a custom value / type if appropriate <nl> if ( resultConverter ! = null ) { <nl> @ @ - 276 , 7 + 277 , 7 @ @ public class Function extends Pointer { <nl> } <nl> <nl> / * * @ see NativeLibrary # NativeLibrary ( String , String , long ) implementation * / <nl> - Object invoke ( Object [ ] args , Class returnType ) { <nl> + Object invoke ( Object [ ] args , Class returnType , boolean allowObjects ) { <nl> Object result = null ; <nl> if ( returnType = = null | | returnType = = void . class | | returnType = = Void . class ) { <nl> invokeVoid ( callingConvention , args ) ; <nl> @ @ - 369 , 6 + 370 , 15 @ @ public class Function extends Pointer { <nl> result = p . getPointerArray ( 0 ) ; <nl> } <nl> } <nl> + else if ( allowObjects ) { <nl> + result = invokeObject ( callingConvention , args ) ; <nl> + if ( result ! = null <nl> + & & ! returnType . isAssignableFrom ( result . getClass ( ) ) ) { <nl> + throw new IllegalArgumentException ( " Return type " + returnType <nl> + + " does not match result " <nl> + + result . getClass ( ) ) ; <nl> + } <nl> + } <nl> else { <nl> throw new IllegalArgumentException ( " Unsupported return type " <nl> + returnType <nl> @ @ - 377 , 7 + 387 , 9 @ @ public class Function extends Pointer { <nl> return result ; <nl> } <nl> <nl> - private Object convertArgument ( Object [ ] args , int index , Method invokingMethod , TypeMapper mapper ) { <nl> + private Object convertArgument ( Object [ ] args , int index , <nl> + Method invokingMethod , TypeMapper mapper , <nl> + boolean allowObjects ) { <nl> Object arg = args [ index ] ; <nl> if ( arg ! = null ) { <nl> Class type = arg . getClass ( ) ; <nl> @ @ - 511 , 10 + 523 , 14 @ @ public class Function extends Pointer { <nl> } <nl> } <nl> else if ( argClass . isArray ( ) ) { <nl> + / / TODO : handle array of NativeMapped <nl> throw new IllegalArgumentException ( " Unsupported array argument type : " <nl> + argClass . getComponentType ( ) ) ; <nl> } <nl> - if ( arg ! = null & & ! Native . isSupportedNativeType ( arg . getClass ( ) ) ) { <nl> + else if ( allowObjects ) { <nl> + return arg ; <nl> + } <nl> + else if ( ! Native . isSupportedNativeType ( arg . getClass ( ) ) ) { <nl> throw new IllegalArgumentException ( " Unsupported argument type " <nl> + arg . getClass ( ) . getName ( ) <nl> + " at parameter " + index <nl> @ @ - 621 , 7 + 637 , 8 @ @ public class Function extends Pointer { <nl> private native Pointer invokePointer ( int callingConvention , Object [ ] args ) ; <nl> <nl> / * * <nl> - * Call the native function being represented by this object <nl> + * Call the native function being represented by this object , returning <nl> + * a struct by value . <nl> * <nl> * @ param callingConvention calling convention to be used <nl> * @ param args <nl> @ @ - 632 , 6 + 649 , 17 @ @ public class Function extends Pointer { <nl> private native Structure invokeStructure ( int callingConvention , Object [ ] args , <nl> Structure result ) ; <nl> <nl> + / * * <nl> + * Call the native function being represented by this object , returning <nl> + * a Java < code > Object < / code > . <nl> + * <nl> + * @ param callingConvention calling convention to be used <nl> + * @ param args <nl> + * Arguments to pass to the native function <nl> + * @ return The returned Java < code > Object < / code > <nl> + * / <nl> + private native Object invokeObject ( int callingConvention , Object [ ] args ) ; <nl> + <nl> / * * Provide a human - readable representation of this object . * / <nl> public String toString ( ) { <nl> if ( library ! = null ) { <nl> @ @ - 641 , 6 + 669 , 13 @ @ public class Function extends Pointer { <nl> return " native function @ 0x " + Long . toHexString ( peer ) ; <nl> } <nl> <nl> + / * * Convenience method for <nl> + * { @ link # invoke ( Class , Object [ ] ) invokeObject ( Object . class , args ) } . <nl> + * / <nl> + public Object invokeObject ( Object [ ] args ) { <nl> + return invoke ( Object . class , args ) ; <nl> + } <nl> + <nl> / * * Convenience method for <nl> * { @ link # invoke ( Class , Object [ ] ) invoke ( Pointer . class , args ) } . <nl> * / <nl> @ @ - 750 , 7 + 785 , 7 @ @ public class Function extends Pointer { <nl> } <nl> <nl> private static class PointerArray extends Memory implements PostCallRead { <nl> - private Pointer [ ] original ; <nl> + private final Pointer [ ] original ; <nl> public PointerArray ( Pointer [ ] arg ) { <nl> super ( Pointer . SIZE * ( arg . length + 1 ) ) ; <nl> this . original = arg ; <nl> diff - - git a / jnalib / src / com / sun / jna / Library . java b / jnalib / src / com / sun / jna / Library . java <nl> index 93b070d . . e2d15ee 100644 <nl> - - - a / jnalib / src / com / sun / jna / Library . java <nl> + + + b / jnalib / src / com / sun / jna / Library . java <nl> @ @ - 74 , 6 + 74 , 14 @ @ public interface Library { <nl> * be one of the predefined alignment types in { @ link Structure } . <nl> * / <nl> String OPTION _ STRUCTURE _ ALIGNMENT = " structure - alignment " ; <nl> + / * * Option key for a boolean flag to allow any Java class instance as a <nl> + parameter . If no type mapper is found , the object is passed as a <nl> + pointer . <nl> + < em > NOTE : < / em > This is for use with raw JNI interactions via the <nl> + JNIEnv data structure . <nl> + * / <nl> + String OPTION _ ALLOW _ OBJECTS = " allow - objects " ; <nl> + <nl> static class Handler implements InvocationHandler { <nl> <nl> static final Method OBJECT _ TOSTRING ; <nl> diff - - git a / jnalib / src / com / sun / jna / NativeLibrary . java b / jnalib / src / com / sun / jna / NativeLibrary . java <nl> index ed7a2ef . . db9052a 100644 <nl> - - - a / jnalib / src / com / sun / jna / NativeLibrary . java <nl> + + + b / jnalib / src / com / sun / jna / NativeLibrary . java <nl> @ @ - 66 , 7 + 66 , 7 @ @ public class NativeLibrary { <nl> if ( Platform . isWindows ( ) & & " kernel32 " . equals ( this . libraryName . toLowerCase ( ) ) ) { <nl> synchronized ( functions ) { <nl> Function f = new Function ( this , " GetLastError " , Function . ALT _ CONVENTION ) { <nl> - Object invoke ( Object [ ] args , Class returnType ) { <nl> + Object invoke ( Object [ ] args , Class returnType , boolean b ) { <nl> return new Integer ( Native . getLastError ( ) ) ; <nl> } <nl> } ; <nl> @ @ - 477 , 23 + 477 , 23 @ @ public class NativeLibrary { <nl> 	 double divisor = 1 ; <nl> 	 int dot = ver . indexOf ( " . " ) ; <nl> 	 while ( ver ! = null ) { <nl> - 	 	 String num ; <nl> - 	 	 if ( dot ! = - 1 ) { <nl> - 	 	 	 num = ver . substring ( 0 , dot ) ; <nl> - 	 	 	 ver = ver . substring ( dot + 1 ) ; <nl> - 	 	 dot = ver . indexOf ( " . " ) ; <nl> - 	 	 } <nl> - 	 	 else { <nl> - 	 	 	 num = ver ; <nl> - 	 	 	 ver = null ; <nl> - 	 	 } <nl> - 	 	 try { <nl> - 	 	 	 v + = Integer . parseInt ( num ) / divisor ; <nl> - 	 	 } <nl> - 	 	 catch ( NumberFormatException e ) { <nl> - 	 	 	 return 0 ; <nl> - 	 	 } <nl> - 	 	 divisor * = 100 ; <nl> + String num ; <nl> + if ( dot ! = - 1 ) { <nl> + num = ver . substring ( 0 , dot ) ; <nl> + ver = ver . substring ( dot + 1 ) ; <nl> + dot = ver . indexOf ( " . " ) ; <nl> + } <nl> + else { <nl> + num = ver ; <nl> + ver = null ; <nl> + } <nl> + try { <nl> + v + = Integer . parseInt ( num ) / divisor ; <nl> + } <nl> + catch ( NumberFormatException e ) { <nl> + return 0 ; <nl> + } <nl> + divisor * = 100 ; <nl> 	 } <nl> <nl> 	 return v ; <nl> diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html <nl> index 1c01ee1 . . c8f0ef2 100644 <nl> - - - a / jnalib / src / com / sun / jna / overview . html <nl> + + + b / jnalib / src / com / sun / jna / overview . html <nl> @ @ - 590 , 12 + 590 , 14 @ @ memory . Structure , String , and WString members will < em > not < / em > be <nl> initialized unless they are selected via { @ link com . sun . jna . Union # setType } . <nl> <nl> < a name = " java - objects " > < / a > <nl> - < h3 > Java Object arguments < / h3 > <nl> - In some cases , it would seem convenient to pass a Java object as an opaque <nl> - pointer for later use by a Java callback method . Unfortunately , this proves <nl> - problematic in that the native code must become responsible for reference <nl> - tracking . Until a consistent method or methods of handling these situations <nl> - is formulated , passing Java objects directly is not supported . <nl> + < h3 > Arbitrary Java Object arguments / return values < / h3 > <nl> + In some cases , such as invoking native VM functions directly , it is necessary <nl> + to pass Java objects to the native methods . By default , JNA disallows using <nl> + any Java object that is not explicitly supported unless it derives from <nl> + { @ link com . sun . jna . NativeMapped } , because it is generally unnecessary to use <nl> + such objects and usually signals a programmer error . To avoid errors flagging <nl> + the use of Java objects , define the system <nl> + property < code > jna . allow _ objects < / code > with the value " true " . <nl> <nl> < p > <nl> < a href = " # toc " > Table of Contents < / a > <nl> diff - - git a / jnalib / test / com / sun / jna / ReturnTypesTest . java b / jnalib / test / com / sun / jna / ReturnTypesTest . java <nl> index 1f45338 . . 3c1c8af 100644 <nl> - - - a / jnalib / test / com / sun / jna / ReturnTypesTest . java <nl> + + + b / jnalib / test / com / sun / jna / ReturnTypesTest . java <nl> @ @ - 12 , 11 + 12 , 13 @ @ <nl> * / <nl> package com . sun . jna ; <nl> <nl> + import java . util . HashMap ; <nl> + <nl> import junit . framework . TestCase ; <nl> <nl> + import com . sun . jna . ReturnTypesTest . TestLibrary . SimpleStructure ; <nl> import com . sun . jna . ReturnTypesTest . TestLibrary . TestStructure ; <nl> import com . sun . jna . ReturnTypesTest . TestLibrary . TestSmallStructure ; <nl> - import com . sun . jna . ReturnTypesTest . TestLibrary . SimpleStructure ; <nl> <nl> / * * Exercise a range of native methods . <nl> * <nl> @ @ - 58 , 7 + 60 , 9 @ @ public class ReturnTypesTest extends TestCase { <nl> public double doubleField = 4d ; <nl> } <nl> <nl> - Object returnStringArgument ( String s ) ; <nl> + class TestObject { } <nl> + Object returnObjectArgument ( Object s ) ; <nl> + TestObject returnObjectArgument ( TestObject s ) ; <nl> boolean returnFalse ( ) ; <nl> boolean returnTrue ( ) ; <nl> int returnInt32Zero ( ) ; <nl> @ @ - 92 , 14 + 96 , 28 @ @ public class ReturnTypesTest extends TestCase { <nl> lib = null ; <nl> } <nl> <nl> - public void testReturnJavaObject ( ) throws Exception { <nl> + public void testReturnObject ( ) throws Exception { <nl> + lib = ( TestLibrary ) Native . loadLibrary ( " testlib " , TestLibrary . class , new HashMap ( ) { { <nl> + put ( Library . OPTION _ ALLOW _ OBJECTS , Boolean . TRUE ) ; <nl> + } } ) ; <nl> + assertNull ( " null value not returned " , lib . returnObjectArgument ( null ) ) ; <nl> + final Object VALUE = new Object ( ) { <nl> + public String toString ( ) { <nl> + return getName ( ) ; <nl> + } <nl> + } ; <nl> + assertEquals ( " Wrong object returned " , VALUE , lib . returnObjectArgument ( VALUE ) ) ; <nl> + } <nl> + <nl> + public void testReturnObjectUnsupported ( ) throws Exception { <nl> + lib = ( TestLibrary ) Native . loadLibrary ( " testlib " , TestLibrary . class ) ; <nl> try { <nl> - lib . returnStringArgument ( getName ( ) ) ; <nl> + lib . returnObjectArgument ( new TestLibrary . TestObject ( ) ) ; <nl> fail ( " Java Object return is not supported , should throw IllegalArgumentException " ) ; <nl> } <nl> catch ( IllegalArgumentException e ) { <nl> assertTrue ( " Exception should include return object type : " + e , <nl> - e . getMessage ( ) . indexOf ( " java . lang . Object " ) ! = - 1 ) ; <nl> + e . getMessage ( ) . indexOf ( TestLibrary . TestObject . class . getName ( ) ) ! = - 1 ) ; <nl> } <nl> catch ( Throwable e ) { <nl> fail ( " Method declared with Java Object return should throw IllegalArgumentException , not " + e ) ;

TEST DIFF:
diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java 
 index 4bcc773 . . e5b3436 100644 
 - - - a / test / com / sun / jna / CallbacksTest . java 
 + + + b / test / com / sun / jna / CallbacksTest . java 
 @ @ - 16 , 6 + 16 , 7 @ @ import java . io . ByteArrayOutputStream ; 
 import java . io . PrintStream ; 
 import java . lang . ref . Reference ; 
 import java . lang . ref . WeakReference ; 
 + import java . nio . charset . Charset ; 
 import java . util . Arrays ; 
 import java . util . Collections ; 
 import java . util . HashSet ; 
 @ @ - 652 , 8 + 653 , 9 @ @ public class CallbacksTest extends TestCase implements Paths { 
 return arg + arg2 ; 
 } 
 } ; 
 - final String VALUE = " value " + UNICODE ; 
 - final String VALUE2 = getName ( ) + UNICODE ; 
 + Charset charset = Charset . forName ( Native . getDefaultStringEncoding ( ) ) ; 
 + final String VALUE = " value " + charset . decode ( charset . encode ( UNICODE ) ) ; 
 + final String VALUE2 = getName ( ) + charset . decode ( charset . encode ( UNICODE ) ) ; 
 String value = lib . callStringCallback ( cb , VALUE , VALUE2 ) ; 
 assertTrue ( " Callback not called " , called [ 0 ] ) ; 
 assertEquals ( " Wrong String callback argument 0 " , VALUE , cbargs [ 0 ] ) ; 
 @ @ - 673 , 8 + 675 , 9 @ @ public class CallbacksTest extends TestCase implements Paths { 
 Map < ? , ? > m = CallbackReference . allocations ; 
 m . clear ( ) ; 
 
 - String arg = getName ( ) + " 1 " + UNICODE ; 
 - String arg2 = getName ( ) + " 2 " + UNICODE ; 
 + Charset charset = Charset . forName ( Native . getDefaultStringEncoding ( ) ) ; 
 + String arg = getName ( ) + " 1 " + charset . decode ( charset . encode ( UNICODE ) ) ; 
 + String arg2 = getName ( ) + " 2 " + charset . decode ( charset . encode ( UNICODE ) ) ; 
 String value = lib . callStringCallback ( cb , arg , arg2 ) ; 
 WeakReference < Object > ref = new WeakReference < Object > ( value ) ; 
 
 @ @ - 723 , 7 + 726 , 8 @ @ public class CallbacksTest extends TestCase implements Paths { 
 return arg ; 
 } 
 } ; 
 - final String VALUE = " value " + UNICODE ; 
 + Charset charset = Charset . forName ( Native . getDefaultStringEncoding ( ) ) ; 
 + final String VALUE = " value " + charset . decode ( charset . encode ( UNICODE ) ) ; 
 final String [ ] VALUE _ ARRAY = { VALUE , null } ; 
 Pointer value = lib . callStringArrayCallback ( cb , VALUE _ ARRAY ) ; 
 assertTrue ( " Callback not called " , called [ 0 ] ) ; 
 @ @ - 795 , 7 + 799 , 8 @ @ public class CallbacksTest extends TestCase implements Paths { 
 public void testUnionByValueCallbackArgument ( ) throws Exception { 
 TestLibrary . TestUnion arg = new TestLibrary . TestUnion ( ) ; 
 arg . setType ( String . class ) ; 
 - final String VALUE = getName ( ) + UNICODE ; 
 + Charset charset = Charset . forName ( arg . getStringEncoding ( ) ) ; 
 + final String VALUE = getName ( ) + charset . decode ( charset . encode ( UNICODE ) ) ; 
 arg . f1 = VALUE ; 
 final boolean [ ] called = { false } ; 
 final TestLibrary . TestUnion [ ] cbvalue = { null } ; 
 diff - - git a / test / com / sun / jna / ReturnTypesTest . java b / test / com / sun / jna / ReturnTypesTest . java 
 index 646ee22 . . 6afbd58 100644 
 - - - a / test / com / sun / jna / ReturnTypesTest . java 
 + + + b / test / com / sun / jna / ReturnTypesTest . java 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * / 
 package com . sun . jna ; 
 
 + import java . nio . charset . Charset ; 
 import java . util . Collections ; 
 import java . util . List ; 
 import junit . framework . TestCase ; 
 @ @ - 314 , 7 + 315 , 8 @ @ public class ReturnTypesTest extends TestCase { 
 } 
 
 public void testReturnStringArray ( ) { 
 - final String VALUE = getName ( ) + UNICODE ; 
 + Charset charset = Charset . forName ( Native . getDefaultStringEncoding ( ) ) ; 
 + final String VALUE = getName ( ) + charset . decode ( charset . encode ( UNICODE ) ) ; 
 String [ ] input = { 
 VALUE , null , 
 } ; 
 diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java 
 index f2ef9a3 . . 833d057 100644 
 - - - a / test / com / sun / jna / StructureTest . java 
 + + + b / test / com / sun / jna / StructureTest . java 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * / 
 package com . sun . jna ; 
 
 + import java . nio . charset . Charset ; 
 import java . util . ArrayList ; 
 import java . util . Arrays ; 
 import java . util . Collections ; 
 @ @ - 1084 , 9 + 1085 , 10 @ @ public class StructureTest extends TestCase { 
 return Arrays . asList ( " inner " ) ; 
 } 
 } 
 - final String VALUE = getName ( ) + UNICODE ; 
 - final WString WVALUE = new WString ( VALUE ) ; 
 StructureFromPointer o = new StructureFromPointer ( ) ; 
 + Charset charset = Charset . forName ( o . getStringEncoding ( ) ) ; 
 + final String VALUE = getName ( ) + charset . decode ( charset . encode ( UNICODE ) ) ; 
 + final WString WVALUE = new WString ( VALUE ) ; 
 o . s = VALUE ; 
 o . ws = WVALUE ; 
 o . write ( ) ;

NEAREST DIFF:
diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c 
 index 2ffa5a1 . . 94eec01 100644 
 - - - a / jnalib / native / dispatch . c 
 + + + b / jnalib / native / dispatch . c 
 @ @ - 347 , 6 + 347 , 7 @ @ dispatch ( JNIEnv * env , jobject self , jint callconv , jobjectArray arr , 
 else if ( ( array _ pt = getArrayComponentType ( env , arg ) ) ! = 0 
 & & array _ pt ! = ' L ' ) { 
 void * ptr = NULL ; 
 + 
 switch ( array _ pt ) { 
 case ' Z ' : ptr = ( * env ) - > GetBooleanArrayElements ( env , arg , NULL ) ; break ; 
 case ' B ' : ptr = ( * env ) - > GetByteArrayElements ( env , arg , NULL ) ; break ; 
 @ @ - 370 , 9 + 371 , 10 @ @ dispatch ( JNIEnv * env , jobject self , jint callconv , jobjectArray arr , 
 array _ elements [ array _ count + + ] . elems = ptr ; 
 } 
 else { 
 - snprintf ( msg , sizeof ( msg ) , " Unsupported type at parameter % d " , i ) ; 
 - throwByName ( env , EIllegalArgument , msg ) ; 
 - goto cleanup ; 
 + / / Anything else , pass directly as a pointer 
 + c _ args [ i ] . l = ( void * ) arg ; 
 + ffi _ types [ i ] = & ffi _ type _ pointer ; 
 + ffi _ values [ i ] = & c _ args [ i ] . l ; 
 } 
 } 
 
 @ @ - 515 , 6 + 517 , 21 @ @ Java _ com _ sun _ jna _ Function _ invokePointer ( JNIEnv * env , jobject self , 
 
 / * 
 * Class : Function 
 + * Method : invokeObject 
 + * Signature : ( I [ Ljava / lang / Object ; ) Ljava / lang / Object ; 
 + * / 
 + JNIEXPORT jobject JNICALL 
 + Java _ com _ sun _ jna _ Function _ invokeObject ( JNIEnv * env , jobject self , 
 + jint callconv , jobjectArray arr ) 
 + { 
 + jvalue result ; 
 + dispatch ( env , self , callconv , arr , & ffi _ type _ pointer , & result ) ; 
 + return result . l ; 
 + } 
 + 
 + 
 + / * 
 + * Class : Function 
 * Method : invokeStructure 
 * Signature : ( I [ Ljava / lang / Object ; Lcom / sun / jna / Structure ) LStructure ; 
 * / 
 diff - - git a / jnalib / native / testlib . c b / jnalib / native / testlib . c 
 index 2ad3b6f . . 3e789e7 100644 
 - - - a / jnalib / native / testlib . c 
 + + + b / jnalib / native / testlib . c 
 @ @ - 201 , 6 + 201 , 11 @ @ returnStringArgument ( char * arg ) { 
 return arg ; 
 } 
 
 + EXPORT void * 
 + returnObjectArgument ( void * arg ) { 
 + return arg ; 
 + } 
 + 
 EXPORT wchar _ t * 
 returnWStringMagic ( ) { 
 return MAGICWSTRING ; 
 @ @ - 757 , 6 + 762 , 7 @ @ callInt32StdCallCallback ( int32 _ t ( _ _ stdcall * func ) ( int32 _ t arg , int32 _ t arg2 ) , 
 } 
 return value ; 
 } 
 + 
 # endif / * _ WIN32 & & ! _ WIN64 * / 
 
 # ifdef _ _ cplusplus 
 diff - - git a / jnalib / release - notes . html b / jnalib / release - notes . html 
 index 3ad4e16 . . 0f6e2cc 100755 
 - - - a / jnalib / release - notes . html 
 + + + b / jnalib / release - notes . html 
 @ @ - 2 , 6 + 2 , 7 @ @ 
 < h2 > Release 3 . 1 . x < / h2 > 
 < b > Features < / b > < br > 
 < ul > 
 + < li > Add library option to allow passing / return of Java Objects . 
 < li > Allow handling of uncaught callback exceptions ( < a href = " https : / / jna . dev . java . net / issues / show _ bug . cgi ? id = 63 " > Issue 63 ) < / a > . 
 < li > Object oriented interface to X server ( see contrib / x11 ) 
 < li > Make Memory class more accessible . 
 diff - - git a / jnalib / src / com / sun / jna / Function . java b / jnalib / src / com / sun / jna / Function . java 
 index dda06c5 . . 78410bd 100644 
 - - - a / jnalib / src / com / sun / jna / Function . java 
 + + + b / jnalib / src / com / sun / jna / Function . java 
 @ @ - 13 , 7 + 13 , 6 @ @ package com . sun . jna ; 
 import java . lang . reflect . InvocationTargetException ; 
 import java . lang . reflect . Method ; 
 import java . util . Collections ; 
 - import java . util . HashMap ; 
 import java . util . Map ; 
 
 / * * 
 @ @ - 92 , 8 + 91 , 8 @ @ public class Function extends Pointer { 
 / / Keep a reference to the NativeLibrary so it does not get garbage collected 
 / / until the function is 
 private NativeLibrary library ; 
 - private String functionName ; 
 - private int callingConvention ; 
 + private final String functionName ; 
 + private final int callingConvention ; 
 
 / * * For internal JNA use . * / 
 static final String OPTION _ INVOKING _ METHOD = " invoking - method " ; 
 @ @ - 202 , 8 + 201 , 10 @ @ public class Function extends Pointer { 
 TypeMapper mapper = 
 ( TypeMapper ) options . get ( Library . OPTION _ TYPE _ MAPPER ) ; 
 Method invokingMethod = ( Method ) options . get ( OPTION _ INVOKING _ METHOD ) ; 
 + boolean allowObjects = Boolean . TRUE . equals ( options . get ( Library . OPTION _ ALLOW _ OBJECTS ) ) ; 
 for ( int i = 0 ; i < args . length ; i + + ) { 
 - args [ i ] = convertArgument ( args , i , invokingMethod , mapper ) ; 
 + args [ i ] = convertArgument ( args , i , invokingMethod , 
 + mapper , allowObjects ) ; 
 } 
 
 Class nativeType = returnType ; 
 @ @ - 220 , 7 + 221 , 7 @ @ public class Function extends Pointer { 
 } 
 } 
 
 - Object result = invoke ( args , nativeType ) ; 
 + Object result = invoke ( args , nativeType , allowObjects ) ; 
 
 / / Convert the result to a custom value / type if appropriate 
 if ( resultConverter ! = null ) { 
 @ @ - 276 , 7 + 277 , 7 @ @ public class Function extends Pointer { 
 } 
 
 / * * @ see NativeLibrary # NativeLibrary ( String , String , long ) implementation * / 
 - Object invoke ( Object [ ] args , Class returnType ) { 
 + Object invoke ( Object [ ] args , Class returnType , boolean allowObjects ) { 
 Object result = null ; 
 if ( returnType = = null | | returnType = = void . class | | returnType = = Void . class ) { 
 invokeVoid ( callingConvention , args ) ; 
 @ @ - 369 , 6 + 370 , 15 @ @ public class Function extends Pointer { 
 result = p . getPointerArray ( 0 ) ; 
 } 
 } 
 + else if ( allowObjects ) { 
 + result = invokeObject ( callingConvention , args ) ; 
 + if ( result ! = null 
 + & & ! returnType . isAssignableFrom ( result . getClass ( ) ) ) { 
 + throw new IllegalArgumentException ( " Return type " + returnType 
 + + " does not match result " 
 + + result . getClass ( ) ) ; 
 + } 
 + } 
 else { 
 throw new IllegalArgumentException ( " Unsupported return type " 
 + returnType 
 @ @ - 377 , 7 + 387 , 9 @ @ public class Function extends Pointer { 
 return result ; 
 } 
 
 - private Object convertArgument ( Object [ ] args , int index , Method invokingMethod , TypeMapper mapper ) { 
 + private Object convertArgument ( Object [ ] args , int index , 
 + Method invokingMethod , TypeMapper mapper , 
 + boolean allowObjects ) { 
 Object arg = args [ index ] ; 
 if ( arg ! = null ) { 
 Class type = arg . getClass ( ) ; 
 @ @ - 511 , 10 + 523 , 14 @ @ public class Function extends Pointer { 
 } 
 } 
 else if ( argClass . isArray ( ) ) { 
 + / / TODO : handle array of NativeMapped 
 throw new IllegalArgumentException ( " Unsupported array argument type : " 
 + argClass . getComponentType ( ) ) ; 
 } 
 - if ( arg ! = null & & ! Native . isSupportedNativeType ( arg . getClass ( ) ) ) { 
 + else if ( allowObjects ) { 
 + return arg ; 
 + } 
 + else if ( ! Native . isSupportedNativeType ( arg . getClass ( ) ) ) { 
 throw new IllegalArgumentException ( " Unsupported argument type " 
 + arg . getClass ( ) . getName ( ) 
 + " at parameter " + index 
 @ @ - 621 , 7 + 637 , 8 @ @ public class Function extends Pointer { 
 private native Pointer invokePointer ( int callingConvention , Object [ ] args ) ; 
 
 / * * 
 - * Call the native function being represented by this object 
 + * Call the native function being represented by this object , returning 
 + * a struct by value . 
 * 
 * @ param callingConvention calling convention to be used 
 * @ param args 
 @ @ - 632 , 6 + 649 , 17 @ @ public class Function extends Pointer { 
 private native Structure invokeStructure ( int callingConvention , Object [ ] args , 
 Structure result ) ; 
 
 + / * * 
 + * Call the native function being represented by this object , returning 
 + * a Java < code > Object < / code > . 
 + * 
 + * @ param callingConvention calling convention to be used 
 + * @ param args 
 + * Arguments to pass to the native function 
 + * @ return The returned Java < code > Object < / code > 
 + * / 
 + private native Object invokeObject ( int callingConvention , Object [ ] args ) ; 
 + 
 / * * Provide a human - readable representation of this object . * / 
 public String toString ( ) { 
 if ( library ! = null ) { 
 @ @ - 641 , 6 + 669 , 13 @ @ public class Function extends Pointer { 
 return " native function @ 0x " + Long . toHexString ( peer ) ; 
 } 
 
 + / * * Convenience method for 
 + * { @ link # invoke ( Class , Object [ ] ) invokeObject ( Object . class , args ) } . 
 + * / 
 + public Object invokeObject ( Object [ ] args ) { 
 + return invoke ( Object . class , args ) ; 
 + } 
 + 
 / * * Convenience method for 
 * { @ link # invoke ( Class , Object [ ] ) invoke ( Pointer . class , args ) } . 
 * / 
 @ @ - 750 , 7 + 785 , 7 @ @ public class Function extends Pointer { 
 } 
 
 private static class PointerArray extends Memory implements PostCallRead { 
 - private Pointer [ ] original ; 
 + private final Pointer [ ] original ; 
 public PointerArray ( Pointer [ ] arg ) { 
 super ( Pointer . SIZE * ( arg . length + 1 ) ) ; 
 this . original = arg ; 
 diff - - git a / jnalib / src / com / sun / jna / Library . java b / jnalib / src / com / sun / jna / Library . java 
 index 93b070d . . e2d15ee 100644 
 - - - a / jnalib / src / com / sun / jna / Library . java 
 + + + b / jnalib / src / com / sun / jna / Library . java 
 @ @ - 74 , 6 + 74 , 14 @ @ public interface Library { 
 * be one of the predefined alignment types in { @ link Structure } . 
 * / 
 String OPTION _ STRUCTURE _ ALIGNMENT = " structure - alignment " ; 
 + / * * Option key for a boolean flag to allow any Java class instance as a 
 + parameter . If no type mapper is found , the object is passed as a 
 + pointer . 
 + < em > NOTE : < / em > This is for use with raw JNI interactions via the 
 + JNIEnv data structure . 
 + * / 
 + String OPTION _ ALLOW _ OBJECTS = " allow - objects " ; 
 + 
 static class Handler implements InvocationHandler { 
 
 static final Method OBJECT _ TOSTRING ; 
 diff - - git a / jnalib / src / com / sun / jna / NativeLibrary . java b / jnalib / src / com / sun / jna / NativeLibrary . java 
 index ed7a2ef . . db9052a 100644 
 - - - a / jnalib / src / com / sun / jna / NativeLibrary . java 
 + + + b / jnalib / src / com / sun / jna / NativeLibrary . java 
 @ @ - 66 , 7 + 66 , 7 @ @ public class NativeLibrary { 
 if ( Platform . isWindows ( ) & & " kernel32 " . equals ( this . libraryName . toLowerCase ( ) ) ) { 
 synchronized ( functions ) { 
 Function f = new Function ( this , " GetLastError " , Function . ALT _ CONVENTION ) { 
 - Object invoke ( Object [ ] args , Class returnType ) { 
 + Object invoke ( Object [ ] args , Class returnType , boolean b ) { 
 return new Integer ( Native . getLastError ( ) ) ; 
 } 
 } ; 
 @ @ - 477 , 23 + 477 , 23 @ @ public class NativeLibrary { 
 	 double divisor = 1 ; 
 	 int dot = ver . indexOf ( " . " ) ; 
 	 while ( ver ! = null ) { 
 - 	 	 String num ; 
 - 	 	 if ( dot ! = - 1 ) { 
 - 	 	 	 num = ver . substring ( 0 , dot ) ; 
 - 	 	 	 ver = ver . substring ( dot + 1 ) ; 
 - 	 	 dot = ver . indexOf ( " . " ) ; 
 - 	 	 } 
 - 	 	 else { 
 - 	 	 	 num = ver ; 
 - 	 	 	 ver = null ; 
 - 	 	 } 
 - 	 	 try { 
 - 	 	 	 v + = Integer . parseInt ( num ) / divisor ; 
 - 	 	 } 
 - 	 	 catch ( NumberFormatException e ) { 
 - 	 	 	 return 0 ; 
 - 	 	 } 
 - 	 	 divisor * = 100 ; 
 + String num ; 
 + if ( dot ! = - 1 ) { 
 + num = ver . substring ( 0 , dot ) ; 
 + ver = ver . substring ( dot + 1 ) ; 
 + dot = ver . indexOf ( " . " ) ; 
 + } 
 + else { 
 + num = ver ; 
 + ver = null ; 
 + } 
 + try { 
 + v + = Integer . parseInt ( num ) / divisor ; 
 + } 
 + catch ( NumberFormatException e ) { 
 + return 0 ; 
 + } 
 + divisor * = 100 ; 
 	 } 
 
 	 return v ; 
 diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html 
 index 1c01ee1 . . c8f0ef2 100644 
 - - - a / jnalib / src / com / sun / jna / overview . html 
 + + + b / jnalib / src / com / sun / jna / overview . html 
 @ @ - 590 , 12 + 590 , 14 @ @ memory . Structure , String , and WString members will < em > not < / em > be 
 initialized unless they are selected via { @ link com . sun . jna . Union # setType } . 
 
 < a name = " java - objects " > < / a > 
 - < h3 > Java Object arguments < / h3 > 
 - In some cases , it would seem convenient to pass a Java object as an opaque 
 - pointer for later use by a Java callback method . Unfortunately , this proves 
 - problematic in that the native code must become responsible for reference 
 - tracking . Until a consistent method or methods of handling these situations 
 - is formulated , passing Java objects directly is not supported . 
 + < h3 > Arbitrary Java Object arguments / return values < / h3 > 
 + In some cases , such as invoking native VM functions directly , it is necessary 
 + to pass Java objects to the native methods . By default , JNA disallows using 
 + any Java object that is not explicitly supported unless it derives from 
 + { @ link com . sun . jna . NativeMapped } , because it is generally unnecessary to use 
 + such objects and usually signals a programmer error . To avoid errors flagging 
 + the use of Java objects , define the system 
 + property < code > jna . allow _ objects < / code > with the value " true " . 
 
 < p > 
 < a href = " # toc " > Table of Contents < / a > 
 diff - - git a / jnalib / test / com / sun / jna / ReturnTypesTest . java b / jnalib / test / com / sun / jna / ReturnTypesTest . java 
 index 1f45338 . . 3c1c8af 100644 
 - - - a / jnalib / test / com / sun / jna / ReturnTypesTest . java 
 + + + b / jnalib / test / com / sun / jna / ReturnTypesTest . java 
 @ @ - 12 , 11 + 12 , 13 @ @ 
 * / 
 package com . sun . jna ; 
 
 + import java . util . HashMap ; 
 + 
 import junit . framework . TestCase ; 
 
 + import com . sun . jna . ReturnTypesTest . TestLibrary . SimpleStructure ; 
 import com . sun . jna . ReturnTypesTest . TestLibrary . TestStructure ; 
 import com . sun . jna . ReturnTypesTest . TestLibrary . TestSmallStructure ; 
 - import com . sun . jna . ReturnTypesTest . TestLibrary . SimpleStructure ; 
 
 / * * Exercise a range of native methods . 
 * 
 @ @ - 58 , 7 + 60 , 9 @ @ public class ReturnTypesTest extends TestCase { 
 public double doubleField = 4d ; 
 } 
 
 - Object returnStringArgument ( String s ) ; 
 + class TestObject { } 
 + Object returnObjectArgument ( Object s ) ; 
 + TestObject returnObjectArgument ( TestObject s ) ; 
 boolean returnFalse ( ) ; 
 boolean returnTrue ( ) ; 
 int returnInt32Zero ( ) ; 
 @ @ - 92 , 14 + 96 , 28 @ @ public class ReturnTypesTest extends TestCase { 
 lib = null ; 
 } 
 
 - public void testReturnJavaObject ( ) throws Exception { 
 + public void testReturnObject ( ) throws Exception { 
 + lib = ( TestLibrary ) Native . loadLibrary ( " testlib " , TestLibrary . class , new HashMap ( ) { { 
 + put ( Library . OPTION _ ALLOW _ OBJECTS , Boolean . TRUE ) ; 
 + } } ) ; 
 + assertNull ( " null value not returned " , lib . returnObjectArgument ( null ) ) ; 
 + final Object VALUE = new Object ( ) { 
 + public String toString ( ) { 
 + return getName ( ) ; 
 + } 
 + } ; 
 + assertEquals ( " Wrong object returned " , VALUE , lib . returnObjectArgument ( VALUE ) ) ; 
 + } 
 + 
 + public void testReturnObjectUnsupported ( ) throws Exception { 
 + lib = ( TestLibrary ) Native . loadLibrary ( " testlib " , TestLibrary . class ) ; 
 try { 
 - lib . returnStringArgument ( getName ( ) ) ; 
 + lib . returnObjectArgument ( new TestLibrary . TestObject ( ) ) ; 
 fail ( " Java Object return is not supported , should throw IllegalArgumentException " ) ; 
 } 
 catch ( IllegalArgumentException e ) { 
 assertTrue ( " Exception should include return object type : " + e , 
 - e . getMessage ( ) . indexOf ( " java . lang . Object " ) ! = - 1 ) ; 
 + e . getMessage ( ) . indexOf ( TestLibrary . TestObject . class . getName ( ) ) ! = - 1 ) ; 
 } 
 catch ( Throwable e ) { 
 fail ( " Method declared with Java Object return should throw IllegalArgumentException , not " + e ) ;
