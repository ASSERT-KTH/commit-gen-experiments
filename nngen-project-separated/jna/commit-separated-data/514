BLEU SCORE: 0.03283637368030199

TEST MSG: make conditional read perform auto - read
GENERATED MSG: update more Structure . newInstance calls

TEST DIFF (one line): diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java <nl> index 819f536 . . a8bb107 100644 <nl> - - - a / src / com / sun / jna / CallbackReference . java <nl> + + + b / src / com / sun / jna / CallbackReference . java <nl> @ @ - 521 , 7 + 521 , 7 @ @ class CallbackReference extends WeakReference { <nl> } <nl> else { <nl> Structure s = Structure . newInstance ( dstType , ( Pointer ) value ) ; <nl> - s . conditionalRead ( ) ; <nl> + s . conditionalAutoRead ( ) ; <nl> value = s ; <nl> } <nl> } <nl> diff - - git a / src / com / sun / jna / Function . java b / src / com / sun / jna / Function . java <nl> index 7cf8c1b . . 4924581 100644 <nl> - - - a / src / com / sun / jna / Function . java <nl> + + + b / src / com / sun / jna / Function . java <nl> @ @ - 376 , 7 + 376 , 7 @ @ public class Function extends Pointer { <nl> result = invokePointer ( callFlags , args ) ; <nl> if ( result ! = null ) { <nl> Structure s = Structure . newInstance ( returnType , ( Pointer ) result ) ; <nl> - s . conditionalRead ( ) ; <nl> + s . conditionalAutoRead ( ) ; <nl> result = s ; <nl> } <nl> } <nl> diff - - git a / src / com / sun / jna / Pointer . java b / src / com / sun / jna / Pointer . java <nl> index 937db13 . . 4c9c4a0 100644 <nl> - - - a / src / com / sun / jna / Pointer . java <nl> + + + b / src / com / sun / jna / Pointer . java <nl> @ @ - 518 , 7 + 518 , 7 @ @ public class Pointer { <nl> Structure first = sarray [ 0 ] ; <nl> if ( first = = null ) { <nl> first = Structure . newInstance ( cls , share ( offset ) ) ; <nl> - first . conditionalRead ( ) ; <nl> + first . conditionalAutoRead ( ) ; <nl> sarray [ 0 ] = first ; <nl> } <nl> else { <nl> diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java <nl> index f2e8f7e . . 864ae5a 100644 <nl> - - - a / src / com / sun / jna / Structure . java <nl> + + + b / src / com / sun / jna / Structure . java <nl> @ @ - 482 , 10 + 482 , 10 @ @ public abstract class Structure { <nl> return ( Map ) reads . get ( ) ; <nl> } <nl> <nl> - / * * Reads only if uninitialized . * / <nl> - void conditionalRead ( ) { <nl> + / * * Performs auto - read only if uninitialized . * / <nl> + void conditionalAutoRead ( ) { <nl> if ( ! readCalled ) { <nl> - read ( ) ; <nl> + autoRead ( ) ; <nl> } <nl> } <nl> <nl> @ @ - 1384 , 7 + 1384 , 7 @ @ public abstract class Structure { <nl> int size = size ( ) ; <nl> for ( int i = 1 ; i < array . length ; i + + ) { <nl> array [ i ] = newInstance ( getClass ( ) , memory . share ( i * size , size ) ) ; <nl> - array [ i ] . conditionalRead ( ) ; <nl> + array [ i ] . conditionalAutoRead ( ) ; <nl> } <nl> <nl> if ( ! ( this instanceof ByValue ) ) { <nl> @ @ - 1485 , 6 + 1485 , 18 @ @ public abstract class Structure { <nl> setAutoRead ( auto ) ; <nl> setAutoWrite ( auto ) ; <nl> < / code > < / pre > <nl> + For extremely large or complex structures where you only need to <nl> + access a small number of fields , you may see a significant performance <nl> + benefit by avoiding automatic structure reads and writes . If <nl> + auto - read and - write are disabled , it is up to you to ensure that the <nl> + Java fields of interest are synched before and after native function <nl> + calls via { @ link # readField ( String ) } and { @ link <nl> + # writeField ( String , Object ) } . <nl> + < p / > <nl> + This is typically most effective when a native call populates a large <nl> + structure and you only need a few fields out of it . After the native <nl> + call you can call { @ link # readField ( String ) } on only the fields of <nl> + interest . <nl> * / <nl> public void setAutoSynch ( boolean auto ) { <nl> setAutoRead ( auto ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / com / sun / jna / CallbackReference . java b / src / com / sun / jna / CallbackReference . java 
 index 819f536 . . a8bb107 100644 
 - - - a / src / com / sun / jna / CallbackReference . java 
 + + + b / src / com / sun / jna / CallbackReference . java 
 @ @ - 521 , 7 + 521 , 7 @ @ class CallbackReference extends WeakReference { 
 } 
 else { 
 Structure s = Structure . newInstance ( dstType , ( Pointer ) value ) ; 
 - s . conditionalRead ( ) ; 
 + s . conditionalAutoRead ( ) ; 
 value = s ; 
 } 
 } 
 diff - - git a / src / com / sun / jna / Function . java b / src / com / sun / jna / Function . java 
 index 7cf8c1b . . 4924581 100644 
 - - - a / src / com / sun / jna / Function . java 
 + + + b / src / com / sun / jna / Function . java 
 @ @ - 376 , 7 + 376 , 7 @ @ public class Function extends Pointer { 
 result = invokePointer ( callFlags , args ) ; 
 if ( result ! = null ) { 
 Structure s = Structure . newInstance ( returnType , ( Pointer ) result ) ; 
 - s . conditionalRead ( ) ; 
 + s . conditionalAutoRead ( ) ; 
 result = s ; 
 } 
 } 
 diff - - git a / src / com / sun / jna / Pointer . java b / src / com / sun / jna / Pointer . java 
 index 937db13 . . 4c9c4a0 100644 
 - - - a / src / com / sun / jna / Pointer . java 
 + + + b / src / com / sun / jna / Pointer . java 
 @ @ - 518 , 7 + 518 , 7 @ @ public class Pointer { 
 Structure first = sarray [ 0 ] ; 
 if ( first = = null ) { 
 first = Structure . newInstance ( cls , share ( offset ) ) ; 
 - first . conditionalRead ( ) ; 
 + first . conditionalAutoRead ( ) ; 
 sarray [ 0 ] = first ; 
 } 
 else { 
 diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java 
 index f2e8f7e . . 864ae5a 100644 
 - - - a / src / com / sun / jna / Structure . java 
 + + + b / src / com / sun / jna / Structure . java 
 @ @ - 482 , 10 + 482 , 10 @ @ public abstract class Structure { 
 return ( Map ) reads . get ( ) ; 
 } 
 
 - / * * Reads only if uninitialized . * / 
 - void conditionalRead ( ) { 
 + / * * Performs auto - read only if uninitialized . * / 
 + void conditionalAutoRead ( ) { 
 if ( ! readCalled ) { 
 - read ( ) ; 
 + autoRead ( ) ; 
 } 
 } 
 
 @ @ - 1384 , 7 + 1384 , 7 @ @ public abstract class Structure { 
 int size = size ( ) ; 
 for ( int i = 1 ; i < array . length ; i + + ) { 
 array [ i ] = newInstance ( getClass ( ) , memory . share ( i * size , size ) ) ; 
 - array [ i ] . conditionalRead ( ) ; 
 + array [ i ] . conditionalAutoRead ( ) ; 
 } 
 
 if ( ! ( this instanceof ByValue ) ) { 
 @ @ - 1485 , 6 + 1485 , 18 @ @ public abstract class Structure { 
 setAutoRead ( auto ) ; 
 setAutoWrite ( auto ) ; 
 < / code > < / pre > 
 + For extremely large or complex structures where you only need to 
 + access a small number of fields , you may see a significant performance 
 + benefit by avoiding automatic structure reads and writes . If 
 + auto - read and - write are disabled , it is up to you to ensure that the 
 + Java fields of interest are synched before and after native function 
 + calls via { @ link # readField ( String ) } and { @ link 
 + # writeField ( String , Object ) } . 
 + < p / > 
 + This is typically most effective when a native call populates a large 
 + structure and you only need a few fields out of it . After the native 
 + call you can call { @ link # readField ( String ) } on only the fields of 
 + interest . 
 * / 
 public void setAutoSynch ( boolean auto ) { 
 setAutoRead ( auto ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
