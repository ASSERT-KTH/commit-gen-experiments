BLEU SCORE: 0.028465126651392333

TEST MSG: fix JNI containing classname in performance test
GENERATED MSG: rename native method according to Java class rename

TEST DIFF (one line): diff - - git a / native / testlib . c b / native / testlib . c <nl> index d7e0d18 . . 60dc1d7 100644 <nl> - - - a / native / testlib . c <nl> + + + b / native / testlib . c <nl> @ @ - 937 , 7 + 937 , 7 @ @ callInt32StdCallCallback ( int32 _ t ( _ _ stdcall * func ) ( int32 _ t arg , int32 _ t arg2 ) , <nl> # include < jni . h > <nl> # include < math . h > <nl> JNIEXPORT jdouble JNICALL <nl> - Java _ com _ sun _ jna _ DirectTest _ 00024JNI _ cos ( JNIEnv * env , jclass cls , jdouble x ) { <nl> + Java _ com _ sun _ jna _ PerformanceTest _ 00024JNI _ cos ( JNIEnv * env , jclass cls , jdouble x ) { <nl> return cos ( x ) ; <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html <nl> index 1e99f47 . . 0328ad1 100644 <nl> - - - a / jnalib / src / com / sun / jna / overview . html <nl> + + + b / jnalib / src / com / sun / jna / overview . html <nl> @ @ - 132 , 30 + 132 , 33 @ @ An instance of the { @ link com . sun . jna . Function } class is obtained through the { @ <nl> Java types must be chosen to match native types of the same size . Following are the types supported by the JNA library . < p > <nl> < center > <nl> < table border = 1 borderColor = white class = styled width = " 100 % " > <nl> - < tr > < td > < b > Java Type < / b > < / td > < td > < b > C Type < / b > < / td > < td > < b > Native Representation < / b > < / td > < / tr > <nl> - < tr > < td > boolean < / td > < td > int < / td > < td > 32 - bit integer ( customizable ) < / td > <nl> - < tr > < td > byte < / td > < td > char < / td > < td > 8 - bit integer < / td > <nl> - < tr > < td > char < / td > < td > wchar _ t < / td > < td > platform - dependent < / td > <nl> - < tr > < td > short < / td > < td > short < / td > < td > 16 - bit integer < / td > <nl> - < tr > < td > int < / td > < td > int < / td > < td > 32 - bit integer < / td > <nl> - < tr > < td > long < / td > < td > long long , _ _ int64 < / td > < td > 64 - bit integer < / td > <nl> - < tr > < td > float < / td > < td > float < / td > < td > 32 - bit floating point < / td > <nl> - < tr > < td > double < / td > < td > double < / td > < td > 64 - bit floating point < / td > <nl> - < tr > < td > { @ link java . nio . Buffer } < br > <nl> - { @ link com . sun . jna . Pointer } < td > pointer < / td > < td > platform - dependent ( 32 - or 64 - bit pointer to memory ) < / td > <nl> - < tr > < td > & lt ; T & gt ; [ ] ( array of primitive type ) < / td > < td > pointer < br > array < / td > < td > 32 - or 64 - bit pointer to memory ( argument / return ) < br > contiguous memory ( struct member ) < / td > <nl> - < tr > < td colspan = 3 > In addition to the above types , which are supported at the native layer , the JNA Java library automatically handles the following types . All but < code > NativeMapped < / code > and < code > NativeLong < / code > are converted to { @ link com . sun . jna . Pointer } before being passed to the native layer . < / td > < / tr > <nl> - < tr > < td > { @ link java . lang . String } < / td > < td > char * < / td > < td > NUL - terminated array ( native encoding or < code > jna . encoding < / code > ) < / td > <nl> - < tr > < td > { @ link com . sun . jna . WString } < / td > < td > wchar _ t * < / td > < td > NUL - terminated array ( unicode ) < / td > <nl> - < tr > < td > { @ link java . lang . String String [ ] } < / td > < td > char * * < / td > < td > NULL - terminated array of C strings < / td > <nl> - < tr > < td > { @ link com . sun . jna . WString WString [ ] } < / td > < td > wchar _ t * * < / td > < td > NULL - terminated array of wide C strings < / td > <nl> - < tr > < td > { @ link com . sun . jna . Structure } < / td > < td > struct * < br > struct < / td > < td > pointer to struct ( argument or return ) ( { @ link com . sun . jna . Structure . ByReference or explicitly } ) < br > struct by value ( member of struct ) ( { @ link com . sun . jna . Structure . ByValue or explicitly } ) < / td > <nl> - < tr > < td > { @ link com . sun . jna . Union } < / td > < td > union < / td > < td > same as < code > Structure < / code > < / td > <nl> - < tr > < td > { @ link com . sun . jna . Structure Structure [ ] } < / td > < td > struct [ ] < / td > < td > array of structs , contiguous in memory < / td > <nl> - < tr > < td > { @ link com . sun . jna . Callback } < / td > < td > & lt ; T & gt ; ( * fp ) ( ) < / td > < td > function pointer ( Java or native ) < / td > <nl> - < tr > < td > { @ link com . sun . jna . NativeMapped } < / td > < td > varies < / td > < td > depends on definition < / td > <nl> - < tr > < td > { @ link com . sun . jna . NativeLong } < / td > < td > long < / td > < td > platform - dependent ( 32 - or 64 - bit integer ) < / td > <nl> - < tr > < td > { @ link com . sun . jna . PointerType } < / td > < td > pointer < / td > < td > same as < code > Pointer < / code > < / td > <nl> + < tr > < td > < b > C Type < / b > < / td > < td > < b > Native Representation < / b > < / td > < td > < b > Java Type < / b > < / td > < / tr > <nl> + < tr > < td > char < / td > < td > 8 - bit integer < / td > < td > byte < / td > < / tr > <nl> + < tr > < td > wchar _ t < / td > < td > platform - dependent < / td > < td > char < / td > < / tr > <nl> + < tr > < td > short < / td > < td > 16 - bit integer < / td > < td > short < / td > < / tr > <nl> + < tr > < td > int < / td > < td > 32 - bit integer < / td > < td > int < / td > < / tr > <nl> + < tr > < td > int < / td > < td > boolean flag < / td > < td > boolean < / td > < / tr > <nl> + < tr > < td > enum < / td > < td > enumeration type < / td > < td > int ( usually ) < / td > < / tr > <nl> + < tr > < td > long long , _ _ int64 < / td > < td > 64 - bit integer < / td > < td > long < / td > < / tr > <nl> + < tr > < td > float < / td > < td > 32 - bit floating point < / td > < td > float < / td > < / tr > <nl> + < tr > < td > double < / td > < td > 64 - bit floating point < / td > < td > double < / td > < / tr > <nl> + < tr > < td > pointer ( e . g . void * ) < / td > < td > platform - dependent ( 32 - or 64 - bit pointer to memory ) < / td > < td > { @ link java . nio . Buffer } < br > <nl> + { @ link com . sun . jna . Pointer } < / td > < / tr > <nl> + < tr > < td > pointer ( e . g . void * ) , < br > array < / td > < td > 32 - or 64 - bit pointer to memory ( argument / return ) < br > contiguous memory ( struct member ) < / td > < td > & lt ; P & gt ; [ ] ( array of primitive type ) < / td > < / tr > <nl> + < tr > < td colspan = ' 3 ' style = ' padding : 20px 5px ' > In addition to the above types , which are supported at the native layer , the JNA Java library automatically handles the following types . All but < code > NativeMapped < / code > and < code > NativeLong < / code > are converted to { @ link com . sun . jna . Pointer } before being passed to the native layer . < / td > < / tr > <nl> + < tr > < td > long < / td > < td > platform - dependent ( 32 - or 64 - bit integer ) < / td > < td > { @ link com . sun . jna . NativeLong } < / td > < / tr > <nl> + < tr > < td > const char * < / td > < td > NUL - terminated array ( native encoding or < code > jna . encoding < / code > ) < / td > < td > { @ link java . lang . String } < / td > < / tr > <nl> + < tr > < td > const wchar _ t * < / td > < td > NUL - terminated array ( unicode ) < / td > < td > { @ link com . sun . jna . WString } < / td > < / tr > <nl> + < tr > < td > char * * < / td > < td > NULL - terminated array of C strings < / td > < td > { @ link java . lang . String String [ ] } < / td > < / tr > <nl> + < tr > < td > wchar _ t * * < / td > < td > NULL - terminated array of wide C strings < / td > < td > { @ link com . sun . jna . WString WString [ ] } < / td > < / tr > <nl> + < tr > < td > void * * < / td > < td > NULL - terminated array of pointers < / td > < td > { @ link com . sun . jna . Pointer Pointer [ ] } < / td > < / tr > <nl> + < tr > < td > struct * < br > struct < / td > < td > pointer to struct ( argument or return ) ( { @ link com . sun . jna . Structure . ByReference or explicitly } ) < br > struct by value ( member of struct ) ( { @ link com . sun . jna . Structure . ByValue or explicitly } ) < / td > < td > { @ link com . sun . jna . Structure } < / td > < / tr > <nl> + < tr > < td > union < / td > < td > same as < code > Structure < / code > < / td > < td > { @ link com . sun . jna . Union } < / td > < / tr > <nl> + < tr > < td > struct [ ] < / td > < td > array of structs , contiguous in memory < / td > < td > { @ link com . sun . jna . Structure Structure [ ] } < / td > < / tr > <nl> + < tr > < td > void ( * FP ) ( ) < / td > < td > function pointer ( Java or native ) < / td > < td > { @ link com . sun . jna . Callback } < / td > < / tr > <nl> + < tr > < td > pointer ( & lt ; T & gt ; * ) < / td > < td > same as < code > Pointer < / code > < / td > < td > { @ link com . sun . jna . PointerType } < / td > < / tr > <nl> + < tr > < td > other < / td > < td > integer type < / td > < td > { @ link com . sun . jna . IntegerType } < / td > < / tr > <nl> + < tr > < td > other < / td > < td > custom mapping , depends on definition < / td > < td > { @ link com . sun . jna . NativeMapped } < / td > < / tr > <nl> < / table > <nl> < / center > <nl> < p > <nl> @ @ - 170 , 8 + 173 , 8 @ @ Java types must be chosen to match native types of the same size . Following are <nl> single call . If the native code keeps a reference to the memory , use { @ link <nl> com . sun . jna . Memory } or { @ link java . nio . Buffer } instead . <nl> < li > Primitive arrays and structures as members of a structure are overlaid on the parent structure memory . <nl> - < li > Bitfields must be manully packed into an integer type . <nl> - < li > All other types must eventually be converted to one of the types in this table . Methods with arguments or return values of types other than these must either use types deriving from { @ link com . sun . jna . NativeMapped } or supply type conversion information for the unsupported types . <nl> + < li > Bitfields must be manually packed into an integer type . <nl> + < li > All other types must eventually be converted to one of the types in the this table . Methods with arguments or return values of types other than these must either use types deriving from { @ link com . sun . jna . NativeMapped } or supply type conversion information for the unsupported types . <nl> < li > Type mapping behavior may be customized by providing a { @ link com . sun . jna . TypeMapper } for the { @ link com . sun . jna . Library # OPTION _ TYPE _ MAPPER } option when initializing a library interface . See { @ link com . sun . jna . win32 . W32APITypeMapper } for an example which provides custom conversion of boolean and String types . You are free to use whatever types are convenient in your defined interfaces , but all custom types < em > must < / em > provide a mapping to one of the basic or derived types listed above . <nl> < li > Type mapping may also be customized on a per - class basis for user - defined types by making the user - defined type implement the { @ link com . sun . jna . NativeMapped } interface . <nl> < li > < code > Structure < / code > and < code > Union < / code > are < em > not < / em > converted to < code > Pointer < / code > when passed by value . <nl> @ @ - 654 , 9 + 657 , 16 @ @ NOTE : When protected mode is enabled , you should make use of the jsig library , i <nl> < a name = " performance " > < / a > <nl> < h2 > Performance < / h2 > <nl> < h3 > Use direct mapping of methods < / h3 > <nl> - While more limited in its support of automatic type conversion , using < a href = " # direct - mapping " > direct mapping < / a > of methods makes native calls more efficiently than does interface mapping . <nl> + Using < a href = " # direct - mapping " > direct mapping < / a > of methods makes native <nl> + calls more efficiently than does interface mapping . Direct mapping does not <nl> + support varargs calls or arrays of Pointer , String , or WString as an argument <nl> + or return value . <nl> + < h3 > Avoid type mapping < / h3 > <nl> + Type mapping incurs additional overhead on each function call . You can avoid <nl> + this by ensuring that your arguments and / or return types are already primitive <nl> + types . <nl> < h3 > Pointer / Array / Buffer Variants < / h3 > <nl> - Java primitive arrays are generally slower to use than memory <nl> + Java primitive arrays are generally slower to use than direct memory <nl> ( Pointer , Memory , or ByReference ) or NIO buffers , since the Java memory has to <nl> be pinned and possibly copied across the native call , since the Java array is not necessarily contiguously allocated . <nl> < h3 > Large Structures < / h3 > <nl> diff - - git a / www / index . html b / www / index . html <nl> index e18a156 . . ae41ce5 100644 <nl> - - - a / www / index . html <nl> + + + b / www / index . html <nl> @ @ - 3 , 7 + 3 , 7 @ @ <nl> < meta name = " author " content = " Timothy Wall " > <nl> < meta name = " keywords " content = " java , jna , jni , c , c + + , native , method , function , call , ctypes , ffi , foreign function interface , jdirect , jinvoke , pinvoke , platform invoke , native library access , native access , call native from java , java c library , easy jni , call c from java , avoid jni , jni alternative , jni replacement , legacy , call from java , replace jni " > <nl> < meta name = " description " content = " Java Native Access ( JNA ) : access native libraries with pure Java code . " > <nl> - < meta name = " date " content = " 2009 - 07 - 16 " > <nl> + < meta name = " date " content = " 2009 - 07 - 21 " > <nl> < title > Java Native Access ( JNA ) : Pure Java access to native libraries < / title > <nl> < meta http - equiv = " Content - Type " content = " text / html ; charset = iso - 8859 - 1 " > <nl> < / head > <nl> @ @ - 238 , 7 + 238 , 9 @ @ Java primitive types ( and their object equivalents ) map directly to the native C <nl> < tr > < td > char * < / td > < td > C string < / td > < td > String < / td > < td > LPTCSTR < / td > <nl> < tr > < td > void * < / td > < td > pointer < / td > < td > Pointer < / td > < td > LPVOID , HANDLE , LP < i > XXX < / i > < / td > <nl> < / table > < / blockquote > <nl> - Unsigned types use the same mappings as signed types . A full list of mappings may be found < a href = " javadoc / overview - summary . html # marshalling " > here < / a > . <nl> + Unsigned types use the same mappings as signed types . C enums are usually <nl> + interchangeable with " int " . A more comprehensive list of mappings may be <nl> + found < a href = " javadoc / overview - summary . html # marshalling " > here < / a > . <nl> < p > <nl> <nl> < a href = # top > Top < / a >

TEST DIFF:
diff - - git a / native / testlib . c b / native / testlib . c 
 index d7e0d18 . . 60dc1d7 100644 
 - - - a / native / testlib . c 
 + + + b / native / testlib . c 
 @ @ - 937 , 7 + 937 , 7 @ @ callInt32StdCallCallback ( int32 _ t ( _ _ stdcall * func ) ( int32 _ t arg , int32 _ t arg2 ) , 
 # include < jni . h > 
 # include < math . h > 
 JNIEXPORT jdouble JNICALL 
 - Java _ com _ sun _ jna _ DirectTest _ 00024JNI _ cos ( JNIEnv * env , jclass cls , jdouble x ) { 
 + Java _ com _ sun _ jna _ PerformanceTest _ 00024JNI _ cos ( JNIEnv * env , jclass cls , jdouble x ) { 
 return cos ( x ) ; 
 } 


NEAREST DIFF:
diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html 
 index 1e99f47 . . 0328ad1 100644 
 - - - a / jnalib / src / com / sun / jna / overview . html 
 + + + b / jnalib / src / com / sun / jna / overview . html 
 @ @ - 132 , 30 + 132 , 33 @ @ An instance of the { @ link com . sun . jna . Function } class is obtained through the { @ 
 Java types must be chosen to match native types of the same size . Following are the types supported by the JNA library . < p > 
 < center > 
 < table border = 1 borderColor = white class = styled width = " 100 % " > 
 - < tr > < td > < b > Java Type < / b > < / td > < td > < b > C Type < / b > < / td > < td > < b > Native Representation < / b > < / td > < / tr > 
 - < tr > < td > boolean < / td > < td > int < / td > < td > 32 - bit integer ( customizable ) < / td > 
 - < tr > < td > byte < / td > < td > char < / td > < td > 8 - bit integer < / td > 
 - < tr > < td > char < / td > < td > wchar _ t < / td > < td > platform - dependent < / td > 
 - < tr > < td > short < / td > < td > short < / td > < td > 16 - bit integer < / td > 
 - < tr > < td > int < / td > < td > int < / td > < td > 32 - bit integer < / td > 
 - < tr > < td > long < / td > < td > long long , _ _ int64 < / td > < td > 64 - bit integer < / td > 
 - < tr > < td > float < / td > < td > float < / td > < td > 32 - bit floating point < / td > 
 - < tr > < td > double < / td > < td > double < / td > < td > 64 - bit floating point < / td > 
 - < tr > < td > { @ link java . nio . Buffer } < br > 
 - { @ link com . sun . jna . Pointer } < td > pointer < / td > < td > platform - dependent ( 32 - or 64 - bit pointer to memory ) < / td > 
 - < tr > < td > & lt ; T & gt ; [ ] ( array of primitive type ) < / td > < td > pointer < br > array < / td > < td > 32 - or 64 - bit pointer to memory ( argument / return ) < br > contiguous memory ( struct member ) < / td > 
 - < tr > < td colspan = 3 > In addition to the above types , which are supported at the native layer , the JNA Java library automatically handles the following types . All but < code > NativeMapped < / code > and < code > NativeLong < / code > are converted to { @ link com . sun . jna . Pointer } before being passed to the native layer . < / td > < / tr > 
 - < tr > < td > { @ link java . lang . String } < / td > < td > char * < / td > < td > NUL - terminated array ( native encoding or < code > jna . encoding < / code > ) < / td > 
 - < tr > < td > { @ link com . sun . jna . WString } < / td > < td > wchar _ t * < / td > < td > NUL - terminated array ( unicode ) < / td > 
 - < tr > < td > { @ link java . lang . String String [ ] } < / td > < td > char * * < / td > < td > NULL - terminated array of C strings < / td > 
 - < tr > < td > { @ link com . sun . jna . WString WString [ ] } < / td > < td > wchar _ t * * < / td > < td > NULL - terminated array of wide C strings < / td > 
 - < tr > < td > { @ link com . sun . jna . Structure } < / td > < td > struct * < br > struct < / td > < td > pointer to struct ( argument or return ) ( { @ link com . sun . jna . Structure . ByReference or explicitly } ) < br > struct by value ( member of struct ) ( { @ link com . sun . jna . Structure . ByValue or explicitly } ) < / td > 
 - < tr > < td > { @ link com . sun . jna . Union } < / td > < td > union < / td > < td > same as < code > Structure < / code > < / td > 
 - < tr > < td > { @ link com . sun . jna . Structure Structure [ ] } < / td > < td > struct [ ] < / td > < td > array of structs , contiguous in memory < / td > 
 - < tr > < td > { @ link com . sun . jna . Callback } < / td > < td > & lt ; T & gt ; ( * fp ) ( ) < / td > < td > function pointer ( Java or native ) < / td > 
 - < tr > < td > { @ link com . sun . jna . NativeMapped } < / td > < td > varies < / td > < td > depends on definition < / td > 
 - < tr > < td > { @ link com . sun . jna . NativeLong } < / td > < td > long < / td > < td > platform - dependent ( 32 - or 64 - bit integer ) < / td > 
 - < tr > < td > { @ link com . sun . jna . PointerType } < / td > < td > pointer < / td > < td > same as < code > Pointer < / code > < / td > 
 + < tr > < td > < b > C Type < / b > < / td > < td > < b > Native Representation < / b > < / td > < td > < b > Java Type < / b > < / td > < / tr > 
 + < tr > < td > char < / td > < td > 8 - bit integer < / td > < td > byte < / td > < / tr > 
 + < tr > < td > wchar _ t < / td > < td > platform - dependent < / td > < td > char < / td > < / tr > 
 + < tr > < td > short < / td > < td > 16 - bit integer < / td > < td > short < / td > < / tr > 
 + < tr > < td > int < / td > < td > 32 - bit integer < / td > < td > int < / td > < / tr > 
 + < tr > < td > int < / td > < td > boolean flag < / td > < td > boolean < / td > < / tr > 
 + < tr > < td > enum < / td > < td > enumeration type < / td > < td > int ( usually ) < / td > < / tr > 
 + < tr > < td > long long , _ _ int64 < / td > < td > 64 - bit integer < / td > < td > long < / td > < / tr > 
 + < tr > < td > float < / td > < td > 32 - bit floating point < / td > < td > float < / td > < / tr > 
 + < tr > < td > double < / td > < td > 64 - bit floating point < / td > < td > double < / td > < / tr > 
 + < tr > < td > pointer ( e . g . void * ) < / td > < td > platform - dependent ( 32 - or 64 - bit pointer to memory ) < / td > < td > { @ link java . nio . Buffer } < br > 
 + { @ link com . sun . jna . Pointer } < / td > < / tr > 
 + < tr > < td > pointer ( e . g . void * ) , < br > array < / td > < td > 32 - or 64 - bit pointer to memory ( argument / return ) < br > contiguous memory ( struct member ) < / td > < td > & lt ; P & gt ; [ ] ( array of primitive type ) < / td > < / tr > 
 + < tr > < td colspan = ' 3 ' style = ' padding : 20px 5px ' > In addition to the above types , which are supported at the native layer , the JNA Java library automatically handles the following types . All but < code > NativeMapped < / code > and < code > NativeLong < / code > are converted to { @ link com . sun . jna . Pointer } before being passed to the native layer . < / td > < / tr > 
 + < tr > < td > long < / td > < td > platform - dependent ( 32 - or 64 - bit integer ) < / td > < td > { @ link com . sun . jna . NativeLong } < / td > < / tr > 
 + < tr > < td > const char * < / td > < td > NUL - terminated array ( native encoding or < code > jna . encoding < / code > ) < / td > < td > { @ link java . lang . String } < / td > < / tr > 
 + < tr > < td > const wchar _ t * < / td > < td > NUL - terminated array ( unicode ) < / td > < td > { @ link com . sun . jna . WString } < / td > < / tr > 
 + < tr > < td > char * * < / td > < td > NULL - terminated array of C strings < / td > < td > { @ link java . lang . String String [ ] } < / td > < / tr > 
 + < tr > < td > wchar _ t * * < / td > < td > NULL - terminated array of wide C strings < / td > < td > { @ link com . sun . jna . WString WString [ ] } < / td > < / tr > 
 + < tr > < td > void * * < / td > < td > NULL - terminated array of pointers < / td > < td > { @ link com . sun . jna . Pointer Pointer [ ] } < / td > < / tr > 
 + < tr > < td > struct * < br > struct < / td > < td > pointer to struct ( argument or return ) ( { @ link com . sun . jna . Structure . ByReference or explicitly } ) < br > struct by value ( member of struct ) ( { @ link com . sun . jna . Structure . ByValue or explicitly } ) < / td > < td > { @ link com . sun . jna . Structure } < / td > < / tr > 
 + < tr > < td > union < / td > < td > same as < code > Structure < / code > < / td > < td > { @ link com . sun . jna . Union } < / td > < / tr > 
 + < tr > < td > struct [ ] < / td > < td > array of structs , contiguous in memory < / td > < td > { @ link com . sun . jna . Structure Structure [ ] } < / td > < / tr > 
 + < tr > < td > void ( * FP ) ( ) < / td > < td > function pointer ( Java or native ) < / td > < td > { @ link com . sun . jna . Callback } < / td > < / tr > 
 + < tr > < td > pointer ( & lt ; T & gt ; * ) < / td > < td > same as < code > Pointer < / code > < / td > < td > { @ link com . sun . jna . PointerType } < / td > < / tr > 
 + < tr > < td > other < / td > < td > integer type < / td > < td > { @ link com . sun . jna . IntegerType } < / td > < / tr > 
 + < tr > < td > other < / td > < td > custom mapping , depends on definition < / td > < td > { @ link com . sun . jna . NativeMapped } < / td > < / tr > 
 < / table > 
 < / center > 
 < p > 
 @ @ - 170 , 8 + 173 , 8 @ @ Java types must be chosen to match native types of the same size . Following are 
 single call . If the native code keeps a reference to the memory , use { @ link 
 com . sun . jna . Memory } or { @ link java . nio . Buffer } instead . 
 < li > Primitive arrays and structures as members of a structure are overlaid on the parent structure memory . 
 - < li > Bitfields must be manully packed into an integer type . 
 - < li > All other types must eventually be converted to one of the types in this table . Methods with arguments or return values of types other than these must either use types deriving from { @ link com . sun . jna . NativeMapped } or supply type conversion information for the unsupported types . 
 + < li > Bitfields must be manually packed into an integer type . 
 + < li > All other types must eventually be converted to one of the types in the this table . Methods with arguments or return values of types other than these must either use types deriving from { @ link com . sun . jna . NativeMapped } or supply type conversion information for the unsupported types . 
 < li > Type mapping behavior may be customized by providing a { @ link com . sun . jna . TypeMapper } for the { @ link com . sun . jna . Library # OPTION _ TYPE _ MAPPER } option when initializing a library interface . See { @ link com . sun . jna . win32 . W32APITypeMapper } for an example which provides custom conversion of boolean and String types . You are free to use whatever types are convenient in your defined interfaces , but all custom types < em > must < / em > provide a mapping to one of the basic or derived types listed above . 
 < li > Type mapping may also be customized on a per - class basis for user - defined types by making the user - defined type implement the { @ link com . sun . jna . NativeMapped } interface . 
 < li > < code > Structure < / code > and < code > Union < / code > are < em > not < / em > converted to < code > Pointer < / code > when passed by value . 
 @ @ - 654 , 9 + 657 , 16 @ @ NOTE : When protected mode is enabled , you should make use of the jsig library , i 
 < a name = " performance " > < / a > 
 < h2 > Performance < / h2 > 
 < h3 > Use direct mapping of methods < / h3 > 
 - While more limited in its support of automatic type conversion , using < a href = " # direct - mapping " > direct mapping < / a > of methods makes native calls more efficiently than does interface mapping . 
 + Using < a href = " # direct - mapping " > direct mapping < / a > of methods makes native 
 + calls more efficiently than does interface mapping . Direct mapping does not 
 + support varargs calls or arrays of Pointer , String , or WString as an argument 
 + or return value . 
 + < h3 > Avoid type mapping < / h3 > 
 + Type mapping incurs additional overhead on each function call . You can avoid 
 + this by ensuring that your arguments and / or return types are already primitive 
 + types . 
 < h3 > Pointer / Array / Buffer Variants < / h3 > 
 - Java primitive arrays are generally slower to use than memory 
 + Java primitive arrays are generally slower to use than direct memory 
 ( Pointer , Memory , or ByReference ) or NIO buffers , since the Java memory has to 
 be pinned and possibly copied across the native call , since the Java array is not necessarily contiguously allocated . 
 < h3 > Large Structures < / h3 > 
 diff - - git a / www / index . html b / www / index . html 
 index e18a156 . . ae41ce5 100644 
 - - - a / www / index . html 
 + + + b / www / index . html 
 @ @ - 3 , 7 + 3 , 7 @ @ 
 < meta name = " author " content = " Timothy Wall " > 
 < meta name = " keywords " content = " java , jna , jni , c , c + + , native , method , function , call , ctypes , ffi , foreign function interface , jdirect , jinvoke , pinvoke , platform invoke , native library access , native access , call native from java , java c library , easy jni , call c from java , avoid jni , jni alternative , jni replacement , legacy , call from java , replace jni " > 
 < meta name = " description " content = " Java Native Access ( JNA ) : access native libraries with pure Java code . " > 
 - < meta name = " date " content = " 2009 - 07 - 16 " > 
 + < meta name = " date " content = " 2009 - 07 - 21 " > 
 < title > Java Native Access ( JNA ) : Pure Java access to native libraries < / title > 
 < meta http - equiv = " Content - Type " content = " text / html ; charset = iso - 8859 - 1 " > 
 < / head > 
 @ @ - 238 , 7 + 238 , 9 @ @ Java primitive types ( and their object equivalents ) map directly to the native C 
 < tr > < td > char * < / td > < td > C string < / td > < td > String < / td > < td > LPTCSTR < / td > 
 < tr > < td > void * < / td > < td > pointer < / td > < td > Pointer < / td > < td > LPVOID , HANDLE , LP < i > XXX < / i > < / td > 
 < / table > < / blockquote > 
 - Unsigned types use the same mappings as signed types . A full list of mappings may be found < a href = " javadoc / overview - summary . html # marshalling " > here < / a > . 
 + Unsigned types use the same mappings as signed types . C enums are usually 
 + interchangeable with " int " . A more comprehensive list of mappings may be 
 + found < a href = " javadoc / overview - summary . html # marshalling " > here < / a > . 
 < p > 
 
 < a href = # top > Top < / a >
