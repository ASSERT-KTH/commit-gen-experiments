BLEU SCORE: 0.01763751180315069

TEST MSG: Fix building tests on openjdk 6
GENERATED MSG: Improve error messages when illegal argument / return types are used

TEST DIFF (one line): diff - - git a / native / testlib . c b / native / testlib . c <nl> index cbf8959 . . 0747e45 100644 <nl> - - - a / native / testlib . c <nl> + + + b / native / testlib . c <nl> @ @ - 928 , 6 + 928 , 16 @ @ returnStringVarArgs ( const char * fmt , . . . ) { <nl> return cp ; <nl> } <nl> <nl> + EXPORT char * <nl> + returnStringVarArgs2 ( const char * fmt , . . . ) { <nl> + char * cp ; <nl> + va _ list ap ; <nl> + va _ start ( ap , fmt ) ; <nl> + cp = va _ arg ( ap , char * ) ; <nl> + va _ end ( ap ) ; <nl> + return cp ; <nl> + } <nl> + <nl> # if defined ( _ WIN32 ) & & ! defined ( _ WIN64 ) & & ! defined ( _ WIN32 _ WCE ) <nl> / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> / / stdcall tests <nl> diff - - git a / test / com / sun / jna / VarArgsTest . java b / test / com / sun / jna / VarArgsTest . java <nl> index aeb1473 . . a10938a 100644 <nl> - - - a / test / com / sun / jna / VarArgsTest . java <nl> + + + b / test / com / sun / jna / VarArgsTest . java <nl> @ @ - 43 , 7 + 43 , 7 @ @ public class VarArgsTest extends TestCase { <nl> public int addVarArgs ( String fmt , Number . . . args ) ; <nl> public String returnStringVarArgs ( String fmt , Object . . . args ) ; <nl> public void modifyStructureVarArgs ( String fmt , Object arg1 , Object . . . args ) ; <nl> - public String returnStringVarArgs ( String . . . args ) ; <nl> + public String returnStringVarArgs2 ( String . . . args ) ; <nl> } <nl> TestLibrary lib ; <nl> @ Override <nl> @ @ - 93 , 7 + 93 , 7 @ @ public class VarArgsTest extends TestCase { <nl> public void testStringVarArgsFull ( ) { <nl> Object [ ] args = new Object [ ] { " Test " } ; <nl> assertEquals ( " Did not return correct string " , args [ 0 ] , <nl> - lib . returnStringVarArgs ( " " , " Test " ) ) ; <nl> + lib . returnStringVarArgs2 ( " " , " Test " ) ) ; <nl> } <nl> <nl> public void testAppendNullToVarargs ( ) {
NEAREST DIFF (one line): diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html <nl> index 59606ed . . a01e107 100644 <nl> - - - a / jnalib / src / com / sun / jna / overview . html <nl> + + + b / jnalib / src / com / sun / jna / overview . html <nl> @ @ - 430 , 7 + 430 , 9 @ @ class Line2 extends Structure { <nl> } <nl> < / pre > < / code > < / blockquote > <nl> <nl> - The more general case is just a pointer to a buffer : < br > <nl> + The more general case is just a pointer to memory . This allows you to define <nl> + the field without necessarily defining the inner structure itself , similar to <nl> + declaring a struct without defining it in C : < br > <nl> <nl> < blockquote > < code > < pre > <nl> / / Original C code

TEST DIFF:
diff - - git a / native / testlib . c b / native / testlib . c 
 index cbf8959 . . 0747e45 100644 
 - - - a / native / testlib . c 
 + + + b / native / testlib . c 
 @ @ - 928 , 6 + 928 , 16 @ @ returnStringVarArgs ( const char * fmt , . . . ) { 
 return cp ; 
 } 
 
 + EXPORT char * 
 + returnStringVarArgs2 ( const char * fmt , . . . ) { 
 + char * cp ; 
 + va _ list ap ; 
 + va _ start ( ap , fmt ) ; 
 + cp = va _ arg ( ap , char * ) ; 
 + va _ end ( ap ) ; 
 + return cp ; 
 + } 
 + 
 # if defined ( _ WIN32 ) & & ! defined ( _ WIN64 ) & & ! defined ( _ WIN32 _ WCE ) 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / stdcall tests 
 diff - - git a / test / com / sun / jna / VarArgsTest . java b / test / com / sun / jna / VarArgsTest . java 
 index aeb1473 . . a10938a 100644 
 - - - a / test / com / sun / jna / VarArgsTest . java 
 + + + b / test / com / sun / jna / VarArgsTest . java 
 @ @ - 43 , 7 + 43 , 7 @ @ public class VarArgsTest extends TestCase { 
 public int addVarArgs ( String fmt , Number . . . args ) ; 
 public String returnStringVarArgs ( String fmt , Object . . . args ) ; 
 public void modifyStructureVarArgs ( String fmt , Object arg1 , Object . . . args ) ; 
 - public String returnStringVarArgs ( String . . . args ) ; 
 + public String returnStringVarArgs2 ( String . . . args ) ; 
 } 
 TestLibrary lib ; 
 @ Override 
 @ @ - 93 , 7 + 93 , 7 @ @ public class VarArgsTest extends TestCase { 
 public void testStringVarArgsFull ( ) { 
 Object [ ] args = new Object [ ] { " Test " } ; 
 assertEquals ( " Did not return correct string " , args [ 0 ] , 
 - lib . returnStringVarArgs ( " " , " Test " ) ) ; 
 + lib . returnStringVarArgs2 ( " " , " Test " ) ) ; 
 } 
 
 public void testAppendNullToVarargs ( ) {

NEAREST DIFF:
diff - - git a / jnalib / src / com / sun / jna / overview . html b / jnalib / src / com / sun / jna / overview . html 
 index 59606ed . . a01e107 100644 
 - - - a / jnalib / src / com / sun / jna / overview . html 
 + + + b / jnalib / src / com / sun / jna / overview . html 
 @ @ - 430 , 7 + 430 , 9 @ @ class Line2 extends Structure { 
 } 
 < / pre > < / code > < / blockquote > 
 
 - The more general case is just a pointer to a buffer : < br > 
 + The more general case is just a pointer to memory . This allows you to define 
 + the field without necessarily defining the inner structure itself , similar to 
 + declaring a struct without defining it in C : < br > 
 
 < blockquote > < code > < pre > 
 / / Original C code
