BLEU SCORE: 0.037477767366779206

TEST MSG: fix bug if ByValue types are explicitly used in struct fields
GENERATED MSG: Allow Pointer [ ] as field in Structure

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 979ef79 . . af951b5 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 1 , 12 + 1 , 19 @ @ <nl> + NOTE : as of JNA 4 . 0 , JNA is now dual - licensed under LGPL and ASL ( see LICENSE ) . <nl> + <nl> + NOTE : JNI native support is typically incompatible between minor versions , and almost always incompatible between major versions . <nl> + <nl> Next Release ( 4 . 0 . 1 ) <nl> = = = = = = = = = = = = = = = = = = = = <nl> <nl> - Release 4 . 0 <nl> - = = = = = = = = = = = <nl> + Features <nl> + - - - - - - - - <nl> <nl> - NOTE : as of JNA 4 . 0 , JNA is now dual - licensed under LGPL and ASL ( see LICENSE ) . <nl> + Bug Fixes <nl> + - - - - - - - - - <nl> + * Fix inconsistent behavior on ` Structure . ByValue ` fields within a ` Structure ` - [ @ twall ] ( https : / / github . com / twall ) <nl> <nl> - NOTE : JNI native support is typically incompatible between minor versions , and almost always incompatible between major versions . <nl> + Release 4 . 0 <nl> + = = = = = = = = = = = <nl> <nl> Features <nl> - - - - - - - - <nl> diff - - git a / src / com / sun / jna / Pointer . java b / src / com / sun / jna / Pointer . java <nl> index 9f554cb . . 7f3f3d8 100644 <nl> - - - a / src / com / sun / jna / Pointer . java <nl> + + + b / src / com / sun / jna / Pointer . java <nl> @ @ - 369 , 7 + 369 , 7 @ @ public class Pointer { <nl> s = Structure . updateStructureByReference ( type , s , getPointer ( offset ) ) ; <nl> } <nl> else { <nl> - s . useMemory ( this , ( int ) offset ) ; <nl> + s . useMemory ( this , ( int ) offset , true ) ; <nl> s . read ( ) ; <nl> } <nl> result = s ; <nl> @ @ - 522 , 7 + 522 , 7 @ @ public class Pointer { <nl> sarray [ 0 ] = first ; <nl> } <nl> else { <nl> - first . useMemory ( this , ( int ) offset ) ; <nl> + first . useMemory ( this , ( int ) offset , true ) ; <nl> first . read ( ) ; <nl> } <nl> Structure [ ] tmp = first . toArray ( sarray . length ) ; <nl> @ @ - 532 , 7 + 532 , 7 @ @ public class Pointer { <nl> sarray [ i ] = tmp [ i ] ; <nl> } <nl> else { <nl> - sarray [ i ] . useMemory ( this , ( int ) ( offset + i * sarray [ i ] . size ( ) ) ) ; <nl> + sarray [ i ] . useMemory ( this , ( int ) ( offset + i * sarray [ i ] . size ( ) ) , true ) ; <nl> sarray [ i ] . read ( ) ; <nl> } <nl> } <nl> @ @ - 952 , 7 + 952 , 7 @ @ v * @ param wide whether to convert from a wide or standard C string <nl> } <nl> } <nl> else { <nl> - s . useMemory ( this , ( int ) offset ) ; <nl> + s . useMemory ( this , ( int ) offset , true ) ; <nl> s . write ( ) ; <nl> } <nl> } <nl> @ @ - 1033 , 7 + 1033 , 7 @ @ v * @ param wide whether to convert from a wide or standard C string <nl> sbuf [ 0 ] = first ; <nl> } <nl> else { <nl> - first . useMemory ( this , ( int ) offset ) ; <nl> + first . useMemory ( this , ( int ) offset , true ) ; <nl> } <nl> first . write ( ) ; <nl> Structure [ ] tmp = first . toArray ( sbuf . length ) ; <nl> @ @ - 1042 , 7 + 1042 , 7 @ @ v * @ param wide whether to convert from a wide or standard C string <nl> sbuf [ i ] = tmp [ i ] ; <nl> } <nl> else { <nl> - sbuf [ i ] . useMemory ( this , ( int ) ( offset + i * sbuf [ i ] . size ( ) ) ) ; <nl> + sbuf [ i ] . useMemory ( this , ( int ) ( offset + i * sbuf [ i ] . size ( ) ) , true ) ; <nl> } <nl> sbuf [ i ] . write ( ) ; <nl> } <nl> diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java <nl> index b1bf3f2 . . c7c4f17 100644 <nl> - - - a / src / com / sun / jna / Structure . java <nl> + + + b / src / com / sun / jna / Structure . java <nl> @ @ - 178 , 7 + 178 , 7 @ @ public abstract class Structure { <nl> initializeTypeMapper ( mapper ) ; <nl> validateFields ( ) ; <nl> if ( p ! = null ) { <nl> - useMemory ( p ) ; <nl> + useMemory ( p , 0 , true ) ; <nl> } <nl> else { <nl> allocateMemory ( CALCULATE _ SIZE ) ; <nl> @ @ - 279 , 12 + 279 , 27 @ @ public abstract class Structure { <nl> * thus does not own its own memory allocation . <nl> * / <nl> protected void useMemory ( Pointer m , int offset ) { <nl> + useMemory ( m , offset , false ) ; <nl> + } <nl> + <nl> + / * * Set the memory used by this structure . This method is used to <nl> + * indicate the given structure is based on natively - allocated data , <nl> + * nested within another , or otherwise overlaid on existing memory and <nl> + * thus does not own its own memory allocation . <nl> + * @ param m Native pointer <nl> + * @ param offset offset from pointer to use <nl> + * @ param force ByValue structures normally ignore requests to use a <nl> + * different memory offset ; this input is set < code > true < / code > when <nl> + * setting a ByValue struct that is nested within another struct . <nl> + * / <nl> + void useMemory ( Pointer m , int offset , boolean force ) { <nl> try { <nl> / / Clear any local cache <nl> nativeStrings . clear ( ) ; <nl> <nl> - if ( this instanceof ByValue ) { <nl> - / / ByValue always uses own memory <nl> + if ( this instanceof ByValue & & ! force ) { <nl> + / / ByValue parameters always use dedicated memory , so only <nl> + / / copy the contents of the original <nl> byte [ ] buf = new byte [ size ( ) ] ; <nl> m . read ( 0 , buf , 0 , buf . length ) ; <nl> this . memory . write ( 0 , buf , 0 , buf . length ) ; <nl> diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java <nl> index fedaea1 . . 0699a66 100644 <nl> - - - a / test / com / sun / jna / StructureTest . java <nl> + + + b / test / com / sun / jna / StructureTest . java <nl> @ @ - 343 , 6 + 343 , 10 @ @ public class StructureTest extends TestCase { <nl> <nl> / / must be publicly accessible in order to create array elements <nl> public static class PublicTestStructure extends Structure { <nl> + public static class ByValue extends PublicTestStructure implements Structure . ByValue { <nl> + public ByValue ( ) { } <nl> + public ByValue ( Pointer p ) { super ( p ) ; } <nl> + } <nl> public static class ByReference extends PublicTestStructure implements Structure . ByReference { <nl> public ByReference ( ) { } <nl> public ByReference ( Pointer p ) { super ( p ) ; } <nl> @ @ - 388 , 6 + 392 , 35 @ @ public class StructureTest extends TestCase { <nl> s . s2 . getPointer ( ) ) ; <nl> } <nl> <nl> + public void testStructureByValueField ( ) { <nl> + class TestStructure extends Structure { <nl> + public PublicTestStructure . ByValue s1 , s2 ; <nl> + public int after ; <nl> + protected List getFieldOrder ( ) { <nl> + return Arrays . asList ( new String [ ] { " s1 " , " s2 " , " after " } ) ; <nl> + } <nl> + } <nl> + TestStructure s = new TestStructure ( ) ; <nl> + TestStructure s2 = new TestStructure ( ) ; <nl> + assertNotNull ( " Inner structure should be initialized " , s . s1 ) ; <nl> + assertNotNull ( " Inner structure should be initialized ( cached ) " , s2 . s1 ) ; <nl> + assertEquals ( " Wrong aggregate size " , <nl> + s . s1 . size ( ) + s . s2 . size ( ) + 4 , s . size ( ) ) ; <nl> + s . write ( ) ; <nl> + assertEquals ( " Wrong memory for structure field 1 after write " , <nl> + s . getPointer ( ) , s . s1 . getPointer ( ) ) ; <nl> + assertEquals ( " Wrong memory for structure field 2 after write " , <nl> + s . getPointer ( ) . share ( s . s1 . size ( ) ) , <nl> + s . s2 . getPointer ( ) ) ; <nl> + <nl> + s . read ( ) ; <nl> + assertEquals ( " Wrong memory for structure field 1 after read " , <nl> + s . getPointer ( ) , s . s1 . getPointer ( ) ) ; <nl> + assertEquals ( " Wrong memory for structure field 2 after read " , <nl> + s . getPointer ( ) . share ( s . s1 . size ( ) ) , <nl> + s . s2 . getPointer ( ) ) ; <nl> + } <nl> + <nl> static class TestUnion extends Union { <nl> public int u _ int ; <nl> public float u _ float ;
NEAREST DIFF (one line): diff - - git a / jnalib / TODO b / jnalib / TODO <nl> index 6aed9ef . . 5fd53b8 100644 <nl> - - - a / jnalib / TODO <nl> + + + b / jnalib / TODO <nl> @ @ - 21 , 6 + 21 , 11 @ @ <nl> <nl> # TODO <nl> <nl> + * Make a separate jar file for all OS - specific headers <nl> + * Maybe make interfaces per - header file ( winbase , winnt , stdlib , etc ) , <nl> + aggregated per - library ( interface CLibrary extends stdlib , stdio , etc ) <nl> + ( how useful ? ) <nl> + <nl> * review / use direct Buffer in more places if it makes sense <nl> * support annotations of parameters and return values w / o breaking <nl> 1 . 4 compatibility , e . g . <nl> @ @ - 37 , 6 + 42 , 7 @ @ <nl> * standard types for various platforms : posix / types . h , w32 ( DWORD , HANDLE ) <nl> * StringBuffer / StringBuilder as mutable char * / wchar _ t * argument <nl> NOTE : byte [ ] / char [ ] is probably better ; it ' s trivial to convert to String <nl> + and native code can ' t change the size anyway <nl> * flag string ( / wstring ) - returning methods which need to free their result <nl> to avoid leaking memory whan auto - creating strings from the result <nl> ( since normally we don ' t take explicit ownership of any returned pointers ) <nl> @ @ - 48 , 8 + 54 , 7 @ @ <nl> Structure or some other type . Then memory will free itself when no longer <nl> referenced . <nl> * provide library load / unload hooks ( Runnables in options ? ) . Examples : <nl> - o GetLastError in kernel32 ( note : would need to initialize kernel32 from any <nl> - other w32 api dll as well ) <nl> + o GetLastError ( no longer required ) <nl> o WSAInit ? <nl> * if method has " GetLastErrorException / ErrnoException " in its signature , use <nl> result codes + GetLastError / errno / errstr to auto - generate <nl> diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c <nl> index d71d167 . . 059f7dd 100644 <nl> - - - a / jnalib / native / dispatch . c <nl> + + + b / jnalib / native / dispatch . c <nl> @ @ - 31 , 11 + 31 , 16 @ @ <nl> # define FREE _ LIBRARY ( handle ) FreeLibrary ( handle ) <nl> # define FIND _ ENTRY ( lib , name ) GetProcAddress ( lib , name ) <nl> # define dlerror ( ) " " <nl> + # define GET _ LAST _ ERROR ( ) GetLastError ( ) <nl> + # define SET _ LAST _ ERROR ( CODE ) SetLastError ( CODE ) <nl> # else <nl> # include < dlfcn . h > <nl> + # include < errno . h > <nl> # define LOAD _ LIBRARY ( name ) dlopen ( name , RTLD _ LAZY ) <nl> # define FREE _ LIBRARY ( handle ) dlclose ( handle ) <nl> # define FIND _ ENTRY ( lib , name ) dlsym ( lib , name ) <nl> + # define GET _ LAST _ ERROR ( ) errno <nl> + # define SET _ LAST _ ERROR ( CODE ) ( errno = ( CODE ) ) <nl> # endif <nl> <nl> # include < stdlib . h > <nl> @ @ - 66 , 8 + 71 , 10 @ @ extern " C " <nl> # endif <nl> <nl> static JAWT awt ; <nl> - static int jawt _ initialized ; <nl> + static jboolean jawt _ initialized ; <nl> + static jboolean preserve _ last _ error ; <nl> <nl> + / / TODO : include address fault information in error message <nl> # ifdef PROTECTED _ START <nl> # define ON _ ERROR ( ) throwByName ( env , " java / lang / Error " , " Invalid memory access " ) <nl> # define PSTART ( ) PROTECTED _ START ( ) <nl> @ @ - 95 , 7 + 102 , 6 @ @ static jclass classLong , classPrimitiveLong ; <nl> static jclass classFloat , classPrimitiveFloat ; <nl> static jclass classDouble , classPrimitiveDouble ; <nl> static jclass classString ; <nl> - static jclass classPointer ; <nl> static jclass classBuffer ; <nl> static jclass classByteBuffer ; <nl> static jclass classCharBuffer ; <nl> @ @ - 105 , 11 + 111 , 13 @ @ static jclass classLongBuffer ; <nl> static jclass classFloatBuffer ; <nl> static jclass classDoubleBuffer ; <nl> <nl> + static jclass classPointer ; <nl> + static jclass classNative ; <nl> + <nl> static jmethodID MID _ Class _ getComponentType ; <nl> static jmethodID MID _ String _ getBytes ; <nl> static jmethodID MID _ String _ toCharArray ; <nl> static jmethodID MID _ String _ init _ bytes ; <nl> - static jmethodID MID _ Pointer _ init ; <nl> static jmethodID MID _ Method _ getReturnType ; <nl> static jmethodID MID _ Method _ getParameterTypes ; <nl> static jmethodID MID _ Long _ init ; <nl> @ @ - 135 , 6 + 143 , 9 @ @ static jmethodID MID _ FloatBuffer _ arrayOffset ; <nl> static jmethodID MID _ DoubleBuffer _ array ; <nl> static jmethodID MID _ DoubleBuffer _ arrayOffset ; <nl> <nl> + static jmethodID MID _ Pointer _ init ; <nl> + static jmethodID MID _ Native _ updateLastError ; <nl> + <nl> static jfieldID FID _ Boolean _ value ; <nl> static jfieldID FID _ Byte _ value ; <nl> static jfieldID FID _ Short _ value ; <nl> @ @ - 143 , 6 + 154 , 7 @ @ static jfieldID FID _ Integer _ value ; <nl> static jfieldID FID _ Long _ value ; <nl> static jfieldID FID _ Float _ value ; <nl> static jfieldID FID _ Double _ value ; <nl> + <nl> static jfieldID FID _ Pointer _ peer ; <nl> <nl> / * Forward declarations * / <nl> @ @ - 155 , 6 + 167 , 7 @ @ static void * getBufferArray ( JNIEnv * env , jobject buf , <nl> static char getArrayComponentType ( JNIEnv * , jobject ) ; <nl> static void * getNativeAddress ( JNIEnv * , jobject ) ; <nl> static jboolean init _ jawt ( JNIEnv * ) ; <nl> + static void update _ last _ error ( JNIEnv * , int ) ; <nl> <nl> / * invoke the real native function * / <nl> static void <nl> @ @ - 323 , 6 + 336 , 8 @ @ dispatch ( JNIEnv * env , jobject self , jint callconv , jobjectArray arr , <nl> PSTART ( ) ; <nl> ffi _ call ( & cif , FFI _ FN ( func ) , resP , ffi _ values ) ; <nl> PEND ( ) ; <nl> + if ( preserve _ last _ error ) <nl> + update _ last _ error ( env , GET _ LAST _ ERROR ( ) ) ; <nl> break ; <nl> } <nl> default : <nl> @ @ - 381 , 7 + 396 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokePointer ( JNIEnv * env , jobject self , <nl> jint callconv , jobjectArray arr ) <nl> { <nl> jvalue result ; <nl> - dispatch ( env , self , callconv , arr , & ffi _ type _ pointer , & result . l ) ; <nl> + dispatch ( env , self , callconv , arr , & ffi _ type _ pointer , & result ) ; <nl> return newJavaPointer ( env , result . l ) ; <nl> } <nl> <nl> @ @ - 395 , 7 + 410 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokeDouble ( JNIEnv * env , jobject self , <nl> jint callconv , jobjectArray arr ) <nl> { <nl> jvalue result ; <nl> - dispatch ( env , self , callconv , arr , & ffi _ type _ double , & result . d ) ; <nl> + dispatch ( env , self , callconv , arr , & ffi _ type _ double , & result ) ; <nl> return result . d ; <nl> } <nl> <nl> @ @ - 409 , 7 + 424 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokeFloat ( JNIEnv * env , jobject self , <nl> jint callconv , jobjectArray arr ) <nl> { <nl> jvalue result ; <nl> - dispatch ( env , self , callconv , arr , & ffi _ type _ float , & result . f ) ; <nl> + dispatch ( env , self , callconv , arr , & ffi _ type _ float , & result ) ; <nl> return result . f ; <nl> } <nl> <nl> @ @ - 423 , 7 + 438 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokeInt ( JNIEnv * env , jobject self , <nl> jint callconv , jobjectArray arr ) <nl> { <nl> jvalue result ; <nl> - dispatch ( env , self , callconv , arr , & ffi _ type _ sint32 , & result . i ) ; <nl> + dispatch ( env , self , callconv , arr , & ffi _ type _ sint32 , & result ) ; <nl> / * <nl> * Big endian 64bit machines will put a 32bit return value in the <nl> * upper 4 bytes of the memory area . <nl> @ @ - 445 , 7 + 460 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokeLong ( JNIEnv * env , jobject self , <nl> jint callconv , jobjectArray arr ) <nl> { <nl> jvalue result ; <nl> - dispatch ( env , self , callconv , arr , & ffi _ type _ sint64 , & result . j ) ; <nl> + dispatch ( env , self , callconv , arr , & ffi _ type _ sint64 , & result ) ; <nl> return result . j ; <nl> } <nl> <nl> @ @ - 493 , 8 + 508 , 8 @ @ Java _ com _ sun _ jna _ NativeLibrary _ open ( JNIEnv * env , jclass cls , jstring lib ) { <nl> char * libname = NULL ; <nl> <nl> if ( ( libname = newCString ( env , lib ) ) ! = NULL ) { <nl> - 	 handle = ( void * ) LOAD _ LIBRARY ( libname ) ; <nl> - 	 free ( libname ) ; <nl> + handle = ( void * ) LOAD _ LIBRARY ( libname ) ; <nl> + free ( libname ) ; <nl> } <nl> return ( jlong ) A2L ( handle ) ; <nl> } <nl> @ @ - 1183 , 6 + 1198 , 13 @ @ newWideCString ( JNIEnv * env , jstring str ) <nl> return result ; <nl> } <nl> <nl> + / * * Update the per - thread last error setting . * / <nl> + static void <nl> + update _ last _ error ( JNIEnv * env , int err ) { <nl> + ( * env ) - > CallStaticVoidMethod ( env , classNative , <nl> + MID _ Native _ updateLastError , err ) ; <nl> + } <nl> + <nl> / * Constructs a Java string from a char array ( using the String ( byte [ ] ) <nl> * constructor , which uses default local encoding ) or a short array ( using the <nl> * String ( char [ ] ) ctor , which uses the character values unmodified ) . <nl> @ @ - 1371 , 6 + 1393 , 7 @ @ Java _ com _ sun _ jna _ Native _ wideCharSize ( JNIEnv * env , jclass cls ) { <nl> * / <nl> JNIEXPORT void JNICALL <nl> Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { <nl> + preserve _ last _ error = JNI _ TRUE ; <nl> if ( ! LOAD _ CREF ( env , Pointer , " com / sun / jna / Pointer " ) ) { <nl> throwByName ( env , " java / lang / UnsatisfiedLinkError " , <nl> " Can ' t obtain class com . sun . jna . Pointer " ) ; <nl> @ @ - 1388 , 6 + 1411 , 16 @ @ Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { <nl> throwByName ( env , " java / lang / UnsatisfiedLinkError " , <nl> " Can ' t obtain peer field ID for class com . sun . jna . Pointer " ) ; <nl> } <nl> + else if ( ! ( classNative = ( * env ) - > NewGlobalRef ( env , cls ) ) ) { <nl> + throwByName ( env , " java / lang / UnsatisfiedLinkError " , <nl> + " Can ' t obtain global reference for class com . sun . jna . Native " ) ; <nl> + } <nl> + else if ( ! ( MID _ Native _ updateLastError <nl> + = ( * env ) - > GetStaticMethodID ( env , classNative , <nl> + " updateLastError " , " ( I ) V " ) ) ) { <nl> + throwByName ( env , " java / lang / UnsatisfiedLinkError " , <nl> + " Can ' t obtain updateLastError method for class com . sun . jna . Native " ) ; <nl> + } <nl> } <nl> <nl> JNIEXPORT jlong JNICALL <nl> @ @ - 1498 , 10 + 1531 , 25 @ @ Java _ com _ sun _ jna _ Native _ setProtected ( JNIEnv * env , jclass classp , jboolean protec <nl> JNIEXPORT jboolean JNICALL <nl> Java _ com _ sun _ jna _ Native _ isProtected ( JNIEnv * env , jclass classp ) { <nl> # ifdef HAVE _ PROTECTION <nl> - return protect ? JNI _ TRUE : JNI _ FALSE ; <nl> - # else <nl> - return JNI _ FALSE ; <nl> + if ( protect ) return JNI _ TRUE ; <nl> # endif <nl> + return JNI _ FALSE ; <nl> + } <nl> + <nl> + JNIEXPORT void JNICALL <nl> + Java _ com _ sun _ jna _ Native _ setPreserveLastError ( JNIEnv * env , jclass classp , jboolean preserve ) { <nl> + preserve _ last _ error = preserve ; <nl> + } <nl> + <nl> + JNIEXPORT jboolean JNICALL <nl> + Java _ com _ sun _ jna _ Native _ getPreserveLastError ( JNIEnv * env , jclass classp ) { <nl> + return preserve _ last _ error ; <nl> + } <nl> + <nl> + JNIEXPORT void JNICALL <nl> + Java _ com _ sun _ jna _ Native _ setLastError ( JNIEnv * env , jclass classp , jint code ) { <nl> + SET _ LAST _ ERROR ( code ) ; <nl> + update _ last _ error ( env , code ) ; <nl> } <nl> <nl> static jboolean <nl> diff - - git a / jnalib / release - notes . txt b / jnalib / release - notes . txt <nl> index 9b4bee7 . . 7b446e4 100755 <nl> - - - a / jnalib / release - notes . txt <nl> + + + b / jnalib / release - notes . txt <nl> @ @ - 24 , 6 + 24 , 8 @ @ Bug Fixes <nl> * Update X11 library for 64 - bit use ( wmeissner ) <nl> * Properly map arrays of char * / wchar _ t * under w32 <nl> * Allow Pointer [ ] as a Structure field <nl> + * Fix some misleading Structure error messages <nl> + * Properly preserve / return GetLastError / errno after native calls <nl> <nl> Release 2 . 5 <nl> Features <nl> diff - - git a / jnalib / src / com / sun / jna / CallbackReference . java b / jnalib / src / com / sun / jna / CallbackReference . java <nl> index 6a43345 . . 9a1648d 100644 <nl> - - - a / jnalib / src / com / sun / jna / CallbackReference . java <nl> + + + b / jnalib / src / com / sun / jna / CallbackReference . java <nl> @ @ - 20 , 7 + 20 , 6 @ @ import java . lang . reflect . Proxy ; <nl> import java . util . Iterator ; <nl> import java . util . Map ; <nl> import java . util . WeakHashMap ; <nl> - import com . sun . jna . Library . Handler ; <nl> <nl> / * * Provides a reference to an association between a native callback closure <nl> * and a Java { @ link Callback } closure . <nl> diff - - git a / jnalib / src / com / sun / jna / Function . java b / jnalib / src / com / sun / jna / Function . java <nl> index 4ec5385 . . 9331ca7 100644 <nl> - - - a / jnalib / src / com / sun / jna / Function . java <nl> + + + b / jnalib / src / com / sun / jna / Function . java <nl> @ @ - 15 , 8 + 15 , 6 @ @ import java . lang . reflect . Method ; <nl> import java . util . Collections ; <nl> import java . util . Map ; <nl> <nl> - import com . sun . jna . ptr . ByReference ; <nl> - <nl> / * * <nl> * An abstraction for a native function pointer . An instance of <nl> * < code > Function < / code > repesents a pointer to some native function . <nl> @ @ - 29 , 7 + 27 , 7 @ @ import com . sun . jna . ptr . ByReference ; <nl> * / <nl> public class Function extends Pointer { <nl> / * * Maximum number of arguments supported by a JNA function call . * / <nl> - / / NOTE : this may be different with libffi <nl> + / / TODO : make this match libffi ' s limit ( if any ) <nl> public static final int MAX _ NARGS = 32 ; <nl> <nl> / * * Standard C calling convention . * / <nl> @ @ - 37 , 6 + 35 , 42 @ @ public class Function extends Pointer { <nl> / * * First alternate convention ( currently used only for w32 stdcall ) . * / <nl> public static final int ALT _ CONVENTION = 1 ; <nl> <nl> + / * * <nl> + * Obtain a { @ link Function } representing a native <nl> + * function that follows the standard " C " calling convention . <nl> + * <nl> + * < p > The allocated instance represents a pointer to the named native <nl> + * function from the named library , called with the standard " C " calling <nl> + * convention . <nl> + * <nl> + * @ param libraryName <nl> + * Library in which to find the native function <nl> + * @ param functionName <nl> + * Name of the native function to be linked with <nl> + * / <nl> + public static Function getFunction ( String libraryName , String functionName ) { <nl> + return NativeLibrary . getInstance ( libraryName ) . getFunction ( functionName ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Obtain a { @ link Function } representing a native <nl> + * function that follows a given calling convention . <nl> + * <nl> + * < p > The allocated instance represents a pointer to the named native <nl> + * function from the named library , called with the named calling <nl> + * convention . <nl> + * <nl> + * @ param libraryName <nl> + * Library in which to find the function <nl> + * @ param functionName <nl> + * Name of the native function to be linked with <nl> + * @ param callConvention <nl> + * Call convention used by the native function <nl> + * / <nl> + public static Function getFunction ( String libraryName , String functionName , int callConvention ) { <nl> + return NativeLibrary . getInstance ( libraryName ) . getFunction ( functionName , callConvention ) ; <nl> + } <nl> + <nl> / / Keep a reference to the NativeLibrary so it does not get garbage collected <nl> / / until the function is <nl> private NativeLibrary library ; <nl> @ @ - 44 , 7 + 78 , 7 @ @ public class Function extends Pointer { <nl> private int callingConvention ; <nl> <nl> / * * <nl> - * Create a new { @ link Function } that is linked with a native <nl> + * Create a new { @ link Function } representing a native <nl> * function that follows the standard " C " calling convention . <nl> * <nl> * < p > The allocated instance represents a pointer to the named native <nl> @ @ - 55 , 14 + 89 , 15 @ @ public class Function extends Pointer { <nl> * 	 	 	 Library in which to find the native function <nl> * @ param 	 functionName <nl> * 	 	 	 Name of the native function to be linked with <nl> + * @ deprecated Use { @ link # getFunction ( String , String ) } instead . This <nl> + * version bypasses lookup cacheing done by { @ link NativeLibrary } . <nl> * / <nl> public Function ( String libraryName , String functionName ) { <nl> this ( libraryName , functionName , C _ CONVENTION ) ; <nl> } <nl> - <nl> - <nl> + <nl> / * * <nl> - * Create a new @ { link Function } that is linked with a native <nl> + * Create a new { @ link Function } representing a native <nl> * function that follows a given calling convention . <nl> * <nl> * < p > The allocated instance represents a pointer to the named native <nl> @ @ - 75 , 6 + 110 , 8 @ @ public class Function extends Pointer { <nl> * 	 	 	 Name of the native function to be linked with <nl> * @ param 	 callingConvention <nl> * 	 	 	 Calling convention used by the native function <nl> + * @ deprecated Use { @ link # getFunction ( String , String , int ) } instead . <nl> + * This version bypasses lookup cacheing done by { @ link NativeLibrary } . <nl> * / <nl> public Function ( String libraryName , String functionName , <nl> int callingConvention ) { <nl> @ @ - 188 , 6 + 225 , 7 @ @ public class Function extends Pointer { <nl> nativeType = resultConverter . nativeType ( ) ; <nl> } <nl> } <nl> + <nl> Object result = invoke ( args , nativeType ) ; <nl> <nl> / / Convert the result to a custom value / type if appropriate <nl> @ @ - 216 , 7 + 254 , 7 @ @ public class Function extends Pointer { <nl> / / were modified <nl> ( ( StringArray ) args [ i ] ) . read ( ) ; <nl> } <nl> - else if ( isStructureArray ( arg . getClass ( ) ) ) { <nl> + else if ( Structure [ ] . class . isAssignableFrom ( arg . getClass ( ) ) ) { <nl> Structure [ ] ss = ( Structure [ ] ) arg ; <nl> for ( int si = 0 ; si < ss . length ; si + + ) { <nl> ss [ si ] . read ( ) ; <nl> @ @ - 228 , 7 + 266 , 7 @ @ public class Function extends Pointer { <nl> return result ; <nl> } <nl> <nl> - private Object invoke ( Object [ ] args , Class returnType ) { <nl> + Object invoke ( Object [ ] args , Class returnType ) { <nl> Object result = null ; <nl> if ( returnType = = null | | returnType = = void . class | | returnType = = Void . class ) { <nl> invokeVoid ( callingConvention , args ) ; <nl> @ @ - 332 , 10 + 370 , 6 @ @ public class Function extends Pointer { <nl> struct . write ( ) ; <nl> return struct . getPointer ( ) ; <nl> } <nl> - / / Convert reference class to pointer <nl> - else if ( arg instanceof ByReference ) { <nl> - return ( ( ByReference ) arg ) . getPointer ( ) ; <nl> - } <nl> / / Convert Callback to Pointer <nl> else if ( arg instanceof Callback ) { <nl> return CallbackReference . getFunctionPointer ( ( Callback ) arg ) ; <nl> @ @ - 362 , 7 + 396 , 7 @ @ public class Function extends Pointer { <nl> else if ( WString [ ] . class = = argClass ) { <nl> return new StringArray ( ( WString [ ] ) arg ) ; <nl> } <nl> - else if ( isStructureArray ( argClass ) ) { <nl> + else if ( Structure [ ] . class . isAssignableFrom ( argClass ) ) { <nl> / / Initialize uninitialized arrays of Structure to point <nl> / / to a single block of memory <nl> Structure [ ] ss = ( Structure [ ] ) arg ; <nl> @ @ - 397 , 18 + 431 , 13 @ @ public class Function extends Pointer { <nl> int size = ss [ 0 ] . size ( ) ; <nl> ss [ 0 ] . write ( ) ; <nl> for ( int si = 1 ; si < ss . length ; si + + ) { <nl> - try { <nl> - Pointer p = base . share ( size * si , size ) ; <nl> - if ( ss [ si ] . getPointer ( ) . peer ! = p . peer ) { <nl> - throw new RuntimeException ( ) ; <nl> - } <nl> - ss [ si ] . write ( ) ; <nl> - } <nl> - catch ( RuntimeException e ) { <nl> + Pointer p = base . share ( size * si , size ) ; <nl> + if ( ss [ si ] . getPointer ( ) . peer ! = p . peer ) { <nl> String msg = " Structure array elements must use " <nl> - + " contiguous memory : " + si ; <nl> + + " contiguous memory ( at element index " + si + " ) " ; <nl> throw new IllegalArgumentException ( msg ) ; <nl> } <nl> + ss [ si ] . write ( ) ; <nl> } <nl> return base ; <nl> } <nl> @ @ - 420 , 12 + 449 , 6 @ @ public class Function extends Pointer { <nl> return arg ; <nl> } <nl> <nl> - private boolean isStructureArray ( Class argClass ) { <nl> - return argClass . isArray ( ) <nl> - & & Structure . class . isAssignableFrom ( argClass . getComponentType ( ) ) ; <nl> - } <nl> - <nl> - <nl> private boolean isPrimitiveArray ( Class argClass ) { <nl> return argClass . isArray ( ) <nl> & & argClass . getComponentType ( ) . isPrimitive ( ) ; <nl> diff - - git a / jnalib / src / com / sun / jna / Native . java b / jnalib / src / com / sun / jna / Native . java <nl> index f8b03aa . . b718493 100644 <nl> - - - a / jnalib / src / com / sun / jna / Native . java <nl> + + + b / jnalib / src / com / sun / jna / Native . java <nl> @ @ - 94 , 6 + 94 , 16 @ @ public final class Native { <nl> * if this platform supports protecting memory accesses . <nl> * / <nl> public static native boolean isProtected ( ) ; <nl> + <nl> + / * * Set whether the system last error result is captured after every <nl> + * native invocation . Defaults to < code > true < / code > . <nl> + * / <nl> + public static native void setPreserveLastError ( boolean enable ) ; <nl> + <nl> + / * * Indicates whether the system last error result is preserved <nl> + * after every invocation . <nl> + * / <nl> + public static native boolean getPreserveLastError ( ) ; <nl> <nl> / * * Utility method to get the native window ID for a Java { @ link Window } <nl> * as a < code > long < / code > value . <nl> @ @ - 208 , 8 + 218 , 8 @ @ public final class Native { <nl> * @ param options Map of library options <nl> * / <nl> public static Object loadLibrary ( String name , <nl> - Class interfaceClass , <nl> - Map options ) { <nl> + Class interfaceClass , <nl> + Map options ) { <nl> Library . Handler handler = <nl> new Library . Handler ( name , interfaceClass , options ) ; <nl> ClassLoader loader = interfaceClass . getClassLoader ( ) ; <nl> @ @ - 399 , 4 + 409 , 29 @ @ public final class Native { <nl> <nl> / * * Return the size of a native < code > wchar _ t < / code > . * / <nl> private static native int wideCharSize ( ) ; <nl> + <nl> + private static final ThreadLocal lastError = new ThreadLocal ( ) { <nl> + protected synchronized Object initialValue ( ) { <nl> + return new Integer ( 0 ) ; <nl> + } <nl> + } ; <nl> + <nl> + / * * Retrieve the last error set by the OS . The value is preserved <nl> + * per - thread , but whether the original value is per - thread depends on <nl> + * the underlying OS . The result is undefined If <nl> + * { @ link # getPreserveLastError } is < code > false < / code > . <nl> + * / <nl> + public static int getLastError ( ) { <nl> + return ( ( Integer ) lastError . get ( ) ) . intValue ( ) ; <nl> + } <nl> + <nl> + / * * Set the OS last error code . Whether the setting is per - thread <nl> + * or global depends on the underlying OS . <nl> + * / <nl> + public static native void setLastError ( int code ) ; <nl> + <nl> + / * * Update the last error value ( called from native code ) . * / <nl> + static void updateLastError ( int e ) { <nl> + lastError . set ( new Integer ( e ) ) ; <nl> + } <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / NativeLibrary . java b / jnalib / src / com / sun / jna / NativeLibrary . java <nl> index 7f22749 . . d3e361f 100644 <nl> - - - a / jnalib / src / com / sun / jna / NativeLibrary . java <nl> + + + b / jnalib / src / com / sun / jna / NativeLibrary . java <nl> @ @ - 58 , 6 + 58 , 18 @ @ public class NativeLibrary { <nl> this . libraryName = getLibraryName ( libraryName ) ; <nl> this . libraryPath = libraryPath ; <nl> this . handle = handle ; <nl> + / / Special workaround for w32 kernel32 . GetLastError <nl> + / / Short - circuit the function to use built - in GetLastError access <nl> + if ( Platform . isWindows ( ) & & " kernel32 " . equals ( this . libraryName ) ) { <nl> + synchronized ( functions ) { <nl> + Function f = new Function ( this , " GetLastError " , Function . ALT _ CONVENTION ) { <nl> + Object invoke ( Object [ ] args , Class returnType ) { <nl> + return new Integer ( Native . getLastError ( ) ) ; <nl> + } <nl> + } ; <nl> + functions . put ( " GetLastError " , f ) ; <nl> + } <nl> + } <nl> } <nl> <nl> private static NativeLibrary loadLibrary ( String libraryName ) { <nl> diff - - git a / jnalib / src / com / sun / jna / Structure . java b / jnalib / src / com / sun / jna / Structure . java <nl> index 8d7ff9e . . 1d6d94a 100644 <nl> - - - a / jnalib / src / com / sun / jna / Structure . java <nl> + + + b / jnalib / src / com / sun / jna / Structure . java <nl> @ @ - 13 , 7 + 13 , 6 @ @ package com . sun . jna ; <nl> import java . lang . reflect . Array ; <nl> import java . lang . reflect . Field ; <nl> import java . lang . reflect . Modifier ; <nl> - import java . util . Arrays ; <nl> import java . util . HashMap ; <nl> import java . util . Iterator ; <nl> import java . util . LinkedHashMap ; <nl> @ @ - 317 , 7 + 316 , 7 @ @ public abstract class Structure { <nl> try { <nl> Object o = structField . field . get ( this ) ; <nl> if ( o = = null ) { <nl> - throw new IllegalStateException ( " Structure array field not initialized " ) ; <nl> + throw new IllegalStateException ( " Array field in Structure not initialized " ) ; <nl> } <nl> length = Array . getLength ( o ) ; <nl> } <nl> @ @ - 369 , 9 + 368 , 9 @ @ public abstract class Structure { <nl> structField . field . set ( this , result ) ; <nl> } <nl> catch ( Exception e ) { <nl> - throw new RuntimeException ( " Exception setting field \ " " <nl> - + structField . name + " \ " to " + result <nl> - + " : " + e , e ) ; <nl> + throw new Error ( " Exception setting field \ " " <nl> + + structField . name + " \ " to " + result <nl> + + " : " + e , e ) ; <nl> } <nl> } <nl> <nl> @ @ - 413 , 8 + 412 , 8 @ @ public abstract class Structure { <nl> value = structField . field . get ( this ) ; <nl> } <nl> catch ( Exception e ) { <nl> - throw new RuntimeException ( " Exception reading field \ " " <nl> - + structField . name + " \ " " , e ) ; <nl> + throw new Error ( " Exception reading field \ " " <nl> + + structField . name + " \ " " , e ) ; <nl> } <nl> / / Determine the type of the field <nl> Class nativeType = structField . type ; <nl> diff - - git a / jnalib / src / com / sun / jna / examples / WindowUtils . java b / jnalib / src / com / sun / jna / examples / WindowUtils . java <nl> index 63413cb . . 205f885 100644 <nl> - - - a / jnalib / src / com / sun / jna / examples / WindowUtils . java <nl> + + + b / jnalib / src / com / sun / jna / examples / WindowUtils . java <nl> @ @ - 984 , 7 + 984 , 7 @ @ public class WindowUtils { <nl> false ) , <nl> X11 . XA _ CARDINAL , 32 , <nl> X11 . PropModeReplace , <nl> - patom . getPointer ( ) , 1 ) ; <nl> + patom , 1 ) ; <nl> } <nl> } <nl> finally { <nl> diff - - git a / jnalib / src / com / sun / jna / examples / unix / X11 . java b / jnalib / src / com / sun / jna / examples / unix / X11 . java <nl> index 8097c7f . . 793cbd9 100644 <nl> - - - a / jnalib / src / com / sun / jna / examples / unix / X11 . java <nl> + + + b / jnalib / src / com / sun / jna / examples / unix / X11 . java <nl> @ @ - 15 , 8 + 15 , 8 @ @ package com . sun . jna . examples . unix ; <nl> import com . sun . jna . FromNativeContext ; <nl> import com . sun . jna . Library ; <nl> import com . sun . jna . Native ; <nl> - import com . sun . jna . NativeMapped ; <nl> import com . sun . jna . NativeLong ; <nl> + import com . sun . jna . NativeMapped ; <nl> import com . sun . jna . Pointer ; <nl> import com . sun . jna . PointerType ; <nl> import com . sun . jna . Structure ; <nl> @ @ - 29 , 11 + 29 , 17 @ @ import com . sun . jna . ptr . PointerByReference ; <nl> public interface X11 extends Library { <nl> <nl> public static class XID implements NativeMapped { <nl> + public static final XID None = null ; <nl> private Integer id = new Integer ( 0 ) ; <nl> - public XID ( ) { this ( None ) ; } <nl> + public XID ( ) { this ( X11 . None ) ; } <nl> public XID ( Integer id ) { this . id = id ; } <nl> public XID ( int id ) { this ( new Integer ( id ) ) ; } <nl> + protected boolean isNone ( Object o ) { <nl> + return ( ( Integer ) o ) . intValue ( ) = = X11 . None ; <nl> + } <nl> public Object fromNative ( Object nativeValue , FromNativeContext context ) { <nl> + if ( isNone ( nativeValue ) ) <nl> + return None ; <nl> return new XID ( ( Integer ) nativeValue ) ; <nl> } <nl> public Class nativeType ( ) { <nl> @ @ - 44 , 12 + 50 , 16 @ @ public interface X11 extends Library { <nl> } <nl> } <nl> public static class Atom extends XID { <nl> + public static final Atom None = null ; <nl> public Atom ( ) { } <nl> public Atom ( Integer id ) { super ( id ) ; } <nl> public Atom ( int id ) { super ( id ) ; } <nl> + / * * Return constants for predefined < code > Atom < / code > values . * / <nl> public Object fromNative ( Object nativeValue , FromNativeContext context ) { <nl> int value = ( ( Integer ) nativeValue ) . intValue ( ) ; <nl> switch ( value ) { <nl> + case 0 : <nl> + return None ; <nl> case 1 : <nl> return XA _ PRIMARY ; <nl> case 2 : <nl> @ @ - 70 , 56 + 80 , 68 @ @ public interface X11 extends Library { <nl> public static class AtomByReference extends ByReference { <nl> public AtomByReference ( ) { super ( 4 ) ; } <nl> public Atom getValue ( ) { <nl> - return ( Atom ) new Atom ( ) . fromNative ( new Integer ( getPointer ( ) . getInt ( 0 ) ) , null ) ; <nl> + return ( Atom ) new Atom ( ) . fromNative ( new Integer ( getInt ( 0 ) ) , null ) ; <nl> } <nl> } <nl> public static class Colormap extends XID { <nl> + public static final Colormap None = null ; <nl> public Colormap ( ) { } <nl> public Colormap ( Integer id ) { super ( id ) ; } <nl> public Colormap ( int id ) { super ( id ) ; } <nl> public Object fromNative ( Object nativeValue , FromNativeContext context ) { <nl> + if ( isNone ( nativeValue ) ) <nl> + return None ; <nl> return new Colormap ( ( Integer ) nativeValue ) ; <nl> } <nl> } <nl> public static class Cursor extends XID { <nl> + public static final Cursor None = null ; <nl> public Cursor ( ) { } <nl> public Cursor ( Integer id ) { super ( id ) ; } <nl> public Cursor ( int id ) { super ( id ) ; } <nl> public Object fromNative ( Object nativeValue , FromNativeContext context ) { <nl> + if ( isNone ( nativeValue ) ) <nl> + return None ; <nl> return new Cursor ( ( Integer ) nativeValue ) ; <nl> } <nl> } <nl> public static class Drawable extends XID { <nl> - public static final Drawable None = new Drawable ( X11 . None ) ; <nl> + public static final Drawable None = null ; <nl> public Drawable ( ) { } <nl> public Drawable ( Integer id ) { super ( id ) ; } <nl> public Drawable ( int id ) { super ( id ) ; } <nl> public Object fromNative ( Object nativeValue , FromNativeContext context ) { <nl> + if ( isNone ( nativeValue ) ) <nl> + return None ; <nl> return new Drawable ( ( Integer ) nativeValue ) ; <nl> } <nl> } <nl> public static class Window extends Drawable { <nl> - public static final Window None = new Window ( X11 . None ) ; <nl> + public static final Window None = null ; <nl> public Window ( ) { } <nl> public Window ( Integer id ) { super ( id ) ; } <nl> public Window ( int id ) { super ( id ) ; } <nl> public Object fromNative ( Object nativeValue , FromNativeContext context ) { <nl> + if ( isNone ( nativeValue ) ) <nl> + return None ; <nl> return new Window ( ( Integer ) nativeValue ) ; <nl> } <nl> } <nl> public static class WindowByReference extends ByReference { <nl> public WindowByReference ( ) { super ( 4 ) ; } <nl> public Window getValue ( ) { <nl> - int value = getPointer ( ) . getInt ( 0 ) ; <nl> + int value = getInt ( 0 ) ; <nl> return value = = X11 . None ? Window . None : new Window ( value ) ; <nl> } <nl> } <nl> public static class Pixmap extends Drawable { <nl> - public static final Pixmap None = new Pixmap ( X11 . None ) ; <nl> + public static final Pixmap None = null ; <nl> public Pixmap ( ) { } <nl> public Pixmap ( Integer id ) { super ( id ) ; } <nl> public Pixmap ( int id ) { super ( id ) ; } <nl> public Object fromNative ( Object nativeValue , FromNativeContext context ) { <nl> + if ( isNone ( nativeValue ) ) <nl> + return None ; <nl> return new Pixmap ( ( Integer ) nativeValue ) ; <nl> } <nl> } <nl> @ @ - 334 , 12 + 356 , 14 @ @ public interface X11 extends Library { <nl> int AllocNone = 0 ; <nl> int AllocAll = 1 ; <nl> <nl> - Atom XA _ PRIMARY = new Atom ( 0 ) ; <nl> - Atom XA _ SECONDARY = new Atom ( 1 ) ; <nl> - Atom XA _ ARC = new Atom ( 2 ) ; <nl> + Atom XA _ PRIMARY = new Atom ( 1 ) ; <nl> + Atom XA _ SECONDARY = new Atom ( 2 ) ; <nl> + Atom XA _ ARC = new Atom ( 3 ) ; <nl> Atom XA _ ATOM = new Atom ( 4 ) ; <nl> Atom XA _ BITMAP = new Atom ( 5 ) ; <nl> Atom XA _ CARDINAL = new Atom ( 6 ) ; <nl> + Atom XA _ COLORMAP = new Atom ( 7 ) ; <nl> + Atom XA _ CURSOR = new Atom ( 8 ) ; <nl> <nl> int PropModeReplace = 0 ; <nl> int PropModePrepend = 1 ; <nl> diff - - git a / jnalib / src / com / sun / jna / examples / win32 / Kernel32 . java b / jnalib / src / com / sun / jna / examples / win32 / Kernel32 . java <nl> index d6fee2b . . 590af27 100644 <nl> - - - a / jnalib / src / com / sun / jna / examples / win32 / Kernel32 . java <nl> + + + b / jnalib / src / com / sun / jna / examples / win32 / Kernel32 . java <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * / <nl> package com . sun . jna . examples . win32 ; <nl> <nl> + import java . nio . Buffer ; <nl> import com . sun . jna . Native ; <nl> import com . sun . jna . Pointer ; <nl> import com . sun . jna . Structure ; <nl> @ @ - 20 , 7 + 21 , 7 @ @ import com . sun . jna . ptr . PointerByReference ; <nl> <nl> / * * Definition ( incomplete ) of < code > kernel32 . dll < / code > . * / <nl> public interface Kernel32 extends W32API { <nl> - <nl> + <nl> Kernel32 INSTANCE = ( Kernel32 ) <nl> Native . loadLibrary ( " kernel32 " , Kernel32 . class , DEFAULT _ OPTIONS ) ; <nl> <nl> @ @ - 49 , 6 + 50 , 9 @ @ public interface Kernel32 extends W32API { <nl> int FormatMessage ( int dwFlags , Pointer lpSource , int dwMessageId , <nl> int dwLanguageId , PointerByReference lpBuffer , <nl> int nSize , Pointer va _ list ) ; <nl> + int FormatMessage ( int dwFlags , Pointer lpSource , int dwMessageId , <nl> + int dwLanguageId , Buffer lpBuffer , <nl> + int nSize , Pointer va _ list ) ; <nl> <nl> int FILE _ LIST _ DIRECTORY = 0x00000001 ; <nl> <nl> diff - - git a / jnalib / src / com / sun / jna / ptr / ByReference . java b / jnalib / src / com / sun / jna / ptr / ByReference . java <nl> index b9ceb56 . . 26fae77 100644 <nl> - - - a / jnalib / src / com / sun / jna / ptr / ByReference . java <nl> + + + b / jnalib / src / com / sun / jna / ptr / ByReference . java <nl> @ @ - 15 , 16 + 15 , 22 @ @ package com . sun . jna . ptr ; <nl> import com . sun . jna . Memory ; <nl> import com . sun . jna . Pointer ; <nl> <nl> - / * * Provides generic " pointer to type " functionality . * / <nl> - public abstract class ByReference { <nl> - <nl> - private Pointer pointer ; <nl> + / * * Provides generic " pointer to type " functionality , often used in C <nl> + * code to return values to the caller in addition to a function result . <nl> + * < p > <nl> + * Derived classes should define < code > setValue ( & lt ; T & gt ; ) < / code > <nl> + * and < code > & lt ; T & gt ; getValue ( ) < / code > methods which write to / read from <nl> + * memory . <nl> + * / <nl> + public abstract class ByReference extends Memory { <nl> <nl> protected ByReference ( int dataSize ) { <nl> - pointer = new Memory ( dataSize ) ; <nl> + super ( dataSize ) ; <nl> } <nl> <nl> + / * * @ deprecated This is equivalent to the object itself . * / <nl> public Pointer getPointer ( ) { <nl> - return pointer ; <nl> + return this ; <nl> } <nl> + <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / ptr / ByteByReference . java b / jnalib / src / com / sun / jna / ptr / ByteByReference . java <nl> index 3307e46 . . fc0dec6 100644 <nl> - - - a / jnalib / src / com / sun / jna / ptr / ByteByReference . java <nl> + + + b / jnalib / src / com / sun / jna / ptr / ByteByReference . java <nl> @ @ - 24 , 11 + 24 , 11 @ @ public class ByteByReference extends ByReference { <nl> } <nl> <nl> public void setValue ( byte value ) { <nl> - getPointer ( ) . setByte ( 0 , value ) ; <nl> + setByte ( 0 , value ) ; <nl> } <nl> <nl> public byte getValue ( ) { <nl> - return getPointer ( ) . getByte ( 0 ) ; <nl> + return getByte ( 0 ) ; <nl> } <nl> <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / ptr / DoubleByReference . java b / jnalib / src / com / sun / jna / ptr / DoubleByReference . java <nl> index 88c1cc6 . . 51ec904 100644 <nl> - - - a / jnalib / src / com / sun / jna / ptr / DoubleByReference . java <nl> + + + b / jnalib / src / com / sun / jna / ptr / DoubleByReference . java <nl> @ @ - 23 , 11 + 23 , 11 @ @ public class DoubleByReference extends ByReference { <nl> } <nl> <nl> public void setValue ( double value ) { <nl> - getPointer ( ) . setDouble ( 0 , value ) ; <nl> + setDouble ( 0 , value ) ; <nl> } <nl> <nl> public double getValue ( ) { <nl> - return getPointer ( ) . getDouble ( 0 ) ; <nl> + return getDouble ( 0 ) ; <nl> } <nl> <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / ptr / FloatByReference . java b / jnalib / src / com / sun / jna / ptr / FloatByReference . java <nl> index 8675a98 . . ea932bf 100644 <nl> - - - a / jnalib / src / com / sun / jna / ptr / FloatByReference . java <nl> + + + b / jnalib / src / com / sun / jna / ptr / FloatByReference . java <nl> @ @ - 23 , 11 + 23 , 11 @ @ public class FloatByReference extends ByReference { <nl> } <nl> <nl> public void setValue ( float value ) { <nl> - getPointer ( ) . setFloat ( 0 , value ) ; <nl> + setFloat ( 0 , value ) ; <nl> } <nl> <nl> public float getValue ( ) { <nl> - return getPointer ( ) . getFloat ( 0 ) ; <nl> + return getFloat ( 0 ) ; <nl> } <nl> <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / ptr / IntByReference . java b / jnalib / src / com / sun / jna / ptr / IntByReference . java <nl> index a330001 . . f04fd26 100644 <nl> - - - a / jnalib / src / com / sun / jna / ptr / IntByReference . java <nl> + + + b / jnalib / src / com / sun / jna / ptr / IntByReference . java <nl> @ @ - 24 , 10 + 24 , 10 @ @ public class IntByReference extends ByReference { <nl> } <nl> <nl> public void setValue ( int value ) { <nl> - getPointer ( ) . setInt ( 0 , value ) ; <nl> + setInt ( 0 , value ) ; <nl> } <nl> <nl> public int getValue ( ) { <nl> - return getPointer ( ) . getInt ( 0 ) ; <nl> + return getInt ( 0 ) ; <nl> } <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / ptr / LongByReference . java b / jnalib / src / com / sun / jna / ptr / LongByReference . java <nl> index 132fe88 . . c67d9ac 100644 <nl> - - - a / jnalib / src / com / sun / jna / ptr / LongByReference . java <nl> + + + b / jnalib / src / com / sun / jna / ptr / LongByReference . java <nl> @ @ - 23 , 10 + 23 , 10 @ @ public class LongByReference extends ByReference { <nl> } <nl> <nl> public void setValue ( long value ) { <nl> - getPointer ( ) . setLong ( 0 , value ) ; <nl> + setLong ( 0 , value ) ; <nl> } <nl> <nl> public long getValue ( ) { <nl> - return getPointer ( ) . getLong ( 0 ) ; <nl> + return getLong ( 0 ) ; <nl> } <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / ptr / NativeLongByReference . java b / jnalib / src / com / sun / jna / ptr / NativeLongByReference . java <nl> index f27dfdb . . 0858c06 100644 <nl> - - - a / jnalib / src / com / sun / jna / ptr / NativeLongByReference . java <nl> + + + b / jnalib / src / com / sun / jna / ptr / NativeLongByReference . java <nl> @ @ - 25 , 10 + 25 , 10 @ @ public class NativeLongByReference extends ByReference { <nl> } <nl> <nl> public void setValue ( NativeLong value ) { <nl> - getPointer ( ) . setNativeLong ( 0 , value ) ; <nl> + setNativeLong ( 0 , value ) ; <nl> } <nl> <nl> public NativeLong getValue ( ) { <nl> - return getPointer ( ) . getNativeLong ( 0 ) ; <nl> + return getNativeLong ( 0 ) ; <nl> } <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / ptr / PointerByReference . java b / jnalib / src / com / sun / jna / ptr / PointerByReference . java <nl> index 86b4b7e . . 1484c3e 100644 <nl> - - - a / jnalib / src / com / sun / jna / ptr / PointerByReference . java <nl> + + + b / jnalib / src / com / sun / jna / ptr / PointerByReference . java <nl> @ @ - 30 , 10 + 30 , 10 @ @ public class PointerByReference extends ByReference { <nl> } <nl> <nl> public void setValue ( Pointer value ) { <nl> - getPointer ( ) . setPointer ( 0 , value ) ; <nl> + setPointer ( 0 , value ) ; <nl> } <nl> <nl> public Pointer getValue ( ) { <nl> - return getPointer ( ) . getPointer ( 0 ) ; <nl> + return getPointer ( 0 ) ; <nl> } <nl> } <nl> diff - - git a / jnalib / src / com / sun / jna / ptr / ShortByReference . java b / jnalib / src / com / sun / jna / ptr / ShortByReference . java <nl> index c3ed01c . . 43f5456 100644 <nl> - - - a / jnalib / src / com / sun / jna / ptr / ShortByReference . java <nl> + + + b / jnalib / src / com / sun / jna / ptr / ShortByReference . java <nl> @ @ - 24 , 11 + 24 , 11 @ @ public class ShortByReference extends ByReference { <nl> } <nl> <nl> public void setValue ( short value ) { <nl> - getPointer ( ) . setShort ( 0 , value ) ; <nl> + setShort ( 0 , value ) ; <nl> } <nl> <nl> public short getValue ( ) { <nl> - return getPointer ( ) . getShort ( 0 ) ; <nl> + return getShort ( 0 ) ; <nl> } <nl> <nl> } <nl> diff - - git a / jnalib / test / com / sun / jna / examples / win32 / Kernel32Test . java b / jnalib / test / com / sun / jna / examples / win32 / Kernel32Test . java <nl> index 1446ab1 . . 708f6f8 100644 <nl> - - - a / jnalib / test / com / sun / jna / examples / win32 / Kernel32Test . java <nl> + + + b / jnalib / test / com / sun / jna / examples / win32 / Kernel32Test . java <nl> @ @ - 14 , 9 + 14 , 6 @ @ package com . sun . jna . examples . win32 ; <nl> <nl> import java . util . Calendar ; <nl> import java . util . TimeZone ; <nl> - import com . sun . jna . Native ; <nl> - import com . sun . jna . Pointer ; <nl> - import com . sun . jna . win32 . StdCallLibrary ; <nl> import junit . framework . TestCase ; <nl> <nl> public class Kernel32Test extends TestCase { <nl> @ @ - 34 , 33 + 31 , 26 @ @ public class Kernel32Test extends TestCase { <nl> assertEquals ( " Year not properly set " , <nl> cal . get ( Calendar . YEAR ) , time . wYear ) ; <nl> } <nl> - <nl> + <nl> public void testGetLastError ( ) { <nl> Kernel32 kernel = Kernel32 . INSTANCE ; <nl> - kernel . GetLastError ( ) ; <nl> + int ERRCODE = 8 ; <nl> + <nl> + kernel . SetLastError ( ERRCODE ) ; <nl> + int code = kernel . GetLastError ( ) ; <nl> + assertEquals ( " Wrong GetLastError value " , ERRCODE , code ) ; <nl> + <nl> if ( kernel . GetProcessId ( null ) = = 0 ) { <nl> final int INVALID _ HANDLE = 6 ; <nl> - int code = kernel . GetLastError ( ) ; <nl> + code = kernel . GetLastError ( ) ; <nl> assertEquals ( " GetLastError failed " , INVALID _ HANDLE , code ) ; <nl> - int ERRCODE = 8 ; <nl> - kernel . SetLastError ( ERRCODE ) ; <nl> - code = kernel . GetLastError ( ) ; <nl> - assertEquals ( " Wrong GetLastError value " , ERRCODE , code ) ; <nl> } <nl> else { <nl> fail ( " GetProcessId ( NULL ) should fail " ) ; <nl> } <nl> - <nl> - / * <nl> - final int GENERIC _ EXECUTE = 0x20000000 ; <nl> - Pointer h = AdvAPI32 . INSTANCE . OpenSCManager ( " localhost " , null , GENERIC _ EXECUTE ) ; <nl> - int code = kernel . GetLastError ( ) ; <nl> - int EXPECTED = 1722 ; <nl> - if ( h = = null ) { <nl> - assertEquals ( " Wrong error " , EXPECTED , code ) ; <nl> - } <nl> - else { <nl> - fail ( " Unexpected non - null result " ) ; <nl> - } * / <nl> + } <nl> + <nl> + public static void main ( String [ ] args ) { <nl> + junit . textui . TestRunner . run ( Kernel32Test . class ) ; <nl> } <nl> }

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 979ef79 . . af951b5 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 1 , 12 + 1 , 19 @ @ 
 + NOTE : as of JNA 4 . 0 , JNA is now dual - licensed under LGPL and ASL ( see LICENSE ) . 
 + 
 + NOTE : JNI native support is typically incompatible between minor versions , and almost always incompatible between major versions . 
 + 
 Next Release ( 4 . 0 . 1 ) 
 = = = = = = = = = = = = = = = = = = = = 
 
 - Release 4 . 0 
 - = = = = = = = = = = = 
 + Features 
 + - - - - - - - - 
 
 - NOTE : as of JNA 4 . 0 , JNA is now dual - licensed under LGPL and ASL ( see LICENSE ) . 
 + Bug Fixes 
 + - - - - - - - - - 
 + * Fix inconsistent behavior on ` Structure . ByValue ` fields within a ` Structure ` - [ @ twall ] ( https : / / github . com / twall ) 
 
 - NOTE : JNI native support is typically incompatible between minor versions , and almost always incompatible between major versions . 
 + Release 4 . 0 
 + = = = = = = = = = = = 
 
 Features 
 - - - - - - - - 
 diff - - git a / src / com / sun / jna / Pointer . java b / src / com / sun / jna / Pointer . java 
 index 9f554cb . . 7f3f3d8 100644 
 - - - a / src / com / sun / jna / Pointer . java 
 + + + b / src / com / sun / jna / Pointer . java 
 @ @ - 369 , 7 + 369 , 7 @ @ public class Pointer { 
 s = Structure . updateStructureByReference ( type , s , getPointer ( offset ) ) ; 
 } 
 else { 
 - s . useMemory ( this , ( int ) offset ) ; 
 + s . useMemory ( this , ( int ) offset , true ) ; 
 s . read ( ) ; 
 } 
 result = s ; 
 @ @ - 522 , 7 + 522 , 7 @ @ public class Pointer { 
 sarray [ 0 ] = first ; 
 } 
 else { 
 - first . useMemory ( this , ( int ) offset ) ; 
 + first . useMemory ( this , ( int ) offset , true ) ; 
 first . read ( ) ; 
 } 
 Structure [ ] tmp = first . toArray ( sarray . length ) ; 
 @ @ - 532 , 7 + 532 , 7 @ @ public class Pointer { 
 sarray [ i ] = tmp [ i ] ; 
 } 
 else { 
 - sarray [ i ] . useMemory ( this , ( int ) ( offset + i * sarray [ i ] . size ( ) ) ) ; 
 + sarray [ i ] . useMemory ( this , ( int ) ( offset + i * sarray [ i ] . size ( ) ) , true ) ; 
 sarray [ i ] . read ( ) ; 
 } 
 } 
 @ @ - 952 , 7 + 952 , 7 @ @ v * @ param wide whether to convert from a wide or standard C string 
 } 
 } 
 else { 
 - s . useMemory ( this , ( int ) offset ) ; 
 + s . useMemory ( this , ( int ) offset , true ) ; 
 s . write ( ) ; 
 } 
 } 
 @ @ - 1033 , 7 + 1033 , 7 @ @ v * @ param wide whether to convert from a wide or standard C string 
 sbuf [ 0 ] = first ; 
 } 
 else { 
 - first . useMemory ( this , ( int ) offset ) ; 
 + first . useMemory ( this , ( int ) offset , true ) ; 
 } 
 first . write ( ) ; 
 Structure [ ] tmp = first . toArray ( sbuf . length ) ; 
 @ @ - 1042 , 7 + 1042 , 7 @ @ v * @ param wide whether to convert from a wide or standard C string 
 sbuf [ i ] = tmp [ i ] ; 
 } 
 else { 
 - sbuf [ i ] . useMemory ( this , ( int ) ( offset + i * sbuf [ i ] . size ( ) ) ) ; 
 + sbuf [ i ] . useMemory ( this , ( int ) ( offset + i * sbuf [ i ] . size ( ) ) , true ) ; 
 } 
 sbuf [ i ] . write ( ) ; 
 } 
 diff - - git a / src / com / sun / jna / Structure . java b / src / com / sun / jna / Structure . java 
 index b1bf3f2 . . c7c4f17 100644 
 - - - a / src / com / sun / jna / Structure . java 
 + + + b / src / com / sun / jna / Structure . java 
 @ @ - 178 , 7 + 178 , 7 @ @ public abstract class Structure { 
 initializeTypeMapper ( mapper ) ; 
 validateFields ( ) ; 
 if ( p ! = null ) { 
 - useMemory ( p ) ; 
 + useMemory ( p , 0 , true ) ; 
 } 
 else { 
 allocateMemory ( CALCULATE _ SIZE ) ; 
 @ @ - 279 , 12 + 279 , 27 @ @ public abstract class Structure { 
 * thus does not own its own memory allocation . 
 * / 
 protected void useMemory ( Pointer m , int offset ) { 
 + useMemory ( m , offset , false ) ; 
 + } 
 + 
 + / * * Set the memory used by this structure . This method is used to 
 + * indicate the given structure is based on natively - allocated data , 
 + * nested within another , or otherwise overlaid on existing memory and 
 + * thus does not own its own memory allocation . 
 + * @ param m Native pointer 
 + * @ param offset offset from pointer to use 
 + * @ param force ByValue structures normally ignore requests to use a 
 + * different memory offset ; this input is set < code > true < / code > when 
 + * setting a ByValue struct that is nested within another struct . 
 + * / 
 + void useMemory ( Pointer m , int offset , boolean force ) { 
 try { 
 / / Clear any local cache 
 nativeStrings . clear ( ) ; 
 
 - if ( this instanceof ByValue ) { 
 - / / ByValue always uses own memory 
 + if ( this instanceof ByValue & & ! force ) { 
 + / / ByValue parameters always use dedicated memory , so only 
 + / / copy the contents of the original 
 byte [ ] buf = new byte [ size ( ) ] ; 
 m . read ( 0 , buf , 0 , buf . length ) ; 
 this . memory . write ( 0 , buf , 0 , buf . length ) ; 
 diff - - git a / test / com / sun / jna / StructureTest . java b / test / com / sun / jna / StructureTest . java 
 index fedaea1 . . 0699a66 100644 
 - - - a / test / com / sun / jna / StructureTest . java 
 + + + b / test / com / sun / jna / StructureTest . java 
 @ @ - 343 , 6 + 343 , 10 @ @ public class StructureTest extends TestCase { 
 
 / / must be publicly accessible in order to create array elements 
 public static class PublicTestStructure extends Structure { 
 + public static class ByValue extends PublicTestStructure implements Structure . ByValue { 
 + public ByValue ( ) { } 
 + public ByValue ( Pointer p ) { super ( p ) ; } 
 + } 
 public static class ByReference extends PublicTestStructure implements Structure . ByReference { 
 public ByReference ( ) { } 
 public ByReference ( Pointer p ) { super ( p ) ; } 
 @ @ - 388 , 6 + 392 , 35 @ @ public class StructureTest extends TestCase { 
 s . s2 . getPointer ( ) ) ; 
 } 
 
 + public void testStructureByValueField ( ) { 
 + class TestStructure extends Structure { 
 + public PublicTestStructure . ByValue s1 , s2 ; 
 + public int after ; 
 + protected List getFieldOrder ( ) { 
 + return Arrays . asList ( new String [ ] { " s1 " , " s2 " , " after " } ) ; 
 + } 
 + } 
 + TestStructure s = new TestStructure ( ) ; 
 + TestStructure s2 = new TestStructure ( ) ; 
 + assertNotNull ( " Inner structure should be initialized " , s . s1 ) ; 
 + assertNotNull ( " Inner structure should be initialized ( cached ) " , s2 . s1 ) ; 
 + assertEquals ( " Wrong aggregate size " , 
 + s . s1 . size ( ) + s . s2 . size ( ) + 4 , s . size ( ) ) ; 
 + s . write ( ) ; 
 + assertEquals ( " Wrong memory for structure field 1 after write " , 
 + s . getPointer ( ) , s . s1 . getPointer ( ) ) ; 
 + assertEquals ( " Wrong memory for structure field 2 after write " , 
 + s . getPointer ( ) . share ( s . s1 . size ( ) ) , 
 + s . s2 . getPointer ( ) ) ; 
 + 
 + s . read ( ) ; 
 + assertEquals ( " Wrong memory for structure field 1 after read " , 
 + s . getPointer ( ) , s . s1 . getPointer ( ) ) ; 
 + assertEquals ( " Wrong memory for structure field 2 after read " , 
 + s . getPointer ( ) . share ( s . s1 . size ( ) ) , 
 + s . s2 . getPointer ( ) ) ; 
 + } 
 + 
 static class TestUnion extends Union { 
 public int u _ int ; 
 public float u _ float ;

NEAREST DIFF:
diff - - git a / jnalib / TODO b / jnalib / TODO 
 index 6aed9ef . . 5fd53b8 100644 
 - - - a / jnalib / TODO 
 + + + b / jnalib / TODO 
 @ @ - 21 , 6 + 21 , 11 @ @ 
 
 # TODO 
 
 + * Make a separate jar file for all OS - specific headers 
 + * Maybe make interfaces per - header file ( winbase , winnt , stdlib , etc ) , 
 + aggregated per - library ( interface CLibrary extends stdlib , stdio , etc ) 
 + ( how useful ? ) 
 + 
 * review / use direct Buffer in more places if it makes sense 
 * support annotations of parameters and return values w / o breaking 
 1 . 4 compatibility , e . g . 
 @ @ - 37 , 6 + 42 , 7 @ @ 
 * standard types for various platforms : posix / types . h , w32 ( DWORD , HANDLE ) 
 * StringBuffer / StringBuilder as mutable char * / wchar _ t * argument 
 NOTE : byte [ ] / char [ ] is probably better ; it ' s trivial to convert to String 
 + and native code can ' t change the size anyway 
 * flag string ( / wstring ) - returning methods which need to free their result 
 to avoid leaking memory whan auto - creating strings from the result 
 ( since normally we don ' t take explicit ownership of any returned pointers ) 
 @ @ - 48 , 8 + 54 , 7 @ @ 
 Structure or some other type . Then memory will free itself when no longer 
 referenced . 
 * provide library load / unload hooks ( Runnables in options ? ) . Examples : 
 - o GetLastError in kernel32 ( note : would need to initialize kernel32 from any 
 - other w32 api dll as well ) 
 + o GetLastError ( no longer required ) 
 o WSAInit ? 
 * if method has " GetLastErrorException / ErrnoException " in its signature , use 
 result codes + GetLastError / errno / errstr to auto - generate 
 diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c 
 index d71d167 . . 059f7dd 100644 
 - - - a / jnalib / native / dispatch . c 
 + + + b / jnalib / native / dispatch . c 
 @ @ - 31 , 11 + 31 , 16 @ @ 
 # define FREE _ LIBRARY ( handle ) FreeLibrary ( handle ) 
 # define FIND _ ENTRY ( lib , name ) GetProcAddress ( lib , name ) 
 # define dlerror ( ) " " 
 + # define GET _ LAST _ ERROR ( ) GetLastError ( ) 
 + # define SET _ LAST _ ERROR ( CODE ) SetLastError ( CODE ) 
 # else 
 # include < dlfcn . h > 
 + # include < errno . h > 
 # define LOAD _ LIBRARY ( name ) dlopen ( name , RTLD _ LAZY ) 
 # define FREE _ LIBRARY ( handle ) dlclose ( handle ) 
 # define FIND _ ENTRY ( lib , name ) dlsym ( lib , name ) 
 + # define GET _ LAST _ ERROR ( ) errno 
 + # define SET _ LAST _ ERROR ( CODE ) ( errno = ( CODE ) ) 
 # endif 
 
 # include < stdlib . h > 
 @ @ - 66 , 8 + 71 , 10 @ @ extern " C " 
 # endif 
 
 static JAWT awt ; 
 - static int jawt _ initialized ; 
 + static jboolean jawt _ initialized ; 
 + static jboolean preserve _ last _ error ; 
 
 + / / TODO : include address fault information in error message 
 # ifdef PROTECTED _ START 
 # define ON _ ERROR ( ) throwByName ( env , " java / lang / Error " , " Invalid memory access " ) 
 # define PSTART ( ) PROTECTED _ START ( ) 
 @ @ - 95 , 7 + 102 , 6 @ @ static jclass classLong , classPrimitiveLong ; 
 static jclass classFloat , classPrimitiveFloat ; 
 static jclass classDouble , classPrimitiveDouble ; 
 static jclass classString ; 
 - static jclass classPointer ; 
 static jclass classBuffer ; 
 static jclass classByteBuffer ; 
 static jclass classCharBuffer ; 
 @ @ - 105 , 11 + 111 , 13 @ @ static jclass classLongBuffer ; 
 static jclass classFloatBuffer ; 
 static jclass classDoubleBuffer ; 
 
 + static jclass classPointer ; 
 + static jclass classNative ; 
 + 
 static jmethodID MID _ Class _ getComponentType ; 
 static jmethodID MID _ String _ getBytes ; 
 static jmethodID MID _ String _ toCharArray ; 
 static jmethodID MID _ String _ init _ bytes ; 
 - static jmethodID MID _ Pointer _ init ; 
 static jmethodID MID _ Method _ getReturnType ; 
 static jmethodID MID _ Method _ getParameterTypes ; 
 static jmethodID MID _ Long _ init ; 
 @ @ - 135 , 6 + 143 , 9 @ @ static jmethodID MID _ FloatBuffer _ arrayOffset ; 
 static jmethodID MID _ DoubleBuffer _ array ; 
 static jmethodID MID _ DoubleBuffer _ arrayOffset ; 
 
 + static jmethodID MID _ Pointer _ init ; 
 + static jmethodID MID _ Native _ updateLastError ; 
 + 
 static jfieldID FID _ Boolean _ value ; 
 static jfieldID FID _ Byte _ value ; 
 static jfieldID FID _ Short _ value ; 
 @ @ - 143 , 6 + 154 , 7 @ @ static jfieldID FID _ Integer _ value ; 
 static jfieldID FID _ Long _ value ; 
 static jfieldID FID _ Float _ value ; 
 static jfieldID FID _ Double _ value ; 
 + 
 static jfieldID FID _ Pointer _ peer ; 
 
 / * Forward declarations * / 
 @ @ - 155 , 6 + 167 , 7 @ @ static void * getBufferArray ( JNIEnv * env , jobject buf , 
 static char getArrayComponentType ( JNIEnv * , jobject ) ; 
 static void * getNativeAddress ( JNIEnv * , jobject ) ; 
 static jboolean init _ jawt ( JNIEnv * ) ; 
 + static void update _ last _ error ( JNIEnv * , int ) ; 
 
 / * invoke the real native function * / 
 static void 
 @ @ - 323 , 6 + 336 , 8 @ @ dispatch ( JNIEnv * env , jobject self , jint callconv , jobjectArray arr , 
 PSTART ( ) ; 
 ffi _ call ( & cif , FFI _ FN ( func ) , resP , ffi _ values ) ; 
 PEND ( ) ; 
 + if ( preserve _ last _ error ) 
 + update _ last _ error ( env , GET _ LAST _ ERROR ( ) ) ; 
 break ; 
 } 
 default : 
 @ @ - 381 , 7 + 396 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokePointer ( JNIEnv * env , jobject self , 
 jint callconv , jobjectArray arr ) 
 { 
 jvalue result ; 
 - dispatch ( env , self , callconv , arr , & ffi _ type _ pointer , & result . l ) ; 
 + dispatch ( env , self , callconv , arr , & ffi _ type _ pointer , & result ) ; 
 return newJavaPointer ( env , result . l ) ; 
 } 
 
 @ @ - 395 , 7 + 410 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokeDouble ( JNIEnv * env , jobject self , 
 jint callconv , jobjectArray arr ) 
 { 
 jvalue result ; 
 - dispatch ( env , self , callconv , arr , & ffi _ type _ double , & result . d ) ; 
 + dispatch ( env , self , callconv , arr , & ffi _ type _ double , & result ) ; 
 return result . d ; 
 } 
 
 @ @ - 409 , 7 + 424 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokeFloat ( JNIEnv * env , jobject self , 
 jint callconv , jobjectArray arr ) 
 { 
 jvalue result ; 
 - dispatch ( env , self , callconv , arr , & ffi _ type _ float , & result . f ) ; 
 + dispatch ( env , self , callconv , arr , & ffi _ type _ float , & result ) ; 
 return result . f ; 
 } 
 
 @ @ - 423 , 7 + 438 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokeInt ( JNIEnv * env , jobject self , 
 jint callconv , jobjectArray arr ) 
 { 
 jvalue result ; 
 - dispatch ( env , self , callconv , arr , & ffi _ type _ sint32 , & result . i ) ; 
 + dispatch ( env , self , callconv , arr , & ffi _ type _ sint32 , & result ) ; 
 / * 
 * Big endian 64bit machines will put a 32bit return value in the 
 * upper 4 bytes of the memory area . 
 @ @ - 445 , 7 + 460 , 7 @ @ Java _ com _ sun _ jna _ Function _ invokeLong ( JNIEnv * env , jobject self , 
 jint callconv , jobjectArray arr ) 
 { 
 jvalue result ; 
 - dispatch ( env , self , callconv , arr , & ffi _ type _ sint64 , & result . j ) ; 
 + dispatch ( env , self , callconv , arr , & ffi _ type _ sint64 , & result ) ; 
 return result . j ; 
 } 
 
 @ @ - 493 , 8 + 508 , 8 @ @ Java _ com _ sun _ jna _ NativeLibrary _ open ( JNIEnv * env , jclass cls , jstring lib ) { 
 char * libname = NULL ; 
 
 if ( ( libname = newCString ( env , lib ) ) ! = NULL ) { 
 - 	 handle = ( void * ) LOAD _ LIBRARY ( libname ) ; 
 - 	 free ( libname ) ; 
 + handle = ( void * ) LOAD _ LIBRARY ( libname ) ; 
 + free ( libname ) ; 
 } 
 return ( jlong ) A2L ( handle ) ; 
 } 
 @ @ - 1183 , 6 + 1198 , 13 @ @ newWideCString ( JNIEnv * env , jstring str ) 
 return result ; 
 } 
 
 + / * * Update the per - thread last error setting . * / 
 + static void 
 + update _ last _ error ( JNIEnv * env , int err ) { 
 + ( * env ) - > CallStaticVoidMethod ( env , classNative , 
 + MID _ Native _ updateLastError , err ) ; 
 + } 
 + 
 / * Constructs a Java string from a char array ( using the String ( byte [ ] ) 
 * constructor , which uses default local encoding ) or a short array ( using the 
 * String ( char [ ] ) ctor , which uses the character values unmodified ) . 
 @ @ - 1371 , 6 + 1393 , 7 @ @ Java _ com _ sun _ jna _ Native _ wideCharSize ( JNIEnv * env , jclass cls ) { 
 * / 
 JNIEXPORT void JNICALL 
 Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { 
 + preserve _ last _ error = JNI _ TRUE ; 
 if ( ! LOAD _ CREF ( env , Pointer , " com / sun / jna / Pointer " ) ) { 
 throwByName ( env , " java / lang / UnsatisfiedLinkError " , 
 " Can ' t obtain class com . sun . jna . Pointer " ) ; 
 @ @ - 1388 , 6 + 1411 , 16 @ @ Java _ com _ sun _ jna _ Native _ initIDs ( JNIEnv * env , jclass cls ) { 
 throwByName ( env , " java / lang / UnsatisfiedLinkError " , 
 " Can ' t obtain peer field ID for class com . sun . jna . Pointer " ) ; 
 } 
 + else if ( ! ( classNative = ( * env ) - > NewGlobalRef ( env , cls ) ) ) { 
 + throwByName ( env , " java / lang / UnsatisfiedLinkError " , 
 + " Can ' t obtain global reference for class com . sun . jna . Native " ) ; 
 + } 
 + else if ( ! ( MID _ Native _ updateLastError 
 + = ( * env ) - > GetStaticMethodID ( env , classNative , 
 + " updateLastError " , " ( I ) V " ) ) ) { 
 + throwByName ( env , " java / lang / UnsatisfiedLinkError " , 
 + " Can ' t obtain updateLastError method for class com . sun . jna . Native " ) ; 
 + } 
 } 
 
 JNIEXPORT jlong JNICALL 
 @ @ - 1498 , 10 + 1531 , 25 @ @ Java _ com _ sun _ jna _ Native _ setProtected ( JNIEnv * env , jclass classp , jboolean protec 
 JNIEXPORT jboolean JNICALL 
 Java _ com _ sun _ jna _ Native _ isProtected ( JNIEnv * env , jclass classp ) { 
 # ifdef HAVE _ PROTECTION 
 - return protect ? JNI _ TRUE : JNI _ FALSE ; 
 - # else 
 - return JNI _ FALSE ; 
 + if ( protect ) return JNI _ TRUE ; 
 # endif 
 + return JNI _ FALSE ; 
 + } 
 + 
 + JNIEXPORT void JNICALL 
 + Java _ com _ sun _ jna _ Native _ setPreserveLastError ( JNIEnv * env , jclass classp , jboolean preserve ) { 
 + preserve _ last _ error = preserve ; 
 + } 
 + 
 + JNIEXPORT jboolean JNICALL 
 + Java _ com _ sun _ jna _ Native _ getPreserveLastError ( JNIEnv * env , jclass classp ) { 
 + return preserve _ last _ error ; 
 + } 
 + 
 + JNIEXPORT void JNICALL 
 + Java _ com _ sun _ jna _ Native _ setLastError ( JNIEnv * env , jclass classp , jint code ) { 
 + SET _ LAST _ ERROR ( code ) ; 
 + update _ last _ error ( env , code ) ; 
 } 
 
 static jboolean 
 diff - - git a / jnalib / release - notes . txt b / jnalib / release - notes . txt 
 index 9b4bee7 . . 7b446e4 100755 
 - - - a / jnalib / release - notes . txt 
 + + + b / jnalib / release - notes . txt 
 @ @ - 24 , 6 + 24 , 8 @ @ Bug Fixes 
 * Update X11 library for 64 - bit use ( wmeissner ) 
 * Properly map arrays of char * / wchar _ t * under w32 
 * Allow Pointer [ ] as a Structure field 
 + * Fix some misleading Structure error messages 
 + * Properly preserve / return GetLastError / errno after native calls 
 
 Release 2 . 5 
 Features 
 diff - - git a / jnalib / src / com / sun / jna / CallbackReference . java b / jnalib / src / com / sun / jna / CallbackReference . java 
 index 6a43345 . . 9a1648d 100644 
 - - - a / jnalib / src / com / sun / jna / CallbackReference . java 
 + + + b / jnalib / src / com / sun / jna / CallbackReference . java 
 @ @ - 20 , 7 + 20 , 6 @ @ import java . lang . reflect . Proxy ; 
 import java . util . Iterator ; 
 import java . util . Map ; 
 import java . util . WeakHashMap ; 
 - import com . sun . jna . Library . Handler ; 
 
 / * * Provides a reference to an association between a native callback closure 
 * and a Java { @ link Callback } closure . 
 diff - - git a / jnalib / src / com / sun / jna / Function . java b / jnalib / src / com / sun / jna / Function . java 
 index 4ec5385 . . 9331ca7 100644 
 - - - a / jnalib / src / com / sun / jna / Function . java 
 + + + b / jnalib / src / com / sun / jna / Function . java 
 @ @ - 15 , 8 + 15 , 6 @ @ import java . lang . reflect . Method ; 
 import java . util . Collections ; 
 import java . util . Map ; 
 
 - import com . sun . jna . ptr . ByReference ; 
 - 
 / * * 
 * An abstraction for a native function pointer . An instance of 
 * < code > Function < / code > repesents a pointer to some native function . 
 @ @ - 29 , 7 + 27 , 7 @ @ import com . sun . jna . ptr . ByReference ; 
 * / 
 public class Function extends Pointer { 
 / * * Maximum number of arguments supported by a JNA function call . * / 
 - / / NOTE : this may be different with libffi 
 + / / TODO : make this match libffi ' s limit ( if any ) 
 public static final int MAX _ NARGS = 32 ; 
 
 / * * Standard C calling convention . * / 
 @ @ - 37 , 6 + 35 , 42 @ @ public class Function extends Pointer { 
 / * * First alternate convention ( currently used only for w32 stdcall ) . * / 
 public static final int ALT _ CONVENTION = 1 ; 
 
 + / * * 
 + * Obtain a { @ link Function } representing a native 
 + * function that follows the standard " C " calling convention . 
 + * 
 + * < p > The allocated instance represents a pointer to the named native 
 + * function from the named library , called with the standard " C " calling 
 + * convention . 
 + * 
 + * @ param libraryName 
 + * Library in which to find the native function 
 + * @ param functionName 
 + * Name of the native function to be linked with 
 + * / 
 + public static Function getFunction ( String libraryName , String functionName ) { 
 + return NativeLibrary . getInstance ( libraryName ) . getFunction ( functionName ) ; 
 + } 
 + 
 + / * * 
 + * Obtain a { @ link Function } representing a native 
 + * function that follows a given calling convention . 
 + * 
 + * < p > The allocated instance represents a pointer to the named native 
 + * function from the named library , called with the named calling 
 + * convention . 
 + * 
 + * @ param libraryName 
 + * Library in which to find the function 
 + * @ param functionName 
 + * Name of the native function to be linked with 
 + * @ param callConvention 
 + * Call convention used by the native function 
 + * / 
 + public static Function getFunction ( String libraryName , String functionName , int callConvention ) { 
 + return NativeLibrary . getInstance ( libraryName ) . getFunction ( functionName , callConvention ) ; 
 + } 
 + 
 / / Keep a reference to the NativeLibrary so it does not get garbage collected 
 / / until the function is 
 private NativeLibrary library ; 
 @ @ - 44 , 7 + 78 , 7 @ @ public class Function extends Pointer { 
 private int callingConvention ; 
 
 / * * 
 - * Create a new { @ link Function } that is linked with a native 
 + * Create a new { @ link Function } representing a native 
 * function that follows the standard " C " calling convention . 
 * 
 * < p > The allocated instance represents a pointer to the named native 
 @ @ - 55 , 14 + 89 , 15 @ @ public class Function extends Pointer { 
 * 	 	 	 Library in which to find the native function 
 * @ param 	 functionName 
 * 	 	 	 Name of the native function to be linked with 
 + * @ deprecated Use { @ link # getFunction ( String , String ) } instead . This 
 + * version bypasses lookup cacheing done by { @ link NativeLibrary } . 
 * / 
 public Function ( String libraryName , String functionName ) { 
 this ( libraryName , functionName , C _ CONVENTION ) ; 
 } 
 - 
 - 
 + 
 / * * 
 - * Create a new @ { link Function } that is linked with a native 
 + * Create a new { @ link Function } representing a native 
 * function that follows a given calling convention . 
 * 
 * < p > The allocated instance represents a pointer to the named native 
 @ @ - 75 , 6 + 110 , 8 @ @ public class Function extends Pointer { 
 * 	 	 	 Name of the native function to be linked with 
 * @ param 	 callingConvention 
 * 	 	 	 Calling convention used by the native function 
 + * @ deprecated Use { @ link # getFunction ( String , String , int ) } instead . 
 + * This version bypasses lookup cacheing done by { @ link NativeLibrary } . 
 * / 
 public Function ( String libraryName , String functionName , 
 int callingConvention ) { 
 @ @ - 188 , 6 + 225 , 7 @ @ public class Function extends Pointer { 
 nativeType = resultConverter . nativeType ( ) ; 
 } 
 } 
 + 
 Object result = invoke ( args , nativeType ) ; 
 
 / / Convert the result to a custom value / type if appropriate 
 @ @ - 216 , 7 + 254 , 7 @ @ public class Function extends Pointer { 
 / / were modified 
 ( ( StringArray ) args [ i ] ) . read ( ) ; 
 } 
 - else if ( isStructureArray ( arg . getClass ( ) ) ) { 
 + else if ( Structure [ ] . class . isAssignableFrom ( arg . getClass ( ) ) ) { 
 Structure [ ] ss = ( Structure [ ] ) arg ; 
 for ( int si = 0 ; si < ss . length ; si + + ) { 
 ss [ si ] . read ( ) ; 
 @ @ - 228 , 7 + 266 , 7 @ @ public class Function extends Pointer { 
 return result ; 
 } 
 
 - private Object invoke ( Object [ ] args , Class returnType ) { 
 + Object invoke ( Object [ ] args , Class returnType ) { 
 Object result = null ; 
 if ( returnType = = null | | returnType = = void . class | | returnType = = Void . class ) { 
 invokeVoid ( callingConvention , args ) ; 
 @ @ - 332 , 10 + 370 , 6 @ @ public class Function extends Pointer { 
 struct . write ( ) ; 
 return struct . getPointer ( ) ; 
 } 
 - / / Convert reference class to pointer 
 - else if ( arg instanceof ByReference ) { 
 - return ( ( ByReference ) arg ) . getPointer ( ) ; 
 - } 
 / / Convert Callback to Pointer 
 else if ( arg instanceof Callback ) { 
 return CallbackReference . getFunctionPointer ( ( Callback ) arg ) ; 
 @ @ - 362 , 7 + 396 , 7 @ @ public class Function extends Pointer { 
 else if ( WString [ ] . class = = argClass ) { 
 return new StringArray ( ( WString [ ] ) arg ) ; 
 } 
 - else if ( isStructureArray ( argClass ) ) { 
 + else if ( Structure [ ] . class . isAssignableFrom ( argClass ) ) { 
 / / Initialize uninitialized arrays of Structure to point 
 / / to a single block of memory 
 Structure [ ] ss = ( Structure [ ] ) arg ; 
 @ @ - 397 , 18 + 431 , 13 @ @ public class Function extends Pointer { 
 int size = ss [ 0 ] . size ( ) ; 
 ss [ 0 ] . write ( ) ; 
 for ( int si = 1 ; si < ss . length ; si + + ) { 
 - try { 
 - Pointer p = base . share ( size * si , size ) ; 
 - if ( ss [ si ] . getPointer ( ) . peer ! = p . peer ) { 
 - throw new RuntimeException ( ) ; 
 - } 
 - ss [ si ] . write ( ) ; 
 - } 
 - catch ( RuntimeException e ) { 
 + Pointer p = base . share ( size * si , size ) ; 
 + if ( ss [ si ] . getPointer ( ) . peer ! = p . peer ) { 
 String msg = " Structure array elements must use " 
 - + " contiguous memory : " + si ; 
 + + " contiguous memory ( at element index " + si + " ) " ; 
 throw new IllegalArgumentException ( msg ) ; 
 } 
 + ss [ si ] . write ( ) ; 
 } 
 return base ; 
 } 
 @ @ - 420 , 12 + 449 , 6 @ @ public class Function extends Pointer { 
 return arg ; 
 } 
 
 - private boolean isStructureArray ( Class argClass ) { 
 - return argClass . isArray ( ) 
 - & & Structure . class . isAssignableFrom ( argClass . getComponentType ( ) ) ; 
 - } 
 - 
 - 
 private boolean isPrimitiveArray ( Class argClass ) { 
 return argClass . isArray ( ) 
 & & argClass . getComponentType ( ) . isPrimitive ( ) ; 
 diff - - git a / jnalib / src / com / sun / jna / Native . java b / jnalib / src / com / sun / jna / Native . java 
 index f8b03aa . . b718493 100644 
 - - - a / jnalib / src / com / sun / jna / Native . java 
 + + + b / jnalib / src / com / sun / jna / Native . java 
 @ @ - 94 , 6 + 94 , 16 @ @ public final class Native { 
 * if this platform supports protecting memory accesses . 
 * / 
 public static native boolean isProtected ( ) ; 
 + 
 + / * * Set whether the system last error result is captured after every 
 + * native invocation . Defaults to < code > true < / code > . 
 + * / 
 + public static native void setPreserveLastError ( boolean enable ) ; 
 + 
 + / * * Indicates whether the system last error result is preserved 
 + * after every invocation . 
 + * / 
 + public static native boolean getPreserveLastError ( ) ; 
 
 / * * Utility method to get the native window ID for a Java { @ link Window } 
 * as a < code > long < / code > value . 
 @ @ - 208 , 8 + 218 , 8 @ @ public final class Native { 
 * @ param options Map of library options 
 * / 
 public static Object loadLibrary ( String name , 
 - Class interfaceClass , 
 - Map options ) { 
 + Class interfaceClass , 
 + Map options ) { 
 Library . Handler handler = 
 new Library . Handler ( name , interfaceClass , options ) ; 
 ClassLoader loader = interfaceClass . getClassLoader ( ) ; 
 @ @ - 399 , 4 + 409 , 29 @ @ public final class Native { 
 
 / * * Return the size of a native < code > wchar _ t < / code > . * / 
 private static native int wideCharSize ( ) ; 
 + 
 + private static final ThreadLocal lastError = new ThreadLocal ( ) { 
 + protected synchronized Object initialValue ( ) { 
 + return new Integer ( 0 ) ; 
 + } 
 + } ; 
 + 
 + / * * Retrieve the last error set by the OS . The value is preserved 
 + * per - thread , but whether the original value is per - thread depends on 
 + * the underlying OS . The result is undefined If 
 + * { @ link # getPreserveLastError } is < code > false < / code > . 
 + * / 
 + public static int getLastError ( ) { 
 + return ( ( Integer ) lastError . get ( ) ) . intValue ( ) ; 
 + } 
 + 
 + / * * Set the OS last error code . Whether the setting is per - thread 
 + * or global depends on the underlying OS . 
 + * / 
 + public static native void setLastError ( int code ) ; 
 + 
 + / * * Update the last error value ( called from native code ) . * / 
 + static void updateLastError ( int e ) { 
 + lastError . set ( new Integer ( e ) ) ; 
 + } 
 } 
 diff - - git a / jnalib / src / com / sun / jna / NativeLibrary . java b / jnalib / src / com / sun / jna / NativeLibrary . java 
 index 7f22749 . . d3e361f 100644 
 - - - a / jnalib / src / com / sun / jna / NativeLibrary . java 
 + + + b / jnalib / src / com / sun / jna / NativeLibrary . java 
 @ @ - 58 , 6 + 58 , 18 @ @ public class NativeLibrary { 
 this . libraryName = getLibraryName ( libraryName ) ; 
 this . libraryPath = libraryPath ; 
 this . handle = handle ; 
 + / / Special workaround for w32 kernel32 . GetLastError 
 + / / Short - circuit the function to use built - in GetLastError access 
 + if ( Platform . isWindows ( ) & & " kernel32 " . equals ( this . libraryName ) ) { 
 + synchronized ( functions ) { 
 + Function f = new Function ( this , " GetLastError " , Function . ALT _ CONVENTION ) { 
 + Object invoke ( Object [ ] args , Class returnType ) { 
 + return new Integer ( Native . getLastError ( ) ) ; 
 + } 
 + } ; 
 + functions . put ( " GetLastError " , f ) ; 
 + } 
 + } 
 } 
 
 private static NativeLibrary loadLibrary ( String libraryName ) { 
 diff - - git a / jnalib / src / com / sun / jna / Structure . java b / jnalib / src / com / sun / jna / Structure . java 
 index 8d7ff9e . . 1d6d94a 100644 
 - - - a / jnalib / src / com / sun / jna / Structure . java 
 + + + b / jnalib / src / com / sun / jna / Structure . java 
 @ @ - 13 , 7 + 13 , 6 @ @ package com . sun . jna ; 
 import java . lang . reflect . Array ; 
 import java . lang . reflect . Field ; 
 import java . lang . reflect . Modifier ; 
 - import java . util . Arrays ; 
 import java . util . HashMap ; 
 import java . util . Iterator ; 
 import java . util . LinkedHashMap ; 
 @ @ - 317 , 7 + 316 , 7 @ @ public abstract class Structure { 
 try { 
 Object o = structField . field . get ( this ) ; 
 if ( o = = null ) { 
 - throw new IllegalStateException ( " Structure array field not initialized " ) ; 
 + throw new IllegalStateException ( " Array field in Structure not initialized " ) ; 
 } 
 length = Array . getLength ( o ) ; 
 } 
 @ @ - 369 , 9 + 368 , 9 @ @ public abstract class Structure { 
 structField . field . set ( this , result ) ; 
 } 
 catch ( Exception e ) { 
 - throw new RuntimeException ( " Exception setting field \ " " 
 - + structField . name + " \ " to " + result 
 - + " : " + e , e ) ; 
 + throw new Error ( " Exception setting field \ " " 
 + + structField . name + " \ " to " + result 
 + + " : " + e , e ) ; 
 } 
 } 
 
 @ @ - 413 , 8 + 412 , 8 @ @ public abstract class Structure { 
 value = structField . field . get ( this ) ; 
 } 
 catch ( Exception e ) { 
 - throw new RuntimeException ( " Exception reading field \ " " 
 - + structField . name + " \ " " , e ) ; 
 + throw new Error ( " Exception reading field \ " " 
 + + structField . name + " \ " " , e ) ; 
 } 
 / / Determine the type of the field 
 Class nativeType = structField . type ; 
 diff - - git a / jnalib / src / com / sun / jna / examples / WindowUtils . java b / jnalib / src / com / sun / jna / examples / WindowUtils . java 
 index 63413cb . . 205f885 100644 
 - - - a / jnalib / src / com / sun / jna / examples / WindowUtils . java 
 + + + b / jnalib / src / com / sun / jna / examples / WindowUtils . java 
 @ @ - 984 , 7 + 984 , 7 @ @ public class WindowUtils { 
 false ) , 
 X11 . XA _ CARDINAL , 32 , 
 X11 . PropModeReplace , 
 - patom . getPointer ( ) , 1 ) ; 
 + patom , 1 ) ; 
 } 
 } 
 finally { 
 diff - - git a / jnalib / src / com / sun / jna / examples / unix / X11 . java b / jnalib / src / com / sun / jna / examples / unix / X11 . java 
 index 8097c7f . . 793cbd9 100644 
 - - - a / jnalib / src / com / sun / jna / examples / unix / X11 . java 
 + + + b / jnalib / src / com / sun / jna / examples / unix / X11 . java 
 @ @ - 15 , 8 + 15 , 8 @ @ package com . sun . jna . examples . unix ; 
 import com . sun . jna . FromNativeContext ; 
 import com . sun . jna . Library ; 
 import com . sun . jna . Native ; 
 - import com . sun . jna . NativeMapped ; 
 import com . sun . jna . NativeLong ; 
 + import com . sun . jna . NativeMapped ; 
 import com . sun . jna . Pointer ; 
 import com . sun . jna . PointerType ; 
 import com . sun . jna . Structure ; 
 @ @ - 29 , 11 + 29 , 17 @ @ import com . sun . jna . ptr . PointerByReference ; 
 public interface X11 extends Library { 
 
 public static class XID implements NativeMapped { 
 + public static final XID None = null ; 
 private Integer id = new Integer ( 0 ) ; 
 - public XID ( ) { this ( None ) ; } 
 + public XID ( ) { this ( X11 . None ) ; } 
 public XID ( Integer id ) { this . id = id ; } 
 public XID ( int id ) { this ( new Integer ( id ) ) ; } 
 + protected boolean isNone ( Object o ) { 
 + return ( ( Integer ) o ) . intValue ( ) = = X11 . None ; 
 + } 
 public Object fromNative ( Object nativeValue , FromNativeContext context ) { 
 + if ( isNone ( nativeValue ) ) 
 + return None ; 
 return new XID ( ( Integer ) nativeValue ) ; 
 } 
 public Class nativeType ( ) { 
 @ @ - 44 , 12 + 50 , 16 @ @ public interface X11 extends Library { 
 } 
 } 
 public static class Atom extends XID { 
 + public static final Atom None = null ; 
 public Atom ( ) { } 
 public Atom ( Integer id ) { super ( id ) ; } 
 public Atom ( int id ) { super ( id ) ; } 
 + / * * Return constants for predefined < code > Atom < / code > values . * / 
 public Object fromNative ( Object nativeValue , FromNativeContext context ) { 
 int value = ( ( Integer ) nativeValue ) . intValue ( ) ; 
 switch ( value ) { 
 + case 0 : 
 + return None ; 
 case 1 : 
 return XA _ PRIMARY ; 
 case 2 : 
 @ @ - 70 , 56 + 80 , 68 @ @ public interface X11 extends Library { 
 public static class AtomByReference extends ByReference { 
 public AtomByReference ( ) { super ( 4 ) ; } 
 public Atom getValue ( ) { 
 - return ( Atom ) new Atom ( ) . fromNative ( new Integer ( getPointer ( ) . getInt ( 0 ) ) , null ) ; 
 + return ( Atom ) new Atom ( ) . fromNative ( new Integer ( getInt ( 0 ) ) , null ) ; 
 } 
 } 
 public static class Colormap extends XID { 
 + public static final Colormap None = null ; 
 public Colormap ( ) { } 
 public Colormap ( Integer id ) { super ( id ) ; } 
 public Colormap ( int id ) { super ( id ) ; } 
 public Object fromNative ( Object nativeValue , FromNativeContext context ) { 
 + if ( isNone ( nativeValue ) ) 
 + return None ; 
 return new Colormap ( ( Integer ) nativeValue ) ; 
 } 
 } 
 public static class Cursor extends XID { 
 + public static final Cursor None = null ; 
 public Cursor ( ) { } 
 public Cursor ( Integer id ) { super ( id ) ; } 
 public Cursor ( int id ) { super ( id ) ; } 
 public Object fromNative ( Object nativeValue , FromNativeContext context ) { 
 + if ( isNone ( nativeValue ) ) 
 + return None ; 
 return new Cursor ( ( Integer ) nativeValue ) ; 
 } 
 } 
 public static class Drawable extends XID { 
 - public static final Drawable None = new Drawable ( X11 . None ) ; 
 + public static final Drawable None = null ; 
 public Drawable ( ) { } 
 public Drawable ( Integer id ) { super ( id ) ; } 
 public Drawable ( int id ) { super ( id ) ; } 
 public Object fromNative ( Object nativeValue , FromNativeContext context ) { 
 + if ( isNone ( nativeValue ) ) 
 + return None ; 
 return new Drawable ( ( Integer ) nativeValue ) ; 
 } 
 } 
 public static class Window extends Drawable { 
 - public static final Window None = new Window ( X11 . None ) ; 
 + public static final Window None = null ; 
 public Window ( ) { } 
 public Window ( Integer id ) { super ( id ) ; } 
 public Window ( int id ) { super ( id ) ; } 
 public Object fromNative ( Object nativeValue , FromNativeContext context ) { 
 + if ( isNone ( nativeValue ) ) 
 + return None ; 
 return new Window ( ( Integer ) nativeValue ) ; 
 } 
 } 
 public static class WindowByReference extends ByReference { 
 public WindowByReference ( ) { super ( 4 ) ; } 
 public Window getValue ( ) { 
 - int value = getPointer ( ) . getInt ( 0 ) ; 
 + int value = getInt ( 0 ) ; 
 return value = = X11 . None ? Window . None : new Window ( value ) ; 
 } 
 } 
 public static class Pixmap extends Drawable { 
 - public static final Pixmap None = new Pixmap ( X11 . None ) ; 
 + public static final Pixmap None = null ; 
 public Pixmap ( ) { } 
 public Pixmap ( Integer id ) { super ( id ) ; } 
 public Pixmap ( int id ) { super ( id ) ; } 
 public Object fromNative ( Object nativeValue , FromNativeContext context ) { 
 + if ( isNone ( nativeValue ) ) 
 + return None ; 
 return new Pixmap ( ( Integer ) nativeValue ) ; 
 } 
 } 
 @ @ - 334 , 12 + 356 , 14 @ @ public interface X11 extends Library { 
 int AllocNone = 0 ; 
 int AllocAll = 1 ; 
 
 - Atom XA _ PRIMARY = new Atom ( 0 ) ; 
 - Atom XA _ SECONDARY = new Atom ( 1 ) ; 
 - Atom XA _ ARC = new Atom ( 2 ) ; 
 + Atom XA _ PRIMARY = new Atom ( 1 ) ; 
 + Atom XA _ SECONDARY = new Atom ( 2 ) ; 
 + Atom XA _ ARC = new Atom ( 3 ) ; 
 Atom XA _ ATOM = new Atom ( 4 ) ; 
 Atom XA _ BITMAP = new Atom ( 5 ) ; 
 Atom XA _ CARDINAL = new Atom ( 6 ) ; 
 + Atom XA _ COLORMAP = new Atom ( 7 ) ; 
 + Atom XA _ CURSOR = new Atom ( 8 ) ; 
 
 int PropModeReplace = 0 ; 
 int PropModePrepend = 1 ; 
 diff - - git a / jnalib / src / com / sun / jna / examples / win32 / Kernel32 . java b / jnalib / src / com / sun / jna / examples / win32 / Kernel32 . java 
 index d6fee2b . . 590af27 100644 
 - - - a / jnalib / src / com / sun / jna / examples / win32 / Kernel32 . java 
 + + + b / jnalib / src / com / sun / jna / examples / win32 / Kernel32 . java 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * / 
 package com . sun . jna . examples . win32 ; 
 
 + import java . nio . Buffer ; 
 import com . sun . jna . Native ; 
 import com . sun . jna . Pointer ; 
 import com . sun . jna . Structure ; 
 @ @ - 20 , 7 + 21 , 7 @ @ import com . sun . jna . ptr . PointerByReference ; 
 
 / * * Definition ( incomplete ) of < code > kernel32 . dll < / code > . * / 
 public interface Kernel32 extends W32API { 
 - 
 + 
 Kernel32 INSTANCE = ( Kernel32 ) 
 Native . loadLibrary ( " kernel32 " , Kernel32 . class , DEFAULT _ OPTIONS ) ; 
 
 @ @ - 49 , 6 + 50 , 9 @ @ public interface Kernel32 extends W32API { 
 int FormatMessage ( int dwFlags , Pointer lpSource , int dwMessageId , 
 int dwLanguageId , PointerByReference lpBuffer , 
 int nSize , Pointer va _ list ) ; 
 + int FormatMessage ( int dwFlags , Pointer lpSource , int dwMessageId , 
 + int dwLanguageId , Buffer lpBuffer , 
 + int nSize , Pointer va _ list ) ; 
 
 int FILE _ LIST _ DIRECTORY = 0x00000001 ; 
 
 diff - - git a / jnalib / src / com / sun / jna / ptr / ByReference . java b / jnalib / src / com / sun / jna / ptr / ByReference . java 
 index b9ceb56 . . 26fae77 100644 
 - - - a / jnalib / src / com / sun / jna / ptr / ByReference . java 
 + + + b / jnalib / src / com / sun / jna / ptr / ByReference . java 
 @ @ - 15 , 16 + 15 , 22 @ @ package com . sun . jna . ptr ; 
 import com . sun . jna . Memory ; 
 import com . sun . jna . Pointer ; 
 
 - / * * Provides generic " pointer to type " functionality . * / 
 - public abstract class ByReference { 
 - 
 - private Pointer pointer ; 
 + / * * Provides generic " pointer to type " functionality , often used in C 
 + * code to return values to the caller in addition to a function result . 
 + * < p > 
 + * Derived classes should define < code > setValue ( & lt ; T & gt ; ) < / code > 
 + * and < code > & lt ; T & gt ; getValue ( ) < / code > methods which write to / read from 
 + * memory . 
 + * / 
 + public abstract class ByReference extends Memory { 
 
 protected ByReference ( int dataSize ) { 
 - pointer = new Memory ( dataSize ) ; 
 + super ( dataSize ) ; 
 } 
 
 + / * * @ deprecated This is equivalent to the object itself . * / 
 public Pointer getPointer ( ) { 
 - return pointer ; 
 + return this ; 
 } 
 + 
 } 
 diff - - git a / jnalib / src / com / sun / jna / ptr / ByteByReference . java b / jnalib / src / com / sun / jna / ptr / ByteByReference . java 
 index 3307e46 . . fc0dec6 100644 
 - - - a / jnalib / src / com / sun / jna / ptr / ByteByReference . java 
 + + + b / jnalib / src / com / sun / jna / ptr / ByteByReference . java 
 @ @ - 24 , 11 + 24 , 11 @ @ public class ByteByReference extends ByReference { 
 } 
 
 public void setValue ( byte value ) { 
 - getPointer ( ) . setByte ( 0 , value ) ; 
 + setByte ( 0 , value ) ; 
 } 
 
 public byte getValue ( ) { 
 - return getPointer ( ) . getByte ( 0 ) ; 
 + return getByte ( 0 ) ; 
 } 
 
 } 
 diff - - git a / jnalib / src / com / sun / jna / ptr / DoubleByReference . java b / jnalib / src / com / sun / jna / ptr / DoubleByReference . java 
 index 88c1cc6 . . 51ec904 100644 
 - - - a / jnalib / src / com / sun / jna / ptr / DoubleByReference . java 
 + + + b / jnalib / src / com / sun / jna / ptr / DoubleByReference . java 
 @ @ - 23 , 11 + 23 , 11 @ @ public class DoubleByReference extends ByReference { 
 } 
 
 public void setValue ( double value ) { 
 - getPointer ( ) . setDouble ( 0 , value ) ; 
 + setDouble ( 0 , value ) ; 
 } 
 
 public double getValue ( ) { 
 - return getPointer ( ) . getDouble ( 0 ) ; 
 + return getDouble ( 0 ) ; 
 } 
 
 } 
 diff - - git a / jnalib / src / com / sun / jna / ptr / FloatByReference . java b / jnalib / src / com / sun / jna / ptr / FloatByReference . java 
 index 8675a98 . . ea932bf 100644 
 - - - a / jnalib / src / com / sun / jna / ptr / FloatByReference . java 
 + + + b / jnalib / src / com / sun / jna / ptr / FloatByReference . java 
 @ @ - 23 , 11 + 23 , 11 @ @ public class FloatByReference extends ByReference { 
 } 
 
 public void setValue ( float value ) { 
 - getPointer ( ) . setFloat ( 0 , value ) ; 
 + setFloat ( 0 , value ) ; 
 } 
 
 public float getValue ( ) { 
 - return getPointer ( ) . getFloat ( 0 ) ; 
 + return getFloat ( 0 ) ; 
 } 
 
 } 
 diff - - git a / jnalib / src / com / sun / jna / ptr / IntByReference . java b / jnalib / src / com / sun / jna / ptr / IntByReference . java 
 index a330001 . . f04fd26 100644 
 - - - a / jnalib / src / com / sun / jna / ptr / IntByReference . java 
 + + + b / jnalib / src / com / sun / jna / ptr / IntByReference . java 
 @ @ - 24 , 10 + 24 , 10 @ @ public class IntByReference extends ByReference { 
 } 
 
 public void setValue ( int value ) { 
 - getPointer ( ) . setInt ( 0 , value ) ; 
 + setInt ( 0 , value ) ; 
 } 
 
 public int getValue ( ) { 
 - return getPointer ( ) . getInt ( 0 ) ; 
 + return getInt ( 0 ) ; 
 } 
 } 
 diff - - git a / jnalib / src / com / sun / jna / ptr / LongByReference . java b / jnalib / src / com / sun / jna / ptr / LongByReference . java 
 index 132fe88 . . c67d9ac 100644 
 - - - a / jnalib / src / com / sun / jna / ptr / LongByReference . java 
 + + + b / jnalib / src / com / sun / jna / ptr / LongByReference . java 
 @ @ - 23 , 10 + 23 , 10 @ @ public class LongByReference extends ByReference { 
 } 
 
 public void setValue ( long value ) { 
 - getPointer ( ) . setLong ( 0 , value ) ; 
 + setLong ( 0 , value ) ; 
 } 
 
 public long getValue ( ) { 
 - return getPointer ( ) . getLong ( 0 ) ; 
 + return getLong ( 0 ) ; 
 } 
 } 
 diff - - git a / jnalib / src / com / sun / jna / ptr / NativeLongByReference . java b / jnalib / src / com / sun / jna / ptr / NativeLongByReference . java 
 index f27dfdb . . 0858c06 100644 
 - - - a / jnalib / src / com / sun / jna / ptr / NativeLongByReference . java 
 + + + b / jnalib / src / com / sun / jna / ptr / NativeLongByReference . java 
 @ @ - 25 , 10 + 25 , 10 @ @ public class NativeLongByReference extends ByReference { 
 } 
 
 public void setValue ( NativeLong value ) { 
 - getPointer ( ) . setNativeLong ( 0 , value ) ; 
 + setNativeLong ( 0 , value ) ; 
 } 
 
 public NativeLong getValue ( ) { 
 - return getPointer ( ) . getNativeLong ( 0 ) ; 
 + return getNativeLong ( 0 ) ; 
 } 
 } 
 diff - - git a / jnalib / src / com / sun / jna / ptr / PointerByReference . java b / jnalib / src / com / sun / jna / ptr / PointerByReference . java 
 index 86b4b7e . . 1484c3e 100644 
 - - - a / jnalib / src / com / sun / jna / ptr / PointerByReference . java 
 + + + b / jnalib / src / com / sun / jna / ptr / PointerByReference . java 
 @ @ - 30 , 10 + 30 , 10 @ @ public class PointerByReference extends ByReference { 
 } 
 
 public void setValue ( Pointer value ) { 
 - getPointer ( ) . setPointer ( 0 , value ) ; 
 + setPointer ( 0 , value ) ; 
 } 
 
 public Pointer getValue ( ) { 
 - return getPointer ( ) . getPointer ( 0 ) ; 
 + return getPointer ( 0 ) ; 
 } 
 } 
 diff - - git a / jnalib / src / com / sun / jna / ptr / ShortByReference . java b / jnalib / src / com / sun / jna / ptr / ShortByReference . java 
 index c3ed01c . . 43f5456 100644 
 - - - a / jnalib / src / com / sun / jna / ptr / ShortByReference . java 
 + + + b / jnalib / src / com / sun / jna / ptr / ShortByReference . java 
 @ @ - 24 , 11 + 24 , 11 @ @ public class ShortByReference extends ByReference { 
 } 
 
 public void setValue ( short value ) { 
 - getPointer ( ) . setShort ( 0 , value ) ; 
 + setShort ( 0 , value ) ; 
 } 
 
 public short getValue ( ) { 
 - return getPointer ( ) . getShort ( 0 ) ; 
 + return getShort ( 0 ) ; 
 } 
 
 } 
 diff - - git a / jnalib / test / com / sun / jna / examples / win32 / Kernel32Test . java b / jnalib / test / com / sun / jna / examples / win32 / Kernel32Test . java 
 index 1446ab1 . . 708f6f8 100644 
 - - - a / jnalib / test / com / sun / jna / examples / win32 / Kernel32Test . java 
 + + + b / jnalib / test / com / sun / jna / examples / win32 / Kernel32Test . java 
 @ @ - 14 , 9 + 14 , 6 @ @ package com . sun . jna . examples . win32 ; 
 
 import java . util . Calendar ; 
 import java . util . TimeZone ; 
 - import com . sun . jna . Native ; 
 - import com . sun . jna . Pointer ; 
 - import com . sun . jna . win32 . StdCallLibrary ; 
 import junit . framework . TestCase ; 
 
 public class Kernel32Test extends TestCase { 
 @ @ - 34 , 33 + 31 , 26 @ @ public class Kernel32Test extends TestCase { 
 assertEquals ( " Year not properly set " , 
 cal . get ( Calendar . YEAR ) , time . wYear ) ; 
 } 
 - 
 + 
 public void testGetLastError ( ) { 
 Kernel32 kernel = Kernel32 . INSTANCE ; 
 - kernel . GetLastError ( ) ; 
 + int ERRCODE = 8 ; 
 + 
 + kernel . SetLastError ( ERRCODE ) ; 
 + int code = kernel . GetLastError ( ) ; 
 + assertEquals ( " Wrong GetLastError value " , ERRCODE , code ) ; 
 + 
 if ( kernel . GetProcessId ( null ) = = 0 ) { 
 final int INVALID _ HANDLE = 6 ; 
 - int code = kernel . GetLastError ( ) ; 
 + code = kernel . GetLastError ( ) ; 
 assertEquals ( " GetLastError failed " , INVALID _ HANDLE , code ) ; 
 - int ERRCODE = 8 ; 
 - kernel . SetLastError ( ERRCODE ) ; 
 - code = kernel . GetLastError ( ) ; 
 - assertEquals ( " Wrong GetLastError value " , ERRCODE , code ) ; 
 } 
 else { 
 fail ( " GetProcessId ( NULL ) should fail " ) ; 
 } 
 - 
 - / * 
 - final int GENERIC _ EXECUTE = 0x20000000 ; 
 - Pointer h = AdvAPI32 . INSTANCE . OpenSCManager ( " localhost " , null , GENERIC _ EXECUTE ) ; 
 - int code = kernel . GetLastError ( ) ; 
 - int EXPECTED = 1722 ; 
 - if ( h = = null ) { 
 - assertEquals ( " Wrong error " , EXPECTED , code ) ; 
 - } 
 - else { 
 - fail ( " Unexpected non - null result " ) ; 
 - } * / 
 + } 
 + 
 + public static void main ( String [ ] args ) { 
 + junit . textui . TestRunner . run ( Kernel32Test . class ) ; 
 } 
 }
