BLEU SCORE: 0.005918093729486186

TEST MSG: fix failing test on XP
GENERATED MSG: Pass the Method of the Library subclass that invoked the Function , to the FromNativeConverter .

TEST DIFF (one line): diff - - git a / src / com / sun / jna / Library . java b / src / com / sun / jna / Library . java <nl> index 6344a1f . . 621e4f3 100644 <nl> - - - a / src / com / sun / jna / Library . java <nl> + + + b / src / com / sun / jna / Library . java <nl> @ @ - 136 , 7 + 136 , 6 @ @ public interface Library { <nl> private final Class interfaceClass ; <nl> / / Library invocation options <nl> private final Map options ; <nl> - private FunctionMapper functionMapper ; <nl> private final InvocationMapper invocationMapper ; <nl> private final Map functions = new WeakHashMap ( ) ; <nl> public Handler ( String libname , Class interfaceClass , Map options ) { <nl> @ @ - 155 , 13 + 154 , 12 @ @ public interface Library { <nl> options . put ( OPTION _ CALLING _ CONVENTION , <nl> new Integer ( callingConvention ) ) ; <nl> } <nl> + if ( ! options . containsKey ( OPTION _ FUNCTION _ MAPPER ) ) { <nl> + / / Passed - in map is itself the name map <nl> + options . put ( OPTION _ FUNCTION _ MAPPER , new FunctionNameMap ( options ) ) ; <nl> + } <nl> this . options = options ; <nl> this . nativeLibrary = NativeLibrary . getInstance ( libname , options ) ; <nl> - functionMapper = ( FunctionMapper ) options . get ( OPTION _ FUNCTION _ MAPPER ) ; <nl> - if ( functionMapper = = null ) { <nl> - / / backward compatibility ; passed - in map is itself the name map <nl> - functionMapper = new FunctionNameMap ( options ) ; <nl> - } <nl> invocationMapper = ( InvocationMapper ) options . get ( OPTION _ INVOCATION _ MAPPER ) ; <nl> } <nl> <nl> @ @ - 213 , 13 + 211 , 7 @ @ public interface Library { <nl> } <nl> if ( f . handler = = null ) { <nl> / / Find the function to invoke <nl> - String methodName = <nl> - functionMapper . getFunctionName ( nativeLibrary , method ) ; <nl> - if ( methodName = = null ) { <nl> - / / Just in case the function mapper screwed up <nl> - methodName = method . getName ( ) ; <nl> - } <nl> - f . function = nativeLibrary . getFunction ( methodName , method ) ; <nl> + f . function = nativeLibrary . getFunction ( method . getName ( ) , method ) ; <nl> f . options = new HashMap ( this . options ) ; <nl> f . options . put ( Function . OPTION _ INVOKING _ METHOD , method ) ; <nl> } <nl> diff - - git a / src / com / sun / jna / NativeLibrary . java b / src / com / sun / jna / NativeLibrary . java <nl> index 21fcceb . . 8aa6622 100644 <nl> - - - a / src / com / sun / jna / NativeLibrary . java <nl> + + + b / src / com / sun / jna / NativeLibrary . java <nl> @ @ - 68 , 6 + 68 , 7 @ @ public class NativeLibrary { <nl> private final String libraryPath ; <nl> private final Map functions = new HashMap ( ) ; <nl> final int callFlags ; <nl> + private String encoding ; <nl> final Map options ; <nl> <nl> private static final Map libraries = new HashMap ( ) ; <nl> @ @ - 93 , 9 + 94 , 9 @ @ public class NativeLibrary { <nl> ? ( ( Number ) option ) . intValue ( ) : Function . C _ CONVENTION ; <nl> this . callFlags = callingConvention ; <nl> this . options = options ; <nl> - String encoding = ( String ) options . get ( Library . OPTION _ STRING _ ENCODING ) ; <nl> - if ( encoding = = null ) { <nl> - encoding = Native . getDefaultStringEncoding ( ) ; <nl> + this . encoding = ( String ) options . get ( Library . OPTION _ STRING _ ENCODING ) ; <nl> + if ( this . encoding = = null ) { <nl> + this . encoding = Native . getDefaultStringEncoding ( ) ; <nl> } <nl> <nl> / / Special workaround for w32 kernel32 . GetLastError <nl> @ @ - 422 , 12 + 423 , 19 @ @ public class NativeLibrary { <nl> * function from the library . <nl> * <nl> * @ param 	 name <nl> - * 	 	 	 Name of the native function to be linked with <nl> + * 	 	 	 Name of the native function to be linked with . Uses a <nl> + * 	 	 	 function mapper option if one was provided to <nl> + * 	 	 	 transform the name . <nl> * @ param 	 method <nl> * 	 	 	 Method to which the native function is to be mapped <nl> * @ throws UnsatisfiedLinkError if the function is not found <nl> * / <nl> Function getFunction ( String name , Method method ) { <nl> + FunctionMapper mapper = ( FunctionMapper ) <nl> + options . get ( Library . OPTION _ FUNCTION _ MAPPER ) ; <nl> + if ( mapper ! = null ) { <nl> + name = mapper . getFunctionName ( this , method ) ; <nl> + } <nl> int flags = this . callFlags ; <nl> Class [ ] etypes = method . getExceptionTypes ( ) ; <nl> for ( int i = 0 ; i < etypes . length ; i + + ) { <nl> @ @ - 449 , 7 + 457 , 7 @ @ public class NativeLibrary { <nl> * @ throws UnsatisfiedLinkError if the function is not found <nl> * / <nl> public Function getFunction ( String functionName , int callFlags ) { <nl> - return getFunction ( functionName , callFlags , Native . getDefaultStringEncoding ( ) ) ; <nl> + return getFunction ( functionName , callFlags , encoding ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java <nl> index 02448e1 . . fe7e630 100644 <nl> - - - a / test / com / sun / jna / CallbacksTest . java <nl> + + + b / test / com / sun / jna / CallbacksTest . java <nl> @ @ - 13 , 6 + 13 , 7 @ @ <nl> package com . sun . jna ; <nl> <nl> import java . io . ByteArrayOutputStream ; <nl> + import java . io . File ; <nl> import java . io . PrintStream ; <nl> import java . lang . ref . WeakReference ; <nl> import java . util . Arrays ; <nl> @ @ - 36 , 7 + 37 , 7 @ @ import com . sun . jna . win32 . W32APIOptions ; <nl> * @ author twall @ users . sf . net <nl> * / <nl> / / @ SuppressWarnings ( " unused " ) <nl> - public class CallbacksTest extends TestCase { <nl> + public class CallbacksTest extends TestCase implements Paths { <nl> <nl> private static final String UNICODE = " [ \ u0444 ] " ; <nl> <nl> @ @ - 1201 , 11 + 1202 , 19 @ @ public class CallbacksTest extends TestCase { <nl> PointerByReference pref = new PointerByReference ( ) ; <nl> int result = f . invokeInt ( new Object [ ] { new Integer ( GET _ MODULE _ HANDLE _ FROM _ ADDRESS ) , fp , pref } ) ; <nl> assertTrue ( " GetModuleHandleEx ( fptr ) failed : " + Native . getLastError ( ) , result ! = 0 ) ; <nl> + f = kernel32 . getFunction ( " GetModuleFileNameW " ) ; <nl> + char [ ] buf = new char [ 1024 ] ; <nl> + result = f . invokeInt ( new Object [ ] { pref . getValue ( ) , buf , buf . length } ) ; <nl> + assertTrue ( " GetModuleFileName ( fptr ) failed : " + Native . getLastError ( ) , result ! = 0 ) ; <nl> + <nl> <nl> f = kernel32 . getFunction ( " GetModuleHandleW " ) ; <nl> - Pointer handle = f . invokePointer ( new Object [ ] { " jnidispatch . dll " } ) ; <nl> - assertTrue ( " GetModuleHandle ( \ " jnidispatch \ " ) failed : " + Native . getLastError ( ) , result ! = 0 ) ; <nl> - assertNotNull ( " Could not get module handle for jnidispatch . dll " , handle ) ; <nl> + / / XP needs full path to DLL ; win7 only needs " jnidispatch " <nl> + File dispatch = new File ( CLASSES , " com / sun / jna / " + Platform . RESOURCE _ PREFIX + " / jnidispatch " ) ; <nl> + String path = dispatch . getAbsolutePath ( ) ; <nl> + Pointer handle = f . invokePointer ( new Object [ ] { path } ) ; <nl> + assertTrue ( " GetModuleHandle ( \ " " + path + " \ " ) failed : " + Native . getLastError ( ) , result ! = 0 ) ; <nl> + assertNotNull ( " Could not get module handle for " + path + " : " + Native . getLastError ( ) , handle ) ; <nl> assertEquals ( " Wrong module HANDLE for DLL function pointer " , handle , pref . getValue ( ) ) ; <nl> <nl> / / Check slot re - use
NEAREST DIFF (one line): diff - - git a / jnalib / dist / freebsd - i386 . jar b / jnalib / dist / freebsd - i386 . jar <nl> index 6c8aec2 . . 7eea228 100644 <nl> Binary files a / jnalib / dist / freebsd - i386 . jar and b / jnalib / dist / freebsd - i386 . jar differ <nl> diff - - git a / jnalib / native / dispatch . h b / jnalib / native / dispatch . h <nl> index d1dc381 . . 4c5a20d 100644 <nl> - - - a / jnalib / native / dispatch . h <nl> + + + b / jnalib / native / dispatch . h <nl> @ @ - 47 , 8 + 47 , 12 @ @ typedef long word _ t ; <nl> # define alloca _ alloca <nl> # endif <nl> # else <nl> + # ifdef _ _ FreeBSD _ _ <nl> + # include < stdlib . h > <nl> + # else <nl> # include < alloca . h > <nl> # endif <nl> + # endif <nl> <nl> / * Convenience macros * / <nl> # define LOAD _ REF ( ENV , VAR ) \

TEST DIFF:
diff - - git a / src / com / sun / jna / Library . java b / src / com / sun / jna / Library . java 
 index 6344a1f . . 621e4f3 100644 
 - - - a / src / com / sun / jna / Library . java 
 + + + b / src / com / sun / jna / Library . java 
 @ @ - 136 , 7 + 136 , 6 @ @ public interface Library { 
 private final Class interfaceClass ; 
 / / Library invocation options 
 private final Map options ; 
 - private FunctionMapper functionMapper ; 
 private final InvocationMapper invocationMapper ; 
 private final Map functions = new WeakHashMap ( ) ; 
 public Handler ( String libname , Class interfaceClass , Map options ) { 
 @ @ - 155 , 13 + 154 , 12 @ @ public interface Library { 
 options . put ( OPTION _ CALLING _ CONVENTION , 
 new Integer ( callingConvention ) ) ; 
 } 
 + if ( ! options . containsKey ( OPTION _ FUNCTION _ MAPPER ) ) { 
 + / / Passed - in map is itself the name map 
 + options . put ( OPTION _ FUNCTION _ MAPPER , new FunctionNameMap ( options ) ) ; 
 + } 
 this . options = options ; 
 this . nativeLibrary = NativeLibrary . getInstance ( libname , options ) ; 
 - functionMapper = ( FunctionMapper ) options . get ( OPTION _ FUNCTION _ MAPPER ) ; 
 - if ( functionMapper = = null ) { 
 - / / backward compatibility ; passed - in map is itself the name map 
 - functionMapper = new FunctionNameMap ( options ) ; 
 - } 
 invocationMapper = ( InvocationMapper ) options . get ( OPTION _ INVOCATION _ MAPPER ) ; 
 } 
 
 @ @ - 213 , 13 + 211 , 7 @ @ public interface Library { 
 } 
 if ( f . handler = = null ) { 
 / / Find the function to invoke 
 - String methodName = 
 - functionMapper . getFunctionName ( nativeLibrary , method ) ; 
 - if ( methodName = = null ) { 
 - / / Just in case the function mapper screwed up 
 - methodName = method . getName ( ) ; 
 - } 
 - f . function = nativeLibrary . getFunction ( methodName , method ) ; 
 + f . function = nativeLibrary . getFunction ( method . getName ( ) , method ) ; 
 f . options = new HashMap ( this . options ) ; 
 f . options . put ( Function . OPTION _ INVOKING _ METHOD , method ) ; 
 } 
 diff - - git a / src / com / sun / jna / NativeLibrary . java b / src / com / sun / jna / NativeLibrary . java 
 index 21fcceb . . 8aa6622 100644 
 - - - a / src / com / sun / jna / NativeLibrary . java 
 + + + b / src / com / sun / jna / NativeLibrary . java 
 @ @ - 68 , 6 + 68 , 7 @ @ public class NativeLibrary { 
 private final String libraryPath ; 
 private final Map functions = new HashMap ( ) ; 
 final int callFlags ; 
 + private String encoding ; 
 final Map options ; 
 
 private static final Map libraries = new HashMap ( ) ; 
 @ @ - 93 , 9 + 94 , 9 @ @ public class NativeLibrary { 
 ? ( ( Number ) option ) . intValue ( ) : Function . C _ CONVENTION ; 
 this . callFlags = callingConvention ; 
 this . options = options ; 
 - String encoding = ( String ) options . get ( Library . OPTION _ STRING _ ENCODING ) ; 
 - if ( encoding = = null ) { 
 - encoding = Native . getDefaultStringEncoding ( ) ; 
 + this . encoding = ( String ) options . get ( Library . OPTION _ STRING _ ENCODING ) ; 
 + if ( this . encoding = = null ) { 
 + this . encoding = Native . getDefaultStringEncoding ( ) ; 
 } 
 
 / / Special workaround for w32 kernel32 . GetLastError 
 @ @ - 422 , 12 + 423 , 19 @ @ public class NativeLibrary { 
 * function from the library . 
 * 
 * @ param 	 name 
 - * 	 	 	 Name of the native function to be linked with 
 + * 	 	 	 Name of the native function to be linked with . Uses a 
 + * 	 	 	 function mapper option if one was provided to 
 + * 	 	 	 transform the name . 
 * @ param 	 method 
 * 	 	 	 Method to which the native function is to be mapped 
 * @ throws UnsatisfiedLinkError if the function is not found 
 * / 
 Function getFunction ( String name , Method method ) { 
 + FunctionMapper mapper = ( FunctionMapper ) 
 + options . get ( Library . OPTION _ FUNCTION _ MAPPER ) ; 
 + if ( mapper ! = null ) { 
 + name = mapper . getFunctionName ( this , method ) ; 
 + } 
 int flags = this . callFlags ; 
 Class [ ] etypes = method . getExceptionTypes ( ) ; 
 for ( int i = 0 ; i < etypes . length ; i + + ) { 
 @ @ - 449 , 7 + 457 , 7 @ @ public class NativeLibrary { 
 * @ throws UnsatisfiedLinkError if the function is not found 
 * / 
 public Function getFunction ( String functionName , int callFlags ) { 
 - return getFunction ( functionName , callFlags , Native . getDefaultStringEncoding ( ) ) ; 
 + return getFunction ( functionName , callFlags , encoding ) ; 
 } 
 
 / * * 
 diff - - git a / test / com / sun / jna / CallbacksTest . java b / test / com / sun / jna / CallbacksTest . java 
 index 02448e1 . . fe7e630 100644 
 - - - a / test / com / sun / jna / CallbacksTest . java 
 + + + b / test / com / sun / jna / CallbacksTest . java 
 @ @ - 13 , 6 + 13 , 7 @ @ 
 package com . sun . jna ; 
 
 import java . io . ByteArrayOutputStream ; 
 + import java . io . File ; 
 import java . io . PrintStream ; 
 import java . lang . ref . WeakReference ; 
 import java . util . Arrays ; 
 @ @ - 36 , 7 + 37 , 7 @ @ import com . sun . jna . win32 . W32APIOptions ; 
 * @ author twall @ users . sf . net 
 * / 
 / / @ SuppressWarnings ( " unused " ) 
 - public class CallbacksTest extends TestCase { 
 + public class CallbacksTest extends TestCase implements Paths { 
 
 private static final String UNICODE = " [ \ u0444 ] " ; 
 
 @ @ - 1201 , 11 + 1202 , 19 @ @ public class CallbacksTest extends TestCase { 
 PointerByReference pref = new PointerByReference ( ) ; 
 int result = f . invokeInt ( new Object [ ] { new Integer ( GET _ MODULE _ HANDLE _ FROM _ ADDRESS ) , fp , pref } ) ; 
 assertTrue ( " GetModuleHandleEx ( fptr ) failed : " + Native . getLastError ( ) , result ! = 0 ) ; 
 + f = kernel32 . getFunction ( " GetModuleFileNameW " ) ; 
 + char [ ] buf = new char [ 1024 ] ; 
 + result = f . invokeInt ( new Object [ ] { pref . getValue ( ) , buf , buf . length } ) ; 
 + assertTrue ( " GetModuleFileName ( fptr ) failed : " + Native . getLastError ( ) , result ! = 0 ) ; 
 + 
 
 f = kernel32 . getFunction ( " GetModuleHandleW " ) ; 
 - Pointer handle = f . invokePointer ( new Object [ ] { " jnidispatch . dll " } ) ; 
 - assertTrue ( " GetModuleHandle ( \ " jnidispatch \ " ) failed : " + Native . getLastError ( ) , result ! = 0 ) ; 
 - assertNotNull ( " Could not get module handle for jnidispatch . dll " , handle ) ; 
 + / / XP needs full path to DLL ; win7 only needs " jnidispatch " 
 + File dispatch = new File ( CLASSES , " com / sun / jna / " + Platform . RESOURCE _ PREFIX + " / jnidispatch " ) ; 
 + String path = dispatch . getAbsolutePath ( ) ; 
 + Pointer handle = f . invokePointer ( new Object [ ] { path } ) ; 
 + assertTrue ( " GetModuleHandle ( \ " " + path + " \ " ) failed : " + Native . getLastError ( ) , result ! = 0 ) ; 
 + assertNotNull ( " Could not get module handle for " + path + " : " + Native . getLastError ( ) , handle ) ; 
 assertEquals ( " Wrong module HANDLE for DLL function pointer " , handle , pref . getValue ( ) ) ; 
 
 / / Check slot re - use

NEAREST DIFF:
diff - - git a / jnalib / dist / freebsd - i386 . jar b / jnalib / dist / freebsd - i386 . jar 
 index 6c8aec2 . . 7eea228 100644 
 Binary files a / jnalib / dist / freebsd - i386 . jar and b / jnalib / dist / freebsd - i386 . jar differ 
 diff - - git a / jnalib / native / dispatch . h b / jnalib / native / dispatch . h 
 index d1dc381 . . 4c5a20d 100644 
 - - - a / jnalib / native / dispatch . h 
 + + + b / jnalib / native / dispatch . h 
 @ @ - 47 , 8 + 47 , 12 @ @ typedef long word _ t ; 
 # define alloca _ alloca 
 # endif 
 # else 
 + # ifdef _ _ FreeBSD _ _ 
 + # include < stdlib . h > 
 + # else 
 # include < alloca . h > 
 # endif 
 + # endif 
 
 / * Convenience macros * / 
 # define LOAD _ REF ( ENV , VAR ) \
