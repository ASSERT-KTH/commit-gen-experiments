BLEU SCORE: 0.03772691894380681

TEST MSG: merge from upstream master
GENERATED MSG: Add encryption and decryption functions to Advapi32

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> old mode 100644 <nl> new mode 100755 <nl> index a73c961 . . fae7c2d <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 23 , 6 + 23 , 7 @ @ Features <nl> * [ # 365 ] ( https : / / github . com / twall / jna / pull / 365 ) : Added ` com . sun . jna . platform . win32 . Kernel32 . GetComputerNameEx ` support - [ @ lgoldstein ] ( https : / / github . com / lgoldstein ) . <nl> * [ # 368 ] ( https : / / github . com / twall / jna / pull / 368 ) : Added ` com . sun . jna . platform . win32 . Kernel32 . VirtualQueryEx ` , ` com . sun . jna . platform . win32 . WinNT . MEMORY _ BASIC _ INFORMATION ` and ` MEM _ COMMIT ` , ` MEM _ FREE ` , ` MEM _ RESERVE ` , ` MEM _ IMAGE ` , ` MEM _ MAPPED ` , ` MEM _ PRIVATE ` constants to ` com . sun . jna . platform . win32 . WinNT ` - [ @ apsk ] ( https : / / github . com / apsk ) . <nl> * Allow interoperation with JNI revision changes - [ @ twall ] ( https : / / github . com / twall ) . <nl> + * [ # 391 ] ( https : / / github . com / twall / jna / pull / 391 ) : Added ` EncryptFile ` , ` DecryptFile ` , ` FileEncryptionStatus ` , ` EncryptionDisable ` , ` OpenEncryptedFileRaw ` , ` ReadEncryptedFileRaw ` , ` WriteEncryptedFileRaw ` , and ` CloseEncryptedFileRaw ` to ` com . sun . jna . platform . win32 . Advapi32 ` with related ` Advapi32Util ` helpers - [ @ khalidq ] ( https : / / github . com / khalidq ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> @ @ - 36 , 6 + 37 , 8 @ @ Bug Fixes <nl> * Disable WebStart tests - [ @ twall ] ( https : / / github . com / twall ) . <nl> * Dispose all native resources when JNA ' s native library is unloaded - Paul Gr ü tter of signotec GmbH and [ @ twall ] ( https : / / github . com / twall ) . This fixes a number of seemingly random , sporadic crashes on windows . <nl> * Weakly hold registered Direct - mapped classes - [ @ twall ] ( https : / / github . com / twall ) . <nl> + * [ # 382 ] ( https : / / github . com / twall / jna / pull / 382 ) : Fixed memory allocation in ` com . sun . jna . platform . win32 . WTypes . LPWSTR ` and ` LPSTR ` constructors - [ @ junak - michal ] ( https : / / github . com / junak - michal ) . <nl> + * Fix publish doc links - [ @ bhamail ] ( https : / / github . com / bhamail ) . <nl> * [ # 388 ] ( https : / / github . com / twall / jna / issues / 388 ) : Ensure native library always opened with provided flags - [ @ zolyfarkas ] ( https : / / github . com / zolyfarkas ) . <nl> <nl> Release 4 . 1 <nl> diff - - git a / README . md b / README . md <nl> index 557b447 . . 7f412c0 100644 <nl> - - - a / README . md <nl> + + + b / README . md <nl> @ @ - 93 , 7 + 93 , 7 @ @ Using the Library <nl> * [ Platform Library ] ( https : / / github . com / twall / jna / blob / master / www / PlatformLibrary . md ) <nl> * [ Direct Method Mapping ] ( https : / / github . com / twall / jna / blob / master / www / DirectMapping . md ) ( Optimization ) <nl> * [ Frequently Asked Questions ( FAQ ) ] ( https : / / github . com / twall / jna / blob / master / www / FrequentlyAskedQuestions . md ) <nl> - * [ Avoiding Crashes ] ( http : / / twall . github . com / jna / 4 . 1 . 0 / javadoc / overview - summary . html # crash - protection ) <nl> + * [ Avoiding Crashes ] ( http : / / twall . github . com / jna / 4 . 1 . 0 / overview - summary . html # crash - protection ) <nl> <nl> Primary Documentation ( JavaDoc ) <nl> = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> diff - - git a / build . xml b / build . xml <nl> index 740e9f5 . . 61e18b2 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 371 , 6 + 371 , 10 @ @ com / sun / jna / win32 - x86 / jnidispatch . dll ; <nl> processor = x86 ; osname = win32 , <nl> com / sun / jna / win32 - x86 - 64 / jnidispatch . dll ; <nl> processor = x86 - 64 ; osname = win32 , <nl> + com / sun / jna / win32 - x86 / jnidispatch . dll ; <nl> + processor = x86 ; osname = win , <nl> + com / sun / jna / win32 - x86 - 64 / jnidispatch . dll ; <nl> + processor = x86 - 64 ; osname = win , <nl> com / sun / jna / w32ce - arm / jnidispatch . dll ; <nl> processor = arm ; osname = wince , <nl> <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> old mode 100644 <nl> new mode 100755 <nl> index d34c06d . . cb5556b <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java <nl> @ @ - 17 , 6 + 17 , 8 @ @ import com . sun . jna . Pointer ; <nl> import com . sun . jna . Structure ; <nl> import com . sun . jna . WString ; <nl> import com . sun . jna . platform . win32 . WinBase . SECURITY _ ATTRIBUTES ; <nl> + import com . sun . jna . platform . win32 . WinBase . FE _ EXPORT _ FUNC ; <nl> + import com . sun . jna . platform . win32 . WinBase . FE _ IMPORT _ FUNC ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLE ; <nl> import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; <nl> import com . sun . jna . platform . win32 . WinNT . PSID ; <nl> @ @ - 35 , 6 + 37 , 7 @ @ import com . sun . jna . win32 . W32APIOptions ; <nl> import static com . sun . jna . platform . win32 . WinDef . BOOLByReference ; <nl> import static com . sun . jna . platform . win32 . WinDef . DWORD ; <nl> import static com . sun . jna . platform . win32 . WinDef . DWORDByReference ; <nl> + import static com . sun . jna . platform . win32 . WinDef . ULONG ; <nl> import static com . sun . jna . platform . win32 . WinNT . GENERIC _ MAPPING ; <nl> import static com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; <nl> <nl> @ @ - 1558 , 4 + 1561 , 153 @ @ public interface Advapi32 extends StdCallLibrary { <nl> PRIVILEGE _ SET PrivilegeSet , <nl> DWORDByReference PrivilegeSetLength , <nl> DWORDByReference GrantedAccess , BOOLByReference AccessStatus ) ; <nl> + 	 <nl> + 	 / * * <nl> + 	 * Encrypts a file or directory . All data streams in a file are encrypted . All <nl> + 	 * new files created in an encrypted directory are encrypted . <nl> + 	 * <nl> + 	 * @ param lpFileName <nl> + 	 * The name of the file or directory to be encrypted . <nl> + 	 * @ return If the function succeeds , the return value is nonzero . If the <nl> + 	 * function fails , the return value is zero . To get extended error <nl> + 	 * information , call GetLastError . <nl> + 	 * / <nl> + 	 public boolean EncryptFile ( WString lpFileName ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Decrypts an encrypted file or directory . <nl> + 	 * <nl> + 	 * @ param lpFileName <nl> + 	 * The name of the file or directory to be decrypted . <nl> + 	 * @ param dwReserved <nl> + 	 * Reserved ; must be zero . <nl> + 	 * @ return If the function succeeds , the return value is nonzero . If the <nl> + 	 * function fails , the return value is zero . To get extended error <nl> + 	 * information , call GetLastError . <nl> + 	 * / <nl> + 	 public boolean DecryptFile ( WString lpFileName , DWORD dwReserved ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Retrieves the encryption status of the specified file . <nl> + 	 * <nl> + 	 * @ param lpFileName <nl> + 	 * The name of the file . <nl> + 	 * @ param lpStatus <nl> + 	 * A pointer to a variable that receives the encryption status of the <nl> + 	 * file . <nl> + 	 * @ return If the function succeeds , the return value is nonzero . If the <nl> + 	 * function fails , the return value is zero . To get extended error <nl> + 	 * information , call GetLastError . <nl> + 	 * / <nl> + 	 public boolean FileEncryptionStatus ( WString lpFileName , DWORDByReference lpStatus ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Disables or enables encryption of the specified directory and the files in <nl> + 	 * it . It does not affect encryption of subdirectories below the indicated <nl> + 	 * directory . <nl> + 	 * <nl> + 	 * @ param DirPath <nl> + 	 * The name of the directory for which to enable or disable <nl> + 	 * encryption . <nl> + 	 * @ param Disable <nl> + 	 * Indicates whether to disable encryption ( TRUE ) or enable it <nl> + 	 * ( FALSE ) . <nl> + 	 * @ return If the function succeeds , the return value is nonzero . If the <nl> + 	 * function fails , the return value is zero . To get extended error <nl> + 	 * information , call GetLastError . <nl> + 	 * / <nl> + 	 public boolean EncryptionDisable ( WString DirPath , boolean Disable ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Opens an encrypted file in order to backup ( export ) or restore ( import ) the <nl> + 	 * file . This is one of a group of Encrypted File System ( EFS ) functions that <nl> + 	 * is intended to implement backup and restore functionality , while <nl> + 	 * maintaining files in their encrypted state . <nl> + 	 * <nl> + 	 * @ param lpFileName <nl> + 	 * The name of the file to be opened . The string must consist of <nl> + 	 * characters from the Windows character set . <nl> + 	 * @ param ulFlags <nl> + 	 * The operation to be performed . <nl> + 	 * @ param pvContext <nl> + 	 * The address of a context block that must be presented in subsequent <nl> + 	 * calls to ReadEncryptedFileRaw , WriteEncryptedFileRaw , or <nl> + 	 * CloseEncryptedFileRaw . Do not modify it . <nl> + 	 * @ return If the function succeeds , it returns ERROR _ SUCCESS . If the function <nl> + 	 * fails , it returns a nonzero error code defined in WinError . h . You can use <nl> + 	 * FormatMessage with the FORMAT _ MESSAGE _ FROM _ SYSTEM flag to get a generic <nl> + 	 * text description of the error . <nl> + 	 * / <nl> + 	 public int OpenEncryptedFileRaw ( WString lpFileName , ULONG ulFlags , <nl> + PointerByReference pvContext ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Backs up ( export ) encrypted files . This is one of a group of Encrypted File <nl> + 	 * System ( EFS ) functions that is intended to implement backup and restore <nl> + 	 * functionality , while maintaining files in their encrypted state . <nl> + 	 * <nl> + 	 * @ param pfExportCallback <nl> + 	 * A pointer to the export callback function . The system calls the <nl> + 	 * callback function multiple times , each time passing a block of the <nl> + 	 * file ' s data to the callback function until the entire file has been <nl> + 	 * read . For more information , see ExportCallback . <nl> + 	 * @ param pvCallbackContext <nl> + 	 * A pointer to an application - defined and allocated context block . <nl> + 	 * The system passes this pointer to the callback function as a <nl> + 	 * parameter so that the callback function can have access to <nl> + 	 * application - specific data . This can be a structure and can contain <nl> + 	 * any data the application needs , such as the handle to the file that <nl> + 	 * will contain the backup copy of the encrypted file . <nl> + 	 * @ param pvContext <nl> + 	 * A pointer to a system - defined context block . The context block is <nl> + 	 * returned by the OpenEncryptedFileRaw function . Do not modify it . <nl> + 	 * @ return If the function succeeds , the return value is ERROR _ SUCCESS . If the <nl> + 	 * function fails , it returns a nonzero error code defined in WinError . h . You <nl> + 	 * can use FormatMessage with the FORMAT _ MESSAGE _ FROM _ SYSTEM flag to get a <nl> + 	 * generic text description of the error . <nl> + 	 * / <nl> + 	 public int ReadEncryptedFileRaw ( FE _ EXPORT _ FUNC pfExportCallback , <nl> + Pointer pvCallbackContext , Pointer pvContext ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Restores ( import ) encrypted files . This is one of a group of Encrypted File <nl> + 	 * System ( EFS ) functions that is intended to implement backup and restore <nl> + 	 * functionality , while maintaining files in . <nl> + 	 * <nl> + 	 * @ param pfImportCallback <nl> + 	 * A pointer to the import callback function . The system calls the <nl> + 	 * callback function multiple times , each time passing a buffer that <nl> + 	 * will be filled by the callback function with a portion of backed - up <nl> + 	 * file ' s data . When the callback function signals that the entire <nl> + 	 * file has been processed , it tells the system that the restore <nl> + 	 * operation is finished . For more information , see ImportCallback . <nl> + 	 * @ param pvCallbackContext <nl> + 	 * A pointer to an application - defined and allocated context block . <nl> + 	 * The system passes this pointer to the callback function as a <nl> + 	 * parameter so that the callback function can have access to <nl> + 	 * application - specific data . This can be a structure and can contain <nl> + 	 * any data the application needs , such as the handle to the file that <nl> + 	 * will contain the backup copy of the encrypted file . <nl> + 	 * @ param pvContext <nl> + 	 * A pointer to a system - defined context block . The context block is <nl> + 	 * returned by the OpenEncryptedFileRaw function . Do not modify it . <nl> + 	 * @ return If the function succeeds , the return value is ERROR _ SUCCESS . If the <nl> + 	 * function fails , it returns a nonzero error code defined in WinError . h . You <nl> + 	 * can use FormatMessage with the FORMAT _ MESSAGE _ FROM _ SYSTEM flag to get a <nl> + 	 * generic text description of the error . <nl> + 	 * / <nl> + 	 public int WriteEncryptedFileRaw ( FE _ IMPORT _ FUNC pfImportCallback , <nl> + Pointer pvCallbackContext , Pointer pvContext ) ; <nl> + <nl> + 	 / * * <nl> + 	 * Closes an encrypted file after a backup or restore operation , and frees <nl> + 	 * associated system resources . This is one of a group of Encrypted File <nl> + 	 * System ( EFS ) functions that is intended to implement backup and restore <nl> + 	 * functionality , while maintaining files in their encrypted state . <nl> + 	 * <nl> + 	 * @ param pvContext <nl> + 	 * A pointer to a system - defined context block . The <nl> + 	 * OpenEncryptedFileRaw function returns the context block . <nl> + 	 * / <nl> + 	 public void CloseEncryptedFileRaw ( Pointer pvContext ) ; <nl> } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> old mode 100644 <nl> new mode 100755 <nl> index c28e348 . . 6b08e38 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java <nl> @ @ - 12 , 7 + 12 , 9 @ @ <nl> * / <nl> package com . sun . jna . platform . win32 ; <nl> <nl> + import java . io . ByteArrayOutputStream ; <nl> import java . io . File ; <nl> + import java . io . IOException ; <nl> import java . util . ArrayList ; <nl> import java . util . HashMap ; <nl> import java . util . Iterator ; <nl> @ @ - 37 , 6 + 39 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; <nl> import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEY ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> + import com . sun . jna . ptr . ByteByReference ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> import com . sun . jna . ptr . LongByReference ; <nl> import com . sun . jna . ptr . PointerByReference ; <nl> @ @ - 2185 , 4 + 2188 , 159 @ @ public abstract class Advapi32Util { <nl> <nl> return hasAccess ; <nl> } <nl> + 	 <nl> + / * * <nl> + * Encrypts a file or directory . <nl> + * <nl> + * @ param file <nl> + * The file or directory to encrypt . <nl> + * / <nl> + public static void encryptFile ( File file ) { <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + if ( ! Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Decrypts an encrypted file or directory . <nl> + * <nl> + * @ param file <nl> + * The file or directory to decrypt . <nl> + * / <nl> + public static void decryptFile ( File file ) { <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + if ( ! Advapi32 . INSTANCE . DecryptFile ( lpFileName , new DWORD ( 0 ) ) ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Checks the encryption status of a file . <nl> + * <nl> + * @ param file <nl> + * The file to check the status for . <nl> + * @ return The status of the file . <nl> + * / <nl> + public static int fileEncryptionStatus ( File file ) { <nl> + DWORDByReference status = new DWORDByReference ( ) ; <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + if ( ! Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , status ) ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + return status . getValue ( ) . intValue ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Disables or enables encryption of the specified directory and the files in <nl> + * it . <nl> + * <nl> + * @ param directory <nl> + * The directory for which to enable or disable encryption . <nl> + * @ param disable <nl> + * TRUE to disable encryption . FALSE to enable it . <nl> + * / <nl> + public static void disableEncryption ( File directory , boolean disable ) { <nl> + WString dirPath = new WString ( directory . getAbsolutePath ( ) ) ; <nl> + if ( ! Advapi32 . INSTANCE . EncryptionDisable ( dirPath , disable ) ) { <nl> + throw new Win32Exception ( Native . getLastError ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Backup an encrypted file or folder without decrypting it . A file named <nl> + * " bar / sample . text " will be backed - up to " destDir / sample . text " . A directory <nl> + * named " bar " will be backed - up to " destDir / bar " . This method is NOT <nl> + * recursive . If you have an encrypted directory with encrypted files , this <nl> + * method must be called once for the directory , and once for each encrypted <nl> + * file to be backed - up . <nl> + * <nl> + * @ param src <nl> + * The encrypted file or directory to backup . <nl> + * @ param destDir <nl> + * The directory where the backup will be saved . <nl> + * / <nl> + public static void backupEncryptedFile ( File src , File destDir ) { <nl> + if ( ! destDir . isDirectory ( ) ) { <nl> + throw new IllegalArgumentException ( " destDir must be a directory . " ) ; <nl> + } <nl> + <nl> + ULONG readFlag = new ULONG ( 0 ) ; / / Open the file for export ( backup ) <nl> + ULONG writeFlag = new ULONG ( CREATE _ FOR _ IMPORT ) ; / / Import ( restore ) file <nl> + <nl> + if ( src . isDirectory ( ) ) { <nl> + writeFlag . setValue ( CREATE _ FOR _ IMPORT | CREATE _ FOR _ DIR ) ; <nl> + } <nl> + <nl> + / / open encrypted file for export <nl> + WString srcFileName = new WString ( src . getAbsolutePath ( ) ) ; <nl> + PointerByReference pvContext = new PointerByReference ( ) ; <nl> + if ( Advapi32 . INSTANCE . OpenEncryptedFileRaw ( srcFileName , readFlag , <nl> + pvContext ) ! = W32Errors . ERROR _ SUCCESS ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + <nl> + / / read encrypted file <nl> + final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; <nl> + FE _ EXPORT _ FUNC pfExportCallback = new FE _ EXPORT _ FUNC ( ) { <nl> + @ Override <nl> + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , <nl> + ULONG ulLength ) { <nl> + byte [ ] arr = pbData . getPointer ( ) . getByteArray ( 0 , ulLength . intValue ( ) ) ; <nl> + try { <nl> + outputStream . write ( arr ) ; <nl> + } catch ( IOException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; <nl> + } <nl> + } ; <nl> + <nl> + if ( Advapi32 . INSTANCE . ReadEncryptedFileRaw ( pfExportCallback , null , <nl> + pvContext . getValue ( ) ) ! = W32Errors . ERROR _ SUCCESS ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + <nl> + / / close <nl> + try { <nl> + outputStream . close ( ) ; <nl> + } catch ( IOException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; <nl> + <nl> + / / open file for import <nl> + WString destFileName = new WString ( destDir . getAbsolutePath ( ) + File . separator <nl> + + src . getName ( ) ) ; <nl> + pvContext = new PointerByReference ( ) ; <nl> + if ( Advapi32 . INSTANCE . OpenEncryptedFileRaw ( destFileName , writeFlag , <nl> + pvContext ) ! = W32Errors . ERROR _ SUCCESS ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + <nl> + / / write encrypted file <nl> + final IntByReference elementsReadWrapper = new IntByReference ( 0 ) ; <nl> + FE _ IMPORT _ FUNC pfImportCallback = new FE _ IMPORT _ FUNC ( ) { <nl> + @ Override <nl> + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , <nl> + ULONGByReference ulLength ) { <nl> + int elementsRead = elementsReadWrapper . getValue ( ) ; <nl> + int remainingElements = outputStream . size ( ) - elementsRead ; <nl> + int length = Math . min ( remainingElements , ulLength . getValue ( ) . intValue ( ) ) ; <nl> + pbData . getPointer ( ) . write ( 0 , outputStream . toByteArray ( ) , elementsRead , <nl> + length ) ; <nl> + elementsReadWrapper . setValue ( elementsRead + length ) ; <nl> + ulLength . setValue ( new ULONG ( length ) ) ; <nl> + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; <nl> + } <nl> + } ; <nl> + <nl> + if ( Advapi32 . INSTANCE . WriteEncryptedFileRaw ( pfImportCallback , null , <nl> + pvContext . getValue ( ) ) ! = W32Errors . ERROR _ SUCCESS ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + <nl> + / / close <nl> + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; <nl> + } <nl> } <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java b / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java <nl> index e997f95 . . c487312 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java <nl> @ @ - 135 , 7 + 135 , 7 @ @ public interface WTypes { <nl> } <nl> <nl> public LPSTR ( String value ) { <nl> - this ( ) ; <nl> + this ( new Memory ( ( value . length ( ) + 1L ) * Native . WCHAR _ SIZE ) ) ; <nl> this . setValue ( value ) ; <nl> } <nl> <nl> @ @ - 172 , 7 + 172 , 7 @ @ public interface WTypes { <nl> } <nl> <nl> public LPWSTR ( String value ) { <nl> - this ( ) ; <nl> + this ( new Memory ( ( value . length ( ) + 1L ) * Native . WCHAR _ SIZE ) ) ; <nl> this . setValue ( value ) ; <nl> } <nl> <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinBase . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinBase . java <nl> old mode 100644 <nl> new mode 100755 <nl> index 4f32e37 . . 80a936e <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinBase . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinBase . java <nl> @ @ - 153 , 6 + 153 , 23 @ @ public interface WinBase extends StdCallLibrary , WinDef , BaseTSD { <nl> int CREATE _ DEFAULT _ ERROR _ MODE = 0x04000000 ; <nl> int CREATE _ NO _ WINDOW = 0x08000000 ; <nl> <nl> + / * File encryption status * / <nl> + int FILE _ ENCRYPTABLE = 0 ; <nl> + int FILE _ IS _ ENCRYPTED = 1 ; <nl> + int FILE _ SYSTEM _ ATTR = 2 ; <nl> + int FILE _ ROOT _ DIR = 3 ; <nl> + int FILE _ SYSTEM _ DIR = 4 ; <nl> + int FILE _ UNKNOWN = 5 ; <nl> + int FILE _ SYSTEM _ NOT _ SUPPORT = 6 ; <nl> + int FILE _ USER _ DISALLOWED = 7 ; <nl> + int FILE _ READ _ ONLY = 8 ; <nl> + int FILE _ DIR _ DISALOWED = 9 ; <nl> + <nl> + / * Open encrypted files raw flags * / <nl> + int CREATE _ FOR _ IMPORT = 1 ; <nl> + int CREATE _ FOR _ DIR = 2 ; <nl> + int OVERWRITE _ HIDDEN = 4 ; <nl> + <nl> / * Invalid return values * / <nl> int INVALID _ FILE _ SIZE = 0xFFFFFFFF ; <nl> int INVALID _ SET _ FILE _ POINTER = 0xFFFFFFFF ; <nl> @ @ - 986 , 4 + 1003 , 28 @ @ public interface WinBase extends StdCallLibrary , WinDef , BaseTSD { <nl> * / <nl> int ComputerNameMax = 8 ; <nl> } <nl> + <nl> + / * * <nl> + * An application - defined callback function used with ReadEncryptedFileRaw . <nl> + * The system calls ExportCallback one or more times , each time with a block <nl> + * of the encrypted file ' s data , until it has received all of the file data . <nl> + * ExportCallback writes the encrypted file ' s data to another storage media , <nl> + * usually for purposes of backing up the file . <nl> + * / <nl> + public interface FE _ EXPORT _ FUNC extends Callback { <nl> + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , <nl> + ULONG ulLength ) ; <nl> + } <nl> + <nl> + / * * <nl> + * An application - defined callback function used with WriteEncryptedFileRaw . <nl> + * The system calls ImportCallback one or more times , each time to retrieve a <nl> + * portion of a backup file ' s data . ImportCallback reads the data from a <nl> + * backup file sequentially and restores the data , and the system continues <nl> + * calling it until it has read all of the backup file data . <nl> + * / <nl> + public interface FE _ IMPORT _ FUNC extends Callback { <nl> + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , <nl> + ULONGByReference ulLength ) ; <nl> + } <nl> } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> old mode 100644 <nl> new mode 100755 <nl> index c144ee1 . . c09dbee <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java <nl> @ @ - 12 , 7 + 12 , 10 @ @ <nl> * / <nl> package com . sun . jna . platform . win32 ; <nl> <nl> + import java . io . ByteArrayOutputStream ; <nl> import java . io . File ; <nl> + import java . io . FileWriter ; <nl> + import java . io . IOException ; <nl> <nl> import junit . framework . TestCase ; <nl> <nl> @ @ - 38 , 6 + 41 , 7 @ @ import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> import com . sun . jna . platform . win32 . Winsvc . SC _ HANDLE ; <nl> import com . sun . jna . platform . win32 . Winsvc . SC _ STATUS _ TYPE ; <nl> import com . sun . jna . platform . win32 . Winsvc . SERVICE _ STATUS _ PROCESS ; <nl> + import com . sun . jna . ptr . ByteByReference ; <nl> import com . sun . jna . ptr . IntByReference ; <nl> import com . sun . jna . ptr . PointerByReference ; <nl> <nl> @ @ - 906 , 4 + 910 , 225 @ @ public class Advapi32Test extends TestCase { <nl> assertEquals ( WinError . ERROR _ INVALID _ HANDLE , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> } <nl> <nl> + public void testEncryptFile ( ) throws Exception { <nl> + / / create a temp file <nl> + File file = createTempFile ( ) ; <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + <nl> + / / encrypt a read only file <nl> + file . setWritable ( false ) ; <nl> + assertFalse ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; <nl> + assertEquals ( WinError . ERROR _ FILE _ READ _ ONLY , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + <nl> + / / encrypt a writable file <nl> + file . setWritable ( true ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; <nl> + <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + public void testDecryptFile ( ) throws Exception { <nl> + / / create an encrypted file <nl> + File file = createTempFile ( ) ; <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; <nl> + <nl> + / / decrypt a read only file <nl> + file . setWritable ( false ) ; <nl> + assertFalse ( Advapi32 . INSTANCE . DecryptFile ( lpFileName , new DWORD ( 0 ) ) ) ; <nl> + assertEquals ( WinError . ERROR _ FILE _ READ _ ONLY , Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + <nl> + / / decrypt <nl> + file . setWritable ( true ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . DecryptFile ( lpFileName , new DWORD ( 0 ) ) ) ; <nl> + <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + public void testFileEncryptionStatus ( ) throws Exception { <nl> + DWORDByReference lpStatus = new DWORDByReference ( ) ; <nl> + <nl> + / / create a temp file <nl> + File file = createTempFile ( ) ; <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + <nl> + / / unencrypted file <nl> + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , lpStatus ) ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , lpStatus . getValue ( ) . intValue ( ) ) ; <nl> + <nl> + / / read only file <nl> + file . setWritable ( false ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , lpStatus ) ) ; <nl> + assertEquals ( FILE _ READ _ ONLY , lpStatus . getValue ( ) . intValue ( ) ) ; <nl> + <nl> + / / encrypted file <nl> + file . setWritable ( true ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , lpStatus ) ) ; <nl> + assertEquals ( FILE _ IS _ ENCRYPTED , lpStatus . getValue ( ) . intValue ( ) ) ; <nl> + <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + public void testEncryptionDisable ( ) throws Exception { <nl> + DWORDByReference lpStatus = new DWORDByReference ( ) ; <nl> + <nl> + / / create a temp dir <nl> + String filePath = System . getProperty ( " java . io . tmpdir " ) + File . separator + <nl> + System . nanoTime ( ) ; <nl> + WString DirPath = new WString ( filePath ) ; <nl> + File dir = new File ( filePath ) ; <nl> + dir . mkdir ( ) ; <nl> + <nl> + / / check status <nl> + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( DirPath , lpStatus ) ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , lpStatus . getValue ( ) . intValue ( ) ) ; <nl> + <nl> + / / disable encryption <nl> + assertTrue ( Advapi32 . INSTANCE . EncryptionDisable ( DirPath , true ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( DirPath , lpStatus ) ) ; <nl> + assertEquals ( FILE _ DIR _ DISALOWED , lpStatus . getValue ( ) . intValue ( ) ) ; <nl> + <nl> + / / enable encryption <nl> + assertTrue ( Advapi32 . INSTANCE . EncryptionDisable ( DirPath , false ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( DirPath , lpStatus ) ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , lpStatus . getValue ( ) . intValue ( ) ) ; <nl> + <nl> + / / clean up <nl> + for ( File file : dir . listFiles ( ) ) { <nl> + file . delete ( ) ; <nl> + } <nl> + dir . delete ( ) ; <nl> + } <nl> + <nl> + public void testOpenEncryptedFileRaw ( ) throws Exception { <nl> + / / create an encrypted file <nl> + File file = createTempFile ( ) ; <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; <nl> + <nl> + / / open file for export <nl> + ULONG ulFlags = new ULONG ( 0 ) ; <nl> + PointerByReference pvContext = new PointerByReference ( ) ; <nl> + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . OpenEncryptedFileRaw ( <nl> + lpFileName , ulFlags , pvContext ) ) ; <nl> + <nl> + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + public void testReadEncryptedFileRaw ( ) throws Exception { <nl> + / / create an encrypted file <nl> + File file = createTempFile ( ) ; <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; <nl> + <nl> + / / open file for export <nl> + ULONG ulFlags = new ULONG ( 0 ) ; <nl> + PointerByReference pvContext = new PointerByReference ( ) ; <nl> + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . OpenEncryptedFileRaw ( <nl> + lpFileName , ulFlags , pvContext ) ) ; <nl> + <nl> + / / read encrypted file <nl> + final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; <nl> + FE _ EXPORT _ FUNC pfExportCallback = new FE _ EXPORT _ FUNC ( ) { <nl> + @ Override <nl> + public DWORD callback ( ByteByReference pbData , Pointer <nl> + pvCallbackContext , ULONG ulLength ) { <nl> + byte [ ] arr = pbData . getPointer ( ) . getByteArray ( 0 , ulLength . intValue ( ) ) ; <nl> + try { <nl> + outputStream . write ( arr ) ; <nl> + } catch ( IOException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; <nl> + } <nl> + } ; <nl> + <nl> + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . ReadEncryptedFileRaw ( <nl> + pfExportCallback , null , pvContext . getValue ( ) ) ) ; <nl> + outputStream . close ( ) ; <nl> + <nl> + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + public void testWriteEncryptedFileRaw ( ) throws Exception { <nl> + / / create an encrypted file <nl> + File file = createTempFile ( ) ; <nl> + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; <nl> + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; <nl> + <nl> + / / open file for export <nl> + ULONG ulFlags = new ULONG ( 0 ) ; <nl> + PointerByReference pvContext = new PointerByReference ( ) ; <nl> + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . OpenEncryptedFileRaw ( <nl> + lpFileName , ulFlags , pvContext ) ) ; <nl> + <nl> + / / read encrypted file <nl> + final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; <nl> + FE _ EXPORT _ FUNC pfExportCallback = new FE _ EXPORT _ FUNC ( ) { <nl> + @ Override <nl> + public DWORD callback ( ByteByReference pbData , Pointer <nl> + pvCallbackContext , ULONG ulLength ) { <nl> + byte [ ] arr = pbData . getPointer ( ) . getByteArray ( 0 , ulLength . intValue ( ) ) ; <nl> + try { <nl> + outputStream . write ( arr ) ; <nl> + } catch ( IOException e ) { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; <nl> + } <nl> + } ; <nl> + <nl> + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . ReadEncryptedFileRaw ( <nl> + pfExportCallback , null , pvContext . getValue ( ) ) ) ; <nl> + outputStream . close ( ) ; <nl> + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; <nl> + <nl> + / / open file for import <nl> + WString lbFileName2 = new WString ( System . getProperty ( " java . io . tmpdir " ) + <nl> + File . separator + " backup - " + file . getName ( ) ) ; <nl> + ULONG ulFlags2 = new ULONG ( CREATE _ FOR _ IMPORT ) ; <nl> + PointerByReference pvContext2 = new PointerByReference ( ) ; <nl> + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . OpenEncryptedFileRaw ( <nl> + lbFileName2 , ulFlags2 , pvContext2 ) ) ; <nl> + <nl> + / / write encrypted file <nl> + final IntByReference elementsReadWrapper = new IntByReference ( 0 ) ; <nl> + FE _ IMPORT _ FUNC pfImportCallback = new FE _ IMPORT _ FUNC ( ) { <nl> + @ Override <nl> + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , <nl> + ULONGByReference ulLength ) { <nl> + int elementsRead = elementsReadWrapper . getValue ( ) ; <nl> + int remainingElements = outputStream . size ( ) - elementsRead ; <nl> + int length = Math . min ( remainingElements , ulLength . getValue ( ) . intValue ( ) ) ; <nl> + pbData . getPointer ( ) . write ( 0 , outputStream . toByteArray ( ) , elementsRead , <nl> + length ) ; <nl> + elementsReadWrapper . setValue ( elementsRead + length ) ; <nl> + ulLength . setValue ( new ULONG ( length ) ) ; <nl> + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; <nl> + } <nl> + } ; <nl> + <nl> + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . WriteEncryptedFileRaw ( <nl> + pfImportCallback , null , pvContext2 . getValue ( ) ) ) ; <nl> + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext2 . getValue ( ) ) ; <nl> + <nl> + file . delete ( ) ; <nl> + new File ( lbFileName2 . toString ( ) ) . delete ( ) ; <nl> + } <nl> + <nl> + private File createTempFile ( ) throws Exception { <nl> + String filePath = System . getProperty ( " java . io . tmpdir " ) + System . nanoTime ( ) <nl> + + " . text " ; <nl> + File file = new File ( filePath ) ; <nl> + file . createNewFile ( ) ; <nl> + FileWriter fileWriter = new FileWriter ( file ) ; <nl> + for ( int i = 0 ; i < 1000 ; i + + ) { <nl> + fileWriter . write ( " Sample text " + i + System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> + fileWriter . close ( ) ; <nl> + return file ; <nl> + } <nl> } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java <nl> old mode 100644 <nl> new mode 100755 <nl> index 835c409 . . c8eb531 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java <nl> @ @ - 13 , 6 + 13 , 7 @ @ <nl> package com . sun . jna . platform . win32 ; <nl> <nl> import java . io . File ; <nl> + import java . io . FileWriter ; <nl> import java . util . Map ; <nl> import java . util . TreeMap ; <nl> <nl> @ @ - 30 , 6 + 31 , 8 @ @ import com . sun . jna . platform . win32 . WinNT . WELL _ KNOWN _ SID _ TYPE ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEY ; <nl> import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; <nl> <nl> + import static com . sun . jna . platform . win32 . WinBase . * ; <nl> + <nl> / * * <nl> * @ author dblock [ at ] dblock [ dot ] org <nl> * / <nl> @ @ - 483 , 4 + 486 , 89 @ @ public class Advapi32UtilTest extends TestCase { <nl> String block = Advapi32Util . getEnvironmentBlock ( mockEnvironment ) ; <nl> assertEquals ( " Environment block must comprise key = value pairs separated by NUL characters " , expected , block ) ; <nl> } <nl> + 	 <nl> + public void testEncryptFile ( ) throws Exception { <nl> + File file = createTempFile ( ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( file ) ) ; <nl> + Advapi32Util . encryptFile ( file ) ; <nl> + assertEquals ( FILE _ IS _ ENCRYPTED , Advapi32Util . fileEncryptionStatus ( file ) ) ; <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + public void testDecryptFile ( ) throws Exception { <nl> + File file = createTempFile ( ) ; <nl> + Advapi32Util . encryptFile ( file ) ; <nl> + assertEquals ( FILE _ IS _ ENCRYPTED , Advapi32Util . fileEncryptionStatus ( file ) ) ; <nl> + Advapi32Util . decryptFile ( file ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( file ) ) ; <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + public void testDisableEncryption ( ) throws Exception { <nl> + File dir = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator <nl> + + System . nanoTime ( ) ) ; <nl> + dir . mkdir ( ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( dir ) ) ; <nl> + Advapi32Util . disableEncryption ( dir , true ) ; <nl> + assertEquals ( FILE _ DIR _ DISALOWED , Advapi32Util . fileEncryptionStatus ( dir ) ) ; <nl> + Advapi32Util . disableEncryption ( dir , false ) ; <nl> + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( dir ) ) ; <nl> + for ( File file : dir . listFiles ( ) ) { <nl> + file . delete ( ) ; <nl> + } <nl> + dir . delete ( ) ; <nl> + } <nl> + <nl> + public void testBackupEncryptedFile ( ) throws Exception { <nl> + / / backup an encrypted file <nl> + File srcFile = createTempFile ( ) ; <nl> + Advapi32Util . encryptFile ( srcFile ) ; <nl> + File dest = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator <nl> + + " backup " + System . nanoTime ( ) ) ; <nl> + dest . mkdir ( ) ; <nl> + <nl> + Advapi32Util . backupEncryptedFile ( srcFile , dest ) ; <nl> + <nl> + / / simple check to see if a backup file exist <nl> + File backupFile = new File ( dest . getAbsolutePath ( ) + File . separator + <nl> + srcFile . getName ( ) ) ; <nl> + assertTrue ( backupFile . exists ( ) ) ; <nl> + assertEquals ( srcFile . length ( ) , backupFile . length ( ) ) ; <nl> + <nl> + / / backup an encrypted directory <nl> + File srcDir = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator <nl> + + System . nanoTime ( ) ) ; <nl> + srcDir . mkdir ( ) ; <nl> + Advapi32Util . encryptFile ( srcDir ) ; <nl> + <nl> + Advapi32Util . backupEncryptedFile ( srcDir , dest ) ; <nl> + <nl> + / / Check to see if a backup directory exist <nl> + File backupDir = new File ( dest . getAbsolutePath ( ) + File . separator + srcDir . getName ( ) ) ; <nl> + assertTrue ( backupDir . exists ( ) ) ; <nl> + <nl> + / / clean up <nl> + srcFile . delete ( ) ; <nl> + for ( File file : srcDir . listFiles ( ) ) { <nl> + file . delete ( ) ; <nl> + } <nl> + srcDir . delete ( ) ; <nl> + for ( File file : dest . listFiles ( ) ) { <nl> + file . delete ( ) ; <nl> + } <nl> + dest . delete ( ) ; <nl> + } <nl> + <nl> + private File createTempFile ( ) throws Exception { <nl> + String filePath = System . getProperty ( " java . io . tmpdir " ) + System . nanoTime ( ) <nl> + + " . text " ; <nl> + File file = new File ( filePath ) ; <nl> + file . createNewFile ( ) ; <nl> + FileWriter fileWriter = new FileWriter ( file ) ; <nl> + for ( int i = 0 ; i < 1000 ; i + + ) { <nl> + fileWriter . write ( " Sample text " + i + System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> + fileWriter . close ( ) ; <nl> + return file ; <nl> + } <nl> } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / WTypesTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / WTypesTest . java <nl> new file mode 100644 <nl> index 0000000 . . cf01c21 <nl> - - - / dev / null <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / WTypesTest . java <nl> @ @ - 0 , 0 + 1 , 60 @ @ <nl> + / * Copyright ( c ) 2007 - 2014 Timothy Wall , All Rights Reserved <nl> + * <nl> + * This library is free software ; you can redistribute it and / or <nl> + * modify it under the terms of the GNU Lesser General Public <nl> + * License as published by the Free Software Foundation ; either <nl> + * version 2 . 1 of the License , or ( at your option ) any later version . <nl> + * <nl> + * This library is distributed in the hope that it will be useful , <nl> + * but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + * Lesser General Public License for more details . <nl> + * / <nl> + package com . sun . jna . platform . win32 ; <nl> + <nl> + import com . sun . jna . Memory ; <nl> + import com . sun . jna . Native ; <nl> + import com . sun . jna . Pointer ; <nl> + import junit . framework . TestCase ; <nl> + <nl> + public class WTypesTest extends TestCase { <nl> + <nl> + private static final String TEST _ STRING = " input " ; <nl> + <nl> + private static final Pointer TEST _ POINTER = new Memory ( ( TEST _ STRING . length ( ) + 1L ) * Native . WCHAR _ SIZE ) ; <nl> + <nl> + static { <nl> + TEST _ POINTER . setWideString ( 0 , TEST _ STRING ) ; <nl> + } <nl> + <nl> + public void testLPOLESTRConstruction ( ) { <nl> + WTypes . LPOLESTR fromString = new WTypes . LPOLESTR ( TEST _ STRING ) ; <nl> + assertEquals ( fromString . getValue ( ) , TEST _ STRING ) ; <nl> + WTypes . LPOLESTR empty = new WTypes . LPOLESTR ( ) ; <nl> + assertNull ( empty . getValue ( ) ) ; <nl> + WTypes . LPOLESTR fromPointer = new WTypes . LPOLESTR ( TEST _ POINTER ) ; <nl> + assertEquals ( fromPointer . getValue ( ) , TEST _ STRING ) ; <nl> + } <nl> + <nl> + public void testLPSTRConstruction ( ) { <nl> + WTypes . LPSTR instance = new WTypes . LPSTR ( TEST _ STRING ) ; <nl> + assertEquals ( instance . getValue ( ) , TEST _ STRING ) ; <nl> + WTypes . LPSTR empty = new WTypes . LPSTR ( ) ; <nl> + assertNull ( empty . getValue ( ) ) ; <nl> + WTypes . LPSTR fromPointer = new WTypes . LPSTR ( TEST _ POINTER ) ; <nl> + assertEquals ( fromPointer . getValue ( ) , TEST _ STRING ) ; <nl> + } <nl> + <nl> + public void testLPWSTRConstruction ( ) { <nl> + WTypes . LPWSTR instance = new WTypes . LPWSTR ( TEST _ STRING ) ; <nl> + assertEquals ( instance . getValue ( ) , TEST _ STRING ) ; <nl> + WTypes . LPWSTR empty = new WTypes . LPWSTR ( ) ; <nl> + assertNull ( empty . getValue ( ) ) ; <nl> + WTypes . LPWSTR fromPointer = new WTypes . LPWSTR ( TEST _ POINTER ) ; <nl> + assertEquals ( fromPointer . getValue ( ) , TEST _ STRING ) ; <nl> + } <nl> + <nl> + public static void main ( String [ ] args ) { <nl> + junit . textui . TestRunner . run ( WTypesTest . class ) ; <nl> + } <nl> + } <nl> diff - - git a / www / PublishingToMavenCentral . md b / www / PublishingToMavenCentral . md <nl> index e835785 . . 4b1c413 100644 <nl> - - - a / www / PublishingToMavenCentral . md <nl> + + + b / www / PublishingToMavenCentral . md <nl> @ @ - 4 , 8 + 4 , 8 @ @ Publishing JNA to Maven Central <nl> One Time <nl> - - - - - - - - <nl> <nl> - * Set up your gpg keys as described [ here ] ( https : / / docs . sonatype . org / display / Repository / How + To + Generate + PGP + Signatures + With + Maven ) . Make sure you distribute your public key . <nl> - * Make sure you have a settings . xml file ( in directory : $ { user . home } / . m2 / ) as described at the bottom of 7a1 [ here ] ( https : / / docs . sonatype . org / display / Repository / Sonatype + OSS + Maven + Repository + Usage + Guide # SonatypeOSSMavenRepositoryUsageGuide - 7a . 1 . POMandsettingsconfig ) . For example : <nl> + * Set up your gpg keys as described [ here ] ( http : / / central . sonatype . org / pages / working - with - pgp - signatures . html ) . Make sure you distribute your public key . <nl> + * Make sure you have a settings . xml file ( in directory : $ { user . home } / . m2 / ) . For example : <nl> <nl> < settings > <nl> . . . <nl> @ @ - 52 , 11 + 52 , 10 @ @ full release is performed ) . <nl> Publish Release <nl> - - - - - - - - - - - - - - - <nl> <nl> - * Verify the & lt ; version > tags in [ pom - jna . xml ] ( https : / / github . com / twall / jna / blob / master / pom - jna . xml ) and [ pom - platform . xml ] ( https : / / github . com / twall / jna / blob / master / pom - platform . xml ) <nl> + * Verify the & lt ; version > tags in [ pom - jna . xml ] ( https : / / github . com / twall / jna / blob / master / pom - jna . xml ) and [ pom - jna - platform . xml ] ( https : / / github . com / twall / jna / blob / master / pom - jna - platform . xml ) <nl> match the version ( jna . version ) in [ build . xml ] ( https : / / github . com / twall / jna / blob / master / build . xml ) . <nl> * Run ` ant - Dmaven - release = true stage ` . This uploads current checkout to [ maven . java . net ] ( https : / / maven . java . net ) . <nl> - * Follow steps from [ release <nl> - it ] ( https : / / docs . sonatype . org / display / Repository / Sonatype + OSS + Maven + Repository + Usage + Guide # SonatypeOSSMavenRepositoryUsageGuide - 8a . ReleaseIt ) . <nl> + * Follow steps from [ Releasing the Deployment ] ( http : / / central . sonatype . org / pages / releasing - the - deployment . html ) . <nl> Note that the releases are managed from [ maven . java . net ] ( https : / / maven . java . net ) . <nl> <nl>
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 old mode 100644 
 new mode 100755 
 index a73c961 . . fae7c2d 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 23 , 6 + 23 , 7 @ @ Features 
 * [ # 365 ] ( https : / / github . com / twall / jna / pull / 365 ) : Added ` com . sun . jna . platform . win32 . Kernel32 . GetComputerNameEx ` support - [ @ lgoldstein ] ( https : / / github . com / lgoldstein ) . 
 * [ # 368 ] ( https : / / github . com / twall / jna / pull / 368 ) : Added ` com . sun . jna . platform . win32 . Kernel32 . VirtualQueryEx ` , ` com . sun . jna . platform . win32 . WinNT . MEMORY _ BASIC _ INFORMATION ` and ` MEM _ COMMIT ` , ` MEM _ FREE ` , ` MEM _ RESERVE ` , ` MEM _ IMAGE ` , ` MEM _ MAPPED ` , ` MEM _ PRIVATE ` constants to ` com . sun . jna . platform . win32 . WinNT ` - [ @ apsk ] ( https : / / github . com / apsk ) . 
 * Allow interoperation with JNI revision changes - [ @ twall ] ( https : / / github . com / twall ) . 
 + * [ # 391 ] ( https : / / github . com / twall / jna / pull / 391 ) : Added ` EncryptFile ` , ` DecryptFile ` , ` FileEncryptionStatus ` , ` EncryptionDisable ` , ` OpenEncryptedFileRaw ` , ` ReadEncryptedFileRaw ` , ` WriteEncryptedFileRaw ` , and ` CloseEncryptedFileRaw ` to ` com . sun . jna . platform . win32 . Advapi32 ` with related ` Advapi32Util ` helpers - [ @ khalidq ] ( https : / / github . com / khalidq ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 @ @ - 36 , 6 + 37 , 8 @ @ Bug Fixes 
 * Disable WebStart tests - [ @ twall ] ( https : / / github . com / twall ) . 
 * Dispose all native resources when JNA ' s native library is unloaded - Paul Gr ü tter of signotec GmbH and [ @ twall ] ( https : / / github . com / twall ) . This fixes a number of seemingly random , sporadic crashes on windows . 
 * Weakly hold registered Direct - mapped classes - [ @ twall ] ( https : / / github . com / twall ) . 
 + * [ # 382 ] ( https : / / github . com / twall / jna / pull / 382 ) : Fixed memory allocation in ` com . sun . jna . platform . win32 . WTypes . LPWSTR ` and ` LPSTR ` constructors - [ @ junak - michal ] ( https : / / github . com / junak - michal ) . 
 + * Fix publish doc links - [ @ bhamail ] ( https : / / github . com / bhamail ) . 
 * [ # 388 ] ( https : / / github . com / twall / jna / issues / 388 ) : Ensure native library always opened with provided flags - [ @ zolyfarkas ] ( https : / / github . com / zolyfarkas ) . 
 
 Release 4 . 1 
 diff - - git a / README . md b / README . md 
 index 557b447 . . 7f412c0 100644 
 - - - a / README . md 
 + + + b / README . md 
 @ @ - 93 , 7 + 93 , 7 @ @ Using the Library 
 * [ Platform Library ] ( https : / / github . com / twall / jna / blob / master / www / PlatformLibrary . md ) 
 * [ Direct Method Mapping ] ( https : / / github . com / twall / jna / blob / master / www / DirectMapping . md ) ( Optimization ) 
 * [ Frequently Asked Questions ( FAQ ) ] ( https : / / github . com / twall / jna / blob / master / www / FrequentlyAskedQuestions . md ) 
 - * [ Avoiding Crashes ] ( http : / / twall . github . com / jna / 4 . 1 . 0 / javadoc / overview - summary . html # crash - protection ) 
 + * [ Avoiding Crashes ] ( http : / / twall . github . com / jna / 4 . 1 . 0 / overview - summary . html # crash - protection ) 
 
 Primary Documentation ( JavaDoc ) 
 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 diff - - git a / build . xml b / build . xml 
 index 740e9f5 . . 61e18b2 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 371 , 6 + 371 , 10 @ @ com / sun / jna / win32 - x86 / jnidispatch . dll ; 
 processor = x86 ; osname = win32 , 
 com / sun / jna / win32 - x86 - 64 / jnidispatch . dll ; 
 processor = x86 - 64 ; osname = win32 , 
 + com / sun / jna / win32 - x86 / jnidispatch . dll ; 
 + processor = x86 ; osname = win , 
 + com / sun / jna / win32 - x86 - 64 / jnidispatch . dll ; 
 + processor = x86 - 64 ; osname = win , 
 com / sun / jna / w32ce - arm / jnidispatch . dll ; 
 processor = arm ; osname = wince , 
 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 old mode 100644 
 new mode 100755 
 index d34c06d . . cb5556b 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32 . java 
 @ @ - 17 , 6 + 17 , 8 @ @ import com . sun . jna . Pointer ; 
 import com . sun . jna . Structure ; 
 import com . sun . jna . WString ; 
 import com . sun . jna . platform . win32 . WinBase . SECURITY _ ATTRIBUTES ; 
 + import com . sun . jna . platform . win32 . WinBase . FE _ EXPORT _ FUNC ; 
 + import com . sun . jna . platform . win32 . WinBase . FE _ IMPORT _ FUNC ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLE ; 
 import com . sun . jna . platform . win32 . WinNT . HANDLEByReference ; 
 import com . sun . jna . platform . win32 . WinNT . PSID ; 
 @ @ - 35 , 6 + 37 , 7 @ @ import com . sun . jna . win32 . W32APIOptions ; 
 import static com . sun . jna . platform . win32 . WinDef . BOOLByReference ; 
 import static com . sun . jna . platform . win32 . WinDef . DWORD ; 
 import static com . sun . jna . platform . win32 . WinDef . DWORDByReference ; 
 + import static com . sun . jna . platform . win32 . WinDef . ULONG ; 
 import static com . sun . jna . platform . win32 . WinNT . GENERIC _ MAPPING ; 
 import static com . sun . jna . platform . win32 . WinNT . PRIVILEGE _ SET ; 
 
 @ @ - 1558 , 4 + 1561 , 153 @ @ public interface Advapi32 extends StdCallLibrary { 
 PRIVILEGE _ SET PrivilegeSet , 
 DWORDByReference PrivilegeSetLength , 
 DWORDByReference GrantedAccess , BOOLByReference AccessStatus ) ; 
 + 	 
 + 	 / * * 
 + 	 * Encrypts a file or directory . All data streams in a file are encrypted . All 
 + 	 * new files created in an encrypted directory are encrypted . 
 + 	 * 
 + 	 * @ param lpFileName 
 + 	 * The name of the file or directory to be encrypted . 
 + 	 * @ return If the function succeeds , the return value is nonzero . If the 
 + 	 * function fails , the return value is zero . To get extended error 
 + 	 * information , call GetLastError . 
 + 	 * / 
 + 	 public boolean EncryptFile ( WString lpFileName ) ; 
 + 
 + 	 / * * 
 + 	 * Decrypts an encrypted file or directory . 
 + 	 * 
 + 	 * @ param lpFileName 
 + 	 * The name of the file or directory to be decrypted . 
 + 	 * @ param dwReserved 
 + 	 * Reserved ; must be zero . 
 + 	 * @ return If the function succeeds , the return value is nonzero . If the 
 + 	 * function fails , the return value is zero . To get extended error 
 + 	 * information , call GetLastError . 
 + 	 * / 
 + 	 public boolean DecryptFile ( WString lpFileName , DWORD dwReserved ) ; 
 + 
 + 	 / * * 
 + 	 * Retrieves the encryption status of the specified file . 
 + 	 * 
 + 	 * @ param lpFileName 
 + 	 * The name of the file . 
 + 	 * @ param lpStatus 
 + 	 * A pointer to a variable that receives the encryption status of the 
 + 	 * file . 
 + 	 * @ return If the function succeeds , the return value is nonzero . If the 
 + 	 * function fails , the return value is zero . To get extended error 
 + 	 * information , call GetLastError . 
 + 	 * / 
 + 	 public boolean FileEncryptionStatus ( WString lpFileName , DWORDByReference lpStatus ) ; 
 + 
 + 	 / * * 
 + 	 * Disables or enables encryption of the specified directory and the files in 
 + 	 * it . It does not affect encryption of subdirectories below the indicated 
 + 	 * directory . 
 + 	 * 
 + 	 * @ param DirPath 
 + 	 * The name of the directory for which to enable or disable 
 + 	 * encryption . 
 + 	 * @ param Disable 
 + 	 * Indicates whether to disable encryption ( TRUE ) or enable it 
 + 	 * ( FALSE ) . 
 + 	 * @ return If the function succeeds , the return value is nonzero . If the 
 + 	 * function fails , the return value is zero . To get extended error 
 + 	 * information , call GetLastError . 
 + 	 * / 
 + 	 public boolean EncryptionDisable ( WString DirPath , boolean Disable ) ; 
 + 
 + 	 / * * 
 + 	 * Opens an encrypted file in order to backup ( export ) or restore ( import ) the 
 + 	 * file . This is one of a group of Encrypted File System ( EFS ) functions that 
 + 	 * is intended to implement backup and restore functionality , while 
 + 	 * maintaining files in their encrypted state . 
 + 	 * 
 + 	 * @ param lpFileName 
 + 	 * The name of the file to be opened . The string must consist of 
 + 	 * characters from the Windows character set . 
 + 	 * @ param ulFlags 
 + 	 * The operation to be performed . 
 + 	 * @ param pvContext 
 + 	 * The address of a context block that must be presented in subsequent 
 + 	 * calls to ReadEncryptedFileRaw , WriteEncryptedFileRaw , or 
 + 	 * CloseEncryptedFileRaw . Do not modify it . 
 + 	 * @ return If the function succeeds , it returns ERROR _ SUCCESS . If the function 
 + 	 * fails , it returns a nonzero error code defined in WinError . h . You can use 
 + 	 * FormatMessage with the FORMAT _ MESSAGE _ FROM _ SYSTEM flag to get a generic 
 + 	 * text description of the error . 
 + 	 * / 
 + 	 public int OpenEncryptedFileRaw ( WString lpFileName , ULONG ulFlags , 
 + PointerByReference pvContext ) ; 
 + 
 + 	 / * * 
 + 	 * Backs up ( export ) encrypted files . This is one of a group of Encrypted File 
 + 	 * System ( EFS ) functions that is intended to implement backup and restore 
 + 	 * functionality , while maintaining files in their encrypted state . 
 + 	 * 
 + 	 * @ param pfExportCallback 
 + 	 * A pointer to the export callback function . The system calls the 
 + 	 * callback function multiple times , each time passing a block of the 
 + 	 * file ' s data to the callback function until the entire file has been 
 + 	 * read . For more information , see ExportCallback . 
 + 	 * @ param pvCallbackContext 
 + 	 * A pointer to an application - defined and allocated context block . 
 + 	 * The system passes this pointer to the callback function as a 
 + 	 * parameter so that the callback function can have access to 
 + 	 * application - specific data . This can be a structure and can contain 
 + 	 * any data the application needs , such as the handle to the file that 
 + 	 * will contain the backup copy of the encrypted file . 
 + 	 * @ param pvContext 
 + 	 * A pointer to a system - defined context block . The context block is 
 + 	 * returned by the OpenEncryptedFileRaw function . Do not modify it . 
 + 	 * @ return If the function succeeds , the return value is ERROR _ SUCCESS . If the 
 + 	 * function fails , it returns a nonzero error code defined in WinError . h . You 
 + 	 * can use FormatMessage with the FORMAT _ MESSAGE _ FROM _ SYSTEM flag to get a 
 + 	 * generic text description of the error . 
 + 	 * / 
 + 	 public int ReadEncryptedFileRaw ( FE _ EXPORT _ FUNC pfExportCallback , 
 + Pointer pvCallbackContext , Pointer pvContext ) ; 
 + 
 + 	 / * * 
 + 	 * Restores ( import ) encrypted files . This is one of a group of Encrypted File 
 + 	 * System ( EFS ) functions that is intended to implement backup and restore 
 + 	 * functionality , while maintaining files in . 
 + 	 * 
 + 	 * @ param pfImportCallback 
 + 	 * A pointer to the import callback function . The system calls the 
 + 	 * callback function multiple times , each time passing a buffer that 
 + 	 * will be filled by the callback function with a portion of backed - up 
 + 	 * file ' s data . When the callback function signals that the entire 
 + 	 * file has been processed , it tells the system that the restore 
 + 	 * operation is finished . For more information , see ImportCallback . 
 + 	 * @ param pvCallbackContext 
 + 	 * A pointer to an application - defined and allocated context block . 
 + 	 * The system passes this pointer to the callback function as a 
 + 	 * parameter so that the callback function can have access to 
 + 	 * application - specific data . This can be a structure and can contain 
 + 	 * any data the application needs , such as the handle to the file that 
 + 	 * will contain the backup copy of the encrypted file . 
 + 	 * @ param pvContext 
 + 	 * A pointer to a system - defined context block . The context block is 
 + 	 * returned by the OpenEncryptedFileRaw function . Do not modify it . 
 + 	 * @ return If the function succeeds , the return value is ERROR _ SUCCESS . If the 
 + 	 * function fails , it returns a nonzero error code defined in WinError . h . You 
 + 	 * can use FormatMessage with the FORMAT _ MESSAGE _ FROM _ SYSTEM flag to get a 
 + 	 * generic text description of the error . 
 + 	 * / 
 + 	 public int WriteEncryptedFileRaw ( FE _ IMPORT _ FUNC pfImportCallback , 
 + Pointer pvCallbackContext , Pointer pvContext ) ; 
 + 
 + 	 / * * 
 + 	 * Closes an encrypted file after a backup or restore operation , and frees 
 + 	 * associated system resources . This is one of a group of Encrypted File 
 + 	 * System ( EFS ) functions that is intended to implement backup and restore 
 + 	 * functionality , while maintaining files in their encrypted state . 
 + 	 * 
 + 	 * @ param pvContext 
 + 	 * A pointer to a system - defined context block . The 
 + 	 * OpenEncryptedFileRaw function returns the context block . 
 + 	 * / 
 + 	 public void CloseEncryptedFileRaw ( Pointer pvContext ) ; 
 } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 old mode 100644 
 new mode 100755 
 index c28e348 . . 6b08e38 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Advapi32Util . java 
 @ @ - 12 , 7 + 12 , 9 @ @ 
 * / 
 package com . sun . jna . platform . win32 ; 
 
 + import java . io . ByteArrayOutputStream ; 
 import java . io . File ; 
 + import java . io . IOException ; 
 import java . util . ArrayList ; 
 import java . util . HashMap ; 
 import java . util . Iterator ; 
 @ @ - 37 , 6 + 39 , 7 @ @ import com . sun . jna . platform . win32 . WinNT . SID _ AND _ ATTRIBUTES ; 
 import com . sun . jna . platform . win32 . WinNT . SID _ NAME _ USE ; 
 import com . sun . jna . platform . win32 . WinReg . HKEY ; 
 import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 + import com . sun . jna . ptr . ByteByReference ; 
 import com . sun . jna . ptr . IntByReference ; 
 import com . sun . jna . ptr . LongByReference ; 
 import com . sun . jna . ptr . PointerByReference ; 
 @ @ - 2185 , 4 + 2188 , 159 @ @ public abstract class Advapi32Util { 
 
 return hasAccess ; 
 } 
 + 	 
 + / * * 
 + * Encrypts a file or directory . 
 + * 
 + * @ param file 
 + * The file or directory to encrypt . 
 + * / 
 + public static void encryptFile ( File file ) { 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + if ( ! Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Decrypts an encrypted file or directory . 
 + * 
 + * @ param file 
 + * The file or directory to decrypt . 
 + * / 
 + public static void decryptFile ( File file ) { 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + if ( ! Advapi32 . INSTANCE . DecryptFile ( lpFileName , new DWORD ( 0 ) ) ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Checks the encryption status of a file . 
 + * 
 + * @ param file 
 + * The file to check the status for . 
 + * @ return The status of the file . 
 + * / 
 + public static int fileEncryptionStatus ( File file ) { 
 + DWORDByReference status = new DWORDByReference ( ) ; 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + if ( ! Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , status ) ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + return status . getValue ( ) . intValue ( ) ; 
 + } 
 + 
 + / * * 
 + * Disables or enables encryption of the specified directory and the files in 
 + * it . 
 + * 
 + * @ param directory 
 + * The directory for which to enable or disable encryption . 
 + * @ param disable 
 + * TRUE to disable encryption . FALSE to enable it . 
 + * / 
 + public static void disableEncryption ( File directory , boolean disable ) { 
 + WString dirPath = new WString ( directory . getAbsolutePath ( ) ) ; 
 + if ( ! Advapi32 . INSTANCE . EncryptionDisable ( dirPath , disable ) ) { 
 + throw new Win32Exception ( Native . getLastError ( ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Backup an encrypted file or folder without decrypting it . A file named 
 + * " bar / sample . text " will be backed - up to " destDir / sample . text " . A directory 
 + * named " bar " will be backed - up to " destDir / bar " . This method is NOT 
 + * recursive . If you have an encrypted directory with encrypted files , this 
 + * method must be called once for the directory , and once for each encrypted 
 + * file to be backed - up . 
 + * 
 + * @ param src 
 + * The encrypted file or directory to backup . 
 + * @ param destDir 
 + * The directory where the backup will be saved . 
 + * / 
 + public static void backupEncryptedFile ( File src , File destDir ) { 
 + if ( ! destDir . isDirectory ( ) ) { 
 + throw new IllegalArgumentException ( " destDir must be a directory . " ) ; 
 + } 
 + 
 + ULONG readFlag = new ULONG ( 0 ) ; / / Open the file for export ( backup ) 
 + ULONG writeFlag = new ULONG ( CREATE _ FOR _ IMPORT ) ; / / Import ( restore ) file 
 + 
 + if ( src . isDirectory ( ) ) { 
 + writeFlag . setValue ( CREATE _ FOR _ IMPORT | CREATE _ FOR _ DIR ) ; 
 + } 
 + 
 + / / open encrypted file for export 
 + WString srcFileName = new WString ( src . getAbsolutePath ( ) ) ; 
 + PointerByReference pvContext = new PointerByReference ( ) ; 
 + if ( Advapi32 . INSTANCE . OpenEncryptedFileRaw ( srcFileName , readFlag , 
 + pvContext ) ! = W32Errors . ERROR _ SUCCESS ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + 
 + / / read encrypted file 
 + final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; 
 + FE _ EXPORT _ FUNC pfExportCallback = new FE _ EXPORT _ FUNC ( ) { 
 + @ Override 
 + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , 
 + ULONG ulLength ) { 
 + byte [ ] arr = pbData . getPointer ( ) . getByteArray ( 0 , ulLength . intValue ( ) ) ; 
 + try { 
 + outputStream . write ( arr ) ; 
 + } catch ( IOException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; 
 + } 
 + } ; 
 + 
 + if ( Advapi32 . INSTANCE . ReadEncryptedFileRaw ( pfExportCallback , null , 
 + pvContext . getValue ( ) ) ! = W32Errors . ERROR _ SUCCESS ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + 
 + / / close 
 + try { 
 + outputStream . close ( ) ; 
 + } catch ( IOException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; 
 + 
 + / / open file for import 
 + WString destFileName = new WString ( destDir . getAbsolutePath ( ) + File . separator 
 + + src . getName ( ) ) ; 
 + pvContext = new PointerByReference ( ) ; 
 + if ( Advapi32 . INSTANCE . OpenEncryptedFileRaw ( destFileName , writeFlag , 
 + pvContext ) ! = W32Errors . ERROR _ SUCCESS ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + 
 + / / write encrypted file 
 + final IntByReference elementsReadWrapper = new IntByReference ( 0 ) ; 
 + FE _ IMPORT _ FUNC pfImportCallback = new FE _ IMPORT _ FUNC ( ) { 
 + @ Override 
 + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , 
 + ULONGByReference ulLength ) { 
 + int elementsRead = elementsReadWrapper . getValue ( ) ; 
 + int remainingElements = outputStream . size ( ) - elementsRead ; 
 + int length = Math . min ( remainingElements , ulLength . getValue ( ) . intValue ( ) ) ; 
 + pbData . getPointer ( ) . write ( 0 , outputStream . toByteArray ( ) , elementsRead , 
 + length ) ; 
 + elementsReadWrapper . setValue ( elementsRead + length ) ; 
 + ulLength . setValue ( new ULONG ( length ) ) ; 
 + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; 
 + } 
 + } ; 
 + 
 + if ( Advapi32 . INSTANCE . WriteEncryptedFileRaw ( pfImportCallback , null , 
 + pvContext . getValue ( ) ) ! = W32Errors . ERROR _ SUCCESS ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + 
 + / / close 
 + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; 
 + } 
 } 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java b / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java 
 index e997f95 . . c487312 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WTypes . java 
 @ @ - 135 , 7 + 135 , 7 @ @ public interface WTypes { 
 } 
 
 public LPSTR ( String value ) { 
 - this ( ) ; 
 + this ( new Memory ( ( value . length ( ) + 1L ) * Native . WCHAR _ SIZE ) ) ; 
 this . setValue ( value ) ; 
 } 
 
 @ @ - 172 , 7 + 172 , 7 @ @ public interface WTypes { 
 } 
 
 public LPWSTR ( String value ) { 
 - this ( ) ; 
 + this ( new Memory ( ( value . length ( ) + 1L ) * Native . WCHAR _ SIZE ) ) ; 
 this . setValue ( value ) ; 
 } 
 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / WinBase . java b / contrib / platform / src / com / sun / jna / platform / win32 / WinBase . java 
 old mode 100644 
 new mode 100755 
 index 4f32e37 . . 80a936e 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / WinBase . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / WinBase . java 
 @ @ - 153 , 6 + 153 , 23 @ @ public interface WinBase extends StdCallLibrary , WinDef , BaseTSD { 
 int CREATE _ DEFAULT _ ERROR _ MODE = 0x04000000 ; 
 int CREATE _ NO _ WINDOW = 0x08000000 ; 
 
 + / * File encryption status * / 
 + int FILE _ ENCRYPTABLE = 0 ; 
 + int FILE _ IS _ ENCRYPTED = 1 ; 
 + int FILE _ SYSTEM _ ATTR = 2 ; 
 + int FILE _ ROOT _ DIR = 3 ; 
 + int FILE _ SYSTEM _ DIR = 4 ; 
 + int FILE _ UNKNOWN = 5 ; 
 + int FILE _ SYSTEM _ NOT _ SUPPORT = 6 ; 
 + int FILE _ USER _ DISALLOWED = 7 ; 
 + int FILE _ READ _ ONLY = 8 ; 
 + int FILE _ DIR _ DISALOWED = 9 ; 
 + 
 + / * Open encrypted files raw flags * / 
 + int CREATE _ FOR _ IMPORT = 1 ; 
 + int CREATE _ FOR _ DIR = 2 ; 
 + int OVERWRITE _ HIDDEN = 4 ; 
 + 
 / * Invalid return values * / 
 int INVALID _ FILE _ SIZE = 0xFFFFFFFF ; 
 int INVALID _ SET _ FILE _ POINTER = 0xFFFFFFFF ; 
 @ @ - 986 , 4 + 1003 , 28 @ @ public interface WinBase extends StdCallLibrary , WinDef , BaseTSD { 
 * / 
 int ComputerNameMax = 8 ; 
 } 
 + 
 + / * * 
 + * An application - defined callback function used with ReadEncryptedFileRaw . 
 + * The system calls ExportCallback one or more times , each time with a block 
 + * of the encrypted file ' s data , until it has received all of the file data . 
 + * ExportCallback writes the encrypted file ' s data to another storage media , 
 + * usually for purposes of backing up the file . 
 + * / 
 + public interface FE _ EXPORT _ FUNC extends Callback { 
 + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , 
 + ULONG ulLength ) ; 
 + } 
 + 
 + / * * 
 + * An application - defined callback function used with WriteEncryptedFileRaw . 
 + * The system calls ImportCallback one or more times , each time to retrieve a 
 + * portion of a backup file ' s data . ImportCallback reads the data from a 
 + * backup file sequentially and restores the data , and the system continues 
 + * calling it until it has read all of the backup file data . 
 + * / 
 + public interface FE _ IMPORT _ FUNC extends Callback { 
 + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , 
 + ULONGByReference ulLength ) ; 
 + } 
 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 old mode 100644 
 new mode 100755 
 index c144ee1 . . c09dbee 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32Test . java 
 @ @ - 12 , 7 + 12 , 10 @ @ 
 * / 
 package com . sun . jna . platform . win32 ; 
 
 + import java . io . ByteArrayOutputStream ; 
 import java . io . File ; 
 + import java . io . FileWriter ; 
 + import java . io . IOException ; 
 
 import junit . framework . TestCase ; 
 
 @ @ - 38 , 6 + 41 , 7 @ @ import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 import com . sun . jna . platform . win32 . Winsvc . SC _ HANDLE ; 
 import com . sun . jna . platform . win32 . Winsvc . SC _ STATUS _ TYPE ; 
 import com . sun . jna . platform . win32 . Winsvc . SERVICE _ STATUS _ PROCESS ; 
 + import com . sun . jna . ptr . ByteByReference ; 
 import com . sun . jna . ptr . IntByReference ; 
 import com . sun . jna . ptr . PointerByReference ; 
 
 @ @ - 906 , 4 + 910 , 225 @ @ public class Advapi32Test extends TestCase { 
 assertEquals ( WinError . ERROR _ INVALID _ HANDLE , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 } 
 
 + public void testEncryptFile ( ) throws Exception { 
 + / / create a temp file 
 + File file = createTempFile ( ) ; 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + 
 + / / encrypt a read only file 
 + file . setWritable ( false ) ; 
 + assertFalse ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; 
 + assertEquals ( WinError . ERROR _ FILE _ READ _ ONLY , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + 
 + / / encrypt a writable file 
 + file . setWritable ( true ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; 
 + 
 + file . delete ( ) ; 
 + } 
 + 
 + public void testDecryptFile ( ) throws Exception { 
 + / / create an encrypted file 
 + File file = createTempFile ( ) ; 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; 
 + 
 + / / decrypt a read only file 
 + file . setWritable ( false ) ; 
 + assertFalse ( Advapi32 . INSTANCE . DecryptFile ( lpFileName , new DWORD ( 0 ) ) ) ; 
 + assertEquals ( WinError . ERROR _ FILE _ READ _ ONLY , Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + 
 + / / decrypt 
 + file . setWritable ( true ) ; 
 + assertTrue ( Advapi32 . INSTANCE . DecryptFile ( lpFileName , new DWORD ( 0 ) ) ) ; 
 + 
 + file . delete ( ) ; 
 + } 
 + 
 + public void testFileEncryptionStatus ( ) throws Exception { 
 + DWORDByReference lpStatus = new DWORDByReference ( ) ; 
 + 
 + / / create a temp file 
 + File file = createTempFile ( ) ; 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + 
 + / / unencrypted file 
 + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , lpStatus ) ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , lpStatus . getValue ( ) . intValue ( ) ) ; 
 + 
 + / / read only file 
 + file . setWritable ( false ) ; 
 + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , lpStatus ) ) ; 
 + assertEquals ( FILE _ READ _ ONLY , lpStatus . getValue ( ) . intValue ( ) ) ; 
 + 
 + / / encrypted file 
 + file . setWritable ( true ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( lpFileName , lpStatus ) ) ; 
 + assertEquals ( FILE _ IS _ ENCRYPTED , lpStatus . getValue ( ) . intValue ( ) ) ; 
 + 
 + file . delete ( ) ; 
 + } 
 + 
 + public void testEncryptionDisable ( ) throws Exception { 
 + DWORDByReference lpStatus = new DWORDByReference ( ) ; 
 + 
 + / / create a temp dir 
 + String filePath = System . getProperty ( " java . io . tmpdir " ) + File . separator + 
 + System . nanoTime ( ) ; 
 + WString DirPath = new WString ( filePath ) ; 
 + File dir = new File ( filePath ) ; 
 + dir . mkdir ( ) ; 
 + 
 + / / check status 
 + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( DirPath , lpStatus ) ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , lpStatus . getValue ( ) . intValue ( ) ) ; 
 + 
 + / / disable encryption 
 + assertTrue ( Advapi32 . INSTANCE . EncryptionDisable ( DirPath , true ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( DirPath , lpStatus ) ) ; 
 + assertEquals ( FILE _ DIR _ DISALOWED , lpStatus . getValue ( ) . intValue ( ) ) ; 
 + 
 + / / enable encryption 
 + assertTrue ( Advapi32 . INSTANCE . EncryptionDisable ( DirPath , false ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . FileEncryptionStatus ( DirPath , lpStatus ) ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , lpStatus . getValue ( ) . intValue ( ) ) ; 
 + 
 + / / clean up 
 + for ( File file : dir . listFiles ( ) ) { 
 + file . delete ( ) ; 
 + } 
 + dir . delete ( ) ; 
 + } 
 + 
 + public void testOpenEncryptedFileRaw ( ) throws Exception { 
 + / / create an encrypted file 
 + File file = createTempFile ( ) ; 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; 
 + 
 + / / open file for export 
 + ULONG ulFlags = new ULONG ( 0 ) ; 
 + PointerByReference pvContext = new PointerByReference ( ) ; 
 + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . OpenEncryptedFileRaw ( 
 + lpFileName , ulFlags , pvContext ) ) ; 
 + 
 + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; 
 + file . delete ( ) ; 
 + } 
 + 
 + public void testReadEncryptedFileRaw ( ) throws Exception { 
 + / / create an encrypted file 
 + File file = createTempFile ( ) ; 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; 
 + 
 + / / open file for export 
 + ULONG ulFlags = new ULONG ( 0 ) ; 
 + PointerByReference pvContext = new PointerByReference ( ) ; 
 + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . OpenEncryptedFileRaw ( 
 + lpFileName , ulFlags , pvContext ) ) ; 
 + 
 + / / read encrypted file 
 + final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; 
 + FE _ EXPORT _ FUNC pfExportCallback = new FE _ EXPORT _ FUNC ( ) { 
 + @ Override 
 + public DWORD callback ( ByteByReference pbData , Pointer 
 + pvCallbackContext , ULONG ulLength ) { 
 + byte [ ] arr = pbData . getPointer ( ) . getByteArray ( 0 , ulLength . intValue ( ) ) ; 
 + try { 
 + outputStream . write ( arr ) ; 
 + } catch ( IOException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; 
 + } 
 + } ; 
 + 
 + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . ReadEncryptedFileRaw ( 
 + pfExportCallback , null , pvContext . getValue ( ) ) ) ; 
 + outputStream . close ( ) ; 
 + 
 + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; 
 + file . delete ( ) ; 
 + } 
 + 
 + public void testWriteEncryptedFileRaw ( ) throws Exception { 
 + / / create an encrypted file 
 + File file = createTempFile ( ) ; 
 + WString lpFileName = new WString ( file . getAbsolutePath ( ) ) ; 
 + assertTrue ( Advapi32 . INSTANCE . EncryptFile ( lpFileName ) ) ; 
 + 
 + / / open file for export 
 + ULONG ulFlags = new ULONG ( 0 ) ; 
 + PointerByReference pvContext = new PointerByReference ( ) ; 
 + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . OpenEncryptedFileRaw ( 
 + lpFileName , ulFlags , pvContext ) ) ; 
 + 
 + / / read encrypted file 
 + final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; 
 + FE _ EXPORT _ FUNC pfExportCallback = new FE _ EXPORT _ FUNC ( ) { 
 + @ Override 
 + public DWORD callback ( ByteByReference pbData , Pointer 
 + pvCallbackContext , ULONG ulLength ) { 
 + byte [ ] arr = pbData . getPointer ( ) . getByteArray ( 0 , ulLength . intValue ( ) ) ; 
 + try { 
 + outputStream . write ( arr ) ; 
 + } catch ( IOException e ) { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; 
 + } 
 + } ; 
 + 
 + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . ReadEncryptedFileRaw ( 
 + pfExportCallback , null , pvContext . getValue ( ) ) ) ; 
 + outputStream . close ( ) ; 
 + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext . getValue ( ) ) ; 
 + 
 + / / open file for import 
 + WString lbFileName2 = new WString ( System . getProperty ( " java . io . tmpdir " ) + 
 + File . separator + " backup - " + file . getName ( ) ) ; 
 + ULONG ulFlags2 = new ULONG ( CREATE _ FOR _ IMPORT ) ; 
 + PointerByReference pvContext2 = new PointerByReference ( ) ; 
 + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . OpenEncryptedFileRaw ( 
 + lbFileName2 , ulFlags2 , pvContext2 ) ) ; 
 + 
 + / / write encrypted file 
 + final IntByReference elementsReadWrapper = new IntByReference ( 0 ) ; 
 + FE _ IMPORT _ FUNC pfImportCallback = new FE _ IMPORT _ FUNC ( ) { 
 + @ Override 
 + public DWORD callback ( ByteByReference pbData , Pointer pvCallbackContext , 
 + ULONGByReference ulLength ) { 
 + int elementsRead = elementsReadWrapper . getValue ( ) ; 
 + int remainingElements = outputStream . size ( ) - elementsRead ; 
 + int length = Math . min ( remainingElements , ulLength . getValue ( ) . intValue ( ) ) ; 
 + pbData . getPointer ( ) . write ( 0 , outputStream . toByteArray ( ) , elementsRead , 
 + length ) ; 
 + elementsReadWrapper . setValue ( elementsRead + length ) ; 
 + ulLength . setValue ( new ULONG ( length ) ) ; 
 + return new DWORD ( W32Errors . ERROR _ SUCCESS ) ; 
 + } 
 + } ; 
 + 
 + assertEquals ( W32Errors . ERROR _ SUCCESS , Advapi32 . INSTANCE . WriteEncryptedFileRaw ( 
 + pfImportCallback , null , pvContext2 . getValue ( ) ) ) ; 
 + Advapi32 . INSTANCE . CloseEncryptedFileRaw ( pvContext2 . getValue ( ) ) ; 
 + 
 + file . delete ( ) ; 
 + new File ( lbFileName2 . toString ( ) ) . delete ( ) ; 
 + } 
 + 
 + private File createTempFile ( ) throws Exception { 
 + String filePath = System . getProperty ( " java . io . tmpdir " ) + System . nanoTime ( ) 
 + + " . text " ; 
 + File file = new File ( filePath ) ; 
 + file . createNewFile ( ) ; 
 + FileWriter fileWriter = new FileWriter ( file ) ; 
 + for ( int i = 0 ; i < 1000 ; i + + ) { 
 + fileWriter . write ( " Sample text " + i + System . getProperty ( " line . separator " ) ) ; 
 + } 
 + fileWriter . close ( ) ; 
 + return file ; 
 + } 
 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java 
 old mode 100644 
 new mode 100755 
 index 835c409 . . c8eb531 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Advapi32UtilTest . java 
 @ @ - 13 , 6 + 13 , 7 @ @ 
 package com . sun . jna . platform . win32 ; 
 
 import java . io . File ; 
 + import java . io . FileWriter ; 
 import java . util . Map ; 
 import java . util . TreeMap ; 
 
 @ @ - 30 , 6 + 31 , 8 @ @ import com . sun . jna . platform . win32 . WinNT . WELL _ KNOWN _ SID _ TYPE ; 
 import com . sun . jna . platform . win32 . WinReg . HKEY ; 
 import com . sun . jna . platform . win32 . WinReg . HKEYByReference ; 
 
 + import static com . sun . jna . platform . win32 . WinBase . * ; 
 + 
 / * * 
 * @ author dblock [ at ] dblock [ dot ] org 
 * / 
 @ @ - 483 , 4 + 486 , 89 @ @ public class Advapi32UtilTest extends TestCase { 
 String block = Advapi32Util . getEnvironmentBlock ( mockEnvironment ) ; 
 assertEquals ( " Environment block must comprise key = value pairs separated by NUL characters " , expected , block ) ; 
 } 
 + 	 
 + public void testEncryptFile ( ) throws Exception { 
 + File file = createTempFile ( ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( file ) ) ; 
 + Advapi32Util . encryptFile ( file ) ; 
 + assertEquals ( FILE _ IS _ ENCRYPTED , Advapi32Util . fileEncryptionStatus ( file ) ) ; 
 + file . delete ( ) ; 
 + } 
 + 
 + public void testDecryptFile ( ) throws Exception { 
 + File file = createTempFile ( ) ; 
 + Advapi32Util . encryptFile ( file ) ; 
 + assertEquals ( FILE _ IS _ ENCRYPTED , Advapi32Util . fileEncryptionStatus ( file ) ) ; 
 + Advapi32Util . decryptFile ( file ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( file ) ) ; 
 + file . delete ( ) ; 
 + } 
 + 
 + public void testDisableEncryption ( ) throws Exception { 
 + File dir = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator 
 + + System . nanoTime ( ) ) ; 
 + dir . mkdir ( ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( dir ) ) ; 
 + Advapi32Util . disableEncryption ( dir , true ) ; 
 + assertEquals ( FILE _ DIR _ DISALOWED , Advapi32Util . fileEncryptionStatus ( dir ) ) ; 
 + Advapi32Util . disableEncryption ( dir , false ) ; 
 + assertEquals ( FILE _ ENCRYPTABLE , Advapi32Util . fileEncryptionStatus ( dir ) ) ; 
 + for ( File file : dir . listFiles ( ) ) { 
 + file . delete ( ) ; 
 + } 
 + dir . delete ( ) ; 
 + } 
 + 
 + public void testBackupEncryptedFile ( ) throws Exception { 
 + / / backup an encrypted file 
 + File srcFile = createTempFile ( ) ; 
 + Advapi32Util . encryptFile ( srcFile ) ; 
 + File dest = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator 
 + + " backup " + System . nanoTime ( ) ) ; 
 + dest . mkdir ( ) ; 
 + 
 + Advapi32Util . backupEncryptedFile ( srcFile , dest ) ; 
 + 
 + / / simple check to see if a backup file exist 
 + File backupFile = new File ( dest . getAbsolutePath ( ) + File . separator + 
 + srcFile . getName ( ) ) ; 
 + assertTrue ( backupFile . exists ( ) ) ; 
 + assertEquals ( srcFile . length ( ) , backupFile . length ( ) ) ; 
 + 
 + / / backup an encrypted directory 
 + File srcDir = new File ( System . getProperty ( " java . io . tmpdir " ) + File . separator 
 + + System . nanoTime ( ) ) ; 
 + srcDir . mkdir ( ) ; 
 + Advapi32Util . encryptFile ( srcDir ) ; 
 + 
 + Advapi32Util . backupEncryptedFile ( srcDir , dest ) ; 
 + 
 + / / Check to see if a backup directory exist 
 + File backupDir = new File ( dest . getAbsolutePath ( ) + File . separator + srcDir . getName ( ) ) ; 
 + assertTrue ( backupDir . exists ( ) ) ; 
 + 
 + / / clean up 
 + srcFile . delete ( ) ; 
 + for ( File file : srcDir . listFiles ( ) ) { 
 + file . delete ( ) ; 
 + } 
 + srcDir . delete ( ) ; 
 + for ( File file : dest . listFiles ( ) ) { 
 + file . delete ( ) ; 
 + } 
 + dest . delete ( ) ; 
 + } 
 + 
 + private File createTempFile ( ) throws Exception { 
 + String filePath = System . getProperty ( " java . io . tmpdir " ) + System . nanoTime ( ) 
 + + " . text " ; 
 + File file = new File ( filePath ) ; 
 + file . createNewFile ( ) ; 
 + FileWriter fileWriter = new FileWriter ( file ) ; 
 + for ( int i = 0 ; i < 1000 ; i + + ) { 
 + fileWriter . write ( " Sample text " + i + System . getProperty ( " line . separator " ) ) ; 
 + } 
 + fileWriter . close ( ) ; 
 + return file ; 
 + } 
 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / WTypesTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / WTypesTest . java 
 new file mode 100644 
 index 0000000 . . cf01c21 
 - - - / dev / null 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / WTypesTest . java 
 @ @ - 0 , 0 + 1 , 60 @ @ 
 + / * Copyright ( c ) 2007 - 2014 Timothy Wall , All Rights Reserved 
 + * 
 + * This library is free software ; you can redistribute it and / or 
 + * modify it under the terms of the GNU Lesser General Public 
 + * License as published by the Free Software Foundation ; either 
 + * version 2 . 1 of the License , or ( at your option ) any later version . 
 + * 
 + * This library is distributed in the hope that it will be useful , 
 + * but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + * Lesser General Public License for more details . 
 + * / 
 + package com . sun . jna . platform . win32 ; 
 + 
 + import com . sun . jna . Memory ; 
 + import com . sun . jna . Native ; 
 + import com . sun . jna . Pointer ; 
 + import junit . framework . TestCase ; 
 + 
 + public class WTypesTest extends TestCase { 
 + 
 + private static final String TEST _ STRING = " input " ; 
 + 
 + private static final Pointer TEST _ POINTER = new Memory ( ( TEST _ STRING . length ( ) + 1L ) * Native . WCHAR _ SIZE ) ; 
 + 
 + static { 
 + TEST _ POINTER . setWideString ( 0 , TEST _ STRING ) ; 
 + } 
 + 
 + public void testLPOLESTRConstruction ( ) { 
 + WTypes . LPOLESTR fromString = new WTypes . LPOLESTR ( TEST _ STRING ) ; 
 + assertEquals ( fromString . getValue ( ) , TEST _ STRING ) ; 
 + WTypes . LPOLESTR empty = new WTypes . LPOLESTR ( ) ; 
 + assertNull ( empty . getValue ( ) ) ; 
 + WTypes . LPOLESTR fromPointer = new WTypes . LPOLESTR ( TEST _ POINTER ) ; 
 + assertEquals ( fromPointer . getValue ( ) , TEST _ STRING ) ; 
 + } 
 + 
 + public void testLPSTRConstruction ( ) { 
 + WTypes . LPSTR instance = new WTypes . LPSTR ( TEST _ STRING ) ; 
 + assertEquals ( instance . getValue ( ) , TEST _ STRING ) ; 
 + WTypes . LPSTR empty = new WTypes . LPSTR ( ) ; 
 + assertNull ( empty . getValue ( ) ) ; 
 + WTypes . LPSTR fromPointer = new WTypes . LPSTR ( TEST _ POINTER ) ; 
 + assertEquals ( fromPointer . getValue ( ) , TEST _ STRING ) ; 
 + } 
 + 
 + public void testLPWSTRConstruction ( ) { 
 + WTypes . LPWSTR instance = new WTypes . LPWSTR ( TEST _ STRING ) ; 
 + assertEquals ( instance . getValue ( ) , TEST _ STRING ) ; 
 + WTypes . LPWSTR empty = new WTypes . LPWSTR ( ) ; 
 + assertNull ( empty . getValue ( ) ) ; 
 + WTypes . LPWSTR fromPointer = new WTypes . LPWSTR ( TEST _ POINTER ) ; 
 + assertEquals ( fromPointer . getValue ( ) , TEST _ STRING ) ; 
 + } 
 + 
 + public static void main ( String [ ] args ) { 
 + junit . textui . TestRunner . run ( WTypesTest . class ) ; 
 + } 
 + } 
 diff - - git a / www / PublishingToMavenCentral . md b / www / PublishingToMavenCentral . md 
 index e835785 . . 4b1c413 100644 
 - - - a / www / PublishingToMavenCentral . md 
 + + + b / www / PublishingToMavenCentral . md 
 @ @ - 4 , 8 + 4 , 8 @ @ Publishing JNA to Maven Central 
 One Time 
 - - - - - - - - 
 
 - * Set up your gpg keys as described [ here ] ( https : / / docs . sonatype . org / display / Repository / How + To + Generate + PGP + Signatures + With + Maven ) . Make sure you distribute your public key . 
 - * Make sure you have a settings . xml file ( in directory : $ { user . home } / . m2 / ) as described at the bottom of 7a1 [ here ] ( https : / / docs . sonatype . org / display / Repository / Sonatype + OSS + Maven + Repository + Usage + Guide # SonatypeOSSMavenRepositoryUsageGuide - 7a . 1 . POMandsettingsconfig ) . For example : 
 + * Set up your gpg keys as described [ here ] ( http : / / central . sonatype . org / pages / working - with - pgp - signatures . html ) . Make sure you distribute your public key . 
 + * Make sure you have a settings . xml file ( in directory : $ { user . home } / . m2 / ) . For example : 
 
 < settings > 
 . . . 
 @ @ - 52 , 11 + 52 , 10 @ @ full release is performed ) . 
 Publish Release 
 - - - - - - - - - - - - - - - 
 
 - * Verify the & lt ; version > tags in [ pom - jna . xml ] ( https : / / github . com / twall / jna / blob / master / pom - jna . xml ) and [ pom - platform . xml ] ( https : / / github . com / twall / jna / blob / master / pom - platform . xml ) 
 + * Verify the & lt ; version > tags in [ pom - jna . xml ] ( https : / / github . com / twall / jna / blob / master / pom - jna . xml ) and [ pom - jna - platform . xml ] ( https : / / github . com / twall / jna / blob / master / pom - jna - platform . xml ) 
 match the version ( jna . version ) in [ build . xml ] ( https : / / github . com / twall / jna / blob / master / build . xml ) . 
 * Run ` ant - Dmaven - release = true stage ` . This uploads current checkout to [ maven . java . net ] ( https : / / maven . java . net ) . 
 - * Follow steps from [ release 
 - it ] ( https : / / docs . sonatype . org / display / Repository / Sonatype + OSS + Maven + Repository + Usage + Guide # SonatypeOSSMavenRepositoryUsageGuide - 8a . ReleaseIt ) . 
 + * Follow steps from [ Releasing the Deployment ] ( http : / / central . sonatype . org / pages / releasing - the - deployment . html ) . 
 Note that the releases are managed from [ maven . java . net ] ( https : / / maven . java . net ) . 
 


NEAREST DIFF:
ELIMINATEDSENTENCE
