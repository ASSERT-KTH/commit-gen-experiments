BLEU SCORE: 0.027611988917697356

TEST MSG: accommodate long path names , fixes # 243
GENERATED MSG: fix snprintf on windows

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 774ae64 . . 9eae689 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 20 , 6 + 20 , 7 @ @ Features <nl> * [ # 236 ] ( https : / / github . com / twall / jna / issues / 236 ) : Auto - strip profiler native method prefix specified by ` jna . profiler . prefix ` , which defaults to $ $ YJP $ $ - [ @ twall ] ( https : / / github . com / twall ) . <nl> * Added ` jna . debug _ load ` property to diagnose library loading issues - [ @ twall ] ( https : / / github . com / twall ) . <nl> * Throw explicit ` IllegalArgumentException ` when ` Structure . ByReference ` is used where it shouldn ' t be ( can result in multiply freed memory or other unexpected behavior ) - [ @ twall ] ( https : / / github . com / twall ) . <nl> + * [ # 243 ] ( https : / / github . com / twall / jna / issues / 243 ) : Automatically accommodate long library paths on Windows which would otherwise fail - [ @ twall ] ( https : / / github . com / twall ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> diff - - git a / lib / native / win32 - x86 . jar b / lib / native / win32 - x86 . jar <nl> index 6d465bb . . 4e7c979 100755 <nl> Binary files a / lib / native / win32 - x86 . jar and b / lib / native / win32 - x86 . jar differ <nl> diff - - git a / native / dispatch . c b / native / dispatch . c <nl> index 931a790 . . 71fd083 100644 <nl> - - - a / native / dispatch . c <nl> + + + b / native / dispatch . c <nl> @ @ - 21 , 7 + 21 , 7 @ @ <nl> # include < windows . h > <nl> # include < psapi . h > <nl> # define STRTYPE wchar _ t * <nl> - # define NAME2CSTR ( ENV , JSTR ) newWideCString ( ENV , JSTR ) <nl> + # define NAME2CSTR ( ENV , JSTR ) w32 _ short _ name ( ENV , JSTR ) <nl> # ifdef _ WIN32 _ WCE <nl> # include < tlhelp32 . h > <nl> # define DEFAULT _ LOAD _ OPTS 0 / * altered search path unsupported on CE * / <nl> @ @ - 98 , 81 + 98 , 6 @ @ static int _ protect ; <nl> extern " C " { <nl> # endif <nl> <nl> - # ifdef _ WIN32 <nl> - static char * <nl> - w32 _ format _ error ( int err , char * buf , int len ) { <nl> - wchar _ t * wbuf = NULL ; <nl> - int wlen = <nl> - FormatMessageW ( FORMAT _ MESSAGE _ FROM _ SYSTEM <nl> - | FORMAT _ MESSAGE _ IGNORE _ INSERTS <nl> - | FORMAT _ MESSAGE _ ALLOCATE _ BUFFER , <nl> - NULL , err , 0 , ( LPWSTR ) & wbuf , 0 , NULL ) ; <nl> - if ( wlen > 0 ) { <nl> - int result = WideCharToMultiByte ( CP _ UTF8 , 0 , wbuf , - 1 , buf , len , NULL , NULL ) ; <nl> - if ( result = = 0 ) { <nl> - fprintf ( stderr , " JNA : error converting error message : % d \ n " , ( int ) GET _ LAST _ ERROR ( ) ) ; <nl> - * buf = 0 ; <nl> - } <nl> - else { <nl> - buf [ len - 1 ] = 0 ; <nl> - } <nl> - } <nl> - else { <nl> - / / Error retrieving message <nl> - * buf = 0 ; <nl> - } <nl> - if ( wbuf ) { <nl> - LocalFree ( wbuf ) ; <nl> - } <nl> - <nl> - return buf ; <nl> - } <nl> - static HANDLE <nl> - w32 _ find _ entry ( JNIEnv * env , HANDLE handle , const char * funname ) { <nl> - void * func = NULL ; <nl> - if ( handle ! = GetModuleHandle ( NULL ) ) { <nl> - func = GetProcAddress ( handle , funname ) ; <nl> - } <nl> - else { <nl> - # if defined ( _ WIN32 _ WCE ) <nl> - / * CE has no EnumProcessModules , have to use an alternate API * / <nl> - HANDLE snapshot ; <nl> - if ( ( snapshot = CreateToolhelp32Snapshot ( TH32CS _ SNAPMODULE , 0 ) ) ! = INVALID _ HANDLE _ VALUE ) { <nl> - MODULEENTRY32 moduleInfo ; <nl> - moduleInfo . dwSize = sizeof ( moduleInfo ) ; <nl> - if ( Module32First ( snapshot , & moduleInfo ) ) { <nl> - do { <nl> - if ( ( func = ( void * ) GetProcAddress ( moduleInfo . hModule , funname ) ) ) { <nl> - break ; <nl> - } <nl> - } while ( Module32Next ( snapshot , & moduleInfo ) ) ; <nl> - } <nl> - CloseToolhelp32Snapshot ( snapshot ) ; <nl> - } <nl> - # else <nl> - HANDLE cur _ proc = GetCurrentProcess ( ) ; <nl> - HMODULE * modules ; <nl> - DWORD needed , i ; <nl> - if ( ! EnumProcessModules ( cur _ proc , NULL , 0 , & needed ) ) { <nl> - fail : <nl> - throwByName ( env , EError , " Unexpected error enumerating modules " ) ; <nl> - return 0 ; <nl> - } <nl> - modules = ( HMODULE * ) alloca ( needed ) ; <nl> - if ( ! EnumProcessModules ( cur _ proc , modules , needed , & needed ) ) { <nl> - goto fail ; <nl> - } <nl> - for ( i = 0 ; i < needed / sizeof ( HMODULE ) ; i + + ) { <nl> - if ( ( func = ( void * ) GetProcAddress ( modules [ i ] , funname ) ) ) { <nl> - break ; <nl> - } <nl> - } <nl> - # endif <nl> - } <nl> - return func ; <nl> - } <nl> - # endif / * _ WIN32 * / <nl> - <nl> # define MEMCPY ( ENV , D , S , L ) do { \ <nl> PSTART ( ) ; memcpy ( D , S , L ) ; PEND ( ENV ) ; \ <nl> } while ( 0 ) <nl> @ @ - 304 , 6 + 229 , 118 @ @ static ffi _ type * getStructureType ( JNIEnv * , jobject ) ; <nl> <nl> typedef void ( JNICALL * release _ t ) ( JNIEnv * , jarray , void * , jint ) ; <nl> <nl> + # ifdef _ WIN32 <nl> + static char * <nl> + w32 _ format _ error ( int err , char * buf , int len ) { <nl> + wchar _ t * wbuf = NULL ; <nl> + int wlen = <nl> + FormatMessageW ( FORMAT _ MESSAGE _ FROM _ SYSTEM <nl> + | FORMAT _ MESSAGE _ IGNORE _ INSERTS <nl> + | FORMAT _ MESSAGE _ ALLOCATE _ BUFFER , <nl> + NULL , err , 0 , ( LPWSTR ) & wbuf , 0 , NULL ) ; <nl> + if ( wlen > 0 ) { <nl> + int result = WideCharToMultiByte ( CP _ UTF8 , 0 , wbuf , - 1 , buf , len , NULL , NULL ) ; <nl> + if ( result = = 0 ) { <nl> + fprintf ( stderr , " JNA : error converting error message : % d \ n " , ( int ) GET _ LAST _ ERROR ( ) ) ; <nl> + * buf = 0 ; <nl> + } <nl> + else { <nl> + buf [ len - 1 ] = 0 ; <nl> + } <nl> + } <nl> + else { <nl> + / / Error retrieving message <nl> + * buf = 0 ; <nl> + } <nl> + if ( wbuf ) { <nl> + LocalFree ( wbuf ) ; <nl> + } <nl> + <nl> + return buf ; <nl> + } <nl> + static wchar _ t * <nl> + w32 _ short _ name ( JNIEnv * env , jstring str ) { <nl> + wchar _ t * wstr = newWideCString ( env , str ) ; <nl> + if ( wstr & & * wstr ) { <nl> + DWORD required ; <nl> + size _ t size = wcslen ( wstr ) + 5 ; <nl> + wchar _ t * prefixed = ( wchar _ t * ) alloca ( sizeof ( wchar _ t ) * size ) ; <nl> + <nl> + # ifdef _ MSC _ VER <nl> + swprintf ( prefixed , size , L " \ \ \ \ ? \ \ % ls " , wstr ) ; <nl> + # else <nl> + swprintf ( prefixed , L " \ \ \ \ ? \ \ % ls " , wstr ) ; <nl> + # endif <nl> + if ( ( required = GetShortPathNameW ( prefixed , NULL , 0 ) ) ! = 0 ) { <nl> + wchar _ t * wshort = ( wchar _ t * ) malloc ( sizeof ( wchar _ t ) * required ) ; <nl> + if ( GetShortPathNameW ( prefixed , wshort , required ) ) { <nl> + free ( ( void * ) wstr ) ; <nl> + wstr = wshort ; <nl> + } <nl> + else { <nl> + char buf [ MSG _ SIZE ] ; <nl> + throwByName ( env , EError , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; <nl> + free ( ( void * ) wstr ) ; <nl> + free ( ( void * ) wshort ) ; <nl> + wstr = NULL ; <nl> + } <nl> + } <nl> + else if ( GET _ LAST _ ERROR ( ) ! = ERROR _ FILE _ NOT _ FOUND ) { <nl> + char buf [ MSG _ SIZE ] ; <nl> + throwByName ( env , EError , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; <nl> + free ( ( void * ) wstr ) ; <nl> + wstr = NULL ; <nl> + } <nl> + } <nl> + return wstr ; <nl> + } <nl> + <nl> + static HANDLE <nl> + w32 _ find _ entry ( JNIEnv * env , HANDLE handle , const char * funname ) { <nl> + void * func = NULL ; <nl> + if ( handle ! = GetModuleHandle ( NULL ) ) { <nl> + func = GetProcAddress ( handle , funname ) ; <nl> + } <nl> + else { <nl> + # if defined ( _ WIN32 _ WCE ) <nl> + / * CE has no EnumProcessModules , have to use an alternate API * / <nl> + HANDLE snapshot ; <nl> + if ( ( snapshot = CreateToolhelp32Snapshot ( TH32CS _ SNAPMODULE , 0 ) ) ! = INVALID _ HANDLE _ VALUE ) { <nl> + MODULEENTRY32 moduleInfo ; <nl> + moduleInfo . dwSize = sizeof ( moduleInfo ) ; <nl> + if ( Module32First ( snapshot , & moduleInfo ) ) { <nl> + do { <nl> + if ( ( func = ( void * ) GetProcAddress ( moduleInfo . hModule , funname ) ) ) { <nl> + break ; <nl> + } <nl> + } while ( Module32Next ( snapshot , & moduleInfo ) ) ; <nl> + } <nl> + CloseToolhelp32Snapshot ( snapshot ) ; <nl> + } <nl> + # else <nl> + HANDLE cur _ proc = GetCurrentProcess ( ) ; <nl> + HMODULE * modules ; <nl> + DWORD needed , i ; <nl> + if ( ! EnumProcessModules ( cur _ proc , NULL , 0 , & needed ) ) { <nl> + fail : <nl> + throwByName ( env , EError , " Unexpected error enumerating modules " ) ; <nl> + return 0 ; <nl> + } <nl> + modules = ( HMODULE * ) alloca ( needed ) ; <nl> + if ( ! EnumProcessModules ( cur _ proc , modules , needed , & needed ) ) { <nl> + goto fail ; <nl> + } <nl> + for ( i = 0 ; i < needed / sizeof ( HMODULE ) ; i + + ) { <nl> + if ( ( func = ( void * ) GetProcAddress ( modules [ i ] , funname ) ) ) { <nl> + break ; <nl> + } <nl> + } <nl> + # endif <nl> + } <nl> + return func ; <nl> + } <nl> + # endif / * _ WIN32 * / <nl> + <nl> # if 0 <nl> / * * Invokes System . err . println ( for debugging only ) . * / <nl> void <nl> @ @ - 621 , 6 + 658 , 8 @ @ getChars ( JNIEnv * env , wchar _ t * volatile dst , jcharArray chars , volatile jint off <nl> int i ; <nl> ( * env ) - > GetCharArrayRegion ( env , chars , off , count , buf ) ; <nl> for ( i = 0 ; i < count ; i + + ) { <nl> + / / TODO : ensure proper encoding conversion from jchar to native <nl> + / / wchar _ t <nl> dst [ i ] = ( wchar _ t ) buf [ i ] ; <nl> } <nl> dst + = count ; <nl> @ @ - 725 , 13 + 764 , 16 @ @ newCStringEncoding ( JNIEnv * env , jstring jstr , const char * encoding ) <nl> / * Translates a Java string to a wide C string using the String . toCharArray <nl> * method . <nl> * / <nl> - / / TODO : are any encoding changes required ? <nl> static wchar _ t * <nl> newWideCString ( JNIEnv * env , jstring str ) <nl> { <nl> jcharArray chars = 0 ; <nl> wchar _ t * result = NULL ; <nl> <nl> + if ( ( * env ) - > IsSameObject ( env , str , NULL ) ) { <nl> + return result ; <nl> + } <nl> + <nl> chars = ( * env ) - > CallObjectMethod ( env , str , MID _ String _ toCharArray ) ; <nl> if ( ! ( * env ) - > ExceptionCheck ( env ) ) { <nl> jint len = ( * env ) - > GetArrayLength ( env , chars ) ; <nl> @ @ - 741 , 7 + 783 , 6 @ @ newWideCString ( JNIEnv * env , jstring str ) <nl> throwByName ( env , EOutOfMemory , " Can ' t allocate wide C string " ) ; <nl> return NULL ; <nl> } <nl> - / / TODO : ensure proper encoding conversion from jchar to native wchar _ t <nl> getChars ( env , result , chars , 0 , len ) ; <nl> if ( ( * env ) - > ExceptionCheck ( env ) ) { <nl> free ( ( void * ) result ) ; <nl> @ @ - 1816 , 8 + 1857 , 9 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { <nl> case CVT _ ARRAY _ LONG : <nl> case CVT _ ARRAY _ FLOAT : <nl> case CVT _ ARRAY _ DOUBLE : <nl> - if ( * ( void * * ) args [ i ] & & release [ i ] ) <nl> + if ( * ( void * * ) args [ i ] & & release [ i ] ! = NULL ) { <nl> release [ i ] ( env , objects [ i ] , elems [ i ] , 0 ) ; <nl> + } <nl> break ; <nl> } <nl> } <nl> @ @ - 2036 , 7 + 2078 , 7 @ @ Java _ com _ sun _ jna _ Native _ open ( JNIEnv * env , jclass UNUSED ( cls ) , jstring lib , jint <nl> <nl> handle = ( void * ) LOAD _ LIBRARY ( libname , flags ! = - 1 ? flags : DEFAULT _ LOAD _ OPTS ) ; <nl> if ( ! handle ) { <nl> - char buf [ 1024 ] ; <nl> + char buf [ MSG _ SIZE ] ; <nl> throwByName ( env , EUnsatisfiedLink , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; <nl> } <nl> if ( libname ! = NULL ) { <nl> @ @ - 2054 , 7 + 2096 , 7 @ @ JNIEXPORT void JNICALL <nl> Java _ com _ sun _ jna _ Native _ close ( JNIEnv * env , jclass UNUSED ( cls ) , jlong handle ) <nl> { <nl> if ( FREE _ LIBRARY ( L2A ( handle ) ) ) { <nl> - char buf [ 1024 ] ; <nl> + char buf [ MSG _ SIZE ] ; <nl> throwByName ( env , EError , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; <nl> } <nl> } <nl> @ @ - 2075 , 7 + 2117 , 7 @ @ Java _ com _ sun _ jna _ Native _ findSymbol ( JNIEnv * env , jclass UNUSED ( cls ) , <nl> if ( funname ! = NULL ) { <nl> func = ( void * ) FIND _ ENTRY ( handle , funname ) ; <nl> if ( ! func ) { <nl> - char buf [ 1024 ] ; <nl> + char buf [ MSG _ SIZE ] ; <nl> throwByName ( env , EUnsatisfiedLink , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; <nl> } <nl> free ( ( void * ) funname ) ; <nl> diff - - git a / test / com / sun / jna / LibraryLoadTest . java b / test / com / sun / jna / LibraryLoadTest . java <nl> index 6fc8c74 . . 8c00d95 100644 <nl> - - - a / test / com / sun / jna / LibraryLoadTest . java <nl> + + + b / test / com / sun / jna / LibraryLoadTest . java <nl> @ @ - 164 , 6 + 164 , 31 @ @ public class LibraryLoadTest extends TestCase implements Paths { <nl> } <nl> } <nl> <nl> + public void testLoadLibraryWithLongName ( ) throws Exception { <nl> + File tmpdir = Native . getTempDir ( ) ; <nl> + String libName = NativeLibrary . mapSharedLibraryName ( " testlib " ) ; <nl> + File src = new File ( TESTPATH , libName ) ; <nl> + assertTrue ( " Expected JNA native library at " + src + " is missing " , src . exists ( ) ) ; <nl> + <nl> + for ( int i = 0 ; i < 16 ; i + + ) { <nl> + tmpdir = new File ( tmpdir , " subdir0123456789 " ) ; <nl> + tmpdir . deleteOnExit ( ) ; <nl> + } <nl> + <nl> + final String NAME = getName ( ) ; <nl> + String newLibName = libName . replace ( " testlib " , NAME ) ; <nl> + tmpdir . mkdirs ( ) ; <nl> + File dst = new File ( tmpdir , newLibName ) ; <nl> + copy ( src , dst ) ; <nl> + try { <nl> + NativeLibrary . getInstance ( NAME , new TestLoader ( tmpdir ) ) ; <nl> + dst . deleteOnExit ( ) ; <nl> + } <nl> + catch ( UnsatisfiedLinkError e ) { <nl> + fail ( " Library ' " + newLibName + " ' at " + dst + " could not be loaded : " + e ) ; <nl> + } <nl> + } <nl> + <nl> public void testLoadFrameworkLibrary ( ) { <nl> if ( Platform . isMac ( ) ) { <nl> final String PATH = " / System / Library / Frameworks / CoreServices . framework " ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 774ae64 . . 9eae689 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 20 , 6 + 20 , 7 @ @ Features 
 * [ # 236 ] ( https : / / github . com / twall / jna / issues / 236 ) : Auto - strip profiler native method prefix specified by ` jna . profiler . prefix ` , which defaults to $ $ YJP $ $ - [ @ twall ] ( https : / / github . com / twall ) . 
 * Added ` jna . debug _ load ` property to diagnose library loading issues - [ @ twall ] ( https : / / github . com / twall ) . 
 * Throw explicit ` IllegalArgumentException ` when ` Structure . ByReference ` is used where it shouldn ' t be ( can result in multiply freed memory or other unexpected behavior ) - [ @ twall ] ( https : / / github . com / twall ) . 
 + * [ # 243 ] ( https : / / github . com / twall / jna / issues / 243 ) : Automatically accommodate long library paths on Windows which would otherwise fail - [ @ twall ] ( https : / / github . com / twall ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 diff - - git a / lib / native / win32 - x86 . jar b / lib / native / win32 - x86 . jar 
 index 6d465bb . . 4e7c979 100755 
 Binary files a / lib / native / win32 - x86 . jar and b / lib / native / win32 - x86 . jar differ 
 diff - - git a / native / dispatch . c b / native / dispatch . c 
 index 931a790 . . 71fd083 100644 
 - - - a / native / dispatch . c 
 + + + b / native / dispatch . c 
 @ @ - 21 , 7 + 21 , 7 @ @ 
 # include < windows . h > 
 # include < psapi . h > 
 # define STRTYPE wchar _ t * 
 - # define NAME2CSTR ( ENV , JSTR ) newWideCString ( ENV , JSTR ) 
 + # define NAME2CSTR ( ENV , JSTR ) w32 _ short _ name ( ENV , JSTR ) 
 # ifdef _ WIN32 _ WCE 
 # include < tlhelp32 . h > 
 # define DEFAULT _ LOAD _ OPTS 0 / * altered search path unsupported on CE * / 
 @ @ - 98 , 81 + 98 , 6 @ @ static int _ protect ; 
 extern " C " { 
 # endif 
 
 - # ifdef _ WIN32 
 - static char * 
 - w32 _ format _ error ( int err , char * buf , int len ) { 
 - wchar _ t * wbuf = NULL ; 
 - int wlen = 
 - FormatMessageW ( FORMAT _ MESSAGE _ FROM _ SYSTEM 
 - | FORMAT _ MESSAGE _ IGNORE _ INSERTS 
 - | FORMAT _ MESSAGE _ ALLOCATE _ BUFFER , 
 - NULL , err , 0 , ( LPWSTR ) & wbuf , 0 , NULL ) ; 
 - if ( wlen > 0 ) { 
 - int result = WideCharToMultiByte ( CP _ UTF8 , 0 , wbuf , - 1 , buf , len , NULL , NULL ) ; 
 - if ( result = = 0 ) { 
 - fprintf ( stderr , " JNA : error converting error message : % d \ n " , ( int ) GET _ LAST _ ERROR ( ) ) ; 
 - * buf = 0 ; 
 - } 
 - else { 
 - buf [ len - 1 ] = 0 ; 
 - } 
 - } 
 - else { 
 - / / Error retrieving message 
 - * buf = 0 ; 
 - } 
 - if ( wbuf ) { 
 - LocalFree ( wbuf ) ; 
 - } 
 - 
 - return buf ; 
 - } 
 - static HANDLE 
 - w32 _ find _ entry ( JNIEnv * env , HANDLE handle , const char * funname ) { 
 - void * func = NULL ; 
 - if ( handle ! = GetModuleHandle ( NULL ) ) { 
 - func = GetProcAddress ( handle , funname ) ; 
 - } 
 - else { 
 - # if defined ( _ WIN32 _ WCE ) 
 - / * CE has no EnumProcessModules , have to use an alternate API * / 
 - HANDLE snapshot ; 
 - if ( ( snapshot = CreateToolhelp32Snapshot ( TH32CS _ SNAPMODULE , 0 ) ) ! = INVALID _ HANDLE _ VALUE ) { 
 - MODULEENTRY32 moduleInfo ; 
 - moduleInfo . dwSize = sizeof ( moduleInfo ) ; 
 - if ( Module32First ( snapshot , & moduleInfo ) ) { 
 - do { 
 - if ( ( func = ( void * ) GetProcAddress ( moduleInfo . hModule , funname ) ) ) { 
 - break ; 
 - } 
 - } while ( Module32Next ( snapshot , & moduleInfo ) ) ; 
 - } 
 - CloseToolhelp32Snapshot ( snapshot ) ; 
 - } 
 - # else 
 - HANDLE cur _ proc = GetCurrentProcess ( ) ; 
 - HMODULE * modules ; 
 - DWORD needed , i ; 
 - if ( ! EnumProcessModules ( cur _ proc , NULL , 0 , & needed ) ) { 
 - fail : 
 - throwByName ( env , EError , " Unexpected error enumerating modules " ) ; 
 - return 0 ; 
 - } 
 - modules = ( HMODULE * ) alloca ( needed ) ; 
 - if ( ! EnumProcessModules ( cur _ proc , modules , needed , & needed ) ) { 
 - goto fail ; 
 - } 
 - for ( i = 0 ; i < needed / sizeof ( HMODULE ) ; i + + ) { 
 - if ( ( func = ( void * ) GetProcAddress ( modules [ i ] , funname ) ) ) { 
 - break ; 
 - } 
 - } 
 - # endif 
 - } 
 - return func ; 
 - } 
 - # endif / * _ WIN32 * / 
 - 
 # define MEMCPY ( ENV , D , S , L ) do { \ 
 PSTART ( ) ; memcpy ( D , S , L ) ; PEND ( ENV ) ; \ 
 } while ( 0 ) 
 @ @ - 304 , 6 + 229 , 118 @ @ static ffi _ type * getStructureType ( JNIEnv * , jobject ) ; 
 
 typedef void ( JNICALL * release _ t ) ( JNIEnv * , jarray , void * , jint ) ; 
 
 + # ifdef _ WIN32 
 + static char * 
 + w32 _ format _ error ( int err , char * buf , int len ) { 
 + wchar _ t * wbuf = NULL ; 
 + int wlen = 
 + FormatMessageW ( FORMAT _ MESSAGE _ FROM _ SYSTEM 
 + | FORMAT _ MESSAGE _ IGNORE _ INSERTS 
 + | FORMAT _ MESSAGE _ ALLOCATE _ BUFFER , 
 + NULL , err , 0 , ( LPWSTR ) & wbuf , 0 , NULL ) ; 
 + if ( wlen > 0 ) { 
 + int result = WideCharToMultiByte ( CP _ UTF8 , 0 , wbuf , - 1 , buf , len , NULL , NULL ) ; 
 + if ( result = = 0 ) { 
 + fprintf ( stderr , " JNA : error converting error message : % d \ n " , ( int ) GET _ LAST _ ERROR ( ) ) ; 
 + * buf = 0 ; 
 + } 
 + else { 
 + buf [ len - 1 ] = 0 ; 
 + } 
 + } 
 + else { 
 + / / Error retrieving message 
 + * buf = 0 ; 
 + } 
 + if ( wbuf ) { 
 + LocalFree ( wbuf ) ; 
 + } 
 + 
 + return buf ; 
 + } 
 + static wchar _ t * 
 + w32 _ short _ name ( JNIEnv * env , jstring str ) { 
 + wchar _ t * wstr = newWideCString ( env , str ) ; 
 + if ( wstr & & * wstr ) { 
 + DWORD required ; 
 + size _ t size = wcslen ( wstr ) + 5 ; 
 + wchar _ t * prefixed = ( wchar _ t * ) alloca ( sizeof ( wchar _ t ) * size ) ; 
 + 
 + # ifdef _ MSC _ VER 
 + swprintf ( prefixed , size , L " \ \ \ \ ? \ \ % ls " , wstr ) ; 
 + # else 
 + swprintf ( prefixed , L " \ \ \ \ ? \ \ % ls " , wstr ) ; 
 + # endif 
 + if ( ( required = GetShortPathNameW ( prefixed , NULL , 0 ) ) ! = 0 ) { 
 + wchar _ t * wshort = ( wchar _ t * ) malloc ( sizeof ( wchar _ t ) * required ) ; 
 + if ( GetShortPathNameW ( prefixed , wshort , required ) ) { 
 + free ( ( void * ) wstr ) ; 
 + wstr = wshort ; 
 + } 
 + else { 
 + char buf [ MSG _ SIZE ] ; 
 + throwByName ( env , EError , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; 
 + free ( ( void * ) wstr ) ; 
 + free ( ( void * ) wshort ) ; 
 + wstr = NULL ; 
 + } 
 + } 
 + else if ( GET _ LAST _ ERROR ( ) ! = ERROR _ FILE _ NOT _ FOUND ) { 
 + char buf [ MSG _ SIZE ] ; 
 + throwByName ( env , EError , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; 
 + free ( ( void * ) wstr ) ; 
 + wstr = NULL ; 
 + } 
 + } 
 + return wstr ; 
 + } 
 + 
 + static HANDLE 
 + w32 _ find _ entry ( JNIEnv * env , HANDLE handle , const char * funname ) { 
 + void * func = NULL ; 
 + if ( handle ! = GetModuleHandle ( NULL ) ) { 
 + func = GetProcAddress ( handle , funname ) ; 
 + } 
 + else { 
 + # if defined ( _ WIN32 _ WCE ) 
 + / * CE has no EnumProcessModules , have to use an alternate API * / 
 + HANDLE snapshot ; 
 + if ( ( snapshot = CreateToolhelp32Snapshot ( TH32CS _ SNAPMODULE , 0 ) ) ! = INVALID _ HANDLE _ VALUE ) { 
 + MODULEENTRY32 moduleInfo ; 
 + moduleInfo . dwSize = sizeof ( moduleInfo ) ; 
 + if ( Module32First ( snapshot , & moduleInfo ) ) { 
 + do { 
 + if ( ( func = ( void * ) GetProcAddress ( moduleInfo . hModule , funname ) ) ) { 
 + break ; 
 + } 
 + } while ( Module32Next ( snapshot , & moduleInfo ) ) ; 
 + } 
 + CloseToolhelp32Snapshot ( snapshot ) ; 
 + } 
 + # else 
 + HANDLE cur _ proc = GetCurrentProcess ( ) ; 
 + HMODULE * modules ; 
 + DWORD needed , i ; 
 + if ( ! EnumProcessModules ( cur _ proc , NULL , 0 , & needed ) ) { 
 + fail : 
 + throwByName ( env , EError , " Unexpected error enumerating modules " ) ; 
 + return 0 ; 
 + } 
 + modules = ( HMODULE * ) alloca ( needed ) ; 
 + if ( ! EnumProcessModules ( cur _ proc , modules , needed , & needed ) ) { 
 + goto fail ; 
 + } 
 + for ( i = 0 ; i < needed / sizeof ( HMODULE ) ; i + + ) { 
 + if ( ( func = ( void * ) GetProcAddress ( modules [ i ] , funname ) ) ) { 
 + break ; 
 + } 
 + } 
 + # endif 
 + } 
 + return func ; 
 + } 
 + # endif / * _ WIN32 * / 
 + 
 # if 0 
 / * * Invokes System . err . println ( for debugging only ) . * / 
 void 
 @ @ - 621 , 6 + 658 , 8 @ @ getChars ( JNIEnv * env , wchar _ t * volatile dst , jcharArray chars , volatile jint off 
 int i ; 
 ( * env ) - > GetCharArrayRegion ( env , chars , off , count , buf ) ; 
 for ( i = 0 ; i < count ; i + + ) { 
 + / / TODO : ensure proper encoding conversion from jchar to native 
 + / / wchar _ t 
 dst [ i ] = ( wchar _ t ) buf [ i ] ; 
 } 
 dst + = count ; 
 @ @ - 725 , 13 + 764 , 16 @ @ newCStringEncoding ( JNIEnv * env , jstring jstr , const char * encoding ) 
 / * Translates a Java string to a wide C string using the String . toCharArray 
 * method . 
 * / 
 - / / TODO : are any encoding changes required ? 
 static wchar _ t * 
 newWideCString ( JNIEnv * env , jstring str ) 
 { 
 jcharArray chars = 0 ; 
 wchar _ t * result = NULL ; 
 
 + if ( ( * env ) - > IsSameObject ( env , str , NULL ) ) { 
 + return result ; 
 + } 
 + 
 chars = ( * env ) - > CallObjectMethod ( env , str , MID _ String _ toCharArray ) ; 
 if ( ! ( * env ) - > ExceptionCheck ( env ) ) { 
 jint len = ( * env ) - > GetArrayLength ( env , chars ) ; 
 @ @ - 741 , 7 + 783 , 6 @ @ newWideCString ( JNIEnv * env , jstring str ) 
 throwByName ( env , EOutOfMemory , " Can ' t allocate wide C string " ) ; 
 return NULL ; 
 } 
 - / / TODO : ensure proper encoding conversion from jchar to native wchar _ t 
 getChars ( env , result , chars , 0 , len ) ; 
 if ( ( * env ) - > ExceptionCheck ( env ) ) { 
 free ( ( void * ) result ) ; 
 @ @ - 1816 , 8 + 1857 , 9 @ @ method _ handler ( ffi _ cif * cif , void * volatile resp , void * * argp , void * cdata ) { 
 case CVT _ ARRAY _ LONG : 
 case CVT _ ARRAY _ FLOAT : 
 case CVT _ ARRAY _ DOUBLE : 
 - if ( * ( void * * ) args [ i ] & & release [ i ] ) 
 + if ( * ( void * * ) args [ i ] & & release [ i ] ! = NULL ) { 
 release [ i ] ( env , objects [ i ] , elems [ i ] , 0 ) ; 
 + } 
 break ; 
 } 
 } 
 @ @ - 2036 , 7 + 2078 , 7 @ @ Java _ com _ sun _ jna _ Native _ open ( JNIEnv * env , jclass UNUSED ( cls ) , jstring lib , jint 
 
 handle = ( void * ) LOAD _ LIBRARY ( libname , flags ! = - 1 ? flags : DEFAULT _ LOAD _ OPTS ) ; 
 if ( ! handle ) { 
 - char buf [ 1024 ] ; 
 + char buf [ MSG _ SIZE ] ; 
 throwByName ( env , EUnsatisfiedLink , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; 
 } 
 if ( libname ! = NULL ) { 
 @ @ - 2054 , 7 + 2096 , 7 @ @ JNIEXPORT void JNICALL 
 Java _ com _ sun _ jna _ Native _ close ( JNIEnv * env , jclass UNUSED ( cls ) , jlong handle ) 
 { 
 if ( FREE _ LIBRARY ( L2A ( handle ) ) ) { 
 - char buf [ 1024 ] ; 
 + char buf [ MSG _ SIZE ] ; 
 throwByName ( env , EError , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; 
 } 
 } 
 @ @ - 2075 , 7 + 2117 , 7 @ @ Java _ com _ sun _ jna _ Native _ findSymbol ( JNIEnv * env , jclass UNUSED ( cls ) , 
 if ( funname ! = NULL ) { 
 func = ( void * ) FIND _ ENTRY ( handle , funname ) ; 
 if ( ! func ) { 
 - char buf [ 1024 ] ; 
 + char buf [ MSG _ SIZE ] ; 
 throwByName ( env , EUnsatisfiedLink , LOAD _ ERROR ( buf , sizeof ( buf ) ) ) ; 
 } 
 free ( ( void * ) funname ) ; 
 diff - - git a / test / com / sun / jna / LibraryLoadTest . java b / test / com / sun / jna / LibraryLoadTest . java 
 index 6fc8c74 . . 8c00d95 100644 
 - - - a / test / com / sun / jna / LibraryLoadTest . java 
 + + + b / test / com / sun / jna / LibraryLoadTest . java 
 @ @ - 164 , 6 + 164 , 31 @ @ public class LibraryLoadTest extends TestCase implements Paths { 
 } 
 } 
 
 + public void testLoadLibraryWithLongName ( ) throws Exception { 
 + File tmpdir = Native . getTempDir ( ) ; 
 + String libName = NativeLibrary . mapSharedLibraryName ( " testlib " ) ; 
 + File src = new File ( TESTPATH , libName ) ; 
 + assertTrue ( " Expected JNA native library at " + src + " is missing " , src . exists ( ) ) ; 
 + 
 + for ( int i = 0 ; i < 16 ; i + + ) { 
 + tmpdir = new File ( tmpdir , " subdir0123456789 " ) ; 
 + tmpdir . deleteOnExit ( ) ; 
 + } 
 + 
 + final String NAME = getName ( ) ; 
 + String newLibName = libName . replace ( " testlib " , NAME ) ; 
 + tmpdir . mkdirs ( ) ; 
 + File dst = new File ( tmpdir , newLibName ) ; 
 + copy ( src , dst ) ; 
 + try { 
 + NativeLibrary . getInstance ( NAME , new TestLoader ( tmpdir ) ) ; 
 + dst . deleteOnExit ( ) ; 
 + } 
 + catch ( UnsatisfiedLinkError e ) { 
 + fail ( " Library ' " + newLibName + " ' at " + dst + " could not be loaded : " + e ) ; 
 + } 
 + } 
 + 
 public void testLoadFrameworkLibrary ( ) { 
 if ( Platform . isMac ( ) ) { 
 final String PATH = " / System / Library / Frameworks / CoreServices . framework " ;

NEAREST DIFF:
ELIMINATEDSENTENCE
