BLEU SCORE: 0.3680705440519071

TEST MSG: Added ` com . sun . jna . platform . win32 . Kernel32 . GetPrivateProfileSection ` , ` GetPrivateProfileSectionNames ` and ` WritePrivateProfileSection ` and corresponding ` Kernel32Util ` helpers .
GENERATED MSG: Add platform . win32 . Kernel32 . DeleteFile and com . sun . jna . platform . win32 . deleteFile .

TEST DIFF (one line): diff - - git a / CHANGES . md b / CHANGES . md <nl> index 8f80852 . . 7e7bb25 100644 <nl> - - - a / CHANGES . md <nl> + + + b / CHANGES . md <nl> @ @ - 15 , 6 + 15 , 7 @ @ Features <nl> * [ # 101 ] ( https : / / github . com / twall / jna / issues / 101 ) : Modify ` com . sun . jna . platform . win32 . Advapi32Util . registryGet * ` API to support ` KEY _ WOW64 ` option - [ @ falldog ] ( https : / / github . com / falldog ) . <nl> * [ # 271 ] ( https : / / github . com / twall / jna / pull / 271 ) : Added ` com . sun . jna . platform . win32 . Gdi32 . ChoosePixelFormat ` and ` SetPixelFormat ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . <nl> * [ # 271 ] ( https : / / github . com / twall / jna / pull / 271 ) : Added ` com . sun . jna . platform . win32 . OpenGL32 ` , ` OpenGL32Util ` and ` WinOpenGL ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . <nl> + * [ # 250 ] ( https : / / github . com / twall / jna / pull / 250 ) : Added ` com . sun . jna . platform . win32 . Kernel32 . GetPrivateProfileSection ` , ` GetPrivateProfileSectionNames ` and ` WritePrivateProfileSection ` and corresponding ` Kernel32Util ` helpers - [ @ quipsy - karg ] ( https : / / github . com / quipsy - karg ) . <nl> <nl> Bug Fixes <nl> - - - - - - - - - <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java <nl> index 156544e . . 755d90c 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java <nl> @ @ - 1981 , 4 + 1981 , 65 @ @ public interface Kernel32 extends WinNT { <nl> * / <nl> boolean WritePrivateProfileString ( String lpAppName , String lpKeyName , <nl> String lpString , String lpFileName ) ; <nl> + <nl> + / * * <nl> + * Retrieves all the keys and values for the specified section of an initialization file . <nl> + * <nl> + * < p > <nl> + * Each string has the following format : { @ code key = string } . <nl> + * < / p > <nl> + * < p > <nl> + * This operation is atomic ; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied <nl> + * to the buffer pointed to by the { @ code lpReturnedString } parameter . <nl> + * < / p > <nl> + * <nl> + * @ param lpAppName <nl> + * The name of the section in the initialization file . <nl> + * @ param lpReturnedString <nl> + * A buffer that receives the key name and value pairs associated with the named section . The buffer is filled with one or more { @ code null } <nl> + * - terminated strings ; the last string is followed by a second { @ code null } character . <nl> + * @ param nSize <nl> + * The size of the buffer pointed to by the { @ code lpReturnedString } parameter , in characters . The maximum profile section size is 32 , 767 <nl> + * characters . <nl> + * @ param lpFileName <nl> + * The name of the initialization file . If this parameter does not contain a full path to the file , the system searches for the file in the <nl> + * Windows directory . <nl> + * @ return The number of characters copied to the buffer , not including the terminating null character . If the buffer is not large enough to contain all the <nl> + * key name and value pairs associated with the named section , the return value is equal to { @ code nSize } minus two . <nl> + * / <nl> + DWORD GetPrivateProfileSection ( String lpAppName , char [ ] lpReturnedString , DWORD nSize , String lpFileName ) ; <nl> + <nl> + / * * <nl> + * Retrieves the names of all sections in an initialization file . <nl> + * < p > <nl> + * This operation is atomic ; no updates to the initialization file are allowed while the section names are being copied to the buffer . <nl> + * < / p > <nl> + * <nl> + * @ param lpszReturnBuffer <nl> + * A pointer to a buffer that receives the section names associated with the named file . The buffer is filled with one or more { @ code null } <nl> + * - terminated strings ; the last string is followed by a second { @ code null } character . <nl> + * @ param nSize <nl> + * size of the buffer pointed to by the { @ code lpszReturnBuffer } parameter , in characters . <nl> + * @ param lpFileName <nl> + * The name of the initialization file . If this parameter is { @ code NULL } , the function searches the Win . ini file . If this parameter does not <nl> + * contain a full path to the file , the system searches for the file in the Windows directory . <nl> + * @ return The return value specifies the number of characters copied to the specified buffer , not including the terminating { @ code null } character . If the <nl> + * buffer is not large enough to contain all the section names associated with the specified initialization file , the return value is equal to the <nl> + * size specified by { @ code nSize } minus two . <nl> + * / <nl> + DWORD GetPrivateProfileSectionNames ( char [ ] lpszReturnBuffer , DWORD nSize , String lpFileName ) ; <nl> + <nl> + / * * <nl> + * @ param lpAppName <nl> + * The name of the section in which data is written . This section name is typically the name of the calling application . <nl> + * @ param lpString <nl> + * The new key names and associated values that are to be written to the named section . This string is limited to 65 , 535 bytes . Must be filled <nl> + * with zero or many { @ code null } - terminated strings of the form { @ code key = value } , appended by an additional { @ code null } byte to terminate the <nl> + * list . <nl> + * @ param lpFileName <nl> + * The name of the initialization file . If this parameter does not contain a full path for the file , the function searches the Windows directory <nl> + * for the file . If the file does not exist and lpFileName does not contain a full path , the function creates the file in the Windows directory . <nl> + * @ return If the function succeeds , the return value is nonzero . If the function fails , the return value is zero . <nl> + * / <nl> + boolean WritePrivateProfileSection ( String lpAppName , String lpString , String lpFileName ) ; <nl> } <nl> \ No newline at end of file <nl> diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java <nl> index 29ca050 . . aa0f889 100644 <nl> - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java <nl> + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java <nl> @ @ - 362 , 4 + 362 , 67 @ @ public abstract class Kernel32Util implements WinDef { <nl> return ( WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION [ ] ) firstInformation <nl> . toArray ( new WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION [ returnedStructCount ] ) ; <nl> } <nl> + <nl> + / * * <nl> + * Retrieves all the keys and values for the specified section of an initialization file . <nl> + * <nl> + * < p > <nl> + * Each string has the following format : { @ code key = string } . <nl> + * < / p > <nl> + * < p > <nl> + * This operation is atomic ; no updates to the specified initialization file are allowed while this method is executed . <nl> + * < / p > <nl> + * <nl> + * @ param appName <nl> + * The name of the section in the initialization file . <nl> + * @ param fileName <nl> + * The name of the initialization file . If this parameter does not contain a full path to the file , the system searches for the file in the <nl> + * Windows directory . <nl> + * @ return The key name and value pairs associated with the named section . <nl> + * / <nl> + public static final String [ ] getPrivateProfileSection ( final String appName , final String fileName ) { <nl> + final char buffer [ ] = new char [ 32768 ] ; / / Maximum section size according to MSDN ( http : / / msdn . microsoft . com / en - us / library / windows / desktop / ms724348 ( v = vs . 85 ) . aspx ) <nl> + if ( Kernel32 . INSTANCE . GetPrivateProfileSection ( appName , buffer , new DWORD ( buffer . length ) , fileName ) . intValue ( ) = = 0 ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + return new String ( buffer ) . split ( " \ 0 " ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieves the names of all sections in an initialization file . <nl> + * < p > <nl> + * This operation is atomic ; no updates to the initialization file are allowed while this method is executed . <nl> + * < / p > <nl> + * <nl> + * @ param fileName <nl> + * The name of the initialization file . If this parameter is { @ code NULL } , the function searches the Win . ini file . If this parameter does not <nl> + * contain a full path to the file , the system searches for the file in the Windows directory . <nl> + * @ return the section names associated with the named file . <nl> + * / <nl> + public static final String [ ] getPrivateProfileSectionNames ( final String fileName ) { <nl> + final char buffer [ ] = new char [ 65536 ] ; / / Maximum INI file size according to MSDN ( http : / / support . microsoft . com / kb / 78346 ) <nl> + if ( Kernel32 . INSTANCE . GetPrivateProfileSectionNames ( buffer , new DWORD ( buffer . length ) , fileName ) . intValue ( ) = = 0 ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + return new String ( buffer ) . split ( " \ 0 " ) ; <nl> + } <nl> + <nl> + / * * <nl> + * @ param appName <nl> + * The name of the section in which data is written . This section name is typically the name of the calling application . <nl> + * @ param strings <nl> + * The new key names and associated values that are to be written to the named section . Each entry must be of the form { @ code key = value } . <nl> + * @ param fileName <nl> + * The name of the initialization file . If this parameter does not contain a full path for the file , the function searches the Windows directory <nl> + * for the file . If the file does not exist and lpFileName does not contain a full path , the function creates the file in the Windows directory . <nl> + * / <nl> + public static final void writePrivateProfileSection ( final String appName , final String [ ] strings , final String fileName ) { <nl> + final StringBuilder buffer = new StringBuilder ( ) ; <nl> + for ( final String string : strings ) <nl> + buffer . append ( string ) . append ( ' \ 0 ' ) ; <nl> + buffer . append ( ' \ 0 ' ) ; <nl> + if ( ! Kernel32 . INSTANCE . WritePrivateProfileSection ( appName , buffer . toString ( ) , fileName ) ) { <nl> + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32Test . java <nl> index 91d83de . . 81e913b 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32Test . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32Test . java <nl> @ @ - 531 , 4 + 531 , 66 @ @ public class Kernel32Test extends TestCase { <nl> assertEquals ( reader . readLine ( ) , null ) ; <nl> reader . close ( ) ; <nl> } <nl> + <nl> + public final void testGetPrivateProfileSection ( ) throws IOException { <nl> + final File tmp = File . createTempFile ( " testGetPrivateProfileSection " , " . ini " ) ; <nl> + tmp . deleteOnExit ( ) ; <nl> + <nl> + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; <nl> + try { <nl> + writer . println ( " [ X ] " ) ; <nl> + writer . println ( " A = 1 " ) ; <nl> + writer . println ( " B = X " ) ; <nl> + } finally { <nl> + writer . close ( ) ; <nl> + } <nl> + <nl> + final char [ ] buffer = new char [ 9 ] ; <nl> + final DWORD len = Kernel32 . INSTANCE . GetPrivateProfileSection ( " X " , buffer , new DWORD ( buffer . length ) , tmp . getCanonicalPath ( ) ) ; <nl> + <nl> + assertEquals ( len . intValue ( ) , 7 ) ; <nl> + assertEquals ( new String ( buffer ) , " A = 1 \ 0B = X \ 0 \ 0 " ) ; <nl> + } <nl> + <nl> + public final void testGetPrivateProfileSectionNames ( ) throws IOException { <nl> + final File tmp = File . createTempFile ( " testGetPrivateProfileSectionNames " , " . ini " ) ; <nl> + tmp . deleteOnExit ( ) ; <nl> + <nl> + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; <nl> + try { <nl> + writer . println ( " [ S1 ] " ) ; <nl> + writer . println ( " [ S2 ] " ) ; <nl> + } finally { <nl> + writer . close ( ) ; <nl> + } <nl> + <nl> + final char [ ] buffer = new char [ 7 ] ; <nl> + final DWORD len = Kernel32 . INSTANCE . GetPrivateProfileSectionNames ( buffer , new DWORD ( buffer . length ) , tmp . getCanonicalPath ( ) ) ; <nl> + assertEquals ( len . intValue ( ) , 5 ) ; <nl> + assertEquals ( new String ( buffer ) , " S1 \ 0S2 \ 0 \ 0 " ) ; <nl> + } <nl> + <nl> + public final void testWritePrivateProfileSection ( ) throws IOException { <nl> + final File tmp = File . createTempFile ( " testWritePrivateProfileSection " , " . ini " ) ; <nl> + tmp . deleteOnExit ( ) ; <nl> + <nl> + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; <nl> + try { <nl> + writer . println ( " [ S1 ] " ) ; <nl> + writer . println ( " A = 1 " ) ; <nl> + writer . println ( " B = X " ) ; <nl> + } finally { <nl> + writer . close ( ) ; <nl> + } <nl> + <nl> + final boolean result = Kernel32 . INSTANCE . WritePrivateProfileSection ( " S1 " , " A = 3 \ 0E = Z \ 0 \ 0 " , tmp . getCanonicalPath ( ) ) ; <nl> + assertTrue ( result ) ; <nl> + <nl> + final BufferedReader reader = new BufferedReader ( new FileReader ( tmp ) ) ; <nl> + assertEquals ( reader . readLine ( ) , " [ S1 ] " ) ; <nl> + assertTrue ( reader . readLine ( ) . matches ( " A \ \ s * = \ \ s * 3 " ) ) ; <nl> + assertTrue ( reader . readLine ( ) . matches ( " E \ \ s * = \ \ s * Z " ) ) ; <nl> + reader . close ( ) ; <nl> + } <nl> + <nl> } <nl> diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java <nl> index a31a947 . . 3bf889d 100644 <nl> - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java <nl> + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java <nl> @ @ - 180 , 4 + 180 , 76 @ @ public class Kernel32UtilTest extends TestCase { <nl> assertEquals ( reader . readLine ( ) , null ) ; <nl> reader . close ( ) ; <nl> } <nl> + <nl> + public final void testGetPrivateProfileSection ( ) throws IOException { <nl> + final File tmp = File . createTempFile ( " testGetPrivateProfileSection " , " . ini " ) ; <nl> + tmp . deleteOnExit ( ) ; <nl> + <nl> + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; <nl> + try { <nl> + writer . println ( " [ X ] " ) ; <nl> + writer . println ( " A = 1 " ) ; <nl> + writer . println ( " foo = bar " ) ; <nl> + } finally { <nl> + writer . close ( ) ; <nl> + } <nl> + <nl> + final String [ ] lines = Kernel32Util . getPrivateProfileSection ( " X " , tmp . getCanonicalPath ( ) ) ; <nl> + assertEquals ( lines . length , 2 ) ; <nl> + assertEquals ( lines [ 0 ] , " A = 1 " ) ; <nl> + assertEquals ( lines [ 1 ] , " foo = bar " ) ; <nl> + } <nl> + <nl> + public final void testGetPrivateProfileSectionNames ( ) throws IOException { <nl> + final File tmp = File . createTempFile ( " testGetPrivateProfileSectionNames " , " ini " ) ; <nl> + tmp . deleteOnExit ( ) ; <nl> + <nl> + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; <nl> + try { <nl> + writer . println ( " [ S1 ] " ) ; <nl> + writer . println ( " A = 1 " ) ; <nl> + writer . println ( " B = X " ) ; <nl> + writer . println ( " [ S2 ] " ) ; <nl> + writer . println ( " C = 2 " ) ; <nl> + writer . println ( " D = Y " ) ; <nl> + } finally { <nl> + writer . close ( ) ; <nl> + } <nl> + <nl> + String [ ] sectionNames = Kernel32Util . getPrivateProfileSectionNames ( tmp . getCanonicalPath ( ) ) ; <nl> + assertEquals ( sectionNames . length , 2 ) ; <nl> + assertEquals ( sectionNames [ 0 ] , " S1 " ) ; <nl> + assertEquals ( sectionNames [ 1 ] , " S2 " ) ; <nl> + } <nl> + <nl> + public final void testWritePrivateProfileSection ( ) throws IOException { <nl> + final File tmp = File . createTempFile ( " testWritePrivateProfileSecion " , " ini " ) ; <nl> + tmp . deleteOnExit ( ) ; <nl> + <nl> + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; <nl> + try { <nl> + writer . println ( " [ S1 ] " ) ; <nl> + writer . println ( " A = 1 " ) ; <nl> + writer . println ( " B = X " ) ; <nl> + writer . println ( " [ S2 ] " ) ; <nl> + writer . println ( " C = 2 " ) ; <nl> + writer . println ( " foo = bar " ) ; <nl> + } finally { <nl> + writer . close ( ) ; <nl> + } <nl> + <nl> + Kernel32Util . writePrivateProfileSection ( " S1 " , new String [ ] { " A = 3 " , " E = Z " } , tmp . getCanonicalPath ( ) ) ; <nl> + <nl> + final BufferedReader reader = new BufferedReader ( new FileReader ( tmp ) ) ; <nl> + try { <nl> + assertEquals ( reader . readLine ( ) , " [ S1 ] " ) ; <nl> + assertEquals ( reader . readLine ( ) , " A = 3 " ) ; <nl> + assertEquals ( reader . readLine ( ) , " E = Z " ) ; <nl> + assertEquals ( reader . readLine ( ) , " [ S2 ] " ) ; <nl> + assertEquals ( reader . readLine ( ) , " C = 2 " ) ; <nl> + assertEquals ( reader . readLine ( ) , " foo = bar " ) ; <nl> + } finally { <nl> + reader . close ( ) ; <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c <nl> index 383d49f . . b3450f8 100644 <nl> - - - a / jnalib / native / dispatch . c <nl> + + + b / jnalib / native / dispatch . c <nl> @ @ - 992 , 7 + 992 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1write _ _ J _ 3SII <nl> * Signature : ( JB ) J <nl> * / <nl> JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1indexOf _ _ JB <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> { <nl> jbyte * peer = ( jbyte * ) L2A ( addr ) ; <nl> volatile jlong i = 0 ; <nl> @ @ - 1103 , 7 + 1103 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1read _ _ J _ 3SII <nl> * Signature : ( J ) B <nl> * / <nl> JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jbyte res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1116 , 7 + 1116 , 7 @ @ JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte <nl> * Signature : ( J ) C <nl> * / <nl> JNIEXPORT jchar JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getChar <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> wchar _ t res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1153 , 7 + 1153 , 7 @ @ JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDirectByteBuffer <nl> * Signature : ( J ) D <nl> * / <nl> JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jdouble res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1166 , 7 + 1166 , 7 @ @ JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble <nl> * Signature : ( J ) F <nl> * / <nl> JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jfloat res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1179 , 7 + 1179 , 7 @ @ JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat <nl> * Signature : ( J ) I <nl> * / <nl> JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jint res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1192 , 7 + 1192 , 7 @ @ JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt <nl> * Signature : ( J ) J <nl> * / <nl> JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jlong res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1205 , 7 + 1205 , 7 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong <nl> * Signature : ( J ) S <nl> * / <nl> JNIEXPORT jshort JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getShort <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) <nl> { <nl> jshort res = 0 ; <nl> MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; <nl> @ @ - 1229 , 7 + 1229 , 7 @ @ JNIEXPORT jstring JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getString <nl> * Signature : ( JJB ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) <nl> { <nl> MEMSET ( L2A ( addr ) , ( int ) value , ( size _ t ) count ) ; <nl> } <nl> @ @ - 1240 , 7 + 1240 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory <nl> * Signature : ( JB ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1251 , 7 + 1251 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte <nl> * Signature : ( JC ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jchar value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jchar value ) <nl> { <nl> wchar _ t ch = value ; <nl> MEMCPY ( L2A ( addr ) , & ch , sizeof ( ch ) ) ; <nl> @ @ - 1263 , 7 + 1263 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar <nl> * Signature : ( JJ ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> { <nl> void * ptr = L2A ( value ) ; <nl> MEMCPY ( L2A ( addr ) , & ptr , sizeof ( void * ) ) ; <nl> @ @ - 1275 , 7 + 1275 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer <nl> * Signature : ( JD ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jdouble value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jdouble value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1286 , 7 + 1286 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble <nl> * Signature : ( JF ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jfloat value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jfloat value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1297 , 7 + 1297 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat <nl> * Signature : ( JI ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jint value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jint value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1308 , 7 + 1308 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt <nl> * Signature : ( JJ ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> } <nl> @ @ - 1319 , 7 + 1319 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong <nl> * Signature : ( JS ) V <nl> * / <nl> JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setShort <nl> - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jshort value ) <nl> + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jshort value ) <nl> { <nl> MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; <nl> }

TEST DIFF:
diff - - git a / CHANGES . md b / CHANGES . md 
 index 8f80852 . . 7e7bb25 100644 
 - - - a / CHANGES . md 
 + + + b / CHANGES . md 
 @ @ - 15 , 6 + 15 , 7 @ @ Features 
 * [ # 101 ] ( https : / / github . com / twall / jna / issues / 101 ) : Modify ` com . sun . jna . platform . win32 . Advapi32Util . registryGet * ` API to support ` KEY _ WOW64 ` option - [ @ falldog ] ( https : / / github . com / falldog ) . 
 * [ # 271 ] ( https : / / github . com / twall / jna / pull / 271 ) : Added ` com . sun . jna . platform . win32 . Gdi32 . ChoosePixelFormat ` and ` SetPixelFormat ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . 
 * [ # 271 ] ( https : / / github . com / twall / jna / pull / 271 ) : Added ` com . sun . jna . platform . win32 . OpenGL32 ` , ` OpenGL32Util ` and ` WinOpenGL ` - [ @ kc7bfi ] ( https : / / github . com / kc7bfi ) . 
 + * [ # 250 ] ( https : / / github . com / twall / jna / pull / 250 ) : Added ` com . sun . jna . platform . win32 . Kernel32 . GetPrivateProfileSection ` , ` GetPrivateProfileSectionNames ` and ` WritePrivateProfileSection ` and corresponding ` Kernel32Util ` helpers - [ @ quipsy - karg ] ( https : / / github . com / quipsy - karg ) . 
 
 Bug Fixes 
 - - - - - - - - - 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java 
 index 156544e . . 755d90c 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32 . java 
 @ @ - 1981 , 4 + 1981 , 65 @ @ public interface Kernel32 extends WinNT { 
 * / 
 boolean WritePrivateProfileString ( String lpAppName , String lpKeyName , 
 String lpString , String lpFileName ) ; 
 + 
 + / * * 
 + * Retrieves all the keys and values for the specified section of an initialization file . 
 + * 
 + * < p > 
 + * Each string has the following format : { @ code key = string } . 
 + * < / p > 
 + * < p > 
 + * This operation is atomic ; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied 
 + * to the buffer pointed to by the { @ code lpReturnedString } parameter . 
 + * < / p > 
 + * 
 + * @ param lpAppName 
 + * The name of the section in the initialization file . 
 + * @ param lpReturnedString 
 + * A buffer that receives the key name and value pairs associated with the named section . The buffer is filled with one or more { @ code null } 
 + * - terminated strings ; the last string is followed by a second { @ code null } character . 
 + * @ param nSize 
 + * The size of the buffer pointed to by the { @ code lpReturnedString } parameter , in characters . The maximum profile section size is 32 , 767 
 + * characters . 
 + * @ param lpFileName 
 + * The name of the initialization file . If this parameter does not contain a full path to the file , the system searches for the file in the 
 + * Windows directory . 
 + * @ return The number of characters copied to the buffer , not including the terminating null character . If the buffer is not large enough to contain all the 
 + * key name and value pairs associated with the named section , the return value is equal to { @ code nSize } minus two . 
 + * / 
 + DWORD GetPrivateProfileSection ( String lpAppName , char [ ] lpReturnedString , DWORD nSize , String lpFileName ) ; 
 + 
 + / * * 
 + * Retrieves the names of all sections in an initialization file . 
 + * < p > 
 + * This operation is atomic ; no updates to the initialization file are allowed while the section names are being copied to the buffer . 
 + * < / p > 
 + * 
 + * @ param lpszReturnBuffer 
 + * A pointer to a buffer that receives the section names associated with the named file . The buffer is filled with one or more { @ code null } 
 + * - terminated strings ; the last string is followed by a second { @ code null } character . 
 + * @ param nSize 
 + * size of the buffer pointed to by the { @ code lpszReturnBuffer } parameter , in characters . 
 + * @ param lpFileName 
 + * The name of the initialization file . If this parameter is { @ code NULL } , the function searches the Win . ini file . If this parameter does not 
 + * contain a full path to the file , the system searches for the file in the Windows directory . 
 + * @ return The return value specifies the number of characters copied to the specified buffer , not including the terminating { @ code null } character . If the 
 + * buffer is not large enough to contain all the section names associated with the specified initialization file , the return value is equal to the 
 + * size specified by { @ code nSize } minus two . 
 + * / 
 + DWORD GetPrivateProfileSectionNames ( char [ ] lpszReturnBuffer , DWORD nSize , String lpFileName ) ; 
 + 
 + / * * 
 + * @ param lpAppName 
 + * The name of the section in which data is written . This section name is typically the name of the calling application . 
 + * @ param lpString 
 + * The new key names and associated values that are to be written to the named section . This string is limited to 65 , 535 bytes . Must be filled 
 + * with zero or many { @ code null } - terminated strings of the form { @ code key = value } , appended by an additional { @ code null } byte to terminate the 
 + * list . 
 + * @ param lpFileName 
 + * The name of the initialization file . If this parameter does not contain a full path for the file , the function searches the Windows directory 
 + * for the file . If the file does not exist and lpFileName does not contain a full path , the function creates the file in the Windows directory . 
 + * @ return If the function succeeds , the return value is nonzero . If the function fails , the return value is zero . 
 + * / 
 + boolean WritePrivateProfileSection ( String lpAppName , String lpString , String lpFileName ) ; 
 } 
 \ No newline at end of file 
 diff - - git a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java 
 index 29ca050 . . aa0f889 100644 
 - - - a / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java 
 + + + b / contrib / platform / src / com / sun / jna / platform / win32 / Kernel32Util . java 
 @ @ - 362 , 4 + 362 , 67 @ @ public abstract class Kernel32Util implements WinDef { 
 return ( WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION [ ] ) firstInformation 
 . toArray ( new WinNT . SYSTEM _ LOGICAL _ PROCESSOR _ INFORMATION [ returnedStructCount ] ) ; 
 } 
 + 
 + / * * 
 + * Retrieves all the keys and values for the specified section of an initialization file . 
 + * 
 + * < p > 
 + * Each string has the following format : { @ code key = string } . 
 + * < / p > 
 + * < p > 
 + * This operation is atomic ; no updates to the specified initialization file are allowed while this method is executed . 
 + * < / p > 
 + * 
 + * @ param appName 
 + * The name of the section in the initialization file . 
 + * @ param fileName 
 + * The name of the initialization file . If this parameter does not contain a full path to the file , the system searches for the file in the 
 + * Windows directory . 
 + * @ return The key name and value pairs associated with the named section . 
 + * / 
 + public static final String [ ] getPrivateProfileSection ( final String appName , final String fileName ) { 
 + final char buffer [ ] = new char [ 32768 ] ; / / Maximum section size according to MSDN ( http : / / msdn . microsoft . com / en - us / library / windows / desktop / ms724348 ( v = vs . 85 ) . aspx ) 
 + if ( Kernel32 . INSTANCE . GetPrivateProfileSection ( appName , buffer , new DWORD ( buffer . length ) , fileName ) . intValue ( ) = = 0 ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + return new String ( buffer ) . split ( " \ 0 " ) ; 
 + } 
 + 
 + / * * 
 + * Retrieves the names of all sections in an initialization file . 
 + * < p > 
 + * This operation is atomic ; no updates to the initialization file are allowed while this method is executed . 
 + * < / p > 
 + * 
 + * @ param fileName 
 + * The name of the initialization file . If this parameter is { @ code NULL } , the function searches the Win . ini file . If this parameter does not 
 + * contain a full path to the file , the system searches for the file in the Windows directory . 
 + * @ return the section names associated with the named file . 
 + * / 
 + public static final String [ ] getPrivateProfileSectionNames ( final String fileName ) { 
 + final char buffer [ ] = new char [ 65536 ] ; / / Maximum INI file size according to MSDN ( http : / / support . microsoft . com / kb / 78346 ) 
 + if ( Kernel32 . INSTANCE . GetPrivateProfileSectionNames ( buffer , new DWORD ( buffer . length ) , fileName ) . intValue ( ) = = 0 ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + return new String ( buffer ) . split ( " \ 0 " ) ; 
 + } 
 + 
 + / * * 
 + * @ param appName 
 + * The name of the section in which data is written . This section name is typically the name of the calling application . 
 + * @ param strings 
 + * The new key names and associated values that are to be written to the named section . Each entry must be of the form { @ code key = value } . 
 + * @ param fileName 
 + * The name of the initialization file . If this parameter does not contain a full path for the file , the function searches the Windows directory 
 + * for the file . If the file does not exist and lpFileName does not contain a full path , the function creates the file in the Windows directory . 
 + * / 
 + public static final void writePrivateProfileSection ( final String appName , final String [ ] strings , final String fileName ) { 
 + final StringBuilder buffer = new StringBuilder ( ) ; 
 + for ( final String string : strings ) 
 + buffer . append ( string ) . append ( ' \ 0 ' ) ; 
 + buffer . append ( ' \ 0 ' ) ; 
 + if ( ! Kernel32 . INSTANCE . WritePrivateProfileSection ( appName , buffer . toString ( ) , fileName ) ) { 
 + throw new Win32Exception ( Kernel32 . INSTANCE . GetLastError ( ) ) ; 
 + } 
 + } 
 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32Test . java b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32Test . java 
 index 91d83de . . 81e913b 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32Test . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32Test . java 
 @ @ - 531 , 4 + 531 , 66 @ @ public class Kernel32Test extends TestCase { 
 assertEquals ( reader . readLine ( ) , null ) ; 
 reader . close ( ) ; 
 } 
 + 
 + public final void testGetPrivateProfileSection ( ) throws IOException { 
 + final File tmp = File . createTempFile ( " testGetPrivateProfileSection " , " . ini " ) ; 
 + tmp . deleteOnExit ( ) ; 
 + 
 + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; 
 + try { 
 + writer . println ( " [ X ] " ) ; 
 + writer . println ( " A = 1 " ) ; 
 + writer . println ( " B = X " ) ; 
 + } finally { 
 + writer . close ( ) ; 
 + } 
 + 
 + final char [ ] buffer = new char [ 9 ] ; 
 + final DWORD len = Kernel32 . INSTANCE . GetPrivateProfileSection ( " X " , buffer , new DWORD ( buffer . length ) , tmp . getCanonicalPath ( ) ) ; 
 + 
 + assertEquals ( len . intValue ( ) , 7 ) ; 
 + assertEquals ( new String ( buffer ) , " A = 1 \ 0B = X \ 0 \ 0 " ) ; 
 + } 
 + 
 + public final void testGetPrivateProfileSectionNames ( ) throws IOException { 
 + final File tmp = File . createTempFile ( " testGetPrivateProfileSectionNames " , " . ini " ) ; 
 + tmp . deleteOnExit ( ) ; 
 + 
 + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; 
 + try { 
 + writer . println ( " [ S1 ] " ) ; 
 + writer . println ( " [ S2 ] " ) ; 
 + } finally { 
 + writer . close ( ) ; 
 + } 
 + 
 + final char [ ] buffer = new char [ 7 ] ; 
 + final DWORD len = Kernel32 . INSTANCE . GetPrivateProfileSectionNames ( buffer , new DWORD ( buffer . length ) , tmp . getCanonicalPath ( ) ) ; 
 + assertEquals ( len . intValue ( ) , 5 ) ; 
 + assertEquals ( new String ( buffer ) , " S1 \ 0S2 \ 0 \ 0 " ) ; 
 + } 
 + 
 + public final void testWritePrivateProfileSection ( ) throws IOException { 
 + final File tmp = File . createTempFile ( " testWritePrivateProfileSection " , " . ini " ) ; 
 + tmp . deleteOnExit ( ) ; 
 + 
 + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; 
 + try { 
 + writer . println ( " [ S1 ] " ) ; 
 + writer . println ( " A = 1 " ) ; 
 + writer . println ( " B = X " ) ; 
 + } finally { 
 + writer . close ( ) ; 
 + } 
 + 
 + final boolean result = Kernel32 . INSTANCE . WritePrivateProfileSection ( " S1 " , " A = 3 \ 0E = Z \ 0 \ 0 " , tmp . getCanonicalPath ( ) ) ; 
 + assertTrue ( result ) ; 
 + 
 + final BufferedReader reader = new BufferedReader ( new FileReader ( tmp ) ) ; 
 + assertEquals ( reader . readLine ( ) , " [ S1 ] " ) ; 
 + assertTrue ( reader . readLine ( ) . matches ( " A \ \ s * = \ \ s * 3 " ) ) ; 
 + assertTrue ( reader . readLine ( ) . matches ( " E \ \ s * = \ \ s * Z " ) ) ; 
 + reader . close ( ) ; 
 + } 
 + 
 } 
 diff - - git a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java 
 index a31a947 . . 3bf889d 100644 
 - - - a / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java 
 + + + b / contrib / platform / test / com / sun / jna / platform / win32 / Kernel32UtilTest . java 
 @ @ - 180 , 4 + 180 , 76 @ @ public class Kernel32UtilTest extends TestCase { 
 assertEquals ( reader . readLine ( ) , null ) ; 
 reader . close ( ) ; 
 } 
 + 
 + public final void testGetPrivateProfileSection ( ) throws IOException { 
 + final File tmp = File . createTempFile ( " testGetPrivateProfileSection " , " . ini " ) ; 
 + tmp . deleteOnExit ( ) ; 
 + 
 + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; 
 + try { 
 + writer . println ( " [ X ] " ) ; 
 + writer . println ( " A = 1 " ) ; 
 + writer . println ( " foo = bar " ) ; 
 + } finally { 
 + writer . close ( ) ; 
 + } 
 + 
 + final String [ ] lines = Kernel32Util . getPrivateProfileSection ( " X " , tmp . getCanonicalPath ( ) ) ; 
 + assertEquals ( lines . length , 2 ) ; 
 + assertEquals ( lines [ 0 ] , " A = 1 " ) ; 
 + assertEquals ( lines [ 1 ] , " foo = bar " ) ; 
 + } 
 + 
 + public final void testGetPrivateProfileSectionNames ( ) throws IOException { 
 + final File tmp = File . createTempFile ( " testGetPrivateProfileSectionNames " , " ini " ) ; 
 + tmp . deleteOnExit ( ) ; 
 + 
 + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; 
 + try { 
 + writer . println ( " [ S1 ] " ) ; 
 + writer . println ( " A = 1 " ) ; 
 + writer . println ( " B = X " ) ; 
 + writer . println ( " [ S2 ] " ) ; 
 + writer . println ( " C = 2 " ) ; 
 + writer . println ( " D = Y " ) ; 
 + } finally { 
 + writer . close ( ) ; 
 + } 
 + 
 + String [ ] sectionNames = Kernel32Util . getPrivateProfileSectionNames ( tmp . getCanonicalPath ( ) ) ; 
 + assertEquals ( sectionNames . length , 2 ) ; 
 + assertEquals ( sectionNames [ 0 ] , " S1 " ) ; 
 + assertEquals ( sectionNames [ 1 ] , " S2 " ) ; 
 + } 
 + 
 + public final void testWritePrivateProfileSection ( ) throws IOException { 
 + final File tmp = File . createTempFile ( " testWritePrivateProfileSecion " , " ini " ) ; 
 + tmp . deleteOnExit ( ) ; 
 + 
 + final PrintWriter writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( tmp ) ) ) ; 
 + try { 
 + writer . println ( " [ S1 ] " ) ; 
 + writer . println ( " A = 1 " ) ; 
 + writer . println ( " B = X " ) ; 
 + writer . println ( " [ S2 ] " ) ; 
 + writer . println ( " C = 2 " ) ; 
 + writer . println ( " foo = bar " ) ; 
 + } finally { 
 + writer . close ( ) ; 
 + } 
 + 
 + Kernel32Util . writePrivateProfileSection ( " S1 " , new String [ ] { " A = 3 " , " E = Z " } , tmp . getCanonicalPath ( ) ) ; 
 + 
 + final BufferedReader reader = new BufferedReader ( new FileReader ( tmp ) ) ; 
 + try { 
 + assertEquals ( reader . readLine ( ) , " [ S1 ] " ) ; 
 + assertEquals ( reader . readLine ( ) , " A = 3 " ) ; 
 + assertEquals ( reader . readLine ( ) , " E = Z " ) ; 
 + assertEquals ( reader . readLine ( ) , " [ S2 ] " ) ; 
 + assertEquals ( reader . readLine ( ) , " C = 2 " ) ; 
 + assertEquals ( reader . readLine ( ) , " foo = bar " ) ; 
 + } finally { 
 + reader . close ( ) ; 
 + } 
 + } 
 }

NEAREST DIFF:
diff - - git a / jnalib / native / dispatch . c b / jnalib / native / dispatch . c 
 index 383d49f . . b3450f8 100644 
 - - - a / jnalib / native / dispatch . c 
 + + + b / jnalib / native / dispatch . c 
 @ @ - 992 , 7 + 992 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1write _ _ J _ 3SII 
 * Signature : ( JB ) J 
 * / 
 JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1indexOf _ _ JB 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 { 
 jbyte * peer = ( jbyte * ) L2A ( addr ) ; 
 volatile jlong i = 0 ; 
 @ @ - 1103 , 7 + 1103 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1read _ _ J _ 3SII 
 * Signature : ( J ) B 
 * / 
 JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jbyte res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1116 , 7 + 1116 , 7 @ @ JNIEXPORT jbyte JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getByte 
 * Signature : ( J ) C 
 * / 
 JNIEXPORT jchar JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getChar 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 wchar _ t res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1153 , 7 + 1153 , 7 @ @ JNIEXPORT jobject JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDirectByteBuffer 
 * Signature : ( J ) D 
 * / 
 JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jdouble res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1166 , 7 + 1166 , 7 @ @ JNIEXPORT jdouble JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getDouble 
 * Signature : ( J ) F 
 * / 
 JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jfloat res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1179 , 7 + 1179 , 7 @ @ JNIEXPORT jfloat JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getFloat 
 * Signature : ( J ) I 
 * / 
 JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jint res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1192 , 7 + 1192 , 7 @ @ JNIEXPORT jint JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getInt 
 * Signature : ( J ) J 
 * / 
 JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jlong res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1205 , 7 + 1205 , 7 @ @ JNIEXPORT jlong JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getLong 
 * Signature : ( J ) S 
 * / 
 JNIEXPORT jshort JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getShort 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr ) 
 { 
 jshort res = 0 ; 
 MEMCPY ( & res , L2A ( addr ) , sizeof ( res ) ) ; 
 @ @ - 1229 , 7 + 1229 , 7 @ @ JNIEXPORT jstring JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1getString 
 * Signature : ( JJB ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong count , jbyte value ) 
 { 
 MEMSET ( L2A ( addr ) , ( int ) value , ( size _ t ) count ) ; 
 } 
 @ @ - 1240 , 7 + 1240 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setMemory 
 * Signature : ( JB ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jbyte value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1251 , 7 + 1251 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setByte 
 * Signature : ( JC ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jchar value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jchar value ) 
 { 
 wchar _ t ch = value ; 
 MEMCPY ( L2A ( addr ) , & ch , sizeof ( ch ) ) ; 
 @ @ - 1263 , 7 + 1263 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setChar 
 * Signature : ( JJ ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 { 
 void * ptr = L2A ( value ) ; 
 MEMCPY ( L2A ( addr ) , & ptr , sizeof ( void * ) ) ; 
 @ @ - 1275 , 7 + 1275 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setPointer 
 * Signature : ( JD ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jdouble value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jdouble value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1286 , 7 + 1286 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setDouble 
 * Signature : ( JF ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jfloat value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jfloat value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1297 , 7 + 1297 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setFloat 
 * Signature : ( JI ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jint value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jint value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1308 , 7 + 1308 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setInt 
 * Signature : ( JJ ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jlong value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 } 
 @ @ - 1319 , 7 + 1319 , 7 @ @ JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setLong 
 * Signature : ( JS ) V 
 * / 
 JNIEXPORT void JNICALL Java _ com _ sun _ jna _ Pointer _ _ 1setShort 
 - ( JNIEnv * UNUSED ( env ) , jclass UNUSED ( cls ) , jlong addr , jshort value ) 
 + ( JNIEnv * env , jclass UNUSED ( cls ) , jlong addr , jshort value ) 
 { 
 MEMCPY ( L2A ( addr ) , & value , sizeof ( value ) ) ; 
 }
