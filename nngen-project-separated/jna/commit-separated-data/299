BLEU SCORE: 0.027611988917697356

TEST MSG: add libffi . info to avoid triggering makeinfo
GENERATED MSG: Fix win64 - struct - args patch

TEST DIFF (one line): diff - - git a / native / libffi / doc / libffi . info b / native / libffi / doc / libffi . info <nl> new file mode 100644 <nl> index 0000000 . . b0100b2 <nl> - - - / dev / null <nl> + + + b / native / libffi / doc / libffi . info <nl> @ @ - 0 , 0 + 1 , 766 @ @ <nl> + This is libffi . info , produced by makeinfo version 5 . 2 from libffi . texi . <nl> + <nl> + This manual is for Libffi , a portable foreign - function interface <nl> + library . <nl> + <nl> + Copyright ( C ) 2008 , 2010 , 2011 Red Hat , Inc . <nl> + <nl> + Permission is granted to copy , distribute and / or modify this <nl> + document under the terms of the GNU General Public License as <nl> + published by the Free Software Foundation ; either version 2 , or ( at <nl> + your option ) any later version . A copy of the license is included <nl> + in the section entitled " GNU General Public License " . <nl> + <nl> + INFO - DIR - SECTION Development <nl> + START - INFO - DIR - ENTRY <nl> + * libffi : ( libffi ) . Portable foreign - function interface library . <nl> + END - INFO - DIR - ENTRY <nl> + <nl> +  <nl> + File : libffi . info , Node : Top , Next : Introduction , Up : ( dir ) <nl> + <nl> + libffi <nl> + * * * * * * <nl> + <nl> + This manual is for Libffi , a portable foreign - function interface <nl> + library . <nl> + <nl> + Copyright ( C ) 2008 , 2010 , 2011 Red Hat , Inc . <nl> + <nl> + Permission is granted to copy , distribute and / or modify this <nl> + document under the terms of the GNU General Public License as <nl> + published by the Free Software Foundation ; either version 2 , or ( at <nl> + your option ) any later version . A copy of the license is included <nl> + in the section entitled " GNU General Public License " . <nl> + <nl> + * Menu : <nl> + <nl> + * Introduction : : What is libffi ? <nl> + * Using libffi : : How to use libffi . <nl> + * Missing Features : : Things libffi can ' t do . <nl> + * Index : : Index . <nl> + <nl> +  <nl> + File : libffi . info , Node : Introduction , Next : Using libffi , Prev : Top , Up : Top <nl> + <nl> + 1 What is libffi ? <nl> + * * * * * * * * * * * * * * * * * <nl> + <nl> + Compilers for high level languages generate code that follow certain <nl> + conventions . These conventions are necessary , in part , for separate <nl> + compilation to work . One such convention is the " calling convention " . <nl> + The calling convention is a set of assumptions made by the compiler <nl> + about where function arguments will be found on entry to a function . A <nl> + calling convention also specifies where the return value for a function <nl> + is found . The calling convention is also sometimes called the " ABI " or <nl> + " Application Binary Interface " . <nl> + <nl> + Some programs may not know at the time of compilation what arguments <nl> + are to be passed to a function . For instance , an interpreter may be <nl> + told at run - time about the number and types of arguments used to call a <nl> + given function . ' Libffi ' can be used in such programs to provide a <nl> + bridge from the interpreter program to compiled code . <nl> + <nl> + The ' libffi ' library provides a portable , high level programming <nl> + interface to various calling conventions . This allows a programmer to <nl> + call any function specified by a call interface description at run time . <nl> + <nl> + FFI stands for Foreign Function Interface . A foreign function <nl> + interface is the popular name for the interface that allows code written <nl> + in one language to call code written in another language . The ' libffi ' <nl> + library really only provides the lowest , machine dependent layer of a <nl> + fully featured foreign function interface . A layer must exist above <nl> + ' libffi ' that handles type conversions for values passed between the two <nl> + languages . <nl> + <nl> +  <nl> + File : libffi . info , Node : Using libffi , Next : Missing Features , Prev : Introduction , Up : Top <nl> + <nl> + 2 Using libffi <nl> + * * * * * * * * * * * * * * <nl> + <nl> + * Menu : <nl> + <nl> + * The Basics : : The basic libffi API . <nl> + * Simple Example : : A simple example . <nl> + * Types : : libffi type descriptions . <nl> + * Multiple ABIs : : Different passing styles on one platform . <nl> + * The Closure API : : Writing a generic function . <nl> + * Closure Example : : A closure example . <nl> + <nl> +  <nl> + File : libffi . info , Node : The Basics , Next : Simple Example , Up : Using libffi <nl> + <nl> + 2 . 1 The Basics <nl> + = = = = = = = = = = = = = = <nl> + <nl> + ' Libffi ' assumes that you have a pointer to the function you wish to <nl> + call and that you know the number and types of arguments to pass it , as <nl> + well as the return type of the function . <nl> + <nl> + The first thing you must do is create an ' ffi _ cif ' object that <nl> + matches the signature of the function you wish to call . This is a <nl> + separate step because it is common to make multiple calls using a single <nl> + ' ffi _ cif ' . The " cif " in ' ffi _ cif ' stands for Call InterFace . To <nl> + prepare a call interface object , use the function ' ffi _ prep _ cif ' . <nl> + <nl> + - - Function : ffi _ status ffi _ prep _ cif ( ffi _ cif * CIF , ffi _ abi ABI , <nl> + unsigned int NARGS , ffi _ type * RTYPE , ffi _ type * * ARGTYPES ) <nl> + This initializes CIF according to the given parameters . <nl> + <nl> + ABI is the ABI to use ; normally ' FFI _ DEFAULT _ ABI ' is what you want . <nl> + * note Multiple ABIs : : for more information . <nl> + <nl> + NARGS is the number of arguments that this function accepts . <nl> + <nl> + RTYPE is a pointer to an ' ffi _ type ' structure that describes the <nl> + return type of the function . * Note Types : : . <nl> + <nl> + ARGTYPES is a vector of ' ffi _ type ' pointers . ARGTYPES must have <nl> + NARGS elements . If NARGS is 0 , this argument is ignored . <nl> + <nl> + ' ffi _ prep _ cif ' returns a ' libffi ' status code , of type <nl> + ' ffi _ status ' . This will be either ' FFI _ OK ' if everything worked <nl> + properly ; ' FFI _ BAD _ TYPEDEF ' if one of the ' ffi _ type ' objects is <nl> + incorrect ; or ' FFI _ BAD _ ABI ' if the ABI parameter is invalid . <nl> + <nl> + If the function being called is variadic ( varargs ) then <nl> + ' ffi _ prep _ cif _ var ' must be used instead of ' ffi _ prep _ cif ' . <nl> + <nl> + - - Function : ffi _ status ffi _ prep _ cif _ var ( ffi _ cif * CIF , ffi _ abi varabi , <nl> + unsigned int NFIXEDARGS , unsigned int varntotalargs , ffi _ type <nl> + * RTYPE , ffi _ type * * ARGTYPES ) <nl> + This initializes CIF according to the given parameters for a call <nl> + to a variadic function . In general it ' s operation is the same as <nl> + for ' ffi _ prep _ cif ' except that : <nl> + <nl> + NFIXEDARGS is the number of fixed arguments , prior to any variadic <nl> + arguments . It must be greater than zero . <nl> + <nl> + NTOTALARGS the total number of arguments , including variadic and <nl> + fixed arguments . <nl> + <nl> + Note that , different cif ' s must be prepped for calls to the same <nl> + function when different numbers of arguments are passed . <nl> + <nl> + Also note that a call to ' ffi _ prep _ cif _ var ' with <nl> + NFIXEDARGS = NOTOTALARGS is NOT equivalent to a call to <nl> + ' ffi _ prep _ cif ' . <nl> + <nl> + To call a function using an initialized ' ffi _ cif ' , use the ' ffi _ call ' <nl> + function : <nl> + <nl> + - - Function : void ffi _ call ( ffi _ cif * CIF , void * FN , void * RVALUE , void <nl> + * * AVALUES ) <nl> + This calls the function FN according to the description given in <nl> + CIF . CIF must have already been prepared using ' ffi _ prep _ cif ' . <nl> + <nl> + RVALUE is a pointer to a chunk of memory that will hold the result <nl> + of the function call . This must be large enough to hold the <nl> + result , no smaller than the system register size ( generally 32 or <nl> + 64 bits ) , and must be suitably aligned ; it is the caller ' s <nl> + responsibility to ensure this . If CIF declares that the function <nl> + returns ' void ' ( using ' ffi _ type _ void ' ) , then RVALUE is ignored . <nl> + <nl> + AVALUES is a vector of ' void * ' pointers that point to the memory <nl> + locations holding the argument values for a call . If CIF declares <nl> + that the function has no arguments ( i . e . , NARGS was 0 ) , then <nl> + AVALUES is ignored . Note that argument values may be modified by <nl> + the callee ( for instance , structs passed by value ) ; the burden of <nl> + copying pass - by - value arguments is placed on the caller . <nl> + <nl> +  <nl> + File : libffi . info , Node : Simple Example , Next : Types , Prev : The Basics , Up : Using libffi <nl> + <nl> + 2 . 2 Simple Example <nl> + = = = = = = = = = = = = = = = = = = <nl> + <nl> + Here is a trivial example that calls ' puts ' a few times . <nl> + <nl> + # include < stdio . h > <nl> + # include < ffi . h > <nl> + <nl> + int main ( ) <nl> + { <nl> + ffi _ cif cif ; <nl> + ffi _ type * args [ 1 ] ; <nl> + void * values [ 1 ] ; <nl> + char * s ; <nl> + ffi _ arg rc ; <nl> + <nl> + / * Initialize the argument info vectors * / <nl> + args [ 0 ] = & ffi _ type _ pointer ; <nl> + values [ 0 ] = & s ; <nl> + <nl> + / * Initialize the cif * / <nl> + if ( ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 1 , <nl> + 	 	 & ffi _ type _ sint , args ) = = FFI _ OK ) <nl> + { <nl> + s = " Hello World ! " ; <nl> + ffi _ call ( & cif , puts , & rc , values ) ; <nl> + / * rc now holds the result of the call to puts * / <nl> + <nl> + / * values holds a pointer to the function ' s arg , so to <nl> + call puts ( ) again all we need to do is change the <nl> + value of s * / <nl> + s = " This is cool ! " ; <nl> + ffi _ call ( & cif , puts , & rc , values ) ; <nl> + } <nl> + <nl> + return 0 ; <nl> + } <nl> + <nl> +  <nl> + File : libffi . info , Node : Types , Next : Multiple ABIs , Prev : Simple Example , Up : Using libffi <nl> + <nl> + 2 . 3 Types <nl> + = = = = = = = = = <nl> + <nl> + * Menu : <nl> + <nl> + * Primitive Types : : Built - in types . <nl> + * Structures : : Structure types . <nl> + * Type Example : : Structure type example . <nl> + * Complex : : Complex types . <nl> + * Complex Type Example : : Complex type example . <nl> + <nl> +  <nl> + File : libffi . info , Node : Primitive Types , Next : Structures , Up : Types <nl> + <nl> + 2 . 3 . 1 Primitive Types <nl> + - - - - - - - - - - - - - - - - - - - - - <nl> + <nl> + ' Libffi ' provides a number of built - in type descriptors that can be used <nl> + to describe argument and return types : <nl> + <nl> + ' ffi _ type _ void ' <nl> + The type ' void ' . This cannot be used for argument types , only for <nl> + return values . <nl> + <nl> + ' ffi _ type _ uint8 ' <nl> + An unsigned , 8 - bit integer type . <nl> + <nl> + ' ffi _ type _ sint8 ' <nl> + A signed , 8 - bit integer type . <nl> + <nl> + ' ffi _ type _ uint16 ' <nl> + An unsigned , 16 - bit integer type . <nl> + <nl> + ' ffi _ type _ sint16 ' <nl> + A signed , 16 - bit integer type . <nl> + <nl> + ' ffi _ type _ uint32 ' <nl> + An unsigned , 32 - bit integer type . <nl> + <nl> + ' ffi _ type _ sint32 ' <nl> + A signed , 32 - bit integer type . <nl> + <nl> + ' ffi _ type _ uint64 ' <nl> + An unsigned , 64 - bit integer type . <nl> + <nl> + ' ffi _ type _ sint64 ' <nl> + A signed , 64 - bit integer type . <nl> + <nl> + ' ffi _ type _ float ' <nl> + The C ' float ' type . <nl> + <nl> + ' ffi _ type _ double ' <nl> + The C ' double ' type . <nl> + <nl> + ' ffi _ type _ uchar ' <nl> + The C ' unsigned char ' type . <nl> + <nl> + ' ffi _ type _ schar ' <nl> + The C ' signed char ' type . ( Note that there is not an exact <nl> + equivalent to the C ' char ' type in ' libffi ' ; ordinarily you should <nl> + either use ' ffi _ type _ schar ' or ' ffi _ type _ uchar ' depending on <nl> + whether ' char ' is signed . ) <nl> + <nl> + ' ffi _ type _ ushort ' <nl> + The C ' unsigned short ' type . <nl> + <nl> + ' ffi _ type _ sshort ' <nl> + The C ' short ' type . <nl> + <nl> + ' ffi _ type _ uint ' <nl> + The C ' unsigned int ' type . <nl> + <nl> + ' ffi _ type _ sint ' <nl> + The C ' int ' type . <nl> + <nl> + ' ffi _ type _ ulong ' <nl> + The C ' unsigned long ' type . <nl> + <nl> + ' ffi _ type _ slong ' <nl> + The C ' long ' type . <nl> + <nl> + ' ffi _ type _ longdouble ' <nl> + On platforms that have a C ' long double ' type , this is defined . On <nl> + other platforms , it is not . <nl> + <nl> + ' ffi _ type _ pointer ' <nl> + A generic ' void * ' pointer . You should use this for all pointers , <nl> + regardless of their real type . <nl> + <nl> + ' ffi _ type _ complex _ float ' <nl> + The C ' _ Complex float ' type . <nl> + <nl> + ' ffi _ type _ complex _ double ' <nl> + The C ' _ Complex double ' type . <nl> + <nl> + ' ffi _ type _ complex _ longdouble ' <nl> + The C ' _ Complex long double ' type . On platforms that have a C <nl> + ' long double ' type , this is defined . On other platforms , it is <nl> + not . <nl> + <nl> + Each of these is of type ' ffi _ type ' , so you must take the address <nl> + when passing to ' ffi _ prep _ cif ' . <nl> + <nl> +  <nl> + File : libffi . info , Node : Structures , Next : Type Example , Prev : Primitive Types , Up : Types <nl> + <nl> + 2 . 3 . 2 Structures <nl> + - - - - - - - - - - - - - - - - <nl> + <nl> + Although ' libffi ' has no special support for unions or bit - fields , it is <nl> + perfectly happy passing structures back and forth . You must first <nl> + describe the structure to ' libffi ' by creating a new ' ffi _ type ' object <nl> + for it . <nl> + <nl> + - - Data type : ffi _ type <nl> + The ' ffi _ type ' has the following members : <nl> + ' size _ t size ' <nl> + This is set by ' libffi ' ; you should initialize it to zero . <nl> + <nl> + ' unsigned short alignment ' <nl> + This is set by ' libffi ' ; you should initialize it to zero . <nl> + <nl> + ' unsigned short type ' <nl> + For a structure , this should be set to ' FFI _ TYPE _ STRUCT ' . <nl> + <nl> + ' ffi _ type * * elements ' <nl> + This is a ' NULL ' - terminated array of pointers to ' ffi _ type ' <nl> + objects . There is one element per field of the struct . <nl> + <nl> +  <nl> + File : libffi . info , Node : Type Example , Next : Complex , Prev : Structures , Up : Types <nl> + <nl> + 2 . 3 . 3 Type Example <nl> + - - - - - - - - - - - - - - - - - - <nl> + <nl> + The following example initializes a ' ffi _ type ' object representing the <nl> + ' tm ' struct from Linux ' s ' time . h ' . <nl> + <nl> + Here is how the struct is defined : <nl> + <nl> + struct tm { <nl> + int tm _ sec ; <nl> + int tm _ min ; <nl> + int tm _ hour ; <nl> + int tm _ mday ; <nl> + int tm _ mon ; <nl> + int tm _ year ; <nl> + int tm _ wday ; <nl> + int tm _ yday ; <nl> + int tm _ isdst ; <nl> + / * Those are for future use . * / <nl> + long int _ _ tm _ gmtoff _ _ ; <nl> + _ _ const char * _ _ tm _ zone _ _ ; <nl> + } ; <nl> + <nl> + Here is the corresponding code to describe this struct to ' libffi ' : <nl> + <nl> + { <nl> + ffi _ type tm _ type ; <nl> + ffi _ type * tm _ type _ elements [ 12 ] ; <nl> + int i ; <nl> + <nl> + tm _ type . size = tm _ type . alignment = 0 ; <nl> + tm _ type . type = FFI _ TYPE _ STRUCT ; <nl> + tm _ type . elements = & tm _ type _ elements ; <nl> + <nl> + for ( i = 0 ; i < 9 ; i + + ) <nl> + tm _ type _ elements [ i ] = & ffi _ type _ sint ; <nl> + <nl> + tm _ type _ elements [ 9 ] = & ffi _ type _ slong ; <nl> + tm _ type _ elements [ 10 ] = & ffi _ type _ pointer ; <nl> + tm _ type _ elements [ 11 ] = NULL ; <nl> + <nl> + / * tm _ type can now be used to represent tm argument types and <nl> + 	 return types for ffi _ prep _ cif ( ) * / <nl> + } <nl> + <nl> +  <nl> + File : libffi . info , Node : Complex , Next : Complex Type Example , Prev : Type Example , Up : Types <nl> + <nl> + 2 . 3 . 4 Complex Types <nl> + - - - - - - - - - - - - - - - - - - - <nl> + <nl> + ' libffi ' supports the complex types defined by the C99 standard <nl> + ( ' _ Complex float ' , ' _ Complex double ' and ' _ Complex long double ' with the <nl> + built - in type descriptors ' ffi _ type _ complex _ float ' , <nl> + ' ffi _ type _ complex _ double ' and ' ffi _ type _ complex _ longdouble ' . <nl> + <nl> + Custom complex types like ' _ Complex int ' can also be used . An <nl> + ' ffi _ type ' object has to be defined to describe the complex type to <nl> + ' libffi ' . <nl> + <nl> + - - Data type : ffi _ type <nl> + ' size _ t size ' <nl> + This must be manually set to the size of the complex type . <nl> + <nl> + ' unsigned short alignment ' <nl> + This must be manually set to the alignment of the complex <nl> + type . <nl> + <nl> + ' unsigned short type ' <nl> + For a complex type , this must be set to ' FFI _ TYPE _ COMPLEX ' . <nl> + <nl> + ' ffi _ type * * elements ' <nl> + <nl> + This is a ' NULL ' - terminated array of pointers to ' ffi _ type ' <nl> + objects . The first element is set to the ' ffi _ type ' of the <nl> + complex ' s base type . The second element must be set to <nl> + ' NULL ' . <nl> + <nl> + The section * note Complex Type Example : : shows a way to determine the <nl> + ' size ' and ' alignment ' members in a platform independent way . <nl> + <nl> + For platforms that have no complex support in ' libffi ' yet , the <nl> + functions ' ffi _ prep _ cif ' and ' ffi _ prep _ args ' abort the program if they <nl> + encounter a complex type . <nl> + <nl> +  <nl> + File : libffi . info , Node : Complex Type Example , Prev : Complex , Up : Types <nl> + <nl> + 2 . 3 . 5 Complex Type Example <nl> + - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> + <nl> + This example demonstrates how to use complex types : <nl> + <nl> + # include < stdio . h > <nl> + # include < ffi . h > <nl> + # include < complex . h > <nl> + <nl> + void complex _ fn ( _ Complex float cf , <nl> + _ Complex double cd , <nl> + _ Complex long double cld ) <nl> + { <nl> + printf ( " cf = % f + % fi \ ncd = % f + % fi \ ncld = % f + % fi \ n " , <nl> + ( float ) creal ( cf ) , ( float ) cimag ( cf ) , <nl> + ( float ) creal ( cd ) , ( float ) cimag ( cd ) , <nl> + ( float ) creal ( cld ) , ( float ) cimag ( cld ) ) ; <nl> + } <nl> + <nl> + int main ( ) <nl> + { <nl> + ffi _ cif cif ; <nl> + ffi _ type * args [ 3 ] ; <nl> + void * values [ 3 ] ; <nl> + _ Complex float cf ; <nl> + _ Complex double cd ; <nl> + _ Complex long double cld ; <nl> + <nl> + / * Initialize the argument info vectors * / <nl> + args [ 0 ] = & ffi _ type _ complex _ float ; <nl> + args [ 1 ] = & ffi _ type _ complex _ double ; <nl> + args [ 2 ] = & ffi _ type _ complex _ longdouble ; <nl> + values [ 0 ] = & cf ; <nl> + values [ 1 ] = & cd ; <nl> + values [ 2 ] = & cld ; <nl> + <nl> + / * Initialize the cif * / <nl> + if ( ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 3 , <nl> + & ffi _ type _ void , args ) = = FFI _ OK ) <nl> + { <nl> + cf = 1 . 0 + 20 . 0 * I ; <nl> + cd = 300 . 0 + 4000 . 0 * I ; <nl> + cld = 50000 . 0 + 600000 . 0 * I ; <nl> + / * Call the function * / <nl> + ffi _ call ( & cif , ( void ( * ) ( void ) ) complex _ fn , 0 , values ) ; <nl> + } <nl> + <nl> + return 0 ; <nl> + } <nl> + <nl> + This is an example for defining a custom complex type descriptor for <nl> + compilers that support them : <nl> + <nl> + / * <nl> + * This macro can be used to define new complex type descriptors <nl> + * in a platform independent way . <nl> + * <nl> + * name : Name of the new descriptor is ffi _ type _ complex _ < name > . <nl> + * type : The C base type of the complex type . <nl> + * / <nl> + # define FFI _ COMPLEX _ TYPEDEF ( name , type , ffitype ) \ <nl> + static ffi _ type * ffi _ elements _ complex _ # # name [ 2 ] = { \ <nl> + ( ffi _ type * ) ( & ffitype ) , NULL \ <nl> + } ; \ <nl> + struct struct _ align _ complex _ # # name { \ <nl> + char c ; \ <nl> + _ Complex type x ; \ <nl> + } ; \ <nl> + ffi _ type ffi _ type _ complex _ # # name = { \ <nl> + sizeof ( _ Complex type ) , \ <nl> + offsetof ( struct struct _ align _ complex _ # # name , x ) , \ <nl> + FFI _ TYPE _ COMPLEX , \ <nl> + ( ffi _ type * * ) ffi _ elements _ complex _ # # name \ <nl> + } <nl> + <nl> + / * Define new complex type descriptors using the macro : * / <nl> + / * ffi _ type _ complex _ sint * / <nl> + FFI _ COMPLEX _ TYPEDEF ( sint , int , ffi _ type _ sint ) ; <nl> + / * ffi _ type _ complex _ uchar * / <nl> + FFI _ COMPLEX _ TYPEDEF ( uchar , unsigned char , ffi _ type _ uint8 ) ; <nl> + <nl> + The new type descriptors can then be used like one of the built - in <nl> + type descriptors in the previous example . <nl> + <nl> +  <nl> + File : libffi . info , Node : Multiple ABIs , Next : The Closure API , Prev : Types , Up : Using libffi <nl> + <nl> + 2 . 4 Multiple ABIs <nl> + = = = = = = = = = = = = = = = = = <nl> + <nl> + A given platform may provide multiple different ABIs at once . For <nl> + instance , the x86 platform has both ' stdcall ' and ' fastcall ' functions . <nl> + <nl> + ' libffi ' provides some support for this . However , this is <nl> + necessarily platform - specific . <nl> + <nl> +  <nl> + File : libffi . info , Node : The Closure API , Next : Closure Example , Prev : Multiple ABIs , Up : Using libffi <nl> + <nl> + 2 . 5 The Closure API <nl> + = = = = = = = = = = = = = = = = = = = <nl> + <nl> + ' libffi ' also provides a way to write a generic function - a function <nl> + that can accept and decode any combination of arguments . This can be <nl> + useful when writing an interpreter , or to provide wrappers for arbitrary <nl> + functions . <nl> + <nl> + This facility is called the " closure API " . Closures are not supported <nl> + on all platforms ; you can check the ' FFI _ CLOSURES ' define to determine <nl> + whether they are supported on the current platform . <nl> + <nl> + Because closures work by assembling a tiny function at runtime , they <nl> + require special allocation on platforms that have a non - executable heap . <nl> + Memory management for closures is handled by a pair of functions : <nl> + <nl> + - - Function : void * ffi _ closure _ alloc ( size _ t SIZE , void * * CODE ) <nl> + Allocate a chunk of memory holding SIZE bytes . This returns a <nl> + pointer to the writable address , and sets * CODE to the <nl> + corresponding executable address . <nl> + <nl> + SIZE should be sufficient to hold a ' ffi _ closure ' object . <nl> + <nl> + - - Function : void ffi _ closure _ free ( void * WRITABLE ) <nl> + Free memory allocated using ' ffi _ closure _ alloc ' . The argument is <nl> + the writable address that was returned . <nl> + <nl> + Once you have allocated the memory for a closure , you must construct <nl> + a ' ffi _ cif ' describing the function call . Finally you can prepare the <nl> + closure function : <nl> + <nl> + - - Function : ffi _ status ffi _ prep _ closure _ loc ( ffi _ closure * CLOSURE , <nl> + ffi _ cif * CIF , void ( * FUN ) ( ffi _ cif * CIF , void * RET , void <nl> + * * ARGS , void * USER _ DATA ) , void * USER _ DATA , void * CODELOC ) <nl> + Prepare a closure function . <nl> + <nl> + CLOSURE is the address of a ' ffi _ closure ' object ; this is the <nl> + writable address returned by ' ffi _ closure _ alloc ' . <nl> + <nl> + CIF is the ' ffi _ cif ' describing the function parameters . <nl> + <nl> + USER _ DATA is an arbitrary datum that is passed , uninterpreted , to <nl> + your closure function . <nl> + <nl> + CODELOC is the executable address returned by ' ffi _ closure _ alloc ' . <nl> + <nl> + FUN is the function which will be called when the closure is <nl> + invoked . It is called with the arguments : <nl> + CIF <nl> + The ' ffi _ cif ' passed to ' ffi _ prep _ closure _ loc ' . <nl> + <nl> + RET <nl> + A pointer to the memory used for the function ' s return value . <nl> + FUN must fill this , unless the function is declared as <nl> + returning ' void ' . <nl> + <nl> + ARGS <nl> + A vector of pointers to memory holding the arguments to the <nl> + function . <nl> + <nl> + USER _ DATA <nl> + The same USER _ DATA that was passed to ' ffi _ prep _ closure _ loc ' . <nl> + <nl> + ' ffi _ prep _ closure _ loc ' will return ' FFI _ OK ' if everything went ok , <nl> + and something else on error . <nl> + <nl> + After calling ' ffi _ prep _ closure _ loc ' , you can cast CODELOC to the <nl> + appropriate pointer - to - function type . <nl> + <nl> + You may see old code referring to ' ffi _ prep _ closure ' . This function <nl> + is deprecated , as it cannot handle the need for separate writable and <nl> + executable addresses . <nl> + <nl> +  <nl> + File : libffi . info , Node : Closure Example , Prev : The Closure API , Up : Using libffi <nl> + <nl> + 2 . 6 Closure Example <nl> + = = = = = = = = = = = = = = = = = = = <nl> + <nl> + A trivial example that creates a new ' puts ' by binding ' fputs ' with <nl> + ' stdout ' . <nl> + <nl> + # include < stdio . h > <nl> + # include < ffi . h > <nl> + <nl> + / * Acts like puts with the file given at time of enclosure . * / <nl> + void puts _ binding ( ffi _ cif * cif , void * ret , void * args [ ] , <nl> + void * stream ) <nl> + { <nl> + * ( ffi _ arg * ) ret = fputs ( * ( char * * ) args [ 0 ] , ( FILE * ) stream ) ; <nl> + } <nl> + <nl> + typedef int ( * puts _ t ) ( char * ) ; <nl> + <nl> + int main ( ) <nl> + { <nl> + ffi _ cif cif ; <nl> + ffi _ type * args [ 1 ] ; <nl> + ffi _ closure * closure ; <nl> + <nl> + void * bound _ puts ; <nl> + int rc ; <nl> + <nl> + / * Allocate closure and bound _ puts * / <nl> + closure = ffi _ closure _ alloc ( sizeof ( ffi _ closure ) , & bound _ puts ) ; <nl> + <nl> + if ( closure ) <nl> + { <nl> + / * Initialize the argument info vectors * / <nl> + args [ 0 ] = & ffi _ type _ pointer ; <nl> + <nl> + / * Initialize the cif * / <nl> + if ( ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 1 , <nl> + & ffi _ type _ sint , args ) = = FFI _ OK ) <nl> + { <nl> + / * Initialize the closure , setting stream to stdout * / <nl> + if ( ffi _ prep _ closure _ loc ( closure , & cif , puts _ binding , <nl> + stdout , bound _ puts ) = = FFI _ OK ) <nl> + { <nl> + rc = ( ( puts _ t ) bound _ puts ) ( " Hello World ! " ) ; <nl> + / * rc now holds the result of the call to fputs * / <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * Deallocate both closure , and bound _ puts * / <nl> + ffi _ closure _ free ( closure ) ; <nl> + <nl> + return 0 ; <nl> + } <nl> + <nl> + <nl> +  <nl> + File : libffi . info , Node : Missing Features , Next : Index , Prev : Using libffi , Up : Top <nl> + <nl> + 3 Missing Features <nl> + * * * * * * * * * * * * * * * * * * <nl> + <nl> + ' libffi ' is missing a few features . We welcome patches to add support <nl> + for these . <nl> + <nl> + * Variadic closures . <nl> + <nl> + * There is no support for bit fields in structures . <nl> + <nl> + * The closure API is <nl> + <nl> + * The " raw " API is undocumented . <nl> + <nl> + Note that variadic support is very new and tested on a relatively <nl> + small number of platforms . <nl> + <nl> +  <nl> + File : libffi . info , Node : Index , Prev : Missing Features , Up : Top <nl> + <nl> + Index <nl> + * * * * * <nl> + <nl> +    [ index    ] <nl> + * Menu : <nl> + <nl> + * ABI : Introduction . ( line 13 ) <nl> + * Application Binary Interface : Introduction . ( line 13 ) <nl> + * calling convention : Introduction . ( line 13 ) <nl> + * cif : The Basics . ( line 14 ) <nl> + * closure API : The Closure API . ( line 13 ) <nl> + * closures : The Closure API . ( line 13 ) <nl> + * FFI : Introduction . ( line 31 ) <nl> + * ffi _ call : The Basics . ( line 62 ) <nl> + * FFI _ CLOSURES : The Closure API . ( line 13 ) <nl> + * ffi _ closure _ alloc : The Closure API . ( line 19 ) <nl> + * ffi _ closure _ free : The Closure API . ( line 26 ) <nl> + * ffi _ prep _ cif : The Basics . ( line 16 ) <nl> + * ffi _ prep _ cif _ var : The Basics . ( line 39 ) <nl> + * ffi _ prep _ closure _ loc : The Closure API . ( line 34 ) <nl> + * ffi _ status : The Basics . ( line 16 ) <nl> + * ffi _ status < 1 > : The Basics . ( line 39 ) <nl> + * ffi _ status < 2 > : The Closure API . ( line 34 ) <nl> + * ffi _ type : Structures . ( line 11 ) <nl> + * ffi _ type < 1 > : Structures . ( line 11 ) <nl> + * ffi _ type < 2 > : Complex . ( line 15 ) <nl> + * ffi _ type < 3 > : Complex . ( line 15 ) <nl> + * ffi _ type _ complex _ double : Primitive Types . ( line 82 ) <nl> + * ffi _ type _ complex _ float : Primitive Types . ( line 79 ) <nl> + * ffi _ type _ complex _ longdouble : Primitive Types . ( line 85 ) <nl> + * ffi _ type _ double : Primitive Types . ( line 41 ) <nl> + * ffi _ type _ float : Primitive Types . ( line 38 ) <nl> + * ffi _ type _ longdouble : Primitive Types . ( line 71 ) <nl> + * ffi _ type _ pointer : Primitive Types . ( line 75 ) <nl> + * ffi _ type _ schar : Primitive Types . ( line 47 ) <nl> + * ffi _ type _ sint : Primitive Types . ( line 62 ) <nl> + * ffi _ type _ sint16 : Primitive Types . ( line 23 ) <nl> + * ffi _ type _ sint32 : Primitive Types . ( line 29 ) <nl> + * ffi _ type _ sint64 : Primitive Types . ( line 35 ) <nl> + * ffi _ type _ sint8 : Primitive Types . ( line 17 ) <nl> + * ffi _ type _ slong : Primitive Types . ( line 68 ) <nl> + * ffi _ type _ sshort : Primitive Types . ( line 56 ) <nl> + * ffi _ type _ uchar : Primitive Types . ( line 44 ) <nl> + * ffi _ type _ uint : Primitive Types . ( line 59 ) <nl> + * ffi _ type _ uint16 : Primitive Types . ( line 20 ) <nl> + * ffi _ type _ uint32 : Primitive Types . ( line 26 ) <nl> + * ffi _ type _ uint64 : Primitive Types . ( line 32 ) <nl> + * ffi _ type _ uint8 : Primitive Types . ( line 14 ) <nl> + * ffi _ type _ ulong : Primitive Types . ( line 65 ) <nl> + * ffi _ type _ ushort : Primitive Types . ( line 53 ) <nl> + * ffi _ type _ void : Primitive Types . ( line 10 ) <nl> + * Foreign Function Interface : Introduction . ( line 31 ) <nl> + * void : The Basics . ( line 62 ) <nl> + * void < 1 > : The Closure API . ( line 19 ) <nl> + * void < 2 > : The Closure API . ( line 26 ) <nl> + <nl> + <nl> +  <nl> + Tag Table : <nl> + Node : Top  682 <nl> + Node : Introduction  1429 <nl> + Node : Using libffi  3061 <nl> + Node : The Basics  3547 <nl> + Node : Simple Example  7198 <nl> + Node : Types  8229 <nl> + Node : Primitive Types  8613 <nl> + Node : Structures  10734 <nl> + Node : Type Example  11608 <nl> + Node : Complex  12890 <nl> + Node : Complex Type Example  14308 <nl> + Node : Multiple ABIs  17360 <nl> + Node : The Closure API  17731 <nl> + Node : Closure Example  20675 <nl> + Node : Missing Features  22285 <nl> + Node : Index  22738 <nl> +  <nl> + End Tag Table
NEAREST DIFF (one line): diff - - git a / build - iphone . sh b / build - iphone . sh <nl> new file mode 100755 <nl> index 0000000 . . a3593aa <nl> - - - / dev / null <nl> + + + b / build - iphone . sh <nl> @ @ - 0 , 0 + 1 , 12 @ @ <nl> + # ! / bin / sh <nl> + <nl> + PLATFORM _ IOS = / Developer / Platforms / iPhoneOS . platform / <nl> + PLATFORM _ IOS _ SIM = / Developer / Platforms / iPhoneSimulator . platform / <nl> + SDK _ IOS _ VERSION = " 4 . 1 " <nl> + <nl> + mkdir - p " build - ios " <nl> + pushd " build - ios " <nl> + export CC = " $ { PLATFORM _ IOS } " / Developer / usr / bin / gcc - 4 . 2 <nl> + export CFLAGS = " - arch armv6 - isysroot $ { PLATFORM _ IOS } / Developer / SDKs / iPhoneOS $ { SDK _ IOS _ VERSION } . sdk / " <nl> + . . / configure - - host = armv6 - apple - darwin & & make <nl> + popd

TEST DIFF:
diff - - git a / native / libffi / doc / libffi . info b / native / libffi / doc / libffi . info 
 new file mode 100644 
 index 0000000 . . b0100b2 
 - - - / dev / null 
 + + + b / native / libffi / doc / libffi . info 
 @ @ - 0 , 0 + 1 , 766 @ @ 
 + This is libffi . info , produced by makeinfo version 5 . 2 from libffi . texi . 
 + 
 + This manual is for Libffi , a portable foreign - function interface 
 + library . 
 + 
 + Copyright ( C ) 2008 , 2010 , 2011 Red Hat , Inc . 
 + 
 + Permission is granted to copy , distribute and / or modify this 
 + document under the terms of the GNU General Public License as 
 + published by the Free Software Foundation ; either version 2 , or ( at 
 + your option ) any later version . A copy of the license is included 
 + in the section entitled " GNU General Public License " . 
 + 
 + INFO - DIR - SECTION Development 
 + START - INFO - DIR - ENTRY 
 + * libffi : ( libffi ) . Portable foreign - function interface library . 
 + END - INFO - DIR - ENTRY 
 + 
 +  
 + File : libffi . info , Node : Top , Next : Introduction , Up : ( dir ) 
 + 
 + libffi 
 + * * * * * * 
 + 
 + This manual is for Libffi , a portable foreign - function interface 
 + library . 
 + 
 + Copyright ( C ) 2008 , 2010 , 2011 Red Hat , Inc . 
 + 
 + Permission is granted to copy , distribute and / or modify this 
 + document under the terms of the GNU General Public License as 
 + published by the Free Software Foundation ; either version 2 , or ( at 
 + your option ) any later version . A copy of the license is included 
 + in the section entitled " GNU General Public License " . 
 + 
 + * Menu : 
 + 
 + * Introduction : : What is libffi ? 
 + * Using libffi : : How to use libffi . 
 + * Missing Features : : Things libffi can ' t do . 
 + * Index : : Index . 
 + 
 +  
 + File : libffi . info , Node : Introduction , Next : Using libffi , Prev : Top , Up : Top 
 + 
 + 1 What is libffi ? 
 + * * * * * * * * * * * * * * * * * 
 + 
 + Compilers for high level languages generate code that follow certain 
 + conventions . These conventions are necessary , in part , for separate 
 + compilation to work . One such convention is the " calling convention " . 
 + The calling convention is a set of assumptions made by the compiler 
 + about where function arguments will be found on entry to a function . A 
 + calling convention also specifies where the return value for a function 
 + is found . The calling convention is also sometimes called the " ABI " or 
 + " Application Binary Interface " . 
 + 
 + Some programs may not know at the time of compilation what arguments 
 + are to be passed to a function . For instance , an interpreter may be 
 + told at run - time about the number and types of arguments used to call a 
 + given function . ' Libffi ' can be used in such programs to provide a 
 + bridge from the interpreter program to compiled code . 
 + 
 + The ' libffi ' library provides a portable , high level programming 
 + interface to various calling conventions . This allows a programmer to 
 + call any function specified by a call interface description at run time . 
 + 
 + FFI stands for Foreign Function Interface . A foreign function 
 + interface is the popular name for the interface that allows code written 
 + in one language to call code written in another language . The ' libffi ' 
 + library really only provides the lowest , machine dependent layer of a 
 + fully featured foreign function interface . A layer must exist above 
 + ' libffi ' that handles type conversions for values passed between the two 
 + languages . 
 + 
 +  
 + File : libffi . info , Node : Using libffi , Next : Missing Features , Prev : Introduction , Up : Top 
 + 
 + 2 Using libffi 
 + * * * * * * * * * * * * * * 
 + 
 + * Menu : 
 + 
 + * The Basics : : The basic libffi API . 
 + * Simple Example : : A simple example . 
 + * Types : : libffi type descriptions . 
 + * Multiple ABIs : : Different passing styles on one platform . 
 + * The Closure API : : Writing a generic function . 
 + * Closure Example : : A closure example . 
 + 
 +  
 + File : libffi . info , Node : The Basics , Next : Simple Example , Up : Using libffi 
 + 
 + 2 . 1 The Basics 
 + = = = = = = = = = = = = = = 
 + 
 + ' Libffi ' assumes that you have a pointer to the function you wish to 
 + call and that you know the number and types of arguments to pass it , as 
 + well as the return type of the function . 
 + 
 + The first thing you must do is create an ' ffi _ cif ' object that 
 + matches the signature of the function you wish to call . This is a 
 + separate step because it is common to make multiple calls using a single 
 + ' ffi _ cif ' . The " cif " in ' ffi _ cif ' stands for Call InterFace . To 
 + prepare a call interface object , use the function ' ffi _ prep _ cif ' . 
 + 
 + - - Function : ffi _ status ffi _ prep _ cif ( ffi _ cif * CIF , ffi _ abi ABI , 
 + unsigned int NARGS , ffi _ type * RTYPE , ffi _ type * * ARGTYPES ) 
 + This initializes CIF according to the given parameters . 
 + 
 + ABI is the ABI to use ; normally ' FFI _ DEFAULT _ ABI ' is what you want . 
 + * note Multiple ABIs : : for more information . 
 + 
 + NARGS is the number of arguments that this function accepts . 
 + 
 + RTYPE is a pointer to an ' ffi _ type ' structure that describes the 
 + return type of the function . * Note Types : : . 
 + 
 + ARGTYPES is a vector of ' ffi _ type ' pointers . ARGTYPES must have 
 + NARGS elements . If NARGS is 0 , this argument is ignored . 
 + 
 + ' ffi _ prep _ cif ' returns a ' libffi ' status code , of type 
 + ' ffi _ status ' . This will be either ' FFI _ OK ' if everything worked 
 + properly ; ' FFI _ BAD _ TYPEDEF ' if one of the ' ffi _ type ' objects is 
 + incorrect ; or ' FFI _ BAD _ ABI ' if the ABI parameter is invalid . 
 + 
 + If the function being called is variadic ( varargs ) then 
 + ' ffi _ prep _ cif _ var ' must be used instead of ' ffi _ prep _ cif ' . 
 + 
 + - - Function : ffi _ status ffi _ prep _ cif _ var ( ffi _ cif * CIF , ffi _ abi varabi , 
 + unsigned int NFIXEDARGS , unsigned int varntotalargs , ffi _ type 
 + * RTYPE , ffi _ type * * ARGTYPES ) 
 + This initializes CIF according to the given parameters for a call 
 + to a variadic function . In general it ' s operation is the same as 
 + for ' ffi _ prep _ cif ' except that : 
 + 
 + NFIXEDARGS is the number of fixed arguments , prior to any variadic 
 + arguments . It must be greater than zero . 
 + 
 + NTOTALARGS the total number of arguments , including variadic and 
 + fixed arguments . 
 + 
 + Note that , different cif ' s must be prepped for calls to the same 
 + function when different numbers of arguments are passed . 
 + 
 + Also note that a call to ' ffi _ prep _ cif _ var ' with 
 + NFIXEDARGS = NOTOTALARGS is NOT equivalent to a call to 
 + ' ffi _ prep _ cif ' . 
 + 
 + To call a function using an initialized ' ffi _ cif ' , use the ' ffi _ call ' 
 + function : 
 + 
 + - - Function : void ffi _ call ( ffi _ cif * CIF , void * FN , void * RVALUE , void 
 + * * AVALUES ) 
 + This calls the function FN according to the description given in 
 + CIF . CIF must have already been prepared using ' ffi _ prep _ cif ' . 
 + 
 + RVALUE is a pointer to a chunk of memory that will hold the result 
 + of the function call . This must be large enough to hold the 
 + result , no smaller than the system register size ( generally 32 or 
 + 64 bits ) , and must be suitably aligned ; it is the caller ' s 
 + responsibility to ensure this . If CIF declares that the function 
 + returns ' void ' ( using ' ffi _ type _ void ' ) , then RVALUE is ignored . 
 + 
 + AVALUES is a vector of ' void * ' pointers that point to the memory 
 + locations holding the argument values for a call . If CIF declares 
 + that the function has no arguments ( i . e . , NARGS was 0 ) , then 
 + AVALUES is ignored . Note that argument values may be modified by 
 + the callee ( for instance , structs passed by value ) ; the burden of 
 + copying pass - by - value arguments is placed on the caller . 
 + 
 +  
 + File : libffi . info , Node : Simple Example , Next : Types , Prev : The Basics , Up : Using libffi 
 + 
 + 2 . 2 Simple Example 
 + = = = = = = = = = = = = = = = = = = 
 + 
 + Here is a trivial example that calls ' puts ' a few times . 
 + 
 + # include < stdio . h > 
 + # include < ffi . h > 
 + 
 + int main ( ) 
 + { 
 + ffi _ cif cif ; 
 + ffi _ type * args [ 1 ] ; 
 + void * values [ 1 ] ; 
 + char * s ; 
 + ffi _ arg rc ; 
 + 
 + / * Initialize the argument info vectors * / 
 + args [ 0 ] = & ffi _ type _ pointer ; 
 + values [ 0 ] = & s ; 
 + 
 + / * Initialize the cif * / 
 + if ( ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 1 , 
 + 	 	 & ffi _ type _ sint , args ) = = FFI _ OK ) 
 + { 
 + s = " Hello World ! " ; 
 + ffi _ call ( & cif , puts , & rc , values ) ; 
 + / * rc now holds the result of the call to puts * / 
 + 
 + / * values holds a pointer to the function ' s arg , so to 
 + call puts ( ) again all we need to do is change the 
 + value of s * / 
 + s = " This is cool ! " ; 
 + ffi _ call ( & cif , puts , & rc , values ) ; 
 + } 
 + 
 + return 0 ; 
 + } 
 + 
 +  
 + File : libffi . info , Node : Types , Next : Multiple ABIs , Prev : Simple Example , Up : Using libffi 
 + 
 + 2 . 3 Types 
 + = = = = = = = = = 
 + 
 + * Menu : 
 + 
 + * Primitive Types : : Built - in types . 
 + * Structures : : Structure types . 
 + * Type Example : : Structure type example . 
 + * Complex : : Complex types . 
 + * Complex Type Example : : Complex type example . 
 + 
 +  
 + File : libffi . info , Node : Primitive Types , Next : Structures , Up : Types 
 + 
 + 2 . 3 . 1 Primitive Types 
 + - - - - - - - - - - - - - - - - - - - - - 
 + 
 + ' Libffi ' provides a number of built - in type descriptors that can be used 
 + to describe argument and return types : 
 + 
 + ' ffi _ type _ void ' 
 + The type ' void ' . This cannot be used for argument types , only for 
 + return values . 
 + 
 + ' ffi _ type _ uint8 ' 
 + An unsigned , 8 - bit integer type . 
 + 
 + ' ffi _ type _ sint8 ' 
 + A signed , 8 - bit integer type . 
 + 
 + ' ffi _ type _ uint16 ' 
 + An unsigned , 16 - bit integer type . 
 + 
 + ' ffi _ type _ sint16 ' 
 + A signed , 16 - bit integer type . 
 + 
 + ' ffi _ type _ uint32 ' 
 + An unsigned , 32 - bit integer type . 
 + 
 + ' ffi _ type _ sint32 ' 
 + A signed , 32 - bit integer type . 
 + 
 + ' ffi _ type _ uint64 ' 
 + An unsigned , 64 - bit integer type . 
 + 
 + ' ffi _ type _ sint64 ' 
 + A signed , 64 - bit integer type . 
 + 
 + ' ffi _ type _ float ' 
 + The C ' float ' type . 
 + 
 + ' ffi _ type _ double ' 
 + The C ' double ' type . 
 + 
 + ' ffi _ type _ uchar ' 
 + The C ' unsigned char ' type . 
 + 
 + ' ffi _ type _ schar ' 
 + The C ' signed char ' type . ( Note that there is not an exact 
 + equivalent to the C ' char ' type in ' libffi ' ; ordinarily you should 
 + either use ' ffi _ type _ schar ' or ' ffi _ type _ uchar ' depending on 
 + whether ' char ' is signed . ) 
 + 
 + ' ffi _ type _ ushort ' 
 + The C ' unsigned short ' type . 
 + 
 + ' ffi _ type _ sshort ' 
 + The C ' short ' type . 
 + 
 + ' ffi _ type _ uint ' 
 + The C ' unsigned int ' type . 
 + 
 + ' ffi _ type _ sint ' 
 + The C ' int ' type . 
 + 
 + ' ffi _ type _ ulong ' 
 + The C ' unsigned long ' type . 
 + 
 + ' ffi _ type _ slong ' 
 + The C ' long ' type . 
 + 
 + ' ffi _ type _ longdouble ' 
 + On platforms that have a C ' long double ' type , this is defined . On 
 + other platforms , it is not . 
 + 
 + ' ffi _ type _ pointer ' 
 + A generic ' void * ' pointer . You should use this for all pointers , 
 + regardless of their real type . 
 + 
 + ' ffi _ type _ complex _ float ' 
 + The C ' _ Complex float ' type . 
 + 
 + ' ffi _ type _ complex _ double ' 
 + The C ' _ Complex double ' type . 
 + 
 + ' ffi _ type _ complex _ longdouble ' 
 + The C ' _ Complex long double ' type . On platforms that have a C 
 + ' long double ' type , this is defined . On other platforms , it is 
 + not . 
 + 
 + Each of these is of type ' ffi _ type ' , so you must take the address 
 + when passing to ' ffi _ prep _ cif ' . 
 + 
 +  
 + File : libffi . info , Node : Structures , Next : Type Example , Prev : Primitive Types , Up : Types 
 + 
 + 2 . 3 . 2 Structures 
 + - - - - - - - - - - - - - - - - 
 + 
 + Although ' libffi ' has no special support for unions or bit - fields , it is 
 + perfectly happy passing structures back and forth . You must first 
 + describe the structure to ' libffi ' by creating a new ' ffi _ type ' object 
 + for it . 
 + 
 + - - Data type : ffi _ type 
 + The ' ffi _ type ' has the following members : 
 + ' size _ t size ' 
 + This is set by ' libffi ' ; you should initialize it to zero . 
 + 
 + ' unsigned short alignment ' 
 + This is set by ' libffi ' ; you should initialize it to zero . 
 + 
 + ' unsigned short type ' 
 + For a structure , this should be set to ' FFI _ TYPE _ STRUCT ' . 
 + 
 + ' ffi _ type * * elements ' 
 + This is a ' NULL ' - terminated array of pointers to ' ffi _ type ' 
 + objects . There is one element per field of the struct . 
 + 
 +  
 + File : libffi . info , Node : Type Example , Next : Complex , Prev : Structures , Up : Types 
 + 
 + 2 . 3 . 3 Type Example 
 + - - - - - - - - - - - - - - - - - - 
 + 
 + The following example initializes a ' ffi _ type ' object representing the 
 + ' tm ' struct from Linux ' s ' time . h ' . 
 + 
 + Here is how the struct is defined : 
 + 
 + struct tm { 
 + int tm _ sec ; 
 + int tm _ min ; 
 + int tm _ hour ; 
 + int tm _ mday ; 
 + int tm _ mon ; 
 + int tm _ year ; 
 + int tm _ wday ; 
 + int tm _ yday ; 
 + int tm _ isdst ; 
 + / * Those are for future use . * / 
 + long int _ _ tm _ gmtoff _ _ ; 
 + _ _ const char * _ _ tm _ zone _ _ ; 
 + } ; 
 + 
 + Here is the corresponding code to describe this struct to ' libffi ' : 
 + 
 + { 
 + ffi _ type tm _ type ; 
 + ffi _ type * tm _ type _ elements [ 12 ] ; 
 + int i ; 
 + 
 + tm _ type . size = tm _ type . alignment = 0 ; 
 + tm _ type . type = FFI _ TYPE _ STRUCT ; 
 + tm _ type . elements = & tm _ type _ elements ; 
 + 
 + for ( i = 0 ; i < 9 ; i + + ) 
 + tm _ type _ elements [ i ] = & ffi _ type _ sint ; 
 + 
 + tm _ type _ elements [ 9 ] = & ffi _ type _ slong ; 
 + tm _ type _ elements [ 10 ] = & ffi _ type _ pointer ; 
 + tm _ type _ elements [ 11 ] = NULL ; 
 + 
 + / * tm _ type can now be used to represent tm argument types and 
 + 	 return types for ffi _ prep _ cif ( ) * / 
 + } 
 + 
 +  
 + File : libffi . info , Node : Complex , Next : Complex Type Example , Prev : Type Example , Up : Types 
 + 
 + 2 . 3 . 4 Complex Types 
 + - - - - - - - - - - - - - - - - - - - 
 + 
 + ' libffi ' supports the complex types defined by the C99 standard 
 + ( ' _ Complex float ' , ' _ Complex double ' and ' _ Complex long double ' with the 
 + built - in type descriptors ' ffi _ type _ complex _ float ' , 
 + ' ffi _ type _ complex _ double ' and ' ffi _ type _ complex _ longdouble ' . 
 + 
 + Custom complex types like ' _ Complex int ' can also be used . An 
 + ' ffi _ type ' object has to be defined to describe the complex type to 
 + ' libffi ' . 
 + 
 + - - Data type : ffi _ type 
 + ' size _ t size ' 
 + This must be manually set to the size of the complex type . 
 + 
 + ' unsigned short alignment ' 
 + This must be manually set to the alignment of the complex 
 + type . 
 + 
 + ' unsigned short type ' 
 + For a complex type , this must be set to ' FFI _ TYPE _ COMPLEX ' . 
 + 
 + ' ffi _ type * * elements ' 
 + 
 + This is a ' NULL ' - terminated array of pointers to ' ffi _ type ' 
 + objects . The first element is set to the ' ffi _ type ' of the 
 + complex ' s base type . The second element must be set to 
 + ' NULL ' . 
 + 
 + The section * note Complex Type Example : : shows a way to determine the 
 + ' size ' and ' alignment ' members in a platform independent way . 
 + 
 + For platforms that have no complex support in ' libffi ' yet , the 
 + functions ' ffi _ prep _ cif ' and ' ffi _ prep _ args ' abort the program if they 
 + encounter a complex type . 
 + 
 +  
 + File : libffi . info , Node : Complex Type Example , Prev : Complex , Up : Types 
 + 
 + 2 . 3 . 5 Complex Type Example 
 + - - - - - - - - - - - - - - - - - - - - - - - - - - 
 + 
 + This example demonstrates how to use complex types : 
 + 
 + # include < stdio . h > 
 + # include < ffi . h > 
 + # include < complex . h > 
 + 
 + void complex _ fn ( _ Complex float cf , 
 + _ Complex double cd , 
 + _ Complex long double cld ) 
 + { 
 + printf ( " cf = % f + % fi \ ncd = % f + % fi \ ncld = % f + % fi \ n " , 
 + ( float ) creal ( cf ) , ( float ) cimag ( cf ) , 
 + ( float ) creal ( cd ) , ( float ) cimag ( cd ) , 
 + ( float ) creal ( cld ) , ( float ) cimag ( cld ) ) ; 
 + } 
 + 
 + int main ( ) 
 + { 
 + ffi _ cif cif ; 
 + ffi _ type * args [ 3 ] ; 
 + void * values [ 3 ] ; 
 + _ Complex float cf ; 
 + _ Complex double cd ; 
 + _ Complex long double cld ; 
 + 
 + / * Initialize the argument info vectors * / 
 + args [ 0 ] = & ffi _ type _ complex _ float ; 
 + args [ 1 ] = & ffi _ type _ complex _ double ; 
 + args [ 2 ] = & ffi _ type _ complex _ longdouble ; 
 + values [ 0 ] = & cf ; 
 + values [ 1 ] = & cd ; 
 + values [ 2 ] = & cld ; 
 + 
 + / * Initialize the cif * / 
 + if ( ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 3 , 
 + & ffi _ type _ void , args ) = = FFI _ OK ) 
 + { 
 + cf = 1 . 0 + 20 . 0 * I ; 
 + cd = 300 . 0 + 4000 . 0 * I ; 
 + cld = 50000 . 0 + 600000 . 0 * I ; 
 + / * Call the function * / 
 + ffi _ call ( & cif , ( void ( * ) ( void ) ) complex _ fn , 0 , values ) ; 
 + } 
 + 
 + return 0 ; 
 + } 
 + 
 + This is an example for defining a custom complex type descriptor for 
 + compilers that support them : 
 + 
 + / * 
 + * This macro can be used to define new complex type descriptors 
 + * in a platform independent way . 
 + * 
 + * name : Name of the new descriptor is ffi _ type _ complex _ < name > . 
 + * type : The C base type of the complex type . 
 + * / 
 + # define FFI _ COMPLEX _ TYPEDEF ( name , type , ffitype ) \ 
 + static ffi _ type * ffi _ elements _ complex _ # # name [ 2 ] = { \ 
 + ( ffi _ type * ) ( & ffitype ) , NULL \ 
 + } ; \ 
 + struct struct _ align _ complex _ # # name { \ 
 + char c ; \ 
 + _ Complex type x ; \ 
 + } ; \ 
 + ffi _ type ffi _ type _ complex _ # # name = { \ 
 + sizeof ( _ Complex type ) , \ 
 + offsetof ( struct struct _ align _ complex _ # # name , x ) , \ 
 + FFI _ TYPE _ COMPLEX , \ 
 + ( ffi _ type * * ) ffi _ elements _ complex _ # # name \ 
 + } 
 + 
 + / * Define new complex type descriptors using the macro : * / 
 + / * ffi _ type _ complex _ sint * / 
 + FFI _ COMPLEX _ TYPEDEF ( sint , int , ffi _ type _ sint ) ; 
 + / * ffi _ type _ complex _ uchar * / 
 + FFI _ COMPLEX _ TYPEDEF ( uchar , unsigned char , ffi _ type _ uint8 ) ; 
 + 
 + The new type descriptors can then be used like one of the built - in 
 + type descriptors in the previous example . 
 + 
 +  
 + File : libffi . info , Node : Multiple ABIs , Next : The Closure API , Prev : Types , Up : Using libffi 
 + 
 + 2 . 4 Multiple ABIs 
 + = = = = = = = = = = = = = = = = = 
 + 
 + A given platform may provide multiple different ABIs at once . For 
 + instance , the x86 platform has both ' stdcall ' and ' fastcall ' functions . 
 + 
 + ' libffi ' provides some support for this . However , this is 
 + necessarily platform - specific . 
 + 
 +  
 + File : libffi . info , Node : The Closure API , Next : Closure Example , Prev : Multiple ABIs , Up : Using libffi 
 + 
 + 2 . 5 The Closure API 
 + = = = = = = = = = = = = = = = = = = = 
 + 
 + ' libffi ' also provides a way to write a generic function - a function 
 + that can accept and decode any combination of arguments . This can be 
 + useful when writing an interpreter , or to provide wrappers for arbitrary 
 + functions . 
 + 
 + This facility is called the " closure API " . Closures are not supported 
 + on all platforms ; you can check the ' FFI _ CLOSURES ' define to determine 
 + whether they are supported on the current platform . 
 + 
 + Because closures work by assembling a tiny function at runtime , they 
 + require special allocation on platforms that have a non - executable heap . 
 + Memory management for closures is handled by a pair of functions : 
 + 
 + - - Function : void * ffi _ closure _ alloc ( size _ t SIZE , void * * CODE ) 
 + Allocate a chunk of memory holding SIZE bytes . This returns a 
 + pointer to the writable address , and sets * CODE to the 
 + corresponding executable address . 
 + 
 + SIZE should be sufficient to hold a ' ffi _ closure ' object . 
 + 
 + - - Function : void ffi _ closure _ free ( void * WRITABLE ) 
 + Free memory allocated using ' ffi _ closure _ alloc ' . The argument is 
 + the writable address that was returned . 
 + 
 + Once you have allocated the memory for a closure , you must construct 
 + a ' ffi _ cif ' describing the function call . Finally you can prepare the 
 + closure function : 
 + 
 + - - Function : ffi _ status ffi _ prep _ closure _ loc ( ffi _ closure * CLOSURE , 
 + ffi _ cif * CIF , void ( * FUN ) ( ffi _ cif * CIF , void * RET , void 
 + * * ARGS , void * USER _ DATA ) , void * USER _ DATA , void * CODELOC ) 
 + Prepare a closure function . 
 + 
 + CLOSURE is the address of a ' ffi _ closure ' object ; this is the 
 + writable address returned by ' ffi _ closure _ alloc ' . 
 + 
 + CIF is the ' ffi _ cif ' describing the function parameters . 
 + 
 + USER _ DATA is an arbitrary datum that is passed , uninterpreted , to 
 + your closure function . 
 + 
 + CODELOC is the executable address returned by ' ffi _ closure _ alloc ' . 
 + 
 + FUN is the function which will be called when the closure is 
 + invoked . It is called with the arguments : 
 + CIF 
 + The ' ffi _ cif ' passed to ' ffi _ prep _ closure _ loc ' . 
 + 
 + RET 
 + A pointer to the memory used for the function ' s return value . 
 + FUN must fill this , unless the function is declared as 
 + returning ' void ' . 
 + 
 + ARGS 
 + A vector of pointers to memory holding the arguments to the 
 + function . 
 + 
 + USER _ DATA 
 + The same USER _ DATA that was passed to ' ffi _ prep _ closure _ loc ' . 
 + 
 + ' ffi _ prep _ closure _ loc ' will return ' FFI _ OK ' if everything went ok , 
 + and something else on error . 
 + 
 + After calling ' ffi _ prep _ closure _ loc ' , you can cast CODELOC to the 
 + appropriate pointer - to - function type . 
 + 
 + You may see old code referring to ' ffi _ prep _ closure ' . This function 
 + is deprecated , as it cannot handle the need for separate writable and 
 + executable addresses . 
 + 
 +  
 + File : libffi . info , Node : Closure Example , Prev : The Closure API , Up : Using libffi 
 + 
 + 2 . 6 Closure Example 
 + = = = = = = = = = = = = = = = = = = = 
 + 
 + A trivial example that creates a new ' puts ' by binding ' fputs ' with 
 + ' stdout ' . 
 + 
 + # include < stdio . h > 
 + # include < ffi . h > 
 + 
 + / * Acts like puts with the file given at time of enclosure . * / 
 + void puts _ binding ( ffi _ cif * cif , void * ret , void * args [ ] , 
 + void * stream ) 
 + { 
 + * ( ffi _ arg * ) ret = fputs ( * ( char * * ) args [ 0 ] , ( FILE * ) stream ) ; 
 + } 
 + 
 + typedef int ( * puts _ t ) ( char * ) ; 
 + 
 + int main ( ) 
 + { 
 + ffi _ cif cif ; 
 + ffi _ type * args [ 1 ] ; 
 + ffi _ closure * closure ; 
 + 
 + void * bound _ puts ; 
 + int rc ; 
 + 
 + / * Allocate closure and bound _ puts * / 
 + closure = ffi _ closure _ alloc ( sizeof ( ffi _ closure ) , & bound _ puts ) ; 
 + 
 + if ( closure ) 
 + { 
 + / * Initialize the argument info vectors * / 
 + args [ 0 ] = & ffi _ type _ pointer ; 
 + 
 + / * Initialize the cif * / 
 + if ( ffi _ prep _ cif ( & cif , FFI _ DEFAULT _ ABI , 1 , 
 + & ffi _ type _ sint , args ) = = FFI _ OK ) 
 + { 
 + / * Initialize the closure , setting stream to stdout * / 
 + if ( ffi _ prep _ closure _ loc ( closure , & cif , puts _ binding , 
 + stdout , bound _ puts ) = = FFI _ OK ) 
 + { 
 + rc = ( ( puts _ t ) bound _ puts ) ( " Hello World ! " ) ; 
 + / * rc now holds the result of the call to fputs * / 
 + } 
 + } 
 + } 
 + 
 + / * Deallocate both closure , and bound _ puts * / 
 + ffi _ closure _ free ( closure ) ; 
 + 
 + return 0 ; 
 + } 
 + 
 + 
 +  
 + File : libffi . info , Node : Missing Features , Next : Index , Prev : Using libffi , Up : Top 
 + 
 + 3 Missing Features 
 + * * * * * * * * * * * * * * * * * * 
 + 
 + ' libffi ' is missing a few features . We welcome patches to add support 
 + for these . 
 + 
 + * Variadic closures . 
 + 
 + * There is no support for bit fields in structures . 
 + 
 + * The closure API is 
 + 
 + * The " raw " API is undocumented . 
 + 
 + Note that variadic support is very new and tested on a relatively 
 + small number of platforms . 
 + 
 +  
 + File : libffi . info , Node : Index , Prev : Missing Features , Up : Top 
 + 
 + Index 
 + * * * * * 
 + 
 +    [ index    ] 
 + * Menu : 
 + 
 + * ABI : Introduction . ( line 13 ) 
 + * Application Binary Interface : Introduction . ( line 13 ) 
 + * calling convention : Introduction . ( line 13 ) 
 + * cif : The Basics . ( line 14 ) 
 + * closure API : The Closure API . ( line 13 ) 
 + * closures : The Closure API . ( line 13 ) 
 + * FFI : Introduction . ( line 31 ) 
 + * ffi _ call : The Basics . ( line 62 ) 
 + * FFI _ CLOSURES : The Closure API . ( line 13 ) 
 + * ffi _ closure _ alloc : The Closure API . ( line 19 ) 
 + * ffi _ closure _ free : The Closure API . ( line 26 ) 
 + * ffi _ prep _ cif : The Basics . ( line 16 ) 
 + * ffi _ prep _ cif _ var : The Basics . ( line 39 ) 
 + * ffi _ prep _ closure _ loc : The Closure API . ( line 34 ) 
 + * ffi _ status : The Basics . ( line 16 ) 
 + * ffi _ status < 1 > : The Basics . ( line 39 ) 
 + * ffi _ status < 2 > : The Closure API . ( line 34 ) 
 + * ffi _ type : Structures . ( line 11 ) 
 + * ffi _ type < 1 > : Structures . ( line 11 ) 
 + * ffi _ type < 2 > : Complex . ( line 15 ) 
 + * ffi _ type < 3 > : Complex . ( line 15 ) 
 + * ffi _ type _ complex _ double : Primitive Types . ( line 82 ) 
 + * ffi _ type _ complex _ float : Primitive Types . ( line 79 ) 
 + * ffi _ type _ complex _ longdouble : Primitive Types . ( line 85 ) 
 + * ffi _ type _ double : Primitive Types . ( line 41 ) 
 + * ffi _ type _ float : Primitive Types . ( line 38 ) 
 + * ffi _ type _ longdouble : Primitive Types . ( line 71 ) 
 + * ffi _ type _ pointer : Primitive Types . ( line 75 ) 
 + * ffi _ type _ schar : Primitive Types . ( line 47 ) 
 + * ffi _ type _ sint : Primitive Types . ( line 62 ) 
 + * ffi _ type _ sint16 : Primitive Types . ( line 23 ) 
 + * ffi _ type _ sint32 : Primitive Types . ( line 29 ) 
 + * ffi _ type _ sint64 : Primitive Types . ( line 35 ) 
 + * ffi _ type _ sint8 : Primitive Types . ( line 17 ) 
 + * ffi _ type _ slong : Primitive Types . ( line 68 ) 
 + * ffi _ type _ sshort : Primitive Types . ( line 56 ) 
 + * ffi _ type _ uchar : Primitive Types . ( line 44 ) 
 + * ffi _ type _ uint : Primitive Types . ( line 59 ) 
 + * ffi _ type _ uint16 : Primitive Types . ( line 20 ) 
 + * ffi _ type _ uint32 : Primitive Types . ( line 26 ) 
 + * ffi _ type _ uint64 : Primitive Types . ( line 32 ) 
 + * ffi _ type _ uint8 : Primitive Types . ( line 14 ) 
 + * ffi _ type _ ulong : Primitive Types . ( line 65 ) 
 + * ffi _ type _ ushort : Primitive Types . ( line 53 ) 
 + * ffi _ type _ void : Primitive Types . ( line 10 ) 
 + * Foreign Function Interface : Introduction . ( line 31 ) 
 + * void : The Basics . ( line 62 ) 
 + * void < 1 > : The Closure API . ( line 19 ) 
 + * void < 2 > : The Closure API . ( line 26 ) 
 + 
 + 
 +  
 + Tag Table : 
 + Node : Top  682 
 + Node : Introduction  1429 
 + Node : Using libffi  3061 
 + Node : The Basics  3547 
 + Node : Simple Example  7198 
 + Node : Types  8229 
 + Node : Primitive Types  8613 
 + Node : Structures  10734 
 + Node : Type Example  11608 
 + Node : Complex  12890 
 + Node : Complex Type Example  14308 
 + Node : Multiple ABIs  17360 
 + Node : The Closure API  17731 
 + Node : Closure Example  20675 
 + Node : Missing Features  22285 
 + Node : Index  22738 
 +  
 + End Tag Table

NEAREST DIFF:
diff - - git a / build - iphone . sh b / build - iphone . sh 
 new file mode 100755 
 index 0000000 . . a3593aa 
 - - - / dev / null 
 + + + b / build - iphone . sh 
 @ @ - 0 , 0 + 1 , 12 @ @ 
 + # ! / bin / sh 
 + 
 + PLATFORM _ IOS = / Developer / Platforms / iPhoneOS . platform / 
 + PLATFORM _ IOS _ SIM = / Developer / Platforms / iPhoneSimulator . platform / 
 + SDK _ IOS _ VERSION = " 4 . 1 " 
 + 
 + mkdir - p " build - ios " 
 + pushd " build - ios " 
 + export CC = " $ { PLATFORM _ IOS } " / Developer / usr / bin / gcc - 4 . 2 
 + export CFLAGS = " - arch armv6 - isysroot $ { PLATFORM _ IOS } / Developer / SDKs / iPhoneOS $ { SDK _ IOS _ VERSION } . sdk / " 
 + . . / configure - - host = armv6 - apple - darwin & & make 
 + popd
