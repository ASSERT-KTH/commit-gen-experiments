BLEU SCORE: 0.09652434877402245

TEST MSG: Deliver the callbacks for async transaction
GENERATED MSG: add async write transaction

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index 92ac808 . . b8e1d18 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import android . support . test . runner . AndroidJUnit4 ; <nl> <nl> import org . junit . Rule ; <nl> import org . junit . Test ; <nl> + import org . junit . rules . ExpectedException ; <nl> import org . junit . runner . RunWith ; <nl> <nl> import java . lang . ref . WeakReference ; <nl> @ @ - 66 , 6 + 67 , 8 @ @ public class RealmAsyncQueryTests { <nl> public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; <nl> @ Rule <nl> public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule ( ) ; <nl> + @ Rule <nl> + public final ExpectedException thrown = ExpectedException . none ( ) ; <nl> <nl> <nl> / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> @ @ - 125 , 6 + 128 , 31 @ @ public class RealmAsyncQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> + public void executeTransactionAsync _ onSuccessCallerRealmClosed ( ) throws Throwable { <nl> + final Realm realm = looperThread . realm ; <nl> + assertEquals ( 0 , realm . where ( Owner . class ) . count ( ) ) ; <nl> + <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + Owner owner = realm . createObject ( Owner . class ) ; <nl> + owner . setName ( " Owner " ) ; <nl> + } <nl> + } , new Realm . Transaction . OnSuccess ( ) { <nl> + @ Override <nl> + public void onSuccess ( ) { <nl> + assertTrue ( realm . isClosed ( ) ) ; <nl> + Realm newRealm = Realm . getInstance ( looperThread . realmConfiguration ) ; <nl> + assertEquals ( 1 , newRealm . where ( Owner . class ) . count ( ) ) ; <nl> + assertEquals ( " Owner " , newRealm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + realm . close ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> public void executeTransactionAsync _ onError ( ) throws Throwable { <nl> final Realm realm = looperThread . realm ; <nl> final RuntimeException runtimeException = new RuntimeException ( " Oh ! What a Terrible Failure " ) ; <nl> @ @ - 148 , 6 + 176 , 32 @ @ public class RealmAsyncQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> + public void executeTransactionAsync _ onErrorCallerRealmClosed ( ) throws Throwable { <nl> + final Realm realm = looperThread . realm ; <nl> + final RuntimeException runtimeException = new RuntimeException ( " Oh ! What a Terrible Failure " ) ; <nl> + assertEquals ( 0 , realm . where ( Owner . class ) . count ( ) ) ; <nl> + <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + throw runtimeException ; <nl> + } <nl> + } , new Realm . Transaction . OnError ( ) { <nl> + @ Override <nl> + public void onError ( Throwable error ) { <nl> + assertTrue ( realm . isClosed ( ) ) ; <nl> + Realm newRealm = Realm . getInstance ( looperThread . realmConfiguration ) ; <nl> + assertEquals ( 0 , newRealm . where ( Owner . class ) . count ( ) ) ; <nl> + assertNull ( newRealm . where ( Owner . class ) . findFirst ( ) ) ; <nl> + assertEquals ( runtimeException , error ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + realm . close ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> public void executeTransactionAsync _ NoCallbacks ( ) throws Throwable { <nl> final Realm realm = looperThread . realm ; <nl> assertEquals ( 0 , realm . where ( Owner . class ) . count ( ) ) ; <nl> @ @ - 313 , 6 + 367 , 38 @ @ public class RealmAsyncQueryTests { <nl> } ) ; <nl> } <nl> <nl> + @ Test <nl> + public void executeTransactionAsync _ onSuccessOnNonLooperThreadThrows ( ) { <nl> + Realm realm = Realm . getInstance ( configFactory . createConfiguration ( ) ) ; <nl> + thrown . expect ( IllegalStateException . class ) ; <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + <nl> + } <nl> + } , new Realm . Transaction . OnSuccess ( ) { <nl> + @ Override <nl> + public void onSuccess ( ) { <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void executeTransactionAsync _ onErrorOnNonLooperThreadThrows ( ) { <nl> + Realm realm = Realm . getInstance ( configFactory . createConfiguration ( ) ) ; <nl> + thrown . expect ( IllegalStateException . class ) ; <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + <nl> + } <nl> + } , new Realm . Transaction . OnError ( ) { <nl> + @ Override <nl> + public void onError ( Throwable error ) { <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> / * <nl> / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> / / * * * promises based async queries * * * <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> index 28a6dfb . . 0126c11 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / Realm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> @ @ - 46 , 10 + 46 , 12 @ @ import java . util . concurrent . atomic . AtomicInteger ; <nl> import io . realm . exceptions . RealmException ; <nl> import io . realm . exceptions . RealmFileException ; <nl> import io . realm . exceptions . RealmMigrationNeededException ; <nl> + import io . realm . internal . Capabilities ; <nl> import io . realm . internal . ColumnIndices ; <nl> import io . realm . internal . ColumnInfo ; <nl> import io . realm . internal . ObjectServerFacade ; <nl> import io . realm . internal . RealmCore ; <nl> + import io . realm . internal . RealmNotifier ; <nl> import io . realm . internal . RealmObjectProxy ; <nl> import io . realm . internal . RealmProxyMediator ; <nl> import io . realm . internal . SharedRealm ; <nl> @ @ - 1315 , 26 + 1317 , 30 @ @ public final class Realm extends BaseRealm { <nl> * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from <nl> * another thread . <nl> * / <nl> - public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , final Realm . Transaction . OnSuccess onSuccess , final Realm . Transaction . OnError onError ) { <nl> + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , <nl> + final Realm . Transaction . OnSuccess onSuccess , <nl> + final Realm . Transaction . OnError onError ) { <nl> checkIfValid ( ) ; <nl> <nl> if ( transaction = = null ) { <nl> throw new IllegalArgumentException ( " Transaction should not be null " ) ; <nl> } <nl> <nl> - / / If the user provided a Callback then we make sure , the current Realm has a Handler <nl> - / / we can use to deliver the result <nl> - / / FIXME : Implement checking here . <nl> - / * <nl> - if ( ( onSuccess ! = null | | onError ! = null ) & & ! hasValidNotifier ( ) ) { <nl> - throw new IllegalStateException ( " Your Realm is opened from a thread without a Looper " + <nl> - " and you provided a callback , we need a Handler to invoke your callback " ) ; <nl> + / / Avoid to call canDeliverNotification ( ) in bg thread . <nl> + final boolean canDeliverNotification = sharedRealm . capabilities . canDeliverNotification ( ) ; <nl> + <nl> + / / If the user provided a Callback then we have to make sure the current Realm has an events looper to deliver <nl> + / / the results . <nl> + if ( ( onSuccess ! = null | | onError ! = null ) & & ! canDeliverNotification ) { <nl> + throw new IllegalStateException ( " Your Realm is opened from a thread without a event looper . " + <nl> + " The callback cannot be invoked . " ) ; <nl> } <nl> - * / <nl> <nl> / / We need to use the same configuration to open a background SharedRealm ( i . e Realm ) <nl> / / to perform the transaction <nl> final RealmConfiguration realmConfiguration = getConfiguration ( ) ; <nl> + / / We need to deliver the callback even if the Realm is closed . So acquire a reference to the notifier here . <nl> + final RealmNotifier realmNotifier = sharedRealm . realmNotifier ; <nl> <nl> final Future < ? > pendingTransaction = asyncTaskExecutor . submitTransaction ( new Runnable ( ) { <nl> @ Override <nl> @ @ - 1343 , 97 + 1349 , 76 @ @ public final class Realm extends BaseRealm { <nl> return ; <nl> } <nl> <nl> - boolean transactionCommitted = false ; <nl> + final SharedRealm . VersionID [ ] versionID = new SharedRealm . VersionID [ 1 ] ; <nl> final Throwable [ ] exception = new Throwable [ 1 ] ; <nl> - / / FIXME : Disable notifier in SharedRealm <nl> + <nl> final Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> bgRealm . beginTransaction ( ) ; <nl> try { <nl> transaction . execute ( bgRealm ) ; <nl> <nl> - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> - / / No need to send change notification to the work thread . <nl> - bgRealm . commitTransaction ( ) ; <nl> - / / The bgRealm needs to be closed before post event to caller ' s handler to avoid concurrency <nl> - / / problem . This is currently guaranteed by posting handleAsyncTransactionCompleted below . <nl> - bgRealm . close ( ) ; <nl> - transactionCommitted = true ; <nl> + if ( Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + return ; <nl> } <nl> + <nl> + bgRealm . commitTransaction ( ) ; <nl> + / / The bgRealm needs to be closed before post event to caller ' s handler to avoid concurrency <nl> + / / problem . This is currently guaranteed by posting callbacks later below . <nl> + versionID [ 0 ] = bgRealm . sharedRealm . getVersionID ( ) ; <nl> } catch ( final Throwable e ) { <nl> exception [ 0 ] = e ; <nl> } finally { <nl> - if ( ! bgRealm . isClosed ( ) ) { <nl> - if ( bgRealm . isInTransaction ( ) ) { <nl> - bgRealm . cancelTransaction ( ) ; <nl> - } else if ( exception [ 0 ] ! = null ) { <nl> - RealmLog . warn ( " Could not cancel transaction , not currently in a transaction . " ) ; <nl> - } <nl> - bgRealm . close ( ) ; <nl> - } <nl> + / / SharedGroup : : close ( ) will cancel the transaction if needed . <nl> + bgRealm . close ( ) ; <nl> + } <nl> <nl> - / / This will be treated like a special REALM _ CHANGED event <nl> - / / FIXME : Find a way to deliver the callback with current architecture <nl> - / * <nl> - final Throwable backgroundException = exception [ 0 ] ; <nl> - / / Send response as the final step to ensure the bg thread quit before others get the response ! <nl> - if ( hasValidNotifier ( ) & & ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> - <nl> - if ( transactionCommitted ) { <nl> - sharedRealm . realmNotifier . post ( new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - handlerController . handleAsyncTransactionCompleted ( onSuccess ! = null ? new Runnable ( ) { <nl> + final Throwable backgroundException = exception [ 0 ] ; <nl> + / / Cannot be interrupted anymore . <nl> + if ( canDeliverNotification ) { <nl> + if ( versionID [ 0 ] ! = null & & onSuccess ! = null ) { <nl> + realmNotifier . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( isClosed ( ) ) { <nl> + / / The caller Realm is closed . Just call the onSuccess . Since the new created Realm <nl> + / / cannot be behind the background one . <nl> + onSuccess . onSuccess ( ) ; <nl> + return ; <nl> + } <nl> + <nl> + if ( sharedRealm . getVersionID ( ) . compareTo ( versionID [ 0 ] ) < 0 ) { <nl> + sharedRealm . realmNotifier . addTransactionCallback ( new Runnable ( ) { <nl> @ Override <nl> public void run ( ) { <nl> onSuccess . onSuccess ( ) ; <nl> } <nl> - } : null ) ; <nl> + } ) ; <nl> + } else { <nl> + onSuccess . onSuccess ( ) ; <nl> } <nl> - } ) ; <nl> - } <nl> - <nl> - / / Send errors directly to the looper , so they don ' t get intercepted by the HandlerController . <nl> - if ( backgroundException ! = null ) { <nl> - if ( onError ! = null ) { <nl> - sharedRealm . realmNotifier . post ( new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - onError . onError ( backgroundException ) ; <nl> - } <nl> - } ) ; <nl> - } else { <nl> - sharedRealm . realmNotifier . post ( new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - if ( backgroundException instanceof RuntimeException ) { <nl> - throw ( RuntimeException ) backgroundException ; <nl> - } else if ( backgroundException instanceof Exception ) { <nl> - throw new RealmException ( " Async transaction failed " , backgroundException ) ; <nl> - } else if ( backgroundException instanceof Error ) { <nl> - throw ( Error ) backgroundException ; <nl> - } <nl> - } <nl> - } ) ; <nl> } <nl> - } <nl> - <nl> - } else { <nl> - / / Throw exception in the worker thread if the caller thread terminated <nl> - if ( backgroundException ! = null ) { <nl> - if ( backgroundException instanceof RuntimeException ) { <nl> - / / noinspection ThrowFromFinallyBlock <nl> - throw ( RuntimeException ) backgroundException ; <nl> - } else if ( backgroundException instanceof Exception ) { <nl> - / / noinspection ThrowFromFinallyBlock <nl> - throw new RealmException ( " Async transaction failed " , backgroundException ) ; <nl> - } else if ( backgroundException instanceof Error ) { <nl> - / / noinspection ThrowFromFinallyBlock <nl> - throw ( Error ) backgroundException ; <nl> + } ) ; <nl> + } else if ( backgroundException ! = null ) { <nl> + realmNotifier . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( onError ! = null ) { <nl> + onError . onError ( backgroundException ) ; <nl> + } else { <nl> + throw new RealmException ( " Async transaction failed " , backgroundException ) ; <nl> + } <nl> } <nl> - } <nl> + } ) ; <nl> + } <nl> + } else { <nl> + if ( backgroundException ! = null ) { <nl> + / / FIXME : ThreadPoolExecutor will never throw the exception in the background . We need a <nl> + / / redesign of the async transaction API . <nl> + / / Throw in the worker thread since the caller thread cannot get notifications . <nl> + throw new RealmException ( " Async transaction failed " , backgroundException ) ; <nl> } <nl> - * / <nl> } <nl> + <nl> } <nl> } ) ; <nl> <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / RealmNotifier . java b / realm / realm - library / src / main / java / io / realm / internal / RealmNotifier . java <nl> index 3243243 . . 826bfe8 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / RealmNotifier . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / RealmNotifier . java <nl> @ @ - 53 , 6 + 53 , 13 @ @ public abstract class RealmNotifier implements Closeable { <nl> } <nl> } ; <nl> <nl> + / / TODO : The only reason we have this is that async transactions is not supported by OS yet . And OS is using ALopper <nl> + / / which will be using a different message queue from which java is using to deliver remote Realm changes message . <nl> + / / We need a way to deliver the async transaction onSuccess callback to the caller thread after the caller Realm <nl> + / / advanced . This is implemented by posting the callback by RealmNotifier . post ( ) first , and check the realm version <nl> + / / in the posted Runnable . If the Realm version there is still behind the async transaction we committed , the <nl> + / / onSuccess callback will be added to this list and be executed later when we get the change event from OS . <nl> + / / This list is NOT supposed to be thread safe ! <nl> private List < Runnable > transactionCallbacks = new ArrayList < Runnable > ( ) ; <nl> <nl> / / This is called by OS when other thread / process changes the Realm . <nl> @ @ - 117 , 5 + 124 , 10 @ @ public abstract class RealmNotifier implements Closeable { <nl> <nl> public abstract void postAtFrontOfQueue ( Runnable runnable ) ; <nl> <nl> + / * * <nl> + * For current implementation of async transaction only . See comments for { @ link # transactionCallbacks } . <nl> + * <nl> + * @ param runnable to be executed in the following event loop . <nl> + * / <nl> public abstract void post ( Runnable runnable ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index 4e7ea04 . . 2c1889c 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 230 , 6 + 230 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> @ Override <nl> public void onError ( Exception t ) { <nl> threadAssertionError [ 0 ] = t ; <nl> + signalCallbackFinished . countDown ( ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 1371 , 6 + 1372 , 74 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } <nl> <nl> + / / * * * Async write transaction * * * / / <nl> + <nl> + public void testAsyncWriteTransaction ( ) throws Throwable { <nl> + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final Looper [ ] looper = new Looper [ 1 ] ; <nl> + final Realm [ ] realm = new Realm [ 1 ] ; <nl> + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + executorService . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + looper [ 0 ] = Looper . myLooper ( ) ; <nl> + try { <nl> + realm [ 0 ] = openRealmInstance ( " test _ async _ write _ transaction " ) ; <nl> + realm [ 0 ] . executeTransaction ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + Owner owner = realm . createObject ( Owner . class ) ; <nl> + owner . setName ( " Owner " ) ; <nl> + } <nl> + } , new Realm . Transaction . Callback ( ) { <nl> + @ Override <nl> + public void onSuccess ( ) { <nl> + try { <nl> + assertEquals ( 1 , realm [ 0 ] . allObjects ( Owner . class ) . size ( ) ) ; <nl> + assertEquals ( " Owner " , realm [ 0 ] . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; <nl> + } catch ( AssertionFailedError e ) { <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void onError ( Throwable e ) { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + Looper . loop ( ) ; <nl> + <nl> + } catch ( Exception e ) { <nl> + e . printStackTrace ( ) ; <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + if ( signalCallbackFinished . getCount ( ) > 0 ) { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + if ( realm . length > 0 & & realm [ 0 ] ! = null ) { <nl> + realm [ 0 ] . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + / / wait until the callback of our async query proceed <nl> + signalCallbackFinished . await ( ) ; <nl> + looper [ 0 ] . quit ( ) ; <nl> + executorService . shutdownNow ( ) ; <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + } <nl> + <nl> / / * * * Helper methods * * * <nl> <nl> / / This could be done from # setUp but then we can ' t control <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index 63c510e . . c8c9c95 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 24 , 6 + 24 , 8 @ @ import android . os . Looper ; <nl> import android . os . Message ; <nl> import android . util . JsonReader ; <nl> <nl> + import org . jetbrains . annotations . NotNull ; <nl> + import org . jetbrains . annotations . Nullable ; <nl> import org . json . JSONArray ; <nl> import org . json . JSONException ; <nl> import org . json . JSONObject ; <nl> @ @ - 47 , 6 + 49 , 7 @ @ import java . util . concurrent . ConcurrentHashMap ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . ExecutorService ; <nl> import java . util . concurrent . Executors ; <nl> + import java . util . concurrent . Future ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> <nl> import io . realm . exceptions . RealmException ; <nl> @ @ - 1507 , 7 + 1510 , 8 @ @ public final class Realm implements Closeable { <nl> * / <nl> public void executeTransaction ( Transaction transaction ) { <nl> if ( transaction = = null ) <nl> - return ; <nl> + throw new IllegalArgumentException ( " transaction should not be null " ) ; <nl> + <nl> beginTransaction ( ) ; <nl> try { <nl> transaction . execute ( this ) ; <nl> @ @ - 1522 , 6 + 1526 , 70 @ @ public final class Realm implements Closeable { <nl> } <nl> <nl> / * * <nl> + * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously from a worker thread <nl> + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . <nl> + * @ param callback optional , to receive the result of this query <nl> + * @ return A { @ link io . realm . RealmQuery . Request } representing a cancellable task <nl> + * / <nl> + public RealmQuery . Request executeTransaction ( final Transaction transaction , @ Nullable final Transaction . Callback callback ) { <nl> + if ( transaction = = null ) <nl> + throw new IllegalArgumentException ( " transaction should not be null " ) ; <nl> + <nl> + / / will use the Looper of the caller thread to post the result <nl> + final Handler handler = new Handler ( ) ; <nl> + <nl> + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) <nl> + / / to perform the transaction <nl> + final RealmConfiguration realmConfiguration = getConfiguration ( ) ; <nl> + <nl> + final Future < ? > pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> + bgRealm . beginTransaction ( ) ; <nl> + try { <nl> + transaction . execute ( bgRealm ) ; <nl> + bgRealm . commitTransaction ( ) ; <nl> + if ( callback ! = null ) { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + callback . onSuccess ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } catch ( final RuntimeException e ) { <nl> + bgRealm . cancelTransaction ( ) ; <nl> + if ( callback ! = null ) { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + callback . onError ( e ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } catch ( final Error e ) { <nl> + bgRealm . cancelTransaction ( ) ; <nl> + if ( callback ! = null ) { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + callback . onError ( e ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } finally { <nl> + bgRealm . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + return new RealmQuery . Request ( pendingQuery ) ; <nl> + } <nl> + <nl> + / * * <nl> * Remove all objects of the specified class . <nl> * <nl> * @ param clazz The class which objects should be removed <nl> @ @ - 1883 , 6 + 1951 , 11 @ @ public final class Realm implements Closeable { <nl> * / <nl> public interface Transaction { <nl> void execute ( Realm realm ) ; <nl> + <nl> + class Callback { <nl> + public void onSuccess ( ) { } <nl> + public void onError ( Throwable e ) { } <nl> + } <nl> } <nl> <nl> / * * <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index 0066c39 . . ebb719a 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1773 , 7 + 1773 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the <nl> * query will post the result to the caller ' s thread callback ) <nl> * / <nl> - public class Request { <nl> + public static class Request { <nl> private Future < ? > pendingQuery ; <nl> private volatile boolean isCancelled = false ; <nl>

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index 92ac808 . . b8e1d18 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import android . support . test . runner . AndroidJUnit4 ; 
 
 import org . junit . Rule ; 
 import org . junit . Test ; 
 + import org . junit . rules . ExpectedException ; 
 import org . junit . runner . RunWith ; 
 
 import java . lang . ref . WeakReference ; 
 @ @ - 66 , 6 + 67 , 8 @ @ public class RealmAsyncQueryTests { 
 public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; 
 @ Rule 
 public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule ( ) ; 
 + @ Rule 
 + public final ExpectedException thrown = ExpectedException . none ( ) ; 
 
 
 / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 @ @ - 125 , 6 + 128 , 31 @ @ public class RealmAsyncQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 + public void executeTransactionAsync _ onSuccessCallerRealmClosed ( ) throws Throwable { 
 + final Realm realm = looperThread . realm ; 
 + assertEquals ( 0 , realm . where ( Owner . class ) . count ( ) ) ; 
 + 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + Owner owner = realm . createObject ( Owner . class ) ; 
 + owner . setName ( " Owner " ) ; 
 + } 
 + } , new Realm . Transaction . OnSuccess ( ) { 
 + @ Override 
 + public void onSuccess ( ) { 
 + assertTrue ( realm . isClosed ( ) ) ; 
 + Realm newRealm = Realm . getInstance ( looperThread . realmConfiguration ) ; 
 + assertEquals ( 1 , newRealm . where ( Owner . class ) . count ( ) ) ; 
 + assertEquals ( " Owner " , newRealm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + realm . close ( ) ; 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 public void executeTransactionAsync _ onError ( ) throws Throwable { 
 final Realm realm = looperThread . realm ; 
 final RuntimeException runtimeException = new RuntimeException ( " Oh ! What a Terrible Failure " ) ; 
 @ @ - 148 , 6 + 176 , 32 @ @ public class RealmAsyncQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 + public void executeTransactionAsync _ onErrorCallerRealmClosed ( ) throws Throwable { 
 + final Realm realm = looperThread . realm ; 
 + final RuntimeException runtimeException = new RuntimeException ( " Oh ! What a Terrible Failure " ) ; 
 + assertEquals ( 0 , realm . where ( Owner . class ) . count ( ) ) ; 
 + 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + throw runtimeException ; 
 + } 
 + } , new Realm . Transaction . OnError ( ) { 
 + @ Override 
 + public void onError ( Throwable error ) { 
 + assertTrue ( realm . isClosed ( ) ) ; 
 + Realm newRealm = Realm . getInstance ( looperThread . realmConfiguration ) ; 
 + assertEquals ( 0 , newRealm . where ( Owner . class ) . count ( ) ) ; 
 + assertNull ( newRealm . where ( Owner . class ) . findFirst ( ) ) ; 
 + assertEquals ( runtimeException , error ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + realm . close ( ) ; 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 public void executeTransactionAsync _ NoCallbacks ( ) throws Throwable { 
 final Realm realm = looperThread . realm ; 
 assertEquals ( 0 , realm . where ( Owner . class ) . count ( ) ) ; 
 @ @ - 313 , 6 + 367 , 38 @ @ public class RealmAsyncQueryTests { 
 } ) ; 
 } 
 
 + @ Test 
 + public void executeTransactionAsync _ onSuccessOnNonLooperThreadThrows ( ) { 
 + Realm realm = Realm . getInstance ( configFactory . createConfiguration ( ) ) ; 
 + thrown . expect ( IllegalStateException . class ) ; 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + 
 + } 
 + } , new Realm . Transaction . OnSuccess ( ) { 
 + @ Override 
 + public void onSuccess ( ) { 
 + } 
 + } ) ; 
 + } 
 + 
 + @ Test 
 + public void executeTransactionAsync _ onErrorOnNonLooperThreadThrows ( ) { 
 + Realm realm = Realm . getInstance ( configFactory . createConfiguration ( ) ) ; 
 + thrown . expect ( IllegalStateException . class ) ; 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + 
 + } 
 + } , new Realm . Transaction . OnError ( ) { 
 + @ Override 
 + public void onError ( Throwable error ) { 
 + } 
 + } ) ; 
 + } 
 + 
 / * 
 / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 / / * * * promises based async queries * * * 
 diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java 
 index 28a6dfb . . 0126c11 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / Realm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / Realm . java 
 @ @ - 46 , 10 + 46 , 12 @ @ import java . util . concurrent . atomic . AtomicInteger ; 
 import io . realm . exceptions . RealmException ; 
 import io . realm . exceptions . RealmFileException ; 
 import io . realm . exceptions . RealmMigrationNeededException ; 
 + import io . realm . internal . Capabilities ; 
 import io . realm . internal . ColumnIndices ; 
 import io . realm . internal . ColumnInfo ; 
 import io . realm . internal . ObjectServerFacade ; 
 import io . realm . internal . RealmCore ; 
 + import io . realm . internal . RealmNotifier ; 
 import io . realm . internal . RealmObjectProxy ; 
 import io . realm . internal . RealmProxyMediator ; 
 import io . realm . internal . SharedRealm ; 
 @ @ - 1315 , 26 + 1317 , 30 @ @ public final class Realm extends BaseRealm { 
 * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from 
 * another thread . 
 * / 
 - public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , final Realm . Transaction . OnSuccess onSuccess , final Realm . Transaction . OnError onError ) { 
 + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , 
 + final Realm . Transaction . OnSuccess onSuccess , 
 + final Realm . Transaction . OnError onError ) { 
 checkIfValid ( ) ; 
 
 if ( transaction = = null ) { 
 throw new IllegalArgumentException ( " Transaction should not be null " ) ; 
 } 
 
 - / / If the user provided a Callback then we make sure , the current Realm has a Handler 
 - / / we can use to deliver the result 
 - / / FIXME : Implement checking here . 
 - / * 
 - if ( ( onSuccess ! = null | | onError ! = null ) & & ! hasValidNotifier ( ) ) { 
 - throw new IllegalStateException ( " Your Realm is opened from a thread without a Looper " + 
 - " and you provided a callback , we need a Handler to invoke your callback " ) ; 
 + / / Avoid to call canDeliverNotification ( ) in bg thread . 
 + final boolean canDeliverNotification = sharedRealm . capabilities . canDeliverNotification ( ) ; 
 + 
 + / / If the user provided a Callback then we have to make sure the current Realm has an events looper to deliver 
 + / / the results . 
 + if ( ( onSuccess ! = null | | onError ! = null ) & & ! canDeliverNotification ) { 
 + throw new IllegalStateException ( " Your Realm is opened from a thread without a event looper . " + 
 + " The callback cannot be invoked . " ) ; 
 } 
 - * / 
 
 / / We need to use the same configuration to open a background SharedRealm ( i . e Realm ) 
 / / to perform the transaction 
 final RealmConfiguration realmConfiguration = getConfiguration ( ) ; 
 + / / We need to deliver the callback even if the Realm is closed . So acquire a reference to the notifier here . 
 + final RealmNotifier realmNotifier = sharedRealm . realmNotifier ; 
 
 final Future < ? > pendingTransaction = asyncTaskExecutor . submitTransaction ( new Runnable ( ) { 
 @ Override 
 @ @ - 1343 , 97 + 1349 , 76 @ @ public final class Realm extends BaseRealm { 
 return ; 
 } 
 
 - boolean transactionCommitted = false ; 
 + final SharedRealm . VersionID [ ] versionID = new SharedRealm . VersionID [ 1 ] ; 
 final Throwable [ ] exception = new Throwable [ 1 ] ; 
 - / / FIXME : Disable notifier in SharedRealm 
 + 
 final Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 bgRealm . beginTransaction ( ) ; 
 try { 
 transaction . execute ( bgRealm ) ; 
 
 - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 - / / No need to send change notification to the work thread . 
 - bgRealm . commitTransaction ( ) ; 
 - / / The bgRealm needs to be closed before post event to caller ' s handler to avoid concurrency 
 - / / problem . This is currently guaranteed by posting handleAsyncTransactionCompleted below . 
 - bgRealm . close ( ) ; 
 - transactionCommitted = true ; 
 + if ( Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + return ; 
 } 
 + 
 + bgRealm . commitTransaction ( ) ; 
 + / / The bgRealm needs to be closed before post event to caller ' s handler to avoid concurrency 
 + / / problem . This is currently guaranteed by posting callbacks later below . 
 + versionID [ 0 ] = bgRealm . sharedRealm . getVersionID ( ) ; 
 } catch ( final Throwable e ) { 
 exception [ 0 ] = e ; 
 } finally { 
 - if ( ! bgRealm . isClosed ( ) ) { 
 - if ( bgRealm . isInTransaction ( ) ) { 
 - bgRealm . cancelTransaction ( ) ; 
 - } else if ( exception [ 0 ] ! = null ) { 
 - RealmLog . warn ( " Could not cancel transaction , not currently in a transaction . " ) ; 
 - } 
 - bgRealm . close ( ) ; 
 - } 
 + / / SharedGroup : : close ( ) will cancel the transaction if needed . 
 + bgRealm . close ( ) ; 
 + } 
 
 - / / This will be treated like a special REALM _ CHANGED event 
 - / / FIXME : Find a way to deliver the callback with current architecture 
 - / * 
 - final Throwable backgroundException = exception [ 0 ] ; 
 - / / Send response as the final step to ensure the bg thread quit before others get the response ! 
 - if ( hasValidNotifier ( ) & & ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 - 
 - if ( transactionCommitted ) { 
 - sharedRealm . realmNotifier . post ( new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - handlerController . handleAsyncTransactionCompleted ( onSuccess ! = null ? new Runnable ( ) { 
 + final Throwable backgroundException = exception [ 0 ] ; 
 + / / Cannot be interrupted anymore . 
 + if ( canDeliverNotification ) { 
 + if ( versionID [ 0 ] ! = null & & onSuccess ! = null ) { 
 + realmNotifier . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( isClosed ( ) ) { 
 + / / The caller Realm is closed . Just call the onSuccess . Since the new created Realm 
 + / / cannot be behind the background one . 
 + onSuccess . onSuccess ( ) ; 
 + return ; 
 + } 
 + 
 + if ( sharedRealm . getVersionID ( ) . compareTo ( versionID [ 0 ] ) < 0 ) { 
 + sharedRealm . realmNotifier . addTransactionCallback ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 onSuccess . onSuccess ( ) ; 
 } 
 - } : null ) ; 
 + } ) ; 
 + } else { 
 + onSuccess . onSuccess ( ) ; 
 } 
 - } ) ; 
 - } 
 - 
 - / / Send errors directly to the looper , so they don ' t get intercepted by the HandlerController . 
 - if ( backgroundException ! = null ) { 
 - if ( onError ! = null ) { 
 - sharedRealm . realmNotifier . post ( new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - onError . onError ( backgroundException ) ; 
 - } 
 - } ) ; 
 - } else { 
 - sharedRealm . realmNotifier . post ( new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - if ( backgroundException instanceof RuntimeException ) { 
 - throw ( RuntimeException ) backgroundException ; 
 - } else if ( backgroundException instanceof Exception ) { 
 - throw new RealmException ( " Async transaction failed " , backgroundException ) ; 
 - } else if ( backgroundException instanceof Error ) { 
 - throw ( Error ) backgroundException ; 
 - } 
 - } 
 - } ) ; 
 } 
 - } 
 - 
 - } else { 
 - / / Throw exception in the worker thread if the caller thread terminated 
 - if ( backgroundException ! = null ) { 
 - if ( backgroundException instanceof RuntimeException ) { 
 - / / noinspection ThrowFromFinallyBlock 
 - throw ( RuntimeException ) backgroundException ; 
 - } else if ( backgroundException instanceof Exception ) { 
 - / / noinspection ThrowFromFinallyBlock 
 - throw new RealmException ( " Async transaction failed " , backgroundException ) ; 
 - } else if ( backgroundException instanceof Error ) { 
 - / / noinspection ThrowFromFinallyBlock 
 - throw ( Error ) backgroundException ; 
 + } ) ; 
 + } else if ( backgroundException ! = null ) { 
 + realmNotifier . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( onError ! = null ) { 
 + onError . onError ( backgroundException ) ; 
 + } else { 
 + throw new RealmException ( " Async transaction failed " , backgroundException ) ; 
 + } 
 } 
 - } 
 + } ) ; 
 + } 
 + } else { 
 + if ( backgroundException ! = null ) { 
 + / / FIXME : ThreadPoolExecutor will never throw the exception in the background . We need a 
 + / / redesign of the async transaction API . 
 + / / Throw in the worker thread since the caller thread cannot get notifications . 
 + throw new RealmException ( " Async transaction failed " , backgroundException ) ; 
 } 
 - * / 
 } 
 + 
 } 
 } ) ; 
 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / RealmNotifier . java b / realm / realm - library / src / main / java / io / realm / internal / RealmNotifier . java 
 index 3243243 . . 826bfe8 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / RealmNotifier . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / RealmNotifier . java 
 @ @ - 53 , 6 + 53 , 13 @ @ public abstract class RealmNotifier implements Closeable { 
 } 
 } ; 
 
 + / / TODO : The only reason we have this is that async transactions is not supported by OS yet . And OS is using ALopper 
 + / / which will be using a different message queue from which java is using to deliver remote Realm changes message . 
 + / / We need a way to deliver the async transaction onSuccess callback to the caller thread after the caller Realm 
 + / / advanced . This is implemented by posting the callback by RealmNotifier . post ( ) first , and check the realm version 
 + / / in the posted Runnable . If the Realm version there is still behind the async transaction we committed , the 
 + / / onSuccess callback will be added to this list and be executed later when we get the change event from OS . 
 + / / This list is NOT supposed to be thread safe ! 
 private List < Runnable > transactionCallbacks = new ArrayList < Runnable > ( ) ; 
 
 / / This is called by OS when other thread / process changes the Realm . 
 @ @ - 117 , 5 + 124 , 10 @ @ public abstract class RealmNotifier implements Closeable { 
 
 public abstract void postAtFrontOfQueue ( Runnable runnable ) ; 
 
 + / * * 
 + * For current implementation of async transaction only . See comments for { @ link # transactionCallbacks } . 
 + * 
 + * @ param runnable to be executed in the following event loop . 
 + * / 
 public abstract void post ( Runnable runnable ) ; 
 }

NEAREST DIFF:
diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index 4e7ea04 . . 2c1889c 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 230 , 6 + 230 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 @ Override 
 public void onError ( Exception t ) { 
 threadAssertionError [ 0 ] = t ; 
 + signalCallbackFinished . countDown ( ) ; 
 } 
 
 @ Override 
 @ @ - 1371 , 6 + 1372 , 74 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } 
 
 + / / * * * Async write transaction * * * / / 
 + 
 + public void testAsyncWriteTransaction ( ) throws Throwable { 
 + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final Looper [ ] looper = new Looper [ 1 ] ; 
 + final Realm [ ] realm = new Realm [ 1 ] ; 
 + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + executorService . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + looper [ 0 ] = Looper . myLooper ( ) ; 
 + try { 
 + realm [ 0 ] = openRealmInstance ( " test _ async _ write _ transaction " ) ; 
 + realm [ 0 ] . executeTransaction ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + Owner owner = realm . createObject ( Owner . class ) ; 
 + owner . setName ( " Owner " ) ; 
 + } 
 + } , new Realm . Transaction . Callback ( ) { 
 + @ Override 
 + public void onSuccess ( ) { 
 + try { 
 + assertEquals ( 1 , realm [ 0 ] . allObjects ( Owner . class ) . size ( ) ) ; 
 + assertEquals ( " Owner " , realm [ 0 ] . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; 
 + } catch ( AssertionFailedError e ) { 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onError ( Throwable e ) { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } ) ; 
 + 
 + Looper . loop ( ) ; 
 + 
 + } catch ( Exception e ) { 
 + e . printStackTrace ( ) ; 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + if ( signalCallbackFinished . getCount ( ) > 0 ) { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + if ( realm . length > 0 & & realm [ 0 ] ! = null ) { 
 + realm [ 0 ] . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + / / wait until the callback of our async query proceed 
 + signalCallbackFinished . await ( ) ; 
 + looper [ 0 ] . quit ( ) ; 
 + executorService . shutdownNow ( ) ; 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + } 
 + 
 / / * * * Helper methods * * * 
 
 / / This could be done from # setUp but then we can ' t control 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index 63c510e . . c8c9c95 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 24 , 6 + 24 , 8 @ @ import android . os . Looper ; 
 import android . os . Message ; 
 import android . util . JsonReader ; 
 
 + import org . jetbrains . annotations . NotNull ; 
 + import org . jetbrains . annotations . Nullable ; 
 import org . json . JSONArray ; 
 import org . json . JSONException ; 
 import org . json . JSONObject ; 
 @ @ - 47 , 6 + 49 , 7 @ @ import java . util . concurrent . ConcurrentHashMap ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . ExecutorService ; 
 import java . util . concurrent . Executors ; 
 + import java . util . concurrent . Future ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 
 import io . realm . exceptions . RealmException ; 
 @ @ - 1507 , 7 + 1510 , 8 @ @ public final class Realm implements Closeable { 
 * / 
 public void executeTransaction ( Transaction transaction ) { 
 if ( transaction = = null ) 
 - return ; 
 + throw new IllegalArgumentException ( " transaction should not be null " ) ; 
 + 
 beginTransaction ( ) ; 
 try { 
 transaction . execute ( this ) ; 
 @ @ - 1522 , 6 + 1526 , 70 @ @ public final class Realm implements Closeable { 
 } 
 
 / * * 
 + * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously from a worker thread 
 + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . 
 + * @ param callback optional , to receive the result of this query 
 + * @ return A { @ link io . realm . RealmQuery . Request } representing a cancellable task 
 + * / 
 + public RealmQuery . Request executeTransaction ( final Transaction transaction , @ Nullable final Transaction . Callback callback ) { 
 + if ( transaction = = null ) 
 + throw new IllegalArgumentException ( " transaction should not be null " ) ; 
 + 
 + / / will use the Looper of the caller thread to post the result 
 + final Handler handler = new Handler ( ) ; 
 + 
 + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) 
 + / / to perform the transaction 
 + final RealmConfiguration realmConfiguration = getConfiguration ( ) ; 
 + 
 + final Future < ? > pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 + bgRealm . beginTransaction ( ) ; 
 + try { 
 + transaction . execute ( bgRealm ) ; 
 + bgRealm . commitTransaction ( ) ; 
 + if ( callback ! = null ) { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + callback . onSuccess ( ) ; 
 + } 
 + } ) ; 
 + } 
 + } catch ( final RuntimeException e ) { 
 + bgRealm . cancelTransaction ( ) ; 
 + if ( callback ! = null ) { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + callback . onError ( e ) ; 
 + } 
 + } ) ; 
 + } 
 + } catch ( final Error e ) { 
 + bgRealm . cancelTransaction ( ) ; 
 + if ( callback ! = null ) { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + callback . onError ( e ) ; 
 + } 
 + } ) ; 
 + } 
 + } finally { 
 + bgRealm . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + return new RealmQuery . Request ( pendingQuery ) ; 
 + } 
 + 
 + / * * 
 * Remove all objects of the specified class . 
 * 
 * @ param clazz The class which objects should be removed 
 @ @ - 1883 , 6 + 1951 , 11 @ @ public final class Realm implements Closeable { 
 * / 
 public interface Transaction { 
 void execute ( Realm realm ) ; 
 + 
 + class Callback { 
 + public void onSuccess ( ) { } 
 + public void onError ( Throwable e ) { } 
 + } 
 } 
 
 / * * 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index 0066c39 . . ebb719a 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1773 , 7 + 1773 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the 
 * query will post the result to the caller ' s thread callback ) 
 * / 
 - public class Request { 
 + public static class Request { 
 private Future < ? > pendingQuery ; 
 private volatile boolean isCancelled = false ; 

