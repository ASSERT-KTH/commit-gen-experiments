BLEU SCORE: 0.020980574531482755

TEST MSG: Using separate interfaces for async transaction also fixes # 2130
GENERATED MSG: Rewrite of the notifications system

TEST DIFF (one line): diff - - git a / examples / threadExample / src / main / java / io / realm / examples / threads / AsyncQueryFragment . java b / examples / threadExample / src / main / java / io / realm / examples / threads / AsyncQueryFragment . java <nl> index d864060 . . de41b08 100644 <nl> - - - a / examples / threadExample / src / main / java / io / realm / examples / threads / AsyncQueryFragment . java <nl> + + + b / examples / threadExample / src / main / java / io / realm / examples / threads / AsyncQueryFragment . java <nl> @ @ - 89 , 7 + 89 , 7 @ @ public class AsyncQueryFragment extends Fragment implements View . OnClickListener <nl> case R . id . translate _ button : { <nl> cancelAsyncTransaction ( ) ; <nl> / / translate all points coordinates using an async transaction <nl> - asyncTransaction = realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + asyncTransaction = realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> / / query for all points <nl> @ @ - 105 , 16 + 105 , 17 @ @ public class AsyncQueryFragment extends Fragment implements View . OnClickListener <nl> } <nl> } <nl> } <nl> - } , new Realm . Transaction . Callback ( ) { <nl> + } , new Realm . Transaction . OnSuccess ( ) { <nl> @ Override <nl> public void onSuccess ( ) { <nl> if ( isAdded ( ) ) { <nl> Toast . makeText ( getActivity ( ) , " Translation completed " , Toast . LENGTH _ SHORT ) . show ( ) ; <nl> } <nl> } <nl> + } , new Realm . Transaction . OnError ( ) { <nl> <nl> @ Override <nl> - public void onError ( Exception e ) { <nl> + public void onError ( Throwable e ) { <nl> if ( isAdded ( ) ) { <nl> Toast . makeText ( getActivity ( ) , " Error while translating dots " , Toast . LENGTH _ SHORT ) . show ( ) ; <nl> e . printStackTrace ( ) ; <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index e6cc8af . . 57481f9 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 18 , 7 + 18 , 6 @ @ package io . realm ; <nl> <nl> import android . content . Context ; <nl> import android . os . Handler ; <nl> - import android . os . HandlerThread ; <nl> import android . os . Looper ; <nl> import android . os . MessageQueue ; <nl> import android . os . SystemClock ; <nl> @ @ - 56 , 6 + 55 , 7 @ @ import io . realm . rule . RunTestInLooperThread ; <nl> import static org . junit . Assert . assertEquals ; <nl> import static org . junit . Assert . assertFalse ; <nl> import static org . junit . Assert . assertNotNull ; <nl> + import static org . junit . Assert . assertNull ; <nl> import static org . junit . Assert . assertTrue ; <nl> import static org . junit . Assert . fail ; <nl> <nl> @ @ - 78 , 34 + 78 , 96 @ @ public class RealmAsyncQueryTests { <nl> / / start asynchronously a transaction to insert one element <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void executeTransaction _ async ( ) throws Throwable { <nl> + public void executeTransactionAsync ( ) throws Throwable { <nl> assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> <nl> - looperThread . realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + looperThread . realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> Owner owner = realm . createObject ( Owner . class ) ; <nl> owner . setName ( " Owner " ) ; <nl> } <nl> - } , new Realm . Transaction . Callback ( ) { <nl> + } , new Realm . Transaction . OnSuccess ( ) { <nl> @ Override <nl> public void onSuccess ( ) { <nl> assertEquals ( 1 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> assertEquals ( " Owner " , looperThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; <nl> looperThread . testComplete ( ) ; <nl> } <nl> + } , new Realm . Transaction . OnError ( ) { <nl> <nl> @ Override <nl> - public void onError ( Exception e ) { <nl> - looperThread . testComplete ( ) ; ; <nl> - fail ( e . getMessage ( ) ) ; <nl> + public void onError ( Throwable error ) { <nl> + fail ( error . getMessage ( ) ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void executeTransactionAsync _ onSuccess ( ) throws Throwable { <nl> + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> + <nl> + looperThread . realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + Owner owner = realm . createObject ( Owner . class ) ; <nl> + owner . setName ( " Owner " ) ; <nl> + } <nl> + } , new Realm . Transaction . OnSuccess ( ) { <nl> + @ Override <nl> + public void onSuccess ( ) { <nl> + assertEquals ( 1 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> + assertEquals ( " Owner " , looperThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void executeTransactionAsync _ onError ( ) throws Throwable { <nl> + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> + <nl> + looperThread . realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + throw new RuntimeException ( " Oh ! What a Terrible Failure " ) ; <nl> + } <nl> + } , new Realm . Transaction . OnError ( ) { <nl> + @ Override <nl> + public void onError ( Throwable error ) { <nl> + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> + assertNull ( looperThread . realm . where ( Owner . class ) . findFirst ( ) ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void executeTransactionAsync _ NoCallbacks ( ) throws Throwable { <nl> + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> + <nl> + looperThread . realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + Owner owner = realm . createObject ( Owner . class ) ; <nl> + owner . setName ( " Owner " ) ; <nl> + } <nl> + } ) ; <nl> + looperThread . realm . addChangeListener ( new RealmChangeListener ( ) { <nl> + @ Override <nl> + public void onChange ( ) { <nl> + assertEquals ( " Owner " , looperThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> } ) ; <nl> } <nl> <nl> / / Test that an async transaction that throws an exception propagate it properly to the user . <nl> @ Test <nl> - public void executeTransaction _ async _ exceptionHandling ( ) throws Throwable { <nl> + public void executeTransactionAsync _ exceptionHandling ( ) throws Throwable { <nl> final TestHelper . TestLogger testLogger = new TestHelper . TestLogger ( ) ; <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> @ @ - 125 , 7 + 187 , 7 @ @ public class RealmAsyncQueryTests { <nl> <nl> assertEquals ( 0 , realm [ 0 ] . allObjects ( Owner . class ) . size ( ) ) ; <nl> <nl> - realm [ 0 ] . executeTransaction ( new Realm . Transaction ( ) { <nl> + realm [ 0 ] . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> Owner owner = realm . createObject ( Owner . class ) ; <nl> @ @ - 133 , 7 + 195 , 7 @ @ public class RealmAsyncQueryTests { <nl> realm . cancelTransaction ( ) ; / / Cancel the transaction then throw <nl> throw new RuntimeException ( " Boom " ) ; <nl> } <nl> - } , new Realm . Transaction . Callback ( ) { <nl> + } , new Realm . Transaction . OnSuccess ( ) { <nl> @ Override <nl> public void onSuccess ( ) { <nl> try { <nl> @ @ - 144 , 9 + 206 , 9 @ @ public class RealmAsyncQueryTests { <nl> signalCallbackFinished . countDown ( ) ; <nl> } <nl> } <nl> - <nl> + } , new Realm . Transaction . OnError ( ) { <nl> @ Override <nl> - public void onError ( Exception e ) { <nl> + public void onError ( Throwable error ) { <nl> try { <nl> / / Ensure we are giving developers quality messages in the logs . <nl> assertEquals ( testLogger . message , " Could not cancel transaction , not currently in a transaction . " ) ; <nl> @ @ - 182 , 9 + 244 , 9 @ @ public class RealmAsyncQueryTests { <nl> / / Test if the background Realm is closed when transaction success returned . <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void executeTransaction _ async _ realmClosedOnSuccess ( ) { <nl> + public void executeTransactionAsync _ realmClosedOnSuccess ( ) { <nl> final AtomicInteger counter = new AtomicInteger ( 100 ) ; <nl> - final Realm realm = Realm . getInstance ( looperThread . createConfiguration ( " testClosedBeforeAsyncTransactionSuccess " ) ) ; <nl> + final Realm realm = looperThread . realm ; <nl> final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { <nl> @ Override <nl> public void onResult ( int count ) { <nl> @ @ - 195 , 7 + 257 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> } <nl> } ; <nl> - final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { <nl> + final Realm . Transaction . OnSuccess transactionCallback = new Realm . Transaction . OnSuccess ( ) { <nl> @ Override <nl> public void onSuccess ( ) { <nl> RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; <nl> @ @ - 203 , 7 + 265 , 7 @ @ public class RealmAsyncQueryTests { <nl> / / Finish testing <nl> return ; <nl> } <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> } <nl> @ @ - 211 , 7 + 273 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> } ; <nl> <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> } <nl> @ @ - 223 , 7 + 285 , 7 @ @ public class RealmAsyncQueryTests { <nl> @ RunTestInLooperThread <nl> public void executeTransaction _ async _ realmClosedOnError ( ) { <nl> final AtomicInteger counter = new AtomicInteger ( 100 ) ; <nl> - final Realm realm = Realm . getInstance ( looperThread . createConfiguration ( " testClosedBeforeAsyncTransactionSuccess " ) ) ; <nl> + final Realm realm = looperThread . realm ; <nl> final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { <nl> @ Override <nl> public void onResult ( int count ) { <nl> @ @ - 234 , 15 + 296 , 15 @ @ public class RealmAsyncQueryTests { <nl> } <nl> } <nl> } ; <nl> - final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { <nl> + final Realm . Transaction . OnError transactionCallback = new Realm . Transaction . OnError ( ) { <nl> @ Override <nl> - public void onError ( Exception e ) { <nl> + public void onError ( Throwable error ) { <nl> RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; <nl> if ( counter . get ( ) = = 0 ) { <nl> / / Finish testing <nl> return ; <nl> } <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> throw new RuntimeException ( " Dummy exception " ) ; <nl> @ @ - 251 , 7 + 313 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> } ; <nl> <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> throw new RuntimeException ( " Dummy exception " ) ; <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java <nl> index 0f513bd . . 13440d3 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java <nl> @ @ - 2588 , 12 + 2588 , 12 @ @ public class RealmTests { <nl> <nl> realm . addChangeListener ( listener ) ; <nl> <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> realm . createObject ( AllTypes . class ) ; <nl> } <nl> - } , new Realm . Transaction . Callback ( ) ) ; <nl> + } ) ; <nl> } <nl> } ) ; <nl> TestHelper . awaitOrFail ( signalTestFinished ) ; <nl> @ @ - 2632 , 12 + 2632 , 12 @ @ public class RealmTests { <nl> final AllTypes allTypes = realm . where ( AllTypes . class ) . findFirstAsync ( ) ; <nl> allTypes . addChangeListener ( dummyListener ) ; <nl> <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> realm . createObject ( AllTypes . class ) ; <nl> } <nl> - } , new Realm . Transaction . Callback ( ) ) ; <nl> + } ) ; <nl> } <nl> <nl> / / Test if close can be called from Realm change listener when there is an listener on non - empty Realm Object <nl> @ @ - 2677 , 12 + 2677 , 12 @ @ public class RealmTests { <nl> / / Step 1 : Change listener on Realm Object <nl> final AllTypes allTypes = realm . where ( AllTypes . class ) . findFirst ( ) ; <nl> allTypes . addChangeListener ( dummyListener ) ; <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> realm . createObject ( AllTypes . class ) ; <nl> } <nl> - } , new Realm . Transaction . Callback ( ) ) ; <nl> + } ) ; <nl> } <nl> <nl> / / Test if close can be called from Realm change listener when there is an listener on RealmResults <nl> @ @ - 2717 , 12 + 2717 , 12 @ @ public class RealmTests { <nl> RealmResults < AllTypes > results = realm . where ( AllTypes . class ) . findAll ( ) ; <nl> results . addChangeListener ( dummyListener ) ; <nl> <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> realm . createObject ( AllTypes . class ) ; <nl> } <nl> - } , new Realm . Transaction . Callback ( ) ) ; <nl> + } ) ; <nl> } <nl> <nl> @ Test <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> index 69ce18d . . 57d2cb9 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / Realm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> @ @ - 19 , 7 + 19 , 6 @ @ package io . realm ; <nl> import android . annotation . TargetApi ; <nl> import android . content . Context ; <nl> import android . os . Build ; <nl> - import android . os . Handler ; <nl> import android . os . Looper ; <nl> import android . util . JsonReader ; <nl> <nl> @ @ - 1067 , 16 + 1066 , 20 @ @ public final class Realm extends BaseRealm { <nl> } <nl> <nl> / * * <nl> - * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously from a worker thread . <nl> + * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously on a worker thread . <nl> * <nl> * @ param transaction { @ link io . realm . Realm . Transaction } to execute . <nl> * @ param callback optional , to receive the result of this query . <nl> * @ return a { @ link RealmAsyncTask } representing a cancellable task . <nl> * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . <nl> + * @ deprecated replaced by { @ link # executeTransactionAsync ( Transaction ) } , { @ link # executeTransactionAsync ( Transaction , Transaction . OnSuccess ) } , { @ link # executeTransactionAsync ( Transaction , io . realm . Realm . Transaction . OnError ) } and { @ link # executeTransactionAsync ( Transaction , Transaction . OnSuccess , Transaction . OnError ) } . <nl> * / <nl> + @ Deprecated <nl> public RealmAsyncTask executeTransaction ( final Transaction transaction , final Transaction . Callback callback ) { <nl> - if ( transaction = = null ) <nl> + checkIfValid ( ) ; <nl> + if ( transaction = = null ) { <nl> throw new IllegalArgumentException ( " Transaction should not be null " ) ; <nl> + } <nl> <nl> / / If the user provided a Callback then we make sure , the current Realm has a Handler <nl> / / we can use to deliver the result <nl> @ @ - 1157 , 6 + 1160 , 174 @ @ public final class Realm extends BaseRealm { <nl> } <nl> <nl> / * * <nl> + * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously on a worker thread . <nl> + * <nl> + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . <nl> + * @ return a { @ link RealmAsyncTask } representing a cancellable task . <nl> + * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . <nl> + * / <nl> + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction ) { <nl> + return executeTransactionAsync ( transaction , null , null ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Similar to { @ link # executeTransactionAsync ( Transaction ) } , but also accepts an OnSuccess callback . <nl> + * <nl> + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . <nl> + * @ param onSuccess callback invoked when the transaction succeeds . <nl> + * @ return a { @ link RealmAsyncTask } representing a cancellable task . <nl> + * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . <nl> + * / <nl> + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , final Realm . Transaction . OnSuccess onSuccess ) { <nl> + if ( onSuccess = = null ) { <nl> + throw new IllegalArgumentException ( " onSuccess callback can ' t be null " ) ; <nl> + } <nl> + <nl> + return executeTransactionAsync ( transaction , onSuccess , null ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Similar to { @ link # executeTransactionAsync ( Transaction ) } , but also accepts an OnError callback . <nl> + * <nl> + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . <nl> + * @ param onError callback invoked when the transaction failed . <nl> + * @ return a { @ link RealmAsyncTask } representing a cancellable task . <nl> + * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . <nl> + * / <nl> + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , final Realm . Transaction . OnError onError ) { <nl> + if ( onError = = null ) { <nl> + throw new IllegalArgumentException ( " onError callback can ' t be null " ) ; <nl> + } <nl> + <nl> + return executeTransactionAsync ( transaction , null , onError ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Similar to { @ link # executeTransactionAsync ( Transaction ) } , but also accepts an OnSuccess and OnError callbacks . <nl> + * <nl> + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . <nl> + * @ param onSuccess callback invoked when the transaction succeeds . <nl> + * @ param onError callback invoked when the transaction failed . <nl> + * @ return a { @ link RealmAsyncTask } representing a cancellable task . <nl> + * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . <nl> + * / <nl> + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , final Realm . Transaction . OnSuccess onSuccess , final Realm . Transaction . OnError onError ) { <nl> + checkIfValid ( ) ; <nl> + <nl> + if ( transaction = = null ) { <nl> + throw new IllegalArgumentException ( " Transaction should not be null " ) ; <nl> + } <nl> + <nl> + / / If the user provided a Callback then we make sure , the current Realm has a Handler <nl> + / / we can use to deliver the result <nl> + if ( ( onSuccess ! = null | | onError ! = null ) & & handler = = null ) { <nl> + throw new IllegalStateException ( " Your Realm is opened from a thread without a Looper " + <nl> + " and you provided a callback , we need a Handler to invoke your callback " ) ; <nl> + } <nl> + <nl> + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) <nl> + / / to perform the transaction <nl> + final RealmConfiguration realmConfiguration = getConfiguration ( ) ; <nl> + <nl> + final Future < ? > pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + return ; <nl> + } <nl> + <nl> + boolean transactionCommitted = false ; <nl> + final Throwable [ ] exception = new Throwable [ 1 ] ; <nl> + final Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> + bgRealm . beginTransaction ( ) ; <nl> + try { <nl> + transaction . execute ( bgRealm ) ; <nl> + <nl> + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + bgRealm . commitTransaction ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + / / The bgRealm needs to be closed before post event to caller ' s handler to avoid <nl> + / / concurrency problem . eg . : User wants to delete Realm in the callbacks . <nl> + / / This will close Realm before sending REALM _ CHANGED . <nl> + bgRealm . close ( ) ; <nl> + } <nl> + } ) ; <nl> + transactionCommitted = true ; <nl> + } <nl> + } catch ( final Throwable e ) { <nl> + exception [ 0 ] = e ; <nl> + } finally { <nl> + if ( ! bgRealm . isClosed ( ) ) { <nl> + if ( bgRealm . isInTransaction ( ) ) { <nl> + bgRealm . cancelTransaction ( ) ; <nl> + } else if ( exception [ 0 ] ! = null ) { <nl> + RealmLog . w ( " Could not cancel transaction , not currently in a transaction . " ) ; <nl> + } <nl> + bgRealm . close ( ) ; <nl> + } <nl> + <nl> + final Throwable backgroundException = exception [ 0 ] ; <nl> + / / Send response as the final step to ensure the bg thread quit before others get the response ! <nl> + if ( handler ! = null <nl> + & & ! Thread . currentThread ( ) . isInterrupted ( ) <nl> + & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) ) { <nl> + if ( onSuccess ! = null & & transactionCommitted ) { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + onSuccess . onSuccess ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + if ( backgroundException ! = null ) { <nl> + if ( onError ! = null ) { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + onError . onError ( backgroundException ) ; <nl> + } <nl> + } ) ; <nl> + } else { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( backgroundException instanceof RuntimeException ) { <nl> + throw ( RuntimeException ) backgroundException ; <nl> + } else if ( backgroundException instanceof Exception ) { <nl> + throw new RealmException ( " Async transaction failed " , backgroundException ) ; <nl> + } else if ( backgroundException instanceof Error ) { <nl> + throw ( Error ) backgroundException ; <nl> + } <nl> + } <nl> + } ) ; <nl> + } <nl> + } <nl> + } else { <nl> + / / Throw exception in the worker thread if the caller thread terminated <nl> + if ( backgroundException ! = null ) { <nl> + if ( backgroundException instanceof RuntimeException ) { <nl> + / / noinspection ThrowFromFinallyBlock <nl> + throw ( RuntimeException ) backgroundException ; <nl> + } else if ( backgroundException instanceof Exception ) { <nl> + / / noinspection ThrowFromFinallyBlock <nl> + throw new RealmException ( " Async transaction failed " , backgroundException ) ; <nl> + } else if ( backgroundException instanceof Error ) { <nl> + / / noinspection ThrowFromFinallyBlock <nl> + throw ( Error ) backgroundException ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + return new RealmAsyncTask ( pendingQuery ) ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> * Removes all objects of the specified class . <nl> * <nl> * @ param clazz the class which objects should be removed . <nl> @ @ - 1326 , 5 + 1497 , 21 @ @ public final class Realm extends BaseRealm { <nl> public void onSuccess ( ) { } <nl> public void onError ( Exception e ) { } <nl> } <nl> + <nl> + / * * <nl> + * Callback invoked to notify the caller thread about the success of the transaction . <nl> + * / <nl> + interface OnSuccess { <nl> + void onSuccess ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Callback invoked to notify the caller thread about error during the transaction . <nl> + * The transaction will be rolled back and the background Realm will be closed before <nl> + * invoking { @ link # onError ( Throwable ) } . <nl> + * / <nl> + interface OnError { <nl> + void onError ( Throwable error ) ; <nl> + } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / RealmExampleActivity . java b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / RealmExampleActivity . java <nl> index 224eaa0 . . 06510a0 100644 <nl> - - - a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / RealmExampleActivity . java <nl> + + + b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / RealmExampleActivity . java <nl> @ @ - 37 , 7 + 37 , 7 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> public static final String TAG = RealmExampleActivity . class . getName ( ) ; <nl> <nl> - private Realm realm = null ; <nl> + private Realm realm ; <nl> <nl> @ Override <nl> protected void onCreate ( Bundle savedInstanceState ) { <nl> @ @ - 63 , 7 + 63 , 7 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen <nl> public void onResume ( ) { <nl> super . onResume ( ) ; <nl> <nl> - 	 / / Alternatively can use transaction tests here . . . <nl> + / / Alternatively can use transaction tests here . . . <nl> / / startTransactionTests ( ) ; <nl> <nl> startSpawnTests ( ) ; <nl> @ @ - 73 , 7 + 73 , 7 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen <nl> public void onStop ( ) { <nl> super . onStop ( ) ; <nl> <nl> - 	 / / Alternatively can use transaction tests here . . . <nl> + / / Alternatively can use transaction tests here . . . <nl> / / stopTransactionTests ( ) ; <nl> <nl> stopSpawnTests ( ) ; <nl> @ @ - 87 , 12 + 87 , 12 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen <nl> String personAge = ( ( TextView ) findViewById ( R . id . age ) ) . getText ( ) . toString ( ) ; <nl> String petName = ( ( TextView ) findViewById ( R . id . pets _ name ) ) . getText ( ) . toString ( ) ; <nl> <nl> - Integer parseAge = 0 ; <nl> + Integer parseAge ; <nl> try { <nl> parseAge = Integer . parseInt ( personAge ) ; <nl> } catch ( NumberFormatException ignored ) { <nl> - 	 Log . d ( TAG , " Age for a person invalid " ) ; <nl> - 	 return ; <nl> + Log . d ( TAG , " Age for a person invalid " ) ; <nl> + return ; <nl> } <nl> <nl> realm . beginTransaction ( ) ; <nl> @ @ - 135 , 8 + 135 , 8 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen <nl> / / which loop for a specified count <nl> private void startSpawnTests ( ) { <nl> Intent serviceIntent = new Intent ( this , SpawningService . class ) ; <nl> - serviceIntent . putExtra ( SpawningService . REALM _ INSERTCOUNT _ EXTRA , 10000000 ) ; <nl> - serviceIntent . putExtra ( SpawningService . REALM _ READCOUNT _ EXTRA , 10000000 ) ; <nl> + serviceIntent . putExtra ( SpawningService . REALM _ INSERT _ COUNT _ EXTRA , 10000000 ) ; <nl> + serviceIntent . putExtra ( SpawningService . REALM _ READ _ COUNT _ EXTRA , 10000000 ) ; <nl> this . startService ( serviceIntent ) ; <nl> } <nl> <nl> diff - - git a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / services / SpawningService . java b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / services / SpawningService . java <nl> index 8d502ce . . 7acadcf 100644 <nl> - - - a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / services / SpawningService . java <nl> + + + b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / services / SpawningService . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . examples . concurrency . services ; <nl> import android . app . Service ; <nl> import android . content . Intent ; <nl> import android . os . IBinder ; <nl> + import android . util . Log ; <nl> <nl> import java . util . ArrayList ; <nl> import java . util . List ; <nl> @ @ - 30 , 39 + 31 , 38 @ @ import io . realm . examples . concurrency . threads . RealmWriter ; <nl> public class SpawningService extends Service { <nl> <nl> public static final String TAG = SpawningService . class . getName ( ) ; <nl> + public static final String REALM _ INSERT _ COUNT _ EXTRA = " RealmInsertCountExtra " ; <nl> + public static final String REALM _ READ _ COUNT _ EXTRA = " RealmReadCountExtra " ; <nl> <nl> - public static final String REALM _ INSERTCOUNT _ EXTRA = " RealmInsertCountExtra " ; <nl> - public static final String REALM _ READCOUNT _ EXTRA = " RealmReadCountExtra " ; <nl> - <nl> - private List < KillableThread > allThreads = null ; <nl> - <nl> - public void onCreate ( ) { <nl> - super . onCreate ( ) ; <nl> - } <nl> + private List < KillableThread > allThreads = new ArrayList < KillableThread > ( ) ; <nl> <nl> @ Override <nl> public int onStartCommand ( Intent intent , int flags , int startId ) { <nl> + if ( intent = = null ) { <nl> + Log . i ( TAG , " The intent is null " ) ; <nl> + throw new AssertionError ( ) ; <nl> + } <nl> <nl> - int insertCount = intent . getIntExtra ( REALM _ INSERTCOUNT _ EXTRA , 0 ) ; <nl> - int readCount = intent . getIntExtra ( REALM _ READCOUNT _ EXTRA , 0 ) ; <nl> + int insertCount = intent . getIntExtra ( REALM _ INSERT _ COUNT _ EXTRA , 0 ) ; <nl> + int readCount = intent . getIntExtra ( REALM _ READ _ COUNT _ EXTRA , 0 ) ; <nl> <nl> try { <nl> - allThreads = new ArrayList < KillableThread > ( ) ; <nl> - RealmWriter wT = new RealmWriter ( this ) ; <nl> - wT . setInsertCount ( insertCount ) ; <nl> - allThreads . add ( wT ) ; <nl> - wT . start ( ) ; <nl> - RealmReader rT = new RealmReader ( this ) ; <nl> - rT . setReadCount ( readCount ) ; <nl> - allThreads . add ( rT ) ; <nl> - rT . start ( ) ; <nl> + RealmWriter writerThread = new RealmWriter ( this ) ; <nl> + writerThread . setInsertCount ( insertCount ) ; <nl> + allThreads . add ( writerThread ) ; <nl> + writerThread . start ( ) ; <nl> + <nl> + RealmReader readerThread = new RealmReader ( this ) ; <nl> + readerThread . setReadCount ( readCount ) ; <nl> + allThreads . add ( readerThread ) ; <nl> + readerThread . start ( ) ; <nl> } catch ( Exception e ) { <nl> e . printStackTrace ( ) ; <nl> quit ( ) ; <nl> } <nl> <nl> / / Service should stay active as long as Activity is active <nl> - return START _ STICKY ; <nl> + return START _ STICKY _ COMPATIBILITY ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmReader . java b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmReader . java <nl> index 9f7e738 . . 496d1f4 100644 <nl> - - - a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmReader . java <nl> + + + b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmReader . java <nl> @ @ - 17 , 19 + 17 , 18 @ @ <nl> package io . realm . examples . concurrency . threads ; <nl> <nl> import android . content . Context ; <nl> + import android . os . Looper ; <nl> import android . util . Log ; <nl> <nl> import io . realm . Realm ; <nl> + import io . realm . RealmChangeListener ; <nl> import io . realm . examples . concurrency . model . Person ; <nl> <nl> public class RealmReader extends Thread implements KillableThread { <nl> <nl> public static final String TAG = RealmReader . class . getName ( ) ; <nl> <nl> - private Context context = null ; <nl> - <nl> - private boolean mRunning = true ; <nl> - <nl> + private Context context ; <nl> private int mReadCount = 0 ; <nl> <nl> public RealmReader ( Context context ) { <nl> @ @ - 37 , 25 + 36 , 26 @ @ public class RealmReader extends Thread implements KillableThread { <nl> } <nl> <nl> public void run ( ) { <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Looper . prepare ( ) ; <nl> + final Realm realm = Realm . getInstance ( context , true ) ; <nl> <nl> - int loopCount = 0 ; <nl> + realm . addChangeListener ( new RealmChangeListener ( ) { <nl> <nl> - while ( loopCount < mReadCount & & mRunning ) { <nl> - Person person = realm . where ( Person . class ) <nl> - . beginsWith ( " name " , " Foo " ) <nl> - . between ( " age " , 20 , 50 ) . findFirst ( ) ; <nl> + @ Override <nl> + public void onChange ( ) { <nl> + long peopleNumber = realm . where ( Person . class ) . count ( ) ; <nl> + if ( peopleNumber % 10 = = 0 ) { <nl> + Log . d ( TAG , " Found count " + peopleNumber ) ; <nl> + } <nl> <nl> - if ( loopCount % 1000 = = 0 ) { <nl> - Log . d ( TAG , " Found : " + person ) ; <nl> } <nl> - loopCount + + ; <nl> - } <nl> + } ) ; <nl> + Looper . loop ( ) ; <nl> } <nl> <nl> @ Override <nl> public void terminate ( ) { <nl> - mRunning = false ; <nl> + Looper . myLooper ( ) . quit ( ) ; <nl> } <nl> <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> diff - - git a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmWriter . java b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmWriter . java <nl> index 53d7113 . . b400b70 100644 <nl> - - - a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmWriter . java <nl> + + + b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmWriter . java <nl> @ @ - 27 , 10 + 27 , 8 @ @ public class RealmWriter extends Thread implements KillableThread { <nl> <nl> public static final String TAG = RealmWriter . class . getName ( ) ; <nl> <nl> - private Context context = null ; <nl> - <nl> + private Context context ; <nl> private boolean mRunning = true ; <nl> - <nl> private int mInsertCount = 0 ; <nl> <nl> public RealmWriter ( Context context ) { <nl> @ @ - 40 , 27 + 38 , 27 @ @ public class RealmWriter extends Thread implements KillableThread { <nl> public void run ( ) { <nl> Realm realm = Realm . getInstance ( context ) ; <nl> <nl> - int iterCount = 0 ; <nl> + int count = 0 ; <nl> <nl> - while ( iterCount < mInsertCount & & mRunning ) { <nl> + while ( count < mInsertCount & & mRunning ) { <nl> realm . beginTransaction ( ) ; <nl> <nl> Person person = realm . createObject ( Person . class ) ; <nl> - person . setName ( " Foo " + iterCount ) ; <nl> - person . setAge ( iterCount % 20 + ( 50 - 20 ) ) ; <nl> + person . setName ( " Foo " + count ) ; <nl> + person . setAge ( count % 20 + ( 50 - 20 ) ) ; <nl> <nl> / / Add a dog to every 50th person <nl> - if ( iterCount % 50 = = 0 ) { <nl> + if ( count % 50 = = 0 ) { <nl> Dog dog = realm . createObject ( Dog . class ) ; <nl> - dog . setName ( " Foo " + iterCount + " Fido " ) ; <nl> + dog . setName ( " Foo " + count + " Fido " ) ; <nl> person . setDog ( dog ) ; <nl> } <nl> <nl> - iterCount + + ; <nl> + count + + ; <nl> realm . commitTransaction ( ) ; <nl> <nl> - if ( ( iterCount % 1000 ) = = 0 ) { <nl> - Log . d ( TAG , " WriteOperation # : " + iterCount + " , " + Thread . currentThread ( ) . getName ( ) ) ; <nl> + if ( ( count % 1000 ) = = 0 ) { <nl> + Log . d ( TAG , " WriteOperation # : " + count + " , " + Thread . currentThread ( ) . getName ( ) ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / realm / src / androidTest / java / io / realm / NotificationsTest . java b / realm / src / androidTest / java / io / realm / NotificationsTest . java <nl> index 6436da1 . . 2c8a98d 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / NotificationsTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / NotificationsTest . java <nl> @ @ - 15 , 56 + 15 , 144 @ @ <nl> * / <nl> package io . realm ; <nl> <nl> + import android . os . Handler ; <nl> + import android . os . Looper ; <nl> import android . test . AndroidTestCase ; <nl> - import android . util . Log ; <nl> + <nl> + import java . util . Queue ; <nl> + import java . util . concurrent . ConcurrentLinkedQueue ; <nl> + import java . util . concurrent . atomic . AtomicBoolean ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> <nl> import io . realm . entities . Dog ; <nl> - import io . realm . internal . android . LooperThread ; <nl> <nl> public class NotificationsTest extends AndroidTestCase { <nl> - public void testMessageToDeadThread ( ) { <nl> - Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> - <nl> - / / Number of handlers before <nl> - final int handlersBefore = LooperThread . handlers . size ( ) ; <nl> + public void testFailureOnNonLooperThread ( ) { <nl> + Thread thread = new Thread ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + try { <nl> + Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> + fail ( " The Realm instantiations should have thrown an exception " ) ; <nl> + } catch ( IllegalStateException ignored ) { } <nl> + } <nl> + } ; <nl> + thread . start ( ) ; <nl> + try { <nl> + thread . join ( ) ; <nl> + } catch ( InterruptedException e ) { <nl> + fail ( ) ; <nl> + } <nl> + } <nl> <nl> - / / Make sure the Looper Thread is alive <nl> - LooperThread looperThread = LooperThread . getInstance ( ) ; <nl> - assertTrue ( looperThread . isAlive ( ) ) ; <nl> + public void testNotifications ( ) { <nl> + final AtomicBoolean changed = new AtomicBoolean ( false ) ; <nl> <nl> - Thread thread = new Thread ( ) { <nl> + Thread listenerThread = new Thread ( ) { <nl> @ Override <nl> public void run ( ) { <nl> - Realm r = Realm . getInstance ( getContext ( ) ) ; <nl> - assertFalse ( handlersBefore = = LooperThread . handlers . size ( ) ) ; <nl> - r . addChangeListener ( new RealmChangeListener ( ) { <nl> + Looper . prepare ( ) ; <nl> + Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> + realm . addChangeListener ( new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> - Log . i ( " Notification Test " , " Notification Received " ) ; <nl> + changed . set ( true ) ; <nl> + Looper . myLooper ( ) . quit ( ) ; <nl> } <nl> } ) ; <nl> + Looper . loop ( ) ; <nl> } <nl> } ; <nl> - thread . start ( ) ; <nl> + listenerThread . start ( ) ; <nl> + <nl> + Thread writerThread = new Thread ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Realm realm = Realm . getInstance ( getContext ( ) , false ) ; <nl> + realm . beginTransaction ( ) ; <nl> + Dog dog = realm . createObject ( Dog . class ) ; <nl> + dog . setName ( " Rex " ) ; <nl> + realm . commitTransaction ( ) ; <nl> + } <nl> + } ; <nl> + writerThread . start ( ) ; <nl> <nl> try { <nl> - thread . join ( ) ; <nl> + writerThread . join ( ) ; <nl> + listenerThread . join ( 2000 ) ; <nl> } catch ( InterruptedException e ) { <nl> fail ( ) ; <nl> } <nl> - assertFalse ( thread . isAlive ( ) ) ; / / Make sure the thread is dead <nl> - realm . beginTransaction ( ) ; <nl> - Dog dog = realm . createObject ( Dog . class ) ; <nl> - dog . setName ( " Rex " ) ; <nl> - realm . commitTransaction ( ) ; <nl> <nl> - / / Give some time to log the exception <nl> + assertEquals ( true , changed . get ( ) ) ; <nl> + } <nl> + <nl> + public void testNotificationsTwoLoopers ( ) { <nl> + final AtomicInteger counter = new AtomicInteger ( 0 ) ; <nl> + final Queue < Handler > handlers = new ConcurrentLinkedQueue < Handler > ( ) ; <nl> + <nl> + Thread listenerThread = new Thread ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> + realm . addChangeListener ( new RealmChangeListener ( ) { <nl> + @ Override <nl> + public void onChange ( ) { <nl> + counter . incrementAndGet ( ) ; <nl> + Looper . myLooper ( ) . quit ( ) ; <nl> + } <nl> + } ) ; <nl> + Looper . loop ( ) ; <nl> + } <nl> + } ; <nl> + listenerThread . start ( ) ; <nl> + <nl> + Thread writerThread = new Thread ( ) { <nl> + <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> + realm . addChangeListener ( new RealmChangeListener ( ) { <nl> + @ Override <nl> + public void onChange ( ) { <nl> + counter . incrementAndGet ( ) ; <nl> + } <nl> + } ) ; <nl> + Handler handler = new Handler ( ) ; <nl> + handlers . add ( handler ) ; <nl> + Looper . loop ( ) ; <nl> + } <nl> + } ; <nl> + writerThread . start ( ) ; <nl> + while ( handlers . isEmpty ( ) ) { <nl> + try { <nl> + Thread . sleep ( 10 ) ; <nl> + } catch ( InterruptedException e ) { <nl> + fail ( ) ; <nl> + } <nl> + } <nl> + Handler handler = handlers . poll ( ) ; <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> + realm . beginTransaction ( ) ; <nl> + Dog dog = realm . createObject ( Dog . class ) ; <nl> + dog . setName ( " Rex " ) ; <nl> + realm . commitTransaction ( ) ; <nl> + Looper . myLooper ( ) . quit ( ) ; <nl> + } <nl> + } ) ; <nl> + <nl> try { <nl> - Thread . sleep ( 500 ) ; <nl> + writerThread . join ( ) ; <nl> + listenerThread . join ( 2000 ) ; <nl> } catch ( InterruptedException e ) { <nl> fail ( ) ; <nl> } <nl> <nl> - assertEquals ( 0 , looperThread . exceptions . size ( ) ) ; <nl> + assertEquals ( 2 , counter . get ( ) ) ; <nl> } <nl> } <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> index 1762f78 . . 37cac50 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> @ @ - 40 , 11 + 40 , 13 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> <nl> @ Override <nl> protected void setUp ( ) throws InterruptedException { <nl> - Realm . deleteRealmFile ( getContext ( ) ) ; <nl> + boolean result = Realm . deleteRealmFile ( getContext ( ) ) ; <nl> + if ( ! result ) { <nl> + fail ( ) ; <nl> + } <nl> testRealm = Realm . getInstance ( getContext ( ) ) ; <nl> <nl> testRealm . beginTransaction ( ) ; <nl> - <nl> testRealm . allObjects ( AllTypes . class ) . clear ( ) ; <nl> <nl> for ( int i = 0 ; i < TEST _ DATA _ SIZE ; + + i ) { <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index 2b5dbf0 . . 380cb62 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import java . util . Arrays ; <nl> import java . util . HashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> <nl> import io . realm . exceptions . RealmException ; <nl> import io . realm . exceptions . RealmIOException ; <nl> @ @ - 40 , 7 + 41 , 6 @ @ import io . realm . internal . ImplicitTransaction ; <nl> import io . realm . internal . Row ; <nl> import io . realm . internal . SharedGroup ; <nl> import io . realm . internal . Table ; <nl> - import io . realm . internal . android . LooperThread ; <nl> <nl> <nl> / * * <nl> @ @ - 65 , 13 + 65 , 15 @ @ public class Realm { <nl> return new HashMap < String , Realm > ( ) ; <nl> } <nl> } ; <nl> + private static final int REALM _ CHANGED = 14930352 ; / / Just a nice big Fibonacci number . For no reason : ) <nl> + private static final Map < Handler , Integer > handlers = new ConcurrentHashMap < Handler , Integer > ( ) ; <nl> <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> private static SharedGroup . Durability defaultDurability = SharedGroup . Durability . FULL ; <nl> - private static boolean autoRefresh = true ; <nl> + private boolean autoRefresh ; <nl> + private Handler handler ; <nl> <nl> private final int id ; <nl> - private final LooperThread looperThread = LooperThread . getInstance ( ) ; <nl> private final SharedGroup sharedGroup ; <nl> private final ImplicitTransaction transaction ; <nl> private final Map < Class < ? > , String > simpleClassNames = new HashMap < Class < ? > , String > ( ) ; <nl> @ @ - 83 , 38 + 85 , 15 @ @ public class Realm { <nl> private final Map < Class < ? > , Table > tables = new HashMap < Class < ? > , Table > ( ) ; <nl> private static final long UNVERSIONED = - 1 ; <nl> <nl> - private Handler handler ; <nl> - <nl> / / Package protected to be reachable by proxy classes <nl> static final Map < String , Map < String , Long > > columnIndices = new HashMap < String , Map < String , Long > > ( ) ; <nl> <nl> / / The constructor in private to enforce the use of the static one <nl> - private Realm ( String absolutePath , byte [ ] key ) { <nl> + private Realm ( String absolutePath , byte [ ] key , boolean autoRefresh ) { <nl> this . sharedGroup = new SharedGroup ( absolutePath , true , key ) ; <nl> this . transaction = sharedGroup . beginImplicitTransaction ( ) ; <nl> this . id = absolutePath . hashCode ( ) ; <nl> - if ( ! looperThread . isAlive ( ) ) { <nl> - looperThread . start ( ) ; <nl> - } <nl> - <nl> - if ( Looper . myLooper ( ) = = null ) { <nl> - Looper . prepare ( ) ; <nl> - } <nl> - handler = new Handler ( ) { <nl> - @ Override <nl> - public void handleMessage ( Message message ) { <nl> - if ( message . what = = LooperThread . REALM _ CHANGED ) { <nl> - if ( autoRefresh ) { <nl> - transaction . advanceRead ( ) ; <nl> - } <nl> - sendNotifications ( ) ; <nl> - } <nl> - } <nl> - } ; <nl> - if ( Looper . myLooper ( ) = = null ) { <nl> - Looper . loop ( ) ; <nl> - } <nl> - LooperThread . handlers . put ( handler , id ) ; <nl> + setAutoRefresh ( autoRefresh ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 123 , 10 + 102 , 42 @ @ public class Realm { <nl> super . finalize ( ) ; <nl> } <nl> <nl> - / / public static void setDefaultDurability ( SharedGroup . Durability durability ) { <nl> + private class RealmCallback implements Handler . Callback { <nl> + @ Override <nl> + public boolean handleMessage ( Message message ) { <nl> + if ( message . what = = REALM _ CHANGED ) { <nl> + transaction . advanceRead ( ) ; <nl> + sendNotifications ( ) ; <nl> + } <nl> + return true ; <nl> + } <nl> + } <nl> + <nl> + @ SuppressWarnings ( " UnusedDeclaration " ) <nl> + public boolean isAutoRefresh ( ) { <nl> + return autoRefresh ; <nl> + } <nl> + <nl> + public void setAutoRefresh ( boolean autoRefresh ) { <nl> + if ( autoRefresh & & Looper . myLooper ( ) = = null ) { <nl> + throw new IllegalStateException ( " Cannot set auto - refresh in a Thread without a Looper " ) ; <nl> + } <nl> + <nl> + if ( autoRefresh & & ! this . autoRefresh ) { / / Switch it on <nl> + handler = new Handler ( new RealmCallback ( ) ) ; <nl> + handlers . put ( handler , id ) ; <nl> + } else if ( ! autoRefresh & & this . autoRefresh & & handler ! = null ) { / / Switch it off <nl> + handler . removeCallbacksAndMessages ( null ) ; <nl> + handlers . remove ( handler ) ; <nl> + } <nl> + this . autoRefresh = autoRefresh ; <nl> + } <nl> + <nl> + / / public static void setDefaultDurability ( SharedGroup . Durability durability ) { <nl> / / defaultDurability = durability ; <nl> / / } <nl> <nl> + / / Public because of migrations <nl> public Table getTable ( Class < ? > clazz ) { <nl> String simpleClassName = simpleClassNames . get ( clazz ) ; <nl> if ( simpleClassName = = null ) { <nl> @ @ - 147 , 7 + 158 , 24 @ @ public class Realm { <nl> * @ throws RealmException Other errors <nl> * / <nl> public static Realm getInstance ( Context context ) { <nl> - return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , null ) ; <nl> + return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , null , true ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Realm static constructor for the default realm " default . realm " <nl> + * <nl> + * @ param context an Android context <nl> + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) <nl> + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) <nl> + * @ return an instance of the Realm class <nl> + * @ throws RealmMigrationNeededException The model classes have been changed and the Realm <nl> + * must be migrated <nl> + * @ throws RealmIOException Error when accessing underlying file <nl> + * @ throws RealmException Other errors <nl> + * / <nl> + @ SuppressWarnings ( " UnusedDeclaration " ) <nl> + public static Realm getInstance ( Context context , boolean autoRefresh ) { <nl> + return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , null , autoRefresh ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 163 , 7 + 191 , 43 @ @ public class Realm { <nl> * / <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> public static Realm getInstance ( Context context , String fileName ) { <nl> - return Realm . create ( context . getFilesDir ( ) , fileName , null ) ; <nl> + return Realm . create ( context . getFilesDir ( ) , fileName , null , true ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Realm static constructor <nl> + * <nl> + * @ param context an Android context <nl> + * @ param fileName the name of the file to save the Realm to <nl> + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) <nl> + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) <nl> + * @ return an instance of the Realm class <nl> + * @ throws RealmMigrationNeededException The model classes have been changed and the Realm <nl> + * must be migrated <nl> + * @ throws RealmIOException Error when accessing underlying file <nl> + * @ throws RealmException Other errors <nl> + * / <nl> + @ SuppressWarnings ( " UnusedDeclaration " ) <nl> + public static Realm getInstance ( Context context , String fileName , boolean autoRefresh ) { <nl> + return Realm . create ( context . getFilesDir ( ) , fileName , null , autoRefresh ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Realm static constructor <nl> + * <nl> + * @ param context an Android context <nl> + * @ param key a 32 - byte encryption key <nl> + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) <nl> + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) <nl> + * @ return an instance of the Realm class <nl> + * @ throws RealmMigrationNeededException The model classes have been changed and the Realm <nl> + * must be migrated <nl> + * @ throws RealmIOException Error when accessing underlying file <nl> + * @ throws RealmException Other errors <nl> + * / <nl> + @ SuppressWarnings ( " UnusedDeclaration " ) <nl> + public static Realm getInstance ( Context context , byte [ ] key , boolean autoRefresh ) { <nl> + return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , key , autoRefresh ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 179 , 23 + 243 , 27 @ @ public class Realm { <nl> * / <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> public static Realm getInstance ( Context context , byte [ ] key ) { <nl> - return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , key ) ; <nl> + return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , key , true ) ; <nl> } <nl> <nl> + <nl> + <nl> / * * <nl> * Realm static constructor <nl> * <nl> * @ param context an Android context <nl> * @ param fileName the name of the file to save the Realm to <nl> * @ param key a 32 - byte encryption key <nl> + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) <nl> + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) <nl> * @ return an instance of the Realm class <nl> * @ throws RealmMigrationNeededException The model classes have been changed and the Realm <nl> * must be migrated <nl> * @ throws RealmIOException Error when accessing underlying file <nl> * @ throws RealmException Other errors <nl> * / <nl> - public static Realm getInstance ( Context context , String fileName , byte [ ] key ) { <nl> - return Realm . create ( context . getFilesDir ( ) , fileName , key ) ; <nl> + public static Realm getInstance ( Context context , String fileName , byte [ ] key , boolean autoRefresh ) { <nl> + return Realm . create ( context . getFilesDir ( ) , fileName , key , autoRefresh ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 203 , 6 + 271 , 8 @ @ public class Realm { <nl> * <nl> * @ param writableFolder absolute path to a writable directory <nl> * @ param key a 32 - byte encryption key <nl> + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) <nl> + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) <nl> * @ return an instance of the Realm class <nl> * @ throws RealmMigrationNeededException The model classes have been changed and the Realm <nl> * must be migrated <nl> @ @ - 210 , 8 + 280 , 8 @ @ public class Realm { <nl> * @ throws RealmException Other errors <nl> * / <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> - public static Realm getInstance ( File writableFolder , byte [ ] key ) { <nl> - return Realm . create ( writableFolder , DEFAULT _ REALM _ NAME , key ) ; <nl> + public static Realm getInstance ( File writableFolder , byte [ ] key , boolean autoRefresh ) { <nl> + return Realm . create ( writableFolder , DEFAULT _ REALM _ NAME , key , autoRefresh ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 220 , 23 + 290 , 25 @ @ public class Realm { <nl> * @ param writableFolder absolute path to a writable directory <nl> * @ param filename the name of the file to save the Realm to <nl> * @ param key a 32 - byte encryption key <nl> + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) <nl> + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) <nl> * @ return an instance of the Realm class <nl> * @ throws RealmMigrationNeededException The model classes have been changed and the Realm <nl> * must be migrated <nl> * @ throws RealmIOException Error when accessing underlying file <nl> * @ throws RealmException Other errors <nl> * / <nl> - public static Realm create ( File writableFolder , String filename , byte [ ] key ) { <nl> + public static Realm create ( File writableFolder , String filename , byte [ ] key , boolean autoRefresh ) { <nl> String absolutePath = new File ( writableFolder , filename ) . getAbsolutePath ( ) ; <nl> - return createAndValidate ( absolutePath , key , true ) ; <nl> + return createAndValidate ( absolutePath , key , true , autoRefresh ) ; <nl> } <nl> <nl> - private static Realm createAndValidate ( String absolutePath , byte [ ] key , boolean validateSchema ) { <nl> + private static Realm createAndValidate ( String absolutePath , byte [ ] key , boolean validateSchema , boolean autoRefresh ) { <nl> Map < String , Realm > realms = realmsCache . get ( ) ; <nl> Realm realm = realms . get ( absolutePath ) ; <nl> <nl> if ( realm = = null ) { <nl> - realm = new Realm ( absolutePath , key ) ; <nl> + realm = new Realm ( absolutePath , key , autoRefresh ) ; <nl> realms . put ( absolutePath , realm ) ; <nl> realmsCache . set ( realms ) ; <nl> } <nl> @ @ - 517 , 7 + 589 , 6 @ @ public class Realm { <nl> * / <nl> public void addChangeListener ( RealmChangeListener listener ) { <nl> changeListeners . add ( listener ) ; <nl> - LooperThread . handlers . put ( handler , id ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 528 , 9 + 599 , 6 @ @ public class Realm { <nl> * / <nl> public void removeChangeListener ( RealmChangeListener listener ) { <nl> changeListeners . remove ( listener ) ; <nl> - if ( changeListeners . isEmpty ( ) ) { <nl> - LooperThread . handlers . remove ( handler ) ; <nl> - } <nl> } <nl> <nl> / * * <nl> @ @ - 540 , 7 + 608 , 6 @ @ public class Realm { <nl> * / <nl> public void removeAllChangeListeners ( ) { <nl> changeListeners . clear ( ) ; <nl> - LooperThread . handlers . remove ( handler ) ; <nl> } <nl> <nl> void sendNotifications ( ) { <nl> @ @ - 558 , 9 + 625 , 13 @ @ public class Realm { <nl> * Transactions <nl> * / <nl> <nl> - / / public void refresh ( ) { <nl> - / / transaction . advanceRead ( ) ; <nl> - / / } <nl> + / * * <nl> + * Refresh the Realm instance and all the RealmResults and RealmObjects instances coming from it <nl> + * / <nl> + @ SuppressWarnings ( " UnusedDeclaration " ) <nl> + public void refresh ( ) { <nl> + transaction . advanceRead ( ) ; <nl> + } <nl> <nl> / * * <nl> * Starts a write transaction , this must be closed with commitTransaction ( ) or aborted <nl> @ @ - 582 , 7 + 653 , 7 @ @ public class Realm { <nl> <nl> / * * <nl> * All changes since beginTransaction ( ) are persisted to disk and the realm reverts back to being read - only , <nl> - * An event is sent to notify all other realm instances that a change has occured . <nl> + * An event is sent to notify all other realm instances that a change has occurred . <nl> * When the event is received , the other realms will get their objects and RealmResults updated to reflect <nl> * the changes from this commit . <nl> * <nl> @ @ - 591 , 13 + 662 , 16 @ @ public class Realm { <nl> public void commitTransaction ( ) { <nl> transaction . commitAndContinueAsRead ( ) ; <nl> <nl> - Message message = Message . obtain ( ) ; <nl> - message . arg1 = LooperThread . REALM _ CHANGED ; <nl> - message . arg2 = id ; <nl> - if ( looperThread . handler ! = null ) { <nl> - looperThread . handler . sendMessage ( message ) ; <nl> - } else { <nl> - Log . i ( TAG , " The LooperThread is not up and running yet . Commit message not sent " ) ; <nl> + for ( Map . Entry < Handler , Integer > handlerIntegerEntry : handlers . entrySet ( ) ) { <nl> + Handler handler = handlerIntegerEntry . getKey ( ) ; <nl> + int realmId = handlerIntegerEntry . getValue ( ) ; <nl> + if ( <nl> + realmId = = id / / It ' s the right realm <nl> + & & ! handler . hasMessages ( REALM _ CHANGED ) / / The right message <nl> + & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) / / The receiving thread is alive <nl> + ) { <nl> + handler . sendEmptyMessage ( REALM _ CHANGED ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 645 , 18 + 719 , 19 @ @ public class Realm { <nl> metadataTable . setLong ( 0 , 0 , version ) ; <nl> } <nl> <nl> - static public void migrateRealmAtPath ( String realmPath , RealmMigration migration ) { <nl> - migrateRealmAtPath ( realmPath , null , migration ) ; <nl> + @ SuppressWarnings ( " UnusedDeclaration " ) <nl> + static public void migrateRealmAtPath ( String realmPath , RealmMigration migration , boolean autoRefresh ) { <nl> + migrateRealmAtPath ( realmPath , null , migration , autoRefresh ) ; <nl> } <nl> <nl> - static public void migrateRealmAtPath ( String realmPath , byte [ ] key , RealmMigration migration ) { <nl> - Realm realm = Realm . createAndValidate ( realmPath , key , false ) ; <nl> + static public void migrateRealmAtPath ( String realmPath , byte [ ] key , RealmMigration migration , boolean autoUpdate ) { <nl> + Realm realm = Realm . createAndValidate ( realmPath , key , false , autoUpdate ) ; <nl> realm . beginTransaction ( ) ; <nl> realm . setVersion ( migration . execute ( realm , realm . getVersion ( ) ) ) ; <nl> realm . commitTransaction ( ) ; <nl> <nl> Map < String , Realm > realms = realmsCache . get ( ) ; <nl> - realms . put ( realmPath , new Realm ( realmPath , key ) ) ; <nl> + realms . put ( realmPath , new Realm ( realmPath , key , autoUpdate ) ) ; <nl> realmsCache . set ( realms ) ; <nl> } <nl> <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / LooperThread . java b / realm / src / main / java / io / realm / internal / android / LooperThread . java <nl> deleted file mode 100644 <nl> index 7edd0d1 . . 0000000 <nl> - - - a / realm / src / main / java / io / realm / internal / android / LooperThread . java <nl> + + + / dev / null <nl> @ @ - 1 , 87 + 0 , 0 @ @ <nl> - / * <nl> - * Copyright 2014 Realm Inc . <nl> - * <nl> - * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> - * you may not use this file except in compliance with the License . <nl> - * You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package io . realm . internal . android ; <nl> - <nl> - import android . os . Handler ; <nl> - import android . os . Looper ; <nl> - import android . os . Message ; <nl> - import android . util . Log ; <nl> - <nl> - import java . util . ArrayList ; <nl> - import java . util . List ; <nl> - import java . util . Map ; <nl> - import java . util . concurrent . ConcurrentHashMap ; <nl> - <nl> - / * * <nl> - * This thread continuously receives and dispatches messages regarding changes in realms . <nl> - * / <nl> - public class LooperThread extends Thread { <nl> - / / Message types <nl> - public static final int REALM _ CHANGED = 3 ; <nl> - public static final Map < Handler , Integer > handlers = new ConcurrentHashMap < Handler , Integer > ( ) ; <nl> - <nl> - public Handler handler ; <nl> - public List < RuntimeException > exceptions = new ArrayList < RuntimeException > ( ) ; <nl> - <nl> - private static final String TAG = LooperThread . class . getName ( ) ; <nl> - private static LooperThread instance ; <nl> - <nl> - / / private because it ' s a singleton <nl> - private LooperThread ( ) { } <nl> - <nl> - / / thread safe static constructor <nl> - public static LooperThread getInstance ( ) { <nl> - if ( instance = = null ) { <nl> - synchronized ( LooperThread . class ) { <nl> - if ( instance = = null ) { <nl> - instance = new LooperThread ( ) ; <nl> - } <nl> - } <nl> - } <nl> - return instance ; <nl> - } <nl> - <nl> - @ Override <nl> - public void run ( ) { <nl> - Looper . prepare ( ) ; <nl> - <nl> - handler = new Handler ( ) { <nl> - @ Override <nl> - public void handleMessage ( Message message ) { <nl> - if ( message . arg1 = = REALM _ CHANGED ) { <nl> - for ( Map . Entry < Handler , Integer > entry : handlers . entrySet ( ) ) { <nl> - if ( entry . getValue ( ) = = message . arg2 ) { <nl> - Handler currentHandler = entry . getKey ( ) ; <nl> - if ( currentHandler . getLooper ( ) . getThread ( ) . isAlive ( ) & & <nl> - ! currentHandler . hasMessages ( REALM _ CHANGED ) ) <nl> - { <nl> - try { <nl> - currentHandler . sendEmptyMessage ( REALM _ CHANGED ) ; <nl> - } catch ( RuntimeException e ) { <nl> - exceptions . add ( e ) ; <nl> - Log . w ( TAG , e . getMessage ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - } <nl> - } <nl> - } ; <nl> - <nl> - Looper . loop ( ) ; <nl> - } <nl> - }

TEST DIFF:
diff - - git a / examples / threadExample / src / main / java / io / realm / examples / threads / AsyncQueryFragment . java b / examples / threadExample / src / main / java / io / realm / examples / threads / AsyncQueryFragment . java 
 index d864060 . . de41b08 100644 
 - - - a / examples / threadExample / src / main / java / io / realm / examples / threads / AsyncQueryFragment . java 
 + + + b / examples / threadExample / src / main / java / io / realm / examples / threads / AsyncQueryFragment . java 
 @ @ - 89 , 7 + 89 , 7 @ @ public class AsyncQueryFragment extends Fragment implements View . OnClickListener 
 case R . id . translate _ button : { 
 cancelAsyncTransaction ( ) ; 
 / / translate all points coordinates using an async transaction 
 - asyncTransaction = realm . executeTransaction ( new Realm . Transaction ( ) { 
 + asyncTransaction = realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 / / query for all points 
 @ @ - 105 , 16 + 105 , 17 @ @ public class AsyncQueryFragment extends Fragment implements View . OnClickListener 
 } 
 } 
 } 
 - } , new Realm . Transaction . Callback ( ) { 
 + } , new Realm . Transaction . OnSuccess ( ) { 
 @ Override 
 public void onSuccess ( ) { 
 if ( isAdded ( ) ) { 
 Toast . makeText ( getActivity ( ) , " Translation completed " , Toast . LENGTH _ SHORT ) . show ( ) ; 
 } 
 } 
 + } , new Realm . Transaction . OnError ( ) { 
 
 @ Override 
 - public void onError ( Exception e ) { 
 + public void onError ( Throwable e ) { 
 if ( isAdded ( ) ) { 
 Toast . makeText ( getActivity ( ) , " Error while translating dots " , Toast . LENGTH _ SHORT ) . show ( ) ; 
 e . printStackTrace ( ) ; 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index e6cc8af . . 57481f9 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 18 , 7 + 18 , 6 @ @ package io . realm ; 
 
 import android . content . Context ; 
 import android . os . Handler ; 
 - import android . os . HandlerThread ; 
 import android . os . Looper ; 
 import android . os . MessageQueue ; 
 import android . os . SystemClock ; 
 @ @ - 56 , 6 + 55 , 7 @ @ import io . realm . rule . RunTestInLooperThread ; 
 import static org . junit . Assert . assertEquals ; 
 import static org . junit . Assert . assertFalse ; 
 import static org . junit . Assert . assertNotNull ; 
 + import static org . junit . Assert . assertNull ; 
 import static org . junit . Assert . assertTrue ; 
 import static org . junit . Assert . fail ; 
 
 @ @ - 78 , 34 + 78 , 96 @ @ public class RealmAsyncQueryTests { 
 / / start asynchronously a transaction to insert one element 
 @ Test 
 @ RunTestInLooperThread 
 - public void executeTransaction _ async ( ) throws Throwable { 
 + public void executeTransactionAsync ( ) throws Throwable { 
 assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 
 - looperThread . realm . executeTransaction ( new Realm . Transaction ( ) { 
 + looperThread . realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 Owner owner = realm . createObject ( Owner . class ) ; 
 owner . setName ( " Owner " ) ; 
 } 
 - } , new Realm . Transaction . Callback ( ) { 
 + } , new Realm . Transaction . OnSuccess ( ) { 
 @ Override 
 public void onSuccess ( ) { 
 assertEquals ( 1 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 assertEquals ( " Owner " , looperThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; 
 looperThread . testComplete ( ) ; 
 } 
 + } , new Realm . Transaction . OnError ( ) { 
 
 @ Override 
 - public void onError ( Exception e ) { 
 - looperThread . testComplete ( ) ; ; 
 - fail ( e . getMessage ( ) ) ; 
 + public void onError ( Throwable error ) { 
 + fail ( error . getMessage ( ) ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void executeTransactionAsync _ onSuccess ( ) throws Throwable { 
 + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 + 
 + looperThread . realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + Owner owner = realm . createObject ( Owner . class ) ; 
 + owner . setName ( " Owner " ) ; 
 + } 
 + } , new Realm . Transaction . OnSuccess ( ) { 
 + @ Override 
 + public void onSuccess ( ) { 
 + assertEquals ( 1 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 + assertEquals ( " Owner " , looperThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void executeTransactionAsync _ onError ( ) throws Throwable { 
 + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 + 
 + looperThread . realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + throw new RuntimeException ( " Oh ! What a Terrible Failure " ) ; 
 + } 
 + } , new Realm . Transaction . OnError ( ) { 
 + @ Override 
 + public void onError ( Throwable error ) { 
 + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 + assertNull ( looperThread . realm . where ( Owner . class ) . findFirst ( ) ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void executeTransactionAsync _ NoCallbacks ( ) throws Throwable { 
 + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 + 
 + looperThread . realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + Owner owner = realm . createObject ( Owner . class ) ; 
 + owner . setName ( " Owner " ) ; 
 + } 
 + } ) ; 
 + looperThread . realm . addChangeListener ( new RealmChangeListener ( ) { 
 + @ Override 
 + public void onChange ( ) { 
 + assertEquals ( " Owner " , looperThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 } ) ; 
 } 
 
 / / Test that an async transaction that throws an exception propagate it properly to the user . 
 @ Test 
 - public void executeTransaction _ async _ exceptionHandling ( ) throws Throwable { 
 + public void executeTransactionAsync _ exceptionHandling ( ) throws Throwable { 
 final TestHelper . TestLogger testLogger = new TestHelper . TestLogger ( ) ; 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 @ @ - 125 , 7 + 187 , 7 @ @ public class RealmAsyncQueryTests { 
 
 assertEquals ( 0 , realm [ 0 ] . allObjects ( Owner . class ) . size ( ) ) ; 
 
 - realm [ 0 ] . executeTransaction ( new Realm . Transaction ( ) { 
 + realm [ 0 ] . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 Owner owner = realm . createObject ( Owner . class ) ; 
 @ @ - 133 , 7 + 195 , 7 @ @ public class RealmAsyncQueryTests { 
 realm . cancelTransaction ( ) ; / / Cancel the transaction then throw 
 throw new RuntimeException ( " Boom " ) ; 
 } 
 - } , new Realm . Transaction . Callback ( ) { 
 + } , new Realm . Transaction . OnSuccess ( ) { 
 @ Override 
 public void onSuccess ( ) { 
 try { 
 @ @ - 144 , 9 + 206 , 9 @ @ public class RealmAsyncQueryTests { 
 signalCallbackFinished . countDown ( ) ; 
 } 
 } 
 - 
 + } , new Realm . Transaction . OnError ( ) { 
 @ Override 
 - public void onError ( Exception e ) { 
 + public void onError ( Throwable error ) { 
 try { 
 / / Ensure we are giving developers quality messages in the logs . 
 assertEquals ( testLogger . message , " Could not cancel transaction , not currently in a transaction . " ) ; 
 @ @ - 182 , 9 + 244 , 9 @ @ public class RealmAsyncQueryTests { 
 / / Test if the background Realm is closed when transaction success returned . 
 @ Test 
 @ RunTestInLooperThread 
 - public void executeTransaction _ async _ realmClosedOnSuccess ( ) { 
 + public void executeTransactionAsync _ realmClosedOnSuccess ( ) { 
 final AtomicInteger counter = new AtomicInteger ( 100 ) ; 
 - final Realm realm = Realm . getInstance ( looperThread . createConfiguration ( " testClosedBeforeAsyncTransactionSuccess " ) ) ; 
 + final Realm realm = looperThread . realm ; 
 final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { 
 @ Override 
 public void onResult ( int count ) { 
 @ @ - 195 , 7 + 257 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 } 
 } ; 
 - final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { 
 + final Realm . Transaction . OnSuccess transactionCallback = new Realm . Transaction . OnSuccess ( ) { 
 @ Override 
 public void onSuccess ( ) { 
 RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; 
 @ @ - 203 , 7 + 265 , 7 @ @ public class RealmAsyncQueryTests { 
 / / Finish testing 
 return ; 
 } 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 } 
 @ @ - 211 , 7 + 273 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 } ; 
 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 } 
 @ @ - 223 , 7 + 285 , 7 @ @ public class RealmAsyncQueryTests { 
 @ RunTestInLooperThread 
 public void executeTransaction _ async _ realmClosedOnError ( ) { 
 final AtomicInteger counter = new AtomicInteger ( 100 ) ; 
 - final Realm realm = Realm . getInstance ( looperThread . createConfiguration ( " testClosedBeforeAsyncTransactionSuccess " ) ) ; 
 + final Realm realm = looperThread . realm ; 
 final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { 
 @ Override 
 public void onResult ( int count ) { 
 @ @ - 234 , 15 + 296 , 15 @ @ public class RealmAsyncQueryTests { 
 } 
 } 
 } ; 
 - final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { 
 + final Realm . Transaction . OnError transactionCallback = new Realm . Transaction . OnError ( ) { 
 @ Override 
 - public void onError ( Exception e ) { 
 + public void onError ( Throwable error ) { 
 RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; 
 if ( counter . get ( ) = = 0 ) { 
 / / Finish testing 
 return ; 
 } 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 throw new RuntimeException ( " Dummy exception " ) ; 
 @ @ - 251 , 7 + 313 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 } ; 
 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 throw new RuntimeException ( " Dummy exception " ) ; 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java 
 index 0f513bd . . 13440d3 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java 
 @ @ - 2588 , 12 + 2588 , 12 @ @ public class RealmTests { 
 
 realm . addChangeListener ( listener ) ; 
 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 realm . createObject ( AllTypes . class ) ; 
 } 
 - } , new Realm . Transaction . Callback ( ) ) ; 
 + } ) ; 
 } 
 } ) ; 
 TestHelper . awaitOrFail ( signalTestFinished ) ; 
 @ @ - 2632 , 12 + 2632 , 12 @ @ public class RealmTests { 
 final AllTypes allTypes = realm . where ( AllTypes . class ) . findFirstAsync ( ) ; 
 allTypes . addChangeListener ( dummyListener ) ; 
 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 realm . createObject ( AllTypes . class ) ; 
 } 
 - } , new Realm . Transaction . Callback ( ) ) ; 
 + } ) ; 
 } 
 
 / / Test if close can be called from Realm change listener when there is an listener on non - empty Realm Object 
 @ @ - 2677 , 12 + 2677 , 12 @ @ public class RealmTests { 
 / / Step 1 : Change listener on Realm Object 
 final AllTypes allTypes = realm . where ( AllTypes . class ) . findFirst ( ) ; 
 allTypes . addChangeListener ( dummyListener ) ; 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 realm . createObject ( AllTypes . class ) ; 
 } 
 - } , new Realm . Transaction . Callback ( ) ) ; 
 + } ) ; 
 } 
 
 / / Test if close can be called from Realm change listener when there is an listener on RealmResults 
 @ @ - 2717 , 12 + 2717 , 12 @ @ public class RealmTests { 
 RealmResults < AllTypes > results = realm . where ( AllTypes . class ) . findAll ( ) ; 
 results . addChangeListener ( dummyListener ) ; 
 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 + realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 realm . createObject ( AllTypes . class ) ; 
 } 
 - } , new Realm . Transaction . Callback ( ) ) ; 
 + } ) ; 
 } 
 
 @ Test 
 diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java 
 index 69ce18d . . 57d2cb9 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / Realm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / Realm . java 
 @ @ - 19 , 7 + 19 , 6 @ @ package io . realm ; 
 import android . annotation . TargetApi ; 
 import android . content . Context ; 
 import android . os . Build ; 
 - import android . os . Handler ; 
 import android . os . Looper ; 
 import android . util . JsonReader ; 
 
 @ @ - 1067 , 16 + 1066 , 20 @ @ public final class Realm extends BaseRealm { 
 } 
 
 / * * 
 - * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously from a worker thread . 
 + * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously on a worker thread . 
 * 
 * @ param transaction { @ link io . realm . Realm . Transaction } to execute . 
 * @ param callback optional , to receive the result of this query . 
 * @ return a { @ link RealmAsyncTask } representing a cancellable task . 
 * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . 
 + * @ deprecated replaced by { @ link # executeTransactionAsync ( Transaction ) } , { @ link # executeTransactionAsync ( Transaction , Transaction . OnSuccess ) } , { @ link # executeTransactionAsync ( Transaction , io . realm . Realm . Transaction . OnError ) } and { @ link # executeTransactionAsync ( Transaction , Transaction . OnSuccess , Transaction . OnError ) } . 
 * / 
 + @ Deprecated 
 public RealmAsyncTask executeTransaction ( final Transaction transaction , final Transaction . Callback callback ) { 
 - if ( transaction = = null ) 
 + checkIfValid ( ) ; 
 + if ( transaction = = null ) { 
 throw new IllegalArgumentException ( " Transaction should not be null " ) ; 
 + } 
 
 / / If the user provided a Callback then we make sure , the current Realm has a Handler 
 / / we can use to deliver the result 
 @ @ - 1157 , 6 + 1160 , 174 @ @ public final class Realm extends BaseRealm { 
 } 
 
 / * * 
 + * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously on a worker thread . 
 + * 
 + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . 
 + * @ return a { @ link RealmAsyncTask } representing a cancellable task . 
 + * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . 
 + * / 
 + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction ) { 
 + return executeTransactionAsync ( transaction , null , null ) ; 
 + } 
 + 
 + / * * 
 + * Similar to { @ link # executeTransactionAsync ( Transaction ) } , but also accepts an OnSuccess callback . 
 + * 
 + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . 
 + * @ param onSuccess callback invoked when the transaction succeeds . 
 + * @ return a { @ link RealmAsyncTask } representing a cancellable task . 
 + * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . 
 + * / 
 + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , final Realm . Transaction . OnSuccess onSuccess ) { 
 + if ( onSuccess = = null ) { 
 + throw new IllegalArgumentException ( " onSuccess callback can ' t be null " ) ; 
 + } 
 + 
 + return executeTransactionAsync ( transaction , onSuccess , null ) ; 
 + } 
 + 
 + / * * 
 + * Similar to { @ link # executeTransactionAsync ( Transaction ) } , but also accepts an OnError callback . 
 + * 
 + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . 
 + * @ param onError callback invoked when the transaction failed . 
 + * @ return a { @ link RealmAsyncTask } representing a cancellable task . 
 + * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . 
 + * / 
 + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , final Realm . Transaction . OnError onError ) { 
 + if ( onError = = null ) { 
 + throw new IllegalArgumentException ( " onError callback can ' t be null " ) ; 
 + } 
 + 
 + return executeTransactionAsync ( transaction , null , onError ) ; 
 + } 
 + 
 + / * * 
 + * Similar to { @ link # executeTransactionAsync ( Transaction ) } , but also accepts an OnSuccess and OnError callbacks . 
 + * 
 + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . 
 + * @ param onSuccess callback invoked when the transaction succeeds . 
 + * @ param onError callback invoked when the transaction failed . 
 + * @ return a { @ link RealmAsyncTask } representing a cancellable task . 
 + * @ throws IllegalArgumentException if the { @ code transaction } is { @ code null } , or if the realm is opened from another thread . 
 + * / 
 + public RealmAsyncTask executeTransactionAsync ( final Transaction transaction , final Realm . Transaction . OnSuccess onSuccess , final Realm . Transaction . OnError onError ) { 
 + checkIfValid ( ) ; 
 + 
 + if ( transaction = = null ) { 
 + throw new IllegalArgumentException ( " Transaction should not be null " ) ; 
 + } 
 + 
 + / / If the user provided a Callback then we make sure , the current Realm has a Handler 
 + / / we can use to deliver the result 
 + if ( ( onSuccess ! = null | | onError ! = null ) & & handler = = null ) { 
 + throw new IllegalStateException ( " Your Realm is opened from a thread without a Looper " + 
 + " and you provided a callback , we need a Handler to invoke your callback " ) ; 
 + } 
 + 
 + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) 
 + / / to perform the transaction 
 + final RealmConfiguration realmConfiguration = getConfiguration ( ) ; 
 + 
 + final Future < ? > pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + return ; 
 + } 
 + 
 + boolean transactionCommitted = false ; 
 + final Throwable [ ] exception = new Throwable [ 1 ] ; 
 + final Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 + bgRealm . beginTransaction ( ) ; 
 + try { 
 + transaction . execute ( bgRealm ) ; 
 + 
 + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + bgRealm . commitTransaction ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + / / The bgRealm needs to be closed before post event to caller ' s handler to avoid 
 + / / concurrency problem . eg . : User wants to delete Realm in the callbacks . 
 + / / This will close Realm before sending REALM _ CHANGED . 
 + bgRealm . close ( ) ; 
 + } 
 + } ) ; 
 + transactionCommitted = true ; 
 + } 
 + } catch ( final Throwable e ) { 
 + exception [ 0 ] = e ; 
 + } finally { 
 + if ( ! bgRealm . isClosed ( ) ) { 
 + if ( bgRealm . isInTransaction ( ) ) { 
 + bgRealm . cancelTransaction ( ) ; 
 + } else if ( exception [ 0 ] ! = null ) { 
 + RealmLog . w ( " Could not cancel transaction , not currently in a transaction . " ) ; 
 + } 
 + bgRealm . close ( ) ; 
 + } 
 + 
 + final Throwable backgroundException = exception [ 0 ] ; 
 + / / Send response as the final step to ensure the bg thread quit before others get the response ! 
 + if ( handler ! = null 
 + & & ! Thread . currentThread ( ) . isInterrupted ( ) 
 + & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) ) { 
 + if ( onSuccess ! = null & & transactionCommitted ) { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + onSuccess . onSuccess ( ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 + if ( backgroundException ! = null ) { 
 + if ( onError ! = null ) { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + onError . onError ( backgroundException ) ; 
 + } 
 + } ) ; 
 + } else { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( backgroundException instanceof RuntimeException ) { 
 + throw ( RuntimeException ) backgroundException ; 
 + } else if ( backgroundException instanceof Exception ) { 
 + throw new RealmException ( " Async transaction failed " , backgroundException ) ; 
 + } else if ( backgroundException instanceof Error ) { 
 + throw ( Error ) backgroundException ; 
 + } 
 + } 
 + } ) ; 
 + } 
 + } 
 + } else { 
 + / / Throw exception in the worker thread if the caller thread terminated 
 + if ( backgroundException ! = null ) { 
 + if ( backgroundException instanceof RuntimeException ) { 
 + / / noinspection ThrowFromFinallyBlock 
 + throw ( RuntimeException ) backgroundException ; 
 + } else if ( backgroundException instanceof Exception ) { 
 + / / noinspection ThrowFromFinallyBlock 
 + throw new RealmException ( " Async transaction failed " , backgroundException ) ; 
 + } else if ( backgroundException instanceof Error ) { 
 + / / noinspection ThrowFromFinallyBlock 
 + throw ( Error ) backgroundException ; 
 + } 
 + } 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + return new RealmAsyncTask ( pendingQuery ) ; 
 + } 
 + 
 + 
 + / * * 
 * Removes all objects of the specified class . 
 * 
 * @ param clazz the class which objects should be removed . 
 @ @ - 1326 , 5 + 1497 , 21 @ @ public final class Realm extends BaseRealm { 
 public void onSuccess ( ) { } 
 public void onError ( Exception e ) { } 
 } 
 + 
 + / * * 
 + * Callback invoked to notify the caller thread about the success of the transaction . 
 + * / 
 + interface OnSuccess { 
 + void onSuccess ( ) ; 
 + } 
 + 
 + / * * 
 + * Callback invoked to notify the caller thread about error during the transaction . 
 + * The transaction will be rolled back and the background Realm will be closed before 
 + * invoking { @ link # onError ( Throwable ) } . 
 + * / 
 + interface OnError { 
 + void onError ( Throwable error ) ; 
 + } 
 } 
 }

NEAREST DIFF:
diff - - git a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / RealmExampleActivity . java b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / RealmExampleActivity . java 
 index 224eaa0 . . 06510a0 100644 
 - - - a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / RealmExampleActivity . java 
 + + + b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / RealmExampleActivity . java 
 @ @ - 37 , 7 + 37 , 7 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 public static final String TAG = RealmExampleActivity . class . getName ( ) ; 
 
 - private Realm realm = null ; 
 + private Realm realm ; 
 
 @ Override 
 protected void onCreate ( Bundle savedInstanceState ) { 
 @ @ - 63 , 7 + 63 , 7 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen 
 public void onResume ( ) { 
 super . onResume ( ) ; 
 
 - 	 / / Alternatively can use transaction tests here . . . 
 + / / Alternatively can use transaction tests here . . . 
 / / startTransactionTests ( ) ; 
 
 startSpawnTests ( ) ; 
 @ @ - 73 , 7 + 73 , 7 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen 
 public void onStop ( ) { 
 super . onStop ( ) ; 
 
 - 	 / / Alternatively can use transaction tests here . . . 
 + / / Alternatively can use transaction tests here . . . 
 / / stopTransactionTests ( ) ; 
 
 stopSpawnTests ( ) ; 
 @ @ - 87 , 12 + 87 , 12 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen 
 String personAge = ( ( TextView ) findViewById ( R . id . age ) ) . getText ( ) . toString ( ) ; 
 String petName = ( ( TextView ) findViewById ( R . id . pets _ name ) ) . getText ( ) . toString ( ) ; 
 
 - Integer parseAge = 0 ; 
 + Integer parseAge ; 
 try { 
 parseAge = Integer . parseInt ( personAge ) ; 
 } catch ( NumberFormatException ignored ) { 
 - 	 Log . d ( TAG , " Age for a person invalid " ) ; 
 - 	 return ; 
 + Log . d ( TAG , " Age for a person invalid " ) ; 
 + return ; 
 } 
 
 realm . beginTransaction ( ) ; 
 @ @ - 135 , 8 + 135 , 8 @ @ public class RealmExampleActivity extends Activity implements View . OnClickListen 
 / / which loop for a specified count 
 private void startSpawnTests ( ) { 
 Intent serviceIntent = new Intent ( this , SpawningService . class ) ; 
 - serviceIntent . putExtra ( SpawningService . REALM _ INSERTCOUNT _ EXTRA , 10000000 ) ; 
 - serviceIntent . putExtra ( SpawningService . REALM _ READCOUNT _ EXTRA , 10000000 ) ; 
 + serviceIntent . putExtra ( SpawningService . REALM _ INSERT _ COUNT _ EXTRA , 10000000 ) ; 
 + serviceIntent . putExtra ( SpawningService . REALM _ READ _ COUNT _ EXTRA , 10000000 ) ; 
 this . startService ( serviceIntent ) ; 
 } 
 
 diff - - git a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / services / SpawningService . java b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / services / SpawningService . java 
 index 8d502ce . . 7acadcf 100644 
 - - - a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / services / SpawningService . java 
 + + + b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / services / SpawningService . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . examples . concurrency . services ; 
 import android . app . Service ; 
 import android . content . Intent ; 
 import android . os . IBinder ; 
 + import android . util . Log ; 
 
 import java . util . ArrayList ; 
 import java . util . List ; 
 @ @ - 30 , 39 + 31 , 38 @ @ import io . realm . examples . concurrency . threads . RealmWriter ; 
 public class SpawningService extends Service { 
 
 public static final String TAG = SpawningService . class . getName ( ) ; 
 + public static final String REALM _ INSERT _ COUNT _ EXTRA = " RealmInsertCountExtra " ; 
 + public static final String REALM _ READ _ COUNT _ EXTRA = " RealmReadCountExtra " ; 
 
 - public static final String REALM _ INSERTCOUNT _ EXTRA = " RealmInsertCountExtra " ; 
 - public static final String REALM _ READCOUNT _ EXTRA = " RealmReadCountExtra " ; 
 - 
 - private List < KillableThread > allThreads = null ; 
 - 
 - public void onCreate ( ) { 
 - super . onCreate ( ) ; 
 - } 
 + private List < KillableThread > allThreads = new ArrayList < KillableThread > ( ) ; 
 
 @ Override 
 public int onStartCommand ( Intent intent , int flags , int startId ) { 
 + if ( intent = = null ) { 
 + Log . i ( TAG , " The intent is null " ) ; 
 + throw new AssertionError ( ) ; 
 + } 
 
 - int insertCount = intent . getIntExtra ( REALM _ INSERTCOUNT _ EXTRA , 0 ) ; 
 - int readCount = intent . getIntExtra ( REALM _ READCOUNT _ EXTRA , 0 ) ; 
 + int insertCount = intent . getIntExtra ( REALM _ INSERT _ COUNT _ EXTRA , 0 ) ; 
 + int readCount = intent . getIntExtra ( REALM _ READ _ COUNT _ EXTRA , 0 ) ; 
 
 try { 
 - allThreads = new ArrayList < KillableThread > ( ) ; 
 - RealmWriter wT = new RealmWriter ( this ) ; 
 - wT . setInsertCount ( insertCount ) ; 
 - allThreads . add ( wT ) ; 
 - wT . start ( ) ; 
 - RealmReader rT = new RealmReader ( this ) ; 
 - rT . setReadCount ( readCount ) ; 
 - allThreads . add ( rT ) ; 
 - rT . start ( ) ; 
 + RealmWriter writerThread = new RealmWriter ( this ) ; 
 + writerThread . setInsertCount ( insertCount ) ; 
 + allThreads . add ( writerThread ) ; 
 + writerThread . start ( ) ; 
 + 
 + RealmReader readerThread = new RealmReader ( this ) ; 
 + readerThread . setReadCount ( readCount ) ; 
 + allThreads . add ( readerThread ) ; 
 + readerThread . start ( ) ; 
 } catch ( Exception e ) { 
 e . printStackTrace ( ) ; 
 quit ( ) ; 
 } 
 
 / / Service should stay active as long as Activity is active 
 - return START _ STICKY ; 
 + return START _ STICKY _ COMPATIBILITY ; 
 } 
 
 @ Override 
 diff - - git a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmReader . java b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmReader . java 
 index 9f7e738 . . 496d1f4 100644 
 - - - a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmReader . java 
 + + + b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmReader . java 
 @ @ - 17 , 19 + 17 , 18 @ @ 
 package io . realm . examples . concurrency . threads ; 
 
 import android . content . Context ; 
 + import android . os . Looper ; 
 import android . util . Log ; 
 
 import io . realm . Realm ; 
 + import io . realm . RealmChangeListener ; 
 import io . realm . examples . concurrency . model . Person ; 
 
 public class RealmReader extends Thread implements KillableThread { 
 
 public static final String TAG = RealmReader . class . getName ( ) ; 
 
 - private Context context = null ; 
 - 
 - private boolean mRunning = true ; 
 - 
 + private Context context ; 
 private int mReadCount = 0 ; 
 
 public RealmReader ( Context context ) { 
 @ @ - 37 , 25 + 36 , 26 @ @ public class RealmReader extends Thread implements KillableThread { 
 } 
 
 public void run ( ) { 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Looper . prepare ( ) ; 
 + final Realm realm = Realm . getInstance ( context , true ) ; 
 
 - int loopCount = 0 ; 
 + realm . addChangeListener ( new RealmChangeListener ( ) { 
 
 - while ( loopCount < mReadCount & & mRunning ) { 
 - Person person = realm . where ( Person . class ) 
 - . beginsWith ( " name " , " Foo " ) 
 - . between ( " age " , 20 , 50 ) . findFirst ( ) ; 
 + @ Override 
 + public void onChange ( ) { 
 + long peopleNumber = realm . where ( Person . class ) . count ( ) ; 
 + if ( peopleNumber % 10 = = 0 ) { 
 + Log . d ( TAG , " Found count " + peopleNumber ) ; 
 + } 
 
 - if ( loopCount % 1000 = = 0 ) { 
 - Log . d ( TAG , " Found : " + person ) ; 
 } 
 - loopCount + + ; 
 - } 
 + } ) ; 
 + Looper . loop ( ) ; 
 } 
 
 @ Override 
 public void terminate ( ) { 
 - mRunning = false ; 
 + Looper . myLooper ( ) . quit ( ) ; 
 } 
 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 diff - - git a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmWriter . java b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmWriter . java 
 index 53d7113 . . b400b70 100644 
 - - - a / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmWriter . java 
 + + + b / examples / concurrencyExample / src / main / java / io / realm / examples / concurrency / threads / RealmWriter . java 
 @ @ - 27 , 10 + 27 , 8 @ @ public class RealmWriter extends Thread implements KillableThread { 
 
 public static final String TAG = RealmWriter . class . getName ( ) ; 
 
 - private Context context = null ; 
 - 
 + private Context context ; 
 private boolean mRunning = true ; 
 - 
 private int mInsertCount = 0 ; 
 
 public RealmWriter ( Context context ) { 
 @ @ - 40 , 27 + 38 , 27 @ @ public class RealmWriter extends Thread implements KillableThread { 
 public void run ( ) { 
 Realm realm = Realm . getInstance ( context ) ; 
 
 - int iterCount = 0 ; 
 + int count = 0 ; 
 
 - while ( iterCount < mInsertCount & & mRunning ) { 
 + while ( count < mInsertCount & & mRunning ) { 
 realm . beginTransaction ( ) ; 
 
 Person person = realm . createObject ( Person . class ) ; 
 - person . setName ( " Foo " + iterCount ) ; 
 - person . setAge ( iterCount % 20 + ( 50 - 20 ) ) ; 
 + person . setName ( " Foo " + count ) ; 
 + person . setAge ( count % 20 + ( 50 - 20 ) ) ; 
 
 / / Add a dog to every 50th person 
 - if ( iterCount % 50 = = 0 ) { 
 + if ( count % 50 = = 0 ) { 
 Dog dog = realm . createObject ( Dog . class ) ; 
 - dog . setName ( " Foo " + iterCount + " Fido " ) ; 
 + dog . setName ( " Foo " + count + " Fido " ) ; 
 person . setDog ( dog ) ; 
 } 
 
 - iterCount + + ; 
 + count + + ; 
 realm . commitTransaction ( ) ; 
 
 - if ( ( iterCount % 1000 ) = = 0 ) { 
 - Log . d ( TAG , " WriteOperation # : " + iterCount + " , " + Thread . currentThread ( ) . getName ( ) ) ; 
 + if ( ( count % 1000 ) = = 0 ) { 
 + Log . d ( TAG , " WriteOperation # : " + count + " , " + Thread . currentThread ( ) . getName ( ) ) ; 
 } 
 } 
 } 
 diff - - git a / realm / src / androidTest / java / io / realm / NotificationsTest . java b / realm / src / androidTest / java / io / realm / NotificationsTest . java 
 index 6436da1 . . 2c8a98d 100644 
 - - - a / realm / src / androidTest / java / io / realm / NotificationsTest . java 
 + + + b / realm / src / androidTest / java / io / realm / NotificationsTest . java 
 @ @ - 15 , 56 + 15 , 144 @ @ 
 * / 
 package io . realm ; 
 
 + import android . os . Handler ; 
 + import android . os . Looper ; 
 import android . test . AndroidTestCase ; 
 - import android . util . Log ; 
 + 
 + import java . util . Queue ; 
 + import java . util . concurrent . ConcurrentLinkedQueue ; 
 + import java . util . concurrent . atomic . AtomicBoolean ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 
 import io . realm . entities . Dog ; 
 - import io . realm . internal . android . LooperThread ; 
 
 public class NotificationsTest extends AndroidTestCase { 
 - public void testMessageToDeadThread ( ) { 
 - Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 - 
 - / / Number of handlers before 
 - final int handlersBefore = LooperThread . handlers . size ( ) ; 
 + public void testFailureOnNonLooperThread ( ) { 
 + Thread thread = new Thread ( ) { 
 + @ Override 
 + public void run ( ) { 
 + try { 
 + Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 + fail ( " The Realm instantiations should have thrown an exception " ) ; 
 + } catch ( IllegalStateException ignored ) { } 
 + } 
 + } ; 
 + thread . start ( ) ; 
 + try { 
 + thread . join ( ) ; 
 + } catch ( InterruptedException e ) { 
 + fail ( ) ; 
 + } 
 + } 
 
 - / / Make sure the Looper Thread is alive 
 - LooperThread looperThread = LooperThread . getInstance ( ) ; 
 - assertTrue ( looperThread . isAlive ( ) ) ; 
 + public void testNotifications ( ) { 
 + final AtomicBoolean changed = new AtomicBoolean ( false ) ; 
 
 - Thread thread = new Thread ( ) { 
 + Thread listenerThread = new Thread ( ) { 
 @ Override 
 public void run ( ) { 
 - Realm r = Realm . getInstance ( getContext ( ) ) ; 
 - assertFalse ( handlersBefore = = LooperThread . handlers . size ( ) ) ; 
 - r . addChangeListener ( new RealmChangeListener ( ) { 
 + Looper . prepare ( ) ; 
 + Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 + realm . addChangeListener ( new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 - Log . i ( " Notification Test " , " Notification Received " ) ; 
 + changed . set ( true ) ; 
 + Looper . myLooper ( ) . quit ( ) ; 
 } 
 } ) ; 
 + Looper . loop ( ) ; 
 } 
 } ; 
 - thread . start ( ) ; 
 + listenerThread . start ( ) ; 
 + 
 + Thread writerThread = new Thread ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Realm realm = Realm . getInstance ( getContext ( ) , false ) ; 
 + realm . beginTransaction ( ) ; 
 + Dog dog = realm . createObject ( Dog . class ) ; 
 + dog . setName ( " Rex " ) ; 
 + realm . commitTransaction ( ) ; 
 + } 
 + } ; 
 + writerThread . start ( ) ; 
 
 try { 
 - thread . join ( ) ; 
 + writerThread . join ( ) ; 
 + listenerThread . join ( 2000 ) ; 
 } catch ( InterruptedException e ) { 
 fail ( ) ; 
 } 
 - assertFalse ( thread . isAlive ( ) ) ; / / Make sure the thread is dead 
 - realm . beginTransaction ( ) ; 
 - Dog dog = realm . createObject ( Dog . class ) ; 
 - dog . setName ( " Rex " ) ; 
 - realm . commitTransaction ( ) ; 
 
 - / / Give some time to log the exception 
 + assertEquals ( true , changed . get ( ) ) ; 
 + } 
 + 
 + public void testNotificationsTwoLoopers ( ) { 
 + final AtomicInteger counter = new AtomicInteger ( 0 ) ; 
 + final Queue < Handler > handlers = new ConcurrentLinkedQueue < Handler > ( ) ; 
 + 
 + Thread listenerThread = new Thread ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 + realm . addChangeListener ( new RealmChangeListener ( ) { 
 + @ Override 
 + public void onChange ( ) { 
 + counter . incrementAndGet ( ) ; 
 + Looper . myLooper ( ) . quit ( ) ; 
 + } 
 + } ) ; 
 + Looper . loop ( ) ; 
 + } 
 + } ; 
 + listenerThread . start ( ) ; 
 + 
 + Thread writerThread = new Thread ( ) { 
 + 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 + realm . addChangeListener ( new RealmChangeListener ( ) { 
 + @ Override 
 + public void onChange ( ) { 
 + counter . incrementAndGet ( ) ; 
 + } 
 + } ) ; 
 + Handler handler = new Handler ( ) ; 
 + handlers . add ( handler ) ; 
 + Looper . loop ( ) ; 
 + } 
 + } ; 
 + writerThread . start ( ) ; 
 + while ( handlers . isEmpty ( ) ) { 
 + try { 
 + Thread . sleep ( 10 ) ; 
 + } catch ( InterruptedException e ) { 
 + fail ( ) ; 
 + } 
 + } 
 + Handler handler = handlers . poll ( ) ; 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 + realm . beginTransaction ( ) ; 
 + Dog dog = realm . createObject ( Dog . class ) ; 
 + dog . setName ( " Rex " ) ; 
 + realm . commitTransaction ( ) ; 
 + Looper . myLooper ( ) . quit ( ) ; 
 + } 
 + } ) ; 
 + 
 try { 
 - Thread . sleep ( 500 ) ; 
 + writerThread . join ( ) ; 
 + listenerThread . join ( 2000 ) ; 
 } catch ( InterruptedException e ) { 
 fail ( ) ; 
 } 
 
 - assertEquals ( 0 , looperThread . exceptions . size ( ) ) ; 
 + assertEquals ( 2 , counter . get ( ) ) ; 
 } 
 } 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 index 1762f78 . . 37cac50 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 @ @ - 40 , 11 + 40 , 13 @ @ public class RealmResultsTest extends AndroidTestCase { 
 
 @ Override 
 protected void setUp ( ) throws InterruptedException { 
 - Realm . deleteRealmFile ( getContext ( ) ) ; 
 + boolean result = Realm . deleteRealmFile ( getContext ( ) ) ; 
 + if ( ! result ) { 
 + fail ( ) ; 
 + } 
 testRealm = Realm . getInstance ( getContext ( ) ) ; 
 
 testRealm . beginTransaction ( ) ; 
 - 
 testRealm . allObjects ( AllTypes . class ) . clear ( ) ; 
 
 for ( int i = 0 ; i < TEST _ DATA _ SIZE ; + + i ) { 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index 2b5dbf0 . . 380cb62 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import java . util . Arrays ; 
 import java . util . HashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 + import java . util . concurrent . ConcurrentHashMap ; 
 
 import io . realm . exceptions . RealmException ; 
 import io . realm . exceptions . RealmIOException ; 
 @ @ - 40 , 7 + 41 , 6 @ @ import io . realm . internal . ImplicitTransaction ; 
 import io . realm . internal . Row ; 
 import io . realm . internal . SharedGroup ; 
 import io . realm . internal . Table ; 
 - import io . realm . internal . android . LooperThread ; 
 
 
 / * * 
 @ @ - 65 , 13 + 65 , 15 @ @ public class Realm { 
 return new HashMap < String , Realm > ( ) ; 
 } 
 } ; 
 + private static final int REALM _ CHANGED = 14930352 ; / / Just a nice big Fibonacci number . For no reason : ) 
 + private static final Map < Handler , Integer > handlers = new ConcurrentHashMap < Handler , Integer > ( ) ; 
 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 private static SharedGroup . Durability defaultDurability = SharedGroup . Durability . FULL ; 
 - private static boolean autoRefresh = true ; 
 + private boolean autoRefresh ; 
 + private Handler handler ; 
 
 private final int id ; 
 - private final LooperThread looperThread = LooperThread . getInstance ( ) ; 
 private final SharedGroup sharedGroup ; 
 private final ImplicitTransaction transaction ; 
 private final Map < Class < ? > , String > simpleClassNames = new HashMap < Class < ? > , String > ( ) ; 
 @ @ - 83 , 38 + 85 , 15 @ @ public class Realm { 
 private final Map < Class < ? > , Table > tables = new HashMap < Class < ? > , Table > ( ) ; 
 private static final long UNVERSIONED = - 1 ; 
 
 - private Handler handler ; 
 - 
 / / Package protected to be reachable by proxy classes 
 static final Map < String , Map < String , Long > > columnIndices = new HashMap < String , Map < String , Long > > ( ) ; 
 
 / / The constructor in private to enforce the use of the static one 
 - private Realm ( String absolutePath , byte [ ] key ) { 
 + private Realm ( String absolutePath , byte [ ] key , boolean autoRefresh ) { 
 this . sharedGroup = new SharedGroup ( absolutePath , true , key ) ; 
 this . transaction = sharedGroup . beginImplicitTransaction ( ) ; 
 this . id = absolutePath . hashCode ( ) ; 
 - if ( ! looperThread . isAlive ( ) ) { 
 - looperThread . start ( ) ; 
 - } 
 - 
 - if ( Looper . myLooper ( ) = = null ) { 
 - Looper . prepare ( ) ; 
 - } 
 - handler = new Handler ( ) { 
 - @ Override 
 - public void handleMessage ( Message message ) { 
 - if ( message . what = = LooperThread . REALM _ CHANGED ) { 
 - if ( autoRefresh ) { 
 - transaction . advanceRead ( ) ; 
 - } 
 - sendNotifications ( ) ; 
 - } 
 - } 
 - } ; 
 - if ( Looper . myLooper ( ) = = null ) { 
 - Looper . loop ( ) ; 
 - } 
 - LooperThread . handlers . put ( handler , id ) ; 
 + setAutoRefresh ( autoRefresh ) ; 
 } 
 
 @ Override 
 @ @ - 123 , 10 + 102 , 42 @ @ public class Realm { 
 super . finalize ( ) ; 
 } 
 
 - / / public static void setDefaultDurability ( SharedGroup . Durability durability ) { 
 + private class RealmCallback implements Handler . Callback { 
 + @ Override 
 + public boolean handleMessage ( Message message ) { 
 + if ( message . what = = REALM _ CHANGED ) { 
 + transaction . advanceRead ( ) ; 
 + sendNotifications ( ) ; 
 + } 
 + return true ; 
 + } 
 + } 
 + 
 + @ SuppressWarnings ( " UnusedDeclaration " ) 
 + public boolean isAutoRefresh ( ) { 
 + return autoRefresh ; 
 + } 
 + 
 + public void setAutoRefresh ( boolean autoRefresh ) { 
 + if ( autoRefresh & & Looper . myLooper ( ) = = null ) { 
 + throw new IllegalStateException ( " Cannot set auto - refresh in a Thread without a Looper " ) ; 
 + } 
 + 
 + if ( autoRefresh & & ! this . autoRefresh ) { / / Switch it on 
 + handler = new Handler ( new RealmCallback ( ) ) ; 
 + handlers . put ( handler , id ) ; 
 + } else if ( ! autoRefresh & & this . autoRefresh & & handler ! = null ) { / / Switch it off 
 + handler . removeCallbacksAndMessages ( null ) ; 
 + handlers . remove ( handler ) ; 
 + } 
 + this . autoRefresh = autoRefresh ; 
 + } 
 + 
 + / / public static void setDefaultDurability ( SharedGroup . Durability durability ) { 
 / / defaultDurability = durability ; 
 / / } 
 
 + / / Public because of migrations 
 public Table getTable ( Class < ? > clazz ) { 
 String simpleClassName = simpleClassNames . get ( clazz ) ; 
 if ( simpleClassName = = null ) { 
 @ @ - 147 , 7 + 158 , 24 @ @ public class Realm { 
 * @ throws RealmException Other errors 
 * / 
 public static Realm getInstance ( Context context ) { 
 - return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , null ) ; 
 + return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , null , true ) ; 
 + } 
 + 
 + / * * 
 + * Realm static constructor for the default realm " default . realm " 
 + * 
 + * @ param context an Android context 
 + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) 
 + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) 
 + * @ return an instance of the Realm class 
 + * @ throws RealmMigrationNeededException The model classes have been changed and the Realm 
 + * must be migrated 
 + * @ throws RealmIOException Error when accessing underlying file 
 + * @ throws RealmException Other errors 
 + * / 
 + @ SuppressWarnings ( " UnusedDeclaration " ) 
 + public static Realm getInstance ( Context context , boolean autoRefresh ) { 
 + return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , null , autoRefresh ) ; 
 } 
 
 / * * 
 @ @ - 163 , 7 + 191 , 43 @ @ public class Realm { 
 * / 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 public static Realm getInstance ( Context context , String fileName ) { 
 - return Realm . create ( context . getFilesDir ( ) , fileName , null ) ; 
 + return Realm . create ( context . getFilesDir ( ) , fileName , null , true ) ; 
 + } 
 + 
 + / * * 
 + * Realm static constructor 
 + * 
 + * @ param context an Android context 
 + * @ param fileName the name of the file to save the Realm to 
 + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) 
 + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) 
 + * @ return an instance of the Realm class 
 + * @ throws RealmMigrationNeededException The model classes have been changed and the Realm 
 + * must be migrated 
 + * @ throws RealmIOException Error when accessing underlying file 
 + * @ throws RealmException Other errors 
 + * / 
 + @ SuppressWarnings ( " UnusedDeclaration " ) 
 + public static Realm getInstance ( Context context , String fileName , boolean autoRefresh ) { 
 + return Realm . create ( context . getFilesDir ( ) , fileName , null , autoRefresh ) ; 
 + } 
 + 
 + / * * 
 + * Realm static constructor 
 + * 
 + * @ param context an Android context 
 + * @ param key a 32 - byte encryption key 
 + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) 
 + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) 
 + * @ return an instance of the Realm class 
 + * @ throws RealmMigrationNeededException The model classes have been changed and the Realm 
 + * must be migrated 
 + * @ throws RealmIOException Error when accessing underlying file 
 + * @ throws RealmException Other errors 
 + * / 
 + @ SuppressWarnings ( " UnusedDeclaration " ) 
 + public static Realm getInstance ( Context context , byte [ ] key , boolean autoRefresh ) { 
 + return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , key , autoRefresh ) ; 
 } 
 
 / * * 
 @ @ - 179 , 23 + 243 , 27 @ @ public class Realm { 
 * / 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 public static Realm getInstance ( Context context , byte [ ] key ) { 
 - return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , key ) ; 
 + return Realm . getInstance ( context , DEFAULT _ REALM _ NAME , key , true ) ; 
 } 
 
 + 
 + 
 / * * 
 * Realm static constructor 
 * 
 * @ param context an Android context 
 * @ param fileName the name of the file to save the Realm to 
 * @ param key a 32 - byte encryption key 
 + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) 
 + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) 
 * @ return an instance of the Realm class 
 * @ throws RealmMigrationNeededException The model classes have been changed and the Realm 
 * must be migrated 
 * @ throws RealmIOException Error when accessing underlying file 
 * @ throws RealmException Other errors 
 * / 
 - public static Realm getInstance ( Context context , String fileName , byte [ ] key ) { 
 - return Realm . create ( context . getFilesDir ( ) , fileName , key ) ; 
 + public static Realm getInstance ( Context context , String fileName , byte [ ] key , boolean autoRefresh ) { 
 + return Realm . create ( context . getFilesDir ( ) , fileName , key , autoRefresh ) ; 
 } 
 
 / * * 
 @ @ - 203 , 6 + 271 , 8 @ @ public class Realm { 
 * 
 * @ param writableFolder absolute path to a writable directory 
 * @ param key a 32 - byte encryption key 
 + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) 
 + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) 
 * @ return an instance of the Realm class 
 * @ throws RealmMigrationNeededException The model classes have been changed and the Realm 
 * must be migrated 
 @ @ - 210 , 8 + 280 , 8 @ @ public class Realm { 
 * @ throws RealmException Other errors 
 * / 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 - public static Realm getInstance ( File writableFolder , byte [ ] key ) { 
 - return Realm . create ( writableFolder , DEFAULT _ REALM _ NAME , key ) ; 
 + public static Realm getInstance ( File writableFolder , byte [ ] key , boolean autoRefresh ) { 
 + return Realm . create ( writableFolder , DEFAULT _ REALM _ NAME , key , autoRefresh ) ; 
 } 
 
 / * * 
 @ @ - 220 , 23 + 290 , 25 @ @ public class Realm { 
 * @ param writableFolder absolute path to a writable directory 
 * @ param filename the name of the file to save the Realm to 
 * @ param key a 32 - byte encryption key 
 + * @ param autoRefresh whether the Realm object and its derived objects ( RealmResults and RealmObjects ) 
 + * should be automatically refreshed with the event loop ( requires to be in a thread with a Looper ) 
 * @ return an instance of the Realm class 
 * @ throws RealmMigrationNeededException The model classes have been changed and the Realm 
 * must be migrated 
 * @ throws RealmIOException Error when accessing underlying file 
 * @ throws RealmException Other errors 
 * / 
 - public static Realm create ( File writableFolder , String filename , byte [ ] key ) { 
 + public static Realm create ( File writableFolder , String filename , byte [ ] key , boolean autoRefresh ) { 
 String absolutePath = new File ( writableFolder , filename ) . getAbsolutePath ( ) ; 
 - return createAndValidate ( absolutePath , key , true ) ; 
 + return createAndValidate ( absolutePath , key , true , autoRefresh ) ; 
 } 
 
 - private static Realm createAndValidate ( String absolutePath , byte [ ] key , boolean validateSchema ) { 
 + private static Realm createAndValidate ( String absolutePath , byte [ ] key , boolean validateSchema , boolean autoRefresh ) { 
 Map < String , Realm > realms = realmsCache . get ( ) ; 
 Realm realm = realms . get ( absolutePath ) ; 
 
 if ( realm = = null ) { 
 - realm = new Realm ( absolutePath , key ) ; 
 + realm = new Realm ( absolutePath , key , autoRefresh ) ; 
 realms . put ( absolutePath , realm ) ; 
 realmsCache . set ( realms ) ; 
 } 
 @ @ - 517 , 7 + 589 , 6 @ @ public class Realm { 
 * / 
 public void addChangeListener ( RealmChangeListener listener ) { 
 changeListeners . add ( listener ) ; 
 - LooperThread . handlers . put ( handler , id ) ; 
 } 
 
 / * * 
 @ @ - 528 , 9 + 599 , 6 @ @ public class Realm { 
 * / 
 public void removeChangeListener ( RealmChangeListener listener ) { 
 changeListeners . remove ( listener ) ; 
 - if ( changeListeners . isEmpty ( ) ) { 
 - LooperThread . handlers . remove ( handler ) ; 
 - } 
 } 
 
 / * * 
 @ @ - 540 , 7 + 608 , 6 @ @ public class Realm { 
 * / 
 public void removeAllChangeListeners ( ) { 
 changeListeners . clear ( ) ; 
 - LooperThread . handlers . remove ( handler ) ; 
 } 
 
 void sendNotifications ( ) { 
 @ @ - 558 , 9 + 625 , 13 @ @ public class Realm { 
 * Transactions 
 * / 
 
 - / / public void refresh ( ) { 
 - / / transaction . advanceRead ( ) ; 
 - / / } 
 + / * * 
 + * Refresh the Realm instance and all the RealmResults and RealmObjects instances coming from it 
 + * / 
 + @ SuppressWarnings ( " UnusedDeclaration " ) 
 + public void refresh ( ) { 
 + transaction . advanceRead ( ) ; 
 + } 
 
 / * * 
 * Starts a write transaction , this must be closed with commitTransaction ( ) or aborted 
 @ @ - 582 , 7 + 653 , 7 @ @ public class Realm { 
 
 / * * 
 * All changes since beginTransaction ( ) are persisted to disk and the realm reverts back to being read - only , 
 - * An event is sent to notify all other realm instances that a change has occured . 
 + * An event is sent to notify all other realm instances that a change has occurred . 
 * When the event is received , the other realms will get their objects and RealmResults updated to reflect 
 * the changes from this commit . 
 * 
 @ @ - 591 , 13 + 662 , 16 @ @ public class Realm { 
 public void commitTransaction ( ) { 
 transaction . commitAndContinueAsRead ( ) ; 
 
 - Message message = Message . obtain ( ) ; 
 - message . arg1 = LooperThread . REALM _ CHANGED ; 
 - message . arg2 = id ; 
 - if ( looperThread . handler ! = null ) { 
 - looperThread . handler . sendMessage ( message ) ; 
 - } else { 
 - Log . i ( TAG , " The LooperThread is not up and running yet . Commit message not sent " ) ; 
 + for ( Map . Entry < Handler , Integer > handlerIntegerEntry : handlers . entrySet ( ) ) { 
 + Handler handler = handlerIntegerEntry . getKey ( ) ; 
 + int realmId = handlerIntegerEntry . getValue ( ) ; 
 + if ( 
 + realmId = = id / / It ' s the right realm 
 + & & ! handler . hasMessages ( REALM _ CHANGED ) / / The right message 
 + & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) / / The receiving thread is alive 
 + ) { 
 + handler . sendEmptyMessage ( REALM _ CHANGED ) ; 
 + } 
 } 
 } 
 
 @ @ - 645 , 18 + 719 , 19 @ @ public class Realm { 
 metadataTable . setLong ( 0 , 0 , version ) ; 
 } 
 
 - static public void migrateRealmAtPath ( String realmPath , RealmMigration migration ) { 
 - migrateRealmAtPath ( realmPath , null , migration ) ; 
 + @ SuppressWarnings ( " UnusedDeclaration " ) 
 + static public void migrateRealmAtPath ( String realmPath , RealmMigration migration , boolean autoRefresh ) { 
 + migrateRealmAtPath ( realmPath , null , migration , autoRefresh ) ; 
 } 
 
 - static public void migrateRealmAtPath ( String realmPath , byte [ ] key , RealmMigration migration ) { 
 - Realm realm = Realm . createAndValidate ( realmPath , key , false ) ; 
 + static public void migrateRealmAtPath ( String realmPath , byte [ ] key , RealmMigration migration , boolean autoUpdate ) { 
 + Realm realm = Realm . createAndValidate ( realmPath , key , false , autoUpdate ) ; 
 realm . beginTransaction ( ) ; 
 realm . setVersion ( migration . execute ( realm , realm . getVersion ( ) ) ) ; 
 realm . commitTransaction ( ) ; 
 
 Map < String , Realm > realms = realmsCache . get ( ) ; 
 - realms . put ( realmPath , new Realm ( realmPath , key ) ) ; 
 + realms . put ( realmPath , new Realm ( realmPath , key , autoUpdate ) ) ; 
 realmsCache . set ( realms ) ; 
 } 
 
 diff - - git a / realm / src / main / java / io / realm / internal / android / LooperThread . java b / realm / src / main / java / io / realm / internal / android / LooperThread . java 
 deleted file mode 100644 
 index 7edd0d1 . . 0000000 
 - - - a / realm / src / main / java / io / realm / internal / android / LooperThread . java 
 + + + / dev / null 
 @ @ - 1 , 87 + 0 , 0 @ @ 
 - / * 
 - * Copyright 2014 Realm Inc . 
 - * 
 - * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 - * you may not use this file except in compliance with the License . 
 - * You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package io . realm . internal . android ; 
 - 
 - import android . os . Handler ; 
 - import android . os . Looper ; 
 - import android . os . Message ; 
 - import android . util . Log ; 
 - 
 - import java . util . ArrayList ; 
 - import java . util . List ; 
 - import java . util . Map ; 
 - import java . util . concurrent . ConcurrentHashMap ; 
 - 
 - / * * 
 - * This thread continuously receives and dispatches messages regarding changes in realms . 
 - * / 
 - public class LooperThread extends Thread { 
 - / / Message types 
 - public static final int REALM _ CHANGED = 3 ; 
 - public static final Map < Handler , Integer > handlers = new ConcurrentHashMap < Handler , Integer > ( ) ; 
 - 
 - public Handler handler ; 
 - public List < RuntimeException > exceptions = new ArrayList < RuntimeException > ( ) ; 
 - 
 - private static final String TAG = LooperThread . class . getName ( ) ; 
 - private static LooperThread instance ; 
 - 
 - / / private because it ' s a singleton 
 - private LooperThread ( ) { } 
 - 
 - / / thread safe static constructor 
 - public static LooperThread getInstance ( ) { 
 - if ( instance = = null ) { 
 - synchronized ( LooperThread . class ) { 
 - if ( instance = = null ) { 
 - instance = new LooperThread ( ) ; 
 - } 
 - } 
 - } 
 - return instance ; 
 - } 
 - 
 - @ Override 
 - public void run ( ) { 
 - Looper . prepare ( ) ; 
 - 
 - handler = new Handler ( ) { 
 - @ Override 
 - public void handleMessage ( Message message ) { 
 - if ( message . arg1 = = REALM _ CHANGED ) { 
 - for ( Map . Entry < Handler , Integer > entry : handlers . entrySet ( ) ) { 
 - if ( entry . getValue ( ) = = message . arg2 ) { 
 - Handler currentHandler = entry . getKey ( ) ; 
 - if ( currentHandler . getLooper ( ) . getThread ( ) . isAlive ( ) & & 
 - ! currentHandler . hasMessages ( REALM _ CHANGED ) ) 
 - { 
 - try { 
 - currentHandler . sendEmptyMessage ( REALM _ CHANGED ) ; 
 - } catch ( RuntimeException e ) { 
 - exceptions . add ( e ) ; 
 - Log . w ( TAG , e . getMessage ( ) ) ; 
 - } 
 - } 
 - } 
 - } 
 - } 
 - } 
 - } ; 
 - 
 - Looper . loop ( ) ; 
 - } 
 - }
