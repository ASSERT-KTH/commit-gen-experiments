BLEU SCORE: 0.005774363155184915

TEST MSG: Better error handling
GENERATED MSG: POC async query , using Core ' fsa _ handover _ demo ' branch

TEST DIFF (one line): diff - - git a / examples / objectServerExample / src / main / java / io / realm / examples / objectserver / LoginActivity . java b / examples / objectServerExample / src / main / java / io / realm / examples / objectserver / LoginActivity . java <nl> index bd32a9b . . 5c92889 100644 <nl> - - - a / examples / objectServerExample / src / main / java / io / realm / examples / objectserver / LoginActivity . java <nl> + + + b / examples / objectServerExample / src / main / java / io / realm / examples / objectserver / LoginActivity . java <nl> @ @ - 31 , 6 + 31 , 8 @ @ import io . realm . objectserver . ObjectServerError ; <nl> import io . realm . objectserver . User ; <nl> import io . realm . objectserver . UserStore ; <nl> <nl> + import static io . realm . objectserver . ErrorCode . UNKNOWN _ ACCOUNT ; <nl> + <nl> public class LoginActivity extends AppCompatActivity { <nl> <nl> private UserStore userStore = MyApplication . USER _ STORE ; <nl> @ @ - 91 , 7 + 93 , 7 @ @ public class LoginActivity extends AppCompatActivity { <nl> public void onError ( ObjectServerError error ) { <nl> progressDialog . dismiss ( ) ; <nl> String errorMsg ; <nl> - switch ( error . errorCode ( ) ) { <nl> + switch ( error . getErrorCode ( ) ) { <nl> case UNKNOWN _ ACCOUNT : <nl> errorMsg = " Account does not exists . " ; <nl> break ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / ErrorCode . java b / realm / realm - library / src / main / java / io / realm / objectserver / ErrorCode . java <nl> index ac857cc . . 326c717 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / objectserver / ErrorCode . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / objectserver / ErrorCode . java <nl> @ @ - 16 , 31 + 16 , 30 @ @ <nl> <nl> package io . realm . objectserver ; <nl> <nl> + / * * <nl> + * This class enumerate all potential errors related to using the Object Server or synchronizing data . <nl> + * / <nl> public enum ErrorCode { <nl> <nl> - / / See https : / / github . com / realm / realm - sync / issues / 585 <nl> / / See https : / / github . com / realm / realm - sync / blob / master / doc / protocol . md <nl> <nl> / / Realm Java errors ( 0 - 49 ) <nl> - <nl> UNKNOWN ( - 1 ) , / / Catch - all <nl> IO _ EXCEPTION ( 0 , Category . RECOVERABLE ) , / / Some IO error while either contacting the server or reading the response <nl> JSON _ EXCEPTION ( 1 ) , / / JSON input could not be parsed correctly <nl> <nl> / / Realm Object Server errors ( 100 - 199 ) <nl> - <nl> - / / Connection level and protocol errors <nl> - <nl> - CONNECTION _ CLOSED ( 100 , Category . INFO ) , / / Connection closed ( no error ) <nl> - OTHER _ ERROR ( 101 , Category . INFO ) , / / Other connection level error <nl> - UNKNOWN _ MESSAGE ( 102 , Category . INFO ) , / / Unknown type of input message <nl> - BAD _ SYNTAX ( 103 , Category . INFO ) , / / Bad syntax in input message head <nl> - LIMITS _ EXCEEDED ( 104 , Category . INFO ) , / / Limits exceeded in input message <nl> - WRONG _ PROTOCOL _ VERSION ( 105 , Category . INFO ) , / / Wrong protocol version ( CLIENT ) <nl> - BAD _ SESSION _ IDENT ( 106 , Category . INFO ) , / / Bad session identifier in input message <nl> - REUSE _ OF _ SESSION _ IDENT ( 107 , Category . INFO ) , / / Overlapping reuse of session identifier ( BIND ) <nl> - BOUND _ IN _ OTHER _ SESSION ( 108 , Category . INFO ) , / / Client file bound in other session ( IDENT ) <nl> - BAD _ MESSAGE _ ORDER ( 109 , Category . INFO ) , / / Bad input message order <nl> + / / Connection level and protocol errors . <nl> + CONNECTION _ CLOSED ( 100 ) , / / Connection closed ( no error ) <nl> + OTHER _ ERROR ( 101 ) , / / Other connection level error <nl> + UNKNOWN _ MESSAGE ( 102 ) , / / Unknown type of input message <nl> + BAD _ SYNTAX ( 103 ) , / / Bad syntax in input message head <nl> + LIMITS _ EXCEEDED ( 104 ) , / / Limits exceeded in input message <nl> + WRONG _ PROTOCOL _ VERSION ( 105 ) , / / Wrong protocol version ( CLIENT ) <nl> + BAD _ SESSION _ IDENT ( 106 ) , / / Bad session identifier in input message <nl> + REUSE _ OF _ SESSION _ IDENT ( 107 ) , / / Overlapping reuse of session identifier ( BIND ) <nl> + BOUND _ IN _ OTHER _ SESSION ( 108 ) , / / Client file bound in other session ( IDENT ) <nl> + BAD _ MESSAGE _ ORDER ( 109 ) , / / Bad input message order <nl> <nl> / / Session level errors ( 200 - 299 ) <nl> SESSION _ CLOSED ( 200 , Category . RECOVERABLE ) , / / Session closed ( no error ) <nl> @ @ - 53 , 7 + 52 , 7 @ @ public enum ErrorCode { <nl> NO _ SUCH _ PATH ( 205 ) , / / No such Realm ( BIND ) <nl> PERMISSION _ DENIED ( 206 ) , / / Permission denied ( BIND , REFRESH ) <nl> <nl> - / / Fatal : Wrong server / client versions . Trying to sync incompatible files or corrupted . <nl> + / / Fatal : Wrong server / client versions . Trying to sync incompatible files or the file was corrupted . <nl> BAD _ SERVER _ FILE _ IDENT ( 207 ) , / / Bad server file identifier ( IDENT ) <nl> BAD _ CLIENT _ FILE _ IDENT ( 208 ) , / / Bad client file identifier ( IDENT ) <nl> BAD _ SERVER _ VERSION ( 209 ) , / / Bad server version ( IDENT , UPLOAD ) <nl> @ @ - 61 , 10 + 60 , 9 @ @ public enum ErrorCode { <nl> DIVERGING _ HISTORIES ( 211 ) , / / Diverging histories ( IDENT ) <nl> BAD _ CHANGESET ( 212 ) , / / Bad changeset ( UPLOAD ) <nl> <nl> - / / 300 - 599 Standard HTTP error codes <nl> + / / 300 - 599 Reserved for Standard HTTP error codes <nl> <nl> / / Realm Authentication Server response errors ( 600 - 699 ) <nl> - <nl> INVALID _ PARAMETERS ( 601 ) , <nl> MISSING _ PARAMETERS ( 602 ) , <nl> INVALID _ CREDENTIALS ( 611 ) , <nl> @ @ - 90 , 23 + 88 , 27 @ @ public enum ErrorCode { <nl> return super . toString ( ) + " ( " + code + " ) " ; <nl> } <nl> <nl> - public int errorCode ( ) { <nl> + / * * <nl> + * Returns the numerical value for this error code . <nl> + * <nl> + * @ return the error code as an unique { @ code int } value . <nl> + * / <nl> + public int intValue ( ) { <nl> return code ; <nl> } <nl> <nl> - <nl> / * * <nl> - * Returns the category of the error . <nl> + * Returns the getCategory of the error . <nl> * < p > <nl> - * Errors come in 3 categories : FATAL , RECOVERABLE , and INFO . <nl> + * Errors come in 2 categories : FATAL , RECOVERABLE <nl> * < p > <nl> * FATAL : The session cannot be recovered and needs to be re - created . A likely cause is that the User does not <nl> - * have access to this Realm . Check that the { @ link SyncConfiguration } is correct . <nl> + * have access to this Realm . Check that the { @ link SyncConfiguration } is correct . Any fatal error will cause <nl> + * the session to be become { @ link SessionState # STOPPED } . <nl> * < p > <nl> - * RECOVERABLE : The session is paused until given additional information . Most likely cause is an expired access <nl> - * token or similar . <nl> + * RECOVERABLE : Temporary error . The session becomes { @ link SessionState # UNBOUND } , but will automatically try to <nl> + * recover as soon as possible . <nl> * < p > <nl> - * INFO : The underlying sync client will automatically try to recover from this . <nl> * <nl> * @ return the severity of the error . <nl> * / <nl> @ @ - 118 , 7 + 120 , 7 @ @ public enum ErrorCode { <nl> ErrorCode [ ] errorCodes = values ( ) ; <nl> for ( int i = 0 ; i < errorCodes . length ; i + + ) { <nl> ErrorCode error = errorCodes [ i ] ; <nl> - if ( error . errorCode ( ) = = errorCode ) { <nl> + if ( error . intValue ( ) = = errorCode ) { <nl> return error ; <nl> } <nl> } <nl> @ @ - 127 , 7 + 129 , 6 @ @ public enum ErrorCode { <nl> <nl> public enum Category { <nl> FATAL , / / Abort session as soon as possible <nl> - RECOVERABLE , / / Still possible to recover the session by either rebinding or providing the required information . <nl> - INFO / / Just FYI . The underlying network client will automatically try to recover . <nl> + RECOVERABLE / / Still possible to recover the session by either rebinding or providing the required information . <nl> } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / ObjectServerError . java b / realm / realm - library / src / main / java / io / realm / objectserver / ObjectServerError . java <nl> index f66ef6f . . 27f0618 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / objectserver / ObjectServerError . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / objectserver / ObjectServerError . java <nl> @ @ - 22 , 9 + 22 , 9 @ @ import io . realm . internal . Util ; <nl> * This class is a wrapper for all errors happening when communicating with the Realm Object Server . <nl> * This include both exceptions and protocol errors . <nl> * <nl> - * Only { @ link # errorCode ( ) } is guaranteed to be set . If the error was caused by an underlying exception <nl> - * { @ link # errorMessage ( ) } is { @ code null } and { @ link # exception ( ) } is set , while if the error was a protocol error <nl> - * { @ link # errorMessage ( ) } is set and { @ link # exception ( ) } is null . <nl> + * Only { @ link # getErrorCode ( ) } is guaranteed to contain a value . If the error was caused by an underlying exception <nl> + * { @ link # getErrorMessage ( ) } is { @ code null } and { @ link # getException ( ) } is set , while if the error was a protocol error <nl> + * { @ link # getErrorMessage ( ) } is set and { @ link # getException ( ) } is null . <nl> * <nl> * @ see io . realm . objectserver . ErrorCode for a list of possible errors . <nl> * / <nl> @ @ - 34 , 10 + 34 , 22 @ @ public class ObjectServerError extends RuntimeException { <nl> private final String errorMessage ; <nl> private final Throwable exception ; <nl> <nl> + / * * <nl> + * Create an error caused by an error in the protocol when communicating with the Object Server . <nl> + * <nl> + * @ param errorCode error code for this type of error . <nl> + * @ param errorMessage detailed error message . <nl> + * / <nl> public ObjectServerError ( ErrorCode errorCode , String errorMessage ) { <nl> - this ( errorCode , errorMessage , null ) ; <nl> + this ( errorCode , errorMessage , ( Throwable ) null ) ; <nl> } <nl> <nl> + / * * <nl> + * Create an error caused by an an exception when communicating with the Object Server . <nl> + * <nl> + * @ param errorCode error code for this type of error . <nl> + * @ param exception underlying exception causing this error . <nl> + * / <nl> public ObjectServerError ( ErrorCode errorCode , Throwable exception ) { <nl> this ( errorCode , null , exception ) ; <nl> } <nl> @ @ - 45 , 9 + 57 , 9 @ @ public class ObjectServerError extends RuntimeException { <nl> / * * <nl> * Generic error happening that could happen anywhere . <nl> * <nl> - * @ param errorCode <nl> - * @ param errorMessage <nl> - * @ param exception <nl> + * @ param errorCode error code for this type of error . <nl> + * @ param errorMessage detailed error message . <nl> + * @ param exception underlying exception if the error was caused by this . <nl> * / <nl> public ObjectServerError ( ErrorCode errorCode , String errorMessage , Throwable exception ) { <nl> this . error = errorCode ; <nl> @ @ - 58 , 34 + 70 , 57 @ @ public class ObjectServerError extends RuntimeException { <nl> / * * <nl> * Errors happening while trying to authenticate a user . <nl> * <nl> - * @ param errorCode <nl> - * @ param title <nl> - * @ param hint <nl> - * @ param type <nl> + * @ param errorCode error code for this type of error . <nl> + * @ param title Title for this type of error . <nl> + * @ param hint a hint for resolving the error . <nl> * / <nl> - public ObjectServerError ( ErrorCode errorCode , String title , String hint , String type ) { <nl> - this ( errorCode , String . format ( " % s : % s ( % s ) " , title , hint , type ) , null ) ; <nl> + public ObjectServerError ( ErrorCode errorCode , String title , String hint ) { <nl> + this ( errorCode , ( hint ! = null ) ? title + " : " + hint : title , ( Throwable ) null ) ; <nl> } <nl> <nl> - public ErrorCode errorCode ( ) { <nl> + / * * <nl> + * Returns the error code uniquely identifying this type of error . <nl> + * <nl> + * @ return the error code identifying the type of error . <nl> + * @ see ErrorCode <nl> + * / <nl> + public ErrorCode getErrorCode ( ) { <nl> return error ; <nl> } <nl> <nl> - public String errorMessage ( ) { <nl> + / * * <nl> + * Returns a more detailed error message about the cause of this error . <nl> + * <nl> + * @ return a detailed error message or { @ code null } if one was not available . <nl> + * / <nl> + public String getErrorMessage ( ) { <nl> return errorMessage ; <nl> } <nl> <nl> - public Throwable exception ( ) { <nl> + / * * <nl> + * Returns the underlying exception causing this error , if any . <nl> + * <nl> + * @ return the underlying exception causing this error , or { @ code null } if not caused by an exception . <nl> + * / <nl> + public Throwable getException ( ) { <nl> return exception ; <nl> } <nl> <nl> - public ErrorCode . Category category ( ) { <nl> + / * * <nl> + * Returns the { @ link io . realm . objectserver . ErrorCode . Category } category for this error . <nl> + * Errors that are { @ link io . realm . objectserver . ErrorCode . Category # RECOVERABLE } mean that it is still possible for a <nl> + * given { @ link Session } to resume synchronization . { @ link io . realm . objectserver . ErrorCode . Category # FATAL } errors <nl> + * means that session has stopped and cannot be recovered . <nl> + * <nl> + * @ return the error category . <nl> + * / <nl> + public ErrorCode . Category getCategory ( ) { <nl> return error . getCategory ( ) ; <nl> } <nl> <nl> @ Override <nl> public String toString ( ) { <nl> - StringBuilder sb = new StringBuilder ( errorCode ( ) . toString ( ) ) ; <nl> + StringBuilder sb = new StringBuilder ( getErrorCode ( ) . toString ( ) ) ; <nl> if ( errorMessage ! = null ) { <nl> sb . append ( ' \ n ' ) ; <nl> sb . append ( errorMessage ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / SyncManager . java b / realm / realm - library / src / main / java / io / realm / objectserver / SyncManager . java <nl> index e068cec . . 917e98c 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / objectserver / SyncManager . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / objectserver / SyncManager . java <nl> @ @ - 50 , 16 + 50 , 13 @ @ public final class SyncManager { <nl> String errorMsg = String . format ( " Session Error [ % s ] : % s " , <nl> session . getConfiguration ( ) . getServerUrl ( ) , <nl> error . toString ( ) ) ; <nl> - switch ( error . errorCode ( ) . getCategory ( ) ) { <nl> + switch ( error . getErrorCode ( ) . getCategory ( ) ) { <nl> case FATAL : <nl> RealmLog . error ( errorMsg ) ; <nl> break ; <nl> case RECOVERABLE : <nl> RealmLog . info ( errorMsg ) ; <nl> break ; <nl> - case INFO : <nl> - RealmLog . debug ( errorMsg ) ; <nl> - break ; <nl> } <nl> } <nl> } ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / AuthenticatingState . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / AuthenticatingState . java <nl> index 0ac116e . . a52d2f3 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / AuthenticatingState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / AuthenticatingState . java <nl> @ @ - 79 , 21 + 79 , 6 @ @ class AuthenticatingState extends FsmState { <nl> } <nl> } <nl> <nl> - private synchronized void authenticate ( final SyncSession session ) { <nl> - session . authenticateRealm ( new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - gotoNextState ( SessionState . BINDING ) ; <nl> - } <nl> - } , new io . realm . objectserver . Session . ErrorHandler ( ) { <nl> - @ Override <nl> - public void onError ( io . realm . objectserver . Session session , ObjectServerError error ) { <nl> - / / FIXME For critical errors , got directly to STOPPED <nl> - gotoNextState ( SessionState . UNBOUND ) ; <nl> - } <nl> - } ) ; <nl> - } <nl> - <nl> @ Override <nl> public void onBind ( ) { <nl> gotoNextState ( SessionState . BINDING ) ; / / Equivalent to forcing a retry <nl> @ @ - 108 , 4 + 93 , 18 @ @ class AuthenticatingState extends FsmState { <nl> public void onStop ( ) { <nl> gotoNextState ( SessionState . STOPPED ) ; <nl> } <nl> + <nl> + private synchronized void authenticate ( final SyncSession session ) { <nl> + session . authenticateRealm ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + gotoNextState ( SessionState . BINDING ) ; <nl> + } <nl> + } , new Session . ErrorHandler ( ) { <nl> + @ Override <nl> + public void onError ( Session s , ObjectServerError error ) { <nl> + session . onError ( error ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / BoundState . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / BoundState . java <nl> index 5eb347a . . d03632d 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / BoundState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / BoundState . java <nl> @ @ - 16 , 6 + 16 , 7 @ @ <nl> <nl> package io . realm . objectserver . internal ; <nl> <nl> + import io . realm . objectserver . ErrorCode ; <nl> import io . realm . objectserver . ObjectServerError ; <nl> import io . realm . objectserver . SessionState ; <nl> <nl> @ @ - 33 , 7 + 34 , 7 @ @ class BoundState extends FsmState { <nl> <nl> @ Override <nl> public void onExitState ( ) { <nl> - session . stopNativeSession ( ) ; <nl> + / / Do nothing . Entry states will stop the session if needed . <nl> } <nl> <nl> @ Override <nl> @ @ - 48 , 62 + 49 , 15 @ @ class BoundState extends FsmState { <nl> <nl> @ Override <nl> public void onError ( ObjectServerError error ) { <nl> - switch ( error . errorCode ( ) ) { <nl> - / / FIXME : Regenerate this <nl> - / / Auth protocol errors ( should not happen ) . <nl> - case IO _ EXCEPTION : <nl> - case JSON _ EXCEPTION : <nl> - case INVALID _ PARAMETERS : <nl> - case MISSING _ PARAMETERS : <nl> - case INVALID _ CREDENTIALS : <nl> - case UNKNOWN _ ACCOUNT : <nl> - case EXISTING _ ACCOUNT : <nl> - case ACCESS _ DENIED : <nl> - case EXPIRED _ REFRESH _ TOKEN : <nl> - throw new IllegalStateException ( " Authentication protocol errors should not happen : " + error . toString ( ) ) ; <nl> - <nl> - / / Ignore Network client errors ( irrelevant ) <nl> - / / FIXME : Not accurate : https : / / github . com / realm / realm - sync / issues / 659 How should these be handled ? <nl> - case CONNECTION _ CLOSED : <nl> - case OTHER _ ERROR : <nl> - case UNKNOWN _ MESSAGE : <nl> - case BAD _ SYNTAX : <nl> - case LIMITS _ EXCEEDED : <nl> - case WRONG _ PROTOCOL _ VERSION : <nl> - case BAD _ SESSION _ IDENT : <nl> - case REUSE _ OF _ SESSION _ IDENT : <nl> - case BOUND _ IN _ OTHER _ SESSION : <nl> - case BAD _ MESSAGE _ ORDER : <nl> - return ; <nl> - <nl> - / / Session errors : <nl> - / / FIXME : Which of these are just INFO and which can we actually do something about ? Right now treat all as fatal <nl> - case SESSION _ CLOSED : <nl> - case OTHER _ SESSION _ ERROR : <nl> - gotoNextState ( SessionState . STOPPED ) ; <nl> - break ; <nl> - <nl> - case TOKEN _ EXPIRED : <nl> - / / Only known case we can actually work around . <nl> - / / Trigger a rebind which will cause access token to be refreshed . <nl> - gotoNextState ( SessionState . BINDING ) ; <nl> - break ; <nl> - <nl> - case BAD _ AUTHENTICATION : <nl> - case ILLEGAL _ REALM _ PATH : <nl> - case NO _ SUCH _ PATH : <nl> - case PERMISSION _ DENIED : <nl> - case BAD _ SERVER _ FILE _ IDENT : <nl> - case BAD _ CLIENT _ FILE _ IDENT : <nl> - case BAD _ SERVER _ VERSION : <nl> - case BAD _ CLIENT _ VERSION : <nl> - case DIVERGING _ HISTORIES : <nl> - case BAD _ CHANGESET : <nl> - gotoNextState ( SessionState . STOPPED ) ; <nl> - break ; <nl> - <nl> - default : <nl> - throw new IllegalArgumentException ( " Unknown error code : " + error . errorCode ( ) ) ; <nl> + / / If a Realms access token has expired , trigger a rebind . If the user is still valid it will automatically <nl> + / / refresh it . <nl> + if ( error . getErrorCode ( ) = = ErrorCode . TOKEN _ EXPIRED ) { <nl> + gotoNextState ( SessionState . BINDING ) ; <nl> + } else { <nl> + switch ( error . getCategory ( ) ) { <nl> + case FATAL : gotoNextState ( SessionState . STOPPED ) ; break ; <nl> + case RECOVERABLE : gotoNextState ( SessionState . UNBOUND ) ; break ; <nl> + } <nl> } <nl> } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / FsmState . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / FsmState . java <nl> index 8460a58 . . 833e282 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / FsmState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / FsmState . java <nl> @ @ - 16 , 11 + 16 , 12 @ @ <nl> <nl> package io . realm . objectserver . internal ; <nl> <nl> - import io . realm . objectserver . * ; <nl> + import io . realm . objectserver . ObjectServerError ; <nl> + import io . realm . objectserver . SessionState ; <nl> <nl> / * * <nl> - * Abstract class containing shared logic for all { @ link io . realm . objectserver . Session } states . All states must extend this class as it <nl> - * contains the logic for entering and leaving states . <nl> + * Abstract class containing shared logic for all { @ link io . realm . objectserver . Session } states . All states must extend <nl> + * this class as it contains the logic for entering and leaving states . <nl> * <nl> * TODO Move this to the Object Store <nl> * / <nl> @ @ - 43 , 7 + 44 , 7 @ @ abstract class FsmState implements FsmAction { <nl> <nl> / * * <nl> * Called just before leaving the state . Once this method is called no more state changes can be triggered from <nl> - * this state until { @ link # entry ( io . realm . objectserver . Session ) } has been called again . <nl> + * this state until { @ link # entry ( SyncSession ) } has been called again . <nl> * < p > <nl> * This should only be called from { @ link io . realm . objectserver . Session } . <nl> * / <nl> @ @ - 83 , 6 + 84 , 13 @ @ abstract class FsmState implements FsmAction { <nl> <nl> @ Override <nl> public void onError ( ObjectServerError error ) { <nl> - gotoNextState ( SessionState . STOPPED ) ; <nl> + switch ( error . getCategory ( ) ) { <nl> + case FATAL : <nl> + gotoNextState ( SessionState . STOPPED ) ; <nl> + break ; <nl> + case RECOVERABLE : <nl> + gotoNextState ( SessionState . UNBOUND ) ; <nl> + break ; <nl> + } <nl> } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / SyncSession . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / SyncSession . java <nl> index 16ad250 . . 85db11b 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / SyncSession . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / SyncSession . java <nl> @ @ - 90 , 6 + 90 , 8 @ @ import io . realm . objectserver . internal . syncpolicy . SyncPolicy ; <nl> @ Keep <nl> public final class SyncSession { <nl> <nl> + private static final long MAX _ DELAY _ MS = TimeUnit . MINUTES . toMillis ( 5 ) ; <nl> + <nl> private final HashMap < SessionState , FsmState > FSM = new HashMap < SessionState , FsmState > ( ) ; <nl> <nl> / / Variables used by the FSM <nl> @ @ - 262 , 7 + 264 , 7 @ @ public final class SyncSession { <nl> ObjectServerError error = null ; <nl> while ( true ) { <nl> attempt + + ; <nl> - long sleep = Util . calculateExponentialDelay ( attempt - 1 , TimeUnit . MINUTES . toMillis ( 5 ) ) ; <nl> + long sleep = Util . calculateExponentialDelay ( attempt - 1 , MAX _ DELAY _ MS ) ; <nl> if ( sleep > 0 ) { <nl> try { <nl> Thread . sleep ( sleep ) ; <nl> @ @ - 285 , 7 + 287 , 7 @ @ public final class SyncSession { <nl> / / All other errors indicate a bigger problem , so stop trying to authenticate and <nl> / / unbind <nl> ObjectServerError responseError = response . getError ( ) ; <nl> - if ( responseError . errorCode ( ) ! = ErrorCode . IO _ EXCEPTION ) { <nl> + if ( responseError . getErrorCode ( ) ! = ErrorCode . IO _ EXCEPTION ) { <nl> success = false ; <nl> error = responseError ; <nl> break ; <nl> @ @ - 345 , 9 + 347 , 6 @ @ public final class SyncSession { <nl> } <nl> <nl> / * * <nl> - * FIXME : Find a way to keep this out of the public API . Could probably happen as part of moving everything to the <nl> - * Object Store . <nl> - * <nl> * Notify session that a commit on the device has happened . <nl> * / <nl> void notifyCommit ( long version ) { <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / network / AuthenticateResponse . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / network / AuthenticateResponse . java <nl> index 0416786 . . 0455ac4 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / network / AuthenticateResponse . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / network / AuthenticateResponse . java <nl> @ @ - 55 , 11 + 55 , 10 @ @ public class AuthenticateResponse { <nl> if ( response . code ( ) ! = 200 ) { <nl> try { <nl> JSONObject obj = new JSONObject ( serverResponse ) ; <nl> - String type = obj . getString ( " type " ) ; <nl> String hint = obj . optString ( " hint " , null ) ; <nl> String title = obj . optString ( " title " , null ) ; <nl> ErrorCode errorCode = ErrorCode . fromInt ( obj . optInt ( " code " , - 1 ) ) ; <nl> - ObjectServerError error = new ObjectServerError ( errorCode , title , hint , type ) ; <nl> + ObjectServerError error = new ObjectServerError ( errorCode , title , hint ) ; <nl> return new AuthenticateResponse ( error ) ; <nl> } catch ( JSONException e ) { <nl> ObjectServerError error = new ObjectServerError ( ErrorCode . JSON _ EXCEPTION , " Server failed with " + <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / syncpolicy / AutomaticSyncPolicy . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / syncpolicy / AutomaticSyncPolicy . java <nl> index eabb6b6 . . 5941452 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / syncpolicy / AutomaticSyncPolicy . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / syncpolicy / AutomaticSyncPolicy . java <nl> @ @ - 19 , 12 + 19 , 16 @ @ package io . realm . objectserver . internal . syncpolicy ; <nl> import io . realm . objectserver . ObjectServerError ; <nl> import io . realm . objectserver . internal . SyncSession ; <nl> <nl> + import static java . lang . System . currentTimeMillis ; <nl> + <nl> / * * <nl> * This SyncPolicy will automatically start synchronizing changes to a Realm as soon as it is opened . <nl> - * / / TODO Figure out how to close connection once all changes have been uploaded . <nl> * / <nl> public class AutomaticSyncPolicy implements SyncPolicy { <nl> <nl> + private Long lastError = null ; <nl> + private int recurringErrors = 0 ; <nl> + <nl> @ Override <nl> public void onRealmOpened ( SyncSession session ) { <nl> session . bind ( ) ; / / Bind Realm first time it is opened . <nl> @ @ - 32 , 8 + 36 , 8 @ @ public class AutomaticSyncPolicy implements SyncPolicy { <nl> <nl> @ Override <nl> public void onRealmClosed ( SyncSession session ) { <nl> - / / TODO Sync need to expose callback when there is no more local changes <nl> - / / For now just keep the session open . <nl> + / / TODO In order to preserve resources we should ideally close the session as well , but first <nl> + / / we want to make sure that all local changes have been synchronized to the remote Realm . <nl> } <nl> <nl> @ Override <nl> @ @ - 48 , 22 + 52 , 40 @ @ public class AutomaticSyncPolicy implements SyncPolicy { <nl> <nl> @ Override <nl> public boolean onError ( SyncSession session , ObjectServerError error ) { <nl> - switch ( error . category ( ) ) { <nl> + switch ( error . getCategory ( ) ) { <nl> case FATAL : <nl> return false ; / / Report all fatal errors to the user <nl> - case INFO : <nl> - return true ; / / Ignore all INFO errors <nl> case RECOVERABLE : <nl> - rebind ( session ) ; <nl> - return true ; <nl> + return rebind ( session ) ; <nl> default : <nl> return false ; <nl> } <nl> } <nl> <nl> - private void rebind ( SyncSession session ) { <nl> - / / FIXME : Do not rebind uncritically . Figure out a good strategy for this . <nl> - / / See https : / / realmio . slack . com / archives / sync - core / p1472415880000002 <nl> - session . bind ( ) ; <nl> + / * * <nl> + * Returns { @ code true } if we decide to rebind , { @ code false } if the error was determined to no longer be solvable . <nl> + * / <nl> + private boolean rebind ( SyncSession session ) { <nl> + / / Track all calls to rebind ( ) . If some error reported as RECOVERABLE keeps happening , we need to abort to <nl> + / / prevent run - away sessions . Right now we treat an error as recurring if it happens within 3 seconds of each <nl> + / / other . After 5 of such errors we terminate the session . <nl> + / / <nl> + / / Standard IO errors are already handled using incremental backoff by e . g the AUTHENTICATING state , so <nl> + / / re - occurring errors at this level are more serious . <nl> + long now = System . currentTimeMillis ( ) ; <nl> + if ( lastError - now < 3000 ) { <nl> + recurringErrors + + ; <nl> + } else { <nl> + recurringErrors = 1 ; <nl> + } <nl> + lastError = now ; <nl> + <nl> + if ( recurringErrors = = 5 ) { <nl> + session . stop ( ) ; / / Abort session , some error that should be temporary keeps happening . <nl> + return false ; <nl> + } else { <nl> + session . bind ( ) ; <nl> + return true ; <nl> + } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index 1912025 . . 4d02c8a 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * Fixed unchecked cast warnings when building with Realm . <nl> * Cleaned up examples ( remove old test project ) . <nl> * Added checking for missing generic type in RealmList fields in annotation processor . <nl> + * Support async queries <nl> <nl> 0 . 80 . 3 <nl> * Calling Realm . copyToRealmOrUpdate ( ) with an object with a null primary key now throws a proper exception . <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> index bb26d54 . . 3cad125 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> @ @ - 14 , 12 + 14 , 14 @ @ <nl> * limitations under the License . <nl> * / <nl> <nl> + # include < realm / group _ shared . hpp > <nl> # include " util . hpp " <nl> # include " io _ realm _ internal _ TableQuery . h " <nl> # include " tablequery . hpp " <nl> <nl> using namespace realm ; <nl> <nl> + # define SG ( ptr ) reinterpret _ cast < SharedGroup * > ( ptr ) <nl> # if 1 <nl> # define COL _ TYPE _ VALID ( env , ptr , col , type ) TBL _ AND _ COL _ INDEX _ AND _ TYPE _ VALID ( env , ptr , col , type ) <nl> # define COL _ TYPE _ LINK _ OR _ LINKLIST ( env , ptr , col ) TBL _ AND _ COL _ INDEX _ AND _ LINK _ OR _ LINKLIST ( env , ptr , col ) <nl> @ @ - 1174 , 3 + 1176 , 47 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNull ( <nl> pQuery - > and _ query ( query ) ; <nl> } CATCH _ STD ( ) <nl> } <nl> + <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover <nl> + ( JNIEnv * env , jobject , jlong callerSharedGrpPtr , jlong bgSharedGroupPtr , jlong nativeQueryPtr , jlong start , jlong end , jlong limit ) <nl> + { <nl> + Query * pQuery = Q ( nativeQueryPtr ) ; <nl> + Table * pTable = pQuery - > get _ table ( ) . get ( ) ; <nl> + if ( ! QUERY _ VALID ( env , pQuery ) | | <nl> + ! ROW _ INDEXES _ VALID ( env , pTable , start , end , limit ) ) <nl> + return - 1 ; <nl> + try { <nl> + TableView * pResultView = new TableView ( pQuery - > find _ all ( S ( start ) , S ( end ) , S ( limit ) ) ) ; <nl> + std : : unique _ ptr < SharedGroup : : Handover < TableView > > handover ; <nl> + handover . reset ( SG ( bgSharedGroupPtr ) - > export _ for _ handover ( * pResultView , ConstSourcePayload : : Copy ) ) ; <nl> + / / TODO reimplement this so the call to ' export _ for _ handover ' is done on a background thread <nl> + / / and ' import _ from _ handover ' on the caller thread . <nl> + / / <nl> + / / According to core , it ' s preferable to return first the exported handover <nl> + / / then import it from the calling SharedGroup ( Thread ) . <nl> + / / We need to make sure to check that the version id ( version of the shared group used to perform the query ) <nl> + / / is the same as the caller SharedGroup , otherwise the import will fail . In this case , we should <nl> + / / either retry the entire query , or call again ' sync _ if _ needed ' on the TableView to re - query , at this point <nl> + / / we need to export again the handover to the caller SharedGroup , until we converge <nl> + / / ( i . e the version of the caller SharedGroup matches the version returned by the handover TableView ) <nl> + / / <nl> + / / Note : The mode ' ConstSourcePayload : : Copy ' handover perform a deep copy of the TableView , this means that we copy <nl> + / / both the Payload ( row accessors ) & the Query <nl> + / / <nl> + / / The mode ' ConstSourcePayload : : Stay ' handover perform a copy of the Query only ( no payload ) <nl> + / / The mode ' MutableSourcePayload : : Move ' handover perform a move of both the Payload & Query <nl> + / / <nl> + / / The expensive operations are in that order <nl> + / / pQuery - > find _ all > > export _ for _ handover > > import _ from _ handover <nl> + / / so it ' s recommended to run the ' query ' & the ' export ' on a background Thread , then <nl> + / / call ' import _ from _ handover ' on the caller thread ( most of the time UI thread ) . <nl> + / / calling ' import _ from _ handover ' on the UI thread has another benefit , it will block the SharedGroup <nl> + / / from modifying it ' s state ( advance _ read , promote _ write , rollback , commit etc ) <nl> + / / <nl> + / / The handover pointer is Thread safe , it can be passed from different Threads ( using different SharedGroups ) <nl> + <nl> + TableView * tv ( SG ( callerSharedGrpPtr ) - > import _ from _ handover ( handover . release ( ) ) ) ; <nl> + return reinterpret _ cast < jlong > ( tv ) ; <nl> + } CATCH _ STD ( ) <nl> + return - 1 ; <nl> + } <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> index 5ccb9ee . . 97a9ed7 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> @ @ - 369 , 6 + 369 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAll <nl> <nl> / * <nl> * Class : io _ realm _ internal _ TableQuery <nl> + * Method : nativeFindAllWithHandover <nl> + * Signature : ( JJJJJJ ) J <nl> + * / <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover <nl> + ( JNIEnv * , jobject , jlong , jlong , jlong , jlong , jlong , jlong ) ; <nl> + <nl> + / * <nl> + * Class : io _ realm _ internal _ TableQuery <nl> * Method : nativeSumInt <nl> * Signature : ( JJJJJ ) J <nl> * / <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> new file mode 100644 <nl> index 0000000 . . 162e33a <nl> - - - / dev / null <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 0 , 0 + 1 , 151 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm ; <nl> + <nl> + import android . os . Looper ; <nl> + import android . test . InstrumentationTestCase ; <nl> + <nl> + import junit . framework . AssertionFailedError ; <nl> + <nl> + import java . util . Date ; <nl> + import java . util . concurrent . CountDownLatch ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . Executors ; <nl> + <nl> + import io . realm . entities . AllTypes ; <nl> + import io . realm . entities . NonLatinFieldNames ; <nl> + <nl> + public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> + <nl> + / / TODO use Junit4 & define a rule to setup the threading , to avoid <nl> + / / this boiler plat code , or use a custom test runner <nl> + public void testFindAll ( ) throws Throwable { <nl> + / / We need to control precisely which Looper / Thread our Realm <nl> + / / will operate on . This is unfortunately not possible when using the <nl> + / / current Instrumentation # InstrumentationThread , because InstrumentationTestRunner # onStart <nl> + / / Call Looper . prepare ( ) for us and surprisingly doesn ' t call Looper # loop ( ) , this is problematic <nl> + / / as the async query callback will not run ( because the Handler is sending Runnables to a Looper <nl> + / / that didn ' t loop . <nl> + / / <nl> + / / In the other hand , using a dedicated ' ExecutorService ' will allow us to fine grain control the <nl> + / / desired behaviour <nl> + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final Looper [ ] looper = new Looper [ 1 ] ; <nl> + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + executorService . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + looper [ 0 ] = Looper . myLooper ( ) ; <nl> + Realm realm = null ; <nl> + try { <nl> + realm = openRealmInstance ( ) ; <nl> + populateTestRealm ( realm , 10 ) ; <nl> + <nl> + / / async query ( will run on different thread ) <nl> + realm . asyncWhere ( AllTypes . class , <nl> + new Realm . AsyncCallback < RealmResults < AllTypes > > ( ) { <nl> + @ Override <nl> + public void onSuccess ( RealmResults < AllTypes > results ) { <nl> + try { <nl> + assertEquals ( 10 , results . size ( ) ) ; <nl> + <nl> + / / Make sure access to RealmObject will not throw an Exception <nl> + for ( int i = 0 , size = results . size ( ) ; i < size ; i + + ) { <nl> + assertEquals ( i , results . get ( i ) . getColumnLong ( ) ) ; <nl> + } <nl> + <nl> + } catch ( AssertionFailedError e ) { <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + / / whatever happened , make sure to notify the waiting TestCase Thread <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void onError ( Throwable t ) { <nl> + try { <nl> + threadAssertionError [ 0 ] = t ; <nl> + t . printStackTrace ( ) ; <nl> + } finally { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + } ) <nl> + . between ( " columnLong " , 0 , 9 ) . findAll ( ) ; <nl> + <nl> + Looper . loop ( ) ; / / ready to receive callback <nl> + <nl> + } finally { <nl> + if ( realm ! = null ) { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + / / wait until the callback of our async query proceed <nl> + signalCallbackFinished . await ( ) ; <nl> + looper [ 0 ] . quit ( ) ; <nl> + executorService . shutdownNow ( ) ; <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / Throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + } <nl> + <nl> + / / * * * Helper methods * * * <nl> + <nl> + / / This could be done from # setUp but then we can ' t control <nl> + / / which Looper we want to associate this Realm instance with <nl> + private Realm openRealmInstance ( ) { <nl> + RealmConfiguration realmConfiguration = new RealmConfiguration . <nl> + Builder ( getInstrumentation ( ) <nl> + . getTargetContext ( ) ) <nl> + . name ( " test . realm " ) <nl> + . deleteRealmIfMigrationNeeded ( ) <nl> + . build ( ) ; <nl> + Realm . deleteRealm ( realmConfiguration ) ; <nl> + return Realm . getInstance ( realmConfiguration ) ; <nl> + } <nl> + <nl> + private void populateTestRealm ( final Realm testRealm , int objects ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . allObjects ( AllTypes . class ) . clear ( ) ; <nl> + testRealm . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; <nl> + for ( int i = 0 ; i < objects ; + + i ) { <nl> + AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; <nl> + allTypes . setColumnBoolean ( ( i % 3 ) = = 0 ) ; <nl> + allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; <nl> + allTypes . setColumnDate ( new Date ( ) ) ; <nl> + allTypes . setColumnDouble ( 3 . 1415 ) ; <nl> + allTypes . setColumnFloat ( 1 . 234567f + i ) ; <nl> + allTypes . setColumnString ( " test data " + i ) ; <nl> + allTypes . setColumnLong ( i ) ; <nl> + NonLatinFieldNames nonLatinFieldNames = testRealm . createObject ( NonLatinFieldNames . class ) ; <nl> + nonLatinFieldNames . set 델 타 ( i ) ; <nl> + nonLatinFieldNames . set Δ έ λ τ α ( i ) ; <nl> + nonLatinFieldNames . set 베 타 ( 1 . 234567f + i ) ; <nl> + nonLatinFieldNames . set Β ή τ α ( 1 . 234567f + i ) ; <nl> + } <nl> + testRealm . commitTransaction ( ) ; <nl> + testRealm . refresh ( ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index ca29295 . . d2e5033 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 22 , 7 + 22 , 6 @ @ import org . json . JSONArray ; <nl> import org . json . JSONException ; <nl> import org . json . JSONObject ; <nl> <nl> - import java . io . ByteArrayInputStream ; <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> import java . io . InputStream ; <nl> diff - - git a / realm / src / main / java / io / realm / AsyncRealmQueryResult . java b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java <nl> new file mode 100644 <nl> index 0000000 . . 7318359 <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java <nl> @ @ - 0 , 0 + 1 , 25 @ @ <nl> + package io . realm ; <nl> + <nl> + import java . util . concurrent . Future ; <nl> + <nl> + / * * <nl> + * Represents the result of an asynchronous Realm query . <nl> + * <nl> + * Users are responsible of maintaining a reference to { @ code AsyncRealmQueryResult } in order <nl> + * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the <nl> + * query will post the result to the caller ' s thread callback ) <nl> + * / <nl> + public class AsyncRealmQueryResult { <nl> + final Future < ? > pendingQuery ; <nl> + <nl> + public AsyncRealmQueryResult ( Future < ? > pendingQuery ) { <nl> + this . pendingQuery = pendingQuery ; <nl> + } <nl> + <nl> + / * * <nl> + * Attempts to cancel execution of this queries . <nl> + * / <nl> + public void cancel ( ) { <nl> + pendingQuery . cancel ( true ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index ddbc022 . . 15aac8b 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 63 , 6 + 63 , 7 @ @ import io . realm . internal . SharedGroup ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableView ; <nl> import io . realm . internal . Util ; <nl> + import io . realm . internal . android . AsyncRealmQuery ; <nl> import io . realm . internal . android . DebugAndroidLogger ; <nl> import io . realm . internal . android . ReleaseAndroidLogger ; <nl> import io . realm . internal . log . RealmLog ; <nl> @ @ - 154 , 6 + 155 , 9 @ @ public final class Realm implements Closeable { <nl> private static final Map < String , AtomicInteger > globalOpenInstanceCounter = <nl> new ConcurrentHashMap < String , AtomicInteger > ( ) ; <nl> <nl> + / / Thread Pool for all async operations ( Query & Write transaction ) <nl> + public static final ExecutorService asyncQueryExecutor = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) * 2 + 1 ) ; <nl> + <nl> protected static final Map < Handler , String > handlers = new ConcurrentHashMap < Handler , String > ( ) ; <nl> private static final int REALM _ CHANGED = 14930352 ; / / Hopefully it won ' t clash with other message IDs . <nl> <nl> @ @ - 1198 , 6 + 1202 , 20 @ @ public final class Realm implements Closeable { <nl> } <nl> <nl> / * * <nl> + * Prepare an async query <nl> + * TODO point to documentation or example about async query <nl> + * @ param clazz The class of the object which is to be queried for <nl> + * @ return A typed RealmQuery , which can be used to query for specific objects of this type <nl> + * @ throws java . lang . RuntimeException Any other error <nl> + * @ see io . realm . RealmQuery <nl> + * @ param callback <nl> + * / <nl> + public < E extends RealmObject > AsyncRealmQuery < E > asyncWhere ( Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { <nl> + checkIfValid ( ) ; <nl> + return new AsyncRealmQuery < E > ( this , clazz , callback ) ; <nl> + } <nl> + <nl> + / * * <nl> * Get all objects of a specific Class . If no objects exist , the returned RealmResults will not <nl> * be null . The RealmResults . size ( ) to check the number of objects instead . <nl> * <nl> @ @ - 1872 , 4 + 1890 , 24 @ @ public final class Realm implements Closeable { <nl> void execute ( Realm realm ) ; <nl> } <nl> <nl> + / * * <nl> + * Encapsulates an async { @ link RealmQuery } . <nl> + * < p > <nl> + * This will run the { @ link RealmQuery } on a worker thread , then invoke this callback on the caller thread <nl> + * / <nl> + public interface AsyncCallback < T extends RealmResults < ? extends RealmObject > > { <nl> + void onSuccess ( T results ) ; <nl> + void onError ( Throwable t ) ; <nl> + } <nl> + <nl> + <nl> + / / FIXME Realm . java being the public API and the implementation . <nl> + / / we need a Realm interface to be able to separate this kind of call <nl> + / / ( mostly from internal API / tests that need to access private field / method ) . <nl> + / / RealmImpl will be accessible to other internal packages <nl> + / / but not to the user ( avoid compromising our exposed public API ) <nl> + / / <nl> + public long getSharedGroupPtr ( ) { <nl> + return sharedGroup . nativePtr ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index df847f5 . . b744adc 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1302 , 4 + 1302 , 8 @ @ public class RealmQuery < E extends RealmObject > { <nl> return null ; <nl> } <nl> } <nl> + <nl> + protected TableQuery getTableQuery ( ) { <nl> + return this . query ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / internal / TableQuery . java b / realm / src / main / java / io / realm / internal / TableQuery . java <nl> index e82eaa7 . . 268645d 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / TableQuery . java <nl> + + + b / realm / src / main / java / io / realm / internal / TableQuery . java <nl> @ @ - 493 , 8 + 493 , 24 @ @ public class TableQuery implements Closeable { <nl> } <nl> } <nl> <nl> - protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; <nl> + public TableView findAllWithHandover ( long callerSharedGroupPtr , long bgSharedGroupPtr ) { <nl> + validateQuery ( ) ; <nl> + <nl> + / / Execute the disposal of abandoned realm objects each time a new realm object is created <nl> + context . executeDelayedDisposal ( ) ; <nl> + long nativeViewPtr = nativeFindAllWithHandover ( callerSharedGroupPtr , bgSharedGroupPtr , nativePtr , 0 , Table . INFINITE , Table . INFINITE ) ; / / nativeViewPtr is created from bg Thread <nl> + / / handover nativeViewPtr to UI Thread <nl> + <nl> + try { <nl> + return new TableView ( this . context , this . parent , nativeViewPtr ) ; <nl> + } catch ( RuntimeException e ) { <nl> + TableView . nativeClose ( nativeViewPtr ) ; <nl> + throw e ; <nl> + } <nl> + } <nl> <nl> + protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; <nl> + protected native long nativeFindAllWithHandover ( long nativeCallerSharedGroupPtr , long bgSharedGroupPtr , long nativeQueryPtr , long start , long end , long limit ) ; <nl> / / <nl> / / Aggregation methods <nl> / / <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java <nl> new file mode 100644 <nl> index 0000000 . . c3716eb <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java <nl> @ @ - 0 , 0 + 1 , 165 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . android ; <nl> + <nl> + import android . os . Handler ; <nl> + import android . os . Looper ; <nl> + import android . os . Message ; <nl> + <nl> + import java . util . concurrent . Future ; <nl> + <nl> + import io . realm . AsyncRealmQueryResult ; <nl> + import io . realm . Realm ; <nl> + import io . realm . RealmConfiguration ; <nl> + import io . realm . RealmObject ; <nl> + import io . realm . RealmQuery ; <nl> + import io . realm . RealmResults ; <nl> + import io . realm . internal . TableOrView ; <nl> + import io . realm . internal . TableView ; <nl> + <nl> + import static io . realm . Realm . asyncQueryExecutor ; <nl> + <nl> + / * * <nl> + * A helper class to help make handling asynchronous { @ link RealmQuery } easier . <nl> + * <nl> + * @ param < E > type of the object which is to be queried for <nl> + * / <nl> + / / Behaviour may change , user should not subclass <nl> + public final class AsyncRealmQuery < E extends RealmObject > { <nl> + private final Realm callerRealm ; <nl> + private final Class < E > clazz ; <nl> + private final Realm . AsyncCallback < RealmResults < E > > callback ; <nl> + <nl> + private int from ; <nl> + private int to ; <nl> + private String fieldName ; <nl> + private EventHandler eventHandler ; <nl> + private Future < ? > pendingQuery ; <nl> + <nl> + / * * <nl> + * Create an { @ code AsyncRealmQuery } instance . <nl> + * <nl> + * @ param realm The realm to query within . <nl> + * @ param clazz The class to query . <nl> + * @ param callback invoked on the thread { @ link Realm # asyncWhere ( Class , Realm . AsyncCallback ) } was called from , to post results . <nl> + * / <nl> + public AsyncRealmQuery ( Realm realm , Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { <nl> + this . callerRealm = realm ; <nl> + this . callback = callback ; <nl> + this . clazz = clazz ; <nl> + } <nl> + <nl> + / * * <nl> + * Between condition <nl> + * <nl> + * @ param fieldName The field to compare <nl> + * @ param from Lowest value ( inclusive ) <nl> + * @ param to Highest value ( inclusive ) <nl> + * @ return current instance of { @ code AsyncRealmQuery } for method chaining <nl> + * / <nl> + public AsyncRealmQuery < E > between ( String fieldName , int from , int to ) { <nl> + this . from = from ; <nl> + this . to = to ; <nl> + this . fieldName = fieldName ; <nl> + return this ; <nl> + } <nl> + <nl> + / * * <nl> + * Find all objects that fulfill the query conditions . <nl> + * Results will be posted to the callback instance { @ link io . realm . Realm . AsyncCallback } asynchronously <nl> + * If no objects match the condition , a list with zero objects is returned . <nl> + * <nl> + * @ see io . realm . RealmResults <nl> + * / <nl> + public AsyncRealmQueryResult findAll ( ) { <nl> + / / will use the Looper of the caller thread to post the result <nl> + Looper looper ; <nl> + if ( ( looper = Looper . myLooper ( ) ) ! = null ) { <nl> + eventHandler = new EventHandler ( looper ) ; <nl> + } else if ( ( looper = Looper . getMainLooper ( ) ) ! = null ) { <nl> + eventHandler = new EventHandler ( looper ) ; <nl> + } else { <nl> + eventHandler = null ; / / FIXME define strategy / behaviour for regular JVM call <nl> + } <nl> + <nl> + / / We need a pointer to the caller Realm , to be able to handover the result to it <nl> + final long callerSharedGroupNativePtr = callerRealm . getSharedGroupPtr ( ) ; <nl> + <nl> + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) <nl> + / / to perform the query <nl> + final RealmConfiguration realmConfiguration = callerRealm . getConfiguration ( ) ; <nl> + <nl> + pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + try { <nl> + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> + <nl> + / / TODO This will probably be replace by a kind of ' QueryBuilder ' <nl> + / / that holds all the operations ( predicates / filters ) then <nl> + / / replay them here in this background thread . The current implementation <nl> + / / call Core for each step , we want to limit the overhead by sending one <nl> + / / single call to Core with all the parameters . <nl> + <nl> + TableView tv = new RealmQueryAdapter < E > ( bgRealm , clazz ) <nl> + . between ( fieldName , from , to ) <nl> + . findAll ( callerSharedGroupNativePtr , bgRealm . getSharedGroupPtr ( ) ) ; <nl> + <nl> + bgRealm . close ( ) ; <nl> + <nl> + / / send results to the caller thread ' s callback <nl> + if ( ! pendingQuery . isCancelled ( ) ) { <nl> + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ SUCCESS , tv ) ; <nl> + eventHandler . sendMessage ( msg ) ; <nl> + } <nl> + <nl> + } catch ( Exception e ) { <nl> + if ( ! pendingQuery . isCancelled ( ) ) { <nl> + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ ERROR , e ) ; <nl> + eventHandler . sendMessage ( msg ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + return new AsyncRealmQueryResult ( pendingQuery ) ; <nl> + } <nl> + <nl> + private class EventHandler extends Handler { <nl> + private static final int MSG _ SUCCESS = 1 ; <nl> + private static final int MSG _ ERROR = MSG _ SUCCESS + 1 ; <nl> + <nl> + public EventHandler ( Looper looper ) { <nl> + super ( looper ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void handleMessage ( Message msg ) { <nl> + switch ( msg . what ) { <nl> + case MSG _ SUCCESS : <nl> + RealmResults < E > resultList = new RealmResults < E > ( callerRealm , ( TableOrView ) msg . obj , clazz ) ; <nl> + callback . onSuccess ( resultList ) ; <nl> + break ; <nl> + case MSG _ ERROR : <nl> + callback . onError ( ( Throwable ) msg . obj ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java <nl> new file mode 100644 <nl> index 0000000 . . acac317 <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java <nl> @ @ - 0 , 0 + 1 , 38 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . android ; <nl> + <nl> + import io . realm . Realm ; <nl> + import io . realm . RealmObject ; <nl> + import io . realm . RealmQuery ; <nl> + import io . realm . internal . TableView ; <nl> + <nl> + class RealmQueryAdapter < E extends RealmObject > extends RealmQuery < E > { <nl> + public RealmQueryAdapter ( Realm realm , Class < E > clazz ) { <nl> + super ( realm , clazz ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public RealmQueryAdapter < E > between ( String fieldName , int from , int to ) { <nl> + super . between ( fieldName , from , to ) ; <nl> + return this ; <nl> + } <nl> + <nl> + public TableView findAll ( long callerRealmPtr , long backgroundRealmPtr ) { <nl> + return getTableQuery ( ) . findAllWithHandover ( callerRealmPtr , backgroundRealmPtr ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / examples / objectServerExample / src / main / java / io / realm / examples / objectserver / LoginActivity . java b / examples / objectServerExample / src / main / java / io / realm / examples / objectserver / LoginActivity . java 
 index bd32a9b . . 5c92889 100644 
 - - - a / examples / objectServerExample / src / main / java / io / realm / examples / objectserver / LoginActivity . java 
 + + + b / examples / objectServerExample / src / main / java / io / realm / examples / objectserver / LoginActivity . java 
 @ @ - 31 , 6 + 31 , 8 @ @ import io . realm . objectserver . ObjectServerError ; 
 import io . realm . objectserver . User ; 
 import io . realm . objectserver . UserStore ; 
 
 + import static io . realm . objectserver . ErrorCode . UNKNOWN _ ACCOUNT ; 
 + 
 public class LoginActivity extends AppCompatActivity { 
 
 private UserStore userStore = MyApplication . USER _ STORE ; 
 @ @ - 91 , 7 + 93 , 7 @ @ public class LoginActivity extends AppCompatActivity { 
 public void onError ( ObjectServerError error ) { 
 progressDialog . dismiss ( ) ; 
 String errorMsg ; 
 - switch ( error . errorCode ( ) ) { 
 + switch ( error . getErrorCode ( ) ) { 
 case UNKNOWN _ ACCOUNT : 
 errorMsg = " Account does not exists . " ; 
 break ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / ErrorCode . java b / realm / realm - library / src / main / java / io / realm / objectserver / ErrorCode . java 
 index ac857cc . . 326c717 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / objectserver / ErrorCode . java 
 + + + b / realm / realm - library / src / main / java / io / realm / objectserver / ErrorCode . java 
 @ @ - 16 , 31 + 16 , 30 @ @ 
 
 package io . realm . objectserver ; 
 
 + / * * 
 + * This class enumerate all potential errors related to using the Object Server or synchronizing data . 
 + * / 
 public enum ErrorCode { 
 
 - / / See https : / / github . com / realm / realm - sync / issues / 585 
 / / See https : / / github . com / realm / realm - sync / blob / master / doc / protocol . md 
 
 / / Realm Java errors ( 0 - 49 ) 
 - 
 UNKNOWN ( - 1 ) , / / Catch - all 
 IO _ EXCEPTION ( 0 , Category . RECOVERABLE ) , / / Some IO error while either contacting the server or reading the response 
 JSON _ EXCEPTION ( 1 ) , / / JSON input could not be parsed correctly 
 
 / / Realm Object Server errors ( 100 - 199 ) 
 - 
 - / / Connection level and protocol errors 
 - 
 - CONNECTION _ CLOSED ( 100 , Category . INFO ) , / / Connection closed ( no error ) 
 - OTHER _ ERROR ( 101 , Category . INFO ) , / / Other connection level error 
 - UNKNOWN _ MESSAGE ( 102 , Category . INFO ) , / / Unknown type of input message 
 - BAD _ SYNTAX ( 103 , Category . INFO ) , / / Bad syntax in input message head 
 - LIMITS _ EXCEEDED ( 104 , Category . INFO ) , / / Limits exceeded in input message 
 - WRONG _ PROTOCOL _ VERSION ( 105 , Category . INFO ) , / / Wrong protocol version ( CLIENT ) 
 - BAD _ SESSION _ IDENT ( 106 , Category . INFO ) , / / Bad session identifier in input message 
 - REUSE _ OF _ SESSION _ IDENT ( 107 , Category . INFO ) , / / Overlapping reuse of session identifier ( BIND ) 
 - BOUND _ IN _ OTHER _ SESSION ( 108 , Category . INFO ) , / / Client file bound in other session ( IDENT ) 
 - BAD _ MESSAGE _ ORDER ( 109 , Category . INFO ) , / / Bad input message order 
 + / / Connection level and protocol errors . 
 + CONNECTION _ CLOSED ( 100 ) , / / Connection closed ( no error ) 
 + OTHER _ ERROR ( 101 ) , / / Other connection level error 
 + UNKNOWN _ MESSAGE ( 102 ) , / / Unknown type of input message 
 + BAD _ SYNTAX ( 103 ) , / / Bad syntax in input message head 
 + LIMITS _ EXCEEDED ( 104 ) , / / Limits exceeded in input message 
 + WRONG _ PROTOCOL _ VERSION ( 105 ) , / / Wrong protocol version ( CLIENT ) 
 + BAD _ SESSION _ IDENT ( 106 ) , / / Bad session identifier in input message 
 + REUSE _ OF _ SESSION _ IDENT ( 107 ) , / / Overlapping reuse of session identifier ( BIND ) 
 + BOUND _ IN _ OTHER _ SESSION ( 108 ) , / / Client file bound in other session ( IDENT ) 
 + BAD _ MESSAGE _ ORDER ( 109 ) , / / Bad input message order 
 
 / / Session level errors ( 200 - 299 ) 
 SESSION _ CLOSED ( 200 , Category . RECOVERABLE ) , / / Session closed ( no error ) 
 @ @ - 53 , 7 + 52 , 7 @ @ public enum ErrorCode { 
 NO _ SUCH _ PATH ( 205 ) , / / No such Realm ( BIND ) 
 PERMISSION _ DENIED ( 206 ) , / / Permission denied ( BIND , REFRESH ) 
 
 - / / Fatal : Wrong server / client versions . Trying to sync incompatible files or corrupted . 
 + / / Fatal : Wrong server / client versions . Trying to sync incompatible files or the file was corrupted . 
 BAD _ SERVER _ FILE _ IDENT ( 207 ) , / / Bad server file identifier ( IDENT ) 
 BAD _ CLIENT _ FILE _ IDENT ( 208 ) , / / Bad client file identifier ( IDENT ) 
 BAD _ SERVER _ VERSION ( 209 ) , / / Bad server version ( IDENT , UPLOAD ) 
 @ @ - 61 , 10 + 60 , 9 @ @ public enum ErrorCode { 
 DIVERGING _ HISTORIES ( 211 ) , / / Diverging histories ( IDENT ) 
 BAD _ CHANGESET ( 212 ) , / / Bad changeset ( UPLOAD ) 
 
 - / / 300 - 599 Standard HTTP error codes 
 + / / 300 - 599 Reserved for Standard HTTP error codes 
 
 / / Realm Authentication Server response errors ( 600 - 699 ) 
 - 
 INVALID _ PARAMETERS ( 601 ) , 
 MISSING _ PARAMETERS ( 602 ) , 
 INVALID _ CREDENTIALS ( 611 ) , 
 @ @ - 90 , 23 + 88 , 27 @ @ public enum ErrorCode { 
 return super . toString ( ) + " ( " + code + " ) " ; 
 } 
 
 - public int errorCode ( ) { 
 + / * * 
 + * Returns the numerical value for this error code . 
 + * 
 + * @ return the error code as an unique { @ code int } value . 
 + * / 
 + public int intValue ( ) { 
 return code ; 
 } 
 
 - 
 / * * 
 - * Returns the category of the error . 
 + * Returns the getCategory of the error . 
 * < p > 
 - * Errors come in 3 categories : FATAL , RECOVERABLE , and INFO . 
 + * Errors come in 2 categories : FATAL , RECOVERABLE 
 * < p > 
 * FATAL : The session cannot be recovered and needs to be re - created . A likely cause is that the User does not 
 - * have access to this Realm . Check that the { @ link SyncConfiguration } is correct . 
 + * have access to this Realm . Check that the { @ link SyncConfiguration } is correct . Any fatal error will cause 
 + * the session to be become { @ link SessionState # STOPPED } . 
 * < p > 
 - * RECOVERABLE : The session is paused until given additional information . Most likely cause is an expired access 
 - * token or similar . 
 + * RECOVERABLE : Temporary error . The session becomes { @ link SessionState # UNBOUND } , but will automatically try to 
 + * recover as soon as possible . 
 * < p > 
 - * INFO : The underlying sync client will automatically try to recover from this . 
 * 
 * @ return the severity of the error . 
 * / 
 @ @ - 118 , 7 + 120 , 7 @ @ public enum ErrorCode { 
 ErrorCode [ ] errorCodes = values ( ) ; 
 for ( int i = 0 ; i < errorCodes . length ; i + + ) { 
 ErrorCode error = errorCodes [ i ] ; 
 - if ( error . errorCode ( ) = = errorCode ) { 
 + if ( error . intValue ( ) = = errorCode ) { 
 return error ; 
 } 
 } 
 @ @ - 127 , 7 + 129 , 6 @ @ public enum ErrorCode { 
 
 public enum Category { 
 FATAL , / / Abort session as soon as possible 
 - RECOVERABLE , / / Still possible to recover the session by either rebinding or providing the required information . 
 - INFO / / Just FYI . The underlying network client will automatically try to recover . 
 + RECOVERABLE / / Still possible to recover the session by either rebinding or providing the required information . 
 } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / ObjectServerError . java b / realm / realm - library / src / main / java / io / realm / objectserver / ObjectServerError . java 
 index f66ef6f . . 27f0618 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / objectserver / ObjectServerError . java 
 + + + b / realm / realm - library / src / main / java / io / realm / objectserver / ObjectServerError . java 
 @ @ - 22 , 9 + 22 , 9 @ @ import io . realm . internal . Util ; 
 * This class is a wrapper for all errors happening when communicating with the Realm Object Server . 
 * This include both exceptions and protocol errors . 
 * 
 - * Only { @ link # errorCode ( ) } is guaranteed to be set . If the error was caused by an underlying exception 
 - * { @ link # errorMessage ( ) } is { @ code null } and { @ link # exception ( ) } is set , while if the error was a protocol error 
 - * { @ link # errorMessage ( ) } is set and { @ link # exception ( ) } is null . 
 + * Only { @ link # getErrorCode ( ) } is guaranteed to contain a value . If the error was caused by an underlying exception 
 + * { @ link # getErrorMessage ( ) } is { @ code null } and { @ link # getException ( ) } is set , while if the error was a protocol error 
 + * { @ link # getErrorMessage ( ) } is set and { @ link # getException ( ) } is null . 
 * 
 * @ see io . realm . objectserver . ErrorCode for a list of possible errors . 
 * / 
 @ @ - 34 , 10 + 34 , 22 @ @ public class ObjectServerError extends RuntimeException { 
 private final String errorMessage ; 
 private final Throwable exception ; 
 
 + / * * 
 + * Create an error caused by an error in the protocol when communicating with the Object Server . 
 + * 
 + * @ param errorCode error code for this type of error . 
 + * @ param errorMessage detailed error message . 
 + * / 
 public ObjectServerError ( ErrorCode errorCode , String errorMessage ) { 
 - this ( errorCode , errorMessage , null ) ; 
 + this ( errorCode , errorMessage , ( Throwable ) null ) ; 
 } 
 
 + / * * 
 + * Create an error caused by an an exception when communicating with the Object Server . 
 + * 
 + * @ param errorCode error code for this type of error . 
 + * @ param exception underlying exception causing this error . 
 + * / 
 public ObjectServerError ( ErrorCode errorCode , Throwable exception ) { 
 this ( errorCode , null , exception ) ; 
 } 
 @ @ - 45 , 9 + 57 , 9 @ @ public class ObjectServerError extends RuntimeException { 
 / * * 
 * Generic error happening that could happen anywhere . 
 * 
 - * @ param errorCode 
 - * @ param errorMessage 
 - * @ param exception 
 + * @ param errorCode error code for this type of error . 
 + * @ param errorMessage detailed error message . 
 + * @ param exception underlying exception if the error was caused by this . 
 * / 
 public ObjectServerError ( ErrorCode errorCode , String errorMessage , Throwable exception ) { 
 this . error = errorCode ; 
 @ @ - 58 , 34 + 70 , 57 @ @ public class ObjectServerError extends RuntimeException { 
 / * * 
 * Errors happening while trying to authenticate a user . 
 * 
 - * @ param errorCode 
 - * @ param title 
 - * @ param hint 
 - * @ param type 
 + * @ param errorCode error code for this type of error . 
 + * @ param title Title for this type of error . 
 + * @ param hint a hint for resolving the error . 
 * / 
 - public ObjectServerError ( ErrorCode errorCode , String title , String hint , String type ) { 
 - this ( errorCode , String . format ( " % s : % s ( % s ) " , title , hint , type ) , null ) ; 
 + public ObjectServerError ( ErrorCode errorCode , String title , String hint ) { 
 + this ( errorCode , ( hint ! = null ) ? title + " : " + hint : title , ( Throwable ) null ) ; 
 } 
 
 - public ErrorCode errorCode ( ) { 
 + / * * 
 + * Returns the error code uniquely identifying this type of error . 
 + * 
 + * @ return the error code identifying the type of error . 
 + * @ see ErrorCode 
 + * / 
 + public ErrorCode getErrorCode ( ) { 
 return error ; 
 } 
 
 - public String errorMessage ( ) { 
 + / * * 
 + * Returns a more detailed error message about the cause of this error . 
 + * 
 + * @ return a detailed error message or { @ code null } if one was not available . 
 + * / 
 + public String getErrorMessage ( ) { 
 return errorMessage ; 
 } 
 
 - public Throwable exception ( ) { 
 + / * * 
 + * Returns the underlying exception causing this error , if any . 
 + * 
 + * @ return the underlying exception causing this error , or { @ code null } if not caused by an exception . 
 + * / 
 + public Throwable getException ( ) { 
 return exception ; 
 } 
 
 - public ErrorCode . Category category ( ) { 
 + / * * 
 + * Returns the { @ link io . realm . objectserver . ErrorCode . Category } category for this error . 
 + * Errors that are { @ link io . realm . objectserver . ErrorCode . Category # RECOVERABLE } mean that it is still possible for a 
 + * given { @ link Session } to resume synchronization . { @ link io . realm . objectserver . ErrorCode . Category # FATAL } errors 
 + * means that session has stopped and cannot be recovered . 
 + * 
 + * @ return the error category . 
 + * / 
 + public ErrorCode . Category getCategory ( ) { 
 return error . getCategory ( ) ; 
 } 
 
 @ Override 
 public String toString ( ) { 
 - StringBuilder sb = new StringBuilder ( errorCode ( ) . toString ( ) ) ; 
 + StringBuilder sb = new StringBuilder ( getErrorCode ( ) . toString ( ) ) ; 
 if ( errorMessage ! = null ) { 
 sb . append ( ' \ n ' ) ; 
 sb . append ( errorMessage ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / SyncManager . java b / realm / realm - library / src / main / java / io / realm / objectserver / SyncManager . java 
 index e068cec . . 917e98c 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / objectserver / SyncManager . java 
 + + + b / realm / realm - library / src / main / java / io / realm / objectserver / SyncManager . java 
 @ @ - 50 , 16 + 50 , 13 @ @ public final class SyncManager { 
 String errorMsg = String . format ( " Session Error [ % s ] : % s " , 
 session . getConfiguration ( ) . getServerUrl ( ) , 
 error . toString ( ) ) ; 
 - switch ( error . errorCode ( ) . getCategory ( ) ) { 
 + switch ( error . getErrorCode ( ) . getCategory ( ) ) { 
 case FATAL : 
 RealmLog . error ( errorMsg ) ; 
 break ; 
 case RECOVERABLE : 
 RealmLog . info ( errorMsg ) ; 
 break ; 
 - case INFO : 
 - RealmLog . debug ( errorMsg ) ; 
 - break ; 
 } 
 } 
 } ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / AuthenticatingState . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / AuthenticatingState . java 
 index 0ac116e . . a52d2f3 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / AuthenticatingState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / AuthenticatingState . java 
 @ @ - 79 , 21 + 79 , 6 @ @ class AuthenticatingState extends FsmState { 
 } 
 } 
 
 - private synchronized void authenticate ( final SyncSession session ) { 
 - session . authenticateRealm ( new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - gotoNextState ( SessionState . BINDING ) ; 
 - } 
 - } , new io . realm . objectserver . Session . ErrorHandler ( ) { 
 - @ Override 
 - public void onError ( io . realm . objectserver . Session session , ObjectServerError error ) { 
 - / / FIXME For critical errors , got directly to STOPPED 
 - gotoNextState ( SessionState . UNBOUND ) ; 
 - } 
 - } ) ; 
 - } 
 - 
 @ Override 
 public void onBind ( ) { 
 gotoNextState ( SessionState . BINDING ) ; / / Equivalent to forcing a retry 
 @ @ - 108 , 4 + 93 , 18 @ @ class AuthenticatingState extends FsmState { 
 public void onStop ( ) { 
 gotoNextState ( SessionState . STOPPED ) ; 
 } 
 + 
 + private synchronized void authenticate ( final SyncSession session ) { 
 + session . authenticateRealm ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + gotoNextState ( SessionState . BINDING ) ; 
 + } 
 + } , new Session . ErrorHandler ( ) { 
 + @ Override 
 + public void onError ( Session s , ObjectServerError error ) { 
 + session . onError ( error ) ; 
 + } 
 + } ) ; 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / BoundState . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / BoundState . java 
 index 5eb347a . . d03632d 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / BoundState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / BoundState . java 
 @ @ - 16 , 6 + 16 , 7 @ @ 
 
 package io . realm . objectserver . internal ; 
 
 + import io . realm . objectserver . ErrorCode ; 
 import io . realm . objectserver . ObjectServerError ; 
 import io . realm . objectserver . SessionState ; 
 
 @ @ - 33 , 7 + 34 , 7 @ @ class BoundState extends FsmState { 
 
 @ Override 
 public void onExitState ( ) { 
 - session . stopNativeSession ( ) ; 
 + / / Do nothing . Entry states will stop the session if needed . 
 } 
 
 @ Override 
 @ @ - 48 , 62 + 49 , 15 @ @ class BoundState extends FsmState { 
 
 @ Override 
 public void onError ( ObjectServerError error ) { 
 - switch ( error . errorCode ( ) ) { 
 - / / FIXME : Regenerate this 
 - / / Auth protocol errors ( should not happen ) . 
 - case IO _ EXCEPTION : 
 - case JSON _ EXCEPTION : 
 - case INVALID _ PARAMETERS : 
 - case MISSING _ PARAMETERS : 
 - case INVALID _ CREDENTIALS : 
 - case UNKNOWN _ ACCOUNT : 
 - case EXISTING _ ACCOUNT : 
 - case ACCESS _ DENIED : 
 - case EXPIRED _ REFRESH _ TOKEN : 
 - throw new IllegalStateException ( " Authentication protocol errors should not happen : " + error . toString ( ) ) ; 
 - 
 - / / Ignore Network client errors ( irrelevant ) 
 - / / FIXME : Not accurate : https : / / github . com / realm / realm - sync / issues / 659 How should these be handled ? 
 - case CONNECTION _ CLOSED : 
 - case OTHER _ ERROR : 
 - case UNKNOWN _ MESSAGE : 
 - case BAD _ SYNTAX : 
 - case LIMITS _ EXCEEDED : 
 - case WRONG _ PROTOCOL _ VERSION : 
 - case BAD _ SESSION _ IDENT : 
 - case REUSE _ OF _ SESSION _ IDENT : 
 - case BOUND _ IN _ OTHER _ SESSION : 
 - case BAD _ MESSAGE _ ORDER : 
 - return ; 
 - 
 - / / Session errors : 
 - / / FIXME : Which of these are just INFO and which can we actually do something about ? Right now treat all as fatal 
 - case SESSION _ CLOSED : 
 - case OTHER _ SESSION _ ERROR : 
 - gotoNextState ( SessionState . STOPPED ) ; 
 - break ; 
 - 
 - case TOKEN _ EXPIRED : 
 - / / Only known case we can actually work around . 
 - / / Trigger a rebind which will cause access token to be refreshed . 
 - gotoNextState ( SessionState . BINDING ) ; 
 - break ; 
 - 
 - case BAD _ AUTHENTICATION : 
 - case ILLEGAL _ REALM _ PATH : 
 - case NO _ SUCH _ PATH : 
 - case PERMISSION _ DENIED : 
 - case BAD _ SERVER _ FILE _ IDENT : 
 - case BAD _ CLIENT _ FILE _ IDENT : 
 - case BAD _ SERVER _ VERSION : 
 - case BAD _ CLIENT _ VERSION : 
 - case DIVERGING _ HISTORIES : 
 - case BAD _ CHANGESET : 
 - gotoNextState ( SessionState . STOPPED ) ; 
 - break ; 
 - 
 - default : 
 - throw new IllegalArgumentException ( " Unknown error code : " + error . errorCode ( ) ) ; 
 + / / If a Realms access token has expired , trigger a rebind . If the user is still valid it will automatically 
 + / / refresh it . 
 + if ( error . getErrorCode ( ) = = ErrorCode . TOKEN _ EXPIRED ) { 
 + gotoNextState ( SessionState . BINDING ) ; 
 + } else { 
 + switch ( error . getCategory ( ) ) { 
 + case FATAL : gotoNextState ( SessionState . STOPPED ) ; break ; 
 + case RECOVERABLE : gotoNextState ( SessionState . UNBOUND ) ; break ; 
 + } 
 } 
 } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / FsmState . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / FsmState . java 
 index 8460a58 . . 833e282 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / FsmState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / FsmState . java 
 @ @ - 16 , 11 + 16 , 12 @ @ 
 
 package io . realm . objectserver . internal ; 
 
 - import io . realm . objectserver . * ; 
 + import io . realm . objectserver . ObjectServerError ; 
 + import io . realm . objectserver . SessionState ; 
 
 / * * 
 - * Abstract class containing shared logic for all { @ link io . realm . objectserver . Session } states . All states must extend this class as it 
 - * contains the logic for entering and leaving states . 
 + * Abstract class containing shared logic for all { @ link io . realm . objectserver . Session } states . All states must extend 
 + * this class as it contains the logic for entering and leaving states . 
 * 
 * TODO Move this to the Object Store 
 * / 
 @ @ - 43 , 7 + 44 , 7 @ @ abstract class FsmState implements FsmAction { 
 
 / * * 
 * Called just before leaving the state . Once this method is called no more state changes can be triggered from 
 - * this state until { @ link # entry ( io . realm . objectserver . Session ) } has been called again . 
 + * this state until { @ link # entry ( SyncSession ) } has been called again . 
 * < p > 
 * This should only be called from { @ link io . realm . objectserver . Session } . 
 * / 
 @ @ - 83 , 6 + 84 , 13 @ @ abstract class FsmState implements FsmAction { 
 
 @ Override 
 public void onError ( ObjectServerError error ) { 
 - gotoNextState ( SessionState . STOPPED ) ; 
 + switch ( error . getCategory ( ) ) { 
 + case FATAL : 
 + gotoNextState ( SessionState . STOPPED ) ; 
 + break ; 
 + case RECOVERABLE : 
 + gotoNextState ( SessionState . UNBOUND ) ; 
 + break ; 
 + } 
 } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / SyncSession . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / SyncSession . java 
 index 16ad250 . . 85db11b 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / SyncSession . java 
 + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / SyncSession . java 
 @ @ - 90 , 6 + 90 , 8 @ @ import io . realm . objectserver . internal . syncpolicy . SyncPolicy ; 
 @ Keep 
 public final class SyncSession { 
 
 + private static final long MAX _ DELAY _ MS = TimeUnit . MINUTES . toMillis ( 5 ) ; 
 + 
 private final HashMap < SessionState , FsmState > FSM = new HashMap < SessionState , FsmState > ( ) ; 
 
 / / Variables used by the FSM 
 @ @ - 262 , 7 + 264 , 7 @ @ public final class SyncSession { 
 ObjectServerError error = null ; 
 while ( true ) { 
 attempt + + ; 
 - long sleep = Util . calculateExponentialDelay ( attempt - 1 , TimeUnit . MINUTES . toMillis ( 5 ) ) ; 
 + long sleep = Util . calculateExponentialDelay ( attempt - 1 , MAX _ DELAY _ MS ) ; 
 if ( sleep > 0 ) { 
 try { 
 Thread . sleep ( sleep ) ; 
 @ @ - 285 , 7 + 287 , 7 @ @ public final class SyncSession { 
 / / All other errors indicate a bigger problem , so stop trying to authenticate and 
 / / unbind 
 ObjectServerError responseError = response . getError ( ) ; 
 - if ( responseError . errorCode ( ) ! = ErrorCode . IO _ EXCEPTION ) { 
 + if ( responseError . getErrorCode ( ) ! = ErrorCode . IO _ EXCEPTION ) { 
 success = false ; 
 error = responseError ; 
 break ; 
 @ @ - 345 , 9 + 347 , 6 @ @ public final class SyncSession { 
 } 
 
 / * * 
 - * FIXME : Find a way to keep this out of the public API . Could probably happen as part of moving everything to the 
 - * Object Store . 
 - * 
 * Notify session that a commit on the device has happened . 
 * / 
 void notifyCommit ( long version ) { 
 diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / network / AuthenticateResponse . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / network / AuthenticateResponse . java 
 index 0416786 . . 0455ac4 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / network / AuthenticateResponse . java 
 + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / network / AuthenticateResponse . java 
 @ @ - 55 , 11 + 55 , 10 @ @ public class AuthenticateResponse { 
 if ( response . code ( ) ! = 200 ) { 
 try { 
 JSONObject obj = new JSONObject ( serverResponse ) ; 
 - String type = obj . getString ( " type " ) ; 
 String hint = obj . optString ( " hint " , null ) ; 
 String title = obj . optString ( " title " , null ) ; 
 ErrorCode errorCode = ErrorCode . fromInt ( obj . optInt ( " code " , - 1 ) ) ; 
 - ObjectServerError error = new ObjectServerError ( errorCode , title , hint , type ) ; 
 + ObjectServerError error = new ObjectServerError ( errorCode , title , hint ) ; 
 return new AuthenticateResponse ( error ) ; 
 } catch ( JSONException e ) { 
 ObjectServerError error = new ObjectServerError ( ErrorCode . JSON _ EXCEPTION , " Server failed with " + 
 diff - - git a / realm / realm - library / src / main / java / io / realm / objectserver / internal / syncpolicy / AutomaticSyncPolicy . java b / realm / realm - library / src / main / java / io / realm / objectserver / internal / syncpolicy / AutomaticSyncPolicy . java 
 index eabb6b6 . . 5941452 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / objectserver / internal / syncpolicy / AutomaticSyncPolicy . java 
 + + + b / realm / realm - library / src / main / java / io / realm / objectserver / internal / syncpolicy / AutomaticSyncPolicy . java 
 @ @ - 19 , 12 + 19 , 16 @ @ package io . realm . objectserver . internal . syncpolicy ; 
 import io . realm . objectserver . ObjectServerError ; 
 import io . realm . objectserver . internal . SyncSession ; 
 
 + import static java . lang . System . currentTimeMillis ; 
 + 
 / * * 
 * This SyncPolicy will automatically start synchronizing changes to a Realm as soon as it is opened . 
 - * / / TODO Figure out how to close connection once all changes have been uploaded . 
 * / 
 public class AutomaticSyncPolicy implements SyncPolicy { 
 
 + private Long lastError = null ; 
 + private int recurringErrors = 0 ; 
 + 
 @ Override 
 public void onRealmOpened ( SyncSession session ) { 
 session . bind ( ) ; / / Bind Realm first time it is opened . 
 @ @ - 32 , 8 + 36 , 8 @ @ public class AutomaticSyncPolicy implements SyncPolicy { 
 
 @ Override 
 public void onRealmClosed ( SyncSession session ) { 
 - / / TODO Sync need to expose callback when there is no more local changes 
 - / / For now just keep the session open . 
 + / / TODO In order to preserve resources we should ideally close the session as well , but first 
 + / / we want to make sure that all local changes have been synchronized to the remote Realm . 
 } 
 
 @ Override 
 @ @ - 48 , 22 + 52 , 40 @ @ public class AutomaticSyncPolicy implements SyncPolicy { 
 
 @ Override 
 public boolean onError ( SyncSession session , ObjectServerError error ) { 
 - switch ( error . category ( ) ) { 
 + switch ( error . getCategory ( ) ) { 
 case FATAL : 
 return false ; / / Report all fatal errors to the user 
 - case INFO : 
 - return true ; / / Ignore all INFO errors 
 case RECOVERABLE : 
 - rebind ( session ) ; 
 - return true ; 
 + return rebind ( session ) ; 
 default : 
 return false ; 
 } 
 } 
 
 - private void rebind ( SyncSession session ) { 
 - / / FIXME : Do not rebind uncritically . Figure out a good strategy for this . 
 - / / See https : / / realmio . slack . com / archives / sync - core / p1472415880000002 
 - session . bind ( ) ; 
 + / * * 
 + * Returns { @ code true } if we decide to rebind , { @ code false } if the error was determined to no longer be solvable . 
 + * / 
 + private boolean rebind ( SyncSession session ) { 
 + / / Track all calls to rebind ( ) . If some error reported as RECOVERABLE keeps happening , we need to abort to 
 + / / prevent run - away sessions . Right now we treat an error as recurring if it happens within 3 seconds of each 
 + / / other . After 5 of such errors we terminate the session . 
 + / / 
 + / / Standard IO errors are already handled using incremental backoff by e . g the AUTHENTICATING state , so 
 + / / re - occurring errors at this level are more serious . 
 + long now = System . currentTimeMillis ( ) ; 
 + if ( lastError - now < 3000 ) { 
 + recurringErrors + + ; 
 + } else { 
 + recurringErrors = 1 ; 
 + } 
 + lastError = now ; 
 + 
 + if ( recurringErrors = = 5 ) { 
 + session . stop ( ) ; / / Abort session , some error that should be temporary keeps happening . 
 + return false ; 
 + } else { 
 + session . bind ( ) ; 
 + return true ; 
 + } 
 } 
 }

NEAREST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index 1912025 . . 4d02c8a 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * Fixed unchecked cast warnings when building with Realm . 
 * Cleaned up examples ( remove old test project ) . 
 * Added checking for missing generic type in RealmList fields in annotation processor . 
 + * Support async queries 
 
 0 . 80 . 3 
 * Calling Realm . copyToRealmOrUpdate ( ) with an object with a null primary key now throws a proper exception . 
 diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 index bb26d54 . . 3cad125 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 @ @ - 14 , 12 + 14 , 14 @ @ 
 * limitations under the License . 
 * / 
 
 + # include < realm / group _ shared . hpp > 
 # include " util . hpp " 
 # include " io _ realm _ internal _ TableQuery . h " 
 # include " tablequery . hpp " 
 
 using namespace realm ; 
 
 + # define SG ( ptr ) reinterpret _ cast < SharedGroup * > ( ptr ) 
 # if 1 
 # define COL _ TYPE _ VALID ( env , ptr , col , type ) TBL _ AND _ COL _ INDEX _ AND _ TYPE _ VALID ( env , ptr , col , type ) 
 # define COL _ TYPE _ LINK _ OR _ LINKLIST ( env , ptr , col ) TBL _ AND _ COL _ INDEX _ AND _ LINK _ OR _ LINKLIST ( env , ptr , col ) 
 @ @ - 1174 , 3 + 1176 , 47 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNull ( 
 pQuery - > and _ query ( query ) ; 
 } CATCH _ STD ( ) 
 } 
 + 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover 
 + ( JNIEnv * env , jobject , jlong callerSharedGrpPtr , jlong bgSharedGroupPtr , jlong nativeQueryPtr , jlong start , jlong end , jlong limit ) 
 + { 
 + Query * pQuery = Q ( nativeQueryPtr ) ; 
 + Table * pTable = pQuery - > get _ table ( ) . get ( ) ; 
 + if ( ! QUERY _ VALID ( env , pQuery ) | | 
 + ! ROW _ INDEXES _ VALID ( env , pTable , start , end , limit ) ) 
 + return - 1 ; 
 + try { 
 + TableView * pResultView = new TableView ( pQuery - > find _ all ( S ( start ) , S ( end ) , S ( limit ) ) ) ; 
 + std : : unique _ ptr < SharedGroup : : Handover < TableView > > handover ; 
 + handover . reset ( SG ( bgSharedGroupPtr ) - > export _ for _ handover ( * pResultView , ConstSourcePayload : : Copy ) ) ; 
 + / / TODO reimplement this so the call to ' export _ for _ handover ' is done on a background thread 
 + / / and ' import _ from _ handover ' on the caller thread . 
 + / / 
 + / / According to core , it ' s preferable to return first the exported handover 
 + / / then import it from the calling SharedGroup ( Thread ) . 
 + / / We need to make sure to check that the version id ( version of the shared group used to perform the query ) 
 + / / is the same as the caller SharedGroup , otherwise the import will fail . In this case , we should 
 + / / either retry the entire query , or call again ' sync _ if _ needed ' on the TableView to re - query , at this point 
 + / / we need to export again the handover to the caller SharedGroup , until we converge 
 + / / ( i . e the version of the caller SharedGroup matches the version returned by the handover TableView ) 
 + / / 
 + / / Note : The mode ' ConstSourcePayload : : Copy ' handover perform a deep copy of the TableView , this means that we copy 
 + / / both the Payload ( row accessors ) & the Query 
 + / / 
 + / / The mode ' ConstSourcePayload : : Stay ' handover perform a copy of the Query only ( no payload ) 
 + / / The mode ' MutableSourcePayload : : Move ' handover perform a move of both the Payload & Query 
 + / / 
 + / / The expensive operations are in that order 
 + / / pQuery - > find _ all > > export _ for _ handover > > import _ from _ handover 
 + / / so it ' s recommended to run the ' query ' & the ' export ' on a background Thread , then 
 + / / call ' import _ from _ handover ' on the caller thread ( most of the time UI thread ) . 
 + / / calling ' import _ from _ handover ' on the UI thread has another benefit , it will block the SharedGroup 
 + / / from modifying it ' s state ( advance _ read , promote _ write , rollback , commit etc ) 
 + / / 
 + / / The handover pointer is Thread safe , it can be passed from different Threads ( using different SharedGroups ) 
 + 
 + TableView * tv ( SG ( callerSharedGrpPtr ) - > import _ from _ handover ( handover . release ( ) ) ) ; 
 + return reinterpret _ cast < jlong > ( tv ) ; 
 + } CATCH _ STD ( ) 
 + return - 1 ; 
 + } 
 diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 index 5ccb9ee . . 97a9ed7 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 @ @ - 369 , 6 + 369 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAll 
 
 / * 
 * Class : io _ realm _ internal _ TableQuery 
 + * Method : nativeFindAllWithHandover 
 + * Signature : ( JJJJJJ ) J 
 + * / 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover 
 + ( JNIEnv * , jobject , jlong , jlong , jlong , jlong , jlong , jlong ) ; 
 + 
 + / * 
 + * Class : io _ realm _ internal _ TableQuery 
 * Method : nativeSumInt 
 * Signature : ( JJJJJ ) J 
 * / 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 new file mode 100644 
 index 0000000 . . 162e33a 
 - - - / dev / null 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 0 , 0 + 1 , 151 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm ; 
 + 
 + import android . os . Looper ; 
 + import android . test . InstrumentationTestCase ; 
 + 
 + import junit . framework . AssertionFailedError ; 
 + 
 + import java . util . Date ; 
 + import java . util . concurrent . CountDownLatch ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Executors ; 
 + 
 + import io . realm . entities . AllTypes ; 
 + import io . realm . entities . NonLatinFieldNames ; 
 + 
 + public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 + 
 + / / TODO use Junit4 & define a rule to setup the threading , to avoid 
 + / / this boiler plat code , or use a custom test runner 
 + public void testFindAll ( ) throws Throwable { 
 + / / We need to control precisely which Looper / Thread our Realm 
 + / / will operate on . This is unfortunately not possible when using the 
 + / / current Instrumentation # InstrumentationThread , because InstrumentationTestRunner # onStart 
 + / / Call Looper . prepare ( ) for us and surprisingly doesn ' t call Looper # loop ( ) , this is problematic 
 + / / as the async query callback will not run ( because the Handler is sending Runnables to a Looper 
 + / / that didn ' t loop . 
 + / / 
 + / / In the other hand , using a dedicated ' ExecutorService ' will allow us to fine grain control the 
 + / / desired behaviour 
 + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final Looper [ ] looper = new Looper [ 1 ] ; 
 + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + executorService . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + looper [ 0 ] = Looper . myLooper ( ) ; 
 + Realm realm = null ; 
 + try { 
 + realm = openRealmInstance ( ) ; 
 + populateTestRealm ( realm , 10 ) ; 
 + 
 + / / async query ( will run on different thread ) 
 + realm . asyncWhere ( AllTypes . class , 
 + new Realm . AsyncCallback < RealmResults < AllTypes > > ( ) { 
 + @ Override 
 + public void onSuccess ( RealmResults < AllTypes > results ) { 
 + try { 
 + assertEquals ( 10 , results . size ( ) ) ; 
 + 
 + / / Make sure access to RealmObject will not throw an Exception 
 + for ( int i = 0 , size = results . size ( ) ; i < size ; i + + ) { 
 + assertEquals ( i , results . get ( i ) . getColumnLong ( ) ) ; 
 + } 
 + 
 + } catch ( AssertionFailedError e ) { 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + / / whatever happened , make sure to notify the waiting TestCase Thread 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onError ( Throwable t ) { 
 + try { 
 + threadAssertionError [ 0 ] = t ; 
 + t . printStackTrace ( ) ; 
 + } finally { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + } ) 
 + . between ( " columnLong " , 0 , 9 ) . findAll ( ) ; 
 + 
 + Looper . loop ( ) ; / / ready to receive callback 
 + 
 + } finally { 
 + if ( realm ! = null ) { 
 + realm . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + / / wait until the callback of our async query proceed 
 + signalCallbackFinished . await ( ) ; 
 + looper [ 0 ] . quit ( ) ; 
 + executorService . shutdownNow ( ) ; 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / Throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + } 
 + 
 + / / * * * Helper methods * * * 
 + 
 + / / This could be done from # setUp but then we can ' t control 
 + / / which Looper we want to associate this Realm instance with 
 + private Realm openRealmInstance ( ) { 
 + RealmConfiguration realmConfiguration = new RealmConfiguration . 
 + Builder ( getInstrumentation ( ) 
 + . getTargetContext ( ) ) 
 + . name ( " test . realm " ) 
 + . deleteRealmIfMigrationNeeded ( ) 
 + . build ( ) ; 
 + Realm . deleteRealm ( realmConfiguration ) ; 
 + return Realm . getInstance ( realmConfiguration ) ; 
 + } 
 + 
 + private void populateTestRealm ( final Realm testRealm , int objects ) { 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . allObjects ( AllTypes . class ) . clear ( ) ; 
 + testRealm . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; 
 + for ( int i = 0 ; i < objects ; + + i ) { 
 + AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; 
 + allTypes . setColumnBoolean ( ( i % 3 ) = = 0 ) ; 
 + allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; 
 + allTypes . setColumnDate ( new Date ( ) ) ; 
 + allTypes . setColumnDouble ( 3 . 1415 ) ; 
 + allTypes . setColumnFloat ( 1 . 234567f + i ) ; 
 + allTypes . setColumnString ( " test data " + i ) ; 
 + allTypes . setColumnLong ( i ) ; 
 + NonLatinFieldNames nonLatinFieldNames = testRealm . createObject ( NonLatinFieldNames . class ) ; 
 + nonLatinFieldNames . set 델 타 ( i ) ; 
 + nonLatinFieldNames . set Δ έ λ τ α ( i ) ; 
 + nonLatinFieldNames . set 베 타 ( 1 . 234567f + i ) ; 
 + nonLatinFieldNames . set Β ή τ α ( 1 . 234567f + i ) ; 
 + } 
 + testRealm . commitTransaction ( ) ; 
 + testRealm . refresh ( ) ; 
 + } 
 + } 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index ca29295 . . d2e5033 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 22 , 7 + 22 , 6 @ @ import org . json . JSONArray ; 
 import org . json . JSONException ; 
 import org . json . JSONObject ; 
 
 - import java . io . ByteArrayInputStream ; 
 import java . io . File ; 
 import java . io . IOException ; 
 import java . io . InputStream ; 
 diff - - git a / realm / src / main / java / io / realm / AsyncRealmQueryResult . java b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java 
 new file mode 100644 
 index 0000000 . . 7318359 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java 
 @ @ - 0 , 0 + 1 , 25 @ @ 
 + package io . realm ; 
 + 
 + import java . util . concurrent . Future ; 
 + 
 + / * * 
 + * Represents the result of an asynchronous Realm query . 
 + * 
 + * Users are responsible of maintaining a reference to { @ code AsyncRealmQueryResult } in order 
 + * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the 
 + * query will post the result to the caller ' s thread callback ) 
 + * / 
 + public class AsyncRealmQueryResult { 
 + final Future < ? > pendingQuery ; 
 + 
 + public AsyncRealmQueryResult ( Future < ? > pendingQuery ) { 
 + this . pendingQuery = pendingQuery ; 
 + } 
 + 
 + / * * 
 + * Attempts to cancel execution of this queries . 
 + * / 
 + public void cancel ( ) { 
 + pendingQuery . cancel ( true ) ; 
 + } 
 + } 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index ddbc022 . . 15aac8b 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 63 , 6 + 63 , 7 @ @ import io . realm . internal . SharedGroup ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableView ; 
 import io . realm . internal . Util ; 
 + import io . realm . internal . android . AsyncRealmQuery ; 
 import io . realm . internal . android . DebugAndroidLogger ; 
 import io . realm . internal . android . ReleaseAndroidLogger ; 
 import io . realm . internal . log . RealmLog ; 
 @ @ - 154 , 6 + 155 , 9 @ @ public final class Realm implements Closeable { 
 private static final Map < String , AtomicInteger > globalOpenInstanceCounter = 
 new ConcurrentHashMap < String , AtomicInteger > ( ) ; 
 
 + / / Thread Pool for all async operations ( Query & Write transaction ) 
 + public static final ExecutorService asyncQueryExecutor = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) * 2 + 1 ) ; 
 + 
 protected static final Map < Handler , String > handlers = new ConcurrentHashMap < Handler , String > ( ) ; 
 private static final int REALM _ CHANGED = 14930352 ; / / Hopefully it won ' t clash with other message IDs . 
 
 @ @ - 1198 , 6 + 1202 , 20 @ @ public final class Realm implements Closeable { 
 } 
 
 / * * 
 + * Prepare an async query 
 + * TODO point to documentation or example about async query 
 + * @ param clazz The class of the object which is to be queried for 
 + * @ return A typed RealmQuery , which can be used to query for specific objects of this type 
 + * @ throws java . lang . RuntimeException Any other error 
 + * @ see io . realm . RealmQuery 
 + * @ param callback 
 + * / 
 + public < E extends RealmObject > AsyncRealmQuery < E > asyncWhere ( Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { 
 + checkIfValid ( ) ; 
 + return new AsyncRealmQuery < E > ( this , clazz , callback ) ; 
 + } 
 + 
 + / * * 
 * Get all objects of a specific Class . If no objects exist , the returned RealmResults will not 
 * be null . The RealmResults . size ( ) to check the number of objects instead . 
 * 
 @ @ - 1872 , 4 + 1890 , 24 @ @ public final class Realm implements Closeable { 
 void execute ( Realm realm ) ; 
 } 
 
 + / * * 
 + * Encapsulates an async { @ link RealmQuery } . 
 + * < p > 
 + * This will run the { @ link RealmQuery } on a worker thread , then invoke this callback on the caller thread 
 + * / 
 + public interface AsyncCallback < T extends RealmResults < ? extends RealmObject > > { 
 + void onSuccess ( T results ) ; 
 + void onError ( Throwable t ) ; 
 + } 
 + 
 + 
 + / / FIXME Realm . java being the public API and the implementation . 
 + / / we need a Realm interface to be able to separate this kind of call 
 + / / ( mostly from internal API / tests that need to access private field / method ) . 
 + / / RealmImpl will be accessible to other internal packages 
 + / / but not to the user ( avoid compromising our exposed public API ) 
 + / / 
 + public long getSharedGroupPtr ( ) { 
 + return sharedGroup . nativePtr ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index df847f5 . . b744adc 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1302 , 4 + 1302 , 8 @ @ public class RealmQuery < E extends RealmObject > { 
 return null ; 
 } 
 } 
 + 
 + protected TableQuery getTableQuery ( ) { 
 + return this . query ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / internal / TableQuery . java b / realm / src / main / java / io / realm / internal / TableQuery . java 
 index e82eaa7 . . 268645d 100644 
 - - - a / realm / src / main / java / io / realm / internal / TableQuery . java 
 + + + b / realm / src / main / java / io / realm / internal / TableQuery . java 
 @ @ - 493 , 8 + 493 , 24 @ @ public class TableQuery implements Closeable { 
 } 
 } 
 
 - protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; 
 + public TableView findAllWithHandover ( long callerSharedGroupPtr , long bgSharedGroupPtr ) { 
 + validateQuery ( ) ; 
 + 
 + / / Execute the disposal of abandoned realm objects each time a new realm object is created 
 + context . executeDelayedDisposal ( ) ; 
 + long nativeViewPtr = nativeFindAllWithHandover ( callerSharedGroupPtr , bgSharedGroupPtr , nativePtr , 0 , Table . INFINITE , Table . INFINITE ) ; / / nativeViewPtr is created from bg Thread 
 + / / handover nativeViewPtr to UI Thread 
 + 
 + try { 
 + return new TableView ( this . context , this . parent , nativeViewPtr ) ; 
 + } catch ( RuntimeException e ) { 
 + TableView . nativeClose ( nativeViewPtr ) ; 
 + throw e ; 
 + } 
 + } 
 
 + protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; 
 + protected native long nativeFindAllWithHandover ( long nativeCallerSharedGroupPtr , long bgSharedGroupPtr , long nativeQueryPtr , long start , long end , long limit ) ; 
 / / 
 / / Aggregation methods 
 / / 
 diff - - git a / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java 
 new file mode 100644 
 index 0000000 . . c3716eb 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java 
 @ @ - 0 , 0 + 1 , 165 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . android ; 
 + 
 + import android . os . Handler ; 
 + import android . os . Looper ; 
 + import android . os . Message ; 
 + 
 + import java . util . concurrent . Future ; 
 + 
 + import io . realm . AsyncRealmQueryResult ; 
 + import io . realm . Realm ; 
 + import io . realm . RealmConfiguration ; 
 + import io . realm . RealmObject ; 
 + import io . realm . RealmQuery ; 
 + import io . realm . RealmResults ; 
 + import io . realm . internal . TableOrView ; 
 + import io . realm . internal . TableView ; 
 + 
 + import static io . realm . Realm . asyncQueryExecutor ; 
 + 
 + / * * 
 + * A helper class to help make handling asynchronous { @ link RealmQuery } easier . 
 + * 
 + * @ param < E > type of the object which is to be queried for 
 + * / 
 + / / Behaviour may change , user should not subclass 
 + public final class AsyncRealmQuery < E extends RealmObject > { 
 + private final Realm callerRealm ; 
 + private final Class < E > clazz ; 
 + private final Realm . AsyncCallback < RealmResults < E > > callback ; 
 + 
 + private int from ; 
 + private int to ; 
 + private String fieldName ; 
 + private EventHandler eventHandler ; 
 + private Future < ? > pendingQuery ; 
 + 
 + / * * 
 + * Create an { @ code AsyncRealmQuery } instance . 
 + * 
 + * @ param realm The realm to query within . 
 + * @ param clazz The class to query . 
 + * @ param callback invoked on the thread { @ link Realm # asyncWhere ( Class , Realm . AsyncCallback ) } was called from , to post results . 
 + * / 
 + public AsyncRealmQuery ( Realm realm , Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { 
 + this . callerRealm = realm ; 
 + this . callback = callback ; 
 + this . clazz = clazz ; 
 + } 
 + 
 + / * * 
 + * Between condition 
 + * 
 + * @ param fieldName The field to compare 
 + * @ param from Lowest value ( inclusive ) 
 + * @ param to Highest value ( inclusive ) 
 + * @ return current instance of { @ code AsyncRealmQuery } for method chaining 
 + * / 
 + public AsyncRealmQuery < E > between ( String fieldName , int from , int to ) { 
 + this . from = from ; 
 + this . to = to ; 
 + this . fieldName = fieldName ; 
 + return this ; 
 + } 
 + 
 + / * * 
 + * Find all objects that fulfill the query conditions . 
 + * Results will be posted to the callback instance { @ link io . realm . Realm . AsyncCallback } asynchronously 
 + * If no objects match the condition , a list with zero objects is returned . 
 + * 
 + * @ see io . realm . RealmResults 
 + * / 
 + public AsyncRealmQueryResult findAll ( ) { 
 + / / will use the Looper of the caller thread to post the result 
 + Looper looper ; 
 + if ( ( looper = Looper . myLooper ( ) ) ! = null ) { 
 + eventHandler = new EventHandler ( looper ) ; 
 + } else if ( ( looper = Looper . getMainLooper ( ) ) ! = null ) { 
 + eventHandler = new EventHandler ( looper ) ; 
 + } else { 
 + eventHandler = null ; / / FIXME define strategy / behaviour for regular JVM call 
 + } 
 + 
 + / / We need a pointer to the caller Realm , to be able to handover the result to it 
 + final long callerSharedGroupNativePtr = callerRealm . getSharedGroupPtr ( ) ; 
 + 
 + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) 
 + / / to perform the query 
 + final RealmConfiguration realmConfiguration = callerRealm . getConfiguration ( ) ; 
 + 
 + pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + try { 
 + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 + 
 + / / TODO This will probably be replace by a kind of ' QueryBuilder ' 
 + / / that holds all the operations ( predicates / filters ) then 
 + / / replay them here in this background thread . The current implementation 
 + / / call Core for each step , we want to limit the overhead by sending one 
 + / / single call to Core with all the parameters . 
 + 
 + TableView tv = new RealmQueryAdapter < E > ( bgRealm , clazz ) 
 + . between ( fieldName , from , to ) 
 + . findAll ( callerSharedGroupNativePtr , bgRealm . getSharedGroupPtr ( ) ) ; 
 + 
 + bgRealm . close ( ) ; 
 + 
 + / / send results to the caller thread ' s callback 
 + if ( ! pendingQuery . isCancelled ( ) ) { 
 + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ SUCCESS , tv ) ; 
 + eventHandler . sendMessage ( msg ) ; 
 + } 
 + 
 + } catch ( Exception e ) { 
 + if ( ! pendingQuery . isCancelled ( ) ) { 
 + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ ERROR , e ) ; 
 + eventHandler . sendMessage ( msg ) ; 
 + } 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + return new AsyncRealmQueryResult ( pendingQuery ) ; 
 + } 
 + 
 + private class EventHandler extends Handler { 
 + private static final int MSG _ SUCCESS = 1 ; 
 + private static final int MSG _ ERROR = MSG _ SUCCESS + 1 ; 
 + 
 + public EventHandler ( Looper looper ) { 
 + super ( looper ) ; 
 + } 
 + 
 + @ Override 
 + public void handleMessage ( Message msg ) { 
 + switch ( msg . what ) { 
 + case MSG _ SUCCESS : 
 + RealmResults < E > resultList = new RealmResults < E > ( callerRealm , ( TableOrView ) msg . obj , clazz ) ; 
 + callback . onSuccess ( resultList ) ; 
 + break ; 
 + case MSG _ ERROR : 
 + callback . onError ( ( Throwable ) msg . obj ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java 
 new file mode 100644 
 index 0000000 . . acac317 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java 
 @ @ - 0 , 0 + 1 , 38 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . android ; 
 + 
 + import io . realm . Realm ; 
 + import io . realm . RealmObject ; 
 + import io . realm . RealmQuery ; 
 + import io . realm . internal . TableView ; 
 + 
 + class RealmQueryAdapter < E extends RealmObject > extends RealmQuery < E > { 
 + public RealmQueryAdapter ( Realm realm , Class < E > clazz ) { 
 + super ( realm , clazz ) ; 
 + } 
 + 
 + @ Override 
 + public RealmQueryAdapter < E > between ( String fieldName , int from , int to ) { 
 + super . between ( fieldName , from , to ) ; 
 + return this ; 
 + } 
 + 
 + public TableView findAll ( long callerRealmPtr , long backgroundRealmPtr ) { 
 + return getTableQuery ( ) . findAllWithHandover ( callerRealmPtr , backgroundRealmPtr ) ; 
 + } 
 + }
