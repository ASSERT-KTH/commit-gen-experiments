BLEU SCORE: 0.010697691669654345

TEST MSG: Add support for Connection State listeners
GENERATED MSG: POC async query , using Core ' fsa _ handover _ demo ' branch

TEST DIFF (one line): diff - - git a / CHANGELOG . md b / CHANGELOG . md <nl> index 7f4774b . . dd33ec9 100644 <nl> - - - a / CHANGELOG . md <nl> + + + b / CHANGELOG . md <nl> @ @ - 1 , 3 + 1 , 16 @ @ <nl> + # # 5 . 5 . 0 ( YYYY - MM - DD ) <nl> + <nl> + # # # Enhancements <nl> + <nl> + * [ ObjectServer ] Added ` ConnectionState ` enum describing the states a connection can be in . <nl> + * [ ObjectServer ] Added ` SyncSession . isConnected ( ) ` . <nl> + * [ ObjectServer ] Added support for observing connection changes for a session using ` SyncSession . addConnectionChangeListener ( ) ` and ` SyncSession . removeConnectionChangeListener ( ) ` . <nl> + <nl> + # # # Internal <nl> + <nl> + * Updated to Object Store commit : 97fd03819f398b3c81c8b007feaca8636629050b <nl> + <nl> + <nl> # # 5 . 4 . 2 ( 2018 - 08 - 09 ) <nl> <nl> # # # Bug Fixes <nl> diff - - git a / examples / settings . gradle b / examples / settings . gradle <nl> index 4a5ac90 . . 15f6d6c 100644 <nl> - - - a / examples / settings . gradle <nl> + + + b / examples / settings . gradle <nl> @ @ - 15 , 4 + 15 , 3 @ @ include ' threadExample ' <nl> include ' unitTestExample ' <nl> include ' objectServerExample ' <nl> include ' multiprocessExample ' <nl> - <nl> diff - - git a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java <nl> index 458807b . . 6ea9d49 100644 <nl> - - - a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java <nl> + + + b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java <nl> @ @ - 457 , 4 + 457 , 16 @ @ public class SessionTests { <nl> " No SyncSession found using the path : " ) ) ; <nl> } <nl> } <nl> + <nl> + @ Test <nl> + public void isConnected _ falseForInvalidUser ( ) { <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + SyncSession session = SyncManager . getSession ( configuration ) ; <nl> + try { <nl> + assertFalse ( session . isConnected ( ) ) ; <nl> + } finally { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> } <nl> diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp b / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp <nl> index 20c8f76 . . 140e8e5 100644 <nl> - - - a / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp <nl> + + + b / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp <nl> @ @ - 47 , 8 + 47 , 15 @ @ static _ assert ( SyncSession : : PublicState : : Dying = = <nl> static _ assert ( SyncSession : : PublicState : : Inactive = = <nl> static _ cast < SyncSession : : PublicState > ( io _ realm _ SyncSession _ STATE _ VALUE _ INACTIVE ) , <nl> " " ) ; <nl> - static _ assert ( SyncSession : : PublicState : : Error = = <nl> - static _ cast < SyncSession : : PublicState > ( io _ realm _ SyncSession _ STATE _ VALUE _ ERROR ) , <nl> + <nl> + static _ assert ( SyncSession : : ConnectionState : : Disconnected = = <nl> + static _ cast < SyncSession : : ConnectionState > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ DISCONNECTED ) , <nl> + " " ) ; <nl> + static _ assert ( SyncSession : : ConnectionState : : Connecting = = <nl> + static _ cast < SyncSession : : ConnectionState > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTING ) , <nl> + " " ) ; <nl> + static _ assert ( SyncSession : : ConnectionState : : Connected = = <nl> + static _ cast < SyncSession : : ConnectionState > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTED ) , <nl> " " ) ; <nl> <nl> JNIEXPORT jboolean JNICALL Java _ io _ realm _ SyncSession _ nativeRefreshAccessToken ( JNIEnv * env , jclass , <nl> @ @ - 229 , 11 + 236 , 97 @ @ JNIEXPORT jbyte JNICALL Java _ io _ realm _ SyncSession _ nativeGetState ( JNIEnv * env , jc <nl> return io _ realm _ SyncSession _ STATE _ VALUE _ DYING ; <nl> case SyncSession : : PublicState : : Inactive : <nl> return io _ realm _ SyncSession _ STATE _ VALUE _ INACTIVE ; <nl> - case SyncSession : : PublicState : : Error : <nl> - return io _ realm _ SyncSession _ STATE _ VALUE _ ERROR ; <nl> } <nl> } <nl> } <nl> CATCH _ STD ( ) <nl> return - 1 ; <nl> } <nl> + <nl> + JNIEXPORT jbyte JNICALL Java _ io _ realm _ SyncSession _ nativeGetConnectionState ( JNIEnv * env , jclass , jstring j _ local _ realm _ path ) <nl> + { <nl> + TR _ ENTER ( ) <nl> + try { <nl> + JStringAccessor local _ realm _ path ( env , j _ local _ realm _ path ) ; <nl> + auto session = SyncManager : : shared ( ) . get _ existing _ session ( local _ realm _ path ) ; <nl> + <nl> + if ( session ) { <nl> + switch ( session - > connection _ state ( ) ) { <nl> + case SyncSession : : ConnectionState : : Disconnected : <nl> + return io _ realm _ SyncSession _ CONNECTION _ VALUE _ DISCONNECTED ; <nl> + case SyncSession : : ConnectionState : : Connecting : <nl> + return io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTING ; <nl> + case SyncSession : : ConnectionState : : Connected : <nl> + return io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTED ; <nl> + } <nl> + } <nl> + } <nl> + CATCH _ STD ( ) <nl> + return - 1 ; <nl> + } <nl> + <nl> + static jlong get _ connection _ value ( SyncSession : : ConnectionState state ) { <nl> + switch ( state ) { <nl> + case SyncSession : : ConnectionState : : Disconnected : return static _ cast < jlong > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ DISCONNECTED ) ; <nl> + case SyncSession : : ConnectionState : : Connecting : return static _ cast < jlong > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTING ) ; <nl> + case SyncSession : : ConnectionState : : Connected : return static _ cast < jlong > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTED ) ; <nl> + } <nl> + return static _ cast < jlong > ( - 1 ) ; <nl> + } <nl> + <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ SyncSession _ nativeAddConnectionListener ( JNIEnv * env , jclass , jstring j _ local _ realm _ path ) <nl> + { <nl> + try { <nl> + / / JNIEnv is thread confined , so we need a deep copy in order to capture the string in the lambda <nl> + std : : string local _ realm _ path ( JStringAccessor ( env , j _ local _ realm _ path ) ) ; <nl> + std : : shared _ ptr < SyncSession > session = SyncManager : : shared ( ) . get _ existing _ session ( local _ realm _ path ) ; <nl> + if ( ! session ) { <nl> + / / FIXME : We should lift this restriction <nl> + ThrowException ( env , IllegalState , <nl> + " Cannot register a connection listener before a session is " <nl> + " created . A session will be created after the first call to Realm . getInstance ( ) . " ) ; <nl> + return 0 ; <nl> + } <nl> + <nl> + static JavaClass java _ syncmanager _ class ( env , " io / realm / SyncManager " ) ; <nl> + static JavaMethod java _ notify _ connection _ listener ( env , java _ syncmanager _ class , " notifyConnectionListeners " , " ( Ljava / lang / String ; JJ ) V " , true ) ; <nl> + <nl> + std : : function < SyncSession : : ConnectionStateCallback > callback = [ local _ realm _ path ] ( SyncSession : : ConnectionState old _ state , SyncSession : : ConnectionState new _ state ) { <nl> + JNIEnv * local _ env = jni _ util : : JniUtils : : get _ env ( true ) ; <nl> + <nl> + jlong old _ connection _ value = get _ connection _ value ( old _ state ) ; <nl> + jlong new _ connection _ value = get _ connection _ value ( new _ state ) ; <nl> + <nl> + JavaLocalRef < jstring > path ( local _ env , to _ jstring ( local _ env , local _ realm _ path ) ) ; <nl> + local _ env - > CallStaticVoidMethod ( java _ syncmanager _ class , java _ notify _ connection _ listener , path . get ( ) , <nl> + old _ connection _ value , new _ connection _ value ) ; <nl> + <nl> + / / All exceptions will be caught on the Java side of handlers , but Errors will still end <nl> + / / up here , so we need to do something sensible with them . <nl> + / / Throwing a C + + exception will terminate the sync thread and cause the pending Java <nl> + / / exception to become visible . For some ( unknown ) reason Logcat will not see the C + + <nl> + / / exception , only the Java one . <nl> + if ( local _ env - > ExceptionCheck ( ) ) { <nl> + local _ env - > ExceptionDescribe ( ) ; <nl> + throw std : : runtime _ error ( " An unexpected Error was thrown from Java . See LogCat " ) ; <nl> + } <nl> + } ; <nl> + uint64 _ t token = session - > register _ connection _ change _ callback ( callback ) ; <nl> + return static _ cast < jlong > ( token ) ; <nl> + } <nl> + CATCH _ STD ( ) <nl> + return 0 ; <nl> + } <nl> + <nl> + JNIEXPORT void JNICALL Java _ io _ realm _ SyncSession _ nativeRemoveConnectionListener ( JNIEnv * env , jclass , jlong listener _ id , jstring j _ local _ realm _ path ) <nl> + { <nl> + try { <nl> + / / JNIEnv is thread confined , so we need a deep copy in order to capture the string in the lambda <nl> + std : : string local _ realm _ path ( JStringAccessor ( env , j _ local _ realm _ path ) ) ; <nl> + std : : shared _ ptr < SyncSession > session = SyncManager : : shared ( ) . get _ existing _ session ( local _ realm _ path ) ; <nl> + if ( session ) { <nl> + session - > unregister _ connection _ change _ callback ( static _ cast < uint64 _ t > ( listener _ id ) ) ; <nl> + } <nl> + } <nl> + CATCH _ STD ( ) <nl> + } <nl> diff - - git a / realm / realm - library / src / main / cpp / object - store b / realm / realm - library / src / main / cpp / object - store <nl> index 58f1066 . . 97fd038 160000 <nl> - - - a / realm / realm - library / src / main / cpp / object - store <nl> + + + b / realm / realm - library / src / main / cpp / object - store <nl> @ @ - 1 + 1 @ @ <nl> - Subproject commit 58f106676f96d0a5dcb52b6d705cf20db797d5c6 <nl> + Subproject commit 97fd03819f398b3c81c8b007feaca8636629050b <nl> diff - - git a / realm / realm - library / src / objectServer / java / io / realm / ConnectionListener . java b / realm / realm - library / src / objectServer / java / io / realm / ConnectionListener . java <nl> new file mode 100644 <nl> index 0000000 . . 43bed18 <nl> - - - / dev / null <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / ConnectionListener . java <nl> @ @ - 0 , 0 + 1 , 39 @ @ <nl> + / * <nl> + * Copyright 2018 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package io . realm ; <nl> + <nl> + / * * <nl> + * Interface used when reporting changes that happened to the connection used by the session . <nl> + * < p > <nl> + * Multiple sessions might re - use the same connection . In that case , any connection <nl> + * change will be reported to all sessions . <nl> + * < p > <nl> + * If a disconnect happened due to an error , that error will be reported to the sessions <nl> + * { @ link io . realm . SyncSession . ErrorHandler } . <nl> + * <nl> + * @ see SyncSession # isConnected ( ) <nl> + * @ see SyncConfiguration . Builder # errorHandler ( SyncSession . ErrorHandler ) <nl> + * / <nl> + public interface ConnectionListener { <nl> + <nl> + / * * <nl> + * A change in the connection to the server was detected . <nl> + * <nl> + * @ param oldState the state the connection transitioned from . <nl> + * @ param newState the state the connection transitioned to . <nl> + * / <nl> + void onChange ( ConnectionState oldState , ConnectionState newState ) ; <nl> + } <nl> diff - - git a / realm / realm - library / src / objectServer / java / io / realm / ConnectionState . java b / realm / realm - library / src / objectServer / java / io / realm / ConnectionState . java <nl> new file mode 100644 <nl> index 0000000 . . e603160 <nl> - - - / dev / null <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / ConnectionState . java <nl> @ @ - 0 , 0 + 1 , 59 @ @ <nl> + / * <nl> + * Copyright 2018 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm ; <nl> + <nl> + / * * <nl> + * Enum describing the states of the underlying connection used by a { @ link SyncSession } . <nl> + * / <nl> + public enum ConnectionState { <nl> + <nl> + / * * <nl> + * No connection to the server exists . No data is being transferred even if the session <nl> + * is { @ link SyncSession . State # ACTIVE } . If the connection entered this state due to an error , this <nl> + * error will be reported to the { @ link SyncSession . ErrorHandler } . <nl> + * / <nl> + DISCONNECTED ( SyncSession . CONNECTION _ VALUE _ DISCONNECTED ) , <nl> + <nl> + / * * <nl> + * A connection is currently in progress of being established . If successful the next <nl> + * state is { @ link # CONNECTED } . If the connection fails it will be { @ link # DISCONNECTED } . <nl> + * / <nl> + CONNECTING ( SyncSession . CONNECTION _ VALUE _ CONNECTING ) , <nl> + <nl> + / * * <nl> + * A connection was successfully established to the server . If the SyncSession is { @ link SyncSession . State # ACTIVE } <nl> + * data will now be transferred between the device and the server . <nl> + * / <nl> + CONNECTED ( SyncSession . CONNECTION _ VALUE _ CONNECTED ) ; <nl> + <nl> + final int value ; <nl> + <nl> + ConnectionState ( int value ) { <nl> + this . value = value ; <nl> + } <nl> + <nl> + static ConnectionState fromNativeValue ( long value ) { <nl> + ConnectionState [ ] stateCodes = values ( ) ; <nl> + for ( ConnectionState state : stateCodes ) { <nl> + if ( state . value = = value ) { <nl> + return state ; <nl> + } <nl> + } <nl> + <nl> + throw new IllegalArgumentException ( " Unknown connection state code : " + value ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncManager . java b / realm / realm - library / src / objectServer / java / io / realm / SyncManager . java <nl> index 390e447 . . ce556da 100644 <nl> - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncManager . java <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncManager . java <nl> @ @ - 401 , 6 + 401 , 22 @ @ public class SyncManager { <nl> } <nl> <nl> / * * <nl> + * Called from native code . This method is not allowed to throw as it would be swallowed <nl> + * by the native Sync Client thread . Instead log all exceptions to logcat . <nl> + * / <nl> + @ SuppressWarnings ( " unused " ) <nl> + private static synchronized void notifyConnectionListeners ( String localRealmPath , long oldState , long newState ) { <nl> + SyncSession session = sessions . get ( localRealmPath ) ; <nl> + if ( session ! = null ) { <nl> + try { <nl> + session . notifyConnectionListeners ( ConnectionState . fromNativeValue ( oldState ) , ConnectionState . fromNativeValue ( newState ) ) ; <nl> + } catch ( Exception exception ) { <nl> + RealmLog . error ( exception ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> * This is called from the Object Store ( through JNI ) to request an { @ code access _ token } for <nl> * the session specified by sessionPath . <nl> * <nl> diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java <nl> index f05656a . . f099649 100644 <nl> - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import java . util . IdentityHashMap ; <nl> import java . util . Iterator ; <nl> import java . util . Locale ; <nl> import java . util . Map ; <nl> + import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . CountDownLatch ; <nl> import java . util . concurrent . Future ; <nl> import java . util . concurrent . ScheduledFuture ; <nl> @ @ - 36 , 6 + 37 , 8 @ @ import java . util . concurrent . atomic . AtomicInteger ; <nl> import java . util . concurrent . atomic . AtomicLong ; <nl> import java . util . concurrent . atomic . AtomicReference ; <nl> <nl> + import javax . annotation . Nullable ; <nl> + <nl> import io . realm . internal . Keep ; <nl> import io . realm . internal . SyncObjectServerFacade ; <nl> import io . realm . internal . Util ; <nl> @ @ - 50 , 15 + 53 , 23 @ @ import io . realm . internal . util . Pair ; <nl> import io . realm . log . RealmLog ; <nl> <nl> / * * <nl> - * This class represents the connection to the Realm Object Server for one { @ link SyncConfiguration } . <nl> + * A session controls how data is synchronized between a single Realm on the device and the server <nl> + * Realm on the Realm Object Server . <nl> * < p > <nl> - * A Session is created by opening a Realm instance using that configuration . Once a session has been created , <nl> + * A Session is created by opening a Realm instance using a { @ link SyncConfiguration } . Once a session has been created , <nl> * it will continue to exist until the app is closed or all threads using this { @ link SyncConfiguration } closes their respective { @ link Realm } s . <nl> * < p > <nl> - * A session is fully controlled by Realm , but can provide additional information in case of errors . <nl> - * It is passed along in all { @ link SyncSession . ErrorHandler } s . <nl> + * A session is controlled by Realm , but can provide additional information in case of errors . <nl> + * These errors are passed along in the { @ link SyncSession . ErrorHandler } . <nl> + * < p > <nl> + * When creating a session , Realm will establish a connection to the server . This connection is <nl> + * controlled by Realm and might be shared between multiple sessions . It is possible to get insight <nl> + * into the connection using { @ link # addConnectionChangeListener ( ConnectionListener ) } and { @ link # isConnected ( ) } . <nl> + * < p > <nl> + * The session itself has a different lifecycle than the underlying connection . The state of the session <nl> + * can be found using { @ link # getState ( ) } . <nl> * < p > <nl> - * This object is thread safe . <nl> + * The { @ link SyncSession } object is thread safe . <nl> * / <nl> @ Keep <nl> public class SyncSession { <nl> @ @ - 101 , 13 + 112 , 67 @ @ public class SyncSession { <nl> private static final byte STATE _ VALUE _ INACTIVE = 3 ; <nl> private static final byte STATE _ VALUE _ ERROR = 4 ; <nl> <nl> + / / List of Java connection change listeners <nl> + private final CopyOnWriteArrayList < ConnectionListener > connectionListeners = new CopyOnWriteArrayList < > ( ) ; <nl> + <nl> + / / Reference to the token representing the native listener for connection changes <nl> + / / Only one native listener is used for all Java listeners <nl> + private long nativeConnectionListenerToken ; <nl> + <nl> + / / represent different states as defined in SyncSession : : PublicConnectionState ' sync _ session . hpp ' <nl> + / / saved here instead of as constants in ConnectionState . java to enable static checking by JNI <nl> + static final byte CONNECTION _ VALUE _ DISCONNECTED = 0 ; <nl> + static final byte CONNECTION _ VALUE _ CONNECTING = 1 ; <nl> + static final byte CONNECTION _ VALUE _ CONNECTED = 2 ; <nl> + <nl> private URI resolvedRealmURI ; <nl> <nl> + / * * <nl> + * Enum describing the states a SyncSession can be in . The initial state is <nl> + * { @ link State # INACTIVE } . <nl> + * < p > <nl> + * A Realm will automatically synchronize data with the server if the session is either { @ link State # ACTIVE } <nl> + * or { @ link State # DYING } and { @ link # isConnected ( ) } returns { @ code true } . <nl> + * / <nl> public enum State { <nl> + <nl> + / * * <nl> + * This is the initial state . The session is closed . No data is being synchronized . The session <nl> + * will automatically transition to { @ link # WAITING _ FOR _ ACCESS _ TOKEN } when a Realm is opened . <nl> + * / <nl> + INACTIVE ( STATE _ VALUE _ INACTIVE ) , <nl> + <nl> + / * * <nl> + * The user is attempting to synchronize data but needs a valid access token to do so . Realm <nl> + * will either use a cached token or automatically try to acquire one based on the current <nl> + * users login . This requires a network connection . <nl> + * < p > <nl> + * Data cannot be synchronized in this state . <nl> + * < p > <nl> + * Once a valid token is acquired , the session will transition to { @ link # ACTIVE } . <nl> + * / <nl> WAITING _ FOR _ ACCESS _ TOKEN ( STATE _ VALUE _ WAITING _ FOR _ ACCESS _ TOKEN ) , <nl> + <nl> + / * * <nl> + * The Realm is open and data will be synchronized between the device and the server <nl> + * if the underlying connection is { @ link ConnectionState # CONNECTED } . <nl> + * < p > <nl> + * The session will remain in this state until either the current login expires or the Realm <nl> + * is closed . In the first case , the session will transition to { @ link # WAITING _ FOR _ ACCESS _ TOKEN } , <nl> + * in the second case , it will become { @ link # DYING } . <nl> + * / <nl> ACTIVE ( STATE _ VALUE _ ACTIVE ) , <nl> + <nl> + / * * <nl> + * The Realm was closed , but still contains data that needs to be synchronized to the server . <nl> + * The session will attempt to upload all local data before going { @ link # INACTIVE } . <nl> + * / <nl> DYING ( STATE _ VALUE _ DYING ) , <nl> - INACTIVE ( STATE _ VALUE _ INACTIVE ) , <nl> + <nl> + / * * <nl> + * DEPRECATED : This is never used . Errors are reported to { @ link ErrorHandler } instead . <nl> + * / <nl> + @ Deprecated <nl> ERROR ( STATE _ VALUE _ ERROR ) ; <nl> <nl> final byte value ; <nl> @ @ - 116 , 7 + 181 , 7 @ @ public class SyncSession { <nl> this . value = value ; <nl> } <nl> <nl> - static State fromByte ( byte value ) { <nl> + static State fromNativeValue ( long value ) { <nl> State [ ] stateCodes = values ( ) ; <nl> for ( State state : stateCodes ) { <nl> if ( state . value = = value ) { <nl> @ @ - 124 , 7 + 189 , 7 @ @ public class SyncSession { <nl> } <nl> } <nl> <nl> - throw new IllegalArgumentException ( " Unknown state code : " + value ) ; <nl> + throw new IllegalArgumentException ( " Unknown session state code : " + value ) ; <nl> } <nl> } <nl> <nl> @ @ - 188 , 14 + 253 , 45 @ @ public class SyncSession { <nl> * @ return the state of the session . <nl> * @ see SyncSession . State <nl> * / <nl> - @ SuppressWarnings ( " unused " ) <nl> public State getState ( ) { <nl> byte state = nativeGetState ( configuration . getPath ( ) ) ; <nl> if ( state = = - 1 ) { <nl> / / session was not found , probably the Realm was closed <nl> throw new IllegalStateException ( " Could not find session , Realm was probably closed " ) ; <nl> } <nl> - return State . fromByte ( state ) ; <nl> + return State . fromNativeValue ( state ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get the current state of the connection used by the session as defined in { @ link ConnectionState } . <nl> + * <nl> + * @ return the state of connection used by the session . <nl> + * @ see ConnectionState <nl> + * / <nl> + public ConnectionState getConnectionState ( ) { <nl> + byte state = nativeGetConnectionState ( configuration . getPath ( ) ) ; <nl> + if ( state = = - 1 ) { <nl> + / / session was not found , probably the Realm was closed <nl> + throw new IllegalStateException ( " Could not find session , Realm was probably closed " ) ; <nl> + } <nl> + return ConnectionState . fromNativeValue ( state ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks if the session is connected to the server and can synchronize data . <nl> + * <nl> + * This is a best guess effort . To conserve battery the underlying implementation uses heartbeats <nl> + * to detect if the connection is still available . So if no data is actively being synced <nl> + * and some time has elapsed since the last heartbeat , the connection could have been dropped but <nl> + * this method will still return { @ code true } . <nl> + * <nl> + * @ return { @ code true } if the session is connected and ready to synchronize data , { @ code false } <nl> + * if not or if it is in the process of connecting . <nl> + * / <nl> + public boolean isConnected ( ) { <nl> + ConnectionState connectionState = ConnectionState . fromNativeValue ( nativeGetConnectionState ( configuration . getPath ( ) ) ) ; <nl> + State sessionState = getState ( ) ; <nl> + return ( sessionState = = State . ACTIVE | | sessionState = = State . DYING ) & & connectionState = = ConnectionState . CONNECTED ; <nl> } <nl> <nl> synchronized void notifyProgressListener ( long listenerId , long transferredBytes , long transferableBytes ) { <nl> @ @ - 210 , 7 + 306 , 13 @ @ public class SyncSession { <nl> RealmLog . debug ( " Trying unknown listener failed : " + listenerId ) ; <nl> } <nl> } <nl> - <nl> + <nl> + void notifyConnectionListeners ( ConnectionState oldState , ConnectionState newState ) { <nl> + for ( ConnectionListener listener : connectionListeners ) { <nl> + listener . onChange ( oldState , newState ) ; <nl> + } <nl> + } <nl> + <nl> / * * <nl> * Adds a progress listener tracking changes that need to be downloaded from the Realm Object <nl> * Server . <nl> @ @ - 297 , 6 + 399 , 36 @ @ public class SyncSession { <nl> } <nl> } <nl> <nl> + / * * <nl> + * Adds a listener tracking changes to the connection backing this session . See { @ link ConnectionState } <nl> + * for further details . <nl> + * <nl> + * @ param listener the listener to register . <nl> + * @ throws IllegalArgumentException if the listener is { @ code null } . <nl> + * @ see ConnectionState <nl> + * / <nl> + public synchronized void addConnectionChangeListener ( ConnectionListener listener ) { <nl> + checkNonNullListener ( listener ) ; <nl> + if ( connectionListeners . isEmpty ( ) ) { <nl> + nativeConnectionListenerToken = nativeAddConnectionListener ( configuration . getPath ( ) ) ; <nl> + } <nl> + connectionListeners . add ( listener ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Removes a previously registered { @ link ConnectionListener } . <nl> + * <nl> + * @ param listener listener to remove <nl> + * @ throws IllegalArgumentException if the listener is { @ code null } . <nl> + * / <nl> + public synchronized void removeConnectionChangeListener ( ConnectionListener listener ) { <nl> + checkNonNullListener ( listener ) ; <nl> + connectionListeners . remove ( listener ) ; <nl> + if ( connectionListeners . isEmpty ( ) ) { <nl> + nativeRemoveConnectionListener ( nativeConnectionListenerToken , configuration . getPath ( ) ) ; <nl> + } <nl> + } <nl> + <nl> void close ( ) { <nl> isClosed = true ; <nl> if ( networkRequest ! = null ) { <nl> @ @ - 438 , 6 + 570 , 12 @ @ public class SyncSession { <nl> } <nl> } <nl> <nl> + private void checkNonNullListener ( @ Nullable Object listener ) { <nl> + if ( listener = = null ) { <nl> + throw new IllegalArgumentException ( " Non - null ' listener ' required . " ) ; <nl> + } <nl> + } <nl> + <nl> / * * <nl> * Interface used to report any session errors . <nl> * <nl> @ @ - 712 , 10 + 850 , 13 @ @ public class SyncSession { <nl> } <nl> } <nl> <nl> + private static native long nativeAddConnectionListener ( String localRealmPath ) ; <nl> + private static native void nativeRemoveConnectionListener ( long listenerId , String localRealmPath ) ; <nl> private static native long nativeAddProgressListener ( String localRealmPath , long listenerId , int direction , boolean isStreaming ) ; <nl> private static native void nativeRemoveProgressListener ( String localRealmPath , long listenerToken ) ; <nl> private static native boolean nativeRefreshAccessToken ( String localRealmPath , String accessToken , String realmUrl ) ; <nl> private native boolean nativeWaitForDownloadCompletion ( int callbackId , String localRealmPath ) ; <nl> private native boolean nativeWaitForUploadCompletion ( int callbackId , String localRealmPath ) ; <nl> private static native byte nativeGetState ( String localRealmPath ) ; <nl> + private static native byte nativeGetConnectionState ( String localRealmPath ) ; <nl> } <nl> diff - - git a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java <nl> index 7ccccc9 . . c14df62 100644 <nl> - - - a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java <nl> + + + b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java <nl> @ @ - 510 , 4 + 510 , 68 @ @ public class SyncSessionTests extends StandardIntegrationTest { <nl> SyncManager . simulateClientReset ( SyncManager . getSession ( config ) ) ; <nl> } <nl> <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void registerConnectionListener ( ) { <nl> + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; <nl> + SyncConfiguration syncConfiguration = configFactory <nl> + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) <nl> + . build ( ) ; <nl> + Realm realm = Realm . getInstance ( syncConfiguration ) ; <nl> + SyncSession session = SyncManager . getSession ( syncConfiguration ) ; <nl> + session . addConnectionChangeListener ( ( oldState , newState ) - > { <nl> + if ( newState = = ConnectionState . DISCONNECTED ) { <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + realm . close ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void removeConnectionListener ( ) { <nl> + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; <nl> + SyncConfiguration syncConfiguration = configFactory <nl> + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) <nl> + . build ( ) ; <nl> + Realm realm = Realm . getInstance ( syncConfiguration ) ; <nl> + SyncSession session = SyncManager . getSession ( syncConfiguration ) ; <nl> + ConnectionListener listener1 = ( oldState , newState ) - > { <nl> + if ( newState = = ConnectionState . DISCONNECTED ) { <nl> + fail ( " Listener should have been removed " ) ; <nl> + } <nl> + } ; <nl> + ConnectionListener listener2 = ( oldState , newState ) - > { <nl> + if ( newState = = ConnectionState . DISCONNECTED ) { <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + session . addConnectionChangeListener ( listener1 ) ; <nl> + session . addConnectionChangeListener ( listener2 ) ; <nl> + session . removeConnectionChangeListener ( listener1 ) ; <nl> + realm . close ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void isConnected ( ) { <nl> + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; <nl> + SyncConfiguration syncConfiguration = configFactory <nl> + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) <nl> + . build ( ) ; <nl> + looperThread . closeAfterTest ( Realm . getInstance ( syncConfiguration ) ) ; <nl> + SyncSession session = SyncManager . getSession ( syncConfiguration ) ; <nl> + if ( session . isConnected ( ) ) { <nl> + looperThread . testComplete ( ) ; <nl> + } else { <nl> + session . addConnectionChangeListener ( ( ( oldState , newState ) - > { <nl> + if ( newState = = ConnectionState . CONNECTED ) { <nl> + assertEquals ( session . getConnectionState ( ) , ConnectionState . CONNECTED ) ; <nl> + assertTrue ( session . isConnected ( ) ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ) ; <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index 1912025 . . 4d02c8a 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * Fixed unchecked cast warnings when building with Realm . <nl> * Cleaned up examples ( remove old test project ) . <nl> * Added checking for missing generic type in RealmList fields in annotation processor . <nl> + * Support async queries <nl> <nl> 0 . 80 . 3 <nl> * Calling Realm . copyToRealmOrUpdate ( ) with an object with a null primary key now throws a proper exception . <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> index bb26d54 . . 3cad125 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> @ @ - 14 , 12 + 14 , 14 @ @ <nl> * limitations under the License . <nl> * / <nl> <nl> + # include < realm / group _ shared . hpp > <nl> # include " util . hpp " <nl> # include " io _ realm _ internal _ TableQuery . h " <nl> # include " tablequery . hpp " <nl> <nl> using namespace realm ; <nl> <nl> + # define SG ( ptr ) reinterpret _ cast < SharedGroup * > ( ptr ) <nl> # if 1 <nl> # define COL _ TYPE _ VALID ( env , ptr , col , type ) TBL _ AND _ COL _ INDEX _ AND _ TYPE _ VALID ( env , ptr , col , type ) <nl> # define COL _ TYPE _ LINK _ OR _ LINKLIST ( env , ptr , col ) TBL _ AND _ COL _ INDEX _ AND _ LINK _ OR _ LINKLIST ( env , ptr , col ) <nl> @ @ - 1174 , 3 + 1176 , 47 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNull ( <nl> pQuery - > and _ query ( query ) ; <nl> } CATCH _ STD ( ) <nl> } <nl> + <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover <nl> + ( JNIEnv * env , jobject , jlong callerSharedGrpPtr , jlong bgSharedGroupPtr , jlong nativeQueryPtr , jlong start , jlong end , jlong limit ) <nl> + { <nl> + Query * pQuery = Q ( nativeQueryPtr ) ; <nl> + Table * pTable = pQuery - > get _ table ( ) . get ( ) ; <nl> + if ( ! QUERY _ VALID ( env , pQuery ) | | <nl> + ! ROW _ INDEXES _ VALID ( env , pTable , start , end , limit ) ) <nl> + return - 1 ; <nl> + try { <nl> + TableView * pResultView = new TableView ( pQuery - > find _ all ( S ( start ) , S ( end ) , S ( limit ) ) ) ; <nl> + std : : unique _ ptr < SharedGroup : : Handover < TableView > > handover ; <nl> + handover . reset ( SG ( bgSharedGroupPtr ) - > export _ for _ handover ( * pResultView , ConstSourcePayload : : Copy ) ) ; <nl> + / / TODO reimplement this so the call to ' export _ for _ handover ' is done on a background thread <nl> + / / and ' import _ from _ handover ' on the caller thread . <nl> + / / <nl> + / / According to core , it ' s preferable to return first the exported handover <nl> + / / then import it from the calling SharedGroup ( Thread ) . <nl> + / / We need to make sure to check that the version id ( version of the shared group used to perform the query ) <nl> + / / is the same as the caller SharedGroup , otherwise the import will fail . In this case , we should <nl> + / / either retry the entire query , or call again ' sync _ if _ needed ' on the TableView to re - query , at this point <nl> + / / we need to export again the handover to the caller SharedGroup , until we converge <nl> + / / ( i . e the version of the caller SharedGroup matches the version returned by the handover TableView ) <nl> + / / <nl> + / / Note : The mode ' ConstSourcePayload : : Copy ' handover perform a deep copy of the TableView , this means that we copy <nl> + / / both the Payload ( row accessors ) & the Query <nl> + / / <nl> + / / The mode ' ConstSourcePayload : : Stay ' handover perform a copy of the Query only ( no payload ) <nl> + / / The mode ' MutableSourcePayload : : Move ' handover perform a move of both the Payload & Query <nl> + / / <nl> + / / The expensive operations are in that order <nl> + / / pQuery - > find _ all > > export _ for _ handover > > import _ from _ handover <nl> + / / so it ' s recommended to run the ' query ' & the ' export ' on a background Thread , then <nl> + / / call ' import _ from _ handover ' on the caller thread ( most of the time UI thread ) . <nl> + / / calling ' import _ from _ handover ' on the UI thread has another benefit , it will block the SharedGroup <nl> + / / from modifying it ' s state ( advance _ read , promote _ write , rollback , commit etc ) <nl> + / / <nl> + / / The handover pointer is Thread safe , it can be passed from different Threads ( using different SharedGroups ) <nl> + <nl> + TableView * tv ( SG ( callerSharedGrpPtr ) - > import _ from _ handover ( handover . release ( ) ) ) ; <nl> + return reinterpret _ cast < jlong > ( tv ) ; <nl> + } CATCH _ STD ( ) <nl> + return - 1 ; <nl> + } <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> index 5ccb9ee . . 97a9ed7 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> @ @ - 369 , 6 + 369 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAll <nl> <nl> / * <nl> * Class : io _ realm _ internal _ TableQuery <nl> + * Method : nativeFindAllWithHandover <nl> + * Signature : ( JJJJJJ ) J <nl> + * / <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover <nl> + ( JNIEnv * , jobject , jlong , jlong , jlong , jlong , jlong , jlong ) ; <nl> + <nl> + / * <nl> + * Class : io _ realm _ internal _ TableQuery <nl> * Method : nativeSumInt <nl> * Signature : ( JJJJJ ) J <nl> * / <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> new file mode 100644 <nl> index 0000000 . . 162e33a <nl> - - - / dev / null <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 0 , 0 + 1 , 151 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm ; <nl> + <nl> + import android . os . Looper ; <nl> + import android . test . InstrumentationTestCase ; <nl> + <nl> + import junit . framework . AssertionFailedError ; <nl> + <nl> + import java . util . Date ; <nl> + import java . util . concurrent . CountDownLatch ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . Executors ; <nl> + <nl> + import io . realm . entities . AllTypes ; <nl> + import io . realm . entities . NonLatinFieldNames ; <nl> + <nl> + public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> + <nl> + / / TODO use Junit4 & define a rule to setup the threading , to avoid <nl> + / / this boiler plat code , or use a custom test runner <nl> + public void testFindAll ( ) throws Throwable { <nl> + / / We need to control precisely which Looper / Thread our Realm <nl> + / / will operate on . This is unfortunately not possible when using the <nl> + / / current Instrumentation # InstrumentationThread , because InstrumentationTestRunner # onStart <nl> + / / Call Looper . prepare ( ) for us and surprisingly doesn ' t call Looper # loop ( ) , this is problematic <nl> + / / as the async query callback will not run ( because the Handler is sending Runnables to a Looper <nl> + / / that didn ' t loop . <nl> + / / <nl> + / / In the other hand , using a dedicated ' ExecutorService ' will allow us to fine grain control the <nl> + / / desired behaviour <nl> + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final Looper [ ] looper = new Looper [ 1 ] ; <nl> + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + executorService . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + looper [ 0 ] = Looper . myLooper ( ) ; <nl> + Realm realm = null ; <nl> + try { <nl> + realm = openRealmInstance ( ) ; <nl> + populateTestRealm ( realm , 10 ) ; <nl> + <nl> + / / async query ( will run on different thread ) <nl> + realm . asyncWhere ( AllTypes . class , <nl> + new Realm . AsyncCallback < RealmResults < AllTypes > > ( ) { <nl> + @ Override <nl> + public void onSuccess ( RealmResults < AllTypes > results ) { <nl> + try { <nl> + assertEquals ( 10 , results . size ( ) ) ; <nl> + <nl> + / / Make sure access to RealmObject will not throw an Exception <nl> + for ( int i = 0 , size = results . size ( ) ; i < size ; i + + ) { <nl> + assertEquals ( i , results . get ( i ) . getColumnLong ( ) ) ; <nl> + } <nl> + <nl> + } catch ( AssertionFailedError e ) { <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + / / whatever happened , make sure to notify the waiting TestCase Thread <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void onError ( Throwable t ) { <nl> + try { <nl> + threadAssertionError [ 0 ] = t ; <nl> + t . printStackTrace ( ) ; <nl> + } finally { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + } ) <nl> + . between ( " columnLong " , 0 , 9 ) . findAll ( ) ; <nl> + <nl> + Looper . loop ( ) ; / / ready to receive callback <nl> + <nl> + } finally { <nl> + if ( realm ! = null ) { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + / / wait until the callback of our async query proceed <nl> + signalCallbackFinished . await ( ) ; <nl> + looper [ 0 ] . quit ( ) ; <nl> + executorService . shutdownNow ( ) ; <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / Throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + } <nl> + <nl> + / / * * * Helper methods * * * <nl> + <nl> + / / This could be done from # setUp but then we can ' t control <nl> + / / which Looper we want to associate this Realm instance with <nl> + private Realm openRealmInstance ( ) { <nl> + RealmConfiguration realmConfiguration = new RealmConfiguration . <nl> + Builder ( getInstrumentation ( ) <nl> + . getTargetContext ( ) ) <nl> + . name ( " test . realm " ) <nl> + . deleteRealmIfMigrationNeeded ( ) <nl> + . build ( ) ; <nl> + Realm . deleteRealm ( realmConfiguration ) ; <nl> + return Realm . getInstance ( realmConfiguration ) ; <nl> + } <nl> + <nl> + private void populateTestRealm ( final Realm testRealm , int objects ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . allObjects ( AllTypes . class ) . clear ( ) ; <nl> + testRealm . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; <nl> + for ( int i = 0 ; i < objects ; + + i ) { <nl> + AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; <nl> + allTypes . setColumnBoolean ( ( i % 3 ) = = 0 ) ; <nl> + allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; <nl> + allTypes . setColumnDate ( new Date ( ) ) ; <nl> + allTypes . setColumnDouble ( 3 . 1415 ) ; <nl> + allTypes . setColumnFloat ( 1 . 234567f + i ) ; <nl> + allTypes . setColumnString ( " test data " + i ) ; <nl> + allTypes . setColumnLong ( i ) ; <nl> + NonLatinFieldNames nonLatinFieldNames = testRealm . createObject ( NonLatinFieldNames . class ) ; <nl> + nonLatinFieldNames . set 델 타 ( i ) ; <nl> + nonLatinFieldNames . set Δ έ λ τ α ( i ) ; <nl> + nonLatinFieldNames . set 베 타 ( 1 . 234567f + i ) ; <nl> + nonLatinFieldNames . set Β ή τ α ( 1 . 234567f + i ) ; <nl> + } <nl> + testRealm . commitTransaction ( ) ; <nl> + testRealm . refresh ( ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index ca29295 . . d2e5033 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 22 , 7 + 22 , 6 @ @ import org . json . JSONArray ; <nl> import org . json . JSONException ; <nl> import org . json . JSONObject ; <nl> <nl> - import java . io . ByteArrayInputStream ; <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> import java . io . InputStream ; <nl> diff - - git a / realm / src / main / java / io / realm / AsyncRealmQueryResult . java b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java <nl> new file mode 100644 <nl> index 0000000 . . 7318359 <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java <nl> @ @ - 0 , 0 + 1 , 25 @ @ <nl> + package io . realm ; <nl> + <nl> + import java . util . concurrent . Future ; <nl> + <nl> + / * * <nl> + * Represents the result of an asynchronous Realm query . <nl> + * <nl> + * Users are responsible of maintaining a reference to { @ code AsyncRealmQueryResult } in order <nl> + * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the <nl> + * query will post the result to the caller ' s thread callback ) <nl> + * / <nl> + public class AsyncRealmQueryResult { <nl> + final Future < ? > pendingQuery ; <nl> + <nl> + public AsyncRealmQueryResult ( Future < ? > pendingQuery ) { <nl> + this . pendingQuery = pendingQuery ; <nl> + } <nl> + <nl> + / * * <nl> + * Attempts to cancel execution of this queries . <nl> + * / <nl> + public void cancel ( ) { <nl> + pendingQuery . cancel ( true ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index ddbc022 . . 15aac8b 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 63 , 6 + 63 , 7 @ @ import io . realm . internal . SharedGroup ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableView ; <nl> import io . realm . internal . Util ; <nl> + import io . realm . internal . android . AsyncRealmQuery ; <nl> import io . realm . internal . android . DebugAndroidLogger ; <nl> import io . realm . internal . android . ReleaseAndroidLogger ; <nl> import io . realm . internal . log . RealmLog ; <nl> @ @ - 154 , 6 + 155 , 9 @ @ public final class Realm implements Closeable { <nl> private static final Map < String , AtomicInteger > globalOpenInstanceCounter = <nl> new ConcurrentHashMap < String , AtomicInteger > ( ) ; <nl> <nl> + / / Thread Pool for all async operations ( Query & Write transaction ) <nl> + public static final ExecutorService asyncQueryExecutor = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) * 2 + 1 ) ; <nl> + <nl> protected static final Map < Handler , String > handlers = new ConcurrentHashMap < Handler , String > ( ) ; <nl> private static final int REALM _ CHANGED = 14930352 ; / / Hopefully it won ' t clash with other message IDs . <nl> <nl> @ @ - 1198 , 6 + 1202 , 20 @ @ public final class Realm implements Closeable { <nl> } <nl> <nl> / * * <nl> + * Prepare an async query <nl> + * TODO point to documentation or example about async query <nl> + * @ param clazz The class of the object which is to be queried for <nl> + * @ return A typed RealmQuery , which can be used to query for specific objects of this type <nl> + * @ throws java . lang . RuntimeException Any other error <nl> + * @ see io . realm . RealmQuery <nl> + * @ param callback <nl> + * / <nl> + public < E extends RealmObject > AsyncRealmQuery < E > asyncWhere ( Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { <nl> + checkIfValid ( ) ; <nl> + return new AsyncRealmQuery < E > ( this , clazz , callback ) ; <nl> + } <nl> + <nl> + / * * <nl> * Get all objects of a specific Class . If no objects exist , the returned RealmResults will not <nl> * be null . The RealmResults . size ( ) to check the number of objects instead . <nl> * <nl> @ @ - 1872 , 4 + 1890 , 24 @ @ public final class Realm implements Closeable { <nl> void execute ( Realm realm ) ; <nl> } <nl> <nl> + / * * <nl> + * Encapsulates an async { @ link RealmQuery } . <nl> + * < p > <nl> + * This will run the { @ link RealmQuery } on a worker thread , then invoke this callback on the caller thread <nl> + * / <nl> + public interface AsyncCallback < T extends RealmResults < ? extends RealmObject > > { <nl> + void onSuccess ( T results ) ; <nl> + void onError ( Throwable t ) ; <nl> + } <nl> + <nl> + <nl> + / / FIXME Realm . java being the public API and the implementation . <nl> + / / we need a Realm interface to be able to separate this kind of call <nl> + / / ( mostly from internal API / tests that need to access private field / method ) . <nl> + / / RealmImpl will be accessible to other internal packages <nl> + / / but not to the user ( avoid compromising our exposed public API ) <nl> + / / <nl> + public long getSharedGroupPtr ( ) { <nl> + return sharedGroup . nativePtr ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index df847f5 . . b744adc 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1302 , 4 + 1302 , 8 @ @ public class RealmQuery < E extends RealmObject > { <nl> return null ; <nl> } <nl> } <nl> + <nl> + protected TableQuery getTableQuery ( ) { <nl> + return this . query ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / internal / TableQuery . java b / realm / src / main / java / io / realm / internal / TableQuery . java <nl> index e82eaa7 . . 268645d 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / TableQuery . java <nl> + + + b / realm / src / main / java / io / realm / internal / TableQuery . java <nl> @ @ - 493 , 8 + 493 , 24 @ @ public class TableQuery implements Closeable { <nl> } <nl> } <nl> <nl> - protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; <nl> + public TableView findAllWithHandover ( long callerSharedGroupPtr , long bgSharedGroupPtr ) { <nl> + validateQuery ( ) ; <nl> + <nl> + / / Execute the disposal of abandoned realm objects each time a new realm object is created <nl> + context . executeDelayedDisposal ( ) ; <nl> + long nativeViewPtr = nativeFindAllWithHandover ( callerSharedGroupPtr , bgSharedGroupPtr , nativePtr , 0 , Table . INFINITE , Table . INFINITE ) ; / / nativeViewPtr is created from bg Thread <nl> + / / handover nativeViewPtr to UI Thread <nl> + <nl> + try { <nl> + return new TableView ( this . context , this . parent , nativeViewPtr ) ; <nl> + } catch ( RuntimeException e ) { <nl> + TableView . nativeClose ( nativeViewPtr ) ; <nl> + throw e ; <nl> + } <nl> + } <nl> <nl> + protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; <nl> + protected native long nativeFindAllWithHandover ( long nativeCallerSharedGroupPtr , long bgSharedGroupPtr , long nativeQueryPtr , long start , long end , long limit ) ; <nl> / / <nl> / / Aggregation methods <nl> / / <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java <nl> new file mode 100644 <nl> index 0000000 . . c3716eb <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java <nl> @ @ - 0 , 0 + 1 , 165 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . android ; <nl> + <nl> + import android . os . Handler ; <nl> + import android . os . Looper ; <nl> + import android . os . Message ; <nl> + <nl> + import java . util . concurrent . Future ; <nl> + <nl> + import io . realm . AsyncRealmQueryResult ; <nl> + import io . realm . Realm ; <nl> + import io . realm . RealmConfiguration ; <nl> + import io . realm . RealmObject ; <nl> + import io . realm . RealmQuery ; <nl> + import io . realm . RealmResults ; <nl> + import io . realm . internal . TableOrView ; <nl> + import io . realm . internal . TableView ; <nl> + <nl> + import static io . realm . Realm . asyncQueryExecutor ; <nl> + <nl> + / * * <nl> + * A helper class to help make handling asynchronous { @ link RealmQuery } easier . <nl> + * <nl> + * @ param < E > type of the object which is to be queried for <nl> + * / <nl> + / / Behaviour may change , user should not subclass <nl> + public final class AsyncRealmQuery < E extends RealmObject > { <nl> + private final Realm callerRealm ; <nl> + private final Class < E > clazz ; <nl> + private final Realm . AsyncCallback < RealmResults < E > > callback ; <nl> + <nl> + private int from ; <nl> + private int to ; <nl> + private String fieldName ; <nl> + private EventHandler eventHandler ; <nl> + private Future < ? > pendingQuery ; <nl> + <nl> + / * * <nl> + * Create an { @ code AsyncRealmQuery } instance . <nl> + * <nl> + * @ param realm The realm to query within . <nl> + * @ param clazz The class to query . <nl> + * @ param callback invoked on the thread { @ link Realm # asyncWhere ( Class , Realm . AsyncCallback ) } was called from , to post results . <nl> + * / <nl> + public AsyncRealmQuery ( Realm realm , Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { <nl> + this . callerRealm = realm ; <nl> + this . callback = callback ; <nl> + this . clazz = clazz ; <nl> + } <nl> + <nl> + / * * <nl> + * Between condition <nl> + * <nl> + * @ param fieldName The field to compare <nl> + * @ param from Lowest value ( inclusive ) <nl> + * @ param to Highest value ( inclusive ) <nl> + * @ return current instance of { @ code AsyncRealmQuery } for method chaining <nl> + * / <nl> + public AsyncRealmQuery < E > between ( String fieldName , int from , int to ) { <nl> + this . from = from ; <nl> + this . to = to ; <nl> + this . fieldName = fieldName ; <nl> + return this ; <nl> + } <nl> + <nl> + / * * <nl> + * Find all objects that fulfill the query conditions . <nl> + * Results will be posted to the callback instance { @ link io . realm . Realm . AsyncCallback } asynchronously <nl> + * If no objects match the condition , a list with zero objects is returned . <nl> + * <nl> + * @ see io . realm . RealmResults <nl> + * / <nl> + public AsyncRealmQueryResult findAll ( ) { <nl> + / / will use the Looper of the caller thread to post the result <nl> + Looper looper ; <nl> + if ( ( looper = Looper . myLooper ( ) ) ! = null ) { <nl> + eventHandler = new EventHandler ( looper ) ; <nl> + } else if ( ( looper = Looper . getMainLooper ( ) ) ! = null ) { <nl> + eventHandler = new EventHandler ( looper ) ; <nl> + } else { <nl> + eventHandler = null ; / / FIXME define strategy / behaviour for regular JVM call <nl> + } <nl> + <nl> + / / We need a pointer to the caller Realm , to be able to handover the result to it <nl> + final long callerSharedGroupNativePtr = callerRealm . getSharedGroupPtr ( ) ; <nl> + <nl> + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) <nl> + / / to perform the query <nl> + final RealmConfiguration realmConfiguration = callerRealm . getConfiguration ( ) ; <nl> + <nl> + pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + try { <nl> + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> + <nl> + / / TODO This will probably be replace by a kind of ' QueryBuilder ' <nl> + / / that holds all the operations ( predicates / filters ) then <nl> + / / replay them here in this background thread . The current implementation <nl> + / / call Core for each step , we want to limit the overhead by sending one <nl> + / / single call to Core with all the parameters . <nl> + <nl> + TableView tv = new RealmQueryAdapter < E > ( bgRealm , clazz ) <nl> + . between ( fieldName , from , to ) <nl> + . findAll ( callerSharedGroupNativePtr , bgRealm . getSharedGroupPtr ( ) ) ; <nl> + <nl> + bgRealm . close ( ) ; <nl> + <nl> + / / send results to the caller thread ' s callback <nl> + if ( ! pendingQuery . isCancelled ( ) ) { <nl> + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ SUCCESS , tv ) ; <nl> + eventHandler . sendMessage ( msg ) ; <nl> + } <nl> + <nl> + } catch ( Exception e ) { <nl> + if ( ! pendingQuery . isCancelled ( ) ) { <nl> + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ ERROR , e ) ; <nl> + eventHandler . sendMessage ( msg ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + return new AsyncRealmQueryResult ( pendingQuery ) ; <nl> + } <nl> + <nl> + private class EventHandler extends Handler { <nl> + private static final int MSG _ SUCCESS = 1 ; <nl> + private static final int MSG _ ERROR = MSG _ SUCCESS + 1 ; <nl> + <nl> + public EventHandler ( Looper looper ) { <nl> + super ( looper ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void handleMessage ( Message msg ) { <nl> + switch ( msg . what ) { <nl> + case MSG _ SUCCESS : <nl> + RealmResults < E > resultList = new RealmResults < E > ( callerRealm , ( TableOrView ) msg . obj , clazz ) ; <nl> + callback . onSuccess ( resultList ) ; <nl> + break ; <nl> + case MSG _ ERROR : <nl> + callback . onError ( ( Throwable ) msg . obj ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java <nl> new file mode 100644 <nl> index 0000000 . . acac317 <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java <nl> @ @ - 0 , 0 + 1 , 38 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . android ; <nl> + <nl> + import io . realm . Realm ; <nl> + import io . realm . RealmObject ; <nl> + import io . realm . RealmQuery ; <nl> + import io . realm . internal . TableView ; <nl> + <nl> + class RealmQueryAdapter < E extends RealmObject > extends RealmQuery < E > { <nl> + public RealmQueryAdapter ( Realm realm , Class < E > clazz ) { <nl> + super ( realm , clazz ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public RealmQueryAdapter < E > between ( String fieldName , int from , int to ) { <nl> + super . between ( fieldName , from , to ) ; <nl> + return this ; <nl> + } <nl> + <nl> + public TableView findAll ( long callerRealmPtr , long backgroundRealmPtr ) { <nl> + return getTableQuery ( ) . findAllWithHandover ( callerRealmPtr , backgroundRealmPtr ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / CHANGELOG . md b / CHANGELOG . md 
 index 7f4774b . . dd33ec9 100644 
 - - - a / CHANGELOG . md 
 + + + b / CHANGELOG . md 
 @ @ - 1 , 3 + 1 , 16 @ @ 
 + # # 5 . 5 . 0 ( YYYY - MM - DD ) 
 + 
 + # # # Enhancements 
 + 
 + * [ ObjectServer ] Added ` ConnectionState ` enum describing the states a connection can be in . 
 + * [ ObjectServer ] Added ` SyncSession . isConnected ( ) ` . 
 + * [ ObjectServer ] Added support for observing connection changes for a session using ` SyncSession . addConnectionChangeListener ( ) ` and ` SyncSession . removeConnectionChangeListener ( ) ` . 
 + 
 + # # # Internal 
 + 
 + * Updated to Object Store commit : 97fd03819f398b3c81c8b007feaca8636629050b 
 + 
 + 
 # # 5 . 4 . 2 ( 2018 - 08 - 09 ) 
 
 # # # Bug Fixes 
 diff - - git a / examples / settings . gradle b / examples / settings . gradle 
 index 4a5ac90 . . 15f6d6c 100644 
 - - - a / examples / settings . gradle 
 + + + b / examples / settings . gradle 
 @ @ - 15 , 4 + 15 , 3 @ @ include ' threadExample ' 
 include ' unitTestExample ' 
 include ' objectServerExample ' 
 include ' multiprocessExample ' 
 - 
 diff - - git a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java 
 index 458807b . . 6ea9d49 100644 
 - - - a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java 
 + + + b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java 
 @ @ - 457 , 4 + 457 , 16 @ @ public class SessionTests { 
 " No SyncSession found using the path : " ) ) ; 
 } 
 } 
 + 
 + @ Test 
 + public void isConnected _ falseForInvalidUser ( ) { 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + SyncSession session = SyncManager . getSession ( configuration ) ; 
 + try { 
 + assertFalse ( session . isConnected ( ) ) ; 
 + } finally { 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 } 
 diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp b / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp 
 index 20c8f76 . . 140e8e5 100644 
 - - - a / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp 
 + + + b / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp 
 @ @ - 47 , 8 + 47 , 15 @ @ static _ assert ( SyncSession : : PublicState : : Dying = = 
 static _ assert ( SyncSession : : PublicState : : Inactive = = 
 static _ cast < SyncSession : : PublicState > ( io _ realm _ SyncSession _ STATE _ VALUE _ INACTIVE ) , 
 " " ) ; 
 - static _ assert ( SyncSession : : PublicState : : Error = = 
 - static _ cast < SyncSession : : PublicState > ( io _ realm _ SyncSession _ STATE _ VALUE _ ERROR ) , 
 + 
 + static _ assert ( SyncSession : : ConnectionState : : Disconnected = = 
 + static _ cast < SyncSession : : ConnectionState > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ DISCONNECTED ) , 
 + " " ) ; 
 + static _ assert ( SyncSession : : ConnectionState : : Connecting = = 
 + static _ cast < SyncSession : : ConnectionState > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTING ) , 
 + " " ) ; 
 + static _ assert ( SyncSession : : ConnectionState : : Connected = = 
 + static _ cast < SyncSession : : ConnectionState > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTED ) , 
 " " ) ; 
 
 JNIEXPORT jboolean JNICALL Java _ io _ realm _ SyncSession _ nativeRefreshAccessToken ( JNIEnv * env , jclass , 
 @ @ - 229 , 11 + 236 , 97 @ @ JNIEXPORT jbyte JNICALL Java _ io _ realm _ SyncSession _ nativeGetState ( JNIEnv * env , jc 
 return io _ realm _ SyncSession _ STATE _ VALUE _ DYING ; 
 case SyncSession : : PublicState : : Inactive : 
 return io _ realm _ SyncSession _ STATE _ VALUE _ INACTIVE ; 
 - case SyncSession : : PublicState : : Error : 
 - return io _ realm _ SyncSession _ STATE _ VALUE _ ERROR ; 
 } 
 } 
 } 
 CATCH _ STD ( ) 
 return - 1 ; 
 } 
 + 
 + JNIEXPORT jbyte JNICALL Java _ io _ realm _ SyncSession _ nativeGetConnectionState ( JNIEnv * env , jclass , jstring j _ local _ realm _ path ) 
 + { 
 + TR _ ENTER ( ) 
 + try { 
 + JStringAccessor local _ realm _ path ( env , j _ local _ realm _ path ) ; 
 + auto session = SyncManager : : shared ( ) . get _ existing _ session ( local _ realm _ path ) ; 
 + 
 + if ( session ) { 
 + switch ( session - > connection _ state ( ) ) { 
 + case SyncSession : : ConnectionState : : Disconnected : 
 + return io _ realm _ SyncSession _ CONNECTION _ VALUE _ DISCONNECTED ; 
 + case SyncSession : : ConnectionState : : Connecting : 
 + return io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTING ; 
 + case SyncSession : : ConnectionState : : Connected : 
 + return io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTED ; 
 + } 
 + } 
 + } 
 + CATCH _ STD ( ) 
 + return - 1 ; 
 + } 
 + 
 + static jlong get _ connection _ value ( SyncSession : : ConnectionState state ) { 
 + switch ( state ) { 
 + case SyncSession : : ConnectionState : : Disconnected : return static _ cast < jlong > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ DISCONNECTED ) ; 
 + case SyncSession : : ConnectionState : : Connecting : return static _ cast < jlong > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTING ) ; 
 + case SyncSession : : ConnectionState : : Connected : return static _ cast < jlong > ( io _ realm _ SyncSession _ CONNECTION _ VALUE _ CONNECTED ) ; 
 + } 
 + return static _ cast < jlong > ( - 1 ) ; 
 + } 
 + 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ SyncSession _ nativeAddConnectionListener ( JNIEnv * env , jclass , jstring j _ local _ realm _ path ) 
 + { 
 + try { 
 + / / JNIEnv is thread confined , so we need a deep copy in order to capture the string in the lambda 
 + std : : string local _ realm _ path ( JStringAccessor ( env , j _ local _ realm _ path ) ) ; 
 + std : : shared _ ptr < SyncSession > session = SyncManager : : shared ( ) . get _ existing _ session ( local _ realm _ path ) ; 
 + if ( ! session ) { 
 + / / FIXME : We should lift this restriction 
 + ThrowException ( env , IllegalState , 
 + " Cannot register a connection listener before a session is " 
 + " created . A session will be created after the first call to Realm . getInstance ( ) . " ) ; 
 + return 0 ; 
 + } 
 + 
 + static JavaClass java _ syncmanager _ class ( env , " io / realm / SyncManager " ) ; 
 + static JavaMethod java _ notify _ connection _ listener ( env , java _ syncmanager _ class , " notifyConnectionListeners " , " ( Ljava / lang / String ; JJ ) V " , true ) ; 
 + 
 + std : : function < SyncSession : : ConnectionStateCallback > callback = [ local _ realm _ path ] ( SyncSession : : ConnectionState old _ state , SyncSession : : ConnectionState new _ state ) { 
 + JNIEnv * local _ env = jni _ util : : JniUtils : : get _ env ( true ) ; 
 + 
 + jlong old _ connection _ value = get _ connection _ value ( old _ state ) ; 
 + jlong new _ connection _ value = get _ connection _ value ( new _ state ) ; 
 + 
 + JavaLocalRef < jstring > path ( local _ env , to _ jstring ( local _ env , local _ realm _ path ) ) ; 
 + local _ env - > CallStaticVoidMethod ( java _ syncmanager _ class , java _ notify _ connection _ listener , path . get ( ) , 
 + old _ connection _ value , new _ connection _ value ) ; 
 + 
 + / / All exceptions will be caught on the Java side of handlers , but Errors will still end 
 + / / up here , so we need to do something sensible with them . 
 + / / Throwing a C + + exception will terminate the sync thread and cause the pending Java 
 + / / exception to become visible . For some ( unknown ) reason Logcat will not see the C + + 
 + / / exception , only the Java one . 
 + if ( local _ env - > ExceptionCheck ( ) ) { 
 + local _ env - > ExceptionDescribe ( ) ; 
 + throw std : : runtime _ error ( " An unexpected Error was thrown from Java . See LogCat " ) ; 
 + } 
 + } ; 
 + uint64 _ t token = session - > register _ connection _ change _ callback ( callback ) ; 
 + return static _ cast < jlong > ( token ) ; 
 + } 
 + CATCH _ STD ( ) 
 + return 0 ; 
 + } 
 + 
 + JNIEXPORT void JNICALL Java _ io _ realm _ SyncSession _ nativeRemoveConnectionListener ( JNIEnv * env , jclass , jlong listener _ id , jstring j _ local _ realm _ path ) 
 + { 
 + try { 
 + / / JNIEnv is thread confined , so we need a deep copy in order to capture the string in the lambda 
 + std : : string local _ realm _ path ( JStringAccessor ( env , j _ local _ realm _ path ) ) ; 
 + std : : shared _ ptr < SyncSession > session = SyncManager : : shared ( ) . get _ existing _ session ( local _ realm _ path ) ; 
 + if ( session ) { 
 + session - > unregister _ connection _ change _ callback ( static _ cast < uint64 _ t > ( listener _ id ) ) ; 
 + } 
 + } 
 + CATCH _ STD ( ) 
 + } 
 diff - - git a / realm / realm - library / src / main / cpp / object - store b / realm / realm - library / src / main / cpp / object - store 
 index 58f1066 . . 97fd038 160000 
 - - - a / realm / realm - library / src / main / cpp / object - store 
 + + + b / realm / realm - library / src / main / cpp / object - store 
 @ @ - 1 + 1 @ @ 
 - Subproject commit 58f106676f96d0a5dcb52b6d705cf20db797d5c6 
 + Subproject commit 97fd03819f398b3c81c8b007feaca8636629050b 
 diff - - git a / realm / realm - library / src / objectServer / java / io / realm / ConnectionListener . java b / realm / realm - library / src / objectServer / java / io / realm / ConnectionListener . java 
 new file mode 100644 
 index 0000000 . . 43bed18 
 - - - / dev / null 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / ConnectionListener . java 
 @ @ - 0 , 0 + 1 , 39 @ @ 
 + / * 
 + * Copyright 2018 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package io . realm ; 
 + 
 + / * * 
 + * Interface used when reporting changes that happened to the connection used by the session . 
 + * < p > 
 + * Multiple sessions might re - use the same connection . In that case , any connection 
 + * change will be reported to all sessions . 
 + * < p > 
 + * If a disconnect happened due to an error , that error will be reported to the sessions 
 + * { @ link io . realm . SyncSession . ErrorHandler } . 
 + * 
 + * @ see SyncSession # isConnected ( ) 
 + * @ see SyncConfiguration . Builder # errorHandler ( SyncSession . ErrorHandler ) 
 + * / 
 + public interface ConnectionListener { 
 + 
 + / * * 
 + * A change in the connection to the server was detected . 
 + * 
 + * @ param oldState the state the connection transitioned from . 
 + * @ param newState the state the connection transitioned to . 
 + * / 
 + void onChange ( ConnectionState oldState , ConnectionState newState ) ; 
 + } 
 diff - - git a / realm / realm - library / src / objectServer / java / io / realm / ConnectionState . java b / realm / realm - library / src / objectServer / java / io / realm / ConnectionState . java 
 new file mode 100644 
 index 0000000 . . e603160 
 - - - / dev / null 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / ConnectionState . java 
 @ @ - 0 , 0 + 1 , 59 @ @ 
 + / * 
 + * Copyright 2018 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm ; 
 + 
 + / * * 
 + * Enum describing the states of the underlying connection used by a { @ link SyncSession } . 
 + * / 
 + public enum ConnectionState { 
 + 
 + / * * 
 + * No connection to the server exists . No data is being transferred even if the session 
 + * is { @ link SyncSession . State # ACTIVE } . If the connection entered this state due to an error , this 
 + * error will be reported to the { @ link SyncSession . ErrorHandler } . 
 + * / 
 + DISCONNECTED ( SyncSession . CONNECTION _ VALUE _ DISCONNECTED ) , 
 + 
 + / * * 
 + * A connection is currently in progress of being established . If successful the next 
 + * state is { @ link # CONNECTED } . If the connection fails it will be { @ link # DISCONNECTED } . 
 + * / 
 + CONNECTING ( SyncSession . CONNECTION _ VALUE _ CONNECTING ) , 
 + 
 + / * * 
 + * A connection was successfully established to the server . If the SyncSession is { @ link SyncSession . State # ACTIVE } 
 + * data will now be transferred between the device and the server . 
 + * / 
 + CONNECTED ( SyncSession . CONNECTION _ VALUE _ CONNECTED ) ; 
 + 
 + final int value ; 
 + 
 + ConnectionState ( int value ) { 
 + this . value = value ; 
 + } 
 + 
 + static ConnectionState fromNativeValue ( long value ) { 
 + ConnectionState [ ] stateCodes = values ( ) ; 
 + for ( ConnectionState state : stateCodes ) { 
 + if ( state . value = = value ) { 
 + return state ; 
 + } 
 + } 
 + 
 + throw new IllegalArgumentException ( " Unknown connection state code : " + value ) ; 
 + } 
 + } 
 diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncManager . java b / realm / realm - library / src / objectServer / java / io / realm / SyncManager . java 
 index 390e447 . . ce556da 100644 
 - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncManager . java 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncManager . java 
 @ @ - 401 , 6 + 401 , 22 @ @ public class SyncManager { 
 } 
 
 / * * 
 + * Called from native code . This method is not allowed to throw as it would be swallowed 
 + * by the native Sync Client thread . Instead log all exceptions to logcat . 
 + * / 
 + @ SuppressWarnings ( " unused " ) 
 + private static synchronized void notifyConnectionListeners ( String localRealmPath , long oldState , long newState ) { 
 + SyncSession session = sessions . get ( localRealmPath ) ; 
 + if ( session ! = null ) { 
 + try { 
 + session . notifyConnectionListeners ( ConnectionState . fromNativeValue ( oldState ) , ConnectionState . fromNativeValue ( newState ) ) ; 
 + } catch ( Exception exception ) { 
 + RealmLog . error ( exception ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 * This is called from the Object Store ( through JNI ) to request an { @ code access _ token } for 
 * the session specified by sessionPath . 
 * 
 diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java 
 index f05656a . . f099649 100644 
 - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import java . util . IdentityHashMap ; 
 import java . util . Iterator ; 
 import java . util . Locale ; 
 import java . util . Map ; 
 + import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . CountDownLatch ; 
 import java . util . concurrent . Future ; 
 import java . util . concurrent . ScheduledFuture ; 
 @ @ - 36 , 6 + 37 , 8 @ @ import java . util . concurrent . atomic . AtomicInteger ; 
 import java . util . concurrent . atomic . AtomicLong ; 
 import java . util . concurrent . atomic . AtomicReference ; 
 
 + import javax . annotation . Nullable ; 
 + 
 import io . realm . internal . Keep ; 
 import io . realm . internal . SyncObjectServerFacade ; 
 import io . realm . internal . Util ; 
 @ @ - 50 , 15 + 53 , 23 @ @ import io . realm . internal . util . Pair ; 
 import io . realm . log . RealmLog ; 
 
 / * * 
 - * This class represents the connection to the Realm Object Server for one { @ link SyncConfiguration } . 
 + * A session controls how data is synchronized between a single Realm on the device and the server 
 + * Realm on the Realm Object Server . 
 * < p > 
 - * A Session is created by opening a Realm instance using that configuration . Once a session has been created , 
 + * A Session is created by opening a Realm instance using a { @ link SyncConfiguration } . Once a session has been created , 
 * it will continue to exist until the app is closed or all threads using this { @ link SyncConfiguration } closes their respective { @ link Realm } s . 
 * < p > 
 - * A session is fully controlled by Realm , but can provide additional information in case of errors . 
 - * It is passed along in all { @ link SyncSession . ErrorHandler } s . 
 + * A session is controlled by Realm , but can provide additional information in case of errors . 
 + * These errors are passed along in the { @ link SyncSession . ErrorHandler } . 
 + * < p > 
 + * When creating a session , Realm will establish a connection to the server . This connection is 
 + * controlled by Realm and might be shared between multiple sessions . It is possible to get insight 
 + * into the connection using { @ link # addConnectionChangeListener ( ConnectionListener ) } and { @ link # isConnected ( ) } . 
 + * < p > 
 + * The session itself has a different lifecycle than the underlying connection . The state of the session 
 + * can be found using { @ link # getState ( ) } . 
 * < p > 
 - * This object is thread safe . 
 + * The { @ link SyncSession } object is thread safe . 
 * / 
 @ Keep 
 public class SyncSession { 
 @ @ - 101 , 13 + 112 , 67 @ @ public class SyncSession { 
 private static final byte STATE _ VALUE _ INACTIVE = 3 ; 
 private static final byte STATE _ VALUE _ ERROR = 4 ; 
 
 + / / List of Java connection change listeners 
 + private final CopyOnWriteArrayList < ConnectionListener > connectionListeners = new CopyOnWriteArrayList < > ( ) ; 
 + 
 + / / Reference to the token representing the native listener for connection changes 
 + / / Only one native listener is used for all Java listeners 
 + private long nativeConnectionListenerToken ; 
 + 
 + / / represent different states as defined in SyncSession : : PublicConnectionState ' sync _ session . hpp ' 
 + / / saved here instead of as constants in ConnectionState . java to enable static checking by JNI 
 + static final byte CONNECTION _ VALUE _ DISCONNECTED = 0 ; 
 + static final byte CONNECTION _ VALUE _ CONNECTING = 1 ; 
 + static final byte CONNECTION _ VALUE _ CONNECTED = 2 ; 
 + 
 private URI resolvedRealmURI ; 
 
 + / * * 
 + * Enum describing the states a SyncSession can be in . The initial state is 
 + * { @ link State # INACTIVE } . 
 + * < p > 
 + * A Realm will automatically synchronize data with the server if the session is either { @ link State # ACTIVE } 
 + * or { @ link State # DYING } and { @ link # isConnected ( ) } returns { @ code true } . 
 + * / 
 public enum State { 
 + 
 + / * * 
 + * This is the initial state . The session is closed . No data is being synchronized . The session 
 + * will automatically transition to { @ link # WAITING _ FOR _ ACCESS _ TOKEN } when a Realm is opened . 
 + * / 
 + INACTIVE ( STATE _ VALUE _ INACTIVE ) , 
 + 
 + / * * 
 + * The user is attempting to synchronize data but needs a valid access token to do so . Realm 
 + * will either use a cached token or automatically try to acquire one based on the current 
 + * users login . This requires a network connection . 
 + * < p > 
 + * Data cannot be synchronized in this state . 
 + * < p > 
 + * Once a valid token is acquired , the session will transition to { @ link # ACTIVE } . 
 + * / 
 WAITING _ FOR _ ACCESS _ TOKEN ( STATE _ VALUE _ WAITING _ FOR _ ACCESS _ TOKEN ) , 
 + 
 + / * * 
 + * The Realm is open and data will be synchronized between the device and the server 
 + * if the underlying connection is { @ link ConnectionState # CONNECTED } . 
 + * < p > 
 + * The session will remain in this state until either the current login expires or the Realm 
 + * is closed . In the first case , the session will transition to { @ link # WAITING _ FOR _ ACCESS _ TOKEN } , 
 + * in the second case , it will become { @ link # DYING } . 
 + * / 
 ACTIVE ( STATE _ VALUE _ ACTIVE ) , 
 + 
 + / * * 
 + * The Realm was closed , but still contains data that needs to be synchronized to the server . 
 + * The session will attempt to upload all local data before going { @ link # INACTIVE } . 
 + * / 
 DYING ( STATE _ VALUE _ DYING ) , 
 - INACTIVE ( STATE _ VALUE _ INACTIVE ) , 
 + 
 + / * * 
 + * DEPRECATED : This is never used . Errors are reported to { @ link ErrorHandler } instead . 
 + * / 
 + @ Deprecated 
 ERROR ( STATE _ VALUE _ ERROR ) ; 
 
 final byte value ; 
 @ @ - 116 , 7 + 181 , 7 @ @ public class SyncSession { 
 this . value = value ; 
 } 
 
 - static State fromByte ( byte value ) { 
 + static State fromNativeValue ( long value ) { 
 State [ ] stateCodes = values ( ) ; 
 for ( State state : stateCodes ) { 
 if ( state . value = = value ) { 
 @ @ - 124 , 7 + 189 , 7 @ @ public class SyncSession { 
 } 
 } 
 
 - throw new IllegalArgumentException ( " Unknown state code : " + value ) ; 
 + throw new IllegalArgumentException ( " Unknown session state code : " + value ) ; 
 } 
 } 
 
 @ @ - 188 , 14 + 253 , 45 @ @ public class SyncSession { 
 * @ return the state of the session . 
 * @ see SyncSession . State 
 * / 
 - @ SuppressWarnings ( " unused " ) 
 public State getState ( ) { 
 byte state = nativeGetState ( configuration . getPath ( ) ) ; 
 if ( state = = - 1 ) { 
 / / session was not found , probably the Realm was closed 
 throw new IllegalStateException ( " Could not find session , Realm was probably closed " ) ; 
 } 
 - return State . fromByte ( state ) ; 
 + return State . fromNativeValue ( state ) ; 
 + } 
 + 
 + / * * 
 + * Get the current state of the connection used by the session as defined in { @ link ConnectionState } . 
 + * 
 + * @ return the state of connection used by the session . 
 + * @ see ConnectionState 
 + * / 
 + public ConnectionState getConnectionState ( ) { 
 + byte state = nativeGetConnectionState ( configuration . getPath ( ) ) ; 
 + if ( state = = - 1 ) { 
 + / / session was not found , probably the Realm was closed 
 + throw new IllegalStateException ( " Could not find session , Realm was probably closed " ) ; 
 + } 
 + return ConnectionState . fromNativeValue ( state ) ; 
 + } 
 + 
 + / * * 
 + * Checks if the session is connected to the server and can synchronize data . 
 + * 
 + * This is a best guess effort . To conserve battery the underlying implementation uses heartbeats 
 + * to detect if the connection is still available . So if no data is actively being synced 
 + * and some time has elapsed since the last heartbeat , the connection could have been dropped but 
 + * this method will still return { @ code true } . 
 + * 
 + * @ return { @ code true } if the session is connected and ready to synchronize data , { @ code false } 
 + * if not or if it is in the process of connecting . 
 + * / 
 + public boolean isConnected ( ) { 
 + ConnectionState connectionState = ConnectionState . fromNativeValue ( nativeGetConnectionState ( configuration . getPath ( ) ) ) ; 
 + State sessionState = getState ( ) ; 
 + return ( sessionState = = State . ACTIVE | | sessionState = = State . DYING ) & & connectionState = = ConnectionState . CONNECTED ; 
 } 
 
 synchronized void notifyProgressListener ( long listenerId , long transferredBytes , long transferableBytes ) { 
 @ @ - 210 , 7 + 306 , 13 @ @ public class SyncSession { 
 RealmLog . debug ( " Trying unknown listener failed : " + listenerId ) ; 
 } 
 } 
 - 
 + 
 + void notifyConnectionListeners ( ConnectionState oldState , ConnectionState newState ) { 
 + for ( ConnectionListener listener : connectionListeners ) { 
 + listener . onChange ( oldState , newState ) ; 
 + } 
 + } 
 + 
 / * * 
 * Adds a progress listener tracking changes that need to be downloaded from the Realm Object 
 * Server . 
 @ @ - 297 , 6 + 399 , 36 @ @ public class SyncSession { 
 } 
 } 
 
 + / * * 
 + * Adds a listener tracking changes to the connection backing this session . See { @ link ConnectionState } 
 + * for further details . 
 + * 
 + * @ param listener the listener to register . 
 + * @ throws IllegalArgumentException if the listener is { @ code null } . 
 + * @ see ConnectionState 
 + * / 
 + public synchronized void addConnectionChangeListener ( ConnectionListener listener ) { 
 + checkNonNullListener ( listener ) ; 
 + if ( connectionListeners . isEmpty ( ) ) { 
 + nativeConnectionListenerToken = nativeAddConnectionListener ( configuration . getPath ( ) ) ; 
 + } 
 + connectionListeners . add ( listener ) ; 
 + } 
 + 
 + / * * 
 + * Removes a previously registered { @ link ConnectionListener } . 
 + * 
 + * @ param listener listener to remove 
 + * @ throws IllegalArgumentException if the listener is { @ code null } . 
 + * / 
 + public synchronized void removeConnectionChangeListener ( ConnectionListener listener ) { 
 + checkNonNullListener ( listener ) ; 
 + connectionListeners . remove ( listener ) ; 
 + if ( connectionListeners . isEmpty ( ) ) { 
 + nativeRemoveConnectionListener ( nativeConnectionListenerToken , configuration . getPath ( ) ) ; 
 + } 
 + } 
 + 
 void close ( ) { 
 isClosed = true ; 
 if ( networkRequest ! = null ) { 
 @ @ - 438 , 6 + 570 , 12 @ @ public class SyncSession { 
 } 
 } 
 
 + private void checkNonNullListener ( @ Nullable Object listener ) { 
 + if ( listener = = null ) { 
 + throw new IllegalArgumentException ( " Non - null ' listener ' required . " ) ; 
 + } 
 + } 
 + 
 / * * 
 * Interface used to report any session errors . 
 * 
 @ @ - 712 , 10 + 850 , 13 @ @ public class SyncSession { 
 } 
 } 
 
 + private static native long nativeAddConnectionListener ( String localRealmPath ) ; 
 + private static native void nativeRemoveConnectionListener ( long listenerId , String localRealmPath ) ; 
 private static native long nativeAddProgressListener ( String localRealmPath , long listenerId , int direction , boolean isStreaming ) ; 
 private static native void nativeRemoveProgressListener ( String localRealmPath , long listenerToken ) ; 
 private static native boolean nativeRefreshAccessToken ( String localRealmPath , String accessToken , String realmUrl ) ; 
 private native boolean nativeWaitForDownloadCompletion ( int callbackId , String localRealmPath ) ; 
 private native boolean nativeWaitForUploadCompletion ( int callbackId , String localRealmPath ) ; 
 private static native byte nativeGetState ( String localRealmPath ) ; 
 + private static native byte nativeGetConnectionState ( String localRealmPath ) ; 
 } 
 diff - - git a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java 
 index 7ccccc9 . . c14df62 100644 
 - - - a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java 
 + + + b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java 
 @ @ - 510 , 4 + 510 , 68 @ @ public class SyncSessionTests extends StandardIntegrationTest { 
 SyncManager . simulateClientReset ( SyncManager . getSession ( config ) ) ; 
 } 
 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void registerConnectionListener ( ) { 
 + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; 
 + SyncConfiguration syncConfiguration = configFactory 
 + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) 
 + . build ( ) ; 
 + Realm realm = Realm . getInstance ( syncConfiguration ) ; 
 + SyncSession session = SyncManager . getSession ( syncConfiguration ) ; 
 + session . addConnectionChangeListener ( ( oldState , newState ) - > { 
 + if ( newState = = ConnectionState . DISCONNECTED ) { 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + realm . close ( ) ; 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void removeConnectionListener ( ) { 
 + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; 
 + SyncConfiguration syncConfiguration = configFactory 
 + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) 
 + . build ( ) ; 
 + Realm realm = Realm . getInstance ( syncConfiguration ) ; 
 + SyncSession session = SyncManager . getSession ( syncConfiguration ) ; 
 + ConnectionListener listener1 = ( oldState , newState ) - > { 
 + if ( newState = = ConnectionState . DISCONNECTED ) { 
 + fail ( " Listener should have been removed " ) ; 
 + } 
 + } ; 
 + ConnectionListener listener2 = ( oldState , newState ) - > { 
 + if ( newState = = ConnectionState . DISCONNECTED ) { 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ; 
 + 
 + session . addConnectionChangeListener ( listener1 ) ; 
 + session . addConnectionChangeListener ( listener2 ) ; 
 + session . removeConnectionChangeListener ( listener1 ) ; 
 + realm . close ( ) ; 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void isConnected ( ) { 
 + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; 
 + SyncConfiguration syncConfiguration = configFactory 
 + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) 
 + . build ( ) ; 
 + looperThread . closeAfterTest ( Realm . getInstance ( syncConfiguration ) ) ; 
 + SyncSession session = SyncManager . getSession ( syncConfiguration ) ; 
 + if ( session . isConnected ( ) ) { 
 + looperThread . testComplete ( ) ; 
 + } else { 
 + session . addConnectionChangeListener ( ( ( oldState , newState ) - > { 
 + if ( newState = = ConnectionState . CONNECTED ) { 
 + assertEquals ( session . getConnectionState ( ) , ConnectionState . CONNECTED ) ; 
 + assertTrue ( session . isConnected ( ) ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ) ; 
 + } 
 + } 
 }

NEAREST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index 1912025 . . 4d02c8a 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * Fixed unchecked cast warnings when building with Realm . 
 * Cleaned up examples ( remove old test project ) . 
 * Added checking for missing generic type in RealmList fields in annotation processor . 
 + * Support async queries 
 
 0 . 80 . 3 
 * Calling Realm . copyToRealmOrUpdate ( ) with an object with a null primary key now throws a proper exception . 
 diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 index bb26d54 . . 3cad125 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 @ @ - 14 , 12 + 14 , 14 @ @ 
 * limitations under the License . 
 * / 
 
 + # include < realm / group _ shared . hpp > 
 # include " util . hpp " 
 # include " io _ realm _ internal _ TableQuery . h " 
 # include " tablequery . hpp " 
 
 using namespace realm ; 
 
 + # define SG ( ptr ) reinterpret _ cast < SharedGroup * > ( ptr ) 
 # if 1 
 # define COL _ TYPE _ VALID ( env , ptr , col , type ) TBL _ AND _ COL _ INDEX _ AND _ TYPE _ VALID ( env , ptr , col , type ) 
 # define COL _ TYPE _ LINK _ OR _ LINKLIST ( env , ptr , col ) TBL _ AND _ COL _ INDEX _ AND _ LINK _ OR _ LINKLIST ( env , ptr , col ) 
 @ @ - 1174 , 3 + 1176 , 47 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNull ( 
 pQuery - > and _ query ( query ) ; 
 } CATCH _ STD ( ) 
 } 
 + 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover 
 + ( JNIEnv * env , jobject , jlong callerSharedGrpPtr , jlong bgSharedGroupPtr , jlong nativeQueryPtr , jlong start , jlong end , jlong limit ) 
 + { 
 + Query * pQuery = Q ( nativeQueryPtr ) ; 
 + Table * pTable = pQuery - > get _ table ( ) . get ( ) ; 
 + if ( ! QUERY _ VALID ( env , pQuery ) | | 
 + ! ROW _ INDEXES _ VALID ( env , pTable , start , end , limit ) ) 
 + return - 1 ; 
 + try { 
 + TableView * pResultView = new TableView ( pQuery - > find _ all ( S ( start ) , S ( end ) , S ( limit ) ) ) ; 
 + std : : unique _ ptr < SharedGroup : : Handover < TableView > > handover ; 
 + handover . reset ( SG ( bgSharedGroupPtr ) - > export _ for _ handover ( * pResultView , ConstSourcePayload : : Copy ) ) ; 
 + / / TODO reimplement this so the call to ' export _ for _ handover ' is done on a background thread 
 + / / and ' import _ from _ handover ' on the caller thread . 
 + / / 
 + / / According to core , it ' s preferable to return first the exported handover 
 + / / then import it from the calling SharedGroup ( Thread ) . 
 + / / We need to make sure to check that the version id ( version of the shared group used to perform the query ) 
 + / / is the same as the caller SharedGroup , otherwise the import will fail . In this case , we should 
 + / / either retry the entire query , or call again ' sync _ if _ needed ' on the TableView to re - query , at this point 
 + / / we need to export again the handover to the caller SharedGroup , until we converge 
 + / / ( i . e the version of the caller SharedGroup matches the version returned by the handover TableView ) 
 + / / 
 + / / Note : The mode ' ConstSourcePayload : : Copy ' handover perform a deep copy of the TableView , this means that we copy 
 + / / both the Payload ( row accessors ) & the Query 
 + / / 
 + / / The mode ' ConstSourcePayload : : Stay ' handover perform a copy of the Query only ( no payload ) 
 + / / The mode ' MutableSourcePayload : : Move ' handover perform a move of both the Payload & Query 
 + / / 
 + / / The expensive operations are in that order 
 + / / pQuery - > find _ all > > export _ for _ handover > > import _ from _ handover 
 + / / so it ' s recommended to run the ' query ' & the ' export ' on a background Thread , then 
 + / / call ' import _ from _ handover ' on the caller thread ( most of the time UI thread ) . 
 + / / calling ' import _ from _ handover ' on the UI thread has another benefit , it will block the SharedGroup 
 + / / from modifying it ' s state ( advance _ read , promote _ write , rollback , commit etc ) 
 + / / 
 + / / The handover pointer is Thread safe , it can be passed from different Threads ( using different SharedGroups ) 
 + 
 + TableView * tv ( SG ( callerSharedGrpPtr ) - > import _ from _ handover ( handover . release ( ) ) ) ; 
 + return reinterpret _ cast < jlong > ( tv ) ; 
 + } CATCH _ STD ( ) 
 + return - 1 ; 
 + } 
 diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 index 5ccb9ee . . 97a9ed7 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 @ @ - 369 , 6 + 369 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAll 
 
 / * 
 * Class : io _ realm _ internal _ TableQuery 
 + * Method : nativeFindAllWithHandover 
 + * Signature : ( JJJJJJ ) J 
 + * / 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover 
 + ( JNIEnv * , jobject , jlong , jlong , jlong , jlong , jlong , jlong ) ; 
 + 
 + / * 
 + * Class : io _ realm _ internal _ TableQuery 
 * Method : nativeSumInt 
 * Signature : ( JJJJJ ) J 
 * / 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 new file mode 100644 
 index 0000000 . . 162e33a 
 - - - / dev / null 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 0 , 0 + 1 , 151 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm ; 
 + 
 + import android . os . Looper ; 
 + import android . test . InstrumentationTestCase ; 
 + 
 + import junit . framework . AssertionFailedError ; 
 + 
 + import java . util . Date ; 
 + import java . util . concurrent . CountDownLatch ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Executors ; 
 + 
 + import io . realm . entities . AllTypes ; 
 + import io . realm . entities . NonLatinFieldNames ; 
 + 
 + public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 + 
 + / / TODO use Junit4 & define a rule to setup the threading , to avoid 
 + / / this boiler plat code , or use a custom test runner 
 + public void testFindAll ( ) throws Throwable { 
 + / / We need to control precisely which Looper / Thread our Realm 
 + / / will operate on . This is unfortunately not possible when using the 
 + / / current Instrumentation # InstrumentationThread , because InstrumentationTestRunner # onStart 
 + / / Call Looper . prepare ( ) for us and surprisingly doesn ' t call Looper # loop ( ) , this is problematic 
 + / / as the async query callback will not run ( because the Handler is sending Runnables to a Looper 
 + / / that didn ' t loop . 
 + / / 
 + / / In the other hand , using a dedicated ' ExecutorService ' will allow us to fine grain control the 
 + / / desired behaviour 
 + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final Looper [ ] looper = new Looper [ 1 ] ; 
 + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + executorService . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + looper [ 0 ] = Looper . myLooper ( ) ; 
 + Realm realm = null ; 
 + try { 
 + realm = openRealmInstance ( ) ; 
 + populateTestRealm ( realm , 10 ) ; 
 + 
 + / / async query ( will run on different thread ) 
 + realm . asyncWhere ( AllTypes . class , 
 + new Realm . AsyncCallback < RealmResults < AllTypes > > ( ) { 
 + @ Override 
 + public void onSuccess ( RealmResults < AllTypes > results ) { 
 + try { 
 + assertEquals ( 10 , results . size ( ) ) ; 
 + 
 + / / Make sure access to RealmObject will not throw an Exception 
 + for ( int i = 0 , size = results . size ( ) ; i < size ; i + + ) { 
 + assertEquals ( i , results . get ( i ) . getColumnLong ( ) ) ; 
 + } 
 + 
 + } catch ( AssertionFailedError e ) { 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + / / whatever happened , make sure to notify the waiting TestCase Thread 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onError ( Throwable t ) { 
 + try { 
 + threadAssertionError [ 0 ] = t ; 
 + t . printStackTrace ( ) ; 
 + } finally { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + } ) 
 + . between ( " columnLong " , 0 , 9 ) . findAll ( ) ; 
 + 
 + Looper . loop ( ) ; / / ready to receive callback 
 + 
 + } finally { 
 + if ( realm ! = null ) { 
 + realm . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + / / wait until the callback of our async query proceed 
 + signalCallbackFinished . await ( ) ; 
 + looper [ 0 ] . quit ( ) ; 
 + executorService . shutdownNow ( ) ; 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / Throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + } 
 + 
 + / / * * * Helper methods * * * 
 + 
 + / / This could be done from # setUp but then we can ' t control 
 + / / which Looper we want to associate this Realm instance with 
 + private Realm openRealmInstance ( ) { 
 + RealmConfiguration realmConfiguration = new RealmConfiguration . 
 + Builder ( getInstrumentation ( ) 
 + . getTargetContext ( ) ) 
 + . name ( " test . realm " ) 
 + . deleteRealmIfMigrationNeeded ( ) 
 + . build ( ) ; 
 + Realm . deleteRealm ( realmConfiguration ) ; 
 + return Realm . getInstance ( realmConfiguration ) ; 
 + } 
 + 
 + private void populateTestRealm ( final Realm testRealm , int objects ) { 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . allObjects ( AllTypes . class ) . clear ( ) ; 
 + testRealm . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; 
 + for ( int i = 0 ; i < objects ; + + i ) { 
 + AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; 
 + allTypes . setColumnBoolean ( ( i % 3 ) = = 0 ) ; 
 + allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; 
 + allTypes . setColumnDate ( new Date ( ) ) ; 
 + allTypes . setColumnDouble ( 3 . 1415 ) ; 
 + allTypes . setColumnFloat ( 1 . 234567f + i ) ; 
 + allTypes . setColumnString ( " test data " + i ) ; 
 + allTypes . setColumnLong ( i ) ; 
 + NonLatinFieldNames nonLatinFieldNames = testRealm . createObject ( NonLatinFieldNames . class ) ; 
 + nonLatinFieldNames . set 델 타 ( i ) ; 
 + nonLatinFieldNames . set Δ έ λ τ α ( i ) ; 
 + nonLatinFieldNames . set 베 타 ( 1 . 234567f + i ) ; 
 + nonLatinFieldNames . set Β ή τ α ( 1 . 234567f + i ) ; 
 + } 
 + testRealm . commitTransaction ( ) ; 
 + testRealm . refresh ( ) ; 
 + } 
 + } 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index ca29295 . . d2e5033 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 22 , 7 + 22 , 6 @ @ import org . json . JSONArray ; 
 import org . json . JSONException ; 
 import org . json . JSONObject ; 
 
 - import java . io . ByteArrayInputStream ; 
 import java . io . File ; 
 import java . io . IOException ; 
 import java . io . InputStream ; 
 diff - - git a / realm / src / main / java / io / realm / AsyncRealmQueryResult . java b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java 
 new file mode 100644 
 index 0000000 . . 7318359 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java 
 @ @ - 0 , 0 + 1 , 25 @ @ 
 + package io . realm ; 
 + 
 + import java . util . concurrent . Future ; 
 + 
 + / * * 
 + * Represents the result of an asynchronous Realm query . 
 + * 
 + * Users are responsible of maintaining a reference to { @ code AsyncRealmQueryResult } in order 
 + * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the 
 + * query will post the result to the caller ' s thread callback ) 
 + * / 
 + public class AsyncRealmQueryResult { 
 + final Future < ? > pendingQuery ; 
 + 
 + public AsyncRealmQueryResult ( Future < ? > pendingQuery ) { 
 + this . pendingQuery = pendingQuery ; 
 + } 
 + 
 + / * * 
 + * Attempts to cancel execution of this queries . 
 + * / 
 + public void cancel ( ) { 
 + pendingQuery . cancel ( true ) ; 
 + } 
 + } 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index ddbc022 . . 15aac8b 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 63 , 6 + 63 , 7 @ @ import io . realm . internal . SharedGroup ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableView ; 
 import io . realm . internal . Util ; 
 + import io . realm . internal . android . AsyncRealmQuery ; 
 import io . realm . internal . android . DebugAndroidLogger ; 
 import io . realm . internal . android . ReleaseAndroidLogger ; 
 import io . realm . internal . log . RealmLog ; 
 @ @ - 154 , 6 + 155 , 9 @ @ public final class Realm implements Closeable { 
 private static final Map < String , AtomicInteger > globalOpenInstanceCounter = 
 new ConcurrentHashMap < String , AtomicInteger > ( ) ; 
 
 + / / Thread Pool for all async operations ( Query & Write transaction ) 
 + public static final ExecutorService asyncQueryExecutor = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) * 2 + 1 ) ; 
 + 
 protected static final Map < Handler , String > handlers = new ConcurrentHashMap < Handler , String > ( ) ; 
 private static final int REALM _ CHANGED = 14930352 ; / / Hopefully it won ' t clash with other message IDs . 
 
 @ @ - 1198 , 6 + 1202 , 20 @ @ public final class Realm implements Closeable { 
 } 
 
 / * * 
 + * Prepare an async query 
 + * TODO point to documentation or example about async query 
 + * @ param clazz The class of the object which is to be queried for 
 + * @ return A typed RealmQuery , which can be used to query for specific objects of this type 
 + * @ throws java . lang . RuntimeException Any other error 
 + * @ see io . realm . RealmQuery 
 + * @ param callback 
 + * / 
 + public < E extends RealmObject > AsyncRealmQuery < E > asyncWhere ( Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { 
 + checkIfValid ( ) ; 
 + return new AsyncRealmQuery < E > ( this , clazz , callback ) ; 
 + } 
 + 
 + / * * 
 * Get all objects of a specific Class . If no objects exist , the returned RealmResults will not 
 * be null . The RealmResults . size ( ) to check the number of objects instead . 
 * 
 @ @ - 1872 , 4 + 1890 , 24 @ @ public final class Realm implements Closeable { 
 void execute ( Realm realm ) ; 
 } 
 
 + / * * 
 + * Encapsulates an async { @ link RealmQuery } . 
 + * < p > 
 + * This will run the { @ link RealmQuery } on a worker thread , then invoke this callback on the caller thread 
 + * / 
 + public interface AsyncCallback < T extends RealmResults < ? extends RealmObject > > { 
 + void onSuccess ( T results ) ; 
 + void onError ( Throwable t ) ; 
 + } 
 + 
 + 
 + / / FIXME Realm . java being the public API and the implementation . 
 + / / we need a Realm interface to be able to separate this kind of call 
 + / / ( mostly from internal API / tests that need to access private field / method ) . 
 + / / RealmImpl will be accessible to other internal packages 
 + / / but not to the user ( avoid compromising our exposed public API ) 
 + / / 
 + public long getSharedGroupPtr ( ) { 
 + return sharedGroup . nativePtr ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index df847f5 . . b744adc 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1302 , 4 + 1302 , 8 @ @ public class RealmQuery < E extends RealmObject > { 
 return null ; 
 } 
 } 
 + 
 + protected TableQuery getTableQuery ( ) { 
 + return this . query ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / internal / TableQuery . java b / realm / src / main / java / io / realm / internal / TableQuery . java 
 index e82eaa7 . . 268645d 100644 
 - - - a / realm / src / main / java / io / realm / internal / TableQuery . java 
 + + + b / realm / src / main / java / io / realm / internal / TableQuery . java 
 @ @ - 493 , 8 + 493 , 24 @ @ public class TableQuery implements Closeable { 
 } 
 } 
 
 - protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; 
 + public TableView findAllWithHandover ( long callerSharedGroupPtr , long bgSharedGroupPtr ) { 
 + validateQuery ( ) ; 
 + 
 + / / Execute the disposal of abandoned realm objects each time a new realm object is created 
 + context . executeDelayedDisposal ( ) ; 
 + long nativeViewPtr = nativeFindAllWithHandover ( callerSharedGroupPtr , bgSharedGroupPtr , nativePtr , 0 , Table . INFINITE , Table . INFINITE ) ; / / nativeViewPtr is created from bg Thread 
 + / / handover nativeViewPtr to UI Thread 
 + 
 + try { 
 + return new TableView ( this . context , this . parent , nativeViewPtr ) ; 
 + } catch ( RuntimeException e ) { 
 + TableView . nativeClose ( nativeViewPtr ) ; 
 + throw e ; 
 + } 
 + } 
 
 + protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; 
 + protected native long nativeFindAllWithHandover ( long nativeCallerSharedGroupPtr , long bgSharedGroupPtr , long nativeQueryPtr , long start , long end , long limit ) ; 
 / / 
 / / Aggregation methods 
 / / 
 diff - - git a / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java 
 new file mode 100644 
 index 0000000 . . c3716eb 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java 
 @ @ - 0 , 0 + 1 , 165 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . android ; 
 + 
 + import android . os . Handler ; 
 + import android . os . Looper ; 
 + import android . os . Message ; 
 + 
 + import java . util . concurrent . Future ; 
 + 
 + import io . realm . AsyncRealmQueryResult ; 
 + import io . realm . Realm ; 
 + import io . realm . RealmConfiguration ; 
 + import io . realm . RealmObject ; 
 + import io . realm . RealmQuery ; 
 + import io . realm . RealmResults ; 
 + import io . realm . internal . TableOrView ; 
 + import io . realm . internal . TableView ; 
 + 
 + import static io . realm . Realm . asyncQueryExecutor ; 
 + 
 + / * * 
 + * A helper class to help make handling asynchronous { @ link RealmQuery } easier . 
 + * 
 + * @ param < E > type of the object which is to be queried for 
 + * / 
 + / / Behaviour may change , user should not subclass 
 + public final class AsyncRealmQuery < E extends RealmObject > { 
 + private final Realm callerRealm ; 
 + private final Class < E > clazz ; 
 + private final Realm . AsyncCallback < RealmResults < E > > callback ; 
 + 
 + private int from ; 
 + private int to ; 
 + private String fieldName ; 
 + private EventHandler eventHandler ; 
 + private Future < ? > pendingQuery ; 
 + 
 + / * * 
 + * Create an { @ code AsyncRealmQuery } instance . 
 + * 
 + * @ param realm The realm to query within . 
 + * @ param clazz The class to query . 
 + * @ param callback invoked on the thread { @ link Realm # asyncWhere ( Class , Realm . AsyncCallback ) } was called from , to post results . 
 + * / 
 + public AsyncRealmQuery ( Realm realm , Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { 
 + this . callerRealm = realm ; 
 + this . callback = callback ; 
 + this . clazz = clazz ; 
 + } 
 + 
 + / * * 
 + * Between condition 
 + * 
 + * @ param fieldName The field to compare 
 + * @ param from Lowest value ( inclusive ) 
 + * @ param to Highest value ( inclusive ) 
 + * @ return current instance of { @ code AsyncRealmQuery } for method chaining 
 + * / 
 + public AsyncRealmQuery < E > between ( String fieldName , int from , int to ) { 
 + this . from = from ; 
 + this . to = to ; 
 + this . fieldName = fieldName ; 
 + return this ; 
 + } 
 + 
 + / * * 
 + * Find all objects that fulfill the query conditions . 
 + * Results will be posted to the callback instance { @ link io . realm . Realm . AsyncCallback } asynchronously 
 + * If no objects match the condition , a list with zero objects is returned . 
 + * 
 + * @ see io . realm . RealmResults 
 + * / 
 + public AsyncRealmQueryResult findAll ( ) { 
 + / / will use the Looper of the caller thread to post the result 
 + Looper looper ; 
 + if ( ( looper = Looper . myLooper ( ) ) ! = null ) { 
 + eventHandler = new EventHandler ( looper ) ; 
 + } else if ( ( looper = Looper . getMainLooper ( ) ) ! = null ) { 
 + eventHandler = new EventHandler ( looper ) ; 
 + } else { 
 + eventHandler = null ; / / FIXME define strategy / behaviour for regular JVM call 
 + } 
 + 
 + / / We need a pointer to the caller Realm , to be able to handover the result to it 
 + final long callerSharedGroupNativePtr = callerRealm . getSharedGroupPtr ( ) ; 
 + 
 + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) 
 + / / to perform the query 
 + final RealmConfiguration realmConfiguration = callerRealm . getConfiguration ( ) ; 
 + 
 + pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + try { 
 + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 + 
 + / / TODO This will probably be replace by a kind of ' QueryBuilder ' 
 + / / that holds all the operations ( predicates / filters ) then 
 + / / replay them here in this background thread . The current implementation 
 + / / call Core for each step , we want to limit the overhead by sending one 
 + / / single call to Core with all the parameters . 
 + 
 + TableView tv = new RealmQueryAdapter < E > ( bgRealm , clazz ) 
 + . between ( fieldName , from , to ) 
 + . findAll ( callerSharedGroupNativePtr , bgRealm . getSharedGroupPtr ( ) ) ; 
 + 
 + bgRealm . close ( ) ; 
 + 
 + / / send results to the caller thread ' s callback 
 + if ( ! pendingQuery . isCancelled ( ) ) { 
 + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ SUCCESS , tv ) ; 
 + eventHandler . sendMessage ( msg ) ; 
 + } 
 + 
 + } catch ( Exception e ) { 
 + if ( ! pendingQuery . isCancelled ( ) ) { 
 + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ ERROR , e ) ; 
 + eventHandler . sendMessage ( msg ) ; 
 + } 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + return new AsyncRealmQueryResult ( pendingQuery ) ; 
 + } 
 + 
 + private class EventHandler extends Handler { 
 + private static final int MSG _ SUCCESS = 1 ; 
 + private static final int MSG _ ERROR = MSG _ SUCCESS + 1 ; 
 + 
 + public EventHandler ( Looper looper ) { 
 + super ( looper ) ; 
 + } 
 + 
 + @ Override 
 + public void handleMessage ( Message msg ) { 
 + switch ( msg . what ) { 
 + case MSG _ SUCCESS : 
 + RealmResults < E > resultList = new RealmResults < E > ( callerRealm , ( TableOrView ) msg . obj , clazz ) ; 
 + callback . onSuccess ( resultList ) ; 
 + break ; 
 + case MSG _ ERROR : 
 + callback . onError ( ( Throwable ) msg . obj ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java 
 new file mode 100644 
 index 0000000 . . acac317 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java 
 @ @ - 0 , 0 + 1 , 38 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . android ; 
 + 
 + import io . realm . Realm ; 
 + import io . realm . RealmObject ; 
 + import io . realm . RealmQuery ; 
 + import io . realm . internal . TableView ; 
 + 
 + class RealmQueryAdapter < E extends RealmObject > extends RealmQuery < E > { 
 + public RealmQueryAdapter ( Realm realm , Class < E > clazz ) { 
 + super ( realm , clazz ) ; 
 + } 
 + 
 + @ Override 
 + public RealmQueryAdapter < E > between ( String fieldName , int from , int to ) { 
 + super . between ( fieldName , from , to ) ; 
 + return this ; 
 + } 
 + 
 + public TableView findAll ( long callerRealmPtr , long backgroundRealmPtr ) { 
 + return getTableQuery ( ) . findAllWithHandover ( callerRealmPtr , backgroundRealmPtr ) ; 
 + } 
 + }
