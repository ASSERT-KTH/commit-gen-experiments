BLEU SCORE: 0.007934033722384819

TEST MSG: Clean up SharedRealm . java
GENERATED MSG: Adding addModule and setModules . Removed schema from Realm and added it as debug method on RealmConfiguration .

TEST DIFF (one line): diff - - git a / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java b / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java <nl> index 32a52cc . . 3c72498 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java <nl> @ @ - 33 , 49 + 33 , 6 @ @ import io . realm . internal . android . AndroidRealmNotifier ; <nl> @ Keep <nl> public final class SharedRealm implements Closeable , NativeObject { <nl> <nl> - / / Const value for RealmFileException conversion <nl> - public static final byte FILE _ EXCEPTION _ KIND _ ACCESS _ ERROR = 0 ; <nl> - public static final byte FILE _ EXCEPTION _ KIND _ BAD _ HISTORY = 1 ; <nl> - public static final byte FILE _ EXCEPTION _ KIND _ PERMISSION _ DENIED = 2 ; <nl> - public static final byte FILE _ EXCEPTION _ KIND _ EXISTS = 3 ; <nl> - public static final byte FILE _ EXCEPTION _ KIND _ NOT _ FOUND = 4 ; <nl> - public static final byte FILE _ EXCEPTION _ KIND _ INCOMPATIBLE _ LOCK _ FILE = 5 ; <nl> - public static final byte FILE _ EXCEPTION _ KIND _ FORMAT _ UPGRADE _ REQUIRED = 6 ; <nl> - public static final byte FILE _ EXCEPTION _ INCOMPATIBLE _ SYNC _ FILE = 7 ; <nl> - private static final long nativeFinalizerPtr = nativeGetFinalizerPtr ( ) ; <nl> - <nl> - public static void initialize ( File tempDirectory ) { <nl> - if ( SharedRealm . temporaryDirectory ! = null ) { <nl> - / / already initialized <nl> - return ; <nl> - } <nl> - <nl> - String temporaryDirectoryPath = tempDirectory . getAbsolutePath ( ) ; <nl> - if ( ! tempDirectory . isDirectory ( ) & & ! tempDirectory . mkdirs ( ) & & ! tempDirectory . isDirectory ( ) ) { <nl> - throw new IOException ( " failed to create temporary directory : " + temporaryDirectoryPath ) ; <nl> - } <nl> - <nl> - if ( ! temporaryDirectoryPath . endsWith ( " / " ) ) { <nl> - temporaryDirectoryPath + = " / " ; <nl> - } <nl> - nativeInit ( temporaryDirectoryPath ) ; <nl> - SharedRealm . temporaryDirectory = tempDirectory ; <nl> - } <nl> - <nl> - public static File getTemporaryDirectory ( ) { <nl> - return temporaryDirectory ; <nl> - } <nl> - <nl> - private static volatile File temporaryDirectory ; <nl> - <nl> - private final List < WeakReference < PendingRow > > pendingRows = new CopyOnWriteArrayList < > ( ) ; <nl> - public final List < WeakReference < Collection > > collections = new CopyOnWriteArrayList < > ( ) ; <nl> - public final List < WeakReference < Collection . Iterator > > iterators = new ArrayList < > ( ) ; <nl> - <nl> - / / JNI will only hold a weak global ref to this . <nl> - public final RealmNotifier realmNotifier ; <nl> - public final Capabilities capabilities ; <nl> - <nl> public static class VersionID implements Comparable < VersionID > { <nl> public final long version ; <nl> public final long index ; <nl> @ @ - 140 , 9 + 97 , 9 @ @ public final class SharedRealm implements Closeable , NativeObject { <nl> * Callback function . <nl> * <nl> * @ param sharedRealm the same { @ link SharedRealm } instance which has been created from the same <nl> - * { @ link OsRealmConfig } instance . <nl> - * @ param oldVersion the schema version of the existing Realm file . <nl> - * @ param newVersion the expected schema version after migration . <nl> + * { @ link OsRealmConfig } instance . <nl> + * @ param oldVersion the schema version of the existing Realm file . <nl> + * @ param newVersion the expected schema version after migration . <nl> * / <nl> void onMigrationNeeded ( SharedRealm sharedRealm , long oldVersion , long newVersion ) ; <nl> } <nl> @ @ - 161 , 9 + 118 , 10 @ @ public final class SharedRealm implements Closeable , NativeObject { <nl> / * * <nl> * Callback function to be called from JNI by Object Store when the schema is changed . <nl> * / <nl> - @ SuppressWarnings ( " unused " ) <nl> @ Keep <nl> public interface SchemaChangedCallback { <nl> + / / Called from JNI <nl> + @ SuppressWarnings ( " unused " ) <nl> void onSchemaChanged ( ) ; <nl> } <nl> <nl> @ @ - 179 , 13 + 137 , 33 @ @ public final class SharedRealm implements Closeable , NativeObject { <nl> } <nl> <nl> public abstract void onSuccess ( Collection results ) ; <nl> + <nl> public abstract void onError ( RealmException error ) ; <nl> } <nl> <nl> - private final OsRealmConfig osRealmConfig ; <nl> + / / Const value for RealmFileException conversion <nl> + public static final byte FILE _ EXCEPTION _ KIND _ ACCESS _ ERROR = 0 ; <nl> + public static final byte FILE _ EXCEPTION _ KIND _ BAD _ HISTORY = 1 ; <nl> + public static final byte FILE _ EXCEPTION _ KIND _ PERMISSION _ DENIED = 2 ; <nl> + public static final byte FILE _ EXCEPTION _ KIND _ EXISTS = 3 ; <nl> + public static final byte FILE _ EXCEPTION _ KIND _ NOT _ FOUND = 4 ; <nl> + public static final byte FILE _ EXCEPTION _ KIND _ INCOMPATIBLE _ LOCK _ FILE = 5 ; <nl> + public static final byte FILE _ EXCEPTION _ KIND _ FORMAT _ UPGRADE _ REQUIRED = 6 ; <nl> + public static final byte FILE _ EXCEPTION _ INCOMPATIBLE _ SYNC _ FILE = 7 ; <nl> + <nl> + private static final long nativeFinalizerPtr = nativeGetFinalizerPtr ( ) ; <nl> private final long nativePtr ; <nl> + private final OsRealmConfig osRealmConfig ; <nl> final NativeContext context ; <nl> private final OsSchemaInfo schemaInfo ; <nl> + private static volatile File temporaryDirectory ; <nl> + / / JNI will only hold a weak global ref to this . <nl> + public final RealmNotifier realmNotifier ; <nl> + public final Capabilities capabilities ; <nl> + <nl> + private final List < WeakReference < PendingRow > > pendingRows = new CopyOnWriteArrayList < > ( ) ; <nl> + / / Package protected for testing <nl> + final List < WeakReference < Collection . Iterator > > iterators = new ArrayList < > ( ) ; <nl> <nl> private SharedRealm ( OsRealmConfig osRealmConfig ) { <nl> Capabilities capabilities = new AndroidCapabilities ( ) ; <nl> @ @ - 241 , 6 + 219 , 28 @ @ public final class SharedRealm implements Closeable , NativeObject { <nl> return new SharedRealm ( osRealmConfig ) ; <nl> } <nl> <nl> + public static void initialize ( File tempDirectory ) { <nl> + if ( SharedRealm . temporaryDirectory ! = null ) { <nl> + / / already initialized <nl> + return ; <nl> + } <nl> + <nl> + String temporaryDirectoryPath = tempDirectory . getAbsolutePath ( ) ; <nl> + if ( ! tempDirectory . isDirectory ( ) & & ! tempDirectory . mkdirs ( ) & & ! tempDirectory . isDirectory ( ) ) { <nl> + throw new IOException ( " failed to create temporary directory : " + temporaryDirectoryPath ) ; <nl> + } <nl> + <nl> + if ( ! temporaryDirectoryPath . endsWith ( " / " ) ) { <nl> + temporaryDirectoryPath + = " / " ; <nl> + } <nl> + nativeInit ( temporaryDirectoryPath ) ; <nl> + SharedRealm . temporaryDirectory = tempDirectory ; <nl> + } <nl> + <nl> + public static File getTemporaryDirectory ( ) { <nl> + return temporaryDirectory ; <nl> + } <nl> + <nl> public void beginTransaction ( ) { <nl> detachIterators ( ) ; <nl> executePendingRowQueries ( ) ; <nl> @ @ - 290 , 12 + 290 , 12 @ @ public final class SharedRealm implements Closeable , NativeObject { <nl> * Creates a { @ link Table } and adds a primary key field to it . Native assertion will happen if the table with the <nl> * same name exists . <nl> * <nl> - * @ param tableName the name of table . <nl> + * @ param tableName the name of table . <nl> * @ param primaryKeyFieldName the name of primary key field . <nl> - * @ param isStringType if this is true , the primary key field will be create as a string field . Otherwise it will <nl> - * be created as an integer field . <nl> - * @ param isNullable if the primary key field is nullable or not . <nl> - * @ return a creatd { @ link Table } object . <nl> + * @ param isStringType if this is true , the primary key field will be create as a string field . Otherwise it will <nl> + * be created as an integer field . <nl> + * @ param isNullable if the primary key field is nullable or not . <nl> + * @ return a newly created { @ link Table } object . <nl> * / <nl> public Table createTableWithPrimaryKey ( String tableName , String primaryKeyFieldName , boolean isStringType , <nl> boolean isNullable ) { <nl> @ @ - 420 , 7 + 420 , 7 @ @ public final class SharedRealm implements Closeable , NativeObject { <nl> } <nl> <nl> / / The detaching should happen before transaction begins . <nl> - void detachIterators ( ) { <nl> + private void detachIterators ( ) { <nl> for ( WeakReference < Collection . Iterator > iteratorRef : iterators ) { <nl> Collection . Iterator iterator = iteratorRef . get ( ) ; <nl> if ( iterator ! = null ) { <nl> @ @ - 476 , 7 + 476 , 7 @ @ public final class SharedRealm implements Closeable , NativeObject { <nl> / * * <nl> * Called from JNI when the expected schema doesn ' t match the existing one . <nl> * <nl> - * @ param callback the { @ link MigrationCallback } in the { @ link RealmConfiguration } . <nl> + * @ param callback the { @ link MigrationCallback } in the { @ link RealmConfiguration } . <nl> * @ param oldVersion the schema version of the existing Realm file . <nl> * / <nl> @ SuppressWarnings ( " unused " ) <nl> @ @ - 498 , 13 + 498 , 14 @ @ public final class SharedRealm implements Closeable , NativeObject { <nl> <nl> / * * <nl> * Called from JNI when the partial sync callback is invoked from the ObjectStore . <nl> - * @ param error if the partial sync query failed to register . <nl> + * <nl> + * @ param error if the partial sync query failed to register . <nl> * @ param nativeResultsPtr pointer to the { @ code Results } of the partial sync query . <nl> - * @ param callback the callback registered from the user to notify the success / error of the partial sync query . <nl> + * @ param callback the callback registered from the user to notify the success / error of the partial sync query . <nl> * / <nl> @ SuppressWarnings ( " unused " ) <nl> private void runPartialSyncRegistrationCallback ( @ Nullable String error , long nativeResultsPtr , <nl> - PartialSyncCallback callback ) { <nl> + PartialSyncCallback callback ) { <nl> if ( error ! = null ) { <nl> callback . onError ( new RealmException ( error ) ) ; <nl> } else {
NEAREST DIFF (one line): diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index a8f3297 . . 88b8c85 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 145 , 7 + 145 , 6 @ @ public final class Realm implements Closeable { <nl> <nl> private static RealmConfiguration defaultConfiguration ; <nl> <nl> - private static final String APT _ NOT _ EXECUTED _ MESSAGE = " Annotation processor may not have been executed . " ; <nl> private static final String INCORRECT _ THREAD _ MESSAGE = " Realm access from incorrect thread . Realm objects can only be accessed on the thread they where created . " ; <nl> private static final String CLOSED _ REALM _ MESSAGE = " This Realm instance has already been closed , making it unusable . " ; <nl> private static final String DIFFERENT _ KEY _ MESSAGE = " Wrong key used to decrypt Realm . " ; <nl> @ @ - 161 , 7 + 160 , 7 @ @ public final class Realm implements Closeable { <nl> private final ImplicitTransaction transaction ; <nl> <nl> private final List < WeakReference < RealmChangeListener > > changeListeners = new ArrayList < WeakReference < RealmChangeListener > > ( ) ; <nl> - private static RealmProxyMediator proxyMediator = getDefaultMediator ( ) ; <nl> + protected RealmProxyMediator proxyMediator ; <nl> <nl> private static final long UNVERSIONED = - 1 ; <nl> <nl> @ @ - 243 , 24 + 242 , 6 @ @ public final class Realm implements Closeable { <nl> handlers . remove ( handler ) ; <nl> } <nl> <nl> - private static RealmProxyMediator getDefaultMediator ( ) { <nl> - Class < ? > clazz ; <nl> - try { <nl> - clazz = Class . forName ( " io . realm . DefaultRealmModuleMediator " ) ; <nl> - Constructor < ? > constructor = clazz . getDeclaredConstructors ( ) [ 0 ] ; <nl> - constructor . setAccessible ( true ) ; <nl> - return ( RealmProxyMediator ) constructor . newInstance ( ) ; <nl> - } catch ( ClassNotFoundException e ) { <nl> - throw new RealmException ( " Could not find io . realm . DefaultRealmModuleMediator " , e ) ; <nl> - } catch ( InvocationTargetException e ) { <nl> - throw new RealmException ( " Could not create an instance of io . realm . DefaultRealmModuleMediator " , e ) ; <nl> - } catch ( InstantiationException e ) { <nl> - throw new RealmException ( " Could not create an instance of io . realm . DefaultRealmModuleMediator " , e ) ; <nl> - } catch ( IllegalAccessException e ) { <nl> - throw new RealmException ( " Could not create an instance of io . realm . DefaultRealmModuleMediator " , e ) ; <nl> - } <nl> - } <nl> - <nl> private class RealmCallback implements Handler . Callback { <nl> @ Override <nl> public boolean handleMessage ( Message message ) { <nl> @ @ - 547 , 7 + 528 , 6 @ @ public final class Realm implements Closeable { <nl> } <nl> <nl> private static synchronized Realm createAndValidate ( RealmConfiguration config , boolean validateSchema , boolean autoRefresh ) { <nl> - setSchema ( config . getSchema ( ) ) ; <nl> byte [ ] key = config . getEncryptionKey ( ) ; <nl> String canonicalPath = config . getPath ( ) ; <nl> Map < String , Integer > localRefCount = referenceCount . get ( ) ; <nl> @ @ - 576 , 6 + 556 , 7 @ @ public final class Realm implements Closeable { <nl> / / Create new Realm and cache it . All exception code paths must close the Realm otherwise we risk serving <nl> / / faulty cache data . <nl> realm = new Realm ( canonicalPath , key , autoRefresh ) ; <nl> + realm . proxyMediator = config . getSchemaMediator ( ) ; <nl> realms . put ( canonicalPath , realm ) ; <nl> realmsCache . set ( realms ) ; <nl> localRefCount . put ( canonicalPath , references + 1 ) ; <nl> @ @ - 625 , 13 + 606 , 13 @ @ public final class Realm implements Closeable { <nl> commitNeeded = true ; <nl> realm . setVersion ( config . getSchemaVersion ( ) ) ; <nl> } <nl> - for ( Class < ? extends RealmObject > modelClass : proxyMediator . getModelClasses ( ) ) { <nl> + for ( Class < ? extends RealmObject > modelClass : realm . proxyMediator . getModelClasses ( ) ) { <nl> / / Create and validate table <nl> if ( version = = UNVERSIONED ) { <nl> - proxyMediator . createTable ( modelClass , realm . transaction ) ; <nl> + realm . proxyMediator . createTable ( modelClass , realm . transaction ) ; <nl> } <nl> - proxyMediator . validateTable ( modelClass , realm . transaction ) ; <nl> - realm . columnIndices . addClass ( modelClass , proxyMediator . getColumnIndices ( modelClass ) ) ; <nl> + realm . proxyMediator . validateTable ( modelClass , realm . transaction ) ; <nl> + realm . columnIndices . addClass ( modelClass , realm . proxyMediator . getColumnIndices ( modelClass ) ) ; <nl> } <nl> } finally { <nl> if ( commitNeeded ) { <nl> @ @ - 1717 , 25 + 1698 , 7 @ @ public final class Realm implements Closeable { <nl> return canonicalPath ; <nl> } <nl> <nl> - / * * <nl> - * Override the standard behavior of all classes extended RealmObject being part of the schema . <nl> - * Use this method to define the schema as only the classes given here . <nl> - * <nl> - * This class must be called before calling { @ link # getInstance ( android . content . Context ) } <nl> - * ø <nl> - * If { @ code null } is given as parameter , the Schema is reset to use all known classes . <nl> - * <nl> - * / <nl> - private static void setSchema ( Collection < Class < ? extends RealmObject > > classes ) { <nl> - if ( classes ! = null & & classes . size ( ) > 0 ) { <nl> - / / Filter default schema <nl> - proxyMediator = new FilterableMediator ( getDefaultMediator ( ) , classes ) ; <nl> - } else if ( proxyMediator instanceof FilterableMediator ) { <nl> - / / else reset filter if needed <nl> - proxyMediator = ( ( FilterableMediator ) proxyMediator ) . getOriginalMediator ( ) ; <nl> - } <nl> - } <nl> - <nl> + / / Get the canonical path for a given file <nl> static String getCanonicalPath ( File realmFile ) { <nl> try { <nl> return realmFile . getCanonicalPath ( ) ; <nl> diff - - git a / realm / src / main / java / io / realm / RealmConfiguration . java b / realm / src / main / java / io / realm / RealmConfiguration . java <nl> index 84892c4 . . 050b363 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmConfiguration . java <nl> + + + b / realm / src / main / java / io / realm / RealmConfiguration . java <nl> @ @ - 19 , 10 + 19 , 18 @ @ package io . realm ; <nl> import android . content . Context ; <nl> <nl> import java . io . File ; <nl> + import java . lang . reflect . Constructor ; <nl> + import java . lang . reflect . InvocationTargetException ; <nl> import java . util . Collections ; <nl> import java . util . HashSet ; <nl> import java . util . Set ; <nl> <nl> + import io . realm . annotations . RealmModule ; <nl> + import io . realm . exceptions . RealmException ; <nl> + import io . realm . internal . RealmProxyMediator ; <nl> + import io . realm . internal . modules . CompositeMediator ; <nl> + import io . realm . internal . modules . FilterableMediator ; <nl> + <nl> / * * <nl> * A RealmConfiguration is used to setup a specific Realm instance . <nl> * <nl> @ @ - 43 , 6 + 51 , 17 @ @ import java . util . Set ; <nl> * / <nl> public class RealmConfiguration { <nl> <nl> + private static final Object DEFAULT _ MODULE ; <nl> + private static final RealmProxyMediator DEFAULT _ MODULE _ MEDIATOR ; <nl> + static { <nl> + DEFAULT _ MODULE = getDefaultModule ( ) ; <nl> + if ( DEFAULT _ MODULE ! = null ) { <nl> + DEFAULT _ MODULE _ MEDIATOR = getModuleMediator ( DEFAULT _ MODULE . getClass ( ) . getCanonicalName ( ) ) ; <nl> + } else { <nl> + DEFAULT _ MODULE _ MEDIATOR = null ; <nl> + } <nl> + } <nl> + <nl> private final File realmFolder ; <nl> private final String realmFileName ; <nl> private final String canonicalPath ; <nl> @ @ - 51 , 7 + 70 , 7 @ @ public class RealmConfiguration { <nl> private final RealmMigration migration ; <nl> private final boolean deleteRealmIfMigrationNeeded ; <nl> private final boolean deleteRealmBeforeOpening ; <nl> - private final Set < Class < ? extends RealmObject > > schema ; <nl> + private final RealmProxyMediator schemaMediator ; <nl> <nl> private RealmConfiguration ( Builder builder ) { <nl> this . realmFolder = builder . folder ; <nl> @ @ - 62 , 7 + 81 , 7 @ @ public class RealmConfiguration { <nl> this . deleteRealmIfMigrationNeeded = builder . deleteRealmIfMigrationNeeded ; <nl> this . deleteRealmBeforeOpening = builder . deleteRealmBeforeOpening ; <nl> this . migration = builder . migration ; <nl> - this . schema = builder . schema ; <nl> + this . schemaMediator = createSchemaMediator ( builder ) ; <nl> } <nl> <nl> public File getRealmFolder ( ) { <nl> @ @ - 93 , 54 + 112 , 138 @ @ public class RealmConfiguration { <nl> return deleteRealmBeforeOpening ; <nl> } <nl> <nl> - public Set < Class < ? extends RealmObject > > getSchema ( ) { <nl> - return schema ; <nl> + public RealmProxyMediator getSchemaMediator ( ) { <nl> + return schemaMediator ; <nl> } <nl> <nl> public String getPath ( ) { <nl> return canonicalPath ; <nl> } <nl> <nl> + / / Creates the mediator that defines the current schema <nl> + private RealmProxyMediator createSchemaMediator ( Builder builder ) { <nl> + <nl> + Set < Object > modules = builder . modules ; <nl> + Set < Class < ? extends RealmObject > > debugSchema = builder . debugSchema ; <nl> + <nl> + / / If using debug schema , use special mediator <nl> + if ( debugSchema . size ( ) > 0 ) { <nl> + return new FilterableMediator ( DEFAULT _ MODULE _ MEDIATOR , debugSchema ) ; <nl> + } <nl> + <nl> + / / If only one module , use that mediator directly <nl> + if ( modules . size ( ) = = 1 ) { <nl> + return getModuleMediator ( modules . iterator ( ) . next ( ) . getClass ( ) . getCanonicalName ( ) ) ; <nl> + } <nl> + <nl> + / / Otherwise combine all mediators <nl> + CompositeMediator mediator = new CompositeMediator ( ) ; <nl> + for ( Object module : modules ) { <nl> + mediator . addMediator ( getModuleMediator ( module . getClass ( ) . getCanonicalName ( ) ) ) ; <nl> + } <nl> + return mediator ; <nl> + } <nl> + <nl> + / / Finds the module ( if there is one <nl> + private static Object getDefaultModule ( ) { <nl> + String moduleName = " io . realm . DefaultRealmModule " ; <nl> + Class < ? > clazz ; <nl> + try { <nl> + clazz = Class . forName ( moduleName ) ; <nl> + Constructor < ? > constructor = clazz . getDeclaredConstructors ( ) [ 0 ] ; <nl> + constructor . setAccessible ( true ) ; <nl> + return constructor . newInstance ( ) ; <nl> + } catch ( ClassNotFoundException e ) { <nl> + throw new RealmException ( " Could not find " + moduleName , e ) ; <nl> + } catch ( InvocationTargetException e ) { <nl> + throw new RealmException ( " Could not create an instance of " + moduleName , e ) ; <nl> + } catch ( InstantiationException e ) { <nl> + throw new RealmException ( " Could not create an instance of " + moduleName , e ) ; <nl> + } catch ( IllegalAccessException e ) { <nl> + throw new RealmException ( " Could not create an instance of " + moduleName , e ) ; <nl> + } <nl> + } <nl> + <nl> + / / Finds the mediator associated with a given module <nl> + private static RealmProxyMediator getModuleMediator ( String canonicalModuleClassName ) { <nl> + String mediatorName = canonicalModuleClassName + " Mediator " ; <nl> + Class < ? > clazz ; <nl> + try { <nl> + clazz = Class . forName ( mediatorName ) ; <nl> + Constructor < ? > constructor = clazz . getDeclaredConstructors ( ) [ 0 ] ; <nl> + constructor . setAccessible ( true ) ; <nl> + return ( RealmProxyMediator ) constructor . newInstance ( ) ; <nl> + } catch ( ClassNotFoundException e ) { <nl> + throw new RealmException ( " Could not find " + mediatorName , e ) ; <nl> + } catch ( InvocationTargetException e ) { <nl> + throw new RealmException ( " Could not create an instance of " + mediatorName , e ) ; <nl> + } catch ( InstantiationException e ) { <nl> + throw new RealmException ( " Could not create an instance of " + mediatorName , e ) ; <nl> + } catch ( IllegalAccessException e ) { <nl> + throw new RealmException ( " Could not create an instance of " + mediatorName , e ) ; <nl> + } <nl> + } <nl> + <nl> / * * <nl> * RealmConfiguration . Builder used to construct instances of a RealmConfiguration in a fluent manner . <nl> * / <nl> public static class Builder { <nl> - private File folder = null ; <nl> - private String fileName = " default . realm " ; <nl> - private byte [ ] key = null ; <nl> - private int schemaVersion = 0 ; <nl> - private RealmMigration migration = null ; <nl> - private boolean deleteRealmIfMigrationNeeded = false ; <nl> - private boolean deleteRealmBeforeOpening = false ; <nl> - private Set < Class < ? extends RealmObject > > schema = new HashSet < Class < ? extends RealmObject > > ( ) ; <nl> + private File folder ; <nl> + private String fileName ; <nl> + private byte [ ] key ; <nl> + private int schemaVersion ; <nl> + private RealmMigration migration ; <nl> + private boolean deleteRealmIfMigrationNeeded ; <nl> + private boolean deleteRealmBeforeOpening ; <nl> + private HashSet < Object > modules = new HashSet < Object > ( ) ; <nl> + private HashSet < Class < ? extends RealmObject > > debugSchema = new HashSet < Class < ? extends RealmObject > > ( ) ; <nl> <nl> / * * <nl> * Create an instance of the Builder for the RealmConfiguration . <nl> - * The Realm file in the provided folder . <nl> + * The Realm file will be saved in the provided folder . <nl> + * <nl> + * @ param folder Folder to save Realm file in . Folder must be writable . <nl> + * <nl> + * @ throws { @ link IllegalArgumentException } if folder doesn ' t exists or isn ' t writable . <nl> * / <nl> - public Builder ( File writeableFolder ) { <nl> - if ( writeableFolder = = null | | ! writeableFolder . isDirectory ( ) ) { <nl> - throw new IllegalArgumentException ( ( " An existing folder must be provided . " + <nl> - " Yours was " + ( writeableFolder ! = null ? writeableFolder . getAbsolutePath ( ) : " null " ) ) ) ; <nl> - } <nl> - if ( ! writeableFolder . canWrite ( ) ) { <nl> - throw new IllegalArgumentException ( " Folder is not writeable : " + writeableFolder . getAbsolutePath ( ) ) ; <nl> - } <nl> - <nl> - this . folder = writeableFolder ; <nl> + public Builder ( File folder ) { <nl> + initializeBuilder ( folder ) ; <nl> } <nl> <nl> / * * <nl> * Create an instance of the Builder for the RealmConfiguration . <nl> - * This will use the Apps own internal directory for storing the Realm file . This does not require any <nl> + * <nl> + * This will use the apps own internal directory for storing the Realm file . This does not require any <nl> * additional permissions . The default location is { @ code / data / data / < packagename > / files } , but can <nl> * change depending on vendor implementations of Android . <nl> + * <nl> + * @ param context Android context . <nl> * / <nl> public Builder ( Context context ) { <nl> if ( context = = null ) { <nl> throw new IllegalArgumentException ( " A non - null Context must be provided " ) ; <nl> } <nl> - this . folder = context . getFilesDir ( ) ; <nl> + initializeBuilder ( context . getFilesDir ( ) ) ; <nl> + } <nl> + <nl> + / / Setup builder in its initial state <nl> + private void initializeBuilder ( File folder ) { <nl> + if ( folder = = null | | ! folder . isDirectory ( ) ) { <nl> + throw new IllegalArgumentException ( ( " An existing folder must be provided . " + <nl> + " Yours was " + ( folder ! = null ? folder . getAbsolutePath ( ) : " null " ) ) ) ; <nl> + } <nl> + if ( ! folder . canWrite ( ) ) { <nl> + throw new IllegalArgumentException ( " Folder is not writable : " + folder . getAbsolutePath ( ) ) ; <nl> + } <nl> + <nl> + this . folder = folder ; <nl> + this . fileName = Realm . DEFAULT _ REALM _ NAME ; <nl> + this . key = null ; <nl> + this . schemaVersion = 0 ; <nl> + this . migration = null ; <nl> + this . deleteRealmIfMigrationNeeded = false ; <nl> + this . deleteRealmBeforeOpening = false ; <nl> + this . modules . add ( DEFAULT _ MODULE ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 227 , 13 + 330 , 51 @ @ public class RealmConfiguration { <nl> } <nl> <nl> / * * <nl> - * Package private method . Only available for testing until Migrations introduces RealmModules . This restricts <nl> - * the Realm schema to only consist of the provided classes . <nl> + * Add a { @ link RealmModule } s to the existing modules . RealmClasses in the new module is added to the schema <nl> + * for this Realm . <nl> + * <nl> + * @ param module { @ link RealmModule } to add to this Realms schema . <nl> + * <nl> + * @ throws { @ link IllegalArgumentException } if module is { @ code null } or doesn ' t have the { @ link RealmModule } <nl> + * annotation . <nl> + * / <nl> + public void addModule ( Object module ) { <nl> + checkModule ( module ) ; <nl> + modules . add ( module ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Replace the existing modules with one or more { @ link RealmModule } s . Using this method will replace the <nl> + * current schema for this Realm with the schema defined by the provided modules . <nl> + * <nl> + * @ param baseModule <nl> + * @ param additionalModules <nl> + * <nl> + * @ throws { @ link IllegalArgumentException } if any of the modules are { @ code null } or doesn ' t have the <nl> + * { @ link RealmModule } annotation . <nl> + * / <nl> + public void setModule ( Object baseModule , Object . . . additionalModules ) { <nl> + modules . clear ( ) ; <nl> + addModule ( baseModule ) ; <nl> + if ( additionalModules ! = null ) { <nl> + for ( int i = 0 ; i < additionalModules . length ; i + + ) { <nl> + Object module = additionalModules [ i ] ; <nl> + checkModule ( module ) ; <nl> + addModule ( module ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * DEBUG method . This restricts the Realm schema to only consist of the provided classes without having to <nl> + * create a module . These classes must be available in the default module . Calling this will remove any <nl> + * previously configured modules . <nl> * / <nl> Builder schema ( Class < ? extends RealmObject > . . . schemaClass ) { <nl> - schema = new HashSet < Class < ? extends RealmObject > > ( ) ; <nl> + modules . clear ( ) ; <nl> + modules . add ( DEFAULT _ MODULE _ MEDIATOR ) ; <nl> if ( schemaClass ! = null ) { <nl> - Collections . addAll ( schema , schemaClass ) ; <nl> + Collections . addAll ( debugSchema , schemaClass ) ; <nl> } <nl> return this ; <nl> } <nl> @ @ - 246 , 5 + 387 , 12 @ @ public class RealmConfiguration { <nl> public RealmConfiguration build ( ) { <nl> return new RealmConfiguration ( this ) ; <nl> } <nl> + <nl> + private void checkModule ( Object module ) { <nl> + if ( ! module . getClass ( ) . isAnnotationPresent ( RealmModule . class ) ) { <nl> + throw new IllegalArgumentException ( module . getClass ( ) . getCanonicalName ( ) + " is not a RealmModule . " + <nl> + " Add @ RealmModule to the class definition . " ) ; <nl> + } <nl> + } <nl> } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / internal / modules / FilterableMediator . java b / realm / src / main / java / io / realm / internal / modules / FilterableMediator . java <nl> index 34fe93a . . b87d014 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / modules / FilterableMediator . java <nl> + + + b / realm / src / main / java / io / realm / internal / modules / FilterableMediator . java <nl> @ @ - 52 , 10 + 52 , 12 @ @ public class FilterableMediator extends RealmProxyMediator { <nl> * / <nl> public FilterableMediator ( RealmProxyMediator originalMediator , Collection < Class < ? extends RealmObject > > allowedClasses ) { <nl> this . originalMediator = originalMediator ; <nl> - List < Class < ? extends RealmObject > > originalClasses = originalMediator . getModelClasses ( ) ; <nl> - for ( Class < ? extends RealmObject > clazz : allowedClasses ) { <nl> - if ( originalClasses . contains ( clazz ) ) { <nl> - this . allowedClasses . add ( clazz ) ; <nl> + if ( originalMediator ! = null ) { <nl> + List < Class < ? extends RealmObject > > originalClasses = originalMediator . getModelClasses ( ) ; <nl> + for ( Class < ? extends RealmObject > clazz : allowedClasses ) { <nl> + if ( originalClasses . contains ( clazz ) ) { <nl> + this . allowedClasses . add ( clazz ) ; <nl> + } <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java b / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java 
 index 32a52cc . . 3c72498 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java 
 @ @ - 33 , 49 + 33 , 6 @ @ import io . realm . internal . android . AndroidRealmNotifier ; 
 @ Keep 
 public final class SharedRealm implements Closeable , NativeObject { 
 
 - / / Const value for RealmFileException conversion 
 - public static final byte FILE _ EXCEPTION _ KIND _ ACCESS _ ERROR = 0 ; 
 - public static final byte FILE _ EXCEPTION _ KIND _ BAD _ HISTORY = 1 ; 
 - public static final byte FILE _ EXCEPTION _ KIND _ PERMISSION _ DENIED = 2 ; 
 - public static final byte FILE _ EXCEPTION _ KIND _ EXISTS = 3 ; 
 - public static final byte FILE _ EXCEPTION _ KIND _ NOT _ FOUND = 4 ; 
 - public static final byte FILE _ EXCEPTION _ KIND _ INCOMPATIBLE _ LOCK _ FILE = 5 ; 
 - public static final byte FILE _ EXCEPTION _ KIND _ FORMAT _ UPGRADE _ REQUIRED = 6 ; 
 - public static final byte FILE _ EXCEPTION _ INCOMPATIBLE _ SYNC _ FILE = 7 ; 
 - private static final long nativeFinalizerPtr = nativeGetFinalizerPtr ( ) ; 
 - 
 - public static void initialize ( File tempDirectory ) { 
 - if ( SharedRealm . temporaryDirectory ! = null ) { 
 - / / already initialized 
 - return ; 
 - } 
 - 
 - String temporaryDirectoryPath = tempDirectory . getAbsolutePath ( ) ; 
 - if ( ! tempDirectory . isDirectory ( ) & & ! tempDirectory . mkdirs ( ) & & ! tempDirectory . isDirectory ( ) ) { 
 - throw new IOException ( " failed to create temporary directory : " + temporaryDirectoryPath ) ; 
 - } 
 - 
 - if ( ! temporaryDirectoryPath . endsWith ( " / " ) ) { 
 - temporaryDirectoryPath + = " / " ; 
 - } 
 - nativeInit ( temporaryDirectoryPath ) ; 
 - SharedRealm . temporaryDirectory = tempDirectory ; 
 - } 
 - 
 - public static File getTemporaryDirectory ( ) { 
 - return temporaryDirectory ; 
 - } 
 - 
 - private static volatile File temporaryDirectory ; 
 - 
 - private final List < WeakReference < PendingRow > > pendingRows = new CopyOnWriteArrayList < > ( ) ; 
 - public final List < WeakReference < Collection > > collections = new CopyOnWriteArrayList < > ( ) ; 
 - public final List < WeakReference < Collection . Iterator > > iterators = new ArrayList < > ( ) ; 
 - 
 - / / JNI will only hold a weak global ref to this . 
 - public final RealmNotifier realmNotifier ; 
 - public final Capabilities capabilities ; 
 - 
 public static class VersionID implements Comparable < VersionID > { 
 public final long version ; 
 public final long index ; 
 @ @ - 140 , 9 + 97 , 9 @ @ public final class SharedRealm implements Closeable , NativeObject { 
 * Callback function . 
 * 
 * @ param sharedRealm the same { @ link SharedRealm } instance which has been created from the same 
 - * { @ link OsRealmConfig } instance . 
 - * @ param oldVersion the schema version of the existing Realm file . 
 - * @ param newVersion the expected schema version after migration . 
 + * { @ link OsRealmConfig } instance . 
 + * @ param oldVersion the schema version of the existing Realm file . 
 + * @ param newVersion the expected schema version after migration . 
 * / 
 void onMigrationNeeded ( SharedRealm sharedRealm , long oldVersion , long newVersion ) ; 
 } 
 @ @ - 161 , 9 + 118 , 10 @ @ public final class SharedRealm implements Closeable , NativeObject { 
 / * * 
 * Callback function to be called from JNI by Object Store when the schema is changed . 
 * / 
 - @ SuppressWarnings ( " unused " ) 
 @ Keep 
 public interface SchemaChangedCallback { 
 + / / Called from JNI 
 + @ SuppressWarnings ( " unused " ) 
 void onSchemaChanged ( ) ; 
 } 
 
 @ @ - 179 , 13 + 137 , 33 @ @ public final class SharedRealm implements Closeable , NativeObject { 
 } 
 
 public abstract void onSuccess ( Collection results ) ; 
 + 
 public abstract void onError ( RealmException error ) ; 
 } 
 
 - private final OsRealmConfig osRealmConfig ; 
 + / / Const value for RealmFileException conversion 
 + public static final byte FILE _ EXCEPTION _ KIND _ ACCESS _ ERROR = 0 ; 
 + public static final byte FILE _ EXCEPTION _ KIND _ BAD _ HISTORY = 1 ; 
 + public static final byte FILE _ EXCEPTION _ KIND _ PERMISSION _ DENIED = 2 ; 
 + public static final byte FILE _ EXCEPTION _ KIND _ EXISTS = 3 ; 
 + public static final byte FILE _ EXCEPTION _ KIND _ NOT _ FOUND = 4 ; 
 + public static final byte FILE _ EXCEPTION _ KIND _ INCOMPATIBLE _ LOCK _ FILE = 5 ; 
 + public static final byte FILE _ EXCEPTION _ KIND _ FORMAT _ UPGRADE _ REQUIRED = 6 ; 
 + public static final byte FILE _ EXCEPTION _ INCOMPATIBLE _ SYNC _ FILE = 7 ; 
 + 
 + private static final long nativeFinalizerPtr = nativeGetFinalizerPtr ( ) ; 
 private final long nativePtr ; 
 + private final OsRealmConfig osRealmConfig ; 
 final NativeContext context ; 
 private final OsSchemaInfo schemaInfo ; 
 + private static volatile File temporaryDirectory ; 
 + / / JNI will only hold a weak global ref to this . 
 + public final RealmNotifier realmNotifier ; 
 + public final Capabilities capabilities ; 
 + 
 + private final List < WeakReference < PendingRow > > pendingRows = new CopyOnWriteArrayList < > ( ) ; 
 + / / Package protected for testing 
 + final List < WeakReference < Collection . Iterator > > iterators = new ArrayList < > ( ) ; 
 
 private SharedRealm ( OsRealmConfig osRealmConfig ) { 
 Capabilities capabilities = new AndroidCapabilities ( ) ; 
 @ @ - 241 , 6 + 219 , 28 @ @ public final class SharedRealm implements Closeable , NativeObject { 
 return new SharedRealm ( osRealmConfig ) ; 
 } 
 
 + public static void initialize ( File tempDirectory ) { 
 + if ( SharedRealm . temporaryDirectory ! = null ) { 
 + / / already initialized 
 + return ; 
 + } 
 + 
 + String temporaryDirectoryPath = tempDirectory . getAbsolutePath ( ) ; 
 + if ( ! tempDirectory . isDirectory ( ) & & ! tempDirectory . mkdirs ( ) & & ! tempDirectory . isDirectory ( ) ) { 
 + throw new IOException ( " failed to create temporary directory : " + temporaryDirectoryPath ) ; 
 + } 
 + 
 + if ( ! temporaryDirectoryPath . endsWith ( " / " ) ) { 
 + temporaryDirectoryPath + = " / " ; 
 + } 
 + nativeInit ( temporaryDirectoryPath ) ; 
 + SharedRealm . temporaryDirectory = tempDirectory ; 
 + } 
 + 
 + public static File getTemporaryDirectory ( ) { 
 + return temporaryDirectory ; 
 + } 
 + 
 public void beginTransaction ( ) { 
 detachIterators ( ) ; 
 executePendingRowQueries ( ) ; 
 @ @ - 290 , 12 + 290 , 12 @ @ public final class SharedRealm implements Closeable , NativeObject { 
 * Creates a { @ link Table } and adds a primary key field to it . Native assertion will happen if the table with the 
 * same name exists . 
 * 
 - * @ param tableName the name of table . 
 + * @ param tableName the name of table . 
 * @ param primaryKeyFieldName the name of primary key field . 
 - * @ param isStringType if this is true , the primary key field will be create as a string field . Otherwise it will 
 - * be created as an integer field . 
 - * @ param isNullable if the primary key field is nullable or not . 
 - * @ return a creatd { @ link Table } object . 
 + * @ param isStringType if this is true , the primary key field will be create as a string field . Otherwise it will 
 + * be created as an integer field . 
 + * @ param isNullable if the primary key field is nullable or not . 
 + * @ return a newly created { @ link Table } object . 
 * / 
 public Table createTableWithPrimaryKey ( String tableName , String primaryKeyFieldName , boolean isStringType , 
 boolean isNullable ) { 
 @ @ - 420 , 7 + 420 , 7 @ @ public final class SharedRealm implements Closeable , NativeObject { 
 } 
 
 / / The detaching should happen before transaction begins . 
 - void detachIterators ( ) { 
 + private void detachIterators ( ) { 
 for ( WeakReference < Collection . Iterator > iteratorRef : iterators ) { 
 Collection . Iterator iterator = iteratorRef . get ( ) ; 
 if ( iterator ! = null ) { 
 @ @ - 476 , 7 + 476 , 7 @ @ public final class SharedRealm implements Closeable , NativeObject { 
 / * * 
 * Called from JNI when the expected schema doesn ' t match the existing one . 
 * 
 - * @ param callback the { @ link MigrationCallback } in the { @ link RealmConfiguration } . 
 + * @ param callback the { @ link MigrationCallback } in the { @ link RealmConfiguration } . 
 * @ param oldVersion the schema version of the existing Realm file . 
 * / 
 @ SuppressWarnings ( " unused " ) 
 @ @ - 498 , 13 + 498 , 14 @ @ public final class SharedRealm implements Closeable , NativeObject { 
 
 / * * 
 * Called from JNI when the partial sync callback is invoked from the ObjectStore . 
 - * @ param error if the partial sync query failed to register . 
 + * 
 + * @ param error if the partial sync query failed to register . 
 * @ param nativeResultsPtr pointer to the { @ code Results } of the partial sync query . 
 - * @ param callback the callback registered from the user to notify the success / error of the partial sync query . 
 + * @ param callback the callback registered from the user to notify the success / error of the partial sync query . 
 * / 
 @ SuppressWarnings ( " unused " ) 
 private void runPartialSyncRegistrationCallback ( @ Nullable String error , long nativeResultsPtr , 
 - PartialSyncCallback callback ) { 
 + PartialSyncCallback callback ) { 
 if ( error ! = null ) { 
 callback . onError ( new RealmException ( error ) ) ; 
 } else {

NEAREST DIFF:
diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index a8f3297 . . 88b8c85 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 145 , 7 + 145 , 6 @ @ public final class Realm implements Closeable { 
 
 private static RealmConfiguration defaultConfiguration ; 
 
 - private static final String APT _ NOT _ EXECUTED _ MESSAGE = " Annotation processor may not have been executed . " ; 
 private static final String INCORRECT _ THREAD _ MESSAGE = " Realm access from incorrect thread . Realm objects can only be accessed on the thread they where created . " ; 
 private static final String CLOSED _ REALM _ MESSAGE = " This Realm instance has already been closed , making it unusable . " ; 
 private static final String DIFFERENT _ KEY _ MESSAGE = " Wrong key used to decrypt Realm . " ; 
 @ @ - 161 , 7 + 160 , 7 @ @ public final class Realm implements Closeable { 
 private final ImplicitTransaction transaction ; 
 
 private final List < WeakReference < RealmChangeListener > > changeListeners = new ArrayList < WeakReference < RealmChangeListener > > ( ) ; 
 - private static RealmProxyMediator proxyMediator = getDefaultMediator ( ) ; 
 + protected RealmProxyMediator proxyMediator ; 
 
 private static final long UNVERSIONED = - 1 ; 
 
 @ @ - 243 , 24 + 242 , 6 @ @ public final class Realm implements Closeable { 
 handlers . remove ( handler ) ; 
 } 
 
 - private static RealmProxyMediator getDefaultMediator ( ) { 
 - Class < ? > clazz ; 
 - try { 
 - clazz = Class . forName ( " io . realm . DefaultRealmModuleMediator " ) ; 
 - Constructor < ? > constructor = clazz . getDeclaredConstructors ( ) [ 0 ] ; 
 - constructor . setAccessible ( true ) ; 
 - return ( RealmProxyMediator ) constructor . newInstance ( ) ; 
 - } catch ( ClassNotFoundException e ) { 
 - throw new RealmException ( " Could not find io . realm . DefaultRealmModuleMediator " , e ) ; 
 - } catch ( InvocationTargetException e ) { 
 - throw new RealmException ( " Could not create an instance of io . realm . DefaultRealmModuleMediator " , e ) ; 
 - } catch ( InstantiationException e ) { 
 - throw new RealmException ( " Could not create an instance of io . realm . DefaultRealmModuleMediator " , e ) ; 
 - } catch ( IllegalAccessException e ) { 
 - throw new RealmException ( " Could not create an instance of io . realm . DefaultRealmModuleMediator " , e ) ; 
 - } 
 - } 
 - 
 private class RealmCallback implements Handler . Callback { 
 @ Override 
 public boolean handleMessage ( Message message ) { 
 @ @ - 547 , 7 + 528 , 6 @ @ public final class Realm implements Closeable { 
 } 
 
 private static synchronized Realm createAndValidate ( RealmConfiguration config , boolean validateSchema , boolean autoRefresh ) { 
 - setSchema ( config . getSchema ( ) ) ; 
 byte [ ] key = config . getEncryptionKey ( ) ; 
 String canonicalPath = config . getPath ( ) ; 
 Map < String , Integer > localRefCount = referenceCount . get ( ) ; 
 @ @ - 576 , 6 + 556 , 7 @ @ public final class Realm implements Closeable { 
 / / Create new Realm and cache it . All exception code paths must close the Realm otherwise we risk serving 
 / / faulty cache data . 
 realm = new Realm ( canonicalPath , key , autoRefresh ) ; 
 + realm . proxyMediator = config . getSchemaMediator ( ) ; 
 realms . put ( canonicalPath , realm ) ; 
 realmsCache . set ( realms ) ; 
 localRefCount . put ( canonicalPath , references + 1 ) ; 
 @ @ - 625 , 13 + 606 , 13 @ @ public final class Realm implements Closeable { 
 commitNeeded = true ; 
 realm . setVersion ( config . getSchemaVersion ( ) ) ; 
 } 
 - for ( Class < ? extends RealmObject > modelClass : proxyMediator . getModelClasses ( ) ) { 
 + for ( Class < ? extends RealmObject > modelClass : realm . proxyMediator . getModelClasses ( ) ) { 
 / / Create and validate table 
 if ( version = = UNVERSIONED ) { 
 - proxyMediator . createTable ( modelClass , realm . transaction ) ; 
 + realm . proxyMediator . createTable ( modelClass , realm . transaction ) ; 
 } 
 - proxyMediator . validateTable ( modelClass , realm . transaction ) ; 
 - realm . columnIndices . addClass ( modelClass , proxyMediator . getColumnIndices ( modelClass ) ) ; 
 + realm . proxyMediator . validateTable ( modelClass , realm . transaction ) ; 
 + realm . columnIndices . addClass ( modelClass , realm . proxyMediator . getColumnIndices ( modelClass ) ) ; 
 } 
 } finally { 
 if ( commitNeeded ) { 
 @ @ - 1717 , 25 + 1698 , 7 @ @ public final class Realm implements Closeable { 
 return canonicalPath ; 
 } 
 
 - / * * 
 - * Override the standard behavior of all classes extended RealmObject being part of the schema . 
 - * Use this method to define the schema as only the classes given here . 
 - * 
 - * This class must be called before calling { @ link # getInstance ( android . content . Context ) } 
 - * ø 
 - * If { @ code null } is given as parameter , the Schema is reset to use all known classes . 
 - * 
 - * / 
 - private static void setSchema ( Collection < Class < ? extends RealmObject > > classes ) { 
 - if ( classes ! = null & & classes . size ( ) > 0 ) { 
 - / / Filter default schema 
 - proxyMediator = new FilterableMediator ( getDefaultMediator ( ) , classes ) ; 
 - } else if ( proxyMediator instanceof FilterableMediator ) { 
 - / / else reset filter if needed 
 - proxyMediator = ( ( FilterableMediator ) proxyMediator ) . getOriginalMediator ( ) ; 
 - } 
 - } 
 - 
 + / / Get the canonical path for a given file 
 static String getCanonicalPath ( File realmFile ) { 
 try { 
 return realmFile . getCanonicalPath ( ) ; 
 diff - - git a / realm / src / main / java / io / realm / RealmConfiguration . java b / realm / src / main / java / io / realm / RealmConfiguration . java 
 index 84892c4 . . 050b363 100644 
 - - - a / realm / src / main / java / io / realm / RealmConfiguration . java 
 + + + b / realm / src / main / java / io / realm / RealmConfiguration . java 
 @ @ - 19 , 10 + 19 , 18 @ @ package io . realm ; 
 import android . content . Context ; 
 
 import java . io . File ; 
 + import java . lang . reflect . Constructor ; 
 + import java . lang . reflect . InvocationTargetException ; 
 import java . util . Collections ; 
 import java . util . HashSet ; 
 import java . util . Set ; 
 
 + import io . realm . annotations . RealmModule ; 
 + import io . realm . exceptions . RealmException ; 
 + import io . realm . internal . RealmProxyMediator ; 
 + import io . realm . internal . modules . CompositeMediator ; 
 + import io . realm . internal . modules . FilterableMediator ; 
 + 
 / * * 
 * A RealmConfiguration is used to setup a specific Realm instance . 
 * 
 @ @ - 43 , 6 + 51 , 17 @ @ import java . util . Set ; 
 * / 
 public class RealmConfiguration { 
 
 + private static final Object DEFAULT _ MODULE ; 
 + private static final RealmProxyMediator DEFAULT _ MODULE _ MEDIATOR ; 
 + static { 
 + DEFAULT _ MODULE = getDefaultModule ( ) ; 
 + if ( DEFAULT _ MODULE ! = null ) { 
 + DEFAULT _ MODULE _ MEDIATOR = getModuleMediator ( DEFAULT _ MODULE . getClass ( ) . getCanonicalName ( ) ) ; 
 + } else { 
 + DEFAULT _ MODULE _ MEDIATOR = null ; 
 + } 
 + } 
 + 
 private final File realmFolder ; 
 private final String realmFileName ; 
 private final String canonicalPath ; 
 @ @ - 51 , 7 + 70 , 7 @ @ public class RealmConfiguration { 
 private final RealmMigration migration ; 
 private final boolean deleteRealmIfMigrationNeeded ; 
 private final boolean deleteRealmBeforeOpening ; 
 - private final Set < Class < ? extends RealmObject > > schema ; 
 + private final RealmProxyMediator schemaMediator ; 
 
 private RealmConfiguration ( Builder builder ) { 
 this . realmFolder = builder . folder ; 
 @ @ - 62 , 7 + 81 , 7 @ @ public class RealmConfiguration { 
 this . deleteRealmIfMigrationNeeded = builder . deleteRealmIfMigrationNeeded ; 
 this . deleteRealmBeforeOpening = builder . deleteRealmBeforeOpening ; 
 this . migration = builder . migration ; 
 - this . schema = builder . schema ; 
 + this . schemaMediator = createSchemaMediator ( builder ) ; 
 } 
 
 public File getRealmFolder ( ) { 
 @ @ - 93 , 54 + 112 , 138 @ @ public class RealmConfiguration { 
 return deleteRealmBeforeOpening ; 
 } 
 
 - public Set < Class < ? extends RealmObject > > getSchema ( ) { 
 - return schema ; 
 + public RealmProxyMediator getSchemaMediator ( ) { 
 + return schemaMediator ; 
 } 
 
 public String getPath ( ) { 
 return canonicalPath ; 
 } 
 
 + / / Creates the mediator that defines the current schema 
 + private RealmProxyMediator createSchemaMediator ( Builder builder ) { 
 + 
 + Set < Object > modules = builder . modules ; 
 + Set < Class < ? extends RealmObject > > debugSchema = builder . debugSchema ; 
 + 
 + / / If using debug schema , use special mediator 
 + if ( debugSchema . size ( ) > 0 ) { 
 + return new FilterableMediator ( DEFAULT _ MODULE _ MEDIATOR , debugSchema ) ; 
 + } 
 + 
 + / / If only one module , use that mediator directly 
 + if ( modules . size ( ) = = 1 ) { 
 + return getModuleMediator ( modules . iterator ( ) . next ( ) . getClass ( ) . getCanonicalName ( ) ) ; 
 + } 
 + 
 + / / Otherwise combine all mediators 
 + CompositeMediator mediator = new CompositeMediator ( ) ; 
 + for ( Object module : modules ) { 
 + mediator . addMediator ( getModuleMediator ( module . getClass ( ) . getCanonicalName ( ) ) ) ; 
 + } 
 + return mediator ; 
 + } 
 + 
 + / / Finds the module ( if there is one 
 + private static Object getDefaultModule ( ) { 
 + String moduleName = " io . realm . DefaultRealmModule " ; 
 + Class < ? > clazz ; 
 + try { 
 + clazz = Class . forName ( moduleName ) ; 
 + Constructor < ? > constructor = clazz . getDeclaredConstructors ( ) [ 0 ] ; 
 + constructor . setAccessible ( true ) ; 
 + return constructor . newInstance ( ) ; 
 + } catch ( ClassNotFoundException e ) { 
 + throw new RealmException ( " Could not find " + moduleName , e ) ; 
 + } catch ( InvocationTargetException e ) { 
 + throw new RealmException ( " Could not create an instance of " + moduleName , e ) ; 
 + } catch ( InstantiationException e ) { 
 + throw new RealmException ( " Could not create an instance of " + moduleName , e ) ; 
 + } catch ( IllegalAccessException e ) { 
 + throw new RealmException ( " Could not create an instance of " + moduleName , e ) ; 
 + } 
 + } 
 + 
 + / / Finds the mediator associated with a given module 
 + private static RealmProxyMediator getModuleMediator ( String canonicalModuleClassName ) { 
 + String mediatorName = canonicalModuleClassName + " Mediator " ; 
 + Class < ? > clazz ; 
 + try { 
 + clazz = Class . forName ( mediatorName ) ; 
 + Constructor < ? > constructor = clazz . getDeclaredConstructors ( ) [ 0 ] ; 
 + constructor . setAccessible ( true ) ; 
 + return ( RealmProxyMediator ) constructor . newInstance ( ) ; 
 + } catch ( ClassNotFoundException e ) { 
 + throw new RealmException ( " Could not find " + mediatorName , e ) ; 
 + } catch ( InvocationTargetException e ) { 
 + throw new RealmException ( " Could not create an instance of " + mediatorName , e ) ; 
 + } catch ( InstantiationException e ) { 
 + throw new RealmException ( " Could not create an instance of " + mediatorName , e ) ; 
 + } catch ( IllegalAccessException e ) { 
 + throw new RealmException ( " Could not create an instance of " + mediatorName , e ) ; 
 + } 
 + } 
 + 
 / * * 
 * RealmConfiguration . Builder used to construct instances of a RealmConfiguration in a fluent manner . 
 * / 
 public static class Builder { 
 - private File folder = null ; 
 - private String fileName = " default . realm " ; 
 - private byte [ ] key = null ; 
 - private int schemaVersion = 0 ; 
 - private RealmMigration migration = null ; 
 - private boolean deleteRealmIfMigrationNeeded = false ; 
 - private boolean deleteRealmBeforeOpening = false ; 
 - private Set < Class < ? extends RealmObject > > schema = new HashSet < Class < ? extends RealmObject > > ( ) ; 
 + private File folder ; 
 + private String fileName ; 
 + private byte [ ] key ; 
 + private int schemaVersion ; 
 + private RealmMigration migration ; 
 + private boolean deleteRealmIfMigrationNeeded ; 
 + private boolean deleteRealmBeforeOpening ; 
 + private HashSet < Object > modules = new HashSet < Object > ( ) ; 
 + private HashSet < Class < ? extends RealmObject > > debugSchema = new HashSet < Class < ? extends RealmObject > > ( ) ; 
 
 / * * 
 * Create an instance of the Builder for the RealmConfiguration . 
 - * The Realm file in the provided folder . 
 + * The Realm file will be saved in the provided folder . 
 + * 
 + * @ param folder Folder to save Realm file in . Folder must be writable . 
 + * 
 + * @ throws { @ link IllegalArgumentException } if folder doesn ' t exists or isn ' t writable . 
 * / 
 - public Builder ( File writeableFolder ) { 
 - if ( writeableFolder = = null | | ! writeableFolder . isDirectory ( ) ) { 
 - throw new IllegalArgumentException ( ( " An existing folder must be provided . " + 
 - " Yours was " + ( writeableFolder ! = null ? writeableFolder . getAbsolutePath ( ) : " null " ) ) ) ; 
 - } 
 - if ( ! writeableFolder . canWrite ( ) ) { 
 - throw new IllegalArgumentException ( " Folder is not writeable : " + writeableFolder . getAbsolutePath ( ) ) ; 
 - } 
 - 
 - this . folder = writeableFolder ; 
 + public Builder ( File folder ) { 
 + initializeBuilder ( folder ) ; 
 } 
 
 / * * 
 * Create an instance of the Builder for the RealmConfiguration . 
 - * This will use the Apps own internal directory for storing the Realm file . This does not require any 
 + * 
 + * This will use the apps own internal directory for storing the Realm file . This does not require any 
 * additional permissions . The default location is { @ code / data / data / < packagename > / files } , but can 
 * change depending on vendor implementations of Android . 
 + * 
 + * @ param context Android context . 
 * / 
 public Builder ( Context context ) { 
 if ( context = = null ) { 
 throw new IllegalArgumentException ( " A non - null Context must be provided " ) ; 
 } 
 - this . folder = context . getFilesDir ( ) ; 
 + initializeBuilder ( context . getFilesDir ( ) ) ; 
 + } 
 + 
 + / / Setup builder in its initial state 
 + private void initializeBuilder ( File folder ) { 
 + if ( folder = = null | | ! folder . isDirectory ( ) ) { 
 + throw new IllegalArgumentException ( ( " An existing folder must be provided . " + 
 + " Yours was " + ( folder ! = null ? folder . getAbsolutePath ( ) : " null " ) ) ) ; 
 + } 
 + if ( ! folder . canWrite ( ) ) { 
 + throw new IllegalArgumentException ( " Folder is not writable : " + folder . getAbsolutePath ( ) ) ; 
 + } 
 + 
 + this . folder = folder ; 
 + this . fileName = Realm . DEFAULT _ REALM _ NAME ; 
 + this . key = null ; 
 + this . schemaVersion = 0 ; 
 + this . migration = null ; 
 + this . deleteRealmIfMigrationNeeded = false ; 
 + this . deleteRealmBeforeOpening = false ; 
 + this . modules . add ( DEFAULT _ MODULE ) ; 
 } 
 
 / * * 
 @ @ - 227 , 13 + 330 , 51 @ @ public class RealmConfiguration { 
 } 
 
 / * * 
 - * Package private method . Only available for testing until Migrations introduces RealmModules . This restricts 
 - * the Realm schema to only consist of the provided classes . 
 + * Add a { @ link RealmModule } s to the existing modules . RealmClasses in the new module is added to the schema 
 + * for this Realm . 
 + * 
 + * @ param module { @ link RealmModule } to add to this Realms schema . 
 + * 
 + * @ throws { @ link IllegalArgumentException } if module is { @ code null } or doesn ' t have the { @ link RealmModule } 
 + * annotation . 
 + * / 
 + public void addModule ( Object module ) { 
 + checkModule ( module ) ; 
 + modules . add ( module ) ; 
 + } 
 + 
 + / * * 
 + * Replace the existing modules with one or more { @ link RealmModule } s . Using this method will replace the 
 + * current schema for this Realm with the schema defined by the provided modules . 
 + * 
 + * @ param baseModule 
 + * @ param additionalModules 
 + * 
 + * @ throws { @ link IllegalArgumentException } if any of the modules are { @ code null } or doesn ' t have the 
 + * { @ link RealmModule } annotation . 
 + * / 
 + public void setModule ( Object baseModule , Object . . . additionalModules ) { 
 + modules . clear ( ) ; 
 + addModule ( baseModule ) ; 
 + if ( additionalModules ! = null ) { 
 + for ( int i = 0 ; i < additionalModules . length ; i + + ) { 
 + Object module = additionalModules [ i ] ; 
 + checkModule ( module ) ; 
 + addModule ( module ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * DEBUG method . This restricts the Realm schema to only consist of the provided classes without having to 
 + * create a module . These classes must be available in the default module . Calling this will remove any 
 + * previously configured modules . 
 * / 
 Builder schema ( Class < ? extends RealmObject > . . . schemaClass ) { 
 - schema = new HashSet < Class < ? extends RealmObject > > ( ) ; 
 + modules . clear ( ) ; 
 + modules . add ( DEFAULT _ MODULE _ MEDIATOR ) ; 
 if ( schemaClass ! = null ) { 
 - Collections . addAll ( schema , schemaClass ) ; 
 + Collections . addAll ( debugSchema , schemaClass ) ; 
 } 
 return this ; 
 } 
 @ @ - 246 , 5 + 387 , 12 @ @ public class RealmConfiguration { 
 public RealmConfiguration build ( ) { 
 return new RealmConfiguration ( this ) ; 
 } 
 + 
 + private void checkModule ( Object module ) { 
 + if ( ! module . getClass ( ) . isAnnotationPresent ( RealmModule . class ) ) { 
 + throw new IllegalArgumentException ( module . getClass ( ) . getCanonicalName ( ) + " is not a RealmModule . " + 
 + " Add @ RealmModule to the class definition . " ) ; 
 + } 
 + } 
 } 
 } 
 diff - - git a / realm / src / main / java / io / realm / internal / modules / FilterableMediator . java b / realm / src / main / java / io / realm / internal / modules / FilterableMediator . java 
 index 34fe93a . . b87d014 100644 
 - - - a / realm / src / main / java / io / realm / internal / modules / FilterableMediator . java 
 + + + b / realm / src / main / java / io / realm / internal / modules / FilterableMediator . java 
 @ @ - 52 , 10 + 52 , 12 @ @ public class FilterableMediator extends RealmProxyMediator { 
 * / 
 public FilterableMediator ( RealmProxyMediator originalMediator , Collection < Class < ? extends RealmObject > > allowedClasses ) { 
 this . originalMediator = originalMediator ; 
 - List < Class < ? extends RealmObject > > originalClasses = originalMediator . getModelClasses ( ) ; 
 - for ( Class < ? extends RealmObject > clazz : allowedClasses ) { 
 - if ( originalClasses . contains ( clazz ) ) { 
 - this . allowedClasses . add ( clazz ) ; 
 + if ( originalMediator ! = null ) { 
 + List < Class < ? extends RealmObject > > originalClasses = originalMediator . getModelClasses ( ) ; 
 + for ( Class < ? extends RealmObject > clazz : allowedClasses ) { 
 + if ( originalClasses . contains ( clazz ) ) { 
 + this . allowedClasses . add ( clazz ) ; 
 + } 
 } 
 } 
 }
