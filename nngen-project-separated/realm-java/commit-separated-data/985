BLEU SCORE: 0.021566939693939927

TEST MSG: Added missing thread confinement checks
GENERATED MSG: Adding thread check on RealmObject . Refactoring unit tests . Updating changelog .

TEST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index b8bd31a . . 43f9cc4 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 11 , 6 + 11 , 7 @ @ <nl> * Following methods in managed RealmList now throw IllegalStateException instead of ArrayIndexOutOfBoundsException when RealmList . isValid ( ) returns false : set ( int , RealmObject ) , move ( int , int ) , remove ( int ) , get ( int ) <nl> * Following methods in managed RealmList now throw IllegalStateException instead of returning 0 / null when RealmList . isValid ( ) returns false : clear ( ) , removeAll ( Collection ) , remove ( RealmObject ) , first ( ) , last ( ) , size ( ) , where ( ) <nl> * RealmPrimaryKeyConstraintException is now thrown instead of RealmException if two objects with same primary key are inserted . <nl> + * IllegalStateException is now thrown when calling Realm ' s clear ( ) , RealmResults ' s remove ( ) , removeLast ( ) , clear ( ) or RealmObject ' s removeFromRealm ( ) from an incorrect thread . <nl> * Fixed a bug affecting RealmConfiguration . equals ( ) . <nl> * Fixed a bug in RealmQuery . isNotNull ( ) which produced wrong results for binary data . <nl> * Fixed a bug in RealmQuery . isNull ( ) and RealmQuery . isNotNull ( ) which validated the query prematurely . <nl> diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> index c265ce6 . . 2b8d72b 100644 <nl> - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> @ @ - 232 , 6 + 232 , 9 @ @ public class RealmProxyClassGenerator { <nl> / / Getter <nl> writer . emitAnnotation ( " Override " ) ; <nl> writer . beginMethod ( fieldTypeCanonicalName , metadata . getGetter ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) ) ; <nl> + writer . emitStatement ( <nl> + " realm . checkIfValid ( ) " <nl> + ) ; <nl> writer . beginControlFlow ( " if ( row . isNullLink ( % s ) ) " , staticFieldIndexVarName ( field ) ) ; <nl> writer . emitStatement ( " return null " ) ; <nl> writer . endControlFlow ( ) ; <nl> @ @ - 243 , 6 + 246 , 9 @ @ public class RealmProxyClassGenerator { <nl> / / Setter <nl> writer . emitAnnotation ( " Override " ) ; <nl> writer . beginMethod ( " void " , metadata . getSetter ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) , fieldTypeCanonicalName , " value " ) ; <nl> + writer . emitStatement ( <nl> + " realm . checkIfValid ( ) " <nl> + ) ; <nl> writer . beginControlFlow ( " if ( value = = null ) " ) ; <nl> writer . emitStatement ( " row . nullifyLink ( % s ) " , staticFieldIndexVarName ( field ) ) ; <nl> writer . emitStatement ( " return " ) ; <nl> @ @ - 258 , 7 + 264 , 7 @ @ public class RealmProxyClassGenerator { <nl> / / Getter <nl> writer . emitAnnotation ( " Override " ) ; <nl> writer . beginMethod ( fieldTypeCanonicalName , metadata . getGetter ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) ) ; <nl> - <nl> + writer . emitStatement ( " realm . checkIfValid ( ) " ) ; <nl> writer . emitSingleLineComment ( " use the cached value if available " ) ; <nl> writer . beginControlFlow ( " if ( " + fieldName + " RealmList ! = null ) " ) ; <nl> writer . emitStatement ( " return " + fieldName + " RealmList " ) ; <nl> @ @ - 281 , 6 + 287 , 9 @ @ public class RealmProxyClassGenerator { <nl> / / Setter <nl> writer . emitAnnotation ( " Override " ) ; <nl> writer . beginMethod ( " void " , metadata . getSetter ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) , fieldTypeCanonicalName , " value " ) ; <nl> + writer . emitStatement ( <nl> + " realm . checkIfValid ( ) " <nl> + ) ; <nl> writer . emitStatement ( " LinkView links = row . getLinkList ( % s ) " , staticFieldIndexVarName ( field ) ) ; <nl> writer . emitStatement ( " links . clear ( ) " ) ; <nl> writer . beginControlFlow ( " if ( value = = null ) " ) ; <nl> diff - - git a / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java b / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java <nl> index f22faa1 . . c611907 100644 <nl> - - - a / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java <nl> + + + b / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java <nl> @ @ - 152 , 6 + 152 , 7 @ @ public class AllTypesRealmProxy extends AllTypes <nl> <nl> @ Override <nl> public AllTypes getColumnObject ( ) { <nl> + realm . checkIfValid ( ) ; <nl> if ( row . isNullLink ( INDEX _ COLUMNOBJECT ) ) { <nl> return null ; <nl> } <nl> @ @ - 160 , 6 + 161 , 7 @ @ public class AllTypesRealmProxy extends AllTypes <nl> <nl> @ Override <nl> public void setColumnObject ( AllTypes value ) { <nl> + realm . checkIfValid ( ) ; <nl> if ( value = = null ) { <nl> row . nullifyLink ( INDEX _ COLUMNOBJECT ) ; <nl> return ; <nl> @ @ - 169 , 6 + 171 , 7 @ @ public class AllTypesRealmProxy extends AllTypes <nl> <nl> @ Override <nl> public RealmList < AllTypes > getColumnRealmList ( ) { <nl> + realm . checkIfValid ( ) ; <nl> / / use the cached value if available <nl> if ( columnRealmListRealmList ! = null ) { <nl> return columnRealmListRealmList ; <nl> @ @ - 176 , 7 + 179 , 7 @ @ public class AllTypesRealmProxy extends AllTypes <nl> LinkView linkView = row . getLinkList ( INDEX _ COLUMNREALMLIST ) ; <nl> if ( linkView = = null ) { <nl> / / return empty non managed RealmList if the LinkView is null <nl> - / / useful for non - initialized RealmObject ( async query return empty Row while the query is performing ) <nl> + / / useful for non - initialized RealmObject ( async query returns empty Row while the query is still running ) <nl> return EMPTY _ REALM _ LIST _ COLUMNREALMLIST ; <nl> } else { <nl> columnRealmListRealmList = new RealmList < AllTypes > ( AllTypes . class , linkView , realm ) ; <nl> @ @ - 187 , 6 + 190 , 7 @ @ public class AllTypesRealmProxy extends AllTypes <nl> <nl> @ Override <nl> public void setColumnRealmList ( RealmList < AllTypes > value ) { <nl> + realm . checkIfValid ( ) ; <nl> LinkView links = row . getLinkList ( INDEX _ COLUMNREALMLIST ) ; <nl> links . clear ( ) ; <nl> if ( value = = null ) { <nl> diff - - git a / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java b / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java <nl> index 41c6091 . . 95179b1 100644 <nl> - - - a / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java <nl> + + + b / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java <nl> @ @ - 414 , 6 + 414 , 7 @ @ public class NullTypesRealmProxy extends NullTypes <nl> <nl> @ Override <nl> public NullTypes getFieldObjectNull ( ) { <nl> + realm . checkIfValid ( ) ; <nl> if ( row . isNullLink ( INDEX _ FIELDOBJECTNULL ) ) { <nl> return null ; <nl> } <nl> @ @ - 422 , 6 + 423 , 7 @ @ public class NullTypesRealmProxy extends NullTypes <nl> <nl> @ Override <nl> public void setFieldObjectNull ( NullTypes value ) { <nl> + realm . checkIfValid ( ) ; <nl> if ( value = = null ) { <nl> row . nullifyLink ( INDEX _ FIELDOBJECTNULL ) ; <nl> return ; <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmListTest . java b / realm / src / androidTest / java / io / realm / RealmListTest . java <nl> index b787d8d . . 7f7ee50 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmListTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmListTest . java <nl> @ @ - 19 , 8 + 19 , 14 @ @ package io . realm ; <nl> import android . test . AndroidTestCase ; <nl> <nl> import java . util . Collections ; <nl> + import java . util . concurrent . Callable ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . Executors ; <nl> + import java . util . concurrent . Future ; <nl> <nl> import io . realm . entities . AllTypes ; <nl> + import io . realm . entities . AllTypesPrimaryKey ; <nl> import io . realm . entities . CyclicType ; <nl> import io . realm . entities . CyclicTypePrimaryKey ; <nl> import io . realm . entities . Dog ; <nl> @ @ - 79 , 8 + 85 , 8 @ @ public class RealmListTest extends AndroidTestCase { <nl> case 3 : list . move ( 0 , 0 ) ; break ; <nl> } <nl> fail ( ) ; <nl> - } catch ( IndexOutOfBoundsException expected ) { <nl> - } catch ( RealmException expected ) { <nl> + } catch ( IndexOutOfBoundsException ignored ) { <nl> + } catch ( RealmException ignored ) { <nl> } <nl> } <nl> realm . cancelTransaction ( ) ; <nl> @ @ - 719 , 12 + 725 , 76 @ @ public class RealmListTest extends AndroidTestCase { <nl> list . add ( dog ) ; <nl> testRealm . commitTransaction ( ) ; <nl> <nl> - try { list . add ( dog ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } <nl> - try { list . add ( 0 , dog ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } <nl> - try { list . clear ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } <nl> - try { list . move ( 0 , 1 ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } <nl> - try { list . remove ( 0 ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } <nl> - try { list . set ( 0 , dog ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } <nl> + try { list . add ( dog ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } <nl> + try { list . add ( 0 , dog ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } <nl> + try { list . clear ( ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } <nl> + try { list . move ( 0 , 1 ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } <nl> + try { list . remove ( 0 ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } <nl> + try { list . set ( 0 , dog ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } <nl> + } <nl> + <nl> + private enum Method { <nl> + METHOD _ ADD , <nl> + METHOD _ ADD _ AT , <nl> + METHOD _ CLEAR , <nl> + METHOD _ MOVE , <nl> + METHOD _ REMOVE , <nl> + METHOD _ SET <nl> + } <nl> + <nl> + / / Calling methods from the wrong thread should fail <nl> + private boolean methodWrongThread ( final Method method ) throws InterruptedException , ExecutionException { <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . clear ( AllTypes . class ) ; <nl> + testRealm . clear ( Dog . class ) ; <nl> + final RealmList < Dog > list = testRealm . createObject ( AllTypes . class ) . getColumnRealmList ( ) ; <nl> + Dog dog = testRealm . createObject ( Dog . class ) ; <nl> + list . add ( dog ) ; <nl> + testRealm . commitTransaction ( ) ; <nl> + <nl> + testRealm . beginTransaction ( ) ; / / Make sure that a valid transaction has begun on the correct thread <nl> + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> + @ Override <nl> + public Boolean call ( ) throws Exception { <nl> + try { <nl> + switch ( method ) { <nl> + case METHOD _ ADD : <nl> + list . add ( new Dog ( ) ) ; <nl> + break ; <nl> + case METHOD _ ADD _ AT : <nl> + list . add ( 1 , new Dog ( ) ) ; <nl> + break ; <nl> + case METHOD _ CLEAR : <nl> + list . clear ( ) ; <nl> + break ; <nl> + case METHOD _ MOVE : <nl> + list . add ( new Dog ( ) ) ; <nl> + list . move ( 0 , 1 ) ; <nl> + break ; <nl> + case METHOD _ REMOVE : <nl> + list . remove ( 0 ) ; <nl> + break ; <nl> + case METHOD _ SET : <nl> + list . set ( 0 , new Dog ( ) ) ; <nl> + break ; <nl> + } <nl> + return false ; <nl> + } catch ( IllegalStateException ignored ) { <nl> + return true ; <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + boolean result = future . get ( ) ; <nl> + testRealm . cancelTransaction ( ) ; <nl> + return result ; <nl> + } <nl> + <nl> + public void testMethodsThrowOnWrongThread ( ) throws ExecutionException , InterruptedException { <nl> + for ( Method method : Method . values ( ) ) { <nl> + assertTrue ( method . toString ( ) , methodWrongThread ( method ) ) ; <nl> + } <nl> } <nl> <nl> public void testSettingListClearsOldItems ( ) { <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmObjectTest . java b / realm / src / androidTest / java / io / realm / RealmObjectTest . java <nl> index 55267fe . . b05f46e 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmObjectTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmObjectTest . java <nl> @ @ - 214 , 7 + 214 , 14 @ @ public class RealmObjectTest extends AndroidTestCase { <nl> removeOneByOne ( REMOVE _ LAST ) ; <nl> } <nl> <nl> - public boolean methodWrongThread ( final boolean callGetter ) throws ExecutionException , InterruptedException { <nl> + private enum Method { <nl> + METHOD _ GETTER , <nl> + METHOD _ SETTER , <nl> + METHOD _ REMOVE _ FROM _ REALM <nl> + } <nl> + <nl> + public boolean methodWrongThread ( final Method method ) throws ExecutionException , InterruptedException { <nl> + <nl> testRealm = Realm . getInstance ( getContext ( ) ) ; <nl> testRealm . beginTransaction ( ) ; <nl> testRealm . createObject ( AllTypes . class ) ; <nl> @ @ - 225 , 10 + 232 , 16 @ @ public class RealmObjectTest extends AndroidTestCase { <nl> @ Override <nl> public Boolean call ( ) throws Exception { <nl> try { <nl> - if ( callGetter ) { <nl> - allTypes . getColumnFloat ( ) ; <nl> - } else { <nl> - allTypes . setColumnFloat ( 1 . 0f ) ; <nl> + switch ( method ) { <nl> + case METHOD _ GETTER : <nl> + allTypes . getColumnFloat ( ) ; <nl> + break ; <nl> + case METHOD _ SETTER : <nl> + allTypes . setColumnFloat ( 1 . 0f ) ; <nl> + break ; <nl> + case METHOD _ REMOVE _ FROM _ REALM : <nl> + allTypes . removeFromRealm ( ) ; <nl> + break ; <nl> } <nl> return false ; <nl> } catch ( IllegalStateException ignored ) { <nl> @ @ - 242 , 9 + 255 , 10 @ @ public class RealmObjectTest extends AndroidTestCase { <nl> return result ; <nl> } <nl> <nl> - public void testGetSetWrongThread ( ) throws ExecutionException , InterruptedException { <nl> - assertTrue ( methodWrongThread ( true ) ) ; <nl> - assertTrue ( methodWrongThread ( false ) ) ; <nl> + public void testMethodsThrowOnWrongThread ( ) throws ExecutionException , InterruptedException { <nl> + for ( Method method : Method . values ( ) ) { <nl> + assertTrue ( methodWrongThread ( method ) ) ; <nl> + } <nl> } <nl> <nl> public void testEqualsSameRealmObject ( ) { <nl> @ @ - 385 , 21 + 399 , 6 @ @ public class RealmObjectTest extends AndroidTestCase { <nl> return cal . getTime ( ) ; <nl> } <nl> <nl> - private void addDate ( int year , int month , int dayOfMonth ) { <nl> - Date date = newDate ( year , month , dayOfMonth ) ; <nl> - <nl> - testRealm . beginTransaction ( ) ; <nl> - testRealm . clear ( AllTypes . class ) ; <nl> - AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; <nl> - allTypes . setColumnDate ( date ) ; <nl> - testRealm . commitTransaction ( ) ; <nl> - <nl> - AllTypes object = testRealm . allObjects ( AllTypes . class ) . first ( ) ; <nl> - <nl> - / / Realm does not support millisec precision <nl> - assertEquals ( 1000 * ( date . getTime ( ) / 1000 ) , 1000 * ( object . getColumnDate ( ) . getTime ( ) / 1000 ) ) ; <nl> - } <nl> - <nl> public void testWriteMustThrowOutOfTransaction ( ) { <nl> testRealm . beginTransaction ( ) ; <nl> Dog dog = testRealm . createObject ( Dog . class ) ; <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> index e613b71 . . d45acb9 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> @ @ - 138 , 11 + 138 , 15 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> METHOD _ SUM , <nl> METHOD _ AVG , <nl> METHOD _ SORT , <nl> - METHOD _ WHERE <nl> + METHOD _ WHERE , <nl> + METHOD _ REMOVE , <nl> + METHOD _ REMOVE _ LAST , <nl> + METHOD _ CLEAR <nl> } <nl> <nl> public boolean methodWrongThread ( final Method method ) throws ExecutionException , InterruptedException { <nl> final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> + testRealm . beginTransaction ( ) ; <nl> ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> @ Override <nl> @ @ - 166 , 6 + 170 , 16 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> break ; <nl> case METHOD _ WHERE : <nl> allTypeses . where ( ) ; <nl> + break ; <nl> + case METHOD _ REMOVE : <nl> + allTypeses . remove ( 0 ) ; <nl> + break ; <nl> + case METHOD _ REMOVE _ LAST : <nl> + allTypeses . removeLast ( ) ; <nl> + break ; <nl> + case METHOD _ CLEAR : <nl> + allTypeses . clear ( ) ; <nl> + break ; <nl> } <nl> return false ; <nl> } catch ( IllegalStateException ignored ) { <nl> @ @ - 173 , 7 + 187 , 9 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> } <nl> } <nl> } ) ; <nl> - return future . get ( ) ; <nl> + Boolean result = future . get ( ) ; <nl> + testRealm . cancelTransaction ( ) ; <nl> + return result ; <nl> } <nl> <nl> / / test io . realm . ResultList Api <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index 20833e4 . . 620e52d 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 44 , 6 + 44 , 7 @ @ import java . util . concurrent . TimeoutException ; <nl> import java . util . concurrent . atomic . AtomicBoolean ; <nl> <nl> import io . realm . dynamic . DynamicRealmObject ; <nl> + import io . realm . entities . AllJavaTypes ; <nl> import io . realm . entities . AllTypes ; <nl> import io . realm . entities . AllTypesPrimaryKey ; <nl> import io . realm . entities . AnnotationIndexTypes ; <nl> @ @ - 602 , 18 + 603 , 26 @ @ public class RealmTest extends AndroidTestCase { <nl> testRealm . commitTransaction ( ) ; <nl> } <nl> <nl> - private enum TransactionMethod { <nl> + private enum Method { <nl> METHOD _ BEGIN , <nl> METHOD _ COMMIT , <nl> - METHOD _ CANCEL <nl> - } <nl> - <nl> - / / Starting a transaction on the wrong thread will fail <nl> - private boolean transactionMethodWrongThread ( final TransactionMethod method ) throws InterruptedException , <nl> - ExecutionException { <nl> - if ( method ! = TransactionMethod . METHOD _ BEGIN ) { <nl> + METHOD _ CANCEL , <nl> + METHOD _ CLEAR , <nl> + METHOD _ DISTINCT , <nl> + METHOD _ CREATE _ OBJECT , <nl> + METHOD _ COPY _ TO _ REALM , <nl> + METHOD _ COPY _ TO _ REALM _ OR _ UPDATE , <nl> + METHOD _ CREATE _ ALL _ FROM _ JSON , <nl> + METHOD _ CREATE _ OR _ UPDATE _ ALL _ FROM _ JSON , <nl> + METHOD _ CREATE _ FROM _ JSON , <nl> + METHOD _ CREATE _ OR _ UPDATE _ FROM _ JSON <nl> + } <nl> + <nl> + / / Calling methods on a wrong thread will fail . <nl> + private boolean methodWrongThread ( final Method method ) throws InterruptedException , ExecutionException { <nl> + if ( method ! = Method . METHOD _ BEGIN ) { <nl> testRealm . beginTransaction ( ) ; <nl> - testRealm . createObject ( Dog . class ) ; / / FIXME : Empty transactions cannot be cancelled <nl> + testRealm . createObject ( Dog . class ) ; <nl> } <nl> ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> @ @ - 630 , 24 + 639 , 54 @ @ public class RealmTest extends AndroidTestCase { <nl> case METHOD _ CANCEL : <nl> testRealm . cancelTransaction ( ) ; <nl> break ; <nl> + case METHOD _ CLEAR : <nl> + testRealm . clear ( AllTypes . class ) ; <nl> + break ; <nl> + case METHOD _ DISTINCT : <nl> + testRealm . distinct ( AllTypesPrimaryKey . class , " columnLong " ) ; <nl> + break ; <nl> + case METHOD _ CREATE _ OBJECT : <nl> + testRealm . createObject ( AllTypes . class ) ; <nl> + break ; <nl> + case METHOD _ COPY _ TO _ REALM : <nl> + testRealm . copyToRealm ( new AllTypes ( ) ) ; <nl> + break ; <nl> + case METHOD _ COPY _ TO _ REALM _ OR _ UPDATE : <nl> + testRealm . copyToRealm ( new AllTypesPrimaryKey ( ) ) ; <nl> + break ; <nl> + case METHOD _ CREATE _ ALL _ FROM _ JSON : <nl> + testRealm . createAllFromJson ( AllTypes . class , " [ { } ] " ) ; <nl> + break ; <nl> + case METHOD _ CREATE _ OR _ UPDATE _ ALL _ FROM _ JSON : <nl> + testRealm . createOrUpdateAllFromJson ( AllTypesPrimaryKey . class , " [ { \ " columnLong \ " : 1 } ] " ) ; <nl> + break ; <nl> + case METHOD _ CREATE _ FROM _ JSON : <nl> + testRealm . createObjectFromJson ( AllTypes . class , " { } " ) ; <nl> + break ; <nl> + case METHOD _ CREATE _ OR _ UPDATE _ FROM _ JSON : <nl> + testRealm . createOrUpdateObjectFromJson ( AllTypesPrimaryKey . class , " { \ " columnLong \ " : 1 } " ) ; <nl> + break ; <nl> } <nl> return false ; <nl> } catch ( IllegalStateException ignored ) { <nl> return true ; <nl> + } catch ( RealmException jsonFailure ) { <nl> + / / TODO : Eew . Reconsider how our JSON methods reports failure . See https : / / github . com / realm / realm - java / issues / 1594 <nl> + return ( jsonFailure . getMessage ( ) . equals ( " Could not map Json " ) ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> boolean result = future . get ( ) ; <nl> - if ( result & & method ! = TransactionMethod . METHOD _ BEGIN ) { <nl> + if ( method ! = Method . METHOD _ BEGIN ) { <nl> testRealm . cancelTransaction ( ) ; <nl> } <nl> return result ; <nl> } <nl> <nl> - public void testTransactionWrongThread ( ) throws ExecutionException , InterruptedException { <nl> - for ( TransactionMethod method : TransactionMethod . values ( ) ) { <nl> - assertTrue ( method . toString ( ) , transactionMethodWrongThread ( method ) ) ; <nl> + public void testMethodsThrowOnWrongThread ( ) throws ExecutionException , InterruptedException { <nl> + for ( Method method : Method . values ( ) ) { <nl> + assertTrue ( method . toString ( ) , methodWrongThread ( method ) ) ; <nl> } <nl> } <nl> <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index e45e2bd . . c76fb16 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 689 , 6 + 689 , 7 @ @ public final class Realm extends BaseRealm { <nl> * @ throws RealmException An object could not be created <nl> * / <nl> public < E extends RealmObject > E createObject ( Class < E > clazz ) { <nl> + checkIfValid ( ) ; <nl> Table table = getTable ( clazz ) ; <nl> long rowIndex = table . addEmptyRow ( ) ; <nl> return get ( clazz , rowIndex ) ; <nl> @ @ - 952 , 7 + 953 , 7 @ @ public final class Realm extends BaseRealm { <nl> if ( fieldName = = null ) { <nl> throw new IllegalArgumentException ( " fieldName must be provided . " ) ; <nl> } <nl> - <nl> + checkIfValid ( ) ; <nl> Table table = this . getTable ( clazz ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> if ( columnIndex = = - 1 ) { <nl> @ @ - 1077 , 14 + 1078 , 17 @ @ public final class Realm extends BaseRealm { <nl> * Remove all objects of the specified class . <nl> * <nl> * @ param clazz The class which objects should be removed <nl> + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . <nl> * @ throws java . lang . RuntimeException Any other error <nl> * / <nl> public void clear ( Class < ? extends RealmObject > clazz ) { <nl> + checkIfValid ( ) ; <nl> getTable ( clazz ) . clear ( ) ; <nl> } <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> private < E extends RealmObject > E copyOrUpdate ( E object , boolean update ) { <nl> + checkIfValid ( ) ; <nl> return configuration . getSchemaMediator ( ) . copyOrUpdate ( this , object , update , new HashMap < RealmObject , RealmObjectProxy > ( ) ) ; <nl> } <nl> <nl> diff - - git a / realm / src / main / java / io / realm / RealmList . java b / realm / src / main / java / io / realm / RealmList . java <nl> index eedc97d . . 777bf03 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmList . java <nl> + + + b / realm / src / main / java / io / realm / RealmList . java <nl> @ @ - 140 , 7 + 140 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> public void add ( int location , E object ) { <nl> checkValidObject ( object ) ; <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> object = copyToRealmIfNeeded ( object ) ; <nl> view . insert ( location , object . row . getIndex ( ) ) ; <nl> } else { <nl> @ @ - 167 , 7 + 167 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> public boolean add ( E object ) { <nl> checkValidObject ( object ) ; <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> object = copyToRealmIfNeeded ( object ) ; <nl> view . add ( object . row . getIndex ( ) ) ; <nl> } else { <nl> @ @ - 198 , 7 + 198 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> public E set ( int location , E object ) { <nl> checkValidObject ( object ) ; <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> object = copyToRealmIfNeeded ( object ) ; <nl> view . set ( location , object . row . getIndex ( ) ) ; <nl> } else { <nl> @ @ - 233 , 7 + 233 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> * / <nl> public void move ( int oldPos , int newPos ) { <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> view . move ( oldPos , newPos ) ; <nl> } else { <nl> checkIndex ( oldPos ) ; <nl> @ @ - 257 , 7 + 257 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> @ Override <nl> public void clear ( ) { <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> view . clear ( ) ; <nl> } else { <nl> nonManagedList . clear ( ) ; <nl> @ @ - 275 , 7 + 275 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> @ Override <nl> public E remove ( int location ) { <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> E removedItem = get ( location ) ; <nl> view . remove ( location ) ; <nl> return removedItem ; <nl> @ @ - 295 , 7 + 295 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> @ Override <nl> public E get ( int location ) { <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> return realm . get ( clazz , view . getTargetRowIndex ( location ) ) ; <nl> } else { <nl> return nonManagedList . get ( location ) ; <nl> @ @ - 310 , 7 + 310 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> * / <nl> public E first ( ) { <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> return view . isEmpty ( ) ? null : get ( 0 ) ; <nl> } else if ( nonManagedList ! = null & & nonManagedList . size ( ) > 0 ) { <nl> return nonManagedList . get ( 0 ) ; <nl> @ @ - 326 , 7 + 326 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> * / <nl> public E last ( ) { <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> return view . isEmpty ( ) ? null : get ( ( int ) view . size ( ) - 1 ) ; <nl> } else if ( nonManagedList ! = null & & nonManagedList . size ( ) > 0 ) { <nl> return nonManagedList . get ( nonManagedList . size ( ) - 1 ) ; <nl> @ @ - 343 , 7 + 343 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> @ Override <nl> public int size ( ) { <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> long size = view . size ( ) ; <nl> return size < Integer . MAX _ VALUE ? ( int ) size : Integer . MAX _ VALUE ; <nl> } else { <nl> @ @ - 360 , 7 + 360 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> * / <nl> public RealmQuery < E > where ( ) { <nl> if ( managedMode ) { <nl> - checkIfViewAttached ( ) ; <nl> + checkValidView ( ) ; <nl> return new RealmQuery < E > ( this . realm , view , clazz ) ; <nl> } else { <nl> throw new RealmException ( ONLY _ IN _ MANAGED _ MODE _ MESSAGE ) ; <nl> @ @ - 380 , 7 + 380 , 8 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { <nl> } <nl> } <nl> <nl> - private void checkIfViewAttached ( ) { <nl> + private void checkValidView ( ) { <nl> + realm . checkIfValid ( ) ; <nl> if ( view = = null | | ! view . isAttached ( ) ) { <nl> throw new IllegalStateException ( " Realm instance has been closed or parent object has been removed . " ) ; <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java <nl> index 05532ba . . 3e81961 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmObject . java <nl> + + + b / realm / src / main / java / io / realm / RealmObject . java <nl> @ @ - 94 , 6 + 94 , 8 @ @ public abstract class RealmObject { <nl> * < p > <nl> * After this method is called the object will be invalid and any operation ( read or write ) <nl> * performed on it will fail with an IllegalStateException <nl> + * <nl> + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . <nl> * / <nl> public void removeFromRealm ( ) { <nl> if ( row = = null ) { <nl> @ @ - 102 , 6 + 104 , 8 @ @ public abstract class RealmObject { <nl> if ( realm = = null ) { <nl> throw new IllegalStateException ( " Object malformed : missing Realm . Make sure to instantiate RealmObjects with Realm . createObject ( ) " ) ; <nl> } <nl> + realm . checkIfValid ( ) ; <nl> + <nl> row . getTable ( ) . moveLastOver ( row . getIndex ( ) ) ; <nl> row = InvalidRow . INSTANCE ; <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index a3d0225 . . 3a98f0d 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 68 , 7 + 68 , 6 @ @ public class RealmQuery < E extends RealmObject > { <nl> private final Map < String , Long > columns ; <nl> private final Class < E > clazz ; <nl> <nl> - private static final String LINK _ NOT _ SUPPORTED _ METHOD = " ' % s ' is not supported for link queries " ; <nl> private static final String TYPE _ MISMATCH = " Field ' % s ' : type mismatch - % s expected . " ; <nl> <nl> public static final boolean CASE _ SENSITIVE = true ; <nl> diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java <nl> index 9177899 . . 0312296 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / src / main / java / io / realm / RealmResults . java <nl> @ @ - 511 , 9 + 511 , 11 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * <nl> * @ param index The array index identifying the object to be removed . <nl> * @ return Always return { @ code null } . <nl> + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . <nl> * / <nl> @ Override <nl> public E remove ( int index ) { <nl> + realm . checkIfValid ( ) ; <nl> TableOrView table = getTable ( ) ; <nl> table . remove ( index ) ; <nl> return null ; / / Returning the object doesn ' t make sense , since it could no longer access any data . <nl> @ @ - 525 , 8 + 527 , 11 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * <nl> * Using this method while iterating the list can result in a undefined behavior . Use <nl> * { @ link io . realm . RealmResults . RealmResultsListIterator # removeLast ( ) } instead . <nl> + * <nl> + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . <nl> * / <nl> public void removeLast ( ) { <nl> + realm . checkIfValid ( ) ; <nl> TableOrView table = getTable ( ) ; <nl> table . removeLast ( ) ; <nl> } <nl> @ @ - 534 , 8 + 539 , 11 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> / * * <nl> * Removes all objects from the list . This also deletes the objects from the <nl> * underlying Realm . <nl> + * <nl> + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . <nl> * / <nl> public void clear ( ) { <nl> + realm . checkIfValid ( ) ; <nl> TableOrView table = getTable ( ) ; <nl> table . clear ( ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index 568299a . . 74fd137 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 1 , 5 + 1 , 5 @ @ <nl> 0 . 74 . 0 ( ? ? ) <nl> - * For many thread fragtile methods , check if correct thread , and throw exception if not <nl> + * An exception will now be thrown if you try to move Realm , RealmResults or RealmObject between threads . <nl> <nl> 0 . 73 . 1 ( 05 Nov 2014 ) <nl> * Fixed a bug that would send infinite notifications in some instances <nl> diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> index bb6f25f . . 73f135c 100644 <nl> - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> @ @ - 220 , 6 + 220 , 7 @ @ public class RealmProxyClassGenerator { <nl> " io . realm . internal . LinkView " , <nl> " io . realm . RealmList " , <nl> " io . realm . RealmObject " , <nl> + " io . realm . Realm " , <nl> " java . util . * " , <nl> packageName + " . * " ) <nl> . emitEmptyLine ( ) ; <nl> @ @ - 253 , 6 + 254 , 9 @ @ public class RealmProxyClassGenerator { <nl> String getterPrefix = fieldTypeCanonicalName . equals ( " boolean " ) ? " is " : " get " ; <nl> writer . beginMethod ( fieldTypeCanonicalName , getterPrefix + capitaliseFirstChar ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) ) ; <nl> writer . emitStatement ( <nl> + " realm . assertThread ( ) " <nl> + ) ; <nl> + writer . emitStatement ( <nl> " return ( % s ) row . get % s ( Realm . columnIndices . get ( \ " % s \ " ) . get ( \ " % s \ " ) ) " , <nl> fieldTypeCanonicalName , realmType , className , fieldName ) ; <nl> writer . endMethod ( ) ; <nl> @ @ - 262 , 6 + 266 , 9 @ @ public class RealmProxyClassGenerator { <nl> writer . emitAnnotation ( " Override " ) ; <nl> writer . beginMethod ( " void " , " set " + capitaliseFirstChar ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) , fieldTypeCanonicalName , " value " ) ; <nl> writer . emitStatement ( <nl> + " realm . assertThread ( ) " <nl> + ) ; <nl> + writer . emitStatement ( <nl> " row . set % s ( Realm . columnIndices . get ( \ " % s \ " ) . get ( \ " % s \ " ) , ( % s ) value ) " , <nl> realmType , className , fieldName , castingType ) ; <nl> writer . endMethod ( ) ; <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmObjectTest . java b / realm / src / androidTest / java / io / realm / RealmObjectTest . java <nl> index bd3279e . . c251bd8 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmObjectTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmObjectTest . java <nl> @ @ - 18 , 6 + 18 , 12 @ @ package io . realm ; <nl> <nl> import android . test . AndroidTestCase ; <nl> <nl> + import java . util . concurrent . Callable ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . Executors ; <nl> + import java . util . concurrent . Future ; <nl> + <nl> import io . realm . entities . AllTypes ; <nl> import io . realm . entities . Dog ; <nl> import io . realm . internal . Row ; <nl> @ @ - 96 , 4 + 102 , 37 @ @ public class RealmObjectTest extends AndroidTestCase { <nl> fail ( ) ; <nl> } catch ( IllegalStateException ignored ) { } <nl> } <nl> + <nl> + public boolean methodWrongThread ( final boolean callGetter ) throws ExecutionException , InterruptedException { <nl> + Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> + realm . beginTransaction ( ) ; <nl> + realm . createObject ( AllTypes . class ) ; <nl> + realm . commitTransaction ( ) ; <nl> + final AllTypes allTypes = realm . where ( AllTypes . class ) . findFirst ( ) ; <nl> + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> + @ Override <nl> + public Boolean call ( ) throws Exception { <nl> + try { <nl> + if ( callGetter ) <nl> + allTypes . getColumnFloat ( ) ; <nl> + else <nl> + allTypes . setColumnFloat ( 1 . 0f ) ; <nl> + return false ; <nl> + } catch ( IllegalStateException ignored ) { <nl> + return true ; <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + return future . get ( ) ; <nl> + } <nl> + <nl> + public void testGetWrongThread ( ) throws ExecutionException , InterruptedException { <nl> + assertTrue ( methodWrongThread ( true ) ) ; <nl> + } <nl> + <nl> + public void testSetWrong ( ) throws ExecutionException , InterruptedException { <nl> + assertTrue ( methodWrongThread ( false ) ) ; <nl> + } <nl> } <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> index 076c5ae . . c257446 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> @ @ - 67 , 6 + 67 , 48 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> testRealm . commitTransaction ( ) ; <nl> } <nl> <nl> + private static final int METHOD _ MIN = 1 ; <nl> + private static final int METHOD _ MAX = 2 ; <nl> + private static final int METHOD _ SUM = 3 ; <nl> + private static final int METHOD _ AVG = 4 ; <nl> + private static final int METHOD _ SORT = 5 ; <nl> + private static final int METHOD _ WHERE = 6 ; <nl> + public boolean methodWrongThread ( final int method ) throws ExecutionException , InterruptedException { <nl> + final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> + @ Override <nl> + public Boolean call ( ) throws Exception { <nl> + try { <nl> + switch ( method ) { <nl> + case METHOD _ MIN : <nl> + allTypeses . min ( FIELD _ FLOAT ) ; <nl> + break ; <nl> + case METHOD _ MAX : <nl> + allTypeses . max ( FIELD _ FLOAT ) ; <nl> + break ; <nl> + case METHOD _ SUM : <nl> + allTypeses . sum ( FIELD _ FLOAT ) ; <nl> + break ; <nl> + case METHOD _ AVG : <nl> + allTypeses . average ( FIELD _ FLOAT ) ; <nl> + break ; <nl> + case METHOD _ SORT : <nl> + allTypeses . sort ( FIELD _ FLOAT ) ; <nl> + break ; <nl> + case METHOD _ WHERE : <nl> + allTypeses . where ( ) ; <nl> + } <nl> + return false ; <nl> + } catch ( IllegalStateException ignored ) { <nl> + return true ; <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + return future . get ( ) ; <nl> + } <nl> + <nl> <nl> / / test io . realm . ResultList Api <nl> <nl> @ @ - 137 , 22 + 179 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> } <nl> <nl> public void testMinWrongThread ( ) throws ExecutionException , InterruptedException { <nl> - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> - @ Override <nl> - public Boolean call ( ) throws Exception { <nl> - try { <nl> - allTypeses . min ( FIELD _ FLOAT ) ; <nl> - return false ; <nl> - } catch ( IllegalStateException ignored ) { <nl> - return true ; <nl> - } <nl> - } <nl> - } ) ; <nl> - <nl> - Boolean result = future . get ( ) ; <nl> - assertTrue ( result ) ; <nl> + assertTrue ( methodWrongThread ( METHOD _ MIN ) ) ; <nl> } <nl> <nl> public void testMaxValueIsMaxValue ( ) { <nl> @ @ - 163 , 22 + 190 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> } <nl> <nl> public void testMaxWrongThread ( ) throws ExecutionException , InterruptedException { <nl> - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> - @ Override <nl> - public Boolean call ( ) throws Exception { <nl> - try { <nl> - allTypeses . max ( FIELD _ FLOAT ) ; <nl> - return false ; <nl> - } catch ( IllegalStateException ignored ) { <nl> - return true ; <nl> - } <nl> - } <nl> - } ) ; <nl> - <nl> - Boolean result = future . get ( ) ; <nl> - assertTrue ( result ) ; <nl> + assertTrue ( methodWrongThread ( METHOD _ MAX ) ) ; <nl> } <nl> <nl> public void testSumGivesCorrectValue ( ) { <nl> @ @ - 194 , 22 + 206 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> } <nl> <nl> public void testSumWrongThread ( ) throws ExecutionException , InterruptedException { <nl> - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> - @ Override <nl> - public Boolean call ( ) throws Exception { <nl> - try { <nl> - allTypeses . sum ( FIELD _ FLOAT ) ; <nl> - return false ; <nl> - } catch ( IllegalStateException ignored ) { <nl> - return true ; <nl> - } <nl> - } <nl> - } ) ; <nl> - <nl> - Boolean result = future . get ( ) ; <nl> - assertTrue ( result ) ; <nl> + assertTrue ( methodWrongThread ( METHOD _ SUM ) ) ; <nl> } <nl> <nl> public void testAvgGivesCorrectValue ( ) { <nl> @ @ - 241 , 22 + 238 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> } <nl> <nl> public void testAverageWrongThread ( ) throws ExecutionException , InterruptedException { <nl> - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> - @ Override <nl> - public Boolean call ( ) throws Exception { <nl> - try { <nl> - allTypeses . average ( FIELD _ FLOAT ) ; <nl> - return false ; <nl> - } catch ( IllegalStateException ignored ) { <nl> - return true ; <nl> - } <nl> - } <nl> - } ) ; <nl> - <nl> - Boolean result = future . get ( ) ; <nl> - assertTrue ( result ) ; <nl> + assertTrue ( methodWrongThread ( METHOD _ AVG ) ) ; <nl> } <nl> <nl> / / void clear ( Class < ? > classSpec ) <nl> @ @ - 411 , 22 + 393 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> } <nl> <nl> public void testSortWrongThread ( ) throws ExecutionException , InterruptedException { <nl> - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> - @ Override <nl> - public Boolean call ( ) throws Exception { <nl> - try { <nl> - allTypeses . sort ( FIELD _ FLOAT ) ; <nl> - return false ; <nl> - } catch ( IllegalStateException ignored ) { <nl> - return true ; <nl> - } <nl> - } <nl> - } ) ; <nl> - <nl> - Boolean result = future . get ( ) ; <nl> - assertTrue ( result ) ; <nl> + assertTrue ( methodWrongThread ( METHOD _ SORT ) ) ; <nl> } <nl> <nl> public void testCount ( ) { <nl> @ @ - 458 , 21 + 425 , 6 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> } <nl> <nl> public void testWhereWrongThread ( ) throws ExecutionException , InterruptedException { <nl> - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> - @ Override <nl> - public Boolean call ( ) throws Exception { <nl> - try { <nl> - allTypeses . where ( ) ; <nl> - return false ; <nl> - } catch ( IllegalStateException ignored ) { <nl> - return true ; <nl> - } <nl> - } <nl> - } ) ; <nl> - <nl> - Boolean result = future . get ( ) ; <nl> - assertTrue ( result ) ; <nl> + assertTrue ( methodWrongThread ( METHOD _ WHERE ) ) ; <nl> } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index d3a0c3f . . 29b3780 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 83 , 8 + 83 , 7 @ @ public class Realm { <nl> private static final int REALM _ CHANGED = 14930352 ; / / Just a nice big Fibonacci number . For no reason : ) <nl> private static final Map < Handler , Integer > handlers = new ConcurrentHashMap < Handler , Integer > ( ) ; <nl> private static final String APT _ NOT _ EXECUTED _ MESSAGE = " Annotation processor may not have been executed . " ; <nl> - private static final String INCORRECT _ THREAD _ MESSAGE = " Realm accessed from incorrect thread . " ; <nl> - <nl> + private static final String INCORRECT _ THREAD _ MESSAGE = " Realm access from incorrect thread . Realm objects can only be accessed on the thread they where created . " ; <nl> <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> private static SharedGroup . Durability defaultDurability = SharedGroup . Durability . FULL ; <nl> @ @ - 106 , 7 + 105 , 7 @ @ public class Realm { <nl> / / Package protected to be reachable by proxy classes <nl> static final Map < String , Map < String , Long > > columnIndices = new HashMap < String , Map < String , Long > > ( ) ; <nl> <nl> - protected void checkThread ( ) { <nl> + protected void assertThread ( ) { <nl> if ( realmsCache . get ( ) . get ( new Integer ( this . id ) ) = = null ) { <nl> throw new IllegalStateException ( INCORRECT _ THREAD _ MESSAGE ) ; <nl> } <nl> @ @ - 652 , 7 + 651 , 7 @ @ public class Realm { <nl> * @ see io . realm . RealmChangeListener <nl> * / <nl> public void addChangeListener ( RealmChangeListener listener ) { <nl> - checkThread ( ) ; <nl> + assertThread ( ) ; <nl> changeListeners . add ( listener ) ; <nl> } <nl> <nl> @ @ - 663 , 7 + 662 , 7 @ @ public class Realm { <nl> * @ see io . realm . RealmChangeListener <nl> * / <nl> public void removeChangeListener ( RealmChangeListener listener ) { <nl> - checkThread ( ) ; <nl> + assertThread ( ) ; <nl> changeListeners . remove ( listener ) ; <nl> } <nl> <nl> @ @ - 673 , 7 + 672 , 7 @ @ public class Realm { <nl> * @ see io . realm . RealmChangeListener <nl> * / <nl> public void removeAllChangeListeners ( ) { <nl> - checkThread ( ) ; <nl> + assertThread ( ) ; <nl> changeListeners . clear ( ) ; <nl> } <nl> <nl> @ @ - 697 , 7 + 696 , 7 @ @ public class Realm { <nl> * / <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> public void refresh ( ) { <nl> - checkThread ( ) ; <nl> + assertThread ( ) ; <nl> transaction . advanceRead ( ) ; <nl> } <nl> <nl> @ @ - 716 , 7 + 715 , 7 @ @ public class Realm { <nl> * <nl> * / <nl> public void beginTransaction ( ) { <nl> - checkThread ( ) ; <nl> + assertThread ( ) ; <nl> transaction . promoteToWrite ( ) ; <nl> } <nl> <nl> @ @ - 730 , 7 + 729 , 7 @ @ public class Realm { <nl> * @ throws java . lang . IllegalStateException If the write transaction is in an invalid state or incorrect thread . <nl> * / <nl> public void commitTransaction ( ) { <nl> - checkThread ( ) ; <nl> + assertThread ( ) ; <nl> transaction . commitAndContinueAsRead ( ) ; <nl> <nl> for ( Map . Entry < Handler , Integer > handlerIntegerEntry : handlers . entrySet ( ) ) { <nl> @ @ - 760 , 7 + 759 , 7 @ @ public class Realm { <nl> * not in a write transaction or incorrect thread . <nl> * / <nl> public void cancelTransaction ( ) { <nl> - checkThread ( ) ; <nl> + assertThread ( ) ; <nl> transaction . rollbackAndContinueAsRead ( ) ; <nl> } <nl> <nl> diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java <nl> index 335ee7f . . 524a4d2 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmObject . java <nl> + + + b / realm / src / main / java / io / realm / RealmObject . java <nl> @ @ - 44 , 6 + 44 , 7 @ @ public abstract class RealmObject { <nl> * performed on it will fail with an IllegalStateException <nl> * / <nl> public void removeFromRealm ( ) { <nl> + <nl> if ( row = = null ) { <nl> throw new IllegalStateException ( " Object malformed : missing object in Realm . Make sure to instantiate RealmObjects with Realm . createObject ( ) " ) ; <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java <nl> index 5f0059a . . f1148f2 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / src / main / java / io / realm / RealmResults . java <nl> @ @ - 83 , 7 + 83 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ see io . realm . RealmQuery <nl> * / <nl> public RealmQuery < E > where ( ) { <nl> - realm . checkThread ( ) ; <nl> + realm . assertThread ( ) ; <nl> return new RealmQuery < E > ( this , classSpec ) ; <nl> } <nl> <nl> @ @ - 94 , 7 + 94 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> @ Override <nl> public E get ( int rowIndex ) { <nl> E obj ; <nl> - realm . checkThread ( ) ; <nl> + realm . assertThread ( ) ; <nl> TableOrView table = getTable ( ) ; <nl> if ( table instanceof TableView ) { <nl> obj = realm . get ( classSpec , ( ( TableView ) table ) . getSourceRowIndex ( rowIndex ) ) ; <nl> @ @ - 147 , 7 + 147 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> public RealmResults < E > sort ( String fieldName , boolean sortAscending ) { <nl> TableView sorted ; <nl> <nl> - realm . checkThread ( ) ; <nl> + realm . assertThread ( ) ; <nl> TableOrView table = getTable ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> TableView . Order TVOrder = sortAscending ? TableView . Order . ascending : TableView . Order . descending ; <nl> @ @ - 185 , 7 + 185 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if field is not int , float or double . <nl> * / <nl> public Number min ( String fieldName ) { <nl> - realm . checkThread ( ) ; <nl> + realm . assertThread ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> switch ( table . getColumnType ( columnIndex ) ) { <nl> case INTEGER : <nl> @ @ - 208 , 7 + 208 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . <nl> * / <nl> public Date minDate ( String fieldName ) { <nl> - realm . checkThread ( ) ; <nl> + realm . assertThread ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> if ( table . getColumnType ( columnIndex ) = = ColumnType . DATE ) { <nl> return table . minimumDate ( columnIndex ) ; <nl> @ @ - 226 , 7 + 226 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if field is not int , float or double . <nl> * / <nl> public Number max ( String fieldName ) { <nl> - realm . checkThread ( ) ; <nl> + realm . assertThread ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> switch ( table . getColumnType ( columnIndex ) ) { <nl> case INTEGER : <nl> @ @ - 249 , 7 + 249 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . <nl> * / <nl> public Date maxDate ( String fieldName ) { <nl> - realm . checkThread ( ) ; <nl> + realm . assertThread ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> if ( table . getColumnType ( columnIndex ) = = ColumnType . DATE ) { <nl> return table . minimumDate ( columnIndex ) ; <nl> @ @ - 269 , 7 + 269 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * / <nl> <nl> public Number sum ( String fieldName ) { <nl> - realm . checkThread ( ) ; <nl> + realm . assertThread ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> switch ( table . getColumnType ( columnIndex ) ) { <nl> case INTEGER : <nl> @ @ - 294 , 7 + 294 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if field is not int , float or double . <nl> * / <nl> public double average ( String fieldName ) { <nl> - realm . checkThread ( ) ; <nl> + realm . assertThread ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> switch ( table . getColumnType ( columnIndex ) ) { <nl> case INTEGER :

TEST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index b8bd31a . . 43f9cc4 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 11 , 6 + 11 , 7 @ @ 
 * Following methods in managed RealmList now throw IllegalStateException instead of ArrayIndexOutOfBoundsException when RealmList . isValid ( ) returns false : set ( int , RealmObject ) , move ( int , int ) , remove ( int ) , get ( int ) 
 * Following methods in managed RealmList now throw IllegalStateException instead of returning 0 / null when RealmList . isValid ( ) returns false : clear ( ) , removeAll ( Collection ) , remove ( RealmObject ) , first ( ) , last ( ) , size ( ) , where ( ) 
 * RealmPrimaryKeyConstraintException is now thrown instead of RealmException if two objects with same primary key are inserted . 
 + * IllegalStateException is now thrown when calling Realm ' s clear ( ) , RealmResults ' s remove ( ) , removeLast ( ) , clear ( ) or RealmObject ' s removeFromRealm ( ) from an incorrect thread . 
 * Fixed a bug affecting RealmConfiguration . equals ( ) . 
 * Fixed a bug in RealmQuery . isNotNull ( ) which produced wrong results for binary data . 
 * Fixed a bug in RealmQuery . isNull ( ) and RealmQuery . isNotNull ( ) which validated the query prematurely . 
 diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 index c265ce6 . . 2b8d72b 100644 
 - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 @ @ - 232 , 6 + 232 , 9 @ @ public class RealmProxyClassGenerator { 
 / / Getter 
 writer . emitAnnotation ( " Override " ) ; 
 writer . beginMethod ( fieldTypeCanonicalName , metadata . getGetter ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) ) ; 
 + writer . emitStatement ( 
 + " realm . checkIfValid ( ) " 
 + ) ; 
 writer . beginControlFlow ( " if ( row . isNullLink ( % s ) ) " , staticFieldIndexVarName ( field ) ) ; 
 writer . emitStatement ( " return null " ) ; 
 writer . endControlFlow ( ) ; 
 @ @ - 243 , 6 + 246 , 9 @ @ public class RealmProxyClassGenerator { 
 / / Setter 
 writer . emitAnnotation ( " Override " ) ; 
 writer . beginMethod ( " void " , metadata . getSetter ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) , fieldTypeCanonicalName , " value " ) ; 
 + writer . emitStatement ( 
 + " realm . checkIfValid ( ) " 
 + ) ; 
 writer . beginControlFlow ( " if ( value = = null ) " ) ; 
 writer . emitStatement ( " row . nullifyLink ( % s ) " , staticFieldIndexVarName ( field ) ) ; 
 writer . emitStatement ( " return " ) ; 
 @ @ - 258 , 7 + 264 , 7 @ @ public class RealmProxyClassGenerator { 
 / / Getter 
 writer . emitAnnotation ( " Override " ) ; 
 writer . beginMethod ( fieldTypeCanonicalName , metadata . getGetter ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) ) ; 
 - 
 + writer . emitStatement ( " realm . checkIfValid ( ) " ) ; 
 writer . emitSingleLineComment ( " use the cached value if available " ) ; 
 writer . beginControlFlow ( " if ( " + fieldName + " RealmList ! = null ) " ) ; 
 writer . emitStatement ( " return " + fieldName + " RealmList " ) ; 
 @ @ - 281 , 6 + 287 , 9 @ @ public class RealmProxyClassGenerator { 
 / / Setter 
 writer . emitAnnotation ( " Override " ) ; 
 writer . beginMethod ( " void " , metadata . getSetter ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) , fieldTypeCanonicalName , " value " ) ; 
 + writer . emitStatement ( 
 + " realm . checkIfValid ( ) " 
 + ) ; 
 writer . emitStatement ( " LinkView links = row . getLinkList ( % s ) " , staticFieldIndexVarName ( field ) ) ; 
 writer . emitStatement ( " links . clear ( ) " ) ; 
 writer . beginControlFlow ( " if ( value = = null ) " ) ; 
 diff - - git a / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java b / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java 
 index f22faa1 . . c611907 100644 
 - - - a / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java 
 + + + b / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java 
 @ @ - 152 , 6 + 152 , 7 @ @ public class AllTypesRealmProxy extends AllTypes 
 
 @ Override 
 public AllTypes getColumnObject ( ) { 
 + realm . checkIfValid ( ) ; 
 if ( row . isNullLink ( INDEX _ COLUMNOBJECT ) ) { 
 return null ; 
 } 
 @ @ - 160 , 6 + 161 , 7 @ @ public class AllTypesRealmProxy extends AllTypes 
 
 @ Override 
 public void setColumnObject ( AllTypes value ) { 
 + realm . checkIfValid ( ) ; 
 if ( value = = null ) { 
 row . nullifyLink ( INDEX _ COLUMNOBJECT ) ; 
 return ; 
 @ @ - 169 , 6 + 171 , 7 @ @ public class AllTypesRealmProxy extends AllTypes 
 
 @ Override 
 public RealmList < AllTypes > getColumnRealmList ( ) { 
 + realm . checkIfValid ( ) ; 
 / / use the cached value if available 
 if ( columnRealmListRealmList ! = null ) { 
 return columnRealmListRealmList ; 
 @ @ - 176 , 7 + 179 , 7 @ @ public class AllTypesRealmProxy extends AllTypes 
 LinkView linkView = row . getLinkList ( INDEX _ COLUMNREALMLIST ) ; 
 if ( linkView = = null ) { 
 / / return empty non managed RealmList if the LinkView is null 
 - / / useful for non - initialized RealmObject ( async query return empty Row while the query is performing ) 
 + / / useful for non - initialized RealmObject ( async query returns empty Row while the query is still running ) 
 return EMPTY _ REALM _ LIST _ COLUMNREALMLIST ; 
 } else { 
 columnRealmListRealmList = new RealmList < AllTypes > ( AllTypes . class , linkView , realm ) ; 
 @ @ - 187 , 6 + 190 , 7 @ @ public class AllTypesRealmProxy extends AllTypes 
 
 @ Override 
 public void setColumnRealmList ( RealmList < AllTypes > value ) { 
 + realm . checkIfValid ( ) ; 
 LinkView links = row . getLinkList ( INDEX _ COLUMNREALMLIST ) ; 
 links . clear ( ) ; 
 if ( value = = null ) { 
 diff - - git a / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java b / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java 
 index 41c6091 . . 95179b1 100644 
 - - - a / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java 
 + + + b / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java 
 @ @ - 414 , 6 + 414 , 7 @ @ public class NullTypesRealmProxy extends NullTypes 
 
 @ Override 
 public NullTypes getFieldObjectNull ( ) { 
 + realm . checkIfValid ( ) ; 
 if ( row . isNullLink ( INDEX _ FIELDOBJECTNULL ) ) { 
 return null ; 
 } 
 @ @ - 422 , 6 + 423 , 7 @ @ public class NullTypesRealmProxy extends NullTypes 
 
 @ Override 
 public void setFieldObjectNull ( NullTypes value ) { 
 + realm . checkIfValid ( ) ; 
 if ( value = = null ) { 
 row . nullifyLink ( INDEX _ FIELDOBJECTNULL ) ; 
 return ; 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmListTest . java b / realm / src / androidTest / java / io / realm / RealmListTest . java 
 index b787d8d . . 7f7ee50 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmListTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmListTest . java 
 @ @ - 19 , 8 + 19 , 14 @ @ package io . realm ; 
 import android . test . AndroidTestCase ; 
 
 import java . util . Collections ; 
 + import java . util . concurrent . Callable ; 
 + import java . util . concurrent . ExecutionException ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Executors ; 
 + import java . util . concurrent . Future ; 
 
 import io . realm . entities . AllTypes ; 
 + import io . realm . entities . AllTypesPrimaryKey ; 
 import io . realm . entities . CyclicType ; 
 import io . realm . entities . CyclicTypePrimaryKey ; 
 import io . realm . entities . Dog ; 
 @ @ - 79 , 8 + 85 , 8 @ @ public class RealmListTest extends AndroidTestCase { 
 case 3 : list . move ( 0 , 0 ) ; break ; 
 } 
 fail ( ) ; 
 - } catch ( IndexOutOfBoundsException expected ) { 
 - } catch ( RealmException expected ) { 
 + } catch ( IndexOutOfBoundsException ignored ) { 
 + } catch ( RealmException ignored ) { 
 } 
 } 
 realm . cancelTransaction ( ) ; 
 @ @ - 719 , 12 + 725 , 76 @ @ public class RealmListTest extends AndroidTestCase { 
 list . add ( dog ) ; 
 testRealm . commitTransaction ( ) ; 
 
 - try { list . add ( dog ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } 
 - try { list . add ( 0 , dog ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } 
 - try { list . clear ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } 
 - try { list . move ( 0 , 1 ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } 
 - try { list . remove ( 0 ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } 
 - try { list . set ( 0 , dog ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } 
 + try { list . add ( dog ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } 
 + try { list . add ( 0 , dog ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } 
 + try { list . clear ( ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } 
 + try { list . move ( 0 , 1 ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } 
 + try { list . remove ( 0 ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } 
 + try { list . set ( 0 , dog ) ; fail ( ) ; } catch ( IllegalStateException ignored ) { } 
 + } 
 + 
 + private enum Method { 
 + METHOD _ ADD , 
 + METHOD _ ADD _ AT , 
 + METHOD _ CLEAR , 
 + METHOD _ MOVE , 
 + METHOD _ REMOVE , 
 + METHOD _ SET 
 + } 
 + 
 + / / Calling methods from the wrong thread should fail 
 + private boolean methodWrongThread ( final Method method ) throws InterruptedException , ExecutionException { 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . clear ( AllTypes . class ) ; 
 + testRealm . clear ( Dog . class ) ; 
 + final RealmList < Dog > list = testRealm . createObject ( AllTypes . class ) . getColumnRealmList ( ) ; 
 + Dog dog = testRealm . createObject ( Dog . class ) ; 
 + list . add ( dog ) ; 
 + testRealm . commitTransaction ( ) ; 
 + 
 + testRealm . beginTransaction ( ) ; / / Make sure that a valid transaction has begun on the correct thread 
 + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 + @ Override 
 + public Boolean call ( ) throws Exception { 
 + try { 
 + switch ( method ) { 
 + case METHOD _ ADD : 
 + list . add ( new Dog ( ) ) ; 
 + break ; 
 + case METHOD _ ADD _ AT : 
 + list . add ( 1 , new Dog ( ) ) ; 
 + break ; 
 + case METHOD _ CLEAR : 
 + list . clear ( ) ; 
 + break ; 
 + case METHOD _ MOVE : 
 + list . add ( new Dog ( ) ) ; 
 + list . move ( 0 , 1 ) ; 
 + break ; 
 + case METHOD _ REMOVE : 
 + list . remove ( 0 ) ; 
 + break ; 
 + case METHOD _ SET : 
 + list . set ( 0 , new Dog ( ) ) ; 
 + break ; 
 + } 
 + return false ; 
 + } catch ( IllegalStateException ignored ) { 
 + return true ; 
 + } 
 + } 
 + } ) ; 
 + 
 + boolean result = future . get ( ) ; 
 + testRealm . cancelTransaction ( ) ; 
 + return result ; 
 + } 
 + 
 + public void testMethodsThrowOnWrongThread ( ) throws ExecutionException , InterruptedException { 
 + for ( Method method : Method . values ( ) ) { 
 + assertTrue ( method . toString ( ) , methodWrongThread ( method ) ) ; 
 + } 
 } 
 
 public void testSettingListClearsOldItems ( ) { 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmObjectTest . java b / realm / src / androidTest / java / io / realm / RealmObjectTest . java 
 index 55267fe . . b05f46e 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmObjectTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmObjectTest . java 
 @ @ - 214 , 7 + 214 , 14 @ @ public class RealmObjectTest extends AndroidTestCase { 
 removeOneByOne ( REMOVE _ LAST ) ; 
 } 
 
 - public boolean methodWrongThread ( final boolean callGetter ) throws ExecutionException , InterruptedException { 
 + private enum Method { 
 + METHOD _ GETTER , 
 + METHOD _ SETTER , 
 + METHOD _ REMOVE _ FROM _ REALM 
 + } 
 + 
 + public boolean methodWrongThread ( final Method method ) throws ExecutionException , InterruptedException { 
 + 
 testRealm = Realm . getInstance ( getContext ( ) ) ; 
 testRealm . beginTransaction ( ) ; 
 testRealm . createObject ( AllTypes . class ) ; 
 @ @ - 225 , 10 + 232 , 16 @ @ public class RealmObjectTest extends AndroidTestCase { 
 @ Override 
 public Boolean call ( ) throws Exception { 
 try { 
 - if ( callGetter ) { 
 - allTypes . getColumnFloat ( ) ; 
 - } else { 
 - allTypes . setColumnFloat ( 1 . 0f ) ; 
 + switch ( method ) { 
 + case METHOD _ GETTER : 
 + allTypes . getColumnFloat ( ) ; 
 + break ; 
 + case METHOD _ SETTER : 
 + allTypes . setColumnFloat ( 1 . 0f ) ; 
 + break ; 
 + case METHOD _ REMOVE _ FROM _ REALM : 
 + allTypes . removeFromRealm ( ) ; 
 + break ; 
 } 
 return false ; 
 } catch ( IllegalStateException ignored ) { 
 @ @ - 242 , 9 + 255 , 10 @ @ public class RealmObjectTest extends AndroidTestCase { 
 return result ; 
 } 
 
 - public void testGetSetWrongThread ( ) throws ExecutionException , InterruptedException { 
 - assertTrue ( methodWrongThread ( true ) ) ; 
 - assertTrue ( methodWrongThread ( false ) ) ; 
 + public void testMethodsThrowOnWrongThread ( ) throws ExecutionException , InterruptedException { 
 + for ( Method method : Method . values ( ) ) { 
 + assertTrue ( methodWrongThread ( method ) ) ; 
 + } 
 } 
 
 public void testEqualsSameRealmObject ( ) { 
 @ @ - 385 , 21 + 399 , 6 @ @ public class RealmObjectTest extends AndroidTestCase { 
 return cal . getTime ( ) ; 
 } 
 
 - private void addDate ( int year , int month , int dayOfMonth ) { 
 - Date date = newDate ( year , month , dayOfMonth ) ; 
 - 
 - testRealm . beginTransaction ( ) ; 
 - testRealm . clear ( AllTypes . class ) ; 
 - AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; 
 - allTypes . setColumnDate ( date ) ; 
 - testRealm . commitTransaction ( ) ; 
 - 
 - AllTypes object = testRealm . allObjects ( AllTypes . class ) . first ( ) ; 
 - 
 - / / Realm does not support millisec precision 
 - assertEquals ( 1000 * ( date . getTime ( ) / 1000 ) , 1000 * ( object . getColumnDate ( ) . getTime ( ) / 1000 ) ) ; 
 - } 
 - 
 public void testWriteMustThrowOutOfTransaction ( ) { 
 testRealm . beginTransaction ( ) ; 
 Dog dog = testRealm . createObject ( Dog . class ) ; 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 index e613b71 . . d45acb9 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 @ @ - 138 , 11 + 138 , 15 @ @ public class RealmResultsTest extends AndroidTestCase { 
 METHOD _ SUM , 
 METHOD _ AVG , 
 METHOD _ SORT , 
 - METHOD _ WHERE 
 + METHOD _ WHERE , 
 + METHOD _ REMOVE , 
 + METHOD _ REMOVE _ LAST , 
 + METHOD _ CLEAR 
 } 
 
 public boolean methodWrongThread ( final Method method ) throws ExecutionException , InterruptedException { 
 final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; 
 + testRealm . beginTransaction ( ) ; 
 ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 @ Override 
 @ @ - 166 , 6 + 170 , 16 @ @ public class RealmResultsTest extends AndroidTestCase { 
 break ; 
 case METHOD _ WHERE : 
 allTypeses . where ( ) ; 
 + break ; 
 + case METHOD _ REMOVE : 
 + allTypeses . remove ( 0 ) ; 
 + break ; 
 + case METHOD _ REMOVE _ LAST : 
 + allTypeses . removeLast ( ) ; 
 + break ; 
 + case METHOD _ CLEAR : 
 + allTypeses . clear ( ) ; 
 + break ; 
 } 
 return false ; 
 } catch ( IllegalStateException ignored ) { 
 @ @ - 173 , 7 + 187 , 9 @ @ public class RealmResultsTest extends AndroidTestCase { 
 } 
 } 
 } ) ; 
 - return future . get ( ) ; 
 + Boolean result = future . get ( ) ; 
 + testRealm . cancelTransaction ( ) ; 
 + return result ; 
 } 
 
 / / test io . realm . ResultList Api 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index 20833e4 . . 620e52d 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 44 , 6 + 44 , 7 @ @ import java . util . concurrent . TimeoutException ; 
 import java . util . concurrent . atomic . AtomicBoolean ; 
 
 import io . realm . dynamic . DynamicRealmObject ; 
 + import io . realm . entities . AllJavaTypes ; 
 import io . realm . entities . AllTypes ; 
 import io . realm . entities . AllTypesPrimaryKey ; 
 import io . realm . entities . AnnotationIndexTypes ; 
 @ @ - 602 , 18 + 603 , 26 @ @ public class RealmTest extends AndroidTestCase { 
 testRealm . commitTransaction ( ) ; 
 } 
 
 - private enum TransactionMethod { 
 + private enum Method { 
 METHOD _ BEGIN , 
 METHOD _ COMMIT , 
 - METHOD _ CANCEL 
 - } 
 - 
 - / / Starting a transaction on the wrong thread will fail 
 - private boolean transactionMethodWrongThread ( final TransactionMethod method ) throws InterruptedException , 
 - ExecutionException { 
 - if ( method ! = TransactionMethod . METHOD _ BEGIN ) { 
 + METHOD _ CANCEL , 
 + METHOD _ CLEAR , 
 + METHOD _ DISTINCT , 
 + METHOD _ CREATE _ OBJECT , 
 + METHOD _ COPY _ TO _ REALM , 
 + METHOD _ COPY _ TO _ REALM _ OR _ UPDATE , 
 + METHOD _ CREATE _ ALL _ FROM _ JSON , 
 + METHOD _ CREATE _ OR _ UPDATE _ ALL _ FROM _ JSON , 
 + METHOD _ CREATE _ FROM _ JSON , 
 + METHOD _ CREATE _ OR _ UPDATE _ FROM _ JSON 
 + } 
 + 
 + / / Calling methods on a wrong thread will fail . 
 + private boolean methodWrongThread ( final Method method ) throws InterruptedException , ExecutionException { 
 + if ( method ! = Method . METHOD _ BEGIN ) { 
 testRealm . beginTransaction ( ) ; 
 - testRealm . createObject ( Dog . class ) ; / / FIXME : Empty transactions cannot be cancelled 
 + testRealm . createObject ( Dog . class ) ; 
 } 
 ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 @ @ - 630 , 24 + 639 , 54 @ @ public class RealmTest extends AndroidTestCase { 
 case METHOD _ CANCEL : 
 testRealm . cancelTransaction ( ) ; 
 break ; 
 + case METHOD _ CLEAR : 
 + testRealm . clear ( AllTypes . class ) ; 
 + break ; 
 + case METHOD _ DISTINCT : 
 + testRealm . distinct ( AllTypesPrimaryKey . class , " columnLong " ) ; 
 + break ; 
 + case METHOD _ CREATE _ OBJECT : 
 + testRealm . createObject ( AllTypes . class ) ; 
 + break ; 
 + case METHOD _ COPY _ TO _ REALM : 
 + testRealm . copyToRealm ( new AllTypes ( ) ) ; 
 + break ; 
 + case METHOD _ COPY _ TO _ REALM _ OR _ UPDATE : 
 + testRealm . copyToRealm ( new AllTypesPrimaryKey ( ) ) ; 
 + break ; 
 + case METHOD _ CREATE _ ALL _ FROM _ JSON : 
 + testRealm . createAllFromJson ( AllTypes . class , " [ { } ] " ) ; 
 + break ; 
 + case METHOD _ CREATE _ OR _ UPDATE _ ALL _ FROM _ JSON : 
 + testRealm . createOrUpdateAllFromJson ( AllTypesPrimaryKey . class , " [ { \ " columnLong \ " : 1 } ] " ) ; 
 + break ; 
 + case METHOD _ CREATE _ FROM _ JSON : 
 + testRealm . createObjectFromJson ( AllTypes . class , " { } " ) ; 
 + break ; 
 + case METHOD _ CREATE _ OR _ UPDATE _ FROM _ JSON : 
 + testRealm . createOrUpdateObjectFromJson ( AllTypesPrimaryKey . class , " { \ " columnLong \ " : 1 } " ) ; 
 + break ; 
 } 
 return false ; 
 } catch ( IllegalStateException ignored ) { 
 return true ; 
 + } catch ( RealmException jsonFailure ) { 
 + / / TODO : Eew . Reconsider how our JSON methods reports failure . See https : / / github . com / realm / realm - java / issues / 1594 
 + return ( jsonFailure . getMessage ( ) . equals ( " Could not map Json " ) ) ; 
 } 
 } 
 } ) ; 
 
 boolean result = future . get ( ) ; 
 - if ( result & & method ! = TransactionMethod . METHOD _ BEGIN ) { 
 + if ( method ! = Method . METHOD _ BEGIN ) { 
 testRealm . cancelTransaction ( ) ; 
 } 
 return result ; 
 } 
 
 - public void testTransactionWrongThread ( ) throws ExecutionException , InterruptedException { 
 - for ( TransactionMethod method : TransactionMethod . values ( ) ) { 
 - assertTrue ( method . toString ( ) , transactionMethodWrongThread ( method ) ) ; 
 + public void testMethodsThrowOnWrongThread ( ) throws ExecutionException , InterruptedException { 
 + for ( Method method : Method . values ( ) ) { 
 + assertTrue ( method . toString ( ) , methodWrongThread ( method ) ) ; 
 } 
 } 
 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index e45e2bd . . c76fb16 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 689 , 6 + 689 , 7 @ @ public final class Realm extends BaseRealm { 
 * @ throws RealmException An object could not be created 
 * / 
 public < E extends RealmObject > E createObject ( Class < E > clazz ) { 
 + checkIfValid ( ) ; 
 Table table = getTable ( clazz ) ; 
 long rowIndex = table . addEmptyRow ( ) ; 
 return get ( clazz , rowIndex ) ; 
 @ @ - 952 , 7 + 953 , 7 @ @ public final class Realm extends BaseRealm { 
 if ( fieldName = = null ) { 
 throw new IllegalArgumentException ( " fieldName must be provided . " ) ; 
 } 
 - 
 + checkIfValid ( ) ; 
 Table table = this . getTable ( clazz ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 if ( columnIndex = = - 1 ) { 
 @ @ - 1077 , 14 + 1078 , 17 @ @ public final class Realm extends BaseRealm { 
 * Remove all objects of the specified class . 
 * 
 * @ param clazz The class which objects should be removed 
 + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . 
 * @ throws java . lang . RuntimeException Any other error 
 * / 
 public void clear ( Class < ? extends RealmObject > clazz ) { 
 + checkIfValid ( ) ; 
 getTable ( clazz ) . clear ( ) ; 
 } 
 
 @ SuppressWarnings ( " unchecked " ) 
 private < E extends RealmObject > E copyOrUpdate ( E object , boolean update ) { 
 + checkIfValid ( ) ; 
 return configuration . getSchemaMediator ( ) . copyOrUpdate ( this , object , update , new HashMap < RealmObject , RealmObjectProxy > ( ) ) ; 
 } 
 
 diff - - git a / realm / src / main / java / io / realm / RealmList . java b / realm / src / main / java / io / realm / RealmList . java 
 index eedc97d . . 777bf03 100644 
 - - - a / realm / src / main / java / io / realm / RealmList . java 
 + + + b / realm / src / main / java / io / realm / RealmList . java 
 @ @ - 140 , 7 + 140 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 public void add ( int location , E object ) { 
 checkValidObject ( object ) ; 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 object = copyToRealmIfNeeded ( object ) ; 
 view . insert ( location , object . row . getIndex ( ) ) ; 
 } else { 
 @ @ - 167 , 7 + 167 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 public boolean add ( E object ) { 
 checkValidObject ( object ) ; 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 object = copyToRealmIfNeeded ( object ) ; 
 view . add ( object . row . getIndex ( ) ) ; 
 } else { 
 @ @ - 198 , 7 + 198 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 public E set ( int location , E object ) { 
 checkValidObject ( object ) ; 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 object = copyToRealmIfNeeded ( object ) ; 
 view . set ( location , object . row . getIndex ( ) ) ; 
 } else { 
 @ @ - 233 , 7 + 233 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 * / 
 public void move ( int oldPos , int newPos ) { 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 view . move ( oldPos , newPos ) ; 
 } else { 
 checkIndex ( oldPos ) ; 
 @ @ - 257 , 7 + 257 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 @ Override 
 public void clear ( ) { 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 view . clear ( ) ; 
 } else { 
 nonManagedList . clear ( ) ; 
 @ @ - 275 , 7 + 275 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 @ Override 
 public E remove ( int location ) { 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 E removedItem = get ( location ) ; 
 view . remove ( location ) ; 
 return removedItem ; 
 @ @ - 295 , 7 + 295 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 @ Override 
 public E get ( int location ) { 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 return realm . get ( clazz , view . getTargetRowIndex ( location ) ) ; 
 } else { 
 return nonManagedList . get ( location ) ; 
 @ @ - 310 , 7 + 310 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 * / 
 public E first ( ) { 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 return view . isEmpty ( ) ? null : get ( 0 ) ; 
 } else if ( nonManagedList ! = null & & nonManagedList . size ( ) > 0 ) { 
 return nonManagedList . get ( 0 ) ; 
 @ @ - 326 , 7 + 326 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 * / 
 public E last ( ) { 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 return view . isEmpty ( ) ? null : get ( ( int ) view . size ( ) - 1 ) ; 
 } else if ( nonManagedList ! = null & & nonManagedList . size ( ) > 0 ) { 
 return nonManagedList . get ( nonManagedList . size ( ) - 1 ) ; 
 @ @ - 343 , 7 + 343 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 @ Override 
 public int size ( ) { 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 long size = view . size ( ) ; 
 return size < Integer . MAX _ VALUE ? ( int ) size : Integer . MAX _ VALUE ; 
 } else { 
 @ @ - 360 , 7 + 360 , 7 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 * / 
 public RealmQuery < E > where ( ) { 
 if ( managedMode ) { 
 - checkIfViewAttached ( ) ; 
 + checkValidView ( ) ; 
 return new RealmQuery < E > ( this . realm , view , clazz ) ; 
 } else { 
 throw new RealmException ( ONLY _ IN _ MANAGED _ MODE _ MESSAGE ) ; 
 @ @ - 380 , 7 + 380 , 8 @ @ public class RealmList < E extends RealmObject > extends AbstractList < E > { 
 } 
 } 
 
 - private void checkIfViewAttached ( ) { 
 + private void checkValidView ( ) { 
 + realm . checkIfValid ( ) ; 
 if ( view = = null | | ! view . isAttached ( ) ) { 
 throw new IllegalStateException ( " Realm instance has been closed or parent object has been removed . " ) ; 
 } 
 diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java 
 index 05532ba . . 3e81961 100644 
 - - - a / realm / src / main / java / io / realm / RealmObject . java 
 + + + b / realm / src / main / java / io / realm / RealmObject . java 
 @ @ - 94 , 6 + 94 , 8 @ @ public abstract class RealmObject { 
 * < p > 
 * After this method is called the object will be invalid and any operation ( read or write ) 
 * performed on it will fail with an IllegalStateException 
 + * 
 + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . 
 * / 
 public void removeFromRealm ( ) { 
 if ( row = = null ) { 
 @ @ - 102 , 6 + 104 , 8 @ @ public abstract class RealmObject { 
 if ( realm = = null ) { 
 throw new IllegalStateException ( " Object malformed : missing Realm . Make sure to instantiate RealmObjects with Realm . createObject ( ) " ) ; 
 } 
 + realm . checkIfValid ( ) ; 
 + 
 row . getTable ( ) . moveLastOver ( row . getIndex ( ) ) ; 
 row = InvalidRow . INSTANCE ; 
 } 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index a3d0225 . . 3a98f0d 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 68 , 7 + 68 , 6 @ @ public class RealmQuery < E extends RealmObject > { 
 private final Map < String , Long > columns ; 
 private final Class < E > clazz ; 
 
 - private static final String LINK _ NOT _ SUPPORTED _ METHOD = " ' % s ' is not supported for link queries " ; 
 private static final String TYPE _ MISMATCH = " Field ' % s ' : type mismatch - % s expected . " ; 
 
 public static final boolean CASE _ SENSITIVE = true ; 
 diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java 
 index 9177899 . . 0312296 100644 
 - - - a / realm / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / src / main / java / io / realm / RealmResults . java 
 @ @ - 511 , 9 + 511 , 11 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * 
 * @ param index The array index identifying the object to be removed . 
 * @ return Always return { @ code null } . 
 + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . 
 * / 
 @ Override 
 public E remove ( int index ) { 
 + realm . checkIfValid ( ) ; 
 TableOrView table = getTable ( ) ; 
 table . remove ( index ) ; 
 return null ; / / Returning the object doesn ' t make sense , since it could no longer access any data . 
 @ @ - 525 , 8 + 527 , 11 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * 
 * Using this method while iterating the list can result in a undefined behavior . Use 
 * { @ link io . realm . RealmResults . RealmResultsListIterator # removeLast ( ) } instead . 
 + * 
 + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . 
 * / 
 public void removeLast ( ) { 
 + realm . checkIfValid ( ) ; 
 TableOrView table = getTable ( ) ; 
 table . removeLast ( ) ; 
 } 
 @ @ - 534 , 8 + 539 , 11 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 / * * 
 * Removes all objects from the list . This also deletes the objects from the 
 * underlying Realm . 
 + * 
 + * @ throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread . 
 * / 
 public void clear ( ) { 
 + realm . checkIfValid ( ) ; 
 TableOrView table = getTable ( ) ; 
 table . clear ( ) ; 
 }

NEAREST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index 568299a . . 74fd137 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 1 , 5 + 1 , 5 @ @ 
 0 . 74 . 0 ( ? ? ) 
 - * For many thread fragtile methods , check if correct thread , and throw exception if not 
 + * An exception will now be thrown if you try to move Realm , RealmResults or RealmObject between threads . 
 
 0 . 73 . 1 ( 05 Nov 2014 ) 
 * Fixed a bug that would send infinite notifications in some instances 
 diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 index bb6f25f . . 73f135c 100644 
 - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 @ @ - 220 , 6 + 220 , 7 @ @ public class RealmProxyClassGenerator { 
 " io . realm . internal . LinkView " , 
 " io . realm . RealmList " , 
 " io . realm . RealmObject " , 
 + " io . realm . Realm " , 
 " java . util . * " , 
 packageName + " . * " ) 
 . emitEmptyLine ( ) ; 
 @ @ - 253 , 6 + 254 , 9 @ @ public class RealmProxyClassGenerator { 
 String getterPrefix = fieldTypeCanonicalName . equals ( " boolean " ) ? " is " : " get " ; 
 writer . beginMethod ( fieldTypeCanonicalName , getterPrefix + capitaliseFirstChar ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) ) ; 
 writer . emitStatement ( 
 + " realm . assertThread ( ) " 
 + ) ; 
 + writer . emitStatement ( 
 " return ( % s ) row . get % s ( Realm . columnIndices . get ( \ " % s \ " ) . get ( \ " % s \ " ) ) " , 
 fieldTypeCanonicalName , realmType , className , fieldName ) ; 
 writer . endMethod ( ) ; 
 @ @ - 262 , 6 + 266 , 9 @ @ public class RealmProxyClassGenerator { 
 writer . emitAnnotation ( " Override " ) ; 
 writer . beginMethod ( " void " , " set " + capitaliseFirstChar ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) , fieldTypeCanonicalName , " value " ) ; 
 writer . emitStatement ( 
 + " realm . assertThread ( ) " 
 + ) ; 
 + writer . emitStatement ( 
 " row . set % s ( Realm . columnIndices . get ( \ " % s \ " ) . get ( \ " % s \ " ) , ( % s ) value ) " , 
 realmType , className , fieldName , castingType ) ; 
 writer . endMethod ( ) ; 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmObjectTest . java b / realm / src / androidTest / java / io / realm / RealmObjectTest . java 
 index bd3279e . . c251bd8 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmObjectTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmObjectTest . java 
 @ @ - 18 , 6 + 18 , 12 @ @ package io . realm ; 
 
 import android . test . AndroidTestCase ; 
 
 + import java . util . concurrent . Callable ; 
 + import java . util . concurrent . ExecutionException ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Executors ; 
 + import java . util . concurrent . Future ; 
 + 
 import io . realm . entities . AllTypes ; 
 import io . realm . entities . Dog ; 
 import io . realm . internal . Row ; 
 @ @ - 96 , 4 + 102 , 37 @ @ public class RealmObjectTest extends AndroidTestCase { 
 fail ( ) ; 
 } catch ( IllegalStateException ignored ) { } 
 } 
 + 
 + public boolean methodWrongThread ( final boolean callGetter ) throws ExecutionException , InterruptedException { 
 + Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 + realm . beginTransaction ( ) ; 
 + realm . createObject ( AllTypes . class ) ; 
 + realm . commitTransaction ( ) ; 
 + final AllTypes allTypes = realm . where ( AllTypes . class ) . findFirst ( ) ; 
 + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 + @ Override 
 + public Boolean call ( ) throws Exception { 
 + try { 
 + if ( callGetter ) 
 + allTypes . getColumnFloat ( ) ; 
 + else 
 + allTypes . setColumnFloat ( 1 . 0f ) ; 
 + return false ; 
 + } catch ( IllegalStateException ignored ) { 
 + return true ; 
 + } 
 + } 
 + } ) ; 
 + 
 + return future . get ( ) ; 
 + } 
 + 
 + public void testGetWrongThread ( ) throws ExecutionException , InterruptedException { 
 + assertTrue ( methodWrongThread ( true ) ) ; 
 + } 
 + 
 + public void testSetWrong ( ) throws ExecutionException , InterruptedException { 
 + assertTrue ( methodWrongThread ( false ) ) ; 
 + } 
 } 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 index 076c5ae . . c257446 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 @ @ - 67 , 6 + 67 , 48 @ @ public class RealmResultsTest extends AndroidTestCase { 
 testRealm . commitTransaction ( ) ; 
 } 
 
 + private static final int METHOD _ MIN = 1 ; 
 + private static final int METHOD _ MAX = 2 ; 
 + private static final int METHOD _ SUM = 3 ; 
 + private static final int METHOD _ AVG = 4 ; 
 + private static final int METHOD _ SORT = 5 ; 
 + private static final int METHOD _ WHERE = 6 ; 
 + public boolean methodWrongThread ( final int method ) throws ExecutionException , InterruptedException { 
 + final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; 
 + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 + @ Override 
 + public Boolean call ( ) throws Exception { 
 + try { 
 + switch ( method ) { 
 + case METHOD _ MIN : 
 + allTypeses . min ( FIELD _ FLOAT ) ; 
 + break ; 
 + case METHOD _ MAX : 
 + allTypeses . max ( FIELD _ FLOAT ) ; 
 + break ; 
 + case METHOD _ SUM : 
 + allTypeses . sum ( FIELD _ FLOAT ) ; 
 + break ; 
 + case METHOD _ AVG : 
 + allTypeses . average ( FIELD _ FLOAT ) ; 
 + break ; 
 + case METHOD _ SORT : 
 + allTypeses . sort ( FIELD _ FLOAT ) ; 
 + break ; 
 + case METHOD _ WHERE : 
 + allTypeses . where ( ) ; 
 + } 
 + return false ; 
 + } catch ( IllegalStateException ignored ) { 
 + return true ; 
 + } 
 + } 
 + } ) ; 
 + 
 + return future . get ( ) ; 
 + } 
 + 
 
 / / test io . realm . ResultList Api 
 
 @ @ - 137 , 22 + 179 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { 
 } 
 
 public void testMinWrongThread ( ) throws ExecutionException , InterruptedException { 
 - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; 
 - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 - @ Override 
 - public Boolean call ( ) throws Exception { 
 - try { 
 - allTypeses . min ( FIELD _ FLOAT ) ; 
 - return false ; 
 - } catch ( IllegalStateException ignored ) { 
 - return true ; 
 - } 
 - } 
 - } ) ; 
 - 
 - Boolean result = future . get ( ) ; 
 - assertTrue ( result ) ; 
 + assertTrue ( methodWrongThread ( METHOD _ MIN ) ) ; 
 } 
 
 public void testMaxValueIsMaxValue ( ) { 
 @ @ - 163 , 22 + 190 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { 
 } 
 
 public void testMaxWrongThread ( ) throws ExecutionException , InterruptedException { 
 - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; 
 - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 - @ Override 
 - public Boolean call ( ) throws Exception { 
 - try { 
 - allTypeses . max ( FIELD _ FLOAT ) ; 
 - return false ; 
 - } catch ( IllegalStateException ignored ) { 
 - return true ; 
 - } 
 - } 
 - } ) ; 
 - 
 - Boolean result = future . get ( ) ; 
 - assertTrue ( result ) ; 
 + assertTrue ( methodWrongThread ( METHOD _ MAX ) ) ; 
 } 
 
 public void testSumGivesCorrectValue ( ) { 
 @ @ - 194 , 22 + 206 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { 
 } 
 
 public void testSumWrongThread ( ) throws ExecutionException , InterruptedException { 
 - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; 
 - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 - @ Override 
 - public Boolean call ( ) throws Exception { 
 - try { 
 - allTypeses . sum ( FIELD _ FLOAT ) ; 
 - return false ; 
 - } catch ( IllegalStateException ignored ) { 
 - return true ; 
 - } 
 - } 
 - } ) ; 
 - 
 - Boolean result = future . get ( ) ; 
 - assertTrue ( result ) ; 
 + assertTrue ( methodWrongThread ( METHOD _ SUM ) ) ; 
 } 
 
 public void testAvgGivesCorrectValue ( ) { 
 @ @ - 241 , 22 + 238 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { 
 } 
 
 public void testAverageWrongThread ( ) throws ExecutionException , InterruptedException { 
 - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; 
 - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 - @ Override 
 - public Boolean call ( ) throws Exception { 
 - try { 
 - allTypeses . average ( FIELD _ FLOAT ) ; 
 - return false ; 
 - } catch ( IllegalStateException ignored ) { 
 - return true ; 
 - } 
 - } 
 - } ) ; 
 - 
 - Boolean result = future . get ( ) ; 
 - assertTrue ( result ) ; 
 + assertTrue ( methodWrongThread ( METHOD _ AVG ) ) ; 
 } 
 
 / / void clear ( Class < ? > classSpec ) 
 @ @ - 411 , 22 + 393 , 7 @ @ public class RealmResultsTest extends AndroidTestCase { 
 } 
 
 public void testSortWrongThread ( ) throws ExecutionException , InterruptedException { 
 - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; 
 - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 - @ Override 
 - public Boolean call ( ) throws Exception { 
 - try { 
 - allTypeses . sort ( FIELD _ FLOAT ) ; 
 - return false ; 
 - } catch ( IllegalStateException ignored ) { 
 - return true ; 
 - } 
 - } 
 - } ) ; 
 - 
 - Boolean result = future . get ( ) ; 
 - assertTrue ( result ) ; 
 + assertTrue ( methodWrongThread ( METHOD _ SORT ) ) ; 
 } 
 
 public void testCount ( ) { 
 @ @ - 458 , 21 + 425 , 6 @ @ public class RealmResultsTest extends AndroidTestCase { 
 } 
 
 public void testWhereWrongThread ( ) throws ExecutionException , InterruptedException { 
 - final RealmResults < AllTypes > allTypeses = testRealm . where ( AllTypes . class ) . findAll ( ) ; 
 - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 - @ Override 
 - public Boolean call ( ) throws Exception { 
 - try { 
 - allTypeses . where ( ) ; 
 - return false ; 
 - } catch ( IllegalStateException ignored ) { 
 - return true ; 
 - } 
 - } 
 - } ) ; 
 - 
 - Boolean result = future . get ( ) ; 
 - assertTrue ( result ) ; 
 + assertTrue ( methodWrongThread ( METHOD _ WHERE ) ) ; 
 } 
 } 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index d3a0c3f . . 29b3780 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 83 , 8 + 83 , 7 @ @ public class Realm { 
 private static final int REALM _ CHANGED = 14930352 ; / / Just a nice big Fibonacci number . For no reason : ) 
 private static final Map < Handler , Integer > handlers = new ConcurrentHashMap < Handler , Integer > ( ) ; 
 private static final String APT _ NOT _ EXECUTED _ MESSAGE = " Annotation processor may not have been executed . " ; 
 - private static final String INCORRECT _ THREAD _ MESSAGE = " Realm accessed from incorrect thread . " ; 
 - 
 + private static final String INCORRECT _ THREAD _ MESSAGE = " Realm access from incorrect thread . Realm objects can only be accessed on the thread they where created . " ; 
 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 private static SharedGroup . Durability defaultDurability = SharedGroup . Durability . FULL ; 
 @ @ - 106 , 7 + 105 , 7 @ @ public class Realm { 
 / / Package protected to be reachable by proxy classes 
 static final Map < String , Map < String , Long > > columnIndices = new HashMap < String , Map < String , Long > > ( ) ; 
 
 - protected void checkThread ( ) { 
 + protected void assertThread ( ) { 
 if ( realmsCache . get ( ) . get ( new Integer ( this . id ) ) = = null ) { 
 throw new IllegalStateException ( INCORRECT _ THREAD _ MESSAGE ) ; 
 } 
 @ @ - 652 , 7 + 651 , 7 @ @ public class Realm { 
 * @ see io . realm . RealmChangeListener 
 * / 
 public void addChangeListener ( RealmChangeListener listener ) { 
 - checkThread ( ) ; 
 + assertThread ( ) ; 
 changeListeners . add ( listener ) ; 
 } 
 
 @ @ - 663 , 7 + 662 , 7 @ @ public class Realm { 
 * @ see io . realm . RealmChangeListener 
 * / 
 public void removeChangeListener ( RealmChangeListener listener ) { 
 - checkThread ( ) ; 
 + assertThread ( ) ; 
 changeListeners . remove ( listener ) ; 
 } 
 
 @ @ - 673 , 7 + 672 , 7 @ @ public class Realm { 
 * @ see io . realm . RealmChangeListener 
 * / 
 public void removeAllChangeListeners ( ) { 
 - checkThread ( ) ; 
 + assertThread ( ) ; 
 changeListeners . clear ( ) ; 
 } 
 
 @ @ - 697 , 7 + 696 , 7 @ @ public class Realm { 
 * / 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 public void refresh ( ) { 
 - checkThread ( ) ; 
 + assertThread ( ) ; 
 transaction . advanceRead ( ) ; 
 } 
 
 @ @ - 716 , 7 + 715 , 7 @ @ public class Realm { 
 * 
 * / 
 public void beginTransaction ( ) { 
 - checkThread ( ) ; 
 + assertThread ( ) ; 
 transaction . promoteToWrite ( ) ; 
 } 
 
 @ @ - 730 , 7 + 729 , 7 @ @ public class Realm { 
 * @ throws java . lang . IllegalStateException If the write transaction is in an invalid state or incorrect thread . 
 * / 
 public void commitTransaction ( ) { 
 - checkThread ( ) ; 
 + assertThread ( ) ; 
 transaction . commitAndContinueAsRead ( ) ; 
 
 for ( Map . Entry < Handler , Integer > handlerIntegerEntry : handlers . entrySet ( ) ) { 
 @ @ - 760 , 7 + 759 , 7 @ @ public class Realm { 
 * not in a write transaction or incorrect thread . 
 * / 
 public void cancelTransaction ( ) { 
 - checkThread ( ) ; 
 + assertThread ( ) ; 
 transaction . rollbackAndContinueAsRead ( ) ; 
 } 
 
 diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java 
 index 335ee7f . . 524a4d2 100644 
 - - - a / realm / src / main / java / io / realm / RealmObject . java 
 + + + b / realm / src / main / java / io / realm / RealmObject . java 
 @ @ - 44 , 6 + 44 , 7 @ @ public abstract class RealmObject { 
 * performed on it will fail with an IllegalStateException 
 * / 
 public void removeFromRealm ( ) { 
 + 
 if ( row = = null ) { 
 throw new IllegalStateException ( " Object malformed : missing object in Realm . Make sure to instantiate RealmObjects with Realm . createObject ( ) " ) ; 
 } 
 diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java 
 index 5f0059a . . f1148f2 100644 
 - - - a / realm / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / src / main / java / io / realm / RealmResults . java 
 @ @ - 83 , 7 + 83 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ see io . realm . RealmQuery 
 * / 
 public RealmQuery < E > where ( ) { 
 - realm . checkThread ( ) ; 
 + realm . assertThread ( ) ; 
 return new RealmQuery < E > ( this , classSpec ) ; 
 } 
 
 @ @ - 94 , 7 + 94 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 @ Override 
 public E get ( int rowIndex ) { 
 E obj ; 
 - realm . checkThread ( ) ; 
 + realm . assertThread ( ) ; 
 TableOrView table = getTable ( ) ; 
 if ( table instanceof TableView ) { 
 obj = realm . get ( classSpec , ( ( TableView ) table ) . getSourceRowIndex ( rowIndex ) ) ; 
 @ @ - 147 , 7 + 147 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 public RealmResults < E > sort ( String fieldName , boolean sortAscending ) { 
 TableView sorted ; 
 
 - realm . checkThread ( ) ; 
 + realm . assertThread ( ) ; 
 TableOrView table = getTable ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 TableView . Order TVOrder = sortAscending ? TableView . Order . ascending : TableView . Order . descending ; 
 @ @ - 185 , 7 + 185 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if field is not int , float or double . 
 * / 
 public Number min ( String fieldName ) { 
 - realm . checkThread ( ) ; 
 + realm . assertThread ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 switch ( table . getColumnType ( columnIndex ) ) { 
 case INTEGER : 
 @ @ - 208 , 7 + 208 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . 
 * / 
 public Date minDate ( String fieldName ) { 
 - realm . checkThread ( ) ; 
 + realm . assertThread ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 if ( table . getColumnType ( columnIndex ) = = ColumnType . DATE ) { 
 return table . minimumDate ( columnIndex ) ; 
 @ @ - 226 , 7 + 226 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if field is not int , float or double . 
 * / 
 public Number max ( String fieldName ) { 
 - realm . checkThread ( ) ; 
 + realm . assertThread ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 switch ( table . getColumnType ( columnIndex ) ) { 
 case INTEGER : 
 @ @ - 249 , 7 + 249 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . 
 * / 
 public Date maxDate ( String fieldName ) { 
 - realm . checkThread ( ) ; 
 + realm . assertThread ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 if ( table . getColumnType ( columnIndex ) = = ColumnType . DATE ) { 
 return table . minimumDate ( columnIndex ) ; 
 @ @ - 269 , 7 + 269 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * / 
 
 public Number sum ( String fieldName ) { 
 - realm . checkThread ( ) ; 
 + realm . assertThread ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 switch ( table . getColumnType ( columnIndex ) ) { 
 case INTEGER : 
 @ @ - 294 , 7 + 294 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if field is not int , float or double . 
 * / 
 public double average ( String fieldName ) { 
 - realm . checkThread ( ) ; 
 + realm . assertThread ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 switch ( table . getColumnType ( columnIndex ) ) { 
 case INTEGER :
