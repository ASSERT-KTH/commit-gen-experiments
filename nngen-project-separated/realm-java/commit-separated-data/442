BLEU SCORE: 0.0208362582256928

TEST MSG: Implement RealmObject . isLoaded ( )
GENERATED MSG: now RealmQuery throw exception if reused for another async query

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java <nl> index 4699a1a . . cf8329d 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java <nl> @ @ - 356 , 6 + 356 , 7 @ @ public class DynamicRealmTests { <nl> final DynamicRealmObject allTypes = dynamicRealm . where ( AllTypes . CLASS _ NAME ) <nl> . between ( AllTypes . FIELD _ LONG , 4 , 9 ) <nl> . findFirstAsync ( ) ; <nl> + assertFalse ( allTypes . isLoaded ( ) ) ; <nl> looperThread . keepStrongReference . add ( allTypes ) ; <nl> allTypes . addChangeListener ( new RealmChangeListener < DynamicRealmObject > ( ) { <nl> @ Override <nl> @ @ - 396 , 6 + 397 , 7 @ @ public class DynamicRealmTests { <nl> final RealmResults < DynamicRealmObject > allTypes = dynamicRealm . where ( AllTypes . CLASS _ NAME ) <nl> . between ( AllTypes . FIELD _ LONG , 0 , 4 ) <nl> . findAllSorted ( AllTypes . FIELD _ STRING , Sort . DESCENDING ) ; <nl> + assertFalse ( allTypes . isLoaded ( ) ) ; <nl> <nl> allTypes . addChangeListener ( new RealmChangeListener < RealmResults < DynamicRealmObject > > ( ) { <nl> @ Override <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> index d0a8006 . . 49e2237 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> @ @ - 158 , 6 + 158 , 10 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> } ) ; <nl> } <nl> <nl> + public boolean isLoaded ( ) { <nl> + return ! ( row instanceof PendingRow ) ; <nl> + } <nl> + <nl> @ Override <nl> public void onQueryFinished ( Row row ) { <nl> this . row = row ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmObject . java b / realm / realm - library / src / main / java / io / realm / RealmObject . java <nl> index 3cfe6d3 . . df0a903 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmObject . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmObject . java <nl> @ @ - 22 , 7 + 22 , 6 @ @ import io . realm . annotations . RealmClass ; <nl> import io . realm . internal . InvalidRow ; <nl> import io . realm . internal . RealmObjectProxy ; <nl> import io . realm . internal . Row ; <nl> - import io . realm . internal . SharedRealm ; <nl> import rx . Observable ; <nl> <nl> / * * <nl> @ @ - 151 , 26 + 150 , 92 @ @ public abstract class RealmObject implements RealmModel { <nl> } <nl> <nl> / * * <nl> - * @ deprecated <nl> - * @ return { @ code true } always . <nl> + * Checks if the query used to find this RealmObject has completed . <nl> + * <nl> + * Async methods like { @ link RealmQuery # findFirstAsync ( ) } return an { @ link RealmObject } that represents the future result <nl> + * of the { @ link RealmQuery } . It can be considered similar to a { @ link java . util . concurrent . Future } in this regard . <nl> + * <nl> + * Once { @ code isLoaded ( ) } returns { @ code true } , the object represents the query result even if the query <nl> + * didn ' t find any object matching the query parameters . In this case the { @ link RealmObject } will <nl> + * become a " null " object . <nl> + * <nl> + * " Null " objects represents { @ code null } . An exception is throw if any accessor is called , so it is important to also <nl> + * check { @ link # isValid ( ) } before calling any methods . A common pattern is : <nl> + * <nl> + * < pre > <nl> + * { @ code <nl> + * Person person = realm . where ( Person . class ) . findFirstAsync ( ) ; <nl> + * person . isLoaded ( ) ; / / = = false <nl> + * person . addChangeListener ( new RealmChangeListener ( ) { <nl> + * \ @ Override <nl> + * public void onChange ( Person person ) { <nl> + * person . isLoaded ( ) ; / / Always true here <nl> + * if ( person . isValid ( ) ) { <nl> + * / / It is safe to access the person . <nl> + * } <nl> + * } <nl> + * } ) ; <nl> + * } <nl> + * < / pre > <nl> + * <nl> + * Synchronous RealmObjects are by definition blocking hence this method will always return { @ code true } for them . <nl> + * This method will return { @ code true } if called on an unmanaged object ( created outside of Realm ) . <nl> + * <nl> + * @ return { @ code true } if the query has completed , { @ code false } if the query is in <nl> + * progress . <nl> * <nl> * @ see # isValid ( ) <nl> * / <nl> public final boolean isLoaded ( ) { <nl> - / / noinspection deprecation <nl> return RealmObject . isLoaded ( this ) ; <nl> } <nl> <nl> <nl> / * * <nl> - * @ deprecated <nl> + * Checks if the query used to find this RealmObject has completed . <nl> + * <nl> + * Async methods like { @ link RealmQuery # findFirstAsync ( ) } return an { @ link RealmObject } that represents the future result <nl> + * of the { @ link RealmQuery } . It can be considered similar to a { @ link java . util . concurrent . Future } in this regard . <nl> + * <nl> + * Once { @ code isLoaded ( ) } returns { @ code true } , the object represents the query result even if the query <nl> + * didn ' t find any object matching the query parameters . In this case the { @ link RealmObject } will <nl> + * become a " null " object . <nl> + * <nl> + * " Null " objects represents { @ code null } . An exception is throw if any accessor is called , so it is important to also <nl> + * check { @ link # isValid ( ) } before calling any methods . A common pattern is : <nl> + * <nl> + * < pre > <nl> + * { @ code <nl> + * Person person = realm . where ( Person . class ) . findFirstAsync ( ) ; <nl> + * RealmObject . isLoaded ( person ) ; / / = = false <nl> + * RealmObject . addChangeListener ( person , new RealmChangeListener ( ) { <nl> + * \ @ Override <nl> + * public void onChange ( Person person ) { <nl> + * RealmObject . isLoaded ( person ) ; / / always true here <nl> + * if ( RealmObject . isValid ( person ) ) { <nl> + * / / It is safe to access the person . <nl> + * } <nl> + * } <nl> + * } ) ; <nl> + * } <nl> + * < / pre > <nl> + * <nl> + * Synchronous RealmObjects are by definition blocking hence this method will always return { @ code true } for them . <nl> + * This method will return { @ code true } if called on an unmanaged object ( created outside of Realm ) . <nl> + * <nl> + * <nl> * @ param object RealmObject to check . <nl> - * @ return { @ code true } always . <nl> + * @ return { @ code true } if the query has completed , { @ code false } if the query is in <nl> + * progress . <nl> * <nl> * @ see # isValid ( RealmModel ) <nl> * / <nl> - @ SuppressWarnings ( " UnusedParameters " ) <nl> public static < E extends RealmModel > boolean isLoaded ( E object ) { <nl> + if ( object instanceof RealmObjectProxy ) { <nl> + RealmObjectProxy proxy = ( RealmObjectProxy ) object ; <nl> + proxy . realmGet $ proxyState ( ) . getRealm $ realm ( ) . checkIfValid ( ) ; <nl> + return proxy . realmGet $ proxyState ( ) . isLoaded ( ) ; <nl> + } <nl> return true ; <nl> } <nl> <nl> @ @ - 221 , 11 + 286 , 8 @ @ public abstract class RealmObject implements RealmModel { <nl> } <nl> <nl> / * * <nl> - * Makes an asynchronous query blocking . This will also trigger any registered listeners . <nl> - * < p > <nl> - * Note : This will return { @ code true } if called for an unmanaged object ( created outside of Realm ) . <nl> - * <nl> - * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> + * @ return { @ code true } if this is a managed object . <nl> + * @ deprecated see < a href = RealmQuery . html # async - query > Async Queries < / a > for more information . <nl> * / <nl> public final boolean load ( ) { <nl> / / noinspection deprecation <nl> @ @ - 233 , 7 + 295 , 8 @ @ public abstract class RealmObject implements RealmModel { <nl> } <nl> <nl> / * * <nl> - * @ deprecated <nl> + * @ return { @ code true } if this is a managed object . <nl> + * @ deprecated see < a href = RealmQuery . html # async - query > Async Queries < / a > for more information . <nl> * / <nl> public static < E extends RealmModel > boolean load ( E object ) { <nl> return object instanceof RealmObjectProxy ;
NEAREST DIFF (one line): diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index a7cd9ec . . 92cf096 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 268 , 6 + 268 , 70 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } <nl> <nl> + public void testResusingQuery ( ) throws Throwable { <nl> + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> + final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> + final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + executorService . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + backgroundLooper [ 0 ] = Looper . myLooper ( ) ; <nl> + <nl> + Realm realm = null ; <nl> + try { <nl> + realm = openRealmInstance ( " testResusingQuery " ) ; <nl> + populateTestRealm ( realm , 10 ) ; <nl> + <nl> + RealmQuery < AllTypes > query = realm . where ( AllTypes . class ) <nl> + . between ( " columnLong " , 0 , 4 ) ; <nl> + RealmResults < AllTypes > queryAllSync = query . findAll ( ) ; <nl> + RealmResults < AllTypes > allAsync = query . findAllAsync ( ) ; <nl> + <nl> + assertTrue ( allAsync . load ( ) ) ; <nl> + assertEquals ( allAsync , queryAllSync ) ; <nl> + <nl> + / / the RealmQuery already has an argumentHolder , can ' t reuse it <nl> + try { <nl> + RealmResults < AllTypes > allAsyncSorted = query . findAllSorted ( " columnLong " ) ; <nl> + fail ( " Should throw an exception , can not reuse RealmQuery " ) ; <nl> + } catch ( IllegalStateException ignored ) { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + <nl> + Looper . loop ( ) ; <nl> + <nl> + } catch ( Exception e ) { <nl> + e . printStackTrace ( ) ; <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + if ( signalCallbackFinished . getCount ( ) > 0 ) { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + if ( realm ! = null ) { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + / / wait until the callback of our async query proceed <nl> + TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> + <nl> + executorService . shutdownNow ( ) ; <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + if ( backgroundLooper [ 0 ] ! = null ) { <nl> + / / failing to quit the looper will not execute the finally block responsible <nl> + / / of closing the Realm <nl> + backgroundLooper [ 0 ] . quit ( ) ; <nl> + } <nl> + } <nl> + <nl> / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded <nl> / / using a callback to be notified when the data is loaded <nl> public void testFindAllAsyncWithNotification ( ) throws Throwable { <nl> @ @ - 1182 , 10 + 1246 , 11 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> assertEquals ( " " , realmResults . getColumnString ( ) ) ; <nl> <nl> Realm . asyncQueryExecutor . resume ( ) ; <nl> - realmResults . load ( ) ; <nl> <nl> + assertTrue ( realmResults . load ( ) ) ; <nl> assertTrue ( realmResults . isLoaded ( ) ) ; <nl> assertEquals ( " test data 4 " , realmResults . getColumnString ( ) ) ; <nl> + <nl> signalCallbackFinished . countDown ( ) ; <nl> Looper . loop ( ) ; <nl> <nl> diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java <nl> index c6d61a1 . . a865d36 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmObject . java <nl> + + + b / realm / src / main / java / io / realm / RealmObject . java <nl> @ @ - 178 , 16 + 178 , 13 @ @ public abstract class RealmObject { <nl> * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> * / <nl> public boolean load ( ) { <nl> - if ( realm = = null ) { <nl> + if ( isLoaded ( ) ) { <nl> return true ; <nl> - } <nl> - / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) <nl> - / / in this case the Realm # handler will be responsible for retrying <nl> - realm . checkIfValid ( ) ; <nl> - if ( pendingQuery ! = null & & ! pendingQuery . isDone ( ) & & ! isCompleted ) { <nl> + } else { <nl> + / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) <nl> + / / in this case the Realm # handler will be responsible of retrying <nl> return onCompleted ( ) ; <nl> } <nl> - return false ; <nl> } <nl> <nl> / * * <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index cd6c29f . . 6a9fbe0 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1432 , 6 + 1432 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * @ see io . realm . RealmResults <nl> * / <nl> public RealmResults < E > findAllAsync ( ) { <nl> + checkQueryIsNotReused ( ) ; <nl> final WeakReference < Handler > weakHandler = getWeakReferenceHandler ( ) ; <nl> <nl> / / handover the query ( to be used by a worker thread ) <nl> @ @ - 1465 , 7 + 1466 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> / / Run the query & handover the table view for the caller thread <nl> / / Note : the handoverQueryPointer contains the versionID needed by the SG in order <nl> / / to import it . <nl> - long handoverTableViewPointer = query . findAllWithHandover ( sharedGroup . getNativePointer ( ) , sharedGroup . getNativeReplicationPointer ( ) , handoverQueryPointer ) ; <nl> + long handoverTableViewPointer = query . findAllWithHandover ( sharedGroup . getNativePointer ( ) , sharedGroup . getNativeReplicationPointer ( ) , handoverQueryPointer ) ; <nl> <nl> QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmResultsResponse ( ) ; <nl> result . updatedTableViews . put ( weakRealmResults , handoverTableViewPointer ) ; <nl> @ @ - 1532 , 6 + 1533 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * @ throws java . lang . IllegalArgumentException if field name does not exist . <nl> * / <nl> public RealmResults < E > findAllSortedAsync ( String fieldName , boolean sortAscending ) { <nl> + checkQueryIsNotReused ( ) ; <nl> final TableView . Order order = sortAscending ? TableView . Order . ascending : TableView . Order . descending ; <nl> final Long columnIndex = columns . get ( fieldName ) ; <nl> if ( columnIndex = = null | | columnIndex < 0 ) { <nl> @ @ - 1678 , 6 + 1680 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * @ see io . realm . RealmResults <nl> * / <nl> public RealmResults < E > findAllSortedAsync ( String fieldNames [ ] , final boolean [ ] sortAscending ) { <nl> + checkQueryIsNotReused ( ) ; <nl> checkSortParameters ( fieldNames , sortAscending ) ; <nl> <nl> if ( fieldNames . length = = 1 & & sortAscending . length = = 1 ) { <nl> @ @ - 1776 , 7 + 1779 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * / <nl> public RealmResults < E > findAllSorted ( String fieldName1 , boolean sortAscending1 , <nl> String fieldName2 , boolean sortAscending2 ) { <nl> - return findAllSorted ( new String [ ] { fieldName1 , fieldName2 } , new boolean [ ] { sortAscending1 , sortAscending2 } ) ; <nl> + return findAllSorted ( new String [ ] { fieldName1 , fieldName2 } , new boolean [ ] { sortAscending1 , sortAscending2 } ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 1855 , 6 + 1858 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * { @ link io . realm . RealmObject # addChangeListener } to be notified when the query completes . <nl> * / <nl> public E findFirstAsync ( ) { <nl> + checkQueryIsNotReused ( ) ; <nl> final WeakReference < Handler > weakHandler = getWeakReferenceHandler ( ) ; <nl> <nl> / / handover the query ( to be used by a worker thread ) <nl> @ @ - 1938 , 6 + 1942 , 16 @ @ public class RealmQuery < E extends RealmObject > { <nl> return new WeakReference < Handler > ( realm . handler ) ; / / use caller Realm ' s Looper <nl> } <nl> <nl> + / / We need to prevent the user from using the query again ( mostly for async ) <nl> + / / Ex : if the first query fail with findFirstAsync , if the user reuse the same RealmQuery <nl> + / / with findAllSorted , argumentsHolder of the first query will be overridden , <nl> + / / which cause any retry to use the findAllSorted argumentsHolder . <nl> + private void checkQueryIsNotReused ( ) { <nl> + if ( argumentsHolder ! = null ) { <nl> + throw new IllegalStateException ( " This RealmQuery is already used by a find * query , please create a new query " ) ; <nl> + } <nl> + } <nl> + <nl> public ArgumentsHolder getArgument ( ) { <nl> return argumentsHolder ; <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java <nl> index e667bf1 . . fbc37ac 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / src / main / java / io / realm / RealmResults . java <nl> @ @ - 721 , 16 + 721 , 13 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> * / <nl> public boolean load ( ) { <nl> - if ( realm = = null ) { <nl> + if ( isLoaded ( ) ) { <nl> return true ; <nl> - } <nl> + } else { <nl> / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) <nl> / / in this case the Realm # handler will be responsible of retrying <nl> - realm . checkIfValid ( ) ; <nl> - if ( pendingQuery ! = null & & ! pendingQuery . isDone ( ) ) { <nl> return onCompleted ( ) ; <nl> } <nl> - return false ; <nl> } <nl> <nl> / * *

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java 
 index 4699a1a . . cf8329d 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java 
 @ @ - 356 , 6 + 356 , 7 @ @ public class DynamicRealmTests { 
 final DynamicRealmObject allTypes = dynamicRealm . where ( AllTypes . CLASS _ NAME ) 
 . between ( AllTypes . FIELD _ LONG , 4 , 9 ) 
 . findFirstAsync ( ) ; 
 + assertFalse ( allTypes . isLoaded ( ) ) ; 
 looperThread . keepStrongReference . add ( allTypes ) ; 
 allTypes . addChangeListener ( new RealmChangeListener < DynamicRealmObject > ( ) { 
 @ Override 
 @ @ - 396 , 6 + 397 , 7 @ @ public class DynamicRealmTests { 
 final RealmResults < DynamicRealmObject > allTypes = dynamicRealm . where ( AllTypes . CLASS _ NAME ) 
 . between ( AllTypes . FIELD _ LONG , 0 , 4 ) 
 . findAllSorted ( AllTypes . FIELD _ STRING , Sort . DESCENDING ) ; 
 + assertFalse ( allTypes . isLoaded ( ) ) ; 
 
 allTypes . addChangeListener ( new RealmChangeListener < RealmResults < DynamicRealmObject > > ( ) { 
 @ Override 
 diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 index d0a8006 . . 49e2237 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 @ @ - 158 , 6 + 158 , 10 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 } ) ; 
 } 
 
 + public boolean isLoaded ( ) { 
 + return ! ( row instanceof PendingRow ) ; 
 + } 
 + 
 @ Override 
 public void onQueryFinished ( Row row ) { 
 this . row = row ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmObject . java b / realm / realm - library / src / main / java / io / realm / RealmObject . java 
 index 3cfe6d3 . . df0a903 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmObject . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmObject . java 
 @ @ - 22 , 7 + 22 , 6 @ @ import io . realm . annotations . RealmClass ; 
 import io . realm . internal . InvalidRow ; 
 import io . realm . internal . RealmObjectProxy ; 
 import io . realm . internal . Row ; 
 - import io . realm . internal . SharedRealm ; 
 import rx . Observable ; 
 
 / * * 
 @ @ - 151 , 26 + 150 , 92 @ @ public abstract class RealmObject implements RealmModel { 
 } 
 
 / * * 
 - * @ deprecated 
 - * @ return { @ code true } always . 
 + * Checks if the query used to find this RealmObject has completed . 
 + * 
 + * Async methods like { @ link RealmQuery # findFirstAsync ( ) } return an { @ link RealmObject } that represents the future result 
 + * of the { @ link RealmQuery } . It can be considered similar to a { @ link java . util . concurrent . Future } in this regard . 
 + * 
 + * Once { @ code isLoaded ( ) } returns { @ code true } , the object represents the query result even if the query 
 + * didn ' t find any object matching the query parameters . In this case the { @ link RealmObject } will 
 + * become a " null " object . 
 + * 
 + * " Null " objects represents { @ code null } . An exception is throw if any accessor is called , so it is important to also 
 + * check { @ link # isValid ( ) } before calling any methods . A common pattern is : 
 + * 
 + * < pre > 
 + * { @ code 
 + * Person person = realm . where ( Person . class ) . findFirstAsync ( ) ; 
 + * person . isLoaded ( ) ; / / = = false 
 + * person . addChangeListener ( new RealmChangeListener ( ) { 
 + * \ @ Override 
 + * public void onChange ( Person person ) { 
 + * person . isLoaded ( ) ; / / Always true here 
 + * if ( person . isValid ( ) ) { 
 + * / / It is safe to access the person . 
 + * } 
 + * } 
 + * } ) ; 
 + * } 
 + * < / pre > 
 + * 
 + * Synchronous RealmObjects are by definition blocking hence this method will always return { @ code true } for them . 
 + * This method will return { @ code true } if called on an unmanaged object ( created outside of Realm ) . 
 + * 
 + * @ return { @ code true } if the query has completed , { @ code false } if the query is in 
 + * progress . 
 * 
 * @ see # isValid ( ) 
 * / 
 public final boolean isLoaded ( ) { 
 - / / noinspection deprecation 
 return RealmObject . isLoaded ( this ) ; 
 } 
 
 
 / * * 
 - * @ deprecated 
 + * Checks if the query used to find this RealmObject has completed . 
 + * 
 + * Async methods like { @ link RealmQuery # findFirstAsync ( ) } return an { @ link RealmObject } that represents the future result 
 + * of the { @ link RealmQuery } . It can be considered similar to a { @ link java . util . concurrent . Future } in this regard . 
 + * 
 + * Once { @ code isLoaded ( ) } returns { @ code true } , the object represents the query result even if the query 
 + * didn ' t find any object matching the query parameters . In this case the { @ link RealmObject } will 
 + * become a " null " object . 
 + * 
 + * " Null " objects represents { @ code null } . An exception is throw if any accessor is called , so it is important to also 
 + * check { @ link # isValid ( ) } before calling any methods . A common pattern is : 
 + * 
 + * < pre > 
 + * { @ code 
 + * Person person = realm . where ( Person . class ) . findFirstAsync ( ) ; 
 + * RealmObject . isLoaded ( person ) ; / / = = false 
 + * RealmObject . addChangeListener ( person , new RealmChangeListener ( ) { 
 + * \ @ Override 
 + * public void onChange ( Person person ) { 
 + * RealmObject . isLoaded ( person ) ; / / always true here 
 + * if ( RealmObject . isValid ( person ) ) { 
 + * / / It is safe to access the person . 
 + * } 
 + * } 
 + * } ) ; 
 + * } 
 + * < / pre > 
 + * 
 + * Synchronous RealmObjects are by definition blocking hence this method will always return { @ code true } for them . 
 + * This method will return { @ code true } if called on an unmanaged object ( created outside of Realm ) . 
 + * 
 + * 
 * @ param object RealmObject to check . 
 - * @ return { @ code true } always . 
 + * @ return { @ code true } if the query has completed , { @ code false } if the query is in 
 + * progress . 
 * 
 * @ see # isValid ( RealmModel ) 
 * / 
 - @ SuppressWarnings ( " UnusedParameters " ) 
 public static < E extends RealmModel > boolean isLoaded ( E object ) { 
 + if ( object instanceof RealmObjectProxy ) { 
 + RealmObjectProxy proxy = ( RealmObjectProxy ) object ; 
 + proxy . realmGet $ proxyState ( ) . getRealm $ realm ( ) . checkIfValid ( ) ; 
 + return proxy . realmGet $ proxyState ( ) . isLoaded ( ) ; 
 + } 
 return true ; 
 } 
 
 @ @ - 221 , 11 + 286 , 8 @ @ public abstract class RealmObject implements RealmModel { 
 } 
 
 / * * 
 - * Makes an asynchronous query blocking . This will also trigger any registered listeners . 
 - * < p > 
 - * Note : This will return { @ code true } if called for an unmanaged object ( created outside of Realm ) . 
 - * 
 - * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 + * @ return { @ code true } if this is a managed object . 
 + * @ deprecated see < a href = RealmQuery . html # async - query > Async Queries < / a > for more information . 
 * / 
 public final boolean load ( ) { 
 / / noinspection deprecation 
 @ @ - 233 , 7 + 295 , 8 @ @ public abstract class RealmObject implements RealmModel { 
 } 
 
 / * * 
 - * @ deprecated 
 + * @ return { @ code true } if this is a managed object . 
 + * @ deprecated see < a href = RealmQuery . html # async - query > Async Queries < / a > for more information . 
 * / 
 public static < E extends RealmModel > boolean load ( E object ) { 
 return object instanceof RealmObjectProxy ;

NEAREST DIFF:
diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index a7cd9ec . . 92cf096 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 268 , 6 + 268 , 70 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } 
 
 + public void testResusingQuery ( ) throws Throwable { 
 + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 + final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 + final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + executorService . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + backgroundLooper [ 0 ] = Looper . myLooper ( ) ; 
 + 
 + Realm realm = null ; 
 + try { 
 + realm = openRealmInstance ( " testResusingQuery " ) ; 
 + populateTestRealm ( realm , 10 ) ; 
 + 
 + RealmQuery < AllTypes > query = realm . where ( AllTypes . class ) 
 + . between ( " columnLong " , 0 , 4 ) ; 
 + RealmResults < AllTypes > queryAllSync = query . findAll ( ) ; 
 + RealmResults < AllTypes > allAsync = query . findAllAsync ( ) ; 
 + 
 + assertTrue ( allAsync . load ( ) ) ; 
 + assertEquals ( allAsync , queryAllSync ) ; 
 + 
 + / / the RealmQuery already has an argumentHolder , can ' t reuse it 
 + try { 
 + RealmResults < AllTypes > allAsyncSorted = query . findAllSorted ( " columnLong " ) ; 
 + fail ( " Should throw an exception , can not reuse RealmQuery " ) ; 
 + } catch ( IllegalStateException ignored ) { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + 
 + Looper . loop ( ) ; 
 + 
 + } catch ( Exception e ) { 
 + e . printStackTrace ( ) ; 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + if ( signalCallbackFinished . getCount ( ) > 0 ) { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + if ( realm ! = null ) { 
 + realm . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + / / wait until the callback of our async query proceed 
 + TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 + 
 + executorService . shutdownNow ( ) ; 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + if ( backgroundLooper [ 0 ] ! = null ) { 
 + / / failing to quit the looper will not execute the finally block responsible 
 + / / of closing the Realm 
 + backgroundLooper [ 0 ] . quit ( ) ; 
 + } 
 + } 
 + 
 / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded 
 / / using a callback to be notified when the data is loaded 
 public void testFindAllAsyncWithNotification ( ) throws Throwable { 
 @ @ - 1182 , 10 + 1246 , 11 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 assertEquals ( " " , realmResults . getColumnString ( ) ) ; 
 
 Realm . asyncQueryExecutor . resume ( ) ; 
 - realmResults . load ( ) ; 
 
 + assertTrue ( realmResults . load ( ) ) ; 
 assertTrue ( realmResults . isLoaded ( ) ) ; 
 assertEquals ( " test data 4 " , realmResults . getColumnString ( ) ) ; 
 + 
 signalCallbackFinished . countDown ( ) ; 
 Looper . loop ( ) ; 
 
 diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java 
 index c6d61a1 . . a865d36 100644 
 - - - a / realm / src / main / java / io / realm / RealmObject . java 
 + + + b / realm / src / main / java / io / realm / RealmObject . java 
 @ @ - 178 , 16 + 178 , 13 @ @ public abstract class RealmObject { 
 * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 * / 
 public boolean load ( ) { 
 - if ( realm = = null ) { 
 + if ( isLoaded ( ) ) { 
 return true ; 
 - } 
 - / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) 
 - / / in this case the Realm # handler will be responsible for retrying 
 - realm . checkIfValid ( ) ; 
 - if ( pendingQuery ! = null & & ! pendingQuery . isDone ( ) & & ! isCompleted ) { 
 + } else { 
 + / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) 
 + / / in this case the Realm # handler will be responsible of retrying 
 return onCompleted ( ) ; 
 } 
 - return false ; 
 } 
 
 / * * 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index cd6c29f . . 6a9fbe0 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1432 , 6 + 1432 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * @ see io . realm . RealmResults 
 * / 
 public RealmResults < E > findAllAsync ( ) { 
 + checkQueryIsNotReused ( ) ; 
 final WeakReference < Handler > weakHandler = getWeakReferenceHandler ( ) ; 
 
 / / handover the query ( to be used by a worker thread ) 
 @ @ - 1465 , 7 + 1466 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 / / Run the query & handover the table view for the caller thread 
 / / Note : the handoverQueryPointer contains the versionID needed by the SG in order 
 / / to import it . 
 - long handoverTableViewPointer = query . findAllWithHandover ( sharedGroup . getNativePointer ( ) , sharedGroup . getNativeReplicationPointer ( ) , handoverQueryPointer ) ; 
 + long handoverTableViewPointer = query . findAllWithHandover ( sharedGroup . getNativePointer ( ) , sharedGroup . getNativeReplicationPointer ( ) , handoverQueryPointer ) ; 
 
 QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmResultsResponse ( ) ; 
 result . updatedTableViews . put ( weakRealmResults , handoverTableViewPointer ) ; 
 @ @ - 1532 , 6 + 1533 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * @ throws java . lang . IllegalArgumentException if field name does not exist . 
 * / 
 public RealmResults < E > findAllSortedAsync ( String fieldName , boolean sortAscending ) { 
 + checkQueryIsNotReused ( ) ; 
 final TableView . Order order = sortAscending ? TableView . Order . ascending : TableView . Order . descending ; 
 final Long columnIndex = columns . get ( fieldName ) ; 
 if ( columnIndex = = null | | columnIndex < 0 ) { 
 @ @ - 1678 , 6 + 1680 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * @ see io . realm . RealmResults 
 * / 
 public RealmResults < E > findAllSortedAsync ( String fieldNames [ ] , final boolean [ ] sortAscending ) { 
 + checkQueryIsNotReused ( ) ; 
 checkSortParameters ( fieldNames , sortAscending ) ; 
 
 if ( fieldNames . length = = 1 & & sortAscending . length = = 1 ) { 
 @ @ - 1776 , 7 + 1779 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * / 
 public RealmResults < E > findAllSorted ( String fieldName1 , boolean sortAscending1 , 
 String fieldName2 , boolean sortAscending2 ) { 
 - return findAllSorted ( new String [ ] { fieldName1 , fieldName2 } , new boolean [ ] { sortAscending1 , sortAscending2 } ) ; 
 + return findAllSorted ( new String [ ] { fieldName1 , fieldName2 } , new boolean [ ] { sortAscending1 , sortAscending2 } ) ; 
 } 
 
 / * * 
 @ @ - 1855 , 6 + 1858 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * { @ link io . realm . RealmObject # addChangeListener } to be notified when the query completes . 
 * / 
 public E findFirstAsync ( ) { 
 + checkQueryIsNotReused ( ) ; 
 final WeakReference < Handler > weakHandler = getWeakReferenceHandler ( ) ; 
 
 / / handover the query ( to be used by a worker thread ) 
 @ @ - 1938 , 6 + 1942 , 16 @ @ public class RealmQuery < E extends RealmObject > { 
 return new WeakReference < Handler > ( realm . handler ) ; / / use caller Realm ' s Looper 
 } 
 
 + / / We need to prevent the user from using the query again ( mostly for async ) 
 + / / Ex : if the first query fail with findFirstAsync , if the user reuse the same RealmQuery 
 + / / with findAllSorted , argumentsHolder of the first query will be overridden , 
 + / / which cause any retry to use the findAllSorted argumentsHolder . 
 + private void checkQueryIsNotReused ( ) { 
 + if ( argumentsHolder ! = null ) { 
 + throw new IllegalStateException ( " This RealmQuery is already used by a find * query , please create a new query " ) ; 
 + } 
 + } 
 + 
 public ArgumentsHolder getArgument ( ) { 
 return argumentsHolder ; 
 } 
 diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java 
 index e667bf1 . . fbc37ac 100644 
 - - - a / realm / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / src / main / java / io / realm / RealmResults . java 
 @ @ - 721 , 16 + 721 , 13 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 * / 
 public boolean load ( ) { 
 - if ( realm = = null ) { 
 + if ( isLoaded ( ) ) { 
 return true ; 
 - } 
 + } else { 
 / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) 
 / / in this case the Realm # handler will be responsible of retrying 
 - realm . checkIfValid ( ) ; 
 - if ( pendingQuery ! = null & & ! pendingQuery . isDone ( ) ) { 
 return onCompleted ( ) ; 
 } 
 - return false ; 
 } 
 
 / * *
