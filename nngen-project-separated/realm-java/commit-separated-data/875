BLEU SCORE: 0.05095335964988338

TEST MSG: Support for RealmQuery . isNotEmpty ( ) added
GENERATED MSG: Fixed bug where copyToRealm ( ) crashed when copying objects with primary key data .

TEST DIFF (one line): diff - - git a / realm / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> index 9eb8286 . . 92ffd10 100644 <nl> - - - a / realm / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> + + + b / realm / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> @ @ - 1865 , 3 + 1865 , 64 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsEmpty <nl> } <nl> } CATCH _ STD ( ) <nl> } <nl> + <nl> + JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNonEmpty <nl> + ( JNIEnv * env , jobject , jlong nativeQueryPtr , jlongArray columnIndexes ) { <nl> + <nl> + JniLongArray arr ( env , columnIndexes ) ; <nl> + jsize arr _ len = arr . len ( ) ; <nl> + Query * pQuery = Q ( nativeQueryPtr ) ; <nl> + try { <nl> + TableRef src _ table _ ref = getTableForLinkQuery ( nativeQueryPtr , arr ) ; <nl> + jlong column _ idx = arr [ arr _ len - 1 ] ; <nl> + TableRef table _ ref = getTableByArray ( nativeQueryPtr , arr ) ; <nl> + <nl> + int col _ type = table _ ref - > get _ column _ type ( S ( column _ idx ) ) ; <nl> + if ( arr _ len = = 1 ) { <nl> + / / Field queries <nl> + switch ( col _ type ) { <nl> + case type _ Binary : <nl> + pQuery - > not _ equal ( S ( column _ idx ) , BinaryData ( " " , 0 ) ) ; <nl> + break ; <nl> + case type _ LinkList : <nl> + pQuery - > and _ query ( table _ ref - > column < LinkList > ( S ( column _ idx ) ) . count ( ) ! = 0 ) ; <nl> + break ; <nl> + case type _ String : <nl> + pQuery - > not _ equal ( S ( column _ idx ) , " " ) ; <nl> + break ; <nl> + case type _ Link : <nl> + case type _ Bool : <nl> + case type _ Int : <nl> + case type _ Float : <nl> + case type _ Double : <nl> + case type _ DateTime : <nl> + default : <nl> + ThrowException ( env , IllegalArgument , " isNonEmpty ( ) only works on String , byte [ ] and RealmList . " ) ; <nl> + return ; <nl> + } <nl> + } <nl> + else { <nl> + / / Linked queries <nl> + switch ( col _ type ) { <nl> + case type _ Binary : <nl> + pQuery - > and _ query ( src _ table _ ref - > column < Binary > ( S ( column _ idx ) ) ! = BinaryData ( " " , 0 ) ) ; <nl> + break ; <nl> + case type _ LinkList : <nl> + pQuery - > and _ query ( src _ table _ ref - > column < LinkList > ( S ( column _ idx ) ) . count ( ) ! = 0 ) ; <nl> + break ; <nl> + case type _ String : <nl> + pQuery - > and _ query ( src _ table _ ref - > column < String > ( S ( column _ idx ) ) ! = " " ) ; <nl> + break ; <nl> + case type _ Link : <nl> + case type _ Bool : <nl> + case type _ Int : <nl> + case type _ Float : <nl> + case type _ Double : <nl> + case type _ DateTime : <nl> + default : <nl> + ThrowException ( env , IllegalArgument , " isNonEmpty ( ) only works on String , byte [ ] and RealmList across links . " ) ; <nl> + return ; <nl> + } <nl> + } <nl> + } CATCH _ STD ( ) <nl> + } <nl> diff - - git a / realm / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> index caf030b . . 6fb329f 100644 <nl> - - - a / realm / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> + + + b / realm / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> @ @ - 561 , 6 + 561 , 14 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsEmpty <nl> <nl> / * <nl> * Class : io _ realm _ internal _ TableQuery <nl> + * Method : nativeIsNonEmpty <nl> + * Signature : ( J [ J ) V <nl> + * / <nl> + JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNonEmpty <nl> + ( JNIEnv * , jobject , jlong , jlongArray ) ; <nl> + <nl> + / * <nl> + * Class : io _ realm _ internal _ TableQuery <nl> * Method : nativeIsNotNull <nl> * Signature : ( J [ J ) V <nl> * / <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTest . java <nl> index e71333f . . 97012a9 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTest . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTest . java <nl> @ @ - 1655 , 6 + 1655 , 124 @ @ public class RealmQueryTest extends AndroidTestCase { <nl> } <nl> } <nl> <nl> + / / non - empty test harnesses <nl> + private static final List < RealmFieldType > SUPPORTED _ IS _ NONEMPTY _ TYPES = Arrays . asList ( <nl> + RealmFieldType . STRING , <nl> + RealmFieldType . BINARY , <nl> + RealmFieldType . LIST ) ; <nl> + <nl> + private static final List < RealmFieldType > NOT _ SUPPORTED _ IS _ NONEMPTY _ TYPES ; <nl> + static { <nl> + final ArrayList < RealmFieldType > list = new ArrayList < RealmFieldType > ( Arrays . asList ( RealmFieldType . values ( ) ) ) ; <nl> + list . removeAll ( SUPPORTED _ IS _ NONEMPTY _ TYPES ) ; <nl> + list . remove ( RealmFieldType . UNSUPPORTED _ MIXED ) ; <nl> + list . remove ( RealmFieldType . UNSUPPORTED _ TABLE ) ; <nl> + NOT _ SUPPORTED _ IS _ NONEMPTY _ TYPES = list ; <nl> + } <nl> + <nl> + private void createIsNonEmptyDataSet ( Realm realm ) { <nl> + realm . beginTransaction ( ) ; <nl> + <nl> + AllJavaTypes emptyValues = new AllJavaTypes ( ) ; <nl> + emptyValues . setFieldLong ( 1 ) ; <nl> + emptyValues . setFieldString ( " " ) ; <nl> + emptyValues . setFieldBinary ( new byte [ 0 ] ) ; <nl> + emptyValues . setFieldObject ( emptyValues ) ; <nl> + emptyValues . setFieldList ( new RealmList < AllJavaTypes > ( ) ) ; <nl> + realm . copyToRealm ( emptyValues ) ; <nl> + <nl> + AllJavaTypes nonEmpty = new AllJavaTypes ( ) ; <nl> + nonEmpty . setFieldLong ( 2 ) ; <nl> + nonEmpty . setFieldString ( " Foo " ) ; <nl> + nonEmpty . setFieldBinary ( new byte [ ] { 1 , 2 , 3 } ) ; <nl> + nonEmpty . setFieldObject ( nonEmpty ) ; <nl> + nonEmpty . setFieldList ( new RealmList < AllJavaTypes > ( emptyValues ) ) ; <nl> + realm . copyToRealmOrUpdate ( nonEmpty ) ; <nl> + <nl> + realm . commitTransaction ( ) ; <nl> + } <nl> + <nl> + public void testIsNonEmpty ( ) { <nl> + createIsNonEmptyDataSet ( testRealm ) ; <nl> + for ( RealmFieldType type : SUPPORTED _ IS _ NONEMPTY _ TYPES ) { <nl> + switch ( type ) { <nl> + case STRING : <nl> + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ STRING ) . count ( ) ) ; <nl> + break ; <nl> + case BINARY : <nl> + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ BINARY ) . count ( ) ) ; <nl> + break ; <nl> + case LIST : <nl> + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ LIST ) . count ( ) ) ; <nl> + break ; <nl> + default : <nl> + fail ( " Unknown type : " + type ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public void testIsNonEmptyAcrossLink ( ) { <nl> + createIsNonEmptyDataSet ( testRealm ) ; <nl> + for ( RealmFieldType type : SUPPORTED _ IS _ NONEMPTY _ TYPES ) { <nl> + switch ( type ) { <nl> + case STRING : <nl> + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ STRING ) . count ( ) ) ; <nl> + break ; <nl> + case BINARY : <nl> + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) . count ( ) ) ; <nl> + break ; <nl> + case LIST : <nl> + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ LIST ) . count ( ) ) ; <nl> + break ; <nl> + default : <nl> + fail ( " Unknown type : " + type ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public void testIsNonEmptyIllegalFieldTypeThrows ( ) { <nl> + for ( RealmFieldType type : NOT _ SUPPORTED _ IS _ NONEMPTY _ TYPES ) { <nl> + try { <nl> + switch ( type ) { <nl> + case INTEGER : <nl> + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ LONG ) . findAll ( ) ; <nl> + break ; <nl> + case FLOAT : <nl> + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ FLOAT ) . findAll ( ) ; <nl> + break ; <nl> + case DOUBLE : <nl> + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ DOUBLE ) . findAll ( ) ; <nl> + break ; <nl> + case BOOLEAN : <nl> + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ BOOLEAN ) . findAll ( ) ; <nl> + break ; <nl> + case OBJECT : <nl> + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ OBJECT ) . findAll ( ) ; <nl> + break ; <nl> + case DATE : <nl> + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ DATE ) . findAll ( ) ; <nl> + break ; <nl> + default : <nl> + fail ( " Unknown type : " + type ) ; <nl> + } <nl> + fail ( type + " should throw an exception " ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + } <nl> + <nl> + public void testIsNonEmptyInvalidFieldNameThrows ( ) { <nl> + String [ ] fieldNames = new String [ ] { null , " " , " foo " , AllJavaTypes . FIELD _ OBJECT + " . foo " } ; <nl> + <nl> + for ( String fieldName : fieldNames ) { <nl> + try { <nl> + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( fieldName ) . findAll ( ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + } <nl> + <nl> / / Test that deep queries work on a lot of data <nl> public void testDeepLinkListQuery ( ) { <nl> testRealm . executeTransaction ( new Realm . Transaction ( ) { <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> index 0bd2c7c . . 08a4c0b 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1078 , 6 + 1078 , 20 @ @ public class RealmQuery < E extends RealmObject > { <nl> return this ; <nl> } <nl> <nl> + / * * <nl> + * Condition that find values that are considered " Non - empty " , i . e . a list , a string or a byte array with non - empty values . <nl> + * <nl> + * @ param fieldName the field to compare . <nl> + * @ return the query object . <nl> + * @ throws java . lang . IllegalArgumentException if the field name isn ' t valid or its type isn ' t either a RealmList , <nl> + * String or byte array . <nl> + * / <nl> + public RealmQuery < E > isNonEmpty ( String fieldName ) { <nl> + long columnIndices [ ] = schema . getColumnIndices ( fieldName , RealmFieldType . STRING , RealmFieldType . BINARY , RealmFieldType . LIST ) ; <nl> + this . query . isNonEmpty ( columnIndices ) ; <nl> + return this ; <nl> + } <nl> + <nl> / / Aggregates <nl> <nl> / / Sum <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java b / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java <nl> index b408ed4 . . 1e0a92e 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java <nl> @ @ - 411 , 6 + 411 , 12 @ @ public class TableQuery implements Closeable { <nl> return this ; <nl> } <nl> <nl> + public TableQuery isNonEmpty ( long [ ] columnIndices ) { <nl> + nativeIsNonEmpty ( nativePtr , columnIndices ) ; <nl> + queryValidated = false ; <nl> + return this ; <nl> + } <nl> + <nl> / / Searching methods . <nl> <nl> public long find ( long fromTableRow ) { <nl> @ @ - 774 , 6 + 780 , 7 @ @ public class TableQuery implements Closeable { <nl> private native void nativeEndsWith ( long nativeQueryPtr , long columnIndices [ ] , String value , boolean caseSensitive ) ; <nl> private native void nativeContains ( long nativeQueryPtr , long columnIndices [ ] , String value , boolean caseSensitive ) ; <nl> private native void nativeIsEmpty ( long nativePtr , long [ ] columnIndices ) ; <nl> + private native void nativeIsNonEmpty ( long nativePtr , long [ ] columnIndices ) ; <nl> private native long nativeFind ( long nativeQueryPtr , long fromTableRow ) ; <nl> private native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; <nl> private native long nativeSumInt ( long nativeQueryPtr , long columnIndex , long start , long end , long limit ) ;
NEAREST DIFF (one line): diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> index cd86320 . . 463cdce 100644 <nl> - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> @ @ - 506 , 7 + 506 , 11 @ @ public class RealmProxyClassGenerator { <nl> EnumSet . of ( Modifier . PUBLIC , Modifier . STATIC ) , / / Modifiers <nl> " Realm " , " realm " , className , " newObject " , " boolean " , " update " , " Map < RealmObject , RealmObject > " , " cache " ) ; / / Argument type & argument name <nl> <nl> - writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; <nl> + if ( metadata . hasPrimaryKey ( ) ) { <nl> + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class , newObject . % s ( ) ) " , className , className , metadata . getPrimaryKeyGetter ( ) ) ; <nl> + } else { <nl> + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; <nl> + } <nl> writer . emitStatement ( " cache . put ( newObject , realmObject ) " ) ; <nl> for ( VariableElement field : metadata . getFields ( ) ) { <nl> String fieldName = field . getSimpleName ( ) . toString ( ) ; <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index b87516d . . cd0e555 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 46 , 6 + 46 , 7 @ @ import io . realm . entities . NonLatinFieldNames ; <nl> import io . realm . entities . Owner ; <nl> import io . realm . entities . OwnerPrimaryKey ; <nl> import io . realm . entities . PrimaryKeyAsLong ; <nl> + import io . realm . entities . PrimaryKeyAsString ; <nl> import io . realm . entities . PrimaryKeyMix ; <nl> import io . realm . entities . StringOnly ; <nl> import io . realm . exceptions . RealmException ; <nl> @ @ - 1067 , 6 + 1068 , 26 @ @ public class RealmTest extends AndroidTestCase { <nl> assertArrayEquals ( new byte [ 0 ] , realmTypes . getColumnBinary ( ) ) ; <nl> } <nl> <nl> + / / Check that using copyToRealm will set the primary key directly instead of first setting <nl> + / / it to the default value ( which can fail ) <nl> + public void testCopyToRealmWithPrimaryKeySetValueDirectly ( ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . createObject ( OwnerPrimaryKey . class ) ; <nl> + testRealm . copyToRealm ( new OwnerPrimaryKey ( 1 , " Foo " ) ) ; <nl> + testRealm . commitTransaction ( ) ; <nl> + assertEquals ( 2 , testRealm . where ( OwnerPrimaryKey . class ) . count ( ) ) ; <nl> + } <nl> + <nl> + public void testCopyToRealmWithPrimaryAsNullThrows ( ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + try { <nl> + testRealm . copyToRealm ( new PrimaryKeyAsString ( ) ) ; <nl> + fail ( ) ; <nl> + } catch ( RealmException expected ) { <nl> + } finally { <nl> + testRealm . cancelTransaction ( ) ; <nl> + } <nl> + } <nl> <nl> public void testCopyToRealmList ( ) { <nl> Dog dog1 = new Dog ( ) ; <nl> @ @ - 1500 , 7 + 1521 , 6 @ @ public class RealmTest extends AndroidTestCase { <nl> fail ( ) ; <nl> } catch ( IllegalStateException ignored ) { <nl> } <nl> - <nl> } <nl> <nl> public void testUpdateObjectWithLinks ( ) throws Exception { <nl> diff - - git a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> index 3bba1b0 . . ce53189 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> + + + b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> @ @ - 26 , 6 + 26 , 13 @ @ public class PrimaryKeyAsString extends RealmObject { <nl> <nl> private long id ; <nl> <nl> + public PrimaryKeyAsString ( ) { <nl> + } <nl> + <nl> + public PrimaryKeyAsString ( String name ) { <nl> + this . name = name ; <nl> + } <nl> + <nl> public String getName ( ) { <nl> return name ; <nl> } <nl> diff - - git a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> index cbb78bf . . 3106ea9 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> + + + b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> @ @ - 36 , 7 + 36 , 24 @ @ public class JNITransactions extends AndroidTestCase { <nl> } <nl> } <nl> <nl> - <nl> + private Table getTableWithStringPrimaryKey ( ) { <nl> + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; <nl> + WriteTransaction trans = db . beginWrite ( ) ; <nl> + Table t = trans . getTable ( " TestTable " ) ; <nl> + t . addColumn ( ColumnType . STRING , " colName " ) ; <nl> + t . setPrimaryKey ( " colName " ) ; <nl> + return t ; <nl> + } <nl> + <nl> + private Table getTableWithIntegerPrimaryKey ( ) { <nl> + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; <nl> + WriteTransaction trans = db . beginWrite ( ) ; <nl> + Table t = trans . getTable ( " TestTable " ) ; <nl> + t . addColumn ( ColumnType . INTEGER , " colName " ) ; <nl> + t . setPrimaryKey ( " colName " ) ; <nl> + return t ; <nl> + } <nl> + <nl> private void createDBFileName ( ) { <nl> testFile = new File ( <nl> this . getContext ( ) . getFilesDir ( ) , <nl> @ @ - 319 , 24 + 336 , 44 @ @ public class JNITransactions extends AndroidTestCase { <nl> fail ( " Primary key not enforced . " ) ; <nl> } <nl> <nl> + public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( 42 ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> + } <nl> + } <nl> <nl> - <nl> - / * ARM Only works for Java 1 . 7 - NOT available in Android . <nl> - <nl> - @ Test ( enabled = true ) <nl> - public void mustReadARM ( ) { <nl> - writeOneTransaction ( 1 ) ; <nl> - <nl> - / / Read from table <nl> - / / System . out . println ( " mustReadARM . " ) ; <nl> - try ( ReadTransaction t = new ReadTransaction ( db ) ) { <nl> - EmployeeTable employees = new EmployeeTable ( t ) ; <nl> - assertEquals ( true , employees . isValid ( ) ) ; <nl> - assertEquals ( 1 , employees . size ( ) ) ; <nl> + public void testAddEmptyRowWithPrimaryKeyNullStringThrows ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( null ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> } <nl> - catch ( Throwable e ) { <nl> + } <nl> <nl> + public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows ( ) { <nl> + Table t = getTableWithIntegerPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( " Foo " ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> } <nl> } <nl> - * / <nl> + <nl> + public void testAddEmptyRowWithPrimaryKeyString ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + long rowIndex = t . addEmptyRowWithPrimaryKey ( " Foo " ) ; <nl> + assertEquals ( 1 , t . size ( ) ) ; <nl> + assertEquals ( " Foo " , t . getRow ( rowIndex ) . getString ( 0 ) ) ; <nl> + } <nl> + <nl> + public void testAddEmptyRowWithPrimaryKeyLong ( ) { <nl> + Table t = getTableWithIntegerPrimaryKey ( ) ; <nl> + long rowIndex = t . addEmptyRowWithPrimaryKey ( 42 ) ; <nl> + assertEquals ( 1 , t . size ( ) ) ; <nl> + assertEquals ( 42 , t . getRow ( rowIndex ) . getLong ( 0 ) ) ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index df3156b . . e6ad153 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 1089 , 6 + 1089 , 47 @ @ public final class Realm implements Closeable { <nl> return get ( clazz , rowIndex ) ; <nl> } <nl> <nl> + / * * <nl> + * Creates a new object inside the Realm with the Primary key value initially set . <nl> + * If the value violates the primary key constraint , no object will be added and and <nl> + * { @ link RealmException will be thrown } . <nl> + * <nl> + * @ param clazz The Class of the object to create <nl> + * @ param primaryKeyValue Value for the primary key field . <nl> + * @ return The new object <nl> + * @ throws { @ link RealmException } if object could not be created . <nl> + * / <nl> + < E extends RealmObject > E createObject ( Class < E > clazz , Object primaryKeyValue ) { <nl> + Table table ; <nl> + table = tables . get ( clazz ) ; <nl> + if ( table = = null ) { <nl> + Class < ? > generatedClass = getProxyClass ( clazz ) ; <nl> + <nl> + Method method = initTableMethods . get ( generatedClass ) ; <nl> + if ( method = = null ) { <nl> + try { <nl> + method = generatedClass . getMethod ( " initTable " , new Class [ ] { ImplicitTransaction . class } ) ; <nl> + } catch ( NoSuchMethodException e ) { <nl> + throw new RealmException ( " Could not find the initTable ( ) method in generated proxy class : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + initTableMethods . put ( generatedClass , method ) ; <nl> + } <nl> + <nl> + try { <nl> + table = ( Table ) method . invoke ( null , transaction ) ; <nl> + tables . put ( clazz , table ) ; <nl> + } catch ( IllegalAccessException e ) { <nl> + throw new RealmException ( " Could not launch the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } catch ( InvocationTargetException e ) { <nl> + e . printStackTrace ( ) ; <nl> + throw new RealmException ( " An exception occurred while running the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + } <nl> + <nl> + long rowIndex = table . addEmptyRowWithPrimaryKey ( primaryKeyValue ) ; <nl> + return get ( clazz , rowIndex ) ; <nl> + } <nl> + <nl> private Class < ? > getProxyClass ( Class < ? > clazz ) { <nl> <nl> String simpleClassName = getClassSimpleName ( clazz ) ; <nl> diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java <nl> index 42d28b0 . . 83be1fd 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / Table . java <nl> + + + b / realm / src / main / java / io / realm / internal / Table . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . internal ; <nl> import java . io . Closeable ; <nl> import java . util . Date ; <nl> <nl> + import io . realm . annotations . PrimaryKey ; <nl> import io . realm . exceptions . RealmException ; <nl> <nl> <nl> @ @ - 364 , 7 + 365 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> <nl> protected native void nativeMoveLastOver ( long nativeTablePtr , long rowIndex ) ; <nl> <nl> - / / Row Handling methods . <nl> public long addEmptyRow ( ) { <nl> checkImmutable ( ) ; <nl> if ( hasPrimaryKey ( ) ) { <nl> @ @ - 390 , 6 + 390 , 54 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> return nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> } <nl> <nl> + public long addEmptyRowWithPrimaryKey ( Object primaryKeyValue ) { <nl> + checkImmutable ( ) ; <nl> + if ( hasPrimaryKey ( ) ) { <nl> + long primaryKeyColumnIndex = getPrimaryKey ( ) ; <nl> + ColumnType type = getColumnType ( primaryKeyColumnIndex ) ; <nl> + long rowIndex ; <nl> + Row row ; <nl> + <nl> + / / Add with with primary key initially set <nl> + switch ( type ) { <nl> + case STRING : <nl> + if ( ! ( primaryKeyValue instanceof String ) ) { <nl> + throw new IllegalArgumentException ( " Primary key value is not a String : " + primaryKeyValue ) ; <nl> + } <nl> + if ( findFirstString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ! = NO _ MATCH ) { <nl> + throwDuplicatePrimaryKeyException ( primaryKeyValue ) ; <nl> + } <nl> + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> + row = getRow ( rowIndex ) ; <nl> + row . setString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ; <nl> + break ; <nl> + <nl> + case INTEGER : <nl> + long pkValue ; <nl> + try { <nl> + pkValue = new Long ( primaryKeyValue . toString ( ) ) ; <nl> + } catch ( RuntimeException e ) { <nl> + throw new IllegalArgumentException ( " Primary key value is not a long : " + primaryKeyValue ) ; <nl> + } <nl> + if ( findFirstLong ( primaryKeyColumnIndex , pkValue ) ! = NO _ MATCH ) { <nl> + throwDuplicatePrimaryKeyException ( pkValue ) ; <nl> + } <nl> + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> + row = getRow ( rowIndex ) ; <nl> + row . setLong ( primaryKeyColumnIndex , pkValue ) ; <nl> + break ; <nl> + <nl> + default : <nl> + throw new RealmException ( " Cannot check for duplicate rows for unsupported primary key type : " + type ) ; <nl> + } <nl> + <nl> + return rowIndex ; <nl> + <nl> + } else { <nl> + throw new IllegalStateException ( getName ( ) + " has no primary key defined " ) ; <nl> + } <nl> + } <nl> + <nl> public long addEmptyRows ( long rows ) { <nl> checkImmutable ( ) ; <nl> if ( rows < 1 ) {

TEST DIFF:
diff - - git a / realm / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 index 9eb8286 . . 92ffd10 100644 
 - - - a / realm / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 + + + b / realm / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 @ @ - 1865 , 3 + 1865 , 64 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsEmpty 
 } 
 } CATCH _ STD ( ) 
 } 
 + 
 + JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNonEmpty 
 + ( JNIEnv * env , jobject , jlong nativeQueryPtr , jlongArray columnIndexes ) { 
 + 
 + JniLongArray arr ( env , columnIndexes ) ; 
 + jsize arr _ len = arr . len ( ) ; 
 + Query * pQuery = Q ( nativeQueryPtr ) ; 
 + try { 
 + TableRef src _ table _ ref = getTableForLinkQuery ( nativeQueryPtr , arr ) ; 
 + jlong column _ idx = arr [ arr _ len - 1 ] ; 
 + TableRef table _ ref = getTableByArray ( nativeQueryPtr , arr ) ; 
 + 
 + int col _ type = table _ ref - > get _ column _ type ( S ( column _ idx ) ) ; 
 + if ( arr _ len = = 1 ) { 
 + / / Field queries 
 + switch ( col _ type ) { 
 + case type _ Binary : 
 + pQuery - > not _ equal ( S ( column _ idx ) , BinaryData ( " " , 0 ) ) ; 
 + break ; 
 + case type _ LinkList : 
 + pQuery - > and _ query ( table _ ref - > column < LinkList > ( S ( column _ idx ) ) . count ( ) ! = 0 ) ; 
 + break ; 
 + case type _ String : 
 + pQuery - > not _ equal ( S ( column _ idx ) , " " ) ; 
 + break ; 
 + case type _ Link : 
 + case type _ Bool : 
 + case type _ Int : 
 + case type _ Float : 
 + case type _ Double : 
 + case type _ DateTime : 
 + default : 
 + ThrowException ( env , IllegalArgument , " isNonEmpty ( ) only works on String , byte [ ] and RealmList . " ) ; 
 + return ; 
 + } 
 + } 
 + else { 
 + / / Linked queries 
 + switch ( col _ type ) { 
 + case type _ Binary : 
 + pQuery - > and _ query ( src _ table _ ref - > column < Binary > ( S ( column _ idx ) ) ! = BinaryData ( " " , 0 ) ) ; 
 + break ; 
 + case type _ LinkList : 
 + pQuery - > and _ query ( src _ table _ ref - > column < LinkList > ( S ( column _ idx ) ) . count ( ) ! = 0 ) ; 
 + break ; 
 + case type _ String : 
 + pQuery - > and _ query ( src _ table _ ref - > column < String > ( S ( column _ idx ) ) ! = " " ) ; 
 + break ; 
 + case type _ Link : 
 + case type _ Bool : 
 + case type _ Int : 
 + case type _ Float : 
 + case type _ Double : 
 + case type _ DateTime : 
 + default : 
 + ThrowException ( env , IllegalArgument , " isNonEmpty ( ) only works on String , byte [ ] and RealmList across links . " ) ; 
 + return ; 
 + } 
 + } 
 + } CATCH _ STD ( ) 
 + } 
 diff - - git a / realm / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 index caf030b . . 6fb329f 100644 
 - - - a / realm / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 + + + b / realm / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 @ @ - 561 , 6 + 561 , 14 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsEmpty 
 
 / * 
 * Class : io _ realm _ internal _ TableQuery 
 + * Method : nativeIsNonEmpty 
 + * Signature : ( J [ J ) V 
 + * / 
 + JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNonEmpty 
 + ( JNIEnv * , jobject , jlong , jlongArray ) ; 
 + 
 + / * 
 + * Class : io _ realm _ internal _ TableQuery 
 * Method : nativeIsNotNull 
 * Signature : ( J [ J ) V 
 * / 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTest . java 
 index e71333f . . 97012a9 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTest . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTest . java 
 @ @ - 1655 , 6 + 1655 , 124 @ @ public class RealmQueryTest extends AndroidTestCase { 
 } 
 } 
 
 + / / non - empty test harnesses 
 + private static final List < RealmFieldType > SUPPORTED _ IS _ NONEMPTY _ TYPES = Arrays . asList ( 
 + RealmFieldType . STRING , 
 + RealmFieldType . BINARY , 
 + RealmFieldType . LIST ) ; 
 + 
 + private static final List < RealmFieldType > NOT _ SUPPORTED _ IS _ NONEMPTY _ TYPES ; 
 + static { 
 + final ArrayList < RealmFieldType > list = new ArrayList < RealmFieldType > ( Arrays . asList ( RealmFieldType . values ( ) ) ) ; 
 + list . removeAll ( SUPPORTED _ IS _ NONEMPTY _ TYPES ) ; 
 + list . remove ( RealmFieldType . UNSUPPORTED _ MIXED ) ; 
 + list . remove ( RealmFieldType . UNSUPPORTED _ TABLE ) ; 
 + NOT _ SUPPORTED _ IS _ NONEMPTY _ TYPES = list ; 
 + } 
 + 
 + private void createIsNonEmptyDataSet ( Realm realm ) { 
 + realm . beginTransaction ( ) ; 
 + 
 + AllJavaTypes emptyValues = new AllJavaTypes ( ) ; 
 + emptyValues . setFieldLong ( 1 ) ; 
 + emptyValues . setFieldString ( " " ) ; 
 + emptyValues . setFieldBinary ( new byte [ 0 ] ) ; 
 + emptyValues . setFieldObject ( emptyValues ) ; 
 + emptyValues . setFieldList ( new RealmList < AllJavaTypes > ( ) ) ; 
 + realm . copyToRealm ( emptyValues ) ; 
 + 
 + AllJavaTypes nonEmpty = new AllJavaTypes ( ) ; 
 + nonEmpty . setFieldLong ( 2 ) ; 
 + nonEmpty . setFieldString ( " Foo " ) ; 
 + nonEmpty . setFieldBinary ( new byte [ ] { 1 , 2 , 3 } ) ; 
 + nonEmpty . setFieldObject ( nonEmpty ) ; 
 + nonEmpty . setFieldList ( new RealmList < AllJavaTypes > ( emptyValues ) ) ; 
 + realm . copyToRealmOrUpdate ( nonEmpty ) ; 
 + 
 + realm . commitTransaction ( ) ; 
 + } 
 + 
 + public void testIsNonEmpty ( ) { 
 + createIsNonEmptyDataSet ( testRealm ) ; 
 + for ( RealmFieldType type : SUPPORTED _ IS _ NONEMPTY _ TYPES ) { 
 + switch ( type ) { 
 + case STRING : 
 + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ STRING ) . count ( ) ) ; 
 + break ; 
 + case BINARY : 
 + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ BINARY ) . count ( ) ) ; 
 + break ; 
 + case LIST : 
 + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ LIST ) . count ( ) ) ; 
 + break ; 
 + default : 
 + fail ( " Unknown type : " + type ) ; 
 + } 
 + } 
 + } 
 + 
 + public void testIsNonEmptyAcrossLink ( ) { 
 + createIsNonEmptyDataSet ( testRealm ) ; 
 + for ( RealmFieldType type : SUPPORTED _ IS _ NONEMPTY _ TYPES ) { 
 + switch ( type ) { 
 + case STRING : 
 + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ STRING ) . count ( ) ) ; 
 + break ; 
 + case BINARY : 
 + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) . count ( ) ) ; 
 + break ; 
 + case LIST : 
 + assertEquals ( 1 , testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ LIST ) . count ( ) ) ; 
 + break ; 
 + default : 
 + fail ( " Unknown type : " + type ) ; 
 + } 
 + } 
 + } 
 + 
 + public void testIsNonEmptyIllegalFieldTypeThrows ( ) { 
 + for ( RealmFieldType type : NOT _ SUPPORTED _ IS _ NONEMPTY _ TYPES ) { 
 + try { 
 + switch ( type ) { 
 + case INTEGER : 
 + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ LONG ) . findAll ( ) ; 
 + break ; 
 + case FLOAT : 
 + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ FLOAT ) . findAll ( ) ; 
 + break ; 
 + case DOUBLE : 
 + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ DOUBLE ) . findAll ( ) ; 
 + break ; 
 + case BOOLEAN : 
 + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ BOOLEAN ) . findAll ( ) ; 
 + break ; 
 + case OBJECT : 
 + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ OBJECT ) . findAll ( ) ; 
 + break ; 
 + case DATE : 
 + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( AllJavaTypes . FIELD _ DATE ) . findAll ( ) ; 
 + break ; 
 + default : 
 + fail ( " Unknown type : " + type ) ; 
 + } 
 + fail ( type + " should throw an exception " ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + } 
 + 
 + public void testIsNonEmptyInvalidFieldNameThrows ( ) { 
 + String [ ] fieldNames = new String [ ] { null , " " , " foo " , AllJavaTypes . FIELD _ OBJECT + " . foo " } ; 
 + 
 + for ( String fieldName : fieldNames ) { 
 + try { 
 + testRealm . where ( AllJavaTypes . class ) . isNonEmpty ( fieldName ) . findAll ( ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + } 
 + 
 / / Test that deep queries work on a lot of data 
 public void testDeepLinkListQuery ( ) { 
 testRealm . executeTransaction ( new Realm . Transaction ( ) { 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 index 0bd2c7c . . 08a4c0b 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1078 , 6 + 1078 , 20 @ @ public class RealmQuery < E extends RealmObject > { 
 return this ; 
 } 
 
 + / * * 
 + * Condition that find values that are considered " Non - empty " , i . e . a list , a string or a byte array with non - empty values . 
 + * 
 + * @ param fieldName the field to compare . 
 + * @ return the query object . 
 + * @ throws java . lang . IllegalArgumentException if the field name isn ' t valid or its type isn ' t either a RealmList , 
 + * String or byte array . 
 + * / 
 + public RealmQuery < E > isNonEmpty ( String fieldName ) { 
 + long columnIndices [ ] = schema . getColumnIndices ( fieldName , RealmFieldType . STRING , RealmFieldType . BINARY , RealmFieldType . LIST ) ; 
 + this . query . isNonEmpty ( columnIndices ) ; 
 + return this ; 
 + } 
 + 
 / / Aggregates 
 
 / / Sum 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java b / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java 
 index b408ed4 . . 1e0a92e 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java 
 @ @ - 411 , 6 + 411 , 12 @ @ public class TableQuery implements Closeable { 
 return this ; 
 } 
 
 + public TableQuery isNonEmpty ( long [ ] columnIndices ) { 
 + nativeIsNonEmpty ( nativePtr , columnIndices ) ; 
 + queryValidated = false ; 
 + return this ; 
 + } 
 + 
 / / Searching methods . 
 
 public long find ( long fromTableRow ) { 
 @ @ - 774 , 6 + 780 , 7 @ @ public class TableQuery implements Closeable { 
 private native void nativeEndsWith ( long nativeQueryPtr , long columnIndices [ ] , String value , boolean caseSensitive ) ; 
 private native void nativeContains ( long nativeQueryPtr , long columnIndices [ ] , String value , boolean caseSensitive ) ; 
 private native void nativeIsEmpty ( long nativePtr , long [ ] columnIndices ) ; 
 + private native void nativeIsNonEmpty ( long nativePtr , long [ ] columnIndices ) ; 
 private native long nativeFind ( long nativeQueryPtr , long fromTableRow ) ; 
 private native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; 
 private native long nativeSumInt ( long nativeQueryPtr , long columnIndex , long start , long end , long limit ) ;

NEAREST DIFF:
diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 index cd86320 . . 463cdce 100644 
 - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 @ @ - 506 , 7 + 506 , 11 @ @ public class RealmProxyClassGenerator { 
 EnumSet . of ( Modifier . PUBLIC , Modifier . STATIC ) , / / Modifiers 
 " Realm " , " realm " , className , " newObject " , " boolean " , " update " , " Map < RealmObject , RealmObject > " , " cache " ) ; / / Argument type & argument name 
 
 - writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; 
 + if ( metadata . hasPrimaryKey ( ) ) { 
 + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class , newObject . % s ( ) ) " , className , className , metadata . getPrimaryKeyGetter ( ) ) ; 
 + } else { 
 + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; 
 + } 
 writer . emitStatement ( " cache . put ( newObject , realmObject ) " ) ; 
 for ( VariableElement field : metadata . getFields ( ) ) { 
 String fieldName = field . getSimpleName ( ) . toString ( ) ; 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index b87516d . . cd0e555 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 46 , 6 + 46 , 7 @ @ import io . realm . entities . NonLatinFieldNames ; 
 import io . realm . entities . Owner ; 
 import io . realm . entities . OwnerPrimaryKey ; 
 import io . realm . entities . PrimaryKeyAsLong ; 
 + import io . realm . entities . PrimaryKeyAsString ; 
 import io . realm . entities . PrimaryKeyMix ; 
 import io . realm . entities . StringOnly ; 
 import io . realm . exceptions . RealmException ; 
 @ @ - 1067 , 6 + 1068 , 26 @ @ public class RealmTest extends AndroidTestCase { 
 assertArrayEquals ( new byte [ 0 ] , realmTypes . getColumnBinary ( ) ) ; 
 } 
 
 + / / Check that using copyToRealm will set the primary key directly instead of first setting 
 + / / it to the default value ( which can fail ) 
 + public void testCopyToRealmWithPrimaryKeySetValueDirectly ( ) { 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . createObject ( OwnerPrimaryKey . class ) ; 
 + testRealm . copyToRealm ( new OwnerPrimaryKey ( 1 , " Foo " ) ) ; 
 + testRealm . commitTransaction ( ) ; 
 + assertEquals ( 2 , testRealm . where ( OwnerPrimaryKey . class ) . count ( ) ) ; 
 + } 
 + 
 + public void testCopyToRealmWithPrimaryAsNullThrows ( ) { 
 + testRealm . beginTransaction ( ) ; 
 + try { 
 + testRealm . copyToRealm ( new PrimaryKeyAsString ( ) ) ; 
 + fail ( ) ; 
 + } catch ( RealmException expected ) { 
 + } finally { 
 + testRealm . cancelTransaction ( ) ; 
 + } 
 + } 
 
 public void testCopyToRealmList ( ) { 
 Dog dog1 = new Dog ( ) ; 
 @ @ - 1500 , 7 + 1521 , 6 @ @ public class RealmTest extends AndroidTestCase { 
 fail ( ) ; 
 } catch ( IllegalStateException ignored ) { 
 } 
 - 
 } 
 
 public void testUpdateObjectWithLinks ( ) throws Exception { 
 diff - - git a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 index 3bba1b0 . . ce53189 100644 
 - - - a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 + + + b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 @ @ - 26 , 6 + 26 , 13 @ @ public class PrimaryKeyAsString extends RealmObject { 
 
 private long id ; 
 
 + public PrimaryKeyAsString ( ) { 
 + } 
 + 
 + public PrimaryKeyAsString ( String name ) { 
 + this . name = name ; 
 + } 
 + 
 public String getName ( ) { 
 return name ; 
 } 
 diff - - git a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 index cbb78bf . . 3106ea9 100644 
 - - - a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 + + + b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 @ @ - 36 , 7 + 36 , 24 @ @ public class JNITransactions extends AndroidTestCase { 
 } 
 } 
 
 - 
 + private Table getTableWithStringPrimaryKey ( ) { 
 + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; 
 + WriteTransaction trans = db . beginWrite ( ) ; 
 + Table t = trans . getTable ( " TestTable " ) ; 
 + t . addColumn ( ColumnType . STRING , " colName " ) ; 
 + t . setPrimaryKey ( " colName " ) ; 
 + return t ; 
 + } 
 + 
 + private Table getTableWithIntegerPrimaryKey ( ) { 
 + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; 
 + WriteTransaction trans = db . beginWrite ( ) ; 
 + Table t = trans . getTable ( " TestTable " ) ; 
 + t . addColumn ( ColumnType . INTEGER , " colName " ) ; 
 + t . setPrimaryKey ( " colName " ) ; 
 + return t ; 
 + } 
 + 
 private void createDBFileName ( ) { 
 testFile = new File ( 
 this . getContext ( ) . getFilesDir ( ) , 
 @ @ - 319 , 24 + 336 , 44 @ @ public class JNITransactions extends AndroidTestCase { 
 fail ( " Primary key not enforced . " ) ; 
 } 
 
 + public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( 42 ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 + } 
 + } 
 
 - 
 - / * ARM Only works for Java 1 . 7 - NOT available in Android . 
 - 
 - @ Test ( enabled = true ) 
 - public void mustReadARM ( ) { 
 - writeOneTransaction ( 1 ) ; 
 - 
 - / / Read from table 
 - / / System . out . println ( " mustReadARM . " ) ; 
 - try ( ReadTransaction t = new ReadTransaction ( db ) ) { 
 - EmployeeTable employees = new EmployeeTable ( t ) ; 
 - assertEquals ( true , employees . isValid ( ) ) ; 
 - assertEquals ( 1 , employees . size ( ) ) ; 
 + public void testAddEmptyRowWithPrimaryKeyNullStringThrows ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( null ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 } 
 - catch ( Throwable e ) { 
 + } 
 
 + public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows ( ) { 
 + Table t = getTableWithIntegerPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( " Foo " ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 } 
 } 
 - * / 
 + 
 + public void testAddEmptyRowWithPrimaryKeyString ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + long rowIndex = t . addEmptyRowWithPrimaryKey ( " Foo " ) ; 
 + assertEquals ( 1 , t . size ( ) ) ; 
 + assertEquals ( " Foo " , t . getRow ( rowIndex ) . getString ( 0 ) ) ; 
 + } 
 + 
 + public void testAddEmptyRowWithPrimaryKeyLong ( ) { 
 + Table t = getTableWithIntegerPrimaryKey ( ) ; 
 + long rowIndex = t . addEmptyRowWithPrimaryKey ( 42 ) ; 
 + assertEquals ( 1 , t . size ( ) ) ; 
 + assertEquals ( 42 , t . getRow ( rowIndex ) . getLong ( 0 ) ) ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index df3156b . . e6ad153 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 1089 , 6 + 1089 , 47 @ @ public final class Realm implements Closeable { 
 return get ( clazz , rowIndex ) ; 
 } 
 
 + / * * 
 + * Creates a new object inside the Realm with the Primary key value initially set . 
 + * If the value violates the primary key constraint , no object will be added and and 
 + * { @ link RealmException will be thrown } . 
 + * 
 + * @ param clazz The Class of the object to create 
 + * @ param primaryKeyValue Value for the primary key field . 
 + * @ return The new object 
 + * @ throws { @ link RealmException } if object could not be created . 
 + * / 
 + < E extends RealmObject > E createObject ( Class < E > clazz , Object primaryKeyValue ) { 
 + Table table ; 
 + table = tables . get ( clazz ) ; 
 + if ( table = = null ) { 
 + Class < ? > generatedClass = getProxyClass ( clazz ) ; 
 + 
 + Method method = initTableMethods . get ( generatedClass ) ; 
 + if ( method = = null ) { 
 + try { 
 + method = generatedClass . getMethod ( " initTable " , new Class [ ] { ImplicitTransaction . class } ) ; 
 + } catch ( NoSuchMethodException e ) { 
 + throw new RealmException ( " Could not find the initTable ( ) method in generated proxy class : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } 
 + initTableMethods . put ( generatedClass , method ) ; 
 + } 
 + 
 + try { 
 + table = ( Table ) method . invoke ( null , transaction ) ; 
 + tables . put ( clazz , table ) ; 
 + } catch ( IllegalAccessException e ) { 
 + throw new RealmException ( " Could not launch the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } catch ( InvocationTargetException e ) { 
 + e . printStackTrace ( ) ; 
 + throw new RealmException ( " An exception occurred while running the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } 
 + } 
 + 
 + long rowIndex = table . addEmptyRowWithPrimaryKey ( primaryKeyValue ) ; 
 + return get ( clazz , rowIndex ) ; 
 + } 
 + 
 private Class < ? > getProxyClass ( Class < ? > clazz ) { 
 
 String simpleClassName = getClassSimpleName ( clazz ) ; 
 diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java 
 index 42d28b0 . . 83be1fd 100644 
 - - - a / realm / src / main / java / io / realm / internal / Table . java 
 + + + b / realm / src / main / java / io / realm / internal / Table . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . internal ; 
 import java . io . Closeable ; 
 import java . util . Date ; 
 
 + import io . realm . annotations . PrimaryKey ; 
 import io . realm . exceptions . RealmException ; 
 
 
 @ @ - 364 , 7 + 365 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 
 protected native void nativeMoveLastOver ( long nativeTablePtr , long rowIndex ) ; 
 
 - / / Row Handling methods . 
 public long addEmptyRow ( ) { 
 checkImmutable ( ) ; 
 if ( hasPrimaryKey ( ) ) { 
 @ @ - 390 , 6 + 390 , 54 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 return nativeAddEmptyRow ( nativePtr , 1 ) ; 
 } 
 
 + public long addEmptyRowWithPrimaryKey ( Object primaryKeyValue ) { 
 + checkImmutable ( ) ; 
 + if ( hasPrimaryKey ( ) ) { 
 + long primaryKeyColumnIndex = getPrimaryKey ( ) ; 
 + ColumnType type = getColumnType ( primaryKeyColumnIndex ) ; 
 + long rowIndex ; 
 + Row row ; 
 + 
 + / / Add with with primary key initially set 
 + switch ( type ) { 
 + case STRING : 
 + if ( ! ( primaryKeyValue instanceof String ) ) { 
 + throw new IllegalArgumentException ( " Primary key value is not a String : " + primaryKeyValue ) ; 
 + } 
 + if ( findFirstString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ! = NO _ MATCH ) { 
 + throwDuplicatePrimaryKeyException ( primaryKeyValue ) ; 
 + } 
 + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; 
 + row = getRow ( rowIndex ) ; 
 + row . setString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ; 
 + break ; 
 + 
 + case INTEGER : 
 + long pkValue ; 
 + try { 
 + pkValue = new Long ( primaryKeyValue . toString ( ) ) ; 
 + } catch ( RuntimeException e ) { 
 + throw new IllegalArgumentException ( " Primary key value is not a long : " + primaryKeyValue ) ; 
 + } 
 + if ( findFirstLong ( primaryKeyColumnIndex , pkValue ) ! = NO _ MATCH ) { 
 + throwDuplicatePrimaryKeyException ( pkValue ) ; 
 + } 
 + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; 
 + row = getRow ( rowIndex ) ; 
 + row . setLong ( primaryKeyColumnIndex , pkValue ) ; 
 + break ; 
 + 
 + default : 
 + throw new RealmException ( " Cannot check for duplicate rows for unsupported primary key type : " + type ) ; 
 + } 
 + 
 + return rowIndex ; 
 + 
 + } else { 
 + throw new IllegalStateException ( getName ( ) + " has no primary key defined " ) ; 
 + } 
 + } 
 + 
 public long addEmptyRows ( long rows ) { 
 checkImmutable ( ) ; 
 if ( rows < 1 ) {
