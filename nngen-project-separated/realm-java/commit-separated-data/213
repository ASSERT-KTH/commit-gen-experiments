BLEU SCORE: 0.05274815473793832

TEST MSG: refactor CachedFieldDescriptor # compileFieldDescription ( ) and DynamicFieldDescriptor # compileFieldDescription ( )
GENERATED MSG: Fixed bug where copyToRealm ( ) crashed when copying objects with primary key data .

TEST DIFF (one line): diff - - git a / realm / realm - library / src / main / java / io / realm / internal / fields / CachedFieldDescriptor . java b / realm / realm - library / src / main / java / io / realm / internal / fields / CachedFieldDescriptor . java <nl> index 9fde831 . . 014f9d0 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / fields / CachedFieldDescriptor . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / fields / CachedFieldDescriptor . java <nl> @ @ - 54 , 43 + 54 , 41 @ @ class CachedFieldDescriptor extends FieldDescriptor { <nl> final int nFields = fields . size ( ) ; <nl> long [ ] columnIndices = new long [ nFields ] ; <nl> long [ ] tableNativePointers = new long [ nFields ] ; <nl> - String currentTable = className ; <nl> <nl> - ColumnInfo tableInfo ; <nl> - String columnName = null ; <nl> - RealmFieldType columnType = null ; <nl> - long columnIndex ; <nl> + String currentClassName = className ; <nl> + String currentColumnName = null ; <nl> + RealmFieldType currentColumnType = null ; <nl> for ( int i = 0 ; i < nFields ; i + + ) { <nl> - columnName = fields . get ( i ) ; <nl> - if ( ( columnName = = null ) | | ( columnName . length ( ) < = 0 ) ) { <nl> + currentColumnName = fields . get ( i ) ; <nl> + if ( ( currentColumnName = = null ) | | ( currentColumnName . length ( ) < = 0 ) ) { <nl> throw new IllegalArgumentException ( <nl> " Invalid query : Field descriptor contains an empty field . A field description may not begin with or contain adjacent periods ( ' . ' ) . " ) ; <nl> } <nl> <nl> - tableInfo = schema . getColumnInfo ( currentTable ) ; <nl> - if ( tableInfo = = null ) { <nl> + final ColumnInfo columnInfo = schema . getColumnInfo ( currentClassName ) ; <nl> + if ( columnInfo = = null ) { <nl> throw new IllegalArgumentException ( <nl> - String . format ( Locale . US , " Invalid query : table ' % s ' not found in this schema . " , currentTable ) ) ; <nl> + String . format ( Locale . US , " Invalid query : class ' % s ' not found in this schema . " , currentClassName ) ) ; <nl> } <nl> <nl> - columnIndex = tableInfo . getColumnIndex ( columnName ) ; <nl> + final long columnIndex = columnInfo . getColumnIndex ( currentColumnName ) ; <nl> if ( columnIndex < 0 ) { <nl> throw new IllegalArgumentException ( <nl> - String . format ( Locale . US , " Invalid query : field ' % s ' not found in table ' % s ' . " , columnName , currentTable ) ) ; <nl> + String . format ( Locale . US , " Invalid query : field ' % s ' not found in table ' % s ' . " , currentColumnName , currentClassName ) ) ; <nl> } <nl> <nl> - columnType = tableInfo . getColumnType ( columnName ) ; <nl> + currentColumnType = columnInfo . getColumnType ( currentColumnName ) ; <nl> / / we don ' t check the type of the last field in the chain since it is done in the C + + code <nl> if ( i < nFields - 1 ) { <nl> - verifyInternalColumnType ( currentTable , columnName , columnType ) ; <nl> + verifyInternalColumnType ( currentClassName , currentColumnName , currentColumnType ) ; <nl> } <nl> - currentTable = tableInfo . getLinkedTable ( columnName ) ; <nl> + currentClassName = columnInfo . getLinkedTable ( currentColumnName ) ; <nl> columnIndices [ i ] = columnIndex ; <nl> - tableNativePointers [ i ] = ( columnType ! = RealmFieldType . LINKING _ OBJECTS ) <nl> + tableNativePointers [ i ] = ( currentColumnType ! = RealmFieldType . LINKING _ OBJECTS ) <nl> ? NativeObject . NULLPTR <nl> - : schema . getNativeTablePtr ( currentTable ) ; <nl> + : schema . getNativeTablePtr ( currentClassName ) ; <nl> } <nl> <nl> - setCompilationResults ( className , columnName , columnType , columnIndices , tableNativePointers ) ; <nl> + setCompilationResults ( className , currentColumnName , currentColumnType , columnIndices , tableNativePointers ) ; <nl> } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / fields / DynamicFieldDescriptor . java b / realm / realm - library / src / main / java / io / realm / internal / fields / DynamicFieldDescriptor . java <nl> index 80dc911 . . 7328073 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / fields / DynamicFieldDescriptor . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / fields / DynamicFieldDescriptor . java <nl> @ @ - 47 , 36 + 47 , 35 @ @ class DynamicFieldDescriptor extends FieldDescriptor { <nl> protected void compileFieldDescription ( List < String > fields ) { <nl> final int nFields = fields . size ( ) ; <nl> long [ ] columnIndices = new long [ nFields ] ; <nl> - Table currentTable = table ; <nl> <nl> - long columnIndex ; <nl> - String tableName = null ; <nl> - String columnName = null ; <nl> - RealmFieldType columnType = null ; <nl> + Table currentTable = table ; <nl> + String currentClassName = null ; <nl> + String currentColumnName = null ; <nl> + RealmFieldType currentColumnType = null ; <nl> for ( int i = 0 ; i < nFields ; i + + ) { <nl> - columnName = fields . get ( i ) ; <nl> - if ( ( columnName = = null ) | | ( columnName . length ( ) < = 0 ) ) { <nl> + currentColumnName = fields . get ( i ) ; <nl> + if ( ( currentColumnName = = null ) | | ( currentColumnName . length ( ) < = 0 ) ) { <nl> throw new IllegalArgumentException ( <nl> " Invalid query : Field descriptor contains an empty field . A field description may not begin with or contain adjacent periods ( ' . ' ) . " ) ; <nl> } <nl> <nl> - tableName = currentTable . getClassName ( ) ; <nl> + currentClassName = currentTable . getClassName ( ) ; <nl> <nl> - columnIndex = currentTable . getColumnIndex ( columnName ) ; <nl> + final long columnIndex = currentTable . getColumnIndex ( currentColumnName ) ; <nl> if ( columnIndex < 0 ) { <nl> throw new IllegalArgumentException ( <nl> - String . format ( Locale . US , " Invalid query : field ' % s ' not found in table ' % s ' . " , columnName , tableName ) ) ; <nl> + String . format ( Locale . US , " Invalid query : field ' % s ' not found in table ' % s ' . " , currentColumnName , currentClassName ) ) ; <nl> } <nl> <nl> - columnType = currentTable . getColumnType ( columnIndex ) ; <nl> + currentColumnType = currentTable . getColumnType ( columnIndex ) ; <nl> if ( i < nFields - 1 ) { <nl> - verifyInternalColumnType ( tableName , columnName , columnType ) ; <nl> + verifyInternalColumnType ( currentClassName , currentColumnName , currentColumnType ) ; <nl> currentTable = currentTable . getLinkTarget ( columnIndex ) ; <nl> } <nl> <nl> columnIndices [ i ] = columnIndex ; <nl> } <nl> <nl> - setCompilationResults ( tableName , columnName , columnType , columnIndices , new long [ nFields ] ) ; <nl> + setCompilationResults ( currentClassName , currentColumnName , currentColumnType , columnIndices , new long [ nFields ] ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> index cd86320 . . 463cdce 100644 <nl> - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> @ @ - 506 , 7 + 506 , 11 @ @ public class RealmProxyClassGenerator { <nl> EnumSet . of ( Modifier . PUBLIC , Modifier . STATIC ) , / / Modifiers <nl> " Realm " , " realm " , className , " newObject " , " boolean " , " update " , " Map < RealmObject , RealmObject > " , " cache " ) ; / / Argument type & argument name <nl> <nl> - writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; <nl> + if ( metadata . hasPrimaryKey ( ) ) { <nl> + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class , newObject . % s ( ) ) " , className , className , metadata . getPrimaryKeyGetter ( ) ) ; <nl> + } else { <nl> + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; <nl> + } <nl> writer . emitStatement ( " cache . put ( newObject , realmObject ) " ) ; <nl> for ( VariableElement field : metadata . getFields ( ) ) { <nl> String fieldName = field . getSimpleName ( ) . toString ( ) ; <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index b87516d . . cd0e555 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 46 , 6 + 46 , 7 @ @ import io . realm . entities . NonLatinFieldNames ; <nl> import io . realm . entities . Owner ; <nl> import io . realm . entities . OwnerPrimaryKey ; <nl> import io . realm . entities . PrimaryKeyAsLong ; <nl> + import io . realm . entities . PrimaryKeyAsString ; <nl> import io . realm . entities . PrimaryKeyMix ; <nl> import io . realm . entities . StringOnly ; <nl> import io . realm . exceptions . RealmException ; <nl> @ @ - 1067 , 6 + 1068 , 26 @ @ public class RealmTest extends AndroidTestCase { <nl> assertArrayEquals ( new byte [ 0 ] , realmTypes . getColumnBinary ( ) ) ; <nl> } <nl> <nl> + / / Check that using copyToRealm will set the primary key directly instead of first setting <nl> + / / it to the default value ( which can fail ) <nl> + public void testCopyToRealmWithPrimaryKeySetValueDirectly ( ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . createObject ( OwnerPrimaryKey . class ) ; <nl> + testRealm . copyToRealm ( new OwnerPrimaryKey ( 1 , " Foo " ) ) ; <nl> + testRealm . commitTransaction ( ) ; <nl> + assertEquals ( 2 , testRealm . where ( OwnerPrimaryKey . class ) . count ( ) ) ; <nl> + } <nl> + <nl> + public void testCopyToRealmWithPrimaryAsNullThrows ( ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + try { <nl> + testRealm . copyToRealm ( new PrimaryKeyAsString ( ) ) ; <nl> + fail ( ) ; <nl> + } catch ( RealmException expected ) { <nl> + } finally { <nl> + testRealm . cancelTransaction ( ) ; <nl> + } <nl> + } <nl> <nl> public void testCopyToRealmList ( ) { <nl> Dog dog1 = new Dog ( ) ; <nl> @ @ - 1500 , 7 + 1521 , 6 @ @ public class RealmTest extends AndroidTestCase { <nl> fail ( ) ; <nl> } catch ( IllegalStateException ignored ) { <nl> } <nl> - <nl> } <nl> <nl> public void testUpdateObjectWithLinks ( ) throws Exception { <nl> diff - - git a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> index 3bba1b0 . . ce53189 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> + + + b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> @ @ - 26 , 6 + 26 , 13 @ @ public class PrimaryKeyAsString extends RealmObject { <nl> <nl> private long id ; <nl> <nl> + public PrimaryKeyAsString ( ) { <nl> + } <nl> + <nl> + public PrimaryKeyAsString ( String name ) { <nl> + this . name = name ; <nl> + } <nl> + <nl> public String getName ( ) { <nl> return name ; <nl> } <nl> diff - - git a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> index cbb78bf . . 3106ea9 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> + + + b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> @ @ - 36 , 7 + 36 , 24 @ @ public class JNITransactions extends AndroidTestCase { <nl> } <nl> } <nl> <nl> - <nl> + private Table getTableWithStringPrimaryKey ( ) { <nl> + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; <nl> + WriteTransaction trans = db . beginWrite ( ) ; <nl> + Table t = trans . getTable ( " TestTable " ) ; <nl> + t . addColumn ( ColumnType . STRING , " colName " ) ; <nl> + t . setPrimaryKey ( " colName " ) ; <nl> + return t ; <nl> + } <nl> + <nl> + private Table getTableWithIntegerPrimaryKey ( ) { <nl> + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; <nl> + WriteTransaction trans = db . beginWrite ( ) ; <nl> + Table t = trans . getTable ( " TestTable " ) ; <nl> + t . addColumn ( ColumnType . INTEGER , " colName " ) ; <nl> + t . setPrimaryKey ( " colName " ) ; <nl> + return t ; <nl> + } <nl> + <nl> private void createDBFileName ( ) { <nl> testFile = new File ( <nl> this . getContext ( ) . getFilesDir ( ) , <nl> @ @ - 319 , 24 + 336 , 44 @ @ public class JNITransactions extends AndroidTestCase { <nl> fail ( " Primary key not enforced . " ) ; <nl> } <nl> <nl> + public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( 42 ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> + } <nl> + } <nl> <nl> - <nl> - / * ARM Only works for Java 1 . 7 - NOT available in Android . <nl> - <nl> - @ Test ( enabled = true ) <nl> - public void mustReadARM ( ) { <nl> - writeOneTransaction ( 1 ) ; <nl> - <nl> - / / Read from table <nl> - / / System . out . println ( " mustReadARM . " ) ; <nl> - try ( ReadTransaction t = new ReadTransaction ( db ) ) { <nl> - EmployeeTable employees = new EmployeeTable ( t ) ; <nl> - assertEquals ( true , employees . isValid ( ) ) ; <nl> - assertEquals ( 1 , employees . size ( ) ) ; <nl> + public void testAddEmptyRowWithPrimaryKeyNullStringThrows ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( null ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> } <nl> - catch ( Throwable e ) { <nl> + } <nl> <nl> + public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows ( ) { <nl> + Table t = getTableWithIntegerPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( " Foo " ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> } <nl> } <nl> - * / <nl> + <nl> + public void testAddEmptyRowWithPrimaryKeyString ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + long rowIndex = t . addEmptyRowWithPrimaryKey ( " Foo " ) ; <nl> + assertEquals ( 1 , t . size ( ) ) ; <nl> + assertEquals ( " Foo " , t . getRow ( rowIndex ) . getString ( 0 ) ) ; <nl> + } <nl> + <nl> + public void testAddEmptyRowWithPrimaryKeyLong ( ) { <nl> + Table t = getTableWithIntegerPrimaryKey ( ) ; <nl> + long rowIndex = t . addEmptyRowWithPrimaryKey ( 42 ) ; <nl> + assertEquals ( 1 , t . size ( ) ) ; <nl> + assertEquals ( 42 , t . getRow ( rowIndex ) . getLong ( 0 ) ) ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index df3156b . . e6ad153 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 1089 , 6 + 1089 , 47 @ @ public final class Realm implements Closeable { <nl> return get ( clazz , rowIndex ) ; <nl> } <nl> <nl> + / * * <nl> + * Creates a new object inside the Realm with the Primary key value initially set . <nl> + * If the value violates the primary key constraint , no object will be added and and <nl> + * { @ link RealmException will be thrown } . <nl> + * <nl> + * @ param clazz The Class of the object to create <nl> + * @ param primaryKeyValue Value for the primary key field . <nl> + * @ return The new object <nl> + * @ throws { @ link RealmException } if object could not be created . <nl> + * / <nl> + < E extends RealmObject > E createObject ( Class < E > clazz , Object primaryKeyValue ) { <nl> + Table table ; <nl> + table = tables . get ( clazz ) ; <nl> + if ( table = = null ) { <nl> + Class < ? > generatedClass = getProxyClass ( clazz ) ; <nl> + <nl> + Method method = initTableMethods . get ( generatedClass ) ; <nl> + if ( method = = null ) { <nl> + try { <nl> + method = generatedClass . getMethod ( " initTable " , new Class [ ] { ImplicitTransaction . class } ) ; <nl> + } catch ( NoSuchMethodException e ) { <nl> + throw new RealmException ( " Could not find the initTable ( ) method in generated proxy class : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + initTableMethods . put ( generatedClass , method ) ; <nl> + } <nl> + <nl> + try { <nl> + table = ( Table ) method . invoke ( null , transaction ) ; <nl> + tables . put ( clazz , table ) ; <nl> + } catch ( IllegalAccessException e ) { <nl> + throw new RealmException ( " Could not launch the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } catch ( InvocationTargetException e ) { <nl> + e . printStackTrace ( ) ; <nl> + throw new RealmException ( " An exception occurred while running the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + } <nl> + <nl> + long rowIndex = table . addEmptyRowWithPrimaryKey ( primaryKeyValue ) ; <nl> + return get ( clazz , rowIndex ) ; <nl> + } <nl> + <nl> private Class < ? > getProxyClass ( Class < ? > clazz ) { <nl> <nl> String simpleClassName = getClassSimpleName ( clazz ) ; <nl> diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java <nl> index 42d28b0 . . 83be1fd 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / Table . java <nl> + + + b / realm / src / main / java / io / realm / internal / Table . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . internal ; <nl> import java . io . Closeable ; <nl> import java . util . Date ; <nl> <nl> + import io . realm . annotations . PrimaryKey ; <nl> import io . realm . exceptions . RealmException ; <nl> <nl> <nl> @ @ - 364 , 7 + 365 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> <nl> protected native void nativeMoveLastOver ( long nativeTablePtr , long rowIndex ) ; <nl> <nl> - / / Row Handling methods . <nl> public long addEmptyRow ( ) { <nl> checkImmutable ( ) ; <nl> if ( hasPrimaryKey ( ) ) { <nl> @ @ - 390 , 6 + 390 , 54 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> return nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> } <nl> <nl> + public long addEmptyRowWithPrimaryKey ( Object primaryKeyValue ) { <nl> + checkImmutable ( ) ; <nl> + if ( hasPrimaryKey ( ) ) { <nl> + long primaryKeyColumnIndex = getPrimaryKey ( ) ; <nl> + ColumnType type = getColumnType ( primaryKeyColumnIndex ) ; <nl> + long rowIndex ; <nl> + Row row ; <nl> + <nl> + / / Add with with primary key initially set <nl> + switch ( type ) { <nl> + case STRING : <nl> + if ( ! ( primaryKeyValue instanceof String ) ) { <nl> + throw new IllegalArgumentException ( " Primary key value is not a String : " + primaryKeyValue ) ; <nl> + } <nl> + if ( findFirstString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ! = NO _ MATCH ) { <nl> + throwDuplicatePrimaryKeyException ( primaryKeyValue ) ; <nl> + } <nl> + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> + row = getRow ( rowIndex ) ; <nl> + row . setString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ; <nl> + break ; <nl> + <nl> + case INTEGER : <nl> + long pkValue ; <nl> + try { <nl> + pkValue = new Long ( primaryKeyValue . toString ( ) ) ; <nl> + } catch ( RuntimeException e ) { <nl> + throw new IllegalArgumentException ( " Primary key value is not a long : " + primaryKeyValue ) ; <nl> + } <nl> + if ( findFirstLong ( primaryKeyColumnIndex , pkValue ) ! = NO _ MATCH ) { <nl> + throwDuplicatePrimaryKeyException ( pkValue ) ; <nl> + } <nl> + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> + row = getRow ( rowIndex ) ; <nl> + row . setLong ( primaryKeyColumnIndex , pkValue ) ; <nl> + break ; <nl> + <nl> + default : <nl> + throw new RealmException ( " Cannot check for duplicate rows for unsupported primary key type : " + type ) ; <nl> + } <nl> + <nl> + return rowIndex ; <nl> + <nl> + } else { <nl> + throw new IllegalStateException ( getName ( ) + " has no primary key defined " ) ; <nl> + } <nl> + } <nl> + <nl> public long addEmptyRows ( long rows ) { <nl> checkImmutable ( ) ; <nl> if ( rows < 1 ) {

TEST DIFF:
diff - - git a / realm / realm - library / src / main / java / io / realm / internal / fields / CachedFieldDescriptor . java b / realm / realm - library / src / main / java / io / realm / internal / fields / CachedFieldDescriptor . java 
 index 9fde831 . . 014f9d0 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / fields / CachedFieldDescriptor . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / fields / CachedFieldDescriptor . java 
 @ @ - 54 , 43 + 54 , 41 @ @ class CachedFieldDescriptor extends FieldDescriptor { 
 final int nFields = fields . size ( ) ; 
 long [ ] columnIndices = new long [ nFields ] ; 
 long [ ] tableNativePointers = new long [ nFields ] ; 
 - String currentTable = className ; 
 
 - ColumnInfo tableInfo ; 
 - String columnName = null ; 
 - RealmFieldType columnType = null ; 
 - long columnIndex ; 
 + String currentClassName = className ; 
 + String currentColumnName = null ; 
 + RealmFieldType currentColumnType = null ; 
 for ( int i = 0 ; i < nFields ; i + + ) { 
 - columnName = fields . get ( i ) ; 
 - if ( ( columnName = = null ) | | ( columnName . length ( ) < = 0 ) ) { 
 + currentColumnName = fields . get ( i ) ; 
 + if ( ( currentColumnName = = null ) | | ( currentColumnName . length ( ) < = 0 ) ) { 
 throw new IllegalArgumentException ( 
 " Invalid query : Field descriptor contains an empty field . A field description may not begin with or contain adjacent periods ( ' . ' ) . " ) ; 
 } 
 
 - tableInfo = schema . getColumnInfo ( currentTable ) ; 
 - if ( tableInfo = = null ) { 
 + final ColumnInfo columnInfo = schema . getColumnInfo ( currentClassName ) ; 
 + if ( columnInfo = = null ) { 
 throw new IllegalArgumentException ( 
 - String . format ( Locale . US , " Invalid query : table ' % s ' not found in this schema . " , currentTable ) ) ; 
 + String . format ( Locale . US , " Invalid query : class ' % s ' not found in this schema . " , currentClassName ) ) ; 
 } 
 
 - columnIndex = tableInfo . getColumnIndex ( columnName ) ; 
 + final long columnIndex = columnInfo . getColumnIndex ( currentColumnName ) ; 
 if ( columnIndex < 0 ) { 
 throw new IllegalArgumentException ( 
 - String . format ( Locale . US , " Invalid query : field ' % s ' not found in table ' % s ' . " , columnName , currentTable ) ) ; 
 + String . format ( Locale . US , " Invalid query : field ' % s ' not found in table ' % s ' . " , currentColumnName , currentClassName ) ) ; 
 } 
 
 - columnType = tableInfo . getColumnType ( columnName ) ; 
 + currentColumnType = columnInfo . getColumnType ( currentColumnName ) ; 
 / / we don ' t check the type of the last field in the chain since it is done in the C + + code 
 if ( i < nFields - 1 ) { 
 - verifyInternalColumnType ( currentTable , columnName , columnType ) ; 
 + verifyInternalColumnType ( currentClassName , currentColumnName , currentColumnType ) ; 
 } 
 - currentTable = tableInfo . getLinkedTable ( columnName ) ; 
 + currentClassName = columnInfo . getLinkedTable ( currentColumnName ) ; 
 columnIndices [ i ] = columnIndex ; 
 - tableNativePointers [ i ] = ( columnType ! = RealmFieldType . LINKING _ OBJECTS ) 
 + tableNativePointers [ i ] = ( currentColumnType ! = RealmFieldType . LINKING _ OBJECTS ) 
 ? NativeObject . NULLPTR 
 - : schema . getNativeTablePtr ( currentTable ) ; 
 + : schema . getNativeTablePtr ( currentClassName ) ; 
 } 
 
 - setCompilationResults ( className , columnName , columnType , columnIndices , tableNativePointers ) ; 
 + setCompilationResults ( className , currentColumnName , currentColumnType , columnIndices , tableNativePointers ) ; 
 } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / fields / DynamicFieldDescriptor . java b / realm / realm - library / src / main / java / io / realm / internal / fields / DynamicFieldDescriptor . java 
 index 80dc911 . . 7328073 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / fields / DynamicFieldDescriptor . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / fields / DynamicFieldDescriptor . java 
 @ @ - 47 , 36 + 47 , 35 @ @ class DynamicFieldDescriptor extends FieldDescriptor { 
 protected void compileFieldDescription ( List < String > fields ) { 
 final int nFields = fields . size ( ) ; 
 long [ ] columnIndices = new long [ nFields ] ; 
 - Table currentTable = table ; 
 
 - long columnIndex ; 
 - String tableName = null ; 
 - String columnName = null ; 
 - RealmFieldType columnType = null ; 
 + Table currentTable = table ; 
 + String currentClassName = null ; 
 + String currentColumnName = null ; 
 + RealmFieldType currentColumnType = null ; 
 for ( int i = 0 ; i < nFields ; i + + ) { 
 - columnName = fields . get ( i ) ; 
 - if ( ( columnName = = null ) | | ( columnName . length ( ) < = 0 ) ) { 
 + currentColumnName = fields . get ( i ) ; 
 + if ( ( currentColumnName = = null ) | | ( currentColumnName . length ( ) < = 0 ) ) { 
 throw new IllegalArgumentException ( 
 " Invalid query : Field descriptor contains an empty field . A field description may not begin with or contain adjacent periods ( ' . ' ) . " ) ; 
 } 
 
 - tableName = currentTable . getClassName ( ) ; 
 + currentClassName = currentTable . getClassName ( ) ; 
 
 - columnIndex = currentTable . getColumnIndex ( columnName ) ; 
 + final long columnIndex = currentTable . getColumnIndex ( currentColumnName ) ; 
 if ( columnIndex < 0 ) { 
 throw new IllegalArgumentException ( 
 - String . format ( Locale . US , " Invalid query : field ' % s ' not found in table ' % s ' . " , columnName , tableName ) ) ; 
 + String . format ( Locale . US , " Invalid query : field ' % s ' not found in table ' % s ' . " , currentColumnName , currentClassName ) ) ; 
 } 
 
 - columnType = currentTable . getColumnType ( columnIndex ) ; 
 + currentColumnType = currentTable . getColumnType ( columnIndex ) ; 
 if ( i < nFields - 1 ) { 
 - verifyInternalColumnType ( tableName , columnName , columnType ) ; 
 + verifyInternalColumnType ( currentClassName , currentColumnName , currentColumnType ) ; 
 currentTable = currentTable . getLinkTarget ( columnIndex ) ; 
 } 
 
 columnIndices [ i ] = columnIndex ; 
 } 
 
 - setCompilationResults ( tableName , columnName , columnType , columnIndices , new long [ nFields ] ) ; 
 + setCompilationResults ( currentClassName , currentColumnName , currentColumnType , columnIndices , new long [ nFields ] ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 index cd86320 . . 463cdce 100644 
 - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 @ @ - 506 , 7 + 506 , 11 @ @ public class RealmProxyClassGenerator { 
 EnumSet . of ( Modifier . PUBLIC , Modifier . STATIC ) , / / Modifiers 
 " Realm " , " realm " , className , " newObject " , " boolean " , " update " , " Map < RealmObject , RealmObject > " , " cache " ) ; / / Argument type & argument name 
 
 - writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; 
 + if ( metadata . hasPrimaryKey ( ) ) { 
 + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class , newObject . % s ( ) ) " , className , className , metadata . getPrimaryKeyGetter ( ) ) ; 
 + } else { 
 + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; 
 + } 
 writer . emitStatement ( " cache . put ( newObject , realmObject ) " ) ; 
 for ( VariableElement field : metadata . getFields ( ) ) { 
 String fieldName = field . getSimpleName ( ) . toString ( ) ; 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index b87516d . . cd0e555 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 46 , 6 + 46 , 7 @ @ import io . realm . entities . NonLatinFieldNames ; 
 import io . realm . entities . Owner ; 
 import io . realm . entities . OwnerPrimaryKey ; 
 import io . realm . entities . PrimaryKeyAsLong ; 
 + import io . realm . entities . PrimaryKeyAsString ; 
 import io . realm . entities . PrimaryKeyMix ; 
 import io . realm . entities . StringOnly ; 
 import io . realm . exceptions . RealmException ; 
 @ @ - 1067 , 6 + 1068 , 26 @ @ public class RealmTest extends AndroidTestCase { 
 assertArrayEquals ( new byte [ 0 ] , realmTypes . getColumnBinary ( ) ) ; 
 } 
 
 + / / Check that using copyToRealm will set the primary key directly instead of first setting 
 + / / it to the default value ( which can fail ) 
 + public void testCopyToRealmWithPrimaryKeySetValueDirectly ( ) { 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . createObject ( OwnerPrimaryKey . class ) ; 
 + testRealm . copyToRealm ( new OwnerPrimaryKey ( 1 , " Foo " ) ) ; 
 + testRealm . commitTransaction ( ) ; 
 + assertEquals ( 2 , testRealm . where ( OwnerPrimaryKey . class ) . count ( ) ) ; 
 + } 
 + 
 + public void testCopyToRealmWithPrimaryAsNullThrows ( ) { 
 + testRealm . beginTransaction ( ) ; 
 + try { 
 + testRealm . copyToRealm ( new PrimaryKeyAsString ( ) ) ; 
 + fail ( ) ; 
 + } catch ( RealmException expected ) { 
 + } finally { 
 + testRealm . cancelTransaction ( ) ; 
 + } 
 + } 
 
 public void testCopyToRealmList ( ) { 
 Dog dog1 = new Dog ( ) ; 
 @ @ - 1500 , 7 + 1521 , 6 @ @ public class RealmTest extends AndroidTestCase { 
 fail ( ) ; 
 } catch ( IllegalStateException ignored ) { 
 } 
 - 
 } 
 
 public void testUpdateObjectWithLinks ( ) throws Exception { 
 diff - - git a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 index 3bba1b0 . . ce53189 100644 
 - - - a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 + + + b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 @ @ - 26 , 6 + 26 , 13 @ @ public class PrimaryKeyAsString extends RealmObject { 
 
 private long id ; 
 
 + public PrimaryKeyAsString ( ) { 
 + } 
 + 
 + public PrimaryKeyAsString ( String name ) { 
 + this . name = name ; 
 + } 
 + 
 public String getName ( ) { 
 return name ; 
 } 
 diff - - git a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 index cbb78bf . . 3106ea9 100644 
 - - - a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 + + + b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 @ @ - 36 , 7 + 36 , 24 @ @ public class JNITransactions extends AndroidTestCase { 
 } 
 } 
 
 - 
 + private Table getTableWithStringPrimaryKey ( ) { 
 + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; 
 + WriteTransaction trans = db . beginWrite ( ) ; 
 + Table t = trans . getTable ( " TestTable " ) ; 
 + t . addColumn ( ColumnType . STRING , " colName " ) ; 
 + t . setPrimaryKey ( " colName " ) ; 
 + return t ; 
 + } 
 + 
 + private Table getTableWithIntegerPrimaryKey ( ) { 
 + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; 
 + WriteTransaction trans = db . beginWrite ( ) ; 
 + Table t = trans . getTable ( " TestTable " ) ; 
 + t . addColumn ( ColumnType . INTEGER , " colName " ) ; 
 + t . setPrimaryKey ( " colName " ) ; 
 + return t ; 
 + } 
 + 
 private void createDBFileName ( ) { 
 testFile = new File ( 
 this . getContext ( ) . getFilesDir ( ) , 
 @ @ - 319 , 24 + 336 , 44 @ @ public class JNITransactions extends AndroidTestCase { 
 fail ( " Primary key not enforced . " ) ; 
 } 
 
 + public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( 42 ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 + } 
 + } 
 
 - 
 - / * ARM Only works for Java 1 . 7 - NOT available in Android . 
 - 
 - @ Test ( enabled = true ) 
 - public void mustReadARM ( ) { 
 - writeOneTransaction ( 1 ) ; 
 - 
 - / / Read from table 
 - / / System . out . println ( " mustReadARM . " ) ; 
 - try ( ReadTransaction t = new ReadTransaction ( db ) ) { 
 - EmployeeTable employees = new EmployeeTable ( t ) ; 
 - assertEquals ( true , employees . isValid ( ) ) ; 
 - assertEquals ( 1 , employees . size ( ) ) ; 
 + public void testAddEmptyRowWithPrimaryKeyNullStringThrows ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( null ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 } 
 - catch ( Throwable e ) { 
 + } 
 
 + public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows ( ) { 
 + Table t = getTableWithIntegerPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( " Foo " ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 } 
 } 
 - * / 
 + 
 + public void testAddEmptyRowWithPrimaryKeyString ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + long rowIndex = t . addEmptyRowWithPrimaryKey ( " Foo " ) ; 
 + assertEquals ( 1 , t . size ( ) ) ; 
 + assertEquals ( " Foo " , t . getRow ( rowIndex ) . getString ( 0 ) ) ; 
 + } 
 + 
 + public void testAddEmptyRowWithPrimaryKeyLong ( ) { 
 + Table t = getTableWithIntegerPrimaryKey ( ) ; 
 + long rowIndex = t . addEmptyRowWithPrimaryKey ( 42 ) ; 
 + assertEquals ( 1 , t . size ( ) ) ; 
 + assertEquals ( 42 , t . getRow ( rowIndex ) . getLong ( 0 ) ) ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index df3156b . . e6ad153 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 1089 , 6 + 1089 , 47 @ @ public final class Realm implements Closeable { 
 return get ( clazz , rowIndex ) ; 
 } 
 
 + / * * 
 + * Creates a new object inside the Realm with the Primary key value initially set . 
 + * If the value violates the primary key constraint , no object will be added and and 
 + * { @ link RealmException will be thrown } . 
 + * 
 + * @ param clazz The Class of the object to create 
 + * @ param primaryKeyValue Value for the primary key field . 
 + * @ return The new object 
 + * @ throws { @ link RealmException } if object could not be created . 
 + * / 
 + < E extends RealmObject > E createObject ( Class < E > clazz , Object primaryKeyValue ) { 
 + Table table ; 
 + table = tables . get ( clazz ) ; 
 + if ( table = = null ) { 
 + Class < ? > generatedClass = getProxyClass ( clazz ) ; 
 + 
 + Method method = initTableMethods . get ( generatedClass ) ; 
 + if ( method = = null ) { 
 + try { 
 + method = generatedClass . getMethod ( " initTable " , new Class [ ] { ImplicitTransaction . class } ) ; 
 + } catch ( NoSuchMethodException e ) { 
 + throw new RealmException ( " Could not find the initTable ( ) method in generated proxy class : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } 
 + initTableMethods . put ( generatedClass , method ) ; 
 + } 
 + 
 + try { 
 + table = ( Table ) method . invoke ( null , transaction ) ; 
 + tables . put ( clazz , table ) ; 
 + } catch ( IllegalAccessException e ) { 
 + throw new RealmException ( " Could not launch the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } catch ( InvocationTargetException e ) { 
 + e . printStackTrace ( ) ; 
 + throw new RealmException ( " An exception occurred while running the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } 
 + } 
 + 
 + long rowIndex = table . addEmptyRowWithPrimaryKey ( primaryKeyValue ) ; 
 + return get ( clazz , rowIndex ) ; 
 + } 
 + 
 private Class < ? > getProxyClass ( Class < ? > clazz ) { 
 
 String simpleClassName = getClassSimpleName ( clazz ) ; 
 diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java 
 index 42d28b0 . . 83be1fd 100644 
 - - - a / realm / src / main / java / io / realm / internal / Table . java 
 + + + b / realm / src / main / java / io / realm / internal / Table . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . internal ; 
 import java . io . Closeable ; 
 import java . util . Date ; 
 
 + import io . realm . annotations . PrimaryKey ; 
 import io . realm . exceptions . RealmException ; 
 
 
 @ @ - 364 , 7 + 365 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 
 protected native void nativeMoveLastOver ( long nativeTablePtr , long rowIndex ) ; 
 
 - / / Row Handling methods . 
 public long addEmptyRow ( ) { 
 checkImmutable ( ) ; 
 if ( hasPrimaryKey ( ) ) { 
 @ @ - 390 , 6 + 390 , 54 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 return nativeAddEmptyRow ( nativePtr , 1 ) ; 
 } 
 
 + public long addEmptyRowWithPrimaryKey ( Object primaryKeyValue ) { 
 + checkImmutable ( ) ; 
 + if ( hasPrimaryKey ( ) ) { 
 + long primaryKeyColumnIndex = getPrimaryKey ( ) ; 
 + ColumnType type = getColumnType ( primaryKeyColumnIndex ) ; 
 + long rowIndex ; 
 + Row row ; 
 + 
 + / / Add with with primary key initially set 
 + switch ( type ) { 
 + case STRING : 
 + if ( ! ( primaryKeyValue instanceof String ) ) { 
 + throw new IllegalArgumentException ( " Primary key value is not a String : " + primaryKeyValue ) ; 
 + } 
 + if ( findFirstString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ! = NO _ MATCH ) { 
 + throwDuplicatePrimaryKeyException ( primaryKeyValue ) ; 
 + } 
 + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; 
 + row = getRow ( rowIndex ) ; 
 + row . setString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ; 
 + break ; 
 + 
 + case INTEGER : 
 + long pkValue ; 
 + try { 
 + pkValue = new Long ( primaryKeyValue . toString ( ) ) ; 
 + } catch ( RuntimeException e ) { 
 + throw new IllegalArgumentException ( " Primary key value is not a long : " + primaryKeyValue ) ; 
 + } 
 + if ( findFirstLong ( primaryKeyColumnIndex , pkValue ) ! = NO _ MATCH ) { 
 + throwDuplicatePrimaryKeyException ( pkValue ) ; 
 + } 
 + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; 
 + row = getRow ( rowIndex ) ; 
 + row . setLong ( primaryKeyColumnIndex , pkValue ) ; 
 + break ; 
 + 
 + default : 
 + throw new RealmException ( " Cannot check for duplicate rows for unsupported primary key type : " + type ) ; 
 + } 
 + 
 + return rowIndex ; 
 + 
 + } else { 
 + throw new IllegalStateException ( getName ( ) + " has no primary key defined " ) ; 
 + } 
 + } 
 + 
 public long addEmptyRows ( long rows ) { 
 checkImmutable ( ) ; 
 if ( rows < 1 ) {
