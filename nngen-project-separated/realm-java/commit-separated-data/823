BLEU SCORE: 0.027611988917697356

TEST MSG: convert println calls to Gradle info level logging
GENERATED MSG: Add unit tests for the bytecode manipulation

TEST DIFF (one line): diff - - git a / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy b / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy <nl> index 569331b . . 81fe380 100644 <nl> - - - a / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy <nl> + + + b / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy <nl> @ @ - 24 , 10 + 24 , 13 @ @ import javassist . CtNewMethod <nl> import javassist . NotFoundException <nl> import javassist . expr . ExprEditor <nl> import javassist . expr . FieldAccess <nl> + import org . slf4j . Logger <nl> + import org . slf4j . LoggerFactory <nl> <nl> class BytecodeModifier { <nl> public static void addRealmAccessors ( CtClass clazz ) { <nl> - println ( " Realm : Adding accessors to $ { clazz . simpleName } " ) <nl> + Logger logger = LoggerFactory . getLogger ( ' realm - logger ' ) <nl> + logger . info " Realm : Adding accessors to $ { clazz . simpleName } " <nl> clazz . declaredFields . each { CtField field - > <nl> try { <nl> clazz . getDeclaredMethod ( " realmGetter \ $ $ { field . name } " ) <nl> @ @ - 43 , 8 + 46 , 9 @ @ class BytecodeModifier { <nl> } <nl> <nl> public static void useRealmAccessors ( CtClass clazz , List < CtField > managedFields ) { <nl> + Logger logger = LoggerFactory . getLogger ( ' realm - logger ' ) <nl> clazz . getDeclaredBehaviors ( ) . each { behavior - > <nl> - println " Behavior : $ { behavior . name } " <nl> + logger . info " Behavior : $ { behavior . name } " <nl> if ( ! behavior . name . startsWith ( ' realmGetter $ ' ) & & ! behavior . name . startsWith ( ' realmSetter $ ' ) ) { <nl> behavior . instrument ( new ExpressionEditor ( managedFields , clazz , behavior ) ) <nl> } <nl> @ @ - 64 , 8 + 68 , 9 @ @ class BytecodeModifier { <nl> <nl> @ Override <nl> void edit ( FieldAccess fieldAccess ) throws CannotCompileException { <nl> + Logger logger = LoggerFactory . getLogger ( ' realm - logger ' ) <nl> try { <nl> - println " Field being accessed : $ { fieldAccess . className } . $ { fieldAccess . fieldName } " <nl> + logger . info " Field being accessed : $ { fieldAccess . className } . $ { fieldAccess . fieldName } " <nl> def flag = false <nl> managedFields . each { <nl> if ( fieldAccess . className . equals ( it . declaringClass . name ) & & fieldAccess . fieldName . equals ( it . name ) ) { <nl> @ @ - 73 , 8 + 78 , 8 @ @ class BytecodeModifier { <nl> } <nl> } <nl> if ( flag ) { <nl> - println ( " Realm : Manipulating $ { ctClass . simpleName } . $ { behavior . name } ( ) : $ { fieldAccess . fieldName } " ) <nl> - println ( " Methods : $ { ctClass . declaredMethods } " ) <nl> + logger . info " Realm : Manipulating $ { ctClass . simpleName } . $ { behavior . name } ( ) : $ { fieldAccess . fieldName } " <nl> + logger . info " Methods : $ { ctClass . declaredMethods } " <nl> def fieldName = fieldAccess . fieldName <nl> if ( fieldAccess . isReader ( ) ) { <nl> fieldAccess . replace ( ' $ _ = $ 0 . realmGetter $ ' + fieldName + ' ( ) ; ' ) <nl> diff - - git a / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy b / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy <nl> index 8f58daa . . 1998871 100644 <nl> - - - a / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy <nl> + + + b / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy <nl> @ @ - 25 , 11 + 25 , 15 @ @ import groovy . io . FileType <nl> import io . realm . annotations . Ignore <nl> import javassist . ClassPool <nl> import javassist . LoaderClassPath <nl> + import org . slf4j . Logger <nl> + import org . slf4j . LoggerFactory <nl> <nl> import static com . android . build . api . transform . QualifiedContent . * <nl> <nl> class RealmTransformer extends Transform { <nl> <nl> + private Logger logger = LoggerFactory . getLogger ( ' realm - logger ' ) <nl> + <nl> @ Override <nl> String getName ( ) { <nl> return " RealmTransformer " <nl> @ @ - 58 , 7 + 62 , 7 @ @ class RealmTransformer extends Transform { <nl> <nl> final ArrayList < File > folders = [ ] <nl> inputs . each { TransformInput input - > <nl> - println " Directory inputs : $ { input . directoryInputs * . file } " <nl> + logger . info " Directory inputs : $ { input . directoryInputs * . file } " <nl> folders . addAll ( input . directoryInputs * . file ) <nl> } <nl> <nl> @ @ - 94 , 15 + 98 , 15 @ @ class RealmTransformer extends Transform { <nl> classPool . appendClassPath ( folder . canonicalPath ) <nl> } <nl> <nl> - println " Contains io . realm . RealmList : $ { classPool . getOrNull ( ' io . realm . RealmList ' ) } " <nl> + logger . info " Contains io . realm . RealmList : $ { classPool . getOrNull ( ' io . realm . RealmList ' ) } " <nl> <nl> def proxyClasses = classFiles . findAll { key , value - > key . name . endsWith ( ' RealmProxy . class ' ) } <nl> - println " Proxy Classes : $ { proxyClasses * . value } " <nl> + logger . info " Proxy Classes : $ { proxyClasses * . value } " <nl> <nl> def modelClasses = proxyClasses . collect { key , value - > <nl> classPool . getCtClass ( classFiles . get ( key ) ) . superclass <nl> } <nl> - println " Model Classes : $ { modelClasses * . name } " <nl> + logger . info " Model Classes : $ { modelClasses * . name } " <nl> <nl> def managedFields = [ ] <nl> modelClasses . each { <nl> @ @ - 110 , 12 + 114 , 12 @ @ class RealmTransformer extends Transform { <nl> it . getAnnotation ( Ignore . class ) = = null <nl> } ) <nl> } <nl> - println " Managed Fields : $ { managedFields * . name } " <nl> + logger . info " Managed Fields : $ { managedFields * . name } " <nl> <nl> modelClasses . each { BytecodeModifier . addRealmAccessors ( it ) } <nl> <nl> classFiles . each { key , value - > <nl> - println " Modifying class $ { value } " <nl> + logger . info " Modifying class $ { value } " <nl> def ctClass = classPool . getCtClass ( value ) <nl> BytecodeModifier . useRealmAccessors ( ctClass , managedFields ) <nl> ctClass . writeFile ( outputProvider . getContentLocation (
NEAREST DIFF (one line): diff - - git a / gradle - plugin / build . gradle b / gradle - plugin / build . gradle <nl> index 6beb56c . . c21be4b 100644 <nl> - - - a / gradle - plugin / build . gradle <nl> + + + b / gradle - plugin / build . gradle <nl> @ @ - 28 , 6 + 28 , 10 @ @ dependencies { <nl> compile ' org . jetbrains . kotlin : kotlin - gradle - plugin : 1 . 0 . 0 - beta - 3595 ' <nl> compile " io . realm : realm - annotations : $ { version } " <nl> compile " io . realm : realm - android : $ { version } @ jar " <nl> + <nl> + testCompile ( ' org . spockframework : spock - core : 1 . 0 - groovy - 2 . 4 ' ) { <nl> + exclude module : ' groovy - all ' <nl> + } <nl> } <nl> <nl> / / for Ant filter <nl> diff - - git a / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy b / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy <nl> new file mode 100644 <nl> index 0000000 . . 3f3beca <nl> - - - / dev / null <nl> + + + b / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy <nl> @ @ - 0 , 0 + 1 , 73 @ @ <nl> + package io . realm . gradle <nl> + <nl> + import javassist . CannotCompileException <nl> + import javassist . CtBehavior <nl> + import javassist . CtClass <nl> + import javassist . CtField <nl> + import javassist . CtNewMethod <nl> + import javassist . NotFoundException <nl> + import javassist . expr . ExprEditor <nl> + import javassist . expr . FieldAccess <nl> + <nl> + class BytecodeModifier { <nl> + public static void addRealmAccessors ( CtClass clazz ) { <nl> + println ( " Realm : Adding accessors to $ { clazz . simpleName } " ) <nl> + clazz . declaredFields . each { CtField field - > <nl> + try { <nl> + clazz . getDeclaredMethod ( " realmGetter \ $ $ { field . name } " ) <nl> + } catch ( NotFoundException ignored ) { <nl> + clazz . addMethod ( CtNewMethod . getter ( " realmGetter \ $ $ { field . name } " , field ) ) <nl> + } <nl> + try { <nl> + clazz . getDeclaredMethod ( " realmSetter \ $ $ { field . name } " ) <nl> + } catch ( NotFoundException ignored ) { <nl> + clazz . addMethod ( CtNewMethod . setter ( " realmSetter \ $ $ { field . name } " , field ) ) <nl> + } <nl> + } <nl> + } <nl> + <nl> + public static void useRealmAccessors ( CtClass clazz , List < CtField > managedFields ) { <nl> + clazz . getDeclaredBehaviors ( ) . each { behavior - > <nl> + println " Behavior : $ { behavior . name } " <nl> + if ( ! behavior . name . startsWith ( ' realmGetter $ ' ) & & ! behavior . name . startsWith ( ' realmSetter $ ' ) ) { <nl> + behavior . instrument ( new ExpressionEditor ( managedFields , clazz , behavior ) ) <nl> + } <nl> + } <nl> + } <nl> + <nl> + private static class ExpressionEditor extends ExprEditor { <nl> + List < CtField > managedFields <nl> + CtClass ctClass <nl> + CtBehavior behavior <nl> + <nl> + ExpressionEditor ( List < CtField > managedFields , CtClass ctClass , CtBehavior behavior ) { <nl> + this . managedFields = managedFields <nl> + this . ctClass = ctClass <nl> + this . behavior = behavior <nl> + } <nl> + <nl> + @ Override <nl> + void edit ( FieldAccess fieldAccess ) throws CannotCompileException { <nl> + try { <nl> + println " Field being accessed : $ { fieldAccess . className } . $ { fieldAccess . fieldName } " <nl> + def flag = false <nl> + managedFields . each { <nl> + if ( fieldAccess . className . equals ( it . declaringClass . name ) & & fieldAccess . fieldName . equals ( it . name ) ) { <nl> + flag = true <nl> + } <nl> + } <nl> + if ( flag ) { <nl> + println ( " Realm : Manipulating $ { ctClass . simpleName } . $ { behavior . name } ( ) : $ { fieldAccess . fieldName } " ) <nl> + println ( " Methods : $ { ctClass . declaredMethods } " ) <nl> + def fieldName = fieldAccess . fieldName <nl> + if ( fieldAccess . isReader ( ) ) { <nl> + fieldAccess . replace ( ' $ _ = $ 0 . realmGetter $ ' + fieldName + ' ( ) ; ' ) <nl> + } else if ( fieldAccess . isWriter ( ) ) { <nl> + fieldAccess . replace ( ' $ 0 . realmSetter $ ' + fieldName + ' ( $ 1 ) ; ' ) <nl> + } <nl> + } <nl> + } catch ( NotFoundException ignored ) { <nl> + } <nl> + } <nl> + } <nl> + } <nl> diff - - git a / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy b / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy <nl> index 18f2f1e . . 7ed3423 100644 <nl> - - - a / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy <nl> + + + b / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy <nl> @ @ - 6 , 9 + 6 , 8 @ @ import com . google . common . collect . ImmutableSet <nl> import com . google . common . collect . Sets <nl> import groovy . io . FileType <nl> import io . realm . annotations . Ignore <nl> - import javassist . * <nl> - import javassist . expr . ExprEditor <nl> - import javassist . expr . FieldAccess <nl> + import javassist . ClassPool <nl> + import javassist . LoaderClassPath <nl> <nl> import static com . android . build . api . transform . QualifiedContent . * <nl> <nl> @ @ - 94 , 76 + 93 , 15 @ @ class RealmTransformer extends Transform { <nl> } <nl> println " Managed Fields : $ { managedFields * . name } " <nl> <nl> - modelClasses . each { addRealmAccessors ( it ) } <nl> + modelClasses . each { BytecodeModifier . addRealmAccessors ( it ) } <nl> <nl> classFiles . each { key , value - > <nl> println " Modifying class $ { value } " <nl> def ctClass = classPool . getCtClass ( value ) <nl> - useRealmAccessors ( ctClass , managedFields ) <nl> + BytecodeModifier . useRealmAccessors ( ctClass , managedFields ) <nl> ctClass . writeFile ( outputProvider . getContentLocation ( <nl> ' realm ' , getInputTypes ( ) , getScopes ( ) , Format . DIRECTORY ) . canonicalPath ) <nl> } <nl> } <nl> <nl> - private void useRealmAccessors ( CtClass clazz , List < CtField > managedFields ) { <nl> - clazz . getDeclaredBehaviors ( ) . each { behavior - > <nl> - println " Behavior : $ { behavior . name } " <nl> - if ( ! behavior . name . startsWith ( ' realmGetter $ ' ) & & ! behavior . name . startsWith ( ' realmSetter $ ' ) ) { <nl> - behavior . instrument ( new ExpressionEditor ( managedFields , clazz , behavior ) ) <nl> - } <nl> - } <nl> - } <nl> - <nl> - private static void addRealmAccessors ( CtClass clazz ) { <nl> - println ( " Realm : Adding accessors to $ { clazz . simpleName } " ) <nl> - clazz . declaredFields . each { CtField field - > <nl> - try { <nl> - clazz . getDeclaredMethod ( " realmGetter \ $ $ { field . name } " ) <nl> - } catch ( NotFoundException ignored ) { <nl> - clazz . addMethod ( CtNewMethod . getter ( " realmGetter \ $ $ { field . name } " , field ) ) <nl> - } <nl> - try { <nl> - clazz . getDeclaredMethod ( " realmSetter \ $ $ { field . name } " ) <nl> - } catch ( NotFoundException ignored ) { <nl> - clazz . addMethod ( CtNewMethod . setter ( " realmSetter \ $ $ { field . name } " , field ) ) <nl> - } <nl> - } <nl> - } <nl> - <nl> - private class ExpressionEditor extends ExprEditor { <nl> - List < CtField > managedFields <nl> - CtClass ctClass <nl> - CtBehavior behavior <nl> - <nl> - ExpressionEditor ( List < CtField > managedFields , CtClass ctClass , CtBehavior behavior ) { <nl> - this . managedFields = managedFields <nl> - this . ctClass = ctClass <nl> - this . behavior = behavior <nl> - } <nl> - <nl> - @ Override <nl> - void edit ( FieldAccess fieldAccess ) throws CannotCompileException { <nl> - try { <nl> - println " Field being accessed : $ { fieldAccess . className } . $ { fieldAccess . fieldName } " <nl> - def flag = false <nl> - managedFields . each { <nl> - if ( fieldAccess . className . equals ( it . declaringClass . name ) & & fieldAccess . fieldName . equals ( it . name ) ) { <nl> - flag = true <nl> - } <nl> - } <nl> - if ( flag ) { <nl> - println ( " Realm : Manipulating $ { ctClass . simpleName } . $ { behavior . name } ( ) : $ { fieldAccess . fieldName } " ) <nl> - println ( " Methods : $ { ctClass . declaredMethods } " ) <nl> - def fieldName = fieldAccess . fieldName <nl> - if ( fieldAccess . isReader ( ) ) { <nl> - fieldAccess . replace ( ' $ _ = $ 0 . realmGetter $ ' + fieldName + ' ( ) ; ' ) <nl> - } else if ( fieldAccess . isWriter ( ) ) { <nl> - fieldAccess . replace ( ' $ 0 . realmSetter $ ' + fieldName + ' ( $ 1 ) ; ' ) <nl> - } <nl> - } <nl> - } catch ( NotFoundException ignored ) { <nl> - } <nl> - } <nl> - } <nl> - <nl> } <nl> diff - - git a / gradle - plugin / src / test / groovy / io / realm / gradle / BytecodeModifierTest . groovy b / gradle - plugin / src / test / groovy / io / realm / gradle / BytecodeModifierTest . groovy <nl> new file mode 100644 <nl> index 0000000 . . b5e6815 <nl> - - - / dev / null <nl> + + + b / gradle - plugin / src / test / groovy / io / realm / gradle / BytecodeModifierTest . groovy <nl> @ @ - 0 , 0 + 1 , 69 @ @ <nl> + package io . realm . gradle <nl> + import javassist . ClassPool <nl> + import javassist . CtClass <nl> + import javassist . CtField <nl> + import javassist . CtNewMethod <nl> + import javassist . bytecode . CodeIterator <nl> + import javassist . bytecode . Opcode <nl> + import spock . lang . Specification <nl> + <nl> + import java . lang . reflect . Modifier <nl> + <nl> + class BytecodeModifierTest extends Specification { <nl> + def " AddRealmAccessors " ( ) { <nl> + setup : ' generate an empty class ' <nl> + def classPool = ClassPool . getDefault ( ) <nl> + def ctClass = classPool . makeClass ( ' testClass ' ) <nl> + <nl> + and : ' add a field ' <nl> + def ctField = new CtField ( CtClass . intType , ' age ' , ctClass ) <nl> + ctClass . addField ( ctField ) <nl> + <nl> + when : ' the accessors are added ' <nl> + BytecodeModifier . addRealmAccessors ( ctClass ) <nl> + <nl> + then : ' the accessors are generated ' <nl> + def ctMethods = ctClass . getDeclaredMethods ( ) <nl> + def methodNames = ctMethods . name <nl> + methodNames . contains ( ' realmGetter $ age ' ) <nl> + methodNames . contains ( ' realmSetter $ age ' ) <nl> + <nl> + and : ' the accessors are public ' <nl> + ctMethods . each { <nl> + it . getModifiers ( ) = = Modifier . PUBLIC <nl> + } <nl> + } <nl> + <nl> + def " UseRealmAccessors " ( ) { <nl> + setup : ' generate an empty class ' <nl> + def classPool = ClassPool . getDefault ( ) <nl> + def ctClass = classPool . makeClass ( ' testClass ' ) <nl> + <nl> + and : ' add a field ' <nl> + def ctField = new CtField ( CtClass . intType , ' age ' , ctClass ) <nl> + ctClass . addField ( ctField ) <nl> + <nl> + and : ' add a method that uses such field ' <nl> + def ctMethod = CtNewMethod . make ( ' public boolean canDrive ( ) { return this . age > = 18 ; } ' , ctClass ) <nl> + ctClass . addMethod ( ctMethod ) <nl> + <nl> + and : ' realm accessors are added ' <nl> + BytecodeModifier . addRealmAccessors ( ctClass ) <nl> + <nl> + when : ' the field use is replaced by the accessor ' <nl> + BytecodeModifier . useRealmAccessors ( ctClass , [ ctField ] ) <nl> + <nl> + then : ' the field is not used in the method anymore ' <nl> + def methodInfo = ctMethod . getMethodInfo ( ) <nl> + def codeAttribute = methodInfo . getCodeAttribute ( ) <nl> + def fieldIsUsed = false <nl> + for ( CodeIterator ci = codeAttribute . iterator ( ) ; ci . hasNext ( ) ; ) { <nl> + int index = ci . next ( ) ; <nl> + int op = ci . byteAt ( index ) ; <nl> + if ( op = = Opcode . GETFIELD ) { <nl> + fieldIsUsed = true <nl> + } <nl> + } <nl> + ! fieldIsUsed <nl> + } <nl> + }

TEST DIFF:
diff - - git a / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy b / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy 
 index 569331b . . 81fe380 100644 
 - - - a / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy 
 + + + b / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy 
 @ @ - 24 , 10 + 24 , 13 @ @ import javassist . CtNewMethod 
 import javassist . NotFoundException 
 import javassist . expr . ExprEditor 
 import javassist . expr . FieldAccess 
 + import org . slf4j . Logger 
 + import org . slf4j . LoggerFactory 
 
 class BytecodeModifier { 
 public static void addRealmAccessors ( CtClass clazz ) { 
 - println ( " Realm : Adding accessors to $ { clazz . simpleName } " ) 
 + Logger logger = LoggerFactory . getLogger ( ' realm - logger ' ) 
 + logger . info " Realm : Adding accessors to $ { clazz . simpleName } " 
 clazz . declaredFields . each { CtField field - > 
 try { 
 clazz . getDeclaredMethod ( " realmGetter \ $ $ { field . name } " ) 
 @ @ - 43 , 8 + 46 , 9 @ @ class BytecodeModifier { 
 } 
 
 public static void useRealmAccessors ( CtClass clazz , List < CtField > managedFields ) { 
 + Logger logger = LoggerFactory . getLogger ( ' realm - logger ' ) 
 clazz . getDeclaredBehaviors ( ) . each { behavior - > 
 - println " Behavior : $ { behavior . name } " 
 + logger . info " Behavior : $ { behavior . name } " 
 if ( ! behavior . name . startsWith ( ' realmGetter $ ' ) & & ! behavior . name . startsWith ( ' realmSetter $ ' ) ) { 
 behavior . instrument ( new ExpressionEditor ( managedFields , clazz , behavior ) ) 
 } 
 @ @ - 64 , 8 + 68 , 9 @ @ class BytecodeModifier { 
 
 @ Override 
 void edit ( FieldAccess fieldAccess ) throws CannotCompileException { 
 + Logger logger = LoggerFactory . getLogger ( ' realm - logger ' ) 
 try { 
 - println " Field being accessed : $ { fieldAccess . className } . $ { fieldAccess . fieldName } " 
 + logger . info " Field being accessed : $ { fieldAccess . className } . $ { fieldAccess . fieldName } " 
 def flag = false 
 managedFields . each { 
 if ( fieldAccess . className . equals ( it . declaringClass . name ) & & fieldAccess . fieldName . equals ( it . name ) ) { 
 @ @ - 73 , 8 + 78 , 8 @ @ class BytecodeModifier { 
 } 
 } 
 if ( flag ) { 
 - println ( " Realm : Manipulating $ { ctClass . simpleName } . $ { behavior . name } ( ) : $ { fieldAccess . fieldName } " ) 
 - println ( " Methods : $ { ctClass . declaredMethods } " ) 
 + logger . info " Realm : Manipulating $ { ctClass . simpleName } . $ { behavior . name } ( ) : $ { fieldAccess . fieldName } " 
 + logger . info " Methods : $ { ctClass . declaredMethods } " 
 def fieldName = fieldAccess . fieldName 
 if ( fieldAccess . isReader ( ) ) { 
 fieldAccess . replace ( ' $ _ = $ 0 . realmGetter $ ' + fieldName + ' ( ) ; ' ) 
 diff - - git a / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy b / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy 
 index 8f58daa . . 1998871 100644 
 - - - a / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy 
 + + + b / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy 
 @ @ - 25 , 11 + 25 , 15 @ @ import groovy . io . FileType 
 import io . realm . annotations . Ignore 
 import javassist . ClassPool 
 import javassist . LoaderClassPath 
 + import org . slf4j . Logger 
 + import org . slf4j . LoggerFactory 
 
 import static com . android . build . api . transform . QualifiedContent . * 
 
 class RealmTransformer extends Transform { 
 
 + private Logger logger = LoggerFactory . getLogger ( ' realm - logger ' ) 
 + 
 @ Override 
 String getName ( ) { 
 return " RealmTransformer " 
 @ @ - 58 , 7 + 62 , 7 @ @ class RealmTransformer extends Transform { 
 
 final ArrayList < File > folders = [ ] 
 inputs . each { TransformInput input - > 
 - println " Directory inputs : $ { input . directoryInputs * . file } " 
 + logger . info " Directory inputs : $ { input . directoryInputs * . file } " 
 folders . addAll ( input . directoryInputs * . file ) 
 } 
 
 @ @ - 94 , 15 + 98 , 15 @ @ class RealmTransformer extends Transform { 
 classPool . appendClassPath ( folder . canonicalPath ) 
 } 
 
 - println " Contains io . realm . RealmList : $ { classPool . getOrNull ( ' io . realm . RealmList ' ) } " 
 + logger . info " Contains io . realm . RealmList : $ { classPool . getOrNull ( ' io . realm . RealmList ' ) } " 
 
 def proxyClasses = classFiles . findAll { key , value - > key . name . endsWith ( ' RealmProxy . class ' ) } 
 - println " Proxy Classes : $ { proxyClasses * . value } " 
 + logger . info " Proxy Classes : $ { proxyClasses * . value } " 
 
 def modelClasses = proxyClasses . collect { key , value - > 
 classPool . getCtClass ( classFiles . get ( key ) ) . superclass 
 } 
 - println " Model Classes : $ { modelClasses * . name } " 
 + logger . info " Model Classes : $ { modelClasses * . name } " 
 
 def managedFields = [ ] 
 modelClasses . each { 
 @ @ - 110 , 12 + 114 , 12 @ @ class RealmTransformer extends Transform { 
 it . getAnnotation ( Ignore . class ) = = null 
 } ) 
 } 
 - println " Managed Fields : $ { managedFields * . name } " 
 + logger . info " Managed Fields : $ { managedFields * . name } " 
 
 modelClasses . each { BytecodeModifier . addRealmAccessors ( it ) } 
 
 classFiles . each { key , value - > 
 - println " Modifying class $ { value } " 
 + logger . info " Modifying class $ { value } " 
 def ctClass = classPool . getCtClass ( value ) 
 BytecodeModifier . useRealmAccessors ( ctClass , managedFields ) 
 ctClass . writeFile ( outputProvider . getContentLocation (

NEAREST DIFF:
diff - - git a / gradle - plugin / build . gradle b / gradle - plugin / build . gradle 
 index 6beb56c . . c21be4b 100644 
 - - - a / gradle - plugin / build . gradle 
 + + + b / gradle - plugin / build . gradle 
 @ @ - 28 , 6 + 28 , 10 @ @ dependencies { 
 compile ' org . jetbrains . kotlin : kotlin - gradle - plugin : 1 . 0 . 0 - beta - 3595 ' 
 compile " io . realm : realm - annotations : $ { version } " 
 compile " io . realm : realm - android : $ { version } @ jar " 
 + 
 + testCompile ( ' org . spockframework : spock - core : 1 . 0 - groovy - 2 . 4 ' ) { 
 + exclude module : ' groovy - all ' 
 + } 
 } 
 
 / / for Ant filter 
 diff - - git a / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy b / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy 
 new file mode 100644 
 index 0000000 . . 3f3beca 
 - - - / dev / null 
 + + + b / gradle - plugin / src / main / groovy / io / realm / gradle / BytecodeModifier . groovy 
 @ @ - 0 , 0 + 1 , 73 @ @ 
 + package io . realm . gradle 
 + 
 + import javassist . CannotCompileException 
 + import javassist . CtBehavior 
 + import javassist . CtClass 
 + import javassist . CtField 
 + import javassist . CtNewMethod 
 + import javassist . NotFoundException 
 + import javassist . expr . ExprEditor 
 + import javassist . expr . FieldAccess 
 + 
 + class BytecodeModifier { 
 + public static void addRealmAccessors ( CtClass clazz ) { 
 + println ( " Realm : Adding accessors to $ { clazz . simpleName } " ) 
 + clazz . declaredFields . each { CtField field - > 
 + try { 
 + clazz . getDeclaredMethod ( " realmGetter \ $ $ { field . name } " ) 
 + } catch ( NotFoundException ignored ) { 
 + clazz . addMethod ( CtNewMethod . getter ( " realmGetter \ $ $ { field . name } " , field ) ) 
 + } 
 + try { 
 + clazz . getDeclaredMethod ( " realmSetter \ $ $ { field . name } " ) 
 + } catch ( NotFoundException ignored ) { 
 + clazz . addMethod ( CtNewMethod . setter ( " realmSetter \ $ $ { field . name } " , field ) ) 
 + } 
 + } 
 + } 
 + 
 + public static void useRealmAccessors ( CtClass clazz , List < CtField > managedFields ) { 
 + clazz . getDeclaredBehaviors ( ) . each { behavior - > 
 + println " Behavior : $ { behavior . name } " 
 + if ( ! behavior . name . startsWith ( ' realmGetter $ ' ) & & ! behavior . name . startsWith ( ' realmSetter $ ' ) ) { 
 + behavior . instrument ( new ExpressionEditor ( managedFields , clazz , behavior ) ) 
 + } 
 + } 
 + } 
 + 
 + private static class ExpressionEditor extends ExprEditor { 
 + List < CtField > managedFields 
 + CtClass ctClass 
 + CtBehavior behavior 
 + 
 + ExpressionEditor ( List < CtField > managedFields , CtClass ctClass , CtBehavior behavior ) { 
 + this . managedFields = managedFields 
 + this . ctClass = ctClass 
 + this . behavior = behavior 
 + } 
 + 
 + @ Override 
 + void edit ( FieldAccess fieldAccess ) throws CannotCompileException { 
 + try { 
 + println " Field being accessed : $ { fieldAccess . className } . $ { fieldAccess . fieldName } " 
 + def flag = false 
 + managedFields . each { 
 + if ( fieldAccess . className . equals ( it . declaringClass . name ) & & fieldAccess . fieldName . equals ( it . name ) ) { 
 + flag = true 
 + } 
 + } 
 + if ( flag ) { 
 + println ( " Realm : Manipulating $ { ctClass . simpleName } . $ { behavior . name } ( ) : $ { fieldAccess . fieldName } " ) 
 + println ( " Methods : $ { ctClass . declaredMethods } " ) 
 + def fieldName = fieldAccess . fieldName 
 + if ( fieldAccess . isReader ( ) ) { 
 + fieldAccess . replace ( ' $ _ = $ 0 . realmGetter $ ' + fieldName + ' ( ) ; ' ) 
 + } else if ( fieldAccess . isWriter ( ) ) { 
 + fieldAccess . replace ( ' $ 0 . realmSetter $ ' + fieldName + ' ( $ 1 ) ; ' ) 
 + } 
 + } 
 + } catch ( NotFoundException ignored ) { 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy b / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy 
 index 18f2f1e . . 7ed3423 100644 
 - - - a / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy 
 + + + b / gradle - plugin / src / main / groovy / io / realm / gradle / RealmTransformer . groovy 
 @ @ - 6 , 9 + 6 , 8 @ @ import com . google . common . collect . ImmutableSet 
 import com . google . common . collect . Sets 
 import groovy . io . FileType 
 import io . realm . annotations . Ignore 
 - import javassist . * 
 - import javassist . expr . ExprEditor 
 - import javassist . expr . FieldAccess 
 + import javassist . ClassPool 
 + import javassist . LoaderClassPath 
 
 import static com . android . build . api . transform . QualifiedContent . * 
 
 @ @ - 94 , 76 + 93 , 15 @ @ class RealmTransformer extends Transform { 
 } 
 println " Managed Fields : $ { managedFields * . name } " 
 
 - modelClasses . each { addRealmAccessors ( it ) } 
 + modelClasses . each { BytecodeModifier . addRealmAccessors ( it ) } 
 
 classFiles . each { key , value - > 
 println " Modifying class $ { value } " 
 def ctClass = classPool . getCtClass ( value ) 
 - useRealmAccessors ( ctClass , managedFields ) 
 + BytecodeModifier . useRealmAccessors ( ctClass , managedFields ) 
 ctClass . writeFile ( outputProvider . getContentLocation ( 
 ' realm ' , getInputTypes ( ) , getScopes ( ) , Format . DIRECTORY ) . canonicalPath ) 
 } 
 } 
 
 - private void useRealmAccessors ( CtClass clazz , List < CtField > managedFields ) { 
 - clazz . getDeclaredBehaviors ( ) . each { behavior - > 
 - println " Behavior : $ { behavior . name } " 
 - if ( ! behavior . name . startsWith ( ' realmGetter $ ' ) & & ! behavior . name . startsWith ( ' realmSetter $ ' ) ) { 
 - behavior . instrument ( new ExpressionEditor ( managedFields , clazz , behavior ) ) 
 - } 
 - } 
 - } 
 - 
 - private static void addRealmAccessors ( CtClass clazz ) { 
 - println ( " Realm : Adding accessors to $ { clazz . simpleName } " ) 
 - clazz . declaredFields . each { CtField field - > 
 - try { 
 - clazz . getDeclaredMethod ( " realmGetter \ $ $ { field . name } " ) 
 - } catch ( NotFoundException ignored ) { 
 - clazz . addMethod ( CtNewMethod . getter ( " realmGetter \ $ $ { field . name } " , field ) ) 
 - } 
 - try { 
 - clazz . getDeclaredMethod ( " realmSetter \ $ $ { field . name } " ) 
 - } catch ( NotFoundException ignored ) { 
 - clazz . addMethod ( CtNewMethod . setter ( " realmSetter \ $ $ { field . name } " , field ) ) 
 - } 
 - } 
 - } 
 - 
 - private class ExpressionEditor extends ExprEditor { 
 - List < CtField > managedFields 
 - CtClass ctClass 
 - CtBehavior behavior 
 - 
 - ExpressionEditor ( List < CtField > managedFields , CtClass ctClass , CtBehavior behavior ) { 
 - this . managedFields = managedFields 
 - this . ctClass = ctClass 
 - this . behavior = behavior 
 - } 
 - 
 - @ Override 
 - void edit ( FieldAccess fieldAccess ) throws CannotCompileException { 
 - try { 
 - println " Field being accessed : $ { fieldAccess . className } . $ { fieldAccess . fieldName } " 
 - def flag = false 
 - managedFields . each { 
 - if ( fieldAccess . className . equals ( it . declaringClass . name ) & & fieldAccess . fieldName . equals ( it . name ) ) { 
 - flag = true 
 - } 
 - } 
 - if ( flag ) { 
 - println ( " Realm : Manipulating $ { ctClass . simpleName } . $ { behavior . name } ( ) : $ { fieldAccess . fieldName } " ) 
 - println ( " Methods : $ { ctClass . declaredMethods } " ) 
 - def fieldName = fieldAccess . fieldName 
 - if ( fieldAccess . isReader ( ) ) { 
 - fieldAccess . replace ( ' $ _ = $ 0 . realmGetter $ ' + fieldName + ' ( ) ; ' ) 
 - } else if ( fieldAccess . isWriter ( ) ) { 
 - fieldAccess . replace ( ' $ 0 . realmSetter $ ' + fieldName + ' ( $ 1 ) ; ' ) 
 - } 
 - } 
 - } catch ( NotFoundException ignored ) { 
 - } 
 - } 
 - } 
 - 
 } 
 diff - - git a / gradle - plugin / src / test / groovy / io / realm / gradle / BytecodeModifierTest . groovy b / gradle - plugin / src / test / groovy / io / realm / gradle / BytecodeModifierTest . groovy 
 new file mode 100644 
 index 0000000 . . b5e6815 
 - - - / dev / null 
 + + + b / gradle - plugin / src / test / groovy / io / realm / gradle / BytecodeModifierTest . groovy 
 @ @ - 0 , 0 + 1 , 69 @ @ 
 + package io . realm . gradle 
 + import javassist . ClassPool 
 + import javassist . CtClass 
 + import javassist . CtField 
 + import javassist . CtNewMethod 
 + import javassist . bytecode . CodeIterator 
 + import javassist . bytecode . Opcode 
 + import spock . lang . Specification 
 + 
 + import java . lang . reflect . Modifier 
 + 
 + class BytecodeModifierTest extends Specification { 
 + def " AddRealmAccessors " ( ) { 
 + setup : ' generate an empty class ' 
 + def classPool = ClassPool . getDefault ( ) 
 + def ctClass = classPool . makeClass ( ' testClass ' ) 
 + 
 + and : ' add a field ' 
 + def ctField = new CtField ( CtClass . intType , ' age ' , ctClass ) 
 + ctClass . addField ( ctField ) 
 + 
 + when : ' the accessors are added ' 
 + BytecodeModifier . addRealmAccessors ( ctClass ) 
 + 
 + then : ' the accessors are generated ' 
 + def ctMethods = ctClass . getDeclaredMethods ( ) 
 + def methodNames = ctMethods . name 
 + methodNames . contains ( ' realmGetter $ age ' ) 
 + methodNames . contains ( ' realmSetter $ age ' ) 
 + 
 + and : ' the accessors are public ' 
 + ctMethods . each { 
 + it . getModifiers ( ) = = Modifier . PUBLIC 
 + } 
 + } 
 + 
 + def " UseRealmAccessors " ( ) { 
 + setup : ' generate an empty class ' 
 + def classPool = ClassPool . getDefault ( ) 
 + def ctClass = classPool . makeClass ( ' testClass ' ) 
 + 
 + and : ' add a field ' 
 + def ctField = new CtField ( CtClass . intType , ' age ' , ctClass ) 
 + ctClass . addField ( ctField ) 
 + 
 + and : ' add a method that uses such field ' 
 + def ctMethod = CtNewMethod . make ( ' public boolean canDrive ( ) { return this . age > = 18 ; } ' , ctClass ) 
 + ctClass . addMethod ( ctMethod ) 
 + 
 + and : ' realm accessors are added ' 
 + BytecodeModifier . addRealmAccessors ( ctClass ) 
 + 
 + when : ' the field use is replaced by the accessor ' 
 + BytecodeModifier . useRealmAccessors ( ctClass , [ ctField ] ) 
 + 
 + then : ' the field is not used in the method anymore ' 
 + def methodInfo = ctMethod . getMethodInfo ( ) 
 + def codeAttribute = methodInfo . getCodeAttribute ( ) 
 + def fieldIsUsed = false 
 + for ( CodeIterator ci = codeAttribute . iterator ( ) ; ci . hasNext ( ) ; ) { 
 + int index = ci . next ( ) ; 
 + int op = ci . byteAt ( index ) ; 
 + if ( op = = Opcode . GETFIELD ) { 
 + fieldIsUsed = true 
 + } 
 + } 
 + ! fieldIsUsed 
 + } 
 + }
