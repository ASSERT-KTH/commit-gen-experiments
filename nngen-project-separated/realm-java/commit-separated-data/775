BLEU SCORE: 0.2259005009024612

TEST MSG: Add issue template
GENERATED MSG: Added readme

TEST DIFF (one line): diff - - git a / . github / ISSUE _ TEMPLATE . md b / . github / ISSUE _ TEMPLATE . md <nl> new file mode 100644 <nl> index 0000000 . . cce26cc <nl> - - - / dev / null <nl> + + + b / . github / ISSUE _ TEMPLATE . md <nl> @ @ - 0 , 0 + 1 , 35 @ @ <nl> + > In order for us to help you most effectively , please fill out this template when filing <nl> + > an issue . <nl> + > All lines marked as quotes ( ` > ` ) instruct you with what info we expect . <nl> + > Remove this opening paragraph . <nl> + <nl> + # # Goals <nl> + <nl> + > Replace this with what you tried to achieve . <nl> + <nl> + # # Expected Results <nl> + <nl> + > Replace this with what you expected to happen . <nl> + <nl> + # # Actual Results <nl> + <nl> + > Replace this with what actually happened . <nl> + > e . g . the full stack trace with exception messages . <nl> + <nl> + # # Steps to Reproduce <nl> + <nl> + > Provide steps we can follow to reproduce this issue . <nl> + <nl> + # # Code Sample <nl> + <nl> + > Provide a code sample that highlights the issue . <nl> + > If relevant , include your model definitions . <nl> + > For larger code samples , links to external gists or repositories are preferred . <nl> + > Full Android Studio projects that we can compile ourselves are ideal . <nl> + > See https : / / github . com / adam - p / markdown - here / wiki / Markdown - Cheatsheet # code <nl> + > for how to do code formatting . <nl> + <nl> + # # Version of Realm and Tooling <nl> + <nl> + > Describe which version of Realm is effected , which Android Studio version you are using <nl> + > as well as which devices / emulators you have tested on and with what version of Android .
NEAREST DIFF (one line): diff - - git a / RealmAndroid / README . md b / RealmAndroid / README . md <nl> new file mode 100644 <nl> index 0000000 . . 13adedc <nl> - - - / dev / null <nl> + + + b / RealmAndroid / README . md <nl> @ @ - 0 , 0 + 1 , 94 @ @ <nl> + # # Defining a Data Model <nl> + <nl> + Realm data models are defined by implementing a traditional Java Bean ( http : / / en . wikipedia . org / wiki / Java _ Bean ) <nl> + <nl> + 	 public class User { <nl> + <nl> + private int id ; <nl> + private String name ; <nl> + private String email ; <nl> + <nl> + public int getId ( ) { <nl> + return id ; <nl> + } <nl> + <nl> + public void setId ( int id ) { <nl> + this . id = id ; <nl> + } <nl> + <nl> + public String getName ( ) { <nl> + return name ; <nl> + } <nl> + <nl> + public void setName ( String name ) { <nl> + this . name = name ; <nl> + } <nl> + <nl> + public String getEmail ( ) { <nl> + return email ; <nl> + } <nl> + <nl> + public void setEmail ( String email ) { <nl> + this . email = email ; <nl> + } <nl> + <nl> + } <nl> + <nl> + These objects should be instantiated from the RealmCollection using the method create ( ) <nl> + <nl> + # # Instatiating a Realm Collection <nl> + <nl> + To get started with realm we create a new instance of a RealmList , this can be done through a static factory <nl> + <nl> + RealmList < User > users = Realms . list ( context , User . class ) ; <nl> + <nl> + RealmList works as a traditional List , which is just automatically persisted in Realm . <nl> + The Context , is used to get access to a writeable directory on the device , and the Class is used to generate the underlying datamodel . <nl> + <nl> + # # Adding Objects <nl> + <nl> + To add a new object to the RealmList , you add it like you normally do , the only new thing is the way the object is instantiated <nl> + <nl> + 	 User user = users . create ( ) ; <nl> + <nl> + This gives us a new User instance , which we can then populate with data , before adding it to the list . <nl> + <nl> + user . setId ( 0 ) ; <nl> + user . setName ( " John " ) ; <nl> + user . setEmail ( " john @ corporation . com " ) ; <nl> + <nl> + users . add ( user ) ; <nl> + <nl> + <nl> + # # Getting Objects <nl> + <nl> + To retrieve an object from the list <nl> + <nl> + Users user = users . get ( 0 ) ; <nl> + <nl> + This is just like we are used to from a List , the difference here is that the User object is backed by Realm , which means that when you change its values it is automatically persisted . <nl> + <nl> + # # Iterating through Objects <nl> + <nl> + To make a run through all objects in a RealmList you can use a traditional for loop <nl> + <nl> + for ( int i = 0 ; i < users . size ( ) ; i + + ) { <nl> + User u = users . get ( i ) ; <nl> + . . . do something with the object . . . <nl> + } <nl> + <nl> + Or you can take advantage of Iterable <nl> + <nl> + for ( User u : users ) { <nl> + . . . do something with the object . . . <nl> + } <nl> + <nl> + # # Querying <nl> + <nl> + A benefit to using Realm Collections is that you get access to a fast query interface , which enables you to filter the collection <nl> + <nl> + To find all users named " John " you would write <nl> + <nl> + RealmList < User > result = users . where ( ) . equalTo ( " name " , " John " ) ; <nl> + <nl> + This gives you a new list , of users with the name John

TEST DIFF:
diff - - git a / . github / ISSUE _ TEMPLATE . md b / . github / ISSUE _ TEMPLATE . md 
 new file mode 100644 
 index 0000000 . . cce26cc 
 - - - / dev / null 
 + + + b / . github / ISSUE _ TEMPLATE . md 
 @ @ - 0 , 0 + 1 , 35 @ @ 
 + > In order for us to help you most effectively , please fill out this template when filing 
 + > an issue . 
 + > All lines marked as quotes ( ` > ` ) instruct you with what info we expect . 
 + > Remove this opening paragraph . 
 + 
 + # # Goals 
 + 
 + > Replace this with what you tried to achieve . 
 + 
 + # # Expected Results 
 + 
 + > Replace this with what you expected to happen . 
 + 
 + # # Actual Results 
 + 
 + > Replace this with what actually happened . 
 + > e . g . the full stack trace with exception messages . 
 + 
 + # # Steps to Reproduce 
 + 
 + > Provide steps we can follow to reproduce this issue . 
 + 
 + # # Code Sample 
 + 
 + > Provide a code sample that highlights the issue . 
 + > If relevant , include your model definitions . 
 + > For larger code samples , links to external gists or repositories are preferred . 
 + > Full Android Studio projects that we can compile ourselves are ideal . 
 + > See https : / / github . com / adam - p / markdown - here / wiki / Markdown - Cheatsheet # code 
 + > for how to do code formatting . 
 + 
 + # # Version of Realm and Tooling 
 + 
 + > Describe which version of Realm is effected , which Android Studio version you are using 
 + > as well as which devices / emulators you have tested on and with what version of Android .

NEAREST DIFF:
diff - - git a / RealmAndroid / README . md b / RealmAndroid / README . md 
 new file mode 100644 
 index 0000000 . . 13adedc 
 - - - / dev / null 
 + + + b / RealmAndroid / README . md 
 @ @ - 0 , 0 + 1 , 94 @ @ 
 + # # Defining a Data Model 
 + 
 + Realm data models are defined by implementing a traditional Java Bean ( http : / / en . wikipedia . org / wiki / Java _ Bean ) 
 + 
 + 	 public class User { 
 + 
 + private int id ; 
 + private String name ; 
 + private String email ; 
 + 
 + public int getId ( ) { 
 + return id ; 
 + } 
 + 
 + public void setId ( int id ) { 
 + this . id = id ; 
 + } 
 + 
 + public String getName ( ) { 
 + return name ; 
 + } 
 + 
 + public void setName ( String name ) { 
 + this . name = name ; 
 + } 
 + 
 + public String getEmail ( ) { 
 + return email ; 
 + } 
 + 
 + public void setEmail ( String email ) { 
 + this . email = email ; 
 + } 
 + 
 + } 
 + 
 + These objects should be instantiated from the RealmCollection using the method create ( ) 
 + 
 + # # Instatiating a Realm Collection 
 + 
 + To get started with realm we create a new instance of a RealmList , this can be done through a static factory 
 + 
 + RealmList < User > users = Realms . list ( context , User . class ) ; 
 + 
 + RealmList works as a traditional List , which is just automatically persisted in Realm . 
 + The Context , is used to get access to a writeable directory on the device , and the Class is used to generate the underlying datamodel . 
 + 
 + # # Adding Objects 
 + 
 + To add a new object to the RealmList , you add it like you normally do , the only new thing is the way the object is instantiated 
 + 
 + 	 User user = users . create ( ) ; 
 + 
 + This gives us a new User instance , which we can then populate with data , before adding it to the list . 
 + 
 + user . setId ( 0 ) ; 
 + user . setName ( " John " ) ; 
 + user . setEmail ( " john @ corporation . com " ) ; 
 + 
 + users . add ( user ) ; 
 + 
 + 
 + # # Getting Objects 
 + 
 + To retrieve an object from the list 
 + 
 + Users user = users . get ( 0 ) ; 
 + 
 + This is just like we are used to from a List , the difference here is that the User object is backed by Realm , which means that when you change its values it is automatically persisted . 
 + 
 + # # Iterating through Objects 
 + 
 + To make a run through all objects in a RealmList you can use a traditional for loop 
 + 
 + for ( int i = 0 ; i < users . size ( ) ; i + + ) { 
 + User u = users . get ( i ) ; 
 + . . . do something with the object . . . 
 + } 
 + 
 + Or you can take advantage of Iterable 
 + 
 + for ( User u : users ) { 
 + . . . do something with the object . . . 
 + } 
 + 
 + # # Querying 
 + 
 + A benefit to using Realm Collections is that you get access to a fast query interface , which enables you to filter the collection 
 + 
 + To find all users named " John " you would write 
 + 
 + RealmList < User > result = users . where ( ) . equalTo ( " name " , " John " ) ; 
 + 
 + This gives you a new list , of users with the name John
