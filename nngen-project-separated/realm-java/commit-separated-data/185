BLEU SCORE: 0.04923026124015933

TEST MSG: Remove deprecated RealmResults . distinct APIs
GENERATED MSG: Cleanup unit test naming and looper thread usage .

TEST DIFF (one line): diff - - git a / CHANGELOG . md b / CHANGELOG . md <nl> index c44194c . . 244b15d 100644 <nl> - - - a / CHANGELOG . md <nl> + + + b / CHANGELOG . md <nl> @ @ - 1 , 5 + 1 , 9 @ @ <nl> # # 4 . 0 . 0 - BETA3 ( YYYY - MM - DD ) <nl> <nl> + # # # Breaking Changes <nl> + <nl> + * ` RealmResults . distinct ( ) ` / ` RealmResults . distinctAsync ( ) ` have been removed . Use ` RealmQuery . distinct ( ) ` / ` RealmQuery . distinctAsync ( ) ` instead . <nl> + <nl> # # # Internal <nl> <nl> * Upgraded to Realm Sync 2 . 0 . 0 - rc16 . <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java <nl> index 353d588 . . 0c6f652 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java <nl> @ @ - 3034 , 8 + 3034 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinct ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; / / Must be greater than 1 <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> @ @ - 3048 , 8 + 3048 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinct _ withNullValues ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> <nl> for ( String field : new String [ ] { AnnotationIndexTypes . FIELD _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ INDEX _ STRING } ) { <nl> @ @ - 3060 , 8 + 3060 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinct _ notIndexedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) <nl> @ @ - 3076 , 8 + 3076 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinct _ doesNotExist ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; / / Must be greater than 1 <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> try { <nl> @ @ - 3101 , 8 + 3101 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinct _ indexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> <nl> for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { <nl> @ @ - 3116 , 8 + 3116 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinct _ notIndexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> <nl> for ( String field : AnnotationIndexTypes . NOT _ INDEX _ FIELDS ) { <nl> @ @ - 3144 , 8 + 3144 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> public void distinctAsync ( ) throws Throwable { <nl> final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; <nl> final Realm realm = looperThread . getRealm ( ) ; <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; / / Must be greater than 1 <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> @ @ - 3220 , 8 + 3220 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> public void distinctAsync _ withNullValues ( ) throws Throwable { <nl> final AtomicInteger changeListenerCalled = new AtomicInteger ( 2 ) ; <nl> final Realm realm = looperThread . getRealm ( ) ; <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / must be greater than 1 <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; / / must be greater than 1 <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> <nl> final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) <nl> @ @ - 3261 , 8 + 3261 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> @ Test <nl> @ RunTestInLooperThread <nl> public void distinctAsync _ doesNotExist ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> try { <nl> @ @ - 3289 , 8 + 3289 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> @ Test <nl> @ RunTestInLooperThread <nl> public void distinctAsync _ indexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { <nl> @ @ - 3317 , 8 + 3317 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinctMultiArgs ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; / / Must be greater than 1 <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; <nl> @ @ - 3328 , 7 + 3328 , 7 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinctMultiArgs _ switchedFieldsOrder ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> + final long numberOfBlocks = 3 ; <nl> TestHelper . populateForDistinctFieldsOrder ( realm , numberOfBlocks ) ; <nl> <nl> / / Regardless of the block size defined above , the output size is expected to be the same , 4 in this case , due to receiving unique combinations of tuples . <nl> @ @ - 3342 , 8 + 3342 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinctMultiArgs _ emptyField ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; <nl> @ @ - 3396 , 8 + 3396 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinctMultiArgs _ withNullValues ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> <nl> RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; <nl> @ @ - 3407 , 8 + 3407 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinctMultiArgs _ notIndexedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; <nl> @ @ - 3420 , 8 + 3420 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinctMultiArgs _ doesNotExistField ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; <nl> @ @ - 3444 , 8 + 3444 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinctMultiArgs _ indexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> <nl> RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; <nl> @ @ - 3457 , 8 + 3457 , 8 @ @ public class RealmQueryTests extends QueryTests { <nl> <nl> @ Test <nl> public void distinctMultiArgs _ notIndexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> + final long numberOfBlocks = 3 ; <nl> + final long numberOfObjects = 3 ; <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> <nl> RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java <nl> index b4ead0c . . d087c59 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java <nl> @ @ - 34 , 9 + 34 , 7 @ @ import java . util . List ; <nl> import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> <nl> - import io . realm . entities . AllJavaTypes ; <nl> import io . realm . entities . AllTypes ; <nl> - import io . realm . entities . AnnotationIndexTypes ; <nl> import io . realm . entities . DefaultValueOfField ; <nl> import io . realm . entities . Dog ; <nl> import io . realm . entities . NonLatinFieldNames ; <nl> @ @ - 49 , 7 + 47 , 6 @ @ import io . realm . rule . RunTestInLooperThread ; <nl> import io . realm . rule . TestRealmConfigurationFactory ; <nl> <nl> import static org . junit . Assert . assertEquals ; <nl> - import static org . junit . Assert . assertFalse ; <nl> import static org . junit . Assert . assertNull ; <nl> import static org . junit . Assert . assertTrue ; <nl> import static org . junit . Assert . fail ; <nl> @ @ - 185 , 166 + 182 , 6 @ @ public class RealmResultsTests extends CollectionTests { <nl> assertEquals ( 10 , realm . where ( AllTypes . class ) . lessThan ( AllTypes . FIELD _ LONG , 0 ) . findAll ( ) . size ( ) ) ; <nl> } <nl> <nl> - / / RealmResults . distinct ( ) : requires indexing , and type = boolean , integer , date , string . <nl> - private void populateForDistinct ( Realm realm , long numberOfBlocks , long numberOfObjects , boolean withNull ) { <nl> - realm . beginTransaction ( ) ; <nl> - for ( int i = 0 ; i < numberOfObjects * numberOfBlocks ; i + + ) { <nl> - for ( int j = 0 ; j < numberOfBlocks ; j + + ) { <nl> - AnnotationIndexTypes obj = realm . createObject ( AnnotationIndexTypes . class ) ; <nl> - obj . setIndexBoolean ( j % 2 = = 0 ) ; <nl> - obj . setIndexLong ( j ) ; <nl> - obj . setIndexDate ( withNull ? null : new Date ( 1000 * ( long ) j ) ) ; <nl> - obj . setIndexString ( withNull ? null : " Test " + j ) ; <nl> - obj . setNotIndexBoolean ( j % 2 = = 0 ) ; <nl> - obj . setNotIndexLong ( j ) ; <nl> - obj . setNotIndexDate ( withNull ? null : new Date ( 1000 * ( long ) j ) ) ; <nl> - obj . setNotIndexString ( withNull ? null : " Test " + j ) ; <nl> - } <nl> - } <nl> - realm . commitTransaction ( ) ; <nl> - } <nl> - <nl> - private void populateForDistinctInvalidTypesLinked ( Realm realm ) { <nl> - realm . beginTransaction ( ) ; <nl> - AllJavaTypes notEmpty = new AllJavaTypes ( ) ; <nl> - notEmpty . setFieldBinary ( new byte [ ] { 1 , 2 , 3 } ) ; <nl> - notEmpty . setFieldObject ( notEmpty ) ; <nl> - notEmpty . setFieldList ( new RealmList < AllJavaTypes > ( notEmpty ) ) ; <nl> - realm . copyToRealm ( notEmpty ) ; <nl> - realm . commitTransaction ( ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void distinct ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> - assertEquals ( 2 , distinctBool . size ( ) ) ; <nl> - for ( String field : new String [ ] { AnnotationIndexTypes . FIELD _ INDEX _ LONG , AnnotationIndexTypes . FIELD _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ INDEX _ STRING } ) { <nl> - RealmResults < AnnotationIndexTypes > distinct = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( field ) ; <nl> - assertEquals ( field , numberOfBlocks , distinct . size ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - @ SuppressWarnings ( " ReferenceEquality " ) <nl> - public void distinct _ restrictedByPreviousDistinct ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - / / All objects <nl> - RealmResults < AnnotationIndexTypes > allResults = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - assertEquals ( " All Objects Count " , numberOfBlocks * numberOfBlocks * numberOfObjects , allResults . size ( ) ) ; <nl> - / / Distinctive dates <nl> - RealmResults < AnnotationIndexTypes > distinctDates = allResults . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; <nl> - assertEquals ( " Distinctive Dates " , numberOfBlocks , distinctDates . size ( ) ) ; <nl> - / / Distinctive Booleans <nl> - RealmResults < AnnotationIndexTypes > distinctBooleans = distinctDates . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> - assertEquals ( " Distinctive Booleans " , 2 , distinctBooleans . size ( ) ) ; <nl> - / / distinct results are not the same object <nl> - assertTrue ( allResults ! = distinctDates ) ; <nl> - assertTrue ( allResults ! = distinctBooleans ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void distinct _ withNullValues ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> - <nl> - for ( String field : new String [ ] { AnnotationIndexTypes . FIELD _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ INDEX _ STRING } ) { <nl> - RealmResults < AnnotationIndexTypes > distinct = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( field ) ; <nl> - assertEquals ( field , 1 , distinct . size ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinct _ notIndexedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) <nl> - . findAll ( ) . distinct ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ BOOL ) ; <nl> - assertEquals ( 2 , distinctBool . size ( ) ) ; <nl> - for ( String field : new String [ ] { AnnotationIndexTypes . FIELD _ NOT _ INDEX _ LONG , <nl> - AnnotationIndexTypes . FIELD _ NOT _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ NOT _ INDEX _ STRING } ) { <nl> - RealmResults < AnnotationIndexTypes > distinct = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinct ( field ) ; <nl> - assertEquals ( field , numberOfBlocks , distinct . size ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinct _ noneExistingField ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - try { <nl> - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( " doesNotExist " ) ; <nl> - fail ( ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinct _ invalidTypes ( ) { <nl> - populateTestRealm ( ) ; <nl> - <nl> - for ( String field : new String [ ] { AllTypes . FIELD _ REALMOBJECT , AllTypes . FIELD _ REALMLIST , AllTypes . FIELD _ DOUBLE , AllTypes . FIELD _ FLOAT } ) { <nl> - try { <nl> - realm . where ( AllTypes . class ) . findAll ( ) . distinct ( field ) ; <nl> - fail ( field ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinct _ indexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> - <nl> - for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { <nl> - try { <nl> - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; <nl> - fail ( " Unsupported Index " + field + " linked field " ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinct _ notIndexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> - <nl> - for ( String field : AnnotationIndexTypes . NOT _ INDEX _ FIELDS ) { <nl> - try { <nl> - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; <nl> - fail ( " Unsupported notIndex " + field + " linked field " ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinct _ invalidTypesLinkedFields ( ) { <nl> - populateForDistinctInvalidTypesLinked ( realm ) ; <nl> - <nl> - try { <nl> - realm . where ( AllJavaTypes . class ) . findAll ( ) . distinct ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) ; <nl> - fail ( " Unsupported columnBinary linked field " ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - <nl> @ Test <nl> @ RunTestInLooperThread <nl> public void changeListener _ syncIfNeeded _ updatedFromOtherThread ( ) { <nl> @ @ - 417 , 430 + 254 , 6 @ @ public class RealmResultsTests extends CollectionTests { <nl> testRealm . commitTransaction ( ) ; <nl> } <nl> <nl> - @ Test <nl> - @ RunTestInLooperThread <nl> - public void distinctAsync ( ) throws Throwable { <nl> - final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; <nl> - final Realm realm = looperThread . getRealm ( ) ; <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> - <nl> - assertFalse ( distinctBool . isLoaded ( ) ) ; <nl> - assertTrue ( distinctBool . isValid ( ) ) ; <nl> - assertTrue ( distinctBool . isEmpty ( ) ) ; <nl> - <nl> - assertFalse ( distinctLong . isLoaded ( ) ) ; <nl> - assertTrue ( distinctLong . isValid ( ) ) ; <nl> - assertTrue ( distinctLong . isEmpty ( ) ) ; <nl> - <nl> - assertFalse ( distinctDate . isLoaded ( ) ) ; <nl> - assertTrue ( distinctDate . isValid ( ) ) ; <nl> - assertTrue ( distinctDate . isEmpty ( ) ) ; <nl> - <nl> - assertFalse ( distinctString . isLoaded ( ) ) ; <nl> - assertTrue ( distinctString . isValid ( ) ) ; <nl> - assertTrue ( distinctString . isEmpty ( ) ) ; <nl> - <nl> - final Runnable endTest = new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - if ( changeListenerCalled . decrementAndGet ( ) = = 0 ) { <nl> - looperThread . testComplete ( ) ; <nl> - } <nl> - } <nl> - } ; <nl> - <nl> - looperThread . keepStrongReference ( distinctBool ) ; <nl> - looperThread . keepStrongReference ( distinctLong ) ; <nl> - looperThread . keepStrongReference ( distinctDate ) ; <nl> - looperThread . keepStrongReference ( distinctString ) ; <nl> - distinctBool . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( 2 , distinctBool . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - <nl> - distinctLong . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( numberOfBlocks , distinctLong . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - <nl> - distinctDate . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( numberOfBlocks , distinctDate . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - <nl> - distinctString . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( numberOfBlocks , distinctString . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - } <nl> - <nl> - @ Test <nl> - @ RunTestInLooperThread <nl> - public void distinctAsync _ withNullValues ( ) throws Throwable { <nl> - final AtomicInteger changeListenerCalled = new AtomicInteger ( 2 ) ; <nl> - final Realm realm = looperThread . getRealm ( ) ; <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> - <nl> - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> - <nl> - assertFalse ( distinctDate . isLoaded ( ) ) ; <nl> - assertTrue ( distinctDate . isValid ( ) ) ; <nl> - assertTrue ( distinctDate . isEmpty ( ) ) ; <nl> - <nl> - assertFalse ( distinctString . isLoaded ( ) ) ; <nl> - assertTrue ( distinctString . isValid ( ) ) ; <nl> - assertTrue ( distinctString . isEmpty ( ) ) ; <nl> - <nl> - final Runnable endTest = new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - if ( changeListenerCalled . decrementAndGet ( ) = = 0 ) { <nl> - looperThread . testComplete ( ) ; <nl> - } <nl> - } <nl> - } ; <nl> - <nl> - looperThread . keepStrongReference ( distinctDate ) ; <nl> - looperThread . keepStrongReference ( distinctString ) ; <nl> - distinctDate . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( " distinctDate " , 1 , distinctDate . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - <nl> - distinctString . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( " distinctString " , 1 , distinctString . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - } <nl> - <nl> - @ Test <nl> - @ RunTestInLooperThread <nl> - public void distinctAsync _ notIndexedFields ( ) { <nl> - final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; <nl> - Realm realm = looperThread . getRealm ( ) ; <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinctAsync ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ LONG ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinctAsync ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ DATE ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinctAsync ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ STRING ) ; <nl> - <nl> - assertFalse ( distinctBool . isLoaded ( ) ) ; <nl> - assertTrue ( distinctBool . isValid ( ) ) ; <nl> - assertTrue ( distinctBool . isEmpty ( ) ) ; <nl> - <nl> - assertFalse ( distinctLong . isLoaded ( ) ) ; <nl> - assertTrue ( distinctLong . isValid ( ) ) ; <nl> - assertTrue ( distinctLong . isEmpty ( ) ) ; <nl> - <nl> - assertFalse ( distinctDate . isLoaded ( ) ) ; <nl> - assertTrue ( distinctDate . isValid ( ) ) ; <nl> - assertTrue ( distinctDate . isEmpty ( ) ) ; <nl> - <nl> - assertFalse ( distinctString . isLoaded ( ) ) ; <nl> - assertTrue ( distinctString . isValid ( ) ) ; <nl> - assertTrue ( distinctString . isEmpty ( ) ) ; <nl> - <nl> - final Runnable endTest = new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - if ( changeListenerCalled . decrementAndGet ( ) = = 0 ) { <nl> - looperThread . testComplete ( ) ; <nl> - } <nl> - } <nl> - } ; <nl> - <nl> - looperThread . keepStrongReference ( distinctBool ) ; <nl> - looperThread . keepStrongReference ( distinctLong ) ; <nl> - looperThread . keepStrongReference ( distinctDate ) ; <nl> - looperThread . keepStrongReference ( distinctString ) ; <nl> - distinctBool . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( 2 , distinctBool . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - <nl> - distinctLong . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( numberOfBlocks , distinctLong . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - <nl> - distinctDate . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( numberOfBlocks , distinctDate . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - <nl> - distinctString . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { <nl> - @ Override <nl> - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { <nl> - assertEquals ( numberOfBlocks , distinctString . size ( ) ) ; <nl> - endTest . run ( ) ; <nl> - } <nl> - } ) ; <nl> - } <nl> - <nl> - @ Test <nl> - @ RunTestInLooperThread <nl> - public void distinctAsync _ doesNotExist ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - try { <nl> - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( " doesNotExist " ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - looperThread . testComplete ( ) ; <nl> - } <nl> - <nl> - @ Test <nl> - @ RunTestInLooperThread <nl> - public void distinctAsync _ invalidTypes ( ) { <nl> - populateTestRealm ( realm , TEST _ DATA _ SIZE ) ; <nl> - <nl> - for ( String field : new String [ ] { AllTypes . FIELD _ REALMOBJECT , AllTypes . FIELD _ REALMLIST , AllTypes . FIELD _ DOUBLE , AllTypes . FIELD _ FLOAT } ) { <nl> - try { <nl> - realm . where ( AllTypes . class ) . findAll ( ) . distinctAsync ( field ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - looperThread . testComplete ( ) ; <nl> - } <nl> - <nl> - @ Test <nl> - @ RunTestInLooperThread <nl> - public void distinctAsync _ indexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { <nl> - try { <nl> - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; <nl> - fail ( " Unsupported " + field + " linked field " ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - looperThread . testComplete ( ) ; <nl> - } <nl> - <nl> - @ Test <nl> - @ RunTestInLooperThread <nl> - public void distinctAsync _ notIndexedLinkedFields ( ) { <nl> - populateForDistinctInvalidTypesLinked ( realm ) ; <nl> - <nl> - try { <nl> - realm . where ( AllJavaTypes . class ) . findAll ( ) . distinctAsync ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - looperThread . testComplete ( ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; / / Must be greater than 1 <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - RealmResults < AnnotationIndexTypes > distinctMulti = results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , AnnotationIndexTypes . INDEX _ FIELDS ) ; <nl> - assertEquals ( numberOfBlocks , distinctMulti . size ( ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs _ switchedFieldsOrder ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - TestHelper . populateForDistinctFieldsOrder ( realm , numberOfBlocks ) ; <nl> - <nl> - / / Regardless of the block size defined above , the output size is expected to be the same , 4 in this case , due to receiving unique combinations of tuples . <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - RealmResults < AnnotationIndexTypes > distinctStringLong = results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ STRING , AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; <nl> - RealmResults < AnnotationIndexTypes > distinctLongString = results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ LONG , AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> - assertEquals ( 4 , distinctStringLong . size ( ) ) ; <nl> - assertEquals ( 4 , distinctLongString . size ( ) ) ; <nl> - assertEquals ( distinctStringLong . size ( ) , distinctLongString . size ( ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs _ emptyField ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - / / An empty string field in the middle . <nl> - try { <nl> - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , " " , AnnotationIndexTypes . FIELD _ INDEX _ INT ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - / / An empty string field at the end . <nl> - try { <nl> - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , AnnotationIndexTypes . FIELD _ INDEX _ INT , " " ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - / / A null string field in the middle . <nl> - try { <nl> - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , null , AnnotationIndexTypes . FIELD _ INDEX _ INT ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - / / A null string field at the end . <nl> - try { <nl> - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , AnnotationIndexTypes . FIELD _ INDEX _ INT , null ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - / / ( String ) Null makes varargs a null array . <nl> - try { <nl> - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , ( String ) null ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - / / Two ( String ) null for first and varargs fields . <nl> - try { <nl> - results . distinct ( null , ( String ) null ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - / / " " & ( String ) null combination . <nl> - try { <nl> - results . distinct ( " " , ( String ) null ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - / / " " & ( String ) null combination . <nl> - try { <nl> - results . distinct ( null , " " ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - / / Two empty fields tests . <nl> - try { <nl> - results . distinct ( " " , " " ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs _ withNullValues ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - RealmResults < AnnotationIndexTypes > distinctMulti = results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> - assertEquals ( 1 , distinctMulti . size ( ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs _ notIndexedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - try { <nl> - results . distinct ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ STRING , AnnotationIndexTypes . NOT _ INDEX _ FIELDS ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs _ doesNotExistField ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - try { <nl> - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ INT , AnnotationIndexTypes . NONEXISTANT _ MIX _ FIELDS ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs _ invalidTypesFields ( ) { <nl> - populateTestRealm ( ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - try { <nl> - results . distinct ( AllTypes . FIELD _ REALMOBJECT , AllTypes . INVALID _ TYPES _ FIELDS _ FOR _ DISTINCT ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs _ indexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - try { <nl> - results . distinct ( AnnotationIndexTypes . INDEX _ LINKED _ FIELD _ STRING , AnnotationIndexTypes . INDEX _ LINKED _ FIELDS ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs _ notIndexedLinkedFields ( ) { <nl> - final long numberOfBlocks = 25 ; <nl> - final long numberOfObjects = 10 ; <nl> - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - try { <nl> - results . distinct ( AnnotationIndexTypes . NOT _ INDEX _ LINKED _ FILED _ STRING , AnnotationIndexTypes . NOT _ INDEX _ LINKED _ FIELDS ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> - public void distinctMultiArgs _ invalidTypesLinkedFields ( ) { <nl> - populateForDistinctInvalidTypesLinked ( realm ) ; <nl> - <nl> - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; <nl> - try { <nl> - results . distinct ( AllJavaTypes . INVALID _ LINKED _ BINARY _ FIELD _ FOR _ DISTINCT , AllJavaTypes . INVALID _ LINKED _ TYPES _ FIELDS _ FOR _ DISTINCT ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - } <nl> <nl> private RealmResults < Dog > populateRealmResultsOnLinkView ( Realm realm ) { <nl> realm . beginTransaction ( ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> index b1d272d . . 4b61f79 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> @ @ - 338 , 33 + 338 , 4 @ @ public class RealmResults < E extends RealmModel > extends OrderedRealmCollectionIm <nl> throw new UnsupportedOperationException ( realm . getClass ( ) + " does not support RxJava2 . " ) ; <nl> } <nl> } <nl> - <nl> - / * * <nl> - * @ deprecated use { @ link RealmQuery # distinct ( String ) } on the return value of { @ link # where ( ) } instead . This will <nl> - * be removed in coming 3 . x . x minor releases . <nl> - * / <nl> - @ Deprecated <nl> - public RealmResults < E > distinct ( String fieldName ) { <nl> - SortDescriptor distinctDescriptor = SortDescriptor . getInstanceForDistinct ( new SchemaConnector ( realm . getSchema ( ) ) , collection . getTable ( ) , fieldName ) ; <nl> - Collection distinctCollection = collection . distinct ( distinctDescriptor ) ; <nl> - return createLoadedResults ( distinctCollection ) ; <nl> - } <nl> - <nl> - / * * <nl> - * @ deprecated use { @ link RealmQuery # distinctAsync ( String ) } on the return value of { @ link # where ( ) } instead . This <nl> - * will be removed in coming 3 . x . x minor releases . <nl> - * / <nl> - @ Deprecated <nl> - public RealmResults < E > distinctAsync ( String fieldName ) { <nl> - return where ( ) . distinctAsync ( fieldName ) ; <nl> - } <nl> - <nl> - / * * <nl> - * @ deprecated use { @ link RealmQuery # distinct ( String , String . . . ) } on the return value of { @ link # where ( ) } instead . <nl> - * This will be removed in coming 3 . x . x minor releases . <nl> - * / <nl> - @ Deprecated <nl> - public RealmResults < E > distinct ( String firstFieldName , String . . . remainingFieldNames ) { <nl> - return where ( ) . distinct ( firstFieldName , remainingFieldNames ) ; <nl> - } <nl> }
NEAREST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index 9b16b9c . . e6cc8af 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 64 , 7 + 64 , 7 @ @ public class RealmAsyncQueryTests { <nl> private Context context ; <nl> <nl> @ Rule <nl> - public final RunInLooperThread workerThread = new RunInLooperThread ( ) ; <nl> + public final RunInLooperThread looperThread = new RunInLooperThread ( ) ; <nl> <nl> @ Before <nl> public void setUp ( ) throws Exception { <nl> @ @ - 78 , 10 + 78 , 10 @ @ public class RealmAsyncQueryTests { <nl> / / start asynchronously a transaction to insert one element <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testAsyncTransaction ( ) throws Throwable { <nl> - assertEquals ( 0 , workerThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> + public void executeTransaction _ async ( ) throws Throwable { <nl> + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> <nl> - workerThread . realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + looperThread . realm . executeTransaction ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> Owner owner = realm . createObject ( Owner . class ) ; <nl> @ @ - 90 , 23 + 90 , 23 @ @ public class RealmAsyncQueryTests { <nl> } , new Realm . Transaction . Callback ( ) { <nl> @ Override <nl> public void onSuccess ( ) { <nl> - assertEquals ( 1 , workerThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> - assertEquals ( " Owner " , workerThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; <nl> - workerThread . testComplete ( ) ; <nl> + assertEquals ( 1 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; <nl> + assertEquals ( " Owner " , looperThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> <nl> @ Override <nl> public void onError ( Exception e ) { <nl> - workerThread . testComplete ( ) ; ; <nl> + looperThread . testComplete ( ) ; ; <nl> fail ( e . getMessage ( ) ) ; <nl> } <nl> } ) ; <nl> } <nl> <nl> + / / Test that an async transaction that throws an exception propagate it properly to the user . <nl> @ Test <nl> - public void testAsyncTransactionThatThrowsRuntimeException ( ) throws Throwable { <nl> + public void executeTransaction _ async _ exceptionHandling ( ) throws Throwable { <nl> final TestHelper . TestLogger testLogger = new TestHelper . TestLogger ( ) ; <nl> - <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Realm [ ] realm = new Realm [ 1 ] ; <nl> @ @ - 181 , 108 + 181 , 82 @ @ public class RealmAsyncQueryTests { <nl> <nl> / / Test if the background Realm is closed when transaction success returned . <nl> @ Test <nl> - public void testClosedBeforeAsyncTransactionSuccess ( ) { <nl> - final CountDownLatch signalTestFinished = new CountDownLatch ( 1 ) ; <nl> - HandlerThread handlerThread = new HandlerThread ( " background " ) ; <nl> - handlerThread . start ( ) ; <nl> - final Handler handler = new Handler ( handlerThread . getLooper ( ) ) ; <nl> - handler . post ( new Runnable ( ) { <nl> + @ RunTestInLooperThread <nl> + public void executeTransaction _ async _ realmClosedOnSuccess ( ) { <nl> + final AtomicInteger counter = new AtomicInteger ( 100 ) ; <nl> + final Realm realm = Realm . getInstance ( looperThread . createConfiguration ( " testClosedBeforeAsyncTransactionSuccess " ) ) ; <nl> + final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { <nl> @ Override <nl> - public void run ( ) { <nl> - final AtomicInteger counter = new AtomicInteger ( 100 ) ; <nl> - final Realm realm = openRealmInstance ( " testClosedBeforeAsyncTransactionSuccess " ) ; <nl> - final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { <nl> - @ Override <nl> - public void onResult ( int count ) { <nl> - assertEquals ( 1 , count ) ; <nl> - if ( counter . decrementAndGet ( ) = = 0 ) { <nl> - realm . close ( ) ; <nl> - signalTestFinished . countDown ( ) ; <nl> - } <nl> - } <nl> - } ; <nl> - final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { <nl> - @ Override <nl> - public void onSuccess ( ) { <nl> - RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; <nl> - if ( counter . get ( ) = = 0 ) { <nl> - / / Finish testing <nl> - return ; <nl> - } <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> - @ Override <nl> - public void execute ( Realm realm ) { <nl> - } <nl> - } , this ) ; <nl> - } <nl> - } ; <nl> - <nl> + public void onResult ( int count ) { <nl> + assertEquals ( 1 , count ) ; <nl> + if ( counter . decrementAndGet ( ) = = 0 ) { <nl> + realm . close ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } <nl> + } ; <nl> + final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { <nl> + @ Override <nl> + public void onSuccess ( ) { <nl> + RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; <nl> + if ( counter . get ( ) = = 0 ) { <nl> + / / Finish testing <nl> + return ; <nl> + } <nl> realm . executeTransaction ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> } <nl> - } , transactionCallback ) ; <nl> + } , this ) ; <nl> } <nl> - } ) ; <nl> - try { <nl> - TestHelper . awaitOrFail ( signalTestFinished ) ; <nl> - } finally { <nl> - handlerThread . quit ( ) ; <nl> - } <nl> + } ; <nl> + <nl> + realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + } <nl> + } , transactionCallback ) ; <nl> } <nl> <nl> / / Test if the background Realm is closed when transaction error returned . <nl> @ Test <nl> - public void testClosedBeforeAsyncTransactionError ( ) { <nl> - final CountDownLatch signalTestFinished = new CountDownLatch ( 1 ) ; <nl> - HandlerThread handlerThread = new HandlerThread ( " background " ) ; <nl> - handlerThread . start ( ) ; <nl> - final Handler handler = new Handler ( handlerThread . getLooper ( ) ) ; <nl> - handler . post ( new Runnable ( ) { <nl> + @ RunTestInLooperThread <nl> + public void executeTransaction _ async _ realmClosedOnError ( ) { <nl> + final AtomicInteger counter = new AtomicInteger ( 100 ) ; <nl> + final Realm realm = Realm . getInstance ( looperThread . createConfiguration ( " testClosedBeforeAsyncTransactionSuccess " ) ) ; <nl> + final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { <nl> @ Override <nl> - public void run ( ) { <nl> - final AtomicInteger counter = new AtomicInteger ( 100 ) ; <nl> - final Realm realm = openRealmInstance ( " testClosedBeforeAsyncTransactionSuccess " ) ; <nl> - final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { <nl> - @ Override <nl> - public void onResult ( int count ) { <nl> - assertEquals ( 1 , count ) ; <nl> - if ( counter . decrementAndGet ( ) = = 0 ) { <nl> - realm . close ( ) ; <nl> - signalTestFinished . countDown ( ) ; <nl> - } <nl> - } <nl> - } ; <nl> - final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { <nl> - @ Override <nl> - public void onError ( Exception e ) { <nl> - RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; <nl> - if ( counter . get ( ) = = 0 ) { <nl> - / / Finish testing <nl> - return ; <nl> - } <nl> - realm . executeTransaction ( new Realm . Transaction ( ) { <nl> - @ Override <nl> - public void execute ( Realm realm ) { <nl> - throw new RuntimeException ( " Dummy exception " ) ; <nl> - } <nl> - } , this ) ; <nl> - } <nl> - } ; <nl> - <nl> + public void onResult ( int count ) { <nl> + assertEquals ( 1 , count ) ; <nl> + if ( counter . decrementAndGet ( ) = = 0 ) { <nl> + realm . close ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } <nl> + } ; <nl> + final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { <nl> + @ Override <nl> + public void onError ( Exception e ) { <nl> + RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; <nl> + if ( counter . get ( ) = = 0 ) { <nl> + / / Finish testing <nl> + return ; <nl> + } <nl> realm . executeTransaction ( new Realm . Transaction ( ) { <nl> @ Override <nl> public void execute ( Realm realm ) { <nl> throw new RuntimeException ( " Dummy exception " ) ; <nl> } <nl> - } , transactionCallback ) ; <nl> + } , this ) ; <nl> } <nl> - } ) ; <nl> - try { <nl> - TestHelper . awaitOrFail ( signalTestFinished ) ; <nl> - } finally { <nl> - handlerThread . quit ( ) ; <nl> - } <nl> + } ; <nl> + <nl> + realm . executeTransaction ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + throw new RuntimeException ( " Dummy exception " ) ; <nl> + } <nl> + } , transactionCallback ) ; <nl> } <nl> <nl> / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> @ @ - 292 , 7 + 266 , 7 @ @ public class RealmAsyncQueryTests { <nl> / / finding element [ 0 - 4 ] asynchronously then wait for the promise to be loaded . <nl> / / no use of notification callback <nl> @ Test <nl> - public void testFindAllAsync ( ) throws Throwable { <nl> + public void findAllAsync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 370 , 11 + 344 , 11 @ @ public class RealmAsyncQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testAccessingRealmListOnUnloadedRealmObjectShouldThrow ( ) { <nl> + public void accessingRealmListOnUnloadedRealmObjectShouldThrow ( ) { <nl> Realm . asyncQueryExecutor . pause ( ) ; <nl> <nl> - populateTestRealm ( workerThread . realm , 10 ) ; <nl> - final AllTypes alltypes1 = workerThread . realm . where ( AllTypes . class ) <nl> + populateTestRealm ( looperThread . realm , 10 ) ; <nl> + final AllTypes alltypes1 = looperThread . realm . where ( AllTypes . class ) <nl> . equalTo ( " columnLong " , 0 ) <nl> . findFirstAsync ( ) ; <nl> <nl> @ @ - 386 , 13 + 360 , 13 @ @ public class RealmAsyncQueryTests { <nl> } <nl> <nl> Realm . asyncQueryExecutor . resume ( ) ; <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> Looper . loop ( ) ; <nl> <nl> } <nl> <nl> @ Test <nl> - public void testStandaloneObjectAsyncBehaviour ( ) { <nl> + public void standaloneObjectAsyncBehaviour ( ) { <nl> Dog dog = new Dog ( ) ; <nl> dog . setName ( " Akamaru " ) ; <nl> dog . setAge ( 10 ) ; <nl> @ @ - 402 , 7 + 376 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> <nl> @ Test <nl> - public void testAsyncQueryOnNonLooperThreadShouldThrow ( ) throws Throwable { <nl> + public void findAllAsync _ throwsOnNonLooperThread ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 449 , 10 + 423 , 10 @ @ public class RealmAsyncQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testReusingQuery ( ) throws Throwable { <nl> - populateTestRealm ( workerThread . realm , 10 ) ; <nl> + public void findAllAsync _ reusingQuery ( ) throws Throwable { <nl> + populateTestRealm ( looperThread . realm , 10 ) ; <nl> <nl> - RealmQuery < AllTypes > query = workerThread . realm . where ( AllTypes . class ) <nl> + RealmQuery < AllTypes > query = looperThread . realm . where ( AllTypes . class ) <nl> . between ( " columnLong " , 0 , 4 ) ; <nl> RealmResults < AllTypes > queryAllSync = query . findAll ( ) ; <nl> RealmResults < AllTypes > allAsync = query . findAllAsync ( ) ; <nl> @ @ - 465 , 7 + 439 , 7 @ @ public class RealmAsyncQueryTests { <nl> RealmResults < AllTypes > allAsyncSorted = query . findAllSorted ( " columnLong " ) ; <nl> fail ( " Should throw an exception , can not reuse RealmQuery " ) ; <nl> } catch ( IllegalStateException ignored ) { <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> } <nl> <nl> @ @ - 473 , 11 + 447 , 11 @ @ public class RealmAsyncQueryTests { <nl> / / using a callback to be notified when the data is loaded <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testFindAllAsyncWithNotification ( ) throws Throwable { <nl> + public void findAllAsync _ withNotification ( ) throws Throwable { <nl> Realm . asyncQueryExecutor . pause ( ) ; <nl> <nl> - populateTestRealm ( workerThread . realm , 10 ) ; <nl> - final RealmResults < AllTypes > realmResults = workerThread . realm . where ( AllTypes . class ) <nl> + populateTestRealm ( looperThread . realm , 10 ) ; <nl> + final RealmResults < AllTypes > realmResults = looperThread . realm . where ( AllTypes . class ) <nl> . between ( " columnLong " , 0 , 4 ) <nl> . findAllAsync ( ) ; <nl> <nl> @ @ - 487 , 7 + 461 , 7 @ @ public class RealmAsyncQueryTests { <nl> assertTrue ( realmResults . isLoaded ( ) ) ; <nl> assertEquals ( 5 , realmResults . size ( ) ) ; <nl> assertTrue ( realmResults . get ( 4 ) . isValid ( ) ) ; <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> } ) ; <nl> <nl> @ @ - 495 , 18 + 469 , 18 @ @ public class RealmAsyncQueryTests { <nl> assertEquals ( 0 , realmResults . size ( ) ) ; <nl> <nl> Realm . asyncQueryExecutor . resume ( ) ; <nl> - workerThread . keepStrongReference . add ( realmResults ) ; <nl> + looperThread . keepStrongReference . add ( realmResults ) ; <nl> } <nl> <nl> / / transforming an async query into sync by calling load to force <nl> / / the blocking behaviour <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testForceLoadAsync ( ) throws Throwable { <nl> + public void findAllAsync _ forceLoad ( ) throws Throwable { <nl> Realm . asyncQueryExecutor . pause ( ) ; <nl> <nl> - populateTestRealm ( workerThread . realm , 10 ) ; <nl> - final RealmResults < AllTypes > realmResults = workerThread . realm . where ( AllTypes . class ) <nl> + populateTestRealm ( looperThread . realm , 10 ) ; <nl> + final RealmResults < AllTypes > realmResults = looperThread . realm . where ( AllTypes . class ) <nl> . between ( " columnLong " , 0 , 4 ) <nl> . findAllAsync ( ) ; <nl> <nl> @ @ - 516 , 7 + 490 , 7 @ @ public class RealmAsyncQueryTests { <nl> public void onChange ( ) { <nl> assertTrue ( realmResults . isLoaded ( ) ) ; <nl> assertEquals ( 5 , realmResults . size ( ) ) ; <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> <nl> } <nl> } ) ; <nl> @ @ - 543 , 7 + 517 , 7 @ @ public class RealmAsyncQueryTests { <nl> / / 8 - the notification should be called once ( when we retry automatically we shouldn ' t <nl> / / notify the user ) . <nl> @ Test <nl> - public void testFindAllAsyncRetry ( ) throws Throwable { <nl> + public void findAllAsync _ retry ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 642 , 7 + 616 , 7 @ @ public class RealmAsyncQueryTests { <nl> / / 6 - now REALM _ CHANGED will trigger a COMPLETED _ UPDATE _ ASYNC _ QUERIES that should update all queries <nl> / / 7 - callbacks are notified with the latest results ( called twice overall ) <nl> @ Test <nl> - public void testFindAllAsyncBatchUpdate ( ) throws Throwable { <nl> + public void findAllAsync _ batchUpdate ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 804 , 7 + 778 , 7 @ @ public class RealmAsyncQueryTests { <nl> / / is operating on a previous version , this should retry the query on the worker thread <nl> / / to deliver the results once ( using the latest version of the Realm ) <nl> @ Test <nl> - public void testFindAllCallerIsAdvanced ( ) throws Throwable { <nl> + public void findAllAsync _ callerIsAdvanced ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch callbackInvokedFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> @ @ - 958 , 7 + 932 , 7 @ @ public class RealmAsyncQueryTests { <nl> / / update ( using the latest realm ) for all async queries is in progress <nl> / / 7 - onChange notification will be triggered once <nl> @ Test <nl> - public void testFindAllCallerThreadBehind ( ) throws Throwable { <nl> + public void findAllAsync _ callerThreadBehind ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 1095 , 7 + 1069 , 7 @ @ public class RealmAsyncQueryTests { <nl> <nl> / / similar UC as # testFindAllAsync using ' findFirst ' <nl> @ Test <nl> - public void testFindFirstAsync ( ) throws Throwable { <nl> + public void findFirstAsync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 1162 , 8 + 1136 , 8 @ @ public class RealmAsyncQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testFindFirstAsyncWithInitialEmptyRow ( ) throws Throwable { <nl> - final AllTypes firstAsync = workerThread . realm . where ( AllTypes . class ) . findFirstAsync ( ) ; <nl> + public void findFirstAsync _ initalEmptyRow ( ) throws Throwable { <nl> + final AllTypes firstAsync = looperThread . realm . where ( AllTypes . class ) . findFirstAsync ( ) ; <nl> firstAsync . addChangeListener ( new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> @ @ - 1171 , 26 + 1145 , 26 @ @ public class RealmAsyncQueryTests { <nl> assertTrue ( firstAsync . isLoaded ( ) ) ; <nl> assertTrue ( firstAsync . isValid ( ) ) ; <nl> assertEquals ( 0 , firstAsync . getColumnLong ( ) ) ; <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> } ) ; <nl> assertTrue ( firstAsync . load ( ) ) ; <nl> assertTrue ( firstAsync . isLoaded ( ) ) ; <nl> assertFalse ( firstAsync . isValid ( ) ) ; <nl> <nl> - populateTestRealm ( workerThread . realm , 10 ) ; <nl> - workerThread . keepStrongReference . add ( firstAsync ) ; <nl> + populateTestRealm ( looperThread . realm , 10 ) ; <nl> + looperThread . keepStrongReference . add ( firstAsync ) ; <nl> } <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testFindFirstAsyncUpdatedIfSyncRealmObjectIsUpdated ( ) throws Throwable { <nl> - populateTestRealm ( workerThread . realm , 1 ) ; <nl> - AllTypes firstSync = workerThread . realm . where ( AllTypes . class ) . findFirst ( ) ; <nl> + public void findFirstAsync _ updatedIfsyncRealmObjectIsUpdated ( ) throws Throwable { <nl> + populateTestRealm ( looperThread . realm , 1 ) ; <nl> + AllTypes firstSync = looperThread . realm . where ( AllTypes . class ) . findFirst ( ) ; <nl> assertEquals ( 0 , firstSync . getColumnLong ( ) ) ; <nl> assertEquals ( " test data 0 " , firstSync . getColumnString ( ) ) ; <nl> <nl> - final AllTypes firstAsync = workerThread . realm . where ( AllTypes . class ) . findFirstAsync ( ) ; <nl> + final AllTypes firstAsync = looperThread . realm . where ( AllTypes . class ) . findFirstAsync ( ) ; <nl> assertTrue ( firstAsync . load ( ) ) ; <nl> assertTrue ( firstAsync . isLoaded ( ) ) ; <nl> assertTrue ( firstAsync . isValid ( ) ) ; <nl> @ @ - 1201 , 24 + 1175 , 24 @ @ public class RealmAsyncQueryTests { <nl> @ Override <nl> public void onChange ( ) { <nl> assertEquals ( " Galacticon " , firstAsync . getColumnString ( ) ) ; <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> } ) ; <nl> <nl> - workerThread . realm . beginTransaction ( ) ; <nl> + looperThread . realm . beginTransaction ( ) ; <nl> firstSync . setColumnString ( " Galacticon " ) ; <nl> - workerThread . realm . commitTransaction ( ) ; <nl> + looperThread . realm . commitTransaction ( ) ; <nl> } <nl> <nl> / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded <nl> / / using a callback to be notified when the data is loaded <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testFindFirstAsyncWithNotification ( ) throws Throwable { <nl> + public void findFirstAsync _ withNotification ( ) throws Throwable { <nl> Realm . asyncQueryExecutor . pause ( ) ; <nl> <nl> - populateTestRealm ( workerThread . realm , 10 ) ; <nl> - final AllTypes realmResults = workerThread . realm . where ( AllTypes . class ) <nl> + populateTestRealm ( looperThread . realm , 10 ) ; <nl> + final AllTypes realmResults = looperThread . realm . where ( AllTypes . class ) <nl> . between ( " columnLong " , 4 , 9 ) <nl> . findFirstAsync ( ) ; <nl> <nl> @ @ - 1228 , 7 + 1202 , 7 @ @ public class RealmAsyncQueryTests { <nl> assertTrue ( realmResults . isLoaded ( ) ) ; <nl> assertTrue ( realmResults . isValid ( ) ) ; <nl> assertEquals ( " test data 4 " , realmResults . getColumnString ( ) ) ; <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> } ) ; <nl> <nl> @ @ - 1241 , 17 + 1215 , 17 @ @ public class RealmAsyncQueryTests { <nl> } <nl> <nl> Realm . asyncQueryExecutor . resume ( ) ; <nl> - workerThread . keepStrongReference . add ( realmResults ) ; <nl> + looperThread . keepStrongReference . add ( realmResults ) ; <nl> } <nl> <nl> / / similar UC as # testForceLoadAsync using ' findFirst ' <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testForceLoadFindFirstAsync ( ) throws Throwable { <nl> + public void findFirstAsync _ forceLoad ( ) throws Throwable { <nl> Realm . asyncQueryExecutor . pause ( ) ; <nl> <nl> - populateTestRealm ( workerThread . realm , 10 ) ; <nl> - final AllTypes realmResults = workerThread . realm . where ( AllTypes . class ) <nl> + populateTestRealm ( looperThread . realm , 10 ) ; <nl> + final AllTypes realmResults = looperThread . realm . where ( AllTypes . class ) <nl> . between ( " columnLong " , 4 , 9 ) <nl> . findFirstAsync ( ) ; <nl> <nl> @ @ - 1263 , 12 + 1237 , 12 @ @ public class RealmAsyncQueryTests { <nl> assertTrue ( realmResults . isLoaded ( ) ) ; <nl> assertEquals ( " test data 4 " , realmResults . getColumnString ( ) ) ; <nl> <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> <nl> / / similar UC as # testFindAllAsyncRetry using ' findFirst ' <nl> @ Test <nl> - public void testFindFirstAsyncRetry ( ) throws Throwable { <nl> + public void findFirstAsync _ retry ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 1370 , 7 + 1344 , 7 @ @ public class RealmAsyncQueryTests { <nl> <nl> / / similar UC as # testFindAllAsync using ' findAllSorted ' <nl> @ Test <nl> - public void testFindAllSortedAsync ( ) throws Throwable { <nl> + public void findAllSortedAsync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 1453 , 7 + 1427 , 7 @ @ public class RealmAsyncQueryTests { <nl> / / finding elements [ 4 - 8 ] asynchronously then wait for the promise to be loaded <nl> / / using a callback to be notified when the data is loaded <nl> @ Test <nl> - public void testFindAllSortedAsyncRetry ( ) throws Throwable { <nl> + public void findAllSortedAsync _ retry ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 1545 , 7 + 1519 , 7 @ @ public class RealmAsyncQueryTests { <nl> <nl> / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSorted ' <nl> @ Test <nl> - public void testFindAllSortedAsyncBatchUpdate ( ) throws Throwable { <nl> + public void findAllSortedAsync _ batchUpdate ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 1706 , 7 + 1680 , 7 @ @ public class RealmAsyncQueryTests { <nl> <nl> / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSortedMulti ' <nl> @ Test <nl> - public void testFindAllSortedMultiAsyncBatchUpdate ( ) throws Throwable { <nl> + public void findAllSortedAsync _ multipleFields _ batchUpdate ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 1947 , 8 + 1921 , 8 @ @ public class RealmAsyncQueryTests { <nl> / / if unregistered properly . <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testListenerShouldNotLeak ( ) { <nl> - populateTestRealm ( workerThread . realm , 10 ) ; <nl> + public void listenerShouldNotLeak ( ) { <nl> + populateTestRealm ( looperThread . realm , 10 ) ; <nl> <nl> / / simulate the ActivityManager by creating 1 instance responsible <nl> / / of attaching an onChange listener , then simulate a configuration <nl> @ @ - 1956 , 14 + 1930 , 14 @ @ public class RealmAsyncQueryTests { <nl> / / we make sure that the GC enqueue the reference of the destroyed instance <nl> / / which indicate no memory leak <nl> MockActivityManager mockActivityManager = <nl> - MockActivityManager . newInstance ( workerThread . realm . getConfiguration ( ) ) ; <nl> + MockActivityManager . newInstance ( looperThread . realm . getConfiguration ( ) ) ; <nl> <nl> mockActivityManager . sendConfigurationChange ( ) ; <nl> <nl> assertEquals ( 1 , mockActivityManager . numberOfInstances ( ) ) ; <nl> / / remove GC ' d reference & assert that one instance should remain <nl> Iterator < Map . Entry < WeakReference < RealmResults < ? > > , RealmQuery < ? > > > iterator = <nl> - workerThread . realm . handlerController . asyncRealmResults . entrySet ( ) . iterator ( ) ; <nl> + looperThread . realm . handlerController . asyncRealmResults . entrySet ( ) . iterator ( ) ; <nl> while ( iterator . hasNext ( ) ) { <nl> Map . Entry < WeakReference < RealmResults < ? > > , RealmQuery < ? > > entry = iterator . next ( ) ; <nl> RealmResults < ? > weakReference = entry . getKey ( ) . get ( ) ; <nl> @ @ - 1972 , 18 + 1946 , 18 @ @ public class RealmAsyncQueryTests { <nl> } <nl> } <nl> <nl> - assertEquals ( 1 , workerThread . realm . handlerController . asyncRealmResults . size ( ) ) ; <nl> + assertEquals ( 1 , looperThread . realm . handlerController . asyncRealmResults . size ( ) ) ; <nl> mockActivityManager . onStop ( ) ; / / to close the Realm <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testCombiningAsyncAndSync ( ) { <nl> - populateTestRealm ( workerThread . realm , 10 ) ; <nl> + public void combiningAsyncAndSync ( ) { <nl> + populateTestRealm ( looperThread . realm , 10 ) ; <nl> <nl> Realm . asyncQueryExecutor . pause ( ) ; <nl> - final RealmResults < AllTypes > allTypesAsync = workerThread . realm . where ( AllTypes . class ) . greaterThan ( " columnLong " , 5 ) . findAllAsync ( ) ; <nl> + final RealmResults < AllTypes > allTypesAsync = looperThread . realm . where ( AllTypes . class ) . greaterThan ( " columnLong " , 5 ) . findAllAsync ( ) ; <nl> final RealmResults < AllTypes > allTypesSync = allTypesAsync . where ( ) . greaterThan ( " columnLong " , 3 ) . findAll ( ) ; <nl> <nl> assertEquals ( 0 , allTypesAsync . size ( ) ) ; <nl> @ @ - 1993 , 18 + 1967 , 18 @ @ public class RealmAsyncQueryTests { <nl> public void onChange ( ) { <nl> assertEquals ( 4 , allTypesAsync . size ( ) ) ; <nl> assertEquals ( 6 , allTypesSync . size ( ) ) ; <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> } ) ; <nl> Realm . asyncQueryExecutor . resume ( ) ; <nl> - workerThread . keepStrongReference . add ( allTypesAsync ) ; <nl> + looperThread . keepStrongReference . add ( allTypesAsync ) ; <nl> } <nl> <nl> / / keep advancing the Realm by sending 1 commit for each frame ( 16ms ) <nl> / / the async queries should keep up with the modification <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testStressTestBackgroundCommits ( ) throws Throwable { <nl> + public void stressTestBackgroundCommits ( ) throws Throwable { <nl> final int NUMBER _ OF _ COMMITS = 100 ; <nl> final CountDownLatch bgRealmClosed = new CountDownLatch ( 1 ) ; <nl> final long [ ] latestLongValue = new long [ 1 ] ; <nl> @ @ - 2014 , 7 + 1988 , 7 @ @ public class RealmAsyncQueryTests { <nl> @ Override <nl> public void run ( ) { <nl> Random random = new Random ( System . currentTimeMillis ( ) ) ; <nl> - Realm backgroundThreadRealm = Realm . getInstance ( workerThread . realm . getConfiguration ( ) ) ; <nl> + Realm backgroundThreadRealm = Realm . getInstance ( looperThread . realm . getConfiguration ( ) ) ; <nl> for ( int i = 0 ; i < NUMBER _ OF _ COMMITS ; i + + ) { <nl> backgroundThreadRealm . beginTransaction ( ) ; <nl> AllTypes object = backgroundThreadRealm . createObject ( AllTypes . class ) ; <nl> @ @ - 2032 , 25 + 2006 , 25 @ @ public class RealmAsyncQueryTests { <nl> } <nl> } ; <nl> <nl> - final RealmResults < AllTypes > allAsync = workerThread . realm . where ( AllTypes . class ) . findAllAsync ( ) ; <nl> + final RealmResults < AllTypes > allAsync = looperThread . realm . where ( AllTypes . class ) . findAllAsync ( ) ; <nl> allAsync . addChangeListener ( new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> assertTrue ( allAsync . isLoaded ( ) ) ; <nl> if ( allAsync . size ( ) = = NUMBER _ OF _ COMMITS ) { <nl> - AllTypes lastInserted = workerThread . realm . where ( AllTypes . class ) <nl> + AllTypes lastInserted = looperThread . realm . where ( AllTypes . class ) <nl> . equalTo ( " columnLong " , latestLongValue [ 0 ] ) <nl> . equalTo ( " columnFloat " , latestFloatValue [ 0 ] ) <nl> . findFirst ( ) ; <nl> assertNotNull ( lastInserted ) ; <nl> TestHelper . awaitOrFail ( bgRealmClosed ) ; <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> } <nl> } ) ; <nl> - workerThread . keepStrongReference . add ( allAsync ) ; <nl> + looperThread . keepStrongReference . add ( allAsync ) ; <nl> <nl> - workerThread . realm . handler . postDelayed ( new Runnable ( ) { <nl> + looperThread . realm . handler . postDelayed ( new Runnable ( ) { <nl> @ Override <nl> public void run ( ) { <nl> backgroundThread . start ( ) ; <nl> @ @ - 2059 , 7 + 2033 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> <nl> @ Test <nl> - public void testAsyncDistinct ( ) throws Throwable { <nl> + public void distinctAsync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 4 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 2156 , 7 + 2130 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> <nl> @ Test <nl> - public void testAsyncDistinctNotIndexedFields ( ) throws Throwable { <nl> + public void distinctAsync _ notIndexedFields ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 4 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> @ @ - 2207 , 47 + 2181 , 47 @ @ public class RealmAsyncQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testAsyncDistinctFieldDoesNotExist ( ) throws Throwable { <nl> + public void distinctAsync _ noneExistingField ( ) throws Throwable { <nl> final long numberOfBlocks = 25 ; <nl> final long numberOfObjects = 10 ; / / must be greater than 1 <nl> - populateForDistinct ( workerThread . realm , numberOfBlocks , numberOfObjects , false ) ; <nl> + populateForDistinct ( looperThread . realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> try { <nl> - workerThread . realm . distinctAsync ( AnnotationIndexTypes . class , " doesNotExist " ) ; <nl> + looperThread . realm . distinctAsync ( AnnotationIndexTypes . class , " doesNotExist " ) ; <nl> fail ( ) ; <nl> } catch ( IllegalArgumentException ignored ) { <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> } <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void testBatchUpdateDifferentTypeOfQueries ( ) { <nl> - workerThread . realm . beginTransaction ( ) ; <nl> + public void batchUpdateDifferentTypeOfQueries ( ) { <nl> + looperThread . realm . beginTransaction ( ) ; <nl> for ( int i = 0 ; i < 5 ; ) { <nl> - AllTypes allTypes = workerThread . realm . createObject ( AllTypes . class ) ; <nl> + AllTypes allTypes = looperThread . realm . createObject ( AllTypes . class ) ; <nl> allTypes . setColumnLong ( i ) ; <nl> allTypes . setColumnString ( " data " + i % 3 ) ; <nl> <nl> - allTypes = workerThread . realm . createObject ( AllTypes . class ) ; <nl> + allTypes = looperThread . realm . createObject ( AllTypes . class ) ; <nl> allTypes . setColumnLong ( i ) ; <nl> allTypes . setColumnString ( " data " + ( + + i % 3 ) ) ; <nl> } <nl> final long numberOfBlocks = 25 ; <nl> final long numberOfObjects = 10 ; / / must be greater than 1 <nl> - workerThread . realm . commitTransaction ( ) ; <nl> - populateForDistinct ( workerThread . realm , numberOfBlocks , numberOfObjects , false ) ; <nl> + looperThread . realm . commitTransaction ( ) ; <nl> + populateForDistinct ( looperThread . realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> - RealmResults < AllTypes > findAllAsync = workerThread . realm . where ( AllTypes . class ) . findAllAsync ( ) ; <nl> - RealmResults < AllTypes > findAllSorted = workerThread . realm . where ( AllTypes . class ) . findAllSortedAsync ( " columnString " , Sort . ASCENDING ) ; <nl> - RealmResults < AllTypes > findAllSortedMulti = workerThread . realm . where ( AllTypes . class ) . findAllSortedAsync ( new String [ ] { " columnString " , " columnLong " } , <nl> + RealmResults < AllTypes > findAllAsync = looperThread . realm . where ( AllTypes . class ) . findAllAsync ( ) ; <nl> + RealmResults < AllTypes > findAllSorted = looperThread . realm . where ( AllTypes . class ) . findAllSortedAsync ( " columnString " , Sort . ASCENDING ) ; <nl> + RealmResults < AllTypes > findAllSortedMulti = looperThread . realm . where ( AllTypes . class ) . findAllSortedAsync ( new String [ ] { " columnString " , " columnLong " } , <nl> new Sort [ ] { Sort . ASCENDING , Sort . DESCENDING } ) ; <nl> - RealmResults < AnnotationIndexTypes > findDistinct = workerThread . realm . distinctAsync ( AnnotationIndexTypes . class , " indexString " ) ; <nl> + RealmResults < AnnotationIndexTypes > findDistinct = looperThread . realm . distinctAsync ( AnnotationIndexTypes . class , " indexString " ) ; <nl> <nl> - workerThread . keepStrongReference . add ( findAllAsync ) ; <nl> - workerThread . keepStrongReference . add ( findAllSorted ) ; <nl> - workerThread . keepStrongReference . add ( findAllSortedMulti ) ; <nl> - workerThread . keepStrongReference . add ( findDistinct ) ; <nl> + looperThread . keepStrongReference . add ( findAllAsync ) ; <nl> + looperThread . keepStrongReference . add ( findAllSorted ) ; <nl> + looperThread . keepStrongReference . add ( findAllSortedMulti ) ; <nl> + looperThread . keepStrongReference . add ( findDistinct ) ; <nl> <nl> final CountDownLatch queriesCompleted = new CountDownLatch ( 4 ) ; <nl> final AtomicInteger batchUpdateCompleted = new AtomicInteger ( 0 ) ; <nl> @ @ - 2266 , 7 + 2240 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> case 2 : { <nl> if ( batchUpdateCompleted . incrementAndGet ( ) = = 4 ) { <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> break ; <nl> } <nl> @ @ - 2284 , 7 + 2258 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> case 2 : { <nl> if ( batchUpdateCompleted . incrementAndGet ( ) = = 4 ) { <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> break ; <nl> } <nl> @ @ - 2302 , 7 + 2276 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> case 2 : { <nl> if ( batchUpdateCompleted . incrementAndGet ( ) = = 4 ) { <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> break ; <nl> } <nl> @ @ - 2320 , 7 + 2294 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> case 2 : { <nl> if ( batchUpdateCompleted . incrementAndGet ( ) = = 4 ) { <nl> - workerThread . testComplete ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> } <nl> break ; <nl> } <nl> @ @ - 2335 , 7 + 2309 , 7 @ @ public class RealmAsyncQueryTests { <nl> public void run ( ) { <nl> try { <nl> queriesCompleted . await ( ) ; <nl> - Realm bgRealm = Realm . getInstance ( workerThread . realm . getConfiguration ( ) ) ; <nl> + Realm bgRealm = Realm . getInstance ( looperThread . realm . getConfiguration ( ) ) ; <nl> <nl> bgRealm . beginTransaction ( ) ; <nl> bgRealm . createObject ( AllTypes . class ) ; <nl> @ @ - 2351 , 7 + 2325 , 7 @ @ public class RealmAsyncQueryTests { <nl> } <nl> <nl> / / this test make sure that Async queries update when using link <nl> - public void testQueryingLinkHandover ( ) throws Throwable { <nl> + public void queryingLinkHandover ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final AtomicInteger numberOfInvocations = new AtomicInteger ( 0 ) ;

TEST DIFF:
diff - - git a / CHANGELOG . md b / CHANGELOG . md 
 index c44194c . . 244b15d 100644 
 - - - a / CHANGELOG . md 
 + + + b / CHANGELOG . md 
 @ @ - 1 , 5 + 1 , 9 @ @ 
 # # 4 . 0 . 0 - BETA3 ( YYYY - MM - DD ) 
 
 + # # # Breaking Changes 
 + 
 + * ` RealmResults . distinct ( ) ` / ` RealmResults . distinctAsync ( ) ` have been removed . Use ` RealmQuery . distinct ( ) ` / ` RealmQuery . distinctAsync ( ) ` instead . 
 + 
 # # # Internal 
 
 * Upgraded to Realm Sync 2 . 0 . 0 - rc16 . 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java 
 index 353d588 . . 0c6f652 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java 
 @ @ - 3034 , 8 + 3034 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinct ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; / / Must be greater than 1 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 @ @ - 3048 , 8 + 3048 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinct _ withNullValues ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 
 for ( String field : new String [ ] { AnnotationIndexTypes . FIELD _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ INDEX _ STRING } ) { 
 @ @ - 3060 , 8 + 3060 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinct _ notIndexedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) 
 @ @ - 3076 , 8 + 3076 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinct _ doesNotExist ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; / / Must be greater than 1 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 try { 
 @ @ - 3101 , 8 + 3101 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinct _ indexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 
 for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { 
 @ @ - 3116 , 8 + 3116 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinct _ notIndexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 
 for ( String field : AnnotationIndexTypes . NOT _ INDEX _ FIELDS ) { 
 @ @ - 3144 , 8 + 3144 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 public void distinctAsync ( ) throws Throwable { 
 final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; 
 final Realm realm = looperThread . getRealm ( ) ; 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; / / Must be greater than 1 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 @ @ - 3220 , 8 + 3220 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 public void distinctAsync _ withNullValues ( ) throws Throwable { 
 final AtomicInteger changeListenerCalled = new AtomicInteger ( 2 ) ; 
 final Realm realm = looperThread . getRealm ( ) ; 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / must be greater than 1 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; / / must be greater than 1 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 
 final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) 
 @ @ - 3261 , 8 + 3261 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 @ Test 
 @ RunTestInLooperThread 
 public void distinctAsync _ doesNotExist ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 try { 
 @ @ - 3289 , 8 + 3289 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 @ Test 
 @ RunTestInLooperThread 
 public void distinctAsync _ indexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { 
 @ @ - 3317 , 8 + 3317 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinctMultiArgs ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; / / Must be greater than 1 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; 
 @ @ - 3328 , 7 + 3328 , 7 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinctMultiArgs _ switchedFieldsOrder ( ) { 
 - final long numberOfBlocks = 25 ; 
 + final long numberOfBlocks = 3 ; 
 TestHelper . populateForDistinctFieldsOrder ( realm , numberOfBlocks ) ; 
 
 / / Regardless of the block size defined above , the output size is expected to be the same , 4 in this case , due to receiving unique combinations of tuples . 
 @ @ - 3342 , 8 + 3342 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinctMultiArgs _ emptyField ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; 
 @ @ - 3396 , 8 + 3396 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinctMultiArgs _ withNullValues ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 
 RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; 
 @ @ - 3407 , 8 + 3407 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinctMultiArgs _ notIndexedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; 
 @ @ - 3420 , 8 + 3420 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinctMultiArgs _ doesNotExistField ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; 
 @ @ - 3444 , 8 + 3444 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinctMultiArgs _ indexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 
 RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; 
 @ @ - 3457 , 8 + 3457 , 8 @ @ public class RealmQueryTests extends QueryTests { 
 
 @ Test 
 public void distinctMultiArgs _ notIndexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 + final long numberOfBlocks = 3 ; 
 + final long numberOfObjects = 3 ; 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 
 RealmQuery < AnnotationIndexTypes > query = realm . where ( AnnotationIndexTypes . class ) ; 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java 
 index b4ead0c . . d087c59 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java 
 @ @ - 34 , 9 + 34 , 7 @ @ import java . util . List ; 
 import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 
 - import io . realm . entities . AllJavaTypes ; 
 import io . realm . entities . AllTypes ; 
 - import io . realm . entities . AnnotationIndexTypes ; 
 import io . realm . entities . DefaultValueOfField ; 
 import io . realm . entities . Dog ; 
 import io . realm . entities . NonLatinFieldNames ; 
 @ @ - 49 , 7 + 47 , 6 @ @ import io . realm . rule . RunTestInLooperThread ; 
 import io . realm . rule . TestRealmConfigurationFactory ; 
 
 import static org . junit . Assert . assertEquals ; 
 - import static org . junit . Assert . assertFalse ; 
 import static org . junit . Assert . assertNull ; 
 import static org . junit . Assert . assertTrue ; 
 import static org . junit . Assert . fail ; 
 @ @ - 185 , 166 + 182 , 6 @ @ public class RealmResultsTests extends CollectionTests { 
 assertEquals ( 10 , realm . where ( AllTypes . class ) . lessThan ( AllTypes . FIELD _ LONG , 0 ) . findAll ( ) . size ( ) ) ; 
 } 
 
 - / / RealmResults . distinct ( ) : requires indexing , and type = boolean , integer , date , string . 
 - private void populateForDistinct ( Realm realm , long numberOfBlocks , long numberOfObjects , boolean withNull ) { 
 - realm . beginTransaction ( ) ; 
 - for ( int i = 0 ; i < numberOfObjects * numberOfBlocks ; i + + ) { 
 - for ( int j = 0 ; j < numberOfBlocks ; j + + ) { 
 - AnnotationIndexTypes obj = realm . createObject ( AnnotationIndexTypes . class ) ; 
 - obj . setIndexBoolean ( j % 2 = = 0 ) ; 
 - obj . setIndexLong ( j ) ; 
 - obj . setIndexDate ( withNull ? null : new Date ( 1000 * ( long ) j ) ) ; 
 - obj . setIndexString ( withNull ? null : " Test " + j ) ; 
 - obj . setNotIndexBoolean ( j % 2 = = 0 ) ; 
 - obj . setNotIndexLong ( j ) ; 
 - obj . setNotIndexDate ( withNull ? null : new Date ( 1000 * ( long ) j ) ) ; 
 - obj . setNotIndexString ( withNull ? null : " Test " + j ) ; 
 - } 
 - } 
 - realm . commitTransaction ( ) ; 
 - } 
 - 
 - private void populateForDistinctInvalidTypesLinked ( Realm realm ) { 
 - realm . beginTransaction ( ) ; 
 - AllJavaTypes notEmpty = new AllJavaTypes ( ) ; 
 - notEmpty . setFieldBinary ( new byte [ ] { 1 , 2 , 3 } ) ; 
 - notEmpty . setFieldObject ( notEmpty ) ; 
 - notEmpty . setFieldList ( new RealmList < AllJavaTypes > ( notEmpty ) ) ; 
 - realm . copyToRealm ( notEmpty ) ; 
 - realm . commitTransaction ( ) ; 
 - } 
 - 
 - @ Test 
 - public void distinct ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 - assertEquals ( 2 , distinctBool . size ( ) ) ; 
 - for ( String field : new String [ ] { AnnotationIndexTypes . FIELD _ INDEX _ LONG , AnnotationIndexTypes . FIELD _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ INDEX _ STRING } ) { 
 - RealmResults < AnnotationIndexTypes > distinct = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( field ) ; 
 - assertEquals ( field , numberOfBlocks , distinct . size ( ) ) ; 
 - } 
 - } 
 - 
 - @ Test 
 - @ SuppressWarnings ( " ReferenceEquality " ) 
 - public void distinct _ restrictedByPreviousDistinct ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - / / All objects 
 - RealmResults < AnnotationIndexTypes > allResults = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - assertEquals ( " All Objects Count " , numberOfBlocks * numberOfBlocks * numberOfObjects , allResults . size ( ) ) ; 
 - / / Distinctive dates 
 - RealmResults < AnnotationIndexTypes > distinctDates = allResults . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; 
 - assertEquals ( " Distinctive Dates " , numberOfBlocks , distinctDates . size ( ) ) ; 
 - / / Distinctive Booleans 
 - RealmResults < AnnotationIndexTypes > distinctBooleans = distinctDates . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 - assertEquals ( " Distinctive Booleans " , 2 , distinctBooleans . size ( ) ) ; 
 - / / distinct results are not the same object 
 - assertTrue ( allResults ! = distinctDates ) ; 
 - assertTrue ( allResults ! = distinctBooleans ) ; 
 - } 
 - 
 - @ Test 
 - public void distinct _ withNullValues ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 - 
 - for ( String field : new String [ ] { AnnotationIndexTypes . FIELD _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ INDEX _ STRING } ) { 
 - RealmResults < AnnotationIndexTypes > distinct = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( field ) ; 
 - assertEquals ( field , 1 , distinct . size ( ) ) ; 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinct _ notIndexedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) 
 - . findAll ( ) . distinct ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ BOOL ) ; 
 - assertEquals ( 2 , distinctBool . size ( ) ) ; 
 - for ( String field : new String [ ] { AnnotationIndexTypes . FIELD _ NOT _ INDEX _ LONG , 
 - AnnotationIndexTypes . FIELD _ NOT _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ NOT _ INDEX _ STRING } ) { 
 - RealmResults < AnnotationIndexTypes > distinct = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinct ( field ) ; 
 - assertEquals ( field , numberOfBlocks , distinct . size ( ) ) ; 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinct _ noneExistingField ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - try { 
 - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( " doesNotExist " ) ; 
 - fail ( ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinct _ invalidTypes ( ) { 
 - populateTestRealm ( ) ; 
 - 
 - for ( String field : new String [ ] { AllTypes . FIELD _ REALMOBJECT , AllTypes . FIELD _ REALMLIST , AllTypes . FIELD _ DOUBLE , AllTypes . FIELD _ FLOAT } ) { 
 - try { 
 - realm . where ( AllTypes . class ) . findAll ( ) . distinct ( field ) ; 
 - fail ( field ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinct _ indexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 - 
 - for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { 
 - try { 
 - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; 
 - fail ( " Unsupported Index " + field + " linked field " ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinct _ notIndexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 - 
 - for ( String field : AnnotationIndexTypes . NOT _ INDEX _ FIELDS ) { 
 - try { 
 - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinct ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; 
 - fail ( " Unsupported notIndex " + field + " linked field " ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinct _ invalidTypesLinkedFields ( ) { 
 - populateForDistinctInvalidTypesLinked ( realm ) ; 
 - 
 - try { 
 - realm . where ( AllJavaTypes . class ) . findAll ( ) . distinct ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) ; 
 - fail ( " Unsupported columnBinary linked field " ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - 
 @ Test 
 @ RunTestInLooperThread 
 public void changeListener _ syncIfNeeded _ updatedFromOtherThread ( ) { 
 @ @ - 417 , 430 + 254 , 6 @ @ public class RealmResultsTests extends CollectionTests { 
 testRealm . commitTransaction ( ) ; 
 } 
 
 - @ Test 
 - @ RunTestInLooperThread 
 - public void distinctAsync ( ) throws Throwable { 
 - final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; 
 - final Realm realm = looperThread . getRealm ( ) ; 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 - 
 - assertFalse ( distinctBool . isLoaded ( ) ) ; 
 - assertTrue ( distinctBool . isValid ( ) ) ; 
 - assertTrue ( distinctBool . isEmpty ( ) ) ; 
 - 
 - assertFalse ( distinctLong . isLoaded ( ) ) ; 
 - assertTrue ( distinctLong . isValid ( ) ) ; 
 - assertTrue ( distinctLong . isEmpty ( ) ) ; 
 - 
 - assertFalse ( distinctDate . isLoaded ( ) ) ; 
 - assertTrue ( distinctDate . isValid ( ) ) ; 
 - assertTrue ( distinctDate . isEmpty ( ) ) ; 
 - 
 - assertFalse ( distinctString . isLoaded ( ) ) ; 
 - assertTrue ( distinctString . isValid ( ) ) ; 
 - assertTrue ( distinctString . isEmpty ( ) ) ; 
 - 
 - final Runnable endTest = new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - if ( changeListenerCalled . decrementAndGet ( ) = = 0 ) { 
 - looperThread . testComplete ( ) ; 
 - } 
 - } 
 - } ; 
 - 
 - looperThread . keepStrongReference ( distinctBool ) ; 
 - looperThread . keepStrongReference ( distinctLong ) ; 
 - looperThread . keepStrongReference ( distinctDate ) ; 
 - looperThread . keepStrongReference ( distinctString ) ; 
 - distinctBool . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( 2 , distinctBool . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - 
 - distinctLong . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( numberOfBlocks , distinctLong . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - 
 - distinctDate . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( numberOfBlocks , distinctDate . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - 
 - distinctString . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( numberOfBlocks , distinctString . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - } 
 - 
 - @ Test 
 - @ RunTestInLooperThread 
 - public void distinctAsync _ withNullValues ( ) throws Throwable { 
 - final AtomicInteger changeListenerCalled = new AtomicInteger ( 2 ) ; 
 - final Realm realm = looperThread . getRealm ( ) ; 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 - 
 - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 - 
 - assertFalse ( distinctDate . isLoaded ( ) ) ; 
 - assertTrue ( distinctDate . isValid ( ) ) ; 
 - assertTrue ( distinctDate . isEmpty ( ) ) ; 
 - 
 - assertFalse ( distinctString . isLoaded ( ) ) ; 
 - assertTrue ( distinctString . isValid ( ) ) ; 
 - assertTrue ( distinctString . isEmpty ( ) ) ; 
 - 
 - final Runnable endTest = new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - if ( changeListenerCalled . decrementAndGet ( ) = = 0 ) { 
 - looperThread . testComplete ( ) ; 
 - } 
 - } 
 - } ; 
 - 
 - looperThread . keepStrongReference ( distinctDate ) ; 
 - looperThread . keepStrongReference ( distinctString ) ; 
 - distinctDate . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( " distinctDate " , 1 , distinctDate . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - 
 - distinctString . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( " distinctString " , 1 , distinctString . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - } 
 - 
 - @ Test 
 - @ RunTestInLooperThread 
 - public void distinctAsync _ notIndexedFields ( ) { 
 - final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; 
 - Realm realm = looperThread . getRealm ( ) ; 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinctAsync ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ LONG ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinctAsync ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ DATE ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinctAsync ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ STRING ) ; 
 - 
 - assertFalse ( distinctBool . isLoaded ( ) ) ; 
 - assertTrue ( distinctBool . isValid ( ) ) ; 
 - assertTrue ( distinctBool . isEmpty ( ) ) ; 
 - 
 - assertFalse ( distinctLong . isLoaded ( ) ) ; 
 - assertTrue ( distinctLong . isValid ( ) ) ; 
 - assertTrue ( distinctLong . isEmpty ( ) ) ; 
 - 
 - assertFalse ( distinctDate . isLoaded ( ) ) ; 
 - assertTrue ( distinctDate . isValid ( ) ) ; 
 - assertTrue ( distinctDate . isEmpty ( ) ) ; 
 - 
 - assertFalse ( distinctString . isLoaded ( ) ) ; 
 - assertTrue ( distinctString . isValid ( ) ) ; 
 - assertTrue ( distinctString . isEmpty ( ) ) ; 
 - 
 - final Runnable endTest = new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - if ( changeListenerCalled . decrementAndGet ( ) = = 0 ) { 
 - looperThread . testComplete ( ) ; 
 - } 
 - } 
 - } ; 
 - 
 - looperThread . keepStrongReference ( distinctBool ) ; 
 - looperThread . keepStrongReference ( distinctLong ) ; 
 - looperThread . keepStrongReference ( distinctDate ) ; 
 - looperThread . keepStrongReference ( distinctString ) ; 
 - distinctBool . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( 2 , distinctBool . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - 
 - distinctLong . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( numberOfBlocks , distinctLong . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - 
 - distinctDate . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( numberOfBlocks , distinctDate . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - 
 - distinctString . addChangeListener ( new RealmChangeListener < RealmResults < AnnotationIndexTypes > > ( ) { 
 - @ Override 
 - public void onChange ( RealmResults < AnnotationIndexTypes > object ) { 
 - assertEquals ( numberOfBlocks , distinctString . size ( ) ) ; 
 - endTest . run ( ) ; 
 - } 
 - } ) ; 
 - } 
 - 
 - @ Test 
 - @ RunTestInLooperThread 
 - public void distinctAsync _ doesNotExist ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - try { 
 - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( " doesNotExist " ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - looperThread . testComplete ( ) ; 
 - } 
 - 
 - @ Test 
 - @ RunTestInLooperThread 
 - public void distinctAsync _ invalidTypes ( ) { 
 - populateTestRealm ( realm , TEST _ DATA _ SIZE ) ; 
 - 
 - for ( String field : new String [ ] { AllTypes . FIELD _ REALMOBJECT , AllTypes . FIELD _ REALMLIST , AllTypes . FIELD _ DOUBLE , AllTypes . FIELD _ FLOAT } ) { 
 - try { 
 - realm . where ( AllTypes . class ) . findAll ( ) . distinctAsync ( field ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - looperThread . testComplete ( ) ; 
 - } 
 - 
 - @ Test 
 - @ RunTestInLooperThread 
 - public void distinctAsync _ indexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { 
 - try { 
 - realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; 
 - fail ( " Unsupported " + field + " linked field " ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - looperThread . testComplete ( ) ; 
 - } 
 - 
 - @ Test 
 - @ RunTestInLooperThread 
 - public void distinctAsync _ notIndexedLinkedFields ( ) { 
 - populateForDistinctInvalidTypesLinked ( realm ) ; 
 - 
 - try { 
 - realm . where ( AllJavaTypes . class ) . findAll ( ) . distinctAsync ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - looperThread . testComplete ( ) ; 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; / / Must be greater than 1 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - RealmResults < AnnotationIndexTypes > distinctMulti = results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , AnnotationIndexTypes . INDEX _ FIELDS ) ; 
 - assertEquals ( numberOfBlocks , distinctMulti . size ( ) ) ; 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs _ switchedFieldsOrder ( ) { 
 - final long numberOfBlocks = 25 ; 
 - TestHelper . populateForDistinctFieldsOrder ( realm , numberOfBlocks ) ; 
 - 
 - / / Regardless of the block size defined above , the output size is expected to be the same , 4 in this case , due to receiving unique combinations of tuples . 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - RealmResults < AnnotationIndexTypes > distinctStringLong = results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ STRING , AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; 
 - RealmResults < AnnotationIndexTypes > distinctLongString = results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ LONG , AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 - assertEquals ( 4 , distinctStringLong . size ( ) ) ; 
 - assertEquals ( 4 , distinctLongString . size ( ) ) ; 
 - assertEquals ( distinctStringLong . size ( ) , distinctLongString . size ( ) ) ; 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs _ emptyField ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - / / An empty string field in the middle . 
 - try { 
 - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , " " , AnnotationIndexTypes . FIELD _ INDEX _ INT ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - / / An empty string field at the end . 
 - try { 
 - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , AnnotationIndexTypes . FIELD _ INDEX _ INT , " " ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - / / A null string field in the middle . 
 - try { 
 - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , null , AnnotationIndexTypes . FIELD _ INDEX _ INT ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - / / A null string field at the end . 
 - try { 
 - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , AnnotationIndexTypes . FIELD _ INDEX _ INT , null ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - / / ( String ) Null makes varargs a null array . 
 - try { 
 - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL , ( String ) null ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - / / Two ( String ) null for first and varargs fields . 
 - try { 
 - results . distinct ( null , ( String ) null ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - / / " " & ( String ) null combination . 
 - try { 
 - results . distinct ( " " , ( String ) null ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - / / " " & ( String ) null combination . 
 - try { 
 - results . distinct ( null , " " ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - / / Two empty fields tests . 
 - try { 
 - results . distinct ( " " , " " ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs _ withNullValues ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - RealmResults < AnnotationIndexTypes > distinctMulti = results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE , AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 - assertEquals ( 1 , distinctMulti . size ( ) ) ; 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs _ notIndexedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - try { 
 - results . distinct ( AnnotationIndexTypes . FIELD _ NOT _ INDEX _ STRING , AnnotationIndexTypes . NOT _ INDEX _ FIELDS ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs _ doesNotExistField ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - try { 
 - results . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ INT , AnnotationIndexTypes . NONEXISTANT _ MIX _ FIELDS ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs _ invalidTypesFields ( ) { 
 - populateTestRealm ( ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - try { 
 - results . distinct ( AllTypes . FIELD _ REALMOBJECT , AllTypes . INVALID _ TYPES _ FIELDS _ FOR _ DISTINCT ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs _ indexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - try { 
 - results . distinct ( AnnotationIndexTypes . INDEX _ LINKED _ FIELD _ STRING , AnnotationIndexTypes . INDEX _ LINKED _ FIELDS ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs _ notIndexedLinkedFields ( ) { 
 - final long numberOfBlocks = 25 ; 
 - final long numberOfObjects = 10 ; 
 - populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - try { 
 - results . distinct ( AnnotationIndexTypes . NOT _ INDEX _ LINKED _ FILED _ STRING , AnnotationIndexTypes . NOT _ INDEX _ LINKED _ FIELDS ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 - 
 - @ Test 
 - public void distinctMultiArgs _ invalidTypesLinkedFields ( ) { 
 - populateForDistinctInvalidTypesLinked ( realm ) ; 
 - 
 - RealmResults < AnnotationIndexTypes > results = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) ; 
 - try { 
 - results . distinct ( AllJavaTypes . INVALID _ LINKED _ BINARY _ FIELD _ FOR _ DISTINCT , AllJavaTypes . INVALID _ LINKED _ TYPES _ FIELDS _ FOR _ DISTINCT ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - } 
 
 private RealmResults < Dog > populateRealmResultsOnLinkView ( Realm realm ) { 
 realm . beginTransaction ( ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 index b1d272d . . 4b61f79 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 @ @ - 338 , 33 + 338 , 4 @ @ public class RealmResults < E extends RealmModel > extends OrderedRealmCollectionIm 
 throw new UnsupportedOperationException ( realm . getClass ( ) + " does not support RxJava2 . " ) ; 
 } 
 } 
 - 
 - / * * 
 - * @ deprecated use { @ link RealmQuery # distinct ( String ) } on the return value of { @ link # where ( ) } instead . This will 
 - * be removed in coming 3 . x . x minor releases . 
 - * / 
 - @ Deprecated 
 - public RealmResults < E > distinct ( String fieldName ) { 
 - SortDescriptor distinctDescriptor = SortDescriptor . getInstanceForDistinct ( new SchemaConnector ( realm . getSchema ( ) ) , collection . getTable ( ) , fieldName ) ; 
 - Collection distinctCollection = collection . distinct ( distinctDescriptor ) ; 
 - return createLoadedResults ( distinctCollection ) ; 
 - } 
 - 
 - / * * 
 - * @ deprecated use { @ link RealmQuery # distinctAsync ( String ) } on the return value of { @ link # where ( ) } instead . This 
 - * will be removed in coming 3 . x . x minor releases . 
 - * / 
 - @ Deprecated 
 - public RealmResults < E > distinctAsync ( String fieldName ) { 
 - return where ( ) . distinctAsync ( fieldName ) ; 
 - } 
 - 
 - / * * 
 - * @ deprecated use { @ link RealmQuery # distinct ( String , String . . . ) } on the return value of { @ link # where ( ) } instead . 
 - * This will be removed in coming 3 . x . x minor releases . 
 - * / 
 - @ Deprecated 
 - public RealmResults < E > distinct ( String firstFieldName , String . . . remainingFieldNames ) { 
 - return where ( ) . distinct ( firstFieldName , remainingFieldNames ) ; 
 - } 
 }

NEAREST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index 9b16b9c . . e6cc8af 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 64 , 7 + 64 , 7 @ @ public class RealmAsyncQueryTests { 
 private Context context ; 
 
 @ Rule 
 - public final RunInLooperThread workerThread = new RunInLooperThread ( ) ; 
 + public final RunInLooperThread looperThread = new RunInLooperThread ( ) ; 
 
 @ Before 
 public void setUp ( ) throws Exception { 
 @ @ - 78 , 10 + 78 , 10 @ @ public class RealmAsyncQueryTests { 
 / / start asynchronously a transaction to insert one element 
 @ Test 
 @ RunTestInLooperThread 
 - public void testAsyncTransaction ( ) throws Throwable { 
 - assertEquals ( 0 , workerThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 + public void executeTransaction _ async ( ) throws Throwable { 
 + assertEquals ( 0 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 
 - workerThread . realm . executeTransaction ( new Realm . Transaction ( ) { 
 + looperThread . realm . executeTransaction ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 Owner owner = realm . createObject ( Owner . class ) ; 
 @ @ - 90 , 23 + 90 , 23 @ @ public class RealmAsyncQueryTests { 
 } , new Realm . Transaction . Callback ( ) { 
 @ Override 
 public void onSuccess ( ) { 
 - assertEquals ( 1 , workerThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 - assertEquals ( " Owner " , workerThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; 
 - workerThread . testComplete ( ) ; 
 + assertEquals ( 1 , looperThread . realm . allObjects ( Owner . class ) . size ( ) ) ; 
 + assertEquals ( " Owner " , looperThread . realm . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 
 @ Override 
 public void onError ( Exception e ) { 
 - workerThread . testComplete ( ) ; ; 
 + looperThread . testComplete ( ) ; ; 
 fail ( e . getMessage ( ) ) ; 
 } 
 } ) ; 
 } 
 
 + / / Test that an async transaction that throws an exception propagate it properly to the user . 
 @ Test 
 - public void testAsyncTransactionThatThrowsRuntimeException ( ) throws Throwable { 
 + public void executeTransaction _ async _ exceptionHandling ( ) throws Throwable { 
 final TestHelper . TestLogger testLogger = new TestHelper . TestLogger ( ) ; 
 - 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Realm [ ] realm = new Realm [ 1 ] ; 
 @ @ - 181 , 108 + 181 , 82 @ @ public class RealmAsyncQueryTests { 
 
 / / Test if the background Realm is closed when transaction success returned . 
 @ Test 
 - public void testClosedBeforeAsyncTransactionSuccess ( ) { 
 - final CountDownLatch signalTestFinished = new CountDownLatch ( 1 ) ; 
 - HandlerThread handlerThread = new HandlerThread ( " background " ) ; 
 - handlerThread . start ( ) ; 
 - final Handler handler = new Handler ( handlerThread . getLooper ( ) ) ; 
 - handler . post ( new Runnable ( ) { 
 + @ RunTestInLooperThread 
 + public void executeTransaction _ async _ realmClosedOnSuccess ( ) { 
 + final AtomicInteger counter = new AtomicInteger ( 100 ) ; 
 + final Realm realm = Realm . getInstance ( looperThread . createConfiguration ( " testClosedBeforeAsyncTransactionSuccess " ) ) ; 
 + final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { 
 @ Override 
 - public void run ( ) { 
 - final AtomicInteger counter = new AtomicInteger ( 100 ) ; 
 - final Realm realm = openRealmInstance ( " testClosedBeforeAsyncTransactionSuccess " ) ; 
 - final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { 
 - @ Override 
 - public void onResult ( int count ) { 
 - assertEquals ( 1 , count ) ; 
 - if ( counter . decrementAndGet ( ) = = 0 ) { 
 - realm . close ( ) ; 
 - signalTestFinished . countDown ( ) ; 
 - } 
 - } 
 - } ; 
 - final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { 
 - @ Override 
 - public void onSuccess ( ) { 
 - RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; 
 - if ( counter . get ( ) = = 0 ) { 
 - / / Finish testing 
 - return ; 
 - } 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 - @ Override 
 - public void execute ( Realm realm ) { 
 - } 
 - } , this ) ; 
 - } 
 - } ; 
 - 
 + public void onResult ( int count ) { 
 + assertEquals ( 1 , count ) ; 
 + if ( counter . decrementAndGet ( ) = = 0 ) { 
 + realm . close ( ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } 
 + } ; 
 + final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { 
 + @ Override 
 + public void onSuccess ( ) { 
 + RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; 
 + if ( counter . get ( ) = = 0 ) { 
 + / / Finish testing 
 + return ; 
 + } 
 realm . executeTransaction ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 } 
 - } , transactionCallback ) ; 
 + } , this ) ; 
 } 
 - } ) ; 
 - try { 
 - TestHelper . awaitOrFail ( signalTestFinished ) ; 
 - } finally { 
 - handlerThread . quit ( ) ; 
 - } 
 + } ; 
 + 
 + realm . executeTransaction ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + } 
 + } , transactionCallback ) ; 
 } 
 
 / / Test if the background Realm is closed when transaction error returned . 
 @ Test 
 - public void testClosedBeforeAsyncTransactionError ( ) { 
 - final CountDownLatch signalTestFinished = new CountDownLatch ( 1 ) ; 
 - HandlerThread handlerThread = new HandlerThread ( " background " ) ; 
 - handlerThread . start ( ) ; 
 - final Handler handler = new Handler ( handlerThread . getLooper ( ) ) ; 
 - handler . post ( new Runnable ( ) { 
 + @ RunTestInLooperThread 
 + public void executeTransaction _ async _ realmClosedOnError ( ) { 
 + final AtomicInteger counter = new AtomicInteger ( 100 ) ; 
 + final Realm realm = Realm . getInstance ( looperThread . createConfiguration ( " testClosedBeforeAsyncTransactionSuccess " ) ) ; 
 + final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { 
 @ Override 
 - public void run ( ) { 
 - final AtomicInteger counter = new AtomicInteger ( 100 ) ; 
 - final Realm realm = openRealmInstance ( " testClosedBeforeAsyncTransactionSuccess " ) ; 
 - final RealmCache . Callback cacheCallback = new RealmCache . Callback ( ) { 
 - @ Override 
 - public void onResult ( int count ) { 
 - assertEquals ( 1 , count ) ; 
 - if ( counter . decrementAndGet ( ) = = 0 ) { 
 - realm . close ( ) ; 
 - signalTestFinished . countDown ( ) ; 
 - } 
 - } 
 - } ; 
 - final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { 
 - @ Override 
 - public void onError ( Exception e ) { 
 - RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; 
 - if ( counter . get ( ) = = 0 ) { 
 - / / Finish testing 
 - return ; 
 - } 
 - realm . executeTransaction ( new Realm . Transaction ( ) { 
 - @ Override 
 - public void execute ( Realm realm ) { 
 - throw new RuntimeException ( " Dummy exception " ) ; 
 - } 
 - } , this ) ; 
 - } 
 - } ; 
 - 
 + public void onResult ( int count ) { 
 + assertEquals ( 1 , count ) ; 
 + if ( counter . decrementAndGet ( ) = = 0 ) { 
 + realm . close ( ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } 
 + } ; 
 + final Realm . Transaction . Callback transactionCallback = new Realm . Transaction . Callback ( ) { 
 + @ Override 
 + public void onError ( Exception e ) { 
 + RealmCache . invokeWithGlobalRefCount ( realm . getConfiguration ( ) , cacheCallback ) ; 
 + if ( counter . get ( ) = = 0 ) { 
 + / / Finish testing 
 + return ; 
 + } 
 realm . executeTransaction ( new Realm . Transaction ( ) { 
 @ Override 
 public void execute ( Realm realm ) { 
 throw new RuntimeException ( " Dummy exception " ) ; 
 } 
 - } , transactionCallback ) ; 
 + } , this ) ; 
 } 
 - } ) ; 
 - try { 
 - TestHelper . awaitOrFail ( signalTestFinished ) ; 
 - } finally { 
 - handlerThread . quit ( ) ; 
 - } 
 + } ; 
 + 
 + realm . executeTransaction ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + throw new RuntimeException ( " Dummy exception " ) ; 
 + } 
 + } , transactionCallback ) ; 
 } 
 
 / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 @ @ - 292 , 7 + 266 , 7 @ @ public class RealmAsyncQueryTests { 
 / / finding element [ 0 - 4 ] asynchronously then wait for the promise to be loaded . 
 / / no use of notification callback 
 @ Test 
 - public void testFindAllAsync ( ) throws Throwable { 
 + public void findAllAsync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 370 , 11 + 344 , 11 @ @ public class RealmAsyncQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void testAccessingRealmListOnUnloadedRealmObjectShouldThrow ( ) { 
 + public void accessingRealmListOnUnloadedRealmObjectShouldThrow ( ) { 
 Realm . asyncQueryExecutor . pause ( ) ; 
 
 - populateTestRealm ( workerThread . realm , 10 ) ; 
 - final AllTypes alltypes1 = workerThread . realm . where ( AllTypes . class ) 
 + populateTestRealm ( looperThread . realm , 10 ) ; 
 + final AllTypes alltypes1 = looperThread . realm . where ( AllTypes . class ) 
 . equalTo ( " columnLong " , 0 ) 
 . findFirstAsync ( ) ; 
 
 @ @ - 386 , 13 + 360 , 13 @ @ public class RealmAsyncQueryTests { 
 } 
 
 Realm . asyncQueryExecutor . resume ( ) ; 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 Looper . loop ( ) ; 
 
 } 
 
 @ Test 
 - public void testStandaloneObjectAsyncBehaviour ( ) { 
 + public void standaloneObjectAsyncBehaviour ( ) { 
 Dog dog = new Dog ( ) ; 
 dog . setName ( " Akamaru " ) ; 
 dog . setAge ( 10 ) ; 
 @ @ - 402 , 7 + 376 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 
 @ Test 
 - public void testAsyncQueryOnNonLooperThreadShouldThrow ( ) throws Throwable { 
 + public void findAllAsync _ throwsOnNonLooperThread ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 449 , 10 + 423 , 10 @ @ public class RealmAsyncQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void testReusingQuery ( ) throws Throwable { 
 - populateTestRealm ( workerThread . realm , 10 ) ; 
 + public void findAllAsync _ reusingQuery ( ) throws Throwable { 
 + populateTestRealm ( looperThread . realm , 10 ) ; 
 
 - RealmQuery < AllTypes > query = workerThread . realm . where ( AllTypes . class ) 
 + RealmQuery < AllTypes > query = looperThread . realm . where ( AllTypes . class ) 
 . between ( " columnLong " , 0 , 4 ) ; 
 RealmResults < AllTypes > queryAllSync = query . findAll ( ) ; 
 RealmResults < AllTypes > allAsync = query . findAllAsync ( ) ; 
 @ @ - 465 , 7 + 439 , 7 @ @ public class RealmAsyncQueryTests { 
 RealmResults < AllTypes > allAsyncSorted = query . findAllSorted ( " columnLong " ) ; 
 fail ( " Should throw an exception , can not reuse RealmQuery " ) ; 
 } catch ( IllegalStateException ignored ) { 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 } 
 
 @ @ - 473 , 11 + 447 , 11 @ @ public class RealmAsyncQueryTests { 
 / / using a callback to be notified when the data is loaded 
 @ Test 
 @ RunTestInLooperThread 
 - public void testFindAllAsyncWithNotification ( ) throws Throwable { 
 + public void findAllAsync _ withNotification ( ) throws Throwable { 
 Realm . asyncQueryExecutor . pause ( ) ; 
 
 - populateTestRealm ( workerThread . realm , 10 ) ; 
 - final RealmResults < AllTypes > realmResults = workerThread . realm . where ( AllTypes . class ) 
 + populateTestRealm ( looperThread . realm , 10 ) ; 
 + final RealmResults < AllTypes > realmResults = looperThread . realm . where ( AllTypes . class ) 
 . between ( " columnLong " , 0 , 4 ) 
 . findAllAsync ( ) ; 
 
 @ @ - 487 , 7 + 461 , 7 @ @ public class RealmAsyncQueryTests { 
 assertTrue ( realmResults . isLoaded ( ) ) ; 
 assertEquals ( 5 , realmResults . size ( ) ) ; 
 assertTrue ( realmResults . get ( 4 ) . isValid ( ) ) ; 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 } ) ; 
 
 @ @ - 495 , 18 + 469 , 18 @ @ public class RealmAsyncQueryTests { 
 assertEquals ( 0 , realmResults . size ( ) ) ; 
 
 Realm . asyncQueryExecutor . resume ( ) ; 
 - workerThread . keepStrongReference . add ( realmResults ) ; 
 + looperThread . keepStrongReference . add ( realmResults ) ; 
 } 
 
 / / transforming an async query into sync by calling load to force 
 / / the blocking behaviour 
 @ Test 
 @ RunTestInLooperThread 
 - public void testForceLoadAsync ( ) throws Throwable { 
 + public void findAllAsync _ forceLoad ( ) throws Throwable { 
 Realm . asyncQueryExecutor . pause ( ) ; 
 
 - populateTestRealm ( workerThread . realm , 10 ) ; 
 - final RealmResults < AllTypes > realmResults = workerThread . realm . where ( AllTypes . class ) 
 + populateTestRealm ( looperThread . realm , 10 ) ; 
 + final RealmResults < AllTypes > realmResults = looperThread . realm . where ( AllTypes . class ) 
 . between ( " columnLong " , 0 , 4 ) 
 . findAllAsync ( ) ; 
 
 @ @ - 516 , 7 + 490 , 7 @ @ public class RealmAsyncQueryTests { 
 public void onChange ( ) { 
 assertTrue ( realmResults . isLoaded ( ) ) ; 
 assertEquals ( 5 , realmResults . size ( ) ) ; 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 
 } 
 } ) ; 
 @ @ - 543 , 7 + 517 , 7 @ @ public class RealmAsyncQueryTests { 
 / / 8 - the notification should be called once ( when we retry automatically we shouldn ' t 
 / / notify the user ) . 
 @ Test 
 - public void testFindAllAsyncRetry ( ) throws Throwable { 
 + public void findAllAsync _ retry ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 642 , 7 + 616 , 7 @ @ public class RealmAsyncQueryTests { 
 / / 6 - now REALM _ CHANGED will trigger a COMPLETED _ UPDATE _ ASYNC _ QUERIES that should update all queries 
 / / 7 - callbacks are notified with the latest results ( called twice overall ) 
 @ Test 
 - public void testFindAllAsyncBatchUpdate ( ) throws Throwable { 
 + public void findAllAsync _ batchUpdate ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 804 , 7 + 778 , 7 @ @ public class RealmAsyncQueryTests { 
 / / is operating on a previous version , this should retry the query on the worker thread 
 / / to deliver the results once ( using the latest version of the Realm ) 
 @ Test 
 - public void testFindAllCallerIsAdvanced ( ) throws Throwable { 
 + public void findAllAsync _ callerIsAdvanced ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch callbackInvokedFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 @ @ - 958 , 7 + 932 , 7 @ @ public class RealmAsyncQueryTests { 
 / / update ( using the latest realm ) for all async queries is in progress 
 / / 7 - onChange notification will be triggered once 
 @ Test 
 - public void testFindAllCallerThreadBehind ( ) throws Throwable { 
 + public void findAllAsync _ callerThreadBehind ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 1095 , 7 + 1069 , 7 @ @ public class RealmAsyncQueryTests { 
 
 / / similar UC as # testFindAllAsync using ' findFirst ' 
 @ Test 
 - public void testFindFirstAsync ( ) throws Throwable { 
 + public void findFirstAsync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 1162 , 8 + 1136 , 8 @ @ public class RealmAsyncQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void testFindFirstAsyncWithInitialEmptyRow ( ) throws Throwable { 
 - final AllTypes firstAsync = workerThread . realm . where ( AllTypes . class ) . findFirstAsync ( ) ; 
 + public void findFirstAsync _ initalEmptyRow ( ) throws Throwable { 
 + final AllTypes firstAsync = looperThread . realm . where ( AllTypes . class ) . findFirstAsync ( ) ; 
 firstAsync . addChangeListener ( new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 @ @ - 1171 , 26 + 1145 , 26 @ @ public class RealmAsyncQueryTests { 
 assertTrue ( firstAsync . isLoaded ( ) ) ; 
 assertTrue ( firstAsync . isValid ( ) ) ; 
 assertEquals ( 0 , firstAsync . getColumnLong ( ) ) ; 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 } ) ; 
 assertTrue ( firstAsync . load ( ) ) ; 
 assertTrue ( firstAsync . isLoaded ( ) ) ; 
 assertFalse ( firstAsync . isValid ( ) ) ; 
 
 - populateTestRealm ( workerThread . realm , 10 ) ; 
 - workerThread . keepStrongReference . add ( firstAsync ) ; 
 + populateTestRealm ( looperThread . realm , 10 ) ; 
 + looperThread . keepStrongReference . add ( firstAsync ) ; 
 } 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void testFindFirstAsyncUpdatedIfSyncRealmObjectIsUpdated ( ) throws Throwable { 
 - populateTestRealm ( workerThread . realm , 1 ) ; 
 - AllTypes firstSync = workerThread . realm . where ( AllTypes . class ) . findFirst ( ) ; 
 + public void findFirstAsync _ updatedIfsyncRealmObjectIsUpdated ( ) throws Throwable { 
 + populateTestRealm ( looperThread . realm , 1 ) ; 
 + AllTypes firstSync = looperThread . realm . where ( AllTypes . class ) . findFirst ( ) ; 
 assertEquals ( 0 , firstSync . getColumnLong ( ) ) ; 
 assertEquals ( " test data 0 " , firstSync . getColumnString ( ) ) ; 
 
 - final AllTypes firstAsync = workerThread . realm . where ( AllTypes . class ) . findFirstAsync ( ) ; 
 + final AllTypes firstAsync = looperThread . realm . where ( AllTypes . class ) . findFirstAsync ( ) ; 
 assertTrue ( firstAsync . load ( ) ) ; 
 assertTrue ( firstAsync . isLoaded ( ) ) ; 
 assertTrue ( firstAsync . isValid ( ) ) ; 
 @ @ - 1201 , 24 + 1175 , 24 @ @ public class RealmAsyncQueryTests { 
 @ Override 
 public void onChange ( ) { 
 assertEquals ( " Galacticon " , firstAsync . getColumnString ( ) ) ; 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 } ) ; 
 
 - workerThread . realm . beginTransaction ( ) ; 
 + looperThread . realm . beginTransaction ( ) ; 
 firstSync . setColumnString ( " Galacticon " ) ; 
 - workerThread . realm . commitTransaction ( ) ; 
 + looperThread . realm . commitTransaction ( ) ; 
 } 
 
 / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded 
 / / using a callback to be notified when the data is loaded 
 @ Test 
 @ RunTestInLooperThread 
 - public void testFindFirstAsyncWithNotification ( ) throws Throwable { 
 + public void findFirstAsync _ withNotification ( ) throws Throwable { 
 Realm . asyncQueryExecutor . pause ( ) ; 
 
 - populateTestRealm ( workerThread . realm , 10 ) ; 
 - final AllTypes realmResults = workerThread . realm . where ( AllTypes . class ) 
 + populateTestRealm ( looperThread . realm , 10 ) ; 
 + final AllTypes realmResults = looperThread . realm . where ( AllTypes . class ) 
 . between ( " columnLong " , 4 , 9 ) 
 . findFirstAsync ( ) ; 
 
 @ @ - 1228 , 7 + 1202 , 7 @ @ public class RealmAsyncQueryTests { 
 assertTrue ( realmResults . isLoaded ( ) ) ; 
 assertTrue ( realmResults . isValid ( ) ) ; 
 assertEquals ( " test data 4 " , realmResults . getColumnString ( ) ) ; 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 } ) ; 
 
 @ @ - 1241 , 17 + 1215 , 17 @ @ public class RealmAsyncQueryTests { 
 } 
 
 Realm . asyncQueryExecutor . resume ( ) ; 
 - workerThread . keepStrongReference . add ( realmResults ) ; 
 + looperThread . keepStrongReference . add ( realmResults ) ; 
 } 
 
 / / similar UC as # testForceLoadAsync using ' findFirst ' 
 @ Test 
 @ RunTestInLooperThread 
 - public void testForceLoadFindFirstAsync ( ) throws Throwable { 
 + public void findFirstAsync _ forceLoad ( ) throws Throwable { 
 Realm . asyncQueryExecutor . pause ( ) ; 
 
 - populateTestRealm ( workerThread . realm , 10 ) ; 
 - final AllTypes realmResults = workerThread . realm . where ( AllTypes . class ) 
 + populateTestRealm ( looperThread . realm , 10 ) ; 
 + final AllTypes realmResults = looperThread . realm . where ( AllTypes . class ) 
 . between ( " columnLong " , 4 , 9 ) 
 . findFirstAsync ( ) ; 
 
 @ @ - 1263 , 12 + 1237 , 12 @ @ public class RealmAsyncQueryTests { 
 assertTrue ( realmResults . isLoaded ( ) ) ; 
 assertEquals ( " test data 4 " , realmResults . getColumnString ( ) ) ; 
 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 
 / / similar UC as # testFindAllAsyncRetry using ' findFirst ' 
 @ Test 
 - public void testFindFirstAsyncRetry ( ) throws Throwable { 
 + public void findFirstAsync _ retry ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 1370 , 7 + 1344 , 7 @ @ public class RealmAsyncQueryTests { 
 
 / / similar UC as # testFindAllAsync using ' findAllSorted ' 
 @ Test 
 - public void testFindAllSortedAsync ( ) throws Throwable { 
 + public void findAllSortedAsync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 1453 , 7 + 1427 , 7 @ @ public class RealmAsyncQueryTests { 
 / / finding elements [ 4 - 8 ] asynchronously then wait for the promise to be loaded 
 / / using a callback to be notified when the data is loaded 
 @ Test 
 - public void testFindAllSortedAsyncRetry ( ) throws Throwable { 
 + public void findAllSortedAsync _ retry ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 1545 , 7 + 1519 , 7 @ @ public class RealmAsyncQueryTests { 
 
 / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSorted ' 
 @ Test 
 - public void testFindAllSortedAsyncBatchUpdate ( ) throws Throwable { 
 + public void findAllSortedAsync _ batchUpdate ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 1706 , 7 + 1680 , 7 @ @ public class RealmAsyncQueryTests { 
 
 / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSortedMulti ' 
 @ Test 
 - public void testFindAllSortedMultiAsyncBatchUpdate ( ) throws Throwable { 
 + public void findAllSortedAsync _ multipleFields _ batchUpdate ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 1947 , 8 + 1921 , 8 @ @ public class RealmAsyncQueryTests { 
 / / if unregistered properly . 
 @ Test 
 @ RunTestInLooperThread 
 - public void testListenerShouldNotLeak ( ) { 
 - populateTestRealm ( workerThread . realm , 10 ) ; 
 + public void listenerShouldNotLeak ( ) { 
 + populateTestRealm ( looperThread . realm , 10 ) ; 
 
 / / simulate the ActivityManager by creating 1 instance responsible 
 / / of attaching an onChange listener , then simulate a configuration 
 @ @ - 1956 , 14 + 1930 , 14 @ @ public class RealmAsyncQueryTests { 
 / / we make sure that the GC enqueue the reference of the destroyed instance 
 / / which indicate no memory leak 
 MockActivityManager mockActivityManager = 
 - MockActivityManager . newInstance ( workerThread . realm . getConfiguration ( ) ) ; 
 + MockActivityManager . newInstance ( looperThread . realm . getConfiguration ( ) ) ; 
 
 mockActivityManager . sendConfigurationChange ( ) ; 
 
 assertEquals ( 1 , mockActivityManager . numberOfInstances ( ) ) ; 
 / / remove GC ' d reference & assert that one instance should remain 
 Iterator < Map . Entry < WeakReference < RealmResults < ? > > , RealmQuery < ? > > > iterator = 
 - workerThread . realm . handlerController . asyncRealmResults . entrySet ( ) . iterator ( ) ; 
 + looperThread . realm . handlerController . asyncRealmResults . entrySet ( ) . iterator ( ) ; 
 while ( iterator . hasNext ( ) ) { 
 Map . Entry < WeakReference < RealmResults < ? > > , RealmQuery < ? > > entry = iterator . next ( ) ; 
 RealmResults < ? > weakReference = entry . getKey ( ) . get ( ) ; 
 @ @ - 1972 , 18 + 1946 , 18 @ @ public class RealmAsyncQueryTests { 
 } 
 } 
 
 - assertEquals ( 1 , workerThread . realm . handlerController . asyncRealmResults . size ( ) ) ; 
 + assertEquals ( 1 , looperThread . realm . handlerController . asyncRealmResults . size ( ) ) ; 
 mockActivityManager . onStop ( ) ; / / to close the Realm 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void testCombiningAsyncAndSync ( ) { 
 - populateTestRealm ( workerThread . realm , 10 ) ; 
 + public void combiningAsyncAndSync ( ) { 
 + populateTestRealm ( looperThread . realm , 10 ) ; 
 
 Realm . asyncQueryExecutor . pause ( ) ; 
 - final RealmResults < AllTypes > allTypesAsync = workerThread . realm . where ( AllTypes . class ) . greaterThan ( " columnLong " , 5 ) . findAllAsync ( ) ; 
 + final RealmResults < AllTypes > allTypesAsync = looperThread . realm . where ( AllTypes . class ) . greaterThan ( " columnLong " , 5 ) . findAllAsync ( ) ; 
 final RealmResults < AllTypes > allTypesSync = allTypesAsync . where ( ) . greaterThan ( " columnLong " , 3 ) . findAll ( ) ; 
 
 assertEquals ( 0 , allTypesAsync . size ( ) ) ; 
 @ @ - 1993 , 18 + 1967 , 18 @ @ public class RealmAsyncQueryTests { 
 public void onChange ( ) { 
 assertEquals ( 4 , allTypesAsync . size ( ) ) ; 
 assertEquals ( 6 , allTypesSync . size ( ) ) ; 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 } ) ; 
 Realm . asyncQueryExecutor . resume ( ) ; 
 - workerThread . keepStrongReference . add ( allTypesAsync ) ; 
 + looperThread . keepStrongReference . add ( allTypesAsync ) ; 
 } 
 
 / / keep advancing the Realm by sending 1 commit for each frame ( 16ms ) 
 / / the async queries should keep up with the modification 
 @ Test 
 @ RunTestInLooperThread 
 - public void testStressTestBackgroundCommits ( ) throws Throwable { 
 + public void stressTestBackgroundCommits ( ) throws Throwable { 
 final int NUMBER _ OF _ COMMITS = 100 ; 
 final CountDownLatch bgRealmClosed = new CountDownLatch ( 1 ) ; 
 final long [ ] latestLongValue = new long [ 1 ] ; 
 @ @ - 2014 , 7 + 1988 , 7 @ @ public class RealmAsyncQueryTests { 
 @ Override 
 public void run ( ) { 
 Random random = new Random ( System . currentTimeMillis ( ) ) ; 
 - Realm backgroundThreadRealm = Realm . getInstance ( workerThread . realm . getConfiguration ( ) ) ; 
 + Realm backgroundThreadRealm = Realm . getInstance ( looperThread . realm . getConfiguration ( ) ) ; 
 for ( int i = 0 ; i < NUMBER _ OF _ COMMITS ; i + + ) { 
 backgroundThreadRealm . beginTransaction ( ) ; 
 AllTypes object = backgroundThreadRealm . createObject ( AllTypes . class ) ; 
 @ @ - 2032 , 25 + 2006 , 25 @ @ public class RealmAsyncQueryTests { 
 } 
 } ; 
 
 - final RealmResults < AllTypes > allAsync = workerThread . realm . where ( AllTypes . class ) . findAllAsync ( ) ; 
 + final RealmResults < AllTypes > allAsync = looperThread . realm . where ( AllTypes . class ) . findAllAsync ( ) ; 
 allAsync . addChangeListener ( new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 assertTrue ( allAsync . isLoaded ( ) ) ; 
 if ( allAsync . size ( ) = = NUMBER _ OF _ COMMITS ) { 
 - AllTypes lastInserted = workerThread . realm . where ( AllTypes . class ) 
 + AllTypes lastInserted = looperThread . realm . where ( AllTypes . class ) 
 . equalTo ( " columnLong " , latestLongValue [ 0 ] ) 
 . equalTo ( " columnFloat " , latestFloatValue [ 0 ] ) 
 . findFirst ( ) ; 
 assertNotNull ( lastInserted ) ; 
 TestHelper . awaitOrFail ( bgRealmClosed ) ; 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 } 
 } ) ; 
 - workerThread . keepStrongReference . add ( allAsync ) ; 
 + looperThread . keepStrongReference . add ( allAsync ) ; 
 
 - workerThread . realm . handler . postDelayed ( new Runnable ( ) { 
 + looperThread . realm . handler . postDelayed ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 backgroundThread . start ( ) ; 
 @ @ - 2059 , 7 + 2033 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 
 @ Test 
 - public void testAsyncDistinct ( ) throws Throwable { 
 + public void distinctAsync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 4 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 2156 , 7 + 2130 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 
 @ Test 
 - public void testAsyncDistinctNotIndexedFields ( ) throws Throwable { 
 + public void distinctAsync _ notIndexedFields ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 4 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 @ @ - 2207 , 47 + 2181 , 47 @ @ public class RealmAsyncQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void testAsyncDistinctFieldDoesNotExist ( ) throws Throwable { 
 + public void distinctAsync _ noneExistingField ( ) throws Throwable { 
 final long numberOfBlocks = 25 ; 
 final long numberOfObjects = 10 ; / / must be greater than 1 
 - populateForDistinct ( workerThread . realm , numberOfBlocks , numberOfObjects , false ) ; 
 + populateForDistinct ( looperThread . realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 try { 
 - workerThread . realm . distinctAsync ( AnnotationIndexTypes . class , " doesNotExist " ) ; 
 + looperThread . realm . distinctAsync ( AnnotationIndexTypes . class , " doesNotExist " ) ; 
 fail ( ) ; 
 } catch ( IllegalArgumentException ignored ) { 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 } 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void testBatchUpdateDifferentTypeOfQueries ( ) { 
 - workerThread . realm . beginTransaction ( ) ; 
 + public void batchUpdateDifferentTypeOfQueries ( ) { 
 + looperThread . realm . beginTransaction ( ) ; 
 for ( int i = 0 ; i < 5 ; ) { 
 - AllTypes allTypes = workerThread . realm . createObject ( AllTypes . class ) ; 
 + AllTypes allTypes = looperThread . realm . createObject ( AllTypes . class ) ; 
 allTypes . setColumnLong ( i ) ; 
 allTypes . setColumnString ( " data " + i % 3 ) ; 
 
 - allTypes = workerThread . realm . createObject ( AllTypes . class ) ; 
 + allTypes = looperThread . realm . createObject ( AllTypes . class ) ; 
 allTypes . setColumnLong ( i ) ; 
 allTypes . setColumnString ( " data " + ( + + i % 3 ) ) ; 
 } 
 final long numberOfBlocks = 25 ; 
 final long numberOfObjects = 10 ; / / must be greater than 1 
 - workerThread . realm . commitTransaction ( ) ; 
 - populateForDistinct ( workerThread . realm , numberOfBlocks , numberOfObjects , false ) ; 
 + looperThread . realm . commitTransaction ( ) ; 
 + populateForDistinct ( looperThread . realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 - RealmResults < AllTypes > findAllAsync = workerThread . realm . where ( AllTypes . class ) . findAllAsync ( ) ; 
 - RealmResults < AllTypes > findAllSorted = workerThread . realm . where ( AllTypes . class ) . findAllSortedAsync ( " columnString " , Sort . ASCENDING ) ; 
 - RealmResults < AllTypes > findAllSortedMulti = workerThread . realm . where ( AllTypes . class ) . findAllSortedAsync ( new String [ ] { " columnString " , " columnLong " } , 
 + RealmResults < AllTypes > findAllAsync = looperThread . realm . where ( AllTypes . class ) . findAllAsync ( ) ; 
 + RealmResults < AllTypes > findAllSorted = looperThread . realm . where ( AllTypes . class ) . findAllSortedAsync ( " columnString " , Sort . ASCENDING ) ; 
 + RealmResults < AllTypes > findAllSortedMulti = looperThread . realm . where ( AllTypes . class ) . findAllSortedAsync ( new String [ ] { " columnString " , " columnLong " } , 
 new Sort [ ] { Sort . ASCENDING , Sort . DESCENDING } ) ; 
 - RealmResults < AnnotationIndexTypes > findDistinct = workerThread . realm . distinctAsync ( AnnotationIndexTypes . class , " indexString " ) ; 
 + RealmResults < AnnotationIndexTypes > findDistinct = looperThread . realm . distinctAsync ( AnnotationIndexTypes . class , " indexString " ) ; 
 
 - workerThread . keepStrongReference . add ( findAllAsync ) ; 
 - workerThread . keepStrongReference . add ( findAllSorted ) ; 
 - workerThread . keepStrongReference . add ( findAllSortedMulti ) ; 
 - workerThread . keepStrongReference . add ( findDistinct ) ; 
 + looperThread . keepStrongReference . add ( findAllAsync ) ; 
 + looperThread . keepStrongReference . add ( findAllSorted ) ; 
 + looperThread . keepStrongReference . add ( findAllSortedMulti ) ; 
 + looperThread . keepStrongReference . add ( findDistinct ) ; 
 
 final CountDownLatch queriesCompleted = new CountDownLatch ( 4 ) ; 
 final AtomicInteger batchUpdateCompleted = new AtomicInteger ( 0 ) ; 
 @ @ - 2266 , 7 + 2240 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 case 2 : { 
 if ( batchUpdateCompleted . incrementAndGet ( ) = = 4 ) { 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 break ; 
 } 
 @ @ - 2284 , 7 + 2258 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 case 2 : { 
 if ( batchUpdateCompleted . incrementAndGet ( ) = = 4 ) { 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 break ; 
 } 
 @ @ - 2302 , 7 + 2276 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 case 2 : { 
 if ( batchUpdateCompleted . incrementAndGet ( ) = = 4 ) { 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 break ; 
 } 
 @ @ - 2320 , 7 + 2294 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 case 2 : { 
 if ( batchUpdateCompleted . incrementAndGet ( ) = = 4 ) { 
 - workerThread . testComplete ( ) ; 
 + looperThread . testComplete ( ) ; 
 } 
 break ; 
 } 
 @ @ - 2335 , 7 + 2309 , 7 @ @ public class RealmAsyncQueryTests { 
 public void run ( ) { 
 try { 
 queriesCompleted . await ( ) ; 
 - Realm bgRealm = Realm . getInstance ( workerThread . realm . getConfiguration ( ) ) ; 
 + Realm bgRealm = Realm . getInstance ( looperThread . realm . getConfiguration ( ) ) ; 
 
 bgRealm . beginTransaction ( ) ; 
 bgRealm . createObject ( AllTypes . class ) ; 
 @ @ - 2351 , 7 + 2325 , 7 @ @ public class RealmAsyncQueryTests { 
 } 
 
 / / this test make sure that Async queries update when using link 
 - public void testQueryingLinkHandover ( ) throws Throwable { 
 + public void queryingLinkHandover ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final AtomicInteger numberOfInvocations = new AtomicInteger ( 0 ) ;
