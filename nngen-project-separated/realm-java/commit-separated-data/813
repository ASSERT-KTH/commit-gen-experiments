BLEU SCORE: 0.07545383788761362

TEST MSG: Fix more unit tests
GENERATED MSG: Convert migration and cache tests to JUNIT4

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java <nl> index ebbc63e . . f0d7f4a 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java <nl> @ @ - 25 , 6 + 25 , 8 @ @ import org . junit . Test ; <nl> import org . junit . rules . ExpectedException ; <nl> import org . junit . runner . RunWith ; <nl> <nl> + import org . junit . Test ; <nl> + <nl> import java . text . ParseException ; <nl> import java . util . Arrays ; <nl> import java . util . Date ; <nl> @ @ - 475 , 9 + 477 , 20 @ @ public class DynamicRealmObjectTests { <nl> / / List is not a simple getter , test separately . <nl> @ Test <nl> public void getList ( ) { <nl> - RealmList < DynamicRealmObject > list = dObj . getList ( AllJavaTypes . FIELD _ LIST ) ; <nl> + realm . beginTransaction ( ) ; <nl> + AllTypes obj = realm . createObject ( AllTypes . class ) ; <nl> + Dog dog = realm . createObject ( Dog . class ) ; <nl> + dog . setName ( " fido " ) ; <nl> + obj . getColumnRealmList ( ) . add ( dog ) ; <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + DynamicRealmObject dynamicAllTypes = new DynamicRealmObject ( obj ) ; <nl> + RealmList < DynamicRealmObject > list = dynamicAllTypes . getList ( AllTypes . FIELD _ REALMLIST ) ; <nl> + DynamicRealmObject listObject = list . get ( 0 ) ; <nl> + <nl> assertEquals ( 1 , list . size ( ) ) ; <nl> - assertEquals ( dObj , list . get ( 0 ) ) ; <nl> + assertEquals ( Dog . CLASS _ NAME , listObject . getType ( ) ) ; <nl> + assertEquals ( " fido " , listObject . getString ( Dog . FIELD _ NAME ) ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 748 , 4 + 761 , 19 @ @ public class DynamicRealmObjectTests { <nl> assertTrue ( str . startsWith ( " class _ AllJavaTypes = [ " ) ) ; <nl> assertTrue ( str . endsWith ( " } ] " ) ) ; <nl> } <nl> + <nl> + public void testExceptionMessage ( ) { <nl> + / / test for https : / / github . com / realm / realm - java / issues / 2141 <nl> + realm . beginTransaction ( ) ; <nl> + AllTypes obj = realm . createObject ( AllTypes . class ) ; <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + DynamicRealmObject o = new DynamicRealmObject ( obj ) ; <nl> + try { <nl> + o . getFloat ( " nonExisting " ) ; / / Note that " o " does not have " nonExisting " field . <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException e ) { <nl> + assertEquals ( " Illegal Argument : Field not found : nonExisting " , e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / NotificationsTest . java b / realm / realm - library / src / androidTest / java / io / realm / NotificationsTest . java <nl> index 8290024 . . 313ceae 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / NotificationsTest . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / NotificationsTest . java <nl> @ @ - 16 , 11 + 16 , 9 @ @ <nl> <nl> package io . realm ; <nl> <nl> - import android . content . Context ; <nl> import android . os . Handler ; <nl> import android . os . HandlerThread ; <nl> import android . os . Looper ; <nl> - import android . support . test . InstrumentationRegistry ; <nl> import android . support . test . annotation . UiThreadTest ; <nl> import android . support . test . rule . UiThreadTestRule ; <nl> import android . support . test . runner . AndroidJUnit4 ; <nl> @ @ - 52 , 6 + 50 , 7 @ @ import io . realm . entities . AllTypes ; <nl> import io . realm . entities . Dog ; <nl> import io . realm . internal . log . Logger ; <nl> import io . realm . internal . log . RealmLog ; <nl> + import io . realm . rule . TestRealmConfigurationFactory ; <nl> <nl> import static org . junit . Assert . assertEquals ; <nl> import static org . junit . Assert . assertFalse ; <nl> @ @ - 63 , 34 + 62 , 33 @ @ import static org . junit . Assert . fail ; <nl> @ RunWith ( AndroidJUnit4 . class ) <nl> public class NotificationsTest { <nl> <nl> - private Realm realm ; <nl> @ Rule <nl> public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule ( ) ; <nl> - private Context context ; <nl> + @ Rule <nl> + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; <nl> <nl> - @ Before <nl> - public void setUp ( ) throws Exception { <nl> - / / Injecting the Instrumentation instance is required <nl> - / / for your test to run with AndroidJUnitRunner . <nl> - context = InstrumentationRegistry . getInstrumentation ( ) . getContext ( ) ; <nl> + private Realm realm ; <nl> + private RealmConfiguration realmConfig ; <nl> <nl> - Realm . deleteRealm ( TestHelper . createConfiguration ( context ) ) ; <nl> + @ Before <nl> + public void setUp ( ) { <nl> + realmConfig = configFactory . createConfiguration ( ) ; <nl> } <nl> <nl> @ After <nl> - public void tearDown ( ) throws Exception { <nl> + public void tearDown ( ) { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> } <nl> <nl> @ Test <nl> - public void testFailingSetAutoRefreshOnNonLooperThread ( ) throws ExecutionException , InterruptedException { <nl> + public void failingSetAutoRefreshOnNonLooperThread ( ) throws ExecutionException , InterruptedException { <nl> ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> @ Override <nl> public Boolean call ( ) throws Exception { <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> boolean autoRefresh = realm . isAutoRefresh ( ) ; <nl> assertFalse ( autoRefresh ) ; <nl> try { <nl> @ @ - 105 , 18 + 103 , 17 @ @ public class NotificationsTest { <nl> } ) ; <nl> <nl> assertTrue ( future . get ( ) ) ; <nl> - RealmCache . invokeWithGlobalRefCount ( new RealmConfiguration . Builder ( context ) . build ( ) , <nl> - new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> + RealmCache . invokeWithGlobalRefCount ( realmConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> } <nl> <nl> @ Test <nl> - public void testSetAutoRefreshOnHandlerThread ( ) throws ExecutionException , InterruptedException { <nl> + public void setAutoRefresh _ onHandlerThread ( ) throws ExecutionException , InterruptedException { <nl> ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> @ Override <nl> public Boolean call ( ) throws Exception { <nl> Looper . prepare ( ) ; <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> assertTrue ( realm . isAutoRefresh ( ) ) ; <nl> realm . setAutoRefresh ( false ) ; <nl> assertFalse ( realm . isAutoRefresh ( ) ) ; <nl> @ @ - 126 , 14 + 123 , 14 @ @ public class NotificationsTest { <nl> return true ; <nl> } <nl> } ) ; <nl> + <nl> assertTrue ( future . get ( ) ) ; <nl> - RealmCache . invokeWithGlobalRefCount ( new RealmConfiguration . Builder ( context ) . build ( ) , <nl> - new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> + RealmCache . invokeWithGlobalRefCount ( realmConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> } <nl> <nl> @ Test <nl> @ UiThreadTest <nl> - public void testRemoveNotifications ( ) throws InterruptedException , ExecutionException { <nl> + public void removeChangeListener ( ) throws InterruptedException , ExecutionException { <nl> final AtomicInteger counter = new AtomicInteger ( 0 ) ; <nl> RealmChangeListener listener = new RealmChangeListener ( ) { <nl> @ Override <nl> @ @ - 142 , 7 + 139 , 7 @ @ public class NotificationsTest { <nl> } <nl> } ; <nl> <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> realm . addChangeListener ( listener ) ; <nl> realm . removeChangeListener ( listener ) ; <nl> <nl> @ @ - 155 , 7 + 152 , 7 @ @ public class NotificationsTest { <nl> <nl> @ Test <nl> @ UiThreadTest <nl> - public void testAddDuplicatedListener ( ) { <nl> + public void addChangeListener _ duplicatedListener ( ) { <nl> final AtomicInteger counter = new AtomicInteger ( 0 ) ; <nl> RealmChangeListener listener = new RealmChangeListener ( ) { <nl> @ Override <nl> @ @ - 164 , 7 + 161 , 7 @ @ public class NotificationsTest { <nl> } <nl> } ; <nl> <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> realm . addChangeListener ( listener ) ; <nl> realm . addChangeListener ( listener ) ; <nl> <nl> @ @ - 176 , 7 + 173 , 7 @ @ public class NotificationsTest { <nl> } <nl> <nl> @ Test <nl> - public void testNotificationsNumber ( ) throws InterruptedException , ExecutionException { <nl> + public void notificationsNumber ( ) throws InterruptedException , ExecutionException { <nl> final AtomicInteger counter = new AtomicInteger ( 0 ) ; <nl> final AtomicBoolean isReady = new AtomicBoolean ( false ) ; <nl> final Looper [ ] looper = new Looper [ 1 ] ; <nl> @ @ - 196 , 7 + 193 , 7 @ @ public class NotificationsTest { <nl> try { <nl> Looper . prepare ( ) ; <nl> looper [ 0 ] = Looper . myLooper ( ) ; <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> realm . addChangeListener ( listener ) ; <nl> isReady . set ( true ) ; <nl> Looper . loop ( ) ; <nl> @ @ - 217 , 7 + 214 , 7 @ @ public class NotificationsTest { <nl> Thread . sleep ( 100 ) ; <nl> <nl> / / Trigger OnRealmChanged on background thread <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> realm . beginTransaction ( ) ; <nl> Dog dog = realm . createObject ( Dog . class ) ; <nl> dog . setName ( " Rex " ) ; <nl> @ @ - 237 , 12 + 234 , 11 @ @ public class NotificationsTest { <nl> } <nl> <nl> assertEquals ( 1 , counter . get ( ) ) ; <nl> - RealmCache . invokeWithGlobalRefCount ( new RealmConfiguration . Builder ( context ) . build ( ) , <nl> - new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> + RealmCache . invokeWithGlobalRefCount ( realmConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> } <nl> <nl> @ Test <nl> - public void testAutoUpdateRealmResults ( ) throws InterruptedException , ExecutionException { <nl> + public void autoUpdateRealmResults ( ) throws InterruptedException , ExecutionException { <nl> final int TEST _ SIZE = 10 ; <nl> final AtomicInteger counter = new AtomicInteger ( 0 ) ; <nl> final AtomicBoolean isReady = new AtomicBoolean ( false ) ; <nl> @ @ - 260 , 7 + 256 , 7 @ @ public class NotificationsTest { <nl> looper [ 0 ] = Looper . myLooper ( ) ; <nl> Realm realm = null ; <nl> try { <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> final RealmResults < Dog > dogs = realm . allObjects ( Dog . class ) ; <nl> assertEquals ( 0 , dogs . size ( ) ) ; <nl> listener [ 0 ] = new RealmChangeListener ( ) { <nl> @ @ - 289 , 7 + 285 , 7 @ @ public class NotificationsTest { <nl> } <nl> Thread . sleep ( 100 ) ; <nl> <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> realm . beginTransaction ( ) ; <nl> for ( int i = 0 ; i < TEST _ SIZE ; i + + ) { <nl> Dog dog = realm . createObject ( Dog . class ) ; <nl> @ @ - 317 , 12 + 313 , 11 @ @ public class NotificationsTest { <nl> assertEquals ( TEST _ SIZE , results . get ( 1 ) . intValue ( ) ) ; <nl> <nl> assertEquals ( 1 , counter . get ( ) ) ; <nl> - RealmCache . invokeWithGlobalRefCount ( new RealmConfiguration . Builder ( context ) . build ( ) , <nl> - new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> + RealmCache . invokeWithGlobalRefCount ( realmConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> } <nl> <nl> - / / TODO Disabled until we can figure out why this times out so often on the build server <nl> - public void DISABLEDtestCloseClearingHandlerMessages ( ) throws InterruptedException , TimeoutException , ExecutionException { <nl> + @ Test <nl> + public void closeClearingHandlerMessages ( ) throws InterruptedException , TimeoutException , ExecutionException { <nl> final int TEST _ SIZE = 10 ; <nl> final CountDownLatch backgroundLooperStarted = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch addHandlerMessages = new CountDownLatch ( 1 ) ; <nl> @ @ - 332 , 7 + 327 , 7 @ @ public class NotificationsTest { <nl> @ Override <nl> public Boolean call ( ) throws Exception { <nl> Looper . prepare ( ) ; / / Fake background thread with a looper , eg . a IntentService <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> backgroundLooperStarted . countDown ( ) ; <nl> <nl> / / Random operation in the client code <nl> @ @ - 355 , 7 + 350 , 7 @ @ public class NotificationsTest { <nl> threadHandler . post ( new Runnable ( ) { <nl> @ Override <nl> public void run ( ) { <nl> - Looper . myLooper ( ) . quit ( ) ; <nl> + TestHelper . quitLooperOrFail ( ) ; <nl> } <nl> } ) ; <nl> <nl> @ @ - 372 , 7 + 367 , 7 @ @ public class NotificationsTest { <nl> backgroundLooperStarted . await ( 1 , TimeUnit . SECONDS ) ; <nl> <nl> / / Execute a transaction that will trigger a Realm update <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> realm . beginTransaction ( ) ; <nl> for ( int i = 0 ; i < TEST _ SIZE ; i + + ) { <nl> Dog dog = realm . createObject ( Dog . class ) ; <nl> @ @ - 392 , 8 + 387 , 8 @ @ public class NotificationsTest { <nl> <nl> @ Test <nl> @ UiThreadTest <nl> - public void testHandlerNotRemovedToSoon ( ) { <nl> - RealmConfiguration realmConfig = TestHelper . createConfiguration ( context , " private - realm " ) ; <nl> + public void handlerNotRemovedToSoon ( ) { <nl> + RealmConfiguration realmConfig = configFactory . createConfiguration ( " private - realm " ) ; <nl> Realm . deleteRealm ( realmConfig ) ; <nl> Realm instance1 = Realm . getInstance ( realmConfig ) ; <nl> Realm instance2 = Realm . getInstance ( realmConfig ) ; <nl> @ @ - 410 , 10 + 405 , 10 @ @ public class NotificationsTest { <nl> <nl> @ Test <nl> @ UiThreadTest <nl> - public void testImmediateNotificationsOnSameThread ( ) { <nl> + public void immediateNotificationsOnSameThread ( ) { <nl> final AtomicBoolean success = new AtomicBoolean ( false ) ; <nl> final RealmChangeListener listener [ ] = new RealmChangeListener [ 1 ] ; <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> listener [ 0 ] = new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> @ @ - 431 , 7 + 426 , 7 @ @ public class NotificationsTest { <nl> <nl> @ Test <nl> @ UiThreadTest <nl> - public void testEmptyCommitTriggerChangeListener ( ) { <nl> + public void emptyCommitTriggerChangeListener ( ) { <nl> final AtomicBoolean success = new AtomicBoolean ( false ) ; <nl> final RealmChangeListener listener = new RealmChangeListener ( ) { <nl> @ Override <nl> @ @ - 439 , 7 + 434 , 7 @ @ public class NotificationsTest { <nl> success . set ( true ) ; <nl> } <nl> } ; <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> realm . addChangeListener ( listener ) ; <nl> realm . beginTransaction ( ) ; <nl> realm . commitTransaction ( ) ; <nl> @ @ - 448 , 7 + 443 , 7 @ @ public class NotificationsTest { <nl> <nl> @ Test <nl> @ UiThreadTest <nl> - public void testAddRemoveListenerConcurrency ( ) { <nl> + public void addRemoveListenerConcurrency ( ) { <nl> final AtomicInteger counter1 = new AtomicInteger ( 0 ) ; <nl> final AtomicInteger counter2 = new AtomicInteger ( 0 ) ; <nl> final AtomicInteger counter3 = new AtomicInteger ( 0 ) ; <nl> @ @ - 482 , 7 + 477 , 7 @ @ public class NotificationsTest { <nl> } <nl> } ; <nl> <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> realm . addChangeListener ( listener2 ) ; <nl> realm . addChangeListener ( listener3 ) ; <nl> <nl> @ @ - 513 , 9 + 508 , 9 @ @ public class NotificationsTest { <nl> <nl> @ Test <nl> @ UiThreadTest <nl> - public void testWeakReferenceListener ( ) throws InterruptedException { <nl> + public void weakReferenceListener ( ) throws InterruptedException { <nl> final AtomicInteger counter = new AtomicInteger ( 0 ) ; <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> RealmChangeListener listener = new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> @ @ - 544 , 9 + 539 , 9 @ @ public class NotificationsTest { <nl> / / without throwing an exception . <nl> @ Test <nl> @ UiThreadTest <nl> - public void testRemovingWeakReferenceListener ( ) throws InterruptedException { <nl> + public void removingWeakReferenceListener ( ) throws InterruptedException { <nl> final AtomicInteger counter = new AtomicInteger ( 0 ) ; <nl> - realm = Realm . getInstance ( context ) ; <nl> + realm = Realm . getInstance ( realmConfig ) ; <nl> RealmChangeListener listenerA = new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> @ @ - 581 , 11 + 576 , 8 @ @ public class NotificationsTest { <nl> / / Tests that if the same configuration is used on 2 different Looper threads that each gets its own Handler . This <nl> / / prevents commitTransaction from accidentally posting messages to Handlers which might reference a closed Realm . <nl> @ Test <nl> - public void testDoNotUseClosedHandler ( ) throws InterruptedException { <nl> - final RealmConfiguration realmConfiguration = TestHelper . createConfiguration ( context ) ; <nl> + public void doNotUseClosedHandler ( ) throws InterruptedException { <nl> final AssertionFailedError [ ] threadAssertionError = new AssertionFailedError [ 1 ] ; / / Keep track of errors in test threads . <nl> - Realm . deleteRealm ( realmConfiguration ) ; <nl> - <nl> final CountDownLatch handlerNotified = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch backgroundThreadClosed = new CountDownLatch ( 1 ) ; <nl> <nl> @ @ - 595 , 7 + 587 , 7 @ @ public class NotificationsTest { <nl> @ Override <nl> public void run ( ) { <nl> Looper . prepare ( ) ; <nl> - final Realm realm = Realm . getInstance ( realmConfiguration ) ; <nl> + final Realm realm = Realm . getInstance ( realmConfig ) ; <nl> RealmChangeListener listener = new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> @ @ - 613 , 7 + 605 , 7 @ @ public class NotificationsTest { <nl> @ Override <nl> public void run ( ) { <nl> Looper . prepare ( ) ; <nl> - Realm realm = Realm . getInstance ( realmConfiguration ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> RealmChangeListener listener = new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> @ @ - 635 , 7 + 627 , 7 @ @ public class NotificationsTest { <nl> <nl> / / Any REALM _ CHANGED message should now only reach the open Handler on Thread1 <nl> backgroundThreadClosed . await ( ) ; <nl> - Realm realm = Realm . getInstance ( realmConfiguration ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> realm . beginTransaction ( ) ; <nl> realm . commitTransaction ( ) ; <nl> try { <nl> @ @ - 654 , 10 + 646 , 7 @ @ public class NotificationsTest { <nl> / / Test that we handle a Looper thread quiting it ' s looper before it is done executing the current loop ( = Realm . close ( ) <nl> / / isn ' t called yet ) . <nl> @ Test <nl> - public void testLooperThreadQuitsLooperEarly ( ) throws InterruptedException { <nl> - RealmConfiguration config = TestHelper . createConfiguration ( context ) ; <nl> - Realm . deleteRealm ( config ) ; <nl> - <nl> + public void looperThreadQuitsLooperEarly ( ) throws InterruptedException { <nl> final CountDownLatch backgroundLooperStartedAndStopped = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch mainThreadCommitCompleted = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch backgroundThreadStopped = new CountDownLatch ( 1 ) ; <nl> @ @ - 669 , 9 + 658 , 9 @ @ public class NotificationsTest { <nl> public void run ( ) { <nl> Looper . prepare ( ) ; / / Fake background thread with a looper , eg . a IntentService <nl> <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> realm . setAutoRefresh ( false ) ; <nl> - Looper . myLooper ( ) . quit ( ) ; <nl> + TestHelper . quitLooperOrFail ( ) ; <nl> backgroundLooperStartedAndStopped . countDown ( ) ; <nl> try { <nl> mainThreadCommitCompleted . await ( ) ; <nl> @ @ - 685 , 7 + 674 , 7 @ @ public class NotificationsTest { <nl> <nl> / / Create a commit on another thread <nl> TestHelper . awaitOrFail ( backgroundLooperStartedAndStopped ) ; <nl> - Realm realm = Realm . getInstance ( config ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> Logger logger = TestHelper . getFailureLogger ( Log . WARN ) ; <nl> RealmLog . add ( logger ) ; <nl> <nl> @ @ - 699 , 7 + 688 , 7 @ @ public class NotificationsTest { <nl> } <nl> <nl> @ Test <nl> - public void testHandlerThreadShouldReceiveNotification ( ) throws ExecutionException , InterruptedException { <nl> + public void handlerThreadShouldReceiveNotification ( ) throws ExecutionException , InterruptedException { <nl> final AssertionFailedError [ ] assertionFailedErrors = new AssertionFailedError [ 1 ] ; <nl> final CountDownLatch backgroundThreadReady = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch numberOfInvocation = new CountDownLatch ( 1 ) ; <nl> @ @ - 715 , 7 + 704 , 7 @ @ public class NotificationsTest { <nl> } catch ( AssertionFailedError e ) { <nl> assertionFailedErrors [ 0 ] = e ; <nl> } <nl> - final Realm backgroundRealm = Realm . getInstance ( context ) ; <nl> + final Realm backgroundRealm = Realm . getInstance ( realmConfig ) ; <nl> backgroundRealm . addChangeListener ( new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> @ @ - 729 , 7 + 718 , 7 @ @ public class NotificationsTest { <nl> TestHelper . awaitOrFail ( backgroundThreadReady ) ; <nl> / / At this point the background thread started & registered the listener <nl> <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> realm . beginTransaction ( ) ; <nl> realm . createObject ( AllTypes . class ) ; <nl> realm . commitTransaction ( ) ; <nl> @ @ - 743 , 14 + 732 , 14 @ @ public class NotificationsTest { <nl> } <nl> <nl> @ Test <nl> - public void testNonLooperThreadShouldNotifyLooperThreadAboutCommit ( ) throws Throwable { <nl> + public void nonLooperThreadShouldNotifyLooperThreadAboutCommit ( ) throws Throwable { <nl> final CountDownLatch mainThreadReady = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch numberOfInvocation = new CountDownLatch ( 1 ) ; <nl> Thread thread = new Thread ( ) { <nl> @ Override <nl> public void run ( ) { <nl> TestHelper . awaitOrFail ( mainThreadReady ) ; <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> realm . beginTransaction ( ) ; <nl> realm . createObject ( AllTypes . class ) ; <nl> realm . commitTransaction ( ) ; <nl> @ @ - 765 , 7 + 754 , 7 @ @ public class NotificationsTest { <nl> handler . post ( new Runnable ( ) { <nl> @ Override <nl> public void run ( ) { <nl> - final Realm mainRealm = Realm . getInstance ( context ) ; <nl> + final Realm mainRealm = Realm . getInstance ( realmConfig ) ; <nl> mainRealm . addChangeListener ( new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> @ @ - 785 , 7 + 774 , 7 @ @ public class NotificationsTest { <nl> / / to advance to the latest version . We make sure in this test that all Realm listeners will be notified <nl> / / regardless of the presence of an async RealmResults that will delay the ` REALM _ CHANGE ` sometimes <nl> @ Test <nl> - public void testAsyncRealmResultsShouldNotBlockBackgroundCommitNotification ( ) throws Throwable { <nl> + public void asyncRealmResultsShouldNotBlockBackgroundCommitNotification ( ) throws Throwable { <nl> final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger ( 0 ) ; <nl> final AtomicInteger numberOfAsyncRealmResultsCallbackInvocation = new AtomicInteger ( 0 ) ; <nl> final CountDownLatch signalTestFinished = new CountDownLatch ( 2 ) ; <nl> @ @ - 801 , 11 + 790 , 11 @ @ public class NotificationsTest { <nl> backgroundLooper [ 0 ] = Looper . myLooper ( ) ; <nl> <nl> try { <nl> - realm [ 0 ] = Realm . getInstance ( context ) ; <nl> + realm [ 0 ] = Realm . getInstance ( realmConfig ) ; <nl> realm [ 0 ] . addChangeListener ( new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> - RealmResults < Dog > dogs = null ; / / to keep it as a strong reference <nl> + RealmResults < Dog > dogs ; / / to keep it as a strong reference <nl> switch ( numberOfRealmCallbackInvocation . incrementAndGet ( ) ) { <nl> case 1 : { <nl> / / first commit <nl> @ @ - 821 , 7 + 810 , 7 @ @ public class NotificationsTest { <nl> new Thread ( ) { <nl> @ Override <nl> public void run ( ) { <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> realm . beginTransaction ( ) ; <nl> realm . createObject ( Dog . class ) ; <nl> realm . commitTransaction ( ) ; <nl> @ @ - 873 , 7 + 862 , 7 @ @ public class NotificationsTest { <nl> / / to advance to the latest version . We make sure in this test that all Realm listeners will be notified <nl> / / regardless of the presence of an async RealmObject that will delay the ` REALM _ CHANGE ` sometimes <nl> @ Test <nl> - public void testAsyncRealmObjectShouldNotBlockBackgroundCommitNotification ( ) throws Throwable { <nl> + public void asyncRealmObjectShouldNotBlockBackgroundCommitNotification ( ) throws Throwable { <nl> final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger ( 0 ) ; <nl> final AtomicInteger numberOfAsyncRealmObjectCallbackInvocation = new AtomicInteger ( 0 ) ; <nl> final CountDownLatch signalTestFinished = new CountDownLatch ( 1 ) ; <nl> @ @ - 889 , 11 + 878 , 11 @ @ public class NotificationsTest { <nl> backgroundLooper [ 0 ] = Looper . myLooper ( ) ; <nl> <nl> try { <nl> - realm [ 0 ] = Realm . getInstance ( context ) ; <nl> + realm [ 0 ] = Realm . getInstance ( realmConfig ) ; <nl> realm [ 0 ] . addChangeListener ( new RealmChangeListener ( ) { <nl> @ Override <nl> public void onChange ( ) { <nl> - Dog dog = null ; / / to keep it as a strong reference <nl> + Dog dog ; / / to keep it as a strong reference <nl> switch ( numberOfRealmCallbackInvocation . incrementAndGet ( ) ) { <nl> case 1 : { <nl> / / first commit <nl> @ @ - 909 , 7 + 898 , 7 @ @ public class NotificationsTest { <nl> new Thread ( ) { <nl> @ Override <nl> public void run ( ) { <nl> - Realm realm = Realm . getInstance ( context ) ; <nl> + Realm realm = Realm . getInstance ( realmConfig ) ; <nl> realm . beginTransaction ( ) ; <nl> realm . createObject ( Dog . class ) ; <nl> realm . commitTransaction ( ) ; <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java <nl> index 898f0b7 . . 5ac41a5 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java <nl> @ @ - 342 , 6 + 342 , 26 @ @ public class RealmObjectSchemaTests extends AndroidTestCase { <nl> } <nl> } <nl> <nl> + public void testAddPrimaryKeyFieldModifier _ duplicateValues ( ) { <nl> + for ( PrimaryKeyFieldType fieldType : PrimaryKeyFieldType . values ( ) ) { <nl> + final String fieldName = " foo " ; <nl> + schema . addField ( fieldName , fieldType . getType ( ) ) ; <nl> + <nl> + / / create multiple objects with same values . <nl> + realm . createObject ( schema . getClassName ( ) ) ; <nl> + realm . createObject ( schema . getClassName ( ) ) ; <nl> + <nl> + try { <nl> + schema . addPrimaryKey ( fieldName ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException e ) { <nl> + / / check if message reports correct field name . <nl> + assertTrue ( e . getMessage ( ) . contains ( " \ " " + fieldName + " \ " " ) ) ; <nl> + } <nl> + schema . removeField ( fieldName ) ; <nl> + } <nl> + } <nl> + <nl> public void testAddIndexFieldModifier _ illegalFieldTypeThrows ( ) { <nl> String fieldName = " foo " ; <nl> for ( InvalidIndexFieldType fieldType : InvalidIndexFieldType . values ( ) ) { <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java <nl> index 8892be9 . . 949fc32 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java <nl> @ @ - 939 , 15 + 939 , 15 @ @ public class RealmResultsTests { <nl> @ Test <nl> public void contains _ realmObjectFromOtherRealm ( ) { <nl> RealmConfiguration realmConfig = configFactory . createConfiguration ( " contains _ test . realm " ) ; <nl> - Realm testRealmTwo = Realm . getInstance ( realmConfig ) ; <nl> + Realm realmTwo = Realm . getInstance ( realmConfig ) ; <nl> try { <nl> <nl> - testRealmTwo . beginTransaction ( ) ; <nl> - testRealmTwo . allObjects ( AllTypes . class ) . clear ( ) ; <nl> - testRealmTwo . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; <nl> + realmTwo . beginTransaction ( ) ; <nl> + realmTwo . allObjects ( AllTypes . class ) . clear ( ) ; <nl> + realmTwo . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; <nl> <nl> for ( int i = 0 ; i < TEST _ DATA _ SIZE ; + + i ) { <nl> - AllTypes allTypes = testRealmTwo . createObject ( AllTypes . class ) ; <nl> + AllTypes allTypes = realmTwo . createObject ( AllTypes . class ) ; <nl> allTypes . setColumnBoolean ( ( i % 2 ) = = 0 ) ; <nl> allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; <nl> allTypes . setColumnDate ( new Date ( YEAR _ MILLIS * ( i - TEST _ DATA _ SIZE / 2 ) ) ) ; <nl> @ @ - 955 , 24 + 955 , 24 @ @ public class RealmResultsTests { <nl> allTypes . setColumnFloat ( 1 . 234567f + i ) ; <nl> allTypes . setColumnString ( " test data " + i ) ; <nl> allTypes . setColumnLong ( i ) ; <nl> - Dog d = testRealmTwo . createObject ( Dog . class ) ; <nl> + Dog d = realmTwo . createObject ( Dog . class ) ; <nl> d . setName ( " Foo " + i ) ; <nl> allTypes . setColumnRealmObject ( d ) ; <nl> allTypes . getColumnRealmList ( ) . add ( d ) ; <nl> - NonLatinFieldNames nonLatinFieldNames = testRealmTwo . createObject ( NonLatinFieldNames . class ) ; <nl> + NonLatinFieldNames nonLatinFieldNames = realmTwo . createObject ( NonLatinFieldNames . class ) ; <nl> nonLatinFieldNames . set 델 타 ( i ) ; <nl> nonLatinFieldNames . set Δ έ λ τ α ( i ) ; <nl> } <nl> - testRealmTwo . commitTransaction ( ) ; <nl> + realmTwo . commitTransaction ( ) ; <nl> <nl> - final AllTypes item = testRealmTwo . where ( AllTypes . class ) . findFirst ( ) ; <nl> + final AllTypes item = realmTwo . where ( AllTypes . class ) . findFirst ( ) ; <nl> <nl> assertFalse ( " Should not be able to find one object in another Realm via RealmResults # contains " , <nl> realm . where ( AllTypes . class ) . findAll ( ) . contains ( item ) ) ; <nl> <nl> } finally { <nl> - if ( testRealmTwo ! = null & & ! testRealmTwo . isClosed ( ) ) { <nl> - testRealmTwo . close ( ) ; <nl> + if ( realmTwo ! = null & & ! realmTwo . isClosed ( ) ) { <nl> + realmTwo . close ( ) ; <nl> } <nl> } <nl> } <nl> @ @ - 1424 , 4 + 1424 , 112 @ @ public class RealmResultsTests { <nl> } catch ( IllegalArgumentException ignored ) { <nl> } <nl> } <nl> + <nl> + private RealmResults < Dog > populateRealmResultsOnDeletedLinkView ( ) { <nl> + realm . beginTransaction ( ) ; <nl> + Owner owner = realm . createObject ( Owner . class ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) { <nl> + Dog dog = new Dog ( ) ; <nl> + dog . setName ( " name _ " + i ) ; <nl> + dog . setOwner ( owner ) ; <nl> + owner . getDogs ( ) . add ( dog ) ; <nl> + } <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + <nl> + RealmResults < Dog > dogs = owner . getDogs ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; <nl> + / / dogs = dogs . where ( ) . findFirst ( ) . getOwner ( ) . getDogs ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; <nl> + <nl> + realm . beginTransaction ( ) ; <nl> + owner . removeFromRealm ( ) ; <nl> + realm . commitTransaction ( ) ; <nl> + return dogs ; <nl> + } <nl> + <nl> + @ Test <nl> + public void isValid _ resultsBuiltOnDeletedLinkView ( ) { <nl> + assertEquals ( false , populateRealmResultsOnDeletedLinkView ( ) . isValid ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void size _ resultsBuiltOnDeletedLinkView ( ) { <nl> + assertEquals ( 0 , populateRealmResultsOnDeletedLinkView ( ) . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void first _ resultsBuiltOnDeletedLinkView ( ) { <nl> + try { <nl> + populateRealmResultsOnDeletedLinkView ( ) . first ( ) ; <nl> + } catch ( ArrayIndexOutOfBoundsException ignored ) { <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void last _ resultsBuiltOnDeletedLinkView ( ) { <nl> + try { <nl> + populateRealmResultsOnDeletedLinkView ( ) . last ( ) ; <nl> + } catch ( ArrayIndexOutOfBoundsException ignored ) { <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void sum _ resultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + assertEquals ( 0 , dogs . sum ( Dog . FIELD _ AGE ) . intValue ( ) ) ; <nl> + assertEquals ( 0f , dogs . sum ( Dog . FIELD _ HEIGHT ) . floatValue ( ) , 0f ) ; <nl> + assertEquals ( 0d , dogs . sum ( Dog . FIELD _ WEIGHT ) . doubleValue ( ) , 0d ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void average _ resultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + assertEquals ( 0d , dogs . average ( Dog . FIELD _ AGE ) , 0d ) ; <nl> + assertEquals ( 0d , dogs . average ( Dog . FIELD _ HEIGHT ) , 0d ) ; <nl> + assertEquals ( 0d , dogs . average ( Dog . FIELD _ WEIGHT ) , 0d ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void clear _ resultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + realm . beginTransaction ( ) ; <nl> + dogs . clear ( ) ; <nl> + assertEquals ( 0 , dogs . size ( ) ) ; <nl> + realm . commitTransaction ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void max _ resultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + assertNull ( dogs . max ( Dog . FIELD _ AGE ) ) ; <nl> + assertNull ( dogs . max ( Dog . FIELD _ HEIGHT ) ) ; <nl> + assertNull ( dogs . max ( Dog . FIELD _ WEIGHT ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void max _ dateResultsBuiltOnDeletedLinkView ( ) { <nl> + assertEquals ( null , populateRealmResultsOnDeletedLinkView ( ) . maxDate ( Dog . FIELD _ BIRTHDAY ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void min _ resultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + assertNull ( dogs . min ( Dog . FIELD _ AGE ) ) ; <nl> + assertNull ( dogs . min ( Dog . FIELD _ HEIGHT ) ) ; <nl> + assertNull ( dogs . min ( Dog . FIELD _ WEIGHT ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void minDateResultsBuiltOnDeletedLinkView ( ) { <nl> + assertEquals ( null , populateRealmResultsOnDeletedLinkView ( ) . minDate ( Dog . FIELD _ BIRTHDAY ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void whereResultsBuiltOnDeletedLinkView ( ) { <nl> + try { <nl> + populateRealmResultsOnDeletedLinkView ( ) . where ( ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalStateException e ) { <nl> + assertEquals ( " The RealmList which this RealmResults is created on has been deleted . " , e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java <nl> index 62129bf . . c94fee0 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java <nl> @ @ - 16 , 8 + 16 , 15 @ @ <nl> <nl> package io . realm ; <nl> <nl> - import android . test . AndroidTestCase ; <nl> + import android . support . test . runner . AndroidJUnit4 ; <nl> <nl> + import org . junit . After ; <nl> + import org . junit . Before ; <nl> + import org . junit . Rule ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> import java . util . List ; <nl> import java . util . Set ; <nl> @ @ - 25 , 38 + 32 , 47 @ @ import java . util . Set ; <nl> import io . realm . entities . AllJavaTypes ; <nl> import io . realm . entities . Owner ; <nl> import io . realm . internal . Util ; <nl> + import io . realm . rule . TestRealmConfigurationFactory ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> + import static org . junit . Assert . assertNotNull ; <nl> + import static org . junit . Assert . assertNull ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + import static org . junit . Assert . fail ; <nl> + <nl> + @ RunWith ( AndroidJUnit4 . class ) <nl> + public class RealmSchemaTests { <nl> <nl> - public class RealmSchemaTests extends AndroidTestCase { <nl> + @ Rule <nl> + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; <nl> <nl> - public static final String CLASS _ ALL _ JAVA _ TYPES = " AllJavaTypes " ; <nl> private DynamicRealm realm ; <nl> private RealmSchema realmSchema ; <nl> <nl> - @ Override <nl> - protected void setUp ( ) throws Exception { <nl> - super . setUp ( ) ; <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + @ Before <nl> + public void setUp ( ) { <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schema ( AllJavaTypes . class , Owner . class ) <nl> . build ( ) ; <nl> - Realm . deleteRealm ( realmConfig ) ; <nl> Realm . getInstance ( realmConfig ) . close ( ) ; / / create Schema <nl> - this . realm = DynamicRealm . getInstance ( realmConfig ) ; <nl> + realm = DynamicRealm . getInstance ( realmConfig ) ; <nl> realmSchema = this . realm . getSchema ( ) ; <nl> - this . realm . beginTransaction ( ) ; <nl> + realm . beginTransaction ( ) ; <nl> } <nl> <nl> - @ Override <nl> - protected void tearDown ( ) throws Exception { <nl> - super . tearDown ( ) ; <nl> + @ After <nl> + public void tearDown ( ) { <nl> realm . cancelTransaction ( ) ; <nl> realm . close ( ) ; <nl> } <nl> <nl> - public void testGetAllClasses ( ) { <nl> + @ Test <nl> + public void getAll ( ) { <nl> Set < RealmObjectSchema > objectSchemas = realmSchema . getAll ( ) ; <nl> assertEquals ( 5 , objectSchemas . size ( ) ) ; <nl> <nl> - List < String > expectedTables = Arrays . asList ( CLASS _ ALL _ JAVA _ TYPES , " Owner " , " Cat " , " Dog " , " DogPrimaryKey " ) ; <nl> + List < String > expectedTables = Arrays . asList ( AllJavaTypes . CLASS _ NAME , " Owner " , " Cat " , " Dog " , " DogPrimaryKey " ) ; <nl> for ( RealmObjectSchema objectSchema : objectSchemas ) { <nl> if ( ! expectedTables . contains ( objectSchema . getClassName ( ) ) ) { <nl> fail ( objectSchema . getClassName ( ) + " was not found " ) ; <nl> @ @ - 64 , 12 + 80 , 14 @ @ public class RealmSchemaTests extends AndroidTestCase { <nl> } <nl> } <nl> <nl> - public void testCreateClass ( ) { <nl> + @ Test <nl> + public void create ( ) { <nl> realmSchema . create ( " Foo " ) ; <nl> assertTrue ( realmSchema . contains ( " Foo " ) ) ; <nl> } <nl> <nl> - public void testCreateClassInvalidNameThrows ( ) { <nl> + @ Test <nl> + public void create _ invalidNameThrows ( ) { <nl> String [ ] names = { null , " " , TestHelper . getRandomString ( 57 ) } ; <nl> <nl> for ( String name : names ) { <nl> @ @ - 81 , 50 + 99 , 56 @ @ public class RealmSchemaTests extends AndroidTestCase { <nl> } <nl> } <nl> <nl> - public void testGetClass ( ) { <nl> - RealmObjectSchema objectSchema = realmSchema . get ( CLASS _ ALL _ JAVA _ TYPES ) ; <nl> + @ Test <nl> + public void get ( ) { <nl> + RealmObjectSchema objectSchema = realmSchema . get ( AllJavaTypes . CLASS _ NAME ) ; <nl> assertNotNull ( objectSchema ) ; <nl> - assertEquals ( CLASS _ ALL _ JAVA _ TYPES , objectSchema . getClassName ( ) ) ; <nl> + assertEquals ( AllJavaTypes . CLASS _ NAME , objectSchema . getClassName ( ) ) ; <nl> } <nl> <nl> - public void testGetClassNotInSchema ( ) { <nl> + @ Test <nl> + public void get _ unknownClass ( ) { <nl> assertNull ( realmSchema . get ( " Foo " ) ) ; <nl> } <nl> <nl> - public void testRenameClass ( ) { <nl> + @ Test <nl> + public void rename ( ) { <nl> realmSchema . rename ( " Owner " , " Owner2 " ) ; <nl> assertFalse ( realmSchema . contains ( " Owner " ) ) ; <nl> assertTrue ( realmSchema . contains ( " Owner2 " ) ) ; <nl> } <nl> <nl> - public void testRenameClassInvalidArgumentsThrows ( ) { <nl> + @ Test <nl> + public void rename _ invalidArgumentThrows ( ) { <nl> String [ ] illegalNames = new String [ ] { null , " " } ; <nl> <nl> - / / Test as first parameters <nl> + / / Test as first parameter <nl> for ( String illegalName : illegalNames ) { <nl> try { <nl> - realmSchema . rename ( CLASS _ ALL _ JAVA _ TYPES , illegalName ) ; <nl> + realmSchema . rename ( illegalName , AllJavaTypes . CLASS _ NAME ) ; <nl> fail ( illegalName + " should throw an exception " ) ; <nl> } catch ( IllegalArgumentException ignored ) { <nl> } <nl> } <nl> <nl> - / / Test as last parameter <nl> + / / Test as last parameters <nl> for ( String illegalName : illegalNames ) { <nl> try { <nl> - realmSchema . rename ( illegalName , CLASS _ ALL _ JAVA _ TYPES ) ; <nl> + realmSchema . rename ( AllJavaTypes . CLASS _ NAME , illegalName ) ; <nl> fail ( illegalName + " should throw an exception " ) ; <nl> } catch ( IllegalArgumentException ignored ) { <nl> } <nl> } <nl> } <nl> <nl> - public void testRemoveClass ( ) { <nl> - realmSchema . remove ( CLASS _ ALL _ JAVA _ TYPES ) ; <nl> - assertFalse ( realmSchema . contains ( CLASS _ ALL _ JAVA _ TYPES ) ) ; <nl> + @ Test <nl> + public void remove ( ) { <nl> + realmSchema . remove ( AllJavaTypes . CLASS _ NAME ) ; <nl> + assertFalse ( realmSchema . contains ( AllJavaTypes . CLASS _ NAME ) ) ; <nl> } <nl> <nl> - public void testRemoveClassInvalidClassNameThrows ( ) { <nl> + @ Test <nl> + public void remove _ invalidArgumentThrows ( ) { <nl> try { <nl> realmSchema . remove ( " Foo " ) ; <nl> fail ( ) ; <nl> @ @ - 139 , 10 + 163 , 9 @ @ public class RealmSchemaTests extends AndroidTestCase { <nl> } <nl> <nl> / / Test that it if { A - > B & & B - > A } you should remove the individual fields first before removing the entire <nl> - / / class . This also include transitive dependencies : / <nl> - / / Re - enable when this if fixed : https : / / github . com / realm / realm - core / pull / 1267 <nl> - public void FIMXEtestRemoveClassWithReferencesThrows ( ) { <nl> - Util . setDebugLevel ( 2 ) ; <nl> + / / class . This also include transitive dependencies . <nl> + @ Test <nl> + public void remove _ classWithReferencesThrows ( ) { <nl> try { <nl> realmSchema . remove ( " Cat " ) ; <nl> fail ( ) ; <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java b / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java <nl> index 109fd7e . . 056f4c6 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java <nl> @ @ - 21 , 6 + 21 , 8 @ @ import android . content . res . AssetManager ; <nl> import android . os . Looper ; <nl> import android . util . Log ; <nl> <nl> + import org . junit . Assert ; <nl> + <nl> import java . io . BufferedReader ; <nl> import java . io . ByteArrayInputStream ; <nl> import java . io . File ; <nl> @ @ - 684 , 4 + 686 , 13 @ @ public class TestHelper { <nl> AssetManager assetManager = context . getAssets ( ) ; <nl> return assetManager . open ( file ) ; <nl> } <nl> + <nl> + public static void quitLooperOrFail ( ) { <nl> + Looper looper = Looper . myLooper ( ) ; <nl> + if ( looper ! = null ) { <nl> + looper . quit ( ) ; <nl> + } else { <nl> + Assert . fail ( ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / entities / AllJavaTypes . java b / realm / realm - library / src / androidTest / java / io / realm / entities / AllJavaTypes . java <nl> index 0264d61 . . fb37752 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / entities / AllJavaTypes . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / entities / AllJavaTypes . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import io . realm . annotations . PrimaryKey ; <nl> <nl> public class AllJavaTypes extends RealmObject { <nl> <nl> + public static final String CLASS _ NAME = " AllJavaTypes " ; <nl> public static String FIELD _ IGNORED = " fieldIgnored " ; <nl> public static String FIELD _ STRING = " fieldString " ; <nl> public static String FIELD _ SHORT = " fieldShort " ; <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java b / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java <nl> index f27ba08 . . d6b2046 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java <nl> @ @ - 25 , 6 + 25 , 11 @ @ import io . realm . annotations . Index ; <nl> public class Dog extends RealmObject { <nl> <nl> public static final String CLASS _ NAME = " Dog " ; <nl> + public static final String FIELD _ NAME = " name " ; <nl> + public static final String FIELD _ AGE = " age " ; <nl> + public static final String FIELD _ HEIGHT = " height " ; <nl> + public static final String FIELD _ WEIGHT = " weight " ; <nl> + public static final String FIELD _ BIRTHDAY = " birthday " ; <nl> <nl> @ Index <nl> private String name ;
NEAREST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTest . java <nl> deleted file mode 100644 <nl> index cdc66ad . . 0000000 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTest . java <nl> + + + / dev / null <nl> @ @ - 1 , 283 + 0 , 0 @ @ <nl> - / * <nl> - * Copyright 2015 Realm Inc . <nl> - * <nl> - * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> - * you may not use this file except in compliance with the License . <nl> - * You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package io . realm ; <nl> - <nl> - import android . test . AndroidTestCase ; <nl> - <nl> - import java . io . File ; <nl> - import java . io . IOException ; <nl> - import java . util . concurrent . Callable ; <nl> - import java . util . concurrent . CountDownLatch ; <nl> - import java . util . concurrent . ExecutionException ; <nl> - import java . util . concurrent . ExecutorService ; <nl> - import java . util . concurrent . Executors ; <nl> - import java . util . concurrent . Future ; <nl> - import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . TimeoutException ; <nl> - <nl> - import io . realm . entities . AllTypes ; <nl> - import io . realm . entities . StringOnly ; <nl> - <nl> - public class RealmCacheTest extends AndroidTestCase { <nl> - <nl> - private RealmConfiguration defaultConfig ; <nl> - <nl> - @ Override <nl> - protected void setUp ( ) throws Exception { <nl> - super . setUp ( ) ; <nl> - defaultConfig = TestHelper . createConfiguration ( getContext ( ) ) ; <nl> - Realm . deleteRealm ( defaultConfig ) ; <nl> - } <nl> - <nl> - / / Test that the closed Realm isn ' t kept in the Realm instance cache <nl> - public void testRealmCacheIsCleared ( ) { <nl> - Realm typedRealm = Realm . getInstance ( defaultConfig ) ; <nl> - DynamicRealm dynamicRealm = DynamicRealm . getInstance ( defaultConfig ) ; <nl> - <nl> - typedRealm . close ( ) ; / / Still a dynamic instance open , but the typed Realm cache must still be cleared . <nl> - dynamicRealm . close ( ) ; <nl> - <nl> - Realm typedRealm1 = Realm . getInstance ( defaultConfig ) ; <nl> - try { <nl> - assertFalse ( typedRealm = = typedRealm1 ) ; / / Must be different instance <nl> - / / If cache isn ' t cleared this would crash because of a closed shared group . <nl> - assertEquals ( 0 , typedRealm1 . where ( AllTypes . class ) . count ( ) ) ; <nl> - } finally { <nl> - typedRealm1 . close ( ) ; <nl> - } <nl> - } <nl> - <nl> - / / Test that the closed DynamicRealms isn ' t kept in the DynamicRealm instance cache <nl> - public void testDynamicRealmCacheIsCleared ( ) { <nl> - DynamicRealm dynamicRealm = DynamicRealm . getInstance ( defaultConfig ) ; <nl> - Realm typedRealm = Realm . getInstance ( defaultConfig ) ; <nl> - <nl> - dynamicRealm . close ( ) ; / / Still an instance open , but DynamicRealm cache must still be cleared . <nl> - typedRealm . close ( ) ; <nl> - <nl> - DynamicRealm dynamicRealm1 = DynamicRealm . getInstance ( defaultConfig ) ; <nl> - try { <nl> - / / If cache isn ' t cleared this would crash because of a closed shared group . <nl> - assertFalse ( dynamicRealm = = dynamicRealm1 ) ; <nl> - assertEquals ( 0 , dynamicRealm1 . getVersion ( ) ) ; <nl> - } finally { <nl> - dynamicRealm1 . close ( ) ; <nl> - } <nl> - } <nl> - <nl> - public void testGetInstanceClearsCacheWhenFailed ( ) { <nl> - String REALM _ NAME = " invalid _ cache . realm " ; <nl> - RealmConfiguration configA = TestHelper . createConfiguration ( getContext ( ) , REALM _ NAME , TestHelper . getRandomKey ( 42 ) ) ; <nl> - RealmConfiguration configB = TestHelper . createConfiguration ( getContext ( ) , REALM _ NAME , TestHelper . getRandomKey ( 43 ) ) ; <nl> - <nl> - Realm . deleteRealm ( configA ) ; <nl> - Realm realm = Realm . getInstance ( configA ) ; / / Create starting Realm with key1 <nl> - realm . close ( ) ; <nl> - try { <nl> - Realm . getInstance ( configB ) ; / / Try to open with key 2 <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - / / Delete Realm so key 2 works . This should work as a Realm shouldn ' t be cached <nl> - / / if initialization failed . <nl> - assertTrue ( Realm . deleteRealm ( configA ) ) ; <nl> - realm = Realm . getInstance ( configB ) ; <nl> - realm . close ( ) ; <nl> - } <nl> - } <nl> - <nl> - public void testRealmCache ( ) { <nl> - Realm realm = Realm . getInstance ( defaultConfig ) ; <nl> - Realm newRealm = Realm . getInstance ( defaultConfig ) ; <nl> - try { <nl> - assertEquals ( realm , newRealm ) ; <nl> - } finally { <nl> - realm . close ( ) ; <nl> - newRealm . close ( ) ; <nl> - } <nl> - } <nl> - <nl> - / / We should not cache wrong configurations <nl> - public void testDontCacheWrongConfigurations ( ) throws IOException { <nl> - Realm testRealm ; <nl> - String REALM _ NAME = " encrypted . realm " ; <nl> - TestHelper . copyRealmFromAssets ( getContext ( ) , REALM _ NAME , REALM _ NAME ) ; <nl> - RealmMigration realmMigration = TestHelper . prepareMigrationToNullSupportStep ( ) ; <nl> - <nl> - RealmConfiguration wrongConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> - . name ( REALM _ NAME ) <nl> - . encryptionKey ( TestHelper . SHA512 ( " foo " ) ) <nl> - . migration ( realmMigration ) <nl> - . schema ( StringOnly . class ) <nl> - . build ( ) ; <nl> - <nl> - RealmConfiguration rightConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> - . name ( REALM _ NAME ) <nl> - . encryptionKey ( TestHelper . SHA512 ( " realm " ) ) <nl> - . migration ( realmMigration ) <nl> - . schema ( StringOnly . class ) <nl> - . build ( ) ; <nl> - <nl> - / / Open Realm with wrong key <nl> - try { <nl> - Realm . getInstance ( wrongConfig ) ; <nl> - fail ( ) ; <nl> - } catch ( IllegalArgumentException ignored ) { <nl> - } <nl> - <nl> - / / Try again with proper key <nl> - testRealm = Realm . getInstance ( rightConfig ) ; <nl> - assertNotNull ( testRealm ) ; <nl> - testRealm . close ( ) ; <nl> - } <nl> - <nl> - public void testDeletingRealmAlsoClearsConfigurationCache ( ) throws IOException { <nl> - String REALM _ NAME = " encrypted . realm " ; <nl> - byte [ ] oldPassword = TestHelper . SHA512 ( " realm " ) ; <nl> - byte [ ] newPassword = TestHelper . SHA512 ( " realm - copy " ) ; <nl> - <nl> - TestHelper . copyRealmFromAssets ( getContext ( ) , REALM _ NAME , REALM _ NAME ) ; <nl> - RealmMigration realmMigration = TestHelper . prepareMigrationToNullSupportStep ( ) ; <nl> - <nl> - RealmConfiguration config = new RealmConfiguration . Builder ( getContext ( ) ) <nl> - . name ( REALM _ NAME ) <nl> - . encryptionKey ( oldPassword ) <nl> - . migration ( realmMigration ) <nl> - . schema ( StringOnly . class ) <nl> - . build ( ) ; <nl> - <nl> - / / 1 . Write a copy of the encrypted Realm to a new file <nl> - Realm testRealm = Realm . getInstance ( config ) ; <nl> - File copiedRealm = new File ( config . getRealmFolder ( ) , " encrypted - copy . realm " ) ; <nl> - if ( copiedRealm . exists ( ) ) { <nl> - assertTrue ( copiedRealm . delete ( ) ) ; <nl> - } <nl> - testRealm . writeEncryptedCopyTo ( copiedRealm , newPassword ) ; <nl> - testRealm . close ( ) ; <nl> - <nl> - / / 2 . Delete the old Realm . <nl> - Realm . deleteRealm ( config ) ; <nl> - <nl> - / / 3 . Rename the new file to the old file name . <nl> - assertTrue ( copiedRealm . renameTo ( new File ( config . getRealmFolder ( ) , REALM _ NAME ) ) ) ; <nl> - <nl> - / / 4 . Try to open the file again with the new password <nl> - / / If the configuration cache wasn ' t cleared this would fail as we would detect two <nl> - / / configurations with 2 different passwords pointing to the same file . <nl> - RealmConfiguration newConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> - . name ( REALM _ NAME ) <nl> - . encryptionKey ( newPassword ) <nl> - . migration ( realmMigration ) <nl> - . schema ( StringOnly . class ) <nl> - . build ( ) ; <nl> - <nl> - testRealm = Realm . getInstance ( newConfig ) ; <nl> - assertNotNull ( testRealm ) ; <nl> - testRealm . close ( ) ; <nl> - } <nl> - <nl> - / / Tests that if the same Realm file is opened on multiple threads , we only need to validate the schema on the first thread . <nl> - public void testValidateSchemasOverThreads ( ) throws InterruptedException , TimeoutException , ExecutionException { <nl> - final RealmConfiguration config = TestHelper . createConfiguration ( getContext ( ) , " foo " ) ; <nl> - Realm . deleteRealm ( config ) ; <nl> - <nl> - final CountDownLatch bgThreadLocked = new CountDownLatch ( 1 ) ; <nl> - final CountDownLatch mainThreadDone = new CountDownLatch ( 1 ) ; <nl> - <nl> - new Thread ( new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - Realm realm = Realm . getInstance ( config ) ; <nl> - realm . beginTransaction ( ) ; <nl> - bgThreadLocked . countDown ( ) ; <nl> - try { <nl> - mainThreadDone . await ( 5 , TimeUnit . SECONDS ) ; <nl> - } catch ( InterruptedException ignored ) { <nl> - } <nl> - realm . close ( ) ; <nl> - } <nl> - } ) . start ( ) ; <nl> - <nl> - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { <nl> - @ Override <nl> - public Boolean call ( ) throws Exception { <nl> - Realm realm = Realm . getInstance ( config ) ; <nl> - realm . close ( ) ; <nl> - mainThreadDone . countDown ( ) ; <nl> - return true ; <nl> - } <nl> - } ) ; <nl> - <nl> - bgThreadLocked . await ( 2 , TimeUnit . SECONDS ) ; <nl> - assertTrue ( future . get ( 10 , TimeUnit . SECONDS ) ) ; <nl> - } <nl> - <nl> - public void testDifferentThreadsDifferentInstance ( ) throws InterruptedException { <nl> - final CountDownLatch closeLatch = new CountDownLatch ( 1 ) ; <nl> - <nl> - final Realm realmA = Realm . getInstance ( defaultConfig ) ; <nl> - <nl> - Thread thread = new Thread ( new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - Realm realmB = Realm . getInstance ( defaultConfig ) ; <nl> - assertFalse ( realmA = = realmB ) ; <nl> - RealmCache . invokeWithGlobalRefCount ( defaultConfig , <nl> - new TestHelper . ExpectedCountCallback ( 2 ) ) ; <nl> - realmB . close ( ) ; <nl> - closeLatch . countDown ( ) ; <nl> - } <nl> - } ) ; <nl> - thread . start ( ) ; <nl> - <nl> - closeLatch . await ( ) ; <nl> - RealmCache . invokeWithGlobalRefCount ( defaultConfig , new TestHelper . ExpectedCountCallback ( 1 ) ) ; <nl> - realmA . close ( ) ; <nl> - RealmCache . invokeWithGlobalRefCount ( defaultConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> - } <nl> - <nl> - public void testReleaseCacheInOneThread ( ) { <nl> - / / Test release typed Realm instance <nl> - Realm realmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; <nl> - Realm realmB = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; <nl> - RealmCache . release ( realmA ) ; <nl> - assertNotNull ( realmA . sharedGroupManager ) ; <nl> - RealmCache . release ( realmB ) ; <nl> - assertNull ( realmB . sharedGroupManager ) ; <nl> - / / No crash but warning in the log <nl> - RealmCache . release ( realmB ) ; <nl> - <nl> - / / Test release dynamic Realm instance <nl> - DynamicRealm dynamicRealmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , <nl> - DynamicRealm . class ) ; <nl> - DynamicRealm dynamicRealmB = RealmCache . createRealmOrGetFromCache ( defaultConfig , <nl> - DynamicRealm . class ) ; <nl> - RealmCache . release ( dynamicRealmA ) ; <nl> - assertNotNull ( dynamicRealmA . sharedGroupManager ) ; <nl> - RealmCache . release ( dynamicRealmB ) ; <nl> - assertNull ( dynamicRealmB . sharedGroupManager ) ; <nl> - / / No crash but warning in the log <nl> - RealmCache . release ( dynamicRealmB ) ; <nl> - <nl> - / / Test both typed Realm and dynamic Realm in same thread <nl> - realmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; <nl> - dynamicRealmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , DynamicRealm . class ) ; <nl> - RealmCache . release ( realmA ) ; <nl> - assertNull ( realmA . sharedGroupManager ) ; <nl> - RealmCache . release ( dynamicRealmA ) ; <nl> - assertNull ( realmA . sharedGroupManager ) ; <nl> - } <nl> - } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTests . java <nl> new file mode 100644 <nl> index 0000000 . . 3c73dee <nl> - - - / dev / null <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTests . java <nl> @ @ - 0 , 0 + 1 , 292 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm ; <nl> + <nl> + import android . content . Context ; <nl> + import android . support . test . InstrumentationRegistry ; <nl> + import android . support . test . runner . AndroidJUnit4 ; <nl> + <nl> + import org . junit . Before ; <nl> + import org . junit . Rule ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import java . io . File ; <nl> + import java . io . IOException ; <nl> + import java . util . concurrent . CountDownLatch ; <nl> + <nl> + import io . realm . entities . AllTypes ; <nl> + import io . realm . entities . StringOnly ; <nl> + import io . realm . rule . TestRealmConfigurationFactory ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + import static org . junit . Assert . assertFalse ; <nl> + import static org . junit . Assert . assertNull ; <nl> + import static org . junit . Assert . assertNotNull ; <nl> + import static org . junit . Assert . fail ; <nl> + <nl> + @ RunWith ( AndroidJUnit4 . class ) <nl> + public class RealmCacheTests { <nl> + <nl> + @ Rule <nl> + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; <nl> + <nl> + private RealmConfiguration defaultConfig ; <nl> + private Context context ; <nl> + <nl> + @ Before <nl> + public void setUp ( ) { <nl> + defaultConfig = configFactory . createConfiguration ( ) ; <nl> + context = InstrumentationRegistry . getInstrumentation ( ) . getContext ( ) ; <nl> + } <nl> + <nl> + / / Test that the closed Realm isn ' t kept in the Realm instance cache <nl> + @ Test <nl> + public void typedRealmCacheIsCleared ( ) { <nl> + Realm typedRealm = Realm . getInstance ( defaultConfig ) ; <nl> + DynamicRealm dynamicRealm = DynamicRealm . getInstance ( defaultConfig ) ; <nl> + <nl> + typedRealm . close ( ) ; / / Still a dynamic instance open , but the typed Realm cache must still be cleared . <nl> + dynamicRealm . close ( ) ; <nl> + <nl> + Realm typedRealm1 = Realm . getInstance ( defaultConfig ) ; <nl> + try { <nl> + assertFalse ( typedRealm = = typedRealm1 ) ; / / Must be different instance <nl> + / / If cache isn ' t cleared this would crash because of a closed shared group . <nl> + assertEquals ( 0 , typedRealm1 . where ( AllTypes . class ) . count ( ) ) ; <nl> + } finally { <nl> + typedRealm1 . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + / / Test that the closed DynamicRealms isn ' t kept in the DynamicRealm instance cache <nl> + @ Test <nl> + public void dynamicRealmCacheIsCleared ( ) { <nl> + DynamicRealm dynamicRealm = DynamicRealm . getInstance ( defaultConfig ) ; <nl> + Realm typedRealm = Realm . getInstance ( defaultConfig ) ; <nl> + <nl> + dynamicRealm . close ( ) ; / / Still an instance open , but DynamicRealm cache must still be cleared . <nl> + typedRealm . close ( ) ; <nl> + <nl> + DynamicRealm dynamicRealm1 = DynamicRealm . getInstance ( defaultConfig ) ; <nl> + try { <nl> + / / If cache isn ' t cleared this would crash because of a closed shared group . <nl> + assertFalse ( dynamicRealm = = dynamicRealm1 ) ; <nl> + assertEquals ( 0 , dynamicRealm1 . getVersion ( ) ) ; <nl> + } finally { <nl> + dynamicRealm1 . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void getInstanceClearsCacheWhenFailed ( ) { <nl> + String REALM _ NAME = " invalid _ cache . realm " ; <nl> + RealmConfiguration configA = configFactory . createConfiguration ( REALM _ NAME , <nl> + TestHelper . getRandomKey ( 42 ) ) ; <nl> + RealmConfiguration configB = configFactory . createConfiguration ( REALM _ NAME , <nl> + TestHelper . getRandomKey ( 43 ) ) ; <nl> + <nl> + Realm realm = Realm . getInstance ( configA ) ; / / Create starting Realm with key1 <nl> + realm . close ( ) ; <nl> + try { <nl> + Realm . getInstance ( configB ) ; / / Try to open with key 2 <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + / / Delete Realm so key 2 works . This should work as a Realm shouldn ' t be cached <nl> + / / if initialization failed . <nl> + assertTrue ( Realm . deleteRealm ( configA ) ) ; <nl> + realm = Realm . getInstance ( configB ) ; <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void realmCache ( ) { <nl> + Realm realm = Realm . getInstance ( defaultConfig ) ; <nl> + Realm newRealm = Realm . getInstance ( defaultConfig ) ; <nl> + try { <nl> + assertEquals ( realm , newRealm ) ; <nl> + } finally { <nl> + realm . close ( ) ; <nl> + newRealm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + / / We should not cache wrong configurations <nl> + @ Test <nl> + public void dontCacheWrongConfigurations ( ) throws IOException { <nl> + Realm testRealm ; <nl> + String REALM _ NAME = " encrypted . realm " ; <nl> + configFactory . copyRealmFromAssets ( context , REALM _ NAME , REALM _ NAME ) ; <nl> + RealmMigration realmMigration = TestHelper . prepareMigrationToNullSupportStep ( ) ; <nl> + <nl> + RealmConfiguration wrongConfig = configFactory . createConfigurationBuilder ( ) <nl> + . name ( REALM _ NAME ) <nl> + . encryptionKey ( TestHelper . SHA512 ( " foo " ) ) <nl> + . migration ( realmMigration ) <nl> + . schema ( StringOnly . class ) <nl> + . build ( ) ; <nl> + <nl> + RealmConfiguration rightConfig = configFactory . createConfigurationBuilder ( ) <nl> + . name ( REALM _ NAME ) <nl> + . encryptionKey ( TestHelper . SHA512 ( " realm " ) ) <nl> + . migration ( realmMigration ) <nl> + . schema ( StringOnly . class ) <nl> + . build ( ) ; <nl> + <nl> + / / Open Realm with wrong key <nl> + try { <nl> + Realm . getInstance ( wrongConfig ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + <nl> + / / Try again with proper key <nl> + testRealm = Realm . getInstance ( rightConfig ) ; <nl> + assertNotNull ( testRealm ) ; <nl> + testRealm . close ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void deletingRealmAlsoClearsConfigurationCache ( ) throws IOException { <nl> + String REALM _ NAME = " encrypted . realm " ; <nl> + byte [ ] oldPassword = TestHelper . SHA512 ( " realm " ) ; <nl> + byte [ ] newPassword = TestHelper . SHA512 ( " realm - copy " ) ; <nl> + <nl> + configFactory . copyRealmFromAssets ( context , REALM _ NAME , REALM _ NAME ) ; <nl> + RealmMigration realmMigration = TestHelper . prepareMigrationToNullSupportStep ( ) ; <nl> + <nl> + RealmConfiguration config = configFactory . createConfigurationBuilder ( ) <nl> + . name ( REALM _ NAME ) <nl> + . encryptionKey ( oldPassword ) <nl> + . migration ( realmMigration ) <nl> + . schema ( StringOnly . class ) <nl> + . build ( ) ; <nl> + <nl> + / / 1 . Write a copy of the encrypted Realm to a new file <nl> + Realm testRealm = Realm . getInstance ( config ) ; <nl> + File copiedRealm = new File ( config . getRealmFolder ( ) , " encrypted - copy . realm " ) ; <nl> + if ( copiedRealm . exists ( ) ) { <nl> + assertTrue ( copiedRealm . delete ( ) ) ; <nl> + } <nl> + testRealm . writeEncryptedCopyTo ( copiedRealm , newPassword ) ; <nl> + testRealm . close ( ) ; <nl> + <nl> + / / 2 . Delete the old Realm . <nl> + Realm . deleteRealm ( config ) ; <nl> + <nl> + / / 3 . Rename the new file to the old file name . <nl> + assertTrue ( copiedRealm . renameTo ( new File ( config . getRealmFolder ( ) , REALM _ NAME ) ) ) ; <nl> + <nl> + / / 4 . Try to open the file again with the new password <nl> + / / If the configuration cache wasn ' t cleared this would fail as we would detect two <nl> + / / configurations with 2 different passwords pointing to the same file . <nl> + RealmConfiguration newConfig = configFactory . createConfigurationBuilder ( ) <nl> + . name ( REALM _ NAME ) <nl> + . encryptionKey ( newPassword ) <nl> + . migration ( realmMigration ) <nl> + . schema ( StringOnly . class ) <nl> + . build ( ) ; <nl> + <nl> + testRealm = Realm . getInstance ( newConfig ) ; <nl> + assertNotNull ( testRealm ) ; <nl> + testRealm . close ( ) ; <nl> + } <nl> + <nl> + / / Tests that if the same Realm file is opened on multiple threads , we only need to validate the <nl> + / / schema on the first thread <nl> + / / When there is a transaction holding by a typed Realm in one thread , getInstance from the <nl> + / / other thread should not be blocked since we have cached the schemas already . <nl> + @ Test <nl> + public void getInstance _ shouldNotBeBlockedByTransactionInAnotherThread ( ) <nl> + throws InterruptedException { <nl> + Realm realm = Realm . getInstance ( defaultConfig ) ; <nl> + final CountDownLatch latch = new CountDownLatch ( 1 ) ; <nl> + realm . beginTransaction ( ) ; <nl> + <nl> + Thread thread = new Thread ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Realm realm = Realm . getInstance ( defaultConfig ) ; <nl> + realm . close ( ) ; <nl> + latch . countDown ( ) ; <nl> + } <nl> + } ) ; <nl> + thread . start ( ) ; <nl> + TestHelper . awaitOrFail ( latch ) ; <nl> + realm . cancelTransaction ( ) ; <nl> + realm . close ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void differentThreadsDifferentInstance ( ) throws InterruptedException { <nl> + final CountDownLatch closeLatch = new CountDownLatch ( 1 ) ; <nl> + <nl> + final Realm realmA = Realm . getInstance ( defaultConfig ) ; <nl> + <nl> + Thread thread = new Thread ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Realm realmB = Realm . getInstance ( defaultConfig ) ; <nl> + assertFalse ( realmA = = realmB ) ; <nl> + RealmCache . invokeWithGlobalRefCount ( defaultConfig , <nl> + new TestHelper . ExpectedCountCallback ( 2 ) ) ; <nl> + realmB . close ( ) ; <nl> + closeLatch . countDown ( ) ; <nl> + } <nl> + } ) ; <nl> + thread . start ( ) ; <nl> + <nl> + closeLatch . await ( ) ; <nl> + RealmCache . invokeWithGlobalRefCount ( defaultConfig , new TestHelper . ExpectedCountCallback ( 1 ) ) ; <nl> + realmA . close ( ) ; <nl> + RealmCache . invokeWithGlobalRefCount ( defaultConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void releaseCacheInOneThread ( ) { <nl> + / / Test release typed Realm instance <nl> + Realm realmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; <nl> + Realm realmB = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; <nl> + RealmCache . release ( realmA ) ; <nl> + assertNotNull ( realmA . sharedGroupManager ) ; <nl> + RealmCache . release ( realmB ) ; <nl> + assertNull ( realmB . sharedGroupManager ) ; <nl> + / / No crash but warning in the log <nl> + RealmCache . release ( realmB ) ; <nl> + <nl> + / / Test release dynamic Realm instance <nl> + DynamicRealm dynamicRealmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , <nl> + DynamicRealm . class ) ; <nl> + DynamicRealm dynamicRealmB = RealmCache . createRealmOrGetFromCache ( defaultConfig , <nl> + DynamicRealm . class ) ; <nl> + RealmCache . release ( dynamicRealmA ) ; <nl> + assertNotNull ( dynamicRealmA . sharedGroupManager ) ; <nl> + RealmCache . release ( dynamicRealmB ) ; <nl> + assertNull ( dynamicRealmB . sharedGroupManager ) ; <nl> + / / No crash but warning in the log <nl> + RealmCache . release ( dynamicRealmB ) ; <nl> + <nl> + / / Test both typed Realm and dynamic Realm in same thread <nl> + realmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; <nl> + dynamicRealmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , DynamicRealm . class ) ; <nl> + RealmCache . release ( realmA ) ; <nl> + assertNull ( realmA . sharedGroupManager ) ; <nl> + RealmCache . release ( dynamicRealmA ) ; <nl> + assertNull ( realmA . sharedGroupManager ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmMigrationTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmMigrationTests . java <nl> index c882a00 . . fa9a208 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmMigrationTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmMigrationTests . java <nl> @ @ - 16 , 7 + 16 , 15 @ @ <nl> <nl> package io . realm ; <nl> <nl> - import android . test . AndroidTestCase ; <nl> + import android . content . Context ; <nl> + import android . support . test . InstrumentationRegistry ; <nl> + import android . support . test . runner . AndroidJUnit4 ; <nl> + <nl> + import org . junit . After ; <nl> + import org . junit . Before ; <nl> + import org . junit . Rule ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> @ @ - 30 , 24 + 38 , 38 @ @ import io . realm . entities . PrimaryKeyAsString ; <nl> import io . realm . entities . StringOnly ; <nl> import io . realm . exceptions . RealmMigrationNeededException ; <nl> import io . realm . internal . Table ; <nl> + import io . realm . rule . TestRealmConfigurationFactory ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + import static org . junit . Assert . fail ; <nl> + <nl> + @ RunWith ( AndroidJUnit4 . class ) <nl> + public class RealmMigrationTests { <nl> <nl> - public class RealmMigrationTests extends AndroidTestCase { <nl> + @ Rule <nl> + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; <nl> <nl> - public Realm realm ; <nl> + private Realm realm ; <nl> + private Context context ; <nl> <nl> - @ Override <nl> - protected void tearDown ( ) throws Exception { <nl> - super . tearDown ( ) ; <nl> + @ Before <nl> + public void setup ( ) { <nl> + context = InstrumentationRegistry . getInstrumentation ( ) . getContext ( ) ; <nl> + } <nl> + <nl> + @ After <nl> + public void tearDown ( ) { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> } <nl> <nl> - public void testRealmClosedAfterMigrationException ( ) throws IOException { <nl> + @ Test <nl> + public void getInstance _ realmClosedAfterMigrationException ( ) throws IOException { <nl> String REALM _ NAME = " default0 . realm " ; <nl> - RealmConfiguration realmConfig = TestHelper . createConfiguration ( getContext ( ) , REALM _ NAME ) ; <nl> - Realm . deleteRealm ( realmConfig ) ; <nl> - TestHelper . copyRealmFromAssets ( getContext ( ) , REALM _ NAME , REALM _ NAME ) ; <nl> + RealmConfiguration realmConfig = configFactory . createConfiguration ( REALM _ NAME ) ; <nl> + configFactory . copyRealmFromAssets ( context , REALM _ NAME , REALM _ NAME ) ; <nl> try { <nl> Realm . getInstance ( realmConfig ) ; <nl> fail ( " A migration should be triggered " ) ; <nl> @ @ - 64 , 19 + 86 , 19 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> <nl> / / If a migration creates a different ordering of columns on Realm A , while another ordering is generated by <nl> / / creating a new Realm B . Global column indices will not work . They must be calculated for each Realm . <nl> - public void testLocalColumnIndices ( ) throws IOException { <nl> + @ Test <nl> + public void localColumnIndices ( ) throws IOException { <nl> String MIGRATED _ REALM = " migrated . realm " ; <nl> String NEW _ REALM = " new . realm " ; <nl> <nl> / / Migrate old Realm to proper schema <nl> <nl> / / V1 config <nl> - RealmConfiguration v1Config = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration v1Config = configFactory . createConfigurationBuilder ( ) <nl> . name ( MIGRATED _ REALM ) <nl> . schema ( AllTypes . class ) <nl> . schemaVersion ( 1 ) <nl> . build ( ) ; <nl> - Realm . deleteRealm ( v1Config ) ; <nl> Realm oldRealm = Realm . getInstance ( v1Config ) ; <nl> oldRealm . close ( ) ; <nl> <nl> @ @ - 91 , 7 + 113 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } <nl> } ; <nl> <nl> - RealmConfiguration v2Config = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration v2Config = configFactory . createConfigurationBuilder ( ) <nl> . name ( MIGRATED _ REALM ) <nl> . schema ( AllTypes . class , FieldOrder . class ) <nl> . schemaVersion ( 2 ) <nl> @ @ - 101 , 12 + 123 , 11 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> <nl> / / Create new Realm which will cause column indices to be recalculated based on the order in the java file <nl> / / instead of the migration <nl> - RealmConfiguration newConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration newConfig = configFactory . createConfigurationBuilder ( ) <nl> . name ( NEW _ REALM ) <nl> . schemaVersion ( 2 ) <nl> . schema ( AllTypes . class , FieldOrder . class ) <nl> . build ( ) ; <nl> - Realm . deleteRealm ( newConfig ) ; <nl> Realm newRealm = Realm . getInstance ( newConfig ) ; <nl> newRealm . close ( ) ; <nl> <nl> @ @ - 115 , 11 + 136 , 13 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> oldRealm . close ( ) ; <nl> } <nl> <nl> - public void testNotSettingIndexThrows ( ) { <nl> + @ Test <nl> + public void notSettingIndexThrows ( ) { <nl> <nl> / / Create v0 of the Realm <nl> - RealmConfiguration originalConfig = new RealmConfiguration . Builder ( getContext ( ) ) . schema ( AllTypes . class ) . build ( ) ; <nl> - Realm . deleteRealm ( originalConfig ) ; <nl> + RealmConfiguration originalConfig = configFactory . createConfigurationBuilder ( ) <nl> + . schema ( AllTypes . class ) <nl> + . build ( ) ; <nl> Realm . getInstance ( originalConfig ) . close ( ) ; <nl> <nl> / / Create v1 of the Realm <nl> @ @ - 134 , 7 + 157 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } <nl> } ; <nl> <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schemaVersion ( 1 ) <nl> . schema ( AllTypes . class , AnnotationTypes . class ) <nl> . migration ( migration ) <nl> @ @ - 146 , 16 + 169 , 17 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } finally { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> - Realm . deleteRealm ( realmConfig ) ; <nl> } <nl> } <nl> } <nl> <nl> - public void testNotSettingPrimaryKeyThrows ( ) { <nl> + @ Test <nl> + public void notSettingPrimaryKeyThrows ( ) { <nl> <nl> / / Create v0 of the Realm <nl> - RealmConfiguration originalConfig = new RealmConfiguration . Builder ( getContext ( ) ) . schema ( AllTypes . class ) . build ( ) ; <nl> - Realm . deleteRealm ( originalConfig ) ; <nl> + RealmConfiguration originalConfig = configFactory . createConfigurationBuilder ( ) <nl> + . schema ( AllTypes . class ) <nl> + . build ( ) ; <nl> Realm . getInstance ( originalConfig ) . close ( ) ; <nl> <nl> RealmMigration migration = new RealmMigration ( ) { <nl> @ @ - 170 , 7 + 194 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } ; <nl> <nl> / / Create v1 of the Realm <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schemaVersion ( 1 ) <nl> . schema ( AllTypes . class , AnnotationTypes . class ) <nl> . migration ( migration ) <nl> @ @ - 185 , 13 + 209 , 13 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } finally { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> - Realm . deleteRealm ( realmConfig ) ; <nl> } <nl> } <nl> } <nl> <nl> / / adding search index is idempotent <nl> - public void testAddingSearchIndexTwice ( ) throws IOException { <nl> + @ Test <nl> + public void addingSearchIndexTwice ( ) throws IOException { <nl> Class [ ] classes = { PrimaryKeyAsLong . class , PrimaryKeyAsString . class } ; <nl> <nl> for ( final Class clazz : classes ) { <nl> @ @ - 210 , 13 + 234 , 14 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> didMigrate [ 0 ] = true ; <nl> } <nl> } ; <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schemaVersion ( 42 ) <nl> . schema ( clazz ) <nl> . migration ( migration ) <nl> . build ( ) ; <nl> Realm . deleteRealm ( realmConfig ) ; <nl> - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> + configFactory . copyRealmFromAssets ( context , <nl> + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> Realm . migrateRealm ( realmConfig ) ; <nl> realm = Realm . getInstance ( realmConfig ) ; <nl> assertEquals ( 42 , realm . getVersion ( ) ) ; <nl> @ @ - 227 , 11 + 252 , 13 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } <nl> } <nl> <nl> - public void testSetAnnotations ( ) { <nl> + @ Test <nl> + public void setAnnotations ( ) { <nl> <nl> / / Create v0 of the Realm <nl> - RealmConfiguration originalConfig = new RealmConfiguration . Builder ( getContext ( ) ) . schema ( AllTypes . class ) . build ( ) ; <nl> - Realm . deleteRealm ( originalConfig ) ; <nl> + RealmConfiguration originalConfig = configFactory . createConfigurationBuilder ( ) <nl> + . schema ( AllTypes . class ) <nl> + . build ( ) ; <nl> Realm . getInstance ( originalConfig ) . close ( ) ; <nl> <nl> RealmMigration migration = new RealmMigration ( ) { <nl> @ @ - 245 , 7 + 272 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } <nl> } ; <nl> <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schemaVersion ( 1 ) <nl> . schema ( AllTypes . class , AnnotationTypes . class ) <nl> . migration ( migration ) <nl> @ @ - 259 , 11 + 286 , 12 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> assertTrue ( table . hasSearchIndex ( table . getColumnIndex ( " indexString " ) ) ) ; <nl> } <nl> <nl> - public void testGetPathFromMigrationException ( ) throws IOException { <nl> - TestHelper . copyRealmFromAssets ( getContext ( ) , " default0 . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> - File realm = new File ( getContext ( ) . getFilesDir ( ) , Realm . DEFAULT _ REALM _ NAME ) ; <nl> + @ Test <nl> + public void migrationException _ getPath ( ) throws IOException { <nl> + configFactory . copyRealmFromAssets ( context , " default0 . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> + File realm = new File ( configFactory . getRoot ( ) , Realm . DEFAULT _ REALM _ NAME ) ; <nl> try { <nl> - Realm . getInstance ( getContext ( ) ) ; <nl> + Realm . getInstance ( configFactory . createConfiguration ( ) ) ; <nl> fail ( ) ; <nl> } catch ( RealmMigrationNeededException expected ) { <nl> assertEquals ( expected . getPath ( ) , realm . getCanonicalPath ( ) ) ; <nl> @ @ - 272 , 10 + 300 , 12 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> <nl> / / In default - before - migration . realm , CatOwner has a RealmList < Dog > field . <nl> / / This is changed to RealmList < Cat > and getInstance ( ) must throw an exception . <nl> - public void testRealmListChanged ( ) throws IOException { <nl> - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> + @ Test <nl> + public void migrationException _ realmListChanged ( ) throws IOException { <nl> + configFactory . copyRealmFromAssets ( context , <nl> + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> try { <nl> - realm = Realm . getInstance ( getContext ( ) ) ; <nl> + realm = Realm . getInstance ( configFactory . createConfiguration ( ) ) ; <nl> fail ( ) ; <nl> } catch ( RealmMigrationNeededException expected ) { <nl> } <nl> @ @ - 284 , 8 + 314 , 10 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> / / Pre - null Realms will leave columns not - nullable after the underlying storage engine has <nl> / / migrated the file format . But @ Required must be added , and forgetting so will give you <nl> / / a RealmMigrationNeeded exception . <nl> - public void testOpenPreNullRealmRequiredMissing ( ) throws IOException { <nl> - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> + @ Test <nl> + public void openPreNullRealmRequiredMissing ( ) throws IOException { <nl> + configFactory . copyRealmFromAssets ( context , <nl> + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> RealmMigration realmMigration = new RealmMigration ( ) { <nl> @ Override <nl> public void migrate ( DynamicRealm realm , long oldVersion , long newVersion ) { <nl> @ @ - 294 , 7 + 326 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } ; <nl> <nl> try { <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schemaVersion ( 0 ) <nl> . schema ( StringOnly . class ) <nl> . migration ( realmMigration ) <nl> @ @ - 311 , 8 + 343 , 10 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> / / Pre - null Realms will leave columns not - nullable after the underlying storage engine has <nl> / / migrated the file format . An explicit migration step to convert to nullable , and the <nl> / / old class ( without @ Required ) can be used , <nl> - public void testMigratePreNull ( ) throws IOException { <nl> - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> + @ Test <nl> + public void migratePreNull ( ) throws IOException { <nl> + configFactory . copyRealmFromAssets ( context , <nl> + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> RealmMigration migration = new RealmMigration ( ) { <nl> @ Override <nl> public void migrate ( DynamicRealm realm , long oldVersion , long newVersion ) { <nl> @ @ - 321 , 7 + 355 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } <nl> } ; <nl> <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schemaVersion ( 1 ) <nl> . schema ( StringOnly . class ) <nl> . migration ( migration ) <nl> @ @ - 337 , 9 + 371 , 11 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> / / Pre - null Realms will leave columns not - nullable after the underlying storage engine has <nl> / / migrated the file format . If the user adds the @ Required annotation to a field and does not <nl> / / change the schema version , no migration is needed . But then , null cannot be used as a value . <nl> - public void testOpenPreNullWithRequired ( ) throws IOException { <nl> - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + @ Test <nl> + public void openPreNullWithRequired ( ) throws IOException { <nl> + configFactory . copyRealmFromAssets ( context , <nl> + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schemaVersion ( 0 ) <nl> . schema ( AllTypes . class ) <nl> . build ( ) ; <nl> @ @ - 358 , 7 + 394 , 8 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } <nl> <nl> / / If a required field was nullable before , a RealmMigrationNeededException should be thrown <nl> - public void testNotSettingRequiredForNotNullableThrows ( ) { <nl> + @ Test <nl> + public void notSettingRequiredForNotNullableThrows ( ) { <nl> String [ ] notNullableFields = { " fieldStringNotNull " , " fieldBytesNotNull " , " fieldBooleanNotNull " , <nl> " fieldByteNotNull " , " fieldShortNotNull " , " fieldIntegerNotNull " , " fieldLongNotNull " , <nl> " fieldFloatNotNull " , " fieldDoubleNotNull " , " fieldDateNotNull " } ; <nl> @ @ - 400 , 7 + 437 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } ; <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schemaVersion ( 1 ) <nl> . schema ( NullTypes . class ) <nl> . migration ( migration ) <nl> @ @ - 421 , 7 + 458 , 8 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } <nl> <nl> / / If a field is not required but was not nullable before , a RealmMigrationNeededException should be thrown <nl> - public void testSettingRequiredForNullableThrows ( ) { <nl> + @ Test <nl> + public void settingRequiredForNullableThrows ( ) { <nl> String [ ] notNullableFields = { " fieldStringNull " , " fieldBytesNull " , " fieldBooleanNull " , <nl> " fieldByteNull " , " fieldShortNull " , " fieldIntegerNull " , " fieldLongNull " , <nl> " fieldFloatNull " , " fieldDoubleNull " , " fieldDateNull " } ; <nl> @ @ - 462 , 7 + 500 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } ; <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) <nl> + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) <nl> . schemaVersion ( 1 ) <nl> . schema ( NullTypes . class ) <nl> . migration ( migration ) <nl> @ @ - 487 , 9 + 525 , 9 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> } <nl> } <nl> <nl> - public void testRealmOpenBeforeMigrationThrows ( ) { <nl> - RealmConfiguration config = TestHelper . createConfiguration ( getContext ( ) ) ; <nl> - Realm . deleteRealm ( config ) ; <nl> + @ Test <nl> + public void realmOpenBeforeMigrationThrows ( ) { <nl> + RealmConfiguration config = configFactory . createConfiguration ( ) ; <nl> realm = Realm . getInstance ( config ) ; <nl> <nl> try { <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java <nl> index 86d949f . . 0f513bd 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java <nl> @ @ - 2801 , 25 + 2801 , 4 @ @ public class RealmTests { <nl> assertEquals ( 0 , realm . where ( Cat . class ) . count ( ) ) ; <nl> assertTrue ( realm . isEmpty ( ) ) ; <nl> } <nl> - <nl> - / / When there is a transaction holding by a typed Realm in one thread , getInstance from the <nl> - / / other thread should not be blocked since we have cached the schemas already . <nl> - @ Test <nl> - public void getInstance _ shouldNotBeBlockedByTransactionInAnotherThread ( ) <nl> - throws InterruptedException { <nl> - final CountDownLatch latch = new CountDownLatch ( 1 ) ; <nl> - realm . beginTransaction ( ) ; <nl> - <nl> - Thread thread = new Thread ( new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - Realm realm = Realm . getInstance ( realmConfig ) ; <nl> - realm . close ( ) ; <nl> - latch . countDown ( ) ; <nl> - } <nl> - } ) ; <nl> - thread . start ( ) ; <nl> - TestHelper . awaitOrFail ( latch ) ; <nl> - realm . cancelTransaction ( ) ; <nl> - } <nl> } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java b / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java <nl> index 6bc2097 . . 8837c97 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java <nl> @ @ - 16 , 10 + 16 , 17 @ @ <nl> <nl> package io . realm . rule ; <nl> <nl> + import android . content . Context ; <nl> + import android . content . res . AssetManager ; <nl> + <nl> import org . junit . rules . TemporaryFolder ; <nl> import org . junit . runner . Description ; <nl> import org . junit . runners . model . Statement ; <nl> <nl> + import java . io . File ; <nl> + import java . io . FileOutputStream ; <nl> + import java . io . IOException ; <nl> + import java . io . InputStream ; <nl> import java . util . Collections ; <nl> import java . util . Map ; <nl> import java . util . Set ; <nl> @ @ - 109 , 4 + 116 , 20 @ @ public class TestRealmConfigurationFactory extends TemporaryFolder { <nl> public RealmConfiguration . Builder createConfigurationBuilder ( ) { <nl> return new RealmConfiguration . Builder ( getRoot ( ) ) ; <nl> } <nl> + <nl> + / / Copies a Realm file from assets to temp dir <nl> + public void copyRealmFromAssets ( Context context , String realmPath , String newName ) <nl> + throws IOException { <nl> + AssetManager assetManager = context . getAssets ( ) ; <nl> + InputStream is = assetManager . open ( realmPath ) ; <nl> + File file = new File ( getRoot ( ) , newName ) ; <nl> + FileOutputStream outputStream = new FileOutputStream ( file ) ; <nl> + byte [ ] buf = new byte [ 1024 ] ; <nl> + int bytesRead ; <nl> + while ( ( bytesRead = is . read ( buf ) ) > - 1 ) { <nl> + outputStream . write ( buf , 0 , bytesRead ) ; <nl> + } <nl> + outputStream . close ( ) ; <nl> + is . close ( ) ; <nl> + } <nl> }

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java 
 index ebbc63e . . f0d7f4a 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java 
 @ @ - 25 , 6 + 25 , 8 @ @ import org . junit . Test ; 
 import org . junit . rules . ExpectedException ; 
 import org . junit . runner . RunWith ; 
 
 + import org . junit . Test ; 
 + 
 import java . text . ParseException ; 
 import java . util . Arrays ; 
 import java . util . Date ; 
 @ @ - 475 , 9 + 477 , 20 @ @ public class DynamicRealmObjectTests { 
 / / List is not a simple getter , test separately . 
 @ Test 
 public void getList ( ) { 
 - RealmList < DynamicRealmObject > list = dObj . getList ( AllJavaTypes . FIELD _ LIST ) ; 
 + realm . beginTransaction ( ) ; 
 + AllTypes obj = realm . createObject ( AllTypes . class ) ; 
 + Dog dog = realm . createObject ( Dog . class ) ; 
 + dog . setName ( " fido " ) ; 
 + obj . getColumnRealmList ( ) . add ( dog ) ; 
 + realm . commitTransaction ( ) ; 
 + 
 + DynamicRealmObject dynamicAllTypes = new DynamicRealmObject ( obj ) ; 
 + RealmList < DynamicRealmObject > list = dynamicAllTypes . getList ( AllTypes . FIELD _ REALMLIST ) ; 
 + DynamicRealmObject listObject = list . get ( 0 ) ; 
 + 
 assertEquals ( 1 , list . size ( ) ) ; 
 - assertEquals ( dObj , list . get ( 0 ) ) ; 
 + assertEquals ( Dog . CLASS _ NAME , listObject . getType ( ) ) ; 
 + assertEquals ( " fido " , listObject . getString ( Dog . FIELD _ NAME ) ) ; 
 } 
 
 @ Test 
 @ @ - 748 , 4 + 761 , 19 @ @ public class DynamicRealmObjectTests { 
 assertTrue ( str . startsWith ( " class _ AllJavaTypes = [ " ) ) ; 
 assertTrue ( str . endsWith ( " } ] " ) ) ; 
 } 
 + 
 + public void testExceptionMessage ( ) { 
 + / / test for https : / / github . com / realm / realm - java / issues / 2141 
 + realm . beginTransaction ( ) ; 
 + AllTypes obj = realm . createObject ( AllTypes . class ) ; 
 + realm . commitTransaction ( ) ; 
 + 
 + DynamicRealmObject o = new DynamicRealmObject ( obj ) ; 
 + try { 
 + o . getFloat ( " nonExisting " ) ; / / Note that " o " does not have " nonExisting " field . 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException e ) { 
 + assertEquals ( " Illegal Argument : Field not found : nonExisting " , e . getMessage ( ) ) ; 
 + } 
 + } 
 } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / NotificationsTest . java b / realm / realm - library / src / androidTest / java / io / realm / NotificationsTest . java 
 index 8290024 . . 313ceae 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / NotificationsTest . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / NotificationsTest . java 
 @ @ - 16 , 11 + 16 , 9 @ @ 
 
 package io . realm ; 
 
 - import android . content . Context ; 
 import android . os . Handler ; 
 import android . os . HandlerThread ; 
 import android . os . Looper ; 
 - import android . support . test . InstrumentationRegistry ; 
 import android . support . test . annotation . UiThreadTest ; 
 import android . support . test . rule . UiThreadTestRule ; 
 import android . support . test . runner . AndroidJUnit4 ; 
 @ @ - 52 , 6 + 50 , 7 @ @ import io . realm . entities . AllTypes ; 
 import io . realm . entities . Dog ; 
 import io . realm . internal . log . Logger ; 
 import io . realm . internal . log . RealmLog ; 
 + import io . realm . rule . TestRealmConfigurationFactory ; 
 
 import static org . junit . Assert . assertEquals ; 
 import static org . junit . Assert . assertFalse ; 
 @ @ - 63 , 34 + 62 , 33 @ @ import static org . junit . Assert . fail ; 
 @ RunWith ( AndroidJUnit4 . class ) 
 public class NotificationsTest { 
 
 - private Realm realm ; 
 @ Rule 
 public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule ( ) ; 
 - private Context context ; 
 + @ Rule 
 + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; 
 
 - @ Before 
 - public void setUp ( ) throws Exception { 
 - / / Injecting the Instrumentation instance is required 
 - / / for your test to run with AndroidJUnitRunner . 
 - context = InstrumentationRegistry . getInstrumentation ( ) . getContext ( ) ; 
 + private Realm realm ; 
 + private RealmConfiguration realmConfig ; 
 
 - Realm . deleteRealm ( TestHelper . createConfiguration ( context ) ) ; 
 + @ Before 
 + public void setUp ( ) { 
 + realmConfig = configFactory . createConfiguration ( ) ; 
 } 
 
 @ After 
 - public void tearDown ( ) throws Exception { 
 + public void tearDown ( ) { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 } 
 
 @ Test 
 - public void testFailingSetAutoRefreshOnNonLooperThread ( ) throws ExecutionException , InterruptedException { 
 + public void failingSetAutoRefreshOnNonLooperThread ( ) throws ExecutionException , InterruptedException { 
 ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 @ Override 
 public Boolean call ( ) throws Exception { 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 boolean autoRefresh = realm . isAutoRefresh ( ) ; 
 assertFalse ( autoRefresh ) ; 
 try { 
 @ @ - 105 , 18 + 103 , 17 @ @ public class NotificationsTest { 
 } ) ; 
 
 assertTrue ( future . get ( ) ) ; 
 - RealmCache . invokeWithGlobalRefCount ( new RealmConfiguration . Builder ( context ) . build ( ) , 
 - new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 + RealmCache . invokeWithGlobalRefCount ( realmConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 } 
 
 @ Test 
 - public void testSetAutoRefreshOnHandlerThread ( ) throws ExecutionException , InterruptedException { 
 + public void setAutoRefresh _ onHandlerThread ( ) throws ExecutionException , InterruptedException { 
 ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 @ Override 
 public Boolean call ( ) throws Exception { 
 Looper . prepare ( ) ; 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 assertTrue ( realm . isAutoRefresh ( ) ) ; 
 realm . setAutoRefresh ( false ) ; 
 assertFalse ( realm . isAutoRefresh ( ) ) ; 
 @ @ - 126 , 14 + 123 , 14 @ @ public class NotificationsTest { 
 return true ; 
 } 
 } ) ; 
 + 
 assertTrue ( future . get ( ) ) ; 
 - RealmCache . invokeWithGlobalRefCount ( new RealmConfiguration . Builder ( context ) . build ( ) , 
 - new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 + RealmCache . invokeWithGlobalRefCount ( realmConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 } 
 
 @ Test 
 @ UiThreadTest 
 - public void testRemoveNotifications ( ) throws InterruptedException , ExecutionException { 
 + public void removeChangeListener ( ) throws InterruptedException , ExecutionException { 
 final AtomicInteger counter = new AtomicInteger ( 0 ) ; 
 RealmChangeListener listener = new RealmChangeListener ( ) { 
 @ Override 
 @ @ - 142 , 7 + 139 , 7 @ @ public class NotificationsTest { 
 } 
 } ; 
 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 realm . addChangeListener ( listener ) ; 
 realm . removeChangeListener ( listener ) ; 
 
 @ @ - 155 , 7 + 152 , 7 @ @ public class NotificationsTest { 
 
 @ Test 
 @ UiThreadTest 
 - public void testAddDuplicatedListener ( ) { 
 + public void addChangeListener _ duplicatedListener ( ) { 
 final AtomicInteger counter = new AtomicInteger ( 0 ) ; 
 RealmChangeListener listener = new RealmChangeListener ( ) { 
 @ Override 
 @ @ - 164 , 7 + 161 , 7 @ @ public class NotificationsTest { 
 } 
 } ; 
 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 realm . addChangeListener ( listener ) ; 
 realm . addChangeListener ( listener ) ; 
 
 @ @ - 176 , 7 + 173 , 7 @ @ public class NotificationsTest { 
 } 
 
 @ Test 
 - public void testNotificationsNumber ( ) throws InterruptedException , ExecutionException { 
 + public void notificationsNumber ( ) throws InterruptedException , ExecutionException { 
 final AtomicInteger counter = new AtomicInteger ( 0 ) ; 
 final AtomicBoolean isReady = new AtomicBoolean ( false ) ; 
 final Looper [ ] looper = new Looper [ 1 ] ; 
 @ @ - 196 , 7 + 193 , 7 @ @ public class NotificationsTest { 
 try { 
 Looper . prepare ( ) ; 
 looper [ 0 ] = Looper . myLooper ( ) ; 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 realm . addChangeListener ( listener ) ; 
 isReady . set ( true ) ; 
 Looper . loop ( ) ; 
 @ @ - 217 , 7 + 214 , 7 @ @ public class NotificationsTest { 
 Thread . sleep ( 100 ) ; 
 
 / / Trigger OnRealmChanged on background thread 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 realm . beginTransaction ( ) ; 
 Dog dog = realm . createObject ( Dog . class ) ; 
 dog . setName ( " Rex " ) ; 
 @ @ - 237 , 12 + 234 , 11 @ @ public class NotificationsTest { 
 } 
 
 assertEquals ( 1 , counter . get ( ) ) ; 
 - RealmCache . invokeWithGlobalRefCount ( new RealmConfiguration . Builder ( context ) . build ( ) , 
 - new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 + RealmCache . invokeWithGlobalRefCount ( realmConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 } 
 
 @ Test 
 - public void testAutoUpdateRealmResults ( ) throws InterruptedException , ExecutionException { 
 + public void autoUpdateRealmResults ( ) throws InterruptedException , ExecutionException { 
 final int TEST _ SIZE = 10 ; 
 final AtomicInteger counter = new AtomicInteger ( 0 ) ; 
 final AtomicBoolean isReady = new AtomicBoolean ( false ) ; 
 @ @ - 260 , 7 + 256 , 7 @ @ public class NotificationsTest { 
 looper [ 0 ] = Looper . myLooper ( ) ; 
 Realm realm = null ; 
 try { 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 final RealmResults < Dog > dogs = realm . allObjects ( Dog . class ) ; 
 assertEquals ( 0 , dogs . size ( ) ) ; 
 listener [ 0 ] = new RealmChangeListener ( ) { 
 @ @ - 289 , 7 + 285 , 7 @ @ public class NotificationsTest { 
 } 
 Thread . sleep ( 100 ) ; 
 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 realm . beginTransaction ( ) ; 
 for ( int i = 0 ; i < TEST _ SIZE ; i + + ) { 
 Dog dog = realm . createObject ( Dog . class ) ; 
 @ @ - 317 , 12 + 313 , 11 @ @ public class NotificationsTest { 
 assertEquals ( TEST _ SIZE , results . get ( 1 ) . intValue ( ) ) ; 
 
 assertEquals ( 1 , counter . get ( ) ) ; 
 - RealmCache . invokeWithGlobalRefCount ( new RealmConfiguration . Builder ( context ) . build ( ) , 
 - new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 + RealmCache . invokeWithGlobalRefCount ( realmConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 } 
 
 - / / TODO Disabled until we can figure out why this times out so often on the build server 
 - public void DISABLEDtestCloseClearingHandlerMessages ( ) throws InterruptedException , TimeoutException , ExecutionException { 
 + @ Test 
 + public void closeClearingHandlerMessages ( ) throws InterruptedException , TimeoutException , ExecutionException { 
 final int TEST _ SIZE = 10 ; 
 final CountDownLatch backgroundLooperStarted = new CountDownLatch ( 1 ) ; 
 final CountDownLatch addHandlerMessages = new CountDownLatch ( 1 ) ; 
 @ @ - 332 , 7 + 327 , 7 @ @ public class NotificationsTest { 
 @ Override 
 public Boolean call ( ) throws Exception { 
 Looper . prepare ( ) ; / / Fake background thread with a looper , eg . a IntentService 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 backgroundLooperStarted . countDown ( ) ; 
 
 / / Random operation in the client code 
 @ @ - 355 , 7 + 350 , 7 @ @ public class NotificationsTest { 
 threadHandler . post ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 - Looper . myLooper ( ) . quit ( ) ; 
 + TestHelper . quitLooperOrFail ( ) ; 
 } 
 } ) ; 
 
 @ @ - 372 , 7 + 367 , 7 @ @ public class NotificationsTest { 
 backgroundLooperStarted . await ( 1 , TimeUnit . SECONDS ) ; 
 
 / / Execute a transaction that will trigger a Realm update 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 realm . beginTransaction ( ) ; 
 for ( int i = 0 ; i < TEST _ SIZE ; i + + ) { 
 Dog dog = realm . createObject ( Dog . class ) ; 
 @ @ - 392 , 8 + 387 , 8 @ @ public class NotificationsTest { 
 
 @ Test 
 @ UiThreadTest 
 - public void testHandlerNotRemovedToSoon ( ) { 
 - RealmConfiguration realmConfig = TestHelper . createConfiguration ( context , " private - realm " ) ; 
 + public void handlerNotRemovedToSoon ( ) { 
 + RealmConfiguration realmConfig = configFactory . createConfiguration ( " private - realm " ) ; 
 Realm . deleteRealm ( realmConfig ) ; 
 Realm instance1 = Realm . getInstance ( realmConfig ) ; 
 Realm instance2 = Realm . getInstance ( realmConfig ) ; 
 @ @ - 410 , 10 + 405 , 10 @ @ public class NotificationsTest { 
 
 @ Test 
 @ UiThreadTest 
 - public void testImmediateNotificationsOnSameThread ( ) { 
 + public void immediateNotificationsOnSameThread ( ) { 
 final AtomicBoolean success = new AtomicBoolean ( false ) ; 
 final RealmChangeListener listener [ ] = new RealmChangeListener [ 1 ] ; 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 listener [ 0 ] = new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 @ @ - 431 , 7 + 426 , 7 @ @ public class NotificationsTest { 
 
 @ Test 
 @ UiThreadTest 
 - public void testEmptyCommitTriggerChangeListener ( ) { 
 + public void emptyCommitTriggerChangeListener ( ) { 
 final AtomicBoolean success = new AtomicBoolean ( false ) ; 
 final RealmChangeListener listener = new RealmChangeListener ( ) { 
 @ Override 
 @ @ - 439 , 7 + 434 , 7 @ @ public class NotificationsTest { 
 success . set ( true ) ; 
 } 
 } ; 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 realm . addChangeListener ( listener ) ; 
 realm . beginTransaction ( ) ; 
 realm . commitTransaction ( ) ; 
 @ @ - 448 , 7 + 443 , 7 @ @ public class NotificationsTest { 
 
 @ Test 
 @ UiThreadTest 
 - public void testAddRemoveListenerConcurrency ( ) { 
 + public void addRemoveListenerConcurrency ( ) { 
 final AtomicInteger counter1 = new AtomicInteger ( 0 ) ; 
 final AtomicInteger counter2 = new AtomicInteger ( 0 ) ; 
 final AtomicInteger counter3 = new AtomicInteger ( 0 ) ; 
 @ @ - 482 , 7 + 477 , 7 @ @ public class NotificationsTest { 
 } 
 } ; 
 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 realm . addChangeListener ( listener2 ) ; 
 realm . addChangeListener ( listener3 ) ; 
 
 @ @ - 513 , 9 + 508 , 9 @ @ public class NotificationsTest { 
 
 @ Test 
 @ UiThreadTest 
 - public void testWeakReferenceListener ( ) throws InterruptedException { 
 + public void weakReferenceListener ( ) throws InterruptedException { 
 final AtomicInteger counter = new AtomicInteger ( 0 ) ; 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 RealmChangeListener listener = new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 @ @ - 544 , 9 + 539 , 9 @ @ public class NotificationsTest { 
 / / without throwing an exception . 
 @ Test 
 @ UiThreadTest 
 - public void testRemovingWeakReferenceListener ( ) throws InterruptedException { 
 + public void removingWeakReferenceListener ( ) throws InterruptedException { 
 final AtomicInteger counter = new AtomicInteger ( 0 ) ; 
 - realm = Realm . getInstance ( context ) ; 
 + realm = Realm . getInstance ( realmConfig ) ; 
 RealmChangeListener listenerA = new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 @ @ - 581 , 11 + 576 , 8 @ @ public class NotificationsTest { 
 / / Tests that if the same configuration is used on 2 different Looper threads that each gets its own Handler . This 
 / / prevents commitTransaction from accidentally posting messages to Handlers which might reference a closed Realm . 
 @ Test 
 - public void testDoNotUseClosedHandler ( ) throws InterruptedException { 
 - final RealmConfiguration realmConfiguration = TestHelper . createConfiguration ( context ) ; 
 + public void doNotUseClosedHandler ( ) throws InterruptedException { 
 final AssertionFailedError [ ] threadAssertionError = new AssertionFailedError [ 1 ] ; / / Keep track of errors in test threads . 
 - Realm . deleteRealm ( realmConfiguration ) ; 
 - 
 final CountDownLatch handlerNotified = new CountDownLatch ( 1 ) ; 
 final CountDownLatch backgroundThreadClosed = new CountDownLatch ( 1 ) ; 
 
 @ @ - 595 , 7 + 587 , 7 @ @ public class NotificationsTest { 
 @ Override 
 public void run ( ) { 
 Looper . prepare ( ) ; 
 - final Realm realm = Realm . getInstance ( realmConfiguration ) ; 
 + final Realm realm = Realm . getInstance ( realmConfig ) ; 
 RealmChangeListener listener = new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 @ @ - 613 , 7 + 605 , 7 @ @ public class NotificationsTest { 
 @ Override 
 public void run ( ) { 
 Looper . prepare ( ) ; 
 - Realm realm = Realm . getInstance ( realmConfiguration ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 RealmChangeListener listener = new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 @ @ - 635 , 7 + 627 , 7 @ @ public class NotificationsTest { 
 
 / / Any REALM _ CHANGED message should now only reach the open Handler on Thread1 
 backgroundThreadClosed . await ( ) ; 
 - Realm realm = Realm . getInstance ( realmConfiguration ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 realm . beginTransaction ( ) ; 
 realm . commitTransaction ( ) ; 
 try { 
 @ @ - 654 , 10 + 646 , 7 @ @ public class NotificationsTest { 
 / / Test that we handle a Looper thread quiting it ' s looper before it is done executing the current loop ( = Realm . close ( ) 
 / / isn ' t called yet ) . 
 @ Test 
 - public void testLooperThreadQuitsLooperEarly ( ) throws InterruptedException { 
 - RealmConfiguration config = TestHelper . createConfiguration ( context ) ; 
 - Realm . deleteRealm ( config ) ; 
 - 
 + public void looperThreadQuitsLooperEarly ( ) throws InterruptedException { 
 final CountDownLatch backgroundLooperStartedAndStopped = new CountDownLatch ( 1 ) ; 
 final CountDownLatch mainThreadCommitCompleted = new CountDownLatch ( 1 ) ; 
 final CountDownLatch backgroundThreadStopped = new CountDownLatch ( 1 ) ; 
 @ @ - 669 , 9 + 658 , 9 @ @ public class NotificationsTest { 
 public void run ( ) { 
 Looper . prepare ( ) ; / / Fake background thread with a looper , eg . a IntentService 
 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 realm . setAutoRefresh ( false ) ; 
 - Looper . myLooper ( ) . quit ( ) ; 
 + TestHelper . quitLooperOrFail ( ) ; 
 backgroundLooperStartedAndStopped . countDown ( ) ; 
 try { 
 mainThreadCommitCompleted . await ( ) ; 
 @ @ - 685 , 7 + 674 , 7 @ @ public class NotificationsTest { 
 
 / / Create a commit on another thread 
 TestHelper . awaitOrFail ( backgroundLooperStartedAndStopped ) ; 
 - Realm realm = Realm . getInstance ( config ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 Logger logger = TestHelper . getFailureLogger ( Log . WARN ) ; 
 RealmLog . add ( logger ) ; 
 
 @ @ - 699 , 7 + 688 , 7 @ @ public class NotificationsTest { 
 } 
 
 @ Test 
 - public void testHandlerThreadShouldReceiveNotification ( ) throws ExecutionException , InterruptedException { 
 + public void handlerThreadShouldReceiveNotification ( ) throws ExecutionException , InterruptedException { 
 final AssertionFailedError [ ] assertionFailedErrors = new AssertionFailedError [ 1 ] ; 
 final CountDownLatch backgroundThreadReady = new CountDownLatch ( 1 ) ; 
 final CountDownLatch numberOfInvocation = new CountDownLatch ( 1 ) ; 
 @ @ - 715 , 7 + 704 , 7 @ @ public class NotificationsTest { 
 } catch ( AssertionFailedError e ) { 
 assertionFailedErrors [ 0 ] = e ; 
 } 
 - final Realm backgroundRealm = Realm . getInstance ( context ) ; 
 + final Realm backgroundRealm = Realm . getInstance ( realmConfig ) ; 
 backgroundRealm . addChangeListener ( new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 @ @ - 729 , 7 + 718 , 7 @ @ public class NotificationsTest { 
 TestHelper . awaitOrFail ( backgroundThreadReady ) ; 
 / / At this point the background thread started & registered the listener 
 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 realm . beginTransaction ( ) ; 
 realm . createObject ( AllTypes . class ) ; 
 realm . commitTransaction ( ) ; 
 @ @ - 743 , 14 + 732 , 14 @ @ public class NotificationsTest { 
 } 
 
 @ Test 
 - public void testNonLooperThreadShouldNotifyLooperThreadAboutCommit ( ) throws Throwable { 
 + public void nonLooperThreadShouldNotifyLooperThreadAboutCommit ( ) throws Throwable { 
 final CountDownLatch mainThreadReady = new CountDownLatch ( 1 ) ; 
 final CountDownLatch numberOfInvocation = new CountDownLatch ( 1 ) ; 
 Thread thread = new Thread ( ) { 
 @ Override 
 public void run ( ) { 
 TestHelper . awaitOrFail ( mainThreadReady ) ; 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 realm . beginTransaction ( ) ; 
 realm . createObject ( AllTypes . class ) ; 
 realm . commitTransaction ( ) ; 
 @ @ - 765 , 7 + 754 , 7 @ @ public class NotificationsTest { 
 handler . post ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 - final Realm mainRealm = Realm . getInstance ( context ) ; 
 + final Realm mainRealm = Realm . getInstance ( realmConfig ) ; 
 mainRealm . addChangeListener ( new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 @ @ - 785 , 7 + 774 , 7 @ @ public class NotificationsTest { 
 / / to advance to the latest version . We make sure in this test that all Realm listeners will be notified 
 / / regardless of the presence of an async RealmResults that will delay the ` REALM _ CHANGE ` sometimes 
 @ Test 
 - public void testAsyncRealmResultsShouldNotBlockBackgroundCommitNotification ( ) throws Throwable { 
 + public void asyncRealmResultsShouldNotBlockBackgroundCommitNotification ( ) throws Throwable { 
 final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger ( 0 ) ; 
 final AtomicInteger numberOfAsyncRealmResultsCallbackInvocation = new AtomicInteger ( 0 ) ; 
 final CountDownLatch signalTestFinished = new CountDownLatch ( 2 ) ; 
 @ @ - 801 , 11 + 790 , 11 @ @ public class NotificationsTest { 
 backgroundLooper [ 0 ] = Looper . myLooper ( ) ; 
 
 try { 
 - realm [ 0 ] = Realm . getInstance ( context ) ; 
 + realm [ 0 ] = Realm . getInstance ( realmConfig ) ; 
 realm [ 0 ] . addChangeListener ( new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 - RealmResults < Dog > dogs = null ; / / to keep it as a strong reference 
 + RealmResults < Dog > dogs ; / / to keep it as a strong reference 
 switch ( numberOfRealmCallbackInvocation . incrementAndGet ( ) ) { 
 case 1 : { 
 / / first commit 
 @ @ - 821 , 7 + 810 , 7 @ @ public class NotificationsTest { 
 new Thread ( ) { 
 @ Override 
 public void run ( ) { 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 realm . beginTransaction ( ) ; 
 realm . createObject ( Dog . class ) ; 
 realm . commitTransaction ( ) ; 
 @ @ - 873 , 7 + 862 , 7 @ @ public class NotificationsTest { 
 / / to advance to the latest version . We make sure in this test that all Realm listeners will be notified 
 / / regardless of the presence of an async RealmObject that will delay the ` REALM _ CHANGE ` sometimes 
 @ Test 
 - public void testAsyncRealmObjectShouldNotBlockBackgroundCommitNotification ( ) throws Throwable { 
 + public void asyncRealmObjectShouldNotBlockBackgroundCommitNotification ( ) throws Throwable { 
 final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger ( 0 ) ; 
 final AtomicInteger numberOfAsyncRealmObjectCallbackInvocation = new AtomicInteger ( 0 ) ; 
 final CountDownLatch signalTestFinished = new CountDownLatch ( 1 ) ; 
 @ @ - 889 , 11 + 878 , 11 @ @ public class NotificationsTest { 
 backgroundLooper [ 0 ] = Looper . myLooper ( ) ; 
 
 try { 
 - realm [ 0 ] = Realm . getInstance ( context ) ; 
 + realm [ 0 ] = Realm . getInstance ( realmConfig ) ; 
 realm [ 0 ] . addChangeListener ( new RealmChangeListener ( ) { 
 @ Override 
 public void onChange ( ) { 
 - Dog dog = null ; / / to keep it as a strong reference 
 + Dog dog ; / / to keep it as a strong reference 
 switch ( numberOfRealmCallbackInvocation . incrementAndGet ( ) ) { 
 case 1 : { 
 / / first commit 
 @ @ - 909 , 7 + 898 , 7 @ @ public class NotificationsTest { 
 new Thread ( ) { 
 @ Override 
 public void run ( ) { 
 - Realm realm = Realm . getInstance ( context ) ; 
 + Realm realm = Realm . getInstance ( realmConfig ) ; 
 realm . beginTransaction ( ) ; 
 realm . createObject ( Dog . class ) ; 
 realm . commitTransaction ( ) ; 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java 
 index 898f0b7 . . 5ac41a5 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java 
 @ @ - 342 , 6 + 342 , 26 @ @ public class RealmObjectSchemaTests extends AndroidTestCase { 
 } 
 } 
 
 + public void testAddPrimaryKeyFieldModifier _ duplicateValues ( ) { 
 + for ( PrimaryKeyFieldType fieldType : PrimaryKeyFieldType . values ( ) ) { 
 + final String fieldName = " foo " ; 
 + schema . addField ( fieldName , fieldType . getType ( ) ) ; 
 + 
 + / / create multiple objects with same values . 
 + realm . createObject ( schema . getClassName ( ) ) ; 
 + realm . createObject ( schema . getClassName ( ) ) ; 
 + 
 + try { 
 + schema . addPrimaryKey ( fieldName ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException e ) { 
 + / / check if message reports correct field name . 
 + assertTrue ( e . getMessage ( ) . contains ( " \ " " + fieldName + " \ " " ) ) ; 
 + } 
 + schema . removeField ( fieldName ) ; 
 + } 
 + } 
 + 
 public void testAddIndexFieldModifier _ illegalFieldTypeThrows ( ) { 
 String fieldName = " foo " ; 
 for ( InvalidIndexFieldType fieldType : InvalidIndexFieldType . values ( ) ) { 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java 
 index 8892be9 . . 949fc32 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java 
 @ @ - 939 , 15 + 939 , 15 @ @ public class RealmResultsTests { 
 @ Test 
 public void contains _ realmObjectFromOtherRealm ( ) { 
 RealmConfiguration realmConfig = configFactory . createConfiguration ( " contains _ test . realm " ) ; 
 - Realm testRealmTwo = Realm . getInstance ( realmConfig ) ; 
 + Realm realmTwo = Realm . getInstance ( realmConfig ) ; 
 try { 
 
 - testRealmTwo . beginTransaction ( ) ; 
 - testRealmTwo . allObjects ( AllTypes . class ) . clear ( ) ; 
 - testRealmTwo . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; 
 + realmTwo . beginTransaction ( ) ; 
 + realmTwo . allObjects ( AllTypes . class ) . clear ( ) ; 
 + realmTwo . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; 
 
 for ( int i = 0 ; i < TEST _ DATA _ SIZE ; + + i ) { 
 - AllTypes allTypes = testRealmTwo . createObject ( AllTypes . class ) ; 
 + AllTypes allTypes = realmTwo . createObject ( AllTypes . class ) ; 
 allTypes . setColumnBoolean ( ( i % 2 ) = = 0 ) ; 
 allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; 
 allTypes . setColumnDate ( new Date ( YEAR _ MILLIS * ( i - TEST _ DATA _ SIZE / 2 ) ) ) ; 
 @ @ - 955 , 24 + 955 , 24 @ @ public class RealmResultsTests { 
 allTypes . setColumnFloat ( 1 . 234567f + i ) ; 
 allTypes . setColumnString ( " test data " + i ) ; 
 allTypes . setColumnLong ( i ) ; 
 - Dog d = testRealmTwo . createObject ( Dog . class ) ; 
 + Dog d = realmTwo . createObject ( Dog . class ) ; 
 d . setName ( " Foo " + i ) ; 
 allTypes . setColumnRealmObject ( d ) ; 
 allTypes . getColumnRealmList ( ) . add ( d ) ; 
 - NonLatinFieldNames nonLatinFieldNames = testRealmTwo . createObject ( NonLatinFieldNames . class ) ; 
 + NonLatinFieldNames nonLatinFieldNames = realmTwo . createObject ( NonLatinFieldNames . class ) ; 
 nonLatinFieldNames . set 델 타 ( i ) ; 
 nonLatinFieldNames . set Δ έ λ τ α ( i ) ; 
 } 
 - testRealmTwo . commitTransaction ( ) ; 
 + realmTwo . commitTransaction ( ) ; 
 
 - final AllTypes item = testRealmTwo . where ( AllTypes . class ) . findFirst ( ) ; 
 + final AllTypes item = realmTwo . where ( AllTypes . class ) . findFirst ( ) ; 
 
 assertFalse ( " Should not be able to find one object in another Realm via RealmResults # contains " , 
 realm . where ( AllTypes . class ) . findAll ( ) . contains ( item ) ) ; 
 
 } finally { 
 - if ( testRealmTwo ! = null & & ! testRealmTwo . isClosed ( ) ) { 
 - testRealmTwo . close ( ) ; 
 + if ( realmTwo ! = null & & ! realmTwo . isClosed ( ) ) { 
 + realmTwo . close ( ) ; 
 } 
 } 
 } 
 @ @ - 1424 , 4 + 1424 , 112 @ @ public class RealmResultsTests { 
 } catch ( IllegalArgumentException ignored ) { 
 } 
 } 
 + 
 + private RealmResults < Dog > populateRealmResultsOnDeletedLinkView ( ) { 
 + realm . beginTransaction ( ) ; 
 + Owner owner = realm . createObject ( Owner . class ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) { 
 + Dog dog = new Dog ( ) ; 
 + dog . setName ( " name _ " + i ) ; 
 + dog . setOwner ( owner ) ; 
 + owner . getDogs ( ) . add ( dog ) ; 
 + } 
 + realm . commitTransaction ( ) ; 
 + 
 + 
 + RealmResults < Dog > dogs = owner . getDogs ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; 
 + / / dogs = dogs . where ( ) . findFirst ( ) . getOwner ( ) . getDogs ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; 
 + 
 + realm . beginTransaction ( ) ; 
 + owner . removeFromRealm ( ) ; 
 + realm . commitTransaction ( ) ; 
 + return dogs ; 
 + } 
 + 
 + @ Test 
 + public void isValid _ resultsBuiltOnDeletedLinkView ( ) { 
 + assertEquals ( false , populateRealmResultsOnDeletedLinkView ( ) . isValid ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void size _ resultsBuiltOnDeletedLinkView ( ) { 
 + assertEquals ( 0 , populateRealmResultsOnDeletedLinkView ( ) . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void first _ resultsBuiltOnDeletedLinkView ( ) { 
 + try { 
 + populateRealmResultsOnDeletedLinkView ( ) . first ( ) ; 
 + } catch ( ArrayIndexOutOfBoundsException ignored ) { 
 + } 
 + } 
 + 
 + @ Test 
 + public void last _ resultsBuiltOnDeletedLinkView ( ) { 
 + try { 
 + populateRealmResultsOnDeletedLinkView ( ) . last ( ) ; 
 + } catch ( ArrayIndexOutOfBoundsException ignored ) { 
 + } 
 + } 
 + 
 + @ Test 
 + public void sum _ resultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + assertEquals ( 0 , dogs . sum ( Dog . FIELD _ AGE ) . intValue ( ) ) ; 
 + assertEquals ( 0f , dogs . sum ( Dog . FIELD _ HEIGHT ) . floatValue ( ) , 0f ) ; 
 + assertEquals ( 0d , dogs . sum ( Dog . FIELD _ WEIGHT ) . doubleValue ( ) , 0d ) ; 
 + } 
 + 
 + @ Test 
 + public void average _ resultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + assertEquals ( 0d , dogs . average ( Dog . FIELD _ AGE ) , 0d ) ; 
 + assertEquals ( 0d , dogs . average ( Dog . FIELD _ HEIGHT ) , 0d ) ; 
 + assertEquals ( 0d , dogs . average ( Dog . FIELD _ WEIGHT ) , 0d ) ; 
 + } 
 + 
 + @ Test 
 + public void clear _ resultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + realm . beginTransaction ( ) ; 
 + dogs . clear ( ) ; 
 + assertEquals ( 0 , dogs . size ( ) ) ; 
 + realm . commitTransaction ( ) ; 
 + } 
 + 
 + @ Test 
 + public void max _ resultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + assertNull ( dogs . max ( Dog . FIELD _ AGE ) ) ; 
 + assertNull ( dogs . max ( Dog . FIELD _ HEIGHT ) ) ; 
 + assertNull ( dogs . max ( Dog . FIELD _ WEIGHT ) ) ; 
 + } 
 + 
 + @ Test 
 + public void max _ dateResultsBuiltOnDeletedLinkView ( ) { 
 + assertEquals ( null , populateRealmResultsOnDeletedLinkView ( ) . maxDate ( Dog . FIELD _ BIRTHDAY ) ) ; 
 + } 
 + 
 + @ Test 
 + public void min _ resultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + assertNull ( dogs . min ( Dog . FIELD _ AGE ) ) ; 
 + assertNull ( dogs . min ( Dog . FIELD _ HEIGHT ) ) ; 
 + assertNull ( dogs . min ( Dog . FIELD _ WEIGHT ) ) ; 
 + } 
 + 
 + @ Test 
 + public void minDateResultsBuiltOnDeletedLinkView ( ) { 
 + assertEquals ( null , populateRealmResultsOnDeletedLinkView ( ) . minDate ( Dog . FIELD _ BIRTHDAY ) ) ; 
 + } 
 + 
 + @ Test 
 + public void whereResultsBuiltOnDeletedLinkView ( ) { 
 + try { 
 + populateRealmResultsOnDeletedLinkView ( ) . where ( ) ; 
 + fail ( ) ; 
 + } catch ( IllegalStateException e ) { 
 + assertEquals ( " The RealmList which this RealmResults is created on has been deleted . " , e . getMessage ( ) ) ; 
 + } 
 + } 
 } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java 
 index 62129bf . . c94fee0 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java 
 @ @ - 16 , 8 + 16 , 15 @ @ 
 
 package io . realm ; 
 
 - import android . test . AndroidTestCase ; 
 + import android . support . test . runner . AndroidJUnit4 ; 
 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Rule ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import java . util . ArrayList ; 
 import java . util . Arrays ; 
 import java . util . List ; 
 import java . util . Set ; 
 @ @ - 25 , 38 + 32 , 47 @ @ import java . util . Set ; 
 import io . realm . entities . AllJavaTypes ; 
 import io . realm . entities . Owner ; 
 import io . realm . internal . Util ; 
 + import io . realm . rule . TestRealmConfigurationFactory ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 + import static org . junit . Assert . assertNotNull ; 
 + import static org . junit . Assert . assertNull ; 
 + import static org . junit . Assert . assertTrue ; 
 + import static org . junit . Assert . fail ; 
 + 
 + @ RunWith ( AndroidJUnit4 . class ) 
 + public class RealmSchemaTests { 
 
 - public class RealmSchemaTests extends AndroidTestCase { 
 + @ Rule 
 + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; 
 
 - public static final String CLASS _ ALL _ JAVA _ TYPES = " AllJavaTypes " ; 
 private DynamicRealm realm ; 
 private RealmSchema realmSchema ; 
 
 - @ Override 
 - protected void setUp ( ) throws Exception { 
 - super . setUp ( ) ; 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + @ Before 
 + public void setUp ( ) { 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schema ( AllJavaTypes . class , Owner . class ) 
 . build ( ) ; 
 - Realm . deleteRealm ( realmConfig ) ; 
 Realm . getInstance ( realmConfig ) . close ( ) ; / / create Schema 
 - this . realm = DynamicRealm . getInstance ( realmConfig ) ; 
 + realm = DynamicRealm . getInstance ( realmConfig ) ; 
 realmSchema = this . realm . getSchema ( ) ; 
 - this . realm . beginTransaction ( ) ; 
 + realm . beginTransaction ( ) ; 
 } 
 
 - @ Override 
 - protected void tearDown ( ) throws Exception { 
 - super . tearDown ( ) ; 
 + @ After 
 + public void tearDown ( ) { 
 realm . cancelTransaction ( ) ; 
 realm . close ( ) ; 
 } 
 
 - public void testGetAllClasses ( ) { 
 + @ Test 
 + public void getAll ( ) { 
 Set < RealmObjectSchema > objectSchemas = realmSchema . getAll ( ) ; 
 assertEquals ( 5 , objectSchemas . size ( ) ) ; 
 
 - List < String > expectedTables = Arrays . asList ( CLASS _ ALL _ JAVA _ TYPES , " Owner " , " Cat " , " Dog " , " DogPrimaryKey " ) ; 
 + List < String > expectedTables = Arrays . asList ( AllJavaTypes . CLASS _ NAME , " Owner " , " Cat " , " Dog " , " DogPrimaryKey " ) ; 
 for ( RealmObjectSchema objectSchema : objectSchemas ) { 
 if ( ! expectedTables . contains ( objectSchema . getClassName ( ) ) ) { 
 fail ( objectSchema . getClassName ( ) + " was not found " ) ; 
 @ @ - 64 , 12 + 80 , 14 @ @ public class RealmSchemaTests extends AndroidTestCase { 
 } 
 } 
 
 - public void testCreateClass ( ) { 
 + @ Test 
 + public void create ( ) { 
 realmSchema . create ( " Foo " ) ; 
 assertTrue ( realmSchema . contains ( " Foo " ) ) ; 
 } 
 
 - public void testCreateClassInvalidNameThrows ( ) { 
 + @ Test 
 + public void create _ invalidNameThrows ( ) { 
 String [ ] names = { null , " " , TestHelper . getRandomString ( 57 ) } ; 
 
 for ( String name : names ) { 
 @ @ - 81 , 50 + 99 , 56 @ @ public class RealmSchemaTests extends AndroidTestCase { 
 } 
 } 
 
 - public void testGetClass ( ) { 
 - RealmObjectSchema objectSchema = realmSchema . get ( CLASS _ ALL _ JAVA _ TYPES ) ; 
 + @ Test 
 + public void get ( ) { 
 + RealmObjectSchema objectSchema = realmSchema . get ( AllJavaTypes . CLASS _ NAME ) ; 
 assertNotNull ( objectSchema ) ; 
 - assertEquals ( CLASS _ ALL _ JAVA _ TYPES , objectSchema . getClassName ( ) ) ; 
 + assertEquals ( AllJavaTypes . CLASS _ NAME , objectSchema . getClassName ( ) ) ; 
 } 
 
 - public void testGetClassNotInSchema ( ) { 
 + @ Test 
 + public void get _ unknownClass ( ) { 
 assertNull ( realmSchema . get ( " Foo " ) ) ; 
 } 
 
 - public void testRenameClass ( ) { 
 + @ Test 
 + public void rename ( ) { 
 realmSchema . rename ( " Owner " , " Owner2 " ) ; 
 assertFalse ( realmSchema . contains ( " Owner " ) ) ; 
 assertTrue ( realmSchema . contains ( " Owner2 " ) ) ; 
 } 
 
 - public void testRenameClassInvalidArgumentsThrows ( ) { 
 + @ Test 
 + public void rename _ invalidArgumentThrows ( ) { 
 String [ ] illegalNames = new String [ ] { null , " " } ; 
 
 - / / Test as first parameters 
 + / / Test as first parameter 
 for ( String illegalName : illegalNames ) { 
 try { 
 - realmSchema . rename ( CLASS _ ALL _ JAVA _ TYPES , illegalName ) ; 
 + realmSchema . rename ( illegalName , AllJavaTypes . CLASS _ NAME ) ; 
 fail ( illegalName + " should throw an exception " ) ; 
 } catch ( IllegalArgumentException ignored ) { 
 } 
 } 
 
 - / / Test as last parameter 
 + / / Test as last parameters 
 for ( String illegalName : illegalNames ) { 
 try { 
 - realmSchema . rename ( illegalName , CLASS _ ALL _ JAVA _ TYPES ) ; 
 + realmSchema . rename ( AllJavaTypes . CLASS _ NAME , illegalName ) ; 
 fail ( illegalName + " should throw an exception " ) ; 
 } catch ( IllegalArgumentException ignored ) { 
 } 
 } 
 } 
 
 - public void testRemoveClass ( ) { 
 - realmSchema . remove ( CLASS _ ALL _ JAVA _ TYPES ) ; 
 - assertFalse ( realmSchema . contains ( CLASS _ ALL _ JAVA _ TYPES ) ) ; 
 + @ Test 
 + public void remove ( ) { 
 + realmSchema . remove ( AllJavaTypes . CLASS _ NAME ) ; 
 + assertFalse ( realmSchema . contains ( AllJavaTypes . CLASS _ NAME ) ) ; 
 } 
 
 - public void testRemoveClassInvalidClassNameThrows ( ) { 
 + @ Test 
 + public void remove _ invalidArgumentThrows ( ) { 
 try { 
 realmSchema . remove ( " Foo " ) ; 
 fail ( ) ; 
 @ @ - 139 , 10 + 163 , 9 @ @ public class RealmSchemaTests extends AndroidTestCase { 
 } 
 
 / / Test that it if { A - > B & & B - > A } you should remove the individual fields first before removing the entire 
 - / / class . This also include transitive dependencies : / 
 - / / Re - enable when this if fixed : https : / / github . com / realm / realm - core / pull / 1267 
 - public void FIMXEtestRemoveClassWithReferencesThrows ( ) { 
 - Util . setDebugLevel ( 2 ) ; 
 + / / class . This also include transitive dependencies . 
 + @ Test 
 + public void remove _ classWithReferencesThrows ( ) { 
 try { 
 realmSchema . remove ( " Cat " ) ; 
 fail ( ) ; 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java b / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java 
 index 109fd7e . . 056f4c6 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java 
 @ @ - 21 , 6 + 21 , 8 @ @ import android . content . res . AssetManager ; 
 import android . os . Looper ; 
 import android . util . Log ; 
 
 + import org . junit . Assert ; 
 + 
 import java . io . BufferedReader ; 
 import java . io . ByteArrayInputStream ; 
 import java . io . File ; 
 @ @ - 684 , 4 + 686 , 13 @ @ public class TestHelper { 
 AssetManager assetManager = context . getAssets ( ) ; 
 return assetManager . open ( file ) ; 
 } 
 + 
 + public static void quitLooperOrFail ( ) { 
 + Looper looper = Looper . myLooper ( ) ; 
 + if ( looper ! = null ) { 
 + looper . quit ( ) ; 
 + } else { 
 + Assert . fail ( ) ; 
 + } 
 + } 
 } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / entities / AllJavaTypes . java b / realm / realm - library / src / androidTest / java / io / realm / entities / AllJavaTypes . java 
 index 0264d61 . . fb37752 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / entities / AllJavaTypes . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / entities / AllJavaTypes . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import io . realm . annotations . PrimaryKey ; 
 
 public class AllJavaTypes extends RealmObject { 
 
 + public static final String CLASS _ NAME = " AllJavaTypes " ; 
 public static String FIELD _ IGNORED = " fieldIgnored " ; 
 public static String FIELD _ STRING = " fieldString " ; 
 public static String FIELD _ SHORT = " fieldShort " ; 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java b / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java 
 index f27ba08 . . d6b2046 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java 
 @ @ - 25 , 6 + 25 , 11 @ @ import io . realm . annotations . Index ; 
 public class Dog extends RealmObject { 
 
 public static final String CLASS _ NAME = " Dog " ; 
 + public static final String FIELD _ NAME = " name " ; 
 + public static final String FIELD _ AGE = " age " ; 
 + public static final String FIELD _ HEIGHT = " height " ; 
 + public static final String FIELD _ WEIGHT = " weight " ; 
 + public static final String FIELD _ BIRTHDAY = " birthday " ; 
 
 @ Index 
 private String name ;

NEAREST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTest . java 
 deleted file mode 100644 
 index cdc66ad . . 0000000 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTest . java 
 + + + / dev / null 
 @ @ - 1 , 283 + 0 , 0 @ @ 
 - / * 
 - * Copyright 2015 Realm Inc . 
 - * 
 - * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 - * you may not use this file except in compliance with the License . 
 - * You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package io . realm ; 
 - 
 - import android . test . AndroidTestCase ; 
 - 
 - import java . io . File ; 
 - import java . io . IOException ; 
 - import java . util . concurrent . Callable ; 
 - import java . util . concurrent . CountDownLatch ; 
 - import java . util . concurrent . ExecutionException ; 
 - import java . util . concurrent . ExecutorService ; 
 - import java . util . concurrent . Executors ; 
 - import java . util . concurrent . Future ; 
 - import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . TimeoutException ; 
 - 
 - import io . realm . entities . AllTypes ; 
 - import io . realm . entities . StringOnly ; 
 - 
 - public class RealmCacheTest extends AndroidTestCase { 
 - 
 - private RealmConfiguration defaultConfig ; 
 - 
 - @ Override 
 - protected void setUp ( ) throws Exception { 
 - super . setUp ( ) ; 
 - defaultConfig = TestHelper . createConfiguration ( getContext ( ) ) ; 
 - Realm . deleteRealm ( defaultConfig ) ; 
 - } 
 - 
 - / / Test that the closed Realm isn ' t kept in the Realm instance cache 
 - public void testRealmCacheIsCleared ( ) { 
 - Realm typedRealm = Realm . getInstance ( defaultConfig ) ; 
 - DynamicRealm dynamicRealm = DynamicRealm . getInstance ( defaultConfig ) ; 
 - 
 - typedRealm . close ( ) ; / / Still a dynamic instance open , but the typed Realm cache must still be cleared . 
 - dynamicRealm . close ( ) ; 
 - 
 - Realm typedRealm1 = Realm . getInstance ( defaultConfig ) ; 
 - try { 
 - assertFalse ( typedRealm = = typedRealm1 ) ; / / Must be different instance 
 - / / If cache isn ' t cleared this would crash because of a closed shared group . 
 - assertEquals ( 0 , typedRealm1 . where ( AllTypes . class ) . count ( ) ) ; 
 - } finally { 
 - typedRealm1 . close ( ) ; 
 - } 
 - } 
 - 
 - / / Test that the closed DynamicRealms isn ' t kept in the DynamicRealm instance cache 
 - public void testDynamicRealmCacheIsCleared ( ) { 
 - DynamicRealm dynamicRealm = DynamicRealm . getInstance ( defaultConfig ) ; 
 - Realm typedRealm = Realm . getInstance ( defaultConfig ) ; 
 - 
 - dynamicRealm . close ( ) ; / / Still an instance open , but DynamicRealm cache must still be cleared . 
 - typedRealm . close ( ) ; 
 - 
 - DynamicRealm dynamicRealm1 = DynamicRealm . getInstance ( defaultConfig ) ; 
 - try { 
 - / / If cache isn ' t cleared this would crash because of a closed shared group . 
 - assertFalse ( dynamicRealm = = dynamicRealm1 ) ; 
 - assertEquals ( 0 , dynamicRealm1 . getVersion ( ) ) ; 
 - } finally { 
 - dynamicRealm1 . close ( ) ; 
 - } 
 - } 
 - 
 - public void testGetInstanceClearsCacheWhenFailed ( ) { 
 - String REALM _ NAME = " invalid _ cache . realm " ; 
 - RealmConfiguration configA = TestHelper . createConfiguration ( getContext ( ) , REALM _ NAME , TestHelper . getRandomKey ( 42 ) ) ; 
 - RealmConfiguration configB = TestHelper . createConfiguration ( getContext ( ) , REALM _ NAME , TestHelper . getRandomKey ( 43 ) ) ; 
 - 
 - Realm . deleteRealm ( configA ) ; 
 - Realm realm = Realm . getInstance ( configA ) ; / / Create starting Realm with key1 
 - realm . close ( ) ; 
 - try { 
 - Realm . getInstance ( configB ) ; / / Try to open with key 2 
 - } catch ( IllegalArgumentException ignored ) { 
 - / / Delete Realm so key 2 works . This should work as a Realm shouldn ' t be cached 
 - / / if initialization failed . 
 - assertTrue ( Realm . deleteRealm ( configA ) ) ; 
 - realm = Realm . getInstance ( configB ) ; 
 - realm . close ( ) ; 
 - } 
 - } 
 - 
 - public void testRealmCache ( ) { 
 - Realm realm = Realm . getInstance ( defaultConfig ) ; 
 - Realm newRealm = Realm . getInstance ( defaultConfig ) ; 
 - try { 
 - assertEquals ( realm , newRealm ) ; 
 - } finally { 
 - realm . close ( ) ; 
 - newRealm . close ( ) ; 
 - } 
 - } 
 - 
 - / / We should not cache wrong configurations 
 - public void testDontCacheWrongConfigurations ( ) throws IOException { 
 - Realm testRealm ; 
 - String REALM _ NAME = " encrypted . realm " ; 
 - TestHelper . copyRealmFromAssets ( getContext ( ) , REALM _ NAME , REALM _ NAME ) ; 
 - RealmMigration realmMigration = TestHelper . prepareMigrationToNullSupportStep ( ) ; 
 - 
 - RealmConfiguration wrongConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 - . name ( REALM _ NAME ) 
 - . encryptionKey ( TestHelper . SHA512 ( " foo " ) ) 
 - . migration ( realmMigration ) 
 - . schema ( StringOnly . class ) 
 - . build ( ) ; 
 - 
 - RealmConfiguration rightConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 - . name ( REALM _ NAME ) 
 - . encryptionKey ( TestHelper . SHA512 ( " realm " ) ) 
 - . migration ( realmMigration ) 
 - . schema ( StringOnly . class ) 
 - . build ( ) ; 
 - 
 - / / Open Realm with wrong key 
 - try { 
 - Realm . getInstance ( wrongConfig ) ; 
 - fail ( ) ; 
 - } catch ( IllegalArgumentException ignored ) { 
 - } 
 - 
 - / / Try again with proper key 
 - testRealm = Realm . getInstance ( rightConfig ) ; 
 - assertNotNull ( testRealm ) ; 
 - testRealm . close ( ) ; 
 - } 
 - 
 - public void testDeletingRealmAlsoClearsConfigurationCache ( ) throws IOException { 
 - String REALM _ NAME = " encrypted . realm " ; 
 - byte [ ] oldPassword = TestHelper . SHA512 ( " realm " ) ; 
 - byte [ ] newPassword = TestHelper . SHA512 ( " realm - copy " ) ; 
 - 
 - TestHelper . copyRealmFromAssets ( getContext ( ) , REALM _ NAME , REALM _ NAME ) ; 
 - RealmMigration realmMigration = TestHelper . prepareMigrationToNullSupportStep ( ) ; 
 - 
 - RealmConfiguration config = new RealmConfiguration . Builder ( getContext ( ) ) 
 - . name ( REALM _ NAME ) 
 - . encryptionKey ( oldPassword ) 
 - . migration ( realmMigration ) 
 - . schema ( StringOnly . class ) 
 - . build ( ) ; 
 - 
 - / / 1 . Write a copy of the encrypted Realm to a new file 
 - Realm testRealm = Realm . getInstance ( config ) ; 
 - File copiedRealm = new File ( config . getRealmFolder ( ) , " encrypted - copy . realm " ) ; 
 - if ( copiedRealm . exists ( ) ) { 
 - assertTrue ( copiedRealm . delete ( ) ) ; 
 - } 
 - testRealm . writeEncryptedCopyTo ( copiedRealm , newPassword ) ; 
 - testRealm . close ( ) ; 
 - 
 - / / 2 . Delete the old Realm . 
 - Realm . deleteRealm ( config ) ; 
 - 
 - / / 3 . Rename the new file to the old file name . 
 - assertTrue ( copiedRealm . renameTo ( new File ( config . getRealmFolder ( ) , REALM _ NAME ) ) ) ; 
 - 
 - / / 4 . Try to open the file again with the new password 
 - / / If the configuration cache wasn ' t cleared this would fail as we would detect two 
 - / / configurations with 2 different passwords pointing to the same file . 
 - RealmConfiguration newConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 - . name ( REALM _ NAME ) 
 - . encryptionKey ( newPassword ) 
 - . migration ( realmMigration ) 
 - . schema ( StringOnly . class ) 
 - . build ( ) ; 
 - 
 - testRealm = Realm . getInstance ( newConfig ) ; 
 - assertNotNull ( testRealm ) ; 
 - testRealm . close ( ) ; 
 - } 
 - 
 - / / Tests that if the same Realm file is opened on multiple threads , we only need to validate the schema on the first thread . 
 - public void testValidateSchemasOverThreads ( ) throws InterruptedException , TimeoutException , ExecutionException { 
 - final RealmConfiguration config = TestHelper . createConfiguration ( getContext ( ) , " foo " ) ; 
 - Realm . deleteRealm ( config ) ; 
 - 
 - final CountDownLatch bgThreadLocked = new CountDownLatch ( 1 ) ; 
 - final CountDownLatch mainThreadDone = new CountDownLatch ( 1 ) ; 
 - 
 - new Thread ( new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - Realm realm = Realm . getInstance ( config ) ; 
 - realm . beginTransaction ( ) ; 
 - bgThreadLocked . countDown ( ) ; 
 - try { 
 - mainThreadDone . await ( 5 , TimeUnit . SECONDS ) ; 
 - } catch ( InterruptedException ignored ) { 
 - } 
 - realm . close ( ) ; 
 - } 
 - } ) . start ( ) ; 
 - 
 - ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 - Future < Boolean > future = executorService . submit ( new Callable < Boolean > ( ) { 
 - @ Override 
 - public Boolean call ( ) throws Exception { 
 - Realm realm = Realm . getInstance ( config ) ; 
 - realm . close ( ) ; 
 - mainThreadDone . countDown ( ) ; 
 - return true ; 
 - } 
 - } ) ; 
 - 
 - bgThreadLocked . await ( 2 , TimeUnit . SECONDS ) ; 
 - assertTrue ( future . get ( 10 , TimeUnit . SECONDS ) ) ; 
 - } 
 - 
 - public void testDifferentThreadsDifferentInstance ( ) throws InterruptedException { 
 - final CountDownLatch closeLatch = new CountDownLatch ( 1 ) ; 
 - 
 - final Realm realmA = Realm . getInstance ( defaultConfig ) ; 
 - 
 - Thread thread = new Thread ( new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - Realm realmB = Realm . getInstance ( defaultConfig ) ; 
 - assertFalse ( realmA = = realmB ) ; 
 - RealmCache . invokeWithGlobalRefCount ( defaultConfig , 
 - new TestHelper . ExpectedCountCallback ( 2 ) ) ; 
 - realmB . close ( ) ; 
 - closeLatch . countDown ( ) ; 
 - } 
 - } ) ; 
 - thread . start ( ) ; 
 - 
 - closeLatch . await ( ) ; 
 - RealmCache . invokeWithGlobalRefCount ( defaultConfig , new TestHelper . ExpectedCountCallback ( 1 ) ) ; 
 - realmA . close ( ) ; 
 - RealmCache . invokeWithGlobalRefCount ( defaultConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 - } 
 - 
 - public void testReleaseCacheInOneThread ( ) { 
 - / / Test release typed Realm instance 
 - Realm realmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; 
 - Realm realmB = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; 
 - RealmCache . release ( realmA ) ; 
 - assertNotNull ( realmA . sharedGroupManager ) ; 
 - RealmCache . release ( realmB ) ; 
 - assertNull ( realmB . sharedGroupManager ) ; 
 - / / No crash but warning in the log 
 - RealmCache . release ( realmB ) ; 
 - 
 - / / Test release dynamic Realm instance 
 - DynamicRealm dynamicRealmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , 
 - DynamicRealm . class ) ; 
 - DynamicRealm dynamicRealmB = RealmCache . createRealmOrGetFromCache ( defaultConfig , 
 - DynamicRealm . class ) ; 
 - RealmCache . release ( dynamicRealmA ) ; 
 - assertNotNull ( dynamicRealmA . sharedGroupManager ) ; 
 - RealmCache . release ( dynamicRealmB ) ; 
 - assertNull ( dynamicRealmB . sharedGroupManager ) ; 
 - / / No crash but warning in the log 
 - RealmCache . release ( dynamicRealmB ) ; 
 - 
 - / / Test both typed Realm and dynamic Realm in same thread 
 - realmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; 
 - dynamicRealmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , DynamicRealm . class ) ; 
 - RealmCache . release ( realmA ) ; 
 - assertNull ( realmA . sharedGroupManager ) ; 
 - RealmCache . release ( dynamicRealmA ) ; 
 - assertNull ( realmA . sharedGroupManager ) ; 
 - } 
 - } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTests . java 
 new file mode 100644 
 index 0000000 . . 3c73dee 
 - - - / dev / null 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmCacheTests . java 
 @ @ - 0 , 0 + 1 , 292 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm ; 
 + 
 + import android . content . Context ; 
 + import android . support . test . InstrumentationRegistry ; 
 + import android . support . test . runner . AndroidJUnit4 ; 
 + 
 + import org . junit . Before ; 
 + import org . junit . Rule ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import java . io . File ; 
 + import java . io . IOException ; 
 + import java . util . concurrent . CountDownLatch ; 
 + 
 + import io . realm . entities . AllTypes ; 
 + import io . realm . entities . StringOnly ; 
 + import io . realm . rule . TestRealmConfigurationFactory ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + import static org . junit . Assert . assertFalse ; 
 + import static org . junit . Assert . assertNull ; 
 + import static org . junit . Assert . assertNotNull ; 
 + import static org . junit . Assert . fail ; 
 + 
 + @ RunWith ( AndroidJUnit4 . class ) 
 + public class RealmCacheTests { 
 + 
 + @ Rule 
 + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; 
 + 
 + private RealmConfiguration defaultConfig ; 
 + private Context context ; 
 + 
 + @ Before 
 + public void setUp ( ) { 
 + defaultConfig = configFactory . createConfiguration ( ) ; 
 + context = InstrumentationRegistry . getInstrumentation ( ) . getContext ( ) ; 
 + } 
 + 
 + / / Test that the closed Realm isn ' t kept in the Realm instance cache 
 + @ Test 
 + public void typedRealmCacheIsCleared ( ) { 
 + Realm typedRealm = Realm . getInstance ( defaultConfig ) ; 
 + DynamicRealm dynamicRealm = DynamicRealm . getInstance ( defaultConfig ) ; 
 + 
 + typedRealm . close ( ) ; / / Still a dynamic instance open , but the typed Realm cache must still be cleared . 
 + dynamicRealm . close ( ) ; 
 + 
 + Realm typedRealm1 = Realm . getInstance ( defaultConfig ) ; 
 + try { 
 + assertFalse ( typedRealm = = typedRealm1 ) ; / / Must be different instance 
 + / / If cache isn ' t cleared this would crash because of a closed shared group . 
 + assertEquals ( 0 , typedRealm1 . where ( AllTypes . class ) . count ( ) ) ; 
 + } finally { 
 + typedRealm1 . close ( ) ; 
 + } 
 + } 
 + 
 + / / Test that the closed DynamicRealms isn ' t kept in the DynamicRealm instance cache 
 + @ Test 
 + public void dynamicRealmCacheIsCleared ( ) { 
 + DynamicRealm dynamicRealm = DynamicRealm . getInstance ( defaultConfig ) ; 
 + Realm typedRealm = Realm . getInstance ( defaultConfig ) ; 
 + 
 + dynamicRealm . close ( ) ; / / Still an instance open , but DynamicRealm cache must still be cleared . 
 + typedRealm . close ( ) ; 
 + 
 + DynamicRealm dynamicRealm1 = DynamicRealm . getInstance ( defaultConfig ) ; 
 + try { 
 + / / If cache isn ' t cleared this would crash because of a closed shared group . 
 + assertFalse ( dynamicRealm = = dynamicRealm1 ) ; 
 + assertEquals ( 0 , dynamicRealm1 . getVersion ( ) ) ; 
 + } finally { 
 + dynamicRealm1 . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void getInstanceClearsCacheWhenFailed ( ) { 
 + String REALM _ NAME = " invalid _ cache . realm " ; 
 + RealmConfiguration configA = configFactory . createConfiguration ( REALM _ NAME , 
 + TestHelper . getRandomKey ( 42 ) ) ; 
 + RealmConfiguration configB = configFactory . createConfiguration ( REALM _ NAME , 
 + TestHelper . getRandomKey ( 43 ) ) ; 
 + 
 + Realm realm = Realm . getInstance ( configA ) ; / / Create starting Realm with key1 
 + realm . close ( ) ; 
 + try { 
 + Realm . getInstance ( configB ) ; / / Try to open with key 2 
 + } catch ( IllegalArgumentException ignored ) { 
 + / / Delete Realm so key 2 works . This should work as a Realm shouldn ' t be cached 
 + / / if initialization failed . 
 + assertTrue ( Realm . deleteRealm ( configA ) ) ; 
 + realm = Realm . getInstance ( configB ) ; 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void realmCache ( ) { 
 + Realm realm = Realm . getInstance ( defaultConfig ) ; 
 + Realm newRealm = Realm . getInstance ( defaultConfig ) ; 
 + try { 
 + assertEquals ( realm , newRealm ) ; 
 + } finally { 
 + realm . close ( ) ; 
 + newRealm . close ( ) ; 
 + } 
 + } 
 + 
 + / / We should not cache wrong configurations 
 + @ Test 
 + public void dontCacheWrongConfigurations ( ) throws IOException { 
 + Realm testRealm ; 
 + String REALM _ NAME = " encrypted . realm " ; 
 + configFactory . copyRealmFromAssets ( context , REALM _ NAME , REALM _ NAME ) ; 
 + RealmMigration realmMigration = TestHelper . prepareMigrationToNullSupportStep ( ) ; 
 + 
 + RealmConfiguration wrongConfig = configFactory . createConfigurationBuilder ( ) 
 + . name ( REALM _ NAME ) 
 + . encryptionKey ( TestHelper . SHA512 ( " foo " ) ) 
 + . migration ( realmMigration ) 
 + . schema ( StringOnly . class ) 
 + . build ( ) ; 
 + 
 + RealmConfiguration rightConfig = configFactory . createConfigurationBuilder ( ) 
 + . name ( REALM _ NAME ) 
 + . encryptionKey ( TestHelper . SHA512 ( " realm " ) ) 
 + . migration ( realmMigration ) 
 + . schema ( StringOnly . class ) 
 + . build ( ) ; 
 + 
 + / / Open Realm with wrong key 
 + try { 
 + Realm . getInstance ( wrongConfig ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + 
 + / / Try again with proper key 
 + testRealm = Realm . getInstance ( rightConfig ) ; 
 + assertNotNull ( testRealm ) ; 
 + testRealm . close ( ) ; 
 + } 
 + 
 + @ Test 
 + public void deletingRealmAlsoClearsConfigurationCache ( ) throws IOException { 
 + String REALM _ NAME = " encrypted . realm " ; 
 + byte [ ] oldPassword = TestHelper . SHA512 ( " realm " ) ; 
 + byte [ ] newPassword = TestHelper . SHA512 ( " realm - copy " ) ; 
 + 
 + configFactory . copyRealmFromAssets ( context , REALM _ NAME , REALM _ NAME ) ; 
 + RealmMigration realmMigration = TestHelper . prepareMigrationToNullSupportStep ( ) ; 
 + 
 + RealmConfiguration config = configFactory . createConfigurationBuilder ( ) 
 + . name ( REALM _ NAME ) 
 + . encryptionKey ( oldPassword ) 
 + . migration ( realmMigration ) 
 + . schema ( StringOnly . class ) 
 + . build ( ) ; 
 + 
 + / / 1 . Write a copy of the encrypted Realm to a new file 
 + Realm testRealm = Realm . getInstance ( config ) ; 
 + File copiedRealm = new File ( config . getRealmFolder ( ) , " encrypted - copy . realm " ) ; 
 + if ( copiedRealm . exists ( ) ) { 
 + assertTrue ( copiedRealm . delete ( ) ) ; 
 + } 
 + testRealm . writeEncryptedCopyTo ( copiedRealm , newPassword ) ; 
 + testRealm . close ( ) ; 
 + 
 + / / 2 . Delete the old Realm . 
 + Realm . deleteRealm ( config ) ; 
 + 
 + / / 3 . Rename the new file to the old file name . 
 + assertTrue ( copiedRealm . renameTo ( new File ( config . getRealmFolder ( ) , REALM _ NAME ) ) ) ; 
 + 
 + / / 4 . Try to open the file again with the new password 
 + / / If the configuration cache wasn ' t cleared this would fail as we would detect two 
 + / / configurations with 2 different passwords pointing to the same file . 
 + RealmConfiguration newConfig = configFactory . createConfigurationBuilder ( ) 
 + . name ( REALM _ NAME ) 
 + . encryptionKey ( newPassword ) 
 + . migration ( realmMigration ) 
 + . schema ( StringOnly . class ) 
 + . build ( ) ; 
 + 
 + testRealm = Realm . getInstance ( newConfig ) ; 
 + assertNotNull ( testRealm ) ; 
 + testRealm . close ( ) ; 
 + } 
 + 
 + / / Tests that if the same Realm file is opened on multiple threads , we only need to validate the 
 + / / schema on the first thread 
 + / / When there is a transaction holding by a typed Realm in one thread , getInstance from the 
 + / / other thread should not be blocked since we have cached the schemas already . 
 + @ Test 
 + public void getInstance _ shouldNotBeBlockedByTransactionInAnotherThread ( ) 
 + throws InterruptedException { 
 + Realm realm = Realm . getInstance ( defaultConfig ) ; 
 + final CountDownLatch latch = new CountDownLatch ( 1 ) ; 
 + realm . beginTransaction ( ) ; 
 + 
 + Thread thread = new Thread ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Realm realm = Realm . getInstance ( defaultConfig ) ; 
 + realm . close ( ) ; 
 + latch . countDown ( ) ; 
 + } 
 + } ) ; 
 + thread . start ( ) ; 
 + TestHelper . awaitOrFail ( latch ) ; 
 + realm . cancelTransaction ( ) ; 
 + realm . close ( ) ; 
 + } 
 + 
 + @ Test 
 + public void differentThreadsDifferentInstance ( ) throws InterruptedException { 
 + final CountDownLatch closeLatch = new CountDownLatch ( 1 ) ; 
 + 
 + final Realm realmA = Realm . getInstance ( defaultConfig ) ; 
 + 
 + Thread thread = new Thread ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Realm realmB = Realm . getInstance ( defaultConfig ) ; 
 + assertFalse ( realmA = = realmB ) ; 
 + RealmCache . invokeWithGlobalRefCount ( defaultConfig , 
 + new TestHelper . ExpectedCountCallback ( 2 ) ) ; 
 + realmB . close ( ) ; 
 + closeLatch . countDown ( ) ; 
 + } 
 + } ) ; 
 + thread . start ( ) ; 
 + 
 + closeLatch . await ( ) ; 
 + RealmCache . invokeWithGlobalRefCount ( defaultConfig , new TestHelper . ExpectedCountCallback ( 1 ) ) ; 
 + realmA . close ( ) ; 
 + RealmCache . invokeWithGlobalRefCount ( defaultConfig , new TestHelper . ExpectedCountCallback ( 0 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void releaseCacheInOneThread ( ) { 
 + / / Test release typed Realm instance 
 + Realm realmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; 
 + Realm realmB = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; 
 + RealmCache . release ( realmA ) ; 
 + assertNotNull ( realmA . sharedGroupManager ) ; 
 + RealmCache . release ( realmB ) ; 
 + assertNull ( realmB . sharedGroupManager ) ; 
 + / / No crash but warning in the log 
 + RealmCache . release ( realmB ) ; 
 + 
 + / / Test release dynamic Realm instance 
 + DynamicRealm dynamicRealmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , 
 + DynamicRealm . class ) ; 
 + DynamicRealm dynamicRealmB = RealmCache . createRealmOrGetFromCache ( defaultConfig , 
 + DynamicRealm . class ) ; 
 + RealmCache . release ( dynamicRealmA ) ; 
 + assertNotNull ( dynamicRealmA . sharedGroupManager ) ; 
 + RealmCache . release ( dynamicRealmB ) ; 
 + assertNull ( dynamicRealmB . sharedGroupManager ) ; 
 + / / No crash but warning in the log 
 + RealmCache . release ( dynamicRealmB ) ; 
 + 
 + / / Test both typed Realm and dynamic Realm in same thread 
 + realmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , Realm . class ) ; 
 + dynamicRealmA = RealmCache . createRealmOrGetFromCache ( defaultConfig , DynamicRealm . class ) ; 
 + RealmCache . release ( realmA ) ; 
 + assertNull ( realmA . sharedGroupManager ) ; 
 + RealmCache . release ( dynamicRealmA ) ; 
 + assertNull ( realmA . sharedGroupManager ) ; 
 + } 
 + } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmMigrationTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmMigrationTests . java 
 index c882a00 . . fa9a208 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmMigrationTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmMigrationTests . java 
 @ @ - 16 , 7 + 16 , 15 @ @ 
 
 package io . realm ; 
 
 - import android . test . AndroidTestCase ; 
 + import android . content . Context ; 
 + import android . support . test . InstrumentationRegistry ; 
 + import android . support . test . runner . AndroidJUnit4 ; 
 + 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Rule ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 
 import java . io . File ; 
 import java . io . IOException ; 
 @ @ - 30 , 24 + 38 , 38 @ @ import io . realm . entities . PrimaryKeyAsString ; 
 import io . realm . entities . StringOnly ; 
 import io . realm . exceptions . RealmMigrationNeededException ; 
 import io . realm . internal . Table ; 
 + import io . realm . rule . TestRealmConfigurationFactory ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + import static org . junit . Assert . fail ; 
 + 
 + @ RunWith ( AndroidJUnit4 . class ) 
 + public class RealmMigrationTests { 
 
 - public class RealmMigrationTests extends AndroidTestCase { 
 + @ Rule 
 + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; 
 
 - public Realm realm ; 
 + private Realm realm ; 
 + private Context context ; 
 
 - @ Override 
 - protected void tearDown ( ) throws Exception { 
 - super . tearDown ( ) ; 
 + @ Before 
 + public void setup ( ) { 
 + context = InstrumentationRegistry . getInstrumentation ( ) . getContext ( ) ; 
 + } 
 + 
 + @ After 
 + public void tearDown ( ) { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 } 
 
 - public void testRealmClosedAfterMigrationException ( ) throws IOException { 
 + @ Test 
 + public void getInstance _ realmClosedAfterMigrationException ( ) throws IOException { 
 String REALM _ NAME = " default0 . realm " ; 
 - RealmConfiguration realmConfig = TestHelper . createConfiguration ( getContext ( ) , REALM _ NAME ) ; 
 - Realm . deleteRealm ( realmConfig ) ; 
 - TestHelper . copyRealmFromAssets ( getContext ( ) , REALM _ NAME , REALM _ NAME ) ; 
 + RealmConfiguration realmConfig = configFactory . createConfiguration ( REALM _ NAME ) ; 
 + configFactory . copyRealmFromAssets ( context , REALM _ NAME , REALM _ NAME ) ; 
 try { 
 Realm . getInstance ( realmConfig ) ; 
 fail ( " A migration should be triggered " ) ; 
 @ @ - 64 , 19 + 86 , 19 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 
 / / If a migration creates a different ordering of columns on Realm A , while another ordering is generated by 
 / / creating a new Realm B . Global column indices will not work . They must be calculated for each Realm . 
 - public void testLocalColumnIndices ( ) throws IOException { 
 + @ Test 
 + public void localColumnIndices ( ) throws IOException { 
 String MIGRATED _ REALM = " migrated . realm " ; 
 String NEW _ REALM = " new . realm " ; 
 
 / / Migrate old Realm to proper schema 
 
 / / V1 config 
 - RealmConfiguration v1Config = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration v1Config = configFactory . createConfigurationBuilder ( ) 
 . name ( MIGRATED _ REALM ) 
 . schema ( AllTypes . class ) 
 . schemaVersion ( 1 ) 
 . build ( ) ; 
 - Realm . deleteRealm ( v1Config ) ; 
 Realm oldRealm = Realm . getInstance ( v1Config ) ; 
 oldRealm . close ( ) ; 
 
 @ @ - 91 , 7 + 113 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } 
 } ; 
 
 - RealmConfiguration v2Config = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration v2Config = configFactory . createConfigurationBuilder ( ) 
 . name ( MIGRATED _ REALM ) 
 . schema ( AllTypes . class , FieldOrder . class ) 
 . schemaVersion ( 2 ) 
 @ @ - 101 , 12 + 123 , 11 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 
 / / Create new Realm which will cause column indices to be recalculated based on the order in the java file 
 / / instead of the migration 
 - RealmConfiguration newConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration newConfig = configFactory . createConfigurationBuilder ( ) 
 . name ( NEW _ REALM ) 
 . schemaVersion ( 2 ) 
 . schema ( AllTypes . class , FieldOrder . class ) 
 . build ( ) ; 
 - Realm . deleteRealm ( newConfig ) ; 
 Realm newRealm = Realm . getInstance ( newConfig ) ; 
 newRealm . close ( ) ; 
 
 @ @ - 115 , 11 + 136 , 13 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 oldRealm . close ( ) ; 
 } 
 
 - public void testNotSettingIndexThrows ( ) { 
 + @ Test 
 + public void notSettingIndexThrows ( ) { 
 
 / / Create v0 of the Realm 
 - RealmConfiguration originalConfig = new RealmConfiguration . Builder ( getContext ( ) ) . schema ( AllTypes . class ) . build ( ) ; 
 - Realm . deleteRealm ( originalConfig ) ; 
 + RealmConfiguration originalConfig = configFactory . createConfigurationBuilder ( ) 
 + . schema ( AllTypes . class ) 
 + . build ( ) ; 
 Realm . getInstance ( originalConfig ) . close ( ) ; 
 
 / / Create v1 of the Realm 
 @ @ - 134 , 7 + 157 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } 
 } ; 
 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schemaVersion ( 1 ) 
 . schema ( AllTypes . class , AnnotationTypes . class ) 
 . migration ( migration ) 
 @ @ - 146 , 16 + 169 , 17 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } finally { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 - Realm . deleteRealm ( realmConfig ) ; 
 } 
 } 
 } 
 
 - public void testNotSettingPrimaryKeyThrows ( ) { 
 + @ Test 
 + public void notSettingPrimaryKeyThrows ( ) { 
 
 / / Create v0 of the Realm 
 - RealmConfiguration originalConfig = new RealmConfiguration . Builder ( getContext ( ) ) . schema ( AllTypes . class ) . build ( ) ; 
 - Realm . deleteRealm ( originalConfig ) ; 
 + RealmConfiguration originalConfig = configFactory . createConfigurationBuilder ( ) 
 + . schema ( AllTypes . class ) 
 + . build ( ) ; 
 Realm . getInstance ( originalConfig ) . close ( ) ; 
 
 RealmMigration migration = new RealmMigration ( ) { 
 @ @ - 170 , 7 + 194 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } ; 
 
 / / Create v1 of the Realm 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schemaVersion ( 1 ) 
 . schema ( AllTypes . class , AnnotationTypes . class ) 
 . migration ( migration ) 
 @ @ - 185 , 13 + 209 , 13 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } finally { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 - Realm . deleteRealm ( realmConfig ) ; 
 } 
 } 
 } 
 
 / / adding search index is idempotent 
 - public void testAddingSearchIndexTwice ( ) throws IOException { 
 + @ Test 
 + public void addingSearchIndexTwice ( ) throws IOException { 
 Class [ ] classes = { PrimaryKeyAsLong . class , PrimaryKeyAsString . class } ; 
 
 for ( final Class clazz : classes ) { 
 @ @ - 210 , 13 + 234 , 14 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 didMigrate [ 0 ] = true ; 
 } 
 } ; 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schemaVersion ( 42 ) 
 . schema ( clazz ) 
 . migration ( migration ) 
 . build ( ) ; 
 Realm . deleteRealm ( realmConfig ) ; 
 - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 + configFactory . copyRealmFromAssets ( context , 
 + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 Realm . migrateRealm ( realmConfig ) ; 
 realm = Realm . getInstance ( realmConfig ) ; 
 assertEquals ( 42 , realm . getVersion ( ) ) ; 
 @ @ - 227 , 11 + 252 , 13 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } 
 } 
 
 - public void testSetAnnotations ( ) { 
 + @ Test 
 + public void setAnnotations ( ) { 
 
 / / Create v0 of the Realm 
 - RealmConfiguration originalConfig = new RealmConfiguration . Builder ( getContext ( ) ) . schema ( AllTypes . class ) . build ( ) ; 
 - Realm . deleteRealm ( originalConfig ) ; 
 + RealmConfiguration originalConfig = configFactory . createConfigurationBuilder ( ) 
 + . schema ( AllTypes . class ) 
 + . build ( ) ; 
 Realm . getInstance ( originalConfig ) . close ( ) ; 
 
 RealmMigration migration = new RealmMigration ( ) { 
 @ @ - 245 , 7 + 272 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } 
 } ; 
 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schemaVersion ( 1 ) 
 . schema ( AllTypes . class , AnnotationTypes . class ) 
 . migration ( migration ) 
 @ @ - 259 , 11 + 286 , 12 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 assertTrue ( table . hasSearchIndex ( table . getColumnIndex ( " indexString " ) ) ) ; 
 } 
 
 - public void testGetPathFromMigrationException ( ) throws IOException { 
 - TestHelper . copyRealmFromAssets ( getContext ( ) , " default0 . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 - File realm = new File ( getContext ( ) . getFilesDir ( ) , Realm . DEFAULT _ REALM _ NAME ) ; 
 + @ Test 
 + public void migrationException _ getPath ( ) throws IOException { 
 + configFactory . copyRealmFromAssets ( context , " default0 . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 + File realm = new File ( configFactory . getRoot ( ) , Realm . DEFAULT _ REALM _ NAME ) ; 
 try { 
 - Realm . getInstance ( getContext ( ) ) ; 
 + Realm . getInstance ( configFactory . createConfiguration ( ) ) ; 
 fail ( ) ; 
 } catch ( RealmMigrationNeededException expected ) { 
 assertEquals ( expected . getPath ( ) , realm . getCanonicalPath ( ) ) ; 
 @ @ - 272 , 10 + 300 , 12 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 
 / / In default - before - migration . realm , CatOwner has a RealmList < Dog > field . 
 / / This is changed to RealmList < Cat > and getInstance ( ) must throw an exception . 
 - public void testRealmListChanged ( ) throws IOException { 
 - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 + @ Test 
 + public void migrationException _ realmListChanged ( ) throws IOException { 
 + configFactory . copyRealmFromAssets ( context , 
 + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 try { 
 - realm = Realm . getInstance ( getContext ( ) ) ; 
 + realm = Realm . getInstance ( configFactory . createConfiguration ( ) ) ; 
 fail ( ) ; 
 } catch ( RealmMigrationNeededException expected ) { 
 } 
 @ @ - 284 , 8 + 314 , 10 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 / / Pre - null Realms will leave columns not - nullable after the underlying storage engine has 
 / / migrated the file format . But @ Required must be added , and forgetting so will give you 
 / / a RealmMigrationNeeded exception . 
 - public void testOpenPreNullRealmRequiredMissing ( ) throws IOException { 
 - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 + @ Test 
 + public void openPreNullRealmRequiredMissing ( ) throws IOException { 
 + configFactory . copyRealmFromAssets ( context , 
 + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 RealmMigration realmMigration = new RealmMigration ( ) { 
 @ Override 
 public void migrate ( DynamicRealm realm , long oldVersion , long newVersion ) { 
 @ @ - 294 , 7 + 326 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } ; 
 
 try { 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schemaVersion ( 0 ) 
 . schema ( StringOnly . class ) 
 . migration ( realmMigration ) 
 @ @ - 311 , 8 + 343 , 10 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 / / Pre - null Realms will leave columns not - nullable after the underlying storage engine has 
 / / migrated the file format . An explicit migration step to convert to nullable , and the 
 / / old class ( without @ Required ) can be used , 
 - public void testMigratePreNull ( ) throws IOException { 
 - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 + @ Test 
 + public void migratePreNull ( ) throws IOException { 
 + configFactory . copyRealmFromAssets ( context , 
 + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 RealmMigration migration = new RealmMigration ( ) { 
 @ Override 
 public void migrate ( DynamicRealm realm , long oldVersion , long newVersion ) { 
 @ @ - 321 , 7 + 355 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } 
 } ; 
 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schemaVersion ( 1 ) 
 . schema ( StringOnly . class ) 
 . migration ( migration ) 
 @ @ - 337 , 9 + 371 , 11 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 / / Pre - null Realms will leave columns not - nullable after the underlying storage engine has 
 / / migrated the file format . If the user adds the @ Required annotation to a field and does not 
 / / change the schema version , no migration is needed . But then , null cannot be used as a value . 
 - public void testOpenPreNullWithRequired ( ) throws IOException { 
 - TestHelper . copyRealmFromAssets ( getContext ( ) , " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + @ Test 
 + public void openPreNullWithRequired ( ) throws IOException { 
 + configFactory . copyRealmFromAssets ( context , 
 + " default - before - migration . realm " , Realm . DEFAULT _ REALM _ NAME ) ; 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schemaVersion ( 0 ) 
 . schema ( AllTypes . class ) 
 . build ( ) ; 
 @ @ - 358 , 7 + 394 , 8 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } 
 
 / / If a required field was nullable before , a RealmMigrationNeededException should be thrown 
 - public void testNotSettingRequiredForNotNullableThrows ( ) { 
 + @ Test 
 + public void notSettingRequiredForNotNullableThrows ( ) { 
 String [ ] notNullableFields = { " fieldStringNotNull " , " fieldBytesNotNull " , " fieldBooleanNotNull " , 
 " fieldByteNotNull " , " fieldShortNotNull " , " fieldIntegerNotNull " , " fieldLongNotNull " , 
 " fieldFloatNotNull " , " fieldDoubleNotNull " , " fieldDateNotNull " } ; 
 @ @ - 400 , 7 + 437 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } ; 
 
 @ SuppressWarnings ( " unchecked " ) 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schemaVersion ( 1 ) 
 . schema ( NullTypes . class ) 
 . migration ( migration ) 
 @ @ - 421 , 7 + 458 , 8 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } 
 
 / / If a field is not required but was not nullable before , a RealmMigrationNeededException should be thrown 
 - public void testSettingRequiredForNullableThrows ( ) { 
 + @ Test 
 + public void settingRequiredForNullableThrows ( ) { 
 String [ ] notNullableFields = { " fieldStringNull " , " fieldBytesNull " , " fieldBooleanNull " , 
 " fieldByteNull " , " fieldShortNull " , " fieldIntegerNull " , " fieldLongNull " , 
 " fieldFloatNull " , " fieldDoubleNull " , " fieldDateNull " } ; 
 @ @ - 462 , 7 + 500 , 7 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } ; 
 
 @ SuppressWarnings ( " unchecked " ) 
 - RealmConfiguration realmConfig = new RealmConfiguration . Builder ( getContext ( ) ) 
 + RealmConfiguration realmConfig = configFactory . createConfigurationBuilder ( ) 
 . schemaVersion ( 1 ) 
 . schema ( NullTypes . class ) 
 . migration ( migration ) 
 @ @ - 487 , 9 + 525 , 9 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 } 
 } 
 
 - public void testRealmOpenBeforeMigrationThrows ( ) { 
 - RealmConfiguration config = TestHelper . createConfiguration ( getContext ( ) ) ; 
 - Realm . deleteRealm ( config ) ; 
 + @ Test 
 + public void realmOpenBeforeMigrationThrows ( ) { 
 + RealmConfiguration config = configFactory . createConfiguration ( ) ; 
 realm = Realm . getInstance ( config ) ; 
 
 try { 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java 
 index 86d949f . . 0f513bd 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmTests . java 
 @ @ - 2801 , 25 + 2801 , 4 @ @ public class RealmTests { 
 assertEquals ( 0 , realm . where ( Cat . class ) . count ( ) ) ; 
 assertTrue ( realm . isEmpty ( ) ) ; 
 } 
 - 
 - / / When there is a transaction holding by a typed Realm in one thread , getInstance from the 
 - / / other thread should not be blocked since we have cached the schemas already . 
 - @ Test 
 - public void getInstance _ shouldNotBeBlockedByTransactionInAnotherThread ( ) 
 - throws InterruptedException { 
 - final CountDownLatch latch = new CountDownLatch ( 1 ) ; 
 - realm . beginTransaction ( ) ; 
 - 
 - Thread thread = new Thread ( new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - Realm realm = Realm . getInstance ( realmConfig ) ; 
 - realm . close ( ) ; 
 - latch . countDown ( ) ; 
 - } 
 - } ) ; 
 - thread . start ( ) ; 
 - TestHelper . awaitOrFail ( latch ) ; 
 - realm . cancelTransaction ( ) ; 
 - } 
 } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java b / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java 
 index 6bc2097 . . 8837c97 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java 
 @ @ - 16 , 10 + 16 , 17 @ @ 
 
 package io . realm . rule ; 
 
 + import android . content . Context ; 
 + import android . content . res . AssetManager ; 
 + 
 import org . junit . rules . TemporaryFolder ; 
 import org . junit . runner . Description ; 
 import org . junit . runners . model . Statement ; 
 
 + import java . io . File ; 
 + import java . io . FileOutputStream ; 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 import java . util . Collections ; 
 import java . util . Map ; 
 import java . util . Set ; 
 @ @ - 109 , 4 + 116 , 20 @ @ public class TestRealmConfigurationFactory extends TemporaryFolder { 
 public RealmConfiguration . Builder createConfigurationBuilder ( ) { 
 return new RealmConfiguration . Builder ( getRoot ( ) ) ; 
 } 
 + 
 + / / Copies a Realm file from assets to temp dir 
 + public void copyRealmFromAssets ( Context context , String realmPath , String newName ) 
 + throws IOException { 
 + AssetManager assetManager = context . getAssets ( ) ; 
 + InputStream is = assetManager . open ( realmPath ) ; 
 + File file = new File ( getRoot ( ) , newName ) ; 
 + FileOutputStream outputStream = new FileOutputStream ( file ) ; 
 + byte [ ] buf = new byte [ 1024 ] ; 
 + int bytesRead ; 
 + while ( ( bytesRead = is . read ( buf ) ) > - 1 ) { 
 + outputStream . write ( buf , 0 , bytesRead ) ; 
 + } 
 + outputStream . close ( ) ; 
 + is . close ( ) ; 
 + } 
 }
