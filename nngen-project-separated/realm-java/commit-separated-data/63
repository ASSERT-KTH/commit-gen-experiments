BLEU SCORE: 0.03283637368030199

TEST MSG: Migration that changes primary key deletes rows
GENERATED MSG: Moved setPrimaryKey to JNI .

TEST DIFF (one line): diff - - git a / CHANGELOG . md b / CHANGELOG . md <nl> index d86e153 . . f7b9e6c 100644 <nl> - - - a / CHANGELOG . md <nl> + + + b / CHANGELOG . md <nl> @ @ - 1 , 3 + 1 , 10 @ @ <nl> + # # 5 . 0 . 2 ( YYYY - MM - DD ) <nl> + <nl> + # # # Bug Fixes <nl> + <nl> + * Changing a primary key from being nullable to being required could result in objects being deleted ( # # 5899 ) . <nl> + <nl> + <nl> # # 5 . 0 . 1 ( 2018 - 04 - 09 ) <nl> <nl> # # # Enhancements <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java <nl> index 74c3b6e . . 8ea8719 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java <nl> @ @ - 884 , 7 + 884 , 7 @ @ public class RealmObjectSchemaTests { <nl> assertEquals ( 0 , list . get ( 0 ) . length ) ; <nl> assertArrayEquals ( new byte [ ] { 1 , 2 , 3 } , list . get ( 1 ) ) ; <nl> } <nl> - <nl> + <nl> @ Test <nl> public void setRequired _ true _ onPrimaryKeyField _ containsNullValues _ shouldThrow ( ) { <nl> if ( type = = ObjectSchemaType . IMMUTABLE ) { <nl> @ @ - 1349 , 4 + 1349 , 39 @ @ public class RealmObjectSchemaTests { <nl> private interface FieldRunnable { <nl> void run ( String fieldName ) ; <nl> } <nl> + <nl> + / / Tests https : / / github . com / realm / realm - studio / issues / 5899 <nl> + @ Test <nl> + public void setRequired _ keepExistingRowsIfPrimaryKey ( ) { <nl> + if ( type = = ObjectSchemaType . IMMUTABLE ) { <nl> + return ; <nl> + } <nl> + DynamicRealm dynRealm = ( DynamicRealm ) realm ; <nl> + String className = " NewClass " ; <nl> + String fieldName = " field " ; <nl> + <nl> + / / Check all primary key types <nl> + for ( PrimaryKeyFieldType fieldType : PrimaryKeyFieldType . values ( ) ) { <nl> + schema . addField ( fieldName , fieldType . getType ( ) , FieldAttribute . PRIMARY _ KEY ) ; / / primary key field <nl> + <nl> + / / Hackish way to add sample data , only treat string differently <nl> + for ( int i = 0 ; i < 5 ; i + + ) { <nl> + Object primaryKeyValue = ( fieldType . getType ( ) = = String . class ) ? Integer . toString ( i ) : i ; <nl> + dynRealm . createObject ( className , primaryKeyValue ) ; <nl> + } <nl> + <nl> + / / Verify that sample data is intact before swapping nullability state <nl> + String errMsg = String . format ( String . format ( " Count mismatch for FieldType = % s and Nullable = % s " , fieldType . getType ( ) , schema . isNullable ( fieldName ) ) ) ; <nl> + assertEquals ( errMsg , 5 , dynRealm . where ( className ) . count ( ) ) ; <nl> + <nl> + / / Swap nullability state <nl> + schema . setRequired ( fieldName , ! schema . isRequired ( fieldName ) ) ; <nl> + errMsg = String . format ( String . format ( " Count mismatch for FieldType = % s and Nullable = % s " , fieldType . getType ( ) , schema . isNullable ( fieldName ) ) ) ; <nl> + assertEquals ( errMsg , 5 , dynRealm . where ( className ) . count ( ) ) ; <nl> + <nl> + / / Cleanup <nl> + dynRealm . delete ( className ) ; <nl> + schema . removeField ( fieldName ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Table . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Table . cpp <nl> index d85ad5e . . 077b0de 100644 <nl> - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Table . cpp <nl> + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Table . cpp <nl> @ @ - 215 , 10 + 215 , 13 @ @ JNIEXPORT jboolean JNICALL Java _ io _ realm _ internal _ Table _ nativeIsColumnNullable ( J <nl> / / 4d . the column to be converted will index shifted one place to column _ index + 1 <nl> / / 5 . search indexing must be preserved <nl> / / 6 . removing the original column and renaming the temporary column will make it look like original is being modified <nl> + / / <nl> + / / WARNING : These methods do NOT work on primary key columns if the Realm is synchronized . <nl> + / / <nl> <nl> / / Converts a table to allow for nullable values <nl> / / Works on both normal table columns and sub tables <nl> - static void convert _ column _ to _ nullable ( JNIEnv * env , Table * old _ table , size _ t old _ col _ ndx , Table * new _ table , size _ t new _ col _ ndx , bool is _ primary _ key ) <nl> + static void convert _ column _ to _ nullable ( JNIEnv * env , Table * old _ table , size _ t old _ col _ ndx , Table * new _ table , size _ t new _ col _ ndx ) <nl> { <nl> DataType column _ type = old _ table - > get _ column _ type ( old _ col _ ndx ) ; <nl> if ( old _ table ! = new _ table ) { <nl> @ @ - 229 , 12 + 232 , 7 @ @ static void convert _ column _ to _ nullable ( JNIEnv * env , Table * old _ table , size _ t old <nl> case type _ String : { <nl> / / Payload copy is needed <nl> StringData sd ( old _ table - > get _ string ( old _ col _ ndx , i ) ) ; <nl> - if ( is _ primary _ key ) { <nl> - new _ table - > set _ string _ unique ( new _ col _ ndx , i , sd ) ; <nl> - } <nl> - else { <nl> - new _ table - > set _ string ( new _ col _ ndx , i , sd ) ; <nl> - } <nl> + new _ table - > set _ string ( new _ col _ ndx , i , sd ) ; <nl> break ; <nl> } <nl> case type _ Binary : { <nl> @ @ - 243 , 12 + 241 , 7 @ @ static void convert _ column _ to _ nullable ( JNIEnv * env , Table * old _ table , size _ t old <nl> break ; <nl> } <nl> case type _ Int : <nl> - if ( is _ primary _ key ) { <nl> - new _ table - > set _ int _ unique ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; <nl> - } <nl> - else { <nl> - new _ table - > set _ int ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; <nl> - } <nl> + new _ table - > set _ int ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; <nl> break ; <nl> case type _ Bool : <nl> new _ table - > set _ bool ( new _ col _ ndx , i , old _ table - > get _ bool ( old _ col _ ndx , i ) ) ; <nl> @ @ - 313 , 8 + 306 , 11 @ @ static void create _ new _ column ( Table * table , size _ t column _ index , bool nullable ) <nl> JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeConvertColumnToNullable ( JNIEnv * env , jobject obj , <nl> jlong native _ table _ ptr , <nl> jlong j _ column _ index , <nl> - jboolean is _ primary _ key ) <nl> + jboolean ) <nl> { <nl> + # if REALM _ ENABLE _ SYNC <nl> + REALM _ ASSERT ( false ) ; <nl> + # endif <nl> Table * table = TBL ( native _ table _ ptr ) ; <nl> if ( ! TBL _ AND _ COL _ INDEX _ VALID ( env , table , j _ column _ index ) ) { <nl> return ; <nl> @ @ - 352 , 11 + 348 , 11 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeConvertColumnToNullabl <nl> for ( size _ t i = 0 ; i < table - > size ( ) ; + + i ) { <nl> TableRef new _ subtable = table - > get _ subtable ( column _ index , i ) ; <nl> TableRef old _ subtable = table - > get _ subtable ( column _ index + 1 , i ) ; <nl> - convert _ column _ to _ nullable ( env , old _ subtable . get ( ) , 0 , new _ subtable . get ( ) , 0 , is _ primary _ key ) ; <nl> + convert _ column _ to _ nullable ( env , old _ subtable . get ( ) , 0 , new _ subtable . get ( ) , 0 ) ; <nl> } <nl> } <nl> else { <nl> - convert _ column _ to _ nullable ( env , table , column _ index + 1 , table , column _ index , is _ primary _ key ) ; <nl> + convert _ column _ to _ nullable ( env , table , column _ index + 1 , table , column _ index ) ; <nl> } <nl> <nl> / / Cleanup <nl> @ @ - 373 , 12 + 369 , 14 @ @ static void convert _ column _ to _ not _ nullable ( JNIEnv * env , Table * old _ table , size _ t <nl> { <nl> DataType column _ type = old _ table - > get _ column _ type ( old _ col _ ndx ) ; <nl> std : : string column _ name = old _ table - > get _ column _ name ( old _ col _ ndx ) ; <nl> + size _ t no _ rows = old _ table - > size ( ) ; <nl> if ( old _ table ! = new _ table ) { <nl> - new _ table - > add _ empty _ row ( old _ table - > size ( ) ) ; <nl> + new _ table - > add _ empty _ row ( no _ rows ) ; <nl> } <nl> - for ( size _ t i = 0 ; i < old _ table - > size ( ) ; + + i ) { <nl> + for ( size _ t i = 0 ; i < no _ rows ; + + i ) { <nl> switch ( column _ type ) { / / FIXME : respect user - specified default values <nl> case type _ String : { <nl> + / / Payload copy is needed <nl> StringData sd = old _ table - > get _ string ( old _ col _ ndx , i ) ; <nl> if ( sd = = realm : : null ( ) ) { <nl> if ( is _ primary _ key ) { <nl> @ @ - 390 , 13 + 388 , 7 @ @ static void convert _ column _ to _ not _ nullable ( JNIEnv * env , Table * old _ table , size _ t <nl> } <nl> } <nl> else { <nl> - / / Payload copy is needed <nl> - if ( is _ primary _ key ) { <nl> - new _ table - > set _ string _ unique ( new _ col _ ndx , i , sd ) ; <nl> - } <nl> - else { <nl> - new _ table - > set _ string ( new _ col _ ndx , i , sd ) ; <nl> - } <nl> + new _ table - > set _ string ( new _ col _ ndx , i , sd ) ; <nl> } <nl> break ; <nl> } <nl> @ @ - 423 , 12 + 415 , 7 @ @ static void convert _ column _ to _ not _ nullable ( JNIEnv * env , Table * old _ table , size _ t <nl> } <nl> } <nl> else { <nl> - if ( is _ primary _ key ) { <nl> - new _ table - > set _ int _ unique ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; <nl> - } <nl> - else { <nl> - new _ table - > set _ int ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; <nl> - } <nl> + new _ table - > set _ int ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; <nl> } <nl> break ; <nl> case type _ Bool : <nl> @ @ - 483 , 6 + 470 , 9 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeConvertColumnToNotNull <nl> jlong j _ column _ index , <nl> jboolean is _ primary _ key ) <nl> { <nl> + # if REALM _ ENABLE _ SYNC <nl> + REALM _ ASSERT ( false ) ; <nl> + # endif <nl> try { <nl> Table * table = TBL ( native _ table _ ptr ) ; <nl> if ( ! TBL _ AND _ COL _ INDEX _ VALID ( env , table , j _ column _ index ) ) { <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / OsSharedRealm . java b / realm / realm - library / src / main / java / io / realm / internal / OsSharedRealm . java <nl> index b897c13 . . e9be90c 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / OsSharedRealm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / OsSharedRealm . java <nl> @ @ - 445 , 12 + 445 , 20 @ @ public final class OsSharedRealm implements Closeable , NativeObject { <nl> } <nl> <nl> / * * <nl> - * Returns { @ code true } if this Realm is a partially synchronized Realm . <nl> + * Returns { @ code true } if this Realm is a query - based synchronized Realm . <nl> * / <nl> public boolean isPartial ( ) { <nl> return nativeIsPartial ( nativePtr ) ; <nl> } <nl> <nl> + / * * <nl> + * Returns { @ code true } if this Realm is a synchronized Realm , either query - based or fully <nl> + * synchronized . <nl> + * / <nl> + public boolean isSyncRealm ( ) { <nl> + return osRealmConfig . getResolvedRealmURI ( ) ! = null ; <nl> + } <nl> + <nl> / / addIterator ( ) , detachIterators ( ) and invalidateIterators ( ) are used to make RealmResults stable iterators work . <nl> / / The iterator will iterate on a snapshot Results if it is accessed inside a transaction . <nl> / / See https : / / github . com / realm / realm - java / issues / 3883 for more information . <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / Table . java b / realm / realm - library / src / main / java / io / realm / internal / Table . java <nl> index 533603d . . 063e580 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / Table . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / Table . java <nl> @ @ - 226 , 6 + 226 , 9 @ @ public class Table implements NativeObject { <nl> * @ param columnIndex the column index . <nl> * / <nl> public void convertColumnToNullable ( long columnIndex ) { <nl> + if ( sharedRealm . isSyncRealm ( ) ) { <nl> + throw new IllegalStateException ( " This method is only available for non - synchronized Realms " ) ; <nl> + } <nl> nativeConvertColumnToNullable ( nativePtr , columnIndex , isPrimaryKey ( columnIndex ) ) ; <nl> } <nl> <nl> @ @ - 235 , 6 + 238 , 9 @ @ public class Table implements NativeObject { <nl> * @ param columnIndex the column index . <nl> * / <nl> public void convertColumnToNotNullable ( long columnIndex ) { <nl> + if ( sharedRealm . isSyncRealm ( ) ) { <nl> + throw new IllegalStateException ( " This method is only available for non - synchronized Realms " ) ; <nl> + } <nl> nativeConvertColumnToNotNullable ( nativePtr , columnIndex , isPrimaryKey ( columnIndex ) ) ; <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / realm - jni / src / io _ realm _ internal _ Table . h b / realm - jni / src / io _ realm _ internal _ Table . h <nl> index ed35d0e . . c5212e7 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ Table . h <nl> + + + b / realm - jni / src / io _ realm _ internal _ Table . h <nl> @ @ - 9 , 6 + 9 , 14 @ @ extern " C " { <nl> # endif <nl> # undef io _ realm _ internal _ Table _ INFINITE <nl> # define io _ realm _ internal _ Table _ INFINITE - 1LL <nl> + # undef io _ realm _ internal _ Table _ INTEGER _ DEFAULT _ VALUE <nl> + # define io _ realm _ internal _ Table _ INTEGER _ DEFAULT _ VALUE 0LL <nl> + # undef io _ realm _ internal _ Table _ PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX <nl> + # define io _ realm _ internal _ Table _ PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX 0LL <nl> + # undef io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX <nl> + # define io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX 1LL <nl> + # undef io _ realm _ internal _ Table _ NO _ PRIMARY _ KEY <nl> + # define io _ realm _ internal _ Table _ NO _ PRIMARY _ KEY - 2LL <nl> / * <nl> * Class : io _ realm _ internal _ Table <nl> * Method : createNative <nl> @ @ - 491 , 6 + 499 , 14 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeAddInt <nl> <nl> / * <nl> * Class : io _ realm _ internal _ Table <nl> + * Method : nativeSetPrimaryKey <nl> + * Signature : ( JJLjava / lang / String ; ) J <nl> + * / <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeSetPrimaryKey <nl> + ( JNIEnv * , jobject , jlong , jlong , jstring ) ; <nl> + <nl> + / * <nl> + * Class : io _ realm _ internal _ Table <nl> * Method : nativeSetIndex <nl> * Signature : ( JJ ) V <nl> * / <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ table . cpp b / realm - jni / src / io _ realm _ internal _ table . cpp <nl> index 41863ca . . cd5f56a 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ table . cpp <nl> + + + b / realm - jni / src / io _ realm _ internal _ table . cpp <nl> @ @ - 1385 , 3 + 1385 , 100 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ createNative ( JNIEnv * env , j <nl> } CATCH _ STD ( ) <nl> return 0 ; <nl> } <nl> + <nl> + <nl> + / / Checks if the primary key column contains any duplicate values , making it ineligible as a <nl> + / / primary key . <nl> + bool check _ valid _ primary _ key _ column ( JNIEnv * env , Table * table , size _ t column _ index ) / / throws <nl> + { <nl> + int column _ type = table - > get _ column _ type ( column _ index ) ; <nl> + TableView results = table - > get _ sorted _ view ( column _ index ) ; <nl> + <nl> + switch ( column _ type ) { <nl> + case type _ Int : <nl> + if ( results . size ( ) > 1 ) { <nl> + int64 _ t val = results . get _ int ( column _ index , 0 ) ; <nl> + for ( size _ t i = 1 ; i < results . size ( ) ; i + + ) { <nl> + int64 _ t next _ val = results . get _ int ( column _ index , i ) ; <nl> + if ( val = = next _ val ) { <nl> + std : : ostringstream error _ msg ; <nl> + error _ msg < < " Field \ " " < < table - > get _ column _ name ( column _ index ) . data ( ) < < " \ " cannot be a primary key , " ; <nl> + error _ msg < < " it already contains duplicate values : " < < val ; <nl> + ThrowException ( env , IllegalArgument , error _ msg . str ( ) ) ; <nl> + return false ; <nl> + } else { <nl> + val = next _ val ; <nl> + } <nl> + } <nl> + } <nl> + break ; <nl> + <nl> + case type _ String : <nl> + if ( results . size ( ) > 1 ) { <nl> + string str = results . get _ string ( column _ index , 0 ) ; <nl> + for ( size _ t i = 1 ; i < results . size ( ) ; i + + ) { <nl> + string next _ str = results . get _ string ( column _ index , i ) ; <nl> + if ( str . compare ( next _ str ) = = 0 ) { <nl> + std : : ostringstream error _ msg ; <nl> + error _ msg < < " Field \ " " < < table - > get _ column _ name ( column _ index ) . data ( ) < < " \ " cannot be a primary key , " ; <nl> + error _ msg < < " it already contains duplicate values : " < < str ; <nl> + ThrowException ( env , IllegalArgument , error _ msg . str ( ) ) ; <nl> + return false ; <nl> + } else { <nl> + str = next _ str ; <nl> + } <nl> + } <nl> + } <nl> + break ; <nl> + <nl> + default : <nl> + ThrowException ( env , IllegalArgument , " Invalid primary key type : " + column _ type ) ; <nl> + return false ; <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeSetPrimaryKey ( <nl> + JNIEnv * env , jobject , jlong nativePrivateKeyTablePtr , jlong nativeTablePtr , jstring columnName ) <nl> + { <nl> + try { <nl> + Table * table = TBL ( nativeTablePtr ) ; <nl> + Table * pk _ table = TBL ( nativePrivateKeyTablePtr ) ; <nl> + const string table _ name = table - > get _ name ( ) ; <nl> + size _ t row _ index = pk _ table - > find _ first _ string ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX , table _ name ) ; <nl> + <nl> + / / I <nl> + if ( columnName = = NULL | | env - > GetStringLength ( columnName ) = = 0 ) { <nl> + / / No primary key set . Remove any previous set keys <nl> + if ( row _ index ! = tightdb : : not _ found ) { <nl> + pk _ table - > remove ( row _ index ) ; <nl> + } <nl> + return jlong ( io _ realm _ internal _ Table _ NO _ PRIMARY _ KEY ) ; <nl> + } else { <nl> + JStringAccessor columnName2 ( env , columnName ) ; <nl> + size _ t primary _ key _ column _ index = table - > get _ column _ index ( columnName2 ) ; <nl> + if ( row _ index = = tightdb : : not _ found ) { <nl> + / / No primary key is currently set <nl> + if ( check _ valid _ primary _ key _ column ( env , table , primary _ key _ column _ index ) ) { <nl> + row _ index = pk _ table - > add _ empty _ row ( ) ; <nl> + pk _ table - > set _ string ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX , row _ index , table _ name ) ; <nl> + pk _ table - > set _ int ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX , row _ index , primary _ key _ column _ index ) ; <nl> + } <nl> + } else { <nl> + / / Primary key already exists <nl> + / / We only wish to check for duplicate values if a column isn ' t already a primary key <nl> + Row * row = new Row ( ( * pk _ table ) [ row _ index ] ) ; <nl> + size _ t current _ primary _ key = row - > get _ int ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX ) ; <nl> + if ( primary _ key _ column _ index ! = current _ primary _ key ) { <nl> + if ( check _ valid _ primary _ key _ column ( env , table , primary _ key _ column _ index ) ) { <nl> + pk _ table - > set _ int ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX , row _ index , primary _ key _ column _ index ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + return jlong ( primary _ key _ column _ index ) ; <nl> + } <nl> + } CATCH _ STD ( ) <nl> + return 0 ; <nl> + } <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmAnnotationTest . java b / realm / src / androidTest / java / io / realm / RealmAnnotationTest . java <nl> index d661983 . . 65a249c 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmAnnotationTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAnnotationTest . java <nl> @ @ - 89 , 7 + 89 , 7 @ @ public class RealmAnnotationTest extends AndroidTestCase { <nl> try { <nl> table . setPrimaryKey ( " id " ) ; <nl> fail ( " It should not be possible to set a primary key column which already contains duplicate values . " ) ; <nl> - } catch ( RealmException expected ) { <nl> + } catch ( IllegalArgumentException expected ) { <nl> assertEquals ( 0 , table . getPrimaryKey ( ) ) ; <nl> } finally { <nl> testRealm . cancelTransaction ( ) ; <nl> @ @ - 124 , 7 + 124 , 7 @ @ public class RealmAnnotationTest extends AndroidTestCase { <nl> try { <nl> table . setPrimaryKey ( " name " ) ; <nl> fail ( " It should not be possible to set a primary key column which already contains duplicate values . " ) ; <nl> - } catch ( RealmException expected ) { <nl> + } catch ( IllegalArgumentException expected ) { <nl> assertEquals ( 0 , table . getPrimaryKey ( ) ) ; <nl> } finally { <nl> testRealm . cancelTransaction ( ) ; <nl> diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java <nl> index 00d0942 . . 42d28b0 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / Table . java <nl> + + + b / realm / src / main / java / io / realm / internal / Table . java <nl> @ @ - 626 , 7 + 626 , 7 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> * @ return Column index or { @ code # NO _ MATCH } if no primary key is set . <nl> * / <nl> public long getPrimaryKey ( ) { <nl> - if ( cachedPrimaryKeyColumnIndex > 0 | | cachedPrimaryKeyColumnIndex = = NO _ PRIMARY _ KEY ) { <nl> + if ( cachedPrimaryKeyColumnIndex > = 0 | | cachedPrimaryKeyColumnIndex = = NO _ PRIMARY _ KEY ) { <nl> return cachedPrimaryKeyColumnIndex ; <nl> } else { <nl> Table pkTable = getPrimaryKeyTable ( ) ; <nl> @ @ - 687 , 10 + 687 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> throw new RealmException ( " Primary key constraint broken . Value already exists : " + value ) ; <nl> } <nl> <nl> - private void throwInvalidPrimaryKeyColumn ( long columnIndex , Object value ) { <nl> - throw new RealmException ( String . format ( " Field \ " % s \ " cannot be a primary key , it already contains duplicate values : % s " , getColumnName ( columnIndex ) , value ) ) ; <nl> - } <nl> - <nl> / / Holds methods that must be publicly available for AbstractClass . <nl> / / Should not be called when using the dynamic interface . The methods can be accessed by calling getInternalMethods ( ) in Table class <nl> public class InternalMethods { <nl> @ @ - 1137 , 73 + 1133 , 11 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> if ( pkTable = = null ) { <nl> throw new RealmException ( " Primary keys are only supported if Table is part of a Group " ) ; <nl> } <nl> - <nl> - long rowIndex = pkTable . findFirstString ( PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX , getName ( ) ) ; <nl> - if ( columnName = = null | | columnName . equals ( " " ) ) { <nl> - if ( rowIndex > 0 ) { <nl> - pkTable . remove ( rowIndex ) ; <nl> - } <nl> - cachedPrimaryKeyColumnIndex = NO _ PRIMARY _ KEY ; <nl> - } else { <nl> - long primaryKeyColumnIndex = getColumnIndex ( columnName ) ; <nl> - if ( rowIndex = = NO _ MATCH ) { <nl> - / / No primary key is currently set <nl> - checkIsValidPrimaryKeyColumn ( primaryKeyColumnIndex ) ; <nl> - pkTable . add ( getName ( ) , primaryKeyColumnIndex ) ; <nl> - } else { <nl> - / / Primary key already exists <nl> - / / We only wish to check for duplicate values if a column isn ' t already a primary key <nl> - long currentPrimaryKey = pkTable . getRow ( rowIndex ) . getLong ( PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX ) ; <nl> - if ( primaryKeyColumnIndex ! = currentPrimaryKey ) { <nl> - checkIsValidPrimaryKeyColumn ( primaryKeyColumnIndex ) ; <nl> - pkTable . setLong ( PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX , rowIndex , primaryKeyColumnIndex ) ; <nl> - } <nl> - } <nl> - <nl> - cachedPrimaryKeyColumnIndex = primaryKeyColumnIndex ; <nl> - } <nl> + long index = nativeSetPrimaryKey ( pkTable . nativePtr , nativePtr , columnName ) ; <nl> + cachedPrimaryKeyColumnIndex = index ; <nl> } <nl> <nl> - / / Checks if the primary key column contains any duplicate values , making it ineligible as a <nl> - / / primary key . <nl> - private void checkIsValidPrimaryKeyColumn ( long columnIndex ) { <nl> - ColumnType columnType = getColumnType ( columnIndex ) ; <nl> - TableView result = where ( ) . findAll ( ) ; <nl> - result . sort ( columnIndex ) ; <nl> - <nl> - switch ( columnType ) { <nl> - case INTEGER : <nl> - if ( result . size ( ) > 1 ) { <nl> - long value = result . getLong ( columnIndex , 0 ) ; <nl> - for ( long i = 1 ; i < result . size ( ) ; i + + ) { <nl> - long nextValue = result . getLong ( columnIndex , i ) ; <nl> - if ( value = = nextValue ) { <nl> - throwInvalidPrimaryKeyColumn ( columnIndex , value ) ; <nl> - } else { <nl> - value = nextValue ; <nl> - } <nl> - } <nl> - } <nl> - break ; <nl> - <nl> - case STRING : <nl> - if ( result . size ( ) > 1 ) { <nl> - String str = result . getString ( columnIndex , 0 ) ; <nl> - for ( int i = 1 ; i < result . size ( ) ; i + + ) { <nl> - String nextStr = result . getString ( columnIndex , i ) ; <nl> - if ( str . equals ( nextStr ) ) { <nl> - throwInvalidPrimaryKeyColumn ( columnIndex , str ) ; <nl> - } else { <nl> - str = nextStr ; <nl> - } <nl> - } <nl> - } <nl> - break ; <nl> - <nl> - default : <nl> - throw new RealmException ( " Invalid primary key type : " + columnType ) ; <nl> - } <nl> - } <nl> + private native long nativeSetPrimaryKey ( long privateKeyTableNativePtr , long nativePtr , String columnName ) ; <nl> <nl> private Table getPrimaryKeyTable ( ) { <nl> Group group = getTableGroup ( ) ;

TEST DIFF:
diff - - git a / CHANGELOG . md b / CHANGELOG . md 
 index d86e153 . . f7b9e6c 100644 
 - - - a / CHANGELOG . md 
 + + + b / CHANGELOG . md 
 @ @ - 1 , 3 + 1 , 10 @ @ 
 + # # 5 . 0 . 2 ( YYYY - MM - DD ) 
 + 
 + # # # Bug Fixes 
 + 
 + * Changing a primary key from being nullable to being required could result in objects being deleted ( # # 5899 ) . 
 + 
 + 
 # # 5 . 0 . 1 ( 2018 - 04 - 09 ) 
 
 # # # Enhancements 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java 
 index 74c3b6e . . 8ea8719 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java 
 @ @ - 884 , 7 + 884 , 7 @ @ public class RealmObjectSchemaTests { 
 assertEquals ( 0 , list . get ( 0 ) . length ) ; 
 assertArrayEquals ( new byte [ ] { 1 , 2 , 3 } , list . get ( 1 ) ) ; 
 } 
 - 
 + 
 @ Test 
 public void setRequired _ true _ onPrimaryKeyField _ containsNullValues _ shouldThrow ( ) { 
 if ( type = = ObjectSchemaType . IMMUTABLE ) { 
 @ @ - 1349 , 4 + 1349 , 39 @ @ public class RealmObjectSchemaTests { 
 private interface FieldRunnable { 
 void run ( String fieldName ) ; 
 } 
 + 
 + / / Tests https : / / github . com / realm / realm - studio / issues / 5899 
 + @ Test 
 + public void setRequired _ keepExistingRowsIfPrimaryKey ( ) { 
 + if ( type = = ObjectSchemaType . IMMUTABLE ) { 
 + return ; 
 + } 
 + DynamicRealm dynRealm = ( DynamicRealm ) realm ; 
 + String className = " NewClass " ; 
 + String fieldName = " field " ; 
 + 
 + / / Check all primary key types 
 + for ( PrimaryKeyFieldType fieldType : PrimaryKeyFieldType . values ( ) ) { 
 + schema . addField ( fieldName , fieldType . getType ( ) , FieldAttribute . PRIMARY _ KEY ) ; / / primary key field 
 + 
 + / / Hackish way to add sample data , only treat string differently 
 + for ( int i = 0 ; i < 5 ; i + + ) { 
 + Object primaryKeyValue = ( fieldType . getType ( ) = = String . class ) ? Integer . toString ( i ) : i ; 
 + dynRealm . createObject ( className , primaryKeyValue ) ; 
 + } 
 + 
 + / / Verify that sample data is intact before swapping nullability state 
 + String errMsg = String . format ( String . format ( " Count mismatch for FieldType = % s and Nullable = % s " , fieldType . getType ( ) , schema . isNullable ( fieldName ) ) ) ; 
 + assertEquals ( errMsg , 5 , dynRealm . where ( className ) . count ( ) ) ; 
 + 
 + / / Swap nullability state 
 + schema . setRequired ( fieldName , ! schema . isRequired ( fieldName ) ) ; 
 + errMsg = String . format ( String . format ( " Count mismatch for FieldType = % s and Nullable = % s " , fieldType . getType ( ) , schema . isNullable ( fieldName ) ) ) ; 
 + assertEquals ( errMsg , 5 , dynRealm . where ( className ) . count ( ) ) ; 
 + 
 + / / Cleanup 
 + dynRealm . delete ( className ) ; 
 + schema . removeField ( fieldName ) ; 
 + } 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Table . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Table . cpp 
 index d85ad5e . . 077b0de 100644 
 - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Table . cpp 
 + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Table . cpp 
 @ @ - 215 , 10 + 215 , 13 @ @ JNIEXPORT jboolean JNICALL Java _ io _ realm _ internal _ Table _ nativeIsColumnNullable ( J 
 / / 4d . the column to be converted will index shifted one place to column _ index + 1 
 / / 5 . search indexing must be preserved 
 / / 6 . removing the original column and renaming the temporary column will make it look like original is being modified 
 + / / 
 + / / WARNING : These methods do NOT work on primary key columns if the Realm is synchronized . 
 + / / 
 
 / / Converts a table to allow for nullable values 
 / / Works on both normal table columns and sub tables 
 - static void convert _ column _ to _ nullable ( JNIEnv * env , Table * old _ table , size _ t old _ col _ ndx , Table * new _ table , size _ t new _ col _ ndx , bool is _ primary _ key ) 
 + static void convert _ column _ to _ nullable ( JNIEnv * env , Table * old _ table , size _ t old _ col _ ndx , Table * new _ table , size _ t new _ col _ ndx ) 
 { 
 DataType column _ type = old _ table - > get _ column _ type ( old _ col _ ndx ) ; 
 if ( old _ table ! = new _ table ) { 
 @ @ - 229 , 12 + 232 , 7 @ @ static void convert _ column _ to _ nullable ( JNIEnv * env , Table * old _ table , size _ t old 
 case type _ String : { 
 / / Payload copy is needed 
 StringData sd ( old _ table - > get _ string ( old _ col _ ndx , i ) ) ; 
 - if ( is _ primary _ key ) { 
 - new _ table - > set _ string _ unique ( new _ col _ ndx , i , sd ) ; 
 - } 
 - else { 
 - new _ table - > set _ string ( new _ col _ ndx , i , sd ) ; 
 - } 
 + new _ table - > set _ string ( new _ col _ ndx , i , sd ) ; 
 break ; 
 } 
 case type _ Binary : { 
 @ @ - 243 , 12 + 241 , 7 @ @ static void convert _ column _ to _ nullable ( JNIEnv * env , Table * old _ table , size _ t old 
 break ; 
 } 
 case type _ Int : 
 - if ( is _ primary _ key ) { 
 - new _ table - > set _ int _ unique ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; 
 - } 
 - else { 
 - new _ table - > set _ int ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; 
 - } 
 + new _ table - > set _ int ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; 
 break ; 
 case type _ Bool : 
 new _ table - > set _ bool ( new _ col _ ndx , i , old _ table - > get _ bool ( old _ col _ ndx , i ) ) ; 
 @ @ - 313 , 8 + 306 , 11 @ @ static void create _ new _ column ( Table * table , size _ t column _ index , bool nullable ) 
 JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeConvertColumnToNullable ( JNIEnv * env , jobject obj , 
 jlong native _ table _ ptr , 
 jlong j _ column _ index , 
 - jboolean is _ primary _ key ) 
 + jboolean ) 
 { 
 + # if REALM _ ENABLE _ SYNC 
 + REALM _ ASSERT ( false ) ; 
 + # endif 
 Table * table = TBL ( native _ table _ ptr ) ; 
 if ( ! TBL _ AND _ COL _ INDEX _ VALID ( env , table , j _ column _ index ) ) { 
 return ; 
 @ @ - 352 , 11 + 348 , 11 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeConvertColumnToNullabl 
 for ( size _ t i = 0 ; i < table - > size ( ) ; + + i ) { 
 TableRef new _ subtable = table - > get _ subtable ( column _ index , i ) ; 
 TableRef old _ subtable = table - > get _ subtable ( column _ index + 1 , i ) ; 
 - convert _ column _ to _ nullable ( env , old _ subtable . get ( ) , 0 , new _ subtable . get ( ) , 0 , is _ primary _ key ) ; 
 + convert _ column _ to _ nullable ( env , old _ subtable . get ( ) , 0 , new _ subtable . get ( ) , 0 ) ; 
 } 
 } 
 else { 
 - convert _ column _ to _ nullable ( env , table , column _ index + 1 , table , column _ index , is _ primary _ key ) ; 
 + convert _ column _ to _ nullable ( env , table , column _ index + 1 , table , column _ index ) ; 
 } 
 
 / / Cleanup 
 @ @ - 373 , 12 + 369 , 14 @ @ static void convert _ column _ to _ not _ nullable ( JNIEnv * env , Table * old _ table , size _ t 
 { 
 DataType column _ type = old _ table - > get _ column _ type ( old _ col _ ndx ) ; 
 std : : string column _ name = old _ table - > get _ column _ name ( old _ col _ ndx ) ; 
 + size _ t no _ rows = old _ table - > size ( ) ; 
 if ( old _ table ! = new _ table ) { 
 - new _ table - > add _ empty _ row ( old _ table - > size ( ) ) ; 
 + new _ table - > add _ empty _ row ( no _ rows ) ; 
 } 
 - for ( size _ t i = 0 ; i < old _ table - > size ( ) ; + + i ) { 
 + for ( size _ t i = 0 ; i < no _ rows ; + + i ) { 
 switch ( column _ type ) { / / FIXME : respect user - specified default values 
 case type _ String : { 
 + / / Payload copy is needed 
 StringData sd = old _ table - > get _ string ( old _ col _ ndx , i ) ; 
 if ( sd = = realm : : null ( ) ) { 
 if ( is _ primary _ key ) { 
 @ @ - 390 , 13 + 388 , 7 @ @ static void convert _ column _ to _ not _ nullable ( JNIEnv * env , Table * old _ table , size _ t 
 } 
 } 
 else { 
 - / / Payload copy is needed 
 - if ( is _ primary _ key ) { 
 - new _ table - > set _ string _ unique ( new _ col _ ndx , i , sd ) ; 
 - } 
 - else { 
 - new _ table - > set _ string ( new _ col _ ndx , i , sd ) ; 
 - } 
 + new _ table - > set _ string ( new _ col _ ndx , i , sd ) ; 
 } 
 break ; 
 } 
 @ @ - 423 , 12 + 415 , 7 @ @ static void convert _ column _ to _ not _ nullable ( JNIEnv * env , Table * old _ table , size _ t 
 } 
 } 
 else { 
 - if ( is _ primary _ key ) { 
 - new _ table - > set _ int _ unique ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; 
 - } 
 - else { 
 - new _ table - > set _ int ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; 
 - } 
 + new _ table - > set _ int ( new _ col _ ndx , i , old _ table - > get _ int ( old _ col _ ndx , i ) ) ; 
 } 
 break ; 
 case type _ Bool : 
 @ @ - 483 , 6 + 470 , 9 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeConvertColumnToNotNull 
 jlong j _ column _ index , 
 jboolean is _ primary _ key ) 
 { 
 + # if REALM _ ENABLE _ SYNC 
 + REALM _ ASSERT ( false ) ; 
 + # endif 
 try { 
 Table * table = TBL ( native _ table _ ptr ) ; 
 if ( ! TBL _ AND _ COL _ INDEX _ VALID ( env , table , j _ column _ index ) ) { 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / OsSharedRealm . java b / realm / realm - library / src / main / java / io / realm / internal / OsSharedRealm . java 
 index b897c13 . . e9be90c 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / OsSharedRealm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / OsSharedRealm . java 
 @ @ - 445 , 12 + 445 , 20 @ @ public final class OsSharedRealm implements Closeable , NativeObject { 
 } 
 
 / * * 
 - * Returns { @ code true } if this Realm is a partially synchronized Realm . 
 + * Returns { @ code true } if this Realm is a query - based synchronized Realm . 
 * / 
 public boolean isPartial ( ) { 
 return nativeIsPartial ( nativePtr ) ; 
 } 
 
 + / * * 
 + * Returns { @ code true } if this Realm is a synchronized Realm , either query - based or fully 
 + * synchronized . 
 + * / 
 + public boolean isSyncRealm ( ) { 
 + return osRealmConfig . getResolvedRealmURI ( ) ! = null ; 
 + } 
 + 
 / / addIterator ( ) , detachIterators ( ) and invalidateIterators ( ) are used to make RealmResults stable iterators work . 
 / / The iterator will iterate on a snapshot Results if it is accessed inside a transaction . 
 / / See https : / / github . com / realm / realm - java / issues / 3883 for more information . 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / Table . java b / realm / realm - library / src / main / java / io / realm / internal / Table . java 
 index 533603d . . 063e580 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / Table . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / Table . java 
 @ @ - 226 , 6 + 226 , 9 @ @ public class Table implements NativeObject { 
 * @ param columnIndex the column index . 
 * / 
 public void convertColumnToNullable ( long columnIndex ) { 
 + if ( sharedRealm . isSyncRealm ( ) ) { 
 + throw new IllegalStateException ( " This method is only available for non - synchronized Realms " ) ; 
 + } 
 nativeConvertColumnToNullable ( nativePtr , columnIndex , isPrimaryKey ( columnIndex ) ) ; 
 } 
 
 @ @ - 235 , 6 + 238 , 9 @ @ public class Table implements NativeObject { 
 * @ param columnIndex the column index . 
 * / 
 public void convertColumnToNotNullable ( long columnIndex ) { 
 + if ( sharedRealm . isSyncRealm ( ) ) { 
 + throw new IllegalStateException ( " This method is only available for non - synchronized Realms " ) ; 
 + } 
 nativeConvertColumnToNotNullable ( nativePtr , columnIndex , isPrimaryKey ( columnIndex ) ) ; 
 } 


NEAREST DIFF:
diff - - git a / realm - jni / src / io _ realm _ internal _ Table . h b / realm - jni / src / io _ realm _ internal _ Table . h 
 index ed35d0e . . c5212e7 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ Table . h 
 + + + b / realm - jni / src / io _ realm _ internal _ Table . h 
 @ @ - 9 , 6 + 9 , 14 @ @ extern " C " { 
 # endif 
 # undef io _ realm _ internal _ Table _ INFINITE 
 # define io _ realm _ internal _ Table _ INFINITE - 1LL 
 + # undef io _ realm _ internal _ Table _ INTEGER _ DEFAULT _ VALUE 
 + # define io _ realm _ internal _ Table _ INTEGER _ DEFAULT _ VALUE 0LL 
 + # undef io _ realm _ internal _ Table _ PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX 
 + # define io _ realm _ internal _ Table _ PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX 0LL 
 + # undef io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX 
 + # define io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX 1LL 
 + # undef io _ realm _ internal _ Table _ NO _ PRIMARY _ KEY 
 + # define io _ realm _ internal _ Table _ NO _ PRIMARY _ KEY - 2LL 
 / * 
 * Class : io _ realm _ internal _ Table 
 * Method : createNative 
 @ @ - 491 , 6 + 499 , 14 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeAddInt 
 
 / * 
 * Class : io _ realm _ internal _ Table 
 + * Method : nativeSetPrimaryKey 
 + * Signature : ( JJLjava / lang / String ; ) J 
 + * / 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeSetPrimaryKey 
 + ( JNIEnv * , jobject , jlong , jlong , jstring ) ; 
 + 
 + / * 
 + * Class : io _ realm _ internal _ Table 
 * Method : nativeSetIndex 
 * Signature : ( JJ ) V 
 * / 
 diff - - git a / realm - jni / src / io _ realm _ internal _ table . cpp b / realm - jni / src / io _ realm _ internal _ table . cpp 
 index 41863ca . . cd5f56a 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ table . cpp 
 + + + b / realm - jni / src / io _ realm _ internal _ table . cpp 
 @ @ - 1385 , 3 + 1385 , 100 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ createNative ( JNIEnv * env , j 
 } CATCH _ STD ( ) 
 return 0 ; 
 } 
 + 
 + 
 + / / Checks if the primary key column contains any duplicate values , making it ineligible as a 
 + / / primary key . 
 + bool check _ valid _ primary _ key _ column ( JNIEnv * env , Table * table , size _ t column _ index ) / / throws 
 + { 
 + int column _ type = table - > get _ column _ type ( column _ index ) ; 
 + TableView results = table - > get _ sorted _ view ( column _ index ) ; 
 + 
 + switch ( column _ type ) { 
 + case type _ Int : 
 + if ( results . size ( ) > 1 ) { 
 + int64 _ t val = results . get _ int ( column _ index , 0 ) ; 
 + for ( size _ t i = 1 ; i < results . size ( ) ; i + + ) { 
 + int64 _ t next _ val = results . get _ int ( column _ index , i ) ; 
 + if ( val = = next _ val ) { 
 + std : : ostringstream error _ msg ; 
 + error _ msg < < " Field \ " " < < table - > get _ column _ name ( column _ index ) . data ( ) < < " \ " cannot be a primary key , " ; 
 + error _ msg < < " it already contains duplicate values : " < < val ; 
 + ThrowException ( env , IllegalArgument , error _ msg . str ( ) ) ; 
 + return false ; 
 + } else { 
 + val = next _ val ; 
 + } 
 + } 
 + } 
 + break ; 
 + 
 + case type _ String : 
 + if ( results . size ( ) > 1 ) { 
 + string str = results . get _ string ( column _ index , 0 ) ; 
 + for ( size _ t i = 1 ; i < results . size ( ) ; i + + ) { 
 + string next _ str = results . get _ string ( column _ index , i ) ; 
 + if ( str . compare ( next _ str ) = = 0 ) { 
 + std : : ostringstream error _ msg ; 
 + error _ msg < < " Field \ " " < < table - > get _ column _ name ( column _ index ) . data ( ) < < " \ " cannot be a primary key , " ; 
 + error _ msg < < " it already contains duplicate values : " < < str ; 
 + ThrowException ( env , IllegalArgument , error _ msg . str ( ) ) ; 
 + return false ; 
 + } else { 
 + str = next _ str ; 
 + } 
 + } 
 + } 
 + break ; 
 + 
 + default : 
 + ThrowException ( env , IllegalArgument , " Invalid primary key type : " + column _ type ) ; 
 + return false ; 
 + } 
 + 
 + return true ; 
 + } 
 + 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeSetPrimaryKey ( 
 + JNIEnv * env , jobject , jlong nativePrivateKeyTablePtr , jlong nativeTablePtr , jstring columnName ) 
 + { 
 + try { 
 + Table * table = TBL ( nativeTablePtr ) ; 
 + Table * pk _ table = TBL ( nativePrivateKeyTablePtr ) ; 
 + const string table _ name = table - > get _ name ( ) ; 
 + size _ t row _ index = pk _ table - > find _ first _ string ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX , table _ name ) ; 
 + 
 + / / I 
 + if ( columnName = = NULL | | env - > GetStringLength ( columnName ) = = 0 ) { 
 + / / No primary key set . Remove any previous set keys 
 + if ( row _ index ! = tightdb : : not _ found ) { 
 + pk _ table - > remove ( row _ index ) ; 
 + } 
 + return jlong ( io _ realm _ internal _ Table _ NO _ PRIMARY _ KEY ) ; 
 + } else { 
 + JStringAccessor columnName2 ( env , columnName ) ; 
 + size _ t primary _ key _ column _ index = table - > get _ column _ index ( columnName2 ) ; 
 + if ( row _ index = = tightdb : : not _ found ) { 
 + / / No primary key is currently set 
 + if ( check _ valid _ primary _ key _ column ( env , table , primary _ key _ column _ index ) ) { 
 + row _ index = pk _ table - > add _ empty _ row ( ) ; 
 + pk _ table - > set _ string ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX , row _ index , table _ name ) ; 
 + pk _ table - > set _ int ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX , row _ index , primary _ key _ column _ index ) ; 
 + } 
 + } else { 
 + / / Primary key already exists 
 + / / We only wish to check for duplicate values if a column isn ' t already a primary key 
 + Row * row = new Row ( ( * pk _ table ) [ row _ index ] ) ; 
 + size _ t current _ primary _ key = row - > get _ int ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX ) ; 
 + if ( primary _ key _ column _ index ! = current _ primary _ key ) { 
 + if ( check _ valid _ primary _ key _ column ( env , table , primary _ key _ column _ index ) ) { 
 + pk _ table - > set _ int ( io _ realm _ internal _ Table _ PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX , row _ index , primary _ key _ column _ index ) ; 
 + } 
 + } 
 + } 
 + 
 + return jlong ( primary _ key _ column _ index ) ; 
 + } 
 + } CATCH _ STD ( ) 
 + return 0 ; 
 + } 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmAnnotationTest . java b / realm / src / androidTest / java / io / realm / RealmAnnotationTest . java 
 index d661983 . . 65a249c 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmAnnotationTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmAnnotationTest . java 
 @ @ - 89 , 7 + 89 , 7 @ @ public class RealmAnnotationTest extends AndroidTestCase { 
 try { 
 table . setPrimaryKey ( " id " ) ; 
 fail ( " It should not be possible to set a primary key column which already contains duplicate values . " ) ; 
 - } catch ( RealmException expected ) { 
 + } catch ( IllegalArgumentException expected ) { 
 assertEquals ( 0 , table . getPrimaryKey ( ) ) ; 
 } finally { 
 testRealm . cancelTransaction ( ) ; 
 @ @ - 124 , 7 + 124 , 7 @ @ public class RealmAnnotationTest extends AndroidTestCase { 
 try { 
 table . setPrimaryKey ( " name " ) ; 
 fail ( " It should not be possible to set a primary key column which already contains duplicate values . " ) ; 
 - } catch ( RealmException expected ) { 
 + } catch ( IllegalArgumentException expected ) { 
 assertEquals ( 0 , table . getPrimaryKey ( ) ) ; 
 } finally { 
 testRealm . cancelTransaction ( ) ; 
 diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java 
 index 00d0942 . . 42d28b0 100644 
 - - - a / realm / src / main / java / io / realm / internal / Table . java 
 + + + b / realm / src / main / java / io / realm / internal / Table . java 
 @ @ - 626 , 7 + 626 , 7 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 * @ return Column index or { @ code # NO _ MATCH } if no primary key is set . 
 * / 
 public long getPrimaryKey ( ) { 
 - if ( cachedPrimaryKeyColumnIndex > 0 | | cachedPrimaryKeyColumnIndex = = NO _ PRIMARY _ KEY ) { 
 + if ( cachedPrimaryKeyColumnIndex > = 0 | | cachedPrimaryKeyColumnIndex = = NO _ PRIMARY _ KEY ) { 
 return cachedPrimaryKeyColumnIndex ; 
 } else { 
 Table pkTable = getPrimaryKeyTable ( ) ; 
 @ @ - 687 , 10 + 687 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 throw new RealmException ( " Primary key constraint broken . Value already exists : " + value ) ; 
 } 
 
 - private void throwInvalidPrimaryKeyColumn ( long columnIndex , Object value ) { 
 - throw new RealmException ( String . format ( " Field \ " % s \ " cannot be a primary key , it already contains duplicate values : % s " , getColumnName ( columnIndex ) , value ) ) ; 
 - } 
 - 
 / / Holds methods that must be publicly available for AbstractClass . 
 / / Should not be called when using the dynamic interface . The methods can be accessed by calling getInternalMethods ( ) in Table class 
 public class InternalMethods { 
 @ @ - 1137 , 73 + 1133 , 11 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 if ( pkTable = = null ) { 
 throw new RealmException ( " Primary keys are only supported if Table is part of a Group " ) ; 
 } 
 - 
 - long rowIndex = pkTable . findFirstString ( PRIMARY _ KEY _ CLASS _ COLUMN _ INDEX , getName ( ) ) ; 
 - if ( columnName = = null | | columnName . equals ( " " ) ) { 
 - if ( rowIndex > 0 ) { 
 - pkTable . remove ( rowIndex ) ; 
 - } 
 - cachedPrimaryKeyColumnIndex = NO _ PRIMARY _ KEY ; 
 - } else { 
 - long primaryKeyColumnIndex = getColumnIndex ( columnName ) ; 
 - if ( rowIndex = = NO _ MATCH ) { 
 - / / No primary key is currently set 
 - checkIsValidPrimaryKeyColumn ( primaryKeyColumnIndex ) ; 
 - pkTable . add ( getName ( ) , primaryKeyColumnIndex ) ; 
 - } else { 
 - / / Primary key already exists 
 - / / We only wish to check for duplicate values if a column isn ' t already a primary key 
 - long currentPrimaryKey = pkTable . getRow ( rowIndex ) . getLong ( PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX ) ; 
 - if ( primaryKeyColumnIndex ! = currentPrimaryKey ) { 
 - checkIsValidPrimaryKeyColumn ( primaryKeyColumnIndex ) ; 
 - pkTable . setLong ( PRIMARY _ KEY _ FIELD _ COLUMN _ INDEX , rowIndex , primaryKeyColumnIndex ) ; 
 - } 
 - } 
 - 
 - cachedPrimaryKeyColumnIndex = primaryKeyColumnIndex ; 
 - } 
 + long index = nativeSetPrimaryKey ( pkTable . nativePtr , nativePtr , columnName ) ; 
 + cachedPrimaryKeyColumnIndex = index ; 
 } 
 
 - / / Checks if the primary key column contains any duplicate values , making it ineligible as a 
 - / / primary key . 
 - private void checkIsValidPrimaryKeyColumn ( long columnIndex ) { 
 - ColumnType columnType = getColumnType ( columnIndex ) ; 
 - TableView result = where ( ) . findAll ( ) ; 
 - result . sort ( columnIndex ) ; 
 - 
 - switch ( columnType ) { 
 - case INTEGER : 
 - if ( result . size ( ) > 1 ) { 
 - long value = result . getLong ( columnIndex , 0 ) ; 
 - for ( long i = 1 ; i < result . size ( ) ; i + + ) { 
 - long nextValue = result . getLong ( columnIndex , i ) ; 
 - if ( value = = nextValue ) { 
 - throwInvalidPrimaryKeyColumn ( columnIndex , value ) ; 
 - } else { 
 - value = nextValue ; 
 - } 
 - } 
 - } 
 - break ; 
 - 
 - case STRING : 
 - if ( result . size ( ) > 1 ) { 
 - String str = result . getString ( columnIndex , 0 ) ; 
 - for ( int i = 1 ; i < result . size ( ) ; i + + ) { 
 - String nextStr = result . getString ( columnIndex , i ) ; 
 - if ( str . equals ( nextStr ) ) { 
 - throwInvalidPrimaryKeyColumn ( columnIndex , str ) ; 
 - } else { 
 - str = nextStr ; 
 - } 
 - } 
 - } 
 - break ; 
 - 
 - default : 
 - throw new RealmException ( " Invalid primary key type : " + columnType ) ; 
 - } 
 - } 
 + private native long nativeSetPrimaryKey ( long privateKeyTableNativePtr , long nativePtr , String columnName ) ; 
 
 private Table getPrimaryKeyTable ( ) { 
 Group group = getTableGroup ( ) ;
