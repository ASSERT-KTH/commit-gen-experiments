BLEU SCORE: 0.05095335964988338

TEST MSG: Add support for SyncSession . uploadAllLocalChanges ( )
GENERATED MSG: Fixed bug where copyToRealm ( ) crashed when copying objects with primary key data .

TEST DIFF (one line): diff - - git a / CHANGELOG . md b / CHANGELOG . md <nl> index a695fc6 . . 7b5246a 100644 <nl> - - - a / CHANGELOG . md <nl> + + + b / CHANGELOG . md <nl> @ @ - 2 , 6 + 2 , 8 @ @ <nl> <nl> # # # Enhancements <nl> <nl> + * [ ObjectServer ] Added ` SyncSession . uploadAllLocalChanges ( ) ` . <nl> + <nl> # # # Bug Fixes <nl> <nl> # # # Internal <nl> diff - - git a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java <nl> index acf65b4 . . 853d888 100644 <nl> - - - a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java <nl> + + + b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java <nl> @ @ - 16 , 6 + 16 , 8 @ @ <nl> <nl> package io . realm ; <nl> <nl> + import android . support . test . annotation . UiThreadTest ; <nl> + import android . support . test . rule . UiThreadTestRule ; <nl> import android . support . test . runner . AndroidJUnit4 ; <nl> <nl> import org . junit . Before ; <nl> @ @ - 23 , 6 + 25 , 8 @ @ import org . junit . Rule ; <nl> import org . junit . Test ; <nl> import org . junit . runner . RunWith ; <nl> <nl> + import io . realm . objectserver . utils . Constants ; <nl> + import io . realm . objectserver . utils . UserFactory ; <nl> import io . realm . rule . RunInLooperThread ; <nl> import io . realm . rule . RunTestInLooperThread ; <nl> import io . realm . rule . TestSyncConfigurationFactory ; <nl> @ @ - 47 , 6 + 51 , 9 @ @ public class SessionTests { <nl> @ Rule <nl> public final RunInLooperThread looperThread = new RunInLooperThread ( ) ; <nl> <nl> + @ Rule <nl> + public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule ( ) ; <nl> + <nl> @ Before <nl> public void setUp ( ) { <nl> user = createTestUser ( ) ; <nl> @ @ - 182 , 4 + 189 , 30 @ @ public class SessionTests { <nl> / / Trigger error <nl> SyncManager . simulateClientReset ( SyncManager . getSession ( config ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + @ UiThreadTest <nl> + public void uploadAllLocalChanges _ throwsOnUiThread ( ) throws InterruptedException { <nl> + SyncUser user = createTestUser ( ) ; <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + try { <nl> + SyncManager . getSession ( configuration ) . uploadAllLocalChanges ( ) ; <nl> + } catch ( IllegalStateException ignored ) { <nl> + } finally { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + @ UiThreadTest <nl> + public void downloadAllServerChanges _ throwsOnUiThread ( ) throws InterruptedException { <nl> + SyncUser user = createTestUser ( ) ; <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + try { <nl> + SyncManager . getSession ( configuration ) . downloadAllServerChanges ( ) ; <nl> + } catch ( IllegalStateException ignored ) { <nl> + } finally { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp b / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp <nl> index 5dde2c6 . . 4acc008 100644 <nl> - - - a / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp <nl> + + + b / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp <nl> @ @ - 146 , 7 + 146 , 7 @ @ JNIEXPORT jboolean JNICALL Java _ io _ realm _ SyncSession _ nativeWaitForDownloadComple <nl> <nl> if ( session ) { <nl> static JavaClass java _ sync _ session _ class ( env , " io / realm / SyncSession " ) ; <nl> - static JavaMethod java _ notify _ result _ method ( env , java _ sync _ session _ class , " notifyAllChangesDownloaded " , <nl> + static JavaMethod java _ notify _ result _ method ( env , java _ sync _ session _ class , " notifyAllChangesSent " , <nl> " ( Ljava / lang / Long ; Ljava / lang / String ; ) V " ) ; <nl> JavaGlobalRef java _ session _ object _ ref ( env , session _ object ) ; <nl> <nl> @ @ - 170 , 8 + 170 , 43 @ @ JNIEXPORT jboolean JNICALL Java _ io _ realm _ SyncSession _ nativeWaitForDownloadComple <nl> return JNI _ FALSE ; <nl> } <nl> <nl> - JNIEXPORT jbyte JNICALL Java _ io _ realm _ SyncSession _ nativeGetState ( JNIEnv * env , jclass , <nl> - jstring j _ local _ realm _ path ) <nl> + JNIEXPORT jboolean JNICALL Java _ io _ realm _ SyncSession _ nativeWaitForUploadCompletion ( JNIEnv * env , <nl> + jobject session _ object , <nl> + jstring j _ local _ realm _ path ) <nl> + { <nl> + TR _ ENTER ( ) <nl> + try { <nl> + JStringAccessor local _ realm _ path ( env , j _ local _ realm _ path ) ; <nl> + auto session = SyncManager : : shared ( ) . get _ existing _ session ( local _ realm _ path ) ; <nl> + <nl> + if ( session ) { <nl> + static JavaClass java _ sync _ session _ class ( env , " io / realm / SyncSession " ) ; <nl> + static JavaMethod java _ notify _ result _ method ( env , java _ sync _ session _ class , " notifyAllChangesSent " , <nl> + " ( Ljava / lang / Long ; Ljava / lang / String ; ) V " ) ; <nl> + JavaGlobalRef java _ session _ object _ ref ( env , session _ object ) ; <nl> + <nl> + bool listener _ registered = <nl> + session - > wait _ for _ upload _ completion ( [ java _ session _ object _ ref ] ( std : : error _ code error ) { <nl> + JNIEnv * env = JniUtils : : get _ env ( true ) ; <nl> + JavaLocalRef < jobject > java _ error _ code ; <nl> + JavaLocalRef < jstring > java _ error _ message ; <nl> + if ( error ! = std : : error _ code { } ) { <nl> + java _ error _ code = JavaLocalRef < jobject > ( env , NewLong ( env , error . value ( ) ) ) ; <nl> + java _ error _ message = JavaLocalRef < jstring > ( env , env - > NewStringUTF ( error . message ( ) . c _ str ( ) ) ) ; <nl> + } <nl> + env - > CallVoidMethod ( java _ session _ object _ ref . get ( ) , java _ notify _ result _ method , <nl> + java _ error _ code . get ( ) , java _ error _ message . get ( ) ) ; <nl> + } ) ; <nl> + <nl> + return to _ jbool ( listener _ registered ) ; <nl> + } <nl> + } <nl> + CATCH _ STD ( ) <nl> + return JNI _ FALSE ; <nl> + } <nl> + <nl> + <nl> + JNIEXPORT jbyte JNICALL Java _ io _ realm _ SyncSession _ nativeGetState ( JNIEnv * env , jclass , jstring j _ local _ realm _ path ) <nl> { <nl> TR _ ENTER ( ) <nl> try { <nl> diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java <nl> index 2a0438f . . a6c7740 100644 <nl> - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java <nl> @ @ - 71 , 7 + 71 , 7 @ @ public class SyncSession { <nl> private RealmAsyncTask refreshTokenNetworkRequest ; <nl> private AtomicBoolean onGoingAccessTokenQuery = new AtomicBoolean ( false ) ; <nl> private volatile boolean isClosed = false ; <nl> - private final AtomicReference < WaitForServerChangesWrapper > waitingForServerChanges = new AtomicReference < > ( null ) ; <nl> + private final AtomicReference < WaitForSessionWrapper > waitingForServerChanges = new AtomicReference < > ( null ) ; <nl> private final Object waitForChangesMutex = new Object ( ) ; <nl> <nl> / / We need JavaId - > Listener so C + + can trigger callbacks without keeping a reference to the <nl> @ @ - 294 , 14 + 294 , 16 @ @ public class SyncSession { <nl> clearScheduledAccessTokenRefresh ( ) ; <nl> } <nl> <nl> - / / This method will be called once all changes have been downloaded . <nl> - / / This method might be called on another thread than the one that called ` downloadAllServerChanges ` . <nl> + / / This method will be called once all changes have been downloaded or uploaded . <nl> + / / This method might be called on another thread than the one that called ` downloadAllServerChanges ` or <nl> + / / ` uploadAllLocalChanges ( ) ` <nl> + / / <nl> / / Be very careful with synchronized blocks . <nl> / / If the native listener was successfully registered , Object Store guarantees that this method will be called at <nl> / / least once , even if the session is closed . <nl> @ SuppressWarnings ( " unused " ) <nl> - private void notifyAllChangesDownloaded ( Long errorcode , String errorMessage ) { <nl> - WaitForServerChangesWrapper wrapper = waitingForServerChanges . get ( ) ; <nl> + private void notifyAllChangesSent ( Long errorcode , String errorMessage ) { <nl> + WaitForSessionWrapper wrapper = waitingForServerChanges . get ( ) ; <nl> if ( wrapper ! = null ) { <nl> wrapper . handleResult ( errorcode , errorMessage ) ; <nl> } <nl> @ @ - 328 , 26 + 330 , 74 @ @ public class SyncSession { <nl> / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the <nl> / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . <nl> synchronized ( waitForChangesMutex ) { <nl> - if ( ! isClosed ) { <nl> - WaitForServerChangesWrapper wrapper = new WaitForServerChangesWrapper ( ) ; <nl> - waitingForServerChanges . set ( wrapper ) ; <nl> - boolean listenerRegistered = nativeWaitForDownloadCompletion ( configuration . getPath ( ) ) ; <nl> - if ( ! listenerRegistered ) { <nl> - waitingForServerChanges . set ( null ) ; <nl> - throw new ObjectServerError ( ErrorCode . UNKNOWN , " It was not possible to download all changes . Has the SyncClient been started ? " ) ; <nl> + waitForChanges ( DIRECTION _ DOWNLOAD ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Calling this method will block until all known local changes have been uploaded to the server . <nl> + * This will involve network access , so calling this method should only be done from a non - UI thread . <nl> + * < p > <nl> + * If the device is offline , this method might never return . <nl> + * < p > <nl> + * This method cannot be called before the session has been started . <nl> + * <nl> + * @ throws IllegalStateException if called on the Android main thread . <nl> + * @ throws InterruptedException if the thread was interrupted while downloading was in progress . <nl> + * / <nl> + public void uploadAllLocalChanges ( ) throws InterruptedException { <nl> + checkIfNotOnMainThread ( " uploadAllLocalChanges ( ) cannot be called from the main thread . " ) ; <nl> + <nl> + / / Blocking only happens at the Java layer . To prevent deadlocking the underlying SyncSession we register <nl> + / / an async listener there and let it callback to the Java Session when done . This feels icky at best , but <nl> + / / since all operations on the SyncSession operate under a shared mutex , we would prevent all other actions on the <nl> + / / session , including trying to stop it . <nl> + / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the <nl> + / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . <nl> + synchronized ( waitForChangesMutex ) { <nl> + waitForChanges ( DIRECTION _ UPLOAD ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * This method should only be called when guarded by the { @ link # waitForChangesMutex } . <nl> + * It will block into all changes have been either uploaded or downloaded depending on the chosen direction . <nl> + * <nl> + * @ param direction either { @ link # DIRECTION _ DOWNLOAD } or { @ link # DIRECTION _ UPLOAD } <nl> + * / <nl> + private void waitForChanges ( int direction ) throws InterruptedException { <nl> + if ( direction ! = DIRECTION _ DOWNLOAD & & direction ! = DIRECTION _ UPLOAD ) { <nl> + throw new IllegalArgumentException ( " Unknown direction : " + direction ) ; <nl> + } <nl> + if ( ! isClosed ) { <nl> + WaitForSessionWrapper wrapper = new WaitForSessionWrapper ( ) ; <nl> + waitingForServerChanges . set ( wrapper ) ; <nl> + boolean listenerRegistered = ( direction = = DIRECTION _ DOWNLOAD ) <nl> + ? nativeWaitForDownloadCompletion ( configuration . getPath ( ) ) <nl> + : nativeWaitForUploadCompletion ( configuration . getPath ( ) ) ; <nl> + if ( ! listenerRegistered ) { <nl> + waitingForServerChanges . set ( null ) ; <nl> + String errorMsg = " " ; <nl> + switch ( direction ) { <nl> + case DIRECTION _ DOWNLOAD : errorMsg = " It was not possible to download all remote changes . " ; break ; <nl> + case DIRECTION _ UPLOAD : errorMsg = " It was not possible upload all local changes . " ; break ; <nl> + default : <nl> + throw new IllegalArgumentException ( " Unknown direction : " + direction ) ; <nl> } <nl> - wrapper . waitForServerChanges ( ) ; <nl> <nl> - / / This might return after the session was closed . In that case , just ignore any result <nl> - try { <nl> - if ( ! isClosed ) { <nl> - if ( ! wrapper . isSuccess ( ) ) { <nl> - wrapper . throwExceptionIfNeeded ( ) ; <nl> - } <nl> + throw new ObjectServerError ( ErrorCode . UNKNOWN , errorMsg + " Has the SyncClient been started ? " ) ; <nl> + } <nl> + wrapper . waitForServerChanges ( ) ; <nl> + <nl> + / / This might return after the session was closed . In that case , just ignore any result <nl> + try { <nl> + if ( ! isClosed ) { <nl> + if ( ! wrapper . isSuccess ( ) ) { <nl> + wrapper . throwExceptionIfNeeded ( ) ; <nl> } <nl> - } finally { <nl> - waitingForServerChanges . set ( null ) ; <nl> } <nl> + } finally { <nl> + waitingForServerChanges . set ( null ) ; <nl> } <nl> } <nl> } <nl> @ @ - 596 , 10 + 646 , 11 @ @ public class SyncSession { <nl> } <nl> } <nl> <nl> - / / Wrapper class for handling the async operations of the underlying SyncSession calling ` async _ wait _ for _ download _ completion ` <nl> - private static class WaitForServerChangesWrapper { <nl> + / / Wrapper class for handling the async operations of the underlying SyncSession calling <nl> + / / ` async _ wait _ for _ download _ completion ` or ` async _ wait _ for _ upload _ completion ` <nl> + private static class WaitForSessionWrapper { <nl> <nl> - private final CountDownLatch waitForChanges = new CountDownLatch ( 1 ) ; <nl> + private final CountDownLatch waiter = new CountDownLatch ( 1 ) ; <nl> private volatile boolean resultReceived = false ; <nl> private Long errorCode = null ; <nl> private String errorMessage ; <nl> @ @ - 609 , 12 + 660 , 12 @ @ public class SyncSession { <nl> * / <nl> public void waitForServerChanges ( ) throws InterruptedException { <nl> if ( ! resultReceived ) { <nl> - waitForChanges . await ( ) ; <nl> + waiter . await ( ) ; <nl> } <nl> } <nl> <nl> / * * <nl> - * Process the result of a waiting action . This will also unblock anyone who called { @ link # waitForChanges } . <nl> + * Process the result of a waiting action . This will also unblock anyone who called { @ link # waiter } . <nl> * <nl> * @ param errorCode error code if an error occurred , { @ code null } if changes were successfully downloaded . <nl> * @ param errorMessage error message ( if any ) . <nl> @ @ - 623 , 7 + 674 , 7 @ @ public class SyncSession { <nl> this . errorCode = errorCode ; <nl> this . errorMessage = errorMessage ; <nl> this . resultReceived = true ; <nl> - waitForChanges . countDown ( ) ; <nl> + waiter . countDown ( ) ; <nl> } <nl> <nl> public boolean isSuccess ( ) { <nl> @ @ - 646 , 5 + 697 , 6 @ @ public class SyncSession { <nl> private static native void nativeRemoveProgressListener ( String localRealmPath , long listenerToken ) ; <nl> private static native boolean nativeRefreshAccessToken ( String localRealmPath , String accessToken , String realmUrl ) ; <nl> private native boolean nativeWaitForDownloadCompletion ( String localRealmPath ) ; <nl> + private native boolean nativeWaitForUploadCompletion ( String localRealmPath ) ; <nl> private static native byte nativeGetState ( String localRealmPath ) ; <nl> } <nl> diff - - git a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncedRealmTests . java b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncedRealmTests . java <nl> index be5da79 . . 8b79a07 100644 <nl> - - - a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncedRealmTests . java <nl> + + + b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncedRealmTests . java <nl> @ @ - 67 , 7 + 67 , 7 @ @ public class SyncedRealmTests extends BaseIntegrationTest { <nl> } <nl> <nl> @ Test <nl> - public void waitForInitialRemoteData ( ) { <nl> + public void waitForInitialRemoteData ( ) throws InterruptedException { <nl> String username = UUID . randomUUID ( ) . toString ( ) ; <nl> String password = " password " ; <nl> SyncUser user = SyncUser . login ( SyncCredentials . usernamePassword ( username , password , true ) , Constants . AUTH _ URL ) ; <nl> @ @ - 85 , 7 + 85 , 7 @ @ public class SyncedRealmTests extends BaseIntegrationTest { <nl> } <nl> } <nl> } ) ; <nl> - SystemClock . sleep ( TimeUnit . SECONDS . toMillis ( 10 ) ) ; / / FIXME : Replace with Sync Progress Notifications once available . <nl> + SyncManager . getSession ( configOld ) . uploadAllLocalChanges ( ) ; <nl> realm . close ( ) ; <nl> user . logout ( ) ; <nl> Realm . deleteRealm ( configOld ) ; <nl> @ @ - 181 , 7 + 181 , 7 @ @ public class SyncedRealmTests extends BaseIntegrationTest { <nl> } <nl> <nl> @ Test <nl> - public void waitForInitialRemoteData _ readOnlyTrue ( ) { <nl> + public void waitForInitialRemoteData _ readOnlyTrue ( ) throws InterruptedException { <nl> String username = UUID . randomUUID ( ) . toString ( ) ; <nl> String password = " password " ; <nl> SyncUser user = SyncUser . login ( SyncCredentials . usernamePassword ( username , password , true ) , Constants . AUTH _ URL ) ; <nl> @ @ - 199 , 7 + 199 , 7 @ @ public class SyncedRealmTests extends BaseIntegrationTest { <nl> } <nl> } <nl> } ) ; <nl> - SystemClock . sleep ( TimeUnit . SECONDS . toMillis ( 10 ) ) ; / / FIXME : Replace with Sync Progress Notifications once available . <nl> + SyncManager . getSession ( configOld ) . uploadAllLocalChanges ( ) ; <nl> realm . close ( ) ; <nl> user . logout ( ) ; <nl> Realm . deleteRealm ( configOld ) ; <nl> diff - - git a / realm / realm - library / src / syncIntegrationTest / java / io / realm / objectserver / SyncSessionTests . java b / realm / realm - library / src / syncIntegrationTest / java / io / realm / objectserver / SyncSessionTests . java <nl> index 695fd03 . . a46591c 100644 <nl> - - - a / realm / realm - library / src / syncIntegrationTest / java / io / realm / objectserver / SyncSessionTests . java <nl> + + + b / realm / realm - library / src / syncIntegrationTest / java / io / realm / objectserver / SyncSessionTests . java <nl> @ @ - 1 , 6 + 1 , 7 @ @ <nl> package io . realm . objectserver ; <nl> <nl> import android . os . SystemClock ; <nl> + import android . support . test . annotation . UiThreadTest ; <nl> import android . support . test . runner . AndroidJUnit4 ; <nl> <nl> import org . junit . Rule ; <nl> @ @ - 15 , 6 + 16 , 7 @ @ import io . realm . SyncConfiguration ; <nl> import io . realm . SyncManager ; <nl> import io . realm . SyncSession ; <nl> import io . realm . SyncUser ; <nl> + import io . realm . entities . AllTypes ; <nl> import io . realm . objectserver . utils . Constants ; <nl> import io . realm . objectserver . utils . UserFactory ; <nl> import io . realm . rule . TestSyncConfigurationFactory ; <nl> @ @ - 79 , 4 + 81 , 29 @ @ public class SyncSessionTests extends BaseIntegrationTest { <nl> } catch ( IllegalStateException expected ) { <nl> } <nl> } <nl> + <nl> + @ Test <nl> + public void uploadDownloadAllChanges ( ) throws InterruptedException { <nl> + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; <nl> + SyncUser adminUser = UserFactory . createAdminUser ( Constants . AUTH _ URL ) ; <nl> + SyncConfiguration userConfig = configFactory <nl> + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) <nl> + . build ( ) ; <nl> + SyncConfiguration adminConfig = configFactory <nl> + . createSyncConfigurationBuilder ( adminUser , userConfig . getServerUrl ( ) . toString ( ) ) <nl> + . build ( ) ; <nl> + <nl> + Realm userRealm = Realm . getInstance ( userConfig ) ; <nl> + userRealm . beginTransaction ( ) ; <nl> + userRealm . createObject ( AllTypes . class ) ; <nl> + userRealm . commitTransaction ( ) ; <nl> + SyncManager . getSession ( userConfig ) . uploadAllLocalChanges ( ) ; <nl> + userRealm . close ( ) ; <nl> + <nl> + Realm adminRealm = Realm . getInstance ( adminConfig ) ; <nl> + SyncManager . getSession ( adminConfig ) . downloadAllServerChanges ( ) ; <nl> + adminRealm . refresh ( ) ; <nl> + assertEquals ( 1 , adminRealm . where ( AllTypes . class ) . count ( ) ) ; <nl> + adminRealm . close ( ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> index cd86320 . . 463cdce 100644 <nl> - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> @ @ - 506 , 7 + 506 , 11 @ @ public class RealmProxyClassGenerator { <nl> EnumSet . of ( Modifier . PUBLIC , Modifier . STATIC ) , / / Modifiers <nl> " Realm " , " realm " , className , " newObject " , " boolean " , " update " , " Map < RealmObject , RealmObject > " , " cache " ) ; / / Argument type & argument name <nl> <nl> - writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; <nl> + if ( metadata . hasPrimaryKey ( ) ) { <nl> + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class , newObject . % s ( ) ) " , className , className , metadata . getPrimaryKeyGetter ( ) ) ; <nl> + } else { <nl> + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; <nl> + } <nl> writer . emitStatement ( " cache . put ( newObject , realmObject ) " ) ; <nl> for ( VariableElement field : metadata . getFields ( ) ) { <nl> String fieldName = field . getSimpleName ( ) . toString ( ) ; <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index b87516d . . cd0e555 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 46 , 6 + 46 , 7 @ @ import io . realm . entities . NonLatinFieldNames ; <nl> import io . realm . entities . Owner ; <nl> import io . realm . entities . OwnerPrimaryKey ; <nl> import io . realm . entities . PrimaryKeyAsLong ; <nl> + import io . realm . entities . PrimaryKeyAsString ; <nl> import io . realm . entities . PrimaryKeyMix ; <nl> import io . realm . entities . StringOnly ; <nl> import io . realm . exceptions . RealmException ; <nl> @ @ - 1067 , 6 + 1068 , 26 @ @ public class RealmTest extends AndroidTestCase { <nl> assertArrayEquals ( new byte [ 0 ] , realmTypes . getColumnBinary ( ) ) ; <nl> } <nl> <nl> + / / Check that using copyToRealm will set the primary key directly instead of first setting <nl> + / / it to the default value ( which can fail ) <nl> + public void testCopyToRealmWithPrimaryKeySetValueDirectly ( ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . createObject ( OwnerPrimaryKey . class ) ; <nl> + testRealm . copyToRealm ( new OwnerPrimaryKey ( 1 , " Foo " ) ) ; <nl> + testRealm . commitTransaction ( ) ; <nl> + assertEquals ( 2 , testRealm . where ( OwnerPrimaryKey . class ) . count ( ) ) ; <nl> + } <nl> + <nl> + public void testCopyToRealmWithPrimaryAsNullThrows ( ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + try { <nl> + testRealm . copyToRealm ( new PrimaryKeyAsString ( ) ) ; <nl> + fail ( ) ; <nl> + } catch ( RealmException expected ) { <nl> + } finally { <nl> + testRealm . cancelTransaction ( ) ; <nl> + } <nl> + } <nl> <nl> public void testCopyToRealmList ( ) { <nl> Dog dog1 = new Dog ( ) ; <nl> @ @ - 1500 , 7 + 1521 , 6 @ @ public class RealmTest extends AndroidTestCase { <nl> fail ( ) ; <nl> } catch ( IllegalStateException ignored ) { <nl> } <nl> - <nl> } <nl> <nl> public void testUpdateObjectWithLinks ( ) throws Exception { <nl> diff - - git a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> index 3bba1b0 . . ce53189 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> + + + b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> @ @ - 26 , 6 + 26 , 13 @ @ public class PrimaryKeyAsString extends RealmObject { <nl> <nl> private long id ; <nl> <nl> + public PrimaryKeyAsString ( ) { <nl> + } <nl> + <nl> + public PrimaryKeyAsString ( String name ) { <nl> + this . name = name ; <nl> + } <nl> + <nl> public String getName ( ) { <nl> return name ; <nl> } <nl> diff - - git a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> index cbb78bf . . 3106ea9 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> + + + b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> @ @ - 36 , 7 + 36 , 24 @ @ public class JNITransactions extends AndroidTestCase { <nl> } <nl> } <nl> <nl> - <nl> + private Table getTableWithStringPrimaryKey ( ) { <nl> + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; <nl> + WriteTransaction trans = db . beginWrite ( ) ; <nl> + Table t = trans . getTable ( " TestTable " ) ; <nl> + t . addColumn ( ColumnType . STRING , " colName " ) ; <nl> + t . setPrimaryKey ( " colName " ) ; <nl> + return t ; <nl> + } <nl> + <nl> + private Table getTableWithIntegerPrimaryKey ( ) { <nl> + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; <nl> + WriteTransaction trans = db . beginWrite ( ) ; <nl> + Table t = trans . getTable ( " TestTable " ) ; <nl> + t . addColumn ( ColumnType . INTEGER , " colName " ) ; <nl> + t . setPrimaryKey ( " colName " ) ; <nl> + return t ; <nl> + } <nl> + <nl> private void createDBFileName ( ) { <nl> testFile = new File ( <nl> this . getContext ( ) . getFilesDir ( ) , <nl> @ @ - 319 , 24 + 336 , 44 @ @ public class JNITransactions extends AndroidTestCase { <nl> fail ( " Primary key not enforced . " ) ; <nl> } <nl> <nl> + public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( 42 ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> + } <nl> + } <nl> <nl> - <nl> - / * ARM Only works for Java 1 . 7 - NOT available in Android . <nl> - <nl> - @ Test ( enabled = true ) <nl> - public void mustReadARM ( ) { <nl> - writeOneTransaction ( 1 ) ; <nl> - <nl> - / / Read from table <nl> - / / System . out . println ( " mustReadARM . " ) ; <nl> - try ( ReadTransaction t = new ReadTransaction ( db ) ) { <nl> - EmployeeTable employees = new EmployeeTable ( t ) ; <nl> - assertEquals ( true , employees . isValid ( ) ) ; <nl> - assertEquals ( 1 , employees . size ( ) ) ; <nl> + public void testAddEmptyRowWithPrimaryKeyNullStringThrows ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( null ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> } <nl> - catch ( Throwable e ) { <nl> + } <nl> <nl> + public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows ( ) { <nl> + Table t = getTableWithIntegerPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( " Foo " ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> } <nl> } <nl> - * / <nl> + <nl> + public void testAddEmptyRowWithPrimaryKeyString ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + long rowIndex = t . addEmptyRowWithPrimaryKey ( " Foo " ) ; <nl> + assertEquals ( 1 , t . size ( ) ) ; <nl> + assertEquals ( " Foo " , t . getRow ( rowIndex ) . getString ( 0 ) ) ; <nl> + } <nl> + <nl> + public void testAddEmptyRowWithPrimaryKeyLong ( ) { <nl> + Table t = getTableWithIntegerPrimaryKey ( ) ; <nl> + long rowIndex = t . addEmptyRowWithPrimaryKey ( 42 ) ; <nl> + assertEquals ( 1 , t . size ( ) ) ; <nl> + assertEquals ( 42 , t . getRow ( rowIndex ) . getLong ( 0 ) ) ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index df3156b . . e6ad153 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 1089 , 6 + 1089 , 47 @ @ public final class Realm implements Closeable { <nl> return get ( clazz , rowIndex ) ; <nl> } <nl> <nl> + / * * <nl> + * Creates a new object inside the Realm with the Primary key value initially set . <nl> + * If the value violates the primary key constraint , no object will be added and and <nl> + * { @ link RealmException will be thrown } . <nl> + * <nl> + * @ param clazz The Class of the object to create <nl> + * @ param primaryKeyValue Value for the primary key field . <nl> + * @ return The new object <nl> + * @ throws { @ link RealmException } if object could not be created . <nl> + * / <nl> + < E extends RealmObject > E createObject ( Class < E > clazz , Object primaryKeyValue ) { <nl> + Table table ; <nl> + table = tables . get ( clazz ) ; <nl> + if ( table = = null ) { <nl> + Class < ? > generatedClass = getProxyClass ( clazz ) ; <nl> + <nl> + Method method = initTableMethods . get ( generatedClass ) ; <nl> + if ( method = = null ) { <nl> + try { <nl> + method = generatedClass . getMethod ( " initTable " , new Class [ ] { ImplicitTransaction . class } ) ; <nl> + } catch ( NoSuchMethodException e ) { <nl> + throw new RealmException ( " Could not find the initTable ( ) method in generated proxy class : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + initTableMethods . put ( generatedClass , method ) ; <nl> + } <nl> + <nl> + try { <nl> + table = ( Table ) method . invoke ( null , transaction ) ; <nl> + tables . put ( clazz , table ) ; <nl> + } catch ( IllegalAccessException e ) { <nl> + throw new RealmException ( " Could not launch the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } catch ( InvocationTargetException e ) { <nl> + e . printStackTrace ( ) ; <nl> + throw new RealmException ( " An exception occurred while running the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + } <nl> + <nl> + long rowIndex = table . addEmptyRowWithPrimaryKey ( primaryKeyValue ) ; <nl> + return get ( clazz , rowIndex ) ; <nl> + } <nl> + <nl> private Class < ? > getProxyClass ( Class < ? > clazz ) { <nl> <nl> String simpleClassName = getClassSimpleName ( clazz ) ; <nl> diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java <nl> index 42d28b0 . . 83be1fd 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / Table . java <nl> + + + b / realm / src / main / java / io / realm / internal / Table . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . internal ; <nl> import java . io . Closeable ; <nl> import java . util . Date ; <nl> <nl> + import io . realm . annotations . PrimaryKey ; <nl> import io . realm . exceptions . RealmException ; <nl> <nl> <nl> @ @ - 364 , 7 + 365 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> <nl> protected native void nativeMoveLastOver ( long nativeTablePtr , long rowIndex ) ; <nl> <nl> - / / Row Handling methods . <nl> public long addEmptyRow ( ) { <nl> checkImmutable ( ) ; <nl> if ( hasPrimaryKey ( ) ) { <nl> @ @ - 390 , 6 + 390 , 54 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> return nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> } <nl> <nl> + public long addEmptyRowWithPrimaryKey ( Object primaryKeyValue ) { <nl> + checkImmutable ( ) ; <nl> + if ( hasPrimaryKey ( ) ) { <nl> + long primaryKeyColumnIndex = getPrimaryKey ( ) ; <nl> + ColumnType type = getColumnType ( primaryKeyColumnIndex ) ; <nl> + long rowIndex ; <nl> + Row row ; <nl> + <nl> + / / Add with with primary key initially set <nl> + switch ( type ) { <nl> + case STRING : <nl> + if ( ! ( primaryKeyValue instanceof String ) ) { <nl> + throw new IllegalArgumentException ( " Primary key value is not a String : " + primaryKeyValue ) ; <nl> + } <nl> + if ( findFirstString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ! = NO _ MATCH ) { <nl> + throwDuplicatePrimaryKeyException ( primaryKeyValue ) ; <nl> + } <nl> + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> + row = getRow ( rowIndex ) ; <nl> + row . setString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ; <nl> + break ; <nl> + <nl> + case INTEGER : <nl> + long pkValue ; <nl> + try { <nl> + pkValue = new Long ( primaryKeyValue . toString ( ) ) ; <nl> + } catch ( RuntimeException e ) { <nl> + throw new IllegalArgumentException ( " Primary key value is not a long : " + primaryKeyValue ) ; <nl> + } <nl> + if ( findFirstLong ( primaryKeyColumnIndex , pkValue ) ! = NO _ MATCH ) { <nl> + throwDuplicatePrimaryKeyException ( pkValue ) ; <nl> + } <nl> + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> + row = getRow ( rowIndex ) ; <nl> + row . setLong ( primaryKeyColumnIndex , pkValue ) ; <nl> + break ; <nl> + <nl> + default : <nl> + throw new RealmException ( " Cannot check for duplicate rows for unsupported primary key type : " + type ) ; <nl> + } <nl> + <nl> + return rowIndex ; <nl> + <nl> + } else { <nl> + throw new IllegalStateException ( getName ( ) + " has no primary key defined " ) ; <nl> + } <nl> + } <nl> + <nl> public long addEmptyRows ( long rows ) { <nl> checkImmutable ( ) ; <nl> if ( rows < 1 ) {

TEST DIFF:
diff - - git a / CHANGELOG . md b / CHANGELOG . md 
 index a695fc6 . . 7b5246a 100644 
 - - - a / CHANGELOG . md 
 + + + b / CHANGELOG . md 
 @ @ - 2 , 6 + 2 , 8 @ @ 
 
 # # # Enhancements 
 
 + * [ ObjectServer ] Added ` SyncSession . uploadAllLocalChanges ( ) ` . 
 + 
 # # # Bug Fixes 
 
 # # # Internal 
 diff - - git a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java 
 index acf65b4 . . 853d888 100644 
 - - - a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java 
 + + + b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java 
 @ @ - 16 , 6 + 16 , 8 @ @ 
 
 package io . realm ; 
 
 + import android . support . test . annotation . UiThreadTest ; 
 + import android . support . test . rule . UiThreadTestRule ; 
 import android . support . test . runner . AndroidJUnit4 ; 
 
 import org . junit . Before ; 
 @ @ - 23 , 6 + 25 , 8 @ @ import org . junit . Rule ; 
 import org . junit . Test ; 
 import org . junit . runner . RunWith ; 
 
 + import io . realm . objectserver . utils . Constants ; 
 + import io . realm . objectserver . utils . UserFactory ; 
 import io . realm . rule . RunInLooperThread ; 
 import io . realm . rule . RunTestInLooperThread ; 
 import io . realm . rule . TestSyncConfigurationFactory ; 
 @ @ - 47 , 6 + 51 , 9 @ @ public class SessionTests { 
 @ Rule 
 public final RunInLooperThread looperThread = new RunInLooperThread ( ) ; 
 
 + @ Rule 
 + public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule ( ) ; 
 + 
 @ Before 
 public void setUp ( ) { 
 user = createTestUser ( ) ; 
 @ @ - 182 , 4 + 189 , 30 @ @ public class SessionTests { 
 / / Trigger error 
 SyncManager . simulateClientReset ( SyncManager . getSession ( config ) ) ; 
 } 
 + 
 + @ Test 
 + @ UiThreadTest 
 + public void uploadAllLocalChanges _ throwsOnUiThread ( ) throws InterruptedException { 
 + SyncUser user = createTestUser ( ) ; 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + try { 
 + SyncManager . getSession ( configuration ) . uploadAllLocalChanges ( ) ; 
 + } catch ( IllegalStateException ignored ) { 
 + } finally { 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + @ UiThreadTest 
 + public void downloadAllServerChanges _ throwsOnUiThread ( ) throws InterruptedException { 
 + SyncUser user = createTestUser ( ) ; 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + try { 
 + SyncManager . getSession ( configuration ) . downloadAllServerChanges ( ) ; 
 + } catch ( IllegalStateException ignored ) { 
 + } finally { 
 + realm . close ( ) ; 
 + } 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp b / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp 
 index 5dde2c6 . . 4acc008 100644 
 - - - a / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp 
 + + + b / realm / realm - library / src / main / cpp / io _ realm _ SyncSession . cpp 
 @ @ - 146 , 7 + 146 , 7 @ @ JNIEXPORT jboolean JNICALL Java _ io _ realm _ SyncSession _ nativeWaitForDownloadComple 
 
 if ( session ) { 
 static JavaClass java _ sync _ session _ class ( env , " io / realm / SyncSession " ) ; 
 - static JavaMethod java _ notify _ result _ method ( env , java _ sync _ session _ class , " notifyAllChangesDownloaded " , 
 + static JavaMethod java _ notify _ result _ method ( env , java _ sync _ session _ class , " notifyAllChangesSent " , 
 " ( Ljava / lang / Long ; Ljava / lang / String ; ) V " ) ; 
 JavaGlobalRef java _ session _ object _ ref ( env , session _ object ) ; 
 
 @ @ - 170 , 8 + 170 , 43 @ @ JNIEXPORT jboolean JNICALL Java _ io _ realm _ SyncSession _ nativeWaitForDownloadComple 
 return JNI _ FALSE ; 
 } 
 
 - JNIEXPORT jbyte JNICALL Java _ io _ realm _ SyncSession _ nativeGetState ( JNIEnv * env , jclass , 
 - jstring j _ local _ realm _ path ) 
 + JNIEXPORT jboolean JNICALL Java _ io _ realm _ SyncSession _ nativeWaitForUploadCompletion ( JNIEnv * env , 
 + jobject session _ object , 
 + jstring j _ local _ realm _ path ) 
 + { 
 + TR _ ENTER ( ) 
 + try { 
 + JStringAccessor local _ realm _ path ( env , j _ local _ realm _ path ) ; 
 + auto session = SyncManager : : shared ( ) . get _ existing _ session ( local _ realm _ path ) ; 
 + 
 + if ( session ) { 
 + static JavaClass java _ sync _ session _ class ( env , " io / realm / SyncSession " ) ; 
 + static JavaMethod java _ notify _ result _ method ( env , java _ sync _ session _ class , " notifyAllChangesSent " , 
 + " ( Ljava / lang / Long ; Ljava / lang / String ; ) V " ) ; 
 + JavaGlobalRef java _ session _ object _ ref ( env , session _ object ) ; 
 + 
 + bool listener _ registered = 
 + session - > wait _ for _ upload _ completion ( [ java _ session _ object _ ref ] ( std : : error _ code error ) { 
 + JNIEnv * env = JniUtils : : get _ env ( true ) ; 
 + JavaLocalRef < jobject > java _ error _ code ; 
 + JavaLocalRef < jstring > java _ error _ message ; 
 + if ( error ! = std : : error _ code { } ) { 
 + java _ error _ code = JavaLocalRef < jobject > ( env , NewLong ( env , error . value ( ) ) ) ; 
 + java _ error _ message = JavaLocalRef < jstring > ( env , env - > NewStringUTF ( error . message ( ) . c _ str ( ) ) ) ; 
 + } 
 + env - > CallVoidMethod ( java _ session _ object _ ref . get ( ) , java _ notify _ result _ method , 
 + java _ error _ code . get ( ) , java _ error _ message . get ( ) ) ; 
 + } ) ; 
 + 
 + return to _ jbool ( listener _ registered ) ; 
 + } 
 + } 
 + CATCH _ STD ( ) 
 + return JNI _ FALSE ; 
 + } 
 + 
 + 
 + JNIEXPORT jbyte JNICALL Java _ io _ realm _ SyncSession _ nativeGetState ( JNIEnv * env , jclass , jstring j _ local _ realm _ path ) 
 { 
 TR _ ENTER ( ) 
 try { 
 diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java 
 index 2a0438f . . a6c7740 100644 
 - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java 
 @ @ - 71 , 7 + 71 , 7 @ @ public class SyncSession { 
 private RealmAsyncTask refreshTokenNetworkRequest ; 
 private AtomicBoolean onGoingAccessTokenQuery = new AtomicBoolean ( false ) ; 
 private volatile boolean isClosed = false ; 
 - private final AtomicReference < WaitForServerChangesWrapper > waitingForServerChanges = new AtomicReference < > ( null ) ; 
 + private final AtomicReference < WaitForSessionWrapper > waitingForServerChanges = new AtomicReference < > ( null ) ; 
 private final Object waitForChangesMutex = new Object ( ) ; 
 
 / / We need JavaId - > Listener so C + + can trigger callbacks without keeping a reference to the 
 @ @ - 294 , 14 + 294 , 16 @ @ public class SyncSession { 
 clearScheduledAccessTokenRefresh ( ) ; 
 } 
 
 - / / This method will be called once all changes have been downloaded . 
 - / / This method might be called on another thread than the one that called ` downloadAllServerChanges ` . 
 + / / This method will be called once all changes have been downloaded or uploaded . 
 + / / This method might be called on another thread than the one that called ` downloadAllServerChanges ` or 
 + / / ` uploadAllLocalChanges ( ) ` 
 + / / 
 / / Be very careful with synchronized blocks . 
 / / If the native listener was successfully registered , Object Store guarantees that this method will be called at 
 / / least once , even if the session is closed . 
 @ SuppressWarnings ( " unused " ) 
 - private void notifyAllChangesDownloaded ( Long errorcode , String errorMessage ) { 
 - WaitForServerChangesWrapper wrapper = waitingForServerChanges . get ( ) ; 
 + private void notifyAllChangesSent ( Long errorcode , String errorMessage ) { 
 + WaitForSessionWrapper wrapper = waitingForServerChanges . get ( ) ; 
 if ( wrapper ! = null ) { 
 wrapper . handleResult ( errorcode , errorMessage ) ; 
 } 
 @ @ - 328 , 26 + 330 , 74 @ @ public class SyncSession { 
 / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the 
 / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . 
 synchronized ( waitForChangesMutex ) { 
 - if ( ! isClosed ) { 
 - WaitForServerChangesWrapper wrapper = new WaitForServerChangesWrapper ( ) ; 
 - waitingForServerChanges . set ( wrapper ) ; 
 - boolean listenerRegistered = nativeWaitForDownloadCompletion ( configuration . getPath ( ) ) ; 
 - if ( ! listenerRegistered ) { 
 - waitingForServerChanges . set ( null ) ; 
 - throw new ObjectServerError ( ErrorCode . UNKNOWN , " It was not possible to download all changes . Has the SyncClient been started ? " ) ; 
 + waitForChanges ( DIRECTION _ DOWNLOAD ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Calling this method will block until all known local changes have been uploaded to the server . 
 + * This will involve network access , so calling this method should only be done from a non - UI thread . 
 + * < p > 
 + * If the device is offline , this method might never return . 
 + * < p > 
 + * This method cannot be called before the session has been started . 
 + * 
 + * @ throws IllegalStateException if called on the Android main thread . 
 + * @ throws InterruptedException if the thread was interrupted while downloading was in progress . 
 + * / 
 + public void uploadAllLocalChanges ( ) throws InterruptedException { 
 + checkIfNotOnMainThread ( " uploadAllLocalChanges ( ) cannot be called from the main thread . " ) ; 
 + 
 + / / Blocking only happens at the Java layer . To prevent deadlocking the underlying SyncSession we register 
 + / / an async listener there and let it callback to the Java Session when done . This feels icky at best , but 
 + / / since all operations on the SyncSession operate under a shared mutex , we would prevent all other actions on the 
 + / / session , including trying to stop it . 
 + / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the 
 + / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . 
 + synchronized ( waitForChangesMutex ) { 
 + waitForChanges ( DIRECTION _ UPLOAD ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * This method should only be called when guarded by the { @ link # waitForChangesMutex } . 
 + * It will block into all changes have been either uploaded or downloaded depending on the chosen direction . 
 + * 
 + * @ param direction either { @ link # DIRECTION _ DOWNLOAD } or { @ link # DIRECTION _ UPLOAD } 
 + * / 
 + private void waitForChanges ( int direction ) throws InterruptedException { 
 + if ( direction ! = DIRECTION _ DOWNLOAD & & direction ! = DIRECTION _ UPLOAD ) { 
 + throw new IllegalArgumentException ( " Unknown direction : " + direction ) ; 
 + } 
 + if ( ! isClosed ) { 
 + WaitForSessionWrapper wrapper = new WaitForSessionWrapper ( ) ; 
 + waitingForServerChanges . set ( wrapper ) ; 
 + boolean listenerRegistered = ( direction = = DIRECTION _ DOWNLOAD ) 
 + ? nativeWaitForDownloadCompletion ( configuration . getPath ( ) ) 
 + : nativeWaitForUploadCompletion ( configuration . getPath ( ) ) ; 
 + if ( ! listenerRegistered ) { 
 + waitingForServerChanges . set ( null ) ; 
 + String errorMsg = " " ; 
 + switch ( direction ) { 
 + case DIRECTION _ DOWNLOAD : errorMsg = " It was not possible to download all remote changes . " ; break ; 
 + case DIRECTION _ UPLOAD : errorMsg = " It was not possible upload all local changes . " ; break ; 
 + default : 
 + throw new IllegalArgumentException ( " Unknown direction : " + direction ) ; 
 } 
 - wrapper . waitForServerChanges ( ) ; 
 
 - / / This might return after the session was closed . In that case , just ignore any result 
 - try { 
 - if ( ! isClosed ) { 
 - if ( ! wrapper . isSuccess ( ) ) { 
 - wrapper . throwExceptionIfNeeded ( ) ; 
 - } 
 + throw new ObjectServerError ( ErrorCode . UNKNOWN , errorMsg + " Has the SyncClient been started ? " ) ; 
 + } 
 + wrapper . waitForServerChanges ( ) ; 
 + 
 + / / This might return after the session was closed . In that case , just ignore any result 
 + try { 
 + if ( ! isClosed ) { 
 + if ( ! wrapper . isSuccess ( ) ) { 
 + wrapper . throwExceptionIfNeeded ( ) ; 
 } 
 - } finally { 
 - waitingForServerChanges . set ( null ) ; 
 } 
 + } finally { 
 + waitingForServerChanges . set ( null ) ; 
 } 
 } 
 } 
 @ @ - 596 , 10 + 646 , 11 @ @ public class SyncSession { 
 } 
 } 
 
 - / / Wrapper class for handling the async operations of the underlying SyncSession calling ` async _ wait _ for _ download _ completion ` 
 - private static class WaitForServerChangesWrapper { 
 + / / Wrapper class for handling the async operations of the underlying SyncSession calling 
 + / / ` async _ wait _ for _ download _ completion ` or ` async _ wait _ for _ upload _ completion ` 
 + private static class WaitForSessionWrapper { 
 
 - private final CountDownLatch waitForChanges = new CountDownLatch ( 1 ) ; 
 + private final CountDownLatch waiter = new CountDownLatch ( 1 ) ; 
 private volatile boolean resultReceived = false ; 
 private Long errorCode = null ; 
 private String errorMessage ; 
 @ @ - 609 , 12 + 660 , 12 @ @ public class SyncSession { 
 * / 
 public void waitForServerChanges ( ) throws InterruptedException { 
 if ( ! resultReceived ) { 
 - waitForChanges . await ( ) ; 
 + waiter . await ( ) ; 
 } 
 } 
 
 / * * 
 - * Process the result of a waiting action . This will also unblock anyone who called { @ link # waitForChanges } . 
 + * Process the result of a waiting action . This will also unblock anyone who called { @ link # waiter } . 
 * 
 * @ param errorCode error code if an error occurred , { @ code null } if changes were successfully downloaded . 
 * @ param errorMessage error message ( if any ) . 
 @ @ - 623 , 7 + 674 , 7 @ @ public class SyncSession { 
 this . errorCode = errorCode ; 
 this . errorMessage = errorMessage ; 
 this . resultReceived = true ; 
 - waitForChanges . countDown ( ) ; 
 + waiter . countDown ( ) ; 
 } 
 
 public boolean isSuccess ( ) { 
 @ @ - 646 , 5 + 697 , 6 @ @ public class SyncSession { 
 private static native void nativeRemoveProgressListener ( String localRealmPath , long listenerToken ) ; 
 private static native boolean nativeRefreshAccessToken ( String localRealmPath , String accessToken , String realmUrl ) ; 
 private native boolean nativeWaitForDownloadCompletion ( String localRealmPath ) ; 
 + private native boolean nativeWaitForUploadCompletion ( String localRealmPath ) ; 
 private static native byte nativeGetState ( String localRealmPath ) ; 
 } 
 diff - - git a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncedRealmTests . java b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncedRealmTests . java 
 index be5da79 . . 8b79a07 100644 
 - - - a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncedRealmTests . java 
 + + + b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncedRealmTests . java 
 @ @ - 67 , 7 + 67 , 7 @ @ public class SyncedRealmTests extends BaseIntegrationTest { 
 } 
 
 @ Test 
 - public void waitForInitialRemoteData ( ) { 
 + public void waitForInitialRemoteData ( ) throws InterruptedException { 
 String username = UUID . randomUUID ( ) . toString ( ) ; 
 String password = " password " ; 
 SyncUser user = SyncUser . login ( SyncCredentials . usernamePassword ( username , password , true ) , Constants . AUTH _ URL ) ; 
 @ @ - 85 , 7 + 85 , 7 @ @ public class SyncedRealmTests extends BaseIntegrationTest { 
 } 
 } 
 } ) ; 
 - SystemClock . sleep ( TimeUnit . SECONDS . toMillis ( 10 ) ) ; / / FIXME : Replace with Sync Progress Notifications once available . 
 + SyncManager . getSession ( configOld ) . uploadAllLocalChanges ( ) ; 
 realm . close ( ) ; 
 user . logout ( ) ; 
 Realm . deleteRealm ( configOld ) ; 
 @ @ - 181 , 7 + 181 , 7 @ @ public class SyncedRealmTests extends BaseIntegrationTest { 
 } 
 
 @ Test 
 - public void waitForInitialRemoteData _ readOnlyTrue ( ) { 
 + public void waitForInitialRemoteData _ readOnlyTrue ( ) throws InterruptedException { 
 String username = UUID . randomUUID ( ) . toString ( ) ; 
 String password = " password " ; 
 SyncUser user = SyncUser . login ( SyncCredentials . usernamePassword ( username , password , true ) , Constants . AUTH _ URL ) ; 
 @ @ - 199 , 7 + 199 , 7 @ @ public class SyncedRealmTests extends BaseIntegrationTest { 
 } 
 } 
 } ) ; 
 - SystemClock . sleep ( TimeUnit . SECONDS . toMillis ( 10 ) ) ; / / FIXME : Replace with Sync Progress Notifications once available . 
 + SyncManager . getSession ( configOld ) . uploadAllLocalChanges ( ) ; 
 realm . close ( ) ; 
 user . logout ( ) ; 
 Realm . deleteRealm ( configOld ) ; 
 diff - - git a / realm / realm - library / src / syncIntegrationTest / java / io / realm / objectserver / SyncSessionTests . java b / realm / realm - library / src / syncIntegrationTest / java / io / realm / objectserver / SyncSessionTests . java 
 index 695fd03 . . a46591c 100644 
 - - - a / realm / realm - library / src / syncIntegrationTest / java / io / realm / objectserver / SyncSessionTests . java 
 + + + b / realm / realm - library / src / syncIntegrationTest / java / io / realm / objectserver / SyncSessionTests . java 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package io . realm . objectserver ; 
 
 import android . os . SystemClock ; 
 + import android . support . test . annotation . UiThreadTest ; 
 import android . support . test . runner . AndroidJUnit4 ; 
 
 import org . junit . Rule ; 
 @ @ - 15 , 6 + 16 , 7 @ @ import io . realm . SyncConfiguration ; 
 import io . realm . SyncManager ; 
 import io . realm . SyncSession ; 
 import io . realm . SyncUser ; 
 + import io . realm . entities . AllTypes ; 
 import io . realm . objectserver . utils . Constants ; 
 import io . realm . objectserver . utils . UserFactory ; 
 import io . realm . rule . TestSyncConfigurationFactory ; 
 @ @ - 79 , 4 + 81 , 29 @ @ public class SyncSessionTests extends BaseIntegrationTest { 
 } catch ( IllegalStateException expected ) { 
 } 
 } 
 + 
 + @ Test 
 + public void uploadDownloadAllChanges ( ) throws InterruptedException { 
 + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; 
 + SyncUser adminUser = UserFactory . createAdminUser ( Constants . AUTH _ URL ) ; 
 + SyncConfiguration userConfig = configFactory 
 + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) 
 + . build ( ) ; 
 + SyncConfiguration adminConfig = configFactory 
 + . createSyncConfigurationBuilder ( adminUser , userConfig . getServerUrl ( ) . toString ( ) ) 
 + . build ( ) ; 
 + 
 + Realm userRealm = Realm . getInstance ( userConfig ) ; 
 + userRealm . beginTransaction ( ) ; 
 + userRealm . createObject ( AllTypes . class ) ; 
 + userRealm . commitTransaction ( ) ; 
 + SyncManager . getSession ( userConfig ) . uploadAllLocalChanges ( ) ; 
 + userRealm . close ( ) ; 
 + 
 + Realm adminRealm = Realm . getInstance ( adminConfig ) ; 
 + SyncManager . getSession ( adminConfig ) . downloadAllServerChanges ( ) ; 
 + adminRealm . refresh ( ) ; 
 + assertEquals ( 1 , adminRealm . where ( AllTypes . class ) . count ( ) ) ; 
 + adminRealm . close ( ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 index cd86320 . . 463cdce 100644 
 - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 @ @ - 506 , 7 + 506 , 11 @ @ public class RealmProxyClassGenerator { 
 EnumSet . of ( Modifier . PUBLIC , Modifier . STATIC ) , / / Modifiers 
 " Realm " , " realm " , className , " newObject " , " boolean " , " update " , " Map < RealmObject , RealmObject > " , " cache " ) ; / / Argument type & argument name 
 
 - writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; 
 + if ( metadata . hasPrimaryKey ( ) ) { 
 + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class , newObject . % s ( ) ) " , className , className , metadata . getPrimaryKeyGetter ( ) ) ; 
 + } else { 
 + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; 
 + } 
 writer . emitStatement ( " cache . put ( newObject , realmObject ) " ) ; 
 for ( VariableElement field : metadata . getFields ( ) ) { 
 String fieldName = field . getSimpleName ( ) . toString ( ) ; 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index b87516d . . cd0e555 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 46 , 6 + 46 , 7 @ @ import io . realm . entities . NonLatinFieldNames ; 
 import io . realm . entities . Owner ; 
 import io . realm . entities . OwnerPrimaryKey ; 
 import io . realm . entities . PrimaryKeyAsLong ; 
 + import io . realm . entities . PrimaryKeyAsString ; 
 import io . realm . entities . PrimaryKeyMix ; 
 import io . realm . entities . StringOnly ; 
 import io . realm . exceptions . RealmException ; 
 @ @ - 1067 , 6 + 1068 , 26 @ @ public class RealmTest extends AndroidTestCase { 
 assertArrayEquals ( new byte [ 0 ] , realmTypes . getColumnBinary ( ) ) ; 
 } 
 
 + / / Check that using copyToRealm will set the primary key directly instead of first setting 
 + / / it to the default value ( which can fail ) 
 + public void testCopyToRealmWithPrimaryKeySetValueDirectly ( ) { 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . createObject ( OwnerPrimaryKey . class ) ; 
 + testRealm . copyToRealm ( new OwnerPrimaryKey ( 1 , " Foo " ) ) ; 
 + testRealm . commitTransaction ( ) ; 
 + assertEquals ( 2 , testRealm . where ( OwnerPrimaryKey . class ) . count ( ) ) ; 
 + } 
 + 
 + public void testCopyToRealmWithPrimaryAsNullThrows ( ) { 
 + testRealm . beginTransaction ( ) ; 
 + try { 
 + testRealm . copyToRealm ( new PrimaryKeyAsString ( ) ) ; 
 + fail ( ) ; 
 + } catch ( RealmException expected ) { 
 + } finally { 
 + testRealm . cancelTransaction ( ) ; 
 + } 
 + } 
 
 public void testCopyToRealmList ( ) { 
 Dog dog1 = new Dog ( ) ; 
 @ @ - 1500 , 7 + 1521 , 6 @ @ public class RealmTest extends AndroidTestCase { 
 fail ( ) ; 
 } catch ( IllegalStateException ignored ) { 
 } 
 - 
 } 
 
 public void testUpdateObjectWithLinks ( ) throws Exception { 
 diff - - git a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 index 3bba1b0 . . ce53189 100644 
 - - - a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 + + + b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 @ @ - 26 , 6 + 26 , 13 @ @ public class PrimaryKeyAsString extends RealmObject { 
 
 private long id ; 
 
 + public PrimaryKeyAsString ( ) { 
 + } 
 + 
 + public PrimaryKeyAsString ( String name ) { 
 + this . name = name ; 
 + } 
 + 
 public String getName ( ) { 
 return name ; 
 } 
 diff - - git a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 index cbb78bf . . 3106ea9 100644 
 - - - a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 + + + b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 @ @ - 36 , 7 + 36 , 24 @ @ public class JNITransactions extends AndroidTestCase { 
 } 
 } 
 
 - 
 + private Table getTableWithStringPrimaryKey ( ) { 
 + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; 
 + WriteTransaction trans = db . beginWrite ( ) ; 
 + Table t = trans . getTable ( " TestTable " ) ; 
 + t . addColumn ( ColumnType . STRING , " colName " ) ; 
 + t . setPrimaryKey ( " colName " ) ; 
 + return t ; 
 + } 
 + 
 + private Table getTableWithIntegerPrimaryKey ( ) { 
 + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; 
 + WriteTransaction trans = db . beginWrite ( ) ; 
 + Table t = trans . getTable ( " TestTable " ) ; 
 + t . addColumn ( ColumnType . INTEGER , " colName " ) ; 
 + t . setPrimaryKey ( " colName " ) ; 
 + return t ; 
 + } 
 + 
 private void createDBFileName ( ) { 
 testFile = new File ( 
 this . getContext ( ) . getFilesDir ( ) , 
 @ @ - 319 , 24 + 336 , 44 @ @ public class JNITransactions extends AndroidTestCase { 
 fail ( " Primary key not enforced . " ) ; 
 } 
 
 + public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( 42 ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 + } 
 + } 
 
 - 
 - / * ARM Only works for Java 1 . 7 - NOT available in Android . 
 - 
 - @ Test ( enabled = true ) 
 - public void mustReadARM ( ) { 
 - writeOneTransaction ( 1 ) ; 
 - 
 - / / Read from table 
 - / / System . out . println ( " mustReadARM . " ) ; 
 - try ( ReadTransaction t = new ReadTransaction ( db ) ) { 
 - EmployeeTable employees = new EmployeeTable ( t ) ; 
 - assertEquals ( true , employees . isValid ( ) ) ; 
 - assertEquals ( 1 , employees . size ( ) ) ; 
 + public void testAddEmptyRowWithPrimaryKeyNullStringThrows ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( null ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 } 
 - catch ( Throwable e ) { 
 + } 
 
 + public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows ( ) { 
 + Table t = getTableWithIntegerPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( " Foo " ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 } 
 } 
 - * / 
 + 
 + public void testAddEmptyRowWithPrimaryKeyString ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + long rowIndex = t . addEmptyRowWithPrimaryKey ( " Foo " ) ; 
 + assertEquals ( 1 , t . size ( ) ) ; 
 + assertEquals ( " Foo " , t . getRow ( rowIndex ) . getString ( 0 ) ) ; 
 + } 
 + 
 + public void testAddEmptyRowWithPrimaryKeyLong ( ) { 
 + Table t = getTableWithIntegerPrimaryKey ( ) ; 
 + long rowIndex = t . addEmptyRowWithPrimaryKey ( 42 ) ; 
 + assertEquals ( 1 , t . size ( ) ) ; 
 + assertEquals ( 42 , t . getRow ( rowIndex ) . getLong ( 0 ) ) ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index df3156b . . e6ad153 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 1089 , 6 + 1089 , 47 @ @ public final class Realm implements Closeable { 
 return get ( clazz , rowIndex ) ; 
 } 
 
 + / * * 
 + * Creates a new object inside the Realm with the Primary key value initially set . 
 + * If the value violates the primary key constraint , no object will be added and and 
 + * { @ link RealmException will be thrown } . 
 + * 
 + * @ param clazz The Class of the object to create 
 + * @ param primaryKeyValue Value for the primary key field . 
 + * @ return The new object 
 + * @ throws { @ link RealmException } if object could not be created . 
 + * / 
 + < E extends RealmObject > E createObject ( Class < E > clazz , Object primaryKeyValue ) { 
 + Table table ; 
 + table = tables . get ( clazz ) ; 
 + if ( table = = null ) { 
 + Class < ? > generatedClass = getProxyClass ( clazz ) ; 
 + 
 + Method method = initTableMethods . get ( generatedClass ) ; 
 + if ( method = = null ) { 
 + try { 
 + method = generatedClass . getMethod ( " initTable " , new Class [ ] { ImplicitTransaction . class } ) ; 
 + } catch ( NoSuchMethodException e ) { 
 + throw new RealmException ( " Could not find the initTable ( ) method in generated proxy class : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } 
 + initTableMethods . put ( generatedClass , method ) ; 
 + } 
 + 
 + try { 
 + table = ( Table ) method . invoke ( null , transaction ) ; 
 + tables . put ( clazz , table ) ; 
 + } catch ( IllegalAccessException e ) { 
 + throw new RealmException ( " Could not launch the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } catch ( InvocationTargetException e ) { 
 + e . printStackTrace ( ) ; 
 + throw new RealmException ( " An exception occurred while running the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } 
 + } 
 + 
 + long rowIndex = table . addEmptyRowWithPrimaryKey ( primaryKeyValue ) ; 
 + return get ( clazz , rowIndex ) ; 
 + } 
 + 
 private Class < ? > getProxyClass ( Class < ? > clazz ) { 
 
 String simpleClassName = getClassSimpleName ( clazz ) ; 
 diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java 
 index 42d28b0 . . 83be1fd 100644 
 - - - a / realm / src / main / java / io / realm / internal / Table . java 
 + + + b / realm / src / main / java / io / realm / internal / Table . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . internal ; 
 import java . io . Closeable ; 
 import java . util . Date ; 
 
 + import io . realm . annotations . PrimaryKey ; 
 import io . realm . exceptions . RealmException ; 
 
 
 @ @ - 364 , 7 + 365 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 
 protected native void nativeMoveLastOver ( long nativeTablePtr , long rowIndex ) ; 
 
 - / / Row Handling methods . 
 public long addEmptyRow ( ) { 
 checkImmutable ( ) ; 
 if ( hasPrimaryKey ( ) ) { 
 @ @ - 390 , 6 + 390 , 54 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 return nativeAddEmptyRow ( nativePtr , 1 ) ; 
 } 
 
 + public long addEmptyRowWithPrimaryKey ( Object primaryKeyValue ) { 
 + checkImmutable ( ) ; 
 + if ( hasPrimaryKey ( ) ) { 
 + long primaryKeyColumnIndex = getPrimaryKey ( ) ; 
 + ColumnType type = getColumnType ( primaryKeyColumnIndex ) ; 
 + long rowIndex ; 
 + Row row ; 
 + 
 + / / Add with with primary key initially set 
 + switch ( type ) { 
 + case STRING : 
 + if ( ! ( primaryKeyValue instanceof String ) ) { 
 + throw new IllegalArgumentException ( " Primary key value is not a String : " + primaryKeyValue ) ; 
 + } 
 + if ( findFirstString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ! = NO _ MATCH ) { 
 + throwDuplicatePrimaryKeyException ( primaryKeyValue ) ; 
 + } 
 + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; 
 + row = getRow ( rowIndex ) ; 
 + row . setString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ; 
 + break ; 
 + 
 + case INTEGER : 
 + long pkValue ; 
 + try { 
 + pkValue = new Long ( primaryKeyValue . toString ( ) ) ; 
 + } catch ( RuntimeException e ) { 
 + throw new IllegalArgumentException ( " Primary key value is not a long : " + primaryKeyValue ) ; 
 + } 
 + if ( findFirstLong ( primaryKeyColumnIndex , pkValue ) ! = NO _ MATCH ) { 
 + throwDuplicatePrimaryKeyException ( pkValue ) ; 
 + } 
 + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; 
 + row = getRow ( rowIndex ) ; 
 + row . setLong ( primaryKeyColumnIndex , pkValue ) ; 
 + break ; 
 + 
 + default : 
 + throw new RealmException ( " Cannot check for duplicate rows for unsupported primary key type : " + type ) ; 
 + } 
 + 
 + return rowIndex ; 
 + 
 + } else { 
 + throw new IllegalStateException ( getName ( ) + " has no primary key defined " ) ; 
 + } 
 + } 
 + 
 public long addEmptyRows ( long rows ) { 
 checkImmutable ( ) ; 
 if ( rows < 1 ) {
