BLEU SCORE: 0.05522397783539471

TEST MSG: Wait all async tasks done before next test
GENERATED MSG: Fix flaky tests related with async transaction

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index f2ea3c8 . . b36526d 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 1884 , 7 + 1884 , 7 @ @ public class RealmAsyncQueryTests { <nl> @ Test <nl> @ UiThreadTest <nl> public void badVersion _ findAll ( ) throws NoSuchFieldException , IllegalAccessException { <nl> - TestHelper . replaceRealmThreadExectutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; <nl> + TestHelper . replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; <nl> RealmConfiguration config = configFactory . createConfiguration ( ) ; <nl> Realm realm = Realm . getInstance ( config ) ; <nl> realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ @ - 1911 , 6 + 1911 , 7 @ @ public class RealmAsyncQueryTests { <nl> } finally { <nl> realm . close ( ) ; <nl> } <nl> + TestHelper . resetRealmThreadExecutor ( ) ; <nl> } <nl> <nl> / / Test case for https : / / github . com / realm / realm - java / issues / 2417 <nl> @ @ - 1918 , 7 + 1919 , 7 @ @ public class RealmAsyncQueryTests { <nl> @ Test <nl> @ UiThreadTest <nl> public void badVersion _ findAllSortedAsync ( ) throws NoSuchFieldException , IllegalAccessException { <nl> - TestHelper . replaceRealmThreadExectutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; <nl> + TestHelper . replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; <nl> RealmConfiguration config = configFactory . createConfiguration ( ) ; <nl> Realm realm = Realm . getInstance ( config ) ; <nl> realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ @ - 1943 , 6 + 1944 , 7 @ @ public class RealmAsyncQueryTests { <nl> . findAllSortedAsync ( AllTypes . FIELD _ STRING , Sort . ASCENDING , AllTypes . FIELD _ LONG , Sort . DESCENDING ) <nl> . load ( ) ; <nl> realm . close ( ) ; <nl> + TestHelper . resetRealmThreadExecutor ( ) ; <nl> } <nl> <nl> / / Test case for https : / / github . com / realm / realm - java / issues / 2417 <nl> @ @ - 1950 , 7 + 1952 , 7 @ @ public class RealmAsyncQueryTests { <nl> @ Test <nl> @ UiThreadTest <nl> public void badVersion _ distinct ( ) throws NoSuchFieldException , IllegalAccessException { <nl> - TestHelper . replaceRealmThreadExectutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; <nl> + TestHelper . replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; <nl> RealmConfiguration config = configFactory . createConfiguration ( ) ; <nl> Realm realm = Realm . getInstance ( config ) ; <nl> realm . executeTransactionAsync ( new Realm . Transaction ( ) { <nl> @ @ - 1976 , 6 + 1978 , 7 @ @ public class RealmAsyncQueryTests { <nl> . load ( ) ; <nl> <nl> realm . close ( ) ; <nl> + TestHelper . resetRealmThreadExecutor ( ) ; <nl> } <nl> <nl> / / Test case for https : / / github . com / realm / realm - java / issues / 2417 <nl> @ @ - 1983 , 7 + 1986 , 7 @ @ public class RealmAsyncQueryTests { <nl> @ Test <nl> @ RunTestInLooperThread <nl> public void badVersion _ syncTransaction ( ) throws NoSuchFieldException , IllegalAccessException { <nl> - TestHelper . replaceRealmThreadExectutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; <nl> + TestHelper . replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; <nl> Realm realm = looperThread . realm ; <nl> <nl> / / 1 . Make sure that async query is not started <nl> @ @ - 2009 , 6 + 2012 , 7 @ @ public class RealmAsyncQueryTests { <nl> <nl> / / 3 . The async query should now ( hopefully ) fail with a BadVersion <nl> result . load ( ) ; <nl> + TestHelper . resetRealmThreadExecutor ( ) ; <nl> } <nl> <nl> / / handlerController # emptyAsyncRealmObject is accessed from different threads <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java b / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java <nl> index 2239f6d . . 94d2d2e 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java <nl> @ @ - 883 , 8 + 883 , 6 @ @ public class TestHelper { <nl> / / used . Any exception in the ` after ( ) ` code will mask the original error . <nl> TestHelper . awaitOrFail ( signalTestFinished ) ; <nl> } finally { <nl> - / / close the executor <nl> - executorService . shutdownNow ( ) ; <nl> if ( looper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> @ @ - 893 , 6 + 891 , 9 @ @ public class TestHelper { <nl> <nl> / / wait for the finally block to execute & close the Realm <nl> TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + / / Close the executor . <nl> + / / This needs to be called after waiting since it might interrupt waitRealmThreadExecutorFinish ( ) . <nl> + executorService . shutdownNow ( ) ; <nl> <nl> if ( throwable [ 0 ] ! = null ) { <nl> / / throw any assertion errors happened in the background thread <nl> @ @ - 947 , 10 + 948 , 12 @ @ public class TestHelper { <nl> / * * <nl> * Replaces the current thread executor with a another one for testing . <nl> * WARNING : This method should only be called before any async tasks have been started . <nl> + * Call { @ link # resetRealmThreadExecutor ( ) } before test return to reset the excutor to default . <nl> * <nl> * @ param executor { @ link RealmThreadPoolExecutor } that should replace the current one <nl> * / <nl> - public static RealmThreadPoolExecutor replaceRealmThreadExectutor ( RealmThreadPoolExecutor executor ) throws NoSuchFieldException , IllegalAccessException { <nl> + public static RealmThreadPoolExecutor replaceRealmThreadExecutor ( RealmThreadPoolExecutor executor ) <nl> + throws NoSuchFieldException , IllegalAccessException { <nl> Field field = BaseRealm . class . getDeclaredField ( " asyncTaskExecutor " ) ; <nl> field . setAccessible ( true ) ; <nl> RealmThreadPoolExecutor oldExecutor = ( RealmThreadPoolExecutor ) field . get ( null ) ; <nl> @ @ - 959 , 6 + 962 , 37 @ @ public class TestHelper { <nl> } <nl> <nl> / * * <nl> + * This will first wait for finishing all tasks in BaseRealm . asyncTaskExecutor , throws if time out . <nl> + * Then reset the BaseRealm . asyncTaskExecutor to the default value . <nl> + * <nl> + * @ throws NoSuchFieldException <nl> + * @ throws IllegalAccessException <nl> + * / <nl> + public static void resetRealmThreadExecutor ( ) throws NoSuchFieldException , IllegalAccessException { <nl> + waitRealmThreadExecutorFinish ( ) ; <nl> + replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newDefaultExecutor ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Wait and check if all tasks in BaseRealm . asyncTaskExecutor can be finished in 5 seconds , otherwise fail the test . <nl> + * / <nl> + public static void waitRealmThreadExecutorFinish ( ) { <nl> + int counter = 50 ; <nl> + while ( counter > 0 ) { <nl> + if ( BaseRealm . asyncTaskExecutor . getActiveCount ( ) = = 0 ) { <nl> + return ; <nl> + } <nl> + try { <nl> + Thread . sleep ( 100 ) ; <nl> + } catch ( InterruptedException e ) { <nl> + fail ( e . getMessage ( ) ) ; <nl> + } <nl> + counter - - ; <nl> + } <nl> + fail ( " ' BaseRealm . asyncTaskExecutor ' is not finished in " + counter / 10 + " seconds " ) ; <nl> + } <nl> + <nl> + / * * <nl> * Emulates an environment where RxJava is not available . <nl> * <nl> * @ param config { @ link RealmConfiguration } instance to be modified . <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java b / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java <nl> index 2681563 . . 7930566 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java <nl> @ @ - 34 , 6 + 34 , 7 @ @ import java . util . concurrent . ConcurrentHashMap ; <nl> <nl> import io . realm . Realm ; <nl> import io . realm . RealmConfiguration ; <nl> + import io . realm . TestHelper ; <nl> <nl> import static org . junit . Assert . assertTrue ; <nl> <nl> @ @ - 73 , 6 + 74 , 10 @ @ public class TestRealmConfigurationFactory extends TemporaryFolder { <nl> <nl> @ Override <nl> protected void after ( ) { <nl> + / / Wait all async tasks done to ensure successful deleteRealm call . <nl> + / / This will throw when timeout . And the reason of timeout needs to be solved properly . <nl> + TestHelper . waitRealmThreadExecutorFinish ( ) ; <nl> + <nl> try { <nl> for ( RealmConfiguration configuration : configurations ) { <nl> Realm . deleteRealm ( configuration ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / BaseRealm . java b / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> index a9ac886 . . 387f739 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> @ @ - 350 , 15 + 350 , 15 @ @ abstract class BaseRealm implements Closeable { <nl> * changes from this commit . <nl> * / <nl> public void commitTransaction ( ) { <nl> - commitTransaction ( true , true , null ) ; <nl> + commitTransaction ( true , true ) ; <nl> } <nl> <nl> / * * <nl> * Commits an async transaction . This will not trigger any REALM _ CHANGED events . Caller is responsible for handling <nl> * that . <nl> * / <nl> - void commitAsyncTransaction ( Runnable runAfterCommit ) { <nl> - commitTransaction ( false , false , runAfterCommit ) ; <nl> + void commitAsyncTransaction ( ) { <nl> + commitTransaction ( false , false ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 367 , 16 + 367 , 11 @ @ abstract class BaseRealm implements Closeable { <nl> * other threads see the changes to majoyly avoid the flaky tests . <nl> * <nl> * @ param notifyLocalThread set to { @ code false } to prevent this commit from triggering thread local change listeners . <nl> - * @ param runAfterCommit runnable will run after transaction committed but before notification sent . <nl> * / <nl> - void commitTransaction ( boolean notifyLocalThread , boolean notifyOtherThreads , Runnable runAfterCommit ) { <nl> + void commitTransaction ( boolean notifyLocalThread , boolean notifyOtherThreads ) { <nl> checkIfValid ( ) ; <nl> sharedGroupManager . commitAndContinueAsRead ( ) ; <nl> <nl> - if ( runAfterCommit ! = null ) { <nl> - runAfterCommit . run ( ) ; <nl> - } <nl> - <nl> for ( Map . Entry < Handler , String > handlerIntegerEntry : handlers . entrySet ( ) ) { <nl> Handler handler = handlerIntegerEntry . getKey ( ) ; <nl> String realmPath = handlerIntegerEntry . getValue ( ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> index 6173bd3 . . dcc415e 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / Realm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> @ @ - 288 , 7 + 288 , 7 @ @ public final class Realm extends BaseRealm { <nl> } <nl> } finally { <nl> if ( commitNeeded ) { <nl> - realm . commitTransaction ( false , true , null ) ; <nl> + realm . commitTransaction ( false , true ) ; <nl> } else { <nl> realm . cancelTransaction ( ) ; <nl> } <nl> @ @ - 1186 , 15 + 1186 , 11 @ @ public final class Realm extends BaseRealm { <nl> transaction . execute ( bgRealm ) ; <nl> <nl> if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> - bgRealm . commitAsyncTransaction ( new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - / / The bgRealm needs to be closed before post event to caller ' s handler to avoid <nl> - / / concurrency problem . eg . : User wants to delete Realm in the callbacks . <nl> - / / This will close Realm before sending REALM _ CHANGED . <nl> - bgRealm . close ( ) ; <nl> - } <nl> - } ) ; <nl> + bgRealm . commitAsyncTransaction ( ) ; <nl> + / / The bgRealm needs to be closed before posting the REALM _ CHANGED event to the caller ' s handler <nl> + / / to avoid currency problems . This is currently guaranteed by posting <nl> + / / handleAsyncTransactionCompleted below . <nl> + bgRealm . close ( ) ; <nl> transactionCommitted = true ; <nl> } <nl> } catch ( final Throwable e ) {
NEAREST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java <nl> index c814e3b . . 9531e8c 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 2865 , 10 + 2865 , 10 @ @ public class RealmTest { <nl> } <nl> } ) ; <nl> fail ( " Should not be able to invoke removeChangeListener " ) ; <nl> - } catch ( IllegalStateException e ) { <nl> - signalTestFinished . countDown ( ) ; <nl> + } catch ( IllegalStateException ignored ) { <nl> } finally { <nl> realm . close ( ) ; <nl> + signalTestFinished . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> @ @ - 2891 , 10 + 2891 , 10 @ @ public class RealmTest { <nl> try { <nl> realm . removeAllChangeListeners ( ) ; <nl> fail ( " Should not be able to invoke removeChangeListener " ) ; <nl> - } catch ( IllegalStateException e ) { <nl> - signalTestFinished . countDown ( ) ; <nl> + } catch ( IllegalStateException ignored ) { <nl> } finally { <nl> realm . close ( ) ; <nl> + signalTestFinished . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / BaseRealm . java b / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> index 1956ca0 . . 9aa683d 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> @ @ - 291 , 9 + 291 , 24 @ @ abstract class BaseRealm implements Closeable { <nl> * changes from this commit . <nl> * / <nl> public void commitTransaction ( ) { <nl> + commitTransaction ( null ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Commits transaction , runs the given runnable and then sends notifications . The runnable is useful to meet some <nl> + * timing conditions like the async transaction . In async transaction , the background Realm has to be closed before <nl> + * other threads see the changes to majoyly avoid the flaky tests . <nl> + * <nl> + * @ param runAfterCommit runnable will run after transaction committed but before notification sent . <nl> + * / <nl> + void commitTransaction ( Runnable runAfterCommit ) { <nl> checkIfValid ( ) ; <nl> sharedGroupManager . commitAndContinueAsRead ( ) ; <nl> <nl> + if ( runAfterCommit ! = null ) { <nl> + runAfterCommit . run ( ) ; <nl> + } <nl> + <nl> for ( Map . Entry < Handler , String > handlerIntegerEntry : handlers . entrySet ( ) ) { <nl> Handler handler = handlerIntegerEntry . getKey ( ) ; <nl> String realmPath = handlerIntegerEntry . getValue ( ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> index 0905fdb . . b0a2af1 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / Realm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> @ @ - 1104 , 57 + 1104 , 61 @ @ public final class Realm extends BaseRealm { <nl> final Future < ? > pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { <nl> @ Override <nl> public void run ( ) { <nl> - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> - Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> - bgRealm . beginTransaction ( ) ; <nl> - try { <nl> - transaction . execute ( bgRealm ) ; <nl> - <nl> - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> - bgRealm . commitTransaction ( ) ; <nl> - if ( callback ! = null <nl> - & & handler ! = null <nl> - & & ! Thread . currentThread ( ) . isInterrupted ( ) <nl> - & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) ) { <nl> - / / The bgRealm needs to be closed before post event to caller ' s handler to avoid concurrency problem <nl> - / / eg . : User wants to delete Realm in the callbacks . <nl> + if ( Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + return ; <nl> + } <nl> + <nl> + boolean transactionCommitted = false ; <nl> + final Exception [ ] exception = new Exception [ 1 ] ; <nl> + final Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> + bgRealm . beginTransaction ( ) ; <nl> + try { <nl> + transaction . execute ( bgRealm ) ; <nl> + <nl> + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + bgRealm . commitTransaction ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + / / The bgRealm needs to be closed before post event to caller ' s handler to avoid <nl> + / / concurrency problem . eg . : User wants to delete Realm in the callbacks . <nl> + / / This will close Realm before sending REALM _ CHANGED . <nl> bgRealm . close ( ) ; <nl> - handler . post ( new Runnable ( ) { <nl> - @ Override <nl> - public void run ( ) { <nl> - callback . onSuccess ( ) ; <nl> - } <nl> - } ) ; <nl> } <nl> - } else { <nl> - if ( bgRealm . isInTransaction ( ) ) { <nl> - bgRealm . cancelTransaction ( ) ; <nl> - } else { <nl> - RealmLog . w ( " Thread is interrupted . Could not cancel transaction , not currently in a transaction . " ) ; <nl> - } <nl> - } <nl> - <nl> - } catch ( final Exception e ) { <nl> + } ) ; <nl> + transactionCommitted = true ; <nl> + } <nl> + } catch ( final Exception e ) { <nl> + exception [ 0 ] = e ; <nl> + } finally { <nl> + if ( ! bgRealm . isClosed ( ) ) { <nl> if ( bgRealm . isInTransaction ( ) ) { <nl> bgRealm . cancelTransaction ( ) ; <nl> - } else { <nl> + } else if ( exception [ 0 ] ! = null ) { <nl> RealmLog . w ( " Could not cancel transaction , not currently in a transaction . " ) ; <nl> } <nl> - if ( callback ! = null <nl> - & & handler ! = null <nl> - & & ! Thread . currentThread ( ) . isInterrupted ( ) <nl> - & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) ) { <nl> - bgRealm . close ( ) ; <nl> + bgRealm . close ( ) ; <nl> + } <nl> + <nl> + / / Send response as the final step to ensure the bg thread quit before others get the response ! <nl> + if ( callback ! = null <nl> + & & handler ! = null <nl> + & & ! Thread . currentThread ( ) . isInterrupted ( ) <nl> + & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) ) { <nl> + if ( transactionCommitted ) { <nl> handler . post ( new Runnable ( ) { <nl> @ Override <nl> public void run ( ) { <nl> - callback . onError ( e ) ; <nl> + callback . onSuccess ( ) ; <nl> + } <nl> + } ) ; <nl> + } else if ( exception [ 0 ] ! = null ) { <nl> + / / transaction has not been canceled by there is a exception during transaction . <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + callback . onError ( exception [ 0 ] ) ; <nl> } <nl> } ) ; <nl> - } <nl> - } finally { <nl> - if ( ! bgRealm . isClosed ( ) ) { <nl> - bgRealm . close ( ) ; <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index f2ea3c8 . . b36526d 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 1884 , 7 + 1884 , 7 @ @ public class RealmAsyncQueryTests { 
 @ Test 
 @ UiThreadTest 
 public void badVersion _ findAll ( ) throws NoSuchFieldException , IllegalAccessException { 
 - TestHelper . replaceRealmThreadExectutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; 
 + TestHelper . replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; 
 RealmConfiguration config = configFactory . createConfiguration ( ) ; 
 Realm realm = Realm . getInstance ( config ) ; 
 realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ @ - 1911 , 6 + 1911 , 7 @ @ public class RealmAsyncQueryTests { 
 } finally { 
 realm . close ( ) ; 
 } 
 + TestHelper . resetRealmThreadExecutor ( ) ; 
 } 
 
 / / Test case for https : / / github . com / realm / realm - java / issues / 2417 
 @ @ - 1918 , 7 + 1919 , 7 @ @ public class RealmAsyncQueryTests { 
 @ Test 
 @ UiThreadTest 
 public void badVersion _ findAllSortedAsync ( ) throws NoSuchFieldException , IllegalAccessException { 
 - TestHelper . replaceRealmThreadExectutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; 
 + TestHelper . replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; 
 RealmConfiguration config = configFactory . createConfiguration ( ) ; 
 Realm realm = Realm . getInstance ( config ) ; 
 realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ @ - 1943 , 6 + 1944 , 7 @ @ public class RealmAsyncQueryTests { 
 . findAllSortedAsync ( AllTypes . FIELD _ STRING , Sort . ASCENDING , AllTypes . FIELD _ LONG , Sort . DESCENDING ) 
 . load ( ) ; 
 realm . close ( ) ; 
 + TestHelper . resetRealmThreadExecutor ( ) ; 
 } 
 
 / / Test case for https : / / github . com / realm / realm - java / issues / 2417 
 @ @ - 1950 , 7 + 1952 , 7 @ @ public class RealmAsyncQueryTests { 
 @ Test 
 @ UiThreadTest 
 public void badVersion _ distinct ( ) throws NoSuchFieldException , IllegalAccessException { 
 - TestHelper . replaceRealmThreadExectutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; 
 + TestHelper . replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; 
 RealmConfiguration config = configFactory . createConfiguration ( ) ; 
 Realm realm = Realm . getInstance ( config ) ; 
 realm . executeTransactionAsync ( new Realm . Transaction ( ) { 
 @ @ - 1976 , 6 + 1978 , 7 @ @ public class RealmAsyncQueryTests { 
 . load ( ) ; 
 
 realm . close ( ) ; 
 + TestHelper . resetRealmThreadExecutor ( ) ; 
 } 
 
 / / Test case for https : / / github . com / realm / realm - java / issues / 2417 
 @ @ - 1983 , 7 + 1986 , 7 @ @ public class RealmAsyncQueryTests { 
 @ Test 
 @ RunTestInLooperThread 
 public void badVersion _ syncTransaction ( ) throws NoSuchFieldException , IllegalAccessException { 
 - TestHelper . replaceRealmThreadExectutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; 
 + TestHelper . replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newSingleThreadExecutor ( ) ) ; 
 Realm realm = looperThread . realm ; 
 
 / / 1 . Make sure that async query is not started 
 @ @ - 2009 , 6 + 2012 , 7 @ @ public class RealmAsyncQueryTests { 
 
 / / 3 . The async query should now ( hopefully ) fail with a BadVersion 
 result . load ( ) ; 
 + TestHelper . resetRealmThreadExecutor ( ) ; 
 } 
 
 / / handlerController # emptyAsyncRealmObject is accessed from different threads 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java b / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java 
 index 2239f6d . . 94d2d2e 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / TestHelper . java 
 @ @ - 883 , 8 + 883 , 6 @ @ public class TestHelper { 
 / / used . Any exception in the ` after ( ) ` code will mask the original error . 
 TestHelper . awaitOrFail ( signalTestFinished ) ; 
 } finally { 
 - / / close the executor 
 - executorService . shutdownNow ( ) ; 
 if ( looper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 @ @ - 893 , 6 + 891 , 9 @ @ public class TestHelper { 
 
 / / wait for the finally block to execute & close the Realm 
 TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + / / Close the executor . 
 + / / This needs to be called after waiting since it might interrupt waitRealmThreadExecutorFinish ( ) . 
 + executorService . shutdownNow ( ) ; 
 
 if ( throwable [ 0 ] ! = null ) { 
 / / throw any assertion errors happened in the background thread 
 @ @ - 947 , 10 + 948 , 12 @ @ public class TestHelper { 
 / * * 
 * Replaces the current thread executor with a another one for testing . 
 * WARNING : This method should only be called before any async tasks have been started . 
 + * Call { @ link # resetRealmThreadExecutor ( ) } before test return to reset the excutor to default . 
 * 
 * @ param executor { @ link RealmThreadPoolExecutor } that should replace the current one 
 * / 
 - public static RealmThreadPoolExecutor replaceRealmThreadExectutor ( RealmThreadPoolExecutor executor ) throws NoSuchFieldException , IllegalAccessException { 
 + public static RealmThreadPoolExecutor replaceRealmThreadExecutor ( RealmThreadPoolExecutor executor ) 
 + throws NoSuchFieldException , IllegalAccessException { 
 Field field = BaseRealm . class . getDeclaredField ( " asyncTaskExecutor " ) ; 
 field . setAccessible ( true ) ; 
 RealmThreadPoolExecutor oldExecutor = ( RealmThreadPoolExecutor ) field . get ( null ) ; 
 @ @ - 959 , 6 + 962 , 37 @ @ public class TestHelper { 
 } 
 
 / * * 
 + * This will first wait for finishing all tasks in BaseRealm . asyncTaskExecutor , throws if time out . 
 + * Then reset the BaseRealm . asyncTaskExecutor to the default value . 
 + * 
 + * @ throws NoSuchFieldException 
 + * @ throws IllegalAccessException 
 + * / 
 + public static void resetRealmThreadExecutor ( ) throws NoSuchFieldException , IllegalAccessException { 
 + waitRealmThreadExecutorFinish ( ) ; 
 + replaceRealmThreadExecutor ( RealmThreadPoolExecutor . newDefaultExecutor ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Wait and check if all tasks in BaseRealm . asyncTaskExecutor can be finished in 5 seconds , otherwise fail the test . 
 + * / 
 + public static void waitRealmThreadExecutorFinish ( ) { 
 + int counter = 50 ; 
 + while ( counter > 0 ) { 
 + if ( BaseRealm . asyncTaskExecutor . getActiveCount ( ) = = 0 ) { 
 + return ; 
 + } 
 + try { 
 + Thread . sleep ( 100 ) ; 
 + } catch ( InterruptedException e ) { 
 + fail ( e . getMessage ( ) ) ; 
 + } 
 + counter - - ; 
 + } 
 + fail ( " ' BaseRealm . asyncTaskExecutor ' is not finished in " + counter / 10 + " seconds " ) ; 
 + } 
 + 
 + / * * 
 * Emulates an environment where RxJava is not available . 
 * 
 * @ param config { @ link RealmConfiguration } instance to be modified . 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java b / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java 
 index 2681563 . . 7930566 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / rule / TestRealmConfigurationFactory . java 
 @ @ - 34 , 6 + 34 , 7 @ @ import java . util . concurrent . ConcurrentHashMap ; 
 
 import io . realm . Realm ; 
 import io . realm . RealmConfiguration ; 
 + import io . realm . TestHelper ; 
 
 import static org . junit . Assert . assertTrue ; 
 
 @ @ - 73 , 6 + 74 , 10 @ @ public class TestRealmConfigurationFactory extends TemporaryFolder { 
 
 @ Override 
 protected void after ( ) { 
 + / / Wait all async tasks done to ensure successful deleteRealm call . 
 + / / This will throw when timeout . And the reason of timeout needs to be solved properly . 
 + TestHelper . waitRealmThreadExecutorFinish ( ) ; 
 + 
 try { 
 for ( RealmConfiguration configuration : configurations ) { 
 Realm . deleteRealm ( configuration ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / BaseRealm . java b / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 index a9ac886 . . 387f739 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 @ @ - 350 , 15 + 350 , 15 @ @ abstract class BaseRealm implements Closeable { 
 * changes from this commit . 
 * / 
 public void commitTransaction ( ) { 
 - commitTransaction ( true , true , null ) ; 
 + commitTransaction ( true , true ) ; 
 } 
 
 / * * 
 * Commits an async transaction . This will not trigger any REALM _ CHANGED events . Caller is responsible for handling 
 * that . 
 * / 
 - void commitAsyncTransaction ( Runnable runAfterCommit ) { 
 - commitTransaction ( false , false , runAfterCommit ) ; 
 + void commitAsyncTransaction ( ) { 
 + commitTransaction ( false , false ) ; 
 } 
 
 / * * 
 @ @ - 367 , 16 + 367 , 11 @ @ abstract class BaseRealm implements Closeable { 
 * other threads see the changes to majoyly avoid the flaky tests . 
 * 
 * @ param notifyLocalThread set to { @ code false } to prevent this commit from triggering thread local change listeners . 
 - * @ param runAfterCommit runnable will run after transaction committed but before notification sent . 
 * / 
 - void commitTransaction ( boolean notifyLocalThread , boolean notifyOtherThreads , Runnable runAfterCommit ) { 
 + void commitTransaction ( boolean notifyLocalThread , boolean notifyOtherThreads ) { 
 checkIfValid ( ) ; 
 sharedGroupManager . commitAndContinueAsRead ( ) ; 
 
 - if ( runAfterCommit ! = null ) { 
 - runAfterCommit . run ( ) ; 
 - } 
 - 
 for ( Map . Entry < Handler , String > handlerIntegerEntry : handlers . entrySet ( ) ) { 
 Handler handler = handlerIntegerEntry . getKey ( ) ; 
 String realmPath = handlerIntegerEntry . getValue ( ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java 
 index 6173bd3 . . dcc415e 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / Realm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / Realm . java 
 @ @ - 288 , 7 + 288 , 7 @ @ public final class Realm extends BaseRealm { 
 } 
 } finally { 
 if ( commitNeeded ) { 
 - realm . commitTransaction ( false , true , null ) ; 
 + realm . commitTransaction ( false , true ) ; 
 } else { 
 realm . cancelTransaction ( ) ; 
 } 
 @ @ - 1186 , 15 + 1186 , 11 @ @ public final class Realm extends BaseRealm { 
 transaction . execute ( bgRealm ) ; 
 
 if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 - bgRealm . commitAsyncTransaction ( new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - / / The bgRealm needs to be closed before post event to caller ' s handler to avoid 
 - / / concurrency problem . eg . : User wants to delete Realm in the callbacks . 
 - / / This will close Realm before sending REALM _ CHANGED . 
 - bgRealm . close ( ) ; 
 - } 
 - } ) ; 
 + bgRealm . commitAsyncTransaction ( ) ; 
 + / / The bgRealm needs to be closed before posting the REALM _ CHANGED event to the caller ' s handler 
 + / / to avoid currency problems . This is currently guaranteed by posting 
 + / / handleAsyncTransactionCompleted below . 
 + bgRealm . close ( ) ; 
 transactionCommitted = true ; 
 } 
 } catch ( final Throwable e ) {

NEAREST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java 
 index c814e3b . . 9531e8c 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 2865 , 10 + 2865 , 10 @ @ public class RealmTest { 
 } 
 } ) ; 
 fail ( " Should not be able to invoke removeChangeListener " ) ; 
 - } catch ( IllegalStateException e ) { 
 - signalTestFinished . countDown ( ) ; 
 + } catch ( IllegalStateException ignored ) { 
 } finally { 
 realm . close ( ) ; 
 + signalTestFinished . countDown ( ) ; 
 } 
 } 
 } ) ; 
 @ @ - 2891 , 10 + 2891 , 10 @ @ public class RealmTest { 
 try { 
 realm . removeAllChangeListeners ( ) ; 
 fail ( " Should not be able to invoke removeChangeListener " ) ; 
 - } catch ( IllegalStateException e ) { 
 - signalTestFinished . countDown ( ) ; 
 + } catch ( IllegalStateException ignored ) { 
 } finally { 
 realm . close ( ) ; 
 + signalTestFinished . countDown ( ) ; 
 } 
 } 
 } ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / BaseRealm . java b / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 index 1956ca0 . . 9aa683d 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 @ @ - 291 , 9 + 291 , 24 @ @ abstract class BaseRealm implements Closeable { 
 * changes from this commit . 
 * / 
 public void commitTransaction ( ) { 
 + commitTransaction ( null ) ; 
 + } 
 + 
 + / * * 
 + * Commits transaction , runs the given runnable and then sends notifications . The runnable is useful to meet some 
 + * timing conditions like the async transaction . In async transaction , the background Realm has to be closed before 
 + * other threads see the changes to majoyly avoid the flaky tests . 
 + * 
 + * @ param runAfterCommit runnable will run after transaction committed but before notification sent . 
 + * / 
 + void commitTransaction ( Runnable runAfterCommit ) { 
 checkIfValid ( ) ; 
 sharedGroupManager . commitAndContinueAsRead ( ) ; 
 
 + if ( runAfterCommit ! = null ) { 
 + runAfterCommit . run ( ) ; 
 + } 
 + 
 for ( Map . Entry < Handler , String > handlerIntegerEntry : handlers . entrySet ( ) ) { 
 Handler handler = handlerIntegerEntry . getKey ( ) ; 
 String realmPath = handlerIntegerEntry . getValue ( ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java 
 index 0905fdb . . b0a2af1 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / Realm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / Realm . java 
 @ @ - 1104 , 57 + 1104 , 61 @ @ public final class Realm extends BaseRealm { 
 final Future < ? > pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 - Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 - bgRealm . beginTransaction ( ) ; 
 - try { 
 - transaction . execute ( bgRealm ) ; 
 - 
 - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 - bgRealm . commitTransaction ( ) ; 
 - if ( callback ! = null 
 - & & handler ! = null 
 - & & ! Thread . currentThread ( ) . isInterrupted ( ) 
 - & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) ) { 
 - / / The bgRealm needs to be closed before post event to caller ' s handler to avoid concurrency problem 
 - / / eg . : User wants to delete Realm in the callbacks . 
 + if ( Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + return ; 
 + } 
 + 
 + boolean transactionCommitted = false ; 
 + final Exception [ ] exception = new Exception [ 1 ] ; 
 + final Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 + bgRealm . beginTransaction ( ) ; 
 + try { 
 + transaction . execute ( bgRealm ) ; 
 + 
 + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + bgRealm . commitTransaction ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + / / The bgRealm needs to be closed before post event to caller ' s handler to avoid 
 + / / concurrency problem . eg . : User wants to delete Realm in the callbacks . 
 + / / This will close Realm before sending REALM _ CHANGED . 
 bgRealm . close ( ) ; 
 - handler . post ( new Runnable ( ) { 
 - @ Override 
 - public void run ( ) { 
 - callback . onSuccess ( ) ; 
 - } 
 - } ) ; 
 } 
 - } else { 
 - if ( bgRealm . isInTransaction ( ) ) { 
 - bgRealm . cancelTransaction ( ) ; 
 - } else { 
 - RealmLog . w ( " Thread is interrupted . Could not cancel transaction , not currently in a transaction . " ) ; 
 - } 
 - } 
 - 
 - } catch ( final Exception e ) { 
 + } ) ; 
 + transactionCommitted = true ; 
 + } 
 + } catch ( final Exception e ) { 
 + exception [ 0 ] = e ; 
 + } finally { 
 + if ( ! bgRealm . isClosed ( ) ) { 
 if ( bgRealm . isInTransaction ( ) ) { 
 bgRealm . cancelTransaction ( ) ; 
 - } else { 
 + } else if ( exception [ 0 ] ! = null ) { 
 RealmLog . w ( " Could not cancel transaction , not currently in a transaction . " ) ; 
 } 
 - if ( callback ! = null 
 - & & handler ! = null 
 - & & ! Thread . currentThread ( ) . isInterrupted ( ) 
 - & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) ) { 
 - bgRealm . close ( ) ; 
 + bgRealm . close ( ) ; 
 + } 
 + 
 + / / Send response as the final step to ensure the bg thread quit before others get the response ! 
 + if ( callback ! = null 
 + & & handler ! = null 
 + & & ! Thread . currentThread ( ) . isInterrupted ( ) 
 + & & handler . getLooper ( ) . getThread ( ) . isAlive ( ) ) { 
 + if ( transactionCommitted ) { 
 handler . post ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 - callback . onError ( e ) ; 
 + callback . onSuccess ( ) ; 
 + } 
 + } ) ; 
 + } else if ( exception [ 0 ] ! = null ) { 
 + / / transaction has not been canceled by there is a exception during transaction . 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + callback . onError ( exception [ 0 ] ) ; 
 } 
 } ) ; 
 - } 
 - } finally { 
 - if ( ! bgRealm . isClosed ( ) ) { 
 - bgRealm . close ( ) ; 
 } 
 } 
 }
