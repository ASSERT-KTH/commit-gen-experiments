BLEU SCORE: 0.2259005009024612

TEST MSG: Remove useless code
GENERATED MSG: WiP

TEST DIFF (one line): diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> index 052d8bb . . d971354 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> @ @ - 31 , 7 + 31 , 6 @ @ import java . util . NoSuchElementException ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . Future ; <nl> <nl> - import io . realm . internal . CheckedRow ; <nl> import io . realm . internal . InvalidRow ; <nl> import io . realm . internal . RealmObjectProxy ; <nl> import io . realm . internal . Row ; <nl> @ @ - 95 , 12 + 94 , 6 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> / / clear it . <nl> private boolean viewUpdated = false ; <nl> <nl> - / / Public for static checking in JNI <nl> - public static final byte AGGREGATE _ FUNCTION _ MINIMUM = 1 ; <nl> - public static final byte AGGREGATE _ FUNCTION _ MAXIMUM = 2 ; <nl> - public static final byte AGGREGATE _ FUNCTION _ AVERAGE = 3 ; <nl> - public static final byte AGGREGATE _ FUNCTION _ SUM = 4 ; <nl> - <nl> static < E extends RealmModel > RealmResults < E > createFromTableQuery ( BaseRealm realm , TableQuery query , Class < E > clazz ) { <nl> return new RealmResults < E > ( realm , query , clazz ) ; <nl> } <nl> @ @ - 135 , 29 + 128 , 6 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> this . collection = collection ; <nl> } <nl> <nl> - private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz , String fieldNames [ ] , Sort [ ] sortOrder ) { <nl> - this . realm = realm ; <nl> - this . classSpec = clazz ; <nl> - this . query = query ; <nl> - <nl> - boolean [ ] order = null ; <nl> - long [ ] indices = null ; <nl> - <nl> - if ( fieldNames ! = null & & sortOrder ! = null ) { <nl> - order = new boolean [ sortOrder . length ] ; <nl> - indices = new long [ sortOrder . length ] ; <nl> - if ( sortOrder . length ! = fieldNames . length ) { <nl> - throw new IllegalArgumentException ( " Number of field names and sort orders does not match " ) ; <nl> - } <nl> - for ( int i = 0 ; i < sortOrder . length ; i + + ) { <nl> - order [ i ] = sortOrder [ i ] = = Sort . ASCENDING ; <nl> - indices [ i ] = getColumnIndexForSort ( fieldNames [ i ] ) ; <nl> - } <nl> - } <nl> - <nl> - collection = null ; <nl> - } <nl> - <nl> private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz ) { <nl> this . realm = realm ; <nl> this . classSpec = clazz ;
NEAREST DIFF (one line): diff - - git a / realm / realm - library / src / main / cpp / CMakeLists . txt b / realm / realm - library / src / main / cpp / CMakeLists . txt <nl> index 8d9ce2b . . 3d156b0 100644 <nl> - - - a / realm / realm - library / src / main / cpp / CMakeLists . txt <nl> + + + b / realm / realm - library / src / main / cpp / CMakeLists . txt <nl> @ @ - 37 , 7 + 37 , 7 @ @ set ( classes _ LIST <nl> io . realm . internal . LinkView io . realm . internal . Util io . realm . internal . UncheckedRow <nl> io . realm . internal . TableQuery io . realm . internal . SharedRealm io . realm . internal . TestUtil <nl> io . realm . log . LogLevel io . realm . log . RealmLog io . realm . Property io . realm . RealmSchema <nl> - io . realm . RealmObjectSchema <nl> + io . realm . RealmObjectSchema io . realm . RealmResults <nl> ) <nl> # / . / is the workaround for the problem that AS cannot find the jni headers . <nl> # See https : / / github . com / googlesamples / android - ndk / issues / 319 <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> index 7bc4df2 . . 29121bf 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> @ @ - 89 , 6 + 89 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> / / clear it . <nl> private boolean viewUpdated = false ; <nl> <nl> + private final long nativePtr ; <nl> + <nl> + static < E extends RealmModel > RealmResults < E > createFromQuery ( BaseRealm realm , TableQuery query , Class < E > clazz , <nl> + String fieldNames [ ] , Sort [ ] sortOrder ) { <nl> + return new RealmResults < E > ( realm , query , clazz , fieldNames , sortOrder ) ; <nl> + } <nl> <nl> static < E extends RealmModel > RealmResults < E > createFromTableQuery ( BaseRealm realm , TableQuery query , Class < E > clazz ) { <nl> return new RealmResults < E > ( realm , query , clazz ) ; <nl> @ @ - 110 , 16 + 116 , 34 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> return realmResults ; <nl> } <nl> <nl> + private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz , String fieldNames [ ] , Sort [ ] sortOrder ) { <nl> + this . realm = realm ; <nl> + this . classSpec = clazz ; <nl> + this . query = query ; <nl> + <nl> + if ( sortOrder . length ! = fieldNames . length ) { <nl> + throw new IllegalArgumentException ( " Number of field names and sort orders does not match " ) ; <nl> + } <nl> + <nl> + boolean [ ] order = new boolean [ sortOrder . length ] ; <nl> + for ( int i = 0 ; i < sortOrder . length ; i + + ) { <nl> + order [ i ] = sortOrder [ i ] = = Sort . ASCENDING ; <nl> + } <nl> + this . nativePtr = nativeCreateResults ( realm . sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , order ) ; <nl> + } <nl> + <nl> private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz ) { <nl> this . realm = realm ; <nl> this . classSpec = clazz ; <nl> this . query = query ; <nl> + this . nativePtr = 0 ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , TableQuery query , String className ) { <nl> this . realm = realm ; <nl> this . query = query ; <nl> this . className = className ; <nl> + this . nativePtr = 0 ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , TableOrView table , Class < E > classSpec ) { <nl> @ @ - 130 , 6 + 154 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> this . pendingQuery = null ; <nl> this . query = null ; <nl> this . currentTableViewVersion = table . syncIfNeeded ( ) ; <nl> + this . nativePtr = 0 ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , String className ) { <nl> @ @ - 138 , 6 + 163 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> <nl> pendingQuery = null ; <nl> query = null ; <nl> + this . nativePtr = 0 ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , TableOrView table , String className ) { <nl> @ @ - 262 , 7 + 288 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> @ Override <nl> public E last ( E defaultValue ) { <nl> return lastImpl ( false , defaultValue ) ; <nl> - <nl> + <nl> } <nl> <nl> private E lastImpl ( boolean shouldThrow , E defaultValue ) { <nl> @ @ - 294 , 8 + 320 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public boolean deleteAllFromRealm ( ) { <nl> realm . checkIfValid ( ) ; <nl> if ( size ( ) > 0 ) { <nl> - TableOrView table = getTableOrView ( ) ; <nl> - table . clear ( ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + TableOrView table = getTableOrView ( ) ; <nl> + table . clear ( ) ; <nl> + } else { <nl> + nativeClear ( nativePtr ) ; <nl> + } <nl> return true ; <nl> } else { <nl> return false ; <nl> @ @ - 413 , 7 + 443 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> if ( ! isLoaded ( ) ) { <nl> return 0 ; <nl> } else { <nl> - long size = getTableOrView ( ) . size ( ) ; <nl> + long size ; <nl> + if ( nativePtr = = 0 ) { <nl> + size = getTableOrView ( ) . size ( ) ; <nl> + } else { <nl> + size = nativeSize ( nativePtr ) ; <nl> + } <nl> return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; <nl> } <nl> } <nl> @ @ - 424 , 15 + 459 , 19 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public Number min ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - switch ( table . getColumnType ( columnIndex ) ) { <nl> - case INTEGER : <nl> - return table . minimumLong ( columnIndex ) ; <nl> - case FLOAT : <nl> - return table . minimumFloat ( columnIndex ) ; <nl> - case DOUBLE : <nl> - return table . minimumDouble ( columnIndex ) ; <nl> - default : <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + switch ( table . getColumnType ( columnIndex ) ) { <nl> + case INTEGER : <nl> + return table . minimumLong ( columnIndex ) ; <nl> + case FLOAT : <nl> + return table . minimumFloat ( columnIndex ) ; <nl> + case DOUBLE : <nl> + return table . minimumDouble ( columnIndex ) ; <nl> + default : <nl> + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> + } <nl> + } else { <nl> + return nativeAggregate ( nativePtr , columnIndex , 1 ) ; <nl> } <nl> } <nl> <nl> @ @ - 1056 , 4 + 1095 , 10 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> } <nl> } <nl> } <nl> + <nl> + native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , boolean [ ] order ) ; <nl> + native long nativeGetRow ( long nativePtr , int index ) ; <nl> + native void nativeClear ( long nativePtr ) ; <nl> + native long nativeSize ( long nativePtr ) ; <nl> + native Object nativeAggregate ( long nativePtr , long columnIndex , byte aggregateFunc ) ; <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java b / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java <nl> index e7ad6c0 . . 9f9cf2d 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java <nl> @ @ - 211 , 7 + 211 , 8 @ @ public final class SharedRealm implements Closeable { <nl> } <nl> } <nl> <nl> - long getNativePtr ( ) { <nl> + / / FIXME : can it be protected ? <nl> + public long getNativePtr ( ) { <nl> return nativePtr ; <nl> } <nl> <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java b / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java <nl> index 5060ad4 . . 80cffcb 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java <nl> @ @ - 60 , 6 + 60 , 11 @ @ public class TableQuery implements Closeable { <nl> this . origin = origin ; <nl> } <nl> <nl> + / / FIXME : can it be protected ? <nl> + public long getNativePtr ( ) { <nl> + return this . nativePtr ; <nl> + } <nl> + <nl> public void close ( ) { <nl> synchronized ( context ) { <nl> if ( nativePtr ! = 0 ) {

TEST DIFF:
diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 index 052d8bb . . d971354 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 @ @ - 31 , 7 + 31 , 6 @ @ import java . util . NoSuchElementException ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . Future ; 
 
 - import io . realm . internal . CheckedRow ; 
 import io . realm . internal . InvalidRow ; 
 import io . realm . internal . RealmObjectProxy ; 
 import io . realm . internal . Row ; 
 @ @ - 95 , 12 + 94 , 6 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 / / clear it . 
 private boolean viewUpdated = false ; 
 
 - / / Public for static checking in JNI 
 - public static final byte AGGREGATE _ FUNCTION _ MINIMUM = 1 ; 
 - public static final byte AGGREGATE _ FUNCTION _ MAXIMUM = 2 ; 
 - public static final byte AGGREGATE _ FUNCTION _ AVERAGE = 3 ; 
 - public static final byte AGGREGATE _ FUNCTION _ SUM = 4 ; 
 - 
 static < E extends RealmModel > RealmResults < E > createFromTableQuery ( BaseRealm realm , TableQuery query , Class < E > clazz ) { 
 return new RealmResults < E > ( realm , query , clazz ) ; 
 } 
 @ @ - 135 , 29 + 128 , 6 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 this . collection = collection ; 
 } 
 
 - private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz , String fieldNames [ ] , Sort [ ] sortOrder ) { 
 - this . realm = realm ; 
 - this . classSpec = clazz ; 
 - this . query = query ; 
 - 
 - boolean [ ] order = null ; 
 - long [ ] indices = null ; 
 - 
 - if ( fieldNames ! = null & & sortOrder ! = null ) { 
 - order = new boolean [ sortOrder . length ] ; 
 - indices = new long [ sortOrder . length ] ; 
 - if ( sortOrder . length ! = fieldNames . length ) { 
 - throw new IllegalArgumentException ( " Number of field names and sort orders does not match " ) ; 
 - } 
 - for ( int i = 0 ; i < sortOrder . length ; i + + ) { 
 - order [ i ] = sortOrder [ i ] = = Sort . ASCENDING ; 
 - indices [ i ] = getColumnIndexForSort ( fieldNames [ i ] ) ; 
 - } 
 - } 
 - 
 - collection = null ; 
 - } 
 - 
 private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz ) { 
 this . realm = realm ; 
 this . classSpec = clazz ;

NEAREST DIFF:
diff - - git a / realm / realm - library / src / main / cpp / CMakeLists . txt b / realm / realm - library / src / main / cpp / CMakeLists . txt 
 index 8d9ce2b . . 3d156b0 100644 
 - - - a / realm / realm - library / src / main / cpp / CMakeLists . txt 
 + + + b / realm / realm - library / src / main / cpp / CMakeLists . txt 
 @ @ - 37 , 7 + 37 , 7 @ @ set ( classes _ LIST 
 io . realm . internal . LinkView io . realm . internal . Util io . realm . internal . UncheckedRow 
 io . realm . internal . TableQuery io . realm . internal . SharedRealm io . realm . internal . TestUtil 
 io . realm . log . LogLevel io . realm . log . RealmLog io . realm . Property io . realm . RealmSchema 
 - io . realm . RealmObjectSchema 
 + io . realm . RealmObjectSchema io . realm . RealmResults 
 ) 
 # / . / is the workaround for the problem that AS cannot find the jni headers . 
 # See https : / / github . com / googlesamples / android - ndk / issues / 319 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 index 7bc4df2 . . 29121bf 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 @ @ - 89 , 6 + 89 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 / / clear it . 
 private boolean viewUpdated = false ; 
 
 + private final long nativePtr ; 
 + 
 + static < E extends RealmModel > RealmResults < E > createFromQuery ( BaseRealm realm , TableQuery query , Class < E > clazz , 
 + String fieldNames [ ] , Sort [ ] sortOrder ) { 
 + return new RealmResults < E > ( realm , query , clazz , fieldNames , sortOrder ) ; 
 + } 
 
 static < E extends RealmModel > RealmResults < E > createFromTableQuery ( BaseRealm realm , TableQuery query , Class < E > clazz ) { 
 return new RealmResults < E > ( realm , query , clazz ) ; 
 @ @ - 110 , 16 + 116 , 34 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 return realmResults ; 
 } 
 
 + private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz , String fieldNames [ ] , Sort [ ] sortOrder ) { 
 + this . realm = realm ; 
 + this . classSpec = clazz ; 
 + this . query = query ; 
 + 
 + if ( sortOrder . length ! = fieldNames . length ) { 
 + throw new IllegalArgumentException ( " Number of field names and sort orders does not match " ) ; 
 + } 
 + 
 + boolean [ ] order = new boolean [ sortOrder . length ] ; 
 + for ( int i = 0 ; i < sortOrder . length ; i + + ) { 
 + order [ i ] = sortOrder [ i ] = = Sort . ASCENDING ; 
 + } 
 + this . nativePtr = nativeCreateResults ( realm . sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , order ) ; 
 + } 
 + 
 private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz ) { 
 this . realm = realm ; 
 this . classSpec = clazz ; 
 this . query = query ; 
 + this . nativePtr = 0 ; 
 } 
 
 private RealmResults ( BaseRealm realm , TableQuery query , String className ) { 
 this . realm = realm ; 
 this . query = query ; 
 this . className = className ; 
 + this . nativePtr = 0 ; 
 } 
 
 private RealmResults ( BaseRealm realm , TableOrView table , Class < E > classSpec ) { 
 @ @ - 130 , 6 + 154 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 this . pendingQuery = null ; 
 this . query = null ; 
 this . currentTableViewVersion = table . syncIfNeeded ( ) ; 
 + this . nativePtr = 0 ; 
 } 
 
 private RealmResults ( BaseRealm realm , String className ) { 
 @ @ - 138 , 6 + 163 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 
 pendingQuery = null ; 
 query = null ; 
 + this . nativePtr = 0 ; 
 } 
 
 private RealmResults ( BaseRealm realm , TableOrView table , String className ) { 
 @ @ - 262 , 7 + 288 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 @ Override 
 public E last ( E defaultValue ) { 
 return lastImpl ( false , defaultValue ) ; 
 - 
 + 
 } 
 
 private E lastImpl ( boolean shouldThrow , E defaultValue ) { 
 @ @ - 294 , 8 + 320 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public boolean deleteAllFromRealm ( ) { 
 realm . checkIfValid ( ) ; 
 if ( size ( ) > 0 ) { 
 - TableOrView table = getTableOrView ( ) ; 
 - table . clear ( ) ; 
 + if ( nativePtr = = 0 ) { 
 + TableOrView table = getTableOrView ( ) ; 
 + table . clear ( ) ; 
 + } else { 
 + nativeClear ( nativePtr ) ; 
 + } 
 return true ; 
 } else { 
 return false ; 
 @ @ - 413 , 7 + 443 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 if ( ! isLoaded ( ) ) { 
 return 0 ; 
 } else { 
 - long size = getTableOrView ( ) . size ( ) ; 
 + long size ; 
 + if ( nativePtr = = 0 ) { 
 + size = getTableOrView ( ) . size ( ) ; 
 + } else { 
 + size = nativeSize ( nativePtr ) ; 
 + } 
 return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; 
 } 
 } 
 @ @ - 424 , 15 + 459 , 19 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public Number min ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - switch ( table . getColumnType ( columnIndex ) ) { 
 - case INTEGER : 
 - return table . minimumLong ( columnIndex ) ; 
 - case FLOAT : 
 - return table . minimumFloat ( columnIndex ) ; 
 - case DOUBLE : 
 - return table . minimumDouble ( columnIndex ) ; 
 - default : 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 + if ( nativePtr = = 0 ) { 
 + switch ( table . getColumnType ( columnIndex ) ) { 
 + case INTEGER : 
 + return table . minimumLong ( columnIndex ) ; 
 + case FLOAT : 
 + return table . minimumFloat ( columnIndex ) ; 
 + case DOUBLE : 
 + return table . minimumDouble ( columnIndex ) ; 
 + default : 
 + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 + } 
 + } else { 
 + return nativeAggregate ( nativePtr , columnIndex , 1 ) ; 
 } 
 } 
 
 @ @ - 1056 , 4 + 1095 , 10 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 } 
 } 
 } 
 + 
 + native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , boolean [ ] order ) ; 
 + native long nativeGetRow ( long nativePtr , int index ) ; 
 + native void nativeClear ( long nativePtr ) ; 
 + native long nativeSize ( long nativePtr ) ; 
 + native Object nativeAggregate ( long nativePtr , long columnIndex , byte aggregateFunc ) ; 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java b / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java 
 index e7ad6c0 . . 9f9cf2d 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / SharedRealm . java 
 @ @ - 211 , 7 + 211 , 8 @ @ public final class SharedRealm implements Closeable { 
 } 
 } 
 
 - long getNativePtr ( ) { 
 + / / FIXME : can it be protected ? 
 + public long getNativePtr ( ) { 
 return nativePtr ; 
 } 
 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java b / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java 
 index 5060ad4 . . 80cffcb 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / TableQuery . java 
 @ @ - 60 , 6 + 60 , 11 @ @ public class TableQuery implements Closeable { 
 this . origin = origin ; 
 } 
 
 + / / FIXME : can it be protected ? 
 + public long getNativePtr ( ) { 
 + return this . nativePtr ; 
 + } 
 + 
 public void close ( ) { 
 synchronized ( context ) { 
 if ( nativePtr ! = 0 ) {
