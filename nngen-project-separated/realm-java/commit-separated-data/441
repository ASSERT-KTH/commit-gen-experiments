BLEU SCORE: 0.05341087579952926

TEST MSG: Get findAllAsync and findFirstAsync back
GENERATED MSG: Add PendingRow to suport findFirst

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java <nl> index 1946af6 . . 32764c7 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java <nl> @ @ - 2601 , 7 + 2601 , 7 @ @ public class RealmQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void findAllSorted _ async _ onSubObjectField ( ) { <nl> + public void findAllSortedAsync _ onSubObjectField ( ) { <nl> Realm realm = looperThread . realm ; <nl> populateTestRealm ( realm , TEST _ DATA _ SIZE ) ; <nl> RealmResults < AllTypes > results = realm . where ( AllTypes . class ) <nl> @ @ - 2636 , 7 + 2636 , 7 @ @ public class RealmQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void findAllSorted _ async _ listOnSubObjectField ( ) { <nl> + public void findAllSortedAsync _ listOnSubObjectField ( ) { <nl> Realm realm = looperThread . realm ; <nl> String [ ] fieldNames = new String [ 2 ] ; <nl> fieldNames [ 0 ] = AllTypes . FIELD _ REALMOBJECT + " . " + Dog . FIELD _ AGE ; <nl> @ @ - 2798 , 21 + 2798 , 33 @ @ public class RealmQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void distinct _ async ( ) throws Throwable { <nl> + public void distinctAsync ( ) throws Throwable { <nl> final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; <nl> final Realm realm = looperThread . realm ; <nl> final long numberOfBlocks = 25 ; <nl> final long numberOfObjects = 10 ; / / must be greater than 1 <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> - final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> + <nl> + assertFalse ( distinctBool . isLoaded ( ) ) ; <nl> + assertTrue ( distinctBool . isValid ( ) ) ; <nl> + assertTrue ( distinctBool . isEmpty ( ) ) ; <nl> + <nl> + assertFalse ( distinctLong . isLoaded ( ) ) ; <nl> + assertTrue ( distinctLong . isValid ( ) ) ; <nl> + assertTrue ( distinctLong . isEmpty ( ) ) ; <nl> + <nl> + assertFalse ( distinctDate . isLoaded ( ) ) ; <nl> + assertTrue ( distinctDate . isValid ( ) ) ; <nl> + assertTrue ( distinctDate . isEmpty ( ) ) ; <nl> + <nl> + assertFalse ( distinctString . isLoaded ( ) ) ; <nl> + assertTrue ( distinctString . isValid ( ) ) ; <nl> + assertTrue ( distinctString . isEmpty ( ) ) ; <nl> <nl> final Runnable endTest = new Runnable ( ) { <nl> @ Override <nl> @ @ - 2862 , 7 + 2874 , 7 @ @ public class RealmQueryTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void distinct _ async _ withNullValues ( ) throws Throwable { <nl> + public void distinctAsync _ withNullValues ( ) throws Throwable { <nl> final AtomicInteger changeListenerCalled = new AtomicInteger ( 2 ) ; <nl> final Realm realm = looperThread . realm ; <nl> final long numberOfBlocks = 25 ; <nl> @ @ - 2904 , 6 + 2916 , 55 @ @ public class RealmQueryTests { <nl> } <nl> <nl> @ Test <nl> + public void distinctAsync _ doesNotExist ( ) { <nl> + final long numberOfBlocks = 25 ; <nl> + final long numberOfObjects = 10 ; <nl> + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> + <nl> + try { <nl> + realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( " doesNotExist " ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void distinctAsync _ invalidTypes ( ) { <nl> + populateTestRealm ( realm , TEST _ DATA _ SIZE ) ; <nl> + <nl> + for ( String field : new String [ ] { AllTypes . FIELD _ REALMOBJECT , AllTypes . FIELD _ REALMLIST , AllTypes . FIELD _ DOUBLE , AllTypes . FIELD _ FLOAT } ) { <nl> + try { <nl> + realm . where ( AllTypes . class ) . distinctAsync ( field ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void distinctAsync _ indexedLinkedFields ( ) { <nl> + final long numberOfBlocks = 25 ; <nl> + final long numberOfObjects = 10 ; <nl> + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> + <nl> + for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { <nl> + try { <nl> + realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; <nl> + fail ( " Unsupported " + field + " linked field " ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void distinctAsync _ notIndexedLinkedFields ( ) { <nl> + populateForDistinctInvalidTypesLinked ( realm ) ; <nl> + <nl> + try { <nl> + realm . where ( AllJavaTypes . class ) . distinctAsync ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> public void distinctMultiArgs ( ) { <nl> final long numberOfBlocks = 25 ; <nl> final long numberOfObjects = 10 ; / / must be greater than 1 <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java <nl> index 5664434 . . 5c92ab9 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java <nl> @ @ - 49 , 6 + 49 , 7 @ @ import io . realm . rule . RunTestInLooperThread ; <nl> import io . realm . rule . TestRealmConfigurationFactory ; <nl> <nl> import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> import static org . junit . Assert . assertNull ; <nl> import static org . junit . Assert . assertTrue ; <nl> import static org . junit . Assert . fail ; <nl> @ @ - 103 , 6 + 104 , 7 @ @ public class RealmResultsTests extends CollectionTests { <nl> public void size _ returns _ Integer _ MAX _ VALUE _ for _ huge _ results ( ) { <nl> final Collection collection = Mockito . mock ( Collection . class ) ; <nl> final RealmResults < AllTypes > targetResult = TestHelper . newRealmResults ( realm , collection , AllTypes . class ) ; <nl> + targetResult . load ( ) ; <nl> <nl> Mockito . when ( collection . size ( ) ) . thenReturn ( ( ( long ) Integer . MAX _ VALUE ) - 1 ) ; <nl> assertEquals ( Integer . MAX _ VALUE - 1 , targetResult . size ( ) ) ; <nl> @ @ - 414 , 21 + 416 , 33 @ @ public class RealmResultsTests extends CollectionTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void distinct _ async ( ) throws Throwable { <nl> + public void distinctAsync ( ) throws Throwable { <nl> final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; <nl> final Realm realm = looperThread . realm ; <nl> final long numberOfBlocks = 25 ; <nl> final long numberOfObjects = 10 ; / / must be greater than 1 <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> <nl> - final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> + <nl> + assertFalse ( distinctBool . isLoaded ( ) ) ; <nl> + assertTrue ( distinctBool . isValid ( ) ) ; <nl> + assertTrue ( distinctBool . isEmpty ( ) ) ; <nl> + <nl> + assertFalse ( distinctLong . isLoaded ( ) ) ; <nl> + assertTrue ( distinctLong . isValid ( ) ) ; <nl> + assertTrue ( distinctLong . isEmpty ( ) ) ; <nl> + <nl> + assertFalse ( distinctDate . isLoaded ( ) ) ; <nl> + assertTrue ( distinctDate . isValid ( ) ) ; <nl> + assertTrue ( distinctDate . isEmpty ( ) ) ; <nl> + <nl> + assertFalse ( distinctString . isLoaded ( ) ) ; <nl> + assertTrue ( distinctString . isValid ( ) ) ; <nl> + assertTrue ( distinctString . isEmpty ( ) ) ; <nl> <nl> final Runnable endTest = new Runnable ( ) { <nl> @ Override <nl> @ @ - 478 , 17 + 492 , 23 @ @ public class RealmResultsTests extends CollectionTests { <nl> <nl> @ Test <nl> @ RunTestInLooperThread <nl> - public void distinct _ async _ withNullValues ( ) throws Throwable { <nl> + public void distinctAsync _ withNullValues ( ) throws Throwable { <nl> final AtomicInteger changeListenerCalled = new AtomicInteger ( 2 ) ; <nl> final Realm realm = looperThread . realm ; <nl> final long numberOfBlocks = 25 ; <nl> final long numberOfObjects = 10 ; / / must be greater than 1 <nl> populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; <nl> <nl> - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; <nl> - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) <nl> - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; <nl> + final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; <nl> + <nl> + assertFalse ( distinctDate . isLoaded ( ) ) ; <nl> + assertTrue ( distinctDate . isValid ( ) ) ; <nl> + assertTrue ( distinctDate . isEmpty ( ) ) ; <nl> + <nl> + assertFalse ( distinctString . isLoaded ( ) ) ; <nl> + assertTrue ( distinctString . isValid ( ) ) ; <nl> + assertTrue ( distinctString . isEmpty ( ) ) ; <nl> <nl> final Runnable endTest = new Runnable ( ) { <nl> @ Override <nl> @ @ - 519 , 6 + 539 , 70 @ @ public class RealmResultsTests extends CollectionTests { <nl> } <nl> <nl> @ Test <nl> + public void distinctAsync _ notIndexedFields ( ) { <nl> + final long numberOfBlocks = 25 ; <nl> + final long numberOfObjects = 10 ; <nl> + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> + <nl> + for ( String field : AnnotationIndexTypes . NOT _ INDEX _ FIELDS ) { <nl> + try { <nl> + realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( field ) ; <nl> + fail ( field ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void distinctAsync _ doesNotExist ( ) { <nl> + final long numberOfBlocks = 25 ; <nl> + final long numberOfObjects = 10 ; <nl> + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> + <nl> + try { <nl> + realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( " doesNotExist " ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void distinctAsync _ invalidTypes ( ) { <nl> + populateTestRealm ( realm , TEST _ DATA _ SIZE ) ; <nl> + <nl> + for ( String field : new String [ ] { AllTypes . FIELD _ REALMOBJECT , AllTypes . FIELD _ REALMLIST , AllTypes . FIELD _ DOUBLE , AllTypes . FIELD _ FLOAT } ) { <nl> + try { <nl> + realm . where ( AllTypes . class ) . findAll ( ) . distinctAsync ( field ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void distinctAsync _ indexedLinkedFields ( ) { <nl> + final long numberOfBlocks = 25 ; <nl> + final long numberOfObjects = 10 ; <nl> + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; <nl> + <nl> + for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { <nl> + try { <nl> + realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; <nl> + fail ( " Unsupported " + field + " linked field " ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void distinctAsync _ notIndexedLinkedFields ( ) { <nl> + populateForDistinctInvalidTypesLinked ( realm ) ; <nl> + <nl> + try { <nl> + realm . where ( AllJavaTypes . class ) . findAll ( ) . distinctAsync ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> public void distinctMultiArgs ( ) { <nl> final long numberOfBlocks = 25 ; <nl> final long numberOfObjects = 10 ; / / must be greater than 1 <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> index 49e2237 . . d57c2cf 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package io . realm ; <nl> import java . util . List ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> <nl> + import io . realm . internal . InvalidRow ; <nl> import io . realm . internal . PendingRow ; <nl> import io . realm . internal . Row ; <nl> import io . realm . internal . UncheckedRow ; <nl> @ @ - 56 , 10 + 57 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> } <nl> <nl> public Row getRow $ realm ( ) { <nl> - if ( row instanceof PendingRow ) { <nl> - row = ( ( PendingRow ) row ) . executeQuery ( ) ; <nl> - registerToRealmNotifier ( ) ; <nl> - } <nl> return row ; <nl> } <nl> <nl> @ @ - 162 , 6 + 159 , 16 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> return ! ( row instanceof PendingRow ) ; <nl> } <nl> <nl> + public void load ( ) { <nl> + if ( row instanceof PendingRow ) { <nl> + row = ( ( PendingRow ) row ) . executeQuery ( ) ; <nl> + if ( ! ( row instanceof InvalidRow ) ) { <nl> + registerToRealmNotifier ( ) ; <nl> + } <nl> + notifyChangeListeners ( ) ; <nl> + } <nl> + } <nl> + <nl> @ Override <nl> public void onQueryFinished ( Row row ) { <nl> this . row = row ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmObject . java b / realm / realm - library / src / main / java / io / realm / RealmObject . java <nl> index df0a903 . . 487a6ea 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmObject . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmObject . java <nl> @ @ - 286 , 8 + 286 , 11 @ @ public abstract class RealmObject implements RealmModel { <nl> } <nl> <nl> / * * <nl> - * @ return { @ code true } if this is a managed object . <nl> - * @ deprecated see < a href = RealmQuery . html # async - query > Async Queries < / a > for more information . <nl> + * Makes an asynchronous query blocking . This will also trigger any registered listeners . <nl> + * < p > <nl> + * Note : This will return { @ code true } if called for an unmanaged object ( created outside of Realm ) . <nl> + * <nl> + * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> * / <nl> public final boolean load ( ) { <nl> / / noinspection deprecation <nl> @ @ - 295 , 11 + 298 , 21 @ @ public abstract class RealmObject implements RealmModel { <nl> } <nl> <nl> / * * <nl> - * @ return { @ code true } if this is a managed object . <nl> - * @ deprecated see < a href = RealmQuery . html # async - query > Async Queries < / a > for more information . <nl> + * Makes an asynchronous query blocking . This will also trigger any registered listeners . <nl> + * < p > <nl> + * Note : This will return { @ code true } if called for an unmanaged object ( created outside of Realm ) . <nl> + * <nl> + * @ param object RealmObject to force load . <nl> + * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> * / <nl> public static < E extends RealmModel > boolean load ( E object ) { <nl> - return object instanceof RealmObjectProxy ; <nl> + if ( RealmObject . isLoaded ( object ) ) { <nl> + return true ; <nl> + } else if ( object instanceof RealmObjectProxy ) { <nl> + ( ( RealmObjectProxy ) object ) . realmGet $ proxyState ( ) . load ( ) ; <nl> + return true ; <nl> + } <nl> + return false ; <nl> } <nl> <nl> / * * <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> index f0da40e . . e335f4e 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1318 , 15 + 1318 , 24 @ @ public class RealmQuery < E extends RealmModel > { <nl> * / <nl> public RealmResults < E > distinct ( String fieldName ) { <nl> SortDescriptor distinctDescriptor = SortDescriptor . getInstanceForDistinct ( query . getTable ( ) , fieldName ) ; <nl> - Collection collection = new Collection ( realm . sharedRealm , query , null , distinctDescriptor ) ; <nl> - return createRealmResults ( collection ) ; <nl> + return createRealmResults ( query , null , distinctDescriptor , true ) ; <nl> } <nl> <nl> / * * <nl> - * @ deprecated use { @ link # distinct ( String ) } instead . <nl> + * Asynchronously returns a distinct set of objects of a specific class . If the result is <nl> + * sorted , the first object will be returned in case of multiple occurrences , otherwise it is <nl> + * undefined which object is returned . <nl> + * <nl> + * @ param fieldName the field name . <nl> + * @ return immediately a { @ link RealmResults } . Users need to register a listener <nl> + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the <nl> + * query completes . <nl> + * @ throws IllegalArgumentException if a field is { @ code null } , does not exist , is an unsupported type , <nl> + * is not indexed , or points to linked fields . <nl> * / <nl> public RealmResults < E > distinctAsync ( String fieldName ) { <nl> - return distinct ( fieldName ) ; <nl> + SortDescriptor distinctDescriptor = SortDescriptor . getInstanceForDistinct ( query . getTable ( ) , fieldName ) ; <nl> + return createRealmResults ( query , null , distinctDescriptor , false ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 1347 , 8 + 1356 , 7 @ @ public class RealmQuery < E extends RealmModel > { <nl> fieldNames [ 0 ] = firstFieldName ; <nl> System . arraycopy ( remainingFieldNames , 0 , fieldNames , 1 , remainingFieldNames . length ) ; <nl> SortDescriptor distinctDescriptor = SortDescriptor . getInstanceForDistinct ( table . getTable ( ) , fieldNames ) ; <nl> - Collection collection = new Collection ( realm . sharedRealm , query , null , distinctDescriptor ) ; <nl> - return createRealmResults ( collection ) ; <nl> + return createRealmResults ( query , null , distinctDescriptor , true ) ; <nl> } <nl> <nl> / / Aggregates <nl> @ @ - 1502 , 15 + 1510 , 19 @ @ public class RealmQuery < E extends RealmModel > { <nl> * / <nl> @ SuppressWarnings ( " unchecked " ) <nl> public RealmResults < E > findAll ( ) { <nl> - Collection collection = new Collection ( realm . sharedRealm , query ) ; <nl> - return createRealmResults ( collection ) ; <nl> + return createRealmResults ( query , null , null , true ) ; <nl> } <nl> <nl> / * * <nl> - * @ deprecated use { @ link # findAll ( ) } instead . <nl> + * Finds all objects that fulfill the query conditions and sorted by specific field name . <nl> + * This method is only available from a Looper thread . <nl> + * <nl> + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener <nl> + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . <nl> + * @ see io . realm . RealmResults <nl> * / <nl> public RealmResults < E > findAllAsync ( ) { <nl> - return findAll ( ) ; <nl> + return createRealmResults ( query , null , null , false ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 1529 , 16 + 1541 , 21 @ @ public class RealmQuery < E extends RealmModel > { <nl> @ SuppressWarnings ( " unchecked " ) <nl> public RealmResults < E > findAllSorted ( String fieldName , Sort sortOrder ) { <nl> SortDescriptor sortDescriptor = SortDescriptor . getInstanceForSort ( query . getTable ( ) , fieldName , sortOrder ) ; <nl> - <nl> - Collection collection = new Collection ( realm . sharedRealm , query , sortDescriptor ) ; <nl> - return createRealmResults ( collection ) ; <nl> + return createRealmResults ( query , sortDescriptor , null , true ) ; <nl> } <nl> <nl> / * * <nl> - * @ deprecated use { @ link # findAllSorted ( String , Sort ) instead . } <nl> + * Similar to { @ link # findAllSorted ( String , Sort ) } but runs asynchronously on a worker thread <nl> + * ( Need a Realm opened from a looper thread to work ) . <nl> + * <nl> + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener <nl> + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . <nl> + * @ throws java . lang . IllegalArgumentException if field name does not exist or it belongs to a child <nl> + * { @ link RealmObject } or a child { @ link RealmList } . <nl> * / <nl> public RealmResults < E > findAllSortedAsync ( final String fieldName , final Sort sortOrder ) { <nl> - return findAllSorted ( fieldName , sortOrder ) ; <nl> + SortDescriptor sortDescriptor = SortDescriptor . getInstanceForSort ( query . getTable ( ) , fieldName , sortOrder ) ; <nl> + return createRealmResults ( query , sortDescriptor , null , false ) ; <nl> } <nl> <nl> <nl> @ @ - 1559 , 7 + 1576 , 13 @ @ public class RealmQuery < E extends RealmModel > { <nl> } <nl> <nl> / * * <nl> - * @ deprecated use { @ link # findAllSorted ( String ) } instead . <nl> + * Similar to { @ link # findAllSorted ( String ) } but runs asynchronously on a worker thread <nl> + * This method is only available from a Looper thread . <nl> + * <nl> + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener <nl> + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . <nl> + * @ throws java . lang . IllegalArgumentException if the field name does not exist or it belongs to a child <nl> + * { @ link RealmObject } or a child { @ link RealmList } . <nl> * / <nl> public RealmResults < E > findAllSortedAsync ( String fieldName ) { <nl> return findAllSortedAsync ( fieldName , Sort . ASCENDING ) ; <nl> @ @ - 1573 , 16 + 1596 , 14 @ @ public class RealmQuery < E extends RealmModel > { <nl> * <nl> * @ param fieldNames an array of field names to sort by . <nl> * @ param sortOrders how to sort the field names . <nl> - * @ return a { @ link io . realm . RealmResults } containing objects . If no objects match the condition , a list with zero <nl> + * @ return a { @ link io . realm . RealmResults } containing objects . If no objects match the condition , a list with zero <nl> * objects is returned . <nl> * @ throws java . lang . IllegalArgumentException if one of the field names does not exist or it belongs to a child <nl> * { @ link RealmObject } or a child { @ link RealmList } . <nl> * / <nl> public RealmResults < E > findAllSorted ( String fieldNames [ ] , Sort sortOrders [ ] ) { <nl> SortDescriptor sortDescriptor = SortDescriptor . getInstanceForSort ( query . getTable ( ) , fieldNames , sortOrders ) ; <nl> - <nl> - Collection collection = new Collection ( realm . sharedRealm , query , sortDescriptor ) ; <nl> - return createRealmResults ( collection ) ; <nl> + return createRealmResults ( query , sortDescriptor , null , true ) ; <nl> } <nl> <nl> private boolean isDynamicQuery ( ) { <nl> @ @ - 1590 , 10 + 1611 , 19 @ @ public class RealmQuery < E extends RealmModel > { <nl> } <nl> <nl> / * * <nl> - * @ deprecated use { @ link # findAllSorted ( String [ ] , Sort [ ] ) } instead . <nl> + * Similar to { @ link # findAllSorted ( String [ ] , Sort [ ] ) } but runs asynchronously <nl> + * from a worker thread . <nl> + * This method is only available from a Looper thread . <nl> + * <nl> + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener <nl> + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . <nl> + * @ see io . realm . RealmResults <nl> + * @ throws java . lang . IllegalArgumentException if one of the field names does not exist or it belongs to a child <nl> + * { @ link RealmObject } or a child { @ link RealmList } . <nl> * / <nl> public RealmResults < E > findAllSortedAsync ( String fieldNames [ ] , final Sort [ ] sortOrders ) { <nl> - return findAllSorted ( fieldNames , sortOrders ) ; <nl> + SortDescriptor sortDescriptor = SortDescriptor . getInstanceForSort ( query . getTable ( ) , fieldNames , sortOrders ) ; <nl> + return createRealmResults ( query , sortDescriptor , null , false ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 1617 , 7 + 1647 , 13 @ @ public class RealmQuery < E extends RealmModel > { <nl> } <nl> <nl> / * * <nl> - * @ deprecated use { @ link # findAllSorted ( String , Sort , String , Sort ) } instead . <nl> + * Similar to { @ link # findAllSorted ( String , Sort , String , Sort ) } but runs asynchronously on a worker thread <nl> + * This method is only available from a Looper thread . <nl> + * <nl> + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener <nl> + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . <nl> + * @ throws java . lang . IllegalArgumentException if a field name does not exist or it belongs to a child <nl> + * { @ link RealmObject } or a child { @ link RealmList } . <nl> * / <nl> public RealmResults < E > findAllSortedAsync ( String fieldName1 , Sort sortOrder1 , <nl> String fieldName2 , Sort sortOrder2 ) { <nl> @ @ - 1684 , 26 + 1720 , 21 @ @ public class RealmQuery < E extends RealmModel > { <nl> return result ; <nl> } <nl> <nl> - private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { <nl> - if ( fieldNames = = null ) { <nl> - throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; <nl> - } else if ( sortOrders = = null ) { <nl> - throw new IllegalArgumentException ( " sortOrders cannot be ' null ' . " ) ; <nl> - } else if ( fieldNames . length = = 0 ) { <nl> - throw new IllegalArgumentException ( " At least one field name must be specified . " ) ; <nl> - } else if ( fieldNames . length ! = sortOrders . length ) { <nl> - throw new IllegalArgumentException ( String . format ( Locale . ENGLISH , <nl> - " Number of field names ( % d ) and sort orders ( % d ) does not match . " , <nl> - fieldNames . length , sortOrders . length ) ) ; <nl> - } <nl> - } <nl> - <nl> - private RealmResults < E > createRealmResults ( Collection collection ) { <nl> + private RealmResults < E > createRealmResults ( TableQuery query , <nl> + SortDescriptor sortDescriptor , <nl> + SortDescriptor distinctDescriptor , <nl> + boolean loadResults ) { <nl> + RealmResults < E > results ; <nl> + Collection collection = new Collection ( realm . sharedRealm , query , sortDescriptor , distinctDescriptor ) ; <nl> if ( isDynamicQuery ( ) ) { <nl> - return new RealmResults < E > ( realm , collection , className ) ; <nl> + results = new RealmResults < E > ( realm , collection , className ) ; <nl> } else { <nl> - return new RealmResults < E > ( realm , collection , clazz ) ; <nl> + results = new RealmResults < E > ( realm , collection , clazz ) ; <nl> + } <nl> + if ( loadResults ) { <nl> + results . load ( ) ; <nl> } <nl> + return results ; <nl> } <nl> <nl> private long getSourceRowIndexForFirstObject ( ) { <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> index 386d77c . . 0bdd8e5 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> @ @ - 73 , 6 + 73 , 7 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen <nl> String className ; / / Class name used by DynamicRealmObjects <nl> <nl> private final Collection collection ; <nl> + private boolean loadedManually = false ; <nl> <nl> RealmResults ( BaseRealm realm , Collection collection , Class < E > clazz ) { <nl> this . realm = realm ; <nl> @ @ - 130 , 7 + 131 , 7 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen <nl> @ Override <nl> public boolean contains ( Object object ) { <nl> boolean contains = false ; <nl> - if ( object instanceof RealmObjectProxy ) { <nl> + if ( isLoaded ( ) & & object instanceof RealmObjectProxy ) { <nl> RealmObjectProxy proxy = ( RealmObjectProxy ) object ; <nl> / / TODO : Maybe we should just let OS throw ? <nl> if ( proxy . realmGet $ proxyState ( ) . getRealm $ realm ( ) = = realm ) { <nl> @ @ - 360 , 8 + 361 , 11 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen <nl> * / <nl> @ Override <nl> public int size ( ) { <nl> - long size = collection . size ( ) ; <nl> - return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; <nl> + if ( isLoaded ( ) ) { <nl> + long size = collection . size ( ) ; <nl> + return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; <nl> + } <nl> + return 0 ; <nl> } <nl> <nl> / * * <nl> @ @ - 449 , 10 + 453 , 19 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen <nl> } <nl> <nl> / * * <nl> - * @ deprecated use { @ link # distinct ( String ) } instead . <nl> + * Asynchronously returns a distinct set of objects of a specific class . If the result is <nl> + * sorted , the first object will be returned in case of multiple occurrences , otherwise it is <nl> + * undefined which object is returned . <nl> + * <nl> + * @ param fieldName the field name . <nl> + * @ return immediately a { @ link RealmResults } . Users need to register a listener <nl> + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the <nl> + * query completes . <nl> + * @ throws IllegalArgumentException if a field is null , does not exist , is an unsupported type , <nl> + * is not indexed , or points to linked fields . <nl> * / <nl> public RealmResults < E > distinctAsync ( String fieldName ) { <nl> - return distinct ( fieldName ) ; <nl> + return where ( ) . distinctAsync ( fieldName ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 731 , 13 + 744 , 21 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen <nl> * / <nl> public boolean isLoaded ( ) { <nl> realm . checkIfValid ( ) ; <nl> - return collection . getMode ( ) = = Collection . Mode . TABLEVIEW ; <nl> + return loadedManually | | collection . getMode ( ) = = Collection . Mode . TABLEVIEW ; <nl> } <nl> <nl> / * * <nl> - * @ deprecated <nl> + * Makes an asynchronous query blocking . This will also trigger any registered { @ link RealmChangeListener } when <nl> + * the query completes . <nl> + * <nl> + * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> * / <nl> public boolean load ( ) { <nl> + / / The Collection doesn ' t have to be loaded before accessing it if the query has not returned . <nl> + / / Instead , accessing the Collection will just trigger the execution of query if needed . We add this flag is <nl> + / / only to keep the original behavior of those APIs . eg . : For a async RealmResults , before query returns , the <nl> + / / size ( ) call should return 0 instead of running the query get the real size . <nl> + loadedManually = true ; <nl> return true ; <nl> } <nl> <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / Collection . java b / realm / realm - library / src / main / java / io / realm / internal / Collection . java <nl> index 623f50d . . bf0e120 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / Collection . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / Collection . java <nl> @ @ - 148 , 8 + 148 , 11 @ @ public class Collection implements NativeObject { <nl> } <nl> <nl> <nl> + / / neverDetach means the collection won ' t be detached when local transaction starts . This is useful for the <nl> + / / PendingRow implementation . <nl> public Collection ( SharedRealm sharedRealm , TableQuery query , <nl> - SortDescriptor sortDescriptor , SortDescriptor distinctDescriptor ) { <nl> + SortDescriptor sortDescriptor , SortDescriptor distinctDescriptor , <nl> + boolean neverDetach ) { <nl> query . validateQuery ( ) ; <nl> <nl> this . nativePtr = nativeCreateResults ( sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , <nl> @ @ - 160 , 7 + 163 , 14 @ @ public class Collection implements NativeObject { <nl> this . context = sharedRealm . context ; <nl> this . table = query . getTable ( ) ; <nl> this . context . addReference ( this ) ; <nl> - sharedRealm . addCollection ( this ) ; <nl> + if ( ! neverDetach ) { <nl> + sharedRealm . addCollection ( this ) ; <nl> + } <nl> + } <nl> + <nl> + public Collection ( SharedRealm sharedRealm , TableQuery query , <nl> + SortDescriptor sortDescriptor , SortDescriptor distinctDescriptor ) { <nl> + this ( sharedRealm , query , sortDescriptor , distinctDescriptor , false ) ; <nl> } <nl> <nl> public Collection ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> index af4a24a . . 79a3f5a 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> @ @ - 35 , 7 + 35 , 7 @ @ public class PendingRow implements Row { <nl> <nl> public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor , <nl> final boolean returnCheckedRow ) { <nl> - pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; <nl> + pendingCollection = new Collection ( sharedRealm , query , sortDescriptor , null , true ) ; <nl> <nl> listener = new RealmChangeListener < PendingRow > ( ) { <nl> @ Override <nl> @ @ - 212 , 7 + 212 , 7 @ @ public class PendingRow implements Row { <nl> <nl> @ Override <nl> public boolean isAttached ( ) { <nl> - throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> + return false ; <nl> } <nl> <nl> @ Override
NEAREST DIFF (one line): diff - - git a / realm / realm - library / src / main / java / io / realm / HandlerController . java b / realm / realm - library / src / main / java / io / realm / HandlerController . java <nl> index 134ead5 . . 752fdc1 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / HandlerController . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / HandlerController . java <nl> @ @ - 298 , 7 + 298 , 7 @ @ final class HandlerController implements Handler . Callback { <nl> * @ param realmResultsToBeNotified list of all RealmResults listeners that can be notified . <nl> * / <nl> void notifyAllListeners ( List < RealmResults < ? extends RealmModel > > realmResultsToBeNotified ) { <nl> - <nl> + / * <nl> / / Notify all RealmResults ( async and synchronous ) . <nl> for ( Iterator < RealmResults < ? extends RealmModel > > it = realmResultsToBeNotified . iterator ( ) ; ! realm . isClosed ( ) & & it . hasNext ( ) ; ) { <nl> RealmResults < ? extends RealmModel > realmResults = it . next ( ) ; <nl> @ @ - 320 , 6 + 320 , 7 @ @ final class HandlerController implements Handler . Callback { <nl> / / Trigger global listeners last . <nl> / / Note that NotificationTest . callingOrdersOfListeners will fail if orders change . <nl> notifyGlobalListeners ( ) ; <nl> + * / <nl> } <nl> <nl> private void collectAsyncRealmResultsCallbacks ( List < RealmResults < ? extends RealmModel > > resultsToBeNotified ) { <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> index af3d807 . . 3e67066 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ import java . util . List ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . Future ; <nl> <nl> + import io . realm . internal . PendingRow ; <nl> import io . realm . internal . Row ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableQuery ; <nl> @ @ - 29 , 7 + 30 , 7 @ @ import io . realm . log . RealmLog ; <nl> * This implements { @ code RealmObjectProxy } interface , to eliminate copying logic between <nl> * { @ link RealmObject } and { @ link DynamicRealmObject } . <nl> * / <nl> - public final class ProxyState < E extends RealmModel > { <nl> + public final class ProxyState < E extends RealmModel > implements PendingRow . FrontEnd { <nl> private E model ; <nl> private String className ; <nl> private Class < ? extends RealmModel > clazzName ; <nl> @ @ - 163 , 27 + 164 , 8 @ @ public final class ProxyState < E extends RealmModel > { <nl> * / <nl> void notifyChangeListeners $ realm ( ) { <nl> if ( ! listeners . isEmpty ( ) ) { <nl> - boolean notify = false ; <nl> - <nl> - Table table = row . getTable ( ) ; <nl> - if ( table = = null ) { <nl> - / / Completed async queries might result in ` table = = null ` , ` isCompleted = = true ` and ` row = = Row . EMPTY _ ROW ` <nl> - / / We still want to trigger change notifications for these cases . <nl> - / / isLoaded / isValid should be considered properties on RealmObjects as well so any change to these <nl> - / / should trigger a RealmChangeListener . <nl> - notify = true ; <nl> - } else { <nl> - long version = table . getVersion ( ) ; <nl> - if ( currentTableVersion ! = version ) { <nl> - currentTableVersion = version ; <nl> - notify = true ; <nl> - } <nl> - } <nl> - <nl> - if ( notify ) { <nl> - for ( RealmChangeListener listener : listeners ) { <nl> - listener . onChange ( model ) ; <nl> - } <nl> + for ( RealmChangeListener listener : listeners ) { <nl> + listener . onChange ( model ) ; <nl> } <nl> } <nl> } <nl> @ @ - 219 , 4 + 201 , 12 @ @ public final class ProxyState < E extends RealmModel > { <nl> realm . checkIfValid ( ) ; <nl> return getPendingQuery $ realm ( ) = = null | | isCompleted $ realm ( ) ; <nl> } <nl> + <nl> + @ Override <nl> + public void onQueryFinished ( Row row , boolean asyncQuery ) { <nl> + this . row = row ; <nl> + if ( asyncQuery ) { <nl> + notifyChangeListeners $ realm ( ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> index 281fa7d . . 0e20605 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 21 , 22 + 21 , 19 @ @ import java . lang . ref . WeakReference ; <nl> import java . util . Collections ; <nl> import java . util . Date ; <nl> import java . util . Locale ; <nl> - import java . util . concurrent . Callable ; <nl> - import java . util . concurrent . Future ; <nl> <nl> import io . realm . annotations . Required ; <nl> import io . realm . internal . Collection ; <nl> import io . realm . internal . LinkView ; <nl> + import io . realm . internal . PendingRow ; <nl> import io . realm . internal . RealmNotifier ; <nl> import io . realm . internal . RealmObjectProxy ; <nl> - import io . realm . internal . Row ; <nl> import io . realm . internal . SharedRealm ; <nl> import io . realm . internal . SortDescriptor ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableQuery ; <nl> import io . realm . internal . async . ArgumentsHolder ; <nl> import io . realm . internal . async . QueryUpdateTask ; <nl> - import io . realm . log . RealmLog ; <nl> <nl> / * * <nl> * A RealmQuery encapsulates a query on a { @ link io . realm . Realm } or a { @ link io . realm . RealmResults } using the Builder <nl> @ @ - 1649 , 98 + 1646 , 36 @ @ public final class RealmQuery < E extends RealmModel > { <nl> * / <nl> public E findFirst ( ) { <nl> checkQueryIsNotReused ( ) ; <nl> - long tableRowIndex = getSourceRowIndexForFirstObject ( ) ; <nl> - if ( tableRowIndex > = 0 ) { <nl> - E realmObject = realm . get ( clazz , className , tableRowIndex ) ; <nl> - return realmObject ; <nl> - } else { <nl> - return null ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Similar to { @ link # findFirst ( ) } but runs asynchronously on a worker thread <nl> - * This method is only available from a Looper thread . <nl> - * <nl> - * @ return immediately an empty { @ link RealmObject } . Trying to access any field on the returned object <nl> - * before it is loaded will throw an { @ code IllegalStateException } . Use { @ link RealmObject # isLoaded ( ) } to check if <nl> - * the object is fully loaded or register a listener { @ link io . realm . RealmObject # addChangeListener } <nl> - * to be notified when the query completes . If no RealmObject was found after the query completed , the returned <nl> - * RealmObject will have { @ link RealmObject # isLoaded ( ) } set to { @ code true } and { @ link RealmObject # isValid ( ) } set to <nl> - * { @ code false } . <nl> - * / <nl> - public E findFirstAsync ( ) { <nl> - checkQueryIsNotReused ( ) ; <nl> - final WeakReference < RealmNotifier > weakNotifier = getWeakReferenceNotifier ( ) ; <nl> - <nl> - / / handover the query ( to be used by a worker thread ) <nl> - final long handoverQueryPointer = query . handoverQuery ( realm . sharedRealm ) ; <nl> - <nl> - / / save query arguments ( for future update ) <nl> - argumentsHolder = new ArgumentsHolder ( ArgumentsHolder . TYPE _ FIND _ FIRST ) ; <nl> - <nl> - final RealmConfiguration realmConfiguration = realm . getConfiguration ( ) ; <nl> <nl> + / / TODO : The performance by the pending query will be a little bit worse than directly calling core ' s <nl> + / / Query . find ( ) . The overhead comes with core needs to add all the row indices to the vector . However this can <nl> + / / be optimized by adding support of limit in OS ' s Results which is supported by core already . <nl> + PendingRow pendingRow = new PendingRow ( realm . sharedRealm , query , null ) ; <nl> / / prepare an empty reference of the RealmObject , so we can return it immediately ( promise ) <nl> / / then update it once the query complete in the background . <nl> final E result ; <nl> if ( isDynamicQuery ( ) ) { <nl> / / noinspection unchecked <nl> - result = ( E ) new DynamicRealmObject ( className , realm , Row . EMPTY _ ROW ) ; <nl> + result = ( E ) new DynamicRealmObject ( className , realm , pendingRow ) ; <nl> } else { <nl> result = realm . getConfiguration ( ) . getSchemaMediator ( ) . newInstance ( <nl> - clazz , realm , Row . EMPTY _ ROW , realm . getSchema ( ) . getColumnInfo ( clazz ) , <nl> + clazz , realm , pendingRow , realm . getSchema ( ) . getColumnInfo ( clazz ) , <nl> false , Collections . < String > emptyList ( ) ) ; <nl> } <nl> <nl> final RealmObjectProxy proxy = ( RealmObjectProxy ) result ; <nl> - final WeakReference < RealmObjectProxy > realmObjectWeakReference = realm . handlerController . addToAsyncRealmObject ( proxy , this ) ; <nl> - <nl> - final Future < Long > pendingQuery = Realm . asyncTaskExecutor . submitQuery ( new Callable < Long > ( ) { <nl> - @ Override <nl> - public Long call ( ) throws Exception { <nl> - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> - SharedRealm sharedRealm = null ; <nl> - <nl> - try { <nl> - sharedRealm = SharedRealm . getInstance ( realmConfiguration ) ; <nl> - <nl> - long handoverRowPointer = TableQuery . findWithHandover ( sharedRealm , handoverQueryPointer ) ; <nl> - if ( handoverRowPointer = = 0 ) { / / empty row <nl> - realm . handlerController . addToEmptyAsyncRealmObject ( realmObjectWeakReference , RealmQuery . this ) ; <nl> - realm . handlerController . removeFromAsyncRealmObject ( realmObjectWeakReference ) ; <nl> - } <nl> - <nl> - QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmObjectResponse ( ) ; <nl> - result . updatedRow . put ( realmObjectWeakReference , handoverRowPointer ) ; <nl> - result . versionID = sharedRealm . getVersionID ( ) ; <nl> - closeSharedRealmAndSendEventToNotifier ( sharedRealm , <nl> - weakNotifier , QueryUpdateTask . NotifyEvent . COMPLETE _ ASYNC _ OBJECT , result ) ; <nl> - <nl> - return handoverRowPointer ; <nl> - <nl> - } catch ( Throwable e ) { <nl> - RealmLog . error ( e ) ; <nl> - / / handler can ' t throw a checked exception need to wrap it into unchecked Exception <nl> - closeSharedRealmAndSendEventToNotifier ( sharedRealm , <nl> - weakNotifier , QueryUpdateTask . NotifyEvent . THROW _ BACKGROUND _ EXCEPTION , e ) ; <nl> - } finally { <nl> - if ( sharedRealm ! = null & & ! sharedRealm . isClosed ( ) ) { <nl> - sharedRealm . close ( ) ; <nl> - } <nl> - } <nl> - } else { <nl> - TableQuery . nativeCloseQueryHandover ( handoverQueryPointer ) ; <nl> - } <nl> - <nl> - return INVALID _ NATIVE _ POINTER ; <nl> - } <nl> - } ) ; <nl> - proxy . realmGet $ proxyState ( ) . setPendingQuery $ realm ( pendingQuery ) ; <nl> + pendingRow . setFrontEnd ( proxy . realmGet $ proxyState ( ) ) ; <nl> <nl> return result ; <nl> } <nl> <nl> + / * * <nl> + * @ deprecated use { @ link # findFirst ( ) } instead . <nl> + * / <nl> + public E findFirstAsync ( ) { <nl> + return findFirst ( ) ; <nl> + } <nl> + <nl> private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { <nl> if ( fieldNames = = null ) { <nl> throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> index 25fcf2c . . 3f24caf 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> @ @ - 1 , 8 + 1 , 235 @ @ <nl> package io . realm . internal ; <nl> <nl> + import java . lang . ref . WeakReference ; <nl> + import java . util . Date ; <nl> + <nl> + import io . realm . RealmChangeListener ; <nl> + import io . realm . RealmFieldType ; <nl> + <nl> / * * <nl> - * Created by cc on 16 - 11 - 30 . <nl> + * A PendingRow is a row relies on a pending async query . <nl> + * Before the query returns , calling any accessors will immediately execute the query and call the corresponding <nl> + * accessor on the query result . If the query results is empty , an { @ link IllegalStateException } will be thrown . <nl> + * After the query returns , { @ link FrontEnd # onQueryFinished ( Row , boolean ) } will be called to give the front end a <nl> + * chance to reset the row . If the async query returns an empty result , the query will be executed again later until a <nl> + * valid row is contained by the query results . <nl> * / <nl> - <nl> public class PendingRow implements Row { <nl> + <nl> + / / Implement this interface to reset the PendingRow to a Row backed by real data when query returned . <nl> + public interface FrontEnd { <nl> + / / When asyncQuery is true , the pending query is executed asynchronously . Otherwise the query is triggered by <nl> + / / calling any accessors before the async query returns . <nl> + void onQueryFinished ( Row row , boolean asyncQuery ) ; <nl> + } <nl> + <nl> + private static final String EMPTY _ ROW _ MESSAGE = <nl> + " This RealmObject is empty . There isn ' t any objects match the query . " ; <nl> + private static final String PROXY _ NOT _ SET _ MESSAGE = " The ' frontEnd ' has not been set . " ; <nl> + private static final String QUERY _ EXECUTED _ MESSAGE = <nl> + " The query has been executed . This ' PendingRow ' is not valid anymore . " ; <nl> + <nl> + private Collection pendingCollection ; <nl> + private Collection . Listener listener ; <nl> + private WeakReference < FrontEnd > frontEnd ; <nl> + <nl> + public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { <nl> + pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; <nl> + listener = new Collection . Listener ( new RealmChangeListener < PendingRow > ( ) { <nl> + @ Override <nl> + public void onChange ( PendingRow pendingRow ) { <nl> + if ( frontEnd = = null ) { <nl> + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> + } <nl> + / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . <nl> + Row row = pendingCollection . firstUncheckedRow ( ) ; <nl> + if ( frontEnd . get ( ) = = null ) { <nl> + / / The front end is GCed . <nl> + clearPendingCollection ( ) ; <nl> + return ; <nl> + } <nl> + / / If no rows returned by the query , just wait for the query updates until it returns a valid row . <nl> + if ( row ! = null ) { <nl> + / / Ask the front end to reset the row and stop async query . <nl> + frontEnd . get ( ) . onQueryFinished ( row , true ) ; <nl> + clearPendingCollection ( ) ; <nl> + } <nl> + } <nl> + } , this ) ; <nl> + pendingCollection . addListener ( listener ) ; <nl> + } <nl> + <nl> + / / To set the front end of this PendingRow . <nl> + public void setFrontEnd ( FrontEnd frontEnd ) { <nl> + this . frontEnd = new WeakReference < FrontEnd > ( frontEnd ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getColumnCount ( ) { <nl> + return executeQuery ( ) . getColumnCount ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getColumnName ( long columnIndex ) { <nl> + return executeQuery ( ) . getColumnName ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getColumnIndex ( String columnName ) { <nl> + return executeQuery ( ) . getColumnIndex ( columnName ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public RealmFieldType getColumnType ( long columnIndex ) { <nl> + return executeQuery ( ) . getColumnType ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Table getTable ( ) { <nl> + return executeQuery ( ) . getTable ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getIndex ( ) { <nl> + return executeQuery ( ) . getIndex ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getLong ( long columnIndex ) { <nl> + return executeQuery ( ) . getLong ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean getBoolean ( long columnIndex ) { <nl> + return executeQuery ( ) . getBoolean ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public float getFloat ( long columnIndex ) { <nl> + return executeQuery ( ) . getFloat ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public double getDouble ( long columnIndex ) { <nl> + return executeQuery ( ) . getDouble ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Date getDate ( long columnIndex ) { <nl> + return executeQuery ( ) . getDate ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getString ( long columnIndex ) { <nl> + return executeQuery ( ) . getString ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public byte [ ] getBinaryByteArray ( long columnIndex ) { <nl> + return executeQuery ( ) . getBinaryByteArray ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getLink ( long columnIndex ) { <nl> + return executeQuery ( ) . getLink ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isNullLink ( long columnIndex ) { <nl> + return executeQuery ( ) . isNullLink ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public LinkView getLinkList ( long columnIndex ) { <nl> + return executeQuery ( ) . getLinkList ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setLong ( long columnIndex , long value ) { <nl> + executeQuery ( ) . setLong ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setBoolean ( long columnIndex , boolean value ) { <nl> + executeQuery ( ) . setBoolean ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setFloat ( long columnIndex , float value ) { <nl> + executeQuery ( ) . setFloat ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setDouble ( long columnIndex , double value ) { <nl> + executeQuery ( ) . setDouble ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setDate ( long columnIndex , Date date ) { <nl> + executeQuery ( ) . setDate ( columnIndex , date ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setString ( long columnIndex , String value ) { <nl> + executeQuery ( ) . setString ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setBinaryByteArray ( long columnIndex , byte [ ] data ) { <nl> + executeQuery ( ) . setBinaryByteArray ( columnIndex , data ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setLink ( long columnIndex , long value ) { <nl> + executeQuery ( ) . setLink ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void nullifyLink ( long columnIndex ) { <nl> + executeQuery ( ) . nullifyLink ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isNull ( long columnIndex ) { <nl> + return executeQuery ( ) . isNull ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setNull ( long columnIndex ) { <nl> + executeQuery ( ) . setNull ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isAttached ( ) { <nl> + return executeQuery ( ) . isAttached ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasColumn ( String fieldName ) { <nl> + return executeQuery ( ) . hasColumn ( fieldName ) ; <nl> + } <nl> + <nl> + private void clearPendingCollection ( ) { <nl> + pendingCollection . removeListener ( listener ) ; <nl> + pendingCollection = null ; <nl> + listener = null ; <nl> + } <nl> + <nl> + private Row executeQuery ( ) { <nl> + if ( pendingCollection = = null ) { <nl> + throw new IllegalStateException ( QUERY _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + if ( frontEnd = = null ) { <nl> + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> + } <nl> + Row row = pendingCollection . getUncheckedRow ( 0 ) ; <nl> + if ( row = = null ) { <nl> + throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; <nl> + } <nl> + if ( frontEnd . get ( ) ! = null ) { <nl> + frontEnd . get ( ) . onQueryFinished ( pendingCollection . firstUncheckedRow ( ) , false ) ; <nl> + } <nl> + clearPendingCollection ( ) ; <nl> + return row ; <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java <nl> index 7802428 . . 5b5b441 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java <nl> @ @ - 89 , 8 + 89 , 10 @ @ public class UncheckedRow implements NativeObject , Row { <nl> <nl> / / FIXME : Testing code <nl> public static UncheckedRow getByRowPointer ( Table table , long nativeRowPointer ) { <nl> - UncheckedRow row = new UncheckedRow ( table . context , table , nativeRowPointer ) ; <nl> - return row ; <nl> + if ( nativeRowPointer ! = 0 ) { <nl> + return new UncheckedRow ( table . context , table , nativeRowPointer ) ; <nl> + } <nl> + return null ; <nl> } <nl> <nl> / * *

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java 
 index 1946af6 . . 32764c7 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmQueryTests . java 
 @ @ - 2601 , 7 + 2601 , 7 @ @ public class RealmQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void findAllSorted _ async _ onSubObjectField ( ) { 
 + public void findAllSortedAsync _ onSubObjectField ( ) { 
 Realm realm = looperThread . realm ; 
 populateTestRealm ( realm , TEST _ DATA _ SIZE ) ; 
 RealmResults < AllTypes > results = realm . where ( AllTypes . class ) 
 @ @ - 2636 , 7 + 2636 , 7 @ @ public class RealmQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void findAllSorted _ async _ listOnSubObjectField ( ) { 
 + public void findAllSortedAsync _ listOnSubObjectField ( ) { 
 Realm realm = looperThread . realm ; 
 String [ ] fieldNames = new String [ 2 ] ; 
 fieldNames [ 0 ] = AllTypes . FIELD _ REALMOBJECT + " . " + Dog . FIELD _ AGE ; 
 @ @ - 2798 , 21 + 2798 , 33 @ @ public class RealmQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void distinct _ async ( ) throws Throwable { 
 + public void distinctAsync ( ) throws Throwable { 
 final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; 
 final Realm realm = looperThread . realm ; 
 final long numberOfBlocks = 25 ; 
 final long numberOfObjects = 10 ; / / must be greater than 1 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 - final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 + 
 + assertFalse ( distinctBool . isLoaded ( ) ) ; 
 + assertTrue ( distinctBool . isValid ( ) ) ; 
 + assertTrue ( distinctBool . isEmpty ( ) ) ; 
 + 
 + assertFalse ( distinctLong . isLoaded ( ) ) ; 
 + assertTrue ( distinctLong . isValid ( ) ) ; 
 + assertTrue ( distinctLong . isEmpty ( ) ) ; 
 + 
 + assertFalse ( distinctDate . isLoaded ( ) ) ; 
 + assertTrue ( distinctDate . isValid ( ) ) ; 
 + assertTrue ( distinctDate . isEmpty ( ) ) ; 
 + 
 + assertFalse ( distinctString . isLoaded ( ) ) ; 
 + assertTrue ( distinctString . isValid ( ) ) ; 
 + assertTrue ( distinctString . isEmpty ( ) ) ; 
 
 final Runnable endTest = new Runnable ( ) { 
 @ Override 
 @ @ - 2862 , 7 + 2874 , 7 @ @ public class RealmQueryTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void distinct _ async _ withNullValues ( ) throws Throwable { 
 + public void distinctAsync _ withNullValues ( ) throws Throwable { 
 final AtomicInteger changeListenerCalled = new AtomicInteger ( 2 ) ; 
 final Realm realm = looperThread . realm ; 
 final long numberOfBlocks = 25 ; 
 @ @ - 2904 , 6 + 2916 , 55 @ @ public class RealmQueryTests { 
 } 
 
 @ Test 
 + public void distinctAsync _ doesNotExist ( ) { 
 + final long numberOfBlocks = 25 ; 
 + final long numberOfObjects = 10 ; 
 + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 + 
 + try { 
 + realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( " doesNotExist " ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + 
 + @ Test 
 + public void distinctAsync _ invalidTypes ( ) { 
 + populateTestRealm ( realm , TEST _ DATA _ SIZE ) ; 
 + 
 + for ( String field : new String [ ] { AllTypes . FIELD _ REALMOBJECT , AllTypes . FIELD _ REALMLIST , AllTypes . FIELD _ DOUBLE , AllTypes . FIELD _ FLOAT } ) { 
 + try { 
 + realm . where ( AllTypes . class ) . distinctAsync ( field ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + } 
 + 
 + @ Test 
 + public void distinctAsync _ indexedLinkedFields ( ) { 
 + final long numberOfBlocks = 25 ; 
 + final long numberOfObjects = 10 ; 
 + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 + 
 + for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { 
 + try { 
 + realm . where ( AnnotationIndexTypes . class ) . distinctAsync ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; 
 + fail ( " Unsupported " + field + " linked field " ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + } 
 + 
 + @ Test 
 + public void distinctAsync _ notIndexedLinkedFields ( ) { 
 + populateForDistinctInvalidTypesLinked ( realm ) ; 
 + 
 + try { 
 + realm . where ( AllJavaTypes . class ) . distinctAsync ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + 
 + @ Test 
 public void distinctMultiArgs ( ) { 
 final long numberOfBlocks = 25 ; 
 final long numberOfObjects = 10 ; / / must be greater than 1 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java 
 index 5664434 . . 5c92ab9 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTests . java 
 @ @ - 49 , 6 + 49 , 7 @ @ import io . realm . rule . RunTestInLooperThread ; 
 import io . realm . rule . TestRealmConfigurationFactory ; 
 
 import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 import static org . junit . Assert . assertNull ; 
 import static org . junit . Assert . assertTrue ; 
 import static org . junit . Assert . fail ; 
 @ @ - 103 , 6 + 104 , 7 @ @ public class RealmResultsTests extends CollectionTests { 
 public void size _ returns _ Integer _ MAX _ VALUE _ for _ huge _ results ( ) { 
 final Collection collection = Mockito . mock ( Collection . class ) ; 
 final RealmResults < AllTypes > targetResult = TestHelper . newRealmResults ( realm , collection , AllTypes . class ) ; 
 + targetResult . load ( ) ; 
 
 Mockito . when ( collection . size ( ) ) . thenReturn ( ( ( long ) Integer . MAX _ VALUE ) - 1 ) ; 
 assertEquals ( Integer . MAX _ VALUE - 1 , targetResult . size ( ) ) ; 
 @ @ - 414 , 21 + 416 , 33 @ @ public class RealmResultsTests extends CollectionTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void distinct _ async ( ) throws Throwable { 
 + public void distinctAsync ( ) throws Throwable { 
 final AtomicInteger changeListenerCalled = new AtomicInteger ( 4 ) ; 
 final Realm realm = looperThread . realm ; 
 final long numberOfBlocks = 25 ; 
 final long numberOfObjects = 10 ; / / must be greater than 1 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 
 - final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctBool = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ BOOL ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctLong = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ LONG ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 + 
 + assertFalse ( distinctBool . isLoaded ( ) ) ; 
 + assertTrue ( distinctBool . isValid ( ) ) ; 
 + assertTrue ( distinctBool . isEmpty ( ) ) ; 
 + 
 + assertFalse ( distinctLong . isLoaded ( ) ) ; 
 + assertTrue ( distinctLong . isValid ( ) ) ; 
 + assertTrue ( distinctLong . isEmpty ( ) ) ; 
 + 
 + assertFalse ( distinctDate . isLoaded ( ) ) ; 
 + assertTrue ( distinctDate . isValid ( ) ) ; 
 + assertTrue ( distinctDate . isEmpty ( ) ) ; 
 + 
 + assertFalse ( distinctString . isLoaded ( ) ) ; 
 + assertTrue ( distinctString . isValid ( ) ) ; 
 + assertTrue ( distinctString . isEmpty ( ) ) ; 
 
 final Runnable endTest = new Runnable ( ) { 
 @ Override 
 @ @ - 478 , 17 + 492 , 23 @ @ public class RealmResultsTests extends CollectionTests { 
 
 @ Test 
 @ RunTestInLooperThread 
 - public void distinct _ async _ withNullValues ( ) throws Throwable { 
 + public void distinctAsync _ withNullValues ( ) throws Throwable { 
 final AtomicInteger changeListenerCalled = new AtomicInteger ( 2 ) ; 
 final Realm realm = looperThread . realm ; 
 final long numberOfBlocks = 25 ; 
 final long numberOfObjects = 10 ; / / must be greater than 1 
 populateForDistinct ( realm , numberOfBlocks , numberOfObjects , true ) ; 
 
 - final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; 
 - final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) 
 - . distinct ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctDate = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ DATE ) ; 
 + final RealmResults < AnnotationIndexTypes > distinctString = realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ INDEX _ STRING ) ; 
 + 
 + assertFalse ( distinctDate . isLoaded ( ) ) ; 
 + assertTrue ( distinctDate . isValid ( ) ) ; 
 + assertTrue ( distinctDate . isEmpty ( ) ) ; 
 + 
 + assertFalse ( distinctString . isLoaded ( ) ) ; 
 + assertTrue ( distinctString . isValid ( ) ) ; 
 + assertTrue ( distinctString . isEmpty ( ) ) ; 
 
 final Runnable endTest = new Runnable ( ) { 
 @ Override 
 @ @ - 519 , 6 + 539 , 70 @ @ public class RealmResultsTests extends CollectionTests { 
 } 
 
 @ Test 
 + public void distinctAsync _ notIndexedFields ( ) { 
 + final long numberOfBlocks = 25 ; 
 + final long numberOfObjects = 10 ; 
 + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 + 
 + for ( String field : AnnotationIndexTypes . NOT _ INDEX _ FIELDS ) { 
 + try { 
 + realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( field ) ; 
 + fail ( field ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + } 
 + 
 + @ Test 
 + public void distinctAsync _ doesNotExist ( ) { 
 + final long numberOfBlocks = 25 ; 
 + final long numberOfObjects = 10 ; 
 + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 + 
 + try { 
 + realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( " doesNotExist " ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + 
 + @ Test 
 + public void distinctAsync _ invalidTypes ( ) { 
 + populateTestRealm ( realm , TEST _ DATA _ SIZE ) ; 
 + 
 + for ( String field : new String [ ] { AllTypes . FIELD _ REALMOBJECT , AllTypes . FIELD _ REALMLIST , AllTypes . FIELD _ DOUBLE , AllTypes . FIELD _ FLOAT } ) { 
 + try { 
 + realm . where ( AllTypes . class ) . findAll ( ) . distinctAsync ( field ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + } 
 + 
 + @ Test 
 + public void distinctAsync _ indexedLinkedFields ( ) { 
 + final long numberOfBlocks = 25 ; 
 + final long numberOfObjects = 10 ; 
 + populateForDistinct ( realm , numberOfBlocks , numberOfObjects , false ) ; 
 + 
 + for ( String field : AnnotationIndexTypes . INDEX _ FIELDS ) { 
 + try { 
 + realm . where ( AnnotationIndexTypes . class ) . findAll ( ) . distinctAsync ( AnnotationIndexTypes . FIELD _ OBJECT + " . " + field ) ; 
 + fail ( " Unsupported " + field + " linked field " ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + } 
 + 
 + @ Test 
 + public void distinctAsync _ notIndexedLinkedFields ( ) { 
 + populateForDistinctInvalidTypesLinked ( realm ) ; 
 + 
 + try { 
 + realm . where ( AllJavaTypes . class ) . findAll ( ) . distinctAsync ( AllJavaTypes . FIELD _ OBJECT + " . " + AllJavaTypes . FIELD _ BINARY ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } 
 + 
 + @ Test 
 public void distinctMultiArgs ( ) { 
 final long numberOfBlocks = 25 ; 
 final long numberOfObjects = 10 ; / / must be greater than 1 
 diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 index 49e2237 . . d57c2cf 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package io . realm ; 
 import java . util . List ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 
 + import io . realm . internal . InvalidRow ; 
 import io . realm . internal . PendingRow ; 
 import io . realm . internal . Row ; 
 import io . realm . internal . UncheckedRow ; 
 @ @ - 56 , 10 + 57 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 } 
 
 public Row getRow $ realm ( ) { 
 - if ( row instanceof PendingRow ) { 
 - row = ( ( PendingRow ) row ) . executeQuery ( ) ; 
 - registerToRealmNotifier ( ) ; 
 - } 
 return row ; 
 } 
 
 @ @ - 162 , 6 + 159 , 16 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 return ! ( row instanceof PendingRow ) ; 
 } 
 
 + public void load ( ) { 
 + if ( row instanceof PendingRow ) { 
 + row = ( ( PendingRow ) row ) . executeQuery ( ) ; 
 + if ( ! ( row instanceof InvalidRow ) ) { 
 + registerToRealmNotifier ( ) ; 
 + } 
 + notifyChangeListeners ( ) ; 
 + } 
 + } 
 + 
 @ Override 
 public void onQueryFinished ( Row row ) { 
 this . row = row ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmObject . java b / realm / realm - library / src / main / java / io / realm / RealmObject . java 
 index df0a903 . . 487a6ea 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmObject . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmObject . java 
 @ @ - 286 , 8 + 286 , 11 @ @ public abstract class RealmObject implements RealmModel { 
 } 
 
 / * * 
 - * @ return { @ code true } if this is a managed object . 
 - * @ deprecated see < a href = RealmQuery . html # async - query > Async Queries < / a > for more information . 
 + * Makes an asynchronous query blocking . This will also trigger any registered listeners . 
 + * < p > 
 + * Note : This will return { @ code true } if called for an unmanaged object ( created outside of Realm ) . 
 + * 
 + * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 * / 
 public final boolean load ( ) { 
 / / noinspection deprecation 
 @ @ - 295 , 11 + 298 , 21 @ @ public abstract class RealmObject implements RealmModel { 
 } 
 
 / * * 
 - * @ return { @ code true } if this is a managed object . 
 - * @ deprecated see < a href = RealmQuery . html # async - query > Async Queries < / a > for more information . 
 + * Makes an asynchronous query blocking . This will also trigger any registered listeners . 
 + * < p > 
 + * Note : This will return { @ code true } if called for an unmanaged object ( created outside of Realm ) . 
 + * 
 + * @ param object RealmObject to force load . 
 + * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 * / 
 public static < E extends RealmModel > boolean load ( E object ) { 
 - return object instanceof RealmObjectProxy ; 
 + if ( RealmObject . isLoaded ( object ) ) { 
 + return true ; 
 + } else if ( object instanceof RealmObjectProxy ) { 
 + ( ( RealmObjectProxy ) object ) . realmGet $ proxyState ( ) . load ( ) ; 
 + return true ; 
 + } 
 + return false ; 
 } 
 
 / * * 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 index f0da40e . . e335f4e 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1318 , 15 + 1318 , 24 @ @ public class RealmQuery < E extends RealmModel > { 
 * / 
 public RealmResults < E > distinct ( String fieldName ) { 
 SortDescriptor distinctDescriptor = SortDescriptor . getInstanceForDistinct ( query . getTable ( ) , fieldName ) ; 
 - Collection collection = new Collection ( realm . sharedRealm , query , null , distinctDescriptor ) ; 
 - return createRealmResults ( collection ) ; 
 + return createRealmResults ( query , null , distinctDescriptor , true ) ; 
 } 
 
 / * * 
 - * @ deprecated use { @ link # distinct ( String ) } instead . 
 + * Asynchronously returns a distinct set of objects of a specific class . If the result is 
 + * sorted , the first object will be returned in case of multiple occurrences , otherwise it is 
 + * undefined which object is returned . 
 + * 
 + * @ param fieldName the field name . 
 + * @ return immediately a { @ link RealmResults } . Users need to register a listener 
 + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the 
 + * query completes . 
 + * @ throws IllegalArgumentException if a field is { @ code null } , does not exist , is an unsupported type , 
 + * is not indexed , or points to linked fields . 
 * / 
 public RealmResults < E > distinctAsync ( String fieldName ) { 
 - return distinct ( fieldName ) ; 
 + SortDescriptor distinctDescriptor = SortDescriptor . getInstanceForDistinct ( query . getTable ( ) , fieldName ) ; 
 + return createRealmResults ( query , null , distinctDescriptor , false ) ; 
 } 
 
 / * * 
 @ @ - 1347 , 8 + 1356 , 7 @ @ public class RealmQuery < E extends RealmModel > { 
 fieldNames [ 0 ] = firstFieldName ; 
 System . arraycopy ( remainingFieldNames , 0 , fieldNames , 1 , remainingFieldNames . length ) ; 
 SortDescriptor distinctDescriptor = SortDescriptor . getInstanceForDistinct ( table . getTable ( ) , fieldNames ) ; 
 - Collection collection = new Collection ( realm . sharedRealm , query , null , distinctDescriptor ) ; 
 - return createRealmResults ( collection ) ; 
 + return createRealmResults ( query , null , distinctDescriptor , true ) ; 
 } 
 
 / / Aggregates 
 @ @ - 1502 , 15 + 1510 , 19 @ @ public class RealmQuery < E extends RealmModel > { 
 * / 
 @ SuppressWarnings ( " unchecked " ) 
 public RealmResults < E > findAll ( ) { 
 - Collection collection = new Collection ( realm . sharedRealm , query ) ; 
 - return createRealmResults ( collection ) ; 
 + return createRealmResults ( query , null , null , true ) ; 
 } 
 
 / * * 
 - * @ deprecated use { @ link # findAll ( ) } instead . 
 + * Finds all objects that fulfill the query conditions and sorted by specific field name . 
 + * This method is only available from a Looper thread . 
 + * 
 + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener 
 + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . 
 + * @ see io . realm . RealmResults 
 * / 
 public RealmResults < E > findAllAsync ( ) { 
 - return findAll ( ) ; 
 + return createRealmResults ( query , null , null , false ) ; 
 } 
 
 / * * 
 @ @ - 1529 , 16 + 1541 , 21 @ @ public class RealmQuery < E extends RealmModel > { 
 @ SuppressWarnings ( " unchecked " ) 
 public RealmResults < E > findAllSorted ( String fieldName , Sort sortOrder ) { 
 SortDescriptor sortDescriptor = SortDescriptor . getInstanceForSort ( query . getTable ( ) , fieldName , sortOrder ) ; 
 - 
 - Collection collection = new Collection ( realm . sharedRealm , query , sortDescriptor ) ; 
 - return createRealmResults ( collection ) ; 
 + return createRealmResults ( query , sortDescriptor , null , true ) ; 
 } 
 
 / * * 
 - * @ deprecated use { @ link # findAllSorted ( String , Sort ) instead . } 
 + * Similar to { @ link # findAllSorted ( String , Sort ) } but runs asynchronously on a worker thread 
 + * ( Need a Realm opened from a looper thread to work ) . 
 + * 
 + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener 
 + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . 
 + * @ throws java . lang . IllegalArgumentException if field name does not exist or it belongs to a child 
 + * { @ link RealmObject } or a child { @ link RealmList } . 
 * / 
 public RealmResults < E > findAllSortedAsync ( final String fieldName , final Sort sortOrder ) { 
 - return findAllSorted ( fieldName , sortOrder ) ; 
 + SortDescriptor sortDescriptor = SortDescriptor . getInstanceForSort ( query . getTable ( ) , fieldName , sortOrder ) ; 
 + return createRealmResults ( query , sortDescriptor , null , false ) ; 
 } 
 
 
 @ @ - 1559 , 7 + 1576 , 13 @ @ public class RealmQuery < E extends RealmModel > { 
 } 
 
 / * * 
 - * @ deprecated use { @ link # findAllSorted ( String ) } instead . 
 + * Similar to { @ link # findAllSorted ( String ) } but runs asynchronously on a worker thread 
 + * This method is only available from a Looper thread . 
 + * 
 + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener 
 + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . 
 + * @ throws java . lang . IllegalArgumentException if the field name does not exist or it belongs to a child 
 + * { @ link RealmObject } or a child { @ link RealmList } . 
 * / 
 public RealmResults < E > findAllSortedAsync ( String fieldName ) { 
 return findAllSortedAsync ( fieldName , Sort . ASCENDING ) ; 
 @ @ - 1573 , 16 + 1596 , 14 @ @ public class RealmQuery < E extends RealmModel > { 
 * 
 * @ param fieldNames an array of field names to sort by . 
 * @ param sortOrders how to sort the field names . 
 - * @ return a { @ link io . realm . RealmResults } containing objects . If no objects match the condition , a list with zero 
 + * @ return a { @ link io . realm . RealmResults } containing objects . If no objects match the condition , a list with zero 
 * objects is returned . 
 * @ throws java . lang . IllegalArgumentException if one of the field names does not exist or it belongs to a child 
 * { @ link RealmObject } or a child { @ link RealmList } . 
 * / 
 public RealmResults < E > findAllSorted ( String fieldNames [ ] , Sort sortOrders [ ] ) { 
 SortDescriptor sortDescriptor = SortDescriptor . getInstanceForSort ( query . getTable ( ) , fieldNames , sortOrders ) ; 
 - 
 - Collection collection = new Collection ( realm . sharedRealm , query , sortDescriptor ) ; 
 - return createRealmResults ( collection ) ; 
 + return createRealmResults ( query , sortDescriptor , null , true ) ; 
 } 
 
 private boolean isDynamicQuery ( ) { 
 @ @ - 1590 , 10 + 1611 , 19 @ @ public class RealmQuery < E extends RealmModel > { 
 } 
 
 / * * 
 - * @ deprecated use { @ link # findAllSorted ( String [ ] , Sort [ ] ) } instead . 
 + * Similar to { @ link # findAllSorted ( String [ ] , Sort [ ] ) } but runs asynchronously 
 + * from a worker thread . 
 + * This method is only available from a Looper thread . 
 + * 
 + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener 
 + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . 
 + * @ see io . realm . RealmResults 
 + * @ throws java . lang . IllegalArgumentException if one of the field names does not exist or it belongs to a child 
 + * { @ link RealmObject } or a child { @ link RealmList } . 
 * / 
 public RealmResults < E > findAllSortedAsync ( String fieldNames [ ] , final Sort [ ] sortOrders ) { 
 - return findAllSorted ( fieldNames , sortOrders ) ; 
 + SortDescriptor sortDescriptor = SortDescriptor . getInstanceForSort ( query . getTable ( ) , fieldNames , sortOrders ) ; 
 + return createRealmResults ( query , sortDescriptor , null , false ) ; 
 } 
 
 / * * 
 @ @ - 1617 , 7 + 1647 , 13 @ @ public class RealmQuery < E extends RealmModel > { 
 } 
 
 / * * 
 - * @ deprecated use { @ link # findAllSorted ( String , Sort , String , Sort ) } instead . 
 + * Similar to { @ link # findAllSorted ( String , Sort , String , Sort ) } but runs asynchronously on a worker thread 
 + * This method is only available from a Looper thread . 
 + * 
 + * @ return immediately an empty { @ link RealmResults } . Users need to register a listener 
 + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the query completes . 
 + * @ throws java . lang . IllegalArgumentException if a field name does not exist or it belongs to a child 
 + * { @ link RealmObject } or a child { @ link RealmList } . 
 * / 
 public RealmResults < E > findAllSortedAsync ( String fieldName1 , Sort sortOrder1 , 
 String fieldName2 , Sort sortOrder2 ) { 
 @ @ - 1684 , 26 + 1720 , 21 @ @ public class RealmQuery < E extends RealmModel > { 
 return result ; 
 } 
 
 - private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { 
 - if ( fieldNames = = null ) { 
 - throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; 
 - } else if ( sortOrders = = null ) { 
 - throw new IllegalArgumentException ( " sortOrders cannot be ' null ' . " ) ; 
 - } else if ( fieldNames . length = = 0 ) { 
 - throw new IllegalArgumentException ( " At least one field name must be specified . " ) ; 
 - } else if ( fieldNames . length ! = sortOrders . length ) { 
 - throw new IllegalArgumentException ( String . format ( Locale . ENGLISH , 
 - " Number of field names ( % d ) and sort orders ( % d ) does not match . " , 
 - fieldNames . length , sortOrders . length ) ) ; 
 - } 
 - } 
 - 
 - private RealmResults < E > createRealmResults ( Collection collection ) { 
 + private RealmResults < E > createRealmResults ( TableQuery query , 
 + SortDescriptor sortDescriptor , 
 + SortDescriptor distinctDescriptor , 
 + boolean loadResults ) { 
 + RealmResults < E > results ; 
 + Collection collection = new Collection ( realm . sharedRealm , query , sortDescriptor , distinctDescriptor ) ; 
 if ( isDynamicQuery ( ) ) { 
 - return new RealmResults < E > ( realm , collection , className ) ; 
 + results = new RealmResults < E > ( realm , collection , className ) ; 
 } else { 
 - return new RealmResults < E > ( realm , collection , clazz ) ; 
 + results = new RealmResults < E > ( realm , collection , clazz ) ; 
 + } 
 + if ( loadResults ) { 
 + results . load ( ) ; 
 } 
 + return results ; 
 } 
 
 private long getSourceRowIndexForFirstObject ( ) { 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 index 386d77c . . 0bdd8e5 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 @ @ - 73 , 6 + 73 , 7 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen 
 String className ; / / Class name used by DynamicRealmObjects 
 
 private final Collection collection ; 
 + private boolean loadedManually = false ; 
 
 RealmResults ( BaseRealm realm , Collection collection , Class < E > clazz ) { 
 this . realm = realm ; 
 @ @ - 130 , 7 + 131 , 7 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen 
 @ Override 
 public boolean contains ( Object object ) { 
 boolean contains = false ; 
 - if ( object instanceof RealmObjectProxy ) { 
 + if ( isLoaded ( ) & & object instanceof RealmObjectProxy ) { 
 RealmObjectProxy proxy = ( RealmObjectProxy ) object ; 
 / / TODO : Maybe we should just let OS throw ? 
 if ( proxy . realmGet $ proxyState ( ) . getRealm $ realm ( ) = = realm ) { 
 @ @ - 360 , 8 + 361 , 11 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen 
 * / 
 @ Override 
 public int size ( ) { 
 - long size = collection . size ( ) ; 
 - return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; 
 + if ( isLoaded ( ) ) { 
 + long size = collection . size ( ) ; 
 + return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; 
 + } 
 + return 0 ; 
 } 
 
 / * * 
 @ @ - 449 , 10 + 453 , 19 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen 
 } 
 
 / * * 
 - * @ deprecated use { @ link # distinct ( String ) } instead . 
 + * Asynchronously returns a distinct set of objects of a specific class . If the result is 
 + * sorted , the first object will be returned in case of multiple occurrences , otherwise it is 
 + * undefined which object is returned . 
 + * 
 + * @ param fieldName the field name . 
 + * @ return immediately a { @ link RealmResults } . Users need to register a listener 
 + * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the 
 + * query completes . 
 + * @ throws IllegalArgumentException if a field is null , does not exist , is an unsupported type , 
 + * is not indexed , or points to linked fields . 
 * / 
 public RealmResults < E > distinctAsync ( String fieldName ) { 
 - return distinct ( fieldName ) ; 
 + return where ( ) . distinctAsync ( fieldName ) ; 
 } 
 
 / * * 
 @ @ - 731 , 13 + 744 , 21 @ @ public class RealmResults < E extends RealmModel > extends AbstractList < E > implemen 
 * / 
 public boolean isLoaded ( ) { 
 realm . checkIfValid ( ) ; 
 - return collection . getMode ( ) = = Collection . Mode . TABLEVIEW ; 
 + return loadedManually | | collection . getMode ( ) = = Collection . Mode . TABLEVIEW ; 
 } 
 
 / * * 
 - * @ deprecated 
 + * Makes an asynchronous query blocking . This will also trigger any registered { @ link RealmChangeListener } when 
 + * the query completes . 
 + * 
 + * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 * / 
 public boolean load ( ) { 
 + / / The Collection doesn ' t have to be loaded before accessing it if the query has not returned . 
 + / / Instead , accessing the Collection will just trigger the execution of query if needed . We add this flag is 
 + / / only to keep the original behavior of those APIs . eg . : For a async RealmResults , before query returns , the 
 + / / size ( ) call should return 0 instead of running the query get the real size . 
 + loadedManually = true ; 
 return true ; 
 } 
 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / Collection . java b / realm / realm - library / src / main / java / io / realm / internal / Collection . java 
 index 623f50d . . bf0e120 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / Collection . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / Collection . java 
 @ @ - 148 , 8 + 148 , 11 @ @ public class Collection implements NativeObject { 
 } 
 
 
 + / / neverDetach means the collection won ' t be detached when local transaction starts . This is useful for the 
 + / / PendingRow implementation . 
 public Collection ( SharedRealm sharedRealm , TableQuery query , 
 - SortDescriptor sortDescriptor , SortDescriptor distinctDescriptor ) { 
 + SortDescriptor sortDescriptor , SortDescriptor distinctDescriptor , 
 + boolean neverDetach ) { 
 query . validateQuery ( ) ; 
 
 this . nativePtr = nativeCreateResults ( sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , 
 @ @ - 160 , 7 + 163 , 14 @ @ public class Collection implements NativeObject { 
 this . context = sharedRealm . context ; 
 this . table = query . getTable ( ) ; 
 this . context . addReference ( this ) ; 
 - sharedRealm . addCollection ( this ) ; 
 + if ( ! neverDetach ) { 
 + sharedRealm . addCollection ( this ) ; 
 + } 
 + } 
 + 
 + public Collection ( SharedRealm sharedRealm , TableQuery query , 
 + SortDescriptor sortDescriptor , SortDescriptor distinctDescriptor ) { 
 + this ( sharedRealm , query , sortDescriptor , distinctDescriptor , false ) ; 
 } 
 
 public Collection ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 index af4a24a . . 79a3f5a 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 @ @ - 35 , 7 + 35 , 7 @ @ public class PendingRow implements Row { 
 
 public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor , 
 final boolean returnCheckedRow ) { 
 - pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; 
 + pendingCollection = new Collection ( sharedRealm , query , sortDescriptor , null , true ) ; 
 
 listener = new RealmChangeListener < PendingRow > ( ) { 
 @ Override 
 @ @ - 212 , 7 + 212 , 7 @ @ public class PendingRow implements Row { 
 
 @ Override 
 public boolean isAttached ( ) { 
 - throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 + return false ; 
 } 
 
 @ Override

NEAREST DIFF:
diff - - git a / realm / realm - library / src / main / java / io / realm / HandlerController . java b / realm / realm - library / src / main / java / io / realm / HandlerController . java 
 index 134ead5 . . 752fdc1 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / HandlerController . java 
 + + + b / realm / realm - library / src / main / java / io / realm / HandlerController . java 
 @ @ - 298 , 7 + 298 , 7 @ @ final class HandlerController implements Handler . Callback { 
 * @ param realmResultsToBeNotified list of all RealmResults listeners that can be notified . 
 * / 
 void notifyAllListeners ( List < RealmResults < ? extends RealmModel > > realmResultsToBeNotified ) { 
 - 
 + / * 
 / / Notify all RealmResults ( async and synchronous ) . 
 for ( Iterator < RealmResults < ? extends RealmModel > > it = realmResultsToBeNotified . iterator ( ) ; ! realm . isClosed ( ) & & it . hasNext ( ) ; ) { 
 RealmResults < ? extends RealmModel > realmResults = it . next ( ) ; 
 @ @ - 320 , 6 + 320 , 7 @ @ final class HandlerController implements Handler . Callback { 
 / / Trigger global listeners last . 
 / / Note that NotificationTest . callingOrdersOfListeners will fail if orders change . 
 notifyGlobalListeners ( ) ; 
 + * / 
 } 
 
 private void collectAsyncRealmResultsCallbacks ( List < RealmResults < ? extends RealmModel > > resultsToBeNotified ) { 
 diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 index af3d807 . . 3e67066 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 @ @ - 20 , 6 + 20 , 7 @ @ import java . util . List ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . Future ; 
 
 + import io . realm . internal . PendingRow ; 
 import io . realm . internal . Row ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableQuery ; 
 @ @ - 29 , 7 + 30 , 7 @ @ import io . realm . log . RealmLog ; 
 * This implements { @ code RealmObjectProxy } interface , to eliminate copying logic between 
 * { @ link RealmObject } and { @ link DynamicRealmObject } . 
 * / 
 - public final class ProxyState < E extends RealmModel > { 
 + public final class ProxyState < E extends RealmModel > implements PendingRow . FrontEnd { 
 private E model ; 
 private String className ; 
 private Class < ? extends RealmModel > clazzName ; 
 @ @ - 163 , 27 + 164 , 8 @ @ public final class ProxyState < E extends RealmModel > { 
 * / 
 void notifyChangeListeners $ realm ( ) { 
 if ( ! listeners . isEmpty ( ) ) { 
 - boolean notify = false ; 
 - 
 - Table table = row . getTable ( ) ; 
 - if ( table = = null ) { 
 - / / Completed async queries might result in ` table = = null ` , ` isCompleted = = true ` and ` row = = Row . EMPTY _ ROW ` 
 - / / We still want to trigger change notifications for these cases . 
 - / / isLoaded / isValid should be considered properties on RealmObjects as well so any change to these 
 - / / should trigger a RealmChangeListener . 
 - notify = true ; 
 - } else { 
 - long version = table . getVersion ( ) ; 
 - if ( currentTableVersion ! = version ) { 
 - currentTableVersion = version ; 
 - notify = true ; 
 - } 
 - } 
 - 
 - if ( notify ) { 
 - for ( RealmChangeListener listener : listeners ) { 
 - listener . onChange ( model ) ; 
 - } 
 + for ( RealmChangeListener listener : listeners ) { 
 + listener . onChange ( model ) ; 
 } 
 } 
 } 
 @ @ - 219 , 4 + 201 , 12 @ @ public final class ProxyState < E extends RealmModel > { 
 realm . checkIfValid ( ) ; 
 return getPendingQuery $ realm ( ) = = null | | isCompleted $ realm ( ) ; 
 } 
 + 
 + @ Override 
 + public void onQueryFinished ( Row row , boolean asyncQuery ) { 
 + this . row = row ; 
 + if ( asyncQuery ) { 
 + notifyChangeListeners $ realm ( ) ; 
 + } 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 index 281fa7d . . 0e20605 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 @ @ - 21 , 22 + 21 , 19 @ @ import java . lang . ref . WeakReference ; 
 import java . util . Collections ; 
 import java . util . Date ; 
 import java . util . Locale ; 
 - import java . util . concurrent . Callable ; 
 - import java . util . concurrent . Future ; 
 
 import io . realm . annotations . Required ; 
 import io . realm . internal . Collection ; 
 import io . realm . internal . LinkView ; 
 + import io . realm . internal . PendingRow ; 
 import io . realm . internal . RealmNotifier ; 
 import io . realm . internal . RealmObjectProxy ; 
 - import io . realm . internal . Row ; 
 import io . realm . internal . SharedRealm ; 
 import io . realm . internal . SortDescriptor ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableQuery ; 
 import io . realm . internal . async . ArgumentsHolder ; 
 import io . realm . internal . async . QueryUpdateTask ; 
 - import io . realm . log . RealmLog ; 
 
 / * * 
 * A RealmQuery encapsulates a query on a { @ link io . realm . Realm } or a { @ link io . realm . RealmResults } using the Builder 
 @ @ - 1649 , 98 + 1646 , 36 @ @ public final class RealmQuery < E extends RealmModel > { 
 * / 
 public E findFirst ( ) { 
 checkQueryIsNotReused ( ) ; 
 - long tableRowIndex = getSourceRowIndexForFirstObject ( ) ; 
 - if ( tableRowIndex > = 0 ) { 
 - E realmObject = realm . get ( clazz , className , tableRowIndex ) ; 
 - return realmObject ; 
 - } else { 
 - return null ; 
 - } 
 - } 
 - 
 - / * * 
 - * Similar to { @ link # findFirst ( ) } but runs asynchronously on a worker thread 
 - * This method is only available from a Looper thread . 
 - * 
 - * @ return immediately an empty { @ link RealmObject } . Trying to access any field on the returned object 
 - * before it is loaded will throw an { @ code IllegalStateException } . Use { @ link RealmObject # isLoaded ( ) } to check if 
 - * the object is fully loaded or register a listener { @ link io . realm . RealmObject # addChangeListener } 
 - * to be notified when the query completes . If no RealmObject was found after the query completed , the returned 
 - * RealmObject will have { @ link RealmObject # isLoaded ( ) } set to { @ code true } and { @ link RealmObject # isValid ( ) } set to 
 - * { @ code false } . 
 - * / 
 - public E findFirstAsync ( ) { 
 - checkQueryIsNotReused ( ) ; 
 - final WeakReference < RealmNotifier > weakNotifier = getWeakReferenceNotifier ( ) ; 
 - 
 - / / handover the query ( to be used by a worker thread ) 
 - final long handoverQueryPointer = query . handoverQuery ( realm . sharedRealm ) ; 
 - 
 - / / save query arguments ( for future update ) 
 - argumentsHolder = new ArgumentsHolder ( ArgumentsHolder . TYPE _ FIND _ FIRST ) ; 
 - 
 - final RealmConfiguration realmConfiguration = realm . getConfiguration ( ) ; 
 
 + / / TODO : The performance by the pending query will be a little bit worse than directly calling core ' s 
 + / / Query . find ( ) . The overhead comes with core needs to add all the row indices to the vector . However this can 
 + / / be optimized by adding support of limit in OS ' s Results which is supported by core already . 
 + PendingRow pendingRow = new PendingRow ( realm . sharedRealm , query , null ) ; 
 / / prepare an empty reference of the RealmObject , so we can return it immediately ( promise ) 
 / / then update it once the query complete in the background . 
 final E result ; 
 if ( isDynamicQuery ( ) ) { 
 / / noinspection unchecked 
 - result = ( E ) new DynamicRealmObject ( className , realm , Row . EMPTY _ ROW ) ; 
 + result = ( E ) new DynamicRealmObject ( className , realm , pendingRow ) ; 
 } else { 
 result = realm . getConfiguration ( ) . getSchemaMediator ( ) . newInstance ( 
 - clazz , realm , Row . EMPTY _ ROW , realm . getSchema ( ) . getColumnInfo ( clazz ) , 
 + clazz , realm , pendingRow , realm . getSchema ( ) . getColumnInfo ( clazz ) , 
 false , Collections . < String > emptyList ( ) ) ; 
 } 
 
 final RealmObjectProxy proxy = ( RealmObjectProxy ) result ; 
 - final WeakReference < RealmObjectProxy > realmObjectWeakReference = realm . handlerController . addToAsyncRealmObject ( proxy , this ) ; 
 - 
 - final Future < Long > pendingQuery = Realm . asyncTaskExecutor . submitQuery ( new Callable < Long > ( ) { 
 - @ Override 
 - public Long call ( ) throws Exception { 
 - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 - SharedRealm sharedRealm = null ; 
 - 
 - try { 
 - sharedRealm = SharedRealm . getInstance ( realmConfiguration ) ; 
 - 
 - long handoverRowPointer = TableQuery . findWithHandover ( sharedRealm , handoverQueryPointer ) ; 
 - if ( handoverRowPointer = = 0 ) { / / empty row 
 - realm . handlerController . addToEmptyAsyncRealmObject ( realmObjectWeakReference , RealmQuery . this ) ; 
 - realm . handlerController . removeFromAsyncRealmObject ( realmObjectWeakReference ) ; 
 - } 
 - 
 - QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmObjectResponse ( ) ; 
 - result . updatedRow . put ( realmObjectWeakReference , handoverRowPointer ) ; 
 - result . versionID = sharedRealm . getVersionID ( ) ; 
 - closeSharedRealmAndSendEventToNotifier ( sharedRealm , 
 - weakNotifier , QueryUpdateTask . NotifyEvent . COMPLETE _ ASYNC _ OBJECT , result ) ; 
 - 
 - return handoverRowPointer ; 
 - 
 - } catch ( Throwable e ) { 
 - RealmLog . error ( e ) ; 
 - / / handler can ' t throw a checked exception need to wrap it into unchecked Exception 
 - closeSharedRealmAndSendEventToNotifier ( sharedRealm , 
 - weakNotifier , QueryUpdateTask . NotifyEvent . THROW _ BACKGROUND _ EXCEPTION , e ) ; 
 - } finally { 
 - if ( sharedRealm ! = null & & ! sharedRealm . isClosed ( ) ) { 
 - sharedRealm . close ( ) ; 
 - } 
 - } 
 - } else { 
 - TableQuery . nativeCloseQueryHandover ( handoverQueryPointer ) ; 
 - } 
 - 
 - return INVALID _ NATIVE _ POINTER ; 
 - } 
 - } ) ; 
 - proxy . realmGet $ proxyState ( ) . setPendingQuery $ realm ( pendingQuery ) ; 
 + pendingRow . setFrontEnd ( proxy . realmGet $ proxyState ( ) ) ; 
 
 return result ; 
 } 
 
 + / * * 
 + * @ deprecated use { @ link # findFirst ( ) } instead . 
 + * / 
 + public E findFirstAsync ( ) { 
 + return findFirst ( ) ; 
 + } 
 + 
 private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { 
 if ( fieldNames = = null ) { 
 throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 index 25fcf2c . . 3f24caf 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 @ @ - 1 , 8 + 1 , 235 @ @ 
 package io . realm . internal ; 
 
 + import java . lang . ref . WeakReference ; 
 + import java . util . Date ; 
 + 
 + import io . realm . RealmChangeListener ; 
 + import io . realm . RealmFieldType ; 
 + 
 / * * 
 - * Created by cc on 16 - 11 - 30 . 
 + * A PendingRow is a row relies on a pending async query . 
 + * Before the query returns , calling any accessors will immediately execute the query and call the corresponding 
 + * accessor on the query result . If the query results is empty , an { @ link IllegalStateException } will be thrown . 
 + * After the query returns , { @ link FrontEnd # onQueryFinished ( Row , boolean ) } will be called to give the front end a 
 + * chance to reset the row . If the async query returns an empty result , the query will be executed again later until a 
 + * valid row is contained by the query results . 
 * / 
 - 
 public class PendingRow implements Row { 
 + 
 + / / Implement this interface to reset the PendingRow to a Row backed by real data when query returned . 
 + public interface FrontEnd { 
 + / / When asyncQuery is true , the pending query is executed asynchronously . Otherwise the query is triggered by 
 + / / calling any accessors before the async query returns . 
 + void onQueryFinished ( Row row , boolean asyncQuery ) ; 
 + } 
 + 
 + private static final String EMPTY _ ROW _ MESSAGE = 
 + " This RealmObject is empty . There isn ' t any objects match the query . " ; 
 + private static final String PROXY _ NOT _ SET _ MESSAGE = " The ' frontEnd ' has not been set . " ; 
 + private static final String QUERY _ EXECUTED _ MESSAGE = 
 + " The query has been executed . This ' PendingRow ' is not valid anymore . " ; 
 + 
 + private Collection pendingCollection ; 
 + private Collection . Listener listener ; 
 + private WeakReference < FrontEnd > frontEnd ; 
 + 
 + public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { 
 + pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; 
 + listener = new Collection . Listener ( new RealmChangeListener < PendingRow > ( ) { 
 + @ Override 
 + public void onChange ( PendingRow pendingRow ) { 
 + if ( frontEnd = = null ) { 
 + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 + } 
 + / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . 
 + Row row = pendingCollection . firstUncheckedRow ( ) ; 
 + if ( frontEnd . get ( ) = = null ) { 
 + / / The front end is GCed . 
 + clearPendingCollection ( ) ; 
 + return ; 
 + } 
 + / / If no rows returned by the query , just wait for the query updates until it returns a valid row . 
 + if ( row ! = null ) { 
 + / / Ask the front end to reset the row and stop async query . 
 + frontEnd . get ( ) . onQueryFinished ( row , true ) ; 
 + clearPendingCollection ( ) ; 
 + } 
 + } 
 + } , this ) ; 
 + pendingCollection . addListener ( listener ) ; 
 + } 
 + 
 + / / To set the front end of this PendingRow . 
 + public void setFrontEnd ( FrontEnd frontEnd ) { 
 + this . frontEnd = new WeakReference < FrontEnd > ( frontEnd ) ; 
 + } 
 + 
 + @ Override 
 + public long getColumnCount ( ) { 
 + return executeQuery ( ) . getColumnCount ( ) ; 
 + } 
 + 
 + @ Override 
 + public String getColumnName ( long columnIndex ) { 
 + return executeQuery ( ) . getColumnName ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public long getColumnIndex ( String columnName ) { 
 + return executeQuery ( ) . getColumnIndex ( columnName ) ; 
 + } 
 + 
 + @ Override 
 + public RealmFieldType getColumnType ( long columnIndex ) { 
 + return executeQuery ( ) . getColumnType ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public Table getTable ( ) { 
 + return executeQuery ( ) . getTable ( ) ; 
 + } 
 + 
 + @ Override 
 + public long getIndex ( ) { 
 + return executeQuery ( ) . getIndex ( ) ; 
 + } 
 + 
 + @ Override 
 + public long getLong ( long columnIndex ) { 
 + return executeQuery ( ) . getLong ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean getBoolean ( long columnIndex ) { 
 + return executeQuery ( ) . getBoolean ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public float getFloat ( long columnIndex ) { 
 + return executeQuery ( ) . getFloat ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public double getDouble ( long columnIndex ) { 
 + return executeQuery ( ) . getDouble ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public Date getDate ( long columnIndex ) { 
 + return executeQuery ( ) . getDate ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public String getString ( long columnIndex ) { 
 + return executeQuery ( ) . getString ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public byte [ ] getBinaryByteArray ( long columnIndex ) { 
 + return executeQuery ( ) . getBinaryByteArray ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public long getLink ( long columnIndex ) { 
 + return executeQuery ( ) . getLink ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isNullLink ( long columnIndex ) { 
 + return executeQuery ( ) . isNullLink ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public LinkView getLinkList ( long columnIndex ) { 
 + return executeQuery ( ) . getLinkList ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public void setLong ( long columnIndex , long value ) { 
 + executeQuery ( ) . setLong ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setBoolean ( long columnIndex , boolean value ) { 
 + executeQuery ( ) . setBoolean ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setFloat ( long columnIndex , float value ) { 
 + executeQuery ( ) . setFloat ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setDouble ( long columnIndex , double value ) { 
 + executeQuery ( ) . setDouble ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setDate ( long columnIndex , Date date ) { 
 + executeQuery ( ) . setDate ( columnIndex , date ) ; 
 + } 
 + 
 + @ Override 
 + public void setString ( long columnIndex , String value ) { 
 + executeQuery ( ) . setString ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setBinaryByteArray ( long columnIndex , byte [ ] data ) { 
 + executeQuery ( ) . setBinaryByteArray ( columnIndex , data ) ; 
 + } 
 + 
 + @ Override 
 + public void setLink ( long columnIndex , long value ) { 
 + executeQuery ( ) . setLink ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void nullifyLink ( long columnIndex ) { 
 + executeQuery ( ) . nullifyLink ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isNull ( long columnIndex ) { 
 + return executeQuery ( ) . isNull ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public void setNull ( long columnIndex ) { 
 + executeQuery ( ) . setNull ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isAttached ( ) { 
 + return executeQuery ( ) . isAttached ( ) ; 
 + } 
 + 
 + @ Override 
 + public boolean hasColumn ( String fieldName ) { 
 + return executeQuery ( ) . hasColumn ( fieldName ) ; 
 + } 
 + 
 + private void clearPendingCollection ( ) { 
 + pendingCollection . removeListener ( listener ) ; 
 + pendingCollection = null ; 
 + listener = null ; 
 + } 
 + 
 + private Row executeQuery ( ) { 
 + if ( pendingCollection = = null ) { 
 + throw new IllegalStateException ( QUERY _ EXECUTED _ MESSAGE ) ; 
 + } 
 + if ( frontEnd = = null ) { 
 + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 + } 
 + Row row = pendingCollection . getUncheckedRow ( 0 ) ; 
 + if ( row = = null ) { 
 + throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; 
 + } 
 + if ( frontEnd . get ( ) ! = null ) { 
 + frontEnd . get ( ) . onQueryFinished ( pendingCollection . firstUncheckedRow ( ) , false ) ; 
 + } 
 + clearPendingCollection ( ) ; 
 + return row ; 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java 
 index 7802428 . . 5b5b441 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java 
 @ @ - 89 , 8 + 89 , 10 @ @ public class UncheckedRow implements NativeObject , Row { 
 
 / / FIXME : Testing code 
 public static UncheckedRow getByRowPointer ( Table table , long nativeRowPointer ) { 
 - UncheckedRow row = new UncheckedRow ( table . context , table , nativeRowPointer ) ; 
 - return row ; 
 + if ( nativeRowPointer ! = 0 ) { 
 + return new UncheckedRow ( table . context , table , nativeRowPointer ) ; 
 + } 
 + return null ; 
 } 
 
 / * *
