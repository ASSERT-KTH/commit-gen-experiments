BLEU SCORE: 0.017177441586169604

TEST MSG: WiP - start using Object Store ' s Results class
GENERATED MSG: Optimizing Realm . allObjectSorted ( ) and refactoring for code reuse .

TEST DIFF (one line): diff - - git a / realm / realm - library / src / main / cpp / CMakeLists . txt b / realm / realm - library / src / main / cpp / CMakeLists . txt <nl> index 3d156b0 . . 187ae3e 100644 <nl> - - - a / realm / realm - library / src / main / cpp / CMakeLists . txt <nl> + + + b / realm / realm - library / src / main / cpp / CMakeLists . txt <nl> @ @ - 157 , 6 + 157 , 7 @ @ file ( GLOB objectstore _ SRC <nl> " object - store / src / schema . cpp " <nl> " object - store / src / index _ set . cpp " <nl> " object - store / src / shared _ realm . cpp " <nl> + " object - store / src / results . cpp " <nl> " object - store / src / impl / realm _ coordinator . cpp " <nl> " object - store / src / impl / collection _ notifier . cpp " <nl> " object - store / src / impl / collection _ change _ builder . cpp " <nl> diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ RealmResults . cpp b / realm / realm - library / src / main / cpp / io _ realm _ RealmResults . cpp <nl> new file mode 100644 <nl> index 0000000 . . 9da609e <nl> - - - / dev / null <nl> + + + b / realm / realm - library / src / main / cpp / io _ realm _ RealmResults . cpp <nl> @ @ - 0 , 0 + 1 , 164 @ @ <nl> + / * <nl> + * Copyright 2016 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + # include < jni . h > <nl> + # include " io _ realm _ RealmResults . h " <nl> + <nl> + # include < vector > <nl> + <nl> + # include < object - store / src / shared _ realm . hpp > <nl> + # include < object - store / src / results . hpp > <nl> + <nl> + # include " util . hpp " <nl> + <nl> + using namespace realm ; <nl> + <nl> + JNIEXPORT jlong JNICALL <nl> + Java _ io _ realm _ RealmResults _ nativeCreateResults ( JNIEnv * env , jclass , jlong shared _ realm _ ptr , jlong query _ ptr , jlongArray colunm _ indices , jbooleanArray jsort _ orders ) { <nl> + TR _ ENTER ( ) <nl> + try { <nl> + auto shared _ realm = * ( reinterpret _ cast < SharedRealm * > ( shared _ realm _ ptr ) ) ; <nl> + auto query = reinterpret _ cast < Query * > ( query _ ptr ) ; <nl> + <nl> + JniBooleanArray order ( env , jsort _ orders ) ; <nl> + JniLongArray indices ( env , colunm _ indices ) ; <nl> + <nl> + std : : vector < bool > sort _ order ; <nl> + std : : vector < std : : vector < size _ t > > sort _ indices ; <nl> + for ( jsize i = 0 ; i < order . len ( ) ; + + i ) { <nl> + sort _ order . push _ back ( to _ bool ( order [ i ] ) ) ; <nl> + sort _ indices . push _ back ( std : : vector < size _ t > { S ( indices [ i ] ) } ) ; <nl> + } <nl> + <nl> + SortDescriptor sort _ descriptor ( * ( query - > get _ table ( ) . get ( ) ) , sort _ indices , sort _ order ) ; <nl> + Results results ( shared _ realm , * query , sort _ descriptor ) ; <nl> + return reinterpret _ cast < jlong > ( new Results ( std : : move ( results ) ) ) ; <nl> + } CATCH _ STD ( ) <nl> + return reinterpret _ cast < jlong > ( nullptr ) ; <nl> + } <nl> + <nl> + JNIEXPORT jlong JNICALL <nl> + Java _ io _ realm _ RealmResults _ nativeCreateSnapshort ( JNIEnv * env , jclass , jlong native _ ptr ) { <nl> + TR _ ENTER _ PTR ( native _ ptr ) <nl> + try { <nl> + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; <nl> + auto snapshot = results - > snapshot ( ) ; <nl> + return reinterpret _ cast < jlong > ( new Results ( snapshot ) ) ; <nl> + } CATCH _ STD ( ) <nl> + return reinterpret _ cast < jlong > ( nullptr ) ; <nl> + } <nl> + <nl> + / / FIXME : we don ' t use it at the moment <nl> + JNIEXPORT jlong JNICALL <nl> + Java _ io _ realm _ RealmResults _ nativeGetRow ( JNIEnv * env , jclass , jlong native _ ptr , jint index ) { <nl> + TR _ ENTER _ PTR ( native _ ptr ) <nl> + try { <nl> + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; <nl> + auto row = results - > get ( static _ cast < size _ t > ( index ) ) ; <nl> + return reinterpret _ cast < jlong > ( new Row ( std : : move ( row ) ) ) ; <nl> + } CATCH _ STD ( ) <nl> + return reinterpret _ cast < jlong > ( nullptr ) ; <nl> + } <nl> + <nl> + JNIEXPORT void JNICALL <nl> + Java _ io _ realm _ RealmResults _ nativeClear ( JNIEnv * env , jclass , jlong native _ ptr ) { <nl> + TR _ ENTER _ PTR ( native _ ptr ) <nl> + try { <nl> + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; <nl> + results - > clear ( ) ; <nl> + } CATCH _ STD ( ) <nl> + } <nl> + <nl> + JNIEXPORT jlong JNICALL <nl> + Java _ io _ realm _ RealmResults _ nativeSize ( JNIEnv * env , jclass , jlong native _ ptr ) { <nl> + TR _ ENTER _ PTR ( native _ ptr ) <nl> + try { <nl> + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; <nl> + return static _ cast < jlong > ( results - > size ( ) ) ; <nl> + } CATCH _ STD ( ) <nl> + return 0 ; <nl> + } <nl> + <nl> + JNIEXPORT jobject JNICALL <nl> + Java _ io _ realm _ RealmResults _ nativeAggregate ( JNIEnv * env , jclass , jlong native _ ptr , jlong column _ index , jbyte agg _ func ) { <nl> + TR _ ENTER _ PTR ( native _ ptr ) <nl> + try { <nl> + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; <nl> + <nl> + size _ t index = S ( column _ index ) ; <nl> + Optional < Mixed > value ; <nl> + switch ( agg _ func ) { <nl> + case io _ realm _ RealmResults _ AGGREGATE _ FUNCTION _ MINIMUM : <nl> + value = results - > min ( index ) ; <nl> + break ; <nl> + case io _ realm _ RealmResults _ AGGREGATE _ FUNCTION _ MAXIMUM : <nl> + value = results - > max ( index ) ; <nl> + break ; <nl> + case io _ realm _ RealmResults _ AGGREGATE _ FUNCTION _ AVERAGE : <nl> + value = results - > average ( index ) ; <nl> + break ; <nl> + case io _ realm _ RealmResults _ AGGREGATE _ FUNCTION _ SUM : <nl> + value = results - > sum ( index ) ; <nl> + break ; <nl> + } <nl> + <nl> + if ( ! value ) { <nl> + return static _ cast < jobject > ( nullptr ) ; <nl> + } <nl> + <nl> + Mixed m = * value ; <nl> + switch ( m . get _ type ( ) ) { <nl> + case type _ Int : <nl> + return NewLong ( env , m . get _ int ( ) ) ; <nl> + case type _ Float : <nl> + return NewFloat ( env , m . get _ float ( ) ) ; <nl> + case type _ Double : <nl> + return NewDouble ( env , m . get _ double ( ) ) ; <nl> + case type _ Timestamp : <nl> + return NewDate ( env , m . get _ timestamp ( ) ) ; <nl> + default : <nl> + throw std : : invalid _ argument ( " Excepted numeric type " ) ; <nl> + } <nl> + } CATCH _ STD ( ) <nl> + return static _ cast < jobject > ( nullptr ) ; <nl> + } <nl> + <nl> + JNIEXPORT jlong JNICALL <nl> + Java _ io _ realm _ RealmResults _ nativeSort ( JNIEnv * env , jclass , jlong native _ ptr , jlongArray colunm _ indices , jbooleanArray jsort _ orders ) { <nl> + TR _ ENTER _ PTR ( native _ ptr ) <nl> + try { <nl> + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; <nl> + <nl> + JniBooleanArray order ( env , jsort _ orders ) ; <nl> + JniLongArray indices ( env , colunm _ indices ) ; <nl> + <nl> + if ( order . len ( ) ! = indices . len ( ) ) { <nl> + throw std : : invalid _ argument ( " Number of columns and sorting orders do not match . " ) ; <nl> + } <nl> + <nl> + std : : vector < bool > sort _ orders ; <nl> + std : : vector < std : : vector < size _ t > > sort _ indices ; <nl> + for ( jsize i = 0 ; i < order . len ( ) ; + + i ) { <nl> + sort _ orders . push _ back ( to _ bool ( order [ i ] ) ) ; <nl> + sort _ indices . push _ back ( std : : vector < size _ t > { S ( indices [ i ] ) } ) ; <nl> + } <nl> + <nl> + SortDescriptor sort _ descriptor ( * ( results - > get _ query ( ) . get _ table ( ) . get ( ) ) , sort _ indices , sort _ orders ) ; <nl> + auto sorted _ result = results - > sort ( std : : move ( sort _ descriptor ) ) ; <nl> + return reinterpret _ cast < jlong > ( new Results ( std : : move ( sorted _ result ) ) ) ; <nl> + } CATCH _ STD ( ) <nl> + return reinterpret _ cast < jlong > ( nullptr ) ; <nl> + } <nl> diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ SharedRealm . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ SharedRealm . cpp <nl> index 6d200de . . 1a84771 100644 <nl> - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ SharedRealm . cpp <nl> + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ SharedRealm . cpp <nl> @ @ - 1 , 4 + 1 , 20 @ @ <nl> - # include < object - store / src / sync _ manager . hpp > <nl> + / * <nl> + * Copyright 2016 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + # include < object - store / src / sync / sync _ manager . hpp > <nl> # include " io _ realm _ internal _ SharedRealm . h " <nl> <nl> # include " object _ store . hpp " <nl> diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Util . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Util . cpp <nl> index 241ce22 . . d796eaa 100644 <nl> - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Util . cpp <nl> + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Util . cpp <nl> @ @ - 47 , 6 + 47 , 8 @ @ JNIEXPORT jint JNICALL JNI _ OnLoad ( JavaVM * vm , void * ) <nl> java _ lang _ float _ init = env - > GetMethodID ( java _ lang _ float , " < init > " , " ( F ) V " ) ; <nl> java _ lang _ double = GetClass ( env , " java / lang / Double " ) ; <nl> java _ lang _ double _ init = env - > GetMethodID ( java _ lang _ double , " < init > " , " ( D ) V " ) ; <nl> + java _ util _ date = GetClass ( env , " java / util / Date " ) ; <nl> + java _ util _ date _ init = env - > GetMethodID ( java _ util _ date , " < init > " , " ( J ) V " ) ; <nl> } <nl> <nl> return JNI _ VERSION _ 1 _ 6 ; <nl> @ @ - 62 , 6 + 64 , 7 @ @ JNIEXPORT void JNI _ OnUnload ( JavaVM * vm , void * ) <nl> env - > DeleteGlobalRef ( java _ lang _ long ) ; <nl> env - > DeleteGlobalRef ( java _ lang _ float ) ; <nl> env - > DeleteGlobalRef ( java _ lang _ double ) ; <nl> + env - > DeleteGlobalRef ( java _ util _ date ) ; <nl> } <nl> } <nl> <nl> diff - - git a / realm / realm - library / src / main / cpp / util . cpp b / realm / realm - library / src / main / cpp / util . cpp <nl> index 1ba8e3e . . b309893 100644 <nl> - - - a / realm / realm - library / src / main / cpp / util . cpp <nl> + + + b / realm / realm - library / src / main / cpp / util . cpp <nl> @ @ - 39 , 6 + 39 , 8 @ @ jclass java _ lang _ float ; <nl> jmethodID java _ lang _ float _ init ; <nl> jclass java _ lang _ double ; <nl> jmethodID java _ lang _ double _ init ; <nl> + jclass java _ util _ date ; <nl> + jmethodID java _ util _ date _ init ; <nl> jclass session _ class _ ref ; <nl> jmethodID session _ error _ handler ; <nl> <nl> diff - - git a / realm / realm - library / src / main / cpp / util . hpp b / realm / realm - library / src / main / cpp / util . hpp <nl> index 68b9a89 . . a214e9f 100644 <nl> - - - a / realm / realm - library / src / main / cpp / util . hpp <nl> + + + b / realm / realm - library / src / main / cpp / util . hpp <nl> @ @ - 666 , 6 + 666 , 8 @ @ extern jclass java _ lang _ float ; <nl> extern jmethodID java _ lang _ float _ init ; <nl> extern jclass java _ lang _ double ; <nl> extern jmethodID java _ lang _ double _ init ; <nl> + extern jclass java _ util _ date ; <nl> + extern jmethodID java _ util _ date _ init ; <nl> <nl> / / FIXME Move to own library <nl> extern jclass session _ class _ ref ; <nl> @ @ - 704 , 6 + 706 , 10 @ @ inline realm : : Timestamp from _ milliseconds ( jlong milliseconds ) <nl> return realm : : Timestamp ( seconds , nanoseconds ) ; <nl> } <nl> <nl> + inline jobject NewDate ( JNIEnv * env , const realm : : Timestamp & ts ) { <nl> + return env - > NewObject ( java _ util _ date , java _ util _ date _ init , to _ milliseconds ( ts ) ) ; <nl> + } <nl> + <nl> extern const std : : string TABLE _ PREFIX ; <nl> <nl> static inline bool to _ bool ( jboolean b ) { <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> index 29121bf . . 5a2aa84 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> @ @ - 91 , 6 + 91 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> <nl> private final long nativePtr ; <nl> <nl> + / / Public for static checking in JNI <nl> + public static final byte AGGREGATE _ FUNCTION _ MINIMUM = 1 ; <nl> + public static final byte AGGREGATE _ FUNCTION _ MAXIMUM = 2 ; <nl> + public static final byte AGGREGATE _ FUNCTION _ AVERAGE = 3 ; <nl> + public static final byte AGGREGATE _ FUNCTION _ SUM = 4 ; <nl> + <nl> static < E extends RealmModel > RealmResults < E > createFromQuery ( BaseRealm realm , TableQuery query , Class < E > clazz , <nl> String fieldNames [ ] , Sort [ ] sortOrder ) { <nl> return new RealmResults < E > ( realm , query , clazz , fieldNames , sortOrder ) ; <nl> @ @ - 126 , 10 + 132 , 13 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> } <nl> <nl> boolean [ ] order = new boolean [ sortOrder . length ] ; <nl> + long [ ] indices = new long [ sortOrder . length ] ; <nl> for ( int i = 0 ; i < sortOrder . length ; i + + ) { <nl> order [ i ] = sortOrder [ i ] = = Sort . ASCENDING ; <nl> + indices [ i ] = getColumnIndexForSort ( fieldNames [ i ] ) ; <nl> } <nl> - this . nativePtr = nativeCreateResults ( realm . sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , order ) ; <nl> + <nl> + this . nativePtr = nativeCreateResults ( realm . sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , indices , order ) ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz ) { <nl> @ @ - 172 , 6 + 181 , 13 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> this . currentTableViewVersion = table . syncIfNeeded ( ) ; <nl> } <nl> <nl> + private RealmResults ( BaseRealm realm , String className , long nativePtr ) { <nl> + this . realm = realm ; <nl> + this . className = className ; <nl> + this . nativePtr = nativePtr ; <nl> + this . query = null ; <nl> + } <nl> + <nl> TableOrView getTableOrView ( ) { <nl> if ( table = = null ) { <nl> return realm . schema . getTable ( classSpec ) ; <nl> @ @ - 404 , 7 + 420 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Override <nl> public RealmResults < E > sort ( String fieldName ) { <nl> - return this . sort ( fieldName , Sort . ASCENDING ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + return this . sort ( fieldName , Sort . ASCENDING ) ; <nl> + } else { <nl> + long ptr = nativeSort ( nativePtr , new long [ ] { getColumnIndexForSort ( fieldName ) } , new boolean [ ] { Sort . ASCENDING . getValue ( ) } ) ; <nl> + return new RealmResults < E > ( realm , className , ptr ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> @ @ - 412 , 7 + 433 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Override <nl> public RealmResults < E > sort ( String fieldName , Sort sortOrder ) { <nl> - return where ( ) . findAllSorted ( fieldName , sortOrder ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + return where ( ) . findAllSorted ( fieldName , sortOrder ) ; <nl> + } else { <nl> + long ptr = nativeSort ( nativePtr , new long [ ] { getColumnIndexForSort ( fieldName ) } , new boolean [ ] { sortOrder = = Sort . ASCENDING } ) ; <nl> + return new RealmResults < E > ( realm , className , ptr ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> @ @ - 420 , 7 + 446 , 22 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Override <nl> public RealmResults < E > sort ( String fieldNames [ ] , Sort sortOrders [ ] ) { <nl> - return where ( ) . findAllSorted ( fieldNames , sortOrders ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + return where ( ) . findAllSorted ( fieldNames , sortOrders ) ; <nl> + } else { <nl> + long columnIndices [ ] = new long [ fieldNames . length ] ; <nl> + for ( int i = 0 ; i < fieldNames . length ; i + + ) { <nl> + columnIndices [ i ] = getColumnIndexForSort ( fieldNames [ i ] ) ; <nl> + } <nl> + <nl> + boolean orders [ ] = new boolean [ sortOrders . length ] ; <nl> + for ( int i = 0 ; i < sortOrders . length ; i + + ) { <nl> + orders [ i ] = sortOrders [ i ] . getValue ( ) <nl> + } <nl> + <nl> + long ptr = nativeSort ( nativePtr , columnIndices , orders ) ; <nl> + return new RealmResults < E > ( realm , className , ptr ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> @ @ - 471 , 7 + 512 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> } <nl> } else { <nl> - return nativeAggregate ( nativePtr , columnIndex , 1 ) ; <nl> + return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MINIMUM ) ; <nl> } <nl> } <nl> <nl> @ @ - 481 , 11 + 522 , 14 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public Date minDate ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { <nl> - return table . minimumDate ( columnIndex ) ; <nl> - } <nl> - else { <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { <nl> + return table . minimumDate ( columnIndex ) ; <nl> + } else { <nl> + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; <nl> + } <nl> + } else { <nl> + return ( Date ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MINIMUM ) ; <nl> } <nl> } <nl> <nl> @ @ - 495 , 15 + 539 , 19 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public Number max ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - switch ( table . getColumnType ( columnIndex ) ) { <nl> - case INTEGER : <nl> - return table . maximumLong ( columnIndex ) ; <nl> - case FLOAT : <nl> - return table . maximumFloat ( columnIndex ) ; <nl> - case DOUBLE : <nl> - return table . maximumDouble ( columnIndex ) ; <nl> - default : <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + switch ( table . getColumnType ( columnIndex ) ) { <nl> + case INTEGER : <nl> + return table . maximumLong ( columnIndex ) ; <nl> + case FLOAT : <nl> + return table . maximumFloat ( columnIndex ) ; <nl> + case DOUBLE : <nl> + return table . maximumDouble ( columnIndex ) ; <nl> + default : <nl> + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> + } <nl> + } else { <nl> + return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MAXIMUM ) ; <nl> } <nl> } <nl> <nl> @ @ - 520 , 11 + 568 , 14 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public Date maxDate ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { <nl> - return table . maximumDate ( columnIndex ) ; <nl> - } <nl> - else { <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { <nl> + return table . maximumDate ( columnIndex ) ; <nl> + } else { <nl> + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; <nl> + } <nl> + } else { <nl> + return ( Date ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MAXIMUM ) ; <nl> } <nl> } <nl> <nl> @ @ - 535 , 15 + 586 , 19 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public Number sum ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - switch ( table . getColumnType ( columnIndex ) ) { <nl> - case INTEGER : <nl> - return table . sumLong ( columnIndex ) ; <nl> - case FLOAT : <nl> - return table . sumFloat ( columnIndex ) ; <nl> - case DOUBLE : <nl> - return table . sumDouble ( columnIndex ) ; <nl> - default : <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + switch ( table . getColumnType ( columnIndex ) ) { <nl> + case INTEGER : <nl> + return table . sumLong ( columnIndex ) ; <nl> + case FLOAT : <nl> + return table . sumFloat ( columnIndex ) ; <nl> + case DOUBLE : <nl> + return table . sumDouble ( columnIndex ) ; <nl> + default : <nl> + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> + } <nl> + } else { <nl> + return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ SUM ) ; <nl> } <nl> } <nl> <nl> @ @ - 553 , 15 + 608 , 21 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public double average ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - switch ( table . getColumnType ( columnIndex ) ) { <nl> - case INTEGER : <nl> - return table . averageLong ( columnIndex ) ; <nl> - case DOUBLE : <nl> - return table . averageDouble ( columnIndex ) ; <nl> - case FLOAT : <nl> - return table . averageFloat ( columnIndex ) ; <nl> - default : <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> + if ( nativePtr = = 0 ) { <nl> + switch ( table . getColumnType ( columnIndex ) ) { <nl> + case INTEGER : <nl> + return table . averageLong ( columnIndex ) ; <nl> + case DOUBLE : <nl> + return table . averageDouble ( columnIndex ) ; <nl> + case FLOAT : <nl> + return table . averageFloat ( columnIndex ) ; <nl> + default : <nl> + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> + } <nl> + } else { <nl> + / / FIXME : Should we change return type to Double ? <nl> + Number sum = ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ AVERAGE ) ; <nl> + return sum . doubleValue ( ) ; <nl> } <nl> } <nl> <nl> @ @ - 1096 , 9 + 1157 , 11 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> } <nl> } <nl> <nl> - native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , boolean [ ] order ) ; <nl> - native long nativeGetRow ( long nativePtr , int index ) ; <nl> - native void nativeClear ( long nativePtr ) ; <nl> - native long nativeSize ( long nativePtr ) ; <nl> - native Object nativeAggregate ( long nativePtr , long columnIndex , byte aggregateFunc ) ; <nl> + private static native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , long [ ] columnIndices , boolean [ ] orders ) ; <nl> + private static native long nativeCreateSnapshot ( long nativePtr ) ; <nl> + private static native long nativeGetRow ( long nativePtr , int index ) ; <nl> + private static native void nativeClear ( long nativePtr ) ; <nl> + private static native long nativeSize ( long nativePtr ) ; <nl> + private static native Object nativeAggregate ( long nativePtr , long columnIndex , byte aggregateFunc ) ; <nl> + private static native long nativeSort ( long nativePtr , long [ ] columnIndices , boolean [ ] orders ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index dec8e69 . . 7e6dad8 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 1 , 3 + 1 , 7 @ @ <nl> + 0 . 78 <nl> + * Optimizing Realm . allObjectSorted ( ) . <nl> + <nl> + <nl> 0 . 77 <nl> * Adding Realm . allObjectsSorted ( ) and RealmQuery . findAllSorted ( ) and exteding RealmResults . sort ( ) for multi - field sorting . <nl> * RealmResults . sort ( ) now has better error reporting . <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ Table . h b / realm - jni / src / io _ realm _ internal _ Table . h <nl> index 23a706e . . ed35d0e 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ Table . h <nl> + + + b / realm - jni / src / io _ realm _ internal _ Table . h <nl> @ @ - 195 , 6 + 195 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeGetSortedView <nl> <nl> / * <nl> * Class : io _ realm _ internal _ Table <nl> + * Method : nativeGetSortedViewMulti <nl> + * Signature : ( J [ J [ Z ) J <nl> + * / <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeGetSortedViewMulti <nl> + ( JNIEnv * , jobject , jlong , jlongArray , jbooleanArray ) ; <nl> + <nl> + / * <nl> + * Class : io _ realm _ internal _ Table <nl> * Method : nativeInsertFloat <nl> * Signature : ( JJJF ) V <nl> * / <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ table . cpp b / realm - jni / src / io _ realm _ internal _ table . cpp <nl> index 161d820 . . 414edad 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ table . cpp <nl> + + + b / realm - jni / src / io _ realm _ internal _ table . cpp <nl> @ @ - 1219 , 12 + 1219 , 59 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeGetSortedView ( <nl> return reinterpret _ cast < jlong > ( pTableView ) ; <nl> } CATCH _ STD ( ) <nl> default : <nl> - ThrowException ( env , IllegalArgument , " Sort is currently only supported on Integer , Boolean and Date columns . " ) ; <nl> + ThrowException ( env , IllegalArgument , " Sort is currently only supported on integer , boolean , double , float , String , and Date columns . " ) ; <nl> return 0 ; <nl> } <nl> return 0 ; <nl> } <nl> <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeGetSortedViewMulti ( <nl> + JNIEnv * env , jobject , jlong nativeTablePtr , jlongArray columnIndices , jbooleanArray ascending ) <nl> + { <nl> + Table * pTable = TBL ( nativeTablePtr ) ; <nl> + <nl> + jsize arr _ len = env - > GetArrayLength ( columnIndices ) ; <nl> + if ( arr _ len ! = env - > GetArrayLength ( ascending ) ) { <nl> + ThrowException ( env , IllegalArgument , " Number of column indices and sort orders do not match . " ) ; <nl> + return 0 ; <nl> + } <nl> + <nl> + jlong * long _ arr = env - > GetLongArrayElements ( columnIndices , NULL ) ; <nl> + jboolean * bool _ arr = env - > GetBooleanArrayElements ( ascending , NULL ) ; <nl> + <nl> + std : : vector < size _ t > indices ; <nl> + std : : vector < bool > ascendings ; <nl> + <nl> + for ( int i = 0 ; i < arr _ len ; + + i ) { <nl> + if ( ! TBL _ AND _ COL _ INDEX _ VALID ( env , pTable , S ( long _ arr [ i ] ) ) ) <nl> + return 0 ; <nl> + int colType = pTable - > get _ column _ type ( S ( long _ arr [ i ] ) ) ; <nl> + switch ( colType ) { <nl> + case type _ Int : <nl> + case type _ Bool : <nl> + case type _ DateTime : <nl> + case type _ String : <nl> + case type _ Double : <nl> + case type _ Float : <nl> + indices . push _ back ( S ( long _ arr [ i ] ) ) ; <nl> + ascendings . push _ back ( bool _ arr [ i ] ! = 0 ? true : false ) ; <nl> + break ; <nl> + default : <nl> + ThrowException ( env , IllegalArgument , " Sort is currently only supported on integer , boolean , double , float , String , and Date columns . " ) ; <nl> + return 0 ; <nl> + } <nl> + } <nl> + <nl> + env - > ReleaseLongArrayElements ( columnIndices , long _ arr , 0 ) ; <nl> + env - > ReleaseBooleanArrayElements ( ascending , bool _ arr , 0 ) ; <nl> + <nl> + try { <nl> + TableView * pTableView = new TableView ( pTable - > get _ sorted _ view ( indices , ascendings ) ) ; <nl> + return reinterpret _ cast < jlong > ( pTableView ) ; <nl> + } CATCH _ STD ( ) <nl> + return 0 ; <nl> + } <nl> + <nl> JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeOptimize ( <nl> JNIEnv * env , jobject , jlong nativeTablePtr ) <nl> { <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index 92d4bf2 . . 7470777 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 16 , 8 + 16 , 8 @ @ <nl> <nl> package io . realm ; <nl> <nl> - import android . annotation . TargetApi ; <nl> import android . annotation . SuppressLint ; <nl> + import android . annotation . TargetApi ; <nl> import android . content . Context ; <nl> import android . os . Build ; <nl> import android . os . Handler ; <nl> @ @ - 39 , 7 + 39 , 6 @ @ import java . lang . reflect . InvocationTargetException ; <nl> import java . lang . reflect . Method ; <nl> import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> - import java . util . Collection ; <nl> import java . util . HashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> @ @ - 1096 , 11 + 1095 , 7 @ @ public final class Realm implements Closeable { <nl> * / <nl> @ Deprecated <nl> public < E extends RealmObject > RealmResults < E > allObjects ( Class < E > clazz , String fieldNames [ ] , boolean sortAscending [ ] ) { <nl> - / / FIXME : This is not an optimal implementation . When core ' s Table : : get _ sorted _ view ( ) supports <nl> - / / FIXME : multi - column sorting , we can rewrite this method to a far better implementation . <nl> - RealmResults < E > results = this . allObjects ( clazz ) ; <nl> - results . sort ( fieldNames , sortAscending ) ; <nl> - return results ; <nl> + return allObjectsSorted ( clazz , fieldNames , sortAscending ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 1115 , 11 + 1110 , 22 @ @ public final class Realm implements Closeable { <nl> * / <nl> public < E extends RealmObject > RealmResults < E > allObjectsSorted ( Class < E > clazz , String fieldNames [ ] , <nl> boolean sortAscending [ ] ) { <nl> - / / FIXME : This is not an optimal implementation . When core ' s Table : : get _ sorted _ view ( ) supports <nl> - / / FIXME : multi - column sorting , we can rewrite this method to a far better implementation . <nl> - RealmResults < E > results = this . allObjects ( clazz ) ; <nl> - results . sort ( fieldNames , sortAscending ) ; <nl> - return results ; <nl> + io . realm . internal . android . Util . validateMultiSortParameters ( fieldNames , sortAscending ) ; <nl> + <nl> + Table table = this . getTable ( clazz ) ; <nl> + List < TableView . Order > TVOrder = new ArrayList < TableView . Order > ( ) ; <nl> + List < Long > columnIndices = new ArrayList < Long > ( ) ; <nl> + for ( int i = 0 ; i < fieldNames . length ; i + + ) { <nl> + String fieldName = fieldNames [ i ] ; <nl> + long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> + if ( columnIndex = = - 1 ) { <nl> + throw new IllegalArgumentException ( String . format ( " Field name ' % s ' does not exist . " , fieldName ) ) ; <nl> + } <nl> + columnIndices . add ( columnIndex ) ; <nl> + TVOrder . add ( sortAscending [ i ] ? TableView . Order . ascending : TableView . Order . descending ) ; <nl> + } <nl> + TableView tableView = table . getSortedView ( columnIndices , TVOrder ) ; <nl> + return new RealmResults ( this , tableView , clazz ) ; <nl> } <nl> <nl> / / Notifications <nl> diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java <nl> index 8865f38 . . cc0fef2 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / src / main / java / io / realm / RealmResults . java <nl> @ @ - 230 , 17 + 230 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if a field name does not exist . <nl> * / <nl> public void sort ( String fieldNames [ ] , boolean sortAscending [ ] ) { <nl> - if ( fieldNames = = null ) { <nl> - throw new IllegalArgumentException ( " fieldNames must be provided . " ) ; <nl> - } else if ( sortAscending = = null ) { <nl> - throw new IllegalArgumentException ( " sortAscending must be provided . " ) ; <nl> - } else if ( fieldNames . length = = 0 ) { <nl> - throw new IllegalArgumentException ( " You must provide at least one field name . " ) ; <nl> - } else if ( sortAscending . length = = 0 ) { <nl> - throw new IllegalArgumentException ( " You must provide at least one sort order . " ) ; <nl> - } else if ( fieldNames . length ! = sortAscending . length ) { <nl> - throw new IllegalArgumentException ( String . format ( " Number of field names ( % d ) and sort orders ( % d ) do not match . " , fieldNames . length , sortAscending . length ) ) ; <nl> - } <nl> + io . realm . internal . android . Util . validateMultiSortParameters ( fieldNames , sortAscending ) ; <nl> <nl> if ( fieldNames . length = = 1 ) { <nl> sort ( fieldNames [ 0 ] , sortAscending [ 0 ] ) ; <nl> @ @ - 261 , 6 + 251 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> } <nl> } <nl> <nl> + <nl> / * * <nl> * Sort existing { link io . realm . RealmResults } using two fields . <nl> * <nl> diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java <nl> index 3b78199 . . f823a4e 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / Table . java <nl> + + + b / realm / src / main / java / io / realm / internal / Table . java <nl> @ @ - 18 , 6 + 18 , 7 @ @ package io . realm . internal ; <nl> <nl> import java . io . Closeable ; <nl> import java . util . Date ; <nl> + import java . util . List ; <nl> <nl> <nl> / * * <nl> @ @ - 546 , 6 + 547 , 24 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> protected native long nativeGetSortedView ( long nativeTableViewPtr , long columnIndex , boolean ascending ) ; <nl> <nl> <nl> + public TableView getSortedView ( List < Long > columnIndices , List < TableView . Order > orders ) { <nl> + context . executeDelayedDisposal ( ) ; <nl> + long indices [ ] = new long [ columnIndices . size ( ) ] ; <nl> + boolean sortOrders [ ] = new boolean [ orders . size ( ) ] ; <nl> + for ( int i = 0 ; i < columnIndices . size ( ) ; i + + ) { <nl> + indices [ i ] = columnIndices . get ( i ) ; <nl> + sortOrders [ i ] = orders . get ( i ) = = TableView . Order . ascending ; <nl> + } <nl> + long nativeViewPtr = nativeGetSortedViewMulti ( nativePtr , indices , sortOrders ) ; <nl> + try { <nl> + return new TableView ( this . context , this , nativeViewPtr ) ; <nl> + } catch ( RuntimeException e ) { <nl> + TableView . nativeClose ( nativeViewPtr ) ; <nl> + throw e ; <nl> + } <nl> + } <nl> + <nl> + protected native long nativeGetSortedViewMulti ( long nativeTableViewPtr , long [ ] columnIndices , boolean [ ] ascending ) ; <nl> <nl> / * * <nl> * Replaces the row at the specified position with the specified row . <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / Util . java b / realm / src / main / java / io / realm / internal / android / Util . java <nl> new file mode 100644 <nl> index 0000000 . . 1bc68c3 <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / internal / android / Util . java <nl> @ @ - 0 , 0 + 1 , 40 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . android ; <nl> + <nl> + public class Util { <nl> + / * * <nl> + * Basic validation the parameters used by multi - column sorting methods . It will throw an <nl> + * exception in case of an error . <nl> + * <nl> + * @ param fieldNames list of field names <nl> + * @ param sortAscending list of sorting orders <nl> + * / <nl> + public static void validateMultiSortParameters ( String [ ] fieldNames , boolean [ ] sortAscending ) { <nl> + if ( fieldNames = = null ) { <nl> + throw new IllegalArgumentException ( " fieldNames must be provided . " ) ; <nl> + } else if ( sortAscending = = null ) { <nl> + throw new IllegalArgumentException ( " sortAscending must be provided . " ) ; <nl> + } else if ( fieldNames . length = = 0 ) { <nl> + throw new IllegalArgumentException ( " You must provide at least one field name . " ) ; <nl> + } else if ( sortAscending . length = = 0 ) { <nl> + throw new IllegalArgumentException ( " You must provide at least one sort order . " ) ; <nl> + } else if ( fieldNames . length ! = sortAscending . length ) { <nl> + throw new IllegalArgumentException ( String . format ( " Number of field names ( % d ) and sort orders ( % d ) do not match . " , fieldNames . length , sortAscending . length ) ) ; <nl> + } <nl> + } <nl> + }

TEST DIFF:
diff - - git a / realm / realm - library / src / main / cpp / CMakeLists . txt b / realm / realm - library / src / main / cpp / CMakeLists . txt 
 index 3d156b0 . . 187ae3e 100644 
 - - - a / realm / realm - library / src / main / cpp / CMakeLists . txt 
 + + + b / realm / realm - library / src / main / cpp / CMakeLists . txt 
 @ @ - 157 , 6 + 157 , 7 @ @ file ( GLOB objectstore _ SRC 
 " object - store / src / schema . cpp " 
 " object - store / src / index _ set . cpp " 
 " object - store / src / shared _ realm . cpp " 
 + " object - store / src / results . cpp " 
 " object - store / src / impl / realm _ coordinator . cpp " 
 " object - store / src / impl / collection _ notifier . cpp " 
 " object - store / src / impl / collection _ change _ builder . cpp " 
 diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ RealmResults . cpp b / realm / realm - library / src / main / cpp / io _ realm _ RealmResults . cpp 
 new file mode 100644 
 index 0000000 . . 9da609e 
 - - - / dev / null 
 + + + b / realm / realm - library / src / main / cpp / io _ realm _ RealmResults . cpp 
 @ @ - 0 , 0 + 1 , 164 @ @ 
 + / * 
 + * Copyright 2016 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + # include < jni . h > 
 + # include " io _ realm _ RealmResults . h " 
 + 
 + # include < vector > 
 + 
 + # include < object - store / src / shared _ realm . hpp > 
 + # include < object - store / src / results . hpp > 
 + 
 + # include " util . hpp " 
 + 
 + using namespace realm ; 
 + 
 + JNIEXPORT jlong JNICALL 
 + Java _ io _ realm _ RealmResults _ nativeCreateResults ( JNIEnv * env , jclass , jlong shared _ realm _ ptr , jlong query _ ptr , jlongArray colunm _ indices , jbooleanArray jsort _ orders ) { 
 + TR _ ENTER ( ) 
 + try { 
 + auto shared _ realm = * ( reinterpret _ cast < SharedRealm * > ( shared _ realm _ ptr ) ) ; 
 + auto query = reinterpret _ cast < Query * > ( query _ ptr ) ; 
 + 
 + JniBooleanArray order ( env , jsort _ orders ) ; 
 + JniLongArray indices ( env , colunm _ indices ) ; 
 + 
 + std : : vector < bool > sort _ order ; 
 + std : : vector < std : : vector < size _ t > > sort _ indices ; 
 + for ( jsize i = 0 ; i < order . len ( ) ; + + i ) { 
 + sort _ order . push _ back ( to _ bool ( order [ i ] ) ) ; 
 + sort _ indices . push _ back ( std : : vector < size _ t > { S ( indices [ i ] ) } ) ; 
 + } 
 + 
 + SortDescriptor sort _ descriptor ( * ( query - > get _ table ( ) . get ( ) ) , sort _ indices , sort _ order ) ; 
 + Results results ( shared _ realm , * query , sort _ descriptor ) ; 
 + return reinterpret _ cast < jlong > ( new Results ( std : : move ( results ) ) ) ; 
 + } CATCH _ STD ( ) 
 + return reinterpret _ cast < jlong > ( nullptr ) ; 
 + } 
 + 
 + JNIEXPORT jlong JNICALL 
 + Java _ io _ realm _ RealmResults _ nativeCreateSnapshort ( JNIEnv * env , jclass , jlong native _ ptr ) { 
 + TR _ ENTER _ PTR ( native _ ptr ) 
 + try { 
 + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; 
 + auto snapshot = results - > snapshot ( ) ; 
 + return reinterpret _ cast < jlong > ( new Results ( snapshot ) ) ; 
 + } CATCH _ STD ( ) 
 + return reinterpret _ cast < jlong > ( nullptr ) ; 
 + } 
 + 
 + / / FIXME : we don ' t use it at the moment 
 + JNIEXPORT jlong JNICALL 
 + Java _ io _ realm _ RealmResults _ nativeGetRow ( JNIEnv * env , jclass , jlong native _ ptr , jint index ) { 
 + TR _ ENTER _ PTR ( native _ ptr ) 
 + try { 
 + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; 
 + auto row = results - > get ( static _ cast < size _ t > ( index ) ) ; 
 + return reinterpret _ cast < jlong > ( new Row ( std : : move ( row ) ) ) ; 
 + } CATCH _ STD ( ) 
 + return reinterpret _ cast < jlong > ( nullptr ) ; 
 + } 
 + 
 + JNIEXPORT void JNICALL 
 + Java _ io _ realm _ RealmResults _ nativeClear ( JNIEnv * env , jclass , jlong native _ ptr ) { 
 + TR _ ENTER _ PTR ( native _ ptr ) 
 + try { 
 + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; 
 + results - > clear ( ) ; 
 + } CATCH _ STD ( ) 
 + } 
 + 
 + JNIEXPORT jlong JNICALL 
 + Java _ io _ realm _ RealmResults _ nativeSize ( JNIEnv * env , jclass , jlong native _ ptr ) { 
 + TR _ ENTER _ PTR ( native _ ptr ) 
 + try { 
 + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; 
 + return static _ cast < jlong > ( results - > size ( ) ) ; 
 + } CATCH _ STD ( ) 
 + return 0 ; 
 + } 
 + 
 + JNIEXPORT jobject JNICALL 
 + Java _ io _ realm _ RealmResults _ nativeAggregate ( JNIEnv * env , jclass , jlong native _ ptr , jlong column _ index , jbyte agg _ func ) { 
 + TR _ ENTER _ PTR ( native _ ptr ) 
 + try { 
 + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; 
 + 
 + size _ t index = S ( column _ index ) ; 
 + Optional < Mixed > value ; 
 + switch ( agg _ func ) { 
 + case io _ realm _ RealmResults _ AGGREGATE _ FUNCTION _ MINIMUM : 
 + value = results - > min ( index ) ; 
 + break ; 
 + case io _ realm _ RealmResults _ AGGREGATE _ FUNCTION _ MAXIMUM : 
 + value = results - > max ( index ) ; 
 + break ; 
 + case io _ realm _ RealmResults _ AGGREGATE _ FUNCTION _ AVERAGE : 
 + value = results - > average ( index ) ; 
 + break ; 
 + case io _ realm _ RealmResults _ AGGREGATE _ FUNCTION _ SUM : 
 + value = results - > sum ( index ) ; 
 + break ; 
 + } 
 + 
 + if ( ! value ) { 
 + return static _ cast < jobject > ( nullptr ) ; 
 + } 
 + 
 + Mixed m = * value ; 
 + switch ( m . get _ type ( ) ) { 
 + case type _ Int : 
 + return NewLong ( env , m . get _ int ( ) ) ; 
 + case type _ Float : 
 + return NewFloat ( env , m . get _ float ( ) ) ; 
 + case type _ Double : 
 + return NewDouble ( env , m . get _ double ( ) ) ; 
 + case type _ Timestamp : 
 + return NewDate ( env , m . get _ timestamp ( ) ) ; 
 + default : 
 + throw std : : invalid _ argument ( " Excepted numeric type " ) ; 
 + } 
 + } CATCH _ STD ( ) 
 + return static _ cast < jobject > ( nullptr ) ; 
 + } 
 + 
 + JNIEXPORT jlong JNICALL 
 + Java _ io _ realm _ RealmResults _ nativeSort ( JNIEnv * env , jclass , jlong native _ ptr , jlongArray colunm _ indices , jbooleanArray jsort _ orders ) { 
 + TR _ ENTER _ PTR ( native _ ptr ) 
 + try { 
 + auto results = reinterpret _ cast < Results * > ( native _ ptr ) ; 
 + 
 + JniBooleanArray order ( env , jsort _ orders ) ; 
 + JniLongArray indices ( env , colunm _ indices ) ; 
 + 
 + if ( order . len ( ) ! = indices . len ( ) ) { 
 + throw std : : invalid _ argument ( " Number of columns and sorting orders do not match . " ) ; 
 + } 
 + 
 + std : : vector < bool > sort _ orders ; 
 + std : : vector < std : : vector < size _ t > > sort _ indices ; 
 + for ( jsize i = 0 ; i < order . len ( ) ; + + i ) { 
 + sort _ orders . push _ back ( to _ bool ( order [ i ] ) ) ; 
 + sort _ indices . push _ back ( std : : vector < size _ t > { S ( indices [ i ] ) } ) ; 
 + } 
 + 
 + SortDescriptor sort _ descriptor ( * ( results - > get _ query ( ) . get _ table ( ) . get ( ) ) , sort _ indices , sort _ orders ) ; 
 + auto sorted _ result = results - > sort ( std : : move ( sort _ descriptor ) ) ; 
 + return reinterpret _ cast < jlong > ( new Results ( std : : move ( sorted _ result ) ) ) ; 
 + } CATCH _ STD ( ) 
 + return reinterpret _ cast < jlong > ( nullptr ) ; 
 + } 
 diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ SharedRealm . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ SharedRealm . cpp 
 index 6d200de . . 1a84771 100644 
 - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ SharedRealm . cpp 
 + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ SharedRealm . cpp 
 @ @ - 1 , 4 + 1 , 20 @ @ 
 - # include < object - store / src / sync _ manager . hpp > 
 + / * 
 + * Copyright 2016 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + # include < object - store / src / sync / sync _ manager . hpp > 
 # include " io _ realm _ internal _ SharedRealm . h " 
 
 # include " object _ store . hpp " 
 diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Util . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Util . cpp 
 index 241ce22 . . d796eaa 100644 
 - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Util . cpp 
 + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Util . cpp 
 @ @ - 47 , 6 + 47 , 8 @ @ JNIEXPORT jint JNICALL JNI _ OnLoad ( JavaVM * vm , void * ) 
 java _ lang _ float _ init = env - > GetMethodID ( java _ lang _ float , " < init > " , " ( F ) V " ) ; 
 java _ lang _ double = GetClass ( env , " java / lang / Double " ) ; 
 java _ lang _ double _ init = env - > GetMethodID ( java _ lang _ double , " < init > " , " ( D ) V " ) ; 
 + java _ util _ date = GetClass ( env , " java / util / Date " ) ; 
 + java _ util _ date _ init = env - > GetMethodID ( java _ util _ date , " < init > " , " ( J ) V " ) ; 
 } 
 
 return JNI _ VERSION _ 1 _ 6 ; 
 @ @ - 62 , 6 + 64 , 7 @ @ JNIEXPORT void JNI _ OnUnload ( JavaVM * vm , void * ) 
 env - > DeleteGlobalRef ( java _ lang _ long ) ; 
 env - > DeleteGlobalRef ( java _ lang _ float ) ; 
 env - > DeleteGlobalRef ( java _ lang _ double ) ; 
 + env - > DeleteGlobalRef ( java _ util _ date ) ; 
 } 
 } 
 
 diff - - git a / realm / realm - library / src / main / cpp / util . cpp b / realm / realm - library / src / main / cpp / util . cpp 
 index 1ba8e3e . . b309893 100644 
 - - - a / realm / realm - library / src / main / cpp / util . cpp 
 + + + b / realm / realm - library / src / main / cpp / util . cpp 
 @ @ - 39 , 6 + 39 , 8 @ @ jclass java _ lang _ float ; 
 jmethodID java _ lang _ float _ init ; 
 jclass java _ lang _ double ; 
 jmethodID java _ lang _ double _ init ; 
 + jclass java _ util _ date ; 
 + jmethodID java _ util _ date _ init ; 
 jclass session _ class _ ref ; 
 jmethodID session _ error _ handler ; 
 
 diff - - git a / realm / realm - library / src / main / cpp / util . hpp b / realm / realm - library / src / main / cpp / util . hpp 
 index 68b9a89 . . a214e9f 100644 
 - - - a / realm / realm - library / src / main / cpp / util . hpp 
 + + + b / realm / realm - library / src / main / cpp / util . hpp 
 @ @ - 666 , 6 + 666 , 8 @ @ extern jclass java _ lang _ float ; 
 extern jmethodID java _ lang _ float _ init ; 
 extern jclass java _ lang _ double ; 
 extern jmethodID java _ lang _ double _ init ; 
 + extern jclass java _ util _ date ; 
 + extern jmethodID java _ util _ date _ init ; 
 
 / / FIXME Move to own library 
 extern jclass session _ class _ ref ; 
 @ @ - 704 , 6 + 706 , 10 @ @ inline realm : : Timestamp from _ milliseconds ( jlong milliseconds ) 
 return realm : : Timestamp ( seconds , nanoseconds ) ; 
 } 
 
 + inline jobject NewDate ( JNIEnv * env , const realm : : Timestamp & ts ) { 
 + return env - > NewObject ( java _ util _ date , java _ util _ date _ init , to _ milliseconds ( ts ) ) ; 
 + } 
 + 
 extern const std : : string TABLE _ PREFIX ; 
 
 static inline bool to _ bool ( jboolean b ) { 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 index 29121bf . . 5a2aa84 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 @ @ - 91 , 6 + 91 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 
 private final long nativePtr ; 
 
 + / / Public for static checking in JNI 
 + public static final byte AGGREGATE _ FUNCTION _ MINIMUM = 1 ; 
 + public static final byte AGGREGATE _ FUNCTION _ MAXIMUM = 2 ; 
 + public static final byte AGGREGATE _ FUNCTION _ AVERAGE = 3 ; 
 + public static final byte AGGREGATE _ FUNCTION _ SUM = 4 ; 
 + 
 static < E extends RealmModel > RealmResults < E > createFromQuery ( BaseRealm realm , TableQuery query , Class < E > clazz , 
 String fieldNames [ ] , Sort [ ] sortOrder ) { 
 return new RealmResults < E > ( realm , query , clazz , fieldNames , sortOrder ) ; 
 @ @ - 126 , 10 + 132 , 13 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 } 
 
 boolean [ ] order = new boolean [ sortOrder . length ] ; 
 + long [ ] indices = new long [ sortOrder . length ] ; 
 for ( int i = 0 ; i < sortOrder . length ; i + + ) { 
 order [ i ] = sortOrder [ i ] = = Sort . ASCENDING ; 
 + indices [ i ] = getColumnIndexForSort ( fieldNames [ i ] ) ; 
 } 
 - this . nativePtr = nativeCreateResults ( realm . sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , order ) ; 
 + 
 + this . nativePtr = nativeCreateResults ( realm . sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , indices , order ) ; 
 } 
 
 private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz ) { 
 @ @ - 172 , 6 + 181 , 13 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 this . currentTableViewVersion = table . syncIfNeeded ( ) ; 
 } 
 
 + private RealmResults ( BaseRealm realm , String className , long nativePtr ) { 
 + this . realm = realm ; 
 + this . className = className ; 
 + this . nativePtr = nativePtr ; 
 + this . query = null ; 
 + } 
 + 
 TableOrView getTableOrView ( ) { 
 if ( table = = null ) { 
 return realm . schema . getTable ( classSpec ) ; 
 @ @ - 404 , 7 + 420 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Override 
 public RealmResults < E > sort ( String fieldName ) { 
 - return this . sort ( fieldName , Sort . ASCENDING ) ; 
 + if ( nativePtr = = 0 ) { 
 + return this . sort ( fieldName , Sort . ASCENDING ) ; 
 + } else { 
 + long ptr = nativeSort ( nativePtr , new long [ ] { getColumnIndexForSort ( fieldName ) } , new boolean [ ] { Sort . ASCENDING . getValue ( ) } ) ; 
 + return new RealmResults < E > ( realm , className , ptr ) ; 
 + } 
 } 
 
 / * * 
 @ @ - 412 , 7 + 433 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Override 
 public RealmResults < E > sort ( String fieldName , Sort sortOrder ) { 
 - return where ( ) . findAllSorted ( fieldName , sortOrder ) ; 
 + if ( nativePtr = = 0 ) { 
 + return where ( ) . findAllSorted ( fieldName , sortOrder ) ; 
 + } else { 
 + long ptr = nativeSort ( nativePtr , new long [ ] { getColumnIndexForSort ( fieldName ) } , new boolean [ ] { sortOrder = = Sort . ASCENDING } ) ; 
 + return new RealmResults < E > ( realm , className , ptr ) ; 
 + } 
 } 
 
 / * * 
 @ @ - 420 , 7 + 446 , 22 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Override 
 public RealmResults < E > sort ( String fieldNames [ ] , Sort sortOrders [ ] ) { 
 - return where ( ) . findAllSorted ( fieldNames , sortOrders ) ; 
 + if ( nativePtr = = 0 ) { 
 + return where ( ) . findAllSorted ( fieldNames , sortOrders ) ; 
 + } else { 
 + long columnIndices [ ] = new long [ fieldNames . length ] ; 
 + for ( int i = 0 ; i < fieldNames . length ; i + + ) { 
 + columnIndices [ i ] = getColumnIndexForSort ( fieldNames [ i ] ) ; 
 + } 
 + 
 + boolean orders [ ] = new boolean [ sortOrders . length ] ; 
 + for ( int i = 0 ; i < sortOrders . length ; i + + ) { 
 + orders [ i ] = sortOrders [ i ] . getValue ( ) 
 + } 
 + 
 + long ptr = nativeSort ( nativePtr , columnIndices , orders ) ; 
 + return new RealmResults < E > ( realm , className , ptr ) ; 
 + } 
 } 
 
 / * * 
 @ @ - 471 , 7 + 512 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 } 
 } else { 
 - return nativeAggregate ( nativePtr , columnIndex , 1 ) ; 
 + return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MINIMUM ) ; 
 } 
 } 
 
 @ @ - 481 , 11 + 522 , 14 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public Date minDate ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { 
 - return table . minimumDate ( columnIndex ) ; 
 - } 
 - else { 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; 
 + if ( nativePtr = = 0 ) { 
 + if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { 
 + return table . minimumDate ( columnIndex ) ; 
 + } else { 
 + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; 
 + } 
 + } else { 
 + return ( Date ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MINIMUM ) ; 
 } 
 } 
 
 @ @ - 495 , 15 + 539 , 19 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public Number max ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - switch ( table . getColumnType ( columnIndex ) ) { 
 - case INTEGER : 
 - return table . maximumLong ( columnIndex ) ; 
 - case FLOAT : 
 - return table . maximumFloat ( columnIndex ) ; 
 - case DOUBLE : 
 - return table . maximumDouble ( columnIndex ) ; 
 - default : 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 + if ( nativePtr = = 0 ) { 
 + switch ( table . getColumnType ( columnIndex ) ) { 
 + case INTEGER : 
 + return table . maximumLong ( columnIndex ) ; 
 + case FLOAT : 
 + return table . maximumFloat ( columnIndex ) ; 
 + case DOUBLE : 
 + return table . maximumDouble ( columnIndex ) ; 
 + default : 
 + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 + } 
 + } else { 
 + return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MAXIMUM ) ; 
 } 
 } 
 
 @ @ - 520 , 11 + 568 , 14 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public Date maxDate ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { 
 - return table . maximumDate ( columnIndex ) ; 
 - } 
 - else { 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; 
 + if ( nativePtr = = 0 ) { 
 + if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { 
 + return table . maximumDate ( columnIndex ) ; 
 + } else { 
 + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; 
 + } 
 + } else { 
 + return ( Date ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MAXIMUM ) ; 
 } 
 } 
 
 @ @ - 535 , 15 + 586 , 19 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public Number sum ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - switch ( table . getColumnType ( columnIndex ) ) { 
 - case INTEGER : 
 - return table . sumLong ( columnIndex ) ; 
 - case FLOAT : 
 - return table . sumFloat ( columnIndex ) ; 
 - case DOUBLE : 
 - return table . sumDouble ( columnIndex ) ; 
 - default : 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 + if ( nativePtr = = 0 ) { 
 + switch ( table . getColumnType ( columnIndex ) ) { 
 + case INTEGER : 
 + return table . sumLong ( columnIndex ) ; 
 + case FLOAT : 
 + return table . sumFloat ( columnIndex ) ; 
 + case DOUBLE : 
 + return table . sumDouble ( columnIndex ) ; 
 + default : 
 + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 + } 
 + } else { 
 + return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ SUM ) ; 
 } 
 } 
 
 @ @ - 553 , 15 + 608 , 21 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public double average ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - switch ( table . getColumnType ( columnIndex ) ) { 
 - case INTEGER : 
 - return table . averageLong ( columnIndex ) ; 
 - case DOUBLE : 
 - return table . averageDouble ( columnIndex ) ; 
 - case FLOAT : 
 - return table . averageFloat ( columnIndex ) ; 
 - default : 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 + if ( nativePtr = = 0 ) { 
 + switch ( table . getColumnType ( columnIndex ) ) { 
 + case INTEGER : 
 + return table . averageLong ( columnIndex ) ; 
 + case DOUBLE : 
 + return table . averageDouble ( columnIndex ) ; 
 + case FLOAT : 
 + return table . averageFloat ( columnIndex ) ; 
 + default : 
 + throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 + } 
 + } else { 
 + / / FIXME : Should we change return type to Double ? 
 + Number sum = ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ AVERAGE ) ; 
 + return sum . doubleValue ( ) ; 
 } 
 } 
 
 @ @ - 1096 , 9 + 1157 , 11 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 } 
 } 
 
 - native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , boolean [ ] order ) ; 
 - native long nativeGetRow ( long nativePtr , int index ) ; 
 - native void nativeClear ( long nativePtr ) ; 
 - native long nativeSize ( long nativePtr ) ; 
 - native Object nativeAggregate ( long nativePtr , long columnIndex , byte aggregateFunc ) ; 
 + private static native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , long [ ] columnIndices , boolean [ ] orders ) ; 
 + private static native long nativeCreateSnapshot ( long nativePtr ) ; 
 + private static native long nativeGetRow ( long nativePtr , int index ) ; 
 + private static native void nativeClear ( long nativePtr ) ; 
 + private static native long nativeSize ( long nativePtr ) ; 
 + private static native Object nativeAggregate ( long nativePtr , long columnIndex , byte aggregateFunc ) ; 
 + private static native long nativeSort ( long nativePtr , long [ ] columnIndices , boolean [ ] orders ) ; 
 }

NEAREST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index dec8e69 . . 7e6dad8 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 1 , 3 + 1 , 7 @ @ 
 + 0 . 78 
 + * Optimizing Realm . allObjectSorted ( ) . 
 + 
 + 
 0 . 77 
 * Adding Realm . allObjectsSorted ( ) and RealmQuery . findAllSorted ( ) and exteding RealmResults . sort ( ) for multi - field sorting . 
 * RealmResults . sort ( ) now has better error reporting . 
 diff - - git a / realm - jni / src / io _ realm _ internal _ Table . h b / realm - jni / src / io _ realm _ internal _ Table . h 
 index 23a706e . . ed35d0e 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ Table . h 
 + + + b / realm - jni / src / io _ realm _ internal _ Table . h 
 @ @ - 195 , 6 + 195 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeGetSortedView 
 
 / * 
 * Class : io _ realm _ internal _ Table 
 + * Method : nativeGetSortedViewMulti 
 + * Signature : ( J [ J [ Z ) J 
 + * / 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeGetSortedViewMulti 
 + ( JNIEnv * , jobject , jlong , jlongArray , jbooleanArray ) ; 
 + 
 + / * 
 + * Class : io _ realm _ internal _ Table 
 * Method : nativeInsertFloat 
 * Signature : ( JJJF ) V 
 * / 
 diff - - git a / realm - jni / src / io _ realm _ internal _ table . cpp b / realm - jni / src / io _ realm _ internal _ table . cpp 
 index 161d820 . . 414edad 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ table . cpp 
 + + + b / realm - jni / src / io _ realm _ internal _ table . cpp 
 @ @ - 1219 , 12 + 1219 , 59 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeGetSortedView ( 
 return reinterpret _ cast < jlong > ( pTableView ) ; 
 } CATCH _ STD ( ) 
 default : 
 - ThrowException ( env , IllegalArgument , " Sort is currently only supported on Integer , Boolean and Date columns . " ) ; 
 + ThrowException ( env , IllegalArgument , " Sort is currently only supported on integer , boolean , double , float , String , and Date columns . " ) ; 
 return 0 ; 
 } 
 return 0 ; 
 } 
 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ Table _ nativeGetSortedViewMulti ( 
 + JNIEnv * env , jobject , jlong nativeTablePtr , jlongArray columnIndices , jbooleanArray ascending ) 
 + { 
 + Table * pTable = TBL ( nativeTablePtr ) ; 
 + 
 + jsize arr _ len = env - > GetArrayLength ( columnIndices ) ; 
 + if ( arr _ len ! = env - > GetArrayLength ( ascending ) ) { 
 + ThrowException ( env , IllegalArgument , " Number of column indices and sort orders do not match . " ) ; 
 + return 0 ; 
 + } 
 + 
 + jlong * long _ arr = env - > GetLongArrayElements ( columnIndices , NULL ) ; 
 + jboolean * bool _ arr = env - > GetBooleanArrayElements ( ascending , NULL ) ; 
 + 
 + std : : vector < size _ t > indices ; 
 + std : : vector < bool > ascendings ; 
 + 
 + for ( int i = 0 ; i < arr _ len ; + + i ) { 
 + if ( ! TBL _ AND _ COL _ INDEX _ VALID ( env , pTable , S ( long _ arr [ i ] ) ) ) 
 + return 0 ; 
 + int colType = pTable - > get _ column _ type ( S ( long _ arr [ i ] ) ) ; 
 + switch ( colType ) { 
 + case type _ Int : 
 + case type _ Bool : 
 + case type _ DateTime : 
 + case type _ String : 
 + case type _ Double : 
 + case type _ Float : 
 + indices . push _ back ( S ( long _ arr [ i ] ) ) ; 
 + ascendings . push _ back ( bool _ arr [ i ] ! = 0 ? true : false ) ; 
 + break ; 
 + default : 
 + ThrowException ( env , IllegalArgument , " Sort is currently only supported on integer , boolean , double , float , String , and Date columns . " ) ; 
 + return 0 ; 
 + } 
 + } 
 + 
 + env - > ReleaseLongArrayElements ( columnIndices , long _ arr , 0 ) ; 
 + env - > ReleaseBooleanArrayElements ( ascending , bool _ arr , 0 ) ; 
 + 
 + try { 
 + TableView * pTableView = new TableView ( pTable - > get _ sorted _ view ( indices , ascendings ) ) ; 
 + return reinterpret _ cast < jlong > ( pTableView ) ; 
 + } CATCH _ STD ( ) 
 + return 0 ; 
 + } 
 + 
 JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeOptimize ( 
 JNIEnv * env , jobject , jlong nativeTablePtr ) 
 { 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index 92d4bf2 . . 7470777 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 16 , 8 + 16 , 8 @ @ 
 
 package io . realm ; 
 
 - import android . annotation . TargetApi ; 
 import android . annotation . SuppressLint ; 
 + import android . annotation . TargetApi ; 
 import android . content . Context ; 
 import android . os . Build ; 
 import android . os . Handler ; 
 @ @ - 39 , 7 + 39 , 6 @ @ import java . lang . reflect . InvocationTargetException ; 
 import java . lang . reflect . Method ; 
 import java . util . ArrayList ; 
 import java . util . Arrays ; 
 - import java . util . Collection ; 
 import java . util . HashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 @ @ - 1096 , 11 + 1095 , 7 @ @ public final class Realm implements Closeable { 
 * / 
 @ Deprecated 
 public < E extends RealmObject > RealmResults < E > allObjects ( Class < E > clazz , String fieldNames [ ] , boolean sortAscending [ ] ) { 
 - / / FIXME : This is not an optimal implementation . When core ' s Table : : get _ sorted _ view ( ) supports 
 - / / FIXME : multi - column sorting , we can rewrite this method to a far better implementation . 
 - RealmResults < E > results = this . allObjects ( clazz ) ; 
 - results . sort ( fieldNames , sortAscending ) ; 
 - return results ; 
 + return allObjectsSorted ( clazz , fieldNames , sortAscending ) ; 
 } 
 
 / * * 
 @ @ - 1115 , 11 + 1110 , 22 @ @ public final class Realm implements Closeable { 
 * / 
 public < E extends RealmObject > RealmResults < E > allObjectsSorted ( Class < E > clazz , String fieldNames [ ] , 
 boolean sortAscending [ ] ) { 
 - / / FIXME : This is not an optimal implementation . When core ' s Table : : get _ sorted _ view ( ) supports 
 - / / FIXME : multi - column sorting , we can rewrite this method to a far better implementation . 
 - RealmResults < E > results = this . allObjects ( clazz ) ; 
 - results . sort ( fieldNames , sortAscending ) ; 
 - return results ; 
 + io . realm . internal . android . Util . validateMultiSortParameters ( fieldNames , sortAscending ) ; 
 + 
 + Table table = this . getTable ( clazz ) ; 
 + List < TableView . Order > TVOrder = new ArrayList < TableView . Order > ( ) ; 
 + List < Long > columnIndices = new ArrayList < Long > ( ) ; 
 + for ( int i = 0 ; i < fieldNames . length ; i + + ) { 
 + String fieldName = fieldNames [ i ] ; 
 + long columnIndex = table . getColumnIndex ( fieldName ) ; 
 + if ( columnIndex = = - 1 ) { 
 + throw new IllegalArgumentException ( String . format ( " Field name ' % s ' does not exist . " , fieldName ) ) ; 
 + } 
 + columnIndices . add ( columnIndex ) ; 
 + TVOrder . add ( sortAscending [ i ] ? TableView . Order . ascending : TableView . Order . descending ) ; 
 + } 
 + TableView tableView = table . getSortedView ( columnIndices , TVOrder ) ; 
 + return new RealmResults ( this , tableView , clazz ) ; 
 } 
 
 / / Notifications 
 diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java 
 index 8865f38 . . cc0fef2 100644 
 - - - a / realm / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / src / main / java / io / realm / RealmResults . java 
 @ @ - 230 , 17 + 230 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if a field name does not exist . 
 * / 
 public void sort ( String fieldNames [ ] , boolean sortAscending [ ] ) { 
 - if ( fieldNames = = null ) { 
 - throw new IllegalArgumentException ( " fieldNames must be provided . " ) ; 
 - } else if ( sortAscending = = null ) { 
 - throw new IllegalArgumentException ( " sortAscending must be provided . " ) ; 
 - } else if ( fieldNames . length = = 0 ) { 
 - throw new IllegalArgumentException ( " You must provide at least one field name . " ) ; 
 - } else if ( sortAscending . length = = 0 ) { 
 - throw new IllegalArgumentException ( " You must provide at least one sort order . " ) ; 
 - } else if ( fieldNames . length ! = sortAscending . length ) { 
 - throw new IllegalArgumentException ( String . format ( " Number of field names ( % d ) and sort orders ( % d ) do not match . " , fieldNames . length , sortAscending . length ) ) ; 
 - } 
 + io . realm . internal . android . Util . validateMultiSortParameters ( fieldNames , sortAscending ) ; 
 
 if ( fieldNames . length = = 1 ) { 
 sort ( fieldNames [ 0 ] , sortAscending [ 0 ] ) ; 
 @ @ - 261 , 6 + 251 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 } 
 } 
 
 + 
 / * * 
 * Sort existing { link io . realm . RealmResults } using two fields . 
 * 
 diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java 
 index 3b78199 . . f823a4e 100644 
 - - - a / realm / src / main / java / io / realm / internal / Table . java 
 + + + b / realm / src / main / java / io / realm / internal / Table . java 
 @ @ - 18 , 6 + 18 , 7 @ @ package io . realm . internal ; 
 
 import java . io . Closeable ; 
 import java . util . Date ; 
 + import java . util . List ; 
 
 
 / * * 
 @ @ - 546 , 6 + 547 , 24 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 protected native long nativeGetSortedView ( long nativeTableViewPtr , long columnIndex , boolean ascending ) ; 
 
 
 + public TableView getSortedView ( List < Long > columnIndices , List < TableView . Order > orders ) { 
 + context . executeDelayedDisposal ( ) ; 
 + long indices [ ] = new long [ columnIndices . size ( ) ] ; 
 + boolean sortOrders [ ] = new boolean [ orders . size ( ) ] ; 
 + for ( int i = 0 ; i < columnIndices . size ( ) ; i + + ) { 
 + indices [ i ] = columnIndices . get ( i ) ; 
 + sortOrders [ i ] = orders . get ( i ) = = TableView . Order . ascending ; 
 + } 
 + long nativeViewPtr = nativeGetSortedViewMulti ( nativePtr , indices , sortOrders ) ; 
 + try { 
 + return new TableView ( this . context , this , nativeViewPtr ) ; 
 + } catch ( RuntimeException e ) { 
 + TableView . nativeClose ( nativeViewPtr ) ; 
 + throw e ; 
 + } 
 + } 
 + 
 + protected native long nativeGetSortedViewMulti ( long nativeTableViewPtr , long [ ] columnIndices , boolean [ ] ascending ) ; 
 
 / * * 
 * Replaces the row at the specified position with the specified row . 
 diff - - git a / realm / src / main / java / io / realm / internal / android / Util . java b / realm / src / main / java / io / realm / internal / android / Util . java 
 new file mode 100644 
 index 0000000 . . 1bc68c3 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / internal / android / Util . java 
 @ @ - 0 , 0 + 1 , 40 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . android ; 
 + 
 + public class Util { 
 + / * * 
 + * Basic validation the parameters used by multi - column sorting methods . It will throw an 
 + * exception in case of an error . 
 + * 
 + * @ param fieldNames list of field names 
 + * @ param sortAscending list of sorting orders 
 + * / 
 + public static void validateMultiSortParameters ( String [ ] fieldNames , boolean [ ] sortAscending ) { 
 + if ( fieldNames = = null ) { 
 + throw new IllegalArgumentException ( " fieldNames must be provided . " ) ; 
 + } else if ( sortAscending = = null ) { 
 + throw new IllegalArgumentException ( " sortAscending must be provided . " ) ; 
 + } else if ( fieldNames . length = = 0 ) { 
 + throw new IllegalArgumentException ( " You must provide at least one field name . " ) ; 
 + } else if ( sortAscending . length = = 0 ) { 
 + throw new IllegalArgumentException ( " You must provide at least one sort order . " ) ; 
 + } else if ( fieldNames . length ! = sortAscending . length ) { 
 + throw new IllegalArgumentException ( String . format ( " Number of field names ( % d ) and sort orders ( % d ) do not match . " , fieldNames . length , sortAscending . length ) ) ; 
 + } 
 + } 
 + }
