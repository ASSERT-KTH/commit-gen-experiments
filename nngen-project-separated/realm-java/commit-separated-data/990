BLEU SCORE: 0.08392229812593097

TEST MSG: write transaction - > transaction to avoid confusing users .
GENERATED MSG: add async write transaction

TEST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index 0d6ec4d . . eb7e58c 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 5 , 7 + 5 , 7 @ @ <nl> * Added Realm . isClosed ( ) method . <nl> * Added Realm . distinct ( ) method . <nl> * Added RealmQuery . isValid ( ) , RealmResults . isValid ( ) and RealmList . isValid ( ) . Each method checks whether the instance is still valid to use or not ( for example , the Realm has been closed or any parent object has been removed ) . <nl> - * Added Realm . isInWriteTransaction ( ) method . <nl> + * Added Realm . isInTransaction ( ) method . <nl> * Following methods in managed RealmList now throw IllegalStateException instead of native crash when RealmList . isValid ( ) returns false : add ( int , RealmObject ) , add ( RealmObject ) <nl> * Following methods in managed RealmList now throw IllegalStateException instead of ArrayIndexOutOfBoundsException when RealmList . isValid ( ) returns false : set ( int , RealmObject ) , move ( int , int ) , remove ( int ) , get ( int ) <nl> * Following methods in managed RealmList now throw IllegalStateException instead of returning 0 / null when RealmList . isValid ( ) returns false : clear ( ) , removeAll ( Collection ) , remove ( RealmObject ) , first ( ) , last ( ) , size ( ) , where ( ) <nl> @ @ - 28 , 7 + 28 , 7 @ @ <nl> * Deprecated methods : RealmQuery . minimum { Int , Float , Double } , RealmQuery . maximum { Int , Float , Double } . Use RealmQuery . min ( ) and RealmQuery . max ( ) instead . <nl> * Added support for x86 _ 64 . <nl> * Fixed an issue where opening the same Realm file on two Looper threads could potentially lead to an IllegalStateException being thrown . <nl> - * Opening a Realm file from one thread will no longer be blocked by a write transaction from another thread . <nl> + * Opening a Realm file from one thread will no longer be blocked by a transaction from another thread . <nl> * Fixed an issue preventing the call of listeners on refresh ( ) . <nl> * Range restrictions of Date fields have been removed . Date fields now accepts any value . Milliseconds are still removed . <nl> <nl> @ @ - 230 , 7 + 230 , 7 @ @ <nl> * Better support for Java 7 and 8 in the annotations processor <nl> * Better support for the Eclipse annotations processor <nl> * Added Eclipse support to the distribution folder <nl> - * Added Realm . cancelTransaction ( ) to cancel / abort / rollback a write transaction <nl> + * Added Realm . cancelTransaction ( ) to cancel / abort / rollback a transaction <nl> * Faster implementation of RealmQuery . findFirst ( ) <nl> * Upgraded core to 0 . 85 . 1 ( deep copying of strings in queries ; preparation for link queries ) <nl> * Added support for link queries in the form realm . where ( Owner . class ) . equalTo ( " cat . age " , 12 ) . findAll ( ) <nl> @ @ - 239 , 7 + 239 , 7 @ @ <nl> * Simplified the release artifact to a single Jar file <nl> * Added support for Eclipse <nl> * Added support for deploying to Maven <nl> - * Throw exception if nested write transactions are used ( it ' s not allowed ) <nl> + * Throw exception if nested transactions are used ( it ' s not allowed ) <nl> * Javadoc updated <nl> * Fixed bug in RealmResults : https : / / github . com / realm / realm - java / issues / 453 <nl> * New annotation @ Index to add search index to a field ( currently only supporting String fields ) <nl> diff - - git a / examples / introExample / src / main / java / io / realm / examples / intro / IntroExampleActivity . java b / examples / introExample / src / main / java / io / realm / examples / intro / IntroExampleActivity . java <nl> index 3fa8476 . . 7382897 100644 <nl> - - - a / examples / introExample / src / main / java / io / realm / examples / intro / IntroExampleActivity . java <nl> + + + b / examples / introExample / src / main / java / io / realm / examples / intro / IntroExampleActivity . java <nl> @ @ - 96 , 14 + 96 , 14 @ @ public class IntroExampleActivity extends Activity { <nl> person . setName ( " Young Person " ) ; <nl> person . setAge ( 14 ) ; <nl> <nl> - / / When the write transaction is committed , all changes a synced to disk . <nl> + / / When the transaction is committed , all changes a synced to disk . <nl> realm . commitTransaction ( ) ; <nl> <nl> / / Find the first person ( no query conditions ) and read a field <nl> person = realm . where ( Person . class ) . findFirst ( ) ; <nl> showStatus ( person . getName ( ) + " : " + person . getAge ( ) ) ; <nl> <nl> - / / Update person in a write transaction <nl> + / / Update person in a transaction <nl> realm . beginTransaction ( ) ; <nl> person . setName ( " Senior Person " ) ; <nl> person . setAge ( 99 ) ; <nl> @ @ - 141 , 7 + 141 , 7 @ @ public class IntroExampleActivity extends Activity { <nl> / / Those can not be transferred across threads . <nl> Realm realm = Realm . getInstance ( this ) ; <nl> <nl> - / / Add ten persons in one write transaction <nl> + / / Add ten persons in one transaction <nl> realm . beginTransaction ( ) ; <nl> Dog fido = realm . createObject ( Dog . class ) ; <nl> fido . setName ( " fido " ) ; <nl> diff - - git a / examples / kotlinExample / src / main / java / io / realm / examples / kotlin / KotlinExampleActivity . kt b / examples / kotlinExample / src / main / java / io / realm / examples / kotlin / KotlinExampleActivity . kt <nl> index bbc7121 . . e170ed6 100644 <nl> - - - a / examples / kotlinExample / src / main / java / io / realm / examples / kotlin / KotlinExampleActivity . kt <nl> + + + b / examples / kotlinExample / src / main / java / io / realm / examples / kotlin / KotlinExampleActivity . kt <nl> @ @ - 93 , 14 + 93 , 14 @ @ public class KotlinExampleActivity : Activity ( ) { <nl> person . name = " Young Person " <nl> person . age = 14 <nl> <nl> - / / When the write transaction is committed , all changes a synced to disk . <nl> + / / When the transaction is committed , all changes a synced to disk . <nl> realm . commitTransaction ( ) <nl> <nl> / / Find the first person ( no query conditions ) and read a field <nl> person = realm . where ( javaClass < Person > ( ) ) . findFirst ( ) <nl> showStatus ( person . name + " : " + person . age ) <nl> <nl> - / / Update person in a write transaction <nl> + / / Update person in a transaction <nl> realm . beginTransaction ( ) <nl> person . name = " Senior Person " <nl> person . age = 99 <nl> @ @ - 140 , 7 + 140 , 7 @ @ public class KotlinExampleActivity : Activity ( ) { <nl> / / Those can not be transferred across threads . <nl> val realm = Realm . getInstance ( this ) <nl> <nl> - / / Add ten persons in one write transaction <nl> + / / Add ten persons in one transaction <nl> realm . beginTransaction ( ) <nl> val fido = realm . createObject ( javaClass < Dog > ( ) ) <nl> fido . name = " fido " <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index 0aec5bb . . 7114cf0 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 42 , 12 + 42 , 12 @ @ import io . realm . instrumentation . MockActivityManager ; <nl> import io . realm . proxy . HandlerProxy ; <nl> <nl> public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> - / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> - / / * * * * Async write transaction * * * <nl> - / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> + / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> + / / * * * * Async transaction * * * <nl> + / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> <nl> - / / start asynchronously a write transaction to insert one element <nl> - public void testAsyncWriteTransaction ( ) throws Throwable { <nl> + / / start asynchronously a transaction to insert one element <nl> + public void testAsyncTransaction ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final Realm [ ] realm = new Realm [ 1 ] ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; / / to catch both Exception & AssertionError <nl> @ @ - 60 , 7 + 60 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> backgroundLooper [ 0 ] = Looper . myLooper ( ) ; <nl> <nl> try { <nl> - realm [ 0 ] = openRealmInstance ( " testAsyncWriteTransaction " ) ; <nl> + realm [ 0 ] = openRealmInstance ( " testAsyncTransaction " ) ; <nl> <nl> assertEquals ( 0 , realm [ 0 ] . allObjects ( Owner . class ) . size ( ) ) ; <nl> <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmListTest . java b / realm / src / androidTest / java / io / realm / RealmListTest . java <nl> index 8f055f6 . . b787d8d 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmListTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmListTest . java <nl> @ @ - 711 , 8 + 711 , 8 @ @ public class RealmListTest extends AndroidTestCase { <nl> testRealm . commitTransaction ( ) ; <nl> } <nl> <nl> - / / Test that all methods that require a write transaction ( ie . any function that mutates Realm data ) <nl> - public void testMutableMethodsOutsideWriteTransactions ( ) { <nl> + / / Test that all methods that require a transaction ( ie . any function that mutates Realm data ) <nl> + public void testMutableMethodsOutsideTransactions ( ) { <nl> testRealm . beginTransaction ( ) ; <nl> RealmList < Dog > list = testRealm . createObject ( AllTypes . class ) . getColumnRealmList ( ) ; <nl> Dog dog = testRealm . createObject ( Dog . class ) ; <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> index e6fc2fd . . e613b71 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmResultsTest . java <nl> @ @ - 1078 , 8 + 1078 , 8 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> } <nl> <nl> <nl> - / / Test that all methods that require a write transaction ( ie . any function that mutates Realm data ) <nl> - public void testMutableMethodsOutsideWriteTransactions ( ) { <nl> + / / Test that all methods that require a transaction ( ie . any function that mutates Realm data ) <nl> + public void testMutableMethodsOutsideTransactions ( ) { <nl> RealmResults < AllTypes > result = testRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> <nl> try { <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index 5ebe85c . . 20833e4 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 16 , 7 + 16 , 6 @ @ <nl> package io . realm ; <nl> <nl> import android . content . Context ; <nl> - import android . os . Handler ; <nl> import android . test . AndroidTestCase ; <nl> <nl> import junit . framework . AssertionFailedError ; <nl> @ @ - 32 , 7 + 31 , 6 @ @ import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> import java . util . Date ; <nl> import java . util . List ; <nl> - import java . util . Map ; <nl> import java . util . Random ; <nl> import java . util . Scanner ; <nl> import java . util . concurrent . Callable ; <nl> @ @ - 769 , 12 + 767 , 12 @ @ public class RealmTest extends AndroidTestCase { <nl> / / These calls should fail outside a Transaction : <nl> try { <nl> testRealm . createObject ( AllTypes . class ) ; <nl> - fail ( " Realm . createObject should fail outside write transaction " ) ; <nl> + fail ( " Realm . createObject should fail outside transaction " ) ; <nl> } catch ( IllegalStateException ignored ) { <nl> } <nl> try { <nl> testRealm . remove ( AllTypes . class , 0 ) ; <nl> - fail ( " Realm . remove should fail outside write transaction " ) ; <nl> + fail ( " Realm . remove should fail outside transaction " ) ; <nl> } catch ( IllegalStateException ignored ) { <nl> } <nl> } <nl> @ @ - 1708 , 8 + 1706 , 8 @ @ public class RealmTest extends AndroidTestCase { <nl> assertTrue ( tmpFile . createNewFile ( ) ) ; <nl> } <nl> <nl> - / / Test that all methods that require a write transaction ( ie . any function that mutates Realm data ) <nl> - public void testMutableMethodsOutsideWriteTransactions ( ) throws JSONException , IOException { <nl> + / / Test that all methods that require a transaction ( ie . any function that mutates Realm data ) <nl> + public void testMutableMethodsOutsideTransactions ( ) throws JSONException , IOException { <nl> <nl> / / Prepare standalone object data <nl> AllTypesPrimaryKey t = new AllTypesPrimaryKey ( ) ; <nl> @ @ - 1726 , 7 + 1724 , 7 @ @ public class RealmTest extends AndroidTestCase { <nl> InputStream jsonArrStream = TestHelper . stringToStream ( jsonArrStr ) ; <nl> InputStream jsonArrStream2 = TestHelper . stringToStream ( jsonArrStr ) ; <nl> <nl> - / / Test all methods that should require a write transaction <nl> + / / Test all methods that should require a transaction <nl> try { testRealm . createObject ( AllTypes . class ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } <nl> try { testRealm . copyToRealm ( t ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } <nl> try { testRealm . copyToRealm ( ts ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } <nl> @ @ - 2171 , 15 + 2169 , 15 @ @ public class RealmTest extends AndroidTestCase { <nl> } <nl> } <nl> <nl> - public void testIsInWriteTransaction ( ) { <nl> - assertFalse ( testRealm . isInWriteTransaction ( ) ) ; <nl> + public void testIsInTransaction ( ) { <nl> + assertFalse ( testRealm . isInTransaction ( ) ) ; <nl> testRealm . beginTransaction ( ) ; <nl> - assertTrue ( testRealm . isInWriteTransaction ( ) ) ; <nl> + assertTrue ( testRealm . isInTransaction ( ) ) ; <nl> testRealm . commitTransaction ( ) ; <nl> - assertFalse ( testRealm . isInWriteTransaction ( ) ) ; <nl> + assertFalse ( testRealm . isInTransaction ( ) ) ; <nl> testRealm . beginTransaction ( ) ; <nl> - assertTrue ( testRealm . isInWriteTransaction ( ) ) ; <nl> + assertTrue ( testRealm . isInTransaction ( ) ) ; <nl> testRealm . cancelTransaction ( ) ; <nl> - assertFalse ( testRealm . isInWriteTransaction ( ) ) ; <nl> + assertFalse ( testRealm . isInTransaction ( ) ) ; <nl> } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / BaseRealm . java b / realm / src / main / java / io / realm / BaseRealm . java <nl> index 1bf1a97 . . 09160db 100644 <nl> - - - a / realm / src / main / java / io / realm / BaseRealm . java <nl> + + + b / realm / src / main / java / io / realm / BaseRealm . java <nl> @ @ - 78 , 7 + 78 , 7 @ @ abstract class BaseRealm implements Closeable { <nl> / / List of Realm files that has already been validated <nl> static final Set < String > validatedRealmFiles = new HashSet < String > ( ) ; <nl> <nl> - / / thread pool for all async operations ( Query & Write transaction ) <nl> + / / thread pool for all async operations ( Query & transaction ) <nl> static final RealmThreadPoolExecutor asyncQueryExecutor = RealmThreadPoolExecutor . getInstance ( ) ; <nl> <nl> protected final List < WeakReference < RealmChangeListener > > changeListeners = <nl> @ @ - 110 , 7 + 110 , 6 @ @ abstract class BaseRealm implements Closeable { <nl> * This feature is only available if the Realm instance lives is a { @ link android . os . Looper } enabled thread . <nl> * <nl> * @ param autoRefresh true will turn auto - refresh on , false will turn it off . <nl> - * @ throws java . lang . IllegalStateException if trying to enable auto - refresh in a thread without Looper . <nl> * / <nl> public void setAutoRefresh ( boolean autoRefresh ) { <nl> checkIfValid ( ) ; <nl> @ @ - 137 , 12 + 136 , 10 @ @ abstract class BaseRealm implements Closeable { <nl> } <nl> <nl> / * * <nl> - * Indicates if the Realm is currently in a write transaction . <nl> - * @ return the write transaction status . <nl> - * @ throws java . lang . IllegalStateException if the Realm is not opened or in a different thread <nl> - * than the one it was created on . <nl> + * Checks if the Realm is currently in a transaction . <nl> + * @ return { @ code true } if inside a transaction , { @ code false } otherwise . <nl> * / <nl> - public boolean isInWriteTransaction ( ) { <nl> + public boolean isInTransaction ( ) { <nl> checkIfValid ( ) ; <nl> return ! sharedGroupManager . isImmutable ( ) ; <nl> } <nl> @ @ - 253 , 8 + 250 , 8 @ @ abstract class BaseRealm implements Closeable { <nl> * < p > <nl> * The destination file cannot already exist . <nl> * < p > <nl> - * Note that if this is called from within a write transaction it writes the <nl> - * current data , and not the data as it was when the last write transaction was committed . <nl> + * Note that if this is called from within a transaction it writes the <nl> + * current data , and not the data as it was when the last transaction was committed . <nl> * <nl> * @ param destination File to save the Realm to <nl> * @ throws java . io . IOException if any write operation fails <nl> @ @ - 268 , 8 + 265 , 8 @ @ abstract class BaseRealm implements Closeable { <nl> * < p > <nl> * The destination file cannot already exist . <nl> * < p > <nl> - * Note that if this is called from within a write transaction it writes the <nl> - * current data , and not the data as it was when the last write transaction was committed . <nl> + * Note that if this is called from within a transaction it writes the current data , and not the <nl> + * data as it was when the last transaction was committed . <nl> * < p > <nl> * @ param destination File to save the Realm to <nl> * @ param key a 64 - byte encryption key <nl> @ @ - 296 , 18 + 293 , 15 @ @ abstract class BaseRealm implements Closeable { <nl> } <nl> <nl> / * * <nl> - * Starts a write transaction , this must be closed with { @ link io . realm . Realm # commitTransaction ( ) } <nl> - * or aborted by { @ link io . realm . Realm # cancelTransaction ( ) } . Write transactions are used to <nl> - * atomically create , update and delete objects within a realm . <nl> + * Starts a transaction , this must be closed with { @ link io . realm . Realm # commitTransaction ( ) } or <nl> + * aborted by { @ link io . realm . Realm # cancelTransaction ( ) } . Transactions are used to atomically <nl> + * create , update and delete objects within a realm . <nl> * < br > <nl> - * Before beginning the write transaction , { @ link io . realm . Realm # beginTransaction ( ) } updates the <nl> - * realm in the case of pending updates from other threads . <nl> + * Before beginning the transaction , { @ link io . realm . Realm # beginTransaction ( ) } updates the realm <nl> + * in the case of pending updates from other threads . <nl> * < br > <nl> - * Notice : it is not possible to nest write transactions . If you start a write <nl> - * transaction within a write transaction an exception is thrown . <nl> - * < br > <nl> - * @ throws java . lang . IllegalStateException If already in a write transaction or incorrect thread . <nl> - * <nl> + * Notice : it is not possible to nest transactions . If you start a transaction within a <nl> + * transaction an exception is thrown . <nl> * / <nl> public void beginTransaction ( ) { <nl> checkIfValid ( ) ; <nl> @ @ - 320 , 9 + 314 , 6 @ @ abstract class BaseRealm implements Closeable { <nl> * that a change has occurred . When the event is received , the other Realms will get their <nl> * objects and { @ link io . realm . RealmResults } updated to reflect <nl> * the changes from this commit . <nl> - * <nl> - * @ throws java . lang . IllegalStateException if the write transaction is in an invalid state <nl> - * or incorrect thread . <nl> * / <nl> public void commitTransaction ( ) { <nl> checkIfValid ( ) ; <nl> @ @ - 361 , 10 + 352 , 7 @ @ abstract class BaseRealm implements Closeable { <nl> * < br > <nl> * The Realm reverts back to read - only . <nl> * < br > <nl> - * Calling this when not in a write transaction will throw an exception . <nl> - * <nl> - * @ throws java . lang . IllegalStateException If the write transaction is an invalid state , <nl> - * not in a write transaction or incorrect thread . <nl> + * Calling this when not in a transaction will throw an exception . <nl> * / <nl> public void cancelTransaction ( ) { <nl> checkIfValid ( ) ; <nl> @ @ - 422 , 9 + 410 , 6 @ @ abstract class BaseRealm implements Closeable { <nl> * < p > <nl> * It ' s important to always remember to close Realm instances when you ' re done with it in order <nl> * not to leak memory , file descriptors or grow the size of Realm file out of measure . <nl> - * <nl> - * @ throws java . lang . IllegalStateException if trying to close Realm on a different thread than the <nl> - * one it was created on . <nl> * / <nl> @ Override <nl> public void close ( ) { <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index c8d9c9d . . fa2414b 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 1157 , 8 + 1157 , 6 @ @ public final class Realm extends BaseRealm { <nl> * <nl> * @ param configuration A { @ link RealmConfiguration } <nl> * @ return false if a file could not be deleted . The failing file will be logged . <nl> - * <nl> - * @ throws java . lang . IllegalStateException if trying to delete a Realm that is already open . <nl> * / <nl> public static boolean deleteRealm ( RealmConfiguration configuration ) { <nl> return BaseRealm . deleteRealm ( configuration ) ; <nl> @ @ - 1175 , 8 + 1173 , 6 @ @ public final class Realm extends BaseRealm { <nl> * <nl> * @ param configuration a { @ link RealmConfiguration } pointing to a Realm file . <nl> * @ return true if successful , false if any file operation failed <nl> - * <nl> - * @ throws java . lang . IllegalStateException if trying to compact a Realm that is already open . <nl> * / <nl> public static boolean compactRealm ( RealmConfiguration configuration ) { <nl> return BaseRealm . compactRealm ( configuration ) ; <nl> diff - - git a / realm / src / main / java / io / realm / internal / ImplicitTransaction . java b / realm / src / main / java / io / realm / internal / ImplicitTransaction . java <nl> index 98841a9 . . 0930bf5 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / ImplicitTransaction . java <nl> + + + b / realm / src / main / java / io / realm / internal / ImplicitTransaction . java <nl> @ @ - 44 , 22 + 44 , 20 @ @ public class ImplicitTransaction extends Group { <nl> <nl> public void promoteToWrite ( ) { <nl> assertNotClosed ( ) ; <nl> - if ( immutable ) { <nl> - immutable = false ; <nl> - parent . promoteToWrite ( ) ; <nl> - } else { <nl> + if ( ! immutable ) { <nl> throw new IllegalStateException ( " Nested transactions are not allowed . Use commitTransaction ( ) after each beginTransaction ( ) . " ) ; <nl> } <nl> + immutable = false ; <nl> + parent . promoteToWrite ( ) ; <nl> } <nl> <nl> public void commitAndContinueAsRead ( ) { <nl> assertNotClosed ( ) ; <nl> - if ( ! immutable ) { <nl> - parent . commitAndContinueAsRead ( ) ; <nl> - immutable = true ; <nl> - } else { <nl> - throw new IllegalStateException ( " Cannot commit a non - write transaction . " ) ; <nl> + if ( immutable ) { <nl> + throw new IllegalStateException ( " Cannot commit a non transaction . " ) ; <nl> } <nl> + parent . commitAndContinueAsRead ( ) ; <nl> + immutable = true ; <nl> } <nl> <nl> public void endRead ( ) { <nl> @ @ - 69 , 12 + 67 , 11 @ @ public class ImplicitTransaction extends Group { <nl> <nl> public void rollbackAndContinueAsRead ( ) { <nl> assertNotClosed ( ) ; <nl> - if ( ! immutable ) { <nl> - parent . rollbackAndContinueAsRead ( ) ; <nl> - immutable = true ; <nl> - } else { <nl> - throw new IllegalStateException ( " Cannot cancel a non - write transaction . " ) ; <nl> + if ( immutable ) { <nl> + throw new IllegalStateException ( " Cannot cancel a non transaction . " ) ; <nl> } <nl> + parent . rollbackAndContinueAsRead ( ) ; <nl> + immutable = true ; <nl> } <nl> <nl> private void assertNotClosed ( ) { <nl> diff - - git a / realm / src / main / java / io / realm / internal / SharedGroupManager . java b / realm / src / main / java / io / realm / internal / SharedGroupManager . java <nl> index 920d6ff . . 30d2f2c 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / SharedGroupManager . java <nl> + + + b / realm / src / main / java / io / realm / internal / SharedGroupManager . java <nl> @ @ - 155 , 7 + 155 , 7 @ @ public class SharedGroupManager implements Closeable { <nl> } <nl> <nl> / * * <nl> - * Returns if the Realm is currently not in a write transaction . <nl> + * Returns if the Realm is currently not in a transaction . <nl> * / <nl> public boolean isImmutable ( ) { <nl> return transaction . immutable ;
NEAREST DIFF (one line): diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index 4e7ea04 . . 2c1889c 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 230 , 6 + 230 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> @ Override <nl> public void onError ( Exception t ) { <nl> threadAssertionError [ 0 ] = t ; <nl> + signalCallbackFinished . countDown ( ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 1371 , 6 + 1372 , 74 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } <nl> <nl> + / / * * * Async write transaction * * * / / <nl> + <nl> + public void testAsyncWriteTransaction ( ) throws Throwable { <nl> + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final Looper [ ] looper = new Looper [ 1 ] ; <nl> + final Realm [ ] realm = new Realm [ 1 ] ; <nl> + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + executorService . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + looper [ 0 ] = Looper . myLooper ( ) ; <nl> + try { <nl> + realm [ 0 ] = openRealmInstance ( " test _ async _ write _ transaction " ) ; <nl> + realm [ 0 ] . executeTransaction ( new Realm . Transaction ( ) { <nl> + @ Override <nl> + public void execute ( Realm realm ) { <nl> + Owner owner = realm . createObject ( Owner . class ) ; <nl> + owner . setName ( " Owner " ) ; <nl> + } <nl> + } , new Realm . Transaction . Callback ( ) { <nl> + @ Override <nl> + public void onSuccess ( ) { <nl> + try { <nl> + assertEquals ( 1 , realm [ 0 ] . allObjects ( Owner . class ) . size ( ) ) ; <nl> + assertEquals ( " Owner " , realm [ 0 ] . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; <nl> + } catch ( AssertionFailedError e ) { <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void onError ( Throwable e ) { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + Looper . loop ( ) ; <nl> + <nl> + } catch ( Exception e ) { <nl> + e . printStackTrace ( ) ; <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + if ( signalCallbackFinished . getCount ( ) > 0 ) { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + if ( realm . length > 0 & & realm [ 0 ] ! = null ) { <nl> + realm [ 0 ] . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + / / wait until the callback of our async query proceed <nl> + signalCallbackFinished . await ( ) ; <nl> + looper [ 0 ] . quit ( ) ; <nl> + executorService . shutdownNow ( ) ; <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + } <nl> + <nl> / / * * * Helper methods * * * <nl> <nl> / / This could be done from # setUp but then we can ' t control <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index 63c510e . . c8c9c95 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 24 , 6 + 24 , 8 @ @ import android . os . Looper ; <nl> import android . os . Message ; <nl> import android . util . JsonReader ; <nl> <nl> + import org . jetbrains . annotations . NotNull ; <nl> + import org . jetbrains . annotations . Nullable ; <nl> import org . json . JSONArray ; <nl> import org . json . JSONException ; <nl> import org . json . JSONObject ; <nl> @ @ - 47 , 6 + 49 , 7 @ @ import java . util . concurrent . ConcurrentHashMap ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . ExecutorService ; <nl> import java . util . concurrent . Executors ; <nl> + import java . util . concurrent . Future ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> <nl> import io . realm . exceptions . RealmException ; <nl> @ @ - 1507 , 7 + 1510 , 8 @ @ public final class Realm implements Closeable { <nl> * / <nl> public void executeTransaction ( Transaction transaction ) { <nl> if ( transaction = = null ) <nl> - return ; <nl> + throw new IllegalArgumentException ( " transaction should not be null " ) ; <nl> + <nl> beginTransaction ( ) ; <nl> try { <nl> transaction . execute ( this ) ; <nl> @ @ - 1522 , 6 + 1526 , 70 @ @ public final class Realm implements Closeable { <nl> } <nl> <nl> / * * <nl> + * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously from a worker thread <nl> + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . <nl> + * @ param callback optional , to receive the result of this query <nl> + * @ return A { @ link io . realm . RealmQuery . Request } representing a cancellable task <nl> + * / <nl> + public RealmQuery . Request executeTransaction ( final Transaction transaction , @ Nullable final Transaction . Callback callback ) { <nl> + if ( transaction = = null ) <nl> + throw new IllegalArgumentException ( " transaction should not be null " ) ; <nl> + <nl> + / / will use the Looper of the caller thread to post the result <nl> + final Handler handler = new Handler ( ) ; <nl> + <nl> + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) <nl> + / / to perform the transaction <nl> + final RealmConfiguration realmConfiguration = getConfiguration ( ) ; <nl> + <nl> + final Future < ? > pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> + bgRealm . beginTransaction ( ) ; <nl> + try { <nl> + transaction . execute ( bgRealm ) ; <nl> + bgRealm . commitTransaction ( ) ; <nl> + if ( callback ! = null ) { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + callback . onSuccess ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } catch ( final RuntimeException e ) { <nl> + bgRealm . cancelTransaction ( ) ; <nl> + if ( callback ! = null ) { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + callback . onError ( e ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } catch ( final Error e ) { <nl> + bgRealm . cancelTransaction ( ) ; <nl> + if ( callback ! = null ) { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + callback . onError ( e ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } finally { <nl> + bgRealm . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + return new RealmQuery . Request ( pendingQuery ) ; <nl> + } <nl> + <nl> + / * * <nl> * Remove all objects of the specified class . <nl> * <nl> * @ param clazz The class which objects should be removed <nl> @ @ - 1883 , 6 + 1951 , 11 @ @ public final class Realm implements Closeable { <nl> * / <nl> public interface Transaction { <nl> void execute ( Realm realm ) ; <nl> + <nl> + class Callback { <nl> + public void onSuccess ( ) { } <nl> + public void onError ( Throwable e ) { } <nl> + } <nl> } <nl> <nl> / * * <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index 0066c39 . . ebb719a 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1773 , 7 + 1773 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the <nl> * query will post the result to the caller ' s thread callback ) <nl> * / <nl> - public class Request { <nl> + public static class Request { <nl> private Future < ? > pendingQuery ; <nl> private volatile boolean isCancelled = false ; <nl>

TEST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index 0d6ec4d . . eb7e58c 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 5 , 7 + 5 , 7 @ @ 
 * Added Realm . isClosed ( ) method . 
 * Added Realm . distinct ( ) method . 
 * Added RealmQuery . isValid ( ) , RealmResults . isValid ( ) and RealmList . isValid ( ) . Each method checks whether the instance is still valid to use or not ( for example , the Realm has been closed or any parent object has been removed ) . 
 - * Added Realm . isInWriteTransaction ( ) method . 
 + * Added Realm . isInTransaction ( ) method . 
 * Following methods in managed RealmList now throw IllegalStateException instead of native crash when RealmList . isValid ( ) returns false : add ( int , RealmObject ) , add ( RealmObject ) 
 * Following methods in managed RealmList now throw IllegalStateException instead of ArrayIndexOutOfBoundsException when RealmList . isValid ( ) returns false : set ( int , RealmObject ) , move ( int , int ) , remove ( int ) , get ( int ) 
 * Following methods in managed RealmList now throw IllegalStateException instead of returning 0 / null when RealmList . isValid ( ) returns false : clear ( ) , removeAll ( Collection ) , remove ( RealmObject ) , first ( ) , last ( ) , size ( ) , where ( ) 
 @ @ - 28 , 7 + 28 , 7 @ @ 
 * Deprecated methods : RealmQuery . minimum { Int , Float , Double } , RealmQuery . maximum { Int , Float , Double } . Use RealmQuery . min ( ) and RealmQuery . max ( ) instead . 
 * Added support for x86 _ 64 . 
 * Fixed an issue where opening the same Realm file on two Looper threads could potentially lead to an IllegalStateException being thrown . 
 - * Opening a Realm file from one thread will no longer be blocked by a write transaction from another thread . 
 + * Opening a Realm file from one thread will no longer be blocked by a transaction from another thread . 
 * Fixed an issue preventing the call of listeners on refresh ( ) . 
 * Range restrictions of Date fields have been removed . Date fields now accepts any value . Milliseconds are still removed . 
 
 @ @ - 230 , 7 + 230 , 7 @ @ 
 * Better support for Java 7 and 8 in the annotations processor 
 * Better support for the Eclipse annotations processor 
 * Added Eclipse support to the distribution folder 
 - * Added Realm . cancelTransaction ( ) to cancel / abort / rollback a write transaction 
 + * Added Realm . cancelTransaction ( ) to cancel / abort / rollback a transaction 
 * Faster implementation of RealmQuery . findFirst ( ) 
 * Upgraded core to 0 . 85 . 1 ( deep copying of strings in queries ; preparation for link queries ) 
 * Added support for link queries in the form realm . where ( Owner . class ) . equalTo ( " cat . age " , 12 ) . findAll ( ) 
 @ @ - 239 , 7 + 239 , 7 @ @ 
 * Simplified the release artifact to a single Jar file 
 * Added support for Eclipse 
 * Added support for deploying to Maven 
 - * Throw exception if nested write transactions are used ( it ' s not allowed ) 
 + * Throw exception if nested transactions are used ( it ' s not allowed ) 
 * Javadoc updated 
 * Fixed bug in RealmResults : https : / / github . com / realm / realm - java / issues / 453 
 * New annotation @ Index to add search index to a field ( currently only supporting String fields ) 
 diff - - git a / examples / introExample / src / main / java / io / realm / examples / intro / IntroExampleActivity . java b / examples / introExample / src / main / java / io / realm / examples / intro / IntroExampleActivity . java 
 index 3fa8476 . . 7382897 100644 
 - - - a / examples / introExample / src / main / java / io / realm / examples / intro / IntroExampleActivity . java 
 + + + b / examples / introExample / src / main / java / io / realm / examples / intro / IntroExampleActivity . java 
 @ @ - 96 , 14 + 96 , 14 @ @ public class IntroExampleActivity extends Activity { 
 person . setName ( " Young Person " ) ; 
 person . setAge ( 14 ) ; 
 
 - / / When the write transaction is committed , all changes a synced to disk . 
 + / / When the transaction is committed , all changes a synced to disk . 
 realm . commitTransaction ( ) ; 
 
 / / Find the first person ( no query conditions ) and read a field 
 person = realm . where ( Person . class ) . findFirst ( ) ; 
 showStatus ( person . getName ( ) + " : " + person . getAge ( ) ) ; 
 
 - / / Update person in a write transaction 
 + / / Update person in a transaction 
 realm . beginTransaction ( ) ; 
 person . setName ( " Senior Person " ) ; 
 person . setAge ( 99 ) ; 
 @ @ - 141 , 7 + 141 , 7 @ @ public class IntroExampleActivity extends Activity { 
 / / Those can not be transferred across threads . 
 Realm realm = Realm . getInstance ( this ) ; 
 
 - / / Add ten persons in one write transaction 
 + / / Add ten persons in one transaction 
 realm . beginTransaction ( ) ; 
 Dog fido = realm . createObject ( Dog . class ) ; 
 fido . setName ( " fido " ) ; 
 diff - - git a / examples / kotlinExample / src / main / java / io / realm / examples / kotlin / KotlinExampleActivity . kt b / examples / kotlinExample / src / main / java / io / realm / examples / kotlin / KotlinExampleActivity . kt 
 index bbc7121 . . e170ed6 100644 
 - - - a / examples / kotlinExample / src / main / java / io / realm / examples / kotlin / KotlinExampleActivity . kt 
 + + + b / examples / kotlinExample / src / main / java / io / realm / examples / kotlin / KotlinExampleActivity . kt 
 @ @ - 93 , 14 + 93 , 14 @ @ public class KotlinExampleActivity : Activity ( ) { 
 person . name = " Young Person " 
 person . age = 14 
 
 - / / When the write transaction is committed , all changes a synced to disk . 
 + / / When the transaction is committed , all changes a synced to disk . 
 realm . commitTransaction ( ) 
 
 / / Find the first person ( no query conditions ) and read a field 
 person = realm . where ( javaClass < Person > ( ) ) . findFirst ( ) 
 showStatus ( person . name + " : " + person . age ) 
 
 - / / Update person in a write transaction 
 + / / Update person in a transaction 
 realm . beginTransaction ( ) 
 person . name = " Senior Person " 
 person . age = 99 
 @ @ - 140 , 7 + 140 , 7 @ @ public class KotlinExampleActivity : Activity ( ) { 
 / / Those can not be transferred across threads . 
 val realm = Realm . getInstance ( this ) 
 
 - / / Add ten persons in one write transaction 
 + / / Add ten persons in one transaction 
 realm . beginTransaction ( ) 
 val fido = realm . createObject ( javaClass < Dog > ( ) ) 
 fido . name = " fido " 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index 0aec5bb . . 7114cf0 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 42 , 12 + 42 , 12 @ @ import io . realm . instrumentation . MockActivityManager ; 
 import io . realm . proxy . HandlerProxy ; 
 
 public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 - / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 - / / * * * * Async write transaction * * * 
 - / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 + / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 + / / * * * * Async transaction * * * 
 + / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 
 - / / start asynchronously a write transaction to insert one element 
 - public void testAsyncWriteTransaction ( ) throws Throwable { 
 + / / start asynchronously a transaction to insert one element 
 + public void testAsyncTransaction ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final Realm [ ] realm = new Realm [ 1 ] ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; / / to catch both Exception & AssertionError 
 @ @ - 60 , 7 + 60 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 backgroundLooper [ 0 ] = Looper . myLooper ( ) ; 
 
 try { 
 - realm [ 0 ] = openRealmInstance ( " testAsyncWriteTransaction " ) ; 
 + realm [ 0 ] = openRealmInstance ( " testAsyncTransaction " ) ; 
 
 assertEquals ( 0 , realm [ 0 ] . allObjects ( Owner . class ) . size ( ) ) ; 
 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmListTest . java b / realm / src / androidTest / java / io / realm / RealmListTest . java 
 index 8f055f6 . . b787d8d 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmListTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmListTest . java 
 @ @ - 711 , 8 + 711 , 8 @ @ public class RealmListTest extends AndroidTestCase { 
 testRealm . commitTransaction ( ) ; 
 } 
 
 - / / Test that all methods that require a write transaction ( ie . any function that mutates Realm data ) 
 - public void testMutableMethodsOutsideWriteTransactions ( ) { 
 + / / Test that all methods that require a transaction ( ie . any function that mutates Realm data ) 
 + public void testMutableMethodsOutsideTransactions ( ) { 
 testRealm . beginTransaction ( ) ; 
 RealmList < Dog > list = testRealm . createObject ( AllTypes . class ) . getColumnRealmList ( ) ; 
 Dog dog = testRealm . createObject ( Dog . class ) ; 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 index e6fc2fd . . e613b71 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmResultsTest . java 
 @ @ - 1078 , 8 + 1078 , 8 @ @ public class RealmResultsTest extends AndroidTestCase { 
 } 
 
 
 - / / Test that all methods that require a write transaction ( ie . any function that mutates Realm data ) 
 - public void testMutableMethodsOutsideWriteTransactions ( ) { 
 + / / Test that all methods that require a transaction ( ie . any function that mutates Realm data ) 
 + public void testMutableMethodsOutsideTransactions ( ) { 
 RealmResults < AllTypes > result = testRealm . where ( AllTypes . class ) . findAll ( ) ; 
 
 try { 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index 5ebe85c . . 20833e4 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 16 , 7 + 16 , 6 @ @ 
 package io . realm ; 
 
 import android . content . Context ; 
 - import android . os . Handler ; 
 import android . test . AndroidTestCase ; 
 
 import junit . framework . AssertionFailedError ; 
 @ @ - 32 , 7 + 31 , 6 @ @ import java . util . ArrayList ; 
 import java . util . Arrays ; 
 import java . util . Date ; 
 import java . util . List ; 
 - import java . util . Map ; 
 import java . util . Random ; 
 import java . util . Scanner ; 
 import java . util . concurrent . Callable ; 
 @ @ - 769 , 12 + 767 , 12 @ @ public class RealmTest extends AndroidTestCase { 
 / / These calls should fail outside a Transaction : 
 try { 
 testRealm . createObject ( AllTypes . class ) ; 
 - fail ( " Realm . createObject should fail outside write transaction " ) ; 
 + fail ( " Realm . createObject should fail outside transaction " ) ; 
 } catch ( IllegalStateException ignored ) { 
 } 
 try { 
 testRealm . remove ( AllTypes . class , 0 ) ; 
 - fail ( " Realm . remove should fail outside write transaction " ) ; 
 + fail ( " Realm . remove should fail outside transaction " ) ; 
 } catch ( IllegalStateException ignored ) { 
 } 
 } 
 @ @ - 1708 , 8 + 1706 , 8 @ @ public class RealmTest extends AndroidTestCase { 
 assertTrue ( tmpFile . createNewFile ( ) ) ; 
 } 
 
 - / / Test that all methods that require a write transaction ( ie . any function that mutates Realm data ) 
 - public void testMutableMethodsOutsideWriteTransactions ( ) throws JSONException , IOException { 
 + / / Test that all methods that require a transaction ( ie . any function that mutates Realm data ) 
 + public void testMutableMethodsOutsideTransactions ( ) throws JSONException , IOException { 
 
 / / Prepare standalone object data 
 AllTypesPrimaryKey t = new AllTypesPrimaryKey ( ) ; 
 @ @ - 1726 , 7 + 1724 , 7 @ @ public class RealmTest extends AndroidTestCase { 
 InputStream jsonArrStream = TestHelper . stringToStream ( jsonArrStr ) ; 
 InputStream jsonArrStream2 = TestHelper . stringToStream ( jsonArrStr ) ; 
 
 - / / Test all methods that should require a write transaction 
 + / / Test all methods that should require a transaction 
 try { testRealm . createObject ( AllTypes . class ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } 
 try { testRealm . copyToRealm ( t ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } 
 try { testRealm . copyToRealm ( ts ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } 
 @ @ - 2171 , 15 + 2169 , 15 @ @ public class RealmTest extends AndroidTestCase { 
 } 
 } 
 
 - public void testIsInWriteTransaction ( ) { 
 - assertFalse ( testRealm . isInWriteTransaction ( ) ) ; 
 + public void testIsInTransaction ( ) { 
 + assertFalse ( testRealm . isInTransaction ( ) ) ; 
 testRealm . beginTransaction ( ) ; 
 - assertTrue ( testRealm . isInWriteTransaction ( ) ) ; 
 + assertTrue ( testRealm . isInTransaction ( ) ) ; 
 testRealm . commitTransaction ( ) ; 
 - assertFalse ( testRealm . isInWriteTransaction ( ) ) ; 
 + assertFalse ( testRealm . isInTransaction ( ) ) ; 
 testRealm . beginTransaction ( ) ; 
 - assertTrue ( testRealm . isInWriteTransaction ( ) ) ; 
 + assertTrue ( testRealm . isInTransaction ( ) ) ; 
 testRealm . cancelTransaction ( ) ; 
 - assertFalse ( testRealm . isInWriteTransaction ( ) ) ; 
 + assertFalse ( testRealm . isInTransaction ( ) ) ; 
 } 
 } 
 diff - - git a / realm / src / main / java / io / realm / BaseRealm . java b / realm / src / main / java / io / realm / BaseRealm . java 
 index 1bf1a97 . . 09160db 100644 
 - - - a / realm / src / main / java / io / realm / BaseRealm . java 
 + + + b / realm / src / main / java / io / realm / BaseRealm . java 
 @ @ - 78 , 7 + 78 , 7 @ @ abstract class BaseRealm implements Closeable { 
 / / List of Realm files that has already been validated 
 static final Set < String > validatedRealmFiles = new HashSet < String > ( ) ; 
 
 - / / thread pool for all async operations ( Query & Write transaction ) 
 + / / thread pool for all async operations ( Query & transaction ) 
 static final RealmThreadPoolExecutor asyncQueryExecutor = RealmThreadPoolExecutor . getInstance ( ) ; 
 
 protected final List < WeakReference < RealmChangeListener > > changeListeners = 
 @ @ - 110 , 7 + 110 , 6 @ @ abstract class BaseRealm implements Closeable { 
 * This feature is only available if the Realm instance lives is a { @ link android . os . Looper } enabled thread . 
 * 
 * @ param autoRefresh true will turn auto - refresh on , false will turn it off . 
 - * @ throws java . lang . IllegalStateException if trying to enable auto - refresh in a thread without Looper . 
 * / 
 public void setAutoRefresh ( boolean autoRefresh ) { 
 checkIfValid ( ) ; 
 @ @ - 137 , 12 + 136 , 10 @ @ abstract class BaseRealm implements Closeable { 
 } 
 
 / * * 
 - * Indicates if the Realm is currently in a write transaction . 
 - * @ return the write transaction status . 
 - * @ throws java . lang . IllegalStateException if the Realm is not opened or in a different thread 
 - * than the one it was created on . 
 + * Checks if the Realm is currently in a transaction . 
 + * @ return { @ code true } if inside a transaction , { @ code false } otherwise . 
 * / 
 - public boolean isInWriteTransaction ( ) { 
 + public boolean isInTransaction ( ) { 
 checkIfValid ( ) ; 
 return ! sharedGroupManager . isImmutable ( ) ; 
 } 
 @ @ - 253 , 8 + 250 , 8 @ @ abstract class BaseRealm implements Closeable { 
 * < p > 
 * The destination file cannot already exist . 
 * < p > 
 - * Note that if this is called from within a write transaction it writes the 
 - * current data , and not the data as it was when the last write transaction was committed . 
 + * Note that if this is called from within a transaction it writes the 
 + * current data , and not the data as it was when the last transaction was committed . 
 * 
 * @ param destination File to save the Realm to 
 * @ throws java . io . IOException if any write operation fails 
 @ @ - 268 , 8 + 265 , 8 @ @ abstract class BaseRealm implements Closeable { 
 * < p > 
 * The destination file cannot already exist . 
 * < p > 
 - * Note that if this is called from within a write transaction it writes the 
 - * current data , and not the data as it was when the last write transaction was committed . 
 + * Note that if this is called from within a transaction it writes the current data , and not the 
 + * data as it was when the last transaction was committed . 
 * < p > 
 * @ param destination File to save the Realm to 
 * @ param key a 64 - byte encryption key 
 @ @ - 296 , 18 + 293 , 15 @ @ abstract class BaseRealm implements Closeable { 
 } 
 
 / * * 
 - * Starts a write transaction , this must be closed with { @ link io . realm . Realm # commitTransaction ( ) } 
 - * or aborted by { @ link io . realm . Realm # cancelTransaction ( ) } . Write transactions are used to 
 - * atomically create , update and delete objects within a realm . 
 + * Starts a transaction , this must be closed with { @ link io . realm . Realm # commitTransaction ( ) } or 
 + * aborted by { @ link io . realm . Realm # cancelTransaction ( ) } . Transactions are used to atomically 
 + * create , update and delete objects within a realm . 
 * < br > 
 - * Before beginning the write transaction , { @ link io . realm . Realm # beginTransaction ( ) } updates the 
 - * realm in the case of pending updates from other threads . 
 + * Before beginning the transaction , { @ link io . realm . Realm # beginTransaction ( ) } updates the realm 
 + * in the case of pending updates from other threads . 
 * < br > 
 - * Notice : it is not possible to nest write transactions . If you start a write 
 - * transaction within a write transaction an exception is thrown . 
 - * < br > 
 - * @ throws java . lang . IllegalStateException If already in a write transaction or incorrect thread . 
 - * 
 + * Notice : it is not possible to nest transactions . If you start a transaction within a 
 + * transaction an exception is thrown . 
 * / 
 public void beginTransaction ( ) { 
 checkIfValid ( ) ; 
 @ @ - 320 , 9 + 314 , 6 @ @ abstract class BaseRealm implements Closeable { 
 * that a change has occurred . When the event is received , the other Realms will get their 
 * objects and { @ link io . realm . RealmResults } updated to reflect 
 * the changes from this commit . 
 - * 
 - * @ throws java . lang . IllegalStateException if the write transaction is in an invalid state 
 - * or incorrect thread . 
 * / 
 public void commitTransaction ( ) { 
 checkIfValid ( ) ; 
 @ @ - 361 , 10 + 352 , 7 @ @ abstract class BaseRealm implements Closeable { 
 * < br > 
 * The Realm reverts back to read - only . 
 * < br > 
 - * Calling this when not in a write transaction will throw an exception . 
 - * 
 - * @ throws java . lang . IllegalStateException If the write transaction is an invalid state , 
 - * not in a write transaction or incorrect thread . 
 + * Calling this when not in a transaction will throw an exception . 
 * / 
 public void cancelTransaction ( ) { 
 checkIfValid ( ) ; 
 @ @ - 422 , 9 + 410 , 6 @ @ abstract class BaseRealm implements Closeable { 
 * < p > 
 * It ' s important to always remember to close Realm instances when you ' re done with it in order 
 * not to leak memory , file descriptors or grow the size of Realm file out of measure . 
 - * 
 - * @ throws java . lang . IllegalStateException if trying to close Realm on a different thread than the 
 - * one it was created on . 
 * / 
 @ Override 
 public void close ( ) { 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index c8d9c9d . . fa2414b 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 1157 , 8 + 1157 , 6 @ @ public final class Realm extends BaseRealm { 
 * 
 * @ param configuration A { @ link RealmConfiguration } 
 * @ return false if a file could not be deleted . The failing file will be logged . 
 - * 
 - * @ throws java . lang . IllegalStateException if trying to delete a Realm that is already open . 
 * / 
 public static boolean deleteRealm ( RealmConfiguration configuration ) { 
 return BaseRealm . deleteRealm ( configuration ) ; 
 @ @ - 1175 , 8 + 1173 , 6 @ @ public final class Realm extends BaseRealm { 
 * 
 * @ param configuration a { @ link RealmConfiguration } pointing to a Realm file . 
 * @ return true if successful , false if any file operation failed 
 - * 
 - * @ throws java . lang . IllegalStateException if trying to compact a Realm that is already open . 
 * / 
 public static boolean compactRealm ( RealmConfiguration configuration ) { 
 return BaseRealm . compactRealm ( configuration ) ; 
 diff - - git a / realm / src / main / java / io / realm / internal / ImplicitTransaction . java b / realm / src / main / java / io / realm / internal / ImplicitTransaction . java 
 index 98841a9 . . 0930bf5 100644 
 - - - a / realm / src / main / java / io / realm / internal / ImplicitTransaction . java 
 + + + b / realm / src / main / java / io / realm / internal / ImplicitTransaction . java 
 @ @ - 44 , 22 + 44 , 20 @ @ public class ImplicitTransaction extends Group { 
 
 public void promoteToWrite ( ) { 
 assertNotClosed ( ) ; 
 - if ( immutable ) { 
 - immutable = false ; 
 - parent . promoteToWrite ( ) ; 
 - } else { 
 + if ( ! immutable ) { 
 throw new IllegalStateException ( " Nested transactions are not allowed . Use commitTransaction ( ) after each beginTransaction ( ) . " ) ; 
 } 
 + immutable = false ; 
 + parent . promoteToWrite ( ) ; 
 } 
 
 public void commitAndContinueAsRead ( ) { 
 assertNotClosed ( ) ; 
 - if ( ! immutable ) { 
 - parent . commitAndContinueAsRead ( ) ; 
 - immutable = true ; 
 - } else { 
 - throw new IllegalStateException ( " Cannot commit a non - write transaction . " ) ; 
 + if ( immutable ) { 
 + throw new IllegalStateException ( " Cannot commit a non transaction . " ) ; 
 } 
 + parent . commitAndContinueAsRead ( ) ; 
 + immutable = true ; 
 } 
 
 public void endRead ( ) { 
 @ @ - 69 , 12 + 67 , 11 @ @ public class ImplicitTransaction extends Group { 
 
 public void rollbackAndContinueAsRead ( ) { 
 assertNotClosed ( ) ; 
 - if ( ! immutable ) { 
 - parent . rollbackAndContinueAsRead ( ) ; 
 - immutable = true ; 
 - } else { 
 - throw new IllegalStateException ( " Cannot cancel a non - write transaction . " ) ; 
 + if ( immutable ) { 
 + throw new IllegalStateException ( " Cannot cancel a non transaction . " ) ; 
 } 
 + parent . rollbackAndContinueAsRead ( ) ; 
 + immutable = true ; 
 } 
 
 private void assertNotClosed ( ) { 
 diff - - git a / realm / src / main / java / io / realm / internal / SharedGroupManager . java b / realm / src / main / java / io / realm / internal / SharedGroupManager . java 
 index 920d6ff . . 30d2f2c 100644 
 - - - a / realm / src / main / java / io / realm / internal / SharedGroupManager . java 
 + + + b / realm / src / main / java / io / realm / internal / SharedGroupManager . java 
 @ @ - 155 , 7 + 155 , 7 @ @ public class SharedGroupManager implements Closeable { 
 } 
 
 / * * 
 - * Returns if the Realm is currently not in a write transaction . 
 + * Returns if the Realm is currently not in a transaction . 
 * / 
 public boolean isImmutable ( ) { 
 return transaction . immutable ;

NEAREST DIFF:
diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index 4e7ea04 . . 2c1889c 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 230 , 6 + 230 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 @ Override 
 public void onError ( Exception t ) { 
 threadAssertionError [ 0 ] = t ; 
 + signalCallbackFinished . countDown ( ) ; 
 } 
 
 @ Override 
 @ @ - 1371 , 6 + 1372 , 74 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } 
 
 + / / * * * Async write transaction * * * / / 
 + 
 + public void testAsyncWriteTransaction ( ) throws Throwable { 
 + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final Looper [ ] looper = new Looper [ 1 ] ; 
 + final Realm [ ] realm = new Realm [ 1 ] ; 
 + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + executorService . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + looper [ 0 ] = Looper . myLooper ( ) ; 
 + try { 
 + realm [ 0 ] = openRealmInstance ( " test _ async _ write _ transaction " ) ; 
 + realm [ 0 ] . executeTransaction ( new Realm . Transaction ( ) { 
 + @ Override 
 + public void execute ( Realm realm ) { 
 + Owner owner = realm . createObject ( Owner . class ) ; 
 + owner . setName ( " Owner " ) ; 
 + } 
 + } , new Realm . Transaction . Callback ( ) { 
 + @ Override 
 + public void onSuccess ( ) { 
 + try { 
 + assertEquals ( 1 , realm [ 0 ] . allObjects ( Owner . class ) . size ( ) ) ; 
 + assertEquals ( " Owner " , realm [ 0 ] . where ( Owner . class ) . findFirst ( ) . getName ( ) ) ; 
 + } catch ( AssertionFailedError e ) { 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onError ( Throwable e ) { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } ) ; 
 + 
 + Looper . loop ( ) ; 
 + 
 + } catch ( Exception e ) { 
 + e . printStackTrace ( ) ; 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + if ( signalCallbackFinished . getCount ( ) > 0 ) { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + if ( realm . length > 0 & & realm [ 0 ] ! = null ) { 
 + realm [ 0 ] . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + / / wait until the callback of our async query proceed 
 + signalCallbackFinished . await ( ) ; 
 + looper [ 0 ] . quit ( ) ; 
 + executorService . shutdownNow ( ) ; 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + } 
 + 
 / / * * * Helper methods * * * 
 
 / / This could be done from # setUp but then we can ' t control 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index 63c510e . . c8c9c95 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 24 , 6 + 24 , 8 @ @ import android . os . Looper ; 
 import android . os . Message ; 
 import android . util . JsonReader ; 
 
 + import org . jetbrains . annotations . NotNull ; 
 + import org . jetbrains . annotations . Nullable ; 
 import org . json . JSONArray ; 
 import org . json . JSONException ; 
 import org . json . JSONObject ; 
 @ @ - 47 , 6 + 49 , 7 @ @ import java . util . concurrent . ConcurrentHashMap ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . ExecutorService ; 
 import java . util . concurrent . Executors ; 
 + import java . util . concurrent . Future ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 
 import io . realm . exceptions . RealmException ; 
 @ @ - 1507 , 7 + 1510 , 8 @ @ public final class Realm implements Closeable { 
 * / 
 public void executeTransaction ( Transaction transaction ) { 
 if ( transaction = = null ) 
 - return ; 
 + throw new IllegalArgumentException ( " transaction should not be null " ) ; 
 + 
 beginTransaction ( ) ; 
 try { 
 transaction . execute ( this ) ; 
 @ @ - 1522 , 6 + 1526 , 70 @ @ public final class Realm implements Closeable { 
 } 
 
 / * * 
 + * Similar to { @ link # executeTransaction ( Transaction ) } but runs asynchronously from a worker thread 
 + * @ param transaction { @ link io . realm . Realm . Transaction } to execute . 
 + * @ param callback optional , to receive the result of this query 
 + * @ return A { @ link io . realm . RealmQuery . Request } representing a cancellable task 
 + * / 
 + public RealmQuery . Request executeTransaction ( final Transaction transaction , @ Nullable final Transaction . Callback callback ) { 
 + if ( transaction = = null ) 
 + throw new IllegalArgumentException ( " transaction should not be null " ) ; 
 + 
 + / / will use the Looper of the caller thread to post the result 
 + final Handler handler = new Handler ( ) ; 
 + 
 + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) 
 + / / to perform the transaction 
 + final RealmConfiguration realmConfiguration = getConfiguration ( ) ; 
 + 
 + final Future < ? > pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 + bgRealm . beginTransaction ( ) ; 
 + try { 
 + transaction . execute ( bgRealm ) ; 
 + bgRealm . commitTransaction ( ) ; 
 + if ( callback ! = null ) { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + callback . onSuccess ( ) ; 
 + } 
 + } ) ; 
 + } 
 + } catch ( final RuntimeException e ) { 
 + bgRealm . cancelTransaction ( ) ; 
 + if ( callback ! = null ) { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + callback . onError ( e ) ; 
 + } 
 + } ) ; 
 + } 
 + } catch ( final Error e ) { 
 + bgRealm . cancelTransaction ( ) ; 
 + if ( callback ! = null ) { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + callback . onError ( e ) ; 
 + } 
 + } ) ; 
 + } 
 + } finally { 
 + bgRealm . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + return new RealmQuery . Request ( pendingQuery ) ; 
 + } 
 + 
 + / * * 
 * Remove all objects of the specified class . 
 * 
 * @ param clazz The class which objects should be removed 
 @ @ - 1883 , 6 + 1951 , 11 @ @ public final class Realm implements Closeable { 
 * / 
 public interface Transaction { 
 void execute ( Realm realm ) ; 
 + 
 + class Callback { 
 + public void onSuccess ( ) { } 
 + public void onError ( Throwable e ) { } 
 + } 
 } 
 
 / * * 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index 0066c39 . . ebb719a 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1773 , 7 + 1773 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the 
 * query will post the result to the caller ' s thread callback ) 
 * / 
 - public class Request { 
 + public static class Request { 
 private Future < ? > pendingQuery ; 
 private volatile boolean isCancelled = false ; 

