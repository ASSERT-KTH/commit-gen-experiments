BLEU SCORE: 0.08745825313180632

TEST MSG: Back the RealmResults by collection
GENERATED MSG: Mitigate the file size growing problem

TEST DIFF (one line): diff - - git a / realm / realm - library / src / main / java / io / realm / BaseRealm . java b / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> index 6e5dc1c . . a32f249 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> @ @ - 506 , 9 + 506 , 7 @ @ abstract class BaseRealm implements Closeable { <nl> } <nl> <nl> / / FIXME : Testing code <nl> - < E extends RealmModel > E get ( Class < E > clazz , long rowPtr ) { <nl> - Table table = schema . getTable ( clazz ) ; <nl> - UncheckedRow row = UncheckedRow . getByRowPointer ( table , rowPtr ) ; <nl> + < E extends RealmModel > E get ( Class < E > clazz , Row row ) { <nl> <nl> E result = configuration . getSchemaMediator ( ) . newInstance ( clazz , this , row , schema . getColumnInfo ( clazz ) , <nl> false , Collections . < String > emptyList ( ) ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> index 3d2bf45 . . 2c4e578 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> @ @ - 18 , 9 + 18 , 9 @ @ package io . realm ; <nl> <nl> <nl> import android . app . IntentService ; <nl> + import android . os . Looper ; <nl> <nl> import java . util . AbstractList ; <nl> - import java . util . Collection ; <nl> import java . util . Collections ; <nl> import java . util . ConcurrentModificationException ; <nl> import java . util . Date ; <nl> @ @ - 31 , 24 + 31 , 21 @ @ import java . util . NoSuchElementException ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . Future ; <nl> <nl> - import io . realm . internal . CheckedRow ; <nl> - import io . realm . internal . InvalidRow ; <nl> - import io . realm . internal . RealmObjectProxy ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableOrView ; <nl> import io . realm . internal . TableQuery ; <nl> import io . realm . internal . TableView ; <nl> - import io . realm . internal . UncheckedRow ; <nl> + import io . realm . internal . Collection ; <nl> import io . realm . internal . async . BadVersionException ; <nl> import io . realm . log . RealmLog ; <nl> import rx . Observable ; <nl> <nl> / * * <nl> - * This class holds all the matches of a { @ link io . realm . RealmQuery } for a given Realm . The objects are not copied from <nl> + * This class holds all the matches of a { @ link RealmQuery } for a given Realm . The objects are not copied from <nl> * the Realm to the RealmResults list , but are just referenced from the RealmResult instead . This saves memory and <nl> * increases speed . <nl> * < p > <nl> - * RealmResults are live views , which means that if it is on an { @ link android . os . Looper } thread , it will automatically <nl> + * RealmResults are live views , which means that if it is on an { @ link Looper } thread , it will automatically <nl> * update its query results after a transaction has been committed . If on a non - looper thread , { @ link Realm # waitForChange ( ) } <nl> * must be called to update the results . <nl> * < p > <nl> @ @ - 68 , 7 + 65 , 7 @ @ import rx . Observable ; <nl> * <nl> * @ param < E > The class of objects in this list . <nl> * @ see RealmQuery # findAll ( ) <nl> - * @ see io . realm . Realm # executeTransaction ( Realm . Transaction ) <nl> + * @ see Realm # executeTransaction ( Realm . Transaction ) <nl> * / <nl> public final class RealmResults < E extends RealmModel > extends AbstractList < E > implements OrderedRealmCollection < E > { <nl> <nl> @ @ - 84 , 6 + 81 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> <nl> private long currentTableViewVersion = TABLE _ VIEW _ VERSION _ NONE ; <nl> private final TableQuery query ; <nl> + private final io . realm . internal . Collection collection ; <nl> private final List < RealmChangeListener < RealmResults < E > > > listeners = new CopyOnWriteArrayList < RealmChangeListener < RealmResults < E > > > ( ) ; <nl> private Future < Long > pendingQuery ; <nl> private boolean asyncQueryCompleted = false ; <nl> @ @ - 91 , 8 + 89 , 6 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> / / clear it . <nl> private boolean viewUpdated = false ; <nl> <nl> - private final long nativePtr ; <nl> - <nl> / / Public for static checking in JNI <nl> public static final byte AGGREGATE _ FUNCTION _ MINIMUM = 1 ; <nl> public static final byte AGGREGATE _ FUNCTION _ MAXIMUM = 2 ; <nl> @ @ - 124 , 6 + 120 , 13 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> return realmResults ; <nl> } <nl> <nl> + RealmResults ( BaseRealm realm , io . realm . internal . Collection collection , Class < E > clazz ) { <nl> + this . realm = realm ; <nl> + this . query = null ; <nl> + this . classSpec = clazz ; <nl> + this . collection = collection ; <nl> + } <nl> + <nl> private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz , String fieldNames [ ] , Sort [ ] sortOrder ) { <nl> this . realm = realm ; <nl> this . classSpec = clazz ; <nl> @ @ - 144 , 21 + 147 , 21 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> } <nl> } <nl> <nl> - this . nativePtr = nativeCreateResults ( realm . sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , indices , order ) ; <nl> + collection = null ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz ) { <nl> this . realm = realm ; <nl> this . classSpec = clazz ; <nl> this . query = query ; <nl> - this . nativePtr = 0 ; <nl> + collection = null ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , TableQuery query , String className ) { <nl> this . realm = realm ; <nl> this . query = query ; <nl> this . className = className ; <nl> - this . nativePtr = 0 ; <nl> + collection = null ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , TableOrView table , Class < E > classSpec ) { <nl> @ @ - 169 , 7 + 172 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> this . pendingQuery = null ; <nl> this . query = null ; <nl> this . currentTableViewVersion = table . syncIfNeeded ( ) ; <nl> - this . nativePtr = 0 ; <nl> + collection = null ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , String className ) { <nl> @ @ - 178 , 7 + 181 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> <nl> pendingQuery = null ; <nl> query = null ; <nl> - this . nativePtr = 0 ; <nl> + collection = null ; <nl> } <nl> <nl> private RealmResults ( BaseRealm realm , TableOrView table , String className ) { <nl> @ @ - 190 , 8 + 193 , 8 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> private RealmResults ( BaseRealm realm , String className , long nativePtr ) { <nl> this . realm = realm ; <nl> this . className = className ; <nl> - this . nativePtr = nativePtr ; <nl> this . query = null ; <nl> + collection = null ; <nl> } <nl> <nl> TableOrView getTableOrView ( ) { <nl> @ @ - 237 , 6 + 240 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Override <nl> public boolean contains ( Object object ) { <nl> + / * <nl> boolean contains = false ; <nl> if ( isLoaded ( ) & & object instanceof RealmObjectProxy ) { <nl> RealmObjectProxy proxy = ( RealmObjectProxy ) object ; <nl> @ @ - 255 , 6 + 259 , 8 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> } <nl> } <nl> return contains ; <nl> + * / <nl> + return false ; <nl> } <nl> <nl> / * * <nl> @ @ - 266 , 18 + 272 , 8 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Override <nl> public E get ( int location ) { <nl> - E obj ; <nl> realm . checkIfValid ( ) ; <nl> - / * <nl> - TableOrView table = getTableOrView ( ) ; <nl> - if ( table instanceof TableView ) { <nl> - obj = realm . get ( classSpec , className , ( ( TableView ) table ) . getSourceRowIndex ( location ) ) ; <nl> - } else { <nl> - obj = realm . get ( classSpec , className , location ) ; <nl> - } <nl> - * / <nl> - long rowPtr = nativeGetRow ( nativePtr , location ) ; <nl> - return realm . get ( classSpec , rowPtr ) ; <nl> + return realm . get ( classSpec , collection . getUncheckedRow ( location ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 354 , 21 + 350 , 14 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public boolean deleteAllFromRealm ( ) { <nl> realm . checkIfValid ( ) ; <nl> if ( size ( ) > 0 ) { <nl> - if ( nativePtr = = 0 ) { <nl> - TableOrView table = getTableOrView ( ) ; <nl> - table . clear ( ) ; <nl> - } else { <nl> - nativeClear ( nativePtr ) ; <nl> - } <nl> - return true ; <nl> - } else { <nl> - return false ; <nl> + collection . clear ( ) ; <nl> } <nl> + return false ; <nl> } <nl> <nl> / * * <nl> * Returns an iterator for the results of a query . Any change to Realm while iterating will cause this iterator to <nl> - * throw a { @ link java . util . ConcurrentModificationException } if accessed . <nl> + * throw a { @ link ConcurrentModificationException } if accessed . <nl> * <nl> * @ return an iterator on the elements of this list . <nl> * @ see Iterator <nl> @ @ - 384 , 7 + 373 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> <nl> / * * <nl> * Returns a list iterator for the results of a query . Any change to Realm while iterating will cause the iterator <nl> - * to throw a { @ link java . util . ConcurrentModificationException } if accessed . <nl> + * to throw a { @ link ConcurrentModificationException } if accessed . <nl> * <nl> * @ return a ListIterator on the elements of this list . <nl> * @ see ListIterator <nl> @ @ - 400 , 7 + 389 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> <nl> / * * <nl> * Returns a list iterator on the results of a query . Any change to Realm while iterating will cause the iterator to <nl> - * throw a { @ link java . util . ConcurrentModificationException } if accessed . <nl> + * throw a { @ link ConcurrentModificationException } if accessed . <nl> * <nl> * @ param location the index at which to start the iteration . <nl> * @ return a ListIterator on the elements of this list . <nl> @ @ - 438 , 12 + 427 , 15 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Override <nl> public RealmResults < E > sort ( String fieldName ) { <nl> + / * <nl> if ( nativePtr = = 0 ) { <nl> return this . sort ( fieldName , Sort . ASCENDING ) ; <nl> } else { <nl> long ptr = nativeSort ( nativePtr , new long [ ] { getColumnIndexForSort ( fieldName ) } , new boolean [ ] { Sort . ASCENDING . getValue ( ) } ) ; <nl> return new RealmResults < E > ( realm , className , ptr ) ; <nl> } <nl> + * / <nl> + return null ; <nl> } <nl> <nl> / * * <nl> @ @ - 451 , 12 + 443 , 15 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Override <nl> public RealmResults < E > sort ( String fieldName , Sort sortOrder ) { <nl> + / * <nl> if ( nativePtr = = 0 ) { <nl> return where ( ) . findAllSorted ( fieldName , sortOrder ) ; <nl> } else { <nl> long ptr = nativeSort ( nativePtr , new long [ ] { getColumnIndexForSort ( fieldName ) } , new boolean [ ] { sortOrder = = Sort . ASCENDING } ) ; <nl> return new RealmResults < E > ( realm , className , ptr ) ; <nl> } <nl> + * / <nl> + return null ; <nl> } <nl> <nl> / * * <nl> @ @ - 464 , 6 + 459 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Override <nl> public RealmResults < E > sort ( String fieldNames [ ] , Sort sortOrders [ ] ) { <nl> + / * <nl> if ( nativePtr = = 0 ) { <nl> return where ( ) . findAllSorted ( fieldNames , sortOrders ) ; <nl> } else { <nl> @ @ - 480 , 6 + 476 , 8 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> long ptr = nativeSort ( nativePtr , columnIndices , orders ) ; <nl> return new RealmResults < E > ( realm , className , ptr ) ; <nl> } <nl> + * / <nl> + return null ; <nl> } <nl> <nl> / * * <nl> @ @ - 501 , 15 + 499 , 9 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public int size ( ) { <nl> if ( ! isLoaded ( ) ) { <nl> return 0 ; <nl> - } else { <nl> - long size ; <nl> - if ( nativePtr = = 0 ) { <nl> - size = getTableOrView ( ) . size ( ) ; <nl> - } else { <nl> - size = nativeSize ( nativePtr ) ; <nl> - } <nl> - return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; <nl> } <nl> + <nl> + return collection . size ( ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 518 , 20 + 510 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public Number min ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - if ( nativePtr = = 0 ) { <nl> - switch ( table . getColumnType ( columnIndex ) ) { <nl> - case INTEGER : <nl> - return table . minimumLong ( columnIndex ) ; <nl> - case FLOAT : <nl> - return table . minimumFloat ( columnIndex ) ; <nl> - case DOUBLE : <nl> - return table . minimumDouble ( columnIndex ) ; <nl> - default : <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> - } <nl> - } else { <nl> - return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MINIMUM ) ; <nl> - } <nl> + return ( Number ) collection . aggregate ( io . realm . internal . Collection . Aggregate . MINIMUM , columnIndex ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 540 , 15 + 519 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public Date minDate ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - if ( nativePtr = = 0 ) { <nl> - if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { <nl> - return table . minimumDate ( columnIndex ) ; <nl> - } else { <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; <nl> - } <nl> - } else { <nl> - return ( Date ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MINIMUM ) ; <nl> - } <nl> + return ( Date ) collection . aggregate ( Collection . Aggregate . MINIMUM , columnIndex ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 557 , 20 + 528 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public Number max ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - if ( nativePtr = = 0 ) { <nl> - switch ( table . getColumnType ( columnIndex ) ) { <nl> - case INTEGER : <nl> - return table . maximumLong ( columnIndex ) ; <nl> - case FLOAT : <nl> - return table . maximumFloat ( columnIndex ) ; <nl> - case DOUBLE : <nl> - return table . maximumDouble ( columnIndex ) ; <nl> - default : <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> - } <nl> - } else { <nl> - return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MAXIMUM ) ; <nl> - } <nl> + return ( Number ) collection . aggregate ( Collection . Aggregate . MAXIMUM , columnIndex ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 581 , 20 + 539 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * @ return if no objects exist or they all have { @ code null } as the value for the given date field , { @ code null } <nl> * will be returned . Otherwise the maximum date is returned . When determining the maximum date , objects with <nl> * { @ code null } values are ignored . <nl> - * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . <nl> + * @ throws IllegalArgumentException if fieldName is not a Date field . <nl> * / <nl> public Date maxDate ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - if ( nativePtr = = 0 ) { <nl> - if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { <nl> - return table . maximumDate ( columnIndex ) ; <nl> - } else { <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; <nl> - } <nl> - } else { <nl> - return ( Date ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MAXIMUM ) ; <nl> - } <nl> + return ( Date ) collection . aggregate ( Collection . Aggregate . MAXIMUM , columnIndex ) ; <nl> } <nl> <nl> <nl> @ @ - 604 , 20 + 554 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public Number sum ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - if ( nativePtr = = 0 ) { <nl> - switch ( table . getColumnType ( columnIndex ) ) { <nl> - case INTEGER : <nl> - return table . sumLong ( columnIndex ) ; <nl> - case FLOAT : <nl> - return table . sumFloat ( columnIndex ) ; <nl> - case DOUBLE : <nl> - return table . sumDouble ( columnIndex ) ; <nl> - default : <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> - } <nl> - } else { <nl> - return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ SUM ) ; <nl> - } <nl> + return ( Number ) collection . aggregate ( Collection . Aggregate . SUM , columnIndex ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 626 , 22 + 563 , 10 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> public double average ( String fieldName ) { <nl> realm . checkIfValid ( ) ; <nl> long columnIndex = getColumnIndexForSort ( fieldName ) ; <nl> - if ( nativePtr = = 0 ) { <nl> - switch ( table . getColumnType ( columnIndex ) ) { <nl> - case INTEGER : <nl> - return table . averageLong ( columnIndex ) ; <nl> - case DOUBLE : <nl> - return table . averageDouble ( columnIndex ) ; <nl> - case FLOAT : <nl> - return table . averageFloat ( columnIndex ) ; <nl> - default : <nl> - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; <nl> - } <nl> - } else { <nl> - / / FIXME : Should we change return type to Double ? <nl> - Number sum = ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ AVERAGE ) ; <nl> - return sum . doubleValue ( ) ; <nl> - } <nl> + <nl> + / / FIXME : Should we change return type to Double ? <nl> + Number sum = ( Number ) collection . aggregate ( Collection . Aggregate . AVERAGE , columnIndex ) ; <nl> + return sum . doubleValue ( ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 674 , 7 + 599 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * <nl> * @ param fieldName the field name . <nl> * @ return immediately a { @ link RealmResults } . Users need to register a listener <nl> - * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the <nl> + * { @ link RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the <nl> * query completes . <nl> * @ throws IllegalArgumentException if a field is null , does not exist , is an unsupported type , <nl> * is not indexed , or points to linked fields . <nl> @ @ - 730 , 7 + 655 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Deprecated <nl> @ Override <nl> - public boolean removeAll ( Collection < ? > collection ) { <nl> + public boolean removeAll ( java . util . Collection < ? > collection ) { <nl> throw new UnsupportedOperationException ( NOT _ SUPPORTED _ MESSAGE ) ; <nl> } <nl> <nl> @ @ - 754 , 7 + 679 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Deprecated <nl> @ Override <nl> - public boolean retainAll ( Collection < ? > collection ) { <nl> + public boolean retainAll ( java . util . Collection < ? > collection ) { <nl> throw new UnsupportedOperationException ( NOT _ SUPPORTED _ MESSAGE ) ; <nl> } <nl> <nl> @ @ - 845 , 7 + 770 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Override <nl> @ Deprecated <nl> - public boolean addAll ( int location , Collection < ? extends E > collection ) { <nl> + public boolean addAll ( int location , java . util . Collection < ? extends E > collection ) { <nl> throw new UnsupportedOperationException ( NOT _ SUPPORTED _ MESSAGE ) ; <nl> } <nl> <nl> @ @ - 856 , 7 + 781 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> * / <nl> @ Deprecated <nl> @ Override <nl> - public boolean addAll ( Collection < ? extends E > collection ) { <nl> + public boolean addAll ( java . util . Collection < ? extends E > collection ) { <nl> throw new UnsupportedOperationException ( NOT _ SUPPORTED _ MESSAGE ) ; <nl> } <nl> <nl> @ @ - 1085 , 7 + 1010 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> } <nl> realm . checkIfValid ( ) ; <nl> if ( listeners . isEmpty ( ) ) { <nl> - nativeAddListener ( nativePtr ) ; <nl> + / / nativeAddListener ( nativePtr ) ; <nl> } <nl> if ( ! listeners . contains ( listener ) ) { <nl> listeners . add ( listener ) ; <nl> @ @ - 1174 , 22 + 1099 , 4 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im <nl> } <nl> } <nl> } <nl> - <nl> - void notifyChangeListeners ( ) { <nl> - if ( ! listeners . isEmpty ( ) ) { <nl> - for ( RealmChangeListener listener : listeners ) { <nl> - listener . onChange ( this ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - private static native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , long [ ] columnIndices , boolean [ ] orders ) ; <nl> - private static native long nativeCreateSnapshot ( long nativePtr ) ; <nl> - private static native long nativeGetRow ( long nativePtr , int index ) ; <nl> - private static native boolean nativeContains ( long nativePtr , long nativeRowPtr ) ; <nl> - private static native void nativeClear ( long nativePtr ) ; <nl> - private static native long nativeSize ( long nativePtr ) ; <nl> - private static native Object nativeAggregate ( long nativePtr , long columnIndex , byte aggregateFunc ) ; <nl> - private static native long nativeSort ( long nativePtr , long [ ] columnIndices , boolean [ ] orders ) ; <nl> - private native long nativeAddListener ( long nativePtr ) ; <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / Collection . java b / realm / realm - library / src / main / java / io / realm / internal / Collection . java <nl> index b227851 . . be3c35d 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / Collection . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / Collection . java <nl> @ @ - 16 , 7 + 16 , 13 @ @ <nl> <nl> package io . realm . internal ; <nl> <nl> + import io . realm . RealmChangeListener ; <nl> + <nl> public class Collection implements NativeObject { <nl> + <nl> + public interface Listener { <nl> + void onChange ( ) ; <nl> + } <nl> <nl> private final long nativePtr ; <nl> private static final long nativeFinalizerPtr = nativeGetFinalizerPtr ( ) ; <nl> @ @ - 29 , 6 + 35 , 23 @ @ public class Collection implements NativeObject { <nl> public static final byte AGGREGATE _ FUNCTION _ AVERAGE = 3 ; <nl> public static final byte AGGREGATE _ FUNCTION _ SUM = 4 ; <nl> <nl> + public enum Aggregate { <nl> + MINIMUM ( AGGREGATE _ FUNCTION _ MINIMUM ) , <nl> + MAXIMUM ( AGGREGATE _ FUNCTION _ MAXIMUM ) , <nl> + AVERAGE ( AGGREGATE _ FUNCTION _ AVERAGE ) , <nl> + SUM ( AGGREGATE _ FUNCTION _ SUM ) ; <nl> + <nl> + private final byte value ; <nl> + <nl> + Aggregate ( byte value ) { <nl> + this . value = value ; <nl> + } <nl> + <nl> + public byte getValue ( ) { <nl> + return value ; <nl> + } <nl> + } <nl> + <nl> protected Collection ( SharedRealm sharedRealm , TableQuery query , long indices [ ] , boolean [ ] orders ) { <nl> this . context = sharedRealm . context ; <nl> this . query = query ; <nl> @ @ - 46 , 6 + 69 , 23 @ @ public class Collection implements NativeObject { <nl> return nativeFinalizerPtr ; <nl> } <nl> <nl> + public UncheckedRow getUncheckedRow ( int index ) { <nl> + return UncheckedRow . getByRowPointer ( query . table , nativeGetRow ( nativePtr , index ) ) ; <nl> + } <nl> + <nl> + public Object aggregate ( Aggregate aggregateMethod , long columnIndex ) { <nl> + return nativeAggregate ( nativePtr , columnIndex , aggregateMethod . getValue ( ) ) ; <nl> + } <nl> + <nl> + public int size ( ) { <nl> + long size = nativeSize ( nativePtr ) ; <nl> + return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; <nl> + } <nl> + <nl> + public void clear ( ) { <nl> + nativeClear ( nativePtr ) ; <nl> + } <nl> + <nl> private static native long nativeGetFinalizerPtr ( ) ; <nl> private static native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , long [ ] columnIndices , <nl> boolean [ ] orders ) ;
NEAREST DIFF (one line): diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> index a21bc7c . . 3eceee2 100644 <nl> - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> @ @ - 257 , 7 + 257 , 7 @ @ public class RealmProxyClassGenerator { <nl> writer . emitAnnotation ( " Override " ) ; <nl> writer . beginMethod ( fieldTypeCanonicalName , getters . get ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) ) ; <nl> writer . emitStatement ( <nl> - " realm . assertThread ( ) " <nl> + " realm . checkIfValid ( ) " <nl> ) ; <nl> writer . emitStatement ( <nl> " return ( % s ) row . get % s ( Realm . columnIndices . get ( \ " % s \ " ) . get ( \ " % s \ " ) ) " , <nl> @ @ - 269 , 7 + 269 , 7 @ @ public class RealmProxyClassGenerator { <nl> writer . emitAnnotation ( " Override " ) ; <nl> writer . beginMethod ( " void " , setters . get ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) , fieldTypeCanonicalName , " value " ) ; <nl> writer . emitStatement ( <nl> - " realm . assertThread ( ) " <nl> + " realm . checkIfValid ( ) " <nl> ) ; <nl> writer . emitStatement ( <nl> " row . set % s ( Realm . columnIndices . get ( \ " % s \ " ) . get ( \ " % s \ " ) , ( % s ) value ) " , <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index 83d7439 . . 392eb74 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 16 , 12 + 16 , 14 @ @ <nl> <nl> package io . realm ; <nl> <nl> + import android . annotation . SuppressLint ; <nl> import android . content . Context ; <nl> import android . os . Handler ; <nl> import android . os . Looper ; <nl> import android . os . Message ; <nl> import android . util . Log ; <nl> <nl> + import java . io . Closeable ; <nl> import java . io . File ; <nl> import java . lang . reflect . Constructor ; <nl> import java . lang . reflect . InvocationTargetException ; <nl> @ @ - 69 , 21 + 71 , 30 @ @ import io . realm . internal . Table ; <nl> * thread . start ( ) ; <nl> * < / pre > <nl> * / <nl> - public class Realm { <nl> + public class Realm implements Closeable { <nl> public static final String DEFAULT _ REALM _ NAME = " default . realm " ; <nl> <nl> private static final String TAG = " REALM " ; <nl> private static final String TABLE _ PREFIX = " class _ " ; <nl> protected static final ThreadLocal < Map < Integer , Realm > > realmsCache = new ThreadLocal < Map < Integer , Realm > > ( ) { <nl> + @ SuppressLint ( " UseSparseArrays " ) <nl> @ Override <nl> protected Map < Integer , Realm > initialValue ( ) { <nl> - return new HashMap < Integer , Realm > ( ) ; <nl> + return new HashMap < Integer , Realm > ( ) ; / / On Android we could use SparseArray < Realm > which is faster , <nl> + / / but incompatible with Java <nl> + } <nl> + } ; <nl> + private static final ThreadLocal < Integer > referenceCount = new ThreadLocal < Integer > ( ) { <nl> + @ Override <nl> + protected Integer initialValue ( ) { <nl> + return 1 ; <nl> } <nl> } ; <nl> private static final int REALM _ CHANGED = 14930352 ; / / Just a nice big Fibonacci number . For no reason : ) <nl> private static final Map < Handler , Integer > handlers = new ConcurrentHashMap < Handler , Integer > ( ) ; <nl> private static final String APT _ NOT _ EXECUTED _ MESSAGE = " Annotation processor may not have been executed . " ; <nl> private static final String INCORRECT _ THREAD _ MESSAGE = " Realm access from incorrect thread . Realm objects can only be accessed on the thread they where created . " ; <nl> + private static final String CLOSED _ REALM = " This Realm instance has already been closed , making it unusable . " ; <nl> <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> private static SharedGroup . Durability defaultDurability = SharedGroup . Durability . FULL ; <nl> @ @ - 91 , 7 + 102 , 7 @ @ public class Realm { <nl> private Handler handler ; <nl> <nl> private final int id ; <nl> - private final SharedGroup sharedGroup ; <nl> + private SharedGroup sharedGroup ; <nl> private final ImplicitTransaction transaction ; <nl> private final Map < Class < ? > , String > simpleClassNames = new HashMap < Class < ? > , String > ( ) ; <nl> private final Map < String , Class < ? > > generatedClasses = new HashMap < String , Class < ? > > ( ) ; <nl> @ @ - 105 , 8 + 116 , 15 @ @ public class Realm { <nl> / / Package protected to be reachable by proxy classes <nl> static final Map < String , Map < String , Long > > columnIndices = new HashMap < String , Map < String , Long > > ( ) ; <nl> <nl> - protected void assertThread ( ) { <nl> - if ( realmsCache . get ( ) . get ( this . id ) ! = this ) { <nl> + protected void checkIfValid ( ) { <nl> + / / Check if the Realm instance has been closed <nl> + if ( sharedGroup = = null ) { <nl> + throw new IllegalStateException ( CLOSED _ REALM ) ; <nl> + } <nl> + <nl> + / / Check if we are in the right thread <nl> + Realm currentRealm = realmsCache . get ( ) . get ( this . id ) ; <nl> + if ( currentRealm ! = null & & currentRealm ! = this ) { <nl> throw new IllegalStateException ( INCORRECT _ THREAD _ MESSAGE ) ; <nl> } <nl> } <nl> @ @ - 121 , 10 + 139 , 26 @ @ public class Realm { <nl> <nl> @ Override <nl> protected void finalize ( ) throws Throwable { <nl> - transaction . endRead ( ) ; <nl> + this . close ( ) ; <nl> super . finalize ( ) ; <nl> } <nl> <nl> + / * * <nl> + * Closes the Realm instance and all its resources . It ' s important to always remember to close Realm instances <nl> + * when you ' re done with it in order not to leak memory , file descriptors or grow the size of Realm files out of <nl> + * measure . <nl> + * / <nl> + @ Override <nl> + public void close ( ) { <nl> + int references = referenceCount . get ( ) ; <nl> + if ( sharedGroup ! = null & & references = = 1 ) { <nl> + realmsCache . get ( ) . remove ( id ) ; <nl> + sharedGroup . close ( ) ; <nl> + sharedGroup = null ; <nl> + } <nl> + referenceCount . set ( references - 1 ) ; <nl> + } <nl> + <nl> private class RealmCallback implements Handler . Callback { <nl> @ Override <nl> public boolean handleMessage ( Message message ) { <nl> @ @ - 365 , 16 + 399 , 21 @ @ public class Realm { <nl> <nl> @ SuppressWarnings ( " unchecked " ) <nl> private static Realm createAndValidate ( String absolutePath , byte [ ] key , boolean validateSchema , boolean autoRefresh ) { <nl> + int references = referenceCount . get ( ) ; <nl> Map < Integer , Realm > realms = realmsCache . get ( ) ; <nl> Realm realm = realms . get ( absolutePath . hashCode ( ) ) ; <nl> <nl> if ( realm ! = null ) { <nl> + referenceCount . set ( references + 1 ) ; <nl> return realm ; <nl> } <nl> <nl> realm = new Realm ( absolutePath , key , autoRefresh ) ; <nl> - realms . put ( absolutePath . hashCode ( ) , realm ) ; <nl> - realmsCache . set ( realms ) ; <nl> + <nl> + if ( autoRefresh ) { <nl> + realms . put ( absolutePath . hashCode ( ) , realm ) ; <nl> + realmsCache . set ( realms ) ; <nl> + } <nl> <nl> if ( validateSchema ) { <nl> Class < ? > validationClass ; <nl> @ @ - 484 , 6 + 523 , 7 @ @ public class Realm { <nl> } <nl> } <nl> <nl> + referenceCount . set ( references + 1 ) ; <nl> return realm ; <nl> } <nl> <nl> @ @ - 652 , 7 + 692 , 7 @ @ public class Realm { <nl> * @ see io . realm . RealmChangeListener <nl> * / <nl> public void addChangeListener ( RealmChangeListener listener ) { <nl> - assertThread ( ) ; <nl> + checkIfValid ( ) ; <nl> changeListeners . add ( listener ) ; <nl> } <nl> <nl> @ @ - 663 , 7 + 703 , 7 @ @ public class Realm { <nl> * @ see io . realm . RealmChangeListener <nl> * / <nl> public void removeChangeListener ( RealmChangeListener listener ) { <nl> - assertThread ( ) ; <nl> + checkIfValid ( ) ; <nl> changeListeners . remove ( listener ) ; <nl> } <nl> <nl> @ @ - 673 , 7 + 713 , 7 @ @ public class Realm { <nl> * @ see io . realm . RealmChangeListener <nl> * / <nl> public void removeAllChangeListeners ( ) { <nl> - assertThread ( ) ; <nl> + checkIfValid ( ) ; <nl> changeListeners . clear ( ) ; <nl> } <nl> <nl> @ @ - 697 , 7 + 737 , 7 @ @ public class Realm { <nl> * / <nl> @ SuppressWarnings ( " UnusedDeclaration " ) <nl> public void refresh ( ) { <nl> - assertThread ( ) ; <nl> + checkIfValid ( ) ; <nl> transaction . advanceRead ( ) ; <nl> } <nl> <nl> @ @ - 716 , 7 + 756 , 7 @ @ public class Realm { <nl> * <nl> * / <nl> public void beginTransaction ( ) { <nl> - assertThread ( ) ; <nl> + checkIfValid ( ) ; <nl> transaction . promoteToWrite ( ) ; <nl> } <nl> <nl> @ @ - 730 , 7 + 770 , 7 @ @ public class Realm { <nl> * @ throws java . lang . IllegalStateException If the write transaction is in an invalid state or incorrect thread . <nl> * / <nl> public void commitTransaction ( ) { <nl> - assertThread ( ) ; <nl> + checkIfValid ( ) ; <nl> transaction . commitAndContinueAsRead ( ) ; <nl> <nl> for ( Map . Entry < Handler , Integer > handlerIntegerEntry : handlers . entrySet ( ) ) { <nl> @ @ - 760 , 7 + 800 , 7 @ @ public class Realm { <nl> * not in a write transaction or incorrect thread . <nl> * / <nl> public void cancelTransaction ( ) { <nl> - assertThread ( ) ; <nl> + checkIfValid ( ) ; <nl> transaction . rollbackAndContinueAsRead ( ) ; <nl> } <nl> <nl> diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java <nl> index 2b6f97c . . c40b37c 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / src / main / java / io / realm / RealmResults . java <nl> @ @ - 83 , 7 + 83 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ see io . realm . RealmQuery <nl> * / <nl> public RealmQuery < E > where ( ) { <nl> - realm . assertThread ( ) ; <nl> + realm . checkIfValid ( ) ; <nl> return new RealmQuery < E > ( this , classSpec ) ; <nl> } <nl> <nl> @ @ - 93 , 7 + 93 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> @ Override <nl> public E get ( int rowIndex ) { <nl> E obj ; <nl> - realm . assertThread ( ) ; <nl> + realm . checkIfValid ( ) ; <nl> TableOrView table = getTable ( ) ; <nl> if ( table instanceof TableView ) { <nl> obj = realm . get ( classSpec , ( ( TableView ) table ) . getSourceRowIndex ( rowIndex ) ) ; <nl> @ @ - 146 , 7 + 146 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> public RealmResults < E > sort ( String fieldName , boolean sortAscending ) { <nl> TableView sorted ; <nl> <nl> - realm . assertThread ( ) ; <nl> + realm . checkIfValid ( ) ; <nl> TableOrView table = getTable ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> TableView . Order TVOrder = sortAscending ? TableView . Order . ascending : TableView . Order . descending ; <nl> @ @ - 184 , 7 + 184 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if field is not int , float or double . <nl> * / <nl> public Number min ( String fieldName ) { <nl> - realm . assertThread ( ) ; <nl> + realm . checkIfValid ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> switch ( table . getColumnType ( columnIndex ) ) { <nl> case INTEGER : <nl> @ @ - 207 , 7 + 207 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . <nl> * / <nl> public Date minDate ( String fieldName ) { <nl> - realm . assertThread ( ) ; <nl> + realm . checkIfValid ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> if ( table . getColumnType ( columnIndex ) = = ColumnType . DATE ) { <nl> return table . minimumDate ( columnIndex ) ; <nl> @ @ - 225 , 7 + 225 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if field is not int , float or double . <nl> * / <nl> public Number max ( String fieldName ) { <nl> - realm . assertThread ( ) ; <nl> + realm . checkIfValid ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> switch ( table . getColumnType ( columnIndex ) ) { <nl> case INTEGER : <nl> @ @ - 248 , 7 + 248 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . <nl> * / <nl> public Date maxDate ( String fieldName ) { <nl> - realm . assertThread ( ) ; <nl> + realm . checkIfValid ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> if ( table . getColumnType ( columnIndex ) = = ColumnType . DATE ) { <nl> return table . maximumDate ( columnIndex ) ; <nl> @ @ - 268 , 7 + 268 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * / <nl> <nl> public Number sum ( String fieldName ) { <nl> - realm . assertThread ( ) ; <nl> + realm . checkIfValid ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> switch ( table . getColumnType ( columnIndex ) ) { <nl> case INTEGER : <nl> @ @ - 293 , 7 + 293 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ throws java . lang . IllegalArgumentException if field is not int , float or double . <nl> * / <nl> public double average ( String fieldName ) { <nl> - realm . assertThread ( ) ; <nl> + realm . checkIfValid ( ) ; <nl> long columnIndex = table . getColumnIndex ( fieldName ) ; <nl> switch ( table . getColumnType ( columnIndex ) ) { <nl> case INTEGER : <nl> diff - - git a / realm / src / main / java / io / realm / internal / SharedGroup . java b / realm / src / main / java / io / realm / internal / SharedGroup . java <nl> index e8b2f0b . . 9afa75c 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / SharedGroup . java <nl> + + + b / realm / src / main / java / io / realm / internal / SharedGroup . java <nl> @ @ - 49 , 6 + 49 , 7 @ @ public class SharedGroup implements Closeable { <nl> this . nativePtr = createNative ( databaseFile , Durability . FULL . value , false , false , null ) ; <nl> checkNativePtrNotZero ( ) ; <nl> } <nl> + <nl> public SharedGroup ( String databaseFile , boolean enableImplicitTransactions , byte [ ] key ) { <nl> if ( enableImplicitTransactions ) { <nl> nativeTransactLogRegistryPtr = nativeCreateTransactLogRegistry ( databaseFile ) ; <nl> @ @ - 73 , 18 + 74 , 20 @ @ public class SharedGroup implements Closeable { <nl> this . nativePtr = createNative ( databaseFile , durability . value , false , false , key ) ; <nl> checkNativePtrNotZero ( ) ; <nl> } <nl> + <nl> public SharedGroup ( String databaseFile , Durability durability , boolean fileMustExist ) { <nl> context = new Context ( ) ; <nl> this . nativePtr = createNative ( databaseFile , durability . value , fileMustExist , false , null ) ; <nl> checkNativePtrNotZero ( ) ; <nl> } <nl> - / * <nl> - SharedGroup ( String databaseFile , Durability durability , boolean no _ create , boolean enableReplication ) { <nl> - context = new Context ( ) ; <nl> - this . nativePtr = createNative ( databaseFile , durability . value , no _ create , enableReplication ) ; <nl> - checkNativePtr ( ) ; <nl> - } <nl> - * / <nl> + <nl> + / * <nl> + SharedGroup ( String databaseFile , Durability durability , boolean no _ create , boolean enableReplication ) { <nl> + context = new Context ( ) ; <nl> + this . nativePtr = createNative ( databaseFile , durability . value , no _ create , enableReplication ) ; <nl> + checkNativePtr ( ) ; <nl> + } <nl> + * / <nl> void advanceRead ( ) { <nl> nativeAdvanceRead ( nativePtr , nativeTransactLogRegistryPtr ) ; <nl> } <nl> @ @ - 103 , 7 + 106 , 9 @ @ public class SharedGroup implements Closeable { <nl> <nl> private native void nativeCommitAndContinueAsRead ( long nativePtr ) ; <nl> <nl> - void rollbackAndContinueAsRead ( ) { nativeRollbackAndContinueAsRead ( nativePtr ) ; } <nl> + void rollbackAndContinueAsRead ( ) { <nl> + nativeRollbackAndContinueAsRead ( nativePtr ) ; <nl> + } <nl> <nl> private native void nativeRollbackAndContinueAsRead ( long nativePtr ) ; <nl> <nl> @ @ - 132 , 8 + 137 , 7 @ @ public class SharedGroup implements Closeable { <nl> WriteTransaction t = new WriteTransaction ( context , this , nativeWritePtr ) ; <nl> activeTransaction = true ; <nl> return t ; <nl> - } <nl> - catch ( RuntimeException e ) { <nl> + } catch ( RuntimeException e ) { <nl> Group . nativeClose ( nativeWritePtr ) ; <nl> throw e ; <nl> } <nl> @ @ - 141 , 8 + 145 , 7 @ @ public class SharedGroup implements Closeable { <nl> <nl> public ReadTransaction beginRead ( ) { <nl> if ( activeTransaction ) <nl> - throw new IllegalStateException ( <nl> - " Can ' t beginRead ( ) during another active transaction " ) ; <nl> + throw new IllegalStateException ( " Can ' t beginRead ( ) during another active transaction " ) ; <nl> / / FIXME : throw from nativeMethod in case of error <nl> <nl> long nativeReadPtr = nativeBeginRead ( nativePtr ) ; <nl> @ @ - 151 , 8 + 154 , 7 @ @ public class SharedGroup implements Closeable { <nl> ReadTransaction t = new ReadTransaction ( context , this , nativeReadPtr ) ; <nl> activeTransaction = true ; <nl> return t ; <nl> - } <nl> - catch ( RuntimeException e ) { <nl> + } catch ( RuntimeException e ) { <nl> Group . nativeClose ( nativeReadPtr ) ; <nl> throw e ; <nl> } <nl> @ @ - 160 , 18 + 162 , 13 @ @ public class SharedGroup implements Closeable { <nl> <nl> void endRead ( ) { <nl> if ( isClosed ( ) ) <nl> - throw new IllegalStateException ( <nl> - " Can ' t endRead ( ) on closed group . ReadTransaction is invalid . " ) ; <nl> + throw new IllegalStateException ( " Can ' t endRead ( ) on closed group . ReadTransaction is invalid . " ) ; <nl> nativeEndRead ( nativePtr ) ; <nl> activeTransaction = false ; <nl> } <nl> <nl> public void close ( ) { <nl> - if ( activeTransaction ) <nl> - throw new IllegalStateException ( <nl> - " Can ' t close the SharedGroup during an active transaction " ) ; <nl> - <nl> - synchronized ( context ) { <nl> + synchronized ( context ) { <nl> if ( nativePtr ! = 0 ) { <nl> nativeClose ( nativePtr ) ; <nl> nativePtr = 0 ; <nl> @ @ - 192 , 7 + 189 , 7 @ @ public class SharedGroup implements Closeable { <nl> protected void finalize ( ) { <nl> synchronized ( context ) { <nl> if ( nativePtr ! = 0 ) { <nl> - context . asyncDisposeSharedGroup ( nativePtr ) ; <nl> + context . asyncDisposeSharedGroup ( nativePtr ) ; <nl> nativePtr = 0 ; / / Set to 0 if finalize is called before close ( ) for some reason <nl> if ( implicitTransactionsEnabled ) { <nl> if ( nativeTransactLogRegistryPtr ! = 0 ) { <nl> @ @ - 254 , 10 + 251 , 10 @ @ public class SharedGroup implements Closeable { <nl> private native void nativeRollback ( long nativePtr ) ; <nl> <nl> private native long createNative ( String databaseFile , <nl> - int durabilityValue , <nl> - boolean no _ create , <nl> - boolean enableReplication , <nl> - byte [ ] key ) ; <nl> + int durabilityValue , <nl> + boolean no _ create , <nl> + boolean enableReplication , <nl> + byte [ ] key ) ; <nl> <nl> private void checkNativePtrNotZero ( ) { <nl> if ( this . nativePtr = = 0 ) <nl> @ @ - 265 , 7 + 262 , 9 @ @ public class SharedGroup implements Closeable { <nl> } <nl> <nl> protected static native void nativeClose ( long nativePtr ) ; <nl> + <nl> private native void nativeCloseTransactRegistryLog ( long nativeTransactLogRegistryPtr ) ; <nl> + <nl> private native void nativeCloseReplication ( long nativeReplicationPtr ) ; <nl> <nl> }

TEST DIFF:
diff - - git a / realm / realm - library / src / main / java / io / realm / BaseRealm . java b / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 index 6e5dc1c . . a32f249 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 @ @ - 506 , 9 + 506 , 7 @ @ abstract class BaseRealm implements Closeable { 
 } 
 
 / / FIXME : Testing code 
 - < E extends RealmModel > E get ( Class < E > clazz , long rowPtr ) { 
 - Table table = schema . getTable ( clazz ) ; 
 - UncheckedRow row = UncheckedRow . getByRowPointer ( table , rowPtr ) ; 
 + < E extends RealmModel > E get ( Class < E > clazz , Row row ) { 
 
 E result = configuration . getSchemaMediator ( ) . newInstance ( clazz , this , row , schema . getColumnInfo ( clazz ) , 
 false , Collections . < String > emptyList ( ) ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 index 3d2bf45 . . 2c4e578 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 @ @ - 18 , 9 + 18 , 9 @ @ package io . realm ; 
 
 
 import android . app . IntentService ; 
 + import android . os . Looper ; 
 
 import java . util . AbstractList ; 
 - import java . util . Collection ; 
 import java . util . Collections ; 
 import java . util . ConcurrentModificationException ; 
 import java . util . Date ; 
 @ @ - 31 , 24 + 31 , 21 @ @ import java . util . NoSuchElementException ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . Future ; 
 
 - import io . realm . internal . CheckedRow ; 
 - import io . realm . internal . InvalidRow ; 
 - import io . realm . internal . RealmObjectProxy ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableOrView ; 
 import io . realm . internal . TableQuery ; 
 import io . realm . internal . TableView ; 
 - import io . realm . internal . UncheckedRow ; 
 + import io . realm . internal . Collection ; 
 import io . realm . internal . async . BadVersionException ; 
 import io . realm . log . RealmLog ; 
 import rx . Observable ; 
 
 / * * 
 - * This class holds all the matches of a { @ link io . realm . RealmQuery } for a given Realm . The objects are not copied from 
 + * This class holds all the matches of a { @ link RealmQuery } for a given Realm . The objects are not copied from 
 * the Realm to the RealmResults list , but are just referenced from the RealmResult instead . This saves memory and 
 * increases speed . 
 * < p > 
 - * RealmResults are live views , which means that if it is on an { @ link android . os . Looper } thread , it will automatically 
 + * RealmResults are live views , which means that if it is on an { @ link Looper } thread , it will automatically 
 * update its query results after a transaction has been committed . If on a non - looper thread , { @ link Realm # waitForChange ( ) } 
 * must be called to update the results . 
 * < p > 
 @ @ - 68 , 7 + 65 , 7 @ @ import rx . Observable ; 
 * 
 * @ param < E > The class of objects in this list . 
 * @ see RealmQuery # findAll ( ) 
 - * @ see io . realm . Realm # executeTransaction ( Realm . Transaction ) 
 + * @ see Realm # executeTransaction ( Realm . Transaction ) 
 * / 
 public final class RealmResults < E extends RealmModel > extends AbstractList < E > implements OrderedRealmCollection < E > { 
 
 @ @ - 84 , 6 + 81 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 
 private long currentTableViewVersion = TABLE _ VIEW _ VERSION _ NONE ; 
 private final TableQuery query ; 
 + private final io . realm . internal . Collection collection ; 
 private final List < RealmChangeListener < RealmResults < E > > > listeners = new CopyOnWriteArrayList < RealmChangeListener < RealmResults < E > > > ( ) ; 
 private Future < Long > pendingQuery ; 
 private boolean asyncQueryCompleted = false ; 
 @ @ - 91 , 8 + 89 , 6 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 / / clear it . 
 private boolean viewUpdated = false ; 
 
 - private final long nativePtr ; 
 - 
 / / Public for static checking in JNI 
 public static final byte AGGREGATE _ FUNCTION _ MINIMUM = 1 ; 
 public static final byte AGGREGATE _ FUNCTION _ MAXIMUM = 2 ; 
 @ @ - 124 , 6 + 120 , 13 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 return realmResults ; 
 } 
 
 + RealmResults ( BaseRealm realm , io . realm . internal . Collection collection , Class < E > clazz ) { 
 + this . realm = realm ; 
 + this . query = null ; 
 + this . classSpec = clazz ; 
 + this . collection = collection ; 
 + } 
 + 
 private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz , String fieldNames [ ] , Sort [ ] sortOrder ) { 
 this . realm = realm ; 
 this . classSpec = clazz ; 
 @ @ - 144 , 21 + 147 , 21 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 } 
 } 
 
 - this . nativePtr = nativeCreateResults ( realm . sharedRealm . getNativePtr ( ) , query . getNativePtr ( ) , indices , order ) ; 
 + collection = null ; 
 } 
 
 private RealmResults ( BaseRealm realm , TableQuery query , Class < E > clazz ) { 
 this . realm = realm ; 
 this . classSpec = clazz ; 
 this . query = query ; 
 - this . nativePtr = 0 ; 
 + collection = null ; 
 } 
 
 private RealmResults ( BaseRealm realm , TableQuery query , String className ) { 
 this . realm = realm ; 
 this . query = query ; 
 this . className = className ; 
 - this . nativePtr = 0 ; 
 + collection = null ; 
 } 
 
 private RealmResults ( BaseRealm realm , TableOrView table , Class < E > classSpec ) { 
 @ @ - 169 , 7 + 172 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 this . pendingQuery = null ; 
 this . query = null ; 
 this . currentTableViewVersion = table . syncIfNeeded ( ) ; 
 - this . nativePtr = 0 ; 
 + collection = null ; 
 } 
 
 private RealmResults ( BaseRealm realm , String className ) { 
 @ @ - 178 , 7 + 181 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 
 pendingQuery = null ; 
 query = null ; 
 - this . nativePtr = 0 ; 
 + collection = null ; 
 } 
 
 private RealmResults ( BaseRealm realm , TableOrView table , String className ) { 
 @ @ - 190 , 8 + 193 , 8 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 private RealmResults ( BaseRealm realm , String className , long nativePtr ) { 
 this . realm = realm ; 
 this . className = className ; 
 - this . nativePtr = nativePtr ; 
 this . query = null ; 
 + collection = null ; 
 } 
 
 TableOrView getTableOrView ( ) { 
 @ @ - 237 , 6 + 240 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Override 
 public boolean contains ( Object object ) { 
 + / * 
 boolean contains = false ; 
 if ( isLoaded ( ) & & object instanceof RealmObjectProxy ) { 
 RealmObjectProxy proxy = ( RealmObjectProxy ) object ; 
 @ @ - 255 , 6 + 259 , 8 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 } 
 } 
 return contains ; 
 + * / 
 + return false ; 
 } 
 
 / * * 
 @ @ - 266 , 18 + 272 , 8 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Override 
 public E get ( int location ) { 
 - E obj ; 
 realm . checkIfValid ( ) ; 
 - / * 
 - TableOrView table = getTableOrView ( ) ; 
 - if ( table instanceof TableView ) { 
 - obj = realm . get ( classSpec , className , ( ( TableView ) table ) . getSourceRowIndex ( location ) ) ; 
 - } else { 
 - obj = realm . get ( classSpec , className , location ) ; 
 - } 
 - * / 
 - long rowPtr = nativeGetRow ( nativePtr , location ) ; 
 - return realm . get ( classSpec , rowPtr ) ; 
 + return realm . get ( classSpec , collection . getUncheckedRow ( location ) ) ; 
 } 
 
 / * * 
 @ @ - 354 , 21 + 350 , 14 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public boolean deleteAllFromRealm ( ) { 
 realm . checkIfValid ( ) ; 
 if ( size ( ) > 0 ) { 
 - if ( nativePtr = = 0 ) { 
 - TableOrView table = getTableOrView ( ) ; 
 - table . clear ( ) ; 
 - } else { 
 - nativeClear ( nativePtr ) ; 
 - } 
 - return true ; 
 - } else { 
 - return false ; 
 + collection . clear ( ) ; 
 } 
 + return false ; 
 } 
 
 / * * 
 * Returns an iterator for the results of a query . Any change to Realm while iterating will cause this iterator to 
 - * throw a { @ link java . util . ConcurrentModificationException } if accessed . 
 + * throw a { @ link ConcurrentModificationException } if accessed . 
 * 
 * @ return an iterator on the elements of this list . 
 * @ see Iterator 
 @ @ - 384 , 7 + 373 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 
 / * * 
 * Returns a list iterator for the results of a query . Any change to Realm while iterating will cause the iterator 
 - * to throw a { @ link java . util . ConcurrentModificationException } if accessed . 
 + * to throw a { @ link ConcurrentModificationException } if accessed . 
 * 
 * @ return a ListIterator on the elements of this list . 
 * @ see ListIterator 
 @ @ - 400 , 7 + 389 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 
 / * * 
 * Returns a list iterator on the results of a query . Any change to Realm while iterating will cause the iterator to 
 - * throw a { @ link java . util . ConcurrentModificationException } if accessed . 
 + * throw a { @ link ConcurrentModificationException } if accessed . 
 * 
 * @ param location the index at which to start the iteration . 
 * @ return a ListIterator on the elements of this list . 
 @ @ - 438 , 12 + 427 , 15 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Override 
 public RealmResults < E > sort ( String fieldName ) { 
 + / * 
 if ( nativePtr = = 0 ) { 
 return this . sort ( fieldName , Sort . ASCENDING ) ; 
 } else { 
 long ptr = nativeSort ( nativePtr , new long [ ] { getColumnIndexForSort ( fieldName ) } , new boolean [ ] { Sort . ASCENDING . getValue ( ) } ) ; 
 return new RealmResults < E > ( realm , className , ptr ) ; 
 } 
 + * / 
 + return null ; 
 } 
 
 / * * 
 @ @ - 451 , 12 + 443 , 15 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Override 
 public RealmResults < E > sort ( String fieldName , Sort sortOrder ) { 
 + / * 
 if ( nativePtr = = 0 ) { 
 return where ( ) . findAllSorted ( fieldName , sortOrder ) ; 
 } else { 
 long ptr = nativeSort ( nativePtr , new long [ ] { getColumnIndexForSort ( fieldName ) } , new boolean [ ] { sortOrder = = Sort . ASCENDING } ) ; 
 return new RealmResults < E > ( realm , className , ptr ) ; 
 } 
 + * / 
 + return null ; 
 } 
 
 / * * 
 @ @ - 464 , 6 + 459 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Override 
 public RealmResults < E > sort ( String fieldNames [ ] , Sort sortOrders [ ] ) { 
 + / * 
 if ( nativePtr = = 0 ) { 
 return where ( ) . findAllSorted ( fieldNames , sortOrders ) ; 
 } else { 
 @ @ - 480 , 6 + 476 , 8 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 long ptr = nativeSort ( nativePtr , columnIndices , orders ) ; 
 return new RealmResults < E > ( realm , className , ptr ) ; 
 } 
 + * / 
 + return null ; 
 } 
 
 / * * 
 @ @ - 501 , 15 + 499 , 9 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public int size ( ) { 
 if ( ! isLoaded ( ) ) { 
 return 0 ; 
 - } else { 
 - long size ; 
 - if ( nativePtr = = 0 ) { 
 - size = getTableOrView ( ) . size ( ) ; 
 - } else { 
 - size = nativeSize ( nativePtr ) ; 
 - } 
 - return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; 
 } 
 + 
 + return collection . size ( ) ; 
 } 
 
 / * * 
 @ @ - 518 , 20 + 510 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public Number min ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - if ( nativePtr = = 0 ) { 
 - switch ( table . getColumnType ( columnIndex ) ) { 
 - case INTEGER : 
 - return table . minimumLong ( columnIndex ) ; 
 - case FLOAT : 
 - return table . minimumFloat ( columnIndex ) ; 
 - case DOUBLE : 
 - return table . minimumDouble ( columnIndex ) ; 
 - default : 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 - } 
 - } else { 
 - return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MINIMUM ) ; 
 - } 
 + return ( Number ) collection . aggregate ( io . realm . internal . Collection . Aggregate . MINIMUM , columnIndex ) ; 
 } 
 
 / * * 
 @ @ - 540 , 15 + 519 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public Date minDate ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - if ( nativePtr = = 0 ) { 
 - if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { 
 - return table . minimumDate ( columnIndex ) ; 
 - } else { 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; 
 - } 
 - } else { 
 - return ( Date ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MINIMUM ) ; 
 - } 
 + return ( Date ) collection . aggregate ( Collection . Aggregate . MINIMUM , columnIndex ) ; 
 } 
 
 / * * 
 @ @ - 557 , 20 + 528 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public Number max ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - if ( nativePtr = = 0 ) { 
 - switch ( table . getColumnType ( columnIndex ) ) { 
 - case INTEGER : 
 - return table . maximumLong ( columnIndex ) ; 
 - case FLOAT : 
 - return table . maximumFloat ( columnIndex ) ; 
 - case DOUBLE : 
 - return table . maximumDouble ( columnIndex ) ; 
 - default : 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 - } 
 - } else { 
 - return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MAXIMUM ) ; 
 - } 
 + return ( Number ) collection . aggregate ( Collection . Aggregate . MAXIMUM , columnIndex ) ; 
 } 
 
 / * * 
 @ @ - 581 , 20 + 539 , 12 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * @ return if no objects exist or they all have { @ code null } as the value for the given date field , { @ code null } 
 * will be returned . Otherwise the maximum date is returned . When determining the maximum date , objects with 
 * { @ code null } values are ignored . 
 - * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . 
 + * @ throws IllegalArgumentException if fieldName is not a Date field . 
 * / 
 public Date maxDate ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - if ( nativePtr = = 0 ) { 
 - if ( table . getColumnType ( columnIndex ) = = RealmFieldType . DATE ) { 
 - return table . maximumDate ( columnIndex ) ; 
 - } else { 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " Date " ) ) ; 
 - } 
 - } else { 
 - return ( Date ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ MAXIMUM ) ; 
 - } 
 + return ( Date ) collection . aggregate ( Collection . Aggregate . MAXIMUM , columnIndex ) ; 
 } 
 
 
 @ @ - 604 , 20 + 554 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public Number sum ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - if ( nativePtr = = 0 ) { 
 - switch ( table . getColumnType ( columnIndex ) ) { 
 - case INTEGER : 
 - return table . sumLong ( columnIndex ) ; 
 - case FLOAT : 
 - return table . sumFloat ( columnIndex ) ; 
 - case DOUBLE : 
 - return table . sumDouble ( columnIndex ) ; 
 - default : 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 - } 
 - } else { 
 - return ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ SUM ) ; 
 - } 
 + return ( Number ) collection . aggregate ( Collection . Aggregate . SUM , columnIndex ) ; 
 } 
 
 / * * 
 @ @ - 626 , 22 + 563 , 10 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 public double average ( String fieldName ) { 
 realm . checkIfValid ( ) ; 
 long columnIndex = getColumnIndexForSort ( fieldName ) ; 
 - if ( nativePtr = = 0 ) { 
 - switch ( table . getColumnType ( columnIndex ) ) { 
 - case INTEGER : 
 - return table . averageLong ( columnIndex ) ; 
 - case DOUBLE : 
 - return table . averageDouble ( columnIndex ) ; 
 - case FLOAT : 
 - return table . averageFloat ( columnIndex ) ; 
 - default : 
 - throw new IllegalArgumentException ( String . format ( TYPE _ MISMATCH , fieldName , " int , float or double " ) ) ; 
 - } 
 - } else { 
 - / / FIXME : Should we change return type to Double ? 
 - Number sum = ( Number ) nativeAggregate ( nativePtr , columnIndex , AGGREGATE _ FUNCTION _ AVERAGE ) ; 
 - return sum . doubleValue ( ) ; 
 - } 
 + 
 + / / FIXME : Should we change return type to Double ? 
 + Number sum = ( Number ) collection . aggregate ( Collection . Aggregate . AVERAGE , columnIndex ) ; 
 + return sum . doubleValue ( ) ; 
 } 
 
 / * * 
 @ @ - 674 , 7 + 599 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * 
 * @ param fieldName the field name . 
 * @ return immediately a { @ link RealmResults } . Users need to register a listener 
 - * { @ link io . realm . RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the 
 + * { @ link RealmResults # addChangeListener ( RealmChangeListener ) } to be notified when the 
 * query completes . 
 * @ throws IllegalArgumentException if a field is null , does not exist , is an unsupported type , 
 * is not indexed , or points to linked fields . 
 @ @ - 730 , 7 + 655 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Deprecated 
 @ Override 
 - public boolean removeAll ( Collection < ? > collection ) { 
 + public boolean removeAll ( java . util . Collection < ? > collection ) { 
 throw new UnsupportedOperationException ( NOT _ SUPPORTED _ MESSAGE ) ; 
 } 
 
 @ @ - 754 , 7 + 679 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Deprecated 
 @ Override 
 - public boolean retainAll ( Collection < ? > collection ) { 
 + public boolean retainAll ( java . util . Collection < ? > collection ) { 
 throw new UnsupportedOperationException ( NOT _ SUPPORTED _ MESSAGE ) ; 
 } 
 
 @ @ - 845 , 7 + 770 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Override 
 @ Deprecated 
 - public boolean addAll ( int location , Collection < ? extends E > collection ) { 
 + public boolean addAll ( int location , java . util . Collection < ? extends E > collection ) { 
 throw new UnsupportedOperationException ( NOT _ SUPPORTED _ MESSAGE ) ; 
 } 
 
 @ @ - 856 , 7 + 781 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 * / 
 @ Deprecated 
 @ Override 
 - public boolean addAll ( Collection < ? extends E > collection ) { 
 + public boolean addAll ( java . util . Collection < ? extends E > collection ) { 
 throw new UnsupportedOperationException ( NOT _ SUPPORTED _ MESSAGE ) ; 
 } 
 
 @ @ - 1085 , 7 + 1010 , 7 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 } 
 realm . checkIfValid ( ) ; 
 if ( listeners . isEmpty ( ) ) { 
 - nativeAddListener ( nativePtr ) ; 
 + / / nativeAddListener ( nativePtr ) ; 
 } 
 if ( ! listeners . contains ( listener ) ) { 
 listeners . add ( listener ) ; 
 @ @ - 1174 , 22 + 1099 , 4 @ @ public final class RealmResults < E extends RealmModel > extends AbstractList < E > im 
 } 
 } 
 } 
 - 
 - void notifyChangeListeners ( ) { 
 - if ( ! listeners . isEmpty ( ) ) { 
 - for ( RealmChangeListener listener : listeners ) { 
 - listener . onChange ( this ) ; 
 - } 
 - } 
 - } 
 - 
 - private static native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , long [ ] columnIndices , boolean [ ] orders ) ; 
 - private static native long nativeCreateSnapshot ( long nativePtr ) ; 
 - private static native long nativeGetRow ( long nativePtr , int index ) ; 
 - private static native boolean nativeContains ( long nativePtr , long nativeRowPtr ) ; 
 - private static native void nativeClear ( long nativePtr ) ; 
 - private static native long nativeSize ( long nativePtr ) ; 
 - private static native Object nativeAggregate ( long nativePtr , long columnIndex , byte aggregateFunc ) ; 
 - private static native long nativeSort ( long nativePtr , long [ ] columnIndices , boolean [ ] orders ) ; 
 - private native long nativeAddListener ( long nativePtr ) ; 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / Collection . java b / realm / realm - library / src / main / java / io / realm / internal / Collection . java 
 index b227851 . . be3c35d 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / Collection . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / Collection . java 
 @ @ - 16 , 7 + 16 , 13 @ @ 
 
 package io . realm . internal ; 
 
 + import io . realm . RealmChangeListener ; 
 + 
 public class Collection implements NativeObject { 
 + 
 + public interface Listener { 
 + void onChange ( ) ; 
 + } 
 
 private final long nativePtr ; 
 private static final long nativeFinalizerPtr = nativeGetFinalizerPtr ( ) ; 
 @ @ - 29 , 6 + 35 , 23 @ @ public class Collection implements NativeObject { 
 public static final byte AGGREGATE _ FUNCTION _ AVERAGE = 3 ; 
 public static final byte AGGREGATE _ FUNCTION _ SUM = 4 ; 
 
 + public enum Aggregate { 
 + MINIMUM ( AGGREGATE _ FUNCTION _ MINIMUM ) , 
 + MAXIMUM ( AGGREGATE _ FUNCTION _ MAXIMUM ) , 
 + AVERAGE ( AGGREGATE _ FUNCTION _ AVERAGE ) , 
 + SUM ( AGGREGATE _ FUNCTION _ SUM ) ; 
 + 
 + private final byte value ; 
 + 
 + Aggregate ( byte value ) { 
 + this . value = value ; 
 + } 
 + 
 + public byte getValue ( ) { 
 + return value ; 
 + } 
 + } 
 + 
 protected Collection ( SharedRealm sharedRealm , TableQuery query , long indices [ ] , boolean [ ] orders ) { 
 this . context = sharedRealm . context ; 
 this . query = query ; 
 @ @ - 46 , 6 + 69 , 23 @ @ public class Collection implements NativeObject { 
 return nativeFinalizerPtr ; 
 } 
 
 + public UncheckedRow getUncheckedRow ( int index ) { 
 + return UncheckedRow . getByRowPointer ( query . table , nativeGetRow ( nativePtr , index ) ) ; 
 + } 
 + 
 + public Object aggregate ( Aggregate aggregateMethod , long columnIndex ) { 
 + return nativeAggregate ( nativePtr , columnIndex , aggregateMethod . getValue ( ) ) ; 
 + } 
 + 
 + public int size ( ) { 
 + long size = nativeSize ( nativePtr ) ; 
 + return ( size > Integer . MAX _ VALUE ) ? Integer . MAX _ VALUE : ( int ) size ; 
 + } 
 + 
 + public void clear ( ) { 
 + nativeClear ( nativePtr ) ; 
 + } 
 + 
 private static native long nativeGetFinalizerPtr ( ) ; 
 private static native long nativeCreateResults ( long sharedRealmNativePtr , long queryNativePtr , long [ ] columnIndices , 
 boolean [ ] orders ) ;

NEAREST DIFF:
diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 index a21bc7c . . 3eceee2 100644 
 - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 @ @ - 257 , 7 + 257 , 7 @ @ public class RealmProxyClassGenerator { 
 writer . emitAnnotation ( " Override " ) ; 
 writer . beginMethod ( fieldTypeCanonicalName , getters . get ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) ) ; 
 writer . emitStatement ( 
 - " realm . assertThread ( ) " 
 + " realm . checkIfValid ( ) " 
 ) ; 
 writer . emitStatement ( 
 " return ( % s ) row . get % s ( Realm . columnIndices . get ( \ " % s \ " ) . get ( \ " % s \ " ) ) " , 
 @ @ - 269 , 7 + 269 , 7 @ @ public class RealmProxyClassGenerator { 
 writer . emitAnnotation ( " Override " ) ; 
 writer . beginMethod ( " void " , setters . get ( fieldName ) , EnumSet . of ( Modifier . PUBLIC ) , fieldTypeCanonicalName , " value " ) ; 
 writer . emitStatement ( 
 - " realm . assertThread ( ) " 
 + " realm . checkIfValid ( ) " 
 ) ; 
 writer . emitStatement ( 
 " row . set % s ( Realm . columnIndices . get ( \ " % s \ " ) . get ( \ " % s \ " ) , ( % s ) value ) " , 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index 83d7439 . . 392eb74 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 16 , 12 + 16 , 14 @ @ 
 
 package io . realm ; 
 
 + import android . annotation . SuppressLint ; 
 import android . content . Context ; 
 import android . os . Handler ; 
 import android . os . Looper ; 
 import android . os . Message ; 
 import android . util . Log ; 
 
 + import java . io . Closeable ; 
 import java . io . File ; 
 import java . lang . reflect . Constructor ; 
 import java . lang . reflect . InvocationTargetException ; 
 @ @ - 69 , 21 + 71 , 30 @ @ import io . realm . internal . Table ; 
 * thread . start ( ) ; 
 * < / pre > 
 * / 
 - public class Realm { 
 + public class Realm implements Closeable { 
 public static final String DEFAULT _ REALM _ NAME = " default . realm " ; 
 
 private static final String TAG = " REALM " ; 
 private static final String TABLE _ PREFIX = " class _ " ; 
 protected static final ThreadLocal < Map < Integer , Realm > > realmsCache = new ThreadLocal < Map < Integer , Realm > > ( ) { 
 + @ SuppressLint ( " UseSparseArrays " ) 
 @ Override 
 protected Map < Integer , Realm > initialValue ( ) { 
 - return new HashMap < Integer , Realm > ( ) ; 
 + return new HashMap < Integer , Realm > ( ) ; / / On Android we could use SparseArray < Realm > which is faster , 
 + / / but incompatible with Java 
 + } 
 + } ; 
 + private static final ThreadLocal < Integer > referenceCount = new ThreadLocal < Integer > ( ) { 
 + @ Override 
 + protected Integer initialValue ( ) { 
 + return 1 ; 
 } 
 } ; 
 private static final int REALM _ CHANGED = 14930352 ; / / Just a nice big Fibonacci number . For no reason : ) 
 private static final Map < Handler , Integer > handlers = new ConcurrentHashMap < Handler , Integer > ( ) ; 
 private static final String APT _ NOT _ EXECUTED _ MESSAGE = " Annotation processor may not have been executed . " ; 
 private static final String INCORRECT _ THREAD _ MESSAGE = " Realm access from incorrect thread . Realm objects can only be accessed on the thread they where created . " ; 
 + private static final String CLOSED _ REALM = " This Realm instance has already been closed , making it unusable . " ; 
 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 private static SharedGroup . Durability defaultDurability = SharedGroup . Durability . FULL ; 
 @ @ - 91 , 7 + 102 , 7 @ @ public class Realm { 
 private Handler handler ; 
 
 private final int id ; 
 - private final SharedGroup sharedGroup ; 
 + private SharedGroup sharedGroup ; 
 private final ImplicitTransaction transaction ; 
 private final Map < Class < ? > , String > simpleClassNames = new HashMap < Class < ? > , String > ( ) ; 
 private final Map < String , Class < ? > > generatedClasses = new HashMap < String , Class < ? > > ( ) ; 
 @ @ - 105 , 8 + 116 , 15 @ @ public class Realm { 
 / / Package protected to be reachable by proxy classes 
 static final Map < String , Map < String , Long > > columnIndices = new HashMap < String , Map < String , Long > > ( ) ; 
 
 - protected void assertThread ( ) { 
 - if ( realmsCache . get ( ) . get ( this . id ) ! = this ) { 
 + protected void checkIfValid ( ) { 
 + / / Check if the Realm instance has been closed 
 + if ( sharedGroup = = null ) { 
 + throw new IllegalStateException ( CLOSED _ REALM ) ; 
 + } 
 + 
 + / / Check if we are in the right thread 
 + Realm currentRealm = realmsCache . get ( ) . get ( this . id ) ; 
 + if ( currentRealm ! = null & & currentRealm ! = this ) { 
 throw new IllegalStateException ( INCORRECT _ THREAD _ MESSAGE ) ; 
 } 
 } 
 @ @ - 121 , 10 + 139 , 26 @ @ public class Realm { 
 
 @ Override 
 protected void finalize ( ) throws Throwable { 
 - transaction . endRead ( ) ; 
 + this . close ( ) ; 
 super . finalize ( ) ; 
 } 
 
 + / * * 
 + * Closes the Realm instance and all its resources . It ' s important to always remember to close Realm instances 
 + * when you ' re done with it in order not to leak memory , file descriptors or grow the size of Realm files out of 
 + * measure . 
 + * / 
 + @ Override 
 + public void close ( ) { 
 + int references = referenceCount . get ( ) ; 
 + if ( sharedGroup ! = null & & references = = 1 ) { 
 + realmsCache . get ( ) . remove ( id ) ; 
 + sharedGroup . close ( ) ; 
 + sharedGroup = null ; 
 + } 
 + referenceCount . set ( references - 1 ) ; 
 + } 
 + 
 private class RealmCallback implements Handler . Callback { 
 @ Override 
 public boolean handleMessage ( Message message ) { 
 @ @ - 365 , 16 + 399 , 21 @ @ public class Realm { 
 
 @ SuppressWarnings ( " unchecked " ) 
 private static Realm createAndValidate ( String absolutePath , byte [ ] key , boolean validateSchema , boolean autoRefresh ) { 
 + int references = referenceCount . get ( ) ; 
 Map < Integer , Realm > realms = realmsCache . get ( ) ; 
 Realm realm = realms . get ( absolutePath . hashCode ( ) ) ; 
 
 if ( realm ! = null ) { 
 + referenceCount . set ( references + 1 ) ; 
 return realm ; 
 } 
 
 realm = new Realm ( absolutePath , key , autoRefresh ) ; 
 - realms . put ( absolutePath . hashCode ( ) , realm ) ; 
 - realmsCache . set ( realms ) ; 
 + 
 + if ( autoRefresh ) { 
 + realms . put ( absolutePath . hashCode ( ) , realm ) ; 
 + realmsCache . set ( realms ) ; 
 + } 
 
 if ( validateSchema ) { 
 Class < ? > validationClass ; 
 @ @ - 484 , 6 + 523 , 7 @ @ public class Realm { 
 } 
 } 
 
 + referenceCount . set ( references + 1 ) ; 
 return realm ; 
 } 
 
 @ @ - 652 , 7 + 692 , 7 @ @ public class Realm { 
 * @ see io . realm . RealmChangeListener 
 * / 
 public void addChangeListener ( RealmChangeListener listener ) { 
 - assertThread ( ) ; 
 + checkIfValid ( ) ; 
 changeListeners . add ( listener ) ; 
 } 
 
 @ @ - 663 , 7 + 703 , 7 @ @ public class Realm { 
 * @ see io . realm . RealmChangeListener 
 * / 
 public void removeChangeListener ( RealmChangeListener listener ) { 
 - assertThread ( ) ; 
 + checkIfValid ( ) ; 
 changeListeners . remove ( listener ) ; 
 } 
 
 @ @ - 673 , 7 + 713 , 7 @ @ public class Realm { 
 * @ see io . realm . RealmChangeListener 
 * / 
 public void removeAllChangeListeners ( ) { 
 - assertThread ( ) ; 
 + checkIfValid ( ) ; 
 changeListeners . clear ( ) ; 
 } 
 
 @ @ - 697 , 7 + 737 , 7 @ @ public class Realm { 
 * / 
 @ SuppressWarnings ( " UnusedDeclaration " ) 
 public void refresh ( ) { 
 - assertThread ( ) ; 
 + checkIfValid ( ) ; 
 transaction . advanceRead ( ) ; 
 } 
 
 @ @ - 716 , 7 + 756 , 7 @ @ public class Realm { 
 * 
 * / 
 public void beginTransaction ( ) { 
 - assertThread ( ) ; 
 + checkIfValid ( ) ; 
 transaction . promoteToWrite ( ) ; 
 } 
 
 @ @ - 730 , 7 + 770 , 7 @ @ public class Realm { 
 * @ throws java . lang . IllegalStateException If the write transaction is in an invalid state or incorrect thread . 
 * / 
 public void commitTransaction ( ) { 
 - assertThread ( ) ; 
 + checkIfValid ( ) ; 
 transaction . commitAndContinueAsRead ( ) ; 
 
 for ( Map . Entry < Handler , Integer > handlerIntegerEntry : handlers . entrySet ( ) ) { 
 @ @ - 760 , 7 + 800 , 7 @ @ public class Realm { 
 * not in a write transaction or incorrect thread . 
 * / 
 public void cancelTransaction ( ) { 
 - assertThread ( ) ; 
 + checkIfValid ( ) ; 
 transaction . rollbackAndContinueAsRead ( ) ; 
 } 
 
 diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java 
 index 2b6f97c . . c40b37c 100644 
 - - - a / realm / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / src / main / java / io / realm / RealmResults . java 
 @ @ - 83 , 7 + 83 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ see io . realm . RealmQuery 
 * / 
 public RealmQuery < E > where ( ) { 
 - realm . assertThread ( ) ; 
 + realm . checkIfValid ( ) ; 
 return new RealmQuery < E > ( this , classSpec ) ; 
 } 
 
 @ @ - 93 , 7 + 93 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 @ Override 
 public E get ( int rowIndex ) { 
 E obj ; 
 - realm . assertThread ( ) ; 
 + realm . checkIfValid ( ) ; 
 TableOrView table = getTable ( ) ; 
 if ( table instanceof TableView ) { 
 obj = realm . get ( classSpec , ( ( TableView ) table ) . getSourceRowIndex ( rowIndex ) ) ; 
 @ @ - 146 , 7 + 146 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 public RealmResults < E > sort ( String fieldName , boolean sortAscending ) { 
 TableView sorted ; 
 
 - realm . assertThread ( ) ; 
 + realm . checkIfValid ( ) ; 
 TableOrView table = getTable ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 TableView . Order TVOrder = sortAscending ? TableView . Order . ascending : TableView . Order . descending ; 
 @ @ - 184 , 7 + 184 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if field is not int , float or double . 
 * / 
 public Number min ( String fieldName ) { 
 - realm . assertThread ( ) ; 
 + realm . checkIfValid ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 switch ( table . getColumnType ( columnIndex ) ) { 
 case INTEGER : 
 @ @ - 207 , 7 + 207 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . 
 * / 
 public Date minDate ( String fieldName ) { 
 - realm . assertThread ( ) ; 
 + realm . checkIfValid ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 if ( table . getColumnType ( columnIndex ) = = ColumnType . DATE ) { 
 return table . minimumDate ( columnIndex ) ; 
 @ @ - 225 , 7 + 225 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if field is not int , float or double . 
 * / 
 public Number max ( String fieldName ) { 
 - realm . assertThread ( ) ; 
 + realm . checkIfValid ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 switch ( table . getColumnType ( columnIndex ) ) { 
 case INTEGER : 
 @ @ - 248 , 7 + 248 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if fieldName is not a Date field . 
 * / 
 public Date maxDate ( String fieldName ) { 
 - realm . assertThread ( ) ; 
 + realm . checkIfValid ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 if ( table . getColumnType ( columnIndex ) = = ColumnType . DATE ) { 
 return table . maximumDate ( columnIndex ) ; 
 @ @ - 268 , 7 + 268 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * / 
 
 public Number sum ( String fieldName ) { 
 - realm . assertThread ( ) ; 
 + realm . checkIfValid ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 switch ( table . getColumnType ( columnIndex ) ) { 
 case INTEGER : 
 @ @ - 293 , 7 + 293 , 7 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ throws java . lang . IllegalArgumentException if field is not int , float or double . 
 * / 
 public double average ( String fieldName ) { 
 - realm . assertThread ( ) ; 
 + realm . checkIfValid ( ) ; 
 long columnIndex = table . getColumnIndex ( fieldName ) ; 
 switch ( table . getColumnType ( columnIndex ) ) { 
 case INTEGER : 
 diff - - git a / realm / src / main / java / io / realm / internal / SharedGroup . java b / realm / src / main / java / io / realm / internal / SharedGroup . java 
 index e8b2f0b . . 9afa75c 100644 
 - - - a / realm / src / main / java / io / realm / internal / SharedGroup . java 
 + + + b / realm / src / main / java / io / realm / internal / SharedGroup . java 
 @ @ - 49 , 6 + 49 , 7 @ @ public class SharedGroup implements Closeable { 
 this . nativePtr = createNative ( databaseFile , Durability . FULL . value , false , false , null ) ; 
 checkNativePtrNotZero ( ) ; 
 } 
 + 
 public SharedGroup ( String databaseFile , boolean enableImplicitTransactions , byte [ ] key ) { 
 if ( enableImplicitTransactions ) { 
 nativeTransactLogRegistryPtr = nativeCreateTransactLogRegistry ( databaseFile ) ; 
 @ @ - 73 , 18 + 74 , 20 @ @ public class SharedGroup implements Closeable { 
 this . nativePtr = createNative ( databaseFile , durability . value , false , false , key ) ; 
 checkNativePtrNotZero ( ) ; 
 } 
 + 
 public SharedGroup ( String databaseFile , Durability durability , boolean fileMustExist ) { 
 context = new Context ( ) ; 
 this . nativePtr = createNative ( databaseFile , durability . value , fileMustExist , false , null ) ; 
 checkNativePtrNotZero ( ) ; 
 } 
 - / * 
 - SharedGroup ( String databaseFile , Durability durability , boolean no _ create , boolean enableReplication ) { 
 - context = new Context ( ) ; 
 - this . nativePtr = createNative ( databaseFile , durability . value , no _ create , enableReplication ) ; 
 - checkNativePtr ( ) ; 
 - } 
 - * / 
 + 
 + / * 
 + SharedGroup ( String databaseFile , Durability durability , boolean no _ create , boolean enableReplication ) { 
 + context = new Context ( ) ; 
 + this . nativePtr = createNative ( databaseFile , durability . value , no _ create , enableReplication ) ; 
 + checkNativePtr ( ) ; 
 + } 
 + * / 
 void advanceRead ( ) { 
 nativeAdvanceRead ( nativePtr , nativeTransactLogRegistryPtr ) ; 
 } 
 @ @ - 103 , 7 + 106 , 9 @ @ public class SharedGroup implements Closeable { 
 
 private native void nativeCommitAndContinueAsRead ( long nativePtr ) ; 
 
 - void rollbackAndContinueAsRead ( ) { nativeRollbackAndContinueAsRead ( nativePtr ) ; } 
 + void rollbackAndContinueAsRead ( ) { 
 + nativeRollbackAndContinueAsRead ( nativePtr ) ; 
 + } 
 
 private native void nativeRollbackAndContinueAsRead ( long nativePtr ) ; 
 
 @ @ - 132 , 8 + 137 , 7 @ @ public class SharedGroup implements Closeable { 
 WriteTransaction t = new WriteTransaction ( context , this , nativeWritePtr ) ; 
 activeTransaction = true ; 
 return t ; 
 - } 
 - catch ( RuntimeException e ) { 
 + } catch ( RuntimeException e ) { 
 Group . nativeClose ( nativeWritePtr ) ; 
 throw e ; 
 } 
 @ @ - 141 , 8 + 145 , 7 @ @ public class SharedGroup implements Closeable { 
 
 public ReadTransaction beginRead ( ) { 
 if ( activeTransaction ) 
 - throw new IllegalStateException ( 
 - " Can ' t beginRead ( ) during another active transaction " ) ; 
 + throw new IllegalStateException ( " Can ' t beginRead ( ) during another active transaction " ) ; 
 / / FIXME : throw from nativeMethod in case of error 
 
 long nativeReadPtr = nativeBeginRead ( nativePtr ) ; 
 @ @ - 151 , 8 + 154 , 7 @ @ public class SharedGroup implements Closeable { 
 ReadTransaction t = new ReadTransaction ( context , this , nativeReadPtr ) ; 
 activeTransaction = true ; 
 return t ; 
 - } 
 - catch ( RuntimeException e ) { 
 + } catch ( RuntimeException e ) { 
 Group . nativeClose ( nativeReadPtr ) ; 
 throw e ; 
 } 
 @ @ - 160 , 18 + 162 , 13 @ @ public class SharedGroup implements Closeable { 
 
 void endRead ( ) { 
 if ( isClosed ( ) ) 
 - throw new IllegalStateException ( 
 - " Can ' t endRead ( ) on closed group . ReadTransaction is invalid . " ) ; 
 + throw new IllegalStateException ( " Can ' t endRead ( ) on closed group . ReadTransaction is invalid . " ) ; 
 nativeEndRead ( nativePtr ) ; 
 activeTransaction = false ; 
 } 
 
 public void close ( ) { 
 - if ( activeTransaction ) 
 - throw new IllegalStateException ( 
 - " Can ' t close the SharedGroup during an active transaction " ) ; 
 - 
 - synchronized ( context ) { 
 + synchronized ( context ) { 
 if ( nativePtr ! = 0 ) { 
 nativeClose ( nativePtr ) ; 
 nativePtr = 0 ; 
 @ @ - 192 , 7 + 189 , 7 @ @ public class SharedGroup implements Closeable { 
 protected void finalize ( ) { 
 synchronized ( context ) { 
 if ( nativePtr ! = 0 ) { 
 - context . asyncDisposeSharedGroup ( nativePtr ) ; 
 + context . asyncDisposeSharedGroup ( nativePtr ) ; 
 nativePtr = 0 ; / / Set to 0 if finalize is called before close ( ) for some reason 
 if ( implicitTransactionsEnabled ) { 
 if ( nativeTransactLogRegistryPtr ! = 0 ) { 
 @ @ - 254 , 10 + 251 , 10 @ @ public class SharedGroup implements Closeable { 
 private native void nativeRollback ( long nativePtr ) ; 
 
 private native long createNative ( String databaseFile , 
 - int durabilityValue , 
 - boolean no _ create , 
 - boolean enableReplication , 
 - byte [ ] key ) ; 
 + int durabilityValue , 
 + boolean no _ create , 
 + boolean enableReplication , 
 + byte [ ] key ) ; 
 
 private void checkNativePtrNotZero ( ) { 
 if ( this . nativePtr = = 0 ) 
 @ @ - 265 , 7 + 262 , 9 @ @ public class SharedGroup implements Closeable { 
 } 
 
 protected static native void nativeClose ( long nativePtr ) ; 
 + 
 private native void nativeCloseTransactRegistryLog ( long nativeTransactLogRegistryPtr ) ; 
 + 
 private native void nativeCloseReplication ( long nativeReplicationPtr ) ; 
 
 }
