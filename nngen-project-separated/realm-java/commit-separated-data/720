BLEU SCORE: 0.025275658895144486

TEST MSG: Use RealmObjectSchema . getPrimaryKey in tests
GENERATED MSG: validateTable now also verifies that primary key and index is set correctly .

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java <nl> index e5fb518 . . 6963b7f 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java <nl> @ @ - 619 , 9 + 619 , 7 @ @ public class RealmObjectSchemaTests { <nl> schema . renameField ( fieldName , " bar " ) ; <nl> assertTrue ( schema . hasPrimaryKey ( ) ) ; <nl> <nl> - / / TODO : Use this after merge to master <nl> - / / assertEquals ( " bar " , schema . getPrimaryKey ( ) ) ; <nl> - assertEquals ( " bar " , schema . table . getColumnName ( schema . table . getPrimaryKey ( ) ) ) ; <nl> + assertEquals ( " bar " , schema . getPrimaryKey ( ) ) ; <nl> } <nl> <nl> @ Test <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java <nl> index f09c91b . . bef98fa 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java <nl> @ @ - 151 , 31 + 151 , 21 @ @ public class RealmSchemaTests { <nl> assertTrue ( realmSchema . contains ( NEW _ NAME ) ) ; <nl> RealmObjectSchema objectSchema = realmSchema . getSchemaForClass ( NEW _ NAME ) ; <nl> <nl> - / / TODO : Use this after merge to master <nl> - / / assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , objectSchema . getPrimaryKey ( ) ) ; <nl> - assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , <nl> - objectSchema . table . getColumnName ( objectSchema . table . getPrimaryKey ( ) ) ) ; <nl> + assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , objectSchema . getPrimaryKey ( ) ) ; <nl> <nl> / / Create an object with the old name , and the PK should not exist after created . <nl> RealmObjectSchema oldObjectSchema = realmSchema . create ( PrimaryKeyAsString . CLASS _ NAME ) ; <nl> oldObjectSchema . addField ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , String . class ) ; <nl> <nl> - / / TODO : Use this after merge to master <nl> - / * <nl> try { <nl> / / It should not have primary key anymore at this point <nl> oldObjectSchema . getPrimaryKey ( ) ; <nl> fail ( ) ; <nl> } catch ( IllegalStateException ignored ) { <nl> } <nl> - * / <nl> - assertEquals ( - 2 , oldObjectSchema . table . getPrimaryKey ( ) ) ; <nl> <nl> oldObjectSchema . addPrimaryKey ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY ) ; <nl> - / / TODO : Use this after merge to master <nl> - / / assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , oldObjectSchema . getPrimaryKey ( ) ) ; <nl> - assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , <nl> - oldObjectSchema . table . getColumnName ( oldObjectSchema . table . getPrimaryKey ( ) ) ) ; <nl> + assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , oldObjectSchema . getPrimaryKey ( ) ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 227 , 21 + 217 , 14 @ @ public class RealmSchemaTests { <nl> RealmObjectSchema objectSchema = realmSchema . create ( PrimaryKeyAsString . CLASS _ NAME ) ; <nl> objectSchema . addField ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , String . class ) ; <nl> <nl> - / / TODO : Use this after merge to master <nl> - / * <nl> try { <nl> / / It should not have primary key anymore at this point <nl> objectSchema . getPrimaryKey ( ) ; <nl> fail ( ) ; <nl> } catch ( IllegalStateException ignored ) { <nl> } <nl> - * / <nl> - assertEquals ( - 2 , objectSchema . table . getPrimaryKey ( ) ) ; <nl> <nl> objectSchema . addPrimaryKey ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY ) ; <nl> - / / TODO : Use this after merge to master <nl> - / / assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , objectSchema . getPrimaryKey ( ) ) ; <nl> - assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , <nl> - objectSchema . table . getColumnName ( objectSchema . table . getPrimaryKey ( ) ) ) ; <nl> + assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , objectSchema . getPrimaryKey ( ) ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index b08e6da . . 7133782 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 0 . 81 <nl> + * A RealmMigrationExceptionNeeded is now properly thrown if @ Index and @ PrimaryKey are not set correctly during a migration . <nl> * Fixed bug causing Realms to be cached even though they failed to open correctly . <nl> * Fixed bug when using Realm . copyToRealm ( ) with a primary key could crash if default value was already used in the Realm . <nl> <nl> diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> index 9f518de . . 1dee0e8 100644 <nl> - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> @ @ - 408 , 6 + 408 , 21 @ @ public class RealmProxyClassGenerator { <nl> writer . emitStatement ( " throw new IllegalStateException ( \ " Invalid type ' % s ' for column ' % s ' \ " ) " , <nl> fieldTypeSimpleName , fieldName ) ; <nl> writer . endControlFlow ( ) ; <nl> + <nl> + / / Validate @ PrimaryKey <nl> + if ( field . equals ( metadata . getPrimaryKey ( ) ) ) { <nl> + writer . beginControlFlow ( " if ( table . getPrimaryKey ( ) ! = table . getColumnIndex ( \ " % s \ " ) ) " , fieldName ) ; <nl> + writer . emitStatement ( " throw new IllegalStateException ( \ " Primary key not defined for field ' % s ' \ " ) " , fieldName ) ; <nl> + writer . endControlFlow ( ) ; <nl> + } <nl> + <nl> + / / Validate @ Index <nl> + if ( metadata . getIndexedFields ( ) . contains ( field ) ) { <nl> + writer . beginControlFlow ( " if ( ! table . hasIndex ( table . getColumnIndex ( \ " % s \ " ) ) ) " , fieldName ) ; <nl> + writer . emitStatement ( " throw new IllegalStateException ( \ " Index not defined for field ' % s ' \ " ) " , fieldName ) ; <nl> + writer . endControlFlow ( ) ; <nl> + } <nl> + <nl> } else if ( typeUtils . isAssignable ( field . asType ( ) , realmObject ) ) { / / Links <nl> writer . beginControlFlow ( " if ( ! columnTypes . containsKey ( \ " % s \ " ) ) " , fieldName ) ; <nl> writer . emitStatement ( " throw new IllegalStateException ( \ " Missing column ' % s ' \ " ) " , fieldName ) ; <nl> diff - - git a / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java b / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java <nl> index da83178 . . a5c2d41 100644 <nl> - - - a / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java <nl> + + + b / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java <nl> @ @ - 210 , 6 + 210 , 12 @ @ public class AllTypesRealmProxy extends AllTypes { <nl> if ( columnTypes . get ( " columnString " ) ! = ColumnType . STRING ) { <nl> throw new IllegalStateException ( " Invalid type ' String ' for column ' columnString ' " ) ; <nl> } <nl> + if ( table . getPrimaryKey ( ) ! = table . getColumnIndex ( " columnString " ) ) { <nl> + throw new IllegalStateException ( " Primary key not defined for field ' columnString ' " ) ; <nl> + } <nl> + if ( ! table . hasIndex ( table . getColumnIndex ( " columnString " ) ) ) { <nl> + throw new IllegalStateException ( " Index not defined for field ' columnString ' " ) ; <nl> + } <nl> if ( ! columnTypes . containsKey ( " columnLong " ) ) { <nl> throw new IllegalStateException ( " Missing column ' columnLong ' " ) ; <nl> } <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmMigrationTests . java b / realm / src / androidTest / java / io / realm / RealmMigrationTests . java <nl> index 680965a . . ab6a946 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmMigrationTests . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmMigrationTests . java <nl> @ @ - 2 , 13 + 2 , 34 @ @ package io . realm ; <nl> <nl> import android . test . AndroidTestCase ; <nl> <nl> + import java . io . File ; <nl> import java . io . IOException ; <nl> <nl> import io . realm . entities . AllTypes ; <nl> + import io . realm . entities . AnnotationTypes ; <nl> import io . realm . exceptions . RealmMigrationNeededException ; <nl> + import io . realm . internal . ColumnType ; <nl> + import io . realm . internal . Table ; <nl> <nl> public class RealmMigrationTests extends AndroidTestCase { <nl> <nl> + public Realm realm ; <nl> + <nl> + @ Override <nl> + protected void setUp ( ) throws Exception { <nl> + super . setUp ( ) ; <nl> + Realm . setSchema ( null ) ; <nl> + Realm . deleteRealmFile ( getContext ( ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected void tearDown ( ) throws Exception { <nl> + super . tearDown ( ) ; <nl> + if ( realm ! = null ) { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> public void testRealmClosedAfterMigrationException ( ) throws IOException { <nl> String REALM _ NAME = " default0 . realm " ; <nl> Realm . deleteRealmFile ( getContext ( ) , REALM _ NAME ) ; <nl> @ @ - 25 , 4 + 46 , 70 @ @ public class RealmMigrationTests extends AndroidTestCase { <nl> int result = realm . where ( AllTypes . class ) . equalTo ( " columnString " , " Foo " ) . findAll ( ) . size ( ) ; <nl> assertEquals ( 0 , result ) ; <nl> } <nl> + <nl> + public void testNotSettingIndexThrows ( ) { <nl> + Realm . setSchema ( AnnotationTypes . class ) ; <nl> + Realm . migrateRealmAtPath ( new File ( getContext ( ) . getFilesDir ( ) , " default . realm " ) . getAbsolutePath ( ) , new RealmMigration ( ) { <nl> + @ Override <nl> + public long execute ( Realm realm , long version ) { <nl> + Table table = realm . getTable ( AnnotationTypes . class ) ; <nl> + table . addColumn ( ColumnType . INTEGER , " id " ) ; <nl> + table . setPrimaryKey ( " id " ) ; <nl> + table . addColumn ( ColumnType . STRING , " indexString " ) ; <nl> + table . addColumn ( ColumnType . STRING , " notIndexString " ) ; <nl> + / / Forget to set @ Index <nl> + return 1 ; <nl> + } <nl> + } ) ; <nl> + <nl> + try { <nl> + realm = Realm . getInstance ( getContext ( ) ) ; <nl> + fail ( ) ; <nl> + } catch ( RealmMigrationNeededException expected ) { <nl> + } <nl> + } <nl> + <nl> + public void testNotSettingPrimaryKeyThrows ( ) { <nl> + Realm . setSchema ( AnnotationTypes . class ) ; <nl> + Realm . migrateRealmAtPath ( new File ( getContext ( ) . getFilesDir ( ) , " default . realm " ) . getAbsolutePath ( ) , new RealmMigration ( ) { <nl> + @ Override <nl> + public long execute ( Realm realm , long version ) { <nl> + Table table = realm . getTable ( AnnotationTypes . class ) ; <nl> + table . addColumn ( ColumnType . INTEGER , " id " ) ; <nl> + / / Forget to set @ PrimaryKey <nl> + long columnIndex = table . addColumn ( ColumnType . STRING , " indexString " ) ; <nl> + table . setIndex ( columnIndex ) ; <nl> + table . addColumn ( ColumnType . STRING , " notIndexString " ) ; <nl> + return 1 ; <nl> + } <nl> + } ) ; <nl> + <nl> + try { <nl> + realm = Realm . getInstance ( getContext ( ) ) ; <nl> + fail ( ) ; <nl> + } catch ( RealmMigrationNeededException expected ) { <nl> + } <nl> + } <nl> + <nl> + public void testSetAnnotations ( ) { <nl> + Realm . setSchema ( AnnotationTypes . class ) ; <nl> + Realm . migrateRealmAtPath ( new File ( getContext ( ) . getFilesDir ( ) , " default . realm " ) . getAbsolutePath ( ) , new RealmMigration ( ) { <nl> + @ Override <nl> + public long execute ( Realm realm , long version ) { <nl> + Table table = realm . getTable ( AnnotationTypes . class ) ; <nl> + table . addColumn ( ColumnType . INTEGER , " id " ) ; <nl> + table . setPrimaryKey ( " id " ) ; <nl> + long columnIndex = table . addColumn ( ColumnType . STRING , " indexString " ) ; <nl> + table . setIndex ( columnIndex ) ; <nl> + table . addColumn ( ColumnType . STRING , " notIndexString " ) ; <nl> + return 1 ; <nl> + } <nl> + } ) ; <nl> + <nl> + realm = Realm . getInstance ( getContext ( ) ) ; <nl> + Table table = realm . getTable ( AnnotationTypes . class ) ; <nl> + assertEquals ( 3 , table . getColumnCount ( ) ) ; <nl> + assertTrue ( table . hasPrimaryKey ( ) ) ; <nl> + assertTrue ( table . hasIndex ( table . getColumnIndex ( " indexString " ) ) ) ; <nl> + } <nl> }

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java 
 index e5fb518 . . 6963b7f 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmObjectSchemaTests . java 
 @ @ - 619 , 9 + 619 , 7 @ @ public class RealmObjectSchemaTests { 
 schema . renameField ( fieldName , " bar " ) ; 
 assertTrue ( schema . hasPrimaryKey ( ) ) ; 
 
 - / / TODO : Use this after merge to master 
 - / / assertEquals ( " bar " , schema . getPrimaryKey ( ) ) ; 
 - assertEquals ( " bar " , schema . table . getColumnName ( schema . table . getPrimaryKey ( ) ) ) ; 
 + assertEquals ( " bar " , schema . getPrimaryKey ( ) ) ; 
 } 
 
 @ Test 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java b / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java 
 index f09c91b . . bef98fa 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmSchemaTests . java 
 @ @ - 151 , 31 + 151 , 21 @ @ public class RealmSchemaTests { 
 assertTrue ( realmSchema . contains ( NEW _ NAME ) ) ; 
 RealmObjectSchema objectSchema = realmSchema . getSchemaForClass ( NEW _ NAME ) ; 
 
 - / / TODO : Use this after merge to master 
 - / / assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , objectSchema . getPrimaryKey ( ) ) ; 
 - assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , 
 - objectSchema . table . getColumnName ( objectSchema . table . getPrimaryKey ( ) ) ) ; 
 + assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , objectSchema . getPrimaryKey ( ) ) ; 
 
 / / Create an object with the old name , and the PK should not exist after created . 
 RealmObjectSchema oldObjectSchema = realmSchema . create ( PrimaryKeyAsString . CLASS _ NAME ) ; 
 oldObjectSchema . addField ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , String . class ) ; 
 
 - / / TODO : Use this after merge to master 
 - / * 
 try { 
 / / It should not have primary key anymore at this point 
 oldObjectSchema . getPrimaryKey ( ) ; 
 fail ( ) ; 
 } catch ( IllegalStateException ignored ) { 
 } 
 - * / 
 - assertEquals ( - 2 , oldObjectSchema . table . getPrimaryKey ( ) ) ; 
 
 oldObjectSchema . addPrimaryKey ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY ) ; 
 - / / TODO : Use this after merge to master 
 - / / assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , oldObjectSchema . getPrimaryKey ( ) ) ; 
 - assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , 
 - oldObjectSchema . table . getColumnName ( oldObjectSchema . table . getPrimaryKey ( ) ) ) ; 
 + assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , oldObjectSchema . getPrimaryKey ( ) ) ; 
 } 
 
 @ Test 
 @ @ - 227 , 21 + 217 , 14 @ @ public class RealmSchemaTests { 
 RealmObjectSchema objectSchema = realmSchema . create ( PrimaryKeyAsString . CLASS _ NAME ) ; 
 objectSchema . addField ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , String . class ) ; 
 
 - / / TODO : Use this after merge to master 
 - / * 
 try { 
 / / It should not have primary key anymore at this point 
 objectSchema . getPrimaryKey ( ) ; 
 fail ( ) ; 
 } catch ( IllegalStateException ignored ) { 
 } 
 - * / 
 - assertEquals ( - 2 , objectSchema . table . getPrimaryKey ( ) ) ; 
 
 objectSchema . addPrimaryKey ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY ) ; 
 - / / TODO : Use this after merge to master 
 - / / assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , objectSchema . getPrimaryKey ( ) ) ; 
 - assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , 
 - objectSchema . table . getColumnName ( objectSchema . table . getPrimaryKey ( ) ) ) ; 
 + assertEquals ( PrimaryKeyAsString . FIELD _ PRIMARY _ KEY , objectSchema . getPrimaryKey ( ) ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index b08e6da . . 7133782 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 0 . 81 
 + * A RealmMigrationExceptionNeeded is now properly thrown if @ Index and @ PrimaryKey are not set correctly during a migration . 
 * Fixed bug causing Realms to be cached even though they failed to open correctly . 
 * Fixed bug when using Realm . copyToRealm ( ) with a primary key could crash if default value was already used in the Realm . 
 
 diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 index 9f518de . . 1dee0e8 100644 
 - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 @ @ - 408 , 6 + 408 , 21 @ @ public class RealmProxyClassGenerator { 
 writer . emitStatement ( " throw new IllegalStateException ( \ " Invalid type ' % s ' for column ' % s ' \ " ) " , 
 fieldTypeSimpleName , fieldName ) ; 
 writer . endControlFlow ( ) ; 
 + 
 + / / Validate @ PrimaryKey 
 + if ( field . equals ( metadata . getPrimaryKey ( ) ) ) { 
 + writer . beginControlFlow ( " if ( table . getPrimaryKey ( ) ! = table . getColumnIndex ( \ " % s \ " ) ) " , fieldName ) ; 
 + writer . emitStatement ( " throw new IllegalStateException ( \ " Primary key not defined for field ' % s ' \ " ) " , fieldName ) ; 
 + writer . endControlFlow ( ) ; 
 + } 
 + 
 + / / Validate @ Index 
 + if ( metadata . getIndexedFields ( ) . contains ( field ) ) { 
 + writer . beginControlFlow ( " if ( ! table . hasIndex ( table . getColumnIndex ( \ " % s \ " ) ) ) " , fieldName ) ; 
 + writer . emitStatement ( " throw new IllegalStateException ( \ " Index not defined for field ' % s ' \ " ) " , fieldName ) ; 
 + writer . endControlFlow ( ) ; 
 + } 
 + 
 } else if ( typeUtils . isAssignable ( field . asType ( ) , realmObject ) ) { / / Links 
 writer . beginControlFlow ( " if ( ! columnTypes . containsKey ( \ " % s \ " ) ) " , fieldName ) ; 
 writer . emitStatement ( " throw new IllegalStateException ( \ " Missing column ' % s ' \ " ) " , fieldName ) ; 
 diff - - git a / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java b / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java 
 index da83178 . . a5c2d41 100644 
 - - - a / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java 
 + + + b / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java 
 @ @ - 210 , 6 + 210 , 12 @ @ public class AllTypesRealmProxy extends AllTypes { 
 if ( columnTypes . get ( " columnString " ) ! = ColumnType . STRING ) { 
 throw new IllegalStateException ( " Invalid type ' String ' for column ' columnString ' " ) ; 
 } 
 + if ( table . getPrimaryKey ( ) ! = table . getColumnIndex ( " columnString " ) ) { 
 + throw new IllegalStateException ( " Primary key not defined for field ' columnString ' " ) ; 
 + } 
 + if ( ! table . hasIndex ( table . getColumnIndex ( " columnString " ) ) ) { 
 + throw new IllegalStateException ( " Index not defined for field ' columnString ' " ) ; 
 + } 
 if ( ! columnTypes . containsKey ( " columnLong " ) ) { 
 throw new IllegalStateException ( " Missing column ' columnLong ' " ) ; 
 } 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmMigrationTests . java b / realm / src / androidTest / java / io / realm / RealmMigrationTests . java 
 index 680965a . . ab6a946 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmMigrationTests . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmMigrationTests . java 
 @ @ - 2 , 13 + 2 , 34 @ @ package io . realm ; 
 
 import android . test . AndroidTestCase ; 
 
 + import java . io . File ; 
 import java . io . IOException ; 
 
 import io . realm . entities . AllTypes ; 
 + import io . realm . entities . AnnotationTypes ; 
 import io . realm . exceptions . RealmMigrationNeededException ; 
 + import io . realm . internal . ColumnType ; 
 + import io . realm . internal . Table ; 
 
 public class RealmMigrationTests extends AndroidTestCase { 
 
 + public Realm realm ; 
 + 
 + @ Override 
 + protected void setUp ( ) throws Exception { 
 + super . setUp ( ) ; 
 + Realm . setSchema ( null ) ; 
 + Realm . deleteRealmFile ( getContext ( ) ) ; 
 + } 
 + 
 + @ Override 
 + protected void tearDown ( ) throws Exception { 
 + super . tearDown ( ) ; 
 + if ( realm ! = null ) { 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 public void testRealmClosedAfterMigrationException ( ) throws IOException { 
 String REALM _ NAME = " default0 . realm " ; 
 Realm . deleteRealmFile ( getContext ( ) , REALM _ NAME ) ; 
 @ @ - 25 , 4 + 46 , 70 @ @ public class RealmMigrationTests extends AndroidTestCase { 
 int result = realm . where ( AllTypes . class ) . equalTo ( " columnString " , " Foo " ) . findAll ( ) . size ( ) ; 
 assertEquals ( 0 , result ) ; 
 } 
 + 
 + public void testNotSettingIndexThrows ( ) { 
 + Realm . setSchema ( AnnotationTypes . class ) ; 
 + Realm . migrateRealmAtPath ( new File ( getContext ( ) . getFilesDir ( ) , " default . realm " ) . getAbsolutePath ( ) , new RealmMigration ( ) { 
 + @ Override 
 + public long execute ( Realm realm , long version ) { 
 + Table table = realm . getTable ( AnnotationTypes . class ) ; 
 + table . addColumn ( ColumnType . INTEGER , " id " ) ; 
 + table . setPrimaryKey ( " id " ) ; 
 + table . addColumn ( ColumnType . STRING , " indexString " ) ; 
 + table . addColumn ( ColumnType . STRING , " notIndexString " ) ; 
 + / / Forget to set @ Index 
 + return 1 ; 
 + } 
 + } ) ; 
 + 
 + try { 
 + realm = Realm . getInstance ( getContext ( ) ) ; 
 + fail ( ) ; 
 + } catch ( RealmMigrationNeededException expected ) { 
 + } 
 + } 
 + 
 + public void testNotSettingPrimaryKeyThrows ( ) { 
 + Realm . setSchema ( AnnotationTypes . class ) ; 
 + Realm . migrateRealmAtPath ( new File ( getContext ( ) . getFilesDir ( ) , " default . realm " ) . getAbsolutePath ( ) , new RealmMigration ( ) { 
 + @ Override 
 + public long execute ( Realm realm , long version ) { 
 + Table table = realm . getTable ( AnnotationTypes . class ) ; 
 + table . addColumn ( ColumnType . INTEGER , " id " ) ; 
 + / / Forget to set @ PrimaryKey 
 + long columnIndex = table . addColumn ( ColumnType . STRING , " indexString " ) ; 
 + table . setIndex ( columnIndex ) ; 
 + table . addColumn ( ColumnType . STRING , " notIndexString " ) ; 
 + return 1 ; 
 + } 
 + } ) ; 
 + 
 + try { 
 + realm = Realm . getInstance ( getContext ( ) ) ; 
 + fail ( ) ; 
 + } catch ( RealmMigrationNeededException expected ) { 
 + } 
 + } 
 + 
 + public void testSetAnnotations ( ) { 
 + Realm . setSchema ( AnnotationTypes . class ) ; 
 + Realm . migrateRealmAtPath ( new File ( getContext ( ) . getFilesDir ( ) , " default . realm " ) . getAbsolutePath ( ) , new RealmMigration ( ) { 
 + @ Override 
 + public long execute ( Realm realm , long version ) { 
 + Table table = realm . getTable ( AnnotationTypes . class ) ; 
 + table . addColumn ( ColumnType . INTEGER , " id " ) ; 
 + table . setPrimaryKey ( " id " ) ; 
 + long columnIndex = table . addColumn ( ColumnType . STRING , " indexString " ) ; 
 + table . setIndex ( columnIndex ) ; 
 + table . addColumn ( ColumnType . STRING , " notIndexString " ) ; 
 + return 1 ; 
 + } 
 + } ) ; 
 + 
 + realm = Realm . getInstance ( getContext ( ) ) ; 
 + Table table = realm . getTable ( AnnotationTypes . class ) ; 
 + assertEquals ( 3 , table . getColumnCount ( ) ) ; 
 + assertTrue ( table . hasPrimaryKey ( ) ) ; 
 + assertTrue ( table . hasIndex ( table . getColumnIndex ( " indexString " ) ) ) ; 
 + } 
 }
