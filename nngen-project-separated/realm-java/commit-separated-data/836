BLEU SCORE: 0.012079826799606154

TEST MSG: Access to RealmResults based on deleted RealmList
GENERATED MSG: POC async query , using Core ' fsa _ handover _ demo ' branch

TEST DIFF (one line): diff - - git a / realm / realm - jni / src / io _ realm _ internal _ Util . cpp b / realm / realm - jni / src / io _ realm _ internal _ Util . cpp <nl> index 03d298a . . 0d6144d 100644 <nl> - - - a / realm / realm - jni / src / io _ realm _ internal _ Util . cpp <nl> + + + b / realm / realm - jni / src / io _ realm _ internal _ Util . cpp <nl> @ @ - 169 , 7 + 169 , 11 @ @ JNIEXPORT jstring JNICALL Java _ io _ realm _ internal _ Util _ nativeTestcase ( <nl> if ( dotest ) <nl> ThrowException ( env , BadVersion , " parm1 " , " parm2 " ) ; <nl> break ; <nl> - <nl> + case DeletedLinkViewException : <nl> + expect = " io . realm . internal . DeletedRealmListException : parm1 " ; <nl> + if ( dotest ) <nl> + ThrowException ( env , DeletedLinkViewException , " parm1 " , " parm2 " ) ; <nl> + break ; <nl> } <nl> if ( dotest ) { <nl> return NULL ; <nl> diff - - git a / realm / realm - jni / src / io _ realm _ internal _ tableview . cpp b / realm / realm - jni / src / io _ realm _ internal _ tableview . cpp <nl> index 84f33a6 . . 3e1a612 100644 <nl> - - - a / realm / realm - jni / src / io _ realm _ internal _ tableview . cpp <nl> + + + b / realm / realm - jni / src / io _ realm _ internal _ tableview . cpp <nl> @ @ - 24 , 22 + 24 , 36 @ @ <nl> <nl> using namespace realm ; <nl> <nl> - / / if you disable the validation , please remember to call sync _ in _ needed ( ) <nl> - # define VIEW _ VALID _ AND _ IN _ SYNC ( env , ptr ) view _ valid _ and _ in _ sync ( env , ptr ) <nl> + / / The validation will try to sync the table view as well . <nl> + / / if you disable the validation , please remember to call sync _ if _ needed ( ) <nl> + # define VIEW _ VALID _ AND _ IN _ SYNC ( env , ptr ) ( is _ view _ valid ( env , ptr ) & & sync _ table _ view ( env , ptr ) ) <nl> + <nl> + inline bool is _ view _ valid ( JNIEnv * env , jlong nativeViewPtr ) { <nl> + if ( TV ( nativeViewPtr ) = = NULL ) { <nl> + / / Should never get here <nl> + ThrowException ( env , FatalError , " Null pointer of table view . " ) ; <nl> + return false ; <nl> + } <nl> + if ( ! TV ( nativeViewPtr ) - > is _ attached ( ) ) { <nl> + ThrowException ( env , TableInvalid , " The Realm has been closed and is no longer accessible . " ) ; <nl> + return false ; <nl> + } <nl> + return true ; <nl> + } <nl> <nl> - inline bool view _ valid _ and _ in _ sync ( JNIEnv * env , jlong nativeViewPtr ) { <nl> - bool valid = ( TV ( nativeViewPtr ) ! = NULL ) ; <nl> - if ( valid ) { <nl> - if ( ! TV ( nativeViewPtr ) - > is _ attached ( ) ) { <nl> - ThrowException ( env , TableInvalid , " The Realm has been closed and is no longer accessible . " ) ; <nl> - return false ; <nl> - } <nl> + / / Sync the TableView and return false if sync failed . <nl> + inline bool sync _ table _ view ( JNIEnv * / * env * / , jlong nativeViewPtr ) { <nl> + try { <nl> TV ( nativeViewPtr ) - > sync _ if _ needed ( ) ; <nl> + } catch ( realm : : DeletedLinkView & ) { <nl> + / / FIXME : Temp fix for https : / / github . com / realm / realm - core / pull / 1434 <nl> + / / Better solution would be core only throw the exception when really necessary , methods like size <nl> + / / should just return 0 . <nl> + return false ; <nl> } <nl> - return valid ; <nl> + return true ; <nl> } <nl> <nl> - <nl> JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableView _ createNativeTableView ( <nl> JNIEnv * env , jobject , jobject , jlong ) <nl> { <nl> @ @ - 105 , 10 + 119 , 16 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetSourceRowIndex <nl> ( JNIEnv * env , jobject , jlong nativeViewPtr , jlong rowIndex ) <nl> { <nl> try { <nl> - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) ) <nl> - return 0 ; <nl> + if ( ! is _ view _ valid ( env , nativeViewPtr ) ) { <nl> + return npos ; <nl> + } <nl> + if ( ! sync _ table _ view ( env , nativeViewPtr ) ) { <nl> + TR _ ERR ( " The source LinkView created this TableView has been deleted . " ) ; <nl> + / / Let it fall through . Since the size will return 0 , an ArrayIndexOutOfBoundsException <nl> + / / will be thrown in ROW _ INDEX _ VALID check . <nl> + } <nl> if ( ! ROW _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , rowIndex ) ) <nl> - return 0 ; <nl> + return npos ; <nl> } CATCH _ STD ( ) <nl> return TV ( nativeViewPtr ) - > get _ source _ ndx ( S ( rowIndex ) ) ; / / noexcept <nl> } <nl> @ @ - 117 , 7 + 137 , 8 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetColumnCount <nl> ( JNIEnv * env , jobject , jlong nativeViewPtr ) <nl> { <nl> try { <nl> - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) ) <nl> + / / No need to sync here . <nl> + if ( ! is _ view _ valid ( env , nativeViewPtr ) ) <nl> return 0 ; <nl> } CATCH _ STD ( ) <nl> return TV ( nativeViewPtr ) - > get _ column _ count ( ) ; <nl> @ @ - 127 , 7 + 148 , 8 @ @ JNIEXPORT jstring JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetColumnName <nl> ( JNIEnv * env , jobject , jlong nativeViewPtr , jlong columnIndex ) <nl> { <nl> try { <nl> - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) | | ! COL _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , columnIndex ) ) <nl> + / / No need to sync here . <nl> + if ( ! is _ view _ valid ( env , nativeViewPtr ) | | ! COL _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , columnIndex ) ) <nl> return NULL ; <nl> return to _ jstring ( env , TV ( nativeViewPtr ) - > get _ column _ name ( S ( columnIndex ) ) ) ; <nl> } CATCH _ STD ( ) <nl> @ @ - 138 , 8 + 160 , 9 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetColumnIndex <nl> ( JNIEnv * env , jobject , jlong nativeViewPtr , jstring columnName ) <nl> { <nl> try { <nl> - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) ) <nl> - return 0 ; <nl> + / / No need to sync here . <nl> + if ( ! is _ view _ valid ( env , nativeViewPtr ) ) <nl> + return 0 ; <nl> <nl> JStringAccessor columnName2 ( env , columnName ) ; / / throws <nl> return to _ jlong _ or _ not _ found ( TV ( nativeViewPtr ) - > get _ column _ index ( columnName2 ) ) ; / / noexcept <nl> @ @ - 151 , 7 + 174 , 8 @ @ JNIEXPORT jint JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetColumnType <nl> ( JNIEnv * env , jobject , jlong nativeViewPtr , jlong columnIndex ) <nl> { <nl> try { <nl> - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) | | ! COL _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , columnIndex ) ) <nl> + / / No need to sync here . <nl> + if ( ! is _ view _ valid ( env , nativeViewPtr ) | | ! COL _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , columnIndex ) ) <nl> return 0 ; <nl> } CATCH _ STD ( ) <nl> return static _ cast < int > ( TV ( nativeViewPtr ) - > get _ column _ type ( S ( columnIndex ) ) ) ; <nl> diff - - git a / realm / realm - jni / src / util . cpp b / realm / realm - jni / src / util . cpp <nl> index a8bad14 . . c20a02d 100644 <nl> - - - a / realm / realm - jni / src / util . cpp <nl> + + + b / realm / realm - jni / src / util . cpp <nl> @ @ - 53 , 6 + 53 , 10 @ @ void ConvertException ( JNIEnv * env , const char * file , int line ) <nl> ss < < e . what ( ) < < " in " < < file < < " line " < < line ; <nl> ThrowException ( env , BadVersion , ss . str ( ) ) ; <nl> } <nl> + catch ( realm : : DeletedLinkView & e ) { <nl> + ss < < e . what ( ) < < " in " < < file < < " line " < < line ; <nl> + ThrowException ( env , DeletedLinkViewException , ss . str ( ) ) ; <nl> + } <nl> catch ( std : : exception & e ) { <nl> ss < < e . what ( ) < < " in " < < file < < " line " < < line ; <nl> ThrowException ( env , FatalError , ss . str ( ) ) ; <nl> @ @ - 152 , 6 + 156 , 11 @ @ void ThrowException ( JNIEnv * env , ExceptionKind exception , const std : : string & cla <nl> jExceptionClass = env - > FindClass ( " io / realm / internal / async / BadVersionException " ) ; <nl> message = classStr ; <nl> break ; <nl> + <nl> + case DeletedLinkViewException : <nl> + jExceptionClass = env - > FindClass ( " io / realm / internal / DeletedRealmListException " ) ; <nl> + message = classStr ; <nl> + break ; <nl> } <nl> if ( jExceptionClass ! = NULL ) { <nl> env - > ThrowNew ( jExceptionClass , message . c _ str ( ) ) ; <nl> @ @ - 315 , 7 + 324 , 7 @ @ jstring to _ jstring ( JNIEnv * env , StringData str ) <nl> if ( str . is _ null ( ) ) { <nl> return NULL ; <nl> } <nl> - <nl> + <nl> / / For efficiency , if the incoming UTF - 8 string is sufficiently <nl> / / small , we will attempt to store the UTF - 16 output into a stack <nl> / / allocated buffer of static size . Otherwise we will have to <nl> @ @ - 346 , 7 + 355 , 7 @ @ jstring to _ jstring ( JNIEnv * env , StringData str ) <nl> const char * in _ begin2 = in _ begin ; <nl> size _ t error _ code ; <nl> size _ t size = Xcode : : find _ utf16 _ buf _ size ( in _ begin2 , in _ end , error _ code ) ; <nl> - if ( in _ begin2 ! = in _ end ) <nl> + if ( in _ begin2 ! = in _ end ) <nl> throw runtime _ error ( string _ to _ hex ( " Failure when computing UTF - 16 size " , str , in _ begin , in _ end , out _ curr , out _ end , size , error _ code ) ) ; <nl> if ( int _ add _ with _ overflow _ detect ( size , stack _ buf _ size ) ) <nl> throw runtime _ error ( " String size overflow " ) ; <nl> @ @ - 355 , 7 + 364 , 7 @ @ jstring to _ jstring ( JNIEnv * env , StringData str ) <nl> out _ begin = dyn _ buf . get ( ) ; <nl> out _ end = dyn _ buf . get ( ) + size ; <nl> size _ t retcode = Xcode : : to _ utf16 ( in _ begin , in _ end , out _ curr , out _ end ) ; <nl> - if ( retcode ! = 0 ) <nl> + if ( retcode ! = 0 ) <nl> throw runtime _ error ( string _ to _ hex ( " Failure when converting long string to UTF - 16 " , str , in _ begin , in _ end , out _ curr , out _ end , size _ t ( 0 ) , retcode ) ) ; <nl> REALM _ ASSERT ( in _ begin = = in _ end ) ; <nl> } <nl> diff - - git a / realm / realm - jni / src / util . hpp b / realm / realm - jni / src / util . hpp <nl> index e976306 . . 18c31ce 100644 <nl> - - - a / realm / realm - jni / src / util . hpp <nl> + + + b / realm / realm - jni / src / util . hpp <nl> @ @ - 121 , 7 + 121 , 8 @ @ enum ExceptionKind { <nl> RuntimeError = 12 , <nl> RowInvalid = 13 , <nl> CrossTableLink = 15 , <nl> - BadVersion = 16 <nl> + BadVersion = 16 , <nl> + DeletedLinkViewException = 17 <nl> / / NOTE ! ! ! ! : Please also add test cases to Util . java when introducing a new exception kind . <nl> } ; <nl> <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTest . java <nl> index 67269e5 . . 57be8fe 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTest . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTest . java <nl> @ @ - 280 , 9 + 280 , 9 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> TestHelper . populateAllNullRowsForNumericTesting ( testRealm ) ; <nl> <nl> RealmResults < NullTypes > results = testRealm . where ( NullTypes . class ) . findAll ( ) ; <nl> - assertNull ( results . max ( NullTypes . FIELD _ INTEGER _ NULL ) ) ; <nl> - assertNull ( results . max ( NullTypes . FIELD _ FLOAT _ NULL ) ) ; <nl> - assertNull ( results . max ( NullTypes . FIELD _ DOUBLE _ NULL ) ) ; <nl> + assertNull ( results . min ( NullTypes . FIELD _ INTEGER _ NULL ) ) ; <nl> + assertNull ( results . min ( NullTypes . FIELD _ FLOAT _ NULL ) ) ; <nl> + assertNull ( results . min ( NullTypes . FIELD _ DOUBLE _ NULL ) ) ; <nl> assertNull ( results . maxDate ( NullTypes . FIELD _ DATE _ NULL ) ) ; <nl> } <nl> <nl> @ @ - 1146 , 4 + 1146 , 100 @ @ public class RealmResultsTest extends AndroidTestCase { <nl> assertEquals ( 10 , testRealm . where ( AllTypes . class ) . lessThanOrEqualTo ( AllTypes . FIELD _ LONG , - 1 ) . findAll ( ) . size ( ) ) ; <nl> assertEquals ( 10 , testRealm . where ( AllTypes . class ) . lessThan ( AllTypes . FIELD _ LONG , 0 ) . findAll ( ) . size ( ) ) ; <nl> } <nl> + <nl> + private RealmResults < Dog > populateRealmResultsOnDeletedLinkView ( ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + Owner owner = testRealm . createObject ( Owner . class ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) { <nl> + Dog dog = new Dog ( ) ; <nl> + dog . setName ( " name _ " + i ) ; <nl> + dog . setOwner ( owner ) ; <nl> + owner . getDogs ( ) . add ( dog ) ; <nl> + } <nl> + testRealm . commitTransaction ( ) ; <nl> + <nl> + <nl> + RealmResults < Dog > dogs = owner . getDogs ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; <nl> + / / dogs = dogs . where ( ) . findFirst ( ) . getOwner ( ) . getDogs ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; <nl> + <nl> + testRealm . beginTransaction ( ) ; <nl> + owner . removeFromRealm ( ) ; <nl> + testRealm . commitTransaction ( ) ; <nl> + return dogs ; <nl> + } <nl> + <nl> + public void testisValidResultsBuiltOnDeletedLinkView ( ) { <nl> + assertEquals ( false , populateRealmResultsOnDeletedLinkView ( ) . isValid ( ) ) ; <nl> + } <nl> + <nl> + public void testSizeResultsBuiltOnDeletedLinkView ( ) { <nl> + assertEquals ( 0 , populateRealmResultsOnDeletedLinkView ( ) . size ( ) ) ; <nl> + } <nl> + <nl> + public void testFirstResultsBuiltOnDeletedLinkView ( ) { <nl> + try { <nl> + populateRealmResultsOnDeletedLinkView ( ) . first ( ) ; <nl> + } catch ( ArrayIndexOutOfBoundsException ignored ) { <nl> + } <nl> + } <nl> + <nl> + public void testLastResultsBuiltOnDeletedLinkView ( ) { <nl> + try { <nl> + populateRealmResultsOnDeletedLinkView ( ) . last ( ) ; <nl> + } catch ( ArrayIndexOutOfBoundsException ignored ) { <nl> + } <nl> + } <nl> + <nl> + public void testSumResultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + assertEquals ( 0 , dogs . sum ( Dog . FIELD _ AGE ) . intValue ( ) ) ; <nl> + assertEquals ( 0f , dogs . sum ( Dog . FIELD _ HEIGHT ) . floatValue ( ) , 0f ) ; <nl> + assertEquals ( 0d , dogs . sum ( Dog . FIELD _ WEIGHT ) . doubleValue ( ) , 0d ) ; <nl> + } <nl> + <nl> + public void testAverageResultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + assertEquals ( 0d , dogs . average ( Dog . FIELD _ AGE ) , 0d ) ; <nl> + assertEquals ( 0d , dogs . average ( Dog . FIELD _ HEIGHT ) , 0d ) ; <nl> + assertEquals ( 0d , dogs . average ( Dog . FIELD _ WEIGHT ) , 0d ) ; <nl> + } <nl> + <nl> + public void testClearResultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + testRealm . beginTransaction ( ) ; <nl> + dogs . clear ( ) ; <nl> + assertEquals ( 0 , dogs . size ( ) ) ; <nl> + testRealm . commitTransaction ( ) ; <nl> + } <nl> + <nl> + public void testMaxResultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + assertNull ( dogs . max ( Dog . FIELD _ AGE ) ) ; <nl> + assertNull ( dogs . max ( Dog . FIELD _ HEIGHT ) ) ; <nl> + assertNull ( dogs . max ( Dog . FIELD _ WEIGHT ) ) ; <nl> + } <nl> + <nl> + public void testMaxDateResultsBuiltOnDeletedLinkView ( ) { <nl> + assertEquals ( null , populateRealmResultsOnDeletedLinkView ( ) . maxDate ( Dog . FIELD _ BIRTHDAY ) ) ; <nl> + } <nl> + <nl> + public void testMinResultsBuiltOnDeletedLinkView ( ) { <nl> + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; <nl> + assertNull ( dogs . min ( Dog . FIELD _ AGE ) ) ; <nl> + assertNull ( dogs . min ( Dog . FIELD _ HEIGHT ) ) ; <nl> + assertNull ( dogs . min ( Dog . FIELD _ WEIGHT ) ) ; <nl> + } <nl> + <nl> + public void testMinDateResultsBuiltOnDeletedLinkView ( ) { <nl> + assertEquals ( null , populateRealmResultsOnDeletedLinkView ( ) . minDate ( Dog . FIELD _ BIRTHDAY ) ) ; <nl> + } <nl> + <nl> + public void testWhereResultsBuiltOnDeletedLinkView ( ) { <nl> + try { <nl> + populateRealmResultsOnDeletedLinkView ( ) . where ( ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalStateException e ) { <nl> + assertEquals ( " The RealmList which this RealmResults is created on has been deleted . " , e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / TypeBasedNotificationsTest . java b / realm / realm - library / src / androidTest / java / io / realm / TypeBasedNotificationsTest . java <nl> index 1c22ad1 . . 60da724 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / TypeBasedNotificationsTest . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / TypeBasedNotificationsTest . java <nl> @ @ - 27 , 7 + 27 , 6 @ @ import java . io . IOException ; <nl> import java . io . InputStream ; <nl> import java . lang . ref . WeakReference ; <nl> import java . util . Date ; <nl> - import java . util . WeakHashMap ; <nl> import java . util . concurrent . CountDownLatch ; <nl> import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> @ @ - 1827 , 8 + 1826 , 8 @ @ public class TypeBasedNotificationsTest extends AndroidTestCase { <nl> / / Check if cat has been added to the realmObjects in case of the behaviour of getCat changes <nl> for ( WeakReference < RealmObject > weakReference : realm . handlerController . realmObjects . keySet ( ) ) { <nl> if ( weakReference . get ( ) = = cat ) { <nl> - foundKey = true ; <nl> - break ; <nl> + foundKey = true ; <nl> + break ; <nl> } <nl> } <nl> assertTrue ( foundKey ) ; <nl> @ @ - 1890 , 4 + 1889 , 58 @ @ public class TypeBasedNotificationsTest extends AndroidTestCase { <nl> <nl> finishedLatch . await ( ) ; <nl> } <nl> + <nl> + / / Build a RealmResults from a RealmList , and delete the RealmList . Test the behavior of ChangeListener on the <nl> + / / " invalid " RealmResults . <nl> + public void test _ changeListener _ onResultsBuiltOnDeletedLinkView ( ) { <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + realm = Realm . getInstance ( configuration ) ; <nl> + realm . beginTransaction ( ) ; <nl> + AllTypes allTypes = realm . createObject ( AllTypes . class ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) { <nl> + Dog dog = new Dog ( ) ; <nl> + dog . setName ( " name _ " + i ) ; <nl> + allTypes . getColumnRealmList ( ) . add ( dog ) ; <nl> + } <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + final RealmResults < Dog > dogs = <nl> + allTypes . getColumnRealmList ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; <nl> + dogs . addChangeListener ( new RealmChangeListener ( ) { <nl> + @ Override <nl> + public void onChange ( ) { <nl> + if ( typebasedCommitInvocations . getAndIncrement ( ) = = 0 ) { <nl> + assertFalse ( dogs . isValid ( ) ) ; <nl> + assertEquals ( 0 , dogs . size ( ) ) ; <nl> + } else { <nl> + fail ( " This listener should only be called once . " ) ; <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + / / Trigger the listener at the first time . <nl> + realm . beginTransaction ( ) ; <nl> + allTypes . removeFromRealm ( ) ; <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + / / Try to trigger the listener second time . <nl> + realm . beginTransaction ( ) ; <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + / / Close the realm and finish the test . This needs to follow the REALM _ CHANGED in the queue . <nl> + handler . post ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + realm . close ( ) ; <nl> + signalTestFinished . countDown ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + TestHelper . awaitOrFail ( signalTestFinished ) ; <nl> + assertEquals ( 1 , typebasedCommitInvocations . get ( ) ) ; <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java b / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java <nl> index 753db7f . . d6b2046 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java <nl> @ @ - 26 , 6 + 26 , 10 @ @ public class Dog extends RealmObject { <nl> <nl> public static final String CLASS _ NAME = " Dog " ; <nl> public static final String FIELD _ NAME = " name " ; <nl> + public static final String FIELD _ AGE = " age " ; <nl> + public static final String FIELD _ HEIGHT = " height " ; <nl> + public static final String FIELD _ WEIGHT = " weight " ; <nl> + public static final String FIELD _ BIRTHDAY = " birthday " ; <nl> <nl> @ Index <nl> private String name ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> index 1e7a50d . . 6b13240 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . Future ; <nl> <nl> import io . realm . exceptions . RealmException ; <nl> + import io . realm . internal . DeletedRealmListException ; <nl> import io . realm . internal . TableOrView ; <nl> import io . realm . internal . TableQuery ; <nl> import io . realm . internal . TableView ; <nl> @ @ - 51 , 6 + 52 , 10 @ @ import rx . Observable ; <nl> * < p > <nl> * Notice that a RealmResults is never { @ code null } not even in the case where it contains no objects . You should always <nl> * use the size ( ) method to check if a RealmResults is empty or not . <nl> + * < p > <nl> + * If a RealmResults is built on RealmList through { @ link RealmList # where ( ) } , it will become invalid when the source <nl> + * RealmList gets deleted . When that happens , the RealmResults will behave like a empty RealmResults , but calling <nl> + * { @ link # where ( ) } will throw an { @ link IllegalStateException } . Use { @ link # isValid } to detect this situation . <nl> * <nl> * @ param < E > The class of objects in this list . <nl> * @ see RealmQuery # findAll ( ) <nl> @ @ - 65 , 7 + 70 , 9 @ @ public final class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> private TableOrView table = null ; <nl> <nl> private static final String TYPE _ MISMATCH = " Field ' % s ' : type mismatch - % s expected . " ; <nl> - private long currentTableViewVersion = - 1 ; <nl> + private static final long TABLE _ VIEW _ VERSION _ NONE = - 1 ; <nl> + private static final long TABLE _ VIEW _ VERSION _ REALM _ LIST _ DELETED = - 2 ; <nl> + private long currentTableViewVersion = TABLE _ VIEW _ VERSION _ NONE ; <nl> <nl> private final TableQuery query ; <nl> private final List < RealmChangeListener > listeners = new CopyOnWriteArrayList < RealmChangeListener > ( ) ; <nl> @ @ - 138 , 7 + 145 , 11 @ @ public final class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ return { @ code true } if still valid to use , { @ code false } otherwise . <nl> * / <nl> public boolean isValid ( ) { <nl> - return realm ! = null & & ! realm . isClosed ( ) ; <nl> + if ( realm = = null | | realm . isClosed ( ) ) { <nl> + return false ; <nl> + } <nl> + <nl> + return syncToCheckIfValid ( " Calling isValid on RealmResults whose parent RealmList has been deleted already . " ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 146 , 9 + 157 , 14 @ @ public final class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * <nl> * @ return a typed RealmQuery . <nl> * @ see io . realm . RealmQuery <nl> + * @ throws IllegalStateException if the RealmList which this RealmResults is created on has been deleted . <nl> * / <nl> public RealmQuery < E > where ( ) { <nl> realm . checkIfValid ( ) ; <nl> + <nl> + if ( ! syncToCheckIfValid ( " Calling where on RealmResults whose parent RealmList has been deleted already . " ) ) { <nl> + throw new IllegalStateException ( " The RealmList which this RealmResults is created on has been deleted . " ) ; <nl> + } <nl> return RealmQuery . createQueryFromResult ( this ) ; <nl> } <nl> <nl> @ @ - 856 , 13 + 872 , 45 @ @ public final class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> / / FIXME : still waiting for Core to provide a fix <nl> / / for crash when calling _ sync _ if _ needed on a cleared View . <nl> / / https : / / github . com / realm / realm - core / pull / 1390 <nl> - long version = table . sync ( ) ; <nl> + long version ; <nl> + try { <nl> + version = table . sync ( ) ; <nl> + } catch ( DeletedRealmListException e ) { <nl> + / / Although this RealmResults won ' t be updated anymore , it is good to give user a chance to do update . <nl> + / / When the onChange called this time , user can use isValid to check if the RealmList has been deleted . <nl> + version = TABLE _ VIEW _ VERSION _ REALM _ LIST _ DELETED ; <nl> + RealmLog . d ( " The parent RealmList has been deleted already . " ) ; <nl> + } <nl> if ( currentTableViewVersion ! = version ) { <nl> currentTableViewVersion = version ; <nl> for ( RealmChangeListener listener : listeners ) { <nl> listener . onChange ( ) ; <nl> } <nl> } <nl> + <nl> + / / Since the parent RealmList has been removed , this RealmResults won ' t be updated anymore . <nl> + / / We just remove the change listeners from this to avoid unnecessary callings in the future . <nl> + if ( version = = TABLE _ VIEW _ VERSION _ REALM _ LIST _ DELETED ) { <nl> + listeners . clear ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / / FIXME : This is a temp fix , see https : / / github . com / realm / realm - core / pull / 1434 <nl> + private boolean syncToCheckIfValid ( String warningMessage ) { <nl> + if ( currentTableViewVersion = = TABLE _ VIEW _ VERSION _ REALM _ LIST _ DELETED ) { <nl> + RealmLog . d ( warningMessage ) ; <nl> + return false ; <nl> + } <nl> + TableOrView tableOrView = getTable ( ) ; <nl> + if ( tableOrView instanceof TableView ) { <nl> + try { <nl> + tableOrView . sync ( ) ; <nl> + } catch ( DeletedRealmListException e ) { <nl> + RealmLog . d ( warningMessage ) ; <nl> + return false ; <nl> + } <nl> } <nl> + return true ; <nl> } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / DeletedRealmListException . java b / realm / realm - library / src / main / java / io / realm / internal / DeletedRealmListException . java <nl> new file mode 100644 <nl> index 0000000 . . 308dfbc <nl> - - - / dev / null <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / DeletedRealmListException . java <nl> @ @ - 0 , 0 + 1 , 28 @ @ <nl> + / * <nl> + * Copyright 2016 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package io . realm . internal ; <nl> + <nl> + import io . realm . exceptions . RealmException ; <nl> + <nl> + / * * <nl> + * Triggered from JNI level when accessing a RealmResults whose parent RealmList has been deleted already . <nl> + * / <nl> + @ Keep <nl> + public class DeletedRealmListException extends RealmException { <nl> + public DeletedRealmListException ( String detailMessage ) { <nl> + super ( detailMessage ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / Util . java b / realm / realm - library / src / main / java / io / realm / internal / Util . java <nl> index 1f409e1 . . 632a9f6 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / Util . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / Util . java <nl> @ @ - 64 , 7 + 64 , 8 @ @ public class Util { <nl> Exception _ RowInvalid ( 13 ) , <nl> Exception _ EncryptionNotSupported ( 14 ) , <nl> Exception _ CrossTableLink ( 15 ) , <nl> - Exception _ BadVersion ( 16 ) ; <nl> + Exception _ BadVersion ( 16 ) , <nl> + Exception _ DeletedLinkView ( 17 ) ; <nl> <nl> private final int nativeTestcase ; <nl> Testcase ( int nativeValue ) {
NEAREST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index 1912025 . . 4d02c8a 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * Fixed unchecked cast warnings when building with Realm . <nl> * Cleaned up examples ( remove old test project ) . <nl> * Added checking for missing generic type in RealmList fields in annotation processor . <nl> + * Support async queries <nl> <nl> 0 . 80 . 3 <nl> * Calling Realm . copyToRealmOrUpdate ( ) with an object with a null primary key now throws a proper exception . <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> index bb26d54 . . 3cad125 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> @ @ - 14 , 12 + 14 , 14 @ @ <nl> * limitations under the License . <nl> * / <nl> <nl> + # include < realm / group _ shared . hpp > <nl> # include " util . hpp " <nl> # include " io _ realm _ internal _ TableQuery . h " <nl> # include " tablequery . hpp " <nl> <nl> using namespace realm ; <nl> <nl> + # define SG ( ptr ) reinterpret _ cast < SharedGroup * > ( ptr ) <nl> # if 1 <nl> # define COL _ TYPE _ VALID ( env , ptr , col , type ) TBL _ AND _ COL _ INDEX _ AND _ TYPE _ VALID ( env , ptr , col , type ) <nl> # define COL _ TYPE _ LINK _ OR _ LINKLIST ( env , ptr , col ) TBL _ AND _ COL _ INDEX _ AND _ LINK _ OR _ LINKLIST ( env , ptr , col ) <nl> @ @ - 1174 , 3 + 1176 , 47 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNull ( <nl> pQuery - > and _ query ( query ) ; <nl> } CATCH _ STD ( ) <nl> } <nl> + <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover <nl> + ( JNIEnv * env , jobject , jlong callerSharedGrpPtr , jlong bgSharedGroupPtr , jlong nativeQueryPtr , jlong start , jlong end , jlong limit ) <nl> + { <nl> + Query * pQuery = Q ( nativeQueryPtr ) ; <nl> + Table * pTable = pQuery - > get _ table ( ) . get ( ) ; <nl> + if ( ! QUERY _ VALID ( env , pQuery ) | | <nl> + ! ROW _ INDEXES _ VALID ( env , pTable , start , end , limit ) ) <nl> + return - 1 ; <nl> + try { <nl> + TableView * pResultView = new TableView ( pQuery - > find _ all ( S ( start ) , S ( end ) , S ( limit ) ) ) ; <nl> + std : : unique _ ptr < SharedGroup : : Handover < TableView > > handover ; <nl> + handover . reset ( SG ( bgSharedGroupPtr ) - > export _ for _ handover ( * pResultView , ConstSourcePayload : : Copy ) ) ; <nl> + / / TODO reimplement this so the call to ' export _ for _ handover ' is done on a background thread <nl> + / / and ' import _ from _ handover ' on the caller thread . <nl> + / / <nl> + / / According to core , it ' s preferable to return first the exported handover <nl> + / / then import it from the calling SharedGroup ( Thread ) . <nl> + / / We need to make sure to check that the version id ( version of the shared group used to perform the query ) <nl> + / / is the same as the caller SharedGroup , otherwise the import will fail . In this case , we should <nl> + / / either retry the entire query , or call again ' sync _ if _ needed ' on the TableView to re - query , at this point <nl> + / / we need to export again the handover to the caller SharedGroup , until we converge <nl> + / / ( i . e the version of the caller SharedGroup matches the version returned by the handover TableView ) <nl> + / / <nl> + / / Note : The mode ' ConstSourcePayload : : Copy ' handover perform a deep copy of the TableView , this means that we copy <nl> + / / both the Payload ( row accessors ) & the Query <nl> + / / <nl> + / / The mode ' ConstSourcePayload : : Stay ' handover perform a copy of the Query only ( no payload ) <nl> + / / The mode ' MutableSourcePayload : : Move ' handover perform a move of both the Payload & Query <nl> + / / <nl> + / / The expensive operations are in that order <nl> + / / pQuery - > find _ all > > export _ for _ handover > > import _ from _ handover <nl> + / / so it ' s recommended to run the ' query ' & the ' export ' on a background Thread , then <nl> + / / call ' import _ from _ handover ' on the caller thread ( most of the time UI thread ) . <nl> + / / calling ' import _ from _ handover ' on the UI thread has another benefit , it will block the SharedGroup <nl> + / / from modifying it ' s state ( advance _ read , promote _ write , rollback , commit etc ) <nl> + / / <nl> + / / The handover pointer is Thread safe , it can be passed from different Threads ( using different SharedGroups ) <nl> + <nl> + TableView * tv ( SG ( callerSharedGrpPtr ) - > import _ from _ handover ( handover . release ( ) ) ) ; <nl> + return reinterpret _ cast < jlong > ( tv ) ; <nl> + } CATCH _ STD ( ) <nl> + return - 1 ; <nl> + } <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> index 5ccb9ee . . 97a9ed7 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> @ @ - 369 , 6 + 369 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAll <nl> <nl> / * <nl> * Class : io _ realm _ internal _ TableQuery <nl> + * Method : nativeFindAllWithHandover <nl> + * Signature : ( JJJJJJ ) J <nl> + * / <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover <nl> + ( JNIEnv * , jobject , jlong , jlong , jlong , jlong , jlong , jlong ) ; <nl> + <nl> + / * <nl> + * Class : io _ realm _ internal _ TableQuery <nl> * Method : nativeSumInt <nl> * Signature : ( JJJJJ ) J <nl> * / <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> new file mode 100644 <nl> index 0000000 . . 162e33a <nl> - - - / dev / null <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 0 , 0 + 1 , 151 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm ; <nl> + <nl> + import android . os . Looper ; <nl> + import android . test . InstrumentationTestCase ; <nl> + <nl> + import junit . framework . AssertionFailedError ; <nl> + <nl> + import java . util . Date ; <nl> + import java . util . concurrent . CountDownLatch ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . Executors ; <nl> + <nl> + import io . realm . entities . AllTypes ; <nl> + import io . realm . entities . NonLatinFieldNames ; <nl> + <nl> + public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> + <nl> + / / TODO use Junit4 & define a rule to setup the threading , to avoid <nl> + / / this boiler plat code , or use a custom test runner <nl> + public void testFindAll ( ) throws Throwable { <nl> + / / We need to control precisely which Looper / Thread our Realm <nl> + / / will operate on . This is unfortunately not possible when using the <nl> + / / current Instrumentation # InstrumentationThread , because InstrumentationTestRunner # onStart <nl> + / / Call Looper . prepare ( ) for us and surprisingly doesn ' t call Looper # loop ( ) , this is problematic <nl> + / / as the async query callback will not run ( because the Handler is sending Runnables to a Looper <nl> + / / that didn ' t loop . <nl> + / / <nl> + / / In the other hand , using a dedicated ' ExecutorService ' will allow us to fine grain control the <nl> + / / desired behaviour <nl> + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final Looper [ ] looper = new Looper [ 1 ] ; <nl> + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + executorService . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + looper [ 0 ] = Looper . myLooper ( ) ; <nl> + Realm realm = null ; <nl> + try { <nl> + realm = openRealmInstance ( ) ; <nl> + populateTestRealm ( realm , 10 ) ; <nl> + <nl> + / / async query ( will run on different thread ) <nl> + realm . asyncWhere ( AllTypes . class , <nl> + new Realm . AsyncCallback < RealmResults < AllTypes > > ( ) { <nl> + @ Override <nl> + public void onSuccess ( RealmResults < AllTypes > results ) { <nl> + try { <nl> + assertEquals ( 10 , results . size ( ) ) ; <nl> + <nl> + / / Make sure access to RealmObject will not throw an Exception <nl> + for ( int i = 0 , size = results . size ( ) ; i < size ; i + + ) { <nl> + assertEquals ( i , results . get ( i ) . getColumnLong ( ) ) ; <nl> + } <nl> + <nl> + } catch ( AssertionFailedError e ) { <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + / / whatever happened , make sure to notify the waiting TestCase Thread <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void onError ( Throwable t ) { <nl> + try { <nl> + threadAssertionError [ 0 ] = t ; <nl> + t . printStackTrace ( ) ; <nl> + } finally { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + } ) <nl> + . between ( " columnLong " , 0 , 9 ) . findAll ( ) ; <nl> + <nl> + Looper . loop ( ) ; / / ready to receive callback <nl> + <nl> + } finally { <nl> + if ( realm ! = null ) { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + / / wait until the callback of our async query proceed <nl> + signalCallbackFinished . await ( ) ; <nl> + looper [ 0 ] . quit ( ) ; <nl> + executorService . shutdownNow ( ) ; <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / Throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + } <nl> + <nl> + / / * * * Helper methods * * * <nl> + <nl> + / / This could be done from # setUp but then we can ' t control <nl> + / / which Looper we want to associate this Realm instance with <nl> + private Realm openRealmInstance ( ) { <nl> + RealmConfiguration realmConfiguration = new RealmConfiguration . <nl> + Builder ( getInstrumentation ( ) <nl> + . getTargetContext ( ) ) <nl> + . name ( " test . realm " ) <nl> + . deleteRealmIfMigrationNeeded ( ) <nl> + . build ( ) ; <nl> + Realm . deleteRealm ( realmConfiguration ) ; <nl> + return Realm . getInstance ( realmConfiguration ) ; <nl> + } <nl> + <nl> + private void populateTestRealm ( final Realm testRealm , int objects ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . allObjects ( AllTypes . class ) . clear ( ) ; <nl> + testRealm . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; <nl> + for ( int i = 0 ; i < objects ; + + i ) { <nl> + AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; <nl> + allTypes . setColumnBoolean ( ( i % 3 ) = = 0 ) ; <nl> + allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; <nl> + allTypes . setColumnDate ( new Date ( ) ) ; <nl> + allTypes . setColumnDouble ( 3 . 1415 ) ; <nl> + allTypes . setColumnFloat ( 1 . 234567f + i ) ; <nl> + allTypes . setColumnString ( " test data " + i ) ; <nl> + allTypes . setColumnLong ( i ) ; <nl> + NonLatinFieldNames nonLatinFieldNames = testRealm . createObject ( NonLatinFieldNames . class ) ; <nl> + nonLatinFieldNames . set 델 타 ( i ) ; <nl> + nonLatinFieldNames . set Δ έ λ τ α ( i ) ; <nl> + nonLatinFieldNames . set 베 타 ( 1 . 234567f + i ) ; <nl> + nonLatinFieldNames . set Β ή τ α ( 1 . 234567f + i ) ; <nl> + } <nl> + testRealm . commitTransaction ( ) ; <nl> + testRealm . refresh ( ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index ca29295 . . d2e5033 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 22 , 7 + 22 , 6 @ @ import org . json . JSONArray ; <nl> import org . json . JSONException ; <nl> import org . json . JSONObject ; <nl> <nl> - import java . io . ByteArrayInputStream ; <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> import java . io . InputStream ; <nl> diff - - git a / realm / src / main / java / io / realm / AsyncRealmQueryResult . java b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java <nl> new file mode 100644 <nl> index 0000000 . . 7318359 <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java <nl> @ @ - 0 , 0 + 1 , 25 @ @ <nl> + package io . realm ; <nl> + <nl> + import java . util . concurrent . Future ; <nl> + <nl> + / * * <nl> + * Represents the result of an asynchronous Realm query . <nl> + * <nl> + * Users are responsible of maintaining a reference to { @ code AsyncRealmQueryResult } in order <nl> + * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the <nl> + * query will post the result to the caller ' s thread callback ) <nl> + * / <nl> + public class AsyncRealmQueryResult { <nl> + final Future < ? > pendingQuery ; <nl> + <nl> + public AsyncRealmQueryResult ( Future < ? > pendingQuery ) { <nl> + this . pendingQuery = pendingQuery ; <nl> + } <nl> + <nl> + / * * <nl> + * Attempts to cancel execution of this queries . <nl> + * / <nl> + public void cancel ( ) { <nl> + pendingQuery . cancel ( true ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index ddbc022 . . 15aac8b 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 63 , 6 + 63 , 7 @ @ import io . realm . internal . SharedGroup ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableView ; <nl> import io . realm . internal . Util ; <nl> + import io . realm . internal . android . AsyncRealmQuery ; <nl> import io . realm . internal . android . DebugAndroidLogger ; <nl> import io . realm . internal . android . ReleaseAndroidLogger ; <nl> import io . realm . internal . log . RealmLog ; <nl> @ @ - 154 , 6 + 155 , 9 @ @ public final class Realm implements Closeable { <nl> private static final Map < String , AtomicInteger > globalOpenInstanceCounter = <nl> new ConcurrentHashMap < String , AtomicInteger > ( ) ; <nl> <nl> + / / Thread Pool for all async operations ( Query & Write transaction ) <nl> + public static final ExecutorService asyncQueryExecutor = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) * 2 + 1 ) ; <nl> + <nl> protected static final Map < Handler , String > handlers = new ConcurrentHashMap < Handler , String > ( ) ; <nl> private static final int REALM _ CHANGED = 14930352 ; / / Hopefully it won ' t clash with other message IDs . <nl> <nl> @ @ - 1198 , 6 + 1202 , 20 @ @ public final class Realm implements Closeable { <nl> } <nl> <nl> / * * <nl> + * Prepare an async query <nl> + * TODO point to documentation or example about async query <nl> + * @ param clazz The class of the object which is to be queried for <nl> + * @ return A typed RealmQuery , which can be used to query for specific objects of this type <nl> + * @ throws java . lang . RuntimeException Any other error <nl> + * @ see io . realm . RealmQuery <nl> + * @ param callback <nl> + * / <nl> + public < E extends RealmObject > AsyncRealmQuery < E > asyncWhere ( Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { <nl> + checkIfValid ( ) ; <nl> + return new AsyncRealmQuery < E > ( this , clazz , callback ) ; <nl> + } <nl> + <nl> + / * * <nl> * Get all objects of a specific Class . If no objects exist , the returned RealmResults will not <nl> * be null . The RealmResults . size ( ) to check the number of objects instead . <nl> * <nl> @ @ - 1872 , 4 + 1890 , 24 @ @ public final class Realm implements Closeable { <nl> void execute ( Realm realm ) ; <nl> } <nl> <nl> + / * * <nl> + * Encapsulates an async { @ link RealmQuery } . <nl> + * < p > <nl> + * This will run the { @ link RealmQuery } on a worker thread , then invoke this callback on the caller thread <nl> + * / <nl> + public interface AsyncCallback < T extends RealmResults < ? extends RealmObject > > { <nl> + void onSuccess ( T results ) ; <nl> + void onError ( Throwable t ) ; <nl> + } <nl> + <nl> + <nl> + / / FIXME Realm . java being the public API and the implementation . <nl> + / / we need a Realm interface to be able to separate this kind of call <nl> + / / ( mostly from internal API / tests that need to access private field / method ) . <nl> + / / RealmImpl will be accessible to other internal packages <nl> + / / but not to the user ( avoid compromising our exposed public API ) <nl> + / / <nl> + public long getSharedGroupPtr ( ) { <nl> + return sharedGroup . nativePtr ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index df847f5 . . b744adc 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1302 , 4 + 1302 , 8 @ @ public class RealmQuery < E extends RealmObject > { <nl> return null ; <nl> } <nl> } <nl> + <nl> + protected TableQuery getTableQuery ( ) { <nl> + return this . query ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / internal / TableQuery . java b / realm / src / main / java / io / realm / internal / TableQuery . java <nl> index e82eaa7 . . 268645d 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / TableQuery . java <nl> + + + b / realm / src / main / java / io / realm / internal / TableQuery . java <nl> @ @ - 493 , 8 + 493 , 24 @ @ public class TableQuery implements Closeable { <nl> } <nl> } <nl> <nl> - protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; <nl> + public TableView findAllWithHandover ( long callerSharedGroupPtr , long bgSharedGroupPtr ) { <nl> + validateQuery ( ) ; <nl> + <nl> + / / Execute the disposal of abandoned realm objects each time a new realm object is created <nl> + context . executeDelayedDisposal ( ) ; <nl> + long nativeViewPtr = nativeFindAllWithHandover ( callerSharedGroupPtr , bgSharedGroupPtr , nativePtr , 0 , Table . INFINITE , Table . INFINITE ) ; / / nativeViewPtr is created from bg Thread <nl> + / / handover nativeViewPtr to UI Thread <nl> + <nl> + try { <nl> + return new TableView ( this . context , this . parent , nativeViewPtr ) ; <nl> + } catch ( RuntimeException e ) { <nl> + TableView . nativeClose ( nativeViewPtr ) ; <nl> + throw e ; <nl> + } <nl> + } <nl> <nl> + protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; <nl> + protected native long nativeFindAllWithHandover ( long nativeCallerSharedGroupPtr , long bgSharedGroupPtr , long nativeQueryPtr , long start , long end , long limit ) ; <nl> / / <nl> / / Aggregation methods <nl> / / <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java <nl> new file mode 100644 <nl> index 0000000 . . c3716eb <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java <nl> @ @ - 0 , 0 + 1 , 165 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . android ; <nl> + <nl> + import android . os . Handler ; <nl> + import android . os . Looper ; <nl> + import android . os . Message ; <nl> + <nl> + import java . util . concurrent . Future ; <nl> + <nl> + import io . realm . AsyncRealmQueryResult ; <nl> + import io . realm . Realm ; <nl> + import io . realm . RealmConfiguration ; <nl> + import io . realm . RealmObject ; <nl> + import io . realm . RealmQuery ; <nl> + import io . realm . RealmResults ; <nl> + import io . realm . internal . TableOrView ; <nl> + import io . realm . internal . TableView ; <nl> + <nl> + import static io . realm . Realm . asyncQueryExecutor ; <nl> + <nl> + / * * <nl> + * A helper class to help make handling asynchronous { @ link RealmQuery } easier . <nl> + * <nl> + * @ param < E > type of the object which is to be queried for <nl> + * / <nl> + / / Behaviour may change , user should not subclass <nl> + public final class AsyncRealmQuery < E extends RealmObject > { <nl> + private final Realm callerRealm ; <nl> + private final Class < E > clazz ; <nl> + private final Realm . AsyncCallback < RealmResults < E > > callback ; <nl> + <nl> + private int from ; <nl> + private int to ; <nl> + private String fieldName ; <nl> + private EventHandler eventHandler ; <nl> + private Future < ? > pendingQuery ; <nl> + <nl> + / * * <nl> + * Create an { @ code AsyncRealmQuery } instance . <nl> + * <nl> + * @ param realm The realm to query within . <nl> + * @ param clazz The class to query . <nl> + * @ param callback invoked on the thread { @ link Realm # asyncWhere ( Class , Realm . AsyncCallback ) } was called from , to post results . <nl> + * / <nl> + public AsyncRealmQuery ( Realm realm , Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { <nl> + this . callerRealm = realm ; <nl> + this . callback = callback ; <nl> + this . clazz = clazz ; <nl> + } <nl> + <nl> + / * * <nl> + * Between condition <nl> + * <nl> + * @ param fieldName The field to compare <nl> + * @ param from Lowest value ( inclusive ) <nl> + * @ param to Highest value ( inclusive ) <nl> + * @ return current instance of { @ code AsyncRealmQuery } for method chaining <nl> + * / <nl> + public AsyncRealmQuery < E > between ( String fieldName , int from , int to ) { <nl> + this . from = from ; <nl> + this . to = to ; <nl> + this . fieldName = fieldName ; <nl> + return this ; <nl> + } <nl> + <nl> + / * * <nl> + * Find all objects that fulfill the query conditions . <nl> + * Results will be posted to the callback instance { @ link io . realm . Realm . AsyncCallback } asynchronously <nl> + * If no objects match the condition , a list with zero objects is returned . <nl> + * <nl> + * @ see io . realm . RealmResults <nl> + * / <nl> + public AsyncRealmQueryResult findAll ( ) { <nl> + / / will use the Looper of the caller thread to post the result <nl> + Looper looper ; <nl> + if ( ( looper = Looper . myLooper ( ) ) ! = null ) { <nl> + eventHandler = new EventHandler ( looper ) ; <nl> + } else if ( ( looper = Looper . getMainLooper ( ) ) ! = null ) { <nl> + eventHandler = new EventHandler ( looper ) ; <nl> + } else { <nl> + eventHandler = null ; / / FIXME define strategy / behaviour for regular JVM call <nl> + } <nl> + <nl> + / / We need a pointer to the caller Realm , to be able to handover the result to it <nl> + final long callerSharedGroupNativePtr = callerRealm . getSharedGroupPtr ( ) ; <nl> + <nl> + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) <nl> + / / to perform the query <nl> + final RealmConfiguration realmConfiguration = callerRealm . getConfiguration ( ) ; <nl> + <nl> + pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + try { <nl> + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> + <nl> + / / TODO This will probably be replace by a kind of ' QueryBuilder ' <nl> + / / that holds all the operations ( predicates / filters ) then <nl> + / / replay them here in this background thread . The current implementation <nl> + / / call Core for each step , we want to limit the overhead by sending one <nl> + / / single call to Core with all the parameters . <nl> + <nl> + TableView tv = new RealmQueryAdapter < E > ( bgRealm , clazz ) <nl> + . between ( fieldName , from , to ) <nl> + . findAll ( callerSharedGroupNativePtr , bgRealm . getSharedGroupPtr ( ) ) ; <nl> + <nl> + bgRealm . close ( ) ; <nl> + <nl> + / / send results to the caller thread ' s callback <nl> + if ( ! pendingQuery . isCancelled ( ) ) { <nl> + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ SUCCESS , tv ) ; <nl> + eventHandler . sendMessage ( msg ) ; <nl> + } <nl> + <nl> + } catch ( Exception e ) { <nl> + if ( ! pendingQuery . isCancelled ( ) ) { <nl> + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ ERROR , e ) ; <nl> + eventHandler . sendMessage ( msg ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + return new AsyncRealmQueryResult ( pendingQuery ) ; <nl> + } <nl> + <nl> + private class EventHandler extends Handler { <nl> + private static final int MSG _ SUCCESS = 1 ; <nl> + private static final int MSG _ ERROR = MSG _ SUCCESS + 1 ; <nl> + <nl> + public EventHandler ( Looper looper ) { <nl> + super ( looper ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void handleMessage ( Message msg ) { <nl> + switch ( msg . what ) { <nl> + case MSG _ SUCCESS : <nl> + RealmResults < E > resultList = new RealmResults < E > ( callerRealm , ( TableOrView ) msg . obj , clazz ) ; <nl> + callback . onSuccess ( resultList ) ; <nl> + break ; <nl> + case MSG _ ERROR : <nl> + callback . onError ( ( Throwable ) msg . obj ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java <nl> new file mode 100644 <nl> index 0000000 . . acac317 <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java <nl> @ @ - 0 , 0 + 1 , 38 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . android ; <nl> + <nl> + import io . realm . Realm ; <nl> + import io . realm . RealmObject ; <nl> + import io . realm . RealmQuery ; <nl> + import io . realm . internal . TableView ; <nl> + <nl> + class RealmQueryAdapter < E extends RealmObject > extends RealmQuery < E > { <nl> + public RealmQueryAdapter ( Realm realm , Class < E > clazz ) { <nl> + super ( realm , clazz ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public RealmQueryAdapter < E > between ( String fieldName , int from , int to ) { <nl> + super . between ( fieldName , from , to ) ; <nl> + return this ; <nl> + } <nl> + <nl> + public TableView findAll ( long callerRealmPtr , long backgroundRealmPtr ) { <nl> + return getTableQuery ( ) . findAllWithHandover ( callerRealmPtr , backgroundRealmPtr ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / realm / realm - jni / src / io _ realm _ internal _ Util . cpp b / realm / realm - jni / src / io _ realm _ internal _ Util . cpp 
 index 03d298a . . 0d6144d 100644 
 - - - a / realm / realm - jni / src / io _ realm _ internal _ Util . cpp 
 + + + b / realm / realm - jni / src / io _ realm _ internal _ Util . cpp 
 @ @ - 169 , 7 + 169 , 11 @ @ JNIEXPORT jstring JNICALL Java _ io _ realm _ internal _ Util _ nativeTestcase ( 
 if ( dotest ) 
 ThrowException ( env , BadVersion , " parm1 " , " parm2 " ) ; 
 break ; 
 - 
 + case DeletedLinkViewException : 
 + expect = " io . realm . internal . DeletedRealmListException : parm1 " ; 
 + if ( dotest ) 
 + ThrowException ( env , DeletedLinkViewException , " parm1 " , " parm2 " ) ; 
 + break ; 
 } 
 if ( dotest ) { 
 return NULL ; 
 diff - - git a / realm / realm - jni / src / io _ realm _ internal _ tableview . cpp b / realm / realm - jni / src / io _ realm _ internal _ tableview . cpp 
 index 84f33a6 . . 3e1a612 100644 
 - - - a / realm / realm - jni / src / io _ realm _ internal _ tableview . cpp 
 + + + b / realm / realm - jni / src / io _ realm _ internal _ tableview . cpp 
 @ @ - 24 , 22 + 24 , 36 @ @ 
 
 using namespace realm ; 
 
 - / / if you disable the validation , please remember to call sync _ in _ needed ( ) 
 - # define VIEW _ VALID _ AND _ IN _ SYNC ( env , ptr ) view _ valid _ and _ in _ sync ( env , ptr ) 
 + / / The validation will try to sync the table view as well . 
 + / / if you disable the validation , please remember to call sync _ if _ needed ( ) 
 + # define VIEW _ VALID _ AND _ IN _ SYNC ( env , ptr ) ( is _ view _ valid ( env , ptr ) & & sync _ table _ view ( env , ptr ) ) 
 + 
 + inline bool is _ view _ valid ( JNIEnv * env , jlong nativeViewPtr ) { 
 + if ( TV ( nativeViewPtr ) = = NULL ) { 
 + / / Should never get here 
 + ThrowException ( env , FatalError , " Null pointer of table view . " ) ; 
 + return false ; 
 + } 
 + if ( ! TV ( nativeViewPtr ) - > is _ attached ( ) ) { 
 + ThrowException ( env , TableInvalid , " The Realm has been closed and is no longer accessible . " ) ; 
 + return false ; 
 + } 
 + return true ; 
 + } 
 
 - inline bool view _ valid _ and _ in _ sync ( JNIEnv * env , jlong nativeViewPtr ) { 
 - bool valid = ( TV ( nativeViewPtr ) ! = NULL ) ; 
 - if ( valid ) { 
 - if ( ! TV ( nativeViewPtr ) - > is _ attached ( ) ) { 
 - ThrowException ( env , TableInvalid , " The Realm has been closed and is no longer accessible . " ) ; 
 - return false ; 
 - } 
 + / / Sync the TableView and return false if sync failed . 
 + inline bool sync _ table _ view ( JNIEnv * / * env * / , jlong nativeViewPtr ) { 
 + try { 
 TV ( nativeViewPtr ) - > sync _ if _ needed ( ) ; 
 + } catch ( realm : : DeletedLinkView & ) { 
 + / / FIXME : Temp fix for https : / / github . com / realm / realm - core / pull / 1434 
 + / / Better solution would be core only throw the exception when really necessary , methods like size 
 + / / should just return 0 . 
 + return false ; 
 } 
 - return valid ; 
 + return true ; 
 } 
 
 - 
 JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableView _ createNativeTableView ( 
 JNIEnv * env , jobject , jobject , jlong ) 
 { 
 @ @ - 105 , 10 + 119 , 16 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetSourceRowIndex 
 ( JNIEnv * env , jobject , jlong nativeViewPtr , jlong rowIndex ) 
 { 
 try { 
 - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) ) 
 - return 0 ; 
 + if ( ! is _ view _ valid ( env , nativeViewPtr ) ) { 
 + return npos ; 
 + } 
 + if ( ! sync _ table _ view ( env , nativeViewPtr ) ) { 
 + TR _ ERR ( " The source LinkView created this TableView has been deleted . " ) ; 
 + / / Let it fall through . Since the size will return 0 , an ArrayIndexOutOfBoundsException 
 + / / will be thrown in ROW _ INDEX _ VALID check . 
 + } 
 if ( ! ROW _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , rowIndex ) ) 
 - return 0 ; 
 + return npos ; 
 } CATCH _ STD ( ) 
 return TV ( nativeViewPtr ) - > get _ source _ ndx ( S ( rowIndex ) ) ; / / noexcept 
 } 
 @ @ - 117 , 7 + 137 , 8 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetColumnCount 
 ( JNIEnv * env , jobject , jlong nativeViewPtr ) 
 { 
 try { 
 - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) ) 
 + / / No need to sync here . 
 + if ( ! is _ view _ valid ( env , nativeViewPtr ) ) 
 return 0 ; 
 } CATCH _ STD ( ) 
 return TV ( nativeViewPtr ) - > get _ column _ count ( ) ; 
 @ @ - 127 , 7 + 148 , 8 @ @ JNIEXPORT jstring JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetColumnName 
 ( JNIEnv * env , jobject , jlong nativeViewPtr , jlong columnIndex ) 
 { 
 try { 
 - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) | | ! COL _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , columnIndex ) ) 
 + / / No need to sync here . 
 + if ( ! is _ view _ valid ( env , nativeViewPtr ) | | ! COL _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , columnIndex ) ) 
 return NULL ; 
 return to _ jstring ( env , TV ( nativeViewPtr ) - > get _ column _ name ( S ( columnIndex ) ) ) ; 
 } CATCH _ STD ( ) 
 @ @ - 138 , 8 + 160 , 9 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetColumnIndex 
 ( JNIEnv * env , jobject , jlong nativeViewPtr , jstring columnName ) 
 { 
 try { 
 - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) ) 
 - return 0 ; 
 + / / No need to sync here . 
 + if ( ! is _ view _ valid ( env , nativeViewPtr ) ) 
 + return 0 ; 
 
 JStringAccessor columnName2 ( env , columnName ) ; / / throws 
 return to _ jlong _ or _ not _ found ( TV ( nativeViewPtr ) - > get _ column _ index ( columnName2 ) ) ; / / noexcept 
 @ @ - 151 , 7 + 174 , 8 @ @ JNIEXPORT jint JNICALL Java _ io _ realm _ internal _ TableView _ nativeGetColumnType 
 ( JNIEnv * env , jobject , jlong nativeViewPtr , jlong columnIndex ) 
 { 
 try { 
 - if ( ! VIEW _ VALID _ AND _ IN _ SYNC ( env , nativeViewPtr ) | | ! COL _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , columnIndex ) ) 
 + / / No need to sync here . 
 + if ( ! is _ view _ valid ( env , nativeViewPtr ) | | ! COL _ INDEX _ VALID ( env , TV ( nativeViewPtr ) , columnIndex ) ) 
 return 0 ; 
 } CATCH _ STD ( ) 
 return static _ cast < int > ( TV ( nativeViewPtr ) - > get _ column _ type ( S ( columnIndex ) ) ) ; 
 diff - - git a / realm / realm - jni / src / util . cpp b / realm / realm - jni / src / util . cpp 
 index a8bad14 . . c20a02d 100644 
 - - - a / realm / realm - jni / src / util . cpp 
 + + + b / realm / realm - jni / src / util . cpp 
 @ @ - 53 , 6 + 53 , 10 @ @ void ConvertException ( JNIEnv * env , const char * file , int line ) 
 ss < < e . what ( ) < < " in " < < file < < " line " < < line ; 
 ThrowException ( env , BadVersion , ss . str ( ) ) ; 
 } 
 + catch ( realm : : DeletedLinkView & e ) { 
 + ss < < e . what ( ) < < " in " < < file < < " line " < < line ; 
 + ThrowException ( env , DeletedLinkViewException , ss . str ( ) ) ; 
 + } 
 catch ( std : : exception & e ) { 
 ss < < e . what ( ) < < " in " < < file < < " line " < < line ; 
 ThrowException ( env , FatalError , ss . str ( ) ) ; 
 @ @ - 152 , 6 + 156 , 11 @ @ void ThrowException ( JNIEnv * env , ExceptionKind exception , const std : : string & cla 
 jExceptionClass = env - > FindClass ( " io / realm / internal / async / BadVersionException " ) ; 
 message = classStr ; 
 break ; 
 + 
 + case DeletedLinkViewException : 
 + jExceptionClass = env - > FindClass ( " io / realm / internal / DeletedRealmListException " ) ; 
 + message = classStr ; 
 + break ; 
 } 
 if ( jExceptionClass ! = NULL ) { 
 env - > ThrowNew ( jExceptionClass , message . c _ str ( ) ) ; 
 @ @ - 315 , 7 + 324 , 7 @ @ jstring to _ jstring ( JNIEnv * env , StringData str ) 
 if ( str . is _ null ( ) ) { 
 return NULL ; 
 } 
 - 
 + 
 / / For efficiency , if the incoming UTF - 8 string is sufficiently 
 / / small , we will attempt to store the UTF - 16 output into a stack 
 / / allocated buffer of static size . Otherwise we will have to 
 @ @ - 346 , 7 + 355 , 7 @ @ jstring to _ jstring ( JNIEnv * env , StringData str ) 
 const char * in _ begin2 = in _ begin ; 
 size _ t error _ code ; 
 size _ t size = Xcode : : find _ utf16 _ buf _ size ( in _ begin2 , in _ end , error _ code ) ; 
 - if ( in _ begin2 ! = in _ end ) 
 + if ( in _ begin2 ! = in _ end ) 
 throw runtime _ error ( string _ to _ hex ( " Failure when computing UTF - 16 size " , str , in _ begin , in _ end , out _ curr , out _ end , size , error _ code ) ) ; 
 if ( int _ add _ with _ overflow _ detect ( size , stack _ buf _ size ) ) 
 throw runtime _ error ( " String size overflow " ) ; 
 @ @ - 355 , 7 + 364 , 7 @ @ jstring to _ jstring ( JNIEnv * env , StringData str ) 
 out _ begin = dyn _ buf . get ( ) ; 
 out _ end = dyn _ buf . get ( ) + size ; 
 size _ t retcode = Xcode : : to _ utf16 ( in _ begin , in _ end , out _ curr , out _ end ) ; 
 - if ( retcode ! = 0 ) 
 + if ( retcode ! = 0 ) 
 throw runtime _ error ( string _ to _ hex ( " Failure when converting long string to UTF - 16 " , str , in _ begin , in _ end , out _ curr , out _ end , size _ t ( 0 ) , retcode ) ) ; 
 REALM _ ASSERT ( in _ begin = = in _ end ) ; 
 } 
 diff - - git a / realm / realm - jni / src / util . hpp b / realm / realm - jni / src / util . hpp 
 index e976306 . . 18c31ce 100644 
 - - - a / realm / realm - jni / src / util . hpp 
 + + + b / realm / realm - jni / src / util . hpp 
 @ @ - 121 , 7 + 121 , 8 @ @ enum ExceptionKind { 
 RuntimeError = 12 , 
 RowInvalid = 13 , 
 CrossTableLink = 15 , 
 - BadVersion = 16 
 + BadVersion = 16 , 
 + DeletedLinkViewException = 17 
 / / NOTE ! ! ! ! : Please also add test cases to Util . java when introducing a new exception kind . 
 } ; 
 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTest . java 
 index 67269e5 . . 57be8fe 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTest . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmResultsTest . java 
 @ @ - 280 , 9 + 280 , 9 @ @ public class RealmResultsTest extends AndroidTestCase { 
 TestHelper . populateAllNullRowsForNumericTesting ( testRealm ) ; 
 
 RealmResults < NullTypes > results = testRealm . where ( NullTypes . class ) . findAll ( ) ; 
 - assertNull ( results . max ( NullTypes . FIELD _ INTEGER _ NULL ) ) ; 
 - assertNull ( results . max ( NullTypes . FIELD _ FLOAT _ NULL ) ) ; 
 - assertNull ( results . max ( NullTypes . FIELD _ DOUBLE _ NULL ) ) ; 
 + assertNull ( results . min ( NullTypes . FIELD _ INTEGER _ NULL ) ) ; 
 + assertNull ( results . min ( NullTypes . FIELD _ FLOAT _ NULL ) ) ; 
 + assertNull ( results . min ( NullTypes . FIELD _ DOUBLE _ NULL ) ) ; 
 assertNull ( results . maxDate ( NullTypes . FIELD _ DATE _ NULL ) ) ; 
 } 
 
 @ @ - 1146 , 4 + 1146 , 100 @ @ public class RealmResultsTest extends AndroidTestCase { 
 assertEquals ( 10 , testRealm . where ( AllTypes . class ) . lessThanOrEqualTo ( AllTypes . FIELD _ LONG , - 1 ) . findAll ( ) . size ( ) ) ; 
 assertEquals ( 10 , testRealm . where ( AllTypes . class ) . lessThan ( AllTypes . FIELD _ LONG , 0 ) . findAll ( ) . size ( ) ) ; 
 } 
 + 
 + private RealmResults < Dog > populateRealmResultsOnDeletedLinkView ( ) { 
 + testRealm . beginTransaction ( ) ; 
 + Owner owner = testRealm . createObject ( Owner . class ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) { 
 + Dog dog = new Dog ( ) ; 
 + dog . setName ( " name _ " + i ) ; 
 + dog . setOwner ( owner ) ; 
 + owner . getDogs ( ) . add ( dog ) ; 
 + } 
 + testRealm . commitTransaction ( ) ; 
 + 
 + 
 + RealmResults < Dog > dogs = owner . getDogs ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; 
 + / / dogs = dogs . where ( ) . findFirst ( ) . getOwner ( ) . getDogs ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; 
 + 
 + testRealm . beginTransaction ( ) ; 
 + owner . removeFromRealm ( ) ; 
 + testRealm . commitTransaction ( ) ; 
 + return dogs ; 
 + } 
 + 
 + public void testisValidResultsBuiltOnDeletedLinkView ( ) { 
 + assertEquals ( false , populateRealmResultsOnDeletedLinkView ( ) . isValid ( ) ) ; 
 + } 
 + 
 + public void testSizeResultsBuiltOnDeletedLinkView ( ) { 
 + assertEquals ( 0 , populateRealmResultsOnDeletedLinkView ( ) . size ( ) ) ; 
 + } 
 + 
 + public void testFirstResultsBuiltOnDeletedLinkView ( ) { 
 + try { 
 + populateRealmResultsOnDeletedLinkView ( ) . first ( ) ; 
 + } catch ( ArrayIndexOutOfBoundsException ignored ) { 
 + } 
 + } 
 + 
 + public void testLastResultsBuiltOnDeletedLinkView ( ) { 
 + try { 
 + populateRealmResultsOnDeletedLinkView ( ) . last ( ) ; 
 + } catch ( ArrayIndexOutOfBoundsException ignored ) { 
 + } 
 + } 
 + 
 + public void testSumResultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + assertEquals ( 0 , dogs . sum ( Dog . FIELD _ AGE ) . intValue ( ) ) ; 
 + assertEquals ( 0f , dogs . sum ( Dog . FIELD _ HEIGHT ) . floatValue ( ) , 0f ) ; 
 + assertEquals ( 0d , dogs . sum ( Dog . FIELD _ WEIGHT ) . doubleValue ( ) , 0d ) ; 
 + } 
 + 
 + public void testAverageResultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + assertEquals ( 0d , dogs . average ( Dog . FIELD _ AGE ) , 0d ) ; 
 + assertEquals ( 0d , dogs . average ( Dog . FIELD _ HEIGHT ) , 0d ) ; 
 + assertEquals ( 0d , dogs . average ( Dog . FIELD _ WEIGHT ) , 0d ) ; 
 + } 
 + 
 + public void testClearResultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + testRealm . beginTransaction ( ) ; 
 + dogs . clear ( ) ; 
 + assertEquals ( 0 , dogs . size ( ) ) ; 
 + testRealm . commitTransaction ( ) ; 
 + } 
 + 
 + public void testMaxResultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + assertNull ( dogs . max ( Dog . FIELD _ AGE ) ) ; 
 + assertNull ( dogs . max ( Dog . FIELD _ HEIGHT ) ) ; 
 + assertNull ( dogs . max ( Dog . FIELD _ WEIGHT ) ) ; 
 + } 
 + 
 + public void testMaxDateResultsBuiltOnDeletedLinkView ( ) { 
 + assertEquals ( null , populateRealmResultsOnDeletedLinkView ( ) . maxDate ( Dog . FIELD _ BIRTHDAY ) ) ; 
 + } 
 + 
 + public void testMinResultsBuiltOnDeletedLinkView ( ) { 
 + RealmResults < Dog > dogs = populateRealmResultsOnDeletedLinkView ( ) ; 
 + assertNull ( dogs . min ( Dog . FIELD _ AGE ) ) ; 
 + assertNull ( dogs . min ( Dog . FIELD _ HEIGHT ) ) ; 
 + assertNull ( dogs . min ( Dog . FIELD _ WEIGHT ) ) ; 
 + } 
 + 
 + public void testMinDateResultsBuiltOnDeletedLinkView ( ) { 
 + assertEquals ( null , populateRealmResultsOnDeletedLinkView ( ) . minDate ( Dog . FIELD _ BIRTHDAY ) ) ; 
 + } 
 + 
 + public void testWhereResultsBuiltOnDeletedLinkView ( ) { 
 + try { 
 + populateRealmResultsOnDeletedLinkView ( ) . where ( ) ; 
 + fail ( ) ; 
 + } catch ( IllegalStateException e ) { 
 + assertEquals ( " The RealmList which this RealmResults is created on has been deleted . " , e . getMessage ( ) ) ; 
 + } 
 + } 
 } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / TypeBasedNotificationsTest . java b / realm / realm - library / src / androidTest / java / io / realm / TypeBasedNotificationsTest . java 
 index 1c22ad1 . . 60da724 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / TypeBasedNotificationsTest . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / TypeBasedNotificationsTest . java 
 @ @ - 27 , 7 + 27 , 6 @ @ import java . io . IOException ; 
 import java . io . InputStream ; 
 import java . lang . ref . WeakReference ; 
 import java . util . Date ; 
 - import java . util . WeakHashMap ; 
 import java . util . concurrent . CountDownLatch ; 
 import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 @ @ - 1827 , 8 + 1826 , 8 @ @ public class TypeBasedNotificationsTest extends AndroidTestCase { 
 / / Check if cat has been added to the realmObjects in case of the behaviour of getCat changes 
 for ( WeakReference < RealmObject > weakReference : realm . handlerController . realmObjects . keySet ( ) ) { 
 if ( weakReference . get ( ) = = cat ) { 
 - foundKey = true ; 
 - break ; 
 + foundKey = true ; 
 + break ; 
 } 
 } 
 assertTrue ( foundKey ) ; 
 @ @ - 1890 , 4 + 1889 , 58 @ @ public class TypeBasedNotificationsTest extends AndroidTestCase { 
 
 finishedLatch . await ( ) ; 
 } 
 + 
 + / / Build a RealmResults from a RealmList , and delete the RealmList . Test the behavior of ChangeListener on the 
 + / / " invalid " RealmResults . 
 + public void test _ changeListener _ onResultsBuiltOnDeletedLinkView ( ) { 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + realm = Realm . getInstance ( configuration ) ; 
 + realm . beginTransaction ( ) ; 
 + AllTypes allTypes = realm . createObject ( AllTypes . class ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) { 
 + Dog dog = new Dog ( ) ; 
 + dog . setName ( " name _ " + i ) ; 
 + allTypes . getColumnRealmList ( ) . add ( dog ) ; 
 + } 
 + realm . commitTransaction ( ) ; 
 + 
 + final RealmResults < Dog > dogs = 
 + allTypes . getColumnRealmList ( ) . where ( ) . equalTo ( Dog . FIELD _ NAME , " name _ 0 " ) . findAll ( ) ; 
 + dogs . addChangeListener ( new RealmChangeListener ( ) { 
 + @ Override 
 + public void onChange ( ) { 
 + if ( typebasedCommitInvocations . getAndIncrement ( ) = = 0 ) { 
 + assertFalse ( dogs . isValid ( ) ) ; 
 + assertEquals ( 0 , dogs . size ( ) ) ; 
 + } else { 
 + fail ( " This listener should only be called once . " ) ; 
 + } 
 + } 
 + } ) ; 
 + 
 + / / Trigger the listener at the first time . 
 + realm . beginTransaction ( ) ; 
 + allTypes . removeFromRealm ( ) ; 
 + realm . commitTransaction ( ) ; 
 + 
 + / / Try to trigger the listener second time . 
 + realm . beginTransaction ( ) ; 
 + realm . commitTransaction ( ) ; 
 + 
 + / / Close the realm and finish the test . This needs to follow the REALM _ CHANGED in the queue . 
 + handler . post ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + realm . close ( ) ; 
 + signalTestFinished . countDown ( ) ; 
 + } 
 + } ) ; 
 + } 
 + } ) ; 
 + 
 + TestHelper . awaitOrFail ( signalTestFinished ) ; 
 + assertEquals ( 1 , typebasedCommitInvocations . get ( ) ) ; 
 + } 
 } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java b / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java 
 index 753db7f . . d6b2046 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / entities / Dog . java 
 @ @ - 26 , 6 + 26 , 10 @ @ public class Dog extends RealmObject { 
 
 public static final String CLASS _ NAME = " Dog " ; 
 public static final String FIELD _ NAME = " name " ; 
 + public static final String FIELD _ AGE = " age " ; 
 + public static final String FIELD _ HEIGHT = " height " ; 
 + public static final String FIELD _ WEIGHT = " weight " ; 
 + public static final String FIELD _ BIRTHDAY = " birthday " ; 
 
 @ Index 
 private String name ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmResults . java b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 index 1e7a50d . . 6b13240 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmResults . java 
 @ @ - 29 , 6 + 29 , 7 @ @ import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . Future ; 
 
 import io . realm . exceptions . RealmException ; 
 + import io . realm . internal . DeletedRealmListException ; 
 import io . realm . internal . TableOrView ; 
 import io . realm . internal . TableQuery ; 
 import io . realm . internal . TableView ; 
 @ @ - 51 , 6 + 52 , 10 @ @ import rx . Observable ; 
 * < p > 
 * Notice that a RealmResults is never { @ code null } not even in the case where it contains no objects . You should always 
 * use the size ( ) method to check if a RealmResults is empty or not . 
 + * < p > 
 + * If a RealmResults is built on RealmList through { @ link RealmList # where ( ) } , it will become invalid when the source 
 + * RealmList gets deleted . When that happens , the RealmResults will behave like a empty RealmResults , but calling 
 + * { @ link # where ( ) } will throw an { @ link IllegalStateException } . Use { @ link # isValid } to detect this situation . 
 * 
 * @ param < E > The class of objects in this list . 
 * @ see RealmQuery # findAll ( ) 
 @ @ - 65 , 7 + 70 , 9 @ @ public final class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 private TableOrView table = null ; 
 
 private static final String TYPE _ MISMATCH = " Field ' % s ' : type mismatch - % s expected . " ; 
 - private long currentTableViewVersion = - 1 ; 
 + private static final long TABLE _ VIEW _ VERSION _ NONE = - 1 ; 
 + private static final long TABLE _ VIEW _ VERSION _ REALM _ LIST _ DELETED = - 2 ; 
 + private long currentTableViewVersion = TABLE _ VIEW _ VERSION _ NONE ; 
 
 private final TableQuery query ; 
 private final List < RealmChangeListener > listeners = new CopyOnWriteArrayList < RealmChangeListener > ( ) ; 
 @ @ - 138 , 7 + 145 , 11 @ @ public final class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ return { @ code true } if still valid to use , { @ code false } otherwise . 
 * / 
 public boolean isValid ( ) { 
 - return realm ! = null & & ! realm . isClosed ( ) ; 
 + if ( realm = = null | | realm . isClosed ( ) ) { 
 + return false ; 
 + } 
 + 
 + return syncToCheckIfValid ( " Calling isValid on RealmResults whose parent RealmList has been deleted already . " ) ; 
 } 
 
 / * * 
 @ @ - 146 , 9 + 157 , 14 @ @ public final class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * 
 * @ return a typed RealmQuery . 
 * @ see io . realm . RealmQuery 
 + * @ throws IllegalStateException if the RealmList which this RealmResults is created on has been deleted . 
 * / 
 public RealmQuery < E > where ( ) { 
 realm . checkIfValid ( ) ; 
 + 
 + if ( ! syncToCheckIfValid ( " Calling where on RealmResults whose parent RealmList has been deleted already . " ) ) { 
 + throw new IllegalStateException ( " The RealmList which this RealmResults is created on has been deleted . " ) ; 
 + } 
 return RealmQuery . createQueryFromResult ( this ) ; 
 } 
 
 @ @ - 856 , 13 + 872 , 45 @ @ public final class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 / / FIXME : still waiting for Core to provide a fix 
 / / for crash when calling _ sync _ if _ needed on a cleared View . 
 / / https : / / github . com / realm / realm - core / pull / 1390 
 - long version = table . sync ( ) ; 
 + long version ; 
 + try { 
 + version = table . sync ( ) ; 
 + } catch ( DeletedRealmListException e ) { 
 + / / Although this RealmResults won ' t be updated anymore , it is good to give user a chance to do update . 
 + / / When the onChange called this time , user can use isValid to check if the RealmList has been deleted . 
 + version = TABLE _ VIEW _ VERSION _ REALM _ LIST _ DELETED ; 
 + RealmLog . d ( " The parent RealmList has been deleted already . " ) ; 
 + } 
 if ( currentTableViewVersion ! = version ) { 
 currentTableViewVersion = version ; 
 for ( RealmChangeListener listener : listeners ) { 
 listener . onChange ( ) ; 
 } 
 } 
 + 
 + / / Since the parent RealmList has been removed , this RealmResults won ' t be updated anymore . 
 + / / We just remove the change listeners from this to avoid unnecessary callings in the future . 
 + if ( version = = TABLE _ VIEW _ VERSION _ REALM _ LIST _ DELETED ) { 
 + listeners . clear ( ) ; 
 + } 
 + } 
 + } 
 + 
 + / / FIXME : This is a temp fix , see https : / / github . com / realm / realm - core / pull / 1434 
 + private boolean syncToCheckIfValid ( String warningMessage ) { 
 + if ( currentTableViewVersion = = TABLE _ VIEW _ VERSION _ REALM _ LIST _ DELETED ) { 
 + RealmLog . d ( warningMessage ) ; 
 + return false ; 
 + } 
 + TableOrView tableOrView = getTable ( ) ; 
 + if ( tableOrView instanceof TableView ) { 
 + try { 
 + tableOrView . sync ( ) ; 
 + } catch ( DeletedRealmListException e ) { 
 + RealmLog . d ( warningMessage ) ; 
 + return false ; 
 + } 
 } 
 + return true ; 
 } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / DeletedRealmListException . java b / realm / realm - library / src / main / java / io / realm / internal / DeletedRealmListException . java 
 new file mode 100644 
 index 0000000 . . 308dfbc 
 - - - / dev / null 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / DeletedRealmListException . java 
 @ @ - 0 , 0 + 1 , 28 @ @ 
 + / * 
 + * Copyright 2016 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package io . realm . internal ; 
 + 
 + import io . realm . exceptions . RealmException ; 
 + 
 + / * * 
 + * Triggered from JNI level when accessing a RealmResults whose parent RealmList has been deleted already . 
 + * / 
 + @ Keep 
 + public class DeletedRealmListException extends RealmException { 
 + public DeletedRealmListException ( String detailMessage ) { 
 + super ( detailMessage ) ; 
 + } 
 + } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / Util . java b / realm / realm - library / src / main / java / io / realm / internal / Util . java 
 index 1f409e1 . . 632a9f6 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / Util . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / Util . java 
 @ @ - 64 , 7 + 64 , 8 @ @ public class Util { 
 Exception _ RowInvalid ( 13 ) , 
 Exception _ EncryptionNotSupported ( 14 ) , 
 Exception _ CrossTableLink ( 15 ) , 
 - Exception _ BadVersion ( 16 ) ; 
 + Exception _ BadVersion ( 16 ) , 
 + Exception _ DeletedLinkView ( 17 ) ; 
 
 private final int nativeTestcase ; 
 Testcase ( int nativeValue ) {

NEAREST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index 1912025 . . 4d02c8a 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * Fixed unchecked cast warnings when building with Realm . 
 * Cleaned up examples ( remove old test project ) . 
 * Added checking for missing generic type in RealmList fields in annotation processor . 
 + * Support async queries 
 
 0 . 80 . 3 
 * Calling Realm . copyToRealmOrUpdate ( ) with an object with a null primary key now throws a proper exception . 
 diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 index bb26d54 . . 3cad125 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 @ @ - 14 , 12 + 14 , 14 @ @ 
 * limitations under the License . 
 * / 
 
 + # include < realm / group _ shared . hpp > 
 # include " util . hpp " 
 # include " io _ realm _ internal _ TableQuery . h " 
 # include " tablequery . hpp " 
 
 using namespace realm ; 
 
 + # define SG ( ptr ) reinterpret _ cast < SharedGroup * > ( ptr ) 
 # if 1 
 # define COL _ TYPE _ VALID ( env , ptr , col , type ) TBL _ AND _ COL _ INDEX _ AND _ TYPE _ VALID ( env , ptr , col , type ) 
 # define COL _ TYPE _ LINK _ OR _ LINKLIST ( env , ptr , col ) TBL _ AND _ COL _ INDEX _ AND _ LINK _ OR _ LINKLIST ( env , ptr , col ) 
 @ @ - 1174 , 3 + 1176 , 47 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNull ( 
 pQuery - > and _ query ( query ) ; 
 } CATCH _ STD ( ) 
 } 
 + 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover 
 + ( JNIEnv * env , jobject , jlong callerSharedGrpPtr , jlong bgSharedGroupPtr , jlong nativeQueryPtr , jlong start , jlong end , jlong limit ) 
 + { 
 + Query * pQuery = Q ( nativeQueryPtr ) ; 
 + Table * pTable = pQuery - > get _ table ( ) . get ( ) ; 
 + if ( ! QUERY _ VALID ( env , pQuery ) | | 
 + ! ROW _ INDEXES _ VALID ( env , pTable , start , end , limit ) ) 
 + return - 1 ; 
 + try { 
 + TableView * pResultView = new TableView ( pQuery - > find _ all ( S ( start ) , S ( end ) , S ( limit ) ) ) ; 
 + std : : unique _ ptr < SharedGroup : : Handover < TableView > > handover ; 
 + handover . reset ( SG ( bgSharedGroupPtr ) - > export _ for _ handover ( * pResultView , ConstSourcePayload : : Copy ) ) ; 
 + / / TODO reimplement this so the call to ' export _ for _ handover ' is done on a background thread 
 + / / and ' import _ from _ handover ' on the caller thread . 
 + / / 
 + / / According to core , it ' s preferable to return first the exported handover 
 + / / then import it from the calling SharedGroup ( Thread ) . 
 + / / We need to make sure to check that the version id ( version of the shared group used to perform the query ) 
 + / / is the same as the caller SharedGroup , otherwise the import will fail . In this case , we should 
 + / / either retry the entire query , or call again ' sync _ if _ needed ' on the TableView to re - query , at this point 
 + / / we need to export again the handover to the caller SharedGroup , until we converge 
 + / / ( i . e the version of the caller SharedGroup matches the version returned by the handover TableView ) 
 + / / 
 + / / Note : The mode ' ConstSourcePayload : : Copy ' handover perform a deep copy of the TableView , this means that we copy 
 + / / both the Payload ( row accessors ) & the Query 
 + / / 
 + / / The mode ' ConstSourcePayload : : Stay ' handover perform a copy of the Query only ( no payload ) 
 + / / The mode ' MutableSourcePayload : : Move ' handover perform a move of both the Payload & Query 
 + / / 
 + / / The expensive operations are in that order 
 + / / pQuery - > find _ all > > export _ for _ handover > > import _ from _ handover 
 + / / so it ' s recommended to run the ' query ' & the ' export ' on a background Thread , then 
 + / / call ' import _ from _ handover ' on the caller thread ( most of the time UI thread ) . 
 + / / calling ' import _ from _ handover ' on the UI thread has another benefit , it will block the SharedGroup 
 + / / from modifying it ' s state ( advance _ read , promote _ write , rollback , commit etc ) 
 + / / 
 + / / The handover pointer is Thread safe , it can be passed from different Threads ( using different SharedGroups ) 
 + 
 + TableView * tv ( SG ( callerSharedGrpPtr ) - > import _ from _ handover ( handover . release ( ) ) ) ; 
 + return reinterpret _ cast < jlong > ( tv ) ; 
 + } CATCH _ STD ( ) 
 + return - 1 ; 
 + } 
 diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 index 5ccb9ee . . 97a9ed7 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 @ @ - 369 , 6 + 369 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAll 
 
 / * 
 * Class : io _ realm _ internal _ TableQuery 
 + * Method : nativeFindAllWithHandover 
 + * Signature : ( JJJJJJ ) J 
 + * / 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover 
 + ( JNIEnv * , jobject , jlong , jlong , jlong , jlong , jlong , jlong ) ; 
 + 
 + / * 
 + * Class : io _ realm _ internal _ TableQuery 
 * Method : nativeSumInt 
 * Signature : ( JJJJJ ) J 
 * / 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 new file mode 100644 
 index 0000000 . . 162e33a 
 - - - / dev / null 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 0 , 0 + 1 , 151 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm ; 
 + 
 + import android . os . Looper ; 
 + import android . test . InstrumentationTestCase ; 
 + 
 + import junit . framework . AssertionFailedError ; 
 + 
 + import java . util . Date ; 
 + import java . util . concurrent . CountDownLatch ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Executors ; 
 + 
 + import io . realm . entities . AllTypes ; 
 + import io . realm . entities . NonLatinFieldNames ; 
 + 
 + public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 + 
 + / / TODO use Junit4 & define a rule to setup the threading , to avoid 
 + / / this boiler plat code , or use a custom test runner 
 + public void testFindAll ( ) throws Throwable { 
 + / / We need to control precisely which Looper / Thread our Realm 
 + / / will operate on . This is unfortunately not possible when using the 
 + / / current Instrumentation # InstrumentationThread , because InstrumentationTestRunner # onStart 
 + / / Call Looper . prepare ( ) for us and surprisingly doesn ' t call Looper # loop ( ) , this is problematic 
 + / / as the async query callback will not run ( because the Handler is sending Runnables to a Looper 
 + / / that didn ' t loop . 
 + / / 
 + / / In the other hand , using a dedicated ' ExecutorService ' will allow us to fine grain control the 
 + / / desired behaviour 
 + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final Looper [ ] looper = new Looper [ 1 ] ; 
 + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + executorService . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + looper [ 0 ] = Looper . myLooper ( ) ; 
 + Realm realm = null ; 
 + try { 
 + realm = openRealmInstance ( ) ; 
 + populateTestRealm ( realm , 10 ) ; 
 + 
 + / / async query ( will run on different thread ) 
 + realm . asyncWhere ( AllTypes . class , 
 + new Realm . AsyncCallback < RealmResults < AllTypes > > ( ) { 
 + @ Override 
 + public void onSuccess ( RealmResults < AllTypes > results ) { 
 + try { 
 + assertEquals ( 10 , results . size ( ) ) ; 
 + 
 + / / Make sure access to RealmObject will not throw an Exception 
 + for ( int i = 0 , size = results . size ( ) ; i < size ; i + + ) { 
 + assertEquals ( i , results . get ( i ) . getColumnLong ( ) ) ; 
 + } 
 + 
 + } catch ( AssertionFailedError e ) { 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + / / whatever happened , make sure to notify the waiting TestCase Thread 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onError ( Throwable t ) { 
 + try { 
 + threadAssertionError [ 0 ] = t ; 
 + t . printStackTrace ( ) ; 
 + } finally { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + } ) 
 + . between ( " columnLong " , 0 , 9 ) . findAll ( ) ; 
 + 
 + Looper . loop ( ) ; / / ready to receive callback 
 + 
 + } finally { 
 + if ( realm ! = null ) { 
 + realm . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + / / wait until the callback of our async query proceed 
 + signalCallbackFinished . await ( ) ; 
 + looper [ 0 ] . quit ( ) ; 
 + executorService . shutdownNow ( ) ; 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / Throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + } 
 + 
 + / / * * * Helper methods * * * 
 + 
 + / / This could be done from # setUp but then we can ' t control 
 + / / which Looper we want to associate this Realm instance with 
 + private Realm openRealmInstance ( ) { 
 + RealmConfiguration realmConfiguration = new RealmConfiguration . 
 + Builder ( getInstrumentation ( ) 
 + . getTargetContext ( ) ) 
 + . name ( " test . realm " ) 
 + . deleteRealmIfMigrationNeeded ( ) 
 + . build ( ) ; 
 + Realm . deleteRealm ( realmConfiguration ) ; 
 + return Realm . getInstance ( realmConfiguration ) ; 
 + } 
 + 
 + private void populateTestRealm ( final Realm testRealm , int objects ) { 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . allObjects ( AllTypes . class ) . clear ( ) ; 
 + testRealm . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; 
 + for ( int i = 0 ; i < objects ; + + i ) { 
 + AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; 
 + allTypes . setColumnBoolean ( ( i % 3 ) = = 0 ) ; 
 + allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; 
 + allTypes . setColumnDate ( new Date ( ) ) ; 
 + allTypes . setColumnDouble ( 3 . 1415 ) ; 
 + allTypes . setColumnFloat ( 1 . 234567f + i ) ; 
 + allTypes . setColumnString ( " test data " + i ) ; 
 + allTypes . setColumnLong ( i ) ; 
 + NonLatinFieldNames nonLatinFieldNames = testRealm . createObject ( NonLatinFieldNames . class ) ; 
 + nonLatinFieldNames . set 델 타 ( i ) ; 
 + nonLatinFieldNames . set Δ έ λ τ α ( i ) ; 
 + nonLatinFieldNames . set 베 타 ( 1 . 234567f + i ) ; 
 + nonLatinFieldNames . set Β ή τ α ( 1 . 234567f + i ) ; 
 + } 
 + testRealm . commitTransaction ( ) ; 
 + testRealm . refresh ( ) ; 
 + } 
 + } 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index ca29295 . . d2e5033 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 22 , 7 + 22 , 6 @ @ import org . json . JSONArray ; 
 import org . json . JSONException ; 
 import org . json . JSONObject ; 
 
 - import java . io . ByteArrayInputStream ; 
 import java . io . File ; 
 import java . io . IOException ; 
 import java . io . InputStream ; 
 diff - - git a / realm / src / main / java / io / realm / AsyncRealmQueryResult . java b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java 
 new file mode 100644 
 index 0000000 . . 7318359 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java 
 @ @ - 0 , 0 + 1 , 25 @ @ 
 + package io . realm ; 
 + 
 + import java . util . concurrent . Future ; 
 + 
 + / * * 
 + * Represents the result of an asynchronous Realm query . 
 + * 
 + * Users are responsible of maintaining a reference to { @ code AsyncRealmQueryResult } in order 
 + * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the 
 + * query will post the result to the caller ' s thread callback ) 
 + * / 
 + public class AsyncRealmQueryResult { 
 + final Future < ? > pendingQuery ; 
 + 
 + public AsyncRealmQueryResult ( Future < ? > pendingQuery ) { 
 + this . pendingQuery = pendingQuery ; 
 + } 
 + 
 + / * * 
 + * Attempts to cancel execution of this queries . 
 + * / 
 + public void cancel ( ) { 
 + pendingQuery . cancel ( true ) ; 
 + } 
 + } 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index ddbc022 . . 15aac8b 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 63 , 6 + 63 , 7 @ @ import io . realm . internal . SharedGroup ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableView ; 
 import io . realm . internal . Util ; 
 + import io . realm . internal . android . AsyncRealmQuery ; 
 import io . realm . internal . android . DebugAndroidLogger ; 
 import io . realm . internal . android . ReleaseAndroidLogger ; 
 import io . realm . internal . log . RealmLog ; 
 @ @ - 154 , 6 + 155 , 9 @ @ public final class Realm implements Closeable { 
 private static final Map < String , AtomicInteger > globalOpenInstanceCounter = 
 new ConcurrentHashMap < String , AtomicInteger > ( ) ; 
 
 + / / Thread Pool for all async operations ( Query & Write transaction ) 
 + public static final ExecutorService asyncQueryExecutor = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) * 2 + 1 ) ; 
 + 
 protected static final Map < Handler , String > handlers = new ConcurrentHashMap < Handler , String > ( ) ; 
 private static final int REALM _ CHANGED = 14930352 ; / / Hopefully it won ' t clash with other message IDs . 
 
 @ @ - 1198 , 6 + 1202 , 20 @ @ public final class Realm implements Closeable { 
 } 
 
 / * * 
 + * Prepare an async query 
 + * TODO point to documentation or example about async query 
 + * @ param clazz The class of the object which is to be queried for 
 + * @ return A typed RealmQuery , which can be used to query for specific objects of this type 
 + * @ throws java . lang . RuntimeException Any other error 
 + * @ see io . realm . RealmQuery 
 + * @ param callback 
 + * / 
 + public < E extends RealmObject > AsyncRealmQuery < E > asyncWhere ( Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { 
 + checkIfValid ( ) ; 
 + return new AsyncRealmQuery < E > ( this , clazz , callback ) ; 
 + } 
 + 
 + / * * 
 * Get all objects of a specific Class . If no objects exist , the returned RealmResults will not 
 * be null . The RealmResults . size ( ) to check the number of objects instead . 
 * 
 @ @ - 1872 , 4 + 1890 , 24 @ @ public final class Realm implements Closeable { 
 void execute ( Realm realm ) ; 
 } 
 
 + / * * 
 + * Encapsulates an async { @ link RealmQuery } . 
 + * < p > 
 + * This will run the { @ link RealmQuery } on a worker thread , then invoke this callback on the caller thread 
 + * / 
 + public interface AsyncCallback < T extends RealmResults < ? extends RealmObject > > { 
 + void onSuccess ( T results ) ; 
 + void onError ( Throwable t ) ; 
 + } 
 + 
 + 
 + / / FIXME Realm . java being the public API and the implementation . 
 + / / we need a Realm interface to be able to separate this kind of call 
 + / / ( mostly from internal API / tests that need to access private field / method ) . 
 + / / RealmImpl will be accessible to other internal packages 
 + / / but not to the user ( avoid compromising our exposed public API ) 
 + / / 
 + public long getSharedGroupPtr ( ) { 
 + return sharedGroup . nativePtr ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index df847f5 . . b744adc 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1302 , 4 + 1302 , 8 @ @ public class RealmQuery < E extends RealmObject > { 
 return null ; 
 } 
 } 
 + 
 + protected TableQuery getTableQuery ( ) { 
 + return this . query ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / internal / TableQuery . java b / realm / src / main / java / io / realm / internal / TableQuery . java 
 index e82eaa7 . . 268645d 100644 
 - - - a / realm / src / main / java / io / realm / internal / TableQuery . java 
 + + + b / realm / src / main / java / io / realm / internal / TableQuery . java 
 @ @ - 493 , 8 + 493 , 24 @ @ public class TableQuery implements Closeable { 
 } 
 } 
 
 - protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; 
 + public TableView findAllWithHandover ( long callerSharedGroupPtr , long bgSharedGroupPtr ) { 
 + validateQuery ( ) ; 
 + 
 + / / Execute the disposal of abandoned realm objects each time a new realm object is created 
 + context . executeDelayedDisposal ( ) ; 
 + long nativeViewPtr = nativeFindAllWithHandover ( callerSharedGroupPtr , bgSharedGroupPtr , nativePtr , 0 , Table . INFINITE , Table . INFINITE ) ; / / nativeViewPtr is created from bg Thread 
 + / / handover nativeViewPtr to UI Thread 
 + 
 + try { 
 + return new TableView ( this . context , this . parent , nativeViewPtr ) ; 
 + } catch ( RuntimeException e ) { 
 + TableView . nativeClose ( nativeViewPtr ) ; 
 + throw e ; 
 + } 
 + } 
 
 + protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; 
 + protected native long nativeFindAllWithHandover ( long nativeCallerSharedGroupPtr , long bgSharedGroupPtr , long nativeQueryPtr , long start , long end , long limit ) ; 
 / / 
 / / Aggregation methods 
 / / 
 diff - - git a / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java 
 new file mode 100644 
 index 0000000 . . c3716eb 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java 
 @ @ - 0 , 0 + 1 , 165 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . android ; 
 + 
 + import android . os . Handler ; 
 + import android . os . Looper ; 
 + import android . os . Message ; 
 + 
 + import java . util . concurrent . Future ; 
 + 
 + import io . realm . AsyncRealmQueryResult ; 
 + import io . realm . Realm ; 
 + import io . realm . RealmConfiguration ; 
 + import io . realm . RealmObject ; 
 + import io . realm . RealmQuery ; 
 + import io . realm . RealmResults ; 
 + import io . realm . internal . TableOrView ; 
 + import io . realm . internal . TableView ; 
 + 
 + import static io . realm . Realm . asyncQueryExecutor ; 
 + 
 + / * * 
 + * A helper class to help make handling asynchronous { @ link RealmQuery } easier . 
 + * 
 + * @ param < E > type of the object which is to be queried for 
 + * / 
 + / / Behaviour may change , user should not subclass 
 + public final class AsyncRealmQuery < E extends RealmObject > { 
 + private final Realm callerRealm ; 
 + private final Class < E > clazz ; 
 + private final Realm . AsyncCallback < RealmResults < E > > callback ; 
 + 
 + private int from ; 
 + private int to ; 
 + private String fieldName ; 
 + private EventHandler eventHandler ; 
 + private Future < ? > pendingQuery ; 
 + 
 + / * * 
 + * Create an { @ code AsyncRealmQuery } instance . 
 + * 
 + * @ param realm The realm to query within . 
 + * @ param clazz The class to query . 
 + * @ param callback invoked on the thread { @ link Realm # asyncWhere ( Class , Realm . AsyncCallback ) } was called from , to post results . 
 + * / 
 + public AsyncRealmQuery ( Realm realm , Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { 
 + this . callerRealm = realm ; 
 + this . callback = callback ; 
 + this . clazz = clazz ; 
 + } 
 + 
 + / * * 
 + * Between condition 
 + * 
 + * @ param fieldName The field to compare 
 + * @ param from Lowest value ( inclusive ) 
 + * @ param to Highest value ( inclusive ) 
 + * @ return current instance of { @ code AsyncRealmQuery } for method chaining 
 + * / 
 + public AsyncRealmQuery < E > between ( String fieldName , int from , int to ) { 
 + this . from = from ; 
 + this . to = to ; 
 + this . fieldName = fieldName ; 
 + return this ; 
 + } 
 + 
 + / * * 
 + * Find all objects that fulfill the query conditions . 
 + * Results will be posted to the callback instance { @ link io . realm . Realm . AsyncCallback } asynchronously 
 + * If no objects match the condition , a list with zero objects is returned . 
 + * 
 + * @ see io . realm . RealmResults 
 + * / 
 + public AsyncRealmQueryResult findAll ( ) { 
 + / / will use the Looper of the caller thread to post the result 
 + Looper looper ; 
 + if ( ( looper = Looper . myLooper ( ) ) ! = null ) { 
 + eventHandler = new EventHandler ( looper ) ; 
 + } else if ( ( looper = Looper . getMainLooper ( ) ) ! = null ) { 
 + eventHandler = new EventHandler ( looper ) ; 
 + } else { 
 + eventHandler = null ; / / FIXME define strategy / behaviour for regular JVM call 
 + } 
 + 
 + / / We need a pointer to the caller Realm , to be able to handover the result to it 
 + final long callerSharedGroupNativePtr = callerRealm . getSharedGroupPtr ( ) ; 
 + 
 + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) 
 + / / to perform the query 
 + final RealmConfiguration realmConfiguration = callerRealm . getConfiguration ( ) ; 
 + 
 + pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + try { 
 + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 + 
 + / / TODO This will probably be replace by a kind of ' QueryBuilder ' 
 + / / that holds all the operations ( predicates / filters ) then 
 + / / replay them here in this background thread . The current implementation 
 + / / call Core for each step , we want to limit the overhead by sending one 
 + / / single call to Core with all the parameters . 
 + 
 + TableView tv = new RealmQueryAdapter < E > ( bgRealm , clazz ) 
 + . between ( fieldName , from , to ) 
 + . findAll ( callerSharedGroupNativePtr , bgRealm . getSharedGroupPtr ( ) ) ; 
 + 
 + bgRealm . close ( ) ; 
 + 
 + / / send results to the caller thread ' s callback 
 + if ( ! pendingQuery . isCancelled ( ) ) { 
 + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ SUCCESS , tv ) ; 
 + eventHandler . sendMessage ( msg ) ; 
 + } 
 + 
 + } catch ( Exception e ) { 
 + if ( ! pendingQuery . isCancelled ( ) ) { 
 + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ ERROR , e ) ; 
 + eventHandler . sendMessage ( msg ) ; 
 + } 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + return new AsyncRealmQueryResult ( pendingQuery ) ; 
 + } 
 + 
 + private class EventHandler extends Handler { 
 + private static final int MSG _ SUCCESS = 1 ; 
 + private static final int MSG _ ERROR = MSG _ SUCCESS + 1 ; 
 + 
 + public EventHandler ( Looper looper ) { 
 + super ( looper ) ; 
 + } 
 + 
 + @ Override 
 + public void handleMessage ( Message msg ) { 
 + switch ( msg . what ) { 
 + case MSG _ SUCCESS : 
 + RealmResults < E > resultList = new RealmResults < E > ( callerRealm , ( TableOrView ) msg . obj , clazz ) ; 
 + callback . onSuccess ( resultList ) ; 
 + break ; 
 + case MSG _ ERROR : 
 + callback . onError ( ( Throwable ) msg . obj ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java 
 new file mode 100644 
 index 0000000 . . acac317 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java 
 @ @ - 0 , 0 + 1 , 38 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . android ; 
 + 
 + import io . realm . Realm ; 
 + import io . realm . RealmObject ; 
 + import io . realm . RealmQuery ; 
 + import io . realm . internal . TableView ; 
 + 
 + class RealmQueryAdapter < E extends RealmObject > extends RealmQuery < E > { 
 + public RealmQueryAdapter ( Realm realm , Class < E > clazz ) { 
 + super ( realm , clazz ) ; 
 + } 
 + 
 + @ Override 
 + public RealmQueryAdapter < E > between ( String fieldName , int from , int to ) { 
 + super . between ( fieldName , from , to ) ; 
 + return this ; 
 + } 
 + 
 + public TableView findAll ( long callerRealmPtr , long backgroundRealmPtr ) { 
 + return getTableQuery ( ) . findAllWithHandover ( callerRealmPtr , backgroundRealmPtr ) ; 
 + } 
 + }
