BLEU SCORE: 0.041961149062965476

TEST MSG: add helper method to check and throw errors if needed
GENERATED MSG: waiting for Realm to close for all tests

TEST DIFF (one line): diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index c022aff . . 7a0194f 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 110 , 21 + 110 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> @ @ - 206 , 22 + 192 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> public void testUnloadedRealmListsShouldBeTheSameInstance ( ) throws Throwable { <nl> @ @ - 281 , 21 + 252 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> public void testStandloneObjectAsyncBehaviour ( ) { <nl> @ @ - 403 , 22 + 360 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded <nl> @ @ - 483 , 21 + 425 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / transforming an async query into sync by calling load to force <nl> @ @ - 565 , 23 + 493 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / UC : <nl> @ @ - 681 , 22 + 593 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / UC : <nl> @ @ - 859 , 24 + 756 , 10 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> + <nl> assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; <nl> assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> } <nl> <nl> / / simulate a use case , when the caller thread advance read , while the background thread <nl> @ @ - 1163 , 22 + 1046 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> @ @ - 1248 , 22 + 1116 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded <nl> @ @ - 1333 , 23 + 1186 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / similar UC as # testForceLoadAsync using ' findFirst ' <nl> @ @ - 1403 , 23 + 1240 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / similar UC as # testFindAllAsyncRetry using ' findFirst ' <nl> @ @ - 1513 , 26 + 1334 , 9 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> - <nl> / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> / / * * * ' findAllSorted ' async queries * * * <nl> / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> @ @ - 1614 , 23 + 1418 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> <nl> @ @ - 1723 , 23 + 1511 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSorted ' <nl> @ @ - 1897 , 22 + 1669 , 9 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; <nl> assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - executorService . shutdownNow ( ) ; <nl> } <nl> <nl> / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSortedMulti ' <nl> @ @ - 2148 , 25 + 1907 , 9 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> - <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; <nl> assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> } <nl> <nl> / / make sure the notification listener does not leak the enclosing class <nl> @ @ - 2236 , 22 + 1979 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> - executorService . shutdownNow ( ) ; <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> public void testCombiningAsyncAndSync ( ) throws Throwable { <nl> @ @ - 2303 , 22 + 2031 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / keep advancing the Realm by sending 1 commit for each frame ( 16ms ) <nl> @ @ - 2406 , 20 + 2119 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - TestHelper . awaitOrFail ( signalTestFinished , 120 ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> + exitOrThrow ( executorService , signalTestFinished , signalClosedRealm , backgroundLooper , threadAssertionError , 120 ) ; <nl> } <nl> <nl> public void testAsyncDistinct ( ) throws Throwable { <nl> @ @ - 2515 , 22 + 2215 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> public void testAsyncDistinctNotIndexedFields ( ) throws Throwable { <nl> @ @ - 2579 , 22 + 2264 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> public void testAsyncDistinctFieldDoesNotExist ( ) throws Throwable { <nl> @ @ - 2640 , 22 + 2310 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } ) ; <nl> <nl> - / / wait until the callback of our async query proceed <nl> - TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - executorService . shutdownNow ( ) ; <nl> - if ( backgroundLooper [ 0 ] ! = null ) { <nl> - / / failing to quit the looper will not execute the finally block responsible <nl> - / / of closing the Realm <nl> - backgroundLooper [ 0 ] . quit ( ) ; <nl> - } <nl> - <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> - <nl> + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; <nl> } <nl> <nl> / / * * * Helper methods * * * <nl> @ @ - 2712 , 4 + 2367 , 33 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> realm . commitTransaction ( ) ; <nl> } <nl> <nl> + / / clean resource , shutdown the executor service & throw any background exception <nl> + private void exitOrThrow ( final ExecutorService executorService , <nl> + final CountDownLatch signalTestFinished , <nl> + final CountDownLatch signalFinallyRun , <nl> + final Looper [ ] looper , <nl> + final Throwable [ ] throwable , <nl> + int . . . timeout ) throws Throwable { <nl> + <nl> + / / wait for the signal indicating the test ' s use case is done <nl> + TestHelper . awaitOrFail ( signalTestFinished , ( timeout . length = = 1 ) ? timeout [ 0 ] : 7 ) ; <nl> + <nl> + / / close the executor <nl> + executorService . shutdownNow ( ) ; <nl> + <nl> + if ( looper [ 0 ] ! = null ) { <nl> + / / failing to quit the looper will not execute the finally block responsible <nl> + / / of closing the Realm <nl> + looper [ 0 ] . quit ( ) ; <nl> + } <nl> + <nl> + / / wait for the finally block to execute & close the Realm <nl> + TestHelper . awaitOrFail ( signalFinallyRun , ( timeout . length = = 1 ) ? timeout [ 0 ] : 7 ) ; <nl> + <nl> + if ( throwable [ 0 ] ! = null ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw throwable [ 0 ] ; <nl> + } <nl> + } <nl> + <nl> }
NEAREST DIFF (one line): diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index d30679c . . c022aff 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 50 , 6 + 50 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / start asynchronously a transaction to insert one element <nl> public void testAsyncTransaction ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Realm [ ] realm = new Realm [ 1 ] ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; / / to catch both Exception & AssertionError <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> @ @ - 104 , 6 + 105 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm . length > 0 & & realm [ 0 ] ! = null ) { <nl> realm [ 0 ] . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> @ @ - 111 , 15 + 113 , 18 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> } <nl> <nl> / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> @ @ - 130 , 6 + 135 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / no use of notification callback <nl> public void testFindAllAsync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final RealmResults [ ] results = new RealmResults [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> @ @ - 195 , 27 + 201 , 32 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> } <nl> <nl> public void testUnloadedRealmListsShouldBeTheSameInstance ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 265 , 23 + 276 , 26 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> } <nl> <nl> public void testStandloneObjectAsyncBehaviour ( ) { <nl> @ @ - 340 , 6 + 354 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> <nl> public void testReusingQuery ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 383 , 29 + 398 , 34 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> } <nl> <nl> / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded <nl> / / using a callback to be notified when the data is loaded <nl> public void testFindAllAsyncWithNotification ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> @ @ - 458 , 29 + 478 , 33 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> } <nl> <nl> / / transforming an async query into sync by calling load to force <nl> / / the blocking behaviour <nl> public void testForceLoadAsync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 536 , 23 + 560 , 28 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> + <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> } <nl> <nl> / / UC : <nl> @ @ - 567 , 6 + 596 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / notify the user ) . <nl> public void testFindAllAsyncRetry ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 646 , 23 + 676 , 27 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm [ 0 ] ! = null ) { <nl> realm [ 0 ] . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> } <nl> <nl> / / UC : <nl> @ @ - 675 , 6 + 709 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / 7 - callbacks are notified with the latest results ( called twice overall ) <nl> public void testFindAllAsyncBatchUpdate ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 819 , 6 + 854 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> @ @ - 828 , 15 + 864 , 19 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; <nl> <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> } <nl> <nl> / / simulate a use case , when the caller thread advance read , while the background thread <nl> @ @ - 845 , 6 + 885 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> public void testFindAllCallerIsAdvanced ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> final CountDownLatch callbackInvokedFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final AtomicInteger numberOfInvocation = new AtomicInteger ( 0 ) ; <nl> @ @ - 958 , 6 + 999 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm [ 0 ] ! = null ) { <nl> realm [ 0 ] . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> @ @ - 966 , 16 + 1008 , 20 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> TestHelper . awaitOrFail ( callbackInvokedFinished ) ; <nl> <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> + <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> assertEquals ( 1 , numberOfInvocation . get ( ) ) ; <nl> executorService . shutdownNow ( ) ; <nl> } <nl> @ @ - 991 , 6 + 1037 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / 7 - onChange notification will be triggered once <nl> public void testFindAllCallerThreadBehind ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 1111 , 22 + 1158 , 26 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> + <nl> executorService . shutdownNow ( ) ; <nl> } <nl> <nl> @ @ - 1137 , 6 + 1188 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / similar UC as # testFindAllAsync using ' findFirst ' <nl> public void testFindFirstAsync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final RealmObject [ ] result = new RealmObject [ 1 ] ; <nl> @ @ - 1191 , 21 + 1243 , 26 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> executorService . shutdownNow ( ) ; <nl> } <nl> <nl> @ @ - 1213 , 6 + 1270 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / using a callback to be notified when the data is loaded <nl> public void testFindFirstAsyncWithNotification ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 1270 , 29 + 1328 , 34 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> + <nl> executorService . shutdownNow ( ) ; <nl> } <nl> <nl> / / similar UC as # testForceLoadAsync using ' findFirst ' <nl> public void testForceLoadFindFirstAsync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 1335 , 29 + 1398 , 34 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> + <nl> executorService . shutdownNow ( ) ; <nl> } <nl> <nl> / / similar UC as # testFindAllAsyncRetry using ' findFirst ' <nl> public void testFindFirstAsyncRetry ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 1440 , 22 + 1508 , 27 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm [ 0 ] ! = null ) { <nl> realm [ 0 ] . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> + <nl> executorService . shutdownNow ( ) ; <nl> } <nl> <nl> @ @ - 1467 , 6 + 1540 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / similar UC as # testFindAllAsync using ' findAllSorted ' <nl> public void testFindAllSortedAsync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final RealmResults [ ] result = new RealmResults [ 1 ] ; <nl> @ @ - 1535 , 23 + 1609 , 27 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> + <nl> executorService . shutdownNow ( ) ; <nl> } <nl> <nl> @ @ - 1560 , 6 + 1638 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / using a callback to be notified when the data is loaded <nl> public void testFindAllSortedAsyncRetry ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 1639 , 29 + 1718 , 34 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm [ 0 ] ! = null ) { <nl> realm [ 0 ] . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> + <nl> executorService . shutdownNow ( ) ; <nl> } <nl> <nl> / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSorted ' <nl> public void testFindAllSortedAsyncBatchUpdate ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 1808 , 6 + 1892 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> @ @ - 1815 , 23 + 1900 , 25 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; <nl> assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; <nl> - <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> executorService . shutdownNow ( ) ; <nl> } <nl> <nl> / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSortedMulti ' <nl> public void testFindAllSortedMultiAsyncBatchUpdate ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 2056 , 21 + 2143 , 26 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> + <nl> assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; <nl> assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; <nl> <nl> @ @ - 2081 , 6 + 2173 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / if unregistered properly . <nl> public void testListenerShouldNotLeak ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 2138 , 18 + 2231 , 21 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> if ( null ! = threadAssertionError [ 0 ] ) { <nl> / / throw any assertion errors happened in the background thread <nl> throw threadAssertionError [ 0 ] ; <nl> @ @ - 2160 , 6 + 2256 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> <nl> public void testCombiningAsyncAndSync ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; / / to catch both Exception & AssertionError <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 2201 , 6 + 2298 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> @ @ - 2208 , 15 + 2306 , 19 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> } <nl> <nl> / / keep advancing the Realm by sending 1 commit for each frame ( 16ms ) <nl> @ @ - 2311 , 15 + 2413 , 18 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> if ( null ! = threadAssertionError [ 0 ] ) { <nl> / / throw any assertion errors happened in the background thread <nl> throw threadAssertionError [ 0 ] ; <nl> } <nl> - TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> } <nl> <nl> public void testAsyncDistinct ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 4 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 2405 , 27 + 2510 , 32 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> } <nl> <nl> public void testAsyncDistinctNotIndexedFields ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 4 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 2464 , 27 + 2574 , 32 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> } <nl> <nl> public void testAsyncDistinctFieldDoesNotExist ( ) throws Throwable { <nl> final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; <nl> final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> @ @ - 2520 , 23 + 2635 , 27 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> if ( realm ! = null ) { <nl> realm . close ( ) ; <nl> } <nl> + signalClosedRealm . countDown ( ) ; <nl> } <nl> } <nl> } ) ; <nl> <nl> / / wait until the callback of our async query proceed <nl> TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> - <nl> executorService . shutdownNow ( ) ; <nl> - if ( null ! = threadAssertionError [ 0 ] ) { <nl> - / / throw any assertion errors happened in the background thread <nl> - throw threadAssertionError [ 0 ] ; <nl> - } <nl> if ( backgroundLooper [ 0 ] ! = null ) { <nl> / / failing to quit the looper will not execute the finally block responsible <nl> / / of closing the Realm <nl> backgroundLooper [ 0 ] . quit ( ) ; <nl> } <nl> + <nl> + TestHelper . awaitOrFail ( signalClosedRealm ) ; <nl> + <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> } <nl> <nl> / / * * * Helper methods * * *

TEST DIFF:
diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index c022aff . . 7a0194f 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 110 , 21 + 110 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 @ @ - 206 , 22 + 192 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 public void testUnloadedRealmListsShouldBeTheSameInstance ( ) throws Throwable { 
 @ @ - 281 , 21 + 252 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 public void testStandloneObjectAsyncBehaviour ( ) { 
 @ @ - 403 , 22 + 360 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded 
 @ @ - 483 , 21 + 425 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / transforming an async query into sync by calling load to force 
 @ @ - 565 , 23 + 493 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / UC : 
 @ @ - 681 , 22 + 593 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / UC : 
 @ @ - 859 , 24 + 756 , 10 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 + 
 assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; 
 assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; 
 - 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 } 
 
 / / simulate a use case , when the caller thread advance read , while the background thread 
 @ @ - 1163 , 22 + 1046 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 - 
 - executorService . shutdownNow ( ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 @ @ - 1248 , 22 + 1116 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 - executorService . shutdownNow ( ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded 
 @ @ - 1333 , 23 + 1186 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 - 
 - executorService . shutdownNow ( ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / similar UC as # testForceLoadAsync using ' findFirst ' 
 @ @ - 1403 , 23 + 1240 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 - 
 - executorService . shutdownNow ( ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / similar UC as # testFindAllAsyncRetry using ' findFirst ' 
 @ @ - 1513 , 26 + 1334 , 9 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 - 
 - executorService . shutdownNow ( ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 - 
 / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 / / * * * ' findAllSorted ' async queries * * * 
 / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 @ @ - 1614 , 23 + 1418 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 - 
 - executorService . shutdownNow ( ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 
 @ @ - 1723 , 23 + 1511 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 - 
 - executorService . shutdownNow ( ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSorted ' 
 @ @ - 1897 , 22 + 1669 , 9 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; 
 assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - executorService . shutdownNow ( ) ; 
 } 
 
 / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSortedMulti ' 
 @ @ - 2148 , 25 + 1907 , 9 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 - 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; 
 assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; 
 - 
 - executorService . shutdownNow ( ) ; 
 } 
 
 / / make sure the notification listener does not leak the enclosing class 
 @ @ - 2236 , 22 + 1979 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 - executorService . shutdownNow ( ) ; 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 public void testCombiningAsyncAndSync ( ) throws Throwable { 
 @ @ - 2303 , 22 + 2031 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / keep advancing the Realm by sending 1 commit for each frame ( 16ms ) 
 @ @ - 2406 , 20 + 2119 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - TestHelper . awaitOrFail ( signalTestFinished , 120 ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 + exitOrThrow ( executorService , signalTestFinished , signalClosedRealm , backgroundLooper , threadAssertionError , 120 ) ; 
 } 
 
 public void testAsyncDistinct ( ) throws Throwable { 
 @ @ - 2515 , 22 + 2215 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 public void testAsyncDistinctNotIndexedFields ( ) throws Throwable { 
 @ @ - 2579 , 22 + 2264 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 public void testAsyncDistinctFieldDoesNotExist ( ) throws Throwable { 
 @ @ - 2640 , 22 + 2310 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } ) ; 
 
 - / / wait until the callback of our async query proceed 
 - TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - executorService . shutdownNow ( ) ; 
 - if ( backgroundLooper [ 0 ] ! = null ) { 
 - / / failing to quit the looper will not execute the finally block responsible 
 - / / of closing the Realm 
 - backgroundLooper [ 0 ] . quit ( ) ; 
 - } 
 - 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 - 
 + exitOrThrow ( executorService , signalCallbackFinished , signalClosedRealm , backgroundLooper , threadAssertionError ) ; 
 } 
 
 / / * * * Helper methods * * * 
 @ @ - 2712 , 4 + 2367 , 33 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 realm . commitTransaction ( ) ; 
 } 
 
 + / / clean resource , shutdown the executor service & throw any background exception 
 + private void exitOrThrow ( final ExecutorService executorService , 
 + final CountDownLatch signalTestFinished , 
 + final CountDownLatch signalFinallyRun , 
 + final Looper [ ] looper , 
 + final Throwable [ ] throwable , 
 + int . . . timeout ) throws Throwable { 
 + 
 + / / wait for the signal indicating the test ' s use case is done 
 + TestHelper . awaitOrFail ( signalTestFinished , ( timeout . length = = 1 ) ? timeout [ 0 ] : 7 ) ; 
 + 
 + / / close the executor 
 + executorService . shutdownNow ( ) ; 
 + 
 + if ( looper [ 0 ] ! = null ) { 
 + / / failing to quit the looper will not execute the finally block responsible 
 + / / of closing the Realm 
 + looper [ 0 ] . quit ( ) ; 
 + } 
 + 
 + / / wait for the finally block to execute & close the Realm 
 + TestHelper . awaitOrFail ( signalFinallyRun , ( timeout . length = = 1 ) ? timeout [ 0 ] : 7 ) ; 
 + 
 + if ( throwable [ 0 ] ! = null ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw throwable [ 0 ] ; 
 + } 
 + } 
 + 
 }

NEAREST DIFF:
diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index d30679c . . c022aff 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 50 , 6 + 50 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / start asynchronously a transaction to insert one element 
 public void testAsyncTransaction ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Realm [ ] realm = new Realm [ 1 ] ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; / / to catch both Exception & AssertionError 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 @ @ - 104 , 6 + 105 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm . length > 0 & & realm [ 0 ] ! = null ) { 
 realm [ 0 ] . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 @ @ - 111 , 15 + 113 , 18 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 } 
 
 / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 @ @ - 130 , 6 + 135 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / no use of notification callback 
 public void testFindAllAsync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final RealmResults [ ] results = new RealmResults [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 @ @ - 195 , 27 + 201 , 32 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 } 
 
 public void testUnloadedRealmListsShouldBeTheSameInstance ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 265 , 23 + 276 , 26 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 } 
 
 public void testStandloneObjectAsyncBehaviour ( ) { 
 @ @ - 340 , 6 + 354 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 
 public void testReusingQuery ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 383 , 29 + 398 , 34 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 } 
 
 / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded 
 / / using a callback to be notified when the data is loaded 
 public void testFindAllAsyncWithNotification ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 @ @ - 458 , 29 + 478 , 33 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 } 
 
 / / transforming an async query into sync by calling load to force 
 / / the blocking behaviour 
 public void testForceLoadAsync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 536 , 23 + 560 , 28 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 + 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 } 
 
 / / UC : 
 @ @ - 567 , 6 + 596 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / notify the user ) . 
 public void testFindAllAsyncRetry ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 646 , 23 + 676 , 27 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm [ 0 ] ! = null ) { 
 realm [ 0 ] . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 } 
 
 / / UC : 
 @ @ - 675 , 6 + 709 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / 7 - callbacks are notified with the latest results ( called twice overall ) 
 public void testFindAllAsyncBatchUpdate ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 819 , 6 + 854 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 @ @ - 828 , 15 + 864 , 19 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; 
 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 } 
 
 / / simulate a use case , when the caller thread advance read , while the background thread 
 @ @ - 845 , 6 + 885 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 public void testFindAllCallerIsAdvanced ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 final CountDownLatch callbackInvokedFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final AtomicInteger numberOfInvocation = new AtomicInteger ( 0 ) ; 
 @ @ - 958 , 6 + 999 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm [ 0 ] ! = null ) { 
 realm [ 0 ] . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 @ @ - 966 , 16 + 1008 , 20 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 TestHelper . awaitOrFail ( callbackInvokedFinished ) ; 
 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 + 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 assertEquals ( 1 , numberOfInvocation . get ( ) ) ; 
 executorService . shutdownNow ( ) ; 
 } 
 @ @ - 991 , 6 + 1037 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / 7 - onChange notification will be triggered once 
 public void testFindAllCallerThreadBehind ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 1111 , 22 + 1158 , 26 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 + 
 executorService . shutdownNow ( ) ; 
 } 
 
 @ @ - 1137 , 6 + 1188 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / similar UC as # testFindAllAsync using ' findFirst ' 
 public void testFindFirstAsync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final RealmObject [ ] result = new RealmObject [ 1 ] ; 
 @ @ - 1191 , 21 + 1243 , 26 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 executorService . shutdownNow ( ) ; 
 } 
 
 @ @ - 1213 , 6 + 1270 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / using a callback to be notified when the data is loaded 
 public void testFindFirstAsyncWithNotification ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 1270 , 29 + 1328 , 34 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 + 
 executorService . shutdownNow ( ) ; 
 } 
 
 / / similar UC as # testForceLoadAsync using ' findFirst ' 
 public void testForceLoadFindFirstAsync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 1335 , 29 + 1398 , 34 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 + 
 executorService . shutdownNow ( ) ; 
 } 
 
 / / similar UC as # testFindAllAsyncRetry using ' findFirst ' 
 public void testFindFirstAsyncRetry ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 1440 , 22 + 1508 , 27 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm [ 0 ] ! = null ) { 
 realm [ 0 ] . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 + 
 executorService . shutdownNow ( ) ; 
 } 
 
 @ @ - 1467 , 6 + 1540 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / similar UC as # testFindAllAsync using ' findAllSorted ' 
 public void testFindAllSortedAsync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final RealmResults [ ] result = new RealmResults [ 1 ] ; 
 @ @ - 1535 , 23 + 1609 , 27 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 + 
 executorService . shutdownNow ( ) ; 
 } 
 
 @ @ - 1560 , 6 + 1638 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / using a callback to be notified when the data is loaded 
 public void testFindAllSortedAsyncRetry ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 1639 , 29 + 1718 , 34 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm [ 0 ] ! = null ) { 
 realm [ 0 ] . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 + 
 executorService . shutdownNow ( ) ; 
 } 
 
 / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSorted ' 
 public void testFindAllSortedAsyncBatchUpdate ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 1808 , 6 + 1892 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 @ @ - 1815 , 23 + 1900 , 25 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; 
 assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; 
 - 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 executorService . shutdownNow ( ) ; 
 } 
 
 / / similar UC as # testFindAllAsyncBatchUpdate using ' findAllSortedMulti ' 
 public void testFindAllSortedMultiAsyncBatchUpdate ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 2 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 2056 , 21 + 2143 , 26 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 + 
 assertEquals ( 2 , numberOfNotificationsQuery1 . get ( ) ) ; 
 assertEquals ( 2 , numberOfNotificationsQuery2 . get ( ) ) ; 
 
 @ @ - 2081 , 6 + 2173 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / if unregistered properly . 
 public void testListenerShouldNotLeak ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 2138 , 18 + 2231 , 21 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 if ( null ! = threadAssertionError [ 0 ] ) { 
 / / throw any assertion errors happened in the background thread 
 throw threadAssertionError [ 0 ] ; 
 @ @ - 2160 , 6 + 2256 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 
 public void testCombiningAsyncAndSync ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; / / to catch both Exception & AssertionError 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 2201 , 6 + 2298 , 7 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 @ @ - 2208 , 15 + 2306 , 19 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 } 
 
 / / keep advancing the Realm by sending 1 commit for each frame ( 16ms ) 
 @ @ - 2311 , 15 + 2413 , 18 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 if ( null ! = threadAssertionError [ 0 ] ) { 
 / / throw any assertion errors happened in the background thread 
 throw threadAssertionError [ 0 ] ; 
 } 
 - TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 } 
 
 public void testAsyncDistinct ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 4 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 2405 , 27 + 2510 , 32 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 } 
 
 public void testAsyncDistinctNotIndexedFields ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 4 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 2464 , 27 + 2574 , 32 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 } 
 
 public void testAsyncDistinctFieldDoesNotExist ( ) throws Throwable { 
 final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalClosedRealm = new CountDownLatch ( 1 ) ; 
 final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 @ @ - 2520 , 23 + 2635 , 27 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 if ( realm ! = null ) { 
 realm . close ( ) ; 
 } 
 + signalClosedRealm . countDown ( ) ; 
 } 
 } 
 } ) ; 
 
 / / wait until the callback of our async query proceed 
 TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 - 
 executorService . shutdownNow ( ) ; 
 - if ( null ! = threadAssertionError [ 0 ] ) { 
 - / / throw any assertion errors happened in the background thread 
 - throw threadAssertionError [ 0 ] ; 
 - } 
 if ( backgroundLooper [ 0 ] ! = null ) { 
 / / failing to quit the looper will not execute the finally block responsible 
 / / of closing the Realm 
 backgroundLooper [ 0 ] . quit ( ) ; 
 } 
 + 
 + TestHelper . awaitOrFail ( signalClosedRealm ) ; 
 + 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 } 
 
 / / * * * Helper methods * * *
