BLEU SCORE: 0.0416725164513856

TEST MSG: Disable SyncConfig . Builder . deleteRealmOnLogout
GENERATED MSG: Language cleanup + added missing info to public classes .

TEST DIFF (one line): diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java b / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java <nl> index e6eeebb . . e930e14 100644 <nl> - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java <nl> @ @ - 536 , 10 + 536 , 12 @ @ public final class SyncConfiguration extends RealmConfiguration { <nl> * The default behavior is that the Realm file is allowed to stay behind , making it possible for users to log <nl> * in again and have access to their data faster . <nl> * / <nl> + / * FIXME : Disable this API since we cannot support it without https : / / github . com / realm / realm - core / issues / 2165 <nl> public Builder deleteRealmOnLogout ( ) { <nl> this . deleteRealmOnLogout = true ; <nl> return this ; <nl> } <nl> + * / <nl> <nl> / * * <nl> * Creates the RealmConfiguration based on the builder parameters . <nl> diff - - git a / realm / realm - library / src / objectServer / java / io / realm / User . java b / realm / realm - library / src / objectServer / java / io / realm / User . java <nl> index 41515d7 . . cab8285 100644 <nl> - - - a / realm / realm - library / src / objectServer / java / io / realm / User . java <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / User . java <nl> @ @ - 204 , 13 + 204 , 15 @ @ public class User { <nl> / * * <nl> * Logs out the user from the Realm Object Server . Once the Object Server has confirmed the logout any registered <nl> * { @ link AuthenticationListener } will be notified and user credentials will be deleted from this device . <nl> - * < p > <nl> - * Any Realms owned by the user will be deleted if { @ link SyncConfiguration . Builder # deleteRealmOnLogout ( ) } is <nl> - * also set . <nl> * <nl> * @ throws IllegalStateException if any Realms owned by this user is still open . They should be closed before <nl> * logging out . <nl> * / <nl> + / * FIXME : Add this back to the javadoc when enable SyncConfiguration . Builder # deleteRealmOnLogout ( ) <nl> + < p > <nl> + Any Realms owned by the user will be deleted if { @ link SyncConfiguration . Builder # deleteRealmOnLogout ( ) } is <nl> + also set . <nl> + * / <nl> public void logout ( ) { <nl> / / Acquire lock to prevent users creating new instances <nl> synchronized ( Realm . class ) { <nl> @ @ - 256 , 6 + 258 , 8 @ @ public class User { <nl> <nl> / / Delete all Realms if needed . <nl> for ( SyncUser . AccessDescription desc : syncUser . getRealms ( ) ) { <nl> + / / FIXME : This will always be false since SyncConfiguration . Builder . deleteRealmOnLogout ( ) is <nl> + / / disabled . Make sure this works for Realm opened in the client thread / other processes . <nl> if ( desc . deleteOnLogout ) { <nl> File realmFile = new File ( desc . localPath ) ; <nl> if ( realmFile . exists ( ) & & ! Util . deleteRealm ( desc . localPath , realmFile . getParentFile ( ) , realmFile . getName ( ) ) ) {
NEAREST DIFF (one line): diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index e8a9425 . . 00934ea 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 73 , 11 + 73 , 11 @ @ import io . realm . internal . log . RealmLog ; <nl> * instance . Failing to do so can lead to { @ link java . lang . OutOfMemoryError } as the native <nl> * resources cannot be freed . <nl> * <nl> - * Realm instances cannot be used across different threads , which means you have to open an instance <nl> - * pr . thread . Realm instances are cached automatically per thread using reference counting , so as <nl> - * long as the reference count doesn ' t reach zero , calling <nl> - * { @ link # getInstance ( android . content . Context ) } will just return the cached Realm which and should <nl> - * be considered a lightweight operation . <nl> + * Realm instances cannot be used across different threads . This means that you have to open an <nl> + * instance on each thread you want to use Realm . Realm instances are cached automatically per <nl> + * thread using reference counting , so as long as the reference count doesn ' t reach zero , calling <nl> + * { @ link # getInstance ( android . content . Context ) } will just return the cached Realm and should be <nl> + * considered a lightweight operation . <nl> * <nl> * For the UI thread this means that opening and closing Realms should occur in either <nl> * onCreate / onDestroy or onStart / onStop . onResume / onPause do not overlap between new activities , <nl> @ @ - 88 , 7 + 88 , 7 @ @ import io . realm . internal . log . RealmLog ; <nl> * mechanism . This also mean that Realm instances on threads without a { @ link android . os . Looper } <nl> * doesn ' t get updated unless { @ link # refresh ( ) } is manually called . <nl> * <nl> - * A standard pattern for working with Realm in Android activities is below : <nl> + * A standard pattern for working with Realm in Android activities can be seen below : <nl> * <nl> * < pre > <nl> * public class RealmActivity extends Activity { <nl> @ @ - 113 , 7 + 113 , 7 @ @ import io . realm . internal . log . RealmLog ; <nl> * Realm support String and byte fields containing up to 16 MB . <nl> * <nl> * @ see < a href = " http : / / en . wikipedia . org / wiki / ACID " > ACID < / a > <nl> - * @ see < a href = " https : / / github . com / realm / realm - java / tree / master / examples " > More Realm examples < / a > <nl> + * @ see < a href = " https : / / github . com / realm / realm - java / tree / master / examples " > Examples using Realm < / a > <nl> * / <nl> public final class Realm implements Closeable { <nl> public static final String DEFAULT _ REALM _ NAME = " default . realm " ; <nl> diff - - git a / realm / src / main / java / io / realm / RealmBaseAdapter . java b / realm / src / main / java / io / realm / RealmBaseAdapter . java <nl> index 6d63eab . . 4c7d794 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmBaseAdapter . java <nl> + + + b / realm / src / main / java / io / realm / RealmBaseAdapter . java <nl> @ @ - 27 , 8 + 27 , 9 @ @ import android . widget . BaseAdapter ; <nl> * This adapter will automatically handle any updates to its data and call <nl> * { @ link # notifyDataSetChanged ( ) } as appropriate . <nl> * <nl> - * The RealmAdapter will no longer get any updates and will throw an error if it is accessed after <nl> - * the Realm instance from where the RealmResults came is closed . <nl> + * The RealmAdapter will stop receiving updates if the Realm instance providing the <nl> + * { @ link io . realm . RealmResults } is closed . Trying to access read objects , will at this point also <nl> + * result in a { @ link io . realm . exceptions . RealmException } . <nl> * / <nl> public abstract class RealmBaseAdapter < T extends RealmObject > extends BaseAdapter { <nl> <nl> diff - - git a / realm / src / main / java / io / realm / RealmChangeListener . java b / realm / src / main / java / io / realm / RealmChangeListener . java <nl> index e04fd4b . . a0183c4 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmChangeListener . java <nl> + + + b / realm / src / main / java / io / realm / RealmChangeListener . java <nl> @ @ - 19 , 11 + 19 , 11 @ @ package io . realm ; <nl> / * * <nl> * Using RealmChangeListener , it is possible to be notified when a Realm instance has been updated . <nl> * <nl> - * Realm instances on a thread without a Looper ( almost all background threads ) doesn ' t get <nl> - * updated automatically , but have to call { @ link Realm # refresh ( ) } manually . This will in turn trigger <nl> - * the RealmChangeListener for that background thread . <nl> + * Realm instances on a thread without a { @ link android . os . Looper } ( almost all background threads ) <nl> + * doesn ' t get updated automatically , but have to call { @ link Realm # refresh ( ) } manually . This will <nl> + * in turn trigger the RealmChangeListener for that background thread . <nl> * <nl> - * All { @ link io . realm . RealmObject } s and { @ link io . realm . RealmResults } will automatically contain <nl> + * All { @ link io . realm . RealmObject } and { @ link io . realm . RealmResults } will automatically contain <nl> * their new values when the { @ link # onChange ( ) } method is called . Normally this means that it <nl> * isn ' t necessary to query again for those objects , but just invalidate any UI elements that are <nl> * using them . If there is a chance that a object has been been deleted , it can be verified <nl> diff - - git a / realm / src / main / java / io / realm / RealmList . java b / realm / src / main / java / io / realm / RealmList . java <nl> index 912d4c2 . . 83e1455 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmList . java <nl> + + + b / realm / src / main / java / io / realm / RealmList . java <nl> @ @ - 27 , 16 + 27 , 16 @ @ import io . realm . internal . TableQuery ; <nl> / * * <nl> * RealmList is used to model one - to - many relationships in a { @ link io . realm . RealmObject } . <nl> * RealmList has two modes : A managed and non - managed mode . In managed mode all objects are persisted <nl> - * inside a Realm , in non - managed mode it functions as an normal ArrayList . <nl> + * inside a Realm , in non - managed mode it works as an normal ArrayList . <nl> * <nl> - * Only Realm can create managed RealmList ' s . Managed RealmList ' s will automatically update its <nl> + * Only Realm can create managed RealmLists . Managed RealmLists will automatically update its <nl> * content whenever the underlying Realm is updated , and can only be accessed using the getter <nl> * from a { @ link io . realm . RealmObject } . <nl> * <nl> * Non - managed RealmLists can be created by the user and can contain both managed and non - managed <nl> * RealmObjects . This is useful eg . when dealing with JSON deserializers like GSON or other <nl> * frameworks that inject values into a class . Non - managed elements in this list can be added to a <nl> - * Realm using { @ link Realm # copyToRealm ( Iterable ) } . <nl> + * Realm using the { @ link Realm # copyToRealm ( Iterable ) } method . <nl> * <nl> * @ param < E > The class of objects in list . <nl> * / <nl> diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java <nl> index 1956ad2 . . a97f049 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmObject . java <nl> + + + b / realm / src / main / java / io / realm / RealmObject . java <nl> @ @ - 42 , 7 + 42 , 7 @ @ import io . realm . internal . Row ; <nl> * - Getter and setters for these fields . <nl> * - Static methods . <nl> * <nl> - * The following field data types are supported : <nl> + * The following field data types are supported ( No boxed types ) : <nl> * - boolean <nl> * - short <nl> * - int <nl> @ @ - 55 , 11 + 55 , 13 @ @ import io . realm . internal . Row ; <nl> * - Any RealmObject subclass <nl> * - RealmList <nl> * <nl> - * All fields that are not annotated with { @ link io . realm . annotations . Ignore } require both a <nl> - * getter and setter . Getter and setter names must have the name { @ code getXXX } or { @ code setXXX } if <nl> + * Getter and setter names must have the name { @ code getXXX } or { @ code setXXX } if <nl> * the field name is { @ code XXX } . Getters for fields of type boolean can be called { @ code isXXX } as <nl> * well . <nl> * <nl> + * Fields annotated with { @ link io . realm . annotations . Ignore } doesn ' t have these restrictions and <nl> + * don ' t require either a getter or setter . <nl> + * <nl> * A RealmObject cannot be parsed between different threads . <nl> * <nl> * @ see Realm # createObject ( Class ) <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index 40369c5 . . 6959bac 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 37 , 6 + 37 , 10 @ @ import io . realm . internal . TableView ; <nl> * type safe , so if a model class is refactored care has to be taken to not break any queries . <nl> * This is not optimal , but it is our current best compromise between ease of use and type safety . <nl> * <nl> + * A { @ link io . realm . Realm } is unordered , which means that there is no guarantee that querying a <nl> + * Realm will return the objects in the order they where inserted . Use <nl> + * { @ link # findAllSorted ( String ) } and similar methods if a specific order is required . <nl> + * <nl> * A RealmQuery cannot be parsed between different threads . <nl> * <nl> * @ param < E > The class of the objects to be queried . <nl> diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java <nl> index 3e4b93f . . ca60ba4 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / src / main / java / io / realm / RealmResults . java <nl> @ @ - 33 , 10 + 33 , 10 @ @ import io . realm . internal . TableView ; <nl> / * * <nl> * This class holds all the matches of a { @ link io . realm . RealmQuery } for a given Realm . The objects <nl> * are not copied from the Realm to the RealmResults list , but are just referenced from the <nl> - * RealmResult instead . This saves memory and increase speed . <nl> + * RealmResult instead . This saves memory and increases speed . <nl> * <nl> - * Updates to RealmObjects from a RealmResults list must be done within a transaction and the <nl> - * modified objects are persisted to the backing Realm file during the commit of the transaction . <nl> + * Updates to RealmObjects from a RealmResults list must be done from within a transaction and the <nl> + * modified objects are persisted to the Realm file during the commit of the transaction . <nl> * <nl> * A RealmResults object cannot be parsed between different threads . <nl> *

TEST DIFF:
diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java b / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java 
 index e6eeebb . . e930e14 100644 
 - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java 
 @ @ - 536 , 10 + 536 , 12 @ @ public final class SyncConfiguration extends RealmConfiguration { 
 * The default behavior is that the Realm file is allowed to stay behind , making it possible for users to log 
 * in again and have access to their data faster . 
 * / 
 + / * FIXME : Disable this API since we cannot support it without https : / / github . com / realm / realm - core / issues / 2165 
 public Builder deleteRealmOnLogout ( ) { 
 this . deleteRealmOnLogout = true ; 
 return this ; 
 } 
 + * / 
 
 / * * 
 * Creates the RealmConfiguration based on the builder parameters . 
 diff - - git a / realm / realm - library / src / objectServer / java / io / realm / User . java b / realm / realm - library / src / objectServer / java / io / realm / User . java 
 index 41515d7 . . cab8285 100644 
 - - - a / realm / realm - library / src / objectServer / java / io / realm / User . java 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / User . java 
 @ @ - 204 , 13 + 204 , 15 @ @ public class User { 
 / * * 
 * Logs out the user from the Realm Object Server . Once the Object Server has confirmed the logout any registered 
 * { @ link AuthenticationListener } will be notified and user credentials will be deleted from this device . 
 - * < p > 
 - * Any Realms owned by the user will be deleted if { @ link SyncConfiguration . Builder # deleteRealmOnLogout ( ) } is 
 - * also set . 
 * 
 * @ throws IllegalStateException if any Realms owned by this user is still open . They should be closed before 
 * logging out . 
 * / 
 + / * FIXME : Add this back to the javadoc when enable SyncConfiguration . Builder # deleteRealmOnLogout ( ) 
 + < p > 
 + Any Realms owned by the user will be deleted if { @ link SyncConfiguration . Builder # deleteRealmOnLogout ( ) } is 
 + also set . 
 + * / 
 public void logout ( ) { 
 / / Acquire lock to prevent users creating new instances 
 synchronized ( Realm . class ) { 
 @ @ - 256 , 6 + 258 , 8 @ @ public class User { 
 
 / / Delete all Realms if needed . 
 for ( SyncUser . AccessDescription desc : syncUser . getRealms ( ) ) { 
 + / / FIXME : This will always be false since SyncConfiguration . Builder . deleteRealmOnLogout ( ) is 
 + / / disabled . Make sure this works for Realm opened in the client thread / other processes . 
 if ( desc . deleteOnLogout ) { 
 File realmFile = new File ( desc . localPath ) ; 
 if ( realmFile . exists ( ) & & ! Util . deleteRealm ( desc . localPath , realmFile . getParentFile ( ) , realmFile . getName ( ) ) ) {

NEAREST DIFF:
diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index e8a9425 . . 00934ea 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 73 , 11 + 73 , 11 @ @ import io . realm . internal . log . RealmLog ; 
 * instance . Failing to do so can lead to { @ link java . lang . OutOfMemoryError } as the native 
 * resources cannot be freed . 
 * 
 - * Realm instances cannot be used across different threads , which means you have to open an instance 
 - * pr . thread . Realm instances are cached automatically per thread using reference counting , so as 
 - * long as the reference count doesn ' t reach zero , calling 
 - * { @ link # getInstance ( android . content . Context ) } will just return the cached Realm which and should 
 - * be considered a lightweight operation . 
 + * Realm instances cannot be used across different threads . This means that you have to open an 
 + * instance on each thread you want to use Realm . Realm instances are cached automatically per 
 + * thread using reference counting , so as long as the reference count doesn ' t reach zero , calling 
 + * { @ link # getInstance ( android . content . Context ) } will just return the cached Realm and should be 
 + * considered a lightweight operation . 
 * 
 * For the UI thread this means that opening and closing Realms should occur in either 
 * onCreate / onDestroy or onStart / onStop . onResume / onPause do not overlap between new activities , 
 @ @ - 88 , 7 + 88 , 7 @ @ import io . realm . internal . log . RealmLog ; 
 * mechanism . This also mean that Realm instances on threads without a { @ link android . os . Looper } 
 * doesn ' t get updated unless { @ link # refresh ( ) } is manually called . 
 * 
 - * A standard pattern for working with Realm in Android activities is below : 
 + * A standard pattern for working with Realm in Android activities can be seen below : 
 * 
 * < pre > 
 * public class RealmActivity extends Activity { 
 @ @ - 113 , 7 + 113 , 7 @ @ import io . realm . internal . log . RealmLog ; 
 * Realm support String and byte fields containing up to 16 MB . 
 * 
 * @ see < a href = " http : / / en . wikipedia . org / wiki / ACID " > ACID < / a > 
 - * @ see < a href = " https : / / github . com / realm / realm - java / tree / master / examples " > More Realm examples < / a > 
 + * @ see < a href = " https : / / github . com / realm / realm - java / tree / master / examples " > Examples using Realm < / a > 
 * / 
 public final class Realm implements Closeable { 
 public static final String DEFAULT _ REALM _ NAME = " default . realm " ; 
 diff - - git a / realm / src / main / java / io / realm / RealmBaseAdapter . java b / realm / src / main / java / io / realm / RealmBaseAdapter . java 
 index 6d63eab . . 4c7d794 100644 
 - - - a / realm / src / main / java / io / realm / RealmBaseAdapter . java 
 + + + b / realm / src / main / java / io / realm / RealmBaseAdapter . java 
 @ @ - 27 , 8 + 27 , 9 @ @ import android . widget . BaseAdapter ; 
 * This adapter will automatically handle any updates to its data and call 
 * { @ link # notifyDataSetChanged ( ) } as appropriate . 
 * 
 - * The RealmAdapter will no longer get any updates and will throw an error if it is accessed after 
 - * the Realm instance from where the RealmResults came is closed . 
 + * The RealmAdapter will stop receiving updates if the Realm instance providing the 
 + * { @ link io . realm . RealmResults } is closed . Trying to access read objects , will at this point also 
 + * result in a { @ link io . realm . exceptions . RealmException } . 
 * / 
 public abstract class RealmBaseAdapter < T extends RealmObject > extends BaseAdapter { 
 
 diff - - git a / realm / src / main / java / io / realm / RealmChangeListener . java b / realm / src / main / java / io / realm / RealmChangeListener . java 
 index e04fd4b . . a0183c4 100644 
 - - - a / realm / src / main / java / io / realm / RealmChangeListener . java 
 + + + b / realm / src / main / java / io / realm / RealmChangeListener . java 
 @ @ - 19 , 11 + 19 , 11 @ @ package io . realm ; 
 / * * 
 * Using RealmChangeListener , it is possible to be notified when a Realm instance has been updated . 
 * 
 - * Realm instances on a thread without a Looper ( almost all background threads ) doesn ' t get 
 - * updated automatically , but have to call { @ link Realm # refresh ( ) } manually . This will in turn trigger 
 - * the RealmChangeListener for that background thread . 
 + * Realm instances on a thread without a { @ link android . os . Looper } ( almost all background threads ) 
 + * doesn ' t get updated automatically , but have to call { @ link Realm # refresh ( ) } manually . This will 
 + * in turn trigger the RealmChangeListener for that background thread . 
 * 
 - * All { @ link io . realm . RealmObject } s and { @ link io . realm . RealmResults } will automatically contain 
 + * All { @ link io . realm . RealmObject } and { @ link io . realm . RealmResults } will automatically contain 
 * their new values when the { @ link # onChange ( ) } method is called . Normally this means that it 
 * isn ' t necessary to query again for those objects , but just invalidate any UI elements that are 
 * using them . If there is a chance that a object has been been deleted , it can be verified 
 diff - - git a / realm / src / main / java / io / realm / RealmList . java b / realm / src / main / java / io / realm / RealmList . java 
 index 912d4c2 . . 83e1455 100644 
 - - - a / realm / src / main / java / io / realm / RealmList . java 
 + + + b / realm / src / main / java / io / realm / RealmList . java 
 @ @ - 27 , 16 + 27 , 16 @ @ import io . realm . internal . TableQuery ; 
 / * * 
 * RealmList is used to model one - to - many relationships in a { @ link io . realm . RealmObject } . 
 * RealmList has two modes : A managed and non - managed mode . In managed mode all objects are persisted 
 - * inside a Realm , in non - managed mode it functions as an normal ArrayList . 
 + * inside a Realm , in non - managed mode it works as an normal ArrayList . 
 * 
 - * Only Realm can create managed RealmList ' s . Managed RealmList ' s will automatically update its 
 + * Only Realm can create managed RealmLists . Managed RealmLists will automatically update its 
 * content whenever the underlying Realm is updated , and can only be accessed using the getter 
 * from a { @ link io . realm . RealmObject } . 
 * 
 * Non - managed RealmLists can be created by the user and can contain both managed and non - managed 
 * RealmObjects . This is useful eg . when dealing with JSON deserializers like GSON or other 
 * frameworks that inject values into a class . Non - managed elements in this list can be added to a 
 - * Realm using { @ link Realm # copyToRealm ( Iterable ) } . 
 + * Realm using the { @ link Realm # copyToRealm ( Iterable ) } method . 
 * 
 * @ param < E > The class of objects in list . 
 * / 
 diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java 
 index 1956ad2 . . a97f049 100644 
 - - - a / realm / src / main / java / io / realm / RealmObject . java 
 + + + b / realm / src / main / java / io / realm / RealmObject . java 
 @ @ - 42 , 7 + 42 , 7 @ @ import io . realm . internal . Row ; 
 * - Getter and setters for these fields . 
 * - Static methods . 
 * 
 - * The following field data types are supported : 
 + * The following field data types are supported ( No boxed types ) : 
 * - boolean 
 * - short 
 * - int 
 @ @ - 55 , 11 + 55 , 13 @ @ import io . realm . internal . Row ; 
 * - Any RealmObject subclass 
 * - RealmList 
 * 
 - * All fields that are not annotated with { @ link io . realm . annotations . Ignore } require both a 
 - * getter and setter . Getter and setter names must have the name { @ code getXXX } or { @ code setXXX } if 
 + * Getter and setter names must have the name { @ code getXXX } or { @ code setXXX } if 
 * the field name is { @ code XXX } . Getters for fields of type boolean can be called { @ code isXXX } as 
 * well . 
 * 
 + * Fields annotated with { @ link io . realm . annotations . Ignore } doesn ' t have these restrictions and 
 + * don ' t require either a getter or setter . 
 + * 
 * A RealmObject cannot be parsed between different threads . 
 * 
 * @ see Realm # createObject ( Class ) 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index 40369c5 . . 6959bac 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 37 , 6 + 37 , 10 @ @ import io . realm . internal . TableView ; 
 * type safe , so if a model class is refactored care has to be taken to not break any queries . 
 * This is not optimal , but it is our current best compromise between ease of use and type safety . 
 * 
 + * A { @ link io . realm . Realm } is unordered , which means that there is no guarantee that querying a 
 + * Realm will return the objects in the order they where inserted . Use 
 + * { @ link # findAllSorted ( String ) } and similar methods if a specific order is required . 
 + * 
 * A RealmQuery cannot be parsed between different threads . 
 * 
 * @ param < E > The class of the objects to be queried . 
 diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java 
 index 3e4b93f . . ca60ba4 100644 
 - - - a / realm / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / src / main / java / io / realm / RealmResults . java 
 @ @ - 33 , 10 + 33 , 10 @ @ import io . realm . internal . TableView ; 
 / * * 
 * This class holds all the matches of a { @ link io . realm . RealmQuery } for a given Realm . The objects 
 * are not copied from the Realm to the RealmResults list , but are just referenced from the 
 - * RealmResult instead . This saves memory and increase speed . 
 + * RealmResult instead . This saves memory and increases speed . 
 * 
 - * Updates to RealmObjects from a RealmResults list must be done within a transaction and the 
 - * modified objects are persisted to the backing Realm file during the commit of the transaction . 
 + * Updates to RealmObjects from a RealmResults list must be done from within a transaction and the 
 + * modified objects are persisted to the Realm file during the commit of the transaction . 
 * 
 * A RealmResults object cannot be parsed between different threads . 
 *
