BLEU SCORE: 0.03283637368030199

TEST MSG: Add more capabilities to cleanup RunInLooperThread tests
GENERATED MSG: Init testing framework for multi processes

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RunTestInLooperThreadLifeCycleTest . java b / realm / realm - library / src / androidTest / java / io / realm / RunTestInLooperThreadLifeCycleTest . java <nl> new file mode 100644 <nl> index 0000000 . . cc70851 <nl> - - - / dev / null <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RunTestInLooperThreadLifeCycleTest . java <nl> @ @ - 0 , 0 + 1 , 113 @ @ <nl> + / * <nl> + * Copyright 2017 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm ; <nl> + <nl> + import android . support . test . runner . AndroidJUnit4 ; <nl> + <nl> + import org . junit . After ; <nl> + import org . junit . Before ; <nl> + import org . junit . Rule ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import java . io . Closeable ; <nl> + import java . io . IOException ; <nl> + import java . util . concurrent . atomic . AtomicBoolean ; <nl> + <nl> + import io . realm . rule . RunInLooperThread ; <nl> + import io . realm . rule . RunTestInLooperThread ; <nl> + <nl> + import static org . junit . Assert . assertFalse ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + <nl> + / * * <nl> + * Meta test . Checking the lifecycle of @ RunTestInLooperThreadTest does the right thing . <nl> + * <nl> + * Current order is : <nl> + * - @ RunTestInLooperThread ( before = < classRef > ) <nl> + * - @ Before ( ) <nl> + * - @ RunTestInLooperThread / @ Test <nl> + * - @ After : This is called when exiting the test method . Warning : Looper test is still running . <nl> + * - looperThread . runAfterTest ( Runnable ) : This is called when the LooperTest either succeed or fails . <nl> + * / <nl> + <nl> + @ RunWith ( AndroidJUnit4 . class ) <nl> + public class RunTestInLooperThreadLifeCycleTest { <nl> + <nl> + @ Rule <nl> + public final RunInLooperThread looperThread = new RunInLooperThread ( ) ; <nl> + <nl> + private static AtomicBoolean beforeCalled = new AtomicBoolean ( false ) ; <nl> + private static AtomicBoolean afterCalled = new AtomicBoolean ( false ) ; <nl> + private static AtomicBoolean testExited = new AtomicBoolean ( false ) ; <nl> + private static AtomicBoolean beforeRunnableCalled = new AtomicBoolean ( false ) ; <nl> + private static AtomicBoolean afterRunnableCalled = new AtomicBoolean ( false ) ; <nl> + private static AtomicBoolean closableClosed = new AtomicBoolean ( false ) ; <nl> + <nl> + @ Before <nl> + public void before ( ) { <nl> + assertTrue ( beforeCalled . compareAndSet ( false , true ) ) ; <nl> + assertTrue ( beforeRunnableCalled . get ( ) ) ; <nl> + <nl> + looperThread . closeAfterTest ( new Closeable ( ) { <nl> + @ Override <nl> + public void close ( ) throws IOException { <nl> + assertTrue ( testExited . get ( ) ) ; <nl> + assertFalse ( afterRunnableCalled . get ( ) ) ; <nl> + assertTrue ( closableClosed . compareAndSet ( false , true ) ) ; <nl> + } <nl> + } ) ; <nl> + looperThread . runAfterTest ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + assertTrue ( testExited . get ( ) ) ; <nl> + assertTrue ( afterRunnableCalled . compareAndSet ( false , true ) ) ; <nl> + assertTrue ( looperThread . isTestComplete ( ) ) ; <nl> + } <nl> + } ) ; <nl> + ; } <nl> + <nl> + @ After <nl> + public void after ( ) { <nl> + assertTrue ( afterCalled . compareAndSet ( false , true ) ) ; <nl> + assertTrue ( testExited . get ( ) ) ; <nl> + assertFalse ( looperThread . isTestComplete ( ) ) ; / / Beware of this . Use ` runAfterTest ` for destroying resources used . <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread ( before = PrepareLooperTest . class ) <nl> + public void looperTest ( ) { <nl> + looperThread . postRunnable ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + assertTrue ( afterCalled . get ( ) ) ; <nl> + assertFalse ( looperThread . isTestComplete ( ) ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + assertTrue ( testExited . compareAndSet ( false , true ) ) ; <nl> + } <nl> + <nl> + public static class PrepareLooperTest implements RunInLooperThread . RunnableBefore { <nl> + @ Override <nl> + public void run ( RealmConfiguration realmConfig ) { <nl> + assertTrue ( beforeRunnableCalled . compareAndSet ( false , true ) ) ; <nl> + assertFalse ( beforeCalled . get ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / rule / RunInLooperThread . java b / realm / realm - library / src / androidTest / java / io / realm / rule / RunInLooperThread . java <nl> index 33e6999 . . f44a42e 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / rule / RunInLooperThread . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / rule / RunInLooperThread . java <nl> @ @ - 23 , 6 + 23 , 8 @ @ import org . junit . runner . Description ; <nl> import org . junit . runners . model . MultipleFailureException ; <nl> import org . junit . runners . model . Statement ; <nl> <nl> + import java . io . Closeable ; <nl> + import java . io . IOException ; <nl> import java . io . PrintStream ; <nl> import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> @ @ - 81 , 6 + 83 , 14 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { <nl> / / Access guarded by ' lock ' <nl> private List < Realm > testRealms ; <nl> <nl> + / / List of closable resources that will be automatically closed when the test finishes . <nl> + / / Access guarded by ' lock ' <nl> + private List < Closeable > closableResources ; <nl> + <nl> + / / Runnable guaranteed to trigger after the test either succeeded or failed . <nl> + / / Access guarded by ' lock ' <nl> + private Runnable runAfterTestIsComplete ; <nl> + <nl> / * * <nl> * Get the configuration for the test realm . <nl> * < p > <nl> @ @ - 130 , 6 + 140 , 33 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { <nl> } <nl> <nl> / * * <nl> + * Add a closable resource which this test will guarantee to call { @ link Closeable # close ( ) } on <nl> + * when the tests is done . <nl> + * <nl> + * @ param closeable { @ link Closeable } to close . <nl> + * / <nl> + public void closeAfterTest ( Closeable closeable ) { <nl> + synchronized ( lock ) { <nl> + closableResources . add ( closeable ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Run this task after the unit test either failed or succeeded . <nl> + * This is a work - around for the the current @ After being triggered right after the unit test method exits , <nl> + * but before the @ RunTestInLooperThread has determined the test is done <nl> + * <nl> + * TODO : Consider replacing this pattern with ` @ AfterLooperTest ` annotation . <nl> + * <nl> + * @ param task task to run . Only one task can be provided <nl> + * / <nl> + public void runAfterTest ( Runnable task ) { <nl> + synchronized ( lock ) { <nl> + runAfterTestIsComplete = task ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> * Add a Realm to be closed when test is complete . <nl> * < p > <nl> * Accessed from both test and main threads . <nl> @ @ - 227 , 6 + 264 , 7 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { <nl> RealmConfiguration config = createConfiguration ( UUID . randomUUID ( ) . toString ( ) ) ; <nl> LinkedList < Object > refs = new LinkedList < > ( ) ; <nl> List < Realm > realms = new LinkedList < > ( ) ; <nl> + LinkedList < Closeable > closeables = new LinkedList < > ( ) ; <nl> <nl> synchronized ( lock ) { <nl> realmConfiguration = config ; <nl> @ @ - 234 , 6 + 272 , 7 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { <nl> backgroundHandler = null ; <nl> keepStrongReference = refs ; <nl> testRealms = realms ; <nl> + closableResources = closeables ; <nl> } <nl> } <nl> <nl> @ @ - 290 , 6 + 329 , 24 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { <nl> } <nl> } <nl> <nl> + private void closeResources ( ) throws IOException { <nl> + synchronized ( lock ) { <nl> + for ( Closeable cr : closableResources ) { <nl> + cr . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Checks if the current test is considered completed or not . <nl> + * It is completed if either { @ link # testComplete ( ) } was called or an uncaught exception was thrown . <nl> + * / <nl> + public boolean isTestComplete ( ) { <nl> + synchronized ( lock ) { <nl> + return signalTestCompleted . getCount ( ) = = 0 ; <nl> + } <nl> + } <nl> + <nl> / * * <nl> * If an implementation of this is supplied with the annotation , the { @ link RunnableBefore # run ( RealmConfiguration ) } <nl> * will be executed before the looper thread starts . It is normally for populating the Realm before the test . <nl> @ @ - 427 , 6 + 484 , 10 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { <nl> } finally { <nl> try { <nl> looperTearDown ( ) ; <nl> + closeResources ( ) ; <nl> + if ( runAfterTestIsComplete ! = null ) { <nl> + runAfterTestIsComplete . run ( ) ; <nl> + } <nl> } catch ( Throwable t ) { <nl> setAssertionError ( t ) ; <nl> setUnitTestFailed ( ) ;
NEAREST DIFF (one line): diff - - git a / realm / src / androidTest / AndroidManifest . xml b / realm / src / androidTest / AndroidManifest . xml <nl> new file mode 100644 <nl> index 0000000 . . d7fa5a8 <nl> - - - / dev / null <nl> + + + b / realm / src / androidTest / AndroidManifest . xml <nl> @ @ - 0 , 0 + 1 , 17 @ @ <nl> + < ? xml version = " 1 . 0 " encoding = " utf - 8 " ? > <nl> + < manifest xmlns : android = " http : / / schemas . android . com / apk / res / android " <nl> + package = " io . realm " > <nl> + <nl> + < uses - sdk android : minSdkVersion = " 16 " android : targetSdkVersion = " 22 " / > <nl> + <nl> + < application > <nl> + < uses - library android : name = " android . test . runner " / > <nl> + < service <nl> + android : name = " . services . RemoteProcessService " <nl> + android : enabled = " true " <nl> + android : exported = " true " <nl> + android : process = " : remote " > <nl> + < / service > <nl> + < / application > <nl> + <nl> + < / manifest > <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmInterprocessTest . java b / realm / src / androidTest / java / io / realm / RealmInterprocessTest . java <nl> new file mode 100644 <nl> index 0000000 . . 214acdc <nl> - - - / dev / null <nl> + + + b / realm / src / androidTest / java / io / realm / RealmInterprocessTest . java <nl> @ @ - 0 , 0 + 1 , 290 @ @ <nl> + package io . realm ; <nl> + <nl> + import android . annotation . SuppressLint ; <nl> + import android . app . ActivityManager ; <nl> + import android . content . ComponentName ; <nl> + import android . content . Context ; <nl> + import android . content . Intent ; <nl> + import android . content . ServiceConnection ; <nl> + import android . os . Bundle ; <nl> + import android . os . Handler ; <nl> + import android . os . IBinder ; <nl> + import android . os . Looper ; <nl> + import android . os . Message ; <nl> + import android . os . Messenger ; <nl> + import android . os . RemoteException ; <nl> + import android . test . AndroidTestCase ; <nl> + <nl> + import java . util . List ; <nl> + import java . util . concurrent . CountDownLatch ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import io . realm . entities . AllTypes ; <nl> + import io . realm . services . RemoteProcessService ; <nl> + <nl> + / / This is built for testing multi processes related cases . <nl> + / / To build a test case , create an InterprocessHandler in your test case . This handler will run in the newly <nl> + / / created thread ' s Looper . Remember to call Looper . loop ( ) to start handling messages . <nl> + / / Pass the first thing you want to run to the constructor which will be posted to the beginning of the message queue . <nl> + / / And add steps you want to run in the remote process in RemoteProcessService . <nl> + / / Write the comments of the test case like this : <nl> + / / A - Z means steps running from remote service process . <nl> + / / 1 - 9xx means steps running from the main local process . <nl> + / / eg . : A . Open a Realm <nl> + / / 1 . Open two Realms <nl> + / / B . Open three Realms <nl> + / / 2 . assertTrue ( " OK , remote process win . You can open more Realms than I do in the main local process " , false ) ; <nl> + public class RealmInterprocessTest extends AndroidTestCase { <nl> + private Realm testRealm ; <nl> + private Messenger remoteMessenger ; <nl> + private Messenger localMessenger ; <nl> + private CountDownLatch serviceStartLatch ; <nl> + private final ServiceConnection serviceConnection = new ServiceConnection ( ) { <nl> + @ Override <nl> + public void onServiceConnected ( ComponentName componentName , IBinder iBinder ) { <nl> + remoteMessenger = new Messenger ( iBinder ) ; <nl> + serviceStartLatch . countDown ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void onServiceDisconnected ( ComponentName componentName ) { <nl> + if ( serviceStartLatch ! = null & & serviceStartLatch . getCount ( ) > 1 ) { <nl> + serviceStartLatch . countDown ( ) ; <nl> + } <nl> + serviceStartLatch = null ; <nl> + } <nl> + } ; <nl> + <nl> + / / It is necessary to overload this method . <nl> + / / AndroidTestRunner does call Looper . prepare ( ) and we can have a looper in the case . The problem is all the test <nl> + / / cases are running in a single thread ! ! ! And after Looper . quit ( ) called , it cannot start again . That means we <nl> + / / can only have one case in this class LoL . <nl> + / / By overloading this method , we create a new thread and looper to run the real case . And use latch to wait until <nl> + / / it is finished . Then we can get rid of creating the thread in the test method , using array to store exception , many <nl> + / / levels of nested code . Make the test case more nature . <nl> + @ Override <nl> + public void runBare ( ) throws Throwable { <nl> + final Throwable [ ] throwableArray = new Throwable [ 1 ] ; <nl> + final CountDownLatch latch = new CountDownLatch ( 1 ) ; <nl> + Thread thread = new Thread ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + try { <nl> + RealmInterprocessTest . super . runBare ( ) ; <nl> + } catch ( Throwable throwable ) { <nl> + throwableArray [ 0 ] = throwable ; <nl> + } finally { <nl> + latch . countDown ( ) ; <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + thread . start ( ) ; <nl> + latch . await ( ) ; <nl> + <nl> + if ( throwableArray [ 0 ] ! = null ) { <nl> + throw throwableArray [ 0 ] ; <nl> + } <nl> + } <nl> + <nl> + / / Helper handler to make it easy to interact with remote service process . <nl> + @ SuppressLint ( " HandlerLeak " ) / / SuppressLint bug , doesn ' t work <nl> + private class InterprocessHandler extends Handler { <nl> + / / Timeout Watchdog . In case the service crashed or expected response is not returned . <nl> + / / It is very important to feed the dog after the expected message arrived . <nl> + private final int timeout = 5000 ; <nl> + private volatile boolean isTimeout = true ; <nl> + private Runnable timeoutRunnable = new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( isTimeout ) { <nl> + assertTrue ( " Timeout happened " , false ) ; <nl> + } else { <nl> + isTimeout = true ; <nl> + postDelayed ( timeoutRunnable , timeout ) ; <nl> + } <nl> + } <nl> + } ; <nl> + <nl> + protected void clearTimeoutFlag ( ) { <nl> + isTimeout = false ; <nl> + } <nl> + <nl> + protected void done ( ) { <nl> + Looper . myLooper ( ) . quit ( ) ; <nl> + } <nl> + <nl> + public InterprocessHandler ( Runnable startRunnable ) { <nl> + super ( Looper . myLooper ( ) ) ; <nl> + localMessenger = new Messenger ( this ) ; <nl> + / / To have the first step from main process run <nl> + post ( startRunnable ) ; <nl> + / / Start watchdog <nl> + postDelayed ( timeoutRunnable , timeout ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void handleMessage ( Message msg ) { <nl> + Bundle bundle = msg . getData ( ) ; <nl> + String error = bundle . getString ( RemoteProcessService . BUNDLE _ KEY _ ERROR ) ; <nl> + if ( error ! = null ) { <nl> + / / Assert and show error from service process <nl> + assertTrue ( error , false ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + protected void setUp ( ) throws Exception { <nl> + super . setUp ( ) ; <nl> + <nl> + Realm . deleteRealm ( new RealmConfiguration . Builder ( getContext ( ) ) . build ( ) ) ; <nl> + <nl> + / / Start the testing service <nl> + serviceStartLatch = new CountDownLatch ( 1 ) ; <nl> + Intent intent = new Intent ( getContext ( ) , RemoteProcessService . class ) ; <nl> + getContext ( ) . bindService ( intent , serviceConnection , Context . BIND _ AUTO _ CREATE ) ; <nl> + assertTrue ( serviceStartLatch . await ( 10 , TimeUnit . SECONDS ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected void tearDown ( ) throws Exception { <nl> + int counter = 10 ; <nl> + if ( testRealm ! = null ) { <nl> + testRealm . close ( ) ; <nl> + } <nl> + <nl> + getContext ( ) . unbindService ( serviceConnection ) ; <nl> + remoteMessenger = null ; <nl> + <nl> + / / Kill the remote process . <nl> + ActivityManager . RunningAppProcessInfo info = getRemoteProcessInfo ( ) ; <nl> + if ( info ! = null ) { <nl> + android . os . Process . killProcess ( info . pid ) ; <nl> + } <nl> + while ( getRemoteProcessInfo ( ) ! = null ) { <nl> + if ( counter = = 0 ) { <nl> + assertTrue ( " The remote service process is still alive . " , false ) ; <nl> + } <nl> + Thread . sleep ( 300 ) ; <nl> + counter - - ; <nl> + } <nl> + super . tearDown ( ) ; <nl> + } <nl> + <nl> + / / Call this to trigger the next step of service process <nl> + private void triggerServiceStep ( RemoteProcessService . Step step ) { <nl> + Message msg = Message . obtain ( null , step . message ) ; <nl> + msg . replyTo = localMessenger ; <nl> + try { <nl> + remoteMessenger . send ( msg ) ; <nl> + } catch ( RemoteException e ) { <nl> + assertTrue ( false ) ; <nl> + } <nl> + } <nl> + <nl> + / / Return the service info if it is alive . <nl> + / / When this method return null , it doesn ' t mean the remote process is not exsited . An ' empty ' process could <nl> + / / be retained by the system to be used next time . <nl> + / / Use getRemoteProcessInfo if you want to check the existence of remote process . <nl> + private ActivityManager . RunningServiceInfo getServiceInfo ( ) { <nl> + ActivityManager manager = ( ActivityManager ) getContext ( ) . getSystemService ( Context . ACTIVITY _ SERVICE ) ; <nl> + List < ActivityManager . RunningServiceInfo > serviceInfoList = manager . getRunningServices ( Integer . MAX _ VALUE ) ; <nl> + for ( ActivityManager . RunningServiceInfo service : serviceInfoList ) { <nl> + if ( RemoteProcessService . class . getName ( ) . equals ( service . service . getClassName ( ) ) ) { <nl> + return service ; <nl> + } <nl> + } <nl> + return null ; <nl> + } <nl> + <nl> + / / Get the remote process info if it is alive . <nl> + private ActivityManager . RunningAppProcessInfo getRemoteProcessInfo ( ) { <nl> + ActivityManager manager = ( ActivityManager ) getContext ( ) . getSystemService ( Context . ACTIVITY _ SERVICE ) ; <nl> + List < ActivityManager . RunningAppProcessInfo > processInfoList = manager . getRunningAppProcesses ( ) ; <nl> + for ( ActivityManager . RunningAppProcessInfo info : processInfoList ) { <nl> + if ( info . processName . equals ( getContext ( ) . getPackageName ( ) + " : remote " ) ) { <nl> + return info ; <nl> + } <nl> + } <nl> + <nl> + return null ; <nl> + } <nl> + <nl> + / / A . Open a realm , close it , then call Runtime . getRuntime ( ) . exit ( 0 ) . <nl> + / / 1 . Wait 3 seconds to see if the service process existed . <nl> + public void testExitProcess ( ) { <nl> + new InterprocessHandler ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + / / Step A <nl> + triggerServiceStep ( RemoteProcessService . stepExitProcess _ A ) ; <nl> + } <nl> + } ) { <nl> + <nl> + @ SuppressWarnings ( " ConstantConditions " ) <nl> + final int servicePid = getServiceInfo ( ) . pid ; <nl> + <nl> + @ Override <nl> + public void handleMessage ( Message msg ) { <nl> + super . handleMessage ( msg ) ; <nl> + if ( msg . what = = RemoteProcessService . stepExitProcess _ A . message ) { <nl> + / / Step 1 <nl> + clearTimeoutFlag ( ) ; <nl> + try { <nl> + / / Timeout is 5 seconds . 3 ( 6x500ms ) seconds should be enough to quit the process . <nl> + for ( int i = 1 ; i < = 6 ; i + + ) { <nl> + / / We need to retrieve the service ' s pid again since the system might restart it automatically . <nl> + ActivityManager . RunningAppProcessInfo processInfo = getRemoteProcessInfo ( ) ; <nl> + if ( processInfo ! = null & & processInfo . pid = = servicePid & & i > = 6 ) { <nl> + / / The process is still alive . <nl> + assertTrue ( false ) ; <nl> + } else if ( processInfo = = null | | processInfo . pid ! = servicePid ) { <nl> + / / The process is gone <nl> + break ; <nl> + } <nl> + Thread . sleep ( 500 , 0 ) ; <nl> + } <nl> + } catch ( InterruptedException e ) { <nl> + e . printStackTrace ( ) ; <nl> + assertTrue ( false ) ; <nl> + } <nl> + done ( ) ; <nl> + } <nl> + } <nl> + } ; <nl> + Looper . loop ( ) ; <nl> + } <nl> + <nl> + / / 1 . Main process create Realm , write one object . <nl> + / / A . Service process open Realm , check if there is one and only one object . <nl> + public void testCreateInitialRealm ( ) throws InterruptedException { <nl> + new InterprocessHandler ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + / / Step 1 <nl> + testRealm = Realm . getInstance ( getContext ( ) ) ; <nl> + assertEquals ( testRealm . allObjects ( AllTypes . class ) . size ( ) , 0 ) ; <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . createObject ( AllTypes . class ) ; <nl> + testRealm . commitTransaction ( ) ; <nl> + <nl> + / / Step A <nl> + triggerServiceStep ( RemoteProcessService . stepCreateInitialRealm _ A ) ; <nl> + } } ) { <nl> + <nl> + @ Override <nl> + public void handleMessage ( Message msg ) { <nl> + super . handleMessage ( msg ) ; <nl> + if ( msg . what = = RemoteProcessService . stepCreateInitialRealm _ A . message ) { <nl> + clearTimeoutFlag ( ) ; <nl> + done ( ) ; <nl> + } else { <nl> + assertTrue ( false ) ; <nl> + } <nl> + } <nl> + } ; <nl> + Looper . loop ( ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / src / androidTest / java / io / realm / services / RemoteProcessService . java b / realm / src / androidTest / java / io / realm / services / RemoteProcessService . java <nl> new file mode 100644 <nl> index 0000000 . . 97e5321 <nl> - - - / dev / null <nl> + + + b / realm / src / androidTest / java / io / realm / services / RemoteProcessService . java <nl> @ @ - 0 , 0 + 1 , 129 @ @ <nl> + package io . realm . services ; <nl> + <nl> + import android . app . Service ; <nl> + import android . content . Intent ; <nl> + import android . os . Bundle ; <nl> + import android . os . Handler ; <nl> + import android . os . IBinder ; <nl> + import android . os . Message ; <nl> + import android . os . Messenger ; <nl> + import android . os . RemoteException ; <nl> + <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + <nl> + import io . realm . Realm ; <nl> + import io . realm . entities . AllTypes ; <nl> + <nl> + / * * <nl> + * Helper service for multi - processes support testing . <nl> + * / <nl> + public class RemoteProcessService extends Service { <nl> + <nl> + public abstract static class Step { <nl> + public final int message ; <nl> + private Step ( int message ) { <nl> + this . message = message ; <nl> + stepMap . put ( message , this ) ; <nl> + } <nl> + <nl> + abstract void run ( ) ; <nl> + <nl> + / / Pass a null to tell main process that everything is OK . <nl> + / / Otherwise , pass a error String which will be used by assertion in main process . <nl> + protected void response ( String error ) { <nl> + try { <nl> + Message msg = Message . obtain ( null , message ) ; <nl> + if ( error ! = null ) { <nl> + Bundle bundle = new Bundle ( ) ; <nl> + bundle . putString ( BUNDLE _ KEY _ ERROR , error ) ; <nl> + msg . setData ( bundle ) ; <nl> + } <nl> + thiz . client . send ( msg ) ; <nl> + } catch ( RemoteException e ) { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public static final String BUNDLE _ KEY _ ERROR = " error " ; <nl> + private static Map < Integer , Step > stepMap = new HashMap < Integer , Step > ( ) ; <nl> + <nl> + private static RemoteProcessService thiz ; <nl> + private Realm testRealm ; <nl> + <nl> + private final Messenger messenger = new Messenger ( new IncomingHandler ( ) ) ; <nl> + private Messenger client ; <nl> + <nl> + public RemoteProcessService ( ) { <nl> + if ( thiz ! = null ) { <nl> + throw new RuntimeException ( " Only one instance is allowed ! " ) ; <nl> + } <nl> + thiz = this ; <nl> + } <nl> + <nl> + @ Override <nl> + public IBinder onBind ( Intent intent ) { <nl> + return messenger . getBinder ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean onUnbind ( Intent intent ) { <nl> + stopSelf ( ) ; <nl> + return super . onUnbind ( intent ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int onStartCommand ( Intent intent , int flags , int startId ) { <nl> + return START _ NOT _ STICKY ; <nl> + } <nl> + <nl> + private static class IncomingHandler extends Handler { <nl> + @ Override <nl> + public void handleMessage ( Message msg ) { <nl> + thiz . client = msg . replyTo ; <nl> + if ( thiz . client = = null ) { <nl> + throw new RuntimeException ( " Message with an empty client . " ) ; <nl> + } <nl> + Step step = stepMap . get ( msg . what ) ; <nl> + if ( step ! = null ) { <nl> + step . run ( ) ; <nl> + } else { <nl> + throw new RuntimeException ( " Cannot find corresponding step to message " + msg . what + " . " ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / / Call this function to return the String of current class and line number . <nl> + private static String currentLine ( ) { <nl> + StackTraceElement element = new Throwable ( ) . getStackTrace ( ) [ 1 ] ; <nl> + return element . getClassName ( ) + " line " + element . getLineNumber ( ) + " : " ; <nl> + } <nl> + <nl> + public final static Step stepCreateInitialRealm _ A = new Step ( 10 ) { <nl> + <nl> + @ Override <nl> + void run ( ) { <nl> + thiz . testRealm = Realm . getInstance ( thiz ) ; <nl> + int expected = 1 ; <nl> + int got = thiz . testRealm . allObjects ( AllTypes . class ) . size ( ) ; <nl> + if ( expected = = got ) { <nl> + response ( null ) ; <nl> + } else { <nl> + response ( currentLine ( ) + " expected : " + expected + " , but got " + got ) ; <nl> + } <nl> + thiz . testRealm . close ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + public final static Step stepExitProcess _ A = new Step ( 20 ) { <nl> + <nl> + @ Override <nl> + void run ( ) { <nl> + thiz . testRealm = Realm . getInstance ( thiz ) ; <nl> + thiz . testRealm . close ( ) ; <nl> + response ( null ) ; <nl> + Runtime . getRuntime ( ) . exit ( 0 ) ; <nl> + } <nl> + } ; <nl> + }

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RunTestInLooperThreadLifeCycleTest . java b / realm / realm - library / src / androidTest / java / io / realm / RunTestInLooperThreadLifeCycleTest . java 
 new file mode 100644 
 index 0000000 . . cc70851 
 - - - / dev / null 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RunTestInLooperThreadLifeCycleTest . java 
 @ @ - 0 , 0 + 1 , 113 @ @ 
 + / * 
 + * Copyright 2017 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm ; 
 + 
 + import android . support . test . runner . AndroidJUnit4 ; 
 + 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Rule ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import java . io . Closeable ; 
 + import java . io . IOException ; 
 + import java . util . concurrent . atomic . AtomicBoolean ; 
 + 
 + import io . realm . rule . RunInLooperThread ; 
 + import io . realm . rule . RunTestInLooperThread ; 
 + 
 + import static org . junit . Assert . assertFalse ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + 
 + / * * 
 + * Meta test . Checking the lifecycle of @ RunTestInLooperThreadTest does the right thing . 
 + * 
 + * Current order is : 
 + * - @ RunTestInLooperThread ( before = < classRef > ) 
 + * - @ Before ( ) 
 + * - @ RunTestInLooperThread / @ Test 
 + * - @ After : This is called when exiting the test method . Warning : Looper test is still running . 
 + * - looperThread . runAfterTest ( Runnable ) : This is called when the LooperTest either succeed or fails . 
 + * / 
 + 
 + @ RunWith ( AndroidJUnit4 . class ) 
 + public class RunTestInLooperThreadLifeCycleTest { 
 + 
 + @ Rule 
 + public final RunInLooperThread looperThread = new RunInLooperThread ( ) ; 
 + 
 + private static AtomicBoolean beforeCalled = new AtomicBoolean ( false ) ; 
 + private static AtomicBoolean afterCalled = new AtomicBoolean ( false ) ; 
 + private static AtomicBoolean testExited = new AtomicBoolean ( false ) ; 
 + private static AtomicBoolean beforeRunnableCalled = new AtomicBoolean ( false ) ; 
 + private static AtomicBoolean afterRunnableCalled = new AtomicBoolean ( false ) ; 
 + private static AtomicBoolean closableClosed = new AtomicBoolean ( false ) ; 
 + 
 + @ Before 
 + public void before ( ) { 
 + assertTrue ( beforeCalled . compareAndSet ( false , true ) ) ; 
 + assertTrue ( beforeRunnableCalled . get ( ) ) ; 
 + 
 + looperThread . closeAfterTest ( new Closeable ( ) { 
 + @ Override 
 + public void close ( ) throws IOException { 
 + assertTrue ( testExited . get ( ) ) ; 
 + assertFalse ( afterRunnableCalled . get ( ) ) ; 
 + assertTrue ( closableClosed . compareAndSet ( false , true ) ) ; 
 + } 
 + } ) ; 
 + looperThread . runAfterTest ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + assertTrue ( testExited . get ( ) ) ; 
 + assertTrue ( afterRunnableCalled . compareAndSet ( false , true ) ) ; 
 + assertTrue ( looperThread . isTestComplete ( ) ) ; 
 + } 
 + } ) ; 
 + ; } 
 + 
 + @ After 
 + public void after ( ) { 
 + assertTrue ( afterCalled . compareAndSet ( false , true ) ) ; 
 + assertTrue ( testExited . get ( ) ) ; 
 + assertFalse ( looperThread . isTestComplete ( ) ) ; / / Beware of this . Use ` runAfterTest ` for destroying resources used . 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread ( before = PrepareLooperTest . class ) 
 + public void looperTest ( ) { 
 + looperThread . postRunnable ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + assertTrue ( afterCalled . get ( ) ) ; 
 + assertFalse ( looperThread . isTestComplete ( ) ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + assertTrue ( testExited . compareAndSet ( false , true ) ) ; 
 + } 
 + 
 + public static class PrepareLooperTest implements RunInLooperThread . RunnableBefore { 
 + @ Override 
 + public void run ( RealmConfiguration realmConfig ) { 
 + assertTrue ( beforeRunnableCalled . compareAndSet ( false , true ) ) ; 
 + assertFalse ( beforeCalled . get ( ) ) ; 
 + } 
 + } 
 + } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / rule / RunInLooperThread . java b / realm / realm - library / src / androidTest / java / io / realm / rule / RunInLooperThread . java 
 index 33e6999 . . f44a42e 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / rule / RunInLooperThread . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / rule / RunInLooperThread . java 
 @ @ - 23 , 6 + 23 , 8 @ @ import org . junit . runner . Description ; 
 import org . junit . runners . model . MultipleFailureException ; 
 import org . junit . runners . model . Statement ; 
 
 + import java . io . Closeable ; 
 + import java . io . IOException ; 
 import java . io . PrintStream ; 
 import java . util . ArrayList ; 
 import java . util . Arrays ; 
 @ @ - 81 , 6 + 83 , 14 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { 
 / / Access guarded by ' lock ' 
 private List < Realm > testRealms ; 
 
 + / / List of closable resources that will be automatically closed when the test finishes . 
 + / / Access guarded by ' lock ' 
 + private List < Closeable > closableResources ; 
 + 
 + / / Runnable guaranteed to trigger after the test either succeeded or failed . 
 + / / Access guarded by ' lock ' 
 + private Runnable runAfterTestIsComplete ; 
 + 
 / * * 
 * Get the configuration for the test realm . 
 * < p > 
 @ @ - 130 , 6 + 140 , 33 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { 
 } 
 
 / * * 
 + * Add a closable resource which this test will guarantee to call { @ link Closeable # close ( ) } on 
 + * when the tests is done . 
 + * 
 + * @ param closeable { @ link Closeable } to close . 
 + * / 
 + public void closeAfterTest ( Closeable closeable ) { 
 + synchronized ( lock ) { 
 + closableResources . add ( closeable ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Run this task after the unit test either failed or succeeded . 
 + * This is a work - around for the the current @ After being triggered right after the unit test method exits , 
 + * but before the @ RunTestInLooperThread has determined the test is done 
 + * 
 + * TODO : Consider replacing this pattern with ` @ AfterLooperTest ` annotation . 
 + * 
 + * @ param task task to run . Only one task can be provided 
 + * / 
 + public void runAfterTest ( Runnable task ) { 
 + synchronized ( lock ) { 
 + runAfterTestIsComplete = task ; 
 + } 
 + } 
 + 
 + / * * 
 * Add a Realm to be closed when test is complete . 
 * < p > 
 * Accessed from both test and main threads . 
 @ @ - 227 , 6 + 264 , 7 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { 
 RealmConfiguration config = createConfiguration ( UUID . randomUUID ( ) . toString ( ) ) ; 
 LinkedList < Object > refs = new LinkedList < > ( ) ; 
 List < Realm > realms = new LinkedList < > ( ) ; 
 + LinkedList < Closeable > closeables = new LinkedList < > ( ) ; 
 
 synchronized ( lock ) { 
 realmConfiguration = config ; 
 @ @ - 234 , 6 + 272 , 7 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { 
 backgroundHandler = null ; 
 keepStrongReference = refs ; 
 testRealms = realms ; 
 + closableResources = closeables ; 
 } 
 } 
 
 @ @ - 290 , 6 + 329 , 24 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { 
 } 
 } 
 
 + private void closeResources ( ) throws IOException { 
 + synchronized ( lock ) { 
 + for ( Closeable cr : closableResources ) { 
 + cr . close ( ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Checks if the current test is considered completed or not . 
 + * It is completed if either { @ link # testComplete ( ) } was called or an uncaught exception was thrown . 
 + * / 
 + public boolean isTestComplete ( ) { 
 + synchronized ( lock ) { 
 + return signalTestCompleted . getCount ( ) = = 0 ; 
 + } 
 + } 
 + 
 / * * 
 * If an implementation of this is supplied with the annotation , the { @ link RunnableBefore # run ( RealmConfiguration ) } 
 * will be executed before the looper thread starts . It is normally for populating the Realm before the test . 
 @ @ - 427 , 6 + 484 , 10 @ @ public class RunInLooperThread extends TestRealmConfigurationFactory { 
 } finally { 
 try { 
 looperTearDown ( ) ; 
 + closeResources ( ) ; 
 + if ( runAfterTestIsComplete ! = null ) { 
 + runAfterTestIsComplete . run ( ) ; 
 + } 
 } catch ( Throwable t ) { 
 setAssertionError ( t ) ; 
 setUnitTestFailed ( ) ;

NEAREST DIFF:
diff - - git a / realm / src / androidTest / AndroidManifest . xml b / realm / src / androidTest / AndroidManifest . xml 
 new file mode 100644 
 index 0000000 . . d7fa5a8 
 - - - / dev / null 
 + + + b / realm / src / androidTest / AndroidManifest . xml 
 @ @ - 0 , 0 + 1 , 17 @ @ 
 + < ? xml version = " 1 . 0 " encoding = " utf - 8 " ? > 
 + < manifest xmlns : android = " http : / / schemas . android . com / apk / res / android " 
 + package = " io . realm " > 
 + 
 + < uses - sdk android : minSdkVersion = " 16 " android : targetSdkVersion = " 22 " / > 
 + 
 + < application > 
 + < uses - library android : name = " android . test . runner " / > 
 + < service 
 + android : name = " . services . RemoteProcessService " 
 + android : enabled = " true " 
 + android : exported = " true " 
 + android : process = " : remote " > 
 + < / service > 
 + < / application > 
 + 
 + < / manifest > 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmInterprocessTest . java b / realm / src / androidTest / java / io / realm / RealmInterprocessTest . java 
 new file mode 100644 
 index 0000000 . . 214acdc 
 - - - / dev / null 
 + + + b / realm / src / androidTest / java / io / realm / RealmInterprocessTest . java 
 @ @ - 0 , 0 + 1 , 290 @ @ 
 + package io . realm ; 
 + 
 + import android . annotation . SuppressLint ; 
 + import android . app . ActivityManager ; 
 + import android . content . ComponentName ; 
 + import android . content . Context ; 
 + import android . content . Intent ; 
 + import android . content . ServiceConnection ; 
 + import android . os . Bundle ; 
 + import android . os . Handler ; 
 + import android . os . IBinder ; 
 + import android . os . Looper ; 
 + import android . os . Message ; 
 + import android . os . Messenger ; 
 + import android . os . RemoteException ; 
 + import android . test . AndroidTestCase ; 
 + 
 + import java . util . List ; 
 + import java . util . concurrent . CountDownLatch ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import io . realm . entities . AllTypes ; 
 + import io . realm . services . RemoteProcessService ; 
 + 
 + / / This is built for testing multi processes related cases . 
 + / / To build a test case , create an InterprocessHandler in your test case . This handler will run in the newly 
 + / / created thread ' s Looper . Remember to call Looper . loop ( ) to start handling messages . 
 + / / Pass the first thing you want to run to the constructor which will be posted to the beginning of the message queue . 
 + / / And add steps you want to run in the remote process in RemoteProcessService . 
 + / / Write the comments of the test case like this : 
 + / / A - Z means steps running from remote service process . 
 + / / 1 - 9xx means steps running from the main local process . 
 + / / eg . : A . Open a Realm 
 + / / 1 . Open two Realms 
 + / / B . Open three Realms 
 + / / 2 . assertTrue ( " OK , remote process win . You can open more Realms than I do in the main local process " , false ) ; 
 + public class RealmInterprocessTest extends AndroidTestCase { 
 + private Realm testRealm ; 
 + private Messenger remoteMessenger ; 
 + private Messenger localMessenger ; 
 + private CountDownLatch serviceStartLatch ; 
 + private final ServiceConnection serviceConnection = new ServiceConnection ( ) { 
 + @ Override 
 + public void onServiceConnected ( ComponentName componentName , IBinder iBinder ) { 
 + remoteMessenger = new Messenger ( iBinder ) ; 
 + serviceStartLatch . countDown ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onServiceDisconnected ( ComponentName componentName ) { 
 + if ( serviceStartLatch ! = null & & serviceStartLatch . getCount ( ) > 1 ) { 
 + serviceStartLatch . countDown ( ) ; 
 + } 
 + serviceStartLatch = null ; 
 + } 
 + } ; 
 + 
 + / / It is necessary to overload this method . 
 + / / AndroidTestRunner does call Looper . prepare ( ) and we can have a looper in the case . The problem is all the test 
 + / / cases are running in a single thread ! ! ! And after Looper . quit ( ) called , it cannot start again . That means we 
 + / / can only have one case in this class LoL . 
 + / / By overloading this method , we create a new thread and looper to run the real case . And use latch to wait until 
 + / / it is finished . Then we can get rid of creating the thread in the test method , using array to store exception , many 
 + / / levels of nested code . Make the test case more nature . 
 + @ Override 
 + public void runBare ( ) throws Throwable { 
 + final Throwable [ ] throwableArray = new Throwable [ 1 ] ; 
 + final CountDownLatch latch = new CountDownLatch ( 1 ) ; 
 + Thread thread = new Thread ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + try { 
 + RealmInterprocessTest . super . runBare ( ) ; 
 + } catch ( Throwable throwable ) { 
 + throwableArray [ 0 ] = throwable ; 
 + } finally { 
 + latch . countDown ( ) ; 
 + } 
 + } 
 + } ) ; 
 + 
 + thread . start ( ) ; 
 + latch . await ( ) ; 
 + 
 + if ( throwableArray [ 0 ] ! = null ) { 
 + throw throwableArray [ 0 ] ; 
 + } 
 + } 
 + 
 + / / Helper handler to make it easy to interact with remote service process . 
 + @ SuppressLint ( " HandlerLeak " ) / / SuppressLint bug , doesn ' t work 
 + private class InterprocessHandler extends Handler { 
 + / / Timeout Watchdog . In case the service crashed or expected response is not returned . 
 + / / It is very important to feed the dog after the expected message arrived . 
 + private final int timeout = 5000 ; 
 + private volatile boolean isTimeout = true ; 
 + private Runnable timeoutRunnable = new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( isTimeout ) { 
 + assertTrue ( " Timeout happened " , false ) ; 
 + } else { 
 + isTimeout = true ; 
 + postDelayed ( timeoutRunnable , timeout ) ; 
 + } 
 + } 
 + } ; 
 + 
 + protected void clearTimeoutFlag ( ) { 
 + isTimeout = false ; 
 + } 
 + 
 + protected void done ( ) { 
 + Looper . myLooper ( ) . quit ( ) ; 
 + } 
 + 
 + public InterprocessHandler ( Runnable startRunnable ) { 
 + super ( Looper . myLooper ( ) ) ; 
 + localMessenger = new Messenger ( this ) ; 
 + / / To have the first step from main process run 
 + post ( startRunnable ) ; 
 + / / Start watchdog 
 + postDelayed ( timeoutRunnable , timeout ) ; 
 + } 
 + 
 + @ Override 
 + public void handleMessage ( Message msg ) { 
 + Bundle bundle = msg . getData ( ) ; 
 + String error = bundle . getString ( RemoteProcessService . BUNDLE _ KEY _ ERROR ) ; 
 + if ( error ! = null ) { 
 + / / Assert and show error from service process 
 + assertTrue ( error , false ) ; 
 + } 
 + } 
 + } 
 + 
 + @ Override 
 + protected void setUp ( ) throws Exception { 
 + super . setUp ( ) ; 
 + 
 + Realm . deleteRealm ( new RealmConfiguration . Builder ( getContext ( ) ) . build ( ) ) ; 
 + 
 + / / Start the testing service 
 + serviceStartLatch = new CountDownLatch ( 1 ) ; 
 + Intent intent = new Intent ( getContext ( ) , RemoteProcessService . class ) ; 
 + getContext ( ) . bindService ( intent , serviceConnection , Context . BIND _ AUTO _ CREATE ) ; 
 + assertTrue ( serviceStartLatch . await ( 10 , TimeUnit . SECONDS ) ) ; 
 + } 
 + 
 + @ Override 
 + protected void tearDown ( ) throws Exception { 
 + int counter = 10 ; 
 + if ( testRealm ! = null ) { 
 + testRealm . close ( ) ; 
 + } 
 + 
 + getContext ( ) . unbindService ( serviceConnection ) ; 
 + remoteMessenger = null ; 
 + 
 + / / Kill the remote process . 
 + ActivityManager . RunningAppProcessInfo info = getRemoteProcessInfo ( ) ; 
 + if ( info ! = null ) { 
 + android . os . Process . killProcess ( info . pid ) ; 
 + } 
 + while ( getRemoteProcessInfo ( ) ! = null ) { 
 + if ( counter = = 0 ) { 
 + assertTrue ( " The remote service process is still alive . " , false ) ; 
 + } 
 + Thread . sleep ( 300 ) ; 
 + counter - - ; 
 + } 
 + super . tearDown ( ) ; 
 + } 
 + 
 + / / Call this to trigger the next step of service process 
 + private void triggerServiceStep ( RemoteProcessService . Step step ) { 
 + Message msg = Message . obtain ( null , step . message ) ; 
 + msg . replyTo = localMessenger ; 
 + try { 
 + remoteMessenger . send ( msg ) ; 
 + } catch ( RemoteException e ) { 
 + assertTrue ( false ) ; 
 + } 
 + } 
 + 
 + / / Return the service info if it is alive . 
 + / / When this method return null , it doesn ' t mean the remote process is not exsited . An ' empty ' process could 
 + / / be retained by the system to be used next time . 
 + / / Use getRemoteProcessInfo if you want to check the existence of remote process . 
 + private ActivityManager . RunningServiceInfo getServiceInfo ( ) { 
 + ActivityManager manager = ( ActivityManager ) getContext ( ) . getSystemService ( Context . ACTIVITY _ SERVICE ) ; 
 + List < ActivityManager . RunningServiceInfo > serviceInfoList = manager . getRunningServices ( Integer . MAX _ VALUE ) ; 
 + for ( ActivityManager . RunningServiceInfo service : serviceInfoList ) { 
 + if ( RemoteProcessService . class . getName ( ) . equals ( service . service . getClassName ( ) ) ) { 
 + return service ; 
 + } 
 + } 
 + return null ; 
 + } 
 + 
 + / / Get the remote process info if it is alive . 
 + private ActivityManager . RunningAppProcessInfo getRemoteProcessInfo ( ) { 
 + ActivityManager manager = ( ActivityManager ) getContext ( ) . getSystemService ( Context . ACTIVITY _ SERVICE ) ; 
 + List < ActivityManager . RunningAppProcessInfo > processInfoList = manager . getRunningAppProcesses ( ) ; 
 + for ( ActivityManager . RunningAppProcessInfo info : processInfoList ) { 
 + if ( info . processName . equals ( getContext ( ) . getPackageName ( ) + " : remote " ) ) { 
 + return info ; 
 + } 
 + } 
 + 
 + return null ; 
 + } 
 + 
 + / / A . Open a realm , close it , then call Runtime . getRuntime ( ) . exit ( 0 ) . 
 + / / 1 . Wait 3 seconds to see if the service process existed . 
 + public void testExitProcess ( ) { 
 + new InterprocessHandler ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + / / Step A 
 + triggerServiceStep ( RemoteProcessService . stepExitProcess _ A ) ; 
 + } 
 + } ) { 
 + 
 + @ SuppressWarnings ( " ConstantConditions " ) 
 + final int servicePid = getServiceInfo ( ) . pid ; 
 + 
 + @ Override 
 + public void handleMessage ( Message msg ) { 
 + super . handleMessage ( msg ) ; 
 + if ( msg . what = = RemoteProcessService . stepExitProcess _ A . message ) { 
 + / / Step 1 
 + clearTimeoutFlag ( ) ; 
 + try { 
 + / / Timeout is 5 seconds . 3 ( 6x500ms ) seconds should be enough to quit the process . 
 + for ( int i = 1 ; i < = 6 ; i + + ) { 
 + / / We need to retrieve the service ' s pid again since the system might restart it automatically . 
 + ActivityManager . RunningAppProcessInfo processInfo = getRemoteProcessInfo ( ) ; 
 + if ( processInfo ! = null & & processInfo . pid = = servicePid & & i > = 6 ) { 
 + / / The process is still alive . 
 + assertTrue ( false ) ; 
 + } else if ( processInfo = = null | | processInfo . pid ! = servicePid ) { 
 + / / The process is gone 
 + break ; 
 + } 
 + Thread . sleep ( 500 , 0 ) ; 
 + } 
 + } catch ( InterruptedException e ) { 
 + e . printStackTrace ( ) ; 
 + assertTrue ( false ) ; 
 + } 
 + done ( ) ; 
 + } 
 + } 
 + } ; 
 + Looper . loop ( ) ; 
 + } 
 + 
 + / / 1 . Main process create Realm , write one object . 
 + / / A . Service process open Realm , check if there is one and only one object . 
 + public void testCreateInitialRealm ( ) throws InterruptedException { 
 + new InterprocessHandler ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + / / Step 1 
 + testRealm = Realm . getInstance ( getContext ( ) ) ; 
 + assertEquals ( testRealm . allObjects ( AllTypes . class ) . size ( ) , 0 ) ; 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . createObject ( AllTypes . class ) ; 
 + testRealm . commitTransaction ( ) ; 
 + 
 + / / Step A 
 + triggerServiceStep ( RemoteProcessService . stepCreateInitialRealm _ A ) ; 
 + } } ) { 
 + 
 + @ Override 
 + public void handleMessage ( Message msg ) { 
 + super . handleMessage ( msg ) ; 
 + if ( msg . what = = RemoteProcessService . stepCreateInitialRealm _ A . message ) { 
 + clearTimeoutFlag ( ) ; 
 + done ( ) ; 
 + } else { 
 + assertTrue ( false ) ; 
 + } 
 + } 
 + } ; 
 + Looper . loop ( ) ; 
 + } 
 + } 
 diff - - git a / realm / src / androidTest / java / io / realm / services / RemoteProcessService . java b / realm / src / androidTest / java / io / realm / services / RemoteProcessService . java 
 new file mode 100644 
 index 0000000 . . 97e5321 
 - - - / dev / null 
 + + + b / realm / src / androidTest / java / io / realm / services / RemoteProcessService . java 
 @ @ - 0 , 0 + 1 , 129 @ @ 
 + package io . realm . services ; 
 + 
 + import android . app . Service ; 
 + import android . content . Intent ; 
 + import android . os . Bundle ; 
 + import android . os . Handler ; 
 + import android . os . IBinder ; 
 + import android . os . Message ; 
 + import android . os . Messenger ; 
 + import android . os . RemoteException ; 
 + 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + 
 + import io . realm . Realm ; 
 + import io . realm . entities . AllTypes ; 
 + 
 + / * * 
 + * Helper service for multi - processes support testing . 
 + * / 
 + public class RemoteProcessService extends Service { 
 + 
 + public abstract static class Step { 
 + public final int message ; 
 + private Step ( int message ) { 
 + this . message = message ; 
 + stepMap . put ( message , this ) ; 
 + } 
 + 
 + abstract void run ( ) ; 
 + 
 + / / Pass a null to tell main process that everything is OK . 
 + / / Otherwise , pass a error String which will be used by assertion in main process . 
 + protected void response ( String error ) { 
 + try { 
 + Message msg = Message . obtain ( null , message ) ; 
 + if ( error ! = null ) { 
 + Bundle bundle = new Bundle ( ) ; 
 + bundle . putString ( BUNDLE _ KEY _ ERROR , error ) ; 
 + msg . setData ( bundle ) ; 
 + } 
 + thiz . client . send ( msg ) ; 
 + } catch ( RemoteException e ) { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + } 
 + 
 + public static final String BUNDLE _ KEY _ ERROR = " error " ; 
 + private static Map < Integer , Step > stepMap = new HashMap < Integer , Step > ( ) ; 
 + 
 + private static RemoteProcessService thiz ; 
 + private Realm testRealm ; 
 + 
 + private final Messenger messenger = new Messenger ( new IncomingHandler ( ) ) ; 
 + private Messenger client ; 
 + 
 + public RemoteProcessService ( ) { 
 + if ( thiz ! = null ) { 
 + throw new RuntimeException ( " Only one instance is allowed ! " ) ; 
 + } 
 + thiz = this ; 
 + } 
 + 
 + @ Override 
 + public IBinder onBind ( Intent intent ) { 
 + return messenger . getBinder ( ) ; 
 + } 
 + 
 + @ Override 
 + public boolean onUnbind ( Intent intent ) { 
 + stopSelf ( ) ; 
 + return super . onUnbind ( intent ) ; 
 + } 
 + 
 + @ Override 
 + public int onStartCommand ( Intent intent , int flags , int startId ) { 
 + return START _ NOT _ STICKY ; 
 + } 
 + 
 + private static class IncomingHandler extends Handler { 
 + @ Override 
 + public void handleMessage ( Message msg ) { 
 + thiz . client = msg . replyTo ; 
 + if ( thiz . client = = null ) { 
 + throw new RuntimeException ( " Message with an empty client . " ) ; 
 + } 
 + Step step = stepMap . get ( msg . what ) ; 
 + if ( step ! = null ) { 
 + step . run ( ) ; 
 + } else { 
 + throw new RuntimeException ( " Cannot find corresponding step to message " + msg . what + " . " ) ; 
 + } 
 + } 
 + } 
 + 
 + / / Call this function to return the String of current class and line number . 
 + private static String currentLine ( ) { 
 + StackTraceElement element = new Throwable ( ) . getStackTrace ( ) [ 1 ] ; 
 + return element . getClassName ( ) + " line " + element . getLineNumber ( ) + " : " ; 
 + } 
 + 
 + public final static Step stepCreateInitialRealm _ A = new Step ( 10 ) { 
 + 
 + @ Override 
 + void run ( ) { 
 + thiz . testRealm = Realm . getInstance ( thiz ) ; 
 + int expected = 1 ; 
 + int got = thiz . testRealm . allObjects ( AllTypes . class ) . size ( ) ; 
 + if ( expected = = got ) { 
 + response ( null ) ; 
 + } else { 
 + response ( currentLine ( ) + " expected : " + expected + " , but got " + got ) ; 
 + } 
 + thiz . testRealm . close ( ) ; 
 + } 
 + } ; 
 + 
 + public final static Step stepExitProcess _ A = new Step ( 20 ) { 
 + 
 + @ Override 
 + void run ( ) { 
 + thiz . testRealm = Realm . getInstance ( thiz ) ; 
 + thiz . testRealm . close ( ) ; 
 + response ( null ) ; 
 + Runtime . getRuntime ( ) . exit ( 0 ) ; 
 + } 
 + } ; 
 + }
