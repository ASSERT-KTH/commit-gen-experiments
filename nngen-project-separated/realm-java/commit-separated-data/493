BLEU SCORE: 0.019648763141608138

TEST MSG: We cannot deprecate the findFirstAsync
GENERATED MSG: now RealmQuery throw exception if reused for another async query

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java <nl> index d490d8e . . dae1912 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java <nl> @ @ - 614 , 8 + 614 , 6 @ @ public class DynamicRealmObjectTests { <nl> @ Test <nl> public void setObject _ objectBelongToDiffThreadRealmThrows ( ) { <nl> final CountDownLatch finishedLatch = new CountDownLatch ( 1 ) ; <nl> - / / To run the query of the PendingRow first . <nl> - assertTrue ( dObjDynamic . isValid ( ) ) ; <nl> <nl> new Thread ( new Runnable ( ) { <nl> @ Override <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> index 49108ac . . bb311d6 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 17 , 7 + 17 , 6 @ @ <nl> package io . realm ; <nl> <nl> <nl> - import java . lang . ref . WeakReference ; <nl> import java . util . Collections ; <nl> import java . util . Date ; <nl> import java . util . Locale ; <nl> @ @ - 1632 , 6 + 1631 , 27 @ @ public final class RealmQuery < E extends RealmModel > { <nl> * @ see io . realm . RealmObject <nl> * / <nl> public E findFirst ( ) { <nl> + long tableRowIndex = getSourceRowIndexForFirstObject ( ) ; <nl> + if ( tableRowIndex > = 0 ) { <nl> + E realmObject = realm . get ( clazz , className , tableRowIndex ) ; <nl> + return realmObject ; <nl> + } else { <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Similar to { @ link # findFirst ( ) } but runs asynchronously on a worker thread <nl> + * This method is only available from a Looper thread . <nl> + * <nl> + * @ return immediately an empty { @ link RealmObject } . Trying to access any field on the returned object <nl> + * before it is loaded will throw an { @ code IllegalStateException } . Use { @ link RealmObject # isLoaded ( ) } to check if <nl> + * the object is fully loaded or register a listener { @ link io . realm . RealmObject # addChangeListener } <nl> + * to be notified when the query completes . If no RealmObject was found after the query completed , the returned <nl> + * RealmObject will have { @ link RealmObject # isLoaded ( ) } set to { @ code true } and { @ link RealmObject # isValid ( ) } set to <nl> + * { @ code false } . <nl> + * / <nl> + public E findFirstAsync ( ) { <nl> Row row ; <nl> if ( realm . isInTransaction ( ) ) { <nl> / / It is not possible to create async query inside a transaction . So immediately query the first object . <nl> @ @ - 1664 , 13 + 1684 , 6 @ @ public final class RealmQuery < E extends RealmModel > { <nl> return result ; <nl> } <nl> <nl> - / * * <nl> - * @ deprecated use { @ link # findFirst ( ) } instead . <nl> - * / <nl> - public E findFirstAsync ( ) { <nl> - return findFirst ( ) ; <nl> - } <nl> - <nl> private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { <nl> if ( fieldNames = = null ) { <nl> throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; <nl> @ @ - 1692 , 4 + 1705 , 8 @ @ public final class RealmQuery < E extends RealmModel > { <nl> return new RealmResults < E > ( realm , collection , clazz ) ; <nl> } <nl> } <nl> + <nl> + private long getSourceRowIndexForFirstObject ( ) { <nl> + return this . query . find ( ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> index a7cd9ec . . 92cf096 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 268 , 6 + 268 , 70 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> } <nl> } <nl> <nl> + public void testResusingQuery ( ) throws Throwable { <nl> + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> + final Looper [ ] backgroundLooper = new Looper [ 1 ] ; <nl> + final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + executorService . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + backgroundLooper [ 0 ] = Looper . myLooper ( ) ; <nl> + <nl> + Realm realm = null ; <nl> + try { <nl> + realm = openRealmInstance ( " testResusingQuery " ) ; <nl> + populateTestRealm ( realm , 10 ) ; <nl> + <nl> + RealmQuery < AllTypes > query = realm . where ( AllTypes . class ) <nl> + . between ( " columnLong " , 0 , 4 ) ; <nl> + RealmResults < AllTypes > queryAllSync = query . findAll ( ) ; <nl> + RealmResults < AllTypes > allAsync = query . findAllAsync ( ) ; <nl> + <nl> + assertTrue ( allAsync . load ( ) ) ; <nl> + assertEquals ( allAsync , queryAllSync ) ; <nl> + <nl> + / / the RealmQuery already has an argumentHolder , can ' t reuse it <nl> + try { <nl> + RealmResults < AllTypes > allAsyncSorted = query . findAllSorted ( " columnLong " ) ; <nl> + fail ( " Should throw an exception , can not reuse RealmQuery " ) ; <nl> + } catch ( IllegalStateException ignored ) { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + <nl> + Looper . loop ( ) ; <nl> + <nl> + } catch ( Exception e ) { <nl> + e . printStackTrace ( ) ; <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + if ( signalCallbackFinished . getCount ( ) > 0 ) { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + if ( realm ! = null ) { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + / / wait until the callback of our async query proceed <nl> + TestHelper . awaitOrFail ( signalCallbackFinished ) ; <nl> + <nl> + executorService . shutdownNow ( ) ; <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + if ( backgroundLooper [ 0 ] ! = null ) { <nl> + / / failing to quit the looper will not execute the finally block responsible <nl> + / / of closing the Realm <nl> + backgroundLooper [ 0 ] . quit ( ) ; <nl> + } <nl> + } <nl> + <nl> / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded <nl> / / using a callback to be notified when the data is loaded <nl> public void testFindAllAsyncWithNotification ( ) throws Throwable { <nl> @ @ - 1182 , 10 + 1246 , 11 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> assertEquals ( " " , realmResults . getColumnString ( ) ) ; <nl> <nl> Realm . asyncQueryExecutor . resume ( ) ; <nl> - realmResults . load ( ) ; <nl> <nl> + assertTrue ( realmResults . load ( ) ) ; <nl> assertTrue ( realmResults . isLoaded ( ) ) ; <nl> assertEquals ( " test data 4 " , realmResults . getColumnString ( ) ) ; <nl> + <nl> signalCallbackFinished . countDown ( ) ; <nl> Looper . loop ( ) ; <nl> <nl> diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java <nl> index c6d61a1 . . a865d36 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmObject . java <nl> + + + b / realm / src / main / java / io / realm / RealmObject . java <nl> @ @ - 178 , 16 + 178 , 13 @ @ public abstract class RealmObject { <nl> * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> * / <nl> public boolean load ( ) { <nl> - if ( realm = = null ) { <nl> + if ( isLoaded ( ) ) { <nl> return true ; <nl> - } <nl> - / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) <nl> - / / in this case the Realm # handler will be responsible for retrying <nl> - realm . checkIfValid ( ) ; <nl> - if ( pendingQuery ! = null & & ! pendingQuery . isDone ( ) & & ! isCompleted ) { <nl> + } else { <nl> + / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) <nl> + / / in this case the Realm # handler will be responsible of retrying <nl> return onCompleted ( ) ; <nl> } <nl> - return false ; <nl> } <nl> <nl> / * * <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index cd6c29f . . 6a9fbe0 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1432 , 6 + 1432 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * @ see io . realm . RealmResults <nl> * / <nl> public RealmResults < E > findAllAsync ( ) { <nl> + checkQueryIsNotReused ( ) ; <nl> final WeakReference < Handler > weakHandler = getWeakReferenceHandler ( ) ; <nl> <nl> / / handover the query ( to be used by a worker thread ) <nl> @ @ - 1465 , 7 + 1466 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> / / Run the query & handover the table view for the caller thread <nl> / / Note : the handoverQueryPointer contains the versionID needed by the SG in order <nl> / / to import it . <nl> - long handoverTableViewPointer = query . findAllWithHandover ( sharedGroup . getNativePointer ( ) , sharedGroup . getNativeReplicationPointer ( ) , handoverQueryPointer ) ; <nl> + long handoverTableViewPointer = query . findAllWithHandover ( sharedGroup . getNativePointer ( ) , sharedGroup . getNativeReplicationPointer ( ) , handoverQueryPointer ) ; <nl> <nl> QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmResultsResponse ( ) ; <nl> result . updatedTableViews . put ( weakRealmResults , handoverTableViewPointer ) ; <nl> @ @ - 1532 , 6 + 1533 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * @ throws java . lang . IllegalArgumentException if field name does not exist . <nl> * / <nl> public RealmResults < E > findAllSortedAsync ( String fieldName , boolean sortAscending ) { <nl> + checkQueryIsNotReused ( ) ; <nl> final TableView . Order order = sortAscending ? TableView . Order . ascending : TableView . Order . descending ; <nl> final Long columnIndex = columns . get ( fieldName ) ; <nl> if ( columnIndex = = null | | columnIndex < 0 ) { <nl> @ @ - 1678 , 6 + 1680 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * @ see io . realm . RealmResults <nl> * / <nl> public RealmResults < E > findAllSortedAsync ( String fieldNames [ ] , final boolean [ ] sortAscending ) { <nl> + checkQueryIsNotReused ( ) ; <nl> checkSortParameters ( fieldNames , sortAscending ) ; <nl> <nl> if ( fieldNames . length = = 1 & & sortAscending . length = = 1 ) { <nl> @ @ - 1776 , 7 + 1779 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * / <nl> public RealmResults < E > findAllSorted ( String fieldName1 , boolean sortAscending1 , <nl> String fieldName2 , boolean sortAscending2 ) { <nl> - return findAllSorted ( new String [ ] { fieldName1 , fieldName2 } , new boolean [ ] { sortAscending1 , sortAscending2 } ) ; <nl> + return findAllSorted ( new String [ ] { fieldName1 , fieldName2 } , new boolean [ ] { sortAscending1 , sortAscending2 } ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 1855 , 6 + 1858 , 7 @ @ public class RealmQuery < E extends RealmObject > { <nl> * { @ link io . realm . RealmObject # addChangeListener } to be notified when the query completes . <nl> * / <nl> public E findFirstAsync ( ) { <nl> + checkQueryIsNotReused ( ) ; <nl> final WeakReference < Handler > weakHandler = getWeakReferenceHandler ( ) ; <nl> <nl> / / handover the query ( to be used by a worker thread ) <nl> @ @ - 1938 , 6 + 1942 , 16 @ @ public class RealmQuery < E extends RealmObject > { <nl> return new WeakReference < Handler > ( realm . handler ) ; / / use caller Realm ' s Looper <nl> } <nl> <nl> + / / We need to prevent the user from using the query again ( mostly for async ) <nl> + / / Ex : if the first query fail with findFirstAsync , if the user reuse the same RealmQuery <nl> + / / with findAllSorted , argumentsHolder of the first query will be overridden , <nl> + / / which cause any retry to use the findAllSorted argumentsHolder . <nl> + private void checkQueryIsNotReused ( ) { <nl> + if ( argumentsHolder ! = null ) { <nl> + throw new IllegalStateException ( " This RealmQuery is already used by a find * query , please create a new query " ) ; <nl> + } <nl> + } <nl> + <nl> public ArgumentsHolder getArgument ( ) { <nl> return argumentsHolder ; <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java <nl> index e667bf1 . . fbc37ac 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmResults . java <nl> + + + b / realm / src / main / java / io / realm / RealmResults . java <nl> @ @ - 721 , 16 + 721 , 13 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { <nl> * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> * / <nl> public boolean load ( ) { <nl> - if ( realm = = null ) { <nl> + if ( isLoaded ( ) ) { <nl> return true ; <nl> - } <nl> + } else { <nl> / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) <nl> / / in this case the Realm # handler will be responsible of retrying <nl> - realm . checkIfValid ( ) ; <nl> - if ( pendingQuery ! = null & & ! pendingQuery . isDone ( ) ) { <nl> return onCompleted ( ) ; <nl> } <nl> - return false ; <nl> } <nl> <nl> / * *

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java 
 index d490d8e . . dae1912 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmObjectTests . java 
 @ @ - 614 , 8 + 614 , 6 @ @ public class DynamicRealmObjectTests { 
 @ Test 
 public void setObject _ objectBelongToDiffThreadRealmThrows ( ) { 
 final CountDownLatch finishedLatch = new CountDownLatch ( 1 ) ; 
 - / / To run the query of the PendingRow first . 
 - assertTrue ( dObjDynamic . isValid ( ) ) ; 
 
 new Thread ( new Runnable ( ) { 
 @ Override 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 index 49108ac . . bb311d6 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 @ @ - 17 , 7 + 17 , 6 @ @ 
 package io . realm ; 
 
 
 - import java . lang . ref . WeakReference ; 
 import java . util . Collections ; 
 import java . util . Date ; 
 import java . util . Locale ; 
 @ @ - 1632 , 6 + 1631 , 27 @ @ public final class RealmQuery < E extends RealmModel > { 
 * @ see io . realm . RealmObject 
 * / 
 public E findFirst ( ) { 
 + long tableRowIndex = getSourceRowIndexForFirstObject ( ) ; 
 + if ( tableRowIndex > = 0 ) { 
 + E realmObject = realm . get ( clazz , className , tableRowIndex ) ; 
 + return realmObject ; 
 + } else { 
 + return null ; 
 + } 
 + } 
 + 
 + / * * 
 + * Similar to { @ link # findFirst ( ) } but runs asynchronously on a worker thread 
 + * This method is only available from a Looper thread . 
 + * 
 + * @ return immediately an empty { @ link RealmObject } . Trying to access any field on the returned object 
 + * before it is loaded will throw an { @ code IllegalStateException } . Use { @ link RealmObject # isLoaded ( ) } to check if 
 + * the object is fully loaded or register a listener { @ link io . realm . RealmObject # addChangeListener } 
 + * to be notified when the query completes . If no RealmObject was found after the query completed , the returned 
 + * RealmObject will have { @ link RealmObject # isLoaded ( ) } set to { @ code true } and { @ link RealmObject # isValid ( ) } set to 
 + * { @ code false } . 
 + * / 
 + public E findFirstAsync ( ) { 
 Row row ; 
 if ( realm . isInTransaction ( ) ) { 
 / / It is not possible to create async query inside a transaction . So immediately query the first object . 
 @ @ - 1664 , 13 + 1684 , 6 @ @ public final class RealmQuery < E extends RealmModel > { 
 return result ; 
 } 
 
 - / * * 
 - * @ deprecated use { @ link # findFirst ( ) } instead . 
 - * / 
 - public E findFirstAsync ( ) { 
 - return findFirst ( ) ; 
 - } 
 - 
 private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { 
 if ( fieldNames = = null ) { 
 throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; 
 @ @ - 1692 , 4 + 1705 , 8 @ @ public final class RealmQuery < E extends RealmModel > { 
 return new RealmResults < E > ( realm , collection , clazz ) ; 
 } 
 } 
 + 
 + private long getSourceRowIndexForFirstObject ( ) { 
 + return this . query . find ( ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 index a7cd9ec . . 92cf096 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 268 , 6 + 268 , 70 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 } 
 } 
 
 + public void testResusingQuery ( ) throws Throwable { 
 + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 + final Looper [ ] backgroundLooper = new Looper [ 1 ] ; 
 + final ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + executorService . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + backgroundLooper [ 0 ] = Looper . myLooper ( ) ; 
 + 
 + Realm realm = null ; 
 + try { 
 + realm = openRealmInstance ( " testResusingQuery " ) ; 
 + populateTestRealm ( realm , 10 ) ; 
 + 
 + RealmQuery < AllTypes > query = realm . where ( AllTypes . class ) 
 + . between ( " columnLong " , 0 , 4 ) ; 
 + RealmResults < AllTypes > queryAllSync = query . findAll ( ) ; 
 + RealmResults < AllTypes > allAsync = query . findAllAsync ( ) ; 
 + 
 + assertTrue ( allAsync . load ( ) ) ; 
 + assertEquals ( allAsync , queryAllSync ) ; 
 + 
 + / / the RealmQuery already has an argumentHolder , can ' t reuse it 
 + try { 
 + RealmResults < AllTypes > allAsyncSorted = query . findAllSorted ( " columnLong " ) ; 
 + fail ( " Should throw an exception , can not reuse RealmQuery " ) ; 
 + } catch ( IllegalStateException ignored ) { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + 
 + Looper . loop ( ) ; 
 + 
 + } catch ( Exception e ) { 
 + e . printStackTrace ( ) ; 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + if ( signalCallbackFinished . getCount ( ) > 0 ) { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + if ( realm ! = null ) { 
 + realm . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + / / wait until the callback of our async query proceed 
 + TestHelper . awaitOrFail ( signalCallbackFinished ) ; 
 + 
 + executorService . shutdownNow ( ) ; 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + if ( backgroundLooper [ 0 ] ! = null ) { 
 + / / failing to quit the looper will not execute the finally block responsible 
 + / / of closing the Realm 
 + backgroundLooper [ 0 ] . quit ( ) ; 
 + } 
 + } 
 + 
 / / finding elements [ 0 - 4 ] asynchronously then wait for the promise to be loaded 
 / / using a callback to be notified when the data is loaded 
 public void testFindAllAsyncWithNotification ( ) throws Throwable { 
 @ @ - 1182 , 10 + 1246 , 11 @ @ public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 assertEquals ( " " , realmResults . getColumnString ( ) ) ; 
 
 Realm . asyncQueryExecutor . resume ( ) ; 
 - realmResults . load ( ) ; 
 
 + assertTrue ( realmResults . load ( ) ) ; 
 assertTrue ( realmResults . isLoaded ( ) ) ; 
 assertEquals ( " test data 4 " , realmResults . getColumnString ( ) ) ; 
 + 
 signalCallbackFinished . countDown ( ) ; 
 Looper . loop ( ) ; 
 
 diff - - git a / realm / src / main / java / io / realm / RealmObject . java b / realm / src / main / java / io / realm / RealmObject . java 
 index c6d61a1 . . a865d36 100644 
 - - - a / realm / src / main / java / io / realm / RealmObject . java 
 + + + b / realm / src / main / java / io / realm / RealmObject . java 
 @ @ - 178 , 16 + 178 , 13 @ @ public abstract class RealmObject { 
 * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 * / 
 public boolean load ( ) { 
 - if ( realm = = null ) { 
 + if ( isLoaded ( ) ) { 
 return true ; 
 - } 
 - / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) 
 - / / in this case the Realm # handler will be responsible for retrying 
 - realm . checkIfValid ( ) ; 
 - if ( pendingQuery ! = null & & ! pendingQuery . isDone ( ) & & ! isCompleted ) { 
 + } else { 
 + / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) 
 + / / in this case the Realm # handler will be responsible of retrying 
 return onCompleted ( ) ; 
 } 
 - return false ; 
 } 
 
 / * * 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index cd6c29f . . 6a9fbe0 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1432 , 6 + 1432 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * @ see io . realm . RealmResults 
 * / 
 public RealmResults < E > findAllAsync ( ) { 
 + checkQueryIsNotReused ( ) ; 
 final WeakReference < Handler > weakHandler = getWeakReferenceHandler ( ) ; 
 
 / / handover the query ( to be used by a worker thread ) 
 @ @ - 1465 , 7 + 1466 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 / / Run the query & handover the table view for the caller thread 
 / / Note : the handoverQueryPointer contains the versionID needed by the SG in order 
 / / to import it . 
 - long handoverTableViewPointer = query . findAllWithHandover ( sharedGroup . getNativePointer ( ) , sharedGroup . getNativeReplicationPointer ( ) , handoverQueryPointer ) ; 
 + long handoverTableViewPointer = query . findAllWithHandover ( sharedGroup . getNativePointer ( ) , sharedGroup . getNativeReplicationPointer ( ) , handoverQueryPointer ) ; 
 
 QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmResultsResponse ( ) ; 
 result . updatedTableViews . put ( weakRealmResults , handoverTableViewPointer ) ; 
 @ @ - 1532 , 6 + 1533 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * @ throws java . lang . IllegalArgumentException if field name does not exist . 
 * / 
 public RealmResults < E > findAllSortedAsync ( String fieldName , boolean sortAscending ) { 
 + checkQueryIsNotReused ( ) ; 
 final TableView . Order order = sortAscending ? TableView . Order . ascending : TableView . Order . descending ; 
 final Long columnIndex = columns . get ( fieldName ) ; 
 if ( columnIndex = = null | | columnIndex < 0 ) { 
 @ @ - 1678 , 6 + 1680 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * @ see io . realm . RealmResults 
 * / 
 public RealmResults < E > findAllSortedAsync ( String fieldNames [ ] , final boolean [ ] sortAscending ) { 
 + checkQueryIsNotReused ( ) ; 
 checkSortParameters ( fieldNames , sortAscending ) ; 
 
 if ( fieldNames . length = = 1 & & sortAscending . length = = 1 ) { 
 @ @ - 1776 , 7 + 1779 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * / 
 public RealmResults < E > findAllSorted ( String fieldName1 , boolean sortAscending1 , 
 String fieldName2 , boolean sortAscending2 ) { 
 - return findAllSorted ( new String [ ] { fieldName1 , fieldName2 } , new boolean [ ] { sortAscending1 , sortAscending2 } ) ; 
 + return findAllSorted ( new String [ ] { fieldName1 , fieldName2 } , new boolean [ ] { sortAscending1 , sortAscending2 } ) ; 
 } 
 
 / * * 
 @ @ - 1855 , 6 + 1858 , 7 @ @ public class RealmQuery < E extends RealmObject > { 
 * { @ link io . realm . RealmObject # addChangeListener } to be notified when the query completes . 
 * / 
 public E findFirstAsync ( ) { 
 + checkQueryIsNotReused ( ) ; 
 final WeakReference < Handler > weakHandler = getWeakReferenceHandler ( ) ; 
 
 / / handover the query ( to be used by a worker thread ) 
 @ @ - 1938 , 6 + 1942 , 16 @ @ public class RealmQuery < E extends RealmObject > { 
 return new WeakReference < Handler > ( realm . handler ) ; / / use caller Realm ' s Looper 
 } 
 
 + / / We need to prevent the user from using the query again ( mostly for async ) 
 + / / Ex : if the first query fail with findFirstAsync , if the user reuse the same RealmQuery 
 + / / with findAllSorted , argumentsHolder of the first query will be overridden , 
 + / / which cause any retry to use the findAllSorted argumentsHolder . 
 + private void checkQueryIsNotReused ( ) { 
 + if ( argumentsHolder ! = null ) { 
 + throw new IllegalStateException ( " This RealmQuery is already used by a find * query , please create a new query " ) ; 
 + } 
 + } 
 + 
 public ArgumentsHolder getArgument ( ) { 
 return argumentsHolder ; 
 } 
 diff - - git a / realm / src / main / java / io / realm / RealmResults . java b / realm / src / main / java / io / realm / RealmResults . java 
 index e667bf1 . . fbc37ac 100644 
 - - - a / realm / src / main / java / io / realm / RealmResults . java 
 + + + b / realm / src / main / java / io / realm / RealmResults . java 
 @ @ - 721 , 16 + 721 , 13 @ @ public class RealmResults < E extends RealmObject > extends AbstractList < E > { 
 * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 * / 
 public boolean load ( ) { 
 - if ( realm = = null ) { 
 + if ( isLoaded ( ) ) { 
 return true ; 
 - } 
 + } else { 
 / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) 
 / / in this case the Realm # handler will be responsible of retrying 
 - realm . checkIfValid ( ) ; 
 - if ( pendingQuery ! = null & & ! pendingQuery . isDone ( ) ) { 
 return onCompleted ( ) ; 
 } 
 - return false ; 
 } 
 
 / * *
