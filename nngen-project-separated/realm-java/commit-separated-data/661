BLEU SCORE: 0.012725361711730311

TEST MSG: Save LogCat files on CI in case of test failures
GENERATED MSG: Fixed bug where copyToRealm ( ) crashed when copying objects with primary key data .

TEST DIFF (one line): diff - - git a / Jenkinsfile b / Jenkinsfile <nl> index 46d9908 . . 2e34c95 100644 <nl> - - - a / Jenkinsfile <nl> + + + b / Jenkinsfile <nl> @ @ - 56 , 9 + 56 , 14 @ @ <nl> } <nl> <nl> stage ' Run instrumented tests ' <nl> + boolean archiveLog = true <nl> + String backgroundPid <nl> try { <nl> - sh ' cd realm & & . / gradlew connectedCheck - - stacktrace ' <nl> + backgroundPid = startLogCatCollector ( ) <nl> + sh ' cd realm & & . / gradlew connectedUnitTests - - stacktrace ' <nl> + archiveLog = false ; <nl> } finally { <nl> + stopLogCatCollector ( backgroundPid , archiveLog ) <nl> storeJunitResults ' realm / realm - library / build / outputs / androidTest - results / connected / TEST - * . xml ' <nl> } <nl> <nl> @ @ - 87 , 6 + 92 , 26 @ @ <nl> } <nl> } <nl> <nl> + def String startLogCatCollector ( ) { <nl> + sh ' ' ' adb logcat - c <nl> + adb logcat > " logcat . txt " & <nl> + echo $ ! > pid <nl> + ' ' ' <nl> + return readFile ( " pid " ) . trim ( ) <nl> + } <nl> + <nl> + def stopLogCatCollector ( String backgroundPid , boolean archiveLog ) { <nl> + sh " kill $ { backgroundPid } " <nl> + if ( archiveLog ) { <nl> + zip ( [ <nl> + ' zipFile ' : ' logcat . zip ' , <nl> + ' archive ' : true , <nl> + ' glob ' : ' logcat . txt ' <nl> + ] ) <nl> + } <nl> + sh ' rm logcat . txt ' <nl> + } <nl> + <nl> def isPullRequest ( ) { <nl> return binding . variables . containsKey ( ' GITHUB _ PR _ NUMBER ' ) <nl> } <nl> diff - - git a / integration - tests / optionalAPIExists / build . gradle b / integration - tests / optionalAPIExists / build . gradle <nl> index fbf57a4 . . 96e787f 100644 <nl> - - - a / integration - tests / optionalAPIExists / build . gradle <nl> + + + b / integration - tests / optionalAPIExists / build . gradle <nl> @ @ - 3 , 7 + 3 , 7 @ @ apply plugin : ' realm - android ' <nl> <nl> android { <nl> compileSdkVersion 23 <nl> - buildToolsVersion " 23 . 0 . 2 " <nl> + buildToolsVersion " 23 . 0 . 0 " <nl> <nl> defaultConfig { <nl> applicationId " io . realm . tests . optionalapiexists " <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / internal / JNIMixedSubtableTest . java b / realm / realm - library / src / androidTest / java / io / realm / internal / JNIMixedSubtableTest . java <nl> index fcce79d . . 2b6716e 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / internal / JNIMixedSubtableTest . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / internal / JNIMixedSubtableTest . java <nl> @ @ - 25 , 7 + 25 , 6 @ @ import io . realm . RealmFieldType ; <nl> public class JNIMixedSubtableTest extends TestCase { <nl> <nl> public void testGetSubtableFromMixedColumnTest ( ) { <nl> - Util . setDebugLevel ( 2 ) ; <nl> Table table = new Table ( ) ; <nl> <nl> table . addColumn ( RealmFieldType . INTEGER , " num " ) ;
NEAREST DIFF (one line): diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> index cd86320 . . 463cdce 100644 <nl> - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> @ @ - 506 , 7 + 506 , 11 @ @ public class RealmProxyClassGenerator { <nl> EnumSet . of ( Modifier . PUBLIC , Modifier . STATIC ) , / / Modifiers <nl> " Realm " , " realm " , className , " newObject " , " boolean " , " update " , " Map < RealmObject , RealmObject > " , " cache " ) ; / / Argument type & argument name <nl> <nl> - writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; <nl> + if ( metadata . hasPrimaryKey ( ) ) { <nl> + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class , newObject . % s ( ) ) " , className , className , metadata . getPrimaryKeyGetter ( ) ) ; <nl> + } else { <nl> + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; <nl> + } <nl> writer . emitStatement ( " cache . put ( newObject , realmObject ) " ) ; <nl> for ( VariableElement field : metadata . getFields ( ) ) { <nl> String fieldName = field . getSimpleName ( ) . toString ( ) ; <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index b87516d . . cd0e555 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 46 , 6 + 46 , 7 @ @ import io . realm . entities . NonLatinFieldNames ; <nl> import io . realm . entities . Owner ; <nl> import io . realm . entities . OwnerPrimaryKey ; <nl> import io . realm . entities . PrimaryKeyAsLong ; <nl> + import io . realm . entities . PrimaryKeyAsString ; <nl> import io . realm . entities . PrimaryKeyMix ; <nl> import io . realm . entities . StringOnly ; <nl> import io . realm . exceptions . RealmException ; <nl> @ @ - 1067 , 6 + 1068 , 26 @ @ public class RealmTest extends AndroidTestCase { <nl> assertArrayEquals ( new byte [ 0 ] , realmTypes . getColumnBinary ( ) ) ; <nl> } <nl> <nl> + / / Check that using copyToRealm will set the primary key directly instead of first setting <nl> + / / it to the default value ( which can fail ) <nl> + public void testCopyToRealmWithPrimaryKeySetValueDirectly ( ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . createObject ( OwnerPrimaryKey . class ) ; <nl> + testRealm . copyToRealm ( new OwnerPrimaryKey ( 1 , " Foo " ) ) ; <nl> + testRealm . commitTransaction ( ) ; <nl> + assertEquals ( 2 , testRealm . where ( OwnerPrimaryKey . class ) . count ( ) ) ; <nl> + } <nl> + <nl> + public void testCopyToRealmWithPrimaryAsNullThrows ( ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + try { <nl> + testRealm . copyToRealm ( new PrimaryKeyAsString ( ) ) ; <nl> + fail ( ) ; <nl> + } catch ( RealmException expected ) { <nl> + } finally { <nl> + testRealm . cancelTransaction ( ) ; <nl> + } <nl> + } <nl> <nl> public void testCopyToRealmList ( ) { <nl> Dog dog1 = new Dog ( ) ; <nl> @ @ - 1500 , 7 + 1521 , 6 @ @ public class RealmTest extends AndroidTestCase { <nl> fail ( ) ; <nl> } catch ( IllegalStateException ignored ) { <nl> } <nl> - <nl> } <nl> <nl> public void testUpdateObjectWithLinks ( ) throws Exception { <nl> diff - - git a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> index 3bba1b0 . . ce53189 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> + + + b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java <nl> @ @ - 26 , 6 + 26 , 13 @ @ public class PrimaryKeyAsString extends RealmObject { <nl> <nl> private long id ; <nl> <nl> + public PrimaryKeyAsString ( ) { <nl> + } <nl> + <nl> + public PrimaryKeyAsString ( String name ) { <nl> + this . name = name ; <nl> + } <nl> + <nl> public String getName ( ) { <nl> return name ; <nl> } <nl> diff - - git a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> index cbb78bf . . 3106ea9 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> + + + b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java <nl> @ @ - 36 , 7 + 36 , 24 @ @ public class JNITransactions extends AndroidTestCase { <nl> } <nl> } <nl> <nl> - <nl> + private Table getTableWithStringPrimaryKey ( ) { <nl> + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; <nl> + WriteTransaction trans = db . beginWrite ( ) ; <nl> + Table t = trans . getTable ( " TestTable " ) ; <nl> + t . addColumn ( ColumnType . STRING , " colName " ) ; <nl> + t . setPrimaryKey ( " colName " ) ; <nl> + return t ; <nl> + } <nl> + <nl> + private Table getTableWithIntegerPrimaryKey ( ) { <nl> + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; <nl> + WriteTransaction trans = db . beginWrite ( ) ; <nl> + Table t = trans . getTable ( " TestTable " ) ; <nl> + t . addColumn ( ColumnType . INTEGER , " colName " ) ; <nl> + t . setPrimaryKey ( " colName " ) ; <nl> + return t ; <nl> + } <nl> + <nl> private void createDBFileName ( ) { <nl> testFile = new File ( <nl> this . getContext ( ) . getFilesDir ( ) , <nl> @ @ - 319 , 24 + 336 , 44 @ @ public class JNITransactions extends AndroidTestCase { <nl> fail ( " Primary key not enforced . " ) ; <nl> } <nl> <nl> + public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( 42 ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> + } <nl> + } <nl> <nl> - <nl> - / * ARM Only works for Java 1 . 7 - NOT available in Android . <nl> - <nl> - @ Test ( enabled = true ) <nl> - public void mustReadARM ( ) { <nl> - writeOneTransaction ( 1 ) ; <nl> - <nl> - / / Read from table <nl> - / / System . out . println ( " mustReadARM . " ) ; <nl> - try ( ReadTransaction t = new ReadTransaction ( db ) ) { <nl> - EmployeeTable employees = new EmployeeTable ( t ) ; <nl> - assertEquals ( true , employees . isValid ( ) ) ; <nl> - assertEquals ( 1 , employees . size ( ) ) ; <nl> + public void testAddEmptyRowWithPrimaryKeyNullStringThrows ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( null ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> } <nl> - catch ( Throwable e ) { <nl> + } <nl> <nl> + public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows ( ) { <nl> + Table t = getTableWithIntegerPrimaryKey ( ) ; <nl> + try { <nl> + t . addEmptyRowWithPrimaryKey ( " Foo " ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException expected ) { <nl> } <nl> } <nl> - * / <nl> + <nl> + public void testAddEmptyRowWithPrimaryKeyString ( ) { <nl> + Table t = getTableWithStringPrimaryKey ( ) ; <nl> + long rowIndex = t . addEmptyRowWithPrimaryKey ( " Foo " ) ; <nl> + assertEquals ( 1 , t . size ( ) ) ; <nl> + assertEquals ( " Foo " , t . getRow ( rowIndex ) . getString ( 0 ) ) ; <nl> + } <nl> + <nl> + public void testAddEmptyRowWithPrimaryKeyLong ( ) { <nl> + Table t = getTableWithIntegerPrimaryKey ( ) ; <nl> + long rowIndex = t . addEmptyRowWithPrimaryKey ( 42 ) ; <nl> + assertEquals ( 1 , t . size ( ) ) ; <nl> + assertEquals ( 42 , t . getRow ( rowIndex ) . getLong ( 0 ) ) ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index df3156b . . e6ad153 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 1089 , 6 + 1089 , 47 @ @ public final class Realm implements Closeable { <nl> return get ( clazz , rowIndex ) ; <nl> } <nl> <nl> + / * * <nl> + * Creates a new object inside the Realm with the Primary key value initially set . <nl> + * If the value violates the primary key constraint , no object will be added and and <nl> + * { @ link RealmException will be thrown } . <nl> + * <nl> + * @ param clazz The Class of the object to create <nl> + * @ param primaryKeyValue Value for the primary key field . <nl> + * @ return The new object <nl> + * @ throws { @ link RealmException } if object could not be created . <nl> + * / <nl> + < E extends RealmObject > E createObject ( Class < E > clazz , Object primaryKeyValue ) { <nl> + Table table ; <nl> + table = tables . get ( clazz ) ; <nl> + if ( table = = null ) { <nl> + Class < ? > generatedClass = getProxyClass ( clazz ) ; <nl> + <nl> + Method method = initTableMethods . get ( generatedClass ) ; <nl> + if ( method = = null ) { <nl> + try { <nl> + method = generatedClass . getMethod ( " initTable " , new Class [ ] { ImplicitTransaction . class } ) ; <nl> + } catch ( NoSuchMethodException e ) { <nl> + throw new RealmException ( " Could not find the initTable ( ) method in generated proxy class : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + initTableMethods . put ( generatedClass , method ) ; <nl> + } <nl> + <nl> + try { <nl> + table = ( Table ) method . invoke ( null , transaction ) ; <nl> + tables . put ( clazz , table ) ; <nl> + } catch ( IllegalAccessException e ) { <nl> + throw new RealmException ( " Could not launch the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } catch ( InvocationTargetException e ) { <nl> + e . printStackTrace ( ) ; <nl> + throw new RealmException ( " An exception occurred while running the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + } <nl> + <nl> + long rowIndex = table . addEmptyRowWithPrimaryKey ( primaryKeyValue ) ; <nl> + return get ( clazz , rowIndex ) ; <nl> + } <nl> + <nl> private Class < ? > getProxyClass ( Class < ? > clazz ) { <nl> <nl> String simpleClassName = getClassSimpleName ( clazz ) ; <nl> diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java <nl> index 42d28b0 . . 83be1fd 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / Table . java <nl> + + + b / realm / src / main / java / io / realm / internal / Table . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . internal ; <nl> import java . io . Closeable ; <nl> import java . util . Date ; <nl> <nl> + import io . realm . annotations . PrimaryKey ; <nl> import io . realm . exceptions . RealmException ; <nl> <nl> <nl> @ @ - 364 , 7 + 365 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> <nl> protected native void nativeMoveLastOver ( long nativeTablePtr , long rowIndex ) ; <nl> <nl> - / / Row Handling methods . <nl> public long addEmptyRow ( ) { <nl> checkImmutable ( ) ; <nl> if ( hasPrimaryKey ( ) ) { <nl> @ @ - 390 , 6 + 390 , 54 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> return nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> } <nl> <nl> + public long addEmptyRowWithPrimaryKey ( Object primaryKeyValue ) { <nl> + checkImmutable ( ) ; <nl> + if ( hasPrimaryKey ( ) ) { <nl> + long primaryKeyColumnIndex = getPrimaryKey ( ) ; <nl> + ColumnType type = getColumnType ( primaryKeyColumnIndex ) ; <nl> + long rowIndex ; <nl> + Row row ; <nl> + <nl> + / / Add with with primary key initially set <nl> + switch ( type ) { <nl> + case STRING : <nl> + if ( ! ( primaryKeyValue instanceof String ) ) { <nl> + throw new IllegalArgumentException ( " Primary key value is not a String : " + primaryKeyValue ) ; <nl> + } <nl> + if ( findFirstString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ! = NO _ MATCH ) { <nl> + throwDuplicatePrimaryKeyException ( primaryKeyValue ) ; <nl> + } <nl> + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> + row = getRow ( rowIndex ) ; <nl> + row . setString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ; <nl> + break ; <nl> + <nl> + case INTEGER : <nl> + long pkValue ; <nl> + try { <nl> + pkValue = new Long ( primaryKeyValue . toString ( ) ) ; <nl> + } catch ( RuntimeException e ) { <nl> + throw new IllegalArgumentException ( " Primary key value is not a long : " + primaryKeyValue ) ; <nl> + } <nl> + if ( findFirstLong ( primaryKeyColumnIndex , pkValue ) ! = NO _ MATCH ) { <nl> + throwDuplicatePrimaryKeyException ( pkValue ) ; <nl> + } <nl> + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; <nl> + row = getRow ( rowIndex ) ; <nl> + row . setLong ( primaryKeyColumnIndex , pkValue ) ; <nl> + break ; <nl> + <nl> + default : <nl> + throw new RealmException ( " Cannot check for duplicate rows for unsupported primary key type : " + type ) ; <nl> + } <nl> + <nl> + return rowIndex ; <nl> + <nl> + } else { <nl> + throw new IllegalStateException ( getName ( ) + " has no primary key defined " ) ; <nl> + } <nl> + } <nl> + <nl> public long addEmptyRows ( long rows ) { <nl> checkImmutable ( ) ; <nl> if ( rows < 1 ) {

TEST DIFF:
diff - - git a / Jenkinsfile b / Jenkinsfile 
 index 46d9908 . . 2e34c95 100644 
 - - - a / Jenkinsfile 
 + + + b / Jenkinsfile 
 @ @ - 56 , 9 + 56 , 14 @ @ 
 } 
 
 stage ' Run instrumented tests ' 
 + boolean archiveLog = true 
 + String backgroundPid 
 try { 
 - sh ' cd realm & & . / gradlew connectedCheck - - stacktrace ' 
 + backgroundPid = startLogCatCollector ( ) 
 + sh ' cd realm & & . / gradlew connectedUnitTests - - stacktrace ' 
 + archiveLog = false ; 
 } finally { 
 + stopLogCatCollector ( backgroundPid , archiveLog ) 
 storeJunitResults ' realm / realm - library / build / outputs / androidTest - results / connected / TEST - * . xml ' 
 } 
 
 @ @ - 87 , 6 + 92 , 26 @ @ 
 } 
 } 
 
 + def String startLogCatCollector ( ) { 
 + sh ' ' ' adb logcat - c 
 + adb logcat > " logcat . txt " & 
 + echo $ ! > pid 
 + ' ' ' 
 + return readFile ( " pid " ) . trim ( ) 
 + } 
 + 
 + def stopLogCatCollector ( String backgroundPid , boolean archiveLog ) { 
 + sh " kill $ { backgroundPid } " 
 + if ( archiveLog ) { 
 + zip ( [ 
 + ' zipFile ' : ' logcat . zip ' , 
 + ' archive ' : true , 
 + ' glob ' : ' logcat . txt ' 
 + ] ) 
 + } 
 + sh ' rm logcat . txt ' 
 + } 
 + 
 def isPullRequest ( ) { 
 return binding . variables . containsKey ( ' GITHUB _ PR _ NUMBER ' ) 
 } 
 diff - - git a / integration - tests / optionalAPIExists / build . gradle b / integration - tests / optionalAPIExists / build . gradle 
 index fbf57a4 . . 96e787f 100644 
 - - - a / integration - tests / optionalAPIExists / build . gradle 
 + + + b / integration - tests / optionalAPIExists / build . gradle 
 @ @ - 3 , 7 + 3 , 7 @ @ apply plugin : ' realm - android ' 
 
 android { 
 compileSdkVersion 23 
 - buildToolsVersion " 23 . 0 . 2 " 
 + buildToolsVersion " 23 . 0 . 0 " 
 
 defaultConfig { 
 applicationId " io . realm . tests . optionalapiexists " 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / internal / JNIMixedSubtableTest . java b / realm / realm - library / src / androidTest / java / io / realm / internal / JNIMixedSubtableTest . java 
 index fcce79d . . 2b6716e 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / internal / JNIMixedSubtableTest . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / internal / JNIMixedSubtableTest . java 
 @ @ - 25 , 7 + 25 , 6 @ @ import io . realm . RealmFieldType ; 
 public class JNIMixedSubtableTest extends TestCase { 
 
 public void testGetSubtableFromMixedColumnTest ( ) { 
 - Util . setDebugLevel ( 2 ) ; 
 Table table = new Table ( ) ; 
 
 table . addColumn ( RealmFieldType . INTEGER , " num " ) ;

NEAREST DIFF:
diff - - git a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 index cd86320 . . 463cdce 100644 
 - - - a / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 + + + b / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 @ @ - 506 , 7 + 506 , 11 @ @ public class RealmProxyClassGenerator { 
 EnumSet . of ( Modifier . PUBLIC , Modifier . STATIC ) , / / Modifiers 
 " Realm " , " realm " , className , " newObject " , " boolean " , " update " , " Map < RealmObject , RealmObject > " , " cache " ) ; / / Argument type & argument name 
 
 - writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; 
 + if ( metadata . hasPrimaryKey ( ) ) { 
 + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class , newObject . % s ( ) ) " , className , className , metadata . getPrimaryKeyGetter ( ) ) ; 
 + } else { 
 + writer . emitStatement ( " % s realmObject = realm . createObject ( % s . class ) " , className , className ) ; 
 + } 
 writer . emitStatement ( " cache . put ( newObject , realmObject ) " ) ; 
 for ( VariableElement field : metadata . getFields ( ) ) { 
 String fieldName = field . getSimpleName ( ) . toString ( ) ; 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index b87516d . . cd0e555 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 46 , 6 + 46 , 7 @ @ import io . realm . entities . NonLatinFieldNames ; 
 import io . realm . entities . Owner ; 
 import io . realm . entities . OwnerPrimaryKey ; 
 import io . realm . entities . PrimaryKeyAsLong ; 
 + import io . realm . entities . PrimaryKeyAsString ; 
 import io . realm . entities . PrimaryKeyMix ; 
 import io . realm . entities . StringOnly ; 
 import io . realm . exceptions . RealmException ; 
 @ @ - 1067 , 6 + 1068 , 26 @ @ public class RealmTest extends AndroidTestCase { 
 assertArrayEquals ( new byte [ 0 ] , realmTypes . getColumnBinary ( ) ) ; 
 } 
 
 + / / Check that using copyToRealm will set the primary key directly instead of first setting 
 + / / it to the default value ( which can fail ) 
 + public void testCopyToRealmWithPrimaryKeySetValueDirectly ( ) { 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . createObject ( OwnerPrimaryKey . class ) ; 
 + testRealm . copyToRealm ( new OwnerPrimaryKey ( 1 , " Foo " ) ) ; 
 + testRealm . commitTransaction ( ) ; 
 + assertEquals ( 2 , testRealm . where ( OwnerPrimaryKey . class ) . count ( ) ) ; 
 + } 
 + 
 + public void testCopyToRealmWithPrimaryAsNullThrows ( ) { 
 + testRealm . beginTransaction ( ) ; 
 + try { 
 + testRealm . copyToRealm ( new PrimaryKeyAsString ( ) ) ; 
 + fail ( ) ; 
 + } catch ( RealmException expected ) { 
 + } finally { 
 + testRealm . cancelTransaction ( ) ; 
 + } 
 + } 
 
 public void testCopyToRealmList ( ) { 
 Dog dog1 = new Dog ( ) ; 
 @ @ - 1500 , 7 + 1521 , 6 @ @ public class RealmTest extends AndroidTestCase { 
 fail ( ) ; 
 } catch ( IllegalStateException ignored ) { 
 } 
 - 
 } 
 
 public void testUpdateObjectWithLinks ( ) throws Exception { 
 diff - - git a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 index 3bba1b0 . . ce53189 100644 
 - - - a / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 + + + b / realm / src / androidTest / java / io / realm / entities / PrimaryKeyAsString . java 
 @ @ - 26 , 6 + 26 , 13 @ @ public class PrimaryKeyAsString extends RealmObject { 
 
 private long id ; 
 
 + public PrimaryKeyAsString ( ) { 
 + } 
 + 
 + public PrimaryKeyAsString ( String name ) { 
 + this . name = name ; 
 + } 
 + 
 public String getName ( ) { 
 return name ; 
 } 
 diff - - git a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 index cbb78bf . . 3106ea9 100644 
 - - - a / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 + + + b / realm / src / androidTest / java / io / realm / internal / JNITransactions . java 
 @ @ - 36 , 7 + 36 , 24 @ @ public class JNITransactions extends AndroidTestCase { 
 } 
 } 
 
 - 
 + private Table getTableWithStringPrimaryKey ( ) { 
 + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; 
 + WriteTransaction trans = db . beginWrite ( ) ; 
 + Table t = trans . getTable ( " TestTable " ) ; 
 + t . addColumn ( ColumnType . STRING , " colName " ) ; 
 + t . setPrimaryKey ( " colName " ) ; 
 + return t ; 
 + } 
 + 
 + private Table getTableWithIntegerPrimaryKey ( ) { 
 + SharedGroup db = new SharedGroup ( testFile , SharedGroup . Durability . FULL , null ) ; 
 + WriteTransaction trans = db . beginWrite ( ) ; 
 + Table t = trans . getTable ( " TestTable " ) ; 
 + t . addColumn ( ColumnType . INTEGER , " colName " ) ; 
 + t . setPrimaryKey ( " colName " ) ; 
 + return t ; 
 + } 
 + 
 private void createDBFileName ( ) { 
 testFile = new File ( 
 this . getContext ( ) . getFilesDir ( ) , 
 @ @ - 319 , 24 + 336 , 44 @ @ public class JNITransactions extends AndroidTestCase { 
 fail ( " Primary key not enforced . " ) ; 
 } 
 
 + public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( 42 ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 + } 
 + } 
 
 - 
 - / * ARM Only works for Java 1 . 7 - NOT available in Android . 
 - 
 - @ Test ( enabled = true ) 
 - public void mustReadARM ( ) { 
 - writeOneTransaction ( 1 ) ; 
 - 
 - / / Read from table 
 - / / System . out . println ( " mustReadARM . " ) ; 
 - try ( ReadTransaction t = new ReadTransaction ( db ) ) { 
 - EmployeeTable employees = new EmployeeTable ( t ) ; 
 - assertEquals ( true , employees . isValid ( ) ) ; 
 - assertEquals ( 1 , employees . size ( ) ) ; 
 + public void testAddEmptyRowWithPrimaryKeyNullStringThrows ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( null ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 } 
 - catch ( Throwable e ) { 
 + } 
 
 + public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows ( ) { 
 + Table t = getTableWithIntegerPrimaryKey ( ) ; 
 + try { 
 + t . addEmptyRowWithPrimaryKey ( " Foo " ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException expected ) { 
 } 
 } 
 - * / 
 + 
 + public void testAddEmptyRowWithPrimaryKeyString ( ) { 
 + Table t = getTableWithStringPrimaryKey ( ) ; 
 + long rowIndex = t . addEmptyRowWithPrimaryKey ( " Foo " ) ; 
 + assertEquals ( 1 , t . size ( ) ) ; 
 + assertEquals ( " Foo " , t . getRow ( rowIndex ) . getString ( 0 ) ) ; 
 + } 
 + 
 + public void testAddEmptyRowWithPrimaryKeyLong ( ) { 
 + Table t = getTableWithIntegerPrimaryKey ( ) ; 
 + long rowIndex = t . addEmptyRowWithPrimaryKey ( 42 ) ; 
 + assertEquals ( 1 , t . size ( ) ) ; 
 + assertEquals ( 42 , t . getRow ( rowIndex ) . getLong ( 0 ) ) ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index df3156b . . e6ad153 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 1089 , 6 + 1089 , 47 @ @ public final class Realm implements Closeable { 
 return get ( clazz , rowIndex ) ; 
 } 
 
 + / * * 
 + * Creates a new object inside the Realm with the Primary key value initially set . 
 + * If the value violates the primary key constraint , no object will be added and and 
 + * { @ link RealmException will be thrown } . 
 + * 
 + * @ param clazz The Class of the object to create 
 + * @ param primaryKeyValue Value for the primary key field . 
 + * @ return The new object 
 + * @ throws { @ link RealmException } if object could not be created . 
 + * / 
 + < E extends RealmObject > E createObject ( Class < E > clazz , Object primaryKeyValue ) { 
 + Table table ; 
 + table = tables . get ( clazz ) ; 
 + if ( table = = null ) { 
 + Class < ? > generatedClass = getProxyClass ( clazz ) ; 
 + 
 + Method method = initTableMethods . get ( generatedClass ) ; 
 + if ( method = = null ) { 
 + try { 
 + method = generatedClass . getMethod ( " initTable " , new Class [ ] { ImplicitTransaction . class } ) ; 
 + } catch ( NoSuchMethodException e ) { 
 + throw new RealmException ( " Could not find the initTable ( ) method in generated proxy class : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } 
 + initTableMethods . put ( generatedClass , method ) ; 
 + } 
 + 
 + try { 
 + table = ( Table ) method . invoke ( null , transaction ) ; 
 + tables . put ( clazz , table ) ; 
 + } catch ( IllegalAccessException e ) { 
 + throw new RealmException ( " Could not launch the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } catch ( InvocationTargetException e ) { 
 + e . printStackTrace ( ) ; 
 + throw new RealmException ( " An exception occurred while running the initTable method : " + APT _ NOT _ EXECUTED _ MESSAGE ) ; 
 + } 
 + } 
 + 
 + long rowIndex = table . addEmptyRowWithPrimaryKey ( primaryKeyValue ) ; 
 + return get ( clazz , rowIndex ) ; 
 + } 
 + 
 private Class < ? > getProxyClass ( Class < ? > clazz ) { 
 
 String simpleClassName = getClassSimpleName ( clazz ) ; 
 diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java 
 index 42d28b0 . . 83be1fd 100644 
 - - - a / realm / src / main / java / io / realm / internal / Table . java 
 + + + b / realm / src / main / java / io / realm / internal / Table . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package io . realm . internal ; 
 import java . io . Closeable ; 
 import java . util . Date ; 
 
 + import io . realm . annotations . PrimaryKey ; 
 import io . realm . exceptions . RealmException ; 
 
 
 @ @ - 364 , 7 + 365 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 
 protected native void nativeMoveLastOver ( long nativeTablePtr , long rowIndex ) ; 
 
 - / / Row Handling methods . 
 public long addEmptyRow ( ) { 
 checkImmutable ( ) ; 
 if ( hasPrimaryKey ( ) ) { 
 @ @ - 390 , 6 + 390 , 54 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 return nativeAddEmptyRow ( nativePtr , 1 ) ; 
 } 
 
 + public long addEmptyRowWithPrimaryKey ( Object primaryKeyValue ) { 
 + checkImmutable ( ) ; 
 + if ( hasPrimaryKey ( ) ) { 
 + long primaryKeyColumnIndex = getPrimaryKey ( ) ; 
 + ColumnType type = getColumnType ( primaryKeyColumnIndex ) ; 
 + long rowIndex ; 
 + Row row ; 
 + 
 + / / Add with with primary key initially set 
 + switch ( type ) { 
 + case STRING : 
 + if ( ! ( primaryKeyValue instanceof String ) ) { 
 + throw new IllegalArgumentException ( " Primary key value is not a String : " + primaryKeyValue ) ; 
 + } 
 + if ( findFirstString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ! = NO _ MATCH ) { 
 + throwDuplicatePrimaryKeyException ( primaryKeyValue ) ; 
 + } 
 + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; 
 + row = getRow ( rowIndex ) ; 
 + row . setString ( primaryKeyColumnIndex , ( String ) primaryKeyValue ) ; 
 + break ; 
 + 
 + case INTEGER : 
 + long pkValue ; 
 + try { 
 + pkValue = new Long ( primaryKeyValue . toString ( ) ) ; 
 + } catch ( RuntimeException e ) { 
 + throw new IllegalArgumentException ( " Primary key value is not a long : " + primaryKeyValue ) ; 
 + } 
 + if ( findFirstLong ( primaryKeyColumnIndex , pkValue ) ! = NO _ MATCH ) { 
 + throwDuplicatePrimaryKeyException ( pkValue ) ; 
 + } 
 + rowIndex = nativeAddEmptyRow ( nativePtr , 1 ) ; 
 + row = getRow ( rowIndex ) ; 
 + row . setLong ( primaryKeyColumnIndex , pkValue ) ; 
 + break ; 
 + 
 + default : 
 + throw new RealmException ( " Cannot check for duplicate rows for unsupported primary key type : " + type ) ; 
 + } 
 + 
 + return rowIndex ; 
 + 
 + } else { 
 + throw new IllegalStateException ( getName ( ) + " has no primary key defined " ) ; 
 + } 
 + } 
 + 
 public long addEmptyRows ( long rows ) { 
 checkImmutable ( ) ; 
 if ( rows < 1 ) {
