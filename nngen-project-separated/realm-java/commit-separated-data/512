BLEU SCORE: 7.517195964887862E-4

TEST MSG: Add CollectionTests
GENERATED MSG: Test case - check that all other column than String throws exception when setting index

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java b / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java <nl> new file mode 100644 <nl> index 0000000 . . b78434d <nl> - - - / dev / null <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java <nl> @ @ - 0 , 0 + 1 , 164 @ @ <nl> + / * <nl> + * Copyright 2016 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal ; <nl> + <nl> + <nl> + import android . support . test . runner . AndroidJUnit4 ; <nl> + <nl> + import org . junit . After ; <nl> + import org . junit . Before ; <nl> + import org . junit . Rule ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import io . realm . RealmConfiguration ; <nl> + import io . realm . RealmFieldType ; <nl> + import io . realm . rule . TestRealmConfigurationFactory ; <nl> + <nl> + import static junit . framework . Assert . assertEquals ; <nl> + import static junit . framework . Assert . assertTrue ; <nl> + <nl> + <nl> + @ RunWith ( AndroidJUnit4 . class ) <nl> + public class CollectionTests { <nl> + @ Rule <nl> + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; <nl> + <nl> + private SharedRealm sharedRealm ; <nl> + private Table table ; <nl> + <nl> + @ Before <nl> + public void setUp ( ) { <nl> + RealmConfiguration config = configFactory . createConfiguration ( ) ; <nl> + sharedRealm = SharedRealm . getInstance ( config ) ; <nl> + sharedRealm . beginTransaction ( ) ; <nl> + table = sharedRealm . getTable ( " test _ table " ) ; <nl> + populateData ( table ) ; <nl> + } <nl> + <nl> + @ After <nl> + public void tearDown ( ) { <nl> + sharedRealm . cancelTransaction ( ) ; <nl> + sharedRealm . close ( ) ; <nl> + } <nl> + <nl> + private void populateData ( Table table ) { <nl> + / / Specify the column types and names <nl> + table . addColumn ( RealmFieldType . STRING , " firstName " ) ; <nl> + table . addColumn ( RealmFieldType . STRING , " lastName " ) ; <nl> + table . addColumn ( RealmFieldType . INTEGER , " age " ) ; <nl> + <nl> + / / Add data to the table <nl> + long row = table . addEmptyRow ( ) ; <nl> + table . setString ( 0 , row , " John " , false ) ; <nl> + table . setString ( 1 , row , " Lee " , false ) ; <nl> + table . setLong ( 2 , row , 4 , false ) ; <nl> + <nl> + row = table . addEmptyRow ( ) ; <nl> + table . setString ( 0 , row , " John " , false ) ; <nl> + table . setString ( 1 , row , " Anderson " , false ) ; <nl> + table . setLong ( 2 , row , 3 , false ) ; <nl> + <nl> + row = table . addEmptyRow ( ) ; <nl> + table . setString ( 0 , row , " Erik " , false ) ; <nl> + table . setString ( 1 , row , " Lee " , false ) ; <nl> + table . setLong ( 2 , row , 1 , false ) ; <nl> + <nl> + row = table . addEmptyRow ( ) ; <nl> + table . setString ( 0 , row , " Henry " , false ) ; <nl> + table . setString ( 1 , row , " Anderson " , false ) ; <nl> + table . setLong ( 2 , row , 1 , false ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void size ( ) { <nl> + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + assertEquals ( 3 , collection . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void where ( ) { <nl> + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + Collection collection2 = new Collection ( sharedRealm , collection . where ( ) . equalTo ( new long [ ] { 0 } , " John " ) ) ; <nl> + Collection collection3 = new Collection ( sharedRealm , collection2 . where ( ) . equalTo ( new long [ ] { 1 } , " Anderson " ) ) ; <nl> + <nl> + / / A new native Results should be created . <nl> + assertTrue ( collection . getNativePtr ( ) ! = collection2 . getNativePtr ( ) ) ; <nl> + assertTrue ( collection2 . getNativePtr ( ) ! = collection3 . getNativePtr ( ) ) ; <nl> + <nl> + assertEquals ( 4 , collection . size ( ) ) ; <nl> + assertEquals ( 2 , collection2 . size ( ) ) ; <nl> + assertEquals ( 1 , collection3 . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void sort ( ) { <nl> + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + SortDescriptor sortDescriptor = new SortDescriptor ( table , new long [ ] { 2 } ) ; <nl> + try { <nl> + Collection collection2 = collection . sort ( sortDescriptor ) ; <nl> + <nl> + / / A new native Results should be created . <nl> + assertTrue ( collection . getNativePtr ( ) ! = collection2 . getNativePtr ( ) ) ; <nl> + assertEquals ( 4 , collection . size ( ) ) ; <nl> + assertEquals ( 4 , collection2 . size ( ) ) ; <nl> + <nl> + assertEquals ( collection2 . getUncheckedRow ( 0 ) . getLong ( 2 ) , 1 ) ; <nl> + assertEquals ( collection2 . getUncheckedRow ( 3 ) . getLong ( 2 ) , 4 ) ; <nl> + } finally { <nl> + sortDescriptor . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void clear ( ) { <nl> + assertEquals ( table . size ( ) , 4 ) ; <nl> + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + collection . clear ( ) ; <nl> + assertEquals ( table . size ( ) , 0 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void contains ( ) { <nl> + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + UncheckedRow row = table . getUncheckedRow ( 0 ) ; <nl> + assertTrue ( collection . contains ( row ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void indexOf ( ) { <nl> + SortDescriptor sortDescriptor = new SortDescriptor ( table , new long [ ] { 2 } ) ; <nl> + try { <nl> + Collection collection = new Collection ( sharedRealm , table . where ( ) , sortDescriptor ) ; <nl> + UncheckedRow row = table . getUncheckedRow ( 0 ) ; <nl> + assertEquals ( collection . indexOf ( row ) , 3 ) ; <nl> + } finally { <nl> + sortDescriptor . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void indexOf _ long ( ) { <nl> + SortDescriptor sortDescriptor = new SortDescriptor ( table , new long [ ] { 2 } ) ; <nl> + try { <nl> + Collection collection = new Collection ( sharedRealm , table . where ( ) , sortDescriptor ) ; <nl> + assertEquals ( collection . indexOf ( 0 ) , 3 ) ; <nl> + } finally { <nl> + sortDescriptor . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / internal / JNIQueryTest . java b / realm / realm - library / src / androidTest / java / io / realm / internal / JNIQueryTest . java <nl> index 71f5045 . . b94f545 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / internal / JNIQueryTest . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / internal / JNIQueryTest . java <nl> @ @ - 614 , 56 + 614 , 6 @ @ public class JNIQueryTest extends TestCase { <nl> try { query . equalTo ( new long [ ] { 7 } , true ) ; assert ( false ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } <nl> } <nl> <nl> - <nl> - public void testQueryOnView ( ) { <nl> - Table table = new Table ( ) ; <nl> - <nl> - / / Specify the column types and names <nl> - table . addColumn ( RealmFieldType . STRING , " firstName " ) ; <nl> - table . addColumn ( RealmFieldType . STRING , " lastName " ) ; <nl> - table . addColumn ( RealmFieldType . INTEGER , " salary " ) ; <nl> - <nl> - / / Add data to the table <nl> - table . add ( " John " , " Lee " , 10000 ) ; <nl> - table . add ( " Jane " , " Lee " , 15000 ) ; <nl> - table . add ( " John " , " Anderson " , 20000 ) ; <nl> - table . add ( " Erik " , " Lee " , 30000 ) ; <nl> - table . add ( " Henry " , " Anderson " , 10000 ) ; <nl> - <nl> - TableView view = table . where ( ) . findAll ( ) ; <nl> - <nl> - TableView view2 = view . where ( ) . equalTo ( new long [ ] { 0 } , " John " ) . findAll ( ) ; <nl> - <nl> - assertEquals ( 2 , view2 . size ( ) ) ; <nl> - <nl> - TableView view3 = view2 . where ( ) . equalTo ( new long [ ] { 1 } , " Anderson " ) . findAll ( ) ; <nl> - <nl> - assertEquals ( 1 , view3 . size ( ) ) ; <nl> - } <nl> - <nl> - <nl> - public void testQueryOnViewWithAlreadyQueriedTable ( ) { <nl> - Table table = new Table ( ) ; <nl> - <nl> - / / Specify the column types and names <nl> - table . addColumn ( RealmFieldType . STRING , " firstName " ) ; <nl> - table . addColumn ( RealmFieldType . STRING , " lastName " ) ; <nl> - table . addColumn ( RealmFieldType . INTEGER , " salary " ) ; <nl> - <nl> - / / Add data to the table <nl> - table . add ( " John " , " Lee " , 10000 ) ; <nl> - table . add ( " Jane " , " Lee " , 15000 ) ; <nl> - table . add ( " John " , " Anderson " , 20000 ) ; <nl> - table . add ( " Erik " , " Lee " , 30000 ) ; <nl> - table . add ( " Henry " , " Anderson " , 10000 ) ; <nl> - <nl> - TableView view = table . where ( ) . equalTo ( new long [ ] { 0 } , " John " ) . findAll ( ) ; <nl> - <nl> - TableView view2 = view . where ( ) . equalTo ( new long [ ] { 1 } , " Anderson " ) . findAll ( ) ; <nl> - <nl> - assertEquals ( 1 , view2 . size ( ) ) ; <nl> - } <nl> - <nl> public void testMaximumDate ( ) { <nl> <nl> Table table = new Table ( ) ;
NEAREST DIFF (one line): diff - - git a / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java b / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java <nl> deleted file mode 100644 <nl> index 508f360 . . 0000000 <nl> - - - a / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java <nl> + + + / dev / null <nl> @ @ - 1 , 78 + 0 , 0 @ @ <nl> - package com . tightdb ; <nl> - <nl> - import static org . testng . AssertJUnit . * ; <nl> - import org . testng . annotations . Test ; <nl> - <nl> - / / TODO : Check that Index can be set on multiple columns . <nl> - <nl> - @ SuppressWarnings ( " unused " ) <nl> - public class JNIDistinctTest { <nl> - Table table ; <nl> - <nl> - void init ( ) { <nl> - table = new Table ( ) ; <nl> - table . addColumn ( ColumnType . LONG , " number " ) ; <nl> - table . addColumn ( ColumnType . STRING , " name " ) ; <nl> - <nl> - long i = 0 ; <nl> - table . add ( 0 , " A " ) ; <nl> - table . add ( 1 , " B " ) ; <nl> - table . add ( 2 , " C " ) ; <nl> - table . add ( 3 , " B " ) ; <nl> - table . add ( 4 , " D " ) ; <nl> - table . add ( 5 , " D " ) ; <nl> - table . add ( 6 , " D " ) ; <nl> - assertEquals ( 7 , table . size ( ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void shouldTestDistinct ( ) { <nl> - init ( ) ; <nl> - <nl> - / / Must set index before using distinct ( ) <nl> - table . setIndex ( 1 ) ; <nl> - assertEquals ( true , table . hasIndex ( 1 ) ) ; <nl> - <nl> - TableView view = table . distinct ( 1 ) ; <nl> - assertEquals ( 4 , view . size ( ) ) ; <nl> - assertEquals ( 0 , view . getLong ( 0 , 0 ) ) ; <nl> - assertEquals ( 1 , view . getLong ( 0 , 1 ) ) ; <nl> - assertEquals ( 2 , view . getLong ( 0 , 2 ) ) ; <nl> - assertEquals ( 4 , view . getLong ( 0 , 3 ) ) ; <nl> - } <nl> - <nl> - @ Test ( expectedExceptions = UnsupportedOperationException . class ) <nl> - public void shouldTestDistinctErrorWhenNoIndex ( ) { <nl> - init ( ) ; <nl> - TableView view = table . distinct ( 1 ) ; <nl> - } <nl> - <nl> - @ Test ( expectedExceptions = ArrayIndexOutOfBoundsException . class ) <nl> - public void shouldTestDistinctErrorWhenIndexOutOfBounds ( ) { <nl> - init ( ) ; <nl> - <nl> - TableView view = table . distinct ( 3 ) ; <nl> - } <nl> - <nl> - / / TODO : Check all other column types than String throws exception <nl> - <nl> - @ Test ( expectedExceptions = IllegalArgumentException . class ) <nl> - public void shouldTestIndexOnWrongColumnType ( ) { <nl> - init ( ) ; <nl> - table . setIndex ( 0 ) ; <nl> - } <nl> - <nl> - @ Test ( ) <nl> - public void shouldCheckIndexIsOkOnColumn ( ) { <nl> - init ( ) ; <nl> - table . setIndex ( 1 ) ; <nl> - } <nl> - <nl> - @ Test ( expectedExceptions = UnsupportedOperationException . class ) <nl> - public void shouldTestDistinctErrorWhenWrongColumnType ( ) { <nl> - init ( ) ; <nl> - table . setIndex ( 1 ) ; <nl> - TableView view = table . distinct ( 0 ) ; <nl> - } <nl> - <nl> - } <nl> diff - - git a / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java b / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java <nl> new file mode 100644 <nl> index 0000000 . . 1da18ab <nl> - - - / dev / null <nl> + + + b / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java <nl> @ @ - 0 , 0 + 1 , 148 @ @ <nl> + package com . tightdb ; <nl> + <nl> + import static org . testng . AssertJUnit . * ; <nl> + <nl> + import java . util . Arrays ; <nl> + import java . util . Date ; <nl> + import java . util . Iterator ; <nl> + import java . util . List ; <nl> + <nl> + import org . testng . annotations . DataProvider ; <nl> + import org . testng . annotations . Test ; <nl> + <nl> + import com . tightdb . test . DataProviderUtil ; <nl> + import com . tightdb . test . TestHelper ; <nl> + <nl> + <nl> + @ SuppressWarnings ( " unused " ) <nl> + public class TableIndexAndDistinctTest { <nl> + Table table ; <nl> + <nl> + void init ( ) { <nl> + table = new Table ( ) ; <nl> + table . addColumn ( ColumnType . LONG , " number " ) ; <nl> + table . addColumn ( ColumnType . STRING , " name " ) ; <nl> + <nl> + long i = 0 ; <nl> + table . add ( 0 , " A " ) ; <nl> + table . add ( 1 , " B " ) ; <nl> + table . add ( 2 , " C " ) ; <nl> + table . add ( 3 , " B " ) ; <nl> + table . add ( 4 , " D " ) ; <nl> + table . add ( 5 , " D " ) ; <nl> + table . add ( 6 , " D " ) ; <nl> + assertEquals ( 7 , table . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void shouldTestDistinct ( ) { <nl> + init ( ) ; <nl> + <nl> + / / Must set index before using distinct ( ) <nl> + table . setIndex ( 1 ) ; <nl> + assertEquals ( true , table . hasIndex ( 1 ) ) ; <nl> + <nl> + TableView view = table . distinct ( 1 ) ; <nl> + assertEquals ( 4 , view . size ( ) ) ; <nl> + assertEquals ( 0 , view . getLong ( 0 , 0 ) ) ; <nl> + assertEquals ( 1 , view . getLong ( 0 , 1 ) ) ; <nl> + assertEquals ( 2 , view . getLong ( 0 , 2 ) ) ; <nl> + assertEquals ( 4 , view . getLong ( 0 , 3 ) ) ; <nl> + } <nl> + <nl> + <nl> + <nl> + / * * <nl> + * Should throw exception if trying to get distinct on columns where index has not been set <nl> + * @ param index <nl> + * / <nl> + @ Test ( expectedExceptions = UnsupportedOperationException . class , dataProvider = " columnIndex " ) <nl> + public void shouldTestDistinctErrorWhenNoIndex ( Long index ) { <nl> + <nl> + / / Get a table with all available column types <nl> + Table t = TestHelper . getTableWithAllColumnTypes ( ) ; <nl> + <nl> + TableView view = table . distinct ( 1 ) ; <nl> + } <nl> + <nl> + @ Test ( expectedExceptions = ArrayIndexOutOfBoundsException . class ) <nl> + public void shouldTestDistinctErrorWhenIndexOutOfBounds ( ) { <nl> + init ( ) ; <nl> + <nl> + TableView view = table . distinct ( 3 ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checkd that Index can be set on multiple columns , with the String <nl> + * @ param index <nl> + * / <nl> + public void shouldTestSettingIndexOnMultipleColumns ( ) { <nl> + <nl> + / / Create a table only with String type columns <nl> + Table t = new Table ( ) ; <nl> + t . addColumn ( ColumnType . STRING , " col1 " ) ; <nl> + t . addColumn ( ColumnType . STRING , " col2 " ) ; <nl> + t . addColumn ( ColumnType . STRING , " col3 " ) ; <nl> + t . addColumn ( ColumnType . STRING , " col4 " ) ; <nl> + t . addColumn ( ColumnType . STRING , " col5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + <nl> + for ( long c = 0 ; c < t . getColumnCount ( ) ; c + + ) { <nl> + t . setIndex ( c ) ; <nl> + assertEquals ( true , t . hasIndex ( c ) ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Checks that all other column types than String throws exception . <nl> + * @ param o <nl> + * / <nl> + @ Test ( expectedExceptions = IllegalArgumentException . class , dataProvider = " columnIndex " ) <nl> + public void shouldTestIndexOnWrongColumnType ( Long index ) { <nl> + <nl> + / / Get a table with all available column types <nl> + Table t = TestHelper . getTableWithAllColumnTypes ( ) ; <nl> + <nl> + / / If column type is String , then throw the excepted exception <nl> + if ( t . getColumnType ( index ) . equals ( ColumnType . STRING ) ) { <nl> + throw new IllegalArgumentException ( ) ; <nl> + } <nl> + <nl> + t . setIndex ( index ) ; <nl> + } <nl> + <nl> + @ Test ( ) <nl> + public void shouldCheckIndexIsOkOnColumn ( ) { <nl> + init ( ) ; <nl> + table . setIndex ( 1 ) ; <nl> + } <nl> + <nl> + @ Test ( expectedExceptions = UnsupportedOperationException . class ) <nl> + public void shouldTestDistinctErrorWhenWrongColumnType ( ) { <nl> + init ( ) ; <nl> + table . setIndex ( 1 ) ; <nl> + TableView view = table . distinct ( 0 ) ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Is used to run a test multiple times , <nl> + * that corresponds to the number of columns in the Table generated <nl> + * in TestHelper . getTableWithAllColumnTypes <nl> + * @ return <nl> + * / <nl> + @ DataProvider ( name = " columnIndex " ) <nl> + public Iterator < Object [ ] > mixedValuesProvider ( ) { <nl> + Long [ ] values = { <nl> + 0L , 1L , 2L , 3L , 4L , 5L , 6L , 7L , 8L <nl> + } ; <nl> + <nl> + List < ? > mixedValues = Arrays . asList ( values ) ; <nl> + return DataProviderUtil . allCombinations ( mixedValues ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java b / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java 
 new file mode 100644 
 index 0000000 . . b78434d 
 - - - / dev / null 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java 
 @ @ - 0 , 0 + 1 , 164 @ @ 
 + / * 
 + * Copyright 2016 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal ; 
 + 
 + 
 + import android . support . test . runner . AndroidJUnit4 ; 
 + 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Rule ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import io . realm . RealmConfiguration ; 
 + import io . realm . RealmFieldType ; 
 + import io . realm . rule . TestRealmConfigurationFactory ; 
 + 
 + import static junit . framework . Assert . assertEquals ; 
 + import static junit . framework . Assert . assertTrue ; 
 + 
 + 
 + @ RunWith ( AndroidJUnit4 . class ) 
 + public class CollectionTests { 
 + @ Rule 
 + public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; 
 + 
 + private SharedRealm sharedRealm ; 
 + private Table table ; 
 + 
 + @ Before 
 + public void setUp ( ) { 
 + RealmConfiguration config = configFactory . createConfiguration ( ) ; 
 + sharedRealm = SharedRealm . getInstance ( config ) ; 
 + sharedRealm . beginTransaction ( ) ; 
 + table = sharedRealm . getTable ( " test _ table " ) ; 
 + populateData ( table ) ; 
 + } 
 + 
 + @ After 
 + public void tearDown ( ) { 
 + sharedRealm . cancelTransaction ( ) ; 
 + sharedRealm . close ( ) ; 
 + } 
 + 
 + private void populateData ( Table table ) { 
 + / / Specify the column types and names 
 + table . addColumn ( RealmFieldType . STRING , " firstName " ) ; 
 + table . addColumn ( RealmFieldType . STRING , " lastName " ) ; 
 + table . addColumn ( RealmFieldType . INTEGER , " age " ) ; 
 + 
 + / / Add data to the table 
 + long row = table . addEmptyRow ( ) ; 
 + table . setString ( 0 , row , " John " , false ) ; 
 + table . setString ( 1 , row , " Lee " , false ) ; 
 + table . setLong ( 2 , row , 4 , false ) ; 
 + 
 + row = table . addEmptyRow ( ) ; 
 + table . setString ( 0 , row , " John " , false ) ; 
 + table . setString ( 1 , row , " Anderson " , false ) ; 
 + table . setLong ( 2 , row , 3 , false ) ; 
 + 
 + row = table . addEmptyRow ( ) ; 
 + table . setString ( 0 , row , " Erik " , false ) ; 
 + table . setString ( 1 , row , " Lee " , false ) ; 
 + table . setLong ( 2 , row , 1 , false ) ; 
 + 
 + row = table . addEmptyRow ( ) ; 
 + table . setString ( 0 , row , " Henry " , false ) ; 
 + table . setString ( 1 , row , " Anderson " , false ) ; 
 + table . setLong ( 2 , row , 1 , false ) ; 
 + } 
 + 
 + @ Test 
 + public void size ( ) { 
 + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + assertEquals ( 3 , collection . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void where ( ) { 
 + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + Collection collection2 = new Collection ( sharedRealm , collection . where ( ) . equalTo ( new long [ ] { 0 } , " John " ) ) ; 
 + Collection collection3 = new Collection ( sharedRealm , collection2 . where ( ) . equalTo ( new long [ ] { 1 } , " Anderson " ) ) ; 
 + 
 + / / A new native Results should be created . 
 + assertTrue ( collection . getNativePtr ( ) ! = collection2 . getNativePtr ( ) ) ; 
 + assertTrue ( collection2 . getNativePtr ( ) ! = collection3 . getNativePtr ( ) ) ; 
 + 
 + assertEquals ( 4 , collection . size ( ) ) ; 
 + assertEquals ( 2 , collection2 . size ( ) ) ; 
 + assertEquals ( 1 , collection3 . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void sort ( ) { 
 + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + SortDescriptor sortDescriptor = new SortDescriptor ( table , new long [ ] { 2 } ) ; 
 + try { 
 + Collection collection2 = collection . sort ( sortDescriptor ) ; 
 + 
 + / / A new native Results should be created . 
 + assertTrue ( collection . getNativePtr ( ) ! = collection2 . getNativePtr ( ) ) ; 
 + assertEquals ( 4 , collection . size ( ) ) ; 
 + assertEquals ( 4 , collection2 . size ( ) ) ; 
 + 
 + assertEquals ( collection2 . getUncheckedRow ( 0 ) . getLong ( 2 ) , 1 ) ; 
 + assertEquals ( collection2 . getUncheckedRow ( 3 ) . getLong ( 2 ) , 4 ) ; 
 + } finally { 
 + sortDescriptor . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void clear ( ) { 
 + assertEquals ( table . size ( ) , 4 ) ; 
 + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + collection . clear ( ) ; 
 + assertEquals ( table . size ( ) , 0 ) ; 
 + } 
 + 
 + @ Test 
 + public void contains ( ) { 
 + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + UncheckedRow row = table . getUncheckedRow ( 0 ) ; 
 + assertTrue ( collection . contains ( row ) ) ; 
 + } 
 + 
 + @ Test 
 + public void indexOf ( ) { 
 + SortDescriptor sortDescriptor = new SortDescriptor ( table , new long [ ] { 2 } ) ; 
 + try { 
 + Collection collection = new Collection ( sharedRealm , table . where ( ) , sortDescriptor ) ; 
 + UncheckedRow row = table . getUncheckedRow ( 0 ) ; 
 + assertEquals ( collection . indexOf ( row ) , 3 ) ; 
 + } finally { 
 + sortDescriptor . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void indexOf _ long ( ) { 
 + SortDescriptor sortDescriptor = new SortDescriptor ( table , new long [ ] { 2 } ) ; 
 + try { 
 + Collection collection = new Collection ( sharedRealm , table . where ( ) , sortDescriptor ) ; 
 + assertEquals ( collection . indexOf ( 0 ) , 3 ) ; 
 + } finally { 
 + sortDescriptor . close ( ) ; 
 + } 
 + } 
 + } 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / internal / JNIQueryTest . java b / realm / realm - library / src / androidTest / java / io / realm / internal / JNIQueryTest . java 
 index 71f5045 . . b94f545 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / internal / JNIQueryTest . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / internal / JNIQueryTest . java 
 @ @ - 614 , 56 + 614 , 6 @ @ public class JNIQueryTest extends TestCase { 
 try { query . equalTo ( new long [ ] { 7 } , true ) ; assert ( false ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } 
 } 
 
 - 
 - public void testQueryOnView ( ) { 
 - Table table = new Table ( ) ; 
 - 
 - / / Specify the column types and names 
 - table . addColumn ( RealmFieldType . STRING , " firstName " ) ; 
 - table . addColumn ( RealmFieldType . STRING , " lastName " ) ; 
 - table . addColumn ( RealmFieldType . INTEGER , " salary " ) ; 
 - 
 - / / Add data to the table 
 - table . add ( " John " , " Lee " , 10000 ) ; 
 - table . add ( " Jane " , " Lee " , 15000 ) ; 
 - table . add ( " John " , " Anderson " , 20000 ) ; 
 - table . add ( " Erik " , " Lee " , 30000 ) ; 
 - table . add ( " Henry " , " Anderson " , 10000 ) ; 
 - 
 - TableView view = table . where ( ) . findAll ( ) ; 
 - 
 - TableView view2 = view . where ( ) . equalTo ( new long [ ] { 0 } , " John " ) . findAll ( ) ; 
 - 
 - assertEquals ( 2 , view2 . size ( ) ) ; 
 - 
 - TableView view3 = view2 . where ( ) . equalTo ( new long [ ] { 1 } , " Anderson " ) . findAll ( ) ; 
 - 
 - assertEquals ( 1 , view3 . size ( ) ) ; 
 - } 
 - 
 - 
 - public void testQueryOnViewWithAlreadyQueriedTable ( ) { 
 - Table table = new Table ( ) ; 
 - 
 - / / Specify the column types and names 
 - table . addColumn ( RealmFieldType . STRING , " firstName " ) ; 
 - table . addColumn ( RealmFieldType . STRING , " lastName " ) ; 
 - table . addColumn ( RealmFieldType . INTEGER , " salary " ) ; 
 - 
 - / / Add data to the table 
 - table . add ( " John " , " Lee " , 10000 ) ; 
 - table . add ( " Jane " , " Lee " , 15000 ) ; 
 - table . add ( " John " , " Anderson " , 20000 ) ; 
 - table . add ( " Erik " , " Lee " , 30000 ) ; 
 - table . add ( " Henry " , " Anderson " , 10000 ) ; 
 - 
 - TableView view = table . where ( ) . equalTo ( new long [ ] { 0 } , " John " ) . findAll ( ) ; 
 - 
 - TableView view2 = view . where ( ) . equalTo ( new long [ ] { 1 } , " Anderson " ) . findAll ( ) ; 
 - 
 - assertEquals ( 1 , view2 . size ( ) ) ; 
 - } 
 - 
 public void testMaximumDate ( ) { 
 
 Table table = new Table ( ) ;

NEAREST DIFF:
diff - - git a / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java b / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java 
 deleted file mode 100644 
 index 508f360 . . 0000000 
 - - - a / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java 
 + + + / dev / null 
 @ @ - 1 , 78 + 0 , 0 @ @ 
 - package com . tightdb ; 
 - 
 - import static org . testng . AssertJUnit . * ; 
 - import org . testng . annotations . Test ; 
 - 
 - / / TODO : Check that Index can be set on multiple columns . 
 - 
 - @ SuppressWarnings ( " unused " ) 
 - public class JNIDistinctTest { 
 - Table table ; 
 - 
 - void init ( ) { 
 - table = new Table ( ) ; 
 - table . addColumn ( ColumnType . LONG , " number " ) ; 
 - table . addColumn ( ColumnType . STRING , " name " ) ; 
 - 
 - long i = 0 ; 
 - table . add ( 0 , " A " ) ; 
 - table . add ( 1 , " B " ) ; 
 - table . add ( 2 , " C " ) ; 
 - table . add ( 3 , " B " ) ; 
 - table . add ( 4 , " D " ) ; 
 - table . add ( 5 , " D " ) ; 
 - table . add ( 6 , " D " ) ; 
 - assertEquals ( 7 , table . size ( ) ) ; 
 - } 
 - 
 - @ Test 
 - public void shouldTestDistinct ( ) { 
 - init ( ) ; 
 - 
 - / / Must set index before using distinct ( ) 
 - table . setIndex ( 1 ) ; 
 - assertEquals ( true , table . hasIndex ( 1 ) ) ; 
 - 
 - TableView view = table . distinct ( 1 ) ; 
 - assertEquals ( 4 , view . size ( ) ) ; 
 - assertEquals ( 0 , view . getLong ( 0 , 0 ) ) ; 
 - assertEquals ( 1 , view . getLong ( 0 , 1 ) ) ; 
 - assertEquals ( 2 , view . getLong ( 0 , 2 ) ) ; 
 - assertEquals ( 4 , view . getLong ( 0 , 3 ) ) ; 
 - } 
 - 
 - @ Test ( expectedExceptions = UnsupportedOperationException . class ) 
 - public void shouldTestDistinctErrorWhenNoIndex ( ) { 
 - init ( ) ; 
 - TableView view = table . distinct ( 1 ) ; 
 - } 
 - 
 - @ Test ( expectedExceptions = ArrayIndexOutOfBoundsException . class ) 
 - public void shouldTestDistinctErrorWhenIndexOutOfBounds ( ) { 
 - init ( ) ; 
 - 
 - TableView view = table . distinct ( 3 ) ; 
 - } 
 - 
 - / / TODO : Check all other column types than String throws exception 
 - 
 - @ Test ( expectedExceptions = IllegalArgumentException . class ) 
 - public void shouldTestIndexOnWrongColumnType ( ) { 
 - init ( ) ; 
 - table . setIndex ( 0 ) ; 
 - } 
 - 
 - @ Test ( ) 
 - public void shouldCheckIndexIsOkOnColumn ( ) { 
 - init ( ) ; 
 - table . setIndex ( 1 ) ; 
 - } 
 - 
 - @ Test ( expectedExceptions = UnsupportedOperationException . class ) 
 - public void shouldTestDistinctErrorWhenWrongColumnType ( ) { 
 - init ( ) ; 
 - table . setIndex ( 1 ) ; 
 - TableView view = table . distinct ( 0 ) ; 
 - } 
 - 
 - } 
 diff - - git a / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java b / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java 
 new file mode 100644 
 index 0000000 . . 1da18ab 
 - - - / dev / null 
 + + + b / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java 
 @ @ - 0 , 0 + 1 , 148 @ @ 
 + package com . tightdb ; 
 + 
 + import static org . testng . AssertJUnit . * ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . Date ; 
 + import java . util . Iterator ; 
 + import java . util . List ; 
 + 
 + import org . testng . annotations . DataProvider ; 
 + import org . testng . annotations . Test ; 
 + 
 + import com . tightdb . test . DataProviderUtil ; 
 + import com . tightdb . test . TestHelper ; 
 + 
 + 
 + @ SuppressWarnings ( " unused " ) 
 + public class TableIndexAndDistinctTest { 
 + Table table ; 
 + 
 + void init ( ) { 
 + table = new Table ( ) ; 
 + table . addColumn ( ColumnType . LONG , " number " ) ; 
 + table . addColumn ( ColumnType . STRING , " name " ) ; 
 + 
 + long i = 0 ; 
 + table . add ( 0 , " A " ) ; 
 + table . add ( 1 , " B " ) ; 
 + table . add ( 2 , " C " ) ; 
 + table . add ( 3 , " B " ) ; 
 + table . add ( 4 , " D " ) ; 
 + table . add ( 5 , " D " ) ; 
 + table . add ( 6 , " D " ) ; 
 + assertEquals ( 7 , table . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void shouldTestDistinct ( ) { 
 + init ( ) ; 
 + 
 + / / Must set index before using distinct ( ) 
 + table . setIndex ( 1 ) ; 
 + assertEquals ( true , table . hasIndex ( 1 ) ) ; 
 + 
 + TableView view = table . distinct ( 1 ) ; 
 + assertEquals ( 4 , view . size ( ) ) ; 
 + assertEquals ( 0 , view . getLong ( 0 , 0 ) ) ; 
 + assertEquals ( 1 , view . getLong ( 0 , 1 ) ) ; 
 + assertEquals ( 2 , view . getLong ( 0 , 2 ) ) ; 
 + assertEquals ( 4 , view . getLong ( 0 , 3 ) ) ; 
 + } 
 + 
 + 
 + 
 + / * * 
 + * Should throw exception if trying to get distinct on columns where index has not been set 
 + * @ param index 
 + * / 
 + @ Test ( expectedExceptions = UnsupportedOperationException . class , dataProvider = " columnIndex " ) 
 + public void shouldTestDistinctErrorWhenNoIndex ( Long index ) { 
 + 
 + / / Get a table with all available column types 
 + Table t = TestHelper . getTableWithAllColumnTypes ( ) ; 
 + 
 + TableView view = table . distinct ( 1 ) ; 
 + } 
 + 
 + @ Test ( expectedExceptions = ArrayIndexOutOfBoundsException . class ) 
 + public void shouldTestDistinctErrorWhenIndexOutOfBounds ( ) { 
 + init ( ) ; 
 + 
 + TableView view = table . distinct ( 3 ) ; 
 + } 
 + 
 + / * * 
 + * Checkd that Index can be set on multiple columns , with the String 
 + * @ param index 
 + * / 
 + public void shouldTestSettingIndexOnMultipleColumns ( ) { 
 + 
 + / / Create a table only with String type columns 
 + Table t = new Table ( ) ; 
 + t . addColumn ( ColumnType . STRING , " col1 " ) ; 
 + t . addColumn ( ColumnType . STRING , " col2 " ) ; 
 + t . addColumn ( ColumnType . STRING , " col3 " ) ; 
 + t . addColumn ( ColumnType . STRING , " col4 " ) ; 
 + t . addColumn ( ColumnType . STRING , " col5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + 
 + for ( long c = 0 ; c < t . getColumnCount ( ) ; c + + ) { 
 + t . setIndex ( c ) ; 
 + assertEquals ( true , t . hasIndex ( c ) ) ; 
 + } 
 + } 
 + 
 + 
 + / * * 
 + * Checks that all other column types than String throws exception . 
 + * @ param o 
 + * / 
 + @ Test ( expectedExceptions = IllegalArgumentException . class , dataProvider = " columnIndex " ) 
 + public void shouldTestIndexOnWrongColumnType ( Long index ) { 
 + 
 + / / Get a table with all available column types 
 + Table t = TestHelper . getTableWithAllColumnTypes ( ) ; 
 + 
 + / / If column type is String , then throw the excepted exception 
 + if ( t . getColumnType ( index ) . equals ( ColumnType . STRING ) ) { 
 + throw new IllegalArgumentException ( ) ; 
 + } 
 + 
 + t . setIndex ( index ) ; 
 + } 
 + 
 + @ Test ( ) 
 + public void shouldCheckIndexIsOkOnColumn ( ) { 
 + init ( ) ; 
 + table . setIndex ( 1 ) ; 
 + } 
 + 
 + @ Test ( expectedExceptions = UnsupportedOperationException . class ) 
 + public void shouldTestDistinctErrorWhenWrongColumnType ( ) { 
 + init ( ) ; 
 + table . setIndex ( 1 ) ; 
 + TableView view = table . distinct ( 0 ) ; 
 + } 
 + 
 + 
 + / * * 
 + * Is used to run a test multiple times , 
 + * that corresponds to the number of columns in the Table generated 
 + * in TestHelper . getTableWithAllColumnTypes 
 + * @ return 
 + * / 
 + @ DataProvider ( name = " columnIndex " ) 
 + public Iterator < Object [ ] > mixedValuesProvider ( ) { 
 + Long [ ] values = { 
 + 0L , 1L , 2L , 3L , 4L , 5L , 6L , 7L , 8L 
 + } ; 
 + 
 + List < ? > mixedValues = Arrays . asList ( values ) ; 
 + return DataProviderUtil . allCombinations ( mixedValues ) ; 
 + } 
 + }
