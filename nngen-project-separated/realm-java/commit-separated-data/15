BLEU SCORE: 0.014063699685797683

TEST MSG: Add support for uploading and downloading changes with a timeout
GENERATED MSG: POC async query , using Core ' fsa _ handover _ demo ' branch

TEST DIFF (one line): diff - - git a / CHANGELOG . md b / CHANGELOG . md <nl> index bde269a . . a0f18f8 100644 <nl> - - - a / CHANGELOG . md <nl> + + + b / CHANGELOG . md <nl> @ @ - 25 , 6 + 25 , 8 @ @ This release also contains all changes in 5 . 8 . 0 - BETA1 and 5 . 8 . 0 - BETA2 . <nl> * [ ObjectServer ] Added ` RealmQuery . subscribe ( ) ` and ` RealmQuery . subscribe ( String name ) ` to subscribe immediately inside a transaction . These API ' s are in beta . [ # 6231 ] ( https : / / github . com / realm / realm - java / pull / 6231 ) . <nl> * [ ObjectServer ] Added support for subscribing directly inside ` SyncConfiguration . initialData ( ) ` . This can be coupled with ` SyncConfiguration . waitForInitialRemoteData ( ) ` in order to block a Realm from opening until the initial subscriptions are ready and have downloaded data . This API are in beta . [ # 6231 ] ( https : / / github . com / realm / realm - java / pull / 6231 ) . <nl> * [ ObjectServer ] Improved performance when merging changes from the server . <nl> + * [ ObjectServer ] Added support for timeouts when uploading or downloading data manually using ` SyncSession . downloadAllServerChanges ( long timeout , TimeUnit unit ) ` and ` SyncSession . uploadAllLocalChanges ( long timeout , TimeUnit unit ) ` . [ # 6073 ] ( https : / / github . com / realm / realm - java / pull / 6073 ) <nl> + * [ ObjectServer ] Added support for timing out when downloading initial data for synchronized Realms using ` SyncConfiguration . waitForInitialRemoteData ( long timeout , TimeUnit unit ) ` . [ # 6247 ] ( https : / / github . com / realm / realm - java / issues / 6247 ) <nl> * Added support for ` ImportFlag ` s to ` Realm . copyToRealm ( ) ` and ` Realm . copyToRealmOrUpdate ( ) ` . This makes it possible to choose a mode so only fields that actually changed are written to disk . This improves notifications and Object Server performance . [ # 6224 ] ( https : / / github . com / realm / realm - java / pull / 6224 ) . <nl> <nl> # # # Fixed <nl> diff - - git a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java <nl> index 472c26a . . e86333d 100644 <nl> - - - a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java <nl> + + + b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import org . junit . Rule ; <nl> import org . junit . Test ; <nl> import org . junit . runner . RunWith ; <nl> <nl> + import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . atomic . AtomicBoolean ; <nl> <nl> import io . realm . entities . StringOnly ; <nl> @ @ - 402 , 6 + 403 , 52 @ @ public class SessionTests { <nl> <nl> @ Test <nl> @ UiThreadTest <nl> + public void uploadAllLocalChanges _ withTimeout _ throwsOnUiThread ( ) throws InterruptedException { <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + try { <nl> + SyncManager . getOrCreateSession ( configuration , null ) . uploadAllLocalChanges ( 30 , TimeUnit . SECONDS ) ; <nl> + fail ( " Should throw an IllegalStateException on Ui Thread " ) ; <nl> + } catch ( IllegalStateException ignored ) { <nl> + } finally { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void uploadAllLocalChanges _ withTimeout _ invalidParametersThrows ( ) throws InterruptedException { <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + SyncSession session = SyncManager . getOrCreateSession ( configuration , null ) ; <nl> + try { <nl> + try { <nl> + session . uploadAllLocalChanges ( - 1 , TimeUnit . SECONDS ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + <nl> + try { <nl> + / / noinspection ConstantConditions <nl> + session . uploadAllLocalChanges ( 1 , null ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } finally { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void uploadAllLocalChanges _ returnFalseWhenTimedOut ( ) throws InterruptedException { <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + SyncSession session = SyncManager . getOrCreateSession ( configuration , null ) ; <nl> + try { <nl> + assertFalse ( session . uploadAllLocalChanges ( 100 , TimeUnit . MILLISECONDS ) ) ; <nl> + } finally { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + @ UiThreadTest <nl> public void downloadAllServerChanges _ throwsOnUiThread ( ) throws InterruptedException { <nl> Realm realm = Realm . getInstance ( configuration ) ; <nl> try { <nl> @ @ - 415 , 6 + 462 , 53 @ @ public class SessionTests { <nl> <nl> @ Test <nl> @ UiThreadTest <nl> + public void downloadAllServerChanges _ withTimeout _ throwsOnUiThread ( ) throws InterruptedException { <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + try { <nl> + SyncManager . getOrCreateSession ( configuration , null ) . downloadAllServerChanges ( 30 , TimeUnit . SECONDS ) ; <nl> + fail ( " Should throw an IllegalStateException on Ui Thread " ) ; <nl> + } catch ( IllegalStateException ignored ) { <nl> + } finally { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + @ Test <nl> + public void downloadAllServerChanges _ withTimeout _ invalidParametersThrows ( ) throws InterruptedException { <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + SyncSession session = SyncManager . getOrCreateSession ( configuration , null ) ; <nl> + try { <nl> + try { <nl> + session . downloadAllServerChanges ( - 1 , TimeUnit . SECONDS ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + <nl> + try { <nl> + / / noinspection ConstantConditions <nl> + session . downloadAllServerChanges ( 1 , null ) ; <nl> + fail ( ) ; <nl> + } catch ( IllegalArgumentException ignored ) { <nl> + } <nl> + } finally { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void downloadAllServerChanges _ returnFalseWhenTimedOut ( ) throws InterruptedException { <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + SyncSession session = SyncManager . getOrCreateSession ( configuration , null ) ; <nl> + try { <nl> + assertFalse ( session . downloadAllServerChanges ( 100 , TimeUnit . MILLISECONDS ) ) ; <nl> + } finally { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + @ UiThreadTest <nl> public void unrecognizedErrorCode _ errorHandler ( ) { <nl> AtomicBoolean errorHandlerCalled = new AtomicBoolean ( false ) ; <nl> configuration = configFactory . createSyncConfigurationBuilder ( user , REALM _ URI ) <nl> diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java b / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java <nl> index a2ccd43 . . ed437ef 100644 <nl> - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java <nl> @ @ - 27 , 9 + 27 , 8 @ @ import java . security . NoSuchAlgorithmException ; <nl> import java . util . Arrays ; <nl> import java . util . Collections ; <nl> import java . util . HashSet ; <nl> - import java . util . LinkedHashMap ; <nl> import java . util . Locale ; <nl> - import java . util . Map ; <nl> + import java . util . concurrent . TimeUnit ; <nl> import java . util . regex . Matcher ; <nl> import java . util . regex . Pattern ; <nl> <nl> @ @ - 111 , 6 + 110 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { <nl> @ Nullable private final String serverCertificateAssetName ; <nl> @ Nullable private final String serverCertificateFilePath ; <nl> private final boolean waitForInitialData ; <nl> + private final long initialDataTimeoutMillis ; <nl> private final OsRealmConfig . SyncSessionStopPolicy sessionStopPolicy ; <nl> private final boolean isPartial ; <nl> @ Nullable private final String syncUrlPrefix ; <nl> @ @ - 136 , 6 + 136 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { <nl> @ Nullable String serverCertificateAssetName , <nl> @ Nullable String serverCertificateFilePath , <nl> boolean waitForInitialData , <nl> + long initialDataTimeoutMillis , <nl> OsRealmConfig . SyncSessionStopPolicy sessionStopPolicy , <nl> boolean isPartial , <nl> CompactOnLaunchCallback compactOnLaunch , <nl> @ @ - 165 , 6 + 166 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { <nl> this . serverCertificateAssetName = serverCertificateAssetName ; <nl> this . serverCertificateFilePath = serverCertificateFilePath ; <nl> this . waitForInitialData = waitForInitialData ; <nl> + this . initialDataTimeoutMillis = initialDataTimeoutMillis ; <nl> this . sessionStopPolicy = sessionStopPolicy ; <nl> this . isPartial = isPartial ; <nl> this . syncUrlPrefix = syncUrlPrefix ; <nl> @ @ - 408 , 6 + 410 , 18 @ @ public class SyncConfiguration extends RealmConfiguration { <nl> return waitForInitialData ; <nl> } <nl> <nl> + / * * <nl> + * Returns the timeout defined when downloading any initial data the first time the Realm is opened . <nl> + * < p > <nl> + * This value is only applicable if { @ link # shouldWaitForInitialRemoteData ( ) } returns { @ code true } . <nl> + * <nl> + * @ return the time Realm will wait for all changes to be downloaded before it is aborted and an exception is thrown . <nl> + * @ see SyncConfiguration . Builder # waitForInitialRemoteData ( long , TimeUnit ) <nl> + * / <nl> + public long getInitialRemoteDataTimeout ( TimeUnit unit ) { <nl> + return unit . convert ( initialDataTimeoutMillis , TimeUnit . MILLISECONDS ) ; <nl> + } <nl> + <nl> @ Override <nl> boolean isSyncConfiguration ( ) { <nl> return true ; <nl> @ @ - 479 , 6 + 493 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { <nl> private final Pattern pattern = Pattern . compile ( " ^ [ A - Za - z0 - 9 _ \ \ - \ \ . ] + $ " ) ; / / for checking serverUrl <nl> private boolean readOnly = false ; <nl> private boolean waitForServerChanges = false ; <nl> + private long initialDataTimeoutMillis = Long . MAX _ VALUE ; <nl> / / sync specific <nl> private boolean deleteRealmOnLogout = false ; <nl> private URI serverUrl ; <nl> @ @ - 928 , 7 + 943 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { <nl> return this ; <nl> } <nl> <nl> - / * <nl> + / * * <nl> * Setting this will cause the Realm to download all known changes from the server the first time a Realm is <nl> * opened . The Realm will not open until all the data has been downloaded . This means that if a device is <nl> * offline the Realm will not open . <nl> @ @ - 942 , 6 + 957 , 35 @ @ public class SyncConfiguration extends RealmConfiguration { <nl> * / <nl> public Builder waitForInitialRemoteData ( ) { <nl> this . waitForServerChanges = true ; <nl> + this . initialDataTimeoutMillis = Long . MAX _ VALUE ; <nl> + return this ; <nl> + } <nl> + <nl> + / * * <nl> + * Setting this will cause the Realm to download all known changes from the server the first time a Realm is <nl> + * opened . The Realm will not open until all the data has been downloaded . This means that if a device is <nl> + * offline the Realm will not open . <nl> + * < p > <nl> + * Since downloading all changes can be an lengthy operation that might block the UI thread , Realms with this <nl> + * setting enabled should only be opened on background threads or with <nl> + * { @ link Realm # getInstanceAsync ( RealmConfiguration , Realm . Callback ) } on the UI thread . <nl> + * < p > <nl> + * This check is only enforced the first time a Realm is created . If you otherwise want to make sure a Realm <nl> + * has the latest changes , use { @ link SyncSession # downloadAllServerChanges ( ) } . <nl> + * <nl> + * @ param timeout how long to wait for the download to complete before an { @ link io . realm . exceptions . DownloadingRealmInterruptedException } is thrown . <nl> + * @ param unit the unit of time used to define the timeout . <nl> + * / <nl> + public Builder waitForInitialRemoteData ( long timeout , TimeUnit unit ) { <nl> + if ( timeout < 0 ) { <nl> + throw new IllegalArgumentException ( " ' timeout ' must be > = 0 . It was : " + timeout ) ; <nl> + } <nl> + / / noinspection ConstantConditions <nl> + if ( unit = = null ) { <nl> + throw new IllegalArgumentException ( " Non - null ' unit ' required " ) ; <nl> + } <nl> + this . waitForServerChanges = true ; <nl> + this . initialDataTimeoutMillis = unit . toMillis ( timeout ) ; <nl> return this ; <nl> } <nl> <nl> @ @ - 1177 , 6 + 1221 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { <nl> serverCertificateAssetName , <nl> serverCertificateFilePath , <nl> waitForServerChanges , <nl> + initialDataTimeoutMillis , <nl> sessionStopPolicy , <nl> isPartial , <nl> compactOnLaunch , <nl> diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java <nl> index 08cfd93 . . d98d49d 100644 <nl> - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java <nl> @ @ - 481 , 7 + 481 , 35 @ @ public class SyncSession { <nl> / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the <nl> / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . <nl> synchronized ( waitForChangesMutex ) { <nl> - waitForChanges ( DIRECTION _ DOWNLOAD ) ; <nl> + waitForChanges ( DIRECTION _ DOWNLOAD , Long . MAX _ VALUE , TimeUnit . MILLISECONDS ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Calling this method will block until all known remote changes have been downloaded and applied to the Realm <nl> + * or the specified timeout is hit . This will involve network access , so calling this method should only be done <nl> + * from a non - UI thread . <nl> + * < p > <nl> + * This method cannot be called before the Realm has been opened . <nl> + * <nl> + * @ throws IllegalStateException if called on the Android main thread . <nl> + * @ throws InterruptedException if the download took longer than the specified timeout or the thread was interrupted while downloading was in progress . <nl> + * The download will continue in the background even after this exception is thrown . <nl> + * @ throws IllegalArgumentException if { @ code timeout } is less than or equal to { @ code 0 } or { @ code unit } is { @ code null } . <nl> + * @ return { @ code true } if the data was downloaded before the timeout . { @ code false } if the operation timed out or otherwise failed . <nl> + * / <nl> + public boolean downloadAllServerChanges ( long timeout , TimeUnit unit ) throws InterruptedException { <nl> + checkIfNotOnMainThread ( " downloadAllServerChanges ( ) cannot be called from the main thread . " ) ; <nl> + checkTimeout ( timeout , unit ) ; <nl> + <nl> + / / Blocking only happens at the Java layer . To prevent deadlocking the underlying SyncSession we register <nl> + / / an async listener there and let it callback to the Java Session when done . This feels icky at best , but <nl> + / / since all operations on the SyncSession operate under a shared mutex , we would prevent all other actions on the <nl> + / / session , including trying to stop it . <nl> + / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the <nl> + / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . <nl> + synchronized ( waitForChangesMutex ) { <nl> + return waitForChanges ( DIRECTION _ DOWNLOAD , timeout , unit ) ; <nl> } <nl> } <nl> <nl> @ @ - 491 , 7 + 519 , 7 @ @ public class SyncSession { <nl> * < p > <nl> * If the device is offline , this method might never return . <nl> * < p > <nl> - * This method cannot be called before the session has been started . <nl> + * This method cannot be called before the Realm has been opened . <nl> * <nl> * @ throws IllegalStateException if called on the Android main thread . <nl> * @ throws InterruptedException if the thread was interrupted while downloading was in progress . <nl> @ @ - 506 , 7 + 534 , 35 @ @ public class SyncSession { <nl> / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the <nl> / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . <nl> synchronized ( waitForChangesMutex ) { <nl> - waitForChanges ( DIRECTION _ UPLOAD ) ; <nl> + waitForChanges ( DIRECTION _ UPLOAD , Long . MAX _ VALUE , TimeUnit . MILLISECONDS ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Calling this method will block until all known local changes have been uploaded to the server or the specified <nl> + * timeout is hit . This will involve network access , so calling this method should only be done from a non - UI <nl> + * thread . <nl> + * < p > <nl> + * This method cannot be called before the Realm has been opened . <nl> + * <nl> + * @ throws IllegalStateException if called on the Android main thread . <nl> + * @ throws InterruptedException if the upload took longer than the specified timeout or the thread was interrupted while uploading was in progress . <nl> + * The upload will continue in the background even after this exception is thrown . <nl> + * @ throws IllegalArgumentException if { @ code timeout } is less than or equal to { @ code 0 } or { @ code unit } is { @ code null } . <nl> + * @ return { @ code true } if the data was uploaded before the timeout . { @ code false } if the operation timed out or otherwise failed . <nl> + * / <nl> + public boolean uploadAllLocalChanges ( long timeout , TimeUnit unit ) throws InterruptedException { <nl> + checkIfNotOnMainThread ( " uploadAllLocalChanges ( ) cannot be called from the main thread . " ) ; <nl> + checkTimeout ( timeout , unit ) ; <nl> + <nl> + / / Blocking only happens at the Java layer . To prevent deadlocking the underlying SyncSession we register <nl> + / / an async listener there and let it callback to the Java Session when done . This feels icky at best , but <nl> + / / since all operations on the SyncSession operate under a shared mutex , we would prevent all other actions on the <nl> + / / session , including trying to stop it . <nl> + / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the <nl> + / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . <nl> + synchronized ( waitForChangesMutex ) { <nl> + return waitForChanges ( DIRECTION _ UPLOAD , timeout , unit ) ; <nl> } <nl> } <nl> <nl> @ @ - 549 , 12 + 605 , 16 @ @ public class SyncSession { <nl> * This method should only be called when guarded by the { @ link # waitForChangesMutex } . <nl> * It will block into all changes have been either uploaded or downloaded depending on the chosen direction . <nl> * <nl> - * @ param direction either { @ link # DIRECTION _ DOWNLOAD } or { @ link # DIRECTION _ UPLOAD } <nl> + * @ param direction either { @ link # DIRECTION _ DOWNLOAD } or { @ link # DIRECTION _ UPLOAD } . <nl> + * @ param timeout timeout parameter . <nl> + * @ param unit timeout unit . <nl> + * @ return { @ code true } if the job completed before the timeout was hit , { @ code false } <nl> * / <nl> - private void waitForChanges ( int direction ) throws InterruptedException { <nl> + private boolean waitForChanges ( int direction , long timeout , TimeUnit unit ) throws InterruptedException { <nl> if ( direction ! = DIRECTION _ DOWNLOAD & & direction ! = DIRECTION _ UPLOAD ) { <nl> throw new IllegalArgumentException ( " Unknown direction : " + direction ) ; <nl> } <nl> + boolean result = false ; <nl> if ( ! isClosed ) { <nl> String realmPath = configuration . getPath ( ) ; <nl> WaitForSessionWrapper wrapper = new WaitForSessionWrapper ( ) ; <nl> @ @ - 565 , 7 + 625 , 7 @ @ public class SyncSession { <nl> : nativeWaitForUploadCompletion ( callbackId , realmPath ) ; <nl> if ( ! listenerRegistered ) { <nl> waitingForServerChanges . set ( null ) ; <nl> - String errorMsg = " " ; <nl> + String errorMsg ; <nl> switch ( direction ) { <nl> case DIRECTION _ DOWNLOAD : errorMsg = " It was not possible to download all remote changes . " ; break ; <nl> case DIRECTION _ UPLOAD : errorMsg = " It was not possible upload all local changes . " ; break ; <nl> @ @ - 576 , 7 + 636 , 7 @ @ public class SyncSession { <nl> throw new ObjectServerError ( ErrorCode . UNKNOWN , errorMsg + " Has the SyncClient been started ? " ) ; <nl> } <nl> try { <nl> - wrapper . waitForServerChanges ( ) ; <nl> + result = wrapper . waitForServerChanges ( timeout , unit ) ; <nl> } catch ( InterruptedException e ) { <nl> waitingForServerChanges . set ( null ) ; / / Ignore any results being sent if the wait was interrupted . <nl> throw e ; <nl> @ @ - 593 , 6 + 653 , 7 @ @ public class SyncSession { <nl> waitingForServerChanges . set ( null ) ; <nl> } <nl> } <nl> + return result ; <nl> } <nl> <nl> private void checkIfNotOnMainThread ( String errorMessage ) { <nl> @ @ - 601 , 6 + 662 , 16 @ @ public class SyncSession { <nl> } <nl> } <nl> <nl> + private void checkTimeout ( long timeout , TimeUnit unit ) { <nl> + if ( timeout < = 0 ) { <nl> + throw new IllegalArgumentException ( " ' timeout ' must be > 0 . It was : " + timeout ) ; <nl> + } <nl> + / / noinspection ConstantConditions <nl> + if ( unit = = null ) { <nl> + throw new IllegalArgumentException ( " Non - null ' unit ' required " ) ; <nl> + } <nl> + } <nl> + <nl> private void checkNonNullListener ( @ Nullable Object listener ) { <nl> if ( listener = = null ) { <nl> throw new IllegalArgumentException ( " Non - null ' listener ' required . " ) ; <nl> @ @ - 844 , 12 + 915 , 14 @ @ public class SyncSession { <nl> private String errorMessage ; <nl> <nl> / * * <nl> - * Block until the wait either completes or is terminated for other reasons . <nl> + * Block until the wait either completes , timeouts or is terminated for other reasons . <nl> + * Timeouts are only applied if ` timeout ` > = 0 . <nl> * / <nl> - public void waitForServerChanges ( ) throws InterruptedException { <nl> + public boolean waitForServerChanges ( long timeout , TimeUnit unit ) throws InterruptedException { <nl> if ( ! resultReceived ) { <nl> - waiter . await ( ) ; <nl> + return waiter . await ( timeout , unit ) ; <nl> } <nl> + return isSuccess ( ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / realm / realm - library / src / objectServer / java / io / realm / internal / SyncObjectServerFacade . java b / realm / realm - library / src / objectServer / java / io / realm / internal / SyncObjectServerFacade . java <nl> index e16ecd8 . . c9febae 100644 <nl> - - - a / realm / realm - library / src / objectServer / java / io / realm / internal / SyncObjectServerFacade . java <nl> + + + b / realm / realm - library / src / objectServer / java / io / realm / internal / SyncObjectServerFacade . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import java . lang . reflect . InvocationTargetException ; <nl> import java . lang . reflect . Method ; <nl> import java . util . Arrays ; <nl> import java . util . Map ; <nl> + import java . util . concurrent . TimeUnit ; <nl> <nl> import io . realm . Realm ; <nl> import io . realm . RealmConfiguration ; <nl> @ @ - 183 , 14 + 184 , 25 @ @ public class SyncObjectServerFacade extends ObjectServerFacade { <nl> if ( syncConfig . shouldWaitForInitialRemoteData ( ) ) { <nl> SyncSession session = SyncManager . getSession ( syncConfig ) ; <nl> try { <nl> + long timeoutMillis = syncConfig . getInitialRemoteDataTimeout ( TimeUnit . MILLISECONDS ) ; <nl> if ( ! syncConfig . isFullySynchronizedRealm ( ) ) { <nl> / / For Query - based Realms we want to upload all our local changes <nl> / / first since those might include subscriptions the server needs to process . <nl> - / / This means that once ` downloadAllServerChanges ` completes all <nl> - / / initial subscriptions will also have been downloaded . <nl> - session . uploadAllLocalChanges ( ) ; <nl> + / / This means that once ` downloadAllServerChanges ` completes , all initial <nl> + / / subscriptions will also have been downloaded . <nl> + / / <nl> + / / Note that we are reusing the same timeout for uploading and downloading . <nl> + / / This means that in the worst case you end up with 2x the timeout for <nl> + / / Query - based Realms . This is probably an acceptable trade - of as trying <nl> + / / to expose this would not only complicate the API surface quite a lot , <nl> + / / but in most ( almost all ? ) cases the amount of data to upload will be trivial . <nl> + if ( ! session . uploadAllLocalChanges ( timeoutMillis , TimeUnit . MILLISECONDS ) ) { <nl> + throw new DownloadingRealmInterruptedException ( syncConfig , " Failed to first upload local changes in " + timeoutMillis + " milliseconds " ) ; <nl> + } ; <nl> + } <nl> + if ( ! session . downloadAllServerChanges ( timeoutMillis , TimeUnit . MILLISECONDS ) ) { <nl> + throw new DownloadingRealmInterruptedException ( syncConfig , " Failed to download remote changes in " + timeoutMillis + " milliseconds " ) ; <nl> } <nl> - session . downloadAllServerChanges ( ) ; <nl> } catch ( InterruptedException e ) { <nl> throw new DownloadingRealmInterruptedException ( syncConfig , e ) ; <nl> } <nl> diff - - git a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java <nl> index 6300954 . . f137814 100644 <nl> - - - a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java <nl> + + + b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java <nl> @ @ - 16 , 10 + 16 , 12 @ @ import java . util . Arrays ; <nl> import java . util . List ; <nl> import java . util . UUID ; <nl> import java . util . concurrent . CountDownLatch ; <nl> + import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . atomic . AtomicReference ; <nl> <nl> import io . realm . entities . AllTypes ; <nl> import io . realm . entities . StringOnly ; <nl> + import io . realm . exceptions . DownloadingRealmInterruptedException ; <nl> import io . realm . internal . OsRealmConfig ; <nl> import io . realm . log . RealmLog ; <nl> import io . realm . objectserver . utils . Constants ; <nl> @ @ - 642 , 4 + 644 , 26 @ @ public class SyncSessionTests extends StandardIntegrationTest { <nl> looperThread . testComplete ( ) ; <nl> } ) ; <nl> } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void waitForInitialRemoteData _ throwsOnTimeout ( ) { <nl> + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; <nl> + SyncConfiguration syncConfiguration = configFactory <nl> + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) <nl> + . initialData ( bgRealm - > { <nl> + for ( int i = 0 ; i < 100 ; i + + ) { <nl> + bgRealm . createObject ( AllTypes . class ) ; <nl> + } <nl> + } ) <nl> + . waitForInitialRemoteData ( 1 , TimeUnit . MILLISECONDS ) <nl> + . build ( ) ; <nl> + <nl> + try { <nl> + Realm . getInstance ( syncConfiguration ) ; <nl> + fail ( " This should have timed out " ) ; <nl> + } catch ( DownloadingRealmInterruptedException ignore ) { <nl> + } <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index 1912025 . . 4d02c8a 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * Fixed unchecked cast warnings when building with Realm . <nl> * Cleaned up examples ( remove old test project ) . <nl> * Added checking for missing generic type in RealmList fields in annotation processor . <nl> + * Support async queries <nl> <nl> 0 . 80 . 3 <nl> * Calling Realm . copyToRealmOrUpdate ( ) with an object with a null primary key now throws a proper exception . <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> index bb26d54 . . 3cad125 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp <nl> @ @ - 14 , 12 + 14 , 14 @ @ <nl> * limitations under the License . <nl> * / <nl> <nl> + # include < realm / group _ shared . hpp > <nl> # include " util . hpp " <nl> # include " io _ realm _ internal _ TableQuery . h " <nl> # include " tablequery . hpp " <nl> <nl> using namespace realm ; <nl> <nl> + # define SG ( ptr ) reinterpret _ cast < SharedGroup * > ( ptr ) <nl> # if 1 <nl> # define COL _ TYPE _ VALID ( env , ptr , col , type ) TBL _ AND _ COL _ INDEX _ AND _ TYPE _ VALID ( env , ptr , col , type ) <nl> # define COL _ TYPE _ LINK _ OR _ LINKLIST ( env , ptr , col ) TBL _ AND _ COL _ INDEX _ AND _ LINK _ OR _ LINKLIST ( env , ptr , col ) <nl> @ @ - 1174 , 3 + 1176 , 47 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNull ( <nl> pQuery - > and _ query ( query ) ; <nl> } CATCH _ STD ( ) <nl> } <nl> + <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover <nl> + ( JNIEnv * env , jobject , jlong callerSharedGrpPtr , jlong bgSharedGroupPtr , jlong nativeQueryPtr , jlong start , jlong end , jlong limit ) <nl> + { <nl> + Query * pQuery = Q ( nativeQueryPtr ) ; <nl> + Table * pTable = pQuery - > get _ table ( ) . get ( ) ; <nl> + if ( ! QUERY _ VALID ( env , pQuery ) | | <nl> + ! ROW _ INDEXES _ VALID ( env , pTable , start , end , limit ) ) <nl> + return - 1 ; <nl> + try { <nl> + TableView * pResultView = new TableView ( pQuery - > find _ all ( S ( start ) , S ( end ) , S ( limit ) ) ) ; <nl> + std : : unique _ ptr < SharedGroup : : Handover < TableView > > handover ; <nl> + handover . reset ( SG ( bgSharedGroupPtr ) - > export _ for _ handover ( * pResultView , ConstSourcePayload : : Copy ) ) ; <nl> + / / TODO reimplement this so the call to ' export _ for _ handover ' is done on a background thread <nl> + / / and ' import _ from _ handover ' on the caller thread . <nl> + / / <nl> + / / According to core , it ' s preferable to return first the exported handover <nl> + / / then import it from the calling SharedGroup ( Thread ) . <nl> + / / We need to make sure to check that the version id ( version of the shared group used to perform the query ) <nl> + / / is the same as the caller SharedGroup , otherwise the import will fail . In this case , we should <nl> + / / either retry the entire query , or call again ' sync _ if _ needed ' on the TableView to re - query , at this point <nl> + / / we need to export again the handover to the caller SharedGroup , until we converge <nl> + / / ( i . e the version of the caller SharedGroup matches the version returned by the handover TableView ) <nl> + / / <nl> + / / Note : The mode ' ConstSourcePayload : : Copy ' handover perform a deep copy of the TableView , this means that we copy <nl> + / / both the Payload ( row accessors ) & the Query <nl> + / / <nl> + / / The mode ' ConstSourcePayload : : Stay ' handover perform a copy of the Query only ( no payload ) <nl> + / / The mode ' MutableSourcePayload : : Move ' handover perform a move of both the Payload & Query <nl> + / / <nl> + / / The expensive operations are in that order <nl> + / / pQuery - > find _ all > > export _ for _ handover > > import _ from _ handover <nl> + / / so it ' s recommended to run the ' query ' & the ' export ' on a background Thread , then <nl> + / / call ' import _ from _ handover ' on the caller thread ( most of the time UI thread ) . <nl> + / / calling ' import _ from _ handover ' on the UI thread has another benefit , it will block the SharedGroup <nl> + / / from modifying it ' s state ( advance _ read , promote _ write , rollback , commit etc ) <nl> + / / <nl> + / / The handover pointer is Thread safe , it can be passed from different Threads ( using different SharedGroups ) <nl> + <nl> + TableView * tv ( SG ( callerSharedGrpPtr ) - > import _ from _ handover ( handover . release ( ) ) ) ; <nl> + return reinterpret _ cast < jlong > ( tv ) ; <nl> + } CATCH _ STD ( ) <nl> + return - 1 ; <nl> + } <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> index 5ccb9ee . . 97a9ed7 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . h <nl> @ @ - 369 , 6 + 369 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAll <nl> <nl> / * <nl> * Class : io _ realm _ internal _ TableQuery <nl> + * Method : nativeFindAllWithHandover <nl> + * Signature : ( JJJJJJ ) J <nl> + * / <nl> + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover <nl> + ( JNIEnv * , jobject , jlong , jlong , jlong , jlong , jlong , jlong ) ; <nl> + <nl> + / * <nl> + * Class : io _ realm _ internal _ TableQuery <nl> * Method : nativeSumInt <nl> * Signature : ( JJJJJ ) J <nl> * / <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> new file mode 100644 <nl> index 0000000 . . 162e33a <nl> - - - / dev / null <nl> + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java <nl> @ @ - 0 , 0 + 1 , 151 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm ; <nl> + <nl> + import android . os . Looper ; <nl> + import android . test . InstrumentationTestCase ; <nl> + <nl> + import junit . framework . AssertionFailedError ; <nl> + <nl> + import java . util . Date ; <nl> + import java . util . concurrent . CountDownLatch ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . Executors ; <nl> + <nl> + import io . realm . entities . AllTypes ; <nl> + import io . realm . entities . NonLatinFieldNames ; <nl> + <nl> + public class RealmAsyncQueryTests extends InstrumentationTestCase { <nl> + <nl> + / / TODO use Junit4 & define a rule to setup the threading , to avoid <nl> + / / this boiler plat code , or use a custom test runner <nl> + public void testFindAll ( ) throws Throwable { <nl> + / / We need to control precisely which Looper / Thread our Realm <nl> + / / will operate on . This is unfortunately not possible when using the <nl> + / / current Instrumentation # InstrumentationThread , because InstrumentationTestRunner # onStart <nl> + / / Call Looper . prepare ( ) for us and surprisingly doesn ' t call Looper # loop ( ) , this is problematic <nl> + / / as the async query callback will not run ( because the Handler is sending Runnables to a Looper <nl> + / / that didn ' t loop . <nl> + / / <nl> + / / In the other hand , using a dedicated ' ExecutorService ' will allow us to fine grain control the <nl> + / / desired behaviour <nl> + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; <nl> + final Looper [ ] looper = new Looper [ 1 ] ; <nl> + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; <nl> + executorService . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Looper . prepare ( ) ; <nl> + looper [ 0 ] = Looper . myLooper ( ) ; <nl> + Realm realm = null ; <nl> + try { <nl> + realm = openRealmInstance ( ) ; <nl> + populateTestRealm ( realm , 10 ) ; <nl> + <nl> + / / async query ( will run on different thread ) <nl> + realm . asyncWhere ( AllTypes . class , <nl> + new Realm . AsyncCallback < RealmResults < AllTypes > > ( ) { <nl> + @ Override <nl> + public void onSuccess ( RealmResults < AllTypes > results ) { <nl> + try { <nl> + assertEquals ( 10 , results . size ( ) ) ; <nl> + <nl> + / / Make sure access to RealmObject will not throw an Exception <nl> + for ( int i = 0 , size = results . size ( ) ; i < size ; i + + ) { <nl> + assertEquals ( i , results . get ( i ) . getColumnLong ( ) ) ; <nl> + } <nl> + <nl> + } catch ( AssertionFailedError e ) { <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + / / whatever happened , make sure to notify the waiting TestCase Thread <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void onError ( Throwable t ) { <nl> + try { <nl> + threadAssertionError [ 0 ] = t ; <nl> + t . printStackTrace ( ) ; <nl> + } finally { <nl> + signalCallbackFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + } ) <nl> + . between ( " columnLong " , 0 , 9 ) . findAll ( ) ; <nl> + <nl> + Looper . loop ( ) ; / / ready to receive callback <nl> + <nl> + } finally { <nl> + if ( realm ! = null ) { <nl> + realm . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + / / wait until the callback of our async query proceed <nl> + signalCallbackFinished . await ( ) ; <nl> + looper [ 0 ] . quit ( ) ; <nl> + executorService . shutdownNow ( ) ; <nl> + if ( null ! = threadAssertionError [ 0 ] ) { <nl> + / / Throw any assertion errors happened in the background thread <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + } <nl> + <nl> + / / * * * Helper methods * * * <nl> + <nl> + / / This could be done from # setUp but then we can ' t control <nl> + / / which Looper we want to associate this Realm instance with <nl> + private Realm openRealmInstance ( ) { <nl> + RealmConfiguration realmConfiguration = new RealmConfiguration . <nl> + Builder ( getInstrumentation ( ) <nl> + . getTargetContext ( ) ) <nl> + . name ( " test . realm " ) <nl> + . deleteRealmIfMigrationNeeded ( ) <nl> + . build ( ) ; <nl> + Realm . deleteRealm ( realmConfiguration ) ; <nl> + return Realm . getInstance ( realmConfiguration ) ; <nl> + } <nl> + <nl> + private void populateTestRealm ( final Realm testRealm , int objects ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + testRealm . allObjects ( AllTypes . class ) . clear ( ) ; <nl> + testRealm . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; <nl> + for ( int i = 0 ; i < objects ; + + i ) { <nl> + AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; <nl> + allTypes . setColumnBoolean ( ( i % 3 ) = = 0 ) ; <nl> + allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; <nl> + allTypes . setColumnDate ( new Date ( ) ) ; <nl> + allTypes . setColumnDouble ( 3 . 1415 ) ; <nl> + allTypes . setColumnFloat ( 1 . 234567f + i ) ; <nl> + allTypes . setColumnString ( " test data " + i ) ; <nl> + allTypes . setColumnLong ( i ) ; <nl> + NonLatinFieldNames nonLatinFieldNames = testRealm . createObject ( NonLatinFieldNames . class ) ; <nl> + nonLatinFieldNames . set 델 타 ( i ) ; <nl> + nonLatinFieldNames . set Δ έ λ τ α ( i ) ; <nl> + nonLatinFieldNames . set 베 타 ( 1 . 234567f + i ) ; <nl> + nonLatinFieldNames . set Β ή τ α ( 1 . 234567f + i ) ; <nl> + } <nl> + testRealm . commitTransaction ( ) ; <nl> + testRealm . refresh ( ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index ca29295 . . d2e5033 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 22 , 7 + 22 , 6 @ @ import org . json . JSONArray ; <nl> import org . json . JSONException ; <nl> import org . json . JSONObject ; <nl> <nl> - import java . io . ByteArrayInputStream ; <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> import java . io . InputStream ; <nl> diff - - git a / realm / src / main / java / io / realm / AsyncRealmQueryResult . java b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java <nl> new file mode 100644 <nl> index 0000000 . . 7318359 <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java <nl> @ @ - 0 , 0 + 1 , 25 @ @ <nl> + package io . realm ; <nl> + <nl> + import java . util . concurrent . Future ; <nl> + <nl> + / * * <nl> + * Represents the result of an asynchronous Realm query . <nl> + * <nl> + * Users are responsible of maintaining a reference to { @ code AsyncRealmQueryResult } in order <nl> + * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the <nl> + * query will post the result to the caller ' s thread callback ) <nl> + * / <nl> + public class AsyncRealmQueryResult { <nl> + final Future < ? > pendingQuery ; <nl> + <nl> + public AsyncRealmQueryResult ( Future < ? > pendingQuery ) { <nl> + this . pendingQuery = pendingQuery ; <nl> + } <nl> + <nl> + / * * <nl> + * Attempts to cancel execution of this queries . <nl> + * / <nl> + public void cancel ( ) { <nl> + pendingQuery . cancel ( true ) ; <nl> + } <nl> + } <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index ddbc022 . . 15aac8b 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 63 , 6 + 63 , 7 @ @ import io . realm . internal . SharedGroup ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableView ; <nl> import io . realm . internal . Util ; <nl> + import io . realm . internal . android . AsyncRealmQuery ; <nl> import io . realm . internal . android . DebugAndroidLogger ; <nl> import io . realm . internal . android . ReleaseAndroidLogger ; <nl> import io . realm . internal . log . RealmLog ; <nl> @ @ - 154 , 6 + 155 , 9 @ @ public final class Realm implements Closeable { <nl> private static final Map < String , AtomicInteger > globalOpenInstanceCounter = <nl> new ConcurrentHashMap < String , AtomicInteger > ( ) ; <nl> <nl> + / / Thread Pool for all async operations ( Query & Write transaction ) <nl> + public static final ExecutorService asyncQueryExecutor = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) * 2 + 1 ) ; <nl> + <nl> protected static final Map < Handler , String > handlers = new ConcurrentHashMap < Handler , String > ( ) ; <nl> private static final int REALM _ CHANGED = 14930352 ; / / Hopefully it won ' t clash with other message IDs . <nl> <nl> @ @ - 1198 , 6 + 1202 , 20 @ @ public final class Realm implements Closeable { <nl> } <nl> <nl> / * * <nl> + * Prepare an async query <nl> + * TODO point to documentation or example about async query <nl> + * @ param clazz The class of the object which is to be queried for <nl> + * @ return A typed RealmQuery , which can be used to query for specific objects of this type <nl> + * @ throws java . lang . RuntimeException Any other error <nl> + * @ see io . realm . RealmQuery <nl> + * @ param callback <nl> + * / <nl> + public < E extends RealmObject > AsyncRealmQuery < E > asyncWhere ( Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { <nl> + checkIfValid ( ) ; <nl> + return new AsyncRealmQuery < E > ( this , clazz , callback ) ; <nl> + } <nl> + <nl> + / * * <nl> * Get all objects of a specific Class . If no objects exist , the returned RealmResults will not <nl> * be null . The RealmResults . size ( ) to check the number of objects instead . <nl> * <nl> @ @ - 1872 , 4 + 1890 , 24 @ @ public final class Realm implements Closeable { <nl> void execute ( Realm realm ) ; <nl> } <nl> <nl> + / * * <nl> + * Encapsulates an async { @ link RealmQuery } . <nl> + * < p > <nl> + * This will run the { @ link RealmQuery } on a worker thread , then invoke this callback on the caller thread <nl> + * / <nl> + public interface AsyncCallback < T extends RealmResults < ? extends RealmObject > > { <nl> + void onSuccess ( T results ) ; <nl> + void onError ( Throwable t ) ; <nl> + } <nl> + <nl> + <nl> + / / FIXME Realm . java being the public API and the implementation . <nl> + / / we need a Realm interface to be able to separate this kind of call <nl> + / / ( mostly from internal API / tests that need to access private field / method ) . <nl> + / / RealmImpl will be accessible to other internal packages <nl> + / / but not to the user ( avoid compromising our exposed public API ) <nl> + / / <nl> + public long getSharedGroupPtr ( ) { <nl> + return sharedGroup . nativePtr ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java <nl> index df847f5 . . b744adc 100644 <nl> - - - a / realm / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1302 , 4 + 1302 , 8 @ @ public class RealmQuery < E extends RealmObject > { <nl> return null ; <nl> } <nl> } <nl> + <nl> + protected TableQuery getTableQuery ( ) { <nl> + return this . query ; <nl> + } <nl> } <nl> diff - - git a / realm / src / main / java / io / realm / internal / TableQuery . java b / realm / src / main / java / io / realm / internal / TableQuery . java <nl> index e82eaa7 . . 268645d 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / TableQuery . java <nl> + + + b / realm / src / main / java / io / realm / internal / TableQuery . java <nl> @ @ - 493 , 8 + 493 , 24 @ @ public class TableQuery implements Closeable { <nl> } <nl> } <nl> <nl> - protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; <nl> + public TableView findAllWithHandover ( long callerSharedGroupPtr , long bgSharedGroupPtr ) { <nl> + validateQuery ( ) ; <nl> + <nl> + / / Execute the disposal of abandoned realm objects each time a new realm object is created <nl> + context . executeDelayedDisposal ( ) ; <nl> + long nativeViewPtr = nativeFindAllWithHandover ( callerSharedGroupPtr , bgSharedGroupPtr , nativePtr , 0 , Table . INFINITE , Table . INFINITE ) ; / / nativeViewPtr is created from bg Thread <nl> + / / handover nativeViewPtr to UI Thread <nl> + <nl> + try { <nl> + return new TableView ( this . context , this . parent , nativeViewPtr ) ; <nl> + } catch ( RuntimeException e ) { <nl> + TableView . nativeClose ( nativeViewPtr ) ; <nl> + throw e ; <nl> + } <nl> + } <nl> <nl> + protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; <nl> + protected native long nativeFindAllWithHandover ( long nativeCallerSharedGroupPtr , long bgSharedGroupPtr , long nativeQueryPtr , long start , long end , long limit ) ; <nl> / / <nl> / / Aggregation methods <nl> / / <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java <nl> new file mode 100644 <nl> index 0000000 . . c3716eb <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java <nl> @ @ - 0 , 0 + 1 , 165 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . android ; <nl> + <nl> + import android . os . Handler ; <nl> + import android . os . Looper ; <nl> + import android . os . Message ; <nl> + <nl> + import java . util . concurrent . Future ; <nl> + <nl> + import io . realm . AsyncRealmQueryResult ; <nl> + import io . realm . Realm ; <nl> + import io . realm . RealmConfiguration ; <nl> + import io . realm . RealmObject ; <nl> + import io . realm . RealmQuery ; <nl> + import io . realm . RealmResults ; <nl> + import io . realm . internal . TableOrView ; <nl> + import io . realm . internal . TableView ; <nl> + <nl> + import static io . realm . Realm . asyncQueryExecutor ; <nl> + <nl> + / * * <nl> + * A helper class to help make handling asynchronous { @ link RealmQuery } easier . <nl> + * <nl> + * @ param < E > type of the object which is to be queried for <nl> + * / <nl> + / / Behaviour may change , user should not subclass <nl> + public final class AsyncRealmQuery < E extends RealmObject > { <nl> + private final Realm callerRealm ; <nl> + private final Class < E > clazz ; <nl> + private final Realm . AsyncCallback < RealmResults < E > > callback ; <nl> + <nl> + private int from ; <nl> + private int to ; <nl> + private String fieldName ; <nl> + private EventHandler eventHandler ; <nl> + private Future < ? > pendingQuery ; <nl> + <nl> + / * * <nl> + * Create an { @ code AsyncRealmQuery } instance . <nl> + * <nl> + * @ param realm The realm to query within . <nl> + * @ param clazz The class to query . <nl> + * @ param callback invoked on the thread { @ link Realm # asyncWhere ( Class , Realm . AsyncCallback ) } was called from , to post results . <nl> + * / <nl> + public AsyncRealmQuery ( Realm realm , Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { <nl> + this . callerRealm = realm ; <nl> + this . callback = callback ; <nl> + this . clazz = clazz ; <nl> + } <nl> + <nl> + / * * <nl> + * Between condition <nl> + * <nl> + * @ param fieldName The field to compare <nl> + * @ param from Lowest value ( inclusive ) <nl> + * @ param to Highest value ( inclusive ) <nl> + * @ return current instance of { @ code AsyncRealmQuery } for method chaining <nl> + * / <nl> + public AsyncRealmQuery < E > between ( String fieldName , int from , int to ) { <nl> + this . from = from ; <nl> + this . to = to ; <nl> + this . fieldName = fieldName ; <nl> + return this ; <nl> + } <nl> + <nl> + / * * <nl> + * Find all objects that fulfill the query conditions . <nl> + * Results will be posted to the callback instance { @ link io . realm . Realm . AsyncCallback } asynchronously <nl> + * If no objects match the condition , a list with zero objects is returned . <nl> + * <nl> + * @ see io . realm . RealmResults <nl> + * / <nl> + public AsyncRealmQueryResult findAll ( ) { <nl> + / / will use the Looper of the caller thread to post the result <nl> + Looper looper ; <nl> + if ( ( looper = Looper . myLooper ( ) ) ! = null ) { <nl> + eventHandler = new EventHandler ( looper ) ; <nl> + } else if ( ( looper = Looper . getMainLooper ( ) ) ! = null ) { <nl> + eventHandler = new EventHandler ( looper ) ; <nl> + } else { <nl> + eventHandler = null ; / / FIXME define strategy / behaviour for regular JVM call <nl> + } <nl> + <nl> + / / We need a pointer to the caller Realm , to be able to handover the result to it <nl> + final long callerSharedGroupNativePtr = callerRealm . getSharedGroupPtr ( ) ; <nl> + <nl> + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) <nl> + / / to perform the query <nl> + final RealmConfiguration realmConfiguration = callerRealm . getConfiguration ( ) ; <nl> + <nl> + pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> + try { <nl> + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; <nl> + <nl> + / / TODO This will probably be replace by a kind of ' QueryBuilder ' <nl> + / / that holds all the operations ( predicates / filters ) then <nl> + / / replay them here in this background thread . The current implementation <nl> + / / call Core for each step , we want to limit the overhead by sending one <nl> + / / single call to Core with all the parameters . <nl> + <nl> + TableView tv = new RealmQueryAdapter < E > ( bgRealm , clazz ) <nl> + . between ( fieldName , from , to ) <nl> + . findAll ( callerSharedGroupNativePtr , bgRealm . getSharedGroupPtr ( ) ) ; <nl> + <nl> + bgRealm . close ( ) ; <nl> + <nl> + / / send results to the caller thread ' s callback <nl> + if ( ! pendingQuery . isCancelled ( ) ) { <nl> + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ SUCCESS , tv ) ; <nl> + eventHandler . sendMessage ( msg ) ; <nl> + } <nl> + <nl> + } catch ( Exception e ) { <nl> + if ( ! pendingQuery . isCancelled ( ) ) { <nl> + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ ERROR , e ) ; <nl> + eventHandler . sendMessage ( msg ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } ) ; <nl> + <nl> + return new AsyncRealmQueryResult ( pendingQuery ) ; <nl> + } <nl> + <nl> + private class EventHandler extends Handler { <nl> + private static final int MSG _ SUCCESS = 1 ; <nl> + private static final int MSG _ ERROR = MSG _ SUCCESS + 1 ; <nl> + <nl> + public EventHandler ( Looper looper ) { <nl> + super ( looper ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void handleMessage ( Message msg ) { <nl> + switch ( msg . what ) { <nl> + case MSG _ SUCCESS : <nl> + RealmResults < E > resultList = new RealmResults < E > ( callerRealm , ( TableOrView ) msg . obj , clazz ) ; <nl> + callback . onSuccess ( resultList ) ; <nl> + break ; <nl> + case MSG _ ERROR : <nl> + callback . onError ( ( Throwable ) msg . obj ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> diff - - git a / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java <nl> new file mode 100644 <nl> index 0000000 . . acac317 <nl> - - - / dev / null <nl> + + + b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java <nl> @ @ - 0 , 0 + 1 , 38 @ @ <nl> + / * <nl> + * Copyright 2015 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . android ; <nl> + <nl> + import io . realm . Realm ; <nl> + import io . realm . RealmObject ; <nl> + import io . realm . RealmQuery ; <nl> + import io . realm . internal . TableView ; <nl> + <nl> + class RealmQueryAdapter < E extends RealmObject > extends RealmQuery < E > { <nl> + public RealmQueryAdapter ( Realm realm , Class < E > clazz ) { <nl> + super ( realm , clazz ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public RealmQueryAdapter < E > between ( String fieldName , int from , int to ) { <nl> + super . between ( fieldName , from , to ) ; <nl> + return this ; <nl> + } <nl> + <nl> + public TableView findAll ( long callerRealmPtr , long backgroundRealmPtr ) { <nl> + return getTableQuery ( ) . findAllWithHandover ( callerRealmPtr , backgroundRealmPtr ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / CHANGELOG . md b / CHANGELOG . md 
 index bde269a . . a0f18f8 100644 
 - - - a / CHANGELOG . md 
 + + + b / CHANGELOG . md 
 @ @ - 25 , 6 + 25 , 8 @ @ This release also contains all changes in 5 . 8 . 0 - BETA1 and 5 . 8 . 0 - BETA2 . 
 * [ ObjectServer ] Added ` RealmQuery . subscribe ( ) ` and ` RealmQuery . subscribe ( String name ) ` to subscribe immediately inside a transaction . These API ' s are in beta . [ # 6231 ] ( https : / / github . com / realm / realm - java / pull / 6231 ) . 
 * [ ObjectServer ] Added support for subscribing directly inside ` SyncConfiguration . initialData ( ) ` . This can be coupled with ` SyncConfiguration . waitForInitialRemoteData ( ) ` in order to block a Realm from opening until the initial subscriptions are ready and have downloaded data . This API are in beta . [ # 6231 ] ( https : / / github . com / realm / realm - java / pull / 6231 ) . 
 * [ ObjectServer ] Improved performance when merging changes from the server . 
 + * [ ObjectServer ] Added support for timeouts when uploading or downloading data manually using ` SyncSession . downloadAllServerChanges ( long timeout , TimeUnit unit ) ` and ` SyncSession . uploadAllLocalChanges ( long timeout , TimeUnit unit ) ` . [ # 6073 ] ( https : / / github . com / realm / realm - java / pull / 6073 ) 
 + * [ ObjectServer ] Added support for timing out when downloading initial data for synchronized Realms using ` SyncConfiguration . waitForInitialRemoteData ( long timeout , TimeUnit unit ) ` . [ # 6247 ] ( https : / / github . com / realm / realm - java / issues / 6247 ) 
 * Added support for ` ImportFlag ` s to ` Realm . copyToRealm ( ) ` and ` Realm . copyToRealmOrUpdate ( ) ` . This makes it possible to choose a mode so only fields that actually changed are written to disk . This improves notifications and Object Server performance . [ # 6224 ] ( https : / / github . com / realm / realm - java / pull / 6224 ) . 
 
 # # # Fixed 
 diff - - git a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java 
 index 472c26a . . e86333d 100644 
 - - - a / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java 
 + + + b / realm / realm - library / src / androidTestObjectServer / java / io / realm / SessionTests . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import org . junit . Rule ; 
 import org . junit . Test ; 
 import org . junit . runner . RunWith ; 
 
 + import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . atomic . AtomicBoolean ; 
 
 import io . realm . entities . StringOnly ; 
 @ @ - 402 , 6 + 403 , 52 @ @ public class SessionTests { 
 
 @ Test 
 @ UiThreadTest 
 + public void uploadAllLocalChanges _ withTimeout _ throwsOnUiThread ( ) throws InterruptedException { 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + try { 
 + SyncManager . getOrCreateSession ( configuration , null ) . uploadAllLocalChanges ( 30 , TimeUnit . SECONDS ) ; 
 + fail ( " Should throw an IllegalStateException on Ui Thread " ) ; 
 + } catch ( IllegalStateException ignored ) { 
 + } finally { 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void uploadAllLocalChanges _ withTimeout _ invalidParametersThrows ( ) throws InterruptedException { 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + SyncSession session = SyncManager . getOrCreateSession ( configuration , null ) ; 
 + try { 
 + try { 
 + session . uploadAllLocalChanges ( - 1 , TimeUnit . SECONDS ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + 
 + try { 
 + / / noinspection ConstantConditions 
 + session . uploadAllLocalChanges ( 1 , null ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } finally { 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void uploadAllLocalChanges _ returnFalseWhenTimedOut ( ) throws InterruptedException { 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + SyncSession session = SyncManager . getOrCreateSession ( configuration , null ) ; 
 + try { 
 + assertFalse ( session . uploadAllLocalChanges ( 100 , TimeUnit . MILLISECONDS ) ) ; 
 + } finally { 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + @ UiThreadTest 
 public void downloadAllServerChanges _ throwsOnUiThread ( ) throws InterruptedException { 
 Realm realm = Realm . getInstance ( configuration ) ; 
 try { 
 @ @ - 415 , 6 + 462 , 53 @ @ public class SessionTests { 
 
 @ Test 
 @ UiThreadTest 
 + public void downloadAllServerChanges _ withTimeout _ throwsOnUiThread ( ) throws InterruptedException { 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + try { 
 + SyncManager . getOrCreateSession ( configuration , null ) . downloadAllServerChanges ( 30 , TimeUnit . SECONDS ) ; 
 + fail ( " Should throw an IllegalStateException on Ui Thread " ) ; 
 + } catch ( IllegalStateException ignored ) { 
 + } finally { 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 + 
 + @ Test 
 + public void downloadAllServerChanges _ withTimeout _ invalidParametersThrows ( ) throws InterruptedException { 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + SyncSession session = SyncManager . getOrCreateSession ( configuration , null ) ; 
 + try { 
 + try { 
 + session . downloadAllServerChanges ( - 1 , TimeUnit . SECONDS ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + 
 + try { 
 + / / noinspection ConstantConditions 
 + session . downloadAllServerChanges ( 1 , null ) ; 
 + fail ( ) ; 
 + } catch ( IllegalArgumentException ignored ) { 
 + } 
 + } finally { 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void downloadAllServerChanges _ returnFalseWhenTimedOut ( ) throws InterruptedException { 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + SyncSession session = SyncManager . getOrCreateSession ( configuration , null ) ; 
 + try { 
 + assertFalse ( session . downloadAllServerChanges ( 100 , TimeUnit . MILLISECONDS ) ) ; 
 + } finally { 
 + realm . close ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + @ UiThreadTest 
 public void unrecognizedErrorCode _ errorHandler ( ) { 
 AtomicBoolean errorHandlerCalled = new AtomicBoolean ( false ) ; 
 configuration = configFactory . createSyncConfigurationBuilder ( user , REALM _ URI ) 
 diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java b / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java 
 index a2ccd43 . . ed437ef 100644 
 - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncConfiguration . java 
 @ @ - 27 , 9 + 27 , 8 @ @ import java . security . NoSuchAlgorithmException ; 
 import java . util . Arrays ; 
 import java . util . Collections ; 
 import java . util . HashSet ; 
 - import java . util . LinkedHashMap ; 
 import java . util . Locale ; 
 - import java . util . Map ; 
 + import java . util . concurrent . TimeUnit ; 
 import java . util . regex . Matcher ; 
 import java . util . regex . Pattern ; 
 
 @ @ - 111 , 6 + 110 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { 
 @ Nullable private final String serverCertificateAssetName ; 
 @ Nullable private final String serverCertificateFilePath ; 
 private final boolean waitForInitialData ; 
 + private final long initialDataTimeoutMillis ; 
 private final OsRealmConfig . SyncSessionStopPolicy sessionStopPolicy ; 
 private final boolean isPartial ; 
 @ Nullable private final String syncUrlPrefix ; 
 @ @ - 136 , 6 + 136 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { 
 @ Nullable String serverCertificateAssetName , 
 @ Nullable String serverCertificateFilePath , 
 boolean waitForInitialData , 
 + long initialDataTimeoutMillis , 
 OsRealmConfig . SyncSessionStopPolicy sessionStopPolicy , 
 boolean isPartial , 
 CompactOnLaunchCallback compactOnLaunch , 
 @ @ - 165 , 6 + 166 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { 
 this . serverCertificateAssetName = serverCertificateAssetName ; 
 this . serverCertificateFilePath = serverCertificateFilePath ; 
 this . waitForInitialData = waitForInitialData ; 
 + this . initialDataTimeoutMillis = initialDataTimeoutMillis ; 
 this . sessionStopPolicy = sessionStopPolicy ; 
 this . isPartial = isPartial ; 
 this . syncUrlPrefix = syncUrlPrefix ; 
 @ @ - 408 , 6 + 410 , 18 @ @ public class SyncConfiguration extends RealmConfiguration { 
 return waitForInitialData ; 
 } 
 
 + / * * 
 + * Returns the timeout defined when downloading any initial data the first time the Realm is opened . 
 + * < p > 
 + * This value is only applicable if { @ link # shouldWaitForInitialRemoteData ( ) } returns { @ code true } . 
 + * 
 + * @ return the time Realm will wait for all changes to be downloaded before it is aborted and an exception is thrown . 
 + * @ see SyncConfiguration . Builder # waitForInitialRemoteData ( long , TimeUnit ) 
 + * / 
 + public long getInitialRemoteDataTimeout ( TimeUnit unit ) { 
 + return unit . convert ( initialDataTimeoutMillis , TimeUnit . MILLISECONDS ) ; 
 + } 
 + 
 @ Override 
 boolean isSyncConfiguration ( ) { 
 return true ; 
 @ @ - 479 , 6 + 493 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { 
 private final Pattern pattern = Pattern . compile ( " ^ [ A - Za - z0 - 9 _ \ \ - \ \ . ] + $ " ) ; / / for checking serverUrl 
 private boolean readOnly = false ; 
 private boolean waitForServerChanges = false ; 
 + private long initialDataTimeoutMillis = Long . MAX _ VALUE ; 
 / / sync specific 
 private boolean deleteRealmOnLogout = false ; 
 private URI serverUrl ; 
 @ @ - 928 , 7 + 943 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { 
 return this ; 
 } 
 
 - / * 
 + / * * 
 * Setting this will cause the Realm to download all known changes from the server the first time a Realm is 
 * opened . The Realm will not open until all the data has been downloaded . This means that if a device is 
 * offline the Realm will not open . 
 @ @ - 942 , 6 + 957 , 35 @ @ public class SyncConfiguration extends RealmConfiguration { 
 * / 
 public Builder waitForInitialRemoteData ( ) { 
 this . waitForServerChanges = true ; 
 + this . initialDataTimeoutMillis = Long . MAX _ VALUE ; 
 + return this ; 
 + } 
 + 
 + / * * 
 + * Setting this will cause the Realm to download all known changes from the server the first time a Realm is 
 + * opened . The Realm will not open until all the data has been downloaded . This means that if a device is 
 + * offline the Realm will not open . 
 + * < p > 
 + * Since downloading all changes can be an lengthy operation that might block the UI thread , Realms with this 
 + * setting enabled should only be opened on background threads or with 
 + * { @ link Realm # getInstanceAsync ( RealmConfiguration , Realm . Callback ) } on the UI thread . 
 + * < p > 
 + * This check is only enforced the first time a Realm is created . If you otherwise want to make sure a Realm 
 + * has the latest changes , use { @ link SyncSession # downloadAllServerChanges ( ) } . 
 + * 
 + * @ param timeout how long to wait for the download to complete before an { @ link io . realm . exceptions . DownloadingRealmInterruptedException } is thrown . 
 + * @ param unit the unit of time used to define the timeout . 
 + * / 
 + public Builder waitForInitialRemoteData ( long timeout , TimeUnit unit ) { 
 + if ( timeout < 0 ) { 
 + throw new IllegalArgumentException ( " ' timeout ' must be > = 0 . It was : " + timeout ) ; 
 + } 
 + / / noinspection ConstantConditions 
 + if ( unit = = null ) { 
 + throw new IllegalArgumentException ( " Non - null ' unit ' required " ) ; 
 + } 
 + this . waitForServerChanges = true ; 
 + this . initialDataTimeoutMillis = unit . toMillis ( timeout ) ; 
 return this ; 
 } 
 
 @ @ - 1177 , 6 + 1221 , 7 @ @ public class SyncConfiguration extends RealmConfiguration { 
 serverCertificateAssetName , 
 serverCertificateFilePath , 
 waitForServerChanges , 
 + initialDataTimeoutMillis , 
 sessionStopPolicy , 
 isPartial , 
 compactOnLaunch , 
 diff - - git a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java 
 index 08cfd93 . . d98d49d 100644 
 - - - a / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / SyncSession . java 
 @ @ - 481 , 7 + 481 , 35 @ @ public class SyncSession { 
 / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the 
 / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . 
 synchronized ( waitForChangesMutex ) { 
 - waitForChanges ( DIRECTION _ DOWNLOAD ) ; 
 + waitForChanges ( DIRECTION _ DOWNLOAD , Long . MAX _ VALUE , TimeUnit . MILLISECONDS ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Calling this method will block until all known remote changes have been downloaded and applied to the Realm 
 + * or the specified timeout is hit . This will involve network access , so calling this method should only be done 
 + * from a non - UI thread . 
 + * < p > 
 + * This method cannot be called before the Realm has been opened . 
 + * 
 + * @ throws IllegalStateException if called on the Android main thread . 
 + * @ throws InterruptedException if the download took longer than the specified timeout or the thread was interrupted while downloading was in progress . 
 + * The download will continue in the background even after this exception is thrown . 
 + * @ throws IllegalArgumentException if { @ code timeout } is less than or equal to { @ code 0 } or { @ code unit } is { @ code null } . 
 + * @ return { @ code true } if the data was downloaded before the timeout . { @ code false } if the operation timed out or otherwise failed . 
 + * / 
 + public boolean downloadAllServerChanges ( long timeout , TimeUnit unit ) throws InterruptedException { 
 + checkIfNotOnMainThread ( " downloadAllServerChanges ( ) cannot be called from the main thread . " ) ; 
 + checkTimeout ( timeout , unit ) ; 
 + 
 + / / Blocking only happens at the Java layer . To prevent deadlocking the underlying SyncSession we register 
 + / / an async listener there and let it callback to the Java Session when done . This feels icky at best , but 
 + / / since all operations on the SyncSession operate under a shared mutex , we would prevent all other actions on the 
 + / / session , including trying to stop it . 
 + / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the 
 + / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . 
 + synchronized ( waitForChangesMutex ) { 
 + return waitForChanges ( DIRECTION _ DOWNLOAD , timeout , unit ) ; 
 } 
 } 
 
 @ @ - 491 , 7 + 519 , 7 @ @ public class SyncSession { 
 * < p > 
 * If the device is offline , this method might never return . 
 * < p > 
 - * This method cannot be called before the session has been started . 
 + * This method cannot be called before the Realm has been opened . 
 * 
 * @ throws IllegalStateException if called on the Android main thread . 
 * @ throws InterruptedException if the thread was interrupted while downloading was in progress . 
 @ @ - 506 , 7 + 534 , 35 @ @ public class SyncSession { 
 / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the 
 / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . 
 synchronized ( waitForChangesMutex ) { 
 - waitForChanges ( DIRECTION _ UPLOAD ) ; 
 + waitForChanges ( DIRECTION _ UPLOAD , Long . MAX _ VALUE , TimeUnit . MILLISECONDS ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Calling this method will block until all known local changes have been uploaded to the server or the specified 
 + * timeout is hit . This will involve network access , so calling this method should only be done from a non - UI 
 + * thread . 
 + * < p > 
 + * This method cannot be called before the Realm has been opened . 
 + * 
 + * @ throws IllegalStateException if called on the Android main thread . 
 + * @ throws InterruptedException if the upload took longer than the specified timeout or the thread was interrupted while uploading was in progress . 
 + * The upload will continue in the background even after this exception is thrown . 
 + * @ throws IllegalArgumentException if { @ code timeout } is less than or equal to { @ code 0 } or { @ code unit } is { @ code null } . 
 + * @ return { @ code true } if the data was uploaded before the timeout . { @ code false } if the operation timed out or otherwise failed . 
 + * / 
 + public boolean uploadAllLocalChanges ( long timeout , TimeUnit unit ) throws InterruptedException { 
 + checkIfNotOnMainThread ( " uploadAllLocalChanges ( ) cannot be called from the main thread . " ) ; 
 + checkTimeout ( timeout , unit ) ; 
 + 
 + / / Blocking only happens at the Java layer . To prevent deadlocking the underlying SyncSession we register 
 + / / an async listener there and let it callback to the Java Session when done . This feels icky at best , but 
 + / / since all operations on the SyncSession operate under a shared mutex , we would prevent all other actions on the 
 + / / session , including trying to stop it . 
 + / / In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the 
 + / / lifecycle while it is in a waiting state . Thus we use a specialised mutex . 
 + synchronized ( waitForChangesMutex ) { 
 + return waitForChanges ( DIRECTION _ UPLOAD , timeout , unit ) ; 
 } 
 } 
 
 @ @ - 549 , 12 + 605 , 16 @ @ public class SyncSession { 
 * This method should only be called when guarded by the { @ link # waitForChangesMutex } . 
 * It will block into all changes have been either uploaded or downloaded depending on the chosen direction . 
 * 
 - * @ param direction either { @ link # DIRECTION _ DOWNLOAD } or { @ link # DIRECTION _ UPLOAD } 
 + * @ param direction either { @ link # DIRECTION _ DOWNLOAD } or { @ link # DIRECTION _ UPLOAD } . 
 + * @ param timeout timeout parameter . 
 + * @ param unit timeout unit . 
 + * @ return { @ code true } if the job completed before the timeout was hit , { @ code false } 
 * / 
 - private void waitForChanges ( int direction ) throws InterruptedException { 
 + private boolean waitForChanges ( int direction , long timeout , TimeUnit unit ) throws InterruptedException { 
 if ( direction ! = DIRECTION _ DOWNLOAD & & direction ! = DIRECTION _ UPLOAD ) { 
 throw new IllegalArgumentException ( " Unknown direction : " + direction ) ; 
 } 
 + boolean result = false ; 
 if ( ! isClosed ) { 
 String realmPath = configuration . getPath ( ) ; 
 WaitForSessionWrapper wrapper = new WaitForSessionWrapper ( ) ; 
 @ @ - 565 , 7 + 625 , 7 @ @ public class SyncSession { 
 : nativeWaitForUploadCompletion ( callbackId , realmPath ) ; 
 if ( ! listenerRegistered ) { 
 waitingForServerChanges . set ( null ) ; 
 - String errorMsg = " " ; 
 + String errorMsg ; 
 switch ( direction ) { 
 case DIRECTION _ DOWNLOAD : errorMsg = " It was not possible to download all remote changes . " ; break ; 
 case DIRECTION _ UPLOAD : errorMsg = " It was not possible upload all local changes . " ; break ; 
 @ @ - 576 , 7 + 636 , 7 @ @ public class SyncSession { 
 throw new ObjectServerError ( ErrorCode . UNKNOWN , errorMsg + " Has the SyncClient been started ? " ) ; 
 } 
 try { 
 - wrapper . waitForServerChanges ( ) ; 
 + result = wrapper . waitForServerChanges ( timeout , unit ) ; 
 } catch ( InterruptedException e ) { 
 waitingForServerChanges . set ( null ) ; / / Ignore any results being sent if the wait was interrupted . 
 throw e ; 
 @ @ - 593 , 6 + 653 , 7 @ @ public class SyncSession { 
 waitingForServerChanges . set ( null ) ; 
 } 
 } 
 + return result ; 
 } 
 
 private void checkIfNotOnMainThread ( String errorMessage ) { 
 @ @ - 601 , 6 + 662 , 16 @ @ public class SyncSession { 
 } 
 } 
 
 + private void checkTimeout ( long timeout , TimeUnit unit ) { 
 + if ( timeout < = 0 ) { 
 + throw new IllegalArgumentException ( " ' timeout ' must be > 0 . It was : " + timeout ) ; 
 + } 
 + / / noinspection ConstantConditions 
 + if ( unit = = null ) { 
 + throw new IllegalArgumentException ( " Non - null ' unit ' required " ) ; 
 + } 
 + } 
 + 
 private void checkNonNullListener ( @ Nullable Object listener ) { 
 if ( listener = = null ) { 
 throw new IllegalArgumentException ( " Non - null ' listener ' required . " ) ; 
 @ @ - 844 , 12 + 915 , 14 @ @ public class SyncSession { 
 private String errorMessage ; 
 
 / * * 
 - * Block until the wait either completes or is terminated for other reasons . 
 + * Block until the wait either completes , timeouts or is terminated for other reasons . 
 + * Timeouts are only applied if ` timeout ` > = 0 . 
 * / 
 - public void waitForServerChanges ( ) throws InterruptedException { 
 + public boolean waitForServerChanges ( long timeout , TimeUnit unit ) throws InterruptedException { 
 if ( ! resultReceived ) { 
 - waiter . await ( ) ; 
 + return waiter . await ( timeout , unit ) ; 
 } 
 + return isSuccess ( ) ; 
 } 
 
 / * * 
 diff - - git a / realm / realm - library / src / objectServer / java / io / realm / internal / SyncObjectServerFacade . java b / realm / realm - library / src / objectServer / java / io / realm / internal / SyncObjectServerFacade . java 
 index e16ecd8 . . c9febae 100644 
 - - - a / realm / realm - library / src / objectServer / java / io / realm / internal / SyncObjectServerFacade . java 
 + + + b / realm / realm - library / src / objectServer / java / io / realm / internal / SyncObjectServerFacade . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import java . lang . reflect . InvocationTargetException ; 
 import java . lang . reflect . Method ; 
 import java . util . Arrays ; 
 import java . util . Map ; 
 + import java . util . concurrent . TimeUnit ; 
 
 import io . realm . Realm ; 
 import io . realm . RealmConfiguration ; 
 @ @ - 183 , 14 + 184 , 25 @ @ public class SyncObjectServerFacade extends ObjectServerFacade { 
 if ( syncConfig . shouldWaitForInitialRemoteData ( ) ) { 
 SyncSession session = SyncManager . getSession ( syncConfig ) ; 
 try { 
 + long timeoutMillis = syncConfig . getInitialRemoteDataTimeout ( TimeUnit . MILLISECONDS ) ; 
 if ( ! syncConfig . isFullySynchronizedRealm ( ) ) { 
 / / For Query - based Realms we want to upload all our local changes 
 / / first since those might include subscriptions the server needs to process . 
 - / / This means that once ` downloadAllServerChanges ` completes all 
 - / / initial subscriptions will also have been downloaded . 
 - session . uploadAllLocalChanges ( ) ; 
 + / / This means that once ` downloadAllServerChanges ` completes , all initial 
 + / / subscriptions will also have been downloaded . 
 + / / 
 + / / Note that we are reusing the same timeout for uploading and downloading . 
 + / / This means that in the worst case you end up with 2x the timeout for 
 + / / Query - based Realms . This is probably an acceptable trade - of as trying 
 + / / to expose this would not only complicate the API surface quite a lot , 
 + / / but in most ( almost all ? ) cases the amount of data to upload will be trivial . 
 + if ( ! session . uploadAllLocalChanges ( timeoutMillis , TimeUnit . MILLISECONDS ) ) { 
 + throw new DownloadingRealmInterruptedException ( syncConfig , " Failed to first upload local changes in " + timeoutMillis + " milliseconds " ) ; 
 + } ; 
 + } 
 + if ( ! session . downloadAllServerChanges ( timeoutMillis , TimeUnit . MILLISECONDS ) ) { 
 + throw new DownloadingRealmInterruptedException ( syncConfig , " Failed to download remote changes in " + timeoutMillis + " milliseconds " ) ; 
 } 
 - session . downloadAllServerChanges ( ) ; 
 } catch ( InterruptedException e ) { 
 throw new DownloadingRealmInterruptedException ( syncConfig , e ) ; 
 } 
 diff - - git a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java 
 index 6300954 . . f137814 100644 
 - - - a / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java 
 + + + b / realm / realm - library / src / syncIntegrationTest / java / io / realm / SyncSessionTests . java 
 @ @ - 16 , 10 + 16 , 12 @ @ import java . util . Arrays ; 
 import java . util . List ; 
 import java . util . UUID ; 
 import java . util . concurrent . CountDownLatch ; 
 + import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . atomic . AtomicReference ; 
 
 import io . realm . entities . AllTypes ; 
 import io . realm . entities . StringOnly ; 
 + import io . realm . exceptions . DownloadingRealmInterruptedException ; 
 import io . realm . internal . OsRealmConfig ; 
 import io . realm . log . RealmLog ; 
 import io . realm . objectserver . utils . Constants ; 
 @ @ - 642 , 4 + 644 , 26 @ @ public class SyncSessionTests extends StandardIntegrationTest { 
 looperThread . testComplete ( ) ; 
 } ) ; 
 } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void waitForInitialRemoteData _ throwsOnTimeout ( ) { 
 + SyncUser user = UserFactory . createUniqueUser ( Constants . AUTH _ URL ) ; 
 + SyncConfiguration syncConfiguration = configFactory 
 + . createSyncConfigurationBuilder ( user , Constants . SYNC _ SERVER _ URL ) 
 + . initialData ( bgRealm - > { 
 + for ( int i = 0 ; i < 100 ; i + + ) { 
 + bgRealm . createObject ( AllTypes . class ) ; 
 + } 
 + } ) 
 + . waitForInitialRemoteData ( 1 , TimeUnit . MILLISECONDS ) 
 + . build ( ) ; 
 + 
 + try { 
 + Realm . getInstance ( syncConfiguration ) ; 
 + fail ( " This should have timed out " ) ; 
 + } catch ( DownloadingRealmInterruptedException ignore ) { 
 + } 
 + looperThread . testComplete ( ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index 1912025 . . 4d02c8a 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * Fixed unchecked cast warnings when building with Realm . 
 * Cleaned up examples ( remove old test project ) . 
 * Added checking for missing generic type in RealmList fields in annotation processor . 
 + * Support async queries 
 
 0 . 80 . 3 
 * Calling Realm . copyToRealmOrUpdate ( ) with an object with a null primary key now throws a proper exception . 
 diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 index bb26d54 . . 3cad125 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . cpp 
 @ @ - 14 , 12 + 14 , 14 @ @ 
 * limitations under the License . 
 * / 
 
 + # include < realm / group _ shared . hpp > 
 # include " util . hpp " 
 # include " io _ realm _ internal _ TableQuery . h " 
 # include " tablequery . hpp " 
 
 using namespace realm ; 
 
 + # define SG ( ptr ) reinterpret _ cast < SharedGroup * > ( ptr ) 
 # if 1 
 # define COL _ TYPE _ VALID ( env , ptr , col , type ) TBL _ AND _ COL _ INDEX _ AND _ TYPE _ VALID ( env , ptr , col , type ) 
 # define COL _ TYPE _ LINK _ OR _ LINKLIST ( env , ptr , col ) TBL _ AND _ COL _ INDEX _ AND _ LINK _ OR _ LINKLIST ( env , ptr , col ) 
 @ @ - 1174 , 3 + 1176 , 47 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeIsNull ( 
 pQuery - > and _ query ( query ) ; 
 } CATCH _ STD ( ) 
 } 
 + 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover 
 + ( JNIEnv * env , jobject , jlong callerSharedGrpPtr , jlong bgSharedGroupPtr , jlong nativeQueryPtr , jlong start , jlong end , jlong limit ) 
 + { 
 + Query * pQuery = Q ( nativeQueryPtr ) ; 
 + Table * pTable = pQuery - > get _ table ( ) . get ( ) ; 
 + if ( ! QUERY _ VALID ( env , pQuery ) | | 
 + ! ROW _ INDEXES _ VALID ( env , pTable , start , end , limit ) ) 
 + return - 1 ; 
 + try { 
 + TableView * pResultView = new TableView ( pQuery - > find _ all ( S ( start ) , S ( end ) , S ( limit ) ) ) ; 
 + std : : unique _ ptr < SharedGroup : : Handover < TableView > > handover ; 
 + handover . reset ( SG ( bgSharedGroupPtr ) - > export _ for _ handover ( * pResultView , ConstSourcePayload : : Copy ) ) ; 
 + / / TODO reimplement this so the call to ' export _ for _ handover ' is done on a background thread 
 + / / and ' import _ from _ handover ' on the caller thread . 
 + / / 
 + / / According to core , it ' s preferable to return first the exported handover 
 + / / then import it from the calling SharedGroup ( Thread ) . 
 + / / We need to make sure to check that the version id ( version of the shared group used to perform the query ) 
 + / / is the same as the caller SharedGroup , otherwise the import will fail . In this case , we should 
 + / / either retry the entire query , or call again ' sync _ if _ needed ' on the TableView to re - query , at this point 
 + / / we need to export again the handover to the caller SharedGroup , until we converge 
 + / / ( i . e the version of the caller SharedGroup matches the version returned by the handover TableView ) 
 + / / 
 + / / Note : The mode ' ConstSourcePayload : : Copy ' handover perform a deep copy of the TableView , this means that we copy 
 + / / both the Payload ( row accessors ) & the Query 
 + / / 
 + / / The mode ' ConstSourcePayload : : Stay ' handover perform a copy of the Query only ( no payload ) 
 + / / The mode ' MutableSourcePayload : : Move ' handover perform a move of both the Payload & Query 
 + / / 
 + / / The expensive operations are in that order 
 + / / pQuery - > find _ all > > export _ for _ handover > > import _ from _ handover 
 + / / so it ' s recommended to run the ' query ' & the ' export ' on a background Thread , then 
 + / / call ' import _ from _ handover ' on the caller thread ( most of the time UI thread ) . 
 + / / calling ' import _ from _ handover ' on the UI thread has another benefit , it will block the SharedGroup 
 + / / from modifying it ' s state ( advance _ read , promote _ write , rollback , commit etc ) 
 + / / 
 + / / The handover pointer is Thread safe , it can be passed from different Threads ( using different SharedGroups ) 
 + 
 + TableView * tv ( SG ( callerSharedGrpPtr ) - > import _ from _ handover ( handover . release ( ) ) ) ; 
 + return reinterpret _ cast < jlong > ( tv ) ; 
 + } CATCH _ STD ( ) 
 + return - 1 ; 
 + } 
 diff - - git a / realm - jni / src / io _ realm _ internal _ TableQuery . h b / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 index 5ccb9ee . . 97a9ed7 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 + + + b / realm - jni / src / io _ realm _ internal _ TableQuery . h 
 @ @ - 369 , 6 + 369 , 14 @ @ JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAll 
 
 / * 
 * Class : io _ realm _ internal _ TableQuery 
 + * Method : nativeFindAllWithHandover 
 + * Signature : ( JJJJJJ ) J 
 + * / 
 + JNIEXPORT jlong JNICALL Java _ io _ realm _ internal _ TableQuery _ nativeFindAllWithHandover 
 + ( JNIEnv * , jobject , jlong , jlong , jlong , jlong , jlong , jlong ) ; 
 + 
 + / * 
 + * Class : io _ realm _ internal _ TableQuery 
 * Method : nativeSumInt 
 * Signature : ( JJJJJ ) J 
 * / 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 new file mode 100644 
 index 0000000 . . 162e33a 
 - - - / dev / null 
 + + + b / realm / src / androidTest / java / io / realm / RealmAsyncQueryTests . java 
 @ @ - 0 , 0 + 1 , 151 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm ; 
 + 
 + import android . os . Looper ; 
 + import android . test . InstrumentationTestCase ; 
 + 
 + import junit . framework . AssertionFailedError ; 
 + 
 + import java . util . Date ; 
 + import java . util . concurrent . CountDownLatch ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Executors ; 
 + 
 + import io . realm . entities . AllTypes ; 
 + import io . realm . entities . NonLatinFieldNames ; 
 + 
 + public class RealmAsyncQueryTests extends InstrumentationTestCase { 
 + 
 + / / TODO use Junit4 & define a rule to setup the threading , to avoid 
 + / / this boiler plat code , or use a custom test runner 
 + public void testFindAll ( ) throws Throwable { 
 + / / We need to control precisely which Looper / Thread our Realm 
 + / / will operate on . This is unfortunately not possible when using the 
 + / / current Instrumentation # InstrumentationThread , because InstrumentationTestRunner # onStart 
 + / / Call Looper . prepare ( ) for us and surprisingly doesn ' t call Looper # loop ( ) , this is problematic 
 + / / as the async query callback will not run ( because the Handler is sending Runnables to a Looper 
 + / / that didn ' t loop . 
 + / / 
 + / / In the other hand , using a dedicated ' ExecutorService ' will allow us to fine grain control the 
 + / / desired behaviour 
 + final CountDownLatch signalCallbackFinished = new CountDownLatch ( 1 ) ; 
 + final Looper [ ] looper = new Looper [ 1 ] ; 
 + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 + ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; 
 + executorService . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Looper . prepare ( ) ; 
 + looper [ 0 ] = Looper . myLooper ( ) ; 
 + Realm realm = null ; 
 + try { 
 + realm = openRealmInstance ( ) ; 
 + populateTestRealm ( realm , 10 ) ; 
 + 
 + / / async query ( will run on different thread ) 
 + realm . asyncWhere ( AllTypes . class , 
 + new Realm . AsyncCallback < RealmResults < AllTypes > > ( ) { 
 + @ Override 
 + public void onSuccess ( RealmResults < AllTypes > results ) { 
 + try { 
 + assertEquals ( 10 , results . size ( ) ) ; 
 + 
 + / / Make sure access to RealmObject will not throw an Exception 
 + for ( int i = 0 , size = results . size ( ) ; i < size ; i + + ) { 
 + assertEquals ( i , results . get ( i ) . getColumnLong ( ) ) ; 
 + } 
 + 
 + } catch ( AssertionFailedError e ) { 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + / / whatever happened , make sure to notify the waiting TestCase Thread 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onError ( Throwable t ) { 
 + try { 
 + threadAssertionError [ 0 ] = t ; 
 + t . printStackTrace ( ) ; 
 + } finally { 
 + signalCallbackFinished . countDown ( ) ; 
 + } 
 + } 
 + } ) 
 + . between ( " columnLong " , 0 , 9 ) . findAll ( ) ; 
 + 
 + Looper . loop ( ) ; / / ready to receive callback 
 + 
 + } finally { 
 + if ( realm ! = null ) { 
 + realm . close ( ) ; 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + / / wait until the callback of our async query proceed 
 + signalCallbackFinished . await ( ) ; 
 + looper [ 0 ] . quit ( ) ; 
 + executorService . shutdownNow ( ) ; 
 + if ( null ! = threadAssertionError [ 0 ] ) { 
 + / / Throw any assertion errors happened in the background thread 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + } 
 + 
 + / / * * * Helper methods * * * 
 + 
 + / / This could be done from # setUp but then we can ' t control 
 + / / which Looper we want to associate this Realm instance with 
 + private Realm openRealmInstance ( ) { 
 + RealmConfiguration realmConfiguration = new RealmConfiguration . 
 + Builder ( getInstrumentation ( ) 
 + . getTargetContext ( ) ) 
 + . name ( " test . realm " ) 
 + . deleteRealmIfMigrationNeeded ( ) 
 + . build ( ) ; 
 + Realm . deleteRealm ( realmConfiguration ) ; 
 + return Realm . getInstance ( realmConfiguration ) ; 
 + } 
 + 
 + private void populateTestRealm ( final Realm testRealm , int objects ) { 
 + testRealm . beginTransaction ( ) ; 
 + testRealm . allObjects ( AllTypes . class ) . clear ( ) ; 
 + testRealm . allObjects ( NonLatinFieldNames . class ) . clear ( ) ; 
 + for ( int i = 0 ; i < objects ; + + i ) { 
 + AllTypes allTypes = testRealm . createObject ( AllTypes . class ) ; 
 + allTypes . setColumnBoolean ( ( i % 3 ) = = 0 ) ; 
 + allTypes . setColumnBinary ( new byte [ ] { 1 , 2 , 3 } ) ; 
 + allTypes . setColumnDate ( new Date ( ) ) ; 
 + allTypes . setColumnDouble ( 3 . 1415 ) ; 
 + allTypes . setColumnFloat ( 1 . 234567f + i ) ; 
 + allTypes . setColumnString ( " test data " + i ) ; 
 + allTypes . setColumnLong ( i ) ; 
 + NonLatinFieldNames nonLatinFieldNames = testRealm . createObject ( NonLatinFieldNames . class ) ; 
 + nonLatinFieldNames . set 델 타 ( i ) ; 
 + nonLatinFieldNames . set Δ έ λ τ α ( i ) ; 
 + nonLatinFieldNames . set 베 타 ( 1 . 234567f + i ) ; 
 + nonLatinFieldNames . set Β ή τ α ( 1 . 234567f + i ) ; 
 + } 
 + testRealm . commitTransaction ( ) ; 
 + testRealm . refresh ( ) ; 
 + } 
 + } 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index ca29295 . . d2e5033 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 22 , 7 + 22 , 6 @ @ import org . json . JSONArray ; 
 import org . json . JSONException ; 
 import org . json . JSONObject ; 
 
 - import java . io . ByteArrayInputStream ; 
 import java . io . File ; 
 import java . io . IOException ; 
 import java . io . InputStream ; 
 diff - - git a / realm / src / main / java / io / realm / AsyncRealmQueryResult . java b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java 
 new file mode 100644 
 index 0000000 . . 7318359 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / AsyncRealmQueryResult . java 
 @ @ - 0 , 0 + 1 , 25 @ @ 
 + package io . realm ; 
 + 
 + import java . util . concurrent . Future ; 
 + 
 + / * * 
 + * Represents the result of an asynchronous Realm query . 
 + * 
 + * Users are responsible of maintaining a reference to { @ code AsyncRealmQueryResult } in order 
 + * to call # cancel in case of a configuration change for example ( to avoid memory leak , as the 
 + * query will post the result to the caller ' s thread callback ) 
 + * / 
 + public class AsyncRealmQueryResult { 
 + final Future < ? > pendingQuery ; 
 + 
 + public AsyncRealmQueryResult ( Future < ? > pendingQuery ) { 
 + this . pendingQuery = pendingQuery ; 
 + } 
 + 
 + / * * 
 + * Attempts to cancel execution of this queries . 
 + * / 
 + public void cancel ( ) { 
 + pendingQuery . cancel ( true ) ; 
 + } 
 + } 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index ddbc022 . . 15aac8b 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 63 , 6 + 63 , 7 @ @ import io . realm . internal . SharedGroup ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableView ; 
 import io . realm . internal . Util ; 
 + import io . realm . internal . android . AsyncRealmQuery ; 
 import io . realm . internal . android . DebugAndroidLogger ; 
 import io . realm . internal . android . ReleaseAndroidLogger ; 
 import io . realm . internal . log . RealmLog ; 
 @ @ - 154 , 6 + 155 , 9 @ @ public final class Realm implements Closeable { 
 private static final Map < String , AtomicInteger > globalOpenInstanceCounter = 
 new ConcurrentHashMap < String , AtomicInteger > ( ) ; 
 
 + / / Thread Pool for all async operations ( Query & Write transaction ) 
 + public static final ExecutorService asyncQueryExecutor = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) * 2 + 1 ) ; 
 + 
 protected static final Map < Handler , String > handlers = new ConcurrentHashMap < Handler , String > ( ) ; 
 private static final int REALM _ CHANGED = 14930352 ; / / Hopefully it won ' t clash with other message IDs . 
 
 @ @ - 1198 , 6 + 1202 , 20 @ @ public final class Realm implements Closeable { 
 } 
 
 / * * 
 + * Prepare an async query 
 + * TODO point to documentation or example about async query 
 + * @ param clazz The class of the object which is to be queried for 
 + * @ return A typed RealmQuery , which can be used to query for specific objects of this type 
 + * @ throws java . lang . RuntimeException Any other error 
 + * @ see io . realm . RealmQuery 
 + * @ param callback 
 + * / 
 + public < E extends RealmObject > AsyncRealmQuery < E > asyncWhere ( Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { 
 + checkIfValid ( ) ; 
 + return new AsyncRealmQuery < E > ( this , clazz , callback ) ; 
 + } 
 + 
 + / * * 
 * Get all objects of a specific Class . If no objects exist , the returned RealmResults will not 
 * be null . The RealmResults . size ( ) to check the number of objects instead . 
 * 
 @ @ - 1872 , 4 + 1890 , 24 @ @ public final class Realm implements Closeable { 
 void execute ( Realm realm ) ; 
 } 
 
 + / * * 
 + * Encapsulates an async { @ link RealmQuery } . 
 + * < p > 
 + * This will run the { @ link RealmQuery } on a worker thread , then invoke this callback on the caller thread 
 + * / 
 + public interface AsyncCallback < T extends RealmResults < ? extends RealmObject > > { 
 + void onSuccess ( T results ) ; 
 + void onError ( Throwable t ) ; 
 + } 
 + 
 + 
 + / / FIXME Realm . java being the public API and the implementation . 
 + / / we need a Realm interface to be able to separate this kind of call 
 + / / ( mostly from internal API / tests that need to access private field / method ) . 
 + / / RealmImpl will be accessible to other internal packages 
 + / / but not to the user ( avoid compromising our exposed public API ) 
 + / / 
 + public long getSharedGroupPtr ( ) { 
 + return sharedGroup . nativePtr ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / RealmQuery . java b / realm / src / main / java / io / realm / RealmQuery . java 
 index df847f5 . . b744adc 100644 
 - - - a / realm / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1302 , 4 + 1302 , 8 @ @ public class RealmQuery < E extends RealmObject > { 
 return null ; 
 } 
 } 
 + 
 + protected TableQuery getTableQuery ( ) { 
 + return this . query ; 
 + } 
 } 
 diff - - git a / realm / src / main / java / io / realm / internal / TableQuery . java b / realm / src / main / java / io / realm / internal / TableQuery . java 
 index e82eaa7 . . 268645d 100644 
 - - - a / realm / src / main / java / io / realm / internal / TableQuery . java 
 + + + b / realm / src / main / java / io / realm / internal / TableQuery . java 
 @ @ - 493 , 8 + 493 , 24 @ @ public class TableQuery implements Closeable { 
 } 
 } 
 
 - protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; 
 + public TableView findAllWithHandover ( long callerSharedGroupPtr , long bgSharedGroupPtr ) { 
 + validateQuery ( ) ; 
 + 
 + / / Execute the disposal of abandoned realm objects each time a new realm object is created 
 + context . executeDelayedDisposal ( ) ; 
 + long nativeViewPtr = nativeFindAllWithHandover ( callerSharedGroupPtr , bgSharedGroupPtr , nativePtr , 0 , Table . INFINITE , Table . INFINITE ) ; / / nativeViewPtr is created from bg Thread 
 + / / handover nativeViewPtr to UI Thread 
 + 
 + try { 
 + return new TableView ( this . context , this . parent , nativeViewPtr ) ; 
 + } catch ( RuntimeException e ) { 
 + TableView . nativeClose ( nativeViewPtr ) ; 
 + throw e ; 
 + } 
 + } 
 
 + protected native long nativeFindAll ( long nativeQueryPtr , long start , long end , long limit ) ; 
 + protected native long nativeFindAllWithHandover ( long nativeCallerSharedGroupPtr , long bgSharedGroupPtr , long nativeQueryPtr , long start , long end , long limit ) ; 
 / / 
 / / Aggregation methods 
 / / 
 diff - - git a / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java 
 new file mode 100644 
 index 0000000 . . c3716eb 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / internal / android / AsyncRealmQuery . java 
 @ @ - 0 , 0 + 1 , 165 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . android ; 
 + 
 + import android . os . Handler ; 
 + import android . os . Looper ; 
 + import android . os . Message ; 
 + 
 + import java . util . concurrent . Future ; 
 + 
 + import io . realm . AsyncRealmQueryResult ; 
 + import io . realm . Realm ; 
 + import io . realm . RealmConfiguration ; 
 + import io . realm . RealmObject ; 
 + import io . realm . RealmQuery ; 
 + import io . realm . RealmResults ; 
 + import io . realm . internal . TableOrView ; 
 + import io . realm . internal . TableView ; 
 + 
 + import static io . realm . Realm . asyncQueryExecutor ; 
 + 
 + / * * 
 + * A helper class to help make handling asynchronous { @ link RealmQuery } easier . 
 + * 
 + * @ param < E > type of the object which is to be queried for 
 + * / 
 + / / Behaviour may change , user should not subclass 
 + public final class AsyncRealmQuery < E extends RealmObject > { 
 + private final Realm callerRealm ; 
 + private final Class < E > clazz ; 
 + private final Realm . AsyncCallback < RealmResults < E > > callback ; 
 + 
 + private int from ; 
 + private int to ; 
 + private String fieldName ; 
 + private EventHandler eventHandler ; 
 + private Future < ? > pendingQuery ; 
 + 
 + / * * 
 + * Create an { @ code AsyncRealmQuery } instance . 
 + * 
 + * @ param realm The realm to query within . 
 + * @ param clazz The class to query . 
 + * @ param callback invoked on the thread { @ link Realm # asyncWhere ( Class , Realm . AsyncCallback ) } was called from , to post results . 
 + * / 
 + public AsyncRealmQuery ( Realm realm , Class < E > clazz , Realm . AsyncCallback < RealmResults < E > > callback ) { 
 + this . callerRealm = realm ; 
 + this . callback = callback ; 
 + this . clazz = clazz ; 
 + } 
 + 
 + / * * 
 + * Between condition 
 + * 
 + * @ param fieldName The field to compare 
 + * @ param from Lowest value ( inclusive ) 
 + * @ param to Highest value ( inclusive ) 
 + * @ return current instance of { @ code AsyncRealmQuery } for method chaining 
 + * / 
 + public AsyncRealmQuery < E > between ( String fieldName , int from , int to ) { 
 + this . from = from ; 
 + this . to = to ; 
 + this . fieldName = fieldName ; 
 + return this ; 
 + } 
 + 
 + / * * 
 + * Find all objects that fulfill the query conditions . 
 + * Results will be posted to the callback instance { @ link io . realm . Realm . AsyncCallback } asynchronously 
 + * If no objects match the condition , a list with zero objects is returned . 
 + * 
 + * @ see io . realm . RealmResults 
 + * / 
 + public AsyncRealmQueryResult findAll ( ) { 
 + / / will use the Looper of the caller thread to post the result 
 + Looper looper ; 
 + if ( ( looper = Looper . myLooper ( ) ) ! = null ) { 
 + eventHandler = new EventHandler ( looper ) ; 
 + } else if ( ( looper = Looper . getMainLooper ( ) ) ! = null ) { 
 + eventHandler = new EventHandler ( looper ) ; 
 + } else { 
 + eventHandler = null ; / / FIXME define strategy / behaviour for regular JVM call 
 + } 
 + 
 + / / We need a pointer to the caller Realm , to be able to handover the result to it 
 + final long callerSharedGroupNativePtr = callerRealm . getSharedGroupPtr ( ) ; 
 + 
 + / / We need to use the same configuration to open a background SharedGroup ( i . e Realm ) 
 + / / to perform the query 
 + final RealmConfiguration realmConfiguration = callerRealm . getConfiguration ( ) ; 
 + 
 + pendingQuery = asyncQueryExecutor . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 + try { 
 + Realm bgRealm = Realm . getInstance ( realmConfiguration ) ; 
 + 
 + / / TODO This will probably be replace by a kind of ' QueryBuilder ' 
 + / / that holds all the operations ( predicates / filters ) then 
 + / / replay them here in this background thread . The current implementation 
 + / / call Core for each step , we want to limit the overhead by sending one 
 + / / single call to Core with all the parameters . 
 + 
 + TableView tv = new RealmQueryAdapter < E > ( bgRealm , clazz ) 
 + . between ( fieldName , from , to ) 
 + . findAll ( callerSharedGroupNativePtr , bgRealm . getSharedGroupPtr ( ) ) ; 
 + 
 + bgRealm . close ( ) ; 
 + 
 + / / send results to the caller thread ' s callback 
 + if ( ! pendingQuery . isCancelled ( ) ) { 
 + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ SUCCESS , tv ) ; 
 + eventHandler . sendMessage ( msg ) ; 
 + } 
 + 
 + } catch ( Exception e ) { 
 + if ( ! pendingQuery . isCancelled ( ) ) { 
 + Message msg = eventHandler . obtainMessage ( EventHandler . MSG _ ERROR , e ) ; 
 + eventHandler . sendMessage ( msg ) ; 
 + } 
 + } 
 + } 
 + } 
 + } ) ; 
 + 
 + return new AsyncRealmQueryResult ( pendingQuery ) ; 
 + } 
 + 
 + private class EventHandler extends Handler { 
 + private static final int MSG _ SUCCESS = 1 ; 
 + private static final int MSG _ ERROR = MSG _ SUCCESS + 1 ; 
 + 
 + public EventHandler ( Looper looper ) { 
 + super ( looper ) ; 
 + } 
 + 
 + @ Override 
 + public void handleMessage ( Message msg ) { 
 + switch ( msg . what ) { 
 + case MSG _ SUCCESS : 
 + RealmResults < E > resultList = new RealmResults < E > ( callerRealm , ( TableOrView ) msg . obj , clazz ) ; 
 + callback . onSuccess ( resultList ) ; 
 + break ; 
 + case MSG _ ERROR : 
 + callback . onError ( ( Throwable ) msg . obj ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java 
 new file mode 100644 
 index 0000000 . . acac317 
 - - - / dev / null 
 + + + b / realm / src / main / java / io / realm / internal / android / RealmQueryAdapter . java 
 @ @ - 0 , 0 + 1 , 38 @ @ 
 + / * 
 + * Copyright 2015 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . android ; 
 + 
 + import io . realm . Realm ; 
 + import io . realm . RealmObject ; 
 + import io . realm . RealmQuery ; 
 + import io . realm . internal . TableView ; 
 + 
 + class RealmQueryAdapter < E extends RealmObject > extends RealmQuery < E > { 
 + public RealmQueryAdapter ( Realm realm , Class < E > clazz ) { 
 + super ( realm , clazz ) ; 
 + } 
 + 
 + @ Override 
 + public RealmQueryAdapter < E > between ( String fieldName , int from , int to ) { 
 + super . between ( fieldName , from , to ) ; 
 + return this ; 
 + } 
 + 
 + public TableView findAll ( long callerRealmPtr , long backgroundRealmPtr ) { 
 + return getTableQuery ( ) . findAllWithHandover ( callerRealmPtr , backgroundRealmPtr ) ; 
 + } 
 + }
