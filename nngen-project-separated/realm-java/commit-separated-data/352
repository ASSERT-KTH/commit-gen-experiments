BLEU SCORE: 0.04767707020457096

TEST MSG: Acquire a global ref of jstring for field changes
GENERATED MSG: Extending unit tests of removeFromRealm ( )

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / ObjectChangeSetTests . java b / realm / realm - library / src / androidTest / java / io / realm / ObjectChangeSetTests . java <nl> index 942e7cb . . c36aef4 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / ObjectChangeSetTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / ObjectChangeSetTests . java <nl> @ @ - 337 , 4 + 337 , 38 @ @ public class ObjectChangeSetTests { <nl> allTypes . deleteFromRealm ( ) ; <nl> realm . commitTransaction ( ) ; <nl> } <nl> + <nl> + / / When there are more than 512 fields change , the JNI local ref table size limitation may be reached . <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void moreFieldsChangedThanLocalRefTableSize ( ) { <nl> + final String CLASS _ NAME = " ManyFields " ; <nl> + final int FIELD _ COUNT = 1024 ; <nl> + RealmConfiguration config = looperThread . createConfiguration ( " many _ fields " ) ; <nl> + final DynamicRealm realm = DynamicRealm . getInstance ( config ) ; <nl> + <nl> + realm . beginTransaction ( ) ; <nl> + RealmSchema schema = realm . getSchema ( ) ; <nl> + RealmObjectSchema objectSchema = schema . create ( CLASS _ NAME ) ; <nl> + for ( int i = 0 ; i < FIELD _ COUNT ; i + + ) { <nl> + objectSchema . addField ( " field " + i , int . class ) ; <nl> + } <nl> + DynamicRealmObject obj = realm . createObject ( CLASS _ NAME ) ; <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + obj . addChangeListener ( new RealmObjectChangeListener < DynamicRealmObject > ( ) { <nl> + @ Override <nl> + public void onChange ( DynamicRealmObject object , ObjectChangeSet changeSet ) { <nl> + assertEquals ( FIELD _ COUNT , changeSet . getChangedFields ( ) . length ) ; <nl> + realm . close ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + realm . beginTransaction ( ) ; <nl> + for ( int i = 0 ; i < FIELD _ COUNT ; i + + ) { <nl> + obj . setInt ( " field " + i , 42 ) ; <nl> + } <nl> + realm . commitTransaction ( ) ; <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ OsObject . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ OsObject . cpp <nl> index abe2e66 . . c35c042 100644 <nl> - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ OsObject . cpp <nl> + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ OsObject . cpp <nl> @ @ - 70 , 7 + 70 , 8 @ @ struct ChangeCallback { <nl> return ; <nl> } <nl> <nl> - std : : vector < jstring > field _ names ; <nl> + / / The local ref of jstring needs to be released to avoid reach the local ref table size limitation . <nl> + std : : vector < JavaGlobalRef > field _ names ; <nl> auto table = m _ wrapper - > m _ object . row ( ) . get _ table ( ) ; <nl> for ( size _ t i = 0 ; i < change _ set . columns . size ( ) ; + + i ) { <nl> if ( change _ set . columns [ i ] . empty ( ) ) { <nl> @ @ - 78 , 11 + 79 , 11 @ @ struct ChangeCallback { <nl> } <nl> / / FIXME : After full integration of the OS schema , parse the column name from <nl> / / wrapper - > m _ object . get _ object _ schema ( ) will be faster . <nl> - field _ names . push _ back ( to _ jstring ( env , table - > get _ column _ name ( i ) ) ) ; <nl> + field _ names . push _ back ( JavaGlobalRef ( env , to _ jstring ( env , table - > get _ column _ name ( i ) ) , true ) ) ; <nl> } <nl> m _ field _ names _ array = env - > NewObjectArray ( field _ names . size ( ) , java _ lang _ string , 0 ) ; <nl> for ( size _ t i = 0 ; i < field _ names . size ( ) ; + + i ) { <nl> - env - > SetObjectArrayElement ( m _ field _ names _ array , i , field _ names [ i ] ) ; <nl> + env - > SetObjectArrayElement ( m _ field _ names _ array , i , field _ names [ i ] . get ( ) ) ; <nl> } <nl> } <nl> <nl> diff - - git a / realm / realm - library / src / main / cpp / jni _ util / java _ global _ ref . hpp b / realm / realm - library / src / main / cpp / jni _ util / java _ global _ ref . hpp <nl> index a08aad4 . . f2d0c33 100644 <nl> - - - a / realm / realm - library / src / main / cpp / jni _ util / java _ global _ ref . hpp <nl> + + + b / realm / realm - library / src / main / cpp / jni _ util / java _ global _ ref . hpp <nl> @ @ - 29 , 9 + 29 , 13 @ @ public : <nl> : m _ ref ( nullptr ) <nl> { <nl> } <nl> - JavaGlobalRef ( JNIEnv * env , jobject obj ) <nl> + / / Acquire a global ref on the given jobject . The local ref will be released if given release _ local _ ref is true . <nl> + JavaGlobalRef ( JNIEnv * env , jobject obj , bool release _ local _ ref = false ) <nl> : m _ ref ( obj ? env - > NewGlobalRef ( obj ) : nullptr ) <nl> { <nl> + if ( release _ local _ ref ) { <nl> + env - > DeleteLocalRef ( obj ) ; <nl> + } <nl> } <nl> JavaGlobalRef ( JavaGlobalRef & & rhs ) <nl> : m _ ref ( rhs . m _ ref )
NEAREST DIFF (one line): diff - - git a / changelog . txt b / changelog . txt <nl> index d1f2f3d . . b309c58 100644 <nl> - - - a / changelog . txt <nl> + + + b / changelog . txt <nl> @ @ - 1 , 6 + 1 , 7 @ @ <nl> 0 . 75 . 0 ( ? ? ) <nl> * Bug fixed in Exception text when field names was not matching the database <nl> - <nl> + * Bug fixed in the JNI call to core ' s move _ last _ over ( ) so removing last object doesn ' t throw an exception <nl> + <nl> 0 . 74 . 0 ( 19 Nov 2014 ) <nl> * Added support for more field / accessors naming conventions <nl> * Allow static methods in model classes <nl> diff - - git a / realm - jni / src / io _ realm _ internal _ table . cpp b / realm - jni / src / io _ realm _ internal _ table . cpp <nl> index f8c3d4b . . 1b62914 100644 <nl> - - - a / realm - jni / src / io _ realm _ internal _ table . cpp <nl> + + + b / realm - jni / src / io _ realm _ internal _ table . cpp <nl> @ @ - 295 , 7 + 295 , 7 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeRemoveLast ( <nl> JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeMoveLastOver <nl> ( JNIEnv * env , jobject , jlong nativeTablePtr , jlong rowIndex ) <nl> { <nl> - if ( ! TBL _ AND _ ROW _ INDEX _ VALID _ OFFSET ( env , TBL ( nativeTablePtr ) , rowIndex , true ) ) <nl> + if ( ! TBL _ AND _ ROW _ INDEX _ VALID _ OFFSET ( env , TBL ( nativeTablePtr ) , rowIndex , false ) ) <nl> return ; <nl> try { <nl> TBL ( nativeTablePtr ) - > move _ last _ over ( S ( rowIndex ) ) ; <nl> diff - - git a / realm - jni / src / util . hpp b / realm - jni / src / util . hpp <nl> index 750d51d . . 3ab6f68 100644 <nl> - - - a / realm - jni / src / util . hpp <nl> + + + b / realm - jni / src / util . hpp <nl> @ @ - 267 , 7 + 267 , 7 @ @ bool RowIndexesValid ( JNIEnv * env , T * pTable , jlong startIndex , jlong endIndex , j <nl> template < class T > <nl> inline bool RowIndexValid ( JNIEnv * env , T * pTable , jlong rowIndex , bool offset = false ) <nl> { <nl> - if ( rowIndex < 0 ) { <nl> + if ( rowIndex < 0 ) { <nl> ThrowException ( env , IndexOutOfBounds , " rowIndex is less than 0 . " ) ; <nl> return false ; <nl> } <nl> diff - - git a / realm / src / androidTest / java / io / realm / RealmObjectTest . java b / realm / src / androidTest / java / io / realm / RealmObjectTest . java <nl> index ed66882 . . f5617a2 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmObjectTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmObjectTest . java <nl> @ @ - 18 , 6 + 18 , 8 @ @ package io . realm ; <nl> <nl> import android . test . AndroidTestCase ; <nl> <nl> + import java . util . HashSet ; <nl> + import java . util . Set ; <nl> import java . util . concurrent . Callable ; <nl> import java . util . concurrent . ExecutionException ; <nl> import java . util . concurrent . ExecutorService ; <nl> @ @ - 33 , 6 + 35 , 8 @ @ public class RealmObjectTest extends AndroidTestCase { <nl> <nl> protected Realm testRealm ; <nl> <nl> + private int TEST _ SIZE = 5 ; <nl> + <nl> @ Override <nl> protected void setUp ( ) throws Exception { <nl> Realm . deleteRealmFile ( getContext ( ) ) ; <nl> @ @ - 77 , 6 + 81 , 7 @ @ public class RealmObjectTest extends AndroidTestCase { <nl> } <nl> } <nl> <nl> + / / removing original object and see if has been removed <nl> public void testRemoveFromRealm ( ) { <nl> Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> realm . beginTransaction ( ) ; <nl> @ @ - 111 , 6 + 116 , 86 @ @ public class RealmObjectTest extends AndroidTestCase { <nl> realm . commitTransaction ( ) ; <nl> } <nl> <nl> + / / query for an object , remove it and see it has been removed from realm <nl> + public void testRemoveResultFromRealm ( ) { <nl> + Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> + realm . beginTransaction ( ) ; <nl> + realm . clear ( Dog . class ) ; <nl> + Dog dogToAdd = realm . createObject ( Dog . class ) ; <nl> + dogToAdd . setName ( " Rex " ) ; <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + assertEquals ( 1 , realm . allObjects ( Dog . class ) . size ( ) ) ; <nl> + <nl> + Dog dogToRemove = realm . where ( Dog . class ) . findFirst ( ) ; <nl> + assertNotNull ( dogToRemove ) ; <nl> + realm . beginTransaction ( ) ; <nl> + dogToRemove . removeFromRealm ( ) ; <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + assertEquals ( 0 , realm . allObjects ( Dog . class ) . size ( ) ) ; <nl> + try { <nl> + dogToAdd . getName ( ) ; <nl> + fail ( ) ; <nl> + } <nl> + catch ( IllegalStateException ignored ) { } <nl> + try { <nl> + dogToRemove . getName ( ) ; <nl> + fail ( ) ; <nl> + } <nl> + catch ( IllegalStateException ignored ) { } <nl> + } <nl> + <nl> + / / remove object in the middle <nl> + <nl> + / / remove all objects - one by one <nl> + public void removeFromRealmAt ( boolean atTop ) { <nl> + Set < Long > ages = new HashSet < Long > ( ) ; <nl> + testRealm . beginTransaction ( ) ; <nl> + for ( int i = 0 ; i < TEST _ SIZE ; i + + ) { <nl> + Dog dog = testRealm . createObject ( Dog . class ) ; <nl> + dog . setAge ( i ) ; <nl> + ages . add ( new Long ( i ) ) ; <nl> + } <nl> + testRealm . commitTransaction ( ) ; <nl> + <nl> + assertEquals ( TEST _ SIZE , testRealm . allObjects ( Dog . class ) . size ( ) ) ; <nl> + <nl> + RealmResults < Dog > dogs = testRealm . allObjects ( Dog . class ) ; <nl> + for ( int i = 0 ; i < TEST _ SIZE ; i + + ) { <nl> + testRealm . beginTransaction ( ) ; <nl> + Dog dogToRemove ; <nl> + if ( atTop ) { <nl> + dogToRemove = dogs . first ( ) ; <nl> + } else { <nl> + dogToRemove = dogs . last ( ) ; <nl> + } <nl> + ages . remove ( new Long ( dogToRemove . getAge ( ) ) ) ; <nl> + dogToRemove . removeFromRealm ( ) ; <nl> + <nl> + / / object is no longer valid <nl> + try { <nl> + dogToRemove . getAge ( ) ; <nl> + fail ( ) ; <nl> + } <nl> + catch ( IllegalStateException ignored ) { } <nl> + <nl> + testRealm . commitTransaction ( ) ; <nl> + <nl> + / / and removed from realm and remaining objects are place correctly <nl> + RealmResults < Dog > remainingDogs = testRealm . allObjects ( Dog . class ) ; <nl> + assertEquals ( TEST _ SIZE - i - 1 , remainingDogs . size ( ) ) ; <nl> + for ( Dog dog : remainingDogs ) { <nl> + assertTrue ( ages . contains ( new Long ( dog . getAge ( ) ) ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public void testRemoveRealmAt ( ) { <nl> + removeFromRealmAt ( true ) ; / / first <nl> + removeFromRealmAt ( false ) ; / / last <nl> + } <nl> + <nl> public boolean methodWrongThread ( final boolean callGetter ) throws ExecutionException , InterruptedException { <nl> Realm realm = Realm . getInstance ( getContext ( ) ) ; <nl> realm . beginTransaction ( ) ; <nl> diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java <nl> index 8ad15c3 . . 7440282 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / Table . java <nl> + + + b / realm / src / main / java / io / realm / internal / Table . java <nl> @ @ - 364 , 9 + 364 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { <nl> <nl> protected native void nativeRemoveLast ( long nativeTablePtr ) ; <nl> <nl> - / * * <nl> - * EXPERIMENTAL function <nl> - * / <nl> public void moveLastOver ( long rowIndex ) { <nl> checkImmutable ( ) ; <nl> nativeMoveLastOver ( nativePtr , rowIndex ) ;

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / ObjectChangeSetTests . java b / realm / realm - library / src / androidTest / java / io / realm / ObjectChangeSetTests . java 
 index 942e7cb . . c36aef4 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / ObjectChangeSetTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / ObjectChangeSetTests . java 
 @ @ - 337 , 4 + 337 , 38 @ @ public class ObjectChangeSetTests { 
 allTypes . deleteFromRealm ( ) ; 
 realm . commitTransaction ( ) ; 
 } 
 + 
 + / / When there are more than 512 fields change , the JNI local ref table size limitation may be reached . 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void moreFieldsChangedThanLocalRefTableSize ( ) { 
 + final String CLASS _ NAME = " ManyFields " ; 
 + final int FIELD _ COUNT = 1024 ; 
 + RealmConfiguration config = looperThread . createConfiguration ( " many _ fields " ) ; 
 + final DynamicRealm realm = DynamicRealm . getInstance ( config ) ; 
 + 
 + realm . beginTransaction ( ) ; 
 + RealmSchema schema = realm . getSchema ( ) ; 
 + RealmObjectSchema objectSchema = schema . create ( CLASS _ NAME ) ; 
 + for ( int i = 0 ; i < FIELD _ COUNT ; i + + ) { 
 + objectSchema . addField ( " field " + i , int . class ) ; 
 + } 
 + DynamicRealmObject obj = realm . createObject ( CLASS _ NAME ) ; 
 + realm . commitTransaction ( ) ; 
 + 
 + obj . addChangeListener ( new RealmObjectChangeListener < DynamicRealmObject > ( ) { 
 + @ Override 
 + public void onChange ( DynamicRealmObject object , ObjectChangeSet changeSet ) { 
 + assertEquals ( FIELD _ COUNT , changeSet . getChangedFields ( ) . length ) ; 
 + realm . close ( ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + 
 + realm . beginTransaction ( ) ; 
 + for ( int i = 0 ; i < FIELD _ COUNT ; i + + ) { 
 + obj . setInt ( " field " + i , 42 ) ; 
 + } 
 + realm . commitTransaction ( ) ; 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ OsObject . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ OsObject . cpp 
 index abe2e66 . . c35c042 100644 
 - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ OsObject . cpp 
 + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ OsObject . cpp 
 @ @ - 70 , 7 + 70 , 8 @ @ struct ChangeCallback { 
 return ; 
 } 
 
 - std : : vector < jstring > field _ names ; 
 + / / The local ref of jstring needs to be released to avoid reach the local ref table size limitation . 
 + std : : vector < JavaGlobalRef > field _ names ; 
 auto table = m _ wrapper - > m _ object . row ( ) . get _ table ( ) ; 
 for ( size _ t i = 0 ; i < change _ set . columns . size ( ) ; + + i ) { 
 if ( change _ set . columns [ i ] . empty ( ) ) { 
 @ @ - 78 , 11 + 79 , 11 @ @ struct ChangeCallback { 
 } 
 / / FIXME : After full integration of the OS schema , parse the column name from 
 / / wrapper - > m _ object . get _ object _ schema ( ) will be faster . 
 - field _ names . push _ back ( to _ jstring ( env , table - > get _ column _ name ( i ) ) ) ; 
 + field _ names . push _ back ( JavaGlobalRef ( env , to _ jstring ( env , table - > get _ column _ name ( i ) ) , true ) ) ; 
 } 
 m _ field _ names _ array = env - > NewObjectArray ( field _ names . size ( ) , java _ lang _ string , 0 ) ; 
 for ( size _ t i = 0 ; i < field _ names . size ( ) ; + + i ) { 
 - env - > SetObjectArrayElement ( m _ field _ names _ array , i , field _ names [ i ] ) ; 
 + env - > SetObjectArrayElement ( m _ field _ names _ array , i , field _ names [ i ] . get ( ) ) ; 
 } 
 } 
 
 diff - - git a / realm / realm - library / src / main / cpp / jni _ util / java _ global _ ref . hpp b / realm / realm - library / src / main / cpp / jni _ util / java _ global _ ref . hpp 
 index a08aad4 . . f2d0c33 100644 
 - - - a / realm / realm - library / src / main / cpp / jni _ util / java _ global _ ref . hpp 
 + + + b / realm / realm - library / src / main / cpp / jni _ util / java _ global _ ref . hpp 
 @ @ - 29 , 9 + 29 , 13 @ @ public : 
 : m _ ref ( nullptr ) 
 { 
 } 
 - JavaGlobalRef ( JNIEnv * env , jobject obj ) 
 + / / Acquire a global ref on the given jobject . The local ref will be released if given release _ local _ ref is true . 
 + JavaGlobalRef ( JNIEnv * env , jobject obj , bool release _ local _ ref = false ) 
 : m _ ref ( obj ? env - > NewGlobalRef ( obj ) : nullptr ) 
 { 
 + if ( release _ local _ ref ) { 
 + env - > DeleteLocalRef ( obj ) ; 
 + } 
 } 
 JavaGlobalRef ( JavaGlobalRef & & rhs ) 
 : m _ ref ( rhs . m _ ref )

NEAREST DIFF:
diff - - git a / changelog . txt b / changelog . txt 
 index d1f2f3d . . b309c58 100644 
 - - - a / changelog . txt 
 + + + b / changelog . txt 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 0 . 75 . 0 ( ? ? ) 
 * Bug fixed in Exception text when field names was not matching the database 
 - 
 + * Bug fixed in the JNI call to core ' s move _ last _ over ( ) so removing last object doesn ' t throw an exception 
 + 
 0 . 74 . 0 ( 19 Nov 2014 ) 
 * Added support for more field / accessors naming conventions 
 * Allow static methods in model classes 
 diff - - git a / realm - jni / src / io _ realm _ internal _ table . cpp b / realm - jni / src / io _ realm _ internal _ table . cpp 
 index f8c3d4b . . 1b62914 100644 
 - - - a / realm - jni / src / io _ realm _ internal _ table . cpp 
 + + + b / realm - jni / src / io _ realm _ internal _ table . cpp 
 @ @ - 295 , 7 + 295 , 7 @ @ JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeRemoveLast ( 
 JNIEXPORT void JNICALL Java _ io _ realm _ internal _ Table _ nativeMoveLastOver 
 ( JNIEnv * env , jobject , jlong nativeTablePtr , jlong rowIndex ) 
 { 
 - if ( ! TBL _ AND _ ROW _ INDEX _ VALID _ OFFSET ( env , TBL ( nativeTablePtr ) , rowIndex , true ) ) 
 + if ( ! TBL _ AND _ ROW _ INDEX _ VALID _ OFFSET ( env , TBL ( nativeTablePtr ) , rowIndex , false ) ) 
 return ; 
 try { 
 TBL ( nativeTablePtr ) - > move _ last _ over ( S ( rowIndex ) ) ; 
 diff - - git a / realm - jni / src / util . hpp b / realm - jni / src / util . hpp 
 index 750d51d . . 3ab6f68 100644 
 - - - a / realm - jni / src / util . hpp 
 + + + b / realm - jni / src / util . hpp 
 @ @ - 267 , 7 + 267 , 7 @ @ bool RowIndexesValid ( JNIEnv * env , T * pTable , jlong startIndex , jlong endIndex , j 
 template < class T > 
 inline bool RowIndexValid ( JNIEnv * env , T * pTable , jlong rowIndex , bool offset = false ) 
 { 
 - if ( rowIndex < 0 ) { 
 + if ( rowIndex < 0 ) { 
 ThrowException ( env , IndexOutOfBounds , " rowIndex is less than 0 . " ) ; 
 return false ; 
 } 
 diff - - git a / realm / src / androidTest / java / io / realm / RealmObjectTest . java b / realm / src / androidTest / java / io / realm / RealmObjectTest . java 
 index ed66882 . . f5617a2 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmObjectTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmObjectTest . java 
 @ @ - 18 , 6 + 18 , 8 @ @ package io . realm ; 
 
 import android . test . AndroidTestCase ; 
 
 + import java . util . HashSet ; 
 + import java . util . Set ; 
 import java . util . concurrent . Callable ; 
 import java . util . concurrent . ExecutionException ; 
 import java . util . concurrent . ExecutorService ; 
 @ @ - 33 , 6 + 35 , 8 @ @ public class RealmObjectTest extends AndroidTestCase { 
 
 protected Realm testRealm ; 
 
 + private int TEST _ SIZE = 5 ; 
 + 
 @ Override 
 protected void setUp ( ) throws Exception { 
 Realm . deleteRealmFile ( getContext ( ) ) ; 
 @ @ - 77 , 6 + 81 , 7 @ @ public class RealmObjectTest extends AndroidTestCase { 
 } 
 } 
 
 + / / removing original object and see if has been removed 
 public void testRemoveFromRealm ( ) { 
 Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 realm . beginTransaction ( ) ; 
 @ @ - 111 , 6 + 116 , 86 @ @ public class RealmObjectTest extends AndroidTestCase { 
 realm . commitTransaction ( ) ; 
 } 
 
 + / / query for an object , remove it and see it has been removed from realm 
 + public void testRemoveResultFromRealm ( ) { 
 + Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 + realm . beginTransaction ( ) ; 
 + realm . clear ( Dog . class ) ; 
 + Dog dogToAdd = realm . createObject ( Dog . class ) ; 
 + dogToAdd . setName ( " Rex " ) ; 
 + realm . commitTransaction ( ) ; 
 + 
 + assertEquals ( 1 , realm . allObjects ( Dog . class ) . size ( ) ) ; 
 + 
 + Dog dogToRemove = realm . where ( Dog . class ) . findFirst ( ) ; 
 + assertNotNull ( dogToRemove ) ; 
 + realm . beginTransaction ( ) ; 
 + dogToRemove . removeFromRealm ( ) ; 
 + realm . commitTransaction ( ) ; 
 + 
 + assertEquals ( 0 , realm . allObjects ( Dog . class ) . size ( ) ) ; 
 + try { 
 + dogToAdd . getName ( ) ; 
 + fail ( ) ; 
 + } 
 + catch ( IllegalStateException ignored ) { } 
 + try { 
 + dogToRemove . getName ( ) ; 
 + fail ( ) ; 
 + } 
 + catch ( IllegalStateException ignored ) { } 
 + } 
 + 
 + / / remove object in the middle 
 + 
 + / / remove all objects - one by one 
 + public void removeFromRealmAt ( boolean atTop ) { 
 + Set < Long > ages = new HashSet < Long > ( ) ; 
 + testRealm . beginTransaction ( ) ; 
 + for ( int i = 0 ; i < TEST _ SIZE ; i + + ) { 
 + Dog dog = testRealm . createObject ( Dog . class ) ; 
 + dog . setAge ( i ) ; 
 + ages . add ( new Long ( i ) ) ; 
 + } 
 + testRealm . commitTransaction ( ) ; 
 + 
 + assertEquals ( TEST _ SIZE , testRealm . allObjects ( Dog . class ) . size ( ) ) ; 
 + 
 + RealmResults < Dog > dogs = testRealm . allObjects ( Dog . class ) ; 
 + for ( int i = 0 ; i < TEST _ SIZE ; i + + ) { 
 + testRealm . beginTransaction ( ) ; 
 + Dog dogToRemove ; 
 + if ( atTop ) { 
 + dogToRemove = dogs . first ( ) ; 
 + } else { 
 + dogToRemove = dogs . last ( ) ; 
 + } 
 + ages . remove ( new Long ( dogToRemove . getAge ( ) ) ) ; 
 + dogToRemove . removeFromRealm ( ) ; 
 + 
 + / / object is no longer valid 
 + try { 
 + dogToRemove . getAge ( ) ; 
 + fail ( ) ; 
 + } 
 + catch ( IllegalStateException ignored ) { } 
 + 
 + testRealm . commitTransaction ( ) ; 
 + 
 + / / and removed from realm and remaining objects are place correctly 
 + RealmResults < Dog > remainingDogs = testRealm . allObjects ( Dog . class ) ; 
 + assertEquals ( TEST _ SIZE - i - 1 , remainingDogs . size ( ) ) ; 
 + for ( Dog dog : remainingDogs ) { 
 + assertTrue ( ages . contains ( new Long ( dog . getAge ( ) ) ) ) ; 
 + } 
 + } 
 + } 
 + 
 + public void testRemoveRealmAt ( ) { 
 + removeFromRealmAt ( true ) ; / / first 
 + removeFromRealmAt ( false ) ; / / last 
 + } 
 + 
 public boolean methodWrongThread ( final boolean callGetter ) throws ExecutionException , InterruptedException { 
 Realm realm = Realm . getInstance ( getContext ( ) ) ; 
 realm . beginTransaction ( ) ; 
 diff - - git a / realm / src / main / java / io / realm / internal / Table . java b / realm / src / main / java / io / realm / internal / Table . java 
 index 8ad15c3 . . 7440282 100644 
 - - - a / realm / src / main / java / io / realm / internal / Table . java 
 + + + b / realm / src / main / java / io / realm / internal / Table . java 
 @ @ - 364 , 9 + 364 , 6 @ @ public class Table implements TableOrView , TableSchema , Closeable { 
 
 protected native void nativeRemoveLast ( long nativeTablePtr ) ; 
 
 - / * * 
 - * EXPERIMENTAL function 
 - * / 
 public void moveLastOver ( long rowIndex ) { 
 checkImmutable ( ) ; 
 nativeMoveLastOver ( nativePtr , rowIndex ) ;
