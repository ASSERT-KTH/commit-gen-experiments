BLEU SCORE: 0.10682175159905853

TEST MSG: Accessor of PendingRow should throw
GENERATED MSG: Add PendingRow to suport findFirst

TEST DIFF (one line): diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> index 799bbea . . 13cde56 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> @ @ - 57 , 6 + 57 , 10 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> } <nl> <nl> public Row getRow $ realm ( ) { <nl> + if ( row instanceof PendingRow ) { <nl> + row = ( ( PendingRow ) row ) . executeQuery ( ) ; <nl> + registerToRowNotifier ( ) ; <nl> + } <nl> return row ; <nl> } <nl> <nl> @ @ - 87 , 9 + 91 , 9 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> / * * <nl> * Notifies all registered listeners . <nl> * / <nl> - void notifyChangeListeners $ realm ( ) { <nl> + private void notifyChangeListeners ( ) { <nl> if ( ! listeners . isEmpty ( ) ) { <nl> - for ( RealmChangeListener listener : listeners ) { <nl> + for ( RealmChangeListener < E > listener : listeners ) { <nl> listener . onChange ( model ) ; <nl> } <nl> } <nl> @ @ - 99 , 12 + 103 , 14 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> if ( ! listeners . contains ( listener ) ) { <nl> listeners . add ( listener ) ; <nl> } <nl> + / / this might be called after query returns . So it is still necessary to register . <nl> if ( row instanceof UncheckedRow ) { <nl> RowNotifier rowNotifier = realm . sharedRealm . rowNotifier ; <nl> + / / RowNotifier will take care of the duplicated ObserverPairs <nl> rowNotifier . registerListener ( ( UncheckedRow ) row , this , new RealmChangeListener < ProxyState < E > > ( ) { <nl> @ Override <nl> public void onChange ( ProxyState < E > proxyState ) { <nl> - proxyState . notifyChangeListeners $ realm ( ) ; <nl> + proxyState . notifyChangeListeners ( ) ; <nl> } <nl> } ) ; <nl> } <nl> @ @ - 126 , 22 + 132 , 26 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> excludeFields = null ; <nl> } <nl> <nl> - @ Override <nl> - public void onQueryFinished ( Row row , boolean asyncQuery ) { <nl> - this . row = row ; <nl> - if ( asyncQuery ) { <nl> - notifyChangeListeners $ realm ( ) ; <nl> + private void registerToRowNotifier ( ) { <nl> + RowNotifier rowNotifier = realm . sharedRealm . rowNotifier ; <nl> + if ( row . isAttached ( ) ) { <nl> + rowNotifier . registerListener ( ( UncheckedRow ) row , this , new RealmChangeListener < ProxyState < E > > ( ) { <nl> + @ Override <nl> + public void onChange ( ProxyState < E > proxyState ) { <nl> + proxyState . notifyChangeListeners ( ) ; <nl> + } <nl> + } ) ; <nl> } <nl> - / / FIXME : Figure out why this can be null . <nl> - if ( realm . sharedRealm = = null ) { <nl> + } <nl> + <nl> + @ Override <nl> + public void onQueryFinished ( Row row ) { <nl> + if ( realm . sharedRealm = = null | | realm . sharedRealm . isClosed ( ) ) { <nl> return ; <nl> } <nl> - RowNotifier rowNotifier = realm . sharedRealm . rowNotifier ; <nl> - rowNotifier . registerListener ( ( UncheckedRow ) row , this , new RealmChangeListener < ProxyState < E > > ( ) { <nl> - @ Override <nl> - public void onChange ( ProxyState < E > proxyState ) { <nl> - proxyState . notifyChangeListeners $ realm ( ) ; <nl> - } <nl> - } ) ; <nl> + <nl> + this . row = row ; <nl> + notifyChangeListeners ( ) ; <nl> + registerToRowNotifier ( ) ; <nl> } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> index 172215f . . 3dbd0d1 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> @ @ - 8 , 23 + 8 , 22 @ @ import io . realm . RealmFieldType ; <nl> <nl> / * * <nl> * A PendingRow is a row relies on a pending async query . <nl> - * Before the query returns , calling any accessors will immediately execute the query and call the corresponding <nl> - * accessor on the query result . If the query results is empty , an { @ link IllegalStateException } will be thrown . <nl> - * After the query returns , { @ link FrontEnd # onQueryFinished ( Row , boolean ) } will be called to give the front end a <nl> - * chance to reset the row . If the async query returns an empty result , the query will be executed again later until a <nl> - * valid row is contained by the query results . <nl> + * Before the query returns , calling any accessors will immediately throw . In this case run { @ link # executeQuery ( ) } to <nl> + * get the queried row immediately . If the query results is empty , an { @ link InvalidRow } will be returned . <nl> + * After the query returns , { @ link FrontEnd # onQueryFinished ( Row ) } will be called to give the front end a chance to reset <nl> + * the row . If the async query returns an empty result , the query will be executed again later until a valid row is <nl> + * contained by the query results . <nl> * / <nl> public class PendingRow implements Row { <nl> <nl> / / Implement this interface to reset the PendingRow to a Row backed by real data when query returned . <nl> public interface FrontEnd { <nl> - / / When asyncQuery is true , the pending query is executed asynchronously . Otherwise the query is triggered by <nl> - / / calling any accessors before the async query returns . <nl> - void onQueryFinished ( Row row , boolean asyncQuery ) ; <nl> + / / When asyncQuery is true , the pending query is executed asynchronously . <nl> + void onQueryFinished ( Row row ) ; <nl> } <nl> <nl> - private static final String EMPTY _ ROW _ MESSAGE = <nl> - " This RealmObject is empty . There isn ' t any objects match the query . " ; <nl> + private static final String QUERY _ NOT _ RETURNED _ MESSAGE = <nl> + " The pending query has not been executed . " ; <nl> private static final String PROXY _ NOT _ SET _ MESSAGE = " The ' frontEnd ' has not been set . " ; <nl> private static final String QUERY _ EXECUTED _ MESSAGE = <nl> " The query has been executed . This ' PendingRow ' is not valid anymore . " ; <nl> @ @ - 44 , 18 + 43 , 19 @ @ public class PendingRow implements Row { <nl> if ( frontEnd = = null ) { <nl> throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> } <nl> - / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . <nl> if ( frontEnd . get ( ) = = null ) { <nl> / / The front end is GCed . <nl> clearPendingCollection ( ) ; <nl> return ; <nl> } <nl> + <nl> + / / PendingRow will always get the first Row of the query since we only support findFirst . <nl> UncheckedRow uncheckedRow = pendingCollection . firstUncheckedRow ( ) ; <nl> / / If no rows returned by the query , just wait for the query updates until it returns a valid row . <nl> if ( uncheckedRow ! = null ) { <nl> Row row = returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; <nl> / / Ask the front end to reset the row and stop async query . <nl> - frontEnd . get ( ) . onQueryFinished ( row , true ) ; <nl> + frontEnd . get ( ) . onQueryFinished ( row ) ; <nl> clearPendingCollection ( ) ; <nl> } <nl> } <nl> @ @ - 71 , 147 + 71 , 147 @ @ public class PendingRow implements Row { <nl> <nl> @ Override <nl> public long getColumnCount ( ) { <nl> - return executeQuery ( ) . getColumnCount ( ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public String getColumnName ( long columnIndex ) { <nl> - return executeQuery ( ) . getColumnName ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public long getColumnIndex ( String columnName ) { <nl> - return executeQuery ( ) . getColumnIndex ( columnName ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public RealmFieldType getColumnType ( long columnIndex ) { <nl> - return executeQuery ( ) . getColumnType ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public Table getTable ( ) { <nl> - return executeQuery ( ) . getTable ( ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public long getIndex ( ) { <nl> - return executeQuery ( ) . getIndex ( ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public long getLong ( long columnIndex ) { <nl> - return executeQuery ( ) . getLong ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public boolean getBoolean ( long columnIndex ) { <nl> - return executeQuery ( ) . getBoolean ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public float getFloat ( long columnIndex ) { <nl> - return executeQuery ( ) . getFloat ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public double getDouble ( long columnIndex ) { <nl> - return executeQuery ( ) . getDouble ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public Date getDate ( long columnIndex ) { <nl> - return executeQuery ( ) . getDate ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public String getString ( long columnIndex ) { <nl> - return executeQuery ( ) . getString ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public byte [ ] getBinaryByteArray ( long columnIndex ) { <nl> - return executeQuery ( ) . getBinaryByteArray ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public long getLink ( long columnIndex ) { <nl> - return executeQuery ( ) . getLink ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public boolean isNullLink ( long columnIndex ) { <nl> - return executeQuery ( ) . isNullLink ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public LinkView getLinkList ( long columnIndex ) { <nl> - return executeQuery ( ) . getLinkList ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void setLong ( long columnIndex , long value ) { <nl> - executeQuery ( ) . setLong ( columnIndex , value ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void setBoolean ( long columnIndex , boolean value ) { <nl> - executeQuery ( ) . setBoolean ( columnIndex , value ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void setFloat ( long columnIndex , float value ) { <nl> - executeQuery ( ) . setFloat ( columnIndex , value ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void setDouble ( long columnIndex , double value ) { <nl> - executeQuery ( ) . setDouble ( columnIndex , value ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void setDate ( long columnIndex , Date date ) { <nl> - executeQuery ( ) . setDate ( columnIndex , date ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void setString ( long columnIndex , String value ) { <nl> - executeQuery ( ) . setString ( columnIndex , value ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void setBinaryByteArray ( long columnIndex , byte [ ] data ) { <nl> - executeQuery ( ) . setBinaryByteArray ( columnIndex , data ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void setLink ( long columnIndex , long value ) { <nl> - executeQuery ( ) . setLink ( columnIndex , value ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void nullifyLink ( long columnIndex ) { <nl> - executeQuery ( ) . nullifyLink ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public boolean isNull ( long columnIndex ) { <nl> - return executeQuery ( ) . isNull ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public void setNull ( long columnIndex ) { <nl> - executeQuery ( ) . setNull ( columnIndex ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public boolean isAttached ( ) { <nl> - return executeQuery ( ) . isAttached ( ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> @ Override <nl> public boolean hasColumn ( String fieldName ) { <nl> - return executeQuery ( ) . hasColumn ( fieldName ) ; <nl> + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; <nl> } <nl> <nl> private void clearPendingCollection ( ) { <nl> @ @ - 220 , 22 + 220 , 20 @ @ public class PendingRow implements Row { <nl> listener = null ; <nl> } <nl> <nl> - private Row executeQuery ( ) { <nl> + public Row executeQuery ( ) { <nl> if ( pendingCollection = = null ) { <nl> throw new IllegalStateException ( QUERY _ EXECUTED _ MESSAGE ) ; <nl> } <nl> if ( frontEnd = = null ) { <nl> throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> } <nl> + <nl> UncheckedRow uncheckedRow = pendingCollection . firstUncheckedRow ( ) ; <nl> + clearPendingCollection ( ) ; <nl> + <nl> if ( uncheckedRow = = null ) { <nl> - throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; <nl> - } <nl> - Row row = returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; <nl> - if ( frontEnd . get ( ) ! = null ) { <nl> - frontEnd . get ( ) . onQueryFinished ( row , false ) ; <nl> + return InvalidRow . INSTANCE ; <nl> } <nl> - clearPendingCollection ( ) ; <nl> - return row ; <nl> + return returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / realm / realm - library / src / main / java / io / realm / HandlerController . java b / realm / realm - library / src / main / java / io / realm / HandlerController . java <nl> index 134ead5 . . 752fdc1 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / HandlerController . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / HandlerController . java <nl> @ @ - 298 , 7 + 298 , 7 @ @ final class HandlerController implements Handler . Callback { <nl> * @ param realmResultsToBeNotified list of all RealmResults listeners that can be notified . <nl> * / <nl> void notifyAllListeners ( List < RealmResults < ? extends RealmModel > > realmResultsToBeNotified ) { <nl> - <nl> + / * <nl> / / Notify all RealmResults ( async and synchronous ) . <nl> for ( Iterator < RealmResults < ? extends RealmModel > > it = realmResultsToBeNotified . iterator ( ) ; ! realm . isClosed ( ) & & it . hasNext ( ) ; ) { <nl> RealmResults < ? extends RealmModel > realmResults = it . next ( ) ; <nl> @ @ - 320 , 6 + 320 , 7 @ @ final class HandlerController implements Handler . Callback { <nl> / / Trigger global listeners last . <nl> / / Note that NotificationTest . callingOrdersOfListeners will fail if orders change . <nl> notifyGlobalListeners ( ) ; <nl> + * / <nl> } <nl> <nl> private void collectAsyncRealmResultsCallbacks ( List < RealmResults < ? extends RealmModel > > resultsToBeNotified ) { <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> index af3d807 . . 3e67066 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ import java . util . List ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . Future ; <nl> <nl> + import io . realm . internal . PendingRow ; <nl> import io . realm . internal . Row ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableQuery ; <nl> @ @ - 29 , 7 + 30 , 7 @ @ import io . realm . log . RealmLog ; <nl> * This implements { @ code RealmObjectProxy } interface , to eliminate copying logic between <nl> * { @ link RealmObject } and { @ link DynamicRealmObject } . <nl> * / <nl> - public final class ProxyState < E extends RealmModel > { <nl> + public final class ProxyState < E extends RealmModel > implements PendingRow . FrontEnd { <nl> private E model ; <nl> private String className ; <nl> private Class < ? extends RealmModel > clazzName ; <nl> @ @ - 163 , 27 + 164 , 8 @ @ public final class ProxyState < E extends RealmModel > { <nl> * / <nl> void notifyChangeListeners $ realm ( ) { <nl> if ( ! listeners . isEmpty ( ) ) { <nl> - boolean notify = false ; <nl> - <nl> - Table table = row . getTable ( ) ; <nl> - if ( table = = null ) { <nl> - / / Completed async queries might result in ` table = = null ` , ` isCompleted = = true ` and ` row = = Row . EMPTY _ ROW ` <nl> - / / We still want to trigger change notifications for these cases . <nl> - / / isLoaded / isValid should be considered properties on RealmObjects as well so any change to these <nl> - / / should trigger a RealmChangeListener . <nl> - notify = true ; <nl> - } else { <nl> - long version = table . getVersion ( ) ; <nl> - if ( currentTableVersion ! = version ) { <nl> - currentTableVersion = version ; <nl> - notify = true ; <nl> - } <nl> - } <nl> - <nl> - if ( notify ) { <nl> - for ( RealmChangeListener listener : listeners ) { <nl> - listener . onChange ( model ) ; <nl> - } <nl> + for ( RealmChangeListener listener : listeners ) { <nl> + listener . onChange ( model ) ; <nl> } <nl> } <nl> } <nl> @ @ - 219 , 4 + 201 , 12 @ @ public final class ProxyState < E extends RealmModel > { <nl> realm . checkIfValid ( ) ; <nl> return getPendingQuery $ realm ( ) = = null | | isCompleted $ realm ( ) ; <nl> } <nl> + <nl> + @ Override <nl> + public void onQueryFinished ( Row row , boolean asyncQuery ) { <nl> + this . row = row ; <nl> + if ( asyncQuery ) { <nl> + notifyChangeListeners $ realm ( ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> index 281fa7d . . 0e20605 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 21 , 22 + 21 , 19 @ @ import java . lang . ref . WeakReference ; <nl> import java . util . Collections ; <nl> import java . util . Date ; <nl> import java . util . Locale ; <nl> - import java . util . concurrent . Callable ; <nl> - import java . util . concurrent . Future ; <nl> <nl> import io . realm . annotations . Required ; <nl> import io . realm . internal . Collection ; <nl> import io . realm . internal . LinkView ; <nl> + import io . realm . internal . PendingRow ; <nl> import io . realm . internal . RealmNotifier ; <nl> import io . realm . internal . RealmObjectProxy ; <nl> - import io . realm . internal . Row ; <nl> import io . realm . internal . SharedRealm ; <nl> import io . realm . internal . SortDescriptor ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableQuery ; <nl> import io . realm . internal . async . ArgumentsHolder ; <nl> import io . realm . internal . async . QueryUpdateTask ; <nl> - import io . realm . log . RealmLog ; <nl> <nl> / * * <nl> * A RealmQuery encapsulates a query on a { @ link io . realm . Realm } or a { @ link io . realm . RealmResults } using the Builder <nl> @ @ - 1649 , 98 + 1646 , 36 @ @ public final class RealmQuery < E extends RealmModel > { <nl> * / <nl> public E findFirst ( ) { <nl> checkQueryIsNotReused ( ) ; <nl> - long tableRowIndex = getSourceRowIndexForFirstObject ( ) ; <nl> - if ( tableRowIndex > = 0 ) { <nl> - E realmObject = realm . get ( clazz , className , tableRowIndex ) ; <nl> - return realmObject ; <nl> - } else { <nl> - return null ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Similar to { @ link # findFirst ( ) } but runs asynchronously on a worker thread <nl> - * This method is only available from a Looper thread . <nl> - * <nl> - * @ return immediately an empty { @ link RealmObject } . Trying to access any field on the returned object <nl> - * before it is loaded will throw an { @ code IllegalStateException } . Use { @ link RealmObject # isLoaded ( ) } to check if <nl> - * the object is fully loaded or register a listener { @ link io . realm . RealmObject # addChangeListener } <nl> - * to be notified when the query completes . If no RealmObject was found after the query completed , the returned <nl> - * RealmObject will have { @ link RealmObject # isLoaded ( ) } set to { @ code true } and { @ link RealmObject # isValid ( ) } set to <nl> - * { @ code false } . <nl> - * / <nl> - public E findFirstAsync ( ) { <nl> - checkQueryIsNotReused ( ) ; <nl> - final WeakReference < RealmNotifier > weakNotifier = getWeakReferenceNotifier ( ) ; <nl> - <nl> - / / handover the query ( to be used by a worker thread ) <nl> - final long handoverQueryPointer = query . handoverQuery ( realm . sharedRealm ) ; <nl> - <nl> - / / save query arguments ( for future update ) <nl> - argumentsHolder = new ArgumentsHolder ( ArgumentsHolder . TYPE _ FIND _ FIRST ) ; <nl> - <nl> - final RealmConfiguration realmConfiguration = realm . getConfiguration ( ) ; <nl> <nl> + / / TODO : The performance by the pending query will be a little bit worse than directly calling core ' s <nl> + / / Query . find ( ) . The overhead comes with core needs to add all the row indices to the vector . However this can <nl> + / / be optimized by adding support of limit in OS ' s Results which is supported by core already . <nl> + PendingRow pendingRow = new PendingRow ( realm . sharedRealm , query , null ) ; <nl> / / prepare an empty reference of the RealmObject , so we can return it immediately ( promise ) <nl> / / then update it once the query complete in the background . <nl> final E result ; <nl> if ( isDynamicQuery ( ) ) { <nl> / / noinspection unchecked <nl> - result = ( E ) new DynamicRealmObject ( className , realm , Row . EMPTY _ ROW ) ; <nl> + result = ( E ) new DynamicRealmObject ( className , realm , pendingRow ) ; <nl> } else { <nl> result = realm . getConfiguration ( ) . getSchemaMediator ( ) . newInstance ( <nl> - clazz , realm , Row . EMPTY _ ROW , realm . getSchema ( ) . getColumnInfo ( clazz ) , <nl> + clazz , realm , pendingRow , realm . getSchema ( ) . getColumnInfo ( clazz ) , <nl> false , Collections . < String > emptyList ( ) ) ; <nl> } <nl> <nl> final RealmObjectProxy proxy = ( RealmObjectProxy ) result ; <nl> - final WeakReference < RealmObjectProxy > realmObjectWeakReference = realm . handlerController . addToAsyncRealmObject ( proxy , this ) ; <nl> - <nl> - final Future < Long > pendingQuery = Realm . asyncTaskExecutor . submitQuery ( new Callable < Long > ( ) { <nl> - @ Override <nl> - public Long call ( ) throws Exception { <nl> - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> - SharedRealm sharedRealm = null ; <nl> - <nl> - try { <nl> - sharedRealm = SharedRealm . getInstance ( realmConfiguration ) ; <nl> - <nl> - long handoverRowPointer = TableQuery . findWithHandover ( sharedRealm , handoverQueryPointer ) ; <nl> - if ( handoverRowPointer = = 0 ) { / / empty row <nl> - realm . handlerController . addToEmptyAsyncRealmObject ( realmObjectWeakReference , RealmQuery . this ) ; <nl> - realm . handlerController . removeFromAsyncRealmObject ( realmObjectWeakReference ) ; <nl> - } <nl> - <nl> - QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmObjectResponse ( ) ; <nl> - result . updatedRow . put ( realmObjectWeakReference , handoverRowPointer ) ; <nl> - result . versionID = sharedRealm . getVersionID ( ) ; <nl> - closeSharedRealmAndSendEventToNotifier ( sharedRealm , <nl> - weakNotifier , QueryUpdateTask . NotifyEvent . COMPLETE _ ASYNC _ OBJECT , result ) ; <nl> - <nl> - return handoverRowPointer ; <nl> - <nl> - } catch ( Throwable e ) { <nl> - RealmLog . error ( e ) ; <nl> - / / handler can ' t throw a checked exception need to wrap it into unchecked Exception <nl> - closeSharedRealmAndSendEventToNotifier ( sharedRealm , <nl> - weakNotifier , QueryUpdateTask . NotifyEvent . THROW _ BACKGROUND _ EXCEPTION , e ) ; <nl> - } finally { <nl> - if ( sharedRealm ! = null & & ! sharedRealm . isClosed ( ) ) { <nl> - sharedRealm . close ( ) ; <nl> - } <nl> - } <nl> - } else { <nl> - TableQuery . nativeCloseQueryHandover ( handoverQueryPointer ) ; <nl> - } <nl> - <nl> - return INVALID _ NATIVE _ POINTER ; <nl> - } <nl> - } ) ; <nl> - proxy . realmGet $ proxyState ( ) . setPendingQuery $ realm ( pendingQuery ) ; <nl> + pendingRow . setFrontEnd ( proxy . realmGet $ proxyState ( ) ) ; <nl> <nl> return result ; <nl> } <nl> <nl> + / * * <nl> + * @ deprecated use { @ link # findFirst ( ) } instead . <nl> + * / <nl> + public E findFirstAsync ( ) { <nl> + return findFirst ( ) ; <nl> + } <nl> + <nl> private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { <nl> if ( fieldNames = = null ) { <nl> throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> index 25fcf2c . . 3f24caf 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> @ @ - 1 , 8 + 1 , 235 @ @ <nl> package io . realm . internal ; <nl> <nl> + import java . lang . ref . WeakReference ; <nl> + import java . util . Date ; <nl> + <nl> + import io . realm . RealmChangeListener ; <nl> + import io . realm . RealmFieldType ; <nl> + <nl> / * * <nl> - * Created by cc on 16 - 11 - 30 . <nl> + * A PendingRow is a row relies on a pending async query . <nl> + * Before the query returns , calling any accessors will immediately execute the query and call the corresponding <nl> + * accessor on the query result . If the query results is empty , an { @ link IllegalStateException } will be thrown . <nl> + * After the query returns , { @ link FrontEnd # onQueryFinished ( Row , boolean ) } will be called to give the front end a <nl> + * chance to reset the row . If the async query returns an empty result , the query will be executed again later until a <nl> + * valid row is contained by the query results . <nl> * / <nl> - <nl> public class PendingRow implements Row { <nl> + <nl> + / / Implement this interface to reset the PendingRow to a Row backed by real data when query returned . <nl> + public interface FrontEnd { <nl> + / / When asyncQuery is true , the pending query is executed asynchronously . Otherwise the query is triggered by <nl> + / / calling any accessors before the async query returns . <nl> + void onQueryFinished ( Row row , boolean asyncQuery ) ; <nl> + } <nl> + <nl> + private static final String EMPTY _ ROW _ MESSAGE = <nl> + " This RealmObject is empty . There isn ' t any objects match the query . " ; <nl> + private static final String PROXY _ NOT _ SET _ MESSAGE = " The ' frontEnd ' has not been set . " ; <nl> + private static final String QUERY _ EXECUTED _ MESSAGE = <nl> + " The query has been executed . This ' PendingRow ' is not valid anymore . " ; <nl> + <nl> + private Collection pendingCollection ; <nl> + private Collection . Listener listener ; <nl> + private WeakReference < FrontEnd > frontEnd ; <nl> + <nl> + public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { <nl> + pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; <nl> + listener = new Collection . Listener ( new RealmChangeListener < PendingRow > ( ) { <nl> + @ Override <nl> + public void onChange ( PendingRow pendingRow ) { <nl> + if ( frontEnd = = null ) { <nl> + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> + } <nl> + / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . <nl> + Row row = pendingCollection . firstUncheckedRow ( ) ; <nl> + if ( frontEnd . get ( ) = = null ) { <nl> + / / The front end is GCed . <nl> + clearPendingCollection ( ) ; <nl> + return ; <nl> + } <nl> + / / If no rows returned by the query , just wait for the query updates until it returns a valid row . <nl> + if ( row ! = null ) { <nl> + / / Ask the front end to reset the row and stop async query . <nl> + frontEnd . get ( ) . onQueryFinished ( row , true ) ; <nl> + clearPendingCollection ( ) ; <nl> + } <nl> + } <nl> + } , this ) ; <nl> + pendingCollection . addListener ( listener ) ; <nl> + } <nl> + <nl> + / / To set the front end of this PendingRow . <nl> + public void setFrontEnd ( FrontEnd frontEnd ) { <nl> + this . frontEnd = new WeakReference < FrontEnd > ( frontEnd ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getColumnCount ( ) { <nl> + return executeQuery ( ) . getColumnCount ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getColumnName ( long columnIndex ) { <nl> + return executeQuery ( ) . getColumnName ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getColumnIndex ( String columnName ) { <nl> + return executeQuery ( ) . getColumnIndex ( columnName ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public RealmFieldType getColumnType ( long columnIndex ) { <nl> + return executeQuery ( ) . getColumnType ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Table getTable ( ) { <nl> + return executeQuery ( ) . getTable ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getIndex ( ) { <nl> + return executeQuery ( ) . getIndex ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getLong ( long columnIndex ) { <nl> + return executeQuery ( ) . getLong ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean getBoolean ( long columnIndex ) { <nl> + return executeQuery ( ) . getBoolean ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public float getFloat ( long columnIndex ) { <nl> + return executeQuery ( ) . getFloat ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public double getDouble ( long columnIndex ) { <nl> + return executeQuery ( ) . getDouble ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Date getDate ( long columnIndex ) { <nl> + return executeQuery ( ) . getDate ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getString ( long columnIndex ) { <nl> + return executeQuery ( ) . getString ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public byte [ ] getBinaryByteArray ( long columnIndex ) { <nl> + return executeQuery ( ) . getBinaryByteArray ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getLink ( long columnIndex ) { <nl> + return executeQuery ( ) . getLink ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isNullLink ( long columnIndex ) { <nl> + return executeQuery ( ) . isNullLink ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public LinkView getLinkList ( long columnIndex ) { <nl> + return executeQuery ( ) . getLinkList ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setLong ( long columnIndex , long value ) { <nl> + executeQuery ( ) . setLong ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setBoolean ( long columnIndex , boolean value ) { <nl> + executeQuery ( ) . setBoolean ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setFloat ( long columnIndex , float value ) { <nl> + executeQuery ( ) . setFloat ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setDouble ( long columnIndex , double value ) { <nl> + executeQuery ( ) . setDouble ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setDate ( long columnIndex , Date date ) { <nl> + executeQuery ( ) . setDate ( columnIndex , date ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setString ( long columnIndex , String value ) { <nl> + executeQuery ( ) . setString ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setBinaryByteArray ( long columnIndex , byte [ ] data ) { <nl> + executeQuery ( ) . setBinaryByteArray ( columnIndex , data ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setLink ( long columnIndex , long value ) { <nl> + executeQuery ( ) . setLink ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void nullifyLink ( long columnIndex ) { <nl> + executeQuery ( ) . nullifyLink ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isNull ( long columnIndex ) { <nl> + return executeQuery ( ) . isNull ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setNull ( long columnIndex ) { <nl> + executeQuery ( ) . setNull ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isAttached ( ) { <nl> + return executeQuery ( ) . isAttached ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasColumn ( String fieldName ) { <nl> + return executeQuery ( ) . hasColumn ( fieldName ) ; <nl> + } <nl> + <nl> + private void clearPendingCollection ( ) { <nl> + pendingCollection . removeListener ( listener ) ; <nl> + pendingCollection = null ; <nl> + listener = null ; <nl> + } <nl> + <nl> + private Row executeQuery ( ) { <nl> + if ( pendingCollection = = null ) { <nl> + throw new IllegalStateException ( QUERY _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + if ( frontEnd = = null ) { <nl> + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> + } <nl> + Row row = pendingCollection . getUncheckedRow ( 0 ) ; <nl> + if ( row = = null ) { <nl> + throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; <nl> + } <nl> + if ( frontEnd . get ( ) ! = null ) { <nl> + frontEnd . get ( ) . onQueryFinished ( pendingCollection . firstUncheckedRow ( ) , false ) ; <nl> + } <nl> + clearPendingCollection ( ) ; <nl> + return row ; <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java <nl> index 7802428 . . 5b5b441 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java <nl> @ @ - 89 , 8 + 89 , 10 @ @ public class UncheckedRow implements NativeObject , Row { <nl> <nl> / / FIXME : Testing code <nl> public static UncheckedRow getByRowPointer ( Table table , long nativeRowPointer ) { <nl> - UncheckedRow row = new UncheckedRow ( table . context , table , nativeRowPointer ) ; <nl> - return row ; <nl> + if ( nativeRowPointer ! = 0 ) { <nl> + return new UncheckedRow ( table . context , table , nativeRowPointer ) ; <nl> + } <nl> + return null ; <nl> } <nl> <nl> / * *

TEST DIFF:
diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 index 799bbea . . 13cde56 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 @ @ - 57 , 6 + 57 , 10 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 } 
 
 public Row getRow $ realm ( ) { 
 + if ( row instanceof PendingRow ) { 
 + row = ( ( PendingRow ) row ) . executeQuery ( ) ; 
 + registerToRowNotifier ( ) ; 
 + } 
 return row ; 
 } 
 
 @ @ - 87 , 9 + 91 , 9 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 / * * 
 * Notifies all registered listeners . 
 * / 
 - void notifyChangeListeners $ realm ( ) { 
 + private void notifyChangeListeners ( ) { 
 if ( ! listeners . isEmpty ( ) ) { 
 - for ( RealmChangeListener listener : listeners ) { 
 + for ( RealmChangeListener < E > listener : listeners ) { 
 listener . onChange ( model ) ; 
 } 
 } 
 @ @ - 99 , 12 + 103 , 14 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 if ( ! listeners . contains ( listener ) ) { 
 listeners . add ( listener ) ; 
 } 
 + / / this might be called after query returns . So it is still necessary to register . 
 if ( row instanceof UncheckedRow ) { 
 RowNotifier rowNotifier = realm . sharedRealm . rowNotifier ; 
 + / / RowNotifier will take care of the duplicated ObserverPairs 
 rowNotifier . registerListener ( ( UncheckedRow ) row , this , new RealmChangeListener < ProxyState < E > > ( ) { 
 @ Override 
 public void onChange ( ProxyState < E > proxyState ) { 
 - proxyState . notifyChangeListeners $ realm ( ) ; 
 + proxyState . notifyChangeListeners ( ) ; 
 } 
 } ) ; 
 } 
 @ @ - 126 , 22 + 132 , 26 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 excludeFields = null ; 
 } 
 
 - @ Override 
 - public void onQueryFinished ( Row row , boolean asyncQuery ) { 
 - this . row = row ; 
 - if ( asyncQuery ) { 
 - notifyChangeListeners $ realm ( ) ; 
 + private void registerToRowNotifier ( ) { 
 + RowNotifier rowNotifier = realm . sharedRealm . rowNotifier ; 
 + if ( row . isAttached ( ) ) { 
 + rowNotifier . registerListener ( ( UncheckedRow ) row , this , new RealmChangeListener < ProxyState < E > > ( ) { 
 + @ Override 
 + public void onChange ( ProxyState < E > proxyState ) { 
 + proxyState . notifyChangeListeners ( ) ; 
 + } 
 + } ) ; 
 } 
 - / / FIXME : Figure out why this can be null . 
 - if ( realm . sharedRealm = = null ) { 
 + } 
 + 
 + @ Override 
 + public void onQueryFinished ( Row row ) { 
 + if ( realm . sharedRealm = = null | | realm . sharedRealm . isClosed ( ) ) { 
 return ; 
 } 
 - RowNotifier rowNotifier = realm . sharedRealm . rowNotifier ; 
 - rowNotifier . registerListener ( ( UncheckedRow ) row , this , new RealmChangeListener < ProxyState < E > > ( ) { 
 - @ Override 
 - public void onChange ( ProxyState < E > proxyState ) { 
 - proxyState . notifyChangeListeners $ realm ( ) ; 
 - } 
 - } ) ; 
 + 
 + this . row = row ; 
 + notifyChangeListeners ( ) ; 
 + registerToRowNotifier ( ) ; 
 } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 index 172215f . . 3dbd0d1 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 @ @ - 8 , 23 + 8 , 22 @ @ import io . realm . RealmFieldType ; 
 
 / * * 
 * A PendingRow is a row relies on a pending async query . 
 - * Before the query returns , calling any accessors will immediately execute the query and call the corresponding 
 - * accessor on the query result . If the query results is empty , an { @ link IllegalStateException } will be thrown . 
 - * After the query returns , { @ link FrontEnd # onQueryFinished ( Row , boolean ) } will be called to give the front end a 
 - * chance to reset the row . If the async query returns an empty result , the query will be executed again later until a 
 - * valid row is contained by the query results . 
 + * Before the query returns , calling any accessors will immediately throw . In this case run { @ link # executeQuery ( ) } to 
 + * get the queried row immediately . If the query results is empty , an { @ link InvalidRow } will be returned . 
 + * After the query returns , { @ link FrontEnd # onQueryFinished ( Row ) } will be called to give the front end a chance to reset 
 + * the row . If the async query returns an empty result , the query will be executed again later until a valid row is 
 + * contained by the query results . 
 * / 
 public class PendingRow implements Row { 
 
 / / Implement this interface to reset the PendingRow to a Row backed by real data when query returned . 
 public interface FrontEnd { 
 - / / When asyncQuery is true , the pending query is executed asynchronously . Otherwise the query is triggered by 
 - / / calling any accessors before the async query returns . 
 - void onQueryFinished ( Row row , boolean asyncQuery ) ; 
 + / / When asyncQuery is true , the pending query is executed asynchronously . 
 + void onQueryFinished ( Row row ) ; 
 } 
 
 - private static final String EMPTY _ ROW _ MESSAGE = 
 - " This RealmObject is empty . There isn ' t any objects match the query . " ; 
 + private static final String QUERY _ NOT _ RETURNED _ MESSAGE = 
 + " The pending query has not been executed . " ; 
 private static final String PROXY _ NOT _ SET _ MESSAGE = " The ' frontEnd ' has not been set . " ; 
 private static final String QUERY _ EXECUTED _ MESSAGE = 
 " The query has been executed . This ' PendingRow ' is not valid anymore . " ; 
 @ @ - 44 , 18 + 43 , 19 @ @ public class PendingRow implements Row { 
 if ( frontEnd = = null ) { 
 throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 } 
 - / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . 
 if ( frontEnd . get ( ) = = null ) { 
 / / The front end is GCed . 
 clearPendingCollection ( ) ; 
 return ; 
 } 
 + 
 + / / PendingRow will always get the first Row of the query since we only support findFirst . 
 UncheckedRow uncheckedRow = pendingCollection . firstUncheckedRow ( ) ; 
 / / If no rows returned by the query , just wait for the query updates until it returns a valid row . 
 if ( uncheckedRow ! = null ) { 
 Row row = returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; 
 / / Ask the front end to reset the row and stop async query . 
 - frontEnd . get ( ) . onQueryFinished ( row , true ) ; 
 + frontEnd . get ( ) . onQueryFinished ( row ) ; 
 clearPendingCollection ( ) ; 
 } 
 } 
 @ @ - 71 , 147 + 71 , 147 @ @ public class PendingRow implements Row { 
 
 @ Override 
 public long getColumnCount ( ) { 
 - return executeQuery ( ) . getColumnCount ( ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public String getColumnName ( long columnIndex ) { 
 - return executeQuery ( ) . getColumnName ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public long getColumnIndex ( String columnName ) { 
 - return executeQuery ( ) . getColumnIndex ( columnName ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public RealmFieldType getColumnType ( long columnIndex ) { 
 - return executeQuery ( ) . getColumnType ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public Table getTable ( ) { 
 - return executeQuery ( ) . getTable ( ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public long getIndex ( ) { 
 - return executeQuery ( ) . getIndex ( ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public long getLong ( long columnIndex ) { 
 - return executeQuery ( ) . getLong ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public boolean getBoolean ( long columnIndex ) { 
 - return executeQuery ( ) . getBoolean ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public float getFloat ( long columnIndex ) { 
 - return executeQuery ( ) . getFloat ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public double getDouble ( long columnIndex ) { 
 - return executeQuery ( ) . getDouble ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public Date getDate ( long columnIndex ) { 
 - return executeQuery ( ) . getDate ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public String getString ( long columnIndex ) { 
 - return executeQuery ( ) . getString ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public byte [ ] getBinaryByteArray ( long columnIndex ) { 
 - return executeQuery ( ) . getBinaryByteArray ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public long getLink ( long columnIndex ) { 
 - return executeQuery ( ) . getLink ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public boolean isNullLink ( long columnIndex ) { 
 - return executeQuery ( ) . isNullLink ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public LinkView getLinkList ( long columnIndex ) { 
 - return executeQuery ( ) . getLinkList ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void setLong ( long columnIndex , long value ) { 
 - executeQuery ( ) . setLong ( columnIndex , value ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void setBoolean ( long columnIndex , boolean value ) { 
 - executeQuery ( ) . setBoolean ( columnIndex , value ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void setFloat ( long columnIndex , float value ) { 
 - executeQuery ( ) . setFloat ( columnIndex , value ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void setDouble ( long columnIndex , double value ) { 
 - executeQuery ( ) . setDouble ( columnIndex , value ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void setDate ( long columnIndex , Date date ) { 
 - executeQuery ( ) . setDate ( columnIndex , date ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void setString ( long columnIndex , String value ) { 
 - executeQuery ( ) . setString ( columnIndex , value ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void setBinaryByteArray ( long columnIndex , byte [ ] data ) { 
 - executeQuery ( ) . setBinaryByteArray ( columnIndex , data ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void setLink ( long columnIndex , long value ) { 
 - executeQuery ( ) . setLink ( columnIndex , value ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void nullifyLink ( long columnIndex ) { 
 - executeQuery ( ) . nullifyLink ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public boolean isNull ( long columnIndex ) { 
 - return executeQuery ( ) . isNull ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public void setNull ( long columnIndex ) { 
 - executeQuery ( ) . setNull ( columnIndex ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public boolean isAttached ( ) { 
 - return executeQuery ( ) . isAttached ( ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 @ Override 
 public boolean hasColumn ( String fieldName ) { 
 - return executeQuery ( ) . hasColumn ( fieldName ) ; 
 + throw new IllegalStateException ( QUERY _ NOT _ RETURNED _ MESSAGE ) ; 
 } 
 
 private void clearPendingCollection ( ) { 
 @ @ - 220 , 22 + 220 , 20 @ @ public class PendingRow implements Row { 
 listener = null ; 
 } 
 
 - private Row executeQuery ( ) { 
 + public Row executeQuery ( ) { 
 if ( pendingCollection = = null ) { 
 throw new IllegalStateException ( QUERY _ EXECUTED _ MESSAGE ) ; 
 } 
 if ( frontEnd = = null ) { 
 throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 } 
 + 
 UncheckedRow uncheckedRow = pendingCollection . firstUncheckedRow ( ) ; 
 + clearPendingCollection ( ) ; 
 + 
 if ( uncheckedRow = = null ) { 
 - throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; 
 - } 
 - Row row = returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; 
 - if ( frontEnd . get ( ) ! = null ) { 
 - frontEnd . get ( ) . onQueryFinished ( row , false ) ; 
 + return InvalidRow . INSTANCE ; 
 } 
 - clearPendingCollection ( ) ; 
 - return row ; 
 + return returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; 
 } 
 }

NEAREST DIFF:
diff - - git a / realm / realm - library / src / main / java / io / realm / HandlerController . java b / realm / realm - library / src / main / java / io / realm / HandlerController . java 
 index 134ead5 . . 752fdc1 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / HandlerController . java 
 + + + b / realm / realm - library / src / main / java / io / realm / HandlerController . java 
 @ @ - 298 , 7 + 298 , 7 @ @ final class HandlerController implements Handler . Callback { 
 * @ param realmResultsToBeNotified list of all RealmResults listeners that can be notified . 
 * / 
 void notifyAllListeners ( List < RealmResults < ? extends RealmModel > > realmResultsToBeNotified ) { 
 - 
 + / * 
 / / Notify all RealmResults ( async and synchronous ) . 
 for ( Iterator < RealmResults < ? extends RealmModel > > it = realmResultsToBeNotified . iterator ( ) ; ! realm . isClosed ( ) & & it . hasNext ( ) ; ) { 
 RealmResults < ? extends RealmModel > realmResults = it . next ( ) ; 
 @ @ - 320 , 6 + 320 , 7 @ @ final class HandlerController implements Handler . Callback { 
 / / Trigger global listeners last . 
 / / Note that NotificationTest . callingOrdersOfListeners will fail if orders change . 
 notifyGlobalListeners ( ) ; 
 + * / 
 } 
 
 private void collectAsyncRealmResultsCallbacks ( List < RealmResults < ? extends RealmModel > > resultsToBeNotified ) { 
 diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 index af3d807 . . 3e67066 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 @ @ - 20 , 6 + 20 , 7 @ @ import java . util . List ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . Future ; 
 
 + import io . realm . internal . PendingRow ; 
 import io . realm . internal . Row ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableQuery ; 
 @ @ - 29 , 7 + 30 , 7 @ @ import io . realm . log . RealmLog ; 
 * This implements { @ code RealmObjectProxy } interface , to eliminate copying logic between 
 * { @ link RealmObject } and { @ link DynamicRealmObject } . 
 * / 
 - public final class ProxyState < E extends RealmModel > { 
 + public final class ProxyState < E extends RealmModel > implements PendingRow . FrontEnd { 
 private E model ; 
 private String className ; 
 private Class < ? extends RealmModel > clazzName ; 
 @ @ - 163 , 27 + 164 , 8 @ @ public final class ProxyState < E extends RealmModel > { 
 * / 
 void notifyChangeListeners $ realm ( ) { 
 if ( ! listeners . isEmpty ( ) ) { 
 - boolean notify = false ; 
 - 
 - Table table = row . getTable ( ) ; 
 - if ( table = = null ) { 
 - / / Completed async queries might result in ` table = = null ` , ` isCompleted = = true ` and ` row = = Row . EMPTY _ ROW ` 
 - / / We still want to trigger change notifications for these cases . 
 - / / isLoaded / isValid should be considered properties on RealmObjects as well so any change to these 
 - / / should trigger a RealmChangeListener . 
 - notify = true ; 
 - } else { 
 - long version = table . getVersion ( ) ; 
 - if ( currentTableVersion ! = version ) { 
 - currentTableVersion = version ; 
 - notify = true ; 
 - } 
 - } 
 - 
 - if ( notify ) { 
 - for ( RealmChangeListener listener : listeners ) { 
 - listener . onChange ( model ) ; 
 - } 
 + for ( RealmChangeListener listener : listeners ) { 
 + listener . onChange ( model ) ; 
 } 
 } 
 } 
 @ @ - 219 , 4 + 201 , 12 @ @ public final class ProxyState < E extends RealmModel > { 
 realm . checkIfValid ( ) ; 
 return getPendingQuery $ realm ( ) = = null | | isCompleted $ realm ( ) ; 
 } 
 + 
 + @ Override 
 + public void onQueryFinished ( Row row , boolean asyncQuery ) { 
 + this . row = row ; 
 + if ( asyncQuery ) { 
 + notifyChangeListeners $ realm ( ) ; 
 + } 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 index 281fa7d . . 0e20605 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 @ @ - 21 , 22 + 21 , 19 @ @ import java . lang . ref . WeakReference ; 
 import java . util . Collections ; 
 import java . util . Date ; 
 import java . util . Locale ; 
 - import java . util . concurrent . Callable ; 
 - import java . util . concurrent . Future ; 
 
 import io . realm . annotations . Required ; 
 import io . realm . internal . Collection ; 
 import io . realm . internal . LinkView ; 
 + import io . realm . internal . PendingRow ; 
 import io . realm . internal . RealmNotifier ; 
 import io . realm . internal . RealmObjectProxy ; 
 - import io . realm . internal . Row ; 
 import io . realm . internal . SharedRealm ; 
 import io . realm . internal . SortDescriptor ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableQuery ; 
 import io . realm . internal . async . ArgumentsHolder ; 
 import io . realm . internal . async . QueryUpdateTask ; 
 - import io . realm . log . RealmLog ; 
 
 / * * 
 * A RealmQuery encapsulates a query on a { @ link io . realm . Realm } or a { @ link io . realm . RealmResults } using the Builder 
 @ @ - 1649 , 98 + 1646 , 36 @ @ public final class RealmQuery < E extends RealmModel > { 
 * / 
 public E findFirst ( ) { 
 checkQueryIsNotReused ( ) ; 
 - long tableRowIndex = getSourceRowIndexForFirstObject ( ) ; 
 - if ( tableRowIndex > = 0 ) { 
 - E realmObject = realm . get ( clazz , className , tableRowIndex ) ; 
 - return realmObject ; 
 - } else { 
 - return null ; 
 - } 
 - } 
 - 
 - / * * 
 - * Similar to { @ link # findFirst ( ) } but runs asynchronously on a worker thread 
 - * This method is only available from a Looper thread . 
 - * 
 - * @ return immediately an empty { @ link RealmObject } . Trying to access any field on the returned object 
 - * before it is loaded will throw an { @ code IllegalStateException } . Use { @ link RealmObject # isLoaded ( ) } to check if 
 - * the object is fully loaded or register a listener { @ link io . realm . RealmObject # addChangeListener } 
 - * to be notified when the query completes . If no RealmObject was found after the query completed , the returned 
 - * RealmObject will have { @ link RealmObject # isLoaded ( ) } set to { @ code true } and { @ link RealmObject # isValid ( ) } set to 
 - * { @ code false } . 
 - * / 
 - public E findFirstAsync ( ) { 
 - checkQueryIsNotReused ( ) ; 
 - final WeakReference < RealmNotifier > weakNotifier = getWeakReferenceNotifier ( ) ; 
 - 
 - / / handover the query ( to be used by a worker thread ) 
 - final long handoverQueryPointer = query . handoverQuery ( realm . sharedRealm ) ; 
 - 
 - / / save query arguments ( for future update ) 
 - argumentsHolder = new ArgumentsHolder ( ArgumentsHolder . TYPE _ FIND _ FIRST ) ; 
 - 
 - final RealmConfiguration realmConfiguration = realm . getConfiguration ( ) ; 
 
 + / / TODO : The performance by the pending query will be a little bit worse than directly calling core ' s 
 + / / Query . find ( ) . The overhead comes with core needs to add all the row indices to the vector . However this can 
 + / / be optimized by adding support of limit in OS ' s Results which is supported by core already . 
 + PendingRow pendingRow = new PendingRow ( realm . sharedRealm , query , null ) ; 
 / / prepare an empty reference of the RealmObject , so we can return it immediately ( promise ) 
 / / then update it once the query complete in the background . 
 final E result ; 
 if ( isDynamicQuery ( ) ) { 
 / / noinspection unchecked 
 - result = ( E ) new DynamicRealmObject ( className , realm , Row . EMPTY _ ROW ) ; 
 + result = ( E ) new DynamicRealmObject ( className , realm , pendingRow ) ; 
 } else { 
 result = realm . getConfiguration ( ) . getSchemaMediator ( ) . newInstance ( 
 - clazz , realm , Row . EMPTY _ ROW , realm . getSchema ( ) . getColumnInfo ( clazz ) , 
 + clazz , realm , pendingRow , realm . getSchema ( ) . getColumnInfo ( clazz ) , 
 false , Collections . < String > emptyList ( ) ) ; 
 } 
 
 final RealmObjectProxy proxy = ( RealmObjectProxy ) result ; 
 - final WeakReference < RealmObjectProxy > realmObjectWeakReference = realm . handlerController . addToAsyncRealmObject ( proxy , this ) ; 
 - 
 - final Future < Long > pendingQuery = Realm . asyncTaskExecutor . submitQuery ( new Callable < Long > ( ) { 
 - @ Override 
 - public Long call ( ) throws Exception { 
 - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 - SharedRealm sharedRealm = null ; 
 - 
 - try { 
 - sharedRealm = SharedRealm . getInstance ( realmConfiguration ) ; 
 - 
 - long handoverRowPointer = TableQuery . findWithHandover ( sharedRealm , handoverQueryPointer ) ; 
 - if ( handoverRowPointer = = 0 ) { / / empty row 
 - realm . handlerController . addToEmptyAsyncRealmObject ( realmObjectWeakReference , RealmQuery . this ) ; 
 - realm . handlerController . removeFromAsyncRealmObject ( realmObjectWeakReference ) ; 
 - } 
 - 
 - QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmObjectResponse ( ) ; 
 - result . updatedRow . put ( realmObjectWeakReference , handoverRowPointer ) ; 
 - result . versionID = sharedRealm . getVersionID ( ) ; 
 - closeSharedRealmAndSendEventToNotifier ( sharedRealm , 
 - weakNotifier , QueryUpdateTask . NotifyEvent . COMPLETE _ ASYNC _ OBJECT , result ) ; 
 - 
 - return handoverRowPointer ; 
 - 
 - } catch ( Throwable e ) { 
 - RealmLog . error ( e ) ; 
 - / / handler can ' t throw a checked exception need to wrap it into unchecked Exception 
 - closeSharedRealmAndSendEventToNotifier ( sharedRealm , 
 - weakNotifier , QueryUpdateTask . NotifyEvent . THROW _ BACKGROUND _ EXCEPTION , e ) ; 
 - } finally { 
 - if ( sharedRealm ! = null & & ! sharedRealm . isClosed ( ) ) { 
 - sharedRealm . close ( ) ; 
 - } 
 - } 
 - } else { 
 - TableQuery . nativeCloseQueryHandover ( handoverQueryPointer ) ; 
 - } 
 - 
 - return INVALID _ NATIVE _ POINTER ; 
 - } 
 - } ) ; 
 - proxy . realmGet $ proxyState ( ) . setPendingQuery $ realm ( pendingQuery ) ; 
 + pendingRow . setFrontEnd ( proxy . realmGet $ proxyState ( ) ) ; 
 
 return result ; 
 } 
 
 + / * * 
 + * @ deprecated use { @ link # findFirst ( ) } instead . 
 + * / 
 + public E findFirstAsync ( ) { 
 + return findFirst ( ) ; 
 + } 
 + 
 private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { 
 if ( fieldNames = = null ) { 
 throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 index 25fcf2c . . 3f24caf 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 @ @ - 1 , 8 + 1 , 235 @ @ 
 package io . realm . internal ; 
 
 + import java . lang . ref . WeakReference ; 
 + import java . util . Date ; 
 + 
 + import io . realm . RealmChangeListener ; 
 + import io . realm . RealmFieldType ; 
 + 
 / * * 
 - * Created by cc on 16 - 11 - 30 . 
 + * A PendingRow is a row relies on a pending async query . 
 + * Before the query returns , calling any accessors will immediately execute the query and call the corresponding 
 + * accessor on the query result . If the query results is empty , an { @ link IllegalStateException } will be thrown . 
 + * After the query returns , { @ link FrontEnd # onQueryFinished ( Row , boolean ) } will be called to give the front end a 
 + * chance to reset the row . If the async query returns an empty result , the query will be executed again later until a 
 + * valid row is contained by the query results . 
 * / 
 - 
 public class PendingRow implements Row { 
 + 
 + / / Implement this interface to reset the PendingRow to a Row backed by real data when query returned . 
 + public interface FrontEnd { 
 + / / When asyncQuery is true , the pending query is executed asynchronously . Otherwise the query is triggered by 
 + / / calling any accessors before the async query returns . 
 + void onQueryFinished ( Row row , boolean asyncQuery ) ; 
 + } 
 + 
 + private static final String EMPTY _ ROW _ MESSAGE = 
 + " This RealmObject is empty . There isn ' t any objects match the query . " ; 
 + private static final String PROXY _ NOT _ SET _ MESSAGE = " The ' frontEnd ' has not been set . " ; 
 + private static final String QUERY _ EXECUTED _ MESSAGE = 
 + " The query has been executed . This ' PendingRow ' is not valid anymore . " ; 
 + 
 + private Collection pendingCollection ; 
 + private Collection . Listener listener ; 
 + private WeakReference < FrontEnd > frontEnd ; 
 + 
 + public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { 
 + pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; 
 + listener = new Collection . Listener ( new RealmChangeListener < PendingRow > ( ) { 
 + @ Override 
 + public void onChange ( PendingRow pendingRow ) { 
 + if ( frontEnd = = null ) { 
 + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 + } 
 + / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . 
 + Row row = pendingCollection . firstUncheckedRow ( ) ; 
 + if ( frontEnd . get ( ) = = null ) { 
 + / / The front end is GCed . 
 + clearPendingCollection ( ) ; 
 + return ; 
 + } 
 + / / If no rows returned by the query , just wait for the query updates until it returns a valid row . 
 + if ( row ! = null ) { 
 + / / Ask the front end to reset the row and stop async query . 
 + frontEnd . get ( ) . onQueryFinished ( row , true ) ; 
 + clearPendingCollection ( ) ; 
 + } 
 + } 
 + } , this ) ; 
 + pendingCollection . addListener ( listener ) ; 
 + } 
 + 
 + / / To set the front end of this PendingRow . 
 + public void setFrontEnd ( FrontEnd frontEnd ) { 
 + this . frontEnd = new WeakReference < FrontEnd > ( frontEnd ) ; 
 + } 
 + 
 + @ Override 
 + public long getColumnCount ( ) { 
 + return executeQuery ( ) . getColumnCount ( ) ; 
 + } 
 + 
 + @ Override 
 + public String getColumnName ( long columnIndex ) { 
 + return executeQuery ( ) . getColumnName ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public long getColumnIndex ( String columnName ) { 
 + return executeQuery ( ) . getColumnIndex ( columnName ) ; 
 + } 
 + 
 + @ Override 
 + public RealmFieldType getColumnType ( long columnIndex ) { 
 + return executeQuery ( ) . getColumnType ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public Table getTable ( ) { 
 + return executeQuery ( ) . getTable ( ) ; 
 + } 
 + 
 + @ Override 
 + public long getIndex ( ) { 
 + return executeQuery ( ) . getIndex ( ) ; 
 + } 
 + 
 + @ Override 
 + public long getLong ( long columnIndex ) { 
 + return executeQuery ( ) . getLong ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean getBoolean ( long columnIndex ) { 
 + return executeQuery ( ) . getBoolean ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public float getFloat ( long columnIndex ) { 
 + return executeQuery ( ) . getFloat ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public double getDouble ( long columnIndex ) { 
 + return executeQuery ( ) . getDouble ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public Date getDate ( long columnIndex ) { 
 + return executeQuery ( ) . getDate ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public String getString ( long columnIndex ) { 
 + return executeQuery ( ) . getString ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public byte [ ] getBinaryByteArray ( long columnIndex ) { 
 + return executeQuery ( ) . getBinaryByteArray ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public long getLink ( long columnIndex ) { 
 + return executeQuery ( ) . getLink ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isNullLink ( long columnIndex ) { 
 + return executeQuery ( ) . isNullLink ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public LinkView getLinkList ( long columnIndex ) { 
 + return executeQuery ( ) . getLinkList ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public void setLong ( long columnIndex , long value ) { 
 + executeQuery ( ) . setLong ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setBoolean ( long columnIndex , boolean value ) { 
 + executeQuery ( ) . setBoolean ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setFloat ( long columnIndex , float value ) { 
 + executeQuery ( ) . setFloat ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setDouble ( long columnIndex , double value ) { 
 + executeQuery ( ) . setDouble ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setDate ( long columnIndex , Date date ) { 
 + executeQuery ( ) . setDate ( columnIndex , date ) ; 
 + } 
 + 
 + @ Override 
 + public void setString ( long columnIndex , String value ) { 
 + executeQuery ( ) . setString ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setBinaryByteArray ( long columnIndex , byte [ ] data ) { 
 + executeQuery ( ) . setBinaryByteArray ( columnIndex , data ) ; 
 + } 
 + 
 + @ Override 
 + public void setLink ( long columnIndex , long value ) { 
 + executeQuery ( ) . setLink ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void nullifyLink ( long columnIndex ) { 
 + executeQuery ( ) . nullifyLink ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isNull ( long columnIndex ) { 
 + return executeQuery ( ) . isNull ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public void setNull ( long columnIndex ) { 
 + executeQuery ( ) . setNull ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isAttached ( ) { 
 + return executeQuery ( ) . isAttached ( ) ; 
 + } 
 + 
 + @ Override 
 + public boolean hasColumn ( String fieldName ) { 
 + return executeQuery ( ) . hasColumn ( fieldName ) ; 
 + } 
 + 
 + private void clearPendingCollection ( ) { 
 + pendingCollection . removeListener ( listener ) ; 
 + pendingCollection = null ; 
 + listener = null ; 
 + } 
 + 
 + private Row executeQuery ( ) { 
 + if ( pendingCollection = = null ) { 
 + throw new IllegalStateException ( QUERY _ EXECUTED _ MESSAGE ) ; 
 + } 
 + if ( frontEnd = = null ) { 
 + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 + } 
 + Row row = pendingCollection . getUncheckedRow ( 0 ) ; 
 + if ( row = = null ) { 
 + throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; 
 + } 
 + if ( frontEnd . get ( ) ! = null ) { 
 + frontEnd . get ( ) . onQueryFinished ( pendingCollection . firstUncheckedRow ( ) , false ) ; 
 + } 
 + clearPendingCollection ( ) ; 
 + return row ; 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java 
 index 7802428 . . 5b5b441 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java 
 @ @ - 89 , 8 + 89 , 10 @ @ public class UncheckedRow implements NativeObject , Row { 
 
 / / FIXME : Testing code 
 public static UncheckedRow getByRowPointer ( Table table , long nativeRowPointer ) { 
 - UncheckedRow row = new UncheckedRow ( table . context , table , nativeRowPointer ) ; 
 - return row ; 
 + if ( nativeRowPointer ! = 0 ) { 
 + return new UncheckedRow ( table . context , table , nativeRowPointer ) ; 
 + } 
 + return null ; 
 } 
 
 / * *
