BLEU SCORE: 0.020943469770777077

TEST MSG: Add test case for Collection notification behavior
GENERATED MSG: Test case - check that all other column than String throws exception when setting index

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java b / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java <nl> index c0e26f0 . . 815aabc 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java <nl> @ @ - 26 , 8 + 26 , 14 @ @ import org . junit . Test ; <nl> import org . junit . rules . ExpectedException ; <nl> import org . junit . runner . RunWith ; <nl> <nl> + import java . util . concurrent . CountDownLatch ; <nl> + <nl> + import io . realm . RealmChangeListener ; <nl> import io . realm . RealmConfiguration ; <nl> import io . realm . RealmFieldType ; <nl> + import io . realm . TestHelper ; <nl> + import io . realm . rule . RunInLooperThread ; <nl> + import io . realm . rule . RunTestInLooperThread ; <nl> import io . realm . rule . TestRealmConfigurationFactory ; <nl> <nl> import static junit . framework . Assert . assertEquals ; <nl> @ @ - 40 , 26 + 46 , 28 @ @ public class CollectionTests { <nl> public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; <nl> @ Rule <nl> public final ExpectedException thrown = ExpectedException . none ( ) ; <nl> + @ Rule <nl> + public final RunInLooperThread looperThread = new RunInLooperThread ( ) ; <nl> <nl> + RealmConfiguration config ; <nl> private SharedRealm sharedRealm ; <nl> private Table table ; <nl> <nl> @ Before <nl> public void setUp ( ) { <nl> - RealmConfiguration config = configFactory . createConfiguration ( ) ; <nl> + config = configFactory . createConfiguration ( ) ; <nl> sharedRealm = SharedRealm . getInstance ( config ) ; <nl> - sharedRealm . beginTransaction ( ) ; <nl> - table = sharedRealm . getTable ( " test _ table " ) ; <nl> - populateData ( table ) ; <nl> + populateData ( ) ; <nl> } <nl> <nl> @ After <nl> public void tearDown ( ) { <nl> - sharedRealm . cancelTransaction ( ) ; <nl> sharedRealm . close ( ) ; <nl> } <nl> <nl> - private void populateData ( Table table ) { <nl> + private void populateData ( ) { <nl> + sharedRealm . beginTransaction ( ) ; <nl> + table = sharedRealm . getTable ( " test _ table " ) ; <nl> / / Specify the column types and names <nl> table . addColumn ( RealmFieldType . STRING , " firstName " ) ; <nl> table . addColumn ( RealmFieldType . STRING , " lastName " ) ; <nl> @ @ - 85 , 6 + 93 , 35 @ @ public class CollectionTests { <nl> table . setString ( 0 , row , " Henry " , false ) ; <nl> table . setString ( 1 , row , " Anderson " , false ) ; <nl> table . setLong ( 2 , row , 1 , false ) ; <nl> + sharedRealm . commitTransaction ( ) ; <nl> + } <nl> + <nl> + private void addRowAsync ( ) { <nl> + final CountDownLatch latch = new CountDownLatch ( 1 ) ; <nl> + new Thread ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; <nl> + addRow ( sharedRealm ) ; <nl> + sharedRealm . close ( ) ; <nl> + latch . countDown ( ) ; <nl> + } <nl> + } ) . start ( ) ; <nl> + TestHelper . awaitOrFail ( latch ) ; <nl> + } <nl> + <nl> + private void addRow ( SharedRealm sharedRealm ) { <nl> + sharedRealm . beginTransaction ( ) ; <nl> + table = sharedRealm . getTable ( " test _ table " ) ; <nl> + table . addEmptyRow ( ) ; <nl> + sharedRealm . commitTransaction ( ) ; <nl> + } <nl> + <nl> + private void removeRow ( SharedRealm sharedRealm ) { <nl> + sharedRealm . beginTransaction ( ) ; <nl> + table = sharedRealm . getTable ( " test _ table " ) ; <nl> + table . remove ( 0 ) ; <nl> + sharedRealm . commitTransaction ( ) ; <nl> } <nl> <nl> @ Test ( expected = UnsupportedOperationException . class ) <nl> @ @ - 96 , 7 + 133 , 9 @ @ public class CollectionTests { <nl> @ Test <nl> public void constructor _ queryOnDeletedTable ( ) { <nl> TableQuery query = table . where ( ) ; <nl> + sharedRealm . beginTransaction ( ) ; <nl> sharedRealm . removeTable ( table . getName ( ) ) ; <nl> + sharedRealm . commitTransaction ( ) ; <nl> / / Query should be checked before creating OS Results . <nl> thrown . expect ( IllegalStateException . class ) ; <nl> new Collection ( sharedRealm , query ) ; <nl> @ @ - 105 , 7 + 144 , 7 @ @ public class CollectionTests { <nl> @ Test <nl> public void size ( ) { <nl> Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> - assertEquals ( 3 , collection . size ( ) ) ; <nl> + assertEquals ( 4 , collection . size ( ) ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 146 , 7 + 185 , 9 @ @ public class CollectionTests { <nl> public void clear ( ) { <nl> assertEquals ( table . size ( ) , 4 ) ; <nl> Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + sharedRealm . beginTransaction ( ) ; <nl> collection . clear ( ) ; <nl> + sharedRealm . commitTransaction ( ) ; <nl> assertEquals ( table . size ( ) , 0 ) ; <nl> } <nl> <nl> @ @ - 190 , 4 + 231 , 163 @ @ public class CollectionTests { <nl> assertEquals ( collection . getUncheckedRow ( 1 ) . getString ( 0 ) , " Erik " ) ; <nl> assertEquals ( collection . getUncheckedRow ( 2 ) . getString ( 0 ) , " Henry " ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void addListener _ shouldBeCalledWhenRefreshAfterLocalCommit ( ) { <nl> + final CountDownLatch latch = new CountDownLatch ( 1 ) ; <nl> + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + collection . size ( ) ; <nl> + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { <nl> + @ Override <nl> + public void onChange ( Collection element ) { <nl> + assertEquals ( latch . getCount ( ) , 1 ) ; <nl> + latch . countDown ( ) ; <nl> + } <nl> + } ) ; <nl> + sharedRealm . beginTransaction ( ) ; <nl> + table . addEmptyRow ( ) ; <nl> + sharedRealm . commitTransaction ( ) ; <nl> + sharedRealm . refresh ( ) ; <nl> + TestHelper . awaitOrFail ( latch ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void addListener _ shouldBeCalledByWaitForChangeThenRefresh ( ) { <nl> + final CountDownLatch latch = new CountDownLatch ( 1 ) ; <nl> + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + collection . size ( ) ; <nl> + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { <nl> + @ Override <nl> + public void onChange ( Collection element ) { <nl> + assertEquals ( latch . getCount ( ) , 1 ) ; <nl> + latch . countDown ( ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + addRowAsync ( ) ; <nl> + <nl> + sharedRealm . waitForChange ( ) ; <nl> + sharedRealm . refresh ( ) ; <nl> + TestHelper . awaitOrFail ( latch ) ; <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void addListener _ queryNotReturned ( ) { <nl> + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; <nl> + Table table = sharedRealm . getTable ( " test _ table " ) ; <nl> + <nl> + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + looperThread . keepStrongReference . add ( collection ) ; <nl> + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { <nl> + @ Override <nl> + public void onChange ( Collection collection1 ) { <nl> + assertEquals ( collection1 , collection ) ; <nl> + assertEquals ( collection1 . size ( ) , 5 ) ; <nl> + sharedRealm . close ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + addRowAsync ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void addListener _ queryReturned ( ) { <nl> + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; <nl> + Table table = sharedRealm . getTable ( " test _ table " ) ; <nl> + <nl> + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + looperThread . keepStrongReference . add ( collection ) ; <nl> + assertEquals ( collection . size ( ) , 4 ) ; / / Trigger the query to run . <nl> + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { <nl> + @ Override <nl> + public void onChange ( Collection collection1 ) { <nl> + assertEquals ( collection1 , collection ) ; <nl> + assertEquals ( collection1 . size ( ) , 5 ) ; <nl> + sharedRealm . close ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + addRowAsync ( ) ; <nl> + } <nl> + <nl> + / / The query has not been executed . <nl> + / / Local commit won ' t trigger the listener immediately . Instead , the notification comes after the background commit . <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void addListener _ queryNotReturnedLocalAndRemoteCommit ( ) { <nl> + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; <nl> + Table table = sharedRealm . getTable ( " test _ table " ) ; <nl> + <nl> + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + looperThread . keepStrongReference . add ( collection ) ; <nl> + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { <nl> + @ Override <nl> + public void onChange ( Collection collection1 ) { <nl> + assertEquals ( collection1 , collection ) ; <nl> + assertEquals ( collection1 . size ( ) , 6 ) ; <nl> + sharedRealm . close ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + addRow ( sharedRealm ) ; <nl> + addRowAsync ( ) ; <nl> + } <nl> + <nl> + / / The query has not been executed . <nl> + / / Local commit will trigger the listener in following event loops . <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void addListener _ queryNotReturnedLocalCommitOnly ( ) { <nl> + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; <nl> + Table table = sharedRealm . getTable ( " test _ table " ) ; <nl> + <nl> + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + looperThread . keepStrongReference . add ( collection ) ; <nl> + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { <nl> + @ Override <nl> + public void onChange ( Collection collection1 ) { <nl> + assertEquals ( collection1 , collection ) ; <nl> + assertEquals ( collection1 . size ( ) , 5 ) ; <nl> + sharedRealm . close ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + addRow ( sharedRealm ) ; <nl> + } <nl> + <nl> + / / The query has been executed . <nl> + / / Local commit will trigger the listener in following event loops . <nl> + @ Test <nl> + @ RunTestInLooperThread <nl> + public void addListener _ queryReturnedLocalCommitOnly ( ) { <nl> + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; <nl> + Table table = sharedRealm . getTable ( " test _ table " ) ; <nl> + <nl> + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + assertEquals ( collection . size ( ) , 4 ) ; / / Trigger the query to run . <nl> + looperThread . keepStrongReference . add ( collection ) ; <nl> + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { <nl> + @ Override <nl> + public void onChange ( Collection collection1 ) { <nl> + assertEquals ( collection1 , collection ) ; <nl> + assertEquals ( collection1 . size ( ) , 5 ) ; <nl> + sharedRealm . close ( ) ; <nl> + looperThread . testComplete ( ) ; <nl> + } <nl> + } ) ; <nl> + addRow ( sharedRealm ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void size _ doesNotChangeAfterLocalCommit ( ) { <nl> + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; <nl> + assertEquals ( collection . size ( ) , 4 ) ; <nl> + addRow ( sharedRealm ) ; <nl> + assertEquals ( collection . size ( ) , 4 ) ; <nl> + sharedRealm . refresh ( ) ; <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Collection . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Collection . cpp <nl> index ff1176a . . 0c82e4b 100644 <nl> - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Collection . cpp <nl> + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Collection . cpp <nl> @ @ - 251 , 6 + 251 , 8 @ @ Java _ io _ realm _ internal _ Collection _ nativeStartListening ( JNIEnv * env , jobject inst <nl> std : : exception _ ptr err ) { <nl> / / OS will call all notifiers ' callback in one run , so check the Java exception first ! ! <nl> if ( env - > ExceptionCheck ( ) ) return ; <nl> + / / No changes . <nl> + if ( changes . empty ( ) ) return ; <nl> <nl> env - > CallVoidMethod ( wrapper - > m _ collection _ weak _ ref , notify _ change _ listeners ) ; <nl> } ;
NEAREST DIFF (one line): diff - - git a / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java b / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java <nl> deleted file mode 100644 <nl> index 508f360 . . 0000000 <nl> - - - a / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java <nl> + + + / dev / null <nl> @ @ - 1 , 78 + 0 , 0 @ @ <nl> - package com . tightdb ; <nl> - <nl> - import static org . testng . AssertJUnit . * ; <nl> - import org . testng . annotations . Test ; <nl> - <nl> - / / TODO : Check that Index can be set on multiple columns . <nl> - <nl> - @ SuppressWarnings ( " unused " ) <nl> - public class JNIDistinctTest { <nl> - Table table ; <nl> - <nl> - void init ( ) { <nl> - table = new Table ( ) ; <nl> - table . addColumn ( ColumnType . LONG , " number " ) ; <nl> - table . addColumn ( ColumnType . STRING , " name " ) ; <nl> - <nl> - long i = 0 ; <nl> - table . add ( 0 , " A " ) ; <nl> - table . add ( 1 , " B " ) ; <nl> - table . add ( 2 , " C " ) ; <nl> - table . add ( 3 , " B " ) ; <nl> - table . add ( 4 , " D " ) ; <nl> - table . add ( 5 , " D " ) ; <nl> - table . add ( 6 , " D " ) ; <nl> - assertEquals ( 7 , table . size ( ) ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void shouldTestDistinct ( ) { <nl> - init ( ) ; <nl> - <nl> - / / Must set index before using distinct ( ) <nl> - table . setIndex ( 1 ) ; <nl> - assertEquals ( true , table . hasIndex ( 1 ) ) ; <nl> - <nl> - TableView view = table . distinct ( 1 ) ; <nl> - assertEquals ( 4 , view . size ( ) ) ; <nl> - assertEquals ( 0 , view . getLong ( 0 , 0 ) ) ; <nl> - assertEquals ( 1 , view . getLong ( 0 , 1 ) ) ; <nl> - assertEquals ( 2 , view . getLong ( 0 , 2 ) ) ; <nl> - assertEquals ( 4 , view . getLong ( 0 , 3 ) ) ; <nl> - } <nl> - <nl> - @ Test ( expectedExceptions = UnsupportedOperationException . class ) <nl> - public void shouldTestDistinctErrorWhenNoIndex ( ) { <nl> - init ( ) ; <nl> - TableView view = table . distinct ( 1 ) ; <nl> - } <nl> - <nl> - @ Test ( expectedExceptions = ArrayIndexOutOfBoundsException . class ) <nl> - public void shouldTestDistinctErrorWhenIndexOutOfBounds ( ) { <nl> - init ( ) ; <nl> - <nl> - TableView view = table . distinct ( 3 ) ; <nl> - } <nl> - <nl> - / / TODO : Check all other column types than String throws exception <nl> - <nl> - @ Test ( expectedExceptions = IllegalArgumentException . class ) <nl> - public void shouldTestIndexOnWrongColumnType ( ) { <nl> - init ( ) ; <nl> - table . setIndex ( 0 ) ; <nl> - } <nl> - <nl> - @ Test ( ) <nl> - public void shouldCheckIndexIsOkOnColumn ( ) { <nl> - init ( ) ; <nl> - table . setIndex ( 1 ) ; <nl> - } <nl> - <nl> - @ Test ( expectedExceptions = UnsupportedOperationException . class ) <nl> - public void shouldTestDistinctErrorWhenWrongColumnType ( ) { <nl> - init ( ) ; <nl> - table . setIndex ( 1 ) ; <nl> - TableView view = table . distinct ( 0 ) ; <nl> - } <nl> - <nl> - } <nl> diff - - git a / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java b / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java <nl> new file mode 100644 <nl> index 0000000 . . 1da18ab <nl> - - - / dev / null <nl> + + + b / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java <nl> @ @ - 0 , 0 + 1 , 148 @ @ <nl> + package com . tightdb ; <nl> + <nl> + import static org . testng . AssertJUnit . * ; <nl> + <nl> + import java . util . Arrays ; <nl> + import java . util . Date ; <nl> + import java . util . Iterator ; <nl> + import java . util . List ; <nl> + <nl> + import org . testng . annotations . DataProvider ; <nl> + import org . testng . annotations . Test ; <nl> + <nl> + import com . tightdb . test . DataProviderUtil ; <nl> + import com . tightdb . test . TestHelper ; <nl> + <nl> + <nl> + @ SuppressWarnings ( " unused " ) <nl> + public class TableIndexAndDistinctTest { <nl> + Table table ; <nl> + <nl> + void init ( ) { <nl> + table = new Table ( ) ; <nl> + table . addColumn ( ColumnType . LONG , " number " ) ; <nl> + table . addColumn ( ColumnType . STRING , " name " ) ; <nl> + <nl> + long i = 0 ; <nl> + table . add ( 0 , " A " ) ; <nl> + table . add ( 1 , " B " ) ; <nl> + table . add ( 2 , " C " ) ; <nl> + table . add ( 3 , " B " ) ; <nl> + table . add ( 4 , " D " ) ; <nl> + table . add ( 5 , " D " ) ; <nl> + table . add ( 6 , " D " ) ; <nl> + assertEquals ( 7 , table . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void shouldTestDistinct ( ) { <nl> + init ( ) ; <nl> + <nl> + / / Must set index before using distinct ( ) <nl> + table . setIndex ( 1 ) ; <nl> + assertEquals ( true , table . hasIndex ( 1 ) ) ; <nl> + <nl> + TableView view = table . distinct ( 1 ) ; <nl> + assertEquals ( 4 , view . size ( ) ) ; <nl> + assertEquals ( 0 , view . getLong ( 0 , 0 ) ) ; <nl> + assertEquals ( 1 , view . getLong ( 0 , 1 ) ) ; <nl> + assertEquals ( 2 , view . getLong ( 0 , 2 ) ) ; <nl> + assertEquals ( 4 , view . getLong ( 0 , 3 ) ) ; <nl> + } <nl> + <nl> + <nl> + <nl> + / * * <nl> + * Should throw exception if trying to get distinct on columns where index has not been set <nl> + * @ param index <nl> + * / <nl> + @ Test ( expectedExceptions = UnsupportedOperationException . class , dataProvider = " columnIndex " ) <nl> + public void shouldTestDistinctErrorWhenNoIndex ( Long index ) { <nl> + <nl> + / / Get a table with all available column types <nl> + Table t = TestHelper . getTableWithAllColumnTypes ( ) ; <nl> + <nl> + TableView view = table . distinct ( 1 ) ; <nl> + } <nl> + <nl> + @ Test ( expectedExceptions = ArrayIndexOutOfBoundsException . class ) <nl> + public void shouldTestDistinctErrorWhenIndexOutOfBounds ( ) { <nl> + init ( ) ; <nl> + <nl> + TableView view = table . distinct ( 3 ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checkd that Index can be set on multiple columns , with the String <nl> + * @ param index <nl> + * / <nl> + public void shouldTestSettingIndexOnMultipleColumns ( ) { <nl> + <nl> + / / Create a table only with String type columns <nl> + Table t = new Table ( ) ; <nl> + t . addColumn ( ColumnType . STRING , " col1 " ) ; <nl> + t . addColumn ( ColumnType . STRING , " col2 " ) ; <nl> + t . addColumn ( ColumnType . STRING , " col3 " ) ; <nl> + t . addColumn ( ColumnType . STRING , " col4 " ) ; <nl> + t . addColumn ( ColumnType . STRING , " col5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; <nl> + <nl> + for ( long c = 0 ; c < t . getColumnCount ( ) ; c + + ) { <nl> + t . setIndex ( c ) ; <nl> + assertEquals ( true , t . hasIndex ( c ) ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Checks that all other column types than String throws exception . <nl> + * @ param o <nl> + * / <nl> + @ Test ( expectedExceptions = IllegalArgumentException . class , dataProvider = " columnIndex " ) <nl> + public void shouldTestIndexOnWrongColumnType ( Long index ) { <nl> + <nl> + / / Get a table with all available column types <nl> + Table t = TestHelper . getTableWithAllColumnTypes ( ) ; <nl> + <nl> + / / If column type is String , then throw the excepted exception <nl> + if ( t . getColumnType ( index ) . equals ( ColumnType . STRING ) ) { <nl> + throw new IllegalArgumentException ( ) ; <nl> + } <nl> + <nl> + t . setIndex ( index ) ; <nl> + } <nl> + <nl> + @ Test ( ) <nl> + public void shouldCheckIndexIsOkOnColumn ( ) { <nl> + init ( ) ; <nl> + table . setIndex ( 1 ) ; <nl> + } <nl> + <nl> + @ Test ( expectedExceptions = UnsupportedOperationException . class ) <nl> + public void shouldTestDistinctErrorWhenWrongColumnType ( ) { <nl> + init ( ) ; <nl> + table . setIndex ( 1 ) ; <nl> + TableView view = table . distinct ( 0 ) ; <nl> + } <nl> + <nl> + <nl> + / * * <nl> + * Is used to run a test multiple times , <nl> + * that corresponds to the number of columns in the Table generated <nl> + * in TestHelper . getTableWithAllColumnTypes <nl> + * @ return <nl> + * / <nl> + @ DataProvider ( name = " columnIndex " ) <nl> + public Iterator < Object [ ] > mixedValuesProvider ( ) { <nl> + Long [ ] values = { <nl> + 0L , 1L , 2L , 3L , 4L , 5L , 6L , 7L , 8L <nl> + } ; <nl> + <nl> + List < ? > mixedValues = Arrays . asList ( values ) ; <nl> + return DataProviderUtil . allCombinations ( mixedValues ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java b / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java 
 index c0e26f0 . . 815aabc 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / internal / CollectionTests . java 
 @ @ - 26 , 8 + 26 , 14 @ @ import org . junit . Test ; 
 import org . junit . rules . ExpectedException ; 
 import org . junit . runner . RunWith ; 
 
 + import java . util . concurrent . CountDownLatch ; 
 + 
 + import io . realm . RealmChangeListener ; 
 import io . realm . RealmConfiguration ; 
 import io . realm . RealmFieldType ; 
 + import io . realm . TestHelper ; 
 + import io . realm . rule . RunInLooperThread ; 
 + import io . realm . rule . RunTestInLooperThread ; 
 import io . realm . rule . TestRealmConfigurationFactory ; 
 
 import static junit . framework . Assert . assertEquals ; 
 @ @ - 40 , 26 + 46 , 28 @ @ public class CollectionTests { 
 public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory ( ) ; 
 @ Rule 
 public final ExpectedException thrown = ExpectedException . none ( ) ; 
 + @ Rule 
 + public final RunInLooperThread looperThread = new RunInLooperThread ( ) ; 
 
 + RealmConfiguration config ; 
 private SharedRealm sharedRealm ; 
 private Table table ; 
 
 @ Before 
 public void setUp ( ) { 
 - RealmConfiguration config = configFactory . createConfiguration ( ) ; 
 + config = configFactory . createConfiguration ( ) ; 
 sharedRealm = SharedRealm . getInstance ( config ) ; 
 - sharedRealm . beginTransaction ( ) ; 
 - table = sharedRealm . getTable ( " test _ table " ) ; 
 - populateData ( table ) ; 
 + populateData ( ) ; 
 } 
 
 @ After 
 public void tearDown ( ) { 
 - sharedRealm . cancelTransaction ( ) ; 
 sharedRealm . close ( ) ; 
 } 
 
 - private void populateData ( Table table ) { 
 + private void populateData ( ) { 
 + sharedRealm . beginTransaction ( ) ; 
 + table = sharedRealm . getTable ( " test _ table " ) ; 
 / / Specify the column types and names 
 table . addColumn ( RealmFieldType . STRING , " firstName " ) ; 
 table . addColumn ( RealmFieldType . STRING , " lastName " ) ; 
 @ @ - 85 , 6 + 93 , 35 @ @ public class CollectionTests { 
 table . setString ( 0 , row , " Henry " , false ) ; 
 table . setString ( 1 , row , " Anderson " , false ) ; 
 table . setLong ( 2 , row , 1 , false ) ; 
 + sharedRealm . commitTransaction ( ) ; 
 + } 
 + 
 + private void addRowAsync ( ) { 
 + final CountDownLatch latch = new CountDownLatch ( 1 ) ; 
 + new Thread ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; 
 + addRow ( sharedRealm ) ; 
 + sharedRealm . close ( ) ; 
 + latch . countDown ( ) ; 
 + } 
 + } ) . start ( ) ; 
 + TestHelper . awaitOrFail ( latch ) ; 
 + } 
 + 
 + private void addRow ( SharedRealm sharedRealm ) { 
 + sharedRealm . beginTransaction ( ) ; 
 + table = sharedRealm . getTable ( " test _ table " ) ; 
 + table . addEmptyRow ( ) ; 
 + sharedRealm . commitTransaction ( ) ; 
 + } 
 + 
 + private void removeRow ( SharedRealm sharedRealm ) { 
 + sharedRealm . beginTransaction ( ) ; 
 + table = sharedRealm . getTable ( " test _ table " ) ; 
 + table . remove ( 0 ) ; 
 + sharedRealm . commitTransaction ( ) ; 
 } 
 
 @ Test ( expected = UnsupportedOperationException . class ) 
 @ @ - 96 , 7 + 133 , 9 @ @ public class CollectionTests { 
 @ Test 
 public void constructor _ queryOnDeletedTable ( ) { 
 TableQuery query = table . where ( ) ; 
 + sharedRealm . beginTransaction ( ) ; 
 sharedRealm . removeTable ( table . getName ( ) ) ; 
 + sharedRealm . commitTransaction ( ) ; 
 / / Query should be checked before creating OS Results . 
 thrown . expect ( IllegalStateException . class ) ; 
 new Collection ( sharedRealm , query ) ; 
 @ @ - 105 , 7 + 144 , 7 @ @ public class CollectionTests { 
 @ Test 
 public void size ( ) { 
 Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 - assertEquals ( 3 , collection . size ( ) ) ; 
 + assertEquals ( 4 , collection . size ( ) ) ; 
 } 
 
 @ Test 
 @ @ - 146 , 7 + 185 , 9 @ @ public class CollectionTests { 
 public void clear ( ) { 
 assertEquals ( table . size ( ) , 4 ) ; 
 Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + sharedRealm . beginTransaction ( ) ; 
 collection . clear ( ) ; 
 + sharedRealm . commitTransaction ( ) ; 
 assertEquals ( table . size ( ) , 0 ) ; 
 } 
 
 @ @ - 190 , 4 + 231 , 163 @ @ public class CollectionTests { 
 assertEquals ( collection . getUncheckedRow ( 1 ) . getString ( 0 ) , " Erik " ) ; 
 assertEquals ( collection . getUncheckedRow ( 2 ) . getString ( 0 ) , " Henry " ) ; 
 } 
 + 
 + @ Test 
 + public void addListener _ shouldBeCalledWhenRefreshAfterLocalCommit ( ) { 
 + final CountDownLatch latch = new CountDownLatch ( 1 ) ; 
 + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + collection . size ( ) ; 
 + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { 
 + @ Override 
 + public void onChange ( Collection element ) { 
 + assertEquals ( latch . getCount ( ) , 1 ) ; 
 + latch . countDown ( ) ; 
 + } 
 + } ) ; 
 + sharedRealm . beginTransaction ( ) ; 
 + table . addEmptyRow ( ) ; 
 + sharedRealm . commitTransaction ( ) ; 
 + sharedRealm . refresh ( ) ; 
 + TestHelper . awaitOrFail ( latch ) ; 
 + } 
 + 
 + @ Test 
 + public void addListener _ shouldBeCalledByWaitForChangeThenRefresh ( ) { 
 + final CountDownLatch latch = new CountDownLatch ( 1 ) ; 
 + Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + collection . size ( ) ; 
 + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { 
 + @ Override 
 + public void onChange ( Collection element ) { 
 + assertEquals ( latch . getCount ( ) , 1 ) ; 
 + latch . countDown ( ) ; 
 + } 
 + } ) ; 
 + 
 + addRowAsync ( ) ; 
 + 
 + sharedRealm . waitForChange ( ) ; 
 + sharedRealm . refresh ( ) ; 
 + TestHelper . awaitOrFail ( latch ) ; 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void addListener _ queryNotReturned ( ) { 
 + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; 
 + Table table = sharedRealm . getTable ( " test _ table " ) ; 
 + 
 + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + looperThread . keepStrongReference . add ( collection ) ; 
 + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { 
 + @ Override 
 + public void onChange ( Collection collection1 ) { 
 + assertEquals ( collection1 , collection ) ; 
 + assertEquals ( collection1 . size ( ) , 5 ) ; 
 + sharedRealm . close ( ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + 
 + addRowAsync ( ) ; 
 + } 
 + 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void addListener _ queryReturned ( ) { 
 + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; 
 + Table table = sharedRealm . getTable ( " test _ table " ) ; 
 + 
 + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + looperThread . keepStrongReference . add ( collection ) ; 
 + assertEquals ( collection . size ( ) , 4 ) ; / / Trigger the query to run . 
 + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { 
 + @ Override 
 + public void onChange ( Collection collection1 ) { 
 + assertEquals ( collection1 , collection ) ; 
 + assertEquals ( collection1 . size ( ) , 5 ) ; 
 + sharedRealm . close ( ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + 
 + addRowAsync ( ) ; 
 + } 
 + 
 + / / The query has not been executed . 
 + / / Local commit won ' t trigger the listener immediately . Instead , the notification comes after the background commit . 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void addListener _ queryNotReturnedLocalAndRemoteCommit ( ) { 
 + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; 
 + Table table = sharedRealm . getTable ( " test _ table " ) ; 
 + 
 + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + looperThread . keepStrongReference . add ( collection ) ; 
 + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { 
 + @ Override 
 + public void onChange ( Collection collection1 ) { 
 + assertEquals ( collection1 , collection ) ; 
 + assertEquals ( collection1 . size ( ) , 6 ) ; 
 + sharedRealm . close ( ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + addRow ( sharedRealm ) ; 
 + addRowAsync ( ) ; 
 + } 
 + 
 + / / The query has not been executed . 
 + / / Local commit will trigger the listener in following event loops . 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void addListener _ queryNotReturnedLocalCommitOnly ( ) { 
 + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; 
 + Table table = sharedRealm . getTable ( " test _ table " ) ; 
 + 
 + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + looperThread . keepStrongReference . add ( collection ) ; 
 + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { 
 + @ Override 
 + public void onChange ( Collection collection1 ) { 
 + assertEquals ( collection1 , collection ) ; 
 + assertEquals ( collection1 . size ( ) , 5 ) ; 
 + sharedRealm . close ( ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + addRow ( sharedRealm ) ; 
 + } 
 + 
 + / / The query has been executed . 
 + / / Local commit will trigger the listener in following event loops . 
 + @ Test 
 + @ RunTestInLooperThread 
 + public void addListener _ queryReturnedLocalCommitOnly ( ) { 
 + final SharedRealm sharedRealm = SharedRealm . getInstance ( config ) ; 
 + Table table = sharedRealm . getTable ( " test _ table " ) ; 
 + 
 + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + assertEquals ( collection . size ( ) , 4 ) ; / / Trigger the query to run . 
 + looperThread . keepStrongReference . add ( collection ) ; 
 + collection . addListener ( collection , new RealmChangeListener < Collection > ( ) { 
 + @ Override 
 + public void onChange ( Collection collection1 ) { 
 + assertEquals ( collection1 , collection ) ; 
 + assertEquals ( collection1 . size ( ) , 5 ) ; 
 + sharedRealm . close ( ) ; 
 + looperThread . testComplete ( ) ; 
 + } 
 + } ) ; 
 + addRow ( sharedRealm ) ; 
 + } 
 + 
 + @ Test 
 + public void size _ doesNotChangeAfterLocalCommit ( ) { 
 + final Collection collection = new Collection ( sharedRealm , table . where ( ) ) ; 
 + assertEquals ( collection . size ( ) , 4 ) ; 
 + addRow ( sharedRealm ) ; 
 + assertEquals ( collection . size ( ) , 4 ) ; 
 + sharedRealm . refresh ( ) ; 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Collection . cpp b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Collection . cpp 
 index ff1176a . . 0c82e4b 100644 
 - - - a / realm / realm - library / src / main / cpp / io _ realm _ internal _ Collection . cpp 
 + + + b / realm / realm - library / src / main / cpp / io _ realm _ internal _ Collection . cpp 
 @ @ - 251 , 6 + 251 , 8 @ @ Java _ io _ realm _ internal _ Collection _ nativeStartListening ( JNIEnv * env , jobject inst 
 std : : exception _ ptr err ) { 
 / / OS will call all notifiers ' callback in one run , so check the Java exception first ! ! 
 if ( env - > ExceptionCheck ( ) ) return ; 
 + / / No changes . 
 + if ( changes . empty ( ) ) return ; 
 
 env - > CallVoidMethod ( wrapper - > m _ collection _ weak _ ref , notify _ change _ listeners ) ; 
 } ;

NEAREST DIFF:
diff - - git a / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java b / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java 
 deleted file mode 100644 
 index 508f360 . . 0000000 
 - - - a / tightdb - java - test / src / test / java / com / tightdb / JNIDistinctTest . java 
 + + + / dev / null 
 @ @ - 1 , 78 + 0 , 0 @ @ 
 - package com . tightdb ; 
 - 
 - import static org . testng . AssertJUnit . * ; 
 - import org . testng . annotations . Test ; 
 - 
 - / / TODO : Check that Index can be set on multiple columns . 
 - 
 - @ SuppressWarnings ( " unused " ) 
 - public class JNIDistinctTest { 
 - Table table ; 
 - 
 - void init ( ) { 
 - table = new Table ( ) ; 
 - table . addColumn ( ColumnType . LONG , " number " ) ; 
 - table . addColumn ( ColumnType . STRING , " name " ) ; 
 - 
 - long i = 0 ; 
 - table . add ( 0 , " A " ) ; 
 - table . add ( 1 , " B " ) ; 
 - table . add ( 2 , " C " ) ; 
 - table . add ( 3 , " B " ) ; 
 - table . add ( 4 , " D " ) ; 
 - table . add ( 5 , " D " ) ; 
 - table . add ( 6 , " D " ) ; 
 - assertEquals ( 7 , table . size ( ) ) ; 
 - } 
 - 
 - @ Test 
 - public void shouldTestDistinct ( ) { 
 - init ( ) ; 
 - 
 - / / Must set index before using distinct ( ) 
 - table . setIndex ( 1 ) ; 
 - assertEquals ( true , table . hasIndex ( 1 ) ) ; 
 - 
 - TableView view = table . distinct ( 1 ) ; 
 - assertEquals ( 4 , view . size ( ) ) ; 
 - assertEquals ( 0 , view . getLong ( 0 , 0 ) ) ; 
 - assertEquals ( 1 , view . getLong ( 0 , 1 ) ) ; 
 - assertEquals ( 2 , view . getLong ( 0 , 2 ) ) ; 
 - assertEquals ( 4 , view . getLong ( 0 , 3 ) ) ; 
 - } 
 - 
 - @ Test ( expectedExceptions = UnsupportedOperationException . class ) 
 - public void shouldTestDistinctErrorWhenNoIndex ( ) { 
 - init ( ) ; 
 - TableView view = table . distinct ( 1 ) ; 
 - } 
 - 
 - @ Test ( expectedExceptions = ArrayIndexOutOfBoundsException . class ) 
 - public void shouldTestDistinctErrorWhenIndexOutOfBounds ( ) { 
 - init ( ) ; 
 - 
 - TableView view = table . distinct ( 3 ) ; 
 - } 
 - 
 - / / TODO : Check all other column types than String throws exception 
 - 
 - @ Test ( expectedExceptions = IllegalArgumentException . class ) 
 - public void shouldTestIndexOnWrongColumnType ( ) { 
 - init ( ) ; 
 - table . setIndex ( 0 ) ; 
 - } 
 - 
 - @ Test ( ) 
 - public void shouldCheckIndexIsOkOnColumn ( ) { 
 - init ( ) ; 
 - table . setIndex ( 1 ) ; 
 - } 
 - 
 - @ Test ( expectedExceptions = UnsupportedOperationException . class ) 
 - public void shouldTestDistinctErrorWhenWrongColumnType ( ) { 
 - init ( ) ; 
 - table . setIndex ( 1 ) ; 
 - TableView view = table . distinct ( 0 ) ; 
 - } 
 - 
 - } 
 diff - - git a / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java b / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java 
 new file mode 100644 
 index 0000000 . . 1da18ab 
 - - - / dev / null 
 + + + b / tightdb - java - test / src / test / java / com / tightdb / TableIndexAndDistinctTest . java 
 @ @ - 0 , 0 + 1 , 148 @ @ 
 + package com . tightdb ; 
 + 
 + import static org . testng . AssertJUnit . * ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . Date ; 
 + import java . util . Iterator ; 
 + import java . util . List ; 
 + 
 + import org . testng . annotations . DataProvider ; 
 + import org . testng . annotations . Test ; 
 + 
 + import com . tightdb . test . DataProviderUtil ; 
 + import com . tightdb . test . TestHelper ; 
 + 
 + 
 + @ SuppressWarnings ( " unused " ) 
 + public class TableIndexAndDistinctTest { 
 + Table table ; 
 + 
 + void init ( ) { 
 + table = new Table ( ) ; 
 + table . addColumn ( ColumnType . LONG , " number " ) ; 
 + table . addColumn ( ColumnType . STRING , " name " ) ; 
 + 
 + long i = 0 ; 
 + table . add ( 0 , " A " ) ; 
 + table . add ( 1 , " B " ) ; 
 + table . add ( 2 , " C " ) ; 
 + table . add ( 3 , " B " ) ; 
 + table . add ( 4 , " D " ) ; 
 + table . add ( 5 , " D " ) ; 
 + table . add ( 6 , " D " ) ; 
 + assertEquals ( 7 , table . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void shouldTestDistinct ( ) { 
 + init ( ) ; 
 + 
 + / / Must set index before using distinct ( ) 
 + table . setIndex ( 1 ) ; 
 + assertEquals ( true , table . hasIndex ( 1 ) ) ; 
 + 
 + TableView view = table . distinct ( 1 ) ; 
 + assertEquals ( 4 , view . size ( ) ) ; 
 + assertEquals ( 0 , view . getLong ( 0 , 0 ) ) ; 
 + assertEquals ( 1 , view . getLong ( 0 , 1 ) ) ; 
 + assertEquals ( 2 , view . getLong ( 0 , 2 ) ) ; 
 + assertEquals ( 4 , view . getLong ( 0 , 3 ) ) ; 
 + } 
 + 
 + 
 + 
 + / * * 
 + * Should throw exception if trying to get distinct on columns where index has not been set 
 + * @ param index 
 + * / 
 + @ Test ( expectedExceptions = UnsupportedOperationException . class , dataProvider = " columnIndex " ) 
 + public void shouldTestDistinctErrorWhenNoIndex ( Long index ) { 
 + 
 + / / Get a table with all available column types 
 + Table t = TestHelper . getTableWithAllColumnTypes ( ) ; 
 + 
 + TableView view = table . distinct ( 1 ) ; 
 + } 
 + 
 + @ Test ( expectedExceptions = ArrayIndexOutOfBoundsException . class ) 
 + public void shouldTestDistinctErrorWhenIndexOutOfBounds ( ) { 
 + init ( ) ; 
 + 
 + TableView view = table . distinct ( 3 ) ; 
 + } 
 + 
 + / * * 
 + * Checkd that Index can be set on multiple columns , with the String 
 + * @ param index 
 + * / 
 + public void shouldTestSettingIndexOnMultipleColumns ( ) { 
 + 
 + / / Create a table only with String type columns 
 + Table t = new Table ( ) ; 
 + t . addColumn ( ColumnType . STRING , " col1 " ) ; 
 + t . addColumn ( ColumnType . STRING , " col2 " ) ; 
 + t . addColumn ( ColumnType . STRING , " col3 " ) ; 
 + t . addColumn ( ColumnType . STRING , " col4 " ) ; 
 + t . addColumn ( ColumnType . STRING , " col5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + t . add ( " row1 " , " row2 " , " row3 " , " row4 " , " row5 " ) ; 
 + 
 + for ( long c = 0 ; c < t . getColumnCount ( ) ; c + + ) { 
 + t . setIndex ( c ) ; 
 + assertEquals ( true , t . hasIndex ( c ) ) ; 
 + } 
 + } 
 + 
 + 
 + / * * 
 + * Checks that all other column types than String throws exception . 
 + * @ param o 
 + * / 
 + @ Test ( expectedExceptions = IllegalArgumentException . class , dataProvider = " columnIndex " ) 
 + public void shouldTestIndexOnWrongColumnType ( Long index ) { 
 + 
 + / / Get a table with all available column types 
 + Table t = TestHelper . getTableWithAllColumnTypes ( ) ; 
 + 
 + / / If column type is String , then throw the excepted exception 
 + if ( t . getColumnType ( index ) . equals ( ColumnType . STRING ) ) { 
 + throw new IllegalArgumentException ( ) ; 
 + } 
 + 
 + t . setIndex ( index ) ; 
 + } 
 + 
 + @ Test ( ) 
 + public void shouldCheckIndexIsOkOnColumn ( ) { 
 + init ( ) ; 
 + table . setIndex ( 1 ) ; 
 + } 
 + 
 + @ Test ( expectedExceptions = UnsupportedOperationException . class ) 
 + public void shouldTestDistinctErrorWhenWrongColumnType ( ) { 
 + init ( ) ; 
 + table . setIndex ( 1 ) ; 
 + TableView view = table . distinct ( 0 ) ; 
 + } 
 + 
 + 
 + / * * 
 + * Is used to run a test multiple times , 
 + * that corresponds to the number of columns in the Table generated 
 + * in TestHelper . getTableWithAllColumnTypes 
 + * @ return 
 + * / 
 + @ DataProvider ( name = " columnIndex " ) 
 + public Iterator < Object [ ] > mixedValuesProvider ( ) { 
 + Long [ ] values = { 
 + 0L , 1L , 2L , 3L , 4L , 5L , 6L , 7L , 8L 
 + } ; 
 + 
 + List < ? > mixedValues = Arrays . asList ( values ) ; 
 + return DataProviderUtil . allCombinations ( mixedValues ) ; 
 + } 
 + }
