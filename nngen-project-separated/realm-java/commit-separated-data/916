BLEU SCORE: 0.03283637368030199

TEST MSG: log files are not deleted by deleteRealm
GENERATED MSG: add fix for # 1466

TEST DIFF (one line): diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java <nl> index a85ea51 . . 16eeec4 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 42 , 7 + 42 , 6 @ @ import java . util . concurrent . ExecutorService ; <nl> import java . util . concurrent . Executors ; <nl> import java . util . concurrent . Future ; <nl> import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . TimeoutException ; <nl> import java . util . concurrent . atomic . AtomicBoolean ; <nl> <nl> import io . realm . entities . AllTypes ; <nl> @ @ - 1744 , 6 + 1743 , 56 @ @ public class RealmTest extends AndroidTestCase { <nl> assertTrue ( tmpFile . createNewFile ( ) ) ; <nl> } <nl> <nl> + public void testDeleteRealmFile ( ) throws InterruptedException { <nl> + File tempDir = new File ( getContext ( ) . getFilesDir ( ) , " delete _ test _ dir " ) ; <nl> + if ( ! tempDir . exists ( ) ) { <nl> + tempDir . mkdir ( ) ; <nl> + } <nl> + <nl> + assertTrue ( tempDir . isDirectory ( ) ) ; <nl> + <nl> + / / Delete all files in the directory <nl> + for ( File file : tempDir . listFiles ( ) ) { <nl> + file . delete ( ) ; <nl> + } <nl> + <nl> + final RealmConfiguration configuration = new RealmConfiguration . Builder ( tempDir ) . build ( ) ; <nl> + <nl> + final CountDownLatch readyToCloseLatch = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch closedLatch = new CountDownLatch ( 1 ) ; <nl> + <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + / / Create another Realm to ensure the log files are generated <nl> + new Thread ( new Runnable ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + Realm realm = Realm . getInstance ( configuration ) ; <nl> + try { <nl> + readyToCloseLatch . await ( ) ; <nl> + } catch ( InterruptedException ignored ) { <nl> + } <nl> + realm . close ( ) ; <nl> + closedLatch . countDown ( ) ; <nl> + } <nl> + } ) . start ( ) ; <nl> + <nl> + realm . beginTransaction ( ) ; <nl> + realm . createObject ( AllTypes . class ) ; <nl> + realm . commitTransaction ( ) ; <nl> + readyToCloseLatch . countDown ( ) ; <nl> + realm . close ( ) ; <nl> + closedLatch . await ( ) ; <nl> + <nl> + / / ATTENTION : log , log _ a , log _ b will be deleted when the other thread close the Realm peacefully . And we force <nl> + / / user to close all Realm instances before deleting . It would be difficult to simulate a case that log files <nl> + / / exist before deletion . Let ' s keep the case like this for now , we might allow user to delete Realm even there <nl> + / / are instances opened in the future . <nl> + assertTrue ( Realm . deleteRealm ( configuration ) ) ; <nl> + <nl> + / / Directory should be empty now <nl> + assertEquals ( 0 , tempDir . listFiles ( ) . length ) ; <nl> + } <nl> + <nl> / / Test that all methods that require a transaction ( ie . any function that mutates Realm data ) <nl> public void testMutableMethodsOutsideTransactions ( ) throws JSONException , IOException { <nl> <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / BaseRealm . java b / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> index d7868a9 . . c1d0177 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / BaseRealm . java <nl> @ @ - 555 , 7 + 555 , 7 @ @ abstract class BaseRealm implements Closeable { <nl> / * * <nl> * Deletes the Realm file defined by the given configuration . <nl> * / <nl> - protected static boolean deleteRealm ( final RealmConfiguration configuration ) { <nl> + static boolean deleteRealm ( final RealmConfiguration configuration ) { <nl> final AtomicBoolean realmDeleted = new AtomicBoolean ( true ) ; <nl> <nl> RealmCache . invokeWithGlobalRefCount ( configuration , new RealmCache . Callback ( ) { <nl> @ @ - 571 , 8 + 571 , 8 @ @ abstract class BaseRealm implements Closeable { <nl> String realmFileName = configuration . getRealmFileName ( ) ; <nl> List < File > filesToDelete = Arrays . asList ( new File ( canonicalPath ) , <nl> new File ( realmFolder , realmFileName + " . lock " ) , <nl> - new File ( realmFolder , realmFileName + " . lock _ a " ) , <nl> - new File ( realmFolder , realmFileName + " . lock _ b " ) , <nl> + new File ( realmFolder , realmFileName + " . log _ a " ) , <nl> + new File ( realmFolder , realmFileName + " . log _ b " ) , <nl> new File ( realmFolder , realmFileName + " . log " ) ) ; <nl> for ( File fileToDelete : filesToDelete ) { <nl> if ( fileToDelete . exists ( ) ) {
NEAREST DIFF (one line): diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index 9692993 . . 013a15f 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 1865 , 6 + 1865 , 66 @ @ public class RealmTest extends AndroidTestCase { <nl> assertTrue ( future . get ( 10 , TimeUnit . SECONDS ) ) ; <nl> } <nl> <nl> + / / Realm validation & initialization is done once , still ColumnIndices <nl> + / / should be populated for the subsequent Realm sharing the same configuration <nl> + / / even if we skip initialization & validation <nl> + public void testColumnIndicesIsPopulatedWhenSkippingInitialization ( ) throws Throwable { <nl> + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; <nl> + final CountDownLatch callerThreadCompleted = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch signalBgFinished = new CountDownLatch ( 1 ) ; <nl> + final RealmConfiguration realmConfiguration = TestHelper . <nl> + createConfiguration ( getContext ( ) , " testColumnIndicesIsPopulatedWhenSkippingInitialization " ) ; <nl> + Realm . deleteRealm ( realmConfiguration ) ; <nl> + Realm realm = Realm . getInstance ( realmConfiguration ) ; <nl> + <nl> + realm . beginTransaction ( ) ; <nl> + realm . createObject ( AllTypes . class ) . setColumnLong ( 42 ) ; <nl> + realm . commitTransaction ( ) ; <nl> + <nl> + RealmResults < AllTypes > all = realm . where ( AllTypes . class ) . findAll ( ) ; <nl> + assertNotNull ( all ) ; <nl> + assertEquals ( 1 , all . size ( ) ) ; <nl> + assertEquals ( 42 , all . get ( 0 ) . getColumnLong ( ) ) ; <nl> + <nl> + / / open a background Realm <nl> + new Thread ( ) { <nl> + @ Override <nl> + public void run ( ) { <nl> + try { <nl> + callerThreadCompleted . await ( ) ; <nl> + Realm backgroundRealm = Realm . getInstance ( realmConfiguration ) ; <nl> + <nl> + backgroundRealm . beginTransaction ( ) ; <nl> + backgroundRealm . createObject ( AllTypes . class ) . setColumnLong ( 7 ) ; <nl> + backgroundRealm . commitTransaction ( ) ; <nl> + <nl> + RealmResults < AllTypes > allBg = backgroundRealm . where ( AllTypes . class ) . findAll ( ) ; <nl> + assertNotNull ( allBg ) ; <nl> + assertEquals ( 2 , allBg . size ( ) ) ; <nl> + assertEquals ( 42 , allBg . get ( 0 ) . getColumnLong ( ) ) ; <nl> + assertEquals ( 7 , allBg . get ( 1 ) . getColumnLong ( ) ) ; <nl> + <nl> + backgroundRealm . close ( ) ; <nl> + <nl> + <nl> + <nl> + } catch ( InterruptedException e ) { <nl> + threadAssertionError [ 0 ] = e ; <nl> + } catch ( AssertionFailedError e ) { <nl> + threadAssertionError [ 0 ] = e ; <nl> + <nl> + } finally { <nl> + signalBgFinished . countDown ( ) ; <nl> + } <nl> + } <nl> + } . start ( ) ; <nl> + <nl> + callerThreadCompleted . countDown ( ) ; <nl> + signalBgFinished . await ( ) ; <nl> + if ( threadAssertionError [ 0 ] ! = null ) <nl> + throw threadAssertionError [ 0 ] ; <nl> + } <nl> + <nl> public void testProcessLocalListenersAfterRefresh ( ) { <nl> / / Used to validate the result <nl> final AtomicBoolean listenerWasCalled = new AtomicBoolean ( false ) ; <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index 2828617 . . d010795 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 779 , 6 + 779 , 8 @ @ public final class Realm implements Closeable { <nl> realm . close ( ) ; <nl> throw e ; <nl> } <nl> + } else { <nl> + loadMediatorClasses ( realm ) ; <nl> } <nl> <nl> return realm ; <nl> @ @ - 856 , 6 + 858 , 13 @ @ public final class Realm implements Closeable { <nl> } <nl> } <nl> <nl> + private static void loadMediatorClasses ( Realm realm ) { <nl> + RealmProxyMediator mediator = realm . configuration . getSchemaMediator ( ) ; <nl> + for ( Class < ? extends RealmObject > modelClass : mediator . getModelClasses ( ) ) { <nl> + realm . columnIndices . addClass ( modelClass , mediator . getColumnIndices ( modelClass ) ) ; <nl> + } <nl> + } <nl> + <nl> / * * <nl> * Create a Realm object for each object in a JSON array . This must be done within a transaction . <nl> * JSON properties with a null value will map to the default value for the data type in Realm

TEST DIFF:
diff - - git a / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java b / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java 
 index a85ea51 . . 16eeec4 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 42 , 7 + 42 , 6 @ @ import java . util . concurrent . ExecutorService ; 
 import java . util . concurrent . Executors ; 
 import java . util . concurrent . Future ; 
 import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . TimeoutException ; 
 import java . util . concurrent . atomic . AtomicBoolean ; 
 
 import io . realm . entities . AllTypes ; 
 @ @ - 1744 , 6 + 1743 , 56 @ @ public class RealmTest extends AndroidTestCase { 
 assertTrue ( tmpFile . createNewFile ( ) ) ; 
 } 
 
 + public void testDeleteRealmFile ( ) throws InterruptedException { 
 + File tempDir = new File ( getContext ( ) . getFilesDir ( ) , " delete _ test _ dir " ) ; 
 + if ( ! tempDir . exists ( ) ) { 
 + tempDir . mkdir ( ) ; 
 + } 
 + 
 + assertTrue ( tempDir . isDirectory ( ) ) ; 
 + 
 + / / Delete all files in the directory 
 + for ( File file : tempDir . listFiles ( ) ) { 
 + file . delete ( ) ; 
 + } 
 + 
 + final RealmConfiguration configuration = new RealmConfiguration . Builder ( tempDir ) . build ( ) ; 
 + 
 + final CountDownLatch readyToCloseLatch = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch closedLatch = new CountDownLatch ( 1 ) ; 
 + 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + / / Create another Realm to ensure the log files are generated 
 + new Thread ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + Realm realm = Realm . getInstance ( configuration ) ; 
 + try { 
 + readyToCloseLatch . await ( ) ; 
 + } catch ( InterruptedException ignored ) { 
 + } 
 + realm . close ( ) ; 
 + closedLatch . countDown ( ) ; 
 + } 
 + } ) . start ( ) ; 
 + 
 + realm . beginTransaction ( ) ; 
 + realm . createObject ( AllTypes . class ) ; 
 + realm . commitTransaction ( ) ; 
 + readyToCloseLatch . countDown ( ) ; 
 + realm . close ( ) ; 
 + closedLatch . await ( ) ; 
 + 
 + / / ATTENTION : log , log _ a , log _ b will be deleted when the other thread close the Realm peacefully . And we force 
 + / / user to close all Realm instances before deleting . It would be difficult to simulate a case that log files 
 + / / exist before deletion . Let ' s keep the case like this for now , we might allow user to delete Realm even there 
 + / / are instances opened in the future . 
 + assertTrue ( Realm . deleteRealm ( configuration ) ) ; 
 + 
 + / / Directory should be empty now 
 + assertEquals ( 0 , tempDir . listFiles ( ) . length ) ; 
 + } 
 + 
 / / Test that all methods that require a transaction ( ie . any function that mutates Realm data ) 
 public void testMutableMethodsOutsideTransactions ( ) throws JSONException , IOException { 
 
 diff - - git a / realm / realm - library / src / main / java / io / realm / BaseRealm . java b / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 index d7868a9 . . c1d0177 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / BaseRealm . java 
 @ @ - 555 , 7 + 555 , 7 @ @ abstract class BaseRealm implements Closeable { 
 / * * 
 * Deletes the Realm file defined by the given configuration . 
 * / 
 - protected static boolean deleteRealm ( final RealmConfiguration configuration ) { 
 + static boolean deleteRealm ( final RealmConfiguration configuration ) { 
 final AtomicBoolean realmDeleted = new AtomicBoolean ( true ) ; 
 
 RealmCache . invokeWithGlobalRefCount ( configuration , new RealmCache . Callback ( ) { 
 @ @ - 571 , 8 + 571 , 8 @ @ abstract class BaseRealm implements Closeable { 
 String realmFileName = configuration . getRealmFileName ( ) ; 
 List < File > filesToDelete = Arrays . asList ( new File ( canonicalPath ) , 
 new File ( realmFolder , realmFileName + " . lock " ) , 
 - new File ( realmFolder , realmFileName + " . lock _ a " ) , 
 - new File ( realmFolder , realmFileName + " . lock _ b " ) , 
 + new File ( realmFolder , realmFileName + " . log _ a " ) , 
 + new File ( realmFolder , realmFileName + " . log _ b " ) , 
 new File ( realmFolder , realmFileName + " . log " ) ) ; 
 for ( File fileToDelete : filesToDelete ) { 
 if ( fileToDelete . exists ( ) ) {

NEAREST DIFF:
diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index 9692993 . . 013a15f 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 1865 , 6 + 1865 , 66 @ @ public class RealmTest extends AndroidTestCase { 
 assertTrue ( future . get ( 10 , TimeUnit . SECONDS ) ) ; 
 } 
 
 + / / Realm validation & initialization is done once , still ColumnIndices 
 + / / should be populated for the subsequent Realm sharing the same configuration 
 + / / even if we skip initialization & validation 
 + public void testColumnIndicesIsPopulatedWhenSkippingInitialization ( ) throws Throwable { 
 + final Throwable [ ] threadAssertionError = new Throwable [ 1 ] ; 
 + final CountDownLatch callerThreadCompleted = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch signalBgFinished = new CountDownLatch ( 1 ) ; 
 + final RealmConfiguration realmConfiguration = TestHelper . 
 + createConfiguration ( getContext ( ) , " testColumnIndicesIsPopulatedWhenSkippingInitialization " ) ; 
 + Realm . deleteRealm ( realmConfiguration ) ; 
 + Realm realm = Realm . getInstance ( realmConfiguration ) ; 
 + 
 + realm . beginTransaction ( ) ; 
 + realm . createObject ( AllTypes . class ) . setColumnLong ( 42 ) ; 
 + realm . commitTransaction ( ) ; 
 + 
 + RealmResults < AllTypes > all = realm . where ( AllTypes . class ) . findAll ( ) ; 
 + assertNotNull ( all ) ; 
 + assertEquals ( 1 , all . size ( ) ) ; 
 + assertEquals ( 42 , all . get ( 0 ) . getColumnLong ( ) ) ; 
 + 
 + / / open a background Realm 
 + new Thread ( ) { 
 + @ Override 
 + public void run ( ) { 
 + try { 
 + callerThreadCompleted . await ( ) ; 
 + Realm backgroundRealm = Realm . getInstance ( realmConfiguration ) ; 
 + 
 + backgroundRealm . beginTransaction ( ) ; 
 + backgroundRealm . createObject ( AllTypes . class ) . setColumnLong ( 7 ) ; 
 + backgroundRealm . commitTransaction ( ) ; 
 + 
 + RealmResults < AllTypes > allBg = backgroundRealm . where ( AllTypes . class ) . findAll ( ) ; 
 + assertNotNull ( allBg ) ; 
 + assertEquals ( 2 , allBg . size ( ) ) ; 
 + assertEquals ( 42 , allBg . get ( 0 ) . getColumnLong ( ) ) ; 
 + assertEquals ( 7 , allBg . get ( 1 ) . getColumnLong ( ) ) ; 
 + 
 + backgroundRealm . close ( ) ; 
 + 
 + 
 + 
 + } catch ( InterruptedException e ) { 
 + threadAssertionError [ 0 ] = e ; 
 + } catch ( AssertionFailedError e ) { 
 + threadAssertionError [ 0 ] = e ; 
 + 
 + } finally { 
 + signalBgFinished . countDown ( ) ; 
 + } 
 + } 
 + } . start ( ) ; 
 + 
 + callerThreadCompleted . countDown ( ) ; 
 + signalBgFinished . await ( ) ; 
 + if ( threadAssertionError [ 0 ] ! = null ) 
 + throw threadAssertionError [ 0 ] ; 
 + } 
 + 
 public void testProcessLocalListenersAfterRefresh ( ) { 
 / / Used to validate the result 
 final AtomicBoolean listenerWasCalled = new AtomicBoolean ( false ) ; 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index 2828617 . . d010795 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 779 , 6 + 779 , 8 @ @ public final class Realm implements Closeable { 
 realm . close ( ) ; 
 throw e ; 
 } 
 + } else { 
 + loadMediatorClasses ( realm ) ; 
 } 
 
 return realm ; 
 @ @ - 856 , 6 + 858 , 13 @ @ public final class Realm implements Closeable { 
 } 
 } 
 
 + private static void loadMediatorClasses ( Realm realm ) { 
 + RealmProxyMediator mediator = realm . configuration . getSchemaMediator ( ) ; 
 + for ( Class < ? extends RealmObject > modelClass : mediator . getModelClasses ( ) ) { 
 + realm . columnIndices . addClass ( modelClass , mediator . getColumnIndices ( modelClass ) ) ; 
 + } 
 + } 
 + 
 / * * 
 * Create a Realm object for each object in a JSON array . This must be done within a transaction . 
 * JSON properties with a null value will map to the default value for the data type in Realm
