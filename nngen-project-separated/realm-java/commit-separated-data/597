BLEU SCORE: 0.01317095981362614

TEST MSG: Make RealmAsyncTask into an interface
GENERATED MSG: Clean up native row accessor from the same thread that created them

TEST DIFF (one line): diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> index 4bc0c25 . . c549ae6 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / Realm . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / Realm . java <nl> @ @ - 57 , 6 + 57 , 7 @ @ import io . realm . internal . RealmCore ; <nl> import io . realm . internal . RealmObjectProxy ; <nl> import io . realm . internal . RealmProxyMediator ; <nl> import io . realm . internal . Table ; <nl> + import io . realm . internal . async . RealmAsyncTaskImpl ; <nl> import io . realm . log . AndroidLogger ; <nl> import io . realm . log . RealmLog ; <nl> import rx . Observable ; <nl> @ @ - 1414 , 7 + 1415 , 7 @ @ public final class Realm extends BaseRealm { <nl> } <nl> } ) ; <nl> <nl> - return new RealmAsyncTask ( pendingTransaction , asyncTaskExecutor ) ; <nl> + return new RealmAsyncTaskImpl ( pendingTransaction , asyncTaskExecutor ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmAsyncTask . java b / realm / realm - library / src / main / java / io / realm / RealmAsyncTask . java <nl> index e2733a7 . . 28fceab 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmAsyncTask . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmAsyncTask . java <nl> @ @ - 16 , 9 + 16 , 6 @ @ <nl> <nl> package io . realm ; <nl> <nl> - import java . util . concurrent . Future ; <nl> - import java . util . concurrent . ThreadPoolExecutor ; <nl> - <nl> / * * <nl> * Represents a pending asynchronous Realm transaction . <nl> * < p > <nl> @ @ - 26 , 41 + 23 , 18 @ @ import java . util . concurrent . ThreadPoolExecutor ; <nl> * case of a configuration change for example ( to avoid memory leak , as the transaction will post the result to the <nl> * caller ' s thread callback ) . <nl> * / <nl> - public final class RealmAsyncTask { <nl> - private final Future < ? > pendingTask ; <nl> - private final ThreadPoolExecutor service ; <nl> - private volatile boolean isCancelled = false ; <nl> - <nl> - public RealmAsyncTask ( Future < ? > pendingTask , ThreadPoolExecutor service ) { <nl> - this . pendingTask = pendingTask ; <nl> - this . service = service ; <nl> - } <nl> + public interface RealmAsyncTask { <nl> <nl> / * * <nl> * Attempts to cancel execution of this transaction ( if it hasn ' t already completed or previously cancelled ) . <nl> * / <nl> - public void cancel ( ) { <nl> - pendingTask . cancel ( true ) ; <nl> - isCancelled = true ; <nl> - <nl> - / / From " Java Threads " : By Scott Oaks & Henry Wong <nl> - / / cancelled tasks are never executed , but may <nl> - / / accumulate in work queues , which may causes a memory leak <nl> - / / if the task hold references ( to an enclosing class for example ) <nl> - / / we can use purge ( ) but one caveat applies : if a second thread attempts to add <nl> - / / something to the pool ( using the execute ( ) method ) at the same time the <nl> - / / first thread is attempting to purge the queue the attempt to purge <nl> - / / the queue fails and the cancelled object remain in the queue . <nl> - / / A better way to cancel objects with thread pools is to use the remove ( ) <nl> - service . getQueue ( ) . remove ( pendingTask ) ; <nl> - } <nl> + void cancel ( ) ; <nl> <nl> / * * <nl> * Checks whether an attempt to cancel the transaction was performed . <nl> * <nl> * @ return { @ code true } if { @ link # cancel ( ) } has already been called , { @ code false } otherwise . <nl> * / <nl> - public boolean isCancelled ( ) { <nl> - return isCancelled ; <nl> - } <nl> + boolean isCancelled ( ) ; <nl> } <nl> + <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / User . java b / realm / realm - library / src / main / java / io / realm / User . java <nl> index 85a9a08 . . 1cf9af3 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / User . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / User . java <nl> @ @ - 34 , 6 + 34 , 7 @ @ import java . util . concurrent . ThreadPoolExecutor ; <nl> <nl> import io . realm . internal . IOException ; <nl> import io . realm . internal . Util ; <nl> + import io . realm . internal . async . RealmAsyncTaskImpl ; <nl> import io . realm . internal . objectserver . SyncUser ; <nl> import io . realm . internal . objectserver . Token ; <nl> import io . realm . internal . network . AuthenticateResponse ; <nl> @ @ - 181 , 7 + 182 , 7 @ @ public class User { <nl> } <nl> } ) ; <nl> <nl> - return new RealmAsyncTask ( authenticateRequest , networkPoolExecutor ) ; <nl> + return new RealmAsyncTaskImpl ( authenticateRequest , networkPoolExecutor ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / async / RealmAsyncTaskImpl . java b / realm / realm - library / src / main / java / io / realm / internal / async / RealmAsyncTaskImpl . java <nl> new file mode 100644 <nl> index 0000000 . . d523c9a <nl> - - - / dev / null <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / async / RealmAsyncTaskImpl . java <nl> @ @ - 0 , 0 + 1 , 59 @ @ <nl> + / * <nl> + * Copyright 2016 Realm Inc . <nl> + * <nl> + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; <nl> + * you may not use this file except in compliance with the License . <nl> + * You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package io . realm . internal . async ; <nl> + <nl> + import java . util . concurrent . Future ; <nl> + import java . util . concurrent . ThreadPoolExecutor ; <nl> + <nl> + import io . realm . RealmAsyncTask ; <nl> + <nl> + public final class RealmAsyncTaskImpl implements RealmAsyncTask { <nl> + private final Future < ? > pendingTask ; <nl> + private final ThreadPoolExecutor service ; <nl> + private volatile boolean isCancelled = false ; <nl> + <nl> + public RealmAsyncTaskImpl ( Future < ? > pendingTask , ThreadPoolExecutor service ) { <nl> + this . pendingTask = pendingTask ; <nl> + this . service = service ; <nl> + } <nl> + <nl> + / * * <nl> + * { @ inheritDoc } <nl> + * / <nl> + public void cancel ( ) { <nl> + pendingTask . cancel ( true ) ; <nl> + isCancelled = true ; <nl> + <nl> + / / From " Java Threads " : By Scott Oaks & Henry Wong <nl> + / / cancelled tasks are never executed , but may <nl> + / / accumulate in work queues , which may causes a memory leak <nl> + / / if the task hold references ( to an enclosing class for example ) <nl> + / / we can use purge ( ) but one caveat applies : if a second thread attempts to add <nl> + / / something to the pool ( using the execute ( ) method ) at the same time the <nl> + / / first thread is attempting to purge the queue the attempt to purge <nl> + / / the queue fails and the cancelled object remain in the queue . <nl> + / / A better way to cancel objects with thread pools is to use the remove ( ) <nl> + service . getQueue ( ) . remove ( pendingTask ) ; <nl> + } <nl> + <nl> + / * * <nl> + * { @ inheritDoc } <nl> + * / <nl> + public boolean isCancelled ( ) { <nl> + return isCancelled ; <nl> + } <nl> + } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncSession . java b / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncSession . java <nl> index 49cbf98 . . 79fc9ae 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncSession . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncSession . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ import java . util . concurrent . Future ; <nl> <nl> import io . realm . RealmAsyncTask ; <nl> import io . realm . internal . Keep ; <nl> + import io . realm . internal . async . RealmAsyncTaskImpl ; <nl> import io . realm . log . RealmLog ; <nl> import io . realm . ErrorCode ; <nl> import io . realm . ObjectServerError ; <nl> @ @ - 279 , 7 + 280 , 7 @ @ public final class SyncSession { <nl> errorHandler . onError ( getUserSession ( ) , response . getError ( ) ) ; <nl> } <nl> } ) ; <nl> - networkRequest = new RealmAsyncTask ( task , SyncManager . NETWORK _ POOL _ EXECUTOR ) ; <nl> + networkRequest = new RealmAsyncTaskImpl ( task , SyncManager . NETWORK _ POOL _ EXECUTOR ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncUser . java b / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncUser . java <nl> index fcbcb96 . . 2e9d845 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncUser . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncUser . java <nl> @ @ - 35 , 6 + 35 , 7 @ @ import io . realm . Session ; <nl> import io . realm . SyncConfiguration ; <nl> import io . realm . SyncManager ; <nl> import io . realm . User ; <nl> + import io . realm . internal . async . RealmAsyncTaskImpl ; <nl> import io . realm . internal . network . AuthenticationServer ; <nl> import io . realm . internal . network . ExponentialBackoffTask ; <nl> import io . realm . internal . network . RefreshResponse ; <nl> @ @ - 95 , 7 + 96 , 7 @ @ public class SyncUser { <nl> <nl> } <nl> } ) ; <nl> - refreshTask = new RealmAsyncTask ( task , SyncManager . NETWORK _ POOL _ EXECUTOR ) ; <nl> + refreshTask = new RealmAsyncTaskImpl ( task , SyncManager . NETWORK _ POOL _ EXECUTOR ) ; <nl> } <nl> <nl> / * *
NEAREST DIFF (one line): diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> index 588b51d . . 73cdd9a 100644 <nl> - - - a / realm / src / androidTest / java / io / realm / RealmTest . java <nl> + + + b / realm / src / androidTest / java / io / realm / RealmTest . java <nl> @ @ - 18 , 6 + 18 , 7 @ @ package io . realm ; <nl> import android . content . Context ; <nl> import android . os . SystemClock ; <nl> import android . test . AndroidTestCase ; <nl> + import android . util . Log ; <nl> <nl> import junit . framework . AssertionFailedError ; <nl> <nl> @ @ - 34 , 7 + 35 , 6 @ @ import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> import java . util . Date ; <nl> import java . util . List ; <nl> - import java . util . Map ; <nl> import java . util . Random ; <nl> import java . util . Scanner ; <nl> import java . util . concurrent . Callable ; <nl> @ @ - 62 , 7 + 62 , 7 @ @ import io . realm . entities . PrimaryKeyMix ; <nl> import io . realm . entities . StringOnly ; <nl> import io . realm . exceptions . RealmException ; <nl> import io . realm . exceptions . RealmIOException ; <nl> - import io . realm . internal . FinalizerRunnable ; <nl> + import io . realm . internal . SharedGroup ; <nl> import io . realm . internal . Table ; <nl> <nl> import static io . realm . internal . test . ExtraTests . assertArrayEquals ; <nl> @ @ - 1685 , 42 + 1685 , 51 @ @ public class RealmTest extends AndroidTestCase { <nl> } <nl> <nl> / / Check that FinalizerRunnable can free native resources ( phantom refs ) <nl> - public void testFinalizerThread ( ) throws NoSuchFieldException , IllegalAccessException { <nl> - Field fieldReferences = FinalizerRunnable . class . getDeclaredField ( " references " ) ; <nl> - fieldReferences . setAccessible ( true ) ; <nl> - Map < Reference < ? > , Boolean > references = ( Map < Reference < ? > , Boolean > ) fieldReferences . get ( null ) ; <nl> - assertNotNull ( references ) ; <nl> - <nl> - Field fieldIsFinalizerStarted = Realm . class . getDeclaredField ( " isFinalizerStarted " ) ; <nl> - fieldIsFinalizerStarted . setAccessible ( true ) ; <nl> - boolean isFinalizerStarted = fieldIsFinalizerStarted . getBoolean ( null ) ; <nl> - assertTrue ( isFinalizerStarted ) ; <nl> - <nl> - / / insert some rows , then give the FinalizerRunnable some time to cleanup <nl> + public void testReferenceCleaning ( ) throws NoSuchFieldException , IllegalAccessException { <nl> + Field sharedGroupReference = Realm . class . getDeclaredField ( " sharedGroup " ) ; <nl> + sharedGroupReference . setAccessible ( true ) ; <nl> + SharedGroup sharedGroup = ( SharedGroup ) sharedGroupReference . get ( testRealm ) ; <nl> + assertNotNull ( sharedGroup ) ; <nl> + <nl> + Field contextField = SharedGroup . class . getDeclaredField ( " context " ) ; <nl> + contextField . setAccessible ( true ) ; <nl> + io . realm . internal . Context context = ( io . realm . internal . Context ) contextField . get ( sharedGroup ) ; <nl> + assertNotNull ( context ) ; <nl> + <nl> + Field rowReferencesField = io . realm . internal . Context . class . getDeclaredField ( " rowReferences " ) ; <nl> + rowReferencesField . setAccessible ( true ) ; <nl> + List < Reference < ? > > rowReferences = ( List < Reference < ? > > ) rowReferencesField . get ( context ) ; <nl> + assertNotNull ( rowReferences ) ; <nl> + <nl> + <nl> + / / insert some rows , then give the thread some time to cleanup <nl> / / we have 8 reference so far let ' s add more <nl> final int numberOfPopulateTest = 10000 ; <nl> final int totalNumberOfReferences = 8 + 20 * 2 * numberOfPopulateTest ; <nl> <nl> + long tic = System . currentTimeMillis ( ) ; <nl> for ( int i = 0 ; i < numberOfPopulateTest ; i + + ) { <nl> populateTestRealm ( testRealm , 20 ) ; <nl> } <nl> + long toc = System . currentTimeMillis ( ) ; <nl> + Log . d ( RealmTest . class . getName ( ) , " Insertion time : " + ( toc - tic ) ) ; <nl> <nl> final int MAX _ GC _ RETRIES = 5 ; <nl> int numberOfRetries = 0 ; <nl> - while ( references . size ( ) > 0 & & numberOfRetries < MAX _ GC _ RETRIES ) { <nl> + while ( rowReferences . size ( ) > 0 & & numberOfRetries < MAX _ GC _ RETRIES ) { <nl> SystemClock . sleep ( TimeUnit . SECONDS . toMillis ( 1 ) ) ; / / 1s <nl> numberOfRetries + + ; <nl> System . gc ( ) ; <nl> } <nl> <nl> / / we can ' t guarantee that all references have been GC ' d but we should detect a decrease <nl> - boolean isDecreasing = references . size ( ) < totalNumberOfReferences ; <nl> + boolean isDecreasing = rowReferences . size ( ) < totalNumberOfReferences ; <nl> if ( ! isDecreasing ) { <nl> fail ( " FinalizerRunnable is not closing all native resources " ) ; <nl> <nl> } else { <nl> - android . util . Log . d ( RealmTest . class . getName ( ) , " FinalizerRunnable freed : " <nl> - + ( totalNumberOfReferences - references . size ( ) ) + " out of " + totalNumberOfReferences ) ; <nl> + android . util . Log . d ( RealmTest . class . getName ( ) , " References freed : " <nl> + + ( totalNumberOfReferences - rowReferences . size ( ) ) + " out of " + totalNumberOfReferences ) ; <nl> } <nl> } <nl> <nl> diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java <nl> index 764eb1e . . 3f29fc2 100644 <nl> - - - a / realm / src / main / java / io / realm / Realm . java <nl> + + + b / realm / src / main / java / io / realm / Realm . java <nl> @ @ - 54 , 14 + 54 , 13 @ @ import io . realm . exceptions . RealmIOException ; <nl> import io . realm . exceptions . RealmMigrationNeededException ; <nl> import io . realm . internal . ColumnIndices ; <nl> import io . realm . internal . ColumnType ; <nl> - import io . realm . internal . FinalizerRunnable ; <nl> import io . realm . internal . ImplicitTransaction ; <nl> import io . realm . internal . RealmObjectProxy ; <nl> import io . realm . internal . RealmProxyMediator ; <nl> - import io . realm . internal . UncheckedRow ; <nl> import io . realm . internal . SharedGroup ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableView ; <nl> + import io . realm . internal . UncheckedRow ; <nl> import io . realm . internal . Util ; <nl> import io . realm . internal . android . DebugAndroidLogger ; <nl> import io . realm . internal . android . ReleaseAndroidLogger ; <nl> @ @ - 573 , 12 + 572 , 6 @ @ public final class Realm implements Closeable { <nl> } <nl> <nl> private static synchronized Realm createAndValidate ( RealmConfiguration configuration , boolean validateSchema , boolean autoRefresh ) { <nl> - / / Start the finalizer thread if needed <nl> - if ( ! isFinalizerStarted ) { <nl> - executorService . submit ( new FinalizerRunnable ( ) ) ; <nl> - isFinalizerStarted = true ; <nl> - } <nl> - <nl> / / Check if a cached instance already exists for this thread <nl> String canonicalPath = configuration . getPath ( ) ; <nl> Map < RealmConfiguration , Integer > localRefCount = referenceCount . get ( ) ; <nl> diff - - git a / realm / src / main / java / io / realm / internal / Context . java b / realm / src / main / java / io / realm / internal / Context . java <nl> index b2a7858 . . 4e5fbc8 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / Context . java <nl> + + + b / realm / src / main / java / io / realm / internal / Context . java <nl> @ @ - 16 , 10 + 16 , 12 @ @ <nl> <nl> package io . realm . internal ; <nl> <nl> + import java . lang . ref . Reference ; <nl> + import java . lang . ref . ReferenceQueue ; <nl> import java . util . ArrayList ; <nl> import java . util . List ; <nl> <nl> - class Context { <nl> + public class Context { <nl> <nl> / / Each group of related Realm objects will have a Context object in the root . <nl> / / The root can be a table , a group , or a shared group . <nl> @ @ - 31 , 6 + 33 , 9 @ @ class Context { <nl> private List < Long > abandonedTableViews = new ArrayList < Long > ( ) ; <nl> private List < Long > abandonedQueries = new ArrayList < Long > ( ) ; <nl> <nl> + List < Reference < ? > > rowReferences = new ArrayList < Reference < ? > > ( ) ; <nl> + ReferenceQueue < NativeObject > referenceQueue = new ReferenceQueue < NativeObject > ( ) ; <nl> + <nl> private boolean isFinalized = false ; <nl> <nl> public void executeDelayedDisposal ( ) { <nl> @ @ - 52 , 6 + 57 , 17 @ @ class Context { <nl> TableQuery . nativeClose ( nativePointer ) ; <nl> } <nl> abandonedQueries . clear ( ) ; <nl> + <nl> + cleanRows ( ) ; <nl> + } <nl> + } <nl> + <nl> + public void cleanRows ( ) { <nl> + NativeObjectReference reference = ( NativeObjectReference ) referenceQueue . poll ( ) ; <nl> + while ( reference ! = null ) { <nl> + UncheckedRow . nativeClose ( reference . nativePointer ) ; <nl> + rowReferences . remove ( reference ) ; <nl> + reference = ( NativeObjectReference ) referenceQueue . poll ( ) ; <nl> } <nl> } <nl> <nl> diff - - git a / realm / src / main / java / io / realm / internal / UncheckedRow . java b / realm / src / main / java / io / realm / internal / UncheckedRow . java <nl> index 04b0573 . . 9127924 100644 <nl> - - - a / realm / src / main / java / io / realm / internal / UncheckedRow . java <nl> + + + b / realm / src / main / java / io / realm / internal / UncheckedRow . java <nl> @ @ - 36 , 6 + 36 , 8 @ @ public class UncheckedRow extends NativeObject implements Row { <nl> this . context = context ; <nl> this . parent = parent ; <nl> this . nativePointer = nativePtr ; <nl> + <nl> + context . cleanRows ( ) ; <nl> } <nl> <nl> / * *

TEST DIFF:
diff - - git a / realm / realm - library / src / main / java / io / realm / Realm . java b / realm / realm - library / src / main / java / io / realm / Realm . java 
 index 4bc0c25 . . c549ae6 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / Realm . java 
 + + + b / realm / realm - library / src / main / java / io / realm / Realm . java 
 @ @ - 57 , 6 + 57 , 7 @ @ import io . realm . internal . RealmCore ; 
 import io . realm . internal . RealmObjectProxy ; 
 import io . realm . internal . RealmProxyMediator ; 
 import io . realm . internal . Table ; 
 + import io . realm . internal . async . RealmAsyncTaskImpl ; 
 import io . realm . log . AndroidLogger ; 
 import io . realm . log . RealmLog ; 
 import rx . Observable ; 
 @ @ - 1414 , 7 + 1415 , 7 @ @ public final class Realm extends BaseRealm { 
 } 
 } ) ; 
 
 - return new RealmAsyncTask ( pendingTransaction , asyncTaskExecutor ) ; 
 + return new RealmAsyncTaskImpl ( pendingTransaction , asyncTaskExecutor ) ; 
 } 
 
 / * * 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmAsyncTask . java b / realm / realm - library / src / main / java / io / realm / RealmAsyncTask . java 
 index e2733a7 . . 28fceab 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmAsyncTask . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmAsyncTask . java 
 @ @ - 16 , 9 + 16 , 6 @ @ 
 
 package io . realm ; 
 
 - import java . util . concurrent . Future ; 
 - import java . util . concurrent . ThreadPoolExecutor ; 
 - 
 / * * 
 * Represents a pending asynchronous Realm transaction . 
 * < p > 
 @ @ - 26 , 41 + 23 , 18 @ @ import java . util . concurrent . ThreadPoolExecutor ; 
 * case of a configuration change for example ( to avoid memory leak , as the transaction will post the result to the 
 * caller ' s thread callback ) . 
 * / 
 - public final class RealmAsyncTask { 
 - private final Future < ? > pendingTask ; 
 - private final ThreadPoolExecutor service ; 
 - private volatile boolean isCancelled = false ; 
 - 
 - public RealmAsyncTask ( Future < ? > pendingTask , ThreadPoolExecutor service ) { 
 - this . pendingTask = pendingTask ; 
 - this . service = service ; 
 - } 
 + public interface RealmAsyncTask { 
 
 / * * 
 * Attempts to cancel execution of this transaction ( if it hasn ' t already completed or previously cancelled ) . 
 * / 
 - public void cancel ( ) { 
 - pendingTask . cancel ( true ) ; 
 - isCancelled = true ; 
 - 
 - / / From " Java Threads " : By Scott Oaks & Henry Wong 
 - / / cancelled tasks are never executed , but may 
 - / / accumulate in work queues , which may causes a memory leak 
 - / / if the task hold references ( to an enclosing class for example ) 
 - / / we can use purge ( ) but one caveat applies : if a second thread attempts to add 
 - / / something to the pool ( using the execute ( ) method ) at the same time the 
 - / / first thread is attempting to purge the queue the attempt to purge 
 - / / the queue fails and the cancelled object remain in the queue . 
 - / / A better way to cancel objects with thread pools is to use the remove ( ) 
 - service . getQueue ( ) . remove ( pendingTask ) ; 
 - } 
 + void cancel ( ) ; 
 
 / * * 
 * Checks whether an attempt to cancel the transaction was performed . 
 * 
 * @ return { @ code true } if { @ link # cancel ( ) } has already been called , { @ code false } otherwise . 
 * / 
 - public boolean isCancelled ( ) { 
 - return isCancelled ; 
 - } 
 + boolean isCancelled ( ) ; 
 } 
 + 
 diff - - git a / realm / realm - library / src / main / java / io / realm / User . java b / realm / realm - library / src / main / java / io / realm / User . java 
 index 85a9a08 . . 1cf9af3 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / User . java 
 + + + b / realm / realm - library / src / main / java / io / realm / User . java 
 @ @ - 34 , 6 + 34 , 7 @ @ import java . util . concurrent . ThreadPoolExecutor ; 
 
 import io . realm . internal . IOException ; 
 import io . realm . internal . Util ; 
 + import io . realm . internal . async . RealmAsyncTaskImpl ; 
 import io . realm . internal . objectserver . SyncUser ; 
 import io . realm . internal . objectserver . Token ; 
 import io . realm . internal . network . AuthenticateResponse ; 
 @ @ - 181 , 7 + 182 , 7 @ @ public class User { 
 } 
 } ) ; 
 
 - return new RealmAsyncTask ( authenticateRequest , networkPoolExecutor ) ; 
 + return new RealmAsyncTaskImpl ( authenticateRequest , networkPoolExecutor ) ; 
 } 
 
 / * * 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / async / RealmAsyncTaskImpl . java b / realm / realm - library / src / main / java / io / realm / internal / async / RealmAsyncTaskImpl . java 
 new file mode 100644 
 index 0000000 . . d523c9a 
 - - - / dev / null 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / async / RealmAsyncTaskImpl . java 
 @ @ - 0 , 0 + 1 , 59 @ @ 
 + / * 
 + * Copyright 2016 Realm Inc . 
 + * 
 + * Licensed under the Apache License , Version 2 . 0 ( the " License " ) ; 
 + * you may not use this file except in compliance with the License . 
 + * You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package io . realm . internal . async ; 
 + 
 + import java . util . concurrent . Future ; 
 + import java . util . concurrent . ThreadPoolExecutor ; 
 + 
 + import io . realm . RealmAsyncTask ; 
 + 
 + public final class RealmAsyncTaskImpl implements RealmAsyncTask { 
 + private final Future < ? > pendingTask ; 
 + private final ThreadPoolExecutor service ; 
 + private volatile boolean isCancelled = false ; 
 + 
 + public RealmAsyncTaskImpl ( Future < ? > pendingTask , ThreadPoolExecutor service ) { 
 + this . pendingTask = pendingTask ; 
 + this . service = service ; 
 + } 
 + 
 + / * * 
 + * { @ inheritDoc } 
 + * / 
 + public void cancel ( ) { 
 + pendingTask . cancel ( true ) ; 
 + isCancelled = true ; 
 + 
 + / / From " Java Threads " : By Scott Oaks & Henry Wong 
 + / / cancelled tasks are never executed , but may 
 + / / accumulate in work queues , which may causes a memory leak 
 + / / if the task hold references ( to an enclosing class for example ) 
 + / / we can use purge ( ) but one caveat applies : if a second thread attempts to add 
 + / / something to the pool ( using the execute ( ) method ) at the same time the 
 + / / first thread is attempting to purge the queue the attempt to purge 
 + / / the queue fails and the cancelled object remain in the queue . 
 + / / A better way to cancel objects with thread pools is to use the remove ( ) 
 + service . getQueue ( ) . remove ( pendingTask ) ; 
 + } 
 + 
 + / * * 
 + * { @ inheritDoc } 
 + * / 
 + public boolean isCancelled ( ) { 
 + return isCancelled ; 
 + } 
 + } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncSession . java b / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncSession . java 
 index 49cbf98 . . 79fc9ae 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncSession . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncSession . java 
 @ @ - 22 , 6 + 22 , 7 @ @ import java . util . concurrent . Future ; 
 
 import io . realm . RealmAsyncTask ; 
 import io . realm . internal . Keep ; 
 + import io . realm . internal . async . RealmAsyncTaskImpl ; 
 import io . realm . log . RealmLog ; 
 import io . realm . ErrorCode ; 
 import io . realm . ObjectServerError ; 
 @ @ - 279 , 7 + 280 , 7 @ @ public final class SyncSession { 
 errorHandler . onError ( getUserSession ( ) , response . getError ( ) ) ; 
 } 
 } ) ; 
 - networkRequest = new RealmAsyncTask ( task , SyncManager . NETWORK _ POOL _ EXECUTOR ) ; 
 + networkRequest = new RealmAsyncTaskImpl ( task , SyncManager . NETWORK _ POOL _ EXECUTOR ) ; 
 } 
 
 / * * 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncUser . java b / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncUser . java 
 index fcbcb96 . . 2e9d845 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncUser . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / objectserver / SyncUser . java 
 @ @ - 35 , 6 + 35 , 7 @ @ import io . realm . Session ; 
 import io . realm . SyncConfiguration ; 
 import io . realm . SyncManager ; 
 import io . realm . User ; 
 + import io . realm . internal . async . RealmAsyncTaskImpl ; 
 import io . realm . internal . network . AuthenticationServer ; 
 import io . realm . internal . network . ExponentialBackoffTask ; 
 import io . realm . internal . network . RefreshResponse ; 
 @ @ - 95 , 7 + 96 , 7 @ @ public class SyncUser { 
 
 } 
 } ) ; 
 - refreshTask = new RealmAsyncTask ( task , SyncManager . NETWORK _ POOL _ EXECUTOR ) ; 
 + refreshTask = new RealmAsyncTaskImpl ( task , SyncManager . NETWORK _ POOL _ EXECUTOR ) ; 
 } 
 
 / * *

NEAREST DIFF:
diff - - git a / realm / src / androidTest / java / io / realm / RealmTest . java b / realm / src / androidTest / java / io / realm / RealmTest . java 
 index 588b51d . . 73cdd9a 100644 
 - - - a / realm / src / androidTest / java / io / realm / RealmTest . java 
 + + + b / realm / src / androidTest / java / io / realm / RealmTest . java 
 @ @ - 18 , 6 + 18 , 7 @ @ package io . realm ; 
 import android . content . Context ; 
 import android . os . SystemClock ; 
 import android . test . AndroidTestCase ; 
 + import android . util . Log ; 
 
 import junit . framework . AssertionFailedError ; 
 
 @ @ - 34 , 7 + 35 , 6 @ @ import java . util . ArrayList ; 
 import java . util . Arrays ; 
 import java . util . Date ; 
 import java . util . List ; 
 - import java . util . Map ; 
 import java . util . Random ; 
 import java . util . Scanner ; 
 import java . util . concurrent . Callable ; 
 @ @ - 62 , 7 + 62 , 7 @ @ import io . realm . entities . PrimaryKeyMix ; 
 import io . realm . entities . StringOnly ; 
 import io . realm . exceptions . RealmException ; 
 import io . realm . exceptions . RealmIOException ; 
 - import io . realm . internal . FinalizerRunnable ; 
 + import io . realm . internal . SharedGroup ; 
 import io . realm . internal . Table ; 
 
 import static io . realm . internal . test . ExtraTests . assertArrayEquals ; 
 @ @ - 1685 , 42 + 1685 , 51 @ @ public class RealmTest extends AndroidTestCase { 
 } 
 
 / / Check that FinalizerRunnable can free native resources ( phantom refs ) 
 - public void testFinalizerThread ( ) throws NoSuchFieldException , IllegalAccessException { 
 - Field fieldReferences = FinalizerRunnable . class . getDeclaredField ( " references " ) ; 
 - fieldReferences . setAccessible ( true ) ; 
 - Map < Reference < ? > , Boolean > references = ( Map < Reference < ? > , Boolean > ) fieldReferences . get ( null ) ; 
 - assertNotNull ( references ) ; 
 - 
 - Field fieldIsFinalizerStarted = Realm . class . getDeclaredField ( " isFinalizerStarted " ) ; 
 - fieldIsFinalizerStarted . setAccessible ( true ) ; 
 - boolean isFinalizerStarted = fieldIsFinalizerStarted . getBoolean ( null ) ; 
 - assertTrue ( isFinalizerStarted ) ; 
 - 
 - / / insert some rows , then give the FinalizerRunnable some time to cleanup 
 + public void testReferenceCleaning ( ) throws NoSuchFieldException , IllegalAccessException { 
 + Field sharedGroupReference = Realm . class . getDeclaredField ( " sharedGroup " ) ; 
 + sharedGroupReference . setAccessible ( true ) ; 
 + SharedGroup sharedGroup = ( SharedGroup ) sharedGroupReference . get ( testRealm ) ; 
 + assertNotNull ( sharedGroup ) ; 
 + 
 + Field contextField = SharedGroup . class . getDeclaredField ( " context " ) ; 
 + contextField . setAccessible ( true ) ; 
 + io . realm . internal . Context context = ( io . realm . internal . Context ) contextField . get ( sharedGroup ) ; 
 + assertNotNull ( context ) ; 
 + 
 + Field rowReferencesField = io . realm . internal . Context . class . getDeclaredField ( " rowReferences " ) ; 
 + rowReferencesField . setAccessible ( true ) ; 
 + List < Reference < ? > > rowReferences = ( List < Reference < ? > > ) rowReferencesField . get ( context ) ; 
 + assertNotNull ( rowReferences ) ; 
 + 
 + 
 + / / insert some rows , then give the thread some time to cleanup 
 / / we have 8 reference so far let ' s add more 
 final int numberOfPopulateTest = 10000 ; 
 final int totalNumberOfReferences = 8 + 20 * 2 * numberOfPopulateTest ; 
 
 + long tic = System . currentTimeMillis ( ) ; 
 for ( int i = 0 ; i < numberOfPopulateTest ; i + + ) { 
 populateTestRealm ( testRealm , 20 ) ; 
 } 
 + long toc = System . currentTimeMillis ( ) ; 
 + Log . d ( RealmTest . class . getName ( ) , " Insertion time : " + ( toc - tic ) ) ; 
 
 final int MAX _ GC _ RETRIES = 5 ; 
 int numberOfRetries = 0 ; 
 - while ( references . size ( ) > 0 & & numberOfRetries < MAX _ GC _ RETRIES ) { 
 + while ( rowReferences . size ( ) > 0 & & numberOfRetries < MAX _ GC _ RETRIES ) { 
 SystemClock . sleep ( TimeUnit . SECONDS . toMillis ( 1 ) ) ; / / 1s 
 numberOfRetries + + ; 
 System . gc ( ) ; 
 } 
 
 / / we can ' t guarantee that all references have been GC ' d but we should detect a decrease 
 - boolean isDecreasing = references . size ( ) < totalNumberOfReferences ; 
 + boolean isDecreasing = rowReferences . size ( ) < totalNumberOfReferences ; 
 if ( ! isDecreasing ) { 
 fail ( " FinalizerRunnable is not closing all native resources " ) ; 
 
 } else { 
 - android . util . Log . d ( RealmTest . class . getName ( ) , " FinalizerRunnable freed : " 
 - + ( totalNumberOfReferences - references . size ( ) ) + " out of " + totalNumberOfReferences ) ; 
 + android . util . Log . d ( RealmTest . class . getName ( ) , " References freed : " 
 + + ( totalNumberOfReferences - rowReferences . size ( ) ) + " out of " + totalNumberOfReferences ) ; 
 } 
 } 
 
 diff - - git a / realm / src / main / java / io / realm / Realm . java b / realm / src / main / java / io / realm / Realm . java 
 index 764eb1e . . 3f29fc2 100644 
 - - - a / realm / src / main / java / io / realm / Realm . java 
 + + + b / realm / src / main / java / io / realm / Realm . java 
 @ @ - 54 , 14 + 54 , 13 @ @ import io . realm . exceptions . RealmIOException ; 
 import io . realm . exceptions . RealmMigrationNeededException ; 
 import io . realm . internal . ColumnIndices ; 
 import io . realm . internal . ColumnType ; 
 - import io . realm . internal . FinalizerRunnable ; 
 import io . realm . internal . ImplicitTransaction ; 
 import io . realm . internal . RealmObjectProxy ; 
 import io . realm . internal . RealmProxyMediator ; 
 - import io . realm . internal . UncheckedRow ; 
 import io . realm . internal . SharedGroup ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableView ; 
 + import io . realm . internal . UncheckedRow ; 
 import io . realm . internal . Util ; 
 import io . realm . internal . android . DebugAndroidLogger ; 
 import io . realm . internal . android . ReleaseAndroidLogger ; 
 @ @ - 573 , 12 + 572 , 6 @ @ public final class Realm implements Closeable { 
 } 
 
 private static synchronized Realm createAndValidate ( RealmConfiguration configuration , boolean validateSchema , boolean autoRefresh ) { 
 - / / Start the finalizer thread if needed 
 - if ( ! isFinalizerStarted ) { 
 - executorService . submit ( new FinalizerRunnable ( ) ) ; 
 - isFinalizerStarted = true ; 
 - } 
 - 
 / / Check if a cached instance already exists for this thread 
 String canonicalPath = configuration . getPath ( ) ; 
 Map < RealmConfiguration , Integer > localRefCount = referenceCount . get ( ) ; 
 diff - - git a / realm / src / main / java / io / realm / internal / Context . java b / realm / src / main / java / io / realm / internal / Context . java 
 index b2a7858 . . 4e5fbc8 100644 
 - - - a / realm / src / main / java / io / realm / internal / Context . java 
 + + + b / realm / src / main / java / io / realm / internal / Context . java 
 @ @ - 16 , 10 + 16 , 12 @ @ 
 
 package io . realm . internal ; 
 
 + import java . lang . ref . Reference ; 
 + import java . lang . ref . ReferenceQueue ; 
 import java . util . ArrayList ; 
 import java . util . List ; 
 
 - class Context { 
 + public class Context { 
 
 / / Each group of related Realm objects will have a Context object in the root . 
 / / The root can be a table , a group , or a shared group . 
 @ @ - 31 , 6 + 33 , 9 @ @ class Context { 
 private List < Long > abandonedTableViews = new ArrayList < Long > ( ) ; 
 private List < Long > abandonedQueries = new ArrayList < Long > ( ) ; 
 
 + List < Reference < ? > > rowReferences = new ArrayList < Reference < ? > > ( ) ; 
 + ReferenceQueue < NativeObject > referenceQueue = new ReferenceQueue < NativeObject > ( ) ; 
 + 
 private boolean isFinalized = false ; 
 
 public void executeDelayedDisposal ( ) { 
 @ @ - 52 , 6 + 57 , 17 @ @ class Context { 
 TableQuery . nativeClose ( nativePointer ) ; 
 } 
 abandonedQueries . clear ( ) ; 
 + 
 + cleanRows ( ) ; 
 + } 
 + } 
 + 
 + public void cleanRows ( ) { 
 + NativeObjectReference reference = ( NativeObjectReference ) referenceQueue . poll ( ) ; 
 + while ( reference ! = null ) { 
 + UncheckedRow . nativeClose ( reference . nativePointer ) ; 
 + rowReferences . remove ( reference ) ; 
 + reference = ( NativeObjectReference ) referenceQueue . poll ( ) ; 
 } 
 } 
 
 diff - - git a / realm / src / main / java / io / realm / internal / UncheckedRow . java b / realm / src / main / java / io / realm / internal / UncheckedRow . java 
 index 04b0573 . . 9127924 100644 
 - - - a / realm / src / main / java / io / realm / internal / UncheckedRow . java 
 + + + b / realm / src / main / java / io / realm / internal / UncheckedRow . java 
 @ @ - 36 , 6 + 36 , 8 @ @ public class UncheckedRow extends NativeObject implements Row { 
 this . context = context ; 
 this . parent = parent ; 
 this . nativePointer = nativePtr ; 
 + 
 + context . cleanRows ( ) ; 
 } 
 
 / * *
