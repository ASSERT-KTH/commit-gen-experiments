BLEU SCORE: 0.10682175159905853

TEST MSG: PendingRow can return a CheckedRow
GENERATED MSG: Add PendingRow to suport findFirst

TEST DIFF (one line): diff - - git a / realm / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> index 2939fcf . . 6f7c49e 100644 <nl> - - - a / realm / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> + + + b / realm / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java <nl> @ @ - 501 , 7 + 501 , 7 @ @ public class RealmProxyClassGenerator { <nl> <nl> writer . emitStatement ( " final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) " ) ; <nl> writer . emitStatement ( " this . columnInfo = ( % 1 $ s ) context . getColumnInfo ( ) " , columnInfoClassName ( ) ) ; <nl> - writer . emitStatement ( " this . proxyState = new ProxyState ( % 1 $ s . class , this ) " , qualifiedClassName ) ; <nl> + writer . emitStatement ( " this . proxyState = new ProxyState ( this ) " ) ; <nl> writer . emitStatement ( " proxyState . setRealm $ realm ( context . getRealm ( ) ) " ) ; <nl> writer . emitStatement ( " proxyState . setRow $ realm ( context . getRow ( ) ) " ) ; <nl> writer . emitStatement ( " proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) " ) ; <nl> diff - - git a / realm / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java b / realm / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java <nl> index 09d5c21 . . d10c4af 100644 <nl> - - - a / realm / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java <nl> + + + b / realm / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java <nl> @ @ - 118 , 7 + 118 , 7 @ @ public class AllTypesRealmProxy extends some . test . AllTypes <nl> private void injectObjectContext ( ) { <nl> final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) ; <nl> this . columnInfo = ( AllTypesColumnInfo ) context . getColumnInfo ( ) ; <nl> - this . proxyState = new ProxyState ( some . test . AllTypes . class , this ) ; <nl> + this . proxyState = new ProxyState ( this ) ; <nl> proxyState . setRealm $ realm ( context . getRealm ( ) ) ; <nl> proxyState . setRow $ realm ( context . getRow ( ) ) ; <nl> proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) ; <nl> diff - - git a / realm / realm - annotations - processor / src / test / resources / io / realm / BooleansRealmProxy . java b / realm / realm - annotations - processor / src / test / resources / io / realm / BooleansRealmProxy . java <nl> index 7323ad2 . . 8fa4bcd 100644 <nl> - - - a / realm / realm - annotations - processor / src / test / resources / io / realm / BooleansRealmProxy . java <nl> + + + b / realm / realm - annotations - processor / src / test / resources / io / realm / BooleansRealmProxy . java <nl> @ @ - 92 , 7 + 92 , 7 @ @ public class BooleansRealmProxy extends some . test . Booleans <nl> private void injectObjectContext ( ) { <nl> final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) ; <nl> this . columnInfo = ( BooleansColumnInfo ) context . getColumnInfo ( ) ; <nl> - this . proxyState = new ProxyState ( some . test . Booleans . class , this ) ; <nl> + this . proxyState = new ProxyState ( this ) ; <nl> proxyState . setRealm $ realm ( context . getRealm ( ) ) ; <nl> proxyState . setRow $ realm ( context . getRow ( ) ) ; <nl> proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) ; <nl> diff - - git a / realm / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java b / realm / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java <nl> index ee1b354 . . 538ab4d 100644 <nl> - - - a / realm / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java <nl> + + + b / realm / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java <nl> @ @ - 177 , 7 + 177 , 7 @ @ public class NullTypesRealmProxy extends some . test . NullTypes <nl> private void injectObjectContext ( ) { <nl> final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) ; <nl> this . columnInfo = ( NullTypesColumnInfo ) context . getColumnInfo ( ) ; <nl> - this . proxyState = new ProxyState ( some . test . NullTypes . class , this ) ; <nl> + this . proxyState = new ProxyState ( this ) ; <nl> proxyState . setRealm $ realm ( context . getRealm ( ) ) ; <nl> proxyState . setRow $ realm ( context . getRow ( ) ) ; <nl> proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) ; <nl> diff - - git a / realm / realm - annotations - processor / src / test / resources / io / realm / SimpleRealmProxy . java b / realm / realm - annotations - processor / src / test / resources / io / realm / SimpleRealmProxy . java <nl> index a1e7952 . . 5092e82 100644 <nl> - - - a / realm / realm - annotations - processor / src / test / resources / io / realm / SimpleRealmProxy . java <nl> + + + b / realm / realm - annotations - processor / src / test / resources / io / realm / SimpleRealmProxy . java <nl> @ @ - 82 , 7 + 82 , 7 @ @ public class SimpleRealmProxy extends some . test . Simple <nl> private void injectObjectContext ( ) { <nl> final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) ; <nl> this . columnInfo = ( SimpleColumnInfo ) context . getColumnInfo ( ) ; <nl> - this . proxyState = new ProxyState ( some . test . Simple . class , this ) ; <nl> + this . proxyState = new ProxyState ( this ) ; <nl> proxyState . setRealm $ realm ( context . getRealm ( ) ) ; <nl> proxyState . setRow $ realm ( context . getRow ( ) ) ; <nl> proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) ; <nl> diff - - git a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java <nl> index c564f4c . . bad48a2 100644 <nl> - - - a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java <nl> + + + b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java <nl> @ @ - 16 , 7 + 16 , 6 @ @ <nl> <nl> package io . realm ; <nl> <nl> - import android . os . Handler ; <nl> import android . support . test . runner . AndroidJUnit4 ; <nl> <nl> import org . junit . After ; <nl> @ @ - 41 , 6 + 40 , 7 @ @ import io . realm . entities . PrimaryKeyAsBoxedLong ; <nl> import io . realm . entities . PrimaryKeyAsBoxedShort ; <nl> import io . realm . entities . PrimaryKeyAsString ; <nl> import io . realm . exceptions . RealmException ; <nl> + import io . realm . internal . PendingRow ; <nl> import io . realm . log . RealmLog ; <nl> import io . realm . rule . RunInLooperThread ; <nl> import io . realm . rule . RunTestInLooperThread ; <nl> @ @ - 341 , 13 + 341 , 22 @ @ public class DynamicRealmTests { <nl> } <nl> <nl> @ Test <nl> + public void findFirst ( ) { <nl> + final DynamicRealmObject allTypes = realm . where ( AllTypes . CLASS _ NAME ) <nl> + . between ( AllTypes . FIELD _ LONG , 4 , 9 ) <nl> + . findFirst ( ) ; <nl> + populateTestRealm ( realm , 10 ) ; <nl> + assertEquals ( " test data 4 " , allTypes . getString ( AllTypes . FIELD _ STRING ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> @ RunTestInLooperThread <nl> - public void findFirstAsync ( ) { <nl> + public void findFirst _ async ( ) { <nl> final DynamicRealm dynamicRealm = initializeDynamicRealm ( ) ; <nl> final DynamicRealmObject allTypes = dynamicRealm . where ( AllTypes . CLASS _ NAME ) <nl> . between ( AllTypes . FIELD _ LONG , 4 , 9 ) <nl> - . findFirstAsync ( ) ; <nl> - assertFalse ( allTypes . isLoaded ( ) ) ; <nl> + . findFirst ( ) ; <nl> + assertTrue ( allTypes . realmGet $ proxyState ( ) . getRow $ realm ( ) instanceof PendingRow ) ; <nl> looperThread . keepStrongReference . add ( allTypes ) ; <nl> allTypes . addChangeListener ( new RealmChangeListener < DynamicRealmObject > ( ) { <nl> @ Override <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / DynamicRealmObject . java b / realm / realm - library / src / main / java / io / realm / DynamicRealmObject . java <nl> index 95c4ae2 . . dd7a78c 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / DynamicRealmObject . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / DynamicRealmObject . java <nl> @ @ - 75 , 14 + 75 , 6 @ @ public final class DynamicRealmObject extends RealmObject implements RealmObject <nl> proxyState . setConstructionFinished ( ) ; <nl> } <nl> <nl> - / / row must not be an instance of UncheckedRow <nl> - DynamicRealmObject ( String className , BaseRealm realm , Row row ) { <nl> - proxyState . setClassName ( className ) ; <nl> - proxyState . setRealm $ realm ( realm ) ; <nl> - proxyState . setRow $ realm ( row ) ; <nl> - proxyState . setConstructionFinished ( ) ; <nl> - } <nl> - <nl> / * * <nl> * Returns the value for the given field . <nl> * <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> index c36f12d . . 41bd384 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> @ @ - 18 , 15 + 18 , 11 @ @ package io . realm ; <nl> <nl> import java . util . List ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> - import java . util . concurrent . Future ; <nl> <nl> import io . realm . internal . PendingRow ; <nl> import io . realm . internal . Row ; <nl> import io . realm . internal . RowNotifier ; <nl> - import io . realm . internal . Table ; <nl> - import io . realm . internal . TableQuery ; <nl> import io . realm . internal . UncheckedRow ; <nl> - import io . realm . log . RealmLog ; <nl> <nl> / * * <nl> * This implements { @ code RealmObjectProxy } interface , to eliminate copying logic between <nl> @ @ - 34 , 8 + 30 , 6 @ @ import io . realm . log . RealmLog ; <nl> * / <nl> public final class ProxyState < E extends RealmModel > implements PendingRow . FrontEnd { <nl> private E model ; <nl> - private String className ; <nl> - private Class < ? extends RealmModel > clazzName ; <nl> <nl> / / true only while executing the constructor of the enclosing proxy object <nl> private boolean underConstruction = true ; <nl> @ @ - 46 , 8 + 40 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> private List < String > excludeFields ; <nl> <nl> private final List < RealmChangeListener < E > > listeners = new CopyOnWriteArrayList < RealmChangeListener < E > > ( ) ; <nl> - private Future < Long > pendingQuery ; <nl> - private boolean isCompleted = false ; <nl> protected long currentTableVersion = - 1 ; <nl> <nl> public ProxyState ( ) { } <nl> @ @ - 56 , 28 + 48 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> this . model = model ; <nl> } <nl> <nl> - public ProxyState ( Class < ? extends RealmModel > clazzName , E model ) { <nl> - this . clazzName = clazzName ; <nl> - this . model = model ; <nl> - } <nl> - <nl> - / * * <nl> - * Sets the Future instance returned by the worker thread , we need this instance to force { @ link RealmObject # load ( ) } an async <nl> - * query , we use it to determine if the current RealmResults is a sync or async one . <nl> - * <nl> - * @ param pendingQuery pending query . <nl> - * / <nl> - public void setPendingQuery $ realm ( Future < Long > pendingQuery ) { <nl> - this . pendingQuery = pendingQuery ; <nl> - if ( isLoaded ( ) ) { <nl> - / / the query completed before RealmQuery <nl> - / / had a chance to call setPendingQuery to register the pendingQuery ( used btw <nl> - / / to determine isLoaded behaviour ) <nl> - onCompleted $ realm ( ) ; <nl> - <nl> - } / / else , it will be handled by the Realm # handler <nl> - } <nl> - <nl> public BaseRealm getRealm $ realm ( ) { <nl> return realm ; <nl> } <nl> @ @ - 110 , 57 + 80 , 10 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> this . excludeFields = excludeFields ; <nl> } <nl> <nl> - public Object getPendingQuery $ realm ( ) { <nl> - return pendingQuery ; <nl> - } <nl> - <nl> - public boolean isCompleted $ realm ( ) { <nl> - return isCompleted ; <nl> - } <nl> - <nl> - / * * <nl> - * Called to import the handover row pointer and notify listeners . <nl> - * <nl> - * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> - * / <nl> - public boolean onCompleted $ realm ( ) { <nl> - try { <nl> - Long handoverResult = pendingQuery . get ( ) ; / / make the query blocking <nl> - if ( handoverResult ! = 0 ) { <nl> - / / this may fail with BadVersionException if the caller and / or the worker thread <nl> - / / are not in sync ( same shared _ group version ) . <nl> - / / COMPLETED _ ASYNC _ REALM _ OBJECT will be fired by the worker thread <nl> - / / this should handle more complex use cases like retry , ignore etc <nl> - onCompleted $ realm ( handoverResult ) ; <nl> - notifyChangeListeners $ realm ( ) ; <nl> - } else { <nl> - isCompleted = true ; <nl> - } <nl> - } catch ( Exception e ) { <nl> - RealmLog . debug ( e ) ; <nl> - return false ; <nl> - } <nl> - return true ; <nl> - } <nl> - <nl> public List < RealmChangeListener < E > > getListeners $ realm ( ) { <nl> return listeners ; <nl> } <nl> <nl> - public void onCompleted $ realm ( long handoverRowPointer ) { <nl> - if ( handoverRowPointer = = 0 ) { <nl> - / / we ' ll retry later to update the row pointer , but we consider <nl> - / / the query done <nl> - isCompleted = true ; <nl> - <nl> - } else if ( ! isCompleted | | row = = Row . EMPTY _ ROW ) { <nl> - isCompleted = true ; <nl> - long nativeRowPointer = TableQuery . importHandoverRow ( handoverRowPointer , realm . sharedRealm ) ; <nl> - Table table = getTable ( ) ; <nl> - this . row = table . getUncheckedRowByPointer ( nativeRowPointer ) ; <nl> - } / / else : already loaded query no need to import again the pointer <nl> - } <nl> - <nl> / * * <nl> * Notifies all registered listeners . <nl> * / <nl> @ @ - 193 , 10 + 116 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> } <nl> } <nl> <nl> - public void setClassName ( String className ) { <nl> - this . className = className ; <nl> - } <nl> - <nl> public boolean isUnderConstruction ( ) { <nl> return underConstruction ; <nl> } <nl> @ @ - 207 , 18 + 126 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE <nl> excludeFields = null ; <nl> } <nl> <nl> - private Table getTable ( ) { <nl> - if ( className ! = null ) { <nl> - return getRealm $ realm ( ) . schema . getTable ( className ) ; <nl> - } <nl> - return getRealm $ realm ( ) . schema . getTable ( clazzName ) ; <nl> - } <nl> - <nl> - private boolean isLoaded ( ) { <nl> - realm . checkIfValid ( ) ; <nl> - return getPendingQuery $ realm ( ) = = null | | isCompleted $ realm ( ) ; <nl> - } <nl> - <nl> @ Override <nl> public void onQueryFinished ( Row row , boolean asyncQuery ) { <nl> this . row = row ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmObject . java b / realm / realm - library / src / main / java / io / realm / RealmObject . java <nl> index ee1e796 . . a4b714c 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmObject . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmObject . java <nl> @ @ - 18 , 8 + 18 , 6 @ @ package io . realm ; <nl> <nl> import android . app . IntentService ; <nl> <nl> - import java . util . List ; <nl> - <nl> import io . realm . annotations . RealmClass ; <nl> import io . realm . internal . InvalidRow ; <nl> import io . realm . internal . RealmObjectProxy ; <nl> @ @ - 151 , 94 + 149 , 27 @ @ public abstract class RealmObject implements RealmModel { <nl> } <nl> <nl> / * * <nl> - * Checks if the query used to find this RealmObject has completed . <nl> - * <nl> - * Async methods like { @ link RealmQuery # findFirstAsync ( ) } return an { @ link RealmObject } that represents the future result <nl> - * of the { @ link RealmQuery } . It can be considered similar to a { @ link java . util . concurrent . Future } in this regard . <nl> - * <nl> - * Once { @ code isLoaded ( ) } returns { @ code true } , the object represents the query result even if the query <nl> - * didn ' t find any object matching the query parameters . In this case the { @ link RealmObject } will <nl> - * become a " null " object . <nl> - * <nl> - * " Null " objects represents { @ code null } . An exception is throw if any accessor is called , so it is important to also <nl> - * check { @ link # isValid ( ) } before calling any methods . A common pattern is : <nl> - * <nl> - * < pre > <nl> - * { @ code <nl> - * Person person = realm . where ( Person . class ) . findFirstAsync ( ) ; <nl> - * person . isLoaded ( ) ; / / = = false <nl> - * person . addChangeListener ( new RealmChangeListener ( ) { <nl> - * \ @ Override <nl> - * public void onChange ( Person person ) { <nl> - * person . isLoaded ( ) ; / / Always true here <nl> - * if ( person . isValid ( ) ) { <nl> - * / / It is safe to access the person . <nl> - * } <nl> - * } <nl> - * } ) ; <nl> - * } <nl> - * < / pre > <nl> - * <nl> - * Synchronous RealmObjects are by definition blocking hence this method will always return { @ code true } for them . <nl> - * This method will return { @ code true } if called on an unmanaged object ( created outside of Realm ) . <nl> - * <nl> - * @ return { @ code true } if the query has completed , { @ code false } if the query is in <nl> - * progress . <nl> + * @ deprecated <nl> + * @ return { @ code true } always . <nl> * <nl> * @ see # isValid ( ) <nl> * / <nl> public final boolean isLoaded ( ) { <nl> + / / noinspection deprecation <nl> return RealmObject . isLoaded ( this ) ; <nl> } <nl> <nl> <nl> / * * <nl> - * Checks if the query used to find this RealmObject has completed . <nl> - * <nl> - * Async methods like { @ link RealmQuery # findFirstAsync ( ) } return an { @ link RealmObject } that represents the future result <nl> - * of the { @ link RealmQuery } . It can be considered similar to a { @ link java . util . concurrent . Future } in this regard . <nl> - * <nl> - * Once { @ code isLoaded ( ) } returns { @ code true } , the object represents the query result even if the query <nl> - * didn ' t find any object matching the query parameters . In this case the { @ link RealmObject } will <nl> - * become a " null " object . <nl> - * <nl> - * " Null " objects represents { @ code null } . An exception is throw if any accessor is called , so it is important to also <nl> - * check { @ link # isValid ( ) } before calling any methods . A common pattern is : <nl> - * <nl> - * < pre > <nl> - * { @ code <nl> - * Person person = realm . where ( Person . class ) . findFirstAsync ( ) ; <nl> - * RealmObject . isLoaded ( person ) ; / / = = false <nl> - * RealmObject . addChangeListener ( person , new RealmChangeListener ( ) { <nl> - * \ @ Override <nl> - * public void onChange ( Person person ) { <nl> - * RealmObject . isLoaded ( person ) ; / / always true here <nl> - * if ( RealmObject . isValid ( person ) ) { <nl> - * / / It is safe to access the person . <nl> - * } <nl> - * } <nl> - * } ) ; <nl> - * } <nl> - * < / pre > <nl> - * <nl> - * Synchronous RealmObjects are by definition blocking hence this method will always return { @ code true } for them . <nl> - * This method will return { @ code true } if called on an unmanaged object ( created outside of Realm ) . <nl> - * <nl> - * <nl> + * @ deprecated <nl> * @ param object RealmObject to check . <nl> - * @ return { @ code true } if the query has completed , { @ code false } if the query is in <nl> - * progress . <nl> + * @ return { @ code true } always . <nl> * <nl> * @ see # isValid ( RealmModel ) <nl> * / <nl> + @ SuppressWarnings ( " UnusedParameters " ) <nl> public static < E extends RealmModel > boolean isLoaded ( E object ) { <nl> - if ( object instanceof RealmObjectProxy ) { <nl> - RealmObjectProxy proxy = ( RealmObjectProxy ) object ; <nl> - proxy . realmGet $ proxyState ( ) . getRealm $ realm ( ) . checkIfValid ( ) ; <nl> - return proxy . realmGet $ proxyState ( ) . getPendingQuery $ realm ( ) = = null | | proxy . realmGet $ proxyState ( ) . isCompleted $ realm ( ) ; <nl> - } else { <nl> - return true ; <nl> - } <nl> + return true ; <nl> } <nl> <nl> / * * <nl> @ @ - 295 , 29 + 226 , 15 @ @ public abstract class RealmObject implements RealmModel { <nl> * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> * / <nl> public final boolean load ( ) { <nl> + / / noinspection deprecation <nl> return RealmObject . load ( this ) ; <nl> } <nl> <nl> / * * <nl> - * Makes an asynchronous query blocking . This will also trigger any registered listeners . <nl> - * < p > <nl> - * Note : This will return { @ code true } if called for an unmanaged object ( created outside of Realm ) . <nl> - * <nl> - * @ param object RealmObject to force load . <nl> - * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . <nl> + * @ deprecated <nl> * / <nl> public static < E extends RealmModel > boolean load ( E object ) { <nl> - if ( RealmObject . isLoaded ( object ) ) { <nl> - return true ; <nl> - } else { <nl> - if ( object instanceof RealmObjectProxy ) { <nl> - / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) <nl> - / / in this case the Realm # handler will be responsible of retrying <nl> - return ( ( RealmObjectProxy ) object ) . realmGet $ proxyState ( ) . onCompleted $ realm ( ) ; <nl> - } else { <nl> - return false ; <nl> - } <nl> - } <nl> + return object instanceof RealmObjectProxy ; <nl> } <nl> <nl> / * * <nl> @ @ - 329 , 6 + 246 , 7 @ @ public abstract class RealmObject implements RealmModel { <nl> * @ throws IllegalStateException if you try to add a listener from a non - Looper or { @ link IntentService } thread . <nl> * / <nl> public final < E extends RealmModel > void addChangeListener ( RealmChangeListener < E > listener ) { <nl> + / / noinspection unchecked <nl> RealmObject . addChangeListener ( ( E ) this , listener ) ; <nl> } <nl> <nl> @ @ - 453 , 6 + 371 , 7 @ @ public abstract class RealmObject implements RealmModel { <nl> * @ see < a href = " https : / / realm . io / docs / java / latest / # rxjava " > RxJava and Realm < / a > <nl> * / <nl> public final < E extends RealmObject > Observable < E > asObservable ( ) { <nl> + / / noinspection unchecked <nl> return ( Observable < E > ) RealmObject . asObservable ( this ) ; <nl> } <nl> <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> index 6dfe00d . . 49108ac 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 1644 , 12 + 1644 , 12 @ @ public final class RealmQuery < E extends RealmModel > { <nl> / / TODO : The performance by the pending query will be a little bit worse than directly calling core ' s <nl> / / Query . find ( ) . The overhead comes with core needs to add all the row indices to the vector . However this <nl> / / can be optimized by adding support of limit in OS ' s Results which is supported by core already . <nl> - row = new PendingRow ( realm . sharedRealm , query , null ) ; <nl> + row = new PendingRow ( realm . sharedRealm , query , null , isDynamicQuery ( ) ) ; <nl> } <nl> final E result ; <nl> if ( isDynamicQuery ( ) ) { <nl> / / noinspection unchecked <nl> - result = ( E ) new DynamicRealmObject ( className , realm , row ) ; <nl> + result = ( E ) new DynamicRealmObject ( realm , row ) ; <nl> } else { <nl> result = realm . getConfiguration ( ) . getSchemaMediator ( ) . newInstance ( <nl> clazz , realm , row , realm . getSchema ( ) . getColumnInfo ( clazz ) , <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> index 3f24caf . . c54a066 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> @ @ - 32 , 8 + 32 , 10 @ @ public class PendingRow implements Row { <nl> private Collection pendingCollection ; <nl> private Collection . Listener listener ; <nl> private WeakReference < FrontEnd > frontEnd ; <nl> + private boolean returnCheckedRow ; <nl> <nl> - public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { <nl> + public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor , <nl> + final boolean returnCheckedRow ) { <nl> pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; <nl> listener = new Collection . Listener ( new RealmChangeListener < PendingRow > ( ) { <nl> @ Override <nl> @ @ - 42 , 14 + 44 , 15 @ @ public class PendingRow implements Row { <nl> throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> } <nl> / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . <nl> - Row row = pendingCollection . firstUncheckedRow ( ) ; <nl> if ( frontEnd . get ( ) = = null ) { <nl> / / The front end is GCed . <nl> clearPendingCollection ( ) ; <nl> return ; <nl> } <nl> + UncheckedRow uncheckedRow = pendingCollection . firstUncheckedRow ( ) ; <nl> / / If no rows returned by the query , just wait for the query updates until it returns a valid row . <nl> - if ( row ! = null ) { <nl> + if ( uncheckedRow ! = null ) { <nl> + Row row = returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; <nl> / / Ask the front end to reset the row and stop async query . <nl> frontEnd . get ( ) . onQueryFinished ( row , true ) ; <nl> clearPendingCollection ( ) ; <nl> @ @ - 57 , 6 + 60 , 7 @ @ public class PendingRow implements Row { <nl> } <nl> } , this ) ; <nl> pendingCollection . addListener ( listener ) ; <nl> + this . returnCheckedRow = returnCheckedRow ; <nl> } <nl> <nl> / / To set the front end of this PendingRow . <nl> @ @ - 222 , 12 + 226 , 13 @ @ public class PendingRow implements Row { <nl> if ( frontEnd = = null ) { <nl> throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> } <nl> - Row row = pendingCollection . getUncheckedRow ( 0 ) ; <nl> - if ( row = = null ) { <nl> + UncheckedRow uncheckedRow = pendingCollection . firstUncheckedRow ( ) ; <nl> + if ( uncheckedRow = = null ) { <nl> throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; <nl> } <nl> + Row row = returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; <nl> if ( frontEnd . get ( ) ! = null ) { <nl> - frontEnd . get ( ) . onQueryFinished ( pendingCollection . firstUncheckedRow ( ) , false ) ; <nl> + frontEnd . get ( ) . onQueryFinished ( row , false ) ; <nl> } <nl> clearPendingCollection ( ) ; <nl> return row ;
NEAREST DIFF (one line): diff - - git a / realm / realm - library / src / main / java / io / realm / HandlerController . java b / realm / realm - library / src / main / java / io / realm / HandlerController . java <nl> index 134ead5 . . 752fdc1 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / HandlerController . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / HandlerController . java <nl> @ @ - 298 , 7 + 298 , 7 @ @ final class HandlerController implements Handler . Callback { <nl> * @ param realmResultsToBeNotified list of all RealmResults listeners that can be notified . <nl> * / <nl> void notifyAllListeners ( List < RealmResults < ? extends RealmModel > > realmResultsToBeNotified ) { <nl> - <nl> + / * <nl> / / Notify all RealmResults ( async and synchronous ) . <nl> for ( Iterator < RealmResults < ? extends RealmModel > > it = realmResultsToBeNotified . iterator ( ) ; ! realm . isClosed ( ) & & it . hasNext ( ) ; ) { <nl> RealmResults < ? extends RealmModel > realmResults = it . next ( ) ; <nl> @ @ - 320 , 6 + 320 , 7 @ @ final class HandlerController implements Handler . Callback { <nl> / / Trigger global listeners last . <nl> / / Note that NotificationTest . callingOrdersOfListeners will fail if orders change . <nl> notifyGlobalListeners ( ) ; <nl> + * / <nl> } <nl> <nl> private void collectAsyncRealmResultsCallbacks ( List < RealmResults < ? extends RealmModel > > resultsToBeNotified ) { <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> index af3d807 . . 3e67066 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ import java . util . List ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> import java . util . concurrent . Future ; <nl> <nl> + import io . realm . internal . PendingRow ; <nl> import io . realm . internal . Row ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableQuery ; <nl> @ @ - 29 , 7 + 30 , 7 @ @ import io . realm . log . RealmLog ; <nl> * This implements { @ code RealmObjectProxy } interface , to eliminate copying logic between <nl> * { @ link RealmObject } and { @ link DynamicRealmObject } . <nl> * / <nl> - public final class ProxyState < E extends RealmModel > { <nl> + public final class ProxyState < E extends RealmModel > implements PendingRow . FrontEnd { <nl> private E model ; <nl> private String className ; <nl> private Class < ? extends RealmModel > clazzName ; <nl> @ @ - 163 , 27 + 164 , 8 @ @ public final class ProxyState < E extends RealmModel > { <nl> * / <nl> void notifyChangeListeners $ realm ( ) { <nl> if ( ! listeners . isEmpty ( ) ) { <nl> - boolean notify = false ; <nl> - <nl> - Table table = row . getTable ( ) ; <nl> - if ( table = = null ) { <nl> - / / Completed async queries might result in ` table = = null ` , ` isCompleted = = true ` and ` row = = Row . EMPTY _ ROW ` <nl> - / / We still want to trigger change notifications for these cases . <nl> - / / isLoaded / isValid should be considered properties on RealmObjects as well so any change to these <nl> - / / should trigger a RealmChangeListener . <nl> - notify = true ; <nl> - } else { <nl> - long version = table . getVersion ( ) ; <nl> - if ( currentTableVersion ! = version ) { <nl> - currentTableVersion = version ; <nl> - notify = true ; <nl> - } <nl> - } <nl> - <nl> - if ( notify ) { <nl> - for ( RealmChangeListener listener : listeners ) { <nl> - listener . onChange ( model ) ; <nl> - } <nl> + for ( RealmChangeListener listener : listeners ) { <nl> + listener . onChange ( model ) ; <nl> } <nl> } <nl> } <nl> @ @ - 219 , 4 + 201 , 12 @ @ public final class ProxyState < E extends RealmModel > { <nl> realm . checkIfValid ( ) ; <nl> return getPendingQuery $ realm ( ) = = null | | isCompleted $ realm ( ) ; <nl> } <nl> + <nl> + @ Override <nl> + public void onQueryFinished ( Row row , boolean asyncQuery ) { <nl> + this . row = row ; <nl> + if ( asyncQuery ) { <nl> + notifyChangeListeners $ realm ( ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> index 281fa7d . . 0e20605 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java <nl> @ @ - 21 , 22 + 21 , 19 @ @ import java . lang . ref . WeakReference ; <nl> import java . util . Collections ; <nl> import java . util . Date ; <nl> import java . util . Locale ; <nl> - import java . util . concurrent . Callable ; <nl> - import java . util . concurrent . Future ; <nl> <nl> import io . realm . annotations . Required ; <nl> import io . realm . internal . Collection ; <nl> import io . realm . internal . LinkView ; <nl> + import io . realm . internal . PendingRow ; <nl> import io . realm . internal . RealmNotifier ; <nl> import io . realm . internal . RealmObjectProxy ; <nl> - import io . realm . internal . Row ; <nl> import io . realm . internal . SharedRealm ; <nl> import io . realm . internal . SortDescriptor ; <nl> import io . realm . internal . Table ; <nl> import io . realm . internal . TableQuery ; <nl> import io . realm . internal . async . ArgumentsHolder ; <nl> import io . realm . internal . async . QueryUpdateTask ; <nl> - import io . realm . log . RealmLog ; <nl> <nl> / * * <nl> * A RealmQuery encapsulates a query on a { @ link io . realm . Realm } or a { @ link io . realm . RealmResults } using the Builder <nl> @ @ - 1649 , 98 + 1646 , 36 @ @ public final class RealmQuery < E extends RealmModel > { <nl> * / <nl> public E findFirst ( ) { <nl> checkQueryIsNotReused ( ) ; <nl> - long tableRowIndex = getSourceRowIndexForFirstObject ( ) ; <nl> - if ( tableRowIndex > = 0 ) { <nl> - E realmObject = realm . get ( clazz , className , tableRowIndex ) ; <nl> - return realmObject ; <nl> - } else { <nl> - return null ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Similar to { @ link # findFirst ( ) } but runs asynchronously on a worker thread <nl> - * This method is only available from a Looper thread . <nl> - * <nl> - * @ return immediately an empty { @ link RealmObject } . Trying to access any field on the returned object <nl> - * before it is loaded will throw an { @ code IllegalStateException } . Use { @ link RealmObject # isLoaded ( ) } to check if <nl> - * the object is fully loaded or register a listener { @ link io . realm . RealmObject # addChangeListener } <nl> - * to be notified when the query completes . If no RealmObject was found after the query completed , the returned <nl> - * RealmObject will have { @ link RealmObject # isLoaded ( ) } set to { @ code true } and { @ link RealmObject # isValid ( ) } set to <nl> - * { @ code false } . <nl> - * / <nl> - public E findFirstAsync ( ) { <nl> - checkQueryIsNotReused ( ) ; <nl> - final WeakReference < RealmNotifier > weakNotifier = getWeakReferenceNotifier ( ) ; <nl> - <nl> - / / handover the query ( to be used by a worker thread ) <nl> - final long handoverQueryPointer = query . handoverQuery ( realm . sharedRealm ) ; <nl> - <nl> - / / save query arguments ( for future update ) <nl> - argumentsHolder = new ArgumentsHolder ( ArgumentsHolder . TYPE _ FIND _ FIRST ) ; <nl> - <nl> - final RealmConfiguration realmConfiguration = realm . getConfiguration ( ) ; <nl> <nl> + / / TODO : The performance by the pending query will be a little bit worse than directly calling core ' s <nl> + / / Query . find ( ) . The overhead comes with core needs to add all the row indices to the vector . However this can <nl> + / / be optimized by adding support of limit in OS ' s Results which is supported by core already . <nl> + PendingRow pendingRow = new PendingRow ( realm . sharedRealm , query , null ) ; <nl> / / prepare an empty reference of the RealmObject , so we can return it immediately ( promise ) <nl> / / then update it once the query complete in the background . <nl> final E result ; <nl> if ( isDynamicQuery ( ) ) { <nl> / / noinspection unchecked <nl> - result = ( E ) new DynamicRealmObject ( className , realm , Row . EMPTY _ ROW ) ; <nl> + result = ( E ) new DynamicRealmObject ( className , realm , pendingRow ) ; <nl> } else { <nl> result = realm . getConfiguration ( ) . getSchemaMediator ( ) . newInstance ( <nl> - clazz , realm , Row . EMPTY _ ROW , realm . getSchema ( ) . getColumnInfo ( clazz ) , <nl> + clazz , realm , pendingRow , realm . getSchema ( ) . getColumnInfo ( clazz ) , <nl> false , Collections . < String > emptyList ( ) ) ; <nl> } <nl> <nl> final RealmObjectProxy proxy = ( RealmObjectProxy ) result ; <nl> - final WeakReference < RealmObjectProxy > realmObjectWeakReference = realm . handlerController . addToAsyncRealmObject ( proxy , this ) ; <nl> - <nl> - final Future < Long > pendingQuery = Realm . asyncTaskExecutor . submitQuery ( new Callable < Long > ( ) { <nl> - @ Override <nl> - public Long call ( ) throws Exception { <nl> - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { <nl> - SharedRealm sharedRealm = null ; <nl> - <nl> - try { <nl> - sharedRealm = SharedRealm . getInstance ( realmConfiguration ) ; <nl> - <nl> - long handoverRowPointer = TableQuery . findWithHandover ( sharedRealm , handoverQueryPointer ) ; <nl> - if ( handoverRowPointer = = 0 ) { / / empty row <nl> - realm . handlerController . addToEmptyAsyncRealmObject ( realmObjectWeakReference , RealmQuery . this ) ; <nl> - realm . handlerController . removeFromAsyncRealmObject ( realmObjectWeakReference ) ; <nl> - } <nl> - <nl> - QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmObjectResponse ( ) ; <nl> - result . updatedRow . put ( realmObjectWeakReference , handoverRowPointer ) ; <nl> - result . versionID = sharedRealm . getVersionID ( ) ; <nl> - closeSharedRealmAndSendEventToNotifier ( sharedRealm , <nl> - weakNotifier , QueryUpdateTask . NotifyEvent . COMPLETE _ ASYNC _ OBJECT , result ) ; <nl> - <nl> - return handoverRowPointer ; <nl> - <nl> - } catch ( Throwable e ) { <nl> - RealmLog . error ( e ) ; <nl> - / / handler can ' t throw a checked exception need to wrap it into unchecked Exception <nl> - closeSharedRealmAndSendEventToNotifier ( sharedRealm , <nl> - weakNotifier , QueryUpdateTask . NotifyEvent . THROW _ BACKGROUND _ EXCEPTION , e ) ; <nl> - } finally { <nl> - if ( sharedRealm ! = null & & ! sharedRealm . isClosed ( ) ) { <nl> - sharedRealm . close ( ) ; <nl> - } <nl> - } <nl> - } else { <nl> - TableQuery . nativeCloseQueryHandover ( handoverQueryPointer ) ; <nl> - } <nl> - <nl> - return INVALID _ NATIVE _ POINTER ; <nl> - } <nl> - } ) ; <nl> - proxy . realmGet $ proxyState ( ) . setPendingQuery $ realm ( pendingQuery ) ; <nl> + pendingRow . setFrontEnd ( proxy . realmGet $ proxyState ( ) ) ; <nl> <nl> return result ; <nl> } <nl> <nl> + / * * <nl> + * @ deprecated use { @ link # findFirst ( ) } instead . <nl> + * / <nl> + public E findFirstAsync ( ) { <nl> + return findFirst ( ) ; <nl> + } <nl> + <nl> private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { <nl> if ( fieldNames = = null ) { <nl> throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> index 25fcf2c . . 3f24caf 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java <nl> @ @ - 1 , 8 + 1 , 235 @ @ <nl> package io . realm . internal ; <nl> <nl> + import java . lang . ref . WeakReference ; <nl> + import java . util . Date ; <nl> + <nl> + import io . realm . RealmChangeListener ; <nl> + import io . realm . RealmFieldType ; <nl> + <nl> / * * <nl> - * Created by cc on 16 - 11 - 30 . <nl> + * A PendingRow is a row relies on a pending async query . <nl> + * Before the query returns , calling any accessors will immediately execute the query and call the corresponding <nl> + * accessor on the query result . If the query results is empty , an { @ link IllegalStateException } will be thrown . <nl> + * After the query returns , { @ link FrontEnd # onQueryFinished ( Row , boolean ) } will be called to give the front end a <nl> + * chance to reset the row . If the async query returns an empty result , the query will be executed again later until a <nl> + * valid row is contained by the query results . <nl> * / <nl> - <nl> public class PendingRow implements Row { <nl> + <nl> + / / Implement this interface to reset the PendingRow to a Row backed by real data when query returned . <nl> + public interface FrontEnd { <nl> + / / When asyncQuery is true , the pending query is executed asynchronously . Otherwise the query is triggered by <nl> + / / calling any accessors before the async query returns . <nl> + void onQueryFinished ( Row row , boolean asyncQuery ) ; <nl> + } <nl> + <nl> + private static final String EMPTY _ ROW _ MESSAGE = <nl> + " This RealmObject is empty . There isn ' t any objects match the query . " ; <nl> + private static final String PROXY _ NOT _ SET _ MESSAGE = " The ' frontEnd ' has not been set . " ; <nl> + private static final String QUERY _ EXECUTED _ MESSAGE = <nl> + " The query has been executed . This ' PendingRow ' is not valid anymore . " ; <nl> + <nl> + private Collection pendingCollection ; <nl> + private Collection . Listener listener ; <nl> + private WeakReference < FrontEnd > frontEnd ; <nl> + <nl> + public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { <nl> + pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; <nl> + listener = new Collection . Listener ( new RealmChangeListener < PendingRow > ( ) { <nl> + @ Override <nl> + public void onChange ( PendingRow pendingRow ) { <nl> + if ( frontEnd = = null ) { <nl> + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> + } <nl> + / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . <nl> + Row row = pendingCollection . firstUncheckedRow ( ) ; <nl> + if ( frontEnd . get ( ) = = null ) { <nl> + / / The front end is GCed . <nl> + clearPendingCollection ( ) ; <nl> + return ; <nl> + } <nl> + / / If no rows returned by the query , just wait for the query updates until it returns a valid row . <nl> + if ( row ! = null ) { <nl> + / / Ask the front end to reset the row and stop async query . <nl> + frontEnd . get ( ) . onQueryFinished ( row , true ) ; <nl> + clearPendingCollection ( ) ; <nl> + } <nl> + } <nl> + } , this ) ; <nl> + pendingCollection . addListener ( listener ) ; <nl> + } <nl> + <nl> + / / To set the front end of this PendingRow . <nl> + public void setFrontEnd ( FrontEnd frontEnd ) { <nl> + this . frontEnd = new WeakReference < FrontEnd > ( frontEnd ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getColumnCount ( ) { <nl> + return executeQuery ( ) . getColumnCount ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getColumnName ( long columnIndex ) { <nl> + return executeQuery ( ) . getColumnName ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getColumnIndex ( String columnName ) { <nl> + return executeQuery ( ) . getColumnIndex ( columnName ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public RealmFieldType getColumnType ( long columnIndex ) { <nl> + return executeQuery ( ) . getColumnType ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Table getTable ( ) { <nl> + return executeQuery ( ) . getTable ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getIndex ( ) { <nl> + return executeQuery ( ) . getIndex ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getLong ( long columnIndex ) { <nl> + return executeQuery ( ) . getLong ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean getBoolean ( long columnIndex ) { <nl> + return executeQuery ( ) . getBoolean ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public float getFloat ( long columnIndex ) { <nl> + return executeQuery ( ) . getFloat ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public double getDouble ( long columnIndex ) { <nl> + return executeQuery ( ) . getDouble ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Date getDate ( long columnIndex ) { <nl> + return executeQuery ( ) . getDate ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getString ( long columnIndex ) { <nl> + return executeQuery ( ) . getString ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public byte [ ] getBinaryByteArray ( long columnIndex ) { <nl> + return executeQuery ( ) . getBinaryByteArray ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getLink ( long columnIndex ) { <nl> + return executeQuery ( ) . getLink ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isNullLink ( long columnIndex ) { <nl> + return executeQuery ( ) . isNullLink ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public LinkView getLinkList ( long columnIndex ) { <nl> + return executeQuery ( ) . getLinkList ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setLong ( long columnIndex , long value ) { <nl> + executeQuery ( ) . setLong ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setBoolean ( long columnIndex , boolean value ) { <nl> + executeQuery ( ) . setBoolean ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setFloat ( long columnIndex , float value ) { <nl> + executeQuery ( ) . setFloat ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setDouble ( long columnIndex , double value ) { <nl> + executeQuery ( ) . setDouble ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setDate ( long columnIndex , Date date ) { <nl> + executeQuery ( ) . setDate ( columnIndex , date ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setString ( long columnIndex , String value ) { <nl> + executeQuery ( ) . setString ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setBinaryByteArray ( long columnIndex , byte [ ] data ) { <nl> + executeQuery ( ) . setBinaryByteArray ( columnIndex , data ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setLink ( long columnIndex , long value ) { <nl> + executeQuery ( ) . setLink ( columnIndex , value ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void nullifyLink ( long columnIndex ) { <nl> + executeQuery ( ) . nullifyLink ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isNull ( long columnIndex ) { <nl> + return executeQuery ( ) . isNull ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setNull ( long columnIndex ) { <nl> + executeQuery ( ) . setNull ( columnIndex ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isAttached ( ) { <nl> + return executeQuery ( ) . isAttached ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasColumn ( String fieldName ) { <nl> + return executeQuery ( ) . hasColumn ( fieldName ) ; <nl> + } <nl> + <nl> + private void clearPendingCollection ( ) { <nl> + pendingCollection . removeListener ( listener ) ; <nl> + pendingCollection = null ; <nl> + listener = null ; <nl> + } <nl> + <nl> + private Row executeQuery ( ) { <nl> + if ( pendingCollection = = null ) { <nl> + throw new IllegalStateException ( QUERY _ EXECUTED _ MESSAGE ) ; <nl> + } <nl> + if ( frontEnd = = null ) { <nl> + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; <nl> + } <nl> + Row row = pendingCollection . getUncheckedRow ( 0 ) ; <nl> + if ( row = = null ) { <nl> + throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; <nl> + } <nl> + if ( frontEnd . get ( ) ! = null ) { <nl> + frontEnd . get ( ) . onQueryFinished ( pendingCollection . firstUncheckedRow ( ) , false ) ; <nl> + } <nl> + clearPendingCollection ( ) ; <nl> + return row ; <nl> + } <nl> } <nl> diff - - git a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java <nl> index 7802428 . . 5b5b441 100644 <nl> - - - a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java <nl> + + + b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java <nl> @ @ - 89 , 8 + 89 , 10 @ @ public class UncheckedRow implements NativeObject , Row { <nl> <nl> / / FIXME : Testing code <nl> public static UncheckedRow getByRowPointer ( Table table , long nativeRowPointer ) { <nl> - UncheckedRow row = new UncheckedRow ( table . context , table , nativeRowPointer ) ; <nl> - return row ; <nl> + if ( nativeRowPointer ! = 0 ) { <nl> + return new UncheckedRow ( table . context , table , nativeRowPointer ) ; <nl> + } <nl> + return null ; <nl> } <nl> <nl> / * *

TEST DIFF:
diff - - git a / realm / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java b / realm / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 index 2939fcf . . 6f7c49e 100644 
 - - - a / realm / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 + + + b / realm / realm - annotations - processor / src / main / java / io / realm / processor / RealmProxyClassGenerator . java 
 @ @ - 501 , 7 + 501 , 7 @ @ public class RealmProxyClassGenerator { 
 
 writer . emitStatement ( " final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) " ) ; 
 writer . emitStatement ( " this . columnInfo = ( % 1 $ s ) context . getColumnInfo ( ) " , columnInfoClassName ( ) ) ; 
 - writer . emitStatement ( " this . proxyState = new ProxyState ( % 1 $ s . class , this ) " , qualifiedClassName ) ; 
 + writer . emitStatement ( " this . proxyState = new ProxyState ( this ) " ) ; 
 writer . emitStatement ( " proxyState . setRealm $ realm ( context . getRealm ( ) ) " ) ; 
 writer . emitStatement ( " proxyState . setRow $ realm ( context . getRow ( ) ) " ) ; 
 writer . emitStatement ( " proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) " ) ; 
 diff - - git a / realm / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java b / realm / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java 
 index 09d5c21 . . d10c4af 100644 
 - - - a / realm / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java 
 + + + b / realm / realm - annotations - processor / src / test / resources / io / realm / AllTypesRealmProxy . java 
 @ @ - 118 , 7 + 118 , 7 @ @ public class AllTypesRealmProxy extends some . test . AllTypes 
 private void injectObjectContext ( ) { 
 final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) ; 
 this . columnInfo = ( AllTypesColumnInfo ) context . getColumnInfo ( ) ; 
 - this . proxyState = new ProxyState ( some . test . AllTypes . class , this ) ; 
 + this . proxyState = new ProxyState ( this ) ; 
 proxyState . setRealm $ realm ( context . getRealm ( ) ) ; 
 proxyState . setRow $ realm ( context . getRow ( ) ) ; 
 proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) ; 
 diff - - git a / realm / realm - annotations - processor / src / test / resources / io / realm / BooleansRealmProxy . java b / realm / realm - annotations - processor / src / test / resources / io / realm / BooleansRealmProxy . java 
 index 7323ad2 . . 8fa4bcd 100644 
 - - - a / realm / realm - annotations - processor / src / test / resources / io / realm / BooleansRealmProxy . java 
 + + + b / realm / realm - annotations - processor / src / test / resources / io / realm / BooleansRealmProxy . java 
 @ @ - 92 , 7 + 92 , 7 @ @ public class BooleansRealmProxy extends some . test . Booleans 
 private void injectObjectContext ( ) { 
 final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) ; 
 this . columnInfo = ( BooleansColumnInfo ) context . getColumnInfo ( ) ; 
 - this . proxyState = new ProxyState ( some . test . Booleans . class , this ) ; 
 + this . proxyState = new ProxyState ( this ) ; 
 proxyState . setRealm $ realm ( context . getRealm ( ) ) ; 
 proxyState . setRow $ realm ( context . getRow ( ) ) ; 
 proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) ; 
 diff - - git a / realm / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java b / realm / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java 
 index ee1b354 . . 538ab4d 100644 
 - - - a / realm / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java 
 + + + b / realm / realm - annotations - processor / src / test / resources / io / realm / NullTypesRealmProxy . java 
 @ @ - 177 , 7 + 177 , 7 @ @ public class NullTypesRealmProxy extends some . test . NullTypes 
 private void injectObjectContext ( ) { 
 final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) ; 
 this . columnInfo = ( NullTypesColumnInfo ) context . getColumnInfo ( ) ; 
 - this . proxyState = new ProxyState ( some . test . NullTypes . class , this ) ; 
 + this . proxyState = new ProxyState ( this ) ; 
 proxyState . setRealm $ realm ( context . getRealm ( ) ) ; 
 proxyState . setRow $ realm ( context . getRow ( ) ) ; 
 proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) ; 
 diff - - git a / realm / realm - annotations - processor / src / test / resources / io / realm / SimpleRealmProxy . java b / realm / realm - annotations - processor / src / test / resources / io / realm / SimpleRealmProxy . java 
 index a1e7952 . . 5092e82 100644 
 - - - a / realm / realm - annotations - processor / src / test / resources / io / realm / SimpleRealmProxy . java 
 + + + b / realm / realm - annotations - processor / src / test / resources / io / realm / SimpleRealmProxy . java 
 @ @ - 82 , 7 + 82 , 7 @ @ public class SimpleRealmProxy extends some . test . Simple 
 private void injectObjectContext ( ) { 
 final BaseRealm . RealmObjectContext context = BaseRealm . objectContext . get ( ) ; 
 this . columnInfo = ( SimpleColumnInfo ) context . getColumnInfo ( ) ; 
 - this . proxyState = new ProxyState ( some . test . Simple . class , this ) ; 
 + this . proxyState = new ProxyState ( this ) ; 
 proxyState . setRealm $ realm ( context . getRealm ( ) ) ; 
 proxyState . setRow $ realm ( context . getRow ( ) ) ; 
 proxyState . setAcceptDefaultValue $ realm ( context . getAcceptDefaultValue ( ) ) ; 
 diff - - git a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java 
 index c564f4c . . bad48a2 100644 
 - - - a / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java 
 + + + b / realm / realm - library / src / androidTest / java / io / realm / DynamicRealmTests . java 
 @ @ - 16 , 7 + 16 , 6 @ @ 
 
 package io . realm ; 
 
 - import android . os . Handler ; 
 import android . support . test . runner . AndroidJUnit4 ; 
 
 import org . junit . After ; 
 @ @ - 41 , 6 + 40 , 7 @ @ import io . realm . entities . PrimaryKeyAsBoxedLong ; 
 import io . realm . entities . PrimaryKeyAsBoxedShort ; 
 import io . realm . entities . PrimaryKeyAsString ; 
 import io . realm . exceptions . RealmException ; 
 + import io . realm . internal . PendingRow ; 
 import io . realm . log . RealmLog ; 
 import io . realm . rule . RunInLooperThread ; 
 import io . realm . rule . RunTestInLooperThread ; 
 @ @ - 341 , 13 + 341 , 22 @ @ public class DynamicRealmTests { 
 } 
 
 @ Test 
 + public void findFirst ( ) { 
 + final DynamicRealmObject allTypes = realm . where ( AllTypes . CLASS _ NAME ) 
 + . between ( AllTypes . FIELD _ LONG , 4 , 9 ) 
 + . findFirst ( ) ; 
 + populateTestRealm ( realm , 10 ) ; 
 + assertEquals ( " test data 4 " , allTypes . getString ( AllTypes . FIELD _ STRING ) ) ; 
 + } 
 + 
 + @ Test 
 @ RunTestInLooperThread 
 - public void findFirstAsync ( ) { 
 + public void findFirst _ async ( ) { 
 final DynamicRealm dynamicRealm = initializeDynamicRealm ( ) ; 
 final DynamicRealmObject allTypes = dynamicRealm . where ( AllTypes . CLASS _ NAME ) 
 . between ( AllTypes . FIELD _ LONG , 4 , 9 ) 
 - . findFirstAsync ( ) ; 
 - assertFalse ( allTypes . isLoaded ( ) ) ; 
 + . findFirst ( ) ; 
 + assertTrue ( allTypes . realmGet $ proxyState ( ) . getRow $ realm ( ) instanceof PendingRow ) ; 
 looperThread . keepStrongReference . add ( allTypes ) ; 
 allTypes . addChangeListener ( new RealmChangeListener < DynamicRealmObject > ( ) { 
 @ Override 
 diff - - git a / realm / realm - library / src / main / java / io / realm / DynamicRealmObject . java b / realm / realm - library / src / main / java / io / realm / DynamicRealmObject . java 
 index 95c4ae2 . . dd7a78c 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / DynamicRealmObject . java 
 + + + b / realm / realm - library / src / main / java / io / realm / DynamicRealmObject . java 
 @ @ - 75 , 14 + 75 , 6 @ @ public final class DynamicRealmObject extends RealmObject implements RealmObject 
 proxyState . setConstructionFinished ( ) ; 
 } 
 
 - / / row must not be an instance of UncheckedRow 
 - DynamicRealmObject ( String className , BaseRealm realm , Row row ) { 
 - proxyState . setClassName ( className ) ; 
 - proxyState . setRealm $ realm ( realm ) ; 
 - proxyState . setRow $ realm ( row ) ; 
 - proxyState . setConstructionFinished ( ) ; 
 - } 
 - 
 / * * 
 * Returns the value for the given field . 
 * 
 diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 index c36f12d . . 41bd384 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 @ @ - 18 , 15 + 18 , 11 @ @ package io . realm ; 
 
 import java . util . List ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 - import java . util . concurrent . Future ; 
 
 import io . realm . internal . PendingRow ; 
 import io . realm . internal . Row ; 
 import io . realm . internal . RowNotifier ; 
 - import io . realm . internal . Table ; 
 - import io . realm . internal . TableQuery ; 
 import io . realm . internal . UncheckedRow ; 
 - import io . realm . log . RealmLog ; 
 
 / * * 
 * This implements { @ code RealmObjectProxy } interface , to eliminate copying logic between 
 @ @ - 34 , 8 + 30 , 6 @ @ import io . realm . log . RealmLog ; 
 * / 
 public final class ProxyState < E extends RealmModel > implements PendingRow . FrontEnd { 
 private E model ; 
 - private String className ; 
 - private Class < ? extends RealmModel > clazzName ; 
 
 / / true only while executing the constructor of the enclosing proxy object 
 private boolean underConstruction = true ; 
 @ @ - 46 , 8 + 40 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 private List < String > excludeFields ; 
 
 private final List < RealmChangeListener < E > > listeners = new CopyOnWriteArrayList < RealmChangeListener < E > > ( ) ; 
 - private Future < Long > pendingQuery ; 
 - private boolean isCompleted = false ; 
 protected long currentTableVersion = - 1 ; 
 
 public ProxyState ( ) { } 
 @ @ - 56 , 28 + 48 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 this . model = model ; 
 } 
 
 - public ProxyState ( Class < ? extends RealmModel > clazzName , E model ) { 
 - this . clazzName = clazzName ; 
 - this . model = model ; 
 - } 
 - 
 - / * * 
 - * Sets the Future instance returned by the worker thread , we need this instance to force { @ link RealmObject # load ( ) } an async 
 - * query , we use it to determine if the current RealmResults is a sync or async one . 
 - * 
 - * @ param pendingQuery pending query . 
 - * / 
 - public void setPendingQuery $ realm ( Future < Long > pendingQuery ) { 
 - this . pendingQuery = pendingQuery ; 
 - if ( isLoaded ( ) ) { 
 - / / the query completed before RealmQuery 
 - / / had a chance to call setPendingQuery to register the pendingQuery ( used btw 
 - / / to determine isLoaded behaviour ) 
 - onCompleted $ realm ( ) ; 
 - 
 - } / / else , it will be handled by the Realm # handler 
 - } 
 - 
 public BaseRealm getRealm $ realm ( ) { 
 return realm ; 
 } 
 @ @ - 110 , 57 + 80 , 10 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 this . excludeFields = excludeFields ; 
 } 
 
 - public Object getPendingQuery $ realm ( ) { 
 - return pendingQuery ; 
 - } 
 - 
 - public boolean isCompleted $ realm ( ) { 
 - return isCompleted ; 
 - } 
 - 
 - / * * 
 - * Called to import the handover row pointer and notify listeners . 
 - * 
 - * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 - * / 
 - public boolean onCompleted $ realm ( ) { 
 - try { 
 - Long handoverResult = pendingQuery . get ( ) ; / / make the query blocking 
 - if ( handoverResult ! = 0 ) { 
 - / / this may fail with BadVersionException if the caller and / or the worker thread 
 - / / are not in sync ( same shared _ group version ) . 
 - / / COMPLETED _ ASYNC _ REALM _ OBJECT will be fired by the worker thread 
 - / / this should handle more complex use cases like retry , ignore etc 
 - onCompleted $ realm ( handoverResult ) ; 
 - notifyChangeListeners $ realm ( ) ; 
 - } else { 
 - isCompleted = true ; 
 - } 
 - } catch ( Exception e ) { 
 - RealmLog . debug ( e ) ; 
 - return false ; 
 - } 
 - return true ; 
 - } 
 - 
 public List < RealmChangeListener < E > > getListeners $ realm ( ) { 
 return listeners ; 
 } 
 
 - public void onCompleted $ realm ( long handoverRowPointer ) { 
 - if ( handoverRowPointer = = 0 ) { 
 - / / we ' ll retry later to update the row pointer , but we consider 
 - / / the query done 
 - isCompleted = true ; 
 - 
 - } else if ( ! isCompleted | | row = = Row . EMPTY _ ROW ) { 
 - isCompleted = true ; 
 - long nativeRowPointer = TableQuery . importHandoverRow ( handoverRowPointer , realm . sharedRealm ) ; 
 - Table table = getTable ( ) ; 
 - this . row = table . getUncheckedRowByPointer ( nativeRowPointer ) ; 
 - } / / else : already loaded query no need to import again the pointer 
 - } 
 - 
 / * * 
 * Notifies all registered listeners . 
 * / 
 @ @ - 193 , 10 + 116 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 } 
 } 
 
 - public void setClassName ( String className ) { 
 - this . className = className ; 
 - } 
 - 
 public boolean isUnderConstruction ( ) { 
 return underConstruction ; 
 } 
 @ @ - 207 , 18 + 126 , 6 @ @ public final class ProxyState < E extends RealmModel > implements PendingRow . FrontE 
 excludeFields = null ; 
 } 
 
 - private Table getTable ( ) { 
 - if ( className ! = null ) { 
 - return getRealm $ realm ( ) . schema . getTable ( className ) ; 
 - } 
 - return getRealm $ realm ( ) . schema . getTable ( clazzName ) ; 
 - } 
 - 
 - private boolean isLoaded ( ) { 
 - realm . checkIfValid ( ) ; 
 - return getPendingQuery $ realm ( ) = = null | | isCompleted $ realm ( ) ; 
 - } 
 - 
 @ Override 
 public void onQueryFinished ( Row row , boolean asyncQuery ) { 
 this . row = row ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmObject . java b / realm / realm - library / src / main / java / io / realm / RealmObject . java 
 index ee1e796 . . a4b714c 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmObject . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmObject . java 
 @ @ - 18 , 8 + 18 , 6 @ @ package io . realm ; 
 
 import android . app . IntentService ; 
 
 - import java . util . List ; 
 - 
 import io . realm . annotations . RealmClass ; 
 import io . realm . internal . InvalidRow ; 
 import io . realm . internal . RealmObjectProxy ; 
 @ @ - 151 , 94 + 149 , 27 @ @ public abstract class RealmObject implements RealmModel { 
 } 
 
 / * * 
 - * Checks if the query used to find this RealmObject has completed . 
 - * 
 - * Async methods like { @ link RealmQuery # findFirstAsync ( ) } return an { @ link RealmObject } that represents the future result 
 - * of the { @ link RealmQuery } . It can be considered similar to a { @ link java . util . concurrent . Future } in this regard . 
 - * 
 - * Once { @ code isLoaded ( ) } returns { @ code true } , the object represents the query result even if the query 
 - * didn ' t find any object matching the query parameters . In this case the { @ link RealmObject } will 
 - * become a " null " object . 
 - * 
 - * " Null " objects represents { @ code null } . An exception is throw if any accessor is called , so it is important to also 
 - * check { @ link # isValid ( ) } before calling any methods . A common pattern is : 
 - * 
 - * < pre > 
 - * { @ code 
 - * Person person = realm . where ( Person . class ) . findFirstAsync ( ) ; 
 - * person . isLoaded ( ) ; / / = = false 
 - * person . addChangeListener ( new RealmChangeListener ( ) { 
 - * \ @ Override 
 - * public void onChange ( Person person ) { 
 - * person . isLoaded ( ) ; / / Always true here 
 - * if ( person . isValid ( ) ) { 
 - * / / It is safe to access the person . 
 - * } 
 - * } 
 - * } ) ; 
 - * } 
 - * < / pre > 
 - * 
 - * Synchronous RealmObjects are by definition blocking hence this method will always return { @ code true } for them . 
 - * This method will return { @ code true } if called on an unmanaged object ( created outside of Realm ) . 
 - * 
 - * @ return { @ code true } if the query has completed , { @ code false } if the query is in 
 - * progress . 
 + * @ deprecated 
 + * @ return { @ code true } always . 
 * 
 * @ see # isValid ( ) 
 * / 
 public final boolean isLoaded ( ) { 
 + / / noinspection deprecation 
 return RealmObject . isLoaded ( this ) ; 
 } 
 
 
 / * * 
 - * Checks if the query used to find this RealmObject has completed . 
 - * 
 - * Async methods like { @ link RealmQuery # findFirstAsync ( ) } return an { @ link RealmObject } that represents the future result 
 - * of the { @ link RealmQuery } . It can be considered similar to a { @ link java . util . concurrent . Future } in this regard . 
 - * 
 - * Once { @ code isLoaded ( ) } returns { @ code true } , the object represents the query result even if the query 
 - * didn ' t find any object matching the query parameters . In this case the { @ link RealmObject } will 
 - * become a " null " object . 
 - * 
 - * " Null " objects represents { @ code null } . An exception is throw if any accessor is called , so it is important to also 
 - * check { @ link # isValid ( ) } before calling any methods . A common pattern is : 
 - * 
 - * < pre > 
 - * { @ code 
 - * Person person = realm . where ( Person . class ) . findFirstAsync ( ) ; 
 - * RealmObject . isLoaded ( person ) ; / / = = false 
 - * RealmObject . addChangeListener ( person , new RealmChangeListener ( ) { 
 - * \ @ Override 
 - * public void onChange ( Person person ) { 
 - * RealmObject . isLoaded ( person ) ; / / always true here 
 - * if ( RealmObject . isValid ( person ) ) { 
 - * / / It is safe to access the person . 
 - * } 
 - * } 
 - * } ) ; 
 - * } 
 - * < / pre > 
 - * 
 - * Synchronous RealmObjects are by definition blocking hence this method will always return { @ code true } for them . 
 - * This method will return { @ code true } if called on an unmanaged object ( created outside of Realm ) . 
 - * 
 - * 
 + * @ deprecated 
 * @ param object RealmObject to check . 
 - * @ return { @ code true } if the query has completed , { @ code false } if the query is in 
 - * progress . 
 + * @ return { @ code true } always . 
 * 
 * @ see # isValid ( RealmModel ) 
 * / 
 + @ SuppressWarnings ( " UnusedParameters " ) 
 public static < E extends RealmModel > boolean isLoaded ( E object ) { 
 - if ( object instanceof RealmObjectProxy ) { 
 - RealmObjectProxy proxy = ( RealmObjectProxy ) object ; 
 - proxy . realmGet $ proxyState ( ) . getRealm $ realm ( ) . checkIfValid ( ) ; 
 - return proxy . realmGet $ proxyState ( ) . getPendingQuery $ realm ( ) = = null | | proxy . realmGet $ proxyState ( ) . isCompleted $ realm ( ) ; 
 - } else { 
 - return true ; 
 - } 
 + return true ; 
 } 
 
 / * * 
 @ @ - 295 , 29 + 226 , 15 @ @ public abstract class RealmObject implements RealmModel { 
 * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 * / 
 public final boolean load ( ) { 
 + / / noinspection deprecation 
 return RealmObject . load ( this ) ; 
 } 
 
 / * * 
 - * Makes an asynchronous query blocking . This will also trigger any registered listeners . 
 - * < p > 
 - * Note : This will return { @ code true } if called for an unmanaged object ( created outside of Realm ) . 
 - * 
 - * @ param object RealmObject to force load . 
 - * @ return { @ code true } if it successfully completed the query , { @ code false } otherwise . 
 + * @ deprecated 
 * / 
 public static < E extends RealmModel > boolean load ( E object ) { 
 - if ( RealmObject . isLoaded ( object ) ) { 
 - return true ; 
 - } else { 
 - if ( object instanceof RealmObjectProxy ) { 
 - / / doesn ' t guarantee to import correctly the result ( because the user may have advanced ) 
 - / / in this case the Realm # handler will be responsible of retrying 
 - return ( ( RealmObjectProxy ) object ) . realmGet $ proxyState ( ) . onCompleted $ realm ( ) ; 
 - } else { 
 - return false ; 
 - } 
 - } 
 + return object instanceof RealmObjectProxy ; 
 } 
 
 / * * 
 @ @ - 329 , 6 + 246 , 7 @ @ public abstract class RealmObject implements RealmModel { 
 * @ throws IllegalStateException if you try to add a listener from a non - Looper or { @ link IntentService } thread . 
 * / 
 public final < E extends RealmModel > void addChangeListener ( RealmChangeListener < E > listener ) { 
 + / / noinspection unchecked 
 RealmObject . addChangeListener ( ( E ) this , listener ) ; 
 } 
 
 @ @ - 453 , 6 + 371 , 7 @ @ public abstract class RealmObject implements RealmModel { 
 * @ see < a href = " https : / / realm . io / docs / java / latest / # rxjava " > RxJava and Realm < / a > 
 * / 
 public final < E extends RealmObject > Observable < E > asObservable ( ) { 
 + / / noinspection unchecked 
 return ( Observable < E > ) RealmObject . asObservable ( this ) ; 
 } 
 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 index 6dfe00d . . 49108ac 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 @ @ - 1644 , 12 + 1644 , 12 @ @ public final class RealmQuery < E extends RealmModel > { 
 / / TODO : The performance by the pending query will be a little bit worse than directly calling core ' s 
 / / Query . find ( ) . The overhead comes with core needs to add all the row indices to the vector . However this 
 / / can be optimized by adding support of limit in OS ' s Results which is supported by core already . 
 - row = new PendingRow ( realm . sharedRealm , query , null ) ; 
 + row = new PendingRow ( realm . sharedRealm , query , null , isDynamicQuery ( ) ) ; 
 } 
 final E result ; 
 if ( isDynamicQuery ( ) ) { 
 / / noinspection unchecked 
 - result = ( E ) new DynamicRealmObject ( className , realm , row ) ; 
 + result = ( E ) new DynamicRealmObject ( realm , row ) ; 
 } else { 
 result = realm . getConfiguration ( ) . getSchemaMediator ( ) . newInstance ( 
 clazz , realm , row , realm . getSchema ( ) . getColumnInfo ( clazz ) , 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 index 3f24caf . . c54a066 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 @ @ - 32 , 8 + 32 , 10 @ @ public class PendingRow implements Row { 
 private Collection pendingCollection ; 
 private Collection . Listener listener ; 
 private WeakReference < FrontEnd > frontEnd ; 
 + private boolean returnCheckedRow ; 
 
 - public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { 
 + public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor , 
 + final boolean returnCheckedRow ) { 
 pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; 
 listener = new Collection . Listener ( new RealmChangeListener < PendingRow > ( ) { 
 @ Override 
 @ @ - 42 , 14 + 44 , 15 @ @ public class PendingRow implements Row { 
 throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 } 
 / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . 
 - Row row = pendingCollection . firstUncheckedRow ( ) ; 
 if ( frontEnd . get ( ) = = null ) { 
 / / The front end is GCed . 
 clearPendingCollection ( ) ; 
 return ; 
 } 
 + UncheckedRow uncheckedRow = pendingCollection . firstUncheckedRow ( ) ; 
 / / If no rows returned by the query , just wait for the query updates until it returns a valid row . 
 - if ( row ! = null ) { 
 + if ( uncheckedRow ! = null ) { 
 + Row row = returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; 
 / / Ask the front end to reset the row and stop async query . 
 frontEnd . get ( ) . onQueryFinished ( row , true ) ; 
 clearPendingCollection ( ) ; 
 @ @ - 57 , 6 + 60 , 7 @ @ public class PendingRow implements Row { 
 } 
 } , this ) ; 
 pendingCollection . addListener ( listener ) ; 
 + this . returnCheckedRow = returnCheckedRow ; 
 } 
 
 / / To set the front end of this PendingRow . 
 @ @ - 222 , 12 + 226 , 13 @ @ public class PendingRow implements Row { 
 if ( frontEnd = = null ) { 
 throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 } 
 - Row row = pendingCollection . getUncheckedRow ( 0 ) ; 
 - if ( row = = null ) { 
 + UncheckedRow uncheckedRow = pendingCollection . firstUncheckedRow ( ) ; 
 + if ( uncheckedRow = = null ) { 
 throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; 
 } 
 + Row row = returnCheckedRow ? CheckedRow . getFromRow ( uncheckedRow ) : uncheckedRow ; 
 if ( frontEnd . get ( ) ! = null ) { 
 - frontEnd . get ( ) . onQueryFinished ( pendingCollection . firstUncheckedRow ( ) , false ) ; 
 + frontEnd . get ( ) . onQueryFinished ( row , false ) ; 
 } 
 clearPendingCollection ( ) ; 
 return row ;

NEAREST DIFF:
diff - - git a / realm / realm - library / src / main / java / io / realm / HandlerController . java b / realm / realm - library / src / main / java / io / realm / HandlerController . java 
 index 134ead5 . . 752fdc1 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / HandlerController . java 
 + + + b / realm / realm - library / src / main / java / io / realm / HandlerController . java 
 @ @ - 298 , 7 + 298 , 7 @ @ final class HandlerController implements Handler . Callback { 
 * @ param realmResultsToBeNotified list of all RealmResults listeners that can be notified . 
 * / 
 void notifyAllListeners ( List < RealmResults < ? extends RealmModel > > realmResultsToBeNotified ) { 
 - 
 + / * 
 / / Notify all RealmResults ( async and synchronous ) . 
 for ( Iterator < RealmResults < ? extends RealmModel > > it = realmResultsToBeNotified . iterator ( ) ; ! realm . isClosed ( ) & & it . hasNext ( ) ; ) { 
 RealmResults < ? extends RealmModel > realmResults = it . next ( ) ; 
 @ @ - 320 , 6 + 320 , 7 @ @ final class HandlerController implements Handler . Callback { 
 / / Trigger global listeners last . 
 / / Note that NotificationTest . callingOrdersOfListeners will fail if orders change . 
 notifyGlobalListeners ( ) ; 
 + * / 
 } 
 
 private void collectAsyncRealmResultsCallbacks ( List < RealmResults < ? extends RealmModel > > resultsToBeNotified ) { 
 diff - - git a / realm / realm - library / src / main / java / io / realm / ProxyState . java b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 index af3d807 . . 3e67066 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 + + + b / realm / realm - library / src / main / java / io / realm / ProxyState . java 
 @ @ - 20 , 6 + 20 , 7 @ @ import java . util . List ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 import java . util . concurrent . Future ; 
 
 + import io . realm . internal . PendingRow ; 
 import io . realm . internal . Row ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableQuery ; 
 @ @ - 29 , 7 + 30 , 7 @ @ import io . realm . log . RealmLog ; 
 * This implements { @ code RealmObjectProxy } interface , to eliminate copying logic between 
 * { @ link RealmObject } and { @ link DynamicRealmObject } . 
 * / 
 - public final class ProxyState < E extends RealmModel > { 
 + public final class ProxyState < E extends RealmModel > implements PendingRow . FrontEnd { 
 private E model ; 
 private String className ; 
 private Class < ? extends RealmModel > clazzName ; 
 @ @ - 163 , 27 + 164 , 8 @ @ public final class ProxyState < E extends RealmModel > { 
 * / 
 void notifyChangeListeners $ realm ( ) { 
 if ( ! listeners . isEmpty ( ) ) { 
 - boolean notify = false ; 
 - 
 - Table table = row . getTable ( ) ; 
 - if ( table = = null ) { 
 - / / Completed async queries might result in ` table = = null ` , ` isCompleted = = true ` and ` row = = Row . EMPTY _ ROW ` 
 - / / We still want to trigger change notifications for these cases . 
 - / / isLoaded / isValid should be considered properties on RealmObjects as well so any change to these 
 - / / should trigger a RealmChangeListener . 
 - notify = true ; 
 - } else { 
 - long version = table . getVersion ( ) ; 
 - if ( currentTableVersion ! = version ) { 
 - currentTableVersion = version ; 
 - notify = true ; 
 - } 
 - } 
 - 
 - if ( notify ) { 
 - for ( RealmChangeListener listener : listeners ) { 
 - listener . onChange ( model ) ; 
 - } 
 + for ( RealmChangeListener listener : listeners ) { 
 + listener . onChange ( model ) ; 
 } 
 } 
 } 
 @ @ - 219 , 4 + 201 , 12 @ @ public final class ProxyState < E extends RealmModel > { 
 realm . checkIfValid ( ) ; 
 return getPendingQuery $ realm ( ) = = null | | isCompleted $ realm ( ) ; 
 } 
 + 
 + @ Override 
 + public void onQueryFinished ( Row row , boolean asyncQuery ) { 
 + this . row = row ; 
 + if ( asyncQuery ) { 
 + notifyChangeListeners $ realm ( ) ; 
 + } 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / RealmQuery . java b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 index 281fa7d . . 0e20605 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 + + + b / realm / realm - library / src / main / java / io / realm / RealmQuery . java 
 @ @ - 21 , 22 + 21 , 19 @ @ import java . lang . ref . WeakReference ; 
 import java . util . Collections ; 
 import java . util . Date ; 
 import java . util . Locale ; 
 - import java . util . concurrent . Callable ; 
 - import java . util . concurrent . Future ; 
 
 import io . realm . annotations . Required ; 
 import io . realm . internal . Collection ; 
 import io . realm . internal . LinkView ; 
 + import io . realm . internal . PendingRow ; 
 import io . realm . internal . RealmNotifier ; 
 import io . realm . internal . RealmObjectProxy ; 
 - import io . realm . internal . Row ; 
 import io . realm . internal . SharedRealm ; 
 import io . realm . internal . SortDescriptor ; 
 import io . realm . internal . Table ; 
 import io . realm . internal . TableQuery ; 
 import io . realm . internal . async . ArgumentsHolder ; 
 import io . realm . internal . async . QueryUpdateTask ; 
 - import io . realm . log . RealmLog ; 
 
 / * * 
 * A RealmQuery encapsulates a query on a { @ link io . realm . Realm } or a { @ link io . realm . RealmResults } using the Builder 
 @ @ - 1649 , 98 + 1646 , 36 @ @ public final class RealmQuery < E extends RealmModel > { 
 * / 
 public E findFirst ( ) { 
 checkQueryIsNotReused ( ) ; 
 - long tableRowIndex = getSourceRowIndexForFirstObject ( ) ; 
 - if ( tableRowIndex > = 0 ) { 
 - E realmObject = realm . get ( clazz , className , tableRowIndex ) ; 
 - return realmObject ; 
 - } else { 
 - return null ; 
 - } 
 - } 
 - 
 - / * * 
 - * Similar to { @ link # findFirst ( ) } but runs asynchronously on a worker thread 
 - * This method is only available from a Looper thread . 
 - * 
 - * @ return immediately an empty { @ link RealmObject } . Trying to access any field on the returned object 
 - * before it is loaded will throw an { @ code IllegalStateException } . Use { @ link RealmObject # isLoaded ( ) } to check if 
 - * the object is fully loaded or register a listener { @ link io . realm . RealmObject # addChangeListener } 
 - * to be notified when the query completes . If no RealmObject was found after the query completed , the returned 
 - * RealmObject will have { @ link RealmObject # isLoaded ( ) } set to { @ code true } and { @ link RealmObject # isValid ( ) } set to 
 - * { @ code false } . 
 - * / 
 - public E findFirstAsync ( ) { 
 - checkQueryIsNotReused ( ) ; 
 - final WeakReference < RealmNotifier > weakNotifier = getWeakReferenceNotifier ( ) ; 
 - 
 - / / handover the query ( to be used by a worker thread ) 
 - final long handoverQueryPointer = query . handoverQuery ( realm . sharedRealm ) ; 
 - 
 - / / save query arguments ( for future update ) 
 - argumentsHolder = new ArgumentsHolder ( ArgumentsHolder . TYPE _ FIND _ FIRST ) ; 
 - 
 - final RealmConfiguration realmConfiguration = realm . getConfiguration ( ) ; 
 
 + / / TODO : The performance by the pending query will be a little bit worse than directly calling core ' s 
 + / / Query . find ( ) . The overhead comes with core needs to add all the row indices to the vector . However this can 
 + / / be optimized by adding support of limit in OS ' s Results which is supported by core already . 
 + PendingRow pendingRow = new PendingRow ( realm . sharedRealm , query , null ) ; 
 / / prepare an empty reference of the RealmObject , so we can return it immediately ( promise ) 
 / / then update it once the query complete in the background . 
 final E result ; 
 if ( isDynamicQuery ( ) ) { 
 / / noinspection unchecked 
 - result = ( E ) new DynamicRealmObject ( className , realm , Row . EMPTY _ ROW ) ; 
 + result = ( E ) new DynamicRealmObject ( className , realm , pendingRow ) ; 
 } else { 
 result = realm . getConfiguration ( ) . getSchemaMediator ( ) . newInstance ( 
 - clazz , realm , Row . EMPTY _ ROW , realm . getSchema ( ) . getColumnInfo ( clazz ) , 
 + clazz , realm , pendingRow , realm . getSchema ( ) . getColumnInfo ( clazz ) , 
 false , Collections . < String > emptyList ( ) ) ; 
 } 
 
 final RealmObjectProxy proxy = ( RealmObjectProxy ) result ; 
 - final WeakReference < RealmObjectProxy > realmObjectWeakReference = realm . handlerController . addToAsyncRealmObject ( proxy , this ) ; 
 - 
 - final Future < Long > pendingQuery = Realm . asyncTaskExecutor . submitQuery ( new Callable < Long > ( ) { 
 - @ Override 
 - public Long call ( ) throws Exception { 
 - if ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { 
 - SharedRealm sharedRealm = null ; 
 - 
 - try { 
 - sharedRealm = SharedRealm . getInstance ( realmConfiguration ) ; 
 - 
 - long handoverRowPointer = TableQuery . findWithHandover ( sharedRealm , handoverQueryPointer ) ; 
 - if ( handoverRowPointer = = 0 ) { / / empty row 
 - realm . handlerController . addToEmptyAsyncRealmObject ( realmObjectWeakReference , RealmQuery . this ) ; 
 - realm . handlerController . removeFromAsyncRealmObject ( realmObjectWeakReference ) ; 
 - } 
 - 
 - QueryUpdateTask . Result result = QueryUpdateTask . Result . newRealmObjectResponse ( ) ; 
 - result . updatedRow . put ( realmObjectWeakReference , handoverRowPointer ) ; 
 - result . versionID = sharedRealm . getVersionID ( ) ; 
 - closeSharedRealmAndSendEventToNotifier ( sharedRealm , 
 - weakNotifier , QueryUpdateTask . NotifyEvent . COMPLETE _ ASYNC _ OBJECT , result ) ; 
 - 
 - return handoverRowPointer ; 
 - 
 - } catch ( Throwable e ) { 
 - RealmLog . error ( e ) ; 
 - / / handler can ' t throw a checked exception need to wrap it into unchecked Exception 
 - closeSharedRealmAndSendEventToNotifier ( sharedRealm , 
 - weakNotifier , QueryUpdateTask . NotifyEvent . THROW _ BACKGROUND _ EXCEPTION , e ) ; 
 - } finally { 
 - if ( sharedRealm ! = null & & ! sharedRealm . isClosed ( ) ) { 
 - sharedRealm . close ( ) ; 
 - } 
 - } 
 - } else { 
 - TableQuery . nativeCloseQueryHandover ( handoverQueryPointer ) ; 
 - } 
 - 
 - return INVALID _ NATIVE _ POINTER ; 
 - } 
 - } ) ; 
 - proxy . realmGet $ proxyState ( ) . setPendingQuery $ realm ( pendingQuery ) ; 
 + pendingRow . setFrontEnd ( proxy . realmGet $ proxyState ( ) ) ; 
 
 return result ; 
 } 
 
 + / * * 
 + * @ deprecated use { @ link # findFirst ( ) } instead . 
 + * / 
 + public E findFirstAsync ( ) { 
 + return findFirst ( ) ; 
 + } 
 + 
 private void checkSortParameters ( String fieldNames [ ] , final Sort [ ] sortOrders ) { 
 if ( fieldNames = = null ) { 
 throw new IllegalArgumentException ( " fieldNames cannot be ' null ' . " ) ; 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 index 25fcf2c . . 3f24caf 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / PendingRow . java 
 @ @ - 1 , 8 + 1 , 235 @ @ 
 package io . realm . internal ; 
 
 + import java . lang . ref . WeakReference ; 
 + import java . util . Date ; 
 + 
 + import io . realm . RealmChangeListener ; 
 + import io . realm . RealmFieldType ; 
 + 
 / * * 
 - * Created by cc on 16 - 11 - 30 . 
 + * A PendingRow is a row relies on a pending async query . 
 + * Before the query returns , calling any accessors will immediately execute the query and call the corresponding 
 + * accessor on the query result . If the query results is empty , an { @ link IllegalStateException } will be thrown . 
 + * After the query returns , { @ link FrontEnd # onQueryFinished ( Row , boolean ) } will be called to give the front end a 
 + * chance to reset the row . If the async query returns an empty result , the query will be executed again later until a 
 + * valid row is contained by the query results . 
 * / 
 - 
 public class PendingRow implements Row { 
 + 
 + / / Implement this interface to reset the PendingRow to a Row backed by real data when query returned . 
 + public interface FrontEnd { 
 + / / When asyncQuery is true , the pending query is executed asynchronously . Otherwise the query is triggered by 
 + / / calling any accessors before the async query returns . 
 + void onQueryFinished ( Row row , boolean asyncQuery ) ; 
 + } 
 + 
 + private static final String EMPTY _ ROW _ MESSAGE = 
 + " This RealmObject is empty . There isn ' t any objects match the query . " ; 
 + private static final String PROXY _ NOT _ SET _ MESSAGE = " The ' frontEnd ' has not been set . " ; 
 + private static final String QUERY _ EXECUTED _ MESSAGE = 
 + " The query has been executed . This ' PendingRow ' is not valid anymore . " ; 
 + 
 + private Collection pendingCollection ; 
 + private Collection . Listener listener ; 
 + private WeakReference < FrontEnd > frontEnd ; 
 + 
 + public PendingRow ( SharedRealm sharedRealm , TableQuery query , SortDescriptor sortDescriptor ) { 
 + pendingCollection = new Collection ( sharedRealm , query , sortDescriptor ) ; 
 + listener = new Collection . Listener ( new RealmChangeListener < PendingRow > ( ) { 
 + @ Override 
 + public void onChange ( PendingRow pendingRow ) { 
 + if ( frontEnd = = null ) { 
 + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 + } 
 + / / TODO : PendingRow will always get the first Row of the query since we only support findFirst . 
 + Row row = pendingCollection . firstUncheckedRow ( ) ; 
 + if ( frontEnd . get ( ) = = null ) { 
 + / / The front end is GCed . 
 + clearPendingCollection ( ) ; 
 + return ; 
 + } 
 + / / If no rows returned by the query , just wait for the query updates until it returns a valid row . 
 + if ( row ! = null ) { 
 + / / Ask the front end to reset the row and stop async query . 
 + frontEnd . get ( ) . onQueryFinished ( row , true ) ; 
 + clearPendingCollection ( ) ; 
 + } 
 + } 
 + } , this ) ; 
 + pendingCollection . addListener ( listener ) ; 
 + } 
 + 
 + / / To set the front end of this PendingRow . 
 + public void setFrontEnd ( FrontEnd frontEnd ) { 
 + this . frontEnd = new WeakReference < FrontEnd > ( frontEnd ) ; 
 + } 
 + 
 + @ Override 
 + public long getColumnCount ( ) { 
 + return executeQuery ( ) . getColumnCount ( ) ; 
 + } 
 + 
 + @ Override 
 + public String getColumnName ( long columnIndex ) { 
 + return executeQuery ( ) . getColumnName ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public long getColumnIndex ( String columnName ) { 
 + return executeQuery ( ) . getColumnIndex ( columnName ) ; 
 + } 
 + 
 + @ Override 
 + public RealmFieldType getColumnType ( long columnIndex ) { 
 + return executeQuery ( ) . getColumnType ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public Table getTable ( ) { 
 + return executeQuery ( ) . getTable ( ) ; 
 + } 
 + 
 + @ Override 
 + public long getIndex ( ) { 
 + return executeQuery ( ) . getIndex ( ) ; 
 + } 
 + 
 + @ Override 
 + public long getLong ( long columnIndex ) { 
 + return executeQuery ( ) . getLong ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean getBoolean ( long columnIndex ) { 
 + return executeQuery ( ) . getBoolean ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public float getFloat ( long columnIndex ) { 
 + return executeQuery ( ) . getFloat ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public double getDouble ( long columnIndex ) { 
 + return executeQuery ( ) . getDouble ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public Date getDate ( long columnIndex ) { 
 + return executeQuery ( ) . getDate ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public String getString ( long columnIndex ) { 
 + return executeQuery ( ) . getString ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public byte [ ] getBinaryByteArray ( long columnIndex ) { 
 + return executeQuery ( ) . getBinaryByteArray ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public long getLink ( long columnIndex ) { 
 + return executeQuery ( ) . getLink ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isNullLink ( long columnIndex ) { 
 + return executeQuery ( ) . isNullLink ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public LinkView getLinkList ( long columnIndex ) { 
 + return executeQuery ( ) . getLinkList ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public void setLong ( long columnIndex , long value ) { 
 + executeQuery ( ) . setLong ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setBoolean ( long columnIndex , boolean value ) { 
 + executeQuery ( ) . setBoolean ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setFloat ( long columnIndex , float value ) { 
 + executeQuery ( ) . setFloat ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setDouble ( long columnIndex , double value ) { 
 + executeQuery ( ) . setDouble ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setDate ( long columnIndex , Date date ) { 
 + executeQuery ( ) . setDate ( columnIndex , date ) ; 
 + } 
 + 
 + @ Override 
 + public void setString ( long columnIndex , String value ) { 
 + executeQuery ( ) . setString ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void setBinaryByteArray ( long columnIndex , byte [ ] data ) { 
 + executeQuery ( ) . setBinaryByteArray ( columnIndex , data ) ; 
 + } 
 + 
 + @ Override 
 + public void setLink ( long columnIndex , long value ) { 
 + executeQuery ( ) . setLink ( columnIndex , value ) ; 
 + } 
 + 
 + @ Override 
 + public void nullifyLink ( long columnIndex ) { 
 + executeQuery ( ) . nullifyLink ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isNull ( long columnIndex ) { 
 + return executeQuery ( ) . isNull ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public void setNull ( long columnIndex ) { 
 + executeQuery ( ) . setNull ( columnIndex ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isAttached ( ) { 
 + return executeQuery ( ) . isAttached ( ) ; 
 + } 
 + 
 + @ Override 
 + public boolean hasColumn ( String fieldName ) { 
 + return executeQuery ( ) . hasColumn ( fieldName ) ; 
 + } 
 + 
 + private void clearPendingCollection ( ) { 
 + pendingCollection . removeListener ( listener ) ; 
 + pendingCollection = null ; 
 + listener = null ; 
 + } 
 + 
 + private Row executeQuery ( ) { 
 + if ( pendingCollection = = null ) { 
 + throw new IllegalStateException ( QUERY _ EXECUTED _ MESSAGE ) ; 
 + } 
 + if ( frontEnd = = null ) { 
 + throw new IllegalStateException ( PROXY _ NOT _ SET _ MESSAGE ) ; 
 + } 
 + Row row = pendingCollection . getUncheckedRow ( 0 ) ; 
 + if ( row = = null ) { 
 + throw new IllegalStateException ( EMPTY _ ROW _ MESSAGE ) ; 
 + } 
 + if ( frontEnd . get ( ) ! = null ) { 
 + frontEnd . get ( ) . onQueryFinished ( pendingCollection . firstUncheckedRow ( ) , false ) ; 
 + } 
 + clearPendingCollection ( ) ; 
 + return row ; 
 + } 
 } 
 diff - - git a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java 
 index 7802428 . . 5b5b441 100644 
 - - - a / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java 
 + + + b / realm / realm - library / src / main / java / io / realm / internal / UncheckedRow . java 
 @ @ - 89 , 8 + 89 , 10 @ @ public class UncheckedRow implements NativeObject , Row { 
 
 / / FIXME : Testing code 
 public static UncheckedRow getByRowPointer ( Table table , long nativeRowPointer ) { 
 - UncheckedRow row = new UncheckedRow ( table . context , table , nativeRowPointer ) ; 
 - return row ; 
 + if ( nativeRowPointer ! = 0 ) { 
 + return new UncheckedRow ( table . context , table , nativeRowPointer ) ; 
 + } 
 + return null ; 
 } 
 
 / * *
