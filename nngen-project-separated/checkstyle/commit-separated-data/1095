BLEU SCORE: 0.0167475178542289

TEST MSG: config : fix missed M2 _ HOME declaration
GENERATED MSG: checkstyle is building fine on windows , we ned to adjust appveyor

TEST DIFF (one line): diff - - git a / appveyor . yml b / appveyor . yml <nl> index ee06a21 . . e71b319 100644 <nl> - - - a / appveyor . yml <nl> + + + b / appveyor . yml <nl> @ @ - 19 , 7 + 19 , 8 @ @ install : <nl> ) <nl> [ System . IO . Compression . ZipFile ] : : ExtractToDirectory ( " C : \ maven - bin . zip " , " C : \ maven " ) <nl> } <nl> - - cmd : SET PATH = C : \ maven \ apache - maven - 3 . 2 . 5 \ bin ; % JAVA _ HOME % \ bin ; % PATH % <nl> + - cmd : SET M2 _ HOME = C : \ maven \ apache - maven - 3 . 2 . 5 <nl> + - cmd : SET PATH = % M2 _ HOME % \ bin ; % JAVA _ HOME % \ bin ; % PATH % <nl> - cmd : git config - - global core . autocrlf <nl> - cmd : mvn - - version <nl> - cmd : java - version
NEAREST DIFF (one line): diff - - git a / pom . xml b / pom . xml <nl> index fb29d60 . . cdd2fa1 100644 <nl> - - - a / pom . xml <nl> + + + b / pom . xml <nl> @ @ - 1083 , 7 + 1083 , 6 @ @ <nl> < regex > < pattern > . * . PropertyCacheFile < / pattern > < branchRate > 22 < / branchRate > < lineRate > 19 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checkstyle . ScopeUtils < / pattern > < branchRate > 90 < / branchRate > < lineRate > 94 < / lineRate > < / regex > <nl> < regex > < pattern > . * . TreeWalker < / pattern > < branchRate > 94 < / branchRate > < lineRate > 92 < / lineRate > < / regex > <nl> - < regex > < pattern > com . puppycrawl . tools . checkstyle . Utils < / pattern > < branchRate > 85 < / branchRate > < lineRate > 93 < / lineRate > < / regex > <nl> < regex > < pattern > . * . XMLLogger < / pattern > < branchRate > 86 < / branchRate > < lineRate > 97 < / lineRate > < / regex > <nl> <nl> <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java b / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java <nl> index 3ade1fc . . 235d03d 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java <nl> @ @ - 58 , 21 + 58 , 15 @ @ public final class Utils { <nl> } <nl> <nl> final String name = f . getName ( ) ; <nl> - try { <nl> - final int tokenValue = f . getInt ( name ) ; <nl> - builder . put ( name , tokenValue ) ; <nl> - if ( tokenValue > tempTokenValueToName . length - 1 ) { <nl> - final String [ ] temp = new String [ tokenValue + 1 ] ; <nl> - System . arraycopy ( tempTokenValueToName , 0 , <nl> - temp , 0 , tempTokenValueToName . length ) ; <nl> - tempTokenValueToName = temp ; <nl> - } <nl> - tempTokenValueToName [ tokenValue ] = name ; <nl> - } <nl> - catch ( final IllegalArgumentException | IllegalAccessException e ) { <nl> - throw new IllegalStateException ( <nl> - " Failed to instantiate collection of Java tokens " , e ) ; <nl> + final int tokenValue = getTokenFieldValue ( f , name ) ; <nl> + builder . put ( name , tokenValue ) ; <nl> + if ( tokenValue > tempTokenValueToName . length - 1 ) { <nl> + final String [ ] temp = new String [ tokenValue + 1 ] ; <nl> + System . arraycopy ( tempTokenValueToName , 0 , <nl> + temp , 0 , tempTokenValueToName . length ) ; <nl> + tempTokenValueToName = temp ; <nl> } <nl> + tempTokenValueToName [ tokenValue ] = name ; <nl> } <nl> <nl> TOKEN _ NAME _ TO _ VALUE = builder . build ( ) ; <nl> @ @ - 369 , 4 + 363 , 21 @ @ public final class Utils { <nl> throw new IllegalStateException ( ex ) ; <nl> } <nl> } <nl> + <nl> + / * * <nl> + * That method exists as workaround for code - coverage 100 % target to let test <nl> + * catch block ( originally it was in static area ) . <nl> + * @ param field token field <nl> + * @ param name token name <nl> + * @ return value of field <nl> + * / <nl> + private static int getTokenFieldValue ( Field field , String name ) { <nl> + try { <nl> + return field . getInt ( name ) ; <nl> + } <nl> + catch ( final IllegalArgumentException | IllegalAccessException e ) { <nl> + throw new IllegalStateException ( <nl> + " Failed to instantiate collection of Java tokens " , e ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java <nl> index 70452d2 . . 39327df 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java <nl> @ @ - 19 , 22 + 19 , 25 @ @ <nl> <nl> package com . puppycrawl . tools . checkstyle ; <nl> <nl> - import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; <nl> - import static com . puppycrawl . tools . checkstyle . Utils . baseClassname ; <nl> - import static com . puppycrawl . tools . checkstyle . Utils . relativizeAndNormalizePath ; <nl> - import static com . puppycrawl . tools . checkstyle . Utils . fileExtensionMatches ; <nl> - import static org . junit . Assert . assertEquals ; <nl> - import static org . junit . Assert . assertFalse ; <nl> - import static org . junit . Assert . assertTrue ; <nl> - import static org . junit . Assert . fail ; <nl> + import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> + import org . apache . commons . beanutils . ConversionException ; <nl> + import org . junit . Assert ; <nl> + import org . junit . Test ; <nl> <nl> - import java . lang . reflect . Constructor ; <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> + import java . lang . reflect . Constructor ; <nl> + import java . lang . reflect . Field ; <nl> + import java . lang . reflect . InvocationTargetException ; <nl> + import java . lang . reflect . Method ; <nl> + import java . lang . reflect . Modifier ; <nl> import java . util . Dictionary ; <nl> <nl> - import org . apache . commons . beanutils . ConversionException ; <nl> - import org . junit . Test ; <nl> + import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + import static org . junit . Assert . fail ; <nl> <nl> public class UtilsTest { <nl> <nl> @ @ - 74 , 34 + 77 , 34 @ @ public class UtilsTest { <nl> public void testFileExtensions ( ) { <nl> final String [ ] fileExtensions = { " java " } ; <nl> File file = new File ( " file . pdf " ) ; <nl> - assertFalse ( fileExtensionMatches ( file , fileExtensions ) ) ; <nl> - assertTrue ( fileExtensionMatches ( file , null ) ) ; <nl> + assertFalse ( Utils . fileExtensionMatches ( file , fileExtensions ) ) ; <nl> + assertTrue ( Utils . fileExtensionMatches ( file , null ) ) ; <nl> file = new File ( " file . java " ) ; <nl> - assertTrue ( fileExtensionMatches ( file , fileExtensions ) ) ; <nl> + assertTrue ( Utils . fileExtensionMatches ( file , fileExtensions ) ) ; <nl> file = new File ( " file . " ) ; <nl> - assertTrue ( fileExtensionMatches ( file , " " ) ) ; <nl> + assertTrue ( Utils . fileExtensionMatches ( file , " " ) ) ; <nl> } <nl> <nl> @ Test <nl> public void testBaseClassnameForCanonicalName ( ) { <nl> - assertEquals ( " List " , baseClassname ( " java . util . List " ) ) ; <nl> + assertEquals ( " List " , Utils . baseClassname ( " java . util . List " ) ) ; <nl> } <nl> <nl> @ Test <nl> public void testBaseClassnameForSimpleName ( ) { <nl> - assertEquals ( " Set " , baseClassname ( " Set " ) ) ; <nl> + assertEquals ( " Set " , Utils . baseClassname ( " Set " ) ) ; <nl> } <nl> <nl> @ Test <nl> public void testRelativeNormalizedPath ( ) { <nl> - final String relativePath = relativizeAndNormalizePath ( " / home " , " / home / test " ) ; <nl> + final String relativePath = Utils . relativizeAndNormalizePath ( " / home " , " / home / test " ) ; <nl> <nl> assertEquals ( " test " , relativePath ) ; <nl> } <nl> <nl> @ Test <nl> public void testRelativeNormalizedPathWithNullBaseDirectory ( ) { <nl> - final String relativePath = relativizeAndNormalizePath ( null , " / tmp " ) ; <nl> + final String relativePath = Utils . relativizeAndNormalizePath ( null , " / tmp " ) ; <nl> <nl> assertEquals ( " / tmp " , relativePath ) ; <nl> } <nl> @ @ - 112 , 7 + 115 , 7 @ @ public class UtilsTest { <nl> final String absoluteFilePath = sampleAbsolutePath + " / SampleFile . java " ; <nl> final String basePath = sampleAbsolutePath + PATH _ DENORMALIZER ; <nl> <nl> - final String relativePath = relativizeAndNormalizePath ( basePath , absoluteFilePath ) ; <nl> + final String relativePath = Utils . relativizeAndNormalizePath ( basePath , absoluteFilePath ) ; <nl> <nl> assertEquals ( " SampleFile . java " , relativePath ) ; <nl> } <nl> @ @ - 167 , 4 + 170 , 111 @ @ public class UtilsTest { <nl> assertEquals ( InstantiationException . class , expected . getCause ( ) . getClass ( ) ) ; <nl> } <nl> } <nl> + <nl> + @ Test <nl> + public void testTokenValueIncorrect ( ) throws NoSuchMethodException { <nl> + Integer id = Integer . MAX _ VALUE - 1 ; <nl> + try { <nl> + Utils . getTokenName ( id ) ; <nl> + fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException expected ) { <nl> + assertEquals ( " given id " + id , expected . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testTokenValueIncorrect2 ( ) throws NoSuchMethodException , IllegalAccessException { <nl> + Integer id = 0 ; <nl> + String [ ] originalValue = null ; <nl> + Field fieldToken = null ; <nl> + try { <nl> + / / overwrite static field with new value <nl> + Field [ ] fields = Utils . class . getDeclaredFields ( ) ; <nl> + for ( Field field : fields ) { <nl> + field . setAccessible ( true ) ; <nl> + if ( " TOKEN _ VALUE _ TO _ NAME " . equals ( field . getName ( ) ) ) { <nl> + fieldToken = field ; <nl> + Field modifiersField = Field . class . getDeclaredField ( " modifiers " ) ; <nl> + modifiersField . setAccessible ( true ) ; <nl> + modifiersField . setInt ( field , field . getModifiers ( ) & ~ Modifier . FINAL ) ; <nl> + originalValue = ( String [ ] ) field . get ( null ) ; <nl> + field . set ( null , new String [ ] { null } ) ; <nl> + } <nl> + } <nl> + <nl> + Utils . getTokenName ( id ) ; <nl> + fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException expected ) { <nl> + / / restoring original value , to let other tests pass <nl> + fieldToken . set ( null , originalValue ) ; <nl> + <nl> + assertEquals ( " given id " + id , expected . getMessage ( ) ) ; <nl> + <nl> + } <nl> + catch ( IllegalAccessException e ) { <nl> + fail ( ) ; <nl> + } <nl> + catch ( NoSuchFieldException e ) { <nl> + fail ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testTokenIdIncorrect ( ) throws NoSuchMethodException { <nl> + String id = " NON _ EXISTING _ VALUE " ; <nl> + try { <nl> + Utils . getTokenId ( id ) ; <nl> + fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException expected ) { <nl> + assertEquals ( " given name " + id , expected . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testShortDescriptionIncorrect ( ) throws NoSuchMethodException { <nl> + String id = " NON _ EXISTING _ VALUE " ; <nl> + try { <nl> + Utils . getShortDescription ( id ) ; <nl> + fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException expected ) { <nl> + assertEquals ( " given name " + id , expected . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testIsCommentType ( ) throws NoSuchMethodException { <nl> + Assert . assertTrue ( Utils . isCommentType ( TokenTypes . SINGLE _ LINE _ COMMENT ) ) ; <nl> + Assert . assertTrue ( Utils . isCommentType ( TokenTypes . BLOCK _ COMMENT _ BEGIN ) ) ; <nl> + Assert . assertTrue ( Utils . isCommentType ( TokenTypes . BLOCK _ COMMENT _ END ) ) ; <nl> + Assert . assertTrue ( Utils . isCommentType ( TokenTypes . COMMENT _ CONTENT ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testGetTokenFieldValue ( ) throws NoSuchMethodException { <nl> + Integer id = 0 ; <nl> + try { <nl> + / / overwrite static field with new value <nl> + Method method = Utils . class . getDeclaredMethod ( " getTokenFieldValue " , <nl> + Field . class , String . class ) ; <nl> + method . setAccessible ( true ) ; <nl> + method . invoke ( null , Field . class . getDeclaredField ( " modifiers " ) , " smth _ strange " ) ; <nl> + <nl> + fail ( ) ; <nl> + } <nl> + catch ( InvocationTargetException expected ) { <nl> + / / in method we throw IllegalStateException , <nl> + / / but JDK wrap that in InvocationTargetException <nl> + assertEquals ( IllegalStateException . class , expected . getCause ( ) . getClass ( ) ) ; <nl> + assertEquals ( " Failed to instantiate collection of Java tokens " , <nl> + expected . getCause ( ) . getMessage ( ) ) ; <nl> + } <nl> + catch ( Exception e ) { <nl> + fail ( ) ; <nl> + } <nl> + } <nl> + <nl> }

TEST DIFF:
diff - - git a / appveyor . yml b / appveyor . yml 
 index ee06a21 . . e71b319 100644 
 - - - a / appveyor . yml 
 + + + b / appveyor . yml 
 @ @ - 19 , 7 + 19 , 8 @ @ install : 
 ) 
 [ System . IO . Compression . ZipFile ] : : ExtractToDirectory ( " C : \ maven - bin . zip " , " C : \ maven " ) 
 } 
 - - cmd : SET PATH = C : \ maven \ apache - maven - 3 . 2 . 5 \ bin ; % JAVA _ HOME % \ bin ; % PATH % 
 + - cmd : SET M2 _ HOME = C : \ maven \ apache - maven - 3 . 2 . 5 
 + - cmd : SET PATH = % M2 _ HOME % \ bin ; % JAVA _ HOME % \ bin ; % PATH % 
 - cmd : git config - - global core . autocrlf 
 - cmd : mvn - - version 
 - cmd : java - version

NEAREST DIFF:
diff - - git a / pom . xml b / pom . xml 
 index fb29d60 . . cdd2fa1 100644 
 - - - a / pom . xml 
 + + + b / pom . xml 
 @ @ - 1083 , 7 + 1083 , 6 @ @ 
 < regex > < pattern > . * . PropertyCacheFile < / pattern > < branchRate > 22 < / branchRate > < lineRate > 19 < / lineRate > < / regex > 
 < regex > < pattern > . * . checkstyle . ScopeUtils < / pattern > < branchRate > 90 < / branchRate > < lineRate > 94 < / lineRate > < / regex > 
 < regex > < pattern > . * . TreeWalker < / pattern > < branchRate > 94 < / branchRate > < lineRate > 92 < / lineRate > < / regex > 
 - < regex > < pattern > com . puppycrawl . tools . checkstyle . Utils < / pattern > < branchRate > 85 < / branchRate > < lineRate > 93 < / lineRate > < / regex > 
 < regex > < pattern > . * . XMLLogger < / pattern > < branchRate > 86 < / branchRate > < lineRate > 97 < / lineRate > < / regex > 
 
 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java b / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java 
 index 3ade1fc . . 235d03d 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java 
 @ @ - 58 , 21 + 58 , 15 @ @ public final class Utils { 
 } 
 
 final String name = f . getName ( ) ; 
 - try { 
 - final int tokenValue = f . getInt ( name ) ; 
 - builder . put ( name , tokenValue ) ; 
 - if ( tokenValue > tempTokenValueToName . length - 1 ) { 
 - final String [ ] temp = new String [ tokenValue + 1 ] ; 
 - System . arraycopy ( tempTokenValueToName , 0 , 
 - temp , 0 , tempTokenValueToName . length ) ; 
 - tempTokenValueToName = temp ; 
 - } 
 - tempTokenValueToName [ tokenValue ] = name ; 
 - } 
 - catch ( final IllegalArgumentException | IllegalAccessException e ) { 
 - throw new IllegalStateException ( 
 - " Failed to instantiate collection of Java tokens " , e ) ; 
 + final int tokenValue = getTokenFieldValue ( f , name ) ; 
 + builder . put ( name , tokenValue ) ; 
 + if ( tokenValue > tempTokenValueToName . length - 1 ) { 
 + final String [ ] temp = new String [ tokenValue + 1 ] ; 
 + System . arraycopy ( tempTokenValueToName , 0 , 
 + temp , 0 , tempTokenValueToName . length ) ; 
 + tempTokenValueToName = temp ; 
 } 
 + tempTokenValueToName [ tokenValue ] = name ; 
 } 
 
 TOKEN _ NAME _ TO _ VALUE = builder . build ( ) ; 
 @ @ - 369 , 4 + 363 , 21 @ @ public final class Utils { 
 throw new IllegalStateException ( ex ) ; 
 } 
 } 
 + 
 + / * * 
 + * That method exists as workaround for code - coverage 100 % target to let test 
 + * catch block ( originally it was in static area ) . 
 + * @ param field token field 
 + * @ param name token name 
 + * @ return value of field 
 + * / 
 + private static int getTokenFieldValue ( Field field , String name ) { 
 + try { 
 + return field . getInt ( name ) ; 
 + } 
 + catch ( final IllegalArgumentException | IllegalAccessException e ) { 
 + throw new IllegalStateException ( 
 + " Failed to instantiate collection of Java tokens " , e ) ; 
 + } 
 + } 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java 
 index 70452d2 . . 39327df 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java 
 @ @ - 19 , 22 + 19 , 25 @ @ 
 
 package com . puppycrawl . tools . checkstyle ; 
 
 - import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; 
 - import static com . puppycrawl . tools . checkstyle . Utils . baseClassname ; 
 - import static com . puppycrawl . tools . checkstyle . Utils . relativizeAndNormalizePath ; 
 - import static com . puppycrawl . tools . checkstyle . Utils . fileExtensionMatches ; 
 - import static org . junit . Assert . assertEquals ; 
 - import static org . junit . Assert . assertFalse ; 
 - import static org . junit . Assert . assertTrue ; 
 - import static org . junit . Assert . fail ; 
 + import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 + import org . apache . commons . beanutils . ConversionException ; 
 + import org . junit . Assert ; 
 + import org . junit . Test ; 
 
 - import java . lang . reflect . Constructor ; 
 import java . io . File ; 
 import java . io . IOException ; 
 + import java . lang . reflect . Constructor ; 
 + import java . lang . reflect . Field ; 
 + import java . lang . reflect . InvocationTargetException ; 
 + import java . lang . reflect . Method ; 
 + import java . lang . reflect . Modifier ; 
 import java . util . Dictionary ; 
 
 - import org . apache . commons . beanutils . ConversionException ; 
 - import org . junit . Test ; 
 + import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 + import static org . junit . Assert . assertTrue ; 
 + import static org . junit . Assert . fail ; 
 
 public class UtilsTest { 
 
 @ @ - 74 , 34 + 77 , 34 @ @ public class UtilsTest { 
 public void testFileExtensions ( ) { 
 final String [ ] fileExtensions = { " java " } ; 
 File file = new File ( " file . pdf " ) ; 
 - assertFalse ( fileExtensionMatches ( file , fileExtensions ) ) ; 
 - assertTrue ( fileExtensionMatches ( file , null ) ) ; 
 + assertFalse ( Utils . fileExtensionMatches ( file , fileExtensions ) ) ; 
 + assertTrue ( Utils . fileExtensionMatches ( file , null ) ) ; 
 file = new File ( " file . java " ) ; 
 - assertTrue ( fileExtensionMatches ( file , fileExtensions ) ) ; 
 + assertTrue ( Utils . fileExtensionMatches ( file , fileExtensions ) ) ; 
 file = new File ( " file . " ) ; 
 - assertTrue ( fileExtensionMatches ( file , " " ) ) ; 
 + assertTrue ( Utils . fileExtensionMatches ( file , " " ) ) ; 
 } 
 
 @ Test 
 public void testBaseClassnameForCanonicalName ( ) { 
 - assertEquals ( " List " , baseClassname ( " java . util . List " ) ) ; 
 + assertEquals ( " List " , Utils . baseClassname ( " java . util . List " ) ) ; 
 } 
 
 @ Test 
 public void testBaseClassnameForSimpleName ( ) { 
 - assertEquals ( " Set " , baseClassname ( " Set " ) ) ; 
 + assertEquals ( " Set " , Utils . baseClassname ( " Set " ) ) ; 
 } 
 
 @ Test 
 public void testRelativeNormalizedPath ( ) { 
 - final String relativePath = relativizeAndNormalizePath ( " / home " , " / home / test " ) ; 
 + final String relativePath = Utils . relativizeAndNormalizePath ( " / home " , " / home / test " ) ; 
 
 assertEquals ( " test " , relativePath ) ; 
 } 
 
 @ Test 
 public void testRelativeNormalizedPathWithNullBaseDirectory ( ) { 
 - final String relativePath = relativizeAndNormalizePath ( null , " / tmp " ) ; 
 + final String relativePath = Utils . relativizeAndNormalizePath ( null , " / tmp " ) ; 
 
 assertEquals ( " / tmp " , relativePath ) ; 
 } 
 @ @ - 112 , 7 + 115 , 7 @ @ public class UtilsTest { 
 final String absoluteFilePath = sampleAbsolutePath + " / SampleFile . java " ; 
 final String basePath = sampleAbsolutePath + PATH _ DENORMALIZER ; 
 
 - final String relativePath = relativizeAndNormalizePath ( basePath , absoluteFilePath ) ; 
 + final String relativePath = Utils . relativizeAndNormalizePath ( basePath , absoluteFilePath ) ; 
 
 assertEquals ( " SampleFile . java " , relativePath ) ; 
 } 
 @ @ - 167 , 4 + 170 , 111 @ @ public class UtilsTest { 
 assertEquals ( InstantiationException . class , expected . getCause ( ) . getClass ( ) ) ; 
 } 
 } 
 + 
 + @ Test 
 + public void testTokenValueIncorrect ( ) throws NoSuchMethodException { 
 + Integer id = Integer . MAX _ VALUE - 1 ; 
 + try { 
 + Utils . getTokenName ( id ) ; 
 + fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException expected ) { 
 + assertEquals ( " given id " + id , expected . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testTokenValueIncorrect2 ( ) throws NoSuchMethodException , IllegalAccessException { 
 + Integer id = 0 ; 
 + String [ ] originalValue = null ; 
 + Field fieldToken = null ; 
 + try { 
 + / / overwrite static field with new value 
 + Field [ ] fields = Utils . class . getDeclaredFields ( ) ; 
 + for ( Field field : fields ) { 
 + field . setAccessible ( true ) ; 
 + if ( " TOKEN _ VALUE _ TO _ NAME " . equals ( field . getName ( ) ) ) { 
 + fieldToken = field ; 
 + Field modifiersField = Field . class . getDeclaredField ( " modifiers " ) ; 
 + modifiersField . setAccessible ( true ) ; 
 + modifiersField . setInt ( field , field . getModifiers ( ) & ~ Modifier . FINAL ) ; 
 + originalValue = ( String [ ] ) field . get ( null ) ; 
 + field . set ( null , new String [ ] { null } ) ; 
 + } 
 + } 
 + 
 + Utils . getTokenName ( id ) ; 
 + fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException expected ) { 
 + / / restoring original value , to let other tests pass 
 + fieldToken . set ( null , originalValue ) ; 
 + 
 + assertEquals ( " given id " + id , expected . getMessage ( ) ) ; 
 + 
 + } 
 + catch ( IllegalAccessException e ) { 
 + fail ( ) ; 
 + } 
 + catch ( NoSuchFieldException e ) { 
 + fail ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testTokenIdIncorrect ( ) throws NoSuchMethodException { 
 + String id = " NON _ EXISTING _ VALUE " ; 
 + try { 
 + Utils . getTokenId ( id ) ; 
 + fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException expected ) { 
 + assertEquals ( " given name " + id , expected . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testShortDescriptionIncorrect ( ) throws NoSuchMethodException { 
 + String id = " NON _ EXISTING _ VALUE " ; 
 + try { 
 + Utils . getShortDescription ( id ) ; 
 + fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException expected ) { 
 + assertEquals ( " given name " + id , expected . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testIsCommentType ( ) throws NoSuchMethodException { 
 + Assert . assertTrue ( Utils . isCommentType ( TokenTypes . SINGLE _ LINE _ COMMENT ) ) ; 
 + Assert . assertTrue ( Utils . isCommentType ( TokenTypes . BLOCK _ COMMENT _ BEGIN ) ) ; 
 + Assert . assertTrue ( Utils . isCommentType ( TokenTypes . BLOCK _ COMMENT _ END ) ) ; 
 + Assert . assertTrue ( Utils . isCommentType ( TokenTypes . COMMENT _ CONTENT ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testGetTokenFieldValue ( ) throws NoSuchMethodException { 
 + Integer id = 0 ; 
 + try { 
 + / / overwrite static field with new value 
 + Method method = Utils . class . getDeclaredMethod ( " getTokenFieldValue " , 
 + Field . class , String . class ) ; 
 + method . setAccessible ( true ) ; 
 + method . invoke ( null , Field . class . getDeclaredField ( " modifiers " ) , " smth _ strange " ) ; 
 + 
 + fail ( ) ; 
 + } 
 + catch ( InvocationTargetException expected ) { 
 + / / in method we throw IllegalStateException , 
 + / / but JDK wrap that in InvocationTargetException 
 + assertEquals ( IllegalStateException . class , expected . getCause ( ) . getClass ( ) ) ; 
 + assertEquals ( " Failed to instantiate collection of Java tokens " , 
 + expected . getCause ( ) . getMessage ( ) ) ; 
 + } 
 + catch ( Exception e ) { 
 + fail ( ) ; 
 + } 
 + } 
 + 
 }
