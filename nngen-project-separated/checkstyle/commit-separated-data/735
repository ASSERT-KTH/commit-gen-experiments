BLEU SCORE: 0.06840594582318651

TEST MSG: Issue # 2329 : Updated lexer grammar to allow javadoc with CR newlines
GENERATED MSG: Issue # 4349 : Changed the lexer grammar for javadoc to make package names conform to the standard

TEST DIFF (one line): diff - - git a / config / checkstyle _ non _ main _ files _ suppressions . xml b / config / checkstyle _ non _ main _ files _ suppressions . xml <nl> index c267245 . . cb9dd4c 100644 <nl> - - - a / config / checkstyle _ non _ main _ files _ suppressions . xml <nl> + + + b / config / checkstyle _ non _ main _ files _ suppressions . xml <nl> @ @ - 14 , 11 + 14 , 9 @ @ <nl> <nl> < ! - - Grammar specific input file , should have exact structure to reproduce the case . - - > <nl> < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] InputEmbeddedNullChar \ . java " / > <nl> - < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] javadoc [ \ \ / ] InputLeadingAsterisks \ . javadoc " / > <nl> <nl> < ! - - Javadoc files should not have new line by design ( on purpose ) . - - > <nl> - < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] javadoc [ \ \ / ] htmlTags [ \ \ / ] . * " / > <nl> - < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] javadoc [ \ \ / ] javadocTags [ \ \ / ] . * " / > <nl> + < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] javadoc [ \ \ / ] . * \ . javadoc " / > <nl> < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] astprinter [ \ \ / ] . * \ . javadoc " / > <nl> <nl> < ! - - Empty file cannot have any new line at the end . - - > <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 <nl> index 34d1e5f . . f015ae5 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 <nl> @ @ - 37 , 8 + 37 , 9 @ @ import java . util . * ; <nl> <nl> } <nl> <nl> - LEADING _ ASTERISK : ( ( ' ' | ' \ t ' ) { _ tokenStartCharPositionInLine = = 0 } ? ) ( ' ' | ' \ t ' ) * ' * ' <nl> - | ' * ' { _ tokenStartCharPositionInLine = = 0 } ? <nl> + LEADING _ ASTERISK : ( ( ' ' | ' \ t ' ) { _ tokenStartCharPositionInLine = = 0 <nl> + | | previousTokenType = = NEWLINE } ? ) ( ' ' | ' \ t ' ) * ' * ' <nl> + | ' * ' { _ tokenStartCharPositionInLine = = 0 | | previousTokenType = = NEWLINE } ? <nl> ; <nl> <nl> HTML _ COMMENT _ START : ' < ! - - ' { recognizeXmlTags } ? <nl> @ @ - 59 , 7 + 60 , 7 @ @ OPEN : ' < ' { recognizeXmlTags & & ( Character . isLetter ( _ input . LA ( 1 ) ) | | _ input . LA ( 1 ) <nl> / / { insidePreTag = false ; recognizeXmlTags = true ; } <nl> / / ; <nl> <nl> - NEWLINE : ' \ n ' | ' \ r \ n ' ; <nl> + NEWLINE : ' \ n ' | ' \ r \ n ' | ' \ r ' ; <nl> <nl> AUTHOR _ LITERAL : ' @ author ' { isJavadocTagAvailable } ? ; <nl> DEPRECATED _ LITERAL : ' @ deprecated ' { isJavadocTagAvailable } ? ; <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParseTreeTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParseTreeTest . java <nl> index 47246e0 . . b194e04 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParseTreeTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParseTreeTest . java <nl> @ @ - 244 , 4 + 244 , 10 @ @ public class JavadocParseTreeTest extends BaseCheckTestSupport { <nl> verifyJavadocTree ( getDocPath ( " expectedTwoLinkTagsInRowAst . txt " ) , <nl> getDocPath ( " InputTwoLinkTagsInRow . javadoc " ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testJavadocWithCrAsNewline ( ) throws Exception { <nl> + verifyJavadocTree ( getPath ( " expectedJavadocWithCrAsNewlineAst . txt " ) , <nl> + getPath ( " InputJavadocWithCrAsNewline . javadoc " ) ) ; <nl> + } <nl> } <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / InputJavadocWithCrAsNewline . javadoc b / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / InputJavadocWithCrAsNewline . javadoc <nl> new file mode 100644 <nl> index 0000000 . . ec3cf7f <nl> - - - / dev / null <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / InputJavadocWithCrAsNewline . javadoc <nl> @ @ - 0 , 0 + 1 @ @ <nl> + <nl> * Checks that commentContent starts with ' * ' javadoc comment identifier . <nl> * & lt ; property name = " ignorePattern " value = " ^ * \ * * [ ^ ] + $ " / & gt * <nl> 	 * This * is not a leading * <nl> * @ return true if commentContent starts with ' * ' javadoc comment identifier <nl> \ No newline at end of file <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / expectedJavadocWithCrAsNewlineAst . txt b / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / expectedJavadocWithCrAsNewlineAst . txt <nl> new file mode 100644 <nl> index 0000000 . . 35fa622 <nl> - - - / dev / null <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / expectedJavadocWithCrAsNewlineAst . txt <nl> @ @ - 0 , 0 + 1 , 21 @ @ <nl> + JAVADOC - > JAVADOC [ 0 : 0 ] <nl> + | - - TEXT - > [ 0 : 0 ] <nl> + | - - NEWLINE - > \ r [ 0 : 4 ] <nl> + | - - LEADING _ ASTERISK - > * [ 0 : 5 ] <nl> + | - - TEXT - > Checks that commentContent starts with ' * ' javadoc comment identifier . [ 0 : 6 ] <nl> + | - - NEWLINE - > \ r [ 0 : 77 ] <nl> + | - - LEADING _ ASTERISK - > * [ 0 : 78 ] <nl> + | - - TEXT - > & lt ; property name = " ignorePattern " value = " ^ * \ * * [ ^ ] + $ " / & gt * [ 0 : 83 ] <nl> + | - - NEWLINE - > \ r [ 0 : 143 ] <nl> + | - - LEADING _ ASTERISK - > \ t * [ 0 : 144 ] <nl> + | - - TEXT - > This * is not a leading * [ 0 : 146 ] <nl> + | - - NEWLINE - > \ r [ 0 : 172 ] <nl> + | - - LEADING _ ASTERISK - > * [ 0 : 173 ] <nl> + | - - WS - > [ 0 : 174 ] <nl> + | - - JAVADOC _ TAG - > JAVADOC _ TAG [ 0 : 175 ] <nl> + | | - - RETURN _ LITERAL - > @ return [ 0 : 175 ] <nl> + | | - - WS - > [ 0 : 182 ] <nl> + | ` - - DESCRIPTION - > DESCRIPTION [ 0 : 183 ] <nl> + | | - - TEXT - > true if commentContent starts with ' * ' javadoc comment identifier [ 0 : 183 ] <nl> + | ` - - NEWLINE - > \ r [ 0 : 248 ] <nl> + ` - - EOF - > < EOF > [ 0 : 249 ]
NEAREST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheck . java <nl> index 9f4ca37 . . 230f2bd 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheck . java <nl> @ @ - 56 , 6 + 56 , 9 @ @ public class ExplicitInitializationCheck extends AbstractCheck { <nl> * / <nl> public static final String MSG _ KEY = " explicit . init " ; <nl> <nl> + / * * Whether only explicit initialization made to null should be checked . * * / <nl> + private boolean onlyObjectReferences ; <nl> + <nl> @ Override <nl> public final int [ ] getDefaultTokens ( ) { <nl> return new int [ ] { TokenTypes . VARIABLE _ DEF } ; <nl> @ @ - 71 , 6 + 74 , 15 @ @ public class ExplicitInitializationCheck extends AbstractCheck { <nl> return new int [ ] { TokenTypes . VARIABLE _ DEF } ; <nl> } <nl> <nl> + / * * <nl> + * Sets whether only explicit initialization made to null should be checked . <nl> + * @ param onlyObjectReferences whether only explicit initialization made to null <nl> + * should be checked <nl> + * / <nl> + public void setOnlyObjectReferences ( boolean onlyObjectReferences ) { <nl> + this . onlyObjectReferences = onlyObjectReferences ; <nl> + } <nl> + <nl> @ Override <nl> public void visitToken ( DetailAST ast ) { <nl> if ( ! isSkipCase ( ast ) ) { <nl> @ @ - 83 , 19 + 95 , 33 @ @ public class ExplicitInitializationCheck extends AbstractCheck { <nl> & & exprStart . getType ( ) = = TokenTypes . LITERAL _ NULL ) { <nl> log ( ident , MSG _ KEY , ident . getText ( ) , " null " ) ; <nl> } <nl> + if ( ! onlyObjectReferences ) { <nl> + validateNonObjects ( ast ) ; <nl> + } <nl> + } <nl> + } <nl> <nl> - final int primitiveType = type . getFirstChild ( ) . getType ( ) ; <nl> - if ( primitiveType = = TokenTypes . LITERAL _ BOOLEAN <nl> + / * * <nl> + * Checks for explicit initializations made to ' false ' , ' 0 ' and ' \ 0 ' . <nl> + * @ param ast token being checked for explicit initializations <nl> + * / <nl> + private void validateNonObjects ( DetailAST ast ) { <nl> + final DetailAST ident = ast . findFirstToken ( TokenTypes . IDENT ) ; <nl> + final DetailAST assign = ast . findFirstToken ( TokenTypes . ASSIGN ) ; <nl> + final DetailAST exprStart = <nl> + assign . getFirstChild ( ) . getFirstChild ( ) ; <nl> + final DetailAST type = ast . findFirstToken ( TokenTypes . TYPE ) ; <nl> + final int primitiveType = type . getFirstChild ( ) . getType ( ) ; <nl> + if ( primitiveType = = TokenTypes . LITERAL _ BOOLEAN <nl> & & exprStart . getType ( ) = = TokenTypes . LITERAL _ FALSE ) { <nl> - log ( ident , MSG _ KEY , ident . getText ( ) , " false " ) ; <nl> - } <nl> - if ( isNumericType ( primitiveType ) & & isZero ( exprStart ) ) { <nl> - log ( ident , MSG _ KEY , ident . getText ( ) , " 0 " ) ; <nl> - } <nl> - if ( primitiveType = = TokenTypes . LITERAL _ CHAR <nl> + log ( ident , MSG _ KEY , ident . getText ( ) , " false " ) ; <nl> + } <nl> + if ( isNumericType ( primitiveType ) & & isZero ( exprStart ) ) { <nl> + log ( ident , MSG _ KEY , ident . getText ( ) , " 0 " ) ; <nl> + } <nl> + if ( primitiveType = = TokenTypes . LITERAL _ CHAR <nl> & & isZeroChar ( exprStart ) ) { <nl> - log ( ident , MSG _ KEY , ident . getText ( ) , " \ \ 0 " ) ; <nl> - } <nl> + log ( ident , MSG _ KEY , ident . getText ( ) , " \ \ 0 " ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheckTest . java <nl> index b77a3ac . . a7e28a7 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheckTest . java <nl> @ @ - 74 , 4 + 74 , 24 @ @ public class ExplicitInitializationCheckTest extends BaseCheckTestSupport { <nl> Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; <nl> Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testonlyObjectReferences ( ) throws Exception { <nl> + final DefaultConfiguration checkConfig = <nl> + createCheckConfig ( ExplicitInitializationCheck . class ) ; <nl> + checkConfig . addAttribute ( " onlyObjectReferences " , " true " ) ; <nl> + final String [ ] expected = { <nl> + " 5 : 20 : " + getCheckMessage ( MSG _ KEY , " bar " , " null " ) , <nl> + " 14 : 22 : " + getCheckMessage ( MSG _ KEY , " str1 " , " null " ) , <nl> + " 14 : 35 : " + getCheckMessage ( MSG _ KEY , " str3 " , " null " ) , <nl> + " 15 : 9 : " + getCheckMessage ( MSG _ KEY , " ar1 " , " null " ) , <nl> + " 39 : 25 : " + getCheckMessage ( MSG _ KEY , " bar " , " null " ) , <nl> + " 40 : 27 : " + getCheckMessage ( MSG _ KEY , " barArray " , " null " ) , <nl> + " 48 : 29 : " + getCheckMessage ( MSG _ KEY , " bar " , " null " ) , <nl> + " 49 : 31 : " + getCheckMessage ( MSG _ KEY , " barArray " , " null " ) , <nl> + " 53 : 25 : " + getCheckMessage ( MSG _ KEY , " bar " , " null " ) , <nl> + " 54 : 27 : " + getCheckMessage ( MSG _ KEY , " barArray " , " null " ) , <nl> + } ; <nl> + verify ( checkConfig , getPath ( " InputExplicitInitialization . java " ) , expected ) ; <nl> + } <nl> } <nl> diff - - git a / src / xdocs / config _ coding . xml b / src / xdocs / config _ coding . xml <nl> index 7b31e70 . . 96d0a58 100644 <nl> - - - a / src / xdocs / config _ coding . xml <nl> + + + b / src / xdocs / config _ coding . xml <nl> @ @ - 861 , 6 + 861 , 24 @ @ String nullString = null ; <nl> < / p > <nl> < / subsection > <nl> <nl> + < subsection name = " Properties " > <nl> + < table > <nl> + < tr > <nl> + < th > name < / th > <nl> + < th > description < / th > <nl> + < th > type < / th > <nl> + < th > default value < / th > <nl> + < / tr > <nl> + < tr > <nl> + < td > onlyObjectReferences < / td > <nl> + < td > whether only explicit initializations made to <nl> + null for objects should be checked < / td > <nl> + < td > < a href = " property _ types . html # boolean " > Boolean < / a > < / td > <nl> + < td > < code > false < / code > < / td > <nl> + < / tr > <nl> + < / table > <nl> + < / subsection > <nl> + <nl> < subsection name = " Examples " > <nl> < p > <nl> To configure the check : <nl> @ @ - 868 , 6 + 886 , 46 @ @ String nullString = null ; <nl> < source > <nl> & lt ; module name = & quot ; ExplicitInitialization & quot ; / & gt ; <nl> < / source > <nl> + <nl> + < p > <nl> + To configure the check so that it only checks <nl> + for objects that explicitly initialize to null : <nl> + < / p > <nl> + < source > <nl> + & lt ; module name = & quot ; ExplicitInitialization & quot ; & gt ; <nl> + & lt ; property name = & quot ; onlyObjectReferences & quot ; value = & quot ; true & quot ; / & gt ; <nl> + & lt ; / module & gt ; <nl> + < / source > <nl> + < p > Example : < / p > <nl> + < p > <nl> + < source > <nl> + public class Test { <nl> + private int a = 0 ; <nl> + private int b = 1 ; <nl> + private int c = 2 ; <nl> + <nl> + private boolean a = true ; <nl> + private boolean b = false ; <nl> + private boolean c = true ; <nl> + private boolean d = false ; <nl> + private boolean e = false ; <nl> + <nl> + private A a = new A ( ) ; <nl> + private A b = null ; / / violation <nl> + private C c = null ; / / violation <nl> + private D d = new D ( ) ; <nl> + <nl> + int ar1 [ ] = null ; / / violation <nl> + int ar2 [ ] = new int [ ] ; <nl> + int ar3 [ ] ; <nl> + private Bar & lt ; String & gt ; bar = null ; / / violation <nl> + private Bar & lt ; String & gt ; [ ] barArray = null ; / / violation <nl> + <nl> + public static void main ( String [ ] args ) { <nl> + } <nl> + } <nl> + < / source > <nl> + < / p > <nl> < / subsection > <nl> <nl> < subsection name = " Example of Usage " >

TEST DIFF:
diff - - git a / config / checkstyle _ non _ main _ files _ suppressions . xml b / config / checkstyle _ non _ main _ files _ suppressions . xml 
 index c267245 . . cb9dd4c 100644 
 - - - a / config / checkstyle _ non _ main _ files _ suppressions . xml 
 + + + b / config / checkstyle _ non _ main _ files _ suppressions . xml 
 @ @ - 14 , 11 + 14 , 9 @ @ 
 
 < ! - - Grammar specific input file , should have exact structure to reproduce the case . - - > 
 < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] InputEmbeddedNullChar \ . java " / > 
 - < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] javadoc [ \ \ / ] InputLeadingAsterisks \ . javadoc " / > 
 
 < ! - - Javadoc files should not have new line by design ( on purpose ) . - - > 
 - < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] javadoc [ \ \ / ] htmlTags [ \ \ / ] . * " / > 
 - < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] javadoc [ \ \ / ] javadocTags [ \ \ / ] . * " / > 
 + < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] grammars [ \ \ / ] javadoc [ \ \ / ] . * \ . javadoc " / > 
 < suppress checks = " NewlineAtEndOfFile " files = " [ \ \ / ] test [ \ \ / ] . * [ \ \ / ] astprinter [ \ \ / ] . * \ . javadoc " / > 
 
 < ! - - Empty file cannot have any new line at the end . - - > 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 
 index 34d1e5f . . f015ae5 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 
 @ @ - 37 , 8 + 37 , 9 @ @ import java . util . * ; 
 
 } 
 
 - LEADING _ ASTERISK : ( ( ' ' | ' \ t ' ) { _ tokenStartCharPositionInLine = = 0 } ? ) ( ' ' | ' \ t ' ) * ' * ' 
 - | ' * ' { _ tokenStartCharPositionInLine = = 0 } ? 
 + LEADING _ ASTERISK : ( ( ' ' | ' \ t ' ) { _ tokenStartCharPositionInLine = = 0 
 + | | previousTokenType = = NEWLINE } ? ) ( ' ' | ' \ t ' ) * ' * ' 
 + | ' * ' { _ tokenStartCharPositionInLine = = 0 | | previousTokenType = = NEWLINE } ? 
 ; 
 
 HTML _ COMMENT _ START : ' < ! - - ' { recognizeXmlTags } ? 
 @ @ - 59 , 7 + 60 , 7 @ @ OPEN : ' < ' { recognizeXmlTags & & ( Character . isLetter ( _ input . LA ( 1 ) ) | | _ input . LA ( 1 ) 
 / / { insidePreTag = false ; recognizeXmlTags = true ; } 
 / / ; 
 
 - NEWLINE : ' \ n ' | ' \ r \ n ' ; 
 + NEWLINE : ' \ n ' | ' \ r \ n ' | ' \ r ' ; 
 
 AUTHOR _ LITERAL : ' @ author ' { isJavadocTagAvailable } ? ; 
 DEPRECATED _ LITERAL : ' @ deprecated ' { isJavadocTagAvailable } ? ; 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParseTreeTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParseTreeTest . java 
 index 47246e0 . . b194e04 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParseTreeTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParseTreeTest . java 
 @ @ - 244 , 4 + 244 , 10 @ @ public class JavadocParseTreeTest extends BaseCheckTestSupport { 
 verifyJavadocTree ( getDocPath ( " expectedTwoLinkTagsInRowAst . txt " ) , 
 getDocPath ( " InputTwoLinkTagsInRow . javadoc " ) ) ; 
 } 
 + 
 + @ Test 
 + public void testJavadocWithCrAsNewline ( ) throws Exception { 
 + verifyJavadocTree ( getPath ( " expectedJavadocWithCrAsNewlineAst . txt " ) , 
 + getPath ( " InputJavadocWithCrAsNewline . javadoc " ) ) ; 
 + } 
 } 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / InputJavadocWithCrAsNewline . javadoc b / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / InputJavadocWithCrAsNewline . javadoc 
 new file mode 100644 
 index 0000000 . . ec3cf7f 
 - - - / dev / null 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / InputJavadocWithCrAsNewline . javadoc 
 @ @ - 0 , 0 + 1 @ @ 
 + 
 * Checks that commentContent starts with ' * ' javadoc comment identifier . 
 * & lt ; property name = " ignorePattern " value = " ^ * \ * * [ ^ ] + $ " / & gt * 
 	 * This * is not a leading * 
 * @ return true if commentContent starts with ' * ' javadoc comment identifier 
 \ No newline at end of file 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / expectedJavadocWithCrAsNewlineAst . txt b / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / expectedJavadocWithCrAsNewlineAst . txt 
 new file mode 100644 
 index 0000000 . . 35fa622 
 - - - / dev / null 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / expectedJavadocWithCrAsNewlineAst . txt 
 @ @ - 0 , 0 + 1 , 21 @ @ 
 + JAVADOC - > JAVADOC [ 0 : 0 ] 
 + | - - TEXT - > [ 0 : 0 ] 
 + | - - NEWLINE - > \ r [ 0 : 4 ] 
 + | - - LEADING _ ASTERISK - > * [ 0 : 5 ] 
 + | - - TEXT - > Checks that commentContent starts with ' * ' javadoc comment identifier . [ 0 : 6 ] 
 + | - - NEWLINE - > \ r [ 0 : 77 ] 
 + | - - LEADING _ ASTERISK - > * [ 0 : 78 ] 
 + | - - TEXT - > & lt ; property name = " ignorePattern " value = " ^ * \ * * [ ^ ] + $ " / & gt * [ 0 : 83 ] 
 + | - - NEWLINE - > \ r [ 0 : 143 ] 
 + | - - LEADING _ ASTERISK - > \ t * [ 0 : 144 ] 
 + | - - TEXT - > This * is not a leading * [ 0 : 146 ] 
 + | - - NEWLINE - > \ r [ 0 : 172 ] 
 + | - - LEADING _ ASTERISK - > * [ 0 : 173 ] 
 + | - - WS - > [ 0 : 174 ] 
 + | - - JAVADOC _ TAG - > JAVADOC _ TAG [ 0 : 175 ] 
 + | | - - RETURN _ LITERAL - > @ return [ 0 : 175 ] 
 + | | - - WS - > [ 0 : 182 ] 
 + | ` - - DESCRIPTION - > DESCRIPTION [ 0 : 183 ] 
 + | | - - TEXT - > true if commentContent starts with ' * ' javadoc comment identifier [ 0 : 183 ] 
 + | ` - - NEWLINE - > \ r [ 0 : 248 ] 
 + ` - - EOF - > < EOF > [ 0 : 249 ]

NEAREST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheck . java 
 index 9f4ca37 . . 230f2bd 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheck . java 
 @ @ - 56 , 6 + 56 , 9 @ @ public class ExplicitInitializationCheck extends AbstractCheck { 
 * / 
 public static final String MSG _ KEY = " explicit . init " ; 
 
 + / * * Whether only explicit initialization made to null should be checked . * * / 
 + private boolean onlyObjectReferences ; 
 + 
 @ Override 
 public final int [ ] getDefaultTokens ( ) { 
 return new int [ ] { TokenTypes . VARIABLE _ DEF } ; 
 @ @ - 71 , 6 + 74 , 15 @ @ public class ExplicitInitializationCheck extends AbstractCheck { 
 return new int [ ] { TokenTypes . VARIABLE _ DEF } ; 
 } 
 
 + / * * 
 + * Sets whether only explicit initialization made to null should be checked . 
 + * @ param onlyObjectReferences whether only explicit initialization made to null 
 + * should be checked 
 + * / 
 + public void setOnlyObjectReferences ( boolean onlyObjectReferences ) { 
 + this . onlyObjectReferences = onlyObjectReferences ; 
 + } 
 + 
 @ Override 
 public void visitToken ( DetailAST ast ) { 
 if ( ! isSkipCase ( ast ) ) { 
 @ @ - 83 , 19 + 95 , 33 @ @ public class ExplicitInitializationCheck extends AbstractCheck { 
 & & exprStart . getType ( ) = = TokenTypes . LITERAL _ NULL ) { 
 log ( ident , MSG _ KEY , ident . getText ( ) , " null " ) ; 
 } 
 + if ( ! onlyObjectReferences ) { 
 + validateNonObjects ( ast ) ; 
 + } 
 + } 
 + } 
 
 - final int primitiveType = type . getFirstChild ( ) . getType ( ) ; 
 - if ( primitiveType = = TokenTypes . LITERAL _ BOOLEAN 
 + / * * 
 + * Checks for explicit initializations made to ' false ' , ' 0 ' and ' \ 0 ' . 
 + * @ param ast token being checked for explicit initializations 
 + * / 
 + private void validateNonObjects ( DetailAST ast ) { 
 + final DetailAST ident = ast . findFirstToken ( TokenTypes . IDENT ) ; 
 + final DetailAST assign = ast . findFirstToken ( TokenTypes . ASSIGN ) ; 
 + final DetailAST exprStart = 
 + assign . getFirstChild ( ) . getFirstChild ( ) ; 
 + final DetailAST type = ast . findFirstToken ( TokenTypes . TYPE ) ; 
 + final int primitiveType = type . getFirstChild ( ) . getType ( ) ; 
 + if ( primitiveType = = TokenTypes . LITERAL _ BOOLEAN 
 & & exprStart . getType ( ) = = TokenTypes . LITERAL _ FALSE ) { 
 - log ( ident , MSG _ KEY , ident . getText ( ) , " false " ) ; 
 - } 
 - if ( isNumericType ( primitiveType ) & & isZero ( exprStart ) ) { 
 - log ( ident , MSG _ KEY , ident . getText ( ) , " 0 " ) ; 
 - } 
 - if ( primitiveType = = TokenTypes . LITERAL _ CHAR 
 + log ( ident , MSG _ KEY , ident . getText ( ) , " false " ) ; 
 + } 
 + if ( isNumericType ( primitiveType ) & & isZero ( exprStart ) ) { 
 + log ( ident , MSG _ KEY , ident . getText ( ) , " 0 " ) ; 
 + } 
 + if ( primitiveType = = TokenTypes . LITERAL _ CHAR 
 & & isZeroChar ( exprStart ) ) { 
 - log ( ident , MSG _ KEY , ident . getText ( ) , " \ \ 0 " ) ; 
 - } 
 + log ( ident , MSG _ KEY , ident . getText ( ) , " \ \ 0 " ) ; 
 } 
 } 
 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheckTest . java 
 index b77a3ac . . a7e28a7 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / ExplicitInitializationCheckTest . java 
 @ @ - 74 , 4 + 74 , 24 @ @ public class ExplicitInitializationCheckTest extends BaseCheckTestSupport { 
 Assert . assertNotNull ( check . getDefaultTokens ( ) ) ; 
 Assert . assertNotNull ( check . getRequiredTokens ( ) ) ; 
 } 
 + 
 + @ Test 
 + public void testonlyObjectReferences ( ) throws Exception { 
 + final DefaultConfiguration checkConfig = 
 + createCheckConfig ( ExplicitInitializationCheck . class ) ; 
 + checkConfig . addAttribute ( " onlyObjectReferences " , " true " ) ; 
 + final String [ ] expected = { 
 + " 5 : 20 : " + getCheckMessage ( MSG _ KEY , " bar " , " null " ) , 
 + " 14 : 22 : " + getCheckMessage ( MSG _ KEY , " str1 " , " null " ) , 
 + " 14 : 35 : " + getCheckMessage ( MSG _ KEY , " str3 " , " null " ) , 
 + " 15 : 9 : " + getCheckMessage ( MSG _ KEY , " ar1 " , " null " ) , 
 + " 39 : 25 : " + getCheckMessage ( MSG _ KEY , " bar " , " null " ) , 
 + " 40 : 27 : " + getCheckMessage ( MSG _ KEY , " barArray " , " null " ) , 
 + " 48 : 29 : " + getCheckMessage ( MSG _ KEY , " bar " , " null " ) , 
 + " 49 : 31 : " + getCheckMessage ( MSG _ KEY , " barArray " , " null " ) , 
 + " 53 : 25 : " + getCheckMessage ( MSG _ KEY , " bar " , " null " ) , 
 + " 54 : 27 : " + getCheckMessage ( MSG _ KEY , " barArray " , " null " ) , 
 + } ; 
 + verify ( checkConfig , getPath ( " InputExplicitInitialization . java " ) , expected ) ; 
 + } 
 } 
 diff - - git a / src / xdocs / config _ coding . xml b / src / xdocs / config _ coding . xml 
 index 7b31e70 . . 96d0a58 100644 
 - - - a / src / xdocs / config _ coding . xml 
 + + + b / src / xdocs / config _ coding . xml 
 @ @ - 861 , 6 + 861 , 24 @ @ String nullString = null ; 
 < / p > 
 < / subsection > 
 
 + < subsection name = " Properties " > 
 + < table > 
 + < tr > 
 + < th > name < / th > 
 + < th > description < / th > 
 + < th > type < / th > 
 + < th > default value < / th > 
 + < / tr > 
 + < tr > 
 + < td > onlyObjectReferences < / td > 
 + < td > whether only explicit initializations made to 
 + null for objects should be checked < / td > 
 + < td > < a href = " property _ types . html # boolean " > Boolean < / a > < / td > 
 + < td > < code > false < / code > < / td > 
 + < / tr > 
 + < / table > 
 + < / subsection > 
 + 
 < subsection name = " Examples " > 
 < p > 
 To configure the check : 
 @ @ - 868 , 6 + 886 , 46 @ @ String nullString = null ; 
 < source > 
 & lt ; module name = & quot ; ExplicitInitialization & quot ; / & gt ; 
 < / source > 
 + 
 + < p > 
 + To configure the check so that it only checks 
 + for objects that explicitly initialize to null : 
 + < / p > 
 + < source > 
 + & lt ; module name = & quot ; ExplicitInitialization & quot ; & gt ; 
 + & lt ; property name = & quot ; onlyObjectReferences & quot ; value = & quot ; true & quot ; / & gt ; 
 + & lt ; / module & gt ; 
 + < / source > 
 + < p > Example : < / p > 
 + < p > 
 + < source > 
 + public class Test { 
 + private int a = 0 ; 
 + private int b = 1 ; 
 + private int c = 2 ; 
 + 
 + private boolean a = true ; 
 + private boolean b = false ; 
 + private boolean c = true ; 
 + private boolean d = false ; 
 + private boolean e = false ; 
 + 
 + private A a = new A ( ) ; 
 + private A b = null ; / / violation 
 + private C c = null ; / / violation 
 + private D d = new D ( ) ; 
 + 
 + int ar1 [ ] = null ; / / violation 
 + int ar2 [ ] = new int [ ] ; 
 + int ar3 [ ] ; 
 + private Bar & lt ; String & gt ; bar = null ; / / violation 
 + private Bar & lt ; String & gt ; [ ] barArray = null ; / / violation 
 + 
 + public static void main ( String [ ] args ) { 
 + } 
 + } 
 + < / source > 
 + < / p > 
 < / subsection > 
 
 < subsection name = " Example of Usage " >
