BLEU SCORE: 0.10552670315936319

TEST MSG: Issue # 1159 : Resolve PMD ExceptionAsFlowControl in PackageObjectFactory
GENERATED MSG: Issue # 2451 : removed excess hierarchy from RequireThisCheck

TEST DIFF (one line): diff - - git a / config / pmd . xml b / config / pmd . xml <nl> index 04cb8b8 . . 72ec709 100644 <nl> - - - a / config / pmd . xml <nl> + + + b / config / pmd . xml <nl> @ @ - 268 , 13 + 268 , 6 @ @ <nl> < ! - - not configurable , decreases readability - - > <nl> < exclude name = " UseStringBufferForStringAppends " / > <nl> < / rule > <nl> - < rule ref = " rulesets / java / strictexception . xml " / > <nl> - < rule ref = " rulesets / java / strictexception . xml / ExceptionAsFlowControl " > <nl> - < properties > <nl> - < ! - - till # 1159 - - > <nl> - < property name = " violationSuppressXPath " value = " / / ClassOrInterfaceDeclaration [ @ Image = ' PackageObjectFactory ' ] " / > <nl> - < / properties > <nl> - < / rule > <nl> < rule ref = " rulesets / java / strictexception . xml / AvoidCatchingGenericException " > <nl> < properties > <nl> < ! - - There is no other way to deliver filename that was under processing - - > <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java b / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java <nl> index bbd86c2 . . 8f2b42f 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java <nl> @ @ - 20 , 12 + 20 , 12 @ @ <nl> package com . puppycrawl . tools . checkstyle ; <nl> <nl> import java . lang . reflect . Constructor ; <nl> + import java . util . Iterator ; <nl> import java . util . Set ; <nl> <nl> import org . apache . commons . logging . Log ; <nl> import org . apache . commons . logging . LogFactory ; <nl> <nl> - import com . google . common . annotations . VisibleForTesting ; <nl> import com . google . common . base . Joiner ; <nl> import com . google . common . collect . Sets ; <nl> import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; <nl> @ @ - 47 , 9 + 47 , 11 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> private static final String UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE = <nl> " PackageObjectFactory . unableToInstantiateExceptionMessage " ; <nl> <nl> + / * * Separator to use in strings . * / <nl> + private static final String STRING _ SEPARATOR = " , " ; <nl> + <nl> / * * A list of package names to prepend to class names . * / <nl> private final Set < String > packages ; <nl> - <nl> / * * The class loader used to load Checkstyle core and custom modules . * / <nl> private final ClassLoader moduleClassLoader ; <nl> <nl> @ @ - 59 , 8 + 61 , 7 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> * @ param moduleClassLoader class loader used to load Checkstyle <nl> * core and custom modules <nl> * / <nl> - public PackageObjectFactory ( Set < String > packageNames , <nl> - ClassLoader moduleClassLoader ) { <nl> + public PackageObjectFactory ( Set < String > packageNames , ClassLoader moduleClassLoader ) { <nl> if ( moduleClassLoader = = null ) { <nl> throw new IllegalArgumentException ( <nl> " moduleClassLoader must not be null " ) ; <nl> @ @ - 72 , 99 + 73 , 65 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> } <nl> <nl> / * * <nl> - * Registers a package name to use for shortName resolution . <nl> - * @ param packageName the package name <nl> - * / <nl> - @ VisibleForTesting <nl> - void addPackage ( String packageName ) { <nl> - packages . add ( packageName ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a new instance of a class from a given name . If the name is <nl> + * Creates a new instance of a class from a given name , or that name <nl> + * concatenated with & quot ; Check & quot ; . If the name is <nl> * a class name , creates an instance of the named class . Otherwise , creates <nl> - * an instance of a class name obtained by concatenating the given <nl> + * an instance of a class name obtained by concatenating the given name <nl> * to a package name from a given list of package names . <nl> * @ param name the name of a class . <nl> - * @ return the { @ code Object } <nl> + * @ return the { @ code Object } created by loader . <nl> * @ throws CheckstyleException if an error occurs . <nl> * / <nl> - private Object doMakeObject ( String name ) <nl> - throws CheckstyleException { <nl> - / / try name first <nl> - try { <nl> - return createObject ( name ) ; <nl> - } <nl> - catch ( final CheckstyleException ex ) { <nl> - LOG . debug ( IGNORING _ EXCEPTION _ MESSAGE , ex ) ; <nl> - } <nl> - <nl> - / / now try packages <nl> - for ( String packageName : packages ) { <nl> - <nl> - final String className = packageName + name ; <nl> - try { <nl> - return createObject ( className ) ; <nl> - } <nl> - catch ( final CheckstyleException ex ) { <nl> - LOG . debug ( IGNORING _ EXCEPTION _ MESSAGE , ex ) ; <nl> + @ Override <nl> + public Object createModule ( String name ) throws CheckstyleException { <nl> + Object instance = createObjectWithIgnoringProblems ( name , getAllPossibleNames ( name ) ) ; <nl> + if ( instance = = null ) { <nl> + final String nameCheck = name + " Check " ; <nl> + instance = createObjectWithIgnoringProblems ( nameCheck , getAllPossibleNames ( nameCheck ) ) ; <nl> + if ( instance = = null ) { <nl> + <nl> + final String attemptedNames = joinPackageNamesWithClassName ( name ) <nl> + + STRING _ SEPARATOR + nameCheck + STRING _ SEPARATOR <nl> + + joinPackageNamesWithClassName ( nameCheck ) ; <nl> + final LocalizedMessage exceptionMessage = new LocalizedMessage ( 0 , <nl> + Definitions . CHECKSTYLE _ BUNDLE , UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE , <nl> + new String [ ] { name , attemptedNames } , null , getClass ( ) , null ) ; <nl> + throw new CheckstyleException ( exceptionMessage . getMessage ( ) ) ; <nl> } <nl> } <nl> - final LocalizedMessage exceptionMessage = new LocalizedMessage ( 0 , <nl> - Definitions . CHECKSTYLE _ BUNDLE , UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE , <nl> - new String [ ] { name , joinPackageNamesWithClassName ( name ) } , <nl> - null , getClass ( ) , null ) ; <nl> - throw new CheckstyleException ( exceptionMessage . getMessage ( ) ) ; <nl> + return instance ; <nl> } <nl> <nl> / * * <nl> - * Creates a new instance of a named class . <nl> + * Create a new instance of a named class . <nl> * @ param className the name of the class to instantiate . <nl> - * @ return the { @ code Object } created by loader . <nl> - * @ throws CheckstyleException if an error occurs . <nl> + * @ param secondAttempt the set of names to attempt instantiation <nl> + * if usage of the className was not successful . <nl> + * @ return the { @ code Object } created by loader or null . <nl> * / <nl> - private Object createObject ( String className ) <nl> - throws CheckstyleException { <nl> - try { <nl> - final Class < ? > clazz = Class . forName ( className , true , moduleClassLoader ) ; <nl> - final Constructor < ? > declaredConstructor = clazz . getDeclaredConstructor ( ) ; <nl> - declaredConstructor . setAccessible ( true ) ; <nl> - return declaredConstructor . newInstance ( ) ; <nl> - } <nl> - catch ( final ReflectiveOperationException | NoClassDefFoundError exception ) { <nl> - throw new CheckstyleException ( " Unable to find class for " + className , exception ) ; <nl> + private Object createObjectWithIgnoringProblems ( String className , <nl> + Set < String > secondAttempt ) { <nl> + Object instance = createObject ( className ) ; <nl> + if ( instance = = null ) { <nl> + final Iterator < String > ite = secondAttempt . iterator ( ) ; <nl> + while ( instance = = null & & ite . hasNext ( ) ) { <nl> + instance = createObject ( ite . next ( ) ) ; <nl> + } <nl> } <nl> + return instance ; <nl> } <nl> <nl> / * * <nl> - * Creates a new instance of a class from a given name , or that name <nl> - * concatenated with & quot ; Check & quot ; . If the name is <nl> - * a class name , creates an instance of the named class . Otherwise , creates <nl> - * an instance of a class name obtained by concatenating the given name <nl> - * to a package name from a given list of package names . <nl> - * @ param name the name of a class . <nl> - * @ return the { @ code Object } created by loader . <nl> - * @ throws CheckstyleException if an error occurs . <nl> + * Generate the set of all possible names for a class name . <nl> + * @ param name the name of the class get possible names for . <nl> + * @ return all possible name for a class . <nl> * / <nl> - @ Override <nl> - public Object createModule ( String name ) <nl> - throws CheckstyleException { <nl> - try { <nl> - return doMakeObject ( name ) ; <nl> - } <nl> - catch ( final CheckstyleException ignored ) { <nl> - / / try again with suffix " Check " <nl> - try { <nl> - return doMakeObject ( name + " Check " ) ; <nl> - } <nl> - catch ( final CheckstyleException ex ) { <nl> - final LocalizedMessage exceptionMessage = new LocalizedMessage ( 0 , <nl> - Definitions . CHECKSTYLE _ BUNDLE , UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE , <nl> - new String [ ] { name , joinPackageNamesWithClassName ( name ) } , <nl> - null , getClass ( ) , null ) ; <nl> - throw new CheckstyleException ( exceptionMessage . getMessage ( ) , ex ) ; <nl> - } <nl> + private Set < String > getAllPossibleNames ( String name ) { <nl> + final Set < String > names = Sets . newHashSet ( ) ; <nl> + for ( String packageName : packages ) { <nl> + names . add ( packageName + name ) ; <nl> } <nl> + return names ; <nl> } <nl> <nl> / * * <nl> @ @ - 173 , 7 + 140 , 26 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> * @ return a string which is obtained by joining package names with a class name . <nl> * / <nl> private String joinPackageNamesWithClassName ( String className ) { <nl> - final Joiner joiner = Joiner . on ( className + " , " ) . skipNulls ( ) ; <nl> + final Joiner joiner = Joiner . on ( className + STRING _ SEPARATOR ) . skipNulls ( ) ; <nl> return joiner . join ( packages ) + className ; <nl> } <nl> + <nl> + / * * <nl> + * Creates a new instance of a named class . <nl> + * @ param className the name of the class to instantiate . <nl> + * @ return the { @ code Object } created by loader or null . <nl> + * / <nl> + private Object createObject ( String className ) { <nl> + Object instance = null ; <nl> + try { <nl> + final Class < ? > clazz = Class . forName ( className , true , moduleClassLoader ) ; <nl> + final Constructor < ? > declaredConstructor = clazz . getDeclaredConstructor ( ) ; <nl> + declaredConstructor . setAccessible ( true ) ; <nl> + instance = declaredConstructor . newInstance ( ) ; <nl> + } <nl> + catch ( final ReflectiveOperationException | NoClassDefFoundError exception ) { <nl> + LOG . debug ( IGNORING _ EXCEPTION _ MESSAGE , exception ) ; <nl> + } <nl> + return instance ; <nl> + } <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java <nl> index 7e66ad4 . . 95a13f4 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java <nl> @ @ - 59 , 14 + 59 , 4 @ @ public class PackageObjectFactoryTest { <nl> " com . puppycrawl . tools . checkstyle . checks . naming . ConstantName " ) ; <nl> assertNotNull ( check ) ; <nl> } <nl> - <nl> - @ Test <nl> - public void testMakeObjectFromList ( ) <nl> - throws CheckstyleException { <nl> - factory . addPackage ( " com . " ) ; <nl> - final Checker checker = <nl> - ( Checker ) factory . createModule ( <nl> - " puppycrawl . tools . checkstyle . Checker " ) ; <nl> - assertNotNull ( checker ) ; <nl> - } <nl> }
NEAREST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java <nl> index 6d1857b . . 594f250 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java <nl> @ @ - 19 , 6 + 19 , 9 @ @ <nl> <nl> package com . puppycrawl . tools . checkstyle . checks . indentation ; <nl> <nl> + import java . util . Locale ; <nl> + import java . util . Stack ; <nl> + <nl> import org . apache . commons . lang3 . ArrayUtils ; <nl> <nl> import com . puppycrawl . tools . checkstyle . api . Check ; <nl> @ @ - 62 , 22 + 65 , 18 @ @ import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; <nl> * } <nl> * < / pre > <nl> * <nl> - * <nl> * @ author < a href = " mailto : nesterenko - aleksey @ list . ru " > Aleksey Nesterenko < / a > <nl> * @ author < a href = " mailto : andreyselkin @ gmail . com " > Andrei Selkin < / a > <nl> - * <nl> * / <nl> public class CommentsIndentationCheck extends Check { <nl> <nl> / * * <nl> - * A key is pointing to the warning message text in " messages . properties " <nl> - * file . <nl> + * A key is pointing to the warning message text in " messages . properties " file . <nl> * / <nl> public static final String MSG _ KEY _ SINGLE = " comments . indentation . single " ; <nl> <nl> / * * <nl> - * A key is pointing to the warning message text in " messages . properties " <nl> - * file . <nl> + * A key is pointing to the warning message text in " messages . properties " file . <nl> * / <nl> public static final String MSG _ KEY _ BLOCK = " comments . indentation . block " ; <nl> <nl> @ @ - 135 , 17 + 134 , 493 @ @ public class CommentsIndentationCheck extends Check { <nl> * @ param singleLineComment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . <nl> * / <nl> private void visitSingleLineComment ( DetailAST singleLineComment ) { <nl> - final DetailAST nextStatement = singleLineComment . getNextSibling ( ) ; <nl> - final DetailAST prevStatement = getPrevStatementFromSwitchBlock ( singleLineComment ) ; <nl> + final DetailAST prevStmt = getPreviousStatementOfSingleLineComment ( singleLineComment ) ; <nl> + final DetailAST nextStmt = singleLineComment . getNextSibling ( ) ; <nl> <nl> - if ( nextStatement ! = null <nl> - & & nextStatement . getType ( ) ! = TokenTypes . RCURLY <nl> - & & ! isTrailingSingleLineComment ( singleLineComment ) <nl> - & & ! areSameLevelIndented ( singleLineComment , prevStatement , nextStatement ) ) { <nl> + if ( ! isTrailingSingleLineComment ( singleLineComment ) ) { <nl> + if ( isInEmptyCaseBlock ( prevStmt , nextStmt ) ) { <nl> + handleSingleLineCommentInEmptyCaseBlock ( prevStmt , singleLineComment , <nl> + nextStmt ) ; <nl> + } <nl> + else if ( isFallThroughSingleLineComment ( prevStmt , nextStmt ) ) { <nl> + handleFallThroughtSingleLineComment ( prevStmt , singleLineComment , <nl> + nextStmt ) ; <nl> + } <nl> + else if ( isInEmptyCodeBlock ( prevStmt , nextStmt ) ) { <nl> + handleSingleLineCommentInEmptyCodeBlock ( singleLineComment , nextStmt ) ; <nl> + } <nl> + else if ( isSingleLineCommentAtTheEndOfTheCodeBlock ( nextStmt ) ) { <nl> + handleSIngleLineCommentAtTheEndOfTheCodeBlock ( prevStmt , singleLineComment , <nl> + nextStmt ) ; <nl> + } <nl> + else if ( nextStmt ! = null <nl> + & & ! areSameLevelIndented ( singleLineComment , nextStmt , nextStmt ) ) { <nl> + log ( singleLineComment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , <nl> + singleLineComment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Returns the previous statement of a single line comment . <nl> + * @ param comment single line comment . <nl> + * @ return the previous statement of a single line comment . <nl> + * / <nl> + private DetailAST getPreviousStatementOfSingleLineComment ( DetailAST comment ) { <nl> + final DetailAST prevStatement ; <nl> + if ( isDistributedPreviousStatement ( comment ) ) { <nl> + prevStatement = getDistributedPreviousStatementOfSingleLineComment ( comment ) ; <nl> + } <nl> + else { <nl> + prevStatement = getOneLinePreviousStatementOfSingleLineComment ( comment ) ; <nl> + } <nl> + return prevStatement ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the previous statement of a single line comment is distributed over two or <nl> + * more lines . <nl> + * @ param singleLineComment single line comment . <nl> + * @ return true if the previous statement of a single line comment is distributed over two or <nl> + * more lines . <nl> + * / <nl> + private boolean isDistributedPreviousStatement ( DetailAST singleLineComment ) { <nl> + final DetailAST previousSibling = singleLineComment . getPreviousSibling ( ) ; <nl> + return isDistributedMethodChainOrConcatenationStatement ( singleLineComment , previousSibling ) <nl> + | | isDistributedReturnStatement ( previousSibling ) <nl> + | | isDistributedThrowStatement ( previousSibling ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the previous statement of a single line comment is a method call chain or <nl> + * string concatenation statemen distributed over two ore more lines . <nl> + * @ param comment single line comment . <nl> + * @ param commentPreviousSibling previous sibling of the sinle line comment . <nl> + * @ return if the previous statement of a single line comment is a method call chain or <nl> + * string concatenation statemen distributed over two ore more lines . <nl> + * / <nl> + private static boolean isDistributedMethodChainOrConcatenationStatement ( <nl> + DetailAST comment , DetailAST commentPreviousSibling ) { <nl> + boolean destributed = false ; <nl> + if ( commentPreviousSibling ! = null <nl> + & & commentPreviousSibling . getType ( ) = = TokenTypes . SEMI <nl> + & & comment . getLineNo ( ) - commentPreviousSibling . getLineNo ( ) = = 1 ) { <nl> + DetailAST currentToken = commentPreviousSibling . getPreviousSibling ( ) ; <nl> + while ( currentToken . getFirstChild ( ) ! = null ) { <nl> + currentToken = currentToken . getFirstChild ( ) ; <nl> + } <nl> + if ( currentToken . getType ( ) ! = TokenTypes . COMMENT _ CONTENT <nl> + & & commentPreviousSibling . getLineNo ( ) ! = currentToken . getLineNo ( ) ) { <nl> + destributed = true ; <nl> + } <nl> + } <nl> + return destributed ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the previous statement of a single line comment is a destributed return <nl> + * statement . <nl> + * @ param commentPreviousSibling previous sibling of the single line comment . <nl> + * @ return true if the previous statement of a single line comment is a destributed return <nl> + * statement . <nl> + * / <nl> + private static boolean isDistributedReturnStatement ( DetailAST commentPreviousSibling ) { <nl> + boolean destributed = false ; <nl> + if ( commentPreviousSibling ! = null <nl> + & & commentPreviousSibling . getType ( ) = = TokenTypes . LITERAL _ RETURN ) { <nl> + final DetailAST firstChild = commentPreviousSibling . getFirstChild ( ) ; <nl> + final DetailAST nextSibling = firstChild . getNextSibling ( ) ; <nl> + if ( nextSibling ! = null ) { <nl> + destributed = true ; <nl> + } <nl> + } <nl> + return destributed ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the previous statement of a single line comment is a destributed throw <nl> + * statement . <nl> + * @ param commentPreviousSibling previous sibling of the single line comment . <nl> + * @ return true if the previous statement of a single line comment is a destributed throw <nl> + * statement . <nl> + * / <nl> + private static boolean isDistributedThrowStatement ( DetailAST commentPreviousSibling ) { <nl> + boolean destributed = false ; <nl> + if ( commentPreviousSibling ! = null <nl> + & & commentPreviousSibling . getType ( ) = = TokenTypes . LITERAL _ THROW ) { <nl> + final DetailAST firstChild = commentPreviousSibling . getFirstChild ( ) ; <nl> + final DetailAST nextSibling = firstChild . getNextSibling ( ) ; <nl> + if ( nextSibling . getLineNo ( ) ! = commentPreviousSibling . getLineNo ( ) ) { <nl> + destributed = true ; <nl> + } <nl> + } <nl> + return destributed ; <nl> + } <nl> <nl> - log ( singleLineComment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStatement . getLineNo ( ) , <nl> - singleLineComment . getColumnNo ( ) , nextStatement . getColumnNo ( ) ) ; <nl> + / * * <nl> + * Returns the first token of the destributed previous statement of single line comment . <nl> + * @ param comment single line comment . <nl> + * @ return the first token of the destributed previous statement of single line comment . <nl> + * / <nl> + public static DetailAST getDistributedPreviousStatementOfSingleLineComment ( DetailAST comment ) { <nl> + DetailAST previousStatement = comment . getPreviousSibling ( ) ; <nl> + if ( previousStatement . getType ( ) = = TokenTypes . LITERAL _ RETURN <nl> + | | previousStatement . getType ( ) = = TokenTypes . LITERAL _ THROW ) { <nl> + return previousStatement ; <nl> + } <nl> + previousStatement = previousStatement . getPreviousSibling ( ) ; <nl> + while ( previousStatement . getFirstChild ( ) ! = null ) { <nl> + previousStatement = previousStatement . getFirstChild ( ) ; <nl> } <nl> + return previousStatement ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether case block is empty . <nl> + * @ param nextStmt previous statement . <nl> + * @ param prevStmt next statement . <nl> + * @ return true if case block is empty . <nl> + * / <nl> + private static boolean isInEmptyCaseBlock ( DetailAST prevStmt , DetailAST nextStmt ) { <nl> + return prevStmt ! = null <nl> + & & nextStmt ! = null <nl> + & & ( prevStmt . getType ( ) = = TokenTypes . LITERAL _ CASE <nl> + | | prevStmt . getType ( ) = = TokenTypes . CASE _ GROUP ) <nl> + & & ( nextStmt . getType ( ) = = TokenTypes . LITERAL _ CASE <nl> + | | nextStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether single line comment is a ' fall through ' comment . <nl> + * For example : <nl> + * < p > <nl> + * { @ code <nl> + * . . . <nl> + * case OPTION _ ONE : <nl> + * int someVariable = 1 ; <nl> + * / / fall through <nl> + * case OPTION _ TWO : <nl> + * int a = 5 ; <nl> + * break ; <nl> + * . . . <nl> + * } <nl> + * < / p > <nl> + * @ param prevStmt previous statement . <nl> + * @ param nextStmt next statement . <nl> + * @ return true if a single line comment is a ' fall through ' comment . <nl> + * / <nl> + private static boolean isFallThroughSingleLineComment ( DetailAST prevStmt , DetailAST nextStmt ) { <nl> + return prevStmt ! = null <nl> + & & prevStmt . getType ( ) ! = TokenTypes . LITERAL _ CASE <nl> + & & nextStmt ! = null <nl> + & & ( nextStmt . getType ( ) = = TokenTypes . LITERAL _ CASE <nl> + | | nextStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether a single line comment is placed at the end of the code block . <nl> + * @ param nextStmt next statement . <nl> + * @ return true if a single line comment is placed at the end of the block . <nl> + * / <nl> + private boolean isSingleLineCommentAtTheEndOfTheCodeBlock ( DetailAST nextStmt ) { <nl> + return nextStmt ! = null <nl> + & & nextStmt . getType ( ) = = TokenTypes . RCURLY ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether comment is placed in the empty code block . <nl> + * For example : <nl> + * < p > <nl> + * . . . <nl> + * { @ code <nl> + * / / empty code block <nl> + * } <nl> + * . . . <nl> + * < / p > <nl> + * Note , the method does not treat empty case blocks . <nl> + * @ param prevStmt previous statement . <nl> + * @ param nextStmt next statement . <nl> + * @ return true if comment is placed in the empty code block . <nl> + * / <nl> + private boolean isInEmptyCodeBlock ( DetailAST prevStmt , DetailAST nextStmt ) { <nl> + return prevStmt ! = null <nl> + & & nextStmt ! = null <nl> + & & ( prevStmt . getType ( ) = = TokenTypes . SLIST <nl> + | | prevStmt . getType ( ) = = TokenTypes . OBJBLOCK ) <nl> + & & nextStmt . getType ( ) = = TokenTypes . RCURLY ; <nl> + } <nl> + <nl> + / * * <nl> + * Handles a single line comment which is plased within empty case block . <nl> + * Note , if comment is placed at the end of the empty case block , we have Checkstyle ' s <nl> + * limitations to clearly detect user intention of explanation target - above or below . The <nl> + * only case we can assume as a violation is when a single line comment within the empty case <nl> + * block has indentation level that is lower than the indentation level of the next case <nl> + * token . For example : <nl> + * < p > <nl> + * { @ code <nl> + * . . . <nl> + * case OPTION _ ONE : <nl> + * / / violation <nl> + * case OPTION _ TWO : <nl> + * . . . <nl> + * } <nl> + * < / p > <nl> + * @ param prevStmt previous statement . <nl> + * @ param comment single line comment . <nl> + * @ param nextStmt next statement . <nl> + * / <nl> + private void handleSingleLineCommentInEmptyCaseBlock ( DetailAST prevStmt , DetailAST comment , <nl> + DetailAST nextStmt ) { <nl> + <nl> + if ( comment . getColumnNo ( ) < prevStmt . getColumnNo ( ) <nl> + | | comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { <nl> + logMultilineIndentation ( prevStmt , comment , nextStmt ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Handles ' fall through ' single line comment . <nl> + * Note , ' fall through ' and similar comments can have indentation level as next or previous <nl> + * statement . <nl> + * For example : <nl> + * < p > <nl> + * { @ code <nl> + * . . . <nl> + * case OPTION _ ONE : <nl> + * int someVariable = 1 ; <nl> + * / / fall through - OK <nl> + * case OPTION _ TWO : <nl> + * int a = 5 ; <nl> + * break ; <nl> + * . . . <nl> + * } <nl> + * < / p > <nl> + * < p > <nl> + * { @ code <nl> + * . . . <nl> + * case OPTION _ ONE : <nl> + * int someVariable = 1 ; <nl> + * / / than init variable a - OK <nl> + * case OPTION _ TWO : <nl> + * int a = 5 ; <nl> + * break ; <nl> + * . . . <nl> + * } <nl> + * < / p > <nl> + * @ param prevStmt previous statement . <nl> + * @ param comment single line comment . <nl> + * @ param nextStmt next statement . <nl> + * / <nl> + private void handleFallThroughtSingleLineComment ( DetailAST prevStmt , DetailAST comment , <nl> + DetailAST nextStmt ) { <nl> + <nl> + if ( ! areSameLevelIndented ( comment , prevStmt , nextStmt ) ) { <nl> + logMultilineIndentation ( prevStmt , comment , nextStmt ) ; <nl> + } <nl> + <nl> + } <nl> + <nl> + / * * <nl> + * Hendles a single line comment which is placed at the end of non empty code block . <nl> + * Note , if single line comment is plcaed at the end of non empty block the comment should have <nl> + * the same indentation level as the previous statement . For example : <nl> + * < p > <nl> + * { @ code <nl> + * if ( a = = true ) { <nl> + * int b = 1 ; <nl> + * / / comment <nl> + * } <nl> + * } <nl> + * < / p > <nl> + * @ param prevStmt previous statement . <nl> + * @ param comment single line statement . <nl> + * @ param nextStmt next statement . <nl> + * / <nl> + private void handleSIngleLineCommentAtTheEndOfTheCodeBlock ( DetailAST prevStmt , <nl> + DetailAST comment , <nl> + DetailAST nextStmt ) { <nl> + if ( prevStmt ! = null ) { <nl> + if ( prevStmt . getType ( ) = = TokenTypes . LITERAL _ CASE <nl> + | | prevStmt . getType ( ) = = TokenTypes . CASE _ GROUP <nl> + | | prevStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT <nl> + | | prevStmt . getType ( ) = = TokenTypes . SINGLE _ LINE _ COMMENT ) { <nl> + if ( comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { <nl> + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , <nl> + comment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; <nl> + } <nl> + } <nl> + else if ( ! areSameLevelIndented ( comment , prevStmt , prevStmt ) ) { <nl> + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , prevStmt . getLineNo ( ) , <nl> + comment . getColumnNo ( ) , prevStmt . getColumnNo ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + } <nl> + <nl> + / * * <nl> + * Handles a single line comment which is placed within the empty code block . <nl> + * Note , if comment is placed at the end of the empty code block , we have Checkstyle ' s <nl> + * limitations to clearly detect user intention of explanation target - above or below . The <nl> + * only case we can assume as a violation is when a single line comment within the empty <nl> + * code block has indentation level that is lower than the indentation level of the closing <nl> + * right curly brace . For example : <nl> + * < p > <nl> + * { @ code <nl> + * if ( a = = true ) { <nl> + * / / violation <nl> + * } <nl> + * } <nl> + * < / p > <nl> + * <nl> + * @ param comment single line comment . <nl> + * @ param nextStmt next statement . <nl> + * / <nl> + private void handleSingleLineCommentInEmptyCodeBlock ( DetailAST comment , DetailAST nextStmt ) { <nl> + if ( comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { <nl> + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , <nl> + comment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Does pre - order traverse of abstract syntax tree to find the previous statement of the <nl> + * single line comment . If previous statement of the comment is found , then the traverse will <nl> + * be finished . <nl> + * @ param comment current statement . <nl> + * @ return previous statement of the comment or null if the comment does not have previous <nl> + * statement . <nl> + * / <nl> + private static DetailAST getOneLinePreviousStatementOfSingleLineComment ( DetailAST comment ) { <nl> + final Stack < DetailAST > stack = new Stack < > ( ) ; <nl> + DetailAST root = comment . getParent ( ) ; <nl> + <nl> + while ( root ! = null | | ! stack . empty ( ) ) { <nl> + if ( ! stack . empty ( ) ) { <nl> + root = stack . pop ( ) ; <nl> + } <nl> + while ( root ! = null ) { <nl> + final DetailAST previousStatement = <nl> + findPreviousStatementOfSingleLineComment ( comment , root ) ; <nl> + if ( previousStatement ! = null ) { <nl> + return previousStatement ; <nl> + } <nl> + if ( root . getNextSibling ( ) ! = null ) { <nl> + stack . push ( root . getNextSibling ( ) ) ; <nl> + } <nl> + root = root . getFirstChild ( ) ; <nl> + } <nl> + } <nl> + return null ; <nl> + } <nl> + <nl> + / * * <nl> + * Finds a previous statement of the single line comment . <nl> + * Uses root token of the line while searching . <nl> + * @ param comment single line comment . <nl> + * @ param root root token of the line . <nl> + * @ return previous statement of the single line comment or null if previous statement was not <nl> + * found . <nl> + * / <nl> + private static DetailAST findPreviousStatementOfSingleLineComment ( DetailAST comment , <nl> + DetailAST root ) { <nl> + DetailAST previousStatement = null ; <nl> + if ( root . getLineNo ( ) > = comment . getLineNo ( ) ) { <nl> + / / ATTENTION : parent of the comment is below the comment in case block <nl> + / / See https : / / github . com / checkstyle / checkstyle / issues / 851 <nl> + previousStatement = getPrevStatementFromSwitchBlock ( comment ) ; <nl> + } <nl> + final DetailAST tokenWhichBeginsTheLine ; <nl> + if ( root . getType ( ) = = TokenTypes . EXPR <nl> + & & root . getFirstChild ( ) . getFirstChild ( ) ! = null ) { <nl> + if ( root . getFirstChild ( ) . getType ( ) = = TokenTypes . LITERAL _ NEW ) { <nl> + tokenWhichBeginsTheLine = root . getFirstChild ( ) ; <nl> + } <nl> + else { <nl> + tokenWhichBeginsTheLine = findTokenWhichBeginsTheLine ( root ) ; <nl> + } <nl> + } <nl> + else if ( root . getType ( ) = = TokenTypes . PLUS ) { <nl> + tokenWhichBeginsTheLine = root . getFirstChild ( ) ; <nl> + } <nl> + else { <nl> + tokenWhichBeginsTheLine = root ; <nl> + } <nl> + if ( tokenWhichBeginsTheLine ! = null <nl> + & & isOnPreviousLine ( comment , tokenWhichBeginsTheLine ) ) { <nl> + previousStatement = tokenWhichBeginsTheLine ; <nl> + } <nl> + return previousStatement ; <nl> + } <nl> + <nl> + / * * <nl> + * Finds a token which begins the line . <nl> + * @ param root root token of the line . <nl> + * @ return token which begins the line . <nl> + * / <nl> + private static DetailAST findTokenWhichBeginsTheLine ( DetailAST root ) { <nl> + DetailAST tokenWhichBeginsTheLine ; <nl> + if ( isUsingOfObjectReferenceToInvokeMethod ( root ) ) { <nl> + tokenWhichBeginsTheLine = findStartTokenOfMethodCallChain ( root ) ; <nl> + } <nl> + else { <nl> + tokenWhichBeginsTheLine = root . getFirstChild ( ) . findFirstToken ( TokenTypes . IDENT ) ; <nl> + } <nl> + return tokenWhichBeginsTheLine ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether there is a use of an object reference to invoke an object ' s method on line . <nl> + * @ param root root token of the line . <nl> + * @ return true if there is a use of an object reference to invoke an object ' s method on line . <nl> + * / <nl> + private static boolean isUsingOfObjectReferenceToInvokeMethod ( DetailAST root ) { <nl> + return root . getFirstChild ( ) . getFirstChild ( ) . getFirstChild ( ) ! = null <nl> + & & root . getFirstChild ( ) . getFirstChild ( ) . getFirstChild ( ) . getNextSibling ( ) ! = null ; <nl> + } <nl> + <nl> + / * * <nl> + * Finds the start token of method call chain . <nl> + * @ param root root token of the line . <nl> + * @ return the start token of method call chain . <nl> + * / <nl> + private static DetailAST findStartTokenOfMethodCallChain ( DetailAST root ) { <nl> + DetailAST startOfMethodCallChain = root ; <nl> + while ( startOfMethodCallChain . getFirstChild ( ) ! = null <nl> + & & startOfMethodCallChain . getFirstChild ( ) . getLineNo ( ) = = root . getLineNo ( ) ) { <nl> + startOfMethodCallChain = startOfMethodCallChain . getFirstChild ( ) ; <nl> + } <nl> + if ( startOfMethodCallChain . getFirstChild ( ) ! = null ) { <nl> + startOfMethodCallChain = startOfMethodCallChain . getFirstChild ( ) . getNextSibling ( ) ; <nl> + } <nl> + return startOfMethodCallChain ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the checked statement is on previous line . <nl> + * @ param currentStatement current statement . <nl> + * @ param checkedStatement checked statement . <nl> + * @ return true if checked statement is on the line which is previous to current statement . <nl> + * / <nl> + private static boolean isOnPreviousLine ( DetailAST currentStatement , <nl> + DetailAST checkedStatement ) { <nl> + return currentStatement . getLineNo ( ) - checkedStatement . getLineNo ( ) = = 1 ; <nl> + } <nl> + <nl> + / * * <nl> + * Logs comment which can have the same indentation level as next or previous statement . <nl> + * @ param comment comment . <nl> + * @ param nextStmt previous statement . <nl> + * @ param prevStmt next statement . <nl> + * / <nl> + private void logMultilineIndentation ( DetailAST prevStmt , DetailAST comment , <nl> + DetailAST nextStmt ) { <nl> + final String multilineNoTemplate = " % d , % d " ; <nl> + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , <nl> + String . format ( Locale . getDefault ( ) , multilineNoTemplate , prevStmt . getLineNo ( ) , <nl> + nextStmt . getLineNo ( ) ) , comment . getColumnNo ( ) , <nl> + String . format ( Locale . getDefault ( ) , multilineNoTemplate , prevStmt . getColumnNo ( ) , <nl> + nextStmt . getColumnNo ( ) ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 181 , 10 + 656 , 20 @ @ public class CommentsIndentationCheck extends Check { <nl> blockBody = blockBody . getPreviousSibling ( ) ; <nl> } <nl> if ( blockBody . getType ( ) = = TokenTypes . EXPR ) { <nl> - prevStmt = blockBody . getFirstChild ( ) . getFirstChild ( ) ; <nl> + if ( isUsingOfObjectReferenceToInvokeMethod ( blockBody ) ) { <nl> + prevStmt = findStartTokenOfMethodCallChain ( blockBody ) ; <nl> + } <nl> + else { <nl> + prevStmt = blockBody . getFirstChild ( ) . getFirstChild ( ) ; <nl> + } <nl> } <nl> else { <nl> - prevStmt = blockBody ; <nl> + if ( blockBody . getType ( ) = = TokenTypes . SLIST ) { <nl> + prevStmt = blockBody . getParent ( ) . getParent ( ) ; <nl> + } <nl> + else { <nl> + prevStmt = blockBody ; <nl> + } <nl> } <nl> } <nl> return prevStmt ; <nl> @ @ - 199 , 10 + 684 , 9 @ @ public class CommentsIndentationCheck extends Check { <nl> final DetailAST prevCaseToken ; <nl> final DetailAST parentBlock = parentStatement . getParent ( ) ; <nl> if ( parentBlock ! = null & & parentBlock . getParent ( ) ! = null <nl> - & & parentBlock . getParent ( ) . getPreviousSibling ( ) ! = null <nl> - & & parentBlock . getParent ( ) . getPreviousSibling ( ) <nl> - . getType ( ) = = TokenTypes . LITERAL _ CASE ) { <nl> - <nl> + & & parentBlock . getParent ( ) . getPreviousSibling ( ) ! = null <nl> + & & parentBlock . getParent ( ) . getPreviousSibling ( ) . getType ( ) <nl> + = = TokenTypes . LITERAL _ CASE ) { <nl> prevCaseToken = parentBlock . getParent ( ) . getPreviousSibling ( ) ; <nl> } <nl> else { <nl> @ @ - 229 , 20 + 713 , 20 @ @ public class CommentsIndentationCheck extends Check { <nl> * } <nl> * < / pre > <nl> * < / p > <nl> - * @ param singleLineComment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . <nl> + * @ param comment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . <nl> * @ param prevStmt previous code statement . <nl> * @ param nextStmt next code statement . <nl> * @ return true if comment and next code statement are indented at the same level . <nl> * / <nl> - private static boolean areSameLevelIndented ( DetailAST singleLineComment , <nl> - DetailAST prevStmt , DetailAST nextStmt ) { <nl> + private static boolean areSameLevelIndented ( DetailAST comment , DetailAST prevStmt , <nl> + DetailAST nextStmt ) { <nl> boolean result ; <nl> if ( prevStmt = = null ) { <nl> - result = singleLineComment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) ; <nl> + result = comment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) ; <nl> } <nl> else { <nl> - result = singleLineComment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) <nl> - | | singleLineComment . getColumnNo ( ) = = prevStmt . getColumnNo ( ) ; <nl> + result = comment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) <nl> + | | comment . getColumnNo ( ) = = prevStmt . getColumnNo ( ) ; <nl> } <nl> return result ; <nl> } <nl> @ @ - 280 , 10 + 764 , 9 @ @ public class CommentsIndentationCheck extends Check { <nl> final DetailAST prevStatement = getPrevStatementFromSwitchBlock ( blockComment ) ; <nl> <nl> if ( nextStatement ! = null <nl> - & & nextStatement . getType ( ) ! = TokenTypes . RCURLY <nl> - & & ! isTrailingBlockComment ( blockComment ) <nl> - & & ! areSameLevelIndented ( blockComment , prevStatement , nextStatement ) ) { <nl> - <nl> + & & nextStatement . getType ( ) ! = TokenTypes . RCURLY <nl> + & & ! isTrailingBlockComment ( blockComment ) <nl> + & & ! areSameLevelIndented ( blockComment , prevStatement , nextStatement ) ) { <nl> log ( blockComment . getLineNo ( ) , MSG _ KEY _ BLOCK , nextStatement . getLineNo ( ) , <nl> blockComment . getColumnNo ( ) , nextStatement . getColumnNo ( ) ) ; <nl> }

TEST DIFF:
diff - - git a / config / pmd . xml b / config / pmd . xml 
 index 04cb8b8 . . 72ec709 100644 
 - - - a / config / pmd . xml 
 + + + b / config / pmd . xml 
 @ @ - 268 , 13 + 268 , 6 @ @ 
 < ! - - not configurable , decreases readability - - > 
 < exclude name = " UseStringBufferForStringAppends " / > 
 < / rule > 
 - < rule ref = " rulesets / java / strictexception . xml " / > 
 - < rule ref = " rulesets / java / strictexception . xml / ExceptionAsFlowControl " > 
 - < properties > 
 - < ! - - till # 1159 - - > 
 - < property name = " violationSuppressXPath " value = " / / ClassOrInterfaceDeclaration [ @ Image = ' PackageObjectFactory ' ] " / > 
 - < / properties > 
 - < / rule > 
 < rule ref = " rulesets / java / strictexception . xml / AvoidCatchingGenericException " > 
 < properties > 
 < ! - - There is no other way to deliver filename that was under processing - - > 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java b / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java 
 index bbd86c2 . . 8f2b42f 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java 
 @ @ - 20 , 12 + 20 , 12 @ @ 
 package com . puppycrawl . tools . checkstyle ; 
 
 import java . lang . reflect . Constructor ; 
 + import java . util . Iterator ; 
 import java . util . Set ; 
 
 import org . apache . commons . logging . Log ; 
 import org . apache . commons . logging . LogFactory ; 
 
 - import com . google . common . annotations . VisibleForTesting ; 
 import com . google . common . base . Joiner ; 
 import com . google . common . collect . Sets ; 
 import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; 
 @ @ - 47 , 9 + 47 , 11 @ @ public class PackageObjectFactory implements ModuleFactory { 
 private static final String UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE = 
 " PackageObjectFactory . unableToInstantiateExceptionMessage " ; 
 
 + / * * Separator to use in strings . * / 
 + private static final String STRING _ SEPARATOR = " , " ; 
 + 
 / * * A list of package names to prepend to class names . * / 
 private final Set < String > packages ; 
 - 
 / * * The class loader used to load Checkstyle core and custom modules . * / 
 private final ClassLoader moduleClassLoader ; 
 
 @ @ - 59 , 8 + 61 , 7 @ @ public class PackageObjectFactory implements ModuleFactory { 
 * @ param moduleClassLoader class loader used to load Checkstyle 
 * core and custom modules 
 * / 
 - public PackageObjectFactory ( Set < String > packageNames , 
 - ClassLoader moduleClassLoader ) { 
 + public PackageObjectFactory ( Set < String > packageNames , ClassLoader moduleClassLoader ) { 
 if ( moduleClassLoader = = null ) { 
 throw new IllegalArgumentException ( 
 " moduleClassLoader must not be null " ) ; 
 @ @ - 72 , 99 + 73 , 65 @ @ public class PackageObjectFactory implements ModuleFactory { 
 } 
 
 / * * 
 - * Registers a package name to use for shortName resolution . 
 - * @ param packageName the package name 
 - * / 
 - @ VisibleForTesting 
 - void addPackage ( String packageName ) { 
 - packages . add ( packageName ) ; 
 - } 
 - 
 - / * * 
 - * Creates a new instance of a class from a given name . If the name is 
 + * Creates a new instance of a class from a given name , or that name 
 + * concatenated with & quot ; Check & quot ; . If the name is 
 * a class name , creates an instance of the named class . Otherwise , creates 
 - * an instance of a class name obtained by concatenating the given 
 + * an instance of a class name obtained by concatenating the given name 
 * to a package name from a given list of package names . 
 * @ param name the name of a class . 
 - * @ return the { @ code Object } 
 + * @ return the { @ code Object } created by loader . 
 * @ throws CheckstyleException if an error occurs . 
 * / 
 - private Object doMakeObject ( String name ) 
 - throws CheckstyleException { 
 - / / try name first 
 - try { 
 - return createObject ( name ) ; 
 - } 
 - catch ( final CheckstyleException ex ) { 
 - LOG . debug ( IGNORING _ EXCEPTION _ MESSAGE , ex ) ; 
 - } 
 - 
 - / / now try packages 
 - for ( String packageName : packages ) { 
 - 
 - final String className = packageName + name ; 
 - try { 
 - return createObject ( className ) ; 
 - } 
 - catch ( final CheckstyleException ex ) { 
 - LOG . debug ( IGNORING _ EXCEPTION _ MESSAGE , ex ) ; 
 + @ Override 
 + public Object createModule ( String name ) throws CheckstyleException { 
 + Object instance = createObjectWithIgnoringProblems ( name , getAllPossibleNames ( name ) ) ; 
 + if ( instance = = null ) { 
 + final String nameCheck = name + " Check " ; 
 + instance = createObjectWithIgnoringProblems ( nameCheck , getAllPossibleNames ( nameCheck ) ) ; 
 + if ( instance = = null ) { 
 + 
 + final String attemptedNames = joinPackageNamesWithClassName ( name ) 
 + + STRING _ SEPARATOR + nameCheck + STRING _ SEPARATOR 
 + + joinPackageNamesWithClassName ( nameCheck ) ; 
 + final LocalizedMessage exceptionMessage = new LocalizedMessage ( 0 , 
 + Definitions . CHECKSTYLE _ BUNDLE , UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE , 
 + new String [ ] { name , attemptedNames } , null , getClass ( ) , null ) ; 
 + throw new CheckstyleException ( exceptionMessage . getMessage ( ) ) ; 
 } 
 } 
 - final LocalizedMessage exceptionMessage = new LocalizedMessage ( 0 , 
 - Definitions . CHECKSTYLE _ BUNDLE , UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE , 
 - new String [ ] { name , joinPackageNamesWithClassName ( name ) } , 
 - null , getClass ( ) , null ) ; 
 - throw new CheckstyleException ( exceptionMessage . getMessage ( ) ) ; 
 + return instance ; 
 } 
 
 / * * 
 - * Creates a new instance of a named class . 
 + * Create a new instance of a named class . 
 * @ param className the name of the class to instantiate . 
 - * @ return the { @ code Object } created by loader . 
 - * @ throws CheckstyleException if an error occurs . 
 + * @ param secondAttempt the set of names to attempt instantiation 
 + * if usage of the className was not successful . 
 + * @ return the { @ code Object } created by loader or null . 
 * / 
 - private Object createObject ( String className ) 
 - throws CheckstyleException { 
 - try { 
 - final Class < ? > clazz = Class . forName ( className , true , moduleClassLoader ) ; 
 - final Constructor < ? > declaredConstructor = clazz . getDeclaredConstructor ( ) ; 
 - declaredConstructor . setAccessible ( true ) ; 
 - return declaredConstructor . newInstance ( ) ; 
 - } 
 - catch ( final ReflectiveOperationException | NoClassDefFoundError exception ) { 
 - throw new CheckstyleException ( " Unable to find class for " + className , exception ) ; 
 + private Object createObjectWithIgnoringProblems ( String className , 
 + Set < String > secondAttempt ) { 
 + Object instance = createObject ( className ) ; 
 + if ( instance = = null ) { 
 + final Iterator < String > ite = secondAttempt . iterator ( ) ; 
 + while ( instance = = null & & ite . hasNext ( ) ) { 
 + instance = createObject ( ite . next ( ) ) ; 
 + } 
 } 
 + return instance ; 
 } 
 
 / * * 
 - * Creates a new instance of a class from a given name , or that name 
 - * concatenated with & quot ; Check & quot ; . If the name is 
 - * a class name , creates an instance of the named class . Otherwise , creates 
 - * an instance of a class name obtained by concatenating the given name 
 - * to a package name from a given list of package names . 
 - * @ param name the name of a class . 
 - * @ return the { @ code Object } created by loader . 
 - * @ throws CheckstyleException if an error occurs . 
 + * Generate the set of all possible names for a class name . 
 + * @ param name the name of the class get possible names for . 
 + * @ return all possible name for a class . 
 * / 
 - @ Override 
 - public Object createModule ( String name ) 
 - throws CheckstyleException { 
 - try { 
 - return doMakeObject ( name ) ; 
 - } 
 - catch ( final CheckstyleException ignored ) { 
 - / / try again with suffix " Check " 
 - try { 
 - return doMakeObject ( name + " Check " ) ; 
 - } 
 - catch ( final CheckstyleException ex ) { 
 - final LocalizedMessage exceptionMessage = new LocalizedMessage ( 0 , 
 - Definitions . CHECKSTYLE _ BUNDLE , UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE , 
 - new String [ ] { name , joinPackageNamesWithClassName ( name ) } , 
 - null , getClass ( ) , null ) ; 
 - throw new CheckstyleException ( exceptionMessage . getMessage ( ) , ex ) ; 
 - } 
 + private Set < String > getAllPossibleNames ( String name ) { 
 + final Set < String > names = Sets . newHashSet ( ) ; 
 + for ( String packageName : packages ) { 
 + names . add ( packageName + name ) ; 
 } 
 + return names ; 
 } 
 
 / * * 
 @ @ - 173 , 7 + 140 , 26 @ @ public class PackageObjectFactory implements ModuleFactory { 
 * @ return a string which is obtained by joining package names with a class name . 
 * / 
 private String joinPackageNamesWithClassName ( String className ) { 
 - final Joiner joiner = Joiner . on ( className + " , " ) . skipNulls ( ) ; 
 + final Joiner joiner = Joiner . on ( className + STRING _ SEPARATOR ) . skipNulls ( ) ; 
 return joiner . join ( packages ) + className ; 
 } 
 + 
 + / * * 
 + * Creates a new instance of a named class . 
 + * @ param className the name of the class to instantiate . 
 + * @ return the { @ code Object } created by loader or null . 
 + * / 
 + private Object createObject ( String className ) { 
 + Object instance = null ; 
 + try { 
 + final Class < ? > clazz = Class . forName ( className , true , moduleClassLoader ) ; 
 + final Constructor < ? > declaredConstructor = clazz . getDeclaredConstructor ( ) ; 
 + declaredConstructor . setAccessible ( true ) ; 
 + instance = declaredConstructor . newInstance ( ) ; 
 + } 
 + catch ( final ReflectiveOperationException | NoClassDefFoundError exception ) { 
 + LOG . debug ( IGNORING _ EXCEPTION _ MESSAGE , exception ) ; 
 + } 
 + return instance ; 
 + } 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java 
 index 7e66ad4 . . 95a13f4 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java 
 @ @ - 59 , 14 + 59 , 4 @ @ public class PackageObjectFactoryTest { 
 " com . puppycrawl . tools . checkstyle . checks . naming . ConstantName " ) ; 
 assertNotNull ( check ) ; 
 } 
 - 
 - @ Test 
 - public void testMakeObjectFromList ( ) 
 - throws CheckstyleException { 
 - factory . addPackage ( " com . " ) ; 
 - final Checker checker = 
 - ( Checker ) factory . createModule ( 
 - " puppycrawl . tools . checkstyle . Checker " ) ; 
 - assertNotNull ( checker ) ; 
 - } 
 }

NEAREST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java 
 index 6d1857b . . 594f250 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java 
 @ @ - 19 , 6 + 19 , 9 @ @ 
 
 package com . puppycrawl . tools . checkstyle . checks . indentation ; 
 
 + import java . util . Locale ; 
 + import java . util . Stack ; 
 + 
 import org . apache . commons . lang3 . ArrayUtils ; 
 
 import com . puppycrawl . tools . checkstyle . api . Check ; 
 @ @ - 62 , 22 + 65 , 18 @ @ import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; 
 * } 
 * < / pre > 
 * 
 - * 
 * @ author < a href = " mailto : nesterenko - aleksey @ list . ru " > Aleksey Nesterenko < / a > 
 * @ author < a href = " mailto : andreyselkin @ gmail . com " > Andrei Selkin < / a > 
 - * 
 * / 
 public class CommentsIndentationCheck extends Check { 
 
 / * * 
 - * A key is pointing to the warning message text in " messages . properties " 
 - * file . 
 + * A key is pointing to the warning message text in " messages . properties " file . 
 * / 
 public static final String MSG _ KEY _ SINGLE = " comments . indentation . single " ; 
 
 / * * 
 - * A key is pointing to the warning message text in " messages . properties " 
 - * file . 
 + * A key is pointing to the warning message text in " messages . properties " file . 
 * / 
 public static final String MSG _ KEY _ BLOCK = " comments . indentation . block " ; 
 
 @ @ - 135 , 17 + 134 , 493 @ @ public class CommentsIndentationCheck extends Check { 
 * @ param singleLineComment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . 
 * / 
 private void visitSingleLineComment ( DetailAST singleLineComment ) { 
 - final DetailAST nextStatement = singleLineComment . getNextSibling ( ) ; 
 - final DetailAST prevStatement = getPrevStatementFromSwitchBlock ( singleLineComment ) ; 
 + final DetailAST prevStmt = getPreviousStatementOfSingleLineComment ( singleLineComment ) ; 
 + final DetailAST nextStmt = singleLineComment . getNextSibling ( ) ; 
 
 - if ( nextStatement ! = null 
 - & & nextStatement . getType ( ) ! = TokenTypes . RCURLY 
 - & & ! isTrailingSingleLineComment ( singleLineComment ) 
 - & & ! areSameLevelIndented ( singleLineComment , prevStatement , nextStatement ) ) { 
 + if ( ! isTrailingSingleLineComment ( singleLineComment ) ) { 
 + if ( isInEmptyCaseBlock ( prevStmt , nextStmt ) ) { 
 + handleSingleLineCommentInEmptyCaseBlock ( prevStmt , singleLineComment , 
 + nextStmt ) ; 
 + } 
 + else if ( isFallThroughSingleLineComment ( prevStmt , nextStmt ) ) { 
 + handleFallThroughtSingleLineComment ( prevStmt , singleLineComment , 
 + nextStmt ) ; 
 + } 
 + else if ( isInEmptyCodeBlock ( prevStmt , nextStmt ) ) { 
 + handleSingleLineCommentInEmptyCodeBlock ( singleLineComment , nextStmt ) ; 
 + } 
 + else if ( isSingleLineCommentAtTheEndOfTheCodeBlock ( nextStmt ) ) { 
 + handleSIngleLineCommentAtTheEndOfTheCodeBlock ( prevStmt , singleLineComment , 
 + nextStmt ) ; 
 + } 
 + else if ( nextStmt ! = null 
 + & & ! areSameLevelIndented ( singleLineComment , nextStmt , nextStmt ) ) { 
 + log ( singleLineComment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , 
 + singleLineComment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Returns the previous statement of a single line comment . 
 + * @ param comment single line comment . 
 + * @ return the previous statement of a single line comment . 
 + * / 
 + private DetailAST getPreviousStatementOfSingleLineComment ( DetailAST comment ) { 
 + final DetailAST prevStatement ; 
 + if ( isDistributedPreviousStatement ( comment ) ) { 
 + prevStatement = getDistributedPreviousStatementOfSingleLineComment ( comment ) ; 
 + } 
 + else { 
 + prevStatement = getOneLinePreviousStatementOfSingleLineComment ( comment ) ; 
 + } 
 + return prevStatement ; 
 + } 
 + 
 + / * * 
 + * Checks whether the previous statement of a single line comment is distributed over two or 
 + * more lines . 
 + * @ param singleLineComment single line comment . 
 + * @ return true if the previous statement of a single line comment is distributed over two or 
 + * more lines . 
 + * / 
 + private boolean isDistributedPreviousStatement ( DetailAST singleLineComment ) { 
 + final DetailAST previousSibling = singleLineComment . getPreviousSibling ( ) ; 
 + return isDistributedMethodChainOrConcatenationStatement ( singleLineComment , previousSibling ) 
 + | | isDistributedReturnStatement ( previousSibling ) 
 + | | isDistributedThrowStatement ( previousSibling ) ; 
 + } 
 + 
 + / * * 
 + * Checks whether the previous statement of a single line comment is a method call chain or 
 + * string concatenation statemen distributed over two ore more lines . 
 + * @ param comment single line comment . 
 + * @ param commentPreviousSibling previous sibling of the sinle line comment . 
 + * @ return if the previous statement of a single line comment is a method call chain or 
 + * string concatenation statemen distributed over two ore more lines . 
 + * / 
 + private static boolean isDistributedMethodChainOrConcatenationStatement ( 
 + DetailAST comment , DetailAST commentPreviousSibling ) { 
 + boolean destributed = false ; 
 + if ( commentPreviousSibling ! = null 
 + & & commentPreviousSibling . getType ( ) = = TokenTypes . SEMI 
 + & & comment . getLineNo ( ) - commentPreviousSibling . getLineNo ( ) = = 1 ) { 
 + DetailAST currentToken = commentPreviousSibling . getPreviousSibling ( ) ; 
 + while ( currentToken . getFirstChild ( ) ! = null ) { 
 + currentToken = currentToken . getFirstChild ( ) ; 
 + } 
 + if ( currentToken . getType ( ) ! = TokenTypes . COMMENT _ CONTENT 
 + & & commentPreviousSibling . getLineNo ( ) ! = currentToken . getLineNo ( ) ) { 
 + destributed = true ; 
 + } 
 + } 
 + return destributed ; 
 + } 
 + 
 + / * * 
 + * Checks whether the previous statement of a single line comment is a destributed return 
 + * statement . 
 + * @ param commentPreviousSibling previous sibling of the single line comment . 
 + * @ return true if the previous statement of a single line comment is a destributed return 
 + * statement . 
 + * / 
 + private static boolean isDistributedReturnStatement ( DetailAST commentPreviousSibling ) { 
 + boolean destributed = false ; 
 + if ( commentPreviousSibling ! = null 
 + & & commentPreviousSibling . getType ( ) = = TokenTypes . LITERAL _ RETURN ) { 
 + final DetailAST firstChild = commentPreviousSibling . getFirstChild ( ) ; 
 + final DetailAST nextSibling = firstChild . getNextSibling ( ) ; 
 + if ( nextSibling ! = null ) { 
 + destributed = true ; 
 + } 
 + } 
 + return destributed ; 
 + } 
 + 
 + / * * 
 + * Checks whether the previous statement of a single line comment is a destributed throw 
 + * statement . 
 + * @ param commentPreviousSibling previous sibling of the single line comment . 
 + * @ return true if the previous statement of a single line comment is a destributed throw 
 + * statement . 
 + * / 
 + private static boolean isDistributedThrowStatement ( DetailAST commentPreviousSibling ) { 
 + boolean destributed = false ; 
 + if ( commentPreviousSibling ! = null 
 + & & commentPreviousSibling . getType ( ) = = TokenTypes . LITERAL _ THROW ) { 
 + final DetailAST firstChild = commentPreviousSibling . getFirstChild ( ) ; 
 + final DetailAST nextSibling = firstChild . getNextSibling ( ) ; 
 + if ( nextSibling . getLineNo ( ) ! = commentPreviousSibling . getLineNo ( ) ) { 
 + destributed = true ; 
 + } 
 + } 
 + return destributed ; 
 + } 
 
 - log ( singleLineComment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStatement . getLineNo ( ) , 
 - singleLineComment . getColumnNo ( ) , nextStatement . getColumnNo ( ) ) ; 
 + / * * 
 + * Returns the first token of the destributed previous statement of single line comment . 
 + * @ param comment single line comment . 
 + * @ return the first token of the destributed previous statement of single line comment . 
 + * / 
 + public static DetailAST getDistributedPreviousStatementOfSingleLineComment ( DetailAST comment ) { 
 + DetailAST previousStatement = comment . getPreviousSibling ( ) ; 
 + if ( previousStatement . getType ( ) = = TokenTypes . LITERAL _ RETURN 
 + | | previousStatement . getType ( ) = = TokenTypes . LITERAL _ THROW ) { 
 + return previousStatement ; 
 + } 
 + previousStatement = previousStatement . getPreviousSibling ( ) ; 
 + while ( previousStatement . getFirstChild ( ) ! = null ) { 
 + previousStatement = previousStatement . getFirstChild ( ) ; 
 } 
 + return previousStatement ; 
 + } 
 + 
 + / * * 
 + * Checks whether case block is empty . 
 + * @ param nextStmt previous statement . 
 + * @ param prevStmt next statement . 
 + * @ return true if case block is empty . 
 + * / 
 + private static boolean isInEmptyCaseBlock ( DetailAST prevStmt , DetailAST nextStmt ) { 
 + return prevStmt ! = null 
 + & & nextStmt ! = null 
 + & & ( prevStmt . getType ( ) = = TokenTypes . LITERAL _ CASE 
 + | | prevStmt . getType ( ) = = TokenTypes . CASE _ GROUP ) 
 + & & ( nextStmt . getType ( ) = = TokenTypes . LITERAL _ CASE 
 + | | nextStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT ) ; 
 + } 
 + 
 + / * * 
 + * Checks whether single line comment is a ' fall through ' comment . 
 + * For example : 
 + * < p > 
 + * { @ code 
 + * . . . 
 + * case OPTION _ ONE : 
 + * int someVariable = 1 ; 
 + * / / fall through 
 + * case OPTION _ TWO : 
 + * int a = 5 ; 
 + * break ; 
 + * . . . 
 + * } 
 + * < / p > 
 + * @ param prevStmt previous statement . 
 + * @ param nextStmt next statement . 
 + * @ return true if a single line comment is a ' fall through ' comment . 
 + * / 
 + private static boolean isFallThroughSingleLineComment ( DetailAST prevStmt , DetailAST nextStmt ) { 
 + return prevStmt ! = null 
 + & & prevStmt . getType ( ) ! = TokenTypes . LITERAL _ CASE 
 + & & nextStmt ! = null 
 + & & ( nextStmt . getType ( ) = = TokenTypes . LITERAL _ CASE 
 + | | nextStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT ) ; 
 + } 
 + 
 + / * * 
 + * Checks whether a single line comment is placed at the end of the code block . 
 + * @ param nextStmt next statement . 
 + * @ return true if a single line comment is placed at the end of the block . 
 + * / 
 + private boolean isSingleLineCommentAtTheEndOfTheCodeBlock ( DetailAST nextStmt ) { 
 + return nextStmt ! = null 
 + & & nextStmt . getType ( ) = = TokenTypes . RCURLY ; 
 + } 
 + 
 + / * * 
 + * Checks whether comment is placed in the empty code block . 
 + * For example : 
 + * < p > 
 + * . . . 
 + * { @ code 
 + * / / empty code block 
 + * } 
 + * . . . 
 + * < / p > 
 + * Note , the method does not treat empty case blocks . 
 + * @ param prevStmt previous statement . 
 + * @ param nextStmt next statement . 
 + * @ return true if comment is placed in the empty code block . 
 + * / 
 + private boolean isInEmptyCodeBlock ( DetailAST prevStmt , DetailAST nextStmt ) { 
 + return prevStmt ! = null 
 + & & nextStmt ! = null 
 + & & ( prevStmt . getType ( ) = = TokenTypes . SLIST 
 + | | prevStmt . getType ( ) = = TokenTypes . OBJBLOCK ) 
 + & & nextStmt . getType ( ) = = TokenTypes . RCURLY ; 
 + } 
 + 
 + / * * 
 + * Handles a single line comment which is plased within empty case block . 
 + * Note , if comment is placed at the end of the empty case block , we have Checkstyle ' s 
 + * limitations to clearly detect user intention of explanation target - above or below . The 
 + * only case we can assume as a violation is when a single line comment within the empty case 
 + * block has indentation level that is lower than the indentation level of the next case 
 + * token . For example : 
 + * < p > 
 + * { @ code 
 + * . . . 
 + * case OPTION _ ONE : 
 + * / / violation 
 + * case OPTION _ TWO : 
 + * . . . 
 + * } 
 + * < / p > 
 + * @ param prevStmt previous statement . 
 + * @ param comment single line comment . 
 + * @ param nextStmt next statement . 
 + * / 
 + private void handleSingleLineCommentInEmptyCaseBlock ( DetailAST prevStmt , DetailAST comment , 
 + DetailAST nextStmt ) { 
 + 
 + if ( comment . getColumnNo ( ) < prevStmt . getColumnNo ( ) 
 + | | comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { 
 + logMultilineIndentation ( prevStmt , comment , nextStmt ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Handles ' fall through ' single line comment . 
 + * Note , ' fall through ' and similar comments can have indentation level as next or previous 
 + * statement . 
 + * For example : 
 + * < p > 
 + * { @ code 
 + * . . . 
 + * case OPTION _ ONE : 
 + * int someVariable = 1 ; 
 + * / / fall through - OK 
 + * case OPTION _ TWO : 
 + * int a = 5 ; 
 + * break ; 
 + * . . . 
 + * } 
 + * < / p > 
 + * < p > 
 + * { @ code 
 + * . . . 
 + * case OPTION _ ONE : 
 + * int someVariable = 1 ; 
 + * / / than init variable a - OK 
 + * case OPTION _ TWO : 
 + * int a = 5 ; 
 + * break ; 
 + * . . . 
 + * } 
 + * < / p > 
 + * @ param prevStmt previous statement . 
 + * @ param comment single line comment . 
 + * @ param nextStmt next statement . 
 + * / 
 + private void handleFallThroughtSingleLineComment ( DetailAST prevStmt , DetailAST comment , 
 + DetailAST nextStmt ) { 
 + 
 + if ( ! areSameLevelIndented ( comment , prevStmt , nextStmt ) ) { 
 + logMultilineIndentation ( prevStmt , comment , nextStmt ) ; 
 + } 
 + 
 + } 
 + 
 + / * * 
 + * Hendles a single line comment which is placed at the end of non empty code block . 
 + * Note , if single line comment is plcaed at the end of non empty block the comment should have 
 + * the same indentation level as the previous statement . For example : 
 + * < p > 
 + * { @ code 
 + * if ( a = = true ) { 
 + * int b = 1 ; 
 + * / / comment 
 + * } 
 + * } 
 + * < / p > 
 + * @ param prevStmt previous statement . 
 + * @ param comment single line statement . 
 + * @ param nextStmt next statement . 
 + * / 
 + private void handleSIngleLineCommentAtTheEndOfTheCodeBlock ( DetailAST prevStmt , 
 + DetailAST comment , 
 + DetailAST nextStmt ) { 
 + if ( prevStmt ! = null ) { 
 + if ( prevStmt . getType ( ) = = TokenTypes . LITERAL _ CASE 
 + | | prevStmt . getType ( ) = = TokenTypes . CASE _ GROUP 
 + | | prevStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT 
 + | | prevStmt . getType ( ) = = TokenTypes . SINGLE _ LINE _ COMMENT ) { 
 + if ( comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { 
 + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , 
 + comment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; 
 + } 
 + } 
 + else if ( ! areSameLevelIndented ( comment , prevStmt , prevStmt ) ) { 
 + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , prevStmt . getLineNo ( ) , 
 + comment . getColumnNo ( ) , prevStmt . getColumnNo ( ) ) ; 
 + } 
 + } 
 + 
 + } 
 + 
 + / * * 
 + * Handles a single line comment which is placed within the empty code block . 
 + * Note , if comment is placed at the end of the empty code block , we have Checkstyle ' s 
 + * limitations to clearly detect user intention of explanation target - above or below . The 
 + * only case we can assume as a violation is when a single line comment within the empty 
 + * code block has indentation level that is lower than the indentation level of the closing 
 + * right curly brace . For example : 
 + * < p > 
 + * { @ code 
 + * if ( a = = true ) { 
 + * / / violation 
 + * } 
 + * } 
 + * < / p > 
 + * 
 + * @ param comment single line comment . 
 + * @ param nextStmt next statement . 
 + * / 
 + private void handleSingleLineCommentInEmptyCodeBlock ( DetailAST comment , DetailAST nextStmt ) { 
 + if ( comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { 
 + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , 
 + comment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Does pre - order traverse of abstract syntax tree to find the previous statement of the 
 + * single line comment . If previous statement of the comment is found , then the traverse will 
 + * be finished . 
 + * @ param comment current statement . 
 + * @ return previous statement of the comment or null if the comment does not have previous 
 + * statement . 
 + * / 
 + private static DetailAST getOneLinePreviousStatementOfSingleLineComment ( DetailAST comment ) { 
 + final Stack < DetailAST > stack = new Stack < > ( ) ; 
 + DetailAST root = comment . getParent ( ) ; 
 + 
 + while ( root ! = null | | ! stack . empty ( ) ) { 
 + if ( ! stack . empty ( ) ) { 
 + root = stack . pop ( ) ; 
 + } 
 + while ( root ! = null ) { 
 + final DetailAST previousStatement = 
 + findPreviousStatementOfSingleLineComment ( comment , root ) ; 
 + if ( previousStatement ! = null ) { 
 + return previousStatement ; 
 + } 
 + if ( root . getNextSibling ( ) ! = null ) { 
 + stack . push ( root . getNextSibling ( ) ) ; 
 + } 
 + root = root . getFirstChild ( ) ; 
 + } 
 + } 
 + return null ; 
 + } 
 + 
 + / * * 
 + * Finds a previous statement of the single line comment . 
 + * Uses root token of the line while searching . 
 + * @ param comment single line comment . 
 + * @ param root root token of the line . 
 + * @ return previous statement of the single line comment or null if previous statement was not 
 + * found . 
 + * / 
 + private static DetailAST findPreviousStatementOfSingleLineComment ( DetailAST comment , 
 + DetailAST root ) { 
 + DetailAST previousStatement = null ; 
 + if ( root . getLineNo ( ) > = comment . getLineNo ( ) ) { 
 + / / ATTENTION : parent of the comment is below the comment in case block 
 + / / See https : / / github . com / checkstyle / checkstyle / issues / 851 
 + previousStatement = getPrevStatementFromSwitchBlock ( comment ) ; 
 + } 
 + final DetailAST tokenWhichBeginsTheLine ; 
 + if ( root . getType ( ) = = TokenTypes . EXPR 
 + & & root . getFirstChild ( ) . getFirstChild ( ) ! = null ) { 
 + if ( root . getFirstChild ( ) . getType ( ) = = TokenTypes . LITERAL _ NEW ) { 
 + tokenWhichBeginsTheLine = root . getFirstChild ( ) ; 
 + } 
 + else { 
 + tokenWhichBeginsTheLine = findTokenWhichBeginsTheLine ( root ) ; 
 + } 
 + } 
 + else if ( root . getType ( ) = = TokenTypes . PLUS ) { 
 + tokenWhichBeginsTheLine = root . getFirstChild ( ) ; 
 + } 
 + else { 
 + tokenWhichBeginsTheLine = root ; 
 + } 
 + if ( tokenWhichBeginsTheLine ! = null 
 + & & isOnPreviousLine ( comment , tokenWhichBeginsTheLine ) ) { 
 + previousStatement = tokenWhichBeginsTheLine ; 
 + } 
 + return previousStatement ; 
 + } 
 + 
 + / * * 
 + * Finds a token which begins the line . 
 + * @ param root root token of the line . 
 + * @ return token which begins the line . 
 + * / 
 + private static DetailAST findTokenWhichBeginsTheLine ( DetailAST root ) { 
 + DetailAST tokenWhichBeginsTheLine ; 
 + if ( isUsingOfObjectReferenceToInvokeMethod ( root ) ) { 
 + tokenWhichBeginsTheLine = findStartTokenOfMethodCallChain ( root ) ; 
 + } 
 + else { 
 + tokenWhichBeginsTheLine = root . getFirstChild ( ) . findFirstToken ( TokenTypes . IDENT ) ; 
 + } 
 + return tokenWhichBeginsTheLine ; 
 + } 
 + 
 + / * * 
 + * Checks whether there is a use of an object reference to invoke an object ' s method on line . 
 + * @ param root root token of the line . 
 + * @ return true if there is a use of an object reference to invoke an object ' s method on line . 
 + * / 
 + private static boolean isUsingOfObjectReferenceToInvokeMethod ( DetailAST root ) { 
 + return root . getFirstChild ( ) . getFirstChild ( ) . getFirstChild ( ) ! = null 
 + & & root . getFirstChild ( ) . getFirstChild ( ) . getFirstChild ( ) . getNextSibling ( ) ! = null ; 
 + } 
 + 
 + / * * 
 + * Finds the start token of method call chain . 
 + * @ param root root token of the line . 
 + * @ return the start token of method call chain . 
 + * / 
 + private static DetailAST findStartTokenOfMethodCallChain ( DetailAST root ) { 
 + DetailAST startOfMethodCallChain = root ; 
 + while ( startOfMethodCallChain . getFirstChild ( ) ! = null 
 + & & startOfMethodCallChain . getFirstChild ( ) . getLineNo ( ) = = root . getLineNo ( ) ) { 
 + startOfMethodCallChain = startOfMethodCallChain . getFirstChild ( ) ; 
 + } 
 + if ( startOfMethodCallChain . getFirstChild ( ) ! = null ) { 
 + startOfMethodCallChain = startOfMethodCallChain . getFirstChild ( ) . getNextSibling ( ) ; 
 + } 
 + return startOfMethodCallChain ; 
 + } 
 + 
 + / * * 
 + * Checks whether the checked statement is on previous line . 
 + * @ param currentStatement current statement . 
 + * @ param checkedStatement checked statement . 
 + * @ return true if checked statement is on the line which is previous to current statement . 
 + * / 
 + private static boolean isOnPreviousLine ( DetailAST currentStatement , 
 + DetailAST checkedStatement ) { 
 + return currentStatement . getLineNo ( ) - checkedStatement . getLineNo ( ) = = 1 ; 
 + } 
 + 
 + / * * 
 + * Logs comment which can have the same indentation level as next or previous statement . 
 + * @ param comment comment . 
 + * @ param nextStmt previous statement . 
 + * @ param prevStmt next statement . 
 + * / 
 + private void logMultilineIndentation ( DetailAST prevStmt , DetailAST comment , 
 + DetailAST nextStmt ) { 
 + final String multilineNoTemplate = " % d , % d " ; 
 + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , 
 + String . format ( Locale . getDefault ( ) , multilineNoTemplate , prevStmt . getLineNo ( ) , 
 + nextStmt . getLineNo ( ) ) , comment . getColumnNo ( ) , 
 + String . format ( Locale . getDefault ( ) , multilineNoTemplate , prevStmt . getColumnNo ( ) , 
 + nextStmt . getColumnNo ( ) ) ) ; 
 } 
 
 / * * 
 @ @ - 181 , 10 + 656 , 20 @ @ public class CommentsIndentationCheck extends Check { 
 blockBody = blockBody . getPreviousSibling ( ) ; 
 } 
 if ( blockBody . getType ( ) = = TokenTypes . EXPR ) { 
 - prevStmt = blockBody . getFirstChild ( ) . getFirstChild ( ) ; 
 + if ( isUsingOfObjectReferenceToInvokeMethod ( blockBody ) ) { 
 + prevStmt = findStartTokenOfMethodCallChain ( blockBody ) ; 
 + } 
 + else { 
 + prevStmt = blockBody . getFirstChild ( ) . getFirstChild ( ) ; 
 + } 
 } 
 else { 
 - prevStmt = blockBody ; 
 + if ( blockBody . getType ( ) = = TokenTypes . SLIST ) { 
 + prevStmt = blockBody . getParent ( ) . getParent ( ) ; 
 + } 
 + else { 
 + prevStmt = blockBody ; 
 + } 
 } 
 } 
 return prevStmt ; 
 @ @ - 199 , 10 + 684 , 9 @ @ public class CommentsIndentationCheck extends Check { 
 final DetailAST prevCaseToken ; 
 final DetailAST parentBlock = parentStatement . getParent ( ) ; 
 if ( parentBlock ! = null & & parentBlock . getParent ( ) ! = null 
 - & & parentBlock . getParent ( ) . getPreviousSibling ( ) ! = null 
 - & & parentBlock . getParent ( ) . getPreviousSibling ( ) 
 - . getType ( ) = = TokenTypes . LITERAL _ CASE ) { 
 - 
 + & & parentBlock . getParent ( ) . getPreviousSibling ( ) ! = null 
 + & & parentBlock . getParent ( ) . getPreviousSibling ( ) . getType ( ) 
 + = = TokenTypes . LITERAL _ CASE ) { 
 prevCaseToken = parentBlock . getParent ( ) . getPreviousSibling ( ) ; 
 } 
 else { 
 @ @ - 229 , 20 + 713 , 20 @ @ public class CommentsIndentationCheck extends Check { 
 * } 
 * < / pre > 
 * < / p > 
 - * @ param singleLineComment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . 
 + * @ param comment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . 
 * @ param prevStmt previous code statement . 
 * @ param nextStmt next code statement . 
 * @ return true if comment and next code statement are indented at the same level . 
 * / 
 - private static boolean areSameLevelIndented ( DetailAST singleLineComment , 
 - DetailAST prevStmt , DetailAST nextStmt ) { 
 + private static boolean areSameLevelIndented ( DetailAST comment , DetailAST prevStmt , 
 + DetailAST nextStmt ) { 
 boolean result ; 
 if ( prevStmt = = null ) { 
 - result = singleLineComment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) ; 
 + result = comment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) ; 
 } 
 else { 
 - result = singleLineComment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) 
 - | | singleLineComment . getColumnNo ( ) = = prevStmt . getColumnNo ( ) ; 
 + result = comment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) 
 + | | comment . getColumnNo ( ) = = prevStmt . getColumnNo ( ) ; 
 } 
 return result ; 
 } 
 @ @ - 280 , 10 + 764 , 9 @ @ public class CommentsIndentationCheck extends Check { 
 final DetailAST prevStatement = getPrevStatementFromSwitchBlock ( blockComment ) ; 
 
 if ( nextStatement ! = null 
 - & & nextStatement . getType ( ) ! = TokenTypes . RCURLY 
 - & & ! isTrailingBlockComment ( blockComment ) 
 - & & ! areSameLevelIndented ( blockComment , prevStatement , nextStatement ) ) { 
 - 
 + & & nextStatement . getType ( ) ! = TokenTypes . RCURLY 
 + & & ! isTrailingBlockComment ( blockComment ) 
 + & & ! areSameLevelIndented ( blockComment , prevStatement , nextStatement ) ) { 
 log ( blockComment . getLineNo ( ) , MSG _ KEY _ BLOCK , nextStatement . getLineNo ( ) , 
 blockComment . getColumnNo ( ) , nextStatement . getColumnNo ( ) ) ; 
 }
