BLEU SCORE: 0.018738883683389617

TEST MSG: doc : Indentation property description become worded in the same way
GENERATED MSG: Clean up on related tools .

TEST DIFF (one line): diff - - git a / src / xdocs / config _ misc . xml b / src / xdocs / config _ misc . xml <nl> index 0b9acf0 . . 4914d3d 100755 <nl> - - - a / src / xdocs / config _ misc . xml <nl> + + + b / src / xdocs / config _ misc . xml <nl> @ @ - 1006 , 19 + 1006 , 19 @ @ String unitAbbrev = " \ u03bc \ u03bc \ u03bc " ; <nl> < / tr > <nl> < tr > <nl> < td > basicOffset < / td > <nl> - < td > how many spaces to use for new indentation level < / td > <nl> + < td > how far new indentation level should be indented when on the next line < / td > <nl> < td > < a href = " property _ types . html # integer " > Integer < / a > < / td > <nl> < td > 4 < / td > <nl> < / tr > <nl> < tr > <nl> < td > braceAdjustment < / td > <nl> - < td > how far braces should be indented when on the next line < / td > <nl> + < td > how far a braces should be indented when on the next line < / td > <nl> < td > < a href = " property _ types . html # integer " > Integer < / a > < / td > <nl> < td > 0 < / td > <nl> < / tr > <nl> < tr > <nl> < td > caseIndent < / td > <nl> - < td > how much to indent a case label < / td > <nl> + < td > how far a case label should be indented when on next line < / td > <nl> < td > < a href = " property _ types . html # integer " > Integer < / a > < / td > <nl> < td > 4 < / td > <nl> < / tr > <nl> @ @ - 1030 , 7 + 1030 , 7 @ @ String unitAbbrev = " \ u03bc \ u03bc \ u03bc " ; <nl> < / tr > <nl> < tr > <nl> < td > arrayInitIndent < / td > <nl> - < td > how much to indent an array initialisation when on next line < / td > <nl> + < td > how far an array initialisation should be indented when on next line < / td > <nl> < td > < a href = " property _ types . html # integer " > Integer < / a > < / td > <nl> < td > 4 < / td > <nl> < / tr > <nl> @ @ - 1042 , 8 + 1042 , 8 @ @ String unitAbbrev = " \ u03bc \ u03bc \ u03bc " ; <nl> < / tr > <nl> < tr > <nl> < td > forceStrictCondition < / td > <nl> - < td > force strict condition in line wrapping case . If value is true , line wrap indent <nl> - have to be same as lineWrappingIndentation parameter < / td > <nl> + < td > force strict indent level in line wrapping case . If value is true , line wrap indent <nl> + have to be same as lineWrappingIndentation parameter . If value is false , line wrap indent could be bigger on any value user would like . < / td > <nl> < td > < a href = " property _ types . html # boolean " > Boolean < / a > < / td > <nl> < td > false < / td > <nl> < / tr >
NEAREST DIFF (one line): diff - - git a / checkstyle _ checks . xml b / checkstyle _ checks . xml <nl> index 1cdf361 . . df878ad 100755 <nl> - - - a / checkstyle _ checks . xml <nl> + + + b / checkstyle _ checks . xml <nl> @ @ - 189 , 6 + 189 , 7 @ @ <nl> < module name = " ArrayTrailingComma " / > <nl> < module name = " FinalLocalVariable " / > <nl> < module name = " EqualsAvoidNull " / > <nl> + < module name = " ParameterAssignment " / > <nl> <nl> < ! - - Generates quite a few errors - - > <nl> < module name = " CyclomaticComplexity " > <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / Checker . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / Checker . java <nl> index eaa79f2 . . f99541e 100755 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / Checker . java <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / Checker . java <nl> @ @ - 246 , 19 + 246 , 19 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> { <nl> / / Prepare to start <nl> fireAuditStarted ( ) ; <nl> - for ( FileSetCheck fsc : mFileSetChecks ) { <nl> + for ( final FileSetCheck fsc : mFileSetChecks ) { <nl> fsc . beginProcessing ( mCharset ) ; <nl> } <nl> <nl> / / Process each file <nl> - for ( File f : aFiles ) { <nl> + for ( final File f : aFiles ) { <nl> final String fileName = f . getAbsolutePath ( ) ; <nl> fireFileStarted ( fileName ) ; <nl> final TreeSet < LocalizedMessage > fileMessages = Sets . newTreeSet ( ) ; <nl> try { <nl> final FileText theText = new FileText ( f . getAbsoluteFile ( ) , <nl> mCharset ) ; <nl> - for ( FileSetCheck fsc : mFileSetChecks ) { <nl> + for ( final FileSetCheck fsc : mFileSetChecks ) { <nl> fileMessages . addAll ( fsc . process ( f , theText ) ) ; <nl> } <nl> } <nl> @ @ - 281 , 7 + 281 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> } <nl> <nl> / / Finish up <nl> - for ( FileSetCheck fsc : mFileSetChecks ) { <nl> + for ( final FileSetCheck fsc : mFileSetChecks ) { <nl> / / They may also log ! ! ! <nl> fsc . finishProcessing ( ) ; <nl> fsc . destroy ( ) ; <nl> @ @ - 334 , 26 + 334 , 24 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> Locale . US ) ; <nl> final boolean onNetWare = ( osName . indexOf ( " netware " ) > - 1 ) ; <nl> <nl> - final String orig = aPath ; <nl> - <nl> - aPath = aPath . replace ( ' / ' , File . separatorChar ) . replace ( ' \ \ ' , <nl> - File . separatorChar ) ; <nl> + String path = aPath . replace ( ' / ' , File . separatorChar ) . replace ( ' \ \ ' , <nl> + File . separatorChar ) ; <nl> <nl> / / make sure we are dealing with an absolute path <nl> - final int colon = aPath . indexOf ( " : " ) ; <nl> + final int colon = path . indexOf ( " : " ) ; <nl> <nl> if ( ! onNetWare ) { <nl> - if ( ! aPath . startsWith ( File . separator ) <nl> - & & ! ( ( aPath . length ( ) > = 2 ) <nl> - & & Character . isLetter ( aPath . charAt ( 0 ) ) & & ( colon = = 1 ) ) ) <nl> + if ( ! path . startsWith ( File . separator ) <nl> + & & ! ( ( path . length ( ) > = 2 ) <nl> + & & Character . isLetter ( path . charAt ( 0 ) ) & & ( colon = = 1 ) ) ) <nl> { <nl> - final String msg = aPath + " is not an absolute path " ; <nl> + final String msg = path + " is not an absolute path " ; <nl> throw new IllegalArgumentException ( msg ) ; <nl> } <nl> } <nl> else { <nl> - if ( ! aPath . startsWith ( File . separator ) & & ( colon = = - 1 ) ) { <nl> - final String msg = aPath + " is not an absolute path " ; <nl> + if ( ! path . startsWith ( File . separator ) & & ( colon = = - 1 ) ) { <nl> + final String msg = path + " is not an absolute path " ; <nl> throw new IllegalArgumentException ( msg ) ; <nl> } <nl> } <nl> @ @ - 361 , 20 + 359 , 20 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> boolean dosWithDrive = false ; <nl> String root = null ; <nl> / / Eliminate consecutive slashes after the drive spec <nl> - if ( ( ! onNetWare & & ( aPath . length ( ) > = 2 ) <nl> - & & Character . isLetter ( aPath . charAt ( 0 ) ) & & ( aPath . charAt ( 1 ) = = ' : ' ) ) <nl> + if ( ( ! onNetWare & & ( path . length ( ) > = 2 ) <nl> + & & Character . isLetter ( path . charAt ( 0 ) ) & & ( path . charAt ( 1 ) = = ' : ' ) ) <nl> | | ( onNetWare & & ( colon > - 1 ) ) ) <nl> { <nl> <nl> dosWithDrive = true ; <nl> <nl> - final char [ ] ca = aPath . replace ( ' / ' , ' \ \ ' ) . toCharArray ( ) ; <nl> + final char [ ] ca = path . replace ( ' / ' , ' \ \ ' ) . toCharArray ( ) ; <nl> final StringBuffer sbRoot = new StringBuffer ( ) ; <nl> for ( int i = 0 ; i < colon ; i + + ) { <nl> sbRoot . append ( Character . toUpperCase ( ca [ i ] ) ) ; <nl> } <nl> sbRoot . append ( ' : ' ) ; <nl> - if ( colon + 1 < aPath . length ( ) ) { <nl> + if ( colon + 1 < path . length ( ) ) { <nl> sbRoot . append ( File . separatorChar ) ; <nl> } <nl> root = sbRoot . toString ( ) ; <nl> @ @ - 387 , 28 + 385 , 28 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> sbPath . append ( ca [ i ] ) ; <nl> } <nl> } <nl> - aPath = sbPath . toString ( ) . replace ( ' \ \ ' , File . separatorChar ) ; <nl> + path = sbPath . toString ( ) . replace ( ' \ \ ' , File . separatorChar ) ; <nl> <nl> } <nl> else { <nl> - if ( aPath . length ( ) = = 1 ) { <nl> + if ( path . length ( ) = = 1 ) { <nl> root = File . separator ; <nl> - aPath = " " ; <nl> + path = " " ; <nl> } <nl> - else if ( aPath . charAt ( 1 ) = = File . separatorChar ) { <nl> + else if ( path . charAt ( 1 ) = = File . separatorChar ) { <nl> / / UNC drive <nl> root = File . separator + File . separator ; <nl> - aPath = aPath . substring ( 2 ) ; <nl> + path = path . substring ( 2 ) ; <nl> } <nl> else { <nl> root = File . separator ; <nl> - aPath = aPath . substring ( 1 ) ; <nl> + path = path . substring ( 1 ) ; <nl> } <nl> } <nl> <nl> final FastStack < String > s = FastStack . newInstance ( ) ; <nl> s . push ( root ) ; <nl> - final StringTokenizer tok = new StringTokenizer ( aPath , File . separator ) ; <nl> + final StringTokenizer tok = new StringTokenizer ( path , File . separator ) ; <nl> while ( tok . hasMoreTokens ( ) ) { <nl> final String thisToken = tok . nextToken ( ) ; <nl> if ( " . " . equals ( thisToken ) ) { <nl> @ @ - 417 , 7 + 415 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> else if ( " . . " . equals ( thisToken ) ) { <nl> if ( s . size ( ) < 2 ) { <nl> throw new IllegalArgumentException ( " Cannot resolve path " <nl> - + orig ) ; <nl> + + aPath ) ; <nl> } <nl> s . pop ( ) ; <nl> } <nl> @ @ - 436 , 11 + 434 , 11 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> sb . append ( s . peek ( i ) ) ; <nl> } <nl> <nl> - aPath = sb . toString ( ) ; <nl> + path = sb . toString ( ) ; <nl> if ( dosWithDrive ) { <nl> - aPath = aPath . replace ( ' / ' , ' \ \ ' ) ; <nl> + path = path . replace ( ' / ' , ' \ \ ' ) ; <nl> } <nl> - return aPath ; <nl> + return path ; <nl> } <nl> <nl> / * * @ return the base directory property used in unit - test . * / <nl> @ @ - 453 , 7 + 451 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> protected void fireAuditStarted ( ) <nl> { <nl> final AuditEvent evt = new AuditEvent ( this ) ; <nl> - for ( AuditListener listener : mListeners ) { <nl> + for ( final AuditListener listener : mListeners ) { <nl> listener . auditStarted ( evt ) ; <nl> } <nl> } <nl> @ @ - 462 , 7 + 460 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> protected void fireAuditFinished ( ) <nl> { <nl> final AuditEvent evt = new AuditEvent ( this ) ; <nl> - for ( AuditListener listener : mListeners ) { <nl> + for ( final AuditListener listener : mListeners ) { <nl> listener . auditFinished ( evt ) ; <nl> } <nl> } <nl> @ @ - 477 , 7 + 475 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> { <nl> final String stripped = getStrippedFileName ( aFileName ) ; <nl> final AuditEvent evt = new AuditEvent ( this , stripped ) ; <nl> - for ( AuditListener listener : mListeners ) { <nl> + for ( final AuditListener listener : mListeners ) { <nl> listener . fileStarted ( evt ) ; <nl> } <nl> } <nl> @ @ - 492 , 7 + 490 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> { <nl> final String stripped = getStrippedFileName ( aFileName ) ; <nl> final AuditEvent evt = new AuditEvent ( this , stripped ) ; <nl> - for ( AuditListener listener : mListeners ) { <nl> + for ( final AuditListener listener : mListeners ) { <nl> listener . fileFinished ( evt ) ; <nl> } <nl> } <nl> @ @ - 506 , 10 + 504 , 10 @ @ public class Checker extends AutomaticBean implements MessageDispatcher <nl> public void fireErrors ( String aFileName , TreeSet < LocalizedMessage > aErrors ) <nl> { <nl> final String stripped = getStrippedFileName ( aFileName ) ; <nl> - for ( LocalizedMessage element : aErrors ) { <nl> + for ( final LocalizedMessage element : aErrors ) { <nl> final AuditEvent evt = new AuditEvent ( this , stripped , element ) ; <nl> if ( mFilters . accept ( evt ) ) { <nl> - for ( AuditListener listener : mListeners ) { <nl> + for ( final AuditListener listener : mListeners ) { <nl> listener . addError ( evt ) ; <nl> } <nl> } <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / CheckUtils . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / CheckUtils . java <nl> index ba0bae1 . . 3ba3b8b 100755 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / CheckUtils . java <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / CheckUtils . java <nl> @ @ - 151 , 32 + 151 , 33 @ @ public final class CheckUtils <nl> * / <nl> public static double parseDouble ( String aText , int aType ) <nl> { <nl> + String txt = aText ; <nl> double result = 0 ; <nl> switch ( aType ) { <nl> case TokenTypes . NUM _ FLOAT : <nl> case TokenTypes . NUM _ DOUBLE : <nl> - result = Double . parseDouble ( aText ) ; <nl> + result = Double . parseDouble ( txt ) ; <nl> break ; <nl> case TokenTypes . NUM _ INT : <nl> case TokenTypes . NUM _ LONG : <nl> int radix = BASE _ 10 ; <nl> - if ( aText . startsWith ( " 0x " ) | | aText . startsWith ( " 0X " ) ) { <nl> + if ( txt . startsWith ( " 0x " ) | | txt . startsWith ( " 0X " ) ) { <nl> radix = BASE _ 16 ; <nl> - aText = aText . substring ( 2 ) ; <nl> + txt = txt . substring ( 2 ) ; <nl> } <nl> - else if ( aText . charAt ( 0 ) = = ' 0 ' ) { <nl> + else if ( txt . charAt ( 0 ) = = ' 0 ' ) { <nl> radix = BASE _ 8 ; <nl> - aText = aText . substring ( 1 ) ; <nl> + txt = txt . substring ( 1 ) ; <nl> } <nl> - if ( ( aText . endsWith ( " L " ) ) | | ( aText . endsWith ( " l " ) ) ) { <nl> - aText = aText . substring ( 0 , aText . length ( ) - 1 ) ; <nl> + if ( ( txt . endsWith ( " L " ) ) | | ( txt . endsWith ( " l " ) ) ) { <nl> + txt = txt . substring ( 0 , txt . length ( ) - 1 ) ; <nl> } <nl> - if ( aText . length ( ) > 0 ) { <nl> + if ( txt . length ( ) > 0 ) { <nl> if ( aType = = TokenTypes . NUM _ INT ) { <nl> - result = parseInt ( aText , radix ) ; <nl> + result = parseInt ( txt , radix ) ; <nl> } <nl> else { <nl> - result = parseLong ( aText , radix ) ; <nl> + result = parseLong ( txt , radix ) ; <nl> } <nl> } <nl> break ; <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / coding / IllegalTokenTextCheck . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / coding / IllegalTokenTextCheck . java <nl> index ba04b9f . . 48b40bd 100755 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / coding / IllegalTokenTextCheck . java <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / coding / IllegalTokenTextCheck . java <nl> @ @ - 84 , 7 + 84 , 7 @ @ public class IllegalTokenTextCheck <nl> final Set < String > tokenNames = getTokenNames ( ) ; <nl> final int [ ] result = new int [ tokenNames . size ( ) ] ; <nl> int i = 0 ; <nl> - for ( String name : tokenNames ) { <nl> + for ( final String name : tokenNames ) { <nl> result [ i ] = TokenTypes . getTokenId ( name ) ; <nl> i + + ; <nl> } <nl> @ @ - 115 , 10 + 115 , 7 @ @ public class IllegalTokenTextCheck <nl> * / <nl> public void setMessage ( String aMessage ) <nl> { <nl> - if ( aMessage = = null ) { <nl> - aMessage = " " ; <nl> - } <nl> - mMessage = aMessage ; <nl> + mMessage = ( null = = aMessage ) ? " " : aMessage ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / ExpressionHandler . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / ExpressionHandler . java <nl> index c155271 . . 16ee2bb 100755 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / ExpressionHandler . java <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / ExpressionHandler . java <nl> @ @ - 228 , 15 + 228 , 16 @ @ public abstract class ExpressionHandler <nl> * @ param aIndentLevel the required indent level <nl> * / <nl> protected final void checkLinesIndent ( int aStartLine , int aEndLine , <nl> - IndentLevel aIndentLevel ) <nl> + IndentLevel aIndentLevel ) <nl> { <nl> / / check first line <nl> checkSingleLine ( aStartLine , aIndentLevel ) ; <nl> <nl> / / check following lines <nl> - aIndentLevel = new IndentLevel ( aIndentLevel , getBasicOffset ( ) ) ; <nl> + final IndentLevel offsetLevel = <nl> + new IndentLevel ( aIndentLevel , getBasicOffset ( ) ) ; <nl> for ( int i = aStartLine + 1 ; i < = aEndLine ; i + + ) { <nl> - checkSingleLine ( i , aIndentLevel ) ; <nl> + checkSingleLine ( i , offsetLevel ) ; <nl> } <nl> } <nl> <nl> @ @ - 289 , 10 + 290 , 11 @ @ public abstract class ExpressionHandler <nl> / / TODO : shouldIncreaseIndent ( ) is a hack , should be removed <nl> / / after complete rewriting of checkExpressionSubtree ( ) <nl> <nl> + IndentLevel theLevel = aIndentLevel ; <nl> if ( aFirstLineMatches <nl> | | ( ( aFirstLine > mMainAst . getLineNo ( ) ) & & shouldIncreaseIndent ( ) ) ) <nl> { <nl> - aIndentLevel = new IndentLevel ( aIndentLevel , getBasicOffset ( ) ) ; <nl> + theLevel = new IndentLevel ( aIndentLevel , getBasicOffset ( ) ) ; <nl> } <nl> <nl> / / check following lines <nl> @ @ - 303 , 7 + 305 , 7 @ @ public abstract class ExpressionHandler <nl> / / checked by a child expression ) <nl> <nl> if ( col ! = null ) { <nl> - checkSingleLine ( i , col . intValue ( ) , aIndentLevel , false ) ; <nl> + checkSingleLine ( i , col . intValue ( ) , theLevel , false ) ; <nl> } <nl> } <nl> } <nl> @ @ - 439 , 10 + 441 , 10 @ @ public abstract class ExpressionHandler <nl> / / find line for this node <nl> / / TODO : getLineNo should probably not return < 0 , but it is for <nl> / / the interface methods . . . I should ask about this <nl> - <nl> + int realStart = aStartLine ; <nl> final int currLine = aTree . getLineNo ( ) ; <nl> - if ( currLine < aStartLine ) { <nl> - aStartLine = currLine ; <nl> + if ( currLine < realStart ) { <nl> + realStart = currLine ; <nl> } <nl> <nl> / / check children <nl> @ @ - 450 , 10 + 452 , 10 @ @ public abstract class ExpressionHandler <nl> node ! = null ; <nl> node = node . getNextSibling ( ) ) <nl> { <nl> - aStartLine = getFirstLine ( aStartLine , node ) ; <nl> + realStart = getFirstLine ( realStart , node ) ; <nl> } <nl> <nl> - return aStartLine ; <nl> + return realStart ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / HandlerFactory . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / HandlerFactory . java <nl> index 92efed4 . . 5075fe6 100755 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / HandlerFactory . java <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / HandlerFactory . java <nl> @ @ - 142 , 7 + 142 , 7 @ @ public class HandlerFactory <nl> final Set < Integer > typeSet = mTypeHandlers . keySet ( ) ; <nl> final int [ ] types = new int [ typeSet . size ( ) ] ; <nl> int index = 0 ; <nl> - for ( Integer val : typeSet ) { <nl> + for ( final Integer val : typeSet ) { <nl> types [ index + + ] = val ; <nl> } <nl> <nl> @ @ - 215 , 15 + 215 , 16 @ @ public class HandlerFactory <nl> ExpressionHandler createMethodCallHandler ( IndentationCheck aIndentCheck , <nl> DetailAST aAst , ExpressionHandler aParent ) <nl> { <nl> + ExpressionHandler theParent = aParent ; <nl> DetailAST ast = aAst . getFirstChild ( ) ; <nl> while ( ( ast ! = null ) & & ( ast . getType ( ) = = TokenTypes . DOT ) ) { <nl> ast = ast . getFirstChild ( ) ; <nl> } <nl> if ( ( ast ! = null ) & & isHandledType ( ast . getType ( ) ) ) { <nl> - aParent = getHandler ( aIndentCheck , ast , aParent ) ; <nl> - mCreatedHandlers . put ( ast , aParent ) ; <nl> + theParent = getHandler ( aIndentCheck , ast , theParent ) ; <nl> + mCreatedHandlers . put ( ast , theParent ) ; <nl> } <nl> - return new MethodCallHandler ( aIndentCheck , aAst , aParent ) ; <nl> + return new MethodCallHandler ( aIndentCheck , aAst , theParent ) ; <nl> } <nl> <nl> / * * Clears cache of created handlers . * / <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / whitespace / ParenPadCheck . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / whitespace / ParenPadCheck . java <nl> index 9f013fb . . da47e4f 100755 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / whitespace / ParenPadCheck . java <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / whitespace / ParenPadCheck . java <nl> @ @ - 78 , 25 + 78 , 26 @ @ public class ParenPadCheck extends AbstractParenPadCheck <nl> @ Override <nl> public void visitToken ( DetailAST aAST ) <nl> { <nl> + DetailAST theAst = aAST ; <nl> / / Strange logic in this method to guard against checking RPAREN tokens <nl> / / that are associated with a TYPECAST token . <nl> - if ( aAST . getType ( ) ! = TokenTypes . RPAREN ) { <nl> - if ( ( aAST . getType ( ) = = TokenTypes . CTOR _ CALL ) <nl> - | | ( aAST . getType ( ) = = TokenTypes . SUPER _ CTOR _ CALL ) ) <nl> + if ( theAst . getType ( ) ! = TokenTypes . RPAREN ) { <nl> + if ( ( theAst . getType ( ) = = TokenTypes . CTOR _ CALL ) <nl> + | | ( theAst . getType ( ) = = TokenTypes . SUPER _ CTOR _ CALL ) ) <nl> { <nl> - aAST = aAST . getFirstChild ( ) ; <nl> + theAst = theAst . getFirstChild ( ) ; <nl> } <nl> - if ( ! isPreceedsEmptyForInit ( aAST ) ) { <nl> - processLeft ( aAST ) ; <nl> + if ( ! isPreceedsEmptyForInit ( theAst ) ) { <nl> + processLeft ( theAst ) ; <nl> } <nl> } <nl> - else if ( ( aAST . getParent ( ) = = null ) <nl> - | | ( aAST . getParent ( ) . getType ( ) ! = TokenTypes . TYPECAST ) <nl> - | | ( aAST . getParent ( ) . findFirstToken ( TokenTypes . RPAREN ) <nl> - ! = aAST ) ) <nl> + else if ( ( theAst . getParent ( ) = = null ) <nl> + | | ( theAst . getParent ( ) . getType ( ) ! = TokenTypes . TYPECAST ) <nl> + | | ( theAst . getParent ( ) . findFirstToken ( TokenTypes . RPAREN ) <nl> + ! = theAst ) ) <nl> { <nl> - if ( ! isFollowsEmptyForIterator ( aAST ) ) { <nl> - processRight ( aAST ) ; <nl> + if ( ! isFollowsEmptyForIterator ( theAst ) ) { <nl> + processRight ( theAst ) ; <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / src / xdocs / config _ misc . xml b / src / xdocs / config _ misc . xml 
 index 0b9acf0 . . 4914d3d 100755 
 - - - a / src / xdocs / config _ misc . xml 
 + + + b / src / xdocs / config _ misc . xml 
 @ @ - 1006 , 19 + 1006 , 19 @ @ String unitAbbrev = " \ u03bc \ u03bc \ u03bc " ; 
 < / tr > 
 < tr > 
 < td > basicOffset < / td > 
 - < td > how many spaces to use for new indentation level < / td > 
 + < td > how far new indentation level should be indented when on the next line < / td > 
 < td > < a href = " property _ types . html # integer " > Integer < / a > < / td > 
 < td > 4 < / td > 
 < / tr > 
 < tr > 
 < td > braceAdjustment < / td > 
 - < td > how far braces should be indented when on the next line < / td > 
 + < td > how far a braces should be indented when on the next line < / td > 
 < td > < a href = " property _ types . html # integer " > Integer < / a > < / td > 
 < td > 0 < / td > 
 < / tr > 
 < tr > 
 < td > caseIndent < / td > 
 - < td > how much to indent a case label < / td > 
 + < td > how far a case label should be indented when on next line < / td > 
 < td > < a href = " property _ types . html # integer " > Integer < / a > < / td > 
 < td > 4 < / td > 
 < / tr > 
 @ @ - 1030 , 7 + 1030 , 7 @ @ String unitAbbrev = " \ u03bc \ u03bc \ u03bc " ; 
 < / tr > 
 < tr > 
 < td > arrayInitIndent < / td > 
 - < td > how much to indent an array initialisation when on next line < / td > 
 + < td > how far an array initialisation should be indented when on next line < / td > 
 < td > < a href = " property _ types . html # integer " > Integer < / a > < / td > 
 < td > 4 < / td > 
 < / tr > 
 @ @ - 1042 , 8 + 1042 , 8 @ @ String unitAbbrev = " \ u03bc \ u03bc \ u03bc " ; 
 < / tr > 
 < tr > 
 < td > forceStrictCondition < / td > 
 - < td > force strict condition in line wrapping case . If value is true , line wrap indent 
 - have to be same as lineWrappingIndentation parameter < / td > 
 + < td > force strict indent level in line wrapping case . If value is true , line wrap indent 
 + have to be same as lineWrappingIndentation parameter . If value is false , line wrap indent could be bigger on any value user would like . < / td > 
 < td > < a href = " property _ types . html # boolean " > Boolean < / a > < / td > 
 < td > false < / td > 
 < / tr >

NEAREST DIFF:
diff - - git a / checkstyle _ checks . xml b / checkstyle _ checks . xml 
 index 1cdf361 . . df878ad 100755 
 - - - a / checkstyle _ checks . xml 
 + + + b / checkstyle _ checks . xml 
 @ @ - 189 , 6 + 189 , 7 @ @ 
 < module name = " ArrayTrailingComma " / > 
 < module name = " FinalLocalVariable " / > 
 < module name = " EqualsAvoidNull " / > 
 + < module name = " ParameterAssignment " / > 
 
 < ! - - Generates quite a few errors - - > 
 < module name = " CyclomaticComplexity " > 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / Checker . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / Checker . java 
 index eaa79f2 . . f99541e 100755 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / Checker . java 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / Checker . java 
 @ @ - 246 , 19 + 246 , 19 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 { 
 / / Prepare to start 
 fireAuditStarted ( ) ; 
 - for ( FileSetCheck fsc : mFileSetChecks ) { 
 + for ( final FileSetCheck fsc : mFileSetChecks ) { 
 fsc . beginProcessing ( mCharset ) ; 
 } 
 
 / / Process each file 
 - for ( File f : aFiles ) { 
 + for ( final File f : aFiles ) { 
 final String fileName = f . getAbsolutePath ( ) ; 
 fireFileStarted ( fileName ) ; 
 final TreeSet < LocalizedMessage > fileMessages = Sets . newTreeSet ( ) ; 
 try { 
 final FileText theText = new FileText ( f . getAbsoluteFile ( ) , 
 mCharset ) ; 
 - for ( FileSetCheck fsc : mFileSetChecks ) { 
 + for ( final FileSetCheck fsc : mFileSetChecks ) { 
 fileMessages . addAll ( fsc . process ( f , theText ) ) ; 
 } 
 } 
 @ @ - 281 , 7 + 281 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 } 
 
 / / Finish up 
 - for ( FileSetCheck fsc : mFileSetChecks ) { 
 + for ( final FileSetCheck fsc : mFileSetChecks ) { 
 / / They may also log ! ! ! 
 fsc . finishProcessing ( ) ; 
 fsc . destroy ( ) ; 
 @ @ - 334 , 26 + 334 , 24 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 Locale . US ) ; 
 final boolean onNetWare = ( osName . indexOf ( " netware " ) > - 1 ) ; 
 
 - final String orig = aPath ; 
 - 
 - aPath = aPath . replace ( ' / ' , File . separatorChar ) . replace ( ' \ \ ' , 
 - File . separatorChar ) ; 
 + String path = aPath . replace ( ' / ' , File . separatorChar ) . replace ( ' \ \ ' , 
 + File . separatorChar ) ; 
 
 / / make sure we are dealing with an absolute path 
 - final int colon = aPath . indexOf ( " : " ) ; 
 + final int colon = path . indexOf ( " : " ) ; 
 
 if ( ! onNetWare ) { 
 - if ( ! aPath . startsWith ( File . separator ) 
 - & & ! ( ( aPath . length ( ) > = 2 ) 
 - & & Character . isLetter ( aPath . charAt ( 0 ) ) & & ( colon = = 1 ) ) ) 
 + if ( ! path . startsWith ( File . separator ) 
 + & & ! ( ( path . length ( ) > = 2 ) 
 + & & Character . isLetter ( path . charAt ( 0 ) ) & & ( colon = = 1 ) ) ) 
 { 
 - final String msg = aPath + " is not an absolute path " ; 
 + final String msg = path + " is not an absolute path " ; 
 throw new IllegalArgumentException ( msg ) ; 
 } 
 } 
 else { 
 - if ( ! aPath . startsWith ( File . separator ) & & ( colon = = - 1 ) ) { 
 - final String msg = aPath + " is not an absolute path " ; 
 + if ( ! path . startsWith ( File . separator ) & & ( colon = = - 1 ) ) { 
 + final String msg = path + " is not an absolute path " ; 
 throw new IllegalArgumentException ( msg ) ; 
 } 
 } 
 @ @ - 361 , 20 + 359 , 20 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 boolean dosWithDrive = false ; 
 String root = null ; 
 / / Eliminate consecutive slashes after the drive spec 
 - if ( ( ! onNetWare & & ( aPath . length ( ) > = 2 ) 
 - & & Character . isLetter ( aPath . charAt ( 0 ) ) & & ( aPath . charAt ( 1 ) = = ' : ' ) ) 
 + if ( ( ! onNetWare & & ( path . length ( ) > = 2 ) 
 + & & Character . isLetter ( path . charAt ( 0 ) ) & & ( path . charAt ( 1 ) = = ' : ' ) ) 
 | | ( onNetWare & & ( colon > - 1 ) ) ) 
 { 
 
 dosWithDrive = true ; 
 
 - final char [ ] ca = aPath . replace ( ' / ' , ' \ \ ' ) . toCharArray ( ) ; 
 + final char [ ] ca = path . replace ( ' / ' , ' \ \ ' ) . toCharArray ( ) ; 
 final StringBuffer sbRoot = new StringBuffer ( ) ; 
 for ( int i = 0 ; i < colon ; i + + ) { 
 sbRoot . append ( Character . toUpperCase ( ca [ i ] ) ) ; 
 } 
 sbRoot . append ( ' : ' ) ; 
 - if ( colon + 1 < aPath . length ( ) ) { 
 + if ( colon + 1 < path . length ( ) ) { 
 sbRoot . append ( File . separatorChar ) ; 
 } 
 root = sbRoot . toString ( ) ; 
 @ @ - 387 , 28 + 385 , 28 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 sbPath . append ( ca [ i ] ) ; 
 } 
 } 
 - aPath = sbPath . toString ( ) . replace ( ' \ \ ' , File . separatorChar ) ; 
 + path = sbPath . toString ( ) . replace ( ' \ \ ' , File . separatorChar ) ; 
 
 } 
 else { 
 - if ( aPath . length ( ) = = 1 ) { 
 + if ( path . length ( ) = = 1 ) { 
 root = File . separator ; 
 - aPath = " " ; 
 + path = " " ; 
 } 
 - else if ( aPath . charAt ( 1 ) = = File . separatorChar ) { 
 + else if ( path . charAt ( 1 ) = = File . separatorChar ) { 
 / / UNC drive 
 root = File . separator + File . separator ; 
 - aPath = aPath . substring ( 2 ) ; 
 + path = path . substring ( 2 ) ; 
 } 
 else { 
 root = File . separator ; 
 - aPath = aPath . substring ( 1 ) ; 
 + path = path . substring ( 1 ) ; 
 } 
 } 
 
 final FastStack < String > s = FastStack . newInstance ( ) ; 
 s . push ( root ) ; 
 - final StringTokenizer tok = new StringTokenizer ( aPath , File . separator ) ; 
 + final StringTokenizer tok = new StringTokenizer ( path , File . separator ) ; 
 while ( tok . hasMoreTokens ( ) ) { 
 final String thisToken = tok . nextToken ( ) ; 
 if ( " . " . equals ( thisToken ) ) { 
 @ @ - 417 , 7 + 415 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 else if ( " . . " . equals ( thisToken ) ) { 
 if ( s . size ( ) < 2 ) { 
 throw new IllegalArgumentException ( " Cannot resolve path " 
 - + orig ) ; 
 + + aPath ) ; 
 } 
 s . pop ( ) ; 
 } 
 @ @ - 436 , 11 + 434 , 11 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 sb . append ( s . peek ( i ) ) ; 
 } 
 
 - aPath = sb . toString ( ) ; 
 + path = sb . toString ( ) ; 
 if ( dosWithDrive ) { 
 - aPath = aPath . replace ( ' / ' , ' \ \ ' ) ; 
 + path = path . replace ( ' / ' , ' \ \ ' ) ; 
 } 
 - return aPath ; 
 + return path ; 
 } 
 
 / * * @ return the base directory property used in unit - test . * / 
 @ @ - 453 , 7 + 451 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 protected void fireAuditStarted ( ) 
 { 
 final AuditEvent evt = new AuditEvent ( this ) ; 
 - for ( AuditListener listener : mListeners ) { 
 + for ( final AuditListener listener : mListeners ) { 
 listener . auditStarted ( evt ) ; 
 } 
 } 
 @ @ - 462 , 7 + 460 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 protected void fireAuditFinished ( ) 
 { 
 final AuditEvent evt = new AuditEvent ( this ) ; 
 - for ( AuditListener listener : mListeners ) { 
 + for ( final AuditListener listener : mListeners ) { 
 listener . auditFinished ( evt ) ; 
 } 
 } 
 @ @ - 477 , 7 + 475 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 { 
 final String stripped = getStrippedFileName ( aFileName ) ; 
 final AuditEvent evt = new AuditEvent ( this , stripped ) ; 
 - for ( AuditListener listener : mListeners ) { 
 + for ( final AuditListener listener : mListeners ) { 
 listener . fileStarted ( evt ) ; 
 } 
 } 
 @ @ - 492 , 7 + 490 , 7 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 { 
 final String stripped = getStrippedFileName ( aFileName ) ; 
 final AuditEvent evt = new AuditEvent ( this , stripped ) ; 
 - for ( AuditListener listener : mListeners ) { 
 + for ( final AuditListener listener : mListeners ) { 
 listener . fileFinished ( evt ) ; 
 } 
 } 
 @ @ - 506 , 10 + 504 , 10 @ @ public class Checker extends AutomaticBean implements MessageDispatcher 
 public void fireErrors ( String aFileName , TreeSet < LocalizedMessage > aErrors ) 
 { 
 final String stripped = getStrippedFileName ( aFileName ) ; 
 - for ( LocalizedMessage element : aErrors ) { 
 + for ( final LocalizedMessage element : aErrors ) { 
 final AuditEvent evt = new AuditEvent ( this , stripped , element ) ; 
 if ( mFilters . accept ( evt ) ) { 
 - for ( AuditListener listener : mListeners ) { 
 + for ( final AuditListener listener : mListeners ) { 
 listener . addError ( evt ) ; 
 } 
 } 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / CheckUtils . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / CheckUtils . java 
 index ba0bae1 . . 3ba3b8b 100755 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / CheckUtils . java 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / CheckUtils . java 
 @ @ - 151 , 32 + 151 , 33 @ @ public final class CheckUtils 
 * / 
 public static double parseDouble ( String aText , int aType ) 
 { 
 + String txt = aText ; 
 double result = 0 ; 
 switch ( aType ) { 
 case TokenTypes . NUM _ FLOAT : 
 case TokenTypes . NUM _ DOUBLE : 
 - result = Double . parseDouble ( aText ) ; 
 + result = Double . parseDouble ( txt ) ; 
 break ; 
 case TokenTypes . NUM _ INT : 
 case TokenTypes . NUM _ LONG : 
 int radix = BASE _ 10 ; 
 - if ( aText . startsWith ( " 0x " ) | | aText . startsWith ( " 0X " ) ) { 
 + if ( txt . startsWith ( " 0x " ) | | txt . startsWith ( " 0X " ) ) { 
 radix = BASE _ 16 ; 
 - aText = aText . substring ( 2 ) ; 
 + txt = txt . substring ( 2 ) ; 
 } 
 - else if ( aText . charAt ( 0 ) = = ' 0 ' ) { 
 + else if ( txt . charAt ( 0 ) = = ' 0 ' ) { 
 radix = BASE _ 8 ; 
 - aText = aText . substring ( 1 ) ; 
 + txt = txt . substring ( 1 ) ; 
 } 
 - if ( ( aText . endsWith ( " L " ) ) | | ( aText . endsWith ( " l " ) ) ) { 
 - aText = aText . substring ( 0 , aText . length ( ) - 1 ) ; 
 + if ( ( txt . endsWith ( " L " ) ) | | ( txt . endsWith ( " l " ) ) ) { 
 + txt = txt . substring ( 0 , txt . length ( ) - 1 ) ; 
 } 
 - if ( aText . length ( ) > 0 ) { 
 + if ( txt . length ( ) > 0 ) { 
 if ( aType = = TokenTypes . NUM _ INT ) { 
 - result = parseInt ( aText , radix ) ; 
 + result = parseInt ( txt , radix ) ; 
 } 
 else { 
 - result = parseLong ( aText , radix ) ; 
 + result = parseLong ( txt , radix ) ; 
 } 
 } 
 break ; 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / coding / IllegalTokenTextCheck . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / coding / IllegalTokenTextCheck . java 
 index ba04b9f . . 48b40bd 100755 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / coding / IllegalTokenTextCheck . java 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / coding / IllegalTokenTextCheck . java 
 @ @ - 84 , 7 + 84 , 7 @ @ public class IllegalTokenTextCheck 
 final Set < String > tokenNames = getTokenNames ( ) ; 
 final int [ ] result = new int [ tokenNames . size ( ) ] ; 
 int i = 0 ; 
 - for ( String name : tokenNames ) { 
 + for ( final String name : tokenNames ) { 
 result [ i ] = TokenTypes . getTokenId ( name ) ; 
 i + + ; 
 } 
 @ @ - 115 , 10 + 115 , 7 @ @ public class IllegalTokenTextCheck 
 * / 
 public void setMessage ( String aMessage ) 
 { 
 - if ( aMessage = = null ) { 
 - aMessage = " " ; 
 - } 
 - mMessage = aMessage ; 
 + mMessage = ( null = = aMessage ) ? " " : aMessage ; 
 } 
 
 / * * 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / ExpressionHandler . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / ExpressionHandler . java 
 index c155271 . . 16ee2bb 100755 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / ExpressionHandler . java 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / ExpressionHandler . java 
 @ @ - 228 , 15 + 228 , 16 @ @ public abstract class ExpressionHandler 
 * @ param aIndentLevel the required indent level 
 * / 
 protected final void checkLinesIndent ( int aStartLine , int aEndLine , 
 - IndentLevel aIndentLevel ) 
 + IndentLevel aIndentLevel ) 
 { 
 / / check first line 
 checkSingleLine ( aStartLine , aIndentLevel ) ; 
 
 / / check following lines 
 - aIndentLevel = new IndentLevel ( aIndentLevel , getBasicOffset ( ) ) ; 
 + final IndentLevel offsetLevel = 
 + new IndentLevel ( aIndentLevel , getBasicOffset ( ) ) ; 
 for ( int i = aStartLine + 1 ; i < = aEndLine ; i + + ) { 
 - checkSingleLine ( i , aIndentLevel ) ; 
 + checkSingleLine ( i , offsetLevel ) ; 
 } 
 } 
 
 @ @ - 289 , 10 + 290 , 11 @ @ public abstract class ExpressionHandler 
 / / TODO : shouldIncreaseIndent ( ) is a hack , should be removed 
 / / after complete rewriting of checkExpressionSubtree ( ) 
 
 + IndentLevel theLevel = aIndentLevel ; 
 if ( aFirstLineMatches 
 | | ( ( aFirstLine > mMainAst . getLineNo ( ) ) & & shouldIncreaseIndent ( ) ) ) 
 { 
 - aIndentLevel = new IndentLevel ( aIndentLevel , getBasicOffset ( ) ) ; 
 + theLevel = new IndentLevel ( aIndentLevel , getBasicOffset ( ) ) ; 
 } 
 
 / / check following lines 
 @ @ - 303 , 7 + 305 , 7 @ @ public abstract class ExpressionHandler 
 / / checked by a child expression ) 
 
 if ( col ! = null ) { 
 - checkSingleLine ( i , col . intValue ( ) , aIndentLevel , false ) ; 
 + checkSingleLine ( i , col . intValue ( ) , theLevel , false ) ; 
 } 
 } 
 } 
 @ @ - 439 , 10 + 441 , 10 @ @ public abstract class ExpressionHandler 
 / / find line for this node 
 / / TODO : getLineNo should probably not return < 0 , but it is for 
 / / the interface methods . . . I should ask about this 
 - 
 + int realStart = aStartLine ; 
 final int currLine = aTree . getLineNo ( ) ; 
 - if ( currLine < aStartLine ) { 
 - aStartLine = currLine ; 
 + if ( currLine < realStart ) { 
 + realStart = currLine ; 
 } 
 
 / / check children 
 @ @ - 450 , 10 + 452 , 10 @ @ public abstract class ExpressionHandler 
 node ! = null ; 
 node = node . getNextSibling ( ) ) 
 { 
 - aStartLine = getFirstLine ( aStartLine , node ) ; 
 + realStart = getFirstLine ( realStart , node ) ; 
 } 
 
 - return aStartLine ; 
 + return realStart ; 
 } 
 
 / * * 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / HandlerFactory . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / HandlerFactory . java 
 index 92efed4 . . 5075fe6 100755 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / HandlerFactory . java 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / indentation / HandlerFactory . java 
 @ @ - 142 , 7 + 142 , 7 @ @ public class HandlerFactory 
 final Set < Integer > typeSet = mTypeHandlers . keySet ( ) ; 
 final int [ ] types = new int [ typeSet . size ( ) ] ; 
 int index = 0 ; 
 - for ( Integer val : typeSet ) { 
 + for ( final Integer val : typeSet ) { 
 types [ index + + ] = val ; 
 } 
 
 @ @ - 215 , 15 + 215 , 16 @ @ public class HandlerFactory 
 ExpressionHandler createMethodCallHandler ( IndentationCheck aIndentCheck , 
 DetailAST aAst , ExpressionHandler aParent ) 
 { 
 + ExpressionHandler theParent = aParent ; 
 DetailAST ast = aAst . getFirstChild ( ) ; 
 while ( ( ast ! = null ) & & ( ast . getType ( ) = = TokenTypes . DOT ) ) { 
 ast = ast . getFirstChild ( ) ; 
 } 
 if ( ( ast ! = null ) & & isHandledType ( ast . getType ( ) ) ) { 
 - aParent = getHandler ( aIndentCheck , ast , aParent ) ; 
 - mCreatedHandlers . put ( ast , aParent ) ; 
 + theParent = getHandler ( aIndentCheck , ast , theParent ) ; 
 + mCreatedHandlers . put ( ast , theParent ) ; 
 } 
 - return new MethodCallHandler ( aIndentCheck , aAst , aParent ) ; 
 + return new MethodCallHandler ( aIndentCheck , aAst , theParent ) ; 
 } 
 
 / * * Clears cache of created handlers . * / 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / whitespace / ParenPadCheck . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / whitespace / ParenPadCheck . java 
 index 9f013fb . . da47e4f 100755 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / whitespace / ParenPadCheck . java 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / checks / whitespace / ParenPadCheck . java 
 @ @ - 78 , 25 + 78 , 26 @ @ public class ParenPadCheck extends AbstractParenPadCheck 
 @ Override 
 public void visitToken ( DetailAST aAST ) 
 { 
 + DetailAST theAst = aAST ; 
 / / Strange logic in this method to guard against checking RPAREN tokens 
 / / that are associated with a TYPECAST token . 
 - if ( aAST . getType ( ) ! = TokenTypes . RPAREN ) { 
 - if ( ( aAST . getType ( ) = = TokenTypes . CTOR _ CALL ) 
 - | | ( aAST . getType ( ) = = TokenTypes . SUPER _ CTOR _ CALL ) ) 
 + if ( theAst . getType ( ) ! = TokenTypes . RPAREN ) { 
 + if ( ( theAst . getType ( ) = = TokenTypes . CTOR _ CALL ) 
 + | | ( theAst . getType ( ) = = TokenTypes . SUPER _ CTOR _ CALL ) ) 
 { 
 - aAST = aAST . getFirstChild ( ) ; 
 + theAst = theAst . getFirstChild ( ) ; 
 } 
 - if ( ! isPreceedsEmptyForInit ( aAST ) ) { 
 - processLeft ( aAST ) ; 
 + if ( ! isPreceedsEmptyForInit ( theAst ) ) { 
 + processLeft ( theAst ) ; 
 } 
 } 
 - else if ( ( aAST . getParent ( ) = = null ) 
 - | | ( aAST . getParent ( ) . getType ( ) ! = TokenTypes . TYPECAST ) 
 - | | ( aAST . getParent ( ) . findFirstToken ( TokenTypes . RPAREN ) 
 - ! = aAST ) ) 
 + else if ( ( theAst . getParent ( ) = = null ) 
 + | | ( theAst . getParent ( ) . getType ( ) ! = TokenTypes . TYPECAST ) 
 + | | ( theAst . getParent ( ) . findFirstToken ( TokenTypes . RPAREN ) 
 + ! = theAst ) ) 
 { 
 - if ( ! isFollowsEmptyForIterator ( aAST ) ) { 
 - processRight ( aAST ) ; 
 + if ( ! isFollowsEmptyForIterator ( theAst ) ) { 
 + processRight ( theAst ) ; 
 } 
 } 
 }
