BLEU SCORE: 0.009128462139364281

TEST MSG: Issue # 6586 : aligned javadoc / xdoc for NoClone
GENERATED MSG: New check NoClone for ensuring a class does not override the clone method from the Object class . Thanks to Travis Schneeberger for providing patch # 1947417 .

TEST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / NoCloneCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / NoCloneCheck . java <nl> index 794937c . . 0235c22 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / NoCloneCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / NoCloneCheck . java <nl> @ @ - 29 , 12 + 29 , 25 @ @ import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> * Checks that the clone method is not overridden from the <nl> * Object class . <nl> * < / p > <nl> - * <nl> - * < p > Rationale : The clone method relies on strange / hard to follow rules that <nl> - * do not work it all situations . Consequently , it is difficult to <nl> - * override correctly . Below are some of the rules / reasons why the clone <nl> - * method should be avoided . <nl> - * <nl> + * < p > <nl> + * This check is almost exactly the same as the { @ code NoFinalizerCheck } . <nl> + * < / p > <nl> + * < p > <nl> + * See <nl> + * < a href = " https : / / docs . oracle . com / en / java / javase / 11 / docs / api / java . base / java / lang / Object . html # clone ( ) " > <nl> + * Object . clone ( ) < / a > <nl> + * < / p > <nl> + * < p > <nl> + * Rationale : The clone method relies on strange , hard to follow rules that <nl> + * are difficult to get right and do not work in all situations . In some cases , <nl> + * either a copy constructor or a static factory method can be used instead of <nl> + * the clone method to return copies of an object . For more information on rules <nl> + * for the clone method and its issues , see Effective Java : <nl> + * Programming Language Guide First Edition by Joshua Bloch pages 45 - 52 . <nl> + * < / p > <nl> + * < p > <nl> + * Below are some of the rules / reasons why the clone method should be avoided . <nl> + * < / p > <nl> * < ul > <nl> * < li > <nl> * Classes supporting the clone method should implement the Cloneable <nl> @ @ - 79 , 42 + 92 , 49 @ @ import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> * force the calling client to handle a CloneNotSupportedException . They also <nl> * are typed therefore no casting is necessary . Finally , they are more <nl> * flexible since they can take interface types rather than concrete classes . <nl> - * <nl> + * < / p > <nl> * < p > Sometimes a copy constructor or static factory is not an acceptable <nl> * alternative to the clone method . The example below highlights the <nl> * limitation of a copy constructor ( or static factory ) . Assume <nl> * Square is a subclass for Shape . <nl> - * <nl> + * < / p > <nl> * < pre > <nl> * Shape s1 = new Square ( ) ; <nl> * System . out . println ( s1 instanceof Square ) ; / / true <nl> * < / pre > <nl> + * < p > <nl> * . . . assume at this point the code knows nothing of s1 being a Square <nl> * that ' s the beauty of polymorphism but the code wants to copy <nl> * the Square which is declared as a Shape , its super type . . . <nl> - * <nl> + * < / p > <nl> * < pre > <nl> * Shape s2 = new Shape ( s1 ) ; / / using the copy constructor <nl> * System . out . println ( s2 instanceof Square ) ; / / false <nl> * < / pre > <nl> + * < p > <nl> * The working solution ( without knowing about all subclasses and doing many <nl> * casts ) is to do the following ( assuming correct clone implementation ) . <nl> - * <nl> + * < / p > <nl> * < pre > <nl> * Shape s2 = s1 . clone ( ) ; <nl> * System . out . println ( s2 instanceof Square ) ; / / true <nl> * < / pre > <nl> + * < p > <nl> * Just keep in mind if this type of polymorphic cloning is required <nl> * then a properly implemented clone method may be the best choice . <nl> - * <nl> + * < / p > <nl> * < p > Much of this information was taken from Effective Java : <nl> * Programming Language Guide First Edition by Joshua Bloch <nl> * pages 45 - 52 . Give Bloch credit for writing an excellent book . <nl> * < / p > <nl> + * < p > <nl> + * To configure the check : <nl> + * < / p > <nl> + * < pre > <nl> + * & lt ; module name = & quot ; NoClone & quot ; / & gt ; <nl> + * < / pre > <nl> * <nl> - * < p > This check is almost exactly the same as the { @ link NoFinalizerCheck } <nl> - * <nl> - * @ see Object # clone ( ) <nl> + * @ since 5 . 0 <nl> * / <nl> @ StatelessCheck <nl> public class NoCloneCheck extends AbstractCheck { <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsJavaDocsTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsJavaDocsTest . java <nl> index c21f909 . . 36eec61 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsJavaDocsTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsJavaDocsTest . java <nl> @ @ - 110 , 6 + 110 , 7 @ @ public class XdocsJavaDocsTest extends AbstractModuleTestSupport { <nl> " MissingOverride " , <nl> " MissingSwitchDefault " , <nl> " NeedBraces " , <nl> + " NoClone " , <nl> " PackageAnnotation " , <nl> " PackageName " , <nl> " ParameterName " , <nl> diff - - git a / src / xdocs / config _ coding . xml b / src / xdocs / config _ coding . xml <nl> index 26a92f0 . . 94f794a 100644 <nl> - - - a / src / xdocs / config _ coding . xml <nl> + + + b / src / xdocs / config _ coding . xml <nl> @ @ - 3282 , 27 + 3282 , 109 @ @ for ( String line : lines ) { <nl> < / section > <nl> <nl> < section name = " NoClone " > <nl> + < p > Since Checkstyle 5 . 0 < / p > <nl> < subsection name = " Description " id = " NoClone _ Description " > <nl> - < p > Since Checkstyle 5 . 0 < / p > <nl> - < p > <nl> - Checks that the clone method is not overridden from the <nl> - Object class . <nl> - < / p > <nl> - <nl> - < p > <nl> - Rationale : The clone method relies on strange , hard to follow rules that <nl> - are difficult to get right and do not work in all situations . <nl> - In some cases , either a copy constructor <nl> - or a static factory method can be used instead of the clone method <nl> - to return copies of an object . <nl> - For more information on rules for the clone method and its issues , see Effective Java : <nl> - Programming Language Guide First Edition by Joshua Bloch <nl> - pages 45 - 52 . <nl> - < / p > <nl> - <nl> - < p > <nl> - This check is almost exactly the same as the { @ link NoFinalizerCheck } <nl> - < / p > <nl> + < p > <nl> + Checks that the clone method is not overridden from the <nl> + Object class . <nl> + < / p > <nl> + < p > <nl> + This check is almost exactly the same as the < code > NoFinalizerCheck < / code > . <nl> + < / p > <nl> + < p > <nl> + See < a href = " https : / / docs . oracle . com / en / java / javase / 11 / docs / api / java . base / java / lang / Object . html # clone ( ) " > <nl> + Object . clone ( ) < / a > <nl> + < / p > <nl> + < p > <nl> + Rationale : The clone method relies on strange , hard to follow rules that <nl> + are difficult to get right and do not work in all situations . <nl> + In some cases , either a copy constructor <nl> + or a static factory method can be used instead of the clone method <nl> + to return copies of an object . <nl> + For more information on rules for the clone method and its issues , see Effective Java : <nl> + Programming Language Guide First Edition by Joshua Bloch <nl> + pages 45 - 52 . <nl> + < / p > <nl> + < p > <nl> + Below are some of the rules / reasons why the clone method should be avoided . <nl> + < / p > <nl> + < ul > <nl> + < li > <nl> + Classes supporting the clone method should implement the Cloneable interface <nl> + but the Cloneable interface does not include the clone method . <nl> + As a result , it doesn ' t enforce the method override . <nl> + < / li > <nl> + < li > <nl> + The Cloneable interface forces the Object ' s clone method to work correctly . <nl> + Without implementing it , the Object ' s clone method will throw a <nl> + CloneNotSupportedException . <nl> + < / li > <nl> + < li > <nl> + Non - final classes must return the object returned from a call to super . clone ( ) . <nl> + < / li > <nl> + < li > <nl> + Final classes can use a constructor to create a clone which is different <nl> + from non - final classes . <nl> + < / li > <nl> + < li > <nl> + If a super class implements the clone method incorrectly all subclasses calling <nl> + super . clone ( ) are doomed to failure . <nl> + < / li > <nl> + < li > <nl> + If a class has references to mutable objects then those object references must be <nl> + replaced with copies in the clone method after calling super . clone ( ) . <nl> + < / li > <nl> + < li > <nl> + The clone method does not work correctly with final mutable object references because <nl> + final references cannot be reassigned . <nl> + < / li > <nl> + < li > <nl> + If a super class overrides the clone method then all subclasses must provide a correct <nl> + clone implementation . <nl> + < / li > <nl> + < / ul > <nl> + < p > <nl> + Two alternatives to the clone method , in some cases , is a copy constructor or a static <nl> + factory method to return copies of an object . Both of these approaches are simpler and <nl> + do not conflict with final fields . They do not force the calling client to handle a <nl> + CloneNotSupportedException . They also are typed therefore no casting is necessary . <nl> + Finally , they are more flexible since they can take interface types rather than concrete <nl> + classes . <nl> + < / p > <nl> + < p > <nl> + Sometimes a copy constructor or static factory is not an acceptable alternative to the <nl> + clone method . The example below highlights the limitation of a copy constructor <nl> + ( or static factory ) . Assume Square is a subclass for Shape . <nl> + < / p > <nl> + < source > <nl> + Shape s1 = new Square ( ) ; <nl> + System . out . println ( s1 instanceof Square ) ; / / true <nl> + < / source > <nl> + < p > <nl> + . . . assume at this point the code knows nothing of s1 being a Square that ' s the beauty <nl> + of polymorphism but the code wants to copy the Square which is declared as a Shape , <nl> + its super type . . . <nl> + < / p > <nl> + < source > <nl> + Shape s2 = new Shape ( s1 ) ; / / using the copy constructor <nl> + System . out . println ( s2 instanceof Square ) ; / / false <nl> + < / source > <nl> + < p > <nl> + The working solution ( without knowing about all subclasses and doing many casts ) is to do <nl> + the following ( assuming correct clone implementation ) . <nl> + < / p > <nl> + < source > <nl> + Shape s2 = s1 . clone ( ) ; <nl> + System . out . println ( s2 instanceof Square ) ; / / true <nl> + < / source > <nl> + < p > <nl> + Just keep in mind if this type of polymorphic cloning is required then a properly <nl> + implemented clone method may be the best choice . <nl> + < / p > <nl> + < p > <nl> + Much of this information was taken from Effective Java : Programming Language Guide First <nl> + Edition by Joshua Bloch pages 45 - 52 . Give Bloch credit for writing an excellent book . <nl> + < / p > <nl> < / subsection > <nl> < subsection name = " Examples " id = " NoClone _ Examples " > <nl> < p >
NEAREST DIFF (one line): diff - - git a / src / testinputs / com / puppycrawl / tools / checkstyle / InputSimpleGenerics . java b / src / testinputs / com / puppycrawl / tools / checkstyle / InputSimpleGenerics . java <nl> deleted file mode 100644 <nl> index 1b61a54 . . 0000000 <nl> - - - a / src / testinputs / com / puppycrawl / tools / checkstyle / InputSimpleGenerics . java <nl> + + + / dev / null <nl> @ @ - 1 , 13 + 0 , 0 @ @ <nl> - package com . puppycrawl . tools . checkstyle ; <nl> - <nl> - import java . util . ArrayList ; <nl> - import java . util . List ; <nl> - <nl> - class InputSimpleGenerics <nl> - { <nl> - void meth ( ) <nl> - { <nl> - List < Integer > x = new ArrayList < Integer > ( ) ; <nl> - List < List < Integer > > y = new ArrayList < List < Integer > > ( ) ; <nl> - } <nl> - }

TEST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / NoCloneCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / NoCloneCheck . java 
 index 794937c . . 0235c22 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / NoCloneCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / NoCloneCheck . java 
 @ @ - 29 , 12 + 29 , 25 @ @ import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 * Checks that the clone method is not overridden from the 
 * Object class . 
 * < / p > 
 - * 
 - * < p > Rationale : The clone method relies on strange / hard to follow rules that 
 - * do not work it all situations . Consequently , it is difficult to 
 - * override correctly . Below are some of the rules / reasons why the clone 
 - * method should be avoided . 
 - * 
 + * < p > 
 + * This check is almost exactly the same as the { @ code NoFinalizerCheck } . 
 + * < / p > 
 + * < p > 
 + * See 
 + * < a href = " https : / / docs . oracle . com / en / java / javase / 11 / docs / api / java . base / java / lang / Object . html # clone ( ) " > 
 + * Object . clone ( ) < / a > 
 + * < / p > 
 + * < p > 
 + * Rationale : The clone method relies on strange , hard to follow rules that 
 + * are difficult to get right and do not work in all situations . In some cases , 
 + * either a copy constructor or a static factory method can be used instead of 
 + * the clone method to return copies of an object . For more information on rules 
 + * for the clone method and its issues , see Effective Java : 
 + * Programming Language Guide First Edition by Joshua Bloch pages 45 - 52 . 
 + * < / p > 
 + * < p > 
 + * Below are some of the rules / reasons why the clone method should be avoided . 
 + * < / p > 
 * < ul > 
 * < li > 
 * Classes supporting the clone method should implement the Cloneable 
 @ @ - 79 , 42 + 92 , 49 @ @ import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 * force the calling client to handle a CloneNotSupportedException . They also 
 * are typed therefore no casting is necessary . Finally , they are more 
 * flexible since they can take interface types rather than concrete classes . 
 - * 
 + * < / p > 
 * < p > Sometimes a copy constructor or static factory is not an acceptable 
 * alternative to the clone method . The example below highlights the 
 * limitation of a copy constructor ( or static factory ) . Assume 
 * Square is a subclass for Shape . 
 - * 
 + * < / p > 
 * < pre > 
 * Shape s1 = new Square ( ) ; 
 * System . out . println ( s1 instanceof Square ) ; / / true 
 * < / pre > 
 + * < p > 
 * . . . assume at this point the code knows nothing of s1 being a Square 
 * that ' s the beauty of polymorphism but the code wants to copy 
 * the Square which is declared as a Shape , its super type . . . 
 - * 
 + * < / p > 
 * < pre > 
 * Shape s2 = new Shape ( s1 ) ; / / using the copy constructor 
 * System . out . println ( s2 instanceof Square ) ; / / false 
 * < / pre > 
 + * < p > 
 * The working solution ( without knowing about all subclasses and doing many 
 * casts ) is to do the following ( assuming correct clone implementation ) . 
 - * 
 + * < / p > 
 * < pre > 
 * Shape s2 = s1 . clone ( ) ; 
 * System . out . println ( s2 instanceof Square ) ; / / true 
 * < / pre > 
 + * < p > 
 * Just keep in mind if this type of polymorphic cloning is required 
 * then a properly implemented clone method may be the best choice . 
 - * 
 + * < / p > 
 * < p > Much of this information was taken from Effective Java : 
 * Programming Language Guide First Edition by Joshua Bloch 
 * pages 45 - 52 . Give Bloch credit for writing an excellent book . 
 * < / p > 
 + * < p > 
 + * To configure the check : 
 + * < / p > 
 + * < pre > 
 + * & lt ; module name = & quot ; NoClone & quot ; / & gt ; 
 + * < / pre > 
 * 
 - * < p > This check is almost exactly the same as the { @ link NoFinalizerCheck } 
 - * 
 - * @ see Object # clone ( ) 
 + * @ since 5 . 0 
 * / 
 @ StatelessCheck 
 public class NoCloneCheck extends AbstractCheck { 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsJavaDocsTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsJavaDocsTest . java 
 index c21f909 . . 36eec61 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsJavaDocsTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsJavaDocsTest . java 
 @ @ - 110 , 6 + 110 , 7 @ @ public class XdocsJavaDocsTest extends AbstractModuleTestSupport { 
 " MissingOverride " , 
 " MissingSwitchDefault " , 
 " NeedBraces " , 
 + " NoClone " , 
 " PackageAnnotation " , 
 " PackageName " , 
 " ParameterName " , 
 diff - - git a / src / xdocs / config _ coding . xml b / src / xdocs / config _ coding . xml 
 index 26a92f0 . . 94f794a 100644 
 - - - a / src / xdocs / config _ coding . xml 
 + + + b / src / xdocs / config _ coding . xml 
 @ @ - 3282 , 27 + 3282 , 109 @ @ for ( String line : lines ) { 
 < / section > 
 
 < section name = " NoClone " > 
 + < p > Since Checkstyle 5 . 0 < / p > 
 < subsection name = " Description " id = " NoClone _ Description " > 
 - < p > Since Checkstyle 5 . 0 < / p > 
 - < p > 
 - Checks that the clone method is not overridden from the 
 - Object class . 
 - < / p > 
 - 
 - < p > 
 - Rationale : The clone method relies on strange , hard to follow rules that 
 - are difficult to get right and do not work in all situations . 
 - In some cases , either a copy constructor 
 - or a static factory method can be used instead of the clone method 
 - to return copies of an object . 
 - For more information on rules for the clone method and its issues , see Effective Java : 
 - Programming Language Guide First Edition by Joshua Bloch 
 - pages 45 - 52 . 
 - < / p > 
 - 
 - < p > 
 - This check is almost exactly the same as the { @ link NoFinalizerCheck } 
 - < / p > 
 + < p > 
 + Checks that the clone method is not overridden from the 
 + Object class . 
 + < / p > 
 + < p > 
 + This check is almost exactly the same as the < code > NoFinalizerCheck < / code > . 
 + < / p > 
 + < p > 
 + See < a href = " https : / / docs . oracle . com / en / java / javase / 11 / docs / api / java . base / java / lang / Object . html # clone ( ) " > 
 + Object . clone ( ) < / a > 
 + < / p > 
 + < p > 
 + Rationale : The clone method relies on strange , hard to follow rules that 
 + are difficult to get right and do not work in all situations . 
 + In some cases , either a copy constructor 
 + or a static factory method can be used instead of the clone method 
 + to return copies of an object . 
 + For more information on rules for the clone method and its issues , see Effective Java : 
 + Programming Language Guide First Edition by Joshua Bloch 
 + pages 45 - 52 . 
 + < / p > 
 + < p > 
 + Below are some of the rules / reasons why the clone method should be avoided . 
 + < / p > 
 + < ul > 
 + < li > 
 + Classes supporting the clone method should implement the Cloneable interface 
 + but the Cloneable interface does not include the clone method . 
 + As a result , it doesn ' t enforce the method override . 
 + < / li > 
 + < li > 
 + The Cloneable interface forces the Object ' s clone method to work correctly . 
 + Without implementing it , the Object ' s clone method will throw a 
 + CloneNotSupportedException . 
 + < / li > 
 + < li > 
 + Non - final classes must return the object returned from a call to super . clone ( ) . 
 + < / li > 
 + < li > 
 + Final classes can use a constructor to create a clone which is different 
 + from non - final classes . 
 + < / li > 
 + < li > 
 + If a super class implements the clone method incorrectly all subclasses calling 
 + super . clone ( ) are doomed to failure . 
 + < / li > 
 + < li > 
 + If a class has references to mutable objects then those object references must be 
 + replaced with copies in the clone method after calling super . clone ( ) . 
 + < / li > 
 + < li > 
 + The clone method does not work correctly with final mutable object references because 
 + final references cannot be reassigned . 
 + < / li > 
 + < li > 
 + If a super class overrides the clone method then all subclasses must provide a correct 
 + clone implementation . 
 + < / li > 
 + < / ul > 
 + < p > 
 + Two alternatives to the clone method , in some cases , is a copy constructor or a static 
 + factory method to return copies of an object . Both of these approaches are simpler and 
 + do not conflict with final fields . They do not force the calling client to handle a 
 + CloneNotSupportedException . They also are typed therefore no casting is necessary . 
 + Finally , they are more flexible since they can take interface types rather than concrete 
 + classes . 
 + < / p > 
 + < p > 
 + Sometimes a copy constructor or static factory is not an acceptable alternative to the 
 + clone method . The example below highlights the limitation of a copy constructor 
 + ( or static factory ) . Assume Square is a subclass for Shape . 
 + < / p > 
 + < source > 
 + Shape s1 = new Square ( ) ; 
 + System . out . println ( s1 instanceof Square ) ; / / true 
 + < / source > 
 + < p > 
 + . . . assume at this point the code knows nothing of s1 being a Square that ' s the beauty 
 + of polymorphism but the code wants to copy the Square which is declared as a Shape , 
 + its super type . . . 
 + < / p > 
 + < source > 
 + Shape s2 = new Shape ( s1 ) ; / / using the copy constructor 
 + System . out . println ( s2 instanceof Square ) ; / / false 
 + < / source > 
 + < p > 
 + The working solution ( without knowing about all subclasses and doing many casts ) is to do 
 + the following ( assuming correct clone implementation ) . 
 + < / p > 
 + < source > 
 + Shape s2 = s1 . clone ( ) ; 
 + System . out . println ( s2 instanceof Square ) ; / / true 
 + < / source > 
 + < p > 
 + Just keep in mind if this type of polymorphic cloning is required then a properly 
 + implemented clone method may be the best choice . 
 + < / p > 
 + < p > 
 + Much of this information was taken from Effective Java : Programming Language Guide First 
 + Edition by Joshua Bloch pages 45 - 52 . Give Bloch credit for writing an excellent book . 
 + < / p > 
 < / subsection > 
 < subsection name = " Examples " id = " NoClone _ Examples " > 
 < p >

NEAREST DIFF:
diff - - git a / src / testinputs / com / puppycrawl / tools / checkstyle / InputSimpleGenerics . java b / src / testinputs / com / puppycrawl / tools / checkstyle / InputSimpleGenerics . java 
 deleted file mode 100644 
 index 1b61a54 . . 0000000 
 - - - a / src / testinputs / com / puppycrawl / tools / checkstyle / InputSimpleGenerics . java 
 + + + / dev / null 
 @ @ - 1 , 13 + 0 , 0 @ @ 
 - package com . puppycrawl . tools . checkstyle ; 
 - 
 - import java . util . ArrayList ; 
 - import java . util . List ; 
 - 
 - class InputSimpleGenerics 
 - { 
 - void meth ( ) 
 - { 
 - List < Integer > x = new ArrayList < Integer > ( ) ; 
 - List < List < Integer > > y = new ArrayList < List < Integer > > ( ) ; 
 - } 
 - }
