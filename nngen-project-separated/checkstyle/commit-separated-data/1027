BLEU SCORE: 0.03737437943747671

TEST MSG: Issue # 3628 : ReturnCountExtendedCheck from sevntu is enabled , all violations are resolved
GENERATED MSG: Fix PMD violations from AvoidFieldNameMatchingMethodName rule . # 984

TEST DIFF (one line): diff - - git a / config / pmd . xml b / config / pmd . xml <nl> index 738aef7 . . 1b63156 100644 <nl> - - - a / config / pmd . xml <nl> + + + b / config / pmd . xml <nl> @ @ - 186 , 6 + 186 , 7 @ @ <nl> < properties > <nl> < ! - - default is 3 but we try to use single point of exit from method and that require extra IFs - - > <nl> < property name = " problemDepth " value = " 4 " / > <nl> + < property name = " violationSuppressXPath " value = " / / ClassOrInterfaceDeclaration [ @ Image = ' ClassResolver ' ] / / MethodDeclarator [ @ Image = ' resolve ' ] " / > <nl> < / properties > <nl> < / rule > <nl> <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / ClassResolver . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / ClassResolver . java <nl> index ca17d73 . . 1736e0a 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / ClassResolver . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / ClassResolver . java <nl> @ @ - 69 , 16 + 69 , 61 @ @ public class ClassResolver { <nl> * @ return the resolved class <nl> * @ throws ClassNotFoundException if unable to resolve the class <nl> * / <nl> - / / - @ cs [ ForbidWildcardAsReturnType ] The class is deprecated and will be removed soon . <nl> + / / - @ cs [ ForbidWildcardAsReturnType ] This method can return any type , so no way to avoid wildcard <nl> public Class < ? > resolve ( String name , String currentClass ) <nl> throws ClassNotFoundException { <nl> / / See if the class is full qualified <nl> Class < ? > clazz = resolveQualifiedName ( name ) ; <nl> - if ( clazz ! = null ) { <nl> - return clazz ; <nl> + if ( clazz = = null ) { <nl> + / / try matching explicit imports <nl> + clazz = resolveMatchingExplicitImport ( name ) ; <nl> + <nl> + if ( clazz = = null ) { <nl> + / / See if in the package <nl> + clazz = resolveInPackage ( name ) ; <nl> + <nl> + if ( clazz = = null ) { <nl> + / / see if inner class of this class <nl> + clazz = resolveInnerClass ( name , currentClass ) ; <nl> + <nl> + if ( clazz = = null ) { <nl> + clazz = resolveByStarImports ( name ) ; <nl> + / / - @ cs [ NestedIfDepth ] it is better to have single return point from method <nl> + if ( clazz = = null ) { <nl> + / / Giving up , the type is unknown , so load the class to generate an <nl> + / / exception <nl> + clazz = safeLoad ( name ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> + return clazz ; <nl> + } <nl> + <nl> + / * * <nl> + * Try to find class by search in package . <nl> + * @ param name class name <nl> + * @ return class object <nl> + * / <nl> + private Class < ? > resolveInPackage ( String name ) { <nl> + Class < ? > clazz = null ; <nl> + if ( pkg ! = null & & ! pkg . isEmpty ( ) ) { <nl> + final Class < ? > classFromQualifiedName = resolveQualifiedName ( pkg + PERIOD + name ) ; <nl> + if ( classFromQualifiedName ! = null ) { <nl> + clazz = classFromQualifiedName ; <nl> + } <nl> } <nl> + return clazz ; <nl> + } <nl> <nl> - / / try matching explicit imports <nl> + / * * <nl> + * Try to find class by matching explicit Import . <nl> + * @ param name class name <nl> + * @ return class object <nl> + * / <nl> + private Class < ? > resolveMatchingExplicitImport ( String name ) { <nl> + Class < ? > clazz = null ; <nl> for ( String imp : imports ) { <nl> / / Very important to add the " . " in the check below . Otherwise you <nl> / / when checking for " DataException " , it will match on <nl> @ @ - 87 , 34 + 132 , 12 @ @ public class ClassResolver { <nl> if ( imp . endsWith ( PERIOD + name ) ) { <nl> clazz = resolveQualifiedName ( imp ) ; <nl> if ( clazz ! = null ) { <nl> - return clazz ; <nl> + break ; <nl> } <nl> <nl> } <nl> } <nl> - <nl> - / / See if in the package <nl> - if ( pkg ! = null & & ! pkg . isEmpty ( ) ) { <nl> - final Class < ? > classFromQualifiedName = resolveQualifiedName ( pkg + PERIOD + name ) ; <nl> - if ( classFromQualifiedName ! = null ) { <nl> - return classFromQualifiedName ; <nl> - } <nl> - } <nl> - <nl> - / / see if inner class of this class <nl> - final Class < ? > innerClass = resolveInnerClass ( name , currentClass ) ; <nl> - if ( innerClass ! = null ) { <nl> - return innerClass ; <nl> - } <nl> - <nl> - final Class < ? > classFromStarImport = resolveByStarImports ( name ) ; <nl> - if ( classFromStarImport ! = null ) { <nl> - return classFromStarImport ; <nl> - } <nl> - <nl> - / / Giving up , the type is unknown , so load the class to generate an <nl> - / / exception <nl> - return safeLoad ( name ) ; <nl> + return clazz ; <nl> } <nl> <nl> / * * <nl> @ @ - 150 , 8 + 173 , 7 @ @ public class ClassResolver { <nl> Class < ? > clazz = null ; <nl> for ( String imp : imports ) { <nl> if ( imp . endsWith ( " . * " ) ) { <nl> - final String fqn = imp . substring ( 0 , imp . lastIndexOf ( ' . ' ) + 1 ) <nl> - + name ; <nl> + final String fqn = imp . substring ( 0 , imp . lastIndexOf ( ' . ' ) + 1 ) + name ; <nl> clazz = resolveQualifiedName ( fqn ) ; <nl> if ( clazz ! = null ) { <nl> break ; <nl> @ @ - 166 , 13 + 188 , 15 @ @ public class ClassResolver { <nl> * @ return whether a specified class is loadable with safeLoad ( ) . <nl> * / <nl> public boolean isLoadable ( String name ) { <nl> + boolean result = false ; <nl> try { <nl> safeLoad ( name ) ; <nl> - return true ; <nl> + result = true ; <nl> } <nl> catch ( final ClassNotFoundException | NoClassDefFoundError ignored ) { <nl> - return false ; <nl> + result = false ; <nl> } <nl> + return result ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / AnnotationUtility . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / AnnotationUtility . java <nl> index 7008132 . . fc8845e 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / AnnotationUtility . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / AnnotationUtility . java <nl> @ @ - 152 , 7 + 152 , 7 @ @ public final class AnnotationUtility { <nl> } <nl> <nl> final DetailAST holder = getAnnotationHolder ( ast ) ; <nl> - <nl> + DetailAST result = null ; <nl> for ( DetailAST child = holder . getFirstChild ( ) ; <nl> child ! = null ; child = child . getNextSibling ( ) ) { <nl> if ( child . getType ( ) = = TokenTypes . ANNOTATION ) { <nl> @ @ - 160 , 12 + 160 , 13 @ @ public final class AnnotationUtility { <nl> final String name = <nl> FullIdent . createFullIdent ( firstChild . getNextSibling ( ) ) . getText ( ) ; <nl> if ( annotation . equals ( name ) ) { <nl> - return child ; <nl> + result = child ; <nl> + break ; <nl> } <nl> } <nl> } <nl> <nl> - return null ; <nl> + return result ; <nl> } <nl> <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java <nl> index 5859888 . . 321e1d0 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java <nl> @ @ - 110 , 13 + 110 , 13 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { <nl> private static boolean isCommentConsistent ( IndentComment comment ) { <nl> final String [ ] levels = comment . getExpectedWarning ( ) . split ( " , " ) ; <nl> final int indent = comment . getIndent ( ) + comment . getIndentOffset ( ) ; <nl> - <nl> + final boolean result ; <nl> if ( levels . length > 1 ) { <nl> / / multi <nl> final boolean containsActualLevel = <nl> Arrays . asList ( levels ) . contains ( String . valueOf ( indent ) ) ; <nl> <nl> - return containsActualLevel ! = comment . isWarning ( ) ; <nl> + result = containsActualLevel ! = comment . isWarning ( ) ; <nl> } <nl> else { <nl> final int expectedWarning = Integer . parseInt ( comment . getExpectedWarning ( ) ) ; <nl> @ @ - 124 , 14 + 124 , 15 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { <nl> if ( comment . isExpectedNonStrict ( ) ) { <nl> / / non - strict <nl> final boolean test = indent > = expectedWarning ; <nl> - return test ! = comment . isWarning ( ) ; <nl> + result = test ! = comment . isWarning ( ) ; <nl> } <nl> else { <nl> / / single <nl> final boolean test = expectedWarning = = indent ; <nl> - return test ! = comment . isWarning ( ) ; <nl> + result = test ! = comment . isWarning ( ) ; <nl> } <nl> } <nl> + return result ; <nl> } <nl> <nl> private static int getLineStart ( String line , final int tabWidth ) {
NEAREST DIFF (one line): diff - - git a / config / pmd . xml b / config / pmd . xml <nl> index 722542b . . aa5170a 100644 <nl> - - - a / config / pmd . xml <nl> + + + b / config / pmd . xml <nl> @ @ - 165 , 11 + 165 , 15 @ @ <nl> < exclude name = " AbstractNaming " / > <nl> < ! - - till # 984 - - > <nl> < exclude name = " AvoidFieldNameMatchingMethodName " / > <nl> - < ! - - nothing bad in long and descriptive variable names if only they fit line - - > <nl> - < exclude name = " LongVariable " / > <nl> < ! - - till # 985 - - > <nl> < exclude name = " ShortVariable " / > <nl> < / rule > <nl> + < rule ref = " rulesets / java / naming . xml / LongVariable " > <nl> + < properties > <nl> + < ! - - nothing bad in long and descriptive variable names if only they fit line , but still keep it reasonable - - > <nl> + < property name = " minimum " value = " 45 " / > <nl> + < / properties > <nl> + < / rule > <nl> < rule ref = " rulesets / java / naming . xml / ShortClassName " > <nl> < properties > <nl> < ! - - Main is good name for class containing main method , Tag as inner class name is also fine - - >

TEST DIFF:
diff - - git a / config / pmd . xml b / config / pmd . xml 
 index 738aef7 . . 1b63156 100644 
 - - - a / config / pmd . xml 
 + + + b / config / pmd . xml 
 @ @ - 186 , 6 + 186 , 7 @ @ 
 < properties > 
 < ! - - default is 3 but we try to use single point of exit from method and that require extra IFs - - > 
 < property name = " problemDepth " value = " 4 " / > 
 + < property name = " violationSuppressXPath " value = " / / ClassOrInterfaceDeclaration [ @ Image = ' ClassResolver ' ] / / MethodDeclarator [ @ Image = ' resolve ' ] " / > 
 < / properties > 
 < / rule > 
 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / ClassResolver . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / ClassResolver . java 
 index ca17d73 . . 1736e0a 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / ClassResolver . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / ClassResolver . java 
 @ @ - 69 , 16 + 69 , 61 @ @ public class ClassResolver { 
 * @ return the resolved class 
 * @ throws ClassNotFoundException if unable to resolve the class 
 * / 
 - / / - @ cs [ ForbidWildcardAsReturnType ] The class is deprecated and will be removed soon . 
 + / / - @ cs [ ForbidWildcardAsReturnType ] This method can return any type , so no way to avoid wildcard 
 public Class < ? > resolve ( String name , String currentClass ) 
 throws ClassNotFoundException { 
 / / See if the class is full qualified 
 Class < ? > clazz = resolveQualifiedName ( name ) ; 
 - if ( clazz ! = null ) { 
 - return clazz ; 
 + if ( clazz = = null ) { 
 + / / try matching explicit imports 
 + clazz = resolveMatchingExplicitImport ( name ) ; 
 + 
 + if ( clazz = = null ) { 
 + / / See if in the package 
 + clazz = resolveInPackage ( name ) ; 
 + 
 + if ( clazz = = null ) { 
 + / / see if inner class of this class 
 + clazz = resolveInnerClass ( name , currentClass ) ; 
 + 
 + if ( clazz = = null ) { 
 + clazz = resolveByStarImports ( name ) ; 
 + / / - @ cs [ NestedIfDepth ] it is better to have single return point from method 
 + if ( clazz = = null ) { 
 + / / Giving up , the type is unknown , so load the class to generate an 
 + / / exception 
 + clazz = safeLoad ( name ) ; 
 + } 
 + } 
 + } 
 + } 
 + } 
 + return clazz ; 
 + } 
 + 
 + / * * 
 + * Try to find class by search in package . 
 + * @ param name class name 
 + * @ return class object 
 + * / 
 + private Class < ? > resolveInPackage ( String name ) { 
 + Class < ? > clazz = null ; 
 + if ( pkg ! = null & & ! pkg . isEmpty ( ) ) { 
 + final Class < ? > classFromQualifiedName = resolveQualifiedName ( pkg + PERIOD + name ) ; 
 + if ( classFromQualifiedName ! = null ) { 
 + clazz = classFromQualifiedName ; 
 + } 
 } 
 + return clazz ; 
 + } 
 
 - / / try matching explicit imports 
 + / * * 
 + * Try to find class by matching explicit Import . 
 + * @ param name class name 
 + * @ return class object 
 + * / 
 + private Class < ? > resolveMatchingExplicitImport ( String name ) { 
 + Class < ? > clazz = null ; 
 for ( String imp : imports ) { 
 / / Very important to add the " . " in the check below . Otherwise you 
 / / when checking for " DataException " , it will match on 
 @ @ - 87 , 34 + 132 , 12 @ @ public class ClassResolver { 
 if ( imp . endsWith ( PERIOD + name ) ) { 
 clazz = resolveQualifiedName ( imp ) ; 
 if ( clazz ! = null ) { 
 - return clazz ; 
 + break ; 
 } 
 
 } 
 } 
 - 
 - / / See if in the package 
 - if ( pkg ! = null & & ! pkg . isEmpty ( ) ) { 
 - final Class < ? > classFromQualifiedName = resolveQualifiedName ( pkg + PERIOD + name ) ; 
 - if ( classFromQualifiedName ! = null ) { 
 - return classFromQualifiedName ; 
 - } 
 - } 
 - 
 - / / see if inner class of this class 
 - final Class < ? > innerClass = resolveInnerClass ( name , currentClass ) ; 
 - if ( innerClass ! = null ) { 
 - return innerClass ; 
 - } 
 - 
 - final Class < ? > classFromStarImport = resolveByStarImports ( name ) ; 
 - if ( classFromStarImport ! = null ) { 
 - return classFromStarImport ; 
 - } 
 - 
 - / / Giving up , the type is unknown , so load the class to generate an 
 - / / exception 
 - return safeLoad ( name ) ; 
 + return clazz ; 
 } 
 
 / * * 
 @ @ - 150 , 8 + 173 , 7 @ @ public class ClassResolver { 
 Class < ? > clazz = null ; 
 for ( String imp : imports ) { 
 if ( imp . endsWith ( " . * " ) ) { 
 - final String fqn = imp . substring ( 0 , imp . lastIndexOf ( ' . ' ) + 1 ) 
 - + name ; 
 + final String fqn = imp . substring ( 0 , imp . lastIndexOf ( ' . ' ) + 1 ) + name ; 
 clazz = resolveQualifiedName ( fqn ) ; 
 if ( clazz ! = null ) { 
 break ; 
 @ @ - 166 , 13 + 188 , 15 @ @ public class ClassResolver { 
 * @ return whether a specified class is loadable with safeLoad ( ) . 
 * / 
 public boolean isLoadable ( String name ) { 
 + boolean result = false ; 
 try { 
 safeLoad ( name ) ; 
 - return true ; 
 + result = true ; 
 } 
 catch ( final ClassNotFoundException | NoClassDefFoundError ignored ) { 
 - return false ; 
 + result = false ; 
 } 
 + return result ; 
 } 
 
 / * * 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / AnnotationUtility . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / AnnotationUtility . java 
 index 7008132 . . fc8845e 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / AnnotationUtility . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / AnnotationUtility . java 
 @ @ - 152 , 7 + 152 , 7 @ @ public final class AnnotationUtility { 
 } 
 
 final DetailAST holder = getAnnotationHolder ( ast ) ; 
 - 
 + DetailAST result = null ; 
 for ( DetailAST child = holder . getFirstChild ( ) ; 
 child ! = null ; child = child . getNextSibling ( ) ) { 
 if ( child . getType ( ) = = TokenTypes . ANNOTATION ) { 
 @ @ - 160 , 12 + 160 , 13 @ @ public final class AnnotationUtility { 
 final String name = 
 FullIdent . createFullIdent ( firstChild . getNextSibling ( ) ) . getText ( ) ; 
 if ( annotation . equals ( name ) ) { 
 - return child ; 
 + result = child ; 
 + break ; 
 } 
 } 
 } 
 
 - return null ; 
 + return result ; 
 } 
 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java 
 index 5859888 . . 321e1d0 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java 
 @ @ - 110 , 13 + 110 , 13 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { 
 private static boolean isCommentConsistent ( IndentComment comment ) { 
 final String [ ] levels = comment . getExpectedWarning ( ) . split ( " , " ) ; 
 final int indent = comment . getIndent ( ) + comment . getIndentOffset ( ) ; 
 - 
 + final boolean result ; 
 if ( levels . length > 1 ) { 
 / / multi 
 final boolean containsActualLevel = 
 Arrays . asList ( levels ) . contains ( String . valueOf ( indent ) ) ; 
 
 - return containsActualLevel ! = comment . isWarning ( ) ; 
 + result = containsActualLevel ! = comment . isWarning ( ) ; 
 } 
 else { 
 final int expectedWarning = Integer . parseInt ( comment . getExpectedWarning ( ) ) ; 
 @ @ - 124 , 14 + 124 , 15 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { 
 if ( comment . isExpectedNonStrict ( ) ) { 
 / / non - strict 
 final boolean test = indent > = expectedWarning ; 
 - return test ! = comment . isWarning ( ) ; 
 + result = test ! = comment . isWarning ( ) ; 
 } 
 else { 
 / / single 
 final boolean test = expectedWarning = = indent ; 
 - return test ! = comment . isWarning ( ) ; 
 + result = test ! = comment . isWarning ( ) ; 
 } 
 } 
 + return result ; 
 } 
 
 private static int getLineStart ( String line , final int tabWidth ) {

NEAREST DIFF:
diff - - git a / config / pmd . xml b / config / pmd . xml 
 index 722542b . . aa5170a 100644 
 - - - a / config / pmd . xml 
 + + + b / config / pmd . xml 
 @ @ - 165 , 11 + 165 , 15 @ @ 
 < exclude name = " AbstractNaming " / > 
 < ! - - till # 984 - - > 
 < exclude name = " AvoidFieldNameMatchingMethodName " / > 
 - < ! - - nothing bad in long and descriptive variable names if only they fit line - - > 
 - < exclude name = " LongVariable " / > 
 < ! - - till # 985 - - > 
 < exclude name = " ShortVariable " / > 
 < / rule > 
 + < rule ref = " rulesets / java / naming . xml / LongVariable " > 
 + < properties > 
 + < ! - - nothing bad in long and descriptive variable names if only they fit line , but still keep it reasonable - - > 
 + < property name = " minimum " value = " 45 " / > 
 + < / properties > 
 + < / rule > 
 < rule ref = " rulesets / java / naming . xml / ShortClassName " > 
 < properties > 
 < ! - - Main is good name for class containing main method , Tag as inner class name is also fine - - >
