BLEU SCORE: 0.03416211359799979

TEST MSG: minor : fix for links at linkcheck plugin validation
GENERATED MSG: Issue # 410 : WritingJavadocChecks wiki - page . Some amendments .

TEST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . java b / src / main / java / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . java <nl> index 79e809b . . 8400d91 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . java <nl> @ @ - 39 , 7 + 39 , 7 @ @ public interface ExternalResourceHolder { <nl> * Returns a set of external configuration resource locations which are used by the module . <nl> * ATTENTION ! <nl> * If ' getExternalResourceLocations ( ) ' return null , there will be <nl> - * { @ link NullPointerException } in { @ link Checker # getExternalResourceLocations ( ) } . <nl> + * { @ link NullPointerException } in { @ link Checker } . <nl> * Such behaviour will signal that your module ( check or filter ) is designed incorrectrly . <nl> * It make sence to return an empty set from ' getExternalResourceLocations ( ) ' <nl> * only for composite modules like { @ link com . puppycrawl . tools . checkstyle . TreeWalker } . <nl> diff - - git a / src / xdocs / writingchecks . xml b / src / xdocs / writingchecks . xml <nl> index b9b8db5 . . c61d54a 100644 <nl> - - - a / src / xdocs / writingchecks . xml <nl> + + + b / src / xdocs / writingchecks . xml <nl> @ @ - 282 , 7 + 282 , 7 @ @ public class MethodLimitCheck extends AbstractCheck <nl> <nl> < p > <nl> There are four methods in Check class to control the processed <nl> - < a href = " http : / / checkstyle . sourceforge . net / apidocs / index . html " > TokenTypes < / a > - <nl> + < a href = " apidocs / index . html " > TokenTypes < / a > - <nl> one setter <nl> < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / AbstractCheck . html # setTokens - java . lang . String . . . - " > <nl> setTokens ( ) < / a > , which is used to define a custom set ( which is different <nl> @ @ - 612 , 22 + 612 , 22 @ @ public class LimitImplementationFiles extends AbstractFileSetCheck <nl> < p > <nl> Checkstyle can cache external configuration resources of any kind which are used by your <nl> check . If you want to do such a thing , you should implement <nl> - < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html " > ExternalResourceHolder < / a > <nl> + < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html " > ExternalResourceHolder < / a > <nl> interface . Such module must declare external resource locations as a set of Strings <nl> - which will be returned from < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > <nl> + which will be returned from < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > <nl> method . This will allow Checkstyle to invalidate ( clear ) cache when the content of at <nl> least one external configuration resource of your check is changed . <nl> < / p > <nl> < p > <nl> ATTENTION ! <nl> < li > <nl> - If < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > <nl> - return null , there will be NullPointerException in < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / Checker . html # getExternalResourceLocations - - " > Checker < / a > . <nl> + If < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > <nl> + return null , there will be NullPointerException in < a href = " apidocs / com / puppycrawl / tools / checkstyle / Checker . html " > Checker < / a > . <nl> Such behaviour will signal that your module ( check or filter ) is designed incorrectrly . <nl> < / li > <nl> < li > <nl> - It make sence to return an empty set from < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > <nl> - only for composite modules like < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / TreeWalker . html " > TreeWalker < / a > . <nl> + It make sence to return an empty set from < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > <nl> + only for composite modules like < a href = " apidocs / com / puppycrawl / tools / checkstyle / TreeWalker . html " > TreeWalker < / a > . <nl> < / li > <nl> < / p > <nl> < / section > <nl> diff - - git a / src / xdocs / writingjavadocchecks . xml . vm b / src / xdocs / writingjavadocchecks . xml . vm <nl> index 19ee6c4 . . 586ef7f 100644 <nl> - - - a / src / xdocs / writingjavadocchecks . xml . vm <nl> + + + b / src / xdocs / writingjavadocchecks . xml . vm <nl> @ @ - 54 , 11 + 54 , 11 @ @ public class MyClass { <nl> The comment should be written in XHTML to be correctly processed by Checkstyle . This means that every HTML tag should have matching closed HTML tag or it is self - closed one ( singlton tag ) . <nl> The only exceptions are & lt ; p & gt ; , & lt ; li & gt ; , & lt ; tr & gt ; , & lt ; td & gt ; , & lt ; th & gt ; , & lt ; body & gt ; , & lt ; colgroup & gt ; , & lt ; dd & gt ; , & lt ; dt & gt ; , & lt ; head & gt ; , & lt ; html & gt ; , & lt ; option & gt ; , <nl> & lt ; tbody & gt ; , & lt ; thead & gt ; , & lt ; tfoot & gt ; and Checkstyle won ' t show error about missing closing tag , however , it leads to broken XHTML structure and to <nl> - not - nested content of the HTML tags in Abstract Syntax Tree of the Javadoc comment . See examples at < a href = " HTML _ Code _ In _ Javadoc _ Comments " > HTML Code In Javadoc Comments < / a > section . <nl> + not - nested content of the HTML tags in Abstract Syntax Tree of the Javadoc comment . See examples at < a href = " # HTML _ Code _ In _ Javadoc _ Comments " > HTML Code In Javadoc Comments < / a > section . <nl> < / p > <nl> < p > <nl> Javadoc parser requires XHTML to be used in Javadoc comments , i . e . if there is some open tag ( for example & lt ; div & gt ; ) then there have to be its close tag & lt ; / div & gt ; . <nl> - This means that if Javadoc comment has incorrect XHTML structure then Javadoc Parser will fail processing the comment , therefore , your new Check can ' t get its parse tree and process anything from this Javadoc comment . For more details and examples go to < a href = " HTML _ Code _ In _ Javadoc _ Comments " > HTML Code In Javadoc Comments < / a > section . <nl> + This means that if Javadoc comment has incorrect XHTML structure then Javadoc Parser will fail processing the comment , therefore , your new Check can ' t get its parse tree and process anything from this Javadoc comment . For more details and examples go to < a href = " # HTML _ Code _ In _ Javadoc _ Comments " > HTML Code In Javadoc Comments < / a > section . <nl> < / p > <nl> < p > <nl> Javadoc grammar requires XHTML , but it can also parse some parts of HTML code ( like some unclosed tags ) . If HTML tags are not closed Javadoc grammar cannot determine content of these tags ,
NEAREST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / TranslationCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / TranslationCheck . java <nl> index 8965e6a . . f310fe9 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / TranslationCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / TranslationCheck . java <nl> @ @ - 201 , 30 + 201 , 6 @ @ public class TranslationCheck extends AbstractFileSetCheck { <nl> validateUserSpecifiedLanguageCodes ( requiredTranslations ) ; <nl> } <nl> <nl> - @ Override <nl> - public void beginProcessing ( String charset ) { <nl> - super . beginProcessing ( charset ) ; <nl> - filesToProcess . clear ( ) ; <nl> - } <nl> - <nl> - @ Override <nl> - protected void processFiltered ( File file , List < String > lines ) { <nl> - / / We just collecting files for processing at finishProcessing ( ) <nl> - filesToProcess . add ( file ) ; <nl> - } <nl> - <nl> - @ Override <nl> - public void finishProcessing ( ) { <nl> - super . finishProcessing ( ) ; <nl> - <nl> - final Set < ResourceBundle > bundles = groupFilesIntoBundles ( filesToProcess , baseNamePattern ) ; <nl> - for ( ResourceBundle currentBundle : bundles ) { <nl> - checkExistenceOfDefaultTranslation ( currentBundle ) ; <nl> - checkExistenceOfRequiredTranslations ( currentBundle ) ; <nl> - checkTranslationKeys ( currentBundle ) ; <nl> - } <nl> - } <nl> - <nl> / * * <nl> * Validates the correctness of user specififed language codes for the check . <nl> * @ param languageCodes user specified language codes for the check . <nl> @ @ - 233 , 9 + 209 , 9 @ @ public class TranslationCheck extends AbstractFileSetCheck { <nl> for ( String code : languageCodes ) { <nl> if ( ! isValidLanguageCode ( code ) ) { <nl> final LocalizedMessage msg = new LocalizedMessage ( 0 , TRANSLATION _ BUNDLE , <nl> - WRONG _ LANGUAGE _ CODE _ KEY , new Object [ ] { code } , getId ( ) , getClass ( ) , null ) ; <nl> + WRONG _ LANGUAGE _ CODE _ KEY , new Object [ ] { code } , getId ( ) , getClass ( ) , null ) ; <nl> final String exceptionMessage = String . format ( Locale . ROOT , <nl> - " % s [ % s ] " , msg . getMessage ( ) , TranslationCheck . class . getSimpleName ( ) ) ; <nl> + " % s [ % s ] " , msg . getMessage ( ) , TranslationCheck . class . getSimpleName ( ) ) ; <nl> throw new IllegalArgumentException ( exceptionMessage ) ; <nl> } <nl> } <nl> @ @ - 258 , 35 + 234 , 28 @ @ public class TranslationCheck extends AbstractFileSetCheck { <nl> return valid ; <nl> } <nl> <nl> - / * * <nl> - * Groups a set of files into bundles . <nl> - * Only files , which names match base name regexp pattern will be grouped . <nl> - * @ param files set of files . <nl> - * @ param baseNameRegexp base name regexp pattern . <nl> - * @ return set of ResourceBundles . <nl> - * / <nl> - private static Set < ResourceBundle > groupFilesIntoBundles ( Set < File > files , <nl> - Pattern baseNameRegexp ) { <nl> - final Set < ResourceBundle > resourceBundles = Sets . newHashSet ( ) ; <nl> - for ( File currentFile : files ) { <nl> - final String fileName = currentFile . getName ( ) ; <nl> - final String baseName = extractBaseName ( fileName ) ; <nl> - final Matcher baseNameMatcher = baseNameRegexp . matcher ( baseName ) ; <nl> - if ( baseNameMatcher . matches ( ) ) { <nl> - final String extension = Files . getFileExtension ( fileName ) ; <nl> - final String path = getPath ( currentFile . getAbsolutePath ( ) ) ; <nl> - final ResourceBundle newBundle = new ResourceBundle ( baseName , path , extension ) ; <nl> - final Optional < ResourceBundle > bundle = findBundle ( resourceBundles , newBundle ) ; <nl> - if ( bundle . isPresent ( ) ) { <nl> - bundle . get ( ) . addFile ( currentFile ) ; <nl> - } <nl> - else { <nl> - newBundle . addFile ( currentFile ) ; <nl> - resourceBundles . add ( newBundle ) ; <nl> - } <nl> - } <nl> + @ Override <nl> + public void beginProcessing ( String charset ) { <nl> + super . beginProcessing ( charset ) ; <nl> + filesToProcess . clear ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected void processFiltered ( File file , List < String > lines ) { <nl> + / / We just collecting files for processing at finishProcessing ( ) <nl> + filesToProcess . add ( file ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void finishProcessing ( ) { <nl> + super . finishProcessing ( ) ; <nl> + <nl> + final Set < ResourceBundle > bundles = groupFilesIntoBundles ( filesToProcess , baseNamePattern ) ; <nl> + for ( ResourceBundle currentBundle : bundles ) { <nl> + checkExistenceOfDefaultTranslation ( currentBundle ) ; <nl> + checkExistenceOfRequiredTranslations ( currentBundle ) ; <nl> + checkTranslationKeys ( currentBundle ) ; <nl> } <nl> - return resourceBundles ; <nl> } <nl> <nl> / * * <nl> @ @ - 317 , 47 + 286 , 6 @ @ public class TranslationCheck extends AbstractFileSetCheck { <nl> } <nl> <nl> / * * <nl> - * Checks resource files in bundle for consistency regarding their keys . <nl> - * All files in bundle must have the same key set . If this is not the case <nl> - * an error message is posted giving information which key misses in which file . <nl> - * @ param bundle resource bundle . <nl> - * / <nl> - private void checkTranslationKeys ( ResourceBundle bundle ) { <nl> - final Set < File > filesInBundle = bundle . getFiles ( ) ; <nl> - if ( filesInBundle . size ( ) > 1 ) { <nl> - / / build a map from files to the keys they contain <nl> - final Set < String > allTranslationKeys = Sets . newHashSet ( ) ; <nl> - final SetMultimap < File , String > filesAssociatedWithKeys = HashMultimap . create ( ) ; <nl> - for ( File currentFile : filesInBundle ) { <nl> - final Set < String > keysInCurrentFile = getTranslationKeys ( currentFile ) ; <nl> - allTranslationKeys . addAll ( keysInCurrentFile ) ; <nl> - filesAssociatedWithKeys . putAll ( currentFile , keysInCurrentFile ) ; <nl> - } <nl> - checkFilesForConsistencyRegardingTheirKeys ( filesAssociatedWithKeys , allTranslationKeys ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * Searches for specific resource bundle in a set of resource bundles . <nl> - * @ param bundles set of resource bundles . <nl> - * @ param targetBundle target bundle to search for . <nl> - * @ return Guava ' s Optional of resource bundle ( present if target bundle is found ) . <nl> - * / <nl> - private static Optional < ResourceBundle > findBundle ( Set < ResourceBundle > bundles , <nl> - ResourceBundle targetBundle ) { <nl> - Optional < ResourceBundle > result = Optional . absent ( ) ; <nl> - for ( ResourceBundle currentBundle : bundles ) { <nl> - if ( targetBundle . getBaseName ( ) . equals ( currentBundle . getBaseName ( ) ) <nl> - & & targetBundle . getExtension ( ) . equals ( currentBundle . getExtension ( ) ) <nl> - & & targetBundle . getPath ( ) . equals ( currentBundle . getPath ( ) ) ) { <nl> - result = Optional . of ( currentBundle ) ; <nl> - break ; <nl> - } <nl> - } <nl> - return result ; <nl> - } <nl> - <nl> - / * * <nl> * Returns the name of translation file which is absent in resource bundle or Guava ' s Optional , <nl> * if there is not missing translation . <nl> * @ param bundle resource bundle . <nl> @ @ - 373 , 7 + 301 , 7 @ @ public class TranslationCheck extends AbstractFileSetCheck { <nl> if ( languageCode = = null ) { <nl> searchForDefaultTranslation = true ; <nl> fileNameRegexp = String . format ( Locale . ROOT , REGEXP _ FORMAT _ TO _ CHECK _ DEFAULT _ TRANSLATIONS , <nl> - baseName , extension ) ; <nl> + baseName , extension ) ; <nl> } <nl> else { <nl> searchForDefaultTranslation = false ; <nl> @ @ - 384 , 17 + 312 , 81 @ @ public class TranslationCheck extends AbstractFileSetCheck { <nl> if ( ! bundle . containsFile ( fileNameRegexp ) ) { <nl> if ( searchForDefaultTranslation ) { <nl> missingFileName = Optional . of ( String . format ( Locale . ROOT , <nl> - DEFAULT _ TRANSLATION _ FILE _ NAME _ FORMATTER , baseName , extension ) ) ; <nl> + DEFAULT _ TRANSLATION _ FILE _ NAME _ FORMATTER , baseName , extension ) ) ; <nl> } <nl> else { <nl> missingFileName = Optional . of ( String . format ( Locale . ROOT , <nl> - FILE _ NAME _ WITH _ LANGUAGE _ CODE _ FORMATTER , baseName , languageCode , extension ) ) ; <nl> + FILE _ NAME _ WITH _ LANGUAGE _ CODE _ FORMATTER , baseName , languageCode , extension ) ) ; <nl> } <nl> } <nl> return missingFileName ; <nl> } <nl> <nl> / * * <nl> + * Logs that translation file is missing . <nl> + * @ param filePath file path . <nl> + * @ param fileName file name . <nl> + * / <nl> + private void logMissingTranslation ( String filePath , String fileName ) { <nl> + final MessageDispatcher dispatcher = getMessageDispatcher ( ) ; <nl> + dispatcher . fireFileStarted ( filePath ) ; <nl> + log ( 0 , MSG _ KEY _ MISSING _ TRANSLATION _ FILE , fileName ) ; <nl> + fireErrors ( filePath ) ; <nl> + dispatcher . fireFileFinished ( filePath ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Groups a set of files into bundles . <nl> + * Only files , which names match base name regexp pattern will be grouped . <nl> + * @ param files set of files . <nl> + * @ param baseNameRegexp base name regexp pattern . <nl> + * @ return set of ResourceBundles . <nl> + * / <nl> + private static Set < ResourceBundle > groupFilesIntoBundles ( Set < File > files , <nl> + Pattern baseNameRegexp ) { <nl> + final Set < ResourceBundle > resourceBundles = Sets . newHashSet ( ) ; <nl> + for ( File currentFile : files ) { <nl> + final String fileName = currentFile . getName ( ) ; <nl> + final String baseName = extractBaseName ( fileName ) ; <nl> + final Matcher baseNameMatcher = baseNameRegexp . matcher ( baseName ) ; <nl> + if ( baseNameMatcher . matches ( ) ) { <nl> + final String extension = Files . getFileExtension ( fileName ) ; <nl> + final String path = getPath ( currentFile . getAbsolutePath ( ) ) ; <nl> + final ResourceBundle newBundle = new ResourceBundle ( baseName , path , extension ) ; <nl> + final Optional < ResourceBundle > bundle = findBundle ( resourceBundles , newBundle ) ; <nl> + if ( bundle . isPresent ( ) ) { <nl> + bundle . get ( ) . addFile ( currentFile ) ; <nl> + } <nl> + else { <nl> + newBundle . addFile ( currentFile ) ; <nl> + resourceBundles . add ( newBundle ) ; <nl> + } <nl> + } <nl> + } <nl> + return resourceBundles ; <nl> + } <nl> + <nl> + / * * <nl> + * Searches for specific resource bundle in a set of resource bundles . <nl> + * @ param bundles set of resource bundles . <nl> + * @ param targetBundle target bundle to search for . <nl> + * @ return Guava ' s Optional of resource bundle ( present if target bundle is found ) . <nl> + * / <nl> + private static Optional < ResourceBundle > findBundle ( Set < ResourceBundle > bundles , <nl> + ResourceBundle targetBundle ) { <nl> + Optional < ResourceBundle > result = Optional . absent ( ) ; <nl> + for ( ResourceBundle currentBundle : bundles ) { <nl> + if ( targetBundle . getBaseName ( ) . equals ( currentBundle . getBaseName ( ) ) <nl> + & & targetBundle . getExtension ( ) . equals ( currentBundle . getExtension ( ) ) <nl> + & & targetBundle . getPath ( ) . equals ( currentBundle . getPath ( ) ) ) { <nl> + result = Optional . of ( currentBundle ) ; <nl> + break ; <nl> + } <nl> + } <nl> + return result ; <nl> + } <nl> + <nl> + / * * <nl> * Extracts the base name ( the unique prefix ) of resource bundle from translation file name . <nl> * For example " messages " is the base name of " messages . properties " , <nl> * " messages _ de _ AT . properties " , " messages _ en . properties " , etc . <nl> @ @ - 438 , 26 + 430 , 24 @ @ public class TranslationCheck extends AbstractFileSetCheck { <nl> } <nl> <nl> / * * <nl> - * Loads the keys from the specified translation file into a set . <nl> - * @ param file translation file . <nl> - * @ return a Set object which holds the loaded keys . <nl> + * Checks resource files in bundle for consistency regarding their keys . <nl> + * All files in bundle must have the same key set . If this is not the case <nl> + * an error message is posted giving information which key misses in which file . <nl> + * @ param bundle resource bundle . <nl> * / <nl> - private Set < String > getTranslationKeys ( File file ) { <nl> - Set < String > keys = Sets . newHashSet ( ) ; <nl> - InputStream inStream = null ; <nl> - try { <nl> - inStream = new FileInputStream ( file ) ; <nl> - final Properties translations = new Properties ( ) ; <nl> - translations . load ( inStream ) ; <nl> - keys = translations . stringPropertyNames ( ) ; <nl> - } <nl> - catch ( final IOException ex ) { <nl> - logIoException ( ex , file ) ; <nl> - } <nl> - finally { <nl> - Closeables . closeQuietly ( inStream ) ; <nl> + private void checkTranslationKeys ( ResourceBundle bundle ) { <nl> + final Set < File > filesInBundle = bundle . getFiles ( ) ; <nl> + if ( filesInBundle . size ( ) > 1 ) { <nl> + / / build a map from files to the keys they contain <nl> + final Set < String > allTranslationKeys = Sets . newHashSet ( ) ; <nl> + final SetMultimap < File , String > filesAssociatedWithKeys = HashMultimap . create ( ) ; <nl> + for ( File currentFile : filesInBundle ) { <nl> + final Set < String > keysInCurrentFile = getTranslationKeys ( currentFile ) ; <nl> + allTranslationKeys . addAll ( keysInCurrentFile ) ; <nl> + filesAssociatedWithKeys . putAll ( currentFile , keysInCurrentFile ) ; <nl> + } <nl> + checkFilesForConsistencyRegardingTheirKeys ( filesAssociatedWithKeys , allTranslationKeys ) ; <nl> } <nl> - return keys ; <nl> } <nl> <nl> / * * <nl> @ @ - 485 , 16 + 475 , 26 @ @ public class TranslationCheck extends AbstractFileSetCheck { <nl> } <nl> <nl> / * * <nl> - * Logs that translation file is missing . <nl> - * @ param filePath file path . <nl> - * @ param fileName file name . <nl> + * Loads the keys from the specified translation file into a set . <nl> + * @ param file translation file . <nl> + * @ return a Set object which holds the loaded keys . <nl> * / <nl> - private void logMissingTranslation ( String filePath , String fileName ) { <nl> - final MessageDispatcher dispatcher = getMessageDispatcher ( ) ; <nl> - dispatcher . fireFileStarted ( filePath ) ; <nl> - log ( 0 , MSG _ KEY _ MISSING _ TRANSLATION _ FILE , fileName ) ; <nl> - fireErrors ( filePath ) ; <nl> - dispatcher . fireFileFinished ( filePath ) ; <nl> + private Set < String > getTranslationKeys ( File file ) { <nl> + Set < String > keys = Sets . newHashSet ( ) ; <nl> + InputStream inStream = null ; <nl> + try { <nl> + inStream = new FileInputStream ( file ) ; <nl> + final Properties translations = new Properties ( ) ; <nl> + translations . load ( inStream ) ; <nl> + keys = translations . stringPropertyNames ( ) ; <nl> + } <nl> + catch ( final IOException ex ) { <nl> + logIoException ( ex , file ) ; <nl> + } <nl> + finally { <nl> + Closeables . closeQuietly ( inStream ) ; <nl> + } <nl> + return keys ; <nl> } <nl> <nl> / * *

TEST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . java b / src / main / java / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . java 
 index 79e809b . . 8400d91 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . java 
 @ @ - 39 , 7 + 39 , 7 @ @ public interface ExternalResourceHolder { 
 * Returns a set of external configuration resource locations which are used by the module . 
 * ATTENTION ! 
 * If ' getExternalResourceLocations ( ) ' return null , there will be 
 - * { @ link NullPointerException } in { @ link Checker # getExternalResourceLocations ( ) } . 
 + * { @ link NullPointerException } in { @ link Checker } . 
 * Such behaviour will signal that your module ( check or filter ) is designed incorrectrly . 
 * It make sence to return an empty set from ' getExternalResourceLocations ( ) ' 
 * only for composite modules like { @ link com . puppycrawl . tools . checkstyle . TreeWalker } . 
 diff - - git a / src / xdocs / writingchecks . xml b / src / xdocs / writingchecks . xml 
 index b9b8db5 . . c61d54a 100644 
 - - - a / src / xdocs / writingchecks . xml 
 + + + b / src / xdocs / writingchecks . xml 
 @ @ - 282 , 7 + 282 , 7 @ @ public class MethodLimitCheck extends AbstractCheck 
 
 < p > 
 There are four methods in Check class to control the processed 
 - < a href = " http : / / checkstyle . sourceforge . net / apidocs / index . html " > TokenTypes < / a > - 
 + < a href = " apidocs / index . html " > TokenTypes < / a > - 
 one setter 
 < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / AbstractCheck . html # setTokens - java . lang . String . . . - " > 
 setTokens ( ) < / a > , which is used to define a custom set ( which is different 
 @ @ - 612 , 22 + 612 , 22 @ @ public class LimitImplementationFiles extends AbstractFileSetCheck 
 < p > 
 Checkstyle can cache external configuration resources of any kind which are used by your 
 check . If you want to do such a thing , you should implement 
 - < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html " > ExternalResourceHolder < / a > 
 + < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html " > ExternalResourceHolder < / a > 
 interface . Such module must declare external resource locations as a set of Strings 
 - which will be returned from < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > 
 + which will be returned from < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > 
 method . This will allow Checkstyle to invalidate ( clear ) cache when the content of at 
 least one external configuration resource of your check is changed . 
 < / p > 
 < p > 
 ATTENTION ! 
 < li > 
 - If < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > 
 - return null , there will be NullPointerException in < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / Checker . html # getExternalResourceLocations - - " > Checker < / a > . 
 + If < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > 
 + return null , there will be NullPointerException in < a href = " apidocs / com / puppycrawl / tools / checkstyle / Checker . html " > Checker < / a > . 
 Such behaviour will signal that your module ( check or filter ) is designed incorrectrly . 
 < / li > 
 < li > 
 - It make sence to return an empty set from < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > 
 - only for composite modules like < a href = " http : / / checkstyle . sourceforge . net / apidocs / com / puppycrawl / tools / checkstyle / TreeWalker . html " > TreeWalker < / a > . 
 + It make sence to return an empty set from < a href = " apidocs / com / puppycrawl / tools / checkstyle / api / ExternalResourceHolder . html # getExternalResourceLocations - - " > getExternalResourceLocations < / a > 
 + only for composite modules like < a href = " apidocs / com / puppycrawl / tools / checkstyle / TreeWalker . html " > TreeWalker < / a > . 
 < / li > 
 < / p > 
 < / section > 
 diff - - git a / src / xdocs / writingjavadocchecks . xml . vm b / src / xdocs / writingjavadocchecks . xml . vm 
 index 19ee6c4 . . 586ef7f 100644 
 - - - a / src / xdocs / writingjavadocchecks . xml . vm 
 + + + b / src / xdocs / writingjavadocchecks . xml . vm 
 @ @ - 54 , 11 + 54 , 11 @ @ public class MyClass { 
 The comment should be written in XHTML to be correctly processed by Checkstyle . This means that every HTML tag should have matching closed HTML tag or it is self - closed one ( singlton tag ) . 
 The only exceptions are & lt ; p & gt ; , & lt ; li & gt ; , & lt ; tr & gt ; , & lt ; td & gt ; , & lt ; th & gt ; , & lt ; body & gt ; , & lt ; colgroup & gt ; , & lt ; dd & gt ; , & lt ; dt & gt ; , & lt ; head & gt ; , & lt ; html & gt ; , & lt ; option & gt ; , 
 & lt ; tbody & gt ; , & lt ; thead & gt ; , & lt ; tfoot & gt ; and Checkstyle won ' t show error about missing closing tag , however , it leads to broken XHTML structure and to 
 - not - nested content of the HTML tags in Abstract Syntax Tree of the Javadoc comment . See examples at < a href = " HTML _ Code _ In _ Javadoc _ Comments " > HTML Code In Javadoc Comments < / a > section . 
 + not - nested content of the HTML tags in Abstract Syntax Tree of the Javadoc comment . See examples at < a href = " # HTML _ Code _ In _ Javadoc _ Comments " > HTML Code In Javadoc Comments < / a > section . 
 < / p > 
 < p > 
 Javadoc parser requires XHTML to be used in Javadoc comments , i . e . if there is some open tag ( for example & lt ; div & gt ; ) then there have to be its close tag & lt ; / div & gt ; . 
 - This means that if Javadoc comment has incorrect XHTML structure then Javadoc Parser will fail processing the comment , therefore , your new Check can ' t get its parse tree and process anything from this Javadoc comment . For more details and examples go to < a href = " HTML _ Code _ In _ Javadoc _ Comments " > HTML Code In Javadoc Comments < / a > section . 
 + This means that if Javadoc comment has incorrect XHTML structure then Javadoc Parser will fail processing the comment , therefore , your new Check can ' t get its parse tree and process anything from this Javadoc comment . For more details and examples go to < a href = " # HTML _ Code _ In _ Javadoc _ Comments " > HTML Code In Javadoc Comments < / a > section . 
 < / p > 
 < p > 
 Javadoc grammar requires XHTML , but it can also parse some parts of HTML code ( like some unclosed tags ) . If HTML tags are not closed Javadoc grammar cannot determine content of these tags ,

NEAREST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / TranslationCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / TranslationCheck . java 
 index 8965e6a . . f310fe9 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / TranslationCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / TranslationCheck . java 
 @ @ - 201 , 30 + 201 , 6 @ @ public class TranslationCheck extends AbstractFileSetCheck { 
 validateUserSpecifiedLanguageCodes ( requiredTranslations ) ; 
 } 
 
 - @ Override 
 - public void beginProcessing ( String charset ) { 
 - super . beginProcessing ( charset ) ; 
 - filesToProcess . clear ( ) ; 
 - } 
 - 
 - @ Override 
 - protected void processFiltered ( File file , List < String > lines ) { 
 - / / We just collecting files for processing at finishProcessing ( ) 
 - filesToProcess . add ( file ) ; 
 - } 
 - 
 - @ Override 
 - public void finishProcessing ( ) { 
 - super . finishProcessing ( ) ; 
 - 
 - final Set < ResourceBundle > bundles = groupFilesIntoBundles ( filesToProcess , baseNamePattern ) ; 
 - for ( ResourceBundle currentBundle : bundles ) { 
 - checkExistenceOfDefaultTranslation ( currentBundle ) ; 
 - checkExistenceOfRequiredTranslations ( currentBundle ) ; 
 - checkTranslationKeys ( currentBundle ) ; 
 - } 
 - } 
 - 
 / * * 
 * Validates the correctness of user specififed language codes for the check . 
 * @ param languageCodes user specified language codes for the check . 
 @ @ - 233 , 9 + 209 , 9 @ @ public class TranslationCheck extends AbstractFileSetCheck { 
 for ( String code : languageCodes ) { 
 if ( ! isValidLanguageCode ( code ) ) { 
 final LocalizedMessage msg = new LocalizedMessage ( 0 , TRANSLATION _ BUNDLE , 
 - WRONG _ LANGUAGE _ CODE _ KEY , new Object [ ] { code } , getId ( ) , getClass ( ) , null ) ; 
 + WRONG _ LANGUAGE _ CODE _ KEY , new Object [ ] { code } , getId ( ) , getClass ( ) , null ) ; 
 final String exceptionMessage = String . format ( Locale . ROOT , 
 - " % s [ % s ] " , msg . getMessage ( ) , TranslationCheck . class . getSimpleName ( ) ) ; 
 + " % s [ % s ] " , msg . getMessage ( ) , TranslationCheck . class . getSimpleName ( ) ) ; 
 throw new IllegalArgumentException ( exceptionMessage ) ; 
 } 
 } 
 @ @ - 258 , 35 + 234 , 28 @ @ public class TranslationCheck extends AbstractFileSetCheck { 
 return valid ; 
 } 
 
 - / * * 
 - * Groups a set of files into bundles . 
 - * Only files , which names match base name regexp pattern will be grouped . 
 - * @ param files set of files . 
 - * @ param baseNameRegexp base name regexp pattern . 
 - * @ return set of ResourceBundles . 
 - * / 
 - private static Set < ResourceBundle > groupFilesIntoBundles ( Set < File > files , 
 - Pattern baseNameRegexp ) { 
 - final Set < ResourceBundle > resourceBundles = Sets . newHashSet ( ) ; 
 - for ( File currentFile : files ) { 
 - final String fileName = currentFile . getName ( ) ; 
 - final String baseName = extractBaseName ( fileName ) ; 
 - final Matcher baseNameMatcher = baseNameRegexp . matcher ( baseName ) ; 
 - if ( baseNameMatcher . matches ( ) ) { 
 - final String extension = Files . getFileExtension ( fileName ) ; 
 - final String path = getPath ( currentFile . getAbsolutePath ( ) ) ; 
 - final ResourceBundle newBundle = new ResourceBundle ( baseName , path , extension ) ; 
 - final Optional < ResourceBundle > bundle = findBundle ( resourceBundles , newBundle ) ; 
 - if ( bundle . isPresent ( ) ) { 
 - bundle . get ( ) . addFile ( currentFile ) ; 
 - } 
 - else { 
 - newBundle . addFile ( currentFile ) ; 
 - resourceBundles . add ( newBundle ) ; 
 - } 
 - } 
 + @ Override 
 + public void beginProcessing ( String charset ) { 
 + super . beginProcessing ( charset ) ; 
 + filesToProcess . clear ( ) ; 
 + } 
 + 
 + @ Override 
 + protected void processFiltered ( File file , List < String > lines ) { 
 + / / We just collecting files for processing at finishProcessing ( ) 
 + filesToProcess . add ( file ) ; 
 + } 
 + 
 + @ Override 
 + public void finishProcessing ( ) { 
 + super . finishProcessing ( ) ; 
 + 
 + final Set < ResourceBundle > bundles = groupFilesIntoBundles ( filesToProcess , baseNamePattern ) ; 
 + for ( ResourceBundle currentBundle : bundles ) { 
 + checkExistenceOfDefaultTranslation ( currentBundle ) ; 
 + checkExistenceOfRequiredTranslations ( currentBundle ) ; 
 + checkTranslationKeys ( currentBundle ) ; 
 } 
 - return resourceBundles ; 
 } 
 
 / * * 
 @ @ - 317 , 47 + 286 , 6 @ @ public class TranslationCheck extends AbstractFileSetCheck { 
 } 
 
 / * * 
 - * Checks resource files in bundle for consistency regarding their keys . 
 - * All files in bundle must have the same key set . If this is not the case 
 - * an error message is posted giving information which key misses in which file . 
 - * @ param bundle resource bundle . 
 - * / 
 - private void checkTranslationKeys ( ResourceBundle bundle ) { 
 - final Set < File > filesInBundle = bundle . getFiles ( ) ; 
 - if ( filesInBundle . size ( ) > 1 ) { 
 - / / build a map from files to the keys they contain 
 - final Set < String > allTranslationKeys = Sets . newHashSet ( ) ; 
 - final SetMultimap < File , String > filesAssociatedWithKeys = HashMultimap . create ( ) ; 
 - for ( File currentFile : filesInBundle ) { 
 - final Set < String > keysInCurrentFile = getTranslationKeys ( currentFile ) ; 
 - allTranslationKeys . addAll ( keysInCurrentFile ) ; 
 - filesAssociatedWithKeys . putAll ( currentFile , keysInCurrentFile ) ; 
 - } 
 - checkFilesForConsistencyRegardingTheirKeys ( filesAssociatedWithKeys , allTranslationKeys ) ; 
 - } 
 - } 
 - 
 - / * * 
 - * Searches for specific resource bundle in a set of resource bundles . 
 - * @ param bundles set of resource bundles . 
 - * @ param targetBundle target bundle to search for . 
 - * @ return Guava ' s Optional of resource bundle ( present if target bundle is found ) . 
 - * / 
 - private static Optional < ResourceBundle > findBundle ( Set < ResourceBundle > bundles , 
 - ResourceBundle targetBundle ) { 
 - Optional < ResourceBundle > result = Optional . absent ( ) ; 
 - for ( ResourceBundle currentBundle : bundles ) { 
 - if ( targetBundle . getBaseName ( ) . equals ( currentBundle . getBaseName ( ) ) 
 - & & targetBundle . getExtension ( ) . equals ( currentBundle . getExtension ( ) ) 
 - & & targetBundle . getPath ( ) . equals ( currentBundle . getPath ( ) ) ) { 
 - result = Optional . of ( currentBundle ) ; 
 - break ; 
 - } 
 - } 
 - return result ; 
 - } 
 - 
 - / * * 
 * Returns the name of translation file which is absent in resource bundle or Guava ' s Optional , 
 * if there is not missing translation . 
 * @ param bundle resource bundle . 
 @ @ - 373 , 7 + 301 , 7 @ @ public class TranslationCheck extends AbstractFileSetCheck { 
 if ( languageCode = = null ) { 
 searchForDefaultTranslation = true ; 
 fileNameRegexp = String . format ( Locale . ROOT , REGEXP _ FORMAT _ TO _ CHECK _ DEFAULT _ TRANSLATIONS , 
 - baseName , extension ) ; 
 + baseName , extension ) ; 
 } 
 else { 
 searchForDefaultTranslation = false ; 
 @ @ - 384 , 17 + 312 , 81 @ @ public class TranslationCheck extends AbstractFileSetCheck { 
 if ( ! bundle . containsFile ( fileNameRegexp ) ) { 
 if ( searchForDefaultTranslation ) { 
 missingFileName = Optional . of ( String . format ( Locale . ROOT , 
 - DEFAULT _ TRANSLATION _ FILE _ NAME _ FORMATTER , baseName , extension ) ) ; 
 + DEFAULT _ TRANSLATION _ FILE _ NAME _ FORMATTER , baseName , extension ) ) ; 
 } 
 else { 
 missingFileName = Optional . of ( String . format ( Locale . ROOT , 
 - FILE _ NAME _ WITH _ LANGUAGE _ CODE _ FORMATTER , baseName , languageCode , extension ) ) ; 
 + FILE _ NAME _ WITH _ LANGUAGE _ CODE _ FORMATTER , baseName , languageCode , extension ) ) ; 
 } 
 } 
 return missingFileName ; 
 } 
 
 / * * 
 + * Logs that translation file is missing . 
 + * @ param filePath file path . 
 + * @ param fileName file name . 
 + * / 
 + private void logMissingTranslation ( String filePath , String fileName ) { 
 + final MessageDispatcher dispatcher = getMessageDispatcher ( ) ; 
 + dispatcher . fireFileStarted ( filePath ) ; 
 + log ( 0 , MSG _ KEY _ MISSING _ TRANSLATION _ FILE , fileName ) ; 
 + fireErrors ( filePath ) ; 
 + dispatcher . fireFileFinished ( filePath ) ; 
 + } 
 + 
 + / * * 
 + * Groups a set of files into bundles . 
 + * Only files , which names match base name regexp pattern will be grouped . 
 + * @ param files set of files . 
 + * @ param baseNameRegexp base name regexp pattern . 
 + * @ return set of ResourceBundles . 
 + * / 
 + private static Set < ResourceBundle > groupFilesIntoBundles ( Set < File > files , 
 + Pattern baseNameRegexp ) { 
 + final Set < ResourceBundle > resourceBundles = Sets . newHashSet ( ) ; 
 + for ( File currentFile : files ) { 
 + final String fileName = currentFile . getName ( ) ; 
 + final String baseName = extractBaseName ( fileName ) ; 
 + final Matcher baseNameMatcher = baseNameRegexp . matcher ( baseName ) ; 
 + if ( baseNameMatcher . matches ( ) ) { 
 + final String extension = Files . getFileExtension ( fileName ) ; 
 + final String path = getPath ( currentFile . getAbsolutePath ( ) ) ; 
 + final ResourceBundle newBundle = new ResourceBundle ( baseName , path , extension ) ; 
 + final Optional < ResourceBundle > bundle = findBundle ( resourceBundles , newBundle ) ; 
 + if ( bundle . isPresent ( ) ) { 
 + bundle . get ( ) . addFile ( currentFile ) ; 
 + } 
 + else { 
 + newBundle . addFile ( currentFile ) ; 
 + resourceBundles . add ( newBundle ) ; 
 + } 
 + } 
 + } 
 + return resourceBundles ; 
 + } 
 + 
 + / * * 
 + * Searches for specific resource bundle in a set of resource bundles . 
 + * @ param bundles set of resource bundles . 
 + * @ param targetBundle target bundle to search for . 
 + * @ return Guava ' s Optional of resource bundle ( present if target bundle is found ) . 
 + * / 
 + private static Optional < ResourceBundle > findBundle ( Set < ResourceBundle > bundles , 
 + ResourceBundle targetBundle ) { 
 + Optional < ResourceBundle > result = Optional . absent ( ) ; 
 + for ( ResourceBundle currentBundle : bundles ) { 
 + if ( targetBundle . getBaseName ( ) . equals ( currentBundle . getBaseName ( ) ) 
 + & & targetBundle . getExtension ( ) . equals ( currentBundle . getExtension ( ) ) 
 + & & targetBundle . getPath ( ) . equals ( currentBundle . getPath ( ) ) ) { 
 + result = Optional . of ( currentBundle ) ; 
 + break ; 
 + } 
 + } 
 + return result ; 
 + } 
 + 
 + / * * 
 * Extracts the base name ( the unique prefix ) of resource bundle from translation file name . 
 * For example " messages " is the base name of " messages . properties " , 
 * " messages _ de _ AT . properties " , " messages _ en . properties " , etc . 
 @ @ - 438 , 26 + 430 , 24 @ @ public class TranslationCheck extends AbstractFileSetCheck { 
 } 
 
 / * * 
 - * Loads the keys from the specified translation file into a set . 
 - * @ param file translation file . 
 - * @ return a Set object which holds the loaded keys . 
 + * Checks resource files in bundle for consistency regarding their keys . 
 + * All files in bundle must have the same key set . If this is not the case 
 + * an error message is posted giving information which key misses in which file . 
 + * @ param bundle resource bundle . 
 * / 
 - private Set < String > getTranslationKeys ( File file ) { 
 - Set < String > keys = Sets . newHashSet ( ) ; 
 - InputStream inStream = null ; 
 - try { 
 - inStream = new FileInputStream ( file ) ; 
 - final Properties translations = new Properties ( ) ; 
 - translations . load ( inStream ) ; 
 - keys = translations . stringPropertyNames ( ) ; 
 - } 
 - catch ( final IOException ex ) { 
 - logIoException ( ex , file ) ; 
 - } 
 - finally { 
 - Closeables . closeQuietly ( inStream ) ; 
 + private void checkTranslationKeys ( ResourceBundle bundle ) { 
 + final Set < File > filesInBundle = bundle . getFiles ( ) ; 
 + if ( filesInBundle . size ( ) > 1 ) { 
 + / / build a map from files to the keys they contain 
 + final Set < String > allTranslationKeys = Sets . newHashSet ( ) ; 
 + final SetMultimap < File , String > filesAssociatedWithKeys = HashMultimap . create ( ) ; 
 + for ( File currentFile : filesInBundle ) { 
 + final Set < String > keysInCurrentFile = getTranslationKeys ( currentFile ) ; 
 + allTranslationKeys . addAll ( keysInCurrentFile ) ; 
 + filesAssociatedWithKeys . putAll ( currentFile , keysInCurrentFile ) ; 
 + } 
 + checkFilesForConsistencyRegardingTheirKeys ( filesAssociatedWithKeys , allTranslationKeys ) ; 
 } 
 - return keys ; 
 } 
 
 / * * 
 @ @ - 485 , 16 + 475 , 26 @ @ public class TranslationCheck extends AbstractFileSetCheck { 
 } 
 
 / * * 
 - * Logs that translation file is missing . 
 - * @ param filePath file path . 
 - * @ param fileName file name . 
 + * Loads the keys from the specified translation file into a set . 
 + * @ param file translation file . 
 + * @ return a Set object which holds the loaded keys . 
 * / 
 - private void logMissingTranslation ( String filePath , String fileName ) { 
 - final MessageDispatcher dispatcher = getMessageDispatcher ( ) ; 
 - dispatcher . fireFileStarted ( filePath ) ; 
 - log ( 0 , MSG _ KEY _ MISSING _ TRANSLATION _ FILE , fileName ) ; 
 - fireErrors ( filePath ) ; 
 - dispatcher . fireFileFinished ( filePath ) ; 
 + private Set < String > getTranslationKeys ( File file ) { 
 + Set < String > keys = Sets . newHashSet ( ) ; 
 + InputStream inStream = null ; 
 + try { 
 + inStream = new FileInputStream ( file ) ; 
 + final Properties translations = new Properties ( ) ; 
 + translations . load ( inStream ) ; 
 + keys = translations . stringPropertyNames ( ) ; 
 + } 
 + catch ( final IOException ex ) { 
 + logIoException ( ex , file ) ; 
 + } 
 + finally { 
 + Closeables . closeQuietly ( inStream ) ; 
 + } 
 + return keys ; 
 } 
 
 / * *
