BLEU SCORE: 0.013540902819918828

TEST MSG: Issue # 3006 : Add test inputs taken from Guava and Findbugs
GENERATED MSG: Variable Declaration Usage Distance Check compilable UT input ( took from sevntu - checks input , already fixed it several months ago )

TEST DIFF (one line): diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / FinalLocalVariableCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / FinalLocalVariableCheckTest . java <nl> index df5e10a . . 3b8205d 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / FinalLocalVariableCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / FinalLocalVariableCheckTest . java <nl> @ @ - 200 , 7 + 200 , 12 @ @ public class FinalLocalVariableCheckTest <nl> final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; <nl> <nl> final String [ ] expected = { <nl> - " 44 : 13 : " + " Variable ' i ' should be declared final . " , <nl> + " 49 : 13 : " + " Variable ' i ' should be declared final . " , <nl> + " 122 : 16 : " + " Variable ' path ' should be declared final . " , <nl> + " 126 : 20 : " + " Variable ' relativePath ' should be declared final . " , <nl> + " 202 : 17 : " + " Variable ' kind ' should be declared final . " , <nl> + " 207 : 24 : " + " Variable ' m ' should be declared final . " , <nl> + " 409 : 17 : " + " Variable ' increment ' should be declared final . " , <nl> } ; <nl> verify ( checkConfig , getPath ( " InputFinalLocalVariableAssignedMultipleTimes . java " ) , expected ) ; <nl> } <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputFinalLocalVariableAssignedMultipleTimes . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputFinalLocalVariableAssignedMultipleTimes . java <nl> index f7b126f . . fb96781 100644 <nl> - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputFinalLocalVariableAssignedMultipleTimes . java <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputFinalLocalVariableAssignedMultipleTimes . java <nl> @ @ - 1 , 5 + 1 , 10 @ @ <nl> package com . puppycrawl . tools . checkstyle . checks . coding ; <nl> <nl> + import java . util . HashMap ; <nl> + import java . util . SortedMap ; <nl> + <nl> + import com . google . common . collect . Maps ; <nl> + <nl> public class InputFinalLocalVariableAssignedMultipleTimes { <nl> <nl> void foo1 ( ) { <nl> @ @ - 111 , 4 + 116 , 330 @ @ public class InputFinalLocalVariableAssignedMultipleTimes { <nl> <nl> } <nl> } <nl> + <nl> + / / Taken from findbugs <nl> + public static String foo9 ( String filePath , String project ) { <nl> + String path = new String ( filePath ) ; / / violation <nl> + String commonPath ; <nl> + if ( project ! = null ) { <nl> + commonPath = " " ; <nl> + String relativePath = " " ; / / violation <nl> + if ( ! relativePath . equals ( path ) ) { <nl> + return relativePath ; <nl> + } <nl> + } <nl> + commonPath = " " ; <nl> + return commonPath ; <nl> + } <nl> + <nl> + / / Taken from findbugs <nl> + public int foo10 ( String factory1 , String factory2 ) { <nl> + int result = 0 ; <nl> + String s1 , s2 ; <nl> + switch ( result ) { <nl> + case 1 : <nl> + s1 = " Java " ; <nl> + s2 = " C # " ; <nl> + break ; <nl> + case 2 : <nl> + s1 = " C + + " ; <nl> + s2 = " Pascal " ; <nl> + ; <nl> + break ; <nl> + case 3 : <nl> + s1 = " Basic " ; <nl> + s2 = " Angol " ; <nl> + break ; <nl> + case 4 : <nl> + s1 = " JavaScript " ; <nl> + s2 = " Go " ; <nl> + break ; <nl> + case 5 : <nl> + default : <nl> + s1 = " F # " ; <nl> + s2 = " Objective C " ; <nl> + break ; <nl> + } <nl> + if ( s1 = = null ) { <nl> + s1 = " incorrect language " ; <nl> + } <nl> + if ( s2 = = null ) { <nl> + s2 = " incorrect language " ; <nl> + } <nl> + result = s1 . compareTo ( s2 ) ; <nl> + <nl> + if ( result = = 0 ) { <nl> + switch ( result ) { <nl> + case 1 : <nl> + s1 = " Java " ; <nl> + s2 = " C # " ; <nl> + break ; <nl> + case 2 : <nl> + default : <nl> + s1 = " C + + " ; <nl> + s2 = " C " ; <nl> + break ; <nl> + } <nl> + result = s1 . compareTo ( s2 ) ; <nl> + } <nl> + else if ( result = = 1 ) { <nl> + result = - 8 ; <nl> + } <nl> + return result ; <nl> + } <nl> + <nl> + / / Taken from findbugs <nl> + public String foo11 ( final Object o , boolean getMinimal ) { <nl> + <nl> + String n = System . lineSeparator ( ) ; <nl> + if ( n ! = null ) { <nl> + return n ; <nl> + } <nl> + <nl> + try { <nl> + <nl> + String className ; <nl> + int kind ; / / violation <nl> + boolean isParameterToInitMethodofAnonymousInnerClass = false ; <nl> + boolean isSyntheticMethod = false ; <nl> + if ( o instanceof String | | o instanceof Integer ) { <nl> + <nl> + String m ; / / violation <nl> + if ( o instanceof String ) { <nl> + m = ( String ) o ; <nl> + isSyntheticMethod = m . equals ( " " ) ; <nl> + kind = 1 ; <nl> + className = this . getClass ( ) . getName ( ) ; <nl> + } <nl> + else if ( o instanceof String ) { <nl> + m = " " ; <nl> + / / Don ' t <nl> + isSyntheticMethod = m . equals ( " " ) ; <nl> + className = this . getClass ( ) . getName ( ) ; <nl> + kind = 2 ; <nl> + if ( " < init > " . equals ( m . toLowerCase ( ) ) ) { <nl> + final int i = className . lastIndexOf ( ' $ ' ) ; <nl> + if ( i + 1 < className . length ( ) & & Character . isDigit ( className . charAt ( i + 1 ) ) ) { <nl> + isParameterToInitMethodofAnonymousInnerClass = true ; <nl> + } <nl> + } <nl> + } <nl> + else { <nl> + throw new IllegalStateException ( " impossible " ) ; <nl> + } <nl> + <nl> + if ( ! m . equals ( " " ) & & ! " < init > " . equals ( m . toLowerCase ( ) ) ) { <nl> + final String c = " className " ; <nl> + / / get inherited annotation <nl> + String inheritedAnnotations = new String ( ) ; <nl> + if ( c . charAt ( 1 ) > 0 ) { <nl> + <nl> + n = " " ; <nl> + if ( n ! = null ) { <nl> + inheritedAnnotations + = " " ; <nl> + } <nl> + } <nl> + for ( int i = 5 ; i < 10 ; i + + ) { <nl> + n = new String ( " " ) ; <nl> + if ( n ! = null ) { <nl> + inheritedAnnotations + = " " ; <nl> + } <nl> + } <nl> + if ( n = = null ) { <nl> + System . out . println ( " # of inherited annotations : " + inheritedAnnotations . length ( ) ) ; <nl> + } <nl> + if ( ! inheritedAnnotations . isEmpty ( ) ) { <nl> + if ( inheritedAnnotations . length ( ) = = 1 ) { <nl> + return inheritedAnnotations ; <nl> + } <nl> + if ( ! getMinimal ) { <nl> + return inheritedAnnotations ; <nl> + } <nl> + <nl> + String min = inheritedAnnotations ; <nl> + if ( min . length ( ) = = 0 ) { <nl> + inheritedAnnotations = null ; <nl> + min = inheritedAnnotations ; <nl> + } <nl> + return min ; <nl> + } <nl> + / / check to see if method is defined in this class ; <nl> + / / if not , on ' t consider default annotations <nl> + if ( inheritedAnnotations = = null ) { <nl> + return null ; <nl> + } <nl> + if ( inheritedAnnotations . equals ( " " ) ) { <nl> + System . out . println ( " looking for default annotations : " + " defines " + m ) ; <nl> + } <nl> + } / / if not static <nl> + } / / associated with method <nl> + else if ( o instanceof String ) { <nl> + <nl> + className = ( ( String ) o ) . getClass ( ) . getName ( ) ; <nl> + kind = 3 ; <nl> + } <nl> + else if ( o instanceof String ) { <nl> + assert false ; <nl> + className = ( String ) o ; <nl> + kind = 4 ; <nl> + } <nl> + else { <nl> + throw new IllegalArgumentException ( " Can ' t look up annotation for " + o . getClass ( ) . getName ( ) ) ; <nl> + } <nl> + <nl> + / / < init > method parameters for inner classes don ' t inherit default <nl> + / / annotations <nl> + / / since some of them are synthetic <nl> + if ( isParameterToInitMethodofAnonymousInnerClass ) { <nl> + return null ; <nl> + } <nl> + <nl> + / / synthetic elements should not inherit default annotations <nl> + if ( isSyntheticMethod ) { <nl> + return null ; <nl> + } <nl> + try { <nl> + final String c = new String ( className ) ; <nl> + <nl> + if ( c ! = null & & c . equals ( " " ) ) { <nl> + return null ; <nl> + } <nl> + } <nl> + catch ( Exception e ) { <nl> + assert true ; <nl> + } <nl> + <nl> + / / look for default annotation <nl> + n = new String ( className ) ; <nl> + if ( n = = null ) { <nl> + System . out . println ( " Default annotation for " + kind + " is " + n ) ; <nl> + } <nl> + if ( n ! = null ) { <nl> + return n ; <nl> + } <nl> + <nl> + n = new String ( className ) ; <nl> + if ( n = = null ) { <nl> + System . out . println ( " Default annotation for any is " + n ) ; <nl> + } <nl> + if ( n ! = null ) { <nl> + return n ; <nl> + } <nl> + <nl> + final int p = className . lastIndexOf ( ' . ' ) ; <nl> + className = className . substring ( 0 , p + 1 ) + " package - info " ; <nl> + n = new String ( className ) ; <nl> + if ( n = = null ) { <nl> + System . out . println ( " Default annotation for " + kind + " is " + n ) ; <nl> + } <nl> + if ( n ! = null ) { <nl> + return n ; <nl> + } <nl> + <nl> + n = new String ( className ) ; <nl> + if ( n = = null ) { <nl> + System . out . println ( " Default annotation for any is " + n ) ; <nl> + } <nl> + if ( n ! = null ) { <nl> + return n ; <nl> + } <nl> + <nl> + return n ; <nl> + } <nl> + catch ( Exception e ) { <nl> + System . out . println ( e ) ; <nl> + ; <nl> + return null ; <nl> + } <nl> + <nl> + } <nl> + <nl> + / / Taken from findbugs <nl> + private void foo12 ( Long start , Long end ) { <nl> + HashMap < Object , Object > headMap ; <nl> + if ( end < Long . MAX _ VALUE ) { <nl> + headMap = Maps . newHashMap ( ) ; <nl> + Long tailEnd = 1L ; <nl> + if ( tailEnd ! = null ) { <nl> + end = tailEnd ; <nl> + } <nl> + if ( ! headMap . isEmpty ( ) ) { <nl> + tailEnd = ( Long ) headMap . get ( headMap . size ( ) ) ; <nl> + if ( tailEnd > end ) { <nl> + end = tailEnd ; <nl> + } <nl> + } <nl> + } <nl> + headMap = Maps . newHashMap ( ) ; <nl> + if ( ! headMap . isEmpty ( ) ) { <nl> + final int headStart = headMap . size ( ) ; <nl> + final Long headEnd = ( Long ) headMap . get ( headStart ) ; <nl> + if ( headEnd > = start - 1 ) { <nl> + headMap . remove ( headStart ) ; <nl> + start = Long . valueOf ( headStart ) ; <nl> + } <nl> + } <nl> + headMap . clear ( ) ; <nl> + headMap . remove ( end ) ; <nl> + headMap . put ( start , end ) ; <nl> + } <nl> + <nl> + / / Taken from Guava <nl> + public static int foo13 ( int p , int q , int mode ) { <nl> + System . out . println ( mode ) ; <nl> + ; <nl> + if ( q = = 0 ) { <nl> + throw new ArithmeticException ( " / by zero " ) ; / / for GWT <nl> + } <nl> + final int div = p / q ; <nl> + final int rem = p - q * div ; / / equal to p % q <nl> + <nl> + if ( rem = = 0 ) { <nl> + return div ; <nl> + } <nl> + <nl> + / * <nl> + * Normal Java division rounds towards 0 , consistently with RoundingMode . DOWN . We just have to <nl> + * deal with the cases where rounding towards 0 is wrong , which typically depends on the sign of <nl> + * p / q . <nl> + * <nl> + * signum is 1 if p and q are both nonnegative or both negative , and - 1 otherwise . <nl> + * / <nl> + final int signum = 1 | ( ( p ^ q ) > > ( Integer . SIZE - 1 ) ) ; <nl> + boolean increment ; / / violation <nl> + switch ( mode ) { <nl> + case 1 : <nl> + System . out . println ( rem = = 0 ) ; <nl> + / / fall through <nl> + case 2 : <nl> + increment = false ; <nl> + break ; <nl> + case 3 : <nl> + increment = true ; <nl> + break ; <nl> + case 4 : <nl> + increment = signum > 0 ; <nl> + break ; <nl> + case 5 : <nl> + increment = signum < 0 ; <nl> + break ; <nl> + case 6 : <nl> + case 7 : <nl> + case 8 : <nl> + final int absRem = 1 ; <nl> + final int cmpRemToHalfDivisor = absRem - ( 1 - absRem ) ; <nl> + / / subtracting two nonnegative ints can ' t overflow <nl> + / / cmpRemToHalfDivisor has the same sign as compare ( abs ( rem ) , abs ( q ) / 2 ) . <nl> + if ( cmpRemToHalfDivisor = = 0 ) { / / exactly on the half mark <nl> + increment = ( mode = = 1 ) | | ( mode = = 2 & ( div & 1 ) ! = 0 ) ; <nl> + } <nl> + else { <nl> + increment = cmpRemToHalfDivisor > 0 ; / / closer to the UP value <nl> + } <nl> + break ; <nl> + default : <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + return increment ? div + signum : div ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / src / site / resources / images / github _ logo _ social _ coding _ outlined . png b / src / site / resources / images / github _ logo _ social _ coding _ outlined . png <nl> new file mode 100644 <nl> index 0000000 . . 3bb42b3 <nl> Binary files / dev / null and b / src / site / resources / images / github _ logo _ social _ coding _ outlined . png differ <nl> diff - - git a / src / site / resources / images / sflogo . gif b / src / site / resources / images / sflogo . gif <nl> new file mode 100644 <nl> index 0000000 . . 7bfc88d <nl> Binary files / dev / null and b / src / site / resources / images / sflogo . gif differ <nl> diff - - git a / src / site / site . xml b / src / site / site . xml <nl> index 2b6dc5f . . 36c26cb 100644 <nl> - - - a / src / site / site . xml <nl> + + + b / src / site / site . xml <nl> @ @ - 15 , 10 + 15 , 10 @ @ <nl> <nl> < poweredBy > <nl> < logo name = " GitHub " href = " https : / / github . com / checkstyle / checkstyle " <nl> - 	 img = " https : / / github . com / github / media / blob / master / logos / github _ logo _ social _ coding _ outlined . png ? raw = true " <nl> + 	 img = " images / github _ logo _ social _ coding _ outlined . png " <nl> 	 width = " 120 " height = " 45 " / > <nl> < logo name = " SourceForge " <nl> - img = " http : / / sflogo . sourceforge . net / sflogo . php ? group _ id = 29721 & amp ; type = 11 " <nl> + img = " images / sflogo . gif " <nl> href = " http : / / sourceforge . net / projects / checkstyle " <nl> / > <nl> < logo name = " Twitter "

TEST DIFF:
diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / FinalLocalVariableCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / FinalLocalVariableCheckTest . java 
 index df5e10a . . 3b8205d 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / FinalLocalVariableCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / FinalLocalVariableCheckTest . java 
 @ @ - 200 , 7 + 200 , 12 @ @ public class FinalLocalVariableCheckTest 
 final DefaultConfiguration checkConfig = createCheckConfig ( FinalLocalVariableCheck . class ) ; 
 
 final String [ ] expected = { 
 - " 44 : 13 : " + " Variable ' i ' should be declared final . " , 
 + " 49 : 13 : " + " Variable ' i ' should be declared final . " , 
 + " 122 : 16 : " + " Variable ' path ' should be declared final . " , 
 + " 126 : 20 : " + " Variable ' relativePath ' should be declared final . " , 
 + " 202 : 17 : " + " Variable ' kind ' should be declared final . " , 
 + " 207 : 24 : " + " Variable ' m ' should be declared final . " , 
 + " 409 : 17 : " + " Variable ' increment ' should be declared final . " , 
 } ; 
 verify ( checkConfig , getPath ( " InputFinalLocalVariableAssignedMultipleTimes . java " ) , expected ) ; 
 } 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputFinalLocalVariableAssignedMultipleTimes . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputFinalLocalVariableAssignedMultipleTimes . java 
 index f7b126f . . fb96781 100644 
 - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputFinalLocalVariableAssignedMultipleTimes . java 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputFinalLocalVariableAssignedMultipleTimes . java 
 @ @ - 1 , 5 + 1 , 10 @ @ 
 package com . puppycrawl . tools . checkstyle . checks . coding ; 
 
 + import java . util . HashMap ; 
 + import java . util . SortedMap ; 
 + 
 + import com . google . common . collect . Maps ; 
 + 
 public class InputFinalLocalVariableAssignedMultipleTimes { 
 
 void foo1 ( ) { 
 @ @ - 111 , 4 + 116 , 330 @ @ public class InputFinalLocalVariableAssignedMultipleTimes { 
 
 } 
 } 
 + 
 + / / Taken from findbugs 
 + public static String foo9 ( String filePath , String project ) { 
 + String path = new String ( filePath ) ; / / violation 
 + String commonPath ; 
 + if ( project ! = null ) { 
 + commonPath = " " ; 
 + String relativePath = " " ; / / violation 
 + if ( ! relativePath . equals ( path ) ) { 
 + return relativePath ; 
 + } 
 + } 
 + commonPath = " " ; 
 + return commonPath ; 
 + } 
 + 
 + / / Taken from findbugs 
 + public int foo10 ( String factory1 , String factory2 ) { 
 + int result = 0 ; 
 + String s1 , s2 ; 
 + switch ( result ) { 
 + case 1 : 
 + s1 = " Java " ; 
 + s2 = " C # " ; 
 + break ; 
 + case 2 : 
 + s1 = " C + + " ; 
 + s2 = " Pascal " ; 
 + ; 
 + break ; 
 + case 3 : 
 + s1 = " Basic " ; 
 + s2 = " Angol " ; 
 + break ; 
 + case 4 : 
 + s1 = " JavaScript " ; 
 + s2 = " Go " ; 
 + break ; 
 + case 5 : 
 + default : 
 + s1 = " F # " ; 
 + s2 = " Objective C " ; 
 + break ; 
 + } 
 + if ( s1 = = null ) { 
 + s1 = " incorrect language " ; 
 + } 
 + if ( s2 = = null ) { 
 + s2 = " incorrect language " ; 
 + } 
 + result = s1 . compareTo ( s2 ) ; 
 + 
 + if ( result = = 0 ) { 
 + switch ( result ) { 
 + case 1 : 
 + s1 = " Java " ; 
 + s2 = " C # " ; 
 + break ; 
 + case 2 : 
 + default : 
 + s1 = " C + + " ; 
 + s2 = " C " ; 
 + break ; 
 + } 
 + result = s1 . compareTo ( s2 ) ; 
 + } 
 + else if ( result = = 1 ) { 
 + result = - 8 ; 
 + } 
 + return result ; 
 + } 
 + 
 + / / Taken from findbugs 
 + public String foo11 ( final Object o , boolean getMinimal ) { 
 + 
 + String n = System . lineSeparator ( ) ; 
 + if ( n ! = null ) { 
 + return n ; 
 + } 
 + 
 + try { 
 + 
 + String className ; 
 + int kind ; / / violation 
 + boolean isParameterToInitMethodofAnonymousInnerClass = false ; 
 + boolean isSyntheticMethod = false ; 
 + if ( o instanceof String | | o instanceof Integer ) { 
 + 
 + String m ; / / violation 
 + if ( o instanceof String ) { 
 + m = ( String ) o ; 
 + isSyntheticMethod = m . equals ( " " ) ; 
 + kind = 1 ; 
 + className = this . getClass ( ) . getName ( ) ; 
 + } 
 + else if ( o instanceof String ) { 
 + m = " " ; 
 + / / Don ' t 
 + isSyntheticMethod = m . equals ( " " ) ; 
 + className = this . getClass ( ) . getName ( ) ; 
 + kind = 2 ; 
 + if ( " < init > " . equals ( m . toLowerCase ( ) ) ) { 
 + final int i = className . lastIndexOf ( ' $ ' ) ; 
 + if ( i + 1 < className . length ( ) & & Character . isDigit ( className . charAt ( i + 1 ) ) ) { 
 + isParameterToInitMethodofAnonymousInnerClass = true ; 
 + } 
 + } 
 + } 
 + else { 
 + throw new IllegalStateException ( " impossible " ) ; 
 + } 
 + 
 + if ( ! m . equals ( " " ) & & ! " < init > " . equals ( m . toLowerCase ( ) ) ) { 
 + final String c = " className " ; 
 + / / get inherited annotation 
 + String inheritedAnnotations = new String ( ) ; 
 + if ( c . charAt ( 1 ) > 0 ) { 
 + 
 + n = " " ; 
 + if ( n ! = null ) { 
 + inheritedAnnotations + = " " ; 
 + } 
 + } 
 + for ( int i = 5 ; i < 10 ; i + + ) { 
 + n = new String ( " " ) ; 
 + if ( n ! = null ) { 
 + inheritedAnnotations + = " " ; 
 + } 
 + } 
 + if ( n = = null ) { 
 + System . out . println ( " # of inherited annotations : " + inheritedAnnotations . length ( ) ) ; 
 + } 
 + if ( ! inheritedAnnotations . isEmpty ( ) ) { 
 + if ( inheritedAnnotations . length ( ) = = 1 ) { 
 + return inheritedAnnotations ; 
 + } 
 + if ( ! getMinimal ) { 
 + return inheritedAnnotations ; 
 + } 
 + 
 + String min = inheritedAnnotations ; 
 + if ( min . length ( ) = = 0 ) { 
 + inheritedAnnotations = null ; 
 + min = inheritedAnnotations ; 
 + } 
 + return min ; 
 + } 
 + / / check to see if method is defined in this class ; 
 + / / if not , on ' t consider default annotations 
 + if ( inheritedAnnotations = = null ) { 
 + return null ; 
 + } 
 + if ( inheritedAnnotations . equals ( " " ) ) { 
 + System . out . println ( " looking for default annotations : " + " defines " + m ) ; 
 + } 
 + } / / if not static 
 + } / / associated with method 
 + else if ( o instanceof String ) { 
 + 
 + className = ( ( String ) o ) . getClass ( ) . getName ( ) ; 
 + kind = 3 ; 
 + } 
 + else if ( o instanceof String ) { 
 + assert false ; 
 + className = ( String ) o ; 
 + kind = 4 ; 
 + } 
 + else { 
 + throw new IllegalArgumentException ( " Can ' t look up annotation for " + o . getClass ( ) . getName ( ) ) ; 
 + } 
 + 
 + / / < init > method parameters for inner classes don ' t inherit default 
 + / / annotations 
 + / / since some of them are synthetic 
 + if ( isParameterToInitMethodofAnonymousInnerClass ) { 
 + return null ; 
 + } 
 + 
 + / / synthetic elements should not inherit default annotations 
 + if ( isSyntheticMethod ) { 
 + return null ; 
 + } 
 + try { 
 + final String c = new String ( className ) ; 
 + 
 + if ( c ! = null & & c . equals ( " " ) ) { 
 + return null ; 
 + } 
 + } 
 + catch ( Exception e ) { 
 + assert true ; 
 + } 
 + 
 + / / look for default annotation 
 + n = new String ( className ) ; 
 + if ( n = = null ) { 
 + System . out . println ( " Default annotation for " + kind + " is " + n ) ; 
 + } 
 + if ( n ! = null ) { 
 + return n ; 
 + } 
 + 
 + n = new String ( className ) ; 
 + if ( n = = null ) { 
 + System . out . println ( " Default annotation for any is " + n ) ; 
 + } 
 + if ( n ! = null ) { 
 + return n ; 
 + } 
 + 
 + final int p = className . lastIndexOf ( ' . ' ) ; 
 + className = className . substring ( 0 , p + 1 ) + " package - info " ; 
 + n = new String ( className ) ; 
 + if ( n = = null ) { 
 + System . out . println ( " Default annotation for " + kind + " is " + n ) ; 
 + } 
 + if ( n ! = null ) { 
 + return n ; 
 + } 
 + 
 + n = new String ( className ) ; 
 + if ( n = = null ) { 
 + System . out . println ( " Default annotation for any is " + n ) ; 
 + } 
 + if ( n ! = null ) { 
 + return n ; 
 + } 
 + 
 + return n ; 
 + } 
 + catch ( Exception e ) { 
 + System . out . println ( e ) ; 
 + ; 
 + return null ; 
 + } 
 + 
 + } 
 + 
 + / / Taken from findbugs 
 + private void foo12 ( Long start , Long end ) { 
 + HashMap < Object , Object > headMap ; 
 + if ( end < Long . MAX _ VALUE ) { 
 + headMap = Maps . newHashMap ( ) ; 
 + Long tailEnd = 1L ; 
 + if ( tailEnd ! = null ) { 
 + end = tailEnd ; 
 + } 
 + if ( ! headMap . isEmpty ( ) ) { 
 + tailEnd = ( Long ) headMap . get ( headMap . size ( ) ) ; 
 + if ( tailEnd > end ) { 
 + end = tailEnd ; 
 + } 
 + } 
 + } 
 + headMap = Maps . newHashMap ( ) ; 
 + if ( ! headMap . isEmpty ( ) ) { 
 + final int headStart = headMap . size ( ) ; 
 + final Long headEnd = ( Long ) headMap . get ( headStart ) ; 
 + if ( headEnd > = start - 1 ) { 
 + headMap . remove ( headStart ) ; 
 + start = Long . valueOf ( headStart ) ; 
 + } 
 + } 
 + headMap . clear ( ) ; 
 + headMap . remove ( end ) ; 
 + headMap . put ( start , end ) ; 
 + } 
 + 
 + / / Taken from Guava 
 + public static int foo13 ( int p , int q , int mode ) { 
 + System . out . println ( mode ) ; 
 + ; 
 + if ( q = = 0 ) { 
 + throw new ArithmeticException ( " / by zero " ) ; / / for GWT 
 + } 
 + final int div = p / q ; 
 + final int rem = p - q * div ; / / equal to p % q 
 + 
 + if ( rem = = 0 ) { 
 + return div ; 
 + } 
 + 
 + / * 
 + * Normal Java division rounds towards 0 , consistently with RoundingMode . DOWN . We just have to 
 + * deal with the cases where rounding towards 0 is wrong , which typically depends on the sign of 
 + * p / q . 
 + * 
 + * signum is 1 if p and q are both nonnegative or both negative , and - 1 otherwise . 
 + * / 
 + final int signum = 1 | ( ( p ^ q ) > > ( Integer . SIZE - 1 ) ) ; 
 + boolean increment ; / / violation 
 + switch ( mode ) { 
 + case 1 : 
 + System . out . println ( rem = = 0 ) ; 
 + / / fall through 
 + case 2 : 
 + increment = false ; 
 + break ; 
 + case 3 : 
 + increment = true ; 
 + break ; 
 + case 4 : 
 + increment = signum > 0 ; 
 + break ; 
 + case 5 : 
 + increment = signum < 0 ; 
 + break ; 
 + case 6 : 
 + case 7 : 
 + case 8 : 
 + final int absRem = 1 ; 
 + final int cmpRemToHalfDivisor = absRem - ( 1 - absRem ) ; 
 + / / subtracting two nonnegative ints can ' t overflow 
 + / / cmpRemToHalfDivisor has the same sign as compare ( abs ( rem ) , abs ( q ) / 2 ) . 
 + if ( cmpRemToHalfDivisor = = 0 ) { / / exactly on the half mark 
 + increment = ( mode = = 1 ) | | ( mode = = 2 & ( div & 1 ) ! = 0 ) ; 
 + } 
 + else { 
 + increment = cmpRemToHalfDivisor > 0 ; / / closer to the UP value 
 + } 
 + break ; 
 + default : 
 + throw new AssertionError ( ) ; 
 + } 
 + return increment ? div + signum : div ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / src / site / resources / images / github _ logo _ social _ coding _ outlined . png b / src / site / resources / images / github _ logo _ social _ coding _ outlined . png 
 new file mode 100644 
 index 0000000 . . 3bb42b3 
 Binary files / dev / null and b / src / site / resources / images / github _ logo _ social _ coding _ outlined . png differ 
 diff - - git a / src / site / resources / images / sflogo . gif b / src / site / resources / images / sflogo . gif 
 new file mode 100644 
 index 0000000 . . 7bfc88d 
 Binary files / dev / null and b / src / site / resources / images / sflogo . gif differ 
 diff - - git a / src / site / site . xml b / src / site / site . xml 
 index 2b6dc5f . . 36c26cb 100644 
 - - - a / src / site / site . xml 
 + + + b / src / site / site . xml 
 @ @ - 15 , 10 + 15 , 10 @ @ 
 
 < poweredBy > 
 < logo name = " GitHub " href = " https : / / github . com / checkstyle / checkstyle " 
 - 	 img = " https : / / github . com / github / media / blob / master / logos / github _ logo _ social _ coding _ outlined . png ? raw = true " 
 + 	 img = " images / github _ logo _ social _ coding _ outlined . png " 
 	 width = " 120 " height = " 45 " / > 
 < logo name = " SourceForge " 
 - img = " http : / / sflogo . sourceforge . net / sflogo . php ? group _ id = 29721 & amp ; type = 11 " 
 + img = " images / sflogo . gif " 
 href = " http : / / sourceforge . net / projects / checkstyle " 
 / > 
 < logo name = " Twitter "
