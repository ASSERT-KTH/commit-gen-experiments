BLEU SCORE: 0.0688037070798893

TEST MSG: Issue # 957 : Remove unused package - private methods
GENERATED MSG: Issue # 1566 : ' missing javadoc comment ' violations fixed in FileDrop

TEST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / gui / FileDrop . java b / src / main / java / com / puppycrawl / tools / checkstyle / gui / FileDrop . java <nl> index 3c0c545 . . 4b39879 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / gui / FileDrop . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / gui / FileDrop . java <nl> @ @ - 191 , 39 + 191 , 6 @ @ class FileDrop { <nl> } <nl> <nl> / * * <nl> - * Removes the drag - and - drop hooks from the component and optionally <nl> - * from the all children . You should call this if you add and remove <nl> - * components after you ' ve set up the drag - and - drop . <nl> - * This will recursively unregister all components contained within <nl> - * < var > c < / var > if < var > c < / var > is a { @ link Container } . <nl> - * <nl> - * @ param component The component to unregister as a drop target <nl> - * @ since 1 . 0 <nl> - * / <nl> - static void remove ( Component component ) { <nl> - remove ( component , true ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Removes the drag - and - drop hooks from the component and optionally <nl> - * from the all children . You should call this if you add and remove <nl> - * components after you ' ve set up the drag - and - drop . <nl> - * <nl> - * @ param component The component to unregister <nl> - * @ param recursive Recursively unregister components within a container <nl> - * @ since 1 . 0 <nl> - * / <nl> - private static void remove ( Component component , boolean recursive ) { <nl> - component . setDropTarget ( null ) ; <nl> - if ( recursive & & component instanceof Container ) { <nl> - final Component [ ] comps = ( ( Container ) component ) . getComponents ( ) ; <nl> - for ( Component element : comps ) { <nl> - remove ( element , recursive ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - / * * <nl> * Listener and handler for file drop target events . <nl> * / <nl> private class FileDropTargetListener extends DropTargetAdapter {
NEAREST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / AbstractSuperCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / AbstractSuperCheck . java <nl> index 23765d9 . . 848fa91 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / AbstractSuperCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / AbstractSuperCheck . java <nl> @ @ - 89 , 36 + 89 , 50 @ @ public abstract class AbstractSuperCheck <nl> } <nl> <nl> / * * <nl> - * Determines whether a ' super ' literal is a call to the super method <nl> + * Determines whether a ' super ' literal is a call to the super method <nl> * for this check . <nl> * @ param literalSuperAst the AST node of a ' super ' literal . <nl> * @ return true if ast is a call to the super method <nl> * for this check . <nl> * / <nl> private boolean isSuperCall ( DetailAST literalSuperAst ) { <nl> - if ( literalSuperAst . getType ( ) ! = TokenTypes . LITERAL _ SUPER ) { <nl> - return false ; <nl> - } <nl> - / / dot operator ? <nl> - DetailAST dotAst = literalSuperAst . getParent ( ) ; <nl> - if ( dotAst . getType ( ) ! = TokenTypes . DOT <nl> - | | isSameNameMethod ( literalSuperAst ) <nl> - | | hasArguments ( dotAst ) ) { <nl> - return false ; <nl> + boolean superCall = false ; <nl> + <nl> + if ( literalSuperAst . getType ( ) = = TokenTypes . LITERAL _ SUPER ) { <nl> + / / dot operator ? <nl> + final DetailAST dotAst = literalSuperAst . getParent ( ) ; <nl> + <nl> + if ( dotAst . getType ( ) = = TokenTypes . DOT <nl> + & & ! isSameNameMethod ( literalSuperAst ) <nl> + & & ! hasArguments ( dotAst ) ) { <nl> + superCall = isSuperCallInOverridingMethod ( dotAst ) ; <nl> + } <nl> } <nl> + return superCall ; <nl> + } <nl> + <nl> + / * * <nl> + * Determines whether a super call in overriding method . <nl> + * <nl> + * @ param ast The AST node of a ' dot operator ' in ' super ' call . <nl> + * @ return true if super call in overriding method . <nl> + * / <nl> + private boolean isSuperCallInOverridingMethod ( DetailAST ast ) { <nl> + boolean inOverridingMethod = false ; <nl> + DetailAST dotAst = ast ; <nl> <nl> - / / in an overriding method for this check ? <nl> while ( dotAst ! = null ) { <nl> if ( dotAst . getType ( ) = = TokenTypes . METHOD _ DEF ) { <nl> - return isOverridingMethod ( dotAst ) ; <nl> + inOverridingMethod = isOverridingMethod ( dotAst ) ; <nl> + break ; <nl> } <nl> if ( dotAst . getType ( ) = = TokenTypes . CTOR _ DEF <nl> | | dotAst . getType ( ) = = TokenTypes . INSTANCE _ INIT ) { <nl> - return false ; <nl> + break ; <nl> } <nl> dotAst = dotAst . getParent ( ) ; <nl> } <nl> - return false ; <nl> + return inOverridingMethod ; <nl> } <nl> <nl> / * * <nl> @ @ - 173 , 19 + 187 , 21 @ @ public abstract class AbstractSuperCheck <nl> * @ return true if the method of ast is a method for this check . <nl> * / <nl> private boolean isOverridingMethod ( DetailAST ast ) { <nl> - if ( ast . getType ( ) ! = TokenTypes . METHOD _ DEF <nl> - | | ScopeUtils . isInInterfaceOrAnnotationBlock ( ast ) ) { <nl> - return false ; <nl> - } <nl> - final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; <nl> - final String name = nameAST . getText ( ) ; <nl> - final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> - if ( ! getMethodName ( ) . equals ( name ) <nl> - | | modifiersAST . branchContains ( TokenTypes . LITERAL _ NATIVE ) ) { <nl> - return false ; <nl> + boolean overridingMethod = false ; <nl> + <nl> + if ( ast . getType ( ) = = TokenTypes . METHOD _ DEF <nl> + & & ! ScopeUtils . isInInterfaceOrAnnotationBlock ( ast ) ) { <nl> + final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; <nl> + final String name = nameAST . getText ( ) ; <nl> + final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> + <nl> + if ( getMethodName ( ) . equals ( name ) <nl> + & & ! modifiersAST . branchContains ( TokenTypes . LITERAL _ NATIVE ) ) { <nl> + final DetailAST params = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; <nl> + overridingMethod = params . getChildCount ( ) = = 0 ; <nl> + } <nl> } <nl> - final DetailAST params = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; <nl> - return params . getChildCount ( ) = = 0 ; <nl> + return overridingMethod ; <nl> } <nl> <nl> / * *

TEST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / gui / FileDrop . java b / src / main / java / com / puppycrawl / tools / checkstyle / gui / FileDrop . java 
 index 3c0c545 . . 4b39879 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / gui / FileDrop . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / gui / FileDrop . java 
 @ @ - 191 , 39 + 191 , 6 @ @ class FileDrop { 
 } 
 
 / * * 
 - * Removes the drag - and - drop hooks from the component and optionally 
 - * from the all children . You should call this if you add and remove 
 - * components after you ' ve set up the drag - and - drop . 
 - * This will recursively unregister all components contained within 
 - * < var > c < / var > if < var > c < / var > is a { @ link Container } . 
 - * 
 - * @ param component The component to unregister as a drop target 
 - * @ since 1 . 0 
 - * / 
 - static void remove ( Component component ) { 
 - remove ( component , true ) ; 
 - } 
 - 
 - / * * 
 - * Removes the drag - and - drop hooks from the component and optionally 
 - * from the all children . You should call this if you add and remove 
 - * components after you ' ve set up the drag - and - drop . 
 - * 
 - * @ param component The component to unregister 
 - * @ param recursive Recursively unregister components within a container 
 - * @ since 1 . 0 
 - * / 
 - private static void remove ( Component component , boolean recursive ) { 
 - component . setDropTarget ( null ) ; 
 - if ( recursive & & component instanceof Container ) { 
 - final Component [ ] comps = ( ( Container ) component ) . getComponents ( ) ; 
 - for ( Component element : comps ) { 
 - remove ( element , recursive ) ; 
 - } 
 - } 
 - } 
 - 
 - / * * 
 * Listener and handler for file drop target events . 
 * / 
 private class FileDropTargetListener extends DropTargetAdapter {

NEAREST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / AbstractSuperCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / AbstractSuperCheck . java 
 index 23765d9 . . 848fa91 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / AbstractSuperCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / AbstractSuperCheck . java 
 @ @ - 89 , 36 + 89 , 50 @ @ public abstract class AbstractSuperCheck 
 } 
 
 / * * 
 - * Determines whether a ' super ' literal is a call to the super method 
 + * Determines whether a ' super ' literal is a call to the super method 
 * for this check . 
 * @ param literalSuperAst the AST node of a ' super ' literal . 
 * @ return true if ast is a call to the super method 
 * for this check . 
 * / 
 private boolean isSuperCall ( DetailAST literalSuperAst ) { 
 - if ( literalSuperAst . getType ( ) ! = TokenTypes . LITERAL _ SUPER ) { 
 - return false ; 
 - } 
 - / / dot operator ? 
 - DetailAST dotAst = literalSuperAst . getParent ( ) ; 
 - if ( dotAst . getType ( ) ! = TokenTypes . DOT 
 - | | isSameNameMethod ( literalSuperAst ) 
 - | | hasArguments ( dotAst ) ) { 
 - return false ; 
 + boolean superCall = false ; 
 + 
 + if ( literalSuperAst . getType ( ) = = TokenTypes . LITERAL _ SUPER ) { 
 + / / dot operator ? 
 + final DetailAST dotAst = literalSuperAst . getParent ( ) ; 
 + 
 + if ( dotAst . getType ( ) = = TokenTypes . DOT 
 + & & ! isSameNameMethod ( literalSuperAst ) 
 + & & ! hasArguments ( dotAst ) ) { 
 + superCall = isSuperCallInOverridingMethod ( dotAst ) ; 
 + } 
 } 
 + return superCall ; 
 + } 
 + 
 + / * * 
 + * Determines whether a super call in overriding method . 
 + * 
 + * @ param ast The AST node of a ' dot operator ' in ' super ' call . 
 + * @ return true if super call in overriding method . 
 + * / 
 + private boolean isSuperCallInOverridingMethod ( DetailAST ast ) { 
 + boolean inOverridingMethod = false ; 
 + DetailAST dotAst = ast ; 
 
 - / / in an overriding method for this check ? 
 while ( dotAst ! = null ) { 
 if ( dotAst . getType ( ) = = TokenTypes . METHOD _ DEF ) { 
 - return isOverridingMethod ( dotAst ) ; 
 + inOverridingMethod = isOverridingMethod ( dotAst ) ; 
 + break ; 
 } 
 if ( dotAst . getType ( ) = = TokenTypes . CTOR _ DEF 
 | | dotAst . getType ( ) = = TokenTypes . INSTANCE _ INIT ) { 
 - return false ; 
 + break ; 
 } 
 dotAst = dotAst . getParent ( ) ; 
 } 
 - return false ; 
 + return inOverridingMethod ; 
 } 
 
 / * * 
 @ @ - 173 , 19 + 187 , 21 @ @ public abstract class AbstractSuperCheck 
 * @ return true if the method of ast is a method for this check . 
 * / 
 private boolean isOverridingMethod ( DetailAST ast ) { 
 - if ( ast . getType ( ) ! = TokenTypes . METHOD _ DEF 
 - | | ScopeUtils . isInInterfaceOrAnnotationBlock ( ast ) ) { 
 - return false ; 
 - } 
 - final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; 
 - final String name = nameAST . getText ( ) ; 
 - final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 - if ( ! getMethodName ( ) . equals ( name ) 
 - | | modifiersAST . branchContains ( TokenTypes . LITERAL _ NATIVE ) ) { 
 - return false ; 
 + boolean overridingMethod = false ; 
 + 
 + if ( ast . getType ( ) = = TokenTypes . METHOD _ DEF 
 + & & ! ScopeUtils . isInInterfaceOrAnnotationBlock ( ast ) ) { 
 + final DetailAST nameAST = ast . findFirstToken ( TokenTypes . IDENT ) ; 
 + final String name = nameAST . getText ( ) ; 
 + final DetailAST modifiersAST = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 + 
 + if ( getMethodName ( ) . equals ( name ) 
 + & & ! modifiersAST . branchContains ( TokenTypes . LITERAL _ NATIVE ) ) { 
 + final DetailAST params = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; 
 + overridingMethod = params . getChildCount ( ) = = 0 ; 
 + } 
 } 
 - final DetailAST params = ast . findFirstToken ( TokenTypes . PARAMETERS ) ; 
 - return params . getChildCount ( ) = = 0 ; 
 + return overridingMethod ; 
 } 
 
 / * *
