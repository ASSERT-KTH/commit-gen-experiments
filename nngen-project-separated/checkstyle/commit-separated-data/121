BLEU SCORE: 0.07495553473355841

TEST MSG: Issue # 5008 : added test cases to kill coding profile mutations
GENERATED MSG: Issue # 5633 : Fix PMD6 violations ( bestpractices )

TEST DIFF (one line): diff - - git a / . ci / pitest . sh b / . ci / pitest . sh <nl> index 108e67c . . cf67fb5 100755 <nl> - - - a / . ci / pitest . sh <nl> + + + b / . ci / pitest . sh <nl> @ @ - 47 , 21 + 47 , 12 @ @ pitest - coding ) <nl> declare - a ignoredItems = ( <nl> " EqualsAvoidNullCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > & # 38 ; & # 38 ; field . getColumnNo ( ) + minimumSymbolsBetween & # 60 ; = objCalledOn . getColumnNo ( ) ) { < / span > < / pre > < / td > < / tr > " <nl> " HiddenFieldCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > processVariable ( ast ) ; < / span > < / pre > < / td > < / tr > " <nl> - " IllegalInstantiationCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > classNames . clear ( ) ; < / span > < / pre > < / td > < / tr > " <nl> - " IllegalInstantiationCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > imports . clear ( ) ; < / span > < / pre > < / td > < / tr > " <nl> - " IllegalInstantiationCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > instantiations . clear ( ) ; < / span > < / pre > < / td > < / tr > " <nl> " MultipleVariableDeclarationsCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > & # 38 ; & # 38 ; newNode . getColumnNo ( ) & # 62 ; currentNode . getColumnNo ( ) ) { < / span > < / pre > < / td > < / tr > " <nl> " MultipleVariableDeclarationsCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( newNode . getLineNo ( ) & # 62 ; currentNode . getLineNo ( ) < / span > < / pre > < / td > < / tr > " <nl> " MultipleVariableDeclarationsCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > | | newNode . getLineNo ( ) = = currentNode . getLineNo ( ) < / span > < / pre > < / td > < / tr > " <nl> " RequireThisCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > & # 38 ; & # 38 ; ast1 . getColumnNo ( ) & # 60 ; ast2 . getColumnNo ( ) ) { < / span > < / pre > < / td > < / tr > " <nl> - " RequireThisCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > current . clear ( ) ; < / span > < / pre > < / td > < / tr > " <nl> " RequireThisCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > final boolean methodNameInMethodCall = parentType = = TokenTypes . DOT < / span > < / pre > < / td > < / tr > " <nl> " UnnecessaryParenthesesCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( type ! = TokenTypes . ASSIGN < / span > < / pre > < / td > < / tr > " <nl> - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > & # 38 ; & # 38 ; currentNode . getType ( ) = = TokenTypes . LITERAL _ CATCH ) { < / span > < / pre > < / td > < / tr > " <nl> - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( currentNode . getType ( ) = = TokenTypes . LITERAL _ IF ) { < / span > < / pre > < / td > < / tr > " <nl> - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( elseBlock . getType ( ) = = TokenTypes . LITERAL _ ELSE ) { < / span > < / pre > < / td > < / tr > " <nl> - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( ! isVarInOperatorDeclaration & # 38 ; & # 38 ; operator . getType ( ) = = TokenTypes . LITERAL _ IF ) { < / span > < / pre > < / td > < / tr > " <nl> - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > while ( currentNode ! = null < / span > < / pre > < / td > < / tr > " <nl> ) ; <nl> checkPitestReport " $ { ignoredItems [ @ ] } " <nl> ; ; <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / IllegalInstantiationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / IllegalInstantiationCheckTest . java <nl> index 78809d4 . . 8fb68d9 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / IllegalInstantiationCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / IllegalInstantiationCheckTest . java <nl> @ @ - 21 , 13 + 21 , 19 @ @ package com . puppycrawl . tools . checkstyle . checks . coding ; <nl> <nl> import static com . puppycrawl . tools . checkstyle . checks . coding . IllegalInstantiationCheck . MSG _ KEY ; <nl> <nl> + import java . io . File ; <nl> + import java . util . Collection ; <nl> + import java . util . Optional ; <nl> + <nl> import org . junit . Assert ; <nl> import org . junit . Test ; <nl> <nl> import com . puppycrawl . tools . checkstyle . AbstractModuleTestSupport ; <nl> import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; <nl> + import com . puppycrawl . tools . checkstyle . JavaParser ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> + import com . puppycrawl . tools . checkstyle . internal . utils . TestUtil ; <nl> import com . puppycrawl . tools . checkstyle . utils . CommonUtil ; <nl> <nl> public class IllegalInstantiationCheckTest <nl> @ @ - 160 , 4 + 166 , 72 @ @ public class IllegalInstantiationCheckTest <nl> } <nl> } <nl> <nl> + / * * <nl> + * We cannot reproduce situation when visitToken is called and leaveToken is not . <nl> + * So , we have to use reflection to be sure that even in such situation <nl> + * state of the field will be cleared . <nl> + * <nl> + * @ throws Exception when code tested throws exception <nl> + * / <nl> + @ Test <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + public void testClearStateClassNames ( ) throws Exception { <nl> + final IllegalInstantiationCheck check = new IllegalInstantiationCheck ( ) ; <nl> + final DetailAST root = JavaParser . parseFile ( <nl> + new File ( getPath ( " InputIllegalInstantiationSemantic . java " ) ) , <nl> + JavaParser . Options . WITHOUT _ COMMENTS ) ; <nl> + final Optional < DetailAST > classDef = TestUtil . findTokenInAstByPredicate ( root , <nl> + ast - > ast . getType ( ) = = TokenTypes . CLASS _ DEF ) ; <nl> + <nl> + Assert . assertTrue ( " Ast should contain CLASS _ DEF " , classDef . isPresent ( ) ) ; <nl> + Assert . assertTrue ( " State is not cleared on beginTree " , <nl> + TestUtil . isStatefulFieldClearedDuringBeginTree ( check , classDef . get ( ) , " classNames " , <nl> + classNames - > ( ( Collection < String > ) classNames ) . isEmpty ( ) ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * We cannot reproduce situation when visitToken is called and leaveToken is not . <nl> + * So , we have to use reflection to be sure that even in such situation <nl> + * state of the field will be cleared . <nl> + * <nl> + * @ throws Exception when code tested throws exception <nl> + * / <nl> + @ Test <nl> + public void testClearStateImports ( ) throws Exception { <nl> + final IllegalInstantiationCheck check = new IllegalInstantiationCheck ( ) ; <nl> + final DetailAST root = JavaParser . parseFile ( new File ( <nl> + getPath ( " InputIllegalInstantiationSemantic . java " ) ) , <nl> + JavaParser . Options . WITHOUT _ COMMENTS ) ; <nl> + final Optional < DetailAST > importDef = TestUtil . findTokenInAstByPredicate ( root , <nl> + ast - > ast . getType ( ) = = TokenTypes . IMPORT ) ; <nl> + <nl> + Assert . assertTrue ( " Ast should contain IMPORT _ DEF " , importDef . isPresent ( ) ) ; <nl> + Assert . assertTrue ( " State is not cleared on beginTree " , <nl> + TestUtil . isStatefulFieldClearedDuringBeginTree ( check , importDef . get ( ) , " imports " , <nl> + imports - > ( ( Collection < ? > ) imports ) . isEmpty ( ) ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * We cannot reproduce situation when visitToken is called and leaveToken is not . <nl> + * So , we have to use reflection to be sure that even in such situation <nl> + * state of the field will be cleared . <nl> + * <nl> + * @ throws Exception when code tested throws exception <nl> + * / <nl> + @ Test <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + public void testClearStateInstantiations ( ) throws Exception { <nl> + final IllegalInstantiationCheck check = new IllegalInstantiationCheck ( ) ; <nl> + final DetailAST root = JavaParser . parseFile ( new File ( <nl> + getNonCompilablePath ( " InputIllegalInstantiationLang . java " ) ) , <nl> + JavaParser . Options . WITHOUT _ COMMENTS ) ; <nl> + final Optional < DetailAST > literalNew = TestUtil . findTokenInAstByPredicate ( root , <nl> + ast - > ast . getType ( ) = = TokenTypes . LITERAL _ NEW ) ; <nl> + <nl> + Assert . assertTrue ( " Ast should contain LITERAL _ NEW " , literalNew . isPresent ( ) ) ; <nl> + Assert . assertTrue ( " State is not cleared on beginTree " , <nl> + TestUtil . isStatefulFieldClearedDuringBeginTree ( check , literalNew . get ( ) , <nl> + " instantiations " , <nl> + instantiations - > ( ( Collection < DetailAST > ) instantiations ) . isEmpty ( ) ) ) ; <nl> + } <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java <nl> index 29362a7 . . 08edb4f 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java <nl> @ @ - 22 , 7 + 22 , 10 @ @ package com . puppycrawl . tools . checkstyle . checks . coding ; <nl> import static com . puppycrawl . tools . checkstyle . checks . coding . RequireThisCheck . MSG _ METHOD ; <nl> import static com . puppycrawl . tools . checkstyle . checks . coding . RequireThisCheck . MSG _ VARIABLE ; <nl> <nl> + import java . io . File ; <nl> import java . lang . reflect . Constructor ; <nl> + import java . util . Collection ; <nl> + import java . util . Optional ; <nl> import java . util . SortedSet ; <nl> <nl> import org . junit . Assert ; <nl> @ @ - 31 , 6 + 34 , 7 @ @ import org . junit . Test ; <nl> import antlr . CommonHiddenStreamToken ; <nl> import com . puppycrawl . tools . checkstyle . AbstractModuleTestSupport ; <nl> import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; <nl> + import com . puppycrawl . tools . checkstyle . JavaParser ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; <nl> import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> @ @ - 374 , 4 + 378 , 26 @ @ public class RequireThisCheckTest extends AbstractModuleTestSupport { <nl> TestUtil . getClassDeclaredMethod ( cls , " getType " ) . invoke ( o ) . toString ( ) ) ; <nl> } <nl> <nl> + / * * <nl> + * We cannot reproduce situation when visitToken is called and leaveToken is not . <nl> + * So , we have to use reflection to be sure that even in such situation <nl> + * state of the field will be cleared . <nl> + * <nl> + * @ throws Exception when code tested throws exception <nl> + * / <nl> + @ Test <nl> + public void testClearState ( ) throws Exception { <nl> + final RequireThisCheck check = new RequireThisCheck ( ) ; <nl> + final DetailAST root = JavaParser . parseFile ( <nl> + new File ( getPath ( " InputRequireThisSimple . java " ) ) , <nl> + JavaParser . Options . WITHOUT _ COMMENTS ) ; <nl> + final Optional < DetailAST > classDef = TestUtil . findTokenInAstByPredicate ( root , <nl> + ast - > ast . getType ( ) = = TokenTypes . CLASS _ DEF ) ; <nl> + <nl> + Assert . assertTrue ( " Ast should contain CLASS _ DEF " , classDef . isPresent ( ) ) ; <nl> + Assert . assertTrue ( " State is not cleared on beginTree " , <nl> + TestUtil . isStatefulFieldClearedDuringBeginTree ( check , classDef . get ( ) , " current " , <nl> + current - > ( ( Collection < ? > ) current ) . isEmpty ( ) ) ) ; <nl> + } <nl> + <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / VariableDeclarationUsageDistanceCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / VariableDeclarationUsageDistanceCheckTest . java <nl> index 3e33b33 . . 57f3ca8 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / VariableDeclarationUsageDistanceCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / VariableDeclarationUsageDistanceCheckTest . java <nl> @ @ - 79 , 6 + 79 , 8 @ @ public class VariableDeclarationUsageDistanceCheckTest extends <nl> " 901 : " + getCheckMessage ( MSG _ KEY , " a " , 4 , 1 ) , <nl> " 967 : " + getCheckMessage ( MSG _ KEY , " a " , 4 , 1 ) , <nl> " 978 : " + getCheckMessage ( MSG _ KEY , " a " , 2 , 1 ) , <nl> + " 989 : " + getCheckMessage ( MSG _ KEY , " a " , 3 , 1 ) , <nl> + " 1024 : " + getCheckMessage ( MSG _ KEY , " c " , 3 , 1 ) , <nl> } ; <nl> verify ( checkConfig , getPath ( " InputVariableDeclarationUsageDistance . java " ) , expected ) ; <nl> } <nl> @ @ - 174 , 6 + 176 , 7 @ @ public class VariableDeclarationUsageDistanceCheckTest extends <nl> " 540 : " + getCheckMessage ( MSG _ KEY , " id " , 2 , 1 ) , <nl> " 542 : " + getCheckMessage ( MSG _ KEY , " parentId " , 4 , 1 ) , <nl> " 978 : " + getCheckMessage ( MSG _ KEY , " a " , 2 , 1 ) , <nl> + " 1024 : " + getCheckMessage ( MSG _ KEY , " c " , 4 , 1 ) , <nl> } ; <nl> verify ( checkConfig , getPath ( " InputVariableDeclarationUsageDistance . java " ) , expected ) ; <nl> } <nl> @ @ - 218 , 6 + 221 , 8 @ @ public class VariableDeclarationUsageDistanceCheckTest extends <nl> " 891 : " + getCheckMessage ( MSG _ KEY _ EXT , " a " , 4 , 1 ) , <nl> " 901 : " + getCheckMessage ( MSG _ KEY _ EXT , " a " , 4 , 1 ) , <nl> " 967 : " + getCheckMessage ( MSG _ KEY _ EXT , " a " , 4 , 1 ) , <nl> + " 989 : " + getCheckMessage ( MSG _ KEY _ EXT , " a " , 3 , 1 ) , <nl> + " 1024 : " + getCheckMessage ( MSG _ KEY _ EXT , " c " , 3 , 1 ) , <nl> } ; <nl> verify ( checkConfig , getPath ( " InputVariableDeclarationUsageDistance . java " ) , expected ) ; <nl> } <nl> @ @ - 241 , 6 + 246 , 7 @ @ public class VariableDeclarationUsageDistanceCheckTest extends <nl> " 479 : " + getCheckMessage ( MSG _ KEY _ EXT , " myOption " , 7 , 3 ) , <nl> " 491 : " + getCheckMessage ( MSG _ KEY _ EXT , " myOption " , 6 , 3 ) , <nl> " 542 : " + getCheckMessage ( MSG _ KEY _ EXT , " parentId " , 4 , 3 ) , <nl> + " 1024 : " + getCheckMessage ( MSG _ KEY _ EXT , " c " , 4 , 3 ) , <nl> } ; <nl> <nl> verify ( checkConfig , getPath ( " InputVariableDeclarationUsageDistance . java " ) , expected ) ; <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / variabledeclarationusagedistance / InputVariableDeclarationUsageDistance . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / variabledeclarationusagedistance / InputVariableDeclarationUsageDistance . java <nl> index 6bf4b3e . . cdff75f 100644 <nl> - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / variabledeclarationusagedistance / InputVariableDeclarationUsageDistance . java <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / variabledeclarationusagedistance / InputVariableDeclarationUsageDistance . java <nl> @ @ - 985 , 4 + 985 , 67 @ @ class New { <nl> final int c = a + 1 ; <nl> } <nl> <nl> + void test ( ) { <nl> + int a = 0 ; <nl> + <nl> + System . lineSeparator ( ) ; <nl> + System . lineSeparator ( ) ; <nl> + System . lineSeparator ( ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) { <nl> + if ( true ) { <nl> + System . identityHashCode ( a ) ; <nl> + } <nl> + else { <nl> + System . identityHashCode ( a ) ; <nl> + } <nl> + } <nl> + <nl> + int b = 0 ; <nl> + try { <nl> + for ( int i = 0 ; i < 10 ; i + + ) { <nl> + if ( true ) { <nl> + System . lineSeparator ( ) ; <nl> + System . lineSeparator ( ) ; <nl> + System . lineSeparator ( ) ; <nl> + b = i ; <nl> + } <nl> + } <nl> + <nl> + System . lineSeparator ( ) ; <nl> + System . lineSeparator ( ) ; <nl> + } <nl> + catch ( Exception e ) { <nl> + System . lineSeparator ( ) ; <nl> + } <nl> + finally { <nl> + System . identityHashCode ( b ) ; <nl> + } <nl> + <nl> + int c = 0 ; <nl> + System . lineSeparator ( ) ; <nl> + System . lineSeparator ( ) ; <nl> + System . lineSeparator ( ) ; <nl> + <nl> + if ( false ) { <nl> + <nl> + } <nl> + else if ( c = = 1 ) { <nl> + if ( c ! = 2 ) { <nl> + System . lineSeparator ( ) ; <nl> + } <nl> + <nl> + System . identityHashCode ( c ) ; <nl> + } <nl> + else if ( c = = 2 ) { <nl> + System . identityHashCode ( c ) ; <nl> + } <nl> + } <nl> + <nl> + private void launch ( Integer number ) { <nl> + String myInt = ( number . toString ( ) + ' \ 0 ' ) ; <nl> + boolean result = false ; <nl> + if ( number = = 123 ) <nl> + result = true ; <nl> + } <nl> + <nl> }
NEAREST DIFF (one line): diff - - git a / pom . xml b / pom . xml <nl> index 31cc349 . . b56404a 100644 <nl> - - - a / pom . xml <nl> + + + b / pom . xml <nl> @ @ - 1362 , 6 + 1362 , 8 @ @ <nl> < excludedLinks > <nl> < excludedLink > reports / google - style / guava < / excludedLink > <nl> < excludedLink > reports / javadoc / openjdk8 < / excludedLink > <nl> + < ! - - temporal suppress till plugin update link in his source - - > <nl> + < excludedLink > http : / / www . mojohaus . org / exec - maven - plugin < / excludedLink > <nl> < ! - - temporal suppress till javadoc tool starts generating links to https - - > <nl> < excludedLink > http : / / docs . oracle . com / javase < / excludedLink > <nl> < ! - - SSL - - >

TEST DIFF:
diff - - git a / . ci / pitest . sh b / . ci / pitest . sh 
 index 108e67c . . cf67fb5 100755 
 - - - a / . ci / pitest . sh 
 + + + b / . ci / pitest . sh 
 @ @ - 47 , 21 + 47 , 12 @ @ pitest - coding ) 
 declare - a ignoredItems = ( 
 " EqualsAvoidNullCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > & # 38 ; & # 38 ; field . getColumnNo ( ) + minimumSymbolsBetween & # 60 ; = objCalledOn . getColumnNo ( ) ) { < / span > < / pre > < / td > < / tr > " 
 " HiddenFieldCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > processVariable ( ast ) ; < / span > < / pre > < / td > < / tr > " 
 - " IllegalInstantiationCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > classNames . clear ( ) ; < / span > < / pre > < / td > < / tr > " 
 - " IllegalInstantiationCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > imports . clear ( ) ; < / span > < / pre > < / td > < / tr > " 
 - " IllegalInstantiationCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > instantiations . clear ( ) ; < / span > < / pre > < / td > < / tr > " 
 " MultipleVariableDeclarationsCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > & # 38 ; & # 38 ; newNode . getColumnNo ( ) & # 62 ; currentNode . getColumnNo ( ) ) { < / span > < / pre > < / td > < / tr > " 
 " MultipleVariableDeclarationsCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( newNode . getLineNo ( ) & # 62 ; currentNode . getLineNo ( ) < / span > < / pre > < / td > < / tr > " 
 " MultipleVariableDeclarationsCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > | | newNode . getLineNo ( ) = = currentNode . getLineNo ( ) < / span > < / pre > < / td > < / tr > " 
 " RequireThisCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > & # 38 ; & # 38 ; ast1 . getColumnNo ( ) & # 60 ; ast2 . getColumnNo ( ) ) { < / span > < / pre > < / td > < / tr > " 
 - " RequireThisCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > current . clear ( ) ; < / span > < / pre > < / td > < / tr > " 
 " RequireThisCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > final boolean methodNameInMethodCall = parentType = = TokenTypes . DOT < / span > < / pre > < / td > < / tr > " 
 " UnnecessaryParenthesesCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( type ! = TokenTypes . ASSIGN < / span > < / pre > < / td > < / tr > " 
 - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > & # 38 ; & # 38 ; currentNode . getType ( ) = = TokenTypes . LITERAL _ CATCH ) { < / span > < / pre > < / td > < / tr > " 
 - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( currentNode . getType ( ) = = TokenTypes . LITERAL _ IF ) { < / span > < / pre > < / td > < / tr > " 
 - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( elseBlock . getType ( ) = = TokenTypes . LITERAL _ ELSE ) { < / span > < / pre > < / td > < / tr > " 
 - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > if ( ! isVarInOperatorDeclaration & # 38 ; & # 38 ; operator . getType ( ) = = TokenTypes . LITERAL _ IF ) { < / span > < / pre > < / td > < / tr > " 
 - " VariableDeclarationUsageDistanceCheck . java . html : < td class = ' covered ' > < pre > < span class = ' survived ' > while ( currentNode ! = null < / span > < / pre > < / td > < / tr > " 
 ) ; 
 checkPitestReport " $ { ignoredItems [ @ ] } " 
 ; ; 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / IllegalInstantiationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / IllegalInstantiationCheckTest . java 
 index 78809d4 . . 8fb68d9 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / IllegalInstantiationCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / IllegalInstantiationCheckTest . java 
 @ @ - 21 , 13 + 21 , 19 @ @ package com . puppycrawl . tools . checkstyle . checks . coding ; 
 
 import static com . puppycrawl . tools . checkstyle . checks . coding . IllegalInstantiationCheck . MSG _ KEY ; 
 
 + import java . io . File ; 
 + import java . util . Collection ; 
 + import java . util . Optional ; 
 + 
 import org . junit . Assert ; 
 import org . junit . Test ; 
 
 import com . puppycrawl . tools . checkstyle . AbstractModuleTestSupport ; 
 import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; 
 + import com . puppycrawl . tools . checkstyle . JavaParser ; 
 import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 + import com . puppycrawl . tools . checkstyle . internal . utils . TestUtil ; 
 import com . puppycrawl . tools . checkstyle . utils . CommonUtil ; 
 
 public class IllegalInstantiationCheckTest 
 @ @ - 160 , 4 + 166 , 72 @ @ public class IllegalInstantiationCheckTest 
 } 
 } 
 
 + / * * 
 + * We cannot reproduce situation when visitToken is called and leaveToken is not . 
 + * So , we have to use reflection to be sure that even in such situation 
 + * state of the field will be cleared . 
 + * 
 + * @ throws Exception when code tested throws exception 
 + * / 
 + @ Test 
 + @ SuppressWarnings ( " unchecked " ) 
 + public void testClearStateClassNames ( ) throws Exception { 
 + final IllegalInstantiationCheck check = new IllegalInstantiationCheck ( ) ; 
 + final DetailAST root = JavaParser . parseFile ( 
 + new File ( getPath ( " InputIllegalInstantiationSemantic . java " ) ) , 
 + JavaParser . Options . WITHOUT _ COMMENTS ) ; 
 + final Optional < DetailAST > classDef = TestUtil . findTokenInAstByPredicate ( root , 
 + ast - > ast . getType ( ) = = TokenTypes . CLASS _ DEF ) ; 
 + 
 + Assert . assertTrue ( " Ast should contain CLASS _ DEF " , classDef . isPresent ( ) ) ; 
 + Assert . assertTrue ( " State is not cleared on beginTree " , 
 + TestUtil . isStatefulFieldClearedDuringBeginTree ( check , classDef . get ( ) , " classNames " , 
 + classNames - > ( ( Collection < String > ) classNames ) . isEmpty ( ) ) ) ; 
 + } 
 + 
 + / * * 
 + * We cannot reproduce situation when visitToken is called and leaveToken is not . 
 + * So , we have to use reflection to be sure that even in such situation 
 + * state of the field will be cleared . 
 + * 
 + * @ throws Exception when code tested throws exception 
 + * / 
 + @ Test 
 + public void testClearStateImports ( ) throws Exception { 
 + final IllegalInstantiationCheck check = new IllegalInstantiationCheck ( ) ; 
 + final DetailAST root = JavaParser . parseFile ( new File ( 
 + getPath ( " InputIllegalInstantiationSemantic . java " ) ) , 
 + JavaParser . Options . WITHOUT _ COMMENTS ) ; 
 + final Optional < DetailAST > importDef = TestUtil . findTokenInAstByPredicate ( root , 
 + ast - > ast . getType ( ) = = TokenTypes . IMPORT ) ; 
 + 
 + Assert . assertTrue ( " Ast should contain IMPORT _ DEF " , importDef . isPresent ( ) ) ; 
 + Assert . assertTrue ( " State is not cleared on beginTree " , 
 + TestUtil . isStatefulFieldClearedDuringBeginTree ( check , importDef . get ( ) , " imports " , 
 + imports - > ( ( Collection < ? > ) imports ) . isEmpty ( ) ) ) ; 
 + } 
 + 
 + / * * 
 + * We cannot reproduce situation when visitToken is called and leaveToken is not . 
 + * So , we have to use reflection to be sure that even in such situation 
 + * state of the field will be cleared . 
 + * 
 + * @ throws Exception when code tested throws exception 
 + * / 
 + @ Test 
 + @ SuppressWarnings ( " unchecked " ) 
 + public void testClearStateInstantiations ( ) throws Exception { 
 + final IllegalInstantiationCheck check = new IllegalInstantiationCheck ( ) ; 
 + final DetailAST root = JavaParser . parseFile ( new File ( 
 + getNonCompilablePath ( " InputIllegalInstantiationLang . java " ) ) , 
 + JavaParser . Options . WITHOUT _ COMMENTS ) ; 
 + final Optional < DetailAST > literalNew = TestUtil . findTokenInAstByPredicate ( root , 
 + ast - > ast . getType ( ) = = TokenTypes . LITERAL _ NEW ) ; 
 + 
 + Assert . assertTrue ( " Ast should contain LITERAL _ NEW " , literalNew . isPresent ( ) ) ; 
 + Assert . assertTrue ( " State is not cleared on beginTree " , 
 + TestUtil . isStatefulFieldClearedDuringBeginTree ( check , literalNew . get ( ) , 
 + " instantiations " , 
 + instantiations - > ( ( Collection < DetailAST > ) instantiations ) . isEmpty ( ) ) ) ; 
 + } 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java 
 index 29362a7 . . 08edb4f 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java 
 @ @ - 22 , 7 + 22 , 10 @ @ package com . puppycrawl . tools . checkstyle . checks . coding ; 
 import static com . puppycrawl . tools . checkstyle . checks . coding . RequireThisCheck . MSG _ METHOD ; 
 import static com . puppycrawl . tools . checkstyle . checks . coding . RequireThisCheck . MSG _ VARIABLE ; 
 
 + import java . io . File ; 
 import java . lang . reflect . Constructor ; 
 + import java . util . Collection ; 
 + import java . util . Optional ; 
 import java . util . SortedSet ; 
 
 import org . junit . Assert ; 
 @ @ - 31 , 6 + 34 , 7 @ @ import org . junit . Test ; 
 import antlr . CommonHiddenStreamToken ; 
 import com . puppycrawl . tools . checkstyle . AbstractModuleTestSupport ; 
 import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; 
 + import com . puppycrawl . tools . checkstyle . JavaParser ; 
 import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; 
 import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 @ @ - 374 , 4 + 378 , 26 @ @ public class RequireThisCheckTest extends AbstractModuleTestSupport { 
 TestUtil . getClassDeclaredMethod ( cls , " getType " ) . invoke ( o ) . toString ( ) ) ; 
 } 
 
 + / * * 
 + * We cannot reproduce situation when visitToken is called and leaveToken is not . 
 + * So , we have to use reflection to be sure that even in such situation 
 + * state of the field will be cleared . 
 + * 
 + * @ throws Exception when code tested throws exception 
 + * / 
 + @ Test 
 + public void testClearState ( ) throws Exception { 
 + final RequireThisCheck check = new RequireThisCheck ( ) ; 
 + final DetailAST root = JavaParser . parseFile ( 
 + new File ( getPath ( " InputRequireThisSimple . java " ) ) , 
 + JavaParser . Options . WITHOUT _ COMMENTS ) ; 
 + final Optional < DetailAST > classDef = TestUtil . findTokenInAstByPredicate ( root , 
 + ast - > ast . getType ( ) = = TokenTypes . CLASS _ DEF ) ; 
 + 
 + Assert . assertTrue ( " Ast should contain CLASS _ DEF " , classDef . isPresent ( ) ) ; 
 + Assert . assertTrue ( " State is not cleared on beginTree " , 
 + TestUtil . isStatefulFieldClearedDuringBeginTree ( check , classDef . get ( ) , " current " , 
 + current - > ( ( Collection < ? > ) current ) . isEmpty ( ) ) ) ; 
 + } 
 + 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / VariableDeclarationUsageDistanceCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / VariableDeclarationUsageDistanceCheckTest . java 
 index 3e33b33 . . 57f3ca8 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / VariableDeclarationUsageDistanceCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / VariableDeclarationUsageDistanceCheckTest . java 
 @ @ - 79 , 6 + 79 , 8 @ @ public class VariableDeclarationUsageDistanceCheckTest extends 
 " 901 : " + getCheckMessage ( MSG _ KEY , " a " , 4 , 1 ) , 
 " 967 : " + getCheckMessage ( MSG _ KEY , " a " , 4 , 1 ) , 
 " 978 : " + getCheckMessage ( MSG _ KEY , " a " , 2 , 1 ) , 
 + " 989 : " + getCheckMessage ( MSG _ KEY , " a " , 3 , 1 ) , 
 + " 1024 : " + getCheckMessage ( MSG _ KEY , " c " , 3 , 1 ) , 
 } ; 
 verify ( checkConfig , getPath ( " InputVariableDeclarationUsageDistance . java " ) , expected ) ; 
 } 
 @ @ - 174 , 6 + 176 , 7 @ @ public class VariableDeclarationUsageDistanceCheckTest extends 
 " 540 : " + getCheckMessage ( MSG _ KEY , " id " , 2 , 1 ) , 
 " 542 : " + getCheckMessage ( MSG _ KEY , " parentId " , 4 , 1 ) , 
 " 978 : " + getCheckMessage ( MSG _ KEY , " a " , 2 , 1 ) , 
 + " 1024 : " + getCheckMessage ( MSG _ KEY , " c " , 4 , 1 ) , 
 } ; 
 verify ( checkConfig , getPath ( " InputVariableDeclarationUsageDistance . java " ) , expected ) ; 
 } 
 @ @ - 218 , 6 + 221 , 8 @ @ public class VariableDeclarationUsageDistanceCheckTest extends 
 " 891 : " + getCheckMessage ( MSG _ KEY _ EXT , " a " , 4 , 1 ) , 
 " 901 : " + getCheckMessage ( MSG _ KEY _ EXT , " a " , 4 , 1 ) , 
 " 967 : " + getCheckMessage ( MSG _ KEY _ EXT , " a " , 4 , 1 ) , 
 + " 989 : " + getCheckMessage ( MSG _ KEY _ EXT , " a " , 3 , 1 ) , 
 + " 1024 : " + getCheckMessage ( MSG _ KEY _ EXT , " c " , 3 , 1 ) , 
 } ; 
 verify ( checkConfig , getPath ( " InputVariableDeclarationUsageDistance . java " ) , expected ) ; 
 } 
 @ @ - 241 , 6 + 246 , 7 @ @ public class VariableDeclarationUsageDistanceCheckTest extends 
 " 479 : " + getCheckMessage ( MSG _ KEY _ EXT , " myOption " , 7 , 3 ) , 
 " 491 : " + getCheckMessage ( MSG _ KEY _ EXT , " myOption " , 6 , 3 ) , 
 " 542 : " + getCheckMessage ( MSG _ KEY _ EXT , " parentId " , 4 , 3 ) , 
 + " 1024 : " + getCheckMessage ( MSG _ KEY _ EXT , " c " , 4 , 3 ) , 
 } ; 
 
 verify ( checkConfig , getPath ( " InputVariableDeclarationUsageDistance . java " ) , expected ) ; 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / variabledeclarationusagedistance / InputVariableDeclarationUsageDistance . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / variabledeclarationusagedistance / InputVariableDeclarationUsageDistance . java 
 index 6bf4b3e . . cdff75f 100644 
 - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / variabledeclarationusagedistance / InputVariableDeclarationUsageDistance . java 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / variabledeclarationusagedistance / InputVariableDeclarationUsageDistance . java 
 @ @ - 985 , 4 + 985 , 67 @ @ class New { 
 final int c = a + 1 ; 
 } 
 
 + void test ( ) { 
 + int a = 0 ; 
 + 
 + System . lineSeparator ( ) ; 
 + System . lineSeparator ( ) ; 
 + System . lineSeparator ( ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) { 
 + if ( true ) { 
 + System . identityHashCode ( a ) ; 
 + } 
 + else { 
 + System . identityHashCode ( a ) ; 
 + } 
 + } 
 + 
 + int b = 0 ; 
 + try { 
 + for ( int i = 0 ; i < 10 ; i + + ) { 
 + if ( true ) { 
 + System . lineSeparator ( ) ; 
 + System . lineSeparator ( ) ; 
 + System . lineSeparator ( ) ; 
 + b = i ; 
 + } 
 + } 
 + 
 + System . lineSeparator ( ) ; 
 + System . lineSeparator ( ) ; 
 + } 
 + catch ( Exception e ) { 
 + System . lineSeparator ( ) ; 
 + } 
 + finally { 
 + System . identityHashCode ( b ) ; 
 + } 
 + 
 + int c = 0 ; 
 + System . lineSeparator ( ) ; 
 + System . lineSeparator ( ) ; 
 + System . lineSeparator ( ) ; 
 + 
 + if ( false ) { 
 + 
 + } 
 + else if ( c = = 1 ) { 
 + if ( c ! = 2 ) { 
 + System . lineSeparator ( ) ; 
 + } 
 + 
 + System . identityHashCode ( c ) ; 
 + } 
 + else if ( c = = 2 ) { 
 + System . identityHashCode ( c ) ; 
 + } 
 + } 
 + 
 + private void launch ( Integer number ) { 
 + String myInt = ( number . toString ( ) + ' \ 0 ' ) ; 
 + boolean result = false ; 
 + if ( number = = 123 ) 
 + result = true ; 
 + } 
 + 
 }

NEAREST DIFF:
diff - - git a / pom . xml b / pom . xml 
 index 31cc349 . . b56404a 100644 
 - - - a / pom . xml 
 + + + b / pom . xml 
 @ @ - 1362 , 6 + 1362 , 8 @ @ 
 < excludedLinks > 
 < excludedLink > reports / google - style / guava < / excludedLink > 
 < excludedLink > reports / javadoc / openjdk8 < / excludedLink > 
 + < ! - - temporal suppress till plugin update link in his source - - > 
 + < excludedLink > http : / / www . mojohaus . org / exec - maven - plugin < / excludedLink > 
 < ! - - temporal suppress till javadoc tool starts generating links to https - - > 
 < excludedLink > http : / / docs . oracle . com / javase < / excludedLink > 
 < ! - - SSL - - >
