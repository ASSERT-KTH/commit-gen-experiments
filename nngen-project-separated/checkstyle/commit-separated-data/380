BLEU SCORE: 0.01960062953647315

TEST MSG: Issue # 5555 : Refactoring of JavadocUtils static init
GENERATED MSG: UT coverage 100 % for com . puppycrawl . tools . checkstyle . Utils . # 1294

TEST DIFF (one line): diff - - git a / pom . xml b / pom . xml <nl> index 6415c68 . . becafd0 100644 <nl> - - - a / pom . xml <nl> + + + b / pom . xml <nl> @ @ - 1678 , 7 + 1678 , 6 @ @ <nl> < ! - - Deprecated classes - - > <nl> < exclude > com . puppycrawl . tools . checkstyle . checks . naming . AbstractTypeParameterNameCheck < / exclude > <nl> < ! - - Classes with their own config - - > <nl> - < exclude > com . puppycrawl . tools . checkstyle . utils . JavadocUtils < / exclude > <nl> < exclude > com . puppycrawl . tools . checkstyle . PackageNamesLoader < / exclude > <nl> < exclude > com . puppycrawl . tools . checkstyle . Main < / exclude > <nl> < exclude > com . puppycrawl . tools . checkstyle . JavadocDetailNodeParser . JavadocParserErrorStrategy < / exclude > <nl> @ @ - 1771 , 24 + 1770 , 6 @ @ <nl> < rule > <nl> < element > CLASS < / element > <nl> < includes > <nl> - < include > com . puppycrawl . tools . checkstyle . utils . JavadocUtils < / include > <nl> - < / includes > <nl> - < limits > <nl> - < limit > <nl> - < counter > LINE < / counter > <nl> - < value > COVEREDRATIO < / value > <nl> - < minimum > 0 . 99 < / minimum > <nl> - < / limit > <nl> - < limit > <nl> - < counter > BRANCH < / counter > <nl> - < value > COVEREDRATIO < / value > <nl> - < minimum > 0 . 98 < / minimum > <nl> - < / limit > <nl> - < / limits > <nl> - < / rule > <nl> - < rule > <nl> - < element > CLASS < / element > <nl> - < includes > <nl> < include > com . puppycrawl . tools . checkstyle . PackageNamesLoader < / include > <nl> < / includes > <nl> < limits > <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java <nl> index 48fc249 . . 0cc02b7 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java <nl> @ @ - 19 , 13 + 19 , 11 @ @ <nl> <nl> package com . puppycrawl . tools . checkstyle . utils ; <nl> <nl> - import java . lang . reflect . Field ; <nl> - import java . lang . reflect . Modifier ; <nl> import java . util . ArrayList ; <nl> import java . util . List ; <nl> + import java . util . Map ; <nl> import java . util . regex . Pattern ; <nl> <nl> - import com . google . common . collect . ImmutableMap ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailNode ; <nl> import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; <nl> @ @ - 60 , 7 + 58 , 7 @ @ public final class JavadocUtils { <nl> } <nl> <nl> / * * Maps from a token name to value . * / <nl> - private static final ImmutableMap < String , Integer > TOKEN _ NAME _ TO _ VALUE ; <nl> + private static final Map < String , Integer > TOKEN _ NAME _ TO _ VALUE ; <nl> / * * Maps from a token value to name . * / <nl> private static final String [ ] TOKEN _ VALUE _ TO _ NAME ; <nl> <nl> @ @ - 77 , 40 + 75 , 10 @ @ public final class JavadocUtils { <nl> / * * Tab pattern . * / <nl> private static final Pattern TAB = Pattern . compile ( " \ t " ) ; <nl> <nl> - / / Using reflection gets all token names and values from JavadocTokenTypes class <nl> - / / and saves to TOKEN _ NAME _ TO _ VALUE and TOKEN _ VALUE _ TO _ NAME collections . <nl> + / / initialise the constants <nl> static { <nl> - final ImmutableMap . Builder < String , Integer > builder = ImmutableMap . builder ( ) ; <nl> - <nl> - final Field [ ] fields = JavadocTokenTypes . class . getDeclaredFields ( ) ; <nl> - <nl> - String [ ] tempTokenValueToName = CommonUtils . EMPTY _ STRING _ ARRAY ; <nl> - <nl> - for ( final Field field : fields ) { <nl> - / / Only process public int fields . <nl> - if ( Modifier . isPublic ( field . getModifiers ( ) ) <nl> - & & field . getType ( ) = = Integer . TYPE ) { <nl> - <nl> - final String name = field . getName ( ) ; <nl> - <nl> - final int tokenValue = TokenUtils . getIntFromField ( field , name ) ; <nl> - builder . put ( name , tokenValue ) ; <nl> - if ( tokenValue > tempTokenValueToName . length - 1 ) { <nl> - final String [ ] temp = new String [ tokenValue + 1 ] ; <nl> - System . arraycopy ( tempTokenValueToName , 0 , temp , 0 , tempTokenValueToName . length ) ; <nl> - tempTokenValueToName = temp ; <nl> - } <nl> - if ( tokenValue = = - 1 ) { <nl> - tempTokenValueToName [ 0 ] = name ; <nl> - } <nl> - else { <nl> - tempTokenValueToName [ tokenValue ] = name ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - TOKEN _ NAME _ TO _ VALUE = builder . build ( ) ; <nl> - TOKEN _ VALUE _ TO _ NAME = tempTokenValueToName ; <nl> + TOKEN _ NAME _ TO _ VALUE = TokenUtils . nameToValueMapFromPublicIntFields ( JavadocTokenTypes . class ) ; <nl> + TOKEN _ VALUE _ TO _ NAME = TokenUtils . valueToNameArrayFromNameToValueMap ( TOKEN _ NAME _ TO _ VALUE ) ; <nl> } <nl> <nl> / * * Prevent instantiation . * / <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java <nl> index 9190b1c . . 400f1eb 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java <nl> @ @ - 20 , 12 + 20 , 16 @ @ <nl> package com . puppycrawl . tools . checkstyle . utils ; <nl> <nl> import java . lang . reflect . Field ; <nl> + import java . lang . reflect . Modifier ; <nl> + import java . util . Arrays ; <nl> + import java . util . Collections ; <nl> import java . util . Locale ; <nl> + import java . util . Map ; <nl> import java . util . Optional ; <nl> import java . util . ResourceBundle ; <nl> import java . util . function . Predicate ; <nl> + import java . util . stream . Collectors ; <nl> <nl> - import com . google . common . collect . ImmutableMap ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> <nl> @ @ - 37 , 7 + 41 , 7 @ @ import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> public final class TokenUtils { <nl> <nl> / * * Maps from a token name to value . * / <nl> - private static final ImmutableMap < String , Integer > TOKEN _ NAME _ TO _ VALUE ; <nl> + private static final Map < String , Integer > TOKEN _ NAME _ TO _ VALUE ; <nl> / * * Maps from a token value to name . * / <nl> private static final String [ ] TOKEN _ VALUE _ TO _ NAME ; <nl> <nl> @ @ - 52 , 29 + 56 , 8 @ @ public final class TokenUtils { <nl> <nl> / / initialise the constants <nl> static { <nl> - final ImmutableMap . Builder < String , Integer > builder = <nl> - ImmutableMap . builder ( ) ; <nl> - final Field [ ] fields = TokenTypes . class . getDeclaredFields ( ) ; <nl> - String [ ] tempTokenValueToName = CommonUtils . EMPTY _ STRING _ ARRAY ; <nl> - for ( final Field field : fields ) { <nl> - / / Only process the int declarations . <nl> - if ( field . getType ( ) = = Integer . TYPE ) { <nl> - <nl> - final String name = field . getName ( ) ; <nl> - final int tokenValue = getIntFromField ( field , name ) ; <nl> - builder . put ( name , tokenValue ) ; <nl> - if ( tokenValue > tempTokenValueToName . length - 1 ) { <nl> - final String [ ] temp = new String [ tokenValue + 1 ] ; <nl> - System . arraycopy ( tempTokenValueToName , 0 , <nl> - temp , 0 , tempTokenValueToName . length ) ; <nl> - tempTokenValueToName = temp ; <nl> - } <nl> - tempTokenValueToName [ tokenValue ] = name ; <nl> - } <nl> - } <nl> - <nl> - TOKEN _ NAME _ TO _ VALUE = builder . build ( ) ; <nl> - TOKEN _ VALUE _ TO _ NAME = tempTokenValueToName ; <nl> + TOKEN _ NAME _ TO _ VALUE = nameToValueMapFromPublicIntFields ( TokenTypes . class ) ; <nl> + TOKEN _ VALUE _ TO _ NAME = valueToNameArrayFromNameToValueMap ( TOKEN _ NAME _ TO _ VALUE ) ; <nl> TOKEN _ IDS = TOKEN _ NAME _ TO _ VALUE . values ( ) . stream ( ) . mapToInt ( Integer : : intValue ) . toArray ( ) ; <nl> } <nl> <nl> @ @ - 102 , 6 + 85 , 42 @ @ public final class TokenUtils { <nl> } <nl> <nl> / * * <nl> + * Creates a map of ' field name ' to ' field value ' from all { @ code public } { @ code int } fields <nl> + * of a class . <nl> + * @ param cls source class <nl> + * @ return unmodifiable name to value map <nl> + * / <nl> + public static Map < String , Integer > nameToValueMapFromPublicIntFields ( Class < ? > cls ) { <nl> + final Map < String , Integer > map = Arrays . stream ( cls . getDeclaredFields ( ) ) <nl> + . filter ( fld - > Modifier . isPublic ( fld . getModifiers ( ) ) & & fld . getType ( ) = = Integer . TYPE ) <nl> + . collect ( Collectors . toMap ( Field : : getName , fld - > getIntFromField ( fld , fld . getName ( ) ) ) ) ; <nl> + return Collections . unmodifiableMap ( map ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Creates an array of map keys for quick value - to - name lookup for the map . <nl> + * @ param map source map <nl> + * @ return array of map keys <nl> + * / <nl> + public static String [ ] valueToNameArrayFromNameToValueMap ( Map < String , Integer > map ) { <nl> + String [ ] valueToNameArray = CommonUtils . EMPTY _ STRING _ ARRAY ; <nl> + <nl> + for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { <nl> + final int value = entry . getValue ( ) ; <nl> + / / JavadocTokenTypes . EOF has value ' - 1 ' and is handled explicitly . <nl> + if ( value > = 0 ) { <nl> + if ( value > = valueToNameArray . length ) { <nl> + final String [ ] temp = new String [ value + 1 ] ; <nl> + System . arraycopy ( valueToNameArray , 0 , temp , 0 , valueToNameArray . length ) ; <nl> + valueToNameArray = temp ; <nl> + } <nl> + valueToNameArray [ value ] = entry . getKey ( ) ; <nl> + } <nl> + } <nl> + return valueToNameArray ; <nl> + } <nl> + <nl> + / * * <nl> * Get total number of TokenTypes . <nl> * @ return total number of TokenTypes . <nl> * / <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / utils / TokenUtilsTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / utils / TokenUtilsTest . java <nl> index 6ec133f . . 27613b4 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / utils / TokenUtilsTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / utils / TokenUtilsTest . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ <nl> package com . puppycrawl . tools . checkstyle . utils ; <nl> <nl> import static com . puppycrawl . tools . checkstyle . internal . utils . TestUtil . isUtilsClassHasPrivateConstructor ; <nl> + import static org . junit . Assert . assertArrayEquals ; <nl> import static org . junit . Assert . assertEquals ; <nl> import static org . junit . Assert . assertTrue ; <nl> import static org . junit . Assert . fail ; <nl> @ @ - 27 , 7 + 28 , 9 @ @ import static org . junit . Assert . fail ; <nl> import java . lang . reflect . Field ; <nl> import java . lang . reflect . Modifier ; <nl> import java . util . Arrays ; <nl> + import java . util . Map ; <nl> import java . util . Optional ; <nl> + import java . util . TreeMap ; <nl> <nl> import org . junit . Test ; <nl> <nl> @ @ - 70 , 6 + 73 , 35 @ @ public class TokenUtilsTest { <nl> } <nl> <nl> @ Test <nl> + public void testNameToValueMapFromPublicIntFields ( ) { <nl> + final Map < String , Integer > actualMap = <nl> + TokenUtils . nameToValueMapFromPublicIntFields ( Integer . class ) ; <nl> + final Map < String , Integer > expectedMap = new TreeMap < > ( ) ; <nl> + expectedMap . put ( " BYTES " , Integer . BYTES ) ; <nl> + expectedMap . put ( " SIZE " , Integer . SIZE ) ; <nl> + expectedMap . put ( " MAX _ VALUE " , Integer . MAX _ VALUE ) ; <nl> + expectedMap . put ( " MIN _ VALUE " , Integer . MIN _ VALUE ) ; <nl> + <nl> + assertEquals ( " Unexpected name to value map " , expectedMap , actualMap ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testValueToNameArrayFromNameToValueMap ( ) { <nl> + final Map < String , Integer > map = new TreeMap < > ( ) ; <nl> + map . put ( " ZERO " , 0 ) ; <nl> + map . put ( " ONE " , 1 ) ; <nl> + map . put ( " TWO " , 2 ) ; <nl> + map . put ( " NEGATIVE " , - 1 ) ; <nl> + <nl> + final String [ ] actualArray = <nl> + TokenUtils . valueToNameArrayFromNameToValueMap ( map ) ; <nl> + final String [ ] expectedArray = { " ZERO " , " ONE " , " TWO " } ; <nl> + <nl> + assertArrayEquals ( " Unexpected value to name array " , <nl> + expectedArray , actualArray ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testTokenValueIncorrect ( ) throws IllegalAccessException { <nl> int maxId = 0 ; <nl> final Field [ ] fields = TokenTypes . class . getDeclaredFields ( ) ; <nl> @ @ - 137 , 12 + 169 , 13 @ @ public class TokenUtilsTest { <nl> fail ( " IllegalArgumentException is expected " ) ; <nl> } <nl> catch ( IllegalArgumentException expected ) { <nl> - / / restoring original value , to let other tests pass <nl> - fieldToken . set ( null , originalValue ) ; <nl> - <nl> assertEquals ( " Invalid exception message " , <nl> " given id " + id , expected . getMessage ( ) ) ; <nl> } <nl> + finally { <nl> + / / restoring original value , to let other tests pass <nl> + fieldToken . set ( null , originalValue ) ; <nl> + } <nl> } <nl> <nl> @ Test
NEAREST DIFF (one line): diff - - git a / pom . xml b / pom . xml <nl> index 39ed7e6 . . 34768b8 100644 <nl> - - - a / pom . xml <nl> + + + b / pom . xml <nl> @ @ - 692 , 7 + 692 , 6 @ @ <nl> < totalBranchRate > 85 < / totalBranchRate > <nl> < totalLineRate > 93 < / totalLineRate > <nl> < regexes > <nl> - < regex > < pattern > . * . checkstyle . AnnotationUtility < / pattern > < branchRate > 60 < / branchRate > < lineRate > 60 < / lineRate > < / regex > <nl> < regex > < pattern > . * . Checker < / pattern > < branchRate > 79 < / branchRate > < lineRate > 84 < / lineRate > < / regex > <nl> < regex > < pattern > . * . ConfigurationLoader < / pattern > < branchRate > 86 < / branchRate > < lineRate > 79 < / lineRate > < / regex > <nl> < regex > < pattern > . * . ConfigurationLoader \ $ . * < / pattern > < branchRate > 65 < / branchRate > < lineRate > 84 < / lineRate > < / regex > <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java b / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java <nl> index 59f5d0a . . 7cf5ca6 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ package com . puppycrawl . tools . checkstyle ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . FullIdent ; <nl> import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> + <nl> import org . apache . commons . lang3 . StringUtils ; <nl> <nl> / * * <nl> @ @ - 30 , 6 + 31 , 12 @ @ import org . apache . commons . lang3 . StringUtils ; <nl> * @ author Travis Schneeberger <nl> * / <nl> public final class AnnotationUtility { <nl> + <nl> + / * * <nl> + * Common message <nl> + * / <nl> + private static final String THE _ AST _ IS _ NULL = " the ast is null " ; <nl> + <nl> / * * <nl> * private utility constructor . <nl> * @ throws UnsupportedOperationException if called <nl> @ @ - 58 , 11 + 65 , 12 @ @ public final class AnnotationUtility { <nl> * @ param ast the current node <nl> * @ param annotation the annotation name to check for <nl> * @ return true if contains the annotation <nl> - * @ throws NullPointerException if the ast or <nl> - * annotation is null <nl> * / <nl> public static boolean containsAnnotation ( final DetailAST ast , <nl> String annotation ) { <nl> + if ( ast = = null ) { <nl> + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; <nl> + } <nl> return AnnotationUtility . getAnnotation ( ast , annotation ) ! = null ; <nl> } <nl> <nl> @ @ - 72 , 9 + 80 , 11 @ @ public final class AnnotationUtility { <nl> * <nl> * @ param ast the current node <nl> * @ return true if contains an annotation <nl> - * @ throws NullPointerException if the ast is null <nl> * / <nl> public static boolean containsAnnotation ( final DetailAST ast ) { <nl> + if ( ast = = null ) { <nl> + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; <nl> + } <nl> final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; <nl> return holder ! = null & & holder . branchContains ( TokenTypes . ANNOTATION ) ; <nl> } <nl> @ @ - 86 , 11 + 96 , 10 @ @ public final class AnnotationUtility { <nl> * <nl> * @ param ast the current node <nl> * @ return the Annotation Holder <nl> - * @ throws NullPointerException if the ast is null <nl> * / <nl> public static DetailAST getAnnotationHolder ( DetailAST ast ) { <nl> if ( ast = = null ) { <nl> - throw new IllegalArgumentException ( " the ast is null " ) ; <nl> + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; <nl> } <nl> <nl> final DetailAST annotationHolder ; <nl> @ @ - 127 , 13 + 136 , 11 @ @ public final class AnnotationUtility { <nl> * @ param ast the current node <nl> * @ param annotation the annotation name to check for <nl> * @ return the AST representing that annotation <nl> - * @ throws NullPointerException if the ast or <nl> - * annotation is null <nl> * / <nl> public static DetailAST getAnnotation ( final DetailAST ast , <nl> String annotation ) { <nl> if ( ast = = null ) { <nl> - throw new IllegalArgumentException ( " the ast is null " ) ; <nl> + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; <nl> } <nl> <nl> if ( annotation = = null ) { <nl> @ @ - 141 , 8 + 148 , 8 @ @ public final class AnnotationUtility { <nl> } <nl> <nl> if ( StringUtils . isBlank ( annotation ) ) { <nl> - throw new IllegalArgumentException ( " the annotation " <nl> - + " is empty or spaces " ) ; <nl> + throw new IllegalArgumentException ( <nl> + " the annotation is empty or spaces " ) ; <nl> } <nl> <nl> final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; <nl> @ @ - 162 , 42 + 169 , 4 @ @ public final class AnnotationUtility { <nl> return null ; <nl> } <nl> <nl> - / * * <nl> - * Checks to see what the passed in AST ( representing <nl> - * an annotation ) is annotating . <nl> - * <nl> - * @ param ast the AST representing an annotation . <nl> - * @ return the AST the annotation is annotating . <nl> - * @ throws NullPointerException if the ast is null <nl> - * @ throws IllegalArgumentException if the ast is not <nl> - * an { @ link TokenTypes # ANNOTATION } <nl> - * / <nl> - public static DetailAST annotatingWhat ( DetailAST ast ) { <nl> - if ( ast = = null ) { <nl> - throw new IllegalArgumentException ( " the ast is null " ) ; <nl> - } <nl> - <nl> - if ( ast . getType ( ) ! = TokenTypes . ANNOTATION ) { <nl> - throw new IllegalArgumentException ( <nl> - " The ast is not an annotation . AST : " + ast ) ; <nl> - } <nl> - <nl> - return ast . getParent ( ) . getParent ( ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Checks to see if the passed in AST ( representing <nl> - * an annotation ) is annotating the passed in type . <nl> - * @ param ast the AST representing an annotation <nl> - * @ param tokenType the passed in type <nl> - * @ return true if the annotation is annotating a type <nl> - * equal to the passed in type <nl> - * @ throws NullPointerException if the ast is null <nl> - * @ throws IllegalArgumentException if the ast is not <nl> - * an { @ link TokenTypes # ANNOTATION } <nl> - * / <nl> - public static boolean isAnnotatingType ( DetailAST ast , int tokenType ) { <nl> - final DetailAST astNode = AnnotationUtility . annotatingWhat ( ast ) ; <nl> - return astNode . getType ( ) = = tokenType ; <nl> - } <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java <nl> new file mode 100644 <nl> index 0000000 . . 311dd7f <nl> - - - / dev / null <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java <nl> @ @ - 0 , 0 + 1 , 140 @ @ <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + / / checkstyle : Checks Java source code for adherence to a set of rules . <nl> + / / Copyright ( C ) 2001 - 2015 the original author or authors . <nl> + / / <nl> + / / This library is free software ; you can redistribute it and / or <nl> + / / modify it under the terms of the GNU Lesser General Public <nl> + / / License as published by the Free Software Foundation ; either <nl> + / / version 2 . 1 of the License , or ( at your option ) any later version . <nl> + / / <nl> + / / This library is distributed in the hope that it will be useful , <nl> + / / but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + / / MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + / / Lesser General Public License for more details . <nl> + / / <nl> + / / You should have received a copy of the GNU Lesser General Public <nl> + / / License along with this library ; if not , write to the Free Software <nl> + / / Foundation , Inc . , 59 Temple Place , Suite 330 , Boston , MA 02111 - 1307 USA <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + <nl> + package com . puppycrawl . tools . checkstyle ; <nl> + <nl> + import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; <nl> + <nl> + import java . lang . reflect . InvocationTargetException ; <nl> + <nl> + import org . junit . Assert ; <nl> + import org . junit . Test ; <nl> + <nl> + import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> + import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> + <nl> + public class AnnotationUtilityTest { <nl> + <nl> + @ Test <nl> + public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { <nl> + try { <nl> + assertUtilsClassHasPrivateConstructor ( AnnotationUtility . class ) ; <nl> + } <nl> + catch ( InvocationTargetException ex ) { <nl> + Assert . assertTrue ( " do not instantiate . " . equals ( ex . getCause ( ) . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationNull ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . containsAnnotation ( null ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationNull2 ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . containsAnnotation ( null , " " ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationFalse ( ) throws ReflectiveOperationException { <nl> + DetailAST ast = new DetailAST ( ) ; <nl> + ast . setType ( 1 ) ; <nl> + Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationFalse2 ( ) throws ReflectiveOperationException { <nl> + DetailAST ast = new DetailAST ( ) ; <nl> + ast . setType ( 1 ) ; <nl> + DetailAST ast2 = new DetailAST ( ) ; <nl> + ast2 . setType ( TokenTypes . MODIFIERS ) ; <nl> + ast . addChild ( ast2 ) ; <nl> + Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationTrue ( ) throws ReflectiveOperationException { <nl> + DetailAST ast = new DetailAST ( ) ; <nl> + ast . setType ( 1 ) ; <nl> + DetailAST ast2 = new DetailAST ( ) ; <nl> + ast2 . setType ( TokenTypes . MODIFIERS ) ; <nl> + ast . addChild ( ast2 ) ; <nl> + DetailAST ast3 = new DetailAST ( ) ; <nl> + ast3 . setType ( TokenTypes . ANNOTATION ) ; <nl> + ast2 . addChild ( ast3 ) ; <nl> + Assert . assertTrue ( AnnotationUtility . containsAnnotation ( ast ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAnnotationHolderNull ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . getAnnotationHolder ( null ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testAnnotationNull ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . getAnnotation ( null , null ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testAnnotationNull2 ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . getAnnotation ( new DetailAST ( ) , null ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the annotation is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testAnnotationEmpty ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . getAnnotation ( new DetailAST ( ) , " " ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the annotation is empty or spaces " <nl> + . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + }

TEST DIFF:
diff - - git a / pom . xml b / pom . xml 
 index 6415c68 . . becafd0 100644 
 - - - a / pom . xml 
 + + + b / pom . xml 
 @ @ - 1678 , 7 + 1678 , 6 @ @ 
 < ! - - Deprecated classes - - > 
 < exclude > com . puppycrawl . tools . checkstyle . checks . naming . AbstractTypeParameterNameCheck < / exclude > 
 < ! - - Classes with their own config - - > 
 - < exclude > com . puppycrawl . tools . checkstyle . utils . JavadocUtils < / exclude > 
 < exclude > com . puppycrawl . tools . checkstyle . PackageNamesLoader < / exclude > 
 < exclude > com . puppycrawl . tools . checkstyle . Main < / exclude > 
 < exclude > com . puppycrawl . tools . checkstyle . JavadocDetailNodeParser . JavadocParserErrorStrategy < / exclude > 
 @ @ - 1771 , 24 + 1770 , 6 @ @ 
 < rule > 
 < element > CLASS < / element > 
 < includes > 
 - < include > com . puppycrawl . tools . checkstyle . utils . JavadocUtils < / include > 
 - < / includes > 
 - < limits > 
 - < limit > 
 - < counter > LINE < / counter > 
 - < value > COVEREDRATIO < / value > 
 - < minimum > 0 . 99 < / minimum > 
 - < / limit > 
 - < limit > 
 - < counter > BRANCH < / counter > 
 - < value > COVEREDRATIO < / value > 
 - < minimum > 0 . 98 < / minimum > 
 - < / limit > 
 - < / limits > 
 - < / rule > 
 - < rule > 
 - < element > CLASS < / element > 
 - < includes > 
 < include > com . puppycrawl . tools . checkstyle . PackageNamesLoader < / include > 
 < / includes > 
 < limits > 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java 
 index 48fc249 . . 0cc02b7 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java 
 @ @ - 19 , 13 + 19 , 11 @ @ 
 
 package com . puppycrawl . tools . checkstyle . utils ; 
 
 - import java . lang . reflect . Field ; 
 - import java . lang . reflect . Modifier ; 
 import java . util . ArrayList ; 
 import java . util . List ; 
 + import java . util . Map ; 
 import java . util . regex . Pattern ; 
 
 - import com . google . common . collect . ImmutableMap ; 
 import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . DetailNode ; 
 import com . puppycrawl . tools . checkstyle . api . JavadocTokenTypes ; 
 @ @ - 60 , 7 + 58 , 7 @ @ public final class JavadocUtils { 
 } 
 
 / * * Maps from a token name to value . * / 
 - private static final ImmutableMap < String , Integer > TOKEN _ NAME _ TO _ VALUE ; 
 + private static final Map < String , Integer > TOKEN _ NAME _ TO _ VALUE ; 
 / * * Maps from a token value to name . * / 
 private static final String [ ] TOKEN _ VALUE _ TO _ NAME ; 
 
 @ @ - 77 , 40 + 75 , 10 @ @ public final class JavadocUtils { 
 / * * Tab pattern . * / 
 private static final Pattern TAB = Pattern . compile ( " \ t " ) ; 
 
 - / / Using reflection gets all token names and values from JavadocTokenTypes class 
 - / / and saves to TOKEN _ NAME _ TO _ VALUE and TOKEN _ VALUE _ TO _ NAME collections . 
 + / / initialise the constants 
 static { 
 - final ImmutableMap . Builder < String , Integer > builder = ImmutableMap . builder ( ) ; 
 - 
 - final Field [ ] fields = JavadocTokenTypes . class . getDeclaredFields ( ) ; 
 - 
 - String [ ] tempTokenValueToName = CommonUtils . EMPTY _ STRING _ ARRAY ; 
 - 
 - for ( final Field field : fields ) { 
 - / / Only process public int fields . 
 - if ( Modifier . isPublic ( field . getModifiers ( ) ) 
 - & & field . getType ( ) = = Integer . TYPE ) { 
 - 
 - final String name = field . getName ( ) ; 
 - 
 - final int tokenValue = TokenUtils . getIntFromField ( field , name ) ; 
 - builder . put ( name , tokenValue ) ; 
 - if ( tokenValue > tempTokenValueToName . length - 1 ) { 
 - final String [ ] temp = new String [ tokenValue + 1 ] ; 
 - System . arraycopy ( tempTokenValueToName , 0 , temp , 0 , tempTokenValueToName . length ) ; 
 - tempTokenValueToName = temp ; 
 - } 
 - if ( tokenValue = = - 1 ) { 
 - tempTokenValueToName [ 0 ] = name ; 
 - } 
 - else { 
 - tempTokenValueToName [ tokenValue ] = name ; 
 - } 
 - } 
 - } 
 - 
 - TOKEN _ NAME _ TO _ VALUE = builder . build ( ) ; 
 - TOKEN _ VALUE _ TO _ NAME = tempTokenValueToName ; 
 + TOKEN _ NAME _ TO _ VALUE = TokenUtils . nameToValueMapFromPublicIntFields ( JavadocTokenTypes . class ) ; 
 + TOKEN _ VALUE _ TO _ NAME = TokenUtils . valueToNameArrayFromNameToValueMap ( TOKEN _ NAME _ TO _ VALUE ) ; 
 } 
 
 / * * Prevent instantiation . * / 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java 
 index 9190b1c . . 400f1eb 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java 
 @ @ - 20 , 12 + 20 , 16 @ @ 
 package com . puppycrawl . tools . checkstyle . utils ; 
 
 import java . lang . reflect . Field ; 
 + import java . lang . reflect . Modifier ; 
 + import java . util . Arrays ; 
 + import java . util . Collections ; 
 import java . util . Locale ; 
 + import java . util . Map ; 
 import java . util . Optional ; 
 import java . util . ResourceBundle ; 
 import java . util . function . Predicate ; 
 + import java . util . stream . Collectors ; 
 
 - import com . google . common . collect . ImmutableMap ; 
 import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 
 @ @ - 37 , 7 + 41 , 7 @ @ import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 public final class TokenUtils { 
 
 / * * Maps from a token name to value . * / 
 - private static final ImmutableMap < String , Integer > TOKEN _ NAME _ TO _ VALUE ; 
 + private static final Map < String , Integer > TOKEN _ NAME _ TO _ VALUE ; 
 / * * Maps from a token value to name . * / 
 private static final String [ ] TOKEN _ VALUE _ TO _ NAME ; 
 
 @ @ - 52 , 29 + 56 , 8 @ @ public final class TokenUtils { 
 
 / / initialise the constants 
 static { 
 - final ImmutableMap . Builder < String , Integer > builder = 
 - ImmutableMap . builder ( ) ; 
 - final Field [ ] fields = TokenTypes . class . getDeclaredFields ( ) ; 
 - String [ ] tempTokenValueToName = CommonUtils . EMPTY _ STRING _ ARRAY ; 
 - for ( final Field field : fields ) { 
 - / / Only process the int declarations . 
 - if ( field . getType ( ) = = Integer . TYPE ) { 
 - 
 - final String name = field . getName ( ) ; 
 - final int tokenValue = getIntFromField ( field , name ) ; 
 - builder . put ( name , tokenValue ) ; 
 - if ( tokenValue > tempTokenValueToName . length - 1 ) { 
 - final String [ ] temp = new String [ tokenValue + 1 ] ; 
 - System . arraycopy ( tempTokenValueToName , 0 , 
 - temp , 0 , tempTokenValueToName . length ) ; 
 - tempTokenValueToName = temp ; 
 - } 
 - tempTokenValueToName [ tokenValue ] = name ; 
 - } 
 - } 
 - 
 - TOKEN _ NAME _ TO _ VALUE = builder . build ( ) ; 
 - TOKEN _ VALUE _ TO _ NAME = tempTokenValueToName ; 
 + TOKEN _ NAME _ TO _ VALUE = nameToValueMapFromPublicIntFields ( TokenTypes . class ) ; 
 + TOKEN _ VALUE _ TO _ NAME = valueToNameArrayFromNameToValueMap ( TOKEN _ NAME _ TO _ VALUE ) ; 
 TOKEN _ IDS = TOKEN _ NAME _ TO _ VALUE . values ( ) . stream ( ) . mapToInt ( Integer : : intValue ) . toArray ( ) ; 
 } 
 
 @ @ - 102 , 6 + 85 , 42 @ @ public final class TokenUtils { 
 } 
 
 / * * 
 + * Creates a map of ' field name ' to ' field value ' from all { @ code public } { @ code int } fields 
 + * of a class . 
 + * @ param cls source class 
 + * @ return unmodifiable name to value map 
 + * / 
 + public static Map < String , Integer > nameToValueMapFromPublicIntFields ( Class < ? > cls ) { 
 + final Map < String , Integer > map = Arrays . stream ( cls . getDeclaredFields ( ) ) 
 + . filter ( fld - > Modifier . isPublic ( fld . getModifiers ( ) ) & & fld . getType ( ) = = Integer . TYPE ) 
 + . collect ( Collectors . toMap ( Field : : getName , fld - > getIntFromField ( fld , fld . getName ( ) ) ) ) ; 
 + return Collections . unmodifiableMap ( map ) ; 
 + } 
 + 
 + / * * 
 + * Creates an array of map keys for quick value - to - name lookup for the map . 
 + * @ param map source map 
 + * @ return array of map keys 
 + * / 
 + public static String [ ] valueToNameArrayFromNameToValueMap ( Map < String , Integer > map ) { 
 + String [ ] valueToNameArray = CommonUtils . EMPTY _ STRING _ ARRAY ; 
 + 
 + for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { 
 + final int value = entry . getValue ( ) ; 
 + / / JavadocTokenTypes . EOF has value ' - 1 ' and is handled explicitly . 
 + if ( value > = 0 ) { 
 + if ( value > = valueToNameArray . length ) { 
 + final String [ ] temp = new String [ value + 1 ] ; 
 + System . arraycopy ( valueToNameArray , 0 , temp , 0 , valueToNameArray . length ) ; 
 + valueToNameArray = temp ; 
 + } 
 + valueToNameArray [ value ] = entry . getKey ( ) ; 
 + } 
 + } 
 + return valueToNameArray ; 
 + } 
 + 
 + / * * 
 * Get total number of TokenTypes . 
 * @ return total number of TokenTypes . 
 * / 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / utils / TokenUtilsTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / utils / TokenUtilsTest . java 
 index 6ec133f . . 27613b4 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / utils / TokenUtilsTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / utils / TokenUtilsTest . java 
 @ @ - 20 , 6 + 20 , 7 @ @ 
 package com . puppycrawl . tools . checkstyle . utils ; 
 
 import static com . puppycrawl . tools . checkstyle . internal . utils . TestUtil . isUtilsClassHasPrivateConstructor ; 
 + import static org . junit . Assert . assertArrayEquals ; 
 import static org . junit . Assert . assertEquals ; 
 import static org . junit . Assert . assertTrue ; 
 import static org . junit . Assert . fail ; 
 @ @ - 27 , 7 + 28 , 9 @ @ import static org . junit . Assert . fail ; 
 import java . lang . reflect . Field ; 
 import java . lang . reflect . Modifier ; 
 import java . util . Arrays ; 
 + import java . util . Map ; 
 import java . util . Optional ; 
 + import java . util . TreeMap ; 
 
 import org . junit . Test ; 
 
 @ @ - 70 , 6 + 73 , 35 @ @ public class TokenUtilsTest { 
 } 
 
 @ Test 
 + public void testNameToValueMapFromPublicIntFields ( ) { 
 + final Map < String , Integer > actualMap = 
 + TokenUtils . nameToValueMapFromPublicIntFields ( Integer . class ) ; 
 + final Map < String , Integer > expectedMap = new TreeMap < > ( ) ; 
 + expectedMap . put ( " BYTES " , Integer . BYTES ) ; 
 + expectedMap . put ( " SIZE " , Integer . SIZE ) ; 
 + expectedMap . put ( " MAX _ VALUE " , Integer . MAX _ VALUE ) ; 
 + expectedMap . put ( " MIN _ VALUE " , Integer . MIN _ VALUE ) ; 
 + 
 + assertEquals ( " Unexpected name to value map " , expectedMap , actualMap ) ; 
 + } 
 + 
 + @ Test 
 + public void testValueToNameArrayFromNameToValueMap ( ) { 
 + final Map < String , Integer > map = new TreeMap < > ( ) ; 
 + map . put ( " ZERO " , 0 ) ; 
 + map . put ( " ONE " , 1 ) ; 
 + map . put ( " TWO " , 2 ) ; 
 + map . put ( " NEGATIVE " , - 1 ) ; 
 + 
 + final String [ ] actualArray = 
 + TokenUtils . valueToNameArrayFromNameToValueMap ( map ) ; 
 + final String [ ] expectedArray = { " ZERO " , " ONE " , " TWO " } ; 
 + 
 + assertArrayEquals ( " Unexpected value to name array " , 
 + expectedArray , actualArray ) ; 
 + } 
 + 
 + @ Test 
 public void testTokenValueIncorrect ( ) throws IllegalAccessException { 
 int maxId = 0 ; 
 final Field [ ] fields = TokenTypes . class . getDeclaredFields ( ) ; 
 @ @ - 137 , 12 + 169 , 13 @ @ public class TokenUtilsTest { 
 fail ( " IllegalArgumentException is expected " ) ; 
 } 
 catch ( IllegalArgumentException expected ) { 
 - / / restoring original value , to let other tests pass 
 - fieldToken . set ( null , originalValue ) ; 
 - 
 assertEquals ( " Invalid exception message " , 
 " given id " + id , expected . getMessage ( ) ) ; 
 } 
 + finally { 
 + / / restoring original value , to let other tests pass 
 + fieldToken . set ( null , originalValue ) ; 
 + } 
 } 
 
 @ Test

NEAREST DIFF:
diff - - git a / pom . xml b / pom . xml 
 index 39ed7e6 . . 34768b8 100644 
 - - - a / pom . xml 
 + + + b / pom . xml 
 @ @ - 692 , 7 + 692 , 6 @ @ 
 < totalBranchRate > 85 < / totalBranchRate > 
 < totalLineRate > 93 < / totalLineRate > 
 < regexes > 
 - < regex > < pattern > . * . checkstyle . AnnotationUtility < / pattern > < branchRate > 60 < / branchRate > < lineRate > 60 < / lineRate > < / regex > 
 < regex > < pattern > . * . Checker < / pattern > < branchRate > 79 < / branchRate > < lineRate > 84 < / lineRate > < / regex > 
 < regex > < pattern > . * . ConfigurationLoader < / pattern > < branchRate > 86 < / branchRate > < lineRate > 79 < / lineRate > < / regex > 
 < regex > < pattern > . * . ConfigurationLoader \ $ . * < / pattern > < branchRate > 65 < / branchRate > < lineRate > 84 < / lineRate > < / regex > 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java b / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java 
 index 59f5d0a . . 7cf5ca6 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java 
 @ @ - 22 , 6 + 22 , 7 @ @ package com . puppycrawl . tools . checkstyle ; 
 import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . FullIdent ; 
 import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 + 
 import org . apache . commons . lang3 . StringUtils ; 
 
 / * * 
 @ @ - 30 , 6 + 31 , 12 @ @ import org . apache . commons . lang3 . StringUtils ; 
 * @ author Travis Schneeberger 
 * / 
 public final class AnnotationUtility { 
 + 
 + / * * 
 + * Common message 
 + * / 
 + private static final String THE _ AST _ IS _ NULL = " the ast is null " ; 
 + 
 / * * 
 * private utility constructor . 
 * @ throws UnsupportedOperationException if called 
 @ @ - 58 , 11 + 65 , 12 @ @ public final class AnnotationUtility { 
 * @ param ast the current node 
 * @ param annotation the annotation name to check for 
 * @ return true if contains the annotation 
 - * @ throws NullPointerException if the ast or 
 - * annotation is null 
 * / 
 public static boolean containsAnnotation ( final DetailAST ast , 
 String annotation ) { 
 + if ( ast = = null ) { 
 + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; 
 + } 
 return AnnotationUtility . getAnnotation ( ast , annotation ) ! = null ; 
 } 
 
 @ @ - 72 , 9 + 80 , 11 @ @ public final class AnnotationUtility { 
 * 
 * @ param ast the current node 
 * @ return true if contains an annotation 
 - * @ throws NullPointerException if the ast is null 
 * / 
 public static boolean containsAnnotation ( final DetailAST ast ) { 
 + if ( ast = = null ) { 
 + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; 
 + } 
 final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; 
 return holder ! = null & & holder . branchContains ( TokenTypes . ANNOTATION ) ; 
 } 
 @ @ - 86 , 11 + 96 , 10 @ @ public final class AnnotationUtility { 
 * 
 * @ param ast the current node 
 * @ return the Annotation Holder 
 - * @ throws NullPointerException if the ast is null 
 * / 
 public static DetailAST getAnnotationHolder ( DetailAST ast ) { 
 if ( ast = = null ) { 
 - throw new IllegalArgumentException ( " the ast is null " ) ; 
 + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; 
 } 
 
 final DetailAST annotationHolder ; 
 @ @ - 127 , 13 + 136 , 11 @ @ public final class AnnotationUtility { 
 * @ param ast the current node 
 * @ param annotation the annotation name to check for 
 * @ return the AST representing that annotation 
 - * @ throws NullPointerException if the ast or 
 - * annotation is null 
 * / 
 public static DetailAST getAnnotation ( final DetailAST ast , 
 String annotation ) { 
 if ( ast = = null ) { 
 - throw new IllegalArgumentException ( " the ast is null " ) ; 
 + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; 
 } 
 
 if ( annotation = = null ) { 
 @ @ - 141 , 8 + 148 , 8 @ @ public final class AnnotationUtility { 
 } 
 
 if ( StringUtils . isBlank ( annotation ) ) { 
 - throw new IllegalArgumentException ( " the annotation " 
 - + " is empty or spaces " ) ; 
 + throw new IllegalArgumentException ( 
 + " the annotation is empty or spaces " ) ; 
 } 
 
 final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; 
 @ @ - 162 , 42 + 169 , 4 @ @ public final class AnnotationUtility { 
 return null ; 
 } 
 
 - / * * 
 - * Checks to see what the passed in AST ( representing 
 - * an annotation ) is annotating . 
 - * 
 - * @ param ast the AST representing an annotation . 
 - * @ return the AST the annotation is annotating . 
 - * @ throws NullPointerException if the ast is null 
 - * @ throws IllegalArgumentException if the ast is not 
 - * an { @ link TokenTypes # ANNOTATION } 
 - * / 
 - public static DetailAST annotatingWhat ( DetailAST ast ) { 
 - if ( ast = = null ) { 
 - throw new IllegalArgumentException ( " the ast is null " ) ; 
 - } 
 - 
 - if ( ast . getType ( ) ! = TokenTypes . ANNOTATION ) { 
 - throw new IllegalArgumentException ( 
 - " The ast is not an annotation . AST : " + ast ) ; 
 - } 
 - 
 - return ast . getParent ( ) . getParent ( ) ; 
 - } 
 - 
 - / * * 
 - * Checks to see if the passed in AST ( representing 
 - * an annotation ) is annotating the passed in type . 
 - * @ param ast the AST representing an annotation 
 - * @ param tokenType the passed in type 
 - * @ return true if the annotation is annotating a type 
 - * equal to the passed in type 
 - * @ throws NullPointerException if the ast is null 
 - * @ throws IllegalArgumentException if the ast is not 
 - * an { @ link TokenTypes # ANNOTATION } 
 - * / 
 - public static boolean isAnnotatingType ( DetailAST ast , int tokenType ) { 
 - final DetailAST astNode = AnnotationUtility . annotatingWhat ( ast ) ; 
 - return astNode . getType ( ) = = tokenType ; 
 - } 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java 
 new file mode 100644 
 index 0000000 . . 311dd7f 
 - - - / dev / null 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java 
 @ @ - 0 , 0 + 1 , 140 @ @ 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / checkstyle : Checks Java source code for adherence to a set of rules . 
 + / / Copyright ( C ) 2001 - 2015 the original author or authors . 
 + / / 
 + / / This library is free software ; you can redistribute it and / or 
 + / / modify it under the terms of the GNU Lesser General Public 
 + / / License as published by the Free Software Foundation ; either 
 + / / version 2 . 1 of the License , or ( at your option ) any later version . 
 + / / 
 + / / This library is distributed in the hope that it will be useful , 
 + / / but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + / / MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + / / Lesser General Public License for more details . 
 + / / 
 + / / You should have received a copy of the GNU Lesser General Public 
 + / / License along with this library ; if not , write to the Free Software 
 + / / Foundation , Inc . , 59 Temple Place , Suite 330 , Boston , MA 02111 - 1307 USA 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + 
 + package com . puppycrawl . tools . checkstyle ; 
 + 
 + import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; 
 + 
 + import java . lang . reflect . InvocationTargetException ; 
 + 
 + import org . junit . Assert ; 
 + import org . junit . Test ; 
 + 
 + import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 + import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 + 
 + public class AnnotationUtilityTest { 
 + 
 + @ Test 
 + public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { 
 + try { 
 + assertUtilsClassHasPrivateConstructor ( AnnotationUtility . class ) ; 
 + } 
 + catch ( InvocationTargetException ex ) { 
 + Assert . assertTrue ( " do not instantiate . " . equals ( ex . getCause ( ) . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationNull ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . containsAnnotation ( null ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationNull2 ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . containsAnnotation ( null , " " ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationFalse ( ) throws ReflectiveOperationException { 
 + DetailAST ast = new DetailAST ( ) ; 
 + ast . setType ( 1 ) ; 
 + Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationFalse2 ( ) throws ReflectiveOperationException { 
 + DetailAST ast = new DetailAST ( ) ; 
 + ast . setType ( 1 ) ; 
 + DetailAST ast2 = new DetailAST ( ) ; 
 + ast2 . setType ( TokenTypes . MODIFIERS ) ; 
 + ast . addChild ( ast2 ) ; 
 + Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationTrue ( ) throws ReflectiveOperationException { 
 + DetailAST ast = new DetailAST ( ) ; 
 + ast . setType ( 1 ) ; 
 + DetailAST ast2 = new DetailAST ( ) ; 
 + ast2 . setType ( TokenTypes . MODIFIERS ) ; 
 + ast . addChild ( ast2 ) ; 
 + DetailAST ast3 = new DetailAST ( ) ; 
 + ast3 . setType ( TokenTypes . ANNOTATION ) ; 
 + ast2 . addChild ( ast3 ) ; 
 + Assert . assertTrue ( AnnotationUtility . containsAnnotation ( ast ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testAnnotationHolderNull ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . getAnnotationHolder ( null ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testAnnotationNull ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . getAnnotation ( null , null ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testAnnotationNull2 ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . getAnnotation ( new DetailAST ( ) , null ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the annotation is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testAnnotationEmpty ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . getAnnotation ( new DetailAST ( ) , " " ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the annotation is empty or spaces " 
 + . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + }
