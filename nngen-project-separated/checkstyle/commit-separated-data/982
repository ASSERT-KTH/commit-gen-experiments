BLEU SCORE: 0.016932492841722675

TEST MSG: Issue # 3740 : verify all tokens are used in google config
GENERATED MSG: Incorporate changes made to the ANTLR Java grammar

TEST DIFF (one line): diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / internal / AllChecksTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / internal / AllChecksTest . java <nl> index 94a7c2d . . a11a4c5 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / internal / AllChecksTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / internal / AllChecksTest . java <nl> @ @ - 61 , 21 + 61 , 26 @ @ public class AllChecksTest extends BaseCheckTestSupport { <nl> Locale . ENGLISH , <nl> } ; <nl> <nl> - private static final Map < String , Set < String > > TOKENS _ IN _ CONFIG _ TO _ IGNORE = new HashMap < > ( ) ; <nl> + private static final Map < String , Set < String > > CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE = <nl> + new HashMap < > ( ) ; <nl> + private static final Map < String , Set < String > > GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE = <nl> + new HashMap < > ( ) ; <nl> <nl> static { <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoWhitespaceBefore " , Stream . of ( <nl> + / / checkstyle <nl> + <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoWhitespaceBefore " , Stream . of ( <nl> / / we use GenericWhitespace for this behavior <nl> " GENERIC _ START " , " GENERIC _ END " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AbbreviationAsWordInName " , Stream . of ( <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AbbreviationAsWordInName " , Stream . of ( <nl> / / enum values should be uppercase , we use EnumValueNameCheck instead <nl> " ENUM _ CONSTANT _ DEF " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " FinalLocalVariable " , Stream . of ( <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " FinalLocalVariable " , Stream . of ( <nl> / / we prefer all parameters be effectively final as to not damage readability <nl> / / we use ParameterAssignmentCheck to enforce this <nl> " PARAMETER _ DEF " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> / / we have no need to block these specific tokens <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalToken " , <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalToken " , <nl> Stream . of ( " LITERAL _ SUPER " , " LITERAL _ ASSERT " , " ENUM _ CONSTANT _ DEF " , <nl> " TYPE _ PARAMETERS " , " TYPE _ UPPER _ BOUNDS " , " NUM _ DOUBLE " , " LITERAL _ SWITCH " , <nl> " ANNOTATIONS " , " LITERAL _ SHORT " , " LITERAL _ PROTECTED " , " FOR _ CONDITION " , <nl> @ @ - 113 , 7 + 118 , 7 @ @ public class AllChecksTest extends BaseCheckTestSupport { <nl> " STRING _ LITERAL " , " ARRAY _ DECLARATOR " , " LITERAL _ CASE " ) . collect ( <nl> Collectors . toSet ( ) ) ) ; <nl> / / we have no need to block specific token text <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalTokenText " , <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalTokenText " , <nl> Stream . of ( " LITERAL _ SUPER " , " LITERAL _ ASSERT " , " ENUM _ CONSTANT _ DEF " , <nl> " TYPE _ PARAMETERS " , " TYPE _ UPPER _ BOUNDS " , " NUM _ DOUBLE " , " LITERAL _ SWITCH " , <nl> " ANNOTATIONS " , " LITERAL _ SHORT " , " LITERAL _ PROTECTED " , " FOR _ CONDITION " , <nl> @ @ - 152 , 15 + 157 , 15 @ @ public class AllChecksTest extends BaseCheckTestSupport { <nl> " MOD _ ASSIGN " , " LITERAL _ FOR " , " SUPER _ CTOR _ CALL " , " STRING _ LITERAL " , <nl> " ARRAY _ DECLARATOR " , " LITERAL _ CASE " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> / / we do not use this check as it is deprecated <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WriteTag " , <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WriteTag " , <nl> Stream . of ( " ENUM _ CONSTANT _ DEF " , " METHOD _ DEF " , " CTOR _ DEF " , " ANNOTATION _ FIELD _ DEF " ) <nl> . collect ( Collectors . toSet ( ) ) ) ; <nl> / / state of the configuration when test was made until reason found in <nl> / / https : / / github . com / checkstyle / checkstyle / issues / 3730 <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AnnotationLocation " , <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AnnotationLocation " , <nl> Stream . of ( " TYPECAST " , " DOT " , " TYPE _ ARGUMENT " , " LITERAL _ NEW " , " LITERAL _ THROWS " , <nl> " IMPLEMENTS _ CLAUSE " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoLineWrap " , Stream . of ( <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoLineWrap " , Stream . of ( <nl> / / method declaration could be long due to " parameters / exceptions " , it is ok to <nl> / / be not strict there <nl> " METHOD _ DEF " , " CTOR _ DEF " , <nl> @ @ - 168 , 25 + 173 , 109 @ @ public class AllChecksTest extends BaseCheckTestSupport { <nl> / / be not strict there <nl> " CLASS _ DEF " , " ENUM _ DEF " , " INTERFACE _ DEF " ) <nl> . collect ( Collectors . toSet ( ) ) ) ; <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoWhitespaceAfter " , Stream . of ( <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoWhitespaceAfter " , Stream . of ( <nl> / / whitespace after is preferred <nl> " TYPECAST " , " LITERAL _ SYNCHRONIZED " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " SeparatorWrap " , Stream . of ( <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " SeparatorWrap " , Stream . of ( <nl> / / needs context to decide what type of parentheses should be separated or not <nl> / / which this check does not provide <nl> " LPAREN " , " RPAREN " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NeedBraces " , Stream . of ( <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NeedBraces " , Stream . of ( <nl> / / we prefer no braces here as it looks unusual even though they help avoid sharing <nl> / / scope of variables <nl> " LITERAL _ DEFAULT " , " LITERAL _ CASE " , " LAMBDA " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " FinalParameters " , Stream . of ( <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " FinalParameters " , Stream . of ( <nl> / / we prefer these to be effectively final as to not damage readability <nl> " FOR _ EACH _ CLAUSE " , " LITERAL _ CATCH " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WhitespaceAround " , Stream . of ( <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WhitespaceAround " , Stream . of ( <nl> / / we prefer no spaces on one side or both for these tokens <nl> " ARRAY _ INIT " , <nl> / / these are covered by GenericWhitespaceCheck <nl> " WILDCARD _ TYPE " , " GENERIC _ END " , " GENERIC _ START " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> + <nl> + / / google <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AnnotationLocation " , Stream . of ( <nl> + / / state of the configuration when test was made until reason found in <nl> + / / https : / / github . com / checkstyle / checkstyle / issues / 3730 <nl> + " TYPECAST " , " DOT " , " TYPE _ ARGUMENT " , " ANNOTATION _ DEF " , " LITERAL _ NEW " , <nl> + " LITERAL _ THROWS " , " PARAMETER _ DEF " , " IMPLEMENTS _ CLAUSE " , " ANNOTATION _ FIELD _ DEF " ) <nl> + . collect ( Collectors . toSet ( ) ) ) ; <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AbbreviationAsWordInName " , Stream . of ( <nl> + / / enum values should be uppercase <nl> + " ENUM _ CONSTANT _ DEF " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoLineWrap " , Stream . of ( <nl> + / / method declaration could be long due to " parameters / exceptions " , it is ok to <nl> + / / be not strict there <nl> + " METHOD _ DEF " , " CTOR _ DEF " , " CLASS _ DEF " , " ENUM _ DEF " , " INTERFACE _ DEF " ) <nl> + . collect ( Collectors . toSet ( ) ) ) ; <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " SeparatorWrap " , Stream . of ( <nl> + / / state of configuration until <nl> + / / https : / / github . com / checkstyle / checkstyle / issues / 3752 <nl> + " RBRACK " , " AT " , " ELLIPSIS " , " SEMI " , " ARRAY _ DECLARATOR " , <nl> + / / needs context to decide what type of parentheses should be separated or not <nl> + / / which this check does not provide <nl> + " LPAREN " , " RPAREN " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NeedBraces " , Stream . of ( <nl> + / / state of configuration until <nl> + / / https : / / github . com / checkstyle / checkstyle / issues / 3753 <nl> + " LAMBDA " , <nl> + / / google doesn ' t require or prevent braces on these <nl> + " LITERAL _ DEFAULT " , " LITERAL _ CASE " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " EmptyBlock " , Stream . of ( <nl> + / / state of the configuration when test was made until <nl> + / / https : / / github . com / checkstyle / checkstyle / issues / 3748 <nl> + " LITERAL _ DEFAULT " , " LITERAL _ CASE " , <nl> + / / can be empty for special cases via ' 6 . 2 Caught exceptions : not ignored ' <nl> + " LITERAL _ CATCH " , <nl> + / / specifically allowed via ' 5 . 2 . 4 Constant names ' <nl> + " ARRAY _ INIT " ) <nl> + . collect ( Collectors . toSet ( ) ) ) ; <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WhitespaceAround " , Stream . of ( <nl> + / / allowed via ' 4 . 8 . 3 Arrays ' <nl> + " ARRAY _ INIT " , <nl> + / / google prefers no spaces on one side or both for these tokens <nl> + " GENERIC _ START " , " GENERIC _ END " , " WILDCARD _ TYPE " ) <nl> + . collect ( Collectors . toSet ( ) ) ) ; <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalTokenText " , Stream . of ( <nl> + / / all other java tokens and text are allowed <nl> + " LITERAL _ SUPER " , " LITERAL _ ASSERT " , " ENUM _ CONSTANT _ DEF " , " TYPE _ PARAMETERS " , <nl> + " TYPE _ UPPER _ BOUNDS " , " NUM _ DOUBLE " , " LITERAL _ SWITCH " , " ANNOTATIONS " , <nl> + " LITERAL _ SHORT " , " LITERAL _ PROTECTED " , " FOR _ CONDITION " , " FOR _ INIT " , " LITERAL _ LONG " , <nl> + " MINUS " , " OBJBLOCK " , " LITERAL _ NULL " , " ANNOTATION " , " LITERAL _ TRUE " , <nl> + " COMMENT _ CONTENT " , " LITERAL _ CHAR " , " PARAMETER _ DEF " , " POST _ DEC " , <nl> + " ANNOTATION _ FIELD _ DEF " , " BLOCK _ COMMENT _ END " , " TYPE " , " LITERAL _ INT " , " BSR " , " ENUM " , <nl> + " LABELED _ STAT " , " ANNOTATION _ MEMBER _ VALUE _ PAIR " , " TYPECAST " , " LITERAL _ SYNCHRONIZED " , <nl> + " PLUS _ ASSIGN " , " DOT " , " LPAREN " , " LITERAL _ IF " , " LITERAL _ CATCH " , " BAND " , <nl> + " INTERFACE _ DEF " , " LOR " , " BNOT " , " METHOD _ CALL " , " AT " , " ELLIPSIS " , " ARRAY _ INIT " , <nl> + " FOR _ EACH _ CLAUSE " , " LITERAL _ THROWS " , " CASE _ GROUP " , " POST _ INC " , " SEMI " , <nl> + " LITERAL _ FINALLY " , " ASSIGN " , " RESOURCE _ SPECIFICATION " , " STATIC _ IMPORT " , <nl> + " GENERIC _ START " , " IMPORT " , " SL " , " VARIABLE _ DEF " , " LITERAL _ DOUBLE " , " RCURLY " , <nl> + " RESOURCE " , " SR " , " COMMA " , " BAND _ ASSIGN " , " METHOD _ DEF " , " LITERAL _ VOID " , <nl> + " NUM _ LONG " , " LITERAL _ TRANSIENT " , " LITERAL _ THIS " , " LCURLY " , " MINUS _ ASSIGN " , <nl> + " TYPE _ LOWER _ BOUNDS " , " TYPE _ ARGUMENT " , " LITERAL _ CLASS " , " INSTANCE _ INIT " , " DIV " , <nl> + " LITERAL _ VOLATILE " , " STAR " , " UNARY _ MINUS " , " FOR _ ITERATOR " , " NOT _ EQUAL " , " LE " , <nl> + " LITERAL _ INTERFACE " , " LITERAL _ FLOAT " , " LITERAL _ INSTANCEOF " , " BOR _ ASSIGN " , " LT " , <nl> + " SL _ ASSIGN " , " ELIST " , " ANNOTATION _ ARRAY _ INIT " , " MODIFIERS " , " LITERAL _ BREAK " , <nl> + " EXTENDS _ CLAUSE " , " TYPE _ PARAMETER " , " LITERAL _ DEFAULT " , " STATIC _ INIT " , " BSR _ ASSIGN " , <nl> + " TYPE _ EXTENSION _ AND " , " BOR " , " LITERAL _ PRIVATE " , " LITERAL _ THROW " , " LITERAL _ BYTE " , <nl> + " BXOR " , " WILDCARD _ TYPE " , " FINAL " , " PARAMETERS " , " RPAREN " , " SR _ ASSIGN " , <nl> + " UNARY _ PLUS " , " EMPTY _ STAT " , " LITERAL _ STATIC " , " LITERAL _ CONTINUE " , " STAR _ ASSIGN " , <nl> + " LAMBDA " , " RBRACK " , " BXOR _ ASSIGN " , " CTOR _ CALL " , " LITERAL _ FALSE " , " DO _ WHILE " , <nl> + " LITERAL _ PUBLIC " , " LITERAL _ WHILE " , " PLUS " , " INC " , " CTOR _ DEF " , " GENERIC _ END " , <nl> + " DIV _ ASSIGN " , " SLIST " , " LNOT " , " LAND " , " LITERAL _ ELSE " , " ABSTRACT " , " STRICTFP " , <nl> + " QUESTION " , " LITERAL _ NEW " , " LITERAL _ RETURN " , " SINGLE _ LINE _ COMMENT " , " INDEX _ OP " , <nl> + " EXPR " , " BLOCK _ COMMENT _ BEGIN " , " PACKAGE _ DEF " , " IMPLEMENTS _ CLAUSE " , " NUM _ FLOAT " , <nl> + " LITERAL _ DO " , " EOF " , " GE " , " RESOURCES " , " MOD " , " DEC " , " EQUAL " , " LITERAL _ BOOLEAN " , <nl> + " CLASS _ DEF " , " COLON " , " LITERAL _ TRY " , " ENUM _ DEF " , " GT " , " NUM _ INT " , " ANNOTATION _ DEF " , <nl> + " LITERAL _ NATIVE " , " METHOD _ REF " , " TYPE _ ARGUMENTS " , " DOUBLE _ COLON " , " IDENT " , <nl> + " MOD _ ASSIGN " , " LITERAL _ FOR " , " SUPER _ CTOR _ CALL " , " ARRAY _ DECLARATOR " , " LITERAL _ CASE " ) <nl> + . collect ( Collectors . toSet ( ) ) ) ; <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " OperatorWrap " , Stream . of ( <nl> + / / state of the configuration when test was made until <nl> + / / https : / / github . com / checkstyle / checkstyle / issues / 3749 <nl> + " DIV _ ASSIGN " , " BOR _ ASSIGN " , " SL _ ASSIGN " , " ASSIGN " , " BSR _ ASSIGN " , " BAND _ ASSIGN " , <nl> + " PLUS _ ASSIGN " , " MINUS _ ASSIGN " , " SR _ ASSIGN " , " STAR _ ASSIGN " , " BXOR _ ASSIGN " , <nl> + " MOD _ ASSIGN " ) . collect ( Collectors . toSet ( ) ) ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 293 , 10 + 382 , 26 @ @ public class AllChecksTest extends BaseCheckTestSupport { <nl> } <nl> <nl> @ Test <nl> - public void testAllCheckTokensAreReferencedInConfigFile ( ) throws Exception { <nl> - final ModuleFactory moduleFactory = TestUtils . getPackageObjectFactory ( ) ; <nl> + public void testAllCheckTokensAreReferencedInCheckstyleConfigFile ( ) throws Exception { <nl> final Configuration configuration = ConfigurationUtil <nl> . loadConfiguration ( " config / checkstyle _ checks . xml " ) ; <nl> + <nl> + validateAllCheckTokensAreReferencedInConfigFile ( " checkstyle " , configuration , <nl> + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAllCheckTokensAreReferencedInGoogleConfigFile ( ) throws Exception { <nl> + final Configuration configuration = ConfigurationUtil <nl> + . loadConfiguration ( " src / main / resources / google _ checks . xml " ) ; <nl> + <nl> + validateAllCheckTokensAreReferencedInConfigFile ( " google " , configuration , <nl> + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE ) ; <nl> + } <nl> + <nl> + private static void validateAllCheckTokensAreReferencedInConfigFile ( String configName , <nl> + Configuration configuration , Map < String , Set < String > > tokensToIgnore ) throws Exception { <nl> + final ModuleFactory moduleFactory = TestUtils . getPackageObjectFactory ( ) ; <nl> final Set < Configuration > configChecks = ConfigurationUtil . getChecks ( configuration ) ; <nl> <nl> final Map < String , Set < String > > configCheckTokens = new HashMap < > ( ) ; <nl> @ @ - 324 , 7 + 429 , 7 @ @ public class AllChecksTest extends BaseCheckTestSupport { <nl> configCheckTokens . put ( checkName , configTokens ) ; <nl> <nl> / / add all overriden tokens <nl> - final Set < String > overrideTokens = TOKENS _ IN _ CONFIG _ TO _ IGNORE . get ( checkName ) ; <nl> + final Set < String > overrideTokens = tokensToIgnore . get ( checkName ) ; <nl> <nl> if ( overrideTokens ! = null ) { <nl> configTokens . addAll ( overrideTokens ) ; <nl> @ @ - 336 , 8 + 441 , 8 @ @ public class AllChecksTest extends BaseCheckTestSupport { <nl> } <nl> <nl> try { <nl> - configTokens . addAll ( Arrays . asList ( checkConfig . getAttribute ( " tokens " ) . split ( <nl> - " , \ \ s * " ) ) ) ; <nl> + configTokens . addAll ( Arrays . asList ( checkConfig . getAttribute ( " tokens " ) . trim ( ) <nl> + . split ( " , \ \ s * " ) ) ) ; <nl> } <nl> catch ( CheckstyleException ex ) { <nl> / / no tokens defined , so it is using default <nl> @ @ - 347 , 8 + 452 , 8 @ @ public class AllChecksTest extends BaseCheckTestSupport { <nl> <nl> for ( Entry < String , Set < String > > entry : checkTokens . entrySet ( ) ) { <nl> Assert . assertEquals ( " ' " + entry . getKey ( ) <nl> - + " ' should have all acceptable tokens from check in config or specify an " <nl> - + " override to ignore the specific tokens " , <nl> + + " ' should have all acceptable tokens from check in " + configName <nl> + + " config or specify an override to ignore the specific tokens " , <nl> entry . getValue ( ) , configCheckTokens . get ( entry . getKey ( ) ) ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / ChangeLog b / ChangeLog <nl> index d043b55 . . 186f278 100644 <nl> - - - a / ChangeLog <nl> + + + b / ChangeLog <nl> @ @ - 1 , 5 + 1 , 10 @ @ <nl> 2001 - 11 - 26 Oliver Burn < oliver @ cortexebusiness . com . au > <nl> <nl> + 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> + 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g : <nl> + 	 Incorporate changes made to the ANTLR Java grammar that checkstyle is <nl> + 	 based off . <nl> + <nl> 	 * src / tests / com / puppycrawl / tools / checkstyle / CheckerTest . java <nl> 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . g : Included patch <nl> 	 to check whitespace after synchronized and catch keywords . From Lars <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> index 4fbca2e . . 80849b6 100644 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> @ @ - 56 , 6 + 56 , 7 @ @ tokens { <nl> 	 POST _ INC ; POST _ DEC ; METHOD _ CALL ; EXPR ; ARRAY _ INIT ; <nl> 	 IMPORT ; UNARY _ MINUS ; UNARY _ PLUS ; CASE _ GROUP ; ELIST ; FOR _ INIT ; FOR _ CONDITION ; <nl> 	 FOR _ ITERATOR ; EMPTY _ STAT ; FINAL = " final " ; ABSTRACT = " abstract " ; <nl> + 	 STRICTFP = " strictfp " ; SUPER _ CTOR _ CALL ; CTOR _ CALL ; <nl> } <nl> 	 <nl> { <nl> @ @ - 112 , 16 + 113 , 6 @ @ declaration ! <nl> 	 	 { # declaration = # v ; } <nl> 	 ; <nl> <nl> - / / A list of zero or more modifiers . We could have used ( modifier ) * in <nl> - / / place of a call to modifiers , but I thought it was a good idea to keep <nl> - / / this rule separate so they can easily be collected in a Vector if <nl> - / / someone so desires <nl> - modifiers <nl> - 	 : 	 ( modifier ) * <nl> - 	 	 { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } <nl> - 	 ; <nl> - <nl> - <nl> / / A type specification is a type name with possible brackets afterwards <nl> / / ( which would make it an array type ) . <nl> typeSpec [ boolean addImagNode ] <nl> @ @ - 192 , 6 + 183 , 14 @ @ identifierStar <nl> } <nl> 	 ; <nl> <nl> + / / A list of zero or more modifiers . We could have used ( modifier ) * in <nl> + / / place of a call to modifiers , but I thought it was a good idea to keep <nl> + / / this rule separate so they can easily be collected in a Vector if <nl> + / / someone so desires <nl> + modifiers <nl> + 	 : 	 ( modifier ) * <nl> + 	 	 { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } <nl> + 	 ; <nl> <nl> / / modifiers for Java classes , interfaces , class / instance vars and methods <nl> modifier <nl> @ @ - 205 , 11 + 204 , 11 @ @ modifier <nl> 	 | 	 " native " <nl> 	 | 	 " threadsafe " <nl> 	 | 	 " synchronized " <nl> - / / 	 | 	 " const " 	 	 	 / / reserved word ; leave out <nl> + / / 	 | 	 " const " 	 	 	 / / reserved word , but not valid <nl> 	 | 	 " volatile " <nl> + 	 | 	 " strictfp " <nl> 	 ; <nl> <nl> - <nl> / / Definition of a Java class <nl> classDefinition ! [ AST modifiers ] <nl> 	 : 	 " class " IDENT <nl> @ @ - 275 , 7 + 274 , 7 @ @ implementsClause <nl> field ! <nl> 	 : 	 / / method , constructor , or variable declaration <nl> 	 	 mods : modifiers <nl> - 	 	 ( 	 h : ctorHead s : compoundStatement / / constructor <nl> + 	 	 ( 	 h : ctorHead s : constructorBody / / constructor <nl> 	 	 	 { # field = # ( # [ CTOR _ DEF , " CTOR _ DEF " ] , mods , h , s ) ; } <nl> <nl> 	 	 | 	 cd : classDefinition [ # mods ] / / inner class <nl> @ @ - 290 , 9 + 289 , 10 @ @ field ! <nl> 	 	 	 	 / / parse the formal parameter declarations . <nl> 	 	 	 	 LPAREN ! param : parameterDeclarationList RPAREN ! <nl> <nl> - 	 	 	 	 rt : returnTypeBrackersOnEndOfMethodHead [ # t ] <nl> + 	 	 	 	 rt : declaratorBrackets [ # t ] <nl> <nl> - 	 	 	 	 / / get the list of exceptions that this method is declared to throw <nl> + 	 	 	 	 / / get the list of exceptions that this method is <nl> + 	 	 	 	 / / declared to throw <nl> 	 	 	 	 ( tc : throwsClause ) ? <nl> <nl> 	 	 	 	 ( s2 : compoundStatement | SEMI ) <nl> @ @ - 318 , 6 + 318 , 38 @ @ field ! <nl> 	 	 { # field = # ( # [ INSTANCE _ INIT , " INSTANCE _ INIT " ] , s4 ) ; } <nl> 	 ; <nl> <nl> + constructorBody <nl> + : lc : LCURLY ^ { # lc . setType ( SLIST ) ; } <nl> + 	 	 / / Predicate might be slow but only checked once per constructor def <nl> + 	 	 / / not for general methods . <nl> + 	 	 ( 	 ( explicitConstructorInvocation ) = > explicitConstructorInvocation <nl> + 	 	 | <nl> + 	 	 ) <nl> + ( statement ) * <nl> + RCURLY ! <nl> + ; <nl> + <nl> + explicitConstructorInvocation <nl> + : ( 	 options { <nl> + 	 	 	 	 / / this / super can begin a primaryExpression too ; with finite <nl> + 	 	 	 	 / / lookahead ANTLR will think the 3rd alternative conflicts <nl> + 	 	 	 	 / / with 1 , 2 . I am shutting off warning since ANTLR resolves <nl> + 	 	 	 	 / / the nondeterminism by correctly matching alts 1 or 2 when <nl> + 	 	 	 	 / / it sees this ( or super ( <nl> + 	 	 	 	 generateAmbigWarnings = false ; <nl> + 	 	 	 } <nl> + 	 	 : 	 " this " ! lp1 : LPAREN ^ argList RPAREN ! SEMI ! <nl> + 	 	 	 { # lp1 . setType ( CTOR _ CALL ) ; } <nl> + <nl> + 	 | " super " ! lp2 : LPAREN ^ argList RPAREN ! SEMI ! <nl> + 	 	 	 { # lp2 . setType ( SUPER _ CTOR _ CALL ) ; } <nl> + <nl> + 	 	 	 / / ( new Outer ( ) ) . super ( ) ( create enclosing instance ) <nl> + 	 	 | 	 primaryExpression DOT ! " super " ! lp3 : LPAREN ^ argList RPAREN ! SEMI ! <nl> + 	 	 	 { # lp3 . setType ( SUPER _ CTOR _ CALL ) ; } <nl> + 	 	 ) <nl> + ; <nl> + <nl> variableDefinitions [ AST mods , AST t ] <nl> 	 : 	 variableDeclarator [ getASTFactory ( ) . dupTree ( mods ) , <nl> 	 	 	 	 	 	 getASTFactory ( ) . dupTree ( t ) ] <nl> @ @ - 392 , 11 + 424 , 6 @ @ throwsClause <nl> 	 ; <nl> <nl> <nl> - returnTypeBrackersOnEndOfMethodHead [ AST typ ] <nl> - 	 : 	 { # returnTypeBrackersOnEndOfMethodHead = typ ; } <nl> - 	 	 ( lb : LBRACK ^ { # lb . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * <nl> - 	 ; <nl> - <nl> / / A list of formal parameters <nl> parameterDeclarationList <nl> 	 : 	 ( parameterDeclaration ( COMMA ! parameterDeclaration ) * ) ? <nl> @ @ - 407 , 16 + 434 , 11 @ @ parameterDeclarationList <nl> / / A formal parameter . <nl> parameterDeclaration ! <nl> 	 : 	 pm : parameterModifier t : typeSpec [ false ] id : IDENT <nl> - 	 	 pd : parameterDeclaratorBrackets [ # t ] <nl> + 	 	 pd : declaratorBrackets [ # t ] <nl> 	 	 { # parameterDeclaration = # ( # [ PARAMETER _ DEF , " PARAMETER _ DEF " ] , <nl> 	 	 	 	 	 	 	 	 	 pm , # ( [ TYPE , " TYPE " ] , pd ) , id ) ; } <nl> 	 ; <nl> <nl> - parameterDeclaratorBrackets [ AST t ] <nl> - 	 : 	 { # parameterDeclaratorBrackets = t ; } <nl> - 	 	 ( lb : LBRACK ^ { # lb . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * <nl> - 	 ; <nl> - <nl> parameterModifier <nl> 	 : 	 ( f : " final " ) ? <nl> 	 	 { # parameterModifier = # ( # [ MODIFIERS , " MODIFIERS " ] , f ) ; } <nl> @ @ - 443 , 15 + 465 , 6 @ @ statement <nl> 	 / / A list of statements in curly braces - - start a new scope ! <nl> 	 : 	 compoundStatement <nl> <nl> - 	 / / class definition <nl> - 	 | 	 classDefinition [ # [ MODIFIERS , " MODIFIERS " ] ] <nl> - <nl> - 	 / / final class definition <nl> - 	 | 	 " final " ! classDefinition [ # ( # [ MODIFIERS , " MODIFIERS " ] , # [ FINAL , " final " ] ) ] <nl> - <nl> - 	 / / abstract class definition <nl> - 	 | 	 " abstract " ! classDefinition [ # ( # [ MODIFIERS , " MODIFIERS " ] , # [ ABSTRACT , " abstract " ] ) ] <nl> - <nl> 	 / / declarations are ambiguous with " ID DOT " relative to expression <nl> 	 / / statements . Must backtrack to be sure . Could use a semantic <nl> 	 / / predicate to test symbol table to see what the type was coming <nl> @ @ - 463 , 6 + 476 , 9 @ @ statement <nl> 	 / / side - effects . <nl> 	 | 	 expression SEMI ! <nl> <nl> + 	 / / class definition <nl> + 	 | 	 m : modifiers ! classDefinition [ # m ] <nl> + <nl> 	 / / Attach a label to the front of a statement <nl> 	 | 	 IDENT c : COLON ^ { # c . setType ( LABELED _ STAT ) ; } statement <nl> <nl> @ @ - 651 , 9 + 667 , 9 @ @ assignmentExpression <nl> <nl> / / conditional test ( level 12 ) <nl> conditionalExpression <nl> - : logicalOrExpression <nl> - ( QUESTION ^ assignmentExpression COLON conditionalExpression ) ? <nl> - ; <nl> + 	 : 	 logicalOrExpression <nl> + 	 	 ( QUESTION ^ assignmentExpression COLON ! conditionalExpression ) ? <nl> + 	 ; <nl> <nl> <nl> / / logical or ( | | ) ( level 11 ) <nl> @ @ - 767 , 10 + 783 , 10 @ @ postfixExpression <nl> 	 	 	 	 | " this " <nl> 	 	 	 	 | " class " <nl> 	 	 	 	 | newExpression <nl> - 	 	 	 	 | " super " LPAREN ( expressionList ) ? RPAREN <nl> + 	 	 	 	 | " super " / / ClassName . super . field <nl> 	 	 	 	 ) <nl> 	 	 	 / / the above line needs a semantic check to make sure " class " <nl> - 	 	 	 / / is the _ last _ qualifier . <nl> + 	 	 	 / / is the _ last _ qualifier . <nl> <nl> 	 	 	 / / allow ClassName [ ] . class <nl> 	 	 | 	 ( lbc : LBRACK ^ { # lbc . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) + <nl> @ @ - 784 , 6 + 800 , 9 @ @ postfixExpression <nl> 	 	 	 / / x [ 2 ] ( 4 ) which are not valid in Java . If this grammar were used <nl> 	 	 	 / / to validate a Java program a semantic check would be needed , or <nl> 	 	 	 / / this rule would get really ugly . . . <nl> + 	 	 	 / / It also allows ctor invocation like super ( 3 ) which is now <nl> + 	 	 	 / / handled by the explicit constructor rule , but it would <nl> + 	 	 	 / / be hard to syntactically prevent ctor calls here <nl> 	 	 | 	 lp : LPAREN ^ { # lp . setType ( METHOD _ CALL ) ; } <nl> 	 	 	 	 argList <nl> 	 	 	 RPAREN ! <nl> @ @ - 795 , 24 + 814 , 23 @ @ postfixExpression <nl> 	 	 | 	 de : DEC ^ { # de . setType ( POST _ DEC ) ; } <nl> 	 	 | 	 / / nothing <nl> 	 	 ) <nl> - <nl> - 	 	 / / look for int . class and int [ ] . class <nl> - 	 | 	 builtInType <nl> - 	 	 ( lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * <nl> - 	 	 DOT ^ " class " <nl> 	 ; <nl> <nl> / / the basic element of an expression <nl> primaryExpression <nl> 	 : 	 i1 : IDENT { sFirstIdent = i1 . getText ( ) ; } <nl> - 	 | 	 newExpression <nl> 	 | 	 constant <nl> - 	 | 	 " super " <nl> 	 | 	 " true " <nl> 	 | 	 " false " <nl> 	 | 	 " this " <nl> 	 | 	 " null " <nl> + 	 | 	 newExpression <nl> 	 | 	 LPAREN ! assignmentExpression RPAREN ! <nl> + 	 | 	 " super " <nl> + 	 	 / / look for int . class and int [ ] . class <nl> + 	 | 	 builtInType <nl> + 	 	 ( lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * <nl> + 	 	 DOT ^ " class " <nl> 	 ; <nl> <nl> / * * object instantiation . <nl> @ @ - 909 , 6 + 927 , 8 @ @ constant <nl> 	 | 	 CHAR _ LITERAL <nl> 	 | 	 STRING _ LITERAL <nl> 	 | 	 NUM _ FLOAT <nl> + 	 | 	 NUM _ LONG <nl> + 	 | 	 NUM _ DOUBLE <nl> 	 ; <nl> <nl> <nl> @ @ - 921 , 7 + 941 , 11 @ @ options { <nl> 	 exportVocab = GeneratedJava ; / / call the vocabulary " GeneratedJava " <nl> 	 testLiterals = false ; / / don ' t automatically test for literals <nl> 	 k = 4 ; / / four characters of lookahead <nl> - / / 	 charVocabulary = ' \ u0003 ' . . ' \ uFFFF ' ; <nl> + 	 charVocabulary = ' \ u0003 ' . . ' \ uFFFF ' ; <nl> + 	 / / without inlining some bitset tests , couldn ' t do unicode ; <nl> + 	 / / I need to make ANTLR generate smaller bitsets ; see <nl> + 	 / / bottom of JavaLexer . java <nl> + 	 codeGenBitsetTestThreshold = 20 ; <nl> } <nl> <nl> <nl> @ @ - 979 , 13 + 1003 , 14 @ @ SEMI 	 	 	 : 	 ' ; ' 	 	 ; <nl> WS 	 : 	 ( 	 ' ' <nl> 	 	 | 	 ' \ t ' <nl> 	 	 | 	 ' \ f ' <nl> - 	 	 / / handle newlines <nl> - 	 	 | 	 ( 	 " \ r \ n " / / Evil DOS <nl> + 	 	 	 / / handle newlines <nl> + 	 	 | 	 ( 	 options { generateAmbigWarnings = false ; } <nl> + 	 	 	 : 	 " \ r \ n " / / Evil DOS <nl> 	 	 	 | 	 ' \ r ' / / Macintosh <nl> 	 	 	 | 	 ' \ n ' / / Unix ( the right way ) <nl> 	 	 	 ) <nl> 	 	 	 { newline ( ) ; } <nl> - 	 	 ) <nl> + 	 	 ) + <nl> 	 	 { _ ttype = Token . SKIP ; } <nl> 	 ; <nl> <nl> @ @ - 1117 , 9 + 1142 , 19 @ @ IDENT <nl> <nl> / / a numeric literal <nl> NUM _ INT <nl> - 	 { boolean isDecimal = false ; } <nl> - 	 : 	 ' . ' { _ ttype = DOT ; } <nl> - 	 	 	 ( ( ' 0 ' . . ' 9 ' ) + ( EXPONENT ) ? ( FLOAT _ SUFFIX ) ? { _ ttype = NUM _ FLOAT ; } ) ? <nl> + 	 { boolean isDecimal = false ; Token t = null ; } <nl> + : ' . ' { _ ttype = DOT ; } <nl> + ( 	 ( ' 0 ' . . ' 9 ' ) + ( EXPONENT ) ? ( f1 : FLOAT _ SUFFIX { t = f1 ; } ) ? <nl> + { <nl> + 	 	 	 	 if ( t ! = null & & t . getText ( ) . toUpperCase ( ) . indexOf ( ' D ' ) > = 0 ) { <nl> + 	 _ ttype = NUM _ DOUBLE ; <nl> + 	 	 	 	 } <nl> + 	 	 	 	 else { <nl> + 	 _ ttype = NUM _ FLOAT ; <nl> + 	 	 	 	 } <nl> + 	 	 	 	 } <nl> + ) ? <nl> + <nl> 	 | 	 ( 	 ' 0 ' { isDecimal = true ; } / / special case for just ' 0 ' <nl> 	 	 	 ( 	 ( ' x ' | ' X ' ) <nl> 	 	 	 	 ( 	 	 	 	 	 	 	 	 	 	 	 / / hex <nl> @ @ - 1137 , 16 + 1172 , 23 @ @ NUM _ INT <nl> 	 	 	 ) ? <nl> 	 	 | 	 ( ' 1 ' . . ' 9 ' ) ( ' 0 ' . . ' 9 ' ) * { isDecimal = true ; } 	 	 / / non - zero decimal <nl> 	 	 ) <nl> - 	 	 ( 	 ( ' l ' | ' L ' ) <nl> + 	 	 ( 	 ( ' l ' | ' L ' ) { _ ttype = NUM _ LONG ; } <nl> 	 	 <nl> 	 	 / / only check to see if it ' s a float if looks like decimal so far <nl> 	 	 | 	 { isDecimal } ? <nl> - 	 	 	 ( 	 ' . ' ( ' 0 ' . . ' 9 ' ) * ( EXPONENT ) ? ( FLOAT _ SUFFIX ) ? <nl> - 	 	 	 | 	 EXPONENT ( FLOAT _ SUFFIX ) ? <nl> - 	 	 	 | 	 FLOAT _ SUFFIX <nl> - 	 	 	 ) <nl> - 	 	 	 { _ ttype = NUM _ FLOAT ; } <nl> - 	 	 ) ? <nl> + ( ' . ' ( ' 0 ' . . ' 9 ' ) * ( EXPONENT ) ? ( f2 : FLOAT _ SUFFIX { t = f2 ; } ) ? <nl> + | EXPONENT ( f3 : FLOAT _ SUFFIX { t = f3 ; } ) ? <nl> + | f4 : FLOAT _ SUFFIX { t = f4 ; } <nl> + ) <nl> + { <nl> + 	 	 	 if ( t ! = null & & t . getText ( ) . toUpperCase ( ) . indexOf ( ' D ' ) > = 0 ) { <nl> + _ ttype = NUM _ DOUBLE ; <nl> + 	 	 	 } <nl> + else { <nl> + _ ttype = NUM _ FLOAT ; <nl> + 	 	 	 } <nl> + 	 	 	 } <nl> + ) ? <nl> 	 ; <nl> <nl> <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g <nl> index 4e98a15 . . 89e6e38 100644 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g <nl> @ @ - 117 , 6 + 117 , 7 @ @ modifier <nl> | " synchronized " <nl> | " const " <nl> | " volatile " <nl> + 	 | 	 " strictfp " <nl> ; <nl> <nl> extendsClause <nl> @ @ - 163 , 7 + 164 , 7 @ @ ctorDef <nl> MyModifierSet mods ; <nl> MethodSignature ms ; <nl> } <nl> - : # ( CTOR _ DEF mods = modifiers ms = methodHead { ver . reportStartMethodBlock ( ) ; } slist { ver . reportEndMethodBlock ( ) ; } ) <nl> + : # ( CTOR _ DEF mods = modifiers ms = methodHead { ver . reportStartMethodBlock ( ) ; } ctorSList { ver . reportEndMethodBlock ( ) ; } ) <nl> { <nl> ver . verifyMethodJavadoc ( mods , null , ms ) ; <nl> } <nl> @ @ - 293 , 6 + 294 , 10 @ @ identifierStar <nl> | # ( DOT ignore = identifier ( STAR | IDENT ) ) <nl> ; <nl> <nl> + ctorSList <nl> + 	 : 	 # ( SLIST ( ctorCall ) ? ( stat ) * ) <nl> + 	 ; <nl> + <nl> slist <nl> 	 : 	 # ( SLIST ( stat ) * ) <nl> 	 ; <nl> @ @ - 434 , 8 + 439 , 9 @ @ primaryExpression <nl> | " this " <nl> | " class " { if ( firstExprIdent ! = null ) { ver . reportReference ( firstExprIdent . getText ( ) ) ; } } <nl> | # ( " new " IDENT elist ) <nl> + 	 	 	 	 | " super " <nl> ) <nl> - | # ( ARRAY _ DECLARATOR type ) <nl> + | # ( ARRAY _ DECLARATOR typeSpecArray ) <nl> | builtInType ( " class " ) ? <nl> ) <nl> ) <nl> @ @ - 452 , 6 + 458 , 15 @ @ primaryExpression <nl> | typeSpec / / type name used with instanceof <nl> ; <nl> <nl> + ctorCall <nl> + 	 : 	 # ( CTOR _ CALL elist ) <nl> + 	 | 	 # ( SUPER _ CTOR _ CALL <nl> + 	 	 	 ( 	 elist <nl> + 	 	 	 | 	 primaryExpression elist <nl> + 	 	 	 ) <nl> + 	 	 ) <nl> + 	 ; <nl> + <nl> arrayIndex <nl> 	 : 	 # ( INDEX _ OP primaryExpression expression ) <nl> 	 ; <nl> @ @ - 461 , 6 + 476 , 8 @ @ constant <nl> | CHAR _ LITERAL <nl> | STRING _ LITERAL <nl> | NUM _ FLOAT <nl> + | NUM _ DOUBLE <nl> + | NUM _ LONG <nl> ; <nl> <nl> newExpression

TEST DIFF:
diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / internal / AllChecksTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / internal / AllChecksTest . java 
 index 94a7c2d . . a11a4c5 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / internal / AllChecksTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / internal / AllChecksTest . java 
 @ @ - 61 , 21 + 61 , 26 @ @ public class AllChecksTest extends BaseCheckTestSupport { 
 Locale . ENGLISH , 
 } ; 
 
 - private static final Map < String , Set < String > > TOKENS _ IN _ CONFIG _ TO _ IGNORE = new HashMap < > ( ) ; 
 + private static final Map < String , Set < String > > CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE = 
 + new HashMap < > ( ) ; 
 + private static final Map < String , Set < String > > GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE = 
 + new HashMap < > ( ) ; 
 
 static { 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoWhitespaceBefore " , Stream . of ( 
 + / / checkstyle 
 + 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoWhitespaceBefore " , Stream . of ( 
 / / we use GenericWhitespace for this behavior 
 " GENERIC _ START " , " GENERIC _ END " ) . collect ( Collectors . toSet ( ) ) ) ; 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AbbreviationAsWordInName " , Stream . of ( 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AbbreviationAsWordInName " , Stream . of ( 
 / / enum values should be uppercase , we use EnumValueNameCheck instead 
 " ENUM _ CONSTANT _ DEF " ) . collect ( Collectors . toSet ( ) ) ) ; 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " FinalLocalVariable " , Stream . of ( 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " FinalLocalVariable " , Stream . of ( 
 / / we prefer all parameters be effectively final as to not damage readability 
 / / we use ParameterAssignmentCheck to enforce this 
 " PARAMETER _ DEF " ) . collect ( Collectors . toSet ( ) ) ) ; 
 / / we have no need to block these specific tokens 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalToken " , 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalToken " , 
 Stream . of ( " LITERAL _ SUPER " , " LITERAL _ ASSERT " , " ENUM _ CONSTANT _ DEF " , 
 " TYPE _ PARAMETERS " , " TYPE _ UPPER _ BOUNDS " , " NUM _ DOUBLE " , " LITERAL _ SWITCH " , 
 " ANNOTATIONS " , " LITERAL _ SHORT " , " LITERAL _ PROTECTED " , " FOR _ CONDITION " , 
 @ @ - 113 , 7 + 118 , 7 @ @ public class AllChecksTest extends BaseCheckTestSupport { 
 " STRING _ LITERAL " , " ARRAY _ DECLARATOR " , " LITERAL _ CASE " ) . collect ( 
 Collectors . toSet ( ) ) ) ; 
 / / we have no need to block specific token text 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalTokenText " , 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalTokenText " , 
 Stream . of ( " LITERAL _ SUPER " , " LITERAL _ ASSERT " , " ENUM _ CONSTANT _ DEF " , 
 " TYPE _ PARAMETERS " , " TYPE _ UPPER _ BOUNDS " , " NUM _ DOUBLE " , " LITERAL _ SWITCH " , 
 " ANNOTATIONS " , " LITERAL _ SHORT " , " LITERAL _ PROTECTED " , " FOR _ CONDITION " , 
 @ @ - 152 , 15 + 157 , 15 @ @ public class AllChecksTest extends BaseCheckTestSupport { 
 " MOD _ ASSIGN " , " LITERAL _ FOR " , " SUPER _ CTOR _ CALL " , " STRING _ LITERAL " , 
 " ARRAY _ DECLARATOR " , " LITERAL _ CASE " ) . collect ( Collectors . toSet ( ) ) ) ; 
 / / we do not use this check as it is deprecated 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WriteTag " , 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WriteTag " , 
 Stream . of ( " ENUM _ CONSTANT _ DEF " , " METHOD _ DEF " , " CTOR _ DEF " , " ANNOTATION _ FIELD _ DEF " ) 
 . collect ( Collectors . toSet ( ) ) ) ; 
 / / state of the configuration when test was made until reason found in 
 / / https : / / github . com / checkstyle / checkstyle / issues / 3730 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AnnotationLocation " , 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AnnotationLocation " , 
 Stream . of ( " TYPECAST " , " DOT " , " TYPE _ ARGUMENT " , " LITERAL _ NEW " , " LITERAL _ THROWS " , 
 " IMPLEMENTS _ CLAUSE " ) . collect ( Collectors . toSet ( ) ) ) ; 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoLineWrap " , Stream . of ( 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoLineWrap " , Stream . of ( 
 / / method declaration could be long due to " parameters / exceptions " , it is ok to 
 / / be not strict there 
 " METHOD _ DEF " , " CTOR _ DEF " , 
 @ @ - 168 , 25 + 173 , 109 @ @ public class AllChecksTest extends BaseCheckTestSupport { 
 / / be not strict there 
 " CLASS _ DEF " , " ENUM _ DEF " , " INTERFACE _ DEF " ) 
 . collect ( Collectors . toSet ( ) ) ) ; 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoWhitespaceAfter " , Stream . of ( 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoWhitespaceAfter " , Stream . of ( 
 / / whitespace after is preferred 
 " TYPECAST " , " LITERAL _ SYNCHRONIZED " ) . collect ( Collectors . toSet ( ) ) ) ; 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " SeparatorWrap " , Stream . of ( 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " SeparatorWrap " , Stream . of ( 
 / / needs context to decide what type of parentheses should be separated or not 
 / / which this check does not provide 
 " LPAREN " , " RPAREN " ) . collect ( Collectors . toSet ( ) ) ) ; 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NeedBraces " , Stream . of ( 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NeedBraces " , Stream . of ( 
 / / we prefer no braces here as it looks unusual even though they help avoid sharing 
 / / scope of variables 
 " LITERAL _ DEFAULT " , " LITERAL _ CASE " , " LAMBDA " ) . collect ( Collectors . toSet ( ) ) ) ; 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " FinalParameters " , Stream . of ( 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " FinalParameters " , Stream . of ( 
 / / we prefer these to be effectively final as to not damage readability 
 " FOR _ EACH _ CLAUSE " , " LITERAL _ CATCH " ) . collect ( Collectors . toSet ( ) ) ) ; 
 - TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WhitespaceAround " , Stream . of ( 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WhitespaceAround " , Stream . of ( 
 / / we prefer no spaces on one side or both for these tokens 
 " ARRAY _ INIT " , 
 / / these are covered by GenericWhitespaceCheck 
 " WILDCARD _ TYPE " , " GENERIC _ END " , " GENERIC _ START " ) . collect ( Collectors . toSet ( ) ) ) ; 
 + 
 + / / google 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AnnotationLocation " , Stream . of ( 
 + / / state of the configuration when test was made until reason found in 
 + / / https : / / github . com / checkstyle / checkstyle / issues / 3730 
 + " TYPECAST " , " DOT " , " TYPE _ ARGUMENT " , " ANNOTATION _ DEF " , " LITERAL _ NEW " , 
 + " LITERAL _ THROWS " , " PARAMETER _ DEF " , " IMPLEMENTS _ CLAUSE " , " ANNOTATION _ FIELD _ DEF " ) 
 + . collect ( Collectors . toSet ( ) ) ) ; 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " AbbreviationAsWordInName " , Stream . of ( 
 + / / enum values should be uppercase 
 + " ENUM _ CONSTANT _ DEF " ) . collect ( Collectors . toSet ( ) ) ) ; 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NoLineWrap " , Stream . of ( 
 + / / method declaration could be long due to " parameters / exceptions " , it is ok to 
 + / / be not strict there 
 + " METHOD _ DEF " , " CTOR _ DEF " , " CLASS _ DEF " , " ENUM _ DEF " , " INTERFACE _ DEF " ) 
 + . collect ( Collectors . toSet ( ) ) ) ; 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " SeparatorWrap " , Stream . of ( 
 + / / state of configuration until 
 + / / https : / / github . com / checkstyle / checkstyle / issues / 3752 
 + " RBRACK " , " AT " , " ELLIPSIS " , " SEMI " , " ARRAY _ DECLARATOR " , 
 + / / needs context to decide what type of parentheses should be separated or not 
 + / / which this check does not provide 
 + " LPAREN " , " RPAREN " ) . collect ( Collectors . toSet ( ) ) ) ; 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " NeedBraces " , Stream . of ( 
 + / / state of configuration until 
 + / / https : / / github . com / checkstyle / checkstyle / issues / 3753 
 + " LAMBDA " , 
 + / / google doesn ' t require or prevent braces on these 
 + " LITERAL _ DEFAULT " , " LITERAL _ CASE " ) . collect ( Collectors . toSet ( ) ) ) ; 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " EmptyBlock " , Stream . of ( 
 + / / state of the configuration when test was made until 
 + / / https : / / github . com / checkstyle / checkstyle / issues / 3748 
 + " LITERAL _ DEFAULT " , " LITERAL _ CASE " , 
 + / / can be empty for special cases via ' 6 . 2 Caught exceptions : not ignored ' 
 + " LITERAL _ CATCH " , 
 + / / specifically allowed via ' 5 . 2 . 4 Constant names ' 
 + " ARRAY _ INIT " ) 
 + . collect ( Collectors . toSet ( ) ) ) ; 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " WhitespaceAround " , Stream . of ( 
 + / / allowed via ' 4 . 8 . 3 Arrays ' 
 + " ARRAY _ INIT " , 
 + / / google prefers no spaces on one side or both for these tokens 
 + " GENERIC _ START " , " GENERIC _ END " , " WILDCARD _ TYPE " ) 
 + . collect ( Collectors . toSet ( ) ) ) ; 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " IllegalTokenText " , Stream . of ( 
 + / / all other java tokens and text are allowed 
 + " LITERAL _ SUPER " , " LITERAL _ ASSERT " , " ENUM _ CONSTANT _ DEF " , " TYPE _ PARAMETERS " , 
 + " TYPE _ UPPER _ BOUNDS " , " NUM _ DOUBLE " , " LITERAL _ SWITCH " , " ANNOTATIONS " , 
 + " LITERAL _ SHORT " , " LITERAL _ PROTECTED " , " FOR _ CONDITION " , " FOR _ INIT " , " LITERAL _ LONG " , 
 + " MINUS " , " OBJBLOCK " , " LITERAL _ NULL " , " ANNOTATION " , " LITERAL _ TRUE " , 
 + " COMMENT _ CONTENT " , " LITERAL _ CHAR " , " PARAMETER _ DEF " , " POST _ DEC " , 
 + " ANNOTATION _ FIELD _ DEF " , " BLOCK _ COMMENT _ END " , " TYPE " , " LITERAL _ INT " , " BSR " , " ENUM " , 
 + " LABELED _ STAT " , " ANNOTATION _ MEMBER _ VALUE _ PAIR " , " TYPECAST " , " LITERAL _ SYNCHRONIZED " , 
 + " PLUS _ ASSIGN " , " DOT " , " LPAREN " , " LITERAL _ IF " , " LITERAL _ CATCH " , " BAND " , 
 + " INTERFACE _ DEF " , " LOR " , " BNOT " , " METHOD _ CALL " , " AT " , " ELLIPSIS " , " ARRAY _ INIT " , 
 + " FOR _ EACH _ CLAUSE " , " LITERAL _ THROWS " , " CASE _ GROUP " , " POST _ INC " , " SEMI " , 
 + " LITERAL _ FINALLY " , " ASSIGN " , " RESOURCE _ SPECIFICATION " , " STATIC _ IMPORT " , 
 + " GENERIC _ START " , " IMPORT " , " SL " , " VARIABLE _ DEF " , " LITERAL _ DOUBLE " , " RCURLY " , 
 + " RESOURCE " , " SR " , " COMMA " , " BAND _ ASSIGN " , " METHOD _ DEF " , " LITERAL _ VOID " , 
 + " NUM _ LONG " , " LITERAL _ TRANSIENT " , " LITERAL _ THIS " , " LCURLY " , " MINUS _ ASSIGN " , 
 + " TYPE _ LOWER _ BOUNDS " , " TYPE _ ARGUMENT " , " LITERAL _ CLASS " , " INSTANCE _ INIT " , " DIV " , 
 + " LITERAL _ VOLATILE " , " STAR " , " UNARY _ MINUS " , " FOR _ ITERATOR " , " NOT _ EQUAL " , " LE " , 
 + " LITERAL _ INTERFACE " , " LITERAL _ FLOAT " , " LITERAL _ INSTANCEOF " , " BOR _ ASSIGN " , " LT " , 
 + " SL _ ASSIGN " , " ELIST " , " ANNOTATION _ ARRAY _ INIT " , " MODIFIERS " , " LITERAL _ BREAK " , 
 + " EXTENDS _ CLAUSE " , " TYPE _ PARAMETER " , " LITERAL _ DEFAULT " , " STATIC _ INIT " , " BSR _ ASSIGN " , 
 + " TYPE _ EXTENSION _ AND " , " BOR " , " LITERAL _ PRIVATE " , " LITERAL _ THROW " , " LITERAL _ BYTE " , 
 + " BXOR " , " WILDCARD _ TYPE " , " FINAL " , " PARAMETERS " , " RPAREN " , " SR _ ASSIGN " , 
 + " UNARY _ PLUS " , " EMPTY _ STAT " , " LITERAL _ STATIC " , " LITERAL _ CONTINUE " , " STAR _ ASSIGN " , 
 + " LAMBDA " , " RBRACK " , " BXOR _ ASSIGN " , " CTOR _ CALL " , " LITERAL _ FALSE " , " DO _ WHILE " , 
 + " LITERAL _ PUBLIC " , " LITERAL _ WHILE " , " PLUS " , " INC " , " CTOR _ DEF " , " GENERIC _ END " , 
 + " DIV _ ASSIGN " , " SLIST " , " LNOT " , " LAND " , " LITERAL _ ELSE " , " ABSTRACT " , " STRICTFP " , 
 + " QUESTION " , " LITERAL _ NEW " , " LITERAL _ RETURN " , " SINGLE _ LINE _ COMMENT " , " INDEX _ OP " , 
 + " EXPR " , " BLOCK _ COMMENT _ BEGIN " , " PACKAGE _ DEF " , " IMPLEMENTS _ CLAUSE " , " NUM _ FLOAT " , 
 + " LITERAL _ DO " , " EOF " , " GE " , " RESOURCES " , " MOD " , " DEC " , " EQUAL " , " LITERAL _ BOOLEAN " , 
 + " CLASS _ DEF " , " COLON " , " LITERAL _ TRY " , " ENUM _ DEF " , " GT " , " NUM _ INT " , " ANNOTATION _ DEF " , 
 + " LITERAL _ NATIVE " , " METHOD _ REF " , " TYPE _ ARGUMENTS " , " DOUBLE _ COLON " , " IDENT " , 
 + " MOD _ ASSIGN " , " LITERAL _ FOR " , " SUPER _ CTOR _ CALL " , " ARRAY _ DECLARATOR " , " LITERAL _ CASE " ) 
 + . collect ( Collectors . toSet ( ) ) ) ; 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE . put ( " OperatorWrap " , Stream . of ( 
 + / / state of the configuration when test was made until 
 + / / https : / / github . com / checkstyle / checkstyle / issues / 3749 
 + " DIV _ ASSIGN " , " BOR _ ASSIGN " , " SL _ ASSIGN " , " ASSIGN " , " BSR _ ASSIGN " , " BAND _ ASSIGN " , 
 + " PLUS _ ASSIGN " , " MINUS _ ASSIGN " , " SR _ ASSIGN " , " STAR _ ASSIGN " , " BXOR _ ASSIGN " , 
 + " MOD _ ASSIGN " ) . collect ( Collectors . toSet ( ) ) ) ; 
 } 
 
 @ Test 
 @ @ - 293 , 10 + 382 , 26 @ @ public class AllChecksTest extends BaseCheckTestSupport { 
 } 
 
 @ Test 
 - public void testAllCheckTokensAreReferencedInConfigFile ( ) throws Exception { 
 - final ModuleFactory moduleFactory = TestUtils . getPackageObjectFactory ( ) ; 
 + public void testAllCheckTokensAreReferencedInCheckstyleConfigFile ( ) throws Exception { 
 final Configuration configuration = ConfigurationUtil 
 . loadConfiguration ( " config / checkstyle _ checks . xml " ) ; 
 + 
 + validateAllCheckTokensAreReferencedInConfigFile ( " checkstyle " , configuration , 
 + CHECKSTYLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE ) ; 
 + } 
 + 
 + @ Test 
 + public void testAllCheckTokensAreReferencedInGoogleConfigFile ( ) throws Exception { 
 + final Configuration configuration = ConfigurationUtil 
 + . loadConfiguration ( " src / main / resources / google _ checks . xml " ) ; 
 + 
 + validateAllCheckTokensAreReferencedInConfigFile ( " google " , configuration , 
 + GOOGLE _ TOKENS _ IN _ CONFIG _ TO _ IGNORE ) ; 
 + } 
 + 
 + private static void validateAllCheckTokensAreReferencedInConfigFile ( String configName , 
 + Configuration configuration , Map < String , Set < String > > tokensToIgnore ) throws Exception { 
 + final ModuleFactory moduleFactory = TestUtils . getPackageObjectFactory ( ) ; 
 final Set < Configuration > configChecks = ConfigurationUtil . getChecks ( configuration ) ; 
 
 final Map < String , Set < String > > configCheckTokens = new HashMap < > ( ) ; 
 @ @ - 324 , 7 + 429 , 7 @ @ public class AllChecksTest extends BaseCheckTestSupport { 
 configCheckTokens . put ( checkName , configTokens ) ; 
 
 / / add all overriden tokens 
 - final Set < String > overrideTokens = TOKENS _ IN _ CONFIG _ TO _ IGNORE . get ( checkName ) ; 
 + final Set < String > overrideTokens = tokensToIgnore . get ( checkName ) ; 
 
 if ( overrideTokens ! = null ) { 
 configTokens . addAll ( overrideTokens ) ; 
 @ @ - 336 , 8 + 441 , 8 @ @ public class AllChecksTest extends BaseCheckTestSupport { 
 } 
 
 try { 
 - configTokens . addAll ( Arrays . asList ( checkConfig . getAttribute ( " tokens " ) . split ( 
 - " , \ \ s * " ) ) ) ; 
 + configTokens . addAll ( Arrays . asList ( checkConfig . getAttribute ( " tokens " ) . trim ( ) 
 + . split ( " , \ \ s * " ) ) ) ; 
 } 
 catch ( CheckstyleException ex ) { 
 / / no tokens defined , so it is using default 
 @ @ - 347 , 8 + 452 , 8 @ @ public class AllChecksTest extends BaseCheckTestSupport { 
 
 for ( Entry < String , Set < String > > entry : checkTokens . entrySet ( ) ) { 
 Assert . assertEquals ( " ' " + entry . getKey ( ) 
 - + " ' should have all acceptable tokens from check in config or specify an " 
 - + " override to ignore the specific tokens " , 
 + + " ' should have all acceptable tokens from check in " + configName 
 + + " config or specify an override to ignore the specific tokens " , 
 entry . getValue ( ) , configCheckTokens . get ( entry . getKey ( ) ) ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / ChangeLog b / ChangeLog 
 index d043b55 . . 186f278 100644 
 - - - a / ChangeLog 
 + + + b / ChangeLog 
 @ @ - 1 , 5 + 1 , 10 @ @ 
 2001 - 11 - 26 Oliver Burn < oliver @ cortexebusiness . com . au > 
 
 + 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 + 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g : 
 + 	 Incorporate changes made to the ANTLR Java grammar that checkstyle is 
 + 	 based off . 
 + 
 	 * src / tests / com / puppycrawl / tools / checkstyle / CheckerTest . java 
 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . g : Included patch 
 	 to check whitespace after synchronized and catch keywords . From Lars 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 index 4fbca2e . . 80849b6 100644 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 @ @ - 56 , 6 + 56 , 7 @ @ tokens { 
 	 POST _ INC ; POST _ DEC ; METHOD _ CALL ; EXPR ; ARRAY _ INIT ; 
 	 IMPORT ; UNARY _ MINUS ; UNARY _ PLUS ; CASE _ GROUP ; ELIST ; FOR _ INIT ; FOR _ CONDITION ; 
 	 FOR _ ITERATOR ; EMPTY _ STAT ; FINAL = " final " ; ABSTRACT = " abstract " ; 
 + 	 STRICTFP = " strictfp " ; SUPER _ CTOR _ CALL ; CTOR _ CALL ; 
 } 
 	 
 { 
 @ @ - 112 , 16 + 113 , 6 @ @ declaration ! 
 	 	 { # declaration = # v ; } 
 	 ; 
 
 - / / A list of zero or more modifiers . We could have used ( modifier ) * in 
 - / / place of a call to modifiers , but I thought it was a good idea to keep 
 - / / this rule separate so they can easily be collected in a Vector if 
 - / / someone so desires 
 - modifiers 
 - 	 : 	 ( modifier ) * 
 - 	 	 { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } 
 - 	 ; 
 - 
 - 
 / / A type specification is a type name with possible brackets afterwards 
 / / ( which would make it an array type ) . 
 typeSpec [ boolean addImagNode ] 
 @ @ - 192 , 6 + 183 , 14 @ @ identifierStar 
 } 
 	 ; 
 
 + / / A list of zero or more modifiers . We could have used ( modifier ) * in 
 + / / place of a call to modifiers , but I thought it was a good idea to keep 
 + / / this rule separate so they can easily be collected in a Vector if 
 + / / someone so desires 
 + modifiers 
 + 	 : 	 ( modifier ) * 
 + 	 	 { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } 
 + 	 ; 
 
 / / modifiers for Java classes , interfaces , class / instance vars and methods 
 modifier 
 @ @ - 205 , 11 + 204 , 11 @ @ modifier 
 	 | 	 " native " 
 	 | 	 " threadsafe " 
 	 | 	 " synchronized " 
 - / / 	 | 	 " const " 	 	 	 / / reserved word ; leave out 
 + / / 	 | 	 " const " 	 	 	 / / reserved word , but not valid 
 	 | 	 " volatile " 
 + 	 | 	 " strictfp " 
 	 ; 
 
 - 
 / / Definition of a Java class 
 classDefinition ! [ AST modifiers ] 
 	 : 	 " class " IDENT 
 @ @ - 275 , 7 + 274 , 7 @ @ implementsClause 
 field ! 
 	 : 	 / / method , constructor , or variable declaration 
 	 	 mods : modifiers 
 - 	 	 ( 	 h : ctorHead s : compoundStatement / / constructor 
 + 	 	 ( 	 h : ctorHead s : constructorBody / / constructor 
 	 	 	 { # field = # ( # [ CTOR _ DEF , " CTOR _ DEF " ] , mods , h , s ) ; } 
 
 	 	 | 	 cd : classDefinition [ # mods ] / / inner class 
 @ @ - 290 , 9 + 289 , 10 @ @ field ! 
 	 	 	 	 / / parse the formal parameter declarations . 
 	 	 	 	 LPAREN ! param : parameterDeclarationList RPAREN ! 
 
 - 	 	 	 	 rt : returnTypeBrackersOnEndOfMethodHead [ # t ] 
 + 	 	 	 	 rt : declaratorBrackets [ # t ] 
 
 - 	 	 	 	 / / get the list of exceptions that this method is declared to throw 
 + 	 	 	 	 / / get the list of exceptions that this method is 
 + 	 	 	 	 / / declared to throw 
 	 	 	 	 ( tc : throwsClause ) ? 
 
 	 	 	 	 ( s2 : compoundStatement | SEMI ) 
 @ @ - 318 , 6 + 318 , 38 @ @ field ! 
 	 	 { # field = # ( # [ INSTANCE _ INIT , " INSTANCE _ INIT " ] , s4 ) ; } 
 	 ; 
 
 + constructorBody 
 + : lc : LCURLY ^ { # lc . setType ( SLIST ) ; } 
 + 	 	 / / Predicate might be slow but only checked once per constructor def 
 + 	 	 / / not for general methods . 
 + 	 	 ( 	 ( explicitConstructorInvocation ) = > explicitConstructorInvocation 
 + 	 	 | 
 + 	 	 ) 
 + ( statement ) * 
 + RCURLY ! 
 + ; 
 + 
 + explicitConstructorInvocation 
 + : ( 	 options { 
 + 	 	 	 	 / / this / super can begin a primaryExpression too ; with finite 
 + 	 	 	 	 / / lookahead ANTLR will think the 3rd alternative conflicts 
 + 	 	 	 	 / / with 1 , 2 . I am shutting off warning since ANTLR resolves 
 + 	 	 	 	 / / the nondeterminism by correctly matching alts 1 or 2 when 
 + 	 	 	 	 / / it sees this ( or super ( 
 + 	 	 	 	 generateAmbigWarnings = false ; 
 + 	 	 	 } 
 + 	 	 : 	 " this " ! lp1 : LPAREN ^ argList RPAREN ! SEMI ! 
 + 	 	 	 { # lp1 . setType ( CTOR _ CALL ) ; } 
 + 
 + 	 | " super " ! lp2 : LPAREN ^ argList RPAREN ! SEMI ! 
 + 	 	 	 { # lp2 . setType ( SUPER _ CTOR _ CALL ) ; } 
 + 
 + 	 	 	 / / ( new Outer ( ) ) . super ( ) ( create enclosing instance ) 
 + 	 	 | 	 primaryExpression DOT ! " super " ! lp3 : LPAREN ^ argList RPAREN ! SEMI ! 
 + 	 	 	 { # lp3 . setType ( SUPER _ CTOR _ CALL ) ; } 
 + 	 	 ) 
 + ; 
 + 
 variableDefinitions [ AST mods , AST t ] 
 	 : 	 variableDeclarator [ getASTFactory ( ) . dupTree ( mods ) , 
 	 	 	 	 	 	 getASTFactory ( ) . dupTree ( t ) ] 
 @ @ - 392 , 11 + 424 , 6 @ @ throwsClause 
 	 ; 
 
 
 - returnTypeBrackersOnEndOfMethodHead [ AST typ ] 
 - 	 : 	 { # returnTypeBrackersOnEndOfMethodHead = typ ; } 
 - 	 	 ( lb : LBRACK ^ { # lb . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * 
 - 	 ; 
 - 
 / / A list of formal parameters 
 parameterDeclarationList 
 	 : 	 ( parameterDeclaration ( COMMA ! parameterDeclaration ) * ) ? 
 @ @ - 407 , 16 + 434 , 11 @ @ parameterDeclarationList 
 / / A formal parameter . 
 parameterDeclaration ! 
 	 : 	 pm : parameterModifier t : typeSpec [ false ] id : IDENT 
 - 	 	 pd : parameterDeclaratorBrackets [ # t ] 
 + 	 	 pd : declaratorBrackets [ # t ] 
 	 	 { # parameterDeclaration = # ( # [ PARAMETER _ DEF , " PARAMETER _ DEF " ] , 
 	 	 	 	 	 	 	 	 	 pm , # ( [ TYPE , " TYPE " ] , pd ) , id ) ; } 
 	 ; 
 
 - parameterDeclaratorBrackets [ AST t ] 
 - 	 : 	 { # parameterDeclaratorBrackets = t ; } 
 - 	 	 ( lb : LBRACK ^ { # lb . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * 
 - 	 ; 
 - 
 parameterModifier 
 	 : 	 ( f : " final " ) ? 
 	 	 { # parameterModifier = # ( # [ MODIFIERS , " MODIFIERS " ] , f ) ; } 
 @ @ - 443 , 15 + 465 , 6 @ @ statement 
 	 / / A list of statements in curly braces - - start a new scope ! 
 	 : 	 compoundStatement 
 
 - 	 / / class definition 
 - 	 | 	 classDefinition [ # [ MODIFIERS , " MODIFIERS " ] ] 
 - 
 - 	 / / final class definition 
 - 	 | 	 " final " ! classDefinition [ # ( # [ MODIFIERS , " MODIFIERS " ] , # [ FINAL , " final " ] ) ] 
 - 
 - 	 / / abstract class definition 
 - 	 | 	 " abstract " ! classDefinition [ # ( # [ MODIFIERS , " MODIFIERS " ] , # [ ABSTRACT , " abstract " ] ) ] 
 - 
 	 / / declarations are ambiguous with " ID DOT " relative to expression 
 	 / / statements . Must backtrack to be sure . Could use a semantic 
 	 / / predicate to test symbol table to see what the type was coming 
 @ @ - 463 , 6 + 476 , 9 @ @ statement 
 	 / / side - effects . 
 	 | 	 expression SEMI ! 
 
 + 	 / / class definition 
 + 	 | 	 m : modifiers ! classDefinition [ # m ] 
 + 
 	 / / Attach a label to the front of a statement 
 	 | 	 IDENT c : COLON ^ { # c . setType ( LABELED _ STAT ) ; } statement 
 
 @ @ - 651 , 9 + 667 , 9 @ @ assignmentExpression 
 
 / / conditional test ( level 12 ) 
 conditionalExpression 
 - : logicalOrExpression 
 - ( QUESTION ^ assignmentExpression COLON conditionalExpression ) ? 
 - ; 
 + 	 : 	 logicalOrExpression 
 + 	 	 ( QUESTION ^ assignmentExpression COLON ! conditionalExpression ) ? 
 + 	 ; 
 
 
 / / logical or ( | | ) ( level 11 ) 
 @ @ - 767 , 10 + 783 , 10 @ @ postfixExpression 
 	 	 	 	 | " this " 
 	 	 	 	 | " class " 
 	 	 	 	 | newExpression 
 - 	 	 	 	 | " super " LPAREN ( expressionList ) ? RPAREN 
 + 	 	 	 	 | " super " / / ClassName . super . field 
 	 	 	 	 ) 
 	 	 	 / / the above line needs a semantic check to make sure " class " 
 - 	 	 	 / / is the _ last _ qualifier . 
 + 	 	 	 / / is the _ last _ qualifier . 
 
 	 	 	 / / allow ClassName [ ] . class 
 	 	 | 	 ( lbc : LBRACK ^ { # lbc . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) + 
 @ @ - 784 , 6 + 800 , 9 @ @ postfixExpression 
 	 	 	 / / x [ 2 ] ( 4 ) which are not valid in Java . If this grammar were used 
 	 	 	 / / to validate a Java program a semantic check would be needed , or 
 	 	 	 / / this rule would get really ugly . . . 
 + 	 	 	 / / It also allows ctor invocation like super ( 3 ) which is now 
 + 	 	 	 / / handled by the explicit constructor rule , but it would 
 + 	 	 	 / / be hard to syntactically prevent ctor calls here 
 	 	 | 	 lp : LPAREN ^ { # lp . setType ( METHOD _ CALL ) ; } 
 	 	 	 	 argList 
 	 	 	 RPAREN ! 
 @ @ - 795 , 24 + 814 , 23 @ @ postfixExpression 
 	 	 | 	 de : DEC ^ { # de . setType ( POST _ DEC ) ; } 
 	 	 | 	 / / nothing 
 	 	 ) 
 - 
 - 	 	 / / look for int . class and int [ ] . class 
 - 	 | 	 builtInType 
 - 	 	 ( lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * 
 - 	 	 DOT ^ " class " 
 	 ; 
 
 / / the basic element of an expression 
 primaryExpression 
 	 : 	 i1 : IDENT { sFirstIdent = i1 . getText ( ) ; } 
 - 	 | 	 newExpression 
 	 | 	 constant 
 - 	 | 	 " super " 
 	 | 	 " true " 
 	 | 	 " false " 
 	 | 	 " this " 
 	 | 	 " null " 
 + 	 | 	 newExpression 
 	 | 	 LPAREN ! assignmentExpression RPAREN ! 
 + 	 | 	 " super " 
 + 	 	 / / look for int . class and int [ ] . class 
 + 	 | 	 builtInType 
 + 	 	 ( lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * 
 + 	 	 DOT ^ " class " 
 	 ; 
 
 / * * object instantiation . 
 @ @ - 909 , 6 + 927 , 8 @ @ constant 
 	 | 	 CHAR _ LITERAL 
 	 | 	 STRING _ LITERAL 
 	 | 	 NUM _ FLOAT 
 + 	 | 	 NUM _ LONG 
 + 	 | 	 NUM _ DOUBLE 
 	 ; 
 
 
 @ @ - 921 , 7 + 941 , 11 @ @ options { 
 	 exportVocab = GeneratedJava ; / / call the vocabulary " GeneratedJava " 
 	 testLiterals = false ; / / don ' t automatically test for literals 
 	 k = 4 ; / / four characters of lookahead 
 - / / 	 charVocabulary = ' \ u0003 ' . . ' \ uFFFF ' ; 
 + 	 charVocabulary = ' \ u0003 ' . . ' \ uFFFF ' ; 
 + 	 / / without inlining some bitset tests , couldn ' t do unicode ; 
 + 	 / / I need to make ANTLR generate smaller bitsets ; see 
 + 	 / / bottom of JavaLexer . java 
 + 	 codeGenBitsetTestThreshold = 20 ; 
 } 
 
 
 @ @ - 979 , 13 + 1003 , 14 @ @ SEMI 	 	 	 : 	 ' ; ' 	 	 ; 
 WS 	 : 	 ( 	 ' ' 
 	 	 | 	 ' \ t ' 
 	 	 | 	 ' \ f ' 
 - 	 	 / / handle newlines 
 - 	 	 | 	 ( 	 " \ r \ n " / / Evil DOS 
 + 	 	 	 / / handle newlines 
 + 	 	 | 	 ( 	 options { generateAmbigWarnings = false ; } 
 + 	 	 	 : 	 " \ r \ n " / / Evil DOS 
 	 	 	 | 	 ' \ r ' / / Macintosh 
 	 	 	 | 	 ' \ n ' / / Unix ( the right way ) 
 	 	 	 ) 
 	 	 	 { newline ( ) ; } 
 - 	 	 ) 
 + 	 	 ) + 
 	 	 { _ ttype = Token . SKIP ; } 
 	 ; 
 
 @ @ - 1117 , 9 + 1142 , 19 @ @ IDENT 
 
 / / a numeric literal 
 NUM _ INT 
 - 	 { boolean isDecimal = false ; } 
 - 	 : 	 ' . ' { _ ttype = DOT ; } 
 - 	 	 	 ( ( ' 0 ' . . ' 9 ' ) + ( EXPONENT ) ? ( FLOAT _ SUFFIX ) ? { _ ttype = NUM _ FLOAT ; } ) ? 
 + 	 { boolean isDecimal = false ; Token t = null ; } 
 + : ' . ' { _ ttype = DOT ; } 
 + ( 	 ( ' 0 ' . . ' 9 ' ) + ( EXPONENT ) ? ( f1 : FLOAT _ SUFFIX { t = f1 ; } ) ? 
 + { 
 + 	 	 	 	 if ( t ! = null & & t . getText ( ) . toUpperCase ( ) . indexOf ( ' D ' ) > = 0 ) { 
 + 	 _ ttype = NUM _ DOUBLE ; 
 + 	 	 	 	 } 
 + 	 	 	 	 else { 
 + 	 _ ttype = NUM _ FLOAT ; 
 + 	 	 	 	 } 
 + 	 	 	 	 } 
 + ) ? 
 + 
 	 | 	 ( 	 ' 0 ' { isDecimal = true ; } / / special case for just ' 0 ' 
 	 	 	 ( 	 ( ' x ' | ' X ' ) 
 	 	 	 	 ( 	 	 	 	 	 	 	 	 	 	 	 / / hex 
 @ @ - 1137 , 16 + 1172 , 23 @ @ NUM _ INT 
 	 	 	 ) ? 
 	 	 | 	 ( ' 1 ' . . ' 9 ' ) ( ' 0 ' . . ' 9 ' ) * { isDecimal = true ; } 	 	 / / non - zero decimal 
 	 	 ) 
 - 	 	 ( 	 ( ' l ' | ' L ' ) 
 + 	 	 ( 	 ( ' l ' | ' L ' ) { _ ttype = NUM _ LONG ; } 
 	 	 
 	 	 / / only check to see if it ' s a float if looks like decimal so far 
 	 	 | 	 { isDecimal } ? 
 - 	 	 	 ( 	 ' . ' ( ' 0 ' . . ' 9 ' ) * ( EXPONENT ) ? ( FLOAT _ SUFFIX ) ? 
 - 	 	 	 | 	 EXPONENT ( FLOAT _ SUFFIX ) ? 
 - 	 	 	 | 	 FLOAT _ SUFFIX 
 - 	 	 	 ) 
 - 	 	 	 { _ ttype = NUM _ FLOAT ; } 
 - 	 	 ) ? 
 + ( ' . ' ( ' 0 ' . . ' 9 ' ) * ( EXPONENT ) ? ( f2 : FLOAT _ SUFFIX { t = f2 ; } ) ? 
 + | EXPONENT ( f3 : FLOAT _ SUFFIX { t = f3 ; } ) ? 
 + | f4 : FLOAT _ SUFFIX { t = f4 ; } 
 + ) 
 + { 
 + 	 	 	 if ( t ! = null & & t . getText ( ) . toUpperCase ( ) . indexOf ( ' D ' ) > = 0 ) { 
 + _ ttype = NUM _ DOUBLE ; 
 + 	 	 	 } 
 + else { 
 + _ ttype = NUM _ FLOAT ; 
 + 	 	 	 } 
 + 	 	 	 } 
 + ) ? 
 	 ; 
 
 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g 
 index 4e98a15 . . 89e6e38 100644 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g 
 @ @ - 117 , 6 + 117 , 7 @ @ modifier 
 | " synchronized " 
 | " const " 
 | " volatile " 
 + 	 | 	 " strictfp " 
 ; 
 
 extendsClause 
 @ @ - 163 , 7 + 164 , 7 @ @ ctorDef 
 MyModifierSet mods ; 
 MethodSignature ms ; 
 } 
 - : # ( CTOR _ DEF mods = modifiers ms = methodHead { ver . reportStartMethodBlock ( ) ; } slist { ver . reportEndMethodBlock ( ) ; } ) 
 + : # ( CTOR _ DEF mods = modifiers ms = methodHead { ver . reportStartMethodBlock ( ) ; } ctorSList { ver . reportEndMethodBlock ( ) ; } ) 
 { 
 ver . verifyMethodJavadoc ( mods , null , ms ) ; 
 } 
 @ @ - 293 , 6 + 294 , 10 @ @ identifierStar 
 | # ( DOT ignore = identifier ( STAR | IDENT ) ) 
 ; 
 
 + ctorSList 
 + 	 : 	 # ( SLIST ( ctorCall ) ? ( stat ) * ) 
 + 	 ; 
 + 
 slist 
 	 : 	 # ( SLIST ( stat ) * ) 
 	 ; 
 @ @ - 434 , 8 + 439 , 9 @ @ primaryExpression 
 | " this " 
 | " class " { if ( firstExprIdent ! = null ) { ver . reportReference ( firstExprIdent . getText ( ) ) ; } } 
 | # ( " new " IDENT elist ) 
 + 	 	 	 	 | " super " 
 ) 
 - | # ( ARRAY _ DECLARATOR type ) 
 + | # ( ARRAY _ DECLARATOR typeSpecArray ) 
 | builtInType ( " class " ) ? 
 ) 
 ) 
 @ @ - 452 , 6 + 458 , 15 @ @ primaryExpression 
 | typeSpec / / type name used with instanceof 
 ; 
 
 + ctorCall 
 + 	 : 	 # ( CTOR _ CALL elist ) 
 + 	 | 	 # ( SUPER _ CTOR _ CALL 
 + 	 	 	 ( 	 elist 
 + 	 	 	 | 	 primaryExpression elist 
 + 	 	 	 ) 
 + 	 	 ) 
 + 	 ; 
 + 
 arrayIndex 
 	 : 	 # ( INDEX _ OP primaryExpression expression ) 
 	 ; 
 @ @ - 461 , 6 + 476 , 8 @ @ constant 
 | CHAR _ LITERAL 
 | STRING _ LITERAL 
 | NUM _ FLOAT 
 + | NUM _ DOUBLE 
 + | NUM _ LONG 
 ; 
 
 newExpression
