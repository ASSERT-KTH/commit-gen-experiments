BLEU SCORE: 0.0367352656298894

TEST MSG: Issue # 1349 : Fix IndentationCheck to accept proper right parenthesis of annotation
GENERATED MSG: Add test coverage to BlockParentHandler in Indentation check . # 1270

TEST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / LineWrappingHandler . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / LineWrappingHandler . java <nl> index ac7281e . . 8a68a6b 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / LineWrappingHandler . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / LineWrappingHandler . java <nl> @ @ - 33 , 7 + 33 , 7 @ @ import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> * lineWrappingIndentation parameter . <nl> * <nl> * @ author maxvetrenko <nl> - * <nl> + * @ author < a href = " mailto : piotr . listkiewicz @ gmail . com " > liscju < / a > <nl> * / <nl> public class LineWrappingHandler { <nl> <nl> @ @ - 222 , 10 + 222 , 13 @ @ public class LineWrappingHandler { <nl> while ( firstNodesOnLines . size ( ) > 1 ) { <nl> final DetailAST node = itr . next ( ) ; <nl> <nl> - if ( node . getLineNo ( ) < lastAnnotationLine <nl> - | | node . getLineNo ( ) = = lastAnnotationLine ) { <nl> + if ( node . getLineNo ( ) < = lastAnnotationLine ) { <nl> final DetailAST parentNode = node . getParent ( ) ; <nl> - if ( node . getType ( ) = = TokenTypes . AT <nl> + final boolean isCurrentNodeCloseAnnotationAloneInLine = <nl> + node . getLineNo ( ) = = lastAnnotationLine <nl> + & & node . equals ( lastAnnotationNode ) ; <nl> + if ( isCurrentNodeCloseAnnotationAloneInLine <nl> + | | node . getType ( ) = = TokenTypes . AT <nl> & & parentNode . getParent ( ) . getType ( ) = = TokenTypes . MODIFIERS ) { <nl> logWarningMessage ( node , firstNodeIndent ) ; <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java <nl> index 54a4f70 . . 1f2b24e 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java <nl> @ @ - 332 , 6 + 332 , 24 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { <nl> } <nl> <nl> @ Test <nl> + public void testAnnotationClosingParenthesisEndsInSameIndentationAsOpening ( ) throws Exception { <nl> + final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; <nl> + <nl> + checkConfig . addAttribute ( " basicOffset " , " 4 " ) ; <nl> + checkConfig . addAttribute ( " forceStrictCondition " , " true " ) ; <nl> + checkConfig . addAttribute ( " tabWidth " , " 4 " ) ; <nl> + <nl> + final String [ ] expected = { <nl> + " 19 : " + getCheckMessage ( MSG _ ERROR , " ) " , 16 , 0 ) , <nl> + " 22 : " + getCheckMessage ( MSG _ ERROR , " ) " , 8 , 4 ) , <nl> + } ; <nl> + <nl> + verifyWarns ( checkConfig , <nl> + getPath ( " InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening . java " ) , <nl> + expected ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testAnonClassesFromGuava ( ) throws Exception { <nl> final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; <nl> <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / indentation / InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / indentation / InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening . java <nl> new file mode 100644 <nl> index 0000000 . . 16a2412 <nl> - - - / dev / null <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / indentation / InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening . java <nl> @ @ - 0 , 0 + 1 , 24 @ @ <nl> + package com . puppycrawl . tools . checkstyle . checks . indentation ; / / indent : 0 exp : 0 <nl> + <nl> + @ interface SimpleType { / / indent : 0 exp : 0 <nl> + Class < ? > value ( ) ; / / indent : 4 exp : 4 <nl> + } / / indent : 0 exp : 0 <nl> + <nl> + @ SimpleType ( / / indent : 0 exp : 0 <nl> + value = Boolean . class / / indent : 4 exp : 4 <nl> + ) / / indent : 0 exp : 0 <nl> + public class InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening { / / indent : 0 exp : 0 <nl> + } / / indent : 0 exp : 0 <nl> + <nl> + @ SimpleType ( value = Boolean . class / / indent : 0 exp : 0 <nl> + ) / / indent : 0 exp : 0 <nl> + class InputAnnotationClosingParenthesisJustLineAfterOpeningSameIndentationAsOpening { / / indent : 0 exp : 0 <nl> + } / / indent : 0 exp : 0 <nl> + <nl> + @ SimpleType ( value = Boolean . class / / indent : 0 exp : 0 <nl> + ) / / indent : 16 exp : 0 warn <nl> + class InputAnnotationClosingParenthesHasBadIndentation { / / indent : 0 exp : 0 <nl> + @ SimpleType ( value = Boolean . class / / indent : 4 exp : 4 <nl> + ) / / indent : 8 exp : 4 warn <nl> + Boolean booleanField ; / / indent : 4 exp : 4 <nl> + } / / indent : 0 exp : 0 <nl> \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / pom . xml b / pom . xml <nl> index 6ad8a45 . . d769c67 100644 <nl> - - - a / pom . xml <nl> + + + b / pom . xml <nl> @ @ - 1185 , 7 + 1185 , 7 @ @ <nl> < regex > < pattern > . * . checks . javadoc . JavadocStyleCheck < / pattern > < branchRate > 89 < / branchRate > < lineRate > 98 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . JavadocTagContinuationIndentationCheck < / pattern > < branchRate > 81 < / branchRate > < lineRate > 86 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . JavadocTypeCheck < / pattern > < branchRate > 95 < / branchRate > < lineRate > 93 < / lineRate > < / regex > <nl> - < regex > < pattern > . * . checks . javadoc . JavadocUtils < / pattern > < branchRate > 94 < / branchRate > < lineRate > 98 < / lineRate > < / regex > <nl> + < regex > < pattern > . * . checks . javadoc . JavadocUtils < / pattern > < branchRate > 94 < / branchRate > < lineRate > 100 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . SummaryJavadocCheck < / pattern > < branchRate > 93 < / branchRate > < lineRate > 100 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . TagParser < / pattern > < branchRate > 92 < / branchRate > < lineRate > 98 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . WriteTagCheck < / pattern > < branchRate > 100 < / branchRate > < lineRate > 91 < / lineRate > < / regex > <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java b / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java <nl> index 235d03d . . 8b6c551 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java <nl> @ @ - 58 , 7 + 58 , 7 @ @ public final class Utils { <nl> } <nl> <nl> final String name = f . getName ( ) ; <nl> - final int tokenValue = getTokenFieldValue ( f , name ) ; <nl> + final int tokenValue = getIntFromField ( f , name ) ; <nl> builder . put ( name , tokenValue ) ; <nl> if ( tokenValue > tempTokenValueToName . length - 1 ) { <nl> final String [ ] temp = new String [ tokenValue + 1 ] ; <nl> @ @ - 365 , 19 + 365 , 21 @ @ public final class Utils { <nl> } <nl> <nl> / * * <nl> - * That method exists as workaround for code - coverage 100 % target to let test <nl> - * catch block ( originally it was in static area ) . <nl> - * @ param field token field <nl> - * @ param name token name <nl> - * @ return value of field <nl> + * Gets the value of a static or instance field of type int or of another primitive type <nl> + * convertible to type int via a widening conversion . Does not throw any checked exceptions . <nl> + * @ param field from which the int should be extracted <nl> + * @ param object to extract the int value from <nl> + * @ return the value of the field converted to type int <nl> + * @ throws IllegalStateException if this Field object is enforcing Java language access control <nl> + * and the underlying field is inaccessible <nl> + * @ see Field # getInt ( Object ) <nl> * / <nl> - private static int getTokenFieldValue ( Field field , String name ) { <nl> + public static int getIntFromField ( Field field , Object object ) { <nl> try { <nl> - return field . getInt ( name ) ; <nl> + return field . getInt ( object ) ; <nl> } <nl> - catch ( final IllegalArgumentException | IllegalAccessException e ) { <nl> - throw new IllegalStateException ( <nl> - " Failed to instantiate collection of Java tokens " , e ) ; <nl> + catch ( final IllegalAccessException exception ) { <nl> + throw new IllegalStateException ( exception ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocUtils . java <nl> index 45494f1 . . 9bf4e44 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocUtils . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocUtils . java <nl> @ @ - 27 , 6 + 27 , 7 @ @ import java . util . regex . Pattern ; <nl> <nl> import com . google . common . collect . ImmutableMap ; <nl> import com . google . common . collect . Lists ; <nl> + import com . puppycrawl . tools . checkstyle . Utils ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailNode ; <nl> import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; <nl> @ @ - 62 , 25 + 63 , 18 @ @ public final class JavadocUtils { <nl> <nl> final String name = f . getName ( ) ; <nl> <nl> - try { <nl> - final int tokenValue = f . getInt ( name ) ; <nl> - builder . put ( name , tokenValue ) ; <nl> - if ( tokenValue > tempTokenValueToName . length - 1 ) { <nl> - final String [ ] temp = new String [ tokenValue + 1 ] ; <nl> - System . arraycopy ( tempTokenValueToName , 0 , temp , 0 , tempTokenValueToName . length ) ; <nl> - tempTokenValueToName = temp ; <nl> - } <nl> - if ( tokenValue = = - 1 ) { <nl> - tempTokenValueToName [ 0 ] = name ; <nl> - } <nl> - else { <nl> - tempTokenValueToName [ tokenValue ] = name ; <nl> - } <nl> + final int tokenValue = Utils . getIntFromField ( f , name ) ; <nl> + builder . put ( name , tokenValue ) ; <nl> + if ( tokenValue > tempTokenValueToName . length - 1 ) { <nl> + final String [ ] temp = new String [ tokenValue + 1 ] ; <nl> + System . arraycopy ( tempTokenValueToName , 0 , temp , 0 , tempTokenValueToName . length ) ; <nl> + tempTokenValueToName = temp ; <nl> + } <nl> + if ( tokenValue = = - 1 ) { <nl> + tempTokenValueToName [ 0 ] = name ; <nl> } <nl> - catch ( IllegalAccessException ex ) { <nl> - / / rethrow as unchecked exception <nl> - throw new IllegalStateException ( <nl> - " Failed to instantiate collection of Javadoc tokens " , ex ) ; <nl> + else { <nl> + tempTokenValueToName [ tokenValue ] = name ; <nl> } <nl> } <nl> <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java <nl> index 39327df . . 253742b 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java <nl> @ @ - 28 , 8 + 28 , 6 @ @ import java . io . File ; <nl> import java . io . IOException ; <nl> import java . lang . reflect . Constructor ; <nl> import java . lang . reflect . Field ; <nl> - import java . lang . reflect . InvocationTargetException ; <nl> - import java . lang . reflect . Method ; <nl> import java . lang . reflect . Modifier ; <nl> import java . util . Dictionary ; <nl> <nl> @ @ - 172 , 6 + 170 , 25 @ @ public class UtilsTest { <nl> } <nl> <nl> @ Test <nl> + public void testGetIntFromAccessibleField ( ) throws NoSuchFieldException { <nl> + Field field = Integer . class . getField ( " MAX _ VALUE " ) ; <nl> + <nl> + assertEquals ( Integer . MAX _ VALUE , Utils . getIntFromField ( field , 0 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testGetIntFromInaccessibleField ( ) throws NoSuchFieldException { <nl> + Field field = Integer . class . getDeclaredField ( " value " ) ; <nl> + <nl> + try { <nl> + Utils . getIntFromField ( field , 0 ) ; <nl> + } <nl> + catch ( IllegalStateException expected ) { <nl> + / / expected <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> public void testTokenValueIncorrect ( ) throws NoSuchMethodException { <nl> Integer id = Integer . MAX _ VALUE - 1 ; <nl> try { <nl> @ @ - 252 , 29 + 269 , 4 @ @ public class UtilsTest { <nl> Assert . assertTrue ( Utils . isCommentType ( TokenTypes . BLOCK _ COMMENT _ END ) ) ; <nl> Assert . assertTrue ( Utils . isCommentType ( TokenTypes . COMMENT _ CONTENT ) ) ; <nl> } <nl> - <nl> - @ Test <nl> - public void testGetTokenFieldValue ( ) throws NoSuchMethodException { <nl> - Integer id = 0 ; <nl> - try { <nl> - / / overwrite static field with new value <nl> - Method method = Utils . class . getDeclaredMethod ( " getTokenFieldValue " , <nl> - Field . class , String . class ) ; <nl> - method . setAccessible ( true ) ; <nl> - method . invoke ( null , Field . class . getDeclaredField ( " modifiers " ) , " smth _ strange " ) ; <nl> - <nl> - fail ( ) ; <nl> - } <nl> - catch ( InvocationTargetException expected ) { <nl> - / / in method we throw IllegalStateException , <nl> - / / but JDK wrap that in InvocationTargetException <nl> - assertEquals ( IllegalStateException . class , expected . getCause ( ) . getClass ( ) ) ; <nl> - assertEquals ( " Failed to instantiate collection of Java tokens " , <nl> - expected . getCause ( ) . getMessage ( ) ) ; <nl> - } <nl> - catch ( Exception e ) { <nl> - fail ( ) ; <nl> - } <nl> - } <nl> - <nl> }

TEST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / LineWrappingHandler . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / LineWrappingHandler . java 
 index ac7281e . . 8a68a6b 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / LineWrappingHandler . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / LineWrappingHandler . java 
 @ @ - 33 , 7 + 33 , 7 @ @ import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 * lineWrappingIndentation parameter . 
 * 
 * @ author maxvetrenko 
 - * 
 + * @ author < a href = " mailto : piotr . listkiewicz @ gmail . com " > liscju < / a > 
 * / 
 public class LineWrappingHandler { 
 
 @ @ - 222 , 10 + 222 , 13 @ @ public class LineWrappingHandler { 
 while ( firstNodesOnLines . size ( ) > 1 ) { 
 final DetailAST node = itr . next ( ) ; 
 
 - if ( node . getLineNo ( ) < lastAnnotationLine 
 - | | node . getLineNo ( ) = = lastAnnotationLine ) { 
 + if ( node . getLineNo ( ) < = lastAnnotationLine ) { 
 final DetailAST parentNode = node . getParent ( ) ; 
 - if ( node . getType ( ) = = TokenTypes . AT 
 + final boolean isCurrentNodeCloseAnnotationAloneInLine = 
 + node . getLineNo ( ) = = lastAnnotationLine 
 + & & node . equals ( lastAnnotationNode ) ; 
 + if ( isCurrentNodeCloseAnnotationAloneInLine 
 + | | node . getType ( ) = = TokenTypes . AT 
 & & parentNode . getParent ( ) . getType ( ) = = TokenTypes . MODIFIERS ) { 
 logWarningMessage ( node , firstNodeIndent ) ; 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java 
 index 54a4f70 . . 1f2b24e 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java 
 @ @ - 332 , 6 + 332 , 24 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { 
 } 
 
 @ Test 
 + public void testAnnotationClosingParenthesisEndsInSameIndentationAsOpening ( ) throws Exception { 
 + final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; 
 + 
 + checkConfig . addAttribute ( " basicOffset " , " 4 " ) ; 
 + checkConfig . addAttribute ( " forceStrictCondition " , " true " ) ; 
 + checkConfig . addAttribute ( " tabWidth " , " 4 " ) ; 
 + 
 + final String [ ] expected = { 
 + " 19 : " + getCheckMessage ( MSG _ ERROR , " ) " , 16 , 0 ) , 
 + " 22 : " + getCheckMessage ( MSG _ ERROR , " ) " , 8 , 4 ) , 
 + } ; 
 + 
 + verifyWarns ( checkConfig , 
 + getPath ( " InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening . java " ) , 
 + expected ) ; 
 + } 
 + 
 + @ Test 
 public void testAnonClassesFromGuava ( ) throws Exception { 
 final DefaultConfiguration checkConfig = createCheckConfig ( IndentationCheck . class ) ; 
 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / indentation / InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / indentation / InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening . java 
 new file mode 100644 
 index 0000000 . . 16a2412 
 - - - / dev / null 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / indentation / InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening . java 
 @ @ - 0 , 0 + 1 , 24 @ @ 
 + package com . puppycrawl . tools . checkstyle . checks . indentation ; / / indent : 0 exp : 0 
 + 
 + @ interface SimpleType { / / indent : 0 exp : 0 
 + Class < ? > value ( ) ; / / indent : 4 exp : 4 
 + } / / indent : 0 exp : 0 
 + 
 + @ SimpleType ( / / indent : 0 exp : 0 
 + value = Boolean . class / / indent : 4 exp : 4 
 + ) / / indent : 0 exp : 0 
 + public class InputAnnotationClosingParenthesisEndsInSameIndentationAsOpening { / / indent : 0 exp : 0 
 + } / / indent : 0 exp : 0 
 + 
 + @ SimpleType ( value = Boolean . class / / indent : 0 exp : 0 
 + ) / / indent : 0 exp : 0 
 + class InputAnnotationClosingParenthesisJustLineAfterOpeningSameIndentationAsOpening { / / indent : 0 exp : 0 
 + } / / indent : 0 exp : 0 
 + 
 + @ SimpleType ( value = Boolean . class / / indent : 0 exp : 0 
 + ) / / indent : 16 exp : 0 warn 
 + class InputAnnotationClosingParenthesHasBadIndentation { / / indent : 0 exp : 0 
 + @ SimpleType ( value = Boolean . class / / indent : 4 exp : 4 
 + ) / / indent : 8 exp : 4 warn 
 + Boolean booleanField ; / / indent : 4 exp : 4 
 + } / / indent : 0 exp : 0 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / pom . xml b / pom . xml 
 index 6ad8a45 . . d769c67 100644 
 - - - a / pom . xml 
 + + + b / pom . xml 
 @ @ - 1185 , 7 + 1185 , 7 @ @ 
 < regex > < pattern > . * . checks . javadoc . JavadocStyleCheck < / pattern > < branchRate > 89 < / branchRate > < lineRate > 98 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . JavadocTagContinuationIndentationCheck < / pattern > < branchRate > 81 < / branchRate > < lineRate > 86 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . JavadocTypeCheck < / pattern > < branchRate > 95 < / branchRate > < lineRate > 93 < / lineRate > < / regex > 
 - < regex > < pattern > . * . checks . javadoc . JavadocUtils < / pattern > < branchRate > 94 < / branchRate > < lineRate > 98 < / lineRate > < / regex > 
 + < regex > < pattern > . * . checks . javadoc . JavadocUtils < / pattern > < branchRate > 94 < / branchRate > < lineRate > 100 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . SummaryJavadocCheck < / pattern > < branchRate > 93 < / branchRate > < lineRate > 100 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . TagParser < / pattern > < branchRate > 92 < / branchRate > < lineRate > 98 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . WriteTagCheck < / pattern > < branchRate > 100 < / branchRate > < lineRate > 91 < / lineRate > < / regex > 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java b / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java 
 index 235d03d . . 8b6c551 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / Utils . java 
 @ @ - 58 , 7 + 58 , 7 @ @ public final class Utils { 
 } 
 
 final String name = f . getName ( ) ; 
 - final int tokenValue = getTokenFieldValue ( f , name ) ; 
 + final int tokenValue = getIntFromField ( f , name ) ; 
 builder . put ( name , tokenValue ) ; 
 if ( tokenValue > tempTokenValueToName . length - 1 ) { 
 final String [ ] temp = new String [ tokenValue + 1 ] ; 
 @ @ - 365 , 19 + 365 , 21 @ @ public final class Utils { 
 } 
 
 / * * 
 - * That method exists as workaround for code - coverage 100 % target to let test 
 - * catch block ( originally it was in static area ) . 
 - * @ param field token field 
 - * @ param name token name 
 - * @ return value of field 
 + * Gets the value of a static or instance field of type int or of another primitive type 
 + * convertible to type int via a widening conversion . Does not throw any checked exceptions . 
 + * @ param field from which the int should be extracted 
 + * @ param object to extract the int value from 
 + * @ return the value of the field converted to type int 
 + * @ throws IllegalStateException if this Field object is enforcing Java language access control 
 + * and the underlying field is inaccessible 
 + * @ see Field # getInt ( Object ) 
 * / 
 - private static int getTokenFieldValue ( Field field , String name ) { 
 + public static int getIntFromField ( Field field , Object object ) { 
 try { 
 - return field . getInt ( name ) ; 
 + return field . getInt ( object ) ; 
 } 
 - catch ( final IllegalArgumentException | IllegalAccessException e ) { 
 - throw new IllegalStateException ( 
 - " Failed to instantiate collection of Java tokens " , e ) ; 
 + catch ( final IllegalAccessException exception ) { 
 + throw new IllegalStateException ( exception ) ; 
 } 
 } 
 } 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocUtils . java 
 index 45494f1 . . 9bf4e44 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocUtils . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocUtils . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import java . util . regex . Pattern ; 
 
 import com . google . common . collect . ImmutableMap ; 
 import com . google . common . collect . Lists ; 
 + import com . puppycrawl . tools . checkstyle . Utils ; 
 import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . DetailNode ; 
 import com . puppycrawl . tools . checkstyle . api . JavadocTagInfo ; 
 @ @ - 62 , 25 + 63 , 18 @ @ public final class JavadocUtils { 
 
 final String name = f . getName ( ) ; 
 
 - try { 
 - final int tokenValue = f . getInt ( name ) ; 
 - builder . put ( name , tokenValue ) ; 
 - if ( tokenValue > tempTokenValueToName . length - 1 ) { 
 - final String [ ] temp = new String [ tokenValue + 1 ] ; 
 - System . arraycopy ( tempTokenValueToName , 0 , temp , 0 , tempTokenValueToName . length ) ; 
 - tempTokenValueToName = temp ; 
 - } 
 - if ( tokenValue = = - 1 ) { 
 - tempTokenValueToName [ 0 ] = name ; 
 - } 
 - else { 
 - tempTokenValueToName [ tokenValue ] = name ; 
 - } 
 + final int tokenValue = Utils . getIntFromField ( f , name ) ; 
 + builder . put ( name , tokenValue ) ; 
 + if ( tokenValue > tempTokenValueToName . length - 1 ) { 
 + final String [ ] temp = new String [ tokenValue + 1 ] ; 
 + System . arraycopy ( tempTokenValueToName , 0 , temp , 0 , tempTokenValueToName . length ) ; 
 + tempTokenValueToName = temp ; 
 + } 
 + if ( tokenValue = = - 1 ) { 
 + tempTokenValueToName [ 0 ] = name ; 
 } 
 - catch ( IllegalAccessException ex ) { 
 - / / rethrow as unchecked exception 
 - throw new IllegalStateException ( 
 - " Failed to instantiate collection of Javadoc tokens " , ex ) ; 
 + else { 
 + tempTokenValueToName [ tokenValue ] = name ; 
 } 
 } 
 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java 
 index 39327df . . 253742b 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / UtilsTest . java 
 @ @ - 28 , 8 + 28 , 6 @ @ import java . io . File ; 
 import java . io . IOException ; 
 import java . lang . reflect . Constructor ; 
 import java . lang . reflect . Field ; 
 - import java . lang . reflect . InvocationTargetException ; 
 - import java . lang . reflect . Method ; 
 import java . lang . reflect . Modifier ; 
 import java . util . Dictionary ; 
 
 @ @ - 172 , 6 + 170 , 25 @ @ public class UtilsTest { 
 } 
 
 @ Test 
 + public void testGetIntFromAccessibleField ( ) throws NoSuchFieldException { 
 + Field field = Integer . class . getField ( " MAX _ VALUE " ) ; 
 + 
 + assertEquals ( Integer . MAX _ VALUE , Utils . getIntFromField ( field , 0 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testGetIntFromInaccessibleField ( ) throws NoSuchFieldException { 
 + Field field = Integer . class . getDeclaredField ( " value " ) ; 
 + 
 + try { 
 + Utils . getIntFromField ( field , 0 ) ; 
 + } 
 + catch ( IllegalStateException expected ) { 
 + / / expected 
 + } 
 + } 
 + 
 + @ Test 
 public void testTokenValueIncorrect ( ) throws NoSuchMethodException { 
 Integer id = Integer . MAX _ VALUE - 1 ; 
 try { 
 @ @ - 252 , 29 + 269 , 4 @ @ public class UtilsTest { 
 Assert . assertTrue ( Utils . isCommentType ( TokenTypes . BLOCK _ COMMENT _ END ) ) ; 
 Assert . assertTrue ( Utils . isCommentType ( TokenTypes . COMMENT _ CONTENT ) ) ; 
 } 
 - 
 - @ Test 
 - public void testGetTokenFieldValue ( ) throws NoSuchMethodException { 
 - Integer id = 0 ; 
 - try { 
 - / / overwrite static field with new value 
 - Method method = Utils . class . getDeclaredMethod ( " getTokenFieldValue " , 
 - Field . class , String . class ) ; 
 - method . setAccessible ( true ) ; 
 - method . invoke ( null , Field . class . getDeclaredField ( " modifiers " ) , " smth _ strange " ) ; 
 - 
 - fail ( ) ; 
 - } 
 - catch ( InvocationTargetException expected ) { 
 - / / in method we throw IllegalStateException , 
 - / / but JDK wrap that in InvocationTargetException 
 - assertEquals ( IllegalStateException . class , expected . getCause ( ) . getClass ( ) ) ; 
 - assertEquals ( " Failed to instantiate collection of Java tokens " , 
 - expected . getCause ( ) . getMessage ( ) ) ; 
 - } 
 - catch ( Exception e ) { 
 - fail ( ) ; 
 - } 
 - } 
 - 
 }
