BLEU SCORE: 0.07714073404379711

TEST MSG: Issue # 2078 : Update xdoc for CommentsIndentationCheck
GENERATED MSG: Issue # 2078 : Fix FP violations at the end of the block and in the middle of the method

TEST DIFF (one line): diff - - git a / src / xdocs / config _ misc . xml b / src / xdocs / config _ misc . xml <nl> index 7a4c3f3 . . abe61f2 100755 <nl> - - - a / src / xdocs / config _ misc . xml <nl> + + + b / src / xdocs / config _ misc . xml <nl> @ @ - 206 , 6 + 206 , 166 @ @ <nl> " http : / / checkstyle . sourceforge . net / reports / google - java - style . html # s4 . 8 . 6 . 1 - block - comment - style " > <nl> here < / a > <nl> < / p > <nl> + < p > Please take a look at the following examples to understand how the check works : < / p > <nl> + <nl> + < p > Example # 1 : Block comments . < / p > <nl> + < source > <nl> + 1 / * <nl> + 2 * it is Ok <nl> + 3 * / <nl> + 4 boolean bool = true ; <nl> + 5 <nl> + 6 / * violation <nl> + 7 * ( block comment should have the same indentation level as line 9 ) <nl> + 8 * / <nl> + 9 double d = 3 . 14 ; <nl> + < / source > <nl> + < p > Example # 2 : Comment is placed at the end of the block and has previous statement . < / p > <nl> + < source > <nl> + 1 public void foo1 ( ) { <nl> + 2 foo2 ( ) ; <nl> + 3 / / it is OK <nl> + 4 } <nl> + 5 <nl> + 6 public void foo2 ( ) { <nl> + 7 foo3 ( ) ; <nl> + 8 / / violation ( comment should have the same indentation level as line 7 ) <nl> + 9 } <nl> + < / source > <nl> + < p > Example # 3 : Comment is used as a single line border to separate groups of methods . < / p > <nl> + < source > <nl> + 1 / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / it is OK <nl> + 2 <nl> + 3 public void foo7 ( ) { <nl> + 4 int a = 0 ; <nl> + 5 } <nl> + 6 <nl> + 7 / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / violation ( should have the same indentation level as line 9 ) <nl> + 8 <nl> + 9 public void foo8 ( ) { } <nl> + < / source > <nl> + < p > Example # 4 : Comment has destributed previous statement . < / p > <nl> + < source > <nl> + 1 public void foo11 ( ) { <nl> + 2 CheckUtils <nl> + 3 . getFirstNode ( new DetailAST ( ) ) <nl> + 4 . getFirstChild ( ) <nl> + 5 . getNextSibling ( ) ; <nl> + 6 / / it is OK <nl> + 7 } <nl> + 8 <nl> + 9 public void foo12 ( ) { <nl> + 10 CheckUtils <nl> + 11 . getFirstNode ( new DetailAST ( ) ) <nl> + 12 . getFirstChild ( ) <nl> + 13 . getNextSibling ( ) ; <nl> + 14 / / violation ( should have the same indentation level as line 10 ) <nl> + 15 } <nl> + < / source > <nl> + < p > <nl> + Example # 5 : Single line block comment is placed within an empty code block . <nl> + Note , if comment is placed at the end of the empty code block , we have Checkstyle ' s <nl> + limitations to clearly detect user intention of explanation target - above or below . The <nl> + only case we can assume as a violation is when a single line comment within the empty <nl> + code block has indentation level that is lower than the indentation level of the closing <nl> + right curly brace . <nl> + < / p > <nl> + < source > <nl> + 1 public void foo46 ( ) { <nl> + 2 / / comment <nl> + 3 / / block <nl> + 4 / / it is OK ( we cannot clearly detect user intention of explanation target ) <nl> + 5 } <nl> + 6 <nl> + 7 public void foo46 ( ) { <nl> + 8 / / comment <nl> + 9 / / block <nl> + 10 / / violation ( comment hould have the same indentation level as line 11 ) <nl> + 11 } <nl> + < / source > <nl> + < p > Example # 6 : ' fallthrough ' comments and similar . < / p > <nl> + < source > <nl> + 0 switch ( a ) { <nl> + 1 case " 1 " : <nl> + 2 int k = 7 ; <nl> + 3 / / it is OK <nl> + 4 case " 2 " : <nl> + 5 int k = 7 ; <nl> + 6 / / it is OK <nl> + 7 case " 3 " : <nl> + 8 if ( true ) { } <nl> + 9 / / violation ( should have the same indentation level as line 8 or 10 ) <nl> + 10 case " 4 " : <nl> + 11 case " 5 " : { <nl> + 12 int a ; <nl> + 13 } <nl> + 14 / / fall through ( it is OK ) <nl> + 15 case " 12 " : { <nl> + 16 int a ; <nl> + 17 } <nl> + 18 default : <nl> + 19 / / it is OK <nl> + 20 } <nl> + < / source > <nl> + < p > Example # 7 : Comment is placed within a destributed statement . < / p > <nl> + < source > <nl> + 1 String breaks = " J " <nl> + 2 / / violation ( comment should have the same indentation level as line 3 ) <nl> + 3 + " A " <nl> + 4 / / it is OK <nl> + 5 + " V " <nl> + 6 + " A " <nl> + 7 / / it is OK <nl> + 8 ; <nl> + < / source > <nl> + < p > <nl> + Examnple # 8 : Comment is placed within an empty case block . <nl> + Note , if comment is placed at the end of the empty case block , we have Checkstyle ' s <nl> + limitations to clearly detect user intention of explanation target - above or below . The <nl> + only case we can assume as a violation is when a single line comment within the empty case <nl> + block has indentation level that is lower than the indentation level of the next case <nl> + token . <nl> + < / p > <nl> + < source > <nl> + 1 case 4 : <nl> + 2 / / it is OK <nl> + 3 case 5 : <nl> + 4 / / violation ( should have the same indentation level as line 3 or 5 ) <nl> + 5 case 6 : <nl> + < / source > <nl> + < p > Example # 9 : Single line block comment has previous and next statement . < / p > <nl> + < source > <nl> + 1 String s1 = " Clean code ! " ; <nl> + 2 s . toString ( ) . toString ( ) . toString ( ) ; <nl> + 3 / / single line <nl> + 4 / / block <nl> + 5 / / comment ( it is OK ) <nl> + 6 int a = 5 ; <nl> + 7 <nl> + 8 String s2 = " Code complete ! " ; <nl> + 9 s . toString ( ) . toString ( ) . toString ( ) ; <nl> + 10 / / violation ( should have the same indentation level as line 11 ) <nl> + 11 / / violation ( should have the same indentation level as line 12 ) <nl> + 12 / / violation ( should have the same indentation level as line 13 ) <nl> + 13 int b = 18 ; <nl> + < / source > <nl> + < p > Example # 10 : Comment within the block tries to describe the next code block . < / p > <nl> + < source > <nl> + 1 public void foo42 ( ) { <nl> + 2 int a = 5 ; <nl> + 3 if ( a = = 5 ) { <nl> + 4 int b ; <nl> + 5 / / it is OK <nl> + 6 } else if ( a = = 6 ) { . . . } <nl> + 7 } <nl> + 8 <nl> + 9 public void foo43 ( ) { <nl> + 10 try { <nl> + 11 int a ; <nl> + 12 / / Why do we catch exception here ? - violation ( should have the same indenatation as line 11 ) <nl> + 13 } catch ( Exception e ) { . . . } <nl> + 14 } <nl> + < / source > <nl> < / subsection > <nl> < subsection name = " Properties " > <nl> < table > <nl> @ @ - 238 , 25 + 398 , 6 @ @ <nl> < source > <nl> & lt ; module name = & quot ; CommentsIndentation & quot ; / & gt ; <nl> < / source > <nl> - < source > <nl> - / * <nl> - * comment <nl> - * some comment <nl> - * / <nl> - boolean bool = true ; - such comment indentation is ok <nl> - <nl> - / * <nl> - * comment <nl> - * some comment <nl> - * / <nl> - double d = 3 . 14 ; - Block Comment has incorrect indentation level 3 , expected 0 . <nl> - <nl> - / / some comment - comment is ok <nl> - String str = " " ; <nl> - <nl> - / / some comment Comment has incorrect indentation level 4 , expected 0 . <nl> - String str1 = " " ; <nl> - < / source > <nl> < / subsection > <nl> <nl> < subsection name = " Example of Usage " >
NEAREST DIFF (one line): diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpCheckTest . java <nl> index 76c307f . . 7f40212 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpCheckTest . java <nl> @ @ - 24 , 6 + 24 , 9 @ @ import static com . puppycrawl . tools . checkstyle . checks . regexp . RegexpCheck . MSG _ ILLE <nl> import static com . puppycrawl . tools . checkstyle . checks . regexp . RegexpCheck . MSG _ REQUIRED _ REGEXP ; <nl> import static org . junit . Assert . assertArrayEquals ; <nl> <nl> + import java . io . File ; <nl> + import java . io . IOException ; <nl> + <nl> import org . apache . commons . lang3 . ArrayUtils ; <nl> import org . junit . Test ; <nl> <nl> @ @ - 31 , 6 + 34 , 11 @ @ import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; <nl> import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; <nl> <nl> public class RegexpCheckTest extends BaseCheckTestSupport { <nl> + @ Override <nl> + protected String getPath ( String filename ) throws IOException { <nl> + return super . getPath ( " checks " + File . separator <nl> + + " regexp " + File . separator + filename ) ; <nl> + } <nl> <nl> @ Test <nl> public void testGetRequiredTokens ( ) { <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpMultilineCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpMultilineCheckTest . java <nl> index b088442 . . 093ff3f 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpMultilineCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpMultilineCheckTest . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . RE <nl> import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . STACKOVERFLOW ; <nl> <nl> import java . io . File ; <nl> + import java . io . IOException ; <nl> <nl> import org . apache . commons . lang3 . ArrayUtils ; <nl> import org . junit . Before ; <nl> @ @ - 47 , 6 + 48 , 12 @ @ public class RegexpMultilineCheckTest extends BaseFileSetCheckTestSupport { <nl> checkConfig = createCheckConfig ( RegexpMultilineCheck . class ) ; <nl> } <nl> <nl> + @ Override <nl> + protected String getPath ( String filename ) throws IOException { <nl> + return super . getPath ( " checks " + File . separator <nl> + + " regexp " + File . separator + filename ) ; <nl> + } <nl> + <nl> @ Test <nl> public void testIt ( ) throws Exception { <nl> final String illegal = " System \ \ . ( out ) | ( err ) \ \ . print ( ln ) ? \ \ ( " ; <nl> @ @ - 196 , 5 + 203 , 4 @ @ public class RegexpMultilineCheckTest extends BaseFileSetCheckTestSupport { <nl> final String [ ] expected = ArrayUtils . EMPTY _ STRING _ ARRAY ; <nl> verify ( checkConfig , getPath ( " InputSemantic . java " ) , expected ) ; <nl> } <nl> - <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineCheckTest . java <nl> index e60bfec . . 6e2f9ac 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineCheckTest . java <nl> @ @ - 22 , 6 + 22 , 9 @ @ package com . puppycrawl . tools . checkstyle . checks . regexp ; <nl> import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP _ EXCEEDED ; <nl> import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP _ MINIMUM ; <nl> <nl> + import java . io . File ; <nl> + import java . io . IOException ; <nl> + <nl> import org . apache . commons . lang3 . ArrayUtils ; <nl> import org . junit . Before ; <nl> import org . junit . Test ; <nl> @ @ - 37 , 6 + 40 , 12 @ @ public class RegexpSinglelineCheckTest extends BaseFileSetCheckTestSupport { <nl> checkConfig = createCheckConfig ( RegexpSinglelineCheck . class ) ; <nl> } <nl> <nl> + @ Override <nl> + protected String getPath ( String filename ) throws IOException { <nl> + return super . getPath ( " checks " + File . separator <nl> + + " regexp " + File . separator + filename ) ; <nl> + } <nl> + <nl> @ Test <nl> public void testIt ( ) throws Exception { <nl> final String illegal = " System \ \ . ( out ) | ( err ) \ \ . print ( ln ) ? \ \ ( " ; <nl> @ @ - 106 , 5 + 115 , 4 @ @ public class RegexpSinglelineCheckTest extends BaseFileSetCheckTestSupport { <nl> <nl> verify ( checkConfig , getPath ( " InputSemantic . java " ) , expected ) ; <nl> } <nl> - <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineJavaCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineJavaCheckTest . java <nl> index f10ddaf . . e9a6fac 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineJavaCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineJavaCheckTest . java <nl> @ @ - 23 , 6 + 23 , 9 @ @ import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . RE <nl> import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP _ MINIMUM ; <nl> import static org . junit . Assert . assertArrayEquals ; <nl> <nl> + import java . io . File ; <nl> + import java . io . IOException ; <nl> + <nl> import org . apache . commons . lang3 . ArrayUtils ; <nl> import org . junit . Before ; <nl> import org . junit . Test ; <nl> @ @ - 38 , 6 + 41 , 12 @ @ public class RegexpSinglelineJavaCheckTest extends BaseCheckTestSupport { <nl> checkConfig = createCheckConfig ( RegexpSinglelineJavaCheck . class ) ; <nl> } <nl> <nl> + @ Override <nl> + protected String getPath ( String filename ) throws IOException { <nl> + return super . getPath ( " checks " + File . separator <nl> + + " regexp " + File . separator + filename ) ; <nl> + } <nl> + <nl> @ Test <nl> public void testGetRequiredTokens ( ) { <nl> RegexpSinglelineJavaCheck checkObj = new RegexpSinglelineJavaCheck ( ) ; <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / InputStartingWithEmptyLine . java b / src / test / resources / com / puppycrawl / tools / checkstyle / InputStartingWithEmptyLine . java <nl> deleted file mode 100644 <nl> index 86c4296 . . 0000000 <nl> - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / InputStartingWithEmptyLine . java <nl> + + + / dev / null <nl> @ @ - 1 , 2 + 0 , 0 @ @ <nl> - <nl> - package com . puppycrawl . tools . checkstyle ; <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputSemantic . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputSemantic . java <nl> new file mode 100644 <nl> index 0000000 . . fd13419 <nl> - - - / dev / null <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputSemantic . java <nl> @ @ - 0 , 0 + 1 , 222 @ @ <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + / / Test case file for checkstyle . <nl> + / / Created : 2001 <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + package com . puppycrawl . tools . checkstyle . checks . regexp ; <nl> + <nl> + import java . io . * ; / / star import for instantiation tests <nl> + import java . awt . Dimension ; / / explicit import for instantiation tests <nl> + import java . awt . Color ; <nl> + <nl> + / * * <nl> + * Test case for detecting simple semantic errors . <nl> + * @ author Lars K ü hne <nl> + * * / <nl> + class InputSemantic <nl> + { <nl> + / * Boolean instantiation in a static initializer * / <nl> + static { <nl> + Boolean x = new Boolean ( true ) ; <nl> + } <nl> + <nl> + / * Boolean instantiation in a non - static initializer * / <nl> + { <nl> + Boolean x = new Boolean ( true ) ; <nl> + Boolean [ ] y = new Boolean [ ] { Boolean . TRUE , Boolean . FALSE } ; <nl> + } <nl> + <nl> + / * * fully qualified Boolean instantiation in a method . * * / <nl> + Boolean getBoolean ( ) <nl> + { <nl> + return new java . lang . Boolean ( true ) ; <nl> + } <nl> + <nl> + void otherInstantiations ( ) <nl> + { <nl> + / / instantiation of classes in the same package <nl> + Object o1 = new InputBraces ( ) ; <nl> + Object o2 = new InputModifier ( ) ; <nl> + / / classes in another package with . * import <nl> + ByteArrayOutputStream s = new ByteArrayOutputStream ( ) ; <nl> + File f = new File ( " / tmp " ) ; <nl> + / / classes in another package with explicit import <nl> + Dimension dim = new Dimension ( ) ; <nl> + Color col = new Color ( 0 , 0 , 0 ) ; <nl> + } <nl> + <nl> + void exHandlerTest ( ) <nl> + { <nl> + try { <nl> + ; / / do stuff and don ' t handle exceptions in some cases <nl> + } <nl> + catch ( IllegalStateException emptyCatchIsAlwaysAnError ) { <nl> + } <nl> + catch ( NullPointerException ex ) { <nl> + / / can never happen , but only commentig this is currently an error <nl> + / / Possible future enhancement : allowEmptyCatch = " commented " <nl> + } <nl> + catch ( ArrayIndexOutOfBoundsException ex ) { <nl> + ; <nl> + / / can never happen , semicolon makes checkstyle happy <nl> + / / this is a workaround for above problem <nl> + } <nl> + catch ( NegativeArraySizeException ex ) { <nl> + { <nl> + } <nl> + / / can never happen , empty compound statement is another workaround <nl> + } <nl> + catch ( UnsupportedOperationException handledException ) { <nl> + System . out . println ( handledException . getMessage ( ) ) ; <nl> + } <nl> + catch ( SecurityException ex ) { / * hello * / } <nl> + catch ( StringIndexOutOfBoundsException ex ) { } <nl> + catch ( IllegalArgumentException ex ) { } <nl> + <nl> + try { <nl> + } <nl> + finally { <nl> + } <nl> + try { <nl> + / / something <nl> + } <nl> + finally { <nl> + / / something <nl> + } <nl> + try { <nl> + ; / / something <nl> + } <nl> + finally { <nl> + ; / / statement <nl> + } <nl> + } <nl> + <nl> + / * * test * * / <nl> + private static final long IGNORE = 666l + 666L ; <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + <nl> + public class EqualsVsHashCode1 <nl> + { <nl> + public boolean equals ( int a ) / / wrong arg type , don ' t flag <nl> + { <nl> + return a = = 1 ; <nl> + } <nl> + } <nl> + <nl> + public class EqualsVsHashCode2 <nl> + { <nl> + public boolean equals ( String a ) / / flag <nl> + { <nl> + return true ; <nl> + } <nl> + } <nl> + <nl> + public class EqualsVsHashCode3 <nl> + { <nl> + public boolean equals ( Object a ) / / don ' t flag <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> + public int hashCode ( ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + } <nl> + <nl> + public class EqualsVsHashCode4 <nl> + { <nl> + / / in anon inner class <nl> + ByteArrayOutputStream bos1 = new ByteArrayOutputStream ( ) <nl> + { <nl> + public boolean equals ( Object a ) / / don ' t flag <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> + public int hashCode ( ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + } ; <nl> + <nl> + ByteArrayOutputStream bos2 = new ByteArrayOutputStream ( ) <nl> + { <nl> + public boolean equals ( Object a ) / / flag <nl> + { <nl> + return true ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + public void triggerEmptyBlockWithoutBlock ( ) <nl> + { <nl> + / / an if statement without a block to increase test coverage <nl> + if ( true ) <nl> + return ; <nl> + } <nl> + <nl> + / / empty instance initializer <nl> + { <nl> + } <nl> + <nl> + public class EqualsVsHashCode5 <nl> + { <nl> + public < A > boolean equals ( int a ) / / wrong arg type , don ' t flag even with generics <nl> + { <nl> + return a = = 1 ; <nl> + } <nl> + } <nl> + <nl> + public class EqualsVsHashCode6 <nl> + { <nl> + public < A > boolean equals ( Comparable < A > a ) / / flag , weven with generics <nl> + { <nl> + return true ; <nl> + } <nl> + } <nl> + <nl> + private class InputBraces { <nl> + <nl> + } <nl> + <nl> + private class InputModifier { <nl> + <nl> + } <nl> + <nl> + synchronized void foo ( ) { <nl> + synchronized ( this ) { } / / not OK <nl> + synchronized ( Class . class ) { / / OK <nl> + synchronized ( new Object ( ) ) { <nl> + / / not OK if checking statements <nl> + } <nl> + } <nl> + } <nl> + <nl> + <nl> + static { <nl> + <nl> + int a = 0 ; } <nl> + <nl> + static { <nl> + <nl> + } <nl> + } <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputStartingWithEmptyLine . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputStartingWithEmptyLine . java <nl> new file mode 100644 <nl> index 0000000 . . 630e139 <nl> - - - / dev / null <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputStartingWithEmptyLine . java <nl> @ @ - 0 , 0 + 1 , 2 @ @ <nl> + <nl> + package com . puppycrawl . tools . checkstyle . checks . regexp ; <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputTrailingComment . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputTrailingComment . java <nl> new file mode 100644 <nl> index 0000000 . . 9221a8a <nl> - - - / dev / null <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputTrailingComment . java <nl> @ @ - 0 , 0 + 1 , 30 @ @ <nl> + package com . puppycrawl . tools . checkstyle . checks . regexp ; <nl> + <nl> + public class InputTrailingComment { <nl> + int i ; / / don ' t use trailing comments : ) <nl> + / / it fine to have comment w / o any statement <nl> + / * good c - style comment . * / <nl> + int j ; / * bad c - style comment . * / <nl> + void method1 ( ) { / * some c - style multi - line <nl> + comment * / <nl> + Runnable r = ( new Runnable ( ) { <nl> + public void run ( ) { <nl> + } <nl> + } ) ; / * we should allow this * / <nl> + } / / we should allow this <nl> + / * <nl> + Let ' s check multi - line comments . <nl> + * / <nl> + / * c - style * / / / cpp - style <nl> + / * c - style 1 * / / * c - style 2 * / <nl> + <nl> + void method2 ( long ms / * we should ignore this * / ) { <nl> + / * comment before text * / int z ; <nl> + / * int y * / int y / * * / ; <nl> + } <nl> + <nl> + / * * <nl> + * comment with trailing space <nl> + * / <nl> + final static public String NAME = " Some Name " ; / / NOI18N <nl> + }

TEST DIFF:
diff - - git a / src / xdocs / config _ misc . xml b / src / xdocs / config _ misc . xml 
 index 7a4c3f3 . . abe61f2 100755 
 - - - a / src / xdocs / config _ misc . xml 
 + + + b / src / xdocs / config _ misc . xml 
 @ @ - 206 , 6 + 206 , 166 @ @ 
 " http : / / checkstyle . sourceforge . net / reports / google - java - style . html # s4 . 8 . 6 . 1 - block - comment - style " > 
 here < / a > 
 < / p > 
 + < p > Please take a look at the following examples to understand how the check works : < / p > 
 + 
 + < p > Example # 1 : Block comments . < / p > 
 + < source > 
 + 1 / * 
 + 2 * it is Ok 
 + 3 * / 
 + 4 boolean bool = true ; 
 + 5 
 + 6 / * violation 
 + 7 * ( block comment should have the same indentation level as line 9 ) 
 + 8 * / 
 + 9 double d = 3 . 14 ; 
 + < / source > 
 + < p > Example # 2 : Comment is placed at the end of the block and has previous statement . < / p > 
 + < source > 
 + 1 public void foo1 ( ) { 
 + 2 foo2 ( ) ; 
 + 3 / / it is OK 
 + 4 } 
 + 5 
 + 6 public void foo2 ( ) { 
 + 7 foo3 ( ) ; 
 + 8 / / violation ( comment should have the same indentation level as line 7 ) 
 + 9 } 
 + < / source > 
 + < p > Example # 3 : Comment is used as a single line border to separate groups of methods . < / p > 
 + < source > 
 + 1 / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / it is OK 
 + 2 
 + 3 public void foo7 ( ) { 
 + 4 int a = 0 ; 
 + 5 } 
 + 6 
 + 7 / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / violation ( should have the same indentation level as line 9 ) 
 + 8 
 + 9 public void foo8 ( ) { } 
 + < / source > 
 + < p > Example # 4 : Comment has destributed previous statement . < / p > 
 + < source > 
 + 1 public void foo11 ( ) { 
 + 2 CheckUtils 
 + 3 . getFirstNode ( new DetailAST ( ) ) 
 + 4 . getFirstChild ( ) 
 + 5 . getNextSibling ( ) ; 
 + 6 / / it is OK 
 + 7 } 
 + 8 
 + 9 public void foo12 ( ) { 
 + 10 CheckUtils 
 + 11 . getFirstNode ( new DetailAST ( ) ) 
 + 12 . getFirstChild ( ) 
 + 13 . getNextSibling ( ) ; 
 + 14 / / violation ( should have the same indentation level as line 10 ) 
 + 15 } 
 + < / source > 
 + < p > 
 + Example # 5 : Single line block comment is placed within an empty code block . 
 + Note , if comment is placed at the end of the empty code block , we have Checkstyle ' s 
 + limitations to clearly detect user intention of explanation target - above or below . The 
 + only case we can assume as a violation is when a single line comment within the empty 
 + code block has indentation level that is lower than the indentation level of the closing 
 + right curly brace . 
 + < / p > 
 + < source > 
 + 1 public void foo46 ( ) { 
 + 2 / / comment 
 + 3 / / block 
 + 4 / / it is OK ( we cannot clearly detect user intention of explanation target ) 
 + 5 } 
 + 6 
 + 7 public void foo46 ( ) { 
 + 8 / / comment 
 + 9 / / block 
 + 10 / / violation ( comment hould have the same indentation level as line 11 ) 
 + 11 } 
 + < / source > 
 + < p > Example # 6 : ' fallthrough ' comments and similar . < / p > 
 + < source > 
 + 0 switch ( a ) { 
 + 1 case " 1 " : 
 + 2 int k = 7 ; 
 + 3 / / it is OK 
 + 4 case " 2 " : 
 + 5 int k = 7 ; 
 + 6 / / it is OK 
 + 7 case " 3 " : 
 + 8 if ( true ) { } 
 + 9 / / violation ( should have the same indentation level as line 8 or 10 ) 
 + 10 case " 4 " : 
 + 11 case " 5 " : { 
 + 12 int a ; 
 + 13 } 
 + 14 / / fall through ( it is OK ) 
 + 15 case " 12 " : { 
 + 16 int a ; 
 + 17 } 
 + 18 default : 
 + 19 / / it is OK 
 + 20 } 
 + < / source > 
 + < p > Example # 7 : Comment is placed within a destributed statement . < / p > 
 + < source > 
 + 1 String breaks = " J " 
 + 2 / / violation ( comment should have the same indentation level as line 3 ) 
 + 3 + " A " 
 + 4 / / it is OK 
 + 5 + " V " 
 + 6 + " A " 
 + 7 / / it is OK 
 + 8 ; 
 + < / source > 
 + < p > 
 + Examnple # 8 : Comment is placed within an empty case block . 
 + Note , if comment is placed at the end of the empty case block , we have Checkstyle ' s 
 + limitations to clearly detect user intention of explanation target - above or below . The 
 + only case we can assume as a violation is when a single line comment within the empty case 
 + block has indentation level that is lower than the indentation level of the next case 
 + token . 
 + < / p > 
 + < source > 
 + 1 case 4 : 
 + 2 / / it is OK 
 + 3 case 5 : 
 + 4 / / violation ( should have the same indentation level as line 3 or 5 ) 
 + 5 case 6 : 
 + < / source > 
 + < p > Example # 9 : Single line block comment has previous and next statement . < / p > 
 + < source > 
 + 1 String s1 = " Clean code ! " ; 
 + 2 s . toString ( ) . toString ( ) . toString ( ) ; 
 + 3 / / single line 
 + 4 / / block 
 + 5 / / comment ( it is OK ) 
 + 6 int a = 5 ; 
 + 7 
 + 8 String s2 = " Code complete ! " ; 
 + 9 s . toString ( ) . toString ( ) . toString ( ) ; 
 + 10 / / violation ( should have the same indentation level as line 11 ) 
 + 11 / / violation ( should have the same indentation level as line 12 ) 
 + 12 / / violation ( should have the same indentation level as line 13 ) 
 + 13 int b = 18 ; 
 + < / source > 
 + < p > Example # 10 : Comment within the block tries to describe the next code block . < / p > 
 + < source > 
 + 1 public void foo42 ( ) { 
 + 2 int a = 5 ; 
 + 3 if ( a = = 5 ) { 
 + 4 int b ; 
 + 5 / / it is OK 
 + 6 } else if ( a = = 6 ) { . . . } 
 + 7 } 
 + 8 
 + 9 public void foo43 ( ) { 
 + 10 try { 
 + 11 int a ; 
 + 12 / / Why do we catch exception here ? - violation ( should have the same indenatation as line 11 ) 
 + 13 } catch ( Exception e ) { . . . } 
 + 14 } 
 + < / source > 
 < / subsection > 
 < subsection name = " Properties " > 
 < table > 
 @ @ - 238 , 25 + 398 , 6 @ @ 
 < source > 
 & lt ; module name = & quot ; CommentsIndentation & quot ; / & gt ; 
 < / source > 
 - < source > 
 - / * 
 - * comment 
 - * some comment 
 - * / 
 - boolean bool = true ; - such comment indentation is ok 
 - 
 - / * 
 - * comment 
 - * some comment 
 - * / 
 - double d = 3 . 14 ; - Block Comment has incorrect indentation level 3 , expected 0 . 
 - 
 - / / some comment - comment is ok 
 - String str = " " ; 
 - 
 - / / some comment Comment has incorrect indentation level 4 , expected 0 . 
 - String str1 = " " ; 
 - < / source > 
 < / subsection > 
 
 < subsection name = " Example of Usage " >

NEAREST DIFF:
diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpCheckTest . java 
 index 76c307f . . 7f40212 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpCheckTest . java 
 @ @ - 24 , 6 + 24 , 9 @ @ import static com . puppycrawl . tools . checkstyle . checks . regexp . RegexpCheck . MSG _ ILLE 
 import static com . puppycrawl . tools . checkstyle . checks . regexp . RegexpCheck . MSG _ REQUIRED _ REGEXP ; 
 import static org . junit . Assert . assertArrayEquals ; 
 
 + import java . io . File ; 
 + import java . io . IOException ; 
 + 
 import org . apache . commons . lang3 . ArrayUtils ; 
 import org . junit . Test ; 
 
 @ @ - 31 , 6 + 34 , 11 @ @ import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; 
 import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; 
 
 public class RegexpCheckTest extends BaseCheckTestSupport { 
 + @ Override 
 + protected String getPath ( String filename ) throws IOException { 
 + return super . getPath ( " checks " + File . separator 
 + + " regexp " + File . separator + filename ) ; 
 + } 
 
 @ Test 
 public void testGetRequiredTokens ( ) { 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpMultilineCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpMultilineCheckTest . java 
 index b088442 . . 093ff3f 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpMultilineCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpMultilineCheckTest . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . RE 
 import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . STACKOVERFLOW ; 
 
 import java . io . File ; 
 + import java . io . IOException ; 
 
 import org . apache . commons . lang3 . ArrayUtils ; 
 import org . junit . Before ; 
 @ @ - 47 , 6 + 48 , 12 @ @ public class RegexpMultilineCheckTest extends BaseFileSetCheckTestSupport { 
 checkConfig = createCheckConfig ( RegexpMultilineCheck . class ) ; 
 } 
 
 + @ Override 
 + protected String getPath ( String filename ) throws IOException { 
 + return super . getPath ( " checks " + File . separator 
 + + " regexp " + File . separator + filename ) ; 
 + } 
 + 
 @ Test 
 public void testIt ( ) throws Exception { 
 final String illegal = " System \ \ . ( out ) | ( err ) \ \ . print ( ln ) ? \ \ ( " ; 
 @ @ - 196 , 5 + 203 , 4 @ @ public class RegexpMultilineCheckTest extends BaseFileSetCheckTestSupport { 
 final String [ ] expected = ArrayUtils . EMPTY _ STRING _ ARRAY ; 
 verify ( checkConfig , getPath ( " InputSemantic . java " ) , expected ) ; 
 } 
 - 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineCheckTest . java 
 index e60bfec . . 6e2f9ac 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineCheckTest . java 
 @ @ - 22 , 6 + 22 , 9 @ @ package com . puppycrawl . tools . checkstyle . checks . regexp ; 
 import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP _ EXCEEDED ; 
 import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP _ MINIMUM ; 
 
 + import java . io . File ; 
 + import java . io . IOException ; 
 + 
 import org . apache . commons . lang3 . ArrayUtils ; 
 import org . junit . Before ; 
 import org . junit . Test ; 
 @ @ - 37 , 6 + 40 , 12 @ @ public class RegexpSinglelineCheckTest extends BaseFileSetCheckTestSupport { 
 checkConfig = createCheckConfig ( RegexpSinglelineCheck . class ) ; 
 } 
 
 + @ Override 
 + protected String getPath ( String filename ) throws IOException { 
 + return super . getPath ( " checks " + File . separator 
 + + " regexp " + File . separator + filename ) ; 
 + } 
 + 
 @ Test 
 public void testIt ( ) throws Exception { 
 final String illegal = " System \ \ . ( out ) | ( err ) \ \ . print ( ln ) ? \ \ ( " ; 
 @ @ - 106 , 5 + 115 , 4 @ @ public class RegexpSinglelineCheckTest extends BaseFileSetCheckTestSupport { 
 
 verify ( checkConfig , getPath ( " InputSemantic . java " ) , expected ) ; 
 } 
 - 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineJavaCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineJavaCheckTest . java 
 index f10ddaf . . e9a6fac 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineJavaCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / regexp / RegexpSinglelineJavaCheckTest . java 
 @ @ - 23 , 6 + 23 , 9 @ @ import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . RE 
 import static com . puppycrawl . tools . checkstyle . checks . regexp . MultilineDetector . REGEXP _ MINIMUM ; 
 import static org . junit . Assert . assertArrayEquals ; 
 
 + import java . io . File ; 
 + import java . io . IOException ; 
 + 
 import org . apache . commons . lang3 . ArrayUtils ; 
 import org . junit . Before ; 
 import org . junit . Test ; 
 @ @ - 38 , 6 + 41 , 12 @ @ public class RegexpSinglelineJavaCheckTest extends BaseCheckTestSupport { 
 checkConfig = createCheckConfig ( RegexpSinglelineJavaCheck . class ) ; 
 } 
 
 + @ Override 
 + protected String getPath ( String filename ) throws IOException { 
 + return super . getPath ( " checks " + File . separator 
 + + " regexp " + File . separator + filename ) ; 
 + } 
 + 
 @ Test 
 public void testGetRequiredTokens ( ) { 
 RegexpSinglelineJavaCheck checkObj = new RegexpSinglelineJavaCheck ( ) ; 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / InputStartingWithEmptyLine . java b / src / test / resources / com / puppycrawl / tools / checkstyle / InputStartingWithEmptyLine . java 
 deleted file mode 100644 
 index 86c4296 . . 0000000 
 - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / InputStartingWithEmptyLine . java 
 + + + / dev / null 
 @ @ - 1 , 2 + 0 , 0 @ @ 
 - 
 - package com . puppycrawl . tools . checkstyle ; 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputSemantic . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputSemantic . java 
 new file mode 100644 
 index 0000000 . . fd13419 
 - - - / dev / null 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputSemantic . java 
 @ @ - 0 , 0 + 1 , 222 @ @ 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / Test case file for checkstyle . 
 + / / Created : 2001 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + package com . puppycrawl . tools . checkstyle . checks . regexp ; 
 + 
 + import java . io . * ; / / star import for instantiation tests 
 + import java . awt . Dimension ; / / explicit import for instantiation tests 
 + import java . awt . Color ; 
 + 
 + / * * 
 + * Test case for detecting simple semantic errors . 
 + * @ author Lars K ü hne 
 + * * / 
 + class InputSemantic 
 + { 
 + / * Boolean instantiation in a static initializer * / 
 + static { 
 + Boolean x = new Boolean ( true ) ; 
 + } 
 + 
 + / * Boolean instantiation in a non - static initializer * / 
 + { 
 + Boolean x = new Boolean ( true ) ; 
 + Boolean [ ] y = new Boolean [ ] { Boolean . TRUE , Boolean . FALSE } ; 
 + } 
 + 
 + / * * fully qualified Boolean instantiation in a method . * * / 
 + Boolean getBoolean ( ) 
 + { 
 + return new java . lang . Boolean ( true ) ; 
 + } 
 + 
 + void otherInstantiations ( ) 
 + { 
 + / / instantiation of classes in the same package 
 + Object o1 = new InputBraces ( ) ; 
 + Object o2 = new InputModifier ( ) ; 
 + / / classes in another package with . * import 
 + ByteArrayOutputStream s = new ByteArrayOutputStream ( ) ; 
 + File f = new File ( " / tmp " ) ; 
 + / / classes in another package with explicit import 
 + Dimension dim = new Dimension ( ) ; 
 + Color col = new Color ( 0 , 0 , 0 ) ; 
 + } 
 + 
 + void exHandlerTest ( ) 
 + { 
 + try { 
 + ; / / do stuff and don ' t handle exceptions in some cases 
 + } 
 + catch ( IllegalStateException emptyCatchIsAlwaysAnError ) { 
 + } 
 + catch ( NullPointerException ex ) { 
 + / / can never happen , but only commentig this is currently an error 
 + / / Possible future enhancement : allowEmptyCatch = " commented " 
 + } 
 + catch ( ArrayIndexOutOfBoundsException ex ) { 
 + ; 
 + / / can never happen , semicolon makes checkstyle happy 
 + / / this is a workaround for above problem 
 + } 
 + catch ( NegativeArraySizeException ex ) { 
 + { 
 + } 
 + / / can never happen , empty compound statement is another workaround 
 + } 
 + catch ( UnsupportedOperationException handledException ) { 
 + System . out . println ( handledException . getMessage ( ) ) ; 
 + } 
 + catch ( SecurityException ex ) { / * hello * / } 
 + catch ( StringIndexOutOfBoundsException ex ) { } 
 + catch ( IllegalArgumentException ex ) { } 
 + 
 + try { 
 + } 
 + finally { 
 + } 
 + try { 
 + / / something 
 + } 
 + finally { 
 + / / something 
 + } 
 + try { 
 + ; / / something 
 + } 
 + finally { 
 + ; / / statement 
 + } 
 + } 
 + 
 + / * * test * * / 
 + private static final long IGNORE = 666l + 666L ; 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + 
 + public class EqualsVsHashCode1 
 + { 
 + public boolean equals ( int a ) / / wrong arg type , don ' t flag 
 + { 
 + return a = = 1 ; 
 + } 
 + } 
 + 
 + public class EqualsVsHashCode2 
 + { 
 + public boolean equals ( String a ) / / flag 
 + { 
 + return true ; 
 + } 
 + } 
 + 
 + public class EqualsVsHashCode3 
 + { 
 + public boolean equals ( Object a ) / / don ' t flag 
 + { 
 + return true ; 
 + } 
 + 
 + public int hashCode ( ) 
 + { 
 + return 0 ; 
 + } 
 + } 
 + 
 + public class EqualsVsHashCode4 
 + { 
 + / / in anon inner class 
 + ByteArrayOutputStream bos1 = new ByteArrayOutputStream ( ) 
 + { 
 + public boolean equals ( Object a ) / / don ' t flag 
 + { 
 + return true ; 
 + } 
 + 
 + public int hashCode ( ) 
 + { 
 + return 0 ; 
 + } 
 + } ; 
 + 
 + ByteArrayOutputStream bos2 = new ByteArrayOutputStream ( ) 
 + { 
 + public boolean equals ( Object a ) / / flag 
 + { 
 + return true ; 
 + } 
 + } ; 
 + } 
 + 
 + public void triggerEmptyBlockWithoutBlock ( ) 
 + { 
 + / / an if statement without a block to increase test coverage 
 + if ( true ) 
 + return ; 
 + } 
 + 
 + / / empty instance initializer 
 + { 
 + } 
 + 
 + public class EqualsVsHashCode5 
 + { 
 + public < A > boolean equals ( int a ) / / wrong arg type , don ' t flag even with generics 
 + { 
 + return a = = 1 ; 
 + } 
 + } 
 + 
 + public class EqualsVsHashCode6 
 + { 
 + public < A > boolean equals ( Comparable < A > a ) / / flag , weven with generics 
 + { 
 + return true ; 
 + } 
 + } 
 + 
 + private class InputBraces { 
 + 
 + } 
 + 
 + private class InputModifier { 
 + 
 + } 
 + 
 + synchronized void foo ( ) { 
 + synchronized ( this ) { } / / not OK 
 + synchronized ( Class . class ) { / / OK 
 + synchronized ( new Object ( ) ) { 
 + / / not OK if checking statements 
 + } 
 + } 
 + } 
 + 
 + 
 + static { 
 + 
 + int a = 0 ; } 
 + 
 + static { 
 + 
 + } 
 + } 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputStartingWithEmptyLine . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputStartingWithEmptyLine . java 
 new file mode 100644 
 index 0000000 . . 630e139 
 - - - / dev / null 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputStartingWithEmptyLine . java 
 @ @ - 0 , 0 + 1 , 2 @ @ 
 + 
 + package com . puppycrawl . tools . checkstyle . checks . regexp ; 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputTrailingComment . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputTrailingComment . java 
 new file mode 100644 
 index 0000000 . . 9221a8a 
 - - - / dev / null 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / regexp / InputTrailingComment . java 
 @ @ - 0 , 0 + 1 , 30 @ @ 
 + package com . puppycrawl . tools . checkstyle . checks . regexp ; 
 + 
 + public class InputTrailingComment { 
 + int i ; / / don ' t use trailing comments : ) 
 + / / it fine to have comment w / o any statement 
 + / * good c - style comment . * / 
 + int j ; / * bad c - style comment . * / 
 + void method1 ( ) { / * some c - style multi - line 
 + comment * / 
 + Runnable r = ( new Runnable ( ) { 
 + public void run ( ) { 
 + } 
 + } ) ; / * we should allow this * / 
 + } / / we should allow this 
 + / * 
 + Let ' s check multi - line comments . 
 + * / 
 + / * c - style * / / / cpp - style 
 + / * c - style 1 * / / * c - style 2 * / 
 + 
 + void method2 ( long ms / * we should ignore this * / ) { 
 + / * comment before text * / int z ; 
 + / * int y * / int y / * * / ; 
 + } 
 + 
 + / * * 
 + * comment with trailing space 
 + * / 
 + final static public String NAME = " Some Name " ; / / NOI18N 
 + }
