BLEU SCORE: 0.10552670315936319

TEST MSG: Issue # 2271 : Replace negated assertTrue with assertFalse
GENERATED MSG: Issue # 1566 : ReturnCount violation fixed for JavadocStyleCheck

TEST DIFF (one line): diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / api / ScopeTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / api / ScopeTest . java <nl> index c9f36a4 . . d08feff 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / api / ScopeTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / api / ScopeTest . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ <nl> package com . puppycrawl . tools . checkstyle . api ; <nl> <nl> import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> import static org . junit . Assert . assertNotNull ; <nl> import static org . junit . Assert . assertTrue ; <nl> <nl> @ @ - 96 , 7 + 97 , 7 @ @ public class ScopeTest { <nl> assertTrue ( Scope . PROTECTED . isIn ( Scope . PRIVATE ) ) ; <nl> assertTrue ( Scope . PACKAGE . isIn ( Scope . PRIVATE ) ) ; <nl> assertTrue ( Scope . PRIVATE . isIn ( Scope . PRIVATE ) ) ; <nl> - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PRIVATE ) ) ; <nl> + assertFalse ( Scope . ANONINNER . isIn ( Scope . PRIVATE ) ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 105 , 8 + 106 , 8 @ @ public class ScopeTest { <nl> assertTrue ( Scope . PUBLIC . isIn ( Scope . PACKAGE ) ) ; <nl> assertTrue ( Scope . PROTECTED . isIn ( Scope . PACKAGE ) ) ; <nl> assertTrue ( Scope . PACKAGE . isIn ( Scope . PACKAGE ) ) ; <nl> - assertTrue ( ! Scope . PRIVATE . isIn ( Scope . PACKAGE ) ) ; <nl> - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PACKAGE ) ) ; <nl> + assertFalse ( Scope . PRIVATE . isIn ( Scope . PACKAGE ) ) ; <nl> + assertFalse ( Scope . ANONINNER . isIn ( Scope . PACKAGE ) ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 114 , 28 + 115 , 28 @ @ public class ScopeTest { <nl> assertTrue ( Scope . NOTHING . isIn ( Scope . PROTECTED ) ) ; <nl> assertTrue ( Scope . PUBLIC . isIn ( Scope . PROTECTED ) ) ; <nl> assertTrue ( Scope . PROTECTED . isIn ( Scope . PROTECTED ) ) ; <nl> - assertTrue ( ! Scope . PACKAGE . isIn ( Scope . PROTECTED ) ) ; <nl> - assertTrue ( ! Scope . PRIVATE . isIn ( Scope . PROTECTED ) ) ; <nl> - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PROTECTED ) ) ; <nl> + assertFalse ( Scope . PACKAGE . isIn ( Scope . PROTECTED ) ) ; <nl> + assertFalse ( Scope . PRIVATE . isIn ( Scope . PROTECTED ) ) ; <nl> + assertFalse ( Scope . ANONINNER . isIn ( Scope . PROTECTED ) ) ; <nl> } <nl> <nl> @ Test <nl> public void testIsInPublic ( ) { <nl> assertTrue ( Scope . NOTHING . isIn ( Scope . PUBLIC ) ) ; <nl> assertTrue ( Scope . PUBLIC . isIn ( Scope . PUBLIC ) ) ; <nl> - assertTrue ( ! Scope . PROTECTED . isIn ( Scope . PUBLIC ) ) ; <nl> - assertTrue ( ! Scope . PACKAGE . isIn ( Scope . PUBLIC ) ) ; <nl> - assertTrue ( ! Scope . PRIVATE . isIn ( Scope . PUBLIC ) ) ; <nl> - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PUBLIC ) ) ; <nl> + assertFalse ( Scope . PROTECTED . isIn ( Scope . PUBLIC ) ) ; <nl> + assertFalse ( Scope . PACKAGE . isIn ( Scope . PUBLIC ) ) ; <nl> + assertFalse ( Scope . PRIVATE . isIn ( Scope . PUBLIC ) ) ; <nl> + assertFalse ( Scope . ANONINNER . isIn ( Scope . PUBLIC ) ) ; <nl> } <nl> <nl> @ Test <nl> public void testIsInNothing ( ) { <nl> assertTrue ( Scope . NOTHING . isIn ( Scope . NOTHING ) ) ; <nl> - assertTrue ( ! Scope . PUBLIC . isIn ( Scope . NOTHING ) ) ; <nl> - assertTrue ( ! Scope . PROTECTED . isIn ( Scope . NOTHING ) ) ; <nl> - assertTrue ( ! Scope . PACKAGE . isIn ( Scope . NOTHING ) ) ; <nl> - assertTrue ( ! Scope . PRIVATE . isIn ( Scope . NOTHING ) ) ; <nl> - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . NOTHING ) ) ; <nl> + assertFalse ( Scope . PUBLIC . isIn ( Scope . NOTHING ) ) ; <nl> + assertFalse ( Scope . PROTECTED . isIn ( Scope . NOTHING ) ) ; <nl> + assertFalse ( Scope . PACKAGE . isIn ( Scope . NOTHING ) ) ; <nl> + assertFalse ( Scope . PRIVATE . isIn ( Scope . NOTHING ) ) ; <nl> + assertFalse ( Scope . ANONINNER . isIn ( Scope . NOTHING ) ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java <nl> index 874c9e7 . . eeae700 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java <nl> @ @ - 133 , 44 + 133 , 7 @ @ public final class JavadocUtils { <nl> } <nl> / / No block tag , so look for inline validTags <nl> else if ( tagType = = JavadocTagType . ALL | | tagType = = JavadocTagType . INLINE ) { <nl> - / / Match Javadoc text after comment characters <nl> - final Pattern commentPattern = Pattern . compile ( " ^ \ \ s * ( ? : / \ \ * { 2 , } | \ \ * + ) \ \ s * ( . * ) " ) ; <nl> - final Matcher commentMatcher = commentPattern . matcher ( s ) ; <nl> - final String commentContents ; <nl> - <nl> - / / offset including comment characters <nl> - final int commentOffset ; <nl> - <nl> - if ( commentMatcher . find ( ) ) { <nl> - commentContents = commentMatcher . group ( 1 ) ; <nl> - commentOffset = commentMatcher . start ( 1 ) - 1 ; <nl> - } <nl> - else { <nl> - / / No leading asterisks , still valid <nl> - commentContents = s ; <nl> - commentOffset = 0 ; <nl> - } <nl> - final Pattern tagPattern = Pattern . compile ( " . * ? \ \ { @ ( \ \ p { Alpha } + ) \ \ s + ( . * ? ) \ \ } " ) ; <nl> - final Matcher tagMatcher = tagPattern . matcher ( commentContents ) ; <nl> - while ( tagMatcher . find ( ) ) { <nl> - final String tagName = tagMatcher . group ( 1 ) ; <nl> - final String tagValue = tagMatcher . group ( 2 ) . trim ( ) ; <nl> - final int line = cmt . getStartLineNo ( ) + i ; <nl> - int col = commentOffset + tagMatcher . start ( 1 ) - 1 ; <nl> - if ( i = = 0 ) { <nl> - col + = cmt . getStartColNo ( ) ; <nl> - } <nl> - if ( JavadocTagInfo . isValidName ( tagName ) ) { <nl> - tags . add ( new JavadocTag ( line , col , tagName , <nl> - tagValue ) ) ; <nl> - } <nl> - else { <nl> - invalidTags . add ( new InvalidJavadocTag ( line , col , <nl> - tagName ) ) ; <nl> - } <nl> - / / else Error : Unexpected match count for inline Javadoc <nl> - / / tag ! <nl> - } <nl> + lookForInlineTags ( cmt , i , tags , invalidTags ) ; <nl> } <nl> blockTagPattern = Pattern . compile ( " ^ \ \ s * \ \ * * \ \ s * @ ( \ \ p { Alpha } + ) \ \ s " ) ; <nl> } <nl> @ @ - 178 , 6 + 141 , 54 @ @ public final class JavadocUtils { <nl> } <nl> <nl> / * * <nl> + * Looks for inline tags in comment and adds them to the proper tags collection . <nl> + * @ param comment comment text block <nl> + * @ param lineNumber line number in the comment <nl> + * @ param validTags collection of valid tags <nl> + * @ param invalidTags collection of invalid tags <nl> + * / <nl> + private static void lookForInlineTags ( TextBlock comment , int lineNumber , <nl> + final List < JavadocTag > validTags , final List < InvalidJavadocTag > invalidTags ) { <nl> + final String s = comment . getText ( ) [ lineNumber ] ; <nl> + / / Match Javadoc text after comment characters <nl> + final Pattern commentPattern = Pattern . compile ( " ^ \ \ s * ( ? : / \ \ * { 2 , } | \ \ * + ) \ \ s * ( . * ) " ) ; <nl> + final Matcher commentMatcher = commentPattern . matcher ( s ) ; <nl> + final String commentContents ; <nl> + <nl> + / / offset including comment characters <nl> + final int commentOffset ; <nl> + <nl> + if ( commentMatcher . find ( ) ) { <nl> + commentContents = commentMatcher . group ( 1 ) ; <nl> + commentOffset = commentMatcher . start ( 1 ) - 1 ; <nl> + } <nl> + else { <nl> + / / No leading asterisks , still valid <nl> + commentContents = s ; <nl> + commentOffset = 0 ; <nl> + } <nl> + final Pattern tagPattern = Pattern . compile ( " . * ? \ \ { @ ( \ \ p { Alpha } + ) \ \ s + ( . * ? ) \ \ } " ) ; <nl> + final Matcher tagMatcher = tagPattern . matcher ( commentContents ) ; <nl> + while ( tagMatcher . find ( ) ) { <nl> + final String tagName = tagMatcher . group ( 1 ) ; <nl> + final String tagValue = tagMatcher . group ( 2 ) . trim ( ) ; <nl> + final int line = comment . getStartLineNo ( ) + lineNumber ; <nl> + int col = commentOffset + tagMatcher . start ( 1 ) - 1 ; <nl> + if ( lineNumber = = 0 ) { <nl> + col + = comment . getStartColNo ( ) ; <nl> + } <nl> + if ( JavadocTagInfo . isValidName ( tagName ) ) { <nl> + validTags . add ( new JavadocTag ( line , col , tagName , <nl> + tagValue ) ) ; <nl> + } <nl> + else { <nl> + invalidTags . add ( new InvalidJavadocTag ( line , col , <nl> + tagName ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> * The type of Javadoc tag we want returned . <nl> * / <nl> public enum JavadocTagType {

TEST DIFF:
diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / api / ScopeTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / api / ScopeTest . java 
 index c9f36a4 . . d08feff 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / api / ScopeTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / api / ScopeTest . java 
 @ @ - 20 , 6 + 20 , 7 @ @ 
 package com . puppycrawl . tools . checkstyle . api ; 
 
 import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 import static org . junit . Assert . assertNotNull ; 
 import static org . junit . Assert . assertTrue ; 
 
 @ @ - 96 , 7 + 97 , 7 @ @ public class ScopeTest { 
 assertTrue ( Scope . PROTECTED . isIn ( Scope . PRIVATE ) ) ; 
 assertTrue ( Scope . PACKAGE . isIn ( Scope . PRIVATE ) ) ; 
 assertTrue ( Scope . PRIVATE . isIn ( Scope . PRIVATE ) ) ; 
 - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PRIVATE ) ) ; 
 + assertFalse ( Scope . ANONINNER . isIn ( Scope . PRIVATE ) ) ; 
 } 
 
 @ Test 
 @ @ - 105 , 8 + 106 , 8 @ @ public class ScopeTest { 
 assertTrue ( Scope . PUBLIC . isIn ( Scope . PACKAGE ) ) ; 
 assertTrue ( Scope . PROTECTED . isIn ( Scope . PACKAGE ) ) ; 
 assertTrue ( Scope . PACKAGE . isIn ( Scope . PACKAGE ) ) ; 
 - assertTrue ( ! Scope . PRIVATE . isIn ( Scope . PACKAGE ) ) ; 
 - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PACKAGE ) ) ; 
 + assertFalse ( Scope . PRIVATE . isIn ( Scope . PACKAGE ) ) ; 
 + assertFalse ( Scope . ANONINNER . isIn ( Scope . PACKAGE ) ) ; 
 } 
 
 @ Test 
 @ @ - 114 , 28 + 115 , 28 @ @ public class ScopeTest { 
 assertTrue ( Scope . NOTHING . isIn ( Scope . PROTECTED ) ) ; 
 assertTrue ( Scope . PUBLIC . isIn ( Scope . PROTECTED ) ) ; 
 assertTrue ( Scope . PROTECTED . isIn ( Scope . PROTECTED ) ) ; 
 - assertTrue ( ! Scope . PACKAGE . isIn ( Scope . PROTECTED ) ) ; 
 - assertTrue ( ! Scope . PRIVATE . isIn ( Scope . PROTECTED ) ) ; 
 - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PROTECTED ) ) ; 
 + assertFalse ( Scope . PACKAGE . isIn ( Scope . PROTECTED ) ) ; 
 + assertFalse ( Scope . PRIVATE . isIn ( Scope . PROTECTED ) ) ; 
 + assertFalse ( Scope . ANONINNER . isIn ( Scope . PROTECTED ) ) ; 
 } 
 
 @ Test 
 public void testIsInPublic ( ) { 
 assertTrue ( Scope . NOTHING . isIn ( Scope . PUBLIC ) ) ; 
 assertTrue ( Scope . PUBLIC . isIn ( Scope . PUBLIC ) ) ; 
 - assertTrue ( ! Scope . PROTECTED . isIn ( Scope . PUBLIC ) ) ; 
 - assertTrue ( ! Scope . PACKAGE . isIn ( Scope . PUBLIC ) ) ; 
 - assertTrue ( ! Scope . PRIVATE . isIn ( Scope . PUBLIC ) ) ; 
 - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . PUBLIC ) ) ; 
 + assertFalse ( Scope . PROTECTED . isIn ( Scope . PUBLIC ) ) ; 
 + assertFalse ( Scope . PACKAGE . isIn ( Scope . PUBLIC ) ) ; 
 + assertFalse ( Scope . PRIVATE . isIn ( Scope . PUBLIC ) ) ; 
 + assertFalse ( Scope . ANONINNER . isIn ( Scope . PUBLIC ) ) ; 
 } 
 
 @ Test 
 public void testIsInNothing ( ) { 
 assertTrue ( Scope . NOTHING . isIn ( Scope . NOTHING ) ) ; 
 - assertTrue ( ! Scope . PUBLIC . isIn ( Scope . NOTHING ) ) ; 
 - assertTrue ( ! Scope . PROTECTED . isIn ( Scope . NOTHING ) ) ; 
 - assertTrue ( ! Scope . PACKAGE . isIn ( Scope . NOTHING ) ) ; 
 - assertTrue ( ! Scope . PRIVATE . isIn ( Scope . NOTHING ) ) ; 
 - assertTrue ( ! Scope . ANONINNER . isIn ( Scope . NOTHING ) ) ; 
 + assertFalse ( Scope . PUBLIC . isIn ( Scope . NOTHING ) ) ; 
 + assertFalse ( Scope . PROTECTED . isIn ( Scope . NOTHING ) ) ; 
 + assertFalse ( Scope . PACKAGE . isIn ( Scope . NOTHING ) ) ; 
 + assertFalse ( Scope . PRIVATE . isIn ( Scope . NOTHING ) ) ; 
 + assertFalse ( Scope . ANONINNER . isIn ( Scope . NOTHING ) ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java 
 index 874c9e7 . . eeae700 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / JavadocUtils . java 
 @ @ - 133 , 44 + 133 , 7 @ @ public final class JavadocUtils { 
 } 
 / / No block tag , so look for inline validTags 
 else if ( tagType = = JavadocTagType . ALL | | tagType = = JavadocTagType . INLINE ) { 
 - / / Match Javadoc text after comment characters 
 - final Pattern commentPattern = Pattern . compile ( " ^ \ \ s * ( ? : / \ \ * { 2 , } | \ \ * + ) \ \ s * ( . * ) " ) ; 
 - final Matcher commentMatcher = commentPattern . matcher ( s ) ; 
 - final String commentContents ; 
 - 
 - / / offset including comment characters 
 - final int commentOffset ; 
 - 
 - if ( commentMatcher . find ( ) ) { 
 - commentContents = commentMatcher . group ( 1 ) ; 
 - commentOffset = commentMatcher . start ( 1 ) - 1 ; 
 - } 
 - else { 
 - / / No leading asterisks , still valid 
 - commentContents = s ; 
 - commentOffset = 0 ; 
 - } 
 - final Pattern tagPattern = Pattern . compile ( " . * ? \ \ { @ ( \ \ p { Alpha } + ) \ \ s + ( . * ? ) \ \ } " ) ; 
 - final Matcher tagMatcher = tagPattern . matcher ( commentContents ) ; 
 - while ( tagMatcher . find ( ) ) { 
 - final String tagName = tagMatcher . group ( 1 ) ; 
 - final String tagValue = tagMatcher . group ( 2 ) . trim ( ) ; 
 - final int line = cmt . getStartLineNo ( ) + i ; 
 - int col = commentOffset + tagMatcher . start ( 1 ) - 1 ; 
 - if ( i = = 0 ) { 
 - col + = cmt . getStartColNo ( ) ; 
 - } 
 - if ( JavadocTagInfo . isValidName ( tagName ) ) { 
 - tags . add ( new JavadocTag ( line , col , tagName , 
 - tagValue ) ) ; 
 - } 
 - else { 
 - invalidTags . add ( new InvalidJavadocTag ( line , col , 
 - tagName ) ) ; 
 - } 
 - / / else Error : Unexpected match count for inline Javadoc 
 - / / tag ! 
 - } 
 + lookForInlineTags ( cmt , i , tags , invalidTags ) ; 
 } 
 blockTagPattern = Pattern . compile ( " ^ \ \ s * \ \ * * \ \ s * @ ( \ \ p { Alpha } + ) \ \ s " ) ; 
 } 
 @ @ - 178 , 6 + 141 , 54 @ @ public final class JavadocUtils { 
 } 
 
 / * * 
 + * Looks for inline tags in comment and adds them to the proper tags collection . 
 + * @ param comment comment text block 
 + * @ param lineNumber line number in the comment 
 + * @ param validTags collection of valid tags 
 + * @ param invalidTags collection of invalid tags 
 + * / 
 + private static void lookForInlineTags ( TextBlock comment , int lineNumber , 
 + final List < JavadocTag > validTags , final List < InvalidJavadocTag > invalidTags ) { 
 + final String s = comment . getText ( ) [ lineNumber ] ; 
 + / / Match Javadoc text after comment characters 
 + final Pattern commentPattern = Pattern . compile ( " ^ \ \ s * ( ? : / \ \ * { 2 , } | \ \ * + ) \ \ s * ( . * ) " ) ; 
 + final Matcher commentMatcher = commentPattern . matcher ( s ) ; 
 + final String commentContents ; 
 + 
 + / / offset including comment characters 
 + final int commentOffset ; 
 + 
 + if ( commentMatcher . find ( ) ) { 
 + commentContents = commentMatcher . group ( 1 ) ; 
 + commentOffset = commentMatcher . start ( 1 ) - 1 ; 
 + } 
 + else { 
 + / / No leading asterisks , still valid 
 + commentContents = s ; 
 + commentOffset = 0 ; 
 + } 
 + final Pattern tagPattern = Pattern . compile ( " . * ? \ \ { @ ( \ \ p { Alpha } + ) \ \ s + ( . * ? ) \ \ } " ) ; 
 + final Matcher tagMatcher = tagPattern . matcher ( commentContents ) ; 
 + while ( tagMatcher . find ( ) ) { 
 + final String tagName = tagMatcher . group ( 1 ) ; 
 + final String tagValue = tagMatcher . group ( 2 ) . trim ( ) ; 
 + final int line = comment . getStartLineNo ( ) + lineNumber ; 
 + int col = commentOffset + tagMatcher . start ( 1 ) - 1 ; 
 + if ( lineNumber = = 0 ) { 
 + col + = comment . getStartColNo ( ) ; 
 + } 
 + if ( JavadocTagInfo . isValidName ( tagName ) ) { 
 + validTags . add ( new JavadocTag ( line , col , tagName , 
 + tagValue ) ) ; 
 + } 
 + else { 
 + invalidTags . add ( new InvalidJavadocTag ( line , col , 
 + tagName ) ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 * The type of Javadoc tag we want returned . 
 * / 
 public enum JavadocTagType {
