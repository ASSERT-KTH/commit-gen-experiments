BLEU SCORE: 0.022325174503683518

TEST MSG: Issue # 2575 : Create directory structure needed to store cache file
GENERATED MSG: UT coverage 100 % for com . puppycrawl . tools . checkstyle . Utils . # 1294

TEST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / PropertyCacheFile . java b / src / main / java / com / puppycrawl / tools / checkstyle / PropertyCacheFile . java <nl> index 824b281 . . 5c4febb 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / PropertyCacheFile . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / PropertyCacheFile . java <nl> @ @ - 27 , 6 + 27 , 11 @ @ import java . io . IOException ; <nl> import java . io . ObjectOutputStream ; <nl> import java . io . OutputStream ; <nl> import java . io . Serializable ; <nl> + import java . nio . file . AccessDeniedException ; <nl> + import java . nio . file . Files ; <nl> + import java . nio . file . InvalidPathException ; <nl> + import java . nio . file . Path ; <nl> + import java . nio . file . Paths ; <nl> import java . security . MessageDigest ; <nl> import java . security . NoSuchAlgorithmException ; <nl> import java . util . Properties ; <nl> @ @ - 130 , 6 + 135 , 15 @ @ final class PropertyCacheFile { <nl> * @ throws IOException when there is a problems with file save <nl> * / <nl> void persist ( ) throws IOException { <nl> + try { <nl> + final Path directory = Paths . get ( fileName ) . getParent ( ) ; <nl> + if ( directory ! = null ) { <nl> + Files . createDirectories ( directory ) ; <nl> + } <nl> + } <nl> + catch ( InvalidPathException | AccessDeniedException ex ) { <nl> + throw new IllegalStateException ( ex . getMessage ( ) , ex ) ; <nl> + } <nl> FileOutputStream out = null ; <nl> try { <nl> out = new FileOutputStream ( fileName ) ; <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / PropertyCacheFileTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / PropertyCacheFileTest . java <nl> index f4bb66c . . 920a577 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / PropertyCacheFileTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / PropertyCacheFileTest . java <nl> @ @ - 19 , 20 + 19 , 32 @ @ <nl> <nl> package com . puppycrawl . tools . checkstyle ; <nl> <nl> + import static org . hamcrest . CoreMatchers . anyOf ; <nl> + import static org . hamcrest . CoreMatchers . instanceOf ; <nl> + import static org . hamcrest . core . StringEndsWith . endsWith ; <nl> import static org . junit . Assert . assertEquals ; <nl> import static org . junit . Assert . assertFalse ; <nl> + import static org . junit . Assert . assertThat ; <nl> import static org . junit . Assert . assertTrue ; <nl> import static org . junit . Assert . fail ; <nl> + import static org . mockito . Mockito . doThrow ; <nl> + import static org . powermock . api . mockito . PowerMockito . mock ; <nl> import static org . powermock . api . mockito . PowerMockito . mockStatic ; <nl> import static org . powermock . api . mockito . PowerMockito . when ; <nl> <nl> import java . io . File ; <nl> + import java . io . FileNotFoundException ; <nl> import java . io . IOException ; <nl> import java . io . Serializable ; <nl> import java . lang . reflect . InvocationTargetException ; <nl> import java . lang . reflect . Method ; <nl> + import java . nio . file . AccessDeniedException ; <nl> + import java . nio . file . Files ; <nl> + import java . nio . file . InvalidPathException ; <nl> + import java . nio . file . Paths ; <nl> import java . security . MessageDigest ; <nl> import java . security . NoSuchAlgorithmException ; <nl> + import java . util . Locale ; <nl> <nl> import org . junit . Rule ; <nl> import org . junit . Test ; <nl> @ @ - 56 , 8 + 68 , 14 @ @ public class PropertyCacheFileTest { <nl> final File file = temporaryFolder . newFile ( " file . output " ) ; <nl> file . setReadable ( true , false ) ; <nl> file . setWritable ( false , false ) ; <nl> - <nl> - new PropertyCacheFile ( config , file . getAbsolutePath ( ) ) ; <nl> + try { <nl> + new PropertyCacheFile ( config , file . getAbsolutePath ( ) ) . persist ( ) ; <nl> + fail ( " FileNotFoundException is expected , since access to the file was denied ! " ) ; <nl> + } <nl> + catch ( FileNotFoundException ex ) { <nl> + assertThat ( ex . getMessage ( ) , anyOf ( endsWith ( " file . output ( Permission denied ) " ) , <nl> + endsWith ( " file . output ( Access is denied ) " ) ) ) ; <nl> + } <nl> } <nl> <nl> @ Test <nl> @ @ - 89 , 6 + 107 , 95 @ @ public class PropertyCacheFileTest { <nl> } <nl> <nl> @ Test <nl> + public void testCacheDirectoryDoesNotExistAndShouldBeCreated ( ) throws IOException { <nl> + final Configuration config = new DefaultConfiguration ( " myName " ) ; <nl> + final String filePath = String . format ( Locale . getDefault ( ) , " % s % 2 $ stemp % 2 $ scache . temp " , <nl> + temporaryFolder . getRoot ( ) , File . separator ) ; <nl> + final PropertyCacheFile cache = new PropertyCacheFile ( config , filePath ) ; <nl> + try { <nl> + cache . persist ( ) ; <nl> + } <nl> + catch ( FileNotFoundException ex ) { <nl> + fail ( " Exception is not expected . Cache directory should be created successfully ! " ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testPathToCacheContainsOnlyFileName ( ) throws IOException { <nl> + final Configuration config = new DefaultConfiguration ( " myName " ) ; <nl> + final String filePath = " temp . cache " ; <nl> + final PropertyCacheFile cache = new PropertyCacheFile ( config , filePath ) ; <nl> + <nl> + try { <nl> + cache . persist ( ) ; <nl> + } <nl> + catch ( FileNotFoundException ex ) { <nl> + fail ( " Exception is not expected ! " ) ; <nl> + } <nl> + <nl> + if ( Files . exists ( Paths . get ( filePath ) ) ) { <nl> + Files . delete ( Paths . get ( filePath ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testPathToCacheFileContainsIllegalCharacters ( ) throws IOException { <nl> + final Configuration config = new DefaultConfiguration ( " myName " ) ; <nl> + final String filePath = " \ \ \ 0 : FOO \ \ server . properties " ; <nl> + final PropertyCacheFile cache = new PropertyCacheFile ( config , filePath ) ; <nl> + try { <nl> + cache . persist ( ) ; <nl> + fail ( " Exception is expected ! " ) ; <nl> + } <nl> + catch ( IllegalStateException ex ) { <nl> + assertThat ( ex . getCause ( ) , instanceOf ( InvalidPathException . class ) ) ; <nl> + assertThat ( ex . getMessage ( ) , endsWith ( " server . properties " ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testNonAccessibleDirectory ( ) throws Exception { <nl> + <nl> + final PropertyCacheFile cache ; <nl> + final String failMessage ; <nl> + <nl> + / / That works fine on Linux / Unix , but . . . . <nl> + / / It ' s not possible to make a directory / file unreadable in Windows NTFS for owner , that <nl> + / / is why we use mock for testing on OS Windows . <nl> + / / http : / / stackoverflow . com / a / 4354686 <nl> + / / https : / / github . com / google / google - oauth - java - client / issues / 55 # issuecomment - 69403681 <nl> + if ( System . getProperty ( " os . name " ) . toLowerCase ( Locale . ENGLISH ) . startsWith ( " windows " ) ) { <nl> + / / We use mock on Windows just to satisfy coverage rate <nl> + cache = mock ( PropertyCacheFile . class ) ; <nl> + final String mockExceptionMessage = " . . . cache " ; <nl> + final AccessDeniedException mockException = <nl> + new AccessDeniedException ( mockExceptionMessage ) ; <nl> + doThrow ( new IllegalStateException ( mockException ) ) . when ( cache ) . persist ( ) ; <nl> + failMessage = " AccessDeniedException is expected since we use the mock object . " ; <nl> + <nl> + } <nl> + else { <nl> + final Configuration config = new DefaultConfiguration ( " myName " ) ; <nl> + final File directory = temporaryFolder . newFolder ( " directory " ) ; <nl> + directory . setReadable ( true , false ) ; <nl> + directory . setWritable ( false , false ) ; <nl> + final String filePath = String . format ( Locale . getDefault ( ) , " % s % 2 $ sscache % 2 $ stemp . cache " , <nl> + directory . getAbsolutePath ( ) , File . separator ) ; <nl> + cache = new PropertyCacheFile ( config , filePath ) ; <nl> + failMessage = " AccessDeniedException is expected since directory is readonly . " ; <nl> + } <nl> + <nl> + try { <nl> + cache . persist ( ) ; <nl> + fail ( failMessage ) ; <nl> + } <nl> + catch ( IllegalStateException ex ) { <nl> + assertTrue ( ex . getCause ( ) instanceof AccessDeniedException ) ; <nl> + assertThat ( ex . getMessage ( ) , endsWith ( " cache " ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> @ SuppressWarnings ( " unchecked " ) <nl> public void testExceptionNoSuchAlgorithmException ( ) throws Exception { <nl> <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / TreeWalkerTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / TreeWalkerTest . java <nl> index 0b69994 . . 2e1f958 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / TreeWalkerTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / TreeWalkerTest . java <nl> @ @ - 19 , 6 + 19 , 9 @ @ <nl> <nl> package com . puppycrawl . tools . checkstyle ; <nl> <nl> + import static org . hamcrest . CoreMatchers . anyOf ; <nl> + import static org . hamcrest . CoreMatchers . instanceOf ; <nl> + import static org . junit . Assert . assertThat ; <nl> import static org . junit . Assert . assertTrue ; <nl> import static org . junit . Assert . fail ; <nl> <nl> @ @ - 29 , 12 + 32 , 14 @ @ import java . io . IOException ; <nl> import java . io . OutputStreamWriter ; <nl> import java . io . Writer ; <nl> import java . nio . charset . StandardCharsets ; <nl> + import java . nio . file . InvalidPathException ; <nl> import java . util . ArrayList ; <nl> import java . util . HashSet ; <nl> import java . util . List ; <nl> import java . util . Locale ; <nl> <nl> import org . apache . commons . lang3 . ArrayUtils ; <nl> + import org . junit . Assume ; <nl> import org . junit . Rule ; <nl> import org . junit . Test ; <nl> import org . junit . rules . TemporaryFolder ; <nl> @ @ - 135 , 6 + 140 , 28 @ @ public class TreeWalkerTest extends BaseCheckTestSupport { <nl> <nl> @ Test <nl> public void testDestroyNonExistingCache ( ) throws Exception { <nl> + <nl> + / / We use assumption to satisfy coverage rate on OS Windows , since persist ( ) method of <nl> + / / class PropertyCacheFile does not throw IOException on OS Linux when path to a cache <nl> + / / directory is invalid on OS Windows . <nl> + Assume . assumeTrue ( System . getProperty ( " os . name " ) <nl> + . toLowerCase ( Locale . ENGLISH ) . startsWith ( " windows " ) ) ; <nl> + <nl> + final TreeWalker treeWalker = new TreeWalker ( ) ; <nl> + treeWalker . configure ( new DefaultConfiguration ( " default config " ) ) ; <nl> + final String tempFilePath = temporaryFolder . newFile ( ) . getPath ( ) + " . \ \ \ ' " ; <nl> + treeWalker . setCacheFile ( tempFilePath ) ; <nl> + try { <nl> + treeWalker . destroy ( ) ; <nl> + fail ( " Exception did not happen " ) ; <nl> + } <nl> + catch ( IllegalStateException ex ) { <nl> + assertTrue ( ex . getCause ( ) instanceof IOException ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testDestroyCacheFileWithInvalidPath ( ) throws Exception { <nl> final TreeWalker treeWalker = new TreeWalker ( ) ; <nl> treeWalker . configure ( new DefaultConfiguration ( " default config " ) ) ; <nl> if ( System . getProperty ( " os . name " ) <nl> @ @ - 152 , 7 + 179 , 8 @ @ public class TreeWalkerTest extends BaseCheckTestSupport { <nl> fail ( " Exception did not happen " ) ; <nl> } <nl> catch ( IllegalStateException ex ) { <nl> - assertTrue ( ex . getCause ( ) instanceof IOException ) ; <nl> + assertThat ( ex . getCause ( ) , anyOf ( instanceOf ( IOException . class ) , <nl> + instanceOf ( InvalidPathException . class ) ) ) ; <nl> } <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / pom . xml b / pom . xml <nl> index 39ed7e6 . . 34768b8 100644 <nl> - - - a / pom . xml <nl> + + + b / pom . xml <nl> @ @ - 692 , 7 + 692 , 6 @ @ <nl> < totalBranchRate > 85 < / totalBranchRate > <nl> < totalLineRate > 93 < / totalLineRate > <nl> < regexes > <nl> - < regex > < pattern > . * . checkstyle . AnnotationUtility < / pattern > < branchRate > 60 < / branchRate > < lineRate > 60 < / lineRate > < / regex > <nl> < regex > < pattern > . * . Checker < / pattern > < branchRate > 79 < / branchRate > < lineRate > 84 < / lineRate > < / regex > <nl> < regex > < pattern > . * . ConfigurationLoader < / pattern > < branchRate > 86 < / branchRate > < lineRate > 79 < / lineRate > < / regex > <nl> < regex > < pattern > . * . ConfigurationLoader \ $ . * < / pattern > < branchRate > 65 < / branchRate > < lineRate > 84 < / lineRate > < / regex > <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java b / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java <nl> index 59f5d0a . . 7cf5ca6 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ package com . puppycrawl . tools . checkstyle ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . FullIdent ; <nl> import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> + <nl> import org . apache . commons . lang3 . StringUtils ; <nl> <nl> / * * <nl> @ @ - 30 , 6 + 31 , 12 @ @ import org . apache . commons . lang3 . StringUtils ; <nl> * @ author Travis Schneeberger <nl> * / <nl> public final class AnnotationUtility { <nl> + <nl> + / * * <nl> + * Common message <nl> + * / <nl> + private static final String THE _ AST _ IS _ NULL = " the ast is null " ; <nl> + <nl> / * * <nl> * private utility constructor . <nl> * @ throws UnsupportedOperationException if called <nl> @ @ - 58 , 11 + 65 , 12 @ @ public final class AnnotationUtility { <nl> * @ param ast the current node <nl> * @ param annotation the annotation name to check for <nl> * @ return true if contains the annotation <nl> - * @ throws NullPointerException if the ast or <nl> - * annotation is null <nl> * / <nl> public static boolean containsAnnotation ( final DetailAST ast , <nl> String annotation ) { <nl> + if ( ast = = null ) { <nl> + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; <nl> + } <nl> return AnnotationUtility . getAnnotation ( ast , annotation ) ! = null ; <nl> } <nl> <nl> @ @ - 72 , 9 + 80 , 11 @ @ public final class AnnotationUtility { <nl> * <nl> * @ param ast the current node <nl> * @ return true if contains an annotation <nl> - * @ throws NullPointerException if the ast is null <nl> * / <nl> public static boolean containsAnnotation ( final DetailAST ast ) { <nl> + if ( ast = = null ) { <nl> + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; <nl> + } <nl> final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; <nl> return holder ! = null & & holder . branchContains ( TokenTypes . ANNOTATION ) ; <nl> } <nl> @ @ - 86 , 11 + 96 , 10 @ @ public final class AnnotationUtility { <nl> * <nl> * @ param ast the current node <nl> * @ return the Annotation Holder <nl> - * @ throws NullPointerException if the ast is null <nl> * / <nl> public static DetailAST getAnnotationHolder ( DetailAST ast ) { <nl> if ( ast = = null ) { <nl> - throw new IllegalArgumentException ( " the ast is null " ) ; <nl> + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; <nl> } <nl> <nl> final DetailAST annotationHolder ; <nl> @ @ - 127 , 13 + 136 , 11 @ @ public final class AnnotationUtility { <nl> * @ param ast the current node <nl> * @ param annotation the annotation name to check for <nl> * @ return the AST representing that annotation <nl> - * @ throws NullPointerException if the ast or <nl> - * annotation is null <nl> * / <nl> public static DetailAST getAnnotation ( final DetailAST ast , <nl> String annotation ) { <nl> if ( ast = = null ) { <nl> - throw new IllegalArgumentException ( " the ast is null " ) ; <nl> + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; <nl> } <nl> <nl> if ( annotation = = null ) { <nl> @ @ - 141 , 8 + 148 , 8 @ @ public final class AnnotationUtility { <nl> } <nl> <nl> if ( StringUtils . isBlank ( annotation ) ) { <nl> - throw new IllegalArgumentException ( " the annotation " <nl> - + " is empty or spaces " ) ; <nl> + throw new IllegalArgumentException ( <nl> + " the annotation is empty or spaces " ) ; <nl> } <nl> <nl> final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; <nl> @ @ - 162 , 42 + 169 , 4 @ @ public final class AnnotationUtility { <nl> return null ; <nl> } <nl> <nl> - / * * <nl> - * Checks to see what the passed in AST ( representing <nl> - * an annotation ) is annotating . <nl> - * <nl> - * @ param ast the AST representing an annotation . <nl> - * @ return the AST the annotation is annotating . <nl> - * @ throws NullPointerException if the ast is null <nl> - * @ throws IllegalArgumentException if the ast is not <nl> - * an { @ link TokenTypes # ANNOTATION } <nl> - * / <nl> - public static DetailAST annotatingWhat ( DetailAST ast ) { <nl> - if ( ast = = null ) { <nl> - throw new IllegalArgumentException ( " the ast is null " ) ; <nl> - } <nl> - <nl> - if ( ast . getType ( ) ! = TokenTypes . ANNOTATION ) { <nl> - throw new IllegalArgumentException ( <nl> - " The ast is not an annotation . AST : " + ast ) ; <nl> - } <nl> - <nl> - return ast . getParent ( ) . getParent ( ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Checks to see if the passed in AST ( representing <nl> - * an annotation ) is annotating the passed in type . <nl> - * @ param ast the AST representing an annotation <nl> - * @ param tokenType the passed in type <nl> - * @ return true if the annotation is annotating a type <nl> - * equal to the passed in type <nl> - * @ throws NullPointerException if the ast is null <nl> - * @ throws IllegalArgumentException if the ast is not <nl> - * an { @ link TokenTypes # ANNOTATION } <nl> - * / <nl> - public static boolean isAnnotatingType ( DetailAST ast , int tokenType ) { <nl> - final DetailAST astNode = AnnotationUtility . annotatingWhat ( ast ) ; <nl> - return astNode . getType ( ) = = tokenType ; <nl> - } <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java <nl> new file mode 100644 <nl> index 0000000 . . 311dd7f <nl> - - - / dev / null <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java <nl> @ @ - 0 , 0 + 1 , 140 @ @ <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + / / checkstyle : Checks Java source code for adherence to a set of rules . <nl> + / / Copyright ( C ) 2001 - 2015 the original author or authors . <nl> + / / <nl> + / / This library is free software ; you can redistribute it and / or <nl> + / / modify it under the terms of the GNU Lesser General Public <nl> + / / License as published by the Free Software Foundation ; either <nl> + / / version 2 . 1 of the License , or ( at your option ) any later version . <nl> + / / <nl> + / / This library is distributed in the hope that it will be useful , <nl> + / / but WITHOUT ANY WARRANTY ; without even the implied warranty of <nl> + / / MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU <nl> + / / Lesser General Public License for more details . <nl> + / / <nl> + / / You should have received a copy of the GNU Lesser General Public <nl> + / / License along with this library ; if not , write to the Free Software <nl> + / / Foundation , Inc . , 59 Temple Place , Suite 330 , Boston , MA 02111 - 1307 USA <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + <nl> + package com . puppycrawl . tools . checkstyle ; <nl> + <nl> + import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; <nl> + <nl> + import java . lang . reflect . InvocationTargetException ; <nl> + <nl> + import org . junit . Assert ; <nl> + import org . junit . Test ; <nl> + <nl> + import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> + import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> + <nl> + public class AnnotationUtilityTest { <nl> + <nl> + @ Test <nl> + public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { <nl> + try { <nl> + assertUtilsClassHasPrivateConstructor ( AnnotationUtility . class ) ; <nl> + } <nl> + catch ( InvocationTargetException ex ) { <nl> + Assert . assertTrue ( " do not instantiate . " . equals ( ex . getCause ( ) . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationNull ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . containsAnnotation ( null ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationNull2 ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . containsAnnotation ( null , " " ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationFalse ( ) throws ReflectiveOperationException { <nl> + DetailAST ast = new DetailAST ( ) ; <nl> + ast . setType ( 1 ) ; <nl> + Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationFalse2 ( ) throws ReflectiveOperationException { <nl> + DetailAST ast = new DetailAST ( ) ; <nl> + ast . setType ( 1 ) ; <nl> + DetailAST ast2 = new DetailAST ( ) ; <nl> + ast2 . setType ( TokenTypes . MODIFIERS ) ; <nl> + ast . addChild ( ast2 ) ; <nl> + Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testContainsAnnotationTrue ( ) throws ReflectiveOperationException { <nl> + DetailAST ast = new DetailAST ( ) ; <nl> + ast . setType ( 1 ) ; <nl> + DetailAST ast2 = new DetailAST ( ) ; <nl> + ast2 . setType ( TokenTypes . MODIFIERS ) ; <nl> + ast . addChild ( ast2 ) ; <nl> + DetailAST ast3 = new DetailAST ( ) ; <nl> + ast3 . setType ( TokenTypes . ANNOTATION ) ; <nl> + ast2 . addChild ( ast3 ) ; <nl> + Assert . assertTrue ( AnnotationUtility . containsAnnotation ( ast ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAnnotationHolderNull ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . getAnnotationHolder ( null ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testAnnotationNull ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . getAnnotation ( null , null ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testAnnotationNull2 ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . getAnnotation ( new DetailAST ( ) , null ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the annotation is null " . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testAnnotationEmpty ( ) throws ReflectiveOperationException { <nl> + try { <nl> + AnnotationUtility . getAnnotation ( new DetailAST ( ) , " " ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + Assert . assertTrue ( " the annotation is empty or spaces " <nl> + . equals ( ex . getMessage ( ) ) ) ; <nl> + } <nl> + } <nl> + }

TEST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / PropertyCacheFile . java b / src / main / java / com / puppycrawl / tools / checkstyle / PropertyCacheFile . java 
 index 824b281 . . 5c4febb 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / PropertyCacheFile . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / PropertyCacheFile . java 
 @ @ - 27 , 6 + 27 , 11 @ @ import java . io . IOException ; 
 import java . io . ObjectOutputStream ; 
 import java . io . OutputStream ; 
 import java . io . Serializable ; 
 + import java . nio . file . AccessDeniedException ; 
 + import java . nio . file . Files ; 
 + import java . nio . file . InvalidPathException ; 
 + import java . nio . file . Path ; 
 + import java . nio . file . Paths ; 
 import java . security . MessageDigest ; 
 import java . security . NoSuchAlgorithmException ; 
 import java . util . Properties ; 
 @ @ - 130 , 6 + 135 , 15 @ @ final class PropertyCacheFile { 
 * @ throws IOException when there is a problems with file save 
 * / 
 void persist ( ) throws IOException { 
 + try { 
 + final Path directory = Paths . get ( fileName ) . getParent ( ) ; 
 + if ( directory ! = null ) { 
 + Files . createDirectories ( directory ) ; 
 + } 
 + } 
 + catch ( InvalidPathException | AccessDeniedException ex ) { 
 + throw new IllegalStateException ( ex . getMessage ( ) , ex ) ; 
 + } 
 FileOutputStream out = null ; 
 try { 
 out = new FileOutputStream ( fileName ) ; 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / PropertyCacheFileTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / PropertyCacheFileTest . java 
 index f4bb66c . . 920a577 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / PropertyCacheFileTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / PropertyCacheFileTest . java 
 @ @ - 19 , 20 + 19 , 32 @ @ 
 
 package com . puppycrawl . tools . checkstyle ; 
 
 + import static org . hamcrest . CoreMatchers . anyOf ; 
 + import static org . hamcrest . CoreMatchers . instanceOf ; 
 + import static org . hamcrest . core . StringEndsWith . endsWith ; 
 import static org . junit . Assert . assertEquals ; 
 import static org . junit . Assert . assertFalse ; 
 + import static org . junit . Assert . assertThat ; 
 import static org . junit . Assert . assertTrue ; 
 import static org . junit . Assert . fail ; 
 + import static org . mockito . Mockito . doThrow ; 
 + import static org . powermock . api . mockito . PowerMockito . mock ; 
 import static org . powermock . api . mockito . PowerMockito . mockStatic ; 
 import static org . powermock . api . mockito . PowerMockito . when ; 
 
 import java . io . File ; 
 + import java . io . FileNotFoundException ; 
 import java . io . IOException ; 
 import java . io . Serializable ; 
 import java . lang . reflect . InvocationTargetException ; 
 import java . lang . reflect . Method ; 
 + import java . nio . file . AccessDeniedException ; 
 + import java . nio . file . Files ; 
 + import java . nio . file . InvalidPathException ; 
 + import java . nio . file . Paths ; 
 import java . security . MessageDigest ; 
 import java . security . NoSuchAlgorithmException ; 
 + import java . util . Locale ; 
 
 import org . junit . Rule ; 
 import org . junit . Test ; 
 @ @ - 56 , 8 + 68 , 14 @ @ public class PropertyCacheFileTest { 
 final File file = temporaryFolder . newFile ( " file . output " ) ; 
 file . setReadable ( true , false ) ; 
 file . setWritable ( false , false ) ; 
 - 
 - new PropertyCacheFile ( config , file . getAbsolutePath ( ) ) ; 
 + try { 
 + new PropertyCacheFile ( config , file . getAbsolutePath ( ) ) . persist ( ) ; 
 + fail ( " FileNotFoundException is expected , since access to the file was denied ! " ) ; 
 + } 
 + catch ( FileNotFoundException ex ) { 
 + assertThat ( ex . getMessage ( ) , anyOf ( endsWith ( " file . output ( Permission denied ) " ) , 
 + endsWith ( " file . output ( Access is denied ) " ) ) ) ; 
 + } 
 } 
 
 @ Test 
 @ @ - 89 , 6 + 107 , 95 @ @ public class PropertyCacheFileTest { 
 } 
 
 @ Test 
 + public void testCacheDirectoryDoesNotExistAndShouldBeCreated ( ) throws IOException { 
 + final Configuration config = new DefaultConfiguration ( " myName " ) ; 
 + final String filePath = String . format ( Locale . getDefault ( ) , " % s % 2 $ stemp % 2 $ scache . temp " , 
 + temporaryFolder . getRoot ( ) , File . separator ) ; 
 + final PropertyCacheFile cache = new PropertyCacheFile ( config , filePath ) ; 
 + try { 
 + cache . persist ( ) ; 
 + } 
 + catch ( FileNotFoundException ex ) { 
 + fail ( " Exception is not expected . Cache directory should be created successfully ! " ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testPathToCacheContainsOnlyFileName ( ) throws IOException { 
 + final Configuration config = new DefaultConfiguration ( " myName " ) ; 
 + final String filePath = " temp . cache " ; 
 + final PropertyCacheFile cache = new PropertyCacheFile ( config , filePath ) ; 
 + 
 + try { 
 + cache . persist ( ) ; 
 + } 
 + catch ( FileNotFoundException ex ) { 
 + fail ( " Exception is not expected ! " ) ; 
 + } 
 + 
 + if ( Files . exists ( Paths . get ( filePath ) ) ) { 
 + Files . delete ( Paths . get ( filePath ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testPathToCacheFileContainsIllegalCharacters ( ) throws IOException { 
 + final Configuration config = new DefaultConfiguration ( " myName " ) ; 
 + final String filePath = " \ \ \ 0 : FOO \ \ server . properties " ; 
 + final PropertyCacheFile cache = new PropertyCacheFile ( config , filePath ) ; 
 + try { 
 + cache . persist ( ) ; 
 + fail ( " Exception is expected ! " ) ; 
 + } 
 + catch ( IllegalStateException ex ) { 
 + assertThat ( ex . getCause ( ) , instanceOf ( InvalidPathException . class ) ) ; 
 + assertThat ( ex . getMessage ( ) , endsWith ( " server . properties " ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testNonAccessibleDirectory ( ) throws Exception { 
 + 
 + final PropertyCacheFile cache ; 
 + final String failMessage ; 
 + 
 + / / That works fine on Linux / Unix , but . . . . 
 + / / It ' s not possible to make a directory / file unreadable in Windows NTFS for owner , that 
 + / / is why we use mock for testing on OS Windows . 
 + / / http : / / stackoverflow . com / a / 4354686 
 + / / https : / / github . com / google / google - oauth - java - client / issues / 55 # issuecomment - 69403681 
 + if ( System . getProperty ( " os . name " ) . toLowerCase ( Locale . ENGLISH ) . startsWith ( " windows " ) ) { 
 + / / We use mock on Windows just to satisfy coverage rate 
 + cache = mock ( PropertyCacheFile . class ) ; 
 + final String mockExceptionMessage = " . . . cache " ; 
 + final AccessDeniedException mockException = 
 + new AccessDeniedException ( mockExceptionMessage ) ; 
 + doThrow ( new IllegalStateException ( mockException ) ) . when ( cache ) . persist ( ) ; 
 + failMessage = " AccessDeniedException is expected since we use the mock object . " ; 
 + 
 + } 
 + else { 
 + final Configuration config = new DefaultConfiguration ( " myName " ) ; 
 + final File directory = temporaryFolder . newFolder ( " directory " ) ; 
 + directory . setReadable ( true , false ) ; 
 + directory . setWritable ( false , false ) ; 
 + final String filePath = String . format ( Locale . getDefault ( ) , " % s % 2 $ sscache % 2 $ stemp . cache " , 
 + directory . getAbsolutePath ( ) , File . separator ) ; 
 + cache = new PropertyCacheFile ( config , filePath ) ; 
 + failMessage = " AccessDeniedException is expected since directory is readonly . " ; 
 + } 
 + 
 + try { 
 + cache . persist ( ) ; 
 + fail ( failMessage ) ; 
 + } 
 + catch ( IllegalStateException ex ) { 
 + assertTrue ( ex . getCause ( ) instanceof AccessDeniedException ) ; 
 + assertThat ( ex . getMessage ( ) , endsWith ( " cache " ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 @ SuppressWarnings ( " unchecked " ) 
 public void testExceptionNoSuchAlgorithmException ( ) throws Exception { 
 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / TreeWalkerTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / TreeWalkerTest . java 
 index 0b69994 . . 2e1f958 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / TreeWalkerTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / TreeWalkerTest . java 
 @ @ - 19 , 6 + 19 , 9 @ @ 
 
 package com . puppycrawl . tools . checkstyle ; 
 
 + import static org . hamcrest . CoreMatchers . anyOf ; 
 + import static org . hamcrest . CoreMatchers . instanceOf ; 
 + import static org . junit . Assert . assertThat ; 
 import static org . junit . Assert . assertTrue ; 
 import static org . junit . Assert . fail ; 
 
 @ @ - 29 , 12 + 32 , 14 @ @ import java . io . IOException ; 
 import java . io . OutputStreamWriter ; 
 import java . io . Writer ; 
 import java . nio . charset . StandardCharsets ; 
 + import java . nio . file . InvalidPathException ; 
 import java . util . ArrayList ; 
 import java . util . HashSet ; 
 import java . util . List ; 
 import java . util . Locale ; 
 
 import org . apache . commons . lang3 . ArrayUtils ; 
 + import org . junit . Assume ; 
 import org . junit . Rule ; 
 import org . junit . Test ; 
 import org . junit . rules . TemporaryFolder ; 
 @ @ - 135 , 6 + 140 , 28 @ @ public class TreeWalkerTest extends BaseCheckTestSupport { 
 
 @ Test 
 public void testDestroyNonExistingCache ( ) throws Exception { 
 + 
 + / / We use assumption to satisfy coverage rate on OS Windows , since persist ( ) method of 
 + / / class PropertyCacheFile does not throw IOException on OS Linux when path to a cache 
 + / / directory is invalid on OS Windows . 
 + Assume . assumeTrue ( System . getProperty ( " os . name " ) 
 + . toLowerCase ( Locale . ENGLISH ) . startsWith ( " windows " ) ) ; 
 + 
 + final TreeWalker treeWalker = new TreeWalker ( ) ; 
 + treeWalker . configure ( new DefaultConfiguration ( " default config " ) ) ; 
 + final String tempFilePath = temporaryFolder . newFile ( ) . getPath ( ) + " . \ \ \ ' " ; 
 + treeWalker . setCacheFile ( tempFilePath ) ; 
 + try { 
 + treeWalker . destroy ( ) ; 
 + fail ( " Exception did not happen " ) ; 
 + } 
 + catch ( IllegalStateException ex ) { 
 + assertTrue ( ex . getCause ( ) instanceof IOException ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testDestroyCacheFileWithInvalidPath ( ) throws Exception { 
 final TreeWalker treeWalker = new TreeWalker ( ) ; 
 treeWalker . configure ( new DefaultConfiguration ( " default config " ) ) ; 
 if ( System . getProperty ( " os . name " ) 
 @ @ - 152 , 7 + 179 , 8 @ @ public class TreeWalkerTest extends BaseCheckTestSupport { 
 fail ( " Exception did not happen " ) ; 
 } 
 catch ( IllegalStateException ex ) { 
 - assertTrue ( ex . getCause ( ) instanceof IOException ) ; 
 + assertThat ( ex . getCause ( ) , anyOf ( instanceOf ( IOException . class ) , 
 + instanceOf ( InvalidPathException . class ) ) ) ; 
 } 
 } 


NEAREST DIFF:
diff - - git a / pom . xml b / pom . xml 
 index 39ed7e6 . . 34768b8 100644 
 - - - a / pom . xml 
 + + + b / pom . xml 
 @ @ - 692 , 7 + 692 , 6 @ @ 
 < totalBranchRate > 85 < / totalBranchRate > 
 < totalLineRate > 93 < / totalLineRate > 
 < regexes > 
 - < regex > < pattern > . * . checkstyle . AnnotationUtility < / pattern > < branchRate > 60 < / branchRate > < lineRate > 60 < / lineRate > < / regex > 
 < regex > < pattern > . * . Checker < / pattern > < branchRate > 79 < / branchRate > < lineRate > 84 < / lineRate > < / regex > 
 < regex > < pattern > . * . ConfigurationLoader < / pattern > < branchRate > 86 < / branchRate > < lineRate > 79 < / lineRate > < / regex > 
 < regex > < pattern > . * . ConfigurationLoader \ $ . * < / pattern > < branchRate > 65 < / branchRate > < lineRate > 84 < / lineRate > < / regex > 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java b / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java 
 index 59f5d0a . . 7cf5ca6 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / AnnotationUtility . java 
 @ @ - 22 , 6 + 22 , 7 @ @ package com . puppycrawl . tools . checkstyle ; 
 import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . FullIdent ; 
 import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 + 
 import org . apache . commons . lang3 . StringUtils ; 
 
 / * * 
 @ @ - 30 , 6 + 31 , 12 @ @ import org . apache . commons . lang3 . StringUtils ; 
 * @ author Travis Schneeberger 
 * / 
 public final class AnnotationUtility { 
 + 
 + / * * 
 + * Common message 
 + * / 
 + private static final String THE _ AST _ IS _ NULL = " the ast is null " ; 
 + 
 / * * 
 * private utility constructor . 
 * @ throws UnsupportedOperationException if called 
 @ @ - 58 , 11 + 65 , 12 @ @ public final class AnnotationUtility { 
 * @ param ast the current node 
 * @ param annotation the annotation name to check for 
 * @ return true if contains the annotation 
 - * @ throws NullPointerException if the ast or 
 - * annotation is null 
 * / 
 public static boolean containsAnnotation ( final DetailAST ast , 
 String annotation ) { 
 + if ( ast = = null ) { 
 + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; 
 + } 
 return AnnotationUtility . getAnnotation ( ast , annotation ) ! = null ; 
 } 
 
 @ @ - 72 , 9 + 80 , 11 @ @ public final class AnnotationUtility { 
 * 
 * @ param ast the current node 
 * @ return true if contains an annotation 
 - * @ throws NullPointerException if the ast is null 
 * / 
 public static boolean containsAnnotation ( final DetailAST ast ) { 
 + if ( ast = = null ) { 
 + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; 
 + } 
 final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; 
 return holder ! = null & & holder . branchContains ( TokenTypes . ANNOTATION ) ; 
 } 
 @ @ - 86 , 11 + 96 , 10 @ @ public final class AnnotationUtility { 
 * 
 * @ param ast the current node 
 * @ return the Annotation Holder 
 - * @ throws NullPointerException if the ast is null 
 * / 
 public static DetailAST getAnnotationHolder ( DetailAST ast ) { 
 if ( ast = = null ) { 
 - throw new IllegalArgumentException ( " the ast is null " ) ; 
 + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; 
 } 
 
 final DetailAST annotationHolder ; 
 @ @ - 127 , 13 + 136 , 11 @ @ public final class AnnotationUtility { 
 * @ param ast the current node 
 * @ param annotation the annotation name to check for 
 * @ return the AST representing that annotation 
 - * @ throws NullPointerException if the ast or 
 - * annotation is null 
 * / 
 public static DetailAST getAnnotation ( final DetailAST ast , 
 String annotation ) { 
 if ( ast = = null ) { 
 - throw new IllegalArgumentException ( " the ast is null " ) ; 
 + throw new IllegalArgumentException ( THE _ AST _ IS _ NULL ) ; 
 } 
 
 if ( annotation = = null ) { 
 @ @ - 141 , 8 + 148 , 8 @ @ public final class AnnotationUtility { 
 } 
 
 if ( StringUtils . isBlank ( annotation ) ) { 
 - throw new IllegalArgumentException ( " the annotation " 
 - + " is empty or spaces " ) ; 
 + throw new IllegalArgumentException ( 
 + " the annotation is empty or spaces " ) ; 
 } 
 
 final DetailAST holder = AnnotationUtility . getAnnotationHolder ( ast ) ; 
 @ @ - 162 , 42 + 169 , 4 @ @ public final class AnnotationUtility { 
 return null ; 
 } 
 
 - / * * 
 - * Checks to see what the passed in AST ( representing 
 - * an annotation ) is annotating . 
 - * 
 - * @ param ast the AST representing an annotation . 
 - * @ return the AST the annotation is annotating . 
 - * @ throws NullPointerException if the ast is null 
 - * @ throws IllegalArgumentException if the ast is not 
 - * an { @ link TokenTypes # ANNOTATION } 
 - * / 
 - public static DetailAST annotatingWhat ( DetailAST ast ) { 
 - if ( ast = = null ) { 
 - throw new IllegalArgumentException ( " the ast is null " ) ; 
 - } 
 - 
 - if ( ast . getType ( ) ! = TokenTypes . ANNOTATION ) { 
 - throw new IllegalArgumentException ( 
 - " The ast is not an annotation . AST : " + ast ) ; 
 - } 
 - 
 - return ast . getParent ( ) . getParent ( ) ; 
 - } 
 - 
 - / * * 
 - * Checks to see if the passed in AST ( representing 
 - * an annotation ) is annotating the passed in type . 
 - * @ param ast the AST representing an annotation 
 - * @ param tokenType the passed in type 
 - * @ return true if the annotation is annotating a type 
 - * equal to the passed in type 
 - * @ throws NullPointerException if the ast is null 
 - * @ throws IllegalArgumentException if the ast is not 
 - * an { @ link TokenTypes # ANNOTATION } 
 - * / 
 - public static boolean isAnnotatingType ( DetailAST ast , int tokenType ) { 
 - final DetailAST astNode = AnnotationUtility . annotatingWhat ( ast ) ; 
 - return astNode . getType ( ) = = tokenType ; 
 - } 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java 
 new file mode 100644 
 index 0000000 . . 311dd7f 
 - - - / dev / null 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / AnnotationUtilityTest . java 
 @ @ - 0 , 0 + 1 , 140 @ @ 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / checkstyle : Checks Java source code for adherence to a set of rules . 
 + / / Copyright ( C ) 2001 - 2015 the original author or authors . 
 + / / 
 + / / This library is free software ; you can redistribute it and / or 
 + / / modify it under the terms of the GNU Lesser General Public 
 + / / License as published by the Free Software Foundation ; either 
 + / / version 2 . 1 of the License , or ( at your option ) any later version . 
 + / / 
 + / / This library is distributed in the hope that it will be useful , 
 + / / but WITHOUT ANY WARRANTY ; without even the implied warranty of 
 + / / MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the GNU 
 + / / Lesser General Public License for more details . 
 + / / 
 + / / You should have received a copy of the GNU Lesser General Public 
 + / / License along with this library ; if not , write to the Free Software 
 + / / Foundation , Inc . , 59 Temple Place , Suite 330 , Boston , MA 02111 - 1307 USA 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + 
 + package com . puppycrawl . tools . checkstyle ; 
 + 
 + import static com . puppycrawl . tools . checkstyle . TestUtils . assertUtilsClassHasPrivateConstructor ; 
 + 
 + import java . lang . reflect . InvocationTargetException ; 
 + 
 + import org . junit . Assert ; 
 + import org . junit . Test ; 
 + 
 + import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 + import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 + 
 + public class AnnotationUtilityTest { 
 + 
 + @ Test 
 + public void testIsProperUtilsClass ( ) throws ReflectiveOperationException { 
 + try { 
 + assertUtilsClassHasPrivateConstructor ( AnnotationUtility . class ) ; 
 + } 
 + catch ( InvocationTargetException ex ) { 
 + Assert . assertTrue ( " do not instantiate . " . equals ( ex . getCause ( ) . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationNull ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . containsAnnotation ( null ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationNull2 ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . containsAnnotation ( null , " " ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationFalse ( ) throws ReflectiveOperationException { 
 + DetailAST ast = new DetailAST ( ) ; 
 + ast . setType ( 1 ) ; 
 + Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationFalse2 ( ) throws ReflectiveOperationException { 
 + DetailAST ast = new DetailAST ( ) ; 
 + ast . setType ( 1 ) ; 
 + DetailAST ast2 = new DetailAST ( ) ; 
 + ast2 . setType ( TokenTypes . MODIFIERS ) ; 
 + ast . addChild ( ast2 ) ; 
 + Assert . assertFalse ( AnnotationUtility . containsAnnotation ( ast ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testContainsAnnotationTrue ( ) throws ReflectiveOperationException { 
 + DetailAST ast = new DetailAST ( ) ; 
 + ast . setType ( 1 ) ; 
 + DetailAST ast2 = new DetailAST ( ) ; 
 + ast2 . setType ( TokenTypes . MODIFIERS ) ; 
 + ast . addChild ( ast2 ) ; 
 + DetailAST ast3 = new DetailAST ( ) ; 
 + ast3 . setType ( TokenTypes . ANNOTATION ) ; 
 + ast2 . addChild ( ast3 ) ; 
 + Assert . assertTrue ( AnnotationUtility . containsAnnotation ( ast ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testAnnotationHolderNull ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . getAnnotationHolder ( null ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testAnnotationNull ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . getAnnotation ( null , null ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the ast is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testAnnotationNull2 ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . getAnnotation ( new DetailAST ( ) , null ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the annotation is null " . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testAnnotationEmpty ( ) throws ReflectiveOperationException { 
 + try { 
 + AnnotationUtility . getAnnotation ( new DetailAST ( ) , " " ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + Assert . assertTrue ( " the annotation is empty or spaces " 
 + . equals ( ex . getMessage ( ) ) ) ; 
 + } 
 + } 
 + }
