BLEU SCORE: 0.028398387225677897

TEST MSG: Issue # 2822 : Makes FinalClass doesnt recognise as final classes with nested subclasses
GENERATED MSG: Patch from Oleg Sukhodolsky to add FinalCheck to check that classes are

TEST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheck . java <nl> index ff924f4 . . 4c59bb0 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheck . java <nl> @ @ - 21 , 6 + 21 , 10 @ @ package com . puppycrawl . tools . checkstyle . checks . design ; <nl> <nl> import java . util . ArrayDeque ; <nl> import java . util . Deque ; <nl> + import java . util . LinkedList ; <nl> + import java . util . List ; <nl> + <nl> + import org . apache . commons . lang3 . StringUtils ; <nl> <nl> import com . puppycrawl . tools . checkstyle . api . AbstractCheck ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> @ @ - 50 , 8 + 54 , 16 @ @ public class FinalClassCheck <nl> * / <nl> public static final String MSG _ KEY = " final . class " ; <nl> <nl> + / * * <nl> + * Character separate package names in qualified name of java class . <nl> + * / <nl> + public static final String PACKAGE _ SEPARATOR = " . " ; <nl> + <nl> / * * Keeps ClassDesc objects for stack of declared classes . * / <nl> - private final Deque < ClassDesc > classes = new ArrayDeque < > ( ) ; <nl> + private Deque < ClassDesc > classes ; <nl> + <nl> + / * * Full qualified name of the package . * / <nl> + private String packageName ; <nl> <nl> @ Override <nl> public int [ ] getDefaultTokens ( ) { <nl> @ @ - 60 , 7 + 72 , 7 @ @ public class FinalClassCheck <nl> <nl> @ Override <nl> public int [ ] getAcceptableTokens ( ) { <nl> - return new int [ ] { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF } ; <nl> + return new int [ ] { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF , TokenTypes . PACKAGE _ DEF } ; <nl> } <nl> <nl> @ Override <nl> @ @ - 69 , 23 + 81 , 45 @ @ public class FinalClassCheck <nl> } <nl> <nl> @ Override <nl> + public void beginTree ( DetailAST rootAST ) { <nl> + classes = new ArrayDeque < > ( ) ; <nl> + packageName = " " ; <nl> + } <nl> + <nl> + @ Override <nl> public void visitToken ( DetailAST ast ) { <nl> final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> <nl> - if ( ast . getType ( ) = = TokenTypes . CLASS _ DEF ) { <nl> - final boolean isFinal = modifiers . branchContains ( TokenTypes . FINAL ) ; <nl> - final boolean isAbstract = modifiers . branchContains ( TokenTypes . ABSTRACT ) ; <nl> - classes . push ( new ClassDesc ( isFinal , isAbstract ) ) ; <nl> - } <nl> - / / ctors in enums don ' t matter <nl> - else if ( ! ScopeUtils . isInEnumBlock ( ast ) ) { <nl> - final ClassDesc desc = classes . peek ( ) ; <nl> - if ( modifiers . branchContains ( TokenTypes . LITERAL _ PRIVATE ) ) { <nl> - desc . reportPrivateCtor ( ) ; <nl> - } <nl> - else { <nl> - desc . reportNonPrivateCtor ( ) ; <nl> - } <nl> + switch ( ast . getType ( ) ) { <nl> + <nl> + case TokenTypes . PACKAGE _ DEF : <nl> + packageName = extractQualifiedName ( ast ) ; <nl> + break ; <nl> + <nl> + case TokenTypes . CLASS _ DEF : <nl> + registerNestedSubclassToOuterSuperClasses ( ast ) ; <nl> + <nl> + final boolean isFinal = modifiers . branchContains ( TokenTypes . FINAL ) ; <nl> + final boolean isAbstract = modifiers . branchContains ( TokenTypes . ABSTRACT ) ; <nl> + <nl> + final String qualifiedClassName = getQualifiedClassName ( ast ) ; <nl> + classes . push ( new ClassDesc ( qualifiedClassName , isFinal , isAbstract ) ) ; <nl> + break ; <nl> + <nl> + case TokenTypes . CTOR _ DEF : <nl> + if ( ! ScopeUtils . isInEnumBlock ( ast ) ) { <nl> + final ClassDesc desc = classes . peek ( ) ; <nl> + if ( modifiers . branchContains ( TokenTypes . LITERAL _ PRIVATE ) ) { <nl> + desc . registerPrivateCtor ( ) ; <nl> + } <nl> + else { <nl> + desc . registerNonPrivateCtor ( ) ; <nl> + } <nl> + } <nl> + break ; <nl> + <nl> + default : <nl> + throw new IllegalStateException ( ast . toString ( ) ) ; <nl> } <nl> } <nl> <nl> @ @ - 96 , 19 + 130 , 150 @ @ public class FinalClassCheck <nl> } <nl> <nl> final ClassDesc desc = classes . pop ( ) ; <nl> - if ( ! desc . isDeclaredAsFinal ( ) <nl> + if ( desc . isWithPrivateCtor ( ) <nl> & & ! desc . isDeclaredAsAbstract ( ) <nl> - & & desc . isWithPrivateCtor ( ) <nl> + & & ! desc . isDeclaredAsFinal ( ) <nl> & & ! desc . isWithNonPrivateCtor ( ) <nl> + & & ! desc . isWithNestedSubclass ( ) <nl> & & ! ScopeUtils . isInInterfaceOrAnnotationBlock ( ast ) ) { <nl> - final String className = <nl> - ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; <nl> + final String qualifiedName = desc . getQualifiedName ( ) ; <nl> + final String className = getClassNameFromQualifiedName ( qualifiedName ) ; <nl> log ( ast . getLineNo ( ) , MSG _ KEY , className ) ; <nl> } <nl> } <nl> <nl> + / * * <nl> + * Get name of class ( with qualified package if specified ) in extend clause . <nl> + * @ param classExtend extend clause to extract class name <nl> + * @ return super class name <nl> + * / <nl> + private static String extractQualifiedName ( DetailAST classExtend ) { <nl> + final String className ; <nl> + <nl> + if ( classExtend . findFirstToken ( TokenTypes . IDENT ) = = null ) { <nl> + / / Name specified with packages , have to traverse DOT <nl> + final DetailAST firstChild = classExtend . findFirstToken ( TokenTypes . DOT ) ; <nl> + final List < String > qualifiedNameParts = new LinkedList < > ( ) ; <nl> + <nl> + qualifiedNameParts . add ( 0 , firstChild . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ) ; <nl> + DetailAST traverse = firstChild . findFirstToken ( TokenTypes . DOT ) ; <nl> + while ( traverse ! = null ) { <nl> + qualifiedNameParts . add ( 0 , traverse . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ) ; <nl> + traverse = traverse . findFirstToken ( TokenTypes . DOT ) ; <nl> + } <nl> + className = StringUtils . join ( qualifiedNameParts , PACKAGE _ SEPARATOR ) ; <nl> + } <nl> + else { <nl> + className = classExtend . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; <nl> + } <nl> + <nl> + return className ; <nl> + } <nl> + <nl> + / * * <nl> + * Register to outer super classes of given classAst that <nl> + * given classAst is extending them . <nl> + * @ param classAst class which outer super classes will be <nl> + * informed about nesting subclass <nl> + * / <nl> + private void registerNestedSubclassToOuterSuperClasses ( DetailAST classAst ) { <nl> + final String currentAstSuperClassName = getSuperClassName ( classAst ) ; <nl> + if ( currentAstSuperClassName ! = null ) { <nl> + for ( ClassDesc classDesc : classes ) { <nl> + final String classDescQualifiedName = classDesc . getQualifiedName ( ) ; <nl> + if ( doesNameInExtendMatchSuperClassName ( classDescQualifiedName , <nl> + currentAstSuperClassName ) ) { <nl> + classDesc . registerNestedSubclass ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Get qualified class name from given class Ast . <nl> + * @ param classAst class to get qualified class name <nl> + * @ return qualified class name of a class <nl> + * / <nl> + private String getQualifiedClassName ( DetailAST classAst ) { <nl> + final String className = classAst . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; <nl> + String outerClassQualifiedName = null ; <nl> + if ( ! classes . isEmpty ( ) ) { <nl> + outerClassQualifiedName = classes . peek ( ) . getQualifiedName ( ) ; <nl> + } <nl> + return getQualifiedClassName ( packageName , outerClassQualifiedName , className ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Calculate qualified class name ( package + class name ) laying inside given <nl> + * outer class . <nl> + * @ param packageName package name , empty string on default package <nl> + * @ param outerClassQualifiedName qualified name ( package + class ) of outer class , <nl> + * null if doesnt exist <nl> + * @ param className class name <nl> + * @ return qualified class name ( package + class name ) <nl> + * / <nl> + private static String getQualifiedClassName ( String packageName , String outerClassQualifiedName , <nl> + String className ) { <nl> + final String qualifiedClassName ; <nl> + <nl> + if ( outerClassQualifiedName = = null ) { <nl> + if ( packageName . isEmpty ( ) ) { <nl> + qualifiedClassName = className ; <nl> + } <nl> + else { <nl> + qualifiedClassName = packageName + PACKAGE _ SEPARATOR + className ; <nl> + } <nl> + } <nl> + else { <nl> + qualifiedClassName = outerClassQualifiedName + PACKAGE _ SEPARATOR + className ; <nl> + } <nl> + return qualifiedClassName ; <nl> + } <nl> + <nl> + / * * <nl> + * Get super class name of given class . <nl> + * @ param classAst class <nl> + * @ return super class name or null if super class is not specified <nl> + * / <nl> + private String getSuperClassName ( DetailAST classAst ) { <nl> + String superClassName = null ; <nl> + final DetailAST classExtend = classAst . findFirstToken ( TokenTypes . EXTENDS _ CLAUSE ) ; <nl> + if ( classExtend ! = null ) { <nl> + superClassName = extractQualifiedName ( classExtend ) ; <nl> + } <nl> + return superClassName ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks if given super class name in extend clause match super class qualified name . <nl> + * @ param superClassQualifiedName super class quaflieid name ( with package ) <nl> + * @ param superClassInExtendClause name in extend clause <nl> + * @ return true if given super class name in extend clause match super class qualified name , <nl> + * false otherwise <nl> + * / <nl> + private static boolean doesNameInExtendMatchSuperClassName ( String superClassQualifiedName , <nl> + String superClassInExtendClause ) { <nl> + String superClassNormalizedName = superClassQualifiedName ; <nl> + if ( ! superClassInExtendClause . contains ( PACKAGE _ SEPARATOR ) ) { <nl> + superClassNormalizedName = getClassNameFromQualifiedName ( superClassQualifiedName ) ; <nl> + } <nl> + return superClassNormalizedName . equals ( superClassInExtendClause ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get class name from qualified name . <nl> + * @ param qualifiedName qualified class name <nl> + * @ return class name <nl> + * / <nl> + private static String getClassNameFromQualifiedName ( String qualifiedName ) { <nl> + return qualifiedName . substring ( qualifiedName . lastIndexOf ( PACKAGE _ SEPARATOR ) + 1 ) ; <nl> + } <nl> + <nl> / * * Maintains information about class ' ctors . * / <nl> private static final class ClassDesc { <nl> + / * * Qualified class name ( with package ) . * / <nl> + private final String qualifiedName ; <nl> + <nl> / * * Is class declared as final . * / <nl> private final boolean declaredAsFinal ; <nl> <nl> @ @ - 121 , 28 + 286 , 46 @ @ public class FinalClassCheck <nl> / * * Does class have private ctors . * / <nl> private boolean withPrivateCtor ; <nl> <nl> + / * * Does class have nested subclass . * / <nl> + private boolean withNestedSubclass ; <nl> + <nl> / * * <nl> * Create a new ClassDesc instance . <nl> + * @ param qualifiedName qualified class name ( with package ) <nl> * @ param declaredAsFinal indicates if the <nl> * class declared as final <nl> * @ param declaredAsAbstract indicates if the <nl> * class declared as abstract <nl> * / <nl> - ClassDesc ( boolean declaredAsFinal , boolean declaredAsAbstract ) { <nl> + ClassDesc ( String qualifiedName , boolean declaredAsFinal , boolean declaredAsAbstract ) { <nl> + this . qualifiedName = qualifiedName ; <nl> this . declaredAsFinal = declaredAsFinal ; <nl> this . declaredAsAbstract = declaredAsAbstract ; <nl> } <nl> <nl> + / * * <nl> + * Get qualified class name . <nl> + * @ return qualified class name <nl> + * / <nl> + private String getQualifiedName ( ) { <nl> + return qualifiedName ; <nl> + } <nl> + <nl> / * * Adds private ctor . * / <nl> - private void reportPrivateCtor ( ) { <nl> + private void registerPrivateCtor ( ) { <nl> withPrivateCtor = true ; <nl> } <nl> <nl> / * * Adds non - private ctor . * / <nl> - private void reportNonPrivateCtor ( ) { <nl> + private void registerNonPrivateCtor ( ) { <nl> withNonPrivateCtor = true ; <nl> } <nl> <nl> + / * * Adds nested subclass . * / <nl> + private void registerNestedSubclass ( ) { <nl> + withNestedSubclass = true ; <nl> + } <nl> + <nl> / * * <nl> * Does class have private ctors . <nl> * @ return true if class has private ctors <nl> @ @ - 160 , 6 + 343 , 14 @ @ public class FinalClassCheck <nl> } <nl> <nl> / * * <nl> + * Does class have nested subclass . <nl> + * @ return true if class has nested subclass <nl> + * / <nl> + private boolean isWithNestedSubclass ( ) { <nl> + return withNestedSubclass ; <nl> + } <nl> + <nl> + / * * <nl> * Is class declared as final . <nl> * @ return true if class is declared as final <nl> * / <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheckTest . java <nl> index c02785d . . d5d9e46 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheckTest . java <nl> @ @ - 25 , 10 + 25 , 12 @ @ import static org . junit . Assert . assertArrayEquals ; <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> <nl> + import org . junit . Assert ; <nl> import org . junit . Test ; <nl> <nl> import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; <nl> import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; <nl> + import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> <nl> public class FinalClassCheckTest <nl> @ @ - 39 , 10 + 41 , 16 @ @ public class FinalClassCheckTest <nl> + " design " + File . separator + filename ) ; <nl> } <nl> <nl> + @ Override <nl> + protected String getNonCompilablePath ( String filename ) throws IOException { <nl> + return super . getNonCompilablePath ( " checks " + File . separator <nl> + + " design " + File . separator + filename ) ; <nl> + } <nl> + <nl> @ Test <nl> public void testGetRequiredTokens ( ) { <nl> final FinalClassCheck checkObj = new FinalClassCheck ( ) ; <nl> - final int [ ] expected = { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF } ; <nl> + final int [ ] expected = { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF , TokenTypes . PACKAGE _ DEF } ; <nl> assertArrayEquals ( expected , checkObj . getRequiredTokens ( ) ) ; <nl> } <nl> <nl> @ @ - 53 , 15 + 61 , 56 @ @ public class FinalClassCheckTest <nl> final String [ ] expected = { <nl> " 7 : " + getCheckMessage ( MSG _ KEY , " InputFinalClass " ) , <nl> " 15 : " + getCheckMessage ( MSG _ KEY , " test4 " ) , <nl> - " 109 : " + getCheckMessage ( MSG _ KEY , " someinnerClass " ) , <nl> + " 113 : " + getCheckMessage ( MSG _ KEY , " someinnerClass " ) , <nl> } ; <nl> verify ( checkConfig , getPath ( " InputFinalClass . java " ) , expected ) ; <nl> } <nl> <nl> @ Test <nl> + public void testClassWithPrivateCtorAndNestedExtendingSubclass ( ) throws Exception { <nl> + final DefaultConfiguration checkConfig = <nl> + createCheckConfig ( FinalClassCheck . class ) ; <nl> + final String [ ] expected = { <nl> + " 15 : " + getCheckMessage ( MSG _ KEY , " C " ) , <nl> + } ; <nl> + verify ( checkConfig , <nl> + getNonCompilablePath ( " InputClassWithPrivateCtorWithNestedExtendingClass . java " ) , <nl> + expected ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testClassWithPrivateCtorAndNestedExtendingSubclassWithoutPackage ( ) <nl> + throws Exception { <nl> + final DefaultConfiguration checkConfig = <nl> + createCheckConfig ( FinalClassCheck . class ) ; <nl> + final String [ ] expected = { <nl> + " 7 : " + getCheckMessage ( MSG _ KEY , " C " ) , <nl> + } ; <nl> + verify ( checkConfig , <nl> + getNonCompilablePath ( <nl> + " InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage . java " ) , <nl> + expected ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testImproperToken ( ) throws Exception { <nl> + final FinalClassCheck finalClassCheck = new FinalClassCheck ( ) ; <nl> + final DetailAST badAst = new DetailAST ( ) ; <nl> + final int unsupportedTokenByCheck = TokenTypes . EOF ; <nl> + badAst . setType ( unsupportedTokenByCheck ) ; <nl> + try { <nl> + finalClassCheck . visitToken ( badAst ) ; <nl> + Assert . fail ( " IllegalStateException is expected " ) ; <nl> + } <nl> + catch ( IllegalStateException ex ) { <nl> + / / it is OK <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> public void testGetAcceptableTokens ( ) { <nl> final FinalClassCheck obj = new FinalClassCheck ( ) ; <nl> - final int [ ] expected = { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF } ; <nl> + final int [ ] expected = { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF , TokenTypes . PACKAGE _ DEF } ; <nl> assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; <nl> } <nl> } <nl> diff - - git a / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClass . java b / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClass . java <nl> new file mode 100644 <nl> index 0000000 . . bd84a4f <nl> - - - / dev / null <nl> + + + b / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClass . java <nl> @ @ - 0 , 0 + 1 , 19 @ @ <nl> + package com . puppycrawl . tools . checkstyle . checks . design ; <nl> + <nl> + public class InputClassWithPrivateCtorWithNestedExtendingClass { <nl> + class A { <nl> + private A ( ) { } <nl> + private class ExtendA extends A { } <nl> + } <nl> + <nl> + class B { <nl> + private B ( ) { } <nl> + private class ExtendB extends <nl> + com . puppycrawl . tools . checkstyle . checks . design . InputClassWithPrivateCtorWithNestedExtendingClass . B { } <nl> + } <nl> + <nl> + class C { <nl> + private C ( ) { } <nl> + private class ExtendC extends com . nonexistent . packages . C { } <nl> + } <nl> + } <nl> diff - - git a / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage . java b / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage . java <nl> new file mode 100644 <nl> index 0000000 . . f8bbe9b <nl> - - - / dev / null <nl> + + + b / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage . java <nl> @ @ - 0 , 0 + 1 , 11 @ @ <nl> + public class InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage { <nl> + class A { <nl> + private A ( ) { } <nl> + private class ExtendA extends A { } <nl> + } <nl> + <nl> + class C { <nl> + private C ( ) { } <nl> + private class ExtendC extends com . nonexistent . packages . C { } <nl> + } <nl> + } <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputFinalClass . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputFinalClass . java <nl> index 96cbc79 . . 5db58d8 100644 <nl> - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputFinalClass . java <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputFinalClass . java <nl> @ @ - 29 , 6 + 29 , 10 @ @ class test6 <nl> public test6 ( ) { } <nl> } <nl> <nl> + final class test7 { <nl> + private test7 ( ) { } <nl> + } <nl> + <nl> / / Typesafe enum with operation <nl> / / abstract classes cannot be final , see bug # 837012 <nl> abstract class Operation
NEAREST DIFF (one line): diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / api / TokenTypes . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / api / TokenTypes . java <nl> index 53e059b . . b442d38 100644 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / api / TokenTypes . java <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / api / TokenTypes . java <nl> @ @ - 178 , 181 + 178 , 179 @ @ public class TokenTypes <nl> public static final int LITERAL _ TRANSIENT = 65 ; <nl> / * * token representing a LITERAL _ native * / <nl> public static final int LITERAL _ NATIVE = 66 ; <nl> - / * * token representing a LITERAL _ threadsafe * / <nl> - public static final int LITERAL _ THREADSAFE = 67 ; <nl> / * * token representing a LITERAL _ synchronized * / <nl> - public static final int LITERAL _ SYNCHRONIZED = 68 ; <nl> + public static final int LITERAL _ SYNCHRONIZED = 67 ; <nl> / * * token representing a LITERAL _ volatile * / <nl> - public static final int LITERAL _ VOLATILE = 69 ; <nl> + public static final int LITERAL _ VOLATILE = 68 ; <nl> / * * token representing a LITERAL _ class * / <nl> - public static final int LITERAL _ CLASS = 70 ; <nl> + public static final int LITERAL _ CLASS = 69 ; <nl> / * * token representing a LITERAL _ extends * / <nl> - public static final int LITERAL _ EXTENDS = 71 ; <nl> + public static final int LITERAL _ EXTENDS = 70 ; <nl> / * * token representing a LITERAL _ interface * / <nl> - public static final int LITERAL _ INTERFACE = 72 ; <nl> + public static final int LITERAL _ INTERFACE = 71 ; <nl> / * * token representing a LCURLY * / <nl> - public static final int LCURLY = 73 ; <nl> + public static final int LCURLY = 72 ; <nl> / * * token representing a RCURLY * / <nl> - public static final int RCURLY = 74 ; <nl> + public static final int RCURLY = 73 ; <nl> / * * token representing a COMMA * / <nl> - public static final int COMMA = 75 ; <nl> + public static final int COMMA = 74 ; <nl> / * * token representing a LITERAL _ implements * / <nl> - public static final int LITERAL _ IMPLEMENTS = 76 ; <nl> + public static final int LITERAL _ IMPLEMENTS = 75 ; <nl> / * * token representing a LPAREN * / <nl> - public static final int LPAREN = 77 ; <nl> + public static final int LPAREN = 76 ; <nl> / * * token representing a RPAREN * / <nl> - public static final int RPAREN = 78 ; <nl> + public static final int RPAREN = 77 ; <nl> / * * token representing a LITERAL _ this * / <nl> - public static final int LITERAL _ THIS = 79 ; <nl> + public static final int LITERAL _ THIS = 78 ; <nl> / * * token representing a LITERAL _ super * / <nl> - public static final int LITERAL _ SUPER = 80 ; <nl> + public static final int LITERAL _ SUPER = 79 ; <nl> / * * token representing a ASSIGN * / <nl> - public static final int ASSIGN = 81 ; <nl> + public static final int ASSIGN = 80 ; <nl> / * * token representing a LITERAL _ throws * / <nl> - public static final int LITERAL _ THROWS = 82 ; <nl> + public static final int LITERAL _ THROWS = 81 ; <nl> / * * token representing a COLON * / <nl> - public static final int COLON = 83 ; <nl> + public static final int COLON = 82 ; <nl> / * * token representing a LITERAL _ if * / <nl> - public static final int LITERAL _ IF = 84 ; <nl> + public static final int LITERAL _ IF = 83 ; <nl> / * * token representing a LITERAL _ for * / <nl> - public static final int LITERAL _ FOR = 85 ; <nl> + public static final int LITERAL _ FOR = 84 ; <nl> / * * token representing a LITERAL _ while * / <nl> - public static final int LITERAL _ WHILE = 86 ; <nl> + public static final int LITERAL _ WHILE = 85 ; <nl> / * * token representing a LITERAL _ do * / <nl> - public static final int LITERAL _ DO = 87 ; <nl> + public static final int LITERAL _ DO = 86 ; <nl> / * * token representing a LITERAL _ break * / <nl> - public static final int LITERAL _ BREAK = 88 ; <nl> + public static final int LITERAL _ BREAK = 87 ; <nl> / * * token representing a LITERAL _ continue * / <nl> - public static final int LITERAL _ CONTINUE = 89 ; <nl> + public static final int LITERAL _ CONTINUE = 88 ; <nl> / * * token representing a LITERAL _ return * / <nl> - public static final int LITERAL _ RETURN = 90 ; <nl> + public static final int LITERAL _ RETURN = 89 ; <nl> / * * token representing a LITERAL _ switch * / <nl> - public static final int LITERAL _ SWITCH = 91 ; <nl> + public static final int LITERAL _ SWITCH = 90 ; <nl> / * * token representing a LITERAL _ throw * / <nl> - public static final int LITERAL _ THROW = 92 ; <nl> + public static final int LITERAL _ THROW = 91 ; <nl> / * * token representing a LITERAL _ else * / <nl> - public static final int LITERAL _ ELSE = 93 ; <nl> + public static final int LITERAL _ ELSE = 92 ; <nl> / * * token representing a LITERAL _ case * / <nl> - public static final int LITERAL _ CASE = 94 ; <nl> + public static final int LITERAL _ CASE = 93 ; <nl> / * * token representing a LITERAL _ default * / <nl> - public static final int LITERAL _ DEFAULT = 95 ; <nl> + public static final int LITERAL _ DEFAULT = 94 ; <nl> / * * token representing a LITERAL _ try * / <nl> - public static final int LITERAL _ TRY = 96 ; <nl> + public static final int LITERAL _ TRY = 95 ; <nl> / * * token representing a LITERAL _ catch * / <nl> - public static final int LITERAL _ CATCH = 97 ; <nl> + public static final int LITERAL _ CATCH = 96 ; <nl> / * * token representing a LITERAL _ finally * / <nl> - public static final int LITERAL _ FINALLY = 98 ; <nl> + public static final int LITERAL _ FINALLY = 97 ; <nl> / * * token representing a PLUS _ ASSIGN * / <nl> - public static final int PLUS _ ASSIGN = 99 ; <nl> + public static final int PLUS _ ASSIGN = 98 ; <nl> / * * token representing a MINUS _ ASSIGN * / <nl> - public static final int MINUS _ ASSIGN = 100 ; <nl> + public static final int MINUS _ ASSIGN = 99 ; <nl> / * * token representing a STAR _ ASSIGN * / <nl> - public static final int STAR _ ASSIGN = 101 ; <nl> + public static final int STAR _ ASSIGN = 100 ; <nl> / * * token representing a DIV _ ASSIGN * / <nl> - public static final int DIV _ ASSIGN = 102 ; <nl> + public static final int DIV _ ASSIGN = 101 ; <nl> / * * token representing a MOD _ ASSIGN * / <nl> - public static final int MOD _ ASSIGN = 103 ; <nl> + public static final int MOD _ ASSIGN = 102 ; <nl> / * * token representing a SR _ ASSIGN * / <nl> - public static final int SR _ ASSIGN = 104 ; <nl> + public static final int SR _ ASSIGN = 103 ; <nl> / * * token representing a BSR _ ASSIGN * / <nl> - public static final int BSR _ ASSIGN = 105 ; <nl> + public static final int BSR _ ASSIGN = 104 ; <nl> / * * token representing a SL _ ASSIGN * / <nl> - public static final int SL _ ASSIGN = 106 ; <nl> + public static final int SL _ ASSIGN = 105 ; <nl> / * * token representing a BAND _ ASSIGN * / <nl> - public static final int BAND _ ASSIGN = 107 ; <nl> + public static final int BAND _ ASSIGN = 106 ; <nl> / * * token representing a BXOR _ ASSIGN * / <nl> - public static final int BXOR _ ASSIGN = 108 ; <nl> + public static final int BXOR _ ASSIGN = 107 ; <nl> / * * token representing a BOR _ ASSIGN * / <nl> - public static final int BOR _ ASSIGN = 109 ; <nl> + public static final int BOR _ ASSIGN = 108 ; <nl> / * * token representing a QUESTION * / <nl> - public static final int QUESTION = 110 ; <nl> + public static final int QUESTION = 109 ; <nl> / * * token representing a LOR * / <nl> - public static final int LOR = 111 ; <nl> + public static final int LOR = 110 ; <nl> / * * token representing a LAND * / <nl> - public static final int LAND = 112 ; <nl> + public static final int LAND = 111 ; <nl> / * * token representing a BOR * / <nl> - public static final int BOR = 113 ; <nl> + public static final int BOR = 112 ; <nl> / * * token representing a BXOR * / <nl> - public static final int BXOR = 114 ; <nl> + public static final int BXOR = 113 ; <nl> / * * token representing a BAND * / <nl> - public static final int BAND = 115 ; <nl> + public static final int BAND = 114 ; <nl> / * * token representing a NOT _ EQUAL * / <nl> - public static final int NOT _ EQUAL = 116 ; <nl> + public static final int NOT _ EQUAL = 115 ; <nl> / * * token representing a EQUAL * / <nl> - public static final int EQUAL = 117 ; <nl> + public static final int EQUAL = 116 ; <nl> / * * token representing a LT * / <nl> - public static final int LT = 118 ; <nl> + public static final int LT = 117 ; <nl> / * * token representing a GT * / <nl> - public static final int GT = 119 ; <nl> + public static final int GT = 118 ; <nl> / * * token representing a LE * / <nl> - public static final int LE = 120 ; <nl> + public static final int LE = 119 ; <nl> / * * token representing a GE * / <nl> - public static final int GE = 121 ; <nl> + public static final int GE = 120 ; <nl> / * * token representing a LITERAL _ instanceof * / <nl> - public static final int LITERAL _ INSTANCEOF = 122 ; <nl> + public static final int LITERAL _ INSTANCEOF = 121 ; <nl> / * * token representing a SL * / <nl> - public static final int SL = 123 ; <nl> + public static final int SL = 122 ; <nl> / * * token representing a SR * / <nl> - public static final int SR = 124 ; <nl> + public static final int SR = 123 ; <nl> / * * token representing a BSR * / <nl> - public static final int BSR = 125 ; <nl> + public static final int BSR = 124 ; <nl> / * * token representing a PLUS * / <nl> - public static final int PLUS = 126 ; <nl> + public static final int PLUS = 125 ; <nl> / * * token representing a MINUS * / <nl> - public static final int MINUS = 127 ; <nl> + public static final int MINUS = 126 ; <nl> / * * token representing a DIV * / <nl> - public static final int DIV = 128 ; <nl> + public static final int DIV = 127 ; <nl> / * * token representing a MOD * / <nl> - public static final int MOD = 129 ; <nl> + public static final int MOD = 128 ; <nl> / * * token representing a INC * / <nl> - public static final int INC = 130 ; <nl> + public static final int INC = 129 ; <nl> / * * token representing a DEC * / <nl> - public static final int DEC = 131 ; <nl> + public static final int DEC = 130 ; <nl> / * * token representing a BNOT * / <nl> - public static final int BNOT = 132 ; <nl> + public static final int BNOT = 131 ; <nl> / * * token representing a LNOT * / <nl> - public static final int LNOT = 133 ; <nl> + public static final int LNOT = 132 ; <nl> / * * token representing a LITERAL _ true * / <nl> - public static final int LITERAL _ TRUE = 134 ; <nl> + public static final int LITERAL _ TRUE = 133 ; <nl> / * * token representing a LITERAL _ false * / <nl> - public static final int LITERAL _ FALSE = 135 ; <nl> + public static final int LITERAL _ FALSE = 134 ; <nl> / * * token representing a LITERAL _ null * / <nl> - public static final int LITERAL _ NULL = 136 ; <nl> + public static final int LITERAL _ NULL = 135 ; <nl> / * * token representing a LITERAL _ new * / <nl> - public static final int LITERAL _ NEW = 137 ; <nl> + public static final int LITERAL _ NEW = 136 ; <nl> / * * token representing a NUM _ INT * / <nl> - public static final int NUM _ INT = 138 ; <nl> + public static final int NUM _ INT = 137 ; <nl> / * * token representing a CHAR _ LITERAL * / <nl> - public static final int CHAR _ LITERAL = 139 ; <nl> + public static final int CHAR _ LITERAL = 138 ; <nl> / * * token representing a STRING _ LITERAL * / <nl> - public static final int STRING _ LITERAL = 140 ; <nl> + public static final int STRING _ LITERAL = 139 ; <nl> / * * token representing a NUM _ FLOAT * / <nl> - public static final int NUM _ FLOAT = 141 ; <nl> + public static final int NUM _ FLOAT = 140 ; <nl> / * * token representing a NUM _ LONG * / <nl> - public static final int NUM _ LONG = 142 ; <nl> + public static final int NUM _ LONG = 141 ; <nl> / * * token representing a NUM _ DOUBLE * / <nl> - public static final int NUM _ DOUBLE = 143 ; <nl> + public static final int NUM _ DOUBLE = 142 ; <nl> / * * token representing a WS * / <nl> - public static final int WS = 144 ; <nl> + public static final int WS = 143 ; <nl> / * * token representing a SL _ COMMENT * / <nl> - public static final int SL _ COMMENT = 145 ; <nl> + public static final int SL _ COMMENT = 144 ; <nl> / * * token representing a ML _ COMMENT * / <nl> - public static final int ML _ COMMENT = 146 ; <nl> + public static final int ML _ COMMENT = 145 ; <nl> / * * token representing a ESC * / <nl> - public static final int ESC = 147 ; <nl> + public static final int ESC = 146 ; <nl> / * * token representing a HEX _ DIGIT * / <nl> - public static final int HEX _ DIGIT = 148 ; <nl> + public static final int HEX _ DIGIT = 147 ; <nl> / * * token representing a EXPONENT * / <nl> - public static final int EXPONENT = 150 ; <nl> + public static final int EXPONENT = 149 ; <nl> / * * token representing a FLOAT _ SUFFIX * / <nl> - public static final int FLOAT _ SUFFIX = 151 ; <nl> + public static final int FLOAT _ SUFFIX = 150 ; <nl> / * * token representing a ASSERT * / <nl> - public static final int LITERAL _ ASSERT = 152 ; <nl> + public static final int LITERAL _ ASSERT = 151 ; <nl> <nl> / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> / / The interesting code goes here <nl> / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> - <nl> + <nl> / * * maps from a token name to value * / <nl> private static final Map TOKEN _ NAME _ TO _ VALUE = new HashMap ( ) ; <nl> / * * maps from a token value to name * / <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> index d75d4b1 . . 9c7d73c 100644 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> @ @ - 184 , 7 + 184 , 6 @ @ modifier <nl> 	 | 	 " final " <nl> 	 | 	 " abstract " <nl> 	 | 	 " native " <nl> - 	 | 	 " threadsafe " <nl> 	 | 	 " synchronized " <nl> / / 	 | 	 " const " 	 	 	 / / reserved word , but not valid <nl> 	 | 	 " volatile "

TEST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheck . java 
 index ff924f4 . . 4c59bb0 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheck . java 
 @ @ - 21 , 6 + 21 , 10 @ @ package com . puppycrawl . tools . checkstyle . checks . design ; 
 
 import java . util . ArrayDeque ; 
 import java . util . Deque ; 
 + import java . util . LinkedList ; 
 + import java . util . List ; 
 + 
 + import org . apache . commons . lang3 . StringUtils ; 
 
 import com . puppycrawl . tools . checkstyle . api . AbstractCheck ; 
 import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 @ @ - 50 , 8 + 54 , 16 @ @ public class FinalClassCheck 
 * / 
 public static final String MSG _ KEY = " final . class " ; 
 
 + / * * 
 + * Character separate package names in qualified name of java class . 
 + * / 
 + public static final String PACKAGE _ SEPARATOR = " . " ; 
 + 
 / * * Keeps ClassDesc objects for stack of declared classes . * / 
 - private final Deque < ClassDesc > classes = new ArrayDeque < > ( ) ; 
 + private Deque < ClassDesc > classes ; 
 + 
 + / * * Full qualified name of the package . * / 
 + private String packageName ; 
 
 @ Override 
 public int [ ] getDefaultTokens ( ) { 
 @ @ - 60 , 7 + 72 , 7 @ @ public class FinalClassCheck 
 
 @ Override 
 public int [ ] getAcceptableTokens ( ) { 
 - return new int [ ] { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF } ; 
 + return new int [ ] { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF , TokenTypes . PACKAGE _ DEF } ; 
 } 
 
 @ Override 
 @ @ - 69 , 23 + 81 , 45 @ @ public class FinalClassCheck 
 } 
 
 @ Override 
 + public void beginTree ( DetailAST rootAST ) { 
 + classes = new ArrayDeque < > ( ) ; 
 + packageName = " " ; 
 + } 
 + 
 + @ Override 
 public void visitToken ( DetailAST ast ) { 
 final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 
 - if ( ast . getType ( ) = = TokenTypes . CLASS _ DEF ) { 
 - final boolean isFinal = modifiers . branchContains ( TokenTypes . FINAL ) ; 
 - final boolean isAbstract = modifiers . branchContains ( TokenTypes . ABSTRACT ) ; 
 - classes . push ( new ClassDesc ( isFinal , isAbstract ) ) ; 
 - } 
 - / / ctors in enums don ' t matter 
 - else if ( ! ScopeUtils . isInEnumBlock ( ast ) ) { 
 - final ClassDesc desc = classes . peek ( ) ; 
 - if ( modifiers . branchContains ( TokenTypes . LITERAL _ PRIVATE ) ) { 
 - desc . reportPrivateCtor ( ) ; 
 - } 
 - else { 
 - desc . reportNonPrivateCtor ( ) ; 
 - } 
 + switch ( ast . getType ( ) ) { 
 + 
 + case TokenTypes . PACKAGE _ DEF : 
 + packageName = extractQualifiedName ( ast ) ; 
 + break ; 
 + 
 + case TokenTypes . CLASS _ DEF : 
 + registerNestedSubclassToOuterSuperClasses ( ast ) ; 
 + 
 + final boolean isFinal = modifiers . branchContains ( TokenTypes . FINAL ) ; 
 + final boolean isAbstract = modifiers . branchContains ( TokenTypes . ABSTRACT ) ; 
 + 
 + final String qualifiedClassName = getQualifiedClassName ( ast ) ; 
 + classes . push ( new ClassDesc ( qualifiedClassName , isFinal , isAbstract ) ) ; 
 + break ; 
 + 
 + case TokenTypes . CTOR _ DEF : 
 + if ( ! ScopeUtils . isInEnumBlock ( ast ) ) { 
 + final ClassDesc desc = classes . peek ( ) ; 
 + if ( modifiers . branchContains ( TokenTypes . LITERAL _ PRIVATE ) ) { 
 + desc . registerPrivateCtor ( ) ; 
 + } 
 + else { 
 + desc . registerNonPrivateCtor ( ) ; 
 + } 
 + } 
 + break ; 
 + 
 + default : 
 + throw new IllegalStateException ( ast . toString ( ) ) ; 
 } 
 } 
 
 @ @ - 96 , 19 + 130 , 150 @ @ public class FinalClassCheck 
 } 
 
 final ClassDesc desc = classes . pop ( ) ; 
 - if ( ! desc . isDeclaredAsFinal ( ) 
 + if ( desc . isWithPrivateCtor ( ) 
 & & ! desc . isDeclaredAsAbstract ( ) 
 - & & desc . isWithPrivateCtor ( ) 
 + & & ! desc . isDeclaredAsFinal ( ) 
 & & ! desc . isWithNonPrivateCtor ( ) 
 + & & ! desc . isWithNestedSubclass ( ) 
 & & ! ScopeUtils . isInInterfaceOrAnnotationBlock ( ast ) ) { 
 - final String className = 
 - ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; 
 + final String qualifiedName = desc . getQualifiedName ( ) ; 
 + final String className = getClassNameFromQualifiedName ( qualifiedName ) ; 
 log ( ast . getLineNo ( ) , MSG _ KEY , className ) ; 
 } 
 } 
 
 + / * * 
 + * Get name of class ( with qualified package if specified ) in extend clause . 
 + * @ param classExtend extend clause to extract class name 
 + * @ return super class name 
 + * / 
 + private static String extractQualifiedName ( DetailAST classExtend ) { 
 + final String className ; 
 + 
 + if ( classExtend . findFirstToken ( TokenTypes . IDENT ) = = null ) { 
 + / / Name specified with packages , have to traverse DOT 
 + final DetailAST firstChild = classExtend . findFirstToken ( TokenTypes . DOT ) ; 
 + final List < String > qualifiedNameParts = new LinkedList < > ( ) ; 
 + 
 + qualifiedNameParts . add ( 0 , firstChild . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ) ; 
 + DetailAST traverse = firstChild . findFirstToken ( TokenTypes . DOT ) ; 
 + while ( traverse ! = null ) { 
 + qualifiedNameParts . add ( 0 , traverse . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ) ; 
 + traverse = traverse . findFirstToken ( TokenTypes . DOT ) ; 
 + } 
 + className = StringUtils . join ( qualifiedNameParts , PACKAGE _ SEPARATOR ) ; 
 + } 
 + else { 
 + className = classExtend . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; 
 + } 
 + 
 + return className ; 
 + } 
 + 
 + / * * 
 + * Register to outer super classes of given classAst that 
 + * given classAst is extending them . 
 + * @ param classAst class which outer super classes will be 
 + * informed about nesting subclass 
 + * / 
 + private void registerNestedSubclassToOuterSuperClasses ( DetailAST classAst ) { 
 + final String currentAstSuperClassName = getSuperClassName ( classAst ) ; 
 + if ( currentAstSuperClassName ! = null ) { 
 + for ( ClassDesc classDesc : classes ) { 
 + final String classDescQualifiedName = classDesc . getQualifiedName ( ) ; 
 + if ( doesNameInExtendMatchSuperClassName ( classDescQualifiedName , 
 + currentAstSuperClassName ) ) { 
 + classDesc . registerNestedSubclass ( ) ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Get qualified class name from given class Ast . 
 + * @ param classAst class to get qualified class name 
 + * @ return qualified class name of a class 
 + * / 
 + private String getQualifiedClassName ( DetailAST classAst ) { 
 + final String className = classAst . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; 
 + String outerClassQualifiedName = null ; 
 + if ( ! classes . isEmpty ( ) ) { 
 + outerClassQualifiedName = classes . peek ( ) . getQualifiedName ( ) ; 
 + } 
 + return getQualifiedClassName ( packageName , outerClassQualifiedName , className ) ; 
 + } 
 + 
 + / * * 
 + * Calculate qualified class name ( package + class name ) laying inside given 
 + * outer class . 
 + * @ param packageName package name , empty string on default package 
 + * @ param outerClassQualifiedName qualified name ( package + class ) of outer class , 
 + * null if doesnt exist 
 + * @ param className class name 
 + * @ return qualified class name ( package + class name ) 
 + * / 
 + private static String getQualifiedClassName ( String packageName , String outerClassQualifiedName , 
 + String className ) { 
 + final String qualifiedClassName ; 
 + 
 + if ( outerClassQualifiedName = = null ) { 
 + if ( packageName . isEmpty ( ) ) { 
 + qualifiedClassName = className ; 
 + } 
 + else { 
 + qualifiedClassName = packageName + PACKAGE _ SEPARATOR + className ; 
 + } 
 + } 
 + else { 
 + qualifiedClassName = outerClassQualifiedName + PACKAGE _ SEPARATOR + className ; 
 + } 
 + return qualifiedClassName ; 
 + } 
 + 
 + / * * 
 + * Get super class name of given class . 
 + * @ param classAst class 
 + * @ return super class name or null if super class is not specified 
 + * / 
 + private String getSuperClassName ( DetailAST classAst ) { 
 + String superClassName = null ; 
 + final DetailAST classExtend = classAst . findFirstToken ( TokenTypes . EXTENDS _ CLAUSE ) ; 
 + if ( classExtend ! = null ) { 
 + superClassName = extractQualifiedName ( classExtend ) ; 
 + } 
 + return superClassName ; 
 + } 
 + 
 + / * * 
 + * Checks if given super class name in extend clause match super class qualified name . 
 + * @ param superClassQualifiedName super class quaflieid name ( with package ) 
 + * @ param superClassInExtendClause name in extend clause 
 + * @ return true if given super class name in extend clause match super class qualified name , 
 + * false otherwise 
 + * / 
 + private static boolean doesNameInExtendMatchSuperClassName ( String superClassQualifiedName , 
 + String superClassInExtendClause ) { 
 + String superClassNormalizedName = superClassQualifiedName ; 
 + if ( ! superClassInExtendClause . contains ( PACKAGE _ SEPARATOR ) ) { 
 + superClassNormalizedName = getClassNameFromQualifiedName ( superClassQualifiedName ) ; 
 + } 
 + return superClassNormalizedName . equals ( superClassInExtendClause ) ; 
 + } 
 + 
 + / * * 
 + * Get class name from qualified name . 
 + * @ param qualifiedName qualified class name 
 + * @ return class name 
 + * / 
 + private static String getClassNameFromQualifiedName ( String qualifiedName ) { 
 + return qualifiedName . substring ( qualifiedName . lastIndexOf ( PACKAGE _ SEPARATOR ) + 1 ) ; 
 + } 
 + 
 / * * Maintains information about class ' ctors . * / 
 private static final class ClassDesc { 
 + / * * Qualified class name ( with package ) . * / 
 + private final String qualifiedName ; 
 + 
 / * * Is class declared as final . * / 
 private final boolean declaredAsFinal ; 
 
 @ @ - 121 , 28 + 286 , 46 @ @ public class FinalClassCheck 
 / * * Does class have private ctors . * / 
 private boolean withPrivateCtor ; 
 
 + / * * Does class have nested subclass . * / 
 + private boolean withNestedSubclass ; 
 + 
 / * * 
 * Create a new ClassDesc instance . 
 + * @ param qualifiedName qualified class name ( with package ) 
 * @ param declaredAsFinal indicates if the 
 * class declared as final 
 * @ param declaredAsAbstract indicates if the 
 * class declared as abstract 
 * / 
 - ClassDesc ( boolean declaredAsFinal , boolean declaredAsAbstract ) { 
 + ClassDesc ( String qualifiedName , boolean declaredAsFinal , boolean declaredAsAbstract ) { 
 + this . qualifiedName = qualifiedName ; 
 this . declaredAsFinal = declaredAsFinal ; 
 this . declaredAsAbstract = declaredAsAbstract ; 
 } 
 
 + / * * 
 + * Get qualified class name . 
 + * @ return qualified class name 
 + * / 
 + private String getQualifiedName ( ) { 
 + return qualifiedName ; 
 + } 
 + 
 / * * Adds private ctor . * / 
 - private void reportPrivateCtor ( ) { 
 + private void registerPrivateCtor ( ) { 
 withPrivateCtor = true ; 
 } 
 
 / * * Adds non - private ctor . * / 
 - private void reportNonPrivateCtor ( ) { 
 + private void registerNonPrivateCtor ( ) { 
 withNonPrivateCtor = true ; 
 } 
 
 + / * * Adds nested subclass . * / 
 + private void registerNestedSubclass ( ) { 
 + withNestedSubclass = true ; 
 + } 
 + 
 / * * 
 * Does class have private ctors . 
 * @ return true if class has private ctors 
 @ @ - 160 , 6 + 343 , 14 @ @ public class FinalClassCheck 
 } 
 
 / * * 
 + * Does class have nested subclass . 
 + * @ return true if class has nested subclass 
 + * / 
 + private boolean isWithNestedSubclass ( ) { 
 + return withNestedSubclass ; 
 + } 
 + 
 + / * * 
 * Is class declared as final . 
 * @ return true if class is declared as final 
 * / 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheckTest . java 
 index c02785d . . d5d9e46 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / FinalClassCheckTest . java 
 @ @ - 25 , 10 + 25 , 12 @ @ import static org . junit . Assert . assertArrayEquals ; 
 import java . io . File ; 
 import java . io . IOException ; 
 
 + import org . junit . Assert ; 
 import org . junit . Test ; 
 
 import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; 
 import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; 
 + import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 
 public class FinalClassCheckTest 
 @ @ - 39 , 10 + 41 , 16 @ @ public class FinalClassCheckTest 
 + " design " + File . separator + filename ) ; 
 } 
 
 + @ Override 
 + protected String getNonCompilablePath ( String filename ) throws IOException { 
 + return super . getNonCompilablePath ( " checks " + File . separator 
 + + " design " + File . separator + filename ) ; 
 + } 
 + 
 @ Test 
 public void testGetRequiredTokens ( ) { 
 final FinalClassCheck checkObj = new FinalClassCheck ( ) ; 
 - final int [ ] expected = { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF } ; 
 + final int [ ] expected = { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF , TokenTypes . PACKAGE _ DEF } ; 
 assertArrayEquals ( expected , checkObj . getRequiredTokens ( ) ) ; 
 } 
 
 @ @ - 53 , 15 + 61 , 56 @ @ public class FinalClassCheckTest 
 final String [ ] expected = { 
 " 7 : " + getCheckMessage ( MSG _ KEY , " InputFinalClass " ) , 
 " 15 : " + getCheckMessage ( MSG _ KEY , " test4 " ) , 
 - " 109 : " + getCheckMessage ( MSG _ KEY , " someinnerClass " ) , 
 + " 113 : " + getCheckMessage ( MSG _ KEY , " someinnerClass " ) , 
 } ; 
 verify ( checkConfig , getPath ( " InputFinalClass . java " ) , expected ) ; 
 } 
 
 @ Test 
 + public void testClassWithPrivateCtorAndNestedExtendingSubclass ( ) throws Exception { 
 + final DefaultConfiguration checkConfig = 
 + createCheckConfig ( FinalClassCheck . class ) ; 
 + final String [ ] expected = { 
 + " 15 : " + getCheckMessage ( MSG _ KEY , " C " ) , 
 + } ; 
 + verify ( checkConfig , 
 + getNonCompilablePath ( " InputClassWithPrivateCtorWithNestedExtendingClass . java " ) , 
 + expected ) ; 
 + } 
 + 
 + @ Test 
 + public void testClassWithPrivateCtorAndNestedExtendingSubclassWithoutPackage ( ) 
 + throws Exception { 
 + final DefaultConfiguration checkConfig = 
 + createCheckConfig ( FinalClassCheck . class ) ; 
 + final String [ ] expected = { 
 + " 7 : " + getCheckMessage ( MSG _ KEY , " C " ) , 
 + } ; 
 + verify ( checkConfig , 
 + getNonCompilablePath ( 
 + " InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage . java " ) , 
 + expected ) ; 
 + } 
 + 
 + @ Test 
 + public void testImproperToken ( ) throws Exception { 
 + final FinalClassCheck finalClassCheck = new FinalClassCheck ( ) ; 
 + final DetailAST badAst = new DetailAST ( ) ; 
 + final int unsupportedTokenByCheck = TokenTypes . EOF ; 
 + badAst . setType ( unsupportedTokenByCheck ) ; 
 + try { 
 + finalClassCheck . visitToken ( badAst ) ; 
 + Assert . fail ( " IllegalStateException is expected " ) ; 
 + } 
 + catch ( IllegalStateException ex ) { 
 + / / it is OK 
 + } 
 + } 
 + 
 + @ Test 
 public void testGetAcceptableTokens ( ) { 
 final FinalClassCheck obj = new FinalClassCheck ( ) ; 
 - final int [ ] expected = { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF } ; 
 + final int [ ] expected = { TokenTypes . CLASS _ DEF , TokenTypes . CTOR _ DEF , TokenTypes . PACKAGE _ DEF } ; 
 assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; 
 } 
 } 
 diff - - git a / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClass . java b / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClass . java 
 new file mode 100644 
 index 0000000 . . bd84a4f 
 - - - / dev / null 
 + + + b / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClass . java 
 @ @ - 0 , 0 + 1 , 19 @ @ 
 + package com . puppycrawl . tools . checkstyle . checks . design ; 
 + 
 + public class InputClassWithPrivateCtorWithNestedExtendingClass { 
 + class A { 
 + private A ( ) { } 
 + private class ExtendA extends A { } 
 + } 
 + 
 + class B { 
 + private B ( ) { } 
 + private class ExtendB extends 
 + com . puppycrawl . tools . checkstyle . checks . design . InputClassWithPrivateCtorWithNestedExtendingClass . B { } 
 + } 
 + 
 + class C { 
 + private C ( ) { } 
 + private class ExtendC extends com . nonexistent . packages . C { } 
 + } 
 + } 
 diff - - git a / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage . java b / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage . java 
 new file mode 100644 
 index 0000000 . . f8bbe9b 
 - - - / dev / null 
 + + + b / src / test / resources - noncompilable / com / puppycrawl / tools / checkstyle / checks / design / InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage . java 
 @ @ - 0 , 0 + 1 , 11 @ @ 
 + public class InputClassWithPrivateCtorWithNestedExtendingClassWithoutPackage { 
 + class A { 
 + private A ( ) { } 
 + private class ExtendA extends A { } 
 + } 
 + 
 + class C { 
 + private C ( ) { } 
 + private class ExtendC extends com . nonexistent . packages . C { } 
 + } 
 + } 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputFinalClass . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputFinalClass . java 
 index 96cbc79 . . 5db58d8 100644 
 - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputFinalClass . java 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputFinalClass . java 
 @ @ - 29 , 6 + 29 , 10 @ @ class test6 
 public test6 ( ) { } 
 } 
 
 + final class test7 { 
 + private test7 ( ) { } 
 + } 
 + 
 / / Typesafe enum with operation 
 / / abstract classes cannot be final , see bug # 837012 
 abstract class Operation

NEAREST DIFF:
diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / api / TokenTypes . java b / src / checkstyle / com / puppycrawl / tools / checkstyle / api / TokenTypes . java 
 index 53e059b . . b442d38 100644 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / api / TokenTypes . java 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / api / TokenTypes . java 
 @ @ - 178 , 181 + 178 , 179 @ @ public class TokenTypes 
 public static final int LITERAL _ TRANSIENT = 65 ; 
 / * * token representing a LITERAL _ native * / 
 public static final int LITERAL _ NATIVE = 66 ; 
 - / * * token representing a LITERAL _ threadsafe * / 
 - public static final int LITERAL _ THREADSAFE = 67 ; 
 / * * token representing a LITERAL _ synchronized * / 
 - public static final int LITERAL _ SYNCHRONIZED = 68 ; 
 + public static final int LITERAL _ SYNCHRONIZED = 67 ; 
 / * * token representing a LITERAL _ volatile * / 
 - public static final int LITERAL _ VOLATILE = 69 ; 
 + public static final int LITERAL _ VOLATILE = 68 ; 
 / * * token representing a LITERAL _ class * / 
 - public static final int LITERAL _ CLASS = 70 ; 
 + public static final int LITERAL _ CLASS = 69 ; 
 / * * token representing a LITERAL _ extends * / 
 - public static final int LITERAL _ EXTENDS = 71 ; 
 + public static final int LITERAL _ EXTENDS = 70 ; 
 / * * token representing a LITERAL _ interface * / 
 - public static final int LITERAL _ INTERFACE = 72 ; 
 + public static final int LITERAL _ INTERFACE = 71 ; 
 / * * token representing a LCURLY * / 
 - public static final int LCURLY = 73 ; 
 + public static final int LCURLY = 72 ; 
 / * * token representing a RCURLY * / 
 - public static final int RCURLY = 74 ; 
 + public static final int RCURLY = 73 ; 
 / * * token representing a COMMA * / 
 - public static final int COMMA = 75 ; 
 + public static final int COMMA = 74 ; 
 / * * token representing a LITERAL _ implements * / 
 - public static final int LITERAL _ IMPLEMENTS = 76 ; 
 + public static final int LITERAL _ IMPLEMENTS = 75 ; 
 / * * token representing a LPAREN * / 
 - public static final int LPAREN = 77 ; 
 + public static final int LPAREN = 76 ; 
 / * * token representing a RPAREN * / 
 - public static final int RPAREN = 78 ; 
 + public static final int RPAREN = 77 ; 
 / * * token representing a LITERAL _ this * / 
 - public static final int LITERAL _ THIS = 79 ; 
 + public static final int LITERAL _ THIS = 78 ; 
 / * * token representing a LITERAL _ super * / 
 - public static final int LITERAL _ SUPER = 80 ; 
 + public static final int LITERAL _ SUPER = 79 ; 
 / * * token representing a ASSIGN * / 
 - public static final int ASSIGN = 81 ; 
 + public static final int ASSIGN = 80 ; 
 / * * token representing a LITERAL _ throws * / 
 - public static final int LITERAL _ THROWS = 82 ; 
 + public static final int LITERAL _ THROWS = 81 ; 
 / * * token representing a COLON * / 
 - public static final int COLON = 83 ; 
 + public static final int COLON = 82 ; 
 / * * token representing a LITERAL _ if * / 
 - public static final int LITERAL _ IF = 84 ; 
 + public static final int LITERAL _ IF = 83 ; 
 / * * token representing a LITERAL _ for * / 
 - public static final int LITERAL _ FOR = 85 ; 
 + public static final int LITERAL _ FOR = 84 ; 
 / * * token representing a LITERAL _ while * / 
 - public static final int LITERAL _ WHILE = 86 ; 
 + public static final int LITERAL _ WHILE = 85 ; 
 / * * token representing a LITERAL _ do * / 
 - public static final int LITERAL _ DO = 87 ; 
 + public static final int LITERAL _ DO = 86 ; 
 / * * token representing a LITERAL _ break * / 
 - public static final int LITERAL _ BREAK = 88 ; 
 + public static final int LITERAL _ BREAK = 87 ; 
 / * * token representing a LITERAL _ continue * / 
 - public static final int LITERAL _ CONTINUE = 89 ; 
 + public static final int LITERAL _ CONTINUE = 88 ; 
 / * * token representing a LITERAL _ return * / 
 - public static final int LITERAL _ RETURN = 90 ; 
 + public static final int LITERAL _ RETURN = 89 ; 
 / * * token representing a LITERAL _ switch * / 
 - public static final int LITERAL _ SWITCH = 91 ; 
 + public static final int LITERAL _ SWITCH = 90 ; 
 / * * token representing a LITERAL _ throw * / 
 - public static final int LITERAL _ THROW = 92 ; 
 + public static final int LITERAL _ THROW = 91 ; 
 / * * token representing a LITERAL _ else * / 
 - public static final int LITERAL _ ELSE = 93 ; 
 + public static final int LITERAL _ ELSE = 92 ; 
 / * * token representing a LITERAL _ case * / 
 - public static final int LITERAL _ CASE = 94 ; 
 + public static final int LITERAL _ CASE = 93 ; 
 / * * token representing a LITERAL _ default * / 
 - public static final int LITERAL _ DEFAULT = 95 ; 
 + public static final int LITERAL _ DEFAULT = 94 ; 
 / * * token representing a LITERAL _ try * / 
 - public static final int LITERAL _ TRY = 96 ; 
 + public static final int LITERAL _ TRY = 95 ; 
 / * * token representing a LITERAL _ catch * / 
 - public static final int LITERAL _ CATCH = 97 ; 
 + public static final int LITERAL _ CATCH = 96 ; 
 / * * token representing a LITERAL _ finally * / 
 - public static final int LITERAL _ FINALLY = 98 ; 
 + public static final int LITERAL _ FINALLY = 97 ; 
 / * * token representing a PLUS _ ASSIGN * / 
 - public static final int PLUS _ ASSIGN = 99 ; 
 + public static final int PLUS _ ASSIGN = 98 ; 
 / * * token representing a MINUS _ ASSIGN * / 
 - public static final int MINUS _ ASSIGN = 100 ; 
 + public static final int MINUS _ ASSIGN = 99 ; 
 / * * token representing a STAR _ ASSIGN * / 
 - public static final int STAR _ ASSIGN = 101 ; 
 + public static final int STAR _ ASSIGN = 100 ; 
 / * * token representing a DIV _ ASSIGN * / 
 - public static final int DIV _ ASSIGN = 102 ; 
 + public static final int DIV _ ASSIGN = 101 ; 
 / * * token representing a MOD _ ASSIGN * / 
 - public static final int MOD _ ASSIGN = 103 ; 
 + public static final int MOD _ ASSIGN = 102 ; 
 / * * token representing a SR _ ASSIGN * / 
 - public static final int SR _ ASSIGN = 104 ; 
 + public static final int SR _ ASSIGN = 103 ; 
 / * * token representing a BSR _ ASSIGN * / 
 - public static final int BSR _ ASSIGN = 105 ; 
 + public static final int BSR _ ASSIGN = 104 ; 
 / * * token representing a SL _ ASSIGN * / 
 - public static final int SL _ ASSIGN = 106 ; 
 + public static final int SL _ ASSIGN = 105 ; 
 / * * token representing a BAND _ ASSIGN * / 
 - public static final int BAND _ ASSIGN = 107 ; 
 + public static final int BAND _ ASSIGN = 106 ; 
 / * * token representing a BXOR _ ASSIGN * / 
 - public static final int BXOR _ ASSIGN = 108 ; 
 + public static final int BXOR _ ASSIGN = 107 ; 
 / * * token representing a BOR _ ASSIGN * / 
 - public static final int BOR _ ASSIGN = 109 ; 
 + public static final int BOR _ ASSIGN = 108 ; 
 / * * token representing a QUESTION * / 
 - public static final int QUESTION = 110 ; 
 + public static final int QUESTION = 109 ; 
 / * * token representing a LOR * / 
 - public static final int LOR = 111 ; 
 + public static final int LOR = 110 ; 
 / * * token representing a LAND * / 
 - public static final int LAND = 112 ; 
 + public static final int LAND = 111 ; 
 / * * token representing a BOR * / 
 - public static final int BOR = 113 ; 
 + public static final int BOR = 112 ; 
 / * * token representing a BXOR * / 
 - public static final int BXOR = 114 ; 
 + public static final int BXOR = 113 ; 
 / * * token representing a BAND * / 
 - public static final int BAND = 115 ; 
 + public static final int BAND = 114 ; 
 / * * token representing a NOT _ EQUAL * / 
 - public static final int NOT _ EQUAL = 116 ; 
 + public static final int NOT _ EQUAL = 115 ; 
 / * * token representing a EQUAL * / 
 - public static final int EQUAL = 117 ; 
 + public static final int EQUAL = 116 ; 
 / * * token representing a LT * / 
 - public static final int LT = 118 ; 
 + public static final int LT = 117 ; 
 / * * token representing a GT * / 
 - public static final int GT = 119 ; 
 + public static final int GT = 118 ; 
 / * * token representing a LE * / 
 - public static final int LE = 120 ; 
 + public static final int LE = 119 ; 
 / * * token representing a GE * / 
 - public static final int GE = 121 ; 
 + public static final int GE = 120 ; 
 / * * token representing a LITERAL _ instanceof * / 
 - public static final int LITERAL _ INSTANCEOF = 122 ; 
 + public static final int LITERAL _ INSTANCEOF = 121 ; 
 / * * token representing a SL * / 
 - public static final int SL = 123 ; 
 + public static final int SL = 122 ; 
 / * * token representing a SR * / 
 - public static final int SR = 124 ; 
 + public static final int SR = 123 ; 
 / * * token representing a BSR * / 
 - public static final int BSR = 125 ; 
 + public static final int BSR = 124 ; 
 / * * token representing a PLUS * / 
 - public static final int PLUS = 126 ; 
 + public static final int PLUS = 125 ; 
 / * * token representing a MINUS * / 
 - public static final int MINUS = 127 ; 
 + public static final int MINUS = 126 ; 
 / * * token representing a DIV * / 
 - public static final int DIV = 128 ; 
 + public static final int DIV = 127 ; 
 / * * token representing a MOD * / 
 - public static final int MOD = 129 ; 
 + public static final int MOD = 128 ; 
 / * * token representing a INC * / 
 - public static final int INC = 130 ; 
 + public static final int INC = 129 ; 
 / * * token representing a DEC * / 
 - public static final int DEC = 131 ; 
 + public static final int DEC = 130 ; 
 / * * token representing a BNOT * / 
 - public static final int BNOT = 132 ; 
 + public static final int BNOT = 131 ; 
 / * * token representing a LNOT * / 
 - public static final int LNOT = 133 ; 
 + public static final int LNOT = 132 ; 
 / * * token representing a LITERAL _ true * / 
 - public static final int LITERAL _ TRUE = 134 ; 
 + public static final int LITERAL _ TRUE = 133 ; 
 / * * token representing a LITERAL _ false * / 
 - public static final int LITERAL _ FALSE = 135 ; 
 + public static final int LITERAL _ FALSE = 134 ; 
 / * * token representing a LITERAL _ null * / 
 - public static final int LITERAL _ NULL = 136 ; 
 + public static final int LITERAL _ NULL = 135 ; 
 / * * token representing a LITERAL _ new * / 
 - public static final int LITERAL _ NEW = 137 ; 
 + public static final int LITERAL _ NEW = 136 ; 
 / * * token representing a NUM _ INT * / 
 - public static final int NUM _ INT = 138 ; 
 + public static final int NUM _ INT = 137 ; 
 / * * token representing a CHAR _ LITERAL * / 
 - public static final int CHAR _ LITERAL = 139 ; 
 + public static final int CHAR _ LITERAL = 138 ; 
 / * * token representing a STRING _ LITERAL * / 
 - public static final int STRING _ LITERAL = 140 ; 
 + public static final int STRING _ LITERAL = 139 ; 
 / * * token representing a NUM _ FLOAT * / 
 - public static final int NUM _ FLOAT = 141 ; 
 + public static final int NUM _ FLOAT = 140 ; 
 / * * token representing a NUM _ LONG * / 
 - public static final int NUM _ LONG = 142 ; 
 + public static final int NUM _ LONG = 141 ; 
 / * * token representing a NUM _ DOUBLE * / 
 - public static final int NUM _ DOUBLE = 143 ; 
 + public static final int NUM _ DOUBLE = 142 ; 
 / * * token representing a WS * / 
 - public static final int WS = 144 ; 
 + public static final int WS = 143 ; 
 / * * token representing a SL _ COMMENT * / 
 - public static final int SL _ COMMENT = 145 ; 
 + public static final int SL _ COMMENT = 144 ; 
 / * * token representing a ML _ COMMENT * / 
 - public static final int ML _ COMMENT = 146 ; 
 + public static final int ML _ COMMENT = 145 ; 
 / * * token representing a ESC * / 
 - public static final int ESC = 147 ; 
 + public static final int ESC = 146 ; 
 / * * token representing a HEX _ DIGIT * / 
 - public static final int HEX _ DIGIT = 148 ; 
 + public static final int HEX _ DIGIT = 147 ; 
 / * * token representing a EXPONENT * / 
 - public static final int EXPONENT = 150 ; 
 + public static final int EXPONENT = 149 ; 
 / * * token representing a FLOAT _ SUFFIX * / 
 - public static final int FLOAT _ SUFFIX = 151 ; 
 + public static final int FLOAT _ SUFFIX = 150 ; 
 / * * token representing a ASSERT * / 
 - public static final int LITERAL _ ASSERT = 152 ; 
 + public static final int LITERAL _ ASSERT = 151 ; 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / The interesting code goes here 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - 
 + 
 / * * maps from a token name to value * / 
 private static final Map TOKEN _ NAME _ TO _ VALUE = new HashMap ( ) ; 
 / * * maps from a token value to name * / 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 index d75d4b1 . . 9c7d73c 100644 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 @ @ - 184 , 7 + 184 , 6 @ @ modifier 
 	 | 	 " final " 
 	 | 	 " abstract " 
 	 | 	 " native " 
 - 	 | 	 " threadsafe " 
 	 | 	 " synchronized " 
 / / 	 | 	 " const " 	 	 	 / / reserved word , but not valid 
 	 | 	 " volatile "
