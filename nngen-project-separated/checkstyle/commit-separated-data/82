BLEU SCORE: 0.014333045747359384

TEST MSG: Issue # 6297 : removed files from cache when an exception occurs
GENERATED MSG: Delete System . exit ( ) and delegate exit control into separate method .

TEST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / Checker . java b / src / main / java / com / puppycrawl / tools / checkstyle / Checker . java <nl> index d3320a7 . . 3e346b0 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / Checker . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / Checker . java <nl> @ @ - 273 , 10 + 273 , 12 @ @ public class Checker extends AutomaticBean implements MessageDispatcher , RootMod <nl> * @ throws CheckstyleException if error condition within Checkstyle occurs . <nl> * @ noinspection ProhibitedExceptionThrown <nl> * / <nl> + / / - @ cs [ CyclomaticComplexity ] no easy way to split this logic of processing the file <nl> private void processFiles ( List < File > files ) throws CheckstyleException { <nl> for ( final File file : files ) { <nl> + String fileName = null ; <nl> try { <nl> - final String fileName = file . getAbsolutePath ( ) ; <nl> + fileName = file . getAbsolutePath ( ) ; <nl> final long timestamp = file . lastModified ( ) ; <nl> if ( cacheFile ! = null & & cacheFile . isInCache ( fileName , timestamp ) <nl> | | ! acceptFileStarted ( fileName ) ) { <nl> @ @ - 293 , 11 + 295 , 19 @ @ public class Checker extends AutomaticBean implements MessageDispatcher , RootMod <nl> / / - @ cs [ IllegalCatch ] There is no other way to deliver filename that was under <nl> / / processing . See https : / / github . com / checkstyle / checkstyle / issues / 2285 <nl> catch ( Exception ex ) { <nl> + if ( fileName ! = null & & cacheFile ! = null ) { <nl> + cacheFile . remove ( fileName ) ; <nl> + } <nl> + <nl> / / We need to catch all exceptions to put a reason failure ( file name ) in exception <nl> throw new CheckstyleException ( " Exception was thrown while processing " <nl> + file . getPath ( ) , ex ) ; <nl> } <nl> catch ( Error error ) { <nl> + if ( fileName ! = null & & cacheFile ! = null ) { <nl> + cacheFile . remove ( fileName ) ; <nl> + } <nl> + <nl> / / We need to catch all errors to put a reason failure ( file name ) in error <nl> throw new Error ( " Error was thrown while processing " + file . getPath ( ) , error ) ; <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / CheckerTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / CheckerTest . java <nl> index d27e6f7 . . 641bed4 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / CheckerTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / CheckerTest . java <nl> @ @ - 674 , 6 + 674 , 7 @ @ public class CheckerTest extends AbstractModuleTestSupport { <nl> + " or has run out of resources necessary for it to continue operating . " ; <nl> final Error expectedError = new IOError ( new InternalError ( errorMessage ) ) ; <nl> when ( mock . lastModified ( ) ) . thenThrow ( expectedError ) ; <nl> + when ( mock . getAbsolutePath ( ) ) . thenReturn ( " testFile " ) ; <nl> final Checker checker = new Checker ( ) ; <nl> final List < File > filesToProcess = new ArrayList < > ( ) ; <nl> filesToProcess . add ( mock ) ; <nl> @ @ - 692 , 6 + 693 , 120 @ @ public class CheckerTest extends AbstractModuleTestSupport { <nl> } <nl> } <nl> <nl> + @ Test <nl> + public void testCatchErrorWithNoFileName ( ) throws Exception { <nl> + / / The idea of the test is to satisfy coverage rate . <nl> + / / An Error indicates serious problems that a reasonable application should not try to <nl> + / / catch , but due to issue https : / / github . com / checkstyle / checkstyle / issues / 2285 <nl> + / / we catch errors in ' processFiles ' method . Most such errors are abnormal conditions , <nl> + / / that is why we use PowerMockito to reproduce them . <nl> + final File mock = PowerMockito . mock ( File . class ) ; <nl> + / / Assume that I / O error is happened when we try to invoke ' lastModified ( ) ' method . <nl> + final String errorMessage = " Java Virtual Machine is broken " <nl> + + " or has run out of resources necessary for it to continue operating . " ; <nl> + final Error expectedError = new IOError ( new InternalError ( errorMessage ) ) ; <nl> + when ( mock . lastModified ( ) ) . thenThrow ( expectedError ) ; <nl> + final Checker checker = new Checker ( ) ; <nl> + final List < File > filesToProcess = new ArrayList < > ( ) ; <nl> + filesToProcess . add ( mock ) ; <nl> + try { <nl> + checker . process ( filesToProcess ) ; <nl> + fail ( " IOError is expected ! " ) ; <nl> + } <nl> + / / - @ cs [ IllegalCatchExtended ] Testing for catch Error is part of 100 % coverage . <nl> + catch ( Error error ) { <nl> + assertThat ( " Error cause differs from IOError " , <nl> + error . getCause ( ) , instanceOf ( IOError . class ) ) ; <nl> + assertThat ( " Error cause is not InternalError " , <nl> + error . getCause ( ) . getCause ( ) , instanceOf ( InternalError . class ) ) ; <nl> + assertEquals ( " Error message is not expected " , <nl> + errorMessage , error . getCause ( ) . getCause ( ) . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testCatchErrorWithCache ( ) throws Exception { <nl> + final File cacheFile = temporaryFolder . newFile ( ) ; <nl> + <nl> + final DefaultConfiguration checkerConfig = new DefaultConfiguration ( " configuration " ) ; <nl> + checkerConfig . addAttribute ( " charset " , StandardCharsets . UTF _ 8 . name ( ) ) ; <nl> + checkerConfig . addAttribute ( " cacheFile " , cacheFile . getPath ( ) ) ; <nl> + <nl> + final File mock = PowerMockito . mock ( File . class ) ; <nl> + final String errorMessage = " Java Virtual Machine is broken " <nl> + + " or has run out of resources necessary for it to continue operating . " ; <nl> + final Error expectedError = new IOError ( new InternalError ( errorMessage ) ) ; <nl> + when ( mock . getAbsolutePath ( ) ) . thenReturn ( " testFile " ) ; <nl> + when ( mock . getAbsoluteFile ( ) ) . thenThrow ( expectedError ) ; <nl> + final Checker checker = new Checker ( ) ; <nl> + checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; <nl> + checker . configure ( checkerConfig ) ; <nl> + final List < File > filesToProcess = new ArrayList < > ( ) ; <nl> + filesToProcess . add ( mock ) ; <nl> + try { <nl> + checker . process ( filesToProcess ) ; <nl> + fail ( " IOError is expected ! " ) ; <nl> + } <nl> + / / - @ cs [ IllegalCatchExtended ] Testing for catch Error is part of 100 % coverage . <nl> + catch ( Error error ) { <nl> + assertThat ( " Error cause differs from IOError " , <nl> + error . getCause ( ) , instanceOf ( IOError . class ) ) ; <nl> + assertEquals ( " Error message is not expected " , <nl> + errorMessage , error . getCause ( ) . getCause ( ) . getMessage ( ) ) ; <nl> + <nl> + / / destroy is called by Main <nl> + checker . destroy ( ) ; <nl> + <nl> + final Properties cache = new Properties ( ) ; <nl> + cache . load ( Files . newBufferedReader ( cacheFile . toPath ( ) ) ) ; <nl> + <nl> + assertEquals ( " Cache has unexpected size " , <nl> + 1 , cache . size ( ) ) ; <nl> + assertNull ( " testFile is not in cache " , <nl> + cache . getProperty ( " testFile " ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testCatchErrorWithCacheWithNoFileName ( ) throws Exception { <nl> + final File cacheFile = temporaryFolder . newFile ( ) ; <nl> + <nl> + final DefaultConfiguration checkerConfig = new DefaultConfiguration ( " configuration " ) ; <nl> + checkerConfig . addAttribute ( " charset " , StandardCharsets . UTF _ 8 . name ( ) ) ; <nl> + checkerConfig . addAttribute ( " cacheFile " , cacheFile . getPath ( ) ) ; <nl> + <nl> + final File mock = PowerMockito . mock ( File . class ) ; <nl> + final String errorMessage = " Java Virtual Machine is broken " <nl> + + " or has run out of resources necessary for it to continue operating . " ; <nl> + final Error expectedError = new IOError ( new InternalError ( errorMessage ) ) ; <nl> + when ( mock . getAbsolutePath ( ) ) . thenThrow ( expectedError ) ; <nl> + final Checker checker = new Checker ( ) ; <nl> + checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; <nl> + checker . configure ( checkerConfig ) ; <nl> + final List < File > filesToProcess = new ArrayList < > ( ) ; <nl> + filesToProcess . add ( mock ) ; <nl> + try { <nl> + checker . process ( filesToProcess ) ; <nl> + fail ( " IOError is expected ! " ) ; <nl> + } <nl> + / / - @ cs [ IllegalCatchExtended ] Testing for catch Error is part of 100 % coverage . <nl> + catch ( Error error ) { <nl> + assertThat ( " Error cause differs from IOError " , <nl> + error . getCause ( ) , instanceOf ( IOError . class ) ) ; <nl> + assertEquals ( " Error message is not expected " , <nl> + errorMessage , error . getCause ( ) . getCause ( ) . getMessage ( ) ) ; <nl> + <nl> + / / destroy is called by Main <nl> + checker . destroy ( ) ; <nl> + <nl> + final Properties cache = new Properties ( ) ; <nl> + cache . load ( Files . newBufferedReader ( cacheFile . toPath ( ) ) ) ; <nl> + <nl> + assertEquals ( " Cache has unexpected size " , <nl> + 1 , cache . size ( ) ) ; <nl> + } <nl> + } <nl> + <nl> / * * <nl> * It is OK to have long test method name here as it describes the test purpose . <nl> * / <nl> @ @ - 875 , 6 + 990 , 115 @ @ public class CheckerTest extends AbstractModuleTestSupport { <nl> } <nl> <nl> @ Test <nl> + public void testExceptionWithCache ( ) throws Exception { <nl> + final File cacheFile = temporaryFolder . newFile ( ) ; <nl> + <nl> + final DefaultConfiguration checkConfig = <nl> + createModuleConfig ( CheckWhichThrowsError . class ) ; <nl> + <nl> + final DefaultConfiguration treewalkerConfig = <nl> + createModuleConfig ( TreeWalker . class ) ; <nl> + treewalkerConfig . addChild ( checkConfig ) ; <nl> + <nl> + final DefaultConfiguration checkerConfig = createRootConfig ( treewalkerConfig ) ; <nl> + checkerConfig . addAttribute ( " charset " , StandardCharsets . UTF _ 8 . name ( ) ) ; <nl> + checkerConfig . addAttribute ( " cacheFile " , cacheFile . getPath ( ) ) ; <nl> + checkerConfig . addChild ( treewalkerConfig ) ; <nl> + <nl> + final Checker checker = createChecker ( checkerConfig ) ; <nl> + <nl> + final String filePath = getPath ( " InputChecker . java " ) ; <nl> + try { <nl> + checker . process ( Collections . singletonList ( new File ( filePath ) ) ) ; <nl> + fail ( " Exception is expected " ) ; <nl> + } <nl> + catch ( CheckstyleException ex ) { <nl> + assertEquals ( " Error message is not expected " , <nl> + " Exception was thrown while processing " + filePath , ex . getMessage ( ) ) ; <nl> + <nl> + / / destroy is called by Main <nl> + checker . destroy ( ) ; <nl> + <nl> + final Properties cache = new Properties ( ) ; <nl> + cache . load ( Files . newBufferedReader ( cacheFile . toPath ( ) ) ) ; <nl> + <nl> + assertEquals ( " Cache has unexpected size " , <nl> + 1 , cache . size ( ) ) ; <nl> + assertNull ( " testFile is not in cache " , <nl> + cache . getProperty ( filePath ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testExceptionWithNoFileName ( ) { <nl> + / / The idea of the test is to satisfy coverage rate . <nl> + / / An Error indicates serious problems that a reasonable application should not try to <nl> + / / catch , but due to issue https : / / github . com / checkstyle / checkstyle / issues / 2285 <nl> + / / we catch errors in ' processFiles ' method . Most such errors are abnormal conditions , <nl> + / / that is why we use PowerMockito to reproduce them . <nl> + final File mock = PowerMockito . mock ( File . class ) ; <nl> + final String errorMessage = " Security Exception " ; <nl> + final Exception expectedError = new SecurityException ( errorMessage ) ; <nl> + when ( mock . getAbsolutePath ( ) ) . thenThrow ( expectedError ) ; <nl> + final Checker checker = new Checker ( ) ; <nl> + final List < File > filesToProcess = new ArrayList < > ( ) ; <nl> + filesToProcess . add ( mock ) ; <nl> + try { <nl> + checker . process ( filesToProcess ) ; <nl> + fail ( " IOError is expected ! " ) ; <nl> + } <nl> + catch ( CheckstyleException ex ) { <nl> + assertThat ( " Error cause differs from SecurityException " , <nl> + ex . getCause ( ) , instanceOf ( SecurityException . class ) ) ; <nl> + assertEquals ( " Error message is not expected " , <nl> + errorMessage , ex . getCause ( ) . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testExceptionWithCacheAndNoFileName ( ) throws Exception { <nl> + final File cacheFile = temporaryFolder . newFile ( ) ; <nl> + <nl> + final DefaultConfiguration checkerConfig = new DefaultConfiguration ( " configuration " ) ; <nl> + checkerConfig . addAttribute ( " charset " , StandardCharsets . UTF _ 8 . name ( ) ) ; <nl> + checkerConfig . addAttribute ( " cacheFile " , cacheFile . getPath ( ) ) ; <nl> + <nl> + / / The idea of the test is to satisfy coverage rate . <nl> + / / An Error indicates serious problems that a reasonable application should not try to <nl> + / / catch , but due to issue https : / / github . com / checkstyle / checkstyle / issues / 2285 <nl> + / / we catch errors in ' processFiles ' method . Most such errors are abnormal conditions , <nl> + / / that is why we use PowerMockito to reproduce them . <nl> + final File mock = PowerMockito . mock ( File . class ) ; <nl> + final String errorMessage = " Security Exception " ; <nl> + final Exception expectedError = new SecurityException ( errorMessage ) ; <nl> + when ( mock . getAbsolutePath ( ) ) . thenThrow ( expectedError ) ; <nl> + final Checker checker = new Checker ( ) ; <nl> + checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; <nl> + checker . configure ( checkerConfig ) ; <nl> + final List < File > filesToProcess = new ArrayList < > ( ) ; <nl> + filesToProcess . add ( mock ) ; <nl> + try { <nl> + checker . process ( filesToProcess ) ; <nl> + fail ( " IOError is expected ! " ) ; <nl> + } <nl> + catch ( CheckstyleException ex ) { <nl> + assertThat ( " Error cause differs from SecurityException " , <nl> + ex . getCause ( ) , instanceOf ( SecurityException . class ) ) ; <nl> + assertEquals ( " Error message is not expected " , <nl> + errorMessage , ex . getCause ( ) . getMessage ( ) ) ; <nl> + <nl> + / / destroy is called by Main <nl> + checker . destroy ( ) ; <nl> + <nl> + final Properties cache = new Properties ( ) ; <nl> + cache . load ( Files . newBufferedReader ( cacheFile . toPath ( ) ) ) ; <nl> + <nl> + assertEquals ( " Cache has unexpected size " , <nl> + 1 , cache . size ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> public void testHaltOnExceptionOff ( ) throws Exception { <nl> final DefaultConfiguration checkConfig = <nl> createModuleConfig ( CheckWhichThrowsError . class ) ;
NEAREST DIFF (one line): diff - - git a / pom . xml b / pom . xml <nl> index 10cf128 . . 2936f24 100644 <nl> - - - a / pom . xml <nl> + + + b / pom . xml <nl> @ @ - 809 , 7 + 809 , 7 @ @ <nl> < regex > < pattern > . * . checks . javadoc . AtclauseOrderCheck < / pattern > < branchRate > 88 < / branchRate > < lineRate > 88 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . HtmlTag < / pattern > < branchRate > 75 < / branchRate > < lineRate > 90 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . JavadocMethodCheck < / pattern > < branchRate > 90 < / branchRate > < lineRate > 96 < / lineRate > < / regex > <nl> - < regex > < pattern > . * . checks . javadoc . JavadocNodeImpl < / pattern > < branchRate > 100 < / branchRate > < lineRate > 87 < / lineRate > < / regex > <nl> + < regex > < pattern > . * . checks . javadoc . JavadocNodeImpl < / pattern > < branchRate > 50 < / branchRate > < lineRate > 84 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . JavadocPackageCheck < / pattern > < branchRate > 80 < / branchRate > < lineRate > 95 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . JavadocParagraphCheck < / pattern > < branchRate > 92 < / branchRate > < lineRate > 100 < / lineRate > < / regex > <nl> < regex > < pattern > . * . checks . javadoc . JavadocStyleCheck < / pattern > < branchRate > 89 < / branchRate > < lineRate > 97 < / lineRate > < / regex > <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocNodeImpl . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocNodeImpl . java <nl> index 3845971 . . cbba929 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocNodeImpl . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocNodeImpl . java <nl> @ @ - 94 , 8 + 94 , 9 @ @ public class JavadocNodeImpl implements DetailNode <nl> public DetailNode [ ] getChildren ( ) <nl> { <nl> if ( children = = null ) { <nl> - return children ; <nl> - } else { <nl> + return null ; <nl> + } <nl> + else { <nl> return Arrays . copyOf ( children , children . length ) ; <nl> } <nl> }

TEST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / Checker . java b / src / main / java / com / puppycrawl / tools / checkstyle / Checker . java 
 index d3320a7 . . 3e346b0 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / Checker . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / Checker . java 
 @ @ - 273 , 10 + 273 , 12 @ @ public class Checker extends AutomaticBean implements MessageDispatcher , RootMod 
 * @ throws CheckstyleException if error condition within Checkstyle occurs . 
 * @ noinspection ProhibitedExceptionThrown 
 * / 
 + / / - @ cs [ CyclomaticComplexity ] no easy way to split this logic of processing the file 
 private void processFiles ( List < File > files ) throws CheckstyleException { 
 for ( final File file : files ) { 
 + String fileName = null ; 
 try { 
 - final String fileName = file . getAbsolutePath ( ) ; 
 + fileName = file . getAbsolutePath ( ) ; 
 final long timestamp = file . lastModified ( ) ; 
 if ( cacheFile ! = null & & cacheFile . isInCache ( fileName , timestamp ) 
 | | ! acceptFileStarted ( fileName ) ) { 
 @ @ - 293 , 11 + 295 , 19 @ @ public class Checker extends AutomaticBean implements MessageDispatcher , RootMod 
 / / - @ cs [ IllegalCatch ] There is no other way to deliver filename that was under 
 / / processing . See https : / / github . com / checkstyle / checkstyle / issues / 2285 
 catch ( Exception ex ) { 
 + if ( fileName ! = null & & cacheFile ! = null ) { 
 + cacheFile . remove ( fileName ) ; 
 + } 
 + 
 / / We need to catch all exceptions to put a reason failure ( file name ) in exception 
 throw new CheckstyleException ( " Exception was thrown while processing " 
 + file . getPath ( ) , ex ) ; 
 } 
 catch ( Error error ) { 
 + if ( fileName ! = null & & cacheFile ! = null ) { 
 + cacheFile . remove ( fileName ) ; 
 + } 
 + 
 / / We need to catch all errors to put a reason failure ( file name ) in error 
 throw new Error ( " Error was thrown while processing " + file . getPath ( ) , error ) ; 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / CheckerTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / CheckerTest . java 
 index d27e6f7 . . 641bed4 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / CheckerTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / CheckerTest . java 
 @ @ - 674 , 6 + 674 , 7 @ @ public class CheckerTest extends AbstractModuleTestSupport { 
 + " or has run out of resources necessary for it to continue operating . " ; 
 final Error expectedError = new IOError ( new InternalError ( errorMessage ) ) ; 
 when ( mock . lastModified ( ) ) . thenThrow ( expectedError ) ; 
 + when ( mock . getAbsolutePath ( ) ) . thenReturn ( " testFile " ) ; 
 final Checker checker = new Checker ( ) ; 
 final List < File > filesToProcess = new ArrayList < > ( ) ; 
 filesToProcess . add ( mock ) ; 
 @ @ - 692 , 6 + 693 , 120 @ @ public class CheckerTest extends AbstractModuleTestSupport { 
 } 
 } 
 
 + @ Test 
 + public void testCatchErrorWithNoFileName ( ) throws Exception { 
 + / / The idea of the test is to satisfy coverage rate . 
 + / / An Error indicates serious problems that a reasonable application should not try to 
 + / / catch , but due to issue https : / / github . com / checkstyle / checkstyle / issues / 2285 
 + / / we catch errors in ' processFiles ' method . Most such errors are abnormal conditions , 
 + / / that is why we use PowerMockito to reproduce them . 
 + final File mock = PowerMockito . mock ( File . class ) ; 
 + / / Assume that I / O error is happened when we try to invoke ' lastModified ( ) ' method . 
 + final String errorMessage = " Java Virtual Machine is broken " 
 + + " or has run out of resources necessary for it to continue operating . " ; 
 + final Error expectedError = new IOError ( new InternalError ( errorMessage ) ) ; 
 + when ( mock . lastModified ( ) ) . thenThrow ( expectedError ) ; 
 + final Checker checker = new Checker ( ) ; 
 + final List < File > filesToProcess = new ArrayList < > ( ) ; 
 + filesToProcess . add ( mock ) ; 
 + try { 
 + checker . process ( filesToProcess ) ; 
 + fail ( " IOError is expected ! " ) ; 
 + } 
 + / / - @ cs [ IllegalCatchExtended ] Testing for catch Error is part of 100 % coverage . 
 + catch ( Error error ) { 
 + assertThat ( " Error cause differs from IOError " , 
 + error . getCause ( ) , instanceOf ( IOError . class ) ) ; 
 + assertThat ( " Error cause is not InternalError " , 
 + error . getCause ( ) . getCause ( ) , instanceOf ( InternalError . class ) ) ; 
 + assertEquals ( " Error message is not expected " , 
 + errorMessage , error . getCause ( ) . getCause ( ) . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testCatchErrorWithCache ( ) throws Exception { 
 + final File cacheFile = temporaryFolder . newFile ( ) ; 
 + 
 + final DefaultConfiguration checkerConfig = new DefaultConfiguration ( " configuration " ) ; 
 + checkerConfig . addAttribute ( " charset " , StandardCharsets . UTF _ 8 . name ( ) ) ; 
 + checkerConfig . addAttribute ( " cacheFile " , cacheFile . getPath ( ) ) ; 
 + 
 + final File mock = PowerMockito . mock ( File . class ) ; 
 + final String errorMessage = " Java Virtual Machine is broken " 
 + + " or has run out of resources necessary for it to continue operating . " ; 
 + final Error expectedError = new IOError ( new InternalError ( errorMessage ) ) ; 
 + when ( mock . getAbsolutePath ( ) ) . thenReturn ( " testFile " ) ; 
 + when ( mock . getAbsoluteFile ( ) ) . thenThrow ( expectedError ) ; 
 + final Checker checker = new Checker ( ) ; 
 + checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; 
 + checker . configure ( checkerConfig ) ; 
 + final List < File > filesToProcess = new ArrayList < > ( ) ; 
 + filesToProcess . add ( mock ) ; 
 + try { 
 + checker . process ( filesToProcess ) ; 
 + fail ( " IOError is expected ! " ) ; 
 + } 
 + / / - @ cs [ IllegalCatchExtended ] Testing for catch Error is part of 100 % coverage . 
 + catch ( Error error ) { 
 + assertThat ( " Error cause differs from IOError " , 
 + error . getCause ( ) , instanceOf ( IOError . class ) ) ; 
 + assertEquals ( " Error message is not expected " , 
 + errorMessage , error . getCause ( ) . getCause ( ) . getMessage ( ) ) ; 
 + 
 + / / destroy is called by Main 
 + checker . destroy ( ) ; 
 + 
 + final Properties cache = new Properties ( ) ; 
 + cache . load ( Files . newBufferedReader ( cacheFile . toPath ( ) ) ) ; 
 + 
 + assertEquals ( " Cache has unexpected size " , 
 + 1 , cache . size ( ) ) ; 
 + assertNull ( " testFile is not in cache " , 
 + cache . getProperty ( " testFile " ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testCatchErrorWithCacheWithNoFileName ( ) throws Exception { 
 + final File cacheFile = temporaryFolder . newFile ( ) ; 
 + 
 + final DefaultConfiguration checkerConfig = new DefaultConfiguration ( " configuration " ) ; 
 + checkerConfig . addAttribute ( " charset " , StandardCharsets . UTF _ 8 . name ( ) ) ; 
 + checkerConfig . addAttribute ( " cacheFile " , cacheFile . getPath ( ) ) ; 
 + 
 + final File mock = PowerMockito . mock ( File . class ) ; 
 + final String errorMessage = " Java Virtual Machine is broken " 
 + + " or has run out of resources necessary for it to continue operating . " ; 
 + final Error expectedError = new IOError ( new InternalError ( errorMessage ) ) ; 
 + when ( mock . getAbsolutePath ( ) ) . thenThrow ( expectedError ) ; 
 + final Checker checker = new Checker ( ) ; 
 + checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; 
 + checker . configure ( checkerConfig ) ; 
 + final List < File > filesToProcess = new ArrayList < > ( ) ; 
 + filesToProcess . add ( mock ) ; 
 + try { 
 + checker . process ( filesToProcess ) ; 
 + fail ( " IOError is expected ! " ) ; 
 + } 
 + / / - @ cs [ IllegalCatchExtended ] Testing for catch Error is part of 100 % coverage . 
 + catch ( Error error ) { 
 + assertThat ( " Error cause differs from IOError " , 
 + error . getCause ( ) , instanceOf ( IOError . class ) ) ; 
 + assertEquals ( " Error message is not expected " , 
 + errorMessage , error . getCause ( ) . getCause ( ) . getMessage ( ) ) ; 
 + 
 + / / destroy is called by Main 
 + checker . destroy ( ) ; 
 + 
 + final Properties cache = new Properties ( ) ; 
 + cache . load ( Files . newBufferedReader ( cacheFile . toPath ( ) ) ) ; 
 + 
 + assertEquals ( " Cache has unexpected size " , 
 + 1 , cache . size ( ) ) ; 
 + } 
 + } 
 + 
 / * * 
 * It is OK to have long test method name here as it describes the test purpose . 
 * / 
 @ @ - 875 , 6 + 990 , 115 @ @ public class CheckerTest extends AbstractModuleTestSupport { 
 } 
 
 @ Test 
 + public void testExceptionWithCache ( ) throws Exception { 
 + final File cacheFile = temporaryFolder . newFile ( ) ; 
 + 
 + final DefaultConfiguration checkConfig = 
 + createModuleConfig ( CheckWhichThrowsError . class ) ; 
 + 
 + final DefaultConfiguration treewalkerConfig = 
 + createModuleConfig ( TreeWalker . class ) ; 
 + treewalkerConfig . addChild ( checkConfig ) ; 
 + 
 + final DefaultConfiguration checkerConfig = createRootConfig ( treewalkerConfig ) ; 
 + checkerConfig . addAttribute ( " charset " , StandardCharsets . UTF _ 8 . name ( ) ) ; 
 + checkerConfig . addAttribute ( " cacheFile " , cacheFile . getPath ( ) ) ; 
 + checkerConfig . addChild ( treewalkerConfig ) ; 
 + 
 + final Checker checker = createChecker ( checkerConfig ) ; 
 + 
 + final String filePath = getPath ( " InputChecker . java " ) ; 
 + try { 
 + checker . process ( Collections . singletonList ( new File ( filePath ) ) ) ; 
 + fail ( " Exception is expected " ) ; 
 + } 
 + catch ( CheckstyleException ex ) { 
 + assertEquals ( " Error message is not expected " , 
 + " Exception was thrown while processing " + filePath , ex . getMessage ( ) ) ; 
 + 
 + / / destroy is called by Main 
 + checker . destroy ( ) ; 
 + 
 + final Properties cache = new Properties ( ) ; 
 + cache . load ( Files . newBufferedReader ( cacheFile . toPath ( ) ) ) ; 
 + 
 + assertEquals ( " Cache has unexpected size " , 
 + 1 , cache . size ( ) ) ; 
 + assertNull ( " testFile is not in cache " , 
 + cache . getProperty ( filePath ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testExceptionWithNoFileName ( ) { 
 + / / The idea of the test is to satisfy coverage rate . 
 + / / An Error indicates serious problems that a reasonable application should not try to 
 + / / catch , but due to issue https : / / github . com / checkstyle / checkstyle / issues / 2285 
 + / / we catch errors in ' processFiles ' method . Most such errors are abnormal conditions , 
 + / / that is why we use PowerMockito to reproduce them . 
 + final File mock = PowerMockito . mock ( File . class ) ; 
 + final String errorMessage = " Security Exception " ; 
 + final Exception expectedError = new SecurityException ( errorMessage ) ; 
 + when ( mock . getAbsolutePath ( ) ) . thenThrow ( expectedError ) ; 
 + final Checker checker = new Checker ( ) ; 
 + final List < File > filesToProcess = new ArrayList < > ( ) ; 
 + filesToProcess . add ( mock ) ; 
 + try { 
 + checker . process ( filesToProcess ) ; 
 + fail ( " IOError is expected ! " ) ; 
 + } 
 + catch ( CheckstyleException ex ) { 
 + assertThat ( " Error cause differs from SecurityException " , 
 + ex . getCause ( ) , instanceOf ( SecurityException . class ) ) ; 
 + assertEquals ( " Error message is not expected " , 
 + errorMessage , ex . getCause ( ) . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testExceptionWithCacheAndNoFileName ( ) throws Exception { 
 + final File cacheFile = temporaryFolder . newFile ( ) ; 
 + 
 + final DefaultConfiguration checkerConfig = new DefaultConfiguration ( " configuration " ) ; 
 + checkerConfig . addAttribute ( " charset " , StandardCharsets . UTF _ 8 . name ( ) ) ; 
 + checkerConfig . addAttribute ( " cacheFile " , cacheFile . getPath ( ) ) ; 
 + 
 + / / The idea of the test is to satisfy coverage rate . 
 + / / An Error indicates serious problems that a reasonable application should not try to 
 + / / catch , but due to issue https : / / github . com / checkstyle / checkstyle / issues / 2285 
 + / / we catch errors in ' processFiles ' method . Most such errors are abnormal conditions , 
 + / / that is why we use PowerMockito to reproduce them . 
 + final File mock = PowerMockito . mock ( File . class ) ; 
 + final String errorMessage = " Security Exception " ; 
 + final Exception expectedError = new SecurityException ( errorMessage ) ; 
 + when ( mock . getAbsolutePath ( ) ) . thenThrow ( expectedError ) ; 
 + final Checker checker = new Checker ( ) ; 
 + checker . setModuleClassLoader ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; 
 + checker . configure ( checkerConfig ) ; 
 + final List < File > filesToProcess = new ArrayList < > ( ) ; 
 + filesToProcess . add ( mock ) ; 
 + try { 
 + checker . process ( filesToProcess ) ; 
 + fail ( " IOError is expected ! " ) ; 
 + } 
 + catch ( CheckstyleException ex ) { 
 + assertThat ( " Error cause differs from SecurityException " , 
 + ex . getCause ( ) , instanceOf ( SecurityException . class ) ) ; 
 + assertEquals ( " Error message is not expected " , 
 + errorMessage , ex . getCause ( ) . getMessage ( ) ) ; 
 + 
 + / / destroy is called by Main 
 + checker . destroy ( ) ; 
 + 
 + final Properties cache = new Properties ( ) ; 
 + cache . load ( Files . newBufferedReader ( cacheFile . toPath ( ) ) ) ; 
 + 
 + assertEquals ( " Cache has unexpected size " , 
 + 1 , cache . size ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 public void testHaltOnExceptionOff ( ) throws Exception { 
 final DefaultConfiguration checkConfig = 
 createModuleConfig ( CheckWhichThrowsError . class ) ;

NEAREST DIFF:
diff - - git a / pom . xml b / pom . xml 
 index 10cf128 . . 2936f24 100644 
 - - - a / pom . xml 
 + + + b / pom . xml 
 @ @ - 809 , 7 + 809 , 7 @ @ 
 < regex > < pattern > . * . checks . javadoc . AtclauseOrderCheck < / pattern > < branchRate > 88 < / branchRate > < lineRate > 88 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . HtmlTag < / pattern > < branchRate > 75 < / branchRate > < lineRate > 90 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . JavadocMethodCheck < / pattern > < branchRate > 90 < / branchRate > < lineRate > 96 < / lineRate > < / regex > 
 - < regex > < pattern > . * . checks . javadoc . JavadocNodeImpl < / pattern > < branchRate > 100 < / branchRate > < lineRate > 87 < / lineRate > < / regex > 
 + < regex > < pattern > . * . checks . javadoc . JavadocNodeImpl < / pattern > < branchRate > 50 < / branchRate > < lineRate > 84 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . JavadocPackageCheck < / pattern > < branchRate > 80 < / branchRate > < lineRate > 95 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . JavadocParagraphCheck < / pattern > < branchRate > 92 < / branchRate > < lineRate > 100 < / lineRate > < / regex > 
 < regex > < pattern > . * . checks . javadoc . JavadocStyleCheck < / pattern > < branchRate > 89 < / branchRate > < lineRate > 97 < / lineRate > < / regex > 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocNodeImpl . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocNodeImpl . java 
 index 3845971 . . cbba929 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocNodeImpl . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / javadoc / JavadocNodeImpl . java 
 @ @ - 94 , 8 + 94 , 9 @ @ public class JavadocNodeImpl implements DetailNode 
 public DetailNode [ ] getChildren ( ) 
 { 
 if ( children = = null ) { 
 - return children ; 
 - } else { 
 + return null ; 
 + } 
 + else { 
 return Arrays . copyOf ( children , children . length ) ; 
 } 
 }
