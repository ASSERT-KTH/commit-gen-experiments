BLEU SCORE: 0.028398387225677897

TEST MSG: minor : formatting for java . g to follow 100 symbols per line rule
GENERATED MSG: Incorporate changes made to the ANTLR Java grammar

TEST DIFF (one line): diff - - git a / config / checkstyle _ checks . xml b / config / checkstyle _ checks . xml <nl> index ed6feca . . 923dbfd 100644 <nl> - - - a / config / checkstyle _ checks . xml <nl> + + + b / config / checkstyle _ checks . xml <nl> @ @ - 16 , 7 + 16 , 7 @ @ <nl> <nl> < property name = " severity " value = " error " / > <nl> <nl> - < property name = " fileExtensions " value = " java , properties , xml " / > <nl> + < property name = " fileExtensions " value = " java , properties , xml , g , g4 " / > <nl> <nl> < ! - - Filters - - > <nl> < module name = " SeverityMatchFilter " > <nl> @ @ - 375 , 6 + 375 , 11 @ @ <nl> <nl> < ! - - Regexp - - > <nl> < module name = " Regexp " / > <nl> + < module name = " Regexp " > <nl> + < property name = " format " value = " ^ ( ? ! ( . * http | import ) ) . { 101 , } $ " / > <nl> + < property name = " illegalPattern " value = " true " / > <nl> + < property name = " message " value = " Line should not be longer then 100 symbols " / > <nl> + < / module > <nl> < module name = " RegexpSinglelineJava " / > <nl> < module name = " RegexpSinglelineJava " > <nl> < property name = " format " value = " [ ^ \ p { ASCII } ] " / > <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / whitespace / OperatorWrapCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / whitespace / OperatorWrapCheck . java <nl> index acd93e6 . . 028cb1b 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / whitespace / OperatorWrapCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / whitespace / OperatorWrapCheck . java <nl> @ @ - 85 , 9 + 85 , 10 @ @ import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; <nl> * < pre > <nl> * & lt ; module name = " OperatorWrap " & gt ; <nl> * & lt ; property name = " tokens " <nl> - * value = " ASSIGN , DIV _ ASSIGN , PLUS _ ASSIGN , MINUS _ ASSIGN , STAR _ ASSIGN , MOD _ ASSIGN , SR _ ASSIGN , BSR _ ASSIGN , SL _ ASSIGN , BXOR _ ASSIGN , BOR _ ASSIGN , BAND _ ASSIGN " / & gt ; <nl> + * value = " ASSIGN , DIV _ ASSIGN , PLUS _ ASSIGN , MINUS _ ASSIGN , STAR _ ASSIGN , MOD _ ASSIGN <nl> + * , SR _ ASSIGN , BSR _ ASSIGN , SL _ ASSIGN , BXOR _ ASSIGN , BOR _ ASSIGN , BAND _ ASSIGN " / & gt ; <nl> * & lt ; property name = " option " value = " eol " / & gt ; <nl> - * & lt ; / module & gt ; <nl> + * & lt ; / module & gt ; <nl> * < / pre > <nl> * <nl> * @ author Rick Giles <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / java . g b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / java . g <nl> index acc6d5f . . f44972c 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / java . g <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / java . g <nl> @ @ - 100 , 7 + 100 , 7 @ @ tokens { <nl> / / we need to put it to the end to maintain binary compatibility <nl> / / with previous versions <nl> DO _ WHILE ; <nl> - <nl> + <nl> / / Tokens for Java 1 . 7 language enhancements <nl> RESOURCE _ SPECIFICATION ; RESOURCES ; RESOURCE ; <nl> <nl> @ @ - 126 , 8 + 126 , 8 @ @ tokens { <nl> * typeArguments production . This is necessary because SR and BSR <nl> * tokens have significance ( the extra ' > ' characters ) not only for the production <nl> * that sees them but also productions higher in the stack ( possibly right up to an outer - most <nl> - * typeParameters production ) . As the stack of the typeArguments / typeParameters productions unwind , <nl> - * any ' > ' characters seen prematurely through SRs or BSRs are reconciled . <nl> + * typeParameters production ) . As the stack of the typeArguments / typeParameters productions <nl> + * unwind , any ' > ' characters seen prematurely through SRs or BSRs are reconciled . <nl> * / <nl> private int gtToReconcile = 0 ; <nl> <nl> @ @ - 164 , 7 + 164 , 8 @ @ tokens { <nl> gtToReconcile - = 1 ; <nl> CommonHiddenStreamToken gtToken = new CommonHiddenStreamToken ( GENERIC _ END , " > " ) ; <nl> gtToken . setLine ( currentGtSequence . getLineNo ( ) ) ; <nl> - gtToken . setColumn ( currentGtSequence . getColumnNo ( ) + ( currentGtSequence . getText ( ) . length ( ) - gtToReconcile ) ) ; <nl> + gtToken . setColumn ( currentGtSequence . getColumnNo ( ) <nl> + + ( currentGtSequence . getText ( ) . length ( ) - gtToReconcile ) ) ; <nl> return ( DetailAST ) astFactory . create ( gtToken ) ; <nl> } <nl> <nl> @ @ - 227 , 7 + 228 , 8 @ @ packageDefinition <nl> / / Import statement : import followed by a package or class name <nl> importDefinition <nl> options { defaultErrorHandler = true ; } <nl> - : i : " import " ^ { # i . setType ( IMPORT ) ; } ( " static " { # i . setType ( STATIC _ IMPORT ) ; } ) ? identifierStar SEMI <nl> + : i : " import " ^ { # i . setType ( IMPORT ) ; } <nl> + ( " static " { # i . setType ( STATIC _ IMPORT ) ; } ) ? identifierStar SEMI <nl> | SEMI <nl> ; <nl> <nl> @ @ - 286 , 7 + 288 , 7 @ @ classOrInterfaceType [ boolean addImagNode ] <nl> ) * <nl> ; <nl> <nl> - / / A generic type argument is a class type , a possibly bounded wildcard type or a built - in type array <nl> + / / A generic type argument is a class type , a possibly bounded wildcard type or built - in type array <nl> typeArgument [ boolean addImagNode ] <nl> : ( ( { LA ( 1 ) = = AT } ? annotations <nl> | ) ( <nl> @ @ - 307 , 7 + 309 , 8 @ @ typeArguments [ boolean addImagNode ] <nl> : <nl> { currentLtLevel = ltCounter ; } <nl> lt : LT { # lt . setType ( GENERIC _ START ) ; ; ltCounter + + ; } <nl> - / / ( Dinesh Bolkensteyn ) Added support for Java 7 diamond notation ( disabled ambiguous warnings since generated code seems to work ) <nl> + / / ( Dinesh Bolkensteyn ) Added support for Java 7 diamond notation <nl> + / / ( disabled ambiguous warnings since generated code seems to work ) <nl> ( options { generateAmbigWarnings = false ; } : typeArgument [ addImagNode ] <nl> ( options { greedy = true ; } : / / match as many as possible <nl> / / If there are any ' > ' to reconcile <nl> @ @ - 437 , 8 + 440 , 7 @ @ modifiers <nl> / / Semantic check that we aren ' t matching @ interface as this is not an annotation <nl> / / A nicer way to do this would be , um , nice <nl> { LA ( 1 ) = = AT & & ! LT ( 2 ) . getText ( ) . equals ( " interface " ) } ? annotation <nl> - <nl> - <nl> + <nl> ) * <nl> <nl> { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } <nl> @ @ - 462 , 7 + 464 , 11 @ @ modifier <nl> ; <nl> <nl> annotation ! <nl> - : AT i : identifier ( options { generateAmbigWarnings = false ; } : l : LPAREN ( args : annotationArguments ) ? r : RPAREN ) ? <nl> + : AT i : identifier <nl> + ( options { generateAmbigWarnings = false ; } : <nl> + l : LPAREN ( args : annotationArguments ) ? <nl> + r : RPAREN <nl> + ) ? <nl> { # annotation = # ( # [ ANNOTATION , " ANNOTATION " ] , AT , i , l , args , r ) ; } <nl> ; <nl> <nl> @ @ - 481 , 7 + 487 , 8 @ @ annotationMemberValuePairs <nl> <nl> annotationMemberValuePair ! <nl> : i : IDENT a : ASSIGN v : annotationMemberValueInitializer <nl> - { # annotationMemberValuePair = # ( # [ ANNOTATION _ MEMBER _ VALUE _ PAIR , " ANNOTATION _ MEMBER _ VALUE _ PAIR " ] , i , a , v ) ; } <nl> + { # annotationMemberValuePair = <nl> + # ( # [ ANNOTATION _ MEMBER _ VALUE _ PAIR , " ANNOTATION _ MEMBER _ VALUE _ PAIR " ] , i , a , v ) ; } <nl> ; <nl> <nl> annotationMemberValueInitializer <nl> @ @ - 862 , 10 + 869 , 12 @ @ explicitConstructorInvocation <nl> <nl> variableDefinitions [ AST mods , AST t ] <nl> : variableDeclarator [ ( AST ) getASTFactory ( ) . dupTree ( mods ) , <nl> - ( AST ) getASTFactory ( ) . dupList ( t ) ] / / dupList as this also copies siblings ( like TYPE _ ARGUMENTS ) <nl> + / / dupList as this also copies siblings ( like TYPE _ ARGUMENTS ) <nl> + ( AST ) getASTFactory ( ) . dupList ( t ) ] <nl> ( COMMA <nl> variableDeclarator [ ( AST ) getASTFactory ( ) . dupTree ( mods ) , <nl> - ( AST ) getASTFactory ( ) . dupList ( t ) ] / / dupList as this also copies siblings ( like TYPE _ ARGUMENTS ) <nl> + / / dupList as this also copies siblings ( like TYPE _ ARGUMENTS ) <nl> + ( AST ) getASTFactory ( ) . dupList ( t ) ] <nl> ) * <nl> ; <nl> <nl> @ @ - 944 , 9 + 953 , 11 @ @ throwsClause <nl> / / If a parameter is variable length ( e . g . String . . . myArg ) it is the right - most parameter <nl> parameterDeclarationList <nl> / / The semantic check in ( . . . . ) * block is flagged as superfluous , and seems superfluous but <nl> - / / is the only way I could make this work . If my understanding is correct this is a known bug in Antlr <nl> + / / is the only way I could make this work . <nl> + / / If my understanding is correct this is a known bug in Antlr <nl> : ( ( parameterDeclaration ) = > parameterDeclaration <nl> - ( options { warnWhenFollowAmbig = false ; } : ( COMMA parameterDeclaration ) = > COMMA parameterDeclaration ) * <nl> + ( options { warnWhenFollowAmbig = false ; } : <nl> + ( COMMA parameterDeclaration ) = > COMMA parameterDeclaration ) * <nl> ( COMMA variableLengthParameterDeclaration ) ? <nl> | <nl> variableLengthParameterDeclaration <nl> @ @ - 965 , 7 + 976 , 8 @ @ variableLengthParameterDeclaration ! <nl> parameterModifier <nl> / / final can appear amongst annotations in any order - greedily consume any preceding <nl> / / annotations to shut nond - eterminism warnings off <nl> - : ( options { greedy = true ; } : annotation ) * ( f : " final " ) ? ( options { warnWhenFollowAmbig = false ; } : annotation ) * <nl> + : ( options { greedy = true ; } : annotation ) * ( f : " final " ) ? <nl> + ( options { warnWhenFollowAmbig = false ; } : annotation ) * <nl> { # parameterModifier = # ( # [ MODIFIERS , " MODIFIERS " ] , # parameterModifier ) ; } <nl> ; <nl> <nl> @ @ - 979 , 7 + 991 , 8 @ @ parameterDeclaration ! <nl> / / Added for support Java7 ' s " multi - catch " , several types separated by ' | ' <nl> catchParameterDeclaration ! <nl> : pm : parameterModifier mct : multiCatchTypes id : IDENT <nl> - { # catchParameterDeclaration = # ( # [ PARAMETER _ DEF , " PARAMETER _ DEF " ] , pm , # ( [ TYPE , " TYPE " ] , mct ) , id ) ; } <nl> + { # catchParameterDeclaration = <nl> + # ( # [ PARAMETER _ DEF , " PARAMETER _ DEF " ] , pm , # ( [ TYPE , " TYPE " ] , mct ) , id ) ; } <nl> ; <nl> <nl> multiCatchTypes <nl> @ @ - 1137 , 8 + 1150 , 8 @ @ aCase <nl> caseSList <nl> : <nl> ( <nl> - / / Here was nondeterministic warnig between default block into switch and default modifier <nl> - / / on methods ( Java8 ) . But we have semantic check for this . <nl> + / / Here was nondeterministic warnig between default block into switch <nl> + / / and default modifier on methods ( Java8 ) . But we have semantic check for this . <nl> options { <nl> warnWhenFollowAmbig = false ; <nl> } <nl> @ @ - 1184 , 7 + 1197 , 8 @ @ tryBlock <nl> <nl> resourceSpecification <nl> : LPAREN resources ( SEMI ) ? RPAREN <nl> - { # resourceSpecification = # ( [ RESOURCE _ SPECIFICATION , " RESOURCE _ SPECIFICATION " ] , # resourceSpecification ) ; } <nl> + { # resourceSpecification = <nl> + # ( [ RESOURCE _ SPECIFICATION , " RESOURCE _ SPECIFICATION " ] , # resourceSpecification ) ; } <nl> ; <nl> <nl> resources <nl> @ @ - 1197 , 7 + 1211 , 7 @ @ resource <nl> : modifiers typeSpec [ true ] IDENT resource _ assign <nl> { # resource = # ( [ RESOURCE , " RESOURCE " ] , # resource ) ; } <nl> ; <nl> - <nl> + <nl> resource _ assign <nl> : ASSIGN ^ expression <nl> ; <nl> @ @ - 1353 , 7 + 1367 , 8 @ @ shiftExpression <nl> <nl> / / binary addition / subtraction ( level 3 ) <nl> additiveExpression <nl> - : multiplicativeExpression ( options { warnWhenFollowAmbig = false ; } : ( PLUS ^ | MINUS ^ ) multiplicativeExpression ) * <nl> + : multiplicativeExpression ( options { warnWhenFollowAmbig = false ; } : <nl> + ( PLUS ^ | MINUS ^ ) multiplicativeExpression ) * <nl> ; <nl> <nl> <nl> @ @ - 1408 , 7 + 1423 , 7 @ @ typeCastParameters <nl> postfixExpression <nl> : primaryExpression / / start with a primary <nl> <nl> - ( options { warnWhenFollowAmbig = false ; } : / / qualified id ( id . id . id . id . . . ) - - build the name <nl> + ( options { warnWhenFollowAmbig = false ; } : / / qualified id ( id . id . id . id . . . ) - - build the name <nl> DOT ^ <nl> ( ( typeArguments [ false ] ) ? <nl> ( IDENT ( ( typeArguments [ false ] DOUBLE _ COLON ) = > typeArguments [ false ] ) ? <nl> @ @ - 1420 , 7 + 1435 , 9 @ @ postfixExpression <nl> | annotations <nl> ) <nl> <nl> - / / Java 8 method references . For example : List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ; numbers . forEach ( System . out : : println ) ; <nl> + / / Java 8 method references . <nl> + / / For example : List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ; <nl> + / / numbers . forEach ( System . out : : println ) ; <nl> | <nl> dc : DOUBLE _ COLON ^ { # dc . setType ( METHOD _ REF ) ; } <nl> ( <nl> @ @ - 1433 , 7 + 1450 , 8 @ @ postfixExpression <nl> / / is the _ last _ qualifier . <nl> <nl> / / allow ClassName [ ] . class or just ClassName [ ] <nl> - | ( options { warnWhenFollowAmbig = false ; } : lbc : LBRACK ^ { # lbc . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ) + <nl> + | ( options { warnWhenFollowAmbig = false ; } : <nl> + lbc : LBRACK ^ { # lbc . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ) + <nl> / / Since java 8 here can be method reference <nl> ( options { warnWhenFollowAmbig = false ; } : DOT ^ " class " ) ? <nl> <nl> @ @ - 1474 , 7 + 1492 , 8 @ @ primaryExpression <nl> | " super " <nl> / / look for int . class and int [ ] . class and int [ ] <nl> | builtInType <nl> - ( options { warnWhenFollowAmbig = false ; } : lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ) * <nl> + ( options { warnWhenFollowAmbig = false ; } : <nl> + lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ) * <nl> / / Since java 8 here can be method reference <nl> ( options { warnWhenFollowAmbig = false ; } : DOT ^ " class " ) ? <nl> ; <nl> @ @ - 1862 , 11 + 1881 , 11 @ @ VOCAB <nl> ; <nl> <nl> protected ID _ START : <nl> - ' _ ' | ' $ ' | <nl> - ( <nl> + ' _ ' | ' $ ' | <nl> + ( <nl> { Character . isJavaIdentifierStart ( LA ( 1 ) ) } ? <nl> ~ ( <nl> - ' _ ' | ' $ ' | ' / ' | ' * ' | ' 0 ' . . ' 9 ' | <nl> + ' _ ' | ' $ ' | ' / ' | ' * ' | ' 0 ' . . ' 9 ' | <nl> ' . ' | ' \ ' ' | ' \ \ ' | ' " ' | ' \ t ' | ' \ n ' | <nl> ' \ r ' | ' ' | ' \ f ' | ' ( ' | ' ) ' | <nl> ' { ' | ' } ' | ' [ ' | ' ] ' | ' ; ' | ' , ' | ' = ' | <nl> @ @ - 1886 , 7 + 1905 , 7 @ @ protected ID _ START : <nl> } <nl> <nl> protected ID _ PART : <nl> - ' _ ' | ' $ ' | <nl> + ' _ ' | ' $ ' | <nl> ( <nl> { Character . isJavaIdentifierPart ( LA ( 1 ) ) } ? <nl> ~ ( <nl> @ @ - 1944 , 21 + 1963 , 29 @ @ NUM _ INT <nl> <nl> protected INT _ LITERAL <nl> : ( ' 0 ' <nl> - ( ( ' x ' | ' X ' ) ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? / / Hexa <nl> - | ( ' b ' | ' B ' ) ( BINARY _ DIGIT ) ( ( BINARY _ DIGIT | ' _ ' ) * ( BINARY _ DIGIT ) ) ? / / Binary <nl> - | ( ( ( ' 0 ' . . ' 7 ' ) | ' _ ' ) * ( ' 0 ' . . ' 7 ' ) ) ? / / If empty 0 , otherwise octal ( which may start with an underscore ) <nl> + / / Hexa <nl> + ( ( ' x ' | ' X ' ) ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? <nl> + / / Binary <nl> + | ( ' b ' | ' B ' ) ( BINARY _ DIGIT ) ( ( BINARY _ DIGIT | ' _ ' ) * ( BINARY _ DIGIT ) ) ? <nl> + / / If empty 0 , otherwise octal ( which may start with an underscore ) <nl> + | ( ( ( ' 0 ' . . ' 7 ' ) | ' _ ' ) * ( ' 0 ' . . ' 7 ' ) ) ? <nl> ) <nl> - | ( ' 1 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? / / Non - zero decimal <nl> + / / Non - zero decimal <nl> + | ( ' 1 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? <nl> ) <nl> ; <nl> <nl> protected LONG _ LITERAL <nl> : ( ' 0 ' <nl> - ( ( ' x ' | ' X ' ) ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? / / Hexa <nl> - | ( ' b ' | ' B ' ) ( BINARY _ DIGIT ) ( ( BINARY _ DIGIT | ' _ ' ) * ( BINARY _ DIGIT ) ) ? / / Binary <nl> - | ( ( ( ' 0 ' . . ' 7 ' ) | ' _ ' ) * ( ' 0 ' . . ' 7 ' ) ) ? / / If empty 0 , otherwise octal ( which may start with an underscore ) <nl> + / / Hexa <nl> + ( ( ' x ' | ' X ' ) ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? <nl> + / / Binary <nl> + | ( ' b ' | ' B ' ) ( BINARY _ DIGIT ) ( ( BINARY _ DIGIT | ' _ ' ) * ( BINARY _ DIGIT ) ) ? <nl> + / / If empty 0 , otherwise octal ( which may start with an underscore ) <nl> + | ( ( ( ' 0 ' . . ' 7 ' ) | ' _ ' ) * ( ' 0 ' . . ' 7 ' ) ) ? <nl> ) <nl> - | ( ' 1 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? / / Non - zero decimal <nl> + / / Non - zero decimal <nl> + | ( ' 1 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? <nl> ) <nl> / / long signifier <nl> ( ' l ' | ' L ' ) <nl> @ @ - 1967 , 7 + 1994 , 7 @ @ protected LONG _ LITERAL <nl> protected FLOAT _ LITERAL <nl> : ( <nl> ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? ' . ' ) = > <nl> - ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? <nl> + ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? <nl> | ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) <nl> ) <nl> ( EXPONENT ) ? ( ' f ' | ' F ' ) ? <nl> @ @ - 1979 , 7 + 2006 , 7 @ @ protected FLOAT _ LITERAL <nl> protected DOUBLE _ LITERAL <nl> : ( <nl> ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? ' . ' ) = > <nl> - ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? <nl> + ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? <nl> | ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) <nl> ) <nl> | <nl> @ @ - 1992 , 7 + 2019 , 8 @ @ protected HEX _ FLOAT _ LITERAL <nl> : ' 0 ' ( ' x ' | ' X ' ) <nl> ( <nl> ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? ' . ' ) = > <nl> - ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ' . ' ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? <nl> + ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ' . ' <nl> + ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? <nl> | ' . ' ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) <nl> ) <nl> | <nl> @ @ - 2005 , 7 + 2033 , 8 @ @ protected HEX _ DOUBLE _ LITERAL <nl> : ' 0 ' ( ' x ' | ' X ' ) <nl> ( <nl> ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? ' . ' ) = > <nl> - ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ' . ' ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? <nl> + ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ' . ' <nl> + ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? <nl> | ' . ' ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) <nl> ) <nl> | <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 <nl> index 763394e . . 303b9d3 100755 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 <nl> @ @ - 65 , 7 + 65 , 7 @ @ AUTHOR _ LITERAL : ' @ author ' { isJavadocTagAvailable } ? ; <nl> DEPRECATED _ LITERAL : ' @ deprecated ' { isJavadocTagAvailable } ? ; <nl> EXCEPTION _ LITERAL : ' @ exception ' { isJavadocTagAvailable } ? - > pushMode ( exception ) ; <nl> PARAM _ LITERAL : ' @ param ' { isJavadocTagAvailable } ? - > pushMode ( param ) ; <nl> - RETURN _ LITERAL : ' @ return ' { isJavadocTagAvailable } ? ; <nl> + RETURN _ LITERAL : ' @ return ' { isJavadocTagAvailable } ? ; <nl> SEE _ LITERAL : ' @ see ' { isJavadocTagAvailable } ? - > pushMode ( seeLink ) ; <nl> SERIAL _ LITERAL : ' @ serial ' { isJavadocTagAvailable } ? ; <nl> SERIAL _ FIELD _ LITERAL : ' @ serialField ' { isJavadocTagAvailable } ? - > pushMode ( serialField ) ; <nl> @ @ - 93 , 7 + 93 , 7 @ @ CHAR : . ; <nl> mode param ; <nl> Space0 : WS - > type ( WS ) ; <nl> PARAMETER _ NAME : [ a - zA - Z0 - 9 < > _ $ ] + - > mode ( DEFAULT _ MODE ) ; <nl> - Char1 : . <nl> + Char1 : . <nl> { <nl> skipCurrentTokenConsuming ( ) ; <nl> } - > skip , mode ( DEFAULT _ MODE ) ; <nl> @ @ - 131 , 7 + 131 , 7 @ @ End20 : JAVADOC _ INLINE _ TAG _ END <nl> - > type ( JAVADOC _ INLINE _ TAG _ END ) , mode ( DEFAULT _ MODE ) <nl> ; <nl> / / exit from ' seeLink ' mode without consuming current character <nl> - Char2 : . <nl> + Char2 : . <nl> { <nl> skipCurrentTokenConsuming ( ) ; <nl> referenceCatched = false ; <nl> @ @ - 177 , 7 + 177 , 7 @ @ End2 : JAVADOC _ INLINE _ TAG _ END <nl> } <nl> - > type ( JAVADOC _ INLINE _ TAG _ END ) , mode ( DEFAULT _ MODE ) <nl> ; <nl> - Char20 : . <nl> + Char20 : . <nl> { <nl> skipCurrentTokenConsuming ( ) ; <nl> referenceCatched = false ; <nl> @ @ - 187 , 7 + 187 , 7 @ @ Char20 : . <nl> mode serialField ; <nl> Space2 : WS - > type ( WS ) ; <nl> FIELD _ NAME : [ a - zA - Z0 - 9 _ $ ] + - > mode ( serialFieldFieldType ) ; <nl> - Char3 : . <nl> + Char3 : . <nl> { <nl> skipCurrentTokenConsuming ( ) ; <nl> referenceCatched = false ; <nl> @ @ - 328 , 7 + 328 , 7 @ @ DIGIT : [ 0 - 9 ] ; <nl> <nl> fragment <nl> NAME _ CHAR : NAME _ START _ CHAR <nl> - | ' - ' | ' _ ' | ' . ' | DIGIT <nl> + | ' - ' | ' _ ' | ' . ' | DIGIT <nl> | ' \ u00B7 ' <nl> | ' \ u0300 ' . . ' \ u036F ' <nl> | ' \ u203F ' . . ' \ u2040 ' <nl> @ @ - 337 , 10 + 337 , 10 @ @ NAME _ CHAR : NAME _ START _ CHAR <nl> fragment <nl> NAME _ START _ CHAR <nl> : [ : a - zA - Z ] <nl> - | ' \ u2070 ' . . ' \ u218F ' <nl> - | ' \ u2C00 ' . . ' \ u2FEF ' <nl> - | ' \ u3001 ' . . ' \ uD7FF ' <nl> - | ' \ uF900 ' . . ' \ uFDCF ' <nl> + | ' \ u2070 ' . . ' \ u218F ' <nl> + | ' \ u2C00 ' . . ' \ u2FEF ' <nl> + | ' \ u3001 ' . . ' \ uD7FF ' <nl> + | ' \ uF900 ' . . ' \ uFDCF ' <nl> | ' \ uFDF0 ' . . ' \ uFFFD ' <nl> ; <nl> <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParser . g4 b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParser . g4 <nl> index dacf17d . . 1f024f1 100755 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParser . g4 <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParser . g4 <nl> @ @ - 784 , 12 + 784 , 12 @ @ singletonTag : OPEN <nl> | P _ HTML _ TAG _ NAME <nl> | LI _ HTML _ TAG _ NAME <nl> | TR _ HTML _ TAG _ NAME <nl> - | TD _ HTML _ TAG _ NAME <nl> - | TH _ HTML _ TAG _ NAME <nl> + | TD _ HTML _ TAG _ NAME <nl> + | TH _ HTML _ TAG _ NAME <nl> | BODY _ HTML _ TAG _ NAME <nl> | COLGROUP _ HTML _ TAG _ NAME <nl> | DD _ HTML _ TAG _ NAME <nl> - | DT _ HTML _ TAG _ NAME <nl> + | DT _ HTML _ TAG _ NAME <nl> | HEAD _ HTML _ TAG _ NAME <nl> | HTML _ HTML _ TAG _ NAME <nl> | OPTION _ HTML _ TAG _ NAME
NEAREST DIFF (one line): diff - - git a / ChangeLog b / ChangeLog <nl> index d043b55 . . 186f278 100644 <nl> - - - a / ChangeLog <nl> + + + b / ChangeLog <nl> @ @ - 1 , 5 + 1 , 10 @ @ <nl> 2001 - 11 - 26 Oliver Burn < oliver @ cortexebusiness . com . au > <nl> <nl> + 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> + 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g : <nl> + 	 Incorporate changes made to the ANTLR Java grammar that checkstyle is <nl> + 	 based off . <nl> + <nl> 	 * src / tests / com / puppycrawl / tools / checkstyle / CheckerTest . java <nl> 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . g : Included patch <nl> 	 to check whitespace after synchronized and catch keywords . From Lars <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> index 4fbca2e . . 80849b6 100644 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g <nl> @ @ - 56 , 6 + 56 , 7 @ @ tokens { <nl> 	 POST _ INC ; POST _ DEC ; METHOD _ CALL ; EXPR ; ARRAY _ INIT ; <nl> 	 IMPORT ; UNARY _ MINUS ; UNARY _ PLUS ; CASE _ GROUP ; ELIST ; FOR _ INIT ; FOR _ CONDITION ; <nl> 	 FOR _ ITERATOR ; EMPTY _ STAT ; FINAL = " final " ; ABSTRACT = " abstract " ; <nl> + 	 STRICTFP = " strictfp " ; SUPER _ CTOR _ CALL ; CTOR _ CALL ; <nl> } <nl> 	 <nl> { <nl> @ @ - 112 , 16 + 113 , 6 @ @ declaration ! <nl> 	 	 { # declaration = # v ; } <nl> 	 ; <nl> <nl> - / / A list of zero or more modifiers . We could have used ( modifier ) * in <nl> - / / place of a call to modifiers , but I thought it was a good idea to keep <nl> - / / this rule separate so they can easily be collected in a Vector if <nl> - / / someone so desires <nl> - modifiers <nl> - 	 : 	 ( modifier ) * <nl> - 	 	 { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } <nl> - 	 ; <nl> - <nl> - <nl> / / A type specification is a type name with possible brackets afterwards <nl> / / ( which would make it an array type ) . <nl> typeSpec [ boolean addImagNode ] <nl> @ @ - 192 , 6 + 183 , 14 @ @ identifierStar <nl> } <nl> 	 ; <nl> <nl> + / / A list of zero or more modifiers . We could have used ( modifier ) * in <nl> + / / place of a call to modifiers , but I thought it was a good idea to keep <nl> + / / this rule separate so they can easily be collected in a Vector if <nl> + / / someone so desires <nl> + modifiers <nl> + 	 : 	 ( modifier ) * <nl> + 	 	 { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } <nl> + 	 ; <nl> <nl> / / modifiers for Java classes , interfaces , class / instance vars and methods <nl> modifier <nl> @ @ - 205 , 11 + 204 , 11 @ @ modifier <nl> 	 | 	 " native " <nl> 	 | 	 " threadsafe " <nl> 	 | 	 " synchronized " <nl> - / / 	 | 	 " const " 	 	 	 / / reserved word ; leave out <nl> + / / 	 | 	 " const " 	 	 	 / / reserved word , but not valid <nl> 	 | 	 " volatile " <nl> + 	 | 	 " strictfp " <nl> 	 ; <nl> <nl> - <nl> / / Definition of a Java class <nl> classDefinition ! [ AST modifiers ] <nl> 	 : 	 " class " IDENT <nl> @ @ - 275 , 7 + 274 , 7 @ @ implementsClause <nl> field ! <nl> 	 : 	 / / method , constructor , or variable declaration <nl> 	 	 mods : modifiers <nl> - 	 	 ( 	 h : ctorHead s : compoundStatement / / constructor <nl> + 	 	 ( 	 h : ctorHead s : constructorBody / / constructor <nl> 	 	 	 { # field = # ( # [ CTOR _ DEF , " CTOR _ DEF " ] , mods , h , s ) ; } <nl> <nl> 	 	 | 	 cd : classDefinition [ # mods ] / / inner class <nl> @ @ - 290 , 9 + 289 , 10 @ @ field ! <nl> 	 	 	 	 / / parse the formal parameter declarations . <nl> 	 	 	 	 LPAREN ! param : parameterDeclarationList RPAREN ! <nl> <nl> - 	 	 	 	 rt : returnTypeBrackersOnEndOfMethodHead [ # t ] <nl> + 	 	 	 	 rt : declaratorBrackets [ # t ] <nl> <nl> - 	 	 	 	 / / get the list of exceptions that this method is declared to throw <nl> + 	 	 	 	 / / get the list of exceptions that this method is <nl> + 	 	 	 	 / / declared to throw <nl> 	 	 	 	 ( tc : throwsClause ) ? <nl> <nl> 	 	 	 	 ( s2 : compoundStatement | SEMI ) <nl> @ @ - 318 , 6 + 318 , 38 @ @ field ! <nl> 	 	 { # field = # ( # [ INSTANCE _ INIT , " INSTANCE _ INIT " ] , s4 ) ; } <nl> 	 ; <nl> <nl> + constructorBody <nl> + : lc : LCURLY ^ { # lc . setType ( SLIST ) ; } <nl> + 	 	 / / Predicate might be slow but only checked once per constructor def <nl> + 	 	 / / not for general methods . <nl> + 	 	 ( 	 ( explicitConstructorInvocation ) = > explicitConstructorInvocation <nl> + 	 	 | <nl> + 	 	 ) <nl> + ( statement ) * <nl> + RCURLY ! <nl> + ; <nl> + <nl> + explicitConstructorInvocation <nl> + : ( 	 options { <nl> + 	 	 	 	 / / this / super can begin a primaryExpression too ; with finite <nl> + 	 	 	 	 / / lookahead ANTLR will think the 3rd alternative conflicts <nl> + 	 	 	 	 / / with 1 , 2 . I am shutting off warning since ANTLR resolves <nl> + 	 	 	 	 / / the nondeterminism by correctly matching alts 1 or 2 when <nl> + 	 	 	 	 / / it sees this ( or super ( <nl> + 	 	 	 	 generateAmbigWarnings = false ; <nl> + 	 	 	 } <nl> + 	 	 : 	 " this " ! lp1 : LPAREN ^ argList RPAREN ! SEMI ! <nl> + 	 	 	 { # lp1 . setType ( CTOR _ CALL ) ; } <nl> + <nl> + 	 | " super " ! lp2 : LPAREN ^ argList RPAREN ! SEMI ! <nl> + 	 	 	 { # lp2 . setType ( SUPER _ CTOR _ CALL ) ; } <nl> + <nl> + 	 	 	 / / ( new Outer ( ) ) . super ( ) ( create enclosing instance ) <nl> + 	 	 | 	 primaryExpression DOT ! " super " ! lp3 : LPAREN ^ argList RPAREN ! SEMI ! <nl> + 	 	 	 { # lp3 . setType ( SUPER _ CTOR _ CALL ) ; } <nl> + 	 	 ) <nl> + ; <nl> + <nl> variableDefinitions [ AST mods , AST t ] <nl> 	 : 	 variableDeclarator [ getASTFactory ( ) . dupTree ( mods ) , <nl> 	 	 	 	 	 	 getASTFactory ( ) . dupTree ( t ) ] <nl> @ @ - 392 , 11 + 424 , 6 @ @ throwsClause <nl> 	 ; <nl> <nl> <nl> - returnTypeBrackersOnEndOfMethodHead [ AST typ ] <nl> - 	 : 	 { # returnTypeBrackersOnEndOfMethodHead = typ ; } <nl> - 	 	 ( lb : LBRACK ^ { # lb . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * <nl> - 	 ; <nl> - <nl> / / A list of formal parameters <nl> parameterDeclarationList <nl> 	 : 	 ( parameterDeclaration ( COMMA ! parameterDeclaration ) * ) ? <nl> @ @ - 407 , 16 + 434 , 11 @ @ parameterDeclarationList <nl> / / A formal parameter . <nl> parameterDeclaration ! <nl> 	 : 	 pm : parameterModifier t : typeSpec [ false ] id : IDENT <nl> - 	 	 pd : parameterDeclaratorBrackets [ # t ] <nl> + 	 	 pd : declaratorBrackets [ # t ] <nl> 	 	 { # parameterDeclaration = # ( # [ PARAMETER _ DEF , " PARAMETER _ DEF " ] , <nl> 	 	 	 	 	 	 	 	 	 pm , # ( [ TYPE , " TYPE " ] , pd ) , id ) ; } <nl> 	 ; <nl> <nl> - parameterDeclaratorBrackets [ AST t ] <nl> - 	 : 	 { # parameterDeclaratorBrackets = t ; } <nl> - 	 	 ( lb : LBRACK ^ { # lb . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * <nl> - 	 ; <nl> - <nl> parameterModifier <nl> 	 : 	 ( f : " final " ) ? <nl> 	 	 { # parameterModifier = # ( # [ MODIFIERS , " MODIFIERS " ] , f ) ; } <nl> @ @ - 443 , 15 + 465 , 6 @ @ statement <nl> 	 / / A list of statements in curly braces - - start a new scope ! <nl> 	 : 	 compoundStatement <nl> <nl> - 	 / / class definition <nl> - 	 | 	 classDefinition [ # [ MODIFIERS , " MODIFIERS " ] ] <nl> - <nl> - 	 / / final class definition <nl> - 	 | 	 " final " ! classDefinition [ # ( # [ MODIFIERS , " MODIFIERS " ] , # [ FINAL , " final " ] ) ] <nl> - <nl> - 	 / / abstract class definition <nl> - 	 | 	 " abstract " ! classDefinition [ # ( # [ MODIFIERS , " MODIFIERS " ] , # [ ABSTRACT , " abstract " ] ) ] <nl> - <nl> 	 / / declarations are ambiguous with " ID DOT " relative to expression <nl> 	 / / statements . Must backtrack to be sure . Could use a semantic <nl> 	 / / predicate to test symbol table to see what the type was coming <nl> @ @ - 463 , 6 + 476 , 9 @ @ statement <nl> 	 / / side - effects . <nl> 	 | 	 expression SEMI ! <nl> <nl> + 	 / / class definition <nl> + 	 | 	 m : modifiers ! classDefinition [ # m ] <nl> + <nl> 	 / / Attach a label to the front of a statement <nl> 	 | 	 IDENT c : COLON ^ { # c . setType ( LABELED _ STAT ) ; } statement <nl> <nl> @ @ - 651 , 9 + 667 , 9 @ @ assignmentExpression <nl> <nl> / / conditional test ( level 12 ) <nl> conditionalExpression <nl> - : logicalOrExpression <nl> - ( QUESTION ^ assignmentExpression COLON conditionalExpression ) ? <nl> - ; <nl> + 	 : 	 logicalOrExpression <nl> + 	 	 ( QUESTION ^ assignmentExpression COLON ! conditionalExpression ) ? <nl> + 	 ; <nl> <nl> <nl> / / logical or ( | | ) ( level 11 ) <nl> @ @ - 767 , 10 + 783 , 10 @ @ postfixExpression <nl> 	 	 	 	 | " this " <nl> 	 	 	 	 | " class " <nl> 	 	 	 	 | newExpression <nl> - 	 	 	 	 | " super " LPAREN ( expressionList ) ? RPAREN <nl> + 	 	 	 	 | " super " / / ClassName . super . field <nl> 	 	 	 	 ) <nl> 	 	 	 / / the above line needs a semantic check to make sure " class " <nl> - 	 	 	 / / is the _ last _ qualifier . <nl> + 	 	 	 / / is the _ last _ qualifier . <nl> <nl> 	 	 	 / / allow ClassName [ ] . class <nl> 	 	 | 	 ( lbc : LBRACK ^ { # lbc . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) + <nl> @ @ - 784 , 6 + 800 , 9 @ @ postfixExpression <nl> 	 	 	 / / x [ 2 ] ( 4 ) which are not valid in Java . If this grammar were used <nl> 	 	 	 / / to validate a Java program a semantic check would be needed , or <nl> 	 	 	 / / this rule would get really ugly . . . <nl> + 	 	 	 / / It also allows ctor invocation like super ( 3 ) which is now <nl> + 	 	 	 / / handled by the explicit constructor rule , but it would <nl> + 	 	 	 / / be hard to syntactically prevent ctor calls here <nl> 	 	 | 	 lp : LPAREN ^ { # lp . setType ( METHOD _ CALL ) ; } <nl> 	 	 	 	 argList <nl> 	 	 	 RPAREN ! <nl> @ @ - 795 , 24 + 814 , 23 @ @ postfixExpression <nl> 	 	 | 	 de : DEC ^ { # de . setType ( POST _ DEC ) ; } <nl> 	 	 | 	 / / nothing <nl> 	 	 ) <nl> - <nl> - 	 	 / / look for int . class and int [ ] . class <nl> - 	 | 	 builtInType <nl> - 	 	 ( lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * <nl> - 	 	 DOT ^ " class " <nl> 	 ; <nl> <nl> / / the basic element of an expression <nl> primaryExpression <nl> 	 : 	 i1 : IDENT { sFirstIdent = i1 . getText ( ) ; } <nl> - 	 | 	 newExpression <nl> 	 | 	 constant <nl> - 	 | 	 " super " <nl> 	 | 	 " true " <nl> 	 | 	 " false " <nl> 	 | 	 " this " <nl> 	 | 	 " null " <nl> + 	 | 	 newExpression <nl> 	 | 	 LPAREN ! assignmentExpression RPAREN ! <nl> + 	 | 	 " super " <nl> + 	 	 / / look for int . class and int [ ] . class <nl> + 	 | 	 builtInType <nl> + 	 	 ( lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * <nl> + 	 	 DOT ^ " class " <nl> 	 ; <nl> <nl> / * * object instantiation . <nl> @ @ - 909 , 6 + 927 , 8 @ @ constant <nl> 	 | 	 CHAR _ LITERAL <nl> 	 | 	 STRING _ LITERAL <nl> 	 | 	 NUM _ FLOAT <nl> + 	 | 	 NUM _ LONG <nl> + 	 | 	 NUM _ DOUBLE <nl> 	 ; <nl> <nl> <nl> @ @ - 921 , 7 + 941 , 11 @ @ options { <nl> 	 exportVocab = GeneratedJava ; / / call the vocabulary " GeneratedJava " <nl> 	 testLiterals = false ; / / don ' t automatically test for literals <nl> 	 k = 4 ; / / four characters of lookahead <nl> - / / 	 charVocabulary = ' \ u0003 ' . . ' \ uFFFF ' ; <nl> + 	 charVocabulary = ' \ u0003 ' . . ' \ uFFFF ' ; <nl> + 	 / / without inlining some bitset tests , couldn ' t do unicode ; <nl> + 	 / / I need to make ANTLR generate smaller bitsets ; see <nl> + 	 / / bottom of JavaLexer . java <nl> + 	 codeGenBitsetTestThreshold = 20 ; <nl> } <nl> <nl> <nl> @ @ - 979 , 13 + 1003 , 14 @ @ SEMI 	 	 	 : 	 ' ; ' 	 	 ; <nl> WS 	 : 	 ( 	 ' ' <nl> 	 	 | 	 ' \ t ' <nl> 	 	 | 	 ' \ f ' <nl> - 	 	 / / handle newlines <nl> - 	 	 | 	 ( 	 " \ r \ n " / / Evil DOS <nl> + 	 	 	 / / handle newlines <nl> + 	 	 | 	 ( 	 options { generateAmbigWarnings = false ; } <nl> + 	 	 	 : 	 " \ r \ n " / / Evil DOS <nl> 	 	 	 | 	 ' \ r ' / / Macintosh <nl> 	 	 	 | 	 ' \ n ' / / Unix ( the right way ) <nl> 	 	 	 ) <nl> 	 	 	 { newline ( ) ; } <nl> - 	 	 ) <nl> + 	 	 ) + <nl> 	 	 { _ ttype = Token . SKIP ; } <nl> 	 ; <nl> <nl> @ @ - 1117 , 9 + 1142 , 19 @ @ IDENT <nl> <nl> / / a numeric literal <nl> NUM _ INT <nl> - 	 { boolean isDecimal = false ; } <nl> - 	 : 	 ' . ' { _ ttype = DOT ; } <nl> - 	 	 	 ( ( ' 0 ' . . ' 9 ' ) + ( EXPONENT ) ? ( FLOAT _ SUFFIX ) ? { _ ttype = NUM _ FLOAT ; } ) ? <nl> + 	 { boolean isDecimal = false ; Token t = null ; } <nl> + : ' . ' { _ ttype = DOT ; } <nl> + ( 	 ( ' 0 ' . . ' 9 ' ) + ( EXPONENT ) ? ( f1 : FLOAT _ SUFFIX { t = f1 ; } ) ? <nl> + { <nl> + 	 	 	 	 if ( t ! = null & & t . getText ( ) . toUpperCase ( ) . indexOf ( ' D ' ) > = 0 ) { <nl> + 	 _ ttype = NUM _ DOUBLE ; <nl> + 	 	 	 	 } <nl> + 	 	 	 	 else { <nl> + 	 _ ttype = NUM _ FLOAT ; <nl> + 	 	 	 	 } <nl> + 	 	 	 	 } <nl> + ) ? <nl> + <nl> 	 | 	 ( 	 ' 0 ' { isDecimal = true ; } / / special case for just ' 0 ' <nl> 	 	 	 ( 	 ( ' x ' | ' X ' ) <nl> 	 	 	 	 ( 	 	 	 	 	 	 	 	 	 	 	 / / hex <nl> @ @ - 1137 , 16 + 1172 , 23 @ @ NUM _ INT <nl> 	 	 	 ) ? <nl> 	 	 | 	 ( ' 1 ' . . ' 9 ' ) ( ' 0 ' . . ' 9 ' ) * { isDecimal = true ; } 	 	 / / non - zero decimal <nl> 	 	 ) <nl> - 	 	 ( 	 ( ' l ' | ' L ' ) <nl> + 	 	 ( 	 ( ' l ' | ' L ' ) { _ ttype = NUM _ LONG ; } <nl> 	 	 <nl> 	 	 / / only check to see if it ' s a float if looks like decimal so far <nl> 	 	 | 	 { isDecimal } ? <nl> - 	 	 	 ( 	 ' . ' ( ' 0 ' . . ' 9 ' ) * ( EXPONENT ) ? ( FLOAT _ SUFFIX ) ? <nl> - 	 	 	 | 	 EXPONENT ( FLOAT _ SUFFIX ) ? <nl> - 	 	 	 | 	 FLOAT _ SUFFIX <nl> - 	 	 	 ) <nl> - 	 	 	 { _ ttype = NUM _ FLOAT ; } <nl> - 	 	 ) ? <nl> + ( ' . ' ( ' 0 ' . . ' 9 ' ) * ( EXPONENT ) ? ( f2 : FLOAT _ SUFFIX { t = f2 ; } ) ? <nl> + | EXPONENT ( f3 : FLOAT _ SUFFIX { t = f3 ; } ) ? <nl> + | f4 : FLOAT _ SUFFIX { t = f4 ; } <nl> + ) <nl> + { <nl> + 	 	 	 if ( t ! = null & & t . getText ( ) . toUpperCase ( ) . indexOf ( ' D ' ) > = 0 ) { <nl> + _ ttype = NUM _ DOUBLE ; <nl> + 	 	 	 } <nl> + else { <nl> + _ ttype = NUM _ FLOAT ; <nl> + 	 	 	 } <nl> + 	 	 	 } <nl> + ) ? <nl> 	 ; <nl> <nl> <nl> diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g <nl> index 4e98a15 . . 89e6e38 100644 <nl> - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g <nl> + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g <nl> @ @ - 117 , 6 + 117 , 7 @ @ modifier <nl> | " synchronized " <nl> | " const " <nl> | " volatile " <nl> + 	 | 	 " strictfp " <nl> ; <nl> <nl> extendsClause <nl> @ @ - 163 , 7 + 164 , 7 @ @ ctorDef <nl> MyModifierSet mods ; <nl> MethodSignature ms ; <nl> } <nl> - : # ( CTOR _ DEF mods = modifiers ms = methodHead { ver . reportStartMethodBlock ( ) ; } slist { ver . reportEndMethodBlock ( ) ; } ) <nl> + : # ( CTOR _ DEF mods = modifiers ms = methodHead { ver . reportStartMethodBlock ( ) ; } ctorSList { ver . reportEndMethodBlock ( ) ; } ) <nl> { <nl> ver . verifyMethodJavadoc ( mods , null , ms ) ; <nl> } <nl> @ @ - 293 , 6 + 294 , 10 @ @ identifierStar <nl> | # ( DOT ignore = identifier ( STAR | IDENT ) ) <nl> ; <nl> <nl> + ctorSList <nl> + 	 : 	 # ( SLIST ( ctorCall ) ? ( stat ) * ) <nl> + 	 ; <nl> + <nl> slist <nl> 	 : 	 # ( SLIST ( stat ) * ) <nl> 	 ; <nl> @ @ - 434 , 8 + 439 , 9 @ @ primaryExpression <nl> | " this " <nl> | " class " { if ( firstExprIdent ! = null ) { ver . reportReference ( firstExprIdent . getText ( ) ) ; } } <nl> | # ( " new " IDENT elist ) <nl> + 	 	 	 	 | " super " <nl> ) <nl> - | # ( ARRAY _ DECLARATOR type ) <nl> + | # ( ARRAY _ DECLARATOR typeSpecArray ) <nl> | builtInType ( " class " ) ? <nl> ) <nl> ) <nl> @ @ - 452 , 6 + 458 , 15 @ @ primaryExpression <nl> | typeSpec / / type name used with instanceof <nl> ; <nl> <nl> + ctorCall <nl> + 	 : 	 # ( CTOR _ CALL elist ) <nl> + 	 | 	 # ( SUPER _ CTOR _ CALL <nl> + 	 	 	 ( 	 elist <nl> + 	 	 	 | 	 primaryExpression elist <nl> + 	 	 	 ) <nl> + 	 	 ) <nl> + 	 ; <nl> + <nl> arrayIndex <nl> 	 : 	 # ( INDEX _ OP primaryExpression expression ) <nl> 	 ; <nl> @ @ - 461 , 6 + 476 , 8 @ @ constant <nl> | CHAR _ LITERAL <nl> | STRING _ LITERAL <nl> | NUM _ FLOAT <nl> + | NUM _ DOUBLE <nl> + | NUM _ LONG <nl> ; <nl> <nl> newExpression

TEST DIFF:
diff - - git a / config / checkstyle _ checks . xml b / config / checkstyle _ checks . xml 
 index ed6feca . . 923dbfd 100644 
 - - - a / config / checkstyle _ checks . xml 
 + + + b / config / checkstyle _ checks . xml 
 @ @ - 16 , 7 + 16 , 7 @ @ 
 
 < property name = " severity " value = " error " / > 
 
 - < property name = " fileExtensions " value = " java , properties , xml " / > 
 + < property name = " fileExtensions " value = " java , properties , xml , g , g4 " / > 
 
 < ! - - Filters - - > 
 < module name = " SeverityMatchFilter " > 
 @ @ - 375 , 6 + 375 , 11 @ @ 
 
 < ! - - Regexp - - > 
 < module name = " Regexp " / > 
 + < module name = " Regexp " > 
 + < property name = " format " value = " ^ ( ? ! ( . * http | import ) ) . { 101 , } $ " / > 
 + < property name = " illegalPattern " value = " true " / > 
 + < property name = " message " value = " Line should not be longer then 100 symbols " / > 
 + < / module > 
 < module name = " RegexpSinglelineJava " / > 
 < module name = " RegexpSinglelineJava " > 
 < property name = " format " value = " [ ^ \ p { ASCII } ] " / > 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / whitespace / OperatorWrapCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / whitespace / OperatorWrapCheck . java 
 index acd93e6 . . 028cb1b 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / whitespace / OperatorWrapCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / whitespace / OperatorWrapCheck . java 
 @ @ - 85 , 9 + 85 , 10 @ @ import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; 
 * < pre > 
 * & lt ; module name = " OperatorWrap " & gt ; 
 * & lt ; property name = " tokens " 
 - * value = " ASSIGN , DIV _ ASSIGN , PLUS _ ASSIGN , MINUS _ ASSIGN , STAR _ ASSIGN , MOD _ ASSIGN , SR _ ASSIGN , BSR _ ASSIGN , SL _ ASSIGN , BXOR _ ASSIGN , BOR _ ASSIGN , BAND _ ASSIGN " / & gt ; 
 + * value = " ASSIGN , DIV _ ASSIGN , PLUS _ ASSIGN , MINUS _ ASSIGN , STAR _ ASSIGN , MOD _ ASSIGN 
 + * , SR _ ASSIGN , BSR _ ASSIGN , SL _ ASSIGN , BXOR _ ASSIGN , BOR _ ASSIGN , BAND _ ASSIGN " / & gt ; 
 * & lt ; property name = " option " value = " eol " / & gt ; 
 - * & lt ; / module & gt ; 
 + * & lt ; / module & gt ; 
 * < / pre > 
 * 
 * @ author Rick Giles 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / java . g b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / java . g 
 index acc6d5f . . f44972c 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / java . g 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / java . g 
 @ @ - 100 , 7 + 100 , 7 @ @ tokens { 
 / / we need to put it to the end to maintain binary compatibility 
 / / with previous versions 
 DO _ WHILE ; 
 - 
 + 
 / / Tokens for Java 1 . 7 language enhancements 
 RESOURCE _ SPECIFICATION ; RESOURCES ; RESOURCE ; 
 
 @ @ - 126 , 8 + 126 , 8 @ @ tokens { 
 * typeArguments production . This is necessary because SR and BSR 
 * tokens have significance ( the extra ' > ' characters ) not only for the production 
 * that sees them but also productions higher in the stack ( possibly right up to an outer - most 
 - * typeParameters production ) . As the stack of the typeArguments / typeParameters productions unwind , 
 - * any ' > ' characters seen prematurely through SRs or BSRs are reconciled . 
 + * typeParameters production ) . As the stack of the typeArguments / typeParameters productions 
 + * unwind , any ' > ' characters seen prematurely through SRs or BSRs are reconciled . 
 * / 
 private int gtToReconcile = 0 ; 
 
 @ @ - 164 , 7 + 164 , 8 @ @ tokens { 
 gtToReconcile - = 1 ; 
 CommonHiddenStreamToken gtToken = new CommonHiddenStreamToken ( GENERIC _ END , " > " ) ; 
 gtToken . setLine ( currentGtSequence . getLineNo ( ) ) ; 
 - gtToken . setColumn ( currentGtSequence . getColumnNo ( ) + ( currentGtSequence . getText ( ) . length ( ) - gtToReconcile ) ) ; 
 + gtToken . setColumn ( currentGtSequence . getColumnNo ( ) 
 + + ( currentGtSequence . getText ( ) . length ( ) - gtToReconcile ) ) ; 
 return ( DetailAST ) astFactory . create ( gtToken ) ; 
 } 
 
 @ @ - 227 , 7 + 228 , 8 @ @ packageDefinition 
 / / Import statement : import followed by a package or class name 
 importDefinition 
 options { defaultErrorHandler = true ; } 
 - : i : " import " ^ { # i . setType ( IMPORT ) ; } ( " static " { # i . setType ( STATIC _ IMPORT ) ; } ) ? identifierStar SEMI 
 + : i : " import " ^ { # i . setType ( IMPORT ) ; } 
 + ( " static " { # i . setType ( STATIC _ IMPORT ) ; } ) ? identifierStar SEMI 
 | SEMI 
 ; 
 
 @ @ - 286 , 7 + 288 , 7 @ @ classOrInterfaceType [ boolean addImagNode ] 
 ) * 
 ; 
 
 - / / A generic type argument is a class type , a possibly bounded wildcard type or a built - in type array 
 + / / A generic type argument is a class type , a possibly bounded wildcard type or built - in type array 
 typeArgument [ boolean addImagNode ] 
 : ( ( { LA ( 1 ) = = AT } ? annotations 
 | ) ( 
 @ @ - 307 , 7 + 309 , 8 @ @ typeArguments [ boolean addImagNode ] 
 : 
 { currentLtLevel = ltCounter ; } 
 lt : LT { # lt . setType ( GENERIC _ START ) ; ; ltCounter + + ; } 
 - / / ( Dinesh Bolkensteyn ) Added support for Java 7 diamond notation ( disabled ambiguous warnings since generated code seems to work ) 
 + / / ( Dinesh Bolkensteyn ) Added support for Java 7 diamond notation 
 + / / ( disabled ambiguous warnings since generated code seems to work ) 
 ( options { generateAmbigWarnings = false ; } : typeArgument [ addImagNode ] 
 ( options { greedy = true ; } : / / match as many as possible 
 / / If there are any ' > ' to reconcile 
 @ @ - 437 , 8 + 440 , 7 @ @ modifiers 
 / / Semantic check that we aren ' t matching @ interface as this is not an annotation 
 / / A nicer way to do this would be , um , nice 
 { LA ( 1 ) = = AT & & ! LT ( 2 ) . getText ( ) . equals ( " interface " ) } ? annotation 
 - 
 - 
 + 
 ) * 
 
 { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } 
 @ @ - 462 , 7 + 464 , 11 @ @ modifier 
 ; 
 
 annotation ! 
 - : AT i : identifier ( options { generateAmbigWarnings = false ; } : l : LPAREN ( args : annotationArguments ) ? r : RPAREN ) ? 
 + : AT i : identifier 
 + ( options { generateAmbigWarnings = false ; } : 
 + l : LPAREN ( args : annotationArguments ) ? 
 + r : RPAREN 
 + ) ? 
 { # annotation = # ( # [ ANNOTATION , " ANNOTATION " ] , AT , i , l , args , r ) ; } 
 ; 
 
 @ @ - 481 , 7 + 487 , 8 @ @ annotationMemberValuePairs 
 
 annotationMemberValuePair ! 
 : i : IDENT a : ASSIGN v : annotationMemberValueInitializer 
 - { # annotationMemberValuePair = # ( # [ ANNOTATION _ MEMBER _ VALUE _ PAIR , " ANNOTATION _ MEMBER _ VALUE _ PAIR " ] , i , a , v ) ; } 
 + { # annotationMemberValuePair = 
 + # ( # [ ANNOTATION _ MEMBER _ VALUE _ PAIR , " ANNOTATION _ MEMBER _ VALUE _ PAIR " ] , i , a , v ) ; } 
 ; 
 
 annotationMemberValueInitializer 
 @ @ - 862 , 10 + 869 , 12 @ @ explicitConstructorInvocation 
 
 variableDefinitions [ AST mods , AST t ] 
 : variableDeclarator [ ( AST ) getASTFactory ( ) . dupTree ( mods ) , 
 - ( AST ) getASTFactory ( ) . dupList ( t ) ] / / dupList as this also copies siblings ( like TYPE _ ARGUMENTS ) 
 + / / dupList as this also copies siblings ( like TYPE _ ARGUMENTS ) 
 + ( AST ) getASTFactory ( ) . dupList ( t ) ] 
 ( COMMA 
 variableDeclarator [ ( AST ) getASTFactory ( ) . dupTree ( mods ) , 
 - ( AST ) getASTFactory ( ) . dupList ( t ) ] / / dupList as this also copies siblings ( like TYPE _ ARGUMENTS ) 
 + / / dupList as this also copies siblings ( like TYPE _ ARGUMENTS ) 
 + ( AST ) getASTFactory ( ) . dupList ( t ) ] 
 ) * 
 ; 
 
 @ @ - 944 , 9 + 953 , 11 @ @ throwsClause 
 / / If a parameter is variable length ( e . g . String . . . myArg ) it is the right - most parameter 
 parameterDeclarationList 
 / / The semantic check in ( . . . . ) * block is flagged as superfluous , and seems superfluous but 
 - / / is the only way I could make this work . If my understanding is correct this is a known bug in Antlr 
 + / / is the only way I could make this work . 
 + / / If my understanding is correct this is a known bug in Antlr 
 : ( ( parameterDeclaration ) = > parameterDeclaration 
 - ( options { warnWhenFollowAmbig = false ; } : ( COMMA parameterDeclaration ) = > COMMA parameterDeclaration ) * 
 + ( options { warnWhenFollowAmbig = false ; } : 
 + ( COMMA parameterDeclaration ) = > COMMA parameterDeclaration ) * 
 ( COMMA variableLengthParameterDeclaration ) ? 
 | 
 variableLengthParameterDeclaration 
 @ @ - 965 , 7 + 976 , 8 @ @ variableLengthParameterDeclaration ! 
 parameterModifier 
 / / final can appear amongst annotations in any order - greedily consume any preceding 
 / / annotations to shut nond - eterminism warnings off 
 - : ( options { greedy = true ; } : annotation ) * ( f : " final " ) ? ( options { warnWhenFollowAmbig = false ; } : annotation ) * 
 + : ( options { greedy = true ; } : annotation ) * ( f : " final " ) ? 
 + ( options { warnWhenFollowAmbig = false ; } : annotation ) * 
 { # parameterModifier = # ( # [ MODIFIERS , " MODIFIERS " ] , # parameterModifier ) ; } 
 ; 
 
 @ @ - 979 , 7 + 991 , 8 @ @ parameterDeclaration ! 
 / / Added for support Java7 ' s " multi - catch " , several types separated by ' | ' 
 catchParameterDeclaration ! 
 : pm : parameterModifier mct : multiCatchTypes id : IDENT 
 - { # catchParameterDeclaration = # ( # [ PARAMETER _ DEF , " PARAMETER _ DEF " ] , pm , # ( [ TYPE , " TYPE " ] , mct ) , id ) ; } 
 + { # catchParameterDeclaration = 
 + # ( # [ PARAMETER _ DEF , " PARAMETER _ DEF " ] , pm , # ( [ TYPE , " TYPE " ] , mct ) , id ) ; } 
 ; 
 
 multiCatchTypes 
 @ @ - 1137 , 8 + 1150 , 8 @ @ aCase 
 caseSList 
 : 
 ( 
 - / / Here was nondeterministic warnig between default block into switch and default modifier 
 - / / on methods ( Java8 ) . But we have semantic check for this . 
 + / / Here was nondeterministic warnig between default block into switch 
 + / / and default modifier on methods ( Java8 ) . But we have semantic check for this . 
 options { 
 warnWhenFollowAmbig = false ; 
 } 
 @ @ - 1184 , 7 + 1197 , 8 @ @ tryBlock 
 
 resourceSpecification 
 : LPAREN resources ( SEMI ) ? RPAREN 
 - { # resourceSpecification = # ( [ RESOURCE _ SPECIFICATION , " RESOURCE _ SPECIFICATION " ] , # resourceSpecification ) ; } 
 + { # resourceSpecification = 
 + # ( [ RESOURCE _ SPECIFICATION , " RESOURCE _ SPECIFICATION " ] , # resourceSpecification ) ; } 
 ; 
 
 resources 
 @ @ - 1197 , 7 + 1211 , 7 @ @ resource 
 : modifiers typeSpec [ true ] IDENT resource _ assign 
 { # resource = # ( [ RESOURCE , " RESOURCE " ] , # resource ) ; } 
 ; 
 - 
 + 
 resource _ assign 
 : ASSIGN ^ expression 
 ; 
 @ @ - 1353 , 7 + 1367 , 8 @ @ shiftExpression 
 
 / / binary addition / subtraction ( level 3 ) 
 additiveExpression 
 - : multiplicativeExpression ( options { warnWhenFollowAmbig = false ; } : ( PLUS ^ | MINUS ^ ) multiplicativeExpression ) * 
 + : multiplicativeExpression ( options { warnWhenFollowAmbig = false ; } : 
 + ( PLUS ^ | MINUS ^ ) multiplicativeExpression ) * 
 ; 
 
 
 @ @ - 1408 , 7 + 1423 , 7 @ @ typeCastParameters 
 postfixExpression 
 : primaryExpression / / start with a primary 
 
 - ( options { warnWhenFollowAmbig = false ; } : / / qualified id ( id . id . id . id . . . ) - - build the name 
 + ( options { warnWhenFollowAmbig = false ; } : / / qualified id ( id . id . id . id . . . ) - - build the name 
 DOT ^ 
 ( ( typeArguments [ false ] ) ? 
 ( IDENT ( ( typeArguments [ false ] DOUBLE _ COLON ) = > typeArguments [ false ] ) ? 
 @ @ - 1420 , 7 + 1435 , 9 @ @ postfixExpression 
 | annotations 
 ) 
 
 - / / Java 8 method references . For example : List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ; numbers . forEach ( System . out : : println ) ; 
 + / / Java 8 method references . 
 + / / For example : List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ; 
 + / / numbers . forEach ( System . out : : println ) ; 
 | 
 dc : DOUBLE _ COLON ^ { # dc . setType ( METHOD _ REF ) ; } 
 ( 
 @ @ - 1433 , 7 + 1450 , 8 @ @ postfixExpression 
 / / is the _ last _ qualifier . 
 
 / / allow ClassName [ ] . class or just ClassName [ ] 
 - | ( options { warnWhenFollowAmbig = false ; } : lbc : LBRACK ^ { # lbc . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ) + 
 + | ( options { warnWhenFollowAmbig = false ; } : 
 + lbc : LBRACK ^ { # lbc . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ) + 
 / / Since java 8 here can be method reference 
 ( options { warnWhenFollowAmbig = false ; } : DOT ^ " class " ) ? 
 
 @ @ - 1474 , 7 + 1492 , 8 @ @ primaryExpression 
 | " super " 
 / / look for int . class and int [ ] . class and int [ ] 
 | builtInType 
 - ( options { warnWhenFollowAmbig = false ; } : lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ) * 
 + ( options { warnWhenFollowAmbig = false ; } : 
 + lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ) * 
 / / Since java 8 here can be method reference 
 ( options { warnWhenFollowAmbig = false ; } : DOT ^ " class " ) ? 
 ; 
 @ @ - 1862 , 11 + 1881 , 11 @ @ VOCAB 
 ; 
 
 protected ID _ START : 
 - ' _ ' | ' $ ' | 
 - ( 
 + ' _ ' | ' $ ' | 
 + ( 
 { Character . isJavaIdentifierStart ( LA ( 1 ) ) } ? 
 ~ ( 
 - ' _ ' | ' $ ' | ' / ' | ' * ' | ' 0 ' . . ' 9 ' | 
 + ' _ ' | ' $ ' | ' / ' | ' * ' | ' 0 ' . . ' 9 ' | 
 ' . ' | ' \ ' ' | ' \ \ ' | ' " ' | ' \ t ' | ' \ n ' | 
 ' \ r ' | ' ' | ' \ f ' | ' ( ' | ' ) ' | 
 ' { ' | ' } ' | ' [ ' | ' ] ' | ' ; ' | ' , ' | ' = ' | 
 @ @ - 1886 , 7 + 1905 , 7 @ @ protected ID _ START : 
 } 
 
 protected ID _ PART : 
 - ' _ ' | ' $ ' | 
 + ' _ ' | ' $ ' | 
 ( 
 { Character . isJavaIdentifierPart ( LA ( 1 ) ) } ? 
 ~ ( 
 @ @ - 1944 , 21 + 1963 , 29 @ @ NUM _ INT 
 
 protected INT _ LITERAL 
 : ( ' 0 ' 
 - ( ( ' x ' | ' X ' ) ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? / / Hexa 
 - | ( ' b ' | ' B ' ) ( BINARY _ DIGIT ) ( ( BINARY _ DIGIT | ' _ ' ) * ( BINARY _ DIGIT ) ) ? / / Binary 
 - | ( ( ( ' 0 ' . . ' 7 ' ) | ' _ ' ) * ( ' 0 ' . . ' 7 ' ) ) ? / / If empty 0 , otherwise octal ( which may start with an underscore ) 
 + / / Hexa 
 + ( ( ' x ' | ' X ' ) ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? 
 + / / Binary 
 + | ( ' b ' | ' B ' ) ( BINARY _ DIGIT ) ( ( BINARY _ DIGIT | ' _ ' ) * ( BINARY _ DIGIT ) ) ? 
 + / / If empty 0 , otherwise octal ( which may start with an underscore ) 
 + | ( ( ( ' 0 ' . . ' 7 ' ) | ' _ ' ) * ( ' 0 ' . . ' 7 ' ) ) ? 
 ) 
 - | ( ' 1 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? / / Non - zero decimal 
 + / / Non - zero decimal 
 + | ( ' 1 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? 
 ) 
 ; 
 
 protected LONG _ LITERAL 
 : ( ' 0 ' 
 - ( ( ' x ' | ' X ' ) ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? / / Hexa 
 - | ( ' b ' | ' B ' ) ( BINARY _ DIGIT ) ( ( BINARY _ DIGIT | ' _ ' ) * ( BINARY _ DIGIT ) ) ? / / Binary 
 - | ( ( ( ' 0 ' . . ' 7 ' ) | ' _ ' ) * ( ' 0 ' . . ' 7 ' ) ) ? / / If empty 0 , otherwise octal ( which may start with an underscore ) 
 + / / Hexa 
 + ( ( ' x ' | ' X ' ) ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? 
 + / / Binary 
 + | ( ' b ' | ' B ' ) ( BINARY _ DIGIT ) ( ( BINARY _ DIGIT | ' _ ' ) * ( BINARY _ DIGIT ) ) ? 
 + / / If empty 0 , otherwise octal ( which may start with an underscore ) 
 + | ( ( ( ' 0 ' . . ' 7 ' ) | ' _ ' ) * ( ' 0 ' . . ' 7 ' ) ) ? 
 ) 
 - | ( ' 1 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? / / Non - zero decimal 
 + / / Non - zero decimal 
 + | ( ' 1 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? 
 ) 
 / / long signifier 
 ( ' l ' | ' L ' ) 
 @ @ - 1967 , 7 + 1994 , 7 @ @ protected LONG _ LITERAL 
 protected FLOAT _ LITERAL 
 : ( 
 ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? ' . ' ) = > 
 - ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? 
 + ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? 
 | ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) 
 ) 
 ( EXPONENT ) ? ( ' f ' | ' F ' ) ? 
 @ @ - 1979 , 7 + 2006 , 7 @ @ protected FLOAT _ LITERAL 
 protected DOUBLE _ LITERAL 
 : ( 
 ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? ' . ' ) = > 
 - ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? 
 + ( ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) ? 
 | ' . ' ( ( ' 0 ' . . ' 9 ' ) ( ( ' 0 ' . . ' 9 ' | ' _ ' ) * ( ' 0 ' . . ' 9 ' ) ) ? ) 
 ) 
 | 
 @ @ - 1992 , 7 + 2019 , 8 @ @ protected HEX _ FLOAT _ LITERAL 
 : ' 0 ' ( ' x ' | ' X ' ) 
 ( 
 ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? ' . ' ) = > 
 - ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ' . ' ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? 
 + ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ' . ' 
 + ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? 
 | ' . ' ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) 
 ) 
 | 
 @ @ - 2005 , 7 + 2033 , 8 @ @ protected HEX _ DOUBLE _ LITERAL 
 : ' 0 ' ( ' x ' | ' X ' ) 
 ( 
 ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? ' . ' ) = > 
 - ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ' . ' ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? 
 + ( ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ' . ' 
 + ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) ? 
 | ' . ' ( ( HEX _ DIGIT ) ( ( HEX _ DIGIT | ' _ ' ) * ( HEX _ DIGIT ) ) ? ) 
 ) 
 | 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 
 index 763394e . . 303b9d3 100755 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocLexer . g4 
 @ @ - 65 , 7 + 65 , 7 @ @ AUTHOR _ LITERAL : ' @ author ' { isJavadocTagAvailable } ? ; 
 DEPRECATED _ LITERAL : ' @ deprecated ' { isJavadocTagAvailable } ? ; 
 EXCEPTION _ LITERAL : ' @ exception ' { isJavadocTagAvailable } ? - > pushMode ( exception ) ; 
 PARAM _ LITERAL : ' @ param ' { isJavadocTagAvailable } ? - > pushMode ( param ) ; 
 - RETURN _ LITERAL : ' @ return ' { isJavadocTagAvailable } ? ; 
 + RETURN _ LITERAL : ' @ return ' { isJavadocTagAvailable } ? ; 
 SEE _ LITERAL : ' @ see ' { isJavadocTagAvailable } ? - > pushMode ( seeLink ) ; 
 SERIAL _ LITERAL : ' @ serial ' { isJavadocTagAvailable } ? ; 
 SERIAL _ FIELD _ LITERAL : ' @ serialField ' { isJavadocTagAvailable } ? - > pushMode ( serialField ) ; 
 @ @ - 93 , 7 + 93 , 7 @ @ CHAR : . ; 
 mode param ; 
 Space0 : WS - > type ( WS ) ; 
 PARAMETER _ NAME : [ a - zA - Z0 - 9 < > _ $ ] + - > mode ( DEFAULT _ MODE ) ; 
 - Char1 : . 
 + Char1 : . 
 { 
 skipCurrentTokenConsuming ( ) ; 
 } - > skip , mode ( DEFAULT _ MODE ) ; 
 @ @ - 131 , 7 + 131 , 7 @ @ End20 : JAVADOC _ INLINE _ TAG _ END 
 - > type ( JAVADOC _ INLINE _ TAG _ END ) , mode ( DEFAULT _ MODE ) 
 ; 
 / / exit from ' seeLink ' mode without consuming current character 
 - Char2 : . 
 + Char2 : . 
 { 
 skipCurrentTokenConsuming ( ) ; 
 referenceCatched = false ; 
 @ @ - 177 , 7 + 177 , 7 @ @ End2 : JAVADOC _ INLINE _ TAG _ END 
 } 
 - > type ( JAVADOC _ INLINE _ TAG _ END ) , mode ( DEFAULT _ MODE ) 
 ; 
 - Char20 : . 
 + Char20 : . 
 { 
 skipCurrentTokenConsuming ( ) ; 
 referenceCatched = false ; 
 @ @ - 187 , 7 + 187 , 7 @ @ Char20 : . 
 mode serialField ; 
 Space2 : WS - > type ( WS ) ; 
 FIELD _ NAME : [ a - zA - Z0 - 9 _ $ ] + - > mode ( serialFieldFieldType ) ; 
 - Char3 : . 
 + Char3 : . 
 { 
 skipCurrentTokenConsuming ( ) ; 
 referenceCatched = false ; 
 @ @ - 328 , 7 + 328 , 7 @ @ DIGIT : [ 0 - 9 ] ; 
 
 fragment 
 NAME _ CHAR : NAME _ START _ CHAR 
 - | ' - ' | ' _ ' | ' . ' | DIGIT 
 + | ' - ' | ' _ ' | ' . ' | DIGIT 
 | ' \ u00B7 ' 
 | ' \ u0300 ' . . ' \ u036F ' 
 | ' \ u203F ' . . ' \ u2040 ' 
 @ @ - 337 , 10 + 337 , 10 @ @ NAME _ CHAR : NAME _ START _ CHAR 
 fragment 
 NAME _ START _ CHAR 
 : [ : a - zA - Z ] 
 - | ' \ u2070 ' . . ' \ u218F ' 
 - | ' \ u2C00 ' . . ' \ u2FEF ' 
 - | ' \ u3001 ' . . ' \ uD7FF ' 
 - | ' \ uF900 ' . . ' \ uFDCF ' 
 + | ' \ u2070 ' . . ' \ u218F ' 
 + | ' \ u2C00 ' . . ' \ u2FEF ' 
 + | ' \ u3001 ' . . ' \ uD7FF ' 
 + | ' \ uF900 ' . . ' \ uFDCF ' 
 | ' \ uFDF0 ' . . ' \ uFFFD ' 
 ; 
 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParser . g4 b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParser . g4 
 index dacf17d . . 1f024f1 100755 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParser . g4 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / grammars / javadoc / JavadocParser . g4 
 @ @ - 784 , 12 + 784 , 12 @ @ singletonTag : OPEN 
 | P _ HTML _ TAG _ NAME 
 | LI _ HTML _ TAG _ NAME 
 | TR _ HTML _ TAG _ NAME 
 - | TD _ HTML _ TAG _ NAME 
 - | TH _ HTML _ TAG _ NAME 
 + | TD _ HTML _ TAG _ NAME 
 + | TH _ HTML _ TAG _ NAME 
 | BODY _ HTML _ TAG _ NAME 
 | COLGROUP _ HTML _ TAG _ NAME 
 | DD _ HTML _ TAG _ NAME 
 - | DT _ HTML _ TAG _ NAME 
 + | DT _ HTML _ TAG _ NAME 
 | HEAD _ HTML _ TAG _ NAME 
 | HTML _ HTML _ TAG _ NAME 
 | OPTION _ HTML _ TAG _ NAME

NEAREST DIFF:
diff - - git a / ChangeLog b / ChangeLog 
 index d043b55 . . 186f278 100644 
 - - - a / ChangeLog 
 + + + b / ChangeLog 
 @ @ - 1 , 5 + 1 , 10 @ @ 
 2001 - 11 - 26 Oliver Burn < oliver @ cortexebusiness . com . au > 
 
 + 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 + 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g : 
 + 	 Incorporate changes made to the ANTLR Java grammar that checkstyle is 
 + 	 based off . 
 + 
 	 * src / tests / com / puppycrawl / tools / checkstyle / CheckerTest . java 
 	 * src / checkstyle / com / puppycrawl / tools / checkstyle / java . g : Included patch 
 	 to check whitespace after synchronized and catch keywords . From Lars 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 index 4fbca2e . . 80849b6 100644 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . g 
 @ @ - 56 , 6 + 56 , 7 @ @ tokens { 
 	 POST _ INC ; POST _ DEC ; METHOD _ CALL ; EXPR ; ARRAY _ INIT ; 
 	 IMPORT ; UNARY _ MINUS ; UNARY _ PLUS ; CASE _ GROUP ; ELIST ; FOR _ INIT ; FOR _ CONDITION ; 
 	 FOR _ ITERATOR ; EMPTY _ STAT ; FINAL = " final " ; ABSTRACT = " abstract " ; 
 + 	 STRICTFP = " strictfp " ; SUPER _ CTOR _ CALL ; CTOR _ CALL ; 
 } 
 	 
 { 
 @ @ - 112 , 16 + 113 , 6 @ @ declaration ! 
 	 	 { # declaration = # v ; } 
 	 ; 
 
 - / / A list of zero or more modifiers . We could have used ( modifier ) * in 
 - / / place of a call to modifiers , but I thought it was a good idea to keep 
 - / / this rule separate so they can easily be collected in a Vector if 
 - / / someone so desires 
 - modifiers 
 - 	 : 	 ( modifier ) * 
 - 	 	 { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } 
 - 	 ; 
 - 
 - 
 / / A type specification is a type name with possible brackets afterwards 
 / / ( which would make it an array type ) . 
 typeSpec [ boolean addImagNode ] 
 @ @ - 192 , 6 + 183 , 14 @ @ identifierStar 
 } 
 	 ; 
 
 + / / A list of zero or more modifiers . We could have used ( modifier ) * in 
 + / / place of a call to modifiers , but I thought it was a good idea to keep 
 + / / this rule separate so they can easily be collected in a Vector if 
 + / / someone so desires 
 + modifiers 
 + 	 : 	 ( modifier ) * 
 + 	 	 { # modifiers = # ( [ MODIFIERS , " MODIFIERS " ] , # modifiers ) ; } 
 + 	 ; 
 
 / / modifiers for Java classes , interfaces , class / instance vars and methods 
 modifier 
 @ @ - 205 , 11 + 204 , 11 @ @ modifier 
 	 | 	 " native " 
 	 | 	 " threadsafe " 
 	 | 	 " synchronized " 
 - / / 	 | 	 " const " 	 	 	 / / reserved word ; leave out 
 + / / 	 | 	 " const " 	 	 	 / / reserved word , but not valid 
 	 | 	 " volatile " 
 + 	 | 	 " strictfp " 
 	 ; 
 
 - 
 / / Definition of a Java class 
 classDefinition ! [ AST modifiers ] 
 	 : 	 " class " IDENT 
 @ @ - 275 , 7 + 274 , 7 @ @ implementsClause 
 field ! 
 	 : 	 / / method , constructor , or variable declaration 
 	 	 mods : modifiers 
 - 	 	 ( 	 h : ctorHead s : compoundStatement / / constructor 
 + 	 	 ( 	 h : ctorHead s : constructorBody / / constructor 
 	 	 	 { # field = # ( # [ CTOR _ DEF , " CTOR _ DEF " ] , mods , h , s ) ; } 
 
 	 	 | 	 cd : classDefinition [ # mods ] / / inner class 
 @ @ - 290 , 9 + 289 , 10 @ @ field ! 
 	 	 	 	 / / parse the formal parameter declarations . 
 	 	 	 	 LPAREN ! param : parameterDeclarationList RPAREN ! 
 
 - 	 	 	 	 rt : returnTypeBrackersOnEndOfMethodHead [ # t ] 
 + 	 	 	 	 rt : declaratorBrackets [ # t ] 
 
 - 	 	 	 	 / / get the list of exceptions that this method is declared to throw 
 + 	 	 	 	 / / get the list of exceptions that this method is 
 + 	 	 	 	 / / declared to throw 
 	 	 	 	 ( tc : throwsClause ) ? 
 
 	 	 	 	 ( s2 : compoundStatement | SEMI ) 
 @ @ - 318 , 6 + 318 , 38 @ @ field ! 
 	 	 { # field = # ( # [ INSTANCE _ INIT , " INSTANCE _ INIT " ] , s4 ) ; } 
 	 ; 
 
 + constructorBody 
 + : lc : LCURLY ^ { # lc . setType ( SLIST ) ; } 
 + 	 	 / / Predicate might be slow but only checked once per constructor def 
 + 	 	 / / not for general methods . 
 + 	 	 ( 	 ( explicitConstructorInvocation ) = > explicitConstructorInvocation 
 + 	 	 | 
 + 	 	 ) 
 + ( statement ) * 
 + RCURLY ! 
 + ; 
 + 
 + explicitConstructorInvocation 
 + : ( 	 options { 
 + 	 	 	 	 / / this / super can begin a primaryExpression too ; with finite 
 + 	 	 	 	 / / lookahead ANTLR will think the 3rd alternative conflicts 
 + 	 	 	 	 / / with 1 , 2 . I am shutting off warning since ANTLR resolves 
 + 	 	 	 	 / / the nondeterminism by correctly matching alts 1 or 2 when 
 + 	 	 	 	 / / it sees this ( or super ( 
 + 	 	 	 	 generateAmbigWarnings = false ; 
 + 	 	 	 } 
 + 	 	 : 	 " this " ! lp1 : LPAREN ^ argList RPAREN ! SEMI ! 
 + 	 	 	 { # lp1 . setType ( CTOR _ CALL ) ; } 
 + 
 + 	 | " super " ! lp2 : LPAREN ^ argList RPAREN ! SEMI ! 
 + 	 	 	 { # lp2 . setType ( SUPER _ CTOR _ CALL ) ; } 
 + 
 + 	 	 	 / / ( new Outer ( ) ) . super ( ) ( create enclosing instance ) 
 + 	 	 | 	 primaryExpression DOT ! " super " ! lp3 : LPAREN ^ argList RPAREN ! SEMI ! 
 + 	 	 	 { # lp3 . setType ( SUPER _ CTOR _ CALL ) ; } 
 + 	 	 ) 
 + ; 
 + 
 variableDefinitions [ AST mods , AST t ] 
 	 : 	 variableDeclarator [ getASTFactory ( ) . dupTree ( mods ) , 
 	 	 	 	 	 	 getASTFactory ( ) . dupTree ( t ) ] 
 @ @ - 392 , 11 + 424 , 6 @ @ throwsClause 
 	 ; 
 
 
 - returnTypeBrackersOnEndOfMethodHead [ AST typ ] 
 - 	 : 	 { # returnTypeBrackersOnEndOfMethodHead = typ ; } 
 - 	 	 ( lb : LBRACK ^ { # lb . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * 
 - 	 ; 
 - 
 / / A list of formal parameters 
 parameterDeclarationList 
 	 : 	 ( parameterDeclaration ( COMMA ! parameterDeclaration ) * ) ? 
 @ @ - 407 , 16 + 434 , 11 @ @ parameterDeclarationList 
 / / A formal parameter . 
 parameterDeclaration ! 
 	 : 	 pm : parameterModifier t : typeSpec [ false ] id : IDENT 
 - 	 	 pd : parameterDeclaratorBrackets [ # t ] 
 + 	 	 pd : declaratorBrackets [ # t ] 
 	 	 { # parameterDeclaration = # ( # [ PARAMETER _ DEF , " PARAMETER _ DEF " ] , 
 	 	 	 	 	 	 	 	 	 pm , # ( [ TYPE , " TYPE " ] , pd ) , id ) ; } 
 	 ; 
 
 - parameterDeclaratorBrackets [ AST t ] 
 - 	 : 	 { # parameterDeclaratorBrackets = t ; } 
 - 	 	 ( lb : LBRACK ^ { # lb . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * 
 - 	 ; 
 - 
 parameterModifier 
 	 : 	 ( f : " final " ) ? 
 	 	 { # parameterModifier = # ( # [ MODIFIERS , " MODIFIERS " ] , f ) ; } 
 @ @ - 443 , 15 + 465 , 6 @ @ statement 
 	 / / A list of statements in curly braces - - start a new scope ! 
 	 : 	 compoundStatement 
 
 - 	 / / class definition 
 - 	 | 	 classDefinition [ # [ MODIFIERS , " MODIFIERS " ] ] 
 - 
 - 	 / / final class definition 
 - 	 | 	 " final " ! classDefinition [ # ( # [ MODIFIERS , " MODIFIERS " ] , # [ FINAL , " final " ] ) ] 
 - 
 - 	 / / abstract class definition 
 - 	 | 	 " abstract " ! classDefinition [ # ( # [ MODIFIERS , " MODIFIERS " ] , # [ ABSTRACT , " abstract " ] ) ] 
 - 
 	 / / declarations are ambiguous with " ID DOT " relative to expression 
 	 / / statements . Must backtrack to be sure . Could use a semantic 
 	 / / predicate to test symbol table to see what the type was coming 
 @ @ - 463 , 6 + 476 , 9 @ @ statement 
 	 / / side - effects . 
 	 | 	 expression SEMI ! 
 
 + 	 / / class definition 
 + 	 | 	 m : modifiers ! classDefinition [ # m ] 
 + 
 	 / / Attach a label to the front of a statement 
 	 | 	 IDENT c : COLON ^ { # c . setType ( LABELED _ STAT ) ; } statement 
 
 @ @ - 651 , 9 + 667 , 9 @ @ assignmentExpression 
 
 / / conditional test ( level 12 ) 
 conditionalExpression 
 - : logicalOrExpression 
 - ( QUESTION ^ assignmentExpression COLON conditionalExpression ) ? 
 - ; 
 + 	 : 	 logicalOrExpression 
 + 	 	 ( QUESTION ^ assignmentExpression COLON ! conditionalExpression ) ? 
 + 	 ; 
 
 
 / / logical or ( | | ) ( level 11 ) 
 @ @ - 767 , 10 + 783 , 10 @ @ postfixExpression 
 	 	 	 	 | " this " 
 	 	 	 	 | " class " 
 	 	 	 	 | newExpression 
 - 	 	 	 	 | " super " LPAREN ( expressionList ) ? RPAREN 
 + 	 	 	 	 | " super " / / ClassName . super . field 
 	 	 	 	 ) 
 	 	 	 / / the above line needs a semantic check to make sure " class " 
 - 	 	 	 / / is the _ last _ qualifier . 
 + 	 	 	 / / is the _ last _ qualifier . 
 
 	 	 	 / / allow ClassName [ ] . class 
 	 	 | 	 ( lbc : LBRACK ^ { # lbc . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) + 
 @ @ - 784 , 6 + 800 , 9 @ @ postfixExpression 
 	 	 	 / / x [ 2 ] ( 4 ) which are not valid in Java . If this grammar were used 
 	 	 	 / / to validate a Java program a semantic check would be needed , or 
 	 	 	 / / this rule would get really ugly . . . 
 + 	 	 	 / / It also allows ctor invocation like super ( 3 ) which is now 
 + 	 	 	 / / handled by the explicit constructor rule , but it would 
 + 	 	 	 / / be hard to syntactically prevent ctor calls here 
 	 	 | 	 lp : LPAREN ^ { # lp . setType ( METHOD _ CALL ) ; } 
 	 	 	 	 argList 
 	 	 	 RPAREN ! 
 @ @ - 795 , 24 + 814 , 23 @ @ postfixExpression 
 	 	 | 	 de : DEC ^ { # de . setType ( POST _ DEC ) ; } 
 	 	 | 	 / / nothing 
 	 	 ) 
 - 
 - 	 	 / / look for int . class and int [ ] . class 
 - 	 | 	 builtInType 
 - 	 	 ( lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * 
 - 	 	 DOT ^ " class " 
 	 ; 
 
 / / the basic element of an expression 
 primaryExpression 
 	 : 	 i1 : IDENT { sFirstIdent = i1 . getText ( ) ; } 
 - 	 | 	 newExpression 
 	 | 	 constant 
 - 	 | 	 " super " 
 	 | 	 " true " 
 	 | 	 " false " 
 	 | 	 " this " 
 	 | 	 " null " 
 + 	 | 	 newExpression 
 	 | 	 LPAREN ! assignmentExpression RPAREN ! 
 + 	 | 	 " super " 
 + 	 	 / / look for int . class and int [ ] . class 
 + 	 | 	 builtInType 
 + 	 	 ( lbt : LBRACK ^ { # lbt . setType ( ARRAY _ DECLARATOR ) ; } RBRACK ! ) * 
 + 	 	 DOT ^ " class " 
 	 ; 
 
 / * * object instantiation . 
 @ @ - 909 , 6 + 927 , 8 @ @ constant 
 	 | 	 CHAR _ LITERAL 
 	 | 	 STRING _ LITERAL 
 	 | 	 NUM _ FLOAT 
 + 	 | 	 NUM _ LONG 
 + 	 | 	 NUM _ DOUBLE 
 	 ; 
 
 
 @ @ - 921 , 7 + 941 , 11 @ @ options { 
 	 exportVocab = GeneratedJava ; / / call the vocabulary " GeneratedJava " 
 	 testLiterals = false ; / / don ' t automatically test for literals 
 	 k = 4 ; / / four characters of lookahead 
 - / / 	 charVocabulary = ' \ u0003 ' . . ' \ uFFFF ' ; 
 + 	 charVocabulary = ' \ u0003 ' . . ' \ uFFFF ' ; 
 + 	 / / without inlining some bitset tests , couldn ' t do unicode ; 
 + 	 / / I need to make ANTLR generate smaller bitsets ; see 
 + 	 / / bottom of JavaLexer . java 
 + 	 codeGenBitsetTestThreshold = 20 ; 
 } 
 
 
 @ @ - 979 , 13 + 1003 , 14 @ @ SEMI 	 	 	 : 	 ' ; ' 	 	 ; 
 WS 	 : 	 ( 	 ' ' 
 	 	 | 	 ' \ t ' 
 	 	 | 	 ' \ f ' 
 - 	 	 / / handle newlines 
 - 	 	 | 	 ( 	 " \ r \ n " / / Evil DOS 
 + 	 	 	 / / handle newlines 
 + 	 	 | 	 ( 	 options { generateAmbigWarnings = false ; } 
 + 	 	 	 : 	 " \ r \ n " / / Evil DOS 
 	 	 	 | 	 ' \ r ' / / Macintosh 
 	 	 	 | 	 ' \ n ' / / Unix ( the right way ) 
 	 	 	 ) 
 	 	 	 { newline ( ) ; } 
 - 	 	 ) 
 + 	 	 ) + 
 	 	 { _ ttype = Token . SKIP ; } 
 	 ; 
 
 @ @ - 1117 , 9 + 1142 , 19 @ @ IDENT 
 
 / / a numeric literal 
 NUM _ INT 
 - 	 { boolean isDecimal = false ; } 
 - 	 : 	 ' . ' { _ ttype = DOT ; } 
 - 	 	 	 ( ( ' 0 ' . . ' 9 ' ) + ( EXPONENT ) ? ( FLOAT _ SUFFIX ) ? { _ ttype = NUM _ FLOAT ; } ) ? 
 + 	 { boolean isDecimal = false ; Token t = null ; } 
 + : ' . ' { _ ttype = DOT ; } 
 + ( 	 ( ' 0 ' . . ' 9 ' ) + ( EXPONENT ) ? ( f1 : FLOAT _ SUFFIX { t = f1 ; } ) ? 
 + { 
 + 	 	 	 	 if ( t ! = null & & t . getText ( ) . toUpperCase ( ) . indexOf ( ' D ' ) > = 0 ) { 
 + 	 _ ttype = NUM _ DOUBLE ; 
 + 	 	 	 	 } 
 + 	 	 	 	 else { 
 + 	 _ ttype = NUM _ FLOAT ; 
 + 	 	 	 	 } 
 + 	 	 	 	 } 
 + ) ? 
 + 
 	 | 	 ( 	 ' 0 ' { isDecimal = true ; } / / special case for just ' 0 ' 
 	 	 	 ( 	 ( ' x ' | ' X ' ) 
 	 	 	 	 ( 	 	 	 	 	 	 	 	 	 	 	 / / hex 
 @ @ - 1137 , 16 + 1172 , 23 @ @ NUM _ INT 
 	 	 	 ) ? 
 	 	 | 	 ( ' 1 ' . . ' 9 ' ) ( ' 0 ' . . ' 9 ' ) * { isDecimal = true ; } 	 	 / / non - zero decimal 
 	 	 ) 
 - 	 	 ( 	 ( ' l ' | ' L ' ) 
 + 	 	 ( 	 ( ' l ' | ' L ' ) { _ ttype = NUM _ LONG ; } 
 	 	 
 	 	 / / only check to see if it ' s a float if looks like decimal so far 
 	 	 | 	 { isDecimal } ? 
 - 	 	 	 ( 	 ' . ' ( ' 0 ' . . ' 9 ' ) * ( EXPONENT ) ? ( FLOAT _ SUFFIX ) ? 
 - 	 	 	 | 	 EXPONENT ( FLOAT _ SUFFIX ) ? 
 - 	 	 	 | 	 FLOAT _ SUFFIX 
 - 	 	 	 ) 
 - 	 	 	 { _ ttype = NUM _ FLOAT ; } 
 - 	 	 ) ? 
 + ( ' . ' ( ' 0 ' . . ' 9 ' ) * ( EXPONENT ) ? ( f2 : FLOAT _ SUFFIX { t = f2 ; } ) ? 
 + | EXPONENT ( f3 : FLOAT _ SUFFIX { t = f3 ; } ) ? 
 + | f4 : FLOAT _ SUFFIX { t = f4 ; } 
 + ) 
 + { 
 + 	 	 	 if ( t ! = null & & t . getText ( ) . toUpperCase ( ) . indexOf ( ' D ' ) > = 0 ) { 
 + _ ttype = NUM _ DOUBLE ; 
 + 	 	 	 } 
 + else { 
 + _ ttype = NUM _ FLOAT ; 
 + 	 	 	 } 
 + 	 	 	 } 
 + ) ? 
 	 ; 
 
 
 diff - - git a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g 
 index 4e98a15 . . 89e6e38 100644 
 - - - a / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g 
 + + + b / src / checkstyle / com / puppycrawl / tools / checkstyle / java . tree . g 
 @ @ - 117 , 6 + 117 , 7 @ @ modifier 
 | " synchronized " 
 | " const " 
 | " volatile " 
 + 	 | 	 " strictfp " 
 ; 
 
 extendsClause 
 @ @ - 163 , 7 + 164 , 7 @ @ ctorDef 
 MyModifierSet mods ; 
 MethodSignature ms ; 
 } 
 - : # ( CTOR _ DEF mods = modifiers ms = methodHead { ver . reportStartMethodBlock ( ) ; } slist { ver . reportEndMethodBlock ( ) ; } ) 
 + : # ( CTOR _ DEF mods = modifiers ms = methodHead { ver . reportStartMethodBlock ( ) ; } ctorSList { ver . reportEndMethodBlock ( ) ; } ) 
 { 
 ver . verifyMethodJavadoc ( mods , null , ms ) ; 
 } 
 @ @ - 293 , 6 + 294 , 10 @ @ identifierStar 
 | # ( DOT ignore = identifier ( STAR | IDENT ) ) 
 ; 
 
 + ctorSList 
 + 	 : 	 # ( SLIST ( ctorCall ) ? ( stat ) * ) 
 + 	 ; 
 + 
 slist 
 	 : 	 # ( SLIST ( stat ) * ) 
 	 ; 
 @ @ - 434 , 8 + 439 , 9 @ @ primaryExpression 
 | " this " 
 | " class " { if ( firstExprIdent ! = null ) { ver . reportReference ( firstExprIdent . getText ( ) ) ; } } 
 | # ( " new " IDENT elist ) 
 + 	 	 	 	 | " super " 
 ) 
 - | # ( ARRAY _ DECLARATOR type ) 
 + | # ( ARRAY _ DECLARATOR typeSpecArray ) 
 | builtInType ( " class " ) ? 
 ) 
 ) 
 @ @ - 452 , 6 + 458 , 15 @ @ primaryExpression 
 | typeSpec / / type name used with instanceof 
 ; 
 
 + ctorCall 
 + 	 : 	 # ( CTOR _ CALL elist ) 
 + 	 | 	 # ( SUPER _ CTOR _ CALL 
 + 	 	 	 ( 	 elist 
 + 	 	 	 | 	 primaryExpression elist 
 + 	 	 	 ) 
 + 	 	 ) 
 + 	 ; 
 + 
 arrayIndex 
 	 : 	 # ( INDEX _ OP primaryExpression expression ) 
 	 ; 
 @ @ - 461 , 6 + 476 , 8 @ @ constant 
 | CHAR _ LITERAL 
 | STRING _ LITERAL 
 | NUM _ FLOAT 
 + | NUM _ DOUBLE 
 + | NUM _ LONG 
 ; 
 
 newExpression
