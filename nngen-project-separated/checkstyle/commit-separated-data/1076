BLEU SCORE: 0.04344259980627079

TEST MSG: Issue # 3102 : DesignForExtension : consider overridable methods and javadoc
GENERATED MSG: Issue # 49 . Added support of Javadoc comments . Extended API to create Javadoc Checks .

TEST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheck . java <nl> index 5ad6f33 . . 12c52bc 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheck . java <nl> @ @ - 19 , 55 + 19 , 77 @ @ <nl> <nl> package com . puppycrawl . tools . checkstyle . checks . design ; <nl> <nl> + import java . util . Arrays ; <nl> + import java . util . Optional ; <nl> + import java . util . Set ; <nl> + import java . util . function . Predicate ; <nl> + import java . util . stream . Collectors ; <nl> + import java . util . stream . Stream ; <nl> + <nl> import com . puppycrawl . tools . checkstyle . api . AbstractCheck ; <nl> import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . Scope ; <nl> import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> import com . puppycrawl . tools . checkstyle . utils . ScopeUtils ; <nl> + import com . puppycrawl . tools . checkstyle . utils . TokenUtils ; <nl> <nl> / * * <nl> - * Checks find classes that are designed for inheritance . <nl> + * The check finds classes that are designed for extension ( subclass creation ) . <nl> * <nl> * < p > <nl> - * Nothing wrong could be with founded classes <nl> - * this Check make sence only for library project ( not a application projects ) <nl> - * who care about ideal OOP design to make sure clas work in all cases even misusage . <nl> - * Even in library projects this Check most likely find classes that are not required to check . <nl> - * User need to use suppressions extensively to got a benefit from this Check and avoid <nl> - * false positives . <nl> + * Nothing wrong could be with founded classes . <nl> + * This check makes sense only for library projects ( not an application projects ) <nl> + * which care of ideal OOP - design to make sure that class works in all cases even misusage . <nl> + * Even in library projects this check most likely will find classes that are designed for extension <nl> + * by somebody . User needs to use suppressions extensively to got a benefit from this check , <nl> + * and keep in suppressions all confirmed / known classes that are deigned for inheritance <nl> + * intentionally to let the check catch only new classes , and bring this to team / user attention . <nl> * < / p > <nl> * <nl> * < p > <nl> - * ATTENTION : Only user can deside whether class is designed for extension or not . <nl> - * Check just show all possible . If smth inappropriate is found please use supporession . <nl> + * ATTENTION : Only user can decide whether a class is designed for extension or not . <nl> + * The check just shows all classes which are possibly designed for extension . <nl> + * If smth inappropriate is found please use suppression . <nl> * < / p > <nl> * <nl> * < p > <nl> - * More specifically , it enforces a programming style <nl> - * where superclasses provide empty " hooks " that can be <nl> - * implemented by subclasses . <nl> + * ATTENTION : If the method which can be overridden in a subclass has a javadoc comment <nl> + * ( a good practise is to explain its self - use of overridable methods ) the check will not <nl> + * rise a violation . The violation can also be skipped if the method which can be overridden <nl> + * in a subclass has one or more annotations that are specified in ignoredAnnotations <nl> + * option . Note , that by default @ Override annotation is not included in the <nl> + * ignoredAnnotations set as in a subclass the method which has the annotation can also be <nl> + * overridden in its subclass . <nl> * < / p > <nl> * <nl> - * < p > The exact rule is that non - private , non - static methods in <nl> - * non - final classes ( or classes that do not <nl> - * only have private constructors ) must either be <nl> - * < ul > <nl> - * < li > abstract or < / li > <nl> - * < li > final or < / li > <nl> - * < li > have an empty implementation < / li > <nl> - * < / ul > <nl> + * < p > <nl> + * More specifically , the check enforces a programming style where superclasses provide empty <nl> + * " hooks " that can be implemented by subclasses . <nl> + * < / p > <nl> * <nl> + * < p > <nl> + * The check finds classes that have overridable methods ( public or protected methods <nl> + * that are non - static , not - final , non - abstract ) and have non - empty implementation . <nl> + * < / p > <nl> + * <nl> + * < p > <nl> + * This protects superclasses against being broken by subclasses . The downside is that subclasses <nl> + * are limited in their flexibility , in particular , they cannot prevent execution of code in the <nl> + * superclass , but that also means that subclasses cannot forget to call their super method . <nl> + * < / p > <nl> * <nl> * < p > <nl> - * This protects superclasses against being broken by <nl> - * subclasses . The downside is that subclasses are limited <nl> - * in their flexibility , in particular they cannot prevent <nl> - * execution of code in the superclass , but that also <nl> - * means that subclasses can ' t forget to call their super <nl> - * method . <nl> + * The check has the following options : <nl> * < / p > <nl> + * < ul > <nl> + * < li > <nl> + * ignoredAnnotations - annotations which allow the check to skip the method from validation . <nl> + * Default value is < b > Test , Before , After , BeforeClass , AfterClass < / b > . <nl> + * < / li > <nl> + * < / ul > <nl> * <nl> * @ author lkuehne <nl> + * @ author Andrei Selkin <nl> * / <nl> public class DesignForExtensionCheck extends AbstractCheck { <nl> <nl> @ @ - 77 , 6 + 99 , 20 @ @ public class DesignForExtensionCheck extends AbstractCheck { <nl> * / <nl> public static final String MSG _ KEY = " design . forExtension " ; <nl> <nl> + / * * <nl> + * A set of annotations which allow the check to skip the method from validation . <nl> + * / <nl> + private Set < String > ignoredAnnotations = Stream . of ( " Test " , " Before " , " After " , " BeforeClass " , <nl> + " AfterClass " ) . collect ( Collectors . toSet ( ) ) ; <nl> + <nl> + / * * <nl> + * Sets annotations which allow the check to skip the method from validation . <nl> + * @ param ignoredAnnotations method annotations . <nl> + * / <nl> + public void setIgnoredAnnotations ( String . . . ignoredAnnotations ) { <nl> + this . ignoredAnnotations = Arrays . stream ( ignoredAnnotations ) . collect ( Collectors . toSet ( ) ) ; <nl> + } <nl> + <nl> @ Override <nl> public int [ ] getDefaultTokens ( ) { <nl> return getAcceptableTokens ( ) ; <nl> @ @ - 84 , 6 + 120 , 9 @ @ public class DesignForExtensionCheck extends AbstractCheck { <nl> <nl> @ Override <nl> public int [ ] getAcceptableTokens ( ) { <nl> + / / The check does not subscribe to CLASS _ DEF token as now it is stateless . If the check <nl> + / / subscribes to CLASS _ DEF token it will become stateful , since we need to have additional <nl> + / / stack to hold CLASS _ DEF tokens . <nl> return new int [ ] { TokenTypes . METHOD _ DEF } ; <nl> } <nl> <nl> @ @ - 93 , 52 + 132 , 169 @ @ public class DesignForExtensionCheck extends AbstractCheck { <nl> } <nl> <nl> @ Override <nl> + public boolean isCommentNodesRequired ( ) { <nl> + return true ; <nl> + } <nl> + <nl> + @ Override <nl> public void visitToken ( DetailAST ast ) { <nl> - / / nothing to do for Interfaces <nl> - if ( ! ScopeUtils . isInInterfaceOrAnnotationBlock ( ast ) <nl> - & & ! isPrivateOrFinalOrAbstract ( ast ) <nl> - & & ScopeUtils . getSurroundingScope ( ast ) . isIn ( Scope . PROTECTED ) ) { <nl> - <nl> - / / method is ok if it is implementation can verified to be empty <nl> - / / Note : native methods don ' t have impl in java code , so <nl> - / / implementation can be null even if method not abstract <nl> - final DetailAST implementation = ast . findFirstToken ( TokenTypes . SLIST ) ; <nl> - final boolean nonEmptyImplementation = implementation = = null <nl> - | | implementation . getFirstChild ( ) . getType ( ) ! = TokenTypes . RCURLY ; <nl> - <nl> - final DetailAST classDef = findContainingClass ( ast ) ; <nl> - final DetailAST classMods = classDef . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> - / / check if the containing class can be subclassed <nl> - final boolean classCanBeSubclassed = classDef . getType ( ) ! = TokenTypes . ENUM _ DEF <nl> - & & ! classMods . branchContains ( TokenTypes . FINAL ) ; <nl> - <nl> - if ( nonEmptyImplementation & & classCanBeSubclassed <nl> - & & hasDefaultOrExplicitNonPrivateCtor ( classDef ) ) { <nl> - <nl> - final String name = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; <nl> - log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG _ KEY , name ) ; <nl> + if ( ! hasJavadocComment ( ast ) <nl> + & & ( isNativeMethod ( ast ) <nl> + | | ! hasEmptyImplementation ( ast ) ) <nl> + & & canBeOverridden ( ast ) <nl> + & & ! hasIgnoredAnnotation ( ast , ignoredAnnotations ) ) { <nl> + <nl> + final DetailAST classDef = getNearestClassOrEnumDefinition ( ast ) ; <nl> + if ( canBeSubclassed ( classDef ) ) { <nl> + final String className = classDef . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; <nl> + final String methodName = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; <nl> + log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG _ KEY , className , methodName ) ; <nl> } <nl> } <nl> } <nl> <nl> / * * <nl> - * Check for modifiers . <nl> - * @ param ast modifier ast <nl> - * @ return tru in modifier is in checked ones <nl> + * Checks whether a method has a javadoc comment . <nl> + * @ param methodDef method definition token . <nl> + * @ return true if a method has a javadoc comment . <nl> + * / <nl> + private boolean hasJavadocComment ( DetailAST methodDef ) { <nl> + final DetailAST modifiers = methodDef . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> + return modifiers . branchContains ( TokenTypes . BLOCK _ COMMENT _ BEGIN ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether a methods is native . <nl> + * @ param ast method definition token . <nl> + * @ return true if a methods is native . <nl> * / <nl> - private static boolean isPrivateOrFinalOrAbstract ( DetailAST ast ) { <nl> - / / method is ok if it is private or abstract or final <nl> - final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> - return modifiers . branchContains ( TokenTypes . LITERAL _ PRIVATE ) <nl> - | | modifiers . branchContains ( TokenTypes . ABSTRACT ) <nl> - | | modifiers . branchContains ( TokenTypes . FINAL ) <nl> - | | modifiers . branchContains ( TokenTypes . LITERAL _ STATIC ) ; <nl> + private boolean isNativeMethod ( DetailAST ast ) { <nl> + final DetailAST mods = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> + return mods . branchContains ( TokenTypes . LITERAL _ NATIVE ) ; <nl> } <nl> <nl> / * * <nl> - * Has Default Or Explicit Non Private Ctor . <nl> - * @ param classDef class ast <nl> - * @ return true if Check should make a violation <nl> + * Checks whether a method has only comments in the body ( has an empty implementation ) . <nl> + * Method is OK if its implementation is empty . <nl> + * @ param ast method definition token . <nl> + * @ return true if a method has only comments in the body . <nl> + * / <nl> + private static boolean hasEmptyImplementation ( DetailAST ast ) { <nl> + boolean hasEmptyBody = true ; <nl> + final DetailAST methodImplOpenBrace = ast . findFirstToken ( TokenTypes . SLIST ) ; <nl> + if ( methodImplOpenBrace ! = null ) { <nl> + final DetailAST methodImplCloseBrace = methodImplOpenBrace . getLastChild ( ) ; <nl> + final Predicate < DetailAST > predicate = currentNode - > <nl> + currentNode ! = null <nl> + & & currentNode ! = methodImplCloseBrace <nl> + & & currentNode . getLineNo ( ) < = methodImplCloseBrace . getLineNo ( ) <nl> + & & ! TokenUtils . isCommentType ( currentNode . getType ( ) ) ; <nl> + final Optional < DetailAST > methodBody = <nl> + TokenUtils . findFirstTokenByPredicate ( methodImplOpenBrace , predicate ) ; <nl> + if ( methodBody . isPresent ( ) ) { <nl> + hasEmptyBody = false ; <nl> + } <nl> + } <nl> + return hasEmptyBody ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether a method can be overridden . <nl> + * Method can be overridden if it is not private , abstract , final or static . <nl> + * Note that the check has nothing to do for interfaces . <nl> + * @ param methodDef method definition token . <nl> + * @ return true if a method can be overridden in a subclass . <nl> + * / <nl> + private boolean canBeOverridden ( DetailAST methodDef ) { <nl> + final DetailAST modifiers = methodDef . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> + return ScopeUtils . getSurroundingScope ( methodDef ) . isIn ( Scope . PROTECTED ) <nl> + & & ! ScopeUtils . isInInterfaceOrAnnotationBlock ( methodDef ) <nl> + & & ! modifiers . branchContains ( TokenTypes . LITERAL _ PRIVATE ) <nl> + & & ! modifiers . branchContains ( TokenTypes . ABSTRACT ) <nl> + & & ! modifiers . branchContains ( TokenTypes . FINAL ) <nl> + & & ! modifiers . branchContains ( TokenTypes . LITERAL _ STATIC ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether a method has any of ignored annotations . <nl> + * @ param methodDef method definition token . <nl> + * @ param annotations a set of ignored annotations . <nl> + * @ return true if a method has any of ignored annotations . <nl> + * / <nl> + private static boolean hasIgnoredAnnotation ( DetailAST methodDef , Set < String > annotations ) { <nl> + return annotations . stream ( ) . filter ( annotation - > hasAnnotation ( methodDef , annotation ) ) <nl> + . findAny ( ) . isPresent ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Check if a method has specific annotation . <nl> + * @ param methodDef method definition token . <nl> + * @ param annotationName annotation name . <nl> + * @ return true , if a method has a specific annotation . <nl> + * / <nl> + private static boolean hasAnnotation ( DetailAST methodDef , String annotationName ) { <nl> + final DetailAST modifiers = methodDef . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> + boolean containsAnnotation = false ; <nl> + if ( modifiers . branchContains ( TokenTypes . ANNOTATION ) ) { <nl> + final Optional < DetailAST > annotation = TokenUtils . findFirstTokenByPredicate ( modifiers , <nl> + currentToken - > currentToken ! = null <nl> + & & currentToken . getType ( ) = = TokenTypes . ANNOTATION <nl> + & & annotationName . equals ( getAnnotationName ( currentToken ) ) ) ; <nl> + if ( annotation . isPresent ( ) ) { <nl> + containsAnnotation = true ; <nl> + } <nl> + } <nl> + return containsAnnotation ; <nl> + } <nl> + <nl> + / * * <nl> + * Gets the name of the annotation . <nl> + * @ param annotation to get name of . <nl> + * @ return the name of the annotation . <nl> + * / <nl> + private static String getAnnotationName ( DetailAST annotation ) { <nl> + final DetailAST dotAst = annotation . findFirstToken ( TokenTypes . DOT ) ; <nl> + final String name ; <nl> + if ( dotAst = = null ) { <nl> + name = annotation . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; <nl> + } <nl> + else { <nl> + name = dotAst . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; <nl> + } <nl> + return name ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns CLASS _ DEF or ENUM _ DEF token which is the nearest to the given ast node . <nl> + * Searches the tree towards the root until it finds a CLASS _ DEF or ENUM _ DEF node . <nl> + * @ param ast the start node for searching . <nl> + * @ return the CLASS _ DEF or ENUM _ DEF token . <nl> + * / <nl> + private static DetailAST getNearestClassOrEnumDefinition ( DetailAST ast ) { <nl> + DetailAST searchAST = ast ; <nl> + while ( searchAST . getType ( ) ! = TokenTypes . CLASS _ DEF <nl> + & & searchAST . getType ( ) ! = TokenTypes . ENUM _ DEF ) { <nl> + searchAST = searchAST . getParent ( ) ; <nl> + } <nl> + return searchAST ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks if the given class ( given CLASS _ DEF node ) can be subclassed . <nl> + * @ param classDef class definition token . <nl> + * @ return true if the containing class can be subclassed . <nl> + * / <nl> + private static boolean canBeSubclassed ( DetailAST classDef ) { <nl> + final DetailAST modifiers = classDef . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> + return classDef . getType ( ) ! = TokenTypes . ENUM _ DEF <nl> + & & ! modifiers . branchContains ( TokenTypes . FINAL ) <nl> + & & hasDefaultOrExplicitNonPrivateCtor ( classDef ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether a class has default or explicit non - private constructor . <nl> + * @ param classDef class ast token . <nl> + * @ return true if a class has default or explicit non - private constructor . <nl> * / <nl> private static boolean hasDefaultOrExplicitNonPrivateCtor ( DetailAST classDef ) { <nl> / / check if subclassing is prevented by having only private ctors <nl> @ @ - 165 , 18 + 321 , 4 @ @ public class DesignForExtensionCheck extends AbstractCheck { <nl> <nl> return hasDefaultConstructor | | hasExplicitNonPrivateCtor ; <nl> } <nl> - <nl> - / * * <nl> - * Searches the tree towards the root until it finds a CLASS _ DEF node . <nl> - * @ param ast the start node for searching <nl> - * @ return the CLASS _ DEF node . <nl> - * / <nl> - private static DetailAST findContainingClass ( DetailAST ast ) { <nl> - DetailAST searchAST = ast ; <nl> - while ( searchAST . getType ( ) ! = TokenTypes . CLASS _ DEF <nl> - & & searchAST . getType ( ) ! = TokenTypes . ENUM _ DEF ) { <nl> - searchAST = searchAST . getParent ( ) ; <nl> - } <nl> - return searchAST ; <nl> - } <nl> } <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java <nl> index 6849b57 . . e49a312 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java <nl> @ @ - 21 , 9 + 21 , 12 @ @ package com . puppycrawl . tools . checkstyle . utils ; <nl> <nl> import java . lang . reflect . Field ; <nl> import java . util . Locale ; <nl> + import java . util . Optional ; <nl> import java . util . ResourceBundle ; <nl> + import java . util . function . Predicate ; <nl> <nl> import com . google . common . collect . ImmutableMap ; <nl> + import com . puppycrawl . tools . checkstyle . api . DetailAST ; <nl> import com . puppycrawl . tools . checkstyle . api . TokenTypes ; <nl> <nl> / * * <nl> @ @ - 179 , 4 + 182 , 30 @ @ public final class TokenUtils { <nl> return isCommentType ( getTokenId ( type ) ) ; <nl> } <nl> <nl> + / * * <nl> + * Finds the first node { @ link Optional } of { @ link DetailAST } which matches the predicate . <nl> + * @ param root root node . <nl> + * @ param predicate predicate . <nl> + * @ return { @ link Optional } of { @ link DetailAST } node which matches the predicate . <nl> + * / <nl> + public static Optional < DetailAST > findFirstTokenByPredicate ( DetailAST root , <nl> + Predicate < DetailAST > predicate ) { <nl> + Optional < DetailAST > result = Optional . empty ( ) ; <nl> + DetailAST rootNode = root ; <nl> + while ( rootNode ! = null ) { <nl> + DetailAST toVisit = rootNode . getFirstChild ( ) ; <nl> + if ( predicate . test ( toVisit ) ) { <nl> + result = Optional . of ( toVisit ) ; <nl> + break ; <nl> + } <nl> + while ( rootNode ! = null & & toVisit = = null ) { <nl> + toVisit = rootNode . getNextSibling ( ) ; <nl> + if ( toVisit = = null ) { <nl> + rootNode = rootNode . getParent ( ) ; <nl> + } <nl> + } <nl> + rootNode = toVisit ; <nl> + } <nl> + return result ; <nl> + } <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheckTest . java <nl> index 388b82e . . 79d4a80 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheckTest . java <nl> @ @ - 51 , 9 + 51 , 8 @ @ public class DesignForExtensionCheckTest <nl> final DefaultConfiguration checkConfig = <nl> createCheckConfig ( DesignForExtensionCheck . class ) ; <nl> final String [ ] expected = { <nl> - " 46 : 5 : " + getCheckMessage ( MSG _ KEY , " doh " ) , <nl> - " 54 : 5 : " + getCheckMessage ( MSG _ KEY , " aNativeMethod " ) , <nl> - " 105 : 9 : " + getCheckMessage ( MSG _ KEY , " someMethod " ) , <nl> + " 46 : 5 : " + getCheckMessage ( MSG _ KEY , " InputDesignForExtension " , " doh " ) , <nl> + " 100 : 9 : " + getCheckMessage ( MSG _ KEY , " anotherNonFinalClass " , " someMethod " ) , <nl> } ; <nl> verify ( checkConfig , getPath ( " InputDesignForExtension . java " ) , expected ) ; <nl> <nl> @ @ - 65 , 4 + 64 , 47 @ @ public class DesignForExtensionCheckTest <nl> final int [ ] expected = { TokenTypes . METHOD _ DEF } ; <nl> assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testOverridableMethods ( ) throws Exception { <nl> + final DefaultConfiguration checkConfig = createCheckConfig ( DesignForExtensionCheck . class ) ; <nl> + final String [ ] expected = { <nl> + " 6 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo1 " ) , <nl> + " 30 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo8 " ) , <nl> + " 35 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo9 " ) , <nl> + " 42 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo10 " ) , <nl> + " 49 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo11 " ) , <nl> + " 54 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo12 " ) , <nl> + " 61 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo13 " ) , <nl> + " 68 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo14 " ) , <nl> + " 90 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo22 " ) , <nl> + " 96 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo23 " ) , <nl> + " 110 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo26 " ) , <nl> + " 117 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo27 " ) , <nl> + } ; <nl> + verify ( checkConfig , getPath ( " InputDesignForExtensionOverridableMethods . java " ) , expected ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testIgnoredAnnotationsOption ( ) throws Exception { <nl> + final DefaultConfiguration checkConfig = createCheckConfig ( DesignForExtensionCheck . class ) ; <nl> + checkConfig . addAttribute ( " ignoredAnnotations " , " Override , Deprecated " ) ; <nl> + final String [ ] expected = { <nl> + " 31 : 5 : " <nl> + + getCheckMessage ( MSG _ KEY , " InputDesignForExtensionIgnoredAnnotations " , " foo1 " ) , <nl> + " 141 : 5 : " <nl> + + getCheckMessage ( MSG _ KEY , " InputDesignForExtensionIgnoredAnnotations " , " foo21 " ) , <nl> + } ; <nl> + verify ( checkConfig , getPath ( " InputDesignForExtensionIgnoredAnnotations . java " ) , expected ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNativeMethods ( ) throws Exception { <nl> + final DefaultConfiguration checkConfig = createCheckConfig ( DesignForExtensionCheck . class ) ; <nl> + checkConfig . addAttribute ( " ignoredAnnotations " , " Deprecated " ) ; <nl> + final String [ ] expected = { <nl> + " 8 : 5 : " + getCheckMessage ( MSG _ KEY , " InputDesignForExtensionNativeMethods " , " foo1 " ) , <nl> + } ; <nl> + verify ( checkConfig , getPath ( " InputDesignForExtensionNativeMethods . java " ) , expected ) ; <nl> + } <nl> } <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtension . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtension . java <nl> index 0b3914d . . b32c5e2 100644 <nl> - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtension . java <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtension . java <nl> @ @ - 47 , 11 + 47 , 6 @ @ public abstract class InputDesignForExtension <nl> { <nl> System . identityHashCode ( " nonempty and overriding possible " ) ; <nl> } <nl> - <nl> - / / has a potentially complex implementation in native code . <nl> - / / We can ' t check that , so to be safe DesignForExtension requires <nl> - / / native methods to also be final <nl> - public native void aNativeMethod ( ) ; <nl> <nl> public final void aFinalMethod ( ) <nl> { <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionIgnoredAnnotations . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionIgnoredAnnotations . java <nl> new file mode 100644 <nl> index 0000000 . . c8a2e36 <nl> - - - / dev / null <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionIgnoredAnnotations . java <nl> @ @ - 0 , 0 + 1 , 143 @ @ <nl> + package com . puppycrawl . tools . checkstyle . checks . design ; <nl> + <nl> + public class InputDesignForExtensionIgnoredAnnotations { <nl> + <nl> + @ Override <nl> + public int hashCode ( ) { <nl> + return super . hashCode ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Javadoc . <nl> + * @ param obj object . <nl> + * @ return boolean . <nl> + * / <nl> + @ Override <nl> + public boolean equals ( Object obj ) { <nl> + return super . equals ( obj ) ; <nl> + } <nl> + <nl> + @ Deprecated <nl> + public void testFoo ( ) throws Exception { <nl> + final int a = 5 ; <nl> + final int b = 6 ; <nl> + } <nl> + <nl> + @ Deprecated <nl> + public String toString ( ) { <nl> + return super . toString ( ) ; <nl> + } <nl> + <nl> + public int foo1 ( ) { return 1 ; } / / violation <nl> + <nl> + / * * <nl> + * <nl> + * @ return <nl> + * / <nl> + public int foo2 ( ) { return 2 ; } <nl> + <nl> + public void foo3 ( ) { } <nl> + <nl> + public class C extends B { <nl> + @ Deprecated <nl> + @ Override <nl> + public void testFoo ( ) { <nl> + super . testFoo ( ) ; <nl> + } <nl> + } <nl> + <nl> + public class B { <nl> + / * * Test foo * / <nl> + public void testFoo ( ) { <nl> + final int a = 6 ; <nl> + } <nl> + } <nl> + <nl> + / / Deprecated <nl> + @ Deprecated <nl> + public void foo4 ( ) { return ; } <nl> + <nl> + / * <nl> + * Deprecated <nl> + * / <nl> + @ Deprecated <nl> + public void foo5 ( ) { return ; } <nl> + <nl> + @ java . lang . Deprecated <nl> + public void foo6 ( ) { return ; } <nl> + <nl> + / / Single line comment <nl> + @ Deprecated <nl> + public void foo7 ( ) { <nl> + return ; <nl> + } <nl> + <nl> + / / Single line comments <nl> + / / organized in a block <nl> + @ Deprecated <nl> + public void foo8 ( ) { <nl> + return ; <nl> + } <nl> + <nl> + / * * Javadoc comment * / <nl> + @ Deprecated <nl> + public void foo9 ( ) { <nl> + return ; <nl> + } <nl> + <nl> + / * Block comment * / <nl> + @ Deprecated <nl> + public void foo10 ( ) { <nl> + return ; <nl> + } <nl> + <nl> + @ Deprecated <nl> + / * * * / <nl> + public int foo11 ( ) { <nl> + return 1 ; <nl> + } <nl> + <nl> + @ Deprecated <nl> + / * * / <nl> + public int foo12 ( ) { <nl> + return 1 ; <nl> + } <nl> + <nl> + @ Deprecated <nl> + / * * / <nl> + public void foo13 ( ) { } <nl> + <nl> + @ Deprecated <nl> + / * * * / <nl> + public void foo14 ( ) { } <nl> + <nl> + @ Deprecated <nl> + / * * * / <nl> + public void foo15 ( ) { / * * * / } <nl> + <nl> + @ Deprecated <nl> + / / comment <nl> + public void foo16 ( ) { } <nl> + <nl> + @ Deprecated <nl> + @ InputLocalAnnotations . ClassRule <nl> + public void foo17 ( ) { return ; } <nl> + <nl> + @ Deprecated <nl> + @ InputLocalAnnotations . ClassRule <nl> + / * * * / <nl> + public void foo18 ( ) { return ; } <nl> + <nl> + @ Deprecated <nl> + / * * * / <nl> + @ InputLocalAnnotations . ClassRule <nl> + public void foo19 ( ) { return ; } <nl> + <nl> + / * * * / <nl> + @ Deprecated <nl> + @ InputLocalAnnotations . ClassRule <nl> + public void foo20 ( ) { return ; } <nl> + <nl> + @ InputLocalAnnotations . ClassRule <nl> + public void foo21 ( ) { return ; } / / violation <nl> + } <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionNativeMethods . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionNativeMethods . java <nl> new file mode 100644 <nl> index 0000000 . . e908730 <nl> - - - / dev / null <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionNativeMethods . java <nl> @ @ - 0 , 0 + 1 , 28 @ @ <nl> + package com . puppycrawl . tools . checkstyle . checks . design ; <nl> + <nl> + public class InputDesignForExtensionNativeMethods { <nl> + <nl> + / / has a potentially complex implementation in native code . <nl> + / / We can ' t check that , so to be safe DesignForExtension requires <nl> + / / native methods to also be final <nl> + public native void foo1 ( ) ; / / violation <nl> + <nl> + public static native void foo2 ( ) ; <nl> + <nl> + protected static native void foo3 ( ) ; <nl> + <nl> + protected static final native void foo4 ( ) ; <nl> + <nl> + / * * <nl> + * Javadoc for native method . <nl> + * / <nl> + public native void foo5 ( ) ; <nl> + <nl> + / * <nl> + * Block - commend doc for native method . <nl> + * / <nl> + public native void foo6 ( ) ; <nl> + <nl> + @ Deprecated <nl> + public native void foo7 ( ) ; <nl> + } <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionOverridableMethods . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionOverridableMethods . java <nl> new file mode 100644 <nl> index 0000000 . . afa1512 <nl> - - - / dev / null <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionOverridableMethods . java <nl> @ @ - 0 , 0 + 1 , 221 @ @ <nl> + package com . puppycrawl . tools . checkstyle . checks . design ; <nl> + <nl> + public class InputDesignForExtensionOverridableMethods { <nl> + <nl> + public class A { <nl> + public int foo1 ( int a , int b ) { return a + b ; } / / violation <nl> + <nl> + public void foo2 ( ) { } <nl> + <nl> + public void foo3 ( int a , int b ) { } <nl> + <nl> + private int foo4 ( int a , int b ) { return a + b ; } <nl> + <nl> + public void foo5 ( ) { <nl> + / / single line comment is not counted as a content <nl> + } <nl> + <nl> + public void foo6 ( ) { <nl> + / * * <nl> + * javadoc block comment is not counted as a content <nl> + * / <nl> + } <nl> + <nl> + public void foo7 ( ) { <nl> + / * <nl> + * block comment is not counted as a content <nl> + * / <nl> + } <nl> + <nl> + public int foo8 ( int a , int b ) { / / violation <nl> + / / single line comment before content <nl> + return a + b ; <nl> + } <nl> + <nl> + public int foo9 ( int a , int b ) { / / violation <nl> + / * <nl> + * block comment before content <nl> + * / <nl> + return a + b ; <nl> + } <nl> + <nl> + public int foo10 ( int a , int b ) { / / violation <nl> + / * * <nl> + * javadoc block comment before content <nl> + * / <nl> + return a + b ; <nl> + } <nl> + <nl> + public int foo11 ( int a , int b ) { / / violation <nl> + return a + b ; <nl> + / / single line comment after content <nl> + } <nl> + <nl> + public int foo12 ( int a , int b ) { / / violation <nl> + return a + b ; <nl> + / * <nl> + * block comment after content <nl> + * / <nl> + } <nl> + <nl> + public int foo13 ( int a , int b ) { / / violation <nl> + return a + b ; <nl> + / * * <nl> + * javadoc block comment after content <nl> + * / <nl> + } <nl> + <nl> + protected int foo14 ( int a ) { return a - 1 ; } / / violation <nl> + <nl> + public final int foo15 ( int a ) { return a - 2 ; } <nl> + <nl> + protected final int foo16 ( int a ) { return a - 2 ; } <nl> + <nl> + / * * Javadoc comment * / <nl> + protected int foo17 ( int a ) { return a - 1 ; } <nl> + <nl> + / * * Method javadoc * / <nl> + public void foo18 ( ) { } <nl> + <nl> + / * * Method javadoc * / <nl> + public int foo19 ( ) { return 1 ; } <nl> + <nl> + / * * * / <nl> + public final int foo20 ( int a ) { return a - 2 ; } <nl> + <nl> + / * * * / <nl> + protected final int foo21 ( int a ) { return a - 2 ; } <nl> + <nl> + / / Single line comment <nl> + public void foo22 ( ) { / / violation <nl> + return ; <nl> + } <nl> + <nl> + / / Single line comments <nl> + / / organized in a block <nl> + public void foo23 ( ) { / / violation <nl> + return ; <nl> + } <nl> + <nl> + / / Single line comments <nl> + / / organized in a block <nl> + public void foo24 ( ) { } <nl> + <nl> + / * Block comment * / <nl> + public void foo25 ( ) { <nl> + return ; <nl> + } <nl> + <nl> + / / Single line comment <nl> + @ Deprecated / / violation <nl> + public void foo26 ( ) { <nl> + return ; <nl> + } <nl> + <nl> + / / Single line comments <nl> + / / organized in a block <nl> + @ Deprecated / / violation <nl> + public void foo27 ( ) { <nl> + return ; <nl> + } <nl> + <nl> + / * * Javadoc comment * / <nl> + @ Deprecated <nl> + public void foo28 ( ) { <nl> + return ; <nl> + } <nl> + <nl> + / * Block comment * / <nl> + @ Deprecated <nl> + public void foo29 ( ) { <nl> + return ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns maximum of a and b . <nl> + * @ param a a . <nl> + * @ param b b . <nl> + * @ return maximum of a and b . <nl> + * / <nl> + public int max ( int a , int b ) { <nl> + return Math . max ( a , b ) ; <nl> + } <nl> + <nl> + / * * * / <nl> + public int foo30 ( ) { <nl> + / * * * / <nl> + return 1 ; <nl> + } <nl> + <nl> + / * * / <nl> + public int foo31 ( ) { <nl> + / * * * / <nl> + return 1 ; <nl> + } <nl> + <nl> + / * * * / <nl> + public int foo32 ( ) { <nl> + / * * / <nl> + return 1 ; <nl> + } <nl> + <nl> + @ Deprecated <nl> + / * * * / <nl> + public int foo33 ( ) { <nl> + return 1 ; <nl> + } <nl> + <nl> + @ Deprecated <nl> + / * * / <nl> + public int foo34 ( ) { <nl> + return 1 ; <nl> + } <nl> + <nl> + @ Deprecated <nl> + / * * / <nl> + public void foo35 ( ) { } <nl> + <nl> + @ Deprecated <nl> + / * * * / <nl> + public void foo36 ( ) { } <nl> + <nl> + @ Deprecated <nl> + / * * * / <nl> + public void foo37 ( ) { / * * * / } <nl> + <nl> + @ Deprecated <nl> + / / comment <nl> + public void foo38 ( ) { } <nl> + <nl> + @ Deprecated / * * * / <nl> + public void foo39 ( ) { return ; } <nl> + <nl> + / * * <nl> + * @ param indent indentation to check . <nl> + * @ return true if { @ code indent } less then minimal of <nl> + * acceptable indentation levels , false otherwise . <nl> + * / <nl> + public boolean isGreaterThan ( int indent ) { <nl> + return indent = = 2 ; <nl> + } <nl> + <nl> + / * * <nl> + * Sets whether to process JavaDoc or not . <nl> + * <nl> + * @ param value Flag for processing JavaDoc . <nl> + * / <nl> + public void setProcessJavadoc ( boolean value ) { <nl> + value = true ; <nl> + } <nl> + } <nl> + <nl> + public final class B { <nl> + public int foo1 ( int a , int b ) { return a + b ; } <nl> + <nl> + protected int foo2 ( int a , int b ) { return a + b ; } <nl> + <nl> + public final int foo3 ( int a , int b ) { return a + b ; } <nl> + <nl> + protected final int foo4 ( int a , int b ) { return a + b ; } <nl> + } <nl> + } <nl> diff - - git a / src / xdocs / config _ design . xml b / src / xdocs / config _ design . xml <nl> index f28d6c3 . . 206dda9 100644 <nl> - - - a / src / xdocs / config _ design . xml <nl> + + + b / src / xdocs / config _ design . xml <nl> @ @ - 24 , 19 + 24 , 31 @ @ <nl> < section name = " DesignForExtension " > <nl> < subsection name = " Description " > <nl> < p > <nl> - The Check finds classes that are designed for extension ( subclass creation ) . <nl> + The check finds classes that are designed for extension ( subclass creation ) . <nl> < / p > <nl> < p > <nl> - Nothing wrong could be with founded classes <nl> - this Check make sence only for library project ( not a application projects ) <nl> - who care about ideal OOP design to make sure class work in all cases even misusage . <nl> - Even in library projects this Check most likely finds classes that are not required to check . <nl> - User need to use suppressions extensively to got a benefit from this Check and avoid <nl> - false positives . <nl> + Nothing wrong could be with founded classes . <nl> + This check makes sense only for library project ( not an application projects ) <nl> + which care of ideal OOP - design to make sure that class works in all cases even misusage . <nl> + Even in library projects this check most likely will find classes that are designed <nl> + for extension by somebody . User needs to use suppressions extensively to got a benefit from <nl> + this check , and keep in suppressions all confirmed / known classes that are deigned for <nl> + inheritance intentionally to let the check catch only new classes , and bring this to <nl> + team / user attention . <nl> < / p > <nl> < p > <nl> - ATTENTION : Only user can deside whether class is designed for extension or not . <nl> - Check just show all possible . If smth inappropriate is found please use supporession . <nl> + ATTENTION : Only user can decide whether a class is designed for extension or not . <nl> + The check just shows all classes which are possibly designed for extension . <nl> + If smth inappropriate is found please use suppression . <nl> + < / p > <nl> + < p > <nl> + ATTENTION : If the method which can be overridden in a subclass has a javadoc comment <nl> + ( a good practise is to explain its self - use of overridable methods ) the check will not <nl> + rise a violation . The violation can also be skipped if the method which can be overridden <nl> + in a subclass has one or more annotations that are specified in ignoredAnnotations <nl> + option . Note , that by default @ Override annotation is not included in the <nl> + ignoredAnnotations set as in a subclass the method which has the annotation can also be <nl> + overridden in its subclass . <nl> < / p > <nl> < p > <nl> Problem is described at " Effective Java , 2nd Edition by Josh Bloch " book , chapter " Item 17 : Design and document for inheritance or else prohibit it " . <nl> @ @ - 61 , 16 + 73 , 10 @ @ In doing so , you â€™ ll create a class that is reasonably safe to subclass . Overri <nl> method will never affect the behavior of any other method . <nl> < / blockquote > <nl> < p > <nl> - The exact rule is that non - private , non - static methods of classes that <nl> - can be subclassed must <nl> + The check finds classes that have overridable methods ( public or protected methods <nl> + that are non - static , not - final , non - abstract ) and have non - empty implementation . <nl> < / p > <nl> <nl> - < ul > <nl> - < li > be abstract or < / li > <nl> - < li > be final or < / li > <nl> - < li > have an empty implementation . < / li > <nl> - < / ul > <nl> - <nl> < p > <nl> Rationale : This library design style protects superclasses against <nl> being broken by subclasses . The downside is that subclasses are <nl> @ @ - 135 , 6 + 141 , 25 @ @ public abstract class Plant { <nl> < / source > <nl> < / subsection > <nl> <nl> + < subsection name = " Properties " > <nl> + < table > <nl> + < tr > <nl> + < th > name < / th > <nl> + < th > description < / th > <nl> + < th > type < / th > <nl> + < th > default value < / th > <nl> + < / tr > <nl> + < tr > <nl> + < td > ignoredAnnotations < / td > <nl> + < td > <nl> + Annotations which allow the check to skip the method from validation . <nl> + < / td > <nl> + < td > < a href = " property _ types . html # stringSet " > String Set < / a > < / td > <nl> + < td > < code > Test , Before , After , BeforeClass , AfterClass < / code > < / td > <nl> + < / tr > <nl> + < / table > <nl> + < / subsection > <nl> + <nl> < subsection name = " Examples " > <nl> < p > <nl> To configure the check : <nl> @ @ - 143 , 6 + 168 , 50 @ @ public abstract class Plant { <nl> < source > <nl> & lt ; module name = & quot ; DesignForExtension & quot ; / & gt ; <nl> < / source > <nl> + <nl> + < p > <nl> + To configure the check to allow methods which have @ Override and @ Test annotations to be <nl> + designed for extension . <nl> + < / p > <nl> + <nl> + < source > <nl> + & lt ; module name = & quot ; DesignForExtension & quot ; & gt ; <nl> + & lt ; property name = & quot ; ignoredAnnotations & quot ; value = & quot ; Override , Test & quot ; / & gt ; <nl> + & lt ; / module & gt ; <nl> + < / source > <nl> + <nl> + < source > <nl> + public class A extends B { <nl> + @ Override <nl> + public int foo ( ) { <nl> + return 2 ; <nl> + } <nl> + <nl> + public int foo2 ( ) { return 8 ; } / / violation <nl> + } <nl> + <nl> + public class B { <nl> + / * * <nl> + * This implementation . . . <nl> + @ return some int value . <nl> + * / <nl> + public int foo ( ) { <nl> + return 1 ; <nl> + } <nl> + <nl> + public int foo3 ( ) { return 3 ; } / / violation <nl> + } <nl> + <nl> + public class FooTest { <nl> + @ Test <nl> + public void testFoo ( ) { <nl> + final B b = new A ( ) ; <nl> + assertEquals ( 2 , b . foo ( ) ) ; <nl> + } <nl> + <nl> + public int foo4 ( ) { return 4 ; } / / violation <nl> + } <nl> + < / source > <nl> < / subsection > <nl> <nl> < subsection name = " Example of Usage " >
NEAREST DIFF (one line): diff - - git a / src / xdocs / config _ modifier . xml b / src / xdocs / config _ modifier . xml <nl> index 0e250b3 . . 3b60f68 100644 <nl> - - - a / src / xdocs / config _ modifier . xml <nl> + + + b / src / xdocs / config _ modifier . xml <nl> @ @ - 96 , 6 + 96 , 11 @ @ <nl> < / p > <nl> <nl> < p > <nl> + Interfaces by definition are abstract so the < code > abstract < / code > <nl> + modifier on the interface is redundant . <nl> + < / p > <nl> + <nl> + < p > <nl> Variables in interfaces and annotations are automatically <nl> public , static and final , so these modifiers are redundant as <nl> well .

TEST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheck . java 
 index 5ad6f33 . . 12c52bc 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheck . java 
 @ @ - 19 , 55 + 19 , 77 @ @ 
 
 package com . puppycrawl . tools . checkstyle . checks . design ; 
 
 + import java . util . Arrays ; 
 + import java . util . Optional ; 
 + import java . util . Set ; 
 + import java . util . function . Predicate ; 
 + import java . util . stream . Collectors ; 
 + import java . util . stream . Stream ; 
 + 
 import com . puppycrawl . tools . checkstyle . api . AbstractCheck ; 
 import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . Scope ; 
 import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 import com . puppycrawl . tools . checkstyle . utils . ScopeUtils ; 
 + import com . puppycrawl . tools . checkstyle . utils . TokenUtils ; 
 
 / * * 
 - * Checks find classes that are designed for inheritance . 
 + * The check finds classes that are designed for extension ( subclass creation ) . 
 * 
 * < p > 
 - * Nothing wrong could be with founded classes 
 - * this Check make sence only for library project ( not a application projects ) 
 - * who care about ideal OOP design to make sure clas work in all cases even misusage . 
 - * Even in library projects this Check most likely find classes that are not required to check . 
 - * User need to use suppressions extensively to got a benefit from this Check and avoid 
 - * false positives . 
 + * Nothing wrong could be with founded classes . 
 + * This check makes sense only for library projects ( not an application projects ) 
 + * which care of ideal OOP - design to make sure that class works in all cases even misusage . 
 + * Even in library projects this check most likely will find classes that are designed for extension 
 + * by somebody . User needs to use suppressions extensively to got a benefit from this check , 
 + * and keep in suppressions all confirmed / known classes that are deigned for inheritance 
 + * intentionally to let the check catch only new classes , and bring this to team / user attention . 
 * < / p > 
 * 
 * < p > 
 - * ATTENTION : Only user can deside whether class is designed for extension or not . 
 - * Check just show all possible . If smth inappropriate is found please use supporession . 
 + * ATTENTION : Only user can decide whether a class is designed for extension or not . 
 + * The check just shows all classes which are possibly designed for extension . 
 + * If smth inappropriate is found please use suppression . 
 * < / p > 
 * 
 * < p > 
 - * More specifically , it enforces a programming style 
 - * where superclasses provide empty " hooks " that can be 
 - * implemented by subclasses . 
 + * ATTENTION : If the method which can be overridden in a subclass has a javadoc comment 
 + * ( a good practise is to explain its self - use of overridable methods ) the check will not 
 + * rise a violation . The violation can also be skipped if the method which can be overridden 
 + * in a subclass has one or more annotations that are specified in ignoredAnnotations 
 + * option . Note , that by default @ Override annotation is not included in the 
 + * ignoredAnnotations set as in a subclass the method which has the annotation can also be 
 + * overridden in its subclass . 
 * < / p > 
 * 
 - * < p > The exact rule is that non - private , non - static methods in 
 - * non - final classes ( or classes that do not 
 - * only have private constructors ) must either be 
 - * < ul > 
 - * < li > abstract or < / li > 
 - * < li > final or < / li > 
 - * < li > have an empty implementation < / li > 
 - * < / ul > 
 + * < p > 
 + * More specifically , the check enforces a programming style where superclasses provide empty 
 + * " hooks " that can be implemented by subclasses . 
 + * < / p > 
 * 
 + * < p > 
 + * The check finds classes that have overridable methods ( public or protected methods 
 + * that are non - static , not - final , non - abstract ) and have non - empty implementation . 
 + * < / p > 
 + * 
 + * < p > 
 + * This protects superclasses against being broken by subclasses . The downside is that subclasses 
 + * are limited in their flexibility , in particular , they cannot prevent execution of code in the 
 + * superclass , but that also means that subclasses cannot forget to call their super method . 
 + * < / p > 
 * 
 * < p > 
 - * This protects superclasses against being broken by 
 - * subclasses . The downside is that subclasses are limited 
 - * in their flexibility , in particular they cannot prevent 
 - * execution of code in the superclass , but that also 
 - * means that subclasses can ' t forget to call their super 
 - * method . 
 + * The check has the following options : 
 * < / p > 
 + * < ul > 
 + * < li > 
 + * ignoredAnnotations - annotations which allow the check to skip the method from validation . 
 + * Default value is < b > Test , Before , After , BeforeClass , AfterClass < / b > . 
 + * < / li > 
 + * < / ul > 
 * 
 * @ author lkuehne 
 + * @ author Andrei Selkin 
 * / 
 public class DesignForExtensionCheck extends AbstractCheck { 
 
 @ @ - 77 , 6 + 99 , 20 @ @ public class DesignForExtensionCheck extends AbstractCheck { 
 * / 
 public static final String MSG _ KEY = " design . forExtension " ; 
 
 + / * * 
 + * A set of annotations which allow the check to skip the method from validation . 
 + * / 
 + private Set < String > ignoredAnnotations = Stream . of ( " Test " , " Before " , " After " , " BeforeClass " , 
 + " AfterClass " ) . collect ( Collectors . toSet ( ) ) ; 
 + 
 + / * * 
 + * Sets annotations which allow the check to skip the method from validation . 
 + * @ param ignoredAnnotations method annotations . 
 + * / 
 + public void setIgnoredAnnotations ( String . . . ignoredAnnotations ) { 
 + this . ignoredAnnotations = Arrays . stream ( ignoredAnnotations ) . collect ( Collectors . toSet ( ) ) ; 
 + } 
 + 
 @ Override 
 public int [ ] getDefaultTokens ( ) { 
 return getAcceptableTokens ( ) ; 
 @ @ - 84 , 6 + 120 , 9 @ @ public class DesignForExtensionCheck extends AbstractCheck { 
 
 @ Override 
 public int [ ] getAcceptableTokens ( ) { 
 + / / The check does not subscribe to CLASS _ DEF token as now it is stateless . If the check 
 + / / subscribes to CLASS _ DEF token it will become stateful , since we need to have additional 
 + / / stack to hold CLASS _ DEF tokens . 
 return new int [ ] { TokenTypes . METHOD _ DEF } ; 
 } 
 
 @ @ - 93 , 52 + 132 , 169 @ @ public class DesignForExtensionCheck extends AbstractCheck { 
 } 
 
 @ Override 
 + public boolean isCommentNodesRequired ( ) { 
 + return true ; 
 + } 
 + 
 + @ Override 
 public void visitToken ( DetailAST ast ) { 
 - / / nothing to do for Interfaces 
 - if ( ! ScopeUtils . isInInterfaceOrAnnotationBlock ( ast ) 
 - & & ! isPrivateOrFinalOrAbstract ( ast ) 
 - & & ScopeUtils . getSurroundingScope ( ast ) . isIn ( Scope . PROTECTED ) ) { 
 - 
 - / / method is ok if it is implementation can verified to be empty 
 - / / Note : native methods don ' t have impl in java code , so 
 - / / implementation can be null even if method not abstract 
 - final DetailAST implementation = ast . findFirstToken ( TokenTypes . SLIST ) ; 
 - final boolean nonEmptyImplementation = implementation = = null 
 - | | implementation . getFirstChild ( ) . getType ( ) ! = TokenTypes . RCURLY ; 
 - 
 - final DetailAST classDef = findContainingClass ( ast ) ; 
 - final DetailAST classMods = classDef . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 - / / check if the containing class can be subclassed 
 - final boolean classCanBeSubclassed = classDef . getType ( ) ! = TokenTypes . ENUM _ DEF 
 - & & ! classMods . branchContains ( TokenTypes . FINAL ) ; 
 - 
 - if ( nonEmptyImplementation & & classCanBeSubclassed 
 - & & hasDefaultOrExplicitNonPrivateCtor ( classDef ) ) { 
 - 
 - final String name = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; 
 - log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG _ KEY , name ) ; 
 + if ( ! hasJavadocComment ( ast ) 
 + & & ( isNativeMethod ( ast ) 
 + | | ! hasEmptyImplementation ( ast ) ) 
 + & & canBeOverridden ( ast ) 
 + & & ! hasIgnoredAnnotation ( ast , ignoredAnnotations ) ) { 
 + 
 + final DetailAST classDef = getNearestClassOrEnumDefinition ( ast ) ; 
 + if ( canBeSubclassed ( classDef ) ) { 
 + final String className = classDef . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; 
 + final String methodName = ast . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; 
 + log ( ast . getLineNo ( ) , ast . getColumnNo ( ) , MSG _ KEY , className , methodName ) ; 
 } 
 } 
 } 
 
 / * * 
 - * Check for modifiers . 
 - * @ param ast modifier ast 
 - * @ return tru in modifier is in checked ones 
 + * Checks whether a method has a javadoc comment . 
 + * @ param methodDef method definition token . 
 + * @ return true if a method has a javadoc comment . 
 + * / 
 + private boolean hasJavadocComment ( DetailAST methodDef ) { 
 + final DetailAST modifiers = methodDef . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 + return modifiers . branchContains ( TokenTypes . BLOCK _ COMMENT _ BEGIN ) ; 
 + } 
 + 
 + / * * 
 + * Checks whether a methods is native . 
 + * @ param ast method definition token . 
 + * @ return true if a methods is native . 
 * / 
 - private static boolean isPrivateOrFinalOrAbstract ( DetailAST ast ) { 
 - / / method is ok if it is private or abstract or final 
 - final DetailAST modifiers = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 - return modifiers . branchContains ( TokenTypes . LITERAL _ PRIVATE ) 
 - | | modifiers . branchContains ( TokenTypes . ABSTRACT ) 
 - | | modifiers . branchContains ( TokenTypes . FINAL ) 
 - | | modifiers . branchContains ( TokenTypes . LITERAL _ STATIC ) ; 
 + private boolean isNativeMethod ( DetailAST ast ) { 
 + final DetailAST mods = ast . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 + return mods . branchContains ( TokenTypes . LITERAL _ NATIVE ) ; 
 } 
 
 / * * 
 - * Has Default Or Explicit Non Private Ctor . 
 - * @ param classDef class ast 
 - * @ return true if Check should make a violation 
 + * Checks whether a method has only comments in the body ( has an empty implementation ) . 
 + * Method is OK if its implementation is empty . 
 + * @ param ast method definition token . 
 + * @ return true if a method has only comments in the body . 
 + * / 
 + private static boolean hasEmptyImplementation ( DetailAST ast ) { 
 + boolean hasEmptyBody = true ; 
 + final DetailAST methodImplOpenBrace = ast . findFirstToken ( TokenTypes . SLIST ) ; 
 + if ( methodImplOpenBrace ! = null ) { 
 + final DetailAST methodImplCloseBrace = methodImplOpenBrace . getLastChild ( ) ; 
 + final Predicate < DetailAST > predicate = currentNode - > 
 + currentNode ! = null 
 + & & currentNode ! = methodImplCloseBrace 
 + & & currentNode . getLineNo ( ) < = methodImplCloseBrace . getLineNo ( ) 
 + & & ! TokenUtils . isCommentType ( currentNode . getType ( ) ) ; 
 + final Optional < DetailAST > methodBody = 
 + TokenUtils . findFirstTokenByPredicate ( methodImplOpenBrace , predicate ) ; 
 + if ( methodBody . isPresent ( ) ) { 
 + hasEmptyBody = false ; 
 + } 
 + } 
 + return hasEmptyBody ; 
 + } 
 + 
 + / * * 
 + * Checks whether a method can be overridden . 
 + * Method can be overridden if it is not private , abstract , final or static . 
 + * Note that the check has nothing to do for interfaces . 
 + * @ param methodDef method definition token . 
 + * @ return true if a method can be overridden in a subclass . 
 + * / 
 + private boolean canBeOverridden ( DetailAST methodDef ) { 
 + final DetailAST modifiers = methodDef . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 + return ScopeUtils . getSurroundingScope ( methodDef ) . isIn ( Scope . PROTECTED ) 
 + & & ! ScopeUtils . isInInterfaceOrAnnotationBlock ( methodDef ) 
 + & & ! modifiers . branchContains ( TokenTypes . LITERAL _ PRIVATE ) 
 + & & ! modifiers . branchContains ( TokenTypes . ABSTRACT ) 
 + & & ! modifiers . branchContains ( TokenTypes . FINAL ) 
 + & & ! modifiers . branchContains ( TokenTypes . LITERAL _ STATIC ) ; 
 + } 
 + 
 + / * * 
 + * Checks whether a method has any of ignored annotations . 
 + * @ param methodDef method definition token . 
 + * @ param annotations a set of ignored annotations . 
 + * @ return true if a method has any of ignored annotations . 
 + * / 
 + private static boolean hasIgnoredAnnotation ( DetailAST methodDef , Set < String > annotations ) { 
 + return annotations . stream ( ) . filter ( annotation - > hasAnnotation ( methodDef , annotation ) ) 
 + . findAny ( ) . isPresent ( ) ; 
 + } 
 + 
 + / * * 
 + * Check if a method has specific annotation . 
 + * @ param methodDef method definition token . 
 + * @ param annotationName annotation name . 
 + * @ return true , if a method has a specific annotation . 
 + * / 
 + private static boolean hasAnnotation ( DetailAST methodDef , String annotationName ) { 
 + final DetailAST modifiers = methodDef . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 + boolean containsAnnotation = false ; 
 + if ( modifiers . branchContains ( TokenTypes . ANNOTATION ) ) { 
 + final Optional < DetailAST > annotation = TokenUtils . findFirstTokenByPredicate ( modifiers , 
 + currentToken - > currentToken ! = null 
 + & & currentToken . getType ( ) = = TokenTypes . ANNOTATION 
 + & & annotationName . equals ( getAnnotationName ( currentToken ) ) ) ; 
 + if ( annotation . isPresent ( ) ) { 
 + containsAnnotation = true ; 
 + } 
 + } 
 + return containsAnnotation ; 
 + } 
 + 
 + / * * 
 + * Gets the name of the annotation . 
 + * @ param annotation to get name of . 
 + * @ return the name of the annotation . 
 + * / 
 + private static String getAnnotationName ( DetailAST annotation ) { 
 + final DetailAST dotAst = annotation . findFirstToken ( TokenTypes . DOT ) ; 
 + final String name ; 
 + if ( dotAst = = null ) { 
 + name = annotation . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; 
 + } 
 + else { 
 + name = dotAst . findFirstToken ( TokenTypes . IDENT ) . getText ( ) ; 
 + } 
 + return name ; 
 + } 
 + 
 + / * * 
 + * Returns CLASS _ DEF or ENUM _ DEF token which is the nearest to the given ast node . 
 + * Searches the tree towards the root until it finds a CLASS _ DEF or ENUM _ DEF node . 
 + * @ param ast the start node for searching . 
 + * @ return the CLASS _ DEF or ENUM _ DEF token . 
 + * / 
 + private static DetailAST getNearestClassOrEnumDefinition ( DetailAST ast ) { 
 + DetailAST searchAST = ast ; 
 + while ( searchAST . getType ( ) ! = TokenTypes . CLASS _ DEF 
 + & & searchAST . getType ( ) ! = TokenTypes . ENUM _ DEF ) { 
 + searchAST = searchAST . getParent ( ) ; 
 + } 
 + return searchAST ; 
 + } 
 + 
 + / * * 
 + * Checks if the given class ( given CLASS _ DEF node ) can be subclassed . 
 + * @ param classDef class definition token . 
 + * @ return true if the containing class can be subclassed . 
 + * / 
 + private static boolean canBeSubclassed ( DetailAST classDef ) { 
 + final DetailAST modifiers = classDef . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 + return classDef . getType ( ) ! = TokenTypes . ENUM _ DEF 
 + & & ! modifiers . branchContains ( TokenTypes . FINAL ) 
 + & & hasDefaultOrExplicitNonPrivateCtor ( classDef ) ; 
 + } 
 + 
 + / * * 
 + * Checks whether a class has default or explicit non - private constructor . 
 + * @ param classDef class ast token . 
 + * @ return true if a class has default or explicit non - private constructor . 
 * / 
 private static boolean hasDefaultOrExplicitNonPrivateCtor ( DetailAST classDef ) { 
 / / check if subclassing is prevented by having only private ctors 
 @ @ - 165 , 18 + 321 , 4 @ @ public class DesignForExtensionCheck extends AbstractCheck { 
 
 return hasDefaultConstructor | | hasExplicitNonPrivateCtor ; 
 } 
 - 
 - / * * 
 - * Searches the tree towards the root until it finds a CLASS _ DEF node . 
 - * @ param ast the start node for searching 
 - * @ return the CLASS _ DEF node . 
 - * / 
 - private static DetailAST findContainingClass ( DetailAST ast ) { 
 - DetailAST searchAST = ast ; 
 - while ( searchAST . getType ( ) ! = TokenTypes . CLASS _ DEF 
 - & & searchAST . getType ( ) ! = TokenTypes . ENUM _ DEF ) { 
 - searchAST = searchAST . getParent ( ) ; 
 - } 
 - return searchAST ; 
 - } 
 } 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java b / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java 
 index 6849b57 . . e49a312 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / utils / TokenUtils . java 
 @ @ - 21 , 9 + 21 , 12 @ @ package com . puppycrawl . tools . checkstyle . utils ; 
 
 import java . lang . reflect . Field ; 
 import java . util . Locale ; 
 + import java . util . Optional ; 
 import java . util . ResourceBundle ; 
 + import java . util . function . Predicate ; 
 
 import com . google . common . collect . ImmutableMap ; 
 + import com . puppycrawl . tools . checkstyle . api . DetailAST ; 
 import com . puppycrawl . tools . checkstyle . api . TokenTypes ; 
 
 / * * 
 @ @ - 179 , 4 + 182 , 30 @ @ public final class TokenUtils { 
 return isCommentType ( getTokenId ( type ) ) ; 
 } 
 
 + / * * 
 + * Finds the first node { @ link Optional } of { @ link DetailAST } which matches the predicate . 
 + * @ param root root node . 
 + * @ param predicate predicate . 
 + * @ return { @ link Optional } of { @ link DetailAST } node which matches the predicate . 
 + * / 
 + public static Optional < DetailAST > findFirstTokenByPredicate ( DetailAST root , 
 + Predicate < DetailAST > predicate ) { 
 + Optional < DetailAST > result = Optional . empty ( ) ; 
 + DetailAST rootNode = root ; 
 + while ( rootNode ! = null ) { 
 + DetailAST toVisit = rootNode . getFirstChild ( ) ; 
 + if ( predicate . test ( toVisit ) ) { 
 + result = Optional . of ( toVisit ) ; 
 + break ; 
 + } 
 + while ( rootNode ! = null & & toVisit = = null ) { 
 + toVisit = rootNode . getNextSibling ( ) ; 
 + if ( toVisit = = null ) { 
 + rootNode = rootNode . getParent ( ) ; 
 + } 
 + } 
 + rootNode = toVisit ; 
 + } 
 + return result ; 
 + } 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheckTest . java 
 index 388b82e . . 79d4a80 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / design / DesignForExtensionCheckTest . java 
 @ @ - 51 , 9 + 51 , 8 @ @ public class DesignForExtensionCheckTest 
 final DefaultConfiguration checkConfig = 
 createCheckConfig ( DesignForExtensionCheck . class ) ; 
 final String [ ] expected = { 
 - " 46 : 5 : " + getCheckMessage ( MSG _ KEY , " doh " ) , 
 - " 54 : 5 : " + getCheckMessage ( MSG _ KEY , " aNativeMethod " ) , 
 - " 105 : 9 : " + getCheckMessage ( MSG _ KEY , " someMethod " ) , 
 + " 46 : 5 : " + getCheckMessage ( MSG _ KEY , " InputDesignForExtension " , " doh " ) , 
 + " 100 : 9 : " + getCheckMessage ( MSG _ KEY , " anotherNonFinalClass " , " someMethod " ) , 
 } ; 
 verify ( checkConfig , getPath ( " InputDesignForExtension . java " ) , expected ) ; 
 
 @ @ - 65 , 4 + 64 , 47 @ @ public class DesignForExtensionCheckTest 
 final int [ ] expected = { TokenTypes . METHOD _ DEF } ; 
 assertArrayEquals ( expected , obj . getAcceptableTokens ( ) ) ; 
 } 
 + 
 + @ Test 
 + public void testOverridableMethods ( ) throws Exception { 
 + final DefaultConfiguration checkConfig = createCheckConfig ( DesignForExtensionCheck . class ) ; 
 + final String [ ] expected = { 
 + " 6 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo1 " ) , 
 + " 30 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo8 " ) , 
 + " 35 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo9 " ) , 
 + " 42 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo10 " ) , 
 + " 49 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo11 " ) , 
 + " 54 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo12 " ) , 
 + " 61 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo13 " ) , 
 + " 68 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo14 " ) , 
 + " 90 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo22 " ) , 
 + " 96 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo23 " ) , 
 + " 110 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo26 " ) , 
 + " 117 : 9 : " + getCheckMessage ( MSG _ KEY , " A " , " foo27 " ) , 
 + } ; 
 + verify ( checkConfig , getPath ( " InputDesignForExtensionOverridableMethods . java " ) , expected ) ; 
 + } 
 + 
 + @ Test 
 + public void testIgnoredAnnotationsOption ( ) throws Exception { 
 + final DefaultConfiguration checkConfig = createCheckConfig ( DesignForExtensionCheck . class ) ; 
 + checkConfig . addAttribute ( " ignoredAnnotations " , " Override , Deprecated " ) ; 
 + final String [ ] expected = { 
 + " 31 : 5 : " 
 + + getCheckMessage ( MSG _ KEY , " InputDesignForExtensionIgnoredAnnotations " , " foo1 " ) , 
 + " 141 : 5 : " 
 + + getCheckMessage ( MSG _ KEY , " InputDesignForExtensionIgnoredAnnotations " , " foo21 " ) , 
 + } ; 
 + verify ( checkConfig , getPath ( " InputDesignForExtensionIgnoredAnnotations . java " ) , expected ) ; 
 + } 
 + 
 + @ Test 
 + public void testNativeMethods ( ) throws Exception { 
 + final DefaultConfiguration checkConfig = createCheckConfig ( DesignForExtensionCheck . class ) ; 
 + checkConfig . addAttribute ( " ignoredAnnotations " , " Deprecated " ) ; 
 + final String [ ] expected = { 
 + " 8 : 5 : " + getCheckMessage ( MSG _ KEY , " InputDesignForExtensionNativeMethods " , " foo1 " ) , 
 + } ; 
 + verify ( checkConfig , getPath ( " InputDesignForExtensionNativeMethods . java " ) , expected ) ; 
 + } 
 } 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtension . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtension . java 
 index 0b3914d . . b32c5e2 100644 
 - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtension . java 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtension . java 
 @ @ - 47 , 11 + 47 , 6 @ @ public abstract class InputDesignForExtension 
 { 
 System . identityHashCode ( " nonempty and overriding possible " ) ; 
 } 
 - 
 - / / has a potentially complex implementation in native code . 
 - / / We can ' t check that , so to be safe DesignForExtension requires 
 - / / native methods to also be final 
 - public native void aNativeMethod ( ) ; 
 
 public final void aFinalMethod ( ) 
 { 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionIgnoredAnnotations . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionIgnoredAnnotations . java 
 new file mode 100644 
 index 0000000 . . c8a2e36 
 - - - / dev / null 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionIgnoredAnnotations . java 
 @ @ - 0 , 0 + 1 , 143 @ @ 
 + package com . puppycrawl . tools . checkstyle . checks . design ; 
 + 
 + public class InputDesignForExtensionIgnoredAnnotations { 
 + 
 + @ Override 
 + public int hashCode ( ) { 
 + return super . hashCode ( ) ; 
 + } 
 + 
 + / * * 
 + * Javadoc . 
 + * @ param obj object . 
 + * @ return boolean . 
 + * / 
 + @ Override 
 + public boolean equals ( Object obj ) { 
 + return super . equals ( obj ) ; 
 + } 
 + 
 + @ Deprecated 
 + public void testFoo ( ) throws Exception { 
 + final int a = 5 ; 
 + final int b = 6 ; 
 + } 
 + 
 + @ Deprecated 
 + public String toString ( ) { 
 + return super . toString ( ) ; 
 + } 
 + 
 + public int foo1 ( ) { return 1 ; } / / violation 
 + 
 + / * * 
 + * 
 + * @ return 
 + * / 
 + public int foo2 ( ) { return 2 ; } 
 + 
 + public void foo3 ( ) { } 
 + 
 + public class C extends B { 
 + @ Deprecated 
 + @ Override 
 + public void testFoo ( ) { 
 + super . testFoo ( ) ; 
 + } 
 + } 
 + 
 + public class B { 
 + / * * Test foo * / 
 + public void testFoo ( ) { 
 + final int a = 6 ; 
 + } 
 + } 
 + 
 + / / Deprecated 
 + @ Deprecated 
 + public void foo4 ( ) { return ; } 
 + 
 + / * 
 + * Deprecated 
 + * / 
 + @ Deprecated 
 + public void foo5 ( ) { return ; } 
 + 
 + @ java . lang . Deprecated 
 + public void foo6 ( ) { return ; } 
 + 
 + / / Single line comment 
 + @ Deprecated 
 + public void foo7 ( ) { 
 + return ; 
 + } 
 + 
 + / / Single line comments 
 + / / organized in a block 
 + @ Deprecated 
 + public void foo8 ( ) { 
 + return ; 
 + } 
 + 
 + / * * Javadoc comment * / 
 + @ Deprecated 
 + public void foo9 ( ) { 
 + return ; 
 + } 
 + 
 + / * Block comment * / 
 + @ Deprecated 
 + public void foo10 ( ) { 
 + return ; 
 + } 
 + 
 + @ Deprecated 
 + / * * * / 
 + public int foo11 ( ) { 
 + return 1 ; 
 + } 
 + 
 + @ Deprecated 
 + / * * / 
 + public int foo12 ( ) { 
 + return 1 ; 
 + } 
 + 
 + @ Deprecated 
 + / * * / 
 + public void foo13 ( ) { } 
 + 
 + @ Deprecated 
 + / * * * / 
 + public void foo14 ( ) { } 
 + 
 + @ Deprecated 
 + / * * * / 
 + public void foo15 ( ) { / * * * / } 
 + 
 + @ Deprecated 
 + / / comment 
 + public void foo16 ( ) { } 
 + 
 + @ Deprecated 
 + @ InputLocalAnnotations . ClassRule 
 + public void foo17 ( ) { return ; } 
 + 
 + @ Deprecated 
 + @ InputLocalAnnotations . ClassRule 
 + / * * * / 
 + public void foo18 ( ) { return ; } 
 + 
 + @ Deprecated 
 + / * * * / 
 + @ InputLocalAnnotations . ClassRule 
 + public void foo19 ( ) { return ; } 
 + 
 + / * * * / 
 + @ Deprecated 
 + @ InputLocalAnnotations . ClassRule 
 + public void foo20 ( ) { return ; } 
 + 
 + @ InputLocalAnnotations . ClassRule 
 + public void foo21 ( ) { return ; } / / violation 
 + } 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionNativeMethods . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionNativeMethods . java 
 new file mode 100644 
 index 0000000 . . e908730 
 - - - / dev / null 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionNativeMethods . java 
 @ @ - 0 , 0 + 1 , 28 @ @ 
 + package com . puppycrawl . tools . checkstyle . checks . design ; 
 + 
 + public class InputDesignForExtensionNativeMethods { 
 + 
 + / / has a potentially complex implementation in native code . 
 + / / We can ' t check that , so to be safe DesignForExtension requires 
 + / / native methods to also be final 
 + public native void foo1 ( ) ; / / violation 
 + 
 + public static native void foo2 ( ) ; 
 + 
 + protected static native void foo3 ( ) ; 
 + 
 + protected static final native void foo4 ( ) ; 
 + 
 + / * * 
 + * Javadoc for native method . 
 + * / 
 + public native void foo5 ( ) ; 
 + 
 + / * 
 + * Block - commend doc for native method . 
 + * / 
 + public native void foo6 ( ) ; 
 + 
 + @ Deprecated 
 + public native void foo7 ( ) ; 
 + } 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionOverridableMethods . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionOverridableMethods . java 
 new file mode 100644 
 index 0000000 . . afa1512 
 - - - / dev / null 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / design / InputDesignForExtensionOverridableMethods . java 
 @ @ - 0 , 0 + 1 , 221 @ @ 
 + package com . puppycrawl . tools . checkstyle . checks . design ; 
 + 
 + public class InputDesignForExtensionOverridableMethods { 
 + 
 + public class A { 
 + public int foo1 ( int a , int b ) { return a + b ; } / / violation 
 + 
 + public void foo2 ( ) { } 
 + 
 + public void foo3 ( int a , int b ) { } 
 + 
 + private int foo4 ( int a , int b ) { return a + b ; } 
 + 
 + public void foo5 ( ) { 
 + / / single line comment is not counted as a content 
 + } 
 + 
 + public void foo6 ( ) { 
 + / * * 
 + * javadoc block comment is not counted as a content 
 + * / 
 + } 
 + 
 + public void foo7 ( ) { 
 + / * 
 + * block comment is not counted as a content 
 + * / 
 + } 
 + 
 + public int foo8 ( int a , int b ) { / / violation 
 + / / single line comment before content 
 + return a + b ; 
 + } 
 + 
 + public int foo9 ( int a , int b ) { / / violation 
 + / * 
 + * block comment before content 
 + * / 
 + return a + b ; 
 + } 
 + 
 + public int foo10 ( int a , int b ) { / / violation 
 + / * * 
 + * javadoc block comment before content 
 + * / 
 + return a + b ; 
 + } 
 + 
 + public int foo11 ( int a , int b ) { / / violation 
 + return a + b ; 
 + / / single line comment after content 
 + } 
 + 
 + public int foo12 ( int a , int b ) { / / violation 
 + return a + b ; 
 + / * 
 + * block comment after content 
 + * / 
 + } 
 + 
 + public int foo13 ( int a , int b ) { / / violation 
 + return a + b ; 
 + / * * 
 + * javadoc block comment after content 
 + * / 
 + } 
 + 
 + protected int foo14 ( int a ) { return a - 1 ; } / / violation 
 + 
 + public final int foo15 ( int a ) { return a - 2 ; } 
 + 
 + protected final int foo16 ( int a ) { return a - 2 ; } 
 + 
 + / * * Javadoc comment * / 
 + protected int foo17 ( int a ) { return a - 1 ; } 
 + 
 + / * * Method javadoc * / 
 + public void foo18 ( ) { } 
 + 
 + / * * Method javadoc * / 
 + public int foo19 ( ) { return 1 ; } 
 + 
 + / * * * / 
 + public final int foo20 ( int a ) { return a - 2 ; } 
 + 
 + / * * * / 
 + protected final int foo21 ( int a ) { return a - 2 ; } 
 + 
 + / / Single line comment 
 + public void foo22 ( ) { / / violation 
 + return ; 
 + } 
 + 
 + / / Single line comments 
 + / / organized in a block 
 + public void foo23 ( ) { / / violation 
 + return ; 
 + } 
 + 
 + / / Single line comments 
 + / / organized in a block 
 + public void foo24 ( ) { } 
 + 
 + / * Block comment * / 
 + public void foo25 ( ) { 
 + return ; 
 + } 
 + 
 + / / Single line comment 
 + @ Deprecated / / violation 
 + public void foo26 ( ) { 
 + return ; 
 + } 
 + 
 + / / Single line comments 
 + / / organized in a block 
 + @ Deprecated / / violation 
 + public void foo27 ( ) { 
 + return ; 
 + } 
 + 
 + / * * Javadoc comment * / 
 + @ Deprecated 
 + public void foo28 ( ) { 
 + return ; 
 + } 
 + 
 + / * Block comment * / 
 + @ Deprecated 
 + public void foo29 ( ) { 
 + return ; 
 + } 
 + 
 + / * * 
 + * Returns maximum of a and b . 
 + * @ param a a . 
 + * @ param b b . 
 + * @ return maximum of a and b . 
 + * / 
 + public int max ( int a , int b ) { 
 + return Math . max ( a , b ) ; 
 + } 
 + 
 + / * * * / 
 + public int foo30 ( ) { 
 + / * * * / 
 + return 1 ; 
 + } 
 + 
 + / * * / 
 + public int foo31 ( ) { 
 + / * * * / 
 + return 1 ; 
 + } 
 + 
 + / * * * / 
 + public int foo32 ( ) { 
 + / * * / 
 + return 1 ; 
 + } 
 + 
 + @ Deprecated 
 + / * * * / 
 + public int foo33 ( ) { 
 + return 1 ; 
 + } 
 + 
 + @ Deprecated 
 + / * * / 
 + public int foo34 ( ) { 
 + return 1 ; 
 + } 
 + 
 + @ Deprecated 
 + / * * / 
 + public void foo35 ( ) { } 
 + 
 + @ Deprecated 
 + / * * * / 
 + public void foo36 ( ) { } 
 + 
 + @ Deprecated 
 + / * * * / 
 + public void foo37 ( ) { / * * * / } 
 + 
 + @ Deprecated 
 + / / comment 
 + public void foo38 ( ) { } 
 + 
 + @ Deprecated / * * * / 
 + public void foo39 ( ) { return ; } 
 + 
 + / * * 
 + * @ param indent indentation to check . 
 + * @ return true if { @ code indent } less then minimal of 
 + * acceptable indentation levels , false otherwise . 
 + * / 
 + public boolean isGreaterThan ( int indent ) { 
 + return indent = = 2 ; 
 + } 
 + 
 + / * * 
 + * Sets whether to process JavaDoc or not . 
 + * 
 + * @ param value Flag for processing JavaDoc . 
 + * / 
 + public void setProcessJavadoc ( boolean value ) { 
 + value = true ; 
 + } 
 + } 
 + 
 + public final class B { 
 + public int foo1 ( int a , int b ) { return a + b ; } 
 + 
 + protected int foo2 ( int a , int b ) { return a + b ; } 
 + 
 + public final int foo3 ( int a , int b ) { return a + b ; } 
 + 
 + protected final int foo4 ( int a , int b ) { return a + b ; } 
 + } 
 + } 
 diff - - git a / src / xdocs / config _ design . xml b / src / xdocs / config _ design . xml 
 index f28d6c3 . . 206dda9 100644 
 - - - a / src / xdocs / config _ design . xml 
 + + + b / src / xdocs / config _ design . xml 
 @ @ - 24 , 19 + 24 , 31 @ @ 
 < section name = " DesignForExtension " > 
 < subsection name = " Description " > 
 < p > 
 - The Check finds classes that are designed for extension ( subclass creation ) . 
 + The check finds classes that are designed for extension ( subclass creation ) . 
 < / p > 
 < p > 
 - Nothing wrong could be with founded classes 
 - this Check make sence only for library project ( not a application projects ) 
 - who care about ideal OOP design to make sure class work in all cases even misusage . 
 - Even in library projects this Check most likely finds classes that are not required to check . 
 - User need to use suppressions extensively to got a benefit from this Check and avoid 
 - false positives . 
 + Nothing wrong could be with founded classes . 
 + This check makes sense only for library project ( not an application projects ) 
 + which care of ideal OOP - design to make sure that class works in all cases even misusage . 
 + Even in library projects this check most likely will find classes that are designed 
 + for extension by somebody . User needs to use suppressions extensively to got a benefit from 
 + this check , and keep in suppressions all confirmed / known classes that are deigned for 
 + inheritance intentionally to let the check catch only new classes , and bring this to 
 + team / user attention . 
 < / p > 
 < p > 
 - ATTENTION : Only user can deside whether class is designed for extension or not . 
 - Check just show all possible . If smth inappropriate is found please use supporession . 
 + ATTENTION : Only user can decide whether a class is designed for extension or not . 
 + The check just shows all classes which are possibly designed for extension . 
 + If smth inappropriate is found please use suppression . 
 + < / p > 
 + < p > 
 + ATTENTION : If the method which can be overridden in a subclass has a javadoc comment 
 + ( a good practise is to explain its self - use of overridable methods ) the check will not 
 + rise a violation . The violation can also be skipped if the method which can be overridden 
 + in a subclass has one or more annotations that are specified in ignoredAnnotations 
 + option . Note , that by default @ Override annotation is not included in the 
 + ignoredAnnotations set as in a subclass the method which has the annotation can also be 
 + overridden in its subclass . 
 < / p > 
 < p > 
 Problem is described at " Effective Java , 2nd Edition by Josh Bloch " book , chapter " Item 17 : Design and document for inheritance or else prohibit it " . 
 @ @ - 61 , 16 + 73 , 10 @ @ In doing so , you â€™ ll create a class that is reasonably safe to subclass . Overri 
 method will never affect the behavior of any other method . 
 < / blockquote > 
 < p > 
 - The exact rule is that non - private , non - static methods of classes that 
 - can be subclassed must 
 + The check finds classes that have overridable methods ( public or protected methods 
 + that are non - static , not - final , non - abstract ) and have non - empty implementation . 
 < / p > 
 
 - < ul > 
 - < li > be abstract or < / li > 
 - < li > be final or < / li > 
 - < li > have an empty implementation . < / li > 
 - < / ul > 
 - 
 < p > 
 Rationale : This library design style protects superclasses against 
 being broken by subclasses . The downside is that subclasses are 
 @ @ - 135 , 6 + 141 , 25 @ @ public abstract class Plant { 
 < / source > 
 < / subsection > 
 
 + < subsection name = " Properties " > 
 + < table > 
 + < tr > 
 + < th > name < / th > 
 + < th > description < / th > 
 + < th > type < / th > 
 + < th > default value < / th > 
 + < / tr > 
 + < tr > 
 + < td > ignoredAnnotations < / td > 
 + < td > 
 + Annotations which allow the check to skip the method from validation . 
 + < / td > 
 + < td > < a href = " property _ types . html # stringSet " > String Set < / a > < / td > 
 + < td > < code > Test , Before , After , BeforeClass , AfterClass < / code > < / td > 
 + < / tr > 
 + < / table > 
 + < / subsection > 
 + 
 < subsection name = " Examples " > 
 < p > 
 To configure the check : 
 @ @ - 143 , 6 + 168 , 50 @ @ public abstract class Plant { 
 < source > 
 & lt ; module name = & quot ; DesignForExtension & quot ; / & gt ; 
 < / source > 
 + 
 + < p > 
 + To configure the check to allow methods which have @ Override and @ Test annotations to be 
 + designed for extension . 
 + < / p > 
 + 
 + < source > 
 + & lt ; module name = & quot ; DesignForExtension & quot ; & gt ; 
 + & lt ; property name = & quot ; ignoredAnnotations & quot ; value = & quot ; Override , Test & quot ; / & gt ; 
 + & lt ; / module & gt ; 
 + < / source > 
 + 
 + < source > 
 + public class A extends B { 
 + @ Override 
 + public int foo ( ) { 
 + return 2 ; 
 + } 
 + 
 + public int foo2 ( ) { return 8 ; } / / violation 
 + } 
 + 
 + public class B { 
 + / * * 
 + * This implementation . . . 
 + @ return some int value . 
 + * / 
 + public int foo ( ) { 
 + return 1 ; 
 + } 
 + 
 + public int foo3 ( ) { return 3 ; } / / violation 
 + } 
 + 
 + public class FooTest { 
 + @ Test 
 + public void testFoo ( ) { 
 + final B b = new A ( ) ; 
 + assertEquals ( 2 , b . foo ( ) ) ; 
 + } 
 + 
 + public int foo4 ( ) { return 4 ; } / / violation 
 + } 
 + < / source > 
 < / subsection > 
 
 < subsection name = " Example of Usage " >

NEAREST DIFF:
diff - - git a / src / xdocs / config _ modifier . xml b / src / xdocs / config _ modifier . xml 
 index 0e250b3 . . 3b60f68 100644 
 - - - a / src / xdocs / config _ modifier . xml 
 + + + b / src / xdocs / config _ modifier . xml 
 @ @ - 96 , 6 + 96 , 11 @ @ 
 < / p > 
 
 < p > 
 + Interfaces by definition are abstract so the < code > abstract < / code > 
 + modifier on the interface is redundant . 
 + < / p > 
 + 
 + < p > 
 Variables in interfaces and annotations are automatically 
 public , static and final , so these modifiers are redundant as 
 well .
