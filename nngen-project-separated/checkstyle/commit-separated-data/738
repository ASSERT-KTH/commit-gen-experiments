BLEU SCORE: 0.09238430210261096

TEST MSG: Issue # 4475 : added verification of columns and since version in xdocs
GENERATED MSG: Issue # 3187 : validate property types in xdocs

TEST DIFF (one line): diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsPagesTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsPagesTest . java <nl> index 2dfd35b . . ca05137 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsPagesTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsPagesTest . java <nl> @ @ - 71 , 6 + 71 , 8 @ @ public class XdocsPagesTest { <nl> private static final String LINK _ TEMPLATE = <nl> " ( ? s ) . * < a href = \ " config _ \ \ w + \ \ . html # % 1 $ s \ " > % 1 $ s < / a > . * " ; <nl> <nl> + private static final Pattern VERSION = Pattern . compile ( " \ \ d + \ \ . \ \ d + ( \ \ . \ \ d + ) ? " ) ; <nl> + <nl> private static final List < String > XML _ FILESET _ LIST = Arrays . asList ( <nl> " TreeWalker " , <nl> " name = \ " Checker \ " " , <nl> @ @ - 487 , 15 + 489 , 35 @ @ public class XdocsPagesTest { <nl> boolean didTokens = false ; <nl> <nl> for ( Node row : XmlUtil . getChildrenElements ( XmlUtil . getFirstChildElement ( subSection ) ) ) { <nl> + final List < Node > columns = new ArrayList < > ( XmlUtil . getChildrenElements ( row ) ) ; <nl> + <nl> + Assert . assertEquals ( fileName + " section ' " + sectionName <nl> + + " ' should have the requested columns " , 5 , columns . size ( ) ) ; <nl> + <nl> if ( skip ) { <nl> + Assert . assertEquals ( fileName + " section ' " + sectionName <nl> + + " ' should have the specific title " , " name " , columns . get ( 0 ) <nl> + . getTextContent ( ) ) ; <nl> + Assert . assertEquals ( fileName + " section ' " + sectionName <nl> + + " ' should have the specific title " , " description " , columns . get ( 1 ) <nl> + . getTextContent ( ) ) ; <nl> + Assert . assertEquals ( fileName + " section ' " + sectionName <nl> + + " ' should have the specific title " , " type " , columns . get ( 2 ) <nl> + . getTextContent ( ) ) ; <nl> + Assert . assertEquals ( fileName + " section ' " + sectionName <nl> + + " ' should have the specific title " , " default value " , columns . get ( 3 ) <nl> + . getTextContent ( ) ) ; <nl> + Assert . assertEquals ( fileName + " section ' " + sectionName <nl> + + " ' should have the specific title " , " since " , columns . get ( 4 ) <nl> + . getTextContent ( ) ) ; <nl> + <nl> skip = false ; <nl> continue ; <nl> } <nl> + <nl> Assert . assertFalse ( fileName + " section ' " + sectionName <nl> + " ' should have token properties last " , didTokens ) ; <nl> <nl> - final List < Node > columns = new ArrayList < > ( XmlUtil . getChildrenElements ( row ) ) ; <nl> - <nl> final String propertyName = columns . get ( 0 ) . getTextContent ( ) ; <nl> Assert . assertTrue ( fileName + " section ' " + sectionName <nl> + " ' should not contain the property : " + propertyName , <nl> @ @ - 515 , 39 + 537 , 53 @ @ public class XdocsPagesTest { <nl> Assert . assertFalse ( fileName + " section ' " + sectionName <nl> + " ' should have javadoc token properties next to last , before tokens " , <nl> didJavadocTokens ) ; <nl> - Assert . assertFalse ( fileName + " section ' " + sectionName <nl> - + " ' should have a description for " + propertyName , columns . get ( 1 ) <nl> - . getTextContent ( ) . trim ( ) . isEmpty ( ) ) ; <nl> <nl> - final String actualTypeName = columns . get ( 2 ) . getTextContent ( ) . replace ( " \ n " , " " ) <nl> - . replace ( " \ r " , " " ) . replaceAll ( " + " , " " ) . trim ( ) ; <nl> + validatePropertySectionPropertyEx ( fileName , sectionName , instance , columns , <nl> + propertyName ) ; <nl> + } <nl> <nl> - Assert . assertFalse ( fileName + " section ' " + sectionName <nl> - + " ' should have a type for " + propertyName , actualTypeName . isEmpty ( ) ) ; <nl> + Assert . assertFalse ( fileName + " section ' " + sectionName <nl> + + " ' should have a version for " + propertyName , columns . get ( 4 ) <nl> + . getTextContent ( ) . trim ( ) . isEmpty ( ) ) ; <nl> + Assert . assertTrue ( fileName + " section ' " + sectionName <nl> + + " ' should have a valid version for " + propertyName , <nl> + VERSION . matcher ( columns . get ( 4 ) . getTextContent ( ) . trim ( ) ) . matches ( ) ) ; <nl> + } <nl> + } <nl> <nl> - final PropertyDescriptor descriptor = PropertyUtils . getPropertyDescriptor ( instance , <nl> - propertyName ) ; <nl> - final Class < ? > clss = descriptor . getPropertyType ( ) ; <nl> - final String expectedTypeName = <nl> - getModulePropertyExpectedTypeName ( clss , instance , propertyName ) ; <nl> - <nl> - if ( expectedTypeName ! = null ) { <nl> - final String expectedValue = getModulePropertyExpectedValue ( clss , instance , <nl> - propertyName ) ; <nl> - <nl> - Assert . assertEquals ( fileName + " section ' " + sectionName <nl> - + " ' should have the type for " + propertyName , expectedTypeName , <nl> - actualTypeName ) ; <nl> - <nl> - if ( expectedValue ! = null ) { <nl> - final String actualValue = columns . get ( 3 ) . getTextContent ( ) . replace ( " \ n " , " " ) <nl> - . replace ( " \ r " , " " ) . replaceAll ( " + " , " " ) . trim ( ) ; <nl> - <nl> - Assert . assertEquals ( fileName + " section ' " + sectionName <nl> - + " ' should have the value for " + propertyName , expectedValue , <nl> - actualValue ) ; <nl> - } <nl> - } <nl> + private static void validatePropertySectionPropertyEx ( String fileName , String sectionName , <nl> + Object instance , List < Node > columns , String propertyName ) throws Exception { <nl> + Assert . assertFalse ( fileName + " section ' " + sectionName <nl> + + " ' should have a description for " + propertyName , columns . get ( 1 ) <nl> + . getTextContent ( ) . trim ( ) . isEmpty ( ) ) ; <nl> + <nl> + final String actualTypeName = columns . get ( 2 ) . getTextContent ( ) . replace ( " \ n " , " " ) <nl> + . replace ( " \ r " , " " ) . replaceAll ( " + " , " " ) . trim ( ) ; <nl> + <nl> + Assert . assertFalse ( fileName + " section ' " + sectionName + " ' should have a type for " <nl> + + propertyName , actualTypeName . isEmpty ( ) ) ; <nl> + <nl> + final PropertyDescriptor descriptor = PropertyUtils . getPropertyDescriptor ( instance , <nl> + propertyName ) ; <nl> + final Class < ? > clss = descriptor . getPropertyType ( ) ; <nl> + final String expectedTypeName = getModulePropertyExpectedTypeName ( clss , instance , <nl> + propertyName ) ; <nl> + <nl> + if ( expectedTypeName ! = null ) { <nl> + final String expectedValue = getModulePropertyExpectedValue ( clss , instance , <nl> + propertyName ) ; <nl> + <nl> + Assert . assertEquals ( fileName + " section ' " + sectionName <nl> + + " ' should have the type for " + propertyName , expectedTypeName , <nl> + actualTypeName ) ; <nl> + <nl> + if ( expectedValue ! = null ) { <nl> + final String actualValue = columns . get ( 3 ) . getTextContent ( ) . replace ( " \ n " , " " ) <nl> + . replace ( " \ r " , " " ) . replaceAll ( " + " , " " ) . trim ( ) ; <nl> + <nl> + Assert . assertEquals ( fileName + " section ' " + sectionName <nl> + + " ' should have the value for " + propertyName , expectedValue , <nl> + actualValue ) ; <nl> } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / config / suppressions . xml b / config / suppressions . xml <nl> index 0ff8df2 . . 895057b 100644 <nl> - - - a / config / suppressions . xml <nl> + + + b / config / suppressions . xml <nl> @ @ - 91 , 6 + 91 , 7 @ @ <nl> < suppress checks = " AvoidStaticImport " files = " . * [ \ \ / ] src [ \ \ / ] ( test | it ) [ \ \ / ] " / > <nl> < suppress checks = " MethodCount " files = " [ \ \ / ] ImportOrderCheckTest . java $ " / > <nl> < suppress checks = " MethodCount " files = " [ \ \ / ] IndentationCheckTest . java $ " / > <nl> + < suppress checks = " ClassDataAbstractionCoupling " files = " [ \ \ / ] IndentationCheckTest . java $ " / > <nl> < suppress checks = " MethodCount " files = " [ \ \ / ] JavadocMethodCheckTest . java $ " / > <nl> < suppress checks = " MethodCount " files = " [ \ \ / ] MainTest . java $ " / > <nl> < suppress checks = " EqualsAvoidNull " files = " [ \ \ / ] Int . * FilterTest . java $ " / > <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java <nl> index f7cafcc . . dccc2da 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import static com . puppycrawl . tools . checkstyle . checks . indentation . IndentationChec <nl> import static com . puppycrawl . tools . checkstyle . checks . indentation . IndentationCheck . MSG _ ERROR _ MULTI ; <nl> import static org . junit . Assert . assertArrayEquals ; <nl> import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> <nl> import java . io . BufferedReader ; <nl> import java . io . File ; <nl> @ @ - 42 , 7 + 43 , 10 @ @ import java . util . regex . Pattern ; <nl> import org . junit . Test ; <nl> <nl> import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; <nl> + import com . puppycrawl . tools . checkstyle . Checker ; <nl> import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; <nl> + import com . puppycrawl . tools . checkstyle . api . AuditEvent ; <nl> + import com . puppycrawl . tools . checkstyle . api . AuditListener ; <nl> import com . puppycrawl . tools . checkstyle . api . Configuration ; <nl> import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; <nl> <nl> @ @ - 52 , 57 + 56 , 42 @ @ import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; <nl> * / <nl> public class IndentationCheckTest extends BaseCheckTestSupport { <nl> private static final Pattern LINE _ WITH _ COMMENT _ REGEX = <nl> - Pattern . compile ( " . * ? ( / / indent : ( \ \ d + ) " <nl> - + " exp : ( ( > = \ \ d + ) | ( \ \ d + ( , \ \ d + ) * ? ) ) ( warn ) ? ) $ " ) ; <nl> + Pattern . compile ( " . * ? / / indent : ( \ \ d + ) ( ? : ioffset : ( \ \ d + ) ) ? " <nl> + + " exp : ( > = ) ? ( \ \ d + ( ? : , \ \ d + ) * ? ) ( warn ) ? $ " ) ; <nl> <nl> - private static final Pattern GET _ INDENT _ FROM _ COMMENT _ REGEX = <nl> - Pattern . compile ( " / / indent : ( \ \ d + ) . * ? " ) ; <nl> - <nl> - private static final Pattern MULTILEVEL _ COMMENT _ REGEX = <nl> - Pattern . compile ( " / / indent : \ \ d + exp : ( \ \ d + ( , \ \ d + ) + ? ) ( warn ) ? " ) ; <nl> - <nl> - private static final Pattern SINGLE _ LEVEL _ COMMENT _ REGEX = <nl> - Pattern . compile ( " / / indent : \ \ d + exp : ( \ \ d + ) ( warn ) ? " ) ; <nl> - <nl> - private static final Pattern NON _ STRICT _ LEVEL _ COMMENT _ REGEX = <nl> - Pattern . compile ( " / / indent : \ \ d + exp : > = ( \ \ d + ) ( warn ) ? " ) ; <nl> - <nl> - private static final String [ ] EMPTY _ EXPECTED = { } ; <nl> - <nl> - private static Integer [ ] getLinesWithWarnAndCheckComments ( String aFileName , <nl> + private static IndentComment [ ] getLinesWithWarnAndCheckComments ( String aFileName , <nl> final int tabWidth ) <nl> throws IOException { <nl> - final List < Integer > result = new ArrayList < > ( ) ; <nl> + final List < IndentComment > result = new ArrayList < > ( ) ; <nl> try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( <nl> new FileInputStream ( aFileName ) , StandardCharsets . UTF _ 8 ) ) ) { <nl> int lineNumber = 1 ; <nl> for ( String line = br . readLine ( ) ; line ! = null ; line = br . readLine ( ) ) { <nl> final Matcher match = LINE _ WITH _ COMMENT _ REGEX . matcher ( line ) ; <nl> if ( match . matches ( ) ) { <nl> - final String comment = match . group ( 1 ) ; <nl> - final int indentInComment = getIndentFromComment ( comment ) ; <nl> + final IndentComment warn = new IndentComment ( match , lineNumber ) ; <nl> final int actualIndent = getLineStart ( line , tabWidth ) ; <nl> <nl> - if ( actualIndent ! = indentInComment ) { <nl> + if ( actualIndent ! = warn . getIndent ( ) ) { <nl> throw new IllegalStateException ( String . format ( Locale . ROOT , <nl> - " File \ " % 1 $ s \ " has incorrect indentation in comment . " <nl> + " File \ " % 1 $ s \ " has incorrect indentation in comment . " <nl> + " Line % 2 $ d : comment : % 3 $ d , actual : % 4 $ d . " , <nl> aFileName , <nl> lineNumber , <nl> - indentInComment , <nl> + warn . getIndent ( ) , <nl> actualIndent ) ) ; <nl> } <nl> <nl> - if ( isWarnComment ( comment ) ) { <nl> - result . add ( lineNumber ) ; <nl> - } <nl> - <nl> - if ( ! isCommentConsistent ( comment ) ) { <nl> + if ( ! isCommentConsistent ( warn ) ) { <nl> throw new IllegalStateException ( String . format ( Locale . ROOT , <nl> " File \ " % 1 $ s \ " has inconsistent comment on line % 2 $ d " , <nl> aFileName , <nl> lineNumber ) ) ; <nl> } <nl> + <nl> + if ( warn . isWarning ( ) ) { <nl> + result . add ( warn ) ; <nl> + } <nl> } <nl> else if ( ! line . isEmpty ( ) ) { <nl> throw new IllegalStateException ( String . format ( Locale . ROOT , <nl> @ @ - 114 , 55 + 103 , 34 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { <nl> lineNumber + + ; <nl> } <nl> } <nl> - return result . toArray ( new Integer [ result . size ( ) ] ) ; <nl> + return result . toArray ( new IndentComment [ result . size ( ) ] ) ; <nl> } <nl> <nl> - private static int getIndentFromComment ( String comment ) { <nl> - final Matcher match = GET _ INDENT _ FROM _ COMMENT _ REGEX . matcher ( comment ) ; <nl> - match . matches ( ) ; <nl> - return Integer . parseInt ( match . group ( 1 ) ) ; <nl> - } <nl> - <nl> - private static boolean isWarnComment ( String comment ) { <nl> - return comment . endsWith ( " warn " ) ; <nl> - } <nl> + private static boolean isCommentConsistent ( IndentComment comment ) { <nl> + final String [ ] levels = comment . getExpectedWarning ( ) . split ( " , " ) ; <nl> + final int indent = comment . getIndent ( ) + comment . getIndentOffset ( ) ; <nl> <nl> - private static boolean isCommentConsistent ( String comment ) { <nl> - final int indentInComment = getIndentFromComment ( comment ) ; <nl> - final boolean isWarnComment = isWarnComment ( comment ) ; <nl> - <nl> - final Matcher multilevelMatch = MULTILEVEL _ COMMENT _ REGEX . matcher ( comment ) ; <nl> - if ( multilevelMatch . matches ( ) ) { <nl> - final String [ ] levels = multilevelMatch . group ( 1 ) . split ( " , " ) ; <nl> - final String indentInCommentStr = String . valueOf ( indentInComment ) ; <nl> + if ( levels . length > 1 ) { <nl> + / / multi <nl> final boolean containsActualLevel = <nl> - Arrays . asList ( levels ) . contains ( indentInCommentStr ) ; <nl> + Arrays . asList ( levels ) . contains ( String . valueOf ( indent ) ) ; <nl> <nl> - return containsActualLevel & & ! isWarnComment <nl> - | | ! containsActualLevel & & isWarnComment ; <nl> + return containsActualLevel ! = comment . isWarning ( ) ; <nl> } <nl> + else { <nl> + final int expectedWarning = Integer . parseInt ( comment . getExpectedWarning ( ) ) ; <nl> <nl> - final Matcher singleLevelMatch = SINGLE _ LEVEL _ COMMENT _ REGEX . matcher ( comment ) ; <nl> - if ( singleLevelMatch . matches ( ) ) { <nl> - final int expectedLevel = Integer . parseInt ( singleLevelMatch . group ( 1 ) ) ; <nl> - return isSingleLevelCommentConsistent ( indentInComment , isWarnComment , expectedLevel ) ; <nl> - } <nl> - <nl> - final Matcher nonStrictLevelMatch = NON _ STRICT _ LEVEL _ COMMENT _ REGEX . matcher ( comment ) ; <nl> - if ( nonStrictLevelMatch . matches ( ) ) { <nl> - final int expectedMinimalIndent = Integer . parseInt ( nonStrictLevelMatch . group ( 1 ) ) ; <nl> - <nl> - return indentInComment > = expectedMinimalIndent & & ! isWarnComment <nl> - | | indentInComment < expectedMinimalIndent & & isWarnComment ; <nl> + if ( comment . isExpectedNonStrict ( ) ) { <nl> + / / non - strict <nl> + final boolean test = indent > = expectedWarning ; <nl> + return test ! = comment . isWarning ( ) ; <nl> + } <nl> + else { <nl> + / / single <nl> + final boolean test = expectedWarning = = indent ; <nl> + return test ! = comment . isWarning ( ) ; <nl> + } <nl> } <nl> - <nl> - throw new IllegalStateException ( " Comments are not consistent " ) ; <nl> - } <nl> - <nl> - private static boolean isSingleLevelCommentConsistent ( int indentInComment , <nl> - boolean isWarnComment , int expectedLevel ) { <nl> - return expectedLevel = = indentInComment & & ! isWarnComment <nl> - | | expectedLevel ! = indentInComment & & isWarnComment ; <nl> } <nl> <nl> private static int getLineStart ( String line , final int tabWidth ) { <nl> @ @ - 175 , 22 + 143 , 29 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { <nl> } <nl> <nl> private void verifyWarns ( Configuration config , String filePath , <nl> + String . . . expected ) <nl> + throws Exception { <nl> + verifyWarns ( config , filePath , expected , 0 ) ; <nl> + } <nl> + <nl> + private void verifyWarns ( Configuration config , String filePath , <nl> String [ ] expected , int warnCountCorrection ) <nl> throws Exception { <nl> final int tabWidth = Integer . parseInt ( config . getAttribute ( " tabWidth " ) ) ; <nl> - final Integer [ ] linesWithWarn = <nl> + final IndentComment [ ] linesWithWarn = <nl> getLinesWithWarnAndCheckComments ( filePath , tabWidth ) ; <nl> assertEquals ( " Expected warning count in UT does not match warn " <nl> + " comment count in input file " , linesWithWarn . length <nl> + warnCountCorrection , <nl> expected . length ) ; <nl> - verify ( config , filePath , expected ) ; <nl> + verify ( config , filePath , expected , linesWithWarn ) ; <nl> } <nl> <nl> - private void verifyWarns ( Configuration config , String filePath , <nl> - String . . . expected ) <nl> - throws Exception { <nl> - verifyWarns ( config , filePath , expected , 0 ) ; <nl> + private void verify ( Configuration config , String filePath , String [ ] expected , <nl> + final IndentComment . . . linesWithWarn ) throws Exception { <nl> + final Checker checker = createChecker ( config ) ; <nl> + checker . addListener ( new IndentAudit ( linesWithWarn ) ) ; <nl> + verify ( checker , new File [ ] { new File ( filePath ) } , filePath , expected ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 1587 , 7 + 1562 , 7 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { <nl> checkConfig . addAttribute ( " tabWidth " , " 4 " ) ; <nl> checkConfig . addAttribute ( " basicOffset " , " 4 " ) ; <nl> checkConfig . addAttribute ( " lineWrappingIndentation " , " 8 " ) ; <nl> - final String [ ] expected = EMPTY _ EXPECTED ; <nl> + final String [ ] expected = CommonUtils . EMPTY _ STRING _ ARRAY ; <nl> verifyWarns ( checkConfig , getNonCompilablePath ( " InputLambda2 . java " ) , expected , 0 ) ; <nl> } <nl> <nl> @ @ - 1608 , 4 + 1583 , 111 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { <nl> final String [ ] expected = CommonUtils . EMPTY _ STRING _ ARRAY ; <nl> verify ( checkConfig , fileName , expected ) ; <nl> } <nl> + <nl> + private static final class IndentAudit implements AuditListener { <nl> + private final IndentComment [ ] comments ; <nl> + private int position ; <nl> + <nl> + private IndentAudit ( IndentComment . . . comments ) { <nl> + this . comments = comments ; <nl> + } <nl> + <nl> + @ Override <nl> + public void auditStarted ( AuditEvent event ) { <nl> + / / No code needed <nl> + } <nl> + <nl> + @ Override <nl> + public void auditFinished ( AuditEvent event ) { <nl> + / / No code needed <nl> + } <nl> + <nl> + @ Override <nl> + public void fileStarted ( AuditEvent event ) { <nl> + / / No code needed <nl> + } <nl> + <nl> + @ Override <nl> + public void fileFinished ( AuditEvent event ) { <nl> + / / No code needed <nl> + } <nl> + <nl> + @ Override <nl> + public void addError ( AuditEvent event ) { <nl> + final int line = event . getLine ( ) ; <nl> + final String message = event . getMessage ( ) ; <nl> + final IndentComment comment = comments [ position ] ; <nl> + position + + ; <nl> + <nl> + assertTrue ( <nl> + " input expected warning # " + position + " at line " + comment . getLineNumber ( ) <nl> + + " to report ' " + comment . getExpectedMessage ( ) + " ' but got instead : " <nl> + + line + " : " + message , <nl> + message . endsWith ( comment . getExpectedMessage ( ) ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void addException ( AuditEvent event , Throwable throwable ) { <nl> + / / No code needed <nl> + } <nl> + } <nl> + <nl> + private static final class IndentComment { <nl> + private final int lineNumber ; <nl> + private final int indent ; <nl> + / * * Used for when violations report nodes not first on the line . * / <nl> + private final int indentOffset ; <nl> + private final boolean expectedNonStrict ; <nl> + private final String expectedWarning ; <nl> + private final boolean warning ; <nl> + <nl> + private IndentComment ( Matcher match , int lineNumber ) { <nl> + this . lineNumber = lineNumber ; <nl> + indent = Integer . parseInt ( match . group ( 1 ) ) ; <nl> + if ( match . group ( 2 ) = = null ) { <nl> + indentOffset = 0 ; <nl> + } <nl> + else { <nl> + indentOffset = Integer . parseInt ( match . group ( 2 ) ) ; <nl> + } <nl> + expectedNonStrict = match . group ( 3 ) ! = null ; <nl> + expectedWarning = match . group ( 4 ) . replace ( " , " , " , " ) ; <nl> + warning = match . group ( 5 ) ! = null ; <nl> + } <nl> + <nl> + public String getExpectedMessage ( ) { <nl> + if ( expectedWarning . contains ( " , " ) ) { <nl> + return " incorrect indentation level " + ( indent + indentOffset ) <nl> + + " , expected level should be one of the following : " + expectedWarning <nl> + + " . " ; <nl> + } <nl> + <nl> + return " incorrect indentation level " + ( indent + indentOffset ) <nl> + + " , expected level should be " + expectedWarning + " . " ; <nl> + } <nl> + <nl> + public int getLineNumber ( ) { <nl> + return lineNumber ; <nl> + } <nl> + <nl> + public int getIndent ( ) { <nl> + return indent ; <nl> + } <nl> + <nl> + public int getIndentOffset ( ) { <nl> + return indentOffset ; <nl> + } <nl> + <nl> + public boolean isExpectedNonStrict ( ) { <nl> + return expectedNonStrict ; <nl> + } <nl> + <nl> + public String getExpectedWarning ( ) { <nl> + return expectedWarning ; <nl> + } <nl> + <nl> + public boolean isWarning ( ) { <nl> + return warning ; <nl> + } <nl> + } <nl> }

TEST DIFF:
diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsPagesTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsPagesTest . java 
 index 2dfd35b . . ca05137 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsPagesTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / internal / XdocsPagesTest . java 
 @ @ - 71 , 6 + 71 , 8 @ @ public class XdocsPagesTest { 
 private static final String LINK _ TEMPLATE = 
 " ( ? s ) . * < a href = \ " config _ \ \ w + \ \ . html # % 1 $ s \ " > % 1 $ s < / a > . * " ; 
 
 + private static final Pattern VERSION = Pattern . compile ( " \ \ d + \ \ . \ \ d + ( \ \ . \ \ d + ) ? " ) ; 
 + 
 private static final List < String > XML _ FILESET _ LIST = Arrays . asList ( 
 " TreeWalker " , 
 " name = \ " Checker \ " " , 
 @ @ - 487 , 15 + 489 , 35 @ @ public class XdocsPagesTest { 
 boolean didTokens = false ; 
 
 for ( Node row : XmlUtil . getChildrenElements ( XmlUtil . getFirstChildElement ( subSection ) ) ) { 
 + final List < Node > columns = new ArrayList < > ( XmlUtil . getChildrenElements ( row ) ) ; 
 + 
 + Assert . assertEquals ( fileName + " section ' " + sectionName 
 + + " ' should have the requested columns " , 5 , columns . size ( ) ) ; 
 + 
 if ( skip ) { 
 + Assert . assertEquals ( fileName + " section ' " + sectionName 
 + + " ' should have the specific title " , " name " , columns . get ( 0 ) 
 + . getTextContent ( ) ) ; 
 + Assert . assertEquals ( fileName + " section ' " + sectionName 
 + + " ' should have the specific title " , " description " , columns . get ( 1 ) 
 + . getTextContent ( ) ) ; 
 + Assert . assertEquals ( fileName + " section ' " + sectionName 
 + + " ' should have the specific title " , " type " , columns . get ( 2 ) 
 + . getTextContent ( ) ) ; 
 + Assert . assertEquals ( fileName + " section ' " + sectionName 
 + + " ' should have the specific title " , " default value " , columns . get ( 3 ) 
 + . getTextContent ( ) ) ; 
 + Assert . assertEquals ( fileName + " section ' " + sectionName 
 + + " ' should have the specific title " , " since " , columns . get ( 4 ) 
 + . getTextContent ( ) ) ; 
 + 
 skip = false ; 
 continue ; 
 } 
 + 
 Assert . assertFalse ( fileName + " section ' " + sectionName 
 + " ' should have token properties last " , didTokens ) ; 
 
 - final List < Node > columns = new ArrayList < > ( XmlUtil . getChildrenElements ( row ) ) ; 
 - 
 final String propertyName = columns . get ( 0 ) . getTextContent ( ) ; 
 Assert . assertTrue ( fileName + " section ' " + sectionName 
 + " ' should not contain the property : " + propertyName , 
 @ @ - 515 , 39 + 537 , 53 @ @ public class XdocsPagesTest { 
 Assert . assertFalse ( fileName + " section ' " + sectionName 
 + " ' should have javadoc token properties next to last , before tokens " , 
 didJavadocTokens ) ; 
 - Assert . assertFalse ( fileName + " section ' " + sectionName 
 - + " ' should have a description for " + propertyName , columns . get ( 1 ) 
 - . getTextContent ( ) . trim ( ) . isEmpty ( ) ) ; 
 
 - final String actualTypeName = columns . get ( 2 ) . getTextContent ( ) . replace ( " \ n " , " " ) 
 - . replace ( " \ r " , " " ) . replaceAll ( " + " , " " ) . trim ( ) ; 
 + validatePropertySectionPropertyEx ( fileName , sectionName , instance , columns , 
 + propertyName ) ; 
 + } 
 
 - Assert . assertFalse ( fileName + " section ' " + sectionName 
 - + " ' should have a type for " + propertyName , actualTypeName . isEmpty ( ) ) ; 
 + Assert . assertFalse ( fileName + " section ' " + sectionName 
 + + " ' should have a version for " + propertyName , columns . get ( 4 ) 
 + . getTextContent ( ) . trim ( ) . isEmpty ( ) ) ; 
 + Assert . assertTrue ( fileName + " section ' " + sectionName 
 + + " ' should have a valid version for " + propertyName , 
 + VERSION . matcher ( columns . get ( 4 ) . getTextContent ( ) . trim ( ) ) . matches ( ) ) ; 
 + } 
 + } 
 
 - final PropertyDescriptor descriptor = PropertyUtils . getPropertyDescriptor ( instance , 
 - propertyName ) ; 
 - final Class < ? > clss = descriptor . getPropertyType ( ) ; 
 - final String expectedTypeName = 
 - getModulePropertyExpectedTypeName ( clss , instance , propertyName ) ; 
 - 
 - if ( expectedTypeName ! = null ) { 
 - final String expectedValue = getModulePropertyExpectedValue ( clss , instance , 
 - propertyName ) ; 
 - 
 - Assert . assertEquals ( fileName + " section ' " + sectionName 
 - + " ' should have the type for " + propertyName , expectedTypeName , 
 - actualTypeName ) ; 
 - 
 - if ( expectedValue ! = null ) { 
 - final String actualValue = columns . get ( 3 ) . getTextContent ( ) . replace ( " \ n " , " " ) 
 - . replace ( " \ r " , " " ) . replaceAll ( " + " , " " ) . trim ( ) ; 
 - 
 - Assert . assertEquals ( fileName + " section ' " + sectionName 
 - + " ' should have the value for " + propertyName , expectedValue , 
 - actualValue ) ; 
 - } 
 - } 
 + private static void validatePropertySectionPropertyEx ( String fileName , String sectionName , 
 + Object instance , List < Node > columns , String propertyName ) throws Exception { 
 + Assert . assertFalse ( fileName + " section ' " + sectionName 
 + + " ' should have a description for " + propertyName , columns . get ( 1 ) 
 + . getTextContent ( ) . trim ( ) . isEmpty ( ) ) ; 
 + 
 + final String actualTypeName = columns . get ( 2 ) . getTextContent ( ) . replace ( " \ n " , " " ) 
 + . replace ( " \ r " , " " ) . replaceAll ( " + " , " " ) . trim ( ) ; 
 + 
 + Assert . assertFalse ( fileName + " section ' " + sectionName + " ' should have a type for " 
 + + propertyName , actualTypeName . isEmpty ( ) ) ; 
 + 
 + final PropertyDescriptor descriptor = PropertyUtils . getPropertyDescriptor ( instance , 
 + propertyName ) ; 
 + final Class < ? > clss = descriptor . getPropertyType ( ) ; 
 + final String expectedTypeName = getModulePropertyExpectedTypeName ( clss , instance , 
 + propertyName ) ; 
 + 
 + if ( expectedTypeName ! = null ) { 
 + final String expectedValue = getModulePropertyExpectedValue ( clss , instance , 
 + propertyName ) ; 
 + 
 + Assert . assertEquals ( fileName + " section ' " + sectionName 
 + + " ' should have the type for " + propertyName , expectedTypeName , 
 + actualTypeName ) ; 
 + 
 + if ( expectedValue ! = null ) { 
 + final String actualValue = columns . get ( 3 ) . getTextContent ( ) . replace ( " \ n " , " " ) 
 + . replace ( " \ r " , " " ) . replaceAll ( " + " , " " ) . trim ( ) ; 
 + 
 + Assert . assertEquals ( fileName + " section ' " + sectionName 
 + + " ' should have the value for " + propertyName , expectedValue , 
 + actualValue ) ; 
 } 
 } 
 }

NEAREST DIFF:
diff - - git a / config / suppressions . xml b / config / suppressions . xml 
 index 0ff8df2 . . 895057b 100644 
 - - - a / config / suppressions . xml 
 + + + b / config / suppressions . xml 
 @ @ - 91 , 6 + 91 , 7 @ @ 
 < suppress checks = " AvoidStaticImport " files = " . * [ \ \ / ] src [ \ \ / ] ( test | it ) [ \ \ / ] " / > 
 < suppress checks = " MethodCount " files = " [ \ \ / ] ImportOrderCheckTest . java $ " / > 
 < suppress checks = " MethodCount " files = " [ \ \ / ] IndentationCheckTest . java $ " / > 
 + < suppress checks = " ClassDataAbstractionCoupling " files = " [ \ \ / ] IndentationCheckTest . java $ " / > 
 < suppress checks = " MethodCount " files = " [ \ \ / ] JavadocMethodCheckTest . java $ " / > 
 < suppress checks = " MethodCount " files = " [ \ \ / ] MainTest . java $ " / > 
 < suppress checks = " EqualsAvoidNull " files = " [ \ \ / ] Int . * FilterTest . java $ " / > 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java 
 index f7cafcc . . dccc2da 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / indentation / IndentationCheckTest . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import static com . puppycrawl . tools . checkstyle . checks . indentation . IndentationChec 
 import static com . puppycrawl . tools . checkstyle . checks . indentation . IndentationCheck . MSG _ ERROR _ MULTI ; 
 import static org . junit . Assert . assertArrayEquals ; 
 import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 
 import java . io . BufferedReader ; 
 import java . io . File ; 
 @ @ - 42 , 7 + 43 , 10 @ @ import java . util . regex . Pattern ; 
 import org . junit . Test ; 
 
 import com . puppycrawl . tools . checkstyle . BaseCheckTestSupport ; 
 + import com . puppycrawl . tools . checkstyle . Checker ; 
 import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; 
 + import com . puppycrawl . tools . checkstyle . api . AuditEvent ; 
 + import com . puppycrawl . tools . checkstyle . api . AuditListener ; 
 import com . puppycrawl . tools . checkstyle . api . Configuration ; 
 import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; 
 
 @ @ - 52 , 57 + 56 , 42 @ @ import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; 
 * / 
 public class IndentationCheckTest extends BaseCheckTestSupport { 
 private static final Pattern LINE _ WITH _ COMMENT _ REGEX = 
 - Pattern . compile ( " . * ? ( / / indent : ( \ \ d + ) " 
 - + " exp : ( ( > = \ \ d + ) | ( \ \ d + ( , \ \ d + ) * ? ) ) ( warn ) ? ) $ " ) ; 
 + Pattern . compile ( " . * ? / / indent : ( \ \ d + ) ( ? : ioffset : ( \ \ d + ) ) ? " 
 + + " exp : ( > = ) ? ( \ \ d + ( ? : , \ \ d + ) * ? ) ( warn ) ? $ " ) ; 
 
 - private static final Pattern GET _ INDENT _ FROM _ COMMENT _ REGEX = 
 - Pattern . compile ( " / / indent : ( \ \ d + ) . * ? " ) ; 
 - 
 - private static final Pattern MULTILEVEL _ COMMENT _ REGEX = 
 - Pattern . compile ( " / / indent : \ \ d + exp : ( \ \ d + ( , \ \ d + ) + ? ) ( warn ) ? " ) ; 
 - 
 - private static final Pattern SINGLE _ LEVEL _ COMMENT _ REGEX = 
 - Pattern . compile ( " / / indent : \ \ d + exp : ( \ \ d + ) ( warn ) ? " ) ; 
 - 
 - private static final Pattern NON _ STRICT _ LEVEL _ COMMENT _ REGEX = 
 - Pattern . compile ( " / / indent : \ \ d + exp : > = ( \ \ d + ) ( warn ) ? " ) ; 
 - 
 - private static final String [ ] EMPTY _ EXPECTED = { } ; 
 - 
 - private static Integer [ ] getLinesWithWarnAndCheckComments ( String aFileName , 
 + private static IndentComment [ ] getLinesWithWarnAndCheckComments ( String aFileName , 
 final int tabWidth ) 
 throws IOException { 
 - final List < Integer > result = new ArrayList < > ( ) ; 
 + final List < IndentComment > result = new ArrayList < > ( ) ; 
 try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( 
 new FileInputStream ( aFileName ) , StandardCharsets . UTF _ 8 ) ) ) { 
 int lineNumber = 1 ; 
 for ( String line = br . readLine ( ) ; line ! = null ; line = br . readLine ( ) ) { 
 final Matcher match = LINE _ WITH _ COMMENT _ REGEX . matcher ( line ) ; 
 if ( match . matches ( ) ) { 
 - final String comment = match . group ( 1 ) ; 
 - final int indentInComment = getIndentFromComment ( comment ) ; 
 + final IndentComment warn = new IndentComment ( match , lineNumber ) ; 
 final int actualIndent = getLineStart ( line , tabWidth ) ; 
 
 - if ( actualIndent ! = indentInComment ) { 
 + if ( actualIndent ! = warn . getIndent ( ) ) { 
 throw new IllegalStateException ( String . format ( Locale . ROOT , 
 - " File \ " % 1 $ s \ " has incorrect indentation in comment . " 
 + " File \ " % 1 $ s \ " has incorrect indentation in comment . " 
 + " Line % 2 $ d : comment : % 3 $ d , actual : % 4 $ d . " , 
 aFileName , 
 lineNumber , 
 - indentInComment , 
 + warn . getIndent ( ) , 
 actualIndent ) ) ; 
 } 
 
 - if ( isWarnComment ( comment ) ) { 
 - result . add ( lineNumber ) ; 
 - } 
 - 
 - if ( ! isCommentConsistent ( comment ) ) { 
 + if ( ! isCommentConsistent ( warn ) ) { 
 throw new IllegalStateException ( String . format ( Locale . ROOT , 
 " File \ " % 1 $ s \ " has inconsistent comment on line % 2 $ d " , 
 aFileName , 
 lineNumber ) ) ; 
 } 
 + 
 + if ( warn . isWarning ( ) ) { 
 + result . add ( warn ) ; 
 + } 
 } 
 else if ( ! line . isEmpty ( ) ) { 
 throw new IllegalStateException ( String . format ( Locale . ROOT , 
 @ @ - 114 , 55 + 103 , 34 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { 
 lineNumber + + ; 
 } 
 } 
 - return result . toArray ( new Integer [ result . size ( ) ] ) ; 
 + return result . toArray ( new IndentComment [ result . size ( ) ] ) ; 
 } 
 
 - private static int getIndentFromComment ( String comment ) { 
 - final Matcher match = GET _ INDENT _ FROM _ COMMENT _ REGEX . matcher ( comment ) ; 
 - match . matches ( ) ; 
 - return Integer . parseInt ( match . group ( 1 ) ) ; 
 - } 
 - 
 - private static boolean isWarnComment ( String comment ) { 
 - return comment . endsWith ( " warn " ) ; 
 - } 
 + private static boolean isCommentConsistent ( IndentComment comment ) { 
 + final String [ ] levels = comment . getExpectedWarning ( ) . split ( " , " ) ; 
 + final int indent = comment . getIndent ( ) + comment . getIndentOffset ( ) ; 
 
 - private static boolean isCommentConsistent ( String comment ) { 
 - final int indentInComment = getIndentFromComment ( comment ) ; 
 - final boolean isWarnComment = isWarnComment ( comment ) ; 
 - 
 - final Matcher multilevelMatch = MULTILEVEL _ COMMENT _ REGEX . matcher ( comment ) ; 
 - if ( multilevelMatch . matches ( ) ) { 
 - final String [ ] levels = multilevelMatch . group ( 1 ) . split ( " , " ) ; 
 - final String indentInCommentStr = String . valueOf ( indentInComment ) ; 
 + if ( levels . length > 1 ) { 
 + / / multi 
 final boolean containsActualLevel = 
 - Arrays . asList ( levels ) . contains ( indentInCommentStr ) ; 
 + Arrays . asList ( levels ) . contains ( String . valueOf ( indent ) ) ; 
 
 - return containsActualLevel & & ! isWarnComment 
 - | | ! containsActualLevel & & isWarnComment ; 
 + return containsActualLevel ! = comment . isWarning ( ) ; 
 } 
 + else { 
 + final int expectedWarning = Integer . parseInt ( comment . getExpectedWarning ( ) ) ; 
 
 - final Matcher singleLevelMatch = SINGLE _ LEVEL _ COMMENT _ REGEX . matcher ( comment ) ; 
 - if ( singleLevelMatch . matches ( ) ) { 
 - final int expectedLevel = Integer . parseInt ( singleLevelMatch . group ( 1 ) ) ; 
 - return isSingleLevelCommentConsistent ( indentInComment , isWarnComment , expectedLevel ) ; 
 - } 
 - 
 - final Matcher nonStrictLevelMatch = NON _ STRICT _ LEVEL _ COMMENT _ REGEX . matcher ( comment ) ; 
 - if ( nonStrictLevelMatch . matches ( ) ) { 
 - final int expectedMinimalIndent = Integer . parseInt ( nonStrictLevelMatch . group ( 1 ) ) ; 
 - 
 - return indentInComment > = expectedMinimalIndent & & ! isWarnComment 
 - | | indentInComment < expectedMinimalIndent & & isWarnComment ; 
 + if ( comment . isExpectedNonStrict ( ) ) { 
 + / / non - strict 
 + final boolean test = indent > = expectedWarning ; 
 + return test ! = comment . isWarning ( ) ; 
 + } 
 + else { 
 + / / single 
 + final boolean test = expectedWarning = = indent ; 
 + return test ! = comment . isWarning ( ) ; 
 + } 
 } 
 - 
 - throw new IllegalStateException ( " Comments are not consistent " ) ; 
 - } 
 - 
 - private static boolean isSingleLevelCommentConsistent ( int indentInComment , 
 - boolean isWarnComment , int expectedLevel ) { 
 - return expectedLevel = = indentInComment & & ! isWarnComment 
 - | | expectedLevel ! = indentInComment & & isWarnComment ; 
 } 
 
 private static int getLineStart ( String line , final int tabWidth ) { 
 @ @ - 175 , 22 + 143 , 29 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { 
 } 
 
 private void verifyWarns ( Configuration config , String filePath , 
 + String . . . expected ) 
 + throws Exception { 
 + verifyWarns ( config , filePath , expected , 0 ) ; 
 + } 
 + 
 + private void verifyWarns ( Configuration config , String filePath , 
 String [ ] expected , int warnCountCorrection ) 
 throws Exception { 
 final int tabWidth = Integer . parseInt ( config . getAttribute ( " tabWidth " ) ) ; 
 - final Integer [ ] linesWithWarn = 
 + final IndentComment [ ] linesWithWarn = 
 getLinesWithWarnAndCheckComments ( filePath , tabWidth ) ; 
 assertEquals ( " Expected warning count in UT does not match warn " 
 + " comment count in input file " , linesWithWarn . length 
 + warnCountCorrection , 
 expected . length ) ; 
 - verify ( config , filePath , expected ) ; 
 + verify ( config , filePath , expected , linesWithWarn ) ; 
 } 
 
 - private void verifyWarns ( Configuration config , String filePath , 
 - String . . . expected ) 
 - throws Exception { 
 - verifyWarns ( config , filePath , expected , 0 ) ; 
 + private void verify ( Configuration config , String filePath , String [ ] expected , 
 + final IndentComment . . . linesWithWarn ) throws Exception { 
 + final Checker checker = createChecker ( config ) ; 
 + checker . addListener ( new IndentAudit ( linesWithWarn ) ) ; 
 + verify ( checker , new File [ ] { new File ( filePath ) } , filePath , expected ) ; 
 } 
 
 @ Override 
 @ @ - 1587 , 7 + 1562 , 7 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { 
 checkConfig . addAttribute ( " tabWidth " , " 4 " ) ; 
 checkConfig . addAttribute ( " basicOffset " , " 4 " ) ; 
 checkConfig . addAttribute ( " lineWrappingIndentation " , " 8 " ) ; 
 - final String [ ] expected = EMPTY _ EXPECTED ; 
 + final String [ ] expected = CommonUtils . EMPTY _ STRING _ ARRAY ; 
 verifyWarns ( checkConfig , getNonCompilablePath ( " InputLambda2 . java " ) , expected , 0 ) ; 
 } 
 
 @ @ - 1608 , 4 + 1583 , 111 @ @ public class IndentationCheckTest extends BaseCheckTestSupport { 
 final String [ ] expected = CommonUtils . EMPTY _ STRING _ ARRAY ; 
 verify ( checkConfig , fileName , expected ) ; 
 } 
 + 
 + private static final class IndentAudit implements AuditListener { 
 + private final IndentComment [ ] comments ; 
 + private int position ; 
 + 
 + private IndentAudit ( IndentComment . . . comments ) { 
 + this . comments = comments ; 
 + } 
 + 
 + @ Override 
 + public void auditStarted ( AuditEvent event ) { 
 + / / No code needed 
 + } 
 + 
 + @ Override 
 + public void auditFinished ( AuditEvent event ) { 
 + / / No code needed 
 + } 
 + 
 + @ Override 
 + public void fileStarted ( AuditEvent event ) { 
 + / / No code needed 
 + } 
 + 
 + @ Override 
 + public void fileFinished ( AuditEvent event ) { 
 + / / No code needed 
 + } 
 + 
 + @ Override 
 + public void addError ( AuditEvent event ) { 
 + final int line = event . getLine ( ) ; 
 + final String message = event . getMessage ( ) ; 
 + final IndentComment comment = comments [ position ] ; 
 + position + + ; 
 + 
 + assertTrue ( 
 + " input expected warning # " + position + " at line " + comment . getLineNumber ( ) 
 + + " to report ' " + comment . getExpectedMessage ( ) + " ' but got instead : " 
 + + line + " : " + message , 
 + message . endsWith ( comment . getExpectedMessage ( ) ) ) ; 
 + } 
 + 
 + @ Override 
 + public void addException ( AuditEvent event , Throwable throwable ) { 
 + / / No code needed 
 + } 
 + } 
 + 
 + private static final class IndentComment { 
 + private final int lineNumber ; 
 + private final int indent ; 
 + / * * Used for when violations report nodes not first on the line . * / 
 + private final int indentOffset ; 
 + private final boolean expectedNonStrict ; 
 + private final String expectedWarning ; 
 + private final boolean warning ; 
 + 
 + private IndentComment ( Matcher match , int lineNumber ) { 
 + this . lineNumber = lineNumber ; 
 + indent = Integer . parseInt ( match . group ( 1 ) ) ; 
 + if ( match . group ( 2 ) = = null ) { 
 + indentOffset = 0 ; 
 + } 
 + else { 
 + indentOffset = Integer . parseInt ( match . group ( 2 ) ) ; 
 + } 
 + expectedNonStrict = match . group ( 3 ) ! = null ; 
 + expectedWarning = match . group ( 4 ) . replace ( " , " , " , " ) ; 
 + warning = match . group ( 5 ) ! = null ; 
 + } 
 + 
 + public String getExpectedMessage ( ) { 
 + if ( expectedWarning . contains ( " , " ) ) { 
 + return " incorrect indentation level " + ( indent + indentOffset ) 
 + + " , expected level should be one of the following : " + expectedWarning 
 + + " . " ; 
 + } 
 + 
 + return " incorrect indentation level " + ( indent + indentOffset ) 
 + + " , expected level should be " + expectedWarning + " . " ; 
 + } 
 + 
 + public int getLineNumber ( ) { 
 + return lineNumber ; 
 + } 
 + 
 + public int getIndent ( ) { 
 + return indent ; 
 + } 
 + 
 + public int getIndentOffset ( ) { 
 + return indentOffset ; 
 + } 
 + 
 + public boolean isExpectedNonStrict ( ) { 
 + return expectedNonStrict ; 
 + } 
 + 
 + public String getExpectedWarning ( ) { 
 + return expectedWarning ; 
 + } 
 + 
 + public boolean isWarning ( ) { 
 + return warning ; 
 + } 
 + } 
 }
