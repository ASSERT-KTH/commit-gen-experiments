BLEU SCORE: 0.10786826322527471

TEST MSG: Issue # 2239 : Extend RequireThis check message
GENERATED MSG: Issue # 2451 : removed excess hierarchy from RequireThisCheck

TEST DIFF (one line): diff - - git a / config / findbugs - exclude . xml b / config / findbugs - exclude . xml <nl> index dcb8c08 . . 1ed5459 100644 <nl> - - - a / config / findbugs - exclude . xml <nl> + + + b / config / findbugs - exclude . xml <nl> @ @ - 56 , 6 + 56 , 16 @ @ <nl> < Bug pattern = " BC _ UNCONFIRMED _ CAST " / > <nl> < / Match > <nl> < Match > <nl> + < ! - - The structure of frames relies on the AST structure which relies on correct / compilable <nl> + java files . It is ok to have direct casts to subtypes there . Any problems at runtime do <nl> + mean serious problems in the algorithm or AST generation . - - > <nl> + < Class name = " com . puppycrawl . tools . checkstyle . checks . coding . RequireThisCheck " / > <nl> + < Or > <nl> + < Bug pattern = " BC _ UNCONFIRMED _ CAST " / > <nl> + < Bug pattern = " BC _ UNCONFIRMED _ CAST _ OF _ RETURN _ VALUE " / > <nl> + < / Or > <nl> + < / Match > <nl> + < Match > <nl> < ! - - till SonarQube update Checkstyle version . Support both getFileName ( ) and getFilename ( ) - - > <nl> < and > <nl> < Class name = " com . puppycrawl . tools . checkstyle . api . FileContents " / > <nl> diff - - git a / config / pmd . xml b / config / pmd . xml <nl> index cb60185 . . 39b446a 100644 <nl> - - - a / config / pmd . xml <nl> + + + b / config / pmd . xml <nl> @ @ - 44 , 6 + 44 , 8 @ @ <nl> < rule ref = " rulesets / java / codesize . xml / TooManyMethods " > <nl> < properties > <nl> < property name = " maxmethods " value = " 20 " / > <nl> + < ! - - Reducing the number of methods requires making excess hierarchy or duplicating code , or making existing methods too complex . - - > <nl> + < property name = " violationSuppressXPath " value = " / / ClassOrInterfaceDeclaration [ @ Image = ' RequireThisCheck ' ] " / > <nl> < / properties > <nl> < / rule > <nl> < rule ref = " rulesets / java / codesize . xml / ExcessiveClassLength " > <nl> diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheck . java <nl> index 3b5d6ce . . 3da0db3 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheck . java <nl> @ @ - 53 , 13 + 53 , 11 @ @ import com . puppycrawl . tools . checkstyle . utils . ScopeUtils ; <nl> * & lt ; / module & gt ; <nl> * < / pre > <nl> * <nl> - * < p > Limitations : I ' m not currently doing anything about static variables <nl> + * < p > Limitations : Nothing is currently done about static variables <nl> * or catch - blocks . Static methods invoked on a class name seem to be OK ; <nl> * both the class name and the method name have a DOT parent . <nl> * Non - static methods invoked on either this or a variable name seem to be <nl> * OK , likewise . < / p > <nl> - * < p > Much of the code for this check was cribbed from Rick Giles ' s <nl> - * { @ code HiddenFieldCheck } . < / p > <nl> * <nl> * @ author Stephen Bloch <nl> * @ author o _ sukhodolsky <nl> @ @ - 77 , 7 + 75 , 6 @ @ public class RequireThisCheck extends Check { <nl> * file . <nl> * / <nl> public static final String MSG _ VARIABLE = " require . this . variable " ; <nl> - <nl> / * * <nl> * Set of all declaration tokens . <nl> * / <nl> @ @ - 95 , 12 + 92 , 12 @ @ public class RequireThisCheck extends Check { <nl> / * * <nl> * Tree of all the parsed frames . <nl> * / <nl> - private Map < DetailAST , LexicalFrame > frames ; <nl> + private Map < DetailAST , AbstractFrame > frames ; <nl> <nl> / * * <nl> * Frame for the currently processed AST . <nl> * / <nl> - private LexicalFrame current ; <nl> + private AbstractFrame current ; <nl> <nl> / * * Whether we should check fields usage . * / <nl> private boolean checkFields = true ; <nl> @ @ - 148 , 8 + 145 , 7 @ @ public class RequireThisCheck extends Check { <nl> <nl> @ Override <nl> public void beginTree ( DetailAST rootAST ) { <nl> - final Deque < LexicalFrame > frameStack = Lists . newLinkedList ( ) ; <nl> - frameStack . add ( new GlobalFrame ( ) ) ; <nl> + final Deque < AbstractFrame > frameStack = Lists . newLinkedList ( ) ; <nl> <nl> frames = Maps . newHashMap ( ) ; <nl> <nl> @ @ - 204 , 37 + 200 , 60 @ @ public class RequireThisCheck extends Check { <nl> break ; <nl> case TokenTypes . METHOD _ CALL : <nl> / / let ' s check method calls <nl> - if ( checkMethods & & isClassMethod ( ast ) ) { <nl> - log ( ast , MSG _ METHOD , ast . getText ( ) ) ; <nl> + if ( checkMethods ) { <nl> + final AbstractFrame frame = checkMethod ( ast ) ; <nl> + if ( frame ! = null ) { <nl> + logViolation ( MSG _ METHOD , ast , frame ) ; <nl> + } <nl> } <nl> break ; <nl> default : <nl> if ( checkFields ) { <nl> - processField ( ast , parentType ) ; <nl> + final AbstractFrame frame = processField ( ast , parentType ) ; <nl> + if ( frame ! = null ) { <nl> + logViolation ( MSG _ VARIABLE , ast , frame ) ; <nl> + } <nl> } <nl> break ; <nl> } <nl> } <nl> <nl> / * * <nl> + * Helper method to log a LocalizedMessage . <nl> + * @ param ast a node to get line id column numbers associated with the message . <nl> + * @ param msgKey key to locale message format . <nl> + * @ param frame the frame , where the violation is found . <nl> + * / <nl> + private void logViolation ( String msgKey , DetailAST ast , AbstractFrame frame ) { <nl> + if ( frame . getFrameName ( ) . equals ( getNearestClassFrameName ( ) ) ) { <nl> + log ( ast , msgKey , ast . getText ( ) , " " ) ; <nl> + } <nl> + else { <nl> + log ( ast , msgKey , ast . getText ( ) , frame . getFrameName ( ) + ' . ' ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> * Process validation of Field . <nl> * @ param ast field definition ast token <nl> * @ param parentType type of the parent <nl> + * @ return frame , where the field is declared , if the violation is found and null otherwise <nl> * / <nl> - private void processField ( DetailAST ast , int parentType ) { <nl> + private AbstractFrame processField ( DetailAST ast , int parentType ) { <nl> final boolean importOrPackage = ScopeUtils . getSurroundingScope ( ast ) = = null ; <nl> final boolean methodNameInMethodCall = parentType = = TokenTypes . DOT <nl> & & ast . getPreviousSibling ( ) ! = null ; <nl> final boolean typeName = parentType = = TokenTypes . TYPE <nl> | | parentType = = TokenTypes . LITERAL _ NEW ; <nl> + AbstractFrame frame = null ; <nl> <nl> if ( ! importOrPackage <nl> & & ! methodNameInMethodCall <nl> & & ! typeName <nl> - & & ! isDeclarationToken ( parentType ) <nl> - & & isClassField ( ast ) ) { <nl> - log ( ast , MSG _ VARIABLE , ast . getText ( ) ) ; <nl> + & & ! isDeclarationToken ( parentType ) ) { <nl> + frame = checkField ( ast ) ; <nl> } <nl> + return frame ; <nl> } <nl> <nl> / * * <nl> @ @ - 243 , 9 + 262 , 9 @ @ public class RequireThisCheck extends Check { <nl> * @ param frameStack Stack containing the FrameTree being built <nl> * @ param ast AST to parse <nl> * / <nl> - private static void collectDeclarations ( Deque < LexicalFrame > frameStack , <nl> + private static void collectDeclarations ( Deque < AbstractFrame > frameStack , <nl> DetailAST ast ) { <nl> - final LexicalFrame frame = frameStack . peek ( ) ; <nl> + final AbstractFrame frame = frameStack . peek ( ) ; <nl> switch ( ast . getType ( ) ) { <nl> case TokenTypes . VARIABLE _ DEF : <nl> collectVariableDeclarations ( ast , frame ) ; <nl> @ @ - 259 , 15 + 278 , 14 @ @ public class RequireThisCheck extends Check { <nl> case TokenTypes . ENUM _ DEF : <nl> case TokenTypes . ANNOTATION _ DEF : <nl> final DetailAST classIdent = ast . findFirstToken ( TokenTypes . IDENT ) ; <nl> - frame . addIdent ( classIdent ) ; <nl> - frameStack . addFirst ( new ClassFrame ( frame ) ) ; <nl> + frameStack . addFirst ( new ClassFrame ( frame , classIdent . getText ( ) ) ) ; <nl> break ; <nl> case TokenTypes . SLIST : <nl> frameStack . addFirst ( new BlockFrame ( frame ) ) ; <nl> break ; <nl> case TokenTypes . METHOD _ DEF : <nl> final DetailAST ident = ast . findFirstToken ( TokenTypes . IDENT ) ; <nl> - if ( frame instanceof ClassFrame ) { <nl> + if ( frame . getType ( ) = = FrameType . CLASS _ FRAME ) { <nl> final DetailAST mods = <nl> ast . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> if ( mods . branchContains ( TokenTypes . LITERAL _ STATIC ) ) { <nl> @ @ - 292 , 10 + 310 , 9 @ @ public class RequireThisCheck extends Check { <nl> * @ param ast variable token <nl> * @ param frame current frame <nl> * / <nl> - private static void collectVariableDeclarations ( DetailAST ast , LexicalFrame frame ) { <nl> - final DetailAST ident = <nl> - ast . findFirstToken ( TokenTypes . IDENT ) ; <nl> - if ( frame instanceof ClassFrame ) { <nl> + private static void collectVariableDeclarations ( DetailAST ast , AbstractFrame frame ) { <nl> + final DetailAST ident = ast . findFirstToken ( TokenTypes . IDENT ) ; <nl> + if ( frame . getType ( ) = = FrameType . CLASS _ FRAME ) { <nl> final DetailAST mods = <nl> ast . findFirstToken ( TokenTypes . MODIFIERS ) ; <nl> if ( ScopeUtils . isInInterfaceBlock ( ast ) <nl> @ @ - 317 , 7 + 334 , 7 @ @ public class RequireThisCheck extends Check { <nl> * @ param frameStack Stack containing the FrameTree being built <nl> * @ param ast AST that was parsed <nl> * / <nl> - private void endCollectingDeclarations ( Queue < LexicalFrame > frameStack , <nl> + private void endCollectingDeclarations ( Queue < AbstractFrame > frameStack , <nl> DetailAST ast ) { <nl> switch ( ast . getType ( ) ) { <nl> case TokenTypes . CLASS _ DEF : <nl> @ @ - 336 , 33 + 353 , 40 @ @ public class RequireThisCheck extends Check { <nl> <nl> / * * <nl> * Check if given name is a name for class field in current environment . <nl> - * @ param ident an IDENT ast to check <nl> - * @ return true is the given name is name of member . <nl> + * @ param ast an IDENT ast to check <nl> + * @ return frame , where the field is declared , if the violation is found and null otherwise <nl> * / <nl> - private boolean isClassField ( DetailAST ident ) { <nl> - final LexicalFrame frame = findFrame ( ident , false ) ; <nl> - return frame instanceof ClassFrame <nl> - & & ( ( ClassFrame ) frame ) . hasInstanceMember ( ident ) ; <nl> + private AbstractFrame checkField ( DetailAST ast ) { <nl> + final AbstractFrame frame = findFrame ( ast , false ) ; <nl> + if ( frame ! = null <nl> + & & frame . getType ( ) = = FrameType . CLASS _ FRAME <nl> + & & ( ( ClassFrame ) frame ) . hasInstanceMember ( ast ) ) { <nl> + return frame ; <nl> + } <nl> + return null ; <nl> } <nl> <nl> / * * <nl> * Check if given name is a name for class method in current environment . <nl> - * @ param ident the IDENT ast of the name to check <nl> - * @ return true is the given name is name of method . <nl> + * @ param ast the IDENT ast of the name to check <nl> + * @ return frame , where the method is declared , if the violation is found and null otherwise <nl> * / <nl> - private boolean isClassMethod ( DetailAST ident ) { <nl> - final LexicalFrame frame = findFrame ( ident , true ) ; <nl> - return frame instanceof ClassFrame <nl> - & & ( ( ClassFrame ) frame ) . hasInstanceMethod ( ident ) ; <nl> + private AbstractFrame checkMethod ( DetailAST ast ) { <nl> + final AbstractFrame frame = findFrame ( ast , true ) ; <nl> + if ( frame ! = null <nl> + & & ( ( ClassFrame ) frame ) . hasInstanceMethod ( ast ) ) { <nl> + return frame ; <nl> + } <nl> + return null ; <nl> } <nl> <nl> / * * <nl> * Find frame containing declaration . <nl> * @ param name IDENT ast of the declaration to find . <nl> * @ param lookForMethod whether we are looking for a method name . <nl> - * @ return LexicalFrame containing declaration or null . <nl> + * @ return AbstractFrame containing declaration or null . <nl> * / <nl> - private LexicalFrame findFrame ( DetailAST name , boolean lookForMethod ) { <nl> + private AbstractFrame findFrame ( DetailAST name , boolean lookForMethod ) { <nl> if ( current = = null ) { <nl> return null ; <nl> } <nl> @ @ - 381 , 29 + 405 , 64 @ @ public class RequireThisCheck extends Check { <nl> } <nl> <nl> / * * <nl> + * Get the name of the nearest parent ClassFrame . <nl> + * @ return the name of the nearest parent ClassFrame . <nl> + * / <nl> + private String getNearestClassFrameName ( ) { <nl> + AbstractFrame frame = current ; <nl> + while ( frame . getType ( ) ! = FrameType . CLASS _ FRAME ) { <nl> + frame = frame . getParent ( ) ; <nl> + } <nl> + return frame . getFrameName ( ) ; <nl> + } <nl> + <nl> + / * * An AbstractFrame type . * / <nl> + private enum FrameType { <nl> + / * * Class frame type . * / <nl> + CLASS _ FRAME , <nl> + / * * Method frame type . * / <nl> + METHOD _ FRAME , <nl> + / * * Block frame type . * / <nl> + BLOCK _ FRAME , <nl> + } <nl> + <nl> + / * * <nl> * A declaration frame . <nl> * @ author Stephen Bloch <nl> * / <nl> - private static class LexicalFrame { <nl> + private abstract static class AbstractFrame { <nl> / * * Set of name of variables declared in this frame . * / <nl> private final Set < DetailAST > varIdents ; <nl> <nl> / * * <nl> * Parent frame . <nl> * / <nl> - private final LexicalFrame parent ; <nl> + private final AbstractFrame parent ; <nl> + <nl> + / * * <nl> + * Frame name . <nl> + * / <nl> + private final String frameName ; <nl> <nl> / * * <nl> * Constructor - - invokable only via super ( ) from subclasses . <nl> * <nl> * @ param parent parent frame <nl> + * @ param frameName frame name <nl> * / <nl> - protected LexicalFrame ( LexicalFrame parent ) { <nl> + protected AbstractFrame ( AbstractFrame parent , String frameName ) { <nl> this . parent = parent ; <nl> + this . frameName = frameName ; <nl> varIdents = Sets . newHashSet ( ) ; <nl> } <nl> <nl> / * * <nl> + * Get the type of the frame . <nl> + * @ return a FrameType . <nl> + * / <nl> + protected abstract FrameType getType ( ) ; <nl> + <nl> + / * * <nl> * Add a name to the frame . <nl> * @ param identToAdd the name we ' re adding <nl> * / <nl> @ @ - 411 , 10 + 470 , 14 @ @ public class RequireThisCheck extends Check { <nl> varIdents . add ( identToAdd ) ; <nl> } <nl> <nl> - protected LexicalFrame getParent ( ) { <nl> + protected AbstractFrame getParent ( ) { <nl> return parent ; <nl> } <nl> <nl> + protected String getFrameName ( ) { <nl> + return frameName ; <nl> + } <nl> + <nl> / * * Check whether the frame contains a given name . <nl> * @ param nameToFind the IDENT ast of the name we ' re looking for <nl> * @ return whether it was found <nl> @ @ - 428 , 14 + 491 , 14 @ @ public class RequireThisCheck extends Check { <nl> * @ param lookForMethod whether we are looking for a method name . <nl> * @ return whether it was found . <nl> * / <nl> - protected LexicalFrame getIfContains ( DetailAST nameToFind , boolean lookForMethod ) { <nl> - LexicalFrame frame = null ; <nl> + protected AbstractFrame getIfContains ( DetailAST nameToFind , boolean lookForMethod ) { <nl> + AbstractFrame frame ; <nl> <nl> if ( ! lookForMethod <nl> & & contains ( nameToFind ) ) { <nl> frame = this ; <nl> } <nl> - else if ( parent ! = null ) { <nl> + else { <nl> frame = parent . getIfContains ( nameToFind , lookForMethod ) ; <nl> } <nl> return frame ; <nl> @ @ - 490 , 40 + 553 , 29 @ @ public class RequireThisCheck extends Check { <nl> } <nl> <nl> / * * <nl> - * The global frame ; should hold only class names . <nl> - * @ author Stephen Bloch <nl> - * / <nl> - private static class GlobalFrame extends LexicalFrame { <nl> - <nl> - / * * <nl> - * Constructor for the root of the FrameTree . <nl> - * / <nl> - protected GlobalFrame ( ) { <nl> - super ( null ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> * A frame initiated at method definition ; holds parameter names . <nl> * @ author Stephen Bloch <nl> * / <nl> - private static class MethodFrame extends LexicalFrame { <nl> + private static class MethodFrame extends AbstractFrame { <nl> / * * <nl> * Creates method frame . <nl> * @ param parent parent frame <nl> * / <nl> - protected MethodFrame ( LexicalFrame parent ) { <nl> - super ( parent ) ; <nl> + protected MethodFrame ( AbstractFrame parent ) { <nl> + super ( parent , null ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected FrameType getType ( ) { <nl> + return FrameType . METHOD _ FRAME ; <nl> } <nl> } <nl> <nl> / * * <nl> - * A frame initiated at class definition ; holds instance variable <nl> - * names . For the present , I ' m not worried about other class names , <nl> - * method names , etc . <nl> + * A frame initiated at class < enum or interface definition ; holds instance variable names . <nl> * @ author Stephen Bloch <nl> * / <nl> - private static class ClassFrame extends LexicalFrame { <nl> + private static class ClassFrame extends AbstractFrame { <nl> / * * Set of idents of instance members declared in this frame . * / <nl> private final Set < DetailAST > instanceMembers ; <nl> / * * Set of idents of instance methods declared in this frame . * / <nl> @ @ - 536 , 15 + 588 , 21 @ @ public class RequireThisCheck extends Check { <nl> / * * <nl> * Creates new instance of ClassFrame . <nl> * @ param parent parent frame <nl> + * @ param frameName frame name <nl> * / <nl> - ClassFrame ( LexicalFrame parent ) { <nl> - super ( parent ) ; <nl> + ClassFrame ( AbstractFrame parent , String frameName ) { <nl> + super ( parent , frameName ) ; <nl> instanceMembers = Sets . newHashSet ( ) ; <nl> instanceMethods = Sets . newHashSet ( ) ; <nl> staticMembers = Sets . newHashSet ( ) ; <nl> staticMethods = Sets . newHashSet ( ) ; <nl> } <nl> <nl> + @ Override <nl> + protected FrameType getType ( ) { <nl> + return FrameType . CLASS _ FRAME ; <nl> + } <nl> + <nl> / * * <nl> * Adds static member ' s ident . <nl> * @ param ident an ident of static member of the class <nl> @ @ - 599 , 8 + 657 , 7 @ @ public class RequireThisCheck extends Check { <nl> <nl> @ Override <nl> boolean contains ( DetailAST nameToFind ) { <nl> - return super . contains ( nameToFind ) <nl> - | | containsName ( instanceMembers , nameToFind ) <nl> + return containsName ( instanceMembers , nameToFind ) <nl> | | containsName ( instanceMethods , nameToFind ) <nl> | | containsName ( staticMembers , nameToFind ) <nl> | | containsName ( staticMethods , nameToFind ) ; <nl> @ @ - 613 , 13 + 670 , 13 @ @ public class RequireThisCheck extends Check { <nl> } <nl> <nl> @ Override <nl> - protected LexicalFrame getIfContains ( DetailAST nameToFind , boolean lookForMethod ) { <nl> - LexicalFrame frame ; <nl> + protected AbstractFrame getIfContains ( DetailAST nameToFind , boolean lookForMethod ) { <nl> + AbstractFrame frame = null ; <nl> <nl> if ( contains ( nameToFind ) ) { <nl> frame = this ; <nl> } <nl> - else { <nl> + else if ( getParent ( ) ! = null ) { <nl> frame = getParent ( ) . getIfContains ( nameToFind , lookForMethod ) ; <nl> } <nl> return frame ; <nl> @ @ - 627 , 19 + 684 , 22 @ @ public class RequireThisCheck extends Check { <nl> } <nl> <nl> / * * <nl> - * A frame initiated on entering a statement list ; holds local variable <nl> - * names . For the present , I ' m not worried about other class names , <nl> - * method names , etc . <nl> + * A frame initiated on entering a statement list ; holds local variable names . <nl> * @ author Stephen Bloch <nl> * / <nl> - private static class BlockFrame extends LexicalFrame { <nl> + private static class BlockFrame extends AbstractFrame { <nl> <nl> / * * <nl> * Creates block frame . <nl> * @ param parent parent frame <nl> * / <nl> - protected BlockFrame ( LexicalFrame parent ) { <nl> - super ( parent ) ; <nl> + protected BlockFrame ( AbstractFrame parent ) { <nl> + super ( parent , null ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected FrameType getType ( ) { <nl> + return FrameType . BLOCK _ FRAME ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages . properties <nl> index 317e8b8 . . 8057bfe 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages . properties <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages . properties <nl> @ @ - 42 , 8 + 42 , 8 @ @ redundant . throws . classInfo = Unable to get class information for { 0 } . <nl> redundant . throws . duplicate = Redundant throws : ' ' { 0 } ' ' listed more then one time . <nl> redundant . throws . subclass = Redundant throws : ' ' { 0 } ' ' is subclass of ' ' { 1 } ' ' . <nl> redundant . throws . unchecked = Redundant throws : ' ' { 0 } ' ' is unchecked exception . <nl> - require . this . variable = Reference to instance variable ' ' { 0 } ' ' needs \ " this . \ " . <nl> - require . this . method = Method call to ' ' { 0 } ' ' needs \ " this . \ " . <nl> + require . this . variable = Reference to instance variable ' ' { 0 } ' ' needs \ " { 1 } this . \ " . <nl> + require . this . method = Method call to ' ' { 0 } ' ' needs \ " { 1 } this . \ " . <nl> return . count = Return count is { 0 , number , integer } ( max allowed is { 1 , number , integer } ) . <nl> simplify . boolReturn = Conditional logic can be removed . <nl> simplify . expression = Expression can be simplified . <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ de . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ de . properties <nl> index 53d683d . . e2f6c1b 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ de . properties <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ de . properties <nl> @ @ - 42 , 8 + 42 , 8 @ @ redundant . throws . classInfo = Klassen - Information f ü r { 0 } nicht verf ü gbar . <nl> redundant . throws . duplicate = Ü berfl ü ssige throws - Deklaration : ' ' { 0 } ' ' ist mehrfach aufgef ü hrt . <nl> redundant . throws . subclass = Ü berfl ü ssige throws - Deklaration : ' ' { 0 } ' ' ist Unterklasse von ' ' { 1 } ' ' . <nl> redundant . throws . unchecked = Ü berfl ü ssige throws - Deklaration : ' ' { 0 } ' ' ist eine unchecked Exception ( abgeleitet von RuntimeException ) . <nl> - require . this . variable = Dereferenzierung der Instanzvariable ' ' { 0 } ' ' muss ü ber \ " this . \ " erfolgen . <nl> - require . this . method = Methodenaufruf ' ' { 0 } ' ' muss ü ber \ " this . \ " erfolgen . <nl> + require . this . variable = Dereferenzierung der Instanzvariable ' ' { 0 } ' ' muss ü ber \ " { 1 } this . \ " erfolgen . <nl> + require . this . method = Methodenaufruf ' ' { 0 } ' ' muss ü ber \ " { 1 } this . \ " erfolgen . <nl> return . count = { 0 , number , integer } return - Anweisungen ( Obergrenze ist { 1 , number , integer } ) . <nl> simplify . boolReturn = Die Verzweigung sollte entfernt werden . <nl> simplify . expression = Der Ausdruck kann vereinfacht werden . <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ es . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ es . properties <nl> index e592c66 . . 7cc533e 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ es . properties <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ es . properties <nl> @ @ - 60 , 8 + 60 , 8 @ @ explicit . init = La variable ' ' { 0 } ' ' se inicializa explicitamente a ' ' { 1 } ' ' ( valor <nl> default . comes . last = La etiqueta default debe ser la ú ltima etiqueta en el switch . <nl> missing . ctor = La clase deber í a definir un constructor . <nl> fall . through = Ca í da desde la etiqueta anterior en la sentencia switch . <nl> - require . this . variable = La referencia a la variable de instancia ' ' { 0 } ' ' necesita \ " this . \ " . <nl> - require . this . method = La llamada al m é todo ' ' { 0 } ' ' necesita \ " this . \ " . <nl> + require . this . variable = La referencia a la variable de instancia ' ' { 0 } ' ' necesita \ " { 1 } this . \ " . <nl> + require . this . method = La llamada al m é todo ' ' { 0 } ' ' necesita \ " { 1 } this . \ " . <nl> multiple . variable . declarations = S ó lo se permite una definici ó n de variable por l í nea . <nl> multiple . variable . declarations . comma = Cada declaraci ó n de variable debe estar en su l í nea . <nl> <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fi . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fi . properties <nl> index 4bbadef . . 14ea08a 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fi . properties <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fi . properties <nl> @ @ - 54 , 8 + 54 , 8 @ @ multiple . variable . declarations . comma = Jokainen muuttuja ilmoitus on oltava oman <nl> nested . for . depth = Sis ä kk ä isi ä syvyys on { 0 , numero , kokonaisluku } ( max sallittu on { 1 , numero , kokonaisluku } ) . <nl> parameter . assignment = Teht ä v ä parametrin ' ' { 0 } ' ' ei ole sallittu . <nl> redundant . throws . classInfo = Ei saada luokan tietoa { 0 } . <nl> - require . this . variable = Viittaus Esimerkiksi muuttuja ' ' { 0 } ' ' tarvitsee \ " t ä m ä . \ " . <nl> - require . this . method = Menetelm ä kehotus ' ' { 0 } ' ' tarvitsee \ " t ä m ä . \ " . <nl> + require . this . variable = Viittaus Esimerkiksi muuttuja ' ' { 0 } ' ' tarvitsee \ " { 1 } this . \ " . <nl> + require . this . method = Menetelm ä kehotus ' ' { 0 } ' ' tarvitsee \ " { 1 } this . \ " . <nl> return . count = Paluu m ä ä r ä on { 0 , numero , kokonaisluku } ( max sallittu on { 1 , numero , kokonaisluku } ) . <nl> string . literal . equality = Kirjaimellinen Strings pit ä isi verrata k ä ytt ä m ä ll ä tasavertaisten ( ) , ei ' ' { 0 } ' ' . <nl> unnecessary . paren . assign = Tarpeettomia sulkuja noin teht ä v ä n oikealla puolella . <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fr . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fr . properties <nl> index e74c9e6 . . af2e8a0 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fr . properties <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fr . properties <nl> @ @ - 60 , 8 + 60 , 8 @ @ explicit . init = L ' ' initialisation explicite de la variable ' ' { 0 } ' ' à la valeur ' ' <nl> default . comes . last = Le cas \ " default \ " devrait apparaitre en dernier dans le bloc \ " switch \ " . <nl> missing . ctor = Il manque un constructeur à la classe . <nl> fall . through = Le cas pr é c é dent du \ " switch \ " ne contient pas de break , return , throw ou continue . <nl> - require . this . variable = La r é f é rence à la variable d ' ' instance ' ' { 0 } ' ' doit utiliser \ " this . \ " . <nl> - require . this . method = L ' ' appel à la m é thode ' ' { 0 } ' ' n é cessite l ' ' utilisation de \ " this . \ " . <nl> + require . this . variable = La r é f é rence à la variable d ' ' instance ' ' { 0 } ' ' doit utiliser \ " { 1 } this . \ " . <nl> + require . this . method = L ' ' appel à la m é thode ' ' { 0 } ' ' n é cessite l ' ' utilisation de \ " { 1 } this . \ " . <nl> multiple . variable . declarations = Ne d é clarez pas plus d ' ' une variable par ligne . <nl> multiple . variable . declarations . comma = Chaque d é claration de variable doit faire l ' ' objet d ' ' une instruction à part . <nl> <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ ja . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ ja . properties <nl> index de9bf55 . . 20c5932 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ ja . properties <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ ja . properties <nl> @ @ - 67 , 8 + 67 , 8 @ @ multiple . string . literal = 文 字 列 { 0 } は 、 こ の フ ァ イ ル に { 1 } に 出 <nl> multiple . variable . declarations = 行 に 1 つ の 変 数 定 義 だ け が 許 可 さ れ ま す 。 <nl> multiple . variable . declarations . comma = 各 変 数 の 宣 言 に は 、 独 自 の ス テ ー ト メ ン ト で な け れ ば な り ま せ ん 。 <nl> nested . for . depth = 入 れ 子 の for の 深 さ { 0 , number , integer } （ 許 可 さ れ た 最 大 値 は { 1 , number , integer } ) 。 <nl> - require . this . variable = イ ン ス タ ン ス 変 数 ' ' { 0 } ' ' へ の 参 照 に は \ " this \ " が 必 要 で す 。 <nl> - require . this . method = メ ソ ッ ド ' ' { 0 } ' ' へ の 呼 び 出 し は 、 \ " this \ " が 必 要 で す 。 <nl> + require . this . variable = イ ン ス タ ン ス 変 数 ' ' { 0 } ' ' へ の 参 照 に は \ " { 1 } this . \ " が 必 要 で す 。 <nl> + require . this . method = メ ソ ッ ド ' ' { 0 } ' ' へ の 呼 び 出 し は 、 \ " { 1 } this . \ " が 必 要 で す 。 <nl> unnecessary . paren . assign = 代 入 右 辺 の 周 り に 不 要 な 括 弧 。 <nl> unnecessary . paren . expr = 式 の 周 り の 不 要 な 括 弧 。 <nl> unnecessary . paren . ident = 識 別 子 の 前 後 に 不 要 な 括 弧 ' ' { 0 } ' ' 。 <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ pt . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ pt . properties <nl> index b8a19b1 . . ffd8593 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ pt . properties <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ pt . properties <nl> @ @ - 47 , 8 + 47 , 8 @ @ multiple . string . literal = The String { 0 } aparece { 1 } vezes no arquivo . <nl> multiple . variable . declarations = Apenas uma defini ç ã o de vari á vel por linha permitidos . <nl> multiple . variable . declarations . comma = Cada declara ç ã o de vari á vel deve estar em sua pr ó pria declara ç ã o . <nl> nested . for . depth = Aninhado para a profundidade é { 0 , number , integer } ( m á ximo permitido é { 1 , number , integer } ) . <nl> - require . this . variable = Refer ê ncia a vari á vel de inst â ncia ' ' { 0 } ' ' precisa de \ " isso . \ " . <nl> - require . this . method = Chamada de m é todo para ' ' { 0 } ' ' precisa de \ " isso . \ " . <nl> + require . this . variable = Refer ê ncia a vari á vel de inst â ncia ' ' { 0 } ' ' precisa de \ " { 1 } this . \ " . <nl> + require . this . method = Chamada de m é todo para ' ' { 0 } ' ' precisa de \ " { 1 } this . \ " . <nl> unnecessary . paren . assign = Par ê nteses desnecess á rios ao redor do lado direito atribui ç ã o . <nl> unnecessary . paren . expr = Par ê nteses desnecess á rios ao redor express ã o . <nl> unnecessary . paren . ident = Par ê nteses desnecess á rios ao redor identificador ' ' { 0 } ' ' . <nl> diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ tr . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ tr . properties <nl> index 285babf . . 5071a1c 100644 <nl> - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ tr . properties <nl> + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ tr . properties <nl> @ @ - 71 , 8 + 71 , 8 @ @ redundant . throws . duplicate = ' ' throws ' ' ifadesinde ' ' { 0 } ' ' tekrardan kullan ı lm <nl> redundant . throws . subclass = ' ' { 0 } ' ' , ' ' { 1 } ' ' s ı n ı f ı n ı n alt s ı n ı f ı d ı r , ' ' throws ' ' kullan ı m ı gereksizdir . <nl> redundant . throws . unchecked = ' ' { 0 } ' ' ' ' unchecked ' ' bir istisnad ı r , ' ' throws ' ' kullan ı m ı gereksizdir . <nl> <nl> - require . this . method = ' ' { 0 } ' ' metoduna eri ş im " this . " kullan ı larak yap ı lmal ı d ı r . <nl> - require . this . variable = ' ' { 0 } ' ' de ğ i ş kenine eri ş im " this . " kullan ı larak yap ı lmal ı d ı r . <nl> + require . this . method = ' ' { 0 } ' ' metoduna eri ş im \ " { 1 } this . \ " kullan ı larak yap ı lmal ı d ı r . <nl> + require . this . variable = ' ' { 0 } ' ' de ğ i ş kenine eri ş im \ " { 1 } this . \ " kullan ı larak yap ı lmal ı d ı r . <nl> <nl> return . count = Kullan ı lan ' ' return ' ' say ı s ı { 0 , number , integer } ( maksimum izin verilen de ğ er { 1 , number , integer } ) . <nl> <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java <nl> index d8f9780 . . c27d4b4 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java <nl> @ @ - 48 , 15 + 48 , 16 @ @ public class RequireThisCheckTest extends BaseCheckTestSupport { <nl> final DefaultConfiguration checkConfig = <nl> createCheckConfig ( RequireThisCheck . class ) ; <nl> final String [ ] expected = { <nl> - " 11 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , <nl> - " 17 : 9 : " + getCheckMessage ( MSG _ METHOD , " method1 " , " \ " this \ " " ) , <nl> - " 31 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , <nl> - " 49 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " \ " this \ " " ) , <nl> - " 56 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " \ " this \ " " ) , <nl> - " 113 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , <nl> - " 114 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , <nl> - " 115 : 9 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " \ " this \ " " ) , <nl> - " 121 : 13 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " \ " this \ " " ) , <nl> + " 11 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , <nl> + " 17 : 9 : " + getCheckMessage ( MSG _ METHOD , " method1 " , " " ) , <nl> + " 31 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , <nl> + " 49 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " " ) , <nl> + " 56 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " " ) , <nl> + " 113 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , <nl> + " 114 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , <nl> + " 115 : 9 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " " ) , <nl> + " 121 : 13 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " Issue2240 . " ) , <nl> + " 122 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " Issue2240 . " ) , <nl> } ; <nl> verify ( checkConfig , <nl> getPath ( " InputRequireThis . java " ) , <nl> @ @ - 69 , 9 + 70 , 9 @ @ public class RequireThisCheckTest extends BaseCheckTestSupport { <nl> createCheckConfig ( RequireThisCheck . class ) ; <nl> checkConfig . addAttribute ( " checkFields " , " false " ) ; <nl> final String [ ] expected = { <nl> - " 17 : 9 : " + getCheckMessage ( MSG _ METHOD , " method1 " , " \ " this \ " " ) , <nl> - " 115 : 9 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " \ " this \ " " ) , <nl> - " 121 : 13 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " \ " this \ " " ) , <nl> + " 17 : 9 : " + getCheckMessage ( MSG _ METHOD , " method1 " , " " ) , <nl> + " 115 : 9 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " " ) , <nl> + " 121 : 13 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " Issue2240 . " ) , <nl> } ; <nl> verify ( checkConfig , <nl> getPath ( " InputRequireThis . java " ) , <nl> @ @ - 84 , 12 + 85 , 13 @ @ public class RequireThisCheckTest extends BaseCheckTestSupport { <nl> createCheckConfig ( RequireThisCheck . class ) ; <nl> checkConfig . addAttribute ( " checkMethods " , " false " ) ; <nl> final String [ ] expected = { <nl> - " 11 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , <nl> - " 31 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , <nl> - " 49 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " \ " this \ " " ) , <nl> - " 56 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " \ " this \ " " ) , <nl> - " 113 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , <nl> - " 114 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , <nl> + " 11 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , <nl> + " 31 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , <nl> + " 49 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " " ) , <nl> + " 56 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " " ) , <nl> + " 113 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , <nl> + " 114 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , <nl> + " 122 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " Issue2240 . " ) , <nl> } ; <nl> verify ( checkConfig , <nl> getPath ( " InputRequireThis . java " ) , <nl> @ @ - 109 , 8 + 111 , 8 @ @ public class RequireThisCheckTest extends BaseCheckTestSupport { <nl> final DefaultConfiguration checkConfig = <nl> createCheckConfig ( RequireThisCheck . class ) ; <nl> final String [ ] expected = { <nl> - " 7 : 19 : " + getCheckMessage ( MSG _ VARIABLE , " number " , " \ " this \ " " ) , <nl> - " 8 : 16 : " + getCheckMessage ( MSG _ METHOD , " other " , " \ " this \ " " ) , <nl> + " 7 : 19 : " + getCheckMessage ( MSG _ VARIABLE , " number " , " " ) , <nl> + " 8 : 16 : " + getCheckMessage ( MSG _ METHOD , " other " , " " ) , <nl> } ; <nl> verify ( checkConfig , <nl> getPath ( " InputRequireThis2 . java " ) , <nl> diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputRequireThis . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputRequireThis . java <nl> index 5cbf936 . . 0fa0b8a 100644 <nl> - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputRequireThis . java <nl> + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputRequireThis . java <nl> @ @ - 119 , 6 + 119 , 7 @ @ class Issue2240 { <nl> class Nested { <nl> void bar ( ) { <nl> instanceMethod ( ) ; <nl> + i + + ; <nl> } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java <nl> index 6d1857b . . 594f250 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java <nl> @ @ - 19 , 6 + 19 , 9 @ @ <nl> <nl> package com . puppycrawl . tools . checkstyle . checks . indentation ; <nl> <nl> + import java . util . Locale ; <nl> + import java . util . Stack ; <nl> + <nl> import org . apache . commons . lang3 . ArrayUtils ; <nl> <nl> import com . puppycrawl . tools . checkstyle . api . Check ; <nl> @ @ - 62 , 22 + 65 , 18 @ @ import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; <nl> * } <nl> * < / pre > <nl> * <nl> - * <nl> * @ author < a href = " mailto : nesterenko - aleksey @ list . ru " > Aleksey Nesterenko < / a > <nl> * @ author < a href = " mailto : andreyselkin @ gmail . com " > Andrei Selkin < / a > <nl> - * <nl> * / <nl> public class CommentsIndentationCheck extends Check { <nl> <nl> / * * <nl> - * A key is pointing to the warning message text in " messages . properties " <nl> - * file . <nl> + * A key is pointing to the warning message text in " messages . properties " file . <nl> * / <nl> public static final String MSG _ KEY _ SINGLE = " comments . indentation . single " ; <nl> <nl> / * * <nl> - * A key is pointing to the warning message text in " messages . properties " <nl> - * file . <nl> + * A key is pointing to the warning message text in " messages . properties " file . <nl> * / <nl> public static final String MSG _ KEY _ BLOCK = " comments . indentation . block " ; <nl> <nl> @ @ - 135 , 17 + 134 , 493 @ @ public class CommentsIndentationCheck extends Check { <nl> * @ param singleLineComment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . <nl> * / <nl> private void visitSingleLineComment ( DetailAST singleLineComment ) { <nl> - final DetailAST nextStatement = singleLineComment . getNextSibling ( ) ; <nl> - final DetailAST prevStatement = getPrevStatementFromSwitchBlock ( singleLineComment ) ; <nl> + final DetailAST prevStmt = getPreviousStatementOfSingleLineComment ( singleLineComment ) ; <nl> + final DetailAST nextStmt = singleLineComment . getNextSibling ( ) ; <nl> <nl> - if ( nextStatement ! = null <nl> - & & nextStatement . getType ( ) ! = TokenTypes . RCURLY <nl> - & & ! isTrailingSingleLineComment ( singleLineComment ) <nl> - & & ! areSameLevelIndented ( singleLineComment , prevStatement , nextStatement ) ) { <nl> + if ( ! isTrailingSingleLineComment ( singleLineComment ) ) { <nl> + if ( isInEmptyCaseBlock ( prevStmt , nextStmt ) ) { <nl> + handleSingleLineCommentInEmptyCaseBlock ( prevStmt , singleLineComment , <nl> + nextStmt ) ; <nl> + } <nl> + else if ( isFallThroughSingleLineComment ( prevStmt , nextStmt ) ) { <nl> + handleFallThroughtSingleLineComment ( prevStmt , singleLineComment , <nl> + nextStmt ) ; <nl> + } <nl> + else if ( isInEmptyCodeBlock ( prevStmt , nextStmt ) ) { <nl> + handleSingleLineCommentInEmptyCodeBlock ( singleLineComment , nextStmt ) ; <nl> + } <nl> + else if ( isSingleLineCommentAtTheEndOfTheCodeBlock ( nextStmt ) ) { <nl> + handleSIngleLineCommentAtTheEndOfTheCodeBlock ( prevStmt , singleLineComment , <nl> + nextStmt ) ; <nl> + } <nl> + else if ( nextStmt ! = null <nl> + & & ! areSameLevelIndented ( singleLineComment , nextStmt , nextStmt ) ) { <nl> + log ( singleLineComment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , <nl> + singleLineComment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Returns the previous statement of a single line comment . <nl> + * @ param comment single line comment . <nl> + * @ return the previous statement of a single line comment . <nl> + * / <nl> + private DetailAST getPreviousStatementOfSingleLineComment ( DetailAST comment ) { <nl> + final DetailAST prevStatement ; <nl> + if ( isDistributedPreviousStatement ( comment ) ) { <nl> + prevStatement = getDistributedPreviousStatementOfSingleLineComment ( comment ) ; <nl> + } <nl> + else { <nl> + prevStatement = getOneLinePreviousStatementOfSingleLineComment ( comment ) ; <nl> + } <nl> + return prevStatement ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the previous statement of a single line comment is distributed over two or <nl> + * more lines . <nl> + * @ param singleLineComment single line comment . <nl> + * @ return true if the previous statement of a single line comment is distributed over two or <nl> + * more lines . <nl> + * / <nl> + private boolean isDistributedPreviousStatement ( DetailAST singleLineComment ) { <nl> + final DetailAST previousSibling = singleLineComment . getPreviousSibling ( ) ; <nl> + return isDistributedMethodChainOrConcatenationStatement ( singleLineComment , previousSibling ) <nl> + | | isDistributedReturnStatement ( previousSibling ) <nl> + | | isDistributedThrowStatement ( previousSibling ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the previous statement of a single line comment is a method call chain or <nl> + * string concatenation statemen distributed over two ore more lines . <nl> + * @ param comment single line comment . <nl> + * @ param commentPreviousSibling previous sibling of the sinle line comment . <nl> + * @ return if the previous statement of a single line comment is a method call chain or <nl> + * string concatenation statemen distributed over two ore more lines . <nl> + * / <nl> + private static boolean isDistributedMethodChainOrConcatenationStatement ( <nl> + DetailAST comment , DetailAST commentPreviousSibling ) { <nl> + boolean destributed = false ; <nl> + if ( commentPreviousSibling ! = null <nl> + & & commentPreviousSibling . getType ( ) = = TokenTypes . SEMI <nl> + & & comment . getLineNo ( ) - commentPreviousSibling . getLineNo ( ) = = 1 ) { <nl> + DetailAST currentToken = commentPreviousSibling . getPreviousSibling ( ) ; <nl> + while ( currentToken . getFirstChild ( ) ! = null ) { <nl> + currentToken = currentToken . getFirstChild ( ) ; <nl> + } <nl> + if ( currentToken . getType ( ) ! = TokenTypes . COMMENT _ CONTENT <nl> + & & commentPreviousSibling . getLineNo ( ) ! = currentToken . getLineNo ( ) ) { <nl> + destributed = true ; <nl> + } <nl> + } <nl> + return destributed ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the previous statement of a single line comment is a destributed return <nl> + * statement . <nl> + * @ param commentPreviousSibling previous sibling of the single line comment . <nl> + * @ return true if the previous statement of a single line comment is a destributed return <nl> + * statement . <nl> + * / <nl> + private static boolean isDistributedReturnStatement ( DetailAST commentPreviousSibling ) { <nl> + boolean destributed = false ; <nl> + if ( commentPreviousSibling ! = null <nl> + & & commentPreviousSibling . getType ( ) = = TokenTypes . LITERAL _ RETURN ) { <nl> + final DetailAST firstChild = commentPreviousSibling . getFirstChild ( ) ; <nl> + final DetailAST nextSibling = firstChild . getNextSibling ( ) ; <nl> + if ( nextSibling ! = null ) { <nl> + destributed = true ; <nl> + } <nl> + } <nl> + return destributed ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the previous statement of a single line comment is a destributed throw <nl> + * statement . <nl> + * @ param commentPreviousSibling previous sibling of the single line comment . <nl> + * @ return true if the previous statement of a single line comment is a destributed throw <nl> + * statement . <nl> + * / <nl> + private static boolean isDistributedThrowStatement ( DetailAST commentPreviousSibling ) { <nl> + boolean destributed = false ; <nl> + if ( commentPreviousSibling ! = null <nl> + & & commentPreviousSibling . getType ( ) = = TokenTypes . LITERAL _ THROW ) { <nl> + final DetailAST firstChild = commentPreviousSibling . getFirstChild ( ) ; <nl> + final DetailAST nextSibling = firstChild . getNextSibling ( ) ; <nl> + if ( nextSibling . getLineNo ( ) ! = commentPreviousSibling . getLineNo ( ) ) { <nl> + destributed = true ; <nl> + } <nl> + } <nl> + return destributed ; <nl> + } <nl> <nl> - log ( singleLineComment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStatement . getLineNo ( ) , <nl> - singleLineComment . getColumnNo ( ) , nextStatement . getColumnNo ( ) ) ; <nl> + / * * <nl> + * Returns the first token of the destributed previous statement of single line comment . <nl> + * @ param comment single line comment . <nl> + * @ return the first token of the destributed previous statement of single line comment . <nl> + * / <nl> + public static DetailAST getDistributedPreviousStatementOfSingleLineComment ( DetailAST comment ) { <nl> + DetailAST previousStatement = comment . getPreviousSibling ( ) ; <nl> + if ( previousStatement . getType ( ) = = TokenTypes . LITERAL _ RETURN <nl> + | | previousStatement . getType ( ) = = TokenTypes . LITERAL _ THROW ) { <nl> + return previousStatement ; <nl> + } <nl> + previousStatement = previousStatement . getPreviousSibling ( ) ; <nl> + while ( previousStatement . getFirstChild ( ) ! = null ) { <nl> + previousStatement = previousStatement . getFirstChild ( ) ; <nl> } <nl> + return previousStatement ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether case block is empty . <nl> + * @ param nextStmt previous statement . <nl> + * @ param prevStmt next statement . <nl> + * @ return true if case block is empty . <nl> + * / <nl> + private static boolean isInEmptyCaseBlock ( DetailAST prevStmt , DetailAST nextStmt ) { <nl> + return prevStmt ! = null <nl> + & & nextStmt ! = null <nl> + & & ( prevStmt . getType ( ) = = TokenTypes . LITERAL _ CASE <nl> + | | prevStmt . getType ( ) = = TokenTypes . CASE _ GROUP ) <nl> + & & ( nextStmt . getType ( ) = = TokenTypes . LITERAL _ CASE <nl> + | | nextStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether single line comment is a ' fall through ' comment . <nl> + * For example : <nl> + * < p > <nl> + * { @ code <nl> + * . . . <nl> + * case OPTION _ ONE : <nl> + * int someVariable = 1 ; <nl> + * / / fall through <nl> + * case OPTION _ TWO : <nl> + * int a = 5 ; <nl> + * break ; <nl> + * . . . <nl> + * } <nl> + * < / p > <nl> + * @ param prevStmt previous statement . <nl> + * @ param nextStmt next statement . <nl> + * @ return true if a single line comment is a ' fall through ' comment . <nl> + * / <nl> + private static boolean isFallThroughSingleLineComment ( DetailAST prevStmt , DetailAST nextStmt ) { <nl> + return prevStmt ! = null <nl> + & & prevStmt . getType ( ) ! = TokenTypes . LITERAL _ CASE <nl> + & & nextStmt ! = null <nl> + & & ( nextStmt . getType ( ) = = TokenTypes . LITERAL _ CASE <nl> + | | nextStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether a single line comment is placed at the end of the code block . <nl> + * @ param nextStmt next statement . <nl> + * @ return true if a single line comment is placed at the end of the block . <nl> + * / <nl> + private boolean isSingleLineCommentAtTheEndOfTheCodeBlock ( DetailAST nextStmt ) { <nl> + return nextStmt ! = null <nl> + & & nextStmt . getType ( ) = = TokenTypes . RCURLY ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether comment is placed in the empty code block . <nl> + * For example : <nl> + * < p > <nl> + * . . . <nl> + * { @ code <nl> + * / / empty code block <nl> + * } <nl> + * . . . <nl> + * < / p > <nl> + * Note , the method does not treat empty case blocks . <nl> + * @ param prevStmt previous statement . <nl> + * @ param nextStmt next statement . <nl> + * @ return true if comment is placed in the empty code block . <nl> + * / <nl> + private boolean isInEmptyCodeBlock ( DetailAST prevStmt , DetailAST nextStmt ) { <nl> + return prevStmt ! = null <nl> + & & nextStmt ! = null <nl> + & & ( prevStmt . getType ( ) = = TokenTypes . SLIST <nl> + | | prevStmt . getType ( ) = = TokenTypes . OBJBLOCK ) <nl> + & & nextStmt . getType ( ) = = TokenTypes . RCURLY ; <nl> + } <nl> + <nl> + / * * <nl> + * Handles a single line comment which is plased within empty case block . <nl> + * Note , if comment is placed at the end of the empty case block , we have Checkstyle ' s <nl> + * limitations to clearly detect user intention of explanation target - above or below . The <nl> + * only case we can assume as a violation is when a single line comment within the empty case <nl> + * block has indentation level that is lower than the indentation level of the next case <nl> + * token . For example : <nl> + * < p > <nl> + * { @ code <nl> + * . . . <nl> + * case OPTION _ ONE : <nl> + * / / violation <nl> + * case OPTION _ TWO : <nl> + * . . . <nl> + * } <nl> + * < / p > <nl> + * @ param prevStmt previous statement . <nl> + * @ param comment single line comment . <nl> + * @ param nextStmt next statement . <nl> + * / <nl> + private void handleSingleLineCommentInEmptyCaseBlock ( DetailAST prevStmt , DetailAST comment , <nl> + DetailAST nextStmt ) { <nl> + <nl> + if ( comment . getColumnNo ( ) < prevStmt . getColumnNo ( ) <nl> + | | comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { <nl> + logMultilineIndentation ( prevStmt , comment , nextStmt ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Handles ' fall through ' single line comment . <nl> + * Note , ' fall through ' and similar comments can have indentation level as next or previous <nl> + * statement . <nl> + * For example : <nl> + * < p > <nl> + * { @ code <nl> + * . . . <nl> + * case OPTION _ ONE : <nl> + * int someVariable = 1 ; <nl> + * / / fall through - OK <nl> + * case OPTION _ TWO : <nl> + * int a = 5 ; <nl> + * break ; <nl> + * . . . <nl> + * } <nl> + * < / p > <nl> + * < p > <nl> + * { @ code <nl> + * . . . <nl> + * case OPTION _ ONE : <nl> + * int someVariable = 1 ; <nl> + * / / than init variable a - OK <nl> + * case OPTION _ TWO : <nl> + * int a = 5 ; <nl> + * break ; <nl> + * . . . <nl> + * } <nl> + * < / p > <nl> + * @ param prevStmt previous statement . <nl> + * @ param comment single line comment . <nl> + * @ param nextStmt next statement . <nl> + * / <nl> + private void handleFallThroughtSingleLineComment ( DetailAST prevStmt , DetailAST comment , <nl> + DetailAST nextStmt ) { <nl> + <nl> + if ( ! areSameLevelIndented ( comment , prevStmt , nextStmt ) ) { <nl> + logMultilineIndentation ( prevStmt , comment , nextStmt ) ; <nl> + } <nl> + <nl> + } <nl> + <nl> + / * * <nl> + * Hendles a single line comment which is placed at the end of non empty code block . <nl> + * Note , if single line comment is plcaed at the end of non empty block the comment should have <nl> + * the same indentation level as the previous statement . For example : <nl> + * < p > <nl> + * { @ code <nl> + * if ( a = = true ) { <nl> + * int b = 1 ; <nl> + * / / comment <nl> + * } <nl> + * } <nl> + * < / p > <nl> + * @ param prevStmt previous statement . <nl> + * @ param comment single line statement . <nl> + * @ param nextStmt next statement . <nl> + * / <nl> + private void handleSIngleLineCommentAtTheEndOfTheCodeBlock ( DetailAST prevStmt , <nl> + DetailAST comment , <nl> + DetailAST nextStmt ) { <nl> + if ( prevStmt ! = null ) { <nl> + if ( prevStmt . getType ( ) = = TokenTypes . LITERAL _ CASE <nl> + | | prevStmt . getType ( ) = = TokenTypes . CASE _ GROUP <nl> + | | prevStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT <nl> + | | prevStmt . getType ( ) = = TokenTypes . SINGLE _ LINE _ COMMENT ) { <nl> + if ( comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { <nl> + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , <nl> + comment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; <nl> + } <nl> + } <nl> + else if ( ! areSameLevelIndented ( comment , prevStmt , prevStmt ) ) { <nl> + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , prevStmt . getLineNo ( ) , <nl> + comment . getColumnNo ( ) , prevStmt . getColumnNo ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + } <nl> + <nl> + / * * <nl> + * Handles a single line comment which is placed within the empty code block . <nl> + * Note , if comment is placed at the end of the empty code block , we have Checkstyle ' s <nl> + * limitations to clearly detect user intention of explanation target - above or below . The <nl> + * only case we can assume as a violation is when a single line comment within the empty <nl> + * code block has indentation level that is lower than the indentation level of the closing <nl> + * right curly brace . For example : <nl> + * < p > <nl> + * { @ code <nl> + * if ( a = = true ) { <nl> + * / / violation <nl> + * } <nl> + * } <nl> + * < / p > <nl> + * <nl> + * @ param comment single line comment . <nl> + * @ param nextStmt next statement . <nl> + * / <nl> + private void handleSingleLineCommentInEmptyCodeBlock ( DetailAST comment , DetailAST nextStmt ) { <nl> + if ( comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { <nl> + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , <nl> + comment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Does pre - order traverse of abstract syntax tree to find the previous statement of the <nl> + * single line comment . If previous statement of the comment is found , then the traverse will <nl> + * be finished . <nl> + * @ param comment current statement . <nl> + * @ return previous statement of the comment or null if the comment does not have previous <nl> + * statement . <nl> + * / <nl> + private static DetailAST getOneLinePreviousStatementOfSingleLineComment ( DetailAST comment ) { <nl> + final Stack < DetailAST > stack = new Stack < > ( ) ; <nl> + DetailAST root = comment . getParent ( ) ; <nl> + <nl> + while ( root ! = null | | ! stack . empty ( ) ) { <nl> + if ( ! stack . empty ( ) ) { <nl> + root = stack . pop ( ) ; <nl> + } <nl> + while ( root ! = null ) { <nl> + final DetailAST previousStatement = <nl> + findPreviousStatementOfSingleLineComment ( comment , root ) ; <nl> + if ( previousStatement ! = null ) { <nl> + return previousStatement ; <nl> + } <nl> + if ( root . getNextSibling ( ) ! = null ) { <nl> + stack . push ( root . getNextSibling ( ) ) ; <nl> + } <nl> + root = root . getFirstChild ( ) ; <nl> + } <nl> + } <nl> + return null ; <nl> + } <nl> + <nl> + / * * <nl> + * Finds a previous statement of the single line comment . <nl> + * Uses root token of the line while searching . <nl> + * @ param comment single line comment . <nl> + * @ param root root token of the line . <nl> + * @ return previous statement of the single line comment or null if previous statement was not <nl> + * found . <nl> + * / <nl> + private static DetailAST findPreviousStatementOfSingleLineComment ( DetailAST comment , <nl> + DetailAST root ) { <nl> + DetailAST previousStatement = null ; <nl> + if ( root . getLineNo ( ) > = comment . getLineNo ( ) ) { <nl> + / / ATTENTION : parent of the comment is below the comment in case block <nl> + / / See https : / / github . com / checkstyle / checkstyle / issues / 851 <nl> + previousStatement = getPrevStatementFromSwitchBlock ( comment ) ; <nl> + } <nl> + final DetailAST tokenWhichBeginsTheLine ; <nl> + if ( root . getType ( ) = = TokenTypes . EXPR <nl> + & & root . getFirstChild ( ) . getFirstChild ( ) ! = null ) { <nl> + if ( root . getFirstChild ( ) . getType ( ) = = TokenTypes . LITERAL _ NEW ) { <nl> + tokenWhichBeginsTheLine = root . getFirstChild ( ) ; <nl> + } <nl> + else { <nl> + tokenWhichBeginsTheLine = findTokenWhichBeginsTheLine ( root ) ; <nl> + } <nl> + } <nl> + else if ( root . getType ( ) = = TokenTypes . PLUS ) { <nl> + tokenWhichBeginsTheLine = root . getFirstChild ( ) ; <nl> + } <nl> + else { <nl> + tokenWhichBeginsTheLine = root ; <nl> + } <nl> + if ( tokenWhichBeginsTheLine ! = null <nl> + & & isOnPreviousLine ( comment , tokenWhichBeginsTheLine ) ) { <nl> + previousStatement = tokenWhichBeginsTheLine ; <nl> + } <nl> + return previousStatement ; <nl> + } <nl> + <nl> + / * * <nl> + * Finds a token which begins the line . <nl> + * @ param root root token of the line . <nl> + * @ return token which begins the line . <nl> + * / <nl> + private static DetailAST findTokenWhichBeginsTheLine ( DetailAST root ) { <nl> + DetailAST tokenWhichBeginsTheLine ; <nl> + if ( isUsingOfObjectReferenceToInvokeMethod ( root ) ) { <nl> + tokenWhichBeginsTheLine = findStartTokenOfMethodCallChain ( root ) ; <nl> + } <nl> + else { <nl> + tokenWhichBeginsTheLine = root . getFirstChild ( ) . findFirstToken ( TokenTypes . IDENT ) ; <nl> + } <nl> + return tokenWhichBeginsTheLine ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether there is a use of an object reference to invoke an object ' s method on line . <nl> + * @ param root root token of the line . <nl> + * @ return true if there is a use of an object reference to invoke an object ' s method on line . <nl> + * / <nl> + private static boolean isUsingOfObjectReferenceToInvokeMethod ( DetailAST root ) { <nl> + return root . getFirstChild ( ) . getFirstChild ( ) . getFirstChild ( ) ! = null <nl> + & & root . getFirstChild ( ) . getFirstChild ( ) . getFirstChild ( ) . getNextSibling ( ) ! = null ; <nl> + } <nl> + <nl> + / * * <nl> + * Finds the start token of method call chain . <nl> + * @ param root root token of the line . <nl> + * @ return the start token of method call chain . <nl> + * / <nl> + private static DetailAST findStartTokenOfMethodCallChain ( DetailAST root ) { <nl> + DetailAST startOfMethodCallChain = root ; <nl> + while ( startOfMethodCallChain . getFirstChild ( ) ! = null <nl> + & & startOfMethodCallChain . getFirstChild ( ) . getLineNo ( ) = = root . getLineNo ( ) ) { <nl> + startOfMethodCallChain = startOfMethodCallChain . getFirstChild ( ) ; <nl> + } <nl> + if ( startOfMethodCallChain . getFirstChild ( ) ! = null ) { <nl> + startOfMethodCallChain = startOfMethodCallChain . getFirstChild ( ) . getNextSibling ( ) ; <nl> + } <nl> + return startOfMethodCallChain ; <nl> + } <nl> + <nl> + / * * <nl> + * Checks whether the checked statement is on previous line . <nl> + * @ param currentStatement current statement . <nl> + * @ param checkedStatement checked statement . <nl> + * @ return true if checked statement is on the line which is previous to current statement . <nl> + * / <nl> + private static boolean isOnPreviousLine ( DetailAST currentStatement , <nl> + DetailAST checkedStatement ) { <nl> + return currentStatement . getLineNo ( ) - checkedStatement . getLineNo ( ) = = 1 ; <nl> + } <nl> + <nl> + / * * <nl> + * Logs comment which can have the same indentation level as next or previous statement . <nl> + * @ param comment comment . <nl> + * @ param nextStmt previous statement . <nl> + * @ param prevStmt next statement . <nl> + * / <nl> + private void logMultilineIndentation ( DetailAST prevStmt , DetailAST comment , <nl> + DetailAST nextStmt ) { <nl> + final String multilineNoTemplate = " % d , % d " ; <nl> + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , <nl> + String . format ( Locale . getDefault ( ) , multilineNoTemplate , prevStmt . getLineNo ( ) , <nl> + nextStmt . getLineNo ( ) ) , comment . getColumnNo ( ) , <nl> + String . format ( Locale . getDefault ( ) , multilineNoTemplate , prevStmt . getColumnNo ( ) , <nl> + nextStmt . getColumnNo ( ) ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 181 , 10 + 656 , 20 @ @ public class CommentsIndentationCheck extends Check { <nl> blockBody = blockBody . getPreviousSibling ( ) ; <nl> } <nl> if ( blockBody . getType ( ) = = TokenTypes . EXPR ) { <nl> - prevStmt = blockBody . getFirstChild ( ) . getFirstChild ( ) ; <nl> + if ( isUsingOfObjectReferenceToInvokeMethod ( blockBody ) ) { <nl> + prevStmt = findStartTokenOfMethodCallChain ( blockBody ) ; <nl> + } <nl> + else { <nl> + prevStmt = blockBody . getFirstChild ( ) . getFirstChild ( ) ; <nl> + } <nl> } <nl> else { <nl> - prevStmt = blockBody ; <nl> + if ( blockBody . getType ( ) = = TokenTypes . SLIST ) { <nl> + prevStmt = blockBody . getParent ( ) . getParent ( ) ; <nl> + } <nl> + else { <nl> + prevStmt = blockBody ; <nl> + } <nl> } <nl> } <nl> return prevStmt ; <nl> @ @ - 199 , 10 + 684 , 9 @ @ public class CommentsIndentationCheck extends Check { <nl> final DetailAST prevCaseToken ; <nl> final DetailAST parentBlock = parentStatement . getParent ( ) ; <nl> if ( parentBlock ! = null & & parentBlock . getParent ( ) ! = null <nl> - & & parentBlock . getParent ( ) . getPreviousSibling ( ) ! = null <nl> - & & parentBlock . getParent ( ) . getPreviousSibling ( ) <nl> - . getType ( ) = = TokenTypes . LITERAL _ CASE ) { <nl> - <nl> + & & parentBlock . getParent ( ) . getPreviousSibling ( ) ! = null <nl> + & & parentBlock . getParent ( ) . getPreviousSibling ( ) . getType ( ) <nl> + = = TokenTypes . LITERAL _ CASE ) { <nl> prevCaseToken = parentBlock . getParent ( ) . getPreviousSibling ( ) ; <nl> } <nl> else { <nl> @ @ - 229 , 20 + 713 , 20 @ @ public class CommentsIndentationCheck extends Check { <nl> * } <nl> * < / pre > <nl> * < / p > <nl> - * @ param singleLineComment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . <nl> + * @ param comment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . <nl> * @ param prevStmt previous code statement . <nl> * @ param nextStmt next code statement . <nl> * @ return true if comment and next code statement are indented at the same level . <nl> * / <nl> - private static boolean areSameLevelIndented ( DetailAST singleLineComment , <nl> - DetailAST prevStmt , DetailAST nextStmt ) { <nl> + private static boolean areSameLevelIndented ( DetailAST comment , DetailAST prevStmt , <nl> + DetailAST nextStmt ) { <nl> boolean result ; <nl> if ( prevStmt = = null ) { <nl> - result = singleLineComment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) ; <nl> + result = comment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) ; <nl> } <nl> else { <nl> - result = singleLineComment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) <nl> - | | singleLineComment . getColumnNo ( ) = = prevStmt . getColumnNo ( ) ; <nl> + result = comment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) <nl> + | | comment . getColumnNo ( ) = = prevStmt . getColumnNo ( ) ; <nl> } <nl> return result ; <nl> } <nl> @ @ - 280 , 10 + 764 , 9 @ @ public class CommentsIndentationCheck extends Check { <nl> final DetailAST prevStatement = getPrevStatementFromSwitchBlock ( blockComment ) ; <nl> <nl> if ( nextStatement ! = null <nl> - & & nextStatement . getType ( ) ! = TokenTypes . RCURLY <nl> - & & ! isTrailingBlockComment ( blockComment ) <nl> - & & ! areSameLevelIndented ( blockComment , prevStatement , nextStatement ) ) { <nl> - <nl> + & & nextStatement . getType ( ) ! = TokenTypes . RCURLY <nl> + & & ! isTrailingBlockComment ( blockComment ) <nl> + & & ! areSameLevelIndented ( blockComment , prevStatement , nextStatement ) ) { <nl> log ( blockComment . getLineNo ( ) , MSG _ KEY _ BLOCK , nextStatement . getLineNo ( ) , <nl> blockComment . getColumnNo ( ) , nextStatement . getColumnNo ( ) ) ; <nl> }

TEST DIFF:
diff - - git a / config / findbugs - exclude . xml b / config / findbugs - exclude . xml 
 index dcb8c08 . . 1ed5459 100644 
 - - - a / config / findbugs - exclude . xml 
 + + + b / config / findbugs - exclude . xml 
 @ @ - 56 , 6 + 56 , 16 @ @ 
 < Bug pattern = " BC _ UNCONFIRMED _ CAST " / > 
 < / Match > 
 < Match > 
 + < ! - - The structure of frames relies on the AST structure which relies on correct / compilable 
 + java files . It is ok to have direct casts to subtypes there . Any problems at runtime do 
 + mean serious problems in the algorithm or AST generation . - - > 
 + < Class name = " com . puppycrawl . tools . checkstyle . checks . coding . RequireThisCheck " / > 
 + < Or > 
 + < Bug pattern = " BC _ UNCONFIRMED _ CAST " / > 
 + < Bug pattern = " BC _ UNCONFIRMED _ CAST _ OF _ RETURN _ VALUE " / > 
 + < / Or > 
 + < / Match > 
 + < Match > 
 < ! - - till SonarQube update Checkstyle version . Support both getFileName ( ) and getFilename ( ) - - > 
 < and > 
 < Class name = " com . puppycrawl . tools . checkstyle . api . FileContents " / > 
 diff - - git a / config / pmd . xml b / config / pmd . xml 
 index cb60185 . . 39b446a 100644 
 - - - a / config / pmd . xml 
 + + + b / config / pmd . xml 
 @ @ - 44 , 6 + 44 , 8 @ @ 
 < rule ref = " rulesets / java / codesize . xml / TooManyMethods " > 
 < properties > 
 < property name = " maxmethods " value = " 20 " / > 
 + < ! - - Reducing the number of methods requires making excess hierarchy or duplicating code , or making existing methods too complex . - - > 
 + < property name = " violationSuppressXPath " value = " / / ClassOrInterfaceDeclaration [ @ Image = ' RequireThisCheck ' ] " / > 
 < / properties > 
 < / rule > 
 < rule ref = " rulesets / java / codesize . xml / ExcessiveClassLength " > 
 diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheck . java 
 index 3b5d6ce . . 3da0db3 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheck . java 
 @ @ - 53 , 13 + 53 , 11 @ @ import com . puppycrawl . tools . checkstyle . utils . ScopeUtils ; 
 * & lt ; / module & gt ; 
 * < / pre > 
 * 
 - * < p > Limitations : I ' m not currently doing anything about static variables 
 + * < p > Limitations : Nothing is currently done about static variables 
 * or catch - blocks . Static methods invoked on a class name seem to be OK ; 
 * both the class name and the method name have a DOT parent . 
 * Non - static methods invoked on either this or a variable name seem to be 
 * OK , likewise . < / p > 
 - * < p > Much of the code for this check was cribbed from Rick Giles ' s 
 - * { @ code HiddenFieldCheck } . < / p > 
 * 
 * @ author Stephen Bloch 
 * @ author o _ sukhodolsky 
 @ @ - 77 , 7 + 75 , 6 @ @ public class RequireThisCheck extends Check { 
 * file . 
 * / 
 public static final String MSG _ VARIABLE = " require . this . variable " ; 
 - 
 / * * 
 * Set of all declaration tokens . 
 * / 
 @ @ - 95 , 12 + 92 , 12 @ @ public class RequireThisCheck extends Check { 
 / * * 
 * Tree of all the parsed frames . 
 * / 
 - private Map < DetailAST , LexicalFrame > frames ; 
 + private Map < DetailAST , AbstractFrame > frames ; 
 
 / * * 
 * Frame for the currently processed AST . 
 * / 
 - private LexicalFrame current ; 
 + private AbstractFrame current ; 
 
 / * * Whether we should check fields usage . * / 
 private boolean checkFields = true ; 
 @ @ - 148 , 8 + 145 , 7 @ @ public class RequireThisCheck extends Check { 
 
 @ Override 
 public void beginTree ( DetailAST rootAST ) { 
 - final Deque < LexicalFrame > frameStack = Lists . newLinkedList ( ) ; 
 - frameStack . add ( new GlobalFrame ( ) ) ; 
 + final Deque < AbstractFrame > frameStack = Lists . newLinkedList ( ) ; 
 
 frames = Maps . newHashMap ( ) ; 
 
 @ @ - 204 , 37 + 200 , 60 @ @ public class RequireThisCheck extends Check { 
 break ; 
 case TokenTypes . METHOD _ CALL : 
 / / let ' s check method calls 
 - if ( checkMethods & & isClassMethod ( ast ) ) { 
 - log ( ast , MSG _ METHOD , ast . getText ( ) ) ; 
 + if ( checkMethods ) { 
 + final AbstractFrame frame = checkMethod ( ast ) ; 
 + if ( frame ! = null ) { 
 + logViolation ( MSG _ METHOD , ast , frame ) ; 
 + } 
 } 
 break ; 
 default : 
 if ( checkFields ) { 
 - processField ( ast , parentType ) ; 
 + final AbstractFrame frame = processField ( ast , parentType ) ; 
 + if ( frame ! = null ) { 
 + logViolation ( MSG _ VARIABLE , ast , frame ) ; 
 + } 
 } 
 break ; 
 } 
 } 
 
 / * * 
 + * Helper method to log a LocalizedMessage . 
 + * @ param ast a node to get line id column numbers associated with the message . 
 + * @ param msgKey key to locale message format . 
 + * @ param frame the frame , where the violation is found . 
 + * / 
 + private void logViolation ( String msgKey , DetailAST ast , AbstractFrame frame ) { 
 + if ( frame . getFrameName ( ) . equals ( getNearestClassFrameName ( ) ) ) { 
 + log ( ast , msgKey , ast . getText ( ) , " " ) ; 
 + } 
 + else { 
 + log ( ast , msgKey , ast . getText ( ) , frame . getFrameName ( ) + ' . ' ) ; 
 + } 
 + } 
 + 
 + / * * 
 * Process validation of Field . 
 * @ param ast field definition ast token 
 * @ param parentType type of the parent 
 + * @ return frame , where the field is declared , if the violation is found and null otherwise 
 * / 
 - private void processField ( DetailAST ast , int parentType ) { 
 + private AbstractFrame processField ( DetailAST ast , int parentType ) { 
 final boolean importOrPackage = ScopeUtils . getSurroundingScope ( ast ) = = null ; 
 final boolean methodNameInMethodCall = parentType = = TokenTypes . DOT 
 & & ast . getPreviousSibling ( ) ! = null ; 
 final boolean typeName = parentType = = TokenTypes . TYPE 
 | | parentType = = TokenTypes . LITERAL _ NEW ; 
 + AbstractFrame frame = null ; 
 
 if ( ! importOrPackage 
 & & ! methodNameInMethodCall 
 & & ! typeName 
 - & & ! isDeclarationToken ( parentType ) 
 - & & isClassField ( ast ) ) { 
 - log ( ast , MSG _ VARIABLE , ast . getText ( ) ) ; 
 + & & ! isDeclarationToken ( parentType ) ) { 
 + frame = checkField ( ast ) ; 
 } 
 + return frame ; 
 } 
 
 / * * 
 @ @ - 243 , 9 + 262 , 9 @ @ public class RequireThisCheck extends Check { 
 * @ param frameStack Stack containing the FrameTree being built 
 * @ param ast AST to parse 
 * / 
 - private static void collectDeclarations ( Deque < LexicalFrame > frameStack , 
 + private static void collectDeclarations ( Deque < AbstractFrame > frameStack , 
 DetailAST ast ) { 
 - final LexicalFrame frame = frameStack . peek ( ) ; 
 + final AbstractFrame frame = frameStack . peek ( ) ; 
 switch ( ast . getType ( ) ) { 
 case TokenTypes . VARIABLE _ DEF : 
 collectVariableDeclarations ( ast , frame ) ; 
 @ @ - 259 , 15 + 278 , 14 @ @ public class RequireThisCheck extends Check { 
 case TokenTypes . ENUM _ DEF : 
 case TokenTypes . ANNOTATION _ DEF : 
 final DetailAST classIdent = ast . findFirstToken ( TokenTypes . IDENT ) ; 
 - frame . addIdent ( classIdent ) ; 
 - frameStack . addFirst ( new ClassFrame ( frame ) ) ; 
 + frameStack . addFirst ( new ClassFrame ( frame , classIdent . getText ( ) ) ) ; 
 break ; 
 case TokenTypes . SLIST : 
 frameStack . addFirst ( new BlockFrame ( frame ) ) ; 
 break ; 
 case TokenTypes . METHOD _ DEF : 
 final DetailAST ident = ast . findFirstToken ( TokenTypes . IDENT ) ; 
 - if ( frame instanceof ClassFrame ) { 
 + if ( frame . getType ( ) = = FrameType . CLASS _ FRAME ) { 
 final DetailAST mods = 
 ast . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 if ( mods . branchContains ( TokenTypes . LITERAL _ STATIC ) ) { 
 @ @ - 292 , 10 + 310 , 9 @ @ public class RequireThisCheck extends Check { 
 * @ param ast variable token 
 * @ param frame current frame 
 * / 
 - private static void collectVariableDeclarations ( DetailAST ast , LexicalFrame frame ) { 
 - final DetailAST ident = 
 - ast . findFirstToken ( TokenTypes . IDENT ) ; 
 - if ( frame instanceof ClassFrame ) { 
 + private static void collectVariableDeclarations ( DetailAST ast , AbstractFrame frame ) { 
 + final DetailAST ident = ast . findFirstToken ( TokenTypes . IDENT ) ; 
 + if ( frame . getType ( ) = = FrameType . CLASS _ FRAME ) { 
 final DetailAST mods = 
 ast . findFirstToken ( TokenTypes . MODIFIERS ) ; 
 if ( ScopeUtils . isInInterfaceBlock ( ast ) 
 @ @ - 317 , 7 + 334 , 7 @ @ public class RequireThisCheck extends Check { 
 * @ param frameStack Stack containing the FrameTree being built 
 * @ param ast AST that was parsed 
 * / 
 - private void endCollectingDeclarations ( Queue < LexicalFrame > frameStack , 
 + private void endCollectingDeclarations ( Queue < AbstractFrame > frameStack , 
 DetailAST ast ) { 
 switch ( ast . getType ( ) ) { 
 case TokenTypes . CLASS _ DEF : 
 @ @ - 336 , 33 + 353 , 40 @ @ public class RequireThisCheck extends Check { 
 
 / * * 
 * Check if given name is a name for class field in current environment . 
 - * @ param ident an IDENT ast to check 
 - * @ return true is the given name is name of member . 
 + * @ param ast an IDENT ast to check 
 + * @ return frame , where the field is declared , if the violation is found and null otherwise 
 * / 
 - private boolean isClassField ( DetailAST ident ) { 
 - final LexicalFrame frame = findFrame ( ident , false ) ; 
 - return frame instanceof ClassFrame 
 - & & ( ( ClassFrame ) frame ) . hasInstanceMember ( ident ) ; 
 + private AbstractFrame checkField ( DetailAST ast ) { 
 + final AbstractFrame frame = findFrame ( ast , false ) ; 
 + if ( frame ! = null 
 + & & frame . getType ( ) = = FrameType . CLASS _ FRAME 
 + & & ( ( ClassFrame ) frame ) . hasInstanceMember ( ast ) ) { 
 + return frame ; 
 + } 
 + return null ; 
 } 
 
 / * * 
 * Check if given name is a name for class method in current environment . 
 - * @ param ident the IDENT ast of the name to check 
 - * @ return true is the given name is name of method . 
 + * @ param ast the IDENT ast of the name to check 
 + * @ return frame , where the method is declared , if the violation is found and null otherwise 
 * / 
 - private boolean isClassMethod ( DetailAST ident ) { 
 - final LexicalFrame frame = findFrame ( ident , true ) ; 
 - return frame instanceof ClassFrame 
 - & & ( ( ClassFrame ) frame ) . hasInstanceMethod ( ident ) ; 
 + private AbstractFrame checkMethod ( DetailAST ast ) { 
 + final AbstractFrame frame = findFrame ( ast , true ) ; 
 + if ( frame ! = null 
 + & & ( ( ClassFrame ) frame ) . hasInstanceMethod ( ast ) ) { 
 + return frame ; 
 + } 
 + return null ; 
 } 
 
 / * * 
 * Find frame containing declaration . 
 * @ param name IDENT ast of the declaration to find . 
 * @ param lookForMethod whether we are looking for a method name . 
 - * @ return LexicalFrame containing declaration or null . 
 + * @ return AbstractFrame containing declaration or null . 
 * / 
 - private LexicalFrame findFrame ( DetailAST name , boolean lookForMethod ) { 
 + private AbstractFrame findFrame ( DetailAST name , boolean lookForMethod ) { 
 if ( current = = null ) { 
 return null ; 
 } 
 @ @ - 381 , 29 + 405 , 64 @ @ public class RequireThisCheck extends Check { 
 } 
 
 / * * 
 + * Get the name of the nearest parent ClassFrame . 
 + * @ return the name of the nearest parent ClassFrame . 
 + * / 
 + private String getNearestClassFrameName ( ) { 
 + AbstractFrame frame = current ; 
 + while ( frame . getType ( ) ! = FrameType . CLASS _ FRAME ) { 
 + frame = frame . getParent ( ) ; 
 + } 
 + return frame . getFrameName ( ) ; 
 + } 
 + 
 + / * * An AbstractFrame type . * / 
 + private enum FrameType { 
 + / * * Class frame type . * / 
 + CLASS _ FRAME , 
 + / * * Method frame type . * / 
 + METHOD _ FRAME , 
 + / * * Block frame type . * / 
 + BLOCK _ FRAME , 
 + } 
 + 
 + / * * 
 * A declaration frame . 
 * @ author Stephen Bloch 
 * / 
 - private static class LexicalFrame { 
 + private abstract static class AbstractFrame { 
 / * * Set of name of variables declared in this frame . * / 
 private final Set < DetailAST > varIdents ; 
 
 / * * 
 * Parent frame . 
 * / 
 - private final LexicalFrame parent ; 
 + private final AbstractFrame parent ; 
 + 
 + / * * 
 + * Frame name . 
 + * / 
 + private final String frameName ; 
 
 / * * 
 * Constructor - - invokable only via super ( ) from subclasses . 
 * 
 * @ param parent parent frame 
 + * @ param frameName frame name 
 * / 
 - protected LexicalFrame ( LexicalFrame parent ) { 
 + protected AbstractFrame ( AbstractFrame parent , String frameName ) { 
 this . parent = parent ; 
 + this . frameName = frameName ; 
 varIdents = Sets . newHashSet ( ) ; 
 } 
 
 / * * 
 + * Get the type of the frame . 
 + * @ return a FrameType . 
 + * / 
 + protected abstract FrameType getType ( ) ; 
 + 
 + / * * 
 * Add a name to the frame . 
 * @ param identToAdd the name we ' re adding 
 * / 
 @ @ - 411 , 10 + 470 , 14 @ @ public class RequireThisCheck extends Check { 
 varIdents . add ( identToAdd ) ; 
 } 
 
 - protected LexicalFrame getParent ( ) { 
 + protected AbstractFrame getParent ( ) { 
 return parent ; 
 } 
 
 + protected String getFrameName ( ) { 
 + return frameName ; 
 + } 
 + 
 / * * Check whether the frame contains a given name . 
 * @ param nameToFind the IDENT ast of the name we ' re looking for 
 * @ return whether it was found 
 @ @ - 428 , 14 + 491 , 14 @ @ public class RequireThisCheck extends Check { 
 * @ param lookForMethod whether we are looking for a method name . 
 * @ return whether it was found . 
 * / 
 - protected LexicalFrame getIfContains ( DetailAST nameToFind , boolean lookForMethod ) { 
 - LexicalFrame frame = null ; 
 + protected AbstractFrame getIfContains ( DetailAST nameToFind , boolean lookForMethod ) { 
 + AbstractFrame frame ; 
 
 if ( ! lookForMethod 
 & & contains ( nameToFind ) ) { 
 frame = this ; 
 } 
 - else if ( parent ! = null ) { 
 + else { 
 frame = parent . getIfContains ( nameToFind , lookForMethod ) ; 
 } 
 return frame ; 
 @ @ - 490 , 40 + 553 , 29 @ @ public class RequireThisCheck extends Check { 
 } 
 
 / * * 
 - * The global frame ; should hold only class names . 
 - * @ author Stephen Bloch 
 - * / 
 - private static class GlobalFrame extends LexicalFrame { 
 - 
 - / * * 
 - * Constructor for the root of the FrameTree . 
 - * / 
 - protected GlobalFrame ( ) { 
 - super ( null ) ; 
 - } 
 - } 
 - 
 - / * * 
 * A frame initiated at method definition ; holds parameter names . 
 * @ author Stephen Bloch 
 * / 
 - private static class MethodFrame extends LexicalFrame { 
 + private static class MethodFrame extends AbstractFrame { 
 / * * 
 * Creates method frame . 
 * @ param parent parent frame 
 * / 
 - protected MethodFrame ( LexicalFrame parent ) { 
 - super ( parent ) ; 
 + protected MethodFrame ( AbstractFrame parent ) { 
 + super ( parent , null ) ; 
 + } 
 + 
 + @ Override 
 + protected FrameType getType ( ) { 
 + return FrameType . METHOD _ FRAME ; 
 } 
 } 
 
 / * * 
 - * A frame initiated at class definition ; holds instance variable 
 - * names . For the present , I ' m not worried about other class names , 
 - * method names , etc . 
 + * A frame initiated at class < enum or interface definition ; holds instance variable names . 
 * @ author Stephen Bloch 
 * / 
 - private static class ClassFrame extends LexicalFrame { 
 + private static class ClassFrame extends AbstractFrame { 
 / * * Set of idents of instance members declared in this frame . * / 
 private final Set < DetailAST > instanceMembers ; 
 / * * Set of idents of instance methods declared in this frame . * / 
 @ @ - 536 , 15 + 588 , 21 @ @ public class RequireThisCheck extends Check { 
 / * * 
 * Creates new instance of ClassFrame . 
 * @ param parent parent frame 
 + * @ param frameName frame name 
 * / 
 - ClassFrame ( LexicalFrame parent ) { 
 - super ( parent ) ; 
 + ClassFrame ( AbstractFrame parent , String frameName ) { 
 + super ( parent , frameName ) ; 
 instanceMembers = Sets . newHashSet ( ) ; 
 instanceMethods = Sets . newHashSet ( ) ; 
 staticMembers = Sets . newHashSet ( ) ; 
 staticMethods = Sets . newHashSet ( ) ; 
 } 
 
 + @ Override 
 + protected FrameType getType ( ) { 
 + return FrameType . CLASS _ FRAME ; 
 + } 
 + 
 / * * 
 * Adds static member ' s ident . 
 * @ param ident an ident of static member of the class 
 @ @ - 599 , 8 + 657 , 7 @ @ public class RequireThisCheck extends Check { 
 
 @ Override 
 boolean contains ( DetailAST nameToFind ) { 
 - return super . contains ( nameToFind ) 
 - | | containsName ( instanceMembers , nameToFind ) 
 + return containsName ( instanceMembers , nameToFind ) 
 | | containsName ( instanceMethods , nameToFind ) 
 | | containsName ( staticMembers , nameToFind ) 
 | | containsName ( staticMethods , nameToFind ) ; 
 @ @ - 613 , 13 + 670 , 13 @ @ public class RequireThisCheck extends Check { 
 } 
 
 @ Override 
 - protected LexicalFrame getIfContains ( DetailAST nameToFind , boolean lookForMethod ) { 
 - LexicalFrame frame ; 
 + protected AbstractFrame getIfContains ( DetailAST nameToFind , boolean lookForMethod ) { 
 + AbstractFrame frame = null ; 
 
 if ( contains ( nameToFind ) ) { 
 frame = this ; 
 } 
 - else { 
 + else if ( getParent ( ) ! = null ) { 
 frame = getParent ( ) . getIfContains ( nameToFind , lookForMethod ) ; 
 } 
 return frame ; 
 @ @ - 627 , 19 + 684 , 22 @ @ public class RequireThisCheck extends Check { 
 } 
 
 / * * 
 - * A frame initiated on entering a statement list ; holds local variable 
 - * names . For the present , I ' m not worried about other class names , 
 - * method names , etc . 
 + * A frame initiated on entering a statement list ; holds local variable names . 
 * @ author Stephen Bloch 
 * / 
 - private static class BlockFrame extends LexicalFrame { 
 + private static class BlockFrame extends AbstractFrame { 
 
 / * * 
 * Creates block frame . 
 * @ param parent parent frame 
 * / 
 - protected BlockFrame ( LexicalFrame parent ) { 
 - super ( parent ) ; 
 + protected BlockFrame ( AbstractFrame parent ) { 
 + super ( parent , null ) ; 
 + } 
 + 
 + @ Override 
 + protected FrameType getType ( ) { 
 + return FrameType . BLOCK _ FRAME ; 
 } 
 } 
 } 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages . properties 
 index 317e8b8 . . 8057bfe 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages . properties 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages . properties 
 @ @ - 42 , 8 + 42 , 8 @ @ redundant . throws . classInfo = Unable to get class information for { 0 } . 
 redundant . throws . duplicate = Redundant throws : ' ' { 0 } ' ' listed more then one time . 
 redundant . throws . subclass = Redundant throws : ' ' { 0 } ' ' is subclass of ' ' { 1 } ' ' . 
 redundant . throws . unchecked = Redundant throws : ' ' { 0 } ' ' is unchecked exception . 
 - require . this . variable = Reference to instance variable ' ' { 0 } ' ' needs \ " this . \ " . 
 - require . this . method = Method call to ' ' { 0 } ' ' needs \ " this . \ " . 
 + require . this . variable = Reference to instance variable ' ' { 0 } ' ' needs \ " { 1 } this . \ " . 
 + require . this . method = Method call to ' ' { 0 } ' ' needs \ " { 1 } this . \ " . 
 return . count = Return count is { 0 , number , integer } ( max allowed is { 1 , number , integer } ) . 
 simplify . boolReturn = Conditional logic can be removed . 
 simplify . expression = Expression can be simplified . 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ de . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ de . properties 
 index 53d683d . . e2f6c1b 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ de . properties 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ de . properties 
 @ @ - 42 , 8 + 42 , 8 @ @ redundant . throws . classInfo = Klassen - Information f ü r { 0 } nicht verf ü gbar . 
 redundant . throws . duplicate = Ü berfl ü ssige throws - Deklaration : ' ' { 0 } ' ' ist mehrfach aufgef ü hrt . 
 redundant . throws . subclass = Ü berfl ü ssige throws - Deklaration : ' ' { 0 } ' ' ist Unterklasse von ' ' { 1 } ' ' . 
 redundant . throws . unchecked = Ü berfl ü ssige throws - Deklaration : ' ' { 0 } ' ' ist eine unchecked Exception ( abgeleitet von RuntimeException ) . 
 - require . this . variable = Dereferenzierung der Instanzvariable ' ' { 0 } ' ' muss ü ber \ " this . \ " erfolgen . 
 - require . this . method = Methodenaufruf ' ' { 0 } ' ' muss ü ber \ " this . \ " erfolgen . 
 + require . this . variable = Dereferenzierung der Instanzvariable ' ' { 0 } ' ' muss ü ber \ " { 1 } this . \ " erfolgen . 
 + require . this . method = Methodenaufruf ' ' { 0 } ' ' muss ü ber \ " { 1 } this . \ " erfolgen . 
 return . count = { 0 , number , integer } return - Anweisungen ( Obergrenze ist { 1 , number , integer } ) . 
 simplify . boolReturn = Die Verzweigung sollte entfernt werden . 
 simplify . expression = Der Ausdruck kann vereinfacht werden . 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ es . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ es . properties 
 index e592c66 . . 7cc533e 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ es . properties 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ es . properties 
 @ @ - 60 , 8 + 60 , 8 @ @ explicit . init = La variable ' ' { 0 } ' ' se inicializa explicitamente a ' ' { 1 } ' ' ( valor 
 default . comes . last = La etiqueta default debe ser la ú ltima etiqueta en el switch . 
 missing . ctor = La clase deber í a definir un constructor . 
 fall . through = Ca í da desde la etiqueta anterior en la sentencia switch . 
 - require . this . variable = La referencia a la variable de instancia ' ' { 0 } ' ' necesita \ " this . \ " . 
 - require . this . method = La llamada al m é todo ' ' { 0 } ' ' necesita \ " this . \ " . 
 + require . this . variable = La referencia a la variable de instancia ' ' { 0 } ' ' necesita \ " { 1 } this . \ " . 
 + require . this . method = La llamada al m é todo ' ' { 0 } ' ' necesita \ " { 1 } this . \ " . 
 multiple . variable . declarations = S ó lo se permite una definici ó n de variable por l í nea . 
 multiple . variable . declarations . comma = Cada declaraci ó n de variable debe estar en su l í nea . 
 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fi . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fi . properties 
 index 4bbadef . . 14ea08a 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fi . properties 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fi . properties 
 @ @ - 54 , 8 + 54 , 8 @ @ multiple . variable . declarations . comma = Jokainen muuttuja ilmoitus on oltava oman 
 nested . for . depth = Sis ä kk ä isi ä syvyys on { 0 , numero , kokonaisluku } ( max sallittu on { 1 , numero , kokonaisluku } ) . 
 parameter . assignment = Teht ä v ä parametrin ' ' { 0 } ' ' ei ole sallittu . 
 redundant . throws . classInfo = Ei saada luokan tietoa { 0 } . 
 - require . this . variable = Viittaus Esimerkiksi muuttuja ' ' { 0 } ' ' tarvitsee \ " t ä m ä . \ " . 
 - require . this . method = Menetelm ä kehotus ' ' { 0 } ' ' tarvitsee \ " t ä m ä . \ " . 
 + require . this . variable = Viittaus Esimerkiksi muuttuja ' ' { 0 } ' ' tarvitsee \ " { 1 } this . \ " . 
 + require . this . method = Menetelm ä kehotus ' ' { 0 } ' ' tarvitsee \ " { 1 } this . \ " . 
 return . count = Paluu m ä ä r ä on { 0 , numero , kokonaisluku } ( max sallittu on { 1 , numero , kokonaisluku } ) . 
 string . literal . equality = Kirjaimellinen Strings pit ä isi verrata k ä ytt ä m ä ll ä tasavertaisten ( ) , ei ' ' { 0 } ' ' . 
 unnecessary . paren . assign = Tarpeettomia sulkuja noin teht ä v ä n oikealla puolella . 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fr . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fr . properties 
 index e74c9e6 . . af2e8a0 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fr . properties 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ fr . properties 
 @ @ - 60 , 8 + 60 , 8 @ @ explicit . init = L ' ' initialisation explicite de la variable ' ' { 0 } ' ' à la valeur ' ' 
 default . comes . last = Le cas \ " default \ " devrait apparaitre en dernier dans le bloc \ " switch \ " . 
 missing . ctor = Il manque un constructeur à la classe . 
 fall . through = Le cas pr é c é dent du \ " switch \ " ne contient pas de break , return , throw ou continue . 
 - require . this . variable = La r é f é rence à la variable d ' ' instance ' ' { 0 } ' ' doit utiliser \ " this . \ " . 
 - require . this . method = L ' ' appel à la m é thode ' ' { 0 } ' ' n é cessite l ' ' utilisation de \ " this . \ " . 
 + require . this . variable = La r é f é rence à la variable d ' ' instance ' ' { 0 } ' ' doit utiliser \ " { 1 } this . \ " . 
 + require . this . method = L ' ' appel à la m é thode ' ' { 0 } ' ' n é cessite l ' ' utilisation de \ " { 1 } this . \ " . 
 multiple . variable . declarations = Ne d é clarez pas plus d ' ' une variable par ligne . 
 multiple . variable . declarations . comma = Chaque d é claration de variable doit faire l ' ' objet d ' ' une instruction à part . 
 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ ja . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ ja . properties 
 index de9bf55 . . 20c5932 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ ja . properties 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ ja . properties 
 @ @ - 67 , 8 + 67 , 8 @ @ multiple . string . literal = 文 字 列 { 0 } は 、 こ の フ ァ イ ル に { 1 } に 出 
 multiple . variable . declarations = 行 に 1 つ の 変 数 定 義 だ け が 許 可 さ れ ま す 。 
 multiple . variable . declarations . comma = 各 変 数 の 宣 言 に は 、 独 自 の ス テ ー ト メ ン ト で な け れ ば な り ま せ ん 。 
 nested . for . depth = 入 れ 子 の for の 深 さ { 0 , number , integer } （ 許 可 さ れ た 最 大 値 は { 1 , number , integer } ) 。 
 - require . this . variable = イ ン ス タ ン ス 変 数 ' ' { 0 } ' ' へ の 参 照 に は \ " this \ " が 必 要 で す 。 
 - require . this . method = メ ソ ッ ド ' ' { 0 } ' ' へ の 呼 び 出 し は 、 \ " this \ " が 必 要 で す 。 
 + require . this . variable = イ ン ス タ ン ス 変 数 ' ' { 0 } ' ' へ の 参 照 に は \ " { 1 } this . \ " が 必 要 で す 。 
 + require . this . method = メ ソ ッ ド ' ' { 0 } ' ' へ の 呼 び 出 し は 、 \ " { 1 } this . \ " が 必 要 で す 。 
 unnecessary . paren . assign = 代 入 右 辺 の 周 り に 不 要 な 括 弧 。 
 unnecessary . paren . expr = 式 の 周 り の 不 要 な 括 弧 。 
 unnecessary . paren . ident = 識 別 子 の 前 後 に 不 要 な 括 弧 ' ' { 0 } ' ' 。 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ pt . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ pt . properties 
 index b8a19b1 . . ffd8593 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ pt . properties 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ pt . properties 
 @ @ - 47 , 8 + 47 , 8 @ @ multiple . string . literal = The String { 0 } aparece { 1 } vezes no arquivo . 
 multiple . variable . declarations = Apenas uma defini ç ã o de vari á vel por linha permitidos . 
 multiple . variable . declarations . comma = Cada declara ç ã o de vari á vel deve estar em sua pr ó pria declara ç ã o . 
 nested . for . depth = Aninhado para a profundidade é { 0 , number , integer } ( m á ximo permitido é { 1 , number , integer } ) . 
 - require . this . variable = Refer ê ncia a vari á vel de inst â ncia ' ' { 0 } ' ' precisa de \ " isso . \ " . 
 - require . this . method = Chamada de m é todo para ' ' { 0 } ' ' precisa de \ " isso . \ " . 
 + require . this . variable = Refer ê ncia a vari á vel de inst â ncia ' ' { 0 } ' ' precisa de \ " { 1 } this . \ " . 
 + require . this . method = Chamada de m é todo para ' ' { 0 } ' ' precisa de \ " { 1 } this . \ " . 
 unnecessary . paren . assign = Par ê nteses desnecess á rios ao redor do lado direito atribui ç ã o . 
 unnecessary . paren . expr = Par ê nteses desnecess á rios ao redor express ã o . 
 unnecessary . paren . ident = Par ê nteses desnecess á rios ao redor identificador ' ' { 0 } ' ' . 
 diff - - git a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ tr . properties b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ tr . properties 
 index 285babf . . 5071a1c 100644 
 - - - a / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ tr . properties 
 + + + b / src / main / resources / com / puppycrawl / tools / checkstyle / checks / coding / messages _ tr . properties 
 @ @ - 71 , 8 + 71 , 8 @ @ redundant . throws . duplicate = ' ' throws ' ' ifadesinde ' ' { 0 } ' ' tekrardan kullan ı lm 
 redundant . throws . subclass = ' ' { 0 } ' ' , ' ' { 1 } ' ' s ı n ı f ı n ı n alt s ı n ı f ı d ı r , ' ' throws ' ' kullan ı m ı gereksizdir . 
 redundant . throws . unchecked = ' ' { 0 } ' ' ' ' unchecked ' ' bir istisnad ı r , ' ' throws ' ' kullan ı m ı gereksizdir . 
 
 - require . this . method = ' ' { 0 } ' ' metoduna eri ş im " this . " kullan ı larak yap ı lmal ı d ı r . 
 - require . this . variable = ' ' { 0 } ' ' de ğ i ş kenine eri ş im " this . " kullan ı larak yap ı lmal ı d ı r . 
 + require . this . method = ' ' { 0 } ' ' metoduna eri ş im \ " { 1 } this . \ " kullan ı larak yap ı lmal ı d ı r . 
 + require . this . variable = ' ' { 0 } ' ' de ğ i ş kenine eri ş im \ " { 1 } this . \ " kullan ı larak yap ı lmal ı d ı r . 
 
 return . count = Kullan ı lan ' ' return ' ' say ı s ı { 0 , number , integer } ( maksimum izin verilen de ğ er { 1 , number , integer } ) . 
 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java 
 index d8f9780 . . c27d4b4 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / checks / coding / RequireThisCheckTest . java 
 @ @ - 48 , 15 + 48 , 16 @ @ public class RequireThisCheckTest extends BaseCheckTestSupport { 
 final DefaultConfiguration checkConfig = 
 createCheckConfig ( RequireThisCheck . class ) ; 
 final String [ ] expected = { 
 - " 11 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , 
 - " 17 : 9 : " + getCheckMessage ( MSG _ METHOD , " method1 " , " \ " this \ " " ) , 
 - " 31 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , 
 - " 49 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " \ " this \ " " ) , 
 - " 56 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " \ " this \ " " ) , 
 - " 113 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , 
 - " 114 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , 
 - " 115 : 9 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " \ " this \ " " ) , 
 - " 121 : 13 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " \ " this \ " " ) , 
 + " 11 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , 
 + " 17 : 9 : " + getCheckMessage ( MSG _ METHOD , " method1 " , " " ) , 
 + " 31 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , 
 + " 49 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " " ) , 
 + " 56 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " " ) , 
 + " 113 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , 
 + " 114 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , 
 + " 115 : 9 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " " ) , 
 + " 121 : 13 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " Issue2240 . " ) , 
 + " 122 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " Issue2240 . " ) , 
 } ; 
 verify ( checkConfig , 
 getPath ( " InputRequireThis . java " ) , 
 @ @ - 69 , 9 + 70 , 9 @ @ public class RequireThisCheckTest extends BaseCheckTestSupport { 
 createCheckConfig ( RequireThisCheck . class ) ; 
 checkConfig . addAttribute ( " checkFields " , " false " ) ; 
 final String [ ] expected = { 
 - " 17 : 9 : " + getCheckMessage ( MSG _ METHOD , " method1 " , " \ " this \ " " ) , 
 - " 115 : 9 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " \ " this \ " " ) , 
 - " 121 : 13 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " \ " this \ " " ) , 
 + " 17 : 9 : " + getCheckMessage ( MSG _ METHOD , " method1 " , " " ) , 
 + " 115 : 9 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " " ) , 
 + " 121 : 13 : " + getCheckMessage ( MSG _ METHOD , " instanceMethod " , " Issue2240 . " ) , 
 } ; 
 verify ( checkConfig , 
 getPath ( " InputRequireThis . java " ) , 
 @ @ - 84 , 12 + 85 , 13 @ @ public class RequireThisCheckTest extends BaseCheckTestSupport { 
 createCheckConfig ( RequireThisCheck . class ) ; 
 checkConfig . addAttribute ( " checkMethods " , " false " ) ; 
 final String [ ] expected = { 
 - " 11 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , 
 - " 31 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , 
 - " 49 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " \ " this \ " " ) , 
 - " 56 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " \ " this \ " " ) , 
 - " 113 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , 
 - " 114 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " \ " this \ " " ) , 
 + " 11 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , 
 + " 31 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , 
 + " 49 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " " ) , 
 + " 56 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " z " , " " ) , 
 + " 113 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , 
 + " 114 : 9 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " " ) , 
 + " 122 : 13 : " + getCheckMessage ( MSG _ VARIABLE , " i " , " Issue2240 . " ) , 
 } ; 
 verify ( checkConfig , 
 getPath ( " InputRequireThis . java " ) , 
 @ @ - 109 , 8 + 111 , 8 @ @ public class RequireThisCheckTest extends BaseCheckTestSupport { 
 final DefaultConfiguration checkConfig = 
 createCheckConfig ( RequireThisCheck . class ) ; 
 final String [ ] expected = { 
 - " 7 : 19 : " + getCheckMessage ( MSG _ VARIABLE , " number " , " \ " this \ " " ) , 
 - " 8 : 16 : " + getCheckMessage ( MSG _ METHOD , " other " , " \ " this \ " " ) , 
 + " 7 : 19 : " + getCheckMessage ( MSG _ VARIABLE , " number " , " " ) , 
 + " 8 : 16 : " + getCheckMessage ( MSG _ METHOD , " other " , " " ) , 
 } ; 
 verify ( checkConfig , 
 getPath ( " InputRequireThis2 . java " ) , 
 diff - - git a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputRequireThis . java b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputRequireThis . java 
 index 5cbf936 . . 0fa0b8a 100644 
 - - - a / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputRequireThis . java 
 + + + b / src / test / resources / com / puppycrawl / tools / checkstyle / checks / coding / InputRequireThis . java 
 @ @ - 119 , 6 + 119 , 7 @ @ class Issue2240 { 
 class Nested { 
 void bar ( ) { 
 instanceMethod ( ) ; 
 + i + + ; 
 } 
 } 
 }

NEAREST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java 
 index 6d1857b . . 594f250 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / checks / indentation / CommentsIndentationCheck . java 
 @ @ - 19 , 6 + 19 , 9 @ @ 
 
 package com . puppycrawl . tools . checkstyle . checks . indentation ; 
 
 + import java . util . Locale ; 
 + import java . util . Stack ; 
 + 
 import org . apache . commons . lang3 . ArrayUtils ; 
 
 import com . puppycrawl . tools . checkstyle . api . Check ; 
 @ @ - 62 , 22 + 65 , 18 @ @ import com . puppycrawl . tools . checkstyle . utils . CommonUtils ; 
 * } 
 * < / pre > 
 * 
 - * 
 * @ author < a href = " mailto : nesterenko - aleksey @ list . ru " > Aleksey Nesterenko < / a > 
 * @ author < a href = " mailto : andreyselkin @ gmail . com " > Andrei Selkin < / a > 
 - * 
 * / 
 public class CommentsIndentationCheck extends Check { 
 
 / * * 
 - * A key is pointing to the warning message text in " messages . properties " 
 - * file . 
 + * A key is pointing to the warning message text in " messages . properties " file . 
 * / 
 public static final String MSG _ KEY _ SINGLE = " comments . indentation . single " ; 
 
 / * * 
 - * A key is pointing to the warning message text in " messages . properties " 
 - * file . 
 + * A key is pointing to the warning message text in " messages . properties " file . 
 * / 
 public static final String MSG _ KEY _ BLOCK = " comments . indentation . block " ; 
 
 @ @ - 135 , 17 + 134 , 493 @ @ public class CommentsIndentationCheck extends Check { 
 * @ param singleLineComment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . 
 * / 
 private void visitSingleLineComment ( DetailAST singleLineComment ) { 
 - final DetailAST nextStatement = singleLineComment . getNextSibling ( ) ; 
 - final DetailAST prevStatement = getPrevStatementFromSwitchBlock ( singleLineComment ) ; 
 + final DetailAST prevStmt = getPreviousStatementOfSingleLineComment ( singleLineComment ) ; 
 + final DetailAST nextStmt = singleLineComment . getNextSibling ( ) ; 
 
 - if ( nextStatement ! = null 
 - & & nextStatement . getType ( ) ! = TokenTypes . RCURLY 
 - & & ! isTrailingSingleLineComment ( singleLineComment ) 
 - & & ! areSameLevelIndented ( singleLineComment , prevStatement , nextStatement ) ) { 
 + if ( ! isTrailingSingleLineComment ( singleLineComment ) ) { 
 + if ( isInEmptyCaseBlock ( prevStmt , nextStmt ) ) { 
 + handleSingleLineCommentInEmptyCaseBlock ( prevStmt , singleLineComment , 
 + nextStmt ) ; 
 + } 
 + else if ( isFallThroughSingleLineComment ( prevStmt , nextStmt ) ) { 
 + handleFallThroughtSingleLineComment ( prevStmt , singleLineComment , 
 + nextStmt ) ; 
 + } 
 + else if ( isInEmptyCodeBlock ( prevStmt , nextStmt ) ) { 
 + handleSingleLineCommentInEmptyCodeBlock ( singleLineComment , nextStmt ) ; 
 + } 
 + else if ( isSingleLineCommentAtTheEndOfTheCodeBlock ( nextStmt ) ) { 
 + handleSIngleLineCommentAtTheEndOfTheCodeBlock ( prevStmt , singleLineComment , 
 + nextStmt ) ; 
 + } 
 + else if ( nextStmt ! = null 
 + & & ! areSameLevelIndented ( singleLineComment , nextStmt , nextStmt ) ) { 
 + log ( singleLineComment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , 
 + singleLineComment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Returns the previous statement of a single line comment . 
 + * @ param comment single line comment . 
 + * @ return the previous statement of a single line comment . 
 + * / 
 + private DetailAST getPreviousStatementOfSingleLineComment ( DetailAST comment ) { 
 + final DetailAST prevStatement ; 
 + if ( isDistributedPreviousStatement ( comment ) ) { 
 + prevStatement = getDistributedPreviousStatementOfSingleLineComment ( comment ) ; 
 + } 
 + else { 
 + prevStatement = getOneLinePreviousStatementOfSingleLineComment ( comment ) ; 
 + } 
 + return prevStatement ; 
 + } 
 + 
 + / * * 
 + * Checks whether the previous statement of a single line comment is distributed over two or 
 + * more lines . 
 + * @ param singleLineComment single line comment . 
 + * @ return true if the previous statement of a single line comment is distributed over two or 
 + * more lines . 
 + * / 
 + private boolean isDistributedPreviousStatement ( DetailAST singleLineComment ) { 
 + final DetailAST previousSibling = singleLineComment . getPreviousSibling ( ) ; 
 + return isDistributedMethodChainOrConcatenationStatement ( singleLineComment , previousSibling ) 
 + | | isDistributedReturnStatement ( previousSibling ) 
 + | | isDistributedThrowStatement ( previousSibling ) ; 
 + } 
 + 
 + / * * 
 + * Checks whether the previous statement of a single line comment is a method call chain or 
 + * string concatenation statemen distributed over two ore more lines . 
 + * @ param comment single line comment . 
 + * @ param commentPreviousSibling previous sibling of the sinle line comment . 
 + * @ return if the previous statement of a single line comment is a method call chain or 
 + * string concatenation statemen distributed over two ore more lines . 
 + * / 
 + private static boolean isDistributedMethodChainOrConcatenationStatement ( 
 + DetailAST comment , DetailAST commentPreviousSibling ) { 
 + boolean destributed = false ; 
 + if ( commentPreviousSibling ! = null 
 + & & commentPreviousSibling . getType ( ) = = TokenTypes . SEMI 
 + & & comment . getLineNo ( ) - commentPreviousSibling . getLineNo ( ) = = 1 ) { 
 + DetailAST currentToken = commentPreviousSibling . getPreviousSibling ( ) ; 
 + while ( currentToken . getFirstChild ( ) ! = null ) { 
 + currentToken = currentToken . getFirstChild ( ) ; 
 + } 
 + if ( currentToken . getType ( ) ! = TokenTypes . COMMENT _ CONTENT 
 + & & commentPreviousSibling . getLineNo ( ) ! = currentToken . getLineNo ( ) ) { 
 + destributed = true ; 
 + } 
 + } 
 + return destributed ; 
 + } 
 + 
 + / * * 
 + * Checks whether the previous statement of a single line comment is a destributed return 
 + * statement . 
 + * @ param commentPreviousSibling previous sibling of the single line comment . 
 + * @ return true if the previous statement of a single line comment is a destributed return 
 + * statement . 
 + * / 
 + private static boolean isDistributedReturnStatement ( DetailAST commentPreviousSibling ) { 
 + boolean destributed = false ; 
 + if ( commentPreviousSibling ! = null 
 + & & commentPreviousSibling . getType ( ) = = TokenTypes . LITERAL _ RETURN ) { 
 + final DetailAST firstChild = commentPreviousSibling . getFirstChild ( ) ; 
 + final DetailAST nextSibling = firstChild . getNextSibling ( ) ; 
 + if ( nextSibling ! = null ) { 
 + destributed = true ; 
 + } 
 + } 
 + return destributed ; 
 + } 
 + 
 + / * * 
 + * Checks whether the previous statement of a single line comment is a destributed throw 
 + * statement . 
 + * @ param commentPreviousSibling previous sibling of the single line comment . 
 + * @ return true if the previous statement of a single line comment is a destributed throw 
 + * statement . 
 + * / 
 + private static boolean isDistributedThrowStatement ( DetailAST commentPreviousSibling ) { 
 + boolean destributed = false ; 
 + if ( commentPreviousSibling ! = null 
 + & & commentPreviousSibling . getType ( ) = = TokenTypes . LITERAL _ THROW ) { 
 + final DetailAST firstChild = commentPreviousSibling . getFirstChild ( ) ; 
 + final DetailAST nextSibling = firstChild . getNextSibling ( ) ; 
 + if ( nextSibling . getLineNo ( ) ! = commentPreviousSibling . getLineNo ( ) ) { 
 + destributed = true ; 
 + } 
 + } 
 + return destributed ; 
 + } 
 
 - log ( singleLineComment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStatement . getLineNo ( ) , 
 - singleLineComment . getColumnNo ( ) , nextStatement . getColumnNo ( ) ) ; 
 + / * * 
 + * Returns the first token of the destributed previous statement of single line comment . 
 + * @ param comment single line comment . 
 + * @ return the first token of the destributed previous statement of single line comment . 
 + * / 
 + public static DetailAST getDistributedPreviousStatementOfSingleLineComment ( DetailAST comment ) { 
 + DetailAST previousStatement = comment . getPreviousSibling ( ) ; 
 + if ( previousStatement . getType ( ) = = TokenTypes . LITERAL _ RETURN 
 + | | previousStatement . getType ( ) = = TokenTypes . LITERAL _ THROW ) { 
 + return previousStatement ; 
 + } 
 + previousStatement = previousStatement . getPreviousSibling ( ) ; 
 + while ( previousStatement . getFirstChild ( ) ! = null ) { 
 + previousStatement = previousStatement . getFirstChild ( ) ; 
 } 
 + return previousStatement ; 
 + } 
 + 
 + / * * 
 + * Checks whether case block is empty . 
 + * @ param nextStmt previous statement . 
 + * @ param prevStmt next statement . 
 + * @ return true if case block is empty . 
 + * / 
 + private static boolean isInEmptyCaseBlock ( DetailAST prevStmt , DetailAST nextStmt ) { 
 + return prevStmt ! = null 
 + & & nextStmt ! = null 
 + & & ( prevStmt . getType ( ) = = TokenTypes . LITERAL _ CASE 
 + | | prevStmt . getType ( ) = = TokenTypes . CASE _ GROUP ) 
 + & & ( nextStmt . getType ( ) = = TokenTypes . LITERAL _ CASE 
 + | | nextStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT ) ; 
 + } 
 + 
 + / * * 
 + * Checks whether single line comment is a ' fall through ' comment . 
 + * For example : 
 + * < p > 
 + * { @ code 
 + * . . . 
 + * case OPTION _ ONE : 
 + * int someVariable = 1 ; 
 + * / / fall through 
 + * case OPTION _ TWO : 
 + * int a = 5 ; 
 + * break ; 
 + * . . . 
 + * } 
 + * < / p > 
 + * @ param prevStmt previous statement . 
 + * @ param nextStmt next statement . 
 + * @ return true if a single line comment is a ' fall through ' comment . 
 + * / 
 + private static boolean isFallThroughSingleLineComment ( DetailAST prevStmt , DetailAST nextStmt ) { 
 + return prevStmt ! = null 
 + & & prevStmt . getType ( ) ! = TokenTypes . LITERAL _ CASE 
 + & & nextStmt ! = null 
 + & & ( nextStmt . getType ( ) = = TokenTypes . LITERAL _ CASE 
 + | | nextStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT ) ; 
 + } 
 + 
 + / * * 
 + * Checks whether a single line comment is placed at the end of the code block . 
 + * @ param nextStmt next statement . 
 + * @ return true if a single line comment is placed at the end of the block . 
 + * / 
 + private boolean isSingleLineCommentAtTheEndOfTheCodeBlock ( DetailAST nextStmt ) { 
 + return nextStmt ! = null 
 + & & nextStmt . getType ( ) = = TokenTypes . RCURLY ; 
 + } 
 + 
 + / * * 
 + * Checks whether comment is placed in the empty code block . 
 + * For example : 
 + * < p > 
 + * . . . 
 + * { @ code 
 + * / / empty code block 
 + * } 
 + * . . . 
 + * < / p > 
 + * Note , the method does not treat empty case blocks . 
 + * @ param prevStmt previous statement . 
 + * @ param nextStmt next statement . 
 + * @ return true if comment is placed in the empty code block . 
 + * / 
 + private boolean isInEmptyCodeBlock ( DetailAST prevStmt , DetailAST nextStmt ) { 
 + return prevStmt ! = null 
 + & & nextStmt ! = null 
 + & & ( prevStmt . getType ( ) = = TokenTypes . SLIST 
 + | | prevStmt . getType ( ) = = TokenTypes . OBJBLOCK ) 
 + & & nextStmt . getType ( ) = = TokenTypes . RCURLY ; 
 + } 
 + 
 + / * * 
 + * Handles a single line comment which is plased within empty case block . 
 + * Note , if comment is placed at the end of the empty case block , we have Checkstyle ' s 
 + * limitations to clearly detect user intention of explanation target - above or below . The 
 + * only case we can assume as a violation is when a single line comment within the empty case 
 + * block has indentation level that is lower than the indentation level of the next case 
 + * token . For example : 
 + * < p > 
 + * { @ code 
 + * . . . 
 + * case OPTION _ ONE : 
 + * / / violation 
 + * case OPTION _ TWO : 
 + * . . . 
 + * } 
 + * < / p > 
 + * @ param prevStmt previous statement . 
 + * @ param comment single line comment . 
 + * @ param nextStmt next statement . 
 + * / 
 + private void handleSingleLineCommentInEmptyCaseBlock ( DetailAST prevStmt , DetailAST comment , 
 + DetailAST nextStmt ) { 
 + 
 + if ( comment . getColumnNo ( ) < prevStmt . getColumnNo ( ) 
 + | | comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { 
 + logMultilineIndentation ( prevStmt , comment , nextStmt ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Handles ' fall through ' single line comment . 
 + * Note , ' fall through ' and similar comments can have indentation level as next or previous 
 + * statement . 
 + * For example : 
 + * < p > 
 + * { @ code 
 + * . . . 
 + * case OPTION _ ONE : 
 + * int someVariable = 1 ; 
 + * / / fall through - OK 
 + * case OPTION _ TWO : 
 + * int a = 5 ; 
 + * break ; 
 + * . . . 
 + * } 
 + * < / p > 
 + * < p > 
 + * { @ code 
 + * . . . 
 + * case OPTION _ ONE : 
 + * int someVariable = 1 ; 
 + * / / than init variable a - OK 
 + * case OPTION _ TWO : 
 + * int a = 5 ; 
 + * break ; 
 + * . . . 
 + * } 
 + * < / p > 
 + * @ param prevStmt previous statement . 
 + * @ param comment single line comment . 
 + * @ param nextStmt next statement . 
 + * / 
 + private void handleFallThroughtSingleLineComment ( DetailAST prevStmt , DetailAST comment , 
 + DetailAST nextStmt ) { 
 + 
 + if ( ! areSameLevelIndented ( comment , prevStmt , nextStmt ) ) { 
 + logMultilineIndentation ( prevStmt , comment , nextStmt ) ; 
 + } 
 + 
 + } 
 + 
 + / * * 
 + * Hendles a single line comment which is placed at the end of non empty code block . 
 + * Note , if single line comment is plcaed at the end of non empty block the comment should have 
 + * the same indentation level as the previous statement . For example : 
 + * < p > 
 + * { @ code 
 + * if ( a = = true ) { 
 + * int b = 1 ; 
 + * / / comment 
 + * } 
 + * } 
 + * < / p > 
 + * @ param prevStmt previous statement . 
 + * @ param comment single line statement . 
 + * @ param nextStmt next statement . 
 + * / 
 + private void handleSIngleLineCommentAtTheEndOfTheCodeBlock ( DetailAST prevStmt , 
 + DetailAST comment , 
 + DetailAST nextStmt ) { 
 + if ( prevStmt ! = null ) { 
 + if ( prevStmt . getType ( ) = = TokenTypes . LITERAL _ CASE 
 + | | prevStmt . getType ( ) = = TokenTypes . CASE _ GROUP 
 + | | prevStmt . getType ( ) = = TokenTypes . LITERAL _ DEFAULT 
 + | | prevStmt . getType ( ) = = TokenTypes . SINGLE _ LINE _ COMMENT ) { 
 + if ( comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { 
 + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , 
 + comment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; 
 + } 
 + } 
 + else if ( ! areSameLevelIndented ( comment , prevStmt , prevStmt ) ) { 
 + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , prevStmt . getLineNo ( ) , 
 + comment . getColumnNo ( ) , prevStmt . getColumnNo ( ) ) ; 
 + } 
 + } 
 + 
 + } 
 + 
 + / * * 
 + * Handles a single line comment which is placed within the empty code block . 
 + * Note , if comment is placed at the end of the empty code block , we have Checkstyle ' s 
 + * limitations to clearly detect user intention of explanation target - above or below . The 
 + * only case we can assume as a violation is when a single line comment within the empty 
 + * code block has indentation level that is lower than the indentation level of the closing 
 + * right curly brace . For example : 
 + * < p > 
 + * { @ code 
 + * if ( a = = true ) { 
 + * / / violation 
 + * } 
 + * } 
 + * < / p > 
 + * 
 + * @ param comment single line comment . 
 + * @ param nextStmt next statement . 
 + * / 
 + private void handleSingleLineCommentInEmptyCodeBlock ( DetailAST comment , DetailAST nextStmt ) { 
 + if ( comment . getColumnNo ( ) < nextStmt . getColumnNo ( ) ) { 
 + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , nextStmt . getLineNo ( ) , 
 + comment . getColumnNo ( ) , nextStmt . getColumnNo ( ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * Does pre - order traverse of abstract syntax tree to find the previous statement of the 
 + * single line comment . If previous statement of the comment is found , then the traverse will 
 + * be finished . 
 + * @ param comment current statement . 
 + * @ return previous statement of the comment or null if the comment does not have previous 
 + * statement . 
 + * / 
 + private static DetailAST getOneLinePreviousStatementOfSingleLineComment ( DetailAST comment ) { 
 + final Stack < DetailAST > stack = new Stack < > ( ) ; 
 + DetailAST root = comment . getParent ( ) ; 
 + 
 + while ( root ! = null | | ! stack . empty ( ) ) { 
 + if ( ! stack . empty ( ) ) { 
 + root = stack . pop ( ) ; 
 + } 
 + while ( root ! = null ) { 
 + final DetailAST previousStatement = 
 + findPreviousStatementOfSingleLineComment ( comment , root ) ; 
 + if ( previousStatement ! = null ) { 
 + return previousStatement ; 
 + } 
 + if ( root . getNextSibling ( ) ! = null ) { 
 + stack . push ( root . getNextSibling ( ) ) ; 
 + } 
 + root = root . getFirstChild ( ) ; 
 + } 
 + } 
 + return null ; 
 + } 
 + 
 + / * * 
 + * Finds a previous statement of the single line comment . 
 + * Uses root token of the line while searching . 
 + * @ param comment single line comment . 
 + * @ param root root token of the line . 
 + * @ return previous statement of the single line comment or null if previous statement was not 
 + * found . 
 + * / 
 + private static DetailAST findPreviousStatementOfSingleLineComment ( DetailAST comment , 
 + DetailAST root ) { 
 + DetailAST previousStatement = null ; 
 + if ( root . getLineNo ( ) > = comment . getLineNo ( ) ) { 
 + / / ATTENTION : parent of the comment is below the comment in case block 
 + / / See https : / / github . com / checkstyle / checkstyle / issues / 851 
 + previousStatement = getPrevStatementFromSwitchBlock ( comment ) ; 
 + } 
 + final DetailAST tokenWhichBeginsTheLine ; 
 + if ( root . getType ( ) = = TokenTypes . EXPR 
 + & & root . getFirstChild ( ) . getFirstChild ( ) ! = null ) { 
 + if ( root . getFirstChild ( ) . getType ( ) = = TokenTypes . LITERAL _ NEW ) { 
 + tokenWhichBeginsTheLine = root . getFirstChild ( ) ; 
 + } 
 + else { 
 + tokenWhichBeginsTheLine = findTokenWhichBeginsTheLine ( root ) ; 
 + } 
 + } 
 + else if ( root . getType ( ) = = TokenTypes . PLUS ) { 
 + tokenWhichBeginsTheLine = root . getFirstChild ( ) ; 
 + } 
 + else { 
 + tokenWhichBeginsTheLine = root ; 
 + } 
 + if ( tokenWhichBeginsTheLine ! = null 
 + & & isOnPreviousLine ( comment , tokenWhichBeginsTheLine ) ) { 
 + previousStatement = tokenWhichBeginsTheLine ; 
 + } 
 + return previousStatement ; 
 + } 
 + 
 + / * * 
 + * Finds a token which begins the line . 
 + * @ param root root token of the line . 
 + * @ return token which begins the line . 
 + * / 
 + private static DetailAST findTokenWhichBeginsTheLine ( DetailAST root ) { 
 + DetailAST tokenWhichBeginsTheLine ; 
 + if ( isUsingOfObjectReferenceToInvokeMethod ( root ) ) { 
 + tokenWhichBeginsTheLine = findStartTokenOfMethodCallChain ( root ) ; 
 + } 
 + else { 
 + tokenWhichBeginsTheLine = root . getFirstChild ( ) . findFirstToken ( TokenTypes . IDENT ) ; 
 + } 
 + return tokenWhichBeginsTheLine ; 
 + } 
 + 
 + / * * 
 + * Checks whether there is a use of an object reference to invoke an object ' s method on line . 
 + * @ param root root token of the line . 
 + * @ return true if there is a use of an object reference to invoke an object ' s method on line . 
 + * / 
 + private static boolean isUsingOfObjectReferenceToInvokeMethod ( DetailAST root ) { 
 + return root . getFirstChild ( ) . getFirstChild ( ) . getFirstChild ( ) ! = null 
 + & & root . getFirstChild ( ) . getFirstChild ( ) . getFirstChild ( ) . getNextSibling ( ) ! = null ; 
 + } 
 + 
 + / * * 
 + * Finds the start token of method call chain . 
 + * @ param root root token of the line . 
 + * @ return the start token of method call chain . 
 + * / 
 + private static DetailAST findStartTokenOfMethodCallChain ( DetailAST root ) { 
 + DetailAST startOfMethodCallChain = root ; 
 + while ( startOfMethodCallChain . getFirstChild ( ) ! = null 
 + & & startOfMethodCallChain . getFirstChild ( ) . getLineNo ( ) = = root . getLineNo ( ) ) { 
 + startOfMethodCallChain = startOfMethodCallChain . getFirstChild ( ) ; 
 + } 
 + if ( startOfMethodCallChain . getFirstChild ( ) ! = null ) { 
 + startOfMethodCallChain = startOfMethodCallChain . getFirstChild ( ) . getNextSibling ( ) ; 
 + } 
 + return startOfMethodCallChain ; 
 + } 
 + 
 + / * * 
 + * Checks whether the checked statement is on previous line . 
 + * @ param currentStatement current statement . 
 + * @ param checkedStatement checked statement . 
 + * @ return true if checked statement is on the line which is previous to current statement . 
 + * / 
 + private static boolean isOnPreviousLine ( DetailAST currentStatement , 
 + DetailAST checkedStatement ) { 
 + return currentStatement . getLineNo ( ) - checkedStatement . getLineNo ( ) = = 1 ; 
 + } 
 + 
 + / * * 
 + * Logs comment which can have the same indentation level as next or previous statement . 
 + * @ param comment comment . 
 + * @ param nextStmt previous statement . 
 + * @ param prevStmt next statement . 
 + * / 
 + private void logMultilineIndentation ( DetailAST prevStmt , DetailAST comment , 
 + DetailAST nextStmt ) { 
 + final String multilineNoTemplate = " % d , % d " ; 
 + log ( comment . getLineNo ( ) , MSG _ KEY _ SINGLE , 
 + String . format ( Locale . getDefault ( ) , multilineNoTemplate , prevStmt . getLineNo ( ) , 
 + nextStmt . getLineNo ( ) ) , comment . getColumnNo ( ) , 
 + String . format ( Locale . getDefault ( ) , multilineNoTemplate , prevStmt . getColumnNo ( ) , 
 + nextStmt . getColumnNo ( ) ) ) ; 
 } 
 
 / * * 
 @ @ - 181 , 10 + 656 , 20 @ @ public class CommentsIndentationCheck extends Check { 
 blockBody = blockBody . getPreviousSibling ( ) ; 
 } 
 if ( blockBody . getType ( ) = = TokenTypes . EXPR ) { 
 - prevStmt = blockBody . getFirstChild ( ) . getFirstChild ( ) ; 
 + if ( isUsingOfObjectReferenceToInvokeMethod ( blockBody ) ) { 
 + prevStmt = findStartTokenOfMethodCallChain ( blockBody ) ; 
 + } 
 + else { 
 + prevStmt = blockBody . getFirstChild ( ) . getFirstChild ( ) ; 
 + } 
 } 
 else { 
 - prevStmt = blockBody ; 
 + if ( blockBody . getType ( ) = = TokenTypes . SLIST ) { 
 + prevStmt = blockBody . getParent ( ) . getParent ( ) ; 
 + } 
 + else { 
 + prevStmt = blockBody ; 
 + } 
 } 
 } 
 return prevStmt ; 
 @ @ - 199 , 10 + 684 , 9 @ @ public class CommentsIndentationCheck extends Check { 
 final DetailAST prevCaseToken ; 
 final DetailAST parentBlock = parentStatement . getParent ( ) ; 
 if ( parentBlock ! = null & & parentBlock . getParent ( ) ! = null 
 - & & parentBlock . getParent ( ) . getPreviousSibling ( ) ! = null 
 - & & parentBlock . getParent ( ) . getPreviousSibling ( ) 
 - . getType ( ) = = TokenTypes . LITERAL _ CASE ) { 
 - 
 + & & parentBlock . getParent ( ) . getPreviousSibling ( ) ! = null 
 + & & parentBlock . getParent ( ) . getPreviousSibling ( ) . getType ( ) 
 + = = TokenTypes . LITERAL _ CASE ) { 
 prevCaseToken = parentBlock . getParent ( ) . getPreviousSibling ( ) ; 
 } 
 else { 
 @ @ - 229 , 20 + 713 , 20 @ @ public class CommentsIndentationCheck extends Check { 
 * } 
 * < / pre > 
 * < / p > 
 - * @ param singleLineComment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . 
 + * @ param comment { @ link TokenTypes # SINGLE _ LINE _ COMMENT single line comment } . 
 * @ param prevStmt previous code statement . 
 * @ param nextStmt next code statement . 
 * @ return true if comment and next code statement are indented at the same level . 
 * / 
 - private static boolean areSameLevelIndented ( DetailAST singleLineComment , 
 - DetailAST prevStmt , DetailAST nextStmt ) { 
 + private static boolean areSameLevelIndented ( DetailAST comment , DetailAST prevStmt , 
 + DetailAST nextStmt ) { 
 boolean result ; 
 if ( prevStmt = = null ) { 
 - result = singleLineComment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) ; 
 + result = comment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) ; 
 } 
 else { 
 - result = singleLineComment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) 
 - | | singleLineComment . getColumnNo ( ) = = prevStmt . getColumnNo ( ) ; 
 + result = comment . getColumnNo ( ) = = nextStmt . getColumnNo ( ) 
 + | | comment . getColumnNo ( ) = = prevStmt . getColumnNo ( ) ; 
 } 
 return result ; 
 } 
 @ @ - 280 , 10 + 764 , 9 @ @ public class CommentsIndentationCheck extends Check { 
 final DetailAST prevStatement = getPrevStatementFromSwitchBlock ( blockComment ) ; 
 
 if ( nextStatement ! = null 
 - & & nextStatement . getType ( ) ! = TokenTypes . RCURLY 
 - & & ! isTrailingBlockComment ( blockComment ) 
 - & & ! areSameLevelIndented ( blockComment , prevStatement , nextStatement ) ) { 
 - 
 + & & nextStatement . getType ( ) ! = TokenTypes . RCURLY 
 + & & ! isTrailingBlockComment ( blockComment ) 
 + & & ! areSameLevelIndented ( blockComment , prevStatement , nextStatement ) ) { 
 log ( blockComment . getLineNo ( ) , MSG _ KEY _ BLOCK , nextStatement . getLineNo ( ) , 
 blockComment . getColumnNo ( ) , nextStatement . getColumnNo ( ) ) ; 
 }
