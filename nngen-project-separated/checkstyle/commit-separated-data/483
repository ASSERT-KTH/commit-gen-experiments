BLEU SCORE: 0.09080027618567452

TEST MSG: Issue # 4916 : Adding ability to force load
GENERATED MSG: Issue # 3778 : show exception when failed to instantiate class

TEST DIFF (one line): diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java b / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java <nl> index 6346fc4 . . 2465edc 100644 <nl> - - - a / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java <nl> + + + b / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java <nl> @ @ - 49 , 6 + 49 , 23 @ @ import com . puppycrawl . tools . checkstyle . utils . ModuleReflectionUtils ; <nl> * @ author lkuehne <nl> * / <nl> public class PackageObjectFactory implements ModuleFactory { <nl> + <nl> + / * * <nl> + * Enum class to define loading options . <nl> + * / <nl> + public enum ModuleLoadOption { <nl> + / * * <nl> + * Searching from registred checkstyle modules and from packages given in countructor . <nl> + * * / <nl> + SEARCH _ REGISTERED _ PACKAGES , <nl> + / * * <nl> + * As SEARCH _ REGISTERED _ PACKAGES and also try to load class from all of packages given in <nl> + * constructor . <nl> + * Required for eclipse - cs plugin . <nl> + * * / <nl> + TRY _ IN _ ALL _ REGISTERED _ PACKAGES , <nl> + } <nl> + <nl> / * * Base package of checkstyle modules checks . * / <nl> public static final String BASE _ PACKAGE = " com . puppycrawl . tools . checkstyle " ; <nl> <nl> @ @ - 87 , 6 + 104 , 9 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> / * * Map of third party Checkstyle module names to the set of their fully qualified names . * / <nl> private Map < String , Set < String > > thirdPartyNameToFullModuleNames ; <nl> <nl> + / * * Module load option which defines class search type . * / <nl> + private ModuleLoadOption moduleLoadOption ; <nl> + <nl> static { <nl> fillShortToFullModuleNamesMap ( ) ; <nl> } <nl> @ @ - 98 , 6 + 118 , 18 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> * core and custom modules <nl> * / <nl> public PackageObjectFactory ( Set < String > packageNames , ClassLoader moduleClassLoader ) { <nl> + this ( packageNames , moduleClassLoader , ModuleLoadOption . SEARCH _ REGISTERED _ PACKAGES ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Creates a new { @ code PackageObjectFactory } instance . <nl> + * @ param packageNames the list of package names to use <nl> + * @ param moduleClassLoader class loader used to load Checkstyle <nl> + * core and custom modules <nl> + * @ param moduleLoadOption loading option <nl> + * / <nl> + public PackageObjectFactory ( Set < String > packageNames , ClassLoader moduleClassLoader , <nl> + ModuleLoadOption moduleLoadOption ) { <nl> if ( moduleClassLoader = = null ) { <nl> throw new IllegalArgumentException ( NULL _ LOADER _ MESSAGE ) ; <nl> } <nl> @ @ - 108 , 6 + 140 , 7 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> / / create a copy of the given set , but retain ordering <nl> packages = new LinkedHashSet < > ( packageNames ) ; <nl> this . moduleClassLoader = moduleClassLoader ; <nl> + this . moduleLoadOption = moduleLoadOption ; <nl> } <nl> <nl> / * * <nl> @ @ - 144 , 19 + 177 , 7 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> Object instance = null ; <nl> / / if the name is a simple class name , try to find it in maps at first <nl> if ( ! name . contains ( PACKAGE _ SEPARATOR ) ) { <nl> - / / find the name in hardcode map <nl> - final String fullModuleName = NAME _ TO _ FULL _ MODULE _ NAME . get ( name ) ; <nl> - if ( fullModuleName = = null ) { <nl> - final String fullCheckModuleName = <nl> - NAME _ TO _ FULL _ MODULE _ NAME . get ( name + CHECK _ SUFFIX ) ; <nl> - if ( fullCheckModuleName ! = null ) { <nl> - instance = createObject ( fullCheckModuleName ) ; <nl> - } <nl> - } <nl> - else { <nl> - instance = createObject ( fullModuleName ) ; <nl> - } <nl> - <nl> + instance = createFromStandardCheckSet ( name ) ; <nl> / / find the name in third party map <nl> if ( instance = = null ) { <nl> if ( thirdPartyNameToFullModuleNames = = null ) { <nl> @ @ - 166 , 10 + 187 , 13 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> instance = createObjectFromMap ( name , thirdPartyNameToFullModuleNames ) ; <nl> } <nl> } <nl> - <nl> if ( instance = = null ) { <nl> instance = createObject ( name ) ; <nl> } <nl> + if ( instance = = null <nl> + & & moduleLoadOption = = ModuleLoadOption . TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) { <nl> + instance = createModuleByTryInEachPackage ( name ) ; <nl> + } <nl> if ( instance = = null ) { <nl> String attemptedNames = null ; <nl> if ( ! name . contains ( PACKAGE _ SEPARATOR ) ) { <nl> @ @ - 187 , 6 + 211 , 28 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> } <nl> <nl> / * * <nl> + * Create object from one of Checkstyle module names . <nl> + * @ param name name of module . <nl> + * @ return instance of module . <nl> + * @ throws CheckstyleException if the class fails to instantiate or there are ambiguous classes . <nl> + * / <nl> + private Object createFromStandardCheckSet ( String name ) throws CheckstyleException { <nl> + final String fullModuleName = NAME _ TO _ FULL _ MODULE _ NAME . get ( name ) ; <nl> + Object instance = null ; <nl> + if ( fullModuleName = = null ) { <nl> + final String fullCheckModuleName = <nl> + NAME _ TO _ FULL _ MODULE _ NAME . get ( name + CHECK _ SUFFIX ) ; <nl> + if ( fullCheckModuleName ! = null ) { <nl> + instance = createObject ( fullCheckModuleName ) ; <nl> + } <nl> + } <nl> + else { <nl> + instance = createObject ( fullModuleName ) ; <nl> + } <nl> + return instance ; <nl> + } <nl> + <nl> + / * * <nl> * Create object with the help of the supplied map . <nl> * @ param name name of module . <nl> * @ param map the supplied map . <nl> @ @ - 308 , 6 + 354 , 30 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> } <nl> <nl> / * * <nl> + * Searching to class with given name ( or name concatinated with & quot ; Check & quot ; ) in existing <nl> + * packages . Returns instance if class found or , otherwise , null . <nl> + * @ param name the name of a class . <nl> + * @ return the { @ code Object } created by loader . <nl> + * @ throws CheckstyleException if an error occurs . <nl> + * / <nl> + private Object createModuleByTryInEachPackage ( String name ) throws CheckstyleException { <nl> + final Set < String > possibleNames = packages . stream ( ) <nl> + . map ( packageName - > packageName + PACKAGE _ SEPARATOR + name ) <nl> + . collect ( Collectors . toSet ( ) ) ; <nl> + possibleNames . addAll ( possibleNames . stream ( ) <nl> + . map ( possibleName - > possibleName + CHECK _ SUFFIX ) <nl> + . collect ( Collectors . toSet ( ) ) ) ; <nl> + Object instance = null ; <nl> + for ( String possibleName : possibleNames ) { <nl> + instance = createObject ( possibleName ) ; <nl> + if ( instance ! = null ) { <nl> + break ; <nl> + } <nl> + } <nl> + return instance ; <nl> + } <nl> + <nl> + / * * <nl> * Fill short - to - full module names map . <nl> * / <nl> private static void fillShortToFullModuleNamesMap ( ) { <nl> @ @ - 769 , 4 + 839 , 5 @ @ public class PackageObjectFactory implements ModuleFactory { <nl> NAME _ TO _ FULL _ MODULE _ NAME . put ( " Checker " , BASE _ PACKAGE + " . Checker " ) ; <nl> NAME _ TO _ FULL _ MODULE _ NAME . put ( " TreeWalker " , BASE _ PACKAGE + " . TreeWalker " ) ; <nl> } <nl> + <nl> } <nl> diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java <nl> index 6e53334 . . 13ff802 100644 <nl> - - - a / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java <nl> + + + b / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ package com . puppycrawl . tools . checkstyle ; <nl> import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . AMBIGUOUS _ MODULE _ NAME _ EXCEPTION _ MESSAGE ; <nl> import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . BASE _ PACKAGE ; <nl> import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . CHECK _ SUFFIX ; <nl> + import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . ModuleLoadOption . TRY _ IN _ ALL _ REGISTERED _ PACKAGES ; <nl> import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . NULL _ LOADER _ MESSAGE ; <nl> import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . NULL _ PACKAGE _ MESSAGE ; <nl> import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . PACKAGE _ SEPARATOR ; <nl> @ @ - 53 , 6 + 54 , 7 @ @ import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; <nl> import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; <nl> import com . puppycrawl . tools . checkstyle . api . FileText ; <nl> import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; <nl> + import com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationLocationCheck ; <nl> import com . puppycrawl . tools . checkstyle . internal . utils . CheckUtil ; <nl> <nl> / * * <nl> @ @ - 112 , 6 + 114 , 19 @ @ public class PackageObjectFactoryTest { <nl> } <nl> <nl> @ Test <nl> + public void testCtorNullPackageException3 ( ) { <nl> + final ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; <nl> + try { <nl> + final Object test = new PackageObjectFactory ( Collections . singleton ( null ) , classLoader , <nl> + TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) ; <nl> + fail ( " Exception is expected but got " + test ) ; <nl> + } <nl> + catch ( IllegalArgumentException ex ) { <nl> + assertEquals ( " Invalid exception message " , NULL _ PACKAGE _ MESSAGE , ex . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> public void testMakeObjectFromName ( ) <nl> throws CheckstyleException { <nl> final Checker checker = <nl> @ @ - 225 , 6 + 240 , 69 @ @ public class PackageObjectFactoryTest { <nl> } <nl> <nl> @ Test <nl> + public void testCreateObjectFromFullModuleNamesWithExceptionByBruteForce ( ) { <nl> + final String package1 = BASE _ PACKAGE + " . wrong1 " ; <nl> + final String package2 = BASE _ PACKAGE + " . wrong2 " ; <nl> + final ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; <nl> + final PackageObjectFactory objectFactory = new PackageObjectFactory ( <nl> + new LinkedHashSet < > ( Arrays . asList ( package1 , package2 ) ) , classLoader , <nl> + TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) ; <nl> + final String name = " FooCheck " ; <nl> + final String checkName = name + CHECK _ SUFFIX ; <nl> + try { <nl> + objectFactory . createModule ( name ) ; <nl> + fail ( " Exception is expected " ) ; <nl> + } <nl> + catch ( CheckstyleException ex ) { <nl> + final String attemptedNames = package1 + PACKAGE _ SEPARATOR + name + STRING _ SEPARATOR <nl> + + package2 + PACKAGE _ SEPARATOR + name + STRING _ SEPARATOR <nl> + + checkName + STRING _ SEPARATOR <nl> + + package1 + PACKAGE _ SEPARATOR + checkName + STRING _ SEPARATOR <nl> + + package2 + PACKAGE _ SEPARATOR + checkName ; <nl> + final LocalizedMessage exceptionMessage = new LocalizedMessage ( 0 , <nl> + Definitions . CHECKSTYLE _ BUNDLE , UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE , <nl> + new String [ ] { name , attemptedNames } , null , getClass ( ) , null ) ; <nl> + assertEquals ( " Invalid exception message " , <nl> + exceptionMessage . getMessage ( ) , ex . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testCreateObjectByBruteForce ( ) throws Exception { <nl> + final String className = " Checker " ; <nl> + final Method createModuleByBruteForce = PackageObjectFactory . class . getDeclaredMethod ( <nl> + " createModuleByTryInEachPackage " , String . class ) ; <nl> + createModuleByBruteForce . setAccessible ( true ) ; <nl> + final Checker checker = ( Checker ) createModuleByBruteForce . invoke ( factory , className ) ; <nl> + assertNotNull ( " Checker should not be null when creating module from name " , checker ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCreateCheckByBruteForce ( ) throws Exception { <nl> + final String checkName = " AnnotationLocation " ; <nl> + final Method createModuleByBruteForce = PackageObjectFactory . class . getDeclaredMethod ( <nl> + " createModuleByTryInEachPackage " , String . class ) ; <nl> + final PackageObjectFactory packageObjectFactory = new PackageObjectFactory ( <nl> + new HashSet < > ( Arrays . asList ( BASE _ PACKAGE , BASE _ PACKAGE + " . checks . annotation " ) ) , <nl> + Thread . currentThread ( ) . getContextClassLoader ( ) , TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) ; <nl> + createModuleByBruteForce . setAccessible ( true ) ; <nl> + final AnnotationLocationCheck check = ( AnnotationLocationCheck ) createModuleByBruteForce <nl> + . invoke ( packageObjectFactory , checkName ) ; <nl> + assertNotNull ( " Check should not be null when creating module from name " , check ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCreateCheckWithPartialPackageNameByBruteForce ( ) throws Exception { <nl> + final String checkName = " checks . annotation . AnnotationLocation " ; <nl> + final PackageObjectFactory packageObjectFactory = new PackageObjectFactory ( <nl> + new HashSet < > ( Collections . singletonList ( BASE _ PACKAGE ) ) , <nl> + Thread . currentThread ( ) . getContextClassLoader ( ) , TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) ; <nl> + final AnnotationLocationCheck check = ( AnnotationLocationCheck ) packageObjectFactory <nl> + . createModule ( checkName ) ; <nl> + assertNotNull ( " Check should not be null when creating module from name " , check ) ; <nl> + } <nl> + <nl> + @ Test <nl> @ SuppressWarnings ( " unchecked " ) <nl> public void testGenerateThirdPartyNameToFullModuleNameWithException ( ) throws Exception { <nl> final URLClassLoader classLoader = mock ( URLClassLoader . class ) ;
NEAREST DIFF (one line): diff - - git a / . travis . yml b / . travis . yml <nl> old mode 100755 <nl> new mode 100644

TEST DIFF:
diff - - git a / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java b / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java 
 index 6346fc4 . . 2465edc 100644 
 - - - a / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java 
 + + + b / src / main / java / com / puppycrawl / tools / checkstyle / PackageObjectFactory . java 
 @ @ - 49 , 6 + 49 , 23 @ @ import com . puppycrawl . tools . checkstyle . utils . ModuleReflectionUtils ; 
 * @ author lkuehne 
 * / 
 public class PackageObjectFactory implements ModuleFactory { 
 + 
 + / * * 
 + * Enum class to define loading options . 
 + * / 
 + public enum ModuleLoadOption { 
 + / * * 
 + * Searching from registred checkstyle modules and from packages given in countructor . 
 + * * / 
 + SEARCH _ REGISTERED _ PACKAGES , 
 + / * * 
 + * As SEARCH _ REGISTERED _ PACKAGES and also try to load class from all of packages given in 
 + * constructor . 
 + * Required for eclipse - cs plugin . 
 + * * / 
 + TRY _ IN _ ALL _ REGISTERED _ PACKAGES , 
 + } 
 + 
 / * * Base package of checkstyle modules checks . * / 
 public static final String BASE _ PACKAGE = " com . puppycrawl . tools . checkstyle " ; 
 
 @ @ - 87 , 6 + 104 , 9 @ @ public class PackageObjectFactory implements ModuleFactory { 
 / * * Map of third party Checkstyle module names to the set of their fully qualified names . * / 
 private Map < String , Set < String > > thirdPartyNameToFullModuleNames ; 
 
 + / * * Module load option which defines class search type . * / 
 + private ModuleLoadOption moduleLoadOption ; 
 + 
 static { 
 fillShortToFullModuleNamesMap ( ) ; 
 } 
 @ @ - 98 , 6 + 118 , 18 @ @ public class PackageObjectFactory implements ModuleFactory { 
 * core and custom modules 
 * / 
 public PackageObjectFactory ( Set < String > packageNames , ClassLoader moduleClassLoader ) { 
 + this ( packageNames , moduleClassLoader , ModuleLoadOption . SEARCH _ REGISTERED _ PACKAGES ) ; 
 + } 
 + 
 + / * * 
 + * Creates a new { @ code PackageObjectFactory } instance . 
 + * @ param packageNames the list of package names to use 
 + * @ param moduleClassLoader class loader used to load Checkstyle 
 + * core and custom modules 
 + * @ param moduleLoadOption loading option 
 + * / 
 + public PackageObjectFactory ( Set < String > packageNames , ClassLoader moduleClassLoader , 
 + ModuleLoadOption moduleLoadOption ) { 
 if ( moduleClassLoader = = null ) { 
 throw new IllegalArgumentException ( NULL _ LOADER _ MESSAGE ) ; 
 } 
 @ @ - 108 , 6 + 140 , 7 @ @ public class PackageObjectFactory implements ModuleFactory { 
 / / create a copy of the given set , but retain ordering 
 packages = new LinkedHashSet < > ( packageNames ) ; 
 this . moduleClassLoader = moduleClassLoader ; 
 + this . moduleLoadOption = moduleLoadOption ; 
 } 
 
 / * * 
 @ @ - 144 , 19 + 177 , 7 @ @ public class PackageObjectFactory implements ModuleFactory { 
 Object instance = null ; 
 / / if the name is a simple class name , try to find it in maps at first 
 if ( ! name . contains ( PACKAGE _ SEPARATOR ) ) { 
 - / / find the name in hardcode map 
 - final String fullModuleName = NAME _ TO _ FULL _ MODULE _ NAME . get ( name ) ; 
 - if ( fullModuleName = = null ) { 
 - final String fullCheckModuleName = 
 - NAME _ TO _ FULL _ MODULE _ NAME . get ( name + CHECK _ SUFFIX ) ; 
 - if ( fullCheckModuleName ! = null ) { 
 - instance = createObject ( fullCheckModuleName ) ; 
 - } 
 - } 
 - else { 
 - instance = createObject ( fullModuleName ) ; 
 - } 
 - 
 + instance = createFromStandardCheckSet ( name ) ; 
 / / find the name in third party map 
 if ( instance = = null ) { 
 if ( thirdPartyNameToFullModuleNames = = null ) { 
 @ @ - 166 , 10 + 187 , 13 @ @ public class PackageObjectFactory implements ModuleFactory { 
 instance = createObjectFromMap ( name , thirdPartyNameToFullModuleNames ) ; 
 } 
 } 
 - 
 if ( instance = = null ) { 
 instance = createObject ( name ) ; 
 } 
 + if ( instance = = null 
 + & & moduleLoadOption = = ModuleLoadOption . TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) { 
 + instance = createModuleByTryInEachPackage ( name ) ; 
 + } 
 if ( instance = = null ) { 
 String attemptedNames = null ; 
 if ( ! name . contains ( PACKAGE _ SEPARATOR ) ) { 
 @ @ - 187 , 6 + 211 , 28 @ @ public class PackageObjectFactory implements ModuleFactory { 
 } 
 
 / * * 
 + * Create object from one of Checkstyle module names . 
 + * @ param name name of module . 
 + * @ return instance of module . 
 + * @ throws CheckstyleException if the class fails to instantiate or there are ambiguous classes . 
 + * / 
 + private Object createFromStandardCheckSet ( String name ) throws CheckstyleException { 
 + final String fullModuleName = NAME _ TO _ FULL _ MODULE _ NAME . get ( name ) ; 
 + Object instance = null ; 
 + if ( fullModuleName = = null ) { 
 + final String fullCheckModuleName = 
 + NAME _ TO _ FULL _ MODULE _ NAME . get ( name + CHECK _ SUFFIX ) ; 
 + if ( fullCheckModuleName ! = null ) { 
 + instance = createObject ( fullCheckModuleName ) ; 
 + } 
 + } 
 + else { 
 + instance = createObject ( fullModuleName ) ; 
 + } 
 + return instance ; 
 + } 
 + 
 + / * * 
 * Create object with the help of the supplied map . 
 * @ param name name of module . 
 * @ param map the supplied map . 
 @ @ - 308 , 6 + 354 , 30 @ @ public class PackageObjectFactory implements ModuleFactory { 
 } 
 
 / * * 
 + * Searching to class with given name ( or name concatinated with & quot ; Check & quot ; ) in existing 
 + * packages . Returns instance if class found or , otherwise , null . 
 + * @ param name the name of a class . 
 + * @ return the { @ code Object } created by loader . 
 + * @ throws CheckstyleException if an error occurs . 
 + * / 
 + private Object createModuleByTryInEachPackage ( String name ) throws CheckstyleException { 
 + final Set < String > possibleNames = packages . stream ( ) 
 + . map ( packageName - > packageName + PACKAGE _ SEPARATOR + name ) 
 + . collect ( Collectors . toSet ( ) ) ; 
 + possibleNames . addAll ( possibleNames . stream ( ) 
 + . map ( possibleName - > possibleName + CHECK _ SUFFIX ) 
 + . collect ( Collectors . toSet ( ) ) ) ; 
 + Object instance = null ; 
 + for ( String possibleName : possibleNames ) { 
 + instance = createObject ( possibleName ) ; 
 + if ( instance ! = null ) { 
 + break ; 
 + } 
 + } 
 + return instance ; 
 + } 
 + 
 + / * * 
 * Fill short - to - full module names map . 
 * / 
 private static void fillShortToFullModuleNamesMap ( ) { 
 @ @ - 769 , 4 + 839 , 5 @ @ public class PackageObjectFactory implements ModuleFactory { 
 NAME _ TO _ FULL _ MODULE _ NAME . put ( " Checker " , BASE _ PACKAGE + " . Checker " ) ; 
 NAME _ TO _ FULL _ MODULE _ NAME . put ( " TreeWalker " , BASE _ PACKAGE + " . TreeWalker " ) ; 
 } 
 + 
 } 
 diff - - git a / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java b / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java 
 index 6e53334 . . 13ff802 100644 
 - - - a / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java 
 + + + b / src / test / java / com / puppycrawl / tools / checkstyle / PackageObjectFactoryTest . java 
 @ @ - 22 , 6 + 22 , 7 @ @ package com . puppycrawl . tools . checkstyle ; 
 import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . AMBIGUOUS _ MODULE _ NAME _ EXCEPTION _ MESSAGE ; 
 import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . BASE _ PACKAGE ; 
 import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . CHECK _ SUFFIX ; 
 + import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . ModuleLoadOption . TRY _ IN _ ALL _ REGISTERED _ PACKAGES ; 
 import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . NULL _ LOADER _ MESSAGE ; 
 import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . NULL _ PACKAGE _ MESSAGE ; 
 import static com . puppycrawl . tools . checkstyle . PackageObjectFactory . PACKAGE _ SEPARATOR ; 
 @ @ - 53 , 6 + 54 , 7 @ @ import com . puppycrawl . tools . checkstyle . api . AbstractFileSetCheck ; 
 import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; 
 import com . puppycrawl . tools . checkstyle . api . FileText ; 
 import com . puppycrawl . tools . checkstyle . api . LocalizedMessage ; 
 + import com . puppycrawl . tools . checkstyle . checks . annotation . AnnotationLocationCheck ; 
 import com . puppycrawl . tools . checkstyle . internal . utils . CheckUtil ; 
 
 / * * 
 @ @ - 112 , 6 + 114 , 19 @ @ public class PackageObjectFactoryTest { 
 } 
 
 @ Test 
 + public void testCtorNullPackageException3 ( ) { 
 + final ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
 + try { 
 + final Object test = new PackageObjectFactory ( Collections . singleton ( null ) , classLoader , 
 + TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) ; 
 + fail ( " Exception is expected but got " + test ) ; 
 + } 
 + catch ( IllegalArgumentException ex ) { 
 + assertEquals ( " Invalid exception message " , NULL _ PACKAGE _ MESSAGE , ex . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 public void testMakeObjectFromName ( ) 
 throws CheckstyleException { 
 final Checker checker = 
 @ @ - 225 , 6 + 240 , 69 @ @ public class PackageObjectFactoryTest { 
 } 
 
 @ Test 
 + public void testCreateObjectFromFullModuleNamesWithExceptionByBruteForce ( ) { 
 + final String package1 = BASE _ PACKAGE + " . wrong1 " ; 
 + final String package2 = BASE _ PACKAGE + " . wrong2 " ; 
 + final ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
 + final PackageObjectFactory objectFactory = new PackageObjectFactory ( 
 + new LinkedHashSet < > ( Arrays . asList ( package1 , package2 ) ) , classLoader , 
 + TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) ; 
 + final String name = " FooCheck " ; 
 + final String checkName = name + CHECK _ SUFFIX ; 
 + try { 
 + objectFactory . createModule ( name ) ; 
 + fail ( " Exception is expected " ) ; 
 + } 
 + catch ( CheckstyleException ex ) { 
 + final String attemptedNames = package1 + PACKAGE _ SEPARATOR + name + STRING _ SEPARATOR 
 + + package2 + PACKAGE _ SEPARATOR + name + STRING _ SEPARATOR 
 + + checkName + STRING _ SEPARATOR 
 + + package1 + PACKAGE _ SEPARATOR + checkName + STRING _ SEPARATOR 
 + + package2 + PACKAGE _ SEPARATOR + checkName ; 
 + final LocalizedMessage exceptionMessage = new LocalizedMessage ( 0 , 
 + Definitions . CHECKSTYLE _ BUNDLE , UNABLE _ TO _ INSTANTIATE _ EXCEPTION _ MESSAGE , 
 + new String [ ] { name , attemptedNames } , null , getClass ( ) , null ) ; 
 + assertEquals ( " Invalid exception message " , 
 + exceptionMessage . getMessage ( ) , ex . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testCreateObjectByBruteForce ( ) throws Exception { 
 + final String className = " Checker " ; 
 + final Method createModuleByBruteForce = PackageObjectFactory . class . getDeclaredMethod ( 
 + " createModuleByTryInEachPackage " , String . class ) ; 
 + createModuleByBruteForce . setAccessible ( true ) ; 
 + final Checker checker = ( Checker ) createModuleByBruteForce . invoke ( factory , className ) ; 
 + assertNotNull ( " Checker should not be null when creating module from name " , checker ) ; 
 + } 
 + 
 + @ Test 
 + public void testCreateCheckByBruteForce ( ) throws Exception { 
 + final String checkName = " AnnotationLocation " ; 
 + final Method createModuleByBruteForce = PackageObjectFactory . class . getDeclaredMethod ( 
 + " createModuleByTryInEachPackage " , String . class ) ; 
 + final PackageObjectFactory packageObjectFactory = new PackageObjectFactory ( 
 + new HashSet < > ( Arrays . asList ( BASE _ PACKAGE , BASE _ PACKAGE + " . checks . annotation " ) ) , 
 + Thread . currentThread ( ) . getContextClassLoader ( ) , TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) ; 
 + createModuleByBruteForce . setAccessible ( true ) ; 
 + final AnnotationLocationCheck check = ( AnnotationLocationCheck ) createModuleByBruteForce 
 + . invoke ( packageObjectFactory , checkName ) ; 
 + assertNotNull ( " Check should not be null when creating module from name " , check ) ; 
 + } 
 + 
 + @ Test 
 + public void testCreateCheckWithPartialPackageNameByBruteForce ( ) throws Exception { 
 + final String checkName = " checks . annotation . AnnotationLocation " ; 
 + final PackageObjectFactory packageObjectFactory = new PackageObjectFactory ( 
 + new HashSet < > ( Collections . singletonList ( BASE _ PACKAGE ) ) , 
 + Thread . currentThread ( ) . getContextClassLoader ( ) , TRY _ IN _ ALL _ REGISTERED _ PACKAGES ) ; 
 + final AnnotationLocationCheck check = ( AnnotationLocationCheck ) packageObjectFactory 
 + . createModule ( checkName ) ; 
 + assertNotNull ( " Check should not be null when creating module from name " , check ) ; 
 + } 
 + 
 + @ Test 
 @ SuppressWarnings ( " unchecked " ) 
 public void testGenerateThirdPartyNameToFullModuleNameWithException ( ) throws Exception { 
 final URLClassLoader classLoader = mock ( URLClassLoader . class ) ;

NEAREST DIFF:
diff - - git a / . travis . yml b / . travis . yml 
 old mode 100755 
 new mode 100644
