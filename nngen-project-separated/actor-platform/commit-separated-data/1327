BLEU SCORE: 0.02383853510228548

TEST MSG: perf ( core ) : Much better contact import
GENERATED MSG: Merge branch ' master ' into develop - android

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java < nl > index fa94c49 . . 91325c6 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java < nl > @ @ - 33 , 6 + 33 , 8 @ @ public abstract class AbsModule { < nl > public static final String STORAGE _ NOTIFICATIONS = " notifications " ; < nl > public static final String STORAGE _ SEARCH = " search " ; < nl > < nl > + public static final String STORAGE _ BOOK _ IMPORT = " book _ import " ; < nl > + < nl > public static final String STORAGE _ CHAT _ PREFIX = " chat _ " ; < nl > public static final String STORAGE _ CHAT _ MEDIA _ PREFIX = " chat _ media _ " ; < nl > public static final String STORAGE _ CHAT _ DOCS _ PREFIX = " chat _ docs _ " ; < nl > @ @ - 40 , 6 + 42 , 7 @ @ public abstract class AbsModule { < nl > public static final String STORAGE _ CHAT _ OUT = " chat _ pending _ out " ; < nl > public static final String STORAGE _ CURSOR = " chat _ cursor " ; < nl > < nl > + < nl > private ModuleContext context ; < nl > < nl > public AbsModule ( ModuleContext context ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java < nl > index e942cdc . . a7e3240 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java < nl > @ @ - 32 , 6 + 32 , 7 @ @ import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > import im . actor . core . network . RpcInternalException ; < nl > import im . actor . core . viewmodel . UserVM ; < nl > + import im . actor . runtime . storage . SyncKeyValue ; < nl > < nl > import static im . actor . runtime . actors . ActorSystem . system ; < nl > < nl > @ @ - 40 , 11 + 41 , 13 @ @ public class ContactsModule extends AbsModule { < nl > private ListEngine < Contact > contacts ; < nl > private ActorRef bookImportActor ; < nl > private ActorRef contactSyncActor ; < nl > + private SyncKeyValue bookImportState ; < nl > < nl > public ContactsModule ( final Modules modules ) { < nl > super ( modules ) ; < nl > < nl > contacts = Storage . createList ( STORAGE _ CONTACTS , Contact . CREATOR ) ; < nl > + bookImportState = new SyncKeyValue ( Storage . createKeyValue ( STORAGE _ BOOK _ IMPORT ) ) ; < nl > } < nl > < nl > public void run ( ) { < nl > @ @ - 62 , 6 + 65 , 10 @ @ public class ContactsModule extends AbsModule { < nl > } ) . changeDispatcher ( " heavy " ) , " actor / contacts _ sync " ) ; < nl > } < nl > < nl > + public SyncKeyValue getBookImportState ( ) { < nl > + return bookImportState ; < nl > + } < nl > + < nl > public ListEngine < Contact > getContacts ( ) { < nl > return contacts ; < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java < nl > index 4c2123f . . 2f23fc3 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java < nl > @ @ - 35 , 10 + 35 , 18 @ @ public class BookImportActor extends ModuleActor { < nl > < nl > private static final int MAX _ IMPORT _ SIZE = 50 ; < nl > < nl > + / / Reading Phone Book < nl > + private boolean phoneBookReadingIsInProgress = false ; < nl > + < nl > + / / Import Queue < nl > + private boolean isUploadingContacts = false ; < nl > + private ArrayList < ImportQueueItem > importQueue = new ArrayList < ImportQueueItem > ( ) ; < nl > + < nl > + / / Currently importing phones and emails < nl > private HashSet < Long > importingPhones = new HashSet < Long > ( ) ; < nl > private HashSet < String > importingEmails = new HashSet < String > ( ) ; < nl > < nl > - private boolean isSyncInProgress = false ; < nl > + / / Imported phones and emails < nl > private BookImportStorage storage = new BookImportStorage ( ) ; < nl > < nl > public BookImportActor ( ModuleContext context ) { < nl > @ @ - 49 , 7 + 57 , 14 @ @ public class BookImportActor extends ModuleActor { < nl > @ Override < nl > public void preStart ( ) { < nl > super . preStart ( ) ; < nl > - < nl > + byte [ ] data = context ( ) . getContactsModule ( ) . getBookImportState ( ) . get ( 0 ) ; < nl > + if ( data ! = null ) { < nl > + try { < nl > + storage = new BookImportStorage ( data ) ; < nl > + } catch ( Exception e ) { < nl > + e . getLocalizedMessage ( ) ; < nl > + } < nl > + } < nl > self ( ) . send ( new PerformSync ( ) ) ; < nl > } < nl > < nl > @ @ - 57 , 13 + 72 , 13 @ @ public class BookImportActor extends ModuleActor { < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Checking sync . . . " ) ; < nl > } < nl > - if ( isSyncInProgress ) { < nl > + if ( phoneBookReadingIsInProgress ) { < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Sync already in progress " ) ; < nl > } < nl > return ; < nl > } < nl > - isSyncInProgress = true ; < nl > + phoneBookReadingIsInProgress = true ; < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Starting book loading . . . " ) ; < nl > } < nl > @ @ - 78 , 161 + 93 , 161 @ @ public class BookImportActor extends ModuleActor { < nl > } < nl > < nl > private void onPhoneBookLoaded ( List < PhoneBookContact > phoneBook ) { < nl > - isSyncInProgress = false ; < nl > + phoneBookReadingIsInProgress = false ; < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Book load completed " ) ; < nl > } < nl > < nl > - ArrayList < ApiPhoneToImport > phoneToImports = new ArrayList < ApiPhoneToImport > ( ) ; < nl > - ArrayList < ApiEmailToImport > emailToImports = new ArrayList < ApiEmailToImport > ( ) ; < nl > + int newPhones = 0 ; < nl > + int newEmails = 0 ; < nl > for ( PhoneBookContact record : phoneBook ) { < nl > for ( PhoneBookPhone phone : record . getPhones ( ) ) { < nl > - if ( isImported ( phone . getNumber ( ) ) ) { < nl > + if ( storage . isImported ( phone . getNumber ( ) ) ) { < nl > continue ; < nl > } < nl > if ( importingPhones . contains ( phone . getNumber ( ) ) ) { < nl > continue ; < nl > } < nl > importingPhones . add ( phone . getNumber ( ) ) ; < nl > - phoneToImports . add ( new ApiPhoneToImport ( phone . getNumber ( ) , record . getName ( ) ) ) ; < nl > + importQueue . add ( new ImportPhoneQueueItem ( phone . getNumber ( ) , record . getName ( ) ) ) ; < nl > + newPhones + + ; < nl > } < nl > < nl > for ( PhoneBookEmail email : record . getEmails ( ) ) { < nl > - if ( isImported ( email . getEmail ( ) . toLowerCase ( ) ) ) { < nl > + if ( storage . isImported ( email . getEmail ( ) . toLowerCase ( ) ) ) { < nl > continue ; < nl > } < nl > if ( importingEmails . contains ( email . getEmail ( ) . toLowerCase ( ) ) ) { < nl > continue ; < nl > } < nl > importingEmails . add ( email . getEmail ( ) . toLowerCase ( ) ) ; < nl > - emailToImports . add ( new ApiEmailToImport ( email . getEmail ( ) . toLowerCase ( ) , record . getName ( ) ) ) ; < nl > + importQueue . add ( new ImportEmailQueueItem ( email . getEmail ( ) . toLowerCase ( ) , record . getName ( ) ) ) ; < nl > + newEmails + + ; < nl > } < nl > } < nl > < nl > - if ( phoneToImports . size ( ) = = 0 & & emailToImports . size ( ) = = 0 ) { < nl > - if ( ENABLE _ LOG ) { < nl > + if ( ENABLE _ LOG ) { < nl > + if ( newPhones = = 0 & & newEmails = = 0 ) { < nl > Log . d ( TAG , " No new contacts found " ) ; < nl > - } < nl > - markImported ( ) ; < nl > - return ; < nl > - } else { < nl > - if ( ENABLE _ LOG ) { < nl > - Log . d ( TAG , " Founded new " + ( phoneToImports . size ( ) + emailToImports . size ( ) ) + " contact records " ) ; < nl > + } else { < nl > + Log . d ( TAG , " Founded new " + ( newPhones + newEmails ) + " contact records " ) ; < nl > } < nl > } < nl > < nl > - ArrayList < ApiPhoneToImport > phoneToImportsPart = new ArrayList < ApiPhoneToImport > ( ) ; < nl > - ArrayList < ApiEmailToImport > emailToImportsPart = new ArrayList < ApiEmailToImport > ( ) ; < nl > - int count = 0 ; < nl > - for ( ApiPhoneToImport phoneToImport : phoneToImports ) { < nl > - phoneToImportsPart . add ( phoneToImport ) ; < nl > - count + + ; < nl > - if ( count > = MAX _ IMPORT _ SIZE ) { < nl > - performImport ( phoneToImportsPart , emailToImportsPart ) ; < nl > - phoneToImportsPart . clear ( ) ; < nl > - emailToImportsPart . clear ( ) ; < nl > - count = 0 ; < nl > - } < nl > - } < nl > - < nl > - for ( ApiEmailToImport emailToImport : emailToImports ) { < nl > - emailToImportsPart . add ( emailToImport ) ; < nl > - count + + ; < nl > - if ( count > = MAX _ IMPORT _ SIZE ) { < nl > - performImport ( phoneToImportsPart , emailToImportsPart ) ; < nl > - phoneToImportsPart . clear ( ) ; < nl > - emailToImportsPart . clear ( ) ; < nl > - count = 0 ; < nl > - } < nl > - } < nl > - < nl > - if ( count > 0 ) { < nl > - performImport ( phoneToImportsPart , emailToImportsPart ) ; < nl > - } < nl > + performImportIfRequired ( ) ; < nl > } < nl > < nl > - private void performImport ( ArrayList < ApiPhoneToImport > phoneToImportsPart , < nl > - ArrayList < ApiEmailToImport > emailToImportsPart ) { < nl > + private void performImportIfRequired ( ) { < nl > + < nl > + / / < nl > + / / Checking state < nl > + / / < nl > < nl > if ( ENABLE _ LOG ) { < nl > - Log . d ( TAG , " Performing import part with " + phoneToImportsPart . size ( ) + < nl > - " phones and " + emailToImportsPart . size ( ) + " emails " ) ; < nl > + Log . d ( TAG , " performImportIfRequired called " ) ; < nl > + } < nl > + if ( isUploadingContacts ) { < nl > + if ( ENABLE _ LOG ) { < nl > + Log . d ( TAG , " performImportIfRequired : exiting : already importing " ) ; < nl > + } < nl > + return ; < nl > } < nl > < nl > - final ApiPhoneToImport [ ] phones = phoneToImportsPart . toArray ( new ApiPhoneToImport [ phoneToImportsPart . size ( ) ] ) ; < nl > - final ApiEmailToImport [ ] emailToImports = emailToImportsPart . toArray ( new ApiEmailToImport [ emailToImportsPart . size ( ) ] ) ; < nl > + if ( importQueue . size ( ) = = 0 ) { < nl > + if ( ENABLE _ LOG ) { < nl > + Log . d ( TAG , " performImportIfRequired : exiting : nothing to import " ) ; < nl > + } < nl > + / / Marking as everything is imported < nl > + context ( ) . getAppStateModule ( ) . onBookImported ( ) ; < nl > + return ; < nl > + } < nl > < nl > - request ( new RequestImportContacts ( ( java . util . List < ApiPhoneToImport > ) phoneToImportsPart . clone ( ) , < nl > - ( java . util . List < ApiEmailToImport > ) emailToImportsPart . clone ( ) ) , new RpcCallback < ResponseImportContacts > ( ) { < nl > + / / < nl > + / / Performing import < nl > + / / < nl > + < nl > + isUploadingContacts = true ; < nl > + final ArrayList < ApiPhoneToImport > phoneToImports = new ArrayList < ApiPhoneToImport > ( ) ; < nl > + final ArrayList < ApiEmailToImport > emailToImports = new ArrayList < ApiEmailToImport > ( ) ; < nl > + for ( int i = 0 ; i < 50 & & importQueue . size ( ) > 0 ; i + + ) { < nl > + ImportQueueItem importQueueItem = importQueue . remove ( 0 ) ; < nl > + if ( importQueueItem instanceof ImportEmailQueueItem ) { < nl > + emailToImports . add ( new ApiEmailToImport ( ( ( ImportEmailQueueItem ) importQueueItem ) . getEmail ( ) , < nl > + ( ( ImportEmailQueueItem ) importQueueItem ) . getName ( ) ) ) ; < nl > + } else if ( importQueueItem instanceof ImportPhoneQueueItem ) { < nl > + phoneToImports . add ( new ApiPhoneToImport ( ( ( ImportPhoneQueueItem ) importQueueItem ) . getPhoneNumber ( ) , < nl > + ( ( ImportPhoneQueueItem ) importQueueItem ) . getName ( ) ) ) ; < nl > + } else { < nl > + throw new RuntimeException ( ) ; < nl > + } < nl > + } < nl > + request ( new RequestImportContacts ( phoneToImports , emailToImports ) , new RpcCallback < ResponseImportContacts > ( ) { < nl > @ Override < nl > public void onResult ( ResponseImportContacts response ) { < nl > - for ( ApiPhoneToImport phoneToImport : phones ) { < nl > - markImported ( phoneToImport . getPhoneNumber ( ) ) ; < nl > + < nl > + / / < nl > + / / Saving imported state < nl > + / / < nl > + < nl > + for ( ApiPhoneToImport phoneToImport : phoneToImports ) { < nl > + storage . markAsImported ( phoneToImport . getPhoneNumber ( ) ) ; < nl > importingPhones . remove ( phoneToImport . getPhoneNumber ( ) ) ; < nl > } < nl > for ( ApiEmailToImport emailToImport : emailToImports ) { < nl > - markImported ( emailToImport . getEmail ( ) ) ; < nl > + storage . markAsImported ( emailToImport . getEmail ( ) ) ; < nl > importingEmails . remove ( emailToImport . getEmail ( ) ) ; < nl > } < nl > + context ( ) . getContactsModule ( ) . getBookImportState ( ) . put ( 0 , storage . toByteArray ( ) ) ; < nl > < nl > - if ( importingEmails . size ( ) = = 0 & & importingPhones . size ( ) = = 0 ) { < nl > - markImported ( ) ; < nl > - } < nl > + / / < nl > + / / Generating update < nl > + / / < nl > + if ( response . getUsers ( ) . size ( ) ! = 0 ) { < nl > + if ( ENABLE _ LOG ) { < nl > + Log . d ( TAG , " Import success with " + response . getUsers ( ) . size ( ) + " new contacts " ) ; < nl > + } < nl > < nl > - if ( response . getUsers ( ) . size ( ) = = 0 ) { < nl > + ArrayList < Integer > uids = new ArrayList < Integer > ( ) ; < nl > + for ( ApiUser u : response . getUsers ( ) ) { < nl > + uids . add ( u . getId ( ) ) ; < nl > + } < nl > + updates ( ) . onUpdateReceived ( new FatSeqUpdate ( < nl > + response . getSeq ( ) , response . getState ( ) , < nl > + UpdateContactsAdded . HEADER , < nl > + new UpdateContactsAdded ( uids ) . toByteArray ( ) , < nl > + response . getUsers ( ) , < nl > + new ArrayList < ApiGroup > ( ) ) ) ; < nl > + } else { < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Import success , but no new contacts found " ) ; < nl > } < nl > - return ; < nl > - } < nl > - < nl > - if ( ENABLE _ LOG ) { < nl > - Log . d ( TAG , " Import success with " + response . getUsers ( ) . size ( ) + " new contacts " ) ; < nl > } < nl > < nl > - ArrayList < Integer > uids = new ArrayList < Integer > ( ) ; < nl > - for ( ApiUser u : response . getUsers ( ) ) { < nl > - uids . add ( u . getId ( ) ) ; < nl > - } < nl > - updates ( ) . onUpdateReceived ( new FatSeqUpdate ( < nl > - response . getSeq ( ) , response . getState ( ) , < nl > - UpdateContactsAdded . HEADER , < nl > - new UpdateContactsAdded ( uids ) . toByteArray ( ) , < nl > - response . getUsers ( ) , < nl > - new ArrayList < ApiGroup > ( ) ) ) ; < nl > + / / < nl > + / / Launching next iteration < nl > + / / < nl > + isUploadingContacts = false ; < nl > + performImportIfRequired ( ) ; < nl > } < nl > < nl > @ Override < nl > public void onError ( RpcException e ) { < nl > + < nl > / / TODO : Better error handling < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Import failure " ) ; < nl > } < nl > e . printStackTrace ( ) ; < nl > + < nl > + / / < nl > + / / Launching next iteration < nl > + / / < nl > + isUploadingContacts = false ; < nl > + performImportIfRequired ( ) ; < nl > } < nl > } ) ; < nl > } < nl > < nl > - / / private boolean isImported ( long phone ) { < nl > - / / return preferences ( ) . getBool ( " book _ phone _ " + phone , false ) ; < nl > - / / } < nl > - / / < nl > - / / private boolean isImported ( String email ) { < nl > - / / return preferences ( ) . getBool ( " book _ email _ " + email . toLowerCase ( ) , false ) ; < nl > - / / } < nl > - / / < nl > - / / private void markImported ( long phone ) { < nl > - / / preferences ( ) . putBool ( " book _ phone _ " + phone , true ) ; < nl > - / / } < nl > - / / < nl > - / / private void markImported ( String email ) { < nl > - / / preferences ( ) . putBool ( " book _ email _ " + email . toLowerCase ( ) , true ) ; < nl > - / / } < nl > - < nl > - private void markImported ( ) { < nl > - context ( ) . getAppStateModule ( ) . onBookImported ( ) ; < nl > - } < nl > - < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > if ( message instanceof PerformSync ) {
NEAREST DIFF (one line): diff - - git a / apps / actor - android / build . gradle b / apps / actor - android / build . gradle < nl > index bb23e83 . . 0778011 100644 < nl > - - - a / apps / actor - android / build . gradle < nl > + + + b / apps / actor - android / build . gradle < nl > @ @ - 53 , 7 + 53 , 6 @ @ android { < nl > def URL _ DEV1 = " \ " tls : / / mtproto - api - dev1 . actor . im : 443 \ " " ; < nl > def URL _ DEV1 _ PLAIN = " \ " tcp : / / mtproto - api - dev1 . actor . im : 8080 \ " " ; < nl > def URL _ DEV2 = " \ " tls : / / mtproto - api - dev2 . actor . im : 443 \ " " ; < nl > - def URL _ LOCAL = " \ " tcp : / / 192 . 168 . 1 . 189 : 8080 \ " " ; < nl > < nl > def HOCKEY _ MAIN = " \ " 38d528f118a899bbd503bda195609003 \ " " < nl > def HOCKEY _ DEV1 = " \ " e2fb9a8444e1d8a5d90dba0e0c9ed534 \ " " < nl > diff - - git a / apps / actor - android / src / main / java / im / actor / messenger / app / Core . java b / apps / actor - android / src / main / java / im / actor / messenger / app / Core . java < nl > index 248c49a . . cfa7289 100644 < nl > - - - a / apps / actor - android / src / main / java / im / actor / messenger / app / Core . java < nl > + + + b / apps / actor - android / src / main / java / im / actor / messenger / app / Core . java < nl > @ @ - 56 , 6 + 56 , 7 @ @ public class Core { < nl > < nl > / / Integrations < nl > if ( BuildConfig . MINT ! = null ) { < nl > + Mint . disableNetworkMonitoring ( ) ; < nl > Mint . initAndStartSession ( application , BuildConfig . MINT ) ; < nl > } < nl > Fresco . initialize ( application ) ; < nl > diff - - git a / apps / actor - android / src / main / java / im / actor / messenger / app / emoji / keyboard / EmojiKeyboardPopup . java b / apps / actor - android / src / main / java / im / actor / messenger / app / emoji / keyboard / EmojiKeyboardPopup . java < nl > index 2418d2b . . 569476e 100644 < nl > - - - a / apps / actor - android / src / main / java / im / actor / messenger / app / emoji / keyboard / EmojiKeyboardPopup . java < nl > + + + b / apps / actor - android / src / main / java / im / actor / messenger / app / emoji / keyboard / EmojiKeyboardPopup . java < nl > @ @ - 43 , 8 + 43 , 6 @ @ import android . widget . ImageView ; < nl > import android . widget . PopupWindow ; < nl > import android . widget . RelativeLayout ; < nl > < nl > - import com . facebook . drawee . view . SimpleDraweeView ; < nl > - < nl > import im . actor . messenger . R ; < nl > import im . actor . messenger . app . base . BaseActivity ; < nl > import im . actor . messenger . app . emoji . stickers . Stickers ; < nl > @ @ - 244 , 10 + 242 , 13 @ @ public class EmojiKeyboardPopup extends PopupWindow < nl > return 3 ; < nl > } < nl > } ) ; < nl > - / / emojiContainer . addView ( createEmojiPagerView ( ) ) ; < nl > - < nl > - / * * / < nl > - < nl > + < nl > + / / emojiPagerIndicator . setTabBackground ( R . drawable . md _ btn _ selector _ ripple ) ; < nl > + emojiPagerIndicator . setIndicatorColorResource ( R . color . main _ tab _ selected ) ; < nl > + emojiPagerIndicator . setIndicatorHeight ( Screen . dp ( 4 ) ) ; < nl > + emojiPagerIndicator . setDividerColorResource ( R . color . main _ tab _ divider ) ; < nl > + emojiPagerIndicator . setUnderlineHeight ( 0 ) ; < nl > + emojiPagerIndicator . setTabPaddingLeftRight ( 0 ) ; < nl > < nl > return keyboardView ; < nl > } < nl > diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java < nl > index 2cc9e64 . . e084730 100644 < nl > - - - a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java < nl > + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java < nl > @ @ - 22 , 13 + 22 , 18 @ @ public class JavaNetworkProvider implements NetworkProvider { < nl > public void run ( ) { < nl > try { < nl > createCallback . onConnectionCreated ( < nl > - new JavaTcpConnection ( < nl > + new JavaOldTcpConnection ( < nl > connectionId , < nl > - mtprotoVersion , < nl > - apiMajorVersion , < nl > - apiMinorVersion , < nl > endpoint , < nl > callback ) ) ; < nl > + / / createCallback . onConnectionCreated ( < nl > + / / new JavaTcpConnection ( < nl > + / / connectionId , < nl > + / / mtprotoVersion , < nl > + / / apiMajorVersion , < nl > + / / apiMinorVersion , < nl > + / / endpoint , < nl > + / / callback ) ) ; < nl > } catch ( Exception e ) { < nl > e . printStackTrace ( ) ; < nl > createCallback . onConnectionCreateError ( ) ; < nl > diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaOldTcpConnection . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaOldTcpConnection . java < nl > new file mode 100644 < nl > index 0000000 . . 7e47ed4 < nl > - - - / dev / null < nl > + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaOldTcpConnection . java < nl > @ @ - 0 , 0 + 1 , 338 @ @ < nl > + package im . actor . model . jvm ; < nl > + < nl > + import java . io . ByteArrayOutputStream ; < nl > + import java . io . IOException ; < nl > + import java . io . InputStream ; < nl > + import java . io . OutputStream ; < nl > + import java . net . InetSocketAddress ; < nl > + import java . net . Socket ; < nl > + import java . util . concurrent . ConcurrentLinkedQueue ; < nl > + import java . util . zip . CRC32 ; < nl > + < nl > + import javax . net . ssl . SSLSocketFactory ; < nl > + < nl > + import im . actor . model . log . Log ; < nl > + import im . actor . model . network . Connection ; < nl > + import im . actor . model . network . ConnectionCallback ; < nl > + import im . actor . model . network . ConnectionEndpoint ; < nl > + < nl > + / * * < nl > + * Created by ex3ndr on 06 . 02 . 15 . < nl > + * / < nl > + public class JavaOldTcpConnection implements Connection { < nl > + < nl > + private static final int CONNECTION _ TIMEOUT = 5 * 1000 ; < nl > + private static final int READ _ DIE _ TIMEOUT = 15 * 1000 ; / / 5 sec < nl > + private static final int MAX _ PACKAGE _ SIZE = 1024 * 1024 ; < nl > + < nl > + private final String TAG ; < nl > + < nl > + private ConnectionEndpoint endpoint ; < nl > + private ConnectionCallback callback ; < nl > + < nl > + private final Socket socket ; < nl > + < nl > + private final ReaderThread readerThread ; < nl > + private final WriterThread writerThread ; < nl > + < nl > + private int sentPackets ; < nl > + private int receivedPackets ; < nl > + < nl > + private boolean isClosed ; < nl > + < nl > + public JavaOldTcpConnection ( int id , ConnectionEndpoint _ endpoint , ConnectionCallback _ callback ) throws IOException { < nl > + this . TAG = " Connection # " + id ; < nl > + this . endpoint = _ endpoint ; < nl > + this . callback = _ callback ; < nl > + < nl > + switch ( endpoint . getType ( ) ) { < nl > + case TCP : < nl > + socket = new Socket ( ) ; < nl > + break ; < nl > + case TCP _ TLS : < nl > + socket = SSLSocketFactory . getDefault ( ) . createSocket ( ) ; < nl > + break ; < nl > + default : < nl > + throw new IOException ( " Unsupported endpoint type : " + endpoint . getType ( ) ) ; < nl > + } < nl > + < nl > + / / if ( ! params . getConfig ( ) . isChromeEnabled ( ) ) { < nl > + this . socket . setKeepAlive ( true ) ; < nl > + this . socket . setTcpNoDelay ( true ) ; < nl > + / / } < nl > + < nl > + this . socket . connect ( new InetSocketAddress ( endpoint . getHost ( ) , endpoint . getPort ( ) ) , CONNECTION _ TIMEOUT ) ; < nl > + < nl > + / / Init socket streams < nl > + this . socket . getInputStream ( ) ; < nl > + this . socket . getOutputStream ( ) ; < nl > + < nl > + / / TODO : Implement handshake < nl > + / / ? ? ? < nl > + < nl > + readerThread = new ReaderThread ( ) ; < nl > + writerThread = new WriterThread ( ) ; < nl > + readerThread . start ( ) ; < nl > + writerThread . start ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void post ( byte [ ] data , int offset , int len ) { < nl > + writerThread . pushPackage ( new Package ( data ) ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public boolean isClosed ( ) { < nl > + return isClosed ; < nl > + } < nl > + < nl > + @ Override < nl > + public void close ( ) { < nl > + breakConnection ( ) ; < nl > + } < nl > + < nl > + private synchronized void breakConnection ( ) { < nl > + if ( ! isClosed ) { < nl > + Log . w ( TAG , " Breaking connection " ) ; < nl > + isClosed = true ; < nl > + try { < nl > + readerThread . interrupt ( ) ; < nl > + } catch ( final Exception e ) { < nl > + Log . e ( TAG , e ) ; < nl > + } < nl > + < nl > + try { < nl > + writerThread . interrupt ( ) ; < nl > + } catch ( final Exception e ) { < nl > + Log . e ( TAG , e ) ; < nl > + } < nl > + < nl > + / / try { < nl > + / / dieThread . interrupt ( ) ; < nl > + / / } catch ( final Exception e ) { < nl > + / / Log . e ( TAG , e ) ; < nl > + / / } < nl > + < nl > + try { < nl > + socket . close ( ) ; < nl > + } catch ( IOException e ) { < nl > + Log . e ( TAG , e ) ; < nl > + } < nl > + < nl > + callback . onConnectionDie ( ) ; < nl > + } < nl > + } < nl > + < nl > + private class ReaderThread extends Thread { < nl > + private ReaderThread ( ) { < nl > + setPriority ( Thread . MIN _ PRIORITY ) ; < nl > + setName ( TAG + " # Reader " + hashCode ( ) ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void run ( ) { < nl > + try { < nl > + while ( ! isClosed & & ! isInterrupted ( ) ) { < nl > + if ( socket . isClosed ( ) ) { < nl > + Log . d ( TAG , " Socket is closed " ) ; < nl > + throw new IOException ( " Socket is closed " ) ; < nl > + } < nl > + if ( ! socket . isConnected ( ) ) { < nl > + Log . d ( TAG , " Socket is not connected " ) ; < nl > + throw new IOException ( " Socket is not connected " ) ; < nl > + } < nl > + < nl > + InputStream stream = socket . getInputStream ( ) ; < nl > + long start = System . currentTimeMillis ( ) ; < nl > + < nl > + / / Length < nl > + / / if ( LOG ! = null & & DEBUG ) { < nl > + / / LOG . d ( TAG , " Reading content length " ) ; < nl > + / / } < nl > + int pkgLen = readInt ( stream ) ; < nl > + if ( pkgLen < 0 | | pkgLen > MAX _ PACKAGE _ SIZE ) { < nl > + Log . w ( TAG , " Invalid package size : " + pkgLen ) ; < nl > + throw new IOException ( " Invalid package size " ) ; < nl > + } < nl > + < nl > + / / Index < nl > + / / if ( LOG ! = null & & DEBUG ) { < nl > + / / LOG . d ( TAG , " Reading package index " ) ; < nl > + / / } < nl > + int pkgIndex = readInt ( stream ) ; < nl > + int expectedIndex = receivedPackets + + ; < nl > + if ( pkgIndex ! = expectedIndex ) { < nl > + / / if ( LOG ! = null ) { < nl > + / / LOG . w ( TAG , " Wrong seq . Expected " + expectedIndex + " , got " + pkgIndex ) ; < nl > + / / } < nl > + Log . w ( TAG , " Wrong seq . Expected " + expectedIndex + " , got " + pkgIndex ) ; < nl > + throw new IOException ( " Wrong number of received packets " ) ; < nl > + } < nl > + < nl > + / / Content < nl > + / / if ( LOG ! = null & & DEBUG ) { < nl > + / / LOG . d ( TAG , " Reading package content of " + pkgLen + " bytes " ) ; < nl > + / / } < nl > + byte [ ] pkg = readBytes ( pkgLen - 8 , stream ) ; < nl > + < nl > + / / CRC32 < nl > + / / if ( LOG ! = null & & DEBUG ) { < nl > + / / LOG . d ( TAG , " Reading CRC32 " ) ; < nl > + / / } < nl > + int pkgCrc = readInt ( stream ) ; < nl > + CRC32 crc32 = new CRC32 ( ) ; < nl > + crc32 . update ( intToBytes ( pkgLen ) ) ; < nl > + crc32 . update ( intToBytes ( pkgIndex ) ) ; < nl > + crc32 . update ( pkg ) ; < nl > + int localCrc = ( int ) crc32 . getValue ( ) ; < nl > + < nl > + if ( localCrc ! = pkgCrc ) { < nl > + Log . w ( TAG , " Package crc32 expected : " + localCrc + " , got : " + pkgCrc ) ; < nl > + throw new IOException ( " Wrong CRC " ) ; < nl > + } < nl > + < nl > + / / if ( LOG ! = null & & DEBUG ) { < nl > + / / LOG . d ( TAG , " Read # " + pkgIndex + " in " + ( System . currentTimeMillis ( ) - start ) + " ms " ) ; < nl > + / / } < nl > + callback . onMessage ( pkg , 0 , pkg . length ) ; < nl > + } < nl > + } catch ( final Throwable e ) { < nl > + Log . e ( TAG , e ) ; < nl > + breakConnection ( ) ; < nl > + } < nl > + } < nl > + } < nl > + < nl > + private class WriterThread extends Thread { < nl > + < nl > + private final CRC32 crc32 = new CRC32 ( ) ; < nl > + private final ConcurrentLinkedQueue < Package > packages = new ConcurrentLinkedQueue < Package > ( ) ; < nl > + < nl > + public WriterThread ( ) { < nl > + setPriority ( Thread . MIN _ PRIORITY ) ; < nl > + setName ( TAG + " # Writer " + hashCode ( ) ) ; < nl > + } < nl > + < nl > + public void pushPackage ( final Package p ) { < nl > + packages . add ( p ) ; < nl > + synchronized ( packages ) { < nl > + packages . notifyAll ( ) ; < nl > + } < nl > + } < nl > + < nl > + @ Override < nl > + public void run ( ) { < nl > + while ( ! isClosed & & ! isInterrupted ( ) ) { < nl > + Package p ; < nl > + synchronized ( packages ) { < nl > + p = packages . poll ( ) ; < nl > + if ( p = = null ) { < nl > + try { < nl > + packages . wait ( ) ; < nl > + } catch ( final InterruptedException e ) { < nl > + return ; < nl > + } < nl > + p = packages . poll ( ) ; < nl > + } < nl > + } < nl > + if ( p = = null ) { < nl > + continue ; < nl > + } < nl > + < nl > + try { < nl > + byte [ ] data = p . data ; < nl > + int length = data . length + 8 ; < nl > + < nl > + ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; < nl > + writeInt ( length , outputStream ) ; < nl > + writeInt ( sentPackets , outputStream ) ; < nl > + writeBytes ( data , outputStream ) ; < nl > + crc32 . reset ( ) ; < nl > + crc32 . update ( outputStream . toByteArray ( ) ) ; < nl > + writeInt ( ( int ) crc32 . getValue ( ) , outputStream ) ; < nl > + socket . getOutputStream ( ) . write ( outputStream . toByteArray ( ) ) ; < nl > + socket . getOutputStream ( ) . flush ( ) ; < nl > + / / onWrite ( ) ; < nl > + < nl > + sentPackets + + ; < nl > + } catch ( final Exception e ) { < nl > + Log . e ( TAG , e ) ; < nl > + breakConnection ( ) ; < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + public static byte [ ] intToBytes ( int v ) { < nl > + return new byte [ ] { < nl > + ( byte ) ( ( v > > 24 ) & 0xFF ) , < nl > + ( byte ) ( ( v > > 16 ) & 0xFF ) , < nl > + ( byte ) ( ( v > > 8 ) & 0xFF ) , < nl > + ( byte ) ( v & 0xFF ) < nl > + } ; < nl > + } < nl > + < nl > + public static void writeByte ( byte v , OutputStream stream ) throws IOException { < nl > + stream . write ( v ) ; < nl > + } < nl > + < nl > + public static void writeBytes ( byte [ ] data , OutputStream stream ) throws IOException { < nl > + stream . write ( data ) ; < nl > + } < nl > + < nl > + public static void writeInt ( int v , OutputStream stream ) throws IOException { < nl > + writeByte ( ( byte ) ( ( v > > 24 ) & 0xFF ) , stream ) ; < nl > + writeByte ( ( byte ) ( ( v > > 16 ) & 0xFF ) , stream ) ; < nl > + writeByte ( ( byte ) ( ( v > > 8 ) & 0xFF ) , stream ) ; < nl > + writeByte ( ( byte ) ( v & 0xFF ) , stream ) ; < nl > + } < nl > + < nl > + public static int readInt ( InputStream stream ) throws IOException { < nl > + int a = stream . read ( ) ; < nl > + if ( a < 0 ) { < nl > + throw new IOException ( ) ; < nl > + } < nl > + int b = stream . read ( ) ; < nl > + if ( b < 0 ) { < nl > + throw new IOException ( ) ; < nl > + } < nl > + int c = stream . read ( ) ; < nl > + if ( c < 0 ) { < nl > + throw new IOException ( ) ; < nl > + } < nl > + int d = stream . read ( ) ; < nl > + if ( d < 0 ) { < nl > + throw new IOException ( ) ; < nl > + } < nl > + < nl > + return d + ( c < < 8 ) + ( b < < 16 ) + ( a < < 24 ) ; < nl > + } < nl > + < nl > + public static byte [ ] readBytes ( int count , InputStream stream ) throws IOException { < nl > + byte [ ] res = new byte [ count ] ; < nl > + int offset = 0 ; < nl > + while ( offset < res . length ) { < nl > + int readed = stream . read ( res , offset , res . length - offset ) ; < nl > + if ( readed > 0 ) { < nl > + offset + = readed ; < nl > + } else if ( readed < 0 ) { < nl > + throw new IOException ( ) ; < nl > + } else { < nl > + Thread . yield ( ) ; < nl > + } < nl > + } < nl > + return res ; < nl > + } < nl > + < nl > + private class Package { < nl > + public byte [ ] data ; < nl > + < nl > + public Package ( ) { < nl > + < nl > + } < nl > + < nl > + private Package ( final byte [ ] data ) { < nl > + this . data = data ; < nl > + } < nl > + } < nl > + }

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java 
 index fa94c49 . . 91325c6 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java 
 @ @ - 33 , 6 + 33 , 8 @ @ public abstract class AbsModule { 
 public static final String STORAGE _ NOTIFICATIONS = " notifications " ; 
 public static final String STORAGE _ SEARCH = " search " ; 
 
 + public static final String STORAGE _ BOOK _ IMPORT = " book _ import " ; 
 + 
 public static final String STORAGE _ CHAT _ PREFIX = " chat _ " ; 
 public static final String STORAGE _ CHAT _ MEDIA _ PREFIX = " chat _ media _ " ; 
 public static final String STORAGE _ CHAT _ DOCS _ PREFIX = " chat _ docs _ " ; 
 @ @ - 40 , 6 + 42 , 7 @ @ public abstract class AbsModule { 
 public static final String STORAGE _ CHAT _ OUT = " chat _ pending _ out " ; 
 public static final String STORAGE _ CURSOR = " chat _ cursor " ; 
 
 + 
 private ModuleContext context ; 
 
 public AbsModule ( ModuleContext context ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java 
 index e942cdc . . a7e3240 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 import im . actor . core . network . RpcInternalException ; 
 import im . actor . core . viewmodel . UserVM ; 
 + import im . actor . runtime . storage . SyncKeyValue ; 
 
 import static im . actor . runtime . actors . ActorSystem . system ; 
 
 @ @ - 40 , 11 + 41 , 13 @ @ public class ContactsModule extends AbsModule { 
 private ListEngine < Contact > contacts ; 
 private ActorRef bookImportActor ; 
 private ActorRef contactSyncActor ; 
 + private SyncKeyValue bookImportState ; 
 
 public ContactsModule ( final Modules modules ) { 
 super ( modules ) ; 
 
 contacts = Storage . createList ( STORAGE _ CONTACTS , Contact . CREATOR ) ; 
 + bookImportState = new SyncKeyValue ( Storage . createKeyValue ( STORAGE _ BOOK _ IMPORT ) ) ; 
 } 
 
 public void run ( ) { 
 @ @ - 62 , 6 + 65 , 10 @ @ public class ContactsModule extends AbsModule { 
 } ) . changeDispatcher ( " heavy " ) , " actor / contacts _ sync " ) ; 
 } 
 
 + public SyncKeyValue getBookImportState ( ) { 
 + return bookImportState ; 
 + } 
 + 
 public ListEngine < Contact > getContacts ( ) { 
 return contacts ; 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java 
 index 4c2123f . . 2f23fc3 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java 
 @ @ - 35 , 10 + 35 , 18 @ @ public class BookImportActor extends ModuleActor { 
 
 private static final int MAX _ IMPORT _ SIZE = 50 ; 
 
 + / / Reading Phone Book 
 + private boolean phoneBookReadingIsInProgress = false ; 
 + 
 + / / Import Queue 
 + private boolean isUploadingContacts = false ; 
 + private ArrayList < ImportQueueItem > importQueue = new ArrayList < ImportQueueItem > ( ) ; 
 + 
 + / / Currently importing phones and emails 
 private HashSet < Long > importingPhones = new HashSet < Long > ( ) ; 
 private HashSet < String > importingEmails = new HashSet < String > ( ) ; 
 
 - private boolean isSyncInProgress = false ; 
 + / / Imported phones and emails 
 private BookImportStorage storage = new BookImportStorage ( ) ; 
 
 public BookImportActor ( ModuleContext context ) { 
 @ @ - 49 , 7 + 57 , 14 @ @ public class BookImportActor extends ModuleActor { 
 @ Override 
 public void preStart ( ) { 
 super . preStart ( ) ; 
 - 
 + byte [ ] data = context ( ) . getContactsModule ( ) . getBookImportState ( ) . get ( 0 ) ; 
 + if ( data ! = null ) { 
 + try { 
 + storage = new BookImportStorage ( data ) ; 
 + } catch ( Exception e ) { 
 + e . getLocalizedMessage ( ) ; 
 + } 
 + } 
 self ( ) . send ( new PerformSync ( ) ) ; 
 } 
 
 @ @ - 57 , 13 + 72 , 13 @ @ public class BookImportActor extends ModuleActor { 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Checking sync . . . " ) ; 
 } 
 - if ( isSyncInProgress ) { 
 + if ( phoneBookReadingIsInProgress ) { 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Sync already in progress " ) ; 
 } 
 return ; 
 } 
 - isSyncInProgress = true ; 
 + phoneBookReadingIsInProgress = true ; 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Starting book loading . . . " ) ; 
 } 
 @ @ - 78 , 161 + 93 , 161 @ @ public class BookImportActor extends ModuleActor { 
 } 
 
 private void onPhoneBookLoaded ( List < PhoneBookContact > phoneBook ) { 
 - isSyncInProgress = false ; 
 + phoneBookReadingIsInProgress = false ; 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Book load completed " ) ; 
 } 
 
 - ArrayList < ApiPhoneToImport > phoneToImports = new ArrayList < ApiPhoneToImport > ( ) ; 
 - ArrayList < ApiEmailToImport > emailToImports = new ArrayList < ApiEmailToImport > ( ) ; 
 + int newPhones = 0 ; 
 + int newEmails = 0 ; 
 for ( PhoneBookContact record : phoneBook ) { 
 for ( PhoneBookPhone phone : record . getPhones ( ) ) { 
 - if ( isImported ( phone . getNumber ( ) ) ) { 
 + if ( storage . isImported ( phone . getNumber ( ) ) ) { 
 continue ; 
 } 
 if ( importingPhones . contains ( phone . getNumber ( ) ) ) { 
 continue ; 
 } 
 importingPhones . add ( phone . getNumber ( ) ) ; 
 - phoneToImports . add ( new ApiPhoneToImport ( phone . getNumber ( ) , record . getName ( ) ) ) ; 
 + importQueue . add ( new ImportPhoneQueueItem ( phone . getNumber ( ) , record . getName ( ) ) ) ; 
 + newPhones + + ; 
 } 
 
 for ( PhoneBookEmail email : record . getEmails ( ) ) { 
 - if ( isImported ( email . getEmail ( ) . toLowerCase ( ) ) ) { 
 + if ( storage . isImported ( email . getEmail ( ) . toLowerCase ( ) ) ) { 
 continue ; 
 } 
 if ( importingEmails . contains ( email . getEmail ( ) . toLowerCase ( ) ) ) { 
 continue ; 
 } 
 importingEmails . add ( email . getEmail ( ) . toLowerCase ( ) ) ; 
 - emailToImports . add ( new ApiEmailToImport ( email . getEmail ( ) . toLowerCase ( ) , record . getName ( ) ) ) ; 
 + importQueue . add ( new ImportEmailQueueItem ( email . getEmail ( ) . toLowerCase ( ) , record . getName ( ) ) ) ; 
 + newEmails + + ; 
 } 
 } 
 
 - if ( phoneToImports . size ( ) = = 0 & & emailToImports . size ( ) = = 0 ) { 
 - if ( ENABLE _ LOG ) { 
 + if ( ENABLE _ LOG ) { 
 + if ( newPhones = = 0 & & newEmails = = 0 ) { 
 Log . d ( TAG , " No new contacts found " ) ; 
 - } 
 - markImported ( ) ; 
 - return ; 
 - } else { 
 - if ( ENABLE _ LOG ) { 
 - Log . d ( TAG , " Founded new " + ( phoneToImports . size ( ) + emailToImports . size ( ) ) + " contact records " ) ; 
 + } else { 
 + Log . d ( TAG , " Founded new " + ( newPhones + newEmails ) + " contact records " ) ; 
 } 
 } 
 
 - ArrayList < ApiPhoneToImport > phoneToImportsPart = new ArrayList < ApiPhoneToImport > ( ) ; 
 - ArrayList < ApiEmailToImport > emailToImportsPart = new ArrayList < ApiEmailToImport > ( ) ; 
 - int count = 0 ; 
 - for ( ApiPhoneToImport phoneToImport : phoneToImports ) { 
 - phoneToImportsPart . add ( phoneToImport ) ; 
 - count + + ; 
 - if ( count > = MAX _ IMPORT _ SIZE ) { 
 - performImport ( phoneToImportsPart , emailToImportsPart ) ; 
 - phoneToImportsPart . clear ( ) ; 
 - emailToImportsPart . clear ( ) ; 
 - count = 0 ; 
 - } 
 - } 
 - 
 - for ( ApiEmailToImport emailToImport : emailToImports ) { 
 - emailToImportsPart . add ( emailToImport ) ; 
 - count + + ; 
 - if ( count > = MAX _ IMPORT _ SIZE ) { 
 - performImport ( phoneToImportsPart , emailToImportsPart ) ; 
 - phoneToImportsPart . clear ( ) ; 
 - emailToImportsPart . clear ( ) ; 
 - count = 0 ; 
 - } 
 - } 
 - 
 - if ( count > 0 ) { 
 - performImport ( phoneToImportsPart , emailToImportsPart ) ; 
 - } 
 + performImportIfRequired ( ) ; 
 } 
 
 - private void performImport ( ArrayList < ApiPhoneToImport > phoneToImportsPart , 
 - ArrayList < ApiEmailToImport > emailToImportsPart ) { 
 + private void performImportIfRequired ( ) { 
 + 
 + / / 
 + / / Checking state 
 + / / 
 
 if ( ENABLE _ LOG ) { 
 - Log . d ( TAG , " Performing import part with " + phoneToImportsPart . size ( ) + 
 - " phones and " + emailToImportsPart . size ( ) + " emails " ) ; 
 + Log . d ( TAG , " performImportIfRequired called " ) ; 
 + } 
 + if ( isUploadingContacts ) { 
 + if ( ENABLE _ LOG ) { 
 + Log . d ( TAG , " performImportIfRequired : exiting : already importing " ) ; 
 + } 
 + return ; 
 } 
 
 - final ApiPhoneToImport [ ] phones = phoneToImportsPart . toArray ( new ApiPhoneToImport [ phoneToImportsPart . size ( ) ] ) ; 
 - final ApiEmailToImport [ ] emailToImports = emailToImportsPart . toArray ( new ApiEmailToImport [ emailToImportsPart . size ( ) ] ) ; 
 + if ( importQueue . size ( ) = = 0 ) { 
 + if ( ENABLE _ LOG ) { 
 + Log . d ( TAG , " performImportIfRequired : exiting : nothing to import " ) ; 
 + } 
 + / / Marking as everything is imported 
 + context ( ) . getAppStateModule ( ) . onBookImported ( ) ; 
 + return ; 
 + } 
 
 - request ( new RequestImportContacts ( ( java . util . List < ApiPhoneToImport > ) phoneToImportsPart . clone ( ) , 
 - ( java . util . List < ApiEmailToImport > ) emailToImportsPart . clone ( ) ) , new RpcCallback < ResponseImportContacts > ( ) { 
 + / / 
 + / / Performing import 
 + / / 
 + 
 + isUploadingContacts = true ; 
 + final ArrayList < ApiPhoneToImport > phoneToImports = new ArrayList < ApiPhoneToImport > ( ) ; 
 + final ArrayList < ApiEmailToImport > emailToImports = new ArrayList < ApiEmailToImport > ( ) ; 
 + for ( int i = 0 ; i < 50 & & importQueue . size ( ) > 0 ; i + + ) { 
 + ImportQueueItem importQueueItem = importQueue . remove ( 0 ) ; 
 + if ( importQueueItem instanceof ImportEmailQueueItem ) { 
 + emailToImports . add ( new ApiEmailToImport ( ( ( ImportEmailQueueItem ) importQueueItem ) . getEmail ( ) , 
 + ( ( ImportEmailQueueItem ) importQueueItem ) . getName ( ) ) ) ; 
 + } else if ( importQueueItem instanceof ImportPhoneQueueItem ) { 
 + phoneToImports . add ( new ApiPhoneToImport ( ( ( ImportPhoneQueueItem ) importQueueItem ) . getPhoneNumber ( ) , 
 + ( ( ImportPhoneQueueItem ) importQueueItem ) . getName ( ) ) ) ; 
 + } else { 
 + throw new RuntimeException ( ) ; 
 + } 
 + } 
 + request ( new RequestImportContacts ( phoneToImports , emailToImports ) , new RpcCallback < ResponseImportContacts > ( ) { 
 @ Override 
 public void onResult ( ResponseImportContacts response ) { 
 - for ( ApiPhoneToImport phoneToImport : phones ) { 
 - markImported ( phoneToImport . getPhoneNumber ( ) ) ; 
 + 
 + / / 
 + / / Saving imported state 
 + / / 
 + 
 + for ( ApiPhoneToImport phoneToImport : phoneToImports ) { 
 + storage . markAsImported ( phoneToImport . getPhoneNumber ( ) ) ; 
 importingPhones . remove ( phoneToImport . getPhoneNumber ( ) ) ; 
 } 
 for ( ApiEmailToImport emailToImport : emailToImports ) { 
 - markImported ( emailToImport . getEmail ( ) ) ; 
 + storage . markAsImported ( emailToImport . getEmail ( ) ) ; 
 importingEmails . remove ( emailToImport . getEmail ( ) ) ; 
 } 
 + context ( ) . getContactsModule ( ) . getBookImportState ( ) . put ( 0 , storage . toByteArray ( ) ) ; 
 
 - if ( importingEmails . size ( ) = = 0 & & importingPhones . size ( ) = = 0 ) { 
 - markImported ( ) ; 
 - } 
 + / / 
 + / / Generating update 
 + / / 
 + if ( response . getUsers ( ) . size ( ) ! = 0 ) { 
 + if ( ENABLE _ LOG ) { 
 + Log . d ( TAG , " Import success with " + response . getUsers ( ) . size ( ) + " new contacts " ) ; 
 + } 
 
 - if ( response . getUsers ( ) . size ( ) = = 0 ) { 
 + ArrayList < Integer > uids = new ArrayList < Integer > ( ) ; 
 + for ( ApiUser u : response . getUsers ( ) ) { 
 + uids . add ( u . getId ( ) ) ; 
 + } 
 + updates ( ) . onUpdateReceived ( new FatSeqUpdate ( 
 + response . getSeq ( ) , response . getState ( ) , 
 + UpdateContactsAdded . HEADER , 
 + new UpdateContactsAdded ( uids ) . toByteArray ( ) , 
 + response . getUsers ( ) , 
 + new ArrayList < ApiGroup > ( ) ) ) ; 
 + } else { 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Import success , but no new contacts found " ) ; 
 } 
 - return ; 
 - } 
 - 
 - if ( ENABLE _ LOG ) { 
 - Log . d ( TAG , " Import success with " + response . getUsers ( ) . size ( ) + " new contacts " ) ; 
 } 
 
 - ArrayList < Integer > uids = new ArrayList < Integer > ( ) ; 
 - for ( ApiUser u : response . getUsers ( ) ) { 
 - uids . add ( u . getId ( ) ) ; 
 - } 
 - updates ( ) . onUpdateReceived ( new FatSeqUpdate ( 
 - response . getSeq ( ) , response . getState ( ) , 
 - UpdateContactsAdded . HEADER , 
 - new UpdateContactsAdded ( uids ) . toByteArray ( ) , 
 - response . getUsers ( ) , 
 - new ArrayList < ApiGroup > ( ) ) ) ; 
 + / / 
 + / / Launching next iteration 
 + / / 
 + isUploadingContacts = false ; 
 + performImportIfRequired ( ) ; 
 } 
 
 @ Override 
 public void onError ( RpcException e ) { 
 + 
 / / TODO : Better error handling 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Import failure " ) ; 
 } 
 e . printStackTrace ( ) ; 
 + 
 + / / 
 + / / Launching next iteration 
 + / / 
 + isUploadingContacts = false ; 
 + performImportIfRequired ( ) ; 
 } 
 } ) ; 
 } 
 
 - / / private boolean isImported ( long phone ) { 
 - / / return preferences ( ) . getBool ( " book _ phone _ " + phone , false ) ; 
 - / / } 
 - / / 
 - / / private boolean isImported ( String email ) { 
 - / / return preferences ( ) . getBool ( " book _ email _ " + email . toLowerCase ( ) , false ) ; 
 - / / } 
 - / / 
 - / / private void markImported ( long phone ) { 
 - / / preferences ( ) . putBool ( " book _ phone _ " + phone , true ) ; 
 - / / } 
 - / / 
 - / / private void markImported ( String email ) { 
 - / / preferences ( ) . putBool ( " book _ email _ " + email . toLowerCase ( ) , true ) ; 
 - / / } 
 - 
 - private void markImported ( ) { 
 - context ( ) . getAppStateModule ( ) . onBookImported ( ) ; 
 - } 
 - 
 @ Override 
 public void onReceive ( Object message ) { 
 if ( message instanceof PerformSync ) {

NEAREST DIFF:
diff - - git a / apps / actor - android / build . gradle b / apps / actor - android / build . gradle 
 index bb23e83 . . 0778011 100644 
 - - - a / apps / actor - android / build . gradle 
 + + + b / apps / actor - android / build . gradle 
 @ @ - 53 , 7 + 53 , 6 @ @ android { 
 def URL _ DEV1 = " \ " tls : / / mtproto - api - dev1 . actor . im : 443 \ " " ; 
 def URL _ DEV1 _ PLAIN = " \ " tcp : / / mtproto - api - dev1 . actor . im : 8080 \ " " ; 
 def URL _ DEV2 = " \ " tls : / / mtproto - api - dev2 . actor . im : 443 \ " " ; 
 - def URL _ LOCAL = " \ " tcp : / / 192 . 168 . 1 . 189 : 8080 \ " " ; 
 
 def HOCKEY _ MAIN = " \ " 38d528f118a899bbd503bda195609003 \ " " 
 def HOCKEY _ DEV1 = " \ " e2fb9a8444e1d8a5d90dba0e0c9ed534 \ " " 
 diff - - git a / apps / actor - android / src / main / java / im / actor / messenger / app / Core . java b / apps / actor - android / src / main / java / im / actor / messenger / app / Core . java 
 index 248c49a . . cfa7289 100644 
 - - - a / apps / actor - android / src / main / java / im / actor / messenger / app / Core . java 
 + + + b / apps / actor - android / src / main / java / im / actor / messenger / app / Core . java 
 @ @ - 56 , 6 + 56 , 7 @ @ public class Core { 
 
 / / Integrations 
 if ( BuildConfig . MINT ! = null ) { 
 + Mint . disableNetworkMonitoring ( ) ; 
 Mint . initAndStartSession ( application , BuildConfig . MINT ) ; 
 } 
 Fresco . initialize ( application ) ; 
 diff - - git a / apps / actor - android / src / main / java / im / actor / messenger / app / emoji / keyboard / EmojiKeyboardPopup . java b / apps / actor - android / src / main / java / im / actor / messenger / app / emoji / keyboard / EmojiKeyboardPopup . java 
 index 2418d2b . . 569476e 100644 
 - - - a / apps / actor - android / src / main / java / im / actor / messenger / app / emoji / keyboard / EmojiKeyboardPopup . java 
 + + + b / apps / actor - android / src / main / java / im / actor / messenger / app / emoji / keyboard / EmojiKeyboardPopup . java 
 @ @ - 43 , 8 + 43 , 6 @ @ import android . widget . ImageView ; 
 import android . widget . PopupWindow ; 
 import android . widget . RelativeLayout ; 
 
 - import com . facebook . drawee . view . SimpleDraweeView ; 
 - 
 import im . actor . messenger . R ; 
 import im . actor . messenger . app . base . BaseActivity ; 
 import im . actor . messenger . app . emoji . stickers . Stickers ; 
 @ @ - 244 , 10 + 242 , 13 @ @ public class EmojiKeyboardPopup extends PopupWindow 
 return 3 ; 
 } 
 } ) ; 
 - / / emojiContainer . addView ( createEmojiPagerView ( ) ) ; 
 - 
 - / * * / 
 - 
 + 
 + / / emojiPagerIndicator . setTabBackground ( R . drawable . md _ btn _ selector _ ripple ) ; 
 + emojiPagerIndicator . setIndicatorColorResource ( R . color . main _ tab _ selected ) ; 
 + emojiPagerIndicator . setIndicatorHeight ( Screen . dp ( 4 ) ) ; 
 + emojiPagerIndicator . setDividerColorResource ( R . color . main _ tab _ divider ) ; 
 + emojiPagerIndicator . setUnderlineHeight ( 0 ) ; 
 + emojiPagerIndicator . setTabPaddingLeftRight ( 0 ) ; 
 
 return keyboardView ; 
 } 
 diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java 
 index 2cc9e64 . . e084730 100644 
 - - - a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java 
 + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java 
 @ @ - 22 , 13 + 22 , 18 @ @ public class JavaNetworkProvider implements NetworkProvider { 
 public void run ( ) { 
 try { 
 createCallback . onConnectionCreated ( 
 - new JavaTcpConnection ( 
 + new JavaOldTcpConnection ( 
 connectionId , 
 - mtprotoVersion , 
 - apiMajorVersion , 
 - apiMinorVersion , 
 endpoint , 
 callback ) ) ; 
 + / / createCallback . onConnectionCreated ( 
 + / / new JavaTcpConnection ( 
 + / / connectionId , 
 + / / mtprotoVersion , 
 + / / apiMajorVersion , 
 + / / apiMinorVersion , 
 + / / endpoint , 
 + / / callback ) ) ; 
 } catch ( Exception e ) { 
 e . printStackTrace ( ) ; 
 createCallback . onConnectionCreateError ( ) ; 
 diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaOldTcpConnection . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaOldTcpConnection . java 
 new file mode 100644 
 index 0000000 . . 7e47ed4 
 - - - / dev / null 
 + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaOldTcpConnection . java 
 @ @ - 0 , 0 + 1 , 338 @ @ 
 + package im . actor . model . jvm ; 
 + 
 + import java . io . ByteArrayOutputStream ; 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 + import java . io . OutputStream ; 
 + import java . net . InetSocketAddress ; 
 + import java . net . Socket ; 
 + import java . util . concurrent . ConcurrentLinkedQueue ; 
 + import java . util . zip . CRC32 ; 
 + 
 + import javax . net . ssl . SSLSocketFactory ; 
 + 
 + import im . actor . model . log . Log ; 
 + import im . actor . model . network . Connection ; 
 + import im . actor . model . network . ConnectionCallback ; 
 + import im . actor . model . network . ConnectionEndpoint ; 
 + 
 + / * * 
 + * Created by ex3ndr on 06 . 02 . 15 . 
 + * / 
 + public class JavaOldTcpConnection implements Connection { 
 + 
 + private static final int CONNECTION _ TIMEOUT = 5 * 1000 ; 
 + private static final int READ _ DIE _ TIMEOUT = 15 * 1000 ; / / 5 sec 
 + private static final int MAX _ PACKAGE _ SIZE = 1024 * 1024 ; 
 + 
 + private final String TAG ; 
 + 
 + private ConnectionEndpoint endpoint ; 
 + private ConnectionCallback callback ; 
 + 
 + private final Socket socket ; 
 + 
 + private final ReaderThread readerThread ; 
 + private final WriterThread writerThread ; 
 + 
 + private int sentPackets ; 
 + private int receivedPackets ; 
 + 
 + private boolean isClosed ; 
 + 
 + public JavaOldTcpConnection ( int id , ConnectionEndpoint _ endpoint , ConnectionCallback _ callback ) throws IOException { 
 + this . TAG = " Connection # " + id ; 
 + this . endpoint = _ endpoint ; 
 + this . callback = _ callback ; 
 + 
 + switch ( endpoint . getType ( ) ) { 
 + case TCP : 
 + socket = new Socket ( ) ; 
 + break ; 
 + case TCP _ TLS : 
 + socket = SSLSocketFactory . getDefault ( ) . createSocket ( ) ; 
 + break ; 
 + default : 
 + throw new IOException ( " Unsupported endpoint type : " + endpoint . getType ( ) ) ; 
 + } 
 + 
 + / / if ( ! params . getConfig ( ) . isChromeEnabled ( ) ) { 
 + this . socket . setKeepAlive ( true ) ; 
 + this . socket . setTcpNoDelay ( true ) ; 
 + / / } 
 + 
 + this . socket . connect ( new InetSocketAddress ( endpoint . getHost ( ) , endpoint . getPort ( ) ) , CONNECTION _ TIMEOUT ) ; 
 + 
 + / / Init socket streams 
 + this . socket . getInputStream ( ) ; 
 + this . socket . getOutputStream ( ) ; 
 + 
 + / / TODO : Implement handshake 
 + / / ? ? ? 
 + 
 + readerThread = new ReaderThread ( ) ; 
 + writerThread = new WriterThread ( ) ; 
 + readerThread . start ( ) ; 
 + writerThread . start ( ) ; 
 + } 
 + 
 + @ Override 
 + public void post ( byte [ ] data , int offset , int len ) { 
 + writerThread . pushPackage ( new Package ( data ) ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isClosed ( ) { 
 + return isClosed ; 
 + } 
 + 
 + @ Override 
 + public void close ( ) { 
 + breakConnection ( ) ; 
 + } 
 + 
 + private synchronized void breakConnection ( ) { 
 + if ( ! isClosed ) { 
 + Log . w ( TAG , " Breaking connection " ) ; 
 + isClosed = true ; 
 + try { 
 + readerThread . interrupt ( ) ; 
 + } catch ( final Exception e ) { 
 + Log . e ( TAG , e ) ; 
 + } 
 + 
 + try { 
 + writerThread . interrupt ( ) ; 
 + } catch ( final Exception e ) { 
 + Log . e ( TAG , e ) ; 
 + } 
 + 
 + / / try { 
 + / / dieThread . interrupt ( ) ; 
 + / / } catch ( final Exception e ) { 
 + / / Log . e ( TAG , e ) ; 
 + / / } 
 + 
 + try { 
 + socket . close ( ) ; 
 + } catch ( IOException e ) { 
 + Log . e ( TAG , e ) ; 
 + } 
 + 
 + callback . onConnectionDie ( ) ; 
 + } 
 + } 
 + 
 + private class ReaderThread extends Thread { 
 + private ReaderThread ( ) { 
 + setPriority ( Thread . MIN _ PRIORITY ) ; 
 + setName ( TAG + " # Reader " + hashCode ( ) ) ; 
 + } 
 + 
 + @ Override 
 + public void run ( ) { 
 + try { 
 + while ( ! isClosed & & ! isInterrupted ( ) ) { 
 + if ( socket . isClosed ( ) ) { 
 + Log . d ( TAG , " Socket is closed " ) ; 
 + throw new IOException ( " Socket is closed " ) ; 
 + } 
 + if ( ! socket . isConnected ( ) ) { 
 + Log . d ( TAG , " Socket is not connected " ) ; 
 + throw new IOException ( " Socket is not connected " ) ; 
 + } 
 + 
 + InputStream stream = socket . getInputStream ( ) ; 
 + long start = System . currentTimeMillis ( ) ; 
 + 
 + / / Length 
 + / / if ( LOG ! = null & & DEBUG ) { 
 + / / LOG . d ( TAG , " Reading content length " ) ; 
 + / / } 
 + int pkgLen = readInt ( stream ) ; 
 + if ( pkgLen < 0 | | pkgLen > MAX _ PACKAGE _ SIZE ) { 
 + Log . w ( TAG , " Invalid package size : " + pkgLen ) ; 
 + throw new IOException ( " Invalid package size " ) ; 
 + } 
 + 
 + / / Index 
 + / / if ( LOG ! = null & & DEBUG ) { 
 + / / LOG . d ( TAG , " Reading package index " ) ; 
 + / / } 
 + int pkgIndex = readInt ( stream ) ; 
 + int expectedIndex = receivedPackets + + ; 
 + if ( pkgIndex ! = expectedIndex ) { 
 + / / if ( LOG ! = null ) { 
 + / / LOG . w ( TAG , " Wrong seq . Expected " + expectedIndex + " , got " + pkgIndex ) ; 
 + / / } 
 + Log . w ( TAG , " Wrong seq . Expected " + expectedIndex + " , got " + pkgIndex ) ; 
 + throw new IOException ( " Wrong number of received packets " ) ; 
 + } 
 + 
 + / / Content 
 + / / if ( LOG ! = null & & DEBUG ) { 
 + / / LOG . d ( TAG , " Reading package content of " + pkgLen + " bytes " ) ; 
 + / / } 
 + byte [ ] pkg = readBytes ( pkgLen - 8 , stream ) ; 
 + 
 + / / CRC32 
 + / / if ( LOG ! = null & & DEBUG ) { 
 + / / LOG . d ( TAG , " Reading CRC32 " ) ; 
 + / / } 
 + int pkgCrc = readInt ( stream ) ; 
 + CRC32 crc32 = new CRC32 ( ) ; 
 + crc32 . update ( intToBytes ( pkgLen ) ) ; 
 + crc32 . update ( intToBytes ( pkgIndex ) ) ; 
 + crc32 . update ( pkg ) ; 
 + int localCrc = ( int ) crc32 . getValue ( ) ; 
 + 
 + if ( localCrc ! = pkgCrc ) { 
 + Log . w ( TAG , " Package crc32 expected : " + localCrc + " , got : " + pkgCrc ) ; 
 + throw new IOException ( " Wrong CRC " ) ; 
 + } 
 + 
 + / / if ( LOG ! = null & & DEBUG ) { 
 + / / LOG . d ( TAG , " Read # " + pkgIndex + " in " + ( System . currentTimeMillis ( ) - start ) + " ms " ) ; 
 + / / } 
 + callback . onMessage ( pkg , 0 , pkg . length ) ; 
 + } 
 + } catch ( final Throwable e ) { 
 + Log . e ( TAG , e ) ; 
 + breakConnection ( ) ; 
 + } 
 + } 
 + } 
 + 
 + private class WriterThread extends Thread { 
 + 
 + private final CRC32 crc32 = new CRC32 ( ) ; 
 + private final ConcurrentLinkedQueue < Package > packages = new ConcurrentLinkedQueue < Package > ( ) ; 
 + 
 + public WriterThread ( ) { 
 + setPriority ( Thread . MIN _ PRIORITY ) ; 
 + setName ( TAG + " # Writer " + hashCode ( ) ) ; 
 + } 
 + 
 + public void pushPackage ( final Package p ) { 
 + packages . add ( p ) ; 
 + synchronized ( packages ) { 
 + packages . notifyAll ( ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void run ( ) { 
 + while ( ! isClosed & & ! isInterrupted ( ) ) { 
 + Package p ; 
 + synchronized ( packages ) { 
 + p = packages . poll ( ) ; 
 + if ( p = = null ) { 
 + try { 
 + packages . wait ( ) ; 
 + } catch ( final InterruptedException e ) { 
 + return ; 
 + } 
 + p = packages . poll ( ) ; 
 + } 
 + } 
 + if ( p = = null ) { 
 + continue ; 
 + } 
 + 
 + try { 
 + byte [ ] data = p . data ; 
 + int length = data . length + 8 ; 
 + 
 + ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; 
 + writeInt ( length , outputStream ) ; 
 + writeInt ( sentPackets , outputStream ) ; 
 + writeBytes ( data , outputStream ) ; 
 + crc32 . reset ( ) ; 
 + crc32 . update ( outputStream . toByteArray ( ) ) ; 
 + writeInt ( ( int ) crc32 . getValue ( ) , outputStream ) ; 
 + socket . getOutputStream ( ) . write ( outputStream . toByteArray ( ) ) ; 
 + socket . getOutputStream ( ) . flush ( ) ; 
 + / / onWrite ( ) ; 
 + 
 + sentPackets + + ; 
 + } catch ( final Exception e ) { 
 + Log . e ( TAG , e ) ; 
 + breakConnection ( ) ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + public static byte [ ] intToBytes ( int v ) { 
 + return new byte [ ] { 
 + ( byte ) ( ( v > > 24 ) & 0xFF ) , 
 + ( byte ) ( ( v > > 16 ) & 0xFF ) , 
 + ( byte ) ( ( v > > 8 ) & 0xFF ) , 
 + ( byte ) ( v & 0xFF ) 
 + } ; 
 + } 
 + 
 + public static void writeByte ( byte v , OutputStream stream ) throws IOException { 
 + stream . write ( v ) ; 
 + } 
 + 
 + public static void writeBytes ( byte [ ] data , OutputStream stream ) throws IOException { 
 + stream . write ( data ) ; 
 + } 
 + 
 + public static void writeInt ( int v , OutputStream stream ) throws IOException { 
 + writeByte ( ( byte ) ( ( v > > 24 ) & 0xFF ) , stream ) ; 
 + writeByte ( ( byte ) ( ( v > > 16 ) & 0xFF ) , stream ) ; 
 + writeByte ( ( byte ) ( ( v > > 8 ) & 0xFF ) , stream ) ; 
 + writeByte ( ( byte ) ( v & 0xFF ) , stream ) ; 
 + } 
 + 
 + public static int readInt ( InputStream stream ) throws IOException { 
 + int a = stream . read ( ) ; 
 + if ( a < 0 ) { 
 + throw new IOException ( ) ; 
 + } 
 + int b = stream . read ( ) ; 
 + if ( b < 0 ) { 
 + throw new IOException ( ) ; 
 + } 
 + int c = stream . read ( ) ; 
 + if ( c < 0 ) { 
 + throw new IOException ( ) ; 
 + } 
 + int d = stream . read ( ) ; 
 + if ( d < 0 ) { 
 + throw new IOException ( ) ; 
 + } 
 + 
 + return d + ( c < < 8 ) + ( b < < 16 ) + ( a < < 24 ) ; 
 + } 
 + 
 + public static byte [ ] readBytes ( int count , InputStream stream ) throws IOException { 
 + byte [ ] res = new byte [ count ] ; 
 + int offset = 0 ; 
 + while ( offset < res . length ) { 
 + int readed = stream . read ( res , offset , res . length - offset ) ; 
 + if ( readed > 0 ) { 
 + offset + = readed ; 
 + } else if ( readed < 0 ) { 
 + throw new IOException ( ) ; 
 + } else { 
 + Thread . yield ( ) ; 
 + } 
 + } 
 + return res ; 
 + } 
 + 
 + private class Package { 
 + public byte [ ] data ; 
 + 
 + public Package ( ) { 
 + 
 + } 
 + 
 + private Package ( final byte [ ] data ) { 
 + this . data = data ; 
 + } 
 + } 
 + }
