BLEU SCORE: 0.1661742929957894

TEST MSG: fix ( server : core ) : dont make timeout when there are no messages in group dialog
GENERATED MSG: fix ( server : messaging ) : fail - tolerant dialog init

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 2baf690 . . 8330296 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 158 , 7 + 158 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case Status . Failure ( e ) ⇒ < nl > log . error ( e , " Failed to init dialog " ) < nl > self ! Kill < nl > - } : Receive ) orElse reactions ( isHidden = false ) ) < nl > + } : Receive ) orElse reactions ( isHidden = false ) orElse dummyActions ) < nl > < nl > ( for { < nl > state ← initialState < nl > @ @ - 184 , 11 + 184 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > } yield resultMessage ) . to ( self , sender ( ) ) < nl > } < nl > < nl > - private def isWriteOperation : PartialFunction [ Any , Boolean ] = { < nl > - case _ : SendMessage | _ : WriteMessage | _ : WriteMessageSelf ⇒ true < nl > - case _ ⇒ false < nl > - } < nl > - < nl > def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( isHidden = state . isHidden ) < nl > < nl > / / when receiving this messages , dialog reacts on other dialog ' s action < nl > @ @ - 201 , 6 + 196 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case uc : UpdateCounters ⇒ updateCountersChanged ( ) < nl > } < nl > < nl > + def dummyActions : Receive = { < nl > + case mrv : MessageReceived if invokes ( mrv ) ⇒ Future . successful ( MessageReceivedAck ( ) ) pipeTo sender ( ) < nl > + case mrd : MessageRead if invokes ( mrd ) ⇒ Future . successful ( MessageReadAck ( ) ) pipeTo sender ( ) < nl > + } < nl > + < nl > / / when receiving this messages , dialog required to take action < nl > def actions ( state : DialogState ) : Receive = { < nl > case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > @ @ - 243 , 6 + 243 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > * / < nl > private def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) < nl > < nl > + private def isWriteOperation : PartialFunction [ Any , Boolean ] = { < nl > + case _ : SendMessage | _ : WriteMessage | _ : WriteMessageSelf ⇒ true < nl > + case _ ⇒ false < nl > + } < nl > + < nl > private def initialState : Future [ InitState ] = < nl > for { < nl > optDialog ← db . run ( DialogRepo . findDialog ( userId , peer ) ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > index 7e097a1 . . fdb8ad5 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > @ @ - 20 , 6 + 20 , 7 @ @ final class GroupsServiceSpec < nl > extends BaseAppSuite < nl > with GroupsServiceHelpers < nl > with MessageParsing < nl > + with MessagingSpecHelpers < nl > with ImplicitSequenceService < nl > with ImplicitAuthService < nl > with ImplicitSessionRegion < nl > @ @ - 512 , 6 + 513 , 8 @ @ final class GroupsServiceSpec < nl > < nl > whenReady ( service . handleInviteUser ( groupOutPeer , Random . nextLong , user2OutPeer ) ) { _ ⇒ } < nl > < nl > + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " This is message to initialize group dialog " , Vector . empty , None ) ) < nl > + < nl > groupOutPeer < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > index dd3f950 . . b7a71be 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > @ @ - 2 , 7 + 2 , 8 @ @ package im . actor . server . dialog < nl > < nl > import java . time . Instant < nl > < nl > - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } < nl > + import akka . actor . _ < nl > + import akka . pattern . pipe < nl > import akka . util . Timeout < nl > import com . github . benmanes . caffeine . cache . Cache < nl > import im . actor . api . rpc . misc . ApiExtension < nl > @ @ - 118 , 14 + 119 , 17 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = < nl > createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) < nl > < nl > - createDialogIfNeeded ( ) < nl > + init ( ) < nl > < nl > - override def receive : Receive = init < nl > + override def receive : Receive = initializing < nl > < nl > - def init : Receive = receiveStashing ( replyTo ⇒ { < nl > + def initializing : Receive = receiveStashing ( replyTo ⇒ { < nl > case Initialized ( isHidden ) ⇒ < nl > context become initialized ( DialogState ( isHidden = isHidden ) ) < nl > unstashAll ( ) < nl > + case Status . Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to init dialog " ) < nl > + self ! Kill < nl > } ) < nl > < nl > def initialized ( state : DialogState ) : Receive = { < nl > @ @ - 165 , 7 + 169 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > * / < nl > def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) < nl > < nl > - private [ this ] def createDialogIfNeeded ( ) : Future [ Unit ] = < nl > + private [ this ] def init ( ) : Unit = < nl > db . run ( for { < nl > optDialog ← DialogRepo . find ( userId , peer ) < nl > dialog ← optDialog match { < nl > @ @ - 177 , 6 + 181 , 6 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > } yield dialog < nl > } < nl > - } yield { self ! Initialized ( dialog . shownAt . isEmpty ) } ) < nl > + } yield Initialized ( dialog . shownAt . isEmpty ) ) pipeTo self < nl > < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 61849ba . . 0a34a19 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 131 , 7 + 131 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } else { < nl > Future . successful ( MessageReadAck ( ) ) < nl > } ) pipeTo sender ( ) andThen { < nl > - case Failure ( e ) = > log . error ( e , " Failed to ack MessageRead " ) < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) < nl > } < nl > < nl > if ( mustRead ) { < nl > @ @ - 143 , 9 + 143 , 9 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > < nl > protected def ackMessageRead ( state : DialogState , mr : MessageRead ) : Unit = { < nl > val notifyFuture = ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { < nl > - case Failure ( e ) = > log . error ( e , " Failed to ack MessageRead " ) < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) < nl > } < nl > - < nl > + < nl > onSuccess ( notifyFuture ) { _ ⇒ < nl > updatePeerReadDate ( state , mr . date ) < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 2baf690 . . 8330296 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 158 , 7 + 158 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case Status . Failure ( e ) ⇒ 
 log . error ( e , " Failed to init dialog " ) 
 self ! Kill 
 - } : Receive ) orElse reactions ( isHidden = false ) ) 
 + } : Receive ) orElse reactions ( isHidden = false ) orElse dummyActions ) 
 
 ( for { 
 state ← initialState 
 @ @ - 184 , 11 + 184 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 } yield resultMessage ) . to ( self , sender ( ) ) 
 } 
 
 - private def isWriteOperation : PartialFunction [ Any , Boolean ] = { 
 - case _ : SendMessage | _ : WriteMessage | _ : WriteMessageSelf ⇒ true 
 - case _ ⇒ false 
 - } 
 - 
 def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( isHidden = state . isHidden ) 
 
 / / when receiving this messages , dialog reacts on other dialog ' s action 
 @ @ - 201 , 6 + 196 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case uc : UpdateCounters ⇒ updateCountersChanged ( ) 
 } 
 
 + def dummyActions : Receive = { 
 + case mrv : MessageReceived if invokes ( mrv ) ⇒ Future . successful ( MessageReceivedAck ( ) ) pipeTo sender ( ) 
 + case mrd : MessageRead if invokes ( mrd ) ⇒ Future . successful ( MessageReadAck ( ) ) pipeTo sender ( ) 
 + } 
 + 
 / / when receiving this messages , dialog required to take action 
 def actions ( state : DialogState ) : Receive = { 
 case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 @ @ - 243 , 6 + 243 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 * / 
 private def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) 
 
 + private def isWriteOperation : PartialFunction [ Any , Boolean ] = { 
 + case _ : SendMessage | _ : WriteMessage | _ : WriteMessageSelf ⇒ true 
 + case _ ⇒ false 
 + } 
 + 
 private def initialState : Future [ InitState ] = 
 for { 
 optDialog ← db . run ( DialogRepo . findDialog ( userId , peer ) ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 index 7e097a1 . . fdb8ad5 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 @ @ - 20 , 6 + 20 , 7 @ @ final class GroupsServiceSpec 
 extends BaseAppSuite 
 with GroupsServiceHelpers 
 with MessageParsing 
 + with MessagingSpecHelpers 
 with ImplicitSequenceService 
 with ImplicitAuthService 
 with ImplicitSessionRegion 
 @ @ - 512 , 6 + 513 , 8 @ @ final class GroupsServiceSpec 
 
 whenReady ( service . handleInviteUser ( groupOutPeer , Random . nextLong , user2OutPeer ) ) { _ ⇒ } 
 
 + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " This is message to initialize group dialog " , Vector . empty , None ) ) 
 + 
 groupOutPeer 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 index dd3f950 . . b7a71be 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 @ @ - 2 , 7 + 2 , 8 @ @ package im . actor . server . dialog 
 
 import java . time . Instant 
 
 - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } 
 + import akka . actor . _ 
 + import akka . pattern . pipe 
 import akka . util . Timeout 
 import com . github . benmanes . caffeine . cache . Cache 
 import im . actor . api . rpc . misc . ApiExtension 
 @ @ - 118 , 14 + 119 , 17 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = 
 createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) 
 
 - createDialogIfNeeded ( ) 
 + init ( ) 
 
 - override def receive : Receive = init 
 + override def receive : Receive = initializing 
 
 - def init : Receive = receiveStashing ( replyTo ⇒ { 
 + def initializing : Receive = receiveStashing ( replyTo ⇒ { 
 case Initialized ( isHidden ) ⇒ 
 context become initialized ( DialogState ( isHidden = isHidden ) ) 
 unstashAll ( ) 
 + case Status . Failure ( e ) ⇒ 
 + log . error ( e , " Failed to init dialog " ) 
 + self ! Kill 
 } ) 
 
 def initialized ( state : DialogState ) : Receive = { 
 @ @ - 165 , 7 + 169 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 * / 
 def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) 
 
 - private [ this ] def createDialogIfNeeded ( ) : Future [ Unit ] = 
 + private [ this ] def init ( ) : Unit = 
 db . run ( for { 
 optDialog ← DialogRepo . find ( userId , peer ) 
 dialog ← optDialog match { 
 @ @ - 177 , 6 + 181 , 6 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 } yield dialog 
 } 
 - } yield { self ! Initialized ( dialog . shownAt . isEmpty ) } ) 
 + } yield Initialized ( dialog . shownAt . isEmpty ) ) pipeTo self 
 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 61849ba . . 0a34a19 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 131 , 7 + 131 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } else { 
 Future . successful ( MessageReadAck ( ) ) 
 } ) pipeTo sender ( ) andThen { 
 - case Failure ( e ) = > log . error ( e , " Failed to ack MessageRead " ) 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) 
 } 
 
 if ( mustRead ) { 
 @ @ - 143 , 9 + 143 , 9 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 
 protected def ackMessageRead ( state : DialogState , mr : MessageRead ) : Unit = { 
 val notifyFuture = ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { 
 - case Failure ( e ) = > log . error ( e , " Failed to ack MessageRead " ) 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) 
 } 
 - 
 + 
 onSuccess ( notifyFuture ) { _ ⇒ 
 updatePeerReadDate ( state , mr . date ) 
 }
