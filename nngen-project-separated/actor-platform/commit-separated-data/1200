BLEU SCORE: 0.27824623288353134

TEST MSG: Update and rename axolotl - ratchet . md to actor - ratchet . md
GENERATED MSG: Update axolotl - ratchet . md

TEST DIFF (one line): diff - - git a / docs / e2e / actor - ratchet . md b / docs / e2e / actor - ratchet . md < nl > new file mode 100644 < nl > index 0000000 . . 36d646c < nl > - - - / dev / null < nl > + + + b / docs / e2e / actor - ratchet . md < nl > @ @ - 0 , 0 + 1 , 75 @ @ < nl > + # Actor Ratchet ( ex Axolotl Ratchet ) < nl > + < nl > + Actor Ratchet is based on ideas of Axolotl Ratchet , but imrove it to make it self - healing proto if something goes wrong in implementation or device environment . < nl > + < nl > + Axolotl also requires to keep RootKey and complex state about encryption . We are trying to avoid this and make proto to be able to automatically heal itself . < nl > + < nl > + Instead of Axolotl , Actor Ratchet support multi - device key syncing for better performance and less offline key verification iterations . < nl > + < nl > + There are various sources for describing Axolotl Ratchet and there are different ways to implement this , our specs are based on : < nl > + * https : / / whispersystems . org / blog / advanced - ratcheting / < nl > + * https : / / github . com / trevp / axolotl / wiki < nl > + * https : / / github . com / WhisperSystems / Signal - Android / wiki / ProtocolV2 < nl > + < nl > + # Public Keys < nl > + < nl > + Each Key Group have Curve25519 public keys : < nl > + * * * Identity Key * * - main static public key that is used for identification < nl > + * * * Ephermal Keys * * - a lot of temporary public keys that is used to start conversaion < nl > + * * * Last Chance Key * * - semi - static key that is used when there are no ephermal keys are available < nl > + < nl > + All this keys are uploaded to Actor Server befor starting communcation . < nl > + < nl > + # Description < nl > + < nl > + Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . < nl > + < nl > + When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . < nl > + < nl > + We start with case when Alice wants to send message to Bob for the first time . < nl > + < nl > + Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs < nl > + < nl > + Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs < nl > + < nl > + # # Computing parameters for first message < nl > + < nl > + Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : < nl > + ` ` ` < nl > + master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) < nl > + master _ secret _ extendend = HKDF ( master _ secret , 64 ) < nl > + root _ key = master _ secret _ extendend [ 0 . . 31 ] < nl > + chain _ key = master _ secret _ extendend [ 32 . . 63 ] < nl > + ` ` ` < nl > + < nl > + # # Encryption key for a message < nl > + For each message chain _ key is derived to a message _ key : < nl > + ` ` ` < nl > + message _ key = HMAC _ SHA256 ( chain _ key , 0x01 ) < nl > + message _ key _ extendend = HKDF ( message _ key , 64 ) < nl > + cipher _ key = message _ key _ extendend [ 0 . . 31 ] < nl > + mac _ key = message _ key _ extendend [ 32 . . 63 ] < nl > + ` ` ` < nl > + < nl > + # # Encryption < nl > + < nl > + Binary plain - text message is encrypted and MACed : < nl > + ` ` ` < nl > + iv = random [ 0 . . 16 ] < nl > + cipher _ text = AES - 128 - CBC ( iv , cipher _ key , plain _ text ) < nl > + cipher _ mac = HMAC _ SHA256 ( mac _ key , cipher _ text ) < nl > + ` ` ` < nl > + < nl > + # # Packing Result < nl > + < nl > + Encrypted Result is serialized to : < nl > + < nl > + ` ` ` < nl > + PreMessage { < nl > + identity : bytes = AI < nl > + used _ ephermal _ id : int63 = B0 . id < nl > + iv : bytes < nl > + cipher _ text : bytes < nl > + cipher _ mac : bytes < nl > + } < nl > + ` ` ` < nl > diff - - git a / docs / e2e / axolotl - ratchet . md b / docs / e2e / axolotl - ratchet . md < nl > deleted file mode 100644 < nl > index 9c021c4 . . 0000000 < nl > - - - a / docs / e2e / axolotl - ratchet . md < nl > + + + / dev / null < nl > @ @ - 1 , 71 + 0 , 0 @ @ < nl > - # Axolotl Ratchet < nl > - < nl > - There are various sources for describing Axolotl Ratchet and there are different ways to implement this : < nl > - * https : / / whispersystems . org / blog / advanced - ratcheting / < nl > - * https : / / github . com / trevp / axolotl / wiki < nl > - * https : / / github . com / WhisperSystems / Signal - Android / wiki / ProtocolV2 < nl > - < nl > - We are trying to combine everything one one actual documentation and implement it in Actor . < nl > - < nl > - # Public Keys < nl > - < nl > - Each Key Group have Curve25519 public keys : < nl > - * * * Identity Key * * - main static public key that is used for identification < nl > - * * * Ephermal Keys * * - a lot of temporary public keys that is used to start conversaion < nl > - * * * Last Chance Key * * - semi - static key that is used when there are no ephermal keys are available < nl > - < nl > - All this keys are uploaded to Actor Server befor starting communcation . < nl > - < nl > - # Description < nl > - < nl > - Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . < nl > - < nl > - When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . < nl > - < nl > - We start with case when Alice wants to send message to Bob for the first time . < nl > - < nl > - Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs < nl > - < nl > - Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs < nl > - < nl > - # # Computing parameters for first message < nl > - < nl > - Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : < nl > - ` ` ` < nl > - master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) < nl > - master _ secret _ extendend = HKDF ( master _ secret , 64 ) < nl > - root _ key = master _ secret _ extendend [ 0 . . 31 ] < nl > - chain _ key = master _ secret _ extendend [ 32 . . 63 ] < nl > - ` ` ` < nl > - < nl > - # # Encryption key for a message < nl > - For each message chain _ key is derived to a message _ key : < nl > - ` ` ` < nl > - message _ key = HMAC _ SHA256 ( chain _ key , 0x01 ) < nl > - message _ key _ extendend = HKDF ( message _ key , 64 ) < nl > - cipher _ key = message _ key _ extendend [ 0 . . 31 ] < nl > - mac _ key = message _ key _ extendend [ 32 . . 63 ] < nl > - ` ` ` < nl > - < nl > - # # Encryption < nl > - < nl > - Binary plain - text message is encrypted and MACed : < nl > - ` ` ` < nl > - iv = random [ 0 . . 16 ] < nl > - cipher _ text = AES - 128 - CBC ( iv , cipher _ key , plain _ text ) < nl > - cipher _ mac = HMAC _ SHA256 ( mac _ key , cipher _ text ) < nl > - ` ` ` < nl > - < nl > - # # Packing Result < nl > - < nl > - Encrypted Result is serialized to : < nl > - < nl > - ` ` ` < nl > - PreMessage { < nl > - identity : bytes = AI < nl > - used _ ephermal _ id : int63 = B0 . id < nl > - iv : bytes < nl > - cipher _ text : bytes < nl > - cipher _ mac : bytes < nl > - } < nl > - ` ` `
NEAREST DIFF (one line): diff - - git a / docs / e2e / axolotl - ratchet . md b / docs / e2e / axolotl - ratchet . md < nl > index 90fd441 . . a2c0da5 100644 < nl > - - - a / docs / e2e / axolotl - ratchet . md < nl > + + + b / docs / e2e / axolotl - ratchet . md < nl > @ @ - 1 , 5 + 1 , 12 @ @ < nl > # Axolotl Ratchet < nl > < nl > + There are various sources for describing Axolotl Ratchet and there are different ways to implement this : < nl > + * https : / / whispersystems . org / blog / advanced - ratcheting / < nl > + * https : / / github . com / trevp / axolotl / wiki < nl > + * https : / / github . com / WhisperSystems / Signal - Android / wiki / ProtocolV2 < nl > + < nl > + We are trying to combine everything one one actual documentation and implement it in Actor . < nl > + < nl > # Public Keys < nl > < nl > Each Key Group have Curve25519 public keys : < nl > @ @ - 11 , 28 + 18 , 22 @ @ All this keys are uploaded to Actor Server befor starting communcation . < nl > < nl > # Description < nl > < nl > + Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . < nl > + < nl > + When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . < nl > + < nl > We start with case when Alice wants to send message to Bob for the first time . < nl > < nl > Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs < nl > < nl > Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs < nl > < nl > - # # Building initial initial _ root _ key < nl > - < nl > - Alice compute initial _ root _ key : < nl > - ` ` ` < nl > - initial _ root _ key = SHA256 ( ECDH ( AI ' , BI ) + ECDH ( AI ' , BI ) ) < nl > - ` ` ` < nl > - Bob compute initial _ root _ key : < nl > - ` ` ` < nl > - initial _ root _ key = SHA256 ( ECDH ( A0 , BI ' ) + ECDH ( AI ' , BI ) ) < nl > - ` ` ` < nl > - < nl > # # Computing parameters for first message < nl > < nl > - Alice generates random ephermal key pair ( A1 , A1 ' ) and picks random Bob ' s ephermal key - B1 < nl > - < nl > + Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : < nl > ` ` ` < nl > - master _ secret = SHA256 ( initial _ root _ key + ECDH ( A1 ' , B1 ) ) < nl > + master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) < nl > + master _ secret _ extendend = HKDF ( master _ secret , 64 ) < nl > + root _ key = master _ secret _ extendend [ 0 . . 31 ] < nl > + chain _ key = master _ secret _ extendend [ 32 . . 63 ] < nl > ` ` ` < nl > -

TEST DIFF:
diff - - git a / docs / e2e / actor - ratchet . md b / docs / e2e / actor - ratchet . md 
 new file mode 100644 
 index 0000000 . . 36d646c 
 - - - / dev / null 
 + + + b / docs / e2e / actor - ratchet . md 
 @ @ - 0 , 0 + 1 , 75 @ @ 
 + # Actor Ratchet ( ex Axolotl Ratchet ) 
 + 
 + Actor Ratchet is based on ideas of Axolotl Ratchet , but imrove it to make it self - healing proto if something goes wrong in implementation or device environment . 
 + 
 + Axolotl also requires to keep RootKey and complex state about encryption . We are trying to avoid this and make proto to be able to automatically heal itself . 
 + 
 + Instead of Axolotl , Actor Ratchet support multi - device key syncing for better performance and less offline key verification iterations . 
 + 
 + There are various sources for describing Axolotl Ratchet and there are different ways to implement this , our specs are based on : 
 + * https : / / whispersystems . org / blog / advanced - ratcheting / 
 + * https : / / github . com / trevp / axolotl / wiki 
 + * https : / / github . com / WhisperSystems / Signal - Android / wiki / ProtocolV2 
 + 
 + # Public Keys 
 + 
 + Each Key Group have Curve25519 public keys : 
 + * * * Identity Key * * - main static public key that is used for identification 
 + * * * Ephermal Keys * * - a lot of temporary public keys that is used to start conversaion 
 + * * * Last Chance Key * * - semi - static key that is used when there are no ephermal keys are available 
 + 
 + All this keys are uploaded to Actor Server befor starting communcation . 
 + 
 + # Description 
 + 
 + Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . 
 + 
 + When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . 
 + 
 + We start with case when Alice wants to send message to Bob for the first time . 
 + 
 + Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs 
 + 
 + Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs 
 + 
 + # # Computing parameters for first message 
 + 
 + Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : 
 + ` ` ` 
 + master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) 
 + master _ secret _ extendend = HKDF ( master _ secret , 64 ) 
 + root _ key = master _ secret _ extendend [ 0 . . 31 ] 
 + chain _ key = master _ secret _ extendend [ 32 . . 63 ] 
 + ` ` ` 
 + 
 + # # Encryption key for a message 
 + For each message chain _ key is derived to a message _ key : 
 + ` ` ` 
 + message _ key = HMAC _ SHA256 ( chain _ key , 0x01 ) 
 + message _ key _ extendend = HKDF ( message _ key , 64 ) 
 + cipher _ key = message _ key _ extendend [ 0 . . 31 ] 
 + mac _ key = message _ key _ extendend [ 32 . . 63 ] 
 + ` ` ` 
 + 
 + # # Encryption 
 + 
 + Binary plain - text message is encrypted and MACed : 
 + ` ` ` 
 + iv = random [ 0 . . 16 ] 
 + cipher _ text = AES - 128 - CBC ( iv , cipher _ key , plain _ text ) 
 + cipher _ mac = HMAC _ SHA256 ( mac _ key , cipher _ text ) 
 + ` ` ` 
 + 
 + # # Packing Result 
 + 
 + Encrypted Result is serialized to : 
 + 
 + ` ` ` 
 + PreMessage { 
 + identity : bytes = AI 
 + used _ ephermal _ id : int63 = B0 . id 
 + iv : bytes 
 + cipher _ text : bytes 
 + cipher _ mac : bytes 
 + } 
 + ` ` ` 
 diff - - git a / docs / e2e / axolotl - ratchet . md b / docs / e2e / axolotl - ratchet . md 
 deleted file mode 100644 
 index 9c021c4 . . 0000000 
 - - - a / docs / e2e / axolotl - ratchet . md 
 + + + / dev / null 
 @ @ - 1 , 71 + 0 , 0 @ @ 
 - # Axolotl Ratchet 
 - 
 - There are various sources for describing Axolotl Ratchet and there are different ways to implement this : 
 - * https : / / whispersystems . org / blog / advanced - ratcheting / 
 - * https : / / github . com / trevp / axolotl / wiki 
 - * https : / / github . com / WhisperSystems / Signal - Android / wiki / ProtocolV2 
 - 
 - We are trying to combine everything one one actual documentation and implement it in Actor . 
 - 
 - # Public Keys 
 - 
 - Each Key Group have Curve25519 public keys : 
 - * * * Identity Key * * - main static public key that is used for identification 
 - * * * Ephermal Keys * * - a lot of temporary public keys that is used to start conversaion 
 - * * * Last Chance Key * * - semi - static key that is used when there are no ephermal keys are available 
 - 
 - All this keys are uploaded to Actor Server befor starting communcation . 
 - 
 - # Description 
 - 
 - Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . 
 - 
 - When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . 
 - 
 - We start with case when Alice wants to send message to Bob for the first time . 
 - 
 - Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs 
 - 
 - Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs 
 - 
 - # # Computing parameters for first message 
 - 
 - Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : 
 - ` ` ` 
 - master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) 
 - master _ secret _ extendend = HKDF ( master _ secret , 64 ) 
 - root _ key = master _ secret _ extendend [ 0 . . 31 ] 
 - chain _ key = master _ secret _ extendend [ 32 . . 63 ] 
 - ` ` ` 
 - 
 - # # Encryption key for a message 
 - For each message chain _ key is derived to a message _ key : 
 - ` ` ` 
 - message _ key = HMAC _ SHA256 ( chain _ key , 0x01 ) 
 - message _ key _ extendend = HKDF ( message _ key , 64 ) 
 - cipher _ key = message _ key _ extendend [ 0 . . 31 ] 
 - mac _ key = message _ key _ extendend [ 32 . . 63 ] 
 - ` ` ` 
 - 
 - # # Encryption 
 - 
 - Binary plain - text message is encrypted and MACed : 
 - ` ` ` 
 - iv = random [ 0 . . 16 ] 
 - cipher _ text = AES - 128 - CBC ( iv , cipher _ key , plain _ text ) 
 - cipher _ mac = HMAC _ SHA256 ( mac _ key , cipher _ text ) 
 - ` ` ` 
 - 
 - # # Packing Result 
 - 
 - Encrypted Result is serialized to : 
 - 
 - ` ` ` 
 - PreMessage { 
 - identity : bytes = AI 
 - used _ ephermal _ id : int63 = B0 . id 
 - iv : bytes 
 - cipher _ text : bytes 
 - cipher _ mac : bytes 
 - } 
 - ` ` `

NEAREST DIFF:
diff - - git a / docs / e2e / axolotl - ratchet . md b / docs / e2e / axolotl - ratchet . md 
 index 90fd441 . . a2c0da5 100644 
 - - - a / docs / e2e / axolotl - ratchet . md 
 + + + b / docs / e2e / axolotl - ratchet . md 
 @ @ - 1 , 5 + 1 , 12 @ @ 
 # Axolotl Ratchet 
 
 + There are various sources for describing Axolotl Ratchet and there are different ways to implement this : 
 + * https : / / whispersystems . org / blog / advanced - ratcheting / 
 + * https : / / github . com / trevp / axolotl / wiki 
 + * https : / / github . com / WhisperSystems / Signal - Android / wiki / ProtocolV2 
 + 
 + We are trying to combine everything one one actual documentation and implement it in Actor . 
 + 
 # Public Keys 
 
 Each Key Group have Curve25519 public keys : 
 @ @ - 11 , 28 + 18 , 22 @ @ All this keys are uploaded to Actor Server befor starting communcation . 
 
 # Description 
 
 + Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . 
 + 
 + When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . 
 + 
 We start with case when Alice wants to send message to Bob for the first time . 
 
 Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs 
 
 Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs 
 
 - # # Building initial initial _ root _ key 
 - 
 - Alice compute initial _ root _ key : 
 - ` ` ` 
 - initial _ root _ key = SHA256 ( ECDH ( AI ' , BI ) + ECDH ( AI ' , BI ) ) 
 - ` ` ` 
 - Bob compute initial _ root _ key : 
 - ` ` ` 
 - initial _ root _ key = SHA256 ( ECDH ( A0 , BI ' ) + ECDH ( AI ' , BI ) ) 
 - ` ` ` 
 - 
 # # Computing parameters for first message 
 
 - Alice generates random ephermal key pair ( A1 , A1 ' ) and picks random Bob ' s ephermal key - B1 
 - 
 + Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : 
 ` ` ` 
 - master _ secret = SHA256 ( initial _ root _ key + ECDH ( A1 ' , B1 ) ) 
 + master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) 
 + master _ secret _ extendend = HKDF ( master _ secret , 64 ) 
 + root _ key = master _ secret _ extendend [ 0 . . 31 ] 
 + chain _ key = master _ secret _ extendend [ 32 . . 63 ] 
 ` ` ` 
 -
