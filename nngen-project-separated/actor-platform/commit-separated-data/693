BLEU SCORE: 0.0367352656298894

TEST MSG: refactor ( server : session ) : straight - forwardify internal resend api
GENERATED MSG: Merge branch ' server / seq - update - too - long '

TEST DIFF (one line): diff - - git a / actor - server / actor - session / src / main / resources / reference . conf b / actor - server / actor - session / src / main / resources / reference . conf < nl > index 1703d5e . . 3f8a726 100644 < nl > - - - a / actor - server / actor - session / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - session / src / main / resources / reference . conf < nl > @ @ - 1 , 11 + 1 , 15 @ @ < nl > session { < nl > - idle - timeout = 40 minutes < nl > - request - ack - delay = 15 seconds < nl > + idle - timeout : 40 minutes < nl > < nl > resend { < nl > - ack - timeout = 10 minutes < nl > - max - resend - size = 1 KiB < nl > - max - buffer - size = 1 MiB < nl > - max - push - buffer - size = 30KiB < nl > + ack - timeout : 10 minutes < nl > + max - resend - size : 1 KiB < nl > + max - buffer - size : 1 MiB < nl > + max - push - buffer - size : 30KiB < nl > + } < nl > + < nl > + rpc { < nl > + ack - delay : 15 seconds < nl > + max - cache - size : 10 < nl > } < nl > } < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > index 83c283f . . 806689e 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > @ @ - 56 , 33 + 56 , 27 @ @ private [ session ] object ReSender { < nl > private sealed trait ResendableItem { < nl > val bitsSize : Long < nl > val size = bitsSize / 8 < nl > + val priority : Priority < nl > } < nl > private final case class RpcItem ( result : ApiRpcResult , requestMessageId : Long ) extends ResendableItem { < nl > lazy val body = RpcResultCodec . encode ( result ) . require < nl > override lazy val bitsSize = body . size < nl > val reduceKeyOpt = None < nl > + override val priority = Priority . RPC < nl > } < nl > private final case class PushItem ( ub : UpdateBox , reduceKeyOpt : Option [ String ] ) extends ResendableItem { < nl > lazy val body = UpdateBoxCodec . encode ( ub ) . require < nl > override lazy val bitsSize = body . size < nl > + override val priority = ub match { < nl > + case _ : SeqUpdate | _ : FatSeqUpdate ⇒ Priority . SeqPush < nl > + case _ : WeakUpdate ⇒ Priority . WeakPush < nl > + } < nl > } < nl > private final case class NewSessionItem ( newSession : NewSession ) extends ResendableItem { < nl > override val bitsSize = 0L < nl > + override val priority = Priority . NewSession < nl > } < nl > < nl > - def props ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) = < nl > - Props ( classOf [ ReSender ] , authId , sessionId , firstMessageId , config ) < nl > - } < nl > - < nl > - private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) < nl > - extends ActorSubscriber with ActorPublisher [ MessageBox ] with ActorLogging with MessageIdHelper { < nl > - < nl > - import ActorPublisherMessage . _ < nl > - import ActorSubscriberMessage . _ < nl > - import ReSender . _ < nl > - import ReSenderMessage . _ < nl > - import context . dispatcher < nl > - < nl > sealed trait Priority { < nl > val id : Int < nl > } < nl > @ @ - 104 , 6 + 98 , 19 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > } < nl > } < nl > < nl > + def props ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) = < nl > + Props ( classOf [ ReSender ] , authId , sessionId , firstMessageId , config ) < nl > + } < nl > + < nl > + private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) < nl > + extends ActorSubscriber with ActorPublisher [ MessageBox ] with ActorLogging with MessageIdHelper { < nl > + < nl > + import ActorPublisherMessage . _ < nl > + import ActorSubscriberMessage . _ < nl > + import ReSender . _ < nl > + import ReSenderMessage . _ < nl > + import context . dispatcher < nl > + < nl > / / TODO : configurable < nl > private val AckTimeout = config . ackTimeout < nl > private val MaxBufferSize = config . maxBufferSize < nl > @ @ - 126 , 13 + 133 , 13 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > this . responseBuffer foreach { < nl > case ( messageId , ( pi , scheduled ) ) ⇒ < nl > scheduled . cancel ( ) < nl > - enqueueRpc ( pi , None ) < nl > + enqueueRpc ( pi , nextMessageId ( ) ) < nl > } < nl > < nl > this . pushBuffer foreach { < nl > case ( messageId , ( pi , scheduled ) ) ⇒ < nl > scheduled . cancel ( ) < nl > - enqueuePush ( pi , None ) < nl > + enqueuePush ( pi , nextMessageId ( ) ) < nl > } < nl > } < nl > < nl > @ @ - 147 , 6 + 154 , 12 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > / / Provides mapping from reduceKey to the last message with the reduceKey < nl > private [ this ] var pushReduceMap = immutable . Map . empty [ String , Long ] < nl > < nl > + / / Provides mapping from request messageId to a responseMessageId < nl > + / / to prevent response duplicates when client re - requests with same messageId < nl > + type RequestMessageId = Long < nl > + type ResponseMessageId = Long < nl > + private [ this ] var rpcMap = immutable . Map . empty [ ResponseMessageId , RequestMessageId ] < nl > + < nl > / / Used to prevent scheduling multiple updates at the same millisecond and result out of order < nl > private [ this ] var lastScheduledResend = System . currentTimeMillis - 1 < nl > < nl > @ @ - 196 , 16 + 209 , 17 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > < nl > item match { < nl > case pi : PushItem ⇒ < nl > - enqueuePush ( pi , None ) < nl > + enqueuePush ( pi , nextMessageId ( ) ) < nl > case ri : RpcItem ⇒ < nl > - enqueueRpc ( ri , None ) < nl > + enqueueRpc ( ri , nextMessageId ( ) ) < nl > case ni : NewSessionItem ⇒ < nl > enqueueNewSession ( ni ) < nl > } < nl > } < nl > - case OnNext ( RpcResult ( rsp , requestMessageId ) ) ⇒ enqueueRpc ( RpcItem ( rsp , requestMessageId ) , None ) < nl > - case OnNext ( p @ Push ( _ , reduceKey ) ) ⇒ enqueuePush ( PushItem ( p . ub , reduceKey ) , None ) < nl > - case OnNext ( SetUpdateOptimizations ( opts ) ) ⇒ this . updateOptimizations = opts < nl > + case OnNext ( RpcResult ( rsp , requestMessageId ) ) ⇒ < nl > + enqueueRpc ( RpcItem ( rsp , requestMessageId ) , nextMessageId ( ) ) < nl > + case OnNext ( p @ Push ( _ , reduceKey ) ) ⇒ enqueuePush ( PushItem ( p . ub , reduceKey ) , nextMessageId ( ) ) < nl > + case OnNext ( SetUpdateOptimizations ( opts ) ) ⇒ this . updateOptimizations = opts < nl > case OnComplete ⇒ < nl > log . debug ( " Stopping due to stream completion " ) < nl > / / TODO : cleanup scheduled resends < nl > @ @ - 222 , 8 + 236 , 16 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > < nl > item match { < nl > case ni : NewSessionItem ⇒ enqueueNewSession ( ni ) < nl > - case pi : PushItem ⇒ enqueuePush ( pi , Some ( messageId ) ) < nl > - case ri : RpcItem ⇒ enqueueRpc ( ri , Some ( messageId ) ) < nl > + case pi : PushItem ⇒ < nl > + if ( pi . size > MaxResendSize ) < nl > + enqueueUnsentPush ( pi , messageId ) < nl > + else < nl > + enqueuePush ( pi , messageId ) < nl > + case ri : RpcItem ⇒ < nl > + if ( ri . size > MaxResendSize ) < nl > + enqueueUnsentRpc ( ri , messageId ) < nl > + else < nl > + enqueueRpc ( ri , messageId ) < nl > } < nl > } else log . debug ( " ScheduledResend for messageId : { } , item : { } , ignoring ( absent in buffer ) " , messageId , item ) < nl > } < nl > @ @ - 367 , 37 + 389 , 28 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > private def enqueueSeqUpdateTooLong ( ) : Unit = < nl > enqueue ( MessageBox ( nextMessageId ( ) , ProtoPush ( UpdateBoxCodec . encode ( SeqUpdateTooLong ) . require ) ) , Priority . SeqPush ) < nl > < nl > - private def enqueueRpc ( item : RpcItem , unsentMessageIdOpt : Option [ Long ] , isNewClient : Boolean = false ) : Unit = { < nl > - val messageId = unsentMessageIdOpt . getOrElse ( nextMessageId ( ) ) < nl > + private def enqueueRpc ( item : RpcItem , messageId : Long ) : Unit = { < nl > scheduleResend ( item , messageId ) < nl > + val mb = MessageBox ( messageId , ProtoRpcResponse ( item . requestMessageId , item . body ) ) < nl > + enqueue ( mb , Priority . RPC ) < nl > + } < nl > < nl > - val mb = < nl > - unsentMessageIdOpt match { < nl > - case Some ( unsentMessageId ) if item . size > MaxResendSize ⇒ < nl > - MessageBox ( nextMessageId ( ) , UnsentResponse ( unsentMessageId , item . requestMessageId , item . size . toInt ) ) < nl > - case _ ⇒ < nl > - MessageBox ( messageId , ProtoRpcResponse ( item . requestMessageId , item . body ) ) < nl > - } < nl > - < nl > + private def enqueueUnsentRpc ( item : RpcItem , unsentMessageId : Long ) : Unit = { < nl > + scheduleResend ( item , unsentMessageId ) < nl > + val mb = MessageBox ( nextMessageId ( ) , UnsentResponse ( unsentMessageId , item . requestMessageId , item . size . toInt ) ) < nl > enqueue ( mb , Priority . RPC ) < nl > } < nl > < nl > - private def enqueuePush ( item : PushItem , unsentMessageIdOpt : Option [ Long ] ) : Unit = { < nl > - val messageId = nextMessageId ( ) < nl > + private def enqueuePush ( item : PushItem , messageId : Long ) : Unit = { < nl > scheduleResend ( item , messageId ) < nl > + val mb = MessageBox ( messageId , ProtoPush ( item . body ) ) < nl > + enqueue ( mb , item . priority ) < nl > + } < nl > < nl > - val msg = < nl > - unsentMessageIdOpt match { < nl > - case Some ( unsentMessageId ) if item . size > MaxResendSize ⇒ UnsentMessage ( unsentMessageId , item . size . toInt ) < nl > - case _ ⇒ ProtoPush ( item . body ) < nl > - } < nl > - < nl > - val priority = item . ub match { < nl > - case _ : SeqUpdate | _ : FatSeqUpdate ⇒ Priority . SeqPush < nl > - case _ : WeakUpdate ⇒ Priority . WeakPush < nl > - } < nl > - < nl > - enqueue ( MessageBox ( messageId , msg ) , priority ) < nl > + private def enqueueUnsentPush ( item : PushItem , unsentMessageId : Long ) : Unit = { < nl > + scheduleResend ( item , unsentMessageId ) < nl > + val mb = MessageBox ( nextMessageId ( ) , UnsentMessage ( unsentMessageId , item . size . toInt ) ) < nl > + enqueue ( mb , item . priority ) < nl > } < nl > < nl > private def enqueue ( mb : MessageBox , priority : Priority ) : Unit = { < nl > @ @ - 417 , 7 + 430 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > onError ( new RuntimeException ( msg ) with NoStackTrace ) < nl > } < nl > < nl > - private def pushBufferSize = responseBuffer . size + pushBuffer . size + newSessionBuffer . map ( _ = > 1 ) . getOrElse ( 0 ) < nl > + private def pushBufferSize = responseBuffer . size + pushBuffer . size + newSessionBuffer . map ( _ ⇒ 1 ) . getOrElse ( 0 ) < nl > < nl > override def postStop ( ) : Unit = { < nl > super . postStop ( ) < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala < nl > index 66439a4 . . f52dcc4 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala < nl > @ @ - 1 , 15 + 1 , 12 @ @ < nl > package im . actor . server . session < nl > < nl > - import java . util . concurrent . TimeUnit < nl > - < nl > import akka . actor . _ < nl > import akka . pattern . pipe < nl > import akka . stream . actor . _ < nl > - import im . actor . api . rpc . { RpcResult , RpcInternalError } < nl > + import im . actor . api . rpc . { RpcInternalError , RpcResult } < nl > import im . actor . server . api . rpc . RpcApiService . RpcResponse < nl > import im . actor . server . api . rpc . { RpcApiExtension , RpcApiService } < nl > import im . actor . util . cache . CacheHelpers . _ < nl > - import scodec . bits . _ < nl > < nl > import scala . annotation . tailrec < nl > import scala . collection . immutable < nl > @ @ - 23 , 7 + 20 , 7 @ @ private [ session ] object RpcHandler { < nl > private [ session ] val MaxCacheSize = 100L < nl > private [ session ] val RequestTimeOut = 30 seconds < nl > < nl > - def props = Props ( classOf [ RpcHandler ] ) < nl > + def props ( config : RpcConfig ) = Props ( classOf [ RpcHandler ] , config ) < nl > < nl > private case class CachedResponse ( rsp : RpcApiService . RpcResponse ) < nl > private case class Ack ( messageId : Long ) < nl > @ @ - 31 , 6 + 28 , 8 @ @ private [ session ] object RpcHandler { < nl > type AckOrResult = Either [ Long , RpcResult ] < nl > } < nl > < nl > + private [ session ] case class RpcConfig ( maxCacheSize : Long , ackDelay : FiniteDuration ) < nl > + < nl > private [ session ] object RequestHandler { < nl > private [ session ] def props ( promise : Promise [ RpcApiService . RpcResponse ] , service : ActorRef , request : RpcApiService . HandleRpcRequest ) = < nl > Props ( classOf [ RequestHandler ] , promise , service , request ) < nl > @ @ - 66 , 7 + 65 , 7 @ @ private [ session ] class RequestHandler ( < nl > } < nl > } < nl > < nl > - private [ session ] class RpcHandler extends ActorSubscriber with ActorPublisher [ ( Option [ RpcResult ] , Long ) ] with ActorLogging { < nl > + private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber with ActorPublisher [ ( Option [ RpcResult ] , Long ) ] with ActorLogging { < nl > < nl > import ActorPublisherMessage . _ < nl > import ActorSubscriberMessage . _ < nl > @ @ - 84 , 11 + 83 , 10 @ @ private [ session ] class RpcHandler extends ActorSubscriber with ActorPublisher [ ( O < nl > < nl > / / TODO : configurable < nl > private [ this ] val MaxRequestQueueSize = 10 < nl > - private [ this ] val AckDelay = context . system . settings . config . getDuration ( " session . request - ack - delay " , TimeUnit . MILLISECONDS ) . seconds < nl > private [ this ] var requestQueue = Map . empty [ Long , Cancellable ] < nl > < nl > private [ this ] var protoMessageQueue = immutable . Queue . empty [ ( Option [ RpcResult ] , Long ) ] < nl > - private [ this ] val responseCache = createCache [ java . lang . Long , Future [ RpcApiService . RpcResponse ] ] ( MaxCacheSize ) < nl > + private [ this ] val responseCache = createCache [ java . lang . Long , Future [ RpcApiService . RpcResponse ] ] ( config . maxCacheSize ) < nl > < nl > def subscriber : Receive = { < nl > case OnNext ( HandleRpcRequest ( messageId , requestBytes , clientData ) ) ⇒ < nl > @ @ - 97 , 7 + 95 , 7 @ @ private [ session ] class RpcHandler extends ActorSubscriber with ActorPublisher [ ( O < nl > log . debug ( " Publishing cached RpcResponse for messageId : { } " , messageId ) < nl > rspFuture map CachedResponse pipeTo self < nl > case None ⇒ < nl > - val scheduledAck = context . system . scheduler . scheduleOnce ( AckDelay , self , Ack ( messageId ) ) < nl > + val scheduledAck = context . system . scheduler . scheduleOnce ( config . ackDelay , self , Ack ( messageId ) ) < nl > requestQueue + = ( messageId → scheduledAck ) < nl > assert ( requestQueue . size < = MaxRequestQueueSize , s " queued too many : $ { requestQueue . size } " ) < nl > < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > index 44d993e . . 12a1292 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > @ @ - 7 , 11 + 7 , 11 @ @ import akka . cluster . pubsub . DistributedPubSubMediator . { SubscribeAck , Subscribe } < nl > import akka . cluster . sharding . ShardRegion . Passivate < nl > import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } < nl > import akka . pattern . pipe < nl > - import akka . stream . { OverflowStrategy , ClosedShape , Materializer } < nl > + import akka . stream . { ClosedShape , Materializer } < nl > import akka . stream . actor . _ < nl > import akka . stream . scaladsl . _ < nl > import com . typesafe . config . Config < nl > - import im . actor . api . rpc . sequence . ApiUpdateOptimization < nl > + import com . github . kxbmap . configs . syntax . _ < nl > import im . actor . api . rpc . { AuthData , ClientData } < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec < nl > @ @ - 29 , 13 + 29 , 14 @ @ import scala . concurrent . ExecutionContext < nl > import scala . concurrent . duration . _ < nl > import scala . util . { Success , Try } < nl > < nl > - final case class SessionConfig ( idleTimeout : Duration , reSendConfig : ReSenderConfig ) < nl > + final case class SessionConfig ( idleTimeout : Duration , reSendConfig : ReSenderConfig , rpcConfig : RpcConfig ) < nl > < nl > object SessionConfig { < nl > def load ( config : Config ) : SessionConfig = { < nl > SessionConfig ( < nl > idleTimeout = config . getDuration ( " idle - timeout " , TimeUnit . SECONDS ) . seconds , < nl > - reSendConfig = ReSenderConfig . fromConfig ( config . getConfig ( " resend " ) ) < nl > + reSendConfig = ReSenderConfig . fromConfig ( config . getConfig ( " resend " ) ) , < nl > + rpcConfig = config . get [ RpcConfig ] ( " rpc " ) < nl > ) < nl > } < nl > } < nl > @ @ - 120 , 7 + 121 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > private val updatesHandler = context . actorOf ( UpdatesHandler . props ( authId ) , " updatesHandler " ) < nl > < nl > val sessionMessagePublisher = context . actorOf ( SessionMessagePublisher . props ( ) , " messagePublisher " ) < nl > - val rpcHandler = context . actorOf ( RpcHandler . props , " rpcHandler " ) < nl > + val rpcHandler = context . actorOf ( RpcHandler . props ( config . rpcConfig ) , " rpcHandler " ) < nl > < nl > def receive = initializing
NEAREST DIFF (one line): diff - - git a / actor - server / actor - rpc - api / src / main / resources / reference . conf b / actor - server / actor - rpc - api / src / main / resources / reference . conf < nl > index c6ddc19 . . cba40cb 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - rpc - api / src / main / resources / reference . conf < nl > @ @ - 10 , 7 + 10 , 7 @ @ modules { < nl > } < nl > < nl > sequence { < nl > - max - difference - size : 20 KiB < nl > + max - difference - size : 60 KiB < nl > } < nl > < nl > search { < nl > diff - - git a / actor - server / actor - session / src / main / resources / reference . conf b / actor - server / actor - session / src / main / resources / reference . conf < nl > index cdd896f . . 1703d5e 100644 < nl > - - - a / actor - server / actor - session / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - session / src / main / resources / reference . conf < nl > @ @ - 6 , 5 + 6 , 6 @ @ session { < nl > ack - timeout = 10 minutes < nl > max - resend - size = 1 KiB < nl > max - buffer - size = 1 MiB < nl > + max - push - buffer - size = 30KiB < nl > } < nl > } < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > index a898213 . . 7f0485c 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > @ @ - 5 , 14 + 5 , 14 @ @ import java . util . concurrent . TimeUnit < nl > import akka . actor . { ActorLogging , ActorRef , Cancellable , Props } < nl > import akka . stream . actor . _ < nl > import com . typesafe . config . Config < nl > - import im . actor . api . rpc . { RpcResult ⇒ ApiRpcResult , UpdateBox } < nl > + import im . actor . api . rpc . { UpdateBox , RpcResult ⇒ ApiRpcResult } < nl > import im . actor . api . rpc . codecs . UpdateBoxCodec < nl > - import im . actor . api . rpc . sequence . { FatSeqUpdate , WeakUpdate , SeqUpdate , ApiUpdateOptimization } < nl > + import im . actor . api . rpc . sequence . _ < nl > import im . actor . server . api . rpc . RpcResultCodec < nl > import im . actor . server . mtproto . protocol . _ < nl > < nl > import scala . annotation . tailrec < nl > - import scala . collection . { mutable , immutable } < nl > + import scala . collection . { immutable , mutable } < nl > import scala . concurrent . duration . _ < nl > import scala . util . control . NoStackTrace < nl > < nl > @ @ - 36 , 14 + 36 , 15 @ @ private [ session ] object ReSenderMessage { < nl > final case class SetUpdateOptimizations ( updateOptimizations : Set [ ApiUpdateOptimization . Value ] ) extends ReSenderMessage < nl > } < nl > < nl > - private [ session ] case class ReSenderConfig ( ackTimeout : FiniteDuration , maxResendSize : Long , maxBufferSize : Long ) < nl > + private [ session ] case class ReSenderConfig ( ackTimeout : FiniteDuration , maxResendSize : Long , maxBufferSize : Long , maxPushBufferSize : Long ) < nl > < nl > private [ session ] object ReSenderConfig { < nl > def fromConfig ( config : Config ) : ReSenderConfig = { < nl > ReSenderConfig ( < nl > ackTimeout = config . getDuration ( " ack - timeout " , TimeUnit . SECONDS ) . seconds , < nl > maxResendSize = config . getBytes ( " max - resend - size " ) , < nl > - maxBufferSize = config . getBytes ( " max - buffer - size " ) < nl > + maxBufferSize = config . getBytes ( " max - buffer - size " ) , < nl > + maxPushBufferSize = config . getBytes ( " max - push - buffer - size " ) < nl > ) < nl > } < nl > } < nl > @ @ - 53 , 19 + 54 , 20 @ @ private [ session ] object ReSender { < nl > private case class ScheduledResend ( messageId : Long , item : ResendableItem ) < nl > < nl > private sealed trait ResendableItem { < nl > - val size : Long < nl > + val bitsSize : Long < nl > + val size = bitsSize / 8 < nl > } < nl > private final case class RpcItem ( result : ApiRpcResult , requestMessageId : Long ) extends ResendableItem { < nl > lazy val body = RpcResultCodec . encode ( result ) . require < nl > - override lazy val size = body . size < nl > + override lazy val bitsSize = body . size < nl > val reduceKeyOpt = None < nl > } < nl > private final case class PushItem ( ub : UpdateBox , reduceKeyOpt : Option [ String ] ) extends ResendableItem { < nl > lazy val body = UpdateBoxCodec . encode ( ub ) . require < nl > - override lazy val size = body . size < nl > + override lazy val bitsSize = body . size < nl > } < nl > private final case class NewSessionItem ( newSession : NewSession ) extends ResendableItem { < nl > - override val size = 0L < nl > + override val bitsSize = 0L < nl > } < nl > < nl > def props ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) = < nl > @ @ - 135 , 6 + 137 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > } < nl > < nl > private [ this ] var resendBufferSize = 0L < nl > + private [ this ] var resendPushBufferSize = 0L < nl > private [ this ] var updateOptimizations = Set . empty [ ApiUpdateOptimization . Value ] < nl > < nl > private [ this ] var newSessionBuffer : Option [ ( Long , NewSessionItem , Cancellable ) ] = None < nl > @ @ - 214 , 8 + 217 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > case ScheduledResend ( messageId , item ) ⇒ < nl > log . debug ( " Scheduled resend for messageId : { } , item : { } " , messageId , item ) < nl > < nl > - if ( item . size < = MaxResendSize ) < nl > - resendBufferSize - = item . size < nl > + decreaseBufferSize ( item ) < nl > < nl > item match { < nl > case ni : NewSessionItem ⇒ enqueueNewSession ( ni ) < nl > @ @ - 224 , 6 + 226 , 41 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > } < nl > } < nl > < nl > + private def increaseBufferSize ( item : ResendableItem ) : Unit = { < nl > + if ( item . size < = MaxResendSize ) { < nl > + this . resendBufferSize + = item . size < nl > + } < nl > + < nl > + item match { < nl > + case p : PushItem ⇒ < nl > + this . resendPushBufferSize + = item . size < nl > + < nl > + if ( this . resendPushBufferSize > config . maxPushBufferSize ) < nl > + clearPushBuffer ( ) < nl > + case _ ⇒ < nl > + } < nl > + } < nl > + < nl > + private def decreaseBufferSize ( item : ResendableItem ) : Unit = { < nl > + if ( item . size < = MaxResendSize ) this . resendBufferSize - = item . size < nl > + item match { < nl > + case _ : PushItem ⇒ this . resendPushBufferSize - = item . size < nl > + case _ ⇒ < nl > + } < nl > + } < nl > + < nl > + private def clearPushBuffer ( ) : Unit = { < nl > + pushBuffer foreach { < nl > + case ( messageId , ( pi : PushItem , resend ) ) ⇒ < nl > + pushBuffer - = messageId < nl > + decreaseBufferSize ( pi ) < nl > + resend . cancel ( ) < nl > + case _ ⇒ < nl > + } < nl > + < nl > + enqueueSeqUpdateTooLong ( ) < nl > + } < nl > + < nl > / / Publisher - related < nl > < nl > override val requestStrategy = WatermarkRequestStrategy ( 100 ) / / TODO : configurable < nl > @ @ - 282 , 8 + 319 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > private def scheduleResend ( item : ResendableItem , messageId : Long ) = { < nl > log . debug ( " Scheduling resend of messageId : { } , timeout : { } " , messageId , AckTimeout ) < nl > < nl > - if ( item . size < = MaxResendSize ) < nl > - this . resendBufferSize + = item . size < nl > + increaseBufferSize ( item ) < nl > < nl > / / FIXME : increase resendBufferSize by real Unsent < nl > < nl > @ @ - 299 , 8 + 335 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > ( ritem , resend ) ← pushBuffer . get ( msgId ) < nl > } yield { < nl > this . pushBuffer - = msgId < nl > - if ( ritem . size < = MaxResendSize ) < nl > - resendBufferSize - = ritem . size < nl > + decreaseBufferSize ( ritem ) < nl > resend . cancel ( ) < nl > } < nl > < nl > @ @ - 325 , 6 + 360 , 9 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > enqueue ( MessageBox ( messageId , item . newSession ) , Priority . NewSession ) < nl > } < nl > < nl > + private def enqueueSeqUpdateTooLong ( ) : Unit = < nl > + enqueue ( MessageBox ( nextMessageId ( ) , ProtoPush ( UpdateBoxCodec . encode ( SeqUpdateTooLong ) . require ) ) , Priority . SeqPush ) < nl > + < nl > private def enqueueRpc ( item : RpcItem , unsentMessageIdOpt : Option [ Long ] , isNewClient : Boolean = false ) : Unit = { < nl > val messageId = unsentMessageIdOpt . getOrElse ( nextMessageId ( ) ) < nl > scheduleResend ( item , messageId ) < nl > @ @ - 372 , 4 + 410 , 9 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > log . warning ( msg ) < nl > onError ( new RuntimeException ( msg ) with NoStackTrace ) < nl > } < nl > + < nl > + override def postStop ( ) : Unit = { < nl > + super . postStop ( ) < nl > + pushBuffer . values foreach ( _ . _ 2 . cancel ( ) ) < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > index 8de1697 . . f94b0b7 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > @ @ - 62 , 9 + 62 , 9 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { < nl > ( maxUpdateSize * ( 1 + 5 . toDouble / example . getSerializedSize ) ) . toInt < nl > } < nl > < nl > - / / serialized update size is : 40 bytes for body + 4 bytes for header , 44 bytes total < nl > - / / with max update size of 20 KiB 1281 updates should split into three parts < nl > - Await . result ( Future . sequence ( ( 0L to 1280L ) map { i ⇒ < nl > + / / serialized update size is : 40 bytes for body + 4 bytes for header , 44 bytes total < nl > + / / with max update size of 60 KiB 3840 updates should split into three parts < nl > + Await . result ( Future . sequence ( ( 0L to 3840 ) map { i ⇒ < nl > val update = UpdateMessageContentChanged ( user2Peer , i , message ) < nl > seqUpdExt . deliverSingleUpdate ( user . id , update ) < nl > } ) , 10 . seconds ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > index 9f9bb60 . . 7265349 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > @ @ - 8 , 7 + 8 , 7 @ @ import im . actor . api . rpc . contacts . { RequestGetContacts , UpdateContactRegistered } < nl > import im . actor . api . rpc . messaging . RequestLoadDialogs < nl > import im . actor . api . rpc . misc . ResponseVoid < nl > import im . actor . api . rpc . peers . ApiUserOutPeer < nl > - import im . actor . api . rpc . sequence . { RequestGetDifference , RequestSubscribeToOnline , RequestGetState } < nl > + import im . actor . api . rpc . sequence . { RequestGetDifference , RequestGetState , RequestSubscribeToOnline , UpdateRawUpdate } < nl > import im . actor . api . rpc . misc . ResponseSeq < nl > import im . actor . api . rpc . weak . UpdateUserOffline < nl > import im . actor . api . rpc . { AuthorizedClientData , Request , RpcOk } < nl > @ @ - 16 , 7 + 16 , 7 @ @ import im . actor . server . api . rpc . service . auth . AuthErrors < nl > import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . mtproto . transport . _ < nl > import im . actor . server . persist . AuthSessionRepo < nl > - import im . actor . server . sequence . { SeqUpdatesExtension , WeakUpdatesExtension } < nl > + import im . actor . server . sequence . { SeqUpdatesExtension , UserSequence , WeakUpdatesExtension } < nl > import im . actor . server . user . UserExtension < nl > import scodec . bits . _ < nl > < nl > @ @ - 36 , 6 + 36 , 7 @ @ final class SessionSpec extends BaseSessionSpec { < nl > it should " subscribe to presences " in sessions ( ) . pres < nl > it should " receive fat updates " in sessions ( ) . fatSeq < nl > it should " react to SessionHello " in sessions ( ) . hello < nl > + it should " send SeqUpdateTooLong " in sessions ( ) . seqUpdateTooLong < nl > < nl > case class sessions ( ) { < nl > < nl > @ @ - 163 , 6 + 164 , 37 @ @ final class SessionSpec extends BaseSessionSpec { < nl > } < nl > } < nl > < nl > + def seqUpdateTooLong ( ) = { < nl > + val ( user , authId , _ , _ ) = createUser ( ) < nl > + val sessionId = Random . nextLong ( ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , SessionHello ) < nl > + ignoreNewSession ( ) < nl > + < nl > + sendRequest ( authId , sessionId , sessionRegion . ref , RequestGetState ( Vector . empty ) ) < nl > + expectMessageAck ( ) < nl > + expectRpcResult ( authId , sessionId ) < nl > + < nl > + val updatesCount = 31 < nl > + < nl > + / / each update is 1024 bytes < nl > + val payload = Array ( List . range ( 0 , 1005 ) . map ( _ . toByte ) : _ * ) < nl > + val update = UpdateRawUpdate ( None , payload ) < nl > + < nl > + for ( _ ← 1 to updatesCount ) { < nl > + whenReady ( seqUpdExt . deliverSingleUpdate ( user . id , update ) ) ( identity ) < nl > + } < nl > + < nl > + / / expect 30Kb of updates to be pushed , then SeqUpdateTooLong ( no ack ) < nl > + for ( _ ← 1 until updatesCount ) { < nl > + expectSeqUpdate ( authId , sessionId , None ) < nl > + } < nl > + < nl > + expectSeqUpdateTooLong ( authId , sessionId ) < nl > + expectSeqUpdate ( authId , sessionId ) < nl > + < nl > + probe . expectNoMsg ( 5 . seconds ) < nl > + } < nl > + < nl > def seq ( ) = { < nl > val authId = createAuthId ( ) < nl > val sessionId = Random . nextLong ( ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > index 0a7b511 . . a2c36b3 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > @ @ - 1 , 11 + 1 , 11 @ @ < nl > package im . actor . server . session < nl > < nl > - import akka . actor . { ActorSystem , ActorRef } < nl > + import akka . actor . { ActorRef , ActorSystem } < nl > import akka . testkit . TestProbe < nl > import com . google . protobuf . ByteString < nl > import im . actor . api . rpc . { Request , RpcRequest , RpcResult } < nl > import im . actor . api . rpc . codecs . _ < nl > - import im . actor . api . rpc . sequence . { WeakUpdate , FatSeqUpdate , SeqUpdate } < nl > + import im . actor . api . rpc . sequence . { FatSeqUpdate , SeqUpdate , SeqUpdateTooLong , WeakUpdate } < nl > import im . actor . server . api . rpc . RpcResultCodec < nl > import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec < nl > import im . actor . server . mtproto . protocol . _ < nl > @ @ - 33 , 6 + 33 , 9 @ @ trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { < nl > protected def expectWeakUpdate ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : WeakUpdate = < nl > expectUpdateBox ( classOf [ WeakUpdate ] , authId , sessionId , None ) < nl > < nl > + protected def expectSeqUpdateTooLong ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : SeqUpdateTooLong = < nl > + expectUpdateBox ( classOf [ SeqUpdateTooLong ] , authId , sessionId , sendAckAt ) < nl > + < nl > protected def expectUpdateBox [ T < : im . actor . api . rpc . UpdateBox ] ( clazz : Class [ T ] , authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] ) ( implicit probe : TestProbe , m : Manifest [ T ] ) : T = { < nl > val mb = expectMessageBox ( )

TEST DIFF:
diff - - git a / actor - server / actor - session / src / main / resources / reference . conf b / actor - server / actor - session / src / main / resources / reference . conf 
 index 1703d5e . . 3f8a726 100644 
 - - - a / actor - server / actor - session / src / main / resources / reference . conf 
 + + + b / actor - server / actor - session / src / main / resources / reference . conf 
 @ @ - 1 , 11 + 1 , 15 @ @ 
 session { 
 - idle - timeout = 40 minutes 
 - request - ack - delay = 15 seconds 
 + idle - timeout : 40 minutes 
 
 resend { 
 - ack - timeout = 10 minutes 
 - max - resend - size = 1 KiB 
 - max - buffer - size = 1 MiB 
 - max - push - buffer - size = 30KiB 
 + ack - timeout : 10 minutes 
 + max - resend - size : 1 KiB 
 + max - buffer - size : 1 MiB 
 + max - push - buffer - size : 30KiB 
 + } 
 + 
 + rpc { 
 + ack - delay : 15 seconds 
 + max - cache - size : 10 
 } 
 } 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 index 83c283f . . 806689e 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 @ @ - 56 , 33 + 56 , 27 @ @ private [ session ] object ReSender { 
 private sealed trait ResendableItem { 
 val bitsSize : Long 
 val size = bitsSize / 8 
 + val priority : Priority 
 } 
 private final case class RpcItem ( result : ApiRpcResult , requestMessageId : Long ) extends ResendableItem { 
 lazy val body = RpcResultCodec . encode ( result ) . require 
 override lazy val bitsSize = body . size 
 val reduceKeyOpt = None 
 + override val priority = Priority . RPC 
 } 
 private final case class PushItem ( ub : UpdateBox , reduceKeyOpt : Option [ String ] ) extends ResendableItem { 
 lazy val body = UpdateBoxCodec . encode ( ub ) . require 
 override lazy val bitsSize = body . size 
 + override val priority = ub match { 
 + case _ : SeqUpdate | _ : FatSeqUpdate ⇒ Priority . SeqPush 
 + case _ : WeakUpdate ⇒ Priority . WeakPush 
 + } 
 } 
 private final case class NewSessionItem ( newSession : NewSession ) extends ResendableItem { 
 override val bitsSize = 0L 
 + override val priority = Priority . NewSession 
 } 
 
 - def props ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) = 
 - Props ( classOf [ ReSender ] , authId , sessionId , firstMessageId , config ) 
 - } 
 - 
 - private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) 
 - extends ActorSubscriber with ActorPublisher [ MessageBox ] with ActorLogging with MessageIdHelper { 
 - 
 - import ActorPublisherMessage . _ 
 - import ActorSubscriberMessage . _ 
 - import ReSender . _ 
 - import ReSenderMessage . _ 
 - import context . dispatcher 
 - 
 sealed trait Priority { 
 val id : Int 
 } 
 @ @ - 104 , 6 + 98 , 19 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 } 
 } 
 
 + def props ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) = 
 + Props ( classOf [ ReSender ] , authId , sessionId , firstMessageId , config ) 
 + } 
 + 
 + private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) 
 + extends ActorSubscriber with ActorPublisher [ MessageBox ] with ActorLogging with MessageIdHelper { 
 + 
 + import ActorPublisherMessage . _ 
 + import ActorSubscriberMessage . _ 
 + import ReSender . _ 
 + import ReSenderMessage . _ 
 + import context . dispatcher 
 + 
 / / TODO : configurable 
 private val AckTimeout = config . ackTimeout 
 private val MaxBufferSize = config . maxBufferSize 
 @ @ - 126 , 13 + 133 , 13 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 this . responseBuffer foreach { 
 case ( messageId , ( pi , scheduled ) ) ⇒ 
 scheduled . cancel ( ) 
 - enqueueRpc ( pi , None ) 
 + enqueueRpc ( pi , nextMessageId ( ) ) 
 } 
 
 this . pushBuffer foreach { 
 case ( messageId , ( pi , scheduled ) ) ⇒ 
 scheduled . cancel ( ) 
 - enqueuePush ( pi , None ) 
 + enqueuePush ( pi , nextMessageId ( ) ) 
 } 
 } 
 
 @ @ - 147 , 6 + 154 , 12 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 / / Provides mapping from reduceKey to the last message with the reduceKey 
 private [ this ] var pushReduceMap = immutable . Map . empty [ String , Long ] 
 
 + / / Provides mapping from request messageId to a responseMessageId 
 + / / to prevent response duplicates when client re - requests with same messageId 
 + type RequestMessageId = Long 
 + type ResponseMessageId = Long 
 + private [ this ] var rpcMap = immutable . Map . empty [ ResponseMessageId , RequestMessageId ] 
 + 
 / / Used to prevent scheduling multiple updates at the same millisecond and result out of order 
 private [ this ] var lastScheduledResend = System . currentTimeMillis - 1 
 
 @ @ - 196 , 16 + 209 , 17 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 
 item match { 
 case pi : PushItem ⇒ 
 - enqueuePush ( pi , None ) 
 + enqueuePush ( pi , nextMessageId ( ) ) 
 case ri : RpcItem ⇒ 
 - enqueueRpc ( ri , None ) 
 + enqueueRpc ( ri , nextMessageId ( ) ) 
 case ni : NewSessionItem ⇒ 
 enqueueNewSession ( ni ) 
 } 
 } 
 - case OnNext ( RpcResult ( rsp , requestMessageId ) ) ⇒ enqueueRpc ( RpcItem ( rsp , requestMessageId ) , None ) 
 - case OnNext ( p @ Push ( _ , reduceKey ) ) ⇒ enqueuePush ( PushItem ( p . ub , reduceKey ) , None ) 
 - case OnNext ( SetUpdateOptimizations ( opts ) ) ⇒ this . updateOptimizations = opts 
 + case OnNext ( RpcResult ( rsp , requestMessageId ) ) ⇒ 
 + enqueueRpc ( RpcItem ( rsp , requestMessageId ) , nextMessageId ( ) ) 
 + case OnNext ( p @ Push ( _ , reduceKey ) ) ⇒ enqueuePush ( PushItem ( p . ub , reduceKey ) , nextMessageId ( ) ) 
 + case OnNext ( SetUpdateOptimizations ( opts ) ) ⇒ this . updateOptimizations = opts 
 case OnComplete ⇒ 
 log . debug ( " Stopping due to stream completion " ) 
 / / TODO : cleanup scheduled resends 
 @ @ - 222 , 8 + 236 , 16 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 
 item match { 
 case ni : NewSessionItem ⇒ enqueueNewSession ( ni ) 
 - case pi : PushItem ⇒ enqueuePush ( pi , Some ( messageId ) ) 
 - case ri : RpcItem ⇒ enqueueRpc ( ri , Some ( messageId ) ) 
 + case pi : PushItem ⇒ 
 + if ( pi . size > MaxResendSize ) 
 + enqueueUnsentPush ( pi , messageId ) 
 + else 
 + enqueuePush ( pi , messageId ) 
 + case ri : RpcItem ⇒ 
 + if ( ri . size > MaxResendSize ) 
 + enqueueUnsentRpc ( ri , messageId ) 
 + else 
 + enqueueRpc ( ri , messageId ) 
 } 
 } else log . debug ( " ScheduledResend for messageId : { } , item : { } , ignoring ( absent in buffer ) " , messageId , item ) 
 } 
 @ @ - 367 , 37 + 389 , 28 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 private def enqueueSeqUpdateTooLong ( ) : Unit = 
 enqueue ( MessageBox ( nextMessageId ( ) , ProtoPush ( UpdateBoxCodec . encode ( SeqUpdateTooLong ) . require ) ) , Priority . SeqPush ) 
 
 - private def enqueueRpc ( item : RpcItem , unsentMessageIdOpt : Option [ Long ] , isNewClient : Boolean = false ) : Unit = { 
 - val messageId = unsentMessageIdOpt . getOrElse ( nextMessageId ( ) ) 
 + private def enqueueRpc ( item : RpcItem , messageId : Long ) : Unit = { 
 scheduleResend ( item , messageId ) 
 + val mb = MessageBox ( messageId , ProtoRpcResponse ( item . requestMessageId , item . body ) ) 
 + enqueue ( mb , Priority . RPC ) 
 + } 
 
 - val mb = 
 - unsentMessageIdOpt match { 
 - case Some ( unsentMessageId ) if item . size > MaxResendSize ⇒ 
 - MessageBox ( nextMessageId ( ) , UnsentResponse ( unsentMessageId , item . requestMessageId , item . size . toInt ) ) 
 - case _ ⇒ 
 - MessageBox ( messageId , ProtoRpcResponse ( item . requestMessageId , item . body ) ) 
 - } 
 - 
 + private def enqueueUnsentRpc ( item : RpcItem , unsentMessageId : Long ) : Unit = { 
 + scheduleResend ( item , unsentMessageId ) 
 + val mb = MessageBox ( nextMessageId ( ) , UnsentResponse ( unsentMessageId , item . requestMessageId , item . size . toInt ) ) 
 enqueue ( mb , Priority . RPC ) 
 } 
 
 - private def enqueuePush ( item : PushItem , unsentMessageIdOpt : Option [ Long ] ) : Unit = { 
 - val messageId = nextMessageId ( ) 
 + private def enqueuePush ( item : PushItem , messageId : Long ) : Unit = { 
 scheduleResend ( item , messageId ) 
 + val mb = MessageBox ( messageId , ProtoPush ( item . body ) ) 
 + enqueue ( mb , item . priority ) 
 + } 
 
 - val msg = 
 - unsentMessageIdOpt match { 
 - case Some ( unsentMessageId ) if item . size > MaxResendSize ⇒ UnsentMessage ( unsentMessageId , item . size . toInt ) 
 - case _ ⇒ ProtoPush ( item . body ) 
 - } 
 - 
 - val priority = item . ub match { 
 - case _ : SeqUpdate | _ : FatSeqUpdate ⇒ Priority . SeqPush 
 - case _ : WeakUpdate ⇒ Priority . WeakPush 
 - } 
 - 
 - enqueue ( MessageBox ( messageId , msg ) , priority ) 
 + private def enqueueUnsentPush ( item : PushItem , unsentMessageId : Long ) : Unit = { 
 + scheduleResend ( item , unsentMessageId ) 
 + val mb = MessageBox ( nextMessageId ( ) , UnsentMessage ( unsentMessageId , item . size . toInt ) ) 
 + enqueue ( mb , item . priority ) 
 } 
 
 private def enqueue ( mb : MessageBox , priority : Priority ) : Unit = { 
 @ @ - 417 , 7 + 430 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 onError ( new RuntimeException ( msg ) with NoStackTrace ) 
 } 
 
 - private def pushBufferSize = responseBuffer . size + pushBuffer . size + newSessionBuffer . map ( _ = > 1 ) . getOrElse ( 0 ) 
 + private def pushBufferSize = responseBuffer . size + pushBuffer . size + newSessionBuffer . map ( _ ⇒ 1 ) . getOrElse ( 0 ) 
 
 override def postStop ( ) : Unit = { 
 super . postStop ( ) 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala 
 index 66439a4 . . f52dcc4 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala 
 @ @ - 1 , 15 + 1 , 12 @ @ 
 package im . actor . server . session 
 
 - import java . util . concurrent . TimeUnit 
 - 
 import akka . actor . _ 
 import akka . pattern . pipe 
 import akka . stream . actor . _ 
 - import im . actor . api . rpc . { RpcResult , RpcInternalError } 
 + import im . actor . api . rpc . { RpcInternalError , RpcResult } 
 import im . actor . server . api . rpc . RpcApiService . RpcResponse 
 import im . actor . server . api . rpc . { RpcApiExtension , RpcApiService } 
 import im . actor . util . cache . CacheHelpers . _ 
 - import scodec . bits . _ 
 
 import scala . annotation . tailrec 
 import scala . collection . immutable 
 @ @ - 23 , 7 + 20 , 7 @ @ private [ session ] object RpcHandler { 
 private [ session ] val MaxCacheSize = 100L 
 private [ session ] val RequestTimeOut = 30 seconds 
 
 - def props = Props ( classOf [ RpcHandler ] ) 
 + def props ( config : RpcConfig ) = Props ( classOf [ RpcHandler ] , config ) 
 
 private case class CachedResponse ( rsp : RpcApiService . RpcResponse ) 
 private case class Ack ( messageId : Long ) 
 @ @ - 31 , 6 + 28 , 8 @ @ private [ session ] object RpcHandler { 
 type AckOrResult = Either [ Long , RpcResult ] 
 } 
 
 + private [ session ] case class RpcConfig ( maxCacheSize : Long , ackDelay : FiniteDuration ) 
 + 
 private [ session ] object RequestHandler { 
 private [ session ] def props ( promise : Promise [ RpcApiService . RpcResponse ] , service : ActorRef , request : RpcApiService . HandleRpcRequest ) = 
 Props ( classOf [ RequestHandler ] , promise , service , request ) 
 @ @ - 66 , 7 + 65 , 7 @ @ private [ session ] class RequestHandler ( 
 } 
 } 
 
 - private [ session ] class RpcHandler extends ActorSubscriber with ActorPublisher [ ( Option [ RpcResult ] , Long ) ] with ActorLogging { 
 + private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber with ActorPublisher [ ( Option [ RpcResult ] , Long ) ] with ActorLogging { 
 
 import ActorPublisherMessage . _ 
 import ActorSubscriberMessage . _ 
 @ @ - 84 , 11 + 83 , 10 @ @ private [ session ] class RpcHandler extends ActorSubscriber with ActorPublisher [ ( O 
 
 / / TODO : configurable 
 private [ this ] val MaxRequestQueueSize = 10 
 - private [ this ] val AckDelay = context . system . settings . config . getDuration ( " session . request - ack - delay " , TimeUnit . MILLISECONDS ) . seconds 
 private [ this ] var requestQueue = Map . empty [ Long , Cancellable ] 
 
 private [ this ] var protoMessageQueue = immutable . Queue . empty [ ( Option [ RpcResult ] , Long ) ] 
 - private [ this ] val responseCache = createCache [ java . lang . Long , Future [ RpcApiService . RpcResponse ] ] ( MaxCacheSize ) 
 + private [ this ] val responseCache = createCache [ java . lang . Long , Future [ RpcApiService . RpcResponse ] ] ( config . maxCacheSize ) 
 
 def subscriber : Receive = { 
 case OnNext ( HandleRpcRequest ( messageId , requestBytes , clientData ) ) ⇒ 
 @ @ - 97 , 7 + 95 , 7 @ @ private [ session ] class RpcHandler extends ActorSubscriber with ActorPublisher [ ( O 
 log . debug ( " Publishing cached RpcResponse for messageId : { } " , messageId ) 
 rspFuture map CachedResponse pipeTo self 
 case None ⇒ 
 - val scheduledAck = context . system . scheduler . scheduleOnce ( AckDelay , self , Ack ( messageId ) ) 
 + val scheduledAck = context . system . scheduler . scheduleOnce ( config . ackDelay , self , Ack ( messageId ) ) 
 requestQueue + = ( messageId → scheduledAck ) 
 assert ( requestQueue . size < = MaxRequestQueueSize , s " queued too many : $ { requestQueue . size } " ) 
 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 index 44d993e . . 12a1292 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 @ @ - 7 , 11 + 7 , 11 @ @ import akka . cluster . pubsub . DistributedPubSubMediator . { SubscribeAck , Subscribe } 
 import akka . cluster . sharding . ShardRegion . Passivate 
 import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } 
 import akka . pattern . pipe 
 - import akka . stream . { OverflowStrategy , ClosedShape , Materializer } 
 + import akka . stream . { ClosedShape , Materializer } 
 import akka . stream . actor . _ 
 import akka . stream . scaladsl . _ 
 import com . typesafe . config . Config 
 - import im . actor . api . rpc . sequence . ApiUpdateOptimization 
 + import com . github . kxbmap . configs . syntax . _ 
 import im . actor . api . rpc . { AuthData , ClientData } 
 import im . actor . server . db . DbExtension 
 import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec 
 @ @ - 29 , 13 + 29 , 14 @ @ import scala . concurrent . ExecutionContext 
 import scala . concurrent . duration . _ 
 import scala . util . { Success , Try } 
 
 - final case class SessionConfig ( idleTimeout : Duration , reSendConfig : ReSenderConfig ) 
 + final case class SessionConfig ( idleTimeout : Duration , reSendConfig : ReSenderConfig , rpcConfig : RpcConfig ) 
 
 object SessionConfig { 
 def load ( config : Config ) : SessionConfig = { 
 SessionConfig ( 
 idleTimeout = config . getDuration ( " idle - timeout " , TimeUnit . SECONDS ) . seconds , 
 - reSendConfig = ReSenderConfig . fromConfig ( config . getConfig ( " resend " ) ) 
 + reSendConfig = ReSenderConfig . fromConfig ( config . getConfig ( " resend " ) ) , 
 + rpcConfig = config . get [ RpcConfig ] ( " rpc " ) 
 ) 
 } 
 } 
 @ @ - 120 , 7 + 121 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 private val updatesHandler = context . actorOf ( UpdatesHandler . props ( authId ) , " updatesHandler " ) 
 
 val sessionMessagePublisher = context . actorOf ( SessionMessagePublisher . props ( ) , " messagePublisher " ) 
 - val rpcHandler = context . actorOf ( RpcHandler . props , " rpcHandler " ) 
 + val rpcHandler = context . actorOf ( RpcHandler . props ( config . rpcConfig ) , " rpcHandler " ) 
 
 def receive = initializing

NEAREST DIFF:
diff - - git a / actor - server / actor - rpc - api / src / main / resources / reference . conf b / actor - server / actor - rpc - api / src / main / resources / reference . conf 
 index c6ddc19 . . cba40cb 100644 
 - - - a / actor - server / actor - rpc - api / src / main / resources / reference . conf 
 + + + b / actor - server / actor - rpc - api / src / main / resources / reference . conf 
 @ @ - 10 , 7 + 10 , 7 @ @ modules { 
 } 
 
 sequence { 
 - max - difference - size : 20 KiB 
 + max - difference - size : 60 KiB 
 } 
 
 search { 
 diff - - git a / actor - server / actor - session / src / main / resources / reference . conf b / actor - server / actor - session / src / main / resources / reference . conf 
 index cdd896f . . 1703d5e 100644 
 - - - a / actor - server / actor - session / src / main / resources / reference . conf 
 + + + b / actor - server / actor - session / src / main / resources / reference . conf 
 @ @ - 6 , 5 + 6 , 6 @ @ session { 
 ack - timeout = 10 minutes 
 max - resend - size = 1 KiB 
 max - buffer - size = 1 MiB 
 + max - push - buffer - size = 30KiB 
 } 
 } 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 index a898213 . . 7f0485c 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 @ @ - 5 , 14 + 5 , 14 @ @ import java . util . concurrent . TimeUnit 
 import akka . actor . { ActorLogging , ActorRef , Cancellable , Props } 
 import akka . stream . actor . _ 
 import com . typesafe . config . Config 
 - import im . actor . api . rpc . { RpcResult ⇒ ApiRpcResult , UpdateBox } 
 + import im . actor . api . rpc . { UpdateBox , RpcResult ⇒ ApiRpcResult } 
 import im . actor . api . rpc . codecs . UpdateBoxCodec 
 - import im . actor . api . rpc . sequence . { FatSeqUpdate , WeakUpdate , SeqUpdate , ApiUpdateOptimization } 
 + import im . actor . api . rpc . sequence . _ 
 import im . actor . server . api . rpc . RpcResultCodec 
 import im . actor . server . mtproto . protocol . _ 
 
 import scala . annotation . tailrec 
 - import scala . collection . { mutable , immutable } 
 + import scala . collection . { immutable , mutable } 
 import scala . concurrent . duration . _ 
 import scala . util . control . NoStackTrace 
 
 @ @ - 36 , 14 + 36 , 15 @ @ private [ session ] object ReSenderMessage { 
 final case class SetUpdateOptimizations ( updateOptimizations : Set [ ApiUpdateOptimization . Value ] ) extends ReSenderMessage 
 } 
 
 - private [ session ] case class ReSenderConfig ( ackTimeout : FiniteDuration , maxResendSize : Long , maxBufferSize : Long ) 
 + private [ session ] case class ReSenderConfig ( ackTimeout : FiniteDuration , maxResendSize : Long , maxBufferSize : Long , maxPushBufferSize : Long ) 
 
 private [ session ] object ReSenderConfig { 
 def fromConfig ( config : Config ) : ReSenderConfig = { 
 ReSenderConfig ( 
 ackTimeout = config . getDuration ( " ack - timeout " , TimeUnit . SECONDS ) . seconds , 
 maxResendSize = config . getBytes ( " max - resend - size " ) , 
 - maxBufferSize = config . getBytes ( " max - buffer - size " ) 
 + maxBufferSize = config . getBytes ( " max - buffer - size " ) , 
 + maxPushBufferSize = config . getBytes ( " max - push - buffer - size " ) 
 ) 
 } 
 } 
 @ @ - 53 , 19 + 54 , 20 @ @ private [ session ] object ReSender { 
 private case class ScheduledResend ( messageId : Long , item : ResendableItem ) 
 
 private sealed trait ResendableItem { 
 - val size : Long 
 + val bitsSize : Long 
 + val size = bitsSize / 8 
 } 
 private final case class RpcItem ( result : ApiRpcResult , requestMessageId : Long ) extends ResendableItem { 
 lazy val body = RpcResultCodec . encode ( result ) . require 
 - override lazy val size = body . size 
 + override lazy val bitsSize = body . size 
 val reduceKeyOpt = None 
 } 
 private final case class PushItem ( ub : UpdateBox , reduceKeyOpt : Option [ String ] ) extends ResendableItem { 
 lazy val body = UpdateBoxCodec . encode ( ub ) . require 
 - override lazy val size = body . size 
 + override lazy val bitsSize = body . size 
 } 
 private final case class NewSessionItem ( newSession : NewSession ) extends ResendableItem { 
 - override val size = 0L 
 + override val bitsSize = 0L 
 } 
 
 def props ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) = 
 @ @ - 135 , 6 + 137 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 } 
 
 private [ this ] var resendBufferSize = 0L 
 + private [ this ] var resendPushBufferSize = 0L 
 private [ this ] var updateOptimizations = Set . empty [ ApiUpdateOptimization . Value ] 
 
 private [ this ] var newSessionBuffer : Option [ ( Long , NewSessionItem , Cancellable ) ] = None 
 @ @ - 214 , 8 + 217 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 case ScheduledResend ( messageId , item ) ⇒ 
 log . debug ( " Scheduled resend for messageId : { } , item : { } " , messageId , item ) 
 
 - if ( item . size < = MaxResendSize ) 
 - resendBufferSize - = item . size 
 + decreaseBufferSize ( item ) 
 
 item match { 
 case ni : NewSessionItem ⇒ enqueueNewSession ( ni ) 
 @ @ - 224 , 6 + 226 , 41 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 } 
 } 
 
 + private def increaseBufferSize ( item : ResendableItem ) : Unit = { 
 + if ( item . size < = MaxResendSize ) { 
 + this . resendBufferSize + = item . size 
 + } 
 + 
 + item match { 
 + case p : PushItem ⇒ 
 + this . resendPushBufferSize + = item . size 
 + 
 + if ( this . resendPushBufferSize > config . maxPushBufferSize ) 
 + clearPushBuffer ( ) 
 + case _ ⇒ 
 + } 
 + } 
 + 
 + private def decreaseBufferSize ( item : ResendableItem ) : Unit = { 
 + if ( item . size < = MaxResendSize ) this . resendBufferSize - = item . size 
 + item match { 
 + case _ : PushItem ⇒ this . resendPushBufferSize - = item . size 
 + case _ ⇒ 
 + } 
 + } 
 + 
 + private def clearPushBuffer ( ) : Unit = { 
 + pushBuffer foreach { 
 + case ( messageId , ( pi : PushItem , resend ) ) ⇒ 
 + pushBuffer - = messageId 
 + decreaseBufferSize ( pi ) 
 + resend . cancel ( ) 
 + case _ ⇒ 
 + } 
 + 
 + enqueueSeqUpdateTooLong ( ) 
 + } 
 + 
 / / Publisher - related 
 
 override val requestStrategy = WatermarkRequestStrategy ( 100 ) / / TODO : configurable 
 @ @ - 282 , 8 + 319 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 private def scheduleResend ( item : ResendableItem , messageId : Long ) = { 
 log . debug ( " Scheduling resend of messageId : { } , timeout : { } " , messageId , AckTimeout ) 
 
 - if ( item . size < = MaxResendSize ) 
 - this . resendBufferSize + = item . size 
 + increaseBufferSize ( item ) 
 
 / / FIXME : increase resendBufferSize by real Unsent 
 
 @ @ - 299 , 8 + 335 , 7 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 ( ritem , resend ) ← pushBuffer . get ( msgId ) 
 } yield { 
 this . pushBuffer - = msgId 
 - if ( ritem . size < = MaxResendSize ) 
 - resendBufferSize - = ritem . size 
 + decreaseBufferSize ( ritem ) 
 resend . cancel ( ) 
 } 
 
 @ @ - 325 , 6 + 360 , 9 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 enqueue ( MessageBox ( messageId , item . newSession ) , Priority . NewSession ) 
 } 
 
 + private def enqueueSeqUpdateTooLong ( ) : Unit = 
 + enqueue ( MessageBox ( nextMessageId ( ) , ProtoPush ( UpdateBoxCodec . encode ( SeqUpdateTooLong ) . require ) ) , Priority . SeqPush ) 
 + 
 private def enqueueRpc ( item : RpcItem , unsentMessageIdOpt : Option [ Long ] , isNewClient : Boolean = false ) : Unit = { 
 val messageId = unsentMessageIdOpt . getOrElse ( nextMessageId ( ) ) 
 scheduleResend ( item , messageId ) 
 @ @ - 372 , 4 + 410 , 9 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 log . warning ( msg ) 
 onError ( new RuntimeException ( msg ) with NoStackTrace ) 
 } 
 + 
 + override def postStop ( ) : Unit = { 
 + super . postStop ( ) 
 + pushBuffer . values foreach ( _ . _ 2 . cancel ( ) ) 
 + } 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 index 8de1697 . . f94b0b7 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 @ @ - 62 , 9 + 62 , 9 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { 
 ( maxUpdateSize * ( 1 + 5 . toDouble / example . getSerializedSize ) ) . toInt 
 } 
 
 - / / serialized update size is : 40 bytes for body + 4 bytes for header , 44 bytes total 
 - / / with max update size of 20 KiB 1281 updates should split into three parts 
 - Await . result ( Future . sequence ( ( 0L to 1280L ) map { i ⇒ 
 + / / serialized update size is : 40 bytes for body + 4 bytes for header , 44 bytes total 
 + / / with max update size of 60 KiB 3840 updates should split into three parts 
 + Await . result ( Future . sequence ( ( 0L to 3840 ) map { i ⇒ 
 val update = UpdateMessageContentChanged ( user2Peer , i , message ) 
 seqUpdExt . deliverSingleUpdate ( user . id , update ) 
 } ) , 10 . seconds ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 index 9f9bb60 . . 7265349 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 @ @ - 8 , 7 + 8 , 7 @ @ import im . actor . api . rpc . contacts . { RequestGetContacts , UpdateContactRegistered } 
 import im . actor . api . rpc . messaging . RequestLoadDialogs 
 import im . actor . api . rpc . misc . ResponseVoid 
 import im . actor . api . rpc . peers . ApiUserOutPeer 
 - import im . actor . api . rpc . sequence . { RequestGetDifference , RequestSubscribeToOnline , RequestGetState } 
 + import im . actor . api . rpc . sequence . { RequestGetDifference , RequestGetState , RequestSubscribeToOnline , UpdateRawUpdate } 
 import im . actor . api . rpc . misc . ResponseSeq 
 import im . actor . api . rpc . weak . UpdateUserOffline 
 import im . actor . api . rpc . { AuthorizedClientData , Request , RpcOk } 
 @ @ - 16 , 7 + 16 , 7 @ @ import im . actor . server . api . rpc . service . auth . AuthErrors 
 import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . mtproto . transport . _ 
 import im . actor . server . persist . AuthSessionRepo 
 - import im . actor . server . sequence . { SeqUpdatesExtension , WeakUpdatesExtension } 
 + import im . actor . server . sequence . { SeqUpdatesExtension , UserSequence , WeakUpdatesExtension } 
 import im . actor . server . user . UserExtension 
 import scodec . bits . _ 
 
 @ @ - 36 , 6 + 36 , 7 @ @ final class SessionSpec extends BaseSessionSpec { 
 it should " subscribe to presences " in sessions ( ) . pres 
 it should " receive fat updates " in sessions ( ) . fatSeq 
 it should " react to SessionHello " in sessions ( ) . hello 
 + it should " send SeqUpdateTooLong " in sessions ( ) . seqUpdateTooLong 
 
 case class sessions ( ) { 
 
 @ @ - 163 , 6 + 164 , 37 @ @ final class SessionSpec extends BaseSessionSpec { 
 } 
 } 
 
 + def seqUpdateTooLong ( ) = { 
 + val ( user , authId , _ , _ ) = createUser ( ) 
 + val sessionId = Random . nextLong ( ) 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , SessionHello ) 
 + ignoreNewSession ( ) 
 + 
 + sendRequest ( authId , sessionId , sessionRegion . ref , RequestGetState ( Vector . empty ) ) 
 + expectMessageAck ( ) 
 + expectRpcResult ( authId , sessionId ) 
 + 
 + val updatesCount = 31 
 + 
 + / / each update is 1024 bytes 
 + val payload = Array ( List . range ( 0 , 1005 ) . map ( _ . toByte ) : _ * ) 
 + val update = UpdateRawUpdate ( None , payload ) 
 + 
 + for ( _ ← 1 to updatesCount ) { 
 + whenReady ( seqUpdExt . deliverSingleUpdate ( user . id , update ) ) ( identity ) 
 + } 
 + 
 + / / expect 30Kb of updates to be pushed , then SeqUpdateTooLong ( no ack ) 
 + for ( _ ← 1 until updatesCount ) { 
 + expectSeqUpdate ( authId , sessionId , None ) 
 + } 
 + 
 + expectSeqUpdateTooLong ( authId , sessionId ) 
 + expectSeqUpdate ( authId , sessionId ) 
 + 
 + probe . expectNoMsg ( 5 . seconds ) 
 + } 
 + 
 def seq ( ) = { 
 val authId = createAuthId ( ) 
 val sessionId = Random . nextLong ( ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 index 0a7b511 . . a2c36b3 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 @ @ - 1 , 11 + 1 , 11 @ @ 
 package im . actor . server . session 
 
 - import akka . actor . { ActorSystem , ActorRef } 
 + import akka . actor . { ActorRef , ActorSystem } 
 import akka . testkit . TestProbe 
 import com . google . protobuf . ByteString 
 import im . actor . api . rpc . { Request , RpcRequest , RpcResult } 
 import im . actor . api . rpc . codecs . _ 
 - import im . actor . api . rpc . sequence . { WeakUpdate , FatSeqUpdate , SeqUpdate } 
 + import im . actor . api . rpc . sequence . { FatSeqUpdate , SeqUpdate , SeqUpdateTooLong , WeakUpdate } 
 import im . actor . server . api . rpc . RpcResultCodec 
 import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec 
 import im . actor . server . mtproto . protocol . _ 
 @ @ - 33 , 6 + 33 , 9 @ @ trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { 
 protected def expectWeakUpdate ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : WeakUpdate = 
 expectUpdateBox ( classOf [ WeakUpdate ] , authId , sessionId , None ) 
 
 + protected def expectSeqUpdateTooLong ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : SeqUpdateTooLong = 
 + expectUpdateBox ( classOf [ SeqUpdateTooLong ] , authId , sessionId , sendAckAt ) 
 + 
 protected def expectUpdateBox [ T < : im . actor . api . rpc . UpdateBox ] ( clazz : Class [ T ] , authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] ) ( implicit probe : TestProbe , m : Manifest [ T ] ) : T = { 
 val mb = expectMessageBox ( )
