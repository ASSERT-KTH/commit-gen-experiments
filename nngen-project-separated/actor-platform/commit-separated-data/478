BLEU SCORE: 0.027757915716335905

TEST MSG: DialogRoot , dialogs creation
GENERATED MSG: fix ( server : messaging ) : fixed dialog creation problems

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 8bf0431 . . ba67e8b 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 11 , 6 + 11 , 15 @ @ import " scalapb / scalapb . proto " ; < nl > import " model . proto " ; < nl > import " sequence . proto " ; < nl > < nl > + message DialogRootEvents { < nl > + message Created { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootEvent " ; < nl > + < nl > + required int64 ts = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + required Peer peer = 2 ; < nl > + } < nl > + } < nl > + < nl > message DialogCommands { < nl > < nl > message Envelope { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > new file mode 100644 < nl > index 0000000 . . 262029a < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 0 , 0 + 1 , 70 @ @ < nl > + package im . actor . server . dialog < nl > + < nl > + import java . time . Instant < nl > + < nl > + import im . actor . server . cqrs . _ < nl > + import im . actor . server . dialog . DialogCommands . SendMessage < nl > + import im . actor . server . model . { Peer , PeerType } < nl > + import im . actor . api . rpc . _ < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + trait DialogRootEvent extends TaggedEvent { < nl > + val ts : Instant < nl > + < nl > + override def tags : Set [ String ] = Set ( " dialogRoot " ) < nl > + } < nl > + < nl > + final case class DialogRootState ( < nl > + active : Map [ DialogGroup , Set [ Peer ] ] , < nl > + activePeers : Set [ Peer ] , < nl > + archived : Set [ Peer ] < nl > + ) extends ProcessorState [ DialogRootState , DialogRootEvent ] { < nl > + override def updated ( e : DialogRootEvent ) : DialogRootState = ? ? ? < nl > + } < nl > + < nl > + private class DialogRoot extends Processor [ DialogRootState , DialogRootEvent ] { < nl > + import DialogRootEvents . _ < nl > + < nl > + private val userId = self . path . name . toInt < nl > + private val selfPeer : Peer = Peer . privat ( userId ) < nl > + < nl > + override def persistenceId : String = s " DialogRoot _ $ userId " < nl > + < nl > + override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , Set . empty , Set . empty ) < nl > + < nl > + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = ? ? ? < nl > + < nl > + override protected def handleCommand : Receive = { < nl > + case sm : SendMessage ⇒ < nl > + needCreateDialog ( sm ) match { < nl > + case Some ( peer ) ⇒ < nl > + persist ( Created ( Instant . now ( ) , peer ) ) { e ⇒ < nl > + commit ( e ) < nl > + handleDialogCommand ( sm ) < nl > + } < nl > + case None ⇒ handleDialogCommand ( sm ) < nl > + } < nl > + case dc : DialogCommand ⇒ handleDialogCommand ( dc ) < nl > + } < nl > + < nl > + def handleDialogCommand : PartialFunction [ DialogCommand , Unit ] = { < nl > + case _ ⇒ < nl > + } < nl > + < nl > + private def needCreateDialog ( sm : SendMessage ) : Option [ Peer ] = { < nl > + val checkPeer = < nl > + sm . origin . typ match { < nl > + case PeerType . Group ⇒ sm . dest < nl > + case PeerType . Private ⇒ < nl > + if ( selfPeer = = sm . dest ) sm . origin < nl > + else sm . dest < nl > + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > + } < nl > + < nl > + if ( dialogExists ( checkPeer ) ) None < nl > + else Some ( checkPeer ) < nl > + } < nl > + < nl > + private def dialogExists ( peer : Peer ) : Boolean = state . activePeers . contains ( peer ) < nl > + } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index b73e615 . . c26a25e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 25 , 31 + 25 , 35 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > import DialogCommands . _ < nl > import DialogEvents . _ < nl > < nl > - protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { < nl > - becomeStashing ( replyTo ⇒ ( { < nl > - case seq : SeqStateDate ⇒ < nl > - replyTo ! seq < nl > - if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } < nl > - updateMessageDate ( state , sm . date ) < nl > - unstashAll ( ) < nl > - case fail : Status . Failure ⇒ < nl > - replyTo forward fail < nl > - unstashAll ( ) < nl > - } : Receive ) orElse reactions ( isHidden = state . isHidden ) ) < nl > - < nl > - withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > - ( for { < nl > - _ ← dialogExt . ackSendMessage ( peer , sm ) < nl > - message = sm . message < nl > - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) < nl > - _ ← dialogExt . updateCounters ( peer , userId ) < nl > - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) < nl > - } yield SeqStateDate ( seq , state , sm . date ) ) recover { < nl > - case e ⇒ < nl > - log . error ( e , " Failed to send message " ) < nl > - throw e < nl > - } < nl > - } pipeTo self < nl > + protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > + withCreated ( s ) { state ⇒ < nl > + becomeStashing ( replyTo ⇒ ( { < nl > + case seq : SeqStateDate ⇒ < nl > + replyTo ! seq < nl > + if ( state . isHidden ) { < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } < nl > + updateMessageDate ( state , sm . date ) < nl > + unstashAll ( ) < nl > + case fail : Status . Failure ⇒ < nl > + replyTo forward fail < nl > + unstashAll ( ) < nl > + } : Receive ) orElse reactions ( state ) , discardOld = true ) < nl > + < nl > + withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > + ( for { < nl > + _ ← dialogExt . ackSendMessage ( peer , sm ) < nl > + message = sm . message < nl > + _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) < nl > + _ ← dialogExt . updateCounters ( peer , userId ) < nl > + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) < nl > + } yield SeqStateDate ( seq , state , sm . date ) ) recover { < nl > + case e ⇒ < nl > + log . error ( e , " Failed to send message " ) < nl > + throw e < nl > + } < nl > + } pipeTo self < nl > + } < nl > } < nl > < nl > protected def updateCountersChanged ( ) : Unit = { < nl > @ @ - 58 , 55 + 62 , 60 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > . pipeTo ( sender ( ) ) < nl > } < nl > < nl > - protected def ackSendMessage ( isHidden : Boolean , sm : SendMessage ) : Unit = { < nl > - if ( peer . typ = = PeerType . Private ) { < nl > - SocialManager . recordRelation ( sm . origin . id , userId ) < nl > - SocialManager . recordRelation ( userId , sm . origin . id ) < nl > - } < nl > - < nl > - deliveryExt < nl > - . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > - . map ( _ ⇒ SendMessageAck ( ) ) < nl > - . pipeTo ( sender ( ) ) onSuccess { < nl > - case _ ⇒ < nl > - if ( isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } < nl > + protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = < nl > + withCreated ( s ) { state ⇒ < nl > + if ( peer . typ = = PeerType . Private ) { < nl > + SocialManager . recordRelation ( sm . origin . id , userId ) < nl > + SocialManager . recordRelation ( userId , sm . origin . id ) < nl > } < nl > - } < nl > + < nl > + deliveryExt < nl > + . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > + . map ( _ ⇒ SendMessageAck ( ) ) < nl > + . pipeTo ( sender ( ) ) onSuccess { < nl > + case _ ⇒ < nl > + if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } < nl > + } < nl > + } < nl > < nl > protected def writeMessage ( < nl > + s : DialogState , < nl > dateMillis : Long , < nl > randomId : Long , < nl > message : ApiMessage < nl > - ) : Unit = { < nl > - val date = new DateTime ( dateMillis ) < nl > - < nl > - db . run ( writeHistoryMessage ( < nl > - selfPeer , < nl > - peer , < nl > - date , < nl > - randomId , < nl > - message . header , < nl > - message . toByteArray < nl > - ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > - } < nl > + ) : Unit = < nl > + withCreated ( s ) { _ ⇒ < nl > + val date = new DateTime ( dateMillis ) < nl > + < nl > + db . run ( writeHistoryMessage ( < nl > + selfPeer , < nl > + peer , < nl > + date , < nl > + randomId , < nl > + message . header , < nl > + message . toByteArray < nl > + ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > + } < nl > < nl > protected def writeMessageSelf ( < nl > + s : DialogState , < nl > senderUserId : Int , < nl > dateMillis : Long , < nl > randomId : Long , < nl > message : ApiMessage < nl > - ) : Unit = { < nl > - val date = new DateTime ( dateMillis ) < nl > - < nl > - val result = < nl > - if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > - Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ { senderUserId } in dialog of user $ { userId } with user $ { peer . id } " ) ) < nl > - } else { < nl > - db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) < nl > - } < nl > - < nl > - result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > - } < nl > + ) : Unit = < nl > + withCreated ( s ) { _ ⇒ < nl > + val date = new DateTime ( dateMillis ) < nl > + < nl > + val result = < nl > + if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > + Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) < nl > + } else { < nl > + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) < nl > + } < nl > + < nl > + result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > + } < nl > < nl > protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { < nl > val mustReceive = mustMakeReceive ( state , mr ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 8330296 . . c4f6144 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 6 , 7 + 6 , 6 @ @ import akka . actor . _ < nl > import akka . pattern . pipe < nl > import akka . util . Timeout < nl > import com . github . benmanes . caffeine . cache . Cache < nl > - import im . actor . api . rpc . messaging . ApiTextMessage < nl > import im . actor . api . rpc . misc . ApiExtension < nl > import im . actor . concurrent . { ActorFutures , ActorStashing } < nl > import im . actor . serialization . ActorSerializer < nl > @ @ - 14 , 7 + 13 , 7 @ @ import im . actor . server . cqrs . ProcessorState < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . model . { Dialog ⇒ DialogModel , PeerType , Peer } < nl > import im . actor . server . persist . dialog . DialogRepo < nl > - import im . actor . server . persist . { GroupRepo , UserRepo , HistoryMessageRepo } < nl > + import im . actor . server . persist . { GroupRepo , UserRepo } < nl > import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > @ @ - 30 , 29 + 29 , 6 @ @ object DialogEvents { < nl > < nl > private [ dialog ] sealed trait DialogEvent < nl > < nl > - sealed trait InitState < nl > - < nl > - private [ dialog ] object Initialized { < nl > - def fromDialog ( dialog : DialogModel ) : Initialized = < nl > - Initialized ( < nl > - dialog . lastMessageDate . getMillis , < nl > - dialog . ownerLastReceivedAt . getMillis , < nl > - dialog . ownerLastReadAt . getMillis , < nl > - dialog . shownAt . isEmpty , < nl > - dialog . isFavourite < nl > - ) < nl > - } < nl > - < nl > - private [ dialog ] final case class Initialized ( < nl > - lastMessageDate : Long , < nl > - lastReceiveDate : Long , < nl > - lastReadDate : Long , < nl > - isHidden : Boolean , < nl > - isFavourite : Boolean < nl > - ) extends DialogEvent with InitState < nl > - < nl > - private [ dialog ] case object Uninitialized extends DialogEvent with InitState < nl > - < nl > private [ dialog ] final case class LastMessageDate ( date : Long ) extends DialogEvent < nl > < nl > private [ dialog ] final case class LastReceiveDate ( date : Long ) extends DialogEvent < nl > @ @ - 73 , 8 + 49 , 19 @ @ private [ dialog ] object DialogState { < nl > lastReceiveDate : Long , < nl > lastReadDate : Long , < nl > isHidden : Boolean , < nl > - isFavourite : Boolean < nl > - ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) < nl > + isFavourite : Boolean , < nl > + isCreated : Boolean < nl > + ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isCreated ) < nl > + < nl > + def fromModel ( model : DialogModel , isCreated : Boolean ) : DialogState = < nl > + DialogState ( < nl > + model . lastMessageDate . getMillis , < nl > + model . ownerLastReceivedAt . getMillis , < nl > + model . ownerLastReadAt . getMillis , < nl > + model . shownAt . isEmpty , < nl > + model . isFavourite , < nl > + isCreated = isCreated < nl > + ) < nl > } < nl > < nl > private [ dialog ] final case class DialogState ( < nl > @ @ - 82 , 7 + 69 , 8 @ @ private [ dialog ] final case class DialogState ( < nl > lastReceiveDate : Long , < nl > lastReadDate : Long , < nl > isHidden : Boolean , < nl > - isFavourite : Boolean < nl > + isFavourite : Boolean , < nl > + isCreated : Boolean < nl > ) extends ProcessorState [ DialogState ] { < nl > import DialogEvents . _ < nl > override def updated ( e : AnyRef , ts : Instant ) : DialogState = e match { < nl > @ @ - 126 , 7 + 114 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > with ActorFutures < nl > with ActorStashing { < nl > import DialogCommands . _ < nl > - import DialogEvents . _ < nl > import DialogProcessor . _ < nl > < nl > protected implicit val ec : ExecutionContext = context . dispatcher < nl > @ @ - 146 , 49 + 133 , 24 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = < nl > createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) < nl > < nl > - override def receive : Receive = initializing < nl > + override def preStart ( ) = init ( ) < nl > < nl > - def initializing : Receive = { < nl > - case msg ⇒ < nl > - stash ( ) < nl > - becomeStashing ( replyTo ⇒ ( { < nl > - case Initialized ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) ⇒ < nl > - context become initialized ( DialogState . init ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) ) < nl > - unstashAll ( ) < nl > - case Status . Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to init dialog " ) < nl > - self ! Kill < nl > - } : Receive ) orElse reactions ( isHidden = false ) orElse dummyActions ) < nl > - < nl > - ( for { < nl > - state ← initialState < nl > - resultMessage ← state match { < nl > - case init : Initialized ⇒ Future . successful ( init ) < nl > - case Uninitialized ⇒ < nl > - if ( isWriteOperation ( msg ) ) { < nl > - log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) < nl > - val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > - db . run ( for { < nl > - exists ← peer . ` type ` match { < nl > - case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) < nl > - case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) < nl > - case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) < nl > - } < nl > - _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ { peer } does not exist " ) ) < nl > - _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > - } yield Initialized . fromDialog ( dialog ) ) < nl > - } else { < nl > - Future . successful ( msg ) < nl > - } < nl > - } < nl > - } yield resultMessage ) . to ( self , sender ( ) ) < nl > - } < nl > + def receive = initializing < nl > + < nl > + def initializing : Receive = receiveStashing ( replyTo ⇒ { < nl > + case state : DialogState ⇒ < nl > + context become initialized ( state ) < nl > + unstashAll ( ) < nl > + case Status . Failure ( cause ) ⇒ < nl > + log . error ( cause , " Failed to init dialog " ) < nl > + self ! Kill < nl > + } ) < nl > < nl > - def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( isHidden = state . isHidden ) < nl > + def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( state ) < nl > < nl > / / when receiving this messages , dialog reacts on other dialog ' s action < nl > - def reactions ( isHidden : Boolean ) : Receive = { < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( isHidden , sm ) / / User ' s message been sent < nl > + def reactions ( state : DialogState ) : Receive = { < nl > + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received < nl > case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) < nl > @ @ - 196 , 11 + 158 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case uc : UpdateCounters ⇒ updateCountersChanged ( ) < nl > } < nl > < nl > - def dummyActions : Receive = { < nl > - case mrv : MessageReceived if invokes ( mrv ) ⇒ Future . successful ( MessageReceivedAck ( ) ) pipeTo sender ( ) < nl > - case mrd : MessageRead if invokes ( mrd ) ⇒ Future . successful ( MessageReadAck ( ) ) pipeTo sender ( ) < nl > - } < nl > - < nl > / / when receiving this messages , dialog required to take action < nl > def actions ( state : DialogState ) : Receive = { < nl > case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > @ @ - 213 , 8 + 170 , 8 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case Favourite ( _ ) ⇒ favourite ( state ) < nl > case Unfavourite ( _ ) ⇒ unfavourite ( state ) < nl > case Delete ( _ ) ⇒ delete ( state ) < nl > - case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) < nl > - case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) < nl > + case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( state , date , randomId , message ) < nl > + case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) < nl > } < nl > < nl > / * * < nl > @ @ - 243 , 18 + 200 , 43 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > * / < nl > private def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) < nl > < nl > - private def isWriteOperation : PartialFunction [ Any , Boolean ] = { < nl > - case _ : SendMessage | _ : WriteMessage | _ : WriteMessageSelf ⇒ true < nl > - case _ ⇒ false < nl > - } < nl > - < nl > - private def initialState : Future [ InitState ] = < nl > - for { < nl > + private def init ( ) : Unit = { < nl > + ( for { < nl > optDialog ← db . run ( DialogRepo . findDialog ( userId , peer ) ) < nl > initState ← optDialog match { < nl > - case Some ( dialog ) ⇒ Future . successful ( Initialized . fromDialog ( dialog ) ) < nl > - case None ⇒ Future . successful ( Uninitialized ) < nl > + case Some ( dialog ) ⇒ Future . successful ( DialogState . fromModel ( dialog , isCreated = true ) ) < nl > + case None ⇒ Future . successful ( DialogState . fromModel ( DialogModel ( userId , peer ) , isCreated = false ) ) < nl > } < nl > - } yield initState < nl > + } yield initState ) pipeTo self < nl > + } < nl > + < nl > + protected def withCreated ( state : DialogState ) ( f : DialogState ⇒ Unit ) : Unit = { < nl > + if ( state . isCreated ) f ( state ) < nl > + else { < nl > + log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) < nl > + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > + val replyTo = sender ( ) < nl > + < nl > + db . run ( for { < nl > + exists ← peer . ` type ` match { < nl > + case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) < nl > + case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) < nl > + case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) < nl > + } < nl > + _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ peer does not exist " ) ) < nl > + _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > + } yield DialogState . fromModel ( dialog , isCreated = true ) ) . to ( self , replyTo ) < nl > + < nl > + becomeStashing ( replyTo ⇒ { < nl > + case state : DialogState ⇒ < nl > + context become initialized ( state ) < nl > + unstashAll ( ) < nl > + f ( state ) < nl > + case Status . Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to create dialog " ) < nl > + self ! Kill < nl > + } , discardOld = true ) < nl > + } < nl > + } < nl > < nl > } < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala < nl > index 797646d . . 962bb84 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala < nl > @ @ - 10 , 11 + 10 , 13 @ @ import scala . concurrent . ExecutionContext < nl > object DialogCommonRepo { < nl > val dialogCommon = TableQuery [ DialogCommonTable ] < nl > < nl > - private def byPK ( dialogId : Rep [ String ] ) = { < nl > + private def byPK ( dialogId : Rep [ String ] ) = < nl > dialogCommon . filter ( _ . dialogId = = = dialogId ) < nl > - } < nl > + < nl > + private def exists ( dialogId : Rep [ String ] ) = byPK ( dialogId ) . exists < nl > < nl > val byPKC = Compiled ( byPK _ ) < nl > + val existsC = Compiled ( exists _ ) < nl > } < nl > < nl > trait DialogCommonOperations extends DialogId { < nl > @ @ - 23 , 8 + 25 , 7 @ @ trait DialogCommonOperations extends DialogId { < nl > def findCommon ( userId : Option [ Int ] , peer : Peer ) : DBIO [ Option [ DialogCommon ] ] = < nl > byPKC . applied ( getDialogId ( userId , peer ) ) . result . headOption < nl > < nl > - def commonExists ( dialogId : String ) = < nl > - byPKC . applied ( dialogId ) . exists . result < nl > + def commonExists ( dialogId : String ) = existsC ( dialogId ) . result < nl > < nl > def updateLastMessageDatePrivate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = { < nl > requirePrivate ( peer ) < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > index 1befed8 . . b478eba 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > @ @ - 8 , 6 + 8 , 7 @ @ import org . joda . time . DateTime < nl > import slick . lifted . ColumnOrdered < nl > < nl > import scala . concurrent . ExecutionContext < nl > + import scala . util . { Success , Failure } < nl > < nl > final class DialogCommonTable ( tag : Tag ) extends Table [ DialogCommon ] ( tag , " dialog _ commons " ) { < nl > < nl > @ @ - 151 , 7 + 152 , 16 @ @ object DialogRepo extends UserDialogOperations with DialogCommonOperations { < nl > UserDialogRepo . userDialogs + = user < nl > } else { < nl > for { < nl > - c ← DialogCommonRepo . dialogCommon + = common < nl > + c ← ( DialogCommonRepo . dialogCommon + = common ) < nl > + . asTry < nl > + . flatMap { < nl > + case Failure ( e ) ⇒ < nl > + commonExists ( common . dialogId ) flatMap { < nl > + case true ⇒ DBIO . successful ( 1 ) < nl > + case false ⇒ DBIO . failed ( e ) < nl > + } < nl > + case Success ( res ) ⇒ DBIO . successful ( res ) < nl > + } < nl > _ ← UserDialogRepo . userDialogs + = user < nl > } yield c < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 8bf0431 . . ba67e8b 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 11 , 6 + 11 , 15 @ @ import " scalapb / scalapb . proto " ; 
 import " model . proto " ; 
 import " sequence . proto " ; 
 
 + message DialogRootEvents { 
 + message Created { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootEvent " ; 
 + 
 + required int64 ts = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + required Peer peer = 2 ; 
 + } 
 + } 
 + 
 message DialogCommands { 
 
 message Envelope { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 new file mode 100644 
 index 0000000 . . 262029a 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 0 , 0 + 1 , 70 @ @ 
 + package im . actor . server . dialog 
 + 
 + import java . time . Instant 
 + 
 + import im . actor . server . cqrs . _ 
 + import im . actor . server . dialog . DialogCommands . SendMessage 
 + import im . actor . server . model . { Peer , PeerType } 
 + import im . actor . api . rpc . _ 
 + 
 + import scala . concurrent . Future 
 + 
 + trait DialogRootEvent extends TaggedEvent { 
 + val ts : Instant 
 + 
 + override def tags : Set [ String ] = Set ( " dialogRoot " ) 
 + } 
 + 
 + final case class DialogRootState ( 
 + active : Map [ DialogGroup , Set [ Peer ] ] , 
 + activePeers : Set [ Peer ] , 
 + archived : Set [ Peer ] 
 + ) extends ProcessorState [ DialogRootState , DialogRootEvent ] { 
 + override def updated ( e : DialogRootEvent ) : DialogRootState = ? ? ? 
 + } 
 + 
 + private class DialogRoot extends Processor [ DialogRootState , DialogRootEvent ] { 
 + import DialogRootEvents . _ 
 + 
 + private val userId = self . path . name . toInt 
 + private val selfPeer : Peer = Peer . privat ( userId ) 
 + 
 + override def persistenceId : String = s " DialogRoot _ $ userId " 
 + 
 + override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , Set . empty , Set . empty ) 
 + 
 + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = ? ? ? 
 + 
 + override protected def handleCommand : Receive = { 
 + case sm : SendMessage ⇒ 
 + needCreateDialog ( sm ) match { 
 + case Some ( peer ) ⇒ 
 + persist ( Created ( Instant . now ( ) , peer ) ) { e ⇒ 
 + commit ( e ) 
 + handleDialogCommand ( sm ) 
 + } 
 + case None ⇒ handleDialogCommand ( sm ) 
 + } 
 + case dc : DialogCommand ⇒ handleDialogCommand ( dc ) 
 + } 
 + 
 + def handleDialogCommand : PartialFunction [ DialogCommand , Unit ] = { 
 + case _ ⇒ 
 + } 
 + 
 + private def needCreateDialog ( sm : SendMessage ) : Option [ Peer ] = { 
 + val checkPeer = 
 + sm . origin . typ match { 
 + case PeerType . Group ⇒ sm . dest 
 + case PeerType . Private ⇒ 
 + if ( selfPeer = = sm . dest ) sm . origin 
 + else sm . dest 
 + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 + } 
 + 
 + if ( dialogExists ( checkPeer ) ) None 
 + else Some ( checkPeer ) 
 + } 
 + 
 + private def dialogExists ( peer : Peer ) : Boolean = state . activePeers . contains ( peer ) 
 + } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index b73e615 . . c26a25e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 25 , 31 + 25 , 35 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 import DialogCommands . _ 
 import DialogEvents . _ 
 
 - protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { 
 - becomeStashing ( replyTo ⇒ ( { 
 - case seq : SeqStateDate ⇒ 
 - replyTo ! seq 
 - if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } 
 - updateMessageDate ( state , sm . date ) 
 - unstashAll ( ) 
 - case fail : Status . Failure ⇒ 
 - replyTo forward fail 
 - unstashAll ( ) 
 - } : Receive ) orElse reactions ( isHidden = state . isHidden ) ) 
 - 
 - withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 - ( for { 
 - _ ← dialogExt . ackSendMessage ( peer , sm ) 
 - message = sm . message 
 - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) 
 - _ ← dialogExt . updateCounters ( peer , userId ) 
 - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) 
 - } yield SeqStateDate ( seq , state , sm . date ) ) recover { 
 - case e ⇒ 
 - log . error ( e , " Failed to send message " ) 
 - throw e 
 - } 
 - } pipeTo self 
 + protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 + withCreated ( s ) { state ⇒ 
 + becomeStashing ( replyTo ⇒ ( { 
 + case seq : SeqStateDate ⇒ 
 + replyTo ! seq 
 + if ( state . isHidden ) { 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } 
 + updateMessageDate ( state , sm . date ) 
 + unstashAll ( ) 
 + case fail : Status . Failure ⇒ 
 + replyTo forward fail 
 + unstashAll ( ) 
 + } : Receive ) orElse reactions ( state ) , discardOld = true ) 
 + 
 + withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 + ( for { 
 + _ ← dialogExt . ackSendMessage ( peer , sm ) 
 + message = sm . message 
 + _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) 
 + _ ← dialogExt . updateCounters ( peer , userId ) 
 + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) 
 + } yield SeqStateDate ( seq , state , sm . date ) ) recover { 
 + case e ⇒ 
 + log . error ( e , " Failed to send message " ) 
 + throw e 
 + } 
 + } pipeTo self 
 + } 
 } 
 
 protected def updateCountersChanged ( ) : Unit = { 
 @ @ - 58 , 55 + 62 , 60 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 . pipeTo ( sender ( ) ) 
 } 
 
 - protected def ackSendMessage ( isHidden : Boolean , sm : SendMessage ) : Unit = { 
 - if ( peer . typ = = PeerType . Private ) { 
 - SocialManager . recordRelation ( sm . origin . id , userId ) 
 - SocialManager . recordRelation ( userId , sm . origin . id ) 
 - } 
 - 
 - deliveryExt 
 - . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 - . map ( _ ⇒ SendMessageAck ( ) ) 
 - . pipeTo ( sender ( ) ) onSuccess { 
 - case _ ⇒ 
 - if ( isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } 
 + protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = 
 + withCreated ( s ) { state ⇒ 
 + if ( peer . typ = = PeerType . Private ) { 
 + SocialManager . recordRelation ( sm . origin . id , userId ) 
 + SocialManager . recordRelation ( userId , sm . origin . id ) 
 } 
 - } 
 + 
 + deliveryExt 
 + . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 + . map ( _ ⇒ SendMessageAck ( ) ) 
 + . pipeTo ( sender ( ) ) onSuccess { 
 + case _ ⇒ 
 + if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } 
 + } 
 + } 
 
 protected def writeMessage ( 
 + s : DialogState , 
 dateMillis : Long , 
 randomId : Long , 
 message : ApiMessage 
 - ) : Unit = { 
 - val date = new DateTime ( dateMillis ) 
 - 
 - db . run ( writeHistoryMessage ( 
 - selfPeer , 
 - peer , 
 - date , 
 - randomId , 
 - message . header , 
 - message . toByteArray 
 - ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 - } 
 + ) : Unit = 
 + withCreated ( s ) { _ ⇒ 
 + val date = new DateTime ( dateMillis ) 
 + 
 + db . run ( writeHistoryMessage ( 
 + selfPeer , 
 + peer , 
 + date , 
 + randomId , 
 + message . header , 
 + message . toByteArray 
 + ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 + } 
 
 protected def writeMessageSelf ( 
 + s : DialogState , 
 senderUserId : Int , 
 dateMillis : Long , 
 randomId : Long , 
 message : ApiMessage 
 - ) : Unit = { 
 - val date = new DateTime ( dateMillis ) 
 - 
 - val result = 
 - if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 - Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ { senderUserId } in dialog of user $ { userId } with user $ { peer . id } " ) ) 
 - } else { 
 - db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) 
 - } 
 - 
 - result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 - } 
 + ) : Unit = 
 + withCreated ( s ) { _ ⇒ 
 + val date = new DateTime ( dateMillis ) 
 + 
 + val result = 
 + if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 + Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) 
 + } else { 
 + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) 
 + } 
 + 
 + result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 + } 
 
 protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { 
 val mustReceive = mustMakeReceive ( state , mr ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 8330296 . . c4f6144 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 6 , 7 + 6 , 6 @ @ import akka . actor . _ 
 import akka . pattern . pipe 
 import akka . util . Timeout 
 import com . github . benmanes . caffeine . cache . Cache 
 - import im . actor . api . rpc . messaging . ApiTextMessage 
 import im . actor . api . rpc . misc . ApiExtension 
 import im . actor . concurrent . { ActorFutures , ActorStashing } 
 import im . actor . serialization . ActorSerializer 
 @ @ - 14 , 7 + 13 , 7 @ @ import im . actor . server . cqrs . ProcessorState 
 import im . actor . server . db . DbExtension 
 import im . actor . server . model . { Dialog ⇒ DialogModel , PeerType , Peer } 
 import im . actor . server . persist . dialog . DialogRepo 
 - import im . actor . server . persist . { GroupRepo , UserRepo , HistoryMessageRepo } 
 + import im . actor . server . persist . { GroupRepo , UserRepo } 
 import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 @ @ - 30 , 29 + 29 , 6 @ @ object DialogEvents { 
 
 private [ dialog ] sealed trait DialogEvent 
 
 - sealed trait InitState 
 - 
 - private [ dialog ] object Initialized { 
 - def fromDialog ( dialog : DialogModel ) : Initialized = 
 - Initialized ( 
 - dialog . lastMessageDate . getMillis , 
 - dialog . ownerLastReceivedAt . getMillis , 
 - dialog . ownerLastReadAt . getMillis , 
 - dialog . shownAt . isEmpty , 
 - dialog . isFavourite 
 - ) 
 - } 
 - 
 - private [ dialog ] final case class Initialized ( 
 - lastMessageDate : Long , 
 - lastReceiveDate : Long , 
 - lastReadDate : Long , 
 - isHidden : Boolean , 
 - isFavourite : Boolean 
 - ) extends DialogEvent with InitState 
 - 
 - private [ dialog ] case object Uninitialized extends DialogEvent with InitState 
 - 
 private [ dialog ] final case class LastMessageDate ( date : Long ) extends DialogEvent 
 
 private [ dialog ] final case class LastReceiveDate ( date : Long ) extends DialogEvent 
 @ @ - 73 , 8 + 49 , 19 @ @ private [ dialog ] object DialogState { 
 lastReceiveDate : Long , 
 lastReadDate : Long , 
 isHidden : Boolean , 
 - isFavourite : Boolean 
 - ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) 
 + isFavourite : Boolean , 
 + isCreated : Boolean 
 + ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isCreated ) 
 + 
 + def fromModel ( model : DialogModel , isCreated : Boolean ) : DialogState = 
 + DialogState ( 
 + model . lastMessageDate . getMillis , 
 + model . ownerLastReceivedAt . getMillis , 
 + model . ownerLastReadAt . getMillis , 
 + model . shownAt . isEmpty , 
 + model . isFavourite , 
 + isCreated = isCreated 
 + ) 
 } 
 
 private [ dialog ] final case class DialogState ( 
 @ @ - 82 , 7 + 69 , 8 @ @ private [ dialog ] final case class DialogState ( 
 lastReceiveDate : Long , 
 lastReadDate : Long , 
 isHidden : Boolean , 
 - isFavourite : Boolean 
 + isFavourite : Boolean , 
 + isCreated : Boolean 
 ) extends ProcessorState [ DialogState ] { 
 import DialogEvents . _ 
 override def updated ( e : AnyRef , ts : Instant ) : DialogState = e match { 
 @ @ - 126 , 7 + 114 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 with ActorFutures 
 with ActorStashing { 
 import DialogCommands . _ 
 - import DialogEvents . _ 
 import DialogProcessor . _ 
 
 protected implicit val ec : ExecutionContext = context . dispatcher 
 @ @ - 146 , 49 + 133 , 24 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = 
 createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) 
 
 - override def receive : Receive = initializing 
 + override def preStart ( ) = init ( ) 
 
 - def initializing : Receive = { 
 - case msg ⇒ 
 - stash ( ) 
 - becomeStashing ( replyTo ⇒ ( { 
 - case Initialized ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) ⇒ 
 - context become initialized ( DialogState . init ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) ) 
 - unstashAll ( ) 
 - case Status . Failure ( e ) ⇒ 
 - log . error ( e , " Failed to init dialog " ) 
 - self ! Kill 
 - } : Receive ) orElse reactions ( isHidden = false ) orElse dummyActions ) 
 - 
 - ( for { 
 - state ← initialState 
 - resultMessage ← state match { 
 - case init : Initialized ⇒ Future . successful ( init ) 
 - case Uninitialized ⇒ 
 - if ( isWriteOperation ( msg ) ) { 
 - log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) 
 - val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 - db . run ( for { 
 - exists ← peer . ` type ` match { 
 - case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) 
 - case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) 
 - case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) 
 - } 
 - _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ { peer } does not exist " ) ) 
 - _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 - } yield Initialized . fromDialog ( dialog ) ) 
 - } else { 
 - Future . successful ( msg ) 
 - } 
 - } 
 - } yield resultMessage ) . to ( self , sender ( ) ) 
 - } 
 + def receive = initializing 
 + 
 + def initializing : Receive = receiveStashing ( replyTo ⇒ { 
 + case state : DialogState ⇒ 
 + context become initialized ( state ) 
 + unstashAll ( ) 
 + case Status . Failure ( cause ) ⇒ 
 + log . error ( cause , " Failed to init dialog " ) 
 + self ! Kill 
 + } ) 
 
 - def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( isHidden = state . isHidden ) 
 + def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( state ) 
 
 / / when receiving this messages , dialog reacts on other dialog ' s action 
 - def reactions ( isHidden : Boolean ) : Receive = { 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( isHidden , sm ) / / User ' s message been sent 
 + def reactions ( state : DialogState ) : Receive = { 
 + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received 
 case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) 
 @ @ - 196 , 11 + 158 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case uc : UpdateCounters ⇒ updateCountersChanged ( ) 
 } 
 
 - def dummyActions : Receive = { 
 - case mrv : MessageReceived if invokes ( mrv ) ⇒ Future . successful ( MessageReceivedAck ( ) ) pipeTo sender ( ) 
 - case mrd : MessageRead if invokes ( mrd ) ⇒ Future . successful ( MessageReadAck ( ) ) pipeTo sender ( ) 
 - } 
 - 
 / / when receiving this messages , dialog required to take action 
 def actions ( state : DialogState ) : Receive = { 
 case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 @ @ - 213 , 8 + 170 , 8 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case Favourite ( _ ) ⇒ favourite ( state ) 
 case Unfavourite ( _ ) ⇒ unfavourite ( state ) 
 case Delete ( _ ) ⇒ delete ( state ) 
 - case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) 
 - case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) 
 + case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( state , date , randomId , message ) 
 + case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) 
 } 
 
 / * * 
 @ @ - 243 , 18 + 200 , 43 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 * / 
 private def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) 
 
 - private def isWriteOperation : PartialFunction [ Any , Boolean ] = { 
 - case _ : SendMessage | _ : WriteMessage | _ : WriteMessageSelf ⇒ true 
 - case _ ⇒ false 
 - } 
 - 
 - private def initialState : Future [ InitState ] = 
 - for { 
 + private def init ( ) : Unit = { 
 + ( for { 
 optDialog ← db . run ( DialogRepo . findDialog ( userId , peer ) ) 
 initState ← optDialog match { 
 - case Some ( dialog ) ⇒ Future . successful ( Initialized . fromDialog ( dialog ) ) 
 - case None ⇒ Future . successful ( Uninitialized ) 
 + case Some ( dialog ) ⇒ Future . successful ( DialogState . fromModel ( dialog , isCreated = true ) ) 
 + case None ⇒ Future . successful ( DialogState . fromModel ( DialogModel ( userId , peer ) , isCreated = false ) ) 
 } 
 - } yield initState 
 + } yield initState ) pipeTo self 
 + } 
 + 
 + protected def withCreated ( state : DialogState ) ( f : DialogState ⇒ Unit ) : Unit = { 
 + if ( state . isCreated ) f ( state ) 
 + else { 
 + log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) 
 + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 + val replyTo = sender ( ) 
 + 
 + db . run ( for { 
 + exists ← peer . ` type ` match { 
 + case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) 
 + case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) 
 + case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) 
 + } 
 + _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ peer does not exist " ) ) 
 + _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 + } yield DialogState . fromModel ( dialog , isCreated = true ) ) . to ( self , replyTo ) 
 + 
 + becomeStashing ( replyTo ⇒ { 
 + case state : DialogState ⇒ 
 + context become initialized ( state ) 
 + unstashAll ( ) 
 + f ( state ) 
 + case Status . Failure ( e ) ⇒ 
 + log . error ( e , " Failed to create dialog " ) 
 + self ! Kill 
 + } , discardOld = true ) 
 + } 
 + } 
 
 } 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala 
 index 797646d . . 962bb84 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala 
 @ @ - 10 , 11 + 10 , 13 @ @ import scala . concurrent . ExecutionContext 
 object DialogCommonRepo { 
 val dialogCommon = TableQuery [ DialogCommonTable ] 
 
 - private def byPK ( dialogId : Rep [ String ] ) = { 
 + private def byPK ( dialogId : Rep [ String ] ) = 
 dialogCommon . filter ( _ . dialogId = = = dialogId ) 
 - } 
 + 
 + private def exists ( dialogId : Rep [ String ] ) = byPK ( dialogId ) . exists 
 
 val byPKC = Compiled ( byPK _ ) 
 + val existsC = Compiled ( exists _ ) 
 } 
 
 trait DialogCommonOperations extends DialogId { 
 @ @ - 23 , 8 + 25 , 7 @ @ trait DialogCommonOperations extends DialogId { 
 def findCommon ( userId : Option [ Int ] , peer : Peer ) : DBIO [ Option [ DialogCommon ] ] = 
 byPKC . applied ( getDialogId ( userId , peer ) ) . result . headOption 
 
 - def commonExists ( dialogId : String ) = 
 - byPKC . applied ( dialogId ) . exists . result 
 + def commonExists ( dialogId : String ) = existsC ( dialogId ) . result 
 
 def updateLastMessageDatePrivate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = { 
 requirePrivate ( peer ) 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 index 1befed8 . . b478eba 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 @ @ - 8 , 6 + 8 , 7 @ @ import org . joda . time . DateTime 
 import slick . lifted . ColumnOrdered 
 
 import scala . concurrent . ExecutionContext 
 + import scala . util . { Success , Failure } 
 
 final class DialogCommonTable ( tag : Tag ) extends Table [ DialogCommon ] ( tag , " dialog _ commons " ) { 
 
 @ @ - 151 , 7 + 152 , 16 @ @ object DialogRepo extends UserDialogOperations with DialogCommonOperations { 
 UserDialogRepo . userDialogs + = user 
 } else { 
 for { 
 - c ← DialogCommonRepo . dialogCommon + = common 
 + c ← ( DialogCommonRepo . dialogCommon + = common ) 
 + . asTry 
 + . flatMap { 
 + case Failure ( e ) ⇒ 
 + commonExists ( common . dialogId ) flatMap { 
 + case true ⇒ DBIO . successful ( 1 ) 
 + case false ⇒ DBIO . failed ( e ) 
 + } 
 + case Success ( res ) ⇒ DBIO . successful ( res ) 
 + } 
 _ ← UserDialogRepo . userDialogs + = user 
 } yield c 
 }
