BLEU SCORE: 0.08737167851715878

TEST MSG: fix ( server : core ) : keep randomId unique inside single dialog
GENERATED MSG: feat ( server ) : edit last message

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index b74fdcc . . 32e6416 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 29 , 48 + 29 , 54 @ @ object HistoryUtils { < nl > requirePrivatePeer ( fromPeer ) < nl > / / requireDifferentPeers ( fromPeer , toPeer ) < nl > < nl > - if ( toPeer . typ = = PeerType . Private ) { < nl > - val outMessage = HistoryMessage ( < nl > - userId = fromPeer . id , < nl > - peer = toPeer , < nl > - date = date , < nl > - senderUserId = fromPeer . id , < nl > - randomId = randomId , < nl > - messageContentHeader = messageContentHeader , < nl > - messageContentData = messageContentData , < nl > - deletedAt = None < nl > - ) < nl > - < nl > - val messages = < nl > - if ( fromPeer ! = toPeer ) { < nl > - Seq ( < nl > - outMessage , < nl > - outMessage . copy ( userId = toPeer . id , peer = fromPeer ) < nl > + HistoryMessageRepo . existstWithRandomId ( fromPeer . id , toPeer , randomId ) flatMap { exists ⇒ < nl > + if ( exists ) { < nl > + DBIO . failed ( NotUniqueRandomId ) < nl > + } else { < nl > + if ( toPeer . typ = = PeerType . Private ) { < nl > + val outMessage = HistoryMessage ( < nl > + userId = fromPeer . id , < nl > + peer = toPeer , < nl > + date = date , < nl > + senderUserId = fromPeer . id , < nl > + randomId = randomId , < nl > + messageContentHeader = messageContentHeader , < nl > + messageContentData = messageContentData , < nl > + deletedAt = None < nl > ) < nl > - } else { < nl > - Seq ( outMessage ) < nl > - } < nl > < nl > - for { < nl > - _ ← HistoryMessageRepo . create ( messages ) < nl > - } yield ( ) < nl > - } else if ( toPeer . typ = = PeerType . Group ) { < nl > - for { < nl > - isHistoryShared ← DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) < nl > - _ ← if ( isHistoryShared ) { < nl > - val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > - HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) < nl > - } else { < nl > - DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ < nl > - val historyMessages = groupUserIds . map { groupUserId ⇒ < nl > - HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > + val messages = < nl > + if ( fromPeer ! = toPeer ) { < nl > + Seq ( < nl > + outMessage , < nl > + outMessage . copy ( userId = toPeer . id , peer = fromPeer ) < nl > + ) < nl > + } else { < nl > + Seq ( outMessage ) < nl > } < nl > - HistoryMessageRepo . create ( historyMessages ) map ( _ ⇒ ( ) ) < nl > - } < nl > + < nl > + for { < nl > + _ ← HistoryMessageRepo . create ( messages ) < nl > + } yield ( ) < nl > + } else if ( toPeer . typ = = PeerType . Group ) { < nl > + for { < nl > + isHistoryShared ← DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) < nl > + _ ← if ( isHistoryShared ) { < nl > + val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > + HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) < nl > + } else { < nl > + DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ < nl > + val historyMessages = groupUserIds . map { groupUserId ⇒ < nl > + HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > + } < nl > + HistoryMessageRepo . create ( historyMessages ) map ( _ ⇒ ( ) ) < nl > + } < nl > + } < nl > + } yield ( ) < nl > + } else { < nl > + DBIO . failed ( new Exception ( " PeerType is not supported " ) with NoStackTrace ) < nl > } < nl > - } yield ( ) < nl > - } else { < nl > - DBIO . failed ( new Exception ( " PeerType is not supported " ) with NoStackTrace ) < nl > + } < nl > } < nl > } < nl > < nl > @ @ - 84 , 16 + 90 , 21 @ @ object HistoryUtils { < nl > messageContentData : Array [ Byte ] < nl > ) ( implicit ec : ExecutionContext ) : DBIO [ Unit ] = { < nl > for { < nl > - _ ← HistoryMessageRepo . create ( HistoryMessage ( < nl > - userId = userId , < nl > - peer = toPeer , < nl > - date = date , < nl > - senderUserId = senderUserId , < nl > - randomId = randomId , < nl > - messageContentHeader = messageContentHeader , < nl > - messageContentData = messageContentData , < nl > - deletedAt = None < nl > - ) ) < nl > + exists ← HistoryMessageRepo . existstWithRandomId ( userId , toPeer , randomId ) < nl > + _ ← if ( exists ) { < nl > + DBIO . failed ( NotUniqueRandomId ) < nl > + } else { < nl > + HistoryMessageRepo . create ( HistoryMessage ( < nl > + userId = userId , < nl > + peer = toPeer , < nl > + date = date , < nl > + senderUserId = senderUserId , < nl > + randomId = randomId , < nl > + messageContentHeader = messageContentHeader , < nl > + messageContentData = messageContentData , < nl > + deletedAt = None < nl > + ) ) < nl > + } < nl > } yield ( ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / package . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / package . scala < nl > index d3c7018 . . 17d0023 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / package . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / package . scala < nl > @ @ - 4 , 10 + 4 , 5 @ @ import scala . util . control . NoStackTrace < nl > < nl > package object dialog { < nl > type AuthSidRandomId = ( Int , Long ) < nl > - < nl > - case object ReceiveFailed extends Exception with NoStackTrace < nl > - < nl > - case object ReadFailed extends Exception with NoStackTrace < nl > - < nl > - private [ dialog ] case object StopDialog < nl > + case object NotUniqueRandomId extends RuntimeException with NoStackTrace < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index b94a3f2 . . edccab9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 180 , 7 + 180 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > } < nl > } < nl > < nl > - protected def setJoined ( group : GroupState , joiningUserId : Int , joinintUserAuthSid : Int , invitingUserId : Int ) : Unit = { < nl > + protected def setJoined ( group : GroupState , joiningUserId : Int , joiningUserAuthSid : Int , invitingUserId : Int ) : Unit = { < nl > if ( ! hasMember ( group , joiningUserId ) | | isInvited ( group , joiningUserId ) ) { < nl > val replyTo = sender ( ) < nl > < nl > @ @ - 200 , 7 + 200 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > seqstatedate ← DBIO . from ( DialogExtension ( system ) . sendMessage ( < nl > peer = ApiPeer ( ApiPeerType . Group , groupId ) , < nl > senderUserId = joiningUserId , < nl > - senderAuthSid = joinintUserAuthSid , < nl > + senderAuthSid = joiningUserAuthSid , < nl > senderAuthId = None , < nl > randomId = randomId , < nl > message = GroupServiceMessages . userJoined , < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > index 0fe59d4 . . b405246 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > @ @ - 126 , 6 + 126 , 13 @ @ object HistoryMessageRepo { < nl > . take ( limit ) < nl > } < nl > < nl > + private val byUserIdPeerRidC = Compiled { ( userId : Rep [ Int ] , peerType : Rep [ Int ] , peerId : Rep [ Int ] , randomId : Rep [ Long ] ) ⇒ < nl > + byUserIdPeer ( userId , peerType , peerId ) . filter ( _ . randomId = = = randomId ) < nl > + } < nl > + < nl > + def existstWithRandomId ( userId : Int , peer : Peer , randomId : Long ) : DBIO [ Boolean ] = < nl > + byUserIdPeerRidC . applied ( ( userId , peer . typ . value , peer . id , randomId ) ) . exists . result < nl > + < nl > def findBefore ( userId : Int , peer : Peer , date : DateTime , limit : Long ) = < nl > beforeC ( ( userId , peer . typ . value , peer . id , date , limit ) ) . result < nl > < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > index 6aa905f . . 8ed8f9a 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > @ @ - 19 , 6 + 19 , 7 @ @ object MessagingRpcErors { < nl > val NotLastMessage = RpcError ( 400 , " NOT _ LAST _ MESSAGE " , " You are trying to edit not last message . " , false , None ) < nl > val NotInTimeWindow = RpcError ( 400 , " NOT _ IN _ TIME _ WINDOW " , " You can ' t edit message sent more than 5 minutes age . " , false , None ) < nl > val NotTextMessage = RpcError ( 400 , " NOT _ TEXT _ MESSAGE " , " You can edit only text messages . " , false , None ) < nl > + val NotUniqueRandomId = RpcError ( 400 , " RANDOM _ ID _ NOT _ UNIQUE " , " " , false , None ) < nl > } < nl > < nl > private [ messaging ] trait MessagingHandlers extends PeersImplicits < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala < nl > index 33abb5e . . b05be3b 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala < nl > @ @ - 1 , 10 + 1 , 10 @ @ < nl > package im . actor . server . api . rpc . service . messaging < nl > < nl > import akka . actor . _ < nl > - import im . actor . api . rpc . { RpcError , Error , CommonRpcErrors } < nl > + import im . actor . api . rpc . { CommonRpcErrors , RpcError } < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . dialog . { InvalidAccessHash , DialogErrors , DialogExtension } < nl > + import im . actor . server . dialog . { DialogErrors , DialogExtension , InvalidAccessHash , NotUniqueRandomId } < nl > import im . actor . server . group . { GroupErrors , GroupExtension } < nl > import im . actor . server . social . { SocialExtension , SocialManagerRegion } < nl > import im . actor . server . user . UserExtension < nl > @ @ - 34 , 6 + 34 , 7 @ @ final class MessagingServiceImpl ( implicit protected val actorSystem : ActorSystem < nl > RpcError ( 406 , " DIALOG _ ALREADY _ ARCHIVED " , " Dialog is already archived . " , canTryAgain = false , None ) < nl > case DialogErrors . DialogAlreadyShown ( peer ) ⇒ < nl > RpcError ( 406 , " DIALOG _ ALREADY _ SHOWN " , " Dialog is already shown . " , canTryAgain = false , None ) < nl > + case NotUniqueRandomId ⇒ MessagingRpcErors . NotUniqueRandomId < nl > } < nl > < nl > - } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > index 8b971e7 . . 72dde09 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > @ @ - 14 , 6 + 14 , 7 @ @ import im . actor . api . rpc . sequence . { ApiUpdateContainer , ResponseGetDifference } < nl > import im . actor . server . _ < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > + import im . actor . server . api . rpc . service . messaging . MessagingRpcErors < nl > import im . actor . server . persist . HistoryMessageRepo < nl > import im . actor . server . pubsub . PeerMessage < nl > < nl > @ @ - 48 , 6 + 49 , 8 @ @ class MessagingServiceSpec < nl > < nl > it should " not allow user to edit alien messages " in s . generic . notEditAlienMessage < nl > < nl > + it should " keep randomId unique inside single dialog " in s . generic . uniqueRandomId < nl > + < nl > object s { < nl > implicit val ec = system . dispatcher < nl > < nl > @ @ - 501 , 6 + 504 , 61 @ @ class MessagingServiceSpec < nl > } < nl > } < nl > < nl > + def uniqueRandomId ( ) = { < nl > + val ( alice , aliceAuthId1 , aliceAuthSid1 , _ ) = createUser ( ) < nl > + val ( aliceAuthId2 , aliceAuthSid2 ) = createAuthId ( alice . id ) < nl > + < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + < nl > + val RandomId = 22L < nl > + < nl > + { < nl > + implicit val cd = ClientData ( aliceAuthId1 , 1 , Some ( AuthData ( alice . id , aliceAuthSid1 , 42 ) ) ) < nl > + whenReady ( service . handleSendMessage ( < nl > + getOutPeer ( bob . id , aliceAuthId1 ) , < nl > + RandomId , < nl > + ApiTextMessage ( " Hello from device number one " , Vector . empty , None ) , < nl > + None , < nl > + None < nl > + ) ) { resp ⇒ < nl > + resp should matchPattern { < nl > + case Ok ( _ ) ⇒ < nl > + } < nl > + < nl > + } < nl > + } < nl > + < nl > + { < nl > + implicit val cd = ClientData ( aliceAuthId2 , 1 , Some ( AuthData ( alice . id , aliceAuthSid2 , 42 ) ) ) < nl > + whenReady ( service . handleSendMessage ( < nl > + getOutPeer ( bob . id , aliceAuthId2 ) , < nl > + RandomId , < nl > + ApiTextMessage ( " Hello from second device with same random id " , Vector . empty , None ) , < nl > + None , < nl > + None < nl > + ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( MessagingRpcErors . NotUniqueRandomId ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + { < nl > + implicit val cd = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > + whenReady ( service . handleSendMessage ( < nl > + getOutPeer ( alice . id , bobAuthId ) , < nl > + RandomId , < nl > + ApiTextMessage ( " Hello you back , and same random id again " , Vector . empty , None ) , < nl > + None , < nl > + None < nl > + ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( MessagingRpcErors . NotUniqueRandomId ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > } < nl > < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > index 9beee63 . . fef0e97 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > @ @ - 131 , 13 + 131 , 33 @ @ object HistoryMessageRepo { < nl > . map ( _ . userId ) < nl > . result < nl > < nl > - def findNewest ( userId : Int , peer : Peer ) : SqlAction [ Option [ HistoryMessage ] , NoStream , Read ] = < nl > + def findNewest ( userId : Int , peer : Peer ) : SqlAction [ Option [ HistoryMessage ] , NoStream , Read ] = { < nl > + val filter = { m : HistoryMessageTable ⇒ < nl > + m . userId = = = userId & & < nl > + m . peerType = = = peer . typ . value & & < nl > + m . peerId = = = peer . id < nl > + } < nl > + findNewestFilter ( userId , peer , filter ) < nl > + } < nl > + < nl > + def findNewestSentBy ( userId : Int , peer : Peer ) : SqlAction [ Option [ HistoryMessage ] , NoStream , Read ] = { < nl > + val filter = { m : HistoryMessageTable ⇒ < nl > + m . userId = = = userId & & < nl > + m . senderUserId = = = userId & & < nl > + m . peerType = = = peer . typ . value & & < nl > + m . peerId = = = peer . id < nl > + } < nl > + findNewestFilter ( userId , peer , filter ) < nl > + } < nl > + < nl > + private def findNewestFilter ( userId : Int , peer : Peer , filterClause : HistoryMessageTable ⇒ Rep [ Boolean ] ) = { < nl > notDeletedMessages < nl > - . filter ( m ⇒ m . userId = = = userId & & m . peerType = = = peer . typ . value & & m . peerId = = = peer . id ) < nl > + . filter ( filterClause ) < nl > . sortBy ( _ . date . desc ) < nl > . take ( 1 ) < nl > . result < nl > . headOption < nl > + } < nl > < nl > def find ( userId : Int , peer : Peer ) : FixedSqlStreamingAction [ Seq [ HistoryMessage ] , HistoryMessage , Read ] = < nl > notDeletedMessages < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala < nl > index 6151c91 . . 548d0e3 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala < nl > @ @ - 1 , 51 + 1 , 50 @ @ < nl > package im . actor . api . rpc < nl > < nl > + import akka . actor . _ < nl > import cats . data . Xor < nl > + import im . actor . api . rpc . CommonRpcErrors . InvalidAccessHash < nl > + import im . actor . api . rpc . peers . _ < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . api . rpc . service . groups . GroupRpcErrors < nl > import im . actor . server . db . DbExtension < nl > + import im . actor . server . group . GroupErrors . GroupNotFound < nl > import im . actor . server . model . _ < nl > import im . actor . server . persist . _ < nl > - < nl > - import scala . concurrent . { Future , ExecutionContext } < nl > - < nl > - import akka . actor . _ < nl > + import im . actor . server . user . UserErrors . UserNotFound < nl > + import im . actor . util . misc . StringUtils < nl > import slick . dbio . DBIO < nl > < nl > - import im . actor . api . rpc . peers . _ < nl > - import im . actor . server . api . rpc . service . groups . GroupRpcErrors < nl > - import im . actor . util . misc . StringUtils < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > < nl > object PeerHelpers { < nl > - def withOutPeerF [ R < : RpcResponse ] ( < nl > - outPeer : ApiOutPeer < nl > - ) ( < nl > - f : ⇒ Future [ RpcError Xor R ] < nl > - ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : Future [ RpcError Xor R ] = < nl > - DbExtension ( actorSystem ) . db . run ( withOutPeer ( outPeer ) ( DBIO . from ( f ) ) ) < nl > - < nl > - def withOutPeer [ R < : RpcResponse ] ( < nl > - outPeer : ApiOutPeer < nl > - ) ( < nl > - f : ⇒ DBIO [ RpcError Xor R ] < nl > - ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : DBIO [ RpcError Xor R ] = { < nl > - outPeer . ` type ` match { < nl > - case ApiPeerType . Private ⇒ < nl > - DBIO . from ( ACLUtils . checkOutPeer ( outPeer , client . authId ) ) flatMap { < nl > - case false ⇒ DBIO . successful ( Error ( CommonRpcErrors . InvalidAccessHash ) ) < nl > - case true ⇒ f < nl > - } < nl > - case ApiPeerType . Group ⇒ < nl > - ( for { < nl > - optGroup ← GroupRepo . find ( outPeer . id ) < nl > - grouperrOrGroup ← validGroup ( optGroup ) < nl > - hasherrOrGroup ← DBIO . successful ( grouperrOrGroup . map ( validGroupAccessHash ( outPeer . accessHash , _ ) ) ) < nl > - } yield hasherrOrGroup ) . flatMap { < nl > - case Error ( err ) ⇒ DBIO . successful ( Error ( err ) ) < nl > - case _ ⇒ f < nl > - } < nl > - } < nl > + < nl > + def withOutPeer [ R < : RpcResponse ] ( outPeer : ApiOutPeer ) ( f : ⇒ Future [ RpcError Xor R ] ) ( < nl > + implicit < nl > + client : AuthorizedClientData , < nl > + system : ActorSystem < nl > + ) : Future [ RpcError Xor R ] = { < nl > + import FutureResultRpc . _ < nl > + import system . dispatcher < nl > + val action : Result [ R ] = for { < nl > + valid ← fromFuture ( handleNotFound ) ( ACLUtils . checkOutPeer ( outPeer , client . authId ) ) < nl > + result ← if ( valid ) fromFutureXor ( f ) else fromXor ( Xor . left ( InvalidAccessHash ) ) < nl > + } yield result < nl > + action . value < nl > + } < nl > + < nl > + private def handleNotFound : PartialFunction [ Throwable , RpcError ] = { < nl > + case _ : UserNotFound ⇒ CommonRpcErrors . UserNotFound < nl > + case _ : GroupNotFound ⇒ CommonRpcErrors . GroupNotFound < nl > + case e ⇒ throw e < nl > } < nl > < nl > + def withOutPeerDBIO [ R < : RpcResponse ] ( outPeer : ApiOutPeer ) ( f : ⇒ DBIO [ RpcError Xor R ] ) ( < nl > + implicit < nl > + client : AuthorizedClientData , < nl > + system : ActorSystem < nl > + ) : DBIO [ RpcError Xor R ] = < nl > + DBIO . from ( withOutPeer ( outPeer ) ( DbExtension ( system ) . db . run ( f ) ) ) < nl > + < nl > def withOutPeerAsGroupPeer [ R < : RpcResponse ] ( outPeer : ApiOutPeer ) ( < nl > f : ApiGroupOutPeer ⇒ DBIO [ RpcError Xor R ] < nl > ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : DBIO [ RpcError Xor R ] = { < nl > @ @ - 81 , 15 + 80 , 6 @ @ object PeerHelpers { < nl > } < nl > } < nl > < nl > - def withGroupAdmin [ R < : RpcResponse ] ( groupOutPeer : ApiGroupOutPeer ) ( f : FullGroup ⇒ DBIO [ RpcError Xor R ] ) ( implicit client : AuthorizedClientData , ec : ExecutionContext ) : DBIO [ RpcError Xor R ] = { < nl > - withOwnGroupMember ( groupOutPeer , client . userId ) { group ⇒ < nl > - ( for ( user ← GroupUserRepo . find ( group . id , client . userId ) ) yield user ) . flatMap { < nl > - case Some ( gu ) if gu . isAdmin ⇒ f ( group ) < nl > - case _ ⇒ DBIO . successful ( Error ( CommonRpcErrors . forbidden ( " Only admin can perform this action . " ) ) ) < nl > - } < nl > - } < nl > - } < nl > - < nl > def withValidGroupTitle [ R < : RpcResponse ] ( title : String ) ( f : String ⇒ DBIO [ RpcError Xor R ] ) ( < nl > implicit < nl > client : AuthorizedClientData , < nl > @ @ - 197 , 7 + 187 , 7 @ @ object PeerHelpers { < nl > GroupRepo . findFull ( groupOutPeer . groupId ) flatMap { < nl > case Some ( group ) ⇒ < nl > if ( group . accessHash ! = groupOutPeer . accessHash ) { < nl > - DBIO . successful ( Error ( CommonRpcErrors . InvalidAccessHash ) ) < nl > + DBIO . successful ( Error ( InvalidAccessHash ) ) < nl > } else { < nl > f ( group ) < nl > } < nl > @ @ - 206 , 22 + 196 , 6 @ @ object PeerHelpers { < nl > } < nl > } < nl > < nl > - private def validGroup ( optGroup : Option [ Group ] ) = { < nl > - optGroup match { < nl > - case Some ( group ) ⇒ < nl > - DBIO . successful ( Xor . right ( group ) ) < nl > - case None ⇒ DBIO . successful ( Error ( CommonRpcErrors . GroupNotFound ) ) < nl > - } < nl > - } < nl > - < nl > - private def validGroupAccessHash ( accessHash : Long , group : Group ) ( implicit client : BaseClientData , actorSystem : ActorSystem ) = { < nl > - if ( accessHash = = group . accessHash ) { < nl > - Xor . right ( group ) < nl > - } else { < nl > - Error ( CommonRpcErrors . InvalidAccessHash ) < nl > - } < nl > - } < nl > - < nl > private def renderCheckResult [ R < : RpcResponse ] ( checkOptsActions : Seq [ DBIO [ Option [ Boolean ] ] ] , f : ⇒ DBIO [ RpcError Xor R ] ) ( implicit ec : ExecutionContext ) : DBIO [ RpcError Xor R ] = { < nl > DBIO . sequence ( checkOptsActions ) flatMap { checkOpts ⇒ < nl > if ( checkOpts . contains ( None ) ) { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index 1fa6b44 . . 35cb12e 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 146 , 7 + 146 , 7 @ @ trait HistoryHandlers { < nl > clientData : im . actor . api . rpc . ClientData < nl > ) : Future [ HandlerResult [ ResponseSeq ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > - withOutPeerF ( peer ) { < nl > + withOutPeer ( peer ) { < nl > for ( seqstate ← dialogExt . archive ( client . userId , peer . asModel ) ) < nl > yield Ok ( ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) ) < nl > } < nl > @ @ - 160 , 7 + 160 , 7 @ @ trait HistoryHandlers { < nl > clientData : ClientData < nl > ) : Future [ HandlerResult [ ResponseLoadHistory ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > - val action = withOutPeer ( peer ) { < nl > + val action = withOutPeerDBIO ( peer ) { < nl > val modelPeer = peer . asModel < nl > for { < nl > historyOwner ← DBIO . from ( getHistoryOwner ( modelPeer , client . userId ) ) < nl > @ @ - 199 , 7 + 199 , 7 @ @ trait HistoryHandlers { < nl > < nl > override def doHandleDeleteMessage ( outPeer : ApiOutPeer , randomIds : IndexedSeq [ Long ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > - val action = withOutPeer ( outPeer ) { < nl > + val action = withOutPeerDBIO ( outPeer ) { < nl > val peer = outPeer . asModel < nl > withHistoryOwner ( peer , client . userId ) { historyOwner ⇒ < nl > if ( isSharedUser ( historyOwner ) ) { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala < nl > new file mode 100644 < nl > index 0000000 . . 649b441 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala < nl > @ @ - 0 , 0 + 1 , 8 @ @ < nl > + package im . actor . server . api . rpc . service . messaging < nl > + < nl > + import com . google . protobuf . CodedInputStream < nl > + import im . actor . api . rpc . messaging . ApiMessage < nl > + < nl > + trait MessageParsing { < nl > + def parseMessage ( body : Array [ Byte ] ) : Either [ Any , ApiMessage ] = ApiMessage . parseFrom ( CodedInputStream . newInstance ( body ) ) < nl > + } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > index 6f9073f . . af429e1 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > @ @ - 1 , 23 + 1 , 39 @ @ < nl > package im . actor . server . api . rpc . service . messaging < nl > < nl > - import akka . http . scaladsl . util . FastFuture < nl > import akka . util . Timeout < nl > + import cats . data . Xor < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . misc . _ < nl > import im . actor . api . rpc . peers . _ < nl > import im . actor . config . ActorConfig < nl > + import im . actor . server . model . { PeerType , Peer } < nl > + import im . actor . server . persist . HistoryMessageRepo < nl > + import im . actor . server . sequence . SeqState < nl > < nl > import scala . concurrent . _ < nl > + import scala . concurrent . duration . _ < nl > < nl > - private [ messaging ] trait MessagingHandlers extends PeersImplicits { < nl > + object MessagingRpcErors { < nl > + val NotLastMessage = RpcError ( 400 , " NOT _ LAST _ MESSAGE " , " You are trying to edit not last message . " , false , None ) < nl > + val NotInTimeWindow = RpcError ( 400 , " NOT _ IN _ TIME _ WINDOW " , " You can ' t edit message sent more than 5 minutes age . " , false , None ) < nl > + val NotTextMessage = RpcError ( 400 , " NOT _ TEXT _ MESSAGE " , " You can edit only text messages . " , false , None ) < nl > + val IntenalError = RpcError ( 500 , " INTERNAL _ ERROR " , " " , false , None ) < nl > + } < nl > + < nl > + private [ messaging ] trait MessagingHandlers extends PeersImplicits with MessageParsing { < nl > this : MessagingServiceImpl ⇒ < nl > < nl > import FutureResultRpc . _ < nl > + import MessagingRpcErors . _ < nl > + import PeerHelpers . _ < nl > < nl > override implicit val ec : ExecutionContext = actorSystem . dispatcher < nl > private implicit val timeout : Timeout = ActorConfig . defaultTimeout < nl > < nl > + / / TODO : configurable < nl > + private val editTimeWindow : Long = 5 . minutes . toMillis < nl > + < nl > override def doHandleSendMessage ( outPeer : ApiOutPeer , randomId : Long , message : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > ( for ( < nl > @ @ - 33 , 6 + 49 , 98 @ @ private [ messaging ] trait MessagingHandlers extends PeersImplicits { < nl > ) yield ResponseSeqDate ( s . seq , s . state . toByteArray , s . date ) ) . value < nl > } < nl > < nl > - override def doHandleUpdateMessage ( peer : ApiOutPeer , randomId : Long , updatedMessage : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = < nl > - FastFuture . failed ( new RuntimeException ( " Not implemented " ) ) < nl > + override def doHandleUpdateMessage ( outPeer : ApiOutPeer , randomId : Long , updatedMessage : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = { < nl > + authorized ( clientData ) { implicit client ⇒ < nl > + withOutPeer ( outPeer ) { < nl > + val peer = outPeer . asModel < nl > + ( for { < nl > + histMessage ← fromFutureOption ( CommonRpcErrors . forbidden ( " Not allowed " ) ) ( db . run ( HistoryMessageRepo . findNewestSentBy ( client . userId , peer ) ) ) < nl > + _ ← fromBoolean ( NotLastMessage ) ( histMessage . randomId = = randomId ) < nl > + _ = fromBoolean ( NotInTimeWindow ) ( inTimeWindow ( histMessage . date . getMillis ) ) < nl > + apiMessage ← fromXor ( ( e : Any ) ⇒ IntenalError ) ( Xor . fromEither ( parseMessage ( histMessage . messageContentData ) ) ) < nl > + _ ← fromBoolean ( NotTextMessage ) ( apiMessage match { < nl > + case _ : ApiTextMessage ⇒ true < nl > + case _ ⇒ false < nl > + } ) < nl > + result ← fromFuture ( updateMessageContent ( peer , randomId , updatedMessage ) ) < nl > + date = System . currentTimeMillis < nl > + } yield ResponseSeqDate ( result . seq , result . state . toByteArray , date ) ) . value < nl > + } < nl > + } < nl > + } < nl > + < nl > + private def inTimeWindow ( messageDateMillis : Long ) : Boolean = { < nl > + ( messageDateMillis + editTimeWindow ) > System . currentTimeMillis < nl > + } < nl > + < nl > + / / TODO : move to trait and reuse < nl > + private def updateMessageContent ( peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit client : AuthorizedClientData ) : Future [ SeqState ] = peer match { < nl > + case Peer ( PeerType . Private , _ ) ⇒ updateContentPrivate ( client . userId , peer , randomId , updatedMessage ) < nl > + case Peer ( PeerType . Group , _ ) ⇒ updateContentGroup ( client . userId , peer , randomId , updatedMessage ) < nl > + } < nl > + < nl > + private def updateContentPrivate ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) : Future [ SeqState ] = { < nl > + for { < nl > + / / update for client himself < nl > + seqState ← userExt . broadcastUserUpdate ( < nl > + userId = userId , < nl > + update = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) , < nl > + pushText = None , < nl > + isFat = false , < nl > + reduceKey = None , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + / / update for peer user < nl > + _ ← userExt . broadcastUserUpdate ( < nl > + userId = peer . id , < nl > + update = UpdateMessageContentChanged ( ApiPeer ( ApiPeerType . Private , userId ) , randomId , updatedMessage ) , < nl > + pushText = None , < nl > + isFat = false , < nl > + reduceKey = None , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > + userIds = Set ( userId , peer . id ) , < nl > + randomId = randomId , < nl > + peerType = PeerType . Private , < nl > + peerIds = Set ( userId , peer . id ) , < nl > + messageContentHeader = updatedMessage . header , < nl > + messageContentData = updatedMessage . toByteArray < nl > + ) ) < nl > + } yield seqState < nl > + } < nl > + < nl > + private def updateContentGroup ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) : Future [ SeqState ] = { < nl > + val upd = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) < nl > + for { < nl > + / / update for client user < nl > + seqState ← userExt . broadcastUserUpdate ( < nl > + userId = userId , < nl > + update = upd , < nl > + pushText = None , < nl > + isFat = false , < nl > + reduceKey = None , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + ( memberIds , _ , _ ) ← groupExt . getMemberIds ( peer . id ) < nl > + membersSet = memberIds . toSet < nl > + / / update for other group members < nl > + _ ← userExt . broadcastUsersUpdate ( < nl > + userIds = membersSet - userId , < nl > + update = upd , < nl > + pushText = None , < nl > + isFat = false , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > + userIds = membersSet , < nl > + randomId = randomId , < nl > + peerType = PeerType . Group , < nl > + peerIds = Set ( peer . id ) , < nl > + messageContentHeader = updatedMessage . header , < nl > + messageContentData = updatedMessage . toByteArray < nl > + ) ) < nl > + } yield seqState < nl > + } < nl > + < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > index 8130563 . . f0c275d 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > @ @ - 37 , 7 + 37 , 7 @ @ final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : Sessi < nl > < nl > override def doHandleDoCall ( peer : ApiOutPeer , timeout : Option [ Long ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > - withOutPeerF ( peer ) { < nl > + withOutPeer ( peer ) { < nl > for { < nl > ( callId , eventBusId , callerDeviceId ) ← webrtcExt . doCall ( client . userId , client . authId , peer . asModel , timeout ) < nl > } yield Ok ( ResponseDoCall ( callId , eventBusId , callerDeviceId ) ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecMatchers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecMatchers . scala < nl > index 7b18557 . . 50efffa 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecMatchers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecMatchers . scala < nl > @ @ - 6 , 7 + 6 , 7 @ @ import org . scalatest . Matchers < nl > import org . scalatest . matchers . Matcher < nl > < nl > trait ServiceSpecMatchers extends Matchers { < nl > - def matchNotAuthorized [ T ] : Matcher [ RpcError Xor T ] = matchPattern { < nl > + def matchForbidden [ T ] : Matcher [ RpcError Xor T ] = matchPattern { < nl > case Xor . Left ( RpcError ( 403 , " FORBIDDEN " , _ , _ , _ ) ) ⇒ < nl > } < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > index e66ec98 . . 2ebb865 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > @ @ - 355 , 7 + 355 , 7 @ @ final class GroupsServiceSpec < nl > { < nl > implicit val clientData = ClientData ( authId2 , sessionId , Some ( AuthData ( user2 . id , authSid2 ) ) ) < nl > whenReady ( service . handleGetGroupInviteUrl ( groupOutPeer ) ) { resp ⇒ < nl > - resp should matchNotAuthorized < nl > + resp should matchForbidden < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala < nl > index ec2dfe9 . . 534dfde 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala < nl > @ @ - 59 , 7 + 59 , 7 @ @ final class IntegrationsServiceSpec < nl > val groupOutPeer = createGroup ( " Fun group " , Set . empty ) . groupPeer < nl > ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) < nl > } < nl > - whenReady ( service . handleGetIntegrationToken ( outPeer ) ( clientData2 ) ) ( _ should matchNotAuthorized ) < nl > + whenReady ( service . handleGetIntegrationToken ( outPeer ) ( clientData2 ) ) ( _ should matchForbidden ) < nl > } < nl > < nl > def e2 ( ) : Unit = { < nl > @ @ - 87 , 7 + 87 , 7 @ @ final class IntegrationsServiceSpec < nl > } < nl > < nl > whenReady ( service . handleRevokeIntegrationToken ( outPeer ) ( clientData2 ) ) { resp ⇒ < nl > - resp should matchNotAuthorized < nl > + resp should matchForbidden < nl > } < nl > < nl > whenReady ( service . handleGetIntegrationToken ( outPeer ) ( clientData2 ) ) { resp ⇒ < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > index 64add45 . . a9d8e9a 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > @ @ - 2 , 6 + 2 , 7 @ @ package im . actor . server . api . rpc . service < nl > < nl > import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } < nl > import akka . testkit . TestProbe < nl > + import cats . data . Xor < nl > import im . actor . api . rpc . Implicits . _ < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . counters . UpdateCountersChanged < nl > @ @ - 13 , 6 + 14 , 7 @ @ import im . actor . api . rpc . sequence . { ApiUpdateContainer , ResponseGetDifference } < nl > import im . actor . server . _ < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > + import im . actor . server . persist . HistoryMessageRepo < nl > import im . actor . server . pubsub . PeerMessage < nl > < nl > import scala . concurrent . Future < nl > @ @ - 42 , 6 + 44 , 10 @ @ class MessagingServiceSpec < nl > < nl > " Any Messaging " should " keep original order of sent messages " in s . generic . rightOrder < nl > < nl > + it should " allow user to edit own message " in s . generic . editOwnMessage < nl > + < nl > + it should " not allow user to edit alien messages " in s . generic . notEditAlienMessage < nl > + < nl > object s { < nl > implicit val ec = system . dispatcher < nl > < nl > @ @ - 211 , 31 + 217 , 31 @ @ class MessagingServiceSpec < nl > val alienClientData = ClientData ( user1AuthId1 , sessionId , Some ( AuthData ( alien . id , authSidAlien ) ) ) < nl > < nl > whenReady ( service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi again " , Vector . empty , None ) ) ( alienClientData ) ) { resp ⇒ < nl > - resp should matchNotAuthorized < nl > + resp should matchForbidden < nl > } < nl > < nl > whenReady ( groupsService . handleEditGroupTitle ( groupOutPeer , 4L , " Loosers " ) ( alienClientData ) ) { resp ⇒ < nl > - resp should matchNotAuthorized < nl > + resp should matchForbidden < nl > } < nl > < nl > val ( user3 , authId3 , _ , _ ) = createUser ( ) < nl > val user3OutPeer = ApiUserOutPeer ( user3 . id , 11 ) < nl > < nl > whenReady ( groupsService . handleInviteUser ( groupOutPeer , 4L , user3OutPeer ) ( alienClientData ) ) { resp ⇒ < nl > - resp should matchNotAuthorized < nl > + resp should matchForbidden < nl > } < nl > < nl > val fileLocation = ApiFileLocation ( 1L , 1L ) < nl > whenReady ( groupsService . handleEditGroupAvatar ( groupOutPeer , 5L , fileLocation ) ( alienClientData ) ) { resp ⇒ < nl > - resp should matchNotAuthorized < nl > + resp should matchForbidden < nl > } < nl > < nl > whenReady ( groupsService . handleRemoveGroupAvatar ( groupOutPeer , 5L ) ( alienClientData ) ) { resp ⇒ < nl > - resp should matchNotAuthorized < nl > + resp should matchForbidden < nl > } < nl > < nl > whenReady ( groupsService . handleLeaveGroup ( groupOutPeer , 5L ) ( alienClientData ) ) { resp ⇒ < nl > - resp should matchNotAuthorized < nl > + resp should matchForbidden < nl > } < nl > < nl > } < nl > @ @ - 386 , 6 + 392 , 115 @ @ class MessagingServiceSpec < nl > < nl > } < nl > < nl > + def notEditAlienMessage ( ) = { < nl > + val sessionId = createSessionId ( ) < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + < nl > + val aliceCD = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobCD = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > + < nl > + val alicePeer = ApiPeer ( ApiPeerType . Private , alice . id ) < nl > + val bobPeer = ApiPeer ( ApiPeerType . Private , bob . id ) < nl > + < nl > + val aliceOutPeer = whenReady ( ACLUtils . getOutPeer ( alicePeer , bobAuthId ) ) ( identity ) < nl > + val bobOutPeer = whenReady ( ACLUtils . getOutPeer ( bobPeer , aliceAuthId ) ) ( identity ) < nl > + < nl > + val messRandomId = { < nl > + implicit val cd = aliceCD < nl > + sendMessageToUser ( bob . id , ApiTextMessage ( " hello bob " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val cd = bobCD < nl > + whenReady ( service . handleUpdateMessage ( aliceOutPeer , messRandomId , ApiTextMessage ( " XXXXXXXXX " , Vector . empty , None ) ) ) { resp ⇒ < nl > + resp should matchForbidden < nl > + } < nl > + expectNoUpdate ( 0 , classOf [ UpdateMessageContentChanged ] ) < nl > + } < nl > + < nl > + { < nl > + implicit val cd = aliceCD < nl > + expectNoUpdate ( 0 , classOf [ UpdateMessageContentChanged ] ) < nl > + } < nl > + < nl > + val messages = for { < nl > + a ← HistoryMessageRepo . findNewest ( alice . id , bobPeer . asModel ) < nl > + b ← HistoryMessageRepo . findNewest ( bob . id , alicePeer . asModel ) < nl > + } yield List ( a , b ) . flatten < nl > + < nl > + whenReady ( db . run ( messages ) ) { messages ⇒ < nl > + messages should have length 2 < nl > + messages foreach { mess ⇒ < nl > + inside ( parseMessage ( mess . messageContentData ) ) { < nl > + case Right ( ApiTextMessage ( " hello bob " , _ , _ ) ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + def editOwnMessage ( ) = { < nl > + val sessionId = createSessionId ( ) < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + < nl > + val aliceCD = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobCD = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > + < nl > + val alicePeer = ApiPeer ( ApiPeerType . Private , alice . id ) < nl > + val bobPeer = ApiPeer ( ApiPeerType . Private , bob . id ) < nl > + < nl > + val aliceOutPeer = whenReady ( ACLUtils . getOutPeer ( alicePeer , bobAuthId ) ) ( identity ) < nl > + val bobOutPeer = whenReady ( ACLUtils . getOutPeer ( bobPeer , aliceAuthId ) ) ( identity ) < nl > + < nl > + val messRandomId = { < nl > + implicit val cd = aliceCD < nl > + sendMessageToUser ( bob . id , ApiTextMessage ( " hello bob " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val cd = aliceCD < nl > + whenReady ( service . handleUpdateMessage ( bobOutPeer , messRandomId , ApiTextMessage ( " XXXXXXXXX " , Vector . empty , None ) ) ) { resp ⇒ < nl > + resp should matchPattern { < nl > + case Xor . Right ( ResponseSeqDate ( _ , _ , _ ) ) ⇒ < nl > + } < nl > + / / resp . toOption . get . seq < nl > + } < nl > + expectUpdate ( classOf [ UpdateMessageContentChanged ] ) { upd ⇒ < nl > + upd . randomId shouldEqual messRandomId < nl > + upd . peer shouldEqual bobPeer < nl > + inside ( parseMessage ( upd . message . toByteArray ) ) { < nl > + case Right ( ApiTextMessage ( " XXXXXXXXX " , _ , _ ) ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + { < nl > + implicit val cd = bobCD < nl > + expectUpdate ( classOf [ UpdateMessageContentChanged ] ) { upd ⇒ < nl > + upd . randomId shouldEqual messRandomId < nl > + upd . peer shouldEqual alicePeer < nl > + inside ( parseMessage ( upd . message . toByteArray ) ) { < nl > + case Right ( ApiTextMessage ( " XXXXXXXXX " , _ , _ ) ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + val messages = for { < nl > + a ← HistoryMessageRepo . findNewest ( alice . id , bobPeer . asModel ) < nl > + b ← HistoryMessageRepo . findNewest ( bob . id , alicePeer . asModel ) < nl > + } yield List ( a , b ) . flatten < nl > + < nl > + whenReady ( db . run ( messages ) ) { messages ⇒ < nl > + messages should have length 2 < nl > + messages foreach { mess ⇒ < nl > + inside ( parseMessage ( mess . messageContentData ) ) { < nl > + case Right ( ApiTextMessage ( " XXXXXXXXX " , _ , _ ) ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > } < nl > < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index b74fdcc . . 32e6416 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 29 , 48 + 29 , 54 @ @ object HistoryUtils { 
 requirePrivatePeer ( fromPeer ) 
 / / requireDifferentPeers ( fromPeer , toPeer ) 
 
 - if ( toPeer . typ = = PeerType . Private ) { 
 - val outMessage = HistoryMessage ( 
 - userId = fromPeer . id , 
 - peer = toPeer , 
 - date = date , 
 - senderUserId = fromPeer . id , 
 - randomId = randomId , 
 - messageContentHeader = messageContentHeader , 
 - messageContentData = messageContentData , 
 - deletedAt = None 
 - ) 
 - 
 - val messages = 
 - if ( fromPeer ! = toPeer ) { 
 - Seq ( 
 - outMessage , 
 - outMessage . copy ( userId = toPeer . id , peer = fromPeer ) 
 + HistoryMessageRepo . existstWithRandomId ( fromPeer . id , toPeer , randomId ) flatMap { exists ⇒ 
 + if ( exists ) { 
 + DBIO . failed ( NotUniqueRandomId ) 
 + } else { 
 + if ( toPeer . typ = = PeerType . Private ) { 
 + val outMessage = HistoryMessage ( 
 + userId = fromPeer . id , 
 + peer = toPeer , 
 + date = date , 
 + senderUserId = fromPeer . id , 
 + randomId = randomId , 
 + messageContentHeader = messageContentHeader , 
 + messageContentData = messageContentData , 
 + deletedAt = None 
 ) 
 - } else { 
 - Seq ( outMessage ) 
 - } 
 
 - for { 
 - _ ← HistoryMessageRepo . create ( messages ) 
 - } yield ( ) 
 - } else if ( toPeer . typ = = PeerType . Group ) { 
 - for { 
 - isHistoryShared ← DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) 
 - _ ← if ( isHistoryShared ) { 
 - val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 - HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) 
 - } else { 
 - DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ 
 - val historyMessages = groupUserIds . map { groupUserId ⇒ 
 - HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 + val messages = 
 + if ( fromPeer ! = toPeer ) { 
 + Seq ( 
 + outMessage , 
 + outMessage . copy ( userId = toPeer . id , peer = fromPeer ) 
 + ) 
 + } else { 
 + Seq ( outMessage ) 
 } 
 - HistoryMessageRepo . create ( historyMessages ) map ( _ ⇒ ( ) ) 
 - } 
 + 
 + for { 
 + _ ← HistoryMessageRepo . create ( messages ) 
 + } yield ( ) 
 + } else if ( toPeer . typ = = PeerType . Group ) { 
 + for { 
 + isHistoryShared ← DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) 
 + _ ← if ( isHistoryShared ) { 
 + val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 + HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) 
 + } else { 
 + DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ 
 + val historyMessages = groupUserIds . map { groupUserId ⇒ 
 + HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 + } 
 + HistoryMessageRepo . create ( historyMessages ) map ( _ ⇒ ( ) ) 
 + } 
 + } 
 + } yield ( ) 
 + } else { 
 + DBIO . failed ( new Exception ( " PeerType is not supported " ) with NoStackTrace ) 
 } 
 - } yield ( ) 
 - } else { 
 - DBIO . failed ( new Exception ( " PeerType is not supported " ) with NoStackTrace ) 
 + } 
 } 
 } 
 
 @ @ - 84 , 16 + 90 , 21 @ @ object HistoryUtils { 
 messageContentData : Array [ Byte ] 
 ) ( implicit ec : ExecutionContext ) : DBIO [ Unit ] = { 
 for { 
 - _ ← HistoryMessageRepo . create ( HistoryMessage ( 
 - userId = userId , 
 - peer = toPeer , 
 - date = date , 
 - senderUserId = senderUserId , 
 - randomId = randomId , 
 - messageContentHeader = messageContentHeader , 
 - messageContentData = messageContentData , 
 - deletedAt = None 
 - ) ) 
 + exists ← HistoryMessageRepo . existstWithRandomId ( userId , toPeer , randomId ) 
 + _ ← if ( exists ) { 
 + DBIO . failed ( NotUniqueRandomId ) 
 + } else { 
 + HistoryMessageRepo . create ( HistoryMessage ( 
 + userId = userId , 
 + peer = toPeer , 
 + date = date , 
 + senderUserId = senderUserId , 
 + randomId = randomId , 
 + messageContentHeader = messageContentHeader , 
 + messageContentData = messageContentData , 
 + deletedAt = None 
 + ) ) 
 + } 
 } yield ( ) 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / package . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / package . scala 
 index d3c7018 . . 17d0023 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / package . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / package . scala 
 @ @ - 4 , 10 + 4 , 5 @ @ import scala . util . control . NoStackTrace 
 
 package object dialog { 
 type AuthSidRandomId = ( Int , Long ) 
 - 
 - case object ReceiveFailed extends Exception with NoStackTrace 
 - 
 - case object ReadFailed extends Exception with NoStackTrace 
 - 
 - private [ dialog ] case object StopDialog 
 + case object NotUniqueRandomId extends RuntimeException with NoStackTrace 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index b94a3f2 . . edccab9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 180 , 7 + 180 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 } 
 } 
 
 - protected def setJoined ( group : GroupState , joiningUserId : Int , joinintUserAuthSid : Int , invitingUserId : Int ) : Unit = { 
 + protected def setJoined ( group : GroupState , joiningUserId : Int , joiningUserAuthSid : Int , invitingUserId : Int ) : Unit = { 
 if ( ! hasMember ( group , joiningUserId ) | | isInvited ( group , joiningUserId ) ) { 
 val replyTo = sender ( ) 
 
 @ @ - 200 , 7 + 200 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 seqstatedate ← DBIO . from ( DialogExtension ( system ) . sendMessage ( 
 peer = ApiPeer ( ApiPeerType . Group , groupId ) , 
 senderUserId = joiningUserId , 
 - senderAuthSid = joinintUserAuthSid , 
 + senderAuthSid = joiningUserAuthSid , 
 senderAuthId = None , 
 randomId = randomId , 
 message = GroupServiceMessages . userJoined , 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 index 0fe59d4 . . b405246 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 @ @ - 126 , 6 + 126 , 13 @ @ object HistoryMessageRepo { 
 . take ( limit ) 
 } 
 
 + private val byUserIdPeerRidC = Compiled { ( userId : Rep [ Int ] , peerType : Rep [ Int ] , peerId : Rep [ Int ] , randomId : Rep [ Long ] ) ⇒ 
 + byUserIdPeer ( userId , peerType , peerId ) . filter ( _ . randomId = = = randomId ) 
 + } 
 + 
 + def existstWithRandomId ( userId : Int , peer : Peer , randomId : Long ) : DBIO [ Boolean ] = 
 + byUserIdPeerRidC . applied ( ( userId , peer . typ . value , peer . id , randomId ) ) . exists . result 
 + 
 def findBefore ( userId : Int , peer : Peer , date : DateTime , limit : Long ) = 
 beforeC ( ( userId , peer . typ . value , peer . id , date , limit ) ) . result 
 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 index 6aa905f . . 8ed8f9a 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 @ @ - 19 , 6 + 19 , 7 @ @ object MessagingRpcErors { 
 val NotLastMessage = RpcError ( 400 , " NOT _ LAST _ MESSAGE " , " You are trying to edit not last message . " , false , None ) 
 val NotInTimeWindow = RpcError ( 400 , " NOT _ IN _ TIME _ WINDOW " , " You can ' t edit message sent more than 5 minutes age . " , false , None ) 
 val NotTextMessage = RpcError ( 400 , " NOT _ TEXT _ MESSAGE " , " You can edit only text messages . " , false , None ) 
 + val NotUniqueRandomId = RpcError ( 400 , " RANDOM _ ID _ NOT _ UNIQUE " , " " , false , None ) 
 } 
 
 private [ messaging ] trait MessagingHandlers extends PeersImplicits 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala 
 index 33abb5e . . b05be3b 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala 
 @ @ - 1 , 10 + 1 , 10 @ @ 
 package im . actor . server . api . rpc . service . messaging 
 
 import akka . actor . _ 
 - import im . actor . api . rpc . { RpcError , Error , CommonRpcErrors } 
 + import im . actor . api . rpc . { CommonRpcErrors , RpcError } 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . dialog . { InvalidAccessHash , DialogErrors , DialogExtension } 
 + import im . actor . server . dialog . { DialogErrors , DialogExtension , InvalidAccessHash , NotUniqueRandomId } 
 import im . actor . server . group . { GroupErrors , GroupExtension } 
 import im . actor . server . social . { SocialExtension , SocialManagerRegion } 
 import im . actor . server . user . UserExtension 
 @ @ - 34 , 6 + 34 , 7 @ @ final class MessagingServiceImpl ( implicit protected val actorSystem : ActorSystem 
 RpcError ( 406 , " DIALOG _ ALREADY _ ARCHIVED " , " Dialog is already archived . " , canTryAgain = false , None ) 
 case DialogErrors . DialogAlreadyShown ( peer ) ⇒ 
 RpcError ( 406 , " DIALOG _ ALREADY _ SHOWN " , " Dialog is already shown . " , canTryAgain = false , None ) 
 + case NotUniqueRandomId ⇒ MessagingRpcErors . NotUniqueRandomId 
 } 
 
 - } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 index 8b971e7 . . 72dde09 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 @ @ - 14 , 6 + 14 , 7 @ @ import im . actor . api . rpc . sequence . { ApiUpdateContainer , ResponseGetDifference } 
 import im . actor . server . _ 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 + import im . actor . server . api . rpc . service . messaging . MessagingRpcErors 
 import im . actor . server . persist . HistoryMessageRepo 
 import im . actor . server . pubsub . PeerMessage 
 
 @ @ - 48 , 6 + 49 , 8 @ @ class MessagingServiceSpec 
 
 it should " not allow user to edit alien messages " in s . generic . notEditAlienMessage 
 
 + it should " keep randomId unique inside single dialog " in s . generic . uniqueRandomId 
 + 
 object s { 
 implicit val ec = system . dispatcher 
 
 @ @ - 501 , 6 + 504 , 61 @ @ class MessagingServiceSpec 
 } 
 } 
 
 + def uniqueRandomId ( ) = { 
 + val ( alice , aliceAuthId1 , aliceAuthSid1 , _ ) = createUser ( ) 
 + val ( aliceAuthId2 , aliceAuthSid2 ) = createAuthId ( alice . id ) 
 + 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + 
 + val RandomId = 22L 
 + 
 + { 
 + implicit val cd = ClientData ( aliceAuthId1 , 1 , Some ( AuthData ( alice . id , aliceAuthSid1 , 42 ) ) ) 
 + whenReady ( service . handleSendMessage ( 
 + getOutPeer ( bob . id , aliceAuthId1 ) , 
 + RandomId , 
 + ApiTextMessage ( " Hello from device number one " , Vector . empty , None ) , 
 + None , 
 + None 
 + ) ) { resp ⇒ 
 + resp should matchPattern { 
 + case Ok ( _ ) ⇒ 
 + } 
 + 
 + } 
 + } 
 + 
 + { 
 + implicit val cd = ClientData ( aliceAuthId2 , 1 , Some ( AuthData ( alice . id , aliceAuthSid2 , 42 ) ) ) 
 + whenReady ( service . handleSendMessage ( 
 + getOutPeer ( bob . id , aliceAuthId2 ) , 
 + RandomId , 
 + ApiTextMessage ( " Hello from second device with same random id " , Vector . empty , None ) , 
 + None , 
 + None 
 + ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( MessagingRpcErors . NotUniqueRandomId ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + { 
 + implicit val cd = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 + whenReady ( service . handleSendMessage ( 
 + getOutPeer ( alice . id , bobAuthId ) , 
 + RandomId , 
 + ApiTextMessage ( " Hello you back , and same random id again " , Vector . empty , None ) , 
 + None , 
 + None 
 + ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( MessagingRpcErors . NotUniqueRandomId ) ⇒ 
 + } 
 + } 
 + } 
 + } 
 + 
 } 
 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 index 9beee63 . . fef0e97 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 @ @ - 131 , 13 + 131 , 33 @ @ object HistoryMessageRepo { 
 . map ( _ . userId ) 
 . result 
 
 - def findNewest ( userId : Int , peer : Peer ) : SqlAction [ Option [ HistoryMessage ] , NoStream , Read ] = 
 + def findNewest ( userId : Int , peer : Peer ) : SqlAction [ Option [ HistoryMessage ] , NoStream , Read ] = { 
 + val filter = { m : HistoryMessageTable ⇒ 
 + m . userId = = = userId & & 
 + m . peerType = = = peer . typ . value & & 
 + m . peerId = = = peer . id 
 + } 
 + findNewestFilter ( userId , peer , filter ) 
 + } 
 + 
 + def findNewestSentBy ( userId : Int , peer : Peer ) : SqlAction [ Option [ HistoryMessage ] , NoStream , Read ] = { 
 + val filter = { m : HistoryMessageTable ⇒ 
 + m . userId = = = userId & & 
 + m . senderUserId = = = userId & & 
 + m . peerType = = = peer . typ . value & & 
 + m . peerId = = = peer . id 
 + } 
 + findNewestFilter ( userId , peer , filter ) 
 + } 
 + 
 + private def findNewestFilter ( userId : Int , peer : Peer , filterClause : HistoryMessageTable ⇒ Rep [ Boolean ] ) = { 
 notDeletedMessages 
 - . filter ( m ⇒ m . userId = = = userId & & m . peerType = = = peer . typ . value & & m . peerId = = = peer . id ) 
 + . filter ( filterClause ) 
 . sortBy ( _ . date . desc ) 
 . take ( 1 ) 
 . result 
 . headOption 
 + } 
 
 def find ( userId : Int , peer : Peer ) : FixedSqlStreamingAction [ Seq [ HistoryMessage ] , HistoryMessage , Read ] = 
 notDeletedMessages 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala 
 index 6151c91 . . 548d0e3 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala 
 @ @ - 1 , 51 + 1 , 50 @ @ 
 package im . actor . api . rpc 
 
 + import akka . actor . _ 
 import cats . data . Xor 
 + import im . actor . api . rpc . CommonRpcErrors . InvalidAccessHash 
 + import im . actor . api . rpc . peers . _ 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . api . rpc . service . groups . GroupRpcErrors 
 import im . actor . server . db . DbExtension 
 + import im . actor . server . group . GroupErrors . GroupNotFound 
 import im . actor . server . model . _ 
 import im . actor . server . persist . _ 
 - 
 - import scala . concurrent . { Future , ExecutionContext } 
 - 
 - import akka . actor . _ 
 + import im . actor . server . user . UserErrors . UserNotFound 
 + import im . actor . util . misc . StringUtils 
 import slick . dbio . DBIO 
 
 - import im . actor . api . rpc . peers . _ 
 - import im . actor . server . api . rpc . service . groups . GroupRpcErrors 
 - import im . actor . util . misc . StringUtils 
 + import scala . concurrent . { ExecutionContext , Future } 
 
 object PeerHelpers { 
 - def withOutPeerF [ R < : RpcResponse ] ( 
 - outPeer : ApiOutPeer 
 - ) ( 
 - f : ⇒ Future [ RpcError Xor R ] 
 - ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : Future [ RpcError Xor R ] = 
 - DbExtension ( actorSystem ) . db . run ( withOutPeer ( outPeer ) ( DBIO . from ( f ) ) ) 
 - 
 - def withOutPeer [ R < : RpcResponse ] ( 
 - outPeer : ApiOutPeer 
 - ) ( 
 - f : ⇒ DBIO [ RpcError Xor R ] 
 - ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : DBIO [ RpcError Xor R ] = { 
 - outPeer . ` type ` match { 
 - case ApiPeerType . Private ⇒ 
 - DBIO . from ( ACLUtils . checkOutPeer ( outPeer , client . authId ) ) flatMap { 
 - case false ⇒ DBIO . successful ( Error ( CommonRpcErrors . InvalidAccessHash ) ) 
 - case true ⇒ f 
 - } 
 - case ApiPeerType . Group ⇒ 
 - ( for { 
 - optGroup ← GroupRepo . find ( outPeer . id ) 
 - grouperrOrGroup ← validGroup ( optGroup ) 
 - hasherrOrGroup ← DBIO . successful ( grouperrOrGroup . map ( validGroupAccessHash ( outPeer . accessHash , _ ) ) ) 
 - } yield hasherrOrGroup ) . flatMap { 
 - case Error ( err ) ⇒ DBIO . successful ( Error ( err ) ) 
 - case _ ⇒ f 
 - } 
 - } 
 + 
 + def withOutPeer [ R < : RpcResponse ] ( outPeer : ApiOutPeer ) ( f : ⇒ Future [ RpcError Xor R ] ) ( 
 + implicit 
 + client : AuthorizedClientData , 
 + system : ActorSystem 
 + ) : Future [ RpcError Xor R ] = { 
 + import FutureResultRpc . _ 
 + import system . dispatcher 
 + val action : Result [ R ] = for { 
 + valid ← fromFuture ( handleNotFound ) ( ACLUtils . checkOutPeer ( outPeer , client . authId ) ) 
 + result ← if ( valid ) fromFutureXor ( f ) else fromXor ( Xor . left ( InvalidAccessHash ) ) 
 + } yield result 
 + action . value 
 + } 
 + 
 + private def handleNotFound : PartialFunction [ Throwable , RpcError ] = { 
 + case _ : UserNotFound ⇒ CommonRpcErrors . UserNotFound 
 + case _ : GroupNotFound ⇒ CommonRpcErrors . GroupNotFound 
 + case e ⇒ throw e 
 } 
 
 + def withOutPeerDBIO [ R < : RpcResponse ] ( outPeer : ApiOutPeer ) ( f : ⇒ DBIO [ RpcError Xor R ] ) ( 
 + implicit 
 + client : AuthorizedClientData , 
 + system : ActorSystem 
 + ) : DBIO [ RpcError Xor R ] = 
 + DBIO . from ( withOutPeer ( outPeer ) ( DbExtension ( system ) . db . run ( f ) ) ) 
 + 
 def withOutPeerAsGroupPeer [ R < : RpcResponse ] ( outPeer : ApiOutPeer ) ( 
 f : ApiGroupOutPeer ⇒ DBIO [ RpcError Xor R ] 
 ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : DBIO [ RpcError Xor R ] = { 
 @ @ - 81 , 15 + 80 , 6 @ @ object PeerHelpers { 
 } 
 } 
 
 - def withGroupAdmin [ R < : RpcResponse ] ( groupOutPeer : ApiGroupOutPeer ) ( f : FullGroup ⇒ DBIO [ RpcError Xor R ] ) ( implicit client : AuthorizedClientData , ec : ExecutionContext ) : DBIO [ RpcError Xor R ] = { 
 - withOwnGroupMember ( groupOutPeer , client . userId ) { group ⇒ 
 - ( for ( user ← GroupUserRepo . find ( group . id , client . userId ) ) yield user ) . flatMap { 
 - case Some ( gu ) if gu . isAdmin ⇒ f ( group ) 
 - case _ ⇒ DBIO . successful ( Error ( CommonRpcErrors . forbidden ( " Only admin can perform this action . " ) ) ) 
 - } 
 - } 
 - } 
 - 
 def withValidGroupTitle [ R < : RpcResponse ] ( title : String ) ( f : String ⇒ DBIO [ RpcError Xor R ] ) ( 
 implicit 
 client : AuthorizedClientData , 
 @ @ - 197 , 7 + 187 , 7 @ @ object PeerHelpers { 
 GroupRepo . findFull ( groupOutPeer . groupId ) flatMap { 
 case Some ( group ) ⇒ 
 if ( group . accessHash ! = groupOutPeer . accessHash ) { 
 - DBIO . successful ( Error ( CommonRpcErrors . InvalidAccessHash ) ) 
 + DBIO . successful ( Error ( InvalidAccessHash ) ) 
 } else { 
 f ( group ) 
 } 
 @ @ - 206 , 22 + 196 , 6 @ @ object PeerHelpers { 
 } 
 } 
 
 - private def validGroup ( optGroup : Option [ Group ] ) = { 
 - optGroup match { 
 - case Some ( group ) ⇒ 
 - DBIO . successful ( Xor . right ( group ) ) 
 - case None ⇒ DBIO . successful ( Error ( CommonRpcErrors . GroupNotFound ) ) 
 - } 
 - } 
 - 
 - private def validGroupAccessHash ( accessHash : Long , group : Group ) ( implicit client : BaseClientData , actorSystem : ActorSystem ) = { 
 - if ( accessHash = = group . accessHash ) { 
 - Xor . right ( group ) 
 - } else { 
 - Error ( CommonRpcErrors . InvalidAccessHash ) 
 - } 
 - } 
 - 
 private def renderCheckResult [ R < : RpcResponse ] ( checkOptsActions : Seq [ DBIO [ Option [ Boolean ] ] ] , f : ⇒ DBIO [ RpcError Xor R ] ) ( implicit ec : ExecutionContext ) : DBIO [ RpcError Xor R ] = { 
 DBIO . sequence ( checkOptsActions ) flatMap { checkOpts ⇒ 
 if ( checkOpts . contains ( None ) ) { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index 1fa6b44 . . 35cb12e 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 146 , 7 + 146 , 7 @ @ trait HistoryHandlers { 
 clientData : im . actor . api . rpc . ClientData 
 ) : Future [ HandlerResult [ ResponseSeq ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 - withOutPeerF ( peer ) { 
 + withOutPeer ( peer ) { 
 for ( seqstate ← dialogExt . archive ( client . userId , peer . asModel ) ) 
 yield Ok ( ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) ) 
 } 
 @ @ - 160 , 7 + 160 , 7 @ @ trait HistoryHandlers { 
 clientData : ClientData 
 ) : Future [ HandlerResult [ ResponseLoadHistory ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 - val action = withOutPeer ( peer ) { 
 + val action = withOutPeerDBIO ( peer ) { 
 val modelPeer = peer . asModel 
 for { 
 historyOwner ← DBIO . from ( getHistoryOwner ( modelPeer , client . userId ) ) 
 @ @ - 199 , 7 + 199 , 7 @ @ trait HistoryHandlers { 
 
 override def doHandleDeleteMessage ( outPeer : ApiOutPeer , randomIds : IndexedSeq [ Long ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 - val action = withOutPeer ( outPeer ) { 
 + val action = withOutPeerDBIO ( outPeer ) { 
 val peer = outPeer . asModel 
 withHistoryOwner ( peer , client . userId ) { historyOwner ⇒ 
 if ( isSharedUser ( historyOwner ) ) { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala 
 new file mode 100644 
 index 0000000 . . 649b441 
 - - - / dev / null 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala 
 @ @ - 0 , 0 + 1 , 8 @ @ 
 + package im . actor . server . api . rpc . service . messaging 
 + 
 + import com . google . protobuf . CodedInputStream 
 + import im . actor . api . rpc . messaging . ApiMessage 
 + 
 + trait MessageParsing { 
 + def parseMessage ( body : Array [ Byte ] ) : Either [ Any , ApiMessage ] = ApiMessage . parseFrom ( CodedInputStream . newInstance ( body ) ) 
 + } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 index 6f9073f . . af429e1 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 @ @ - 1 , 23 + 1 , 39 @ @ 
 package im . actor . server . api . rpc . service . messaging 
 
 - import akka . http . scaladsl . util . FastFuture 
 import akka . util . Timeout 
 + import cats . data . Xor 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . misc . _ 
 import im . actor . api . rpc . peers . _ 
 import im . actor . config . ActorConfig 
 + import im . actor . server . model . { PeerType , Peer } 
 + import im . actor . server . persist . HistoryMessageRepo 
 + import im . actor . server . sequence . SeqState 
 
 import scala . concurrent . _ 
 + import scala . concurrent . duration . _ 
 
 - private [ messaging ] trait MessagingHandlers extends PeersImplicits { 
 + object MessagingRpcErors { 
 + val NotLastMessage = RpcError ( 400 , " NOT _ LAST _ MESSAGE " , " You are trying to edit not last message . " , false , None ) 
 + val NotInTimeWindow = RpcError ( 400 , " NOT _ IN _ TIME _ WINDOW " , " You can ' t edit message sent more than 5 minutes age . " , false , None ) 
 + val NotTextMessage = RpcError ( 400 , " NOT _ TEXT _ MESSAGE " , " You can edit only text messages . " , false , None ) 
 + val IntenalError = RpcError ( 500 , " INTERNAL _ ERROR " , " " , false , None ) 
 + } 
 + 
 + private [ messaging ] trait MessagingHandlers extends PeersImplicits with MessageParsing { 
 this : MessagingServiceImpl ⇒ 
 
 import FutureResultRpc . _ 
 + import MessagingRpcErors . _ 
 + import PeerHelpers . _ 
 
 override implicit val ec : ExecutionContext = actorSystem . dispatcher 
 private implicit val timeout : Timeout = ActorConfig . defaultTimeout 
 
 + / / TODO : configurable 
 + private val editTimeWindow : Long = 5 . minutes . toMillis 
 + 
 override def doHandleSendMessage ( outPeer : ApiOutPeer , randomId : Long , message : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 ( for ( 
 @ @ - 33 , 6 + 49 , 98 @ @ private [ messaging ] trait MessagingHandlers extends PeersImplicits { 
 ) yield ResponseSeqDate ( s . seq , s . state . toByteArray , s . date ) ) . value 
 } 
 
 - override def doHandleUpdateMessage ( peer : ApiOutPeer , randomId : Long , updatedMessage : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = 
 - FastFuture . failed ( new RuntimeException ( " Not implemented " ) ) 
 + override def doHandleUpdateMessage ( outPeer : ApiOutPeer , randomId : Long , updatedMessage : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = { 
 + authorized ( clientData ) { implicit client ⇒ 
 + withOutPeer ( outPeer ) { 
 + val peer = outPeer . asModel 
 + ( for { 
 + histMessage ← fromFutureOption ( CommonRpcErrors . forbidden ( " Not allowed " ) ) ( db . run ( HistoryMessageRepo . findNewestSentBy ( client . userId , peer ) ) ) 
 + _ ← fromBoolean ( NotLastMessage ) ( histMessage . randomId = = randomId ) 
 + _ = fromBoolean ( NotInTimeWindow ) ( inTimeWindow ( histMessage . date . getMillis ) ) 
 + apiMessage ← fromXor ( ( e : Any ) ⇒ IntenalError ) ( Xor . fromEither ( parseMessage ( histMessage . messageContentData ) ) ) 
 + _ ← fromBoolean ( NotTextMessage ) ( apiMessage match { 
 + case _ : ApiTextMessage ⇒ true 
 + case _ ⇒ false 
 + } ) 
 + result ← fromFuture ( updateMessageContent ( peer , randomId , updatedMessage ) ) 
 + date = System . currentTimeMillis 
 + } yield ResponseSeqDate ( result . seq , result . state . toByteArray , date ) ) . value 
 + } 
 + } 
 + } 
 + 
 + private def inTimeWindow ( messageDateMillis : Long ) : Boolean = { 
 + ( messageDateMillis + editTimeWindow ) > System . currentTimeMillis 
 + } 
 + 
 + / / TODO : move to trait and reuse 
 + private def updateMessageContent ( peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit client : AuthorizedClientData ) : Future [ SeqState ] = peer match { 
 + case Peer ( PeerType . Private , _ ) ⇒ updateContentPrivate ( client . userId , peer , randomId , updatedMessage ) 
 + case Peer ( PeerType . Group , _ ) ⇒ updateContentGroup ( client . userId , peer , randomId , updatedMessage ) 
 + } 
 + 
 + private def updateContentPrivate ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) : Future [ SeqState ] = { 
 + for { 
 + / / update for client himself 
 + seqState ← userExt . broadcastUserUpdate ( 
 + userId = userId , 
 + update = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) , 
 + pushText = None , 
 + isFat = false , 
 + reduceKey = None , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + / / update for peer user 
 + _ ← userExt . broadcastUserUpdate ( 
 + userId = peer . id , 
 + update = UpdateMessageContentChanged ( ApiPeer ( ApiPeerType . Private , userId ) , randomId , updatedMessage ) , 
 + pushText = None , 
 + isFat = false , 
 + reduceKey = None , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 + userIds = Set ( userId , peer . id ) , 
 + randomId = randomId , 
 + peerType = PeerType . Private , 
 + peerIds = Set ( userId , peer . id ) , 
 + messageContentHeader = updatedMessage . header , 
 + messageContentData = updatedMessage . toByteArray 
 + ) ) 
 + } yield seqState 
 + } 
 + 
 + private def updateContentGroup ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) : Future [ SeqState ] = { 
 + val upd = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) 
 + for { 
 + / / update for client user 
 + seqState ← userExt . broadcastUserUpdate ( 
 + userId = userId , 
 + update = upd , 
 + pushText = None , 
 + isFat = false , 
 + reduceKey = None , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + ( memberIds , _ , _ ) ← groupExt . getMemberIds ( peer . id ) 
 + membersSet = memberIds . toSet 
 + / / update for other group members 
 + _ ← userExt . broadcastUsersUpdate ( 
 + userIds = membersSet - userId , 
 + update = upd , 
 + pushText = None , 
 + isFat = false , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 + userIds = membersSet , 
 + randomId = randomId , 
 + peerType = PeerType . Group , 
 + peerIds = Set ( peer . id ) , 
 + messageContentHeader = updatedMessage . header , 
 + messageContentData = updatedMessage . toByteArray 
 + ) ) 
 + } yield seqState 
 + } 
 + 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 index 8130563 . . f0c275d 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 @ @ - 37 , 7 + 37 , 7 @ @ final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : Sessi 
 
 override def doHandleDoCall ( peer : ApiOutPeer , timeout : Option [ Long ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 - withOutPeerF ( peer ) { 
 + withOutPeer ( peer ) { 
 for { 
 ( callId , eventBusId , callerDeviceId ) ← webrtcExt . doCall ( client . userId , client . authId , peer . asModel , timeout ) 
 } yield Ok ( ResponseDoCall ( callId , eventBusId , callerDeviceId ) ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecMatchers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecMatchers . scala 
 index 7b18557 . . 50efffa 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecMatchers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecMatchers . scala 
 @ @ - 6 , 7 + 6 , 7 @ @ import org . scalatest . Matchers 
 import org . scalatest . matchers . Matcher 
 
 trait ServiceSpecMatchers extends Matchers { 
 - def matchNotAuthorized [ T ] : Matcher [ RpcError Xor T ] = matchPattern { 
 + def matchForbidden [ T ] : Matcher [ RpcError Xor T ] = matchPattern { 
 case Xor . Left ( RpcError ( 403 , " FORBIDDEN " , _ , _ , _ ) ) ⇒ 
 } 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 index e66ec98 . . 2ebb865 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 @ @ - 355 , 7 + 355 , 7 @ @ final class GroupsServiceSpec 
 { 
 implicit val clientData = ClientData ( authId2 , sessionId , Some ( AuthData ( user2 . id , authSid2 ) ) ) 
 whenReady ( service . handleGetGroupInviteUrl ( groupOutPeer ) ) { resp ⇒ 
 - resp should matchNotAuthorized 
 + resp should matchForbidden 
 } 
 } 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala 
 index ec2dfe9 . . 534dfde 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala 
 @ @ - 59 , 7 + 59 , 7 @ @ final class IntegrationsServiceSpec 
 val groupOutPeer = createGroup ( " Fun group " , Set . empty ) . groupPeer 
 ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) 
 } 
 - whenReady ( service . handleGetIntegrationToken ( outPeer ) ( clientData2 ) ) ( _ should matchNotAuthorized ) 
 + whenReady ( service . handleGetIntegrationToken ( outPeer ) ( clientData2 ) ) ( _ should matchForbidden ) 
 } 
 
 def e2 ( ) : Unit = { 
 @ @ - 87 , 7 + 87 , 7 @ @ final class IntegrationsServiceSpec 
 } 
 
 whenReady ( service . handleRevokeIntegrationToken ( outPeer ) ( clientData2 ) ) { resp ⇒ 
 - resp should matchNotAuthorized 
 + resp should matchForbidden 
 } 
 
 whenReady ( service . handleGetIntegrationToken ( outPeer ) ( clientData2 ) ) { resp ⇒ 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 index 64add45 . . a9d8e9a 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 @ @ - 2 , 6 + 2 , 7 @ @ package im . actor . server . api . rpc . service 
 
 import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } 
 import akka . testkit . TestProbe 
 + import cats . data . Xor 
 import im . actor . api . rpc . Implicits . _ 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . counters . UpdateCountersChanged 
 @ @ - 13 , 6 + 14 , 7 @ @ import im . actor . api . rpc . sequence . { ApiUpdateContainer , ResponseGetDifference } 
 import im . actor . server . _ 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 + import im . actor . server . persist . HistoryMessageRepo 
 import im . actor . server . pubsub . PeerMessage 
 
 import scala . concurrent . Future 
 @ @ - 42 , 6 + 44 , 10 @ @ class MessagingServiceSpec 
 
 " Any Messaging " should " keep original order of sent messages " in s . generic . rightOrder 
 
 + it should " allow user to edit own message " in s . generic . editOwnMessage 
 + 
 + it should " not allow user to edit alien messages " in s . generic . notEditAlienMessage 
 + 
 object s { 
 implicit val ec = system . dispatcher 
 
 @ @ - 211 , 31 + 217 , 31 @ @ class MessagingServiceSpec 
 val alienClientData = ClientData ( user1AuthId1 , sessionId , Some ( AuthData ( alien . id , authSidAlien ) ) ) 
 
 whenReady ( service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi again " , Vector . empty , None ) ) ( alienClientData ) ) { resp ⇒ 
 - resp should matchNotAuthorized 
 + resp should matchForbidden 
 } 
 
 whenReady ( groupsService . handleEditGroupTitle ( groupOutPeer , 4L , " Loosers " ) ( alienClientData ) ) { resp ⇒ 
 - resp should matchNotAuthorized 
 + resp should matchForbidden 
 } 
 
 val ( user3 , authId3 , _ , _ ) = createUser ( ) 
 val user3OutPeer = ApiUserOutPeer ( user3 . id , 11 ) 
 
 whenReady ( groupsService . handleInviteUser ( groupOutPeer , 4L , user3OutPeer ) ( alienClientData ) ) { resp ⇒ 
 - resp should matchNotAuthorized 
 + resp should matchForbidden 
 } 
 
 val fileLocation = ApiFileLocation ( 1L , 1L ) 
 whenReady ( groupsService . handleEditGroupAvatar ( groupOutPeer , 5L , fileLocation ) ( alienClientData ) ) { resp ⇒ 
 - resp should matchNotAuthorized 
 + resp should matchForbidden 
 } 
 
 whenReady ( groupsService . handleRemoveGroupAvatar ( groupOutPeer , 5L ) ( alienClientData ) ) { resp ⇒ 
 - resp should matchNotAuthorized 
 + resp should matchForbidden 
 } 
 
 whenReady ( groupsService . handleLeaveGroup ( groupOutPeer , 5L ) ( alienClientData ) ) { resp ⇒ 
 - resp should matchNotAuthorized 
 + resp should matchForbidden 
 } 
 
 } 
 @ @ - 386 , 6 + 392 , 115 @ @ class MessagingServiceSpec 
 
 } 
 
 + def notEditAlienMessage ( ) = { 
 + val sessionId = createSessionId ( ) 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + 
 + val aliceCD = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobCD = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 + 
 + val alicePeer = ApiPeer ( ApiPeerType . Private , alice . id ) 
 + val bobPeer = ApiPeer ( ApiPeerType . Private , bob . id ) 
 + 
 + val aliceOutPeer = whenReady ( ACLUtils . getOutPeer ( alicePeer , bobAuthId ) ) ( identity ) 
 + val bobOutPeer = whenReady ( ACLUtils . getOutPeer ( bobPeer , aliceAuthId ) ) ( identity ) 
 + 
 + val messRandomId = { 
 + implicit val cd = aliceCD 
 + sendMessageToUser ( bob . id , ApiTextMessage ( " hello bob " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val cd = bobCD 
 + whenReady ( service . handleUpdateMessage ( aliceOutPeer , messRandomId , ApiTextMessage ( " XXXXXXXXX " , Vector . empty , None ) ) ) { resp ⇒ 
 + resp should matchForbidden 
 + } 
 + expectNoUpdate ( 0 , classOf [ UpdateMessageContentChanged ] ) 
 + } 
 + 
 + { 
 + implicit val cd = aliceCD 
 + expectNoUpdate ( 0 , classOf [ UpdateMessageContentChanged ] ) 
 + } 
 + 
 + val messages = for { 
 + a ← HistoryMessageRepo . findNewest ( alice . id , bobPeer . asModel ) 
 + b ← HistoryMessageRepo . findNewest ( bob . id , alicePeer . asModel ) 
 + } yield List ( a , b ) . flatten 
 + 
 + whenReady ( db . run ( messages ) ) { messages ⇒ 
 + messages should have length 2 
 + messages foreach { mess ⇒ 
 + inside ( parseMessage ( mess . messageContentData ) ) { 
 + case Right ( ApiTextMessage ( " hello bob " , _ , _ ) ) ⇒ 
 + } 
 + } 
 + } 
 + } 
 + 
 + def editOwnMessage ( ) = { 
 + val sessionId = createSessionId ( ) 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + 
 + val aliceCD = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobCD = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 + 
 + val alicePeer = ApiPeer ( ApiPeerType . Private , alice . id ) 
 + val bobPeer = ApiPeer ( ApiPeerType . Private , bob . id ) 
 + 
 + val aliceOutPeer = whenReady ( ACLUtils . getOutPeer ( alicePeer , bobAuthId ) ) ( identity ) 
 + val bobOutPeer = whenReady ( ACLUtils . getOutPeer ( bobPeer , aliceAuthId ) ) ( identity ) 
 + 
 + val messRandomId = { 
 + implicit val cd = aliceCD 
 + sendMessageToUser ( bob . id , ApiTextMessage ( " hello bob " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val cd = aliceCD 
 + whenReady ( service . handleUpdateMessage ( bobOutPeer , messRandomId , ApiTextMessage ( " XXXXXXXXX " , Vector . empty , None ) ) ) { resp ⇒ 
 + resp should matchPattern { 
 + case Xor . Right ( ResponseSeqDate ( _ , _ , _ ) ) ⇒ 
 + } 
 + / / resp . toOption . get . seq 
 + } 
 + expectUpdate ( classOf [ UpdateMessageContentChanged ] ) { upd ⇒ 
 + upd . randomId shouldEqual messRandomId 
 + upd . peer shouldEqual bobPeer 
 + inside ( parseMessage ( upd . message . toByteArray ) ) { 
 + case Right ( ApiTextMessage ( " XXXXXXXXX " , _ , _ ) ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + { 
 + implicit val cd = bobCD 
 + expectUpdate ( classOf [ UpdateMessageContentChanged ] ) { upd ⇒ 
 + upd . randomId shouldEqual messRandomId 
 + upd . peer shouldEqual alicePeer 
 + inside ( parseMessage ( upd . message . toByteArray ) ) { 
 + case Right ( ApiTextMessage ( " XXXXXXXXX " , _ , _ ) ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + val messages = for { 
 + a ← HistoryMessageRepo . findNewest ( alice . id , bobPeer . asModel ) 
 + b ← HistoryMessageRepo . findNewest ( bob . id , alicePeer . asModel ) 
 + } yield List ( a , b ) . flatten 
 + 
 + whenReady ( db . run ( messages ) ) { messages ⇒ 
 + messages should have length 2 
 + messages foreach { mess ⇒ 
 + inside ( parseMessage ( mess . messageContentData ) ) { 
 + case Right ( ApiTextMessage ( " XXXXXXXXX " , _ , _ ) ) ⇒ 
 + } 
 + } 
 + } 
 + } 
 + 
 } 
 
 }
