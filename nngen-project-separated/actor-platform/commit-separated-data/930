BLEU SCORE: 0.7598356856515925

TEST MSG: fix ( server : messaging ) : fixed archived logic
GENERATED MSG: fix ( server : messaging ) : fixed loadDialogs

TEST DIFF (one line): diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > index a9c3095 . . a6f72e6 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > @ @ - 118 , 6 + 118 , 8 @ @ object DialogRepo extends UserDialogOperations with DialogCommonOperations { < nl > < nl > private val archived = DialogRepo . dialogs . filter ( _ . _ 2 . archivedAt . isDefined ) < nl > < nl > + private val notArchived = DialogRepo . dialogs . filter ( _ . _ 2 . archivedAt . isEmpty ) < nl > + < nl > private def archivedByUserId ( < nl > userId : Rep [ Int ] , < nl > offset : ConstColumn [ Long ] , < nl > @ @ - 186 , 10 + 188 , 11 @ @ object DialogRepo extends UserDialogOperations with DialogCommonOperations { < nl > fetch ( userId , dateOpt : Option [ DateTime ] , limit , { case ( c , _ ) ⇒ c . lastMessageDate . desc } , fetchArchived ) < nl > < nl > def fetch [ A ] ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , sorting : ( ( DialogCommonTable , UserDialogTable ) ) ⇒ ColumnOrdered [ A ] , fetchArchived : Boolean ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = { < nl > - val baseQuery : Query [ ( DialogCommonTable , UserDialogTable ) , ( DialogCommon , UserDialog ) , Seq ] = < nl > - ( if ( fetchArchived ) archived else dialogs ) < nl > + val baseQuery : Query [ ( DialogCommonTable , UserDialogTable ) , ( DialogCommon , UserDialog ) , Seq ] = { < nl > + ( if ( fetchArchived ) archived else notArchived ) < nl > . filter ( { case ( _ , u ) ⇒ u . userId = = = userId } ) < nl > . sortBy ( sorting ) < nl > + } < nl > < nl > val limitedQuery = dateOpt match { < nl > case Some ( date ) ⇒ baseQuery . filter ( { case ( c , _ ) ⇒ c . lastMessageDate < = date } )
NEAREST DIFF (one line): diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / Dialog . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / Dialog . scala < nl > index 604183f . . e4780a2 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / Dialog . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / Dialog . scala < nl > @ @ - 99 , 18 + 99 , 28 @ @ object Dialog { < nl > def findLastReadBefore ( date : DateTime , userId : Int ) = < nl > dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result < nl > < nl > - def findByUser ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int ) = { < nl > + def findByUser ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int ) ( implicit ec : ExecutionContext ) = { < nl > val baseQuery = dialogs < nl > . filter ( d ⇒ d . userId = = = userId ) < nl > + . sortBy ( _ . lastMessageDate . desc ) < nl > < nl > - val query = dateOpt match { < nl > - case Some ( date ) ⇒ < nl > - baseQuery . filter ( _ . lastMessageDate < = date ) . sortBy ( _ . lastMessageDate . desc ) < nl > - case None ⇒ < nl > - baseQuery . sortBy ( _ . lastMessageDate . desc ) < nl > + val limitedQuery = dateOpt match { < nl > + case Some ( date ) ⇒ baseQuery . filter ( _ . lastMessageDate < = date ) < nl > + case None ⇒ baseQuery < nl > } < nl > < nl > - query . take ( limit ) . result < nl > + for { < nl > + limited ← limitedQuery . take ( limit ) . result < nl > + / / work - around for case when there are more than one dialog with the same lastMessageDate < nl > + result ← limited < nl > + . lastOption match { < nl > + case Some ( last ) ⇒ < nl > + for { < nl > + sameDate ← baseQuery . filter ( _ . lastMessageDate = = = last . lastMessageDate ) . result < nl > + } yield limited . filterNot ( _ . lastMessageDate = = last . lastMessageDate ) + + sameDate < nl > + case None ⇒ DBIO . successful ( limited ) < nl > + } < nl > + } yield result < nl > } < nl > < nl > def updateLastMessageDate ( userId : Int , peer : models . Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index 321b31d . . 6d4be36 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 78 , 7 + 78 , 7 @ @ trait HistoryHandlers { < nl > < nl > override def jhandleLoadDialogs ( endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > - persist . Dialog . findByUser ( client . userId , endDateTimeFrom ( endDate ) , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > + persist . Dialog . findByUser ( client . userId , endDateTimeFrom ( endDate ) , limit ) flatMap { dialogModels ⇒ < nl > for { < nl > dialogs ← DBIO . sequence ( dialogModels map getDialogStruct ) < nl > ( users , groups ) ← getDialogsUsersGroups ( dialogs )

TEST DIFF:
diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 index a9c3095 . . a6f72e6 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 @ @ - 118 , 6 + 118 , 8 @ @ object DialogRepo extends UserDialogOperations with DialogCommonOperations { 
 
 private val archived = DialogRepo . dialogs . filter ( _ . _ 2 . archivedAt . isDefined ) 
 
 + private val notArchived = DialogRepo . dialogs . filter ( _ . _ 2 . archivedAt . isEmpty ) 
 + 
 private def archivedByUserId ( 
 userId : Rep [ Int ] , 
 offset : ConstColumn [ Long ] , 
 @ @ - 186 , 10 + 188 , 11 @ @ object DialogRepo extends UserDialogOperations with DialogCommonOperations { 
 fetch ( userId , dateOpt : Option [ DateTime ] , limit , { case ( c , _ ) ⇒ c . lastMessageDate . desc } , fetchArchived ) 
 
 def fetch [ A ] ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , sorting : ( ( DialogCommonTable , UserDialogTable ) ) ⇒ ColumnOrdered [ A ] , fetchArchived : Boolean ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = { 
 - val baseQuery : Query [ ( DialogCommonTable , UserDialogTable ) , ( DialogCommon , UserDialog ) , Seq ] = 
 - ( if ( fetchArchived ) archived else dialogs ) 
 + val baseQuery : Query [ ( DialogCommonTable , UserDialogTable ) , ( DialogCommon , UserDialog ) , Seq ] = { 
 + ( if ( fetchArchived ) archived else notArchived ) 
 . filter ( { case ( _ , u ) ⇒ u . userId = = = userId } ) 
 . sortBy ( sorting ) 
 + } 
 
 val limitedQuery = dateOpt match { 
 case Some ( date ) ⇒ baseQuery . filter ( { case ( c , _ ) ⇒ c . lastMessageDate < = date } )

NEAREST DIFF:
diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / Dialog . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / Dialog . scala 
 index 604183f . . e4780a2 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / Dialog . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / Dialog . scala 
 @ @ - 99 , 18 + 99 , 28 @ @ object Dialog { 
 def findLastReadBefore ( date : DateTime , userId : Int ) = 
 dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result 
 
 - def findByUser ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int ) = { 
 + def findByUser ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int ) ( implicit ec : ExecutionContext ) = { 
 val baseQuery = dialogs 
 . filter ( d ⇒ d . userId = = = userId ) 
 + . sortBy ( _ . lastMessageDate . desc ) 
 
 - val query = dateOpt match { 
 - case Some ( date ) ⇒ 
 - baseQuery . filter ( _ . lastMessageDate < = date ) . sortBy ( _ . lastMessageDate . desc ) 
 - case None ⇒ 
 - baseQuery . sortBy ( _ . lastMessageDate . desc ) 
 + val limitedQuery = dateOpt match { 
 + case Some ( date ) ⇒ baseQuery . filter ( _ . lastMessageDate < = date ) 
 + case None ⇒ baseQuery 
 } 
 
 - query . take ( limit ) . result 
 + for { 
 + limited ← limitedQuery . take ( limit ) . result 
 + / / work - around for case when there are more than one dialog with the same lastMessageDate 
 + result ← limited 
 + . lastOption match { 
 + case Some ( last ) ⇒ 
 + for { 
 + sameDate ← baseQuery . filter ( _ . lastMessageDate = = = last . lastMessageDate ) . result 
 + } yield limited . filterNot ( _ . lastMessageDate = = last . lastMessageDate ) + + sameDate 
 + case None ⇒ DBIO . successful ( limited ) 
 + } 
 + } yield result 
 } 
 
 def updateLastMessageDate ( userId : Int , peer : models . Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index 321b31d . . 6d4be36 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 78 , 7 + 78 , 7 @ @ trait HistoryHandlers { 
 
 override def jhandleLoadDialogs ( endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 - persist . Dialog . findByUser ( client . userId , endDateTimeFrom ( endDate ) , Int . MaxValue ) flatMap { dialogModels ⇒ 
 + persist . Dialog . findByUser ( client . userId , endDateTimeFrom ( endDate ) , limit ) flatMap { dialogModels ⇒ 
 for { 
 dialogs ← DBIO . sequence ( dialogModels map getDialogStruct ) 
 ( users , groups ) ← getDialogsUsersGroups ( dialogs )
