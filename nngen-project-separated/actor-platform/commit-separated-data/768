BLEU SCORE: 0.07432998184513635

TEST MSG: refactor ( server ) : use single implementation of message updating ; improve RichMessages implementation
GENERATED MSG: feat ( server : bots ) : remote bots

TEST DIFF (one line): diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > index 0da2400 . . 3c1abcc 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > @ @ - 2 , 19 + 2 , 16 @ @ package im . actor . server . bot . services < nl > < nl > import akka . actor . ActorSystem < nl > import im . actor . api . rpc . PeersImplicits < nl > - import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } < nl > import im . actor . bots . BotMessages . BotError < nl > import im . actor . concurrent . FutureResult < nl > import im . actor . server . bot . { BotServiceBase , BotToApiConversions } < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . DialogExtension < nl > - import im . actor . server . group . GroupExtension < nl > - import im . actor . server . model . { Peer ⇒ ModelPeer , PeerType } < nl > + import im . actor . server . messaging . MessageUpdating < nl > + import im . actor . server . model . { Peer ⇒ ModelPeer } < nl > import im . actor . server . persist . HistoryMessageRepo < nl > import im . actor . server . sequence . SeqStateDate < nl > < nl > - import scala . concurrent . Future < nl > - < nl > private [ bot ] object MessagingBotErrors { < nl > val Forbidden = BotError ( 403 , " FORBIDDEN " ) < nl > } < nl > @ @ - 22 , 7 + 19 , 8 @ @ private [ bot ] object MessagingBotErrors { < nl > private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) < nl > with FutureResult [ BotError ] < nl > with BotToApiConversions < nl > - with PeersImplicits { < nl > + with PeersImplicits < nl > + with MessageUpdating { < nl > < nl > import MessagingBotErrors . _ < nl > import im . actor . bots . BotMessages . _ < nl > @ @ - 33 , 7 + 31 , 7 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer < nl > < nl > override val handlers : PartialFunction [ RequestBody , WeakRequestHandler ] = { < nl > case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak < nl > - case UpdateMessageContent ( peer , randomId , message ) ⇒ updateMessageContent ( peer , randomId , message ) . toWeak < nl > + case UpdateMessageContent ( peer , randomId , message ) ⇒ updateMessage ( peer , randomId , message ) . toWeak < nl > } < nl > < nl > private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( < nl > @ @ - 54 , 64 + 52 , 15 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer < nl > ) < nl > < nl > / / allow bot to update only it ' s messages . Bot won ' t not be able to modify user ' s messages < nl > - private def updateMessageContent ( peer : OutPeer , randomId : Long , updatedMessage : MessageBody ) = RequestHandler [ UpdateMessageContent , UpdateMessageContent # Response ] ( < nl > + private def updateMessage ( peer : OutPeer , randomId : Long , updatedMessage : MessageBody ) = RequestHandler [ UpdateMessageContent , UpdateMessageContent # Response ] ( < nl > ( botUserId : BotUserId , botAuthId : BotAuthId , botAuthSid : BotAuthSid ) ⇒ { < nl > val peerModel = toPeer ( peer ) . asModel < nl > val botPeer = ModelPeer . privat ( botUserId ) < nl > ( for { < nl > _ ← fromFutureBoolean ( Forbidden ) ( db . run ( HistoryMessageRepo . findBySender ( botUserId , peerModel , randomId ) . headOption map ( _ . nonEmpty ) ) ) < nl > - _ ← fromFuture ( peer match { < nl > - case UserOutPeer ( userId , _ ) ⇒ updateContentPrivate ( peerModel . id , botPeer , randomId , updatedMessage ) < nl > - case GroupOutPeer ( groupId , _ ) ⇒ updateContentGroup ( botUserId , peerModel , randomId , updatedMessage ) < nl > - } ) < nl > + _ ← fromFuture ( updateMessageContent ( botUserId , peerModel , randomId , updatedMessage ) ( system ) ) < nl > } yield MessageContentUpdated ) . value < nl > } < nl > ) < nl > < nl > - private def updateContentPrivate ( userId : Int , botPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { < nl > - val upd = UpdateMessageContentChanged ( botPeer . asStruct , randomId , updatedMessage ) < nl > - for { < nl > - _ ← userExt . broadcastUserUpdate ( < nl > - userId = userId , < nl > - update = upd , < nl > - pushText = None , < nl > - isFat = false , < nl > - reduceKey = None , < nl > - deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > - ) < nl > - _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > - userIds = Set ( userId , botPeer . id ) , < nl > - randomId = randomId , < nl > - peerType = PeerType . Private , < nl > - peerIds = Set ( userId , botPeer . id ) , < nl > - messageContentHeader = updatedMessage . header , < nl > - messageContentData = updatedMessage . toByteArray < nl > - ) ) < nl > - } yield ( ) < nl > - } < nl > - < nl > - private def updateContentGroup ( botUserId : Int , groupPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { < nl > - / / no need to send update to bot itself < nl > - val upd = UpdateMessageContentChanged ( groupPeer . asStruct , randomId , updatedMessage ) < nl > - for { < nl > - ( memberIds , _ , _ ) ← GroupExtension ( system ) . getMemberIds ( groupPeer . id ) < nl > - membersSet = memberIds . toSet < nl > - _ ← userExt . broadcastUsersUpdate ( < nl > - userIds = membersSet , < nl > - update = upd , < nl > - pushText = None , < nl > - isFat = false , < nl > - deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > - ) < nl > - _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > - userIds = membersSet + botUserId , < nl > - randomId = randomId , < nl > - peerType = PeerType . Group , < nl > - peerIds = Set ( groupPeer . id ) , < nl > - messageContentHeader = updatedMessage . header , < nl > - messageContentData = updatedMessage . toByteArray < nl > - ) ) < nl > - } yield ( ) < nl > - } < nl > - < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageParsing . scala b / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageParsing . scala < nl > new file mode 100644 < nl > index 0000000 . . e91ab05 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageParsing . scala < nl > @ @ - 0 , 0 + 1 , 8 @ @ < nl > + package im . actor . server . messaging < nl > + < nl > + import com . google . protobuf . CodedInputStream < nl > + import im . actor . api . rpc . messaging . ApiMessage < nl > + < nl > + trait MessageParsing { < nl > + def parseMessage ( body : Array [ Byte ] ) : Either [ Any , ApiMessage ] = ApiMessage . parseFrom ( CodedInputStream . newInstance ( body ) ) < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageUpdating . scala b / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageUpdating . scala < nl > new file mode 100644 < nl > index 0000000 . . 4d3ec72 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageUpdating . scala < nl > @ @ - 0 , 0 + 1 , 91 @ @ < nl > + package im . actor . server . messaging < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . PeersImplicits < nl > + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } < nl > + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . group . GroupExtension < nl > + import im . actor . server . model . { Peer , PeerType } < nl > + import im . actor . server . persist . HistoryMessageRepo < nl > + import im . actor . server . sequence . SeqState < nl > + import im . actor . server . user . UserExtension < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + trait MessageUpdating extends PeersImplicits { < nl > + < nl > + def updateMessageContent ( clientUserId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit system : ActorSystem ) : Future [ SeqState ] = { < nl > + peer match { < nl > + case Peer ( PeerType . Private , _ ) ⇒ updateContentPrivate ( clientUserId , peer , randomId , updatedMessage ) < nl > + case Peer ( PeerType . Group , _ ) ⇒ updateContentGroup ( clientUserId , peer , randomId , updatedMessage ) < nl > + } < nl > + } < nl > + < nl > + private def updateContentPrivate ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit system : ActorSystem ) : Future [ SeqState ] = { < nl > + import system . dispatcher < nl > + for { < nl > + / / update for client himself < nl > + seqState ← UserExtension ( system ) . broadcastUserUpdate ( < nl > + userId = userId , < nl > + update = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) , < nl > + pushText = None , < nl > + isFat = false , < nl > + reduceKey = None , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + / / update for peer user < nl > + _ ← UserExtension ( system ) . broadcastUserUpdate ( < nl > + userId = peer . id , < nl > + update = UpdateMessageContentChanged ( ApiPeer ( ApiPeerType . Private , userId ) , randomId , updatedMessage ) , < nl > + pushText = None , < nl > + isFat = false , < nl > + reduceKey = None , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + _ ← DbExtension ( system ) . db . run ( HistoryMessageRepo . updateContentAll ( < nl > + userIds = Set ( userId , peer . id ) , < nl > + randomId = randomId , < nl > + peerType = PeerType . Private , < nl > + peerIds = Set ( userId , peer . id ) , < nl > + messageContentHeader = updatedMessage . header , < nl > + messageContentData = updatedMessage . toByteArray < nl > + ) ) < nl > + } yield seqState < nl > + } < nl > + < nl > + private def updateContentGroup ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit system : ActorSystem ) : Future [ SeqState ] = { < nl > + import system . dispatcher < nl > + val upd = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) < nl > + for { < nl > + / / update for client user < nl > + seqState ← UserExtension ( system ) . broadcastUserUpdate ( < nl > + userId = userId , < nl > + update = upd , < nl > + pushText = None , < nl > + isFat = false , < nl > + reduceKey = None , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + ( memberIds , _ , _ ) ← GroupExtension ( system ) . getMemberIds ( peer . id ) < nl > + membersSet = memberIds . toSet < nl > + / / update for other group members < nl > + _ ← UserExtension ( system ) . broadcastUsersUpdate ( < nl > + userIds = membersSet - userId , < nl > + update = upd , < nl > + pushText = None , < nl > + isFat = false , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + _ ← DbExtension ( system ) . db . run ( HistoryMessageRepo . updateContentAll ( < nl > + userIds = membersSet + userId , < nl > + randomId = randomId , < nl > + peerType = PeerType . Group , < nl > + peerIds = Set ( peer . id ) , < nl > + messageContentHeader = updatedMessage . header , < nl > + messageContentData = updatedMessage . toByteArray < nl > + ) ) < nl > + } yield seqState < nl > + } < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewHelpers . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewHelpers . scala < nl > index e4a9e77 . . fab7766 100644 < nl > - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewHelpers . scala < nl > + + + b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewHelpers . scala < nl > @ @ - 1 , 52 + 1 , 54 @ @ < nl > package im . actor . server . enrich < nl > < nl > - import scala . concurrent . duration . _ < nl > - import scala . concurrent . { ExecutionContext , Future } < nl > - import scala . util . { Failure , Success , Try } < nl > - < nl > - import akka . http . scaladsl . HttpExt < nl > + import akka . actor . ActorSystem < nl > + import akka . http . scaladsl . Http < nl > import akka . http . scaladsl . model . { HttpEntity , HttpRequest , HttpResponse } < nl > import akka . stream . Materializer < nl > import akka . stream . scaladsl . _ < nl > import akka . stream . stage . { Context , PushStage } < nl > import akka . util . ByteString < nl > - < nl > import im . actor . server . enrich . PreviewMaker . Failures . _ < nl > import im . actor . server . enrich . PreviewMaker . _ < nl > < nl > - object PreviewHelpers { < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . util . { Failure , Success , Try } < nl > + < nl > + trait PreviewHelpers { < nl > + < nl > + protected implicit val system : ActorSystem < nl > + protected implicit val ec : ExecutionContext < nl > + protected implicit val mat : Materializer < nl > < nl > - def withRequest ( request : ⇒ HttpRequest , handler : UpdateHandler ) ( function : HttpResponse ⇒ Future [ PreviewResult ] ) ( implicit http : HttpExt , materializer : Materializer , ec : ExecutionContext ) : Future [ PreviewResult ] = { < nl > + def withRequest ( request : ⇒ HttpRequest , randomId : Long ) ( function : HttpResponse ⇒ Future [ PreviewResult ] ) ( implicit system : ActorSystem ) : Future [ PreviewResult ] = { < nl > Try ( request ) match { < nl > - case Success ( v ) ⇒ http . singleRequest ( v ) . flatMap ( function ) . recover { case e : Exception ⇒ failedToMakePreview ( handler , e . getMessage ) } < nl > - case Failure ( _ ) ⇒ Future . successful ( failedToMakePreview ( handler ) ) < nl > + case Success ( v ) ⇒ Http ( ) . singleRequest ( v ) . flatMap ( function ) recover { case e : Exception ⇒ failedToMakePreview ( randomId , e . getMessage ) } < nl > + case Failure ( _ ) ⇒ Future . successful ( failedToMakePreview ( randomId ) ) < nl > } < nl > } < nl > < nl > - def downloadDefault ( entity : HttpEntity . Default , fileName : Option [ String ] , handler : UpdateHandler , config : RichMessageConfig ) ( implicit materializer : Materializer , ec : ExecutionContext ) : Future [ PreviewResult ] = { < nl > + def downloadDefault ( entity : HttpEntity . Default , fileName : Option [ String ] , gp : GetPreview , maxSize : Long ) : Future [ PreviewResult ] = { < nl > val mediaType = entity . contentType . mediaType < nl > val contentLength = entity . contentLength < nl > ( mediaType . isImage , contentLength ) match { < nl > - case ( true , length ) if length < = config . maxSize ⇒ < nl > - entity < nl > - . toStrict ( 10 . seconds ) < nl > - . map { body ⇒ PreviewSuccess ( body . data , fileName , mediaType . value , handler ) } < nl > - . recover { case e : Exception ⇒ failedToMakePreview ( handler , e . getMessage ) } < nl > - case ( true , _ ) ⇒ Future . successful ( contentTooLong ( handler ) ) < nl > - case ( false , _ ) ⇒ Future . successful ( notAnImage ( handler ) ) < nl > + case ( true , length ) if length < = maxSize ⇒ < nl > + entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) < nl > + . map { body ⇒ PreviewSuccess ( body , fileName , mediaType . value , gp . clientUserId , gp . peer , gp . randomId ) } < nl > + . recover { case e : Exception ⇒ failedToMakePreview ( gp . randomId , e . getMessage ) } < nl > + case ( true , _ ) ⇒ Future . successful ( contentTooLong ( gp . randomId ) ) < nl > + case ( false , _ ) ⇒ Future . successful ( notAnImage ( gp . randomId ) ) < nl > } < nl > } < nl > < nl > - def downloadChunked ( entity : HttpEntity . Chunked , fileName : Option [ String ] , handler : UpdateHandler , config : RichMessageConfig ) ( implicit materializer : Materializer , ec : ExecutionContext ) : Future [ PreviewResult ] = { < nl > + def downloadChunked ( entity : HttpEntity . Chunked , fileName : Option [ String ] , gp : GetPreview , maxSize : Long ) : Future [ PreviewResult ] = { < nl > val mediaType = entity . contentType . mediaType < nl > mediaType . isImage match { < nl > case true ⇒ < nl > entity . dataBytes < nl > - . via ( sizeBoundingFlow ( config . maxSize ) ) < nl > - . runWith ( Sink . fold ( ByteString . empty ) { ( acc , el ) ⇒ acc + + el } ) < nl > - . map { body ⇒ PreviewSuccess ( body , fileName , mediaType . value , handler ) } < nl > - . recover { case e : Exception ⇒ failedToMakePreview ( handler , e . getMessage ) } < nl > - case false ⇒ Future . successful ( notAnImage ( handler ) ) < nl > + . via ( sizeBoundingFlow ( maxSize ) ) < nl > + . runFold ( ByteString . empty ) ( _ + + _ ) < nl > + . map { body ⇒ PreviewSuccess ( body , fileName , mediaType . value , gp . clientUserId , gp . peer , gp . randomId ) } < nl > + . recover { case e : Exception ⇒ failedToMakePreview ( gp . randomId , e . getMessage ) } < nl > + case false ⇒ Future . successful ( notAnImage ( gp . randomId ) ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewMaker . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewMaker . scala < nl > index 41452ab . . 58e2c4e 100644 < nl > - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewMaker . scala < nl > + + + b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewMaker . scala < nl > @ @ - 1 , 20 + 1 , 20 @ @ < nl > package im . actor . server . enrich < nl > < nl > - import scala . concurrent . { ExecutionContextExecutor , Future } < nl > - < nl > import akka . actor . _ < nl > import akka . http . scaladsl . model . HttpMethods . GET < nl > import akka . http . scaladsl . model . _ < nl > import akka . http . scaladsl . model . headers . _ < nl > - import akka . http . scaladsl . { Http , HttpExt } < nl > import akka . pattern . pipe < nl > - import akka . stream . Materializer < nl > + import akka . stream . { ActorMaterializer , Materializer } < nl > import akka . util . ByteString < nl > + import im . actor . server . model . Peer < nl > + < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > < nl > object PreviewMaker { < nl > < nl > - def apply ( config : RichMessageConfig , name : String ) ( implicit system : ActorSystem , materializer : Materializer ) : ActorRef = < nl > - system . actorOf ( Props ( classOf [ PreviewMaker ] , config , materializer ) , name ) < nl > + def apply ( config : RichMessageConfig , name : String ) ( implicit system : ActorSystem ) : ActorRef = < nl > + system . actorOf ( Props ( classOf [ PreviewMaker ] , config ) , name ) < nl > < nl > object Failures { < nl > object Messages { < nl > @ @ - 22 , 38 + 22 , 49 @ @ object PreviewMaker { < nl > val ContentTooLong = " content is too long " < nl > val Failed = " failed to make preview " < nl > } < nl > - def notAnImage ( handler : UpdateHandler ) = PreviewFailure ( Messages . NotAnImage , handler ) < nl > - def contentTooLong ( handler : UpdateHandler ) = PreviewFailure ( Messages . ContentTooLong , handler ) < nl > - def failedToMakePreview ( handler : UpdateHandler , cause : String = Messages . Failed ) = PreviewFailure ( cause , handler ) < nl > - def failedWith ( status : StatusCode , handler : UpdateHandler ) : PreviewFailure = PreviewFailure ( s " failed to make preview with http status code $ { status . value } " , handler ) < nl > + def notAnImage ( randomId : Long ) = PreviewFailure ( Messages . NotAnImage , randomId ) < nl > + def contentTooLong ( randomId : Long ) = PreviewFailure ( Messages . ContentTooLong , randomId ) < nl > + def failedToMakePreview ( randomId : Long , cause : String = Messages . Failed ) = PreviewFailure ( cause , randomId ) < nl > + def failedWith ( status : StatusCode , randomId : Long ) : PreviewFailure = PreviewFailure ( s " failed to make preview with http status code $ { status . value } " , randomId ) < nl > } < nl > < nl > - case class GetPreview ( url : String , handler : UpdateHandler ) < nl > + final case class GetPreview ( < nl > + url : String , < nl > + clientUserId : Int , < nl > + peer : Peer , < nl > + randomId : Long < nl > + ) < nl > < nl > sealed trait PreviewResult < nl > - case class PreviewSuccess ( content : ByteString , fileName : Option [ String ] , contentType : String , handler : UpdateHandler ) extends PreviewResult < nl > - case class PreviewFailure ( message : String , handler : UpdateHandler ) extends PreviewResult < nl > + final case class PreviewSuccess ( < nl > + content : ByteString , < nl > + fileName : Option [ String ] , < nl > + contentType : String , < nl > + clientUserId : Int , < nl > + peer : Peer , < nl > + randomId : Long < nl > + ) extends PreviewResult < nl > + final case class PreviewFailure ( message : String , randomId : Long ) extends PreviewResult < nl > < nl > private def getFileName ( cdOption : Option [ ` Content - Disposition ` ] ) = cdOption . flatMap ( _ . params . get ( " filename " ) ) < nl > } < nl > < nl > - class PreviewMaker ( config : RichMessageConfig ) ( implicit materializer : Materializer ) extends Actor with ActorLogging { < nl > + class PreviewMaker ( config : RichMessageConfig ) extends Actor with ActorLogging with PreviewHelpers { < nl > < nl > - import PreviewHelpers . _ < nl > import PreviewMaker . _ < nl > < nl > - implicit val system : ActorSystem = context . system < nl > - implicit val ec : ExecutionContextExecutor = context . dispatcher < nl > - implicit val http : HttpExt = Http ( ) < nl > + protected implicit val system : ActorSystem = context . system < nl > + protected implicit val ec : ExecutionContext = system . dispatcher < nl > + protected implicit val mat : Materializer = ActorMaterializer ( ) < nl > < nl > def receive = { < nl > - case GetPreview ( url , handler ) ⇒ < nl > - val result : Future [ PreviewResult ] = withRequest ( HttpRequest ( GET , url ) , handler ) { response ⇒ < nl > + case gp : GetPreview ⇒ < nl > + val result : Future [ PreviewResult ] = withRequest ( HttpRequest ( GET , gp . url ) , gp . randomId ) { response ⇒ < nl > val cd : Option [ ` Content - Disposition ` ] = response . header [ ` Content - Disposition ` ] < nl > response match { < nl > - case HttpResponse ( _ : StatusCodes . Success , _ , entity : HttpEntity . Default , _ ) ⇒ downloadDefault ( entity , getFileName ( cd ) , handler , config ) < nl > - case HttpResponse ( _ : StatusCodes . Success , _ , entity : HttpEntity . Chunked , _ ) ⇒ downloadChunked ( entity , getFileName ( cd ) , handler , config ) < nl > - case HttpResponse ( status , _ , _ , _ ) ⇒ Future . successful ( Failures . failedWith ( status , handler ) ) < nl > + case HttpResponse ( _ : StatusCodes . Success , _ , entity : HttpEntity . Default , _ ) ⇒ downloadDefault ( entity , getFileName ( cd ) , gp , config . maxSize ) < nl > + case HttpResponse ( _ : StatusCodes . Success , _ , entity : HttpEntity . Chunked , _ ) ⇒ downloadChunked ( entity , getFileName ( cd ) , gp , config . maxSize ) < nl > + case HttpResponse ( status , _ , _ , _ ) ⇒ Future . successful ( Failures . failedWith ( status , gp . randomId ) ) < nl > } < nl > } < nl > result pipeTo sender ( ) < nl > diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala < nl > index cb35dea . . 5f4ff26 100644 < nl > - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala < nl > + + + b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala < nl > @ @ - 4 , 51 + 4 , 43 @ @ import akka . actor . _ < nl > import akka . cluster . pubsub . DistributedPubSubMediator . { Subscribe , SubscribeAck } < nl > import akka . event . Logging < nl > import akka . http . scaladsl . model . Uri < nl > - import akka . stream . Materializer < nl > import akka . util . Timeout < nl > import com . sksamuel . scrimage . Image < nl > import com . sksamuel . scrimage . nio . JpegWriter < nl > import im . actor . api . rpc . files . ApiFastThumb < nl > import im . actor . api . rpc . messaging . _ < nl > - import im . actor . server . db . DbExtension < nl > import im . actor . server . file . _ < nl > + import im . actor . server . messaging . MessageUpdating < nl > import im . actor . server . pubsub . { PeerMessage , PubSubExtension } < nl > import im . actor . util . log . AnyRefLogSource < nl > import org . joda . time . DateTime < nl > - import slick . driver . PostgresDriver . api . _ < nl > < nl > - import scala . concurrent . ExecutionContextExecutor < nl > import scala . concurrent . duration . _ < nl > import scala . util . { Failure , Success , Try } < nl > < nl > object RichMessageWorker { < nl > val groupId = Some ( " RichMessageWorker " ) < nl > < nl > - def startWorker ( config : RichMessageConfig ) ( < nl > - implicit < nl > - system : ActorSystem , < nl > - materializer : Materializer < nl > - ) : ActorRef = system . actorOf ( Props ( classOf [ RichMessageWorker ] , config , materializer ) , " rich - message - worker " ) < nl > + def startWorker ( config : RichMessageConfig ) ( implicit system : ActorSystem ) : ActorRef = < nl > + system . actorOf ( Props ( classOf [ RichMessageWorker ] , config ) , " rich - message - worker " ) < nl > } < nl > < nl > - final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : Materializer ) extends Actor with ActorLogging { < nl > + final class RichMessageWorker ( config : RichMessageConfig ) extends Actor with ActorLogging with MessageUpdating { < nl > < nl > import AnyRefLogSource . _ < nl > import PreviewMaker . _ < nl > import RichMessageWorker . _ < nl > < nl > private implicit val system : ActorSystem = context . system < nl > - private implicit val ec : ExecutionContextExecutor = system . dispatcher < nl > + import system . dispatcher < nl > private implicit val timeout : Timeout = Timeout ( 10 . seconds ) < nl > < nl > - private val db = DbExtension ( system ) . db < nl > private val pubSubExt = PubSubExtension ( system ) < nl > - < nl > private val fsAdapter : FileStorageAdapter = FileStorageExtension ( context . system ) . fsAdapter < nl > < nl > override val log = Logging ( system , this ) < nl > < nl > - val previewMaker = PreviewMaker ( config , " previewMaker " ) < nl > + private val previewMaker = PreviewMaker ( config , " previewMaker " ) < nl > < nl > private val privateSubscribe = Subscribe ( pubSubExt . privateMessagesTopic , groupId , self ) < nl > private val publicSubscribe = Subscribe ( pubSubExt . groupMessagesTopic , None , self ) < nl > @ @ - 63 , 12 + 55 , 12 @ @ final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : < nl > if ( groupAckReceived ) < nl > context . become ( ready ) < nl > else < nl > - context . become ( subscribing ( true , groupAckReceived ) ) < nl > + context . become ( subscribing ( privateAckReceived = true , groupAckReceived = groupAckReceived ) ) < nl > case SubscribeAck ( ` publicSubscribe ` ) ⇒ < nl > if ( privateAckReceived ) < nl > context . become ( ready ) < nl > else < nl > - context . become ( subscribing ( privateAckReceived , true ) ) < nl > + context . become ( subscribing ( privateAckReceived , groupAckReceived = true ) ) < nl > } < nl > < nl > def ready : Receive = { < nl > @ @ - 78 , 43 + 70 , 40 @ @ final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : < nl > Try ( Uri ( text . trim ) ) match { < nl > case Success ( uri ) ⇒ < nl > log . debug ( " TextMessage with uri : { } " , uri ) < nl > - previewMaker ! GetPreview ( uri . toString ( ) , UpdateHandler . getHandler ( fromPeer , toPeer , randomId ) ) < nl > + previewMaker ! GetPreview ( uri . toString ( ) , fromPeer . id , toPeer , randomId ) < nl > case Failure ( _ ) ⇒ < nl > } < nl > case _ ⇒ < nl > } < nl > - case PreviewSuccess ( imageBytes , optFileName , mimeType , handler ) ⇒ < nl > - log . debug ( " PreviewSuccess for message with randomId : { } , fileName : { } , mimeType : { } " , handler . randomId , optFileName , mimeType ) < nl > + case PreviewSuccess ( imageBytes , optFileName , mimeType , clientUserId , peer , randomId ) ⇒ < nl > + log . debug ( " PreviewSuccess for message with randomId : { } , fileName : { } , mimeType : { } " , randomId , optFileName , mimeType ) < nl > val fullName = optFileName getOrElse { < nl > val name = ( new DateTime ) . toString ( " yyyyMMddHHmmss " ) < nl > val ext = Try ( mimeType . split ( " / " ) . last ) . getOrElse ( " tmp " ) < nl > s " $ name . $ ext " < nl > } < nl > val image = Image ( imageBytes . toArray ) . toPar < nl > - db . run { < nl > - for { < nl > - location ← fsAdapter . uploadFile ( UnsafeFileName ( fullName ) , imageBytes . toArray ) < nl > - thumb ← DBIO . from ( ImageUtils . scaleTo ( image , 90 ) ) < nl > - thumbBytes = thumb . toImage . forWriter ( JpegWriter ( ) ) . bytes < nl > - < nl > - _ = log . debug ( " uploaded file to location { } " , location ) < nl > - _ = log . debug ( " image with width : { } , height : { } " , image . width , image . height ) < nl > - < nl > - updated = ApiDocumentMessage ( < nl > - fileId = location . fileId , < nl > - accessHash = location . accessHash , < nl > - fileSize = imageBytes . size , < nl > - name = fullName , < nl > - mimeType = mimeType , < nl > - thumb = Some ( ApiFastThumb ( thumb . width , thumb . height , thumbBytes ) ) , < nl > - ext = Some ( ApiDocumentExPhoto ( image . width , image . height ) ) < nl > - ) < nl > - _ ← handler . handleDbUpdate ( updated ) < nl > - _ ← handler . handleUpdate ( updated ) < nl > - } yield ( ) < nl > - } < nl > - case PreviewFailure ( mess , handler ) ⇒ < nl > - log . debug ( " failed to make preview for message with randomId : { } , cause : { } " , handler . randomId , mess ) < nl > + for { < nl > + location ← fsAdapter . uploadFileF ( UnsafeFileName ( fullName ) , imageBytes . toArray ) < nl > + thumb ← ImageUtils . scaleTo ( image , 90 ) < nl > + thumbBytes = thumb . toImage . forWriter ( JpegWriter ( ) ) . bytes < nl > + < nl > + _ = log . debug ( " uploaded file to location { } " , location ) < nl > + _ = log . debug ( " image with width : { } , height : { } " , image . width , image . height ) < nl > + < nl > + updated = ApiDocumentMessage ( < nl > + fileId = location . fileId , < nl > + accessHash = location . accessHash , < nl > + fileSize = imageBytes . size , < nl > + name = fullName , < nl > + mimeType = mimeType , < nl > + thumb = Some ( ApiFastThumb ( thumb . width , thumb . height , thumbBytes ) ) , < nl > + ext = Some ( ApiDocumentExPhoto ( image . width , image . height ) ) < nl > + ) < nl > + _ ← updateMessageContent ( clientUserId , peer , randomId , updated ) < nl > + } yield ( ) < nl > + case PreviewFailure ( mess , randomId ) ⇒ < nl > + log . debug ( " failed to make preview for message with randomId : { } , cause : { } " , randomId , mess ) < nl > } < nl > < nl > } < nl > diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / UpdateHandler . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / UpdateHandler . scala < nl > deleted file mode 100644 < nl > index 5af8f06 . . 0000000 < nl > - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / UpdateHandler . scala < nl > + + + / dev / null < nl > @ @ - 1 , 81 + 0 , 0 @ @ < nl > - package im . actor . server . enrich < nl > - < nl > - import akka . actor . ActorSystem < nl > - import im . actor . api . rpc . Implicits . _ < nl > - import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } < nl > - import im . actor . server . model . { Peer , PeerType } < nl > - import im . actor . server . persist . { GroupUserRepo , HistoryMessageRepo } < nl > - import im . actor . server . sequence . SeqState < nl > - import im . actor . server . user . UserExtension < nl > - import slick . dbio . _ < nl > - < nl > - object UpdateHandler { < nl > - def getHandler ( fromPeer : Peer , toPeer : Peer , randomId : Long ) ( implicit system : ActorSystem ) : UpdateHandler = < nl > - toPeer . typ match { < nl > - case PeerType . Group ⇒ new GroupHandler ( toPeer , randomId ) < nl > - case PeerType . Private ⇒ new PrivateHandler ( fromPeer , toPeer , randomId ) < nl > - case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) < nl > - } < nl > - } < nl > - < nl > - abstract class UpdateHandler ( val randomId : Long ) { < nl > - def handleDbUpdate ( message : ApiMessage ) : DBIO [ Int ] < nl > - < nl > - def handleUpdate ( message : ApiMessage ) : DBIO [ Seq [ SeqState ] ] < nl > - } < nl > - < nl > - class PrivateHandler ( fromPeer : Peer , toPeer : Peer , randomId : Long ) ( implicit system : ActorSystem ) extends UpdateHandler ( randomId ) { < nl > - import system . dispatcher < nl > - < nl > - require ( fromPeer . typ = = PeerType . Private < nl > - & & toPeer . typ = = PeerType . Private , " Peers must be private " ) < nl > - < nl > - def handleUpdate ( message : ApiMessage ) : DBIO [ Seq [ SeqState ] ] = < nl > - DBIO . from ( for { < nl > - fromUpdate ← UserExtension ( system ) . broadcastUserUpdate ( < nl > - fromPeer . id , < nl > - UpdateMessageContentChanged ( toPeer . asStruct , randomId , message ) , None , false , reduceKey = None , deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > - ) < nl > - toUpdate ← UserExtension ( system ) . broadcastUserUpdate ( < nl > - toPeer . id , < nl > - UpdateMessageContentChanged ( fromPeer . asStruct , randomId , message ) , None , false , reduceKey = None , deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > - ) < nl > - } yield Seq ( fromUpdate , toUpdate ) ) < nl > - < nl > - def handleDbUpdate ( message : ApiMessage ) : DBIO [ Int ] = HistoryMessageRepo . updateContentAll ( < nl > - userIds = Set ( fromPeer . id , toPeer . id ) , < nl > - randomId = randomId , < nl > - peerType = PeerType . Private , < nl > - peerIds = Set ( fromPeer . id , toPeer . id ) , < nl > - messageContentHeader = message . header , < nl > - messageContentData = message . toByteArray < nl > - ) < nl > - } < nl > - < nl > - class GroupHandler ( groupPeer : Peer , randomId : Long ) ( implicit system : ActorSystem ) extends UpdateHandler ( randomId ) { < nl > - import system . dispatcher < nl > - < nl > - require ( groupPeer . typ = = PeerType . Group , " Peer must be a group " ) < nl > - < nl > - def handleUpdate ( message : ApiMessage ) : DBIO [ Seq [ SeqState ] ] = { < nl > - val update = UpdateMessageContentChanged ( groupPeer . asStruct , randomId , message ) < nl > - for { < nl > - usersIds ← GroupUserRepo . findUserIds ( groupPeer . id ) < nl > - seqstate ← DBIO . from ( UserExtension ( system ) . broadcastUsersUpdate ( usersIds . toSet , update , None , false , deliveryId = Some ( s " msgcontent _ $ { randomId } " ) ) ) < nl > - } yield seqstate < nl > - } < nl > - < nl > - def handleDbUpdate ( message : ApiMessage ) : DBIO [ Int ] = < nl > - for { < nl > - usersIds ← GroupUserRepo . findUserIds ( groupPeer . id ) < nl > - result ← HistoryMessageRepo . updateContentAll ( < nl > - userIds = usersIds . toSet , < nl > - randomId = randomId , < nl > - peerType = PeerType . Group , < nl > - peerIds = Set ( groupPeer . id ) , < nl > - messageContentHeader = message . header , < nl > - messageContentData = message . toByteArray < nl > - ) < nl > - } yield result < nl > - < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala < nl > deleted file mode 100644 < nl > index 649b441 . . 0000000 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala < nl > + + + / dev / null < nl > @ @ - 1 , 8 + 0 , 0 @ @ < nl > - package im . actor . server . api . rpc . service . messaging < nl > - < nl > - import com . google . protobuf . CodedInputStream < nl > - import im . actor . api . rpc . messaging . ApiMessage < nl > - < nl > - trait MessageParsing { < nl > - def parseMessage ( body : Array [ Byte ] ) : Either [ Any , ApiMessage ] = ApiMessage . parseFrom ( CodedInputStream . newInstance ( body ) ) < nl > - } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > index af429e1 . . 0e70104 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > @ @ - 7 , 9 + 7 , 8 @ @ import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . misc . _ < nl > import im . actor . api . rpc . peers . _ < nl > import im . actor . config . ActorConfig < nl > - import im . actor . server . model . { PeerType , Peer } < nl > + import im . actor . server . messaging . { MessageParsing , MessageUpdating } < nl > import im . actor . server . persist . HistoryMessageRepo < nl > - import im . actor . server . sequence . SeqState < nl > < nl > import scala . concurrent . _ < nl > import scala . concurrent . duration . _ < nl > @ @ - 21 , 7 + 20 , 9 @ @ object MessagingRpcErors { < nl > val IntenalError = RpcError ( 500 , " INTERNAL _ ERROR " , " " , false , None ) < nl > } < nl > < nl > - private [ messaging ] trait MessagingHandlers extends PeersImplicits with MessageParsing { < nl > + private [ messaging ] trait MessagingHandlers extends PeersImplicits < nl > + with MessageParsing < nl > + with MessageUpdating { < nl > this : MessagingServiceImpl ⇒ < nl > < nl > import FutureResultRpc . _ < nl > @ @ - 62 , 7 + 63 , 7 @ @ private [ messaging ] trait MessagingHandlers extends PeersImplicits with MessagePa < nl > case _ : ApiTextMessage ⇒ true < nl > case _ ⇒ false < nl > } ) < nl > - result ← fromFuture ( updateMessageContent ( peer , randomId , updatedMessage ) ) < nl > + result ← fromFuture ( updateMessageContent ( client . userId , peer , randomId , updatedMessage ) ) < nl > date = System . currentTimeMillis < nl > } yield ResponseSeqDate ( result . seq , result . state . toByteArray , date ) ) . value < nl > } < nl > @ @ - 73 , 74 + 74 , 4 @ @ private [ messaging ] trait MessagingHandlers extends PeersImplicits with MessagePa < nl > ( messageDateMillis + editTimeWindow ) > System . currentTimeMillis < nl > } < nl > < nl > - / / TODO : move to trait and reuse < nl > - private def updateMessageContent ( peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit client : AuthorizedClientData ) : Future [ SeqState ] = peer match { < nl > - case Peer ( PeerType . Private , _ ) ⇒ updateContentPrivate ( client . userId , peer , randomId , updatedMessage ) < nl > - case Peer ( PeerType . Group , _ ) ⇒ updateContentGroup ( client . userId , peer , randomId , updatedMessage ) < nl > - } < nl > - < nl > - private def updateContentPrivate ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) : Future [ SeqState ] = { < nl > - for { < nl > - / / update for client himself < nl > - seqState ← userExt . broadcastUserUpdate ( < nl > - userId = userId , < nl > - update = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) , < nl > - pushText = None , < nl > - isFat = false , < nl > - reduceKey = None , < nl > - deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > - ) < nl > - / / update for peer user < nl > - _ ← userExt . broadcastUserUpdate ( < nl > - userId = peer . id , < nl > - update = UpdateMessageContentChanged ( ApiPeer ( ApiPeerType . Private , userId ) , randomId , updatedMessage ) , < nl > - pushText = None , < nl > - isFat = false , < nl > - reduceKey = None , < nl > - deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > - ) < nl > - _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > - userIds = Set ( userId , peer . id ) , < nl > - randomId = randomId , < nl > - peerType = PeerType . Private , < nl > - peerIds = Set ( userId , peer . id ) , < nl > - messageContentHeader = updatedMessage . header , < nl > - messageContentData = updatedMessage . toByteArray < nl > - ) ) < nl > - } yield seqState < nl > - } < nl > - < nl > - private def updateContentGroup ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) : Future [ SeqState ] = { < nl > - val upd = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) < nl > - for { < nl > - / / update for client user < nl > - seqState ← userExt . broadcastUserUpdate ( < nl > - userId = userId , < nl > - update = upd , < nl > - pushText = None , < nl > - isFat = false , < nl > - reduceKey = None , < nl > - deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > - ) < nl > - ( memberIds , _ , _ ) ← groupExt . getMemberIds ( peer . id ) < nl > - membersSet = memberIds . toSet < nl > - / / update for other group members < nl > - _ ← userExt . broadcastUsersUpdate ( < nl > - userIds = membersSet - userId , < nl > - update = upd , < nl > - pushText = None , < nl > - isFat = false , < nl > - deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > - ) < nl > - _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > - userIds = membersSet , < nl > - randomId = randomId , < nl > - peerType = PeerType . Group , < nl > - peerIds = Set ( peer . id ) , < nl > - messageContentHeader = updatedMessage . header , < nl > - messageContentData = updatedMessage . toByteArray < nl > - ) ) < nl > - } yield seqState < nl > - } < nl > - < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / enrich / PreviewMakerSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / enrich / PreviewMakerSpec . scala < nl > index 75e273c . . aa83369 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / enrich / PreviewMakerSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / enrich / PreviewMakerSpec . scala < nl > @ @ - 1 , 5 + 1 , 7 @ @ < nl > package im . actor . server . enrich < nl > < nl > + import im . actor . server . model . { PeerType , Peer } < nl > + < nl > import scala . concurrent . duration . _ < nl > < nl > import akka . actor . ActorRef < nl > @ @ - 61 , 7 + 63 , 7 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { < nl > sendGetPreview ( previewMaker , image . url ) < nl > probe watch previewMaker < nl > probe . expectMsgPF ( 10 . seconds ) { < nl > - case PreviewSuccess ( content , fileName , mimeType , _ ) ⇒ < nl > + case PreviewSuccess ( content , fileName , mimeType , _ , _ , _ ) ⇒ < nl > content should not be empty < nl > content . length shouldEqual image . contentLength < nl > fileName shouldEqual image . fileName < nl > @ @ - 75 , 7 + 77 , 7 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { < nl > sendGetPreview ( previewMaker , image . url ) < nl > probe watch previewMaker < nl > probe . expectMsgPF ( 10 . seconds ) { < nl > - case PreviewSuccess ( content , fileName , mimeType , _ ) ⇒ < nl > + case PreviewSuccess ( content , fileName , mimeType , _ , _ , _ ) ⇒ < nl > content should not be empty < nl > content . length shouldEqual image . contentLength < nl > fileName shouldEqual image . fileName < nl > @ @ - 101 , 7 + 103 , 7 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { < nl > sendGetPreview ( previewMaker , image . url ) < nl > probe watch previewMaker < nl > probe . expectMsgPF ( 10 . seconds ) { < nl > - case PreviewSuccess ( content , fileName , mimeType , _ ) ⇒ < nl > + case PreviewSuccess ( content , fileName , mimeType , _ , _ , _ ) ⇒ < nl > content should not be empty < nl > fileName shouldEqual image . fileName < nl > mimeType shouldEqual image . mimeType < nl > @ @ - 114 , 7 + 116 , 7 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { < nl > sendGetPreview ( previewMaker , image . url ) < nl > probe watch previewMaker < nl > probe . expectMsgPF ( 10 . seconds ) { < nl > - case PreviewSuccess ( content , fileName , mimeType , _ ) ⇒ < nl > + case PreviewSuccess ( content , fileName , mimeType , _ , _ , _ ) ⇒ < nl > content should not be empty < nl > fileName shouldEqual image . fileName < nl > mimeType shouldEqual image . mimeType < nl > @ @ - 124 , 14 + 126 , 9 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { < nl > } < nl > } < nl > < nl > - class DummyUpdateHandler extends UpdateHandler ( 0L ) { < nl > - def handleDbUpdate ( message : ApiMessage ) = ? ? ? < nl > - def handleUpdate ( message : ApiMessage ) = ? ? ? < nl > - } < nl > - < nl > protected def sendGetPreview ( previewMaker : ActorRef , url : String ) ( implicit probe : TestProbe ) = { < nl > previewMaker . tell ( < nl > - GetPreview ( url , new DummyUpdateHandler ( ) ) , < nl > + GetPreview ( url , 0 , Peer ( PeerType . Private , 0 ) , 0L ) , < nl > probe . ref < nl > ) < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / EchoBot . scala b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / EchoBot . scala < nl > new file mode 100644 < nl > index 0000000 . . 5e21dee < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / EchoBot . scala < nl > @ @ - 0 , 0 + 1 , 28 @ @ < nl > + package im . actor . bot . remote < nl > + < nl > + import akka . actor . { Props , ActorSystem } < nl > + import im . actor . bot . BotMessages . TextMessage < nl > + < nl > + object EchoBotApp extends App { < nl > + implicit val system = ActorSystem ( ) < nl > + < nl > + val token = " e296e29479a6933923119bec40ff46b408ff4d34 " < nl > + < nl > + system . actorOf ( < nl > + EchoBot . props ( token , " ws : / / localhost : 9090 " ) , < nl > + " EchoBot " < nl > + ) < nl > + < nl > + system . awaitTermination ( ) < nl > + } < nl > + < nl > + object EchoBot { < nl > + def props ( token : String , endpoint : String = " wss : / / front1 - ws - mtproto - api - rev2 - dev1 . actor . im : 443 " ) = < nl > + Props ( classOf [ EchoBot ] , token , endpoint ) < nl > + } < nl > + < nl > + final class EchoBot ( token : String , endpoint : String ) extends RemoteBot ( token , endpoint ) { < nl > + override protected def onTextMessage ( tm : TextMessage ) : Unit = { < nl > + sendTextMessage ( outPeer ( tm . sender ) , s " Hey , here is your reply : $ { tm . text } " ) < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBot . scala b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBot . scala < nl > new file mode 100644 < nl > index 0000000 . . 5e0d9bd < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBot . scala < nl > @ @ - 0 , 0 + 1 , 64 @ @ < nl > + package im . actor . bot . remote < nl > + < nl > + import java . net . URLEncoder < nl > + < nl > + import akka . actor . _ < nl > + import akka . stream . scaladsl . { Sink , Source } < nl > + import akka . stream . { ActorMaterializer , OverflowStrategy } < nl > + import im . actor . bot . { BotMessageOut , BotBase , BotMessages } < nl > + import upickle . default . _ < nl > + < nl > + import scala . concurrent . forkjoin . ThreadLocalRandom < nl > + import scala . reflect . ClassTag < nl > + < nl > + object RemoteBot { < nl > + val DefaultEndpoint = " wss : / / front1 - ws - mtproto - api - rev2 - dev1 . actor . im : 443 " < nl > + } < nl > + < nl > + abstract class RemoteBot ( token : String , endpoint : String ) extends BotBase with Actor with ActorLogging { < nl > + < nl > + import BotMessages . _ < nl > + < nl > + private implicit val mat = ActorMaterializer ( ) < nl > + < nl > + private var rqSource = initFlow ( ) < nl > + private var rqCounter : Long = 0 < nl > + < nl > + def receive : Receive = { < nl > + case ConnectionClosed ⇒ < nl > + log . warning ( " Disconnected , reinitiating flow " ) < nl > + rqSource = initFlow ( ) < nl > + case Status . Failure ( e ) ⇒ < nl > + log . error ( e , " Error in a stream , restarting " ) < nl > + throw e < nl > + case tm : TextMessage ⇒ < nl > + log . info ( " Received text message { } " , tm ) < nl > + onTextMessage ( tm ) < nl > + case rsp : BotResponse ⇒ < nl > + log . info ( " Response : { } " , rsp . body ) < nl > + case unmatched ⇒ < nl > + log . error ( " Unmatched { } " , unmatched ) < nl > + } < nl > + < nl > + override protected def sendTextMessage ( peer : OutPeer , text : String ) : Unit = { < nl > + log . info ( " Sending message , peer : { } , text : { } " , peer , text ) < nl > + log . info ( " rqSource { } " , rqSource ) < nl > + rqSource ! nextRequest ( SendTextMessage ( peer , ThreadLocalRandom . current ( ) . nextLong ( ) , text ) ) < nl > + } < nl > + < nl > + private def nextRequest ( body : RequestBody ) : BotRequest = { < nl > + rqCounter + = 1 < nl > + BotRequest ( rqCounter , body ) < nl > + } < nl > + < nl > + private def initFlow ( ) : ActorRef = { < nl > + val ( wsSource , wsSink ) = WebsocketClient . sourceAndSink ( s " $ { endpoint } / v1 / bots / $ { URLEncoder . encode ( token , " UTF - 8 " ) } " ) < nl > + < nl > + wsSource . map ( read [ BotMessageOut ] ) . to ( Sink . actorRef ( self , ConnectionClosed ) ) . run ( ) < nl > + < nl > + Source . actorRef ( bufferSize = 100 , overflowStrategy = OverflowStrategy . fail ) < nl > + . map ( write [ BotRequest ] ) < nl > + . to ( wsSink ) < nl > + . run ( ) < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBotBlueprint . scala b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBotBlueprint . scala < nl > new file mode 100644 < nl > index 0000000 . . 81d595a < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBotBlueprint . scala < nl > @ @ - 0 , 0 + 1 , 13 @ @ < nl > + package im . actor . bot . remote < nl > + < nl > + import akka . stream . scaladsl . _ < nl > + import upickle . default . _ < nl > + < nl > + object RemoteBotBlueprint { < nl > + import im . actor . bot . BotMessages . _ < nl > + < nl > + val flow = < nl > + Flow [ String ] < nl > + . map ( read [ BotUpdate ] ) < nl > + } < nl > + < nl > diff - - git a / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / WebsocketClient . scala b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / WebsocketClient . scala < nl > new file mode 100644 < nl > index 0000000 . . 810c383 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / WebsocketClient . scala < nl > @ @ - 0 , 0 + 1 , 142 @ @ < nl > + package im . actor . bot . remote < nl > + < nl > + import java . net . URI < nl > + < nl > + import akka . actor . { ActorLogging , ActorRefFactory , Props } < nl > + import akka . io . IO < nl > + import akka . stream . actor . _ < nl > + import akka . stream . scaladsl . { Sink , Source } < nl > + import spray . can . server . UHttp < nl > + import spray . can . websocket . frame . { Frame , TextFrame } < nl > + import spray . can . { Http , websocket } < nl > + import spray . http . { HttpHeaders , HttpMethods , HttpRequest } < nl > + import spray . io . ServerSSLEngineProvider < nl > + < nl > + import scala . annotation . tailrec < nl > + < nl > + final case object ConnectionClosed < nl > + < nl > + object WebsocketClient { < nl > + def sourceAndSink ( url : String ) ( implicit context : ActorRefFactory ) = { < nl > + val actor = context . actorOf ( props ( url ) ) < nl > + < nl > + ( Source ( ActorPublisher [ String ] ( actor ) ) , Sink ( ActorSubscriber [ String ] ( actor ) ) ) < nl > + } < nl > + < nl > + def props ( url : String ) = Props ( classOf [ WebsocketClient ] , url ) < nl > + } < nl > + < nl > + final class WebsocketClient ( url : String ) < nl > + extends ActorPublisher [ String ] < nl > + with ActorSubscriber < nl > + with ActorLogging { < nl > + import context . system < nl > + < nl > + implicit def sslEngineProvider : ServerSSLEngineProvider = { < nl > + ServerSSLEngineProvider { engine ⇒ < nl > + engine . setEnabledCipherSuites ( Array ( " TLS _ RSA _ WITH _ AES _ 256 _ CBC _ SHA " ) ) < nl > + engine . setEnabledProtocols ( Array ( " SSLv3 " , " TLSv1 " ) ) < nl > + engine < nl > + } < nl > + } < nl > + < nl > + abstract class WebSocketClient ( connect : Http . Connect , val upgradeRequest : HttpRequest ) extends websocket . WebSocketClientWorker { < nl > + IO ( UHttp ) ! connect < nl > + < nl > + def businessLogic : Receive = { < nl > + case frame : Frame ⇒ < nl > + onMessage ( frame ) < nl > + case str : String ⇒ < nl > + connection ! TextFrame ( str ) < nl > + case _ : Http . ConnectionClosed ⇒ < nl > + onClose ( ) < nl > + context . stop ( self ) < nl > + } < nl > + < nl > + def onMessage ( frame : Frame ) : Unit < nl > + < nl > + def onClose ( ) : Unit < nl > + } < nl > + < nl > + val uri = new URI ( url ) < nl > + val ssl = uri . getScheme = = " wss " < nl > + val host = uri . getHost < nl > + val port = uri . getPort match { < nl > + case - 1 ⇒ if ( ssl ) 443 else 80 < nl > + case p ⇒ p < nl > + } < nl > + < nl > + val agent = " spray - websocket - client " + ( if ( ssl ) " - ssl " else " - basic " ) < nl > + val headers = List ( < nl > + HttpHeaders . Host ( host , port ) , < nl > + HttpHeaders . Connection ( " Upgrade " ) , < nl > + HttpHeaders . RawHeader ( " Upgrade " , " websocket " ) , < nl > + HttpHeaders . RawHeader ( " Sec - WebSocket - Version " , " 13 " ) , < nl > + HttpHeaders . RawHeader ( " Sec - WebSocket - Key " , " x3JJHMbDL1EzLkh9GBhXDw = = " ) , < nl > + HttpHeaders . RawHeader ( " Sec - WebSocket - Extensions " , " permessage - deflate " ) < nl > + ) < nl > + < nl > + val connect = Http . Connect ( host , port , ssl ) < nl > + < nl > + log . info ( " Connecting to { } " , url ) < nl > + < nl > + val req = HttpRequest ( HttpMethods . GET , spray . http . Uri ( Option ( uri . getPath ) . getOrElse ( " / " ) ) , headers ) < nl > + val client = context . actorOf ( Props ( < nl > + new WebSocketClient ( connect , req ) { < nl > + override def onMessage ( frame : Frame ) = { < nl > + context . parent ! frame < nl > + } < nl > + < nl > + override def onClose ( ) = { < nl > + context . parent ! ConnectionClosed < nl > + } < nl > + } < nl > + ) ) < nl > + < nl > + private var receivedBuf = Vector . empty [ String ] < nl > + < nl > + def receive = { < nl > + case TextFrame ( text ) ⇒ < nl > + val str = text . decodeString ( " UTF - 8 " ) < nl > + log . info ( " Received { } " , str ) < nl > + if ( receivedBuf . isEmpty & & totalDemand > 0 ) < nl > + onNext ( str ) < nl > + else { < nl > + receivedBuf : + = str < nl > + deliverBuf ( ) < nl > + } < nl > + case frame : Frame ⇒ < nl > + log . info ( " Unsupported frame { } " , frame ) < nl > + case ActorPublisherMessage . Request ( _ ) ⇒ < nl > + deliverBuf ( ) < nl > + case ActorPublisherMessage . Cancel ⇒ < nl > + context . stop ( self ) < nl > + case ActorSubscriberMessage . OnNext ( textToSend : String ) ⇒ < nl > + client ! textToSend < nl > + case ConnectionClosed ⇒ < nl > + log . error ( " Connection closed " ) < nl > + onErrorThenStop ( new RuntimeException ( " Connection closed " ) ) < nl > + case unmatched ⇒ < nl > + log . error ( " Unmatched { } " , unmatched ) < nl > + } < nl > + < nl > + override val requestStrategy = new WatermarkRequestStrategy ( Int . MaxValue ) < nl > + < nl > + @ tailrec final def deliverBuf ( ) : Unit = < nl > + if ( totalDemand > 0 ) { < nl > + / * < nl > + * totalDemand is a Long and could be larger than < nl > + * what buf . splitAt can accept < nl > + * / < nl > + if ( totalDemand < = Int . MaxValue ) { < nl > + val ( use , keep ) = receivedBuf . splitAt ( totalDemand . toInt ) < nl > + receivedBuf = keep < nl > + use foreach onNext < nl > + } else { < nl > + val ( use , keep ) = receivedBuf . splitAt ( Int . MaxValue ) < nl > + receivedBuf = keep < nl > + use foreach onNext < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala < nl > deleted file mode 100644 < nl > index cd95997 . . 0000000 < nl > - - - a / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala < nl > + + + / dev / null < nl > @ @ - 1 , 38 + 0 , 0 @ @ < nl > - package im . actor . bot < nl > - < nl > - import derive . key < nl > - < nl > - sealed trait BotMessage < nl > - sealed trait BotMessageIn extends BotMessage < nl > - sealed trait BotMessageOut extends BotMessage < nl > - < nl > - final object BotMessages { < nl > - final object OutPeer { < nl > - def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) < nl > - def group ( id : Int , accessHash : Long ) = OutPeer ( 2 , id , accessHash ) < nl > - } < nl > - final case class OutPeer ( ` type ` : Int , id : Int , accessHash : Long ) < nl > - final case class Peer ( ` type ` : Int , id : Int ) < nl > - < nl > - sealed trait RequestBody < nl > - < nl > - final case class BotRequest ( id : Long , body : RequestBody ) extends BotMessageIn < nl > - < nl > - @ key ( " SendMessage " ) < nl > - final case class SendTextMessage ( peer : OutPeer , randomId : Long , message : String ) extends RequestBody < nl > - < nl > - sealed trait ResponseBody < nl > - < nl > - final case class BotResponse ( id : Long , body : ResponseBody ) extends BotMessageOut < nl > - < nl > - @ key ( " MessageSent " ) < nl > - final case class MessageSent ( date : Long ) extends ResponseBody < nl > - < nl > - sealed trait BotUpdate extends BotMessageOut < nl > - < nl > - @ key ( " TextMessage " ) < nl > - final case class TextMessage ( peer : OutPeer , senderUserId : Int , date : Long , randomId : Long , text : String ) extends BotUpdate < nl > - < nl > - final def isPrivate ( peer : OutPeer ) = peer . ` type ` = = 1 < nl > - final def isGroup ( peer : OutPeer ) = peer . ` type ` = = 2 < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotBase . scala b / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotBase . scala < nl > new file mode 100644 < nl > index 0000000 . . c940421 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotBase . scala < nl > @ @ - 0 , 0 + 1 , 11 @ @ < nl > + package im . actor . bot < nl > + < nl > + trait BotBase { < nl > + import BotMessages . _ < nl > + < nl > + protected def onTextMessage ( tm : TextMessage ) : Unit < nl > + < nl > + protected def sendTextMessage ( peer : OutPeer , text : String ) : Unit < nl > + < nl > + protected def outPeer ( userOutPeer : UserOutPeer ) = OutPeer ( 1 , userOutPeer . id , userOutPeer . accessHash ) < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotMessages . scala b / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotMessages . scala < nl > new file mode 100644 < nl > index 0000000 . . dd99373 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotMessages . scala < nl > @ @ - 0 , 0 + 1 , 41 @ @ < nl > + package im . actor . bot < nl > + < nl > + import derive . key < nl > + < nl > + sealed trait BotMessage < nl > + sealed trait BotMessageIn extends BotMessage < nl > + sealed trait BotMessageOut extends BotMessage < nl > + < nl > + final object BotMessages { < nl > + final object OutPeer { < nl > + def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) < nl > + def group ( id : Int , accessHash : Long ) = OutPeer ( 2 , id , accessHash ) < nl > + } < nl > + final case class OutPeer ( ` type ` : Int , id : Int , accessHash : Long ) < nl > + final case class UserOutPeer ( id : Int , accessHash : Long ) < nl > + final case class Peer ( ` type ` : Int , id : Int ) < nl > + < nl > + sealed trait RequestBody < nl > + < nl > + final case class BotRequest ( id : Long , body : RequestBody ) extends BotMessageIn < nl > + < nl > + @ key ( " SendMessage " ) < nl > + final case class SendTextMessage ( peer : OutPeer , randomId : Long , text : String ) extends RequestBody < nl > + < nl > + sealed trait ResponseBody < nl > + < nl > + @ key ( " Response " ) < nl > + final case class BotResponse ( id : Long , body : ResponseBody ) extends BotMessageOut < nl > + < nl > + @ key ( " MessageSent " ) < nl > + final case class MessageSent ( date : Long ) extends ResponseBody < nl > + < nl > + @ key ( " Update " ) < nl > + sealed trait BotUpdate extends BotMessageOut < nl > + < nl > + @ key ( " TextMessage " ) < nl > + final case class TextMessage ( peer : OutPeer , sender : UserOutPeer , date : Long , randomId : Long , text : String ) extends BotUpdate < nl > + < nl > + final def isPrivate ( peer : OutPeer ) = peer . ` type ` = = 1 < nl > + final def isGroup ( peer : OutPeer ) = peer . ` type ` = = 2 < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotBlueprint . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotBlueprint . scala < nl > deleted file mode 100644 < nl > index cf5f910 . . 0000000 < nl > - - - a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotBlueprint . scala < nl > + + + / dev / null < nl > @ @ - 1 , 63 + 0 , 0 @ @ < nl > - package im . actor . server . bot < nl > - < nl > - import akka . actor . ActorSystem < nl > - import akka . stream . scaladsl . { Flow , Merge , Source } < nl > - import im . actor . api . rpc . messaging . ApiTextMessage < nl > - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > - import im . actor . bot . { BotMessageOut , BotMessages } < nl > - import im . actor . server . dialog . DialogExtension < nl > - import im . actor . server . sequence . SeqStateDate < nl > - < nl > - import scala . concurrent . Future < nl > - < nl > - final class BotBlueprint ( botUserId : Int , botAuthId : Long , system : ActorSystem ) { < nl > - < nl > - import BotMessages . _ < nl > - import akka . stream . scaladsl . FlowGraph . Implicits . _ < nl > - import system . _ < nl > - < nl > - private lazy val dialogExt = DialogExtension ( system ) < nl > - < nl > - val flow : Flow [ BotRequest , BotMessageOut , Unit ] = { < nl > - val updSource = < nl > - Source . actorPublisher [ BotMessageOut ] ( UpdatesSource . props ( botAuthId ) ) < nl > - < nl > - val rqrspFlow = Flow [ BotRequest ] < nl > - . mapAsync ( 1 ) ( r ⇒ handleRequest ( r . id , r . body ) ) < nl > - . map ( _ . asInstanceOf [ BotMessageOut ] ) < nl > - < nl > - Flow ( ) { implicit b ⇒ < nl > - val upd = b . add ( updSource ) < nl > - val rqrsp = b . add ( rqrspFlow ) < nl > - val merge = b . add ( Merge [ BotMessageOut ] ( 2 ) ) < nl > - < nl > - upd ~ > merge < nl > - rqrsp ~ > merge < nl > - < nl > - ( rqrsp . inlet , merge . out ) < nl > - } < nl > - } < nl > - < nl > - private def handleRequest ( id : Long , body : RequestBody ) : Future [ BotResponse ] = < nl > - for { < nl > - response ← handleRequestBody ( body ) < nl > - } yield BotResponse ( id , response ) < nl > - < nl > - private def handleRequestBody ( body : RequestBody ) : Future [ ResponseBody ] = body match { < nl > - case SendTextMessage ( peer , randomId , message ) ⇒ sendTextMessage ( peer , randomId , message ) < nl > - } < nl > - < nl > - private def sendTextMessage ( peer : OutPeer , randomId : Long , message : String ) : Future [ ResponseBody ] = { < nl > - / / FIXME : check access hash < nl > - for { < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( < nl > - peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , < nl > - senderUserId = botUserId , < nl > - senderAuthId = 0L , < nl > - randomId = randomId , < nl > - message = ApiTextMessage ( message , Vector . empty , None ) , < nl > - isFat = false < nl > - ) < nl > - } yield MessageSent ( date ) < nl > - } < nl > - } < nl > diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala < nl > new file mode 100644 < nl > index 0000000 . . a0015d0 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala < nl > @ @ - 0 , 0 + 1 , 63 @ @ < nl > + package im . actor . server . bot < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . stream . scaladsl . { Flow , Merge , Source } < nl > + import im . actor . api . rpc . messaging . ApiTextMessage < nl > + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . bot . { BotMessageOut , BotMessages } < nl > + import im . actor . server . dialog . DialogExtension < nl > + import im . actor . server . sequence . SeqStateDate < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + final class BotServerBlueprint ( botUserId : Int , botAuthId : Long , system : ActorSystem ) { < nl > + < nl > + import BotMessages . _ < nl > + import akka . stream . scaladsl . FlowGraph . Implicits . _ < nl > + import system . _ < nl > + < nl > + private lazy val dialogExt = DialogExtension ( system ) < nl > + < nl > + val flow : Flow [ BotRequest , BotMessageOut , Unit ] = { < nl > + val updSource = < nl > + Source . actorPublisher [ BotMessageOut ] ( UpdatesSource . props ( botAuthId ) ) < nl > + < nl > + val rqrspFlow = Flow [ BotRequest ] < nl > + . mapAsync ( 1 ) ( r ⇒ handleRequest ( r . id , r . body ) ) < nl > + . map ( _ . asInstanceOf [ BotMessageOut ] ) < nl > + < nl > + Flow ( ) { implicit b ⇒ < nl > + val upd = b . add ( updSource ) < nl > + val rqrsp = b . add ( rqrspFlow ) < nl > + val merge = b . add ( Merge [ BotMessageOut ] ( 2 ) ) < nl > + < nl > + upd ~ > merge < nl > + rqrsp ~ > merge < nl > + < nl > + ( rqrsp . inlet , merge . out ) < nl > + } < nl > + } < nl > + < nl > + private def handleRequest ( id : Long , body : RequestBody ) : Future [ BotResponse ] = < nl > + for { < nl > + response ← handleRequestBody ( body ) < nl > + } yield BotResponse ( id , response ) < nl > + < nl > + private def handleRequestBody ( body : RequestBody ) : Future [ ResponseBody ] = body match { < nl > + case SendTextMessage ( peer , randomId , message ) ⇒ sendTextMessage ( peer , randomId , message ) < nl > + } < nl > + < nl > + private def sendTextMessage ( peer : OutPeer , randomId : Long , message : String ) : Future [ ResponseBody ] = { < nl > + / / FIXME : check access hash < nl > + for { < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( < nl > + peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , < nl > + senderUserId = botUserId , < nl > + senderAuthId = 0L , < nl > + randomId = randomId , < nl > + message = ApiTextMessage ( message , Vector . empty , None ) , < nl > + isFat = false < nl > + ) < nl > + } yield MessageSent ( date ) < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / InternalBot . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / InternalBot . scala < nl > index f4fcfca . . 59a4ff3 100644 < nl > - - - a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / InternalBot . scala < nl > + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / InternalBot . scala < nl > @ @ - 6 , 7 + 6 , 7 @ @ import akka . stream . ActorMaterializer < nl > import akka . stream . scaladsl . Sink < nl > import im . actor . api . rpc . messaging . ApiTextMessage < nl > import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } < nl > - import im . actor . bot . BotMessages < nl > + import im . actor . bot . { BotBase , BotMessages } < nl > import im . actor . server . dialog . DialogExtension < nl > < nl > import scala . concurrent . Future < nl > @ @ - 18 , 7 + 18 , 7 @ @ private object InternalBot { < nl > final case class Initialized ( authId : Long ) < nl > } < nl > < nl > - abstract class InternalBot ( userId : Int , nickname : String , name : String ) extends Actor with ActorLogging { < nl > + abstract class InternalBot ( userId : Int , nickname : String , name : String ) extends Actor with ActorLogging with BotBase { < nl > < nl > import BotMessages . _ < nl > import InternalBot . _ < nl > @ @ - 31 , 9 + 31 , 7 @ @ abstract class InternalBot ( userId : Int , nickname : String , name : String ) extends < nl > < nl > init ( ) < nl > < nl > - def onTextMessage ( tm : TextMessage ) : Unit < nl > - < nl > - protected def sendTextMessage ( peer : OutPeer , text : String ) : Unit = { < nl > + override protected def sendTextMessage ( peer : OutPeer , text : String ) : Unit = { < nl > / / FIXME : check access hash < nl > dialogExt . sendMessage ( < nl > peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , < nl > diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / UpdatesSource . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / UpdatesSource . scala < nl > index f2d1f51 . . 74be274 100644 < nl > - - - a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / UpdatesSource . scala < nl > + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / UpdatesSource . scala < nl > @ @ - 1 , 6 + 1 , 6 @ @ < nl > package im . actor . server . bot < nl > < nl > - import akka . actor . { ActorLogging , Props } < nl > + import akka . actor . { Stash , ActorLogging , Props } < nl > import akka . pattern . pipe < nl > import akka . stream . actor . ActorPublisher < nl > import akka . stream . scaladsl . Source < nl > @ @ - 8 , 15 + 8 , 22 @ @ import im . actor . api . rpc . codecs . _ < nl > import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateMessage } < nl > import im . actor . api . rpc . sequence . SeqUpdate < nl > import im . actor . bot . BotMessages < nl > - import im . actor . bot . BotMessages . { OutPeer , BotUpdate } < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . mtproto . protocol . UpdateBox < nl > import im . actor . server . presences . { GroupPresenceManager , PresenceManager } < nl > import im . actor . server . sequence . { UpdatesConsumer , WeakUpdatesManager } < nl > + import im . actor . server . user . UserExtension < nl > + import im . actor . server . persist < nl > < nl > import scala . annotation . tailrec < nl > < nl > private [ bot ] object UpdatesSource { < nl > + import BotMessages . _ < nl > + < nl > + private case class Initialized ( userId : Int ) < nl > + private case object AuthIdNotAuthorized < nl > + < nl > def source ( authId : Long ) = Source . actorPublisher [ BotUpdate ] ( props ( authId ) ) < nl > < nl > def props ( authId : Long ) = Props ( classOf [ UpdatesSource ] , authId ) < nl > @ @ - 24 , 10 + 31 , 10 @ @ private [ bot ] object UpdatesSource { < nl > private final case class Enqueue ( upd : BotUpdate ) < nl > } < nl > < nl > - private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotUpdate ] with ActorLogging { < nl > + private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotMessages . BotUpdate ] with ActorLogging with Stash { < nl > < nl > import UpdatesSource . _ < nl > - import BotMessages . TextMessage < nl > + import BotMessages . _ < nl > import akka . stream . actor . ActorPublisherMessage . _ < nl > import context . _ < nl > import im . actor . server . sequence . NewUpdate < nl > @ @ - 35 , 12 + 42 , 29 @ @ private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotUpdate ] with < nl > private implicit val weakUpdatesManagerRegion = WeakUpdatesManager . startRegionProxy ( ) < nl > private implicit val presenceManagerRegion = PresenceManager . startRegionProxy ( ) < nl > private implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegionProxy ( ) < nl > + private val userExt = UserExtension ( system ) < nl > + private val db = DbExtension ( system ) . db < nl > < nl > context . actorOf ( UpdatesConsumer . props ( authId , self ) , " updatesConsumer " ) < nl > < nl > private var buf = Vector . empty [ BotMessages . BotUpdate ] < nl > < nl > + db . run ( persist . AuthId . findUserId ( authId ) ) . map { < nl > + case Some ( userId ) ⇒ Initialized ( userId ) < nl > + case None ⇒ AuthIdNotAuthorized < nl > + } . pipeTo ( self ) < nl > + < nl > def receive = { < nl > + case Initialized ( userId ) ⇒ < nl > + context become working ( userId ) < nl > + case AuthIdNotAuthorized ⇒ < nl > + val msg = " AuthId not authorized " < nl > + log . error ( msg ) < nl > + throw new RuntimeException ( msg ) < nl > + case msg ⇒ stash ( ) < nl > + } < nl > + < nl > + def working ( userId : Int ) : Receive = { < nl > case Enqueue ( upd ) ⇒ enqueue ( upd ) < nl > case NewUpdate ( UpdateBox ( bodyBytes ) , _ ) ⇒ < nl > UpdateBoxCodec . decode ( bodyBytes ) . require . value match { < nl > @ @ - 51 , 18 + 75 , 21 @ @ private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotUpdate ] with < nl > case Right ( upd ) ⇒ < nl > upd . message match { < nl > case ApiTextMessage ( message , _ , _ ) ⇒ < nl > - log . debug ( " Received ApiTextMessage " ) < nl > - < nl > - ( for { < nl > - apiOutPeer ← ACLUtils . getOutPeer ( upd . peer , authId ) < nl > - } yield Enqueue ( TextMessage ( < nl > - peer = OutPeer ( apiOutPeer . ` type ` . id , apiOutPeer . id , apiOutPeer . accessHash ) , < nl > - senderUserId = upd . senderUserId , < nl > - date = upd . date , < nl > - randomId = upd . randomId , < nl > - text = message < nl > - ) ) ) pipeTo self < nl > - < nl > + if ( upd . senderUserId ! = userId ) { < nl > + log . debug ( " Received message { } " , message ) < nl > + ( for { < nl > + apiOutPeer ← ACLUtils . getOutPeer ( upd . peer , authId ) < nl > + senderAccessHash ← userExt . getAccessHash ( upd . senderUserId , authId ) < nl > + } yield Enqueue ( TextMessage ( < nl > + peer = OutPeer ( apiOutPeer . ` type ` . id , apiOutPeer . id , apiOutPeer . accessHash ) , < nl > + sender = UserOutPeer ( upd . senderUserId , senderAccessHash ) , < nl > + date = upd . date , < nl > + randomId = upd . randomId , < nl > + text = message < nl > + ) ) ) pipeTo self < nl > + } else { < nl > + log . debug ( " Message from self , ignoring " ) < nl > + } < nl > case _ ⇒ < nl > log . debug ( " Received non - text message , ignoring " ) < nl > } < nl > @ @ - 82 , 8 + 109 , 6 @ @ private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotUpdate ] with < nl > } < nl > < nl > private def enqueue ( upd : BotMessages . BotUpdate ) : Unit = { < nl > - log . debug ( " Enqueuing { } " , upd ) < nl > - < nl > if ( buf . isEmpty & & totalDemand > 0 ) { < nl > onNext ( upd ) < nl > } else { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > index f927d77 . . 41d633a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > @ @ - 36 , 6 + 36 , 7 @ @ private [ dialog ] final class ActorDelivery ( ) ( implicit val system : ActorSystem ) ex < nl > randomId = randomId , < nl > message = message < nl > ) < nl > + < nl > for { < nl > receiverAuthIds ← userExt . getAuthIds ( receiverUserId ) < nl > _ ← receiverAuthIds match { < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala < nl > index 204033d . . 12ee5c0 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala < nl > @ @ - 9 , 6 + 9 , 7 @ @ import akka . http . scaladsl . server . Route < nl > import akka . stream . Materializer < nl > import com . typesafe . config . Config < nl > import im . actor . server . api . http . app . AppFilesHandler < nl > + import im . actor . server . api . http . bots . BotsHandler < nl > import im . actor . server . api . http . groups . GroupsHandler < nl > import im . actor . server . api . http . status . StatusHandler < nl > import im . actor . server . api . http . webhooks . WebhooksHandler < nl > @ @ - 57 , 6 + 58 , 7 @ @ object HttpApiFrontend { < nl > val webhooks = new WebhooksHandler < nl > val groups = new GroupsHandler < nl > val status = new StatusHandler < nl > + val bots = new BotsHandler < nl > val app = new AppFilesHandler ( config . staticFiles ) < nl > < nl > / / format : OFF < nl > @ @ - 64 , 6 + 66 , 7 @ @ object HttpApiFrontend { < nl > app . routes ~ < nl > pathPrefix ( " v1 " ) { < nl > respondWithDefaultHeaders ( corsHeaders ) { < nl > + bots . routes ~ < nl > status . routes ~ < nl > groups . routes ~ < nl > webhooks . routes < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > index 57e8119 . . 18ac248 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > @ @ - 9 , 12 + 9 , 12 @ @ import cats . data . OptionT < nl > import cats . std . future . _ < nl > import im . actor . bot . BotMessages . { BotRequest , BotResponse , BotUpdate } < nl > import im . actor . server . api . http . RoutesHandler < nl > - import im . actor . server . bot . { BotBlueprint , BotExtension } < nl > + import im . actor . server . bot . { BotServerBlueprint , BotExtension } < nl > import upickle . default . _ < nl > < nl > import scala . util . control . NoStackTrace < nl > < nl > - private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler { < nl > + private [ http ] final class BotsHandler ( implicit system : ActorSystem ) extends RoutesHandler { < nl > < nl > import system . _ < nl > < nl > @ @ - 26 , 7 + 26 , 8 @ @ private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler < nl > authId ← OptionT ( botExt . getAuthId ( token ) ) < nl > } yield flow ( userId , authId ) ) . value map { < nl > case Some ( r ) ⇒ r < nl > - case None ⇒ throw new RuntimeException ( " Wrong token " ) with NoStackTrace < nl > + case None ⇒ < nl > + throw new RuntimeException ( " Wrong token " ) with NoStackTrace < nl > } < nl > < nl > onSuccess ( flowFuture ) { < nl > @ @ - 35 , 7 + 36 , 7 @ @ private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler < nl > } < nl > < nl > private def flow ( botUserId : Int , botAuthId : Long ) = { < nl > - val bp = new BotBlueprint ( botUserId , botAuthId , system ) < nl > + val bp = new BotServerBlueprint ( botUserId , botAuthId , system ) < nl > < nl > Flow [ Message ] < nl > . collect { < nl > @ @ - 44 , 8 + 45 , 15 @ @ private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler < nl > } < nl > . via ( bp . flow ) < nl > . map { < nl > - case rsp : BotResponse ⇒ write [ BotResponse ] ( rsp ) < nl > - case upd : BotUpdate ⇒ write [ BotUpdate ] ( upd ) < nl > + case rsp : BotResponse ⇒ < nl > + log . debug ( " Sending response { } " , rsp ) < nl > + write [ BotResponse ] ( rsp ) < nl > + case upd : BotUpdate ⇒ < nl > + log . debug ( " Sending update { } " , upd ) < nl > + write [ BotUpdate ] ( upd ) < nl > + case unmatched ⇒ < nl > + log . error ( " Unmatched { } " , unmatched ) < nl > + throw new RuntimeException ( s " Unmatched BotMessage $ { unmatched } " ) < nl > } < nl > . map ( TextMessage . Strict ( _ ) . asInstanceOf [ Message ] ) < nl > } < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index 36f9745 . . 07d520e 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 75 , 7 + 75 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > Revolver . settings + + < nl > Seq ( < nl > libraryDependencies + + = Dependencies . root , < nl > - Revolver . reStartArgs : = Seq ( " im . actor . server . Main " ) , < nl > + / / Revolver . reStartArgs : = Seq ( " im . actor . server . Main " ) , < nl > mainClass in Revolver . reStart : = Some ( " im . actor . server . Main " ) , < nl > mainClass in Compile : = Some ( " im . actor . server . Main " ) , < nl > autoCompilerPlugins : = true , < nl > @ @ - 91 , 6 + 91 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > / / actorDashboard , < nl > actorCore , < nl > actorBot , < nl > + actorBotKit , < nl > actorEmail , < nl > actorEnrich , < nl > actorFrontend , < nl > @ @ - 106 , 7 + 107 , 8 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > shardakka < nl > ) < nl > . settings ( < nl > - aggregate in Docker : = false < nl > + aggregate in Docker : = false , < nl > + aggregate in Revolver . reStart : = false < nl > ) < nl > < nl > lazy val actorRunner = Project ( < nl > @ @ - 142 , 11 + 144 , 19 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > Seq ( < nl > libraryDependencies + + = Dependencies . bot < nl > ) < nl > - ) . dependsOn ( actorBotMessages , shardakka , actorCore , actorTestkit % " test " ) < nl > + ) . dependsOn ( actorBotShared , shardakka , actorCore , actorTestkit % " test " ) < nl > < nl > - lazy val actorBotMessages = Project ( < nl > - id = " actor - bot - messages " , < nl > - base = file ( " actor - bot - messages " ) , < nl > + lazy val actorBotKit = Project ( < nl > + id = " actor - bot - kit " , < nl > + base = file ( " actor - bot - kit " ) , < nl > + settings = defaultSettings + + Revolver . settings + + Seq ( < nl > + libraryDependencies + + = Dependencies . botKit < nl > + ) < nl > + ) . dependsOn ( actorBotShared ) < nl > + < nl > + lazy val actorBotShared = Project ( < nl > + id = " actor - bot - shared " , < nl > + base = file ( " actor - bot - shared " ) , < nl > settings = defaultSettings + + < nl > Seq ( < nl > libraryDependencies + + = Dependencies . botMessages < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 8a7da4b . . fddf038 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 6 , 11 + 6 , 10 @ @ object Dependencies { < nl > object V { < nl > val akka = " 2 . 3 . 13 " < nl > val akkaExperimental = " 1 . 0 " < nl > + val cats = " 0 . 2 . 0 " < nl > val scalaz = " 7 . 1 . 1 " < nl > val slick = " 3 . 0 . 3 " < nl > val scalatest = " 2 . 2 . 4 " < nl > - val catsVersion = " 0 . 2 . 0 " < nl > - < nl > } < nl > < nl > object Compile { < nl > @ @ - 23 , 6 + 22 , 8 @ @ object Dependencies { < nl > val akkaHttpPlayJson = " de . heikoseeberger " % % " akka - http - play - json " % " 1 . 0 . 0 " < nl > val akkaSlf4j = " com . typesafe . akka " % % " akka - slf4j " % V . akka < nl > < nl > + val sprayWebsocket = " com . wandoulabs . akka " % % " spray - websocket " % " 0 . 1 . 4 " < nl > + < nl > val akkaPersistenceJdbc = " com . github . dnvriend " % % " akka - persistence - jdbc " % " 1 . 1 . 7 " < nl > val apacheEmail = " org . apache . commons " % " commons - email " % " 1 . 4 " < nl > < nl > @ @ - 30 , 7 + 31 , 7 @ @ object Dependencies { < nl > val caffeine = " com . github . ben - manes . caffeine " % " caffeine " % " 1 . 2 . 0 " < nl > val eaioUuid = " com . eaio . uuid " % " uuid " % " 3 . 4 " < nl > < nl > - val cats = " org . spire - math " % % " cats " % V . catsVersion < nl > + val cats = " org . spire - math " % % " cats " % V . cats < nl > < nl > val configs = " com . github . kxbmap " % % " configs " % " 0 . 2 . 4 " < nl > < nl > @ @ - 104 , 6 + 105 , 8 @ @ object Dependencies { < nl > < nl > val bot = shared + + Seq ( upickle ) < nl > < nl > + val botKit = Seq ( akkaActor , akkaHttp , akkaSlf4j , sprayWebsocket , upickle ) < nl > + < nl > val botMessages = Seq ( upickle ) < nl > < nl > val core = shared + + Seq ( akkaActor , akkaContrib , amazonaws , awsWrap , caffeine , gcmServer , pushy , jodaTime , postgresJdbc , slick , scrImageCore ) < nl > diff - - git a / actor - server / project / plugins . sbt b / actor - server / project / plugins . sbt < nl > index 394e20b . . b4a2e7f 100644 < nl > - - - a / actor - server / project / plugins . sbt < nl > + + + b / actor - server / project / plugins . sbt < nl > @ @ - 27 , 4 + 27 , 6 @ @ addSbtPlugin ( " com . trueaccord . scalapb " % " sbt - scalapb " % " 0 . 5 . 14 " ) < nl > < nl > addSbtPlugin ( " me . lessis " % " bintray - sbt " % " 0 . 3 . 0 " ) < nl > < nl > + addSbtPlugin ( " com . eed3si9n " % " sbt - assembly " % " 0 . 14 . 0 " ) < nl > + < nl > libraryDependencies + + = Seq ( " com . github . os72 " % " protoc - jar " % " 3 . 0 . 0 - a3 " ) < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 index 0da2400 . . 3c1abcc 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 @ @ - 2 , 19 + 2 , 16 @ @ package im . actor . server . bot . services 
 
 import akka . actor . ActorSystem 
 import im . actor . api . rpc . PeersImplicits 
 - import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } 
 import im . actor . bots . BotMessages . BotError 
 import im . actor . concurrent . FutureResult 
 import im . actor . server . bot . { BotServiceBase , BotToApiConversions } 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . DialogExtension 
 - import im . actor . server . group . GroupExtension 
 - import im . actor . server . model . { Peer ⇒ ModelPeer , PeerType } 
 + import im . actor . server . messaging . MessageUpdating 
 + import im . actor . server . model . { Peer ⇒ ModelPeer } 
 import im . actor . server . persist . HistoryMessageRepo 
 import im . actor . server . sequence . SeqStateDate 
 
 - import scala . concurrent . Future 
 - 
 private [ bot ] object MessagingBotErrors { 
 val Forbidden = BotError ( 403 , " FORBIDDEN " ) 
 } 
 @ @ - 22 , 7 + 19 , 8 @ @ private [ bot ] object MessagingBotErrors { 
 private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) 
 with FutureResult [ BotError ] 
 with BotToApiConversions 
 - with PeersImplicits { 
 + with PeersImplicits 
 + with MessageUpdating { 
 
 import MessagingBotErrors . _ 
 import im . actor . bots . BotMessages . _ 
 @ @ - 33 , 7 + 31 , 7 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer 
 
 override val handlers : PartialFunction [ RequestBody , WeakRequestHandler ] = { 
 case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak 
 - case UpdateMessageContent ( peer , randomId , message ) ⇒ updateMessageContent ( peer , randomId , message ) . toWeak 
 + case UpdateMessageContent ( peer , randomId , message ) ⇒ updateMessage ( peer , randomId , message ) . toWeak 
 } 
 
 private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( 
 @ @ - 54 , 64 + 52 , 15 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer 
 ) 
 
 / / allow bot to update only it ' s messages . Bot won ' t not be able to modify user ' s messages 
 - private def updateMessageContent ( peer : OutPeer , randomId : Long , updatedMessage : MessageBody ) = RequestHandler [ UpdateMessageContent , UpdateMessageContent # Response ] ( 
 + private def updateMessage ( peer : OutPeer , randomId : Long , updatedMessage : MessageBody ) = RequestHandler [ UpdateMessageContent , UpdateMessageContent # Response ] ( 
 ( botUserId : BotUserId , botAuthId : BotAuthId , botAuthSid : BotAuthSid ) ⇒ { 
 val peerModel = toPeer ( peer ) . asModel 
 val botPeer = ModelPeer . privat ( botUserId ) 
 ( for { 
 _ ← fromFutureBoolean ( Forbidden ) ( db . run ( HistoryMessageRepo . findBySender ( botUserId , peerModel , randomId ) . headOption map ( _ . nonEmpty ) ) ) 
 - _ ← fromFuture ( peer match { 
 - case UserOutPeer ( userId , _ ) ⇒ updateContentPrivate ( peerModel . id , botPeer , randomId , updatedMessage ) 
 - case GroupOutPeer ( groupId , _ ) ⇒ updateContentGroup ( botUserId , peerModel , randomId , updatedMessage ) 
 - } ) 
 + _ ← fromFuture ( updateMessageContent ( botUserId , peerModel , randomId , updatedMessage ) ( system ) ) 
 } yield MessageContentUpdated ) . value 
 } 
 ) 
 
 - private def updateContentPrivate ( userId : Int , botPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { 
 - val upd = UpdateMessageContentChanged ( botPeer . asStruct , randomId , updatedMessage ) 
 - for { 
 - _ ← userExt . broadcastUserUpdate ( 
 - userId = userId , 
 - update = upd , 
 - pushText = None , 
 - isFat = false , 
 - reduceKey = None , 
 - deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 - ) 
 - _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 - userIds = Set ( userId , botPeer . id ) , 
 - randomId = randomId , 
 - peerType = PeerType . Private , 
 - peerIds = Set ( userId , botPeer . id ) , 
 - messageContentHeader = updatedMessage . header , 
 - messageContentData = updatedMessage . toByteArray 
 - ) ) 
 - } yield ( ) 
 - } 
 - 
 - private def updateContentGroup ( botUserId : Int , groupPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { 
 - / / no need to send update to bot itself 
 - val upd = UpdateMessageContentChanged ( groupPeer . asStruct , randomId , updatedMessage ) 
 - for { 
 - ( memberIds , _ , _ ) ← GroupExtension ( system ) . getMemberIds ( groupPeer . id ) 
 - membersSet = memberIds . toSet 
 - _ ← userExt . broadcastUsersUpdate ( 
 - userIds = membersSet , 
 - update = upd , 
 - pushText = None , 
 - isFat = false , 
 - deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 - ) 
 - _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 - userIds = membersSet + botUserId , 
 - randomId = randomId , 
 - peerType = PeerType . Group , 
 - peerIds = Set ( groupPeer . id ) , 
 - messageContentHeader = updatedMessage . header , 
 - messageContentData = updatedMessage . toByteArray 
 - ) ) 
 - } yield ( ) 
 - } 
 - 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageParsing . scala b / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageParsing . scala 
 new file mode 100644 
 index 0000000 . . e91ab05 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageParsing . scala 
 @ @ - 0 , 0 + 1 , 8 @ @ 
 + package im . actor . server . messaging 
 + 
 + import com . google . protobuf . CodedInputStream 
 + import im . actor . api . rpc . messaging . ApiMessage 
 + 
 + trait MessageParsing { 
 + def parseMessage ( body : Array [ Byte ] ) : Either [ Any , ApiMessage ] = ApiMessage . parseFrom ( CodedInputStream . newInstance ( body ) ) 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageUpdating . scala b / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageUpdating . scala 
 new file mode 100644 
 index 0000000 . . 4d3ec72 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / messaging / MessageUpdating . scala 
 @ @ - 0 , 0 + 1 , 91 @ @ 
 + package im . actor . server . messaging 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . PeersImplicits 
 + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } 
 + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . group . GroupExtension 
 + import im . actor . server . model . { Peer , PeerType } 
 + import im . actor . server . persist . HistoryMessageRepo 
 + import im . actor . server . sequence . SeqState 
 + import im . actor . server . user . UserExtension 
 + 
 + import scala . concurrent . Future 
 + 
 + trait MessageUpdating extends PeersImplicits { 
 + 
 + def updateMessageContent ( clientUserId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit system : ActorSystem ) : Future [ SeqState ] = { 
 + peer match { 
 + case Peer ( PeerType . Private , _ ) ⇒ updateContentPrivate ( clientUserId , peer , randomId , updatedMessage ) 
 + case Peer ( PeerType . Group , _ ) ⇒ updateContentGroup ( clientUserId , peer , randomId , updatedMessage ) 
 + } 
 + } 
 + 
 + private def updateContentPrivate ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit system : ActorSystem ) : Future [ SeqState ] = { 
 + import system . dispatcher 
 + for { 
 + / / update for client himself 
 + seqState ← UserExtension ( system ) . broadcastUserUpdate ( 
 + userId = userId , 
 + update = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) , 
 + pushText = None , 
 + isFat = false , 
 + reduceKey = None , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + / / update for peer user 
 + _ ← UserExtension ( system ) . broadcastUserUpdate ( 
 + userId = peer . id , 
 + update = UpdateMessageContentChanged ( ApiPeer ( ApiPeerType . Private , userId ) , randomId , updatedMessage ) , 
 + pushText = None , 
 + isFat = false , 
 + reduceKey = None , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + _ ← DbExtension ( system ) . db . run ( HistoryMessageRepo . updateContentAll ( 
 + userIds = Set ( userId , peer . id ) , 
 + randomId = randomId , 
 + peerType = PeerType . Private , 
 + peerIds = Set ( userId , peer . id ) , 
 + messageContentHeader = updatedMessage . header , 
 + messageContentData = updatedMessage . toByteArray 
 + ) ) 
 + } yield seqState 
 + } 
 + 
 + private def updateContentGroup ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit system : ActorSystem ) : Future [ SeqState ] = { 
 + import system . dispatcher 
 + val upd = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) 
 + for { 
 + / / update for client user 
 + seqState ← UserExtension ( system ) . broadcastUserUpdate ( 
 + userId = userId , 
 + update = upd , 
 + pushText = None , 
 + isFat = false , 
 + reduceKey = None , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + ( memberIds , _ , _ ) ← GroupExtension ( system ) . getMemberIds ( peer . id ) 
 + membersSet = memberIds . toSet 
 + / / update for other group members 
 + _ ← UserExtension ( system ) . broadcastUsersUpdate ( 
 + userIds = membersSet - userId , 
 + update = upd , 
 + pushText = None , 
 + isFat = false , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + _ ← DbExtension ( system ) . db . run ( HistoryMessageRepo . updateContentAll ( 
 + userIds = membersSet + userId , 
 + randomId = randomId , 
 + peerType = PeerType . Group , 
 + peerIds = Set ( peer . id ) , 
 + messageContentHeader = updatedMessage . header , 
 + messageContentData = updatedMessage . toByteArray 
 + ) ) 
 + } yield seqState 
 + } 
 + 
 + } 
 diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewHelpers . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewHelpers . scala 
 index e4a9e77 . . fab7766 100644 
 - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewHelpers . scala 
 + + + b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewHelpers . scala 
 @ @ - 1 , 52 + 1 , 54 @ @ 
 package im . actor . server . enrich 
 
 - import scala . concurrent . duration . _ 
 - import scala . concurrent . { ExecutionContext , Future } 
 - import scala . util . { Failure , Success , Try } 
 - 
 - import akka . http . scaladsl . HttpExt 
 + import akka . actor . ActorSystem 
 + import akka . http . scaladsl . Http 
 import akka . http . scaladsl . model . { HttpEntity , HttpRequest , HttpResponse } 
 import akka . stream . Materializer 
 import akka . stream . scaladsl . _ 
 import akka . stream . stage . { Context , PushStage } 
 import akka . util . ByteString 
 - 
 import im . actor . server . enrich . PreviewMaker . Failures . _ 
 import im . actor . server . enrich . PreviewMaker . _ 
 
 - object PreviewHelpers { 
 + import scala . concurrent . { ExecutionContext , Future } 
 + import scala . util . { Failure , Success , Try } 
 + 
 + trait PreviewHelpers { 
 + 
 + protected implicit val system : ActorSystem 
 + protected implicit val ec : ExecutionContext 
 + protected implicit val mat : Materializer 
 
 - def withRequest ( request : ⇒ HttpRequest , handler : UpdateHandler ) ( function : HttpResponse ⇒ Future [ PreviewResult ] ) ( implicit http : HttpExt , materializer : Materializer , ec : ExecutionContext ) : Future [ PreviewResult ] = { 
 + def withRequest ( request : ⇒ HttpRequest , randomId : Long ) ( function : HttpResponse ⇒ Future [ PreviewResult ] ) ( implicit system : ActorSystem ) : Future [ PreviewResult ] = { 
 Try ( request ) match { 
 - case Success ( v ) ⇒ http . singleRequest ( v ) . flatMap ( function ) . recover { case e : Exception ⇒ failedToMakePreview ( handler , e . getMessage ) } 
 - case Failure ( _ ) ⇒ Future . successful ( failedToMakePreview ( handler ) ) 
 + case Success ( v ) ⇒ Http ( ) . singleRequest ( v ) . flatMap ( function ) recover { case e : Exception ⇒ failedToMakePreview ( randomId , e . getMessage ) } 
 + case Failure ( _ ) ⇒ Future . successful ( failedToMakePreview ( randomId ) ) 
 } 
 } 
 
 - def downloadDefault ( entity : HttpEntity . Default , fileName : Option [ String ] , handler : UpdateHandler , config : RichMessageConfig ) ( implicit materializer : Materializer , ec : ExecutionContext ) : Future [ PreviewResult ] = { 
 + def downloadDefault ( entity : HttpEntity . Default , fileName : Option [ String ] , gp : GetPreview , maxSize : Long ) : Future [ PreviewResult ] = { 
 val mediaType = entity . contentType . mediaType 
 val contentLength = entity . contentLength 
 ( mediaType . isImage , contentLength ) match { 
 - case ( true , length ) if length < = config . maxSize ⇒ 
 - entity 
 - . toStrict ( 10 . seconds ) 
 - . map { body ⇒ PreviewSuccess ( body . data , fileName , mediaType . value , handler ) } 
 - . recover { case e : Exception ⇒ failedToMakePreview ( handler , e . getMessage ) } 
 - case ( true , _ ) ⇒ Future . successful ( contentTooLong ( handler ) ) 
 - case ( false , _ ) ⇒ Future . successful ( notAnImage ( handler ) ) 
 + case ( true , length ) if length < = maxSize ⇒ 
 + entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) 
 + . map { body ⇒ PreviewSuccess ( body , fileName , mediaType . value , gp . clientUserId , gp . peer , gp . randomId ) } 
 + . recover { case e : Exception ⇒ failedToMakePreview ( gp . randomId , e . getMessage ) } 
 + case ( true , _ ) ⇒ Future . successful ( contentTooLong ( gp . randomId ) ) 
 + case ( false , _ ) ⇒ Future . successful ( notAnImage ( gp . randomId ) ) 
 } 
 } 
 
 - def downloadChunked ( entity : HttpEntity . Chunked , fileName : Option [ String ] , handler : UpdateHandler , config : RichMessageConfig ) ( implicit materializer : Materializer , ec : ExecutionContext ) : Future [ PreviewResult ] = { 
 + def downloadChunked ( entity : HttpEntity . Chunked , fileName : Option [ String ] , gp : GetPreview , maxSize : Long ) : Future [ PreviewResult ] = { 
 val mediaType = entity . contentType . mediaType 
 mediaType . isImage match { 
 case true ⇒ 
 entity . dataBytes 
 - . via ( sizeBoundingFlow ( config . maxSize ) ) 
 - . runWith ( Sink . fold ( ByteString . empty ) { ( acc , el ) ⇒ acc + + el } ) 
 - . map { body ⇒ PreviewSuccess ( body , fileName , mediaType . value , handler ) } 
 - . recover { case e : Exception ⇒ failedToMakePreview ( handler , e . getMessage ) } 
 - case false ⇒ Future . successful ( notAnImage ( handler ) ) 
 + . via ( sizeBoundingFlow ( maxSize ) ) 
 + . runFold ( ByteString . empty ) ( _ + + _ ) 
 + . map { body ⇒ PreviewSuccess ( body , fileName , mediaType . value , gp . clientUserId , gp . peer , gp . randomId ) } 
 + . recover { case e : Exception ⇒ failedToMakePreview ( gp . randomId , e . getMessage ) } 
 + case false ⇒ Future . successful ( notAnImage ( gp . randomId ) ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewMaker . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewMaker . scala 
 index 41452ab . . 58e2c4e 100644 
 - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewMaker . scala 
 + + + b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / PreviewMaker . scala 
 @ @ - 1 , 20 + 1 , 20 @ @ 
 package im . actor . server . enrich 
 
 - import scala . concurrent . { ExecutionContextExecutor , Future } 
 - 
 import akka . actor . _ 
 import akka . http . scaladsl . model . HttpMethods . GET 
 import akka . http . scaladsl . model . _ 
 import akka . http . scaladsl . model . headers . _ 
 - import akka . http . scaladsl . { Http , HttpExt } 
 import akka . pattern . pipe 
 - import akka . stream . Materializer 
 + import akka . stream . { ActorMaterializer , Materializer } 
 import akka . util . ByteString 
 + import im . actor . server . model . Peer 
 + 
 + import scala . concurrent . { ExecutionContext , Future } 
 
 object PreviewMaker { 
 
 - def apply ( config : RichMessageConfig , name : String ) ( implicit system : ActorSystem , materializer : Materializer ) : ActorRef = 
 - system . actorOf ( Props ( classOf [ PreviewMaker ] , config , materializer ) , name ) 
 + def apply ( config : RichMessageConfig , name : String ) ( implicit system : ActorSystem ) : ActorRef = 
 + system . actorOf ( Props ( classOf [ PreviewMaker ] , config ) , name ) 
 
 object Failures { 
 object Messages { 
 @ @ - 22 , 38 + 22 , 49 @ @ object PreviewMaker { 
 val ContentTooLong = " content is too long " 
 val Failed = " failed to make preview " 
 } 
 - def notAnImage ( handler : UpdateHandler ) = PreviewFailure ( Messages . NotAnImage , handler ) 
 - def contentTooLong ( handler : UpdateHandler ) = PreviewFailure ( Messages . ContentTooLong , handler ) 
 - def failedToMakePreview ( handler : UpdateHandler , cause : String = Messages . Failed ) = PreviewFailure ( cause , handler ) 
 - def failedWith ( status : StatusCode , handler : UpdateHandler ) : PreviewFailure = PreviewFailure ( s " failed to make preview with http status code $ { status . value } " , handler ) 
 + def notAnImage ( randomId : Long ) = PreviewFailure ( Messages . NotAnImage , randomId ) 
 + def contentTooLong ( randomId : Long ) = PreviewFailure ( Messages . ContentTooLong , randomId ) 
 + def failedToMakePreview ( randomId : Long , cause : String = Messages . Failed ) = PreviewFailure ( cause , randomId ) 
 + def failedWith ( status : StatusCode , randomId : Long ) : PreviewFailure = PreviewFailure ( s " failed to make preview with http status code $ { status . value } " , randomId ) 
 } 
 
 - case class GetPreview ( url : String , handler : UpdateHandler ) 
 + final case class GetPreview ( 
 + url : String , 
 + clientUserId : Int , 
 + peer : Peer , 
 + randomId : Long 
 + ) 
 
 sealed trait PreviewResult 
 - case class PreviewSuccess ( content : ByteString , fileName : Option [ String ] , contentType : String , handler : UpdateHandler ) extends PreviewResult 
 - case class PreviewFailure ( message : String , handler : UpdateHandler ) extends PreviewResult 
 + final case class PreviewSuccess ( 
 + content : ByteString , 
 + fileName : Option [ String ] , 
 + contentType : String , 
 + clientUserId : Int , 
 + peer : Peer , 
 + randomId : Long 
 + ) extends PreviewResult 
 + final case class PreviewFailure ( message : String , randomId : Long ) extends PreviewResult 
 
 private def getFileName ( cdOption : Option [ ` Content - Disposition ` ] ) = cdOption . flatMap ( _ . params . get ( " filename " ) ) 
 } 
 
 - class PreviewMaker ( config : RichMessageConfig ) ( implicit materializer : Materializer ) extends Actor with ActorLogging { 
 + class PreviewMaker ( config : RichMessageConfig ) extends Actor with ActorLogging with PreviewHelpers { 
 
 - import PreviewHelpers . _ 
 import PreviewMaker . _ 
 
 - implicit val system : ActorSystem = context . system 
 - implicit val ec : ExecutionContextExecutor = context . dispatcher 
 - implicit val http : HttpExt = Http ( ) 
 + protected implicit val system : ActorSystem = context . system 
 + protected implicit val ec : ExecutionContext = system . dispatcher 
 + protected implicit val mat : Materializer = ActorMaterializer ( ) 
 
 def receive = { 
 - case GetPreview ( url , handler ) ⇒ 
 - val result : Future [ PreviewResult ] = withRequest ( HttpRequest ( GET , url ) , handler ) { response ⇒ 
 + case gp : GetPreview ⇒ 
 + val result : Future [ PreviewResult ] = withRequest ( HttpRequest ( GET , gp . url ) , gp . randomId ) { response ⇒ 
 val cd : Option [ ` Content - Disposition ` ] = response . header [ ` Content - Disposition ` ] 
 response match { 
 - case HttpResponse ( _ : StatusCodes . Success , _ , entity : HttpEntity . Default , _ ) ⇒ downloadDefault ( entity , getFileName ( cd ) , handler , config ) 
 - case HttpResponse ( _ : StatusCodes . Success , _ , entity : HttpEntity . Chunked , _ ) ⇒ downloadChunked ( entity , getFileName ( cd ) , handler , config ) 
 - case HttpResponse ( status , _ , _ , _ ) ⇒ Future . successful ( Failures . failedWith ( status , handler ) ) 
 + case HttpResponse ( _ : StatusCodes . Success , _ , entity : HttpEntity . Default , _ ) ⇒ downloadDefault ( entity , getFileName ( cd ) , gp , config . maxSize ) 
 + case HttpResponse ( _ : StatusCodes . Success , _ , entity : HttpEntity . Chunked , _ ) ⇒ downloadChunked ( entity , getFileName ( cd ) , gp , config . maxSize ) 
 + case HttpResponse ( status , _ , _ , _ ) ⇒ Future . successful ( Failures . failedWith ( status , gp . randomId ) ) 
 } 
 } 
 result pipeTo sender ( ) 
 diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala 
 index cb35dea . . 5f4ff26 100644 
 - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala 
 + + + b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala 
 @ @ - 4 , 51 + 4 , 43 @ @ import akka . actor . _ 
 import akka . cluster . pubsub . DistributedPubSubMediator . { Subscribe , SubscribeAck } 
 import akka . event . Logging 
 import akka . http . scaladsl . model . Uri 
 - import akka . stream . Materializer 
 import akka . util . Timeout 
 import com . sksamuel . scrimage . Image 
 import com . sksamuel . scrimage . nio . JpegWriter 
 import im . actor . api . rpc . files . ApiFastThumb 
 import im . actor . api . rpc . messaging . _ 
 - import im . actor . server . db . DbExtension 
 import im . actor . server . file . _ 
 + import im . actor . server . messaging . MessageUpdating 
 import im . actor . server . pubsub . { PeerMessage , PubSubExtension } 
 import im . actor . util . log . AnyRefLogSource 
 import org . joda . time . DateTime 
 - import slick . driver . PostgresDriver . api . _ 
 
 - import scala . concurrent . ExecutionContextExecutor 
 import scala . concurrent . duration . _ 
 import scala . util . { Failure , Success , Try } 
 
 object RichMessageWorker { 
 val groupId = Some ( " RichMessageWorker " ) 
 
 - def startWorker ( config : RichMessageConfig ) ( 
 - implicit 
 - system : ActorSystem , 
 - materializer : Materializer 
 - ) : ActorRef = system . actorOf ( Props ( classOf [ RichMessageWorker ] , config , materializer ) , " rich - message - worker " ) 
 + def startWorker ( config : RichMessageConfig ) ( implicit system : ActorSystem ) : ActorRef = 
 + system . actorOf ( Props ( classOf [ RichMessageWorker ] , config ) , " rich - message - worker " ) 
 } 
 
 - final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : Materializer ) extends Actor with ActorLogging { 
 + final class RichMessageWorker ( config : RichMessageConfig ) extends Actor with ActorLogging with MessageUpdating { 
 
 import AnyRefLogSource . _ 
 import PreviewMaker . _ 
 import RichMessageWorker . _ 
 
 private implicit val system : ActorSystem = context . system 
 - private implicit val ec : ExecutionContextExecutor = system . dispatcher 
 + import system . dispatcher 
 private implicit val timeout : Timeout = Timeout ( 10 . seconds ) 
 
 - private val db = DbExtension ( system ) . db 
 private val pubSubExt = PubSubExtension ( system ) 
 - 
 private val fsAdapter : FileStorageAdapter = FileStorageExtension ( context . system ) . fsAdapter 
 
 override val log = Logging ( system , this ) 
 
 - val previewMaker = PreviewMaker ( config , " previewMaker " ) 
 + private val previewMaker = PreviewMaker ( config , " previewMaker " ) 
 
 private val privateSubscribe = Subscribe ( pubSubExt . privateMessagesTopic , groupId , self ) 
 private val publicSubscribe = Subscribe ( pubSubExt . groupMessagesTopic , None , self ) 
 @ @ - 63 , 12 + 55 , 12 @ @ final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : 
 if ( groupAckReceived ) 
 context . become ( ready ) 
 else 
 - context . become ( subscribing ( true , groupAckReceived ) ) 
 + context . become ( subscribing ( privateAckReceived = true , groupAckReceived = groupAckReceived ) ) 
 case SubscribeAck ( ` publicSubscribe ` ) ⇒ 
 if ( privateAckReceived ) 
 context . become ( ready ) 
 else 
 - context . become ( subscribing ( privateAckReceived , true ) ) 
 + context . become ( subscribing ( privateAckReceived , groupAckReceived = true ) ) 
 } 
 
 def ready : Receive = { 
 @ @ - 78 , 43 + 70 , 40 @ @ final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : 
 Try ( Uri ( text . trim ) ) match { 
 case Success ( uri ) ⇒ 
 log . debug ( " TextMessage with uri : { } " , uri ) 
 - previewMaker ! GetPreview ( uri . toString ( ) , UpdateHandler . getHandler ( fromPeer , toPeer , randomId ) ) 
 + previewMaker ! GetPreview ( uri . toString ( ) , fromPeer . id , toPeer , randomId ) 
 case Failure ( _ ) ⇒ 
 } 
 case _ ⇒ 
 } 
 - case PreviewSuccess ( imageBytes , optFileName , mimeType , handler ) ⇒ 
 - log . debug ( " PreviewSuccess for message with randomId : { } , fileName : { } , mimeType : { } " , handler . randomId , optFileName , mimeType ) 
 + case PreviewSuccess ( imageBytes , optFileName , mimeType , clientUserId , peer , randomId ) ⇒ 
 + log . debug ( " PreviewSuccess for message with randomId : { } , fileName : { } , mimeType : { } " , randomId , optFileName , mimeType ) 
 val fullName = optFileName getOrElse { 
 val name = ( new DateTime ) . toString ( " yyyyMMddHHmmss " ) 
 val ext = Try ( mimeType . split ( " / " ) . last ) . getOrElse ( " tmp " ) 
 s " $ name . $ ext " 
 } 
 val image = Image ( imageBytes . toArray ) . toPar 
 - db . run { 
 - for { 
 - location ← fsAdapter . uploadFile ( UnsafeFileName ( fullName ) , imageBytes . toArray ) 
 - thumb ← DBIO . from ( ImageUtils . scaleTo ( image , 90 ) ) 
 - thumbBytes = thumb . toImage . forWriter ( JpegWriter ( ) ) . bytes 
 - 
 - _ = log . debug ( " uploaded file to location { } " , location ) 
 - _ = log . debug ( " image with width : { } , height : { } " , image . width , image . height ) 
 - 
 - updated = ApiDocumentMessage ( 
 - fileId = location . fileId , 
 - accessHash = location . accessHash , 
 - fileSize = imageBytes . size , 
 - name = fullName , 
 - mimeType = mimeType , 
 - thumb = Some ( ApiFastThumb ( thumb . width , thumb . height , thumbBytes ) ) , 
 - ext = Some ( ApiDocumentExPhoto ( image . width , image . height ) ) 
 - ) 
 - _ ← handler . handleDbUpdate ( updated ) 
 - _ ← handler . handleUpdate ( updated ) 
 - } yield ( ) 
 - } 
 - case PreviewFailure ( mess , handler ) ⇒ 
 - log . debug ( " failed to make preview for message with randomId : { } , cause : { } " , handler . randomId , mess ) 
 + for { 
 + location ← fsAdapter . uploadFileF ( UnsafeFileName ( fullName ) , imageBytes . toArray ) 
 + thumb ← ImageUtils . scaleTo ( image , 90 ) 
 + thumbBytes = thumb . toImage . forWriter ( JpegWriter ( ) ) . bytes 
 + 
 + _ = log . debug ( " uploaded file to location { } " , location ) 
 + _ = log . debug ( " image with width : { } , height : { } " , image . width , image . height ) 
 + 
 + updated = ApiDocumentMessage ( 
 + fileId = location . fileId , 
 + accessHash = location . accessHash , 
 + fileSize = imageBytes . size , 
 + name = fullName , 
 + mimeType = mimeType , 
 + thumb = Some ( ApiFastThumb ( thumb . width , thumb . height , thumbBytes ) ) , 
 + ext = Some ( ApiDocumentExPhoto ( image . width , image . height ) ) 
 + ) 
 + _ ← updateMessageContent ( clientUserId , peer , randomId , updated ) 
 + } yield ( ) 
 + case PreviewFailure ( mess , randomId ) ⇒ 
 + log . debug ( " failed to make preview for message with randomId : { } , cause : { } " , randomId , mess ) 
 } 
 
 } 
 diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / UpdateHandler . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / UpdateHandler . scala 
 deleted file mode 100644 
 index 5af8f06 . . 0000000 
 - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / UpdateHandler . scala 
 + + + / dev / null 
 @ @ - 1 , 81 + 0 , 0 @ @ 
 - package im . actor . server . enrich 
 - 
 - import akka . actor . ActorSystem 
 - import im . actor . api . rpc . Implicits . _ 
 - import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } 
 - import im . actor . server . model . { Peer , PeerType } 
 - import im . actor . server . persist . { GroupUserRepo , HistoryMessageRepo } 
 - import im . actor . server . sequence . SeqState 
 - import im . actor . server . user . UserExtension 
 - import slick . dbio . _ 
 - 
 - object UpdateHandler { 
 - def getHandler ( fromPeer : Peer , toPeer : Peer , randomId : Long ) ( implicit system : ActorSystem ) : UpdateHandler = 
 - toPeer . typ match { 
 - case PeerType . Group ⇒ new GroupHandler ( toPeer , randomId ) 
 - case PeerType . Private ⇒ new PrivateHandler ( fromPeer , toPeer , randomId ) 
 - case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) 
 - } 
 - } 
 - 
 - abstract class UpdateHandler ( val randomId : Long ) { 
 - def handleDbUpdate ( message : ApiMessage ) : DBIO [ Int ] 
 - 
 - def handleUpdate ( message : ApiMessage ) : DBIO [ Seq [ SeqState ] ] 
 - } 
 - 
 - class PrivateHandler ( fromPeer : Peer , toPeer : Peer , randomId : Long ) ( implicit system : ActorSystem ) extends UpdateHandler ( randomId ) { 
 - import system . dispatcher 
 - 
 - require ( fromPeer . typ = = PeerType . Private 
 - & & toPeer . typ = = PeerType . Private , " Peers must be private " ) 
 - 
 - def handleUpdate ( message : ApiMessage ) : DBIO [ Seq [ SeqState ] ] = 
 - DBIO . from ( for { 
 - fromUpdate ← UserExtension ( system ) . broadcastUserUpdate ( 
 - fromPeer . id , 
 - UpdateMessageContentChanged ( toPeer . asStruct , randomId , message ) , None , false , reduceKey = None , deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 - ) 
 - toUpdate ← UserExtension ( system ) . broadcastUserUpdate ( 
 - toPeer . id , 
 - UpdateMessageContentChanged ( fromPeer . asStruct , randomId , message ) , None , false , reduceKey = None , deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 - ) 
 - } yield Seq ( fromUpdate , toUpdate ) ) 
 - 
 - def handleDbUpdate ( message : ApiMessage ) : DBIO [ Int ] = HistoryMessageRepo . updateContentAll ( 
 - userIds = Set ( fromPeer . id , toPeer . id ) , 
 - randomId = randomId , 
 - peerType = PeerType . Private , 
 - peerIds = Set ( fromPeer . id , toPeer . id ) , 
 - messageContentHeader = message . header , 
 - messageContentData = message . toByteArray 
 - ) 
 - } 
 - 
 - class GroupHandler ( groupPeer : Peer , randomId : Long ) ( implicit system : ActorSystem ) extends UpdateHandler ( randomId ) { 
 - import system . dispatcher 
 - 
 - require ( groupPeer . typ = = PeerType . Group , " Peer must be a group " ) 
 - 
 - def handleUpdate ( message : ApiMessage ) : DBIO [ Seq [ SeqState ] ] = { 
 - val update = UpdateMessageContentChanged ( groupPeer . asStruct , randomId , message ) 
 - for { 
 - usersIds ← GroupUserRepo . findUserIds ( groupPeer . id ) 
 - seqstate ← DBIO . from ( UserExtension ( system ) . broadcastUsersUpdate ( usersIds . toSet , update , None , false , deliveryId = Some ( s " msgcontent _ $ { randomId } " ) ) ) 
 - } yield seqstate 
 - } 
 - 
 - def handleDbUpdate ( message : ApiMessage ) : DBIO [ Int ] = 
 - for { 
 - usersIds ← GroupUserRepo . findUserIds ( groupPeer . id ) 
 - result ← HistoryMessageRepo . updateContentAll ( 
 - userIds = usersIds . toSet , 
 - randomId = randomId , 
 - peerType = PeerType . Group , 
 - peerIds = Set ( groupPeer . id ) , 
 - messageContentHeader = message . header , 
 - messageContentData = message . toByteArray 
 - ) 
 - } yield result 
 - 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala 
 deleted file mode 100644 
 index 649b441 . . 0000000 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessageParsing . scala 
 + + + / dev / null 
 @ @ - 1 , 8 + 0 , 0 @ @ 
 - package im . actor . server . api . rpc . service . messaging 
 - 
 - import com . google . protobuf . CodedInputStream 
 - import im . actor . api . rpc . messaging . ApiMessage 
 - 
 - trait MessageParsing { 
 - def parseMessage ( body : Array [ Byte ] ) : Either [ Any , ApiMessage ] = ApiMessage . parseFrom ( CodedInputStream . newInstance ( body ) ) 
 - } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 index af429e1 . . 0e70104 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 @ @ - 7 , 9 + 7 , 8 @ @ import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . misc . _ 
 import im . actor . api . rpc . peers . _ 
 import im . actor . config . ActorConfig 
 - import im . actor . server . model . { PeerType , Peer } 
 + import im . actor . server . messaging . { MessageParsing , MessageUpdating } 
 import im . actor . server . persist . HistoryMessageRepo 
 - import im . actor . server . sequence . SeqState 
 
 import scala . concurrent . _ 
 import scala . concurrent . duration . _ 
 @ @ - 21 , 7 + 20 , 9 @ @ object MessagingRpcErors { 
 val IntenalError = RpcError ( 500 , " INTERNAL _ ERROR " , " " , false , None ) 
 } 
 
 - private [ messaging ] trait MessagingHandlers extends PeersImplicits with MessageParsing { 
 + private [ messaging ] trait MessagingHandlers extends PeersImplicits 
 + with MessageParsing 
 + with MessageUpdating { 
 this : MessagingServiceImpl ⇒ 
 
 import FutureResultRpc . _ 
 @ @ - 62 , 7 + 63 , 7 @ @ private [ messaging ] trait MessagingHandlers extends PeersImplicits with MessagePa 
 case _ : ApiTextMessage ⇒ true 
 case _ ⇒ false 
 } ) 
 - result ← fromFuture ( updateMessageContent ( peer , randomId , updatedMessage ) ) 
 + result ← fromFuture ( updateMessageContent ( client . userId , peer , randomId , updatedMessage ) ) 
 date = System . currentTimeMillis 
 } yield ResponseSeqDate ( result . seq , result . state . toByteArray , date ) ) . value 
 } 
 @ @ - 73 , 74 + 74 , 4 @ @ private [ messaging ] trait MessagingHandlers extends PeersImplicits with MessagePa 
 ( messageDateMillis + editTimeWindow ) > System . currentTimeMillis 
 } 
 
 - / / TODO : move to trait and reuse 
 - private def updateMessageContent ( peer : Peer , randomId : Long , updatedMessage : ApiMessage ) ( implicit client : AuthorizedClientData ) : Future [ SeqState ] = peer match { 
 - case Peer ( PeerType . Private , _ ) ⇒ updateContentPrivate ( client . userId , peer , randomId , updatedMessage ) 
 - case Peer ( PeerType . Group , _ ) ⇒ updateContentGroup ( client . userId , peer , randomId , updatedMessage ) 
 - } 
 - 
 - private def updateContentPrivate ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) : Future [ SeqState ] = { 
 - for { 
 - / / update for client himself 
 - seqState ← userExt . broadcastUserUpdate ( 
 - userId = userId , 
 - update = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) , 
 - pushText = None , 
 - isFat = false , 
 - reduceKey = None , 
 - deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 - ) 
 - / / update for peer user 
 - _ ← userExt . broadcastUserUpdate ( 
 - userId = peer . id , 
 - update = UpdateMessageContentChanged ( ApiPeer ( ApiPeerType . Private , userId ) , randomId , updatedMessage ) , 
 - pushText = None , 
 - isFat = false , 
 - reduceKey = None , 
 - deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 - ) 
 - _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 - userIds = Set ( userId , peer . id ) , 
 - randomId = randomId , 
 - peerType = PeerType . Private , 
 - peerIds = Set ( userId , peer . id ) , 
 - messageContentHeader = updatedMessage . header , 
 - messageContentData = updatedMessage . toByteArray 
 - ) ) 
 - } yield seqState 
 - } 
 - 
 - private def updateContentGroup ( userId : Int , peer : Peer , randomId : Long , updatedMessage : ApiMessage ) : Future [ SeqState ] = { 
 - val upd = UpdateMessageContentChanged ( peer . asStruct , randomId , updatedMessage ) 
 - for { 
 - / / update for client user 
 - seqState ← userExt . broadcastUserUpdate ( 
 - userId = userId , 
 - update = upd , 
 - pushText = None , 
 - isFat = false , 
 - reduceKey = None , 
 - deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 - ) 
 - ( memberIds , _ , _ ) ← groupExt . getMemberIds ( peer . id ) 
 - membersSet = memberIds . toSet 
 - / / update for other group members 
 - _ ← userExt . broadcastUsersUpdate ( 
 - userIds = membersSet - userId , 
 - update = upd , 
 - pushText = None , 
 - isFat = false , 
 - deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 - ) 
 - _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 - userIds = membersSet , 
 - randomId = randomId , 
 - peerType = PeerType . Group , 
 - peerIds = Set ( peer . id ) , 
 - messageContentHeader = updatedMessage . header , 
 - messageContentData = updatedMessage . toByteArray 
 - ) ) 
 - } yield seqState 
 - } 
 - 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / enrich / PreviewMakerSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / enrich / PreviewMakerSpec . scala 
 index 75e273c . . aa83369 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / enrich / PreviewMakerSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / enrich / PreviewMakerSpec . scala 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 package im . actor . server . enrich 
 
 + import im . actor . server . model . { PeerType , Peer } 
 + 
 import scala . concurrent . duration . _ 
 
 import akka . actor . ActorRef 
 @ @ - 61 , 7 + 63 , 7 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { 
 sendGetPreview ( previewMaker , image . url ) 
 probe watch previewMaker 
 probe . expectMsgPF ( 10 . seconds ) { 
 - case PreviewSuccess ( content , fileName , mimeType , _ ) ⇒ 
 + case PreviewSuccess ( content , fileName , mimeType , _ , _ , _ ) ⇒ 
 content should not be empty 
 content . length shouldEqual image . contentLength 
 fileName shouldEqual image . fileName 
 @ @ - 75 , 7 + 77 , 7 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { 
 sendGetPreview ( previewMaker , image . url ) 
 probe watch previewMaker 
 probe . expectMsgPF ( 10 . seconds ) { 
 - case PreviewSuccess ( content , fileName , mimeType , _ ) ⇒ 
 + case PreviewSuccess ( content , fileName , mimeType , _ , _ , _ ) ⇒ 
 content should not be empty 
 content . length shouldEqual image . contentLength 
 fileName shouldEqual image . fileName 
 @ @ - 101 , 7 + 103 , 7 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { 
 sendGetPreview ( previewMaker , image . url ) 
 probe watch previewMaker 
 probe . expectMsgPF ( 10 . seconds ) { 
 - case PreviewSuccess ( content , fileName , mimeType , _ ) ⇒ 
 + case PreviewSuccess ( content , fileName , mimeType , _ , _ , _ ) ⇒ 
 content should not be empty 
 fileName shouldEqual image . fileName 
 mimeType shouldEqual image . mimeType 
 @ @ - 114 , 7 + 116 , 7 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { 
 sendGetPreview ( previewMaker , image . url ) 
 probe watch previewMaker 
 probe . expectMsgPF ( 10 . seconds ) { 
 - case PreviewSuccess ( content , fileName , mimeType , _ ) ⇒ 
 + case PreviewSuccess ( content , fileName , mimeType , _ , _ , _ ) ⇒ 
 content should not be empty 
 fileName shouldEqual image . fileName 
 mimeType shouldEqual image . mimeType 
 @ @ - 124 , 14 + 126 , 9 @ @ class PreviewMakerSpec extends BaseRichMessageSpec { 
 } 
 } 
 
 - class DummyUpdateHandler extends UpdateHandler ( 0L ) { 
 - def handleDbUpdate ( message : ApiMessage ) = ? ? ? 
 - def handleUpdate ( message : ApiMessage ) = ? ? ? 
 - } 
 - 
 protected def sendGetPreview ( previewMaker : ActorRef , url : String ) ( implicit probe : TestProbe ) = { 
 previewMaker . tell ( 
 - GetPreview ( url , new DummyUpdateHandler ( ) ) , 
 + GetPreview ( url , 0 , Peer ( PeerType . Private , 0 ) , 0L ) , 
 probe . ref 
 ) 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / EchoBot . scala b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / EchoBot . scala 
 new file mode 100644 
 index 0000000 . . 5e21dee 
 - - - / dev / null 
 + + + b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / EchoBot . scala 
 @ @ - 0 , 0 + 1 , 28 @ @ 
 + package im . actor . bot . remote 
 + 
 + import akka . actor . { Props , ActorSystem } 
 + import im . actor . bot . BotMessages . TextMessage 
 + 
 + object EchoBotApp extends App { 
 + implicit val system = ActorSystem ( ) 
 + 
 + val token = " e296e29479a6933923119bec40ff46b408ff4d34 " 
 + 
 + system . actorOf ( 
 + EchoBot . props ( token , " ws : / / localhost : 9090 " ) , 
 + " EchoBot " 
 + ) 
 + 
 + system . awaitTermination ( ) 
 + } 
 + 
 + object EchoBot { 
 + def props ( token : String , endpoint : String = " wss : / / front1 - ws - mtproto - api - rev2 - dev1 . actor . im : 443 " ) = 
 + Props ( classOf [ EchoBot ] , token , endpoint ) 
 + } 
 + 
 + final class EchoBot ( token : String , endpoint : String ) extends RemoteBot ( token , endpoint ) { 
 + override protected def onTextMessage ( tm : TextMessage ) : Unit = { 
 + sendTextMessage ( outPeer ( tm . sender ) , s " Hey , here is your reply : $ { tm . text } " ) 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBot . scala b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBot . scala 
 new file mode 100644 
 index 0000000 . . 5e0d9bd 
 - - - / dev / null 
 + + + b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBot . scala 
 @ @ - 0 , 0 + 1 , 64 @ @ 
 + package im . actor . bot . remote 
 + 
 + import java . net . URLEncoder 
 + 
 + import akka . actor . _ 
 + import akka . stream . scaladsl . { Sink , Source } 
 + import akka . stream . { ActorMaterializer , OverflowStrategy } 
 + import im . actor . bot . { BotMessageOut , BotBase , BotMessages } 
 + import upickle . default . _ 
 + 
 + import scala . concurrent . forkjoin . ThreadLocalRandom 
 + import scala . reflect . ClassTag 
 + 
 + object RemoteBot { 
 + val DefaultEndpoint = " wss : / / front1 - ws - mtproto - api - rev2 - dev1 . actor . im : 443 " 
 + } 
 + 
 + abstract class RemoteBot ( token : String , endpoint : String ) extends BotBase with Actor with ActorLogging { 
 + 
 + import BotMessages . _ 
 + 
 + private implicit val mat = ActorMaterializer ( ) 
 + 
 + private var rqSource = initFlow ( ) 
 + private var rqCounter : Long = 0 
 + 
 + def receive : Receive = { 
 + case ConnectionClosed ⇒ 
 + log . warning ( " Disconnected , reinitiating flow " ) 
 + rqSource = initFlow ( ) 
 + case Status . Failure ( e ) ⇒ 
 + log . error ( e , " Error in a stream , restarting " ) 
 + throw e 
 + case tm : TextMessage ⇒ 
 + log . info ( " Received text message { } " , tm ) 
 + onTextMessage ( tm ) 
 + case rsp : BotResponse ⇒ 
 + log . info ( " Response : { } " , rsp . body ) 
 + case unmatched ⇒ 
 + log . error ( " Unmatched { } " , unmatched ) 
 + } 
 + 
 + override protected def sendTextMessage ( peer : OutPeer , text : String ) : Unit = { 
 + log . info ( " Sending message , peer : { } , text : { } " , peer , text ) 
 + log . info ( " rqSource { } " , rqSource ) 
 + rqSource ! nextRequest ( SendTextMessage ( peer , ThreadLocalRandom . current ( ) . nextLong ( ) , text ) ) 
 + } 
 + 
 + private def nextRequest ( body : RequestBody ) : BotRequest = { 
 + rqCounter + = 1 
 + BotRequest ( rqCounter , body ) 
 + } 
 + 
 + private def initFlow ( ) : ActorRef = { 
 + val ( wsSource , wsSink ) = WebsocketClient . sourceAndSink ( s " $ { endpoint } / v1 / bots / $ { URLEncoder . encode ( token , " UTF - 8 " ) } " ) 
 + 
 + wsSource . map ( read [ BotMessageOut ] ) . to ( Sink . actorRef ( self , ConnectionClosed ) ) . run ( ) 
 + 
 + Source . actorRef ( bufferSize = 100 , overflowStrategy = OverflowStrategy . fail ) 
 + . map ( write [ BotRequest ] ) 
 + . to ( wsSink ) 
 + . run ( ) 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBotBlueprint . scala b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBotBlueprint . scala 
 new file mode 100644 
 index 0000000 . . 81d595a 
 - - - / dev / null 
 + + + b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / RemoteBotBlueprint . scala 
 @ @ - 0 , 0 + 1 , 13 @ @ 
 + package im . actor . bot . remote 
 + 
 + import akka . stream . scaladsl . _ 
 + import upickle . default . _ 
 + 
 + object RemoteBotBlueprint { 
 + import im . actor . bot . BotMessages . _ 
 + 
 + val flow = 
 + Flow [ String ] 
 + . map ( read [ BotUpdate ] ) 
 + } 
 + 
 diff - - git a / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / WebsocketClient . scala b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / WebsocketClient . scala 
 new file mode 100644 
 index 0000000 . . 810c383 
 - - - / dev / null 
 + + + b / actor - server / actor - bot - kit / src / main / scala / im / actor / bot / remote / WebsocketClient . scala 
 @ @ - 0 , 0 + 1 , 142 @ @ 
 + package im . actor . bot . remote 
 + 
 + import java . net . URI 
 + 
 + import akka . actor . { ActorLogging , ActorRefFactory , Props } 
 + import akka . io . IO 
 + import akka . stream . actor . _ 
 + import akka . stream . scaladsl . { Sink , Source } 
 + import spray . can . server . UHttp 
 + import spray . can . websocket . frame . { Frame , TextFrame } 
 + import spray . can . { Http , websocket } 
 + import spray . http . { HttpHeaders , HttpMethods , HttpRequest } 
 + import spray . io . ServerSSLEngineProvider 
 + 
 + import scala . annotation . tailrec 
 + 
 + final case object ConnectionClosed 
 + 
 + object WebsocketClient { 
 + def sourceAndSink ( url : String ) ( implicit context : ActorRefFactory ) = { 
 + val actor = context . actorOf ( props ( url ) ) 
 + 
 + ( Source ( ActorPublisher [ String ] ( actor ) ) , Sink ( ActorSubscriber [ String ] ( actor ) ) ) 
 + } 
 + 
 + def props ( url : String ) = Props ( classOf [ WebsocketClient ] , url ) 
 + } 
 + 
 + final class WebsocketClient ( url : String ) 
 + extends ActorPublisher [ String ] 
 + with ActorSubscriber 
 + with ActorLogging { 
 + import context . system 
 + 
 + implicit def sslEngineProvider : ServerSSLEngineProvider = { 
 + ServerSSLEngineProvider { engine ⇒ 
 + engine . setEnabledCipherSuites ( Array ( " TLS _ RSA _ WITH _ AES _ 256 _ CBC _ SHA " ) ) 
 + engine . setEnabledProtocols ( Array ( " SSLv3 " , " TLSv1 " ) ) 
 + engine 
 + } 
 + } 
 + 
 + abstract class WebSocketClient ( connect : Http . Connect , val upgradeRequest : HttpRequest ) extends websocket . WebSocketClientWorker { 
 + IO ( UHttp ) ! connect 
 + 
 + def businessLogic : Receive = { 
 + case frame : Frame ⇒ 
 + onMessage ( frame ) 
 + case str : String ⇒ 
 + connection ! TextFrame ( str ) 
 + case _ : Http . ConnectionClosed ⇒ 
 + onClose ( ) 
 + context . stop ( self ) 
 + } 
 + 
 + def onMessage ( frame : Frame ) : Unit 
 + 
 + def onClose ( ) : Unit 
 + } 
 + 
 + val uri = new URI ( url ) 
 + val ssl = uri . getScheme = = " wss " 
 + val host = uri . getHost 
 + val port = uri . getPort match { 
 + case - 1 ⇒ if ( ssl ) 443 else 80 
 + case p ⇒ p 
 + } 
 + 
 + val agent = " spray - websocket - client " + ( if ( ssl ) " - ssl " else " - basic " ) 
 + val headers = List ( 
 + HttpHeaders . Host ( host , port ) , 
 + HttpHeaders . Connection ( " Upgrade " ) , 
 + HttpHeaders . RawHeader ( " Upgrade " , " websocket " ) , 
 + HttpHeaders . RawHeader ( " Sec - WebSocket - Version " , " 13 " ) , 
 + HttpHeaders . RawHeader ( " Sec - WebSocket - Key " , " x3JJHMbDL1EzLkh9GBhXDw = = " ) , 
 + HttpHeaders . RawHeader ( " Sec - WebSocket - Extensions " , " permessage - deflate " ) 
 + ) 
 + 
 + val connect = Http . Connect ( host , port , ssl ) 
 + 
 + log . info ( " Connecting to { } " , url ) 
 + 
 + val req = HttpRequest ( HttpMethods . GET , spray . http . Uri ( Option ( uri . getPath ) . getOrElse ( " / " ) ) , headers ) 
 + val client = context . actorOf ( Props ( 
 + new WebSocketClient ( connect , req ) { 
 + override def onMessage ( frame : Frame ) = { 
 + context . parent ! frame 
 + } 
 + 
 + override def onClose ( ) = { 
 + context . parent ! ConnectionClosed 
 + } 
 + } 
 + ) ) 
 + 
 + private var receivedBuf = Vector . empty [ String ] 
 + 
 + def receive = { 
 + case TextFrame ( text ) ⇒ 
 + val str = text . decodeString ( " UTF - 8 " ) 
 + log . info ( " Received { } " , str ) 
 + if ( receivedBuf . isEmpty & & totalDemand > 0 ) 
 + onNext ( str ) 
 + else { 
 + receivedBuf : + = str 
 + deliverBuf ( ) 
 + } 
 + case frame : Frame ⇒ 
 + log . info ( " Unsupported frame { } " , frame ) 
 + case ActorPublisherMessage . Request ( _ ) ⇒ 
 + deliverBuf ( ) 
 + case ActorPublisherMessage . Cancel ⇒ 
 + context . stop ( self ) 
 + case ActorSubscriberMessage . OnNext ( textToSend : String ) ⇒ 
 + client ! textToSend 
 + case ConnectionClosed ⇒ 
 + log . error ( " Connection closed " ) 
 + onErrorThenStop ( new RuntimeException ( " Connection closed " ) ) 
 + case unmatched ⇒ 
 + log . error ( " Unmatched { } " , unmatched ) 
 + } 
 + 
 + override val requestStrategy = new WatermarkRequestStrategy ( Int . MaxValue ) 
 + 
 + @ tailrec final def deliverBuf ( ) : Unit = 
 + if ( totalDemand > 0 ) { 
 + / * 
 + * totalDemand is a Long and could be larger than 
 + * what buf . splitAt can accept 
 + * / 
 + if ( totalDemand < = Int . MaxValue ) { 
 + val ( use , keep ) = receivedBuf . splitAt ( totalDemand . toInt ) 
 + receivedBuf = keep 
 + use foreach onNext 
 + } else { 
 + val ( use , keep ) = receivedBuf . splitAt ( Int . MaxValue ) 
 + receivedBuf = keep 
 + use foreach onNext 
 + deliverBuf ( ) 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala 
 deleted file mode 100644 
 index cd95997 . . 0000000 
 - - - a / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala 
 + + + / dev / null 
 @ @ - 1 , 38 + 0 , 0 @ @ 
 - package im . actor . bot 
 - 
 - import derive . key 
 - 
 - sealed trait BotMessage 
 - sealed trait BotMessageIn extends BotMessage 
 - sealed trait BotMessageOut extends BotMessage 
 - 
 - final object BotMessages { 
 - final object OutPeer { 
 - def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) 
 - def group ( id : Int , accessHash : Long ) = OutPeer ( 2 , id , accessHash ) 
 - } 
 - final case class OutPeer ( ` type ` : Int , id : Int , accessHash : Long ) 
 - final case class Peer ( ` type ` : Int , id : Int ) 
 - 
 - sealed trait RequestBody 
 - 
 - final case class BotRequest ( id : Long , body : RequestBody ) extends BotMessageIn 
 - 
 - @ key ( " SendMessage " ) 
 - final case class SendTextMessage ( peer : OutPeer , randomId : Long , message : String ) extends RequestBody 
 - 
 - sealed trait ResponseBody 
 - 
 - final case class BotResponse ( id : Long , body : ResponseBody ) extends BotMessageOut 
 - 
 - @ key ( " MessageSent " ) 
 - final case class MessageSent ( date : Long ) extends ResponseBody 
 - 
 - sealed trait BotUpdate extends BotMessageOut 
 - 
 - @ key ( " TextMessage " ) 
 - final case class TextMessage ( peer : OutPeer , senderUserId : Int , date : Long , randomId : Long , text : String ) extends BotUpdate 
 - 
 - final def isPrivate ( peer : OutPeer ) = peer . ` type ` = = 1 
 - final def isGroup ( peer : OutPeer ) = peer . ` type ` = = 2 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotBase . scala b / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotBase . scala 
 new file mode 100644 
 index 0000000 . . c940421 
 - - - / dev / null 
 + + + b / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotBase . scala 
 @ @ - 0 , 0 + 1 , 11 @ @ 
 + package im . actor . bot 
 + 
 + trait BotBase { 
 + import BotMessages . _ 
 + 
 + protected def onTextMessage ( tm : TextMessage ) : Unit 
 + 
 + protected def sendTextMessage ( peer : OutPeer , text : String ) : Unit 
 + 
 + protected def outPeer ( userOutPeer : UserOutPeer ) = OutPeer ( 1 , userOutPeer . id , userOutPeer . accessHash ) 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotMessages . scala b / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotMessages . scala 
 new file mode 100644 
 index 0000000 . . dd99373 
 - - - / dev / null 
 + + + b / actor - server / actor - bot - shared / src / main / scala / im / actor / bot / BotMessages . scala 
 @ @ - 0 , 0 + 1 , 41 @ @ 
 + package im . actor . bot 
 + 
 + import derive . key 
 + 
 + sealed trait BotMessage 
 + sealed trait BotMessageIn extends BotMessage 
 + sealed trait BotMessageOut extends BotMessage 
 + 
 + final object BotMessages { 
 + final object OutPeer { 
 + def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) 
 + def group ( id : Int , accessHash : Long ) = OutPeer ( 2 , id , accessHash ) 
 + } 
 + final case class OutPeer ( ` type ` : Int , id : Int , accessHash : Long ) 
 + final case class UserOutPeer ( id : Int , accessHash : Long ) 
 + final case class Peer ( ` type ` : Int , id : Int ) 
 + 
 + sealed trait RequestBody 
 + 
 + final case class BotRequest ( id : Long , body : RequestBody ) extends BotMessageIn 
 + 
 + @ key ( " SendMessage " ) 
 + final case class SendTextMessage ( peer : OutPeer , randomId : Long , text : String ) extends RequestBody 
 + 
 + sealed trait ResponseBody 
 + 
 + @ key ( " Response " ) 
 + final case class BotResponse ( id : Long , body : ResponseBody ) extends BotMessageOut 
 + 
 + @ key ( " MessageSent " ) 
 + final case class MessageSent ( date : Long ) extends ResponseBody 
 + 
 + @ key ( " Update " ) 
 + sealed trait BotUpdate extends BotMessageOut 
 + 
 + @ key ( " TextMessage " ) 
 + final case class TextMessage ( peer : OutPeer , sender : UserOutPeer , date : Long , randomId : Long , text : String ) extends BotUpdate 
 + 
 + final def isPrivate ( peer : OutPeer ) = peer . ` type ` = = 1 
 + final def isGroup ( peer : OutPeer ) = peer . ` type ` = = 2 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotBlueprint . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotBlueprint . scala 
 deleted file mode 100644 
 index cf5f910 . . 0000000 
 - - - a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotBlueprint . scala 
 + + + / dev / null 
 @ @ - 1 , 63 + 0 , 0 @ @ 
 - package im . actor . server . bot 
 - 
 - import akka . actor . ActorSystem 
 - import akka . stream . scaladsl . { Flow , Merge , Source } 
 - import im . actor . api . rpc . messaging . ApiTextMessage 
 - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 - import im . actor . bot . { BotMessageOut , BotMessages } 
 - import im . actor . server . dialog . DialogExtension 
 - import im . actor . server . sequence . SeqStateDate 
 - 
 - import scala . concurrent . Future 
 - 
 - final class BotBlueprint ( botUserId : Int , botAuthId : Long , system : ActorSystem ) { 
 - 
 - import BotMessages . _ 
 - import akka . stream . scaladsl . FlowGraph . Implicits . _ 
 - import system . _ 
 - 
 - private lazy val dialogExt = DialogExtension ( system ) 
 - 
 - val flow : Flow [ BotRequest , BotMessageOut , Unit ] = { 
 - val updSource = 
 - Source . actorPublisher [ BotMessageOut ] ( UpdatesSource . props ( botAuthId ) ) 
 - 
 - val rqrspFlow = Flow [ BotRequest ] 
 - . mapAsync ( 1 ) ( r ⇒ handleRequest ( r . id , r . body ) ) 
 - . map ( _ . asInstanceOf [ BotMessageOut ] ) 
 - 
 - Flow ( ) { implicit b ⇒ 
 - val upd = b . add ( updSource ) 
 - val rqrsp = b . add ( rqrspFlow ) 
 - val merge = b . add ( Merge [ BotMessageOut ] ( 2 ) ) 
 - 
 - upd ~ > merge 
 - rqrsp ~ > merge 
 - 
 - ( rqrsp . inlet , merge . out ) 
 - } 
 - } 
 - 
 - private def handleRequest ( id : Long , body : RequestBody ) : Future [ BotResponse ] = 
 - for { 
 - response ← handleRequestBody ( body ) 
 - } yield BotResponse ( id , response ) 
 - 
 - private def handleRequestBody ( body : RequestBody ) : Future [ ResponseBody ] = body match { 
 - case SendTextMessage ( peer , randomId , message ) ⇒ sendTextMessage ( peer , randomId , message ) 
 - } 
 - 
 - private def sendTextMessage ( peer : OutPeer , randomId : Long , message : String ) : Future [ ResponseBody ] = { 
 - / / FIXME : check access hash 
 - for { 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( 
 - peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , 
 - senderUserId = botUserId , 
 - senderAuthId = 0L , 
 - randomId = randomId , 
 - message = ApiTextMessage ( message , Vector . empty , None ) , 
 - isFat = false 
 - ) 
 - } yield MessageSent ( date ) 
 - } 
 - } 
 diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala 
 new file mode 100644 
 index 0000000 . . a0015d0 
 - - - / dev / null 
 + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala 
 @ @ - 0 , 0 + 1 , 63 @ @ 
 + package im . actor . server . bot 
 + 
 + import akka . actor . ActorSystem 
 + import akka . stream . scaladsl . { Flow , Merge , Source } 
 + import im . actor . api . rpc . messaging . ApiTextMessage 
 + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . bot . { BotMessageOut , BotMessages } 
 + import im . actor . server . dialog . DialogExtension 
 + import im . actor . server . sequence . SeqStateDate 
 + 
 + import scala . concurrent . Future 
 + 
 + final class BotServerBlueprint ( botUserId : Int , botAuthId : Long , system : ActorSystem ) { 
 + 
 + import BotMessages . _ 
 + import akka . stream . scaladsl . FlowGraph . Implicits . _ 
 + import system . _ 
 + 
 + private lazy val dialogExt = DialogExtension ( system ) 
 + 
 + val flow : Flow [ BotRequest , BotMessageOut , Unit ] = { 
 + val updSource = 
 + Source . actorPublisher [ BotMessageOut ] ( UpdatesSource . props ( botAuthId ) ) 
 + 
 + val rqrspFlow = Flow [ BotRequest ] 
 + . mapAsync ( 1 ) ( r ⇒ handleRequest ( r . id , r . body ) ) 
 + . map ( _ . asInstanceOf [ BotMessageOut ] ) 
 + 
 + Flow ( ) { implicit b ⇒ 
 + val upd = b . add ( updSource ) 
 + val rqrsp = b . add ( rqrspFlow ) 
 + val merge = b . add ( Merge [ BotMessageOut ] ( 2 ) ) 
 + 
 + upd ~ > merge 
 + rqrsp ~ > merge 
 + 
 + ( rqrsp . inlet , merge . out ) 
 + } 
 + } 
 + 
 + private def handleRequest ( id : Long , body : RequestBody ) : Future [ BotResponse ] = 
 + for { 
 + response ← handleRequestBody ( body ) 
 + } yield BotResponse ( id , response ) 
 + 
 + private def handleRequestBody ( body : RequestBody ) : Future [ ResponseBody ] = body match { 
 + case SendTextMessage ( peer , randomId , message ) ⇒ sendTextMessage ( peer , randomId , message ) 
 + } 
 + 
 + private def sendTextMessage ( peer : OutPeer , randomId : Long , message : String ) : Future [ ResponseBody ] = { 
 + / / FIXME : check access hash 
 + for { 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( 
 + peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , 
 + senderUserId = botUserId , 
 + senderAuthId = 0L , 
 + randomId = randomId , 
 + message = ApiTextMessage ( message , Vector . empty , None ) , 
 + isFat = false 
 + ) 
 + } yield MessageSent ( date ) 
 + } 
 + } 
 diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / InternalBot . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / InternalBot . scala 
 index f4fcfca . . 59a4ff3 100644 
 - - - a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / InternalBot . scala 
 + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / InternalBot . scala 
 @ @ - 6 , 7 + 6 , 7 @ @ import akka . stream . ActorMaterializer 
 import akka . stream . scaladsl . Sink 
 import im . actor . api . rpc . messaging . ApiTextMessage 
 import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } 
 - import im . actor . bot . BotMessages 
 + import im . actor . bot . { BotBase , BotMessages } 
 import im . actor . server . dialog . DialogExtension 
 
 import scala . concurrent . Future 
 @ @ - 18 , 7 + 18 , 7 @ @ private object InternalBot { 
 final case class Initialized ( authId : Long ) 
 } 
 
 - abstract class InternalBot ( userId : Int , nickname : String , name : String ) extends Actor with ActorLogging { 
 + abstract class InternalBot ( userId : Int , nickname : String , name : String ) extends Actor with ActorLogging with BotBase { 
 
 import BotMessages . _ 
 import InternalBot . _ 
 @ @ - 31 , 9 + 31 , 7 @ @ abstract class InternalBot ( userId : Int , nickname : String , name : String ) extends 
 
 init ( ) 
 
 - def onTextMessage ( tm : TextMessage ) : Unit 
 - 
 - protected def sendTextMessage ( peer : OutPeer , text : String ) : Unit = { 
 + override protected def sendTextMessage ( peer : OutPeer , text : String ) : Unit = { 
 / / FIXME : check access hash 
 dialogExt . sendMessage ( 
 peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , 
 diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / UpdatesSource . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / UpdatesSource . scala 
 index f2d1f51 . . 74be274 100644 
 - - - a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / UpdatesSource . scala 
 + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / UpdatesSource . scala 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 package im . actor . server . bot 
 
 - import akka . actor . { ActorLogging , Props } 
 + import akka . actor . { Stash , ActorLogging , Props } 
 import akka . pattern . pipe 
 import akka . stream . actor . ActorPublisher 
 import akka . stream . scaladsl . Source 
 @ @ - 8 , 15 + 8 , 22 @ @ import im . actor . api . rpc . codecs . _ 
 import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateMessage } 
 import im . actor . api . rpc . sequence . SeqUpdate 
 import im . actor . bot . BotMessages 
 - import im . actor . bot . BotMessages . { OutPeer , BotUpdate } 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . mtproto . protocol . UpdateBox 
 import im . actor . server . presences . { GroupPresenceManager , PresenceManager } 
 import im . actor . server . sequence . { UpdatesConsumer , WeakUpdatesManager } 
 + import im . actor . server . user . UserExtension 
 + import im . actor . server . persist 
 
 import scala . annotation . tailrec 
 
 private [ bot ] object UpdatesSource { 
 + import BotMessages . _ 
 + 
 + private case class Initialized ( userId : Int ) 
 + private case object AuthIdNotAuthorized 
 + 
 def source ( authId : Long ) = Source . actorPublisher [ BotUpdate ] ( props ( authId ) ) 
 
 def props ( authId : Long ) = Props ( classOf [ UpdatesSource ] , authId ) 
 @ @ - 24 , 10 + 31 , 10 @ @ private [ bot ] object UpdatesSource { 
 private final case class Enqueue ( upd : BotUpdate ) 
 } 
 
 - private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotUpdate ] with ActorLogging { 
 + private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotMessages . BotUpdate ] with ActorLogging with Stash { 
 
 import UpdatesSource . _ 
 - import BotMessages . TextMessage 
 + import BotMessages . _ 
 import akka . stream . actor . ActorPublisherMessage . _ 
 import context . _ 
 import im . actor . server . sequence . NewUpdate 
 @ @ - 35 , 12 + 42 , 29 @ @ private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotUpdate ] with 
 private implicit val weakUpdatesManagerRegion = WeakUpdatesManager . startRegionProxy ( ) 
 private implicit val presenceManagerRegion = PresenceManager . startRegionProxy ( ) 
 private implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegionProxy ( ) 
 + private val userExt = UserExtension ( system ) 
 + private val db = DbExtension ( system ) . db 
 
 context . actorOf ( UpdatesConsumer . props ( authId , self ) , " updatesConsumer " ) 
 
 private var buf = Vector . empty [ BotMessages . BotUpdate ] 
 
 + db . run ( persist . AuthId . findUserId ( authId ) ) . map { 
 + case Some ( userId ) ⇒ Initialized ( userId ) 
 + case None ⇒ AuthIdNotAuthorized 
 + } . pipeTo ( self ) 
 + 
 def receive = { 
 + case Initialized ( userId ) ⇒ 
 + context become working ( userId ) 
 + case AuthIdNotAuthorized ⇒ 
 + val msg = " AuthId not authorized " 
 + log . error ( msg ) 
 + throw new RuntimeException ( msg ) 
 + case msg ⇒ stash ( ) 
 + } 
 + 
 + def working ( userId : Int ) : Receive = { 
 case Enqueue ( upd ) ⇒ enqueue ( upd ) 
 case NewUpdate ( UpdateBox ( bodyBytes ) , _ ) ⇒ 
 UpdateBoxCodec . decode ( bodyBytes ) . require . value match { 
 @ @ - 51 , 18 + 75 , 21 @ @ private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotUpdate ] with 
 case Right ( upd ) ⇒ 
 upd . message match { 
 case ApiTextMessage ( message , _ , _ ) ⇒ 
 - log . debug ( " Received ApiTextMessage " ) 
 - 
 - ( for { 
 - apiOutPeer ← ACLUtils . getOutPeer ( upd . peer , authId ) 
 - } yield Enqueue ( TextMessage ( 
 - peer = OutPeer ( apiOutPeer . ` type ` . id , apiOutPeer . id , apiOutPeer . accessHash ) , 
 - senderUserId = upd . senderUserId , 
 - date = upd . date , 
 - randomId = upd . randomId , 
 - text = message 
 - ) ) ) pipeTo self 
 - 
 + if ( upd . senderUserId ! = userId ) { 
 + log . debug ( " Received message { } " , message ) 
 + ( for { 
 + apiOutPeer ← ACLUtils . getOutPeer ( upd . peer , authId ) 
 + senderAccessHash ← userExt . getAccessHash ( upd . senderUserId , authId ) 
 + } yield Enqueue ( TextMessage ( 
 + peer = OutPeer ( apiOutPeer . ` type ` . id , apiOutPeer . id , apiOutPeer . accessHash ) , 
 + sender = UserOutPeer ( upd . senderUserId , senderAccessHash ) , 
 + date = upd . date , 
 + randomId = upd . randomId , 
 + text = message 
 + ) ) ) pipeTo self 
 + } else { 
 + log . debug ( " Message from self , ignoring " ) 
 + } 
 case _ ⇒ 
 log . debug ( " Received non - text message , ignoring " ) 
 } 
 @ @ - 82 , 8 + 109 , 6 @ @ private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotUpdate ] with 
 } 
 
 private def enqueue ( upd : BotMessages . BotUpdate ) : Unit = { 
 - log . debug ( " Enqueuing { } " , upd ) 
 - 
 if ( buf . isEmpty & & totalDemand > 0 ) { 
 onNext ( upd ) 
 } else { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 index f927d77 . . 41d633a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 @ @ - 36 , 6 + 36 , 7 @ @ private [ dialog ] final class ActorDelivery ( ) ( implicit val system : ActorSystem ) ex 
 randomId = randomId , 
 message = message 
 ) 
 + 
 for { 
 receiverAuthIds ← userExt . getAuthIds ( receiverUserId ) 
 _ ← receiverAuthIds match { 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala 
 index 204033d . . 12ee5c0 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala 
 @ @ - 9 , 6 + 9 , 7 @ @ import akka . http . scaladsl . server . Route 
 import akka . stream . Materializer 
 import com . typesafe . config . Config 
 import im . actor . server . api . http . app . AppFilesHandler 
 + import im . actor . server . api . http . bots . BotsHandler 
 import im . actor . server . api . http . groups . GroupsHandler 
 import im . actor . server . api . http . status . StatusHandler 
 import im . actor . server . api . http . webhooks . WebhooksHandler 
 @ @ - 57 , 6 + 58 , 7 @ @ object HttpApiFrontend { 
 val webhooks = new WebhooksHandler 
 val groups = new GroupsHandler 
 val status = new StatusHandler 
 + val bots = new BotsHandler 
 val app = new AppFilesHandler ( config . staticFiles ) 
 
 / / format : OFF 
 @ @ - 64 , 6 + 66 , 7 @ @ object HttpApiFrontend { 
 app . routes ~ 
 pathPrefix ( " v1 " ) { 
 respondWithDefaultHeaders ( corsHeaders ) { 
 + bots . routes ~ 
 status . routes ~ 
 groups . routes ~ 
 webhooks . routes 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 index 57e8119 . . 18ac248 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 @ @ - 9 , 12 + 9 , 12 @ @ import cats . data . OptionT 
 import cats . std . future . _ 
 import im . actor . bot . BotMessages . { BotRequest , BotResponse , BotUpdate } 
 import im . actor . server . api . http . RoutesHandler 
 - import im . actor . server . bot . { BotBlueprint , BotExtension } 
 + import im . actor . server . bot . { BotServerBlueprint , BotExtension } 
 import upickle . default . _ 
 
 import scala . util . control . NoStackTrace 
 
 - private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler { 
 + private [ http ] final class BotsHandler ( implicit system : ActorSystem ) extends RoutesHandler { 
 
 import system . _ 
 
 @ @ - 26 , 7 + 26 , 8 @ @ private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler 
 authId ← OptionT ( botExt . getAuthId ( token ) ) 
 } yield flow ( userId , authId ) ) . value map { 
 case Some ( r ) ⇒ r 
 - case None ⇒ throw new RuntimeException ( " Wrong token " ) with NoStackTrace 
 + case None ⇒ 
 + throw new RuntimeException ( " Wrong token " ) with NoStackTrace 
 } 
 
 onSuccess ( flowFuture ) { 
 @ @ - 35 , 7 + 36 , 7 @ @ private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler 
 } 
 
 private def flow ( botUserId : Int , botAuthId : Long ) = { 
 - val bp = new BotBlueprint ( botUserId , botAuthId , system ) 
 + val bp = new BotServerBlueprint ( botUserId , botAuthId , system ) 
 
 Flow [ Message ] 
 . collect { 
 @ @ - 44 , 8 + 45 , 15 @ @ private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler 
 } 
 . via ( bp . flow ) 
 . map { 
 - case rsp : BotResponse ⇒ write [ BotResponse ] ( rsp ) 
 - case upd : BotUpdate ⇒ write [ BotUpdate ] ( upd ) 
 + case rsp : BotResponse ⇒ 
 + log . debug ( " Sending response { } " , rsp ) 
 + write [ BotResponse ] ( rsp ) 
 + case upd : BotUpdate ⇒ 
 + log . debug ( " Sending update { } " , upd ) 
 + write [ BotUpdate ] ( upd ) 
 + case unmatched ⇒ 
 + log . error ( " Unmatched { } " , unmatched ) 
 + throw new RuntimeException ( s " Unmatched BotMessage $ { unmatched } " ) 
 } 
 . map ( TextMessage . Strict ( _ ) . asInstanceOf [ Message ] ) 
 } 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index 36f9745 . . 07d520e 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 75 , 7 + 75 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 Revolver . settings + + 
 Seq ( 
 libraryDependencies + + = Dependencies . root , 
 - Revolver . reStartArgs : = Seq ( " im . actor . server . Main " ) , 
 + / / Revolver . reStartArgs : = Seq ( " im . actor . server . Main " ) , 
 mainClass in Revolver . reStart : = Some ( " im . actor . server . Main " ) , 
 mainClass in Compile : = Some ( " im . actor . server . Main " ) , 
 autoCompilerPlugins : = true , 
 @ @ - 91 , 6 + 91 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 / / actorDashboard , 
 actorCore , 
 actorBot , 
 + actorBotKit , 
 actorEmail , 
 actorEnrich , 
 actorFrontend , 
 @ @ - 106 , 7 + 107 , 8 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 shardakka 
 ) 
 . settings ( 
 - aggregate in Docker : = false 
 + aggregate in Docker : = false , 
 + aggregate in Revolver . reStart : = false 
 ) 
 
 lazy val actorRunner = Project ( 
 @ @ - 142 , 11 + 144 , 19 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 Seq ( 
 libraryDependencies + + = Dependencies . bot 
 ) 
 - ) . dependsOn ( actorBotMessages , shardakka , actorCore , actorTestkit % " test " ) 
 + ) . dependsOn ( actorBotShared , shardakka , actorCore , actorTestkit % " test " ) 
 
 - lazy val actorBotMessages = Project ( 
 - id = " actor - bot - messages " , 
 - base = file ( " actor - bot - messages " ) , 
 + lazy val actorBotKit = Project ( 
 + id = " actor - bot - kit " , 
 + base = file ( " actor - bot - kit " ) , 
 + settings = defaultSettings + + Revolver . settings + + Seq ( 
 + libraryDependencies + + = Dependencies . botKit 
 + ) 
 + ) . dependsOn ( actorBotShared ) 
 + 
 + lazy val actorBotShared = Project ( 
 + id = " actor - bot - shared " , 
 + base = file ( " actor - bot - shared " ) , 
 settings = defaultSettings + + 
 Seq ( 
 libraryDependencies + + = Dependencies . botMessages 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 8a7da4b . . fddf038 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 6 , 11 + 6 , 10 @ @ object Dependencies { 
 object V { 
 val akka = " 2 . 3 . 13 " 
 val akkaExperimental = " 1 . 0 " 
 + val cats = " 0 . 2 . 0 " 
 val scalaz = " 7 . 1 . 1 " 
 val slick = " 3 . 0 . 3 " 
 val scalatest = " 2 . 2 . 4 " 
 - val catsVersion = " 0 . 2 . 0 " 
 - 
 } 
 
 object Compile { 
 @ @ - 23 , 6 + 22 , 8 @ @ object Dependencies { 
 val akkaHttpPlayJson = " de . heikoseeberger " % % " akka - http - play - json " % " 1 . 0 . 0 " 
 val akkaSlf4j = " com . typesafe . akka " % % " akka - slf4j " % V . akka 
 
 + val sprayWebsocket = " com . wandoulabs . akka " % % " spray - websocket " % " 0 . 1 . 4 " 
 + 
 val akkaPersistenceJdbc = " com . github . dnvriend " % % " akka - persistence - jdbc " % " 1 . 1 . 7 " 
 val apacheEmail = " org . apache . commons " % " commons - email " % " 1 . 4 " 
 
 @ @ - 30 , 7 + 31 , 7 @ @ object Dependencies { 
 val caffeine = " com . github . ben - manes . caffeine " % " caffeine " % " 1 . 2 . 0 " 
 val eaioUuid = " com . eaio . uuid " % " uuid " % " 3 . 4 " 
 
 - val cats = " org . spire - math " % % " cats " % V . catsVersion 
 + val cats = " org . spire - math " % % " cats " % V . cats 
 
 val configs = " com . github . kxbmap " % % " configs " % " 0 . 2 . 4 " 
 
 @ @ - 104 , 6 + 105 , 8 @ @ object Dependencies { 
 
 val bot = shared + + Seq ( upickle ) 
 
 + val botKit = Seq ( akkaActor , akkaHttp , akkaSlf4j , sprayWebsocket , upickle ) 
 + 
 val botMessages = Seq ( upickle ) 
 
 val core = shared + + Seq ( akkaActor , akkaContrib , amazonaws , awsWrap , caffeine , gcmServer , pushy , jodaTime , postgresJdbc , slick , scrImageCore ) 
 diff - - git a / actor - server / project / plugins . sbt b / actor - server / project / plugins . sbt 
 index 394e20b . . b4a2e7f 100644 
 - - - a / actor - server / project / plugins . sbt 
 + + + b / actor - server / project / plugins . sbt 
 @ @ - 27 , 4 + 27 , 6 @ @ addSbtPlugin ( " com . trueaccord . scalapb " % " sbt - scalapb " % " 0 . 5 . 14 " ) 
 
 addSbtPlugin ( " me . lessis " % " bintray - sbt " % " 0 . 3 . 0 " ) 
 
 + addSbtPlugin ( " com . eed3si9n " % " sbt - assembly " % " 0 . 14 . 0 " ) 
 + 
 libraryDependencies + + = Seq ( " com . github . os72 " % " protoc - jar " % " 3 . 0 . 0 - a3 " ) 
 \ No newline at end of file
