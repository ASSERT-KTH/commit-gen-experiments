BLEU SCORE: 0.5706745777055999

TEST MSG: fix ( server : messaging ) : send UpdateCountersChanged to reader
GENERATED MSG: fix ( server : messaging ) : delete chat fix

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index f72fdbe . . 853dc34 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 252 , 15 + 252 , 6 @ @ message DialogCommands { < nl > required SeqState seqstate = 1 ; < nl > repeated MessageReaction reactions = 2 ; < nl > } < nl > - < nl > - message UpdateCounters { < nl > - option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; < nl > - < nl > - required Peer origin = 1 ; < nl > - required Peer dest = 2 ; < nl > - } < nl > - < nl > - message UpdateCountersAck { } < nl > } < nl > < nl > message DialogQueries { < nl > @ @ - 303 , 5 + 294 , 6 @ @ message DialogEvents { < nl > option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; < nl > < nl > required int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + required int32 reader _ user _ id = 8 ; < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 5dd6fe8 . . 3c17cd5 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 64 , 12 + 64 , 6 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > } < nl > } < nl > < nl > - protected def updateCountersChanged ( ) : Unit = { < nl > - deliveryExt . sendCountersUpdate ( userId ) < nl > - . map ( _ ⇒ SendMessageAck ( ) ) < nl > - . pipeTo ( sender ( ) ) < nl > - } < nl > - < nl > protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > val messageDate = sm . date getOrElse { < nl > throw new RuntimeException ( " No message date found in SendMessage " ) < nl > @ @ - 87 , 6 + 81 , 8 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , messageDate , sm . message , sm . isFat ) < nl > . map ( _ ⇒ SendMessageAck ( ) ) < nl > . pipeTo ( sender ( ) ) < nl > + < nl > + deliveryExt . sendCountersUpdate ( userId ) < nl > } < nl > } < nl > < nl > @ @ - 134 , 18 + 130 , 23 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > val mustRead = mustMakeRead ( state , mr ) < nl > < nl > if ( mustRead ) { < nl > - ( for { < nl > - _ ← dialogExt . ackMessageRead ( peer , mr ) < nl > - _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , Some ( state . counter ) ) < nl > - _ ← deliveryExt . sendCountersUpdate ( userId ) < nl > - } yield MessageReadAck ( ) ) pipeTo sender ( ) < nl > + persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . origin . id ) ) { e ⇒ < nl > + commit ( e ) < nl > + < nl > + ( for { < nl > + _ ← dialogExt . ackMessageRead ( peer , mr ) < nl > + _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , Some ( state . counter ) ) < nl > + _ = deliveryExt . sendCountersUpdate ( userId ) < nl > + } yield MessageReadAck ( ) ) pipeTo sender ( ) < nl > + } < nl > } else { < nl > sender ( ) ! MessageReadAck ( ) < nl > } < nl > } < nl > < nl > protected def ackMessageRead ( mr : MessageRead ) : Unit = { < nl > - persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ < nl > + require ( mr . origin . typ . isPrivate ) < nl > + persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . origin . id ) ) { e ⇒ < nl > commit ( e ) < nl > ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { < nl > case Failure ( err ) ⇒ log . error ( err , " Failed to ack MessageRead " ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 186352c . . 76609d8 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 8 , 11 + 8 , 10 @ @ import akka . http . scaladsl . util . FastFuture < nl > import akka . pattern . ask < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . _ < nl > - import im . actor . api . rpc . messaging . { ApiDialog , ApiDialogGroup , ApiDialogShort , ApiMessage } < nl > + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiMessage } < nl > import im . actor . api . rpc . misc . ApiExtension < nl > - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . api . rpc . peers . ApiPeer < nl > import im . actor . extension . InternalExtensions < nl > - import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . DialogCommands . _ < nl > import im . actor . server . group . { GroupEnvelope , GroupExtension } < nl > import im . actor . server . model . _ < nl > @ @ - 35 , 7 + 34 , 6 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > < nl > val InternalDialogExtensions = " modules . messaging . extensions " < nl > < nl > - private val db = DbExtension ( system ) . db < nl > private lazy val userExt = UserExtension ( system ) < nl > private lazy val groupExt = GroupExtension ( system ) < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 1807c78 . . 131fd17 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 49 , 6 + 49 , 7 @ @ private case class UnreadMessage ( date : Instant , randomId : Long ) { < nl > } < nl > < nl > private [ dialog ] final case class DialogState ( < nl > + userId : Int , < nl > lastMessageDate : Instant , / / we don ' t use it now anywhere . should we remove it ? < nl > lastReceiveDate : Instant , < nl > lastReadDate : Instant , < nl > @ @ - 58 , 8 + 59 , 6 @ @ private [ dialog ] final case class DialogState ( < nl > import DialogEvents . _ < nl > < nl > override def updated ( e : DialogEvent ) : DialogState = e match { < nl > - case MessagesRead ( date ) if date . isAfter ( lastReadDate ) ⇒ this . copy ( lastReadDate = date ) < nl > - case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) < nl > case NewMessage ( randomId , date , isIncoming ) ⇒ < nl > if ( isIncoming ) { < nl > this . copy ( < nl > @ @ - 68 , 10 + 67 , 12 @ @ private [ dialog ] final case class DialogState ( < nl > lastMessageDate = date < nl > ) < nl > } else this < nl > - case MessagesRead ( date ) ⇒ < nl > + case MessagesRead ( date , readerUserId ) if readerUserId = = userId ⇒ < nl > val newUnreadMessages = unreadMessages . dropWhile ( um ⇒ um . date . isBefore ( date ) | | um . date = = date ) < nl > this . copy ( counter = newUnreadMessages . size , unreadMessages = newUnreadMessages ) < nl > - case _ ⇒ this < nl > + case MessagesRead ( date , readerUserId ) if readerUserId ! = userId & & date . isAfter ( lastReadDate ) ⇒ < nl > + this . copy ( lastReadDate = date ) < nl > + case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) < nl > } < nl > } < nl > < nl > @ @ - 135 , 6 + 136 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > < nl > override protected def getInitialState : DialogState = < nl > DialogState ( < nl > + userId = userId , < nl > lastMessageDate = Instant . ofEpochMilli ( 0 ) , < nl > lastReceiveDate = Instant . ofEpochMilli ( 0 ) , < nl > lastReadDate = Instant . ofEpochMilli ( 0 ) , < nl > @ @ - 164 , 7 + 166 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) < nl > case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( rr ) < nl > - case uc : UpdateCounters ⇒ updateCountersChanged ( ) < nl > } < nl > < nl > / / when receiving this messages , dialog is required to take an action < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / SeqUpdateMatchers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / SeqUpdateMatchers . scala < nl > index dc297cb . . 8884cf9 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / SeqUpdateMatchers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / SeqUpdateMatchers . scala < nl > @ @ - 59 , 6 + 59 , 20 @ @ trait SeqUpdateMatchers extends Matchers with ScalaFutures with AnyRefLogSource < nl > } < nl > ) < nl > < nl > + def expectUpdatesUnordered ( updates : UpdateClass * ) ( check : PartialFunction [ Seq [ Update ] , Any ] ) ( implicit client : ClientData ) : Int = < nl > + expectUpdatesUnordered ( seq = 0 , updates : _ * ) ( check ) < nl > + < nl > + def expectUpdatesUnordered ( seq : Int , updates : UpdateClass * ) ( check : PartialFunction [ Seq [ Update ] , Any ] ) ( implicit client : ClientData ) : Int = < nl > + expectUpdatesAbstract ( seq , updates ) ( check ) ( < nl > + { ( dbUpdatesHeaders , updatesHeaders ) ⇒ updatesHeaders . toSet subsetOf dbUpdatesHeaders . toSet } , < nl > + { ( dbUpdatesNames , updatesNames ) ⇒ < nl > + s " " " Error : did not get expected updates . < nl > + | expected updates : $ updatesNames < nl > + | actual updates : $ dbUpdatesNames < nl > + " " " . stripMargin < nl > + } < nl > + ) < nl > + < nl > def expectUpdatesOnly ( updates : UpdateClass * ) ( check : PartialFunction [ Seq [ Update ] , Any ] ) ( implicit client : ClientData ) : Int = < nl > expectUpdatesOnly ( seq = 0 , updates : _ * ) ( check ) < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > index 8c11fa8 . . 1a57e1d 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > @ @ - 102 , 7 + 102 , 7 @ @ class MessagingServiceSpec < nl > { < nl > implicit val clientData = clientData2 < nl > < nl > - expectUpdates ( classOf [ UpdateChatGroupsChanged ] , classOf [ UpdateMessage ] , classOf [ UpdateCountersChanged ] ) { < nl > + expectUpdatesUnordered ( classOf [ UpdateChatGroupsChanged ] , classOf [ UpdateMessage ] , classOf [ UpdateCountersChanged ] ) { < nl > case Seq ( upd : UpdateMessage ) ⇒ < nl > upd . peer shouldEqual ApiPeer ( ApiPeerType . Private , user1 . id ) < nl > upd . randomId shouldEqual randomId
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 6ec13a8 . . ae2fd6a 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 21 , 6 + 21 , 7 @ @ message DialogCommands { < nl > MessageRead message _ read = 5 ; < nl > Show show = 6 ; < nl > Hide hide = 7 ; < nl > + Delete delete = 8 ; < nl > } < nl > } < nl > < nl > @ @ - 85 , 4 + 86 , 10 @ @ message DialogCommands { < nl > required Peer dest = 1 ; < nl > } < nl > < nl > + message Delete { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + < nl > + required Peer dest = 1 ; < nl > + } < nl > + < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 0a7864f . . 41607a4 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 1 , 6 + 1 , 6 @ @ < nl > package im . actor . server . dialog < nl > < nl > - import akka . actor . { ActorRef , Status } < nl > + import akka . actor . { PoisonPill , ActorRef , Status } < nl > import akka . pattern . pipe < nl > import im . actor . api . rpc . PeersImplicits < nl > import im . actor . api . rpc . messaging . _ < nl > @ @ - 179 , 6 + 179 , 22 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } < nl > } < nl > < nl > + protected def delete ( state : DialogState ) : Unit = { < nl > + val update = UpdateChatDelete ( peer . asStruct ) < nl > + < nl > + val future = < nl > + for { < nl > + _ ← db . run ( < nl > + HistoryMessageRepo . deleteAll ( userId , peer ) < nl > + andThen DialogRepo . delete ( userId , peer ) < nl > + ) < nl > + _ ← userExt . notifyDialogsChanged ( userId ) < nl > + seqstate ← seqUpdExt . deliverSingleUpdate ( userId , update ) < nl > + } yield seqstate < nl > + < nl > + future pipeTo sender ( ) onSuccess { case _ ⇒ self ! PoisonPill } < nl > + } < nl > + < nl > private def mustMakeReceive ( state : DialogState , mr : MessageReceived ) : Boolean = < nl > ( mr . date > state . lastReceiveDate ) & & / / receive date is later than last receive date < nl > ( mr . date < = mr . now ) & & / / and receive date is not in future < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 461366f . . 8deb88d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 23 , 6 + 23 , 7 @ @ import slick . dbio . DBIO < nl > < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . reflect . ClassTag < nl > < nl > sealed trait DialogGroup { < nl > def key : String < nl > @ @ - 60 , 7 + 61 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > < nl > private val log = Logging ( system , getClass ) < nl > < nl > - private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ Future [ A ] = Future . failed [ A ] ( DialogErrors . MessageToSelf ) ) ( f : ⇒ Future [ A ] ) : Future [ A ] = < nl > peer match { < nl > case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ < nl > log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) < nl > @ @ - 124 , 6 + 125 , 11 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > } < nl > < nl > + def delete ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > + withValidPeer ( peer , userId ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withDelete ( Delete ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > + < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > case Seq ( ) ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 78a18df . . b922722 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 13 , 7 + 13 , 7 @ @ import im . actor . server . cqrs . ProcessorState < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . model . { Dialog ⇒ DialogModel , Peer } < nl > import im . actor . server . persist . DialogRepo < nl > - import im . actor . server . sequence . SeqStateDate < nl > + import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . cache . CacheHelpers . _ < nl > @ @ - 105 , 6 + 105 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > < nl > protected val dialogExt = DialogExtension ( system ) < nl > protected val deliveryExt = dialogExt . getDeliveryExtension ( extensions ) < nl > + protected val seqUpdExt = SeqUpdatesExtension ( context . system ) < nl > < nl > protected val selfPeer : Peer = Peer . privat ( userId ) < nl > < nl > @ @ - 134 , 6 + 135 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) < nl > case Show ( _ ) ⇒ show ( state ) < nl > case Hide ( _ ) ⇒ hide ( state ) < nl > + case Delete ( _ ) ⇒ delete ( state ) < nl > } < nl > < nl > / * * < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index 358c65b . . b759493 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 59 , 17 + 59 , 11 @ @ trait HistoryHandlers { < nl > } < nl > < nl > override def jhandleDeleteChat ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { < nl > - val action = requireAuth ( clientData ) . map { implicit client ⇒ < nl > - val update = UpdateChatDelete ( peer . asPeer ) < nl > - < nl > + authorized ( clientData ) { implicit client ⇒ < nl > for { < nl > - _ ← persist . HistoryMessageRepo . deleteAll ( client . userId , peer . asModel ) < nl > - _ ← persist . DialogRepo . delete ( client . userId , peer . asModel ) < nl > - seqstate ← DBIO . from ( userExt . broadcastClientUpdate ( update , None , isFat = false ) ) < nl > - } yield Ok ( ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) ) < nl > + SeqState ( seq , state ) ← dialogExt . delete ( client . userId , peer . asModel ) < nl > + } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) < nl > } < nl > - < nl > - db . run ( toDBIOAction ( action ) ) < nl > } < nl > < nl > override def jhandleLoadDialogs ( endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = {

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index f72fdbe . . 853dc34 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 252 , 15 + 252 , 6 @ @ message DialogCommands { 
 required SeqState seqstate = 1 ; 
 repeated MessageReaction reactions = 2 ; 
 } 
 - 
 - message UpdateCounters { 
 - option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; 
 - 
 - required Peer origin = 1 ; 
 - required Peer dest = 2 ; 
 - } 
 - 
 - message UpdateCountersAck { } 
 } 
 
 message DialogQueries { 
 @ @ - 303 , 5 + 294 , 6 @ @ message DialogEvents { 
 option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; 
 
 required int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + required int32 reader _ user _ id = 8 ; 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 5dd6fe8 . . 3c17cd5 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 64 , 12 + 64 , 6 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 } 
 } 
 
 - protected def updateCountersChanged ( ) : Unit = { 
 - deliveryExt . sendCountersUpdate ( userId ) 
 - . map ( _ ⇒ SendMessageAck ( ) ) 
 - . pipeTo ( sender ( ) ) 
 - } 
 - 
 protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 val messageDate = sm . date getOrElse { 
 throw new RuntimeException ( " No message date found in SendMessage " ) 
 @ @ - 87 , 6 + 81 , 8 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , messageDate , sm . message , sm . isFat ) 
 . map ( _ ⇒ SendMessageAck ( ) ) 
 . pipeTo ( sender ( ) ) 
 + 
 + deliveryExt . sendCountersUpdate ( userId ) 
 } 
 } 
 
 @ @ - 134 , 18 + 130 , 23 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 val mustRead = mustMakeRead ( state , mr ) 
 
 if ( mustRead ) { 
 - ( for { 
 - _ ← dialogExt . ackMessageRead ( peer , mr ) 
 - _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , Some ( state . counter ) ) 
 - _ ← deliveryExt . sendCountersUpdate ( userId ) 
 - } yield MessageReadAck ( ) ) pipeTo sender ( ) 
 + persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . origin . id ) ) { e ⇒ 
 + commit ( e ) 
 + 
 + ( for { 
 + _ ← dialogExt . ackMessageRead ( peer , mr ) 
 + _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , Some ( state . counter ) ) 
 + _ = deliveryExt . sendCountersUpdate ( userId ) 
 + } yield MessageReadAck ( ) ) pipeTo sender ( ) 
 + } 
 } else { 
 sender ( ) ! MessageReadAck ( ) 
 } 
 } 
 
 protected def ackMessageRead ( mr : MessageRead ) : Unit = { 
 - persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ 
 + require ( mr . origin . typ . isPrivate ) 
 + persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . origin . id ) ) { e ⇒ 
 commit ( e ) 
 ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { 
 case Failure ( err ) ⇒ log . error ( err , " Failed to ack MessageRead " ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 186352c . . 76609d8 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 8 , 11 + 8 , 10 @ @ import akka . http . scaladsl . util . FastFuture 
 import akka . pattern . ask 
 import akka . util . Timeout 
 import im . actor . api . rpc . _ 
 - import im . actor . api . rpc . messaging . { ApiDialog , ApiDialogGroup , ApiDialogShort , ApiMessage } 
 + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiMessage } 
 import im . actor . api . rpc . misc . ApiExtension 
 - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . api . rpc . peers . ApiPeer 
 import im . actor . extension . InternalExtensions 
 - import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . DialogCommands . _ 
 import im . actor . server . group . { GroupEnvelope , GroupExtension } 
 import im . actor . server . model . _ 
 @ @ - 35 , 7 + 34 , 6 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 
 val InternalDialogExtensions = " modules . messaging . extensions " 
 
 - private val db = DbExtension ( system ) . db 
 private lazy val userExt = UserExtension ( system ) 
 private lazy val groupExt = GroupExtension ( system ) 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 1807c78 . . 131fd17 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 49 , 6 + 49 , 7 @ @ private case class UnreadMessage ( date : Instant , randomId : Long ) { 
 } 
 
 private [ dialog ] final case class DialogState ( 
 + userId : Int , 
 lastMessageDate : Instant , / / we don ' t use it now anywhere . should we remove it ? 
 lastReceiveDate : Instant , 
 lastReadDate : Instant , 
 @ @ - 58 , 8 + 59 , 6 @ @ private [ dialog ] final case class DialogState ( 
 import DialogEvents . _ 
 
 override def updated ( e : DialogEvent ) : DialogState = e match { 
 - case MessagesRead ( date ) if date . isAfter ( lastReadDate ) ⇒ this . copy ( lastReadDate = date ) 
 - case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) 
 case NewMessage ( randomId , date , isIncoming ) ⇒ 
 if ( isIncoming ) { 
 this . copy ( 
 @ @ - 68 , 10 + 67 , 12 @ @ private [ dialog ] final case class DialogState ( 
 lastMessageDate = date 
 ) 
 } else this 
 - case MessagesRead ( date ) ⇒ 
 + case MessagesRead ( date , readerUserId ) if readerUserId = = userId ⇒ 
 val newUnreadMessages = unreadMessages . dropWhile ( um ⇒ um . date . isBefore ( date ) | | um . date = = date ) 
 this . copy ( counter = newUnreadMessages . size , unreadMessages = newUnreadMessages ) 
 - case _ ⇒ this 
 + case MessagesRead ( date , readerUserId ) if readerUserId ! = userId & & date . isAfter ( lastReadDate ) ⇒ 
 + this . copy ( lastReadDate = date ) 
 + case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) 
 } 
 } 
 
 @ @ - 135 , 6 + 136 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 
 override protected def getInitialState : DialogState = 
 DialogState ( 
 + userId = userId , 
 lastMessageDate = Instant . ofEpochMilli ( 0 ) , 
 lastReceiveDate = Instant . ofEpochMilli ( 0 ) , 
 lastReadDate = Instant . ofEpochMilli ( 0 ) , 
 @ @ - 164 , 7 + 166 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) 
 case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( rr ) 
 - case uc : UpdateCounters ⇒ updateCountersChanged ( ) 
 } 
 
 / / when receiving this messages , dialog is required to take an action 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / SeqUpdateMatchers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / SeqUpdateMatchers . scala 
 index dc297cb . . 8884cf9 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / SeqUpdateMatchers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / SeqUpdateMatchers . scala 
 @ @ - 59 , 6 + 59 , 20 @ @ trait SeqUpdateMatchers extends Matchers with ScalaFutures with AnyRefLogSource 
 } 
 ) 
 
 + def expectUpdatesUnordered ( updates : UpdateClass * ) ( check : PartialFunction [ Seq [ Update ] , Any ] ) ( implicit client : ClientData ) : Int = 
 + expectUpdatesUnordered ( seq = 0 , updates : _ * ) ( check ) 
 + 
 + def expectUpdatesUnordered ( seq : Int , updates : UpdateClass * ) ( check : PartialFunction [ Seq [ Update ] , Any ] ) ( implicit client : ClientData ) : Int = 
 + expectUpdatesAbstract ( seq , updates ) ( check ) ( 
 + { ( dbUpdatesHeaders , updatesHeaders ) ⇒ updatesHeaders . toSet subsetOf dbUpdatesHeaders . toSet } , 
 + { ( dbUpdatesNames , updatesNames ) ⇒ 
 + s " " " Error : did not get expected updates . 
 + | expected updates : $ updatesNames 
 + | actual updates : $ dbUpdatesNames 
 + " " " . stripMargin 
 + } 
 + ) 
 + 
 def expectUpdatesOnly ( updates : UpdateClass * ) ( check : PartialFunction [ Seq [ Update ] , Any ] ) ( implicit client : ClientData ) : Int = 
 expectUpdatesOnly ( seq = 0 , updates : _ * ) ( check ) 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 index 8c11fa8 . . 1a57e1d 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 @ @ - 102 , 7 + 102 , 7 @ @ class MessagingServiceSpec 
 { 
 implicit val clientData = clientData2 
 
 - expectUpdates ( classOf [ UpdateChatGroupsChanged ] , classOf [ UpdateMessage ] , classOf [ UpdateCountersChanged ] ) { 
 + expectUpdatesUnordered ( classOf [ UpdateChatGroupsChanged ] , classOf [ UpdateMessage ] , classOf [ UpdateCountersChanged ] ) { 
 case Seq ( upd : UpdateMessage ) ⇒ 
 upd . peer shouldEqual ApiPeer ( ApiPeerType . Private , user1 . id ) 
 upd . randomId shouldEqual randomId

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 6ec13a8 . . ae2fd6a 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 21 , 6 + 21 , 7 @ @ message DialogCommands { 
 MessageRead message _ read = 5 ; 
 Show show = 6 ; 
 Hide hide = 7 ; 
 + Delete delete = 8 ; 
 } 
 } 
 
 @ @ - 85 , 4 + 86 , 10 @ @ message DialogCommands { 
 required Peer dest = 1 ; 
 } 
 
 + message Delete { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + 
 + required Peer dest = 1 ; 
 + } 
 + 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 0a7864f . . 41607a4 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 package im . actor . server . dialog 
 
 - import akka . actor . { ActorRef , Status } 
 + import akka . actor . { PoisonPill , ActorRef , Status } 
 import akka . pattern . pipe 
 import im . actor . api . rpc . PeersImplicits 
 import im . actor . api . rpc . messaging . _ 
 @ @ - 179 , 6 + 179 , 22 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } 
 } 
 
 + protected def delete ( state : DialogState ) : Unit = { 
 + val update = UpdateChatDelete ( peer . asStruct ) 
 + 
 + val future = 
 + for { 
 + _ ← db . run ( 
 + HistoryMessageRepo . deleteAll ( userId , peer ) 
 + andThen DialogRepo . delete ( userId , peer ) 
 + ) 
 + _ ← userExt . notifyDialogsChanged ( userId ) 
 + seqstate ← seqUpdExt . deliverSingleUpdate ( userId , update ) 
 + } yield seqstate 
 + 
 + future pipeTo sender ( ) onSuccess { case _ ⇒ self ! PoisonPill } 
 + } 
 + 
 private def mustMakeReceive ( state : DialogState , mr : MessageReceived ) : Boolean = 
 ( mr . date > state . lastReceiveDate ) & & / / receive date is later than last receive date 
 ( mr . date < = mr . now ) & & / / and receive date is not in future 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 461366f . . 8deb88d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 23 , 6 + 23 , 7 @ @ import slick . dbio . DBIO 
 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 + import scala . reflect . ClassTag 
 
 sealed trait DialogGroup { 
 def key : String 
 @ @ - 60 , 7 + 61 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 
 private val log = Logging ( system , getClass ) 
 
 - private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ Future [ A ] = Future . failed [ A ] ( DialogErrors . MessageToSelf ) ) ( f : ⇒ Future [ A ] ) : Future [ A ] = 
 peer match { 
 case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ 
 log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) 
 @ @ - 124 , 6 + 125 , 11 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 } 
 
 + def delete ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 + withValidPeer ( peer , userId ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withDelete ( Delete ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 + 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 case Seq ( ) ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 78a18df . . b922722 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 13 , 7 + 13 , 7 @ @ import im . actor . server . cqrs . ProcessorState 
 import im . actor . server . db . DbExtension 
 import im . actor . server . model . { Dialog ⇒ DialogModel , Peer } 
 import im . actor . server . persist . DialogRepo 
 - import im . actor . server . sequence . SeqStateDate 
 + import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 import im . actor . util . cache . CacheHelpers . _ 
 @ @ - 105 , 6 + 105 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 
 protected val dialogExt = DialogExtension ( system ) 
 protected val deliveryExt = dialogExt . getDeliveryExtension ( extensions ) 
 + protected val seqUpdExt = SeqUpdatesExtension ( context . system ) 
 
 protected val selfPeer : Peer = Peer . privat ( userId ) 
 
 @ @ - 134 , 6 + 135 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) 
 case Show ( _ ) ⇒ show ( state ) 
 case Hide ( _ ) ⇒ hide ( state ) 
 + case Delete ( _ ) ⇒ delete ( state ) 
 } 
 
 / * * 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index 358c65b . . b759493 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 59 , 17 + 59 , 11 @ @ trait HistoryHandlers { 
 } 
 
 override def jhandleDeleteChat ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { 
 - val action = requireAuth ( clientData ) . map { implicit client ⇒ 
 - val update = UpdateChatDelete ( peer . asPeer ) 
 - 
 + authorized ( clientData ) { implicit client ⇒ 
 for { 
 - _ ← persist . HistoryMessageRepo . deleteAll ( client . userId , peer . asModel ) 
 - _ ← persist . DialogRepo . delete ( client . userId , peer . asModel ) 
 - seqstate ← DBIO . from ( userExt . broadcastClientUpdate ( update , None , isFat = false ) ) 
 - } yield Ok ( ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) ) 
 + SeqState ( seq , state ) ← dialogExt . delete ( client . userId , peer . asModel ) 
 + } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) 
 } 
 - 
 - db . run ( toDBIOAction ( action ) ) 
 } 
 
 override def jhandleLoadDialogs ( endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = {
