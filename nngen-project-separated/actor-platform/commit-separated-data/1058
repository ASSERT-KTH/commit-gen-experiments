BLEU SCORE: 0.10234459018728541

TEST MSG: feat ( server ) : integration with new actor push server
GENERATED MSG: perf ( server : push ) : async google push via HTTP

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / resources / reference . conf b / actor - server / actor - core / src / main / resources / reference . conf < nl > index 81d251d . . 3c6a67f 100644 < nl > - - - a / actor - server / actor - core / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - core / src / main / resources / reference . conf < nl > @ @ - 15 , 6 + 15 , 13 @ @ modules { < nl > } < nl > < nl > services { < nl > + actor { < nl > + push { < nl > + max - queue : 10000 < nl > + token : " " < nl > + } < nl > + } < nl > + < nl > apple { < nl > push { < nl > certs : [ ] < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala b / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala < nl > index 811caf8 . . bdc07d0 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala < nl > @ @ - 2 , 94 + 2 , 52 @ @ package im . actor . server . push . actor < nl > < nl > import akka . actor . _ < nl > import akka . event . Logging < nl > - import com . rabbitmq . client . { Consumer , TopologyRecoveryException , Channel , Connection } < nl > - import com . rabbitmq . client . impl . DefaultExceptionHandler < nl > - import com . spingo . op _ rabbit . _ < nl > + import akka . http . scaladsl . Http < nl > + import akka . http . scaladsl . model . _ < nl > + import akka . parboiled2 . ParserInput < nl > + import akka . stream . { ActorMaterializer , OverflowStrategy } < nl > + import akka . stream . scaladsl . { Sink , Source } < nl > import im . actor . server . model . push . ActorPushCredentials < nl > + import io . circe . { Json , JsonObject } < nl > import io . circe . generic . auto . _ < nl > import io . circe . syntax . _ < nl > < nl > - import scala . util . { Failure , Success , Try } < nl > + import scala . util . { Failure , Success } < nl > < nl > - final case class ActorPushMessage ( data : Map [ String , String ] ) < nl > + final case class ActorPushMessage ( data : JsonObject ) < nl > < nl > - final class ActorPush ( system : ActorSystem ) extends Extension { < nl > - private val log = Logging ( system , getClass ) < nl > - < nl > - val rabbitControl = < nl > - Try ( ConnectionParams . fromConfig ( system . settings . config . getConfig ( " services . rabbitmq " ) ) ) match { < nl > - case Success ( config ) ⇒ < nl > - system . actorOf ( Props ( new RabbitControl ( config . copy ( exceptionHandler = new ExceptionHandler ( system ) ) ) ) , " rabbit - control " ) < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to parse rabbitmq configuration " ) < nl > - system . deadLetters < nl > - } < nl > - < nl > - def deliver ( seq : Int , creds : ActorPushCredentials ) : Unit = < nl > - rabbitControl ! Message . topic ( < nl > - ActorPushMessage ( data = Map ( < nl > - " seq " → seq . toString < nl > - ) ) . asJson . toString ( ) , < nl > - routingKey = creds . topic < nl > - ) < nl > - } < nl > + private final case class ActorPushDelivery ( creds : ActorPushCredentials , message : ActorPushMessage ) < nl > < nl > - private final class ExceptionHandler ( system : ActorSystem ) extends DefaultExceptionHandler { < nl > + final class ActorPush ( _ system : ActorSystem ) extends Extension { < nl > + private implicit val system = _ system < nl > private val log = Logging ( system , getClass ) < nl > - < nl > - override def handleUnexpectedConnectionDriverException ( conn : Connection , exception : Throwable ) : Unit = { < nl > - log . error ( exception , " Unexpected connection driver " ) < nl > - super . handleUnexpectedConnectionDriverException ( conn , exception ) < nl > - } < nl > - < nl > - override def handleConsumerException ( channel : Channel , exception : Throwable , consumer : Consumer , consumerTag : String , methodName : String ) : Unit = { < nl > - log . error ( exception , " Consumer exception , consumer : { } , consumerTag : { } , methodName : { } " , consumer , consumerTag , methodName ) < nl > - super . handleConsumerException ( channel , exception , consumer , consumerTag , methodName ) < nl > - } < nl > - < nl > - override def handleBlockedListenerException ( connection : Connection , exception : Throwable ) : Unit = { < nl > - log . error ( exception , " Blocked listener " ) < nl > - super . handleBlockedListenerException ( connection , exception ) < nl > - } < nl > - < nl > - override def handleChannelRecoveryException ( ch : Channel , exception : Throwable ) : Unit = { < nl > - log . error ( exception , " Channel recovery error " ) < nl > - super . handleChannelRecoveryException ( ch , exception ) < nl > - } < nl > - < nl > - override def handleFlowListenerException ( channel : Channel , exception : Throwable ) : Unit = { < nl > - log . error ( exception , " Flow listener error " ) < nl > - super . handleFlowListenerException ( channel , exception ) < nl > - } < nl > - < nl > - override def handleChannelKiller ( channel : Channel , exception : Throwable , what : String ) : Unit = { < nl > - log . error ( exception , " Channel killer , what : { } " , what ) < nl > - super . handleChannelKiller ( channel , exception , what ) < nl > - } < nl > - < nl > - override def handleReturnListenerException ( channel : Channel , exception : Throwable ) : Unit = { < nl > - log . error ( exception , " Return listener error " ) < nl > - super . handleReturnListenerException ( channel , exception ) < nl > - } < nl > - < nl > - override def handleConnectionKiller ( connection : Connection , exception : Throwable , what : String ) : Unit = { < nl > - log . error ( exception , " Connection killer , what : { } " , what ) < nl > - super . handleConnectionKiller ( connection , exception , what ) < nl > - } < nl > - < nl > - override def handleTopologyRecoveryException ( conn : Connection , ch : Channel , exception : TopologyRecoveryException ) : Unit = { < nl > - log . error ( exception , " Topology recovery error , channel : { } " , ch ) < nl > - super . handleTopologyRecoveryException ( conn , ch , exception ) < nl > - } < nl > - < nl > - override def handleConfirmListenerException ( channel : Channel , exception : Throwable ) : Unit = { < nl > - log . error ( exception , " Confirm listener error " ) < nl > - super . handleConfirmListenerException ( channel , exception ) < nl > - } < nl > - < nl > - override def handleConnectionRecoveryException ( conn : Connection , exception : Throwable ) : Unit = { < nl > - log . error ( exception , " Connection recovery error " ) < nl > - super . handleConnectionRecoveryException ( conn , exception ) < nl > + private val maxQueue = system . settings . config . getInt ( " services . actor . push . max - queue " ) < nl > + private val token = system . settings . config . getString ( " services . actor . push . token " ) < nl > + private implicit val mat = ActorMaterializer ( ) < nl > + < nl > + private val sourceRef = < nl > + Source < nl > + . actorRef ( maxQueue , OverflowStrategy . dropHead ) < nl > + . via ( Http ( system ) . superPool [ ActorPushDelivery ] ( ) ) < nl > + . to ( Sink foreach { < nl > + case ( Success ( _ ) , _ ) ⇒ < nl > + case ( Failure ( e ) , d ) ⇒ log . error ( e , " Failed to deliver , endpoint : { } " , d . creds . endpoint ) < nl > + } ) < nl > + . run ( ) < nl > + < nl > + private val pushHeaders = List ( headers . Authorization ( headers . OAuth2BearerToken ( token ) ) ) < nl > + < nl > + def deliver ( seq : Int , creds : ActorPushCredentials ) : Unit = { < nl > + val m = ActorPushMessage ( JsonObject . singleton ( " seq " , Json . int ( seq ) ) ) < nl > + val uri = Uri . parseAbsolute ( ParserInput ( creds . endpoint ) ) < nl > + < nl > + sourceRef ! < nl > + HttpRequest ( < nl > + method = HttpMethods . POST , < nl > + uri = uri , < nl > + headers = pushHeaders , < nl > + entity = HttpEntity ( ContentTypes . ` application / json ` , m . asJson . toString ) < nl > + ) → ActorPushDelivery ( creds , m ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > index 779675b . . 824d134 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > @ @ - 137 , 6 + 137 , 7 @ @ private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , Goog < nl > import GooglePushDelivery . _ < nl > < nl > private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] < nl > + private val uri = Uri ( " / gcm / send " ) < nl > < nl > def receive = { < nl > case d : Delivery if buf . size = = MaxQueue ⇒ < nl > @ @ - 167 , 7 + 168 , 7 @ @ private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , Goog < nl > private def mkJob ( d : Delivery ) : ( HttpRequest , Delivery ) = { < nl > HttpRequest ( < nl > method = HttpMethods . POST , < nl > - uri = Uri ( " / gcm / send " ) , < nl > + uri = uri , < nl > headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . key } " , Map . empty [ String , String ] ) ) ) , < nl > entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . toString ( ) ) < nl > ) → d < nl > diff - - git a / actor - server / actor - models / src / main / protobuf / model / push . proto b / actor - server / actor - models / src / main / protobuf / model / push . proto < nl > index 6b9657b . . 357fe9c 100644 < nl > - - - a / actor - server / actor - models / src / main / protobuf / model / push . proto < nl > + + + b / actor - server / actor - models / src / main / protobuf / model / push . proto < nl > @ @ - 24 , 5 + 24 , 5 @ @ message ActorPushCredentials { < nl > option ( scalapb . message ) . extends = " im . actor . server . model . push . PushCredentials " ; < nl > < nl > int64 auth _ id = 1 ; < nl > - string topic = 2 ; < nl > + string endpoint = 2 ; < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 15541de . . 68e05ec 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 104 , 7 + 104 , 6 @ @ object Dependencies { < nl > < nl > val tyrex = " tyrex " % " tyrex " % " 1 . 0 . 1 " < nl > < nl > - val opRabbit = " com . spingo " % % " op - rabbit - core " % " 1 . 2 . 1 " < nl > val pushy = " com . relayrides " % " pushy " % " 0 . 4 . 3 " < nl > < nl > val logbackClassic = " ch . qos . logback " % " logback - classic " % " 1 . 1 . 2 " < nl > @ @ - 168 , 7 + 167 , 6 @ @ object Dependencies { < nl > akkaClusterSharding , < nl > akkaDdata , < nl > caffeine , < nl > - opRabbit , < nl > pushy , < nl > jodaTime , < nl > postgresJdbc ,
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > index d7d65c1 . . 06345e9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > @ @ - 1 , 10 + 1 , 27 @ @ < nl > package im . actor . server . sequence < nl > < nl > - import scala . util . Try < nl > + import akka . actor . _ < nl > + import akka . event . Logging < nl > + import akka . http . ConnectionPoolSettings < nl > + import akka . http . scaladsl . Http < nl > + import akka . http . scaladsl . model . _ < nl > + import akka . stream . Materializer < nl > + import akka . stream . actor . ActorPublisher < nl > + import akka . stream . scaladsl . Source < nl > + import akka . util . ByteString < nl > + import cats . data . Xor < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . persist . push . GooglePushCredentialsRepo < nl > + import io . circe . generic . auto . _ < nl > < nl > import com . github . kxbmap . configs . _ < nl > - import com . google . android . gcm . server . Sender < nl > import com . typesafe . config . Config < nl > + import io . circe . jawn . _ < nl > + import io . circe . syntax . _ < nl > + < nl > + import scala . annotation . tailrec < nl > + import scala . concurrent . Future < nl > + import scala . util . { Failure , Success , Try } < nl > < nl > case class GooglePushKey ( projectId : Long , key : String ) < nl > < nl > @ @ - 27 , 14 + 44 , 124 @ @ object GooglePushManagerConfig { < nl > } yield GooglePushManagerConfig ( keys ) < nl > } < nl > < nl > - final class GooglePushManager ( config : GooglePushManagerConfig ) { < nl > - private val senders : Map [ Long , Sender ] = < nl > + final case class GooglePushMessage ( < nl > + collapseKey : Option [ String ] , < nl > + data : Option [ Map [ String , String ] ] < nl > + ) < nl > + < nl > + final class GooglePushManager ( config : GooglePushManagerConfig ) ( implicit system : ActorSystem , mat : Materializer ) { < nl > + < nl > + import system . dispatcher < nl > + < nl > + private val log = Logging ( system , getClass ) < nl > + private val db = DbExtension ( system ) . db < nl > + < nl > + private val deliveryPublisher = system . actorOf ( GooglePushDelivery . props , " google - push - delivery " ) < nl > + < nl > + / / TODO : flatten < nl > + Source . fromPublisher ( ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] ( deliveryPublisher ) ) < nl > + . via ( GooglePushDelivery . flow ) < nl > + . runForeach { < nl > + case ( Success ( resp ) , delivery ) ⇒ < nl > + if ( resp . status = = StatusCodes . OK ) { < nl > + resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) foreach { bs ⇒ < nl > + parse ( new String ( bs . toArray , " UTF - 8 " ) ) match { < nl > + case Xor . Right ( json ) ⇒ < nl > + json . asObject match { < nl > + case Some ( obj ) ⇒ < nl > + obj ( " error " ) flatMap ( _ . asString ) foreach { < nl > + case " InvalidRegistration " ⇒ < nl > + log . warning ( " Invalid registration , deleting " ) < nl > + remove ( delivery . regId ) < nl > + case " NotRegistered " ⇒ < nl > + log . warning ( " Token is not registered , deleting " ) < nl > + remove ( delivery . regId ) < nl > + case other ⇒ < nl > + log . warning ( " Error in GCM response : { } " , other ) < nl > + } < nl > + case None ⇒ < nl > + log . error ( " Expected JSON Object but got : { } " , json ) < nl > + } < nl > + case Xor . Left ( failure ) ⇒ log . error ( failure . underlying , " Failed to parse response " ) < nl > + } < nl > + } < nl > + } else log . error ( " Status code was not OK : { } " , resp . status ) < nl > + case ( Failure ( e ) , delivery ) ⇒ < nl > + log . error ( e , " Failed to deliver message : { } " , delivery . m ) < nl > + } < nl > + < nl > + private def remove ( regId : String ) : Future [ Int ] = db . run ( GooglePushCredentialsRepo . deleteByToken ( regId ) ) < nl > + < nl > + private val keys : Map [ Long , String ] = < nl > ( config . keys map { < nl > - case GooglePushKey ( projectId , key ) ⇒ < nl > - val sender = new Sender ( key ) < nl > - ( projectId → sender ) < nl > + case GooglePushKey ( projectId , key ) ⇒ projectId → key < nl > } ) . toMap < nl > < nl > - def getInstance ( key : Long ) : Option [ Sender ] = < nl > - senders . get ( key ) < nl > + def send ( projectId : Long , regId : String , message : GooglePushMessage ) : Unit = < nl > + keys get projectId match { < nl > + case Some ( key ) ⇒ < nl > + deliveryPublisher ! GooglePushDelivery . Delivery ( message , key , regId ) < nl > + case None ⇒ < nl > + log . warning ( " Key not found for projectId : { } " , projectId ) < nl > + } < nl > + } < nl > + < nl > + private object GooglePushDelivery { < nl > + < nl > + object Tick < nl > + < nl > + final case class Delivery ( m : GooglePushMessage , key : String , regId : String ) < nl > + < nl > + private val MaxQueue = 100000 < nl > + private val MaxConnections = 4 < nl > + < nl > + def props = Props ( classOf [ GooglePushDelivery ] ) < nl > + < nl > + def flow ( implicit system : ActorSystem , mat : Materializer ) = < nl > + Http ( system ) < nl > + . cachedHostConnectionPoolTls [ GooglePushDelivery . Delivery ] ( < nl > + " gcm - http . googleapis . com " , < nl > + settings = ConnectionPoolSettings ( system ) . copy ( maxConnections = MaxConnections ) < nl > + ) < nl > + } < nl > + < nl > + private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] with ActorLogging { < nl > + < nl > + import GooglePushDelivery . _ < nl > + < nl > + private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] < nl > + < nl > + def receive = { < nl > + case d : Delivery if buf . size = = MaxQueue ⇒ < nl > + log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery " , MaxQueue ) < nl > + case d : Delivery ⇒ < nl > + if ( buf . isEmpty & & totalDemand > 0 ) < nl > + onNext ( mkJob ( d ) ) < nl > + else { < nl > + this . buf : + = mkJob ( d ) < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + < nl > + @ tailrec def deliverBuf ( ) : Unit = < nl > + if ( totalDemand > 0 ) { < nl > + if ( totalDemand < = Int . MaxValue ) { < nl > + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) < nl > + buf = keep < nl > + use foreach onNext < nl > + } else { < nl > + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) < nl > + buf = keep < nl > + use foreach onNext < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + < nl > + private def mkJob ( d : Delivery ) : ( HttpRequest , Delivery ) = < nl > + HttpRequest ( < nl > + method = HttpMethods . POST , < nl > + uri = Uri ( " / gcm / send " ) , < nl > + headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . regId } " , Map . empty [ String , String ] ) ) ) , < nl > + entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . toString ( ) ) < nl > + ) → d < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > index 1985d73 . . 8376311 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > @ @ - 1 , 29 + 1 , 16 @ @ < nl > package im . actor . server . sequence < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . event . Logging < nl > - import com . google . android . gcm . server . { Sender , Message } < nl > import im . actor . server . model . push . GooglePushCredentials < nl > < nl > - import scala . concurrent . { ExecutionContext , Future , blocking } < nl > - < nl > private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : GooglePushManager , system : ActorSystem ) extends PushProvider { < nl > - import system . dispatcher < nl > - < nl > - private val Retries = 3 < nl > - < nl > - private val log = Logging ( system , getClass ) < nl > - < nl > def deliverInvisible ( seq : Int , creds : GooglePushCredentials ) : Unit = { < nl > - withMgr ( creds . projectId ) { implicit mgr ⇒ < nl > - val message = < nl > - new Message . Builder ( ) < nl > - . collapseKey ( s " seq - invisible - $ { userId . toString } " ) < nl > - . addData ( " seq " , seq . toString ) < nl > - . build ( ) < nl > + val message = GooglePushMessage ( < nl > + collapseKey = Some ( s " seq - invisible - $ { userId . toString } " ) , < nl > + data = Some ( Map ( " seq " → seq . toString ) ) < nl > + ) < nl > < nl > - send ( message , creds . regId , Retries ) < nl > - } < nl > + googlePushManager . send ( creds . projectId , creds . regId , message ) < nl > } < nl > < nl > def deliverVisible ( < nl > @ @ - 34 , 33 + 21 , 17 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : < nl > isSoundEnabled : Boolean , < nl > isVibrationEnabled : Boolean < nl > ) : Unit = { < nl > - withMgr ( creds . projectId ) { implicit mgr ⇒ < nl > - val builder = new Message . Builder ( ) < nl > - . collapseKey ( s " seq - visible - $ { userId . toString } " ) < nl > - . addData ( " seq " , seq . toString ) < nl > - < nl > - val message = < nl > + val message = GooglePushMessage ( < nl > + collapseKey = Some ( s " seq - visible - $ { userId . toString } " ) , < nl > + data = Some ( Map ( " seq " → seq . toString ) + + ( < nl > data . text match { < nl > case text if text . nonEmpty & & isTextEnabled ⇒ < nl > - builder < nl > - . addData ( " message " , text ) < nl > - . build ( ) < nl > - case _ ⇒ builder . build ( ) < nl > + Map ( " message " → text ) < nl > + case _ ⇒ Map . empty < nl > } < nl > + ) ) < nl > + ) < nl > < nl > - send ( message , creds . regId , Retries ) < nl > - } < nl > - } < nl > - < nl > - private def withMgr [ A ] ( projectId : Long ) ( f : Sender ⇒ A ) = < nl > - googlePushManager . getInstance ( projectId ) match { < nl > - case Some ( mgr ) ⇒ f ( mgr ) < nl > - case None ⇒ log . warning ( " No google push configured for project - id : { } " , projectId ) < nl > - } < nl > - < nl > - private def send ( message : Message , regId : String , retries : Int ) ( implicit mgr : Sender , ec : ExecutionContext ) : Unit = Future { < nl > - blocking { < nl > - mgr . send ( message , regId , Retries ) < nl > - } < nl > + googlePushManager . send ( creds . projectId , creds . regId , message ) < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > index c2ce0b7 . . 5a7b0cb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import akka . actor . _ < nl > import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } < nl > import akka . event . Logging < nl > import akka . pattern . ask < nl > + import akka . stream . ActorMaterializer < nl > import akka . util . Timeout < nl > import com . google . protobuf . ByteString < nl > import im . actor . api . rpc . Update < nl > @ @ - 239 , 6 + 240 , 8 @ @ object SeqUpdatesExtension extends ExtensionId [ SeqUpdatesExtension ] with Extensi < nl > override def lookup = SeqUpdatesExtension < nl > < nl > override def createExtension ( system : ExtendedActorSystem ) = { < nl > + implicit val _ system = system < nl > + implicit val mat = ActorMaterializer ( ) < nl > val log = Logging ( system , getClass ) < nl > < nl > try { < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > index 08827c4 . . c37af44 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > @ @ - 9 , 13 + 9 , 11 @ @ import akka . http . scaladsl . model . StatusCodes . OK < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . _ < nl > import akka . stream . ActorMaterializer < nl > - import akka . stream . scaladsl . Source < nl > - import akka . util . ByteString < nl > import im . actor . server . api . http . HttpHandler < nl > import im . actor . server . file . local . { FileStorageOperations , LocalFileStorageConfig , RequestSigning } < nl > import im . actor . util . log . AnyRefLogSource < nl > < nl > - import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . concurrent . ExecutionContext < nl > import scala . util . { Failure , Success } < nl > < nl > private [ local ] final class FilesHttpHandler ( storageConfig : LocalFileStorageConfig ) ( implicit val system : ActorSystem ) < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index a259645 . . 5e32937 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 104 , 7 + 104 , 6 @ @ object Dependencies { < nl > < nl > val tyrex = " tyrex " % " tyrex " % " 1 . 0 . 1 " < nl > < nl > - val gcmServer = " com . google . android . gcm " % " gcm - server " % " 1 . 0 . 2 " < nl > val pushy = " com . relayrides " % " pushy " % " 0 . 4 . 3 " < nl > < nl > val logbackClassic = " ch . qos . logback " % " logback - classic " % " 1 . 1 . 2 " < nl > @ @ - 167 , 7 + 166 , 6 @ @ object Dependencies { < nl > akkaClusterSharding , < nl > akkaDdata , < nl > caffeine , < nl > - gcmServer , < nl > pushy , < nl > jodaTime , < nl > postgresJdbc ,

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / resources / reference . conf b / actor - server / actor - core / src / main / resources / reference . conf 
 index 81d251d . . 3c6a67f 100644 
 - - - a / actor - server / actor - core / src / main / resources / reference . conf 
 + + + b / actor - server / actor - core / src / main / resources / reference . conf 
 @ @ - 15 , 6 + 15 , 13 @ @ modules { 
 } 
 
 services { 
 + actor { 
 + push { 
 + max - queue : 10000 
 + token : " " 
 + } 
 + } 
 + 
 apple { 
 push { 
 certs : [ ] 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala b / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala 
 index 811caf8 . . bdc07d0 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala 
 @ @ - 2 , 94 + 2 , 52 @ @ package im . actor . server . push . actor 
 
 import akka . actor . _ 
 import akka . event . Logging 
 - import com . rabbitmq . client . { Consumer , TopologyRecoveryException , Channel , Connection } 
 - import com . rabbitmq . client . impl . DefaultExceptionHandler 
 - import com . spingo . op _ rabbit . _ 
 + import akka . http . scaladsl . Http 
 + import akka . http . scaladsl . model . _ 
 + import akka . parboiled2 . ParserInput 
 + import akka . stream . { ActorMaterializer , OverflowStrategy } 
 + import akka . stream . scaladsl . { Sink , Source } 
 import im . actor . server . model . push . ActorPushCredentials 
 + import io . circe . { Json , JsonObject } 
 import io . circe . generic . auto . _ 
 import io . circe . syntax . _ 
 
 - import scala . util . { Failure , Success , Try } 
 + import scala . util . { Failure , Success } 
 
 - final case class ActorPushMessage ( data : Map [ String , String ] ) 
 + final case class ActorPushMessage ( data : JsonObject ) 
 
 - final class ActorPush ( system : ActorSystem ) extends Extension { 
 - private val log = Logging ( system , getClass ) 
 - 
 - val rabbitControl = 
 - Try ( ConnectionParams . fromConfig ( system . settings . config . getConfig ( " services . rabbitmq " ) ) ) match { 
 - case Success ( config ) ⇒ 
 - system . actorOf ( Props ( new RabbitControl ( config . copy ( exceptionHandler = new ExceptionHandler ( system ) ) ) ) , " rabbit - control " ) 
 - case Failure ( e ) ⇒ 
 - log . error ( e , " Failed to parse rabbitmq configuration " ) 
 - system . deadLetters 
 - } 
 - 
 - def deliver ( seq : Int , creds : ActorPushCredentials ) : Unit = 
 - rabbitControl ! Message . topic ( 
 - ActorPushMessage ( data = Map ( 
 - " seq " → seq . toString 
 - ) ) . asJson . toString ( ) , 
 - routingKey = creds . topic 
 - ) 
 - } 
 + private final case class ActorPushDelivery ( creds : ActorPushCredentials , message : ActorPushMessage ) 
 
 - private final class ExceptionHandler ( system : ActorSystem ) extends DefaultExceptionHandler { 
 + final class ActorPush ( _ system : ActorSystem ) extends Extension { 
 + private implicit val system = _ system 
 private val log = Logging ( system , getClass ) 
 - 
 - override def handleUnexpectedConnectionDriverException ( conn : Connection , exception : Throwable ) : Unit = { 
 - log . error ( exception , " Unexpected connection driver " ) 
 - super . handleUnexpectedConnectionDriverException ( conn , exception ) 
 - } 
 - 
 - override def handleConsumerException ( channel : Channel , exception : Throwable , consumer : Consumer , consumerTag : String , methodName : String ) : Unit = { 
 - log . error ( exception , " Consumer exception , consumer : { } , consumerTag : { } , methodName : { } " , consumer , consumerTag , methodName ) 
 - super . handleConsumerException ( channel , exception , consumer , consumerTag , methodName ) 
 - } 
 - 
 - override def handleBlockedListenerException ( connection : Connection , exception : Throwable ) : Unit = { 
 - log . error ( exception , " Blocked listener " ) 
 - super . handleBlockedListenerException ( connection , exception ) 
 - } 
 - 
 - override def handleChannelRecoveryException ( ch : Channel , exception : Throwable ) : Unit = { 
 - log . error ( exception , " Channel recovery error " ) 
 - super . handleChannelRecoveryException ( ch , exception ) 
 - } 
 - 
 - override def handleFlowListenerException ( channel : Channel , exception : Throwable ) : Unit = { 
 - log . error ( exception , " Flow listener error " ) 
 - super . handleFlowListenerException ( channel , exception ) 
 - } 
 - 
 - override def handleChannelKiller ( channel : Channel , exception : Throwable , what : String ) : Unit = { 
 - log . error ( exception , " Channel killer , what : { } " , what ) 
 - super . handleChannelKiller ( channel , exception , what ) 
 - } 
 - 
 - override def handleReturnListenerException ( channel : Channel , exception : Throwable ) : Unit = { 
 - log . error ( exception , " Return listener error " ) 
 - super . handleReturnListenerException ( channel , exception ) 
 - } 
 - 
 - override def handleConnectionKiller ( connection : Connection , exception : Throwable , what : String ) : Unit = { 
 - log . error ( exception , " Connection killer , what : { } " , what ) 
 - super . handleConnectionKiller ( connection , exception , what ) 
 - } 
 - 
 - override def handleTopologyRecoveryException ( conn : Connection , ch : Channel , exception : TopologyRecoveryException ) : Unit = { 
 - log . error ( exception , " Topology recovery error , channel : { } " , ch ) 
 - super . handleTopologyRecoveryException ( conn , ch , exception ) 
 - } 
 - 
 - override def handleConfirmListenerException ( channel : Channel , exception : Throwable ) : Unit = { 
 - log . error ( exception , " Confirm listener error " ) 
 - super . handleConfirmListenerException ( channel , exception ) 
 - } 
 - 
 - override def handleConnectionRecoveryException ( conn : Connection , exception : Throwable ) : Unit = { 
 - log . error ( exception , " Connection recovery error " ) 
 - super . handleConnectionRecoveryException ( conn , exception ) 
 + private val maxQueue = system . settings . config . getInt ( " services . actor . push . max - queue " ) 
 + private val token = system . settings . config . getString ( " services . actor . push . token " ) 
 + private implicit val mat = ActorMaterializer ( ) 
 + 
 + private val sourceRef = 
 + Source 
 + . actorRef ( maxQueue , OverflowStrategy . dropHead ) 
 + . via ( Http ( system ) . superPool [ ActorPushDelivery ] ( ) ) 
 + . to ( Sink foreach { 
 + case ( Success ( _ ) , _ ) ⇒ 
 + case ( Failure ( e ) , d ) ⇒ log . error ( e , " Failed to deliver , endpoint : { } " , d . creds . endpoint ) 
 + } ) 
 + . run ( ) 
 + 
 + private val pushHeaders = List ( headers . Authorization ( headers . OAuth2BearerToken ( token ) ) ) 
 + 
 + def deliver ( seq : Int , creds : ActorPushCredentials ) : Unit = { 
 + val m = ActorPushMessage ( JsonObject . singleton ( " seq " , Json . int ( seq ) ) ) 
 + val uri = Uri . parseAbsolute ( ParserInput ( creds . endpoint ) ) 
 + 
 + sourceRef ! 
 + HttpRequest ( 
 + method = HttpMethods . POST , 
 + uri = uri , 
 + headers = pushHeaders , 
 + entity = HttpEntity ( ContentTypes . ` application / json ` , m . asJson . toString ) 
 + ) → ActorPushDelivery ( creds , m ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 index 779675b . . 824d134 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 @ @ - 137 , 6 + 137 , 7 @ @ private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , Goog 
 import GooglePushDelivery . _ 
 
 private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] 
 + private val uri = Uri ( " / gcm / send " ) 
 
 def receive = { 
 case d : Delivery if buf . size = = MaxQueue ⇒ 
 @ @ - 167 , 7 + 168 , 7 @ @ private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , Goog 
 private def mkJob ( d : Delivery ) : ( HttpRequest , Delivery ) = { 
 HttpRequest ( 
 method = HttpMethods . POST , 
 - uri = Uri ( " / gcm / send " ) , 
 + uri = uri , 
 headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . key } " , Map . empty [ String , String ] ) ) ) , 
 entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . toString ( ) ) 
 ) → d 
 diff - - git a / actor - server / actor - models / src / main / protobuf / model / push . proto b / actor - server / actor - models / src / main / protobuf / model / push . proto 
 index 6b9657b . . 357fe9c 100644 
 - - - a / actor - server / actor - models / src / main / protobuf / model / push . proto 
 + + + b / actor - server / actor - models / src / main / protobuf / model / push . proto 
 @ @ - 24 , 5 + 24 , 5 @ @ message ActorPushCredentials { 
 option ( scalapb . message ) . extends = " im . actor . server . model . push . PushCredentials " ; 
 
 int64 auth _ id = 1 ; 
 - string topic = 2 ; 
 + string endpoint = 2 ; 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 15541de . . 68e05ec 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 104 , 7 + 104 , 6 @ @ object Dependencies { 
 
 val tyrex = " tyrex " % " tyrex " % " 1 . 0 . 1 " 
 
 - val opRabbit = " com . spingo " % % " op - rabbit - core " % " 1 . 2 . 1 " 
 val pushy = " com . relayrides " % " pushy " % " 0 . 4 . 3 " 
 
 val logbackClassic = " ch . qos . logback " % " logback - classic " % " 1 . 1 . 2 " 
 @ @ - 168 , 7 + 167 , 6 @ @ object Dependencies { 
 akkaClusterSharding , 
 akkaDdata , 
 caffeine , 
 - opRabbit , 
 pushy , 
 jodaTime , 
 postgresJdbc ,

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 index d7d65c1 . . 06345e9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 @ @ - 1 , 10 + 1 , 27 @ @ 
 package im . actor . server . sequence 
 
 - import scala . util . Try 
 + import akka . actor . _ 
 + import akka . event . Logging 
 + import akka . http . ConnectionPoolSettings 
 + import akka . http . scaladsl . Http 
 + import akka . http . scaladsl . model . _ 
 + import akka . stream . Materializer 
 + import akka . stream . actor . ActorPublisher 
 + import akka . stream . scaladsl . Source 
 + import akka . util . ByteString 
 + import cats . data . Xor 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . persist . push . GooglePushCredentialsRepo 
 + import io . circe . generic . auto . _ 
 
 import com . github . kxbmap . configs . _ 
 - import com . google . android . gcm . server . Sender 
 import com . typesafe . config . Config 
 + import io . circe . jawn . _ 
 + import io . circe . syntax . _ 
 + 
 + import scala . annotation . tailrec 
 + import scala . concurrent . Future 
 + import scala . util . { Failure , Success , Try } 
 
 case class GooglePushKey ( projectId : Long , key : String ) 
 
 @ @ - 27 , 14 + 44 , 124 @ @ object GooglePushManagerConfig { 
 } yield GooglePushManagerConfig ( keys ) 
 } 
 
 - final class GooglePushManager ( config : GooglePushManagerConfig ) { 
 - private val senders : Map [ Long , Sender ] = 
 + final case class GooglePushMessage ( 
 + collapseKey : Option [ String ] , 
 + data : Option [ Map [ String , String ] ] 
 + ) 
 + 
 + final class GooglePushManager ( config : GooglePushManagerConfig ) ( implicit system : ActorSystem , mat : Materializer ) { 
 + 
 + import system . dispatcher 
 + 
 + private val log = Logging ( system , getClass ) 
 + private val db = DbExtension ( system ) . db 
 + 
 + private val deliveryPublisher = system . actorOf ( GooglePushDelivery . props , " google - push - delivery " ) 
 + 
 + / / TODO : flatten 
 + Source . fromPublisher ( ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] ( deliveryPublisher ) ) 
 + . via ( GooglePushDelivery . flow ) 
 + . runForeach { 
 + case ( Success ( resp ) , delivery ) ⇒ 
 + if ( resp . status = = StatusCodes . OK ) { 
 + resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) foreach { bs ⇒ 
 + parse ( new String ( bs . toArray , " UTF - 8 " ) ) match { 
 + case Xor . Right ( json ) ⇒ 
 + json . asObject match { 
 + case Some ( obj ) ⇒ 
 + obj ( " error " ) flatMap ( _ . asString ) foreach { 
 + case " InvalidRegistration " ⇒ 
 + log . warning ( " Invalid registration , deleting " ) 
 + remove ( delivery . regId ) 
 + case " NotRegistered " ⇒ 
 + log . warning ( " Token is not registered , deleting " ) 
 + remove ( delivery . regId ) 
 + case other ⇒ 
 + log . warning ( " Error in GCM response : { } " , other ) 
 + } 
 + case None ⇒ 
 + log . error ( " Expected JSON Object but got : { } " , json ) 
 + } 
 + case Xor . Left ( failure ) ⇒ log . error ( failure . underlying , " Failed to parse response " ) 
 + } 
 + } 
 + } else log . error ( " Status code was not OK : { } " , resp . status ) 
 + case ( Failure ( e ) , delivery ) ⇒ 
 + log . error ( e , " Failed to deliver message : { } " , delivery . m ) 
 + } 
 + 
 + private def remove ( regId : String ) : Future [ Int ] = db . run ( GooglePushCredentialsRepo . deleteByToken ( regId ) ) 
 + 
 + private val keys : Map [ Long , String ] = 
 ( config . keys map { 
 - case GooglePushKey ( projectId , key ) ⇒ 
 - val sender = new Sender ( key ) 
 - ( projectId → sender ) 
 + case GooglePushKey ( projectId , key ) ⇒ projectId → key 
 } ) . toMap 
 
 - def getInstance ( key : Long ) : Option [ Sender ] = 
 - senders . get ( key ) 
 + def send ( projectId : Long , regId : String , message : GooglePushMessage ) : Unit = 
 + keys get projectId match { 
 + case Some ( key ) ⇒ 
 + deliveryPublisher ! GooglePushDelivery . Delivery ( message , key , regId ) 
 + case None ⇒ 
 + log . warning ( " Key not found for projectId : { } " , projectId ) 
 + } 
 + } 
 + 
 + private object GooglePushDelivery { 
 + 
 + object Tick 
 + 
 + final case class Delivery ( m : GooglePushMessage , key : String , regId : String ) 
 + 
 + private val MaxQueue = 100000 
 + private val MaxConnections = 4 
 + 
 + def props = Props ( classOf [ GooglePushDelivery ] ) 
 + 
 + def flow ( implicit system : ActorSystem , mat : Materializer ) = 
 + Http ( system ) 
 + . cachedHostConnectionPoolTls [ GooglePushDelivery . Delivery ] ( 
 + " gcm - http . googleapis . com " , 
 + settings = ConnectionPoolSettings ( system ) . copy ( maxConnections = MaxConnections ) 
 + ) 
 + } 
 + 
 + private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] with ActorLogging { 
 + 
 + import GooglePushDelivery . _ 
 + 
 + private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] 
 + 
 + def receive = { 
 + case d : Delivery if buf . size = = MaxQueue ⇒ 
 + log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery " , MaxQueue ) 
 + case d : Delivery ⇒ 
 + if ( buf . isEmpty & & totalDemand > 0 ) 
 + onNext ( mkJob ( d ) ) 
 + else { 
 + this . buf : + = mkJob ( d ) 
 + deliverBuf ( ) 
 + } 
 + } 
 + 
 + @ tailrec def deliverBuf ( ) : Unit = 
 + if ( totalDemand > 0 ) { 
 + if ( totalDemand < = Int . MaxValue ) { 
 + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) 
 + buf = keep 
 + use foreach onNext 
 + } else { 
 + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) 
 + buf = keep 
 + use foreach onNext 
 + deliverBuf ( ) 
 + } 
 + } 
 + 
 + private def mkJob ( d : Delivery ) : ( HttpRequest , Delivery ) = 
 + HttpRequest ( 
 + method = HttpMethods . POST , 
 + uri = Uri ( " / gcm / send " ) , 
 + headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . regId } " , Map . empty [ String , String ] ) ) ) , 
 + entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . toString ( ) ) 
 + ) → d 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 index 1985d73 . . 8376311 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 @ @ - 1 , 29 + 1 , 16 @ @ 
 package im . actor . server . sequence 
 
 import akka . actor . ActorSystem 
 - import akka . event . Logging 
 - import com . google . android . gcm . server . { Sender , Message } 
 import im . actor . server . model . push . GooglePushCredentials 
 
 - import scala . concurrent . { ExecutionContext , Future , blocking } 
 - 
 private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : GooglePushManager , system : ActorSystem ) extends PushProvider { 
 - import system . dispatcher 
 - 
 - private val Retries = 3 
 - 
 - private val log = Logging ( system , getClass ) 
 - 
 def deliverInvisible ( seq : Int , creds : GooglePushCredentials ) : Unit = { 
 - withMgr ( creds . projectId ) { implicit mgr ⇒ 
 - val message = 
 - new Message . Builder ( ) 
 - . collapseKey ( s " seq - invisible - $ { userId . toString } " ) 
 - . addData ( " seq " , seq . toString ) 
 - . build ( ) 
 + val message = GooglePushMessage ( 
 + collapseKey = Some ( s " seq - invisible - $ { userId . toString } " ) , 
 + data = Some ( Map ( " seq " → seq . toString ) ) 
 + ) 
 
 - send ( message , creds . regId , Retries ) 
 - } 
 + googlePushManager . send ( creds . projectId , creds . regId , message ) 
 } 
 
 def deliverVisible ( 
 @ @ - 34 , 33 + 21 , 17 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : 
 isSoundEnabled : Boolean , 
 isVibrationEnabled : Boolean 
 ) : Unit = { 
 - withMgr ( creds . projectId ) { implicit mgr ⇒ 
 - val builder = new Message . Builder ( ) 
 - . collapseKey ( s " seq - visible - $ { userId . toString } " ) 
 - . addData ( " seq " , seq . toString ) 
 - 
 - val message = 
 + val message = GooglePushMessage ( 
 + collapseKey = Some ( s " seq - visible - $ { userId . toString } " ) , 
 + data = Some ( Map ( " seq " → seq . toString ) + + ( 
 data . text match { 
 case text if text . nonEmpty & & isTextEnabled ⇒ 
 - builder 
 - . addData ( " message " , text ) 
 - . build ( ) 
 - case _ ⇒ builder . build ( ) 
 + Map ( " message " → text ) 
 + case _ ⇒ Map . empty 
 } 
 + ) ) 
 + ) 
 
 - send ( message , creds . regId , Retries ) 
 - } 
 - } 
 - 
 - private def withMgr [ A ] ( projectId : Long ) ( f : Sender ⇒ A ) = 
 - googlePushManager . getInstance ( projectId ) match { 
 - case Some ( mgr ) ⇒ f ( mgr ) 
 - case None ⇒ log . warning ( " No google push configured for project - id : { } " , projectId ) 
 - } 
 - 
 - private def send ( message : Message , regId : String , retries : Int ) ( implicit mgr : Sender , ec : ExecutionContext ) : Unit = Future { 
 - blocking { 
 - mgr . send ( message , regId , Retries ) 
 - } 
 + googlePushManager . send ( creds . projectId , creds . regId , message ) 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 index c2ce0b7 . . 5a7b0cb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import akka . actor . _ 
 import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } 
 import akka . event . Logging 
 import akka . pattern . ask 
 + import akka . stream . ActorMaterializer 
 import akka . util . Timeout 
 import com . google . protobuf . ByteString 
 import im . actor . api . rpc . Update 
 @ @ - 239 , 6 + 240 , 8 @ @ object SeqUpdatesExtension extends ExtensionId [ SeqUpdatesExtension ] with Extensi 
 override def lookup = SeqUpdatesExtension 
 
 override def createExtension ( system : ExtendedActorSystem ) = { 
 + implicit val _ system = system 
 + implicit val mat = ActorMaterializer ( ) 
 val log = Logging ( system , getClass ) 
 
 try { 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 index 08827c4 . . c37af44 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 @ @ - 9 , 13 + 9 , 11 @ @ import akka . http . scaladsl . model . StatusCodes . OK 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . _ 
 import akka . stream . ActorMaterializer 
 - import akka . stream . scaladsl . Source 
 - import akka . util . ByteString 
 import im . actor . server . api . http . HttpHandler 
 import im . actor . server . file . local . { FileStorageOperations , LocalFileStorageConfig , RequestSigning } 
 import im . actor . util . log . AnyRefLogSource 
 
 - import scala . concurrent . { ExecutionContext , Future } 
 + import scala . concurrent . ExecutionContext 
 import scala . util . { Failure , Success } 
 
 private [ local ] final class FilesHttpHandler ( storageConfig : LocalFileStorageConfig ) ( implicit val system : ActorSystem ) 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index a259645 . . 5e32937 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 104 , 7 + 104 , 6 @ @ object Dependencies { 
 
 val tyrex = " tyrex " % " tyrex " % " 1 . 0 . 1 " 
 
 - val gcmServer = " com . google . android . gcm " % " gcm - server " % " 1 . 0 . 2 " 
 val pushy = " com . relayrides " % " pushy " % " 0 . 4 . 3 " 
 
 val logbackClassic = " ch . qos . logback " % " logback - classic " % " 1 . 1 . 2 " 
 @ @ - 167 , 7 + 166 , 6 @ @ object Dependencies { 
 akkaClusterSharding , 
 akkaDdata , 
 caffeine , 
 - gcmServer , 
 pushy , 
 jodaTime , 
 postgresJdbc ,
