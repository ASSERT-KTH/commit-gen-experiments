BLEU SCORE: 0.1279474029835104

TEST MSG: feat ( server : search ) :
GENERATED MSG: refactor ( server ) : unify search results to ApiPeer

TEST DIFF (one line): diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > index 88064e0 . . 16ce785 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > @ @ - 40 , 17 + 40 , 18 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > case ( ( pts , txts ) , ApiSearchPeerTypeCondition ( pt ) ) ⇒ ( pts + pt , txts ) < nl > case ( ( pts , txts ) , _ ) ⇒ ( pts , txts ) < nl > } < nl > + val peerTypesSorted = peerTypes . toVector . sortBy ( _ . id ) < nl > < nl > texts . toList match { < nl > case text : : Nil if text . length < 3 ⇒ < nl > FastFuture . successful ( Ok ( EmptyResult ) ) < nl > case text : : Nil ⇒ < nl > val tps = if ( peerTypes . isEmpty ) < nl > - Set ( ApiSearchPeerType . Public , ApiSearchPeerType . Contacts , ApiSearchPeerType . Groups ) < nl > + Vector ( ApiSearchPeerType . Groups , ApiSearchPeerType . Contacts , ApiSearchPeerType . Public ) < nl > else < nl > - peerTypes < nl > - searchResult ( tps . toVector , Some ( text ) , optimizations ) < nl > - case Nil ⇒ searchResult ( peerTypes . toVector , None , optimizations ) < nl > + peerTypesSorted < nl > + searchResult ( tps , Some ( text ) , optimizations ) < nl > + case Nil ⇒ searchResult ( peerTypesSorted , None , optimizations ) < nl > case _ ⇒ FastFuture . successful ( Error ( RpcError ( 400 , " INVALID _ QUERY " , " Invalid query . " , canTryAgain = false , None ) ) ) < nl > } < nl > } < nl > @ @ - 77 , 11 + 78 , 15 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > ) ( implicit client : AuthorizedClientData ) : Future [ HandlerResult [ ResponsePeerSearch ] ] = { < nl > for { < nl > results ← FutureExt . ftraverse ( pts ) ( search ( _ , text ) ) . map ( _ . reduce ( _ + + _ ) ) < nl > - ( groupIds , userIds ) = results . view . map ( _ . peer ) . foldLeft ( Vector . empty [ Int ] , Vector . empty [ Int ] ) { < nl > - case ( ( gids , uids ) , ApiPeer ( pt , pid ) ) ⇒ < nl > - pt match { < nl > - case ApiPeerType . Private ⇒ ( gids , uids : + pid ) < nl > - case ApiPeerType . Group ⇒ ( gids : + pid , uids ) < nl > + ( groupIds , userIds , searchResults ) = ( results foldLeft ( Vector . empty [ Int ] , Vector . empty [ Int ] , Vector . empty [ ApiPeerSearchResult ] ) ) { < nl > + case ( acc @ ( gids , uids , rslts ) , found @ ApiPeerSearchResult ( peer , _ ) ) ⇒ < nl > + if ( rslts . exists ( _ . peer = = peer ) ) { < nl > + acc < nl > + } else { < nl > + peer . ` type ` match { < nl > + case ApiPeerType . Private ⇒ ( gids , uids : + peer . id , rslts : + found ) < nl > + case ApiPeerType . Group ⇒ ( gids : + peer . id , uids , rslts : + found ) < nl > + } < nl > } < nl > } < nl > / / TODO : make like here : im . actor . server . api . rpc . service . groups . GroupsServiceImpl . usersOrPeers < nl > @ @ - 89 , 7 + 94 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > } yield { < nl > val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > Ok ( ResponsePeerSearch ( < nl > - searchResults = results , < nl > + searchResults = searchResults , < nl > users = if ( stripEntities ) Vector . empty else users . toVector , < nl > groups = if ( stripEntities ) Vector . empty else groups . toVector , < nl > userPeers = users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , < nl > @ @ - 149 , 10 + 154 , 10 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > / / search users by nickname prefix < nl > private def searchGlobalUsersPrefix ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ PeerAndMatchString ] ] = { < nl > text map { query ⇒ < nl > - globalNamesStorage . userIdsByPrefix ( query ) map { results ⇒ < nl > + globalNamesStorage . userIdsByPrefix ( normName ( query ) ) map { results ⇒ < nl > results collect { < nl > case ( userId , nickName ) if userId ! = client . userId ⇒ < nl > - ApiPeer ( ApiPeerType . Private , userId ) → nickName < nl > + ApiPeer ( ApiPeerType . Private , userId ) → s " @ $ nickName " < nl > } < nl > } < nl > } getOrElse FastFuture . successful ( Vector . empty ) < nl > @ @ - 161 , 15 + 166 , 17 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > / / find groups by global name prefix < nl > private def searchGlobalGroupsPrefix ( text : Option [ String ] ) : Future [ IndexedSeq [ PeerAndMatchString ] ] = { < nl > text map { query ⇒ < nl > - globalNamesStorage . groupIdsByPrefix ( query ) map { results ⇒ < nl > + globalNamesStorage . groupIdsByPrefix ( normName ( query ) ) map { results ⇒ < nl > results map { < nl > case ( groupId , globalName ) ⇒ < nl > - ApiPeer ( ApiPeerType . Group , groupId ) → globalName < nl > + ApiPeer ( ApiPeerType . Group , groupId ) → s " @ $ globalName " < nl > } < nl > } < nl > } getOrElse FastFuture . successful ( Vector . empty ) < nl > } < nl > < nl > + private def normName ( n : String ) = if ( n . startsWith ( " @ " ) ) n . drop ( 1 ) else n < nl > + < nl > private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeer ] ] = { < nl > for { < nl > userIds ← db . run ( UserContactRepo . findContactIdsActive ( client . userId ) )
NEAREST DIFF (one line): diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > index 1bff78b . . c3647ec 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > @ @ - 26 , 7 + 26 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > private val groupExt = GroupExtension ( system ) < nl > private val globalNamesStorage = new GlobalNamesStorageKeyValueStorage < nl > < nl > - private val EmptySearch = ResponsePeerSearch ( Vector . empty , Vector . empty , Vector . empty , Vector . empty , Vector . empty ) < nl > + private val EmptyResult = ResponsePeerSearch ( Vector . empty , Vector . empty , Vector . empty , Vector . empty , Vector . empty ) < nl > < nl > override def doHandlePeerSearch ( < nl > query : IndexedSeq [ ApiSearchCondition ] , < nl > @ @ - 42 , 7 + 42 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > < nl > texts . toList match { < nl > case text : : Nil if text . length < 3 ⇒ < nl > - FastFuture . successful ( Ok ( EmptySearch ) ) < nl > + FastFuture . successful ( Ok ( EmptyResult ) ) < nl > case text : : Nil ⇒ < nl > val tps = if ( peerTypes . isEmpty ) < nl > Set ( ApiSearchPeerType . Public , ApiSearchPeerType . Contacts , ApiSearchPeerType . Groups ) < nl > @ @ - 109 , 7 + 109 , 6 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > for { < nl > groups ← searchLocalGroups ( text ) < nl > } yield groups map result < nl > - / / global search < nl > case ApiSearchPeerType . Public ⇒ < nl > val usersFull = searchGlobalUsers ( text ) < nl > val usersPrefix = searchGlobalUsersPrefix ( text ) < nl > @ @ - 122 , 28 + 121 , 12 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > } < nl > } < nl > < nl > - / / from contacts < nl > - private def result ( apiUser : ApiUser ) : ApiPeerSearchResult = < nl > - ApiPeerSearchResult ( < nl > - peer = ApiPeer ( ApiPeerType . Private , apiUser . id ) , < nl > - optMatchString = None < nl > - ) < nl > - < nl > - / / from local groups < nl > - private def result ( apiGroup : ApiGroup ) : ApiPeerSearchResult = < nl > - ApiPeerSearchResult ( < nl > - peer = ApiPeer ( ApiPeerType . Group , apiGroup . id ) , < nl > - optMatchString = None < nl > - ) < nl > - < nl > - / / from global peer < nl > private def result ( peer : ApiPeer ) : ApiPeerSearchResult = < nl > ApiPeerSearchResult ( < nl > peer = peer , < nl > optMatchString = None < nl > ) < nl > < nl > - / / from global peer with nickname match < nl > private def result ( peerAndMatch : PeerAndMatchString ) : ApiPeerSearchResult = < nl > ApiPeerSearchResult ( < nl > peer = peerAndMatch . _ 1 , < nl > @ @ - 186 , 26 + 169 , 27 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > } getOrElse FastFuture . successful ( Vector . empty ) < nl > } < nl > < nl > - private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiUser ] ] = { < nl > + private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeer ] ] = { < nl > for { < nl > userIds ← db . run ( UserContactRepo . findContactIdsActive ( client . userId ) ) < nl > users ← FutureExt . ftraverse ( userIds ) ( userExt . getApiStruct ( _ , client . userId , client . authId ) ) < nl > } yield filterUsers ( users . toVector , text ) < nl > } < nl > < nl > - private def filterUsers ( users : IndexedSeq [ ApiUser ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiUser ] = < nl > + private def filterUsers ( users : IndexedSeq [ ApiUser ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiPeer ] = < nl > textOpt match { < nl > case Some ( text ) ⇒ < nl > val lotext = text . toLowerCase < nl > users filter { user ⇒ < nl > user . name . toLowerCase . contains ( lotext ) | | < nl > user . localName . exists ( _ . toLowerCase . contains ( lotext ) ) < nl > + } map { u ⇒ < nl > + ApiPeer ( ApiPeerType . Private , u . id ) < nl > } < nl > - case None ⇒ users < nl > + case None ⇒ users map { u ⇒ ApiPeer ( ApiPeerType . Private , u . id ) } < nl > } < nl > < nl > - / / TODO : rewrite it using async < nl > - private def searchLocalGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { < nl > + private def searchLocalGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeer ] ] = { < nl > for { < nl > ids ← DialogExtension ( system ) . fetchGroupedDialogs ( client . userId ) map ( _ . filter ( _ . typ . isGroups ) . flatMap ( _ . dialogs . map ( _ . getPeer . id ) ) ) < nl > groups ← FutureExt . ftraverse ( ids ) { id ⇒ < nl > @ @ - 214 , 16 + 198 , 18 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > } yield filterGroups ( groups . toVector , text ) < nl > } < nl > < nl > - private def filterGroups ( groups : IndexedSeq [ ApiGroup ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiGroup ] = { < nl > + private def filterGroups ( groups : IndexedSeq [ ApiGroup ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiPeer ] = { < nl > textOpt match { < nl > case Some ( text ) ⇒ < nl > - groups . view . filter { group ⇒ < nl > + groups filter { group ⇒ < nl > val lotext = text . toLowerCase < nl > group . title . toLowerCase . contains ( lotext ) | | < nl > group . about . exists ( _ . toLowerCase . contains ( lotext ) ) | | < nl > group . theme . exists ( _ . toLowerCase . contains ( lotext ) ) < nl > - } . force < nl > - case None ⇒ groups < nl > + } map { g ⇒ < nl > + ApiPeer ( ApiPeerType . Group , g . id ) < nl > + } < nl > + case None ⇒ groups map { g ⇒ ApiPeer ( ApiPeerType . Group , g . id ) } < nl > } < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 index 88064e0 . . 16ce785 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 @ @ - 40 , 17 + 40 , 18 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 case ( ( pts , txts ) , ApiSearchPeerTypeCondition ( pt ) ) ⇒ ( pts + pt , txts ) 
 case ( ( pts , txts ) , _ ) ⇒ ( pts , txts ) 
 } 
 + val peerTypesSorted = peerTypes . toVector . sortBy ( _ . id ) 
 
 texts . toList match { 
 case text : : Nil if text . length < 3 ⇒ 
 FastFuture . successful ( Ok ( EmptyResult ) ) 
 case text : : Nil ⇒ 
 val tps = if ( peerTypes . isEmpty ) 
 - Set ( ApiSearchPeerType . Public , ApiSearchPeerType . Contacts , ApiSearchPeerType . Groups ) 
 + Vector ( ApiSearchPeerType . Groups , ApiSearchPeerType . Contacts , ApiSearchPeerType . Public ) 
 else 
 - peerTypes 
 - searchResult ( tps . toVector , Some ( text ) , optimizations ) 
 - case Nil ⇒ searchResult ( peerTypes . toVector , None , optimizations ) 
 + peerTypesSorted 
 + searchResult ( tps , Some ( text ) , optimizations ) 
 + case Nil ⇒ searchResult ( peerTypesSorted , None , optimizations ) 
 case _ ⇒ FastFuture . successful ( Error ( RpcError ( 400 , " INVALID _ QUERY " , " Invalid query . " , canTryAgain = false , None ) ) ) 
 } 
 } 
 @ @ - 77 , 11 + 78 , 15 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 ) ( implicit client : AuthorizedClientData ) : Future [ HandlerResult [ ResponsePeerSearch ] ] = { 
 for { 
 results ← FutureExt . ftraverse ( pts ) ( search ( _ , text ) ) . map ( _ . reduce ( _ + + _ ) ) 
 - ( groupIds , userIds ) = results . view . map ( _ . peer ) . foldLeft ( Vector . empty [ Int ] , Vector . empty [ Int ] ) { 
 - case ( ( gids , uids ) , ApiPeer ( pt , pid ) ) ⇒ 
 - pt match { 
 - case ApiPeerType . Private ⇒ ( gids , uids : + pid ) 
 - case ApiPeerType . Group ⇒ ( gids : + pid , uids ) 
 + ( groupIds , userIds , searchResults ) = ( results foldLeft ( Vector . empty [ Int ] , Vector . empty [ Int ] , Vector . empty [ ApiPeerSearchResult ] ) ) { 
 + case ( acc @ ( gids , uids , rslts ) , found @ ApiPeerSearchResult ( peer , _ ) ) ⇒ 
 + if ( rslts . exists ( _ . peer = = peer ) ) { 
 + acc 
 + } else { 
 + peer . ` type ` match { 
 + case ApiPeerType . Private ⇒ ( gids , uids : + peer . id , rslts : + found ) 
 + case ApiPeerType . Group ⇒ ( gids : + peer . id , uids , rslts : + found ) 
 + } 
 } 
 } 
 / / TODO : make like here : im . actor . server . api . rpc . service . groups . GroupsServiceImpl . usersOrPeers 
 @ @ - 89 , 7 + 94 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 } yield { 
 val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 Ok ( ResponsePeerSearch ( 
 - searchResults = results , 
 + searchResults = searchResults , 
 users = if ( stripEntities ) Vector . empty else users . toVector , 
 groups = if ( stripEntities ) Vector . empty else groups . toVector , 
 userPeers = users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , 
 @ @ - 149 , 10 + 154 , 10 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 / / search users by nickname prefix 
 private def searchGlobalUsersPrefix ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ PeerAndMatchString ] ] = { 
 text map { query ⇒ 
 - globalNamesStorage . userIdsByPrefix ( query ) map { results ⇒ 
 + globalNamesStorage . userIdsByPrefix ( normName ( query ) ) map { results ⇒ 
 results collect { 
 case ( userId , nickName ) if userId ! = client . userId ⇒ 
 - ApiPeer ( ApiPeerType . Private , userId ) → nickName 
 + ApiPeer ( ApiPeerType . Private , userId ) → s " @ $ nickName " 
 } 
 } 
 } getOrElse FastFuture . successful ( Vector . empty ) 
 @ @ - 161 , 15 + 166 , 17 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 / / find groups by global name prefix 
 private def searchGlobalGroupsPrefix ( text : Option [ String ] ) : Future [ IndexedSeq [ PeerAndMatchString ] ] = { 
 text map { query ⇒ 
 - globalNamesStorage . groupIdsByPrefix ( query ) map { results ⇒ 
 + globalNamesStorage . groupIdsByPrefix ( normName ( query ) ) map { results ⇒ 
 results map { 
 case ( groupId , globalName ) ⇒ 
 - ApiPeer ( ApiPeerType . Group , groupId ) → globalName 
 + ApiPeer ( ApiPeerType . Group , groupId ) → s " @ $ globalName " 
 } 
 } 
 } getOrElse FastFuture . successful ( Vector . empty ) 
 } 
 
 + private def normName ( n : String ) = if ( n . startsWith ( " @ " ) ) n . drop ( 1 ) else n 
 + 
 private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeer ] ] = { 
 for { 
 userIds ← db . run ( UserContactRepo . findContactIdsActive ( client . userId ) )

NEAREST DIFF:
diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 index 1bff78b . . c3647ec 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 @ @ - 26 , 7 + 26 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 private val groupExt = GroupExtension ( system ) 
 private val globalNamesStorage = new GlobalNamesStorageKeyValueStorage 
 
 - private val EmptySearch = ResponsePeerSearch ( Vector . empty , Vector . empty , Vector . empty , Vector . empty , Vector . empty ) 
 + private val EmptyResult = ResponsePeerSearch ( Vector . empty , Vector . empty , Vector . empty , Vector . empty , Vector . empty ) 
 
 override def doHandlePeerSearch ( 
 query : IndexedSeq [ ApiSearchCondition ] , 
 @ @ - 42 , 7 + 42 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 
 texts . toList match { 
 case text : : Nil if text . length < 3 ⇒ 
 - FastFuture . successful ( Ok ( EmptySearch ) ) 
 + FastFuture . successful ( Ok ( EmptyResult ) ) 
 case text : : Nil ⇒ 
 val tps = if ( peerTypes . isEmpty ) 
 Set ( ApiSearchPeerType . Public , ApiSearchPeerType . Contacts , ApiSearchPeerType . Groups ) 
 @ @ - 109 , 7 + 109 , 6 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 for { 
 groups ← searchLocalGroups ( text ) 
 } yield groups map result 
 - / / global search 
 case ApiSearchPeerType . Public ⇒ 
 val usersFull = searchGlobalUsers ( text ) 
 val usersPrefix = searchGlobalUsersPrefix ( text ) 
 @ @ - 122 , 28 + 121 , 12 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 } 
 } 
 
 - / / from contacts 
 - private def result ( apiUser : ApiUser ) : ApiPeerSearchResult = 
 - ApiPeerSearchResult ( 
 - peer = ApiPeer ( ApiPeerType . Private , apiUser . id ) , 
 - optMatchString = None 
 - ) 
 - 
 - / / from local groups 
 - private def result ( apiGroup : ApiGroup ) : ApiPeerSearchResult = 
 - ApiPeerSearchResult ( 
 - peer = ApiPeer ( ApiPeerType . Group , apiGroup . id ) , 
 - optMatchString = None 
 - ) 
 - 
 - / / from global peer 
 private def result ( peer : ApiPeer ) : ApiPeerSearchResult = 
 ApiPeerSearchResult ( 
 peer = peer , 
 optMatchString = None 
 ) 
 
 - / / from global peer with nickname match 
 private def result ( peerAndMatch : PeerAndMatchString ) : ApiPeerSearchResult = 
 ApiPeerSearchResult ( 
 peer = peerAndMatch . _ 1 , 
 @ @ - 186 , 26 + 169 , 27 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 } getOrElse FastFuture . successful ( Vector . empty ) 
 } 
 
 - private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiUser ] ] = { 
 + private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeer ] ] = { 
 for { 
 userIds ← db . run ( UserContactRepo . findContactIdsActive ( client . userId ) ) 
 users ← FutureExt . ftraverse ( userIds ) ( userExt . getApiStruct ( _ , client . userId , client . authId ) ) 
 } yield filterUsers ( users . toVector , text ) 
 } 
 
 - private def filterUsers ( users : IndexedSeq [ ApiUser ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiUser ] = 
 + private def filterUsers ( users : IndexedSeq [ ApiUser ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiPeer ] = 
 textOpt match { 
 case Some ( text ) ⇒ 
 val lotext = text . toLowerCase 
 users filter { user ⇒ 
 user . name . toLowerCase . contains ( lotext ) | | 
 user . localName . exists ( _ . toLowerCase . contains ( lotext ) ) 
 + } map { u ⇒ 
 + ApiPeer ( ApiPeerType . Private , u . id ) 
 } 
 - case None ⇒ users 
 + case None ⇒ users map { u ⇒ ApiPeer ( ApiPeerType . Private , u . id ) } 
 } 
 
 - / / TODO : rewrite it using async 
 - private def searchLocalGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { 
 + private def searchLocalGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeer ] ] = { 
 for { 
 ids ← DialogExtension ( system ) . fetchGroupedDialogs ( client . userId ) map ( _ . filter ( _ . typ . isGroups ) . flatMap ( _ . dialogs . map ( _ . getPeer . id ) ) ) 
 groups ← FutureExt . ftraverse ( ids ) { id ⇒ 
 @ @ - 214 , 16 + 198 , 18 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 } yield filterGroups ( groups . toVector , text ) 
 } 
 
 - private def filterGroups ( groups : IndexedSeq [ ApiGroup ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiGroup ] = { 
 + private def filterGroups ( groups : IndexedSeq [ ApiGroup ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiPeer ] = { 
 textOpt match { 
 case Some ( text ) ⇒ 
 - groups . view . filter { group ⇒ 
 + groups filter { group ⇒ 
 val lotext = text . toLowerCase 
 group . title . toLowerCase . contains ( lotext ) | | 
 group . about . exists ( _ . toLowerCase . contains ( lotext ) ) | | 
 group . theme . exists ( _ . toLowerCase . contains ( lotext ) ) 
 - } . force 
 - case None ⇒ groups 
 + } map { g ⇒ 
 + ApiPeer ( ApiPeerType . Group , g . id ) 
 + } 
 + case None ⇒ groups map { g ⇒ ApiPeer ( ApiPeerType . Group , g . id ) } 
 } 
 } 
 }
