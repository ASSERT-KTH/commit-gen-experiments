BLEU SCORE: 0.09578464408619825

TEST MSG: feat ( clc ) : add some unit test for clc app
GENERATED MSG: feat ( jvm ) : Updated TCP Implementation

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcIndexStorageTest . java b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcIndexStorageTest . java < nl > new file mode 100644 < nl > index 0000000 . . 8144355 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcIndexStorageTest . java < nl > @ @ - 0 , 0 + 1 , 192 @ @ < nl > + package im . actor . runtime . clc ; < nl > + < nl > + import static org . junit . Assert . * ; < nl > + import static org . hamcrest . CoreMatchers . * ; < nl > + < nl > + import im . actor . runtime . StorageRuntimeProvider ; < nl > + import im . actor . runtime . storage . IndexStorage ; < nl > + import org . junit . After ; < nl > + import org . junit . Before ; < nl > + import org . junit . Test ; < nl > + < nl > + import java . util . Arrays ; < nl > + import java . util . List ; < nl > + < nl > + / * * < nl > + * Created by amir on 4 / 12 / 16 . < nl > + * / < nl > + public class ClcIndexStorageTest { < nl > + < nl > + private StorageRuntimeProvider srp ; < nl > + private IndexStorage is ; < nl > + < nl > + @ Before < nl > + public void initialize ( ) { < nl > + System . out . println ( " before " ) ; < nl > + srp = new StorageRuntimeProvider ( ) ; < nl > + / / create test table < nl > + is = srp . createIndex ( " test " ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void get ( ) { < nl > + assertNull ( is . get ( 0 ) ) ; < nl > + < nl > + } < nl > + < nl > + < nl > + @ Test < nl > + public void getWithContext ( ) { < nl > + is . put ( 1 , 20 ) ; < nl > + srp . setContext ( " 935 " ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + is . put ( 1 , 30 ) ; < nl > + assertEquals ( is . get ( 1 ) , new Long ( 30 ) ) ; < nl > + < nl > + srp . setContext ( null ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + assertEquals ( is . get ( 1 ) , new Long ( 20 ) ) ; < nl > + } < nl > + @ Test < nl > + public void put ( ) { < nl > + is . put ( 123 , 456 ) ; < nl > + assertEquals ( is . get ( 123 ) , new Long ( 456 ) ) ; < nl > + < nl > + is . put ( 3 , 30 ) ; < nl > + is . put ( 4 , 30 ) ; < nl > + assertEquals ( is . get ( 3 ) , new Long ( 30 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void putWithContext ( ) { < nl > + is . put ( 1 , 10 ) ; < nl > + is . put ( 2 , 20 ) ; < nl > + srp . setContext ( " 935 " ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + is . put ( 3 , 30 ) ; < nl > + is . put ( 4 , 40 ) ; < nl > + assertNull ( is . get ( 1 ) ) ; < nl > + assertNull ( is . get ( 2 ) ) ; < nl > + assertNotNull ( is . get ( 3 ) ) ; < nl > + is . put ( 1 , 50 ) ; < nl > + is . put ( 2 , 50 ) ; < nl > + < nl > + / / test the effect of context ( id and context are primary keys ) < nl > + assertEquals ( ( ( ClcIndexStorage ) is ) . countAll ( ) , 6 ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void findBeforeValue ( ) { < nl > + is . put ( 1 , 10 ) ; < nl > + is . put ( 2 , 10 ) ; < nl > + is . put ( 3 , 20 ) ; < nl > + List < Long > actual = is . findBeforeValue ( 10 ) ; < nl > + List < Long > expected = Arrays . asList ( 1L , 2L ) ; < nl > + assertThat ( actual , is ( expected ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void findBeforeValueWithContext ( ) { < nl > + is . put ( 1 , 10 ) ; < nl > + is . put ( 2 , 10 ) ; < nl > + srp . setContext ( " 936 " ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + is . put ( 3 , 10 ) ; < nl > + is . put ( 4 , 10 ) ; < nl > + List < Long > actual = is . findBeforeValue ( 10 ) ; < nl > + List < Long > expected = Arrays . asList ( 3L , 4L ) ; < nl > + assertThat ( actual , is ( expected ) ) ; < nl > + srp . setContext ( null ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + actual = is . findBeforeValue ( 10 ) ; < nl > + expected = Arrays . asList ( 1L , 2L ) ; < nl > + assertThat ( actual , is ( expected ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void remove ( ) { < nl > + is . put ( 1 , 10 ) ; < nl > + is . remove ( 1 ) ; < nl > + assertNull ( is . get ( 1 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void removeWithContext ( ) { < nl > + is . put ( 1 , 10 ) ; < nl > + is . put ( 2 , 20 ) ; < nl > + srp . setContext ( " 935 " ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + is . put ( 1 , 30 ) ; < nl > + is . put ( 2 , 40 ) ; < nl > + is . remove ( 1 ) ; < nl > + assertNull ( is . get ( 1 ) ) ; < nl > + srp . setContext ( null ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + assertEquals ( is . get ( 1 ) , new Long ( 10 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void removeList ( ) { < nl > + is . put ( 1 , 10 ) ; < nl > + is . put ( 2 , 10 ) ; < nl > + is . put ( 3 , 10 ) ; < nl > + is . remove ( Arrays . asList ( 1L , 2L , 3L ) ) ; < nl > + assertNull ( is . get ( 1 ) ) ; < nl > + assertNull ( is . get ( 2 ) ) ; < nl > + assertNull ( is . get ( 3 ) ) ; < nl > + } < nl > + < nl > + < nl > + @ Test < nl > + public void removeBeforeValue ( ) { < nl > + is . put ( 1 , 10 ) ; < nl > + is . put ( 2 , 10 ) ; < nl > + is . put ( 3 , 20 ) ; < nl > + is . removeBeforeValue ( 10 ) ; < nl > + assertNull ( is . get ( 1 ) ) ; < nl > + assertNull ( is . get ( 2 ) ) ; < nl > + assertEquals ( is . get ( 3 ) , new Long ( 20 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void getCount ( ) { < nl > + is . put ( 1 , 10 ) ; < nl > + is . put ( 2 , 10 ) ; < nl > + is . put ( 3 , 20 ) ; < nl > + assertEquals ( is . getCount ( ) , 3 ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void getCountWithContext ( ) { < nl > + srp . setContext ( " 935 " ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + is . put ( 1 , 10 ) ; < nl > + is . put ( 2 , 10 ) ; < nl > + assertEquals ( is . getCount ( ) , 2 ) ; < nl > + < nl > + srp . setContext ( null ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + is . put ( 3 , 20 ) ; < nl > + is . put ( 4 , 40 ) ; < nl > + is . put ( 5 , 40 ) ; < nl > + assertEquals ( is . getCount ( ) , 3 ) ; < nl > + < nl > + srp . setContext ( " 935 " ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + assertEquals ( is . getCount ( ) , 2 ) ; < nl > + < nl > + srp . setContext ( " 936 " ) ; < nl > + is = srp . createIndex ( " test " ) ; < nl > + is . put ( 1 , 10 ) ; < nl > + assertEquals ( is . getCount ( ) , 1 ) ; < nl > + < nl > + } < nl > + < nl > + @ After < nl > + public void finalize ( ) { < nl > + System . out . println ( " after " ) ; < nl > + srp . setContext ( null ) ; < nl > + / / remove all records < nl > + ( ( ClcIndexStorage ) is ) . clearAll ( ) ; < nl > + } < nl > + } < nl > diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcJavaPreferenceStorageTest . java b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcJavaPreferenceStorageTest . java < nl > new file mode 100644 < nl > index 0000000 . . 78426da < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcJavaPreferenceStorageTest . java < nl > @ @ - 0 , 0 + 1 , 38 @ @ < nl > + package im . actor . runtime . clc ; < nl > + < nl > + import im . actor . runtime . storage . PreferencesStorage ; < nl > + import org . junit . Test ; < nl > + < nl > + import static junit . framework . TestCase . assertEquals ; < nl > + < nl > + / * * < nl > + * Created by amir on 3 / 14 / 16 . < nl > + * / < nl > + public class ClcJavaPreferenceStorageTest { < nl > + @ Test < nl > + public void getString ( ) { < nl > + PreferencesStorage pref = new ClcJavaPreferenceStorage ( ) ; < nl > + pref . putString ( " key " , " string " ) ; < nl > + / / assertEquals ( " string " , pref . getString ( " key " ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void getLong ( ) { < nl > + PreferencesStorage pref = new ClcJavaPreferenceStorage ( ) ; < nl > + pref . putLong ( " key " , 1 ) ; < nl > + / / assertEquals ( 1 , pref . getLong ( " key " , 0 ) ) ; < nl > + / / assertEquals ( 0 , pref . getLong ( " nokey " , 0 ) ) ; < nl > + } < nl > + < nl > + < nl > + @ Test < nl > + public void getBytes ( ) { < nl > + PreferencesStorage pref = new ClcJavaPreferenceStorage ( ) ; < nl > + pref . putBytes ( " key " , new byte [ ] { 1 , 2 , 3 } ) ; < nl > + byte [ ] arr = pref . getBytes ( " key " ) ; < nl > + / / assertEquals ( ( byte ) 1 , arr [ 0 ] ) ; < nl > + / / assertEquals ( ( byte ) 2 , arr [ 1 ] ) ; < nl > + / / assertEquals ( ( byte ) 3 , arr [ 2 ] ) ; < nl > + } < nl > + < nl > + } < nl > diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcKeyValueStorageTest . java b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcKeyValueStorageTest . java < nl > new file mode 100644 < nl > index 0000000 . . 9019f49 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcKeyValueStorageTest . java < nl > @ @ - 0 , 0 + 1 , 186 @ @ < nl > + package im . actor . runtime . clc ; < nl > + < nl > + import im . actor . runtime . StorageRuntimeProvider ; < nl > + import im . actor . runtime . storage . IndexStorage ; < nl > + import im . actor . runtime . storage . KeyValueEngine ; < nl > + import im . actor . runtime . storage . KeyValueRecord ; < nl > + import im . actor . runtime . storage . KeyValueStorage ; < nl > + import org . junit . After ; < nl > + import org . junit . Before ; < nl > + import org . junit . Test ; < nl > + < nl > + import java . util . Arrays ; < nl > + import java . util . List ; < nl > + < nl > + import static org . hamcrest . CoreMatchers . is ; < nl > + import static org . junit . Assert . * ; < nl > + < nl > + / * * < nl > + * Created by amir on 4 / 12 / 16 . < nl > + * / < nl > + public class ClcKeyValueStorageTest { < nl > + < nl > + private StorageRuntimeProvider srp ; < nl > + private KeyValueStorage kvs ; < nl > + < nl > + @ Before < nl > + public void initialize ( ) { < nl > + srp = new StorageRuntimeProvider ( ) ; < nl > + / / create test table < nl > + kvs = srp . createKeyValue ( " test " ) ; < nl > + } < nl > + < nl > + < nl > + @ Test < nl > + public void loadItem ( ) { < nl > + assertNull ( kvs . loadItem ( 0 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void loadItemWithContext ( ) { < nl > + kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; < nl > + kvs . addOrUpdateItem ( 2 , " value2 " . getBytes ( ) ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + < nl > + srp . setContext ( " 935 " ) ; < nl > + kvs = srp . createKeyValue ( " test " ) ; < nl > + kvs . addOrUpdateItem ( 3 , " value3 " . getBytes ( ) ) ; < nl > + kvs . addOrUpdateItem ( 4 , " value4 " . getBytes ( ) ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 3 ) ) , " value3 " ) ; < nl > + assertNull ( kvs . loadItem ( 1 ) ) ; < nl > + assertNull ( kvs . loadItem ( 2 ) ) ; < nl > + < nl > + srp . setContext ( null ) ; < nl > + kvs = srp . createKeyValue ( " test " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + < nl > + } < nl > + < nl > + < nl > + < nl > + < nl > + @ Test < nl > + public void addOrUpdateItem ( ) { < nl > + / / insert < nl > + kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + < nl > + / / update < nl > + kvs . addOrUpdateItem ( 1 , " value2 " . getBytes ( ) ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value2 " ) ; < nl > + } < nl > + < nl > + < nl > + @ Test < nl > + public void addOrUpdateItems ( ) { < nl > + / / insert < nl > + List keyValues = Arrays . asList ( < nl > + new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , < nl > + new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; < nl > + kvs . addOrUpdateItems ( keyValues ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + < nl > + / / update < nl > + keyValues = Arrays . asList ( < nl > + new KeyValueRecord ( 1 , " value3 " . getBytes ( ) ) , < nl > + new KeyValueRecord ( 2 , " value4 " . getBytes ( ) ) ) ; < nl > + kvs . addOrUpdateItems ( keyValues ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value3 " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value4 " ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void removeItem ( ) { < nl > + kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + kvs . removeItem ( 1 ) ; < nl > + assertNull ( kvs . loadItem ( 1 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void removeItemWithContext ( ) { < nl > + kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + < nl > + srp . setContext ( " 935 " ) ; < nl > + kvs = srp . createKeyValue ( " test " ) ; < nl > + kvs . addOrUpdateItem ( 1 , " value2 " . getBytes ( ) ) ; < nl > + kvs . removeItem ( 1 ) ; < nl > + assertNull ( kvs . loadItem ( 1 ) ) ; < nl > + < nl > + srp . setContext ( null ) ; < nl > + kvs = srp . createKeyValue ( " test " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void removeItems ( ) { < nl > + List keyValues = Arrays . asList ( < nl > + new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , < nl > + new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; < nl > + kvs . addOrUpdateItems ( keyValues ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + < nl > + kvs . removeItems ( new long [ ] { 1 , 2 } ) ; < nl > + assertNull ( kvs . loadItem ( 1 ) ) ; < nl > + assertNull ( kvs . loadItem ( 2 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void clear ( ) { < nl > + List keyValues = Arrays . asList ( < nl > + new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , < nl > + new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; < nl > + kvs . addOrUpdateItems ( keyValues ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + < nl > + kvs . clear ( ) ; < nl > + assertNull ( kvs . loadItem ( 1 ) ) ; < nl > + assertNull ( kvs . loadItem ( 2 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void clearWithContext ( ) { < nl > + List keyValues = Arrays . asList ( < nl > + new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , < nl > + new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; < nl > + kvs . addOrUpdateItems ( keyValues ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + < nl > + srp . setContext ( " 935 " ) ; < nl > + kvs = srp . createKeyValue ( " test " ) ; < nl > + assertNull ( kvs . loadItem ( 1 ) ) ; < nl > + assertNull ( kvs . loadItem ( 2 ) ) ; < nl > + < nl > + List keyValues2 = Arrays . asList ( < nl > + new KeyValueRecord ( 3 , " value3 " . getBytes ( ) ) , < nl > + new KeyValueRecord ( 4 , " value4 " . getBytes ( ) ) ) ; < nl > + kvs . addOrUpdateItems ( keyValues2 ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 3 ) ) , " value3 " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 4 ) ) , " value4 " ) ; < nl > + kvs . clear ( ) ; < nl > + assertNull ( kvs . loadItem ( 3 ) ) ; < nl > + assertNull ( kvs . loadItem ( 4 ) ) ; < nl > + < nl > + srp . setContext ( null ) ; < nl > + kvs = srp . createKeyValue ( " test " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + < nl > + } < nl > + < nl > + < nl > + < nl > + @ After < nl > + public void finalize ( ) { < nl > + srp . setContext ( null ) ; < nl > + / / remove all records < nl > + ( ( ClcKeyValueStorage ) kvs ) . clearAll ( ) ; < nl > + } < nl > + } < nl > diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcListStorageTest . java b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcListStorageTest . java < nl > new file mode 100644 < nl > index 0000000 . . 2b10fae < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcListStorageTest . java < nl > @ @ - 0 , 0 + 1 , 223 @ @ < nl > + package im . actor . runtime . clc ; < nl > + < nl > + import im . actor . runtime . StorageRuntimeProvider ; < nl > + import im . actor . runtime . storage . * ; < nl > + import org . junit . After ; < nl > + import org . junit . Before ; < nl > + import org . junit . Test ; < nl > + < nl > + import java . util . Arrays ; < nl > + import java . util . List ; < nl > + < nl > + import static org . junit . Assert . * ; < nl > + < nl > + / * * < nl > + * Created by amir on 4 / 12 / 16 . < nl > + * / < nl > + public class ClcListStorageTest { < nl > + < nl > + private StorageRuntimeProvider srp ; < nl > + private ListStorage ls ; < nl > + < nl > + @ Before < nl > + public void initialize ( ) { < nl > + srp = new StorageRuntimeProvider ( ) ; < nl > + / / create test table < nl > + ls = srp . createList ( " test " ) ; < nl > + } < nl > + < nl > + < nl > + @ Test < nl > + public void loadItem ( ) { < nl > + assertNull ( ls . loadItem ( 0 ) ) ; < nl > + } < nl > + < nl > + / / @ Test < nl > + / / public void loadItemWithContext ( ) { < nl > + / / ls . updateOrAdd ( 1 , " value1 " . getBytes ( ) ) ; < nl > + / / ls . updateOrAdd ( 2 , " value2 " . getBytes ( ) ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + / / < nl > + / / srp . setContext ( " 935 " ) ; < nl > + / / ls = srp . createKeyValue ( " test " ) ; < nl > + / / ls . addOrUpdateItem ( 3 , " value3 " . getBytes ( ) ) ; < nl > + / / ls . addOrUpdateItem ( 4 , " value4 " . getBytes ( ) ) ; < nl > + / / assertEquals ( new String ( ls . loadItem ( 3 ) ) , " value3 " ) ; < nl > + / / assertNull ( ls . loadItem ( 1 ) ) ; < nl > + / / assertNull ( ls . loadItem ( 2 ) ) ; < nl > + / / < nl > + / / srp . setContext ( null ) ; < nl > + / / kvs = srp . createKeyValue ( " test " ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + / / < nl > + / / } < nl > + < nl > + < nl > + private void assertEqualLER ( ListEngineRecord actualLer , ListEngineRecord expectedLer ) { < nl > + / / assertEquals ( actualLer . getKey ( ) , expectedLer . getKey ( ) ) ; < nl > + assertEquals ( actualLer . getOrder ( ) , expectedLer . getOrder ( ) ) ; < nl > + assertEquals ( actualLer . getQuery ( ) , expectedLer . getQuery ( ) ) ; < nl > + assertEquals ( new String ( actualLer . getData ( ) ) , new String ( expectedLer . getData ( ) ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void updateOrAdd ( ) { < nl > + / / insert < nl > + ListEngineRecord ler = new ListEngineRecord ( 1 , 1 , " test " , " bytes " . getBytes ( ) ) ; < nl > + ls . updateOrAdd ( ler ) ; < nl > + < nl > + ListEngineRecord actual = ls . loadItem ( ler . getKey ( ) ) ; < nl > + assertEqualLER ( actual , ler ) ; < nl > + < nl > + / / update < nl > + ler = new ListEngineRecord ( 1 , 1 , " test2 " , " bytes2 " . getBytes ( ) ) ; < nl > + ls . updateOrAdd ( ler ) ; < nl > + actual = ls . loadItem ( ler . getKey ( ) ) ; < nl > + assertEqualLER ( actual , ler ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void updateOrAddList ( ) { < nl > + / / insert < nl > + ListEngineRecord ler1 = new ListEngineRecord ( 1 , 1 , " test1 " , " bytes1 " . getBytes ( ) ) ; < nl > + ListEngineRecord ler2 = new ListEngineRecord ( 2 , 2 , " test2 " , " bytes2 " . getBytes ( ) ) ; < nl > + ListEngineRecord ler3 = new ListEngineRecord ( 3 , 3 , " test3 " , " bytes3 " . getBytes ( ) ) ; < nl > + ListEngineRecord ler4 = new ListEngineRecord ( 4 , 4 , " test4 " , " bytes4 " . getBytes ( ) ) ; < nl > + ListEngineRecord ler5 = new ListEngineRecord ( 5 , 5 , " test5 " , " bytes5 " . getBytes ( ) ) ; < nl > + ListEngineRecord ler6 = new ListEngineRecord ( 6 , 6 , " test6 " , " bytes6 " . getBytes ( ) ) ; < nl > + ls . updateOrAdd ( Arrays . asList ( ler1 , ler2 , ler3 , ler4 , ler5 , ler6 ) ) ; < nl > + < nl > + ListEngineRecord actual = ls . loadItem ( ler1 . getKey ( ) ) ; < nl > + assertEqualLER ( actual , ler1 ) ; < nl > + actual = ls . loadItem ( ler2 . getKey ( ) ) ; < nl > + assertEqualLER ( actual , ler2 ) ; < nl > + actual = ls . loadItem ( ler3 . getKey ( ) ) ; < nl > + assertEqualLER ( actual , ler3 ) ; < nl > + actual = ls . loadItem ( ler4 . getKey ( ) ) ; < nl > + assertEqualLER ( actual , ler4 ) ; < nl > + actual = ls . loadItem ( ler5 . getKey ( ) ) ; < nl > + assertEqualLER ( actual , ler5 ) ; < nl > + actual = ls . loadItem ( ler6 . getKey ( ) ) ; < nl > + assertEqualLER ( actual , ler6 ) ; < nl > + < nl > + } < nl > + < nl > + @ Test < nl > + public void remove ( ) { < nl > + updateOrAdd ( ) ; < nl > + ls . delete ( 1 ) ; < nl > + assertNull ( ls . loadItem ( 1 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void removeList ( ) { < nl > + updateOrAddList ( ) ; < nl > + ls . delete ( new long [ ] { 1 , 2 } ) ; < nl > + assertNull ( ls . loadItem ( 1 ) ) ; < nl > + assertNull ( ls . loadItem ( 2 ) ) ; < nl > + assertNotNull ( ls . loadItem ( 3 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void isEmpty ( ) { < nl > + assertTrue ( ls . isEmpty ( ) ) ; < nl > + updateOrAdd ( ) ; < nl > + assertFalse ( ls . isEmpty ( ) ) ; < nl > + } < nl > + < nl > + / / @ Test < nl > + / / public void loadForward ( ) { < nl > + / / updateOrAddList ( ) ; < nl > + / / ListStorageDisplayEx lsd = ( ListStorageDisplayEx ) ls ; < nl > + / / List < ListEngineRecord > actual = lsd . loadForward ( 5L , 2 ) ; < nl > + / / < nl > + / / List < ListEngineRecord > expected = Arrays . asList ( < nl > + / / new ListEngineRecord ( 3 , 3 , " test3 " , " bytes3 " . getBytes ( ) ) , < nl > + / / new ListEngineRecord ( 4 , 4 , " test3 " , " bytes3 " . getBytes ( ) ) < nl > + / / ) ; < nl > + / / assertEqualLER ( actual . get ( 0 ) , expected . get ( 0 ) ) ; < nl > + / / assertEqualLER ( actual . get ( 1 ) , expected . get ( 1 ) ) ; < nl > + / / } < nl > + < nl > + / / < nl > + / / < nl > + / / @ Test < nl > + / / public void addOrUpdateItems ( ) { < nl > + / / / / insert < nl > + / / List keyValues = Arrays . asList ( < nl > + / / new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , < nl > + / / new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; < nl > + / / kvs . addOrUpdateItems ( keyValues ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + / / < nl > + / / / / update < nl > + / / keyValues = Arrays . asList ( < nl > + / / new KeyValueRecord ( 1 , " value3 " . getBytes ( ) ) , < nl > + / / new KeyValueRecord ( 2 , " value4 " . getBytes ( ) ) ) ; < nl > + / / kvs . addOrUpdateItems ( keyValues ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value3 " ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value4 " ) ; < nl > + / / } < nl > + / / < nl > + / / @ Test < nl > + / / public void removeItem ( ) { < nl > + / / kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + / / kvs . removeItem ( 1 ) ; < nl > + / / assertNull ( kvs . loadItem ( 1 ) ) ; < nl > + / / } < nl > + / / < nl > + / / @ Test < nl > + / / public void removeItemWithContext ( ) { < nl > + / / kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + / / < nl > + / / srp . setContext ( " 935 " ) ; < nl > + / / kvs = srp . createKeyValue ( " test " ) ; < nl > + / / kvs . addOrUpdateItem ( 1 , " value2 " . getBytes ( ) ) ; < nl > + / / kvs . removeItem ( 1 ) ; < nl > + / / assertNull ( kvs . loadItem ( 1 ) ) ; < nl > + / / < nl > + / / srp . setContext ( null ) ; < nl > + / / kvs = srp . createKeyValue ( " test " ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + / / } < nl > + / / < nl > + / / @ Test < nl > + / / public void removeItems ( ) { < nl > + / / List keyValues = Arrays . asList ( < nl > + / / new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , < nl > + / / new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; < nl > + / / kvs . addOrUpdateItems ( keyValues ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; < nl > + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; < nl > + / / < nl > + / / kvs . removeItems ( new long [ ] { 1 , 2 } ) ; < nl > + / / assertNull ( kvs . loadItem ( 1 ) ) ; < nl > + / / assertNull ( kvs . loadItem ( 2 ) ) ; < nl > + / / } < nl > + / / < nl > + @ Test < nl > + public void clear ( ) { < nl > + updateOrAddList ( ) ; < nl > + ls . clear ( ) ; < nl > + assertNull ( ls . loadItem ( 1 ) ) ; < nl > + assertNull ( ls . loadItem ( 2 ) ) ; < nl > + } < nl > + < nl > + @ Test < nl > + public void getCount ( ) { < nl > + updateOrAddList ( ) ; < nl > + assertEquals ( ls . getCount ( ) , 6 ) ; < nl > + } < nl > + < nl > + @ After < nl > + public void finalize ( ) { < nl > + srp . setContext ( null ) ; < nl > + / / remove all records < nl > + ( ( ClcListStorage ) ls ) . clearAll ( ) ; < nl > + } < nl > + } < nl > diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / resources / preferences . properties b / actor - sdk / sdk - core - clc / app - clc / src / test / resources / preferences . properties < nl > new file mode 100644 < nl > index 0000000 . . e69de29
NEAREST DIFF (one line): diff - - git a / apps / actor - android / src / main / java / im / actor / messenger / app / fragment / auth / BackspaceKeyEditText . java b / apps / actor - android / src / main / java / im / actor / messenger / app / fragment / auth / BackspaceKeyEditText . java < nl > index e785ae6 . . 2b0ec15 100644 < nl > - - - a / apps / actor - android / src / main / java / im / actor / messenger / app / fragment / auth / BackspaceKeyEditText . java < nl > + + + b / apps / actor - android / src / main / java / im / actor / messenger / app / fragment / auth / BackspaceKeyEditText . java < nl > @ @ - 1 , 7 + 1 , 6 @ @ < nl > package im . actor . messenger . app . fragment . auth ; < nl > < nl > import android . content . Context ; < nl > - import android . support . v7 . internal . widget . TintEditText ; < nl > import android . util . AttributeSet ; < nl > import android . view . KeyEvent ; < nl > import android . view . inputmethod . EditorInfo ; < nl > @ @ - 9 , 7 + 8 , 7 @ @ import android . view . inputmethod . InputConnection ; < nl > import android . view . inputmethod . InputConnectionWrapper ; < nl > import android . widget . EditText ; < nl > < nl > - public class BackspaceKeyEditText extends TintEditText { < nl > + public class BackspaceKeyEditText extends EditText { < nl > < nl > private BackspacePressListener listener ; < nl > < nl > diff - - git a / apps / actor - android / src / main / res / values / styles . xml b / apps / actor - android / src / main / res / values / styles . xml < nl > index c3ac8ae . . 8572f57 100644 < nl > - - - a / apps / actor - android / src / main / res / values / styles . xml < nl > + + + b / apps / actor - android / src / main / res / values / styles . xml < nl > @ @ - 11 , 12 + 11 , 17 @ @ < nl > < item name = " android : colorPrimary " > @ color / primary < / item > < nl > < item name = " android : colorPrimaryDark " > @ color / primary _ hovered < / item > < nl > < item name = " android : colorAccent " > @ color / accent < / item > < nl > + < nl > + < nl > < / style > < nl > < nl > < style name = " MainActivityTheme " parent = " AppToolbarTheme " > < nl > + < item name = " android : windowBackground " > @ color / bg _ main < / item > < nl > + < nl > < item name = " windowActionBar " > false < / item > < nl > + < item name = " windowNoTitle " > true < / item > < nl > < item name = " android : windowActionBar " > false < / item > < nl > - < item name = " android : windowBackground " > @ color / bg _ main < / item > < nl > + < item name = " android : windowNoTitle " > true < / item > < nl > < / style > < nl > < nl > < style name = " ProfileActivityTheme " parent = " AppToolbarTheme " > < nl > diff - - git a / library / actor - common / src / main / java / im / actor / model / network / connection / AsyncConnectionFactory . java b / library / actor - common / src / main / java / im / actor / model / network / connection / AsyncConnectionFactory . java < nl > index 986847f . . 2c281d8 100644 < nl > - - - a / library / actor - common / src / main / java / im / actor / model / network / connection / AsyncConnectionFactory . java < nl > + + + b / library / actor - common / src / main / java / im / actor / model / network / connection / AsyncConnectionFactory . java < nl > @ @ - 6 , 5 + 6 , 5 @ @ import im . actor . model . network . ConnectionEndpoint ; < nl > * Created by ex3ndr on 29 . 04 . 15 . < nl > * / < nl > public interface AsyncConnectionFactory { < nl > - AsyncConnection createConnection ( ConnectionEndpoint endpoint , AsyncConnectionInterface connectionInterface ) ; < nl > + AsyncConnection createConnection ( int connectionId , ConnectionEndpoint endpoint , AsyncConnectionInterface connectionInterface ) ; < nl > } < nl > diff - - git a / library / actor - common / src / main / java / im / actor / model / network / connection / ManagedConnection . java b / library / actor - common / src / main / java / im / actor / model / network / connection / ManagedConnection . java < nl > index 6b9e800 . . 6896cdb 100644 < nl > - - - a / library / actor - common / src / main / java / im / actor / model / network / connection / ManagedConnection . java < nl > + + + b / library / actor - common / src / main / java / im / actor / model / network / connection / ManagedConnection . java < nl > @ @ - 20 , 7 + 20 , 7 @ @ import im . actor . model . util . CRC32 ; < nl > * / < nl > public class ManagedConnection implements Connection { < nl > < nl > - private static final int CONNECTION _ TIMEOUT = 5 * 1000 ; < nl > + public static final int CONNECTION _ TIMEOUT = 5 * 1000 ; < nl > private static final int HANDSHAKE _ TIMEOUT = 5 * 1000 ; < nl > private static final int RESPONSE _ TIMEOUT = 5 * 1000 ; < nl > private static final int PING _ TIMEOUT = 5 * 60 * 1000 ; < nl > @ @ - 76 , 7 + 76 , 7 @ @ public class ManagedConnection implements Connection { < nl > this . apiMinorVersion = apiMinorVersion ; < nl > this . callback = callback ; < nl > this . factoryCallback = factoryCallback ; < nl > - this . rawConnection = connectionFactory . createConnection ( endpoint , connectionInterface ) ; < nl > + this . rawConnection = connectionFactory . createConnection ( connectionId , endpoint , connectionInterface ) ; < nl > Log . d ( TAG , " Starting connection " ) ; < nl > < nl > handshakeTimeout = new TimerCompat ( new TimeoutRunnable ( ) ) ; < nl > @ @ - 335 , 9 + 335 , 12 @ @ public class ManagedConnection implements Connection { < nl > e . printStackTrace ( ) ; < nl > close ( ) ; < nl > } < nl > + < nl > + Log . w ( TAG , " onRawReceived : end " ) ; < nl > } < nl > < nl > private synchronized void onRawClosed ( ) { < nl > + Log . w ( TAG , " Received closed event " ) ; < nl > close ( ) ; < nl > } < nl > < nl > @ @ - 348 , 6 + 351 , 7 @ @ public class ManagedConnection implements Connection { < nl > } < nl > < nl > private synchronized void rawPost ( int header , byte [ ] data , int offset , int len ) { < nl > + Log . w ( TAG , " rawPost " ) ; < nl > int packageId = sentPackages + + ; < nl > DataOutput dataOutput = new DataOutput ( ) ; < nl > dataOutput . writeInt ( packageId ) ; < nl > @ @ - 371 , 6 + 375 , 7 @ @ public class ManagedConnection implements Connection { < nl > < nl > @ Override < nl > public synchronized void post ( byte [ ] data , int offset , int len ) { < nl > + Log . w ( TAG , " post " ) ; < nl > if ( isClosed ) { < nl > return ; < nl > } < nl > @ @ - 389 , 6 + 394 , 7 @ @ public class ManagedConnection implements Connection { < nl > < nl > @ Override < nl > public synchronized void close ( ) { < nl > + Log . w ( TAG , " close " ) ; < nl > if ( isClosed ) { < nl > return ; < nl > } < nl > diff - - git a / library / actor - js / src / main / java / im / actor / model / js / providers / websocket / WebSocketConnection . java b / library / actor - js / src / main / java / im / actor / model / js / providers / websocket / WebSocketConnection . java < nl > index a768087 . . f9703b6 100644 < nl > - - - a / library / actor - js / src / main / java / im / actor / model / js / providers / websocket / WebSocketConnection . java < nl > + + + b / library / actor - js / src / main / java / im / actor / model / js / providers / websocket / WebSocketConnection . java < nl > @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . model . network . connection . AsyncConnectionInterface ; < nl > public class WebSocketConnection extends AsyncConnection { < nl > < nl > private JavaScriptObject jsWebSocket ; < nl > + private boolean isClosed ; < nl > < nl > public WebSocketConnection ( ConnectionEndpoint endpoint , AsyncConnectionInterface connection ) { < nl > super ( endpoint , connection ) ; < nl > @ @ - 23 , 6 + 24 , 8 @ @ public class WebSocketConnection extends AsyncConnection { < nl > < nl > @ Override < nl > public void doConnect ( ) { < nl > + isClosed = true ; < nl > + < nl > String url ; < nl > if ( getEndpoint ( ) . getType ( ) = = ConnectionEndpoint . Type . WS ) { < nl > url = " ws : / / " + getEndpoint ( ) . getHost ( ) + " : " + getEndpoint ( ) . getPort ( ) + " / " ; < nl > @ @ - 37 , 6 + 40 , 9 @ @ public class WebSocketConnection extends AsyncConnection { < nl > < nl > @ Override < nl > public void doSend ( byte [ ] data ) { < nl > + if ( isClosed ) { < nl > + return ; < nl > + } < nl > Uint8Array push = TypedArrays . createUint8Array ( data . length ) ; < nl > for ( int i = 0 ; i < data . length ; i + + ) { < nl > push . set ( i , data [ i ] ) ; < nl > @ @ - 46 , 10 + 52 , 14 @ @ public class WebSocketConnection extends AsyncConnection { < nl > < nl > @ Override < nl > public void doClose ( ) { < nl > + isClosed = true ; < nl > close ( ) ; < nl > } < nl > < nl > private void onRawMessage ( ArrayBuffer message ) { < nl > + if ( isClosed ) { < nl > + return ; < nl > + } < nl > Uint8Array array = TypedArrays . createUint8Array ( message ) ; < nl > byte [ ] res = new byte [ array . length ( ) ] ; < nl > for ( int i = 0 ; i < res . length ; i + + ) { < nl > @ @ - 60 , 11 + 70 , 13 @ @ public class WebSocketConnection extends AsyncConnection { < nl > < nl > private void onRawConnected ( ) { < nl > Log . d ( " WS " , " Connected " ) ; < nl > + isClosed = false ; < nl > onConnected ( ) ; < nl > } < nl > < nl > private void onRawClosed ( ) { < nl > Log . d ( " WS " , " Closed " ) ; < nl > + isClosed = true ; < nl > onClosed ( ) ; < nl > } < nl > < nl > diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java < nl > index 2cc9e64 . . f1049db 100644 < nl > - - - a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java < nl > + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java < nl > @ @ - 1 , 39 + 1 , 14 @ @ < nl > package im . actor . model . jvm ; < nl > < nl > - import im . actor . model . NetworkProvider ; < nl > - import im . actor . model . network . ConnectionCallback ; < nl > - import im . actor . model . network . ConnectionEndpoint ; < nl > - import im . actor . model . network . CreateConnectionCallback ; < nl > + import im . actor . model . jvm . tcp . AsyncTcpConnectionFactory ; < nl > + import im . actor . model . network . connection . ManagedNetworkProvider ; < nl > < nl > / * * < nl > * Created by ex3ndr on 13 . 04 . 15 . < nl > * / < nl > - public class JavaNetworkProvider implements NetworkProvider { < nl > + public class JavaNetworkProvider extends ManagedNetworkProvider { < nl > < nl > - @ Override < nl > - public void createConnection ( final int connectionId , < nl > - final int mtprotoVersion , < nl > - final int apiMajorVersion , < nl > - final int apiMinorVersion , < nl > - final ConnectionEndpoint endpoint , final ConnectionCallback callback , < nl > - final CreateConnectionCallback createCallback ) { < nl > - new Thread ( ) { < nl > - @ Override < nl > - public void run ( ) { < nl > - try { < nl > - createCallback . onConnectionCreated ( < nl > - new JavaTcpConnection ( < nl > - connectionId , < nl > - mtprotoVersion , < nl > - apiMajorVersion , < nl > - apiMinorVersion , < nl > - endpoint , < nl > - callback ) ) ; < nl > - } catch ( Exception e ) { < nl > - e . printStackTrace ( ) ; < nl > - createCallback . onConnectionCreateError ( ) ; < nl > - } < nl > - } < nl > - } . start ( ) ; < nl > + public JavaNetworkProvider ( ) { < nl > + super ( new AsyncTcpConnectionFactory ( ) ) ; < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaTcpConnection . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaTcpConnection . java < nl > deleted file mode 100644 < nl > index eee1ea8 . . 0000000 < nl > - - - a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaTcpConnection . java < nl > + + + / dev / null < nl > @ @ - 1 , 545 + 0 , 0 @ @ < nl > - package im . actor . model . jvm ; < nl > - < nl > - import java . io . IOException ; < nl > - import java . io . InputStream ; < nl > - import java . io . OutputStream ; < nl > - import java . net . InetSocketAddress ; < nl > - import java . net . Socket ; < nl > - import java . util . Arrays ; < nl > - import java . util . HashMap ; < nl > - import java . util . Random ; < nl > - import java . util . Timer ; < nl > - import java . util . TimerTask ; < nl > - import java . util . concurrent . ConcurrentLinkedQueue ; < nl > - < nl > - import javax . net . ssl . SSLSocketFactory ; < nl > - < nl > - import im . actor . model . crypto . CryptoUtils ; < nl > - import im . actor . model . droidkit . bser . DataInput ; < nl > - import im . actor . model . droidkit . bser . DataOutput ; < nl > - import im . actor . model . log . Log ; < nl > - import im . actor . model . network . Connection ; < nl > - import im . actor . model . network . ConnectionCallback ; < nl > - import im . actor . model . network . ConnectionEndpoint ; < nl > - import im . actor . model . util . CRC32 ; < nl > - < nl > - / * * < nl > - * Created by ex3ndr on 13 . 04 . 15 . < nl > - * / < nl > - public class JavaTcpConnection implements Connection { < nl > - < nl > - private static final int CONNECTION _ TIMEOUT = 5 * 1000 ; < nl > - private static final int HANDSHAKE _ TIMEOUT = 5 * 1000 ; < nl > - private static final int RESPONSE _ TIMEOUT = 5 * 1000 ; < nl > - private static final int PING _ TIMEOUT = 5 * 60 * 1000 ; < nl > - < nl > - private static final int HEADER _ PROTO = 0 ; < nl > - private static final int HEADER _ PING = 1 ; < nl > - private static final int HEADER _ PONG = 2 ; < nl > - private static final int HEADER _ DROP = 3 ; < nl > - private static final int HEADER _ REDIRECT = 4 ; < nl > - private static final int HEADER _ ACK = 6 ; < nl > - < nl > - private static final Random RANDOM = new Random ( ) ; < nl > - private static final Timer DIE _ TIMER = new Timer ( ) ; < nl > - < nl > - private final String TAG ; < nl > - private final ConnectionCallback callback ; < nl > - private final Socket socket ; < nl > - private final InputStream inputStream ; < nl > - private final OutputStream outputStream ; < nl > - private final ReaderThread readerThread ; < nl > - private final WriterThread writerThread ; < nl > - private TimerTask pingTask ; < nl > - private final HashMap < Long , TimerTask > schedulledPings = new HashMap < Long , TimerTask > ( ) ; < nl > - private final HashMap < Integer , TimerTask > packageTimers = new HashMap < Integer , TimerTask > ( ) ; < nl > - < nl > - / / Connection state < nl > - private int sentPackets ; < nl > - private int receivedPackets ; < nl > - private boolean isClosed ; < nl > - < nl > - public JavaTcpConnection ( int id , < nl > - int mtprotoVersion , < nl > - int apiMajorVersion , < nl > - int apiMinorVersion , < nl > - ConnectionEndpoint endpoint , < nl > - ConnectionCallback callback ) throws IOException { < nl > - this . TAG = " Connection # " + id ; < nl > - this . callback = callback ; < nl > - this . isClosed = false ; < nl > - this . sentPackets = 0 ; < nl > - this . receivedPackets = 0 ; < nl > - < nl > - / / Log . d ( TAG , " Creating socket . . . " ) ; < nl > - switch ( endpoint . getType ( ) ) { < nl > - case TCP : < nl > - socket = new Socket ( ) ; < nl > - break ; < nl > - case TCP _ TLS : < nl > - socket = SSLSocketFactory . getDefault ( ) . createSocket ( ) ; < nl > - break ; < nl > - default : < nl > - throw new IOException ( " Unsupported endpoint type : " + endpoint . getType ( ) ) ; < nl > - } < nl > - < nl > - this . socket . setKeepAlive ( false ) ; < nl > - this . socket . setTcpNoDelay ( true ) ; < nl > - < nl > - / / Log . d ( TAG , " Connecting socket . . . " ) ; < nl > - < nl > - this . socket . connect ( new InetSocketAddress ( endpoint . getHost ( ) , endpoint . getPort ( ) ) , CONNECTION _ TIMEOUT ) ; < nl > - < nl > - / / Log . d ( TAG , " Performing handshake . . . " ) ; < nl > - < nl > - / / Init socket streams < nl > - inputStream = this . socket . getInputStream ( ) ; < nl > - outputStream = this . socket . getOutputStream ( ) ; < nl > - < nl > - / / Handshake request < nl > - DataOutput handshakeRequest = new DataOutput ( ) ; < nl > - handshakeRequest . writeByte ( mtprotoVersion ) ; < nl > - handshakeRequest . writeByte ( apiMajorVersion ) ; < nl > - handshakeRequest . writeByte ( apiMinorVersion ) ; < nl > - byte [ ] randomData = new byte [ 32 ] ; < nl > - synchronized ( RANDOM ) { < nl > - RANDOM . nextBytes ( randomData ) ; < nl > - } < nl > - handshakeRequest . writeInt ( randomData . length ) ; < nl > - handshakeRequest . writeBytes ( randomData , 0 , randomData . length ) ; < nl > - outputStream . write ( handshakeRequest . toByteArray ( ) ) ; < nl > - outputStream . flush ( ) ; < nl > - < nl > - / / Log . d ( TAG , " Reading handshake response . . . " ) ; < nl > - / / Handshake response < nl > - socket . setSoTimeout ( HANDSHAKE _ TIMEOUT ) ; < nl > - byte [ ] data = readBytes ( 3 + 32 ) ; < nl > - socket . setSoTimeout ( 0 ) ; < nl > - DataInput handshakeResponse = new DataInput ( data ) ; < nl > - int protoVersion = handshakeResponse . readByte ( ) ; < nl > - int apiMajor = handshakeResponse . readByte ( ) ; < nl > - int apiMinor = handshakeResponse . readByte ( ) ; < nl > - byte [ ] sha256 = handshakeResponse . readBytes ( 32 ) ; < nl > - byte [ ] localSha256 = CryptoUtils . SHA256 ( randomData ) ; < nl > - < nl > - if ( ! Arrays . equals ( sha256 , localSha256 ) ) { < nl > - throw new IOException ( " SHA 256 is incorrect " ) ; < nl > - } < nl > - if ( protoVersion ! = 1 ) { < nl > - throw new IOException ( " Incorrect Proto Version , expected : 1 , got " + protoVersion + " ; " ) ; < nl > - } < nl > - if ( apiMajor ! = 1 ) { < nl > - throw new IOException ( " Incorrect Api Major Version , expected : 1 , got " + apiMajor + " ; " ) ; < nl > - } < nl > - if ( apiMinor ! = 0 ) { < nl > - throw new IOException ( " Incorrect Api Minor Version , expected : 0 , got " + apiMinor + " ; " ) ; < nl > - } < nl > - < nl > - / / Log . d ( TAG , " Handshake completed . " ) ; < nl > - < nl > - readerThread = new ReaderThread ( ) ; < nl > - writerThread = new WriterThread ( ) ; < nl > - readerThread . start ( ) ; < nl > - writerThread . start ( ) ; < nl > - < nl > - pingTask = new PingTask ( ) ; < nl > - DIE _ TIMER . schedule ( pingTask , PING _ TIMEOUT ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public synchronized void post ( byte [ ] data , int offset , int len ) { < nl > - post ( HEADER _ PROTO , data , offset , len ) ; < nl > - } < nl > - < nl > - protected synchronized void post ( int header , byte [ ] data ) { < nl > - post ( header , data , 0 , data . length ) ; < nl > - } < nl > - < nl > - protected synchronized void post ( int header , byte [ ] data , int offset , int len ) { < nl > - writerThread . pushPackage ( new WritePackage ( header , data , offset , len ) ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public synchronized boolean isClosed ( ) { < nl > - return isClosed ; < nl > - } < nl > - < nl > - @ Override < nl > - public synchronized void close ( ) { < nl > - if ( isClosed ) { < nl > - return ; < nl > - } < nl > - isClosed = true ; < nl > - < nl > - try { < nl > - readerThread . interrupt ( ) ; < nl > - } catch ( Exception e ) { < nl > - Log . e ( TAG , e ) ; < nl > - } < nl > - < nl > - try { < nl > - writerThread . interrupt ( ) ; < nl > - } catch ( Exception e ) { < nl > - Log . e ( TAG , e ) ; < nl > - } < nl > - < nl > - try { < nl > - socket . close ( ) ; < nl > - } catch ( IOException e ) { < nl > - Log . e ( TAG , e ) ; < nl > - } < nl > - < nl > - callback . onConnectionDie ( ) ; < nl > - < nl > - synchronized ( packageTimers ) { < nl > - for ( Integer id : packageTimers . keySet ( ) ) { < nl > - packageTimers . get ( id ) . cancel ( ) ; < nl > - } < nl > - for ( Long ping : schedulledPings . keySet ( ) ) { < nl > - schedulledPings . get ( ping ) . cancel ( ) ; < nl > - } < nl > - schedulledPings . clear ( ) ; < nl > - packageTimers . clear ( ) ; < nl > - } < nl > - < nl > - pingTask . cancel ( ) ; < nl > - } < nl > - < nl > - private void onServerAck ( int packageId ) { < nl > - synchronized ( packageTimers ) { < nl > - TimerTask task = packageTimers . remove ( packageId ) ; < nl > - if ( task = = null ) { < nl > - return ; < nl > - } < nl > - task . cancel ( ) ; < nl > - < nl > - refreshTimeouts ( ) ; < nl > - } < nl > - } < nl > - < nl > - private void onServerPong ( long pingId ) { < nl > - synchronized ( packageTimers ) { < nl > - TimerTask task = schedulledPings . remove ( pingId ) ; < nl > - if ( task = = null ) { < nl > - return ; < nl > - } < nl > - task . cancel ( ) ; < nl > - < nl > - refreshTimeouts ( ) ; < nl > - } < nl > - } < nl > - < nl > - private void refreshTimeouts ( ) { < nl > - for ( Long ping : schedulledPings . keySet ( ) . toArray ( new Long [ 0 ] ) ) { < nl > - / / Remove old < nl > - TimerTask oldTask = schedulledPings . remove ( ping ) ; < nl > - oldTask . cancel ( ) ; < nl > - < nl > - / / Add new < nl > - PingTimeoutTask newTask = new PingTimeoutTask ( ping ) ; < nl > - schedulledPings . put ( ping , newTask ) ; < nl > - DIE _ TIMER . schedule ( newTask , RESPONSE _ TIMEOUT ) ; < nl > - } < nl > - for ( Integer id : packageTimers . keySet ( ) . toArray ( new Integer [ 0 ] ) ) { < nl > - / / Remove old < nl > - TimerTask oldTask = packageTimers . get ( id ) ; < nl > - oldTask . cancel ( ) ; < nl > - < nl > - / / Add new < nl > - FrameTimeoutTask newTask = new FrameTimeoutTask ( id ) ; < nl > - packageTimers . put ( id , newTask ) ; < nl > - DIE _ TIMER . schedule ( newTask , RESPONSE _ TIMEOUT ) ; < nl > - } < nl > - < nl > - pingTask . cancel ( ) ; < nl > - < nl > - pingTask = new PingTask ( ) ; < nl > - DIE _ TIMER . schedule ( pingTask , PING _ TIMEOUT ) ; < nl > - } < nl > - < nl > - private class ReaderThread extends Thread { < nl > - < nl > - private final CRC32 crc32Engine = new CRC32 ( ) ; < nl > - < nl > - private ReaderThread ( ) { < nl > - setName ( TAG + " # Reader " + hashCode ( ) ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void run ( ) { < nl > - try { < nl > - while ( ! isClosed ( ) ) { < nl > - if ( socket . isClosed ( ) ) { < nl > - throw new IOException ( " Socket is closed " ) ; < nl > - } < nl > - if ( ! socket . isConnected ( ) ) { < nl > - throw new IOException ( " Socket is not connected " ) ; < nl > - } < nl > - < nl > - / / Reading package headers < nl > - / / Log . d ( TAG , " Waiting for frame header . . . " ) ; < nl > - byte [ ] packageHeader = readBytes ( 9 ) ; < nl > - DataInput dataInput = new DataInput ( packageHeader ) ; < nl > - int receivedPackageIndex = dataInput . readInt ( ) ; < nl > - if ( receivedPackageIndex ! = receivedPackets ) { < nl > - throw new IOException ( " Received frame with incorrect index . " + < nl > - " Expected : " + receivedPackets + " , got : " + receivedPackageIndex ) ; < nl > - } < nl > - receivedPackets + + ; < nl > - int header = dataInput . readByte ( ) ; < nl > - int size = dataInput . readInt ( ) ; < nl > - < nl > - / / Reading package body < nl > - / / Log . d ( TAG , " Reading frame body for # " + receivedPackageIndex ) ; < nl > - byte [ ] body = readBytes ( size + 4 ) ; < nl > - dataInput = new DataInput ( body ) ; < nl > - byte [ ] contents = dataInput . readBytes ( size ) ; < nl > - < nl > - / / Checking CRC32 < nl > - long crc32 = dataInput . readUInt ( ) ; < nl > - crc32Engine . reset ( ) ; < nl > - crc32Engine . update ( contents ) ; < nl > - long localCrc32 = crc32Engine . getValue ( ) ; < nl > - if ( localCrc32 ! = crc32 ) { < nl > - throw new IOException ( " Received frame contents with incorrect crc32 " ) ; < nl > - } < nl > - < nl > - / / Processing package < nl > - if ( header = = HEADER _ PROTO ) { < nl > - / / Log . d ( TAG , " Received proto frame " ) ; < nl > - callback . onMessage ( contents , 0 , contents . length ) ; < nl > - < nl > - DataOutput ackPackage = new DataOutput ( ) ; < nl > - ackPackage . writeInt ( receivedPackageIndex ) ; < nl > - post ( HEADER _ ACK , ackPackage . toByteArray ( ) ) ; < nl > - } else if ( header = = HEADER _ PING ) { < nl > - / / Log . d ( TAG , " Received ping frame " ) ; < nl > - post ( HEADER _ PONG , contents ) ; < nl > - } else if ( header = = HEADER _ PONG ) { < nl > - / / Log . d ( TAG , " Received pong frame " ) ; < nl > - DataInput pongInput = new DataInput ( contents ) ; < nl > - int pongLen = pongInput . readInt ( ) ; < nl > - if ( pongLen ! = 8 ) { < nl > - / / Log . w ( TAG , " Pong invalid content length , got : " + pongLen ) ; < nl > - continue ; < nl > - } < nl > - onServerPong ( pongInput . readLong ( ) ) ; < nl > - } else if ( header = = HEADER _ ACK ) { < nl > - / / Log . d ( TAG , " Received ack frame " ) ; < nl > - DataInput ackContent = new DataInput ( contents ) ; < nl > - int frameId = ackContent . readInt ( ) ; < nl > - onServerAck ( frameId ) ; < nl > - } else if ( header = = HEADER _ REDIRECT ) { < nl > - DataInput redirectContent = new DataInput ( contents ) ; < nl > - int hostLen = redirectContent . readInt ( ) ; < nl > - String host = new String ( redirectContent . readBytes ( hostLen ) , " UTF - 8 " ) ; < nl > - int port = redirectContent . readInt ( ) ; < nl > - int timeout = redirectContent . readInt ( ) ; < nl > - / / TODO : Implement redirect < nl > - throw new IOException ( " Received redirect frame : " + host + " : " + port + " with timeout " + timeout + " sec " ) ; < nl > - } else if ( header = = HEADER _ DROP ) { < nl > - DataInput drop = new DataInput ( contents ) ; < nl > - long messageId = drop . readLong ( ) ; < nl > - int errorCode = drop . readByte ( ) ; < nl > - int messageLen = drop . readInt ( ) ; < nl > - String message = new String ( drop . readBytes ( messageLen ) , " UTF - 8 " ) ; < nl > - / / Log . d ( TAG , " Received drop frame : " + message ) ; < nl > - < nl > - throw new IOException ( " Received drop frame : " + message ) ; < nl > - } else { < nl > - Log . w ( TAG , " Received unknown frame # " + header ) ; < nl > - } < nl > - } < nl > - } catch ( IOException e ) { < nl > - e . printStackTrace ( ) ; < nl > - close ( ) ; < nl > - } < nl > - } < nl > - } < nl > - < nl > - / * * < nl > - * Package send thread < nl > - * / < nl > - private class WriterThread extends Thread { < nl > - < nl > - private final CRC32 crc32Engine = new CRC32 ( ) ; < nl > - < nl > - private final ConcurrentLinkedQueue < WritePackage > packages = new ConcurrentLinkedQueue < WritePackage > ( ) ; < nl > - < nl > - public WriterThread ( ) { < nl > - setName ( TAG + " # Writer " + hashCode ( ) ) ; < nl > - } < nl > - < nl > - / * * < nl > - * Send package to connection < nl > - * < nl > - * @ param p package < nl > - * / < nl > - public void pushPackage ( final WritePackage p ) { < nl > - packages . add ( p ) ; < nl > - synchronized ( packages ) { < nl > - packages . notifyAll ( ) ; < nl > - } < nl > - } < nl > - < nl > - @ Override < nl > - public void run ( ) { < nl > - try { < nl > - while ( ! isClosed ( ) ) { < nl > - < nl > - / / Pooling of package from queue < nl > - WritePackage p ; < nl > - synchronized ( packages ) { < nl > - p = packages . poll ( ) ; < nl > - if ( p = = null ) { < nl > - try { < nl > - packages . wait ( ) ; < nl > - } catch ( final InterruptedException e ) { < nl > - return ; < nl > - } < nl > - p = packages . poll ( ) ; < nl > - } < nl > - } < nl > - if ( p = = null ) { < nl > - continue ; < nl > - } < nl > - < nl > - / / Start package send < nl > - / / Log . d ( TAG , " Sending frame # " + sentPackets ) ; < nl > - < nl > - / / Prepare package < nl > - final int packageId = sentPackets + + ; < nl > - DataOutput dataOutput = new DataOutput ( ) ; < nl > - dataOutput . writeInt ( packageId ) ; < nl > - dataOutput . writeByte ( p . getHeader ( ) ) ; < nl > - dataOutput . writeInt ( p . getContent ( ) . length ) ; < nl > - dataOutput . writeBytes ( p . getContent ( ) , p . getOffset ( ) , p . getLen ( ) ) ; < nl > - crc32Engine . reset ( ) ; < nl > - crc32Engine . update ( p . getContent ( ) , p . getOffset ( ) , p . getLen ( ) ) ; < nl > - dataOutput . writeInt ( ( int ) crc32Engine . getValue ( ) ) ; < nl > - byte [ ] destPackage = dataOutput . toByteArray ( ) ; < nl > - < nl > - / / Setting Ack timeout < nl > - if ( p . getHeader ( ) = = HEADER _ PROTO ) { < nl > - synchronized ( packageTimers ) { < nl > - TimerTask timeoutTask = new TimerTask ( ) { < nl > - @ Override < nl > - public void run ( ) { < nl > - / / Log . d ( TAG , " Response # " + packageId + " not received in time " ) ; < nl > - close ( ) ; < nl > - } < nl > - } ; < nl > - packageTimers . put ( packageId , timeoutTask ) ; < nl > - DIE _ TIMER . schedule ( timeoutTask , RESPONSE _ TIMEOUT ) ; < nl > - } < nl > - } < nl > - < nl > - / / Writing package to socket < nl > - outputStream . write ( destPackage ) ; < nl > - outputStream . flush ( ) ; < nl > - } < nl > - } catch ( IOException e ) { < nl > - e . printStackTrace ( ) ; < nl > - close ( ) ; < nl > - } < nl > - } < nl > - } < nl > - < nl > - private class WritePackage { < nl > - private int header ; < nl > - private byte [ ] content ; < nl > - private int offset ; < nl > - private int len ; < nl > - < nl > - private WritePackage ( int header , byte [ ] content , int offset , int len ) { < nl > - this . header = header ; < nl > - this . content = content ; < nl > - this . offset = offset ; < nl > - this . len = len ; < nl > - } < nl > - < nl > - public int getHeader ( ) { < nl > - return header ; < nl > - } < nl > - < nl > - public byte [ ] getContent ( ) { < nl > - return content ; < nl > - } < nl > - < nl > - public int getOffset ( ) { < nl > - return offset ; < nl > - } < nl > - < nl > - public int getLen ( ) { < nl > - return len ; < nl > - } < nl > - } < nl > - < nl > - class PingTimeoutTask extends TimerTask { < nl > - private long pingId ; < nl > - < nl > - public PingTimeoutTask ( long pingId ) { < nl > - this . pingId = pingId ; < nl > - } < nl > - < nl > - @ Override < nl > - public void run ( ) { < nl > - / / Log . d ( TAG , " Ping # " + pingId + " is timed out " ) ; < nl > - close ( ) ; < nl > - } < nl > - } < nl > - < nl > - class FrameTimeoutTask extends TimerTask { < nl > - private int frameId ; < nl > - < nl > - FrameTimeoutTask ( int frameId ) { < nl > - this . frameId = frameId ; < nl > - } < nl > - < nl > - @ Override < nl > - public void run ( ) { < nl > - / / Log . d ( TAG , " Response # " + frameId + " not received in time " ) ; < nl > - close ( ) ; < nl > - } < nl > - } < nl > - < nl > - class PingTask extends TimerTask { < nl > - @ Override < nl > - public void run ( ) { < nl > - if ( isClosed ( ) ) { < nl > - return ; < nl > - } < nl > - final long pingId = RANDOM . nextLong ( ) ; < nl > - DataOutput dataOutput = new DataOutput ( ) ; < nl > - dataOutput . writeInt ( 8 ) ; < nl > - synchronized ( RANDOM ) { < nl > - dataOutput . writeLong ( pingId ) ; < nl > - } < nl > - < nl > - PingTimeoutTask pingTimeout = new PingTimeoutTask ( pingId ) ; < nl > - synchronized ( packageTimers ) { < nl > - schedulledPings . put ( pingId , pingTimeout ) ; < nl > - } < nl > - DIE _ TIMER . schedule ( pingTimeout , RESPONSE _ TIMEOUT ) ; < nl > - < nl > - / / Log . d ( TAG , " Performing ping # " + pingId + " . . . " ) ; < nl > - post ( HEADER _ PING , dataOutput . toByteArray ( ) ) ; < nl > - } < nl > - } < nl > - < nl > - private byte [ ] readBytes ( int count ) throws IOException { < nl > - byte [ ] res = new byte [ count ] ; < nl > - int offset = 0 ; < nl > - while ( offset < res . length ) { < nl > - int readed = inputStream . read ( res , offset , res . length - offset ) ; < nl > - if ( readed > 0 ) { < nl > - offset + = readed ; < nl > - } else if ( readed < 0 ) { < nl > - throw new IOException ( ) ; < nl > - } else { < nl > - Thread . yield ( ) ; < nl > - } < nl > - } < nl > - return res ; < nl > - } < nl > - } < nl > diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnection . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnection . java < nl > new file mode 100644 < nl > index 0000000 . . fcdd41c < nl > - - - / dev / null < nl > + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnection . java < nl > @ @ - 0 , 0 + 1 , 271 @ @ < nl > + package im . actor . model . jvm . tcp ; < nl > + < nl > + import java . io . IOException ; < nl > + import java . io . InputStream ; < nl > + import java . io . OutputStream ; < nl > + import java . net . InetSocketAddress ; < nl > + import java . net . Socket ; < nl > + import java . util . concurrent . ConcurrentLinkedQueue ; < nl > + import java . util . concurrent . ExecutorService ; < nl > + import java . util . concurrent . Executors ; < nl > + < nl > + import javax . net . ssl . SSLSocketFactory ; < nl > + < nl > + import im . actor . model . droidkit . bser . DataInput ; < nl > + import im . actor . model . droidkit . bser . DataOutput ; < nl > + import im . actor . model . log . Log ; < nl > + import im . actor . model . network . ConnectionEndpoint ; < nl > + import im . actor . model . network . connection . AsyncConnection ; < nl > + import im . actor . model . network . connection . AsyncConnectionInterface ; < nl > + import im . actor . model . network . connection . ManagedConnection ; < nl > + < nl > + / * * < nl > + * Created by ex3ndr on 01 . 05 . 15 . < nl > + * / < nl > + public class AsyncTcpConnection extends AsyncConnection { < nl > + < nl > + private final ExecutorService connectExecutor = Executors . newSingleThreadExecutor ( ) ; < nl > + < nl > + private final String TAG ; < nl > + < nl > + private Socket socket ; < nl > + private InputStream inputStream ; < nl > + private OutputStream outputStream ; < nl > + private WriterThread writerThread ; < nl > + private ReaderThread readerThread ; < nl > + < nl > + private boolean isConnected = false ; < nl > + private boolean isClosed = false ; < nl > + < nl > + public AsyncTcpConnection ( int id , ConnectionEndpoint endpoint , AsyncConnectionInterface connection ) { < nl > + super ( endpoint , connection ) ; < nl > + < nl > + this . TAG = " ConnectionTcp # " + id ; < nl > + } < nl > + < nl > + @ Override < nl > + public void doConnect ( ) { < nl > + connectExecutor . submit ( new Runnable ( ) { < nl > + @ Override < nl > + public void run ( ) { < nl > + try { < nl > + Socket socket ; < nl > + ConnectionEndpoint endpoint = getEndpoint ( ) ; < nl > + switch ( endpoint . getType ( ) ) { < nl > + case TCP : < nl > + socket = new Socket ( ) ; < nl > + break ; < nl > + case TCP _ TLS : < nl > + socket = SSLSocketFactory . getDefault ( ) . createSocket ( ) ; < nl > + break ; < nl > + default : < nl > + throw new RuntimeException ( " Unsupported endpoint type : " + endpoint . getType ( ) ) ; < nl > + } < nl > + < nl > + / / Configure socket < nl > + socket . setKeepAlive ( false ) ; < nl > + socket . setTcpNoDelay ( true ) ; < nl > + < nl > + socket . connect ( new InetSocketAddress ( endpoint . getHost ( ) , endpoint . getPort ( ) ) , ManagedConnection . CONNECTION _ TIMEOUT ) ; < nl > + < nl > + / / Init streams < nl > + socket . getInputStream ( ) ; < nl > + socket . getOutputStream ( ) ; < nl > + < nl > + onSocketCreated ( socket ) ; < nl > + } catch ( Exception e ) { < nl > + e . printStackTrace ( ) ; < nl > + crashConnection ( ) ; < nl > + } < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void doSend ( byte [ ] data ) { < nl > + writerThread . pushPackage ( data ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void doClose ( ) { < nl > + crashConnection ( ) ; < nl > + } < nl > + < nl > + < nl > + private synchronized void onSocketCreated ( Socket socket ) throws IOException { < nl > + if ( isClosed ) { < nl > + Log . w ( TAG , " Socket created after external close : disposing " ) ; < nl > + throw new IOException ( " Socket created after external close : disposing " ) ; < nl > + } < nl > + < nl > + this . socket = socket ; < nl > + this . inputStream = socket . getInputStream ( ) ; < nl > + this . outputStream = socket . getOutputStream ( ) ; < nl > + < nl > + this . isClosed = false ; < nl > + this . isConnected = true ; < nl > + < nl > + this . readerThread = new ReaderThread ( ) ; < nl > + this . readerThread . start ( ) ; < nl > + < nl > + this . writerThread = new WriterThread ( ) ; < nl > + this . writerThread . start ( ) ; < nl > + < nl > + onConnected ( ) ; < nl > + } < nl > + < nl > + private synchronized void onRawReceived ( byte [ ] data ) throws IOException { < nl > + if ( ! isConnected ) { < nl > + Log . d ( TAG , " onRawReceived : Not connected " ) ; < nl > + return ; < nl > + } < nl > + < nl > + onReceived ( data ) ; < nl > + } < nl > + < nl > + private synchronized void crashConnection ( ) { < nl > + Log . d ( TAG , " Crashing Connection " ) ; < nl > + < nl > + if ( isClosed ) { < nl > + return ; < nl > + } < nl > + isClosed = true ; < nl > + isConnected = false ; < nl > + < nl > + if ( writerThread ! = null ) { < nl > + writerThread . interrupt ( ) ; < nl > + } < nl > + if ( readerThread ! = null ) { < nl > + readerThread . interrupt ( ) ; < nl > + } < nl > + writerThread = null ; < nl > + readerThread = null ; < nl > + < nl > + if ( socket ! = null ) { < nl > + try { < nl > + socket . close ( ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + } < nl > + } < nl > + if ( inputStream ! = null ) { < nl > + try { < nl > + inputStream . close ( ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + } < nl > + } < nl > + if ( outputStream ! = null ) { < nl > + try { < nl > + outputStream . close ( ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + } < nl > + } < nl > + socket = null ; < nl > + inputStream = null ; < nl > + outputStream = null ; < nl > + < nl > + onClosed ( ) ; < nl > + } < nl > + < nl > + < nl > + private class WriterThread extends Thread { < nl > + private final ConcurrentLinkedQueue < byte [ ] > packages = new ConcurrentLinkedQueue < byte [ ] > ( ) ; < nl > + < nl > + public WriterThread ( ) { < nl > + setName ( TAG + " # Writer " ) ; < nl > + } < nl > + < nl > + / * * < nl > + * Send package to connection < nl > + * < nl > + * @ param p package < nl > + * / < nl > + public void pushPackage ( final byte [ ] p ) { < nl > + packages . add ( p ) ; < nl > + synchronized ( packages ) { < nl > + packages . notifyAll ( ) ; < nl > + } < nl > + } < nl > + < nl > + @ Override < nl > + public void run ( ) { < nl > + try { < nl > + while ( isConnected ) { < nl > + < nl > + / / Pooling of package from queue < nl > + byte [ ] p ; < nl > + synchronized ( packages ) { < nl > + p = packages . poll ( ) ; < nl > + if ( p = = null ) { < nl > + try { < nl > + packages . wait ( ) ; < nl > + } catch ( final InterruptedException e ) { < nl > + return ; < nl > + } < nl > + p = packages . poll ( ) ; < nl > + } < nl > + } < nl > + if ( p = = null ) { < nl > + continue ; < nl > + } < nl > + < nl > + outputStream . write ( p ) ; < nl > + outputStream . flush ( ) ; < nl > + } < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + crashConnection ( ) ; < nl > + } < nl > + } < nl > + } < nl > + < nl > + private class ReaderThread extends Thread { < nl > + < nl > + private ReaderThread ( ) { < nl > + setName ( TAG + " # Reader " ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void run ( ) { < nl > + try { < nl > + while ( isConnected ) { < nl > + / / Reading package headers < nl > + byte [ ] header = readBytes ( 9 ) ; < nl > + DataInput dataInput = new DataInput ( header ) ; < nl > + int receivedPackageIndex = dataInput . readInt ( ) ; < nl > + int headerValue = dataInput . readByte ( ) ; < nl > + int size = dataInput . readInt ( ) ; < nl > + < nl > + / / Reading package body < nl > + byte [ ] body = readBytes ( size + 4 ) ; < nl > + < nl > + DataOutput dataOutput = new DataOutput ( ) ; < nl > + dataOutput . writeBytes ( header ) ; < nl > + dataOutput . writeBytes ( body ) ; < nl > + onRawReceived ( dataOutput . toByteArray ( ) ) ; < nl > + } < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + crashConnection ( ) ; < nl > + } < nl > + } < nl > + < nl > + private byte [ ] readBytes ( int count ) throws IOException { < nl > + byte [ ] res = new byte [ count ] ; < nl > + int offset = 0 ; < nl > + while ( offset < res . length ) { < nl > + int readed = inputStream . read ( res , offset , res . length - offset ) ; < nl > + if ( readed > 0 ) { < nl > + offset + = readed ; < nl > + } else if ( readed < 0 ) { < nl > + throw new IOException ( ) ; < nl > + } else { < nl > + Thread . yield ( ) ; < nl > + } < nl > + } < nl > + return res ; < nl > + } < nl > + } < nl > + } < nl > diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnectionFactory . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnectionFactory . java < nl > new file mode 100644 < nl > index 0000000 . . f1eff48 < nl > - - - / dev / null < nl > + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnectionFactory . java < nl > @ @ - 0 , 0 + 1 , 17 @ @ < nl > + package im . actor . model . jvm . tcp ; < nl > + < nl > + import im . actor . model . network . ConnectionEndpoint ; < nl > + import im . actor . model . network . connection . AsyncConnection ; < nl > + import im . actor . model . network . connection . AsyncConnectionFactory ; < nl > + import im . actor . model . network . connection . AsyncConnectionInterface ; < nl > + < nl > + / * * < nl > + * Created by ex3ndr on 01 . 05 . 15 . < nl > + * / < nl > + public class AsyncTcpConnectionFactory implements AsyncConnectionFactory { < nl > + < nl > + @ Override < nl > + public AsyncConnection createConnection ( int connectionId , ConnectionEndpoint endpoint , AsyncConnectionInterface connectionInterface ) { < nl > + return new AsyncTcpConnection ( connectionId , endpoint , connectionInterface ) ; < nl > + } < nl > + }

TEST DIFF:
diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcIndexStorageTest . java b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcIndexStorageTest . java 
 new file mode 100644 
 index 0000000 . . 8144355 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcIndexStorageTest . java 
 @ @ - 0 , 0 + 1 , 192 @ @ 
 + package im . actor . runtime . clc ; 
 + 
 + import static org . junit . Assert . * ; 
 + import static org . hamcrest . CoreMatchers . * ; 
 + 
 + import im . actor . runtime . StorageRuntimeProvider ; 
 + import im . actor . runtime . storage . IndexStorage ; 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Test ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . List ; 
 + 
 + / * * 
 + * Created by amir on 4 / 12 / 16 . 
 + * / 
 + public class ClcIndexStorageTest { 
 + 
 + private StorageRuntimeProvider srp ; 
 + private IndexStorage is ; 
 + 
 + @ Before 
 + public void initialize ( ) { 
 + System . out . println ( " before " ) ; 
 + srp = new StorageRuntimeProvider ( ) ; 
 + / / create test table 
 + is = srp . createIndex ( " test " ) ; 
 + } 
 + 
 + @ Test 
 + public void get ( ) { 
 + assertNull ( is . get ( 0 ) ) ; 
 + 
 + } 
 + 
 + 
 + @ Test 
 + public void getWithContext ( ) { 
 + is . put ( 1 , 20 ) ; 
 + srp . setContext ( " 935 " ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + is . put ( 1 , 30 ) ; 
 + assertEquals ( is . get ( 1 ) , new Long ( 30 ) ) ; 
 + 
 + srp . setContext ( null ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + assertEquals ( is . get ( 1 ) , new Long ( 20 ) ) ; 
 + } 
 + @ Test 
 + public void put ( ) { 
 + is . put ( 123 , 456 ) ; 
 + assertEquals ( is . get ( 123 ) , new Long ( 456 ) ) ; 
 + 
 + is . put ( 3 , 30 ) ; 
 + is . put ( 4 , 30 ) ; 
 + assertEquals ( is . get ( 3 ) , new Long ( 30 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void putWithContext ( ) { 
 + is . put ( 1 , 10 ) ; 
 + is . put ( 2 , 20 ) ; 
 + srp . setContext ( " 935 " ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + is . put ( 3 , 30 ) ; 
 + is . put ( 4 , 40 ) ; 
 + assertNull ( is . get ( 1 ) ) ; 
 + assertNull ( is . get ( 2 ) ) ; 
 + assertNotNull ( is . get ( 3 ) ) ; 
 + is . put ( 1 , 50 ) ; 
 + is . put ( 2 , 50 ) ; 
 + 
 + / / test the effect of context ( id and context are primary keys ) 
 + assertEquals ( ( ( ClcIndexStorage ) is ) . countAll ( ) , 6 ) ; 
 + } 
 + 
 + @ Test 
 + public void findBeforeValue ( ) { 
 + is . put ( 1 , 10 ) ; 
 + is . put ( 2 , 10 ) ; 
 + is . put ( 3 , 20 ) ; 
 + List < Long > actual = is . findBeforeValue ( 10 ) ; 
 + List < Long > expected = Arrays . asList ( 1L , 2L ) ; 
 + assertThat ( actual , is ( expected ) ) ; 
 + } 
 + 
 + @ Test 
 + public void findBeforeValueWithContext ( ) { 
 + is . put ( 1 , 10 ) ; 
 + is . put ( 2 , 10 ) ; 
 + srp . setContext ( " 936 " ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + is . put ( 3 , 10 ) ; 
 + is . put ( 4 , 10 ) ; 
 + List < Long > actual = is . findBeforeValue ( 10 ) ; 
 + List < Long > expected = Arrays . asList ( 3L , 4L ) ; 
 + assertThat ( actual , is ( expected ) ) ; 
 + srp . setContext ( null ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + actual = is . findBeforeValue ( 10 ) ; 
 + expected = Arrays . asList ( 1L , 2L ) ; 
 + assertThat ( actual , is ( expected ) ) ; 
 + } 
 + 
 + @ Test 
 + public void remove ( ) { 
 + is . put ( 1 , 10 ) ; 
 + is . remove ( 1 ) ; 
 + assertNull ( is . get ( 1 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void removeWithContext ( ) { 
 + is . put ( 1 , 10 ) ; 
 + is . put ( 2 , 20 ) ; 
 + srp . setContext ( " 935 " ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + is . put ( 1 , 30 ) ; 
 + is . put ( 2 , 40 ) ; 
 + is . remove ( 1 ) ; 
 + assertNull ( is . get ( 1 ) ) ; 
 + srp . setContext ( null ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + assertEquals ( is . get ( 1 ) , new Long ( 10 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void removeList ( ) { 
 + is . put ( 1 , 10 ) ; 
 + is . put ( 2 , 10 ) ; 
 + is . put ( 3 , 10 ) ; 
 + is . remove ( Arrays . asList ( 1L , 2L , 3L ) ) ; 
 + assertNull ( is . get ( 1 ) ) ; 
 + assertNull ( is . get ( 2 ) ) ; 
 + assertNull ( is . get ( 3 ) ) ; 
 + } 
 + 
 + 
 + @ Test 
 + public void removeBeforeValue ( ) { 
 + is . put ( 1 , 10 ) ; 
 + is . put ( 2 , 10 ) ; 
 + is . put ( 3 , 20 ) ; 
 + is . removeBeforeValue ( 10 ) ; 
 + assertNull ( is . get ( 1 ) ) ; 
 + assertNull ( is . get ( 2 ) ) ; 
 + assertEquals ( is . get ( 3 ) , new Long ( 20 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void getCount ( ) { 
 + is . put ( 1 , 10 ) ; 
 + is . put ( 2 , 10 ) ; 
 + is . put ( 3 , 20 ) ; 
 + assertEquals ( is . getCount ( ) , 3 ) ; 
 + } 
 + 
 + @ Test 
 + public void getCountWithContext ( ) { 
 + srp . setContext ( " 935 " ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + is . put ( 1 , 10 ) ; 
 + is . put ( 2 , 10 ) ; 
 + assertEquals ( is . getCount ( ) , 2 ) ; 
 + 
 + srp . setContext ( null ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + is . put ( 3 , 20 ) ; 
 + is . put ( 4 , 40 ) ; 
 + is . put ( 5 , 40 ) ; 
 + assertEquals ( is . getCount ( ) , 3 ) ; 
 + 
 + srp . setContext ( " 935 " ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + assertEquals ( is . getCount ( ) , 2 ) ; 
 + 
 + srp . setContext ( " 936 " ) ; 
 + is = srp . createIndex ( " test " ) ; 
 + is . put ( 1 , 10 ) ; 
 + assertEquals ( is . getCount ( ) , 1 ) ; 
 + 
 + } 
 + 
 + @ After 
 + public void finalize ( ) { 
 + System . out . println ( " after " ) ; 
 + srp . setContext ( null ) ; 
 + / / remove all records 
 + ( ( ClcIndexStorage ) is ) . clearAll ( ) ; 
 + } 
 + } 
 diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcJavaPreferenceStorageTest . java b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcJavaPreferenceStorageTest . java 
 new file mode 100644 
 index 0000000 . . 78426da 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcJavaPreferenceStorageTest . java 
 @ @ - 0 , 0 + 1 , 38 @ @ 
 + package im . actor . runtime . clc ; 
 + 
 + import im . actor . runtime . storage . PreferencesStorage ; 
 + import org . junit . Test ; 
 + 
 + import static junit . framework . TestCase . assertEquals ; 
 + 
 + / * * 
 + * Created by amir on 3 / 14 / 16 . 
 + * / 
 + public class ClcJavaPreferenceStorageTest { 
 + @ Test 
 + public void getString ( ) { 
 + PreferencesStorage pref = new ClcJavaPreferenceStorage ( ) ; 
 + pref . putString ( " key " , " string " ) ; 
 + / / assertEquals ( " string " , pref . getString ( " key " ) ) ; 
 + } 
 + 
 + @ Test 
 + public void getLong ( ) { 
 + PreferencesStorage pref = new ClcJavaPreferenceStorage ( ) ; 
 + pref . putLong ( " key " , 1 ) ; 
 + / / assertEquals ( 1 , pref . getLong ( " key " , 0 ) ) ; 
 + / / assertEquals ( 0 , pref . getLong ( " nokey " , 0 ) ) ; 
 + } 
 + 
 + 
 + @ Test 
 + public void getBytes ( ) { 
 + PreferencesStorage pref = new ClcJavaPreferenceStorage ( ) ; 
 + pref . putBytes ( " key " , new byte [ ] { 1 , 2 , 3 } ) ; 
 + byte [ ] arr = pref . getBytes ( " key " ) ; 
 + / / assertEquals ( ( byte ) 1 , arr [ 0 ] ) ; 
 + / / assertEquals ( ( byte ) 2 , arr [ 1 ] ) ; 
 + / / assertEquals ( ( byte ) 3 , arr [ 2 ] ) ; 
 + } 
 + 
 + } 
 diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcKeyValueStorageTest . java b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcKeyValueStorageTest . java 
 new file mode 100644 
 index 0000000 . . 9019f49 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcKeyValueStorageTest . java 
 @ @ - 0 , 0 + 1 , 186 @ @ 
 + package im . actor . runtime . clc ; 
 + 
 + import im . actor . runtime . StorageRuntimeProvider ; 
 + import im . actor . runtime . storage . IndexStorage ; 
 + import im . actor . runtime . storage . KeyValueEngine ; 
 + import im . actor . runtime . storage . KeyValueRecord ; 
 + import im . actor . runtime . storage . KeyValueStorage ; 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Test ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . List ; 
 + 
 + import static org . hamcrest . CoreMatchers . is ; 
 + import static org . junit . Assert . * ; 
 + 
 + / * * 
 + * Created by amir on 4 / 12 / 16 . 
 + * / 
 + public class ClcKeyValueStorageTest { 
 + 
 + private StorageRuntimeProvider srp ; 
 + private KeyValueStorage kvs ; 
 + 
 + @ Before 
 + public void initialize ( ) { 
 + srp = new StorageRuntimeProvider ( ) ; 
 + / / create test table 
 + kvs = srp . createKeyValue ( " test " ) ; 
 + } 
 + 
 + 
 + @ Test 
 + public void loadItem ( ) { 
 + assertNull ( kvs . loadItem ( 0 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void loadItemWithContext ( ) { 
 + kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; 
 + kvs . addOrUpdateItem ( 2 , " value2 " . getBytes ( ) ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + 
 + srp . setContext ( " 935 " ) ; 
 + kvs = srp . createKeyValue ( " test " ) ; 
 + kvs . addOrUpdateItem ( 3 , " value3 " . getBytes ( ) ) ; 
 + kvs . addOrUpdateItem ( 4 , " value4 " . getBytes ( ) ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 3 ) ) , " value3 " ) ; 
 + assertNull ( kvs . loadItem ( 1 ) ) ; 
 + assertNull ( kvs . loadItem ( 2 ) ) ; 
 + 
 + srp . setContext ( null ) ; 
 + kvs = srp . createKeyValue ( " test " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + 
 + } 
 + 
 + 
 + 
 + 
 + @ Test 
 + public void addOrUpdateItem ( ) { 
 + / / insert 
 + kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + 
 + / / update 
 + kvs . addOrUpdateItem ( 1 , " value2 " . getBytes ( ) ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value2 " ) ; 
 + } 
 + 
 + 
 + @ Test 
 + public void addOrUpdateItems ( ) { 
 + / / insert 
 + List keyValues = Arrays . asList ( 
 + new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , 
 + new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; 
 + kvs . addOrUpdateItems ( keyValues ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + 
 + / / update 
 + keyValues = Arrays . asList ( 
 + new KeyValueRecord ( 1 , " value3 " . getBytes ( ) ) , 
 + new KeyValueRecord ( 2 , " value4 " . getBytes ( ) ) ) ; 
 + kvs . addOrUpdateItems ( keyValues ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value3 " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value4 " ) ; 
 + } 
 + 
 + @ Test 
 + public void removeItem ( ) { 
 + kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + kvs . removeItem ( 1 ) ; 
 + assertNull ( kvs . loadItem ( 1 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void removeItemWithContext ( ) { 
 + kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + 
 + srp . setContext ( " 935 " ) ; 
 + kvs = srp . createKeyValue ( " test " ) ; 
 + kvs . addOrUpdateItem ( 1 , " value2 " . getBytes ( ) ) ; 
 + kvs . removeItem ( 1 ) ; 
 + assertNull ( kvs . loadItem ( 1 ) ) ; 
 + 
 + srp . setContext ( null ) ; 
 + kvs = srp . createKeyValue ( " test " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + } 
 + 
 + @ Test 
 + public void removeItems ( ) { 
 + List keyValues = Arrays . asList ( 
 + new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , 
 + new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; 
 + kvs . addOrUpdateItems ( keyValues ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + 
 + kvs . removeItems ( new long [ ] { 1 , 2 } ) ; 
 + assertNull ( kvs . loadItem ( 1 ) ) ; 
 + assertNull ( kvs . loadItem ( 2 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void clear ( ) { 
 + List keyValues = Arrays . asList ( 
 + new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , 
 + new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; 
 + kvs . addOrUpdateItems ( keyValues ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + 
 + kvs . clear ( ) ; 
 + assertNull ( kvs . loadItem ( 1 ) ) ; 
 + assertNull ( kvs . loadItem ( 2 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void clearWithContext ( ) { 
 + List keyValues = Arrays . asList ( 
 + new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , 
 + new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; 
 + kvs . addOrUpdateItems ( keyValues ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + 
 + srp . setContext ( " 935 " ) ; 
 + kvs = srp . createKeyValue ( " test " ) ; 
 + assertNull ( kvs . loadItem ( 1 ) ) ; 
 + assertNull ( kvs . loadItem ( 2 ) ) ; 
 + 
 + List keyValues2 = Arrays . asList ( 
 + new KeyValueRecord ( 3 , " value3 " . getBytes ( ) ) , 
 + new KeyValueRecord ( 4 , " value4 " . getBytes ( ) ) ) ; 
 + kvs . addOrUpdateItems ( keyValues2 ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 3 ) ) , " value3 " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 4 ) ) , " value4 " ) ; 
 + kvs . clear ( ) ; 
 + assertNull ( kvs . loadItem ( 3 ) ) ; 
 + assertNull ( kvs . loadItem ( 4 ) ) ; 
 + 
 + srp . setContext ( null ) ; 
 + kvs = srp . createKeyValue ( " test " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + 
 + } 
 + 
 + 
 + 
 + @ After 
 + public void finalize ( ) { 
 + srp . setContext ( null ) ; 
 + / / remove all records 
 + ( ( ClcKeyValueStorage ) kvs ) . clearAll ( ) ; 
 + } 
 + } 
 diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcListStorageTest . java b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcListStorageTest . java 
 new file mode 100644 
 index 0000000 . . 2b10fae 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core - clc / app - clc / src / test / java / im / actor / runtime / clc / ClcListStorageTest . java 
 @ @ - 0 , 0 + 1 , 223 @ @ 
 + package im . actor . runtime . clc ; 
 + 
 + import im . actor . runtime . StorageRuntimeProvider ; 
 + import im . actor . runtime . storage . * ; 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Test ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . List ; 
 + 
 + import static org . junit . Assert . * ; 
 + 
 + / * * 
 + * Created by amir on 4 / 12 / 16 . 
 + * / 
 + public class ClcListStorageTest { 
 + 
 + private StorageRuntimeProvider srp ; 
 + private ListStorage ls ; 
 + 
 + @ Before 
 + public void initialize ( ) { 
 + srp = new StorageRuntimeProvider ( ) ; 
 + / / create test table 
 + ls = srp . createList ( " test " ) ; 
 + } 
 + 
 + 
 + @ Test 
 + public void loadItem ( ) { 
 + assertNull ( ls . loadItem ( 0 ) ) ; 
 + } 
 + 
 + / / @ Test 
 + / / public void loadItemWithContext ( ) { 
 + / / ls . updateOrAdd ( 1 , " value1 " . getBytes ( ) ) ; 
 + / / ls . updateOrAdd ( 2 , " value2 " . getBytes ( ) ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + / / 
 + / / srp . setContext ( " 935 " ) ; 
 + / / ls = srp . createKeyValue ( " test " ) ; 
 + / / ls . addOrUpdateItem ( 3 , " value3 " . getBytes ( ) ) ; 
 + / / ls . addOrUpdateItem ( 4 , " value4 " . getBytes ( ) ) ; 
 + / / assertEquals ( new String ( ls . loadItem ( 3 ) ) , " value3 " ) ; 
 + / / assertNull ( ls . loadItem ( 1 ) ) ; 
 + / / assertNull ( ls . loadItem ( 2 ) ) ; 
 + / / 
 + / / srp . setContext ( null ) ; 
 + / / kvs = srp . createKeyValue ( " test " ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + / / 
 + / / } 
 + 
 + 
 + private void assertEqualLER ( ListEngineRecord actualLer , ListEngineRecord expectedLer ) { 
 + / / assertEquals ( actualLer . getKey ( ) , expectedLer . getKey ( ) ) ; 
 + assertEquals ( actualLer . getOrder ( ) , expectedLer . getOrder ( ) ) ; 
 + assertEquals ( actualLer . getQuery ( ) , expectedLer . getQuery ( ) ) ; 
 + assertEquals ( new String ( actualLer . getData ( ) ) , new String ( expectedLer . getData ( ) ) ) ; 
 + } 
 + 
 + @ Test 
 + public void updateOrAdd ( ) { 
 + / / insert 
 + ListEngineRecord ler = new ListEngineRecord ( 1 , 1 , " test " , " bytes " . getBytes ( ) ) ; 
 + ls . updateOrAdd ( ler ) ; 
 + 
 + ListEngineRecord actual = ls . loadItem ( ler . getKey ( ) ) ; 
 + assertEqualLER ( actual , ler ) ; 
 + 
 + / / update 
 + ler = new ListEngineRecord ( 1 , 1 , " test2 " , " bytes2 " . getBytes ( ) ) ; 
 + ls . updateOrAdd ( ler ) ; 
 + actual = ls . loadItem ( ler . getKey ( ) ) ; 
 + assertEqualLER ( actual , ler ) ; 
 + } 
 + 
 + @ Test 
 + public void updateOrAddList ( ) { 
 + / / insert 
 + ListEngineRecord ler1 = new ListEngineRecord ( 1 , 1 , " test1 " , " bytes1 " . getBytes ( ) ) ; 
 + ListEngineRecord ler2 = new ListEngineRecord ( 2 , 2 , " test2 " , " bytes2 " . getBytes ( ) ) ; 
 + ListEngineRecord ler3 = new ListEngineRecord ( 3 , 3 , " test3 " , " bytes3 " . getBytes ( ) ) ; 
 + ListEngineRecord ler4 = new ListEngineRecord ( 4 , 4 , " test4 " , " bytes4 " . getBytes ( ) ) ; 
 + ListEngineRecord ler5 = new ListEngineRecord ( 5 , 5 , " test5 " , " bytes5 " . getBytes ( ) ) ; 
 + ListEngineRecord ler6 = new ListEngineRecord ( 6 , 6 , " test6 " , " bytes6 " . getBytes ( ) ) ; 
 + ls . updateOrAdd ( Arrays . asList ( ler1 , ler2 , ler3 , ler4 , ler5 , ler6 ) ) ; 
 + 
 + ListEngineRecord actual = ls . loadItem ( ler1 . getKey ( ) ) ; 
 + assertEqualLER ( actual , ler1 ) ; 
 + actual = ls . loadItem ( ler2 . getKey ( ) ) ; 
 + assertEqualLER ( actual , ler2 ) ; 
 + actual = ls . loadItem ( ler3 . getKey ( ) ) ; 
 + assertEqualLER ( actual , ler3 ) ; 
 + actual = ls . loadItem ( ler4 . getKey ( ) ) ; 
 + assertEqualLER ( actual , ler4 ) ; 
 + actual = ls . loadItem ( ler5 . getKey ( ) ) ; 
 + assertEqualLER ( actual , ler5 ) ; 
 + actual = ls . loadItem ( ler6 . getKey ( ) ) ; 
 + assertEqualLER ( actual , ler6 ) ; 
 + 
 + } 
 + 
 + @ Test 
 + public void remove ( ) { 
 + updateOrAdd ( ) ; 
 + ls . delete ( 1 ) ; 
 + assertNull ( ls . loadItem ( 1 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void removeList ( ) { 
 + updateOrAddList ( ) ; 
 + ls . delete ( new long [ ] { 1 , 2 } ) ; 
 + assertNull ( ls . loadItem ( 1 ) ) ; 
 + assertNull ( ls . loadItem ( 2 ) ) ; 
 + assertNotNull ( ls . loadItem ( 3 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void isEmpty ( ) { 
 + assertTrue ( ls . isEmpty ( ) ) ; 
 + updateOrAdd ( ) ; 
 + assertFalse ( ls . isEmpty ( ) ) ; 
 + } 
 + 
 + / / @ Test 
 + / / public void loadForward ( ) { 
 + / / updateOrAddList ( ) ; 
 + / / ListStorageDisplayEx lsd = ( ListStorageDisplayEx ) ls ; 
 + / / List < ListEngineRecord > actual = lsd . loadForward ( 5L , 2 ) ; 
 + / / 
 + / / List < ListEngineRecord > expected = Arrays . asList ( 
 + / / new ListEngineRecord ( 3 , 3 , " test3 " , " bytes3 " . getBytes ( ) ) , 
 + / / new ListEngineRecord ( 4 , 4 , " test3 " , " bytes3 " . getBytes ( ) ) 
 + / / ) ; 
 + / / assertEqualLER ( actual . get ( 0 ) , expected . get ( 0 ) ) ; 
 + / / assertEqualLER ( actual . get ( 1 ) , expected . get ( 1 ) ) ; 
 + / / } 
 + 
 + / / 
 + / / 
 + / / @ Test 
 + / / public void addOrUpdateItems ( ) { 
 + / / / / insert 
 + / / List keyValues = Arrays . asList ( 
 + / / new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , 
 + / / new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; 
 + / / kvs . addOrUpdateItems ( keyValues ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + / / 
 + / / / / update 
 + / / keyValues = Arrays . asList ( 
 + / / new KeyValueRecord ( 1 , " value3 " . getBytes ( ) ) , 
 + / / new KeyValueRecord ( 2 , " value4 " . getBytes ( ) ) ) ; 
 + / / kvs . addOrUpdateItems ( keyValues ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value3 " ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value4 " ) ; 
 + / / } 
 + / / 
 + / / @ Test 
 + / / public void removeItem ( ) { 
 + / / kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + / / kvs . removeItem ( 1 ) ; 
 + / / assertNull ( kvs . loadItem ( 1 ) ) ; 
 + / / } 
 + / / 
 + / / @ Test 
 + / / public void removeItemWithContext ( ) { 
 + / / kvs . addOrUpdateItem ( 1 , " value1 " . getBytes ( ) ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + / / 
 + / / srp . setContext ( " 935 " ) ; 
 + / / kvs = srp . createKeyValue ( " test " ) ; 
 + / / kvs . addOrUpdateItem ( 1 , " value2 " . getBytes ( ) ) ; 
 + / / kvs . removeItem ( 1 ) ; 
 + / / assertNull ( kvs . loadItem ( 1 ) ) ; 
 + / / 
 + / / srp . setContext ( null ) ; 
 + / / kvs = srp . createKeyValue ( " test " ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + / / } 
 + / / 
 + / / @ Test 
 + / / public void removeItems ( ) { 
 + / / List keyValues = Arrays . asList ( 
 + / / new KeyValueRecord ( 1 , " value1 " . getBytes ( ) ) , 
 + / / new KeyValueRecord ( 2 , " value2 " . getBytes ( ) ) ) ; 
 + / / kvs . addOrUpdateItems ( keyValues ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 1 ) ) , " value1 " ) ; 
 + / / assertEquals ( new String ( kvs . loadItem ( 2 ) ) , " value2 " ) ; 
 + / / 
 + / / kvs . removeItems ( new long [ ] { 1 , 2 } ) ; 
 + / / assertNull ( kvs . loadItem ( 1 ) ) ; 
 + / / assertNull ( kvs . loadItem ( 2 ) ) ; 
 + / / } 
 + / / 
 + @ Test 
 + public void clear ( ) { 
 + updateOrAddList ( ) ; 
 + ls . clear ( ) ; 
 + assertNull ( ls . loadItem ( 1 ) ) ; 
 + assertNull ( ls . loadItem ( 2 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void getCount ( ) { 
 + updateOrAddList ( ) ; 
 + assertEquals ( ls . getCount ( ) , 6 ) ; 
 + } 
 + 
 + @ After 
 + public void finalize ( ) { 
 + srp . setContext ( null ) ; 
 + / / remove all records 
 + ( ( ClcListStorage ) ls ) . clearAll ( ) ; 
 + } 
 + } 
 diff - - git a / actor - sdk / sdk - core - clc / app - clc / src / test / resources / preferences . properties b / actor - sdk / sdk - core - clc / app - clc / src / test / resources / preferences . properties 
 new file mode 100644 
 index 0000000 . . e69de29

NEAREST DIFF:
diff - - git a / apps / actor - android / src / main / java / im / actor / messenger / app / fragment / auth / BackspaceKeyEditText . java b / apps / actor - android / src / main / java / im / actor / messenger / app / fragment / auth / BackspaceKeyEditText . java 
 index e785ae6 . . 2b0ec15 100644 
 - - - a / apps / actor - android / src / main / java / im / actor / messenger / app / fragment / auth / BackspaceKeyEditText . java 
 + + + b / apps / actor - android / src / main / java / im / actor / messenger / app / fragment / auth / BackspaceKeyEditText . java 
 @ @ - 1 , 7 + 1 , 6 @ @ 
 package im . actor . messenger . app . fragment . auth ; 
 
 import android . content . Context ; 
 - import android . support . v7 . internal . widget . TintEditText ; 
 import android . util . AttributeSet ; 
 import android . view . KeyEvent ; 
 import android . view . inputmethod . EditorInfo ; 
 @ @ - 9 , 7 + 8 , 7 @ @ import android . view . inputmethod . InputConnection ; 
 import android . view . inputmethod . InputConnectionWrapper ; 
 import android . widget . EditText ; 
 
 - public class BackspaceKeyEditText extends TintEditText { 
 + public class BackspaceKeyEditText extends EditText { 
 
 private BackspacePressListener listener ; 
 
 diff - - git a / apps / actor - android / src / main / res / values / styles . xml b / apps / actor - android / src / main / res / values / styles . xml 
 index c3ac8ae . . 8572f57 100644 
 - - - a / apps / actor - android / src / main / res / values / styles . xml 
 + + + b / apps / actor - android / src / main / res / values / styles . xml 
 @ @ - 11 , 12 + 11 , 17 @ @ 
 < item name = " android : colorPrimary " > @ color / primary < / item > 
 < item name = " android : colorPrimaryDark " > @ color / primary _ hovered < / item > 
 < item name = " android : colorAccent " > @ color / accent < / item > 
 + 
 + 
 < / style > 
 
 < style name = " MainActivityTheme " parent = " AppToolbarTheme " > 
 + < item name = " android : windowBackground " > @ color / bg _ main < / item > 
 + 
 < item name = " windowActionBar " > false < / item > 
 + < item name = " windowNoTitle " > true < / item > 
 < item name = " android : windowActionBar " > false < / item > 
 - < item name = " android : windowBackground " > @ color / bg _ main < / item > 
 + < item name = " android : windowNoTitle " > true < / item > 
 < / style > 
 
 < style name = " ProfileActivityTheme " parent = " AppToolbarTheme " > 
 diff - - git a / library / actor - common / src / main / java / im / actor / model / network / connection / AsyncConnectionFactory . java b / library / actor - common / src / main / java / im / actor / model / network / connection / AsyncConnectionFactory . java 
 index 986847f . . 2c281d8 100644 
 - - - a / library / actor - common / src / main / java / im / actor / model / network / connection / AsyncConnectionFactory . java 
 + + + b / library / actor - common / src / main / java / im / actor / model / network / connection / AsyncConnectionFactory . java 
 @ @ - 6 , 5 + 6 , 5 @ @ import im . actor . model . network . ConnectionEndpoint ; 
 * Created by ex3ndr on 29 . 04 . 15 . 
 * / 
 public interface AsyncConnectionFactory { 
 - AsyncConnection createConnection ( ConnectionEndpoint endpoint , AsyncConnectionInterface connectionInterface ) ; 
 + AsyncConnection createConnection ( int connectionId , ConnectionEndpoint endpoint , AsyncConnectionInterface connectionInterface ) ; 
 } 
 diff - - git a / library / actor - common / src / main / java / im / actor / model / network / connection / ManagedConnection . java b / library / actor - common / src / main / java / im / actor / model / network / connection / ManagedConnection . java 
 index 6b9e800 . . 6896cdb 100644 
 - - - a / library / actor - common / src / main / java / im / actor / model / network / connection / ManagedConnection . java 
 + + + b / library / actor - common / src / main / java / im / actor / model / network / connection / ManagedConnection . java 
 @ @ - 20 , 7 + 20 , 7 @ @ import im . actor . model . util . CRC32 ; 
 * / 
 public class ManagedConnection implements Connection { 
 
 - private static final int CONNECTION _ TIMEOUT = 5 * 1000 ; 
 + public static final int CONNECTION _ TIMEOUT = 5 * 1000 ; 
 private static final int HANDSHAKE _ TIMEOUT = 5 * 1000 ; 
 private static final int RESPONSE _ TIMEOUT = 5 * 1000 ; 
 private static final int PING _ TIMEOUT = 5 * 60 * 1000 ; 
 @ @ - 76 , 7 + 76 , 7 @ @ public class ManagedConnection implements Connection { 
 this . apiMinorVersion = apiMinorVersion ; 
 this . callback = callback ; 
 this . factoryCallback = factoryCallback ; 
 - this . rawConnection = connectionFactory . createConnection ( endpoint , connectionInterface ) ; 
 + this . rawConnection = connectionFactory . createConnection ( connectionId , endpoint , connectionInterface ) ; 
 Log . d ( TAG , " Starting connection " ) ; 
 
 handshakeTimeout = new TimerCompat ( new TimeoutRunnable ( ) ) ; 
 @ @ - 335 , 9 + 335 , 12 @ @ public class ManagedConnection implements Connection { 
 e . printStackTrace ( ) ; 
 close ( ) ; 
 } 
 + 
 + Log . w ( TAG , " onRawReceived : end " ) ; 
 } 
 
 private synchronized void onRawClosed ( ) { 
 + Log . w ( TAG , " Received closed event " ) ; 
 close ( ) ; 
 } 
 
 @ @ - 348 , 6 + 351 , 7 @ @ public class ManagedConnection implements Connection { 
 } 
 
 private synchronized void rawPost ( int header , byte [ ] data , int offset , int len ) { 
 + Log . w ( TAG , " rawPost " ) ; 
 int packageId = sentPackages + + ; 
 DataOutput dataOutput = new DataOutput ( ) ; 
 dataOutput . writeInt ( packageId ) ; 
 @ @ - 371 , 6 + 375 , 7 @ @ public class ManagedConnection implements Connection { 
 
 @ Override 
 public synchronized void post ( byte [ ] data , int offset , int len ) { 
 + Log . w ( TAG , " post " ) ; 
 if ( isClosed ) { 
 return ; 
 } 
 @ @ - 389 , 6 + 394 , 7 @ @ public class ManagedConnection implements Connection { 
 
 @ Override 
 public synchronized void close ( ) { 
 + Log . w ( TAG , " close " ) ; 
 if ( isClosed ) { 
 return ; 
 } 
 diff - - git a / library / actor - js / src / main / java / im / actor / model / js / providers / websocket / WebSocketConnection . java b / library / actor - js / src / main / java / im / actor / model / js / providers / websocket / WebSocketConnection . java 
 index a768087 . . f9703b6 100644 
 - - - a / library / actor - js / src / main / java / im / actor / model / js / providers / websocket / WebSocketConnection . java 
 + + + b / library / actor - js / src / main / java / im / actor / model / js / providers / websocket / WebSocketConnection . java 
 @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . model . network . connection . AsyncConnectionInterface ; 
 public class WebSocketConnection extends AsyncConnection { 
 
 private JavaScriptObject jsWebSocket ; 
 + private boolean isClosed ; 
 
 public WebSocketConnection ( ConnectionEndpoint endpoint , AsyncConnectionInterface connection ) { 
 super ( endpoint , connection ) ; 
 @ @ - 23 , 6 + 24 , 8 @ @ public class WebSocketConnection extends AsyncConnection { 
 
 @ Override 
 public void doConnect ( ) { 
 + isClosed = true ; 
 + 
 String url ; 
 if ( getEndpoint ( ) . getType ( ) = = ConnectionEndpoint . Type . WS ) { 
 url = " ws : / / " + getEndpoint ( ) . getHost ( ) + " : " + getEndpoint ( ) . getPort ( ) + " / " ; 
 @ @ - 37 , 6 + 40 , 9 @ @ public class WebSocketConnection extends AsyncConnection { 
 
 @ Override 
 public void doSend ( byte [ ] data ) { 
 + if ( isClosed ) { 
 + return ; 
 + } 
 Uint8Array push = TypedArrays . createUint8Array ( data . length ) ; 
 for ( int i = 0 ; i < data . length ; i + + ) { 
 push . set ( i , data [ i ] ) ; 
 @ @ - 46 , 10 + 52 , 14 @ @ public class WebSocketConnection extends AsyncConnection { 
 
 @ Override 
 public void doClose ( ) { 
 + isClosed = true ; 
 close ( ) ; 
 } 
 
 private void onRawMessage ( ArrayBuffer message ) { 
 + if ( isClosed ) { 
 + return ; 
 + } 
 Uint8Array array = TypedArrays . createUint8Array ( message ) ; 
 byte [ ] res = new byte [ array . length ( ) ] ; 
 for ( int i = 0 ; i < res . length ; i + + ) { 
 @ @ - 60 , 11 + 70 , 13 @ @ public class WebSocketConnection extends AsyncConnection { 
 
 private void onRawConnected ( ) { 
 Log . d ( " WS " , " Connected " ) ; 
 + isClosed = false ; 
 onConnected ( ) ; 
 } 
 
 private void onRawClosed ( ) { 
 Log . d ( " WS " , " Closed " ) ; 
 + isClosed = true ; 
 onClosed ( ) ; 
 } 
 
 diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java 
 index 2cc9e64 . . f1049db 100644 
 - - - a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java 
 + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaNetworkProvider . java 
 @ @ - 1 , 39 + 1 , 14 @ @ 
 package im . actor . model . jvm ; 
 
 - import im . actor . model . NetworkProvider ; 
 - import im . actor . model . network . ConnectionCallback ; 
 - import im . actor . model . network . ConnectionEndpoint ; 
 - import im . actor . model . network . CreateConnectionCallback ; 
 + import im . actor . model . jvm . tcp . AsyncTcpConnectionFactory ; 
 + import im . actor . model . network . connection . ManagedNetworkProvider ; 
 
 / * * 
 * Created by ex3ndr on 13 . 04 . 15 . 
 * / 
 - public class JavaNetworkProvider implements NetworkProvider { 
 + public class JavaNetworkProvider extends ManagedNetworkProvider { 
 
 - @ Override 
 - public void createConnection ( final int connectionId , 
 - final int mtprotoVersion , 
 - final int apiMajorVersion , 
 - final int apiMinorVersion , 
 - final ConnectionEndpoint endpoint , final ConnectionCallback callback , 
 - final CreateConnectionCallback createCallback ) { 
 - new Thread ( ) { 
 - @ Override 
 - public void run ( ) { 
 - try { 
 - createCallback . onConnectionCreated ( 
 - new JavaTcpConnection ( 
 - connectionId , 
 - mtprotoVersion , 
 - apiMajorVersion , 
 - apiMinorVersion , 
 - endpoint , 
 - callback ) ) ; 
 - } catch ( Exception e ) { 
 - e . printStackTrace ( ) ; 
 - createCallback . onConnectionCreateError ( ) ; 
 - } 
 - } 
 - } . start ( ) ; 
 + public JavaNetworkProvider ( ) { 
 + super ( new AsyncTcpConnectionFactory ( ) ) ; 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaTcpConnection . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaTcpConnection . java 
 deleted file mode 100644 
 index eee1ea8 . . 0000000 
 - - - a / library / actor - jvm / src / main / java / im / actor / model / jvm / JavaTcpConnection . java 
 + + + / dev / null 
 @ @ - 1 , 545 + 0 , 0 @ @ 
 - package im . actor . model . jvm ; 
 - 
 - import java . io . IOException ; 
 - import java . io . InputStream ; 
 - import java . io . OutputStream ; 
 - import java . net . InetSocketAddress ; 
 - import java . net . Socket ; 
 - import java . util . Arrays ; 
 - import java . util . HashMap ; 
 - import java . util . Random ; 
 - import java . util . Timer ; 
 - import java . util . TimerTask ; 
 - import java . util . concurrent . ConcurrentLinkedQueue ; 
 - 
 - import javax . net . ssl . SSLSocketFactory ; 
 - 
 - import im . actor . model . crypto . CryptoUtils ; 
 - import im . actor . model . droidkit . bser . DataInput ; 
 - import im . actor . model . droidkit . bser . DataOutput ; 
 - import im . actor . model . log . Log ; 
 - import im . actor . model . network . Connection ; 
 - import im . actor . model . network . ConnectionCallback ; 
 - import im . actor . model . network . ConnectionEndpoint ; 
 - import im . actor . model . util . CRC32 ; 
 - 
 - / * * 
 - * Created by ex3ndr on 13 . 04 . 15 . 
 - * / 
 - public class JavaTcpConnection implements Connection { 
 - 
 - private static final int CONNECTION _ TIMEOUT = 5 * 1000 ; 
 - private static final int HANDSHAKE _ TIMEOUT = 5 * 1000 ; 
 - private static final int RESPONSE _ TIMEOUT = 5 * 1000 ; 
 - private static final int PING _ TIMEOUT = 5 * 60 * 1000 ; 
 - 
 - private static final int HEADER _ PROTO = 0 ; 
 - private static final int HEADER _ PING = 1 ; 
 - private static final int HEADER _ PONG = 2 ; 
 - private static final int HEADER _ DROP = 3 ; 
 - private static final int HEADER _ REDIRECT = 4 ; 
 - private static final int HEADER _ ACK = 6 ; 
 - 
 - private static final Random RANDOM = new Random ( ) ; 
 - private static final Timer DIE _ TIMER = new Timer ( ) ; 
 - 
 - private final String TAG ; 
 - private final ConnectionCallback callback ; 
 - private final Socket socket ; 
 - private final InputStream inputStream ; 
 - private final OutputStream outputStream ; 
 - private final ReaderThread readerThread ; 
 - private final WriterThread writerThread ; 
 - private TimerTask pingTask ; 
 - private final HashMap < Long , TimerTask > schedulledPings = new HashMap < Long , TimerTask > ( ) ; 
 - private final HashMap < Integer , TimerTask > packageTimers = new HashMap < Integer , TimerTask > ( ) ; 
 - 
 - / / Connection state 
 - private int sentPackets ; 
 - private int receivedPackets ; 
 - private boolean isClosed ; 
 - 
 - public JavaTcpConnection ( int id , 
 - int mtprotoVersion , 
 - int apiMajorVersion , 
 - int apiMinorVersion , 
 - ConnectionEndpoint endpoint , 
 - ConnectionCallback callback ) throws IOException { 
 - this . TAG = " Connection # " + id ; 
 - this . callback = callback ; 
 - this . isClosed = false ; 
 - this . sentPackets = 0 ; 
 - this . receivedPackets = 0 ; 
 - 
 - / / Log . d ( TAG , " Creating socket . . . " ) ; 
 - switch ( endpoint . getType ( ) ) { 
 - case TCP : 
 - socket = new Socket ( ) ; 
 - break ; 
 - case TCP _ TLS : 
 - socket = SSLSocketFactory . getDefault ( ) . createSocket ( ) ; 
 - break ; 
 - default : 
 - throw new IOException ( " Unsupported endpoint type : " + endpoint . getType ( ) ) ; 
 - } 
 - 
 - this . socket . setKeepAlive ( false ) ; 
 - this . socket . setTcpNoDelay ( true ) ; 
 - 
 - / / Log . d ( TAG , " Connecting socket . . . " ) ; 
 - 
 - this . socket . connect ( new InetSocketAddress ( endpoint . getHost ( ) , endpoint . getPort ( ) ) , CONNECTION _ TIMEOUT ) ; 
 - 
 - / / Log . d ( TAG , " Performing handshake . . . " ) ; 
 - 
 - / / Init socket streams 
 - inputStream = this . socket . getInputStream ( ) ; 
 - outputStream = this . socket . getOutputStream ( ) ; 
 - 
 - / / Handshake request 
 - DataOutput handshakeRequest = new DataOutput ( ) ; 
 - handshakeRequest . writeByte ( mtprotoVersion ) ; 
 - handshakeRequest . writeByte ( apiMajorVersion ) ; 
 - handshakeRequest . writeByte ( apiMinorVersion ) ; 
 - byte [ ] randomData = new byte [ 32 ] ; 
 - synchronized ( RANDOM ) { 
 - RANDOM . nextBytes ( randomData ) ; 
 - } 
 - handshakeRequest . writeInt ( randomData . length ) ; 
 - handshakeRequest . writeBytes ( randomData , 0 , randomData . length ) ; 
 - outputStream . write ( handshakeRequest . toByteArray ( ) ) ; 
 - outputStream . flush ( ) ; 
 - 
 - / / Log . d ( TAG , " Reading handshake response . . . " ) ; 
 - / / Handshake response 
 - socket . setSoTimeout ( HANDSHAKE _ TIMEOUT ) ; 
 - byte [ ] data = readBytes ( 3 + 32 ) ; 
 - socket . setSoTimeout ( 0 ) ; 
 - DataInput handshakeResponse = new DataInput ( data ) ; 
 - int protoVersion = handshakeResponse . readByte ( ) ; 
 - int apiMajor = handshakeResponse . readByte ( ) ; 
 - int apiMinor = handshakeResponse . readByte ( ) ; 
 - byte [ ] sha256 = handshakeResponse . readBytes ( 32 ) ; 
 - byte [ ] localSha256 = CryptoUtils . SHA256 ( randomData ) ; 
 - 
 - if ( ! Arrays . equals ( sha256 , localSha256 ) ) { 
 - throw new IOException ( " SHA 256 is incorrect " ) ; 
 - } 
 - if ( protoVersion ! = 1 ) { 
 - throw new IOException ( " Incorrect Proto Version , expected : 1 , got " + protoVersion + " ; " ) ; 
 - } 
 - if ( apiMajor ! = 1 ) { 
 - throw new IOException ( " Incorrect Api Major Version , expected : 1 , got " + apiMajor + " ; " ) ; 
 - } 
 - if ( apiMinor ! = 0 ) { 
 - throw new IOException ( " Incorrect Api Minor Version , expected : 0 , got " + apiMinor + " ; " ) ; 
 - } 
 - 
 - / / Log . d ( TAG , " Handshake completed . " ) ; 
 - 
 - readerThread = new ReaderThread ( ) ; 
 - writerThread = new WriterThread ( ) ; 
 - readerThread . start ( ) ; 
 - writerThread . start ( ) ; 
 - 
 - pingTask = new PingTask ( ) ; 
 - DIE _ TIMER . schedule ( pingTask , PING _ TIMEOUT ) ; 
 - } 
 - 
 - @ Override 
 - public synchronized void post ( byte [ ] data , int offset , int len ) { 
 - post ( HEADER _ PROTO , data , offset , len ) ; 
 - } 
 - 
 - protected synchronized void post ( int header , byte [ ] data ) { 
 - post ( header , data , 0 , data . length ) ; 
 - } 
 - 
 - protected synchronized void post ( int header , byte [ ] data , int offset , int len ) { 
 - writerThread . pushPackage ( new WritePackage ( header , data , offset , len ) ) ; 
 - } 
 - 
 - @ Override 
 - public synchronized boolean isClosed ( ) { 
 - return isClosed ; 
 - } 
 - 
 - @ Override 
 - public synchronized void close ( ) { 
 - if ( isClosed ) { 
 - return ; 
 - } 
 - isClosed = true ; 
 - 
 - try { 
 - readerThread . interrupt ( ) ; 
 - } catch ( Exception e ) { 
 - Log . e ( TAG , e ) ; 
 - } 
 - 
 - try { 
 - writerThread . interrupt ( ) ; 
 - } catch ( Exception e ) { 
 - Log . e ( TAG , e ) ; 
 - } 
 - 
 - try { 
 - socket . close ( ) ; 
 - } catch ( IOException e ) { 
 - Log . e ( TAG , e ) ; 
 - } 
 - 
 - callback . onConnectionDie ( ) ; 
 - 
 - synchronized ( packageTimers ) { 
 - for ( Integer id : packageTimers . keySet ( ) ) { 
 - packageTimers . get ( id ) . cancel ( ) ; 
 - } 
 - for ( Long ping : schedulledPings . keySet ( ) ) { 
 - schedulledPings . get ( ping ) . cancel ( ) ; 
 - } 
 - schedulledPings . clear ( ) ; 
 - packageTimers . clear ( ) ; 
 - } 
 - 
 - pingTask . cancel ( ) ; 
 - } 
 - 
 - private void onServerAck ( int packageId ) { 
 - synchronized ( packageTimers ) { 
 - TimerTask task = packageTimers . remove ( packageId ) ; 
 - if ( task = = null ) { 
 - return ; 
 - } 
 - task . cancel ( ) ; 
 - 
 - refreshTimeouts ( ) ; 
 - } 
 - } 
 - 
 - private void onServerPong ( long pingId ) { 
 - synchronized ( packageTimers ) { 
 - TimerTask task = schedulledPings . remove ( pingId ) ; 
 - if ( task = = null ) { 
 - return ; 
 - } 
 - task . cancel ( ) ; 
 - 
 - refreshTimeouts ( ) ; 
 - } 
 - } 
 - 
 - private void refreshTimeouts ( ) { 
 - for ( Long ping : schedulledPings . keySet ( ) . toArray ( new Long [ 0 ] ) ) { 
 - / / Remove old 
 - TimerTask oldTask = schedulledPings . remove ( ping ) ; 
 - oldTask . cancel ( ) ; 
 - 
 - / / Add new 
 - PingTimeoutTask newTask = new PingTimeoutTask ( ping ) ; 
 - schedulledPings . put ( ping , newTask ) ; 
 - DIE _ TIMER . schedule ( newTask , RESPONSE _ TIMEOUT ) ; 
 - } 
 - for ( Integer id : packageTimers . keySet ( ) . toArray ( new Integer [ 0 ] ) ) { 
 - / / Remove old 
 - TimerTask oldTask = packageTimers . get ( id ) ; 
 - oldTask . cancel ( ) ; 
 - 
 - / / Add new 
 - FrameTimeoutTask newTask = new FrameTimeoutTask ( id ) ; 
 - packageTimers . put ( id , newTask ) ; 
 - DIE _ TIMER . schedule ( newTask , RESPONSE _ TIMEOUT ) ; 
 - } 
 - 
 - pingTask . cancel ( ) ; 
 - 
 - pingTask = new PingTask ( ) ; 
 - DIE _ TIMER . schedule ( pingTask , PING _ TIMEOUT ) ; 
 - } 
 - 
 - private class ReaderThread extends Thread { 
 - 
 - private final CRC32 crc32Engine = new CRC32 ( ) ; 
 - 
 - private ReaderThread ( ) { 
 - setName ( TAG + " # Reader " + hashCode ( ) ) ; 
 - } 
 - 
 - @ Override 
 - public void run ( ) { 
 - try { 
 - while ( ! isClosed ( ) ) { 
 - if ( socket . isClosed ( ) ) { 
 - throw new IOException ( " Socket is closed " ) ; 
 - } 
 - if ( ! socket . isConnected ( ) ) { 
 - throw new IOException ( " Socket is not connected " ) ; 
 - } 
 - 
 - / / Reading package headers 
 - / / Log . d ( TAG , " Waiting for frame header . . . " ) ; 
 - byte [ ] packageHeader = readBytes ( 9 ) ; 
 - DataInput dataInput = new DataInput ( packageHeader ) ; 
 - int receivedPackageIndex = dataInput . readInt ( ) ; 
 - if ( receivedPackageIndex ! = receivedPackets ) { 
 - throw new IOException ( " Received frame with incorrect index . " + 
 - " Expected : " + receivedPackets + " , got : " + receivedPackageIndex ) ; 
 - } 
 - receivedPackets + + ; 
 - int header = dataInput . readByte ( ) ; 
 - int size = dataInput . readInt ( ) ; 
 - 
 - / / Reading package body 
 - / / Log . d ( TAG , " Reading frame body for # " + receivedPackageIndex ) ; 
 - byte [ ] body = readBytes ( size + 4 ) ; 
 - dataInput = new DataInput ( body ) ; 
 - byte [ ] contents = dataInput . readBytes ( size ) ; 
 - 
 - / / Checking CRC32 
 - long crc32 = dataInput . readUInt ( ) ; 
 - crc32Engine . reset ( ) ; 
 - crc32Engine . update ( contents ) ; 
 - long localCrc32 = crc32Engine . getValue ( ) ; 
 - if ( localCrc32 ! = crc32 ) { 
 - throw new IOException ( " Received frame contents with incorrect crc32 " ) ; 
 - } 
 - 
 - / / Processing package 
 - if ( header = = HEADER _ PROTO ) { 
 - / / Log . d ( TAG , " Received proto frame " ) ; 
 - callback . onMessage ( contents , 0 , contents . length ) ; 
 - 
 - DataOutput ackPackage = new DataOutput ( ) ; 
 - ackPackage . writeInt ( receivedPackageIndex ) ; 
 - post ( HEADER _ ACK , ackPackage . toByteArray ( ) ) ; 
 - } else if ( header = = HEADER _ PING ) { 
 - / / Log . d ( TAG , " Received ping frame " ) ; 
 - post ( HEADER _ PONG , contents ) ; 
 - } else if ( header = = HEADER _ PONG ) { 
 - / / Log . d ( TAG , " Received pong frame " ) ; 
 - DataInput pongInput = new DataInput ( contents ) ; 
 - int pongLen = pongInput . readInt ( ) ; 
 - if ( pongLen ! = 8 ) { 
 - / / Log . w ( TAG , " Pong invalid content length , got : " + pongLen ) ; 
 - continue ; 
 - } 
 - onServerPong ( pongInput . readLong ( ) ) ; 
 - } else if ( header = = HEADER _ ACK ) { 
 - / / Log . d ( TAG , " Received ack frame " ) ; 
 - DataInput ackContent = new DataInput ( contents ) ; 
 - int frameId = ackContent . readInt ( ) ; 
 - onServerAck ( frameId ) ; 
 - } else if ( header = = HEADER _ REDIRECT ) { 
 - DataInput redirectContent = new DataInput ( contents ) ; 
 - int hostLen = redirectContent . readInt ( ) ; 
 - String host = new String ( redirectContent . readBytes ( hostLen ) , " UTF - 8 " ) ; 
 - int port = redirectContent . readInt ( ) ; 
 - int timeout = redirectContent . readInt ( ) ; 
 - / / TODO : Implement redirect 
 - throw new IOException ( " Received redirect frame : " + host + " : " + port + " with timeout " + timeout + " sec " ) ; 
 - } else if ( header = = HEADER _ DROP ) { 
 - DataInput drop = new DataInput ( contents ) ; 
 - long messageId = drop . readLong ( ) ; 
 - int errorCode = drop . readByte ( ) ; 
 - int messageLen = drop . readInt ( ) ; 
 - String message = new String ( drop . readBytes ( messageLen ) , " UTF - 8 " ) ; 
 - / / Log . d ( TAG , " Received drop frame : " + message ) ; 
 - 
 - throw new IOException ( " Received drop frame : " + message ) ; 
 - } else { 
 - Log . w ( TAG , " Received unknown frame # " + header ) ; 
 - } 
 - } 
 - } catch ( IOException e ) { 
 - e . printStackTrace ( ) ; 
 - close ( ) ; 
 - } 
 - } 
 - } 
 - 
 - / * * 
 - * Package send thread 
 - * / 
 - private class WriterThread extends Thread { 
 - 
 - private final CRC32 crc32Engine = new CRC32 ( ) ; 
 - 
 - private final ConcurrentLinkedQueue < WritePackage > packages = new ConcurrentLinkedQueue < WritePackage > ( ) ; 
 - 
 - public WriterThread ( ) { 
 - setName ( TAG + " # Writer " + hashCode ( ) ) ; 
 - } 
 - 
 - / * * 
 - * Send package to connection 
 - * 
 - * @ param p package 
 - * / 
 - public void pushPackage ( final WritePackage p ) { 
 - packages . add ( p ) ; 
 - synchronized ( packages ) { 
 - packages . notifyAll ( ) ; 
 - } 
 - } 
 - 
 - @ Override 
 - public void run ( ) { 
 - try { 
 - while ( ! isClosed ( ) ) { 
 - 
 - / / Pooling of package from queue 
 - WritePackage p ; 
 - synchronized ( packages ) { 
 - p = packages . poll ( ) ; 
 - if ( p = = null ) { 
 - try { 
 - packages . wait ( ) ; 
 - } catch ( final InterruptedException e ) { 
 - return ; 
 - } 
 - p = packages . poll ( ) ; 
 - } 
 - } 
 - if ( p = = null ) { 
 - continue ; 
 - } 
 - 
 - / / Start package send 
 - / / Log . d ( TAG , " Sending frame # " + sentPackets ) ; 
 - 
 - / / Prepare package 
 - final int packageId = sentPackets + + ; 
 - DataOutput dataOutput = new DataOutput ( ) ; 
 - dataOutput . writeInt ( packageId ) ; 
 - dataOutput . writeByte ( p . getHeader ( ) ) ; 
 - dataOutput . writeInt ( p . getContent ( ) . length ) ; 
 - dataOutput . writeBytes ( p . getContent ( ) , p . getOffset ( ) , p . getLen ( ) ) ; 
 - crc32Engine . reset ( ) ; 
 - crc32Engine . update ( p . getContent ( ) , p . getOffset ( ) , p . getLen ( ) ) ; 
 - dataOutput . writeInt ( ( int ) crc32Engine . getValue ( ) ) ; 
 - byte [ ] destPackage = dataOutput . toByteArray ( ) ; 
 - 
 - / / Setting Ack timeout 
 - if ( p . getHeader ( ) = = HEADER _ PROTO ) { 
 - synchronized ( packageTimers ) { 
 - TimerTask timeoutTask = new TimerTask ( ) { 
 - @ Override 
 - public void run ( ) { 
 - / / Log . d ( TAG , " Response # " + packageId + " not received in time " ) ; 
 - close ( ) ; 
 - } 
 - } ; 
 - packageTimers . put ( packageId , timeoutTask ) ; 
 - DIE _ TIMER . schedule ( timeoutTask , RESPONSE _ TIMEOUT ) ; 
 - } 
 - } 
 - 
 - / / Writing package to socket 
 - outputStream . write ( destPackage ) ; 
 - outputStream . flush ( ) ; 
 - } 
 - } catch ( IOException e ) { 
 - e . printStackTrace ( ) ; 
 - close ( ) ; 
 - } 
 - } 
 - } 
 - 
 - private class WritePackage { 
 - private int header ; 
 - private byte [ ] content ; 
 - private int offset ; 
 - private int len ; 
 - 
 - private WritePackage ( int header , byte [ ] content , int offset , int len ) { 
 - this . header = header ; 
 - this . content = content ; 
 - this . offset = offset ; 
 - this . len = len ; 
 - } 
 - 
 - public int getHeader ( ) { 
 - return header ; 
 - } 
 - 
 - public byte [ ] getContent ( ) { 
 - return content ; 
 - } 
 - 
 - public int getOffset ( ) { 
 - return offset ; 
 - } 
 - 
 - public int getLen ( ) { 
 - return len ; 
 - } 
 - } 
 - 
 - class PingTimeoutTask extends TimerTask { 
 - private long pingId ; 
 - 
 - public PingTimeoutTask ( long pingId ) { 
 - this . pingId = pingId ; 
 - } 
 - 
 - @ Override 
 - public void run ( ) { 
 - / / Log . d ( TAG , " Ping # " + pingId + " is timed out " ) ; 
 - close ( ) ; 
 - } 
 - } 
 - 
 - class FrameTimeoutTask extends TimerTask { 
 - private int frameId ; 
 - 
 - FrameTimeoutTask ( int frameId ) { 
 - this . frameId = frameId ; 
 - } 
 - 
 - @ Override 
 - public void run ( ) { 
 - / / Log . d ( TAG , " Response # " + frameId + " not received in time " ) ; 
 - close ( ) ; 
 - } 
 - } 
 - 
 - class PingTask extends TimerTask { 
 - @ Override 
 - public void run ( ) { 
 - if ( isClosed ( ) ) { 
 - return ; 
 - } 
 - final long pingId = RANDOM . nextLong ( ) ; 
 - DataOutput dataOutput = new DataOutput ( ) ; 
 - dataOutput . writeInt ( 8 ) ; 
 - synchronized ( RANDOM ) { 
 - dataOutput . writeLong ( pingId ) ; 
 - } 
 - 
 - PingTimeoutTask pingTimeout = new PingTimeoutTask ( pingId ) ; 
 - synchronized ( packageTimers ) { 
 - schedulledPings . put ( pingId , pingTimeout ) ; 
 - } 
 - DIE _ TIMER . schedule ( pingTimeout , RESPONSE _ TIMEOUT ) ; 
 - 
 - / / Log . d ( TAG , " Performing ping # " + pingId + " . . . " ) ; 
 - post ( HEADER _ PING , dataOutput . toByteArray ( ) ) ; 
 - } 
 - } 
 - 
 - private byte [ ] readBytes ( int count ) throws IOException { 
 - byte [ ] res = new byte [ count ] ; 
 - int offset = 0 ; 
 - while ( offset < res . length ) { 
 - int readed = inputStream . read ( res , offset , res . length - offset ) ; 
 - if ( readed > 0 ) { 
 - offset + = readed ; 
 - } else if ( readed < 0 ) { 
 - throw new IOException ( ) ; 
 - } else { 
 - Thread . yield ( ) ; 
 - } 
 - } 
 - return res ; 
 - } 
 - } 
 diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnection . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnection . java 
 new file mode 100644 
 index 0000000 . . fcdd41c 
 - - - / dev / null 
 + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnection . java 
 @ @ - 0 , 0 + 1 , 271 @ @ 
 + package im . actor . model . jvm . tcp ; 
 + 
 + import java . io . IOException ; 
 + import java . io . InputStream ; 
 + import java . io . OutputStream ; 
 + import java . net . InetSocketAddress ; 
 + import java . net . Socket ; 
 + import java . util . concurrent . ConcurrentLinkedQueue ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Executors ; 
 + 
 + import javax . net . ssl . SSLSocketFactory ; 
 + 
 + import im . actor . model . droidkit . bser . DataInput ; 
 + import im . actor . model . droidkit . bser . DataOutput ; 
 + import im . actor . model . log . Log ; 
 + import im . actor . model . network . ConnectionEndpoint ; 
 + import im . actor . model . network . connection . AsyncConnection ; 
 + import im . actor . model . network . connection . AsyncConnectionInterface ; 
 + import im . actor . model . network . connection . ManagedConnection ; 
 + 
 + / * * 
 + * Created by ex3ndr on 01 . 05 . 15 . 
 + * / 
 + public class AsyncTcpConnection extends AsyncConnection { 
 + 
 + private final ExecutorService connectExecutor = Executors . newSingleThreadExecutor ( ) ; 
 + 
 + private final String TAG ; 
 + 
 + private Socket socket ; 
 + private InputStream inputStream ; 
 + private OutputStream outputStream ; 
 + private WriterThread writerThread ; 
 + private ReaderThread readerThread ; 
 + 
 + private boolean isConnected = false ; 
 + private boolean isClosed = false ; 
 + 
 + public AsyncTcpConnection ( int id , ConnectionEndpoint endpoint , AsyncConnectionInterface connection ) { 
 + super ( endpoint , connection ) ; 
 + 
 + this . TAG = " ConnectionTcp # " + id ; 
 + } 
 + 
 + @ Override 
 + public void doConnect ( ) { 
 + connectExecutor . submit ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + try { 
 + Socket socket ; 
 + ConnectionEndpoint endpoint = getEndpoint ( ) ; 
 + switch ( endpoint . getType ( ) ) { 
 + case TCP : 
 + socket = new Socket ( ) ; 
 + break ; 
 + case TCP _ TLS : 
 + socket = SSLSocketFactory . getDefault ( ) . createSocket ( ) ; 
 + break ; 
 + default : 
 + throw new RuntimeException ( " Unsupported endpoint type : " + endpoint . getType ( ) ) ; 
 + } 
 + 
 + / / Configure socket 
 + socket . setKeepAlive ( false ) ; 
 + socket . setTcpNoDelay ( true ) ; 
 + 
 + socket . connect ( new InetSocketAddress ( endpoint . getHost ( ) , endpoint . getPort ( ) ) , ManagedConnection . CONNECTION _ TIMEOUT ) ; 
 + 
 + / / Init streams 
 + socket . getInputStream ( ) ; 
 + socket . getOutputStream ( ) ; 
 + 
 + onSocketCreated ( socket ) ; 
 + } catch ( Exception e ) { 
 + e . printStackTrace ( ) ; 
 + crashConnection ( ) ; 
 + } 
 + } 
 + } ) ; 
 + } 
 + 
 + @ Override 
 + public void doSend ( byte [ ] data ) { 
 + writerThread . pushPackage ( data ) ; 
 + } 
 + 
 + @ Override 
 + public void doClose ( ) { 
 + crashConnection ( ) ; 
 + } 
 + 
 + 
 + private synchronized void onSocketCreated ( Socket socket ) throws IOException { 
 + if ( isClosed ) { 
 + Log . w ( TAG , " Socket created after external close : disposing " ) ; 
 + throw new IOException ( " Socket created after external close : disposing " ) ; 
 + } 
 + 
 + this . socket = socket ; 
 + this . inputStream = socket . getInputStream ( ) ; 
 + this . outputStream = socket . getOutputStream ( ) ; 
 + 
 + this . isClosed = false ; 
 + this . isConnected = true ; 
 + 
 + this . readerThread = new ReaderThread ( ) ; 
 + this . readerThread . start ( ) ; 
 + 
 + this . writerThread = new WriterThread ( ) ; 
 + this . writerThread . start ( ) ; 
 + 
 + onConnected ( ) ; 
 + } 
 + 
 + private synchronized void onRawReceived ( byte [ ] data ) throws IOException { 
 + if ( ! isConnected ) { 
 + Log . d ( TAG , " onRawReceived : Not connected " ) ; 
 + return ; 
 + } 
 + 
 + onReceived ( data ) ; 
 + } 
 + 
 + private synchronized void crashConnection ( ) { 
 + Log . d ( TAG , " Crashing Connection " ) ; 
 + 
 + if ( isClosed ) { 
 + return ; 
 + } 
 + isClosed = true ; 
 + isConnected = false ; 
 + 
 + if ( writerThread ! = null ) { 
 + writerThread . interrupt ( ) ; 
 + } 
 + if ( readerThread ! = null ) { 
 + readerThread . interrupt ( ) ; 
 + } 
 + writerThread = null ; 
 + readerThread = null ; 
 + 
 + if ( socket ! = null ) { 
 + try { 
 + socket . close ( ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + if ( inputStream ! = null ) { 
 + try { 
 + inputStream . close ( ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + if ( outputStream ! = null ) { 
 + try { 
 + outputStream . close ( ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + socket = null ; 
 + inputStream = null ; 
 + outputStream = null ; 
 + 
 + onClosed ( ) ; 
 + } 
 + 
 + 
 + private class WriterThread extends Thread { 
 + private final ConcurrentLinkedQueue < byte [ ] > packages = new ConcurrentLinkedQueue < byte [ ] > ( ) ; 
 + 
 + public WriterThread ( ) { 
 + setName ( TAG + " # Writer " ) ; 
 + } 
 + 
 + / * * 
 + * Send package to connection 
 + * 
 + * @ param p package 
 + * / 
 + public void pushPackage ( final byte [ ] p ) { 
 + packages . add ( p ) ; 
 + synchronized ( packages ) { 
 + packages . notifyAll ( ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void run ( ) { 
 + try { 
 + while ( isConnected ) { 
 + 
 + / / Pooling of package from queue 
 + byte [ ] p ; 
 + synchronized ( packages ) { 
 + p = packages . poll ( ) ; 
 + if ( p = = null ) { 
 + try { 
 + packages . wait ( ) ; 
 + } catch ( final InterruptedException e ) { 
 + return ; 
 + } 
 + p = packages . poll ( ) ; 
 + } 
 + } 
 + if ( p = = null ) { 
 + continue ; 
 + } 
 + 
 + outputStream . write ( p ) ; 
 + outputStream . flush ( ) ; 
 + } 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + crashConnection ( ) ; 
 + } 
 + } 
 + } 
 + 
 + private class ReaderThread extends Thread { 
 + 
 + private ReaderThread ( ) { 
 + setName ( TAG + " # Reader " ) ; 
 + } 
 + 
 + @ Override 
 + public void run ( ) { 
 + try { 
 + while ( isConnected ) { 
 + / / Reading package headers 
 + byte [ ] header = readBytes ( 9 ) ; 
 + DataInput dataInput = new DataInput ( header ) ; 
 + int receivedPackageIndex = dataInput . readInt ( ) ; 
 + int headerValue = dataInput . readByte ( ) ; 
 + int size = dataInput . readInt ( ) ; 
 + 
 + / / Reading package body 
 + byte [ ] body = readBytes ( size + 4 ) ; 
 + 
 + DataOutput dataOutput = new DataOutput ( ) ; 
 + dataOutput . writeBytes ( header ) ; 
 + dataOutput . writeBytes ( body ) ; 
 + onRawReceived ( dataOutput . toByteArray ( ) ) ; 
 + } 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + crashConnection ( ) ; 
 + } 
 + } 
 + 
 + private byte [ ] readBytes ( int count ) throws IOException { 
 + byte [ ] res = new byte [ count ] ; 
 + int offset = 0 ; 
 + while ( offset < res . length ) { 
 + int readed = inputStream . read ( res , offset , res . length - offset ) ; 
 + if ( readed > 0 ) { 
 + offset + = readed ; 
 + } else if ( readed < 0 ) { 
 + throw new IOException ( ) ; 
 + } else { 
 + Thread . yield ( ) ; 
 + } 
 + } 
 + return res ; 
 + } 
 + } 
 + } 
 diff - - git a / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnectionFactory . java b / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnectionFactory . java 
 new file mode 100644 
 index 0000000 . . f1eff48 
 - - - / dev / null 
 + + + b / library / actor - jvm / src / main / java / im / actor / model / jvm / tcp / AsyncTcpConnectionFactory . java 
 @ @ - 0 , 0 + 1 , 17 @ @ 
 + package im . actor . model . jvm . tcp ; 
 + 
 + import im . actor . model . network . ConnectionEndpoint ; 
 + import im . actor . model . network . connection . AsyncConnection ; 
 + import im . actor . model . network . connection . AsyncConnectionFactory ; 
 + import im . actor . model . network . connection . AsyncConnectionInterface ; 
 + 
 + / * * 
 + * Created by ex3ndr on 01 . 05 . 15 . 
 + * / 
 + public class AsyncTcpConnectionFactory implements AsyncConnectionFactory { 
 + 
 + @ Override 
 + public AsyncConnection createConnection ( int connectionId , ConnectionEndpoint endpoint , AsyncConnectionInterface connectionInterface ) { 
 + return new AsyncTcpConnection ( connectionId , endpoint , connectionInterface ) ; 
 + } 
 + }
