BLEU SCORE: 0.019146030690102508

TEST MSG: fix ( core + ios ) : Disabling Audio Routing and creation of media streams only after own user ready
GENERATED MSG: Merge branch ' core / perf / contacts '

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Utils / AAAudioRouter . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Utils / AAAudioRouter . swift < nl > index 0a7c3fa . . 1934a18 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Utils / AAAudioRouter . swift < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Utils / AAAudioRouter . swift < nl > @ @ - 88 , 35 + 88 , 35 @ @ public class AAAudioRouter { < nl > private func fixSession ( ) { < nl > let session = AVAudioSession . sharedInstance ( ) < nl > < nl > - if isManagingEnabled { < nl > - do { < nl > - if session . category ! = category { < nl > - try session . setCategory ( category ) < nl > - } < nl > - < nl > - if session . mode ! = mode { < nl > - try AVAudioSession . sharedInstance ( ) . setMode ( mode ) < nl > - } < nl > - < nl > - if let route : AVAudioSessionRouteDescription = session . currentRoute { < nl > - for port in route . outputs { < nl > - let portDescription : AVAudioSessionPortDescription = port as AVAudioSessionPortDescription < nl > - if ( self . currentRoute = = . Receiver & & portDescription . portType ! = AVAudioSessionPortBuiltInReceiver ) { < nl > - try session . overrideOutputAudioPort ( . None ) < nl > - } else if ( self . currentRoute = = . Speaker & & portDescription . portType ! = AVAudioSessionPortBuiltInSpeaker ) { < nl > - try session . overrideOutputAudioPort ( AVAudioSessionPortOverride . Speaker ) < nl > - } < nl > - } < nl > - } < nl > - } catch let error as NSError { < nl > - print ( " Audio Session : \ ( error . description ) " ) < nl > - } < nl > - < nl > - do { < nl > - try session . setActive ( isEnabled ) < nl > - } catch let error as NSError { < nl > - print ( " Audio Session : \ ( error . description ) " ) < nl > - } < nl > - } < nl > + / / if isManagingEnabled { < nl > + / / do { < nl > + / / if session . category ! = category { < nl > + / / try session . setCategory ( category ) < nl > + / / } < nl > + / / < nl > + / / if session . mode ! = mode { < nl > + / / try AVAudioSession . sharedInstance ( ) . setMode ( mode ) < nl > + / / } < nl > + / / < nl > + / / if let route : AVAudioSessionRouteDescription = session . currentRoute { < nl > + / / for port in route . outputs { < nl > + / / let portDescription : AVAudioSessionPortDescription = port as AVAudioSessionPortDescription < nl > + / / if ( self . currentRoute = = . Receiver & & portDescription . portType ! = AVAudioSessionPortBuiltInReceiver ) { < nl > + / / try session . overrideOutputAudioPort ( . None ) < nl > + / / } else if ( self . currentRoute = = . Speaker & & portDescription . portType ! = AVAudioSessionPortBuiltInSpeaker ) { < nl > + / / try session . overrideOutputAudioPort ( AVAudioSessionPortOverride . Speaker ) < nl > + / / } < nl > + / / } < nl > + / / } < nl > + / / } catch let error as NSError { < nl > + / / print ( " Audio Session : \ ( error . description ) " ) < nl > + / / } < nl > + / / < nl > + / / do { < nl > + / / try session . setActive ( isEnabled ) < nl > + / / } catch let error as NSError { < nl > + / / print ( " Audio Session : \ ( error . description ) " ) < nl > + / / } < nl > + / / } < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / calls / peers / PeerCallActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / calls / peers / PeerCallActor . java < nl > index 5d82b14 . . b892789 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / calls / peers / PeerCallActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / calls / peers / PeerCallActor . java < nl > @ @ - 39 , 6 + 39 , 7 @ @ public class PeerCallActor extends ModuleActor { < nl > / / State objects < nl > private boolean isOwnStarted = false ; < nl > private boolean isMuted = false ; < nl > + private boolean isOwnMediaStarted = false ; < nl > < nl > public PeerCallActor ( PeerCallCallback callback , PeerSettings selfSettings , ModuleContext context ) { < nl > super ( context ) ; < nl > @ @ - 50 , 22 + 51 , 26 @ @ public class PeerCallActor extends ModuleActor { < nl > public void preStart ( ) { < nl > super . preStart ( ) ; < nl > < nl > - WebRTC . getUserAudio ( ) . then ( new Consumer < WebRTCMediaStream > ( ) { < nl > - @ Override < nl > - public void apply ( WebRTCMediaStream webRTCMediaStream ) { < nl > - PeerCallActor . this . webRTCMediaStream = webRTCMediaStream ; < nl > - PeerCallActor . this . webRTCMediaStream . setEnabled ( isOwnStarted & & ! isMuted ) ; < nl > - for ( PeerNodeInt node : refs . values ( ) ) { < nl > - node . setOwnStream ( webRTCMediaStream ) ; < nl > - } < nl > - } < nl > - } ) . failure ( new Consumer < Exception > ( ) { < nl > - @ Override < nl > - public void apply ( Exception e ) { < nl > - Log . d ( TAG , " Unable to load audio " ) ; < nl > - self ( ) . send ( PoisonPill . INSTANCE ) ; < nl > - } < nl > - } ) . done ( self ( ) ) ; < nl > + / / if ( selfSettings . isPreConnectionEnabled ( ) ) { < nl > + / / < nl > + / / } < nl > + / / < nl > + / / WebRTC . getUserAudio ( ) . then ( new Consumer < WebRTCMediaStream > ( ) { < nl > + / / @ Override < nl > + / / public void apply ( WebRTCMediaStream webRTCMediaStream ) { < nl > + / / PeerCallActor . this . webRTCMediaStream = webRTCMediaStream ; < nl > + / / PeerCallActor . this . webRTCMediaStream . setEnabled ( isOwnStarted & & ! isMuted ) ; < nl > + / / for ( PeerNodeInt node : refs . values ( ) ) { < nl > + / / node . setOwnStream ( webRTCMediaStream ) ; < nl > + / / } < nl > + / / } < nl > + / / } ) . failure ( new Consumer < Exception > ( ) { < nl > + / / @ Override < nl > + / / public void apply ( Exception e ) { < nl > + / / Log . d ( TAG , " Unable to load audio " ) ; < nl > + / / self ( ) . send ( PoisonPill . INSTANCE ) ; < nl > + / / } < nl > + / / } ) . done ( self ( ) ) ; < nl > } < nl > < nl > / / < nl > @ @ - 84 , 9 + 89 , 27 @ @ public class PeerCallActor extends ModuleActor { < nl > return ; < nl > } < nl > isOwnStarted = true ; < nl > - if ( webRTCMediaStream ! = null ) { < nl > - webRTCMediaStream . setEnabled ( ! isMuted ) ; < nl > - } < nl > + < nl > + WebRTC . getUserAudio ( ) . then ( new Consumer < WebRTCMediaStream > ( ) { < nl > + @ Override < nl > + public void apply ( WebRTCMediaStream webRTCMediaStream ) { < nl > + PeerCallActor . this . webRTCMediaStream = webRTCMediaStream ; < nl > + PeerCallActor . this . webRTCMediaStream . setEnabled ( ! isMuted ) ; < nl > + for ( PeerNodeInt node : refs . values ( ) ) { < nl > + node . setOwnStream ( webRTCMediaStream ) ; < nl > + } < nl > + } < nl > + } ) . failure ( new Consumer < Exception > ( ) { < nl > + @ Override < nl > + public void apply ( Exception e ) { < nl > + Log . d ( TAG , " Unable to load audio " ) ; < nl > + self ( ) . send ( PoisonPill . INSTANCE ) ; < nl > + } < nl > + } ) . done ( self ( ) ) ; < nl > + / / < nl > + / / if ( webRTCMediaStream ! = null ) { < nl > + / / webRTCMediaStream . setEnabled ( ! isMuted ) ; < nl > + / / } < nl > } < nl > < nl > public void onMasterAdvertised ( List < ApiICEServer > iceServers ) {
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java < nl > index fa94c49 . . 91325c6 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java < nl > @ @ - 33 , 6 + 33 , 8 @ @ public abstract class AbsModule { < nl > public static final String STORAGE _ NOTIFICATIONS = " notifications " ; < nl > public static final String STORAGE _ SEARCH = " search " ; < nl > < nl > + public static final String STORAGE _ BOOK _ IMPORT = " book _ import " ; < nl > + < nl > public static final String STORAGE _ CHAT _ PREFIX = " chat _ " ; < nl > public static final String STORAGE _ CHAT _ MEDIA _ PREFIX = " chat _ media _ " ; < nl > public static final String STORAGE _ CHAT _ DOCS _ PREFIX = " chat _ docs _ " ; < nl > @ @ - 40 , 6 + 42 , 7 @ @ public abstract class AbsModule { < nl > public static final String STORAGE _ CHAT _ OUT = " chat _ pending _ out " ; < nl > public static final String STORAGE _ CURSOR = " chat _ cursor " ; < nl > < nl > + < nl > private ModuleContext context ; < nl > < nl > public AbsModule ( ModuleContext context ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java < nl > index e942cdc . . a7e3240 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java < nl > @ @ - 32 , 6 + 32 , 7 @ @ import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > import im . actor . core . network . RpcInternalException ; < nl > import im . actor . core . viewmodel . UserVM ; < nl > + import im . actor . runtime . storage . SyncKeyValue ; < nl > < nl > import static im . actor . runtime . actors . ActorSystem . system ; < nl > < nl > @ @ - 40 , 11 + 41 , 13 @ @ public class ContactsModule extends AbsModule { < nl > private ListEngine < Contact > contacts ; < nl > private ActorRef bookImportActor ; < nl > private ActorRef contactSyncActor ; < nl > + private SyncKeyValue bookImportState ; < nl > < nl > public ContactsModule ( final Modules modules ) { < nl > super ( modules ) ; < nl > < nl > contacts = Storage . createList ( STORAGE _ CONTACTS , Contact . CREATOR ) ; < nl > + bookImportState = new SyncKeyValue ( Storage . createKeyValue ( STORAGE _ BOOK _ IMPORT ) ) ; < nl > } < nl > < nl > public void run ( ) { < nl > @ @ - 62 , 6 + 65 , 10 @ @ public class ContactsModule extends AbsModule { < nl > } ) . changeDispatcher ( " heavy " ) , " actor / contacts _ sync " ) ; < nl > } < nl > < nl > + public SyncKeyValue getBookImportState ( ) { < nl > + return bookImportState ; < nl > + } < nl > + < nl > public ListEngine < Contact > getContacts ( ) { < nl > return contacts ; < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java < nl > index d06466a . . 2f23fc3 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java < nl > @ @ - 21 , 6 + 21 , 7 @ @ import im . actor . core . entity . PhoneBookContact ; < nl > import im . actor . core . entity . PhoneBookEmail ; < nl > import im . actor . core . entity . PhoneBookPhone ; < nl > import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . internal . contacts . entity . BookImportStorage ; < nl > import im . actor . core . modules . utils . ModuleActor ; < nl > import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > @ @ - 34 , 10 + 35 , 19 @ @ public class BookImportActor extends ModuleActor { < nl > < nl > private static final int MAX _ IMPORT _ SIZE = 50 ; < nl > < nl > + / / Reading Phone Book < nl > + private boolean phoneBookReadingIsInProgress = false ; < nl > + < nl > + / / Import Queue < nl > + private boolean isUploadingContacts = false ; < nl > + private ArrayList < ImportQueueItem > importQueue = new ArrayList < ImportQueueItem > ( ) ; < nl > + < nl > + / / Currently importing phones and emails < nl > private HashSet < Long > importingPhones = new HashSet < Long > ( ) ; < nl > private HashSet < String > importingEmails = new HashSet < String > ( ) ; < nl > < nl > - private boolean isSyncInProgress = false ; < nl > + / / Imported phones and emails < nl > + private BookImportStorage storage = new BookImportStorage ( ) ; < nl > < nl > public BookImportActor ( ModuleContext context ) { < nl > super ( context ) ; < nl > @ @ - 47 , 6 + 57 , 14 @ @ public class BookImportActor extends ModuleActor { < nl > @ Override < nl > public void preStart ( ) { < nl > super . preStart ( ) ; < nl > + byte [ ] data = context ( ) . getContactsModule ( ) . getBookImportState ( ) . get ( 0 ) ; < nl > + if ( data ! = null ) { < nl > + try { < nl > + storage = new BookImportStorage ( data ) ; < nl > + } catch ( Exception e ) { < nl > + e . getLocalizedMessage ( ) ; < nl > + } < nl > + } < nl > self ( ) . send ( new PerformSync ( ) ) ; < nl > } < nl > < nl > @ @ - 54 , 13 + 72 , 13 @ @ public class BookImportActor extends ModuleActor { < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Checking sync . . . " ) ; < nl > } < nl > - if ( isSyncInProgress ) { < nl > + if ( phoneBookReadingIsInProgress ) { < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Sync already in progress " ) ; < nl > } < nl > return ; < nl > } < nl > - isSyncInProgress = true ; < nl > + phoneBookReadingIsInProgress = true ; < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Starting book loading . . . " ) ; < nl > } < nl > @ @ - 75 , 161 + 93 , 161 @ @ public class BookImportActor extends ModuleActor { < nl > } < nl > < nl > private void onPhoneBookLoaded ( List < PhoneBookContact > phoneBook ) { < nl > - isSyncInProgress = false ; < nl > + phoneBookReadingIsInProgress = false ; < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Book load completed " ) ; < nl > } < nl > < nl > - ArrayList < ApiPhoneToImport > phoneToImports = new ArrayList < ApiPhoneToImport > ( ) ; < nl > - ArrayList < ApiEmailToImport > emailToImports = new ArrayList < ApiEmailToImport > ( ) ; < nl > + int newPhones = 0 ; < nl > + int newEmails = 0 ; < nl > for ( PhoneBookContact record : phoneBook ) { < nl > for ( PhoneBookPhone phone : record . getPhones ( ) ) { < nl > - if ( isImported ( phone . getNumber ( ) ) ) { < nl > + if ( storage . isImported ( phone . getNumber ( ) ) ) { < nl > continue ; < nl > } < nl > if ( importingPhones . contains ( phone . getNumber ( ) ) ) { < nl > continue ; < nl > } < nl > importingPhones . add ( phone . getNumber ( ) ) ; < nl > - phoneToImports . add ( new ApiPhoneToImport ( phone . getNumber ( ) , record . getName ( ) ) ) ; < nl > + importQueue . add ( new ImportPhoneQueueItem ( phone . getNumber ( ) , record . getName ( ) ) ) ; < nl > + newPhones + + ; < nl > } < nl > < nl > for ( PhoneBookEmail email : record . getEmails ( ) ) { < nl > - if ( isImported ( email . getEmail ( ) . toLowerCase ( ) ) ) { < nl > + if ( storage . isImported ( email . getEmail ( ) . toLowerCase ( ) ) ) { < nl > continue ; < nl > } < nl > if ( importingEmails . contains ( email . getEmail ( ) . toLowerCase ( ) ) ) { < nl > continue ; < nl > } < nl > importingEmails . add ( email . getEmail ( ) . toLowerCase ( ) ) ; < nl > - emailToImports . add ( new ApiEmailToImport ( email . getEmail ( ) . toLowerCase ( ) , record . getName ( ) ) ) ; < nl > + importQueue . add ( new ImportEmailQueueItem ( email . getEmail ( ) . toLowerCase ( ) , record . getName ( ) ) ) ; < nl > + newEmails + + ; < nl > } < nl > } < nl > < nl > - if ( phoneToImports . size ( ) = = 0 & & emailToImports . size ( ) = = 0 ) { < nl > - if ( ENABLE _ LOG ) { < nl > + if ( ENABLE _ LOG ) { < nl > + if ( newPhones = = 0 & & newEmails = = 0 ) { < nl > Log . d ( TAG , " No new contacts found " ) ; < nl > - } < nl > - markImported ( ) ; < nl > - return ; < nl > - } else { < nl > - if ( ENABLE _ LOG ) { < nl > - Log . d ( TAG , " Founded new " + ( phoneToImports . size ( ) + emailToImports . size ( ) ) + " contact records " ) ; < nl > + } else { < nl > + Log . d ( TAG , " Founded new " + ( newPhones + newEmails ) + " contact records " ) ; < nl > } < nl > } < nl > < nl > - ArrayList < ApiPhoneToImport > phoneToImportsPart = new ArrayList < ApiPhoneToImport > ( ) ; < nl > - ArrayList < ApiEmailToImport > emailToImportsPart = new ArrayList < ApiEmailToImport > ( ) ; < nl > - int count = 0 ; < nl > - for ( ApiPhoneToImport phoneToImport : phoneToImports ) { < nl > - phoneToImportsPart . add ( phoneToImport ) ; < nl > - count + + ; < nl > - if ( count > = MAX _ IMPORT _ SIZE ) { < nl > - performImport ( phoneToImportsPart , emailToImportsPart ) ; < nl > - phoneToImportsPart . clear ( ) ; < nl > - emailToImportsPart . clear ( ) ; < nl > - count = 0 ; < nl > - } < nl > - } < nl > - < nl > - for ( ApiEmailToImport emailToImport : emailToImports ) { < nl > - emailToImportsPart . add ( emailToImport ) ; < nl > - count + + ; < nl > - if ( count > = MAX _ IMPORT _ SIZE ) { < nl > - performImport ( phoneToImportsPart , emailToImportsPart ) ; < nl > - phoneToImportsPart . clear ( ) ; < nl > - emailToImportsPart . clear ( ) ; < nl > - count = 0 ; < nl > - } < nl > - } < nl > - < nl > - if ( count > 0 ) { < nl > - performImport ( phoneToImportsPart , emailToImportsPart ) ; < nl > - } < nl > + performImportIfRequired ( ) ; < nl > } < nl > < nl > - private void performImport ( ArrayList < ApiPhoneToImport > phoneToImportsPart , < nl > - ArrayList < ApiEmailToImport > emailToImportsPart ) { < nl > + private void performImportIfRequired ( ) { < nl > + < nl > + / / < nl > + / / Checking state < nl > + / / < nl > < nl > if ( ENABLE _ LOG ) { < nl > - Log . d ( TAG , " Performing import part with " + phoneToImportsPart . size ( ) + < nl > - " phones and " + emailToImportsPart . size ( ) + " emails " ) ; < nl > + Log . d ( TAG , " performImportIfRequired called " ) ; < nl > + } < nl > + if ( isUploadingContacts ) { < nl > + if ( ENABLE _ LOG ) { < nl > + Log . d ( TAG , " performImportIfRequired : exiting : already importing " ) ; < nl > + } < nl > + return ; < nl > } < nl > < nl > - final ApiPhoneToImport [ ] phones = phoneToImportsPart . toArray ( new ApiPhoneToImport [ phoneToImportsPart . size ( ) ] ) ; < nl > - final ApiEmailToImport [ ] emailToImports = emailToImportsPart . toArray ( new ApiEmailToImport [ emailToImportsPart . size ( ) ] ) ; < nl > + if ( importQueue . size ( ) = = 0 ) { < nl > + if ( ENABLE _ LOG ) { < nl > + Log . d ( TAG , " performImportIfRequired : exiting : nothing to import " ) ; < nl > + } < nl > + / / Marking as everything is imported < nl > + context ( ) . getAppStateModule ( ) . onBookImported ( ) ; < nl > + return ; < nl > + } < nl > < nl > - request ( new RequestImportContacts ( ( java . util . List < ApiPhoneToImport > ) phoneToImportsPart . clone ( ) , < nl > - ( java . util . List < ApiEmailToImport > ) emailToImportsPart . clone ( ) ) , new RpcCallback < ResponseImportContacts > ( ) { < nl > + / / < nl > + / / Performing import < nl > + / / < nl > + < nl > + isUploadingContacts = true ; < nl > + final ArrayList < ApiPhoneToImport > phoneToImports = new ArrayList < ApiPhoneToImport > ( ) ; < nl > + final ArrayList < ApiEmailToImport > emailToImports = new ArrayList < ApiEmailToImport > ( ) ; < nl > + for ( int i = 0 ; i < 50 & & importQueue . size ( ) > 0 ; i + + ) { < nl > + ImportQueueItem importQueueItem = importQueue . remove ( 0 ) ; < nl > + if ( importQueueItem instanceof ImportEmailQueueItem ) { < nl > + emailToImports . add ( new ApiEmailToImport ( ( ( ImportEmailQueueItem ) importQueueItem ) . getEmail ( ) , < nl > + ( ( ImportEmailQueueItem ) importQueueItem ) . getName ( ) ) ) ; < nl > + } else if ( importQueueItem instanceof ImportPhoneQueueItem ) { < nl > + phoneToImports . add ( new ApiPhoneToImport ( ( ( ImportPhoneQueueItem ) importQueueItem ) . getPhoneNumber ( ) , < nl > + ( ( ImportPhoneQueueItem ) importQueueItem ) . getName ( ) ) ) ; < nl > + } else { < nl > + throw new RuntimeException ( ) ; < nl > + } < nl > + } < nl > + request ( new RequestImportContacts ( phoneToImports , emailToImports ) , new RpcCallback < ResponseImportContacts > ( ) { < nl > @ Override < nl > public void onResult ( ResponseImportContacts response ) { < nl > - for ( ApiPhoneToImport phoneToImport : phones ) { < nl > - markImported ( phoneToImport . getPhoneNumber ( ) ) ; < nl > + < nl > + / / < nl > + / / Saving imported state < nl > + / / < nl > + < nl > + for ( ApiPhoneToImport phoneToImport : phoneToImports ) { < nl > + storage . markAsImported ( phoneToImport . getPhoneNumber ( ) ) ; < nl > importingPhones . remove ( phoneToImport . getPhoneNumber ( ) ) ; < nl > } < nl > for ( ApiEmailToImport emailToImport : emailToImports ) { < nl > - markImported ( emailToImport . getEmail ( ) ) ; < nl > + storage . markAsImported ( emailToImport . getEmail ( ) ) ; < nl > importingEmails . remove ( emailToImport . getEmail ( ) ) ; < nl > } < nl > + context ( ) . getContactsModule ( ) . getBookImportState ( ) . put ( 0 , storage . toByteArray ( ) ) ; < nl > < nl > - if ( importingEmails . size ( ) = = 0 & & importingPhones . size ( ) = = 0 ) { < nl > - markImported ( ) ; < nl > - } < nl > + / / < nl > + / / Generating update < nl > + / / < nl > + if ( response . getUsers ( ) . size ( ) ! = 0 ) { < nl > + if ( ENABLE _ LOG ) { < nl > + Log . d ( TAG , " Import success with " + response . getUsers ( ) . size ( ) + " new contacts " ) ; < nl > + } < nl > < nl > - if ( response . getUsers ( ) . size ( ) = = 0 ) { < nl > + ArrayList < Integer > uids = new ArrayList < Integer > ( ) ; < nl > + for ( ApiUser u : response . getUsers ( ) ) { < nl > + uids . add ( u . getId ( ) ) ; < nl > + } < nl > + updates ( ) . onUpdateReceived ( new FatSeqUpdate ( < nl > + response . getSeq ( ) , response . getState ( ) , < nl > + UpdateContactsAdded . HEADER , < nl > + new UpdateContactsAdded ( uids ) . toByteArray ( ) , < nl > + response . getUsers ( ) , < nl > + new ArrayList < ApiGroup > ( ) ) ) ; < nl > + } else { < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Import success , but no new contacts found " ) ; < nl > } < nl > - return ; < nl > - } < nl > - < nl > - if ( ENABLE _ LOG ) { < nl > - Log . d ( TAG , " Import success with " + response . getUsers ( ) . size ( ) + " new contacts " ) ; < nl > } < nl > < nl > - ArrayList < Integer > uids = new ArrayList < Integer > ( ) ; < nl > - for ( ApiUser u : response . getUsers ( ) ) { < nl > - uids . add ( u . getId ( ) ) ; < nl > - } < nl > - updates ( ) . onUpdateReceived ( new FatSeqUpdate ( < nl > - response . getSeq ( ) , response . getState ( ) , < nl > - UpdateContactsAdded . HEADER , < nl > - new UpdateContactsAdded ( uids ) . toByteArray ( ) , < nl > - response . getUsers ( ) , < nl > - new ArrayList < ApiGroup > ( ) ) ) ; < nl > + / / < nl > + / / Launching next iteration < nl > + / / < nl > + isUploadingContacts = false ; < nl > + performImportIfRequired ( ) ; < nl > } < nl > < nl > @ Override < nl > public void onError ( RpcException e ) { < nl > + < nl > / / TODO : Better error handling < nl > if ( ENABLE _ LOG ) { < nl > Log . d ( TAG , " Import failure " ) ; < nl > } < nl > e . printStackTrace ( ) ; < nl > + < nl > + / / < nl > + / / Launching next iteration < nl > + / / < nl > + isUploadingContacts = false ; < nl > + performImportIfRequired ( ) ; < nl > } < nl > } ) ; < nl > } < nl > < nl > - private boolean isImported ( long phone ) { < nl > - return preferences ( ) . getBool ( " book _ phone _ " + phone , false ) ; < nl > - } < nl > - < nl > - private boolean isImported ( String email ) { < nl > - return preferences ( ) . getBool ( " book _ email _ " + email . toLowerCase ( ) , false ) ; < nl > - } < nl > - < nl > - private void markImported ( long phone ) { < nl > - preferences ( ) . putBool ( " book _ phone _ " + phone , true ) ; < nl > - } < nl > - < nl > - private void markImported ( String email ) { < nl > - preferences ( ) . putBool ( " book _ email _ " + email . toLowerCase ( ) , true ) ; < nl > - } < nl > - < nl > - private void markImported ( ) { < nl > - context ( ) . getAppStateModule ( ) . onBookImported ( ) ; < nl > - } < nl > - < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > if ( message instanceof PerformSync ) { < nl > @ @ - 256 , 4 + 274 , 45 @ @ public class BookImportActor extends ModuleActor { < nl > return phoneBook ; < nl > } < nl > } < nl > + < nl > + private static abstract class ImportQueueItem { < nl > + < nl > + } < nl > + < nl > + private static class ImportPhoneQueueItem extends ImportQueueItem { < nl > + < nl > + private long phoneNumber ; < nl > + private String name ; < nl > + < nl > + public ImportPhoneQueueItem ( long phoneNumber , String name ) { < nl > + this . phoneNumber = phoneNumber ; < nl > + this . name = name ; < nl > + } < nl > + < nl > + public long getPhoneNumber ( ) { < nl > + return phoneNumber ; < nl > + } < nl > + < nl > + public String getName ( ) { < nl > + return name ; < nl > + } < nl > + } < nl > + < nl > + private static class ImportEmailQueueItem extends ImportQueueItem { < nl > + private String email ; < nl > + private String name ; < nl > + < nl > + public ImportEmailQueueItem ( String email , String name ) { < nl > + this . email = email ; < nl > + this . name = name ; < nl > + } < nl > + < nl > + public String getEmail ( ) { < nl > + return email ; < nl > + } < nl > + < nl > + public String getName ( ) { < nl > + return name ; < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / entity / BookImportStorage . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / entity / BookImportStorage . java < nl > new file mode 100644 < nl > index 0000000 . . 093eb8f < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / entity / BookImportStorage . java < nl > @ @ - 0 , 0 + 1 , 68 @ @ < nl > + package im . actor . core . modules . internal . contacts . entity ; < nl > + < nl > + import java . io . IOException ; < nl > + import java . util . HashSet ; < nl > + < nl > + import im . actor . runtime . bser . BserObject ; < nl > + import im . actor . runtime . bser . BserValues ; < nl > + import im . actor . runtime . bser . BserWriter ; < nl > + < nl > + public class BookImportStorage extends BserObject { < nl > + < nl > + private HashSet < String > importedEmails = new HashSet < String > ( ) ; < nl > + private HashSet < Long > importedPhones = new HashSet < Long > ( ) ; < nl > + < nl > + public BookImportStorage ( ) { < nl > + } < nl > + < nl > + public BookImportStorage ( byte [ ] data ) { < nl > + super ( ) ; < nl > + try { < nl > + super . load ( data ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + importedEmails = new HashSet < String > ( ) ; < nl > + importedPhones = new HashSet < Long > ( ) ; < nl > + } < nl > + } < nl > + < nl > + public void markAsImported ( String email ) { < nl > + importedEmails . add ( email ) ; < nl > + } < nl > + < nl > + public void markAsImported ( long phone ) { < nl > + importedPhones . add ( ( Long ) phone ) ; < nl > + } < nl > + < nl > + public boolean isImported ( String email ) { < nl > + return importedEmails . contains ( email ) ; < nl > + } < nl > + < nl > + public boolean isImported ( long phone ) { < nl > + return importedPhones . contains ( phone ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void parse ( BserValues values ) throws IOException { < nl > + importedEmails = new HashSet < String > ( ) ; < nl > + importedPhones = new HashSet < Long > ( ) ; < nl > + < nl > + for ( String s : values . getRepeatedString ( 1 ) ) { < nl > + importedEmails . add ( s ) ; < nl > + } < nl > + < nl > + for ( Long p : values . getRepeatedLong ( 2 ) ) { < nl > + importedPhones . add ( p ) ; < nl > + } < nl > + } < nl > + < nl > + @ Override < nl > + public void serialize ( BserWriter writer ) throws IOException { < nl > + for ( String s : importedEmails ) { < nl > + writer . writeString ( 1 , s ) ; < nl > + } < nl > + for ( Long p : importedPhones ) { < nl > + writer . writeLong ( 2 , p ) ; < nl > + } < nl > + } < nl > + }

TEST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Utils / AAAudioRouter . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Utils / AAAudioRouter . swift 
 index 0a7c3fa . . 1934a18 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Utils / AAAudioRouter . swift 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Utils / AAAudioRouter . swift 
 @ @ - 88 , 35 + 88 , 35 @ @ public class AAAudioRouter { 
 private func fixSession ( ) { 
 let session = AVAudioSession . sharedInstance ( ) 
 
 - if isManagingEnabled { 
 - do { 
 - if session . category ! = category { 
 - try session . setCategory ( category ) 
 - } 
 - 
 - if session . mode ! = mode { 
 - try AVAudioSession . sharedInstance ( ) . setMode ( mode ) 
 - } 
 - 
 - if let route : AVAudioSessionRouteDescription = session . currentRoute { 
 - for port in route . outputs { 
 - let portDescription : AVAudioSessionPortDescription = port as AVAudioSessionPortDescription 
 - if ( self . currentRoute = = . Receiver & & portDescription . portType ! = AVAudioSessionPortBuiltInReceiver ) { 
 - try session . overrideOutputAudioPort ( . None ) 
 - } else if ( self . currentRoute = = . Speaker & & portDescription . portType ! = AVAudioSessionPortBuiltInSpeaker ) { 
 - try session . overrideOutputAudioPort ( AVAudioSessionPortOverride . Speaker ) 
 - } 
 - } 
 - } 
 - } catch let error as NSError { 
 - print ( " Audio Session : \ ( error . description ) " ) 
 - } 
 - 
 - do { 
 - try session . setActive ( isEnabled ) 
 - } catch let error as NSError { 
 - print ( " Audio Session : \ ( error . description ) " ) 
 - } 
 - } 
 + / / if isManagingEnabled { 
 + / / do { 
 + / / if session . category ! = category { 
 + / / try session . setCategory ( category ) 
 + / / } 
 + / / 
 + / / if session . mode ! = mode { 
 + / / try AVAudioSession . sharedInstance ( ) . setMode ( mode ) 
 + / / } 
 + / / 
 + / / if let route : AVAudioSessionRouteDescription = session . currentRoute { 
 + / / for port in route . outputs { 
 + / / let portDescription : AVAudioSessionPortDescription = port as AVAudioSessionPortDescription 
 + / / if ( self . currentRoute = = . Receiver & & portDescription . portType ! = AVAudioSessionPortBuiltInReceiver ) { 
 + / / try session . overrideOutputAudioPort ( . None ) 
 + / / } else if ( self . currentRoute = = . Speaker & & portDescription . portType ! = AVAudioSessionPortBuiltInSpeaker ) { 
 + / / try session . overrideOutputAudioPort ( AVAudioSessionPortOverride . Speaker ) 
 + / / } 
 + / / } 
 + / / } 
 + / / } catch let error as NSError { 
 + / / print ( " Audio Session : \ ( error . description ) " ) 
 + / / } 
 + / / 
 + / / do { 
 + / / try session . setActive ( isEnabled ) 
 + / / } catch let error as NSError { 
 + / / print ( " Audio Session : \ ( error . description ) " ) 
 + / / } 
 + / / } 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / calls / peers / PeerCallActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / calls / peers / PeerCallActor . java 
 index 5d82b14 . . b892789 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / calls / peers / PeerCallActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / calls / peers / PeerCallActor . java 
 @ @ - 39 , 6 + 39 , 7 @ @ public class PeerCallActor extends ModuleActor { 
 / / State objects 
 private boolean isOwnStarted = false ; 
 private boolean isMuted = false ; 
 + private boolean isOwnMediaStarted = false ; 
 
 public PeerCallActor ( PeerCallCallback callback , PeerSettings selfSettings , ModuleContext context ) { 
 super ( context ) ; 
 @ @ - 50 , 22 + 51 , 26 @ @ public class PeerCallActor extends ModuleActor { 
 public void preStart ( ) { 
 super . preStart ( ) ; 
 
 - WebRTC . getUserAudio ( ) . then ( new Consumer < WebRTCMediaStream > ( ) { 
 - @ Override 
 - public void apply ( WebRTCMediaStream webRTCMediaStream ) { 
 - PeerCallActor . this . webRTCMediaStream = webRTCMediaStream ; 
 - PeerCallActor . this . webRTCMediaStream . setEnabled ( isOwnStarted & & ! isMuted ) ; 
 - for ( PeerNodeInt node : refs . values ( ) ) { 
 - node . setOwnStream ( webRTCMediaStream ) ; 
 - } 
 - } 
 - } ) . failure ( new Consumer < Exception > ( ) { 
 - @ Override 
 - public void apply ( Exception e ) { 
 - Log . d ( TAG , " Unable to load audio " ) ; 
 - self ( ) . send ( PoisonPill . INSTANCE ) ; 
 - } 
 - } ) . done ( self ( ) ) ; 
 + / / if ( selfSettings . isPreConnectionEnabled ( ) ) { 
 + / / 
 + / / } 
 + / / 
 + / / WebRTC . getUserAudio ( ) . then ( new Consumer < WebRTCMediaStream > ( ) { 
 + / / @ Override 
 + / / public void apply ( WebRTCMediaStream webRTCMediaStream ) { 
 + / / PeerCallActor . this . webRTCMediaStream = webRTCMediaStream ; 
 + / / PeerCallActor . this . webRTCMediaStream . setEnabled ( isOwnStarted & & ! isMuted ) ; 
 + / / for ( PeerNodeInt node : refs . values ( ) ) { 
 + / / node . setOwnStream ( webRTCMediaStream ) ; 
 + / / } 
 + / / } 
 + / / } ) . failure ( new Consumer < Exception > ( ) { 
 + / / @ Override 
 + / / public void apply ( Exception e ) { 
 + / / Log . d ( TAG , " Unable to load audio " ) ; 
 + / / self ( ) . send ( PoisonPill . INSTANCE ) ; 
 + / / } 
 + / / } ) . done ( self ( ) ) ; 
 } 
 
 / / 
 @ @ - 84 , 9 + 89 , 27 @ @ public class PeerCallActor extends ModuleActor { 
 return ; 
 } 
 isOwnStarted = true ; 
 - if ( webRTCMediaStream ! = null ) { 
 - webRTCMediaStream . setEnabled ( ! isMuted ) ; 
 - } 
 + 
 + WebRTC . getUserAudio ( ) . then ( new Consumer < WebRTCMediaStream > ( ) { 
 + @ Override 
 + public void apply ( WebRTCMediaStream webRTCMediaStream ) { 
 + PeerCallActor . this . webRTCMediaStream = webRTCMediaStream ; 
 + PeerCallActor . this . webRTCMediaStream . setEnabled ( ! isMuted ) ; 
 + for ( PeerNodeInt node : refs . values ( ) ) { 
 + node . setOwnStream ( webRTCMediaStream ) ; 
 + } 
 + } 
 + } ) . failure ( new Consumer < Exception > ( ) { 
 + @ Override 
 + public void apply ( Exception e ) { 
 + Log . d ( TAG , " Unable to load audio " ) ; 
 + self ( ) . send ( PoisonPill . INSTANCE ) ; 
 + } 
 + } ) . done ( self ( ) ) ; 
 + / / 
 + / / if ( webRTCMediaStream ! = null ) { 
 + / / webRTCMediaStream . setEnabled ( ! isMuted ) ; 
 + / / } 
 } 
 
 public void onMasterAdvertised ( List < ApiICEServer > iceServers ) {

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java 
 index fa94c49 . . 91325c6 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / AbsModule . java 
 @ @ - 33 , 6 + 33 , 8 @ @ public abstract class AbsModule { 
 public static final String STORAGE _ NOTIFICATIONS = " notifications " ; 
 public static final String STORAGE _ SEARCH = " search " ; 
 
 + public static final String STORAGE _ BOOK _ IMPORT = " book _ import " ; 
 + 
 public static final String STORAGE _ CHAT _ PREFIX = " chat _ " ; 
 public static final String STORAGE _ CHAT _ MEDIA _ PREFIX = " chat _ media _ " ; 
 public static final String STORAGE _ CHAT _ DOCS _ PREFIX = " chat _ docs _ " ; 
 @ @ - 40 , 6 + 42 , 7 @ @ public abstract class AbsModule { 
 public static final String STORAGE _ CHAT _ OUT = " chat _ pending _ out " ; 
 public static final String STORAGE _ CURSOR = " chat _ cursor " ; 
 
 + 
 private ModuleContext context ; 
 
 public AbsModule ( ModuleContext context ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java 
 index e942cdc . . a7e3240 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / ContactsModule . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 import im . actor . core . network . RpcInternalException ; 
 import im . actor . core . viewmodel . UserVM ; 
 + import im . actor . runtime . storage . SyncKeyValue ; 
 
 import static im . actor . runtime . actors . ActorSystem . system ; 
 
 @ @ - 40 , 11 + 41 , 13 @ @ public class ContactsModule extends AbsModule { 
 private ListEngine < Contact > contacts ; 
 private ActorRef bookImportActor ; 
 private ActorRef contactSyncActor ; 
 + private SyncKeyValue bookImportState ; 
 
 public ContactsModule ( final Modules modules ) { 
 super ( modules ) ; 
 
 contacts = Storage . createList ( STORAGE _ CONTACTS , Contact . CREATOR ) ; 
 + bookImportState = new SyncKeyValue ( Storage . createKeyValue ( STORAGE _ BOOK _ IMPORT ) ) ; 
 } 
 
 public void run ( ) { 
 @ @ - 62 , 6 + 65 , 10 @ @ public class ContactsModule extends AbsModule { 
 } ) . changeDispatcher ( " heavy " ) , " actor / contacts _ sync " ) ; 
 } 
 
 + public SyncKeyValue getBookImportState ( ) { 
 + return bookImportState ; 
 + } 
 + 
 public ListEngine < Contact > getContacts ( ) { 
 return contacts ; 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java 
 index d06466a . . 2f23fc3 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / BookImportActor . java 
 @ @ - 21 , 6 + 21 , 7 @ @ import im . actor . core . entity . PhoneBookContact ; 
 import im . actor . core . entity . PhoneBookEmail ; 
 import im . actor . core . entity . PhoneBookPhone ; 
 import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . internal . contacts . entity . BookImportStorage ; 
 import im . actor . core . modules . utils . ModuleActor ; 
 import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 @ @ - 34 , 10 + 35 , 19 @ @ public class BookImportActor extends ModuleActor { 
 
 private static final int MAX _ IMPORT _ SIZE = 50 ; 
 
 + / / Reading Phone Book 
 + private boolean phoneBookReadingIsInProgress = false ; 
 + 
 + / / Import Queue 
 + private boolean isUploadingContacts = false ; 
 + private ArrayList < ImportQueueItem > importQueue = new ArrayList < ImportQueueItem > ( ) ; 
 + 
 + / / Currently importing phones and emails 
 private HashSet < Long > importingPhones = new HashSet < Long > ( ) ; 
 private HashSet < String > importingEmails = new HashSet < String > ( ) ; 
 
 - private boolean isSyncInProgress = false ; 
 + / / Imported phones and emails 
 + private BookImportStorage storage = new BookImportStorage ( ) ; 
 
 public BookImportActor ( ModuleContext context ) { 
 super ( context ) ; 
 @ @ - 47 , 6 + 57 , 14 @ @ public class BookImportActor extends ModuleActor { 
 @ Override 
 public void preStart ( ) { 
 super . preStart ( ) ; 
 + byte [ ] data = context ( ) . getContactsModule ( ) . getBookImportState ( ) . get ( 0 ) ; 
 + if ( data ! = null ) { 
 + try { 
 + storage = new BookImportStorage ( data ) ; 
 + } catch ( Exception e ) { 
 + e . getLocalizedMessage ( ) ; 
 + } 
 + } 
 self ( ) . send ( new PerformSync ( ) ) ; 
 } 
 
 @ @ - 54 , 13 + 72 , 13 @ @ public class BookImportActor extends ModuleActor { 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Checking sync . . . " ) ; 
 } 
 - if ( isSyncInProgress ) { 
 + if ( phoneBookReadingIsInProgress ) { 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Sync already in progress " ) ; 
 } 
 return ; 
 } 
 - isSyncInProgress = true ; 
 + phoneBookReadingIsInProgress = true ; 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Starting book loading . . . " ) ; 
 } 
 @ @ - 75 , 161 + 93 , 161 @ @ public class BookImportActor extends ModuleActor { 
 } 
 
 private void onPhoneBookLoaded ( List < PhoneBookContact > phoneBook ) { 
 - isSyncInProgress = false ; 
 + phoneBookReadingIsInProgress = false ; 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Book load completed " ) ; 
 } 
 
 - ArrayList < ApiPhoneToImport > phoneToImports = new ArrayList < ApiPhoneToImport > ( ) ; 
 - ArrayList < ApiEmailToImport > emailToImports = new ArrayList < ApiEmailToImport > ( ) ; 
 + int newPhones = 0 ; 
 + int newEmails = 0 ; 
 for ( PhoneBookContact record : phoneBook ) { 
 for ( PhoneBookPhone phone : record . getPhones ( ) ) { 
 - if ( isImported ( phone . getNumber ( ) ) ) { 
 + if ( storage . isImported ( phone . getNumber ( ) ) ) { 
 continue ; 
 } 
 if ( importingPhones . contains ( phone . getNumber ( ) ) ) { 
 continue ; 
 } 
 importingPhones . add ( phone . getNumber ( ) ) ; 
 - phoneToImports . add ( new ApiPhoneToImport ( phone . getNumber ( ) , record . getName ( ) ) ) ; 
 + importQueue . add ( new ImportPhoneQueueItem ( phone . getNumber ( ) , record . getName ( ) ) ) ; 
 + newPhones + + ; 
 } 
 
 for ( PhoneBookEmail email : record . getEmails ( ) ) { 
 - if ( isImported ( email . getEmail ( ) . toLowerCase ( ) ) ) { 
 + if ( storage . isImported ( email . getEmail ( ) . toLowerCase ( ) ) ) { 
 continue ; 
 } 
 if ( importingEmails . contains ( email . getEmail ( ) . toLowerCase ( ) ) ) { 
 continue ; 
 } 
 importingEmails . add ( email . getEmail ( ) . toLowerCase ( ) ) ; 
 - emailToImports . add ( new ApiEmailToImport ( email . getEmail ( ) . toLowerCase ( ) , record . getName ( ) ) ) ; 
 + importQueue . add ( new ImportEmailQueueItem ( email . getEmail ( ) . toLowerCase ( ) , record . getName ( ) ) ) ; 
 + newEmails + + ; 
 } 
 } 
 
 - if ( phoneToImports . size ( ) = = 0 & & emailToImports . size ( ) = = 0 ) { 
 - if ( ENABLE _ LOG ) { 
 + if ( ENABLE _ LOG ) { 
 + if ( newPhones = = 0 & & newEmails = = 0 ) { 
 Log . d ( TAG , " No new contacts found " ) ; 
 - } 
 - markImported ( ) ; 
 - return ; 
 - } else { 
 - if ( ENABLE _ LOG ) { 
 - Log . d ( TAG , " Founded new " + ( phoneToImports . size ( ) + emailToImports . size ( ) ) + " contact records " ) ; 
 + } else { 
 + Log . d ( TAG , " Founded new " + ( newPhones + newEmails ) + " contact records " ) ; 
 } 
 } 
 
 - ArrayList < ApiPhoneToImport > phoneToImportsPart = new ArrayList < ApiPhoneToImport > ( ) ; 
 - ArrayList < ApiEmailToImport > emailToImportsPart = new ArrayList < ApiEmailToImport > ( ) ; 
 - int count = 0 ; 
 - for ( ApiPhoneToImport phoneToImport : phoneToImports ) { 
 - phoneToImportsPart . add ( phoneToImport ) ; 
 - count + + ; 
 - if ( count > = MAX _ IMPORT _ SIZE ) { 
 - performImport ( phoneToImportsPart , emailToImportsPart ) ; 
 - phoneToImportsPart . clear ( ) ; 
 - emailToImportsPart . clear ( ) ; 
 - count = 0 ; 
 - } 
 - } 
 - 
 - for ( ApiEmailToImport emailToImport : emailToImports ) { 
 - emailToImportsPart . add ( emailToImport ) ; 
 - count + + ; 
 - if ( count > = MAX _ IMPORT _ SIZE ) { 
 - performImport ( phoneToImportsPart , emailToImportsPart ) ; 
 - phoneToImportsPart . clear ( ) ; 
 - emailToImportsPart . clear ( ) ; 
 - count = 0 ; 
 - } 
 - } 
 - 
 - if ( count > 0 ) { 
 - performImport ( phoneToImportsPart , emailToImportsPart ) ; 
 - } 
 + performImportIfRequired ( ) ; 
 } 
 
 - private void performImport ( ArrayList < ApiPhoneToImport > phoneToImportsPart , 
 - ArrayList < ApiEmailToImport > emailToImportsPart ) { 
 + private void performImportIfRequired ( ) { 
 + 
 + / / 
 + / / Checking state 
 + / / 
 
 if ( ENABLE _ LOG ) { 
 - Log . d ( TAG , " Performing import part with " + phoneToImportsPart . size ( ) + 
 - " phones and " + emailToImportsPart . size ( ) + " emails " ) ; 
 + Log . d ( TAG , " performImportIfRequired called " ) ; 
 + } 
 + if ( isUploadingContacts ) { 
 + if ( ENABLE _ LOG ) { 
 + Log . d ( TAG , " performImportIfRequired : exiting : already importing " ) ; 
 + } 
 + return ; 
 } 
 
 - final ApiPhoneToImport [ ] phones = phoneToImportsPart . toArray ( new ApiPhoneToImport [ phoneToImportsPart . size ( ) ] ) ; 
 - final ApiEmailToImport [ ] emailToImports = emailToImportsPart . toArray ( new ApiEmailToImport [ emailToImportsPart . size ( ) ] ) ; 
 + if ( importQueue . size ( ) = = 0 ) { 
 + if ( ENABLE _ LOG ) { 
 + Log . d ( TAG , " performImportIfRequired : exiting : nothing to import " ) ; 
 + } 
 + / / Marking as everything is imported 
 + context ( ) . getAppStateModule ( ) . onBookImported ( ) ; 
 + return ; 
 + } 
 
 - request ( new RequestImportContacts ( ( java . util . List < ApiPhoneToImport > ) phoneToImportsPart . clone ( ) , 
 - ( java . util . List < ApiEmailToImport > ) emailToImportsPart . clone ( ) ) , new RpcCallback < ResponseImportContacts > ( ) { 
 + / / 
 + / / Performing import 
 + / / 
 + 
 + isUploadingContacts = true ; 
 + final ArrayList < ApiPhoneToImport > phoneToImports = new ArrayList < ApiPhoneToImport > ( ) ; 
 + final ArrayList < ApiEmailToImport > emailToImports = new ArrayList < ApiEmailToImport > ( ) ; 
 + for ( int i = 0 ; i < 50 & & importQueue . size ( ) > 0 ; i + + ) { 
 + ImportQueueItem importQueueItem = importQueue . remove ( 0 ) ; 
 + if ( importQueueItem instanceof ImportEmailQueueItem ) { 
 + emailToImports . add ( new ApiEmailToImport ( ( ( ImportEmailQueueItem ) importQueueItem ) . getEmail ( ) , 
 + ( ( ImportEmailQueueItem ) importQueueItem ) . getName ( ) ) ) ; 
 + } else if ( importQueueItem instanceof ImportPhoneQueueItem ) { 
 + phoneToImports . add ( new ApiPhoneToImport ( ( ( ImportPhoneQueueItem ) importQueueItem ) . getPhoneNumber ( ) , 
 + ( ( ImportPhoneQueueItem ) importQueueItem ) . getName ( ) ) ) ; 
 + } else { 
 + throw new RuntimeException ( ) ; 
 + } 
 + } 
 + request ( new RequestImportContacts ( phoneToImports , emailToImports ) , new RpcCallback < ResponseImportContacts > ( ) { 
 @ Override 
 public void onResult ( ResponseImportContacts response ) { 
 - for ( ApiPhoneToImport phoneToImport : phones ) { 
 - markImported ( phoneToImport . getPhoneNumber ( ) ) ; 
 + 
 + / / 
 + / / Saving imported state 
 + / / 
 + 
 + for ( ApiPhoneToImport phoneToImport : phoneToImports ) { 
 + storage . markAsImported ( phoneToImport . getPhoneNumber ( ) ) ; 
 importingPhones . remove ( phoneToImport . getPhoneNumber ( ) ) ; 
 } 
 for ( ApiEmailToImport emailToImport : emailToImports ) { 
 - markImported ( emailToImport . getEmail ( ) ) ; 
 + storage . markAsImported ( emailToImport . getEmail ( ) ) ; 
 importingEmails . remove ( emailToImport . getEmail ( ) ) ; 
 } 
 + context ( ) . getContactsModule ( ) . getBookImportState ( ) . put ( 0 , storage . toByteArray ( ) ) ; 
 
 - if ( importingEmails . size ( ) = = 0 & & importingPhones . size ( ) = = 0 ) { 
 - markImported ( ) ; 
 - } 
 + / / 
 + / / Generating update 
 + / / 
 + if ( response . getUsers ( ) . size ( ) ! = 0 ) { 
 + if ( ENABLE _ LOG ) { 
 + Log . d ( TAG , " Import success with " + response . getUsers ( ) . size ( ) + " new contacts " ) ; 
 + } 
 
 - if ( response . getUsers ( ) . size ( ) = = 0 ) { 
 + ArrayList < Integer > uids = new ArrayList < Integer > ( ) ; 
 + for ( ApiUser u : response . getUsers ( ) ) { 
 + uids . add ( u . getId ( ) ) ; 
 + } 
 + updates ( ) . onUpdateReceived ( new FatSeqUpdate ( 
 + response . getSeq ( ) , response . getState ( ) , 
 + UpdateContactsAdded . HEADER , 
 + new UpdateContactsAdded ( uids ) . toByteArray ( ) , 
 + response . getUsers ( ) , 
 + new ArrayList < ApiGroup > ( ) ) ) ; 
 + } else { 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Import success , but no new contacts found " ) ; 
 } 
 - return ; 
 - } 
 - 
 - if ( ENABLE _ LOG ) { 
 - Log . d ( TAG , " Import success with " + response . getUsers ( ) . size ( ) + " new contacts " ) ; 
 } 
 
 - ArrayList < Integer > uids = new ArrayList < Integer > ( ) ; 
 - for ( ApiUser u : response . getUsers ( ) ) { 
 - uids . add ( u . getId ( ) ) ; 
 - } 
 - updates ( ) . onUpdateReceived ( new FatSeqUpdate ( 
 - response . getSeq ( ) , response . getState ( ) , 
 - UpdateContactsAdded . HEADER , 
 - new UpdateContactsAdded ( uids ) . toByteArray ( ) , 
 - response . getUsers ( ) , 
 - new ArrayList < ApiGroup > ( ) ) ) ; 
 + / / 
 + / / Launching next iteration 
 + / / 
 + isUploadingContacts = false ; 
 + performImportIfRequired ( ) ; 
 } 
 
 @ Override 
 public void onError ( RpcException e ) { 
 + 
 / / TODO : Better error handling 
 if ( ENABLE _ LOG ) { 
 Log . d ( TAG , " Import failure " ) ; 
 } 
 e . printStackTrace ( ) ; 
 + 
 + / / 
 + / / Launching next iteration 
 + / / 
 + isUploadingContacts = false ; 
 + performImportIfRequired ( ) ; 
 } 
 } ) ; 
 } 
 
 - private boolean isImported ( long phone ) { 
 - return preferences ( ) . getBool ( " book _ phone _ " + phone , false ) ; 
 - } 
 - 
 - private boolean isImported ( String email ) { 
 - return preferences ( ) . getBool ( " book _ email _ " + email . toLowerCase ( ) , false ) ; 
 - } 
 - 
 - private void markImported ( long phone ) { 
 - preferences ( ) . putBool ( " book _ phone _ " + phone , true ) ; 
 - } 
 - 
 - private void markImported ( String email ) { 
 - preferences ( ) . putBool ( " book _ email _ " + email . toLowerCase ( ) , true ) ; 
 - } 
 - 
 - private void markImported ( ) { 
 - context ( ) . getAppStateModule ( ) . onBookImported ( ) ; 
 - } 
 - 
 @ Override 
 public void onReceive ( Object message ) { 
 if ( message instanceof PerformSync ) { 
 @ @ - 256 , 4 + 274 , 45 @ @ public class BookImportActor extends ModuleActor { 
 return phoneBook ; 
 } 
 } 
 + 
 + private static abstract class ImportQueueItem { 
 + 
 + } 
 + 
 + private static class ImportPhoneQueueItem extends ImportQueueItem { 
 + 
 + private long phoneNumber ; 
 + private String name ; 
 + 
 + public ImportPhoneQueueItem ( long phoneNumber , String name ) { 
 + this . phoneNumber = phoneNumber ; 
 + this . name = name ; 
 + } 
 + 
 + public long getPhoneNumber ( ) { 
 + return phoneNumber ; 
 + } 
 + 
 + public String getName ( ) { 
 + return name ; 
 + } 
 + } 
 + 
 + private static class ImportEmailQueueItem extends ImportQueueItem { 
 + private String email ; 
 + private String name ; 
 + 
 + public ImportEmailQueueItem ( String email , String name ) { 
 + this . email = email ; 
 + this . name = name ; 
 + } 
 + 
 + public String getEmail ( ) { 
 + return email ; 
 + } 
 + 
 + public String getName ( ) { 
 + return name ; 
 + } 
 + } 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / entity / BookImportStorage . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / entity / BookImportStorage . java 
 new file mode 100644 
 index 0000000 . . 093eb8f 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / contacts / entity / BookImportStorage . java 
 @ @ - 0 , 0 + 1 , 68 @ @ 
 + package im . actor . core . modules . internal . contacts . entity ; 
 + 
 + import java . io . IOException ; 
 + import java . util . HashSet ; 
 + 
 + import im . actor . runtime . bser . BserObject ; 
 + import im . actor . runtime . bser . BserValues ; 
 + import im . actor . runtime . bser . BserWriter ; 
 + 
 + public class BookImportStorage extends BserObject { 
 + 
 + private HashSet < String > importedEmails = new HashSet < String > ( ) ; 
 + private HashSet < Long > importedPhones = new HashSet < Long > ( ) ; 
 + 
 + public BookImportStorage ( ) { 
 + } 
 + 
 + public BookImportStorage ( byte [ ] data ) { 
 + super ( ) ; 
 + try { 
 + super . load ( data ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + importedEmails = new HashSet < String > ( ) ; 
 + importedPhones = new HashSet < Long > ( ) ; 
 + } 
 + } 
 + 
 + public void markAsImported ( String email ) { 
 + importedEmails . add ( email ) ; 
 + } 
 + 
 + public void markAsImported ( long phone ) { 
 + importedPhones . add ( ( Long ) phone ) ; 
 + } 
 + 
 + public boolean isImported ( String email ) { 
 + return importedEmails . contains ( email ) ; 
 + } 
 + 
 + public boolean isImported ( long phone ) { 
 + return importedPhones . contains ( phone ) ; 
 + } 
 + 
 + @ Override 
 + public void parse ( BserValues values ) throws IOException { 
 + importedEmails = new HashSet < String > ( ) ; 
 + importedPhones = new HashSet < Long > ( ) ; 
 + 
 + for ( String s : values . getRepeatedString ( 1 ) ) { 
 + importedEmails . add ( s ) ; 
 + } 
 + 
 + for ( Long p : values . getRepeatedLong ( 2 ) ) { 
 + importedPhones . add ( p ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void serialize ( BserWriter writer ) throws IOException { 
 + for ( String s : importedEmails ) { 
 + writer . writeString ( 1 , s ) ; 
 + } 
 + for ( Long p : importedPhones ) { 
 + writer . writeLong ( 2 , p ) ; 
 + } 
 + } 
 + }
