BLEU SCORE: 0.09952907986722619

TEST MSG: fix ( server ) : dont add peers to DMs or groups if it is already in favourites
GENERATED MSG: fix ( server : messaging ) : create dialog on WriteMessageSelf , DM and Group dialog groups by default

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > index d44f926 . . 4a216fb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > @ @ - 61 , 11 + 61 , 13 @ @ private [ dialog ] case class ActiveDialogs ( < nl > dms : SortedSet [ SortableDialog ] < nl > ) { < nl > def withPeer ( sd : SortableDialog ) = { < nl > - sd . peer . typ match { < nl > - case PeerType . Private ⇒ copy ( dms = dms + sd ) < nl > - case PeerType . Group ⇒ copy ( groups = groups + sd ) < nl > - case unknown ⇒ throw new PeerErrors . UnknownPeerType ( unknown ) < nl > - } < nl > + if ( favourites . exists ( _ . peer = = sd . peer ) ) this < nl > + else < nl > + sd . peer . typ match { < nl > + case PeerType . Private ⇒ copy ( dms = dms + sd ) < nl > + case PeerType . Group ⇒ copy ( groups = groups + sd ) < nl > + case unknown ⇒ throw new PeerErrors . UnknownPeerType ( unknown ) < nl > + } < nl > } < nl > < nl > def withoutPeer ( sd : SortableDialog ) = { < nl > @ @ - 157 , 27 + 159 , 28 @ @ private [ dialog ] final case class DialogRootState ( < nl > } < nl > < nl > private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - val sortableDialog = SortableDialog ( ts , peer ) < nl > - < nl > if ( this . activePeers . exists ( _ . ts = = ts ) ) withShownPeer ( ts . plusMillis ( 1 ) , peer ) < nl > - else < nl > + else { < nl > + val sortableDialog = SortableDialog ( ts , peer ) < nl > + < nl > copy ( < nl > activePeers = this . activePeers + sortableDialog , < nl > active = this . active . withPeer ( sortableDialog ) , < nl > - archived = this . archived - sortableDialog < nl > + archived = this . archived . filterNot ( _ . peer = = peer ) < nl > ) < nl > + } < nl > } < nl > < nl > private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - val sortableDialog = SortableDialog ( ts , peer ) < nl > - < nl > if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > - else < nl > + else { < nl > + val sortableDialog = SortableDialog ( ts , peer ) < nl > copy ( < nl > - activePeers = this . activePeers - sortableDialog , < nl > + activePeers = this . activePeers . filterNot ( _ . peer = = peer ) , < nl > active = this . active . withoutPeer ( sortableDialog ) , < nl > archived = this . archived + sortableDialog < nl > ) < nl > + } < nl > } < nl > < nl > private def withFavouritedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > index 98d293b . . d10b303 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > @ @ - 14 , 6 + 14 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > it should " remove from Archived on Favourite or new message " in removeFromArchived < nl > it should " archive groups and DMs " in archive < nl > it should " order archived by date desc " in archivedOrder < nl > + it should " not add to DMs or groups if already in favourites " in keepInFavourites < nl > < nl > import DialogRootEvents . _ < nl > < nl > @ @ - 46 , 6 + 47 , 23 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > checkSnapshot < nl > } < nl > < nl > + def keepInFavourites ( ) = { < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + < nl > + val alice = Peer . privat ( 1 ) < nl > + val group = Peer . group ( 100 ) < nl > + < nl > + probe . commit ( Favourited ( Instant . now , Some ( alice ) ) ) < nl > + probe . commit ( Favourited ( Instant . now , Some ( group ) ) ) < nl > + probe . commit ( Created ( Instant . now , Some ( alice ) ) ) < nl > + probe . commit ( Created ( Instant . now , Some ( group ) ) ) < nl > + < nl > + probe . state . active . dms shouldBe empty < nl > + probe . state . active . dms shouldBe empty < nl > + probe . state . active . favourites . map ( _ . peer ) . toSeq should be ( Seq ( alice , group ) ) < nl > + probe . state . activePeers . map ( _ . peer ) . toSeq should be ( Seq ( alice , group ) ) < nl > + } < nl > + < nl > def removeFromArchived ( ) = { < nl > implicit val probe = ProcessorStateProbe ( DialogRootState . initial )
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index 652fad2 . . cf67226 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 7 , 7 + 7 , 7 @ @ import akka . pattern . { ask , pipe } < nl > import akka . util . Timeout < nl > import im . actor . concurrent . _ < nl > import im . actor . server . cqrs . _ < nl > - import im . actor . server . dialog . DialogCommands . SendMessage < nl > + import im . actor . server . dialog . DialogCommands . { SendMessage , WriteMessageSelf } < nl > import im . actor . server . model . { Peer , PeerType } < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . messaging . UpdateChatGroupsChanged < nl > @ @ - 179 , 7 + 179 , 14 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > < nl > override def persistenceId : String = s " DialogRoot _ $ userId " < nl > < nl > - override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , SortedSet . empty ( SortableDialog . ordering ) , SortedSet . empty ( SortableDialog . ordering ) ) < nl > + override protected def getInitialState : DialogRootState = DialogRootState ( < nl > + Map ( < nl > + DialogGroupType . DirectMessages → Set . empty , < nl > + DialogGroupType . Groups → Set . empty < nl > + ) , < nl > + SortedSet . empty ( SortableDialog . ordering ) , < nl > + SortedSet . empty ( SortableDialog . ordering ) < nl > + ) < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > case GetCounter ( ) ⇒ getCounter ( ) < nl > @ @ - 188 , 18 + 195 , 18 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > } < nl > < nl > override protected def handleCommand : Receive = { < nl > - case sm : SendMessage ⇒ < nl > - needShowDialog ( sm ) match { < nl > + case dc : DialogCommand if dc . isInstanceOf [ SendMessage ] | | dc . isInstanceOf [ WriteMessageSelf ] ⇒ < nl > + needShowDialog ( dc ) match { < nl > case Some ( peer ) ⇒ < nl > val e = if ( isArchived ( peer ) ) Unarchived ( Instant . now ( ) , Some ( peer ) ) else Created ( Instant . now ( ) , Some ( peer ) ) < nl > < nl > persist ( e ) { _ ⇒ < nl > commit ( e ) < nl > - handleDialogCommand ( sm ) < nl > + handleDialogCommand ( dc ) < nl > sendChatGroupsChanged ( ) < nl > } < nl > case None ⇒ < nl > - handleDialogCommand ( sm ) < nl > + handleDialogCommand ( dc ) < nl > } < nl > case Archive ( Some ( peer ) , clientAuthSid ) ⇒ archive ( peer , clientAuthSid map ( _ . value ) ) < nl > case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) < nl > @ @ - 219 , 25 + 226 , 17 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > } < nl > < nl > private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - println ( s " = = = archive $ { state . activePeers } " ) < nl > - < nl > if ( isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyArchived ( peer ) ) < nl > else persist ( Archived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - println ( s " = = = archive result $ { state . activePeers } " ) < nl > - < nl > sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > < nl > private def unarchive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - println ( s " = = = unarchive $ { state . activePeers } " ) < nl > - < nl > if ( ! isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyShown ( peer ) ) < nl > else persist ( Unarchived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - < nl > - println ( s " = = = unarchive result $ { state . activePeers } " ) < nl > sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > @ @ - 258 , 18 + 257 , 24 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > } < nl > } < nl > < nl > - private def needShowDialog ( sm : SendMessage ) : Option [ Peer ] = { < nl > - val checkPeer = < nl > - sm . getOrigin . typ match { < nl > - case PeerType . Group ⇒ sm . getDest < nl > - case PeerType . Private ⇒ < nl > - if ( selfPeer = = sm . getDest ) sm . getOrigin < nl > - else sm . getDest < nl > - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > - } < nl > + private def needShowDialog ( cmd : DialogCommand ) : Option [ Peer ] = { < nl > + val checkPeerOpt = cmd match { < nl > + case sm : SendMessage ⇒ < nl > + Some ( sm . getOrigin . typ match { < nl > + case PeerType . Group ⇒ sm . getDest < nl > + case PeerType . Private ⇒ < nl > + if ( selfPeer = = sm . getDest ) sm . getOrigin < nl > + else sm . getDest < nl > + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > + } ) < nl > + case wm : WriteMessageSelf ⇒ Some ( wm . getDest ) < nl > + case _ ⇒ None < nl > + } < nl > < nl > - if ( dialogShown ( checkPeer ) ) None < nl > - else Some ( checkPeer ) < nl > + checkPeerOpt flatMap { checkPeer ⇒ < nl > + if ( dialogShown ( checkPeer ) ) None < nl > + else Some ( checkPeer ) < nl > + } < nl > } < nl > < nl > private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 17e13c3 . . 7d8f59b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 59 , 7 + 59 , 7 @ @ object UserErrors { < nl > final case class BotCommandAlreadyExists ( slashCommand : String ) < nl > extends UserError ( s " Bot command already exists : $ slashCommand " ) < nl > < nl > - final case object ContactNotFound extends UserError ( " Contact not found " ) < nl > + case object ContactNotFound extends UserError ( " Contact not found " ) < nl > < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 index d44f926 . . 4a216fb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 @ @ - 61 , 11 + 61 , 13 @ @ private [ dialog ] case class ActiveDialogs ( 
 dms : SortedSet [ SortableDialog ] 
 ) { 
 def withPeer ( sd : SortableDialog ) = { 
 - sd . peer . typ match { 
 - case PeerType . Private ⇒ copy ( dms = dms + sd ) 
 - case PeerType . Group ⇒ copy ( groups = groups + sd ) 
 - case unknown ⇒ throw new PeerErrors . UnknownPeerType ( unknown ) 
 - } 
 + if ( favourites . exists ( _ . peer = = sd . peer ) ) this 
 + else 
 + sd . peer . typ match { 
 + case PeerType . Private ⇒ copy ( dms = dms + sd ) 
 + case PeerType . Group ⇒ copy ( groups = groups + sd ) 
 + case unknown ⇒ throw new PeerErrors . UnknownPeerType ( unknown ) 
 + } 
 } 
 
 def withoutPeer ( sd : SortableDialog ) = { 
 @ @ - 157 , 27 + 159 , 28 @ @ private [ dialog ] final case class DialogRootState ( 
 } 
 
 private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - val sortableDialog = SortableDialog ( ts , peer ) 
 - 
 if ( this . activePeers . exists ( _ . ts = = ts ) ) withShownPeer ( ts . plusMillis ( 1 ) , peer ) 
 - else 
 + else { 
 + val sortableDialog = SortableDialog ( ts , peer ) 
 + 
 copy ( 
 activePeers = this . activePeers + sortableDialog , 
 active = this . active . withPeer ( sortableDialog ) , 
 - archived = this . archived - sortableDialog 
 + archived = this . archived . filterNot ( _ . peer = = peer ) 
 ) 
 + } 
 } 
 
 private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - val sortableDialog = SortableDialog ( ts , peer ) 
 - 
 if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) 
 - else 
 + else { 
 + val sortableDialog = SortableDialog ( ts , peer ) 
 copy ( 
 - activePeers = this . activePeers - sortableDialog , 
 + activePeers = this . activePeers . filterNot ( _ . peer = = peer ) , 
 active = this . active . withoutPeer ( sortableDialog ) , 
 archived = this . archived + sortableDialog 
 ) 
 + } 
 } 
 
 private def withFavouritedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 index 98d293b . . d10b303 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 @ @ - 14 , 6 + 14 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 it should " remove from Archived on Favourite or new message " in removeFromArchived 
 it should " archive groups and DMs " in archive 
 it should " order archived by date desc " in archivedOrder 
 + it should " not add to DMs or groups if already in favourites " in keepInFavourites 
 
 import DialogRootEvents . _ 
 
 @ @ - 46 , 6 + 47 , 23 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 checkSnapshot 
 } 
 
 + def keepInFavourites ( ) = { 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + 
 + val alice = Peer . privat ( 1 ) 
 + val group = Peer . group ( 100 ) 
 + 
 + probe . commit ( Favourited ( Instant . now , Some ( alice ) ) ) 
 + probe . commit ( Favourited ( Instant . now , Some ( group ) ) ) 
 + probe . commit ( Created ( Instant . now , Some ( alice ) ) ) 
 + probe . commit ( Created ( Instant . now , Some ( group ) ) ) 
 + 
 + probe . state . active . dms shouldBe empty 
 + probe . state . active . dms shouldBe empty 
 + probe . state . active . favourites . map ( _ . peer ) . toSeq should be ( Seq ( alice , group ) ) 
 + probe . state . activePeers . map ( _ . peer ) . toSeq should be ( Seq ( alice , group ) ) 
 + } 
 + 
 def removeFromArchived ( ) = { 
 implicit val probe = ProcessorStateProbe ( DialogRootState . initial )

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index 652fad2 . . cf67226 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 7 , 7 + 7 , 7 @ @ import akka . pattern . { ask , pipe } 
 import akka . util . Timeout 
 import im . actor . concurrent . _ 
 import im . actor . server . cqrs . _ 
 - import im . actor . server . dialog . DialogCommands . SendMessage 
 + import im . actor . server . dialog . DialogCommands . { SendMessage , WriteMessageSelf } 
 import im . actor . server . model . { Peer , PeerType } 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . messaging . UpdateChatGroupsChanged 
 @ @ - 179 , 7 + 179 , 14 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 
 override def persistenceId : String = s " DialogRoot _ $ userId " 
 
 - override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , SortedSet . empty ( SortableDialog . ordering ) , SortedSet . empty ( SortableDialog . ordering ) ) 
 + override protected def getInitialState : DialogRootState = DialogRootState ( 
 + Map ( 
 + DialogGroupType . DirectMessages → Set . empty , 
 + DialogGroupType . Groups → Set . empty 
 + ) , 
 + SortedSet . empty ( SortableDialog . ordering ) , 
 + SortedSet . empty ( SortableDialog . ordering ) 
 + ) 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 case GetCounter ( ) ⇒ getCounter ( ) 
 @ @ - 188 , 18 + 195 , 18 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 } 
 
 override protected def handleCommand : Receive = { 
 - case sm : SendMessage ⇒ 
 - needShowDialog ( sm ) match { 
 + case dc : DialogCommand if dc . isInstanceOf [ SendMessage ] | | dc . isInstanceOf [ WriteMessageSelf ] ⇒ 
 + needShowDialog ( dc ) match { 
 case Some ( peer ) ⇒ 
 val e = if ( isArchived ( peer ) ) Unarchived ( Instant . now ( ) , Some ( peer ) ) else Created ( Instant . now ( ) , Some ( peer ) ) 
 
 persist ( e ) { _ ⇒ 
 commit ( e ) 
 - handleDialogCommand ( sm ) 
 + handleDialogCommand ( dc ) 
 sendChatGroupsChanged ( ) 
 } 
 case None ⇒ 
 - handleDialogCommand ( sm ) 
 + handleDialogCommand ( dc ) 
 } 
 case Archive ( Some ( peer ) , clientAuthSid ) ⇒ archive ( peer , clientAuthSid map ( _ . value ) ) 
 case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) 
 @ @ - 219 , 25 + 226 , 17 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 } 
 
 private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - println ( s " = = = archive $ { state . activePeers } " ) 
 - 
 if ( isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyArchived ( peer ) ) 
 else persist ( Archived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - println ( s " = = = archive result $ { state . activePeers } " ) 
 - 
 sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 
 private def unarchive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - println ( s " = = = unarchive $ { state . activePeers } " ) 
 - 
 if ( ! isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyShown ( peer ) ) 
 else persist ( Unarchived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - 
 - println ( s " = = = unarchive result $ { state . activePeers } " ) 
 sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 @ @ - 258 , 18 + 257 , 24 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 } 
 } 
 
 - private def needShowDialog ( sm : SendMessage ) : Option [ Peer ] = { 
 - val checkPeer = 
 - sm . getOrigin . typ match { 
 - case PeerType . Group ⇒ sm . getDest 
 - case PeerType . Private ⇒ 
 - if ( selfPeer = = sm . getDest ) sm . getOrigin 
 - else sm . getDest 
 - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 - } 
 + private def needShowDialog ( cmd : DialogCommand ) : Option [ Peer ] = { 
 + val checkPeerOpt = cmd match { 
 + case sm : SendMessage ⇒ 
 + Some ( sm . getOrigin . typ match { 
 + case PeerType . Group ⇒ sm . getDest 
 + case PeerType . Private ⇒ 
 + if ( selfPeer = = sm . getDest ) sm . getOrigin 
 + else sm . getDest 
 + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 + } ) 
 + case wm : WriteMessageSelf ⇒ Some ( wm . getDest ) 
 + case _ ⇒ None 
 + } 
 
 - if ( dialogShown ( checkPeer ) ) None 
 - else Some ( checkPeer ) 
 + checkPeerOpt flatMap { checkPeer ⇒ 
 + if ( dialogShown ( checkPeer ) ) None 
 + else Some ( checkPeer ) 
 + } 
 } 
 
 private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 17e13c3 . . 7d8f59b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 59 , 7 + 59 , 7 @ @ object UserErrors { 
 final case class BotCommandAlreadyExists ( slashCommand : String ) 
 extends UserError ( s " Bot command already exists : $ slashCommand " ) 
 
 - final case object ContactNotFound extends UserError ( " Contact not found " ) 
 + case object ContactNotFound extends UserError ( " Contact not found " ) 
 
 }
