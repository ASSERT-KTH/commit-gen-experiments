BLEU SCORE: 0.4232618196604538

TEST MSG: feat ( server : messaging ) : archive inactive chats
GENERATED MSG: fix ( server : messaging ) : dialog show / hide fix

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > index ea02399 . . 5541e3c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > @ @ - 1 , 26 + 1 , 42 @ @ < nl > package im . actor . server . user < nl > < nl > + import java . time . { Instant , Period } < nl > + < nl > import akka . actor . { ActorRef , Props } < nl > import im . actor . api . rpc . PeersImplicits < nl > import im . actor . api . rpc . misc . ApiExtension < nl > import im . actor . concurrent . AlertingActor < nl > - import im . actor . server . dialog . { DialogCommand , DialogProcessor , DirectDialogCommand } < nl > + import im . actor . server . dialog . _ < nl > import im . actor . server . model . { Peer , PeerType } < nl > < nl > + import scala . concurrent . duration . _ < nl > + < nl > private [ user ] object UserPeer { < nl > def props ( userId : Int , extensions : Seq [ ApiExtension ] ) = Props ( classOf [ UserPeer ] , userId , extensions ) < nl > + < nl > + private case object Archive < nl > } < nl > < nl > private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) extends AlertingActor with PeersImplicits { < nl > + import UserPeer . _ < nl > + import context . dispatcher < nl > < nl > private val selfPeer = Peer . privat ( userId ) < nl > < nl > + private val dialogExt = DialogExtension ( context . system ) < nl > + private val archiveInterval = context . system . scheduler . schedule ( 0 . seconds , 1 . hour , self , Archive ) < nl > + < nl > + override def postStop ( ) : Unit = { < nl > + super . postStop ( ) < nl > + archiveInterval . cancel ( ) < nl > + } < nl > + < nl > def receive : Receive = { < nl > / / Forward to a group or a corresponding user dialog < nl > case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc < nl > / / Forward to a dest user dialog < nl > case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc < nl > - case other ⇒ log . debug ( " Unmatched message : { } " , other ) < nl > + case Archive ⇒ archive ( ) < nl > } < nl > < nl > private def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { < nl > @ @ - 40 , 4 + 56 , 17 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e < nl > case other ⇒ throw new Exception ( s " Unknown peer type : $ other " ) < nl > } < nl > < nl > + private def archive ( ) : Unit = { < nl > + for { < nl > + dialogs ← dialogExt . getGroupedDialogs ( userId ) map ( _ flatMap ( _ . dialogs ) ) < nl > + } yield { < nl > + val toArchive = dialogs filter ( d ⇒ d . counter = = 0 & & d . date < = Instant . now ( ) . minus ( Period . ofDays ( 5 ) ) . toEpochMilli ) < nl > + for ( dialog ← toArchive ) { < nl > + log . debug ( " Archiving dialog { } due to inactivity " , dialog . peer ) < nl > + val command = DialogCommands . Archive ( dialog . peer . asModel ) < nl > + dialogRef ( command . dest ) ! command < nl > + } < nl > + } < nl > + } < nl > + < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index e21706c . . 6ec13a8 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 19 , 11 + 19 , 13 @ @ message DialogCommands { < nl > SendMessage send _ message = 3 ; < nl > MessageReceived message _ received = 4 ; < nl > MessageRead message _ read = 5 ; < nl > + Show show = 6 ; < nl > + Hide hide = 7 ; < nl > } < nl > } < nl > < nl > message WriteMessage { < nl > - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; < nl > < nl > required Peer origin = 6 ; < nl > required Peer dest = 7 ; < nl > @ @ - 35 , 7 + 37 , 7 @ @ message DialogCommands { < nl > message WriteMessageAck { } < nl > < nl > message SendMessage { < nl > - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; < nl > < nl > required Peer origin = 7 ; < nl > required Peer dest = 8 ; < nl > @ @ - 49 , 7 + 51 , 7 @ @ message DialogCommands { < nl > message SendMessageAck { } < nl > < nl > message MessageReceived { < nl > - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; < nl > < nl > required Peer origin = 4 ; < nl > required Peer dest = 5 ; < nl > @ @ - 60 , 7 + 62 , 7 @ @ message DialogCommands { < nl > message MessageReceivedAck { } < nl > < nl > message MessageRead { < nl > - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; < nl > < nl > required Peer origin = 5 ; < nl > required Peer dest = 6 ; < nl > @ @ - 71 , 4 + 73 , 16 @ @ message DialogCommands { < nl > < nl > message MessageReadAck { } < nl > < nl > + message Show { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + < nl > + required Peer dest = 1 ; < nl > + } < nl > + < nl > + message Hide { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + < nl > + required Peer dest = 1 ; < nl > + } < nl > + < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > index 51afd1b . . 4181a2e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > @ @ - 27 , 19 + 27 , 22 @ @ object DialogEvents { < nl > < nl > private [ dialog ] sealed trait DialogEvent < nl > < nl > - private [ dialog ] case object Initialized extends DialogEvent < nl > + private [ dialog ] final case class Initialized ( isHidden : Boolean ) extends DialogEvent < nl > < nl > - private [ dialog ] case class LastOwnMessageDate ( date : Long ) extends DialogEvent < nl > + private [ dialog ] final case class LastOwnMessageDate ( date : Long ) extends DialogEvent < nl > < nl > - private [ dialog ] case class LastOwnReceiveDate ( date : Long ) extends DialogEvent < nl > + private [ dialog ] final case class LastOwnReceiveDate ( date : Long ) extends DialogEvent < nl > < nl > - private [ dialog ] case class LastOwnReadDate ( date : Long ) extends DialogEvent < nl > + private [ dialog ] final case class LastOwnReadDate ( date : Long ) extends DialogEvent < nl > < nl > - private [ dialog ] case class LastPeerMessageDate ( date : Long ) extends DialogEvent < nl > + private [ dialog ] final case class LastPeerMessageDate ( date : Long ) extends DialogEvent < nl > < nl > - private [ dialog ] case class LastPeerReceiveDate ( date : Long ) extends DialogEvent < nl > + private [ dialog ] final case class LastPeerReceiveDate ( date : Long ) extends DialogEvent < nl > < nl > - private [ dialog ] case class LastPeerReadDate ( date : Long ) extends DialogEvent < nl > + private [ dialog ] final case class LastPeerReadDate ( date : Long ) extends DialogEvent < nl > + < nl > + private [ dialog ] case object Shown extends DialogEvent < nl > + private [ dialog ] case object Hidden extends DialogEvent < nl > < nl > } < nl > < nl > @ @ - 48 , 8 + 51 , 9 @ @ private [ dialog ] final case class DialogState ( < nl > lastOwnReceiveDate : Long = 0 , < nl > lastOwnReadDate : Long = 0 , < nl > / / lastPeerMessageDate : Long = 0 , < nl > - lastPeerReceiveDate : Long = 0 , < nl > - lastPeerReadDate : Long = 0 < nl > + lastPeerReceiveDate : Long = 0 , < nl > + lastPeerReadDate : Long = 0 , < nl > + isHidden : Boolean = false < nl > ) extends ProcessorState [ DialogState ] { < nl > import DialogEvents . _ < nl > override def updated ( e : AnyRef , ts : Instant ) : DialogState = e match { < nl > @ @ - 59 , 6 + 63 , 8 @ @ private [ dialog ] final case class DialogState ( < nl > / / case LastPeerMessageDate ( date ) if date ! = this . lastPeerMessageDate ⇒ this . copy ( lastPeerMessageDate = date ) < nl > case LastPeerReceiveDate ( date ) if date ! = this . lastPeerReceiveDate ⇒ this . copy ( lastPeerReceiveDate = date ) < nl > case LastPeerReadDate ( date ) if date ! = this . lastPeerReadDate ⇒ this . copy ( lastPeerReadDate = date ) < nl > + case Shown ⇒ this . copy ( isHidden = false ) < nl > + case Hidden ⇒ this . copy ( isHidden = true ) < nl > case unm ⇒ this < nl > } < nl > } < nl > @ @ - 116 , 20 + 122 , 22 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > override def receive : Receive = init < nl > < nl > def init : Receive = receiveStashing ( replyTo ⇒ { < nl > - case Initialized ⇒ < nl > - context become initialized ( DialogState ( ) ) < nl > + case Initialized ( isHidden ) ⇒ < nl > + context become initialized ( DialogState ( isHidden = isHidden ) ) < nl > unstashAll ( ) < nl > } ) < nl > < nl > def initialized ( state : DialogState ) : Receive = { < nl > case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( sm ) / / User ' s message been sent < nl > + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received < nl > case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read < nl > case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) < nl > case md : LastOwnMessageDate ⇒ updateOwnMessageDate ( state , md ) < nl > + case Show ( _ ) ⇒ show ( state ) < nl > + case Hide ( _ ) ⇒ hide ( state ) < nl > } < nl > < nl > / * * < nl > @ @ - 142 , 7 + 150 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > * @ param dc command < nl > * @ return does dialog owner invokes this command < nl > * / < nl > - private def invokes ( dc : DialogCommand ) : Boolean = ( dc . dest = = peer ) & & ( dc . origin = = selfPeer ) < nl > + private def invokes ( dc : DirectDialogCommand ) : Boolean = ( dc . dest = = peer ) & & ( dc . origin = = selfPeer ) < nl > < nl > / * * < nl > * dialog owner accepts ` dc ` < nl > @ @ - 154 , 19 + 162 , 20 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > * @ param dc command < nl > * @ return does dialog owner accepts this command < nl > * / < nl > - def accepts ( dc : DialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) < nl > + def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) < nl > < nl > private [ this ] def createDialogIfNeeded ( ) : Future [ Unit ] = < nl > db . run ( for { < nl > optDialog ← DialogRepo . find ( userId , peer ) < nl > - _ ← optDialog match { < nl > - case Some ( _ ) ⇒ DBIO . successful ( ( ) ) < nl > + dialog ← optDialog match { < nl > + case Some ( dialog ) ⇒ DBIO . successful ( dialog ) < nl > case None ⇒ < nl > + val dialog = DialogModel ( userId , peer ) < nl > for { < nl > - _ ← DialogRepo . create ( DialogModel ( userId , peer ) ) < nl > + _ ← DialogRepo . create ( dialog ) < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > - } yield ( ) < nl > + } yield dialog < nl > } < nl > - } yield { self ! Initialized } ) < nl > + } yield { self ! Initialized ( dialog . isHidden ) } ) < nl > < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommand . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommand . scala < nl > index be7afb3 . . 1b335e3 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommand . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommand . scala < nl > @ @ - 3 , 6 + 3 , 9 @ @ package im . actor . server . dialog < nl > import im . actor . server . model . Peer < nl > < nl > trait DialogCommand { < nl > - val origin : Peer < nl > val dest : Peer < nl > + } < nl > + < nl > + trait DirectDialogCommand extends DialogCommand { < nl > + val origin : Peer < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index a19e97f . . b45cc33 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 1 , 12 + 1 , 13 @ @ < nl > package im . actor . server . dialog < nl > < nl > + import akka . actor . { ActorRef , Status } < nl > import akka . pattern . pipe < nl > import im . actor . api . rpc . PeersImplicits < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . server . dialog . HistoryUtils . _ < nl > import im . actor . server . misc . UpdateCounters < nl > import im . actor . server . model . { Peer , HistoryMessage , PeerType } < nl > - import im . actor . server . persist . HistoryMessageRepo < nl > + import im . actor . server . persist . { DialogRepo , HistoryMessageRepo } < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > import im . actor . server . social . SocialManager < nl > import im . actor . util . cache . CacheHelpers . _ < nl > @ @ - 38 , 13 + 39 , 21 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } < nl > } < nl > < nl > - protected def ackSendMessage ( sm : SendMessage ) : Unit = { < nl > + protected def ackSendMessage ( state : DialogState , sm : SendMessage ) : Unit = { < nl > if ( peer . typ = = PeerType . Private ) SocialManager . recordRelation ( sm . origin . id , userId ) < nl > - deliveryExt . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) map ( _ ⇒ SendMessageAck ( ) ) pipeTo sender ( ) < nl > + < nl > + deliveryExt < nl > + . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > + . map ( _ ⇒ SendMessageAck ( ) ) < nl > + . pipeTo ( sender ( ) ) < nl > + < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > < nl > / / onSuccess ( fu ) { _ = > < nl > / / updatePeerMessageDate ( ) < nl > / / } < nl > + < nl > } < nl > < nl > protected def writeMessage ( < nl > @ @ - 131 , 6 + 140 , 38 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } < nl > } < nl > < nl > + protected def show ( state : DialogState ) : Unit = { < nl > + if ( ! state . isHidden ) < nl > + sender ! Status . Failure ( DialogErrors . DialogAlreadyShown ( peer ) ) < nl > + else { < nl > + val future = < nl > + ( for { < nl > + _ ← db . run ( DialogRepo . show ( userId , peer ) ) < nl > + seqstate ← userExt . notifyDialogsChanged ( userId ) < nl > + } yield seqstate ) pipeTo sender ( ) < nl > + < nl > + onSuccess ( future ) { _ ⇒ < nl > + updateShown ( state ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + protected def hide ( state : DialogState ) : Unit = { < nl > + if ( state . isHidden ) < nl > + sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) < nl > + else { < nl > + val future = < nl > + ( for { < nl > + _ ← db . run ( DialogRepo . hide ( userId , peer ) ) < nl > + seqstate ← userExt . notifyDialogsChanged ( userId ) < nl > + } yield seqstate ) pipeTo sender ( ) < nl > + < nl > + onSuccess ( future ) { _ ⇒ < nl > + updateHidden ( state ) < nl > + } < nl > + } < nl > + } < nl > + < nl > private def mustMakeReceive ( state : DialogState , mr : MessageReceived ) : Boolean = peer match { < nl > case Peer ( PeerType . Private , _ ) ⇒ < nl > ( mr . date > state . lastOwnReceiveDate ) & & / / receive date is later than last receive date < nl > @ @ - 165 , 4 + 206 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > private def updateOwnReadDate ( state : DialogState , date : Long ) : Unit = < nl > context become initialized ( state . updated ( LastOwnReadDate ( date ) ) ) < nl > < nl > + private def updateShown ( state : DialogState ) : Unit = < nl > + context become initialized ( state . updated ( Shown ) ) < nl > + < nl > + private def updateHidden ( state : DialogState ) : Unit = < nl > + context become initialized ( state . updated ( Hidden ) ) < nl > + < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala < nl > index 3248d0f . . 81f95c2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala < nl > @ @ - 1 , 5 + 1 , 14 @ @ < nl > package im . actor . server . dialog < nl > < nl > + import im . actor . server . model . Peer < nl > + < nl > + import scala . util . control . NoStackTrace < nl > + < nl > + abstract class DialogError ( msg : String ) extends RuntimeException ( msg ) with NoStackTrace < nl > + < nl > object DialogErrors { < nl > - final object MessageToSelf extends Exception ( " Private dialog with self is not allowed " ) < nl > + object MessageToSelf extends DialogError ( " Private dialog with self is not allowed " ) < nl > + < nl > + final case class DialogAlreadyShown ( peer : Peer ) extends DialogError ( s " Dialog $ { peer } is already shown " ) < nl > + final case class DialogAlreadyHidden ( peer : Peer ) extends DialogError ( s " Dialog $ { peer } is already hidden " ) < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 8ee49ca . . 55230de 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 16 , 7 + 16 , 7 @ @ import im . actor . server . dialog . DialogCommands . _ < nl > import im . actor . server . group . GroupExtension < nl > import im . actor . server . model . { Peer , PeerType , Dialog ⇒ DialogModel } < nl > import im . actor . server . persist . { DialogRepo , HistoryMessageRepo } < nl > - import im . actor . server . sequence . SeqStateDate < nl > + import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > import im . actor . server . user . UserExtension < nl > import org . joda . time . DateTime < nl > import slick . dbio . DBIO < nl > @ @ - 95 , 6 + 95 , 12 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def ackMessageRead ( peer : Peer , mr : MessageRead ) : Future [ Unit ] = < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > < nl > + def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > + ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + < nl > + def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > + ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > case Seq ( ) ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > index d0a8176 . . b3178ed 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > @ @ - 10 , 7 + 10 , 7 @ @ import im . actor . api . rpc . misc . ApiExtension < nl > import im . actor . serialization . ActorSerializer < nl > import im . actor . server . KeyValueMappings < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . dialog . { DialogCommand , DialogExtension } < nl > + import im . actor . server . dialog . { DirectDialogCommand , DialogExtension } < nl > import im . actor . server . event . TSEvent < nl > import im . actor . server . file . { FileStorageAdapter , S3StorageExtension , Avatar } < nl > import im . actor . server . office . { PeerProcessor , ProcessorState , StopOffice } < nl > @ @ - 239 , 9 + 239 , 9 @ @ private [ group ] final class GroupProcessor < nl > makeUserAdmin ( state , clientUserId , candidateId ) < nl > case RevokeIntegrationToken ( _ , userId ) ⇒ < nl > revokeIntegrationToken ( state , userId ) < nl > - case StopOffice ⇒ context stop self < nl > - case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) < nl > - case dc : DialogCommand ⇒ groupPeer forward dc < nl > + case StopOffice ⇒ context stop self < nl > + case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) < nl > + case dc : DirectDialogCommand ⇒ groupPeer forward dc < nl > } < nl > < nl > private [ this ] var groupStateMaybe : Option [ Group ] = None < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > index 48e3db8 . . 5698901 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . server . user < nl > import akka . actor . { Actor , ActorRef , Props } < nl > import im . actor . api . rpc . PeersImplicits < nl > import im . actor . api . rpc . misc . ApiExtension < nl > - import im . actor . server . dialog . { Dialog , DialogCommand } < nl > + import im . actor . server . dialog . { DirectDialogCommand , Dialog , DialogCommand } < nl > import im . actor . server . model . { Peer , PeerType } < nl > < nl > private [ user ] object UserPeer { < nl > @ @ - 15 , 18 + 15 , 22 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e < nl > private val selfPeer = Peer . privat ( userId ) < nl > < nl > def receive : Receive = { < nl > - case dc : DialogCommand ⇒ dialogRef ( dc ) forward dc < nl > - case other ⇒ context . system . log . debug ( " Unmatched message : { } " , other ) < nl > + case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc < nl > + case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc < nl > + case other ⇒ context . system . log . debug ( " Unmatched message : { } " , other ) < nl > } < nl > < nl > - private def dialogRef ( dc : DialogCommand ) : ActorRef = { < nl > + private def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { < nl > val peer = dc . dest match { < nl > case Peer ( PeerType . Group , _ ) ⇒ dc . dest < nl > case Peer ( PeerType . Private , _ ) ⇒ if ( dc . origin = = selfPeer ) dc . dest else dc . origin < nl > } < nl > - context . child ( dialogName ( peer ) ) getOrElse context . actorOf ( Dialog . props ( userId , peer , extensions ) , dialogName ( peer ) ) < nl > + dialogRef ( peer ) < nl > } < nl > < nl > + private def dialogRef ( peer : Peer ) : ActorRef = < nl > + context . child ( dialogName ( peer ) ) getOrElse context . actorOf ( Dialog . props ( userId , peer , extensions ) , dialogName ( peer ) ) < nl > + < nl > private def dialogName ( peer : Peer ) : String = peer . typ match { < nl > case PeerType . Private ⇒ s " Private _ $ { peer . id } " < nl > case PeerType . Group ⇒ s " Group _ $ { peer . id } " < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index 1884e60 . . 863c6b8 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 6 , 7 + 6 , 7 @ @ import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . misc . { ResponseSeq , ResponseVoid } < nl > import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType } < nl > - import im . actor . server . dialog . HistoryUtils < nl > + import im . actor . server . dialog . { DialogErrors , HistoryUtils } < nl > import im . actor . server . group . GroupUtils < nl > import im . actor . server . persist . DialogRepo < nl > import im . actor . server . sequence . SeqState < nl > @ @ - 111 , 21 + 111 , 25 @ @ trait HistoryHandlers { < nl > < nl > override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = { < nl > authorized ( clientData ) { implicit client ⇒ < nl > - for { < nl > - _ ← db . run ( DialogRepo . hide ( client . userId , peer . asModel ) ) < nl > - seqstate ← userExt . notifyDialogsChanged ( client . userId ) < nl > + ( for { < nl > + seqstate ← dialogExt . hide ( client . userId , peer . asModel ) < nl > groups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > - } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . state . toByteArray , groups = groups ) ) < nl > + } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . state . toByteArray , groups = groups ) ) ) recover { < nl > + case DialogErrors . DialogAlreadyHidden ( peer ) ⇒ < nl > + Error ( RpcError ( 406 , " DIALOG _ ALREADY _ HIDDEN " , " Dialog is already hidden . " , canTryAgain = false , None ) ) < nl > + } < nl > } < nl > } < nl > < nl > override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = { < nl > authorized ( clientData ) { implicit client ⇒ < nl > - for { < nl > - _ ← db . run ( DialogRepo . show ( client . userId , peer . asModel ) ) < nl > - SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) < nl > + ( for { < nl > + seqstate ← dialogExt . show ( client . userId , peer . asModel ) < nl > groups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > - } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups = groups ) ) < nl > + } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . toByteArray , groups = groups ) ) ) recover { < nl > + case DialogErrors . DialogAlreadyHidden ( peer ) ⇒ < nl > + Error ( RpcError ( 406 , " DIALOG _ ALREADY _ SHOWN " , " Dialog is already shown . " , canTryAgain = false , None ) ) < nl > + } < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 index ea02399 . . 5541e3c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 @ @ - 1 , 26 + 1 , 42 @ @ 
 package im . actor . server . user 
 
 + import java . time . { Instant , Period } 
 + 
 import akka . actor . { ActorRef , Props } 
 import im . actor . api . rpc . PeersImplicits 
 import im . actor . api . rpc . misc . ApiExtension 
 import im . actor . concurrent . AlertingActor 
 - import im . actor . server . dialog . { DialogCommand , DialogProcessor , DirectDialogCommand } 
 + import im . actor . server . dialog . _ 
 import im . actor . server . model . { Peer , PeerType } 
 
 + import scala . concurrent . duration . _ 
 + 
 private [ user ] object UserPeer { 
 def props ( userId : Int , extensions : Seq [ ApiExtension ] ) = Props ( classOf [ UserPeer ] , userId , extensions ) 
 + 
 + private case object Archive 
 } 
 
 private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) extends AlertingActor with PeersImplicits { 
 + import UserPeer . _ 
 + import context . dispatcher 
 
 private val selfPeer = Peer . privat ( userId ) 
 
 + private val dialogExt = DialogExtension ( context . system ) 
 + private val archiveInterval = context . system . scheduler . schedule ( 0 . seconds , 1 . hour , self , Archive ) 
 + 
 + override def postStop ( ) : Unit = { 
 + super . postStop ( ) 
 + archiveInterval . cancel ( ) 
 + } 
 + 
 def receive : Receive = { 
 / / Forward to a group or a corresponding user dialog 
 case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc 
 / / Forward to a dest user dialog 
 case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc 
 - case other ⇒ log . debug ( " Unmatched message : { } " , other ) 
 + case Archive ⇒ archive ( ) 
 } 
 
 private def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { 
 @ @ - 40 , 4 + 56 , 17 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e 
 case other ⇒ throw new Exception ( s " Unknown peer type : $ other " ) 
 } 
 
 + private def archive ( ) : Unit = { 
 + for { 
 + dialogs ← dialogExt . getGroupedDialogs ( userId ) map ( _ flatMap ( _ . dialogs ) ) 
 + } yield { 
 + val toArchive = dialogs filter ( d ⇒ d . counter = = 0 & & d . date < = Instant . now ( ) . minus ( Period . ofDays ( 5 ) ) . toEpochMilli ) 
 + for ( dialog ← toArchive ) { 
 + log . debug ( " Archiving dialog { } due to inactivity " , dialog . peer ) 
 + val command = DialogCommands . Archive ( dialog . peer . asModel ) 
 + dialogRef ( command . dest ) ! command 
 + } 
 + } 
 + } 
 + 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index e21706c . . 6ec13a8 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 19 , 11 + 19 , 13 @ @ message DialogCommands { 
 SendMessage send _ message = 3 ; 
 MessageReceived message _ received = 4 ; 
 MessageRead message _ read = 5 ; 
 + Show show = 6 ; 
 + Hide hide = 7 ; 
 } 
 } 
 
 message WriteMessage { 
 - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; 
 
 required Peer origin = 6 ; 
 required Peer dest = 7 ; 
 @ @ - 35 , 7 + 37 , 7 @ @ message DialogCommands { 
 message WriteMessageAck { } 
 
 message SendMessage { 
 - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; 
 
 required Peer origin = 7 ; 
 required Peer dest = 8 ; 
 @ @ - 49 , 7 + 51 , 7 @ @ message DialogCommands { 
 message SendMessageAck { } 
 
 message MessageReceived { 
 - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; 
 
 required Peer origin = 4 ; 
 required Peer dest = 5 ; 
 @ @ - 60 , 7 + 62 , 7 @ @ message DialogCommands { 
 message MessageReceivedAck { } 
 
 message MessageRead { 
 - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; 
 
 required Peer origin = 5 ; 
 required Peer dest = 6 ; 
 @ @ - 71 , 4 + 73 , 16 @ @ message DialogCommands { 
 
 message MessageReadAck { } 
 
 + message Show { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + 
 + required Peer dest = 1 ; 
 + } 
 + 
 + message Hide { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + 
 + required Peer dest = 1 ; 
 + } 
 + 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 index 51afd1b . . 4181a2e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 @ @ - 27 , 19 + 27 , 22 @ @ object DialogEvents { 
 
 private [ dialog ] sealed trait DialogEvent 
 
 - private [ dialog ] case object Initialized extends DialogEvent 
 + private [ dialog ] final case class Initialized ( isHidden : Boolean ) extends DialogEvent 
 
 - private [ dialog ] case class LastOwnMessageDate ( date : Long ) extends DialogEvent 
 + private [ dialog ] final case class LastOwnMessageDate ( date : Long ) extends DialogEvent 
 
 - private [ dialog ] case class LastOwnReceiveDate ( date : Long ) extends DialogEvent 
 + private [ dialog ] final case class LastOwnReceiveDate ( date : Long ) extends DialogEvent 
 
 - private [ dialog ] case class LastOwnReadDate ( date : Long ) extends DialogEvent 
 + private [ dialog ] final case class LastOwnReadDate ( date : Long ) extends DialogEvent 
 
 - private [ dialog ] case class LastPeerMessageDate ( date : Long ) extends DialogEvent 
 + private [ dialog ] final case class LastPeerMessageDate ( date : Long ) extends DialogEvent 
 
 - private [ dialog ] case class LastPeerReceiveDate ( date : Long ) extends DialogEvent 
 + private [ dialog ] final case class LastPeerReceiveDate ( date : Long ) extends DialogEvent 
 
 - private [ dialog ] case class LastPeerReadDate ( date : Long ) extends DialogEvent 
 + private [ dialog ] final case class LastPeerReadDate ( date : Long ) extends DialogEvent 
 + 
 + private [ dialog ] case object Shown extends DialogEvent 
 + private [ dialog ] case object Hidden extends DialogEvent 
 
 } 
 
 @ @ - 48 , 8 + 51 , 9 @ @ private [ dialog ] final case class DialogState ( 
 lastOwnReceiveDate : Long = 0 , 
 lastOwnReadDate : Long = 0 , 
 / / lastPeerMessageDate : Long = 0 , 
 - lastPeerReceiveDate : Long = 0 , 
 - lastPeerReadDate : Long = 0 
 + lastPeerReceiveDate : Long = 0 , 
 + lastPeerReadDate : Long = 0 , 
 + isHidden : Boolean = false 
 ) extends ProcessorState [ DialogState ] { 
 import DialogEvents . _ 
 override def updated ( e : AnyRef , ts : Instant ) : DialogState = e match { 
 @ @ - 59 , 6 + 63 , 8 @ @ private [ dialog ] final case class DialogState ( 
 / / case LastPeerMessageDate ( date ) if date ! = this . lastPeerMessageDate ⇒ this . copy ( lastPeerMessageDate = date ) 
 case LastPeerReceiveDate ( date ) if date ! = this . lastPeerReceiveDate ⇒ this . copy ( lastPeerReceiveDate = date ) 
 case LastPeerReadDate ( date ) if date ! = this . lastPeerReadDate ⇒ this . copy ( lastPeerReadDate = date ) 
 + case Shown ⇒ this . copy ( isHidden = false ) 
 + case Hidden ⇒ this . copy ( isHidden = true ) 
 case unm ⇒ this 
 } 
 } 
 @ @ - 116 , 20 + 122 , 22 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 override def receive : Receive = init 
 
 def init : Receive = receiveStashing ( replyTo ⇒ { 
 - case Initialized ⇒ 
 - context become initialized ( DialogState ( ) ) 
 + case Initialized ( isHidden ) ⇒ 
 + context become initialized ( DialogState ( isHidden = isHidden ) ) 
 unstashAll ( ) 
 } ) 
 
 def initialized ( state : DialogState ) : Receive = { 
 case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( sm ) / / User ' s message been sent 
 + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received 
 case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read 
 case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) 
 case md : LastOwnMessageDate ⇒ updateOwnMessageDate ( state , md ) 
 + case Show ( _ ) ⇒ show ( state ) 
 + case Hide ( _ ) ⇒ hide ( state ) 
 } 
 
 / * * 
 @ @ - 142 , 7 + 150 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 * @ param dc command 
 * @ return does dialog owner invokes this command 
 * / 
 - private def invokes ( dc : DialogCommand ) : Boolean = ( dc . dest = = peer ) & & ( dc . origin = = selfPeer ) 
 + private def invokes ( dc : DirectDialogCommand ) : Boolean = ( dc . dest = = peer ) & & ( dc . origin = = selfPeer ) 
 
 / * * 
 * dialog owner accepts ` dc ` 
 @ @ - 154 , 19 + 162 , 20 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 * @ param dc command 
 * @ return does dialog owner accepts this command 
 * / 
 - def accepts ( dc : DialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) 
 + def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) 
 
 private [ this ] def createDialogIfNeeded ( ) : Future [ Unit ] = 
 db . run ( for { 
 optDialog ← DialogRepo . find ( userId , peer ) 
 - _ ← optDialog match { 
 - case Some ( _ ) ⇒ DBIO . successful ( ( ) ) 
 + dialog ← optDialog match { 
 + case Some ( dialog ) ⇒ DBIO . successful ( dialog ) 
 case None ⇒ 
 + val dialog = DialogModel ( userId , peer ) 
 for { 
 - _ ← DialogRepo . create ( DialogModel ( userId , peer ) ) 
 + _ ← DialogRepo . create ( dialog ) 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 - } yield ( ) 
 + } yield dialog 
 } 
 - } yield { self ! Initialized } ) 
 + } yield { self ! Initialized ( dialog . isHidden ) } ) 
 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommand . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommand . scala 
 index be7afb3 . . 1b335e3 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommand . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommand . scala 
 @ @ - 3 , 6 + 3 , 9 @ @ package im . actor . server . dialog 
 import im . actor . server . model . Peer 
 
 trait DialogCommand { 
 - val origin : Peer 
 val dest : Peer 
 + } 
 + 
 + trait DirectDialogCommand extends DialogCommand { 
 + val origin : Peer 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index a19e97f . . b45cc33 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 1 , 12 + 1 , 13 @ @ 
 package im . actor . server . dialog 
 
 + import akka . actor . { ActorRef , Status } 
 import akka . pattern . pipe 
 import im . actor . api . rpc . PeersImplicits 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . server . dialog . HistoryUtils . _ 
 import im . actor . server . misc . UpdateCounters 
 import im . actor . server . model . { Peer , HistoryMessage , PeerType } 
 - import im . actor . server . persist . HistoryMessageRepo 
 + import im . actor . server . persist . { DialogRepo , HistoryMessageRepo } 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 import im . actor . server . social . SocialManager 
 import im . actor . util . cache . CacheHelpers . _ 
 @ @ - 38 , 13 + 39 , 21 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } 
 } 
 
 - protected def ackSendMessage ( sm : SendMessage ) : Unit = { 
 + protected def ackSendMessage ( state : DialogState , sm : SendMessage ) : Unit = { 
 if ( peer . typ = = PeerType . Private ) SocialManager . recordRelation ( sm . origin . id , userId ) 
 - deliveryExt . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) map ( _ ⇒ SendMessageAck ( ) ) pipeTo sender ( ) 
 + 
 + deliveryExt 
 + . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 + . map ( _ ⇒ SendMessageAck ( ) ) 
 + . pipeTo ( sender ( ) ) 
 + 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 
 / / onSuccess ( fu ) { _ = > 
 / / updatePeerMessageDate ( ) 
 / / } 
 + 
 } 
 
 protected def writeMessage ( 
 @ @ - 131 , 6 + 140 , 38 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } 
 } 
 
 + protected def show ( state : DialogState ) : Unit = { 
 + if ( ! state . isHidden ) 
 + sender ! Status . Failure ( DialogErrors . DialogAlreadyShown ( peer ) ) 
 + else { 
 + val future = 
 + ( for { 
 + _ ← db . run ( DialogRepo . show ( userId , peer ) ) 
 + seqstate ← userExt . notifyDialogsChanged ( userId ) 
 + } yield seqstate ) pipeTo sender ( ) 
 + 
 + onSuccess ( future ) { _ ⇒ 
 + updateShown ( state ) 
 + } 
 + } 
 + } 
 + 
 + protected def hide ( state : DialogState ) : Unit = { 
 + if ( state . isHidden ) 
 + sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) 
 + else { 
 + val future = 
 + ( for { 
 + _ ← db . run ( DialogRepo . hide ( userId , peer ) ) 
 + seqstate ← userExt . notifyDialogsChanged ( userId ) 
 + } yield seqstate ) pipeTo sender ( ) 
 + 
 + onSuccess ( future ) { _ ⇒ 
 + updateHidden ( state ) 
 + } 
 + } 
 + } 
 + 
 private def mustMakeReceive ( state : DialogState , mr : MessageReceived ) : Boolean = peer match { 
 case Peer ( PeerType . Private , _ ) ⇒ 
 ( mr . date > state . lastOwnReceiveDate ) & & / / receive date is later than last receive date 
 @ @ - 165 , 4 + 206 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 private def updateOwnReadDate ( state : DialogState , date : Long ) : Unit = 
 context become initialized ( state . updated ( LastOwnReadDate ( date ) ) ) 
 
 + private def updateShown ( state : DialogState ) : Unit = 
 + context become initialized ( state . updated ( Shown ) ) 
 + 
 + private def updateHidden ( state : DialogState ) : Unit = 
 + context become initialized ( state . updated ( Hidden ) ) 
 + 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala 
 index 3248d0f . . 81f95c2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala 
 @ @ - 1 , 5 + 1 , 14 @ @ 
 package im . actor . server . dialog 
 
 + import im . actor . server . model . Peer 
 + 
 + import scala . util . control . NoStackTrace 
 + 
 + abstract class DialogError ( msg : String ) extends RuntimeException ( msg ) with NoStackTrace 
 + 
 object DialogErrors { 
 - final object MessageToSelf extends Exception ( " Private dialog with self is not allowed " ) 
 + object MessageToSelf extends DialogError ( " Private dialog with self is not allowed " ) 
 + 
 + final case class DialogAlreadyShown ( peer : Peer ) extends DialogError ( s " Dialog $ { peer } is already shown " ) 
 + final case class DialogAlreadyHidden ( peer : Peer ) extends DialogError ( s " Dialog $ { peer } is already hidden " ) 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 8ee49ca . . 55230de 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 16 , 7 + 16 , 7 @ @ import im . actor . server . dialog . DialogCommands . _ 
 import im . actor . server . group . GroupExtension 
 import im . actor . server . model . { Peer , PeerType , Dialog ⇒ DialogModel } 
 import im . actor . server . persist . { DialogRepo , HistoryMessageRepo } 
 - import im . actor . server . sequence . SeqStateDate 
 + import im . actor . server . sequence . { SeqState , SeqStateDate } 
 import im . actor . server . user . UserExtension 
 import org . joda . time . DateTime 
 import slick . dbio . DBIO 
 @ @ - 95 , 6 + 95 , 12 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def ackMessageRead ( peer : Peer , mr : MessageRead ) : Future [ Unit ] = 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 
 + def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 + ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + 
 + def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 + ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 case Seq ( ) ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 index d0a8176 . . b3178ed 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 @ @ - 10 , 7 + 10 , 7 @ @ import im . actor . api . rpc . misc . ApiExtension 
 import im . actor . serialization . ActorSerializer 
 import im . actor . server . KeyValueMappings 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . dialog . { DialogCommand , DialogExtension } 
 + import im . actor . server . dialog . { DirectDialogCommand , DialogExtension } 
 import im . actor . server . event . TSEvent 
 import im . actor . server . file . { FileStorageAdapter , S3StorageExtension , Avatar } 
 import im . actor . server . office . { PeerProcessor , ProcessorState , StopOffice } 
 @ @ - 239 , 9 + 239 , 9 @ @ private [ group ] final class GroupProcessor 
 makeUserAdmin ( state , clientUserId , candidateId ) 
 case RevokeIntegrationToken ( _ , userId ) ⇒ 
 revokeIntegrationToken ( state , userId ) 
 - case StopOffice ⇒ context stop self 
 - case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) 
 - case dc : DialogCommand ⇒ groupPeer forward dc 
 + case StopOffice ⇒ context stop self 
 + case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) 
 + case dc : DirectDialogCommand ⇒ groupPeer forward dc 
 } 
 
 private [ this ] var groupStateMaybe : Option [ Group ] = None 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 index 48e3db8 . . 5698901 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . server . user 
 import akka . actor . { Actor , ActorRef , Props } 
 import im . actor . api . rpc . PeersImplicits 
 import im . actor . api . rpc . misc . ApiExtension 
 - import im . actor . server . dialog . { Dialog , DialogCommand } 
 + import im . actor . server . dialog . { DirectDialogCommand , Dialog , DialogCommand } 
 import im . actor . server . model . { Peer , PeerType } 
 
 private [ user ] object UserPeer { 
 @ @ - 15 , 18 + 15 , 22 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e 
 private val selfPeer = Peer . privat ( userId ) 
 
 def receive : Receive = { 
 - case dc : DialogCommand ⇒ dialogRef ( dc ) forward dc 
 - case other ⇒ context . system . log . debug ( " Unmatched message : { } " , other ) 
 + case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc 
 + case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc 
 + case other ⇒ context . system . log . debug ( " Unmatched message : { } " , other ) 
 } 
 
 - private def dialogRef ( dc : DialogCommand ) : ActorRef = { 
 + private def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { 
 val peer = dc . dest match { 
 case Peer ( PeerType . Group , _ ) ⇒ dc . dest 
 case Peer ( PeerType . Private , _ ) ⇒ if ( dc . origin = = selfPeer ) dc . dest else dc . origin 
 } 
 - context . child ( dialogName ( peer ) ) getOrElse context . actorOf ( Dialog . props ( userId , peer , extensions ) , dialogName ( peer ) ) 
 + dialogRef ( peer ) 
 } 
 
 + private def dialogRef ( peer : Peer ) : ActorRef = 
 + context . child ( dialogName ( peer ) ) getOrElse context . actorOf ( Dialog . props ( userId , peer , extensions ) , dialogName ( peer ) ) 
 + 
 private def dialogName ( peer : Peer ) : String = peer . typ match { 
 case PeerType . Private ⇒ s " Private _ $ { peer . id } " 
 case PeerType . Group ⇒ s " Group _ $ { peer . id } " 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index 1884e60 . . 863c6b8 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 6 , 7 + 6 , 7 @ @ import im . actor . api . rpc . _ 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . misc . { ResponseSeq , ResponseVoid } 
 import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType } 
 - import im . actor . server . dialog . HistoryUtils 
 + import im . actor . server . dialog . { DialogErrors , HistoryUtils } 
 import im . actor . server . group . GroupUtils 
 import im . actor . server . persist . DialogRepo 
 import im . actor . server . sequence . SeqState 
 @ @ - 111 , 21 + 111 , 25 @ @ trait HistoryHandlers { 
 
 override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = { 
 authorized ( clientData ) { implicit client ⇒ 
 - for { 
 - _ ← db . run ( DialogRepo . hide ( client . userId , peer . asModel ) ) 
 - seqstate ← userExt . notifyDialogsChanged ( client . userId ) 
 + ( for { 
 + seqstate ← dialogExt . hide ( client . userId , peer . asModel ) 
 groups ← dialogExt . getGroupedDialogs ( client . userId ) 
 - } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . state . toByteArray , groups = groups ) ) 
 + } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . state . toByteArray , groups = groups ) ) ) recover { 
 + case DialogErrors . DialogAlreadyHidden ( peer ) ⇒ 
 + Error ( RpcError ( 406 , " DIALOG _ ALREADY _ HIDDEN " , " Dialog is already hidden . " , canTryAgain = false , None ) ) 
 + } 
 } 
 } 
 
 override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = { 
 authorized ( clientData ) { implicit client ⇒ 
 - for { 
 - _ ← db . run ( DialogRepo . show ( client . userId , peer . asModel ) ) 
 - SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) 
 + ( for { 
 + seqstate ← dialogExt . show ( client . userId , peer . asModel ) 
 groups ← dialogExt . getGroupedDialogs ( client . userId ) 
 - } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups = groups ) ) 
 + } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . toByteArray , groups = groups ) ) ) recover { 
 + case DialogErrors . DialogAlreadyHidden ( peer ) ⇒ 
 + Error ( RpcError ( 406 , " DIALOG _ ALREADY _ SHOWN " , " Dialog is already shown . " , canTryAgain = false , None ) ) 
 + } 
 } 
 }
