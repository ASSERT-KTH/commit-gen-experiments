BLEU SCORE: 0.07611541650494039

TEST MSG: fix ( server : messaging ) : fixed favourites behavior
GENERATED MSG: feat ( server ) : ResumableProjection ; store message header in NewMessage , fixed GroupsServiceSpec

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > index 043543f . . d4b028a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > @ @ - 11 , 8 + 11 , 8 @ @ import scala . concurrent . Future < nl > import scala . reflect . ClassTag < nl > import scala . util . control . NoStackTrace < nl > < nl > - trait ProcessorState [ S , E ] { < nl > - def updated ( e : E ) : S < nl > + trait ProcessorState [ S ] { < nl > + def updated ( e : Event ) : S < nl > < nl > def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : S < nl > < nl > @ @ - 31 , 7 + 31 , 7 @ @ trait PersistenceDebug extends PersistentActor with ActorLogging with AlertingAc < nl > } < nl > } < nl > < nl > - trait IncrementalSnapshots [ S < : ProcessorState [ S , E ] , E ] extends ProcessorStateControl [ S , E ] with PersistenceDebug { < nl > + trait IncrementalSnapshots [ S < : ProcessorState [ S ] ] extends ProcessorStateControl [ S ] with PersistenceDebug { < nl > private var _ commitsNum = 0 < nl > < nl > val SnapshotCommitsThreshold = 100 < nl > @ @ - 46 , 16 + 46 , 16 @ @ trait IncrementalSnapshots [ S < : ProcessorState [ S , E ] , E ] extends ProcessorStateC < nl > } < nl > } < nl > < nl > - trait ProcessorStateControl [ S < : ProcessorState [ S , E ] , E ] { < nl > + trait ProcessorStateControl [ S < : ProcessorState [ S ] ] { < nl > private [ this ] var _ state : S = getInitialState < nl > < nl > protected def getInitialState : S < nl > < nl > - protected final def state : S = _ state < nl > + final def state : S = _ state < nl > < nl > - protected def setState ( state : S ) = this . _ state = state < nl > + def setState ( state : S ) = this . _ state = state < nl > < nl > - protected def commit ( e : E ) : S = { < nl > + def commit ( e : Event ) : S = { < nl > beforeCommit ( ) < nl > setState ( state . updated ( e ) ) < nl > afterCommit ( ) < nl > @ @ - 67 , 13 + 67 , 16 @ @ trait ProcessorStateControl [ S < : ProcessorState [ S , E ] , E ] { < nl > protected def afterCommit ( ) = { } < nl > } < nl > < nl > + object ProcessorStateProbe { < nl > + def apply [ S < : ProcessorState [ S ] ] ( initial : S ) = new ProcessorStateProbe [ S ] ( initial ) < nl > + } < nl > < nl > - final class ProcessorStateProbe [ S < : ProcessorState [ S , E ] , E ] ( initial : S ) extends ProcessorStateControl [ S , E ] { < nl > + final class ProcessorStateProbe [ S < : ProcessorState [ S ] ] ( initial : S ) extends ProcessorStateControl [ S ] { < nl > override protected def getInitialState : S = initial < nl > } < nl > < nl > - abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] < nl > - extends ProcessorStateControl [ S , E ] < nl > + abstract class Processor [ S < : ProcessorState [ S ] ] < nl > + extends ProcessorStateControl [ S ] < nl > with PersistenceDebug { < nl > < nl > import context . dispatcher < nl > @ @ - 89 , 7 + 92 , 7 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] < nl > } < nl > < nl > override final def receiveRecover = { < nl > - case e : E ⇒ < nl > + case e : Event ⇒ < nl > setState ( state . updated ( e ) ) < nl > case SnapshotOffer ( metadata , snapshot ) ⇒ < nl > setState ( state . withSnapshot ( metadata , snapshot ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala < nl > index ada9106 . . 3be0e6e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala < nl > @ @ - 21 , 7 + 21 , 7 @ @ object ResumableProjection { < nl > private [ cqrs ] val maxHits = 20 < nl > } < nl > < nl > - private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState , Event ] { < nl > + private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState ] { < nl > this : ResumableProjectionState ⇒ < nl > < nl > import ResumableProjectionEvents . _ < nl > @ @ - 49 , 7 + 49 , 7 @ @ final class ResumableProjection ( id : String ) ( implicit factory : ActorRefFactory ) { < nl > < nl > private var isStopped = false < nl > < nl > - private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState , Event ] { < nl > + private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState ] { < nl > import ResumableProjectionEvents . _ < nl > < nl > override def persistenceId : String = s " RProj _ $ id " < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 05e032d . . 2fa0765 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 54 , 10 + 54 , 10 @ @ private [ dialog ] final case class DialogState ( < nl > counter : Int , < nl > unreadMessages : SortedSet [ UnreadMessage ] , < nl > unreadMessagesMap : Map [ Long , Long ] < nl > - ) extends ProcessorState [ DialogState , DialogEvent ] { < nl > + ) extends ProcessorState [ DialogState ] { < nl > import DialogEvents . _ < nl > < nl > - override def updated ( e : DialogEvent ) : DialogState = e match { < nl > + override def updated ( e : Event ) : DialogState = e match { < nl > case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ < nl > if ( senderUserId ! = userId ) { < nl > this . copy ( < nl > @ @ - 132 , 8 + 132 , 8 @ @ object DialogProcessor { < nl > } < nl > < nl > private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , extensions : Seq [ ApiExtension ] ) < nl > - extends Processor [ DialogState , DialogEvent ] < nl > - with IncrementalSnapshots [ DialogState , DialogEvent ] < nl > + extends Processor [ DialogState ] < nl > + with IncrementalSnapshots [ DialogState ] < nl > with AlertingActor < nl > with DialogCommandHandlers < nl > with ActorFutures < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index 9cb4ace . . 2d44f6c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 35 , 8 + 35 , 8 @ @ private object SortableDialog { < nl > val ordering = new Ordering [ SortableDialog ] { < nl > override def compare ( x : SortableDialog , y : SortableDialog ) : Int = < nl > if ( x . peer = = y . peer ) 0 < nl > - else if ( x . ts . isBefore ( y . ts ) ) 1 < nl > - else if ( x . ts . isAfter ( y . ts ) ) - 1 < nl > + else if ( x . ts . isBefore ( y . ts ) ) - 1 < nl > + else if ( x . ts . isAfter ( y . ts ) ) 1 < nl > else 0 < nl > } < nl > } < nl > @ @ - 46 , 8 + 46 , 8 @ @ private case class SortableDialog ( ts : Instant , peer : Peer ) < nl > private object DialogRootState { < nl > val initial = DialogRootState ( < nl > Map ( < nl > - DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . ordering ) , < nl > - DialogGroupType . Groups → SortedSet . empty ( SortableDialog . ordering ) < nl > + DialogGroupType . Groups → SortedSet . empty ( SortableDialog . ordering ) , < nl > + DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . ordering ) < nl > ) , < nl > SortedSet . empty ( SortableDialog . ordering ) , < nl > SortedSet . empty ( SortableDialog . ordering ) < nl > @ @ - 58 , 10 + 58 , 10 @ @ private final case class DialogRootState ( < nl > active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , < nl > activePeers : SortedSet [ SortableDialog ] , < nl > archived : SortedSet [ SortableDialog ] < nl > - ) extends ProcessorState [ DialogRootState , DialogRootEvent ] { < nl > + ) extends ProcessorState [ DialogRootState ] { < nl > import DialogRootEvents . _ < nl > < nl > - override def updated ( e : DialogRootEvent ) : DialogRootState = e match { < nl > + override def updated ( e : Event ) : DialogRootState = e match { < nl > case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) < nl > case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > @ @ - 122 , 7 + 122 , 7 @ @ private final case class DialogRootState ( < nl > < nl > copy ( < nl > activePeers = this . activePeers + sortableDialog , < nl > - active = this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , < nl > + active = this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , < nl > archived = this . archived - sortableDialog < nl > ) < nl > } < nl > @ @ - 132 , 7 + 132 , 7 @ @ private final case class DialogRootState ( < nl > < nl > copy ( < nl > active = < nl > - ( this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { < nl > + ( this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { < nl > case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false < nl > case _ ⇒ true < nl > } < nl > @ @ - 219 , 8 + 219 , 8 @ @ private trait DialogRootQueryHandlers { < nl > } < nl > < nl > private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) < nl > - extends Processor [ DialogRootState , DialogRootEvent ] < nl > - with IncrementalSnapshots [ DialogRootState , DialogRootEvent ] < nl > + extends Processor [ DialogRootState ] < nl > + with IncrementalSnapshots [ DialogRootState ] < nl > with DialogRootQueryHandlers { < nl > import DialogRootEvents . _ < nl > import DialogRootQueries . _ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > index 23fda9a . . 321502a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > @ @ - 2 , 7 + 2 , 7 @ @ package im . actor . server . group < nl > < nl > import akka . actor . { Actor , ActorLogging , ActorSystem , Props } < nl > import akka . persistence . SnapshotMetadata < nl > - import im . actor . server . cqrs . ProcessorState < nl > + import im . actor . server . cqrs . { Event , ProcessorState } < nl > import im . actor . server . dialog . { DialogCommands , DialogExtension } < nl > < nl > import scala . concurrent . ExecutionContext < nl > @ @ - 15 , 9 + 15 , 9 @ @ private [ group ] case class GroupPeerState ( < nl > lastSenderId : Int , < nl > lastReceiveDate : Long , < nl > lastReadDate : Long < nl > - ) extends ProcessorState [ GroupPeerState , GroupPeerEvent ] { < nl > + ) extends ProcessorState [ GroupPeerState ] { < nl > import GroupPeerEvents . _ < nl > - override def updated ( e : GroupPeerEvent ) : GroupPeerState = e match { < nl > + override def updated ( e : Event ) : GroupPeerState = e match { < nl > case LastSenderIdChanged ( id ) ⇒ this . copy ( lastSenderId = id ) < nl > case LastReceiveDateChanged ( date ) ⇒ this . copy ( lastReceiveDate = date ) < nl > case LastReadDateChanged ( date ) ⇒ this . copy ( lastReadDate = date ) < nl > @ @ - 26 , 7 + 26 , 7 @ @ private [ group ] case class GroupPeerState ( < nl > override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupPeerState = this < nl > } < nl > < nl > - private [ group ] sealed trait GroupPeerEvent < nl > + private [ group ] sealed trait GroupPeerEvent extends Event < nl > < nl > object GroupPeerEvents { < nl > private [ group ] case class LastSenderIdChanged ( id : Int ) extends GroupPeerEvent < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > index 29b1a4b . . 431c5e6 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > @ @ - 7 , 7 + 7 , 7 @ @ import akka . pattern . ask < nl > import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . users . UpdateUserLocalNameChanged < nl > - import im . actor . server . cqrs . { Processor , ProcessorState } < nl > + import im . actor . server . cqrs . { Event , Processor , ProcessorState } < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . persist . contact . UserContactRepo < nl > import im . actor . server . sequence . SeqState < nl > @ @ - 15 , 10 + 15 , 10 @ @ import im . actor . server . user . UserCommands . EditLocalName < nl > < nl > import scala . concurrent . Future < nl > < nl > - private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . empty ) extends ProcessorState [ UserContactsState , UserEvent ] { < nl > + private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . empty ) extends ProcessorState [ UserContactsState ] { < nl > import UserEvents . _ < nl > < nl > - override def updated ( e : UserEvent ) : UserContactsState = e match { < nl > + override def updated ( e : Event ) : UserContactsState = e match { < nl > case LocalNameChanged ( _ , contactUserId , localNameOpt ) ⇒ < nl > localNameOpt match { < nl > case None ⇒ this < nl > @ @ - 37 , 7 + 37 , 7 @ @ private [ user ] final class UserContacts ( userId : Int ) ( implicit factory : ActorRefFa < nl > ( ref ? EditLocalName ( userId , contactUserId , nameOpt , supressUpdate ) ) . mapTo [ SeqState ] < nl > } < nl > < nl > - private [ user ] final class UserContactsActor ( userId : Int ) extends Processor [ UserContactsState , UserEvent ] { < nl > + private [ user ] final class UserContactsActor ( userId : Int ) extends Processor [ UserContactsState ] { < nl > import UserCommands . _ < nl > import UserQueries . _ < nl > import UserEvents . _ < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . b1eab08 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > @ @ - 0 , 0 + 1 , 55 @ @ < nl > + package im . actor . server . dialog < nl > + < nl > + import java . time . Instant < nl > + < nl > + import im . actor . api . rpc . PeersImplicits < nl > + import im . actor . server . ActorSuite < nl > + import im . actor . server . cqrs . ProcessorStateProbe < nl > + import im . actor . server . model . Peer < nl > + < nl > + final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > + it should " have DMs and Groups by default " in default < nl > + it should " sort dialogs by appearing " in show < nl > + it should " remove Favourites on Unfavourite " in favouriteUnfavourite < nl > + < nl > + import DialogRootEvents . _ < nl > + < nl > + def default ( ) = { < nl > + val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + probe . state . active . keys should be ( Set ( DialogGroupType . Groups , DialogGroupType . DirectMessages ) ) < nl > + } < nl > + < nl > + def show ( ) = { < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + < nl > + val alice = Peer . privat ( 1 ) < nl > + val bob = Peer . privat ( 2 ) < nl > + < nl > + probe . commit ( Created ( Instant . now ( ) , Some ( alice ) ) ) < nl > + probe . commit ( Created ( Instant . now ( ) . plusMillis ( 1 ) , Some ( bob ) ) ) < nl > + < nl > + getActivePeers should be ( Seq ( alice , bob ) ) < nl > + < nl > + getGroupPeers ( DialogGroupType . DirectMessages ) should be ( Seq ( alice , bob ) ) < nl > + } < nl > + < nl > + def favouriteUnfavourite ( ) = { < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + < nl > + val alice = Peer . privat ( 1 ) < nl > + < nl > + probe . commit ( Favourited ( Instant . now , Some ( alice ) ) ) < nl > + getGroupPeers ( DialogGroupType . DirectMessages ) shouldNot contain ( alice ) < nl > + < nl > + probe . commit ( Unfavourited ( Instant . now , Some ( alice ) ) ) < nl > + < nl > + probe . state . active . keys shouldNot contain ( DialogGroupType . Favourites ) < nl > + getGroupPeers ( DialogGroupType . DirectMessages ) should contain ( alice ) < nl > + } < nl > + < nl > + private def getGroupPeers ( typ : DialogGroupType ) ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = < nl > + probe . state . active . get ( typ ) . get . toSeq . map ( _ . peer ) < nl > + < nl > + private def getActivePeers ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = < nl > + probe . state . activePeers . toSeq . map ( _ . peer ) < nl > + } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / cqrs . proto b / actor - server / actor - core / src / main / protobuf / cqrs . proto < nl > new file mode 100644 < nl > index 0000000 . . 6c559c3 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / protobuf / cqrs . proto < nl > @ @ - 0 , 0 + 1 , 20 @ @ < nl > + syntax = " proto3 " ; < nl > + < nl > + package im . actor . server ; < nl > + < nl > + import " scalapb / scalapb . proto " ; < nl > + < nl > + message ResumableProjectionEvents { < nl > + message OffsetWritten { < nl > + option ( scalapb . message ) . extends = " im . actor . server . cqrs . Event " ; < nl > + < nl > + int64 offset = 1 ; < nl > + } < nl > + } < nl > + < nl > + message ResumableProjectionState { < nl > + option ( scalapb . message ) . extends = " im . actor . server . cqrs . ResumableProjectionStateBase " ; < nl > + < nl > + int64 offset = 1 ; < nl > + int32 hits = 2 ; < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 01c3afc . . b816596 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 295 , 6 + 295 , 7 @ @ message DialogEvents { < nl > int64 random _ id = 2 ; < nl > int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > int32 sender _ user _ id = 3 ; < nl > + int32 message _ header = 4 ; < nl > } < nl > < nl > message MessagesReceived { < nl > @ @ - 309 , 4 + 310 , 8 @ @ message DialogEvents { < nl > int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > int32 reader _ user _ id = 8 ; < nl > } < nl > + < nl > + message CounterReset { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > index 9f2b4eb . . b27c32b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import java . sql . SQLException < nl > < nl > import akka . actor . ActorLogging < nl > import akka . pattern . pipe < nl > - import akka . persistence . { PersistentActor , RecoveryCompleted } < nl > + import akka . persistence . { PersistentActor , RecoveryCompleted , SnapshotMetadata , SnapshotOffer } < nl > import im . actor . concurrent . AlertingActor < nl > < nl > import scala . concurrent . Future < nl > @ @ - 13 , 6 + 13 , 8 @ @ import scala . util . control . NoStackTrace < nl > < nl > trait ProcessorState [ S , E ] { < nl > def updated ( e : E ) : S < nl > + < nl > + def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : S < nl > } < nl > < nl > abstract class ProcessorError ( msg : String ) extends RuntimeException ( msg ) with NoStackTrace < nl > @ @ - 50 , 6 + 52 , 8 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] extends Persist < nl > override final def receiveRecover = { < nl > case e : E ⇒ < nl > _ state = _ state . updated ( e ) < nl > + case SnapshotOffer ( metadata , snapshot ) ⇒ < nl > + _ state = _ state . withSnapshot ( metadata , snapshot ) < nl > case RecoveryCompleted ⇒ onRecoveryCompleted ( ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala < nl > new file mode 100644 < nl > index 0000000 . . ada9106 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala < nl > @ @ - 0 , 0 + 1 , 89 @ @ < nl > + package im . actor . server . cqrs < nl > + < nl > + import akka . actor . { ActorRef , ActorRefFactory , PoisonPill , Props } < nl > + import akka . pattern . ask < nl > + import akka . http . scaladsl . util . FastFuture < nl > + import akka . persistence . SnapshotMetadata < nl > + import akka . util . Timeout < nl > + import im . actor . config . ActorConfig < nl > + import im . actor . serialization . ActorSerializer < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + object ResumableProjection { < nl > + ActorSerializer . register ( < nl > + 110001 → classOf [ ResumableProjectionEvents . OffsetWritten ] , < nl > + 110002 → classOf [ ResumableProjectionState ] < nl > + ) < nl > + < nl > + def apply ( id : String ) ( implicit factory : ActorRefFactory ) = new ResumableProjection ( id ) < nl > + < nl > + private [ cqrs ] val maxHits = 20 < nl > + } < nl > + < nl > + private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState , Event ] { < nl > + this : ResumableProjectionState ⇒ < nl > + < nl > + import ResumableProjectionEvents . _ < nl > + < nl > + override def updated ( e : Event ) : ResumableProjectionState = e match { < nl > + case ow : OffsetWritten ⇒ < nl > + copy ( offset = ow . offset , hits = hits + 1 ) < nl > + } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : ResumableProjectionState = snapshot match { < nl > + case s : ResumableProjectionState ⇒ s < nl > + } < nl > + } < nl > + < nl > + final class ResumableProjection ( id : String ) ( implicit factory : ActorRefFactory ) { < nl > + import factory . dispatcher < nl > + < nl > + private case class SaveOffset ( offset : Long ) < nl > + private object SaveOffsetAck < nl > + < nl > + private object GetOffset < nl > + private case class GetOffsetResponse ( offset : Long ) < nl > + < nl > + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) < nl > + < nl > + private var isStopped = false < nl > + < nl > + private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState , Event ] { < nl > + import ResumableProjectionEvents . _ < nl > + < nl > + override def persistenceId : String = s " RProj _ $ id " < nl > + < nl > + override protected def getInitialState : ResumableProjectionState = ResumableProjectionState ( 0L , 0 ) < nl > + < nl > + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > + case GetOffset ⇒ FastFuture . successful ( GetOffsetResponse ( state . offset ) ) < nl > + } < nl > + < nl > + override protected def handleCommand : Receive = { < nl > + case SaveOffset ( offset ) ⇒ persist ( OffsetWritten ( offset ) ) { e ⇒ < nl > + commit ( e ) < nl > + < nl > + if ( state . hits > 10 ) { < nl > + saveSnapshot ( state ) < nl > + setState ( state . copy ( hits = 0 ) ) < nl > + } < nl > + < nl > + sender ( ) ! SaveOffsetAck < nl > + } < nl > + } < nl > + } ) ) < nl > + < nl > + private def actor : ActorRef = < nl > + if ( isStopped ) throw new IllegalStateException ( " Projection is stopped " ) < nl > + else _ actor < nl > + < nl > + def latestOffset : Future [ Long ] = ( actor ? GetOffset ) . mapTo [ GetOffsetResponse ] map ( _ . offset ) < nl > + < nl > + def saveOffset ( offset : Long ) : Future [ Unit ] = ( actor ? SaveOffset ( offset ) ) map ( _ ⇒ ( ) ) < nl > + < nl > + def stop ( ) : Unit = { < nl > + actor ! PoisonPill < nl > + isStopped = true < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index e02e96e . . b8044bf 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 30 , 7 + 30 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > becomeStashing ( replyTo ⇒ ( { < nl > case seq : SeqStateDate ⇒ < nl > - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id ) ) { e ⇒ < nl > + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ < nl > commit ( e ) < nl > replyTo ! seq < nl > unstashAll ( ) < nl > @ @ - 70 , 7 + 70 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > throw new RuntimeException ( " No message date found in SendMessage " ) < nl > } < nl > < nl > - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id ) ) { e ⇒ < nl > + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ < nl > commit ( e ) < nl > < nl > if ( peer . typ = = PeerType . Private ) { < nl > @ @ - 97 , 7 + 97 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > sender ( ) ! Status . Failure ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) < nl > } else { < nl > - persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId ) ) { e ⇒ < nl > + persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId , message . header ) ) { e ⇒ < nl > commit ( e ) < nl > db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) < nl > . map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index ae2bb79 . . 9fdac80 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . server . dialog < nl > import java . time . Instant < nl > < nl > import akka . actor . _ < nl > + import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import com . github . benmanes . caffeine . cache . Cache < nl > import im . actor . api . rpc . misc . ApiExtension < nl > @ @ - 55 , 7 + 56 , 7 @ @ private [ dialog ] final case class DialogState ( < nl > import DialogEvents . _ < nl > < nl > override def updated ( e : DialogEvent ) : DialogState = e match { < nl > - case NewMessage ( randomId , date , senderUserId ) ⇒ < nl > + case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ < nl > if ( senderUserId ! = userId ) { < nl > this . copy ( < nl > counter = counter + 1 , < nl > @ @ - 69 , 7 + 70 , 10 @ @ private [ dialog ] final case class DialogState ( < nl > case MessagesRead ( date , readerUserId ) if readerUserId ! = userId & & date . isAfter ( lastReadDate ) ⇒ < nl > this . copy ( lastReadDate = date ) < nl > case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) < nl > + case CounterReset ( ) ⇒ this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) ) < nl > } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogState = this < nl > } < nl > < nl > object DialogProcessor { < nl > @ @ - 78 , 7 + 82 , 8 @ @ object DialogProcessor { < nl > ActorSerializer . register ( < nl > 40010 → classOf [ DialogEvents . MessagesRead ] , < nl > 40011 → classOf [ DialogEvents . MessagesReceived ] , < nl > - 40012 → classOf [ DialogEvents . NewMessage ] < nl > + 40012 → classOf [ DialogEvents . NewMessage ] , < nl > + 40013 → classOf [ DialogEvents . CounterReset ] < nl > ) < nl > } < nl > < nl > @ @ - 103 , 12 + 108 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > protected implicit val ec : ExecutionContext = context . dispatcher < nl > protected implicit val system : ActorSystem = context . system < nl > < nl > + protected implicit val timeout = Timeout ( 5 . seconds ) < nl > + < nl > protected val db : Database = DbExtension ( system ) . db < nl > protected val userExt = UserExtension ( system ) < nl > protected val groupExt = GroupExtension ( system ) < nl > protected implicit val socialRegion = SocialExtension ( system ) . region < nl > - protected implicit val timeout = Timeout ( 5 . seconds ) < nl > - < nl > protected val dialogExt = DialogExtension ( system ) < nl > protected val deliveryExt = dialogExt . getDeliveryExtension ( extensions ) < nl > protected val seqUpdExt = SeqUpdatesExtension ( context . system ) < nl > @ @ - 131 , 36 + 136 , 35 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > ) < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > - case GetCounter ( _ ) ⇒ < nl > - Future . successful ( GetCounterResponse ( state . counter ) ) < nl > - case GetInfo ( _ ) ⇒ Future . successful ( < nl > + case GetCounter ( _ ) ⇒ getCounter ( ) map ( GetCounterResponse ( _ ) ) < nl > + case GetInfo ( _ ) ⇒ getCounter ( ) map { counter ⇒ < nl > GetInfoResponse ( Some ( DialogInfo ( < nl > peer = Some ( peer ) , < nl > - counter = state . counter , < nl > + counter = counter , < nl > date = state . lastMessageDate , < nl > lastMessageDate = state . lastMessageDate , < nl > lastReceivedDate = state . lastReceiveDate , < nl > lastReadDate = state . lastReadDate < nl > ) ) ) < nl > - ) < nl > + } < nl > } < nl > < nl > override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) < nl > < nl > / / when receiving this messages , dialog reacts on other dialog ' s action < nl > def reactions ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received < nl > - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received < nl > + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) < nl > case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( rr ) < nl > } < nl > < nl > / / when receiving this messages , dialog is required to take an action < nl > def actions ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) < nl > case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) < nl > case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) < nl > @ @ - 191 , 4 + 195 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > * @ return does dialog owner accepts this command < nl > * / < nl > private def accepts ( dc : DirectDialogCommand ) = ( dc . getDest = = selfPeer ) | | ( ( dc . getDest = = peer ) & & ( dc . getOrigin ! = selfPeer ) ) < nl > + < nl > + private def getCounter ( ) : Future [ Int ] = { < nl > + groupExt . isMember ( peer . id , userId ) map { < nl > + case true ⇒ state . counter < nl > + case false ⇒ 0 < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index cf67226 . . 1a5a772 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant < nl > < nl > import akka . actor . { ActorRef , Props , Status } < nl > import akka . pattern . { ask , pipe } < nl > + import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import im . actor . concurrent . _ < nl > import im . actor . server . cqrs . _ < nl > @ @ - 57 , 6 + 58 , 8 @ @ private final case class DialogRootState ( < nl > case Unfavourited ( _ , Some ( peer ) ) ⇒ withUnfavouritedPeer ( peer ) < nl > } < nl > < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = this < nl > + < nl > private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > index 9ed906a . . 10f3bc3 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > @ @ - 114 , 6 + 114 , 9 @ @ private [ group ] sealed trait Queries { < nl > def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = < nl > ( viewRegion . ref ? GetMembers ( groupId ) ) . mapTo [ GetMembersResponse ] map ( r ⇒ ( r . memberIds , r . invitedUserIds , r . botId ) ) < nl > < nl > + def isMember ( groupId : Int , userId : Int ) : Future [ Boolean ] = < nl > + getMemberIds ( groupId ) map ( _ . _ 1 . contains ( userId ) ) < nl > + < nl > def getAccessHash ( groupId : Int ) : Future [ Long ] = < nl > ( viewRegion . ref ? GetAccessHash ( groupId ) ) . mapTo [ GetAccessHashResponse ] map ( _ . accessHash ) < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > index c9ce341 . . 23fda9a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > @ @ - 1 , 8 + 1 , 9 @ @ < nl > package im . actor . server . group < nl > < nl > - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } < nl > + import akka . actor . { Actor , ActorLogging , ActorSystem , Props } < nl > + import akka . persistence . SnapshotMetadata < nl > import im . actor . server . cqrs . ProcessorState < nl > - import im . actor . server . dialog . { DialogExtension , DialogCommands } < nl > + import im . actor . server . dialog . { DialogCommands , DialogExtension } < nl > < nl > import scala . concurrent . ExecutionContext < nl > < nl > @ @ - 21 , 6 + 22 , 8 @ @ private [ group ] case class GroupPeerState ( < nl > case LastReceiveDateChanged ( date ) ⇒ this . copy ( lastReceiveDate = date ) < nl > case LastReadDateChanged ( date ) ⇒ this . copy ( lastReadDate = date ) < nl > } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupPeerState = this < nl > } < nl > < nl > private [ group ] sealed trait GroupPeerEvent < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > index 2de0cd1 . . 29b1a4b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant < nl > < nl > import akka . actor . { ActorRefFactory , Props } < nl > import akka . pattern . ask < nl > + import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . users . UpdateUserLocalNameChanged < nl > import im . actor . server . cqrs . { Processor , ProcessorState } < nl > @ @ - 25 , 6 + 26 , 8 @ @ private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . em < nl > this . copy ( localNames = localNames + ( contactUserId → localName ) ) < nl > } < nl > } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : UserContactsState = this < nl > } < nl > < nl > private [ user ] final class UserContacts ( userId : Int ) ( implicit factory : ActorRefFactory ) { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > index 416b7cf . . 9e75b2c 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > @ @ - 862 , 7 + 862 , 7 @ @ final class GroupsServiceSpec < nl > < nl > whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > val dialog = resp . toOption . get . dialogs . head < nl > - dialog . unreadCount > 6 shouldEqual true < nl > + dialog . unreadCount should be > 6 < nl > } < nl > < nl > whenReady ( service . handleLeaveGroup ( groupOutPeer , Random . nextLong ( ) ) ) { resp ⇒ < nl > @ @ - 973 , 6 + 973 , 14 @ @ final class GroupsServiceSpec < nl > } < nl > val outPeer = ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) < nl > < nl > + { < nl > + implicit val clientData = clientData2 < nl > + whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > + val dialog = resp . toOption . get . dialogs . head < nl > + dialog . unreadCount shouldBe 2 < nl > + } < nl > + } < nl > + < nl > for ( _ ← 1 to 6 ) { < nl > implicit val clientData = clientData1 < nl > whenReady ( messagingService . handleSendMessage ( outPeer , Random . nextLong ( ) , ApiTextMessage ( " hello public " , Vector . empty , None ) , None ) ) { _ ⇒ } < nl > @ @ - 984 , 7 + 992 , 7 @ @ final class GroupsServiceSpec < nl > implicit val clientData = clientData2 < nl > whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > val dialog = resp . toOption . get . dialogs . head < nl > - dialog . unreadCount shouldBe 6 < nl > + dialog . unreadCount shouldBe 8 < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 index 043543f . . d4b028a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 @ @ - 11 , 8 + 11 , 8 @ @ import scala . concurrent . Future 
 import scala . reflect . ClassTag 
 import scala . util . control . NoStackTrace 
 
 - trait ProcessorState [ S , E ] { 
 - def updated ( e : E ) : S 
 + trait ProcessorState [ S ] { 
 + def updated ( e : Event ) : S 
 
 def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : S 
 
 @ @ - 31 , 7 + 31 , 7 @ @ trait PersistenceDebug extends PersistentActor with ActorLogging with AlertingAc 
 } 
 } 
 
 - trait IncrementalSnapshots [ S < : ProcessorState [ S , E ] , E ] extends ProcessorStateControl [ S , E ] with PersistenceDebug { 
 + trait IncrementalSnapshots [ S < : ProcessorState [ S ] ] extends ProcessorStateControl [ S ] with PersistenceDebug { 
 private var _ commitsNum = 0 
 
 val SnapshotCommitsThreshold = 100 
 @ @ - 46 , 16 + 46 , 16 @ @ trait IncrementalSnapshots [ S < : ProcessorState [ S , E ] , E ] extends ProcessorStateC 
 } 
 } 
 
 - trait ProcessorStateControl [ S < : ProcessorState [ S , E ] , E ] { 
 + trait ProcessorStateControl [ S < : ProcessorState [ S ] ] { 
 private [ this ] var _ state : S = getInitialState 
 
 protected def getInitialState : S 
 
 - protected final def state : S = _ state 
 + final def state : S = _ state 
 
 - protected def setState ( state : S ) = this . _ state = state 
 + def setState ( state : S ) = this . _ state = state 
 
 - protected def commit ( e : E ) : S = { 
 + def commit ( e : Event ) : S = { 
 beforeCommit ( ) 
 setState ( state . updated ( e ) ) 
 afterCommit ( ) 
 @ @ - 67 , 13 + 67 , 16 @ @ trait ProcessorStateControl [ S < : ProcessorState [ S , E ] , E ] { 
 protected def afterCommit ( ) = { } 
 } 
 
 + object ProcessorStateProbe { 
 + def apply [ S < : ProcessorState [ S ] ] ( initial : S ) = new ProcessorStateProbe [ S ] ( initial ) 
 + } 
 
 - final class ProcessorStateProbe [ S < : ProcessorState [ S , E ] , E ] ( initial : S ) extends ProcessorStateControl [ S , E ] { 
 + final class ProcessorStateProbe [ S < : ProcessorState [ S ] ] ( initial : S ) extends ProcessorStateControl [ S ] { 
 override protected def getInitialState : S = initial 
 } 
 
 - abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] 
 - extends ProcessorStateControl [ S , E ] 
 + abstract class Processor [ S < : ProcessorState [ S ] ] 
 + extends ProcessorStateControl [ S ] 
 with PersistenceDebug { 
 
 import context . dispatcher 
 @ @ - 89 , 7 + 92 , 7 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] 
 } 
 
 override final def receiveRecover = { 
 - case e : E ⇒ 
 + case e : Event ⇒ 
 setState ( state . updated ( e ) ) 
 case SnapshotOffer ( metadata , snapshot ) ⇒ 
 setState ( state . withSnapshot ( metadata , snapshot ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala 
 index ada9106 . . 3be0e6e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala 
 @ @ - 21 , 7 + 21 , 7 @ @ object ResumableProjection { 
 private [ cqrs ] val maxHits = 20 
 } 
 
 - private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState , Event ] { 
 + private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState ] { 
 this : ResumableProjectionState ⇒ 
 
 import ResumableProjectionEvents . _ 
 @ @ - 49 , 7 + 49 , 7 @ @ final class ResumableProjection ( id : String ) ( implicit factory : ActorRefFactory ) { 
 
 private var isStopped = false 
 
 - private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState , Event ] { 
 + private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState ] { 
 import ResumableProjectionEvents . _ 
 
 override def persistenceId : String = s " RProj _ $ id " 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 05e032d . . 2fa0765 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 54 , 10 + 54 , 10 @ @ private [ dialog ] final case class DialogState ( 
 counter : Int , 
 unreadMessages : SortedSet [ UnreadMessage ] , 
 unreadMessagesMap : Map [ Long , Long ] 
 - ) extends ProcessorState [ DialogState , DialogEvent ] { 
 + ) extends ProcessorState [ DialogState ] { 
 import DialogEvents . _ 
 
 - override def updated ( e : DialogEvent ) : DialogState = e match { 
 + override def updated ( e : Event ) : DialogState = e match { 
 case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ 
 if ( senderUserId ! = userId ) { 
 this . copy ( 
 @ @ - 132 , 8 + 132 , 8 @ @ object DialogProcessor { 
 } 
 
 private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , extensions : Seq [ ApiExtension ] ) 
 - extends Processor [ DialogState , DialogEvent ] 
 - with IncrementalSnapshots [ DialogState , DialogEvent ] 
 + extends Processor [ DialogState ] 
 + with IncrementalSnapshots [ DialogState ] 
 with AlertingActor 
 with DialogCommandHandlers 
 with ActorFutures 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index 9cb4ace . . 2d44f6c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 35 , 8 + 35 , 8 @ @ private object SortableDialog { 
 val ordering = new Ordering [ SortableDialog ] { 
 override def compare ( x : SortableDialog , y : SortableDialog ) : Int = 
 if ( x . peer = = y . peer ) 0 
 - else if ( x . ts . isBefore ( y . ts ) ) 1 
 - else if ( x . ts . isAfter ( y . ts ) ) - 1 
 + else if ( x . ts . isBefore ( y . ts ) ) - 1 
 + else if ( x . ts . isAfter ( y . ts ) ) 1 
 else 0 
 } 
 } 
 @ @ - 46 , 8 + 46 , 8 @ @ private case class SortableDialog ( ts : Instant , peer : Peer ) 
 private object DialogRootState { 
 val initial = DialogRootState ( 
 Map ( 
 - DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . ordering ) , 
 - DialogGroupType . Groups → SortedSet . empty ( SortableDialog . ordering ) 
 + DialogGroupType . Groups → SortedSet . empty ( SortableDialog . ordering ) , 
 + DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . ordering ) 
 ) , 
 SortedSet . empty ( SortableDialog . ordering ) , 
 SortedSet . empty ( SortableDialog . ordering ) 
 @ @ - 58 , 10 + 58 , 10 @ @ private final case class DialogRootState ( 
 active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , 
 activePeers : SortedSet [ SortableDialog ] , 
 archived : SortedSet [ SortableDialog ] 
 - ) extends ProcessorState [ DialogRootState , DialogRootEvent ] { 
 + ) extends ProcessorState [ DialogRootState ] { 
 import DialogRootEvents . _ 
 
 - override def updated ( e : DialogRootEvent ) : DialogRootState = e match { 
 + override def updated ( e : Event ) : DialogRootState = e match { 
 case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) 
 case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 @ @ - 122 , 7 + 122 , 7 @ @ private final case class DialogRootState ( 
 
 copy ( 
 activePeers = this . activePeers + sortableDialog , 
 - active = this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , 
 + active = this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , 
 archived = this . archived - sortableDialog 
 ) 
 } 
 @ @ - 132 , 7 + 132 , 7 @ @ private final case class DialogRootState ( 
 
 copy ( 
 active = 
 - ( this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { 
 + ( this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { 
 case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false 
 case _ ⇒ true 
 } 
 @ @ - 219 , 8 + 219 , 8 @ @ private trait DialogRootQueryHandlers { 
 } 
 
 private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) 
 - extends Processor [ DialogRootState , DialogRootEvent ] 
 - with IncrementalSnapshots [ DialogRootState , DialogRootEvent ] 
 + extends Processor [ DialogRootState ] 
 + with IncrementalSnapshots [ DialogRootState ] 
 with DialogRootQueryHandlers { 
 import DialogRootEvents . _ 
 import DialogRootQueries . _ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 index 23fda9a . . 321502a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 @ @ - 2 , 7 + 2 , 7 @ @ package im . actor . server . group 
 
 import akka . actor . { Actor , ActorLogging , ActorSystem , Props } 
 import akka . persistence . SnapshotMetadata 
 - import im . actor . server . cqrs . ProcessorState 
 + import im . actor . server . cqrs . { Event , ProcessorState } 
 import im . actor . server . dialog . { DialogCommands , DialogExtension } 
 
 import scala . concurrent . ExecutionContext 
 @ @ - 15 , 9 + 15 , 9 @ @ private [ group ] case class GroupPeerState ( 
 lastSenderId : Int , 
 lastReceiveDate : Long , 
 lastReadDate : Long 
 - ) extends ProcessorState [ GroupPeerState , GroupPeerEvent ] { 
 + ) extends ProcessorState [ GroupPeerState ] { 
 import GroupPeerEvents . _ 
 - override def updated ( e : GroupPeerEvent ) : GroupPeerState = e match { 
 + override def updated ( e : Event ) : GroupPeerState = e match { 
 case LastSenderIdChanged ( id ) ⇒ this . copy ( lastSenderId = id ) 
 case LastReceiveDateChanged ( date ) ⇒ this . copy ( lastReceiveDate = date ) 
 case LastReadDateChanged ( date ) ⇒ this . copy ( lastReadDate = date ) 
 @ @ - 26 , 7 + 26 , 7 @ @ private [ group ] case class GroupPeerState ( 
 override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupPeerState = this 
 } 
 
 - private [ group ] sealed trait GroupPeerEvent 
 + private [ group ] sealed trait GroupPeerEvent extends Event 
 
 object GroupPeerEvents { 
 private [ group ] case class LastSenderIdChanged ( id : Int ) extends GroupPeerEvent 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 index 29b1a4b . . 431c5e6 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 @ @ - 7 , 7 + 7 , 7 @ @ import akka . pattern . ask 
 import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import im . actor . api . rpc . users . UpdateUserLocalNameChanged 
 - import im . actor . server . cqrs . { Processor , ProcessorState } 
 + import im . actor . server . cqrs . { Event , Processor , ProcessorState } 
 import im . actor . server . db . DbExtension 
 import im . actor . server . persist . contact . UserContactRepo 
 import im . actor . server . sequence . SeqState 
 @ @ - 15 , 10 + 15 , 10 @ @ import im . actor . server . user . UserCommands . EditLocalName 
 
 import scala . concurrent . Future 
 
 - private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . empty ) extends ProcessorState [ UserContactsState , UserEvent ] { 
 + private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . empty ) extends ProcessorState [ UserContactsState ] { 
 import UserEvents . _ 
 
 - override def updated ( e : UserEvent ) : UserContactsState = e match { 
 + override def updated ( e : Event ) : UserContactsState = e match { 
 case LocalNameChanged ( _ , contactUserId , localNameOpt ) ⇒ 
 localNameOpt match { 
 case None ⇒ this 
 @ @ - 37 , 7 + 37 , 7 @ @ private [ user ] final class UserContacts ( userId : Int ) ( implicit factory : ActorRefFa 
 ( ref ? EditLocalName ( userId , contactUserId , nameOpt , supressUpdate ) ) . mapTo [ SeqState ] 
 } 
 
 - private [ user ] final class UserContactsActor ( userId : Int ) extends Processor [ UserContactsState , UserEvent ] { 
 + private [ user ] final class UserContactsActor ( userId : Int ) extends Processor [ UserContactsState ] { 
 import UserCommands . _ 
 import UserQueries . _ 
 import UserEvents . _ 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 new file mode 100644 
 index 0000000 . . b1eab08 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 @ @ - 0 , 0 + 1 , 55 @ @ 
 + package im . actor . server . dialog 
 + 
 + import java . time . Instant 
 + 
 + import im . actor . api . rpc . PeersImplicits 
 + import im . actor . server . ActorSuite 
 + import im . actor . server . cqrs . ProcessorStateProbe 
 + import im . actor . server . model . Peer 
 + 
 + final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 + it should " have DMs and Groups by default " in default 
 + it should " sort dialogs by appearing " in show 
 + it should " remove Favourites on Unfavourite " in favouriteUnfavourite 
 + 
 + import DialogRootEvents . _ 
 + 
 + def default ( ) = { 
 + val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + probe . state . active . keys should be ( Set ( DialogGroupType . Groups , DialogGroupType . DirectMessages ) ) 
 + } 
 + 
 + def show ( ) = { 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + 
 + val alice = Peer . privat ( 1 ) 
 + val bob = Peer . privat ( 2 ) 
 + 
 + probe . commit ( Created ( Instant . now ( ) , Some ( alice ) ) ) 
 + probe . commit ( Created ( Instant . now ( ) . plusMillis ( 1 ) , Some ( bob ) ) ) 
 + 
 + getActivePeers should be ( Seq ( alice , bob ) ) 
 + 
 + getGroupPeers ( DialogGroupType . DirectMessages ) should be ( Seq ( alice , bob ) ) 
 + } 
 + 
 + def favouriteUnfavourite ( ) = { 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + 
 + val alice = Peer . privat ( 1 ) 
 + 
 + probe . commit ( Favourited ( Instant . now , Some ( alice ) ) ) 
 + getGroupPeers ( DialogGroupType . DirectMessages ) shouldNot contain ( alice ) 
 + 
 + probe . commit ( Unfavourited ( Instant . now , Some ( alice ) ) ) 
 + 
 + probe . state . active . keys shouldNot contain ( DialogGroupType . Favourites ) 
 + getGroupPeers ( DialogGroupType . DirectMessages ) should contain ( alice ) 
 + } 
 + 
 + private def getGroupPeers ( typ : DialogGroupType ) ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = 
 + probe . state . active . get ( typ ) . get . toSeq . map ( _ . peer ) 
 + 
 + private def getActivePeers ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = 
 + probe . state . activePeers . toSeq . map ( _ . peer ) 
 + } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / cqrs . proto b / actor - server / actor - core / src / main / protobuf / cqrs . proto 
 new file mode 100644 
 index 0000000 . . 6c559c3 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / protobuf / cqrs . proto 
 @ @ - 0 , 0 + 1 , 20 @ @ 
 + syntax = " proto3 " ; 
 + 
 + package im . actor . server ; 
 + 
 + import " scalapb / scalapb . proto " ; 
 + 
 + message ResumableProjectionEvents { 
 + message OffsetWritten { 
 + option ( scalapb . message ) . extends = " im . actor . server . cqrs . Event " ; 
 + 
 + int64 offset = 1 ; 
 + } 
 + } 
 + 
 + message ResumableProjectionState { 
 + option ( scalapb . message ) . extends = " im . actor . server . cqrs . ResumableProjectionStateBase " ; 
 + 
 + int64 offset = 1 ; 
 + int32 hits = 2 ; 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 01c3afc . . b816596 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 295 , 6 + 295 , 7 @ @ message DialogEvents { 
 int64 random _ id = 2 ; 
 int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 int32 sender _ user _ id = 3 ; 
 + int32 message _ header = 4 ; 
 } 
 
 message MessagesReceived { 
 @ @ - 309 , 4 + 310 , 8 @ @ message DialogEvents { 
 int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 int32 reader _ user _ id = 8 ; 
 } 
 + 
 + message CounterReset { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 index 9f2b4eb . . b27c32b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import java . sql . SQLException 
 
 import akka . actor . ActorLogging 
 import akka . pattern . pipe 
 - import akka . persistence . { PersistentActor , RecoveryCompleted } 
 + import akka . persistence . { PersistentActor , RecoveryCompleted , SnapshotMetadata , SnapshotOffer } 
 import im . actor . concurrent . AlertingActor 
 
 import scala . concurrent . Future 
 @ @ - 13 , 6 + 13 , 8 @ @ import scala . util . control . NoStackTrace 
 
 trait ProcessorState [ S , E ] { 
 def updated ( e : E ) : S 
 + 
 + def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : S 
 } 
 
 abstract class ProcessorError ( msg : String ) extends RuntimeException ( msg ) with NoStackTrace 
 @ @ - 50 , 6 + 52 , 8 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] extends Persist 
 override final def receiveRecover = { 
 case e : E ⇒ 
 _ state = _ state . updated ( e ) 
 + case SnapshotOffer ( metadata , snapshot ) ⇒ 
 + _ state = _ state . withSnapshot ( metadata , snapshot ) 
 case RecoveryCompleted ⇒ onRecoveryCompleted ( ) 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala 
 new file mode 100644 
 index 0000000 . . ada9106 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala 
 @ @ - 0 , 0 + 1 , 89 @ @ 
 + package im . actor . server . cqrs 
 + 
 + import akka . actor . { ActorRef , ActorRefFactory , PoisonPill , Props } 
 + import akka . pattern . ask 
 + import akka . http . scaladsl . util . FastFuture 
 + import akka . persistence . SnapshotMetadata 
 + import akka . util . Timeout 
 + import im . actor . config . ActorConfig 
 + import im . actor . serialization . ActorSerializer 
 + 
 + import scala . concurrent . Future 
 + 
 + object ResumableProjection { 
 + ActorSerializer . register ( 
 + 110001 → classOf [ ResumableProjectionEvents . OffsetWritten ] , 
 + 110002 → classOf [ ResumableProjectionState ] 
 + ) 
 + 
 + def apply ( id : String ) ( implicit factory : ActorRefFactory ) = new ResumableProjection ( id ) 
 + 
 + private [ cqrs ] val maxHits = 20 
 + } 
 + 
 + private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState , Event ] { 
 + this : ResumableProjectionState ⇒ 
 + 
 + import ResumableProjectionEvents . _ 
 + 
 + override def updated ( e : Event ) : ResumableProjectionState = e match { 
 + case ow : OffsetWritten ⇒ 
 + copy ( offset = ow . offset , hits = hits + 1 ) 
 + } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : ResumableProjectionState = snapshot match { 
 + case s : ResumableProjectionState ⇒ s 
 + } 
 + } 
 + 
 + final class ResumableProjection ( id : String ) ( implicit factory : ActorRefFactory ) { 
 + import factory . dispatcher 
 + 
 + private case class SaveOffset ( offset : Long ) 
 + private object SaveOffsetAck 
 + 
 + private object GetOffset 
 + private case class GetOffsetResponse ( offset : Long ) 
 + 
 + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) 
 + 
 + private var isStopped = false 
 + 
 + private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState , Event ] { 
 + import ResumableProjectionEvents . _ 
 + 
 + override def persistenceId : String = s " RProj _ $ id " 
 + 
 + override protected def getInitialState : ResumableProjectionState = ResumableProjectionState ( 0L , 0 ) 
 + 
 + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 + case GetOffset ⇒ FastFuture . successful ( GetOffsetResponse ( state . offset ) ) 
 + } 
 + 
 + override protected def handleCommand : Receive = { 
 + case SaveOffset ( offset ) ⇒ persist ( OffsetWritten ( offset ) ) { e ⇒ 
 + commit ( e ) 
 + 
 + if ( state . hits > 10 ) { 
 + saveSnapshot ( state ) 
 + setState ( state . copy ( hits = 0 ) ) 
 + } 
 + 
 + sender ( ) ! SaveOffsetAck 
 + } 
 + } 
 + } ) ) 
 + 
 + private def actor : ActorRef = 
 + if ( isStopped ) throw new IllegalStateException ( " Projection is stopped " ) 
 + else _ actor 
 + 
 + def latestOffset : Future [ Long ] = ( actor ? GetOffset ) . mapTo [ GetOffsetResponse ] map ( _ . offset ) 
 + 
 + def saveOffset ( offset : Long ) : Future [ Unit ] = ( actor ? SaveOffset ( offset ) ) map ( _ ⇒ ( ) ) 
 + 
 + def stop ( ) : Unit = { 
 + actor ! PoisonPill 
 + isStopped = true 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index e02e96e . . b8044bf 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 30 , 7 + 30 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 becomeStashing ( replyTo ⇒ ( { 
 case seq : SeqStateDate ⇒ 
 - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id ) ) { e ⇒ 
 + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ 
 commit ( e ) 
 replyTo ! seq 
 unstashAll ( ) 
 @ @ - 70 , 7 + 70 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 throw new RuntimeException ( " No message date found in SendMessage " ) 
 } 
 
 - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id ) ) { e ⇒ 
 + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ 
 commit ( e ) 
 
 if ( peer . typ = = PeerType . Private ) { 
 @ @ - 97 , 7 + 97 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 sender ( ) ! Status . Failure ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) 
 } else { 
 - persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId ) ) { e ⇒ 
 + persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId , message . header ) ) { e ⇒ 
 commit ( e ) 
 db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) 
 . map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index ae2bb79 . . 9fdac80 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . server . dialog 
 import java . time . Instant 
 
 import akka . actor . _ 
 + import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import com . github . benmanes . caffeine . cache . Cache 
 import im . actor . api . rpc . misc . ApiExtension 
 @ @ - 55 , 7 + 56 , 7 @ @ private [ dialog ] final case class DialogState ( 
 import DialogEvents . _ 
 
 override def updated ( e : DialogEvent ) : DialogState = e match { 
 - case NewMessage ( randomId , date , senderUserId ) ⇒ 
 + case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ 
 if ( senderUserId ! = userId ) { 
 this . copy ( 
 counter = counter + 1 , 
 @ @ - 69 , 7 + 70 , 10 @ @ private [ dialog ] final case class DialogState ( 
 case MessagesRead ( date , readerUserId ) if readerUserId ! = userId & & date . isAfter ( lastReadDate ) ⇒ 
 this . copy ( lastReadDate = date ) 
 case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) 
 + case CounterReset ( ) ⇒ this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) ) 
 } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogState = this 
 } 
 
 object DialogProcessor { 
 @ @ - 78 , 7 + 82 , 8 @ @ object DialogProcessor { 
 ActorSerializer . register ( 
 40010 → classOf [ DialogEvents . MessagesRead ] , 
 40011 → classOf [ DialogEvents . MessagesReceived ] , 
 - 40012 → classOf [ DialogEvents . NewMessage ] 
 + 40012 → classOf [ DialogEvents . NewMessage ] , 
 + 40013 → classOf [ DialogEvents . CounterReset ] 
 ) 
 } 
 
 @ @ - 103 , 12 + 108 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 protected implicit val ec : ExecutionContext = context . dispatcher 
 protected implicit val system : ActorSystem = context . system 
 
 + protected implicit val timeout = Timeout ( 5 . seconds ) 
 + 
 protected val db : Database = DbExtension ( system ) . db 
 protected val userExt = UserExtension ( system ) 
 protected val groupExt = GroupExtension ( system ) 
 protected implicit val socialRegion = SocialExtension ( system ) . region 
 - protected implicit val timeout = Timeout ( 5 . seconds ) 
 - 
 protected val dialogExt = DialogExtension ( system ) 
 protected val deliveryExt = dialogExt . getDeliveryExtension ( extensions ) 
 protected val seqUpdExt = SeqUpdatesExtension ( context . system ) 
 @ @ - 131 , 36 + 136 , 35 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 ) 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 - case GetCounter ( _ ) ⇒ 
 - Future . successful ( GetCounterResponse ( state . counter ) ) 
 - case GetInfo ( _ ) ⇒ Future . successful ( 
 + case GetCounter ( _ ) ⇒ getCounter ( ) map ( GetCounterResponse ( _ ) ) 
 + case GetInfo ( _ ) ⇒ getCounter ( ) map { counter ⇒ 
 GetInfoResponse ( Some ( DialogInfo ( 
 peer = Some ( peer ) , 
 - counter = state . counter , 
 + counter = counter , 
 date = state . lastMessageDate , 
 lastMessageDate = state . lastMessageDate , 
 lastReceivedDate = state . lastReceiveDate , 
 lastReadDate = state . lastReadDate 
 ) ) ) 
 - ) 
 + } 
 } 
 
 override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) 
 
 / / when receiving this messages , dialog reacts on other dialog ' s action 
 def reactions ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received 
 - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received 
 + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) 
 case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( rr ) 
 } 
 
 / / when receiving this messages , dialog is required to take an action 
 def actions ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) 
 case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) 
 case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) 
 @ @ - 191 , 4 + 195 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 * @ return does dialog owner accepts this command 
 * / 
 private def accepts ( dc : DirectDialogCommand ) = ( dc . getDest = = selfPeer ) | | ( ( dc . getDest = = peer ) & & ( dc . getOrigin ! = selfPeer ) ) 
 + 
 + private def getCounter ( ) : Future [ Int ] = { 
 + groupExt . isMember ( peer . id , userId ) map { 
 + case true ⇒ state . counter 
 + case false ⇒ 0 
 + } 
 + } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index cf67226 . . 1a5a772 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant 
 
 import akka . actor . { ActorRef , Props , Status } 
 import akka . pattern . { ask , pipe } 
 + import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import im . actor . concurrent . _ 
 import im . actor . server . cqrs . _ 
 @ @ - 57 , 6 + 58 , 8 @ @ private final case class DialogRootState ( 
 case Unfavourited ( _ , Some ( peer ) ) ⇒ withUnfavouritedPeer ( peer ) 
 } 
 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = this 
 + 
 private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 index 9ed906a . . 10f3bc3 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 @ @ - 114 , 6 + 114 , 9 @ @ private [ group ] sealed trait Queries { 
 def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = 
 ( viewRegion . ref ? GetMembers ( groupId ) ) . mapTo [ GetMembersResponse ] map ( r ⇒ ( r . memberIds , r . invitedUserIds , r . botId ) ) 
 
 + def isMember ( groupId : Int , userId : Int ) : Future [ Boolean ] = 
 + getMemberIds ( groupId ) map ( _ . _ 1 . contains ( userId ) ) 
 + 
 def getAccessHash ( groupId : Int ) : Future [ Long ] = 
 ( viewRegion . ref ? GetAccessHash ( groupId ) ) . mapTo [ GetAccessHashResponse ] map ( _ . accessHash ) 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 index c9ce341 . . 23fda9a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 @ @ - 1 , 8 + 1 , 9 @ @ 
 package im . actor . server . group 
 
 - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } 
 + import akka . actor . { Actor , ActorLogging , ActorSystem , Props } 
 + import akka . persistence . SnapshotMetadata 
 import im . actor . server . cqrs . ProcessorState 
 - import im . actor . server . dialog . { DialogExtension , DialogCommands } 
 + import im . actor . server . dialog . { DialogCommands , DialogExtension } 
 
 import scala . concurrent . ExecutionContext 
 
 @ @ - 21 , 6 + 22 , 8 @ @ private [ group ] case class GroupPeerState ( 
 case LastReceiveDateChanged ( date ) ⇒ this . copy ( lastReceiveDate = date ) 
 case LastReadDateChanged ( date ) ⇒ this . copy ( lastReadDate = date ) 
 } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupPeerState = this 
 } 
 
 private [ group ] sealed trait GroupPeerEvent 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 index 2de0cd1 . . 29b1a4b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant 
 
 import akka . actor . { ActorRefFactory , Props } 
 import akka . pattern . ask 
 + import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import im . actor . api . rpc . users . UpdateUserLocalNameChanged 
 import im . actor . server . cqrs . { Processor , ProcessorState } 
 @ @ - 25 , 6 + 26 , 8 @ @ private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . em 
 this . copy ( localNames = localNames + ( contactUserId → localName ) ) 
 } 
 } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : UserContactsState = this 
 } 
 
 private [ user ] final class UserContacts ( userId : Int ) ( implicit factory : ActorRefFactory ) { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 index 416b7cf . . 9e75b2c 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 @ @ - 862 , 7 + 862 , 7 @ @ final class GroupsServiceSpec 
 
 whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 val dialog = resp . toOption . get . dialogs . head 
 - dialog . unreadCount > 6 shouldEqual true 
 + dialog . unreadCount should be > 6 
 } 
 
 whenReady ( service . handleLeaveGroup ( groupOutPeer , Random . nextLong ( ) ) ) { resp ⇒ 
 @ @ - 973 , 6 + 973 , 14 @ @ final class GroupsServiceSpec 
 } 
 val outPeer = ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) 
 
 + { 
 + implicit val clientData = clientData2 
 + whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 + val dialog = resp . toOption . get . dialogs . head 
 + dialog . unreadCount shouldBe 2 
 + } 
 + } 
 + 
 for ( _ ← 1 to 6 ) { 
 implicit val clientData = clientData1 
 whenReady ( messagingService . handleSendMessage ( outPeer , Random . nextLong ( ) , ApiTextMessage ( " hello public " , Vector . empty , None ) , None ) ) { _ ⇒ } 
 @ @ - 984 , 7 + 992 , 7 @ @ final class GroupsServiceSpec 
 implicit val clientData = clientData2 
 whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 val dialog = resp . toOption . get . dialogs . head 
 - dialog . unreadCount shouldBe 6 
 + dialog . unreadCount shouldBe 8 
 } 
 }
