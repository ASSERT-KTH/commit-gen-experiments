BLEU SCORE: 0.4216120484488187

TEST MSG: fix ( server : push ) : group push notifications corrected
GENERATED MSG: feat ( server : push ) : enable custom ringtones for APNS

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / sequence . proto b / actor - server / actor - core / src / main / protobuf / sequence . proto < nl > index d0c415f . . 056b93a 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / sequence . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / sequence . proto < nl > @ @ - 26 , 6 + 26 , 7 @ @ message PushData { < nl > string text = 1 ; < nl > string censoredText = 3 ; < nl > Peer peer = 2 ; < nl > + bool is _ mentioned = 4 ; < nl > } < nl > < nl > message PushRules { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > index f58eaaa . . d34c550 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > @ @ - 40 , 6 + 40 , 11 @ @ final class ActorDelivery ( val system : ActorSystem ) < nl > quotedMessage = None < nl > ) < nl > < nl > + val isMentioned = message match { < nl > + case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . contains ( receiverUserId ) < nl > + case _ ⇒ false < nl > + } < nl > + < nl > for { < nl > senderName ← UserExtension ( system ) . getName ( senderUserId , receiverUserId ) < nl > ( pushText , censoredPushText ) ← getPushText ( peer , receiverUserId , senderName , message ) < nl > @ @ - 51 , 6 + 56 , 7 @ @ final class ActorDelivery ( val system : ActorSystem ) < nl > . withText ( pushText ) < nl > . withCensoredText ( censoredPushText ) < nl > . withPeer ( peer ) < nl > + . withIsMentioned ( isMentioned ) < nl > ) , < nl > deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , < nl > deliveryTag = deliveryTag < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala < nl > index b940b8d . . 08cfeb7 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala < nl > @ @ - 5 , 7 + 5 , 7 @ @ import akka . pattern . pipe < nl > import im . actor . concurrent . FutureExt < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . model . push . _ < nl > - import im . actor . server . model . { DeviceType , Peer } < nl > + import im . actor . server . model . { DeviceType , Peer , PeerType } < nl > import im . actor . server . persist . { AuthIdRepo , AuthSessionRepo } < nl > import im . actor . server . persist . configs . ParameterRepo < nl > import im . actor . server . persist . push . { ActorPushCredentialsRepo , ApplePushCredentialsRepo , FirebasePushCredentialsKV , GooglePushCredentialsRepo } < nl > @ @ - 24 , 7 + 24 , 13 @ @ private final case class PushCredentialsInfo ( appId : Int , authId : Long ) < nl > < nl > private final case class AllNotificationSettings ( < nl > generic : NotificationSettings = NotificationSettings ( ) , < nl > - specific : Map [ String , NotificationSettings ] = Map . empty < nl > + specific : Map [ String , NotificationSettings ] = Map . empty , < nl > + groups : GroupNotificationSettings = GroupNotificationSettings ( ) < nl > + ) < nl > + < nl > + private final case class GroupNotificationSettings ( < nl > + enabled : Boolean = true , < nl > + onlyMention : Boolean = false < nl > ) < nl > < nl > private final case class NotificationSettings ( < nl > @ @ - 81 , 20 + 87 , 29 @ @ private final class SettingsControl ( userId : Int ) extends Actor with ActorLogging < nl > < nl > private def load ( ) : Future [ AllNotificationSettings ] = < nl > db . run ( for { < nl > - generic ← loadAction ( DeviceType . Generic ) < nl > - mobile ← loadAction ( DeviceType . Mobile ) < nl > - tablet ← loadAction ( DeviceType . Tablet ) < nl > - desktop ← loadAction ( DeviceType . Desktop ) < nl > + generic ← loadForDevice ( DeviceType . Generic ) < nl > + mobile ← loadForDevice ( DeviceType . Mobile ) < nl > + tablet ← loadForDevice ( DeviceType . Tablet ) < nl > + desktop ← loadForDevice ( DeviceType . Desktop ) < nl > + < nl > + groups ← loadForGroups ( ) < nl > } yield AllNotificationSettings ( < nl > generic = generic , < nl > specific = Map ( < nl > DeviceType . Mobile → mobile , < nl > DeviceType . Tablet → tablet , < nl > DeviceType . Desktop → desktop < nl > - ) < nl > + ) , < nl > + groups = groups < nl > ) ) < nl > < nl > - private def loadAction ( deviceType : String ) : DBIO [ NotificationSettings ] = { < nl > + private def loadForGroups ( ) : DBIO [ GroupNotificationSettings ] = < nl > + for { < nl > + enabled ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . accountGroupEnabled , true ) < nl > + onlyMentions ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . accountGroupMentionEnabled , false ) < nl > + } yield GroupNotificationSettings ( enabled , onlyMentions ) < nl > + < nl > + private def loadForDevice ( deviceType : String ) : DBIO [ NotificationSettings ] = < nl > for { < nl > enabled ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . enabled ( deviceType ) , true ) < nl > sound ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . soundEnabled ( deviceType ) , true ) < nl > @ @ - 103 , 7 + 118 , 7 @ @ private final class SettingsControl ( userId : Int ) extends Actor with ActorLogging < nl > peers ← ParameterRepo . findPeerNotifications ( userId , deviceType ) < nl > customSounds ← ParameterRepo . findPeerRingtone ( userId ) < nl > } yield NotificationSettings ( enabled , sound , vibration , text , customSounds . toMap , peers . toMap ) < nl > - } < nl > + < nl > } < nl > < nl > private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLogging with Stash { < nl > @ @ - 120 , 6 + 135 , 7 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo < nl > private val applePushProvider = new ApplePushProvider ( userId ) ( context . system ) < nl > private val actorPushProvider = ActorPush ( context . system ) < nl > < nl > + / / TODO : why do we need ` PushCredentialsInfo ` , we have ` authId ` anyway ! < nl > private var mapping : Map [ PushCredentials , PushCredentialsInfo ] = Map . empty < nl > private var notificationSettings = AllNotificationSettings ( ) < nl > < nl > @ @ - 214 , 33 + 230 , 18 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo < nl > val deviceType = DeviceType ( info . appId ) < nl > < nl > if ( rules . excludeAuthIds . contains ( info . authId ) ) { < nl > - log . debug ( " AuthSid is excluded , not pushing " ) < nl > + log . debug ( " AuthId is excluded , not pushing " ) < nl > } else { < nl > rules . data match { < nl > case Some ( data ) ⇒ < nl > val settings = notificationSettings . specific . getOrElse ( deviceType , notificationSettings . generic ) < nl > < nl > - val isVisible = < nl > - ( settings . enabled , data . peer ) match { < nl > - case ( true , Some ( peer ) ) ⇒ < nl > - settings . peers . get ( peer ) match { < nl > - case Some ( true ) ⇒ < nl > - log . debug ( " Notifications for peer { } are enabled , push will be visible " , peer ) < nl > - true < nl > - case Some ( false ) ⇒ < nl > - log . debug ( " Notifications for peer { } are disabled , push will be invisible " , peer ) < nl > - false < nl > - case None ⇒ < nl > - log . debug ( " Notifications for peer { } are not set , push will be visible " , peer ) < nl > - true < nl > - } < nl > - case ( true , None ) ⇒ < nl > - log . debug ( " Notifications are enabled , delivering visible push " ) < nl > - true < nl > - case ( false , _ ) ⇒ < nl > - log . debug ( " Notifications are disabled , delivering invisible push " ) < nl > - false < nl > - } < nl > + val isVisible = isNotificationVisible ( < nl > + settings , < nl > + notificationSettings . groups , < nl > + data . peer , < nl > + data . isMentioned < nl > + ) < nl > < nl > if ( isVisible ) < nl > deliverVisible ( < nl > @ @ - 262 , 6 + 263 , 56 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo < nl > } < nl > } < nl > < nl > + private def isNotificationVisible ( < nl > + settings : NotificationSettings , < nl > + groupSettings : GroupNotificationSettings , < nl > + optPeer : Option [ Peer ] , < nl > + isMentioned : Boolean < nl > + ) = { < nl > + ( settings . enabled , optPeer ) match { < nl > + case ( true , Some ( peer ) ) ⇒ < nl > + peer . ` type ` match { < nl > + case PeerType . Group ⇒ < nl > + if ( groupSettings . enabled ) { < nl > + if ( groupSettings . onlyMention ) { < nl > + if ( isMentioned ) { < nl > + log . debug ( " User is mentioned , notification for group { } will be visible " , peer ) < nl > + true < nl > + } else { < nl > + log . debug ( " Message without mention , notification for group { } will be visible " , peer ) < nl > + false < nl > + } < nl > + } else { < nl > + log . debug ( " Group notifications are enabled , notification for group { } will be visible " , peer ) < nl > + true < nl > + } < nl > + } else { < nl > + log . debug ( " Group notifications are disabled , notification for group { } will be invisible " , peer ) < nl > + false < nl > + } < nl > + case _ ⇒ < nl > + settings . peers . get ( peer ) match { < nl > + case Some ( true ) ⇒ < nl > + log . debug ( " Notifications for peer { } are enabled , notification will be visible " , peer ) < nl > + true < nl > + case Some ( false ) ⇒ < nl > + log . debug ( " Notifications for peer { } are disabled , notification will be invisible " , peer ) < nl > + false < nl > + case None ⇒ < nl > + log . debug ( " Notifications for peer { } are not set , notification will be visible " , peer ) < nl > + true < nl > + } < nl > + < nl > + } < nl > + case ( true , None ) ⇒ < nl > + log . debug ( " Notifications are enabled , delivering visible push " ) < nl > + true < nl > + case ( false , _ ) ⇒ < nl > + log . debug ( " Notifications are disabled , delivering invisible push " ) < nl > + false < nl > + } < nl > + } < nl > + < nl > / * * < nl > * Delivers an invisible push with seq and contentAvailable < nl > * < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > index 04204cd . . b4d7d30 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > @ @ - 12 , 9 + 12 , 11 @ @ import scala . concurrent . Future < nl > trait DeliveryOperations { this : SeqUpdatesExtension ⇒ < nl > < nl > def pushRules ( isFat : Boolean , pushText : Option [ String ] , excludeAuthIds : Seq [ Long ] = Seq . empty ) : PushRules = < nl > - PushRules ( isFat = isFat ) < nl > - . withData ( PushData ( ) . withText ( pushText . getOrElse ( " " ) ) ) < nl > - . withExcludeAuthIds ( excludeAuthIds ) < nl > + PushRules ( < nl > + isFat = isFat , < nl > + excludeAuthIds = excludeAuthIds , < nl > + data = pushText map ( t ⇒ PushData ( text = t ) ) < nl > + ) < nl > < nl > / * * < nl > * Send update to all devices of user and return ` SeqState ` associated with ` authId ` < nl > @ @ - 147 , 9 + 149 , 10 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ < nl > Future . sequence ( userIds . toSeq map ( deliverUpdate ( _ , deliver ) ) ) map ( _ ⇒ ( ) ) < nl > < nl > private def deliverUpdate ( userId : Int , deliver : DeliverUpdate ) : Future [ SeqState ] = { < nl > - val isUpdateDefined = < nl > - deliver . getMapping . default . isDefined | | deliver . getMapping . custom . nonEmpty < nl > - require ( isUpdateDefined , " No default update nor authId - specific " ) < nl > + require ( < nl > + deliver . getMapping . default . isDefined | | deliver . getMapping . custom . nonEmpty , < nl > + " No default update nor authId - specific " < nl > + ) < nl > ( region . ref ? Envelope ( userId ) . withDeliverUpdate ( deliver ) ) . mapTo [ SeqState ] < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala b / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala < nl > index 0f80002 . . a30578f 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala < nl > @ @ - 1 , 7 + 1 , 5 @ @ < nl > package im . actor . server . userconfig < nl > < nl > - import im . actor . server . model . { Peer , PeerType } < nl > - < nl > object SettingsKeys { < nl > private def wrap ( deviceType : String , postfix : String ) : String = s " category . $ deviceType . notification . $ postfix " < nl > < nl > @ @ - 9 , 6 + 7 , 8 @ @ object SettingsKeys { < nl > < nl > private def wrapEnabled ( deviceType : String , postfix : String ) : String = s " category . $ deviceType . notification . $ postfix . enabled " < nl > < nl > + private def groups ( postfix : String ) = s " account . notifications . group . $ postfix " < nl > + < nl > def enabled ( deviceType : String ) = wrapEnabled ( deviceType ) < nl > < nl > def soundEnabled ( deviceType : String ) = wrapEnabled ( deviceType , " sound " ) < nl > @ @ - 16 , 4 + 16 , 9 @ @ object SettingsKeys { < nl > def vibrationEnabled ( deviceType : String ) = wrapEnabled ( deviceType , " vibration " ) < nl > < nl > def textEnabled ( deviceType : String ) = wrap ( deviceType , " show _ text " ) < nl > + < nl > + def accountGroupEnabled = groups ( " enabled " ) < nl > + < nl > + def accountGroupMentionEnabled = groups ( " mentions " ) < nl > + < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > index 219466b . . a3f261e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > @ @ - 39 , 6 + 39 , 7 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int ) ( implicit system : Ac < nl > data : PushData , < nl > isTextEnabled : Boolean , < nl > isSoundEnabled : Boolean , < nl > + customSound : Option [ String ] , < nl > isVibrationEnabled : Boolean < nl > ) : Unit = { < nl > withClient ( creds ) { implicit client ⇒ < nl > @ @ - 54 , 7 + 55 , 7 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int ) ( implicit system : Ac < nl > builder . setAlertBody ( data . censoredText ) < nl > < nl > if ( isSoundEnabled ) < nl > - builder . setSoundFileName ( " iapetus . caf " ) < nl > + builder . setSoundFileName ( customSound getOrElse " iapetus . caf " ) < nl > < nl > val payload = builder . buildWithDefaultMaximumLength ( ) < nl > sendNotification ( payload , creds , userId ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala < nl > index 243f7b2 . . c5bee73 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala < nl > @ @ - 26 , 11 + 26 , 12 @ @ private final case class AllNotificationSettings ( < nl > ) < nl > < nl > private final case class NotificationSettings ( < nl > - enabled : Boolean = true , < nl > - sound : Boolean = true , < nl > - vibration : Boolean = true , < nl > - text : Boolean = true , < nl > - peers : Map [ Peer , Boolean ] = Map . empty < nl > + enabled : Boolean = true , < nl > + sound : Boolean = true , < nl > + vibration : Boolean = true , < nl > + text : Boolean = true , < nl > + customSounds : Map [ Peer , String ] = Map . empty , < nl > + peers : Map [ Peer , Boolean ] = Map . empty < nl > ) < nl > < nl > private case object FailedToUnregister extends RuntimeException ( " Failed to unregister push credentials " ) < nl > @ @ - 98 , 7 + 99 , 8 @ @ private final class SettingsControl ( userId : Int ) extends Actor with ActorLogging < nl > vibration ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . vibrationEnabled ( deviceType ) , true ) < nl > text ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . textEnabled ( deviceType ) , true ) < nl > peers ← ParameterRepo . findPeerNotifications ( userId , deviceType ) < nl > - } yield NotificationSettings ( enabled , sound , vibration , text , peers . toMap ) < nl > + customSounds ← ParameterRepo . findPeerRingtone ( userId ) < nl > + } yield NotificationSettings ( enabled , sound , vibration , text , customSounds . toMap , peers . toMap ) < nl > } < nl > } < nl > < nl > @ @ - 225 , 20 + 227 , 18 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo < nl > false < nl > } < nl > < nl > - if ( isVisible ) { < nl > - val isSoundEnabled = settings . sound < nl > - val isTextEnabled = settings . text < nl > - val isVibrationEnabled = settings . vibration < nl > - < nl > + if ( isVisible ) < nl > deliverVisible ( < nl > seq = seq , < nl > creds = creds , < nl > data = data , < nl > - isTextEnabled = isTextEnabled , < nl > - isSoundEnabled = isSoundEnabled , < nl > - isVibrationEnabled = isVibrationEnabled < nl > + isTextEnabled = settings . text , < nl > + isSoundEnabled = settings . sound , < nl > + customSound = data . peer flatMap ( p ⇒ settings . customSounds . get ( p ) ) , < nl > + isVibrationEnabled = settings . vibration < nl > ) < nl > - } else deliverInvisible ( seq , creds ) < nl > + else < nl > + deliverInvisible ( seq , creds ) < nl > < nl > case _ ⇒ < nl > log . debug ( " No text , delivering simple seq " ) < nl > @ @ - 275 , 7 + 275 , 15 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo < nl > * @ param isVibrationEnabled < nl > * @ return < nl > * / < nl > - private def deliverVisible ( seq : Int , creds : PushCredentials , data : PushData , isTextEnabled : Boolean , isSoundEnabled : Boolean , isVibrationEnabled : Boolean ) = { < nl > + private def deliverVisible ( < nl > + seq : Int , < nl > + creds : PushCredentials , < nl > + data : PushData , < nl > + isTextEnabled : Boolean , < nl > + isSoundEnabled : Boolean , < nl > + customSound : Option [ String ] , < nl > + isVibrationEnabled : Boolean < nl > + ) = { < nl > creds match { < nl > case c : GooglePushCredentials ⇒ < nl > googlePushProvider . deliverVisible ( < nl > @ @ - 293 , 6 + 301 , 7 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo < nl > data = data , < nl > isTextEnabled = isTextEnabled , < nl > isSoundEnabled = isSoundEnabled , < nl > + customSound = customSound , < nl > isVibrationEnabled = isVibrationEnabled < nl > ) < nl > case c : ActorPushCredentials ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala b / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala < nl > index d049b81 . . 0f80002 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala < nl > @ @ - 9 , 12 + 9 , 6 @ @ object SettingsKeys { < nl > < nl > private def wrapEnabled ( deviceType : String , postfix : String ) : String = s " category . $ deviceType . notification . $ postfix . enabled " < nl > < nl > - private def peerStr ( peer : Peer ) = peer match { < nl > - case Peer ( PeerType . Private , id ) ⇒ s " PRIVATE _ $ id " < nl > - case Peer ( PeerType . Group , id ) ⇒ s " GROUP _ $ id " < nl > - case _ ⇒ throw new RuntimeException ( s " Unknown peer $ peer " ) < nl > - } < nl > - < nl > def enabled ( deviceType : String ) = wrapEnabled ( deviceType ) < nl > < nl > def soundEnabled ( deviceType : String ) = wrapEnabled ( deviceType , " sound " ) < nl > @ @ - 22 , 6 + 16 , 4 @ @ object SettingsKeys { < nl > def vibrationEnabled ( deviceType : String ) = wrapEnabled ( deviceType , " vibration " ) < nl > < nl > def textEnabled ( deviceType : String ) = wrap ( deviceType , " show _ text " ) < nl > - < nl > - def peerEnabled ( deviceType : String , peer : Peer ) = wrapEnabled ( deviceType , s " chat . $ { peerStr ( peer ) } " ) < nl > } < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > index 15b3fdf . . a6d98f8 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > @ @ - 50 , 29 + 50 , 47 @ @ object ParameterRepo { < nl > case _ ⇒ default < nl > } < nl > < nl > + def findPeerRingtone ( userId : Int ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ ( Peer , String ) ] ] = < nl > + extractPeerParams [ ( Peer , String ) ] ( userId , prefix = s " category . mobile . ios . ringtone . chat . " ) { < nl > + case ( key , optValue ) ⇒ < nl > + key . split ( " _ " ) . toList match { < nl > + case " GROUP " : : id : : Nil ⇒ < nl > + optValue map ( v ⇒ ( Peer ( PeerType . Group , id . toInt ) , v ) ) < nl > + case " PRIVATE " : : id : : Nil ⇒ < nl > + optValue map ( v ⇒ ( Peer ( PeerType . Private , id . toInt ) , v ) ) < nl > + case _ ⇒ None < nl > + } < nl > + } < nl > + < nl > def findPeerNotifications ( userId : Int , deviceType : String ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ ( Peer , Boolean ) ] ] = { < nl > def boolValue ( value : Option [ String ] ) = value match { < nl > case Some ( " false " ) ⇒ false < nl > case _ ⇒ true < nl > } < nl > < nl > - val prefix = s " category . $ deviceType . notification . chat . " < nl > - < nl > - for ( rows ← byUserIdAndKeyLikeC ( ( userId , s " $ prefix % _ % . % " ) ) . result ) yield { < nl > - rows flatMap { < nl > - case Parameter ( _ , key , value ) ⇒ < nl > - key . drop ( prefix . length ) . split ( " \ \ . " ) . toList match { < nl > - case peerStr : : " enabled " : : Nil ⇒ < nl > - peerStr . split ( " _ " ) . toList match { < nl > - case " GROUP " : : id : : Nil ⇒ < nl > - Some ( ( Peer ( PeerType . Group , id . toInt ) , boolValue ( value ) ) ) < nl > - case " PRIVATE " : : id : : Nil ⇒ < nl > - Some ( ( Peer ( PeerType . Private , id . toInt ) , boolValue ( value ) ) ) < nl > - case _ ⇒ None < nl > - } < nl > - case _ ⇒ None < nl > - } < nl > - } < nl > + extractPeerParams [ ( Peer , Boolean ) ] ( userId , s " category . $ deviceType . notification . chat . " ) { < nl > + case ( key , value ) ⇒ < nl > + key . split ( " \ \ . " ) . toList match { < nl > + case peerStr : : " enabled " : : Nil ⇒ < nl > + peerStr . split ( " _ " ) . toList match { < nl > + case " GROUP " : : id : : Nil ⇒ < nl > + Some ( ( Peer ( PeerType . Group , id . toInt ) , boolValue ( value ) ) ) < nl > + case " PRIVATE " : : id : : Nil ⇒ < nl > + Some ( ( Peer ( PeerType . Private , id . toInt ) , boolValue ( value ) ) ) < nl > + case _ ⇒ None < nl > + } < nl > + case _ ⇒ None < nl > + } < nl > } < nl > } < nl > + < nl > + private type KeyValue = ( String , Option [ String ] ) < nl > + < nl > + / / key passed in ` f ` comes without prefix < nl > + private def extractPeerParams [ T ] ( userId : Int , prefix : String ) ( f : KeyValue ⇒ Option [ T ] ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ T ] ] = < nl > + byUserIdAndKeyLikeC ( ( userId , s " $ prefix % " ) ) . result map { params ⇒ < nl > + val kvs : Seq [ KeyValue ] = params map ( p ⇒ p . key . drop ( prefix . length ) → p . value ) < nl > + ( kvs map f ) . flatten < nl > + } < nl > + < nl > } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / sequence . proto b / actor - server / actor - core / src / main / protobuf / sequence . proto 
 index d0c415f . . 056b93a 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / sequence . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / sequence . proto 
 @ @ - 26 , 6 + 26 , 7 @ @ message PushData { 
 string text = 1 ; 
 string censoredText = 3 ; 
 Peer peer = 2 ; 
 + bool is _ mentioned = 4 ; 
 } 
 
 message PushRules { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 index f58eaaa . . d34c550 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 @ @ - 40 , 6 + 40 , 11 @ @ final class ActorDelivery ( val system : ActorSystem ) 
 quotedMessage = None 
 ) 
 
 + val isMentioned = message match { 
 + case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . contains ( receiverUserId ) 
 + case _ ⇒ false 
 + } 
 + 
 for { 
 senderName ← UserExtension ( system ) . getName ( senderUserId , receiverUserId ) 
 ( pushText , censoredPushText ) ← getPushText ( peer , receiverUserId , senderName , message ) 
 @ @ - 51 , 6 + 56 , 7 @ @ final class ActorDelivery ( val system : ActorSystem ) 
 . withText ( pushText ) 
 . withCensoredText ( censoredPushText ) 
 . withPeer ( peer ) 
 + . withIsMentioned ( isMentioned ) 
 ) , 
 deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , 
 deliveryTag = deliveryTag 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala 
 index b940b8d . . 08cfeb7 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala 
 @ @ - 5 , 7 + 5 , 7 @ @ import akka . pattern . pipe 
 import im . actor . concurrent . FutureExt 
 import im . actor . server . db . DbExtension 
 import im . actor . server . model . push . _ 
 - import im . actor . server . model . { DeviceType , Peer } 
 + import im . actor . server . model . { DeviceType , Peer , PeerType } 
 import im . actor . server . persist . { AuthIdRepo , AuthSessionRepo } 
 import im . actor . server . persist . configs . ParameterRepo 
 import im . actor . server . persist . push . { ActorPushCredentialsRepo , ApplePushCredentialsRepo , FirebasePushCredentialsKV , GooglePushCredentialsRepo } 
 @ @ - 24 , 7 + 24 , 13 @ @ private final case class PushCredentialsInfo ( appId : Int , authId : Long ) 
 
 private final case class AllNotificationSettings ( 
 generic : NotificationSettings = NotificationSettings ( ) , 
 - specific : Map [ String , NotificationSettings ] = Map . empty 
 + specific : Map [ String , NotificationSettings ] = Map . empty , 
 + groups : GroupNotificationSettings = GroupNotificationSettings ( ) 
 + ) 
 + 
 + private final case class GroupNotificationSettings ( 
 + enabled : Boolean = true , 
 + onlyMention : Boolean = false 
 ) 
 
 private final case class NotificationSettings ( 
 @ @ - 81 , 20 + 87 , 29 @ @ private final class SettingsControl ( userId : Int ) extends Actor with ActorLogging 
 
 private def load ( ) : Future [ AllNotificationSettings ] = 
 db . run ( for { 
 - generic ← loadAction ( DeviceType . Generic ) 
 - mobile ← loadAction ( DeviceType . Mobile ) 
 - tablet ← loadAction ( DeviceType . Tablet ) 
 - desktop ← loadAction ( DeviceType . Desktop ) 
 + generic ← loadForDevice ( DeviceType . Generic ) 
 + mobile ← loadForDevice ( DeviceType . Mobile ) 
 + tablet ← loadForDevice ( DeviceType . Tablet ) 
 + desktop ← loadForDevice ( DeviceType . Desktop ) 
 + 
 + groups ← loadForGroups ( ) 
 } yield AllNotificationSettings ( 
 generic = generic , 
 specific = Map ( 
 DeviceType . Mobile → mobile , 
 DeviceType . Tablet → tablet , 
 DeviceType . Desktop → desktop 
 - ) 
 + ) , 
 + groups = groups 
 ) ) 
 
 - private def loadAction ( deviceType : String ) : DBIO [ NotificationSettings ] = { 
 + private def loadForGroups ( ) : DBIO [ GroupNotificationSettings ] = 
 + for { 
 + enabled ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . accountGroupEnabled , true ) 
 + onlyMentions ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . accountGroupMentionEnabled , false ) 
 + } yield GroupNotificationSettings ( enabled , onlyMentions ) 
 + 
 + private def loadForDevice ( deviceType : String ) : DBIO [ NotificationSettings ] = 
 for { 
 enabled ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . enabled ( deviceType ) , true ) 
 sound ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . soundEnabled ( deviceType ) , true ) 
 @ @ - 103 , 7 + 118 , 7 @ @ private final class SettingsControl ( userId : Int ) extends Actor with ActorLogging 
 peers ← ParameterRepo . findPeerNotifications ( userId , deviceType ) 
 customSounds ← ParameterRepo . findPeerRingtone ( userId ) 
 } yield NotificationSettings ( enabled , sound , vibration , text , customSounds . toMap , peers . toMap ) 
 - } 
 + 
 } 
 
 private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLogging with Stash { 
 @ @ - 120 , 6 + 135 , 7 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo 
 private val applePushProvider = new ApplePushProvider ( userId ) ( context . system ) 
 private val actorPushProvider = ActorPush ( context . system ) 
 
 + / / TODO : why do we need ` PushCredentialsInfo ` , we have ` authId ` anyway ! 
 private var mapping : Map [ PushCredentials , PushCredentialsInfo ] = Map . empty 
 private var notificationSettings = AllNotificationSettings ( ) 
 
 @ @ - 214 , 33 + 230 , 18 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo 
 val deviceType = DeviceType ( info . appId ) 
 
 if ( rules . excludeAuthIds . contains ( info . authId ) ) { 
 - log . debug ( " AuthSid is excluded , not pushing " ) 
 + log . debug ( " AuthId is excluded , not pushing " ) 
 } else { 
 rules . data match { 
 case Some ( data ) ⇒ 
 val settings = notificationSettings . specific . getOrElse ( deviceType , notificationSettings . generic ) 
 
 - val isVisible = 
 - ( settings . enabled , data . peer ) match { 
 - case ( true , Some ( peer ) ) ⇒ 
 - settings . peers . get ( peer ) match { 
 - case Some ( true ) ⇒ 
 - log . debug ( " Notifications for peer { } are enabled , push will be visible " , peer ) 
 - true 
 - case Some ( false ) ⇒ 
 - log . debug ( " Notifications for peer { } are disabled , push will be invisible " , peer ) 
 - false 
 - case None ⇒ 
 - log . debug ( " Notifications for peer { } are not set , push will be visible " , peer ) 
 - true 
 - } 
 - case ( true , None ) ⇒ 
 - log . debug ( " Notifications are enabled , delivering visible push " ) 
 - true 
 - case ( false , _ ) ⇒ 
 - log . debug ( " Notifications are disabled , delivering invisible push " ) 
 - false 
 - } 
 + val isVisible = isNotificationVisible ( 
 + settings , 
 + notificationSettings . groups , 
 + data . peer , 
 + data . isMentioned 
 + ) 
 
 if ( isVisible ) 
 deliverVisible ( 
 @ @ - 262 , 6 + 263 , 56 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo 
 } 
 } 
 
 + private def isNotificationVisible ( 
 + settings : NotificationSettings , 
 + groupSettings : GroupNotificationSettings , 
 + optPeer : Option [ Peer ] , 
 + isMentioned : Boolean 
 + ) = { 
 + ( settings . enabled , optPeer ) match { 
 + case ( true , Some ( peer ) ) ⇒ 
 + peer . ` type ` match { 
 + case PeerType . Group ⇒ 
 + if ( groupSettings . enabled ) { 
 + if ( groupSettings . onlyMention ) { 
 + if ( isMentioned ) { 
 + log . debug ( " User is mentioned , notification for group { } will be visible " , peer ) 
 + true 
 + } else { 
 + log . debug ( " Message without mention , notification for group { } will be visible " , peer ) 
 + false 
 + } 
 + } else { 
 + log . debug ( " Group notifications are enabled , notification for group { } will be visible " , peer ) 
 + true 
 + } 
 + } else { 
 + log . debug ( " Group notifications are disabled , notification for group { } will be invisible " , peer ) 
 + false 
 + } 
 + case _ ⇒ 
 + settings . peers . get ( peer ) match { 
 + case Some ( true ) ⇒ 
 + log . debug ( " Notifications for peer { } are enabled , notification will be visible " , peer ) 
 + true 
 + case Some ( false ) ⇒ 
 + log . debug ( " Notifications for peer { } are disabled , notification will be invisible " , peer ) 
 + false 
 + case None ⇒ 
 + log . debug ( " Notifications for peer { } are not set , notification will be visible " , peer ) 
 + true 
 + } 
 + 
 + } 
 + case ( true , None ) ⇒ 
 + log . debug ( " Notifications are enabled , delivering visible push " ) 
 + true 
 + case ( false , _ ) ⇒ 
 + log . debug ( " Notifications are disabled , delivering invisible push " ) 
 + false 
 + } 
 + } 
 + 
 / * * 
 * Delivers an invisible push with seq and contentAvailable 
 * 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 index 04204cd . . b4d7d30 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 @ @ - 12 , 9 + 12 , 11 @ @ import scala . concurrent . Future 
 trait DeliveryOperations { this : SeqUpdatesExtension ⇒ 
 
 def pushRules ( isFat : Boolean , pushText : Option [ String ] , excludeAuthIds : Seq [ Long ] = Seq . empty ) : PushRules = 
 - PushRules ( isFat = isFat ) 
 - . withData ( PushData ( ) . withText ( pushText . getOrElse ( " " ) ) ) 
 - . withExcludeAuthIds ( excludeAuthIds ) 
 + PushRules ( 
 + isFat = isFat , 
 + excludeAuthIds = excludeAuthIds , 
 + data = pushText map ( t ⇒ PushData ( text = t ) ) 
 + ) 
 
 / * * 
 * Send update to all devices of user and return ` SeqState ` associated with ` authId ` 
 @ @ - 147 , 9 + 149 , 10 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ 
 Future . sequence ( userIds . toSeq map ( deliverUpdate ( _ , deliver ) ) ) map ( _ ⇒ ( ) ) 
 
 private def deliverUpdate ( userId : Int , deliver : DeliverUpdate ) : Future [ SeqState ] = { 
 - val isUpdateDefined = 
 - deliver . getMapping . default . isDefined | | deliver . getMapping . custom . nonEmpty 
 - require ( isUpdateDefined , " No default update nor authId - specific " ) 
 + require ( 
 + deliver . getMapping . default . isDefined | | deliver . getMapping . custom . nonEmpty , 
 + " No default update nor authId - specific " 
 + ) 
 ( region . ref ? Envelope ( userId ) . withDeliverUpdate ( deliver ) ) . mapTo [ SeqState ] 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala b / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala 
 index 0f80002 . . a30578f 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala 
 @ @ - 1 , 7 + 1 , 5 @ @ 
 package im . actor . server . userconfig 
 
 - import im . actor . server . model . { Peer , PeerType } 
 - 
 object SettingsKeys { 
 private def wrap ( deviceType : String , postfix : String ) : String = s " category . $ deviceType . notification . $ postfix " 
 
 @ @ - 9 , 6 + 7 , 8 @ @ object SettingsKeys { 
 
 private def wrapEnabled ( deviceType : String , postfix : String ) : String = s " category . $ deviceType . notification . $ postfix . enabled " 
 
 + private def groups ( postfix : String ) = s " account . notifications . group . $ postfix " 
 + 
 def enabled ( deviceType : String ) = wrapEnabled ( deviceType ) 
 
 def soundEnabled ( deviceType : String ) = wrapEnabled ( deviceType , " sound " ) 
 @ @ - 16 , 4 + 16 , 9 @ @ object SettingsKeys { 
 def vibrationEnabled ( deviceType : String ) = wrapEnabled ( deviceType , " vibration " ) 
 
 def textEnabled ( deviceType : String ) = wrap ( deviceType , " show _ text " ) 
 + 
 + def accountGroupEnabled = groups ( " enabled " ) 
 + 
 + def accountGroupMentionEnabled = groups ( " mentions " ) 
 + 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 index 219466b . . a3f261e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 @ @ - 39 , 6 + 39 , 7 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int ) ( implicit system : Ac 
 data : PushData , 
 isTextEnabled : Boolean , 
 isSoundEnabled : Boolean , 
 + customSound : Option [ String ] , 
 isVibrationEnabled : Boolean 
 ) : Unit = { 
 withClient ( creds ) { implicit client ⇒ 
 @ @ - 54 , 7 + 55 , 7 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int ) ( implicit system : Ac 
 builder . setAlertBody ( data . censoredText ) 
 
 if ( isSoundEnabled ) 
 - builder . setSoundFileName ( " iapetus . caf " ) 
 + builder . setSoundFileName ( customSound getOrElse " iapetus . caf " ) 
 
 val payload = builder . buildWithDefaultMaximumLength ( ) 
 sendNotification ( payload , creds , userId ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala 
 index 243f7b2 . . c5bee73 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / VendorPush . scala 
 @ @ - 26 , 11 + 26 , 12 @ @ private final case class AllNotificationSettings ( 
 ) 
 
 private final case class NotificationSettings ( 
 - enabled : Boolean = true , 
 - sound : Boolean = true , 
 - vibration : Boolean = true , 
 - text : Boolean = true , 
 - peers : Map [ Peer , Boolean ] = Map . empty 
 + enabled : Boolean = true , 
 + sound : Boolean = true , 
 + vibration : Boolean = true , 
 + text : Boolean = true , 
 + customSounds : Map [ Peer , String ] = Map . empty , 
 + peers : Map [ Peer , Boolean ] = Map . empty 
 ) 
 
 private case object FailedToUnregister extends RuntimeException ( " Failed to unregister push credentials " ) 
 @ @ - 98 , 7 + 99 , 8 @ @ private final class SettingsControl ( userId : Int ) extends Actor with ActorLogging 
 vibration ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . vibrationEnabled ( deviceType ) , true ) 
 text ← ParameterRepo . findBooleanValue ( userId , SettingsKeys . textEnabled ( deviceType ) , true ) 
 peers ← ParameterRepo . findPeerNotifications ( userId , deviceType ) 
 - } yield NotificationSettings ( enabled , sound , vibration , text , peers . toMap ) 
 + customSounds ← ParameterRepo . findPeerRingtone ( userId ) 
 + } yield NotificationSettings ( enabled , sound , vibration , text , customSounds . toMap , peers . toMap ) 
 } 
 } 
 
 @ @ - 225 , 20 + 227 , 18 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo 
 false 
 } 
 
 - if ( isVisible ) { 
 - val isSoundEnabled = settings . sound 
 - val isTextEnabled = settings . text 
 - val isVibrationEnabled = settings . vibration 
 - 
 + if ( isVisible ) 
 deliverVisible ( 
 seq = seq , 
 creds = creds , 
 data = data , 
 - isTextEnabled = isTextEnabled , 
 - isSoundEnabled = isSoundEnabled , 
 - isVibrationEnabled = isVibrationEnabled 
 + isTextEnabled = settings . text , 
 + isSoundEnabled = settings . sound , 
 + customSound = data . peer flatMap ( p ⇒ settings . customSounds . get ( p ) ) , 
 + isVibrationEnabled = settings . vibration 
 ) 
 - } else deliverInvisible ( seq , creds ) 
 + else 
 + deliverInvisible ( seq , creds ) 
 
 case _ ⇒ 
 log . debug ( " No text , delivering simple seq " ) 
 @ @ - 275 , 7 + 275 , 15 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo 
 * @ param isVibrationEnabled 
 * @ return 
 * / 
 - private def deliverVisible ( seq : Int , creds : PushCredentials , data : PushData , isTextEnabled : Boolean , isSoundEnabled : Boolean , isVibrationEnabled : Boolean ) = { 
 + private def deliverVisible ( 
 + seq : Int , 
 + creds : PushCredentials , 
 + data : PushData , 
 + isTextEnabled : Boolean , 
 + isSoundEnabled : Boolean , 
 + customSound : Option [ String ] , 
 + isVibrationEnabled : Boolean 
 + ) = { 
 creds match { 
 case c : GooglePushCredentials ⇒ 
 googlePushProvider . deliverVisible ( 
 @ @ - 293 , 6 + 301 , 7 @ @ private [ sequence ] final class VendorPush ( userId : Int ) extends Actor with ActorLo 
 data = data , 
 isTextEnabled = isTextEnabled , 
 isSoundEnabled = isSoundEnabled , 
 + customSound = customSound , 
 isVibrationEnabled = isVibrationEnabled 
 ) 
 case c : ActorPushCredentials ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala b / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala 
 index d049b81 . . 0f80002 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / userconfig / SettingsKeys . scala 
 @ @ - 9 , 12 + 9 , 6 @ @ object SettingsKeys { 
 
 private def wrapEnabled ( deviceType : String , postfix : String ) : String = s " category . $ deviceType . notification . $ postfix . enabled " 
 
 - private def peerStr ( peer : Peer ) = peer match { 
 - case Peer ( PeerType . Private , id ) ⇒ s " PRIVATE _ $ id " 
 - case Peer ( PeerType . Group , id ) ⇒ s " GROUP _ $ id " 
 - case _ ⇒ throw new RuntimeException ( s " Unknown peer $ peer " ) 
 - } 
 - 
 def enabled ( deviceType : String ) = wrapEnabled ( deviceType ) 
 
 def soundEnabled ( deviceType : String ) = wrapEnabled ( deviceType , " sound " ) 
 @ @ - 22 , 6 + 16 , 4 @ @ object SettingsKeys { 
 def vibrationEnabled ( deviceType : String ) = wrapEnabled ( deviceType , " vibration " ) 
 
 def textEnabled ( deviceType : String ) = wrap ( deviceType , " show _ text " ) 
 - 
 - def peerEnabled ( deviceType : String , peer : Peer ) = wrapEnabled ( deviceType , s " chat . $ { peerStr ( peer ) } " ) 
 } 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 index 15b3fdf . . a6d98f8 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 @ @ - 50 , 29 + 50 , 47 @ @ object ParameterRepo { 
 case _ ⇒ default 
 } 
 
 + def findPeerRingtone ( userId : Int ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ ( Peer , String ) ] ] = 
 + extractPeerParams [ ( Peer , String ) ] ( userId , prefix = s " category . mobile . ios . ringtone . chat . " ) { 
 + case ( key , optValue ) ⇒ 
 + key . split ( " _ " ) . toList match { 
 + case " GROUP " : : id : : Nil ⇒ 
 + optValue map ( v ⇒ ( Peer ( PeerType . Group , id . toInt ) , v ) ) 
 + case " PRIVATE " : : id : : Nil ⇒ 
 + optValue map ( v ⇒ ( Peer ( PeerType . Private , id . toInt ) , v ) ) 
 + case _ ⇒ None 
 + } 
 + } 
 + 
 def findPeerNotifications ( userId : Int , deviceType : String ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ ( Peer , Boolean ) ] ] = { 
 def boolValue ( value : Option [ String ] ) = value match { 
 case Some ( " false " ) ⇒ false 
 case _ ⇒ true 
 } 
 
 - val prefix = s " category . $ deviceType . notification . chat . " 
 - 
 - for ( rows ← byUserIdAndKeyLikeC ( ( userId , s " $ prefix % _ % . % " ) ) . result ) yield { 
 - rows flatMap { 
 - case Parameter ( _ , key , value ) ⇒ 
 - key . drop ( prefix . length ) . split ( " \ \ . " ) . toList match { 
 - case peerStr : : " enabled " : : Nil ⇒ 
 - peerStr . split ( " _ " ) . toList match { 
 - case " GROUP " : : id : : Nil ⇒ 
 - Some ( ( Peer ( PeerType . Group , id . toInt ) , boolValue ( value ) ) ) 
 - case " PRIVATE " : : id : : Nil ⇒ 
 - Some ( ( Peer ( PeerType . Private , id . toInt ) , boolValue ( value ) ) ) 
 - case _ ⇒ None 
 - } 
 - case _ ⇒ None 
 - } 
 - } 
 + extractPeerParams [ ( Peer , Boolean ) ] ( userId , s " category . $ deviceType . notification . chat . " ) { 
 + case ( key , value ) ⇒ 
 + key . split ( " \ \ . " ) . toList match { 
 + case peerStr : : " enabled " : : Nil ⇒ 
 + peerStr . split ( " _ " ) . toList match { 
 + case " GROUP " : : id : : Nil ⇒ 
 + Some ( ( Peer ( PeerType . Group , id . toInt ) , boolValue ( value ) ) ) 
 + case " PRIVATE " : : id : : Nil ⇒ 
 + Some ( ( Peer ( PeerType . Private , id . toInt ) , boolValue ( value ) ) ) 
 + case _ ⇒ None 
 + } 
 + case _ ⇒ None 
 + } 
 } 
 } 
 + 
 + private type KeyValue = ( String , Option [ String ] ) 
 + 
 + / / key passed in ` f ` comes without prefix 
 + private def extractPeerParams [ T ] ( userId : Int , prefix : String ) ( f : KeyValue ⇒ Option [ T ] ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ T ] ] = 
 + byUserIdAndKeyLikeC ( ( userId , s " $ prefix % " ) ) . result map { params ⇒ 
 + val kvs : Seq [ KeyValue ] = params map ( p ⇒ p . key . drop ( prefix . length ) → p . value ) 
 + ( kvs map f ) . flatten 
 + } 
 + 
 } 
 \ No newline at end of file
