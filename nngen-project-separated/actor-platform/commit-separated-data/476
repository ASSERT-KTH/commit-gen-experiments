BLEU SCORE: 0.014199193612838947

TEST MSG: refactor ( server : messaging ) : UserEnvelope , GroupEnvelope , DialogEnvelope , DialogRootEnvelope
GENERATED MSG: Merge commit ' 8123e8c970ae311aa02d4c9e0196dbfb802e15a6 '

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 16396b4 . . 6e7f6d7 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 21 , 6 + 21 , 8 @ @ message DialogInfo { < nl > required Peer peer = 3 ; < nl > required int32 counter = 1 ; < nl > required int64 date = 2 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + required int64 last _ received _ date = 5 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + required int64 last _ read _ date = 4 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > } < nl > < nl > message DialogGroup { < nl > @ @ - 126 , 8 + 128 , 21 @ @ message DialogRootQueries { < nl > } < nl > } < nl > < nl > + message DialogRootEnvelope { < nl > + oneof query { < nl > + DialogRootQueries . GetCounter get _ counter = 2 ; < nl > + DialogRootQueries . GetDialogGroups get _ dialog _ groups = 3 ; < nl > + } < nl > + oneof command { < nl > + DialogRootCommands . Archive archive = 6 ; < nl > + DialogRootCommands . Unarchive unarchive = 4 ; < nl > + DialogRootCommands . Favourite favourite = 7 ; < nl > + DialogRootCommands . Unfavourite unfavourite = 8 ; < nl > + DialogRootCommands . Delete delete = 9 ; < nl > + } < nl > + } < nl > + < nl > message DialogEnvelope { < nl > - required Peer peer = 1 ; < nl > oneof command { < nl > DialogCommands . WriteMessage write _ message = 2 ; < nl > DialogCommands . SendMessage send _ message = 3 ; < nl > @ @ - 136 , 7 + 151 , 6 @ @ message DialogEnvelope { < nl > DialogCommands . SetReaction set _ reaction = 9 ; < nl > DialogCommands . RemoveReaction remove _ reaction = 10 ; < nl > DialogCommands . WriteMessageSelf write _ message _ self = 11 ; < nl > - DialogCommands . UpdateCounters update _ counters = 14 ; < nl > } < nl > oneof query { < nl > DialogQueries . GetCounter get _ counter = 15 ; < nl > diff - - git a / actor - server / actor - core / src / main / protobuf / group . proto b / actor - server / actor - core / src / main / protobuf / group . proto < nl > index ab197c5 . . dd88e3a 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / group . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / group . proto < nl > @ @ - 10 , 12 + 10 , 19 @ @ option ( scalapb . options ) = { < nl > import " scalapb / scalapb . proto " ; < nl > import " file . proto " ; < nl > import " sequence . proto " ; < nl > + import " dialog . proto " ; < nl > < nl > enum GroupType { < nl > General = 1 ; < nl > Public = 2 ; < nl > } < nl > < nl > + / / TODO : put GroupCommands and GroupQueries inside < nl > + message GroupEnvelope { < nl > + required int32 group _ id = 1 ; < nl > + optional DialogEnvelope dialog _ envelope = 2 ; < nl > + } < nl > + < nl > message GroupCommands { < nl > message Create { < nl > option ( scalapb . message ) . extends = " im . actor . server . group . GroupCommand " ; < nl > diff - - git a / actor - server / actor - core / src / main / protobuf / user . proto b / actor - server / actor - core / src / main / protobuf / user . proto < nl > index a7db8df . . b7ed956 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / user . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / user . proto < nl > @ @ - 325 , 19 + 325 , 12 @ @ message UserQueries { < nl > } < nl > } < nl > < nl > - message DialogRootEnvelope { < nl > + / / TODO : put UserCommands and UserQueries inside < nl > + < nl > + message UserEnvelope { < nl > required int32 user _ id = 1 ; < nl > - oneof query { < nl > - DialogRootQueries . GetCounter get _ counter = 2 ; < nl > - DialogRootQueries . GetDialogGroups get _ dialog _ groups = 3 ; < nl > - } < nl > - oneof command { < nl > - DialogRootCommands . Archive archive = 6 ; < nl > - DialogRootCommands . Unarchive unarchive = 4 ; < nl > - DialogRootCommands . Favourite favourite = 7 ; < nl > - DialogRootCommands . Unfavourite unfavourite = 8 ; < nl > - DialogRootCommands . Delete delete = 9 ; < nl > - } < nl > + optional DialogRootEnvelope dialog _ root _ envelope = 2 ; < nl > + optional DialogEnvelope dialog _ envelope = 3 ; < nl > } < nl > < nl > message UserEvents { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index f49e7c4 . . 0ec3fb2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 58 , 7 + 58 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > default = for { < nl > _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( sendDate ) ) ) < nl > _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > - _ = dialogExt . updateCounters ( peer , userId ) < nl > + / / _ = dialogExt . updateCounters ( peer , userId ) < nl > SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) < nl > } yield SeqStateDate ( seq , state , sendDate ) , < nl > failed = for { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 5261bf7 . . 0d053bb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 8 , 18 + 8 , 18 @ @ import akka . http . scaladsl . util . FastFuture < nl > import akka . pattern . ask < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . _ < nl > - import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage } < nl > + import im . actor . api . rpc . messaging . { ApiDialog , ApiDialogGroup , ApiDialogShort , ApiMessage } < nl > import im . actor . api . rpc . misc . ApiExtension < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . extension . InternalExtensions < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . DialogCommands . _ < nl > - import im . actor . server . group . GroupExtension < nl > + import im . actor . server . group . { GroupEnvelope , GroupExtension } < nl > import im . actor . server . model . _ < nl > import im . actor . server . persist . HistoryMessageRepo < nl > import im . actor . server . persist . messaging . ReactionEventRepo < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > - import im . actor . server . user . { DialogRootEnvelope , UserExtension } < nl > + import im . actor . server . user . { UserEnvelope , UserExtension } < nl > import im . actor . types . _ < nl > import org . joda . time . DateTime < nl > import slick . dbio . DBIO < nl > @ @ - 64 , 10 + 64 , 9 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > forUserId : Option [ UserId ] = None < nl > ) : Future [ SeqStateDate ] = < nl > withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > - val sender = Peer . privat ( senderUserId ) < nl > / / we don ' t set date here , cause actual date set inside dialog processor < nl > val sendMessage = SendMessage ( < nl > - origin = sender , < nl > + origin = Peer . privat ( senderUserId ) , < nl > dest = peer . asModel , < nl > senderAuthSid = senderAuthSid , < nl > senderAuthId = senderAuthId , < nl > @ @ - 78 , 11 + 77 , 11 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > isFat = isFat , < nl > forUserId = forUserId < nl > ) < nl > - ( userExt . processorRegion . ref ? DialogEnvelope ( sender ) . withSendMessage ( sendMessage ) ) . mapTo [ SeqStateDate ] < nl > + ( userExt . processorRegion . ref ? UserEnvelope ( senderUserId ) . withDialogEnvelope ( DialogEnvelope ( ) . withSendMessage ( sendMessage ) ) ) . mapTo [ SeqStateDate ] < nl > } < nl > < nl > def ackSendMessage ( peer : Peer , sm : SendMessage ) : Future [ Unit ] = < nl > - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withSendMessage ( sm ) ) . mapTo [ SendMessageAck ] map ( _ ⇒ ( ) ) < nl > + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withSendMessage ( sm ) ) ) . mapTo [ SendMessageAck ] map ( _ ⇒ ( ) ) < nl > < nl > def writeMessage ( < nl > peer : ApiPeer , < nl > @ @ - 108 , 13 + 107 , 13 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ) : Future [ Unit ] = < nl > withValidPeer ( Peer . privat ( userId ) , peer . id , Future . successful ( ( ) ) ) { < nl > ( userExt . processorRegion . ref ? < nl > - DialogEnvelope ( Peer . privat ( userId ) ) . withWriteMessageSelf ( WriteMessageSelf ( < nl > + envelope ( Peer . privat ( userId ) , DialogEnvelope ( ) . withWriteMessageSelf ( WriteMessageSelf ( < nl > dest = peer . asModel , < nl > senderUserId , < nl > date . getMillis , < nl > randomId , < nl > message < nl > - ) ) ) map ( _ ⇒ ( ) ) < nl > + ) ) ) ) map ( _ ⇒ ( ) ) < nl > } < nl > < nl > def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = < nl > @ @ - 122 , 84 + 121 , 89 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > val now = Instant . now ( ) . toEpochMilli < nl > val receiver = Peer . privat ( receiverUserId ) < nl > val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) < nl > - ( userExt . processorRegion . ref ? DialogEnvelope ( receiver ) . withMessageReceived ( messageReceived ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > + ( userExt . processorRegion . ref ? envelope ( receiver , DialogEnvelope ( ) . withMessageReceived ( messageReceived ) ) ) < nl > + . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > } < nl > < nl > def ackMessageReceived ( peer : Peer , mr : MessageReceived ) : Future [ Unit ] = < nl > - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withMessageReceived ( mr ) ) ) < nl > + . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > < nl > def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = < nl > withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val reader = Peer . privat ( readerUserId ) < nl > val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) < nl > - ( userExt . processorRegion . ref ? DialogEnvelope ( reader ) . withMessageRead ( messageRead ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > + ( userExt . processorRegion . ref ? envelope ( reader , DialogEnvelope ( ) . withMessageRead ( messageRead ) ) ) < nl > + . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > } < nl > < nl > def ackMessageRead ( peer : Peer , mr : MessageRead ) : Future [ Unit ] = < nl > - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withMessageRead ( mr ) ) ) < nl > + . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > < nl > def unarchive ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withUnarchive ( DialogRootCommands . Unarchive ( peer ) ) ) . mapTo [ SeqState ] < nl > + ( userExt . processorRegion . ref ? < nl > + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withUnarchive ( DialogRootCommands . Unarchive ( peer ) ) ) ) < nl > + . mapTo [ SeqState ] < nl > } < nl > < nl > def archive ( userId : Int , peer : Peer , clientAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = < nl > withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withArchive ( DialogRootCommands . Archive ( peer , clientAuthSid ) ) ) . mapTo [ SeqState ] < nl > + ( userExt . processorRegion . ref ? < nl > + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withArchive ( DialogRootCommands . Archive ( peer , clientAuthSid ) ) ) ) < nl > + . mapTo [ SeqState ] < nl > } < nl > < nl > def favourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withFavourite ( DialogRootCommands . Favourite ( peer ) ) ) . mapTo [ SeqState ] < nl > + ( userExt . processorRegion . ref ? < nl > + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withFavourite ( DialogRootCommands . Favourite ( peer ) ) ) ) < nl > + . mapTo [ SeqState ] < nl > } < nl > < nl > def unfavourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withUnfavourite ( DialogRootCommands . Unfavourite ( peer ) ) ) . mapTo [ SeqState ] < nl > + ( userExt . processorRegion . ref ? < nl > + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withUnfavourite ( DialogRootCommands . Unfavourite ( peer ) ) ) ) < nl > + . mapTo [ SeqState ] < nl > } < nl > < nl > def delete ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > withValidPeer ( peer , userId ) { < nl > - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withDelete ( DialogRootCommands . Delete ( peer ) ) ) . mapTo [ SeqState ] < nl > + ( userExt . processorRegion . ref ? < nl > + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withDelete ( DialogRootCommands . Delete ( peer ) ) ) ) < nl > + . mapTo [ SeqState ] < nl > } < nl > < nl > def setReaction ( userId : Int , authSid : Int , peer : Peer , randomId : Long , code : String ) : Future [ SetReactionAck ] = < nl > withValidPeer ( peer , userId ) { < nl > - ( userExt . processorRegion . ref ? DialogEnvelope ( Peer . privat ( userId ) ) . withSetReaction ( SetReaction ( < nl > + ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withSetReaction ( SetReaction ( < nl > origin = Peer . privat ( userId ) , < nl > dest = peer , < nl > clientAuthSid = authSid , < nl > randomId = randomId , < nl > code = code < nl > - ) ) ) . mapTo [ SetReactionAck ] < nl > + ) ) ) ) . mapTo [ SetReactionAck ] < nl > } < nl > < nl > def removeReaction ( userId : Int , authSid : Int , peer : Peer , randomId : Long , code : String ) : Future [ RemoveReactionAck ] = < nl > withValidPeer ( peer , userId ) { < nl > - ( userExt . processorRegion . ref ? DialogEnvelope ( Peer . privat ( userId ) ) . withRemoveReaction ( RemoveReaction ( < nl > + ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withRemoveReaction ( RemoveReaction ( < nl > origin = Peer . privat ( userId ) , < nl > dest = peer , < nl > clientAuthSid = authSid , < nl > randomId = randomId , < nl > code = code < nl > - ) ) ) . mapTo [ RemoveReactionAck ] < nl > + ) ) ) ) . mapTo [ RemoveReactionAck ] < nl > } < nl > < nl > def ackSetReaction ( peer : Peer , sr : SetReaction ) : Future [ Unit ] = < nl > - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withSetReaction ( sr ) ) map ( _ ⇒ ( ) ) < nl > + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withSetReaction ( sr ) ) ) map ( _ ⇒ ( ) ) < nl > < nl > def ackRemoveReaction ( peer : Peer , rr : RemoveReaction ) : Future [ Unit ] = < nl > - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withRemoveReaction ( rr ) ) map ( _ ⇒ ( ) ) < nl > - < nl > - def updateCounters ( peer : Peer , userId : Int ) : Future [ Unit ] = < nl > - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withUpdateCounters ( UpdateCounters ( < nl > - origin = Peer . privat ( userId ) , < nl > - dest = peer < nl > - ) ) ) map ( _ ⇒ ( ) ) < nl > - < nl > - def ackUpdateCounters ( peer : Peer , uc : UpdateCounters ) : Future [ Unit ] = < nl > - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withUpdateCounters ( uc ) ) map ( _ ⇒ ( ) ) < nl > + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withRemoveReaction ( rr ) ) ) map ( _ ⇒ ( ) ) < nl > < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > @ @ - 223 , 7 + 227 , 13 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > < nl > def getUnreadTotal ( userId : Int ) : DBIO [ Int ] = < nl > DBIO . from ( < nl > - ( processorRegion ( Peer . privat ( userId ) ) ? DialogRootEnvelope ( userId ) . withGetCounter ( DialogRootQueries . GetCounter ( ) ) ) . mapTo [ DialogRootQueries . GetCounterResponse ] map ( _ . counter ) < nl > + ( processorRegion ( Peer . privat ( userId ) ) ? < nl > + UserEnvelope ( userId ) < nl > + . withDialogRootEnvelope ( < nl > + DialogRootEnvelope ( ) < nl > + . withGetCounter ( DialogRootQueries . GetCounter ( ) ) < nl > + ) ) < nl > + . mapTo [ DialogRootQueries . GetCounterResponse ] map ( _ . counter ) < nl > ) < nl > < nl > def getUnreadCount ( clientUserId : Int , historyOwner : Int , peer : Peer , ownerLastReadAt : DateTime ) : DBIO [ Int ] = { < nl > @ @ - 240 , 7 + 250 , 10 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def isSharedUser ( userId : Int ) : Boolean = userId = = 0 < nl > < nl > def fetchGroupedDialogs ( userId : Int ) : Future [ Seq [ DialogGroup ] ] = { < nl > - ( processorRegion ( Peer . privat ( userId ) ) ? DialogRootEnvelope ( userId ) . withGetDialogGroups ( DialogRootQueries . GetDialogGroups ( ) ) ) < nl > + ( processorRegion ( Peer . privat ( userId ) ) ? < nl > + UserEnvelope ( userId ) < nl > + . withDialogRootEnvelope ( DialogRootEnvelope ( ) < nl > + . withGetDialogGroups ( DialogRootQueries . GetDialogGroups ( ) ) ) ) < nl > . mapTo [ DialogRootQueries . GetDialogGroupsResponse ] < nl > . map ( _ . groups ) < nl > } < nl > @ @ - 251 , 6 + 264 , 12 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > } < nl > } < nl > < nl > + def getDialogInfo ( userId : Int , peer : Peer ) : Future [ DialogInfo ] = { < nl > + ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withGetInfo ( DialogQueries . GetInfo ( ) ) ) ) < nl > + . mapTo [ DialogQueries . GetInfoResponse ] < nl > + . map ( _ . info ) < nl > + } < nl > + < nl > def dialogWithSelf ( userId : Int , dialog : DialogObsolete ) : Boolean = < nl > dialog . peer . typ = = PeerType . Private & & dialog . peer . id = = userId < nl > < nl > @ @ - 275 , 20 + 294 , 6 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > } < nl > } < nl > < nl > - def getDialogShortDBIO ( dialog : DialogObsolete ) ( implicit ec : ExecutionContext ) : DBIO [ ApiDialogShort ] = < nl > - for { < nl > - historyOwner ← DBIO . from ( HistoryUtils . getHistoryOwner ( dialog . peer , dialog . userId ) ) < nl > - messageOpt ← HistoryMessageRepo . findNewest ( historyOwner , dialog . peer ) map ( _ . map ( _ . ofUser ( dialog . userId ) ) ) < nl > - unreadCount ← getUnreadCount ( dialog . userId , historyOwner , dialog . peer , dialog . ownerLastReadAt ) < nl > - } yield ApiDialogShort ( < nl > - peer = ApiPeer ( ApiPeerType ( dialog . peer . typ . value ) , dialog . peer . id ) , < nl > - counter = unreadCount , < nl > - date = messageOpt . map ( _ . date . getMillis ) . getOrElse ( 0 ) < nl > - ) < nl > - < nl > - def getDialogShort ( dialog : DialogObsolete ) ( implicit ec : ExecutionContext ) : Future [ ApiDialogShort ] = < nl > - db . run ( getDialogShortDBIO ( dialog ) ) < nl > - < nl > private def processorRegion ( peer : Peer ) : ActorRef = peer . typ match { < nl > case PeerType . Private ⇒ < nl > userExt . processorRegion . ref / / to user peer < nl > @ @ - 296 , 6 + 301 , 12 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > groupExt . processorRegion . ref / / to group peer < nl > case _ ⇒ throw new RuntimeException ( " Unknown peer type ! " ) < nl > } < nl > + < nl > + private def envelope ( peer : Peer , envelope : DialogEnvelope ) : Any = peer . typ match { < nl > + case PeerType . Private ⇒ UserEnvelope ( peer . id ) . withDialogEnvelope ( envelope ) < nl > + case PeerType . Group ⇒ GroupEnvelope ( peer . id ) . withDialogEnvelope ( envelope ) < nl > + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > + } < nl > } < nl > < nl > object DialogExtension extends ExtensionId [ DialogExtensionImpl ] with ExtensionIdProvider { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index ce057a7 . . d84b8aa 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 154 , 7 + 154 , 15 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > case GetCounter ( ) ⇒ Future . successful ( GetCounterResponse ( state . counter ) ) < nl > - case GetInfo ( ) ⇒ Future . successful ( GetInfoResponse ( DialogInfo ( peer , state . counter , Instant . ofEpochMilli ( state . lastMessageDate ) ) ) ) < nl > + case GetInfo ( ) ⇒ Future . successful ( < nl > + GetInfoResponse ( DialogInfo ( < nl > + peer = peer , < nl > + counter = state . counter , < nl > + date = Instant . ofEpochMilli ( state . lastMessageDate ) , < nl > + lastReceivedDate = Instant . ofEpochMilli ( state . lastReceiveDate ) , < nl > + lastReadDate = Instant . ofEpochMilli ( state . lastReadDate ) < nl > + ) ) < nl > + ) < nl > } < nl > < nl > override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > index b492820 . . c9ce341 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > @ @ - 56 , 7 + 56 , 6 @ @ private [ group ] final class GroupPeer ( val groupId : Int ) < nl > case sr : SetReaction ⇒ setReaction ( state , sr ) < nl > case rr : RemoveReaction ⇒ removeReaction ( state , rr ) < nl > case sc : LastSenderIdChanged ⇒ context become initialized ( state . updated ( sc ) ) < nl > - case uc : UpdateCounters ⇒ updateCountersChanged ( uc ) < nl > } < nl > < nl > override def receive : Receive = initialized ( GroupPeerState . empty ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala < nl > index 37df102 . . 6d91468 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala < nl > @ @ - 39 , 18 + 39 , 6 @ @ trait GroupPeerCommandHandlers extends PeersImplicits { < nl > } ) pipeTo sender ( ) < nl > } < nl > < nl > - protected def updateCountersChanged ( uc : UpdateCounters ) = { < nl > - ( withMemberIds ( groupId ) { ( memberIds , _ , _ ) ⇒ < nl > - Future . traverse ( memberIds - uc . origin . id ) { userId ⇒ < nl > - dialogExt . ackUpdateCounters ( Peer . privat ( userId ) , uc ) < nl > - } map ( _ ⇒ UpdateCountersAck ( ) ) < nl > - } recover { < nl > - case e ⇒ < nl > - log . error ( e , " Failed to send update counters changed " ) < nl > - throw e < nl > - } ) pipeTo sender ( ) < nl > - } < nl > - < nl > protected def messageReceived ( state : GroupPeerState , mr : MessageReceived ) = { < nl > val receiverUserId = mr . origin . id < nl > val canReceive = canMakeReceive ( state , mr ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > index c5c3bb9 . . 227cd7e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > @ @ - 12 , 8 + 12 , 8 @ @ import im . actor . serialization . ActorSerializer < nl > import im . actor . server . KeyValueMappings < nl > import im . actor . server . cqrs . TaggedEvent < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . dialog . { DirectDialogCommand , DialogExtension } < nl > - import im . actor . server . file . { FileStorageExtension , FileStorageAdapter , Avatar } < nl > + import im . actor . server . dialog . { DialogEnvelope , DialogExtension , DirectDialogCommand } < nl > + import im . actor . server . file . { Avatar , FileStorageAdapter , FileStorageExtension } < nl > import im . actor . server . model . Group < nl > import im . actor . server . office . { PeerProcessor , ProcessorState , StopOffice } < nl > import im . actor . server . sequence . SeqUpdatesExtension < nl > @ @ - 244 , 9 + 244 , 10 @ @ private [ group ] final class GroupProcessor < nl > makeUserAdmin ( state , clientUserId , candidateId ) < nl > case RevokeIntegrationToken ( _ , userId ) ⇒ < nl > revokeIntegrationToken ( state , userId ) < nl > - case StopOffice ⇒ context stop self < nl > - case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) < nl > - case dc : DirectDialogCommand ⇒ groupPeer forward dc < nl > + case StopOffice ⇒ context stop self < nl > + case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) < nl > + case de : DialogEnvelope ⇒ < nl > + groupPeer forward de . getAllFields . values . head < nl > } < nl > < nl > private [ this ] var groupStateMaybe : Option [ GroupState ] = None < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala < nl > index ca2d0c1 . . 5a8866b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala < nl > @ @ - 3 , 10 + 3 , 6 @ @ package im . actor . server . group < nl > import akka . actor . { ActorRef , ActorSystem , Props } < nl > import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } < nl > import akka . event . Logging < nl > - import im . actor . server . dialog . DialogEnvelope < nl > - import im . actor . server . model . { Peer , PeerType } < nl > - < nl > - import scala . util . { Success , Try } < nl > < nl > object GroupProcessorRegion { < nl > private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { < nl > @ @ - 15 , 27 + 11 , 18 @ @ object GroupProcessorRegion { < nl > { < nl > case c : GroupCommand ⇒ ( c . groupId . toString , c ) < nl > case q : GroupQuery ⇒ ( q . groupId . toString , q ) < nl > - case e @ DialogEnvelope ( peer , command , query ) ⇒ peer match { < nl > - case Peer ( PeerType . Group , groupId ) ⇒ < nl > - Try ( e . getField ( DialogEnvelope . descriptor . findFieldByNumber ( command . number ) ) ) match { < nl > - case Success ( any ) ⇒ ( groupId . toString , any ) < nl > - case _ ⇒ < nl > - val error = new RuntimeException ( s " Payload not found for $ e " ) < nl > - log . error ( error , error . getMessage ) < nl > - throw error < nl > - } < nl > - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in GroupProcessor " ) < nl > - } < nl > + case GroupEnvelope ( groupId , dialogEnvelope ) ⇒ < nl > + ( < nl > + groupId . toString , < nl > + dialogEnvelope . get < nl > + ) < nl > } < nl > } < nl > < nl > private def extractShardId ( system : ActorSystem ) : ShardRegion . ExtractShardId = msg ⇒ msg match { < nl > - case c : GroupCommand ⇒ ( c . groupId % 100 ) . toString / / TODO : configurable < nl > - case q : GroupQuery ⇒ ( q . groupId % 100 ) . toString < nl > - case DialogEnvelope ( peer , _ , _ ) ⇒ peer match { < nl > - case Peer ( PeerType . Group , groupId ) ⇒ ( groupId % 100 ) . toString < nl > - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in GroupProcessor " ) < nl > - } < nl > + case c : GroupCommand ⇒ ( c . groupId % 100 ) . toString / / TODO : configurable < nl > + case q : GroupQuery ⇒ ( q . groupId % 100 ) . toString < nl > + case e : GroupEnvelope ⇒ ( e . groupId % 100 ) . toString < nl > } < nl > < nl > val typeName = " GroupProcessor " < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > index c9f88f3 . . 5040eb4 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > @ @ - 19 , 6 + 19 , 7 @ @ import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . ExecutionContext < nl > import scala . concurrent . duration . _ < nl > + import scala . util . Try < nl > < nl > trait UserEvent extends TaggedEvent { < nl > val ts : Instant < nl > @ @ - 242 , 10 + 243 , 12 @ @ private [ user ] final class UserProcessor < nl > case query : GetLocalName ⇒ contacts . ref forward query < nl > case StopOffice ⇒ context stop self < nl > case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) < nl > - case dc : DialogCommand ⇒ dialogRoot ( state . internalExtensions ) forward dc < nl > - case dq : DialogQuery ⇒ dialogRoot ( state . internalExtensions ) forward dq < nl > - case drc : DialogRootCommand ⇒ dialogRoot ( state . internalExtensions ) forward drc < nl > - case drq : DialogRootQuery ⇒ dialogRoot ( state . internalExtensions ) forward drq < nl > + case e @ DialogRootEnvelope ( query , command ) ⇒ < nl > + val msg = e . getAllFields . values . head < nl > + dialogRoot ( state . internalExtensions ) forward msg < nl > + case de : DialogEnvelope ⇒ < nl > + val msg = de . getAllFields . values . head < nl > + dialogRoot ( state . internalExtensions ) forward msg < nl > } < nl > < nl > override protected def handleQuery ( state : UserState ) : Receive = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala < nl > index 54e2794 . . e778117 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala < nl > @ @ - 2 , 48 + 2 , 28 @ @ package im . actor . server . user < nl > < nl > import akka . actor . { ActorRef , ActorSystem , Props } < nl > import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } < nl > - import akka . event . Logging < nl > - import im . actor . server . dialog . DialogEnvelope < nl > - import im . actor . server . model . { Peer , PeerType } < nl > - < nl > - import scala . util . { Try , Success } < nl > < nl > object UserProcessorRegion { < nl > private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { < nl > - val log = Logging ( system , getClass ) < nl > - < nl > { < nl > case c : UserCommand ⇒ ( c . userId . toString , c ) < nl > case q : UserQuery ⇒ ( q . userId . toString , q ) < nl > - case e @ DialogEnvelope ( peer , command , query ) ⇒ peer match { < nl > - case Peer ( PeerType . Private , userId ) ⇒ < nl > - Try ( e . getField ( DialogEnvelope . descriptor . findFieldByNumber ( command . number ) ) ) match { < nl > - case Success ( any ) ⇒ ( userId . toString , any ) < nl > - case _ ⇒ < nl > - val error = new RuntimeException ( s " Payload not found for $ e " ) < nl > - log . error ( error , error . getMessage ) < nl > - throw error < nl > - } < nl > - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) < nl > - } < nl > - case e @ DialogRootEnvelope ( userId , query , command ) ⇒ < nl > + case e @ UserEnvelope ( < nl > + userId , < nl > + dialogRootEnvelope , < nl > + dialogEnvelope < nl > + ) ⇒ < nl > ( < nl > userId . toString , < nl > - if ( query . isDefined ) e . getField ( DialogRootEnvelope . descriptor . findFieldByNumber ( query . number ) ) < nl > - else if ( command . isDefined ) e . getField ( DialogRootEnvelope . descriptor . findFieldByNumber ( command . number ) ) < nl > - else throw new RuntimeException ( " No defined query nor command " ) < nl > + dialogRootEnvelope . getOrElse ( dialogEnvelope . get ) < nl > ) < nl > } < nl > } < nl > < nl > private def extractShardId ( system : ActorSystem ) : ShardRegion . ExtractShardId = { < nl > - case c : UserCommand ⇒ ( c . userId % 100 ) . toString / / TODO : configurable < nl > - case q : UserQuery ⇒ ( q . userId % 100 ) . toString < nl > - case DialogEnvelope ( peer , _ , _ ) ⇒ peer match { < nl > - case Peer ( PeerType . Private , userId ) ⇒ ( userId % 100 ) . toString < nl > - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) < nl > - } < nl > - case DialogRootEnvelope ( userId , _ , _ ) ⇒ ( userId % 100 ) . toString < nl > + case c : UserCommand ⇒ ( c . userId % 100 ) . toString / / TODO : configurable < nl > + case q : UserQuery ⇒ ( q . userId % 100 ) . toString < nl > + case e : UserEnvelope ⇒ ( e . userId % 100 ) . toString < nl > } < nl > < nl > val typeName = " UserProcessor " < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index 883d2cc . . 02d93f1 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 254 , 13 + 254 , 9 @ @ trait HistoryHandlers { < nl > * in group dialog there are common dates of group < nl > * / < nl > private def getLastReceiveReadDates ( peer : Peer ) ( implicit client : AuthorizedClientData ) : DBIO [ ( DateTime , DateTime ) ] = { < nl > - val optDatesAction = peer match { < nl > - case Peer ( PeerType . Private , peerUserId ) ⇒ < nl > - DialogRepo . findUsers ( peerUserId , Peer . privat ( client . userId ) ) map ( _ . map ( d ⇒ d . ownerLastReceivedAt → d . ownerLastReadAt ) ) < nl > - case Peer ( PeerType . Group , _ ) ⇒ < nl > - DialogRepo . findCommon ( None , peer ) map ( _ . map ( d ⇒ d . lastReceivedAt → d . lastReadAt ) ) < nl > - } < nl > - optDatesAction map { _ getOrElse ( ZeroDate → ZeroDate ) } < nl > + DBIO . from ( for { < nl > + info ← dialogExt . getDialogInfo ( client . userId , peer ) < nl > + } yield ( new DateTime ( info . lastReceivedDate . toEpochMilli ) , new DateTime ( info . lastReadDate . toEpochMilli ) ) ) < nl > } < nl > < nl > private def getDialogStruct ( dialogModel : DialogObsolete ) ( implicit client : AuthorizedClientData ) : dbio . DBIO [ Option [ ApiDialog ] ] = {
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > index 641806f . . 71c4080 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > @ @ - 43 , 7 + 43 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > ) < nl > < nl > for { < nl > - senderName ← userExt . getName ( receiverUserId , senderUserId ) < nl > + senderName ← userExt . getName ( senderUserId , receiverUserId ) < nl > pushText ← getPushText ( peer , receiverUserId , senderName , message ) < nl > _ ← seqUpdatesExt . deliverSingleUpdate ( < nl > receiverUserId , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > index 4181a2e . . 3230c26 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . cache . CacheHelpers . _ < nl > + import org . joda . time . DateTime < nl > import slick . dbio . DBIO < nl > < nl > import slick . driver . PostgresDriver . api . Database < nl > @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > dialog ← optDialog match { < nl > case Some ( dialog ) ⇒ DBIO . successful ( dialog ) < nl > case None ⇒ < nl > - val dialog = DialogModel ( userId , peer ) < nl > + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > for { < nl > _ ← DialogRepo . create ( dialog ) < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index b45cc33 . . d2c2ddb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > throw e < nl > } ) pipeTo sender ( ) < nl > sendFuture onSuccess { < nl > - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) < nl > + case SeqStateDate ( _ , _ , date ) ⇒ < nl > + self ! LastOwnMessageDate ( date ) < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > } < nl > } < nl > < nl > @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > deliveryExt < nl > . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > . map ( _ ⇒ SendMessageAck ( ) ) < nl > - . pipeTo ( sender ( ) ) < nl > - < nl > - if ( state . isHidden ) < nl > - self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + . pipeTo ( sender ( ) ) onSuccess { < nl > + case _ ⇒ < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } < nl > < nl > / / onSuccess ( fu ) { _ = > < nl > / / updatePeerMessageDate ( ) < nl > @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > if ( state . isHidden ) < nl > sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) < nl > else { < nl > + < nl > val future = < nl > ( for { < nl > _ ← db . run ( DialogRepo . hide ( userId , peer ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 55230de . . 01a8d62 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > + sealed trait DialogGroup { < nl > + def key : String < nl > + def title : String < nl > + } < nl > + < nl > + object DialogGroups { < nl > + object Privates extends DialogGroup { < nl > + override def key : String = " privates " < nl > + < nl > + override def title : String = " Private " < nl > + } < nl > + < nl > + object Groups extends DialogGroup { < nl > + override def key : String = " groups " < nl > + < nl > + override def title : String = " Groups " < nl > + } < nl > + } < nl > + < nl > sealed trait DialogExtension extends Extension < nl > < nl > final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { < nl > @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > < nl > private val log = Logging ( system , getClass ) < nl > < nl > - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > peer match { < nl > - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ < nl > + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ < nl > log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) < nl > failed < nl > case _ ⇒ f < nl > } < nl > < nl > def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > val date = Instant . now ( ) . toEpochMilli < nl > val sender = Peer . privat ( senderUserId ) < nl > val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) < nl > @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > randomId : Long , < nl > message : ApiMessage < nl > ) : Future [ Unit ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { < nl > val sender = Peer . privat ( senderUserId ) < nl > val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) < nl > ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) < nl > } < nl > < nl > def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val receiver = Peer . privat ( receiverUserId ) < nl > val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) < nl > @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > < nl > def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val reader = Peer . privat ( readerUserId ) < nl > val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) < nl > @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > < nl > def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def isSharedUser ( userId : Int ) : Boolean = userId = = 0 < nl > < nl > def getGroupedDialogs ( userId : Int ) = { < nl > - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { < nl > case ( ( groupModels , privateModels ) , dialog ) ⇒ < nl > if ( dialog . peer . typ = = PeerType . Group ) < nl > @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) < nl > privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) < nl > } yield Vector ( < nl > - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , < nl > - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) < nl > + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , < nl > + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) < nl > ) < nl > } ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index 4219e8c . . d3a6b75 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { < nl > for { < nl > _ ← persist . HistoryMessageRepo . create ( messages ) < nl > _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) < nl > - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > } yield ( ) < nl > } else if ( toPeer . typ = = PeerType . Group ) { < nl > DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > index 9475e63 . . 912092d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > @ @ - 15 , 27 + 15 , 19 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int , applePushManager : A < nl > private val db = DbExtension ( system ) . db < nl > < nl > def deliverInvisible ( seq : Int , creds : ApplePushCredentials ) : Unit = { < nl > - < < < < < < < Updated upstream < nl > - applePushManager . getInstance ( creds . apnsKey ) match { < nl > - case Some ( mgr ) ⇒ < nl > - db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ < nl > - val builder = < nl > - new ApnsPayloadBuilder ( ) < nl > - . addCustomProperty ( " seq " , seq ) < nl > - . setContentAvailable ( true ) < nl > - = = = = = = = < nl > withMgr ( creds . apnsKey ) { mgr ⇒ < nl > log . debug ( " Delivering invisible ( seq : { } ) to apnsKey : { } " , seq , creds . apnsKey ) < nl > - > > > > > > > Stashed changes < nl > - < nl > + db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ < nl > + val builder = < nl > + new ApnsPayloadBuilder ( ) < nl > + . addCustomProperty ( " seq " , seq ) < nl > + . setContentAvailable ( true ) < nl > builder . setBadgeNumber ( unreadTotal ) < nl > < nl > val payload = builder . buildWithDefaultMaximumLength ( ) < nl > < nl > mgr . getQueue . add ( new SimpleApnsPushNotification ( creds . token . toByteArray , payload ) ) < nl > } < nl > - case None ⇒ < nl > - log . warning ( " No apple push configured for apns - key : { } " , creds . apnsKey ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > index 191aa44 . . a59b5b2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { < nl > def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { < nl > phones . headOption match { < nl > case Some ( phone ) ⇒ Some ( phone . number ) < nl > - case None ⇒ Some ( 0L ) < nl > + case None ⇒ Some ( 0L ) < nl > } < nl > } < nl > < nl > def normalizeLocalName ( name : Option [ String ] ) = name match { < nl > - case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > - case _ ⇒ None < nl > + case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > + case _ ⇒ None < nl > } < nl > < nl > def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > index 9bf22b0 . . d215e44 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . api . http . bots < nl > import java . util . Base64 < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . http . scaladsl . model . StatusCode < nl > import akka . http . scaladsl . model . StatusCodes . _ < nl > import akka . http . scaladsl . model . ws . { Message , TextMessage } < nl > + import akka . http . scaladsl . model . { HttpMethod , StatusCode } < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . Route < nl > import akka . stream . Materializer < nl > @ @ - 14 , 20 + 14 , 16 @ @ import akka . util . ByteString < nl > import cats . data . OptionT < nl > import cats . std . future . _ < nl > import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport < nl > - import im . actor . api . rpc . messaging . ApiJsonMessage < nl > - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . api . rpc . sequence . UpdateRawUpdate < nl > import im . actor . server . api . http . RoutesHandler < nl > import im . actor . server . api . http . json . { ContentUnmarshaller , JsValueUnmarshaller , JsonFormatters , Status } < nl > import im . actor . server . bot . { BotExtension , BotServerBlueprint } < nl > - import im . actor . server . dialog . DialogExtension < nl > import im . actor . server . model . AuthSession < nl > import im . actor . server . user . UserExtension < nl > import play . api . libs . json . _ < nl > import upickle . default . _ < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . util . control . NoStackTrace < nl > import scala . util . { Failure , Success } < nl > < nl > @ @ - 42 , 25 + 38 , 42 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > < nl > override def routes : Route = < nl > path ( " bots " / " hooks " / Segment ) { token ⇒ < nl > - post { < nl > - extractRequest { request ⇒ < nl > - val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) < nl > + extractRequest { request ⇒ < nl > + val method = request . method < nl > + val queryString = request . uri . queryString ( ) < nl > + val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) < nl > < nl > - val sendMessageF = for { < nl > - data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) < nl > - res ← sendMessage ( headers , data , token ) < nl > - } yield res < nl > + val sendMessageF = for { < nl > + data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) < nl > + res ← sendMessage ( method , queryString , headers , data , token ) < nl > + } yield res < nl > < nl > - onComplete ( sendMessageF ) { < nl > - case Success ( result ) ⇒ < nl > - result match { < nl > - case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) < nl > - case Right ( _ ) ⇒ complete ( OK → Status ( " ok " ) ) < nl > - } < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to handle bot hook " ) < nl > - complete ( InternalServerError ) < nl > - } < nl > + onComplete ( sendMessageF ) { < nl > + case Success ( result ) ⇒ < nl > + result match { < nl > + case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) < nl > + case Right ( _ ) ⇒ < nl > + val response = < nl > + " " " < nl > + | < html > < nl > + | < head > < nl > + | < title > Please , return to the app < / title > < nl > + | < style > < nl > + | . element { < nl > + | position : relative ; < nl > + | top : 50 % ; < nl > + | transform : translateY ( - 50 % ) ; < nl > + | } < nl > + | < / style > < nl > + | < / head > < nl > + | < body > < center id = " message " > < h3 > Please , return to the app . < / h1 > < / center > < / body > < nl > + | < / html > < nl > + " " " . stripMargin < nl > + complete ( OK → Status ( response ) ) < nl > + } < nl > + case Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to handle bot hook " ) < nl > + complete ( InternalServerError ) < nl > } < nl > } < nl > } ~ path ( " bots " / Segment ) { token ⇒ < nl > @ @ - 84 , 7 + 97 , 7 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > } < nl > } < nl > < nl > - private def sendMessage ( headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { < nl > + private def sendMessage ( method : HttpMethod , queryString : Option [ String ] , headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { < nl > ( for { < nl > hook ← OptionT ( botExt . findWebHook ( token ) ) < nl > _ ← OptionT . pure ( userExt . broadcastUserUpdate ( < nl > @ @ - 95 , 6 + 108 , 8 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > " dataType " → JsString ( " HookData " ) , < nl > " data " → JsObject ( Map ( < nl > " name " → JsString ( hook . name ) , < nl > + " method " → JsString ( method . name ) , < nl > + " queryString " → ( queryString map JsString getOrElse JsNull ) , < nl > " headers " → JsObject ( headers map { case ( name , value ) ⇒ name → JsString ( value ) } ) , < nl > " body " → JsString ( Base64 . getEncoder . encodeToString ( data . toArray ) ) < nl > ) ) < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > index f7b0742 . . f9c82b0 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { < nl > def findLastReadBefore ( date : DateTime , userId : Int ) = < nl > dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result < nl > < nl > - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) < nl > + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > < nl > def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > index 14c35dd . . 66d4ebf 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { < nl > | " com . trueaccord . scalapb . GeneratedMessage " = actor < nl > | } < nl > | } < nl > + | < nl > + | cluster . sharding . state - store - mode = " ddata " < nl > | } < nl > " " " . stripMargin < nl > ) ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > index 3d25a02 . . 72dc6c1 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > @ @ - 1 , 27 + 1 , 52 @ @ < nl > package im . actor . server < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . util . Timeout < nl > import im . actor . api . rpc . ClientData < nl > - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } < nl > + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . api . rpc . users . ApiUser < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . dialog . DialogGroup < nl > + import org . scalatest . concurrent . ScalaFutures < nl > < nl > - import scala . concurrent . Await < nl > + import scala . language . postfixOps < nl > import scala . util . Random < nl > < nl > - trait MessagingSpecHelpers { < nl > - val timeout : Timeout < nl > + trait MessagingSpecHelpers extends ScalaFutures { < nl > + implicit val system : ActorSystem < nl > < nl > def sendMessageToUser ( userId : Int , message : ApiMessage ) ( < nl > implicit < nl > clientData : ClientData , < nl > - msgService : MessagingService , < nl > - system : ActorSystem < nl > + msgService : MessagingService < nl > ) : Unit = { < nl > - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) < nl > - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) < nl > + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ < nl > + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) < nl > + } < nl > } < nl > < nl > def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) < nl > + < nl > + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { < nl > + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ < nl > + resp . toOption . get . dialogs map { < nl > + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs < nl > + } toMap < nl > + } < nl > + } < nl > + < nl > + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { < nl > + val dgs = getDialogGroups ( ) < nl > + dgs get group . key match { < nl > + case Some ( ds ) ⇒ ds < nl > + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) < nl > + } < nl > + } < nl > + < nl > + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { < nl > + users foreach { user ⇒ < nl > + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) < nl > + Thread . sleep ( 1 ) < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > index 85ba87d . . fe02129 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } < nl > - import org . scalatest . Inside . _ < nl > + import im . actor . server . _ < nl > + import im . actor . server . dialog . DialogGroups < nl > < nl > import scala . concurrent . { Await , Future } < nl > import scala . concurrent . duration . _ < nl > @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec < nl > extends BaseAppSuite < nl > with ImplicitAuthService < nl > with ImplicitSessionRegion < nl > - with GroupsServiceHelpers { < nl > + with GroupsServiceHelpers < nl > + with MessagingSpecHelpers { < nl > " LoadGroupedDialogs " should " load groups and privates " in loadGrouped < nl > < nl > - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > - private val service = MessagingServiceImpl ( ) < nl > + " Dialogs " should " appear in top on new incoming message " in incomingGoTop < nl > + it should " appear in top on new outgoing message " in outgoingGoTop < nl > + < nl > + " Hidden dialogs " should " appear on new message " in appearHidden < nl > + it should " appear on show " in appearShown < nl > + < nl > + import DialogGroups . _ < nl > + < nl > + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > + private implicit lazy val service = MessagingServiceImpl ( ) < nl > < nl > def loadGrouped ( ) = { < nl > val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) < nl > @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec < nl > } < nl > } < nl > } < nl > + < nl > + def incomingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) < nl > + < nl > + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = bobClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val dgs = getDialogGroups ( ) < nl > + val privates = dgs ( Privates . key ) < nl > + privates . size should equal ( 2 ) < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + privates . last . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val privates = getDialogGroups ( Privates ) < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + } < nl > + < nl > + def outgoingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + val ( eve , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + < nl > + prepareDialogs ( bob , eve ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + } < nl > + } < nl > + < nl > + def appearHidden ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > + < nl > + def appearShown ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 16396b4 . . 6e7f6d7 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 21 , 6 + 21 , 8 @ @ message DialogInfo { 
 required Peer peer = 3 ; 
 required int32 counter = 1 ; 
 required int64 date = 2 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + required int64 last _ received _ date = 5 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + required int64 last _ read _ date = 4 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 } 
 
 message DialogGroup { 
 @ @ - 126 , 8 + 128 , 21 @ @ message DialogRootQueries { 
 } 
 } 
 
 + message DialogRootEnvelope { 
 + oneof query { 
 + DialogRootQueries . GetCounter get _ counter = 2 ; 
 + DialogRootQueries . GetDialogGroups get _ dialog _ groups = 3 ; 
 + } 
 + oneof command { 
 + DialogRootCommands . Archive archive = 6 ; 
 + DialogRootCommands . Unarchive unarchive = 4 ; 
 + DialogRootCommands . Favourite favourite = 7 ; 
 + DialogRootCommands . Unfavourite unfavourite = 8 ; 
 + DialogRootCommands . Delete delete = 9 ; 
 + } 
 + } 
 + 
 message DialogEnvelope { 
 - required Peer peer = 1 ; 
 oneof command { 
 DialogCommands . WriteMessage write _ message = 2 ; 
 DialogCommands . SendMessage send _ message = 3 ; 
 @ @ - 136 , 7 + 151 , 6 @ @ message DialogEnvelope { 
 DialogCommands . SetReaction set _ reaction = 9 ; 
 DialogCommands . RemoveReaction remove _ reaction = 10 ; 
 DialogCommands . WriteMessageSelf write _ message _ self = 11 ; 
 - DialogCommands . UpdateCounters update _ counters = 14 ; 
 } 
 oneof query { 
 DialogQueries . GetCounter get _ counter = 15 ; 
 diff - - git a / actor - server / actor - core / src / main / protobuf / group . proto b / actor - server / actor - core / src / main / protobuf / group . proto 
 index ab197c5 . . dd88e3a 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / group . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / group . proto 
 @ @ - 10 , 12 + 10 , 19 @ @ option ( scalapb . options ) = { 
 import " scalapb / scalapb . proto " ; 
 import " file . proto " ; 
 import " sequence . proto " ; 
 + import " dialog . proto " ; 
 
 enum GroupType { 
 General = 1 ; 
 Public = 2 ; 
 } 
 
 + / / TODO : put GroupCommands and GroupQueries inside 
 + message GroupEnvelope { 
 + required int32 group _ id = 1 ; 
 + optional DialogEnvelope dialog _ envelope = 2 ; 
 + } 
 + 
 message GroupCommands { 
 message Create { 
 option ( scalapb . message ) . extends = " im . actor . server . group . GroupCommand " ; 
 diff - - git a / actor - server / actor - core / src / main / protobuf / user . proto b / actor - server / actor - core / src / main / protobuf / user . proto 
 index a7db8df . . b7ed956 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / user . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / user . proto 
 @ @ - 325 , 19 + 325 , 12 @ @ message UserQueries { 
 } 
 } 
 
 - message DialogRootEnvelope { 
 + / / TODO : put UserCommands and UserQueries inside 
 + 
 + message UserEnvelope { 
 required int32 user _ id = 1 ; 
 - oneof query { 
 - DialogRootQueries . GetCounter get _ counter = 2 ; 
 - DialogRootQueries . GetDialogGroups get _ dialog _ groups = 3 ; 
 - } 
 - oneof command { 
 - DialogRootCommands . Archive archive = 6 ; 
 - DialogRootCommands . Unarchive unarchive = 4 ; 
 - DialogRootCommands . Favourite favourite = 7 ; 
 - DialogRootCommands . Unfavourite unfavourite = 8 ; 
 - DialogRootCommands . Delete delete = 9 ; 
 - } 
 + optional DialogRootEnvelope dialog _ root _ envelope = 2 ; 
 + optional DialogEnvelope dialog _ envelope = 3 ; 
 } 
 
 message UserEvents { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index f49e7c4 . . 0ec3fb2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 58 , 7 + 58 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 default = for { 
 _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( sendDate ) ) ) 
 _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 - _ = dialogExt . updateCounters ( peer , userId ) 
 + / / _ = dialogExt . updateCounters ( peer , userId ) 
 SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) 
 } yield SeqStateDate ( seq , state , sendDate ) , 
 failed = for { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 5261bf7 . . 0d053bb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 8 , 18 + 8 , 18 @ @ import akka . http . scaladsl . util . FastFuture 
 import akka . pattern . ask 
 import akka . util . Timeout 
 import im . actor . api . rpc . _ 
 - import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage } 
 + import im . actor . api . rpc . messaging . { ApiDialog , ApiDialogGroup , ApiDialogShort , ApiMessage } 
 import im . actor . api . rpc . misc . ApiExtension 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . extension . InternalExtensions 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . DialogCommands . _ 
 - import im . actor . server . group . GroupExtension 
 + import im . actor . server . group . { GroupEnvelope , GroupExtension } 
 import im . actor . server . model . _ 
 import im . actor . server . persist . HistoryMessageRepo 
 import im . actor . server . persist . messaging . ReactionEventRepo 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 - import im . actor . server . user . { DialogRootEnvelope , UserExtension } 
 + import im . actor . server . user . { UserEnvelope , UserExtension } 
 import im . actor . types . _ 
 import org . joda . time . DateTime 
 import slick . dbio . DBIO 
 @ @ - 64 , 10 + 64 , 9 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 forUserId : Option [ UserId ] = None 
 ) : Future [ SeqStateDate ] = 
 withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 - val sender = Peer . privat ( senderUserId ) 
 / / we don ' t set date here , cause actual date set inside dialog processor 
 val sendMessage = SendMessage ( 
 - origin = sender , 
 + origin = Peer . privat ( senderUserId ) , 
 dest = peer . asModel , 
 senderAuthSid = senderAuthSid , 
 senderAuthId = senderAuthId , 
 @ @ - 78 , 11 + 77 , 11 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 isFat = isFat , 
 forUserId = forUserId 
 ) 
 - ( userExt . processorRegion . ref ? DialogEnvelope ( sender ) . withSendMessage ( sendMessage ) ) . mapTo [ SeqStateDate ] 
 + ( userExt . processorRegion . ref ? UserEnvelope ( senderUserId ) . withDialogEnvelope ( DialogEnvelope ( ) . withSendMessage ( sendMessage ) ) ) . mapTo [ SeqStateDate ] 
 } 
 
 def ackSendMessage ( peer : Peer , sm : SendMessage ) : Future [ Unit ] = 
 - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withSendMessage ( sm ) ) . mapTo [ SendMessageAck ] map ( _ ⇒ ( ) ) 
 + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withSendMessage ( sm ) ) ) . mapTo [ SendMessageAck ] map ( _ ⇒ ( ) ) 
 
 def writeMessage ( 
 peer : ApiPeer , 
 @ @ - 108 , 13 + 107 , 13 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ) : Future [ Unit ] = 
 withValidPeer ( Peer . privat ( userId ) , peer . id , Future . successful ( ( ) ) ) { 
 ( userExt . processorRegion . ref ? 
 - DialogEnvelope ( Peer . privat ( userId ) ) . withWriteMessageSelf ( WriteMessageSelf ( 
 + envelope ( Peer . privat ( userId ) , DialogEnvelope ( ) . withWriteMessageSelf ( WriteMessageSelf ( 
 dest = peer . asModel , 
 senderUserId , 
 date . getMillis , 
 randomId , 
 message 
 - ) ) ) map ( _ ⇒ ( ) ) 
 + ) ) ) ) map ( _ ⇒ ( ) ) 
 } 
 
 def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = 
 @ @ - 122 , 84 + 121 , 89 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 val now = Instant . now ( ) . toEpochMilli 
 val receiver = Peer . privat ( receiverUserId ) 
 val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) 
 - ( userExt . processorRegion . ref ? DialogEnvelope ( receiver ) . withMessageReceived ( messageReceived ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 + ( userExt . processorRegion . ref ? envelope ( receiver , DialogEnvelope ( ) . withMessageReceived ( messageReceived ) ) ) 
 + . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 } 
 
 def ackMessageReceived ( peer : Peer , mr : MessageReceived ) : Future [ Unit ] = 
 - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withMessageReceived ( mr ) ) ) 
 + . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 
 def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = 
 withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val reader = Peer . privat ( readerUserId ) 
 val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) 
 - ( userExt . processorRegion . ref ? DialogEnvelope ( reader ) . withMessageRead ( messageRead ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 + ( userExt . processorRegion . ref ? envelope ( reader , DialogEnvelope ( ) . withMessageRead ( messageRead ) ) ) 
 + . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 } 
 
 def ackMessageRead ( peer : Peer , mr : MessageRead ) : Future [ Unit ] = 
 - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withMessageRead ( mr ) ) ) 
 + . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 
 def unarchive ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withUnarchive ( DialogRootCommands . Unarchive ( peer ) ) ) . mapTo [ SeqState ] 
 + ( userExt . processorRegion . ref ? 
 + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withUnarchive ( DialogRootCommands . Unarchive ( peer ) ) ) ) 
 + . mapTo [ SeqState ] 
 } 
 
 def archive ( userId : Int , peer : Peer , clientAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = 
 withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withArchive ( DialogRootCommands . Archive ( peer , clientAuthSid ) ) ) . mapTo [ SeqState ] 
 + ( userExt . processorRegion . ref ? 
 + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withArchive ( DialogRootCommands . Archive ( peer , clientAuthSid ) ) ) ) 
 + . mapTo [ SeqState ] 
 } 
 
 def favourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withFavourite ( DialogRootCommands . Favourite ( peer ) ) ) . mapTo [ SeqState ] 
 + ( userExt . processorRegion . ref ? 
 + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withFavourite ( DialogRootCommands . Favourite ( peer ) ) ) ) 
 + . mapTo [ SeqState ] 
 } 
 
 def unfavourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withUnfavourite ( DialogRootCommands . Unfavourite ( peer ) ) ) . mapTo [ SeqState ] 
 + ( userExt . processorRegion . ref ? 
 + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withUnfavourite ( DialogRootCommands . Unfavourite ( peer ) ) ) ) 
 + . mapTo [ SeqState ] 
 } 
 
 def delete ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 withValidPeer ( peer , userId ) { 
 - ( userExt . processorRegion . ref ? DialogRootEnvelope ( userId ) . withDelete ( DialogRootCommands . Delete ( peer ) ) ) . mapTo [ SeqState ] 
 + ( userExt . processorRegion . ref ? 
 + UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withDelete ( DialogRootCommands . Delete ( peer ) ) ) ) 
 + . mapTo [ SeqState ] 
 } 
 
 def setReaction ( userId : Int , authSid : Int , peer : Peer , randomId : Long , code : String ) : Future [ SetReactionAck ] = 
 withValidPeer ( peer , userId ) { 
 - ( userExt . processorRegion . ref ? DialogEnvelope ( Peer . privat ( userId ) ) . withSetReaction ( SetReaction ( 
 + ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withSetReaction ( SetReaction ( 
 origin = Peer . privat ( userId ) , 
 dest = peer , 
 clientAuthSid = authSid , 
 randomId = randomId , 
 code = code 
 - ) ) ) . mapTo [ SetReactionAck ] 
 + ) ) ) ) . mapTo [ SetReactionAck ] 
 } 
 
 def removeReaction ( userId : Int , authSid : Int , peer : Peer , randomId : Long , code : String ) : Future [ RemoveReactionAck ] = 
 withValidPeer ( peer , userId ) { 
 - ( userExt . processorRegion . ref ? DialogEnvelope ( Peer . privat ( userId ) ) . withRemoveReaction ( RemoveReaction ( 
 + ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withRemoveReaction ( RemoveReaction ( 
 origin = Peer . privat ( userId ) , 
 dest = peer , 
 clientAuthSid = authSid , 
 randomId = randomId , 
 code = code 
 - ) ) ) . mapTo [ RemoveReactionAck ] 
 + ) ) ) ) . mapTo [ RemoveReactionAck ] 
 } 
 
 def ackSetReaction ( peer : Peer , sr : SetReaction ) : Future [ Unit ] = 
 - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withSetReaction ( sr ) ) map ( _ ⇒ ( ) ) 
 + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withSetReaction ( sr ) ) ) map ( _ ⇒ ( ) ) 
 
 def ackRemoveReaction ( peer : Peer , rr : RemoveReaction ) : Future [ Unit ] = 
 - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withRemoveReaction ( rr ) ) map ( _ ⇒ ( ) ) 
 - 
 - def updateCounters ( peer : Peer , userId : Int ) : Future [ Unit ] = 
 - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withUpdateCounters ( UpdateCounters ( 
 - origin = Peer . privat ( userId ) , 
 - dest = peer 
 - ) ) ) map ( _ ⇒ ( ) ) 
 - 
 - def ackUpdateCounters ( peer : Peer , uc : UpdateCounters ) : Future [ Unit ] = 
 - ( processorRegion ( peer ) ? DialogEnvelope ( peer ) . withUpdateCounters ( uc ) ) map ( _ ⇒ ( ) ) 
 + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withRemoveReaction ( rr ) ) ) map ( _ ⇒ ( ) ) 
 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 @ @ - 223 , 7 + 227 , 13 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 
 def getUnreadTotal ( userId : Int ) : DBIO [ Int ] = 
 DBIO . from ( 
 - ( processorRegion ( Peer . privat ( userId ) ) ? DialogRootEnvelope ( userId ) . withGetCounter ( DialogRootQueries . GetCounter ( ) ) ) . mapTo [ DialogRootQueries . GetCounterResponse ] map ( _ . counter ) 
 + ( processorRegion ( Peer . privat ( userId ) ) ? 
 + UserEnvelope ( userId ) 
 + . withDialogRootEnvelope ( 
 + DialogRootEnvelope ( ) 
 + . withGetCounter ( DialogRootQueries . GetCounter ( ) ) 
 + ) ) 
 + . mapTo [ DialogRootQueries . GetCounterResponse ] map ( _ . counter ) 
 ) 
 
 def getUnreadCount ( clientUserId : Int , historyOwner : Int , peer : Peer , ownerLastReadAt : DateTime ) : DBIO [ Int ] = { 
 @ @ - 240 , 7 + 250 , 10 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def isSharedUser ( userId : Int ) : Boolean = userId = = 0 
 
 def fetchGroupedDialogs ( userId : Int ) : Future [ Seq [ DialogGroup ] ] = { 
 - ( processorRegion ( Peer . privat ( userId ) ) ? DialogRootEnvelope ( userId ) . withGetDialogGroups ( DialogRootQueries . GetDialogGroups ( ) ) ) 
 + ( processorRegion ( Peer . privat ( userId ) ) ? 
 + UserEnvelope ( userId ) 
 + . withDialogRootEnvelope ( DialogRootEnvelope ( ) 
 + . withGetDialogGroups ( DialogRootQueries . GetDialogGroups ( ) ) ) ) 
 . mapTo [ DialogRootQueries . GetDialogGroupsResponse ] 
 . map ( _ . groups ) 
 } 
 @ @ - 251 , 6 + 264 , 12 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 } 
 } 
 
 + def getDialogInfo ( userId : Int , peer : Peer ) : Future [ DialogInfo ] = { 
 + ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withGetInfo ( DialogQueries . GetInfo ( ) ) ) ) 
 + . mapTo [ DialogQueries . GetInfoResponse ] 
 + . map ( _ . info ) 
 + } 
 + 
 def dialogWithSelf ( userId : Int , dialog : DialogObsolete ) : Boolean = 
 dialog . peer . typ = = PeerType . Private & & dialog . peer . id = = userId 
 
 @ @ - 275 , 20 + 294 , 6 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 } 
 } 
 
 - def getDialogShortDBIO ( dialog : DialogObsolete ) ( implicit ec : ExecutionContext ) : DBIO [ ApiDialogShort ] = 
 - for { 
 - historyOwner ← DBIO . from ( HistoryUtils . getHistoryOwner ( dialog . peer , dialog . userId ) ) 
 - messageOpt ← HistoryMessageRepo . findNewest ( historyOwner , dialog . peer ) map ( _ . map ( _ . ofUser ( dialog . userId ) ) ) 
 - unreadCount ← getUnreadCount ( dialog . userId , historyOwner , dialog . peer , dialog . ownerLastReadAt ) 
 - } yield ApiDialogShort ( 
 - peer = ApiPeer ( ApiPeerType ( dialog . peer . typ . value ) , dialog . peer . id ) , 
 - counter = unreadCount , 
 - date = messageOpt . map ( _ . date . getMillis ) . getOrElse ( 0 ) 
 - ) 
 - 
 - def getDialogShort ( dialog : DialogObsolete ) ( implicit ec : ExecutionContext ) : Future [ ApiDialogShort ] = 
 - db . run ( getDialogShortDBIO ( dialog ) ) 
 - 
 private def processorRegion ( peer : Peer ) : ActorRef = peer . typ match { 
 case PeerType . Private ⇒ 
 userExt . processorRegion . ref / / to user peer 
 @ @ - 296 , 6 + 301 , 12 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 groupExt . processorRegion . ref / / to group peer 
 case _ ⇒ throw new RuntimeException ( " Unknown peer type ! " ) 
 } 
 + 
 + private def envelope ( peer : Peer , envelope : DialogEnvelope ) : Any = peer . typ match { 
 + case PeerType . Private ⇒ UserEnvelope ( peer . id ) . withDialogEnvelope ( envelope ) 
 + case PeerType . Group ⇒ GroupEnvelope ( peer . id ) . withDialogEnvelope ( envelope ) 
 + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 + } 
 } 
 
 object DialogExtension extends ExtensionId [ DialogExtensionImpl ] with ExtensionIdProvider { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index ce057a7 . . d84b8aa 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 154 , 7 + 154 , 15 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 case GetCounter ( ) ⇒ Future . successful ( GetCounterResponse ( state . counter ) ) 
 - case GetInfo ( ) ⇒ Future . successful ( GetInfoResponse ( DialogInfo ( peer , state . counter , Instant . ofEpochMilli ( state . lastMessageDate ) ) ) ) 
 + case GetInfo ( ) ⇒ Future . successful ( 
 + GetInfoResponse ( DialogInfo ( 
 + peer = peer , 
 + counter = state . counter , 
 + date = Instant . ofEpochMilli ( state . lastMessageDate ) , 
 + lastReceivedDate = Instant . ofEpochMilli ( state . lastReceiveDate ) , 
 + lastReadDate = Instant . ofEpochMilli ( state . lastReadDate ) 
 + ) ) 
 + ) 
 } 
 
 override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 index b492820 . . c9ce341 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 @ @ - 56 , 7 + 56 , 6 @ @ private [ group ] final class GroupPeer ( val groupId : Int ) 
 case sr : SetReaction ⇒ setReaction ( state , sr ) 
 case rr : RemoveReaction ⇒ removeReaction ( state , rr ) 
 case sc : LastSenderIdChanged ⇒ context become initialized ( state . updated ( sc ) ) 
 - case uc : UpdateCounters ⇒ updateCountersChanged ( uc ) 
 } 
 
 override def receive : Receive = initialized ( GroupPeerState . empty ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala 
 index 37df102 . . 6d91468 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala 
 @ @ - 39 , 18 + 39 , 6 @ @ trait GroupPeerCommandHandlers extends PeersImplicits { 
 } ) pipeTo sender ( ) 
 } 
 
 - protected def updateCountersChanged ( uc : UpdateCounters ) = { 
 - ( withMemberIds ( groupId ) { ( memberIds , _ , _ ) ⇒ 
 - Future . traverse ( memberIds - uc . origin . id ) { userId ⇒ 
 - dialogExt . ackUpdateCounters ( Peer . privat ( userId ) , uc ) 
 - } map ( _ ⇒ UpdateCountersAck ( ) ) 
 - } recover { 
 - case e ⇒ 
 - log . error ( e , " Failed to send update counters changed " ) 
 - throw e 
 - } ) pipeTo sender ( ) 
 - } 
 - 
 protected def messageReceived ( state : GroupPeerState , mr : MessageReceived ) = { 
 val receiverUserId = mr . origin . id 
 val canReceive = canMakeReceive ( state , mr ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 index c5c3bb9 . . 227cd7e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 @ @ - 12 , 8 + 12 , 8 @ @ import im . actor . serialization . ActorSerializer 
 import im . actor . server . KeyValueMappings 
 import im . actor . server . cqrs . TaggedEvent 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . dialog . { DirectDialogCommand , DialogExtension } 
 - import im . actor . server . file . { FileStorageExtension , FileStorageAdapter , Avatar } 
 + import im . actor . server . dialog . { DialogEnvelope , DialogExtension , DirectDialogCommand } 
 + import im . actor . server . file . { Avatar , FileStorageAdapter , FileStorageExtension } 
 import im . actor . server . model . Group 
 import im . actor . server . office . { PeerProcessor , ProcessorState , StopOffice } 
 import im . actor . server . sequence . SeqUpdatesExtension 
 @ @ - 244 , 9 + 244 , 10 @ @ private [ group ] final class GroupProcessor 
 makeUserAdmin ( state , clientUserId , candidateId ) 
 case RevokeIntegrationToken ( _ , userId ) ⇒ 
 revokeIntegrationToken ( state , userId ) 
 - case StopOffice ⇒ context stop self 
 - case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) 
 - case dc : DirectDialogCommand ⇒ groupPeer forward dc 
 + case StopOffice ⇒ context stop self 
 + case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) 
 + case de : DialogEnvelope ⇒ 
 + groupPeer forward de . getAllFields . values . head 
 } 
 
 private [ this ] var groupStateMaybe : Option [ GroupState ] = None 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala 
 index ca2d0c1 . . 5a8866b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala 
 @ @ - 3 , 10 + 3 , 6 @ @ package im . actor . server . group 
 import akka . actor . { ActorRef , ActorSystem , Props } 
 import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } 
 import akka . event . Logging 
 - import im . actor . server . dialog . DialogEnvelope 
 - import im . actor . server . model . { Peer , PeerType } 
 - 
 - import scala . util . { Success , Try } 
 
 object GroupProcessorRegion { 
 private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { 
 @ @ - 15 , 27 + 11 , 18 @ @ object GroupProcessorRegion { 
 { 
 case c : GroupCommand ⇒ ( c . groupId . toString , c ) 
 case q : GroupQuery ⇒ ( q . groupId . toString , q ) 
 - case e @ DialogEnvelope ( peer , command , query ) ⇒ peer match { 
 - case Peer ( PeerType . Group , groupId ) ⇒ 
 - Try ( e . getField ( DialogEnvelope . descriptor . findFieldByNumber ( command . number ) ) ) match { 
 - case Success ( any ) ⇒ ( groupId . toString , any ) 
 - case _ ⇒ 
 - val error = new RuntimeException ( s " Payload not found for $ e " ) 
 - log . error ( error , error . getMessage ) 
 - throw error 
 - } 
 - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in GroupProcessor " ) 
 - } 
 + case GroupEnvelope ( groupId , dialogEnvelope ) ⇒ 
 + ( 
 + groupId . toString , 
 + dialogEnvelope . get 
 + ) 
 } 
 } 
 
 private def extractShardId ( system : ActorSystem ) : ShardRegion . ExtractShardId = msg ⇒ msg match { 
 - case c : GroupCommand ⇒ ( c . groupId % 100 ) . toString / / TODO : configurable 
 - case q : GroupQuery ⇒ ( q . groupId % 100 ) . toString 
 - case DialogEnvelope ( peer , _ , _ ) ⇒ peer match { 
 - case Peer ( PeerType . Group , groupId ) ⇒ ( groupId % 100 ) . toString 
 - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in GroupProcessor " ) 
 - } 
 + case c : GroupCommand ⇒ ( c . groupId % 100 ) . toString / / TODO : configurable 
 + case q : GroupQuery ⇒ ( q . groupId % 100 ) . toString 
 + case e : GroupEnvelope ⇒ ( e . groupId % 100 ) . toString 
 } 
 
 val typeName = " GroupProcessor " 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 index c9f88f3 . . 5040eb4 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 @ @ - 19 , 6 + 19 , 7 @ @ import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . ExecutionContext 
 import scala . concurrent . duration . _ 
 + import scala . util . Try 
 
 trait UserEvent extends TaggedEvent { 
 val ts : Instant 
 @ @ - 242 , 10 + 243 , 12 @ @ private [ user ] final class UserProcessor 
 case query : GetLocalName ⇒ contacts . ref forward query 
 case StopOffice ⇒ context stop self 
 case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) 
 - case dc : DialogCommand ⇒ dialogRoot ( state . internalExtensions ) forward dc 
 - case dq : DialogQuery ⇒ dialogRoot ( state . internalExtensions ) forward dq 
 - case drc : DialogRootCommand ⇒ dialogRoot ( state . internalExtensions ) forward drc 
 - case drq : DialogRootQuery ⇒ dialogRoot ( state . internalExtensions ) forward drq 
 + case e @ DialogRootEnvelope ( query , command ) ⇒ 
 + val msg = e . getAllFields . values . head 
 + dialogRoot ( state . internalExtensions ) forward msg 
 + case de : DialogEnvelope ⇒ 
 + val msg = de . getAllFields . values . head 
 + dialogRoot ( state . internalExtensions ) forward msg 
 } 
 
 override protected def handleQuery ( state : UserState ) : Receive = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala 
 index 54e2794 . . e778117 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala 
 @ @ - 2 , 48 + 2 , 28 @ @ package im . actor . server . user 
 
 import akka . actor . { ActorRef , ActorSystem , Props } 
 import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } 
 - import akka . event . Logging 
 - import im . actor . server . dialog . DialogEnvelope 
 - import im . actor . server . model . { Peer , PeerType } 
 - 
 - import scala . util . { Try , Success } 
 
 object UserProcessorRegion { 
 private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { 
 - val log = Logging ( system , getClass ) 
 - 
 { 
 case c : UserCommand ⇒ ( c . userId . toString , c ) 
 case q : UserQuery ⇒ ( q . userId . toString , q ) 
 - case e @ DialogEnvelope ( peer , command , query ) ⇒ peer match { 
 - case Peer ( PeerType . Private , userId ) ⇒ 
 - Try ( e . getField ( DialogEnvelope . descriptor . findFieldByNumber ( command . number ) ) ) match { 
 - case Success ( any ) ⇒ ( userId . toString , any ) 
 - case _ ⇒ 
 - val error = new RuntimeException ( s " Payload not found for $ e " ) 
 - log . error ( error , error . getMessage ) 
 - throw error 
 - } 
 - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) 
 - } 
 - case e @ DialogRootEnvelope ( userId , query , command ) ⇒ 
 + case e @ UserEnvelope ( 
 + userId , 
 + dialogRootEnvelope , 
 + dialogEnvelope 
 + ) ⇒ 
 ( 
 userId . toString , 
 - if ( query . isDefined ) e . getField ( DialogRootEnvelope . descriptor . findFieldByNumber ( query . number ) ) 
 - else if ( command . isDefined ) e . getField ( DialogRootEnvelope . descriptor . findFieldByNumber ( command . number ) ) 
 - else throw new RuntimeException ( " No defined query nor command " ) 
 + dialogRootEnvelope . getOrElse ( dialogEnvelope . get ) 
 ) 
 } 
 } 
 
 private def extractShardId ( system : ActorSystem ) : ShardRegion . ExtractShardId = { 
 - case c : UserCommand ⇒ ( c . userId % 100 ) . toString / / TODO : configurable 
 - case q : UserQuery ⇒ ( q . userId % 100 ) . toString 
 - case DialogEnvelope ( peer , _ , _ ) ⇒ peer match { 
 - case Peer ( PeerType . Private , userId ) ⇒ ( userId % 100 ) . toString 
 - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) 
 - } 
 - case DialogRootEnvelope ( userId , _ , _ ) ⇒ ( userId % 100 ) . toString 
 + case c : UserCommand ⇒ ( c . userId % 100 ) . toString / / TODO : configurable 
 + case q : UserQuery ⇒ ( q . userId % 100 ) . toString 
 + case e : UserEnvelope ⇒ ( e . userId % 100 ) . toString 
 } 
 
 val typeName = " UserProcessor " 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index 883d2cc . . 02d93f1 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 254 , 13 + 254 , 9 @ @ trait HistoryHandlers { 
 * in group dialog there are common dates of group 
 * / 
 private def getLastReceiveReadDates ( peer : Peer ) ( implicit client : AuthorizedClientData ) : DBIO [ ( DateTime , DateTime ) ] = { 
 - val optDatesAction = peer match { 
 - case Peer ( PeerType . Private , peerUserId ) ⇒ 
 - DialogRepo . findUsers ( peerUserId , Peer . privat ( client . userId ) ) map ( _ . map ( d ⇒ d . ownerLastReceivedAt → d . ownerLastReadAt ) ) 
 - case Peer ( PeerType . Group , _ ) ⇒ 
 - DialogRepo . findCommon ( None , peer ) map ( _ . map ( d ⇒ d . lastReceivedAt → d . lastReadAt ) ) 
 - } 
 - optDatesAction map { _ getOrElse ( ZeroDate → ZeroDate ) } 
 + DBIO . from ( for { 
 + info ← dialogExt . getDialogInfo ( client . userId , peer ) 
 + } yield ( new DateTime ( info . lastReceivedDate . toEpochMilli ) , new DateTime ( info . lastReadDate . toEpochMilli ) ) ) 
 } 
 
 private def getDialogStruct ( dialogModel : DialogObsolete ) ( implicit client : AuthorizedClientData ) : dbio . DBIO [ Option [ ApiDialog ] ] = {

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 index 641806f . . 71c4080 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 @ @ - 43 , 7 + 43 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 ) 
 
 for { 
 - senderName ← userExt . getName ( receiverUserId , senderUserId ) 
 + senderName ← userExt . getName ( senderUserId , receiverUserId ) 
 pushText ← getPushText ( peer , receiverUserId , senderName , message ) 
 _ ← seqUpdatesExt . deliverSingleUpdate ( 
 receiverUserId , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 index 4181a2e . . 3230c26 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 import im . actor . util . cache . CacheHelpers . _ 
 + import org . joda . time . DateTime 
 import slick . dbio . DBIO 
 
 import slick . driver . PostgresDriver . api . Database 
 @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 dialog ← optDialog match { 
 case Some ( dialog ) ⇒ DBIO . successful ( dialog ) 
 case None ⇒ 
 - val dialog = DialogModel ( userId , peer ) 
 + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 for { 
 _ ← DialogRepo . create ( dialog ) 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index b45cc33 . . d2c2ddb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 throw e 
 } ) pipeTo sender ( ) 
 sendFuture onSuccess { 
 - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) 
 + case SeqStateDate ( _ , _ , date ) ⇒ 
 + self ! LastOwnMessageDate ( date ) 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 } 
 } 
 
 @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 deliveryExt 
 . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 . map ( _ ⇒ SendMessageAck ( ) ) 
 - . pipeTo ( sender ( ) ) 
 - 
 - if ( state . isHidden ) 
 - self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + . pipeTo ( sender ( ) ) onSuccess { 
 + case _ ⇒ 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } 
 
 / / onSuccess ( fu ) { _ = > 
 / / updatePeerMessageDate ( ) 
 @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 if ( state . isHidden ) 
 sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) 
 else { 
 + 
 val future = 
 ( for { 
 _ ← db . run ( DialogRepo . hide ( userId , peer ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 55230de . . 01a8d62 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 
 + sealed trait DialogGroup { 
 + def key : String 
 + def title : String 
 + } 
 + 
 + object DialogGroups { 
 + object Privates extends DialogGroup { 
 + override def key : String = " privates " 
 + 
 + override def title : String = " Private " 
 + } 
 + 
 + object Groups extends DialogGroup { 
 + override def key : String = " groups " 
 + 
 + override def title : String = " Groups " 
 + } 
 + } 
 + 
 sealed trait DialogExtension extends Extension 
 
 final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { 
 @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 
 private val log = Logging ( system , getClass ) 
 
 - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 peer match { 
 - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ 
 + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ 
 log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) 
 failed 
 case _ ⇒ f 
 } 
 
 def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 val date = Instant . now ( ) . toEpochMilli 
 val sender = Peer . privat ( senderUserId ) 
 val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) 
 @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 randomId : Long , 
 message : ApiMessage 
 ) : Future [ Unit ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { 
 val sender = Peer . privat ( senderUserId ) 
 val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) 
 ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) 
 } 
 
 def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val receiver = Peer . privat ( receiverUserId ) 
 val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) 
 @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 
 def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val reader = Peer . privat ( readerUserId ) 
 val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) 
 @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 
 def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def isSharedUser ( userId : Int ) : Boolean = userId = = 0 
 
 def getGroupedDialogs ( userId : Int ) = { 
 - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { 
 case ( ( groupModels , privateModels ) , dialog ) ⇒ 
 if ( dialog . peer . typ = = PeerType . Group ) 
 @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) 
 privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) 
 } yield Vector ( 
 - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , 
 - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) 
 + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , 
 + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) 
 ) 
 } ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index 4219e8c . . d3a6b75 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { 
 for { 
 _ ← persist . HistoryMessageRepo . create ( messages ) 
 _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) 
 - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 } yield ( ) 
 } else if ( toPeer . typ = = PeerType . Group ) { 
 DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 index 9475e63 . . 912092d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 @ @ - 15 , 27 + 15 , 19 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int , applePushManager : A 
 private val db = DbExtension ( system ) . db 
 
 def deliverInvisible ( seq : Int , creds : ApplePushCredentials ) : Unit = { 
 - < < < < < < < Updated upstream 
 - applePushManager . getInstance ( creds . apnsKey ) match { 
 - case Some ( mgr ) ⇒ 
 - db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ 
 - val builder = 
 - new ApnsPayloadBuilder ( ) 
 - . addCustomProperty ( " seq " , seq ) 
 - . setContentAvailable ( true ) 
 - = = = = = = = 
 withMgr ( creds . apnsKey ) { mgr ⇒ 
 log . debug ( " Delivering invisible ( seq : { } ) to apnsKey : { } " , seq , creds . apnsKey ) 
 - > > > > > > > Stashed changes 
 - 
 + db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ 
 + val builder = 
 + new ApnsPayloadBuilder ( ) 
 + . addCustomProperty ( " seq " , seq ) 
 + . setContentAvailable ( true ) 
 builder . setBadgeNumber ( unreadTotal ) 
 
 val payload = builder . buildWithDefaultMaximumLength ( ) 
 
 mgr . getQueue . add ( new SimpleApnsPushNotification ( creds . token . toByteArray , payload ) ) 
 } 
 - case None ⇒ 
 - log . warning ( " No apple push configured for apns - key : { } " , creds . apnsKey ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 index 191aa44 . . a59b5b2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { 
 def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { 
 phones . headOption match { 
 case Some ( phone ) ⇒ Some ( phone . number ) 
 - case None ⇒ Some ( 0L ) 
 + case None ⇒ Some ( 0L ) 
 } 
 } 
 
 def normalizeLocalName ( name : Option [ String ] ) = name match { 
 - case n @ Some ( name ) if name . nonEmpty ⇒ n 
 - case _ ⇒ None 
 + case n @ Some ( name ) if name . nonEmpty ⇒ n 
 + case _ ⇒ None 
 } 
 
 def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 index 9bf22b0 . . d215e44 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . api . http . bots 
 import java . util . Base64 
 
 import akka . actor . ActorSystem 
 - import akka . http . scaladsl . model . StatusCode 
 import akka . http . scaladsl . model . StatusCodes . _ 
 import akka . http . scaladsl . model . ws . { Message , TextMessage } 
 + import akka . http . scaladsl . model . { HttpMethod , StatusCode } 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . Route 
 import akka . stream . Materializer 
 @ @ - 14 , 20 + 14 , 16 @ @ import akka . util . ByteString 
 import cats . data . OptionT 
 import cats . std . future . _ 
 import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport 
 - import im . actor . api . rpc . messaging . ApiJsonMessage 
 - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . api . rpc . sequence . UpdateRawUpdate 
 import im . actor . server . api . http . RoutesHandler 
 import im . actor . server . api . http . json . { ContentUnmarshaller , JsValueUnmarshaller , JsonFormatters , Status } 
 import im . actor . server . bot . { BotExtension , BotServerBlueprint } 
 - import im . actor . server . dialog . DialogExtension 
 import im . actor . server . model . AuthSession 
 import im . actor . server . user . UserExtension 
 import play . api . libs . json . _ 
 import upickle . default . _ 
 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . util . control . NoStackTrace 
 import scala . util . { Failure , Success } 
 
 @ @ - 42 , 25 + 38 , 42 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 
 override def routes : Route = 
 path ( " bots " / " hooks " / Segment ) { token ⇒ 
 - post { 
 - extractRequest { request ⇒ 
 - val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) 
 + extractRequest { request ⇒ 
 + val method = request . method 
 + val queryString = request . uri . queryString ( ) 
 + val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) 
 
 - val sendMessageF = for { 
 - data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) 
 - res ← sendMessage ( headers , data , token ) 
 - } yield res 
 + val sendMessageF = for { 
 + data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) 
 + res ← sendMessage ( method , queryString , headers , data , token ) 
 + } yield res 
 
 - onComplete ( sendMessageF ) { 
 - case Success ( result ) ⇒ 
 - result match { 
 - case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) 
 - case Right ( _ ) ⇒ complete ( OK → Status ( " ok " ) ) 
 - } 
 - case Failure ( e ) ⇒ 
 - log . error ( e , " Failed to handle bot hook " ) 
 - complete ( InternalServerError ) 
 - } 
 + onComplete ( sendMessageF ) { 
 + case Success ( result ) ⇒ 
 + result match { 
 + case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) 
 + case Right ( _ ) ⇒ 
 + val response = 
 + " " " 
 + | < html > 
 + | < head > 
 + | < title > Please , return to the app < / title > 
 + | < style > 
 + | . element { 
 + | position : relative ; 
 + | top : 50 % ; 
 + | transform : translateY ( - 50 % ) ; 
 + | } 
 + | < / style > 
 + | < / head > 
 + | < body > < center id = " message " > < h3 > Please , return to the app . < / h1 > < / center > < / body > 
 + | < / html > 
 + " " " . stripMargin 
 + complete ( OK → Status ( response ) ) 
 + } 
 + case Failure ( e ) ⇒ 
 + log . error ( e , " Failed to handle bot hook " ) 
 + complete ( InternalServerError ) 
 } 
 } 
 } ~ path ( " bots " / Segment ) { token ⇒ 
 @ @ - 84 , 7 + 97 , 7 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 } 
 } 
 
 - private def sendMessage ( headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { 
 + private def sendMessage ( method : HttpMethod , queryString : Option [ String ] , headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { 
 ( for { 
 hook ← OptionT ( botExt . findWebHook ( token ) ) 
 _ ← OptionT . pure ( userExt . broadcastUserUpdate ( 
 @ @ - 95 , 6 + 108 , 8 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 " dataType " → JsString ( " HookData " ) , 
 " data " → JsObject ( Map ( 
 " name " → JsString ( hook . name ) , 
 + " method " → JsString ( method . name ) , 
 + " queryString " → ( queryString map JsString getOrElse JsNull ) , 
 " headers " → JsObject ( headers map { case ( name , value ) ⇒ name → JsString ( value ) } ) , 
 " body " → JsString ( Base64 . getEncoder . encodeToString ( data . toArray ) ) 
 ) ) 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 index f7b0742 . . f9c82b0 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { 
 def findLastReadBefore ( date : DateTime , userId : Int ) = 
 dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result 
 
 - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) 
 + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 
 def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 index 14c35dd . . 66d4ebf 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { 
 | " com . trueaccord . scalapb . GeneratedMessage " = actor 
 | } 
 | } 
 + | 
 + | cluster . sharding . state - store - mode = " ddata " 
 | } 
 " " " . stripMargin 
 ) ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 index 3d25a02 . . 72dc6c1 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 @ @ - 1 , 27 + 1 , 52 @ @ 
 package im . actor . server 
 
 import akka . actor . ActorSystem 
 - import akka . util . Timeout 
 import im . actor . api . rpc . ClientData 
 - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } 
 + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . api . rpc . users . ApiUser 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . dialog . DialogGroup 
 + import org . scalatest . concurrent . ScalaFutures 
 
 - import scala . concurrent . Await 
 + import scala . language . postfixOps 
 import scala . util . Random 
 
 - trait MessagingSpecHelpers { 
 - val timeout : Timeout 
 + trait MessagingSpecHelpers extends ScalaFutures { 
 + implicit val system : ActorSystem 
 
 def sendMessageToUser ( userId : Int , message : ApiMessage ) ( 
 implicit 
 clientData : ClientData , 
 - msgService : MessagingService , 
 - system : ActorSystem 
 + msgService : MessagingService 
 ) : Unit = { 
 - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) 
 - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) 
 + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ 
 + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) 
 + } 
 } 
 
 def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) 
 + 
 + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { 
 + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ 
 + resp . toOption . get . dialogs map { 
 + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs 
 + } toMap 
 + } 
 + } 
 + 
 + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { 
 + val dgs = getDialogGroups ( ) 
 + dgs get group . key match { 
 + case Some ( ds ) ⇒ ds 
 + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) 
 + } 
 + } 
 + 
 + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { 
 + users foreach { user ⇒ 
 + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) 
 + Thread . sleep ( 1 ) 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 index 85ba87d . . fe02129 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } 
 - import org . scalatest . Inside . _ 
 + import im . actor . server . _ 
 + import im . actor . server . dialog . DialogGroups 
 
 import scala . concurrent . { Await , Future } 
 import scala . concurrent . duration . _ 
 @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec 
 extends BaseAppSuite 
 with ImplicitAuthService 
 with ImplicitSessionRegion 
 - with GroupsServiceHelpers { 
 + with GroupsServiceHelpers 
 + with MessagingSpecHelpers { 
 " LoadGroupedDialogs " should " load groups and privates " in loadGrouped 
 
 - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 - private val service = MessagingServiceImpl ( ) 
 + " Dialogs " should " appear in top on new incoming message " in incomingGoTop 
 + it should " appear in top on new outgoing message " in outgoingGoTop 
 + 
 + " Hidden dialogs " should " appear on new message " in appearHidden 
 + it should " appear on show " in appearShown 
 + 
 + import DialogGroups . _ 
 + 
 + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 + private implicit lazy val service = MessagingServiceImpl ( ) 
 
 def loadGrouped ( ) = { 
 val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) 
 @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec 
 } 
 } 
 } 
 + 
 + def incomingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) 
 + 
 + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = bobClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val dgs = getDialogGroups ( ) 
 + val privates = dgs ( Privates . key ) 
 + privates . size should equal ( 2 ) 
 + privates . head . peer . id should equal ( bob . id ) 
 + privates . last . peer . id should equal ( eve . id ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val privates = getDialogGroups ( Privates ) 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + } 
 + 
 + def outgoingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + val ( eve , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + 
 + prepareDialogs ( bob , eve ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( bob . id ) 
 + } 
 + } 
 + 
 + def appearHidden ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 + 
 + def appearShown ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 } 
 \ No newline at end of file
