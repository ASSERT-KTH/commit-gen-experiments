BLEU SCORE: 0.3672056269893592

TEST MSG: feat ( core ) : Handling key group updates in EncryptedPeerActor
GENERATED MSG: feat ( core ) : Removing keys downloading in session actor

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 3e38d02 . . 5900ce4 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 158 , 6 + 158 , 11 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > < nl > private void doDecrypt ( final EncryptedBox data , final PromiseResolver < DecryptBoxResponse > resolver ) { < nl > < nl > + if ( ! isReady ) { < nl > + stash ( ) ; < nl > + return ; < nl > + } < nl > + < nl > final int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; < nl > final byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; < nl > < nl > @ @ - 217 , 178 + 222 , 15 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > } ) < nl > . pipeTo ( resolver ) < nl > . done ( self ( ) ) ; < nl > + } < nl > < nl > - / / PromisesArray . of ( data . getKeys ( ) ) < nl > - / / / / Searching for compatable key < nl > - / / . filter ( new Predicate < EncryptedBoxKey > ( ) { < nl > - / / @ Override < nl > - / / public boolean apply ( EncryptedBoxKey boxKey ) { < nl > - / / return boxKey . getUid ( ) = = myUid ( ) < nl > - / / & & boxKey . getKeyGroupId ( ) = = ownKeyGroupId < nl > - / / & & " curve25519 " . equals ( boxKey . getKeyAlg ( ) ) ; < nl > - / / } < nl > - / / } ) < nl > - / / . first ( ) < nl > - / / . mapPromise ( new Function < EncryptedBoxKey , Promise < Tuple2 < SessionActor , EncryptedBoxKey > > > ( ) { < nl > - / / @ Override < nl > - / / public Promise < Tuple2 < SessionActor , EncryptedBoxKey > > apply ( final EncryptedBoxKey boxKey ) { < nl > - / / final long senderEphermalKey0Id = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 4 ) ; < nl > - / / final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 12 ) ; < nl > - / / < nl > - / / if ( activeSessions . containsKey ( boxKey . getKeyGroupId ( ) ) ) { < nl > - / / for ( SessionActor s : activeSessions . get ( senderKeyGroup ) . getSessions ( ) ) { < nl > - / / if ( s . getOwnKeyId ( ) = = receiverEphermalKey0Id & & < nl > - / / s . getTheirKeyId ( ) = = senderEphermalKey0Id ) { < nl > - / / return success ( new Tuple2 < > ( s , boxKey ) ) ; < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / return context ( ) . getEncryption ( ) . getSessionManagerInt ( ) < nl > - / / . pickSession ( uid , senderKeyGroup , receiverEphermalKey0Id , senderEphermalKey0Id ) < nl > - / / . map ( new Function < PeerSession , Tuple2 < SessionActor , EncryptedBoxKey > > ( ) { < nl > - / / @ Override < nl > - / / public Tuple2 < SessionActor , EncryptedBoxKey > apply ( PeerSession src ) { < nl > - / / return new Tuple2 < > ( spawnSession ( src . getTheirKeyGroupId ( ) , src . getTheirPreKeyId ( ) , < nl > - / / src . getOwnPreKeyId ( ) ) , boxKey ) ; < nl > - / / } < nl > - / / } ) ; < nl > - / / } < nl > - / / } ) < nl > - / / . mapPromise ( new Function < Tuple2 < SessionActor , EncryptedBoxKey > , Promise < EncryptedSessionActor . DecryptedPackage > > ( ) { < nl > - / / @ Override < nl > - / / public Promise < EncryptedSessionActor . DecryptedPackage > apply ( Tuple2 < SessionActor , EncryptedBoxKey > src ) { < nl > - / / return ask ( src . getT1 ( ) . getActorRef ( ) , new EncryptedSessionActor . DecryptPackage ( src . getT2 ( ) . getEncryptedKey ( ) ) ) ; < nl > - / / } < nl > - / / } ) < nl > - / / . map ( new Function < EncryptedSessionActor . DecryptedPackage , byte [ ] > ( ) { < nl > - / / @ Override < nl > - / / public byte [ ] apply ( EncryptedSessionActor . DecryptedPackage decryptedPackage ) { < nl > - / / byte [ ] encData ; < nl > - / / try { < nl > - / / encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; < nl > - / / < nl > - / / ApiMessage message = ApiMessage . fromBytes ( encData ) ; < nl > - / / < nl > - / / Log . d ( TAG , " Box open : " + message ) ; < nl > - / / } catch ( IOException e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - / / / / future . error ( e ) ; < nl > - / / / / return ; < nl > - / / } < nl > - / / return null ; < nl > - / / } < nl > - / / } ) < nl > - / / . failure ( new Consumer < Exception > ( ) { < nl > - / / @ Override < nl > - / / public void apply ( Exception e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - / / resolver . error ( e ) ; < nl > - / / } < nl > - / / } ) < nl > - / / . done ( self ( ) ) ; < nl > - < nl > - / / Log . d ( TAG , " Picking session " ) ; < nl > - / / SessionId pickedSession = null ; < nl > - / / byte [ ] pickedMessage = null ; < nl > - / / outer : < nl > - / / for ( SessionId s : activeSessions . keySet ( ) ) { < nl > - / / if ( s . getTheirKeyGroupId ( ) ! = senderKeyGroup ) { < nl > - / / continue ; < nl > - / / } < nl > - / / < nl > - / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > - / / if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { < nl > - / / < nl > - / / byte [ ] encKey = k . getEncryptedKey ( ) ; < nl > - / / < nl > - / / / / final int senderKeyGroupId = ByteStrings . bytesToInt ( encKey , 0 ) ; < nl > - / / final long senderEphermalKey0Id = ByteStrings . bytesToLong ( encKey , 4 ) ; < nl > - / / final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( encKey , 12 ) ; < nl > - / / / / final byte [ ] senderEphermalKey = ByteStrings . substring ( encKey , 20 , 32 ) ; < nl > - / / / / final byte [ ] receiverEphermalKey = ByteStrings . substring ( encKey , 52 , 32 ) ; < nl > - / / / / final int messageIndex = ByteStrings . bytesToInt ( encKey , 84 ) ; < nl > - / / < nl > - / / if ( s . getOwnKeyId0 ( ) = = receiverEphermalKey0Id < nl > - / / & & s . getTheirKeyId0 ( ) = = senderEphermalKey0Id < nl > - / / & & s . getOwnKeyGroupId ( ) = = ownKeyGroupId < nl > - / / & & s . getTheirKeyGroupId ( ) = = senderKeyGroup ) { < nl > - / / < nl > - / / pickedSession = s ; < nl > - / / pickedMessage = encKey ; < nl > - / / continue outer ; < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / if ( pickedSession = = null ) { < nl > - / / Log . d ( TAG , " Creation session " ) ; < nl > - / / / / Picking first encryption key for key group for known key group < nl > - / / byte [ ] encKey = null ; < nl > - / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > - / / if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { < nl > - / / encKey = k . getEncryptedKey ( ) ; < nl > - / / break ; < nl > - / / } < nl > - / / } < nl > - / / if ( encKey ! = null ) { < nl > - / / final long senderEphermalKey0Id = ByteStrings . bytesToLong ( encKey , 4 ) ; < nl > - / / final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( encKey , 12 ) ; < nl > - / / < nl > - / / pickedSession = new SessionId ( ownKeyGroupId , receiverEphermalKey0Id , < nl > - / / senderKeyGroup , senderEphermalKey0Id ) ; < nl > - / / < nl > - / / Log . d ( TAG , " Creation of session : " + pickedSession ) ; < nl > - / / < nl > - / / activeSessions . put ( pickedSession , system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { < nl > - / / @ Override < nl > - / / public EncryptedSessionActor create ( ) { < nl > - / / return new EncryptedSessionActor ( context ( ) , uid , receiverEphermalKey0Id , < nl > - / / senderEphermalKey0Id , senderKeyGroup ) ; < nl > - / / } < nl > - / / } ) , getPath ( ) + " / k _ " + senderKeyGroup + " _ " + senderEphermalKey0Id + " _ " + receiverEphermalKey0Id ) ) ; < nl > - / / pickedMessage = encKey ; < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / if ( pickedSession = = null ) { < nl > - / / Log . d ( TAG , " Unable to create session " ) ; < nl > - / / future . error ( new RuntimeException ( " Unable to find approriate session " ) ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / ActorRef session = activeSessions . get ( pickedSession ) ; < nl > - / / < nl > - / / final long start = im . actor . runtime . Runtime . getActorTime ( ) ; < nl > - / / ask ( session , new EncryptedSessionActor . DecryptPackage ( pickedMessage ) , new AskCallback ( ) { < nl > - / / < nl > - / / @ Override < nl > - / / public void onResult ( Object obj ) { < nl > - / / Log . d ( TAG , " Decryption with key group : onResult " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; < nl > - / / EncryptedSessionActor . DecryptedPackage decryptedPackage = ( EncryptedSessionActor . DecryptedPackage ) obj ; < nl > - / / < nl > - / / byte [ ] encData ; < nl > - / / try { < nl > - / / encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; < nl > - / / < nl > - / / ApiMessage message = ApiMessage . fromBytes ( encData ) ; < nl > - / / < nl > - / / Log . d ( TAG , " Box open : " + message ) ; < nl > - / / } catch ( IOException e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - / / future . error ( e ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / future . result ( null ) ; < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( Exception e ) { < nl > - / / Log . d ( TAG , " Decryption with key group : onError " ) ; < nl > - / / future . error ( e ) ; < nl > - / / } < nl > - / / } ) ; < nl > + private void onKeysUpdated ( UserKeys userKeys ) { < nl > + if ( ! isReady ) { < nl > + stash ( ) ; < nl > + return ; < nl > + } < nl > + < nl > + this . theirKeys = userKeys ; < nl > } < nl > < nl > private SessionActor spawnSession ( final PeerSession session ) { < nl > @ @ - 444 , 6 + 286 , 15 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > } < nl > } < nl > < nl > + @ Override < nl > + public void onReceive ( Object message ) { < nl > + if ( message instanceof KeyGroupUpdated ) { < nl > + onKeysUpdated ( ( ( KeyGroupUpdated ) message ) . getUserKeys ( ) ) ; < nl > + } else { < nl > + super . onReceive ( message ) ; < nl > + } < nl > + } < nl > + < nl > public static class EncryptBox extends AskMessage < EncryptBoxResponse > { < nl > private byte [ ] data ; < nl > < nl > @ @ - 532 , 4 + 383 , 17 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > return session ; < nl > } < nl > } < nl > + < nl > + public static class KeyGroupUpdated { < nl > + < nl > + private UserKeys userKeys ; < nl > + < nl > + public KeyGroupUpdated ( UserKeys userKeys ) { < nl > + this . userKeys = userKeys ; < nl > + } < nl > + < nl > + public UserKeys getUserKeys ( ) { < nl > + return userKeys ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index ef4e7ab . . 0c54c39 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 477 , 7 + 477 , 10 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > UserKeysGroup validatedKeysGroup = validateUserKeysGroup ( uid , keyGroup ) ; < nl > if ( validatedKeysGroup ! = null ) { < nl > - cacheUserKeys ( userKeys . addUserKeyGroup ( validatedKeysGroup ) ) ; < nl > + UserKeys updatedUserKeys = userKeys . addUserKeyGroup ( validatedKeysGroup ) ; < nl > + cacheUserKeys ( updatedUserKeys ) ; < nl > + context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) < nl > + . send ( new EncryptedPeerActor . KeyGroupUpdated ( userKeys ) ) ; < nl > } < nl > } < nl > < nl > @ @ - 492 , 7 + 495 , 11 @ @ public class KeyManagerActor extends ModuleActor { < nl > if ( userKeys = = null ) { < nl > return ; < nl > } < nl > - cacheUserKeys ( userKeys . removeUserKeyGroup ( keyGroupId ) ) ; < nl > + < nl > + UserKeys updatedUserKeys = userKeys . removeUserKeyGroup ( keyGroupId ) ; < nl > + cacheUserKeys ( updatedUserKeys ) ; < nl > + context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) < nl > + . send ( new EncryptedPeerActor . KeyGroupUpdated ( userKeys ) ) ; < nl > } < nl > < nl > / /
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist < nl > index db3802c . . defe98b 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 < nl > + + + b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 < nl > @ @ - 34 , 7 + 34 , 7 @ @ < nl > 	 	 < / dict > < nl > 	 < / array > < nl > 	 < key > CFBundleVersion < / key > < nl > - 	 < string > 747 < / string > < nl > + 	 < string > 751 < / string > < nl > 	 < key > Fabric < / key > < nl > 	 < dict > < nl > 	 	 < key > APIKey < / key > < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index c0000b0 . . 22e85b2 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 1 , 8 + 1 , 10 @ @ < nl > package im . actor . core . modules . encryption ; < nl > < nl > + import java . io . IOException ; < nl > import java . util . ArrayList ; < nl > import java . util . HashMap ; < nl > < nl > + import im . actor . core . api . ApiMessage ; < nl > import im . actor . core . entity . encryption . PeerSession ; < nl > import im . actor . core . modules . ModuleContext ; < nl > import im . actor . core . modules . encryption . entity . EncryptedBox ; < nl > @ @ - 21 , 6 + 23 , 7 @ @ import im . actor . runtime . actors . ask . AskResult ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . function . Consumer ; < nl > import im . actor . runtime . function . Function ; < nl > + import im . actor . runtime . function . Predicate ; < nl > import im . actor . runtime . function . Predicates ; < nl > import im . actor . runtime . promise . Promise ; < nl > import im . actor . runtime . promise . PromiseResolver ; < nl > @ @ - 118 , 12 + 121 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > . log ( TAG + " : session # " + keysGroup . getKeyGroupId ( ) ) ; < nl > } < nl > } ) < nl > - . mapOptional ( new Function < SessionActor , Promise < EncryptedSessionActor . EncryptedPackageRes > > ( ) { < nl > - @ Override < nl > - public Promise < EncryptedSessionActor . EncryptedPackageRes > apply ( SessionActor sessionActor ) { < nl > - return ask ( sessionActor . getActorRef ( ) , new EncryptedSessionActor . EncryptPackage ( encKey ) ) ; < nl > - } < nl > - } ) < nl > + . mapOptional ( encrypt ( encKey ) ) < nl > . zip ( ) < nl > . map ( new Function < EncryptedSessionActor . EncryptedPackageRes [ ] , EncryptBoxResponse > ( ) { < nl > @ Override < nl > @ @ - 169 , 6 + 167 , 59 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > / / Picking session < nl > / / < nl > < nl > + PromisesArray . of ( data . getKeys ( ) ) < nl > + . filter ( EncryptedBoxKey . FILTER ( myUid ( ) , ownKeyGroupId ) ) < nl > + . first ( ) < nl > + . mapPromise ( new Function < EncryptedBoxKey , Promise < Tuple2 < SessionActor , EncryptedBoxKey > > > ( ) { < nl > + @ Override < nl > + public Promise < Tuple2 < SessionActor , EncryptedBoxKey > > apply ( final EncryptedBoxKey boxKey ) { < nl > + final long senderPreKeyId = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 4 ) ; < nl > + final long receiverPreKeyId = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 12 ) ; < nl > + < nl > + if ( activeSessions . containsKey ( boxKey . getKeyGroupId ( ) ) ) { < nl > + for ( SessionActor s : activeSessions . get ( senderKeyGroup ) . getSessions ( ) ) { < nl > + if ( s . getSession ( ) . getOwnPreKeyId ( ) = = receiverPreKeyId & & < nl > + s . getSession ( ) . getTheirPreKeyId ( ) = = senderPreKeyId ) { < nl > + return success ( new Tuple2 < > ( s , boxKey ) ) ; < nl > + } < nl > + } < nl > + } < nl > + return context ( ) . getEncryption ( ) . getSessionManagerInt ( ) < nl > + . pickSession ( uid , senderKeyGroup , receiverPreKeyId , senderPreKeyId ) < nl > + . map ( new Function < PeerSession , Tuple2 < SessionActor , EncryptedBoxKey > > ( ) { < nl > + @ Override < nl > + public Tuple2 < SessionActor , EncryptedBoxKey > apply ( PeerSession src ) { < nl > + return new Tuple2 < > ( spawnSession ( src ) , boxKey ) ; < nl > + } < nl > + } ) ; < nl > + } < nl > + } ) < nl > + . mapPromise ( new Function < Tuple2 < SessionActor , EncryptedBoxKey > , Promise < EncryptedSessionActor . DecryptedPackage > > ( ) { < nl > + @ Override < nl > + public Promise < EncryptedSessionActor . DecryptedPackage > apply ( Tuple2 < SessionActor , EncryptedBoxKey > src ) { < nl > + return ask ( src . getT1 ( ) . getActorRef ( ) , new EncryptedSessionActor . DecryptPackage ( src . getT2 ( ) . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + } ) < nl > + . map ( new Function < EncryptedSessionActor . DecryptedPackage , DecryptBoxResponse > ( ) { < nl > + @ Override < nl > + public DecryptBoxResponse apply ( EncryptedSessionActor . DecryptedPackage decryptedPackage ) { < nl > + byte [ ] encData ; < nl > + try { < nl > + encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; < nl > + < nl > + ApiMessage message = ApiMessage . fromBytes ( encData ) ; < nl > + < nl > + Log . d ( TAG , " Box open : " + message ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + throw new RuntimeException ( e ) ; < nl > + } < nl > + return new DecryptBoxResponse ( encData ) ; < nl > + } < nl > + } ) < nl > + . pipeTo ( resolver ) < nl > + . done ( self ( ) ) ; < nl > + < nl > / / PromisesArray . of ( data . getKeys ( ) ) < nl > / / / / Searching for compatable key < nl > / / . filter ( new Predicate < EncryptedBoxKey > ( ) { < nl > @ @ - 363 , 6 + 414 , 15 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > return cont ; < nl > } < nl > < nl > + private Function < SessionActor , Promise < EncryptedSessionActor . EncryptedPackageRes > > encrypt ( final byte [ ] encKey ) { < nl > + return new Function < SessionActor , Promise < EncryptedSessionActor . EncryptedPackageRes > > ( ) { < nl > + @ Override < nl > + public Promise < EncryptedSessionActor . EncryptedPackageRes > apply ( SessionActor sessionActor ) { < nl > + return ask ( sessionActor . getActorRef ( ) , new EncryptedSessionActor . EncryptPackage ( encKey ) ) ; < nl > + } < nl > + } ; < nl > + } < nl > + < nl > / / < nl > / / Messages < nl > / / < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index 2b1e7f9 . . e59fe50 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 54 , 9 + 54 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > / / < nl > < nl > private final int uid ; < nl > - private final long ownKey0 ; < nl > - private final long theirKey0 ; < nl > - private final int theirKeyGroup ; < nl > + private final PeerSession session ; < nl > < nl > / / < nl > / / Key Manager reference < nl > @ @ - 65 , 13 + 63 , 6 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > private KeyManagerInt keyManager ; < nl > < nl > / / < nl > - / / Loaded Session < nl > - / / < nl > - < nl > - private EncryptedSession session ; < nl > - private boolean isUnavailable = false ; < nl > - < nl > - / / < nl > / / Temp encryption chains < nl > / / < nl > < nl > @ @ - 87 , 89 + 78 , 25 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > super ( context ) ; < nl > this . TAG = " EncryptionSessionActor # " + session . getUid ( ) + " _ " + session . getTheirKeyGroupId ( ) ; < nl > this . uid = session . getUid ( ) ; < nl > - this . ownKey0 = session . getOwnPreKeyId ( ) ; < nl > - this . theirKey0 = session . getTheirPreKeyId ( ) ; < nl > - this . theirKeyGroup = session . getTheirKeyGroupId ( ) ; < nl > + this . session = session ; < nl > } < nl > < nl > @ Override < nl > public void preStart ( ) { < nl > - this . keyManager = context ( ) . getEncryption ( ) . getKeyManagerInt ( ) ; < nl > - < nl > - ActorRef keyManager = context ( ) . getEncryption ( ) . getKeyManager ( ) ; < nl > - Log . d ( TAG , " preStart " ) ; < nl > - < nl > - Promises . tuple ( < nl > - ask ( keyManager , new FetchOwnKey ( ) ) , < nl > - ask ( keyManager , new FetchOwnPreKeyById ( ownKey0 ) ) , < nl > - ask ( keyManager , new FetchUserPreKey ( uid , theirKeyGroup , theirKey0 ) ) , < nl > - ask ( keyManager , new FetchUserKeys ( uid ) ) ) < nl > - . map ( new Function < Tuple4 < OwnIdentity , PrivateKey , PublicKey , UserKeys > , EncryptedSession > ( ) { < nl > - @ Override < nl > - public EncryptedSession apply ( Tuple4 < OwnIdentity , PrivateKey , PublicKey , UserKeys > res ) { < nl > - PrivateKey ownIdentityKey = res . getT1 ( ) . getIdentityKey ( ) ; < nl > - PrivateKey ownPreKey = res . getT2 ( ) ; < nl > - PublicKey theirPreKey = res . getT3 ( ) ; < nl > - UserKeys keyGroups = res . getT4 ( ) ; < nl > - UserKeysGroup keysGroup = null ; < nl > - for ( UserKeysGroup g : keyGroups . getUserKeysGroups ( ) ) { < nl > - if ( g . getKeyGroupId ( ) = = theirKeyGroup ) { < nl > - keysGroup = g ; < nl > - break ; < nl > - } < nl > - } < nl > - if ( keysGroup = = null ) { < nl > - Log . w ( TAG , " Their key group not found " ) ; < nl > - throw new RuntimeException ( " Their key group not found " ) ; < nl > - } < nl > - PublicKey theirIdentityKey = keysGroup . getIdentityKey ( ) ; < nl > - < nl > - return new EncryptedSession ( ownIdentityKey , ownPreKey , theirIdentityKey , theirPreKey , theirKeyGroup ) ; < nl > - } < nl > - } ) < nl > - . then ( new Consumer < EncryptedSession > ( ) { < nl > - @ Override < nl > - public void apply ( EncryptedSession encryptedSession ) { < nl > - Log . d ( TAG , " Loaded " ) ; < nl > - EncryptedSessionActor . this . session = encryptedSession ; < nl > - unstashAll ( ) ; < nl > - } < nl > - } ) < nl > - . failure ( new Consumer < Exception > ( ) { < nl > - @ Override < nl > - public void apply ( Exception e ) { < nl > - Log . w ( TAG , " Session load error " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - isUnavailable = true ; < nl > - unstashAll ( ) ; < nl > - } < nl > - } ) < nl > - . done ( self ( ) ) ; < nl > + super . preStart ( ) ; < nl > + keyManager = context ( ) . getEncryption ( ) . getKeyManagerInt ( ) ; < nl > } < nl > < nl > private void onEncrypt ( final byte [ ] data , final PromiseResolver < EncryptedPackageRes > future ) { < nl > < nl > / / < nl > - / / If not ready : stash encryption request < nl > - / / < nl > - < nl > - if ( session = = null ) { < nl > - if ( isUnavailable ) { < nl > - future . error ( new RuntimeException ( " Session is not available " ) ) ; < nl > - } else { < nl > - stash ( ) ; < nl > - } < nl > - return ; < nl > - } < nl > - < nl > - / / < nl > / / Stage 1 : Pick Their Ephemeral key . Use already received or pick random pre key . < nl > / / Stage 2 : Pick Encryption Chain < nl > / / Stage 3 : Decrypt < nl > / / < nl > < nl > Promises . success ( latestTheirEphemeralKey ) < nl > - . mapIfNullPromise ( keyManager . supplyUserPreKey ( uid , theirKeyGroup ) ) < nl > + . mapIfNullPromise ( keyManager . supplyUserPreKey ( uid , session . getTheirKeyGroupId ( ) ) ) < nl > . map ( new Function < byte [ ] , EncryptedSessionChain > ( ) { < nl > @ Override < nl > public EncryptedSessionChain apply ( byte [ ] publicKey ) { < nl > @ @ - 189 , 19 + 116 , 6 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > private void onDecrypt ( final byte [ ] data , final PromiseResolver < DecryptedPackage > future ) { < nl > < nl > / / < nl > - / / If not ready : stash decryption request < nl > - / / < nl > - < nl > - if ( session = = null ) { < nl > - if ( isUnavailable ) { < nl > - future . error ( new RuntimeException ( " Session is not available " ) ) ; < nl > - } else { < nl > - stash ( ) ; < nl > - } < nl > - return ; < nl > - } < nl > - < nl > - / / < nl > / / Stage 1 : Parsing message header < nl > / / Stage 2 : Picking decryption chain < nl > / / Stage 3 : Decryption of message < nl > @ @ - 257 , 7 + 171 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > e . printStackTrace ( ) ; < nl > throw new RuntimeException ( e ) ; < nl > } < nl > - return new EncryptedPackageRes ( encrypted , theirKeyGroup ) ; < nl > + return new EncryptedPackageRes ( encrypted , session . getTheirKeyGroupId ( ) ) ; < nl > } < nl > < nl > private Promise < EncryptedSessionChain > pickDecryptChain ( final byte [ ] theirEphemeralKey , final byte [ ] ephemeralKey ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / SessionManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / SessionManagerActor . java < nl > index e28582c . . 633e2c8 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / SessionManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / SessionManagerActor . java < nl > @ @ - 153 , 7 + 153 , 8 @ @ public class SessionManagerActor extends ModuleActor { < nl > } ) ; < nl > } < nl > } ) < nl > - . pipeTo ( srcResolver ) ; < nl > + . pipeTo ( srcResolver ) < nl > + . done ( self ( ) ) ; < nl > } < nl > < nl > private PeerSession spawnSession ( int uid , < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / EncryptedBoxKey . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / EncryptedBoxKey . java < nl > index c0325ed . . 6e1fdf1 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / EncryptedBoxKey . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / EncryptedBoxKey . java < nl > @ @ - 1 , 7 + 1 , 18 @ @ < nl > package im . actor . core . modules . encryption . entity ; < nl > < nl > + import im . actor . runtime . function . Predicate ; < nl > + < nl > public class EncryptedBoxKey { < nl > < nl > + public static Predicate < EncryptedBoxKey > FILTER ( final int myUid , final int keyGroupId ) { < nl > + return new Predicate < EncryptedBoxKey > ( ) { < nl > + @ Override < nl > + public boolean apply ( EncryptedBoxKey boxKey ) { < nl > + return boxKey . getUid ( ) = = myUid & & boxKey . getKeyGroupId ( ) = = keyGroupId ; < nl > + } < nl > + } ; < nl > + } < nl > + < nl > private final int uid ; < nl > private final int keyGroupId ; < nl > private final byte [ ] encryptedKey ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > index 6f38004 . . c32e6e0 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . core . modules . encryption . session ; < nl > import java . util . HashSet ; < nl > import java . util . Random ; < nl > < nl > + import im . actor . core . entity . encryption . PeerSession ; < nl > import im . actor . core . util . RandomUtils ; < nl > import im . actor . runtime . Crypto ; < nl > import im . actor . runtime . Log ; < nl > @ @ - 18 , 14 + 19 , 14 @ @ import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; < nl > < nl > public class EncryptedSessionChain { < nl > < nl > - private EncryptedSession session ; < nl > + private PeerSession session ; < nl > private byte [ ] ownPrivateKey ; < nl > private byte [ ] theirPublicKey ; < nl > private HashSet < Integer > receivedCounters ; < nl > private int sentCounter ; < nl > private byte [ ] rootChainKey ; < nl > < nl > - public EncryptedSessionChain ( EncryptedSession session , byte [ ] ownPrivateKey , byte [ ] theirPublicKey ) { < nl > + public EncryptedSessionChain ( PeerSession session , byte [ ] ownPrivateKey , byte [ ] theirPublicKey ) { < nl > this . session = session ; < nl > this . ownPrivateKey = ownPrivateKey ; < nl > this . theirPublicKey = theirPublicKey ; < nl > @ @ - 37 , 7 + 38 , 7 @ @ public class EncryptedSessionChain { < nl > session . getMasterKey ( ) ) ; < nl > } < nl > < nl > - public EncryptedSession getSession ( ) { < nl > + public PeerSession getSession ( ) { < nl > return session ; < nl > } < nl > < nl > @ @ - 101 , 15 + 102 , 15 @ @ public class EncryptedSessionChain { < nl > ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; < nl > < nl > byte [ ] header = ByteStrings . merge ( < nl > - ByteStrings . intToBytes ( session . getPeerKeyGroupId ( ) ) , < nl > - ByteStrings . longToBytes ( session . getOwnPreKey ( ) . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > - ByteStrings . longToBytes ( session . getTheirPreKey ( ) . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > + ByteStrings . intToBytes ( session . getOwnKeyGroupId ( ) ) , < nl > + ByteStrings . longToBytes ( session . getOwnPreKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > + ByteStrings . longToBytes ( session . getTheirPreKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > Curve25519 . keyGenPublic ( ownPrivateKey ) , < nl > theirPublicKey , < nl > ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / < nl > < nl > - Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Own ephemeral Key : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( ownPrivateKey ) ) ) ; < nl > - Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Their ephemeral Key : " + Crypto . keyHash ( theirPublicKey ) ) ; < nl > + / / Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Own ephemeral Key : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( ownPrivateKey ) ) ) ; < nl > + / / Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Their ephemeral Key : " + Crypto . keyHash ( theirPublicKey ) ) ; < nl > < nl > return ByteStrings . merge ( header , ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ) ; < nl > }

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 3e38d02 . . 5900ce4 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 158 , 6 + 158 , 11 @ @ public class EncryptedPeerActor extends ModuleActor { 
 
 private void doDecrypt ( final EncryptedBox data , final PromiseResolver < DecryptBoxResponse > resolver ) { 
 
 + if ( ! isReady ) { 
 + stash ( ) ; 
 + return ; 
 + } 
 + 
 final int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; 
 final byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; 
 
 @ @ - 217 , 178 + 222 , 15 @ @ public class EncryptedPeerActor extends ModuleActor { 
 } ) 
 . pipeTo ( resolver ) 
 . done ( self ( ) ) ; 
 + } 
 
 - / / PromisesArray . of ( data . getKeys ( ) ) 
 - / / / / Searching for compatable key 
 - / / . filter ( new Predicate < EncryptedBoxKey > ( ) { 
 - / / @ Override 
 - / / public boolean apply ( EncryptedBoxKey boxKey ) { 
 - / / return boxKey . getUid ( ) = = myUid ( ) 
 - / / & & boxKey . getKeyGroupId ( ) = = ownKeyGroupId 
 - / / & & " curve25519 " . equals ( boxKey . getKeyAlg ( ) ) ; 
 - / / } 
 - / / } ) 
 - / / . first ( ) 
 - / / . mapPromise ( new Function < EncryptedBoxKey , Promise < Tuple2 < SessionActor , EncryptedBoxKey > > > ( ) { 
 - / / @ Override 
 - / / public Promise < Tuple2 < SessionActor , EncryptedBoxKey > > apply ( final EncryptedBoxKey boxKey ) { 
 - / / final long senderEphermalKey0Id = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 4 ) ; 
 - / / final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 12 ) ; 
 - / / 
 - / / if ( activeSessions . containsKey ( boxKey . getKeyGroupId ( ) ) ) { 
 - / / for ( SessionActor s : activeSessions . get ( senderKeyGroup ) . getSessions ( ) ) { 
 - / / if ( s . getOwnKeyId ( ) = = receiverEphermalKey0Id & & 
 - / / s . getTheirKeyId ( ) = = senderEphermalKey0Id ) { 
 - / / return success ( new Tuple2 < > ( s , boxKey ) ) ; 
 - / / } 
 - / / } 
 - / / } 
 - / / return context ( ) . getEncryption ( ) . getSessionManagerInt ( ) 
 - / / . pickSession ( uid , senderKeyGroup , receiverEphermalKey0Id , senderEphermalKey0Id ) 
 - / / . map ( new Function < PeerSession , Tuple2 < SessionActor , EncryptedBoxKey > > ( ) { 
 - / / @ Override 
 - / / public Tuple2 < SessionActor , EncryptedBoxKey > apply ( PeerSession src ) { 
 - / / return new Tuple2 < > ( spawnSession ( src . getTheirKeyGroupId ( ) , src . getTheirPreKeyId ( ) , 
 - / / src . getOwnPreKeyId ( ) ) , boxKey ) ; 
 - / / } 
 - / / } ) ; 
 - / / } 
 - / / } ) 
 - / / . mapPromise ( new Function < Tuple2 < SessionActor , EncryptedBoxKey > , Promise < EncryptedSessionActor . DecryptedPackage > > ( ) { 
 - / / @ Override 
 - / / public Promise < EncryptedSessionActor . DecryptedPackage > apply ( Tuple2 < SessionActor , EncryptedBoxKey > src ) { 
 - / / return ask ( src . getT1 ( ) . getActorRef ( ) , new EncryptedSessionActor . DecryptPackage ( src . getT2 ( ) . getEncryptedKey ( ) ) ) ; 
 - / / } 
 - / / } ) 
 - / / . map ( new Function < EncryptedSessionActor . DecryptedPackage , byte [ ] > ( ) { 
 - / / @ Override 
 - / / public byte [ ] apply ( EncryptedSessionActor . DecryptedPackage decryptedPackage ) { 
 - / / byte [ ] encData ; 
 - / / try { 
 - / / encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; 
 - / / 
 - / / ApiMessage message = ApiMessage . fromBytes ( encData ) ; 
 - / / 
 - / / Log . d ( TAG , " Box open : " + message ) ; 
 - / / } catch ( IOException e ) { 
 - / / e . printStackTrace ( ) ; 
 - / / / / future . error ( e ) ; 
 - / / / / return ; 
 - / / } 
 - / / return null ; 
 - / / } 
 - / / } ) 
 - / / . failure ( new Consumer < Exception > ( ) { 
 - / / @ Override 
 - / / public void apply ( Exception e ) { 
 - / / e . printStackTrace ( ) ; 
 - / / resolver . error ( e ) ; 
 - / / } 
 - / / } ) 
 - / / . done ( self ( ) ) ; 
 - 
 - / / Log . d ( TAG , " Picking session " ) ; 
 - / / SessionId pickedSession = null ; 
 - / / byte [ ] pickedMessage = null ; 
 - / / outer : 
 - / / for ( SessionId s : activeSessions . keySet ( ) ) { 
 - / / if ( s . getTheirKeyGroupId ( ) ! = senderKeyGroup ) { 
 - / / continue ; 
 - / / } 
 - / / 
 - / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 - / / if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { 
 - / / 
 - / / byte [ ] encKey = k . getEncryptedKey ( ) ; 
 - / / 
 - / / / / final int senderKeyGroupId = ByteStrings . bytesToInt ( encKey , 0 ) ; 
 - / / final long senderEphermalKey0Id = ByteStrings . bytesToLong ( encKey , 4 ) ; 
 - / / final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( encKey , 12 ) ; 
 - / / / / final byte [ ] senderEphermalKey = ByteStrings . substring ( encKey , 20 , 32 ) ; 
 - / / / / final byte [ ] receiverEphermalKey = ByteStrings . substring ( encKey , 52 , 32 ) ; 
 - / / / / final int messageIndex = ByteStrings . bytesToInt ( encKey , 84 ) ; 
 - / / 
 - / / if ( s . getOwnKeyId0 ( ) = = receiverEphermalKey0Id 
 - / / & & s . getTheirKeyId0 ( ) = = senderEphermalKey0Id 
 - / / & & s . getOwnKeyGroupId ( ) = = ownKeyGroupId 
 - / / & & s . getTheirKeyGroupId ( ) = = senderKeyGroup ) { 
 - / / 
 - / / pickedSession = s ; 
 - / / pickedMessage = encKey ; 
 - / / continue outer ; 
 - / / } 
 - / / } 
 - / / } 
 - / / } 
 - / / 
 - / / if ( pickedSession = = null ) { 
 - / / Log . d ( TAG , " Creation session " ) ; 
 - / / / / Picking first encryption key for key group for known key group 
 - / / byte [ ] encKey = null ; 
 - / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 - / / if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { 
 - / / encKey = k . getEncryptedKey ( ) ; 
 - / / break ; 
 - / / } 
 - / / } 
 - / / if ( encKey ! = null ) { 
 - / / final long senderEphermalKey0Id = ByteStrings . bytesToLong ( encKey , 4 ) ; 
 - / / final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( encKey , 12 ) ; 
 - / / 
 - / / pickedSession = new SessionId ( ownKeyGroupId , receiverEphermalKey0Id , 
 - / / senderKeyGroup , senderEphermalKey0Id ) ; 
 - / / 
 - / / Log . d ( TAG , " Creation of session : " + pickedSession ) ; 
 - / / 
 - / / activeSessions . put ( pickedSession , system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { 
 - / / @ Override 
 - / / public EncryptedSessionActor create ( ) { 
 - / / return new EncryptedSessionActor ( context ( ) , uid , receiverEphermalKey0Id , 
 - / / senderEphermalKey0Id , senderKeyGroup ) ; 
 - / / } 
 - / / } ) , getPath ( ) + " / k _ " + senderKeyGroup + " _ " + senderEphermalKey0Id + " _ " + receiverEphermalKey0Id ) ) ; 
 - / / pickedMessage = encKey ; 
 - / / } 
 - / / } 
 - / / 
 - / / if ( pickedSession = = null ) { 
 - / / Log . d ( TAG , " Unable to create session " ) ; 
 - / / future . error ( new RuntimeException ( " Unable to find approriate session " ) ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / ActorRef session = activeSessions . get ( pickedSession ) ; 
 - / / 
 - / / final long start = im . actor . runtime . Runtime . getActorTime ( ) ; 
 - / / ask ( session , new EncryptedSessionActor . DecryptPackage ( pickedMessage ) , new AskCallback ( ) { 
 - / / 
 - / / @ Override 
 - / / public void onResult ( Object obj ) { 
 - / / Log . d ( TAG , " Decryption with key group : onResult " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; 
 - / / EncryptedSessionActor . DecryptedPackage decryptedPackage = ( EncryptedSessionActor . DecryptedPackage ) obj ; 
 - / / 
 - / / byte [ ] encData ; 
 - / / try { 
 - / / encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; 
 - / / 
 - / / ApiMessage message = ApiMessage . fromBytes ( encData ) ; 
 - / / 
 - / / Log . d ( TAG , " Box open : " + message ) ; 
 - / / } catch ( IOException e ) { 
 - / / e . printStackTrace ( ) ; 
 - / / future . error ( e ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / future . result ( null ) ; 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( Exception e ) { 
 - / / Log . d ( TAG , " Decryption with key group : onError " ) ; 
 - / / future . error ( e ) ; 
 - / / } 
 - / / } ) ; 
 + private void onKeysUpdated ( UserKeys userKeys ) { 
 + if ( ! isReady ) { 
 + stash ( ) ; 
 + return ; 
 + } 
 + 
 + this . theirKeys = userKeys ; 
 } 
 
 private SessionActor spawnSession ( final PeerSession session ) { 
 @ @ - 444 , 6 + 286 , 15 @ @ public class EncryptedPeerActor extends ModuleActor { 
 } 
 } 
 
 + @ Override 
 + public void onReceive ( Object message ) { 
 + if ( message instanceof KeyGroupUpdated ) { 
 + onKeysUpdated ( ( ( KeyGroupUpdated ) message ) . getUserKeys ( ) ) ; 
 + } else { 
 + super . onReceive ( message ) ; 
 + } 
 + } 
 + 
 public static class EncryptBox extends AskMessage < EncryptBoxResponse > { 
 private byte [ ] data ; 
 
 @ @ - 532 , 4 + 383 , 17 @ @ public class EncryptedPeerActor extends ModuleActor { 
 return session ; 
 } 
 } 
 + 
 + public static class KeyGroupUpdated { 
 + 
 + private UserKeys userKeys ; 
 + 
 + public KeyGroupUpdated ( UserKeys userKeys ) { 
 + this . userKeys = userKeys ; 
 + } 
 + 
 + public UserKeys getUserKeys ( ) { 
 + return userKeys ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index ef4e7ab . . 0c54c39 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 477 , 7 + 477 , 10 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 UserKeysGroup validatedKeysGroup = validateUserKeysGroup ( uid , keyGroup ) ; 
 if ( validatedKeysGroup ! = null ) { 
 - cacheUserKeys ( userKeys . addUserKeyGroup ( validatedKeysGroup ) ) ; 
 + UserKeys updatedUserKeys = userKeys . addUserKeyGroup ( validatedKeysGroup ) ; 
 + cacheUserKeys ( updatedUserKeys ) ; 
 + context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) 
 + . send ( new EncryptedPeerActor . KeyGroupUpdated ( userKeys ) ) ; 
 } 
 } 
 
 @ @ - 492 , 7 + 495 , 11 @ @ public class KeyManagerActor extends ModuleActor { 
 if ( userKeys = = null ) { 
 return ; 
 } 
 - cacheUserKeys ( userKeys . removeUserKeyGroup ( keyGroupId ) ) ; 
 + 
 + UserKeys updatedUserKeys = userKeys . removeUserKeyGroup ( keyGroupId ) ; 
 + cacheUserKeys ( updatedUserKeys ) ; 
 + context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) 
 + . send ( new EncryptedPeerActor . KeyGroupUpdated ( userKeys ) ) ; 
 } 
 
 / /

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 
 index db3802c . . defe98b 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 
 + + + b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 
 @ @ - 34 , 7 + 34 , 7 @ @ 
 	 	 < / dict > 
 	 < / array > 
 	 < key > CFBundleVersion < / key > 
 - 	 < string > 747 < / string > 
 + 	 < string > 751 < / string > 
 	 < key > Fabric < / key > 
 	 < dict > 
 	 	 < key > APIKey < / key > 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index c0000b0 . . 22e85b2 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 1 , 8 + 1 , 10 @ @ 
 package im . actor . core . modules . encryption ; 
 
 + import java . io . IOException ; 
 import java . util . ArrayList ; 
 import java . util . HashMap ; 
 
 + import im . actor . core . api . ApiMessage ; 
 import im . actor . core . entity . encryption . PeerSession ; 
 import im . actor . core . modules . ModuleContext ; 
 import im . actor . core . modules . encryption . entity . EncryptedBox ; 
 @ @ - 21 , 6 + 23 , 7 @ @ import im . actor . runtime . actors . ask . AskResult ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . function . Consumer ; 
 import im . actor . runtime . function . Function ; 
 + import im . actor . runtime . function . Predicate ; 
 import im . actor . runtime . function . Predicates ; 
 import im . actor . runtime . promise . Promise ; 
 import im . actor . runtime . promise . PromiseResolver ; 
 @ @ - 118 , 12 + 121 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { 
 . log ( TAG + " : session # " + keysGroup . getKeyGroupId ( ) ) ; 
 } 
 } ) 
 - . mapOptional ( new Function < SessionActor , Promise < EncryptedSessionActor . EncryptedPackageRes > > ( ) { 
 - @ Override 
 - public Promise < EncryptedSessionActor . EncryptedPackageRes > apply ( SessionActor sessionActor ) { 
 - return ask ( sessionActor . getActorRef ( ) , new EncryptedSessionActor . EncryptPackage ( encKey ) ) ; 
 - } 
 - } ) 
 + . mapOptional ( encrypt ( encKey ) ) 
 . zip ( ) 
 . map ( new Function < EncryptedSessionActor . EncryptedPackageRes [ ] , EncryptBoxResponse > ( ) { 
 @ Override 
 @ @ - 169 , 6 + 167 , 59 @ @ public class EncryptedPeerActor extends ModuleActor { 
 / / Picking session 
 / / 
 
 + PromisesArray . of ( data . getKeys ( ) ) 
 + . filter ( EncryptedBoxKey . FILTER ( myUid ( ) , ownKeyGroupId ) ) 
 + . first ( ) 
 + . mapPromise ( new Function < EncryptedBoxKey , Promise < Tuple2 < SessionActor , EncryptedBoxKey > > > ( ) { 
 + @ Override 
 + public Promise < Tuple2 < SessionActor , EncryptedBoxKey > > apply ( final EncryptedBoxKey boxKey ) { 
 + final long senderPreKeyId = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 4 ) ; 
 + final long receiverPreKeyId = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 12 ) ; 
 + 
 + if ( activeSessions . containsKey ( boxKey . getKeyGroupId ( ) ) ) { 
 + for ( SessionActor s : activeSessions . get ( senderKeyGroup ) . getSessions ( ) ) { 
 + if ( s . getSession ( ) . getOwnPreKeyId ( ) = = receiverPreKeyId & & 
 + s . getSession ( ) . getTheirPreKeyId ( ) = = senderPreKeyId ) { 
 + return success ( new Tuple2 < > ( s , boxKey ) ) ; 
 + } 
 + } 
 + } 
 + return context ( ) . getEncryption ( ) . getSessionManagerInt ( ) 
 + . pickSession ( uid , senderKeyGroup , receiverPreKeyId , senderPreKeyId ) 
 + . map ( new Function < PeerSession , Tuple2 < SessionActor , EncryptedBoxKey > > ( ) { 
 + @ Override 
 + public Tuple2 < SessionActor , EncryptedBoxKey > apply ( PeerSession src ) { 
 + return new Tuple2 < > ( spawnSession ( src ) , boxKey ) ; 
 + } 
 + } ) ; 
 + } 
 + } ) 
 + . mapPromise ( new Function < Tuple2 < SessionActor , EncryptedBoxKey > , Promise < EncryptedSessionActor . DecryptedPackage > > ( ) { 
 + @ Override 
 + public Promise < EncryptedSessionActor . DecryptedPackage > apply ( Tuple2 < SessionActor , EncryptedBoxKey > src ) { 
 + return ask ( src . getT1 ( ) . getActorRef ( ) , new EncryptedSessionActor . DecryptPackage ( src . getT2 ( ) . getEncryptedKey ( ) ) ) ; 
 + } 
 + } ) 
 + . map ( new Function < EncryptedSessionActor . DecryptedPackage , DecryptBoxResponse > ( ) { 
 + @ Override 
 + public DecryptBoxResponse apply ( EncryptedSessionActor . DecryptedPackage decryptedPackage ) { 
 + byte [ ] encData ; 
 + try { 
 + encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; 
 + 
 + ApiMessage message = ApiMessage . fromBytes ( encData ) ; 
 + 
 + Log . d ( TAG , " Box open : " + message ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + throw new RuntimeException ( e ) ; 
 + } 
 + return new DecryptBoxResponse ( encData ) ; 
 + } 
 + } ) 
 + . pipeTo ( resolver ) 
 + . done ( self ( ) ) ; 
 + 
 / / PromisesArray . of ( data . getKeys ( ) ) 
 / / / / Searching for compatable key 
 / / . filter ( new Predicate < EncryptedBoxKey > ( ) { 
 @ @ - 363 , 6 + 414 , 15 @ @ public class EncryptedPeerActor extends ModuleActor { 
 return cont ; 
 } 
 
 + private Function < SessionActor , Promise < EncryptedSessionActor . EncryptedPackageRes > > encrypt ( final byte [ ] encKey ) { 
 + return new Function < SessionActor , Promise < EncryptedSessionActor . EncryptedPackageRes > > ( ) { 
 + @ Override 
 + public Promise < EncryptedSessionActor . EncryptedPackageRes > apply ( SessionActor sessionActor ) { 
 + return ask ( sessionActor . getActorRef ( ) , new EncryptedSessionActor . EncryptPackage ( encKey ) ) ; 
 + } 
 + } ; 
 + } 
 + 
 / / 
 / / Messages 
 / / 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index 2b1e7f9 . . e59fe50 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 54 , 9 + 54 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 / / 
 
 private final int uid ; 
 - private final long ownKey0 ; 
 - private final long theirKey0 ; 
 - private final int theirKeyGroup ; 
 + private final PeerSession session ; 
 
 / / 
 / / Key Manager reference 
 @ @ - 65 , 13 + 63 , 6 @ @ public class EncryptedSessionActor extends ModuleActor { 
 private KeyManagerInt keyManager ; 
 
 / / 
 - / / Loaded Session 
 - / / 
 - 
 - private EncryptedSession session ; 
 - private boolean isUnavailable = false ; 
 - 
 - / / 
 / / Temp encryption chains 
 / / 
 
 @ @ - 87 , 89 + 78 , 25 @ @ public class EncryptedSessionActor extends ModuleActor { 
 super ( context ) ; 
 this . TAG = " EncryptionSessionActor # " + session . getUid ( ) + " _ " + session . getTheirKeyGroupId ( ) ; 
 this . uid = session . getUid ( ) ; 
 - this . ownKey0 = session . getOwnPreKeyId ( ) ; 
 - this . theirKey0 = session . getTheirPreKeyId ( ) ; 
 - this . theirKeyGroup = session . getTheirKeyGroupId ( ) ; 
 + this . session = session ; 
 } 
 
 @ Override 
 public void preStart ( ) { 
 - this . keyManager = context ( ) . getEncryption ( ) . getKeyManagerInt ( ) ; 
 - 
 - ActorRef keyManager = context ( ) . getEncryption ( ) . getKeyManager ( ) ; 
 - Log . d ( TAG , " preStart " ) ; 
 - 
 - Promises . tuple ( 
 - ask ( keyManager , new FetchOwnKey ( ) ) , 
 - ask ( keyManager , new FetchOwnPreKeyById ( ownKey0 ) ) , 
 - ask ( keyManager , new FetchUserPreKey ( uid , theirKeyGroup , theirKey0 ) ) , 
 - ask ( keyManager , new FetchUserKeys ( uid ) ) ) 
 - . map ( new Function < Tuple4 < OwnIdentity , PrivateKey , PublicKey , UserKeys > , EncryptedSession > ( ) { 
 - @ Override 
 - public EncryptedSession apply ( Tuple4 < OwnIdentity , PrivateKey , PublicKey , UserKeys > res ) { 
 - PrivateKey ownIdentityKey = res . getT1 ( ) . getIdentityKey ( ) ; 
 - PrivateKey ownPreKey = res . getT2 ( ) ; 
 - PublicKey theirPreKey = res . getT3 ( ) ; 
 - UserKeys keyGroups = res . getT4 ( ) ; 
 - UserKeysGroup keysGroup = null ; 
 - for ( UserKeysGroup g : keyGroups . getUserKeysGroups ( ) ) { 
 - if ( g . getKeyGroupId ( ) = = theirKeyGroup ) { 
 - keysGroup = g ; 
 - break ; 
 - } 
 - } 
 - if ( keysGroup = = null ) { 
 - Log . w ( TAG , " Their key group not found " ) ; 
 - throw new RuntimeException ( " Their key group not found " ) ; 
 - } 
 - PublicKey theirIdentityKey = keysGroup . getIdentityKey ( ) ; 
 - 
 - return new EncryptedSession ( ownIdentityKey , ownPreKey , theirIdentityKey , theirPreKey , theirKeyGroup ) ; 
 - } 
 - } ) 
 - . then ( new Consumer < EncryptedSession > ( ) { 
 - @ Override 
 - public void apply ( EncryptedSession encryptedSession ) { 
 - Log . d ( TAG , " Loaded " ) ; 
 - EncryptedSessionActor . this . session = encryptedSession ; 
 - unstashAll ( ) ; 
 - } 
 - } ) 
 - . failure ( new Consumer < Exception > ( ) { 
 - @ Override 
 - public void apply ( Exception e ) { 
 - Log . w ( TAG , " Session load error " ) ; 
 - Log . e ( TAG , e ) ; 
 - isUnavailable = true ; 
 - unstashAll ( ) ; 
 - } 
 - } ) 
 - . done ( self ( ) ) ; 
 + super . preStart ( ) ; 
 + keyManager = context ( ) . getEncryption ( ) . getKeyManagerInt ( ) ; 
 } 
 
 private void onEncrypt ( final byte [ ] data , final PromiseResolver < EncryptedPackageRes > future ) { 
 
 / / 
 - / / If not ready : stash encryption request 
 - / / 
 - 
 - if ( session = = null ) { 
 - if ( isUnavailable ) { 
 - future . error ( new RuntimeException ( " Session is not available " ) ) ; 
 - } else { 
 - stash ( ) ; 
 - } 
 - return ; 
 - } 
 - 
 - / / 
 / / Stage 1 : Pick Their Ephemeral key . Use already received or pick random pre key . 
 / / Stage 2 : Pick Encryption Chain 
 / / Stage 3 : Decrypt 
 / / 
 
 Promises . success ( latestTheirEphemeralKey ) 
 - . mapIfNullPromise ( keyManager . supplyUserPreKey ( uid , theirKeyGroup ) ) 
 + . mapIfNullPromise ( keyManager . supplyUserPreKey ( uid , session . getTheirKeyGroupId ( ) ) ) 
 . map ( new Function < byte [ ] , EncryptedSessionChain > ( ) { 
 @ Override 
 public EncryptedSessionChain apply ( byte [ ] publicKey ) { 
 @ @ - 189 , 19 + 116 , 6 @ @ public class EncryptedSessionActor extends ModuleActor { 
 private void onDecrypt ( final byte [ ] data , final PromiseResolver < DecryptedPackage > future ) { 
 
 / / 
 - / / If not ready : stash decryption request 
 - / / 
 - 
 - if ( session = = null ) { 
 - if ( isUnavailable ) { 
 - future . error ( new RuntimeException ( " Session is not available " ) ) ; 
 - } else { 
 - stash ( ) ; 
 - } 
 - return ; 
 - } 
 - 
 - / / 
 / / Stage 1 : Parsing message header 
 / / Stage 2 : Picking decryption chain 
 / / Stage 3 : Decryption of message 
 @ @ - 257 , 7 + 171 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 e . printStackTrace ( ) ; 
 throw new RuntimeException ( e ) ; 
 } 
 - return new EncryptedPackageRes ( encrypted , theirKeyGroup ) ; 
 + return new EncryptedPackageRes ( encrypted , session . getTheirKeyGroupId ( ) ) ; 
 } 
 
 private Promise < EncryptedSessionChain > pickDecryptChain ( final byte [ ] theirEphemeralKey , final byte [ ] ephemeralKey ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / SessionManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / SessionManagerActor . java 
 index e28582c . . 633e2c8 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / SessionManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / SessionManagerActor . java 
 @ @ - 153 , 7 + 153 , 8 @ @ public class SessionManagerActor extends ModuleActor { 
 } ) ; 
 } 
 } ) 
 - . pipeTo ( srcResolver ) ; 
 + . pipeTo ( srcResolver ) 
 + . done ( self ( ) ) ; 
 } 
 
 private PeerSession spawnSession ( int uid , 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / EncryptedBoxKey . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / EncryptedBoxKey . java 
 index c0325ed . . 6e1fdf1 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / EncryptedBoxKey . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / EncryptedBoxKey . java 
 @ @ - 1 , 7 + 1 , 18 @ @ 
 package im . actor . core . modules . encryption . entity ; 
 
 + import im . actor . runtime . function . Predicate ; 
 + 
 public class EncryptedBoxKey { 
 
 + public static Predicate < EncryptedBoxKey > FILTER ( final int myUid , final int keyGroupId ) { 
 + return new Predicate < EncryptedBoxKey > ( ) { 
 + @ Override 
 + public boolean apply ( EncryptedBoxKey boxKey ) { 
 + return boxKey . getUid ( ) = = myUid & & boxKey . getKeyGroupId ( ) = = keyGroupId ; 
 + } 
 + } ; 
 + } 
 + 
 private final int uid ; 
 private final int keyGroupId ; 
 private final byte [ ] encryptedKey ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 index 6f38004 . . c32e6e0 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . core . modules . encryption . session ; 
 import java . util . HashSet ; 
 import java . util . Random ; 
 
 + import im . actor . core . entity . encryption . PeerSession ; 
 import im . actor . core . util . RandomUtils ; 
 import im . actor . runtime . Crypto ; 
 import im . actor . runtime . Log ; 
 @ @ - 18 , 14 + 19 , 14 @ @ import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; 
 
 public class EncryptedSessionChain { 
 
 - private EncryptedSession session ; 
 + private PeerSession session ; 
 private byte [ ] ownPrivateKey ; 
 private byte [ ] theirPublicKey ; 
 private HashSet < Integer > receivedCounters ; 
 private int sentCounter ; 
 private byte [ ] rootChainKey ; 
 
 - public EncryptedSessionChain ( EncryptedSession session , byte [ ] ownPrivateKey , byte [ ] theirPublicKey ) { 
 + public EncryptedSessionChain ( PeerSession session , byte [ ] ownPrivateKey , byte [ ] theirPublicKey ) { 
 this . session = session ; 
 this . ownPrivateKey = ownPrivateKey ; 
 this . theirPublicKey = theirPublicKey ; 
 @ @ - 37 , 7 + 38 , 7 @ @ public class EncryptedSessionChain { 
 session . getMasterKey ( ) ) ; 
 } 
 
 - public EncryptedSession getSession ( ) { 
 + public PeerSession getSession ( ) { 
 return session ; 
 } 
 
 @ @ - 101 , 15 + 102 , 15 @ @ public class EncryptedSessionChain { 
 ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; 
 
 byte [ ] header = ByteStrings . merge ( 
 - ByteStrings . intToBytes ( session . getPeerKeyGroupId ( ) ) , 
 - ByteStrings . longToBytes ( session . getOwnPreKey ( ) . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 - ByteStrings . longToBytes ( session . getTheirPreKey ( ) . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 + ByteStrings . intToBytes ( session . getOwnKeyGroupId ( ) ) , 
 + ByteStrings . longToBytes ( session . getOwnPreKeyId ( ) ) , / * Alice Initial Ephermal * / 
 + ByteStrings . longToBytes ( session . getTheirPreKeyId ( ) ) , / * Bob Initial Ephermal * / 
 Curve25519 . keyGenPublic ( ownPrivateKey ) , 
 theirPublicKey , 
 ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / 
 
 - Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Own ephemeral Key : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( ownPrivateKey ) ) ) ; 
 - Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Their ephemeral Key : " + Crypto . keyHash ( theirPublicKey ) ) ; 
 + / / Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Own ephemeral Key : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( ownPrivateKey ) ) ) ; 
 + / / Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Their ephemeral Key : " + Crypto . keyHash ( theirPublicKey ) ) ; 
 
 return ByteStrings . merge ( header , ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ) ; 
 }
