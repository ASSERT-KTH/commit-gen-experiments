BLEU SCORE: 0.09442944296079735

TEST MSG: test ( server ) : file url builder example
GENERATED MSG: feat ( ilectro ) : ilectro ads in group messages

TEST DIFF (one line): diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / CalcSignature . java b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / CalcSignature . java < nl > new file mode 100644 < nl > index 0000000 . . a990116 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / CalcSignature . java < nl > @ @ - 0 , 0 + 1 , 67 @ @ < nl > + package im . actor . server . api . rpc . service . files ; < nl > + < nl > + import org . apache . commons . codec . digest . HmacUtils ; < nl > + import org . apache . commons . lang3 . ArrayUtils ; < nl > + < nl > + import java . nio . ByteBuffer ; < nl > + < nl > + public class CalcSignature { < nl > + < nl > + / * * < nl > + * Returns url with calculated signature for specific file with specific file builder parameters < nl > + * @ param baseUri base uri from file url builder < nl > + * @ param seed seed provided by file url builder . Must be included in url < nl > + * @ param signatureSecret secret used to sign request < nl > + * @ param fileId id of file to download < nl > + * @ param fileAccessHash access hash of file to download < nl > + * @ return file url < nl > + * / < nl > + public static String fileBuilderUrl ( String baseUri , String seed , byte [ ] signatureSecret , long fileId , long fileAccessHash ) { < nl > + byte [ ] seedBytes = decodeHex ( seed . toCharArray ( ) ) ; < nl > + byte [ ] fileIdBytes = getBytes ( fileId ) ; < nl > + byte [ ] accessHashBytes = getBytes ( fileAccessHash ) ; < nl > + < nl > + byte [ ] bytesToSign = ArrayUtils . addAll ( ArrayUtils . addAll ( seedBytes , fileIdBytes ) , accessHashBytes ) ; < nl > + < nl > + String signPart = HmacUtils . hmacSha256Hex ( signatureSecret , bytesToSign ) ; < nl > + < nl > + String signature = seed + " _ " + signPart ; < nl > + < nl > + return baseUri + " / " + fileId + " ? signature = " + signature ; < nl > + } < nl > + < nl > + private static byte [ ] decodeHex ( final char [ ] data ) { < nl > + < nl > + final int len = data . length ; < nl > + < nl > + if ( ( len & 0x01 ) ! = 0 ) { < nl > + throw new RuntimeException ( " Odd number of characters . " ) ; < nl > + } < nl > + < nl > + final byte [ ] out = new byte [ len > > 1 ] ; < nl > + < nl > + / / two characters form the hex value . < nl > + for ( int i = 0 , j = 0 ; j < len ; i + + ) { < nl > + int f = toDigit ( data [ j ] , j ) < < 4 ; < nl > + j + + ; < nl > + f = f | toDigit ( data [ j ] , j ) ; < nl > + j + + ; < nl > + out [ i ] = ( byte ) ( f & 0xFF ) ; < nl > + } < nl > + < nl > + return out ; < nl > + } < nl > + < nl > + private static int toDigit ( final char ch , final int index ) { < nl > + final int digit = Character . digit ( ch , 16 ) ; < nl > + if ( digit = = - 1 ) { < nl > + throw new RuntimeException ( " Illegal hexadecimal character " + ch + " at index " + index ) ; < nl > + } < nl > + return digit ; < nl > + } < nl > + < nl > + private static byte [ ] getBytes ( long value ) { < nl > + return ByteBuffer . allocate ( Long . BYTES ) . putLong ( value ) . array ( ) ; < nl > + } < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / FileBuilderSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / FileBuilderSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . a6d0385 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / FileBuilderSpec . scala < nl > @ @ - 0 , 0 + 1 , 96 @ @ < nl > + package im . actor . server . api . rpc . service . files < nl > + < nl > + import java . nio . file . { Files , Paths } < nl > + import java . util < nl > + < nl > + import cats . data . Xor < nl > + import im . actor . api . rpc . { AuthData , ClientData } < nl > + import im . actor . server . api . http . HttpApi < nl > + import im . actor . server . file . { FileStorageExtension , UnsafeFileName } < nl > + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } < nl > + import spray . client . pipelining . _ < nl > + import spray . http . HttpHeaders . Location < nl > + import spray . http . HttpMethods . GET < nl > + import spray . http . { HttpRequest , StatusCodes } < nl > + < nl > + final class FileBuilderSpec < nl > + extends BaseAppSuite < nl > + with ImplicitSessionRegion < nl > + with ImplicitAuthService { < nl > + < nl > + behavior of " File builder " < nl > + < nl > + it should " generate correct redirect uri " in redirectUri < nl > + < nl > + private val fsAdapter = FileStorageExtension ( system ) . fsAdapter < nl > + private lazy val service = new FilesServiceImpl < nl > + HttpApi ( system ) . start ( ) < nl > + < nl > + def redirectUri ( ) = { < nl > + val ( user , authId , authSid , _ ) = createUser ( ) < nl > + val sessionId = createSessionId ( ) < nl > + < nl > + implicit val clientData = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid , 42 ) ) ) < nl > + < nl > + val avatarData = Files . readAllBytes ( Paths . get ( getClass . getResource ( " / valid - avatar . jpg " ) . toURI ) ) < nl > + val fileLocation = whenReady ( db . run ( fsAdapter . uploadFile ( UnsafeFileName ( " avatar " ) , avatarData ) ) ) ( identity ) < nl > + < nl > + println ( s " = = = File id : $ { fileLocation . fileId } " ) < nl > + println ( s " = = = File access hash : $ { fileLocation . accessHash } " ) < nl > + < nl > + val builder = whenReady ( service . handleGetFileUrlBuilder ( Vector ( " HMAC _ SHA256 " ) ) ) { resp ⇒ < nl > + resp should matchPattern { < nl > + case Xor . Right ( _ ) ⇒ < nl > + } < nl > + resp . toOption . get < nl > + } < nl > + < nl > + println ( s " = = = Builder base url : $ { builder . baseUrl } " ) < nl > + println ( s " = = = Builder secret : $ { util . Arrays . toString ( builder . signatureSecret ) } " ) < nl > + println ( s " = = = Builder algo : $ { builder . algo } " ) < nl > + println ( s " = = = Builder seed : $ { builder . seed } " ) < nl > + println ( s " = = = Builder timeout : $ { builder . timeout } " ) < nl > + < nl > + / / val seedBytes = Hex . decodeHex ( builder . seed . toCharArray ) < nl > + / / val fileIdBytes = CalcSignature . getBytes ( fileLocation . fileId ) < nl > + / / val accessHashBytes = CalcSignature . getBytes ( fileLocation . accessHash ) < nl > + / / < nl > + / / println ( s " = = = seed bytes : $ { util . Arrays . toString ( seedBytes ) } " ) < nl > + / / println ( s " = = = file id bytes : $ { util . Arrays . toString ( fileIdBytes ) } " ) < nl > + / / println ( s " = = = access hash bytes : $ { util . Arrays . toString ( accessHashBytes ) } " ) < nl > + / / < nl > + / / val toSignBytes = seedBytes + + fileIdBytes + + accessHashBytes < nl > + / / println ( s " = = = bytes to sign : $ { util . Arrays . toString ( toSignBytes ) } " ) < nl > + / / < nl > + / / val signPart = HmacUtils . hmacSha256Hex ( builder . signatureSecret , toSignBytes ) < nl > + / / < nl > + / / val signature = builder . seed + " _ " + signPart < nl > + / / println ( s " = = = signature : $ { signature } " ) < nl > + < nl > + val url = CalcSignature . fileBuilderUrl ( < nl > + builder . baseUrl , < nl > + builder . seed , < nl > + builder . signatureSecret , < nl > + fileLocation . fileId , < nl > + fileLocation . accessHash < nl > + ) < nl > + < nl > + println ( s " = = = file builder uri is : $ { url } " ) < nl > + < nl > + val makeRequest = sendReceive < nl > + < nl > + val location = whenReady ( makeRequest ( HttpRequest ( GET , url ) ) ) { resp ⇒ < nl > + resp . status shouldEqual StatusCodes . Found < nl > + val optLocation = resp . header [ Location ] < nl > + optLocation shouldBe defined < nl > + optLocation . get . uri < nl > + } < nl > + < nl > + println ( s " = = = location uri is : $ { location } " ) < nl > + < nl > + whenReady ( makeRequest ( HttpRequest ( GET , location ) ) ) { resp ⇒ < nl > + resp . entity . data . toByteArray shouldEqual avatarData < nl > + } < nl > + } < nl > + < nl > + }
NEAREST DIFF (one line): diff - - git a / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala b / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala < nl > index abf65c1 . . 9cf2970 100644 < nl > - - - a / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala < nl > + + + b / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala < nl > @ @ - 35 , 6 + 35 , 9 @ @ object GroupUser { < nl > def find ( groupId : Int , userId : Int ) = < nl > groupUsers . filter ( g ⇒ g . groupId = = = groupId & & g . userId = = = userId ) . result . headOption < nl > < nl > + def findByUserId ( userId : Int ) = < nl > + groupUsers . filter ( _ . userId = = = userId ) . result < nl > + < nl > def findUserIds ( groupId : Int ) = < nl > groupUsers . filter ( g ⇒ g . groupId = = = groupId ) . map ( _ . userId ) . result < nl > < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / ILectroInterceptionConfig . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / ILectroInterceptionConfig . scala < nl > new file mode 100644 < nl > index 0000000 . . d4bb1da < nl > - - - / dev / null < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / ILectroInterceptionConfig . scala < nl > @ @ - 0 , 0 + 1 , 8 @ @ < nl > + package im . actor . server . api . rpc . service . llectro < nl > + < nl > + / * * < nl > + * Created by rock _ jam on 30 . 05 . 15 . < nl > + * / < nl > + class ILectroInterceptionConfig { < nl > + < nl > + } < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / MessageInterceptor . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / MessageInterceptor . scala < nl > index 145c8e9 . . a44e940 100644 < nl > - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / MessageInterceptor . scala < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / MessageInterceptor . scala < nl > @ @ - 8 , 6 + 8 , 7 @ @ import akka . contrib . pattern . { ClusterSingletonProxy , ClusterSingletonManager , Di < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . api . rpc . messaging . MessagingService < nl > + import im . actor . api . rpc . peers . PeerType . { Private , Group } < nl > import im . actor . api . rpc . peers . { Peer , PeerType } < nl > import im . actor . server . api . rpc . service . messaging . MessagingService < nl > import im . actor . server . ilectro . ILectro < nl > @ @ - 100 , 7 + 101 , 7 @ @ class MessageInterceptor ( < nl > subscribedUserIds + + = newIds < nl > case Resubscribe ( peer ) ⇒ < nl > log . debug ( " Resubscribe { } " , peer ) < nl > - mediator ! Subscribe ( MessagingService . messagesTopic ( peer ) , interceptorGroupId ( peer ) , sender ( ) ) < nl > + mediator ! Subscribe ( MessagingService . messagesTopic ( peer ) , Some ( interceptorGroupId ( peer ) ) , sender ( ) ) < nl > case _ ⇒ < nl > } < nl > < nl > @ @ - 119 , 22 + 120 , 24 @ @ class MessageInterceptor ( < nl > db . run { < nl > for { < nl > user ← UserUtils . getUserUnsafe ( userId ) < nl > + groups ← persist . GroupUser . findByUserId ( userId ) < nl > + allTogether ← DBIO . successful ( Seq ( user ) . map ( u ⇒ Peer ( Private , u . id ) ) + + groups . map ( e ⇒ Peer ( Group , e . groupId ) ) ) < nl > ilectroUser ← persist . ilectro . ILectroUser . findByUserId ( userId ) map ( _ . getOrElse { throw new Exception ( s " Failed to find ilectro user $ { userId } " ) } ) < nl > } yield { < nl > - val interceptor = context . actorOf ( < nl > - PrivatePeerInterceptor . props ( < nl > - ilectro , < nl > - downloadManager , < nl > - uploadManager , < nl > - user , < nl > - ilectroUser < nl > - ) , < nl > - s " private - $ { userId } " < nl > - ) < nl > - < nl > - val peer = Peer ( PeerType . Private , userId ) < nl > - val topic = MessagingService . messagesTopic ( peer ) < nl > - mediator ! Subscribe ( topic , interceptorGroupId ( peer ) , interceptor ) < nl > + val interceptors = allTogether foreach { peer ⇒ < nl > + val interceptor = context . actorOf ( < nl > + PeerInterceptor . props ( < nl > + ilectro , < nl > + downloadManager , < nl > + uploadManager , < nl > + user , < nl > + ilectroUser < nl > + ) , < nl > + interceptorGroupId ( peer ) < nl > + ) < nl > + val topic = MessagingService . messagesTopic ( peer ) < nl > + mediator ! Subscribe ( topic , Some ( interceptorGroupId ( peer ) ) , interceptor ) < nl > + } < nl > } < nl > } onFailure { < nl > case e ⇒ < nl > @ @ - 143 , 11 + 146 , 11 @ @ class MessageInterceptor ( < nl > } < nl > } < nl > < nl > - private def interceptorGroupId ( peer : Peer ) : Option [ String ] = { < nl > - Some ( peer . ` type ` match { < nl > - case PeerType . Group ⇒ s " group - $ { peer . id } " < nl > - case PeerType . Private ⇒ s " private - $ { peer . id } " < nl > - } ) < nl > + private def interceptorGroupId ( peer : Peer ) : String = { < nl > + peer match { < nl > + case Peer ( Group , id ) ⇒ s " group - $ id " < nl > + case Peer ( Private , id ) ⇒ s " private - $ id " < nl > + } < nl > } < nl > < nl > } < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PeerInterceptor . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PeerInterceptor . scala < nl > new file mode 100644 < nl > index 0000000 . . e2f152e < nl > - - - / dev / null < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PeerInterceptor . scala < nl > @ @ - 0 , 0 + 1 , 171 @ @ < nl > + package im . actor . server . api . rpc . service . llectro < nl > + < nl > + import java . math . BigInteger < nl > + import java . nio . file . Path < nl > + import java . security . MessageDigest < nl > + import java . util . UUID < nl > + < nl > + import scala . concurrent . duration . _ < nl > + import scala . concurrent . forkjoin . ThreadLocalRandom < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . util . { Failure , Success } < nl > + < nl > + import akka . actor . { Actor , ActorLogging , ActorSystem , Props } < nl > + import akka . contrib . pattern . DistributedPubSubMediator < nl > + import play . api . libs . json . Json < nl > + import slick . driver . PostgresDriver . api . _ < nl > + < nl > + import im . actor . api . PeersImplicits < nl > + import im . actor . api . rpc . Update < nl > + import im . actor . api . rpc . files . FileLocation < nl > + import im . actor . api . rpc . messaging . { JsonMessage , UpdateMessage , UpdateMessageContentChanged , UpdateMessageDateChanged } < nl > + import im . actor . api . rpc . peers . { Peer , PeerType } < nl > + import im . actor . server . api . rpc . service . messaging . Events < nl > + import im . actor . server . ilectro . ILectro < nl > + import im . actor . server . ilectro . results . Banner < nl > + import im . actor . server . models < nl > + import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } < nl > + import im . actor . server . util . UploadManager < nl > + import im . actor . utils . http . DownloadManager < nl > + < nl > + object PeerInterceptor { < nl > + private case object ResetCountdown < nl > + < nl > + def props ( < nl > + ilectro : ILectro , < nl > + downloadManager : DownloadManager , < nl > + uploadManager : UploadManager , < nl > + user : models . User , < nl > + ilectroUser : models . ilectro . ILectroUser < nl > + ) ( < nl > + implicit < nl > + db : Database , < nl > + seqUpdManagerRegion : SeqUpdatesManagerRegion < nl > + ) = < nl > + Props ( classOf [ PeerInterceptor ] , ilectro , downloadManager , uploadManager , user , ilectroUser , db , seqUpdManagerRegion ) < nl > + } < nl > + < nl > + class PeerInterceptor ( < nl > + ilectro : ILectro , < nl > + downloadManager : DownloadManager , < nl > + uploadManager : UploadManager , < nl > + user : models . User , < nl > + ilectroUser : models . ilectro . ILectroUser < nl > + ) ( < nl > + implicit < nl > + db : Database , < nl > + seqUpdManagerRegion : SeqUpdatesManagerRegion < nl > + ) extends Actor with ActorLogging with PeersImplicits { < nl > + import DistributedPubSubMediator . _ < nl > + < nl > + import MessageFormats . _ < nl > + import PeerInterceptor . _ < nl > + < nl > + implicit val ec : ExecutionContext = context . dispatcher < nl > + implicit val system : ActorSystem = context . system < nl > + < nl > + val MessagesBetweenAds = 10 < nl > + < nl > + var countdown : Int = MessagesBetweenAds < nl > + var adRandomId : Option [ Long ] = None < nl > + < nl > + val scheduledResubscribe = < nl > + context . system . scheduler . scheduleOnce ( < nl > + 30 . seconds , context . parent , MessageInterceptor . Resubscribe ( Peer ( PeerType . Private , user . id ) ) < nl > + ) < nl > + < nl > + def receive = { < nl > + case ack : SubscribeAck ⇒ < nl > + scheduledResubscribe . cancel ( ) < nl > + case ResetCountdown ⇒ < nl > + countdown = MessagesBetweenAds < nl > + case Events . PeerMessage ( fromPeer , toPeer , randomId , _ , _ ) ⇒ < nl > + log . debug ( " New message , increasing counter " ) < nl > + countdown - = 1 < nl > + if ( countdown = = 0 ) { < nl > + val dialogPeer = < nl > + toPeer . typ match { < nl > + case models . PeerType . Group ⇒ toPeer < nl > + case models . PeerType . Private ⇒ if ( toPeer . id = = user . id ) fromPeer else toPeer < nl > + } < nl > + insertAds ( dialogPeer . asStruct ) andThen { < nl > + case _ ⇒ self ! ResetCountdown < nl > + } < nl > + } < nl > + } < nl > + < nl > + private def insertAds ( dialogPeer : Peer ) : Future [ Unit ] = { < nl > + log . debug ( " Inserting ads for peer { } " , dialogPeer ) < nl > + < nl > + ( for { < nl > + banner ← getBanner ( ilectroUser . uuid ) < nl > + ( filePath , fileSize ) ← downloadBanner ( banner ) < nl > + fileLocation ← uploadBannerInternally ( banner , filePath , genBannerFileName ( banner ) ) < nl > + < nl > + updates = getUpdates ( dialogPeer , banner , fileLocation , fileSize ) < nl > + < nl > + _ ← db . run ( DBIO . sequence ( < nl > + updates map ( SeqUpdatesManager . broadcastUserUpdate ( user . id , _ , None ) ) < nl > + ) ) < nl > + } yield ( ) ) andThen { < nl > + case Success ( randomId ) ⇒ < nl > + log . debug ( " Inserted an ad with randomId { } " , randomId ) < nl > + case Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to insert ad " ) < nl > + } < nl > + } < nl > + < nl > + private def getUpdates ( dialogPeer : Peer , banner : Banner , fileLocation : FileLocation , fileSize : Long ) : Seq [ Update ] = { < nl > + val message = JsonMessage ( < nl > + Json . stringify ( Json . toJson ( < nl > + Message . banner ( banner . advertUrl , fileLocation . fileId , fileLocation . accessHash , fileSize , 234 , 60 ) < nl > + ) ) < nl > + ) < nl > + < nl > + adRandomId match { < nl > + case Some ( randomId ) ⇒ < nl > + Seq ( < nl > + UpdateMessageDateChanged ( dialogPeer , randomId , System . currentTimeMillis ( ) ) , < nl > + UpdateMessageContentChanged ( dialogPeer , randomId , message ) < nl > + ) < nl > + case None ⇒ < nl > + val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) < nl > + adRandomId = Some ( randomId ) < nl > + < nl > + Seq ( UpdateMessage ( dialogPeer , user . id , System . currentTimeMillis ( ) , randomId , message ) ) < nl > + } < nl > + } < nl > + < nl > + private def getBanner ( userUuid : UUID ) : Future [ Banner ] = { < nl > + ilectro . getBanners ( userUuid ) andThen { < nl > + case Success ( banner ) ⇒ < nl > + log . debug ( " Loaded banner from API for user { } : { } " , user . id , banner ) < nl > + case Failure ( e ) ⇒ < nl > + log . error ( e , s " Failed to load banner for user $ { user . id } " ) < nl > + } < nl > + } < nl > + < nl > + private def downloadBanner ( banner : Banner ) : Future [ ( Path , Long ) ] = { < nl > + downloadManager . download ( banner . imageUrl ) andThen { < nl > + case Success ( _ ) ⇒ < nl > + log . debug ( " Downloaded banner { } " , banner ) < nl > + case Failure ( e ) ⇒ < nl > + log . error ( e , s " Failed to download banner $ { banner } " ) < nl > + } < nl > + } < nl > + < nl > + private def uploadBannerInternally ( banner : Banner , path : Path , internalFileName : String ) : Future [ FileLocation ] = { < nl > + uploadManager . uploadFile ( internalFileName , path . toFile ) andThen { < nl > + case Success ( location ) ⇒ < nl > + log . debug ( " Uploaded banner internally { } { } " , banner , location ) < nl > + case Failure ( e ) ⇒ < nl > + log . error ( e , s " Failed to upload banner internally $ { banner } " ) < nl > + } < nl > + } < nl > + < nl > + private def genBannerFileName ( banner : Banner ) : String = { < nl > + val md = MessageDigest . getInstance ( " MD5 " ) < nl > + val digestBytes = md . digest ( ( banner . advertUrl + + banner . imageUrl ) . getBytes ) < nl > + ( new BigInteger ( digestBytes ) toString ( 16 ) ) + " . jpg " < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PrivatePeerInterceptor . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PrivatePeerInterceptor . scala < nl > deleted file mode 100644 < nl > index 1421b56 . . 0000000 < nl > - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PrivatePeerInterceptor . scala < nl > + + + / dev / null < nl > @ @ - 1 , 174 + 0 , 0 @ @ < nl > - package im . actor . server . api . rpc . service . llectro < nl > - < nl > - import java . math . BigInteger < nl > - import java . nio . file . Path < nl > - import java . security . MessageDigest < nl > - import java . util . UUID < nl > - < nl > - import scala . concurrent . duration . _ < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > - import scala . concurrent . { ExecutionContext , Future } < nl > - import scala . util . { Failure , Success } < nl > - < nl > - import akka . actor . { Actor , ActorLogging , ActorSystem , Props } < nl > - import akka . contrib . pattern . DistributedPubSubMediator < nl > - import play . api . libs . json . Json < nl > - import slick . driver . PostgresDriver . api . _ < nl > - < nl > - import im . actor . api . PeersImplicits < nl > - import im . actor . api . rpc . Update < nl > - import im . actor . api . rpc . files . FileLocation < nl > - import im . actor . api . rpc . messaging . { JsonMessage , UpdateMessage , UpdateMessageContentChanged , UpdateMessageDateChanged } < nl > - import im . actor . api . rpc . peers . { Peer , PeerType } < nl > - import im . actor . server . api . rpc . service . messaging . Events < nl > - import im . actor . server . ilectro . ILectro < nl > - import im . actor . server . ilectro . results . Banner < nl > - import im . actor . server . models < nl > - import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } < nl > - import im . actor . server . util . UploadManager < nl > - import im . actor . utils . http . DownloadManager < nl > - < nl > - object PrivatePeerInterceptor { < nl > - private case object ResetCountdown < nl > - < nl > - def props ( < nl > - ilectro : ILectro , < nl > - downloadManager : DownloadManager , < nl > - uploadManager : UploadManager , < nl > - user : models . User , < nl > - ilectroUser : models . ilectro . ILectroUser < nl > - ) ( < nl > - implicit < nl > - db : Database , < nl > - seqUpdManagerRegion : SeqUpdatesManagerRegion < nl > - ) = < nl > - Props ( classOf [ PrivatePeerInterceptor ] , ilectro , downloadManager , uploadManager , user , ilectroUser , db , seqUpdManagerRegion ) < nl > - < nl > - val groupId = Some ( " PrivatePeerInterceptor " ) < nl > - } < nl > - < nl > - class PrivatePeerInterceptor ( < nl > - ilectro : ILectro , < nl > - downloadManager : DownloadManager , < nl > - uploadManager : UploadManager , < nl > - user : models . User , < nl > - ilectroUser : models . ilectro . ILectroUser < nl > - ) ( < nl > - implicit < nl > - db : Database , < nl > - seqUpdManagerRegion : SeqUpdatesManagerRegion < nl > - ) extends Actor with ActorLogging with PeersImplicits { < nl > - import DistributedPubSubMediator . _ < nl > - < nl > - import MessageFormats . _ < nl > - import PrivatePeerInterceptor . _ < nl > - < nl > - implicit val ec : ExecutionContext = context . dispatcher < nl > - implicit val system : ActorSystem = context . system < nl > - < nl > - val MessagesBetweenAds = 10 < nl > - < nl > - var countdown : Int = MessagesBetweenAds < nl > - var adRandomId : Option [ Long ] = None < nl > - < nl > - val scheduledResubscribe = < nl > - context . system . scheduler . scheduleOnce ( < nl > - 30 . seconds , context . parent , MessageInterceptor . Resubscribe ( Peer ( PeerType . Private , user . id ) ) < nl > - ) < nl > - < nl > - def receive = { < nl > - case ack : SubscribeAck ⇒ < nl > - scheduledResubscribe . cancel ( ) < nl > - case ResetCountdown ⇒ < nl > - countdown = MessagesBetweenAds < nl > - case Events . PeerMessage ( fromPeer , toPeer , randomId , _ , _ ) ⇒ < nl > - log . debug ( " New message , increasing counter " ) < nl > - countdown - = 1 < nl > - if ( countdown = = 0 ) { < nl > - val dialogPeer = < nl > - if ( toPeer . id = = user . id ) < nl > - fromPeer < nl > - else < nl > - toPeer < nl > - < nl > - insertAds ( dialogPeer . asStruct ) andThen { < nl > - case _ ⇒ self ! ResetCountdown < nl > - } < nl > - } < nl > - } < nl > - < nl > - private def insertAds ( dialogPeer : Peer ) : Future [ Unit ] = { < nl > - log . debug ( " Inserting ads for peer { } " , dialogPeer ) < nl > - < nl > - ( for { < nl > - banner ← getBanner ( ilectroUser . uuid ) < nl > - ( filePath , fileSize ) ← downloadBanner ( banner ) < nl > - fileLocation ← uploadBannerInternally ( banner , filePath , genBannerFileName ( banner ) ) < nl > - < nl > - updates = getUpdates ( dialogPeer , banner , fileLocation , fileSize ) < nl > - < nl > - _ ← db . run ( DBIO . sequence ( < nl > - updates map ( SeqUpdatesManager . broadcastUserUpdate ( user . id , _ , None ) ) < nl > - ) ) < nl > - } yield ( ) ) andThen { < nl > - case Success ( randomId ) ⇒ < nl > - log . debug ( " Inserted an ad with randomId { } " , randomId ) < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to insert ad " ) < nl > - } < nl > - } < nl > - < nl > - private def getUpdates ( dialogPeer : Peer , banner : Banner , fileLocation : FileLocation , fileSize : Long ) : Seq [ Update ] = { < nl > - val message = JsonMessage ( < nl > - Json . stringify ( Json . toJson ( < nl > - Message . banner ( banner . advertUrl , fileLocation . fileId , fileLocation . accessHash , fileSize , 234 , 60 ) < nl > - ) ) < nl > - ) < nl > - < nl > - adRandomId match { < nl > - case Some ( randomId ) ⇒ < nl > - Seq ( < nl > - UpdateMessageDateChanged ( dialogPeer , randomId , System . currentTimeMillis ( ) ) , < nl > - UpdateMessageContentChanged ( dialogPeer , randomId , message ) < nl > - ) < nl > - case None ⇒ < nl > - val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) < nl > - adRandomId = Some ( randomId ) < nl > - < nl > - Seq ( UpdateMessage ( dialogPeer , user . id , System . currentTimeMillis ( ) , randomId , message ) ) < nl > - } < nl > - } < nl > - < nl > - private def getBanner ( userUuid : UUID ) : Future [ Banner ] = { < nl > - ilectro . getBanners ( userUuid ) andThen { < nl > - case Success ( banner ) ⇒ < nl > - log . debug ( " Loaded banner from API for user { } : { } " , user . id , banner ) < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , s " Failed to load banner for user $ { user . id } " ) < nl > - } < nl > - } < nl > - < nl > - private def downloadBanner ( banner : Banner ) : Future [ ( Path , Long ) ] = { < nl > - downloadManager . download ( banner . imageUrl ) andThen { < nl > - case Success ( _ ) ⇒ < nl > - log . debug ( " Downloaded banner { } " , banner ) < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , s " Failed to download banner $ { banner } " ) < nl > - } < nl > - } < nl > - < nl > - private def uploadBannerInternally ( banner : Banner , path : Path , internalFileName : String ) : Future [ FileLocation ] = { < nl > - uploadManager . uploadFile ( internalFileName , path . toFile ) andThen { < nl > - case Success ( location ) ⇒ < nl > - log . debug ( " Uploaded banner internally { } { } " , banner , location ) < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , s " Failed to upload banner internally $ { banner } " ) < nl > - } < nl > - } < nl > - < nl > - private def genBannerFileName ( banner : Banner ) : String = { < nl > - val md = MessageDigest . getInstance ( " MD5 " ) < nl > - val digestBytes = md . digest ( ( banner . advertUrl + + banner . imageUrl ) . getBytes ) < nl > - ( new BigInteger ( digestBytes ) toString ( 16 ) ) + " . jpg " < nl > - } < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ILectroInterceptorsSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ILectroInterceptorsSpec . scala < nl > index b647629 . . 655f897 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ILectroInterceptorsSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ILectroInterceptorsSpec . scala < nl > @ @ - 2 , 14 + 2 , 19 @ @ package im . actor . server . api . rpc . service < nl > < nl > import scala . concurrent . _ < nl > import scala . concurrent . duration . _ < nl > + import scala . concurrent . forkjoin . ThreadLocalRandom < nl > < nl > import com . amazonaws . auth . EnvironmentVariableCredentialsProvider < nl > import com . amazonaws . services . s3 . transfer . TransferManager < nl > import com . google . protobuf . CodedInputStream < nl > < nl > - import im . actor . api . rpc . ClientData < nl > + import im . actor . api . PeersImplicits < nl > + import im . actor . api . rpc . groups . UpdateGroupInvite < nl > + import im . actor . api . rpc . misc . ResponseSeqDate < nl > + import im . actor . api . rpc . { Ok , ClientData } < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . peers . { OutPeer , PeerType } < nl > + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . api . rpc . service . llectro . { IlectroServiceImpl , MessageInterceptor } < nl > import im . actor . server . api . rpc . service . messaging . { GroupPeerManager , PrivatePeerManager } < nl > import im . actor . server . api . rpc . service . sequence . SequenceServiceImpl < nl > @ @ - 19 , 15 + 24 , 21 @ @ import im . actor . server . social . SocialManager < nl > import im . actor . server . util . { ACLUtils , UploadManager } < nl > import im . actor . utils . http . DownloadManager < nl > < nl > - class ILectroInterceptorsSpec extends BaseServiceSuite { < nl > + class ILectroInterceptorsSpec extends BaseServiceSuite with GroupsServiceHelpers with PeersImplicits { < nl > + val messageCount = 10 < nl > < nl > behavior of " ILectro MessageInterceptor " < nl > < nl > - it should " insert banner after 10 messages " in s . e1 < nl > + it should s " insert banner after $ messageCount messages " in s . e1 < nl > < nl > it should " not do anything for non ILectro users " in s . e2 < nl > < nl > + it should " not insert ilectro banner in dialog of ilecto user and any other user " in s . e3 < nl > + < nl > + it should s " insert banner in group after $ messageCount messages for ilectro user only " in s . e4 < nl > + < nl > object s { < nl > + < nl > implicit val sessionRegion = buildSessionRegionProxy ( ) < nl > < nl > implicit val seqUpdManagerRegion = buildSeqUpdManagerRegion ( ) < nl > @ @ - 40 , 9 + 51 , 11 @ @ class ILectroInterceptorsSpec extends BaseServiceSuite { < nl > val bucketName = " actor - uploads - test " < nl > val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) < nl > implicit val transferManager = new TransferManager ( awsCredentials ) < nl > + val groupInviteConfig = GroupInviteConfig ( " http : / / actor . im " ) < nl > < nl > implicit val authService = buildAuthService ( ) < nl > implicit val messagingService = messaging . MessagingServiceImpl ( mediator ) < nl > + implicit val groupsService = new GroupsServiceImpl ( bucketName , groupInviteConfig ) < nl > val sequenceService = new SequenceServiceImpl < nl > < nl > lazy val ilectro = new ILectro < nl > @ @ - 79 , 14 + 92 , 14 @ @ class ILectroInterceptorsSpec extends BaseServiceSuite { < nl > sendMessages ( user2Peer ) ( clientData1 ) < nl > Thread . sleep ( 5000 ) < nl > < nl > - val ( randomId1 , seq1 , state1 ) = checkNewAdExists ( 0 , Array . empty , clientData1 ) < nl > - val ( randomId2 , seq2 , state2 ) = checkNewAdExists ( 0 , Array . empty , clientData2 ) < nl > + val ( randomId1 , seq1 , state1 ) = checkNewAdExists ( 0 , Array . empty , clientData1 , user2Peer ) < nl > + val ( randomId2 , seq2 , state2 ) = checkNewAdExists ( 0 , Array . empty , clientData2 , user2Peer ) < nl > < nl > sendMessages ( user2Peer ) ( clientData1 ) < nl > Thread . sleep ( 5000 ) < nl > < nl > - checkUpdatedAdExists ( randomId1 , seq1 , state1 , clientData1 ) < nl > - checkUpdatedAdExists ( randomId2 , seq2 , state2 , clientData2 ) < nl > + checkUpdatedAdExists ( randomId1 , seq1 , state1 , clientData1 , user2Peer ) < nl > + checkUpdatedAdExists ( randomId2 , seq2 , state2 , clientData2 , user2Peer ) < nl > } < nl > < nl > def e2 ( ) : Unit = { < nl > @ @ - 111 , 36 + 124 , 121 @ @ class ILectroInterceptorsSpec extends BaseServiceSuite { < nl > sendMessages ( user2Peer ) ( clientData1 ) < nl > Thread . sleep ( 5000 ) < nl > < nl > - checkNoAdExists ( 0 , Array . empty , clientData1 ) < nl > - checkNoAdExists ( 0 , Array . empty , clientData2 ) < nl > + checkNOAdExists ( 0 , Array . empty , clientData1 , user2Peer ) < nl > + checkNOAdExists ( 0 , Array . empty , clientData2 , user2Peer ) < nl > + } < nl > + < nl > + def e3 ( ) : Unit = { < nl > + val ( ilectroUser , authId1 , _ ) = createUser ( ) < nl > + val sessionId1 = createSessionId ( ) < nl > + < nl > + val ( regularUser , authId2 , _ ) = createUser ( ) < nl > + val sessionId2 = createSessionId ( ) < nl > + < nl > + val ilectroUserData = ClientData ( authId1 , sessionId1 , Some ( ilectroUser . id ) ) < nl > + val regularUserData = ClientData ( authId2 , sessionId2 , Some ( regularUser . id ) ) < nl > + < nl > + val user1AccessHash = ACLUtils . userAccessHash ( authId2 , ilectroUser . id , getUserModel ( ilectroUser . id ) . accessSalt ) < nl > + val user1Peer = OutPeer ( PeerType . Private , ilectroUser . id , user1AccessHash ) < nl > + < nl > + val user2AccessHash = ACLUtils . userAccessHash ( authId1 , regularUser . id , getUserModel ( regularUser . id ) . accessSalt ) < nl > + val user2Peer = OutPeer ( PeerType . Private , regularUser . id , user2AccessHash ) < nl > + < nl > + Await . result ( ilectroService . jhandleGetAvailableInterests ( ilectroUserData ) , 5 . seconds ) < nl > + < nl > + MessageInterceptor . reFetchUsers ( interceptorProxy ) < nl > + Thread . sleep ( 5000 ) < nl > + < nl > + sendMessages ( user2Peer ) ( ilectroUserData ) < nl > + Thread . sleep ( 5000 ) < nl > + < nl > + val ( randomId1 , seq1 , state1 ) = checkNewAdExists ( 0 , Array . empty , ilectroUserData , user2Peer ) < nl > + checkNOAdExists ( 0 , Array . empty , regularUserData , user2Peer ) < nl > + } < nl > + < nl > + def e4 ( ) : Unit = { < nl > + val ( user1 , user1AuthId , _ ) = createUser ( ) < nl > + val ( user2 , user2AuthId , _ ) = createUser ( ) < nl > + val ( user3 , user3AuthId , _ ) = createUser ( ) < nl > + val sessionId = createSessionId ( ) < nl > + < nl > + val clientData1 = ClientData ( user1AuthId , sessionId , Some ( user1 . id ) ) < nl > + val clientData2 = ClientData ( user2AuthId , sessionId , Some ( user2 . id ) ) < nl > + val clientData3 = ClientData ( user3AuthId , sessionId , Some ( user3 . id ) ) < nl > + < nl > + val groupOutPeer = { < nl > + implicit val clientData = clientData1 < nl > + createGroup ( " partial ilectro group " , Set ( user2 . id , user3 . id ) ) . groupPeer < nl > + } . asOutPeer < nl > + < nl > + Await . result ( ilectroService . jhandleGetAvailableInterests ( clientData1 ) , 5 . seconds ) < nl > + < nl > + MessageInterceptor . reFetchUsers ( interceptorProxy ) < nl > + Thread . sleep ( 5000 ) < nl > + < nl > + sendMessages ( groupOutPeer ) ( clientData2 ) < nl > + Thread . sleep ( 5000 ) < nl > + < nl > + val ( randomId1 , seq1 , state1 ) = checkNewAdExists ( 0 , Array . empty , clientData1 , groupOutPeer ) < nl > + val ( randomId2 , seq2 , state2 ) = checkNOAdExists ( 0 , Array . empty , clientData2 , groupOutPeer ) < nl > + val ( randomId3 , seq3 , state3 ) = checkNOAdExists ( 0 , Array . empty , clientData3 , groupOutPeer ) < nl > + < nl > + sendMessages ( groupOutPeer ) ( clientData1 ) < nl > + Thread . sleep ( 5000 ) < nl > + < nl > + checkUpdatedAdExists ( randomId1 , seq1 , state1 , clientData1 , groupOutPeer ) < nl > + checkUpdatedNOAdExists ( seq2 , state2 , clientData2 , groupOutPeer ) < nl > + checkUpdatedNOAdExists ( seq3 , state3 , clientData3 , groupOutPeer ) < nl > } < nl > < nl > private def sendMessages ( outPeer : OutPeer ) ( implicit clientData : ClientData ) : Unit = { < nl > - for ( _ ← 1 to 10 ) { < nl > - whenReady ( messagingService . handleSendMessage ( outPeer , 1L , TextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) ) ( _ ⇒ ( ) ) < nl > + val rng = ThreadLocalRandom . current ( ) < nl > + for ( _ ← 1 to messageCount ) { < nl > + whenReady ( messagingService . handleSendMessage ( outPeer , rng . nextLong ( ) , TextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) ) ( _ ⇒ ( ) ) < nl > + } < nl > + } < nl > + < nl > + private def checkNOAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData , peer : OutPeer ) = { < nl > + val count = if ( peer . ` type ` = = PeerType . Group ) messageCount + 1 else messageCount < nl > + whenReady ( sequenceService . jhandleGetDifference ( seq , state , clientData ) ) { result ⇒ < nl > + val resp = result . toOption . get < nl > + < nl > + val updates = resp . updates < nl > + updates . length shouldEqual count < nl > + < nl > + val message = UpdateMessageSent . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) < nl > + message should matchPattern { < nl > + case Right ( UpdateMessageSent ( _ , _ , _ ) ) ⇒ < nl > + } < nl > + < nl > + ( message . right . toOption . get . randomId , resp . seq , resp . state ) < nl > } < nl > } < nl > < nl > - private def checkNoAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData ) = { < nl > + private def checkUpdatedNOAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData , peer : OutPeer ) = { < nl > + val count = messageCount < nl > whenReady ( sequenceService . jhandleGetDifference ( seq , state , clientData ) ) { result ⇒ < nl > val resp = result . toOption . get < nl > < nl > val updates = resp . updates < nl > - updates . length shouldEqual 10 < nl > + updates . length shouldEqual count < nl > < nl > - val message = TextMessage . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) < nl > + val message = UpdateMessageSent . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) < nl > message should matchPattern { < nl > - case Right ( TextMessage ( _ , _ , None ) ) ⇒ < nl > + case Right ( UpdateMessageSent ( _ , _ , _ ) ) ⇒ < nl > } < nl > + < nl > + ( message . right . toOption . get . randomId , resp . seq , resp . state ) < nl > } < nl > } < nl > < nl > - private def checkNewAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData ) : ( Long , Int , Array [ Byte ] ) = { < nl > + private def checkNewAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData , peer : OutPeer ) : ( Long , Int , Array [ Byte ] ) = { < nl > + val count = if ( peer . ` type ` = = PeerType . Group ) messageCount + 2 else messageCount + 1 < nl > whenReady ( sequenceService . jhandleGetDifference ( seq , state , clientData ) ) { result ⇒ < nl > val resp = result . toOption . get < nl > < nl > val updates = resp . updates < nl > - updates . length shouldEqual 11 < nl > + updates . length shouldEqual count < nl > < nl > val update = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) . right . toOption . get < nl > update . message shouldBe a [ JsonMessage ] < nl > @ @ - 151 , 12 + 249 , 13 @ @ class ILectroInterceptorsSpec extends BaseServiceSuite { < nl > } < nl > } < nl > < nl > - private def checkUpdatedAdExists ( randomId : Long , seq : Int , state : Array [ Byte ] , clientData : ClientData ) : ( Int , Array [ Byte ] ) = { < nl > + private def checkUpdatedAdExists ( randomId : Long , seq : Int , state : Array [ Byte ] , clientData : ClientData , peer : OutPeer ) : ( Int , Array [ Byte ] ) = { < nl > + val count = messageCount + 2 < nl > whenReady ( sequenceService . jhandleGetDifference ( seq , state , clientData ) ) { result ⇒ < nl > val resp = result . toOption . get < nl > < nl > val updates = resp . updates < nl > - updates . length shouldEqual 12 < nl > + updates . length shouldEqual count < nl > < nl > val Seq ( diffUpdate1 , diffUpdate2 ) = updates . takeRight ( 2 ) < nl > < nl > diff - - git a / src / main / scala / im / actor / server / Main . scala b / src / main / scala / im / actor / server / Main . scala < nl > index 8a24d34 . . 3962ff3 100644 < nl > - - - a / src / main / scala / im / actor / server / Main . scala < nl > + + + b / src / main / scala / im / actor / server / Main . scala < nl > @ @ - 101 , 12 + 101 , 12 @ @ class Main extends Bootable with DbInit with FlywayInit { < nl > < nl > val downloadManager = new DownloadManager < nl > implicit val uploadManager = new UploadManager ( s3BucketName ) < nl > - MessageInterceptor . startSingleton ( ilectro , downloadManager , uploadManager ) < nl > < nl > val mediator = DistributedPubSubExtension ( system ) . mediator < nl > < nl > val messagingService = MessagingServiceImpl ( mediator ) < nl > < nl > + MessageInterceptor . startSingleton ( ilectro , downloadManager , uploadManager ) < nl > RichMessageWorker . startWorker ( richMessageConfig , mediator ) < nl > < nl > val services = Seq (

TEST DIFF:
diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / CalcSignature . java b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / CalcSignature . java 
 new file mode 100644 
 index 0000000 . . a990116 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / CalcSignature . java 
 @ @ - 0 , 0 + 1 , 67 @ @ 
 + package im . actor . server . api . rpc . service . files ; 
 + 
 + import org . apache . commons . codec . digest . HmacUtils ; 
 + import org . apache . commons . lang3 . ArrayUtils ; 
 + 
 + import java . nio . ByteBuffer ; 
 + 
 + public class CalcSignature { 
 + 
 + / * * 
 + * Returns url with calculated signature for specific file with specific file builder parameters 
 + * @ param baseUri base uri from file url builder 
 + * @ param seed seed provided by file url builder . Must be included in url 
 + * @ param signatureSecret secret used to sign request 
 + * @ param fileId id of file to download 
 + * @ param fileAccessHash access hash of file to download 
 + * @ return file url 
 + * / 
 + public static String fileBuilderUrl ( String baseUri , String seed , byte [ ] signatureSecret , long fileId , long fileAccessHash ) { 
 + byte [ ] seedBytes = decodeHex ( seed . toCharArray ( ) ) ; 
 + byte [ ] fileIdBytes = getBytes ( fileId ) ; 
 + byte [ ] accessHashBytes = getBytes ( fileAccessHash ) ; 
 + 
 + byte [ ] bytesToSign = ArrayUtils . addAll ( ArrayUtils . addAll ( seedBytes , fileIdBytes ) , accessHashBytes ) ; 
 + 
 + String signPart = HmacUtils . hmacSha256Hex ( signatureSecret , bytesToSign ) ; 
 + 
 + String signature = seed + " _ " + signPart ; 
 + 
 + return baseUri + " / " + fileId + " ? signature = " + signature ; 
 + } 
 + 
 + private static byte [ ] decodeHex ( final char [ ] data ) { 
 + 
 + final int len = data . length ; 
 + 
 + if ( ( len & 0x01 ) ! = 0 ) { 
 + throw new RuntimeException ( " Odd number of characters . " ) ; 
 + } 
 + 
 + final byte [ ] out = new byte [ len > > 1 ] ; 
 + 
 + / / two characters form the hex value . 
 + for ( int i = 0 , j = 0 ; j < len ; i + + ) { 
 + int f = toDigit ( data [ j ] , j ) < < 4 ; 
 + j + + ; 
 + f = f | toDigit ( data [ j ] , j ) ; 
 + j + + ; 
 + out [ i ] = ( byte ) ( f & 0xFF ) ; 
 + } 
 + 
 + return out ; 
 + } 
 + 
 + private static int toDigit ( final char ch , final int index ) { 
 + final int digit = Character . digit ( ch , 16 ) ; 
 + if ( digit = = - 1 ) { 
 + throw new RuntimeException ( " Illegal hexadecimal character " + ch + " at index " + index ) ; 
 + } 
 + return digit ; 
 + } 
 + 
 + private static byte [ ] getBytes ( long value ) { 
 + return ByteBuffer . allocate ( Long . BYTES ) . putLong ( value ) . array ( ) ; 
 + } 
 + 
 + } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / FileBuilderSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / FileBuilderSpec . scala 
 new file mode 100644 
 index 0000000 . . a6d0385 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / files / FileBuilderSpec . scala 
 @ @ - 0 , 0 + 1 , 96 @ @ 
 + package im . actor . server . api . rpc . service . files 
 + 
 + import java . nio . file . { Files , Paths } 
 + import java . util 
 + 
 + import cats . data . Xor 
 + import im . actor . api . rpc . { AuthData , ClientData } 
 + import im . actor . server . api . http . HttpApi 
 + import im . actor . server . file . { FileStorageExtension , UnsafeFileName } 
 + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } 
 + import spray . client . pipelining . _ 
 + import spray . http . HttpHeaders . Location 
 + import spray . http . HttpMethods . GET 
 + import spray . http . { HttpRequest , StatusCodes } 
 + 
 + final class FileBuilderSpec 
 + extends BaseAppSuite 
 + with ImplicitSessionRegion 
 + with ImplicitAuthService { 
 + 
 + behavior of " File builder " 
 + 
 + it should " generate correct redirect uri " in redirectUri 
 + 
 + private val fsAdapter = FileStorageExtension ( system ) . fsAdapter 
 + private lazy val service = new FilesServiceImpl 
 + HttpApi ( system ) . start ( ) 
 + 
 + def redirectUri ( ) = { 
 + val ( user , authId , authSid , _ ) = createUser ( ) 
 + val sessionId = createSessionId ( ) 
 + 
 + implicit val clientData = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid , 42 ) ) ) 
 + 
 + val avatarData = Files . readAllBytes ( Paths . get ( getClass . getResource ( " / valid - avatar . jpg " ) . toURI ) ) 
 + val fileLocation = whenReady ( db . run ( fsAdapter . uploadFile ( UnsafeFileName ( " avatar " ) , avatarData ) ) ) ( identity ) 
 + 
 + println ( s " = = = File id : $ { fileLocation . fileId } " ) 
 + println ( s " = = = File access hash : $ { fileLocation . accessHash } " ) 
 + 
 + val builder = whenReady ( service . handleGetFileUrlBuilder ( Vector ( " HMAC _ SHA256 " ) ) ) { resp ⇒ 
 + resp should matchPattern { 
 + case Xor . Right ( _ ) ⇒ 
 + } 
 + resp . toOption . get 
 + } 
 + 
 + println ( s " = = = Builder base url : $ { builder . baseUrl } " ) 
 + println ( s " = = = Builder secret : $ { util . Arrays . toString ( builder . signatureSecret ) } " ) 
 + println ( s " = = = Builder algo : $ { builder . algo } " ) 
 + println ( s " = = = Builder seed : $ { builder . seed } " ) 
 + println ( s " = = = Builder timeout : $ { builder . timeout } " ) 
 + 
 + / / val seedBytes = Hex . decodeHex ( builder . seed . toCharArray ) 
 + / / val fileIdBytes = CalcSignature . getBytes ( fileLocation . fileId ) 
 + / / val accessHashBytes = CalcSignature . getBytes ( fileLocation . accessHash ) 
 + / / 
 + / / println ( s " = = = seed bytes : $ { util . Arrays . toString ( seedBytes ) } " ) 
 + / / println ( s " = = = file id bytes : $ { util . Arrays . toString ( fileIdBytes ) } " ) 
 + / / println ( s " = = = access hash bytes : $ { util . Arrays . toString ( accessHashBytes ) } " ) 
 + / / 
 + / / val toSignBytes = seedBytes + + fileIdBytes + + accessHashBytes 
 + / / println ( s " = = = bytes to sign : $ { util . Arrays . toString ( toSignBytes ) } " ) 
 + / / 
 + / / val signPart = HmacUtils . hmacSha256Hex ( builder . signatureSecret , toSignBytes ) 
 + / / 
 + / / val signature = builder . seed + " _ " + signPart 
 + / / println ( s " = = = signature : $ { signature } " ) 
 + 
 + val url = CalcSignature . fileBuilderUrl ( 
 + builder . baseUrl , 
 + builder . seed , 
 + builder . signatureSecret , 
 + fileLocation . fileId , 
 + fileLocation . accessHash 
 + ) 
 + 
 + println ( s " = = = file builder uri is : $ { url } " ) 
 + 
 + val makeRequest = sendReceive 
 + 
 + val location = whenReady ( makeRequest ( HttpRequest ( GET , url ) ) ) { resp ⇒ 
 + resp . status shouldEqual StatusCodes . Found 
 + val optLocation = resp . header [ Location ] 
 + optLocation shouldBe defined 
 + optLocation . get . uri 
 + } 
 + 
 + println ( s " = = = location uri is : $ { location } " ) 
 + 
 + whenReady ( makeRequest ( HttpRequest ( GET , location ) ) ) { resp ⇒ 
 + resp . entity . data . toByteArray shouldEqual avatarData 
 + } 
 + } 
 + 
 + }

NEAREST DIFF:
diff - - git a / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala b / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala 
 index abf65c1 . . 9cf2970 100644 
 - - - a / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala 
 + + + b / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala 
 @ @ - 35 , 6 + 35 , 9 @ @ object GroupUser { 
 def find ( groupId : Int , userId : Int ) = 
 groupUsers . filter ( g ⇒ g . groupId = = = groupId & & g . userId = = = userId ) . result . headOption 
 
 + def findByUserId ( userId : Int ) = 
 + groupUsers . filter ( _ . userId = = = userId ) . result 
 + 
 def findUserIds ( groupId : Int ) = 
 groupUsers . filter ( g ⇒ g . groupId = = = groupId ) . map ( _ . userId ) . result 
 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / ILectroInterceptionConfig . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / ILectroInterceptionConfig . scala 
 new file mode 100644 
 index 0000000 . . d4bb1da 
 - - - / dev / null 
 + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / ILectroInterceptionConfig . scala 
 @ @ - 0 , 0 + 1 , 8 @ @ 
 + package im . actor . server . api . rpc . service . llectro 
 + 
 + / * * 
 + * Created by rock _ jam on 30 . 05 . 15 . 
 + * / 
 + class ILectroInterceptionConfig { 
 + 
 + } 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / MessageInterceptor . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / MessageInterceptor . scala 
 index 145c8e9 . . a44e940 100644 
 - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / MessageInterceptor . scala 
 + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / MessageInterceptor . scala 
 @ @ - 8 , 6 + 8 , 7 @ @ import akka . contrib . pattern . { ClusterSingletonProxy , ClusterSingletonManager , Di 
 import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . api . rpc . messaging . MessagingService 
 + import im . actor . api . rpc . peers . PeerType . { Private , Group } 
 import im . actor . api . rpc . peers . { Peer , PeerType } 
 import im . actor . server . api . rpc . service . messaging . MessagingService 
 import im . actor . server . ilectro . ILectro 
 @ @ - 100 , 7 + 101 , 7 @ @ class MessageInterceptor ( 
 subscribedUserIds + + = newIds 
 case Resubscribe ( peer ) ⇒ 
 log . debug ( " Resubscribe { } " , peer ) 
 - mediator ! Subscribe ( MessagingService . messagesTopic ( peer ) , interceptorGroupId ( peer ) , sender ( ) ) 
 + mediator ! Subscribe ( MessagingService . messagesTopic ( peer ) , Some ( interceptorGroupId ( peer ) ) , sender ( ) ) 
 case _ ⇒ 
 } 
 
 @ @ - 119 , 22 + 120 , 24 @ @ class MessageInterceptor ( 
 db . run { 
 for { 
 user ← UserUtils . getUserUnsafe ( userId ) 
 + groups ← persist . GroupUser . findByUserId ( userId ) 
 + allTogether ← DBIO . successful ( Seq ( user ) . map ( u ⇒ Peer ( Private , u . id ) ) + + groups . map ( e ⇒ Peer ( Group , e . groupId ) ) ) 
 ilectroUser ← persist . ilectro . ILectroUser . findByUserId ( userId ) map ( _ . getOrElse { throw new Exception ( s " Failed to find ilectro user $ { userId } " ) } ) 
 } yield { 
 - val interceptor = context . actorOf ( 
 - PrivatePeerInterceptor . props ( 
 - ilectro , 
 - downloadManager , 
 - uploadManager , 
 - user , 
 - ilectroUser 
 - ) , 
 - s " private - $ { userId } " 
 - ) 
 - 
 - val peer = Peer ( PeerType . Private , userId ) 
 - val topic = MessagingService . messagesTopic ( peer ) 
 - mediator ! Subscribe ( topic , interceptorGroupId ( peer ) , interceptor ) 
 + val interceptors = allTogether foreach { peer ⇒ 
 + val interceptor = context . actorOf ( 
 + PeerInterceptor . props ( 
 + ilectro , 
 + downloadManager , 
 + uploadManager , 
 + user , 
 + ilectroUser 
 + ) , 
 + interceptorGroupId ( peer ) 
 + ) 
 + val topic = MessagingService . messagesTopic ( peer ) 
 + mediator ! Subscribe ( topic , Some ( interceptorGroupId ( peer ) ) , interceptor ) 
 + } 
 } 
 } onFailure { 
 case e ⇒ 
 @ @ - 143 , 11 + 146 , 11 @ @ class MessageInterceptor ( 
 } 
 } 
 
 - private def interceptorGroupId ( peer : Peer ) : Option [ String ] = { 
 - Some ( peer . ` type ` match { 
 - case PeerType . Group ⇒ s " group - $ { peer . id } " 
 - case PeerType . Private ⇒ s " private - $ { peer . id } " 
 - } ) 
 + private def interceptorGroupId ( peer : Peer ) : String = { 
 + peer match { 
 + case Peer ( Group , id ) ⇒ s " group - $ id " 
 + case Peer ( Private , id ) ⇒ s " private - $ id " 
 + } 
 } 
 
 } 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PeerInterceptor . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PeerInterceptor . scala 
 new file mode 100644 
 index 0000000 . . e2f152e 
 - - - / dev / null 
 + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PeerInterceptor . scala 
 @ @ - 0 , 0 + 1 , 171 @ @ 
 + package im . actor . server . api . rpc . service . llectro 
 + 
 + import java . math . BigInteger 
 + import java . nio . file . Path 
 + import java . security . MessageDigest 
 + import java . util . UUID 
 + 
 + import scala . concurrent . duration . _ 
 + import scala . concurrent . forkjoin . ThreadLocalRandom 
 + import scala . concurrent . { ExecutionContext , Future } 
 + import scala . util . { Failure , Success } 
 + 
 + import akka . actor . { Actor , ActorLogging , ActorSystem , Props } 
 + import akka . contrib . pattern . DistributedPubSubMediator 
 + import play . api . libs . json . Json 
 + import slick . driver . PostgresDriver . api . _ 
 + 
 + import im . actor . api . PeersImplicits 
 + import im . actor . api . rpc . Update 
 + import im . actor . api . rpc . files . FileLocation 
 + import im . actor . api . rpc . messaging . { JsonMessage , UpdateMessage , UpdateMessageContentChanged , UpdateMessageDateChanged } 
 + import im . actor . api . rpc . peers . { Peer , PeerType } 
 + import im . actor . server . api . rpc . service . messaging . Events 
 + import im . actor . server . ilectro . ILectro 
 + import im . actor . server . ilectro . results . Banner 
 + import im . actor . server . models 
 + import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } 
 + import im . actor . server . util . UploadManager 
 + import im . actor . utils . http . DownloadManager 
 + 
 + object PeerInterceptor { 
 + private case object ResetCountdown 
 + 
 + def props ( 
 + ilectro : ILectro , 
 + downloadManager : DownloadManager , 
 + uploadManager : UploadManager , 
 + user : models . User , 
 + ilectroUser : models . ilectro . ILectroUser 
 + ) ( 
 + implicit 
 + db : Database , 
 + seqUpdManagerRegion : SeqUpdatesManagerRegion 
 + ) = 
 + Props ( classOf [ PeerInterceptor ] , ilectro , downloadManager , uploadManager , user , ilectroUser , db , seqUpdManagerRegion ) 
 + } 
 + 
 + class PeerInterceptor ( 
 + ilectro : ILectro , 
 + downloadManager : DownloadManager , 
 + uploadManager : UploadManager , 
 + user : models . User , 
 + ilectroUser : models . ilectro . ILectroUser 
 + ) ( 
 + implicit 
 + db : Database , 
 + seqUpdManagerRegion : SeqUpdatesManagerRegion 
 + ) extends Actor with ActorLogging with PeersImplicits { 
 + import DistributedPubSubMediator . _ 
 + 
 + import MessageFormats . _ 
 + import PeerInterceptor . _ 
 + 
 + implicit val ec : ExecutionContext = context . dispatcher 
 + implicit val system : ActorSystem = context . system 
 + 
 + val MessagesBetweenAds = 10 
 + 
 + var countdown : Int = MessagesBetweenAds 
 + var adRandomId : Option [ Long ] = None 
 + 
 + val scheduledResubscribe = 
 + context . system . scheduler . scheduleOnce ( 
 + 30 . seconds , context . parent , MessageInterceptor . Resubscribe ( Peer ( PeerType . Private , user . id ) ) 
 + ) 
 + 
 + def receive = { 
 + case ack : SubscribeAck ⇒ 
 + scheduledResubscribe . cancel ( ) 
 + case ResetCountdown ⇒ 
 + countdown = MessagesBetweenAds 
 + case Events . PeerMessage ( fromPeer , toPeer , randomId , _ , _ ) ⇒ 
 + log . debug ( " New message , increasing counter " ) 
 + countdown - = 1 
 + if ( countdown = = 0 ) { 
 + val dialogPeer = 
 + toPeer . typ match { 
 + case models . PeerType . Group ⇒ toPeer 
 + case models . PeerType . Private ⇒ if ( toPeer . id = = user . id ) fromPeer else toPeer 
 + } 
 + insertAds ( dialogPeer . asStruct ) andThen { 
 + case _ ⇒ self ! ResetCountdown 
 + } 
 + } 
 + } 
 + 
 + private def insertAds ( dialogPeer : Peer ) : Future [ Unit ] = { 
 + log . debug ( " Inserting ads for peer { } " , dialogPeer ) 
 + 
 + ( for { 
 + banner ← getBanner ( ilectroUser . uuid ) 
 + ( filePath , fileSize ) ← downloadBanner ( banner ) 
 + fileLocation ← uploadBannerInternally ( banner , filePath , genBannerFileName ( banner ) ) 
 + 
 + updates = getUpdates ( dialogPeer , banner , fileLocation , fileSize ) 
 + 
 + _ ← db . run ( DBIO . sequence ( 
 + updates map ( SeqUpdatesManager . broadcastUserUpdate ( user . id , _ , None ) ) 
 + ) ) 
 + } yield ( ) ) andThen { 
 + case Success ( randomId ) ⇒ 
 + log . debug ( " Inserted an ad with randomId { } " , randomId ) 
 + case Failure ( e ) ⇒ 
 + log . error ( e , " Failed to insert ad " ) 
 + } 
 + } 
 + 
 + private def getUpdates ( dialogPeer : Peer , banner : Banner , fileLocation : FileLocation , fileSize : Long ) : Seq [ Update ] = { 
 + val message = JsonMessage ( 
 + Json . stringify ( Json . toJson ( 
 + Message . banner ( banner . advertUrl , fileLocation . fileId , fileLocation . accessHash , fileSize , 234 , 60 ) 
 + ) ) 
 + ) 
 + 
 + adRandomId match { 
 + case Some ( randomId ) ⇒ 
 + Seq ( 
 + UpdateMessageDateChanged ( dialogPeer , randomId , System . currentTimeMillis ( ) ) , 
 + UpdateMessageContentChanged ( dialogPeer , randomId , message ) 
 + ) 
 + case None ⇒ 
 + val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) 
 + adRandomId = Some ( randomId ) 
 + 
 + Seq ( UpdateMessage ( dialogPeer , user . id , System . currentTimeMillis ( ) , randomId , message ) ) 
 + } 
 + } 
 + 
 + private def getBanner ( userUuid : UUID ) : Future [ Banner ] = { 
 + ilectro . getBanners ( userUuid ) andThen { 
 + case Success ( banner ) ⇒ 
 + log . debug ( " Loaded banner from API for user { } : { } " , user . id , banner ) 
 + case Failure ( e ) ⇒ 
 + log . error ( e , s " Failed to load banner for user $ { user . id } " ) 
 + } 
 + } 
 + 
 + private def downloadBanner ( banner : Banner ) : Future [ ( Path , Long ) ] = { 
 + downloadManager . download ( banner . imageUrl ) andThen { 
 + case Success ( _ ) ⇒ 
 + log . debug ( " Downloaded banner { } " , banner ) 
 + case Failure ( e ) ⇒ 
 + log . error ( e , s " Failed to download banner $ { banner } " ) 
 + } 
 + } 
 + 
 + private def uploadBannerInternally ( banner : Banner , path : Path , internalFileName : String ) : Future [ FileLocation ] = { 
 + uploadManager . uploadFile ( internalFileName , path . toFile ) andThen { 
 + case Success ( location ) ⇒ 
 + log . debug ( " Uploaded banner internally { } { } " , banner , location ) 
 + case Failure ( e ) ⇒ 
 + log . error ( e , s " Failed to upload banner internally $ { banner } " ) 
 + } 
 + } 
 + 
 + private def genBannerFileName ( banner : Banner ) : String = { 
 + val md = MessageDigest . getInstance ( " MD5 " ) 
 + val digestBytes = md . digest ( ( banner . advertUrl + + banner . imageUrl ) . getBytes ) 
 + ( new BigInteger ( digestBytes ) toString ( 16 ) ) + " . jpg " 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PrivatePeerInterceptor . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PrivatePeerInterceptor . scala 
 deleted file mode 100644 
 index 1421b56 . . 0000000 
 - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / llectro / PrivatePeerInterceptor . scala 
 + + + / dev / null 
 @ @ - 1 , 174 + 0 , 0 @ @ 
 - package im . actor . server . api . rpc . service . llectro 
 - 
 - import java . math . BigInteger 
 - import java . nio . file . Path 
 - import java . security . MessageDigest 
 - import java . util . UUID 
 - 
 - import scala . concurrent . duration . _ 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 - import scala . concurrent . { ExecutionContext , Future } 
 - import scala . util . { Failure , Success } 
 - 
 - import akka . actor . { Actor , ActorLogging , ActorSystem , Props } 
 - import akka . contrib . pattern . DistributedPubSubMediator 
 - import play . api . libs . json . Json 
 - import slick . driver . PostgresDriver . api . _ 
 - 
 - import im . actor . api . PeersImplicits 
 - import im . actor . api . rpc . Update 
 - import im . actor . api . rpc . files . FileLocation 
 - import im . actor . api . rpc . messaging . { JsonMessage , UpdateMessage , UpdateMessageContentChanged , UpdateMessageDateChanged } 
 - import im . actor . api . rpc . peers . { Peer , PeerType } 
 - import im . actor . server . api . rpc . service . messaging . Events 
 - import im . actor . server . ilectro . ILectro 
 - import im . actor . server . ilectro . results . Banner 
 - import im . actor . server . models 
 - import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } 
 - import im . actor . server . util . UploadManager 
 - import im . actor . utils . http . DownloadManager 
 - 
 - object PrivatePeerInterceptor { 
 - private case object ResetCountdown 
 - 
 - def props ( 
 - ilectro : ILectro , 
 - downloadManager : DownloadManager , 
 - uploadManager : UploadManager , 
 - user : models . User , 
 - ilectroUser : models . ilectro . ILectroUser 
 - ) ( 
 - implicit 
 - db : Database , 
 - seqUpdManagerRegion : SeqUpdatesManagerRegion 
 - ) = 
 - Props ( classOf [ PrivatePeerInterceptor ] , ilectro , downloadManager , uploadManager , user , ilectroUser , db , seqUpdManagerRegion ) 
 - 
 - val groupId = Some ( " PrivatePeerInterceptor " ) 
 - } 
 - 
 - class PrivatePeerInterceptor ( 
 - ilectro : ILectro , 
 - downloadManager : DownloadManager , 
 - uploadManager : UploadManager , 
 - user : models . User , 
 - ilectroUser : models . ilectro . ILectroUser 
 - ) ( 
 - implicit 
 - db : Database , 
 - seqUpdManagerRegion : SeqUpdatesManagerRegion 
 - ) extends Actor with ActorLogging with PeersImplicits { 
 - import DistributedPubSubMediator . _ 
 - 
 - import MessageFormats . _ 
 - import PrivatePeerInterceptor . _ 
 - 
 - implicit val ec : ExecutionContext = context . dispatcher 
 - implicit val system : ActorSystem = context . system 
 - 
 - val MessagesBetweenAds = 10 
 - 
 - var countdown : Int = MessagesBetweenAds 
 - var adRandomId : Option [ Long ] = None 
 - 
 - val scheduledResubscribe = 
 - context . system . scheduler . scheduleOnce ( 
 - 30 . seconds , context . parent , MessageInterceptor . Resubscribe ( Peer ( PeerType . Private , user . id ) ) 
 - ) 
 - 
 - def receive = { 
 - case ack : SubscribeAck ⇒ 
 - scheduledResubscribe . cancel ( ) 
 - case ResetCountdown ⇒ 
 - countdown = MessagesBetweenAds 
 - case Events . PeerMessage ( fromPeer , toPeer , randomId , _ , _ ) ⇒ 
 - log . debug ( " New message , increasing counter " ) 
 - countdown - = 1 
 - if ( countdown = = 0 ) { 
 - val dialogPeer = 
 - if ( toPeer . id = = user . id ) 
 - fromPeer 
 - else 
 - toPeer 
 - 
 - insertAds ( dialogPeer . asStruct ) andThen { 
 - case _ ⇒ self ! ResetCountdown 
 - } 
 - } 
 - } 
 - 
 - private def insertAds ( dialogPeer : Peer ) : Future [ Unit ] = { 
 - log . debug ( " Inserting ads for peer { } " , dialogPeer ) 
 - 
 - ( for { 
 - banner ← getBanner ( ilectroUser . uuid ) 
 - ( filePath , fileSize ) ← downloadBanner ( banner ) 
 - fileLocation ← uploadBannerInternally ( banner , filePath , genBannerFileName ( banner ) ) 
 - 
 - updates = getUpdates ( dialogPeer , banner , fileLocation , fileSize ) 
 - 
 - _ ← db . run ( DBIO . sequence ( 
 - updates map ( SeqUpdatesManager . broadcastUserUpdate ( user . id , _ , None ) ) 
 - ) ) 
 - } yield ( ) ) andThen { 
 - case Success ( randomId ) ⇒ 
 - log . debug ( " Inserted an ad with randomId { } " , randomId ) 
 - case Failure ( e ) ⇒ 
 - log . error ( e , " Failed to insert ad " ) 
 - } 
 - } 
 - 
 - private def getUpdates ( dialogPeer : Peer , banner : Banner , fileLocation : FileLocation , fileSize : Long ) : Seq [ Update ] = { 
 - val message = JsonMessage ( 
 - Json . stringify ( Json . toJson ( 
 - Message . banner ( banner . advertUrl , fileLocation . fileId , fileLocation . accessHash , fileSize , 234 , 60 ) 
 - ) ) 
 - ) 
 - 
 - adRandomId match { 
 - case Some ( randomId ) ⇒ 
 - Seq ( 
 - UpdateMessageDateChanged ( dialogPeer , randomId , System . currentTimeMillis ( ) ) , 
 - UpdateMessageContentChanged ( dialogPeer , randomId , message ) 
 - ) 
 - case None ⇒ 
 - val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) 
 - adRandomId = Some ( randomId ) 
 - 
 - Seq ( UpdateMessage ( dialogPeer , user . id , System . currentTimeMillis ( ) , randomId , message ) ) 
 - } 
 - } 
 - 
 - private def getBanner ( userUuid : UUID ) : Future [ Banner ] = { 
 - ilectro . getBanners ( userUuid ) andThen { 
 - case Success ( banner ) ⇒ 
 - log . debug ( " Loaded banner from API for user { } : { } " , user . id , banner ) 
 - case Failure ( e ) ⇒ 
 - log . error ( e , s " Failed to load banner for user $ { user . id } " ) 
 - } 
 - } 
 - 
 - private def downloadBanner ( banner : Banner ) : Future [ ( Path , Long ) ] = { 
 - downloadManager . download ( banner . imageUrl ) andThen { 
 - case Success ( _ ) ⇒ 
 - log . debug ( " Downloaded banner { } " , banner ) 
 - case Failure ( e ) ⇒ 
 - log . error ( e , s " Failed to download banner $ { banner } " ) 
 - } 
 - } 
 - 
 - private def uploadBannerInternally ( banner : Banner , path : Path , internalFileName : String ) : Future [ FileLocation ] = { 
 - uploadManager . uploadFile ( internalFileName , path . toFile ) andThen { 
 - case Success ( location ) ⇒ 
 - log . debug ( " Uploaded banner internally { } { } " , banner , location ) 
 - case Failure ( e ) ⇒ 
 - log . error ( e , s " Failed to upload banner internally $ { banner } " ) 
 - } 
 - } 
 - 
 - private def genBannerFileName ( banner : Banner ) : String = { 
 - val md = MessageDigest . getInstance ( " MD5 " ) 
 - val digestBytes = md . digest ( ( banner . advertUrl + + banner . imageUrl ) . getBytes ) 
 - ( new BigInteger ( digestBytes ) toString ( 16 ) ) + " . jpg " 
 - } 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ILectroInterceptorsSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ILectroInterceptorsSpec . scala 
 index b647629 . . 655f897 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ILectroInterceptorsSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ILectroInterceptorsSpec . scala 
 @ @ - 2 , 14 + 2 , 19 @ @ package im . actor . server . api . rpc . service 
 
 import scala . concurrent . _ 
 import scala . concurrent . duration . _ 
 + import scala . concurrent . forkjoin . ThreadLocalRandom 
 
 import com . amazonaws . auth . EnvironmentVariableCredentialsProvider 
 import com . amazonaws . services . s3 . transfer . TransferManager 
 import com . google . protobuf . CodedInputStream 
 
 - import im . actor . api . rpc . ClientData 
 + import im . actor . api . PeersImplicits 
 + import im . actor . api . rpc . groups . UpdateGroupInvite 
 + import im . actor . api . rpc . misc . ResponseSeqDate 
 + import im . actor . api . rpc . { Ok , ClientData } 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . peers . { OutPeer , PeerType } 
 + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . api . rpc . service . llectro . { IlectroServiceImpl , MessageInterceptor } 
 import im . actor . server . api . rpc . service . messaging . { GroupPeerManager , PrivatePeerManager } 
 import im . actor . server . api . rpc . service . sequence . SequenceServiceImpl 
 @ @ - 19 , 15 + 24 , 21 @ @ import im . actor . server . social . SocialManager 
 import im . actor . server . util . { ACLUtils , UploadManager } 
 import im . actor . utils . http . DownloadManager 
 
 - class ILectroInterceptorsSpec extends BaseServiceSuite { 
 + class ILectroInterceptorsSpec extends BaseServiceSuite with GroupsServiceHelpers with PeersImplicits { 
 + val messageCount = 10 
 
 behavior of " ILectro MessageInterceptor " 
 
 - it should " insert banner after 10 messages " in s . e1 
 + it should s " insert banner after $ messageCount messages " in s . e1 
 
 it should " not do anything for non ILectro users " in s . e2 
 
 + it should " not insert ilectro banner in dialog of ilecto user and any other user " in s . e3 
 + 
 + it should s " insert banner in group after $ messageCount messages for ilectro user only " in s . e4 
 + 
 object s { 
 + 
 implicit val sessionRegion = buildSessionRegionProxy ( ) 
 
 implicit val seqUpdManagerRegion = buildSeqUpdManagerRegion ( ) 
 @ @ - 40 , 9 + 51 , 11 @ @ class ILectroInterceptorsSpec extends BaseServiceSuite { 
 val bucketName = " actor - uploads - test " 
 val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) 
 implicit val transferManager = new TransferManager ( awsCredentials ) 
 + val groupInviteConfig = GroupInviteConfig ( " http : / / actor . im " ) 
 
 implicit val authService = buildAuthService ( ) 
 implicit val messagingService = messaging . MessagingServiceImpl ( mediator ) 
 + implicit val groupsService = new GroupsServiceImpl ( bucketName , groupInviteConfig ) 
 val sequenceService = new SequenceServiceImpl 
 
 lazy val ilectro = new ILectro 
 @ @ - 79 , 14 + 92 , 14 @ @ class ILectroInterceptorsSpec extends BaseServiceSuite { 
 sendMessages ( user2Peer ) ( clientData1 ) 
 Thread . sleep ( 5000 ) 
 
 - val ( randomId1 , seq1 , state1 ) = checkNewAdExists ( 0 , Array . empty , clientData1 ) 
 - val ( randomId2 , seq2 , state2 ) = checkNewAdExists ( 0 , Array . empty , clientData2 ) 
 + val ( randomId1 , seq1 , state1 ) = checkNewAdExists ( 0 , Array . empty , clientData1 , user2Peer ) 
 + val ( randomId2 , seq2 , state2 ) = checkNewAdExists ( 0 , Array . empty , clientData2 , user2Peer ) 
 
 sendMessages ( user2Peer ) ( clientData1 ) 
 Thread . sleep ( 5000 ) 
 
 - checkUpdatedAdExists ( randomId1 , seq1 , state1 , clientData1 ) 
 - checkUpdatedAdExists ( randomId2 , seq2 , state2 , clientData2 ) 
 + checkUpdatedAdExists ( randomId1 , seq1 , state1 , clientData1 , user2Peer ) 
 + checkUpdatedAdExists ( randomId2 , seq2 , state2 , clientData2 , user2Peer ) 
 } 
 
 def e2 ( ) : Unit = { 
 @ @ - 111 , 36 + 124 , 121 @ @ class ILectroInterceptorsSpec extends BaseServiceSuite { 
 sendMessages ( user2Peer ) ( clientData1 ) 
 Thread . sleep ( 5000 ) 
 
 - checkNoAdExists ( 0 , Array . empty , clientData1 ) 
 - checkNoAdExists ( 0 , Array . empty , clientData2 ) 
 + checkNOAdExists ( 0 , Array . empty , clientData1 , user2Peer ) 
 + checkNOAdExists ( 0 , Array . empty , clientData2 , user2Peer ) 
 + } 
 + 
 + def e3 ( ) : Unit = { 
 + val ( ilectroUser , authId1 , _ ) = createUser ( ) 
 + val sessionId1 = createSessionId ( ) 
 + 
 + val ( regularUser , authId2 , _ ) = createUser ( ) 
 + val sessionId2 = createSessionId ( ) 
 + 
 + val ilectroUserData = ClientData ( authId1 , sessionId1 , Some ( ilectroUser . id ) ) 
 + val regularUserData = ClientData ( authId2 , sessionId2 , Some ( regularUser . id ) ) 
 + 
 + val user1AccessHash = ACLUtils . userAccessHash ( authId2 , ilectroUser . id , getUserModel ( ilectroUser . id ) . accessSalt ) 
 + val user1Peer = OutPeer ( PeerType . Private , ilectroUser . id , user1AccessHash ) 
 + 
 + val user2AccessHash = ACLUtils . userAccessHash ( authId1 , regularUser . id , getUserModel ( regularUser . id ) . accessSalt ) 
 + val user2Peer = OutPeer ( PeerType . Private , regularUser . id , user2AccessHash ) 
 + 
 + Await . result ( ilectroService . jhandleGetAvailableInterests ( ilectroUserData ) , 5 . seconds ) 
 + 
 + MessageInterceptor . reFetchUsers ( interceptorProxy ) 
 + Thread . sleep ( 5000 ) 
 + 
 + sendMessages ( user2Peer ) ( ilectroUserData ) 
 + Thread . sleep ( 5000 ) 
 + 
 + val ( randomId1 , seq1 , state1 ) = checkNewAdExists ( 0 , Array . empty , ilectroUserData , user2Peer ) 
 + checkNOAdExists ( 0 , Array . empty , regularUserData , user2Peer ) 
 + } 
 + 
 + def e4 ( ) : Unit = { 
 + val ( user1 , user1AuthId , _ ) = createUser ( ) 
 + val ( user2 , user2AuthId , _ ) = createUser ( ) 
 + val ( user3 , user3AuthId , _ ) = createUser ( ) 
 + val sessionId = createSessionId ( ) 
 + 
 + val clientData1 = ClientData ( user1AuthId , sessionId , Some ( user1 . id ) ) 
 + val clientData2 = ClientData ( user2AuthId , sessionId , Some ( user2 . id ) ) 
 + val clientData3 = ClientData ( user3AuthId , sessionId , Some ( user3 . id ) ) 
 + 
 + val groupOutPeer = { 
 + implicit val clientData = clientData1 
 + createGroup ( " partial ilectro group " , Set ( user2 . id , user3 . id ) ) . groupPeer 
 + } . asOutPeer 
 + 
 + Await . result ( ilectroService . jhandleGetAvailableInterests ( clientData1 ) , 5 . seconds ) 
 + 
 + MessageInterceptor . reFetchUsers ( interceptorProxy ) 
 + Thread . sleep ( 5000 ) 
 + 
 + sendMessages ( groupOutPeer ) ( clientData2 ) 
 + Thread . sleep ( 5000 ) 
 + 
 + val ( randomId1 , seq1 , state1 ) = checkNewAdExists ( 0 , Array . empty , clientData1 , groupOutPeer ) 
 + val ( randomId2 , seq2 , state2 ) = checkNOAdExists ( 0 , Array . empty , clientData2 , groupOutPeer ) 
 + val ( randomId3 , seq3 , state3 ) = checkNOAdExists ( 0 , Array . empty , clientData3 , groupOutPeer ) 
 + 
 + sendMessages ( groupOutPeer ) ( clientData1 ) 
 + Thread . sleep ( 5000 ) 
 + 
 + checkUpdatedAdExists ( randomId1 , seq1 , state1 , clientData1 , groupOutPeer ) 
 + checkUpdatedNOAdExists ( seq2 , state2 , clientData2 , groupOutPeer ) 
 + checkUpdatedNOAdExists ( seq3 , state3 , clientData3 , groupOutPeer ) 
 } 
 
 private def sendMessages ( outPeer : OutPeer ) ( implicit clientData : ClientData ) : Unit = { 
 - for ( _ ← 1 to 10 ) { 
 - whenReady ( messagingService . handleSendMessage ( outPeer , 1L , TextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) ) ( _ ⇒ ( ) ) 
 + val rng = ThreadLocalRandom . current ( ) 
 + for ( _ ← 1 to messageCount ) { 
 + whenReady ( messagingService . handleSendMessage ( outPeer , rng . nextLong ( ) , TextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) ) ( _ ⇒ ( ) ) 
 + } 
 + } 
 + 
 + private def checkNOAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData , peer : OutPeer ) = { 
 + val count = if ( peer . ` type ` = = PeerType . Group ) messageCount + 1 else messageCount 
 + whenReady ( sequenceService . jhandleGetDifference ( seq , state , clientData ) ) { result ⇒ 
 + val resp = result . toOption . get 
 + 
 + val updates = resp . updates 
 + updates . length shouldEqual count 
 + 
 + val message = UpdateMessageSent . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) 
 + message should matchPattern { 
 + case Right ( UpdateMessageSent ( _ , _ , _ ) ) ⇒ 
 + } 
 + 
 + ( message . right . toOption . get . randomId , resp . seq , resp . state ) 
 } 
 } 
 
 - private def checkNoAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData ) = { 
 + private def checkUpdatedNOAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData , peer : OutPeer ) = { 
 + val count = messageCount 
 whenReady ( sequenceService . jhandleGetDifference ( seq , state , clientData ) ) { result ⇒ 
 val resp = result . toOption . get 
 
 val updates = resp . updates 
 - updates . length shouldEqual 10 
 + updates . length shouldEqual count 
 
 - val message = TextMessage . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) 
 + val message = UpdateMessageSent . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) 
 message should matchPattern { 
 - case Right ( TextMessage ( _ , _ , None ) ) ⇒ 
 + case Right ( UpdateMessageSent ( _ , _ , _ ) ) ⇒ 
 } 
 + 
 + ( message . right . toOption . get . randomId , resp . seq , resp . state ) 
 } 
 } 
 
 - private def checkNewAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData ) : ( Long , Int , Array [ Byte ] ) = { 
 + private def checkNewAdExists ( seq : Int , state : Array [ Byte ] , clientData : ClientData , peer : OutPeer ) : ( Long , Int , Array [ Byte ] ) = { 
 + val count = if ( peer . ` type ` = = PeerType . Group ) messageCount + 2 else messageCount + 1 
 whenReady ( sequenceService . jhandleGetDifference ( seq , state , clientData ) ) { result ⇒ 
 val resp = result . toOption . get 
 
 val updates = resp . updates 
 - updates . length shouldEqual 11 
 + updates . length shouldEqual count 
 
 val update = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) . right . toOption . get 
 update . message shouldBe a [ JsonMessage ] 
 @ @ - 151 , 12 + 249 , 13 @ @ class ILectroInterceptorsSpec extends BaseServiceSuite { 
 } 
 } 
 
 - private def checkUpdatedAdExists ( randomId : Long , seq : Int , state : Array [ Byte ] , clientData : ClientData ) : ( Int , Array [ Byte ] ) = { 
 + private def checkUpdatedAdExists ( randomId : Long , seq : Int , state : Array [ Byte ] , clientData : ClientData , peer : OutPeer ) : ( Int , Array [ Byte ] ) = { 
 + val count = messageCount + 2 
 whenReady ( sequenceService . jhandleGetDifference ( seq , state , clientData ) ) { result ⇒ 
 val resp = result . toOption . get 
 
 val updates = resp . updates 
 - updates . length shouldEqual 12 
 + updates . length shouldEqual count 
 
 val Seq ( diffUpdate1 , diffUpdate2 ) = updates . takeRight ( 2 ) 
 
 diff - - git a / src / main / scala / im / actor / server / Main . scala b / src / main / scala / im / actor / server / Main . scala 
 index 8a24d34 . . 3962ff3 100644 
 - - - a / src / main / scala / im / actor / server / Main . scala 
 + + + b / src / main / scala / im / actor / server / Main . scala 
 @ @ - 101 , 12 + 101 , 12 @ @ class Main extends Bootable with DbInit with FlywayInit { 
 
 val downloadManager = new DownloadManager 
 implicit val uploadManager = new UploadManager ( s3BucketName ) 
 - MessageInterceptor . startSingleton ( ilectro , downloadManager , uploadManager ) 
 
 val mediator = DistributedPubSubExtension ( system ) . mediator 
 
 val messagingService = MessagingServiceImpl ( mediator ) 
 
 + MessageInterceptor . startSingleton ( ilectro , downloadManager , uploadManager ) 
 RichMessageWorker . startWorker ( richMessageConfig , mediator ) 
 
 val services = Seq (
