BLEU SCORE: 0.48633831680799433

TEST MSG: fix ( server : core ) : break stashing by timeout in processor
GENERATED MSG: fix ( server : core ) : fix stashing and unstashing

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > index 3f928f1 . . 3783955 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . server . office < nl > import java . time . Instant < nl > import java . util . concurrent . TimeUnit < nl > < nl > - import akka . actor . { ActorRef , Status } < nl > + import akka . actor . { ActorRef , Cancellable , Status } < nl > import akka . cluster . sharding . ShardRegion . Passivate < nl > import akka . pattern . pipe < nl > import akka . persistence . PersistentActor < nl > @ @ - 24 , 6 + 24 , 8 @ @ trait ProcessorState < nl > < nl > trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFutures with AlertingActor { < nl > < nl > + case class BreakStashing ( ts : Instant , evts : Seq [ Event ] , state : State ) < nl > + < nl > case class UnstashAndWork ( evt : Event , state : State ) < nl > < nl > case class UnstashAndWorkBatch ( es : immutable . Seq [ Event ] , state : State ) < nl > @ @ - 65 , 23 + 67 , 29 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture < nl > < nl > final def receiveCommand = initializing < nl > < nl > - protected final def initializing : Receive = handleInitCommand orElse unstashing orElse { < nl > - case msg ⇒ < nl > - log . debug ( " Entity not found while processing { } " , msg ) < nl > - sender ( ) ! Status . Failure ( notFoundError ) < nl > - } < nl > + protected final def initializing : Receive = < nl > + handleInitCommand orElse unstashing orElse { < nl > + case msg ⇒ < nl > + log . debug ( " Entity not found while processing { } " , msg ) < nl > + sender ( ) ! Status . Failure ( notFoundError ) < nl > + } < nl > < nl > protected final def working ( state : State ) : Receive = handleCommand ( state ) orElse handleQuery ( state ) orElse { < nl > case unmatched ⇒ log . warning ( " Unmatched message : { } , { } , sender : { } " , unmatched . getClass . getName , unmatched , sender ( ) ) < nl > } < nl > < nl > - protected final def stashingBehavior : Receive = unstashing orElse { < nl > - case msg ⇒ < nl > - log . warning ( " Stashing : { } " , msg ) < nl > - stash ( ) < nl > - } < nl > + protected final def stashingBehavior : Receive = < nl > + unstashing orElse { < nl > + case msg ⇒ < nl > + log . warning ( " Stashing : { } " , msg ) < nl > + stash ( ) < nl > + } < nl > < nl > private final def unstashing : Receive = { < nl > + case BreakStashing ( ts , evts , state ) ⇒ < nl > + log . error ( " Break stashing . Was in stashing since : { } , with events : { } " , ts , ( evts mkString " ; " ) ) < nl > + context become working ( state ) < nl > + unstashAll ( ) < nl > case UnstashAndWork ( evt , s ) ⇒ < nl > context become working ( updatedState ( evt , s ) ) < nl > unstashAll ( ) < nl > @ @ - 117 , 42 + 125 , 22 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture < nl > } < nl > } < nl > < nl > - final def persistStashing [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = { < nl > - log . debug ( " [ persistStashing ] , event { } " , e ) < nl > - context become stashing ( state ) < nl > - < nl > - persistAsync ( e ) { evt ⇒ < nl > - f ( evt ) andThen { < nl > - case Success ( _ ) ⇒ < nl > - unstashAndWork ( e , state ) < nl > - case Failure ( f ) ⇒ < nl > - log . error ( f , " Failure while processing event { } " , e ) < nl > - unstashAndWork ( e , state ) < nl > - } < nl > - } < nl > - } < nl > - < nl > - final def persistStashing [ R ] ( es : immutable . Seq [ Event ] , state : State ) ( f : Event ⇒ Unit ) : Unit = { < nl > - log . debug ( " [ persistStashing ] , events { } " , es ) < nl > - context become stashing ( state ) < nl > - deferAsync ( es ) { _ ⇒ < nl > - unstashAndWorkBatch ( es , state ) < nl > - } < nl > - } < nl > - < nl > final def persistStashingReply [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = < nl > persistStashingReply ( e , state , sender ( ) ) ( f ) < nl > < nl > final def persistStashingReply [ R ] ( e : Event , state : State , replyTo : ActorRef ) ( f : Event ⇒ Future [ R ] ) : Unit = { < nl > log . debug ( " [ persistStashingReply ] , event { } " , e ) < nl > + val breakStashing = breakStashingTimeout ( e , state ) < nl > context become stashing ( state ) < nl > < nl > persistAsync ( e ) { evt ⇒ < nl > f ( evt ) pipeTo replyTo onComplete { < nl > case Success ( r ) ⇒ < nl > + breakStashing . cancel ( ) < nl > unstashAndWork ( e , state ) < nl > - case Failure ( f ) ⇒ < nl > - log . error ( f , " Failure while processing event { } " , e ) < nl > + case Failure ( exc ) ⇒ < nl > + log . error ( exc , " Failure while processing event { } " , e ) < nl > + breakStashing . cancel ( ) < nl > unstashAndWork ( e , state ) < nl > } < nl > } < nl > @ @ - 162 , 6 + 150 , 7 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture < nl > val replyTo = sender ( ) < nl > < nl > log . debug ( " [ persistStashingReply ] , events { } " , es ) < nl > + val breakStashing = breakStashingTimeout ( es , state ) < nl > context become stashing ( state ) < nl > < nl > persistAllAsync ( es ) ( _ ⇒ ( ) ) < nl > @ @ - 169 , 9 + 158 , 11 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture < nl > deferAsync ( ( ) ) { _ ⇒ < nl > f ( es ) pipeTo replyTo onComplete { < nl > case Success ( _ ) ⇒ < nl > + breakStashing . cancel ( ) < nl > unstashAndWorkBatch ( es , state ) < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , " Failure while processing event { } " , e ) < nl > + case Failure ( exc ) ⇒ < nl > + log . error ( exc , " Failure while processing events { } " , es ) < nl > + breakStashing . cancel ( ) < nl > unstashAndWorkBatch ( es , state ) < nl > } < nl > } < nl > @ @ - 181 , 17 + 172 , 25 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture < nl > val replyTo = sender ( ) < nl > < nl > log . debug ( " [ deferStashingReply ] , event { } " , e ) < nl > + val breakStashing = breakStashingTimeout ( e , state ) < nl > context become stashing ( state ) < nl > < nl > f ( e ) pipeTo replyTo onComplete { < nl > case Success ( result ) ⇒ < nl > + breakStashing . cancel ( ) < nl > unstashAndWork ( e , state ) < nl > case Failure ( f ) ⇒ < nl > log . error ( f , " Failure while processing event { } " , e ) < nl > + breakStashing . cancel ( ) < nl > unstashAndWork ( e , state ) < nl > } < nl > } < nl > < nl > + private def breakStashingTimeout ( e : Event , s : State ) : Cancellable = breakStashingTimeout ( Seq ( e ) , s ) < nl > + < nl > + private def breakStashingTimeout ( es : Seq [ Event ] , s : State ) : Cancellable = < nl > + context . system . scheduler . scheduleOnce ( 30 . seconds , self , BreakStashing ( now ( ) , es , s ) ) < nl > + < nl > protected final def unstashAndWork ( evt : Event , state : State ) : Unit = self ! UnstashAndWork ( evt , state ) < nl > < nl > private final def unstashAndWorkBatch ( es : immutable . Seq [ Event ] , state : State ) : Unit = self ! UnstashAndWorkBatch ( es , state ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > index ff1d684 . . 7968d37 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > @ @ - 20 , 7 + 20 , 7 @ @ import im . actor . server . sequence . SeqUpdatesExtension < nl > import im . actor . server . social . { SocialExtension , SocialManagerRegion } < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > - import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . concurrent . ExecutionContext < nl > import scala . concurrent . duration . _ < nl > < nl > trait UserEvent extends TaggedEvent {
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > index ff399eb . . 66fe120 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > @ @ - 16 , 12 + 16 , 14 @ @ import scala . util . { Failure , Success } < nl > < nl > case object StopOffice < nl > < nl > - case object UnStash < nl > - < nl > trait ProcessorState < nl > < nl > trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActor with ActorLogging { < nl > < nl > + case class UnstashAndWork ( evt : Event , state : State ) < nl > + < nl > + case class UnstashAndWorkBatch ( es : immutable . Seq [ Event ] , state : State ) < nl > + < nl > private val passivationIntervalMs = context . system . settings . config . getDuration ( " office . passivation - interval " , TimeUnit . MILLISECONDS ) < nl > private implicit val ec = context . dispatcher < nl > < nl > @ @ - 60 , 24 + 62 , 22 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo < nl > protected final def initializing : Receive = handleInitCommand orElse stashingBehavior ( ) < nl > < nl > protected final def working ( state : State ) : Receive = handleCommand ( state ) orElse handleQuery ( state ) orElse { < nl > - case UnStash = > unstashAll ( ) < nl > case unmatched ⇒ log . warning ( " Unmatched message : { } , sender : { } " , unmatched , sender ( ) ) < nl > } < nl > < nl > private final def stashingBehavior ( ) : Receive = { < nl > + case UnstashAndWork ( evt , newState ) = > < nl > + workWith ( evt , newState ) < nl > + unstashAll ( ) < nl > + case UnstashAndWorkBatch ( es , newState ) = > < nl > + workWith ( es , newState ) < nl > + unstashAll ( ) < nl > case msg ⇒ < nl > log . debug ( " Stashing while initializing . Message : { } " , msg ) < nl > stash ( ) < nl > } < nl > < nl > - private final def stashingBehavior ( evt : Any ) : Receive = { < nl > - case msg ⇒ < nl > - log . debug ( " Stashing while event processing . Message : { } , Event : { } " , msg , evt ) < nl > - stash ( ) < nl > - } < nl > - < nl > - protected final def stashing ( evt : Any , state : State ) : Receive = < nl > - handleQuery ( state ) orElse stashingBehavior ( evt ) < nl > + protected final def stashing ( state : State ) : Receive = handleQuery ( state ) orElse stashingBehavior ( ) < nl > < nl > final def persistReply [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = { < nl > log . debug ( " [ persistReply ] { } " , e ) < nl > @ @ - 96 , 17 + 96 , 15 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo < nl > < nl > final def persistStashing [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = { < nl > log . debug ( " [ persistStashing ] , event { } " , e ) < nl > - context become stashing ( e , state ) < nl > + context become stashing ( state ) < nl > < nl > persistAsync ( e ) { evt ⇒ < nl > f ( evt ) andThen { < nl > case Success ( _ ) ⇒ < nl > - workWith ( e , state ) < nl > - unstashAll ( ) < nl > + unstashAndWork ( e , state ) < nl > case Failure ( f ) ⇒ < nl > log . error ( f , " Failure while processing event { } " , e ) < nl > - workWith ( e , state ) < nl > - unstashAll ( ) < nl > + unstashAndWork ( e , state ) < nl > } < nl > } < nl > } < nl > @ @ - 115 , 19 + 113 , 17 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo < nl > val replyTo = sender ( ) < nl > < nl > log . debug ( " [ persistStashingReply ] , event { } " , e ) < nl > - context become stashing ( e , state ) < nl > + context become stashing ( state ) < nl > < nl > persistAsync ( e ) { evt ⇒ < nl > f ( evt ) pipeTo replyTo onComplete { < nl > case Success ( r ) ⇒ < nl > - workWith ( e , state ) < nl > - unstashAll ( ) < nl > + unstashAndWork ( e , state ) < nl > case Failure ( f ) ⇒ < nl > log . error ( f , " Failure while processing event { } " , e ) < nl > replyTo ! Status . Failure ( f ) < nl > < nl > - workWith ( e , state ) < nl > - unstashAll ( ) < nl > + unstashAndWork ( e , state ) < nl > } < nl > } < nl > } < nl > @ @ - 136 , 27 + 132 , 19 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo < nl > val replyTo = sender ( ) < nl > < nl > log . debug ( " [ persistStashingReply ] , events { } " , es ) < nl > - context become stashing ( es , state ) < nl > + context become stashing ( state ) / / remove es < nl > < nl > persistAsync ( es ) ( _ ⇒ ( ) ) < nl > < nl > - def updateBatch ( es : immutable . Seq [ Event ] , s : State ) : State = < nl > - es . foldLeft ( state ) { < nl > - case ( s , e ) ⇒ < nl > - updatedState ( e , s ) < nl > - } < nl > - < nl > defer ( ( ) ) { _ ⇒ < nl > f ( es ) pipeTo replyTo onComplete { < nl > case Success ( _ ) ⇒ < nl > - context become working ( updateBatch ( es , state ) ) < nl > - unstashAll ( ) < nl > + unstashAndWorkBatch ( es , state ) < nl > case Failure ( e ) ⇒ < nl > log . error ( e , " Failure while processing event { } " , e ) < nl > replyTo ! Status . Failure ( e ) < nl > < nl > - context become working ( updateBatch ( es , state ) ) < nl > - unstashAll ( ) < nl > + unstashAndWorkBatch ( es , state ) < nl > } < nl > } < nl > } < nl > @ @ - 165 , 18 + 153 , 16 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo < nl > val replyTo = sender ( ) < nl > < nl > log . debug ( " [ deferStashingReply ] , event { } " , e ) < nl > - context become stashing ( e , state ) < nl > + context become stashing ( state ) < nl > < nl > f ( e ) pipeTo replyTo onComplete { < nl > case Success ( result ) ⇒ < nl > - workWith ( e , state ) < nl > - self ! UnStash < nl > + unstashAndWork ( e , state ) < nl > case Failure ( f ) ⇒ < nl > log . error ( f , " Failure while processing event { } " , e ) < nl > replyTo ! Status . Failure ( f ) < nl > < nl > - workWith ( e , state ) < nl > - self ! UnStash < nl > + unstashAndWork ( e , state ) < nl > } < nl > } < nl > < nl > @ @ - 194 , 6 + 180 , 10 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo < nl > workWith ( e , state ) < nl > } < nl > < nl > + private final def unstashAndWork ( evt : Event , state : State ) : Unit = self ! UnstashAndWork ( evt , state ) < nl > + < nl > + private final def unstashAndWorkBatch ( es : immutable . Seq [ Event ] , state : State ) : Unit = self ! UnstashAndWorkBatch ( es , state ) < nl > + < nl > def now ( ) : DateTime = new DateTime ( ) < nl > < nl > if ( passivationIntervalMs > 0 ) {

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 index 3f928f1 . . 3783955 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . server . office 
 import java . time . Instant 
 import java . util . concurrent . TimeUnit 
 
 - import akka . actor . { ActorRef , Status } 
 + import akka . actor . { ActorRef , Cancellable , Status } 
 import akka . cluster . sharding . ShardRegion . Passivate 
 import akka . pattern . pipe 
 import akka . persistence . PersistentActor 
 @ @ - 24 , 6 + 24 , 8 @ @ trait ProcessorState 
 
 trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFutures with AlertingActor { 
 
 + case class BreakStashing ( ts : Instant , evts : Seq [ Event ] , state : State ) 
 + 
 case class UnstashAndWork ( evt : Event , state : State ) 
 
 case class UnstashAndWorkBatch ( es : immutable . Seq [ Event ] , state : State ) 
 @ @ - 65 , 23 + 67 , 29 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture 
 
 final def receiveCommand = initializing 
 
 - protected final def initializing : Receive = handleInitCommand orElse unstashing orElse { 
 - case msg ⇒ 
 - log . debug ( " Entity not found while processing { } " , msg ) 
 - sender ( ) ! Status . Failure ( notFoundError ) 
 - } 
 + protected final def initializing : Receive = 
 + handleInitCommand orElse unstashing orElse { 
 + case msg ⇒ 
 + log . debug ( " Entity not found while processing { } " , msg ) 
 + sender ( ) ! Status . Failure ( notFoundError ) 
 + } 
 
 protected final def working ( state : State ) : Receive = handleCommand ( state ) orElse handleQuery ( state ) orElse { 
 case unmatched ⇒ log . warning ( " Unmatched message : { } , { } , sender : { } " , unmatched . getClass . getName , unmatched , sender ( ) ) 
 } 
 
 - protected final def stashingBehavior : Receive = unstashing orElse { 
 - case msg ⇒ 
 - log . warning ( " Stashing : { } " , msg ) 
 - stash ( ) 
 - } 
 + protected final def stashingBehavior : Receive = 
 + unstashing orElse { 
 + case msg ⇒ 
 + log . warning ( " Stashing : { } " , msg ) 
 + stash ( ) 
 + } 
 
 private final def unstashing : Receive = { 
 + case BreakStashing ( ts , evts , state ) ⇒ 
 + log . error ( " Break stashing . Was in stashing since : { } , with events : { } " , ts , ( evts mkString " ; " ) ) 
 + context become working ( state ) 
 + unstashAll ( ) 
 case UnstashAndWork ( evt , s ) ⇒ 
 context become working ( updatedState ( evt , s ) ) 
 unstashAll ( ) 
 @ @ - 117 , 42 + 125 , 22 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture 
 } 
 } 
 
 - final def persistStashing [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = { 
 - log . debug ( " [ persistStashing ] , event { } " , e ) 
 - context become stashing ( state ) 
 - 
 - persistAsync ( e ) { evt ⇒ 
 - f ( evt ) andThen { 
 - case Success ( _ ) ⇒ 
 - unstashAndWork ( e , state ) 
 - case Failure ( f ) ⇒ 
 - log . error ( f , " Failure while processing event { } " , e ) 
 - unstashAndWork ( e , state ) 
 - } 
 - } 
 - } 
 - 
 - final def persistStashing [ R ] ( es : immutable . Seq [ Event ] , state : State ) ( f : Event ⇒ Unit ) : Unit = { 
 - log . debug ( " [ persistStashing ] , events { } " , es ) 
 - context become stashing ( state ) 
 - deferAsync ( es ) { _ ⇒ 
 - unstashAndWorkBatch ( es , state ) 
 - } 
 - } 
 - 
 final def persistStashingReply [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = 
 persistStashingReply ( e , state , sender ( ) ) ( f ) 
 
 final def persistStashingReply [ R ] ( e : Event , state : State , replyTo : ActorRef ) ( f : Event ⇒ Future [ R ] ) : Unit = { 
 log . debug ( " [ persistStashingReply ] , event { } " , e ) 
 + val breakStashing = breakStashingTimeout ( e , state ) 
 context become stashing ( state ) 
 
 persistAsync ( e ) { evt ⇒ 
 f ( evt ) pipeTo replyTo onComplete { 
 case Success ( r ) ⇒ 
 + breakStashing . cancel ( ) 
 unstashAndWork ( e , state ) 
 - case Failure ( f ) ⇒ 
 - log . error ( f , " Failure while processing event { } " , e ) 
 + case Failure ( exc ) ⇒ 
 + log . error ( exc , " Failure while processing event { } " , e ) 
 + breakStashing . cancel ( ) 
 unstashAndWork ( e , state ) 
 } 
 } 
 @ @ - 162 , 6 + 150 , 7 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture 
 val replyTo = sender ( ) 
 
 log . debug ( " [ persistStashingReply ] , events { } " , es ) 
 + val breakStashing = breakStashingTimeout ( es , state ) 
 context become stashing ( state ) 
 
 persistAllAsync ( es ) ( _ ⇒ ( ) ) 
 @ @ - 169 , 9 + 158 , 11 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture 
 deferAsync ( ( ) ) { _ ⇒ 
 f ( es ) pipeTo replyTo onComplete { 
 case Success ( _ ) ⇒ 
 + breakStashing . cancel ( ) 
 unstashAndWorkBatch ( es , state ) 
 - case Failure ( e ) ⇒ 
 - log . error ( e , " Failure while processing event { } " , e ) 
 + case Failure ( exc ) ⇒ 
 + log . error ( exc , " Failure while processing events { } " , es ) 
 + breakStashing . cancel ( ) 
 unstashAndWorkBatch ( es , state ) 
 } 
 } 
 @ @ - 181 , 17 + 172 , 25 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture 
 val replyTo = sender ( ) 
 
 log . debug ( " [ deferStashingReply ] , event { } " , e ) 
 + val breakStashing = breakStashingTimeout ( e , state ) 
 context become stashing ( state ) 
 
 f ( e ) pipeTo replyTo onComplete { 
 case Success ( result ) ⇒ 
 + breakStashing . cancel ( ) 
 unstashAndWork ( e , state ) 
 case Failure ( f ) ⇒ 
 log . error ( f , " Failure while processing event { } " , e ) 
 + breakStashing . cancel ( ) 
 unstashAndWork ( e , state ) 
 } 
 } 
 
 + private def breakStashingTimeout ( e : Event , s : State ) : Cancellable = breakStashingTimeout ( Seq ( e ) , s ) 
 + 
 + private def breakStashingTimeout ( es : Seq [ Event ] , s : State ) : Cancellable = 
 + context . system . scheduler . scheduleOnce ( 30 . seconds , self , BreakStashing ( now ( ) , es , s ) ) 
 + 
 protected final def unstashAndWork ( evt : Event , state : State ) : Unit = self ! UnstashAndWork ( evt , state ) 
 
 private final def unstashAndWorkBatch ( es : immutable . Seq [ Event ] , state : State ) : Unit = self ! UnstashAndWorkBatch ( es , state ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 index ff1d684 . . 7968d37 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 @ @ - 20 , 7 + 20 , 7 @ @ import im . actor . server . sequence . SeqUpdatesExtension 
 import im . actor . server . social . { SocialExtension , SocialManagerRegion } 
 import slick . driver . PostgresDriver . api . _ 
 
 - import scala . concurrent . { ExecutionContext , Future } 
 + import scala . concurrent . ExecutionContext 
 import scala . concurrent . duration . _ 
 
 trait UserEvent extends TaggedEvent {

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 index ff399eb . . 66fe120 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 @ @ - 16 , 12 + 16 , 14 @ @ import scala . util . { Failure , Success } 
 
 case object StopOffice 
 
 - case object UnStash 
 - 
 trait ProcessorState 
 
 trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActor with ActorLogging { 
 
 + case class UnstashAndWork ( evt : Event , state : State ) 
 + 
 + case class UnstashAndWorkBatch ( es : immutable . Seq [ Event ] , state : State ) 
 + 
 private val passivationIntervalMs = context . system . settings . config . getDuration ( " office . passivation - interval " , TimeUnit . MILLISECONDS ) 
 private implicit val ec = context . dispatcher 
 
 @ @ - 60 , 24 + 62 , 22 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo 
 protected final def initializing : Receive = handleInitCommand orElse stashingBehavior ( ) 
 
 protected final def working ( state : State ) : Receive = handleCommand ( state ) orElse handleQuery ( state ) orElse { 
 - case UnStash = > unstashAll ( ) 
 case unmatched ⇒ log . warning ( " Unmatched message : { } , sender : { } " , unmatched , sender ( ) ) 
 } 
 
 private final def stashingBehavior ( ) : Receive = { 
 + case UnstashAndWork ( evt , newState ) = > 
 + workWith ( evt , newState ) 
 + unstashAll ( ) 
 + case UnstashAndWorkBatch ( es , newState ) = > 
 + workWith ( es , newState ) 
 + unstashAll ( ) 
 case msg ⇒ 
 log . debug ( " Stashing while initializing . Message : { } " , msg ) 
 stash ( ) 
 } 
 
 - private final def stashingBehavior ( evt : Any ) : Receive = { 
 - case msg ⇒ 
 - log . debug ( " Stashing while event processing . Message : { } , Event : { } " , msg , evt ) 
 - stash ( ) 
 - } 
 - 
 - protected final def stashing ( evt : Any , state : State ) : Receive = 
 - handleQuery ( state ) orElse stashingBehavior ( evt ) 
 + protected final def stashing ( state : State ) : Receive = handleQuery ( state ) orElse stashingBehavior ( ) 
 
 final def persistReply [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = { 
 log . debug ( " [ persistReply ] { } " , e ) 
 @ @ - 96 , 17 + 96 , 15 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo 
 
 final def persistStashing [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = { 
 log . debug ( " [ persistStashing ] , event { } " , e ) 
 - context become stashing ( e , state ) 
 + context become stashing ( state ) 
 
 persistAsync ( e ) { evt ⇒ 
 f ( evt ) andThen { 
 case Success ( _ ) ⇒ 
 - workWith ( e , state ) 
 - unstashAll ( ) 
 + unstashAndWork ( e , state ) 
 case Failure ( f ) ⇒ 
 log . error ( f , " Failure while processing event { } " , e ) 
 - workWith ( e , state ) 
 - unstashAll ( ) 
 + unstashAndWork ( e , state ) 
 } 
 } 
 } 
 @ @ - 115 , 19 + 113 , 17 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo 
 val replyTo = sender ( ) 
 
 log . debug ( " [ persistStashingReply ] , event { } " , e ) 
 - context become stashing ( e , state ) 
 + context become stashing ( state ) 
 
 persistAsync ( e ) { evt ⇒ 
 f ( evt ) pipeTo replyTo onComplete { 
 case Success ( r ) ⇒ 
 - workWith ( e , state ) 
 - unstashAll ( ) 
 + unstashAndWork ( e , state ) 
 case Failure ( f ) ⇒ 
 log . error ( f , " Failure while processing event { } " , e ) 
 replyTo ! Status . Failure ( f ) 
 
 - workWith ( e , state ) 
 - unstashAll ( ) 
 + unstashAndWork ( e , state ) 
 } 
 } 
 } 
 @ @ - 136 , 27 + 132 , 19 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo 
 val replyTo = sender ( ) 
 
 log . debug ( " [ persistStashingReply ] , events { } " , es ) 
 - context become stashing ( es , state ) 
 + context become stashing ( state ) / / remove es 
 
 persistAsync ( es ) ( _ ⇒ ( ) ) 
 
 - def updateBatch ( es : immutable . Seq [ Event ] , s : State ) : State = 
 - es . foldLeft ( state ) { 
 - case ( s , e ) ⇒ 
 - updatedState ( e , s ) 
 - } 
 - 
 defer ( ( ) ) { _ ⇒ 
 f ( es ) pipeTo replyTo onComplete { 
 case Success ( _ ) ⇒ 
 - context become working ( updateBatch ( es , state ) ) 
 - unstashAll ( ) 
 + unstashAndWorkBatch ( es , state ) 
 case Failure ( e ) ⇒ 
 log . error ( e , " Failure while processing event { } " , e ) 
 replyTo ! Status . Failure ( e ) 
 
 - context become working ( updateBatch ( es , state ) ) 
 - unstashAll ( ) 
 + unstashAndWorkBatch ( es , state ) 
 } 
 } 
 } 
 @ @ - 165 , 18 + 153 , 16 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo 
 val replyTo = sender ( ) 
 
 log . debug ( " [ deferStashingReply ] , event { } " , e ) 
 - context become stashing ( e , state ) 
 + context become stashing ( state ) 
 
 f ( e ) pipeTo replyTo onComplete { 
 case Success ( result ) ⇒ 
 - workWith ( e , state ) 
 - self ! UnStash 
 + unstashAndWork ( e , state ) 
 case Failure ( f ) ⇒ 
 log . error ( f , " Failure while processing event { } " , e ) 
 replyTo ! Status . Failure ( f ) 
 
 - workWith ( e , state ) 
 - self ! UnStash 
 + unstashAndWork ( e , state ) 
 } 
 } 
 
 @ @ - 194 , 6 + 180 , 10 @ @ trait Processor [ State < : ProcessorState , Event < : AnyRef ] extends PersistentActo 
 workWith ( e , state ) 
 } 
 
 + private final def unstashAndWork ( evt : Event , state : State ) : Unit = self ! UnstashAndWork ( evt , state ) 
 + 
 + private final def unstashAndWorkBatch ( es : immutable . Seq [ Event ] , state : State ) : Unit = self ! UnstashAndWorkBatch ( es , state ) 
 + 
 def now ( ) : DateTime = new DateTime ( ) 
 
 if ( passivationIntervalMs > 0 ) {
