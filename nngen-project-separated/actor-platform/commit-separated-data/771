BLEU SCORE: 0.10307386760781874

TEST MSG: feat ( server : webrtc ) : send actor push on incoming call ; add attemptIndex to pushkit push
GENERATED MSG: perf ( server : push ) : async google push via HTTP

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala b / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala < nl > index a6d8434 . . a2fe84d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala < nl > @ @ - 7 , 23 + 7 , 37 @ @ import akka . http . scaladsl . model . _ < nl > import akka . parboiled2 . ParserInput < nl > import akka . stream . { ActorMaterializer , OverflowStrategy } < nl > import akka . stream . scaladsl . { Sink , Source } < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . model . push . ActorPushCredentials < nl > + import im . actor . server . persist . push . ActorPushCredentialsRepo < nl > import io . circe . { Json , JsonObject } < nl > import io . circe . generic . auto . _ < nl > import io . circe . syntax . _ < nl > < nl > + import scala . concurrent . Future < nl > import scala . util . { Failure , Success } < nl > < nl > final case class ActorPushMessage ( data : JsonObject ) < nl > < nl > + object ActorPushMessage { < nl > + def apply ( fields : Map [ String , String ] ) : ActorPushMessage = < nl > + ActorPushMessage ( JsonObject . fromMap ( fields mapValues Json . string ) ) < nl > + < nl > + def apply ( fields : ( String , String ) * ) : ActorPushMessage = < nl > + ActorPushMessage ( Map ( fields : _ * ) ) < nl > + } < nl > + < nl > private final case class ActorPushDelivery ( creds : ActorPushCredentials , message : ActorPushMessage ) < nl > < nl > - final class ActorPush ( _ system : ActorSystem ) extends Extension { < nl > - private implicit val system = _ system < nl > + final class ActorPush ( system : ActorSystem ) extends Extension { < nl > + import system . dispatcher < nl > + < nl > + private implicit val _ system = system < nl > private val log = Logging ( system , getClass ) < nl > private val maxQueue = system . settings . config . getInt ( " services . actor . push . max - queue " ) < nl > private val token = system . settings . config . getString ( " services . actor . push . token " ) < nl > private implicit val mat = ActorMaterializer ( ) < nl > + private val db = DbExtension ( system ) . db < nl > < nl > private val sourceRef = < nl > Source < nl > @ @ - 37 , 8 + 51 , 10 @ @ final class ActorPush ( _ system : ActorSystem ) extends Extension { < nl > < nl > private val pushHeaders = List ( headers . Authorization ( headers . OAuth2BearerToken ( token ) ) ) < nl > < nl > - def deliver ( seq : Int , creds : ActorPushCredentials ) : Unit = { < nl > - val m = ActorPushMessage ( JsonObject . singleton ( " seq " , Json . int ( seq ) ) ) < nl > + def deliver ( seq : Int , creds : ActorPushCredentials ) : Unit = < nl > + deliver ( ActorPushMessage ( JsonObject . singleton ( " seq " , Json . int ( seq ) ) ) , creds ) < nl > + < nl > + def deliver ( message : ActorPushMessage , creds : ActorPushCredentials ) : Unit = { < nl > val uri = Uri . parseAbsolute ( ParserInput ( creds . endpoint ) ) < nl > < nl > sourceRef ! < nl > @ @ - 46 , 9 + 62 , 12 @ @ final class ActorPush ( _ system : ActorSystem ) extends Extension { < nl > method = HttpMethods . POST , < nl > uri = uri , < nl > headers = pushHeaders , < nl > - entity = HttpEntity ( ContentTypes . ` application / json ` , m . asJson . noSpaces ) < nl > - ) → ActorPushDelivery ( creds , m ) < nl > + entity = HttpEntity ( ContentTypes . ` application / json ` , message . asJson . noSpaces ) < nl > + ) → ActorPushDelivery ( creds , message ) < nl > } < nl > + < nl > + def fetchCreds ( userId : Int ) : Future [ Seq [ ActorPushCredentials ] ] = < nl > + db . run ( ActorPushCredentialsRepo . findByUser ( userId ) ) < nl > } < nl > < nl > object ActorPush extends ExtensionId [ ActorPush ] with ExtensionIdProvider { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > index 025c37a . . 08ab43a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . server . dialog . DialogExtension < nl > import im . actor . server . eventbus . { EventBus , EventBusExtension } < nl > import im . actor . server . group . GroupExtension < nl > import im . actor . server . model . { Peer , PeerType } < nl > + import im . actor . server . push . actor . { ActorPushMessage , ActorPush } < nl > import im . actor . server . sequence . { GooglePushMessage , GooglePushExtension , ApplePushExtension , WeakUpdatesExtension } < nl > import im . actor . server . user . UserExtension < nl > import im . actor . server . values . ValuesExtension < nl > @ @ - 152 , 6 + 153 , 7 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging with < nl > private val valuesExt = ValuesExtension ( context . system ) < nl > private val apnsExt = ApplePushExtension ( context . system ) < nl > private val gcmExt = GooglePushExtension ( context . system ) < nl > + private val actorPush = ActorPush ( context . system ) < nl > private val webrtcExt = WebrtcExtension ( context . system ) < nl > < nl > case class Device ( < nl > @ @ - 474 , 31 + 476 , 56 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging with < nl > private def scheduleIncomingCallUpdates ( callees : Seq [ UserId ] ) : Future [ Unit ] = { < nl > for { < nl > authIdsMap ← userExt . getAuthIdsMap ( callees . toSet ) < nl > - acredss ← apnsExt . fetchVoipCreds ( authIdsMap . values . flatten . toSet ) < nl > - gcredsMap ← FutureExt . ftraverse ( authIdsMap . toSeq ) { < nl > - case ( userId , authIds ) ⇒ < nl > - gcmExt . fetchCreds ( authIds . toSet ) map ( userId → _ ) < nl > + membersMap = authIdsMap flatMap { < nl > + case ( userId , authIds ) ⇒ getMember ( userId ) map ( _ → authIds ) < nl > + } < nl > + acredsMap ← FutureExt . ftraverse ( membersMap . toSeq ) { < nl > + case ( member , authIds ) ⇒ < nl > + apnsExt . fetchVoipCreds ( authIds . toSet ) map ( member → _ ) < nl > + } < nl > + gcredsMap ← FutureExt . ftraverse ( membersMap . toSeq ) { < nl > + case ( member , authIds ) ⇒ < nl > + gcmExt . fetchCreds ( authIds . toSet ) map ( member → _ ) < nl > + } < nl > + ourCredsMap ← FutureExt . ftraverse ( membersMap . toSeq ) { < nl > + case ( member , authIds ) ⇒ < nl > + actorPush . fetchCreds ( member . userId ) map ( member → _ ) < nl > } < nl > } yield { < nl > - acredss foreach { creds ⇒ < nl > - val payload = ( new ApnsPayloadBuilder ) . addCustomProperty ( " callId " , id ) . buildWithDefaultMaximumLength ( ) < nl > + for { < nl > + ( member , creds ) ← acredsMap < nl > + cred ← creds < nl > + instance ← apnsExt . getVoipInstance ( cred . apnsKey ) < nl > + } yield { < nl > + val payload = < nl > + ( new ApnsPayloadBuilder ) < nl > + . addCustomProperty ( " callId " , id ) < nl > + . addCustomProperty ( " attemptIndex " , member . callAttempts ) < nl > + . buildWithDefaultMaximumLength ( ) < nl > + val notif = new SimpleApnsPushNotification ( cred . token . toByteArray , payload ) < nl > + instance . getQueue . add ( notif ) < nl > + } < nl > < nl > - val instanceCreds = apnsExt . getVoipInstance ( creds . apnsKey ) map ( _ → creds ) < nl > - for ( ( instance , cred ) ← instanceCreds ) { < nl > - val notif = new SimpleApnsPushNotification ( cred . token . toByteArray , payload ) < nl > - instance . getQueue . add ( notif ) < nl > - } < nl > + for { < nl > + ( member , creds ) ← gcredsMap < nl > + cred ← creds < nl > + } yield { < nl > + val message = new GooglePushMessage ( < nl > + cred . regId , < nl > + None , < nl > + Some ( Map ( " callId " → id . toString , " attemptIndex " → member . callAttempts . toString ) ) < nl > + ) < nl > + gcmExt . send ( cred . projectId , message ) < nl > } < nl > < nl > - gcredsMap foreach { < nl > - case ( userId , credss ) ⇒ < nl > - for { < nl > - member ← getMember ( userId ) < nl > - creds ← credss < nl > - } { < nl > - val message = new GooglePushMessage ( creds . regId , None , Some ( Map ( " callId " → id . toString , " attemptIndex " → member . callAttempts . toString ) ) ) < nl > - gcmExt . send ( creds . projectId , message ) < nl > - } < nl > + for { < nl > + ( member , creds ) ← ourCredsMap < nl > + cred ← creds < nl > + } yield { < nl > + actorPush . deliver ( ActorPushMessage ( < nl > + " callId " → id . toString , < nl > + " attemptIndex " → member . callAttempts . toString < nl > + ) , cred ) < nl > } < nl > < nl > scheduledUpds =
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > index d7d65c1 . . 06345e9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > @ @ - 1 , 10 + 1 , 27 @ @ < nl > package im . actor . server . sequence < nl > < nl > - import scala . util . Try < nl > + import akka . actor . _ < nl > + import akka . event . Logging < nl > + import akka . http . ConnectionPoolSettings < nl > + import akka . http . scaladsl . Http < nl > + import akka . http . scaladsl . model . _ < nl > + import akka . stream . Materializer < nl > + import akka . stream . actor . ActorPublisher < nl > + import akka . stream . scaladsl . Source < nl > + import akka . util . ByteString < nl > + import cats . data . Xor < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . persist . push . GooglePushCredentialsRepo < nl > + import io . circe . generic . auto . _ < nl > < nl > import com . github . kxbmap . configs . _ < nl > - import com . google . android . gcm . server . Sender < nl > import com . typesafe . config . Config < nl > + import io . circe . jawn . _ < nl > + import io . circe . syntax . _ < nl > + < nl > + import scala . annotation . tailrec < nl > + import scala . concurrent . Future < nl > + import scala . util . { Failure , Success , Try } < nl > < nl > case class GooglePushKey ( projectId : Long , key : String ) < nl > < nl > @ @ - 27 , 14 + 44 , 124 @ @ object GooglePushManagerConfig { < nl > } yield GooglePushManagerConfig ( keys ) < nl > } < nl > < nl > - final class GooglePushManager ( config : GooglePushManagerConfig ) { < nl > - private val senders : Map [ Long , Sender ] = < nl > + final case class GooglePushMessage ( < nl > + collapseKey : Option [ String ] , < nl > + data : Option [ Map [ String , String ] ] < nl > + ) < nl > + < nl > + final class GooglePushManager ( config : GooglePushManagerConfig ) ( implicit system : ActorSystem , mat : Materializer ) { < nl > + < nl > + import system . dispatcher < nl > + < nl > + private val log = Logging ( system , getClass ) < nl > + private val db = DbExtension ( system ) . db < nl > + < nl > + private val deliveryPublisher = system . actorOf ( GooglePushDelivery . props , " google - push - delivery " ) < nl > + < nl > + / / TODO : flatten < nl > + Source . fromPublisher ( ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] ( deliveryPublisher ) ) < nl > + . via ( GooglePushDelivery . flow ) < nl > + . runForeach { < nl > + case ( Success ( resp ) , delivery ) ⇒ < nl > + if ( resp . status = = StatusCodes . OK ) { < nl > + resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) foreach { bs ⇒ < nl > + parse ( new String ( bs . toArray , " UTF - 8 " ) ) match { < nl > + case Xor . Right ( json ) ⇒ < nl > + json . asObject match { < nl > + case Some ( obj ) ⇒ < nl > + obj ( " error " ) flatMap ( _ . asString ) foreach { < nl > + case " InvalidRegistration " ⇒ < nl > + log . warning ( " Invalid registration , deleting " ) < nl > + remove ( delivery . regId ) < nl > + case " NotRegistered " ⇒ < nl > + log . warning ( " Token is not registered , deleting " ) < nl > + remove ( delivery . regId ) < nl > + case other ⇒ < nl > + log . warning ( " Error in GCM response : { } " , other ) < nl > + } < nl > + case None ⇒ < nl > + log . error ( " Expected JSON Object but got : { } " , json ) < nl > + } < nl > + case Xor . Left ( failure ) ⇒ log . error ( failure . underlying , " Failed to parse response " ) < nl > + } < nl > + } < nl > + } else log . error ( " Status code was not OK : { } " , resp . status ) < nl > + case ( Failure ( e ) , delivery ) ⇒ < nl > + log . error ( e , " Failed to deliver message : { } " , delivery . m ) < nl > + } < nl > + < nl > + private def remove ( regId : String ) : Future [ Int ] = db . run ( GooglePushCredentialsRepo . deleteByToken ( regId ) ) < nl > + < nl > + private val keys : Map [ Long , String ] = < nl > ( config . keys map { < nl > - case GooglePushKey ( projectId , key ) ⇒ < nl > - val sender = new Sender ( key ) < nl > - ( projectId → sender ) < nl > + case GooglePushKey ( projectId , key ) ⇒ projectId → key < nl > } ) . toMap < nl > < nl > - def getInstance ( key : Long ) : Option [ Sender ] = < nl > - senders . get ( key ) < nl > + def send ( projectId : Long , regId : String , message : GooglePushMessage ) : Unit = < nl > + keys get projectId match { < nl > + case Some ( key ) ⇒ < nl > + deliveryPublisher ! GooglePushDelivery . Delivery ( message , key , regId ) < nl > + case None ⇒ < nl > + log . warning ( " Key not found for projectId : { } " , projectId ) < nl > + } < nl > + } < nl > + < nl > + private object GooglePushDelivery { < nl > + < nl > + object Tick < nl > + < nl > + final case class Delivery ( m : GooglePushMessage , key : String , regId : String ) < nl > + < nl > + private val MaxQueue = 100000 < nl > + private val MaxConnections = 4 < nl > + < nl > + def props = Props ( classOf [ GooglePushDelivery ] ) < nl > + < nl > + def flow ( implicit system : ActorSystem , mat : Materializer ) = < nl > + Http ( system ) < nl > + . cachedHostConnectionPoolTls [ GooglePushDelivery . Delivery ] ( < nl > + " gcm - http . googleapis . com " , < nl > + settings = ConnectionPoolSettings ( system ) . copy ( maxConnections = MaxConnections ) < nl > + ) < nl > + } < nl > + < nl > + private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] with ActorLogging { < nl > + < nl > + import GooglePushDelivery . _ < nl > + < nl > + private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] < nl > + < nl > + def receive = { < nl > + case d : Delivery if buf . size = = MaxQueue ⇒ < nl > + log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery " , MaxQueue ) < nl > + case d : Delivery ⇒ < nl > + if ( buf . isEmpty & & totalDemand > 0 ) < nl > + onNext ( mkJob ( d ) ) < nl > + else { < nl > + this . buf : + = mkJob ( d ) < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + < nl > + @ tailrec def deliverBuf ( ) : Unit = < nl > + if ( totalDemand > 0 ) { < nl > + if ( totalDemand < = Int . MaxValue ) { < nl > + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) < nl > + buf = keep < nl > + use foreach onNext < nl > + } else { < nl > + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) < nl > + buf = keep < nl > + use foreach onNext < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + < nl > + private def mkJob ( d : Delivery ) : ( HttpRequest , Delivery ) = < nl > + HttpRequest ( < nl > + method = HttpMethods . POST , < nl > + uri = Uri ( " / gcm / send " ) , < nl > + headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . regId } " , Map . empty [ String , String ] ) ) ) , < nl > + entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . toString ( ) ) < nl > + ) → d < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > index 1985d73 . . 8376311 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > @ @ - 1 , 29 + 1 , 16 @ @ < nl > package im . actor . server . sequence < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . event . Logging < nl > - import com . google . android . gcm . server . { Sender , Message } < nl > import im . actor . server . model . push . GooglePushCredentials < nl > < nl > - import scala . concurrent . { ExecutionContext , Future , blocking } < nl > - < nl > private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : GooglePushManager , system : ActorSystem ) extends PushProvider { < nl > - import system . dispatcher < nl > - < nl > - private val Retries = 3 < nl > - < nl > - private val log = Logging ( system , getClass ) < nl > - < nl > def deliverInvisible ( seq : Int , creds : GooglePushCredentials ) : Unit = { < nl > - withMgr ( creds . projectId ) { implicit mgr ⇒ < nl > - val message = < nl > - new Message . Builder ( ) < nl > - . collapseKey ( s " seq - invisible - $ { userId . toString } " ) < nl > - . addData ( " seq " , seq . toString ) < nl > - . build ( ) < nl > + val message = GooglePushMessage ( < nl > + collapseKey = Some ( s " seq - invisible - $ { userId . toString } " ) , < nl > + data = Some ( Map ( " seq " → seq . toString ) ) < nl > + ) < nl > < nl > - send ( message , creds . regId , Retries ) < nl > - } < nl > + googlePushManager . send ( creds . projectId , creds . regId , message ) < nl > } < nl > < nl > def deliverVisible ( < nl > @ @ - 34 , 33 + 21 , 17 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : < nl > isSoundEnabled : Boolean , < nl > isVibrationEnabled : Boolean < nl > ) : Unit = { < nl > - withMgr ( creds . projectId ) { implicit mgr ⇒ < nl > - val builder = new Message . Builder ( ) < nl > - . collapseKey ( s " seq - visible - $ { userId . toString } " ) < nl > - . addData ( " seq " , seq . toString ) < nl > - < nl > - val message = < nl > + val message = GooglePushMessage ( < nl > + collapseKey = Some ( s " seq - visible - $ { userId . toString } " ) , < nl > + data = Some ( Map ( " seq " → seq . toString ) + + ( < nl > data . text match { < nl > case text if text . nonEmpty & & isTextEnabled ⇒ < nl > - builder < nl > - . addData ( " message " , text ) < nl > - . build ( ) < nl > - case _ ⇒ builder . build ( ) < nl > + Map ( " message " → text ) < nl > + case _ ⇒ Map . empty < nl > } < nl > + ) ) < nl > + ) < nl > < nl > - send ( message , creds . regId , Retries ) < nl > - } < nl > - } < nl > - < nl > - private def withMgr [ A ] ( projectId : Long ) ( f : Sender ⇒ A ) = < nl > - googlePushManager . getInstance ( projectId ) match { < nl > - case Some ( mgr ) ⇒ f ( mgr ) < nl > - case None ⇒ log . warning ( " No google push configured for project - id : { } " , projectId ) < nl > - } < nl > - < nl > - private def send ( message : Message , regId : String , retries : Int ) ( implicit mgr : Sender , ec : ExecutionContext ) : Unit = Future { < nl > - blocking { < nl > - mgr . send ( message , regId , Retries ) < nl > - } < nl > + googlePushManager . send ( creds . projectId , creds . regId , message ) < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > index c2ce0b7 . . 5a7b0cb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import akka . actor . _ < nl > import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } < nl > import akka . event . Logging < nl > import akka . pattern . ask < nl > + import akka . stream . ActorMaterializer < nl > import akka . util . Timeout < nl > import com . google . protobuf . ByteString < nl > import im . actor . api . rpc . Update < nl > @ @ - 239 , 6 + 240 , 8 @ @ object SeqUpdatesExtension extends ExtensionId [ SeqUpdatesExtension ] with Extensi < nl > override def lookup = SeqUpdatesExtension < nl > < nl > override def createExtension ( system : ExtendedActorSystem ) = { < nl > + implicit val _ system = system < nl > + implicit val mat = ActorMaterializer ( ) < nl > val log = Logging ( system , getClass ) < nl > < nl > try { < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > index 08827c4 . . c37af44 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > @ @ - 9 , 13 + 9 , 11 @ @ import akka . http . scaladsl . model . StatusCodes . OK < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . _ < nl > import akka . stream . ActorMaterializer < nl > - import akka . stream . scaladsl . Source < nl > - import akka . util . ByteString < nl > import im . actor . server . api . http . HttpHandler < nl > import im . actor . server . file . local . { FileStorageOperations , LocalFileStorageConfig , RequestSigning } < nl > import im . actor . util . log . AnyRefLogSource < nl > < nl > - import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . concurrent . ExecutionContext < nl > import scala . util . { Failure , Success } < nl > < nl > private [ local ] final class FilesHttpHandler ( storageConfig : LocalFileStorageConfig ) ( implicit val system : ActorSystem ) < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index a259645 . . 5e32937 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 104 , 7 + 104 , 6 @ @ object Dependencies { < nl > < nl > val tyrex = " tyrex " % " tyrex " % " 1 . 0 . 1 " < nl > < nl > - val gcmServer = " com . google . android . gcm " % " gcm - server " % " 1 . 0 . 2 " < nl > val pushy = " com . relayrides " % " pushy " % " 0 . 4 . 3 " < nl > < nl > val logbackClassic = " ch . qos . logback " % " logback - classic " % " 1 . 1 . 2 " < nl > @ @ - 167 , 7 + 166 , 6 @ @ object Dependencies { < nl > akkaClusterSharding , < nl > akkaDdata , < nl > caffeine , < nl > - gcmServer , < nl > pushy , < nl > jodaTime , < nl > postgresJdbc ,

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala b / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala 
 index a6d8434 . . a2fe84d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / push / actor / ActorPush . scala 
 @ @ - 7 , 23 + 7 , 37 @ @ import akka . http . scaladsl . model . _ 
 import akka . parboiled2 . ParserInput 
 import akka . stream . { ActorMaterializer , OverflowStrategy } 
 import akka . stream . scaladsl . { Sink , Source } 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . model . push . ActorPushCredentials 
 + import im . actor . server . persist . push . ActorPushCredentialsRepo 
 import io . circe . { Json , JsonObject } 
 import io . circe . generic . auto . _ 
 import io . circe . syntax . _ 
 
 + import scala . concurrent . Future 
 import scala . util . { Failure , Success } 
 
 final case class ActorPushMessage ( data : JsonObject ) 
 
 + object ActorPushMessage { 
 + def apply ( fields : Map [ String , String ] ) : ActorPushMessage = 
 + ActorPushMessage ( JsonObject . fromMap ( fields mapValues Json . string ) ) 
 + 
 + def apply ( fields : ( String , String ) * ) : ActorPushMessage = 
 + ActorPushMessage ( Map ( fields : _ * ) ) 
 + } 
 + 
 private final case class ActorPushDelivery ( creds : ActorPushCredentials , message : ActorPushMessage ) 
 
 - final class ActorPush ( _ system : ActorSystem ) extends Extension { 
 - private implicit val system = _ system 
 + final class ActorPush ( system : ActorSystem ) extends Extension { 
 + import system . dispatcher 
 + 
 + private implicit val _ system = system 
 private val log = Logging ( system , getClass ) 
 private val maxQueue = system . settings . config . getInt ( " services . actor . push . max - queue " ) 
 private val token = system . settings . config . getString ( " services . actor . push . token " ) 
 private implicit val mat = ActorMaterializer ( ) 
 + private val db = DbExtension ( system ) . db 
 
 private val sourceRef = 
 Source 
 @ @ - 37 , 8 + 51 , 10 @ @ final class ActorPush ( _ system : ActorSystem ) extends Extension { 
 
 private val pushHeaders = List ( headers . Authorization ( headers . OAuth2BearerToken ( token ) ) ) 
 
 - def deliver ( seq : Int , creds : ActorPushCredentials ) : Unit = { 
 - val m = ActorPushMessage ( JsonObject . singleton ( " seq " , Json . int ( seq ) ) ) 
 + def deliver ( seq : Int , creds : ActorPushCredentials ) : Unit = 
 + deliver ( ActorPushMessage ( JsonObject . singleton ( " seq " , Json . int ( seq ) ) ) , creds ) 
 + 
 + def deliver ( message : ActorPushMessage , creds : ActorPushCredentials ) : Unit = { 
 val uri = Uri . parseAbsolute ( ParserInput ( creds . endpoint ) ) 
 
 sourceRef ! 
 @ @ - 46 , 9 + 62 , 12 @ @ final class ActorPush ( _ system : ActorSystem ) extends Extension { 
 method = HttpMethods . POST , 
 uri = uri , 
 headers = pushHeaders , 
 - entity = HttpEntity ( ContentTypes . ` application / json ` , m . asJson . noSpaces ) 
 - ) → ActorPushDelivery ( creds , m ) 
 + entity = HttpEntity ( ContentTypes . ` application / json ` , message . asJson . noSpaces ) 
 + ) → ActorPushDelivery ( creds , message ) 
 } 
 + 
 + def fetchCreds ( userId : Int ) : Future [ Seq [ ActorPushCredentials ] ] = 
 + db . run ( ActorPushCredentialsRepo . findByUser ( userId ) ) 
 } 
 
 object ActorPush extends ExtensionId [ ActorPush ] with ExtensionIdProvider { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 index 025c37a . . 08ab43a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . server . dialog . DialogExtension 
 import im . actor . server . eventbus . { EventBus , EventBusExtension } 
 import im . actor . server . group . GroupExtension 
 import im . actor . server . model . { Peer , PeerType } 
 + import im . actor . server . push . actor . { ActorPushMessage , ActorPush } 
 import im . actor . server . sequence . { GooglePushMessage , GooglePushExtension , ApplePushExtension , WeakUpdatesExtension } 
 import im . actor . server . user . UserExtension 
 import im . actor . server . values . ValuesExtension 
 @ @ - 152 , 6 + 153 , 7 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging with 
 private val valuesExt = ValuesExtension ( context . system ) 
 private val apnsExt = ApplePushExtension ( context . system ) 
 private val gcmExt = GooglePushExtension ( context . system ) 
 + private val actorPush = ActorPush ( context . system ) 
 private val webrtcExt = WebrtcExtension ( context . system ) 
 
 case class Device ( 
 @ @ - 474 , 31 + 476 , 56 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging with 
 private def scheduleIncomingCallUpdates ( callees : Seq [ UserId ] ) : Future [ Unit ] = { 
 for { 
 authIdsMap ← userExt . getAuthIdsMap ( callees . toSet ) 
 - acredss ← apnsExt . fetchVoipCreds ( authIdsMap . values . flatten . toSet ) 
 - gcredsMap ← FutureExt . ftraverse ( authIdsMap . toSeq ) { 
 - case ( userId , authIds ) ⇒ 
 - gcmExt . fetchCreds ( authIds . toSet ) map ( userId → _ ) 
 + membersMap = authIdsMap flatMap { 
 + case ( userId , authIds ) ⇒ getMember ( userId ) map ( _ → authIds ) 
 + } 
 + acredsMap ← FutureExt . ftraverse ( membersMap . toSeq ) { 
 + case ( member , authIds ) ⇒ 
 + apnsExt . fetchVoipCreds ( authIds . toSet ) map ( member → _ ) 
 + } 
 + gcredsMap ← FutureExt . ftraverse ( membersMap . toSeq ) { 
 + case ( member , authIds ) ⇒ 
 + gcmExt . fetchCreds ( authIds . toSet ) map ( member → _ ) 
 + } 
 + ourCredsMap ← FutureExt . ftraverse ( membersMap . toSeq ) { 
 + case ( member , authIds ) ⇒ 
 + actorPush . fetchCreds ( member . userId ) map ( member → _ ) 
 } 
 } yield { 
 - acredss foreach { creds ⇒ 
 - val payload = ( new ApnsPayloadBuilder ) . addCustomProperty ( " callId " , id ) . buildWithDefaultMaximumLength ( ) 
 + for { 
 + ( member , creds ) ← acredsMap 
 + cred ← creds 
 + instance ← apnsExt . getVoipInstance ( cred . apnsKey ) 
 + } yield { 
 + val payload = 
 + ( new ApnsPayloadBuilder ) 
 + . addCustomProperty ( " callId " , id ) 
 + . addCustomProperty ( " attemptIndex " , member . callAttempts ) 
 + . buildWithDefaultMaximumLength ( ) 
 + val notif = new SimpleApnsPushNotification ( cred . token . toByteArray , payload ) 
 + instance . getQueue . add ( notif ) 
 + } 
 
 - val instanceCreds = apnsExt . getVoipInstance ( creds . apnsKey ) map ( _ → creds ) 
 - for ( ( instance , cred ) ← instanceCreds ) { 
 - val notif = new SimpleApnsPushNotification ( cred . token . toByteArray , payload ) 
 - instance . getQueue . add ( notif ) 
 - } 
 + for { 
 + ( member , creds ) ← gcredsMap 
 + cred ← creds 
 + } yield { 
 + val message = new GooglePushMessage ( 
 + cred . regId , 
 + None , 
 + Some ( Map ( " callId " → id . toString , " attemptIndex " → member . callAttempts . toString ) ) 
 + ) 
 + gcmExt . send ( cred . projectId , message ) 
 } 
 
 - gcredsMap foreach { 
 - case ( userId , credss ) ⇒ 
 - for { 
 - member ← getMember ( userId ) 
 - creds ← credss 
 - } { 
 - val message = new GooglePushMessage ( creds . regId , None , Some ( Map ( " callId " → id . toString , " attemptIndex " → member . callAttempts . toString ) ) ) 
 - gcmExt . send ( creds . projectId , message ) 
 - } 
 + for { 
 + ( member , creds ) ← ourCredsMap 
 + cred ← creds 
 + } yield { 
 + actorPush . deliver ( ActorPushMessage ( 
 + " callId " → id . toString , 
 + " attemptIndex " → member . callAttempts . toString 
 + ) , cred ) 
 } 
 
 scheduledUpds =

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 index d7d65c1 . . 06345e9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 @ @ - 1 , 10 + 1 , 27 @ @ 
 package im . actor . server . sequence 
 
 - import scala . util . Try 
 + import akka . actor . _ 
 + import akka . event . Logging 
 + import akka . http . ConnectionPoolSettings 
 + import akka . http . scaladsl . Http 
 + import akka . http . scaladsl . model . _ 
 + import akka . stream . Materializer 
 + import akka . stream . actor . ActorPublisher 
 + import akka . stream . scaladsl . Source 
 + import akka . util . ByteString 
 + import cats . data . Xor 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . persist . push . GooglePushCredentialsRepo 
 + import io . circe . generic . auto . _ 
 
 import com . github . kxbmap . configs . _ 
 - import com . google . android . gcm . server . Sender 
 import com . typesafe . config . Config 
 + import io . circe . jawn . _ 
 + import io . circe . syntax . _ 
 + 
 + import scala . annotation . tailrec 
 + import scala . concurrent . Future 
 + import scala . util . { Failure , Success , Try } 
 
 case class GooglePushKey ( projectId : Long , key : String ) 
 
 @ @ - 27 , 14 + 44 , 124 @ @ object GooglePushManagerConfig { 
 } yield GooglePushManagerConfig ( keys ) 
 } 
 
 - final class GooglePushManager ( config : GooglePushManagerConfig ) { 
 - private val senders : Map [ Long , Sender ] = 
 + final case class GooglePushMessage ( 
 + collapseKey : Option [ String ] , 
 + data : Option [ Map [ String , String ] ] 
 + ) 
 + 
 + final class GooglePushManager ( config : GooglePushManagerConfig ) ( implicit system : ActorSystem , mat : Materializer ) { 
 + 
 + import system . dispatcher 
 + 
 + private val log = Logging ( system , getClass ) 
 + private val db = DbExtension ( system ) . db 
 + 
 + private val deliveryPublisher = system . actorOf ( GooglePushDelivery . props , " google - push - delivery " ) 
 + 
 + / / TODO : flatten 
 + Source . fromPublisher ( ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] ( deliveryPublisher ) ) 
 + . via ( GooglePushDelivery . flow ) 
 + . runForeach { 
 + case ( Success ( resp ) , delivery ) ⇒ 
 + if ( resp . status = = StatusCodes . OK ) { 
 + resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) foreach { bs ⇒ 
 + parse ( new String ( bs . toArray , " UTF - 8 " ) ) match { 
 + case Xor . Right ( json ) ⇒ 
 + json . asObject match { 
 + case Some ( obj ) ⇒ 
 + obj ( " error " ) flatMap ( _ . asString ) foreach { 
 + case " InvalidRegistration " ⇒ 
 + log . warning ( " Invalid registration , deleting " ) 
 + remove ( delivery . regId ) 
 + case " NotRegistered " ⇒ 
 + log . warning ( " Token is not registered , deleting " ) 
 + remove ( delivery . regId ) 
 + case other ⇒ 
 + log . warning ( " Error in GCM response : { } " , other ) 
 + } 
 + case None ⇒ 
 + log . error ( " Expected JSON Object but got : { } " , json ) 
 + } 
 + case Xor . Left ( failure ) ⇒ log . error ( failure . underlying , " Failed to parse response " ) 
 + } 
 + } 
 + } else log . error ( " Status code was not OK : { } " , resp . status ) 
 + case ( Failure ( e ) , delivery ) ⇒ 
 + log . error ( e , " Failed to deliver message : { } " , delivery . m ) 
 + } 
 + 
 + private def remove ( regId : String ) : Future [ Int ] = db . run ( GooglePushCredentialsRepo . deleteByToken ( regId ) ) 
 + 
 + private val keys : Map [ Long , String ] = 
 ( config . keys map { 
 - case GooglePushKey ( projectId , key ) ⇒ 
 - val sender = new Sender ( key ) 
 - ( projectId → sender ) 
 + case GooglePushKey ( projectId , key ) ⇒ projectId → key 
 } ) . toMap 
 
 - def getInstance ( key : Long ) : Option [ Sender ] = 
 - senders . get ( key ) 
 + def send ( projectId : Long , regId : String , message : GooglePushMessage ) : Unit = 
 + keys get projectId match { 
 + case Some ( key ) ⇒ 
 + deliveryPublisher ! GooglePushDelivery . Delivery ( message , key , regId ) 
 + case None ⇒ 
 + log . warning ( " Key not found for projectId : { } " , projectId ) 
 + } 
 + } 
 + 
 + private object GooglePushDelivery { 
 + 
 + object Tick 
 + 
 + final case class Delivery ( m : GooglePushMessage , key : String , regId : String ) 
 + 
 + private val MaxQueue = 100000 
 + private val MaxConnections = 4 
 + 
 + def props = Props ( classOf [ GooglePushDelivery ] ) 
 + 
 + def flow ( implicit system : ActorSystem , mat : Materializer ) = 
 + Http ( system ) 
 + . cachedHostConnectionPoolTls [ GooglePushDelivery . Delivery ] ( 
 + " gcm - http . googleapis . com " , 
 + settings = ConnectionPoolSettings ( system ) . copy ( maxConnections = MaxConnections ) 
 + ) 
 + } 
 + 
 + private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] with ActorLogging { 
 + 
 + import GooglePushDelivery . _ 
 + 
 + private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] 
 + 
 + def receive = { 
 + case d : Delivery if buf . size = = MaxQueue ⇒ 
 + log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery " , MaxQueue ) 
 + case d : Delivery ⇒ 
 + if ( buf . isEmpty & & totalDemand > 0 ) 
 + onNext ( mkJob ( d ) ) 
 + else { 
 + this . buf : + = mkJob ( d ) 
 + deliverBuf ( ) 
 + } 
 + } 
 + 
 + @ tailrec def deliverBuf ( ) : Unit = 
 + if ( totalDemand > 0 ) { 
 + if ( totalDemand < = Int . MaxValue ) { 
 + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) 
 + buf = keep 
 + use foreach onNext 
 + } else { 
 + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) 
 + buf = keep 
 + use foreach onNext 
 + deliverBuf ( ) 
 + } 
 + } 
 + 
 + private def mkJob ( d : Delivery ) : ( HttpRequest , Delivery ) = 
 + HttpRequest ( 
 + method = HttpMethods . POST , 
 + uri = Uri ( " / gcm / send " ) , 
 + headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . regId } " , Map . empty [ String , String ] ) ) ) , 
 + entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . toString ( ) ) 
 + ) → d 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 index 1985d73 . . 8376311 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 @ @ - 1 , 29 + 1 , 16 @ @ 
 package im . actor . server . sequence 
 
 import akka . actor . ActorSystem 
 - import akka . event . Logging 
 - import com . google . android . gcm . server . { Sender , Message } 
 import im . actor . server . model . push . GooglePushCredentials 
 
 - import scala . concurrent . { ExecutionContext , Future , blocking } 
 - 
 private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : GooglePushManager , system : ActorSystem ) extends PushProvider { 
 - import system . dispatcher 
 - 
 - private val Retries = 3 
 - 
 - private val log = Logging ( system , getClass ) 
 - 
 def deliverInvisible ( seq : Int , creds : GooglePushCredentials ) : Unit = { 
 - withMgr ( creds . projectId ) { implicit mgr ⇒ 
 - val message = 
 - new Message . Builder ( ) 
 - . collapseKey ( s " seq - invisible - $ { userId . toString } " ) 
 - . addData ( " seq " , seq . toString ) 
 - . build ( ) 
 + val message = GooglePushMessage ( 
 + collapseKey = Some ( s " seq - invisible - $ { userId . toString } " ) , 
 + data = Some ( Map ( " seq " → seq . toString ) ) 
 + ) 
 
 - send ( message , creds . regId , Retries ) 
 - } 
 + googlePushManager . send ( creds . projectId , creds . regId , message ) 
 } 
 
 def deliverVisible ( 
 @ @ - 34 , 33 + 21 , 17 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : 
 isSoundEnabled : Boolean , 
 isVibrationEnabled : Boolean 
 ) : Unit = { 
 - withMgr ( creds . projectId ) { implicit mgr ⇒ 
 - val builder = new Message . Builder ( ) 
 - . collapseKey ( s " seq - visible - $ { userId . toString } " ) 
 - . addData ( " seq " , seq . toString ) 
 - 
 - val message = 
 + val message = GooglePushMessage ( 
 + collapseKey = Some ( s " seq - visible - $ { userId . toString } " ) , 
 + data = Some ( Map ( " seq " → seq . toString ) + + ( 
 data . text match { 
 case text if text . nonEmpty & & isTextEnabled ⇒ 
 - builder 
 - . addData ( " message " , text ) 
 - . build ( ) 
 - case _ ⇒ builder . build ( ) 
 + Map ( " message " → text ) 
 + case _ ⇒ Map . empty 
 } 
 + ) ) 
 + ) 
 
 - send ( message , creds . regId , Retries ) 
 - } 
 - } 
 - 
 - private def withMgr [ A ] ( projectId : Long ) ( f : Sender ⇒ A ) = 
 - googlePushManager . getInstance ( projectId ) match { 
 - case Some ( mgr ) ⇒ f ( mgr ) 
 - case None ⇒ log . warning ( " No google push configured for project - id : { } " , projectId ) 
 - } 
 - 
 - private def send ( message : Message , regId : String , retries : Int ) ( implicit mgr : Sender , ec : ExecutionContext ) : Unit = Future { 
 - blocking { 
 - mgr . send ( message , regId , Retries ) 
 - } 
 + googlePushManager . send ( creds . projectId , creds . regId , message ) 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 index c2ce0b7 . . 5a7b0cb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import akka . actor . _ 
 import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } 
 import akka . event . Logging 
 import akka . pattern . ask 
 + import akka . stream . ActorMaterializer 
 import akka . util . Timeout 
 import com . google . protobuf . ByteString 
 import im . actor . api . rpc . Update 
 @ @ - 239 , 6 + 240 , 8 @ @ object SeqUpdatesExtension extends ExtensionId [ SeqUpdatesExtension ] with Extensi 
 override def lookup = SeqUpdatesExtension 
 
 override def createExtension ( system : ExtendedActorSystem ) = { 
 + implicit val _ system = system 
 + implicit val mat = ActorMaterializer ( ) 
 val log = Logging ( system , getClass ) 
 
 try { 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 index 08827c4 . . c37af44 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 @ @ - 9 , 13 + 9 , 11 @ @ import akka . http . scaladsl . model . StatusCodes . OK 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . _ 
 import akka . stream . ActorMaterializer 
 - import akka . stream . scaladsl . Source 
 - import akka . util . ByteString 
 import im . actor . server . api . http . HttpHandler 
 import im . actor . server . file . local . { FileStorageOperations , LocalFileStorageConfig , RequestSigning } 
 import im . actor . util . log . AnyRefLogSource 
 
 - import scala . concurrent . { ExecutionContext , Future } 
 + import scala . concurrent . ExecutionContext 
 import scala . util . { Failure , Success } 
 
 private [ local ] final class FilesHttpHandler ( storageConfig : LocalFileStorageConfig ) ( implicit val system : ActorSystem ) 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index a259645 . . 5e32937 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 104 , 7 + 104 , 6 @ @ object Dependencies { 
 
 val tyrex = " tyrex " % " tyrex " % " 1 . 0 . 1 " 
 
 - val gcmServer = " com . google . android . gcm " % " gcm - server " % " 1 . 0 . 2 " 
 val pushy = " com . relayrides " % " pushy " % " 0 . 4 . 3 " 
 
 val logbackClassic = " ch . qos . logback " % " logback - classic " % " 1 . 1 . 2 " 
 @ @ - 167 , 7 + 166 , 6 @ @ object Dependencies { 
 akkaClusterSharding , 
 akkaDdata , 
 caffeine , 
 - gcmServer , 
 pushy , 
 jodaTime , 
 postgresJdbc ,
