BLEU SCORE: 0.07491281958423808

TEST MSG: fix ( server : messaging ) : load archived dialogs from eventsourced state
GENERATED MSG: feat ( server ) : ResumableProjection ; store message header in NewMessage , fixed GroupsServiceSpec

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 6b9c6c4 . . 549754f 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 143 , 6 + 143 , 17 @ @ message DialogRootQueries { < nl > message GetDialogsResponse { < nl > map < int64 , DialogInfo > dialogs = 1 ; < nl > } < nl > + < nl > + message GetArchivedDialogs { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootQuery " ; < nl > + google . protobuf . Int64Value offset = 1 ; < nl > + int32 limit = 2 ; < nl > + } < nl > + < nl > + message GetArchivedDialogsResponse { < nl > + map < int64 , DialogInfo > dialogs = 1 ; < nl > + google . protobuf . Int64Value nextOffset = 2 ; < nl > + } < nl > } < nl > < nl > message DialogStateSnapshot { < nl > @ @ - 159 , 6 + 170 , 7 @ @ message DialogRootEnvelope { < nl > DialogRootQueries . GetCounter get _ counter = 2 ; < nl > DialogRootQueries . GetDialogGroups get _ dialog _ groups = 3 ; < nl > DialogRootQueries . GetDialogs get _ dialogs = 10 ; < nl > + DialogRootQueries . GetArchivedDialogs get _ archived _ dialogs = 11 ; < nl > } < nl > oneof command { < nl > DialogRootCommands . Archive archive = 6 ; < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / api / TypeMappers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / api / TypeMappers . scala < nl > index 00adb05 . . d7e1e6b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / api / TypeMappers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / api / TypeMappers . scala < nl > @ @ - 2 , 8 + 2 , 9 @ @ package im . actor . server . api < nl > < nl > import java . time . Instant < nl > < nl > - import akka . actor . { ExtendedActorSystem , ActorSystem , ActorRef } < nl > + import akka . actor . { ActorRef , ActorSystem , ExtendedActorSystem } < nl > import akka . serialization . Serialization < nl > + import com . google . protobuf . wrappers . Int64Value < nl > import com . google . protobuf . { ByteString , CodedInputStream } < nl > import com . trueaccord . scalapb . TypeMapper < nl > import im . actor . api . rpc . files . ApiAvatar < nl > @ @ - 13 , 7 + 14 , 7 @ @ import im . actor . api . rpc . misc . ApiExtension < nl > import im . actor . api . rpc . peers . ApiPeer < nl > import im . actor . api . rpc . sequence . SeqUpdate < nl > import im . actor . api . rpc . users . ApiSex . ApiSex < nl > - import im . actor . api . rpc . users . { ApiSex ⇒ S , ApiUser } < nl > + import im . actor . api . rpc . users . { ApiUser , ApiSex ⇒ S } < nl > import im . actor . serialization . ActorSerializer < nl > import org . joda . time . DateTime < nl > < nl > @ @ - 85 , 6 + 86 , 10 @ @ private [ api ] trait MessageMapper { < nl > < nl > private def unapplyInstant ( dt : Instant ) : Long = dt . toEpochMilli < nl > < nl > + private def applyInstantOpt ( millis : Int64Value ) : Instant = Instant . ofEpochMilli ( millis . value ) < nl > + < nl > + private def unapplyInstantOpt ( dt : Instant ) : Int64Value = Int64Value ( dt . toEpochMilli ) < nl > + < nl > private def applyAvatar ( buf : ByteString ) : ApiAvatar = < nl > get ( ApiAvatar . parseFrom ( CodedInputStream . newInstance ( buf . asReadOnlyByteBuffer ( ) ) ) ) < nl > < nl > @ @ - 150 , 6 + 155 , 8 @ @ private [ api ] trait MessageMapper { < nl > < nl > implicit val instantMapper : TypeMapper [ Long , Instant ] = TypeMapper ( applyInstant ) ( unapplyInstant ) < nl > < nl > + implicit val instantOptMapper : TypeMapper [ Int64Value , Instant ] = TypeMapper ( applyInstantOpt ) ( unapplyInstantOpt ) < nl > + < nl > implicit val avatarMapper : TypeMapper [ ByteString , ApiAvatar ] = TypeMapper ( applyAvatar ) ( unapplyAvatar ) < nl > < nl > implicit val sexMapper : TypeMapper [ Int , ApiSex ] = TypeMapper ( applySex ) ( unapplySex ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 3e0cfa9 . . f064519 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 284 , 6 + 284 , 28 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > } yield dialogs < nl > } < nl > < nl > + def fetchArchivedDialogs ( userId : Int , offset : Option [ Array [ Byte ] ] , limit : Int ) : Future [ ( Map [ Instant , DialogInfo ] , Option [ Array [ Byte ] ] ) ] = { < nl > + ( processorRegion ( Peer . privat ( userId ) ) ? < nl > + UserEnvelope ( userId ) < nl > + . withDialogRootEnvelope ( DialogRootEnvelope ( ) < nl > + . withGetArchivedDialogs ( DialogRootQueries . GetArchivedDialogs ( offset map Int64Value . parseFrom , limit ) ) ) ) < nl > + . mapTo [ DialogRootQueries . GetArchivedDialogsResponse ] < nl > + . map { < nl > + case DialogRootQueries . GetArchivedDialogsResponse ( dialogs , nextOffset ) ⇒ < nl > + ( < nl > + dialogs . map { case ( date , dialog ) ⇒ Instant . ofEpochMilli ( date ) → dialog } , < nl > + nextOffset map ( _ . toByteArray ) < nl > + ) < nl > + } < nl > + } < nl > + < nl > + def fetchArchivedApiDialogs ( userId : Int , offset : Option [ Array [ Byte ] ] , limit : Int ) : Future [ ( Iterable [ ApiDialog ] , Option [ Array [ Byte ] ] ) ] = { < nl > + for { < nl > + ( infos , nextOffset ) ← fetchArchivedDialogs ( userId , offset , limit ) < nl > + dialogs ← Future . sequence ( infos map { case ( date , info ) ⇒ getApiDialog ( userId , info , date ) } ) < nl > + } yield ( dialogs , nextOffset ) < nl > + } < nl > + < nl > def getDialogInfo ( userId : Int , peer : Peer ) : Future [ DialogInfo ] = { < nl > ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withGetInfo ( DialogQueries . GetInfo ( Some ( peer ) ) ) ) ) < nl > . mapTo [ DialogQueries . GetInfoResponse ] < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 33c39fb . . bb2d139 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 35 , 7 + 35 , 7 @ @ trait DialogQuery { < nl > } < nl > < nl > private object UnreadMessage { < nl > - val ordering = new Ordering [ UnreadMessage ] { < nl > + val OrderingAsc = new Ordering [ UnreadMessage ] { < nl > override def compare ( x : UnreadMessage , y : UnreadMessage ) : Int = < nl > if ( x . randomId = = y . randomId ) 0 < nl > else if ( x . date . isBefore ( y . date ) ) - 1 < nl > @ @ - 53 , 7 + 53 , 7 @ @ private [ dialog ] object DialogState { < nl > lastReceiveDate = Instant . ofEpochMilli ( 0 ) , < nl > lastReadDate = Instant . ofEpochMilli ( 0 ) , < nl > counter = 0 , < nl > - unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) , < nl > + unreadMessages = SortedSet . empty ( UnreadMessage . OrderingAsc ) , < nl > unreadMessagesMap = Map . empty < nl > ) < nl > } < nl > @ @ - 93 , 7 + 93 , 7 @ @ private [ dialog ] final case class DialogState ( < nl > this . copy ( lastReadDate = date ) < nl > case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) < nl > case CounterReset ( ) ⇒ < nl > - this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) , unreadMessagesMap = Map . empty ) < nl > + this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . OrderingAsc ) , unreadMessagesMap = Map . empty ) < nl > } < nl > < nl > override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogState = snapshot match { < nl > @ @ - 108 , 7 + 108 , 7 @ @ private [ dialog ] final case class DialogState ( < nl > ( s . unreadMessages . toSeq map { < nl > case ( randomId , ts ) ⇒ UnreadMessage ( Instant . ofEpochMilli ( ts ) , randomId ) < nl > } ) : _ * < nl > - ) ( UnreadMessage . ordering ) , < nl > + ) ( UnreadMessage . OrderingAsc ) , < nl > unreadMessagesMap = s . unreadMessages < nl > ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index e5a0065 . . dacaf2d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 6 , 6 + 6 , 7 @ @ import akka . actor . { ActorRef , Props , Status } < nl > import akka . pattern . { ask , pipe } < nl > import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > + import com . google . protobuf . wrappers . Int64Value < nl > import im . actor . concurrent . _ < nl > import im . actor . server . cqrs . _ < nl > import im . actor . server . dialog . DialogCommands . { SendMessage , WriteMessageSelf } < nl > @ @ - 32 , 25 + 33 , 33 @ @ trait DialogRootCommand < nl > trait DialogRootQuery < nl > < nl > private object SortableDialog { < nl > - val ordering = new Ordering [ SortableDialog ] { < nl > + val OrderingAsc = new Ordering [ SortableDialog ] { < nl > override def compare ( x : SortableDialog , y : SortableDialog ) : Int = < nl > if ( x . peer = = y . peer ) 0 < nl > else if ( x . ts . isBefore ( y . ts ) ) - 1 < nl > else if ( x . ts . isAfter ( y . ts ) ) 1 < nl > else 0 < nl > } < nl > + < nl > + val OrderingDesc = new Ordering [ SortableDialog ] { < nl > + override def compare ( x : SortableDialog , y : SortableDialog ) : Int = < nl > + if ( x . peer = = y . peer ) 0 < nl > + else if ( x . ts . isBefore ( y . ts ) ) 1 < nl > + else if ( x . ts . isAfter ( y . ts ) ) - 1 < nl > + else 0 < nl > + } < nl > } < nl > < nl > private case class SortableDialog ( ts : Instant , peer : Peer ) < nl > < nl > private object DialogRootState { < nl > val initial = DialogRootState ( < nl > - Map ( < nl > - DialogGroupType . Groups → SortedSet . empty ( SortableDialog . ordering ) , < nl > - DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . ordering ) < nl > + active = Map ( < nl > + DialogGroupType . Groups → SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > + DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . OrderingAsc ) < nl > ) , < nl > - SortedSet . empty ( SortableDialog . ordering ) , < nl > - SortedSet . empty ( SortableDialog . ordering ) < nl > + activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > + archived = SortedSet . empty ( SortableDialog . OrderingDesc ) < nl > ) < nl > } < nl > < nl > @ @ - 74 , 7 + 83 , 7 @ @ private final case class DialogRootState ( < nl > val state = DialogRootState . initial . copy ( < nl > archived = SortedSet ( < nl > ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * < nl > - ) ( SortableDialog . ordering ) < nl > + ) ( SortableDialog . OrderingAsc ) < nl > ) < nl > < nl > dialogGroups . foldLeft ( state ) { < nl > @ @ - 142 , 7 + 151 , 7 @ @ private final case class DialogRootState ( < nl > private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = { < nl > val activeBase = < nl > if ( this . active . contains ( group ) ) this . active < nl > - else this . active + ( group → SortedSet . empty ( SortableDialog . ordering ) ) < nl > + else this . active + ( group → SortedSet . empty ( SortableDialog . OrderingAsc ) ) < nl > < nl > copy ( < nl > active = activeBase map { < nl > @ @ - 161 , 7 + 170 , 7 @ @ private final case class DialogRootState ( < nl > case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > } < nl > < nl > - group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . ordering ) ) + sortableDialog ) < nl > + group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . OrderingAsc ) ) + sortableDialog ) < nl > } < nl > } < nl > < nl > @ @ - 197 , 8 + 206 , 22 @ @ private trait DialogRootQueryHandlers { < nl > } < nl > < nl > for { < nl > - infoss ← Future . sequence ( dialogs map ( sd ⇒ getInfo ( sd . peer ) map ( sd . ts . toEpochMilli → _ . getInfo ) ) ) < nl > - } yield GetDialogsResponse ( infoss . toMap ) < nl > + infos ← Future . sequence ( dialogs map ( sd ⇒ getInfo ( sd . peer ) map ( sd . ts . toEpochMilli → _ . getInfo ) ) ) < nl > + } yield GetDialogsResponse ( infos . toMap ) < nl > + } < nl > + < nl > + def getArchivedDialogs ( offsetOpt : Option [ Int64Value ] , limit : Int ) : Future [ GetArchivedDialogsResponse ] = { < nl > + val dialogs = ( offsetOpt . map ( offset ⇒ Instant . ofEpochMilli ( offset . value ) ) match { < nl > + case None ⇒ state . archived < nl > + case Some ( offset ) ⇒ state . archived . dropWhile ( sd ⇒ sd . ts . isAfter ( offset ) | | sd . ts = = offset ) < nl > + } ) . take ( limit ) < nl > + < nl > + for { < nl > + infos ← Future . sequence ( dialogs map ( sd ⇒ getInfo ( sd . peer ) map ( sd . ts . toEpochMilli → _ . getInfo ) ) ) < nl > + } yield GetArchivedDialogsResponse ( < nl > + dialogs = infos . toMap , < nl > + nextOffset = infos . lastOption map ( tup ⇒ Int64Value ( tup . _ 1 ) ) < nl > + ) < nl > } < nl > < nl > def getDialogGroups ( ) : Future [ GetDialogGroupsResponse ] = < nl > @ @ - 241 , 9 + 264 , 10 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) < nl > override protected def getInitialState : DialogRootState = DialogRootState . initial < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > - case GetCounter ( ) ⇒ getCounter ( ) < nl > - case GetDialogGroups ( ) ⇒ getDialogGroups ( ) < nl > - case GetDialogs ( endDate , limit ) ⇒ getDialogs ( endDate , limit ) < nl > + case GetCounter ( ) ⇒ getCounter ( ) < nl > + case GetDialogGroups ( ) ⇒ getDialogGroups ( ) < nl > + case GetDialogs ( endDate , limit ) ⇒ getDialogs ( endDate , limit ) < nl > + case GetArchivedDialogs ( offset , limit ) ⇒ getArchivedDialogs ( offset , limit ) < nl > } < nl > < nl > override protected def handleCommand : Receive = { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index f29a53d . . 05ab925 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 2 , 7 + 2 , 6 @ @ package im . actor . server . api . rpc . service . messaging < nl > < nl > import java . time . Instant < nl > < nl > - import com . google . protobuf . wrappers . Int32Value < nl > import im . actor . api . rpc . PeerHelpers . _ < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . messaging . _ < nl > @ @ - 10 , 10 + 9 , 10 @ @ import im . actor . api . rpc . misc . { ResponseSeq , ResponseVoid } < nl > import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType } < nl > import im . actor . server . dialog . HistoryUtils < nl > import im . actor . server . group . GroupUtils < nl > - import im . actor . server . model . { DialogObsolete , HistoryMessage , Peer , PeerType } < nl > + import im . actor . server . model . { DialogObsolete , HistoryMessage , Peer } < nl > import im . actor . server . persist . contact . UserContactRepo < nl > - import im . actor . server . persist . { GroupUserRepo , HistoryMessageRepo } < nl > import im . actor . server . persist . dialog . DialogRepo < nl > + import im . actor . server . persist . { GroupUserRepo , HistoryMessageRepo } < nl > import im . actor . server . sequence . SeqState < nl > import im . actor . server . user . UserUtils < nl > import org . joda . time . DateTime < nl > @ @ - 26 , 9 + 25 , 9 @ @ import scala . language . postfixOps < nl > trait HistoryHandlers { < nl > self : MessagingServiceImpl ⇒ < nl > < nl > + import DBIOResultRpc . _ < nl > import HistoryUtils . _ < nl > import Implicits . _ < nl > - import DBIOResultRpc . _ < nl > < nl > override def doHandleMessageReceived ( peer : ApiOutPeer , date : Long , clientData : im . actor . api . rpc . ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > authorized ( clientData ) { client ⇒ < nl > @ @ - 68 , 20 + 67 , 17 @ @ trait HistoryHandlers { < nl > } < nl > } < nl > < nl > - override def doHandleLoadArchived ( nextOffset : Option [ Array [ Byte ] ] , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadArchived ] ] = < nl > + override def doHandleLoadArchived ( offset : Option [ Array [ Byte ] ] , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadArchived ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > - val offset = nextOffset map ( Int32Value . parseFrom ( _ ) . value ) getOrElse 0 < nl > - < nl > - db . run ( for { < nl > - models ← DialogRepo . fetchArchived ( client . userId , offset , limit ) < nl > - dialogs ← DBIO . sequence ( models map getDialogStruct ) map ( _ . flatten ) < nl > - ( users , groups ) ← getDialogsUsersGroups ( dialogs ) < nl > + for { < nl > + ( dialogs , nextOffset ) ← dialogExt . fetchArchivedApiDialogs ( client . userId , offset , limit ) < nl > + ( users , groups ) ← db . run ( getDialogsUsersGroups ( dialogs . toSeq ) ) < nl > } yield Ok ( ResponseLoadArchived ( < nl > groups . toVector , < nl > users . toVector , < nl > dialogs . toVector , < nl > - Some ( Int32Value ( offset + dialogs . length ) . toByteArray ) < nl > - ) ) ) < nl > + nextOffset < nl > + ) ) < nl > } < nl > < nl > override def doHandleLoadDialogs ( endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > index 7289ad0 . . e7c67fa 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > @ @ - 1 , 7 + 1 , 7 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > import im . actor . api . rpc . _ < nl > - import im . actor . api . rpc . messaging . { ApiDialogShort , ApiTextMessage , ResponseLoadGroupedDialogs } < nl > + import im . actor . api . rpc . messaging . { ApiDialogShort , ApiTextMessage , ResponseLoadArchived , ResponseLoadGroupedDialogs } < nl > import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeer , ApiPeerType } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > @ @ - 31 , 6 + 31 , 8 @ @ final class GroupedDialogsSpec < nl > " Favourited dialogs " should " appear on favourite " in appearFavourite < nl > it should " not be in grouped dialogs if no favourites left " in noGroupInFavAbsent < nl > < nl > + " Archived dialogs " should " be loaded by desc order " in archived < nl > + < nl > private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > private implicit lazy val service = MessagingServiceImpl ( ) < nl > < nl > @ @ - 256 , 4 + 258 , 42 @ @ final class GroupedDialogsSpec < nl > < nl > getDialogGroups ( ) . get ( DialogExtension . groupKey ( DialogGroupType . Favourites ) ) shouldBe empty < nl > } < nl > + < nl > + def archived ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + val ( eve , _ , _ , _ ) = createUser ( ) < nl > + val ( kira , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + val evePeer = getOutPeer ( eve . id , aliceAuthId ) < nl > + val kiraPeer = getOutPeer ( kira . id , aliceAuthId ) < nl > + < nl > + prepareDialogs ( bob , eve , kira ) < nl > + whenReady ( service . handleArchiveChat ( bobPeer ) ) ( identity ) < nl > + whenReady ( service . handleArchiveChat ( evePeer ) ) ( identity ) < nl > + whenReady ( service . handleArchiveChat ( kiraPeer ) ) ( identity ) < nl > + < nl > + val offset1 = whenReady ( service . handleLoadArchived ( None , 1 ) ) { resp ⇒ < nl > + val okResp = resp . toOption . get < nl > + okResp . dialogs . size shouldBe 1 < nl > + okResp . dialogs . head . peer . id shouldBe kiraPeer . id < nl > + okResp . nextOffset < nl > + } < nl > + < nl > + val offset2 = whenReady ( service . handleLoadArchived ( offset1 , 1 ) ) { resp ⇒ < nl > + val okResp = resp . toOption . get < nl > + okResp . dialogs . size shouldBe 1 < nl > + okResp . dialogs . head . peer . id shouldBe evePeer . id < nl > + okResp . nextOffset < nl > + } < nl > + < nl > + whenReady ( service . handleLoadArchived ( offset2 , 1 ) ) { resp ⇒ < nl > + val okResp = resp . toOption . get < nl > + okResp . dialogs . size shouldBe 1 < nl > + okResp . dialogs . head . peer . id shouldBe bobPeer . id < nl > + okResp . nextOffset < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > index f7cb830 . . 6afdaae 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > @ @ - 13 , 6 + 13 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > it should " sort dialogs by appearing " in show < nl > it should " remove Favourites on Unfavourite " in favouriteUnfavourite < nl > it should " remove from Archived on Favourite or new message " in removeFromArchived < nl > + it should " order archived by date desc " in archivedOrder < nl > < nl > import DialogRootEvents . _ < nl > < nl > @ @ - 75 , 6 + 76 , 18 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > checkSnapshot < nl > } < nl > < nl > + def archivedOrder ( ) = { < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + < nl > + val alice = Peer . privat ( 1 ) < nl > + val bob = Peer . privat ( 2 ) < nl > + < nl > + probe . commit ( Archived ( Instant . now , Some ( alice ) ) ) < nl > + probe . commit ( Archived ( Instant . now , Some ( bob ) ) ) < nl > + < nl > + getArchivedPeers should be ( Seq ( bob , alice ) ) < nl > + } < nl > + < nl > private def getGroupPeers ( typ : DialogGroupType ) ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = < nl > probe . state . active . get ( typ ) . get . toSeq . map ( _ . peer )
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / cqrs . proto b / actor - server / actor - core / src / main / protobuf / cqrs . proto < nl > new file mode 100644 < nl > index 0000000 . . 6c559c3 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / protobuf / cqrs . proto < nl > @ @ - 0 , 0 + 1 , 20 @ @ < nl > + syntax = " proto3 " ; < nl > + < nl > + package im . actor . server ; < nl > + < nl > + import " scalapb / scalapb . proto " ; < nl > + < nl > + message ResumableProjectionEvents { < nl > + message OffsetWritten { < nl > + option ( scalapb . message ) . extends = " im . actor . server . cqrs . Event " ; < nl > + < nl > + int64 offset = 1 ; < nl > + } < nl > + } < nl > + < nl > + message ResumableProjectionState { < nl > + option ( scalapb . message ) . extends = " im . actor . server . cqrs . ResumableProjectionStateBase " ; < nl > + < nl > + int64 offset = 1 ; < nl > + int32 hits = 2 ; < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 01c3afc . . b816596 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 295 , 6 + 295 , 7 @ @ message DialogEvents { < nl > int64 random _ id = 2 ; < nl > int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > int32 sender _ user _ id = 3 ; < nl > + int32 message _ header = 4 ; < nl > } < nl > < nl > message MessagesReceived { < nl > @ @ - 309 , 4 + 310 , 8 @ @ message DialogEvents { < nl > int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > int32 reader _ user _ id = 8 ; < nl > } < nl > + < nl > + message CounterReset { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > index 9f2b4eb . . b27c32b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import java . sql . SQLException < nl > < nl > import akka . actor . ActorLogging < nl > import akka . pattern . pipe < nl > - import akka . persistence . { PersistentActor , RecoveryCompleted } < nl > + import akka . persistence . { PersistentActor , RecoveryCompleted , SnapshotMetadata , SnapshotOffer } < nl > import im . actor . concurrent . AlertingActor < nl > < nl > import scala . concurrent . Future < nl > @ @ - 13 , 6 + 13 , 8 @ @ import scala . util . control . NoStackTrace < nl > < nl > trait ProcessorState [ S , E ] { < nl > def updated ( e : E ) : S < nl > + < nl > + def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : S < nl > } < nl > < nl > abstract class ProcessorError ( msg : String ) extends RuntimeException ( msg ) with NoStackTrace < nl > @ @ - 50 , 6 + 52 , 8 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] extends Persist < nl > override final def receiveRecover = { < nl > case e : E ⇒ < nl > _ state = _ state . updated ( e ) < nl > + case SnapshotOffer ( metadata , snapshot ) ⇒ < nl > + _ state = _ state . withSnapshot ( metadata , snapshot ) < nl > case RecoveryCompleted ⇒ onRecoveryCompleted ( ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala < nl > new file mode 100644 < nl > index 0000000 . . ada9106 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala < nl > @ @ - 0 , 0 + 1 , 89 @ @ < nl > + package im . actor . server . cqrs < nl > + < nl > + import akka . actor . { ActorRef , ActorRefFactory , PoisonPill , Props } < nl > + import akka . pattern . ask < nl > + import akka . http . scaladsl . util . FastFuture < nl > + import akka . persistence . SnapshotMetadata < nl > + import akka . util . Timeout < nl > + import im . actor . config . ActorConfig < nl > + import im . actor . serialization . ActorSerializer < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + object ResumableProjection { < nl > + ActorSerializer . register ( < nl > + 110001 → classOf [ ResumableProjectionEvents . OffsetWritten ] , < nl > + 110002 → classOf [ ResumableProjectionState ] < nl > + ) < nl > + < nl > + def apply ( id : String ) ( implicit factory : ActorRefFactory ) = new ResumableProjection ( id ) < nl > + < nl > + private [ cqrs ] val maxHits = 20 < nl > + } < nl > + < nl > + private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState , Event ] { < nl > + this : ResumableProjectionState ⇒ < nl > + < nl > + import ResumableProjectionEvents . _ < nl > + < nl > + override def updated ( e : Event ) : ResumableProjectionState = e match { < nl > + case ow : OffsetWritten ⇒ < nl > + copy ( offset = ow . offset , hits = hits + 1 ) < nl > + } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : ResumableProjectionState = snapshot match { < nl > + case s : ResumableProjectionState ⇒ s < nl > + } < nl > + } < nl > + < nl > + final class ResumableProjection ( id : String ) ( implicit factory : ActorRefFactory ) { < nl > + import factory . dispatcher < nl > + < nl > + private case class SaveOffset ( offset : Long ) < nl > + private object SaveOffsetAck < nl > + < nl > + private object GetOffset < nl > + private case class GetOffsetResponse ( offset : Long ) < nl > + < nl > + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) < nl > + < nl > + private var isStopped = false < nl > + < nl > + private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState , Event ] { < nl > + import ResumableProjectionEvents . _ < nl > + < nl > + override def persistenceId : String = s " RProj _ $ id " < nl > + < nl > + override protected def getInitialState : ResumableProjectionState = ResumableProjectionState ( 0L , 0 ) < nl > + < nl > + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > + case GetOffset ⇒ FastFuture . successful ( GetOffsetResponse ( state . offset ) ) < nl > + } < nl > + < nl > + override protected def handleCommand : Receive = { < nl > + case SaveOffset ( offset ) ⇒ persist ( OffsetWritten ( offset ) ) { e ⇒ < nl > + commit ( e ) < nl > + < nl > + if ( state . hits > 10 ) { < nl > + saveSnapshot ( state ) < nl > + setState ( state . copy ( hits = 0 ) ) < nl > + } < nl > + < nl > + sender ( ) ! SaveOffsetAck < nl > + } < nl > + } < nl > + } ) ) < nl > + < nl > + private def actor : ActorRef = < nl > + if ( isStopped ) throw new IllegalStateException ( " Projection is stopped " ) < nl > + else _ actor < nl > + < nl > + def latestOffset : Future [ Long ] = ( actor ? GetOffset ) . mapTo [ GetOffsetResponse ] map ( _ . offset ) < nl > + < nl > + def saveOffset ( offset : Long ) : Future [ Unit ] = ( actor ? SaveOffset ( offset ) ) map ( _ ⇒ ( ) ) < nl > + < nl > + def stop ( ) : Unit = { < nl > + actor ! PoisonPill < nl > + isStopped = true < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index e02e96e . . b8044bf 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 30 , 7 + 30 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > becomeStashing ( replyTo ⇒ ( { < nl > case seq : SeqStateDate ⇒ < nl > - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id ) ) { e ⇒ < nl > + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ < nl > commit ( e ) < nl > replyTo ! seq < nl > unstashAll ( ) < nl > @ @ - 70 , 7 + 70 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > throw new RuntimeException ( " No message date found in SendMessage " ) < nl > } < nl > < nl > - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id ) ) { e ⇒ < nl > + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ < nl > commit ( e ) < nl > < nl > if ( peer . typ = = PeerType . Private ) { < nl > @ @ - 97 , 7 + 97 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > sender ( ) ! Status . Failure ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) < nl > } else { < nl > - persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId ) ) { e ⇒ < nl > + persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId , message . header ) ) { e ⇒ < nl > commit ( e ) < nl > db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) < nl > . map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index ae2bb79 . . 9fdac80 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . server . dialog < nl > import java . time . Instant < nl > < nl > import akka . actor . _ < nl > + import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import com . github . benmanes . caffeine . cache . Cache < nl > import im . actor . api . rpc . misc . ApiExtension < nl > @ @ - 55 , 7 + 56 , 7 @ @ private [ dialog ] final case class DialogState ( < nl > import DialogEvents . _ < nl > < nl > override def updated ( e : DialogEvent ) : DialogState = e match { < nl > - case NewMessage ( randomId , date , senderUserId ) ⇒ < nl > + case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ < nl > if ( senderUserId ! = userId ) { < nl > this . copy ( < nl > counter = counter + 1 , < nl > @ @ - 69 , 7 + 70 , 10 @ @ private [ dialog ] final case class DialogState ( < nl > case MessagesRead ( date , readerUserId ) if readerUserId ! = userId & & date . isAfter ( lastReadDate ) ⇒ < nl > this . copy ( lastReadDate = date ) < nl > case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) < nl > + case CounterReset ( ) ⇒ this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) ) < nl > } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogState = this < nl > } < nl > < nl > object DialogProcessor { < nl > @ @ - 78 , 7 + 82 , 8 @ @ object DialogProcessor { < nl > ActorSerializer . register ( < nl > 40010 → classOf [ DialogEvents . MessagesRead ] , < nl > 40011 → classOf [ DialogEvents . MessagesReceived ] , < nl > - 40012 → classOf [ DialogEvents . NewMessage ] < nl > + 40012 → classOf [ DialogEvents . NewMessage ] , < nl > + 40013 → classOf [ DialogEvents . CounterReset ] < nl > ) < nl > } < nl > < nl > @ @ - 103 , 12 + 108 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > protected implicit val ec : ExecutionContext = context . dispatcher < nl > protected implicit val system : ActorSystem = context . system < nl > < nl > + protected implicit val timeout = Timeout ( 5 . seconds ) < nl > + < nl > protected val db : Database = DbExtension ( system ) . db < nl > protected val userExt = UserExtension ( system ) < nl > protected val groupExt = GroupExtension ( system ) < nl > protected implicit val socialRegion = SocialExtension ( system ) . region < nl > - protected implicit val timeout = Timeout ( 5 . seconds ) < nl > - < nl > protected val dialogExt = DialogExtension ( system ) < nl > protected val deliveryExt = dialogExt . getDeliveryExtension ( extensions ) < nl > protected val seqUpdExt = SeqUpdatesExtension ( context . system ) < nl > @ @ - 131 , 36 + 136 , 35 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > ) < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > - case GetCounter ( _ ) ⇒ < nl > - Future . successful ( GetCounterResponse ( state . counter ) ) < nl > - case GetInfo ( _ ) ⇒ Future . successful ( < nl > + case GetCounter ( _ ) ⇒ getCounter ( ) map ( GetCounterResponse ( _ ) ) < nl > + case GetInfo ( _ ) ⇒ getCounter ( ) map { counter ⇒ < nl > GetInfoResponse ( Some ( DialogInfo ( < nl > peer = Some ( peer ) , < nl > - counter = state . counter , < nl > + counter = counter , < nl > date = state . lastMessageDate , < nl > lastMessageDate = state . lastMessageDate , < nl > lastReceivedDate = state . lastReceiveDate , < nl > lastReadDate = state . lastReadDate < nl > ) ) ) < nl > - ) < nl > + } < nl > } < nl > < nl > override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) < nl > < nl > / / when receiving this messages , dialog reacts on other dialog ' s action < nl > def reactions ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received < nl > - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received < nl > + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) < nl > case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( rr ) < nl > } < nl > < nl > / / when receiving this messages , dialog is required to take an action < nl > def actions ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) < nl > case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) < nl > case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) < nl > @ @ - 191 , 4 + 195 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > * @ return does dialog owner accepts this command < nl > * / < nl > private def accepts ( dc : DirectDialogCommand ) = ( dc . getDest = = selfPeer ) | | ( ( dc . getDest = = peer ) & & ( dc . getOrigin ! = selfPeer ) ) < nl > + < nl > + private def getCounter ( ) : Future [ Int ] = { < nl > + groupExt . isMember ( peer . id , userId ) map { < nl > + case true ⇒ state . counter < nl > + case false ⇒ 0 < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index cf67226 . . 1a5a772 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant < nl > < nl > import akka . actor . { ActorRef , Props , Status } < nl > import akka . pattern . { ask , pipe } < nl > + import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import im . actor . concurrent . _ < nl > import im . actor . server . cqrs . _ < nl > @ @ - 57 , 6 + 58 , 8 @ @ private final case class DialogRootState ( < nl > case Unfavourited ( _ , Some ( peer ) ) ⇒ withUnfavouritedPeer ( peer ) < nl > } < nl > < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = this < nl > + < nl > private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > index 9ed906a . . 10f3bc3 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > @ @ - 114 , 6 + 114 , 9 @ @ private [ group ] sealed trait Queries { < nl > def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = < nl > ( viewRegion . ref ? GetMembers ( groupId ) ) . mapTo [ GetMembersResponse ] map ( r ⇒ ( r . memberIds , r . invitedUserIds , r . botId ) ) < nl > < nl > + def isMember ( groupId : Int , userId : Int ) : Future [ Boolean ] = < nl > + getMemberIds ( groupId ) map ( _ . _ 1 . contains ( userId ) ) < nl > + < nl > def getAccessHash ( groupId : Int ) : Future [ Long ] = < nl > ( viewRegion . ref ? GetAccessHash ( groupId ) ) . mapTo [ GetAccessHashResponse ] map ( _ . accessHash ) < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > index c9ce341 . . 23fda9a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > @ @ - 1 , 8 + 1 , 9 @ @ < nl > package im . actor . server . group < nl > < nl > - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } < nl > + import akka . actor . { Actor , ActorLogging , ActorSystem , Props } < nl > + import akka . persistence . SnapshotMetadata < nl > import im . actor . server . cqrs . ProcessorState < nl > - import im . actor . server . dialog . { DialogExtension , DialogCommands } < nl > + import im . actor . server . dialog . { DialogCommands , DialogExtension } < nl > < nl > import scala . concurrent . ExecutionContext < nl > < nl > @ @ - 21 , 6 + 22 , 8 @ @ private [ group ] case class GroupPeerState ( < nl > case LastReceiveDateChanged ( date ) ⇒ this . copy ( lastReceiveDate = date ) < nl > case LastReadDateChanged ( date ) ⇒ this . copy ( lastReadDate = date ) < nl > } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupPeerState = this < nl > } < nl > < nl > private [ group ] sealed trait GroupPeerEvent < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > index 2de0cd1 . . 29b1a4b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant < nl > < nl > import akka . actor . { ActorRefFactory , Props } < nl > import akka . pattern . ask < nl > + import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . users . UpdateUserLocalNameChanged < nl > import im . actor . server . cqrs . { Processor , ProcessorState } < nl > @ @ - 25 , 6 + 26 , 8 @ @ private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . em < nl > this . copy ( localNames = localNames + ( contactUserId → localName ) ) < nl > } < nl > } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : UserContactsState = this < nl > } < nl > < nl > private [ user ] final class UserContacts ( userId : Int ) ( implicit factory : ActorRefFactory ) { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > index 416b7cf . . 9e75b2c 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > @ @ - 862 , 7 + 862 , 7 @ @ final class GroupsServiceSpec < nl > < nl > whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > val dialog = resp . toOption . get . dialogs . head < nl > - dialog . unreadCount > 6 shouldEqual true < nl > + dialog . unreadCount should be > 6 < nl > } < nl > < nl > whenReady ( service . handleLeaveGroup ( groupOutPeer , Random . nextLong ( ) ) ) { resp ⇒ < nl > @ @ - 973 , 6 + 973 , 14 @ @ final class GroupsServiceSpec < nl > } < nl > val outPeer = ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) < nl > < nl > + { < nl > + implicit val clientData = clientData2 < nl > + whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > + val dialog = resp . toOption . get . dialogs . head < nl > + dialog . unreadCount shouldBe 2 < nl > + } < nl > + } < nl > + < nl > for ( _ ← 1 to 6 ) { < nl > implicit val clientData = clientData1 < nl > whenReady ( messagingService . handleSendMessage ( outPeer , Random . nextLong ( ) , ApiTextMessage ( " hello public " , Vector . empty , None ) , None ) ) { _ ⇒ } < nl > @ @ - 984 , 7 + 992 , 7 @ @ final class GroupsServiceSpec < nl > implicit val clientData = clientData2 < nl > whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > val dialog = resp . toOption . get . dialogs . head < nl > - dialog . unreadCount shouldBe 6 < nl > + dialog . unreadCount shouldBe 8 < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 6b9c6c4 . . 549754f 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 143 , 6 + 143 , 17 @ @ message DialogRootQueries { 
 message GetDialogsResponse { 
 map < int64 , DialogInfo > dialogs = 1 ; 
 } 
 + 
 + message GetArchivedDialogs { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootQuery " ; 
 + google . protobuf . Int64Value offset = 1 ; 
 + int32 limit = 2 ; 
 + } 
 + 
 + message GetArchivedDialogsResponse { 
 + map < int64 , DialogInfo > dialogs = 1 ; 
 + google . protobuf . Int64Value nextOffset = 2 ; 
 + } 
 } 
 
 message DialogStateSnapshot { 
 @ @ - 159 , 6 + 170 , 7 @ @ message DialogRootEnvelope { 
 DialogRootQueries . GetCounter get _ counter = 2 ; 
 DialogRootQueries . GetDialogGroups get _ dialog _ groups = 3 ; 
 DialogRootQueries . GetDialogs get _ dialogs = 10 ; 
 + DialogRootQueries . GetArchivedDialogs get _ archived _ dialogs = 11 ; 
 } 
 oneof command { 
 DialogRootCommands . Archive archive = 6 ; 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / api / TypeMappers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / api / TypeMappers . scala 
 index 00adb05 . . d7e1e6b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / api / TypeMappers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / api / TypeMappers . scala 
 @ @ - 2 , 8 + 2 , 9 @ @ package im . actor . server . api 
 
 import java . time . Instant 
 
 - import akka . actor . { ExtendedActorSystem , ActorSystem , ActorRef } 
 + import akka . actor . { ActorRef , ActorSystem , ExtendedActorSystem } 
 import akka . serialization . Serialization 
 + import com . google . protobuf . wrappers . Int64Value 
 import com . google . protobuf . { ByteString , CodedInputStream } 
 import com . trueaccord . scalapb . TypeMapper 
 import im . actor . api . rpc . files . ApiAvatar 
 @ @ - 13 , 7 + 14 , 7 @ @ import im . actor . api . rpc . misc . ApiExtension 
 import im . actor . api . rpc . peers . ApiPeer 
 import im . actor . api . rpc . sequence . SeqUpdate 
 import im . actor . api . rpc . users . ApiSex . ApiSex 
 - import im . actor . api . rpc . users . { ApiSex ⇒ S , ApiUser } 
 + import im . actor . api . rpc . users . { ApiUser , ApiSex ⇒ S } 
 import im . actor . serialization . ActorSerializer 
 import org . joda . time . DateTime 
 
 @ @ - 85 , 6 + 86 , 10 @ @ private [ api ] trait MessageMapper { 
 
 private def unapplyInstant ( dt : Instant ) : Long = dt . toEpochMilli 
 
 + private def applyInstantOpt ( millis : Int64Value ) : Instant = Instant . ofEpochMilli ( millis . value ) 
 + 
 + private def unapplyInstantOpt ( dt : Instant ) : Int64Value = Int64Value ( dt . toEpochMilli ) 
 + 
 private def applyAvatar ( buf : ByteString ) : ApiAvatar = 
 get ( ApiAvatar . parseFrom ( CodedInputStream . newInstance ( buf . asReadOnlyByteBuffer ( ) ) ) ) 
 
 @ @ - 150 , 6 + 155 , 8 @ @ private [ api ] trait MessageMapper { 
 
 implicit val instantMapper : TypeMapper [ Long , Instant ] = TypeMapper ( applyInstant ) ( unapplyInstant ) 
 
 + implicit val instantOptMapper : TypeMapper [ Int64Value , Instant ] = TypeMapper ( applyInstantOpt ) ( unapplyInstantOpt ) 
 + 
 implicit val avatarMapper : TypeMapper [ ByteString , ApiAvatar ] = TypeMapper ( applyAvatar ) ( unapplyAvatar ) 
 
 implicit val sexMapper : TypeMapper [ Int , ApiSex ] = TypeMapper ( applySex ) ( unapplySex ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 3e0cfa9 . . f064519 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 284 , 6 + 284 , 28 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 } yield dialogs 
 } 
 
 + def fetchArchivedDialogs ( userId : Int , offset : Option [ Array [ Byte ] ] , limit : Int ) : Future [ ( Map [ Instant , DialogInfo ] , Option [ Array [ Byte ] ] ) ] = { 
 + ( processorRegion ( Peer . privat ( userId ) ) ? 
 + UserEnvelope ( userId ) 
 + . withDialogRootEnvelope ( DialogRootEnvelope ( ) 
 + . withGetArchivedDialogs ( DialogRootQueries . GetArchivedDialogs ( offset map Int64Value . parseFrom , limit ) ) ) ) 
 + . mapTo [ DialogRootQueries . GetArchivedDialogsResponse ] 
 + . map { 
 + case DialogRootQueries . GetArchivedDialogsResponse ( dialogs , nextOffset ) ⇒ 
 + ( 
 + dialogs . map { case ( date , dialog ) ⇒ Instant . ofEpochMilli ( date ) → dialog } , 
 + nextOffset map ( _ . toByteArray ) 
 + ) 
 + } 
 + } 
 + 
 + def fetchArchivedApiDialogs ( userId : Int , offset : Option [ Array [ Byte ] ] , limit : Int ) : Future [ ( Iterable [ ApiDialog ] , Option [ Array [ Byte ] ] ) ] = { 
 + for { 
 + ( infos , nextOffset ) ← fetchArchivedDialogs ( userId , offset , limit ) 
 + dialogs ← Future . sequence ( infos map { case ( date , info ) ⇒ getApiDialog ( userId , info , date ) } ) 
 + } yield ( dialogs , nextOffset ) 
 + } 
 + 
 def getDialogInfo ( userId : Int , peer : Peer ) : Future [ DialogInfo ] = { 
 ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withGetInfo ( DialogQueries . GetInfo ( Some ( peer ) ) ) ) ) 
 . mapTo [ DialogQueries . GetInfoResponse ] 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 33c39fb . . bb2d139 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 35 , 7 + 35 , 7 @ @ trait DialogQuery { 
 } 
 
 private object UnreadMessage { 
 - val ordering = new Ordering [ UnreadMessage ] { 
 + val OrderingAsc = new Ordering [ UnreadMessage ] { 
 override def compare ( x : UnreadMessage , y : UnreadMessage ) : Int = 
 if ( x . randomId = = y . randomId ) 0 
 else if ( x . date . isBefore ( y . date ) ) - 1 
 @ @ - 53 , 7 + 53 , 7 @ @ private [ dialog ] object DialogState { 
 lastReceiveDate = Instant . ofEpochMilli ( 0 ) , 
 lastReadDate = Instant . ofEpochMilli ( 0 ) , 
 counter = 0 , 
 - unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) , 
 + unreadMessages = SortedSet . empty ( UnreadMessage . OrderingAsc ) , 
 unreadMessagesMap = Map . empty 
 ) 
 } 
 @ @ - 93 , 7 + 93 , 7 @ @ private [ dialog ] final case class DialogState ( 
 this . copy ( lastReadDate = date ) 
 case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) 
 case CounterReset ( ) ⇒ 
 - this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) , unreadMessagesMap = Map . empty ) 
 + this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . OrderingAsc ) , unreadMessagesMap = Map . empty ) 
 } 
 
 override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogState = snapshot match { 
 @ @ - 108 , 7 + 108 , 7 @ @ private [ dialog ] final case class DialogState ( 
 ( s . unreadMessages . toSeq map { 
 case ( randomId , ts ) ⇒ UnreadMessage ( Instant . ofEpochMilli ( ts ) , randomId ) 
 } ) : _ * 
 - ) ( UnreadMessage . ordering ) , 
 + ) ( UnreadMessage . OrderingAsc ) , 
 unreadMessagesMap = s . unreadMessages 
 ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index e5a0065 . . dacaf2d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 6 , 6 + 6 , 7 @ @ import akka . actor . { ActorRef , Props , Status } 
 import akka . pattern . { ask , pipe } 
 import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 + import com . google . protobuf . wrappers . Int64Value 
 import im . actor . concurrent . _ 
 import im . actor . server . cqrs . _ 
 import im . actor . server . dialog . DialogCommands . { SendMessage , WriteMessageSelf } 
 @ @ - 32 , 25 + 33 , 33 @ @ trait DialogRootCommand 
 trait DialogRootQuery 
 
 private object SortableDialog { 
 - val ordering = new Ordering [ SortableDialog ] { 
 + val OrderingAsc = new Ordering [ SortableDialog ] { 
 override def compare ( x : SortableDialog , y : SortableDialog ) : Int = 
 if ( x . peer = = y . peer ) 0 
 else if ( x . ts . isBefore ( y . ts ) ) - 1 
 else if ( x . ts . isAfter ( y . ts ) ) 1 
 else 0 
 } 
 + 
 + val OrderingDesc = new Ordering [ SortableDialog ] { 
 + override def compare ( x : SortableDialog , y : SortableDialog ) : Int = 
 + if ( x . peer = = y . peer ) 0 
 + else if ( x . ts . isBefore ( y . ts ) ) 1 
 + else if ( x . ts . isAfter ( y . ts ) ) - 1 
 + else 0 
 + } 
 } 
 
 private case class SortableDialog ( ts : Instant , peer : Peer ) 
 
 private object DialogRootState { 
 val initial = DialogRootState ( 
 - Map ( 
 - DialogGroupType . Groups → SortedSet . empty ( SortableDialog . ordering ) , 
 - DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . ordering ) 
 + active = Map ( 
 + DialogGroupType . Groups → SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 + DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . OrderingAsc ) 
 ) , 
 - SortedSet . empty ( SortableDialog . ordering ) , 
 - SortedSet . empty ( SortableDialog . ordering ) 
 + activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 + archived = SortedSet . empty ( SortableDialog . OrderingDesc ) 
 ) 
 } 
 
 @ @ - 74 , 7 + 83 , 7 @ @ private final case class DialogRootState ( 
 val state = DialogRootState . initial . copy ( 
 archived = SortedSet ( 
 ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * 
 - ) ( SortableDialog . ordering ) 
 + ) ( SortableDialog . OrderingAsc ) 
 ) 
 
 dialogGroups . foldLeft ( state ) { 
 @ @ - 142 , 7 + 151 , 7 @ @ private final case class DialogRootState ( 
 private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = { 
 val activeBase = 
 if ( this . active . contains ( group ) ) this . active 
 - else this . active + ( group → SortedSet . empty ( SortableDialog . ordering ) ) 
 + else this . active + ( group → SortedSet . empty ( SortableDialog . OrderingAsc ) ) 
 
 copy ( 
 active = activeBase map { 
 @ @ - 161 , 7 + 170 , 7 @ @ private final case class DialogRootState ( 
 case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 } 
 
 - group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . ordering ) ) + sortableDialog ) 
 + group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . OrderingAsc ) ) + sortableDialog ) 
 } 
 } 
 
 @ @ - 197 , 8 + 206 , 22 @ @ private trait DialogRootQueryHandlers { 
 } 
 
 for { 
 - infoss ← Future . sequence ( dialogs map ( sd ⇒ getInfo ( sd . peer ) map ( sd . ts . toEpochMilli → _ . getInfo ) ) ) 
 - } yield GetDialogsResponse ( infoss . toMap ) 
 + infos ← Future . sequence ( dialogs map ( sd ⇒ getInfo ( sd . peer ) map ( sd . ts . toEpochMilli → _ . getInfo ) ) ) 
 + } yield GetDialogsResponse ( infos . toMap ) 
 + } 
 + 
 + def getArchivedDialogs ( offsetOpt : Option [ Int64Value ] , limit : Int ) : Future [ GetArchivedDialogsResponse ] = { 
 + val dialogs = ( offsetOpt . map ( offset ⇒ Instant . ofEpochMilli ( offset . value ) ) match { 
 + case None ⇒ state . archived 
 + case Some ( offset ) ⇒ state . archived . dropWhile ( sd ⇒ sd . ts . isAfter ( offset ) | | sd . ts = = offset ) 
 + } ) . take ( limit ) 
 + 
 + for { 
 + infos ← Future . sequence ( dialogs map ( sd ⇒ getInfo ( sd . peer ) map ( sd . ts . toEpochMilli → _ . getInfo ) ) ) 
 + } yield GetArchivedDialogsResponse ( 
 + dialogs = infos . toMap , 
 + nextOffset = infos . lastOption map ( tup ⇒ Int64Value ( tup . _ 1 ) ) 
 + ) 
 } 
 
 def getDialogGroups ( ) : Future [ GetDialogGroupsResponse ] = 
 @ @ - 241 , 9 + 264 , 10 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) 
 override protected def getInitialState : DialogRootState = DialogRootState . initial 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 - case GetCounter ( ) ⇒ getCounter ( ) 
 - case GetDialogGroups ( ) ⇒ getDialogGroups ( ) 
 - case GetDialogs ( endDate , limit ) ⇒ getDialogs ( endDate , limit ) 
 + case GetCounter ( ) ⇒ getCounter ( ) 
 + case GetDialogGroups ( ) ⇒ getDialogGroups ( ) 
 + case GetDialogs ( endDate , limit ) ⇒ getDialogs ( endDate , limit ) 
 + case GetArchivedDialogs ( offset , limit ) ⇒ getArchivedDialogs ( offset , limit ) 
 } 
 
 override protected def handleCommand : Receive = { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index f29a53d . . 05ab925 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 2 , 7 + 2 , 6 @ @ package im . actor . server . api . rpc . service . messaging 
 
 import java . time . Instant 
 
 - import com . google . protobuf . wrappers . Int32Value 
 import im . actor . api . rpc . PeerHelpers . _ 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . messaging . _ 
 @ @ - 10 , 10 + 9 , 10 @ @ import im . actor . api . rpc . misc . { ResponseSeq , ResponseVoid } 
 import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType } 
 import im . actor . server . dialog . HistoryUtils 
 import im . actor . server . group . GroupUtils 
 - import im . actor . server . model . { DialogObsolete , HistoryMessage , Peer , PeerType } 
 + import im . actor . server . model . { DialogObsolete , HistoryMessage , Peer } 
 import im . actor . server . persist . contact . UserContactRepo 
 - import im . actor . server . persist . { GroupUserRepo , HistoryMessageRepo } 
 import im . actor . server . persist . dialog . DialogRepo 
 + import im . actor . server . persist . { GroupUserRepo , HistoryMessageRepo } 
 import im . actor . server . sequence . SeqState 
 import im . actor . server . user . UserUtils 
 import org . joda . time . DateTime 
 @ @ - 26 , 9 + 25 , 9 @ @ import scala . language . postfixOps 
 trait HistoryHandlers { 
 self : MessagingServiceImpl ⇒ 
 
 + import DBIOResultRpc . _ 
 import HistoryUtils . _ 
 import Implicits . _ 
 - import DBIOResultRpc . _ 
 
 override def doHandleMessageReceived ( peer : ApiOutPeer , date : Long , clientData : im . actor . api . rpc . ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 authorized ( clientData ) { client ⇒ 
 @ @ - 68 , 20 + 67 , 17 @ @ trait HistoryHandlers { 
 } 
 } 
 
 - override def doHandleLoadArchived ( nextOffset : Option [ Array [ Byte ] ] , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadArchived ] ] = 
 + override def doHandleLoadArchived ( offset : Option [ Array [ Byte ] ] , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadArchived ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 - val offset = nextOffset map ( Int32Value . parseFrom ( _ ) . value ) getOrElse 0 
 - 
 - db . run ( for { 
 - models ← DialogRepo . fetchArchived ( client . userId , offset , limit ) 
 - dialogs ← DBIO . sequence ( models map getDialogStruct ) map ( _ . flatten ) 
 - ( users , groups ) ← getDialogsUsersGroups ( dialogs ) 
 + for { 
 + ( dialogs , nextOffset ) ← dialogExt . fetchArchivedApiDialogs ( client . userId , offset , limit ) 
 + ( users , groups ) ← db . run ( getDialogsUsersGroups ( dialogs . toSeq ) ) 
 } yield Ok ( ResponseLoadArchived ( 
 groups . toVector , 
 users . toVector , 
 dialogs . toVector , 
 - Some ( Int32Value ( offset + dialogs . length ) . toByteArray ) 
 - ) ) ) 
 + nextOffset 
 + ) ) 
 } 
 
 override def doHandleLoadDialogs ( endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 index 7289ad0 . . e7c67fa 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 @ @ - 1 , 7 + 1 , 7 @ @ 
 package im . actor . server . api . rpc . service 
 
 import im . actor . api . rpc . _ 
 - import im . actor . api . rpc . messaging . { ApiDialogShort , ApiTextMessage , ResponseLoadGroupedDialogs } 
 + import im . actor . api . rpc . messaging . { ApiDialogShort , ApiTextMessage , ResponseLoadArchived , ResponseLoadGroupedDialogs } 
 import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeer , ApiPeerType } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 @ @ - 31 , 6 + 31 , 8 @ @ final class GroupedDialogsSpec 
 " Favourited dialogs " should " appear on favourite " in appearFavourite 
 it should " not be in grouped dialogs if no favourites left " in noGroupInFavAbsent 
 
 + " Archived dialogs " should " be loaded by desc order " in archived 
 + 
 private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 private implicit lazy val service = MessagingServiceImpl ( ) 
 
 @ @ - 256 , 4 + 258 , 42 @ @ final class GroupedDialogsSpec 
 
 getDialogGroups ( ) . get ( DialogExtension . groupKey ( DialogGroupType . Favourites ) ) shouldBe empty 
 } 
 + 
 + def archived ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + val ( eve , _ , _ , _ ) = createUser ( ) 
 + val ( kira , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + val evePeer = getOutPeer ( eve . id , aliceAuthId ) 
 + val kiraPeer = getOutPeer ( kira . id , aliceAuthId ) 
 + 
 + prepareDialogs ( bob , eve , kira ) 
 + whenReady ( service . handleArchiveChat ( bobPeer ) ) ( identity ) 
 + whenReady ( service . handleArchiveChat ( evePeer ) ) ( identity ) 
 + whenReady ( service . handleArchiveChat ( kiraPeer ) ) ( identity ) 
 + 
 + val offset1 = whenReady ( service . handleLoadArchived ( None , 1 ) ) { resp ⇒ 
 + val okResp = resp . toOption . get 
 + okResp . dialogs . size shouldBe 1 
 + okResp . dialogs . head . peer . id shouldBe kiraPeer . id 
 + okResp . nextOffset 
 + } 
 + 
 + val offset2 = whenReady ( service . handleLoadArchived ( offset1 , 1 ) ) { resp ⇒ 
 + val okResp = resp . toOption . get 
 + okResp . dialogs . size shouldBe 1 
 + okResp . dialogs . head . peer . id shouldBe evePeer . id 
 + okResp . nextOffset 
 + } 
 + 
 + whenReady ( service . handleLoadArchived ( offset2 , 1 ) ) { resp ⇒ 
 + val okResp = resp . toOption . get 
 + okResp . dialogs . size shouldBe 1 
 + okResp . dialogs . head . peer . id shouldBe bobPeer . id 
 + okResp . nextOffset 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 index f7cb830 . . 6afdaae 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 @ @ - 13 , 6 + 13 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 it should " sort dialogs by appearing " in show 
 it should " remove Favourites on Unfavourite " in favouriteUnfavourite 
 it should " remove from Archived on Favourite or new message " in removeFromArchived 
 + it should " order archived by date desc " in archivedOrder 
 
 import DialogRootEvents . _ 
 
 @ @ - 75 , 6 + 76 , 18 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 checkSnapshot 
 } 
 
 + def archivedOrder ( ) = { 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + 
 + val alice = Peer . privat ( 1 ) 
 + val bob = Peer . privat ( 2 ) 
 + 
 + probe . commit ( Archived ( Instant . now , Some ( alice ) ) ) 
 + probe . commit ( Archived ( Instant . now , Some ( bob ) ) ) 
 + 
 + getArchivedPeers should be ( Seq ( bob , alice ) ) 
 + } 
 + 
 private def getGroupPeers ( typ : DialogGroupType ) ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = 
 probe . state . active . get ( typ ) . get . toSeq . map ( _ . peer )

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / cqrs . proto b / actor - server / actor - core / src / main / protobuf / cqrs . proto 
 new file mode 100644 
 index 0000000 . . 6c559c3 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / protobuf / cqrs . proto 
 @ @ - 0 , 0 + 1 , 20 @ @ 
 + syntax = " proto3 " ; 
 + 
 + package im . actor . server ; 
 + 
 + import " scalapb / scalapb . proto " ; 
 + 
 + message ResumableProjectionEvents { 
 + message OffsetWritten { 
 + option ( scalapb . message ) . extends = " im . actor . server . cqrs . Event " ; 
 + 
 + int64 offset = 1 ; 
 + } 
 + } 
 + 
 + message ResumableProjectionState { 
 + option ( scalapb . message ) . extends = " im . actor . server . cqrs . ResumableProjectionStateBase " ; 
 + 
 + int64 offset = 1 ; 
 + int32 hits = 2 ; 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 01c3afc . . b816596 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 295 , 6 + 295 , 7 @ @ message DialogEvents { 
 int64 random _ id = 2 ; 
 int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 int32 sender _ user _ id = 3 ; 
 + int32 message _ header = 4 ; 
 } 
 
 message MessagesReceived { 
 @ @ - 309 , 4 + 310 , 8 @ @ message DialogEvents { 
 int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 int32 reader _ user _ id = 8 ; 
 } 
 + 
 + message CounterReset { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 index 9f2b4eb . . b27c32b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import java . sql . SQLException 
 
 import akka . actor . ActorLogging 
 import akka . pattern . pipe 
 - import akka . persistence . { PersistentActor , RecoveryCompleted } 
 + import akka . persistence . { PersistentActor , RecoveryCompleted , SnapshotMetadata , SnapshotOffer } 
 import im . actor . concurrent . AlertingActor 
 
 import scala . concurrent . Future 
 @ @ - 13 , 6 + 13 , 8 @ @ import scala . util . control . NoStackTrace 
 
 trait ProcessorState [ S , E ] { 
 def updated ( e : E ) : S 
 + 
 + def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : S 
 } 
 
 abstract class ProcessorError ( msg : String ) extends RuntimeException ( msg ) with NoStackTrace 
 @ @ - 50 , 6 + 52 , 8 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] extends Persist 
 override final def receiveRecover = { 
 case e : E ⇒ 
 _ state = _ state . updated ( e ) 
 + case SnapshotOffer ( metadata , snapshot ) ⇒ 
 + _ state = _ state . withSnapshot ( metadata , snapshot ) 
 case RecoveryCompleted ⇒ onRecoveryCompleted ( ) 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala 
 new file mode 100644 
 index 0000000 . . ada9106 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala 
 @ @ - 0 , 0 + 1 , 89 @ @ 
 + package im . actor . server . cqrs 
 + 
 + import akka . actor . { ActorRef , ActorRefFactory , PoisonPill , Props } 
 + import akka . pattern . ask 
 + import akka . http . scaladsl . util . FastFuture 
 + import akka . persistence . SnapshotMetadata 
 + import akka . util . Timeout 
 + import im . actor . config . ActorConfig 
 + import im . actor . serialization . ActorSerializer 
 + 
 + import scala . concurrent . Future 
 + 
 + object ResumableProjection { 
 + ActorSerializer . register ( 
 + 110001 → classOf [ ResumableProjectionEvents . OffsetWritten ] , 
 + 110002 → classOf [ ResumableProjectionState ] 
 + ) 
 + 
 + def apply ( id : String ) ( implicit factory : ActorRefFactory ) = new ResumableProjection ( id ) 
 + 
 + private [ cqrs ] val maxHits = 20 
 + } 
 + 
 + private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState , Event ] { 
 + this : ResumableProjectionState ⇒ 
 + 
 + import ResumableProjectionEvents . _ 
 + 
 + override def updated ( e : Event ) : ResumableProjectionState = e match { 
 + case ow : OffsetWritten ⇒ 
 + copy ( offset = ow . offset , hits = hits + 1 ) 
 + } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : ResumableProjectionState = snapshot match { 
 + case s : ResumableProjectionState ⇒ s 
 + } 
 + } 
 + 
 + final class ResumableProjection ( id : String ) ( implicit factory : ActorRefFactory ) { 
 + import factory . dispatcher 
 + 
 + private case class SaveOffset ( offset : Long ) 
 + private object SaveOffsetAck 
 + 
 + private object GetOffset 
 + private case class GetOffsetResponse ( offset : Long ) 
 + 
 + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) 
 + 
 + private var isStopped = false 
 + 
 + private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState , Event ] { 
 + import ResumableProjectionEvents . _ 
 + 
 + override def persistenceId : String = s " RProj _ $ id " 
 + 
 + override protected def getInitialState : ResumableProjectionState = ResumableProjectionState ( 0L , 0 ) 
 + 
 + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 + case GetOffset ⇒ FastFuture . successful ( GetOffsetResponse ( state . offset ) ) 
 + } 
 + 
 + override protected def handleCommand : Receive = { 
 + case SaveOffset ( offset ) ⇒ persist ( OffsetWritten ( offset ) ) { e ⇒ 
 + commit ( e ) 
 + 
 + if ( state . hits > 10 ) { 
 + saveSnapshot ( state ) 
 + setState ( state . copy ( hits = 0 ) ) 
 + } 
 + 
 + sender ( ) ! SaveOffsetAck 
 + } 
 + } 
 + } ) ) 
 + 
 + private def actor : ActorRef = 
 + if ( isStopped ) throw new IllegalStateException ( " Projection is stopped " ) 
 + else _ actor 
 + 
 + def latestOffset : Future [ Long ] = ( actor ? GetOffset ) . mapTo [ GetOffsetResponse ] map ( _ . offset ) 
 + 
 + def saveOffset ( offset : Long ) : Future [ Unit ] = ( actor ? SaveOffset ( offset ) ) map ( _ ⇒ ( ) ) 
 + 
 + def stop ( ) : Unit = { 
 + actor ! PoisonPill 
 + isStopped = true 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index e02e96e . . b8044bf 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 30 , 7 + 30 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 becomeStashing ( replyTo ⇒ ( { 
 case seq : SeqStateDate ⇒ 
 - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id ) ) { e ⇒ 
 + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ 
 commit ( e ) 
 replyTo ! seq 
 unstashAll ( ) 
 @ @ - 70 , 7 + 70 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 throw new RuntimeException ( " No message date found in SendMessage " ) 
 } 
 
 - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id ) ) { e ⇒ 
 + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ 
 commit ( e ) 
 
 if ( peer . typ = = PeerType . Private ) { 
 @ @ - 97 , 7 + 97 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 sender ( ) ! Status . Failure ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) 
 } else { 
 - persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId ) ) { e ⇒ 
 + persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId , message . header ) ) { e ⇒ 
 commit ( e ) 
 db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) 
 . map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index ae2bb79 . . 9fdac80 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . server . dialog 
 import java . time . Instant 
 
 import akka . actor . _ 
 + import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import com . github . benmanes . caffeine . cache . Cache 
 import im . actor . api . rpc . misc . ApiExtension 
 @ @ - 55 , 7 + 56 , 7 @ @ private [ dialog ] final case class DialogState ( 
 import DialogEvents . _ 
 
 override def updated ( e : DialogEvent ) : DialogState = e match { 
 - case NewMessage ( randomId , date , senderUserId ) ⇒ 
 + case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ 
 if ( senderUserId ! = userId ) { 
 this . copy ( 
 counter = counter + 1 , 
 @ @ - 69 , 7 + 70 , 10 @ @ private [ dialog ] final case class DialogState ( 
 case MessagesRead ( date , readerUserId ) if readerUserId ! = userId & & date . isAfter ( lastReadDate ) ⇒ 
 this . copy ( lastReadDate = date ) 
 case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) 
 + case CounterReset ( ) ⇒ this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) ) 
 } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogState = this 
 } 
 
 object DialogProcessor { 
 @ @ - 78 , 7 + 82 , 8 @ @ object DialogProcessor { 
 ActorSerializer . register ( 
 40010 → classOf [ DialogEvents . MessagesRead ] , 
 40011 → classOf [ DialogEvents . MessagesReceived ] , 
 - 40012 → classOf [ DialogEvents . NewMessage ] 
 + 40012 → classOf [ DialogEvents . NewMessage ] , 
 + 40013 → classOf [ DialogEvents . CounterReset ] 
 ) 
 } 
 
 @ @ - 103 , 12 + 108 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 protected implicit val ec : ExecutionContext = context . dispatcher 
 protected implicit val system : ActorSystem = context . system 
 
 + protected implicit val timeout = Timeout ( 5 . seconds ) 
 + 
 protected val db : Database = DbExtension ( system ) . db 
 protected val userExt = UserExtension ( system ) 
 protected val groupExt = GroupExtension ( system ) 
 protected implicit val socialRegion = SocialExtension ( system ) . region 
 - protected implicit val timeout = Timeout ( 5 . seconds ) 
 - 
 protected val dialogExt = DialogExtension ( system ) 
 protected val deliveryExt = dialogExt . getDeliveryExtension ( extensions ) 
 protected val seqUpdExt = SeqUpdatesExtension ( context . system ) 
 @ @ - 131 , 36 + 136 , 35 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 ) 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 - case GetCounter ( _ ) ⇒ 
 - Future . successful ( GetCounterResponse ( state . counter ) ) 
 - case GetInfo ( _ ) ⇒ Future . successful ( 
 + case GetCounter ( _ ) ⇒ getCounter ( ) map ( GetCounterResponse ( _ ) ) 
 + case GetInfo ( _ ) ⇒ getCounter ( ) map { counter ⇒ 
 GetInfoResponse ( Some ( DialogInfo ( 
 peer = Some ( peer ) , 
 - counter = state . counter , 
 + counter = counter , 
 date = state . lastMessageDate , 
 lastMessageDate = state . lastMessageDate , 
 lastReceivedDate = state . lastReceiveDate , 
 lastReadDate = state . lastReadDate 
 ) ) ) 
 - ) 
 + } 
 } 
 
 override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) 
 
 / / when receiving this messages , dialog reacts on other dialog ' s action 
 def reactions ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received 
 - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received 
 + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) 
 case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( rr ) 
 } 
 
 / / when receiving this messages , dialog is required to take an action 
 def actions ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) 
 case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) 
 case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) 
 @ @ - 191 , 4 + 195 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 * @ return does dialog owner accepts this command 
 * / 
 private def accepts ( dc : DirectDialogCommand ) = ( dc . getDest = = selfPeer ) | | ( ( dc . getDest = = peer ) & & ( dc . getOrigin ! = selfPeer ) ) 
 + 
 + private def getCounter ( ) : Future [ Int ] = { 
 + groupExt . isMember ( peer . id , userId ) map { 
 + case true ⇒ state . counter 
 + case false ⇒ 0 
 + } 
 + } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index cf67226 . . 1a5a772 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant 
 
 import akka . actor . { ActorRef , Props , Status } 
 import akka . pattern . { ask , pipe } 
 + import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import im . actor . concurrent . _ 
 import im . actor . server . cqrs . _ 
 @ @ - 57 , 6 + 58 , 8 @ @ private final case class DialogRootState ( 
 case Unfavourited ( _ , Some ( peer ) ) ⇒ withUnfavouritedPeer ( peer ) 
 } 
 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = this 
 + 
 private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 index 9ed906a . . 10f3bc3 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 @ @ - 114 , 6 + 114 , 9 @ @ private [ group ] sealed trait Queries { 
 def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = 
 ( viewRegion . ref ? GetMembers ( groupId ) ) . mapTo [ GetMembersResponse ] map ( r ⇒ ( r . memberIds , r . invitedUserIds , r . botId ) ) 
 
 + def isMember ( groupId : Int , userId : Int ) : Future [ Boolean ] = 
 + getMemberIds ( groupId ) map ( _ . _ 1 . contains ( userId ) ) 
 + 
 def getAccessHash ( groupId : Int ) : Future [ Long ] = 
 ( viewRegion . ref ? GetAccessHash ( groupId ) ) . mapTo [ GetAccessHashResponse ] map ( _ . accessHash ) 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 index c9ce341 . . 23fda9a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 @ @ - 1 , 8 + 1 , 9 @ @ 
 package im . actor . server . group 
 
 - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } 
 + import akka . actor . { Actor , ActorLogging , ActorSystem , Props } 
 + import akka . persistence . SnapshotMetadata 
 import im . actor . server . cqrs . ProcessorState 
 - import im . actor . server . dialog . { DialogExtension , DialogCommands } 
 + import im . actor . server . dialog . { DialogCommands , DialogExtension } 
 
 import scala . concurrent . ExecutionContext 
 
 @ @ - 21 , 6 + 22 , 8 @ @ private [ group ] case class GroupPeerState ( 
 case LastReceiveDateChanged ( date ) ⇒ this . copy ( lastReceiveDate = date ) 
 case LastReadDateChanged ( date ) ⇒ this . copy ( lastReadDate = date ) 
 } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupPeerState = this 
 } 
 
 private [ group ] sealed trait GroupPeerEvent 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 index 2de0cd1 . . 29b1a4b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant 
 
 import akka . actor . { ActorRefFactory , Props } 
 import akka . pattern . ask 
 + import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import im . actor . api . rpc . users . UpdateUserLocalNameChanged 
 import im . actor . server . cqrs . { Processor , ProcessorState } 
 @ @ - 25 , 6 + 26 , 8 @ @ private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . em 
 this . copy ( localNames = localNames + ( contactUserId → localName ) ) 
 } 
 } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : UserContactsState = this 
 } 
 
 private [ user ] final class UserContacts ( userId : Int ) ( implicit factory : ActorRefFactory ) { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 index 416b7cf . . 9e75b2c 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 @ @ - 862 , 7 + 862 , 7 @ @ final class GroupsServiceSpec 
 
 whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 val dialog = resp . toOption . get . dialogs . head 
 - dialog . unreadCount > 6 shouldEqual true 
 + dialog . unreadCount should be > 6 
 } 
 
 whenReady ( service . handleLeaveGroup ( groupOutPeer , Random . nextLong ( ) ) ) { resp ⇒ 
 @ @ - 973 , 6 + 973 , 14 @ @ final class GroupsServiceSpec 
 } 
 val outPeer = ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) 
 
 + { 
 + implicit val clientData = clientData2 
 + whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 + val dialog = resp . toOption . get . dialogs . head 
 + dialog . unreadCount shouldBe 2 
 + } 
 + } 
 + 
 for ( _ ← 1 to 6 ) { 
 implicit val clientData = clientData1 
 whenReady ( messagingService . handleSendMessage ( outPeer , Random . nextLong ( ) , ApiTextMessage ( " hello public " , Vector . empty , None ) , None ) ) { _ ⇒ } 
 @ @ - 984 , 7 + 992 , 7 @ @ final class GroupsServiceSpec 
 implicit val clientData = clientData2 
 whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 val dialog = resp . toOption . get . dialogs . head 
 - dialog . unreadCount shouldBe 6 
 + dialog . unreadCount shouldBe 8 
 } 
 }
