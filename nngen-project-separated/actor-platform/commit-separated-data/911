BLEU SCORE: 0.0844991782262014

TEST MSG: fix ( server : eventbus ) : eventbus fixes
GENERATED MSG: feat ( * ) : invalidate all sessions on AuthId invalidation

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala < nl > index fa4ae6e . . 88f1938 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala < nl > @ @ - 72 , 7 + 72 , 7 @ @ final class EventBusMediator extends Actor with ActorLogging { < nl > object consumers { < nl > private val a2d = mutable . Map . empty [ AuthId , ( UserId , DeviceId ) ] < nl > private val d2a = mutable . Map . empty [ DeviceId , ( UserId , AuthId ) ] < nl > - private val ownerAuthIds = mutable . Set . empty [ AuthId ] < nl > + val ownerAuthIds = mutable . Set . empty [ AuthId ] < nl > private val a2timeouts = mutable . Map . empty [ AuthId , Cancellable ] < nl > < nl > def isOwnerConnected = ownerAuthIds . nonEmpty < nl > @ @ - 108 , 11 + 108 , 6 @ @ final class EventBusMediator extends Actor with ActorLogging { < nl > } < nl > } < nl > < nl > - override def postStop ( ) : Unit = { < nl > - super . postStop ( ) < nl > - internalConsumers foreach ( _ ! EventBus . Disposed ( id ) ) < nl > - } < nl > - < nl > def receive = { < nl > case Create ( clientUserId , clientAuthId , timeoutOpt , isOwned ) ⇒ < nl > if ( isOwned . contains ( true ) ) this . owner = Some ( clientUserId ) < nl > @ @ - 152 , 16 + 147 , 16 @ @ final class EventBusMediator extends Actor with ActorLogging { < nl > case None ⇒ consumers . stopKeepAlive ( clientAuthId ) < nl > } < nl > case ConsumerTimedOut ( authId ) ⇒ < nl > - consumers . remove ( authId ) match { < nl > - case Some ( ( userId , deviceId ) ) ⇒ < nl > - broadcast ( UpdateEventBusDeviceDisconnected ( id , userId , deviceId ) ) < nl > - < nl > - if ( ( owner . isDefined & & ! consumers . isOwnerConnected ) | | consumers . isEmpty ) { < nl > - broadcast ( UpdateEventBusDisposed ( id ) ) < nl > - context stop self < nl > - } < nl > - case None ⇒ < nl > - log . error ( " ConsumerTimedOut with unknown authId : { } " , authId ) < nl > + if ( ( owner . isDefined & & consumers . ownerAuthIds = = Set ( authId ) ) | | consumers . authIds = = Set ( authId ) ) { < nl > + log . debug ( " Disposing " ) < nl > + broadcast ( UpdateEventBusDisposed ( id ) ) < nl > + context stop self < nl > + } else { < nl > + consumers . remove ( authId ) match { < nl > + case Some ( ( userId , deviceId ) ) ⇒ < nl > + broadcast ( UpdateEventBusDeviceDisconnected ( id , userId , deviceId ) ) < nl > + case None ⇒ log . error ( " Consumer timed out with unknown authId : { } " , authId ) < nl > + } < nl > } < nl > case Join ( clientUserId , clientAuthId , timeoutOpt ) ⇒ < nl > val deviceId = Random . nextLong ( ) < nl > @ @ - 171 , 7 + 166 , 6 @ @ final class EventBusMediator extends Actor with ActorLogging { < nl > sender ( ) ! JoinAck ( deviceId ) < nl > case Dispose ( clientUserId ) ⇒ < nl > if ( owner . contains ( clientUserId ) ) { < nl > - broadcast ( UpdateEventBusDisposed ( id ) ) < nl > context stop self < nl > } else sender ( ) ! Status . Failure ( new RuntimeException ( " Attempt to dispose by not an owner " ) ) < nl > case Subscribe ( ref ) ⇒ < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala < nl > index c1afcf0 . . f23c7f1 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala < nl > @ @ - 25 , 7 + 25 , 7 @ @ abstract class BaseAppSuite ( _ system : ActorSystem = { < nl > with ActorSerializerPrepare { < nl > < nl > protected implicit val materializer : ActorMaterializer = ActorMaterializer ( ) < nl > - protected implicit lazy val ec : ExecutionContext = _ system . dispatcher < nl > + implicit lazy val ec : ExecutionContext = _ system . dispatcher < nl > < nl > protected implicit lazy val db : PostgresDriver . api . Database = { < nl > DbExtension ( _ system ) . clean ( ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ImplicitSessionRegion . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ImplicitSessionRegion . scala < nl > index 186b737 . . c57ce48 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / ImplicitSessionRegion . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ImplicitSessionRegion . scala < nl > @ @ - 9 , 5 + 9 , 5 @ @ trait ImplicitSessionRegion { < nl > protected implicit val materializer : Materializer < nl > < nl > private implicit lazy val config = SessionConfig . load ( system . settings . config . getConfig ( " session " ) ) < nl > - protected implicit lazy val sessionRegion : SessionRegion = Session . startRegion ( Session . props ) < nl > + implicit lazy val sessionRegion : SessionRegion = Session . startRegion ( Session . props ) < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / eventbus / EventbusServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / eventbus / EventbusServiceSpec . scala < nl > index f0b8285 . . 5610cc3 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / eventbus / EventbusServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / eventbus / EventbusServiceSpec . scala < nl > @ @ - 1 , 25 + 1 , 44 @ @ < nl > package im . actor . server . api . rpc . service . eventbus < nl > < nl > - import im . actor . api . rpc . eventbus . { ApiEventBusDestination , ResponseCreateNewEventBus } < nl > + import akka . testkit . TestProbe < nl > + import im . actor . api . rpc . eventbus . _ < nl > + import im . actor . server . mtproto . protocol . SessionHello < nl > + import im . actor . server . session . SessionSpecHelpers < nl > import im . actor . server . { SeqUpdateMatchers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } < nl > import im . actor . api . rpc . _ < nl > < nl > - final class EventbusServiceSpec extends BaseAppSuite with ImplicitAuthService with ImplicitSessionRegion with SeqUpdateMatchers { < nl > + import scala . util . Random < nl > + < nl > + final class EventbusServiceSpec < nl > + extends BaseAppSuite < nl > + with ImplicitAuthService < nl > + with ImplicitSessionRegion < nl > + with SeqUpdateMatchers < nl > + with SessionSpecHelpers { < nl > it should " broadcast messages " in broadcast < nl > < nl > lazy val service = new EventbusServiceImpl ( system ) < nl > < nl > def broadcast ( ) = { < nl > + val aliceProbe = TestProbe ( ) < nl > + val bobProbe = TestProbe ( ) < nl > + < nl > val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val aliceSessionId = 1L < nl > + val bobSessionId = 2L < nl > + < nl > + val aliceClientData = ClientData ( aliceAuthId , aliceSessionId , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobClientData = ClientData ( bobAuthId , bobSessionId , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > < nl > - val aliceClientData = ClientData ( aliceAuthId , 1L , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > - val bobClientData = ClientData ( bobAuthId , 1L , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > + sendMessageBox ( aliceAuthId , aliceSessionId , sessionRegion . ref , Random . nextLong ( ) , SessionHello ) ( aliceProbe ) < nl > + ignoreNewSession ( ) ( aliceProbe ) < nl > + expectMessageAck ( ) ( aliceProbe ) < nl > < nl > val ( id , aliceDeviceId ) = { < nl > implicit val clientData = aliceClientData < nl > < nl > - whenReady ( service . handleCreateNewEventBus ( None , None ) ) { < nl > + whenReady ( service . handleCreateNewEventBus ( Some ( 1000 ) , Some ( true ) ) ) { < nl > case Ok ( ResponseCreateNewEventBus ( id , deviceId ) ) ⇒ ( id , deviceId ) < nl > } < nl > } < nl > @ @ - 33 , 5 + 52 , 12 @ @ final class EventbusServiceSpec extends BaseAppSuite with ImplicitAuthService wi < nl > < nl > service . handlePostToEventBus ( id , Vector ( ApiEventBusDestination ( alice . id , Vector ( aliceDeviceId ) ) ) , Array [ Byte ] ( 123 ) ) < nl > } < nl > + < nl > + expectWeakUpdate ( aliceAuthId , aliceSessionId ) ( aliceProbe ) . updateHeader shouldBe UpdateEventBusDeviceConnected . header < nl > + expectWeakUpdate ( aliceAuthId , aliceSessionId ) ( aliceProbe ) . updateHeader shouldBe UpdateEventBusMessage . header < nl > + < nl > + Thread . sleep ( 1000 ) < nl > + < nl > + expectWeakUpdate ( aliceAuthId , aliceSessionId ) ( aliceProbe ) . updateHeader shouldBe UpdateEventBusDisposed . header < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > index 0e88019 . . 83c5071 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > @ @ - 1 , 31 + 1 , 22 @ @ < nl > package im . actor . server . session < nl > < nl > import akka . actor . _ < nl > - import akka . testkit . TestProbe < nl > - import com . google . protobuf . ByteString < nl > - import im . actor . api . rpc . codecs . _ < nl > - import im . actor . api . rpc . sequence . { FatSeqUpdate , SeqUpdate , WeakUpdate } < nl > - import im . actor . api . rpc . { Request , RpcRequest , RpcResult } < nl > import im . actor . server < nl > import im . actor . server . _ < nl > + import im . actor . server . api . rpc . RpcApiExtension < nl > import im . actor . server . api . rpc . service . auth . AuthServiceImpl < nl > import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl < nl > import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } < nl > - import im . actor . server . api . rpc . { RpcApiExtension , RpcResultCodec } < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec < nl > - import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } < nl > - import im . actor . server . session . SessionEnvelope . Payload < nl > import org . scalatest . concurrent . ScalaFutures < nl > import org . scalatest . time . { Seconds , Span } < nl > import org . scalatest . { FlatSpecLike , Matchers } < nl > - import scodec . bits . BitVector < nl > import slick . driver . PostgresDriver < nl > < nl > + import scala . concurrent . Await < nl > import scala . concurrent . duration . _ < nl > - import scala . concurrent . { Await , Future , blocking } < nl > import scala . util . Random < nl > < nl > abstract class BaseSessionSpec ( _ system : ActorSystem = { < nl > @ @ - 36 , 12 + 27 , 13 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { < nl > with ScalaFutures < nl > with Matchers < nl > with ActorSerializerPrepare < nl > - with ServiceSpecHelpers { < nl > + with ServiceSpecHelpers < nl > + with SessionSpecHelpers { < nl > < nl > override implicit def patienceConfig : PatienceConfig = < nl > new PatienceConfig ( timeout = Span ( 10 , Seconds ) ) < nl > < nl > - protected implicit val ec = system . dispatcher < nl > + implicit val ec = system . dispatcher < nl > < nl > protected implicit lazy val db : PostgresDriver . api . Database = { < nl > DbExtension ( _ system ) . db < nl > @ @ - 54 , 7 + 46 , 7 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { < nl > < nl > Session . startRegion ( Session . props ) < nl > < nl > - protected implicit val sessionRegion = Session . startRegionProxy ( ) < nl > + implicit val sessionRegion = Session . startRegionProxy ( ) < nl > < nl > protected val oauthGoogleConfig = OAuth2GoogleConfig . load ( system . settings . config . getConfig ( " services . google . oauth " ) ) < nl > protected implicit val oauth2Service = new GoogleProvider ( oauthGoogleConfig ) < nl > @ @ - 73 , 148 + 65 , 4 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { < nl > Await . result ( db . run ( persist . AuthIdRepo . create ( authId , None , None ) ) , 1 . second ) < nl > authId < nl > } < nl > - < nl > - protected def expectSeqUpdate ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : SeqUpdate = < nl > - expectUpdateBox ( classOf [ SeqUpdate ] , authId , sessionId , sendAckAt ) < nl > - < nl > - protected def expectFatSeqUpdate ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : FatSeqUpdate = < nl > - expectUpdateBox ( classOf [ FatSeqUpdate ] , authId , sessionId , sendAckAt ) < nl > - < nl > - protected def expectWeakUpdate ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : WeakUpdate = < nl > - expectUpdateBox ( classOf [ WeakUpdate ] , authId , sessionId , None ) < nl > - < nl > - protected def expectUpdateBox [ T < : im . actor . api . rpc . UpdateBox ] ( clazz : Class [ T ] , authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] ) ( implicit probe : TestProbe , m : Manifest [ T ] ) : T = { < nl > - val mb = expectMessageBox ( ) < nl > - < nl > - val update = UpdateBoxCodec . decode ( mb . body . asInstanceOf [ ProtoPush ] . bodyBytes ) . require . value < nl > - < nl > - sendAckAt map { delay ⇒ < nl > - Future { < nl > - blocking { < nl > - Thread . sleep ( delay . toMillis ) < nl > - sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong , MessageAck ( Vector ( mb . messageId ) ) ) < nl > - } < nl > - } < nl > - } < nl > - < nl > - update shouldBe a [ T ] < nl > - < nl > - update . asInstanceOf [ T ] < nl > - } < nl > - < nl > - protected def expectRpcResult ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) , expectAckFor : Set [ Long ] = Set . empty ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : RpcResult = { < nl > - val messages = probe . receiveN ( 1 + expectAckFor . size , patienceConfig . timeout . totalNanos . nano ) . toSet < nl > - < nl > - if ( messages . size ! = expectAckFor . size + 1 ) { < nl > - fail ( s " Expected response and acks for $ { expectAckFor . mkString ( " , " ) } , got : $ { messages . mkString ( " , " ) } " ) < nl > - } else { < nl > - val ( rest , ackIds ) = messages . foldLeft ( Vector . empty [ ( Long , ProtoMessage ) ] , Set . empty [ Long ] ) { < nl > - case ( ( rest , ackIds ) , mbBytes : BitVector ) ⇒ < nl > - val mb = MessageBoxCodec . decode ( mbBytes ) . require . value < nl > - < nl > - mb . body match { < nl > - case MessageAck ( ids ) ⇒ ( rest , ackIds + + ids ) < nl > - case body ⇒ ( rest : + ( ( mb . messageId , body ) ) , ackIds ) < nl > - } < nl > - } < nl > - < nl > - ackIds shouldEqual expectAckFor < nl > - < nl > - rest match { < nl > - case Vector ( ( messageId , ProtoRpcResponse ( _ , rpcResultBytes ) ) ) ⇒ < nl > - sendAckAt map { delay ⇒ < nl > - Future { < nl > - blocking { < nl > - Thread . sleep ( delay . toMillis ) < nl > - sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong , MessageAck ( Vector ( messageId ) ) ) < nl > - } < nl > - } < nl > - } < nl > - < nl > - RpcResultCodec . decode ( rpcResultBytes ) . require . value < nl > - case unexpected ⇒ throw new Exception ( s " Expected RpcResponseBox but got $ unexpected " ) < nl > - } < nl > - } < nl > - } < nl > - < nl > - protected def expectMessageAck ( ) ( implicit probe : TestProbe ) : MessageAck = { < nl > - val mb = expectMessageBox ( ) < nl > - mb . body shouldBe a [ MessageAck ] < nl > - < nl > - val ack = mb . body . asInstanceOf [ MessageAck ] < nl > - ack < nl > - } < nl > - < nl > - protected def expectMessageAck ( messageId : Long ) ( implicit probe : TestProbe ) : MessageAck = { < nl > - val mb = expectMessageBox ( ) < nl > - mb . body shouldBe a [ MessageAck ] < nl > - < nl > - val ack = mb . body . asInstanceOf [ MessageAck ] < nl > - ack . messageIds should = = = ( Vector ( messageId ) ) < nl > - ack < nl > - } < nl > - < nl > - protected def expectNewSession ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : NewSession = { < nl > - expectMessageBoxPF ( ) { < nl > - case mb @ MessageBox ( _ , NewSession ( sid , mid ) ) ⇒ < nl > - sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , MessageAck ( Vector ( mb . messageId ) ) ) < nl > - < nl > - val ns = mb . body . asInstanceOf [ NewSession ] < nl > - ns should = = = ( NewSession ( sessionId , messageId ) ) < nl > - ns < nl > - } < nl > - } < nl > - < nl > - protected def ignoreNewSession ( ) ( implicit probe : TestProbe ) : Unit = { < nl > - probe . ignoreMsg { < nl > - case body : BitVector ⇒ < nl > - MessageBoxCodec . decode ( body ) . require . value . body . isInstanceOf [ NewSession ] < nl > - case _ ⇒ false < nl > - } < nl > - } < nl > - < nl > - protected def expectMessageBoxPF [ T ] ( hint : String = " " ) ( pf : PartialFunction [ MessageBox , T ] ) ( implicit probe : TestProbe ) : T = { < nl > - probe . expectMsgPF ( max = patienceConfig . timeout . totalNanos . nano ) { < nl > - case body : BitVector ⇒ < nl > - val mb = MessageBoxCodec . decode ( body ) . require . value < nl > - < nl > - assert ( pf . isDefinedAt ( mb ) , s " expected : $ hint but got $ mb " ) < nl > - pf ( mb ) < nl > - } < nl > - } < nl > - < nl > - protected def expectMessageBox ( ) ( implicit probe : TestProbe ) : MessageBox = { < nl > - val packageBody = probe . expectMsgPF ( max = patienceConfig . timeout . totalNanos . nano ) { < nl > - case body : BitVector ⇒ body < nl > - } < nl > - < nl > - MessageBoxCodec . decode ( packageBody ) . require . value < nl > - } < nl > - < nl > - protected def sendMessageBox ( authId : Long , sessionId : Long , session : ActorRef , messageId : Long , body : ProtoMessage ) ( implicit probe : TestProbe ) = < nl > - sendEnvelope ( authId , sessionId , session , Payload . HandleMessageBox ( handleMessageBox ( messageId , body ) ) ) < nl > - < nl > - protected def handleMessageBox ( messageId : Long , body : ProtoMessage ) = < nl > - HandleMessageBox ( ByteString . copyFrom ( MessageBoxCodec . encode ( MessageBox ( messageId , body ) ) . require . toByteBuffer ) ) < nl > - < nl > - protected def sendEnvelope ( authId : Long , sessionId : Long , session : ActorRef , payload : Payload ) ( implicit probe : TestProbe ) = { < nl > - session . tell ( < nl > - SessionEnvelope ( < nl > - authId , < nl > - sessionId < nl > - ) . withPayload ( payload ) , < nl > - probe . ref < nl > - ) < nl > - } < nl > - < nl > - protected def sendRequest ( authId : Long , sessionId : Long , session : ActorRef , messageId : Long , request : RpcRequest ) ( implicit probe : TestProbe ) : Unit = { < nl > - val rqBox = ProtoRpcRequest ( RequestCodec . encode ( Request ( request ) ) . require ) < nl > - sendMessageBox ( authId , sessionId , session , messageId , rqBox ) < nl > - } < nl > - < nl > - protected def sendRequest ( authId : Long , sessionId : Long , session : ActorRef , request : RpcRequest ) ( implicit probe : TestProbe ) : Long = { < nl > - val messageId = Random . nextLong ( ) < nl > - sendRequest ( authId , sessionId , session , messageId , request ) < nl > - messageId < nl > - } < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > new file mode 100644 < nl > index 0000000 . . 0a7b511 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > @ @ - 0 , 0 + 1 , 170 @ @ < nl > + package im . actor . server . session < nl > + < nl > + import akka . actor . { ActorSystem , ActorRef } < nl > + import akka . testkit . TestProbe < nl > + import com . google . protobuf . ByteString < nl > + import im . actor . api . rpc . { Request , RpcRequest , RpcResult } < nl > + import im . actor . api . rpc . codecs . _ < nl > + import im . actor . api . rpc . sequence . { WeakUpdate , FatSeqUpdate , SeqUpdate } < nl > + import im . actor . server . api . rpc . RpcResultCodec < nl > + import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec < nl > + import im . actor . server . mtproto . protocol . _ < nl > + import im . actor . server . session . SessionEnvelope . Payload < nl > + import org . scalatest . Matchers < nl > + import org . scalatest . concurrent . AbstractPatienceConfiguration < nl > + import scodec . bits . BitVector < nl > + < nl > + import scala . concurrent . _ < nl > + import scala . concurrent . duration . _ < nl > + import scala . util . Random < nl > + < nl > + trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { < nl > + < nl > + val system : ActorSystem < nl > + val sessionRegion : SessionRegion < nl > + implicit val ec : ExecutionContext < nl > + < nl > + protected def expectSeqUpdate ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : SeqUpdate = < nl > + expectUpdateBox ( classOf [ SeqUpdate ] , authId , sessionId , sendAckAt ) < nl > + < nl > + protected def expectFatSeqUpdate ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : FatSeqUpdate = < nl > + expectUpdateBox ( classOf [ FatSeqUpdate ] , authId , sessionId , sendAckAt ) < nl > + < nl > + protected def expectWeakUpdate ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : WeakUpdate = < nl > + expectUpdateBox ( classOf [ WeakUpdate ] , authId , sessionId , None ) < nl > + < nl > + protected def expectUpdateBox [ T < : im . actor . api . rpc . UpdateBox ] ( clazz : Class [ T ] , authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] ) ( implicit probe : TestProbe , m : Manifest [ T ] ) : T = { < nl > + val mb = expectMessageBox ( ) < nl > + < nl > + val update = UpdateBoxCodec . decode ( mb . body . asInstanceOf [ ProtoPush ] . bodyBytes ) . require . value < nl > + < nl > + sendAckAt map { delay ⇒ < nl > + Future { < nl > + blocking { < nl > + Thread . sleep ( delay . toMillis ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong , MessageAck ( Vector ( mb . messageId ) ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + update shouldBe a [ T ] < nl > + < nl > + update . asInstanceOf [ T ] < nl > + } < nl > + < nl > + protected def expectRpcResult ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) , expectAckFor : Set [ Long ] = Set . empty ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : RpcResult = { < nl > + val messages = probe . receiveN ( 1 + expectAckFor . size , patienceConfig . timeout . totalNanos . nano ) . toSet < nl > + < nl > + if ( messages . size ! = expectAckFor . size + 1 ) { < nl > + fail ( s " Expected response and acks for $ { expectAckFor . mkString ( " , " ) } , got : $ { messages . mkString ( " , " ) } " ) < nl > + } else { < nl > + val ( rest , ackIds ) = messages . foldLeft ( Vector . empty [ ( Long , ProtoMessage ) ] , Set . empty [ Long ] ) { < nl > + case ( ( rest , ackIds ) , mbBytes : BitVector ) ⇒ < nl > + val mb = MessageBoxCodec . decode ( mbBytes ) . require . value < nl > + < nl > + mb . body match { < nl > + case MessageAck ( ids ) ⇒ ( rest , ackIds + + ids ) < nl > + case body ⇒ ( rest : + ( ( mb . messageId , body ) ) , ackIds ) < nl > + } < nl > + } < nl > + < nl > + ackIds shouldEqual expectAckFor < nl > + < nl > + rest match { < nl > + case Vector ( ( messageId , ProtoRpcResponse ( _ , rpcResultBytes ) ) ) ⇒ < nl > + sendAckAt map { delay ⇒ < nl > + Future { < nl > + blocking { < nl > + Thread . sleep ( delay . toMillis ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong , MessageAck ( Vector ( messageId ) ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + RpcResultCodec . decode ( rpcResultBytes ) . require . value < nl > + case unexpected ⇒ throw new Exception ( s " Expected RpcResponseBox but got $ unexpected " ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + protected def expectMessageAck ( ) ( implicit probe : TestProbe ) : MessageAck = { < nl > + val mb = expectMessageBox ( ) < nl > + mb . body shouldBe a [ MessageAck ] < nl > + < nl > + val ack = mb . body . asInstanceOf [ MessageAck ] < nl > + ack < nl > + } < nl > + < nl > + protected def expectMessageAck ( messageId : Long ) ( implicit probe : TestProbe ) : MessageAck = { < nl > + val mb = expectMessageBox ( ) < nl > + mb . body shouldBe a [ MessageAck ] < nl > + < nl > + val ack = mb . body . asInstanceOf [ MessageAck ] < nl > + ack . messageIds should = = = ( Vector ( messageId ) ) < nl > + ack < nl > + } < nl > + < nl > + protected def expectNewSession ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : NewSession = { < nl > + expectMessageBoxPF ( ) { < nl > + case mb @ MessageBox ( _ , NewSession ( sid , mid ) ) ⇒ < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , MessageAck ( Vector ( mb . messageId ) ) ) < nl > + < nl > + val ns = mb . body . asInstanceOf [ NewSession ] < nl > + ns should = = = ( NewSession ( sessionId , messageId ) ) < nl > + ns < nl > + } < nl > + } < nl > + < nl > + protected def ignoreNewSession ( ) ( implicit probe : TestProbe ) : Unit = { < nl > + probe . ignoreMsg { < nl > + case body : BitVector ⇒ < nl > + MessageBoxCodec . decode ( body ) . require . value . body . isInstanceOf [ NewSession ] < nl > + case _ ⇒ false < nl > + } < nl > + } < nl > + < nl > + protected def expectMessageBoxPF [ T ] ( hint : String = " " ) ( pf : PartialFunction [ MessageBox , T ] ) ( implicit probe : TestProbe ) : T = { < nl > + probe . expectMsgPF ( max = patienceConfig . timeout . totalNanos . nano ) { < nl > + case body : BitVector ⇒ < nl > + val mb = MessageBoxCodec . decode ( body ) . require . value < nl > + < nl > + assert ( pf . isDefinedAt ( mb ) , s " expected : $ hint but got $ mb " ) < nl > + pf ( mb ) < nl > + } < nl > + } < nl > + < nl > + protected def expectMessageBox ( ) ( implicit probe : TestProbe ) : MessageBox = { < nl > + val packageBody = probe . expectMsgPF ( max = patienceConfig . timeout . totalNanos . nano ) { < nl > + case body : BitVector ⇒ body < nl > + } < nl > + < nl > + MessageBoxCodec . decode ( packageBody ) . require . value < nl > + } < nl > + < nl > + protected def sendMessageBox ( authId : Long , sessionId : Long , session : ActorRef , messageId : Long , body : ProtoMessage ) ( implicit probe : TestProbe ) = < nl > + sendEnvelope ( authId , sessionId , session , Payload . HandleMessageBox ( handleMessageBox ( messageId , body ) ) ) < nl > + < nl > + protected def handleMessageBox ( messageId : Long , body : ProtoMessage ) = < nl > + HandleMessageBox ( ByteString . copyFrom ( MessageBoxCodec . encode ( MessageBox ( messageId , body ) ) . require . toByteBuffer ) ) < nl > + < nl > + protected def sendEnvelope ( authId : Long , sessionId : Long , session : ActorRef , payload : Payload ) ( implicit probe : TestProbe ) = { < nl > + session . tell ( < nl > + SessionEnvelope ( < nl > + authId , < nl > + sessionId < nl > + ) . withPayload ( payload ) , < nl > + probe . ref < nl > + ) < nl > + } < nl > + < nl > + protected def sendRequest ( authId : Long , sessionId : Long , session : ActorRef , messageId : Long , request : RpcRequest ) ( implicit probe : TestProbe ) : Unit = { < nl > + val rqBox = ProtoRpcRequest ( RequestCodec . encode ( Request ( request ) ) . require ) < nl > + sendMessageBox ( authId , sessionId , session , messageId , rqBox ) < nl > + } < nl > + < nl > + protected def sendRequest ( authId : Long , sessionId : Long , session : ActorRef , request : RpcRequest ) ( implicit probe : TestProbe ) : Long = { < nl > + val messageId = Random . nextLong ( ) < nl > + sendRequest ( authId , sessionId , session , messageId , request ) < nl > + messageId < nl > + } < nl > + } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > index 08f08ac . . e66d34f 100644 < nl > - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > @ @ - 5 , 7 + 5 , 7 @ @ import scala . concurrent . duration . _ < nl > import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scalaz . _ < nl > < nl > - import akka . actor . ActorSystem < nl > + import akka . actor . { ActorRef , ActorSystem } < nl > import akka . event . Logging < nl > import akka . util . Timeout < nl > import org . joda . time . DateTime < nl > @ @ - 27 , 7 + 27 , 24 @ @ import im . actor . server . util . PhoneNumber . normalizeWithCountry < nl > import im . actor . server . util . _ < nl > import im . actor . server . { models , persist } < nl > < nl > - class AuthServiceImpl ( activationContext : ActivationContext ) ( < nl > + sealed trait AuthEvent < nl > + < nl > + object AuthEvents { < nl > + case object AuthIdInvalidated extends AuthEvent < nl > + } < nl > + < nl > + object AuthService { < nl > + import akka . contrib . pattern . DistributedPubSubMediator . _ < nl > + import AuthEvents . _ < nl > + < nl > + def authIdTopic ( authId : Long ) : String = s " auth . events . $ { authId } " < nl > + < nl > + private [ auth ] def publishAuthIdInvalidated ( mediator : ActorRef , authId : Long ) : Unit = { < nl > + mediator ! Publish ( authIdTopic ( authId ) , AuthIdInvalidated ) < nl > + } < nl > + } < nl > + < nl > + class AuthServiceImpl ( activationContext : ActivationContext , mediator : ActorRef ) ( < nl > implicit < nl > val sessionRegion : SessionRegion , < nl > val seqUpdatesManagerRegion : SeqUpdatesManagerRegion , < nl > @ @ - 142 , 14 + 159 , 6 @ @ class AuthServiceImpl ( activationContext : ActivationContext ) ( < nl > throw new Exception ( " Not implemented " ) < nl > } < nl > < nl > - override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > - val action = requireAuth ( clientData ) map { implicit client ⇒ < nl > - DBIO . successful ( Ok ( misc . ResponseVoid ) ) < nl > - } < nl > - < nl > - db . run ( toDBIOAction ( action ) ) < nl > - } < nl > - < nl > override def jhandleSignIn ( < nl > rawPhoneNumber : Long , < nl > smsHash : String , < nl > @ @ - 299 , 6 + 308 , 18 @ @ class AuthServiceImpl ( activationContext : ActivationContext ) ( < nl > } < nl > } < nl > < nl > + override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > + val action = requireAuth ( clientData ) map { implicit client ⇒ < nl > + persist . AuthSession . findByAuthId ( client . authId ) flatMap { < nl > + case Some ( session ) ⇒ < nl > + for ( _ ← logout ( session ) ) yield Ok ( misc . ResponseVoid ) < nl > + case None ⇒ throw new Exception ( s " Cannot find AuthSession for authId : $ { client . authId } " ) < nl > + } < nl > + } < nl > + < nl > + db . run ( toDBIOAction ( action ) ) < nl > + } < nl > + < nl > override def jhandleTerminateAllSessions ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { client ⇒ < nl > for { < nl > @ @ - 371 , 7 + 392 , 9 @ @ class AuthServiceImpl ( activationContext : ActivationContext ) ( < nl > for { < nl > _ ← persist . AuthSession . delete ( session . userId , session . id ) < nl > _ ← persist . AuthId . delete ( session . authId ) < nl > - } yield ( ) < nl > + } yield { < nl > + AuthService . publishAuthIdInvalidated ( mediator , session . authId ) < nl > + } < nl > } < nl > < nl > private def sendSmsCode ( authId : Long , phoneNumber : Long , code : String ) : Unit = { < nl > diff - - git a / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > index 05bb462 . . f5ea5fb 100644 < nl > - - - a / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > + + + b / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > @ @ - 2 , 13 + 2 , 15 @ @ package im . actor . server . session < nl > < nl > import java . util . concurrent . TimeUnit < nl > < nl > + import im . actor . server . api . rpc . service . auth . { AuthEvents , AuthService } < nl > + < nl > import scala . collection . immutable < nl > import scala . concurrent . ExecutionContext < nl > import scala . concurrent . duration . _ < nl > < nl > import akka . actor . _ < nl > import akka . contrib . pattern . ShardRegion . Passivate < nl > - import akka . contrib . pattern . { ClusterSharding , ShardRegion } < nl > + import akka . contrib . pattern . { DistributedPubSubMediator , ClusterSharding , ShardRegion } < nl > import akka . stream . FlowMaterializer < nl > import akka . stream . actor . _ < nl > import akka . stream . scaladsl . _ < nl > @ @ - 60 , 7 + 62 , 7 @ @ object Session { < nl > < nl > def startRegionProxy ( ) ( implicit system : ActorSystem ) : SessionRegion = startRegion ( None ) < nl > < nl > - def props ( < nl > + def props ( mediator : ActorRef ) ( < nl > implicit < nl > config : SessionConfig , < nl > seqUpdManagerRegion : SeqUpdatesManagerRegion , < nl > @ @ - 72 , 6 + 74 , 7 @ @ object Session { < nl > ) : Props = < nl > Props ( < nl > classOf [ Session ] , < nl > + mediator , < nl > config , < nl > seqUpdManagerRegion , < nl > weakUpdManagerRegion , < nl > @ @ - 82 , 7 + 85 , 7 @ @ object Session { < nl > ) < nl > } < nl > < nl > - class Session ( < nl > + class Session ( mediator : ActorRef ) ( < nl > implicit < nl > config : SessionConfig , < nl > seqUpdManagerRegion : SeqUpdatesManagerRegion , < nl > @ @ - 114 , 9 + 117 , 12 @ @ class Session ( < nl > def waitingForEnvelope : Receive = { < nl > case env @ Envelope ( authId , sessionId , _ ) ⇒ < nl > val replyTo = sender ( ) < nl > - < nl > stash ( ) < nl > - context . become ( waitingForSessionInfo ) < nl > + < nl > + val subscribe = DistributedPubSubMediator . Subscribe ( AuthService . authIdTopic ( authId ) , self ) < nl > + mediator ! subscribe < nl > + < nl > + context . become ( waitingForSessionInfo ( authId , sessionId , subscribe ) ) < nl > < nl > / / TODO : handle errors < nl > / / TODO : refactor < nl > @ @ - 141 , 21 + 147 , 30 @ @ class Session ( < nl > infoFuture map { < nl > case Some ( info ) ⇒ self ! info < nl > case None ⇒ < nl > + log . warning ( " Reporting AuthIdInvalid and dying " ) < nl > replyTo ! MTPackage ( authId , sessionId , MessageBoxCodec . encode ( MessageBox ( Long . MaxValue , AuthIdInvalid ) ) . require ) < nl > - self ! PoisonPill / / TODO : AuthIdInvalid < nl > + self ! PoisonPill < nl > } < nl > case msg ⇒ stash ( ) < nl > } < nl > < nl > - def waitingForSessionInfo : Receive = { < nl > + def waitingForSessionInfo ( authId : Long , sessionId : Long , subscribe : DistributedPubSubMediator . Subscribe ) : Receive = { < nl > case info : models . SessionInfo ⇒ < nl > optUserId = info . optUserId < nl > unstashAll ( ) < nl > - context . become ( anonymous ) < nl > + context . become ( waitingForSubscribeAck ( authId , sessionId , subscribe ) ) < nl > case msg ⇒ stash ( ) < nl > } < nl > < nl > - def anonymous : Receive = { < nl > + def waitingForSubscribeAck ( authId : Long , sessionId : Long , subscribe : DistributedPubSubMediator . Subscribe ) : Receive = { < nl > + case msg if msg = = DistributedPubSubMediator . SubscribeAck ( subscribe ) ⇒ < nl > + unstashAll ( ) < nl > + context . become ( anonymous ( authId , sessionId ) ) < nl > + case msg ⇒ < nl > + stash ( ) < nl > + } < nl > + < nl > + def anonymous ( authId : Long , sessionId : Long ) : Receive = { < nl > case env @ Envelope ( authId , sessionId , HandleMessageBox ( messageBoxBytes ) ) ⇒ < nl > val client = sender ( ) < nl > < nl > @ @ - 165 , 7 + 180 , 7 @ @ class Session ( < nl > val updatesHandler = context . actorOf ( UpdatesHandler . props ( authId ) , " updatesHandler " ) < nl > val reSender = context . actorOf ( ReSender . props ( authId , sessionId ) ( config . reSendConfig ) , " reSender " ) < nl > < nl > - val graph = SessionStream . graph ( authId , sessionId , mb . messageId , rpcHandler , updatesHandler , reSender ) < nl > + val graph = SessionStream . graph ( authId , sessionId , rpcHandler , updatesHandler , reSender ) < nl > < nl > val flow = FlowGraph . closed ( graph ) { implicit b ⇒ g ⇒ < nl > import FlowGraph . Implicits . _ < nl > @ @ - 191 , 7 + 206 , 7 @ @ class Session ( < nl > < nl > context . become ( resolved ( authId , sessionId , sessionMessagePublisher , reSender ) ) < nl > } < nl > - case internal ⇒ handleInternal ( internal ) < nl > + case internal ⇒ handleInternal ( authId , sessionId , internal ) < nl > } < nl > < nl > def resolved ( authId : Long , sessionId : Long , publisher : ActorRef , reSender : ActorRef ) : Receive = { < nl > @ @ - 202 , 7 + 217 , 7 @ @ class Session ( < nl > log . error ( " Received Envelope with another ' s authId and sessionId { } " , env ) < nl > else < nl > handleSessionMessage ( authId , sessionId , client , msg , publisher , reSender ) < nl > - case internal ⇒ handleInternal ( internal ) < nl > + case internal ⇒ handleInternal ( authId , sessionId , internal ) < nl > } < nl > < nl > private def recordClient ( client : ActorRef , reSender : ActorRef ) : Unit = { < nl > @ @ - 256 , 8 + 271 , 10 @ @ class Session ( < nl > } < nl > } < nl > < nl > - private def handleInternal ( message : Any ) = < nl > + private def handleInternal ( authId : Long , sessionId : Long , message : Any ) = < nl > message match { < nl > + case AuthEvents . AuthIdInvalidated ⇒ < nl > + sendAuthIdInvalidAndStop ( authId , sessionId ) < nl > case ReceiveTimeout ⇒ < nl > context . parent ! Passivate ( stopMessage = PoisonPill ) < nl > case Terminated ( client ) ⇒ < nl > @ @ - 266 , 4 + 283 , 12 @ @ class Session ( < nl > log . error ( " Received unmatched message { } " , message ) < nl > } < nl > < nl > + private def sendAuthIdInvalidAndStop ( authId : Long , sessionId : Long ) : Unit = { < nl > + log . warning ( " Reporting AuthIdInvalid and dying " ) < nl > + < nl > + clients foreach { client ⇒ < nl > + client ! MTPackage ( authId , sessionId , MessageBoxCodec . encode ( MessageBox ( Long . MaxValue , AuthIdInvalid ) ) . require ) < nl > + } < nl > + self ! PoisonPill < nl > + } < nl > } < nl > diff - - git a / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > index 5a9669c . . a7eba9f 100644 < nl > - - - a / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > + + + b / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > @ @ - 32 , 7 + 32 , 6 @ @ private [ session ] object SessionStream { < nl > def graph ( < nl > authId : Long , < nl > sessionId : Long , < nl > - firstMessageId : Long , < nl > rpcHandler : ActorRef , < nl > updatesHandler : ActorRef , < nl > reSender : ActorRef < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala b / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala < nl > index 95a0ae5 . . cace69b 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala < nl > @ @ - 11 , 7 + 11 , 7 @ @ import com . amazonaws . services . s3 . transfer . TransferManager < nl > import com . google . android . gcm . server . Sender < nl > import com . typesafe . config . ConfigFactory < nl > < nl > - import im . actor . api . rpc . auth . { RequestSendAuthCode , RequestSignUp , ResponseSendAuthCode } < nl > + import im . actor . api . rpc . auth . _ < nl > import im . actor . api . rpc . codecs . RequestCodec < nl > import im . actor . api . rpc . sequence . RequestGetDifference < nl > import im . actor . api . rpc . { Request , RpcOk , RpcResult } < nl > @ @ - 49 , 7 + 49 , 9 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( < nl > < nl > it should " notify about lost session " in Server . e3 < nl > < nl > - it should " throw AuthIdInvalid and close connection if sending wrong AuthId " in Server . e4 < nl > + it should " throw AuthIdInvalid if sending wrong AuthId " in Server . e4 < nl > + < nl > + it should " throw AuthIdInvalid if valid AuthId invalidated by some reason " in Server . e5 < nl > < nl > implicit lazy val ( ds , db ) = migrateAndInitDb ( ) < nl > < nl > @ @ - 73 , 18 + 75 , 18 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( < nl > implicit val privatePeerManagerRegion = PrivatePeerManager . startRegion ( ) < nl > implicit val groupPeerManagerRegion = GroupPeerManager . startRegion ( ) < nl > < nl > + val mediator = DistributedPubSubExtension ( system ) . mediator < nl > + < nl > implicit val sessionConfig = SessionConfig . fromConfig ( system . settings . config . getConfig ( " session " ) ) < nl > - Session . startRegion ( Some ( Session . props ) ) < nl > + Session . startRegion ( Some ( Session . props ( mediator ) ) ) < nl > implicit val sessionRegion = Session . startRegionProxy ( ) < nl > < nl > - val mediator = DistributedPubSubExtension ( system ) . mediator < nl > - < nl > val bucketName = " actor - uploads - test " < nl > val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) < nl > implicit val transferManager = new TransferManager ( awsCredentials ) < nl > < nl > val services = Seq ( < nl > - new AuthServiceImpl ( new DummyActivationContext ) , < nl > + new AuthServiceImpl ( new DummyActivationContext , mediator ) , < nl > new ContactsServiceImpl , < nl > MessagingServiceImpl ( mediator ) , < nl > new SequenceServiceImpl < nl > @ @ - 111 , 69 + 113 , 20 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( < nl > val sessionId = 2L < nl > val phoneNumber = 75550000000L < nl > < nl > - val smsHash = { < nl > - val helloMessageId = 4L < nl > - val helloMbBytes = MessageBoxCodec . encode ( MessageBox ( helloMessageId , SessionHello ) ) . require < nl > - val helloMtPackage = MTPackage ( authId , sessionId , helloMbBytes ) < nl > - client . send ( helloMtPackage ) < nl > - expectNewSession ( sessionId , helloMessageId ) < nl > - expectMessageAck ( helloMessageId ) < nl > - < nl > - val messageId = 3L < nl > - < nl > - val requestBytes = RequestCodec . encode ( Request ( RequestSendAuthCode ( phoneNumber , 1 , " apiKey " ) ) ) . require < nl > - val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require < nl > - val mtPackage = MTPackage ( authId , sessionId , mbBytes ) < nl > - < nl > - client . send ( mtPackage ) < nl > - < nl > - expectMessageAck ( messageId ) < nl > - < nl > - val result = receiveRpcResult ( messageId ) < nl > - result shouldBe an [ RpcOk ] < nl > - < nl > - result . asInstanceOf [ RpcOk ] . response . asInstanceOf [ ResponseSendAuthCode ] . smsHash < nl > - } < nl > - < nl > - { < nl > - val messageId = 4L < nl > - < nl > - val requestBytes = RequestCodec . encode ( Request ( RequestSignUp ( < nl > - phoneNumber = phoneNumber , < nl > - smsHash = smsHash , < nl > - smsCode = " 0000 " , < nl > - name = " Wayne Brain " , < nl > - deviceHash = Array ( 4 , 5 , 6 ) , < nl > - deviceTitle = " Specs virtual device " , < nl > - appId = 1 , < nl > - appKey = " appKey " , < nl > - isSilent = false < nl > - ) ) ) . require < nl > - val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require < nl > - val mtPackage = MTPackage ( authId , sessionId , mbBytes ) < nl > - < nl > - client . send ( mtPackage ) < nl > + signUp ( authId , sessionId , phoneNumber ) < nl > < nl > - expectMessageAck ( messageId ) < nl > - < nl > - val result = receiveRpcResult ( messageId ) < nl > - result shouldBe an [ RpcOk ] < nl > - } < nl > - < nl > - { < nl > - val messageId = 5L < nl > + val messageId = Random . nextLong ( ) < nl > < nl > - val requestBytes = RequestCodec . encode ( Request ( RequestGetDifference ( 999 , Array ( ) ) ) ) . require < nl > - val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require < nl > - val mtPackage = MTPackage ( authId , sessionId , mbBytes ) < nl > + val requestBytes = RequestCodec . encode ( Request ( RequestGetDifference ( 999 , Array ( ) ) ) ) . require < nl > + val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require < nl > + val mtPackage = MTPackage ( authId , sessionId , mbBytes ) < nl > < nl > - client . send ( mtPackage ) < nl > + client . send ( mtPackage ) < nl > < nl > - expectMessageAck ( messageId ) < nl > + expectMessageAck ( messageId ) < nl > < nl > - val result = receiveRpcResult ( messageId ) < nl > - result shouldBe an [ RpcOk ] < nl > - } < nl > + val result = receiveRpcResult ( messageId ) < nl > + result shouldBe an [ RpcOk ] < nl > < nl > client . close ( ) < nl > } < nl > @ @ - 220 , 6 + 173 , 99 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( < nl > expectAuthIdInvalid ( ) < nl > } < nl > < nl > + def e5 ( ) = { < nl > + val phoneNumber = 75551234567L < nl > + < nl > + val client1 = MTProtoClient ( ) < nl > + client1 . connectAndHandshake ( remote ) < nl > + val authId1 = requestAuthId ( ) ( client1 ) < nl > + val sessionId1 = Random . nextLong ( ) < nl > + < nl > + val client2 = MTProtoClient ( ) < nl > + client2 . connectAndHandshake ( remote ) < nl > + val authId2 = requestAuthId ( ) ( client2 ) < nl > + val sessionId2 = Random . nextLong ( ) < nl > + < nl > + { < nl > + implicit val client = client1 < nl > + signUp ( authId1 , sessionId1 , phoneNumber ) < nl > + } < nl > + < nl > + { < nl > + implicit val client = client2 < nl > + signUp ( authId2 , sessionId2 , phoneNumber ) < nl > + val requestBits = RequestCodec . encode ( Request ( RequestTerminateAllSessions ) ) . require < nl > + client . send ( MTPackage ( authId2 , Random . nextLong ( ) , MessageBoxCodec . encode ( MessageBox ( Random . nextLong , RpcRequestBox ( requestBits ) ) ) . require ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val client = client1 < nl > + expectAuthIdInvalid ( ) < nl > + expectSessionLost ( ) < nl > + < nl > + client . send ( MTPackage ( authId1 , sessionId1 , MessageBoxCodec . encode ( MessageBox ( Random . nextLong , SessionHello ) ) . require ) ) < nl > + expectAuthIdInvalid ( ) < nl > + } < nl > + } < nl > + < nl > + private def signUp ( authId : Long , sessionId : Long , phoneNumber : Long ) ( implicit client : MTProtoClient ) : Int = { < nl > + require ( phoneNumber . toString . startsWith ( " 7555 " ) ) / / to be able to generate code < nl > + require ( phoneNumber . toString . length > = 5 ) < nl > + < nl > + val smsHash = { < nl > + val helloMessageId = Random . nextLong ( ) < nl > + val helloMbBytes = MessageBoxCodec . encode ( MessageBox ( helloMessageId , SessionHello ) ) . require < nl > + val helloMtPackage = MTPackage ( authId , sessionId , helloMbBytes ) < nl > + client . send ( helloMtPackage ) < nl > + expectNewSession ( sessionId , helloMessageId ) < nl > + expectMessageAck ( helloMessageId ) < nl > + < nl > + val messageId = Random . nextLong ( ) < nl > + < nl > + val requestBytes = RequestCodec . encode ( Request ( RequestSendAuthCode ( phoneNumber , 1 , " apiKey " ) ) ) . require < nl > + val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require < nl > + val mtPackage = MTPackage ( authId , sessionId , mbBytes ) < nl > + < nl > + client . send ( mtPackage ) < nl > + < nl > + expectMessageAck ( messageId ) < nl > + < nl > + val result = receiveRpcResult ( messageId ) < nl > + result shouldBe an [ RpcOk ] < nl > + < nl > + result . asInstanceOf [ RpcOk ] . response . asInstanceOf [ ResponseSendAuthCode ] . smsHash < nl > + } < nl > + < nl > + { < nl > + val messageId = Random . nextLong ( ) < nl > + < nl > + val code = phoneNumber . toString . charAt ( 4 ) . toString * 4 < nl > + < nl > + val requestBytes = RequestCodec . encode ( Request ( RequestSignUp ( < nl > + phoneNumber = phoneNumber , < nl > + smsHash = smsHash , < nl > + smsCode = code , < nl > + name = " Wayne Brain " , < nl > + deviceHash = Array ( 4 , 5 , 6 ) , < nl > + deviceTitle = " Specs virtual device " , < nl > + appId = 1 , < nl > + appKey = " appKey " , < nl > + isSilent = false < nl > + ) ) ) . require < nl > + val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require < nl > + val mtPackage = MTPackage ( authId , sessionId , mbBytes ) < nl > + < nl > + client . send ( mtPackage ) < nl > + < nl > + expectMessageAck ( messageId ) < nl > + < nl > + val result = receiveRpcResult ( messageId ) < nl > + result shouldBe an [ RpcOk ] < nl > + < nl > + result . asInstanceOf [ RpcOk ] . response . asInstanceOf [ ResponseAuth ] . user . id < nl > + } < nl > + } < nl > + < nl > private def requestAuthId ( ) ( implicit client : MTProtoClient ) : Long = { < nl > val messageId = Random . nextLong ( ) < nl > val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RequestAuthId ) ) . require < nl > @ @ - 236 , 6 + 282 , 15 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( < nl > mb . body shouldBe an [ AuthIdInvalid ] < nl > } < nl > < nl > + private def expectMessageAck ( ) ( implicit client : MTProtoClient ) : MessageAck = { < nl > + val mb = receiveMessageBox ( ) < nl > + mb . body shouldBe a [ MessageAck ] < nl > + < nl > + val ack = mb . body . asInstanceOf [ MessageAck ] < nl > + < nl > + ack < nl > + } < nl > + < nl > private def expectMessageAck ( messageId : Long ) ( implicit client : MTProtoClient ) : MessageAck = { < nl > val mb = receiveMessageBox ( ) < nl > mb . body shouldBe a [ MessageAck ] < nl > @ @ - 280 , 6 + 335 , 14 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( < nl > body . asInstanceOf [ MTPackage ] < nl > } < nl > < nl > + private def expectNewSession ( ) ( implicit client : MTProtoClient ) : NewSession = { < nl > + val mtp = receiveMTPackage ( ) < nl > + < nl > + val mb = MessageBoxCodec . decode ( mtp . messageBytes ) . require . value < nl > + mb . body shouldBe a [ NewSession ] < nl > + mb . body . asInstanceOf [ NewSession ] < nl > + } < nl > + < nl > private def expectNewSession ( sessionId : Long , messageId : Long ) ( implicit client : MTProtoClient ) : Unit = { < nl > val mtp = receiveMTPackage ( ) < nl > < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > index aed3614 . . a74ea8c 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > @ @ - 36 , 7 + 36 , 7 @ @ class AuthServiceSpec extends BaseServiceSuite { < nl > implicit val sessionRegion = Session . startRegionProxy ( ) < nl > implicit val seqUpdManagerRegion = buildSeqUpdManagerRegion ( ) < nl > implicit val socialManagerRegion = SocialManager . startRegion ( ) < nl > - implicit val service = new auth . AuthServiceImpl ( new DummyActivationContext ) < nl > + implicit val service = new auth . AuthServiceImpl ( new DummyActivationContext , mediator ) < nl > implicit val rpcApiService = system . actorOf ( RpcApiService . props ( Seq ( service ) ) ) < nl > < nl > implicit val ec = system . dispatcher < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala < nl > index 18c9e80 . . d79fe37 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala < nl > @ @ - 36 , 6 + 36 , 8 @ @ trait UserStructExtensions { < nl > trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { < nl > this : Suite ⇒ < nl > < nl > + val mediator : ActorRef < nl > + < nl > val fairy = Fairy . create ( ) < nl > < nl > def buildPhone ( ) : Long = { < nl > @ @ - 121 , 7 + 123 , 7 @ @ trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { < nl > flowMaterializer : FlowMaterializer < nl > ) = { < nl > implicit val sessionConfig = SessionConfig . fromConfig ( system . settings . config . getConfig ( " session " ) ) < nl > - Session . startRegion ( Some ( Session . props ) ) < nl > + Session . startRegion ( Some ( Session . props ( mediator ) ) ) < nl > } < nl > < nl > def buildSessionRegionProxy ( ) ( implicit system : ActorSystem ) = Session . startRegionProxy ( ) < nl > @ @ - 133 , 7 + 135 , 7 @ @ trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { < nl > socialManagerRegion : SocialManagerRegion , < nl > system : ActorSystem , < nl > database : Database < nl > - ) = new auth . AuthServiceImpl ( new DummyActivationContext ) < nl > + ) = new auth . AuthServiceImpl ( new DummyActivationContext , mediator ) < nl > < nl > protected def withoutLogs [ A ] ( f : ⇒ A ) ( implicit system : ActorSystem ) : A = { < nl > val logger = org . slf4j . LoggerFactory . getLogger ( org . slf4j . Logger . ROOT _ LOGGER _ NAME ) . asInstanceOf [ ch . qos . logback . classic . Logger ] < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > index 1b43ae2 . . 8396a17 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > @ @ - 1 , 5 + 1 , 7 @ @ < nl > package im . actor . server . session < nl > < nl > + import akka . contrib . pattern . DistributedPubSubExtension < nl > + < nl > import scala . concurrent . { Promise , Future , Await , blocking } < nl > import scala . concurrent . duration . _ < nl > import scala . util . { Success , Random } < nl > @ @ - 42 , 12 + 44 , 14 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { ActorSpecification . creat < nl > implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegion ( ) < nl > implicit val socialManagerRegion = SocialManager . startRegion ( ) < nl > < nl > + val mediator = DistributedPubSubExtension ( _ system ) . mediator < nl > + < nl > implicit val sessionConfig = SessionConfig . fromConfig ( system . settings . config . getConfig ( " session " ) ) < nl > < nl > - Session . startRegion ( Some ( Session . props ) ) < nl > + Session . startRegion ( Some ( Session . props ( mediator ) ) ) < nl > < nl > implicit val sessionRegion = Session . startRegionProxy ( ) < nl > - val authService = new AuthServiceImpl ( new DummyActivationContext ) < nl > + val authService = new AuthServiceImpl ( new DummyActivationContext , mediator ) < nl > val sequenceService = new SequenceServiceImpl < nl > < nl > system . actorOf ( RpcApiService . props ( Seq ( authService , sequenceService ) ) , " rpcApiService " ) < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala < nl > index 10f3498 . . fded7e8 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala < nl > @ @ - 71 , 7 + 71 , 7 @ @ class SessionResendLargeSpec extends BaseSessionSpec ( < nl > < nl > val authId = createAuthId ( ) < nl > val sessionId = Random . nextLong ( ) < nl > - val session = system . actorOf ( Session . props ) < nl > + val session = system . actorOf ( Session . props ( mediator ) ) < nl > watchProbe watch session < nl > < nl > val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > index 4b329eb . . bbf1b29 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > @ @ - 40 , 7 + 40 , 7 @ @ class SessionSpec extends BaseSessionSpec { < nl > def e1 ( ) = { < nl > val authId = createAuthId ( ) < nl > val sessionId = Random . nextLong ( ) < nl > - val session = system . actorOf ( Session . props ) < nl > + val session = system . actorOf ( Session . props ( mediator ) ) < nl > < nl > sendEnvelope ( authId , sessionId , session , HandleMessageBox ( BitVector . empty . toByteArray ) ) < nl > < nl > diff - - git a / src / main / scala / im / actor / server / Main . scala b / src / main / scala / im / actor / server / Main . scala < nl > index 8a24d34 . . ee661f5 100644 < nl > - - - a / src / main / scala / im / actor / server / Main . scala < nl > + + + b / src / main / scala / im / actor / server / Main . scala < nl > @ @ - 85 , 10 + 85 , 12 @ @ class Main extends Bootable with DbInit with FlywayInit { < nl > implicit val client = new AmazonS3ScalaClient ( awsCredentials ) < nl > implicit val transferManager = new TransferManager ( awsCredentials ) < nl > < nl > + val mediator = DistributedPubSubExtension ( system ) . mediator < nl > + < nl > val activationContext = SmsActivation . newContext ( smsConfig ) < nl > < nl > Session . startRegion ( < nl > - Some ( Session . props ) < nl > + Some ( Session . props ( mediator ) ) < nl > ) < nl > < nl > implicit val sessionRegion = Session . startRegionProxy ( ) < nl > @ @ - 103 , 14 + 105 , 12 @ @ class Main extends Bootable with DbInit with FlywayInit { < nl > implicit val uploadManager = new UploadManager ( s3BucketName ) < nl > MessageInterceptor . startSingleton ( ilectro , downloadManager , uploadManager ) < nl > < nl > - val mediator = DistributedPubSubExtension ( system ) . mediator < nl > - < nl > val messagingService = MessagingServiceImpl ( mediator ) < nl > < nl > RichMessageWorker . startWorker ( richMessageConfig , mediator ) < nl > < nl > val services = Seq ( < nl > - new AuthServiceImpl ( activationContext ) , < nl > + new AuthServiceImpl ( activationContext , mediator ) , < nl > new ContactsServiceImpl , < nl > messagingService , < nl > new GroupsServiceImpl ( s3BucketName , groupInviteConfig ) ,

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala 
 index fa4ae6e . . 88f1938 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala 
 @ @ - 72 , 7 + 72 , 7 @ @ final class EventBusMediator extends Actor with ActorLogging { 
 object consumers { 
 private val a2d = mutable . Map . empty [ AuthId , ( UserId , DeviceId ) ] 
 private val d2a = mutable . Map . empty [ DeviceId , ( UserId , AuthId ) ] 
 - private val ownerAuthIds = mutable . Set . empty [ AuthId ] 
 + val ownerAuthIds = mutable . Set . empty [ AuthId ] 
 private val a2timeouts = mutable . Map . empty [ AuthId , Cancellable ] 
 
 def isOwnerConnected = ownerAuthIds . nonEmpty 
 @ @ - 108 , 11 + 108 , 6 @ @ final class EventBusMediator extends Actor with ActorLogging { 
 } 
 } 
 
 - override def postStop ( ) : Unit = { 
 - super . postStop ( ) 
 - internalConsumers foreach ( _ ! EventBus . Disposed ( id ) ) 
 - } 
 - 
 def receive = { 
 case Create ( clientUserId , clientAuthId , timeoutOpt , isOwned ) ⇒ 
 if ( isOwned . contains ( true ) ) this . owner = Some ( clientUserId ) 
 @ @ - 152 , 16 + 147 , 16 @ @ final class EventBusMediator extends Actor with ActorLogging { 
 case None ⇒ consumers . stopKeepAlive ( clientAuthId ) 
 } 
 case ConsumerTimedOut ( authId ) ⇒ 
 - consumers . remove ( authId ) match { 
 - case Some ( ( userId , deviceId ) ) ⇒ 
 - broadcast ( UpdateEventBusDeviceDisconnected ( id , userId , deviceId ) ) 
 - 
 - if ( ( owner . isDefined & & ! consumers . isOwnerConnected ) | | consumers . isEmpty ) { 
 - broadcast ( UpdateEventBusDisposed ( id ) ) 
 - context stop self 
 - } 
 - case None ⇒ 
 - log . error ( " ConsumerTimedOut with unknown authId : { } " , authId ) 
 + if ( ( owner . isDefined & & consumers . ownerAuthIds = = Set ( authId ) ) | | consumers . authIds = = Set ( authId ) ) { 
 + log . debug ( " Disposing " ) 
 + broadcast ( UpdateEventBusDisposed ( id ) ) 
 + context stop self 
 + } else { 
 + consumers . remove ( authId ) match { 
 + case Some ( ( userId , deviceId ) ) ⇒ 
 + broadcast ( UpdateEventBusDeviceDisconnected ( id , userId , deviceId ) ) 
 + case None ⇒ log . error ( " Consumer timed out with unknown authId : { } " , authId ) 
 + } 
 } 
 case Join ( clientUserId , clientAuthId , timeoutOpt ) ⇒ 
 val deviceId = Random . nextLong ( ) 
 @ @ - 171 , 7 + 166 , 6 @ @ final class EventBusMediator extends Actor with ActorLogging { 
 sender ( ) ! JoinAck ( deviceId ) 
 case Dispose ( clientUserId ) ⇒ 
 if ( owner . contains ( clientUserId ) ) { 
 - broadcast ( UpdateEventBusDisposed ( id ) ) 
 context stop self 
 } else sender ( ) ! Status . Failure ( new RuntimeException ( " Attempt to dispose by not an owner " ) ) 
 case Subscribe ( ref ) ⇒ 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala 
 index c1afcf0 . . f23c7f1 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala 
 @ @ - 25 , 7 + 25 , 7 @ @ abstract class BaseAppSuite ( _ system : ActorSystem = { 
 with ActorSerializerPrepare { 
 
 protected implicit val materializer : ActorMaterializer = ActorMaterializer ( ) 
 - protected implicit lazy val ec : ExecutionContext = _ system . dispatcher 
 + implicit lazy val ec : ExecutionContext = _ system . dispatcher 
 
 protected implicit lazy val db : PostgresDriver . api . Database = { 
 DbExtension ( _ system ) . clean ( ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ImplicitSessionRegion . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ImplicitSessionRegion . scala 
 index 186b737 . . c57ce48 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / ImplicitSessionRegion . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ImplicitSessionRegion . scala 
 @ @ - 9 , 5 + 9 , 5 @ @ trait ImplicitSessionRegion { 
 protected implicit val materializer : Materializer 
 
 private implicit lazy val config = SessionConfig . load ( system . settings . config . getConfig ( " session " ) ) 
 - protected implicit lazy val sessionRegion : SessionRegion = Session . startRegion ( Session . props ) 
 + implicit lazy val sessionRegion : SessionRegion = Session . startRegion ( Session . props ) 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / eventbus / EventbusServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / eventbus / EventbusServiceSpec . scala 
 index f0b8285 . . 5610cc3 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / eventbus / EventbusServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / eventbus / EventbusServiceSpec . scala 
 @ @ - 1 , 25 + 1 , 44 @ @ 
 package im . actor . server . api . rpc . service . eventbus 
 
 - import im . actor . api . rpc . eventbus . { ApiEventBusDestination , ResponseCreateNewEventBus } 
 + import akka . testkit . TestProbe 
 + import im . actor . api . rpc . eventbus . _ 
 + import im . actor . server . mtproto . protocol . SessionHello 
 + import im . actor . server . session . SessionSpecHelpers 
 import im . actor . server . { SeqUpdateMatchers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } 
 import im . actor . api . rpc . _ 
 
 - final class EventbusServiceSpec extends BaseAppSuite with ImplicitAuthService with ImplicitSessionRegion with SeqUpdateMatchers { 
 + import scala . util . Random 
 + 
 + final class EventbusServiceSpec 
 + extends BaseAppSuite 
 + with ImplicitAuthService 
 + with ImplicitSessionRegion 
 + with SeqUpdateMatchers 
 + with SessionSpecHelpers { 
 it should " broadcast messages " in broadcast 
 
 lazy val service = new EventbusServiceImpl ( system ) 
 
 def broadcast ( ) = { 
 + val aliceProbe = TestProbe ( ) 
 + val bobProbe = TestProbe ( ) 
 + 
 val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val aliceSessionId = 1L 
 + val bobSessionId = 2L 
 + 
 + val aliceClientData = ClientData ( aliceAuthId , aliceSessionId , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobClientData = ClientData ( bobAuthId , bobSessionId , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 
 - val aliceClientData = ClientData ( aliceAuthId , 1L , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 - val bobClientData = ClientData ( bobAuthId , 1L , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 + sendMessageBox ( aliceAuthId , aliceSessionId , sessionRegion . ref , Random . nextLong ( ) , SessionHello ) ( aliceProbe ) 
 + ignoreNewSession ( ) ( aliceProbe ) 
 + expectMessageAck ( ) ( aliceProbe ) 
 
 val ( id , aliceDeviceId ) = { 
 implicit val clientData = aliceClientData 
 
 - whenReady ( service . handleCreateNewEventBus ( None , None ) ) { 
 + whenReady ( service . handleCreateNewEventBus ( Some ( 1000 ) , Some ( true ) ) ) { 
 case Ok ( ResponseCreateNewEventBus ( id , deviceId ) ) ⇒ ( id , deviceId ) 
 } 
 } 
 @ @ - 33 , 5 + 52 , 12 @ @ final class EventbusServiceSpec extends BaseAppSuite with ImplicitAuthService wi 
 
 service . handlePostToEventBus ( id , Vector ( ApiEventBusDestination ( alice . id , Vector ( aliceDeviceId ) ) ) , Array [ Byte ] ( 123 ) ) 
 } 
 + 
 + expectWeakUpdate ( aliceAuthId , aliceSessionId ) ( aliceProbe ) . updateHeader shouldBe UpdateEventBusDeviceConnected . header 
 + expectWeakUpdate ( aliceAuthId , aliceSessionId ) ( aliceProbe ) . updateHeader shouldBe UpdateEventBusMessage . header 
 + 
 + Thread . sleep ( 1000 ) 
 + 
 + expectWeakUpdate ( aliceAuthId , aliceSessionId ) ( aliceProbe ) . updateHeader shouldBe UpdateEventBusDisposed . header 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 index 0e88019 . . 83c5071 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 @ @ - 1 , 31 + 1 , 22 @ @ 
 package im . actor . server . session 
 
 import akka . actor . _ 
 - import akka . testkit . TestProbe 
 - import com . google . protobuf . ByteString 
 - import im . actor . api . rpc . codecs . _ 
 - import im . actor . api . rpc . sequence . { FatSeqUpdate , SeqUpdate , WeakUpdate } 
 - import im . actor . api . rpc . { Request , RpcRequest , RpcResult } 
 import im . actor . server 
 import im . actor . server . _ 
 + import im . actor . server . api . rpc . RpcApiExtension 
 import im . actor . server . api . rpc . service . auth . AuthServiceImpl 
 import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl 
 import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } 
 - import im . actor . server . api . rpc . { RpcApiExtension , RpcResultCodec } 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec 
 - import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } 
 - import im . actor . server . session . SessionEnvelope . Payload 
 import org . scalatest . concurrent . ScalaFutures 
 import org . scalatest . time . { Seconds , Span } 
 import org . scalatest . { FlatSpecLike , Matchers } 
 - import scodec . bits . BitVector 
 import slick . driver . PostgresDriver 
 
 + import scala . concurrent . Await 
 import scala . concurrent . duration . _ 
 - import scala . concurrent . { Await , Future , blocking } 
 import scala . util . Random 
 
 abstract class BaseSessionSpec ( _ system : ActorSystem = { 
 @ @ - 36 , 12 + 27 , 13 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { 
 with ScalaFutures 
 with Matchers 
 with ActorSerializerPrepare 
 - with ServiceSpecHelpers { 
 + with ServiceSpecHelpers 
 + with SessionSpecHelpers { 
 
 override implicit def patienceConfig : PatienceConfig = 
 new PatienceConfig ( timeout = Span ( 10 , Seconds ) ) 
 
 - protected implicit val ec = system . dispatcher 
 + implicit val ec = system . dispatcher 
 
 protected implicit lazy val db : PostgresDriver . api . Database = { 
 DbExtension ( _ system ) . db 
 @ @ - 54 , 7 + 46 , 7 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { 
 
 Session . startRegion ( Session . props ) 
 
 - protected implicit val sessionRegion = Session . startRegionProxy ( ) 
 + implicit val sessionRegion = Session . startRegionProxy ( ) 
 
 protected val oauthGoogleConfig = OAuth2GoogleConfig . load ( system . settings . config . getConfig ( " services . google . oauth " ) ) 
 protected implicit val oauth2Service = new GoogleProvider ( oauthGoogleConfig ) 
 @ @ - 73 , 148 + 65 , 4 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { 
 Await . result ( db . run ( persist . AuthIdRepo . create ( authId , None , None ) ) , 1 . second ) 
 authId 
 } 
 - 
 - protected def expectSeqUpdate ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : SeqUpdate = 
 - expectUpdateBox ( classOf [ SeqUpdate ] , authId , sessionId , sendAckAt ) 
 - 
 - protected def expectFatSeqUpdate ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : FatSeqUpdate = 
 - expectUpdateBox ( classOf [ FatSeqUpdate ] , authId , sessionId , sendAckAt ) 
 - 
 - protected def expectWeakUpdate ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : WeakUpdate = 
 - expectUpdateBox ( classOf [ WeakUpdate ] , authId , sessionId , None ) 
 - 
 - protected def expectUpdateBox [ T < : im . actor . api . rpc . UpdateBox ] ( clazz : Class [ T ] , authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] ) ( implicit probe : TestProbe , m : Manifest [ T ] ) : T = { 
 - val mb = expectMessageBox ( ) 
 - 
 - val update = UpdateBoxCodec . decode ( mb . body . asInstanceOf [ ProtoPush ] . bodyBytes ) . require . value 
 - 
 - sendAckAt map { delay ⇒ 
 - Future { 
 - blocking { 
 - Thread . sleep ( delay . toMillis ) 
 - sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong , MessageAck ( Vector ( mb . messageId ) ) ) 
 - } 
 - } 
 - } 
 - 
 - update shouldBe a [ T ] 
 - 
 - update . asInstanceOf [ T ] 
 - } 
 - 
 - protected def expectRpcResult ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) , expectAckFor : Set [ Long ] = Set . empty ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : RpcResult = { 
 - val messages = probe . receiveN ( 1 + expectAckFor . size , patienceConfig . timeout . totalNanos . nano ) . toSet 
 - 
 - if ( messages . size ! = expectAckFor . size + 1 ) { 
 - fail ( s " Expected response and acks for $ { expectAckFor . mkString ( " , " ) } , got : $ { messages . mkString ( " , " ) } " ) 
 - } else { 
 - val ( rest , ackIds ) = messages . foldLeft ( Vector . empty [ ( Long , ProtoMessage ) ] , Set . empty [ Long ] ) { 
 - case ( ( rest , ackIds ) , mbBytes : BitVector ) ⇒ 
 - val mb = MessageBoxCodec . decode ( mbBytes ) . require . value 
 - 
 - mb . body match { 
 - case MessageAck ( ids ) ⇒ ( rest , ackIds + + ids ) 
 - case body ⇒ ( rest : + ( ( mb . messageId , body ) ) , ackIds ) 
 - } 
 - } 
 - 
 - ackIds shouldEqual expectAckFor 
 - 
 - rest match { 
 - case Vector ( ( messageId , ProtoRpcResponse ( _ , rpcResultBytes ) ) ) ⇒ 
 - sendAckAt map { delay ⇒ 
 - Future { 
 - blocking { 
 - Thread . sleep ( delay . toMillis ) 
 - sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong , MessageAck ( Vector ( messageId ) ) ) 
 - } 
 - } 
 - } 
 - 
 - RpcResultCodec . decode ( rpcResultBytes ) . require . value 
 - case unexpected ⇒ throw new Exception ( s " Expected RpcResponseBox but got $ unexpected " ) 
 - } 
 - } 
 - } 
 - 
 - protected def expectMessageAck ( ) ( implicit probe : TestProbe ) : MessageAck = { 
 - val mb = expectMessageBox ( ) 
 - mb . body shouldBe a [ MessageAck ] 
 - 
 - val ack = mb . body . asInstanceOf [ MessageAck ] 
 - ack 
 - } 
 - 
 - protected def expectMessageAck ( messageId : Long ) ( implicit probe : TestProbe ) : MessageAck = { 
 - val mb = expectMessageBox ( ) 
 - mb . body shouldBe a [ MessageAck ] 
 - 
 - val ack = mb . body . asInstanceOf [ MessageAck ] 
 - ack . messageIds should = = = ( Vector ( messageId ) ) 
 - ack 
 - } 
 - 
 - protected def expectNewSession ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : NewSession = { 
 - expectMessageBoxPF ( ) { 
 - case mb @ MessageBox ( _ , NewSession ( sid , mid ) ) ⇒ 
 - sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , MessageAck ( Vector ( mb . messageId ) ) ) 
 - 
 - val ns = mb . body . asInstanceOf [ NewSession ] 
 - ns should = = = ( NewSession ( sessionId , messageId ) ) 
 - ns 
 - } 
 - } 
 - 
 - protected def ignoreNewSession ( ) ( implicit probe : TestProbe ) : Unit = { 
 - probe . ignoreMsg { 
 - case body : BitVector ⇒ 
 - MessageBoxCodec . decode ( body ) . require . value . body . isInstanceOf [ NewSession ] 
 - case _ ⇒ false 
 - } 
 - } 
 - 
 - protected def expectMessageBoxPF [ T ] ( hint : String = " " ) ( pf : PartialFunction [ MessageBox , T ] ) ( implicit probe : TestProbe ) : T = { 
 - probe . expectMsgPF ( max = patienceConfig . timeout . totalNanos . nano ) { 
 - case body : BitVector ⇒ 
 - val mb = MessageBoxCodec . decode ( body ) . require . value 
 - 
 - assert ( pf . isDefinedAt ( mb ) , s " expected : $ hint but got $ mb " ) 
 - pf ( mb ) 
 - } 
 - } 
 - 
 - protected def expectMessageBox ( ) ( implicit probe : TestProbe ) : MessageBox = { 
 - val packageBody = probe . expectMsgPF ( max = patienceConfig . timeout . totalNanos . nano ) { 
 - case body : BitVector ⇒ body 
 - } 
 - 
 - MessageBoxCodec . decode ( packageBody ) . require . value 
 - } 
 - 
 - protected def sendMessageBox ( authId : Long , sessionId : Long , session : ActorRef , messageId : Long , body : ProtoMessage ) ( implicit probe : TestProbe ) = 
 - sendEnvelope ( authId , sessionId , session , Payload . HandleMessageBox ( handleMessageBox ( messageId , body ) ) ) 
 - 
 - protected def handleMessageBox ( messageId : Long , body : ProtoMessage ) = 
 - HandleMessageBox ( ByteString . copyFrom ( MessageBoxCodec . encode ( MessageBox ( messageId , body ) ) . require . toByteBuffer ) ) 
 - 
 - protected def sendEnvelope ( authId : Long , sessionId : Long , session : ActorRef , payload : Payload ) ( implicit probe : TestProbe ) = { 
 - session . tell ( 
 - SessionEnvelope ( 
 - authId , 
 - sessionId 
 - ) . withPayload ( payload ) , 
 - probe . ref 
 - ) 
 - } 
 - 
 - protected def sendRequest ( authId : Long , sessionId : Long , session : ActorRef , messageId : Long , request : RpcRequest ) ( implicit probe : TestProbe ) : Unit = { 
 - val rqBox = ProtoRpcRequest ( RequestCodec . encode ( Request ( request ) ) . require ) 
 - sendMessageBox ( authId , sessionId , session , messageId , rqBox ) 
 - } 
 - 
 - protected def sendRequest ( authId : Long , sessionId : Long , session : ActorRef , request : RpcRequest ) ( implicit probe : TestProbe ) : Long = { 
 - val messageId = Random . nextLong ( ) 
 - sendRequest ( authId , sessionId , session , messageId , request ) 
 - messageId 
 - } 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 new file mode 100644 
 index 0000000 . . 0a7b511 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 @ @ - 0 , 0 + 1 , 170 @ @ 
 + package im . actor . server . session 
 + 
 + import akka . actor . { ActorSystem , ActorRef } 
 + import akka . testkit . TestProbe 
 + import com . google . protobuf . ByteString 
 + import im . actor . api . rpc . { Request , RpcRequest , RpcResult } 
 + import im . actor . api . rpc . codecs . _ 
 + import im . actor . api . rpc . sequence . { WeakUpdate , FatSeqUpdate , SeqUpdate } 
 + import im . actor . server . api . rpc . RpcResultCodec 
 + import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec 
 + import im . actor . server . mtproto . protocol . _ 
 + import im . actor . server . session . SessionEnvelope . Payload 
 + import org . scalatest . Matchers 
 + import org . scalatest . concurrent . AbstractPatienceConfiguration 
 + import scodec . bits . BitVector 
 + 
 + import scala . concurrent . _ 
 + import scala . concurrent . duration . _ 
 + import scala . util . Random 
 + 
 + trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { 
 + 
 + val system : ActorSystem 
 + val sessionRegion : SessionRegion 
 + implicit val ec : ExecutionContext 
 + 
 + protected def expectSeqUpdate ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : SeqUpdate = 
 + expectUpdateBox ( classOf [ SeqUpdate ] , authId , sessionId , sendAckAt ) 
 + 
 + protected def expectFatSeqUpdate ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : FatSeqUpdate = 
 + expectUpdateBox ( classOf [ FatSeqUpdate ] , authId , sessionId , sendAckAt ) 
 + 
 + protected def expectWeakUpdate ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : WeakUpdate = 
 + expectUpdateBox ( classOf [ WeakUpdate ] , authId , sessionId , None ) 
 + 
 + protected def expectUpdateBox [ T < : im . actor . api . rpc . UpdateBox ] ( clazz : Class [ T ] , authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] ) ( implicit probe : TestProbe , m : Manifest [ T ] ) : T = { 
 + val mb = expectMessageBox ( ) 
 + 
 + val update = UpdateBoxCodec . decode ( mb . body . asInstanceOf [ ProtoPush ] . bodyBytes ) . require . value 
 + 
 + sendAckAt map { delay ⇒ 
 + Future { 
 + blocking { 
 + Thread . sleep ( delay . toMillis ) 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong , MessageAck ( Vector ( mb . messageId ) ) ) 
 + } 
 + } 
 + } 
 + 
 + update shouldBe a [ T ] 
 + 
 + update . asInstanceOf [ T ] 
 + } 
 + 
 + protected def expectRpcResult ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) , expectAckFor : Set [ Long ] = Set . empty ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : RpcResult = { 
 + val messages = probe . receiveN ( 1 + expectAckFor . size , patienceConfig . timeout . totalNanos . nano ) . toSet 
 + 
 + if ( messages . size ! = expectAckFor . size + 1 ) { 
 + fail ( s " Expected response and acks for $ { expectAckFor . mkString ( " , " ) } , got : $ { messages . mkString ( " , " ) } " ) 
 + } else { 
 + val ( rest , ackIds ) = messages . foldLeft ( Vector . empty [ ( Long , ProtoMessage ) ] , Set . empty [ Long ] ) { 
 + case ( ( rest , ackIds ) , mbBytes : BitVector ) ⇒ 
 + val mb = MessageBoxCodec . decode ( mbBytes ) . require . value 
 + 
 + mb . body match { 
 + case MessageAck ( ids ) ⇒ ( rest , ackIds + + ids ) 
 + case body ⇒ ( rest : + ( ( mb . messageId , body ) ) , ackIds ) 
 + } 
 + } 
 + 
 + ackIds shouldEqual expectAckFor 
 + 
 + rest match { 
 + case Vector ( ( messageId , ProtoRpcResponse ( _ , rpcResultBytes ) ) ) ⇒ 
 + sendAckAt map { delay ⇒ 
 + Future { 
 + blocking { 
 + Thread . sleep ( delay . toMillis ) 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong , MessageAck ( Vector ( messageId ) ) ) 
 + } 
 + } 
 + } 
 + 
 + RpcResultCodec . decode ( rpcResultBytes ) . require . value 
 + case unexpected ⇒ throw new Exception ( s " Expected RpcResponseBox but got $ unexpected " ) 
 + } 
 + } 
 + } 
 + 
 + protected def expectMessageAck ( ) ( implicit probe : TestProbe ) : MessageAck = { 
 + val mb = expectMessageBox ( ) 
 + mb . body shouldBe a [ MessageAck ] 
 + 
 + val ack = mb . body . asInstanceOf [ MessageAck ] 
 + ack 
 + } 
 + 
 + protected def expectMessageAck ( messageId : Long ) ( implicit probe : TestProbe ) : MessageAck = { 
 + val mb = expectMessageBox ( ) 
 + mb . body shouldBe a [ MessageAck ] 
 + 
 + val ack = mb . body . asInstanceOf [ MessageAck ] 
 + ack . messageIds should = = = ( Vector ( messageId ) ) 
 + ack 
 + } 
 + 
 + protected def expectNewSession ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : NewSession = { 
 + expectMessageBoxPF ( ) { 
 + case mb @ MessageBox ( _ , NewSession ( sid , mid ) ) ⇒ 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , MessageAck ( Vector ( mb . messageId ) ) ) 
 + 
 + val ns = mb . body . asInstanceOf [ NewSession ] 
 + ns should = = = ( NewSession ( sessionId , messageId ) ) 
 + ns 
 + } 
 + } 
 + 
 + protected def ignoreNewSession ( ) ( implicit probe : TestProbe ) : Unit = { 
 + probe . ignoreMsg { 
 + case body : BitVector ⇒ 
 + MessageBoxCodec . decode ( body ) . require . value . body . isInstanceOf [ NewSession ] 
 + case _ ⇒ false 
 + } 
 + } 
 + 
 + protected def expectMessageBoxPF [ T ] ( hint : String = " " ) ( pf : PartialFunction [ MessageBox , T ] ) ( implicit probe : TestProbe ) : T = { 
 + probe . expectMsgPF ( max = patienceConfig . timeout . totalNanos . nano ) { 
 + case body : BitVector ⇒ 
 + val mb = MessageBoxCodec . decode ( body ) . require . value 
 + 
 + assert ( pf . isDefinedAt ( mb ) , s " expected : $ hint but got $ mb " ) 
 + pf ( mb ) 
 + } 
 + } 
 + 
 + protected def expectMessageBox ( ) ( implicit probe : TestProbe ) : MessageBox = { 
 + val packageBody = probe . expectMsgPF ( max = patienceConfig . timeout . totalNanos . nano ) { 
 + case body : BitVector ⇒ body 
 + } 
 + 
 + MessageBoxCodec . decode ( packageBody ) . require . value 
 + } 
 + 
 + protected def sendMessageBox ( authId : Long , sessionId : Long , session : ActorRef , messageId : Long , body : ProtoMessage ) ( implicit probe : TestProbe ) = 
 + sendEnvelope ( authId , sessionId , session , Payload . HandleMessageBox ( handleMessageBox ( messageId , body ) ) ) 
 + 
 + protected def handleMessageBox ( messageId : Long , body : ProtoMessage ) = 
 + HandleMessageBox ( ByteString . copyFrom ( MessageBoxCodec . encode ( MessageBox ( messageId , body ) ) . require . toByteBuffer ) ) 
 + 
 + protected def sendEnvelope ( authId : Long , sessionId : Long , session : ActorRef , payload : Payload ) ( implicit probe : TestProbe ) = { 
 + session . tell ( 
 + SessionEnvelope ( 
 + authId , 
 + sessionId 
 + ) . withPayload ( payload ) , 
 + probe . ref 
 + ) 
 + } 
 + 
 + protected def sendRequest ( authId : Long , sessionId : Long , session : ActorRef , messageId : Long , request : RpcRequest ) ( implicit probe : TestProbe ) : Unit = { 
 + val rqBox = ProtoRpcRequest ( RequestCodec . encode ( Request ( request ) ) . require ) 
 + sendMessageBox ( authId , sessionId , session , messageId , rqBox ) 
 + } 
 + 
 + protected def sendRequest ( authId : Long , sessionId : Long , session : ActorRef , request : RpcRequest ) ( implicit probe : TestProbe ) : Long = { 
 + val messageId = Random . nextLong ( ) 
 + sendRequest ( authId , sessionId , session , messageId , request ) 
 + messageId 
 + } 
 + } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 index 08f08ac . . e66d34f 100644 
 - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 @ @ - 5 , 7 + 5 , 7 @ @ import scala . concurrent . duration . _ 
 import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scalaz . _ 
 
 - import akka . actor . ActorSystem 
 + import akka . actor . { ActorRef , ActorSystem } 
 import akka . event . Logging 
 import akka . util . Timeout 
 import org . joda . time . DateTime 
 @ @ - 27 , 7 + 27 , 24 @ @ import im . actor . server . util . PhoneNumber . normalizeWithCountry 
 import im . actor . server . util . _ 
 import im . actor . server . { models , persist } 
 
 - class AuthServiceImpl ( activationContext : ActivationContext ) ( 
 + sealed trait AuthEvent 
 + 
 + object AuthEvents { 
 + case object AuthIdInvalidated extends AuthEvent 
 + } 
 + 
 + object AuthService { 
 + import akka . contrib . pattern . DistributedPubSubMediator . _ 
 + import AuthEvents . _ 
 + 
 + def authIdTopic ( authId : Long ) : String = s " auth . events . $ { authId } " 
 + 
 + private [ auth ] def publishAuthIdInvalidated ( mediator : ActorRef , authId : Long ) : Unit = { 
 + mediator ! Publish ( authIdTopic ( authId ) , AuthIdInvalidated ) 
 + } 
 + } 
 + 
 + class AuthServiceImpl ( activationContext : ActivationContext , mediator : ActorRef ) ( 
 implicit 
 val sessionRegion : SessionRegion , 
 val seqUpdatesManagerRegion : SeqUpdatesManagerRegion , 
 @ @ - 142 , 14 + 159 , 6 @ @ class AuthServiceImpl ( activationContext : ActivationContext ) ( 
 throw new Exception ( " Not implemented " ) 
 } 
 
 - override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 - val action = requireAuth ( clientData ) map { implicit client ⇒ 
 - DBIO . successful ( Ok ( misc . ResponseVoid ) ) 
 - } 
 - 
 - db . run ( toDBIOAction ( action ) ) 
 - } 
 - 
 override def jhandleSignIn ( 
 rawPhoneNumber : Long , 
 smsHash : String , 
 @ @ - 299 , 6 + 308 , 18 @ @ class AuthServiceImpl ( activationContext : ActivationContext ) ( 
 } 
 } 
 
 + override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 + val action = requireAuth ( clientData ) map { implicit client ⇒ 
 + persist . AuthSession . findByAuthId ( client . authId ) flatMap { 
 + case Some ( session ) ⇒ 
 + for ( _ ← logout ( session ) ) yield Ok ( misc . ResponseVoid ) 
 + case None ⇒ throw new Exception ( s " Cannot find AuthSession for authId : $ { client . authId } " ) 
 + } 
 + } 
 + 
 + db . run ( toDBIOAction ( action ) ) 
 + } 
 + 
 override def jhandleTerminateAllSessions ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { client ⇒ 
 for { 
 @ @ - 371 , 7 + 392 , 9 @ @ class AuthServiceImpl ( activationContext : ActivationContext ) ( 
 for { 
 _ ← persist . AuthSession . delete ( session . userId , session . id ) 
 _ ← persist . AuthId . delete ( session . authId ) 
 - } yield ( ) 
 + } yield { 
 + AuthService . publishAuthIdInvalidated ( mediator , session . authId ) 
 + } 
 } 
 
 private def sendSmsCode ( authId : Long , phoneNumber : Long , code : String ) : Unit = { 
 diff - - git a / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 index 05bb462 . . f5ea5fb 100644 
 - - - a / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 + + + b / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 @ @ - 2 , 13 + 2 , 15 @ @ package im . actor . server . session 
 
 import java . util . concurrent . TimeUnit 
 
 + import im . actor . server . api . rpc . service . auth . { AuthEvents , AuthService } 
 + 
 import scala . collection . immutable 
 import scala . concurrent . ExecutionContext 
 import scala . concurrent . duration . _ 
 
 import akka . actor . _ 
 import akka . contrib . pattern . ShardRegion . Passivate 
 - import akka . contrib . pattern . { ClusterSharding , ShardRegion } 
 + import akka . contrib . pattern . { DistributedPubSubMediator , ClusterSharding , ShardRegion } 
 import akka . stream . FlowMaterializer 
 import akka . stream . actor . _ 
 import akka . stream . scaladsl . _ 
 @ @ - 60 , 7 + 62 , 7 @ @ object Session { 
 
 def startRegionProxy ( ) ( implicit system : ActorSystem ) : SessionRegion = startRegion ( None ) 
 
 - def props ( 
 + def props ( mediator : ActorRef ) ( 
 implicit 
 config : SessionConfig , 
 seqUpdManagerRegion : SeqUpdatesManagerRegion , 
 @ @ - 72 , 6 + 74 , 7 @ @ object Session { 
 ) : Props = 
 Props ( 
 classOf [ Session ] , 
 + mediator , 
 config , 
 seqUpdManagerRegion , 
 weakUpdManagerRegion , 
 @ @ - 82 , 7 + 85 , 7 @ @ object Session { 
 ) 
 } 
 
 - class Session ( 
 + class Session ( mediator : ActorRef ) ( 
 implicit 
 config : SessionConfig , 
 seqUpdManagerRegion : SeqUpdatesManagerRegion , 
 @ @ - 114 , 9 + 117 , 12 @ @ class Session ( 
 def waitingForEnvelope : Receive = { 
 case env @ Envelope ( authId , sessionId , _ ) ⇒ 
 val replyTo = sender ( ) 
 - 
 stash ( ) 
 - context . become ( waitingForSessionInfo ) 
 + 
 + val subscribe = DistributedPubSubMediator . Subscribe ( AuthService . authIdTopic ( authId ) , self ) 
 + mediator ! subscribe 
 + 
 + context . become ( waitingForSessionInfo ( authId , sessionId , subscribe ) ) 
 
 / / TODO : handle errors 
 / / TODO : refactor 
 @ @ - 141 , 21 + 147 , 30 @ @ class Session ( 
 infoFuture map { 
 case Some ( info ) ⇒ self ! info 
 case None ⇒ 
 + log . warning ( " Reporting AuthIdInvalid and dying " ) 
 replyTo ! MTPackage ( authId , sessionId , MessageBoxCodec . encode ( MessageBox ( Long . MaxValue , AuthIdInvalid ) ) . require ) 
 - self ! PoisonPill / / TODO : AuthIdInvalid 
 + self ! PoisonPill 
 } 
 case msg ⇒ stash ( ) 
 } 
 
 - def waitingForSessionInfo : Receive = { 
 + def waitingForSessionInfo ( authId : Long , sessionId : Long , subscribe : DistributedPubSubMediator . Subscribe ) : Receive = { 
 case info : models . SessionInfo ⇒ 
 optUserId = info . optUserId 
 unstashAll ( ) 
 - context . become ( anonymous ) 
 + context . become ( waitingForSubscribeAck ( authId , sessionId , subscribe ) ) 
 case msg ⇒ stash ( ) 
 } 
 
 - def anonymous : Receive = { 
 + def waitingForSubscribeAck ( authId : Long , sessionId : Long , subscribe : DistributedPubSubMediator . Subscribe ) : Receive = { 
 + case msg if msg = = DistributedPubSubMediator . SubscribeAck ( subscribe ) ⇒ 
 + unstashAll ( ) 
 + context . become ( anonymous ( authId , sessionId ) ) 
 + case msg ⇒ 
 + stash ( ) 
 + } 
 + 
 + def anonymous ( authId : Long , sessionId : Long ) : Receive = { 
 case env @ Envelope ( authId , sessionId , HandleMessageBox ( messageBoxBytes ) ) ⇒ 
 val client = sender ( ) 
 
 @ @ - 165 , 7 + 180 , 7 @ @ class Session ( 
 val updatesHandler = context . actorOf ( UpdatesHandler . props ( authId ) , " updatesHandler " ) 
 val reSender = context . actorOf ( ReSender . props ( authId , sessionId ) ( config . reSendConfig ) , " reSender " ) 
 
 - val graph = SessionStream . graph ( authId , sessionId , mb . messageId , rpcHandler , updatesHandler , reSender ) 
 + val graph = SessionStream . graph ( authId , sessionId , rpcHandler , updatesHandler , reSender ) 
 
 val flow = FlowGraph . closed ( graph ) { implicit b ⇒ g ⇒ 
 import FlowGraph . Implicits . _ 
 @ @ - 191 , 7 + 206 , 7 @ @ class Session ( 
 
 context . become ( resolved ( authId , sessionId , sessionMessagePublisher , reSender ) ) 
 } 
 - case internal ⇒ handleInternal ( internal ) 
 + case internal ⇒ handleInternal ( authId , sessionId , internal ) 
 } 
 
 def resolved ( authId : Long , sessionId : Long , publisher : ActorRef , reSender : ActorRef ) : Receive = { 
 @ @ - 202 , 7 + 217 , 7 @ @ class Session ( 
 log . error ( " Received Envelope with another ' s authId and sessionId { } " , env ) 
 else 
 handleSessionMessage ( authId , sessionId , client , msg , publisher , reSender ) 
 - case internal ⇒ handleInternal ( internal ) 
 + case internal ⇒ handleInternal ( authId , sessionId , internal ) 
 } 
 
 private def recordClient ( client : ActorRef , reSender : ActorRef ) : Unit = { 
 @ @ - 256 , 8 + 271 , 10 @ @ class Session ( 
 } 
 } 
 
 - private def handleInternal ( message : Any ) = 
 + private def handleInternal ( authId : Long , sessionId : Long , message : Any ) = 
 message match { 
 + case AuthEvents . AuthIdInvalidated ⇒ 
 + sendAuthIdInvalidAndStop ( authId , sessionId ) 
 case ReceiveTimeout ⇒ 
 context . parent ! Passivate ( stopMessage = PoisonPill ) 
 case Terminated ( client ) ⇒ 
 @ @ - 266 , 4 + 283 , 12 @ @ class Session ( 
 log . error ( " Received unmatched message { } " , message ) 
 } 
 
 + private def sendAuthIdInvalidAndStop ( authId : Long , sessionId : Long ) : Unit = { 
 + log . warning ( " Reporting AuthIdInvalid and dying " ) 
 + 
 + clients foreach { client ⇒ 
 + client ! MTPackage ( authId , sessionId , MessageBoxCodec . encode ( MessageBox ( Long . MaxValue , AuthIdInvalid ) ) . require ) 
 + } 
 + self ! PoisonPill 
 + } 
 } 
 diff - - git a / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 index 5a9669c . . a7eba9f 100644 
 - - - a / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 + + + b / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 @ @ - 32 , 7 + 32 , 6 @ @ private [ session ] object SessionStream { 
 def graph ( 
 authId : Long , 
 sessionId : Long , 
 - firstMessageId : Long , 
 rpcHandler : ActorRef , 
 updatesHandler : ActorRef , 
 reSender : ActorRef 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala b / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala 
 index 95a0ae5 . . cace69b 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala 
 @ @ - 11 , 7 + 11 , 7 @ @ import com . amazonaws . services . s3 . transfer . TransferManager 
 import com . google . android . gcm . server . Sender 
 import com . typesafe . config . ConfigFactory 
 
 - import im . actor . api . rpc . auth . { RequestSendAuthCode , RequestSignUp , ResponseSendAuthCode } 
 + import im . actor . api . rpc . auth . _ 
 import im . actor . api . rpc . codecs . RequestCodec 
 import im . actor . api . rpc . sequence . RequestGetDifference 
 import im . actor . api . rpc . { Request , RpcOk , RpcResult } 
 @ @ - 49 , 7 + 49 , 9 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( 
 
 it should " notify about lost session " in Server . e3 
 
 - it should " throw AuthIdInvalid and close connection if sending wrong AuthId " in Server . e4 
 + it should " throw AuthIdInvalid if sending wrong AuthId " in Server . e4 
 + 
 + it should " throw AuthIdInvalid if valid AuthId invalidated by some reason " in Server . e5 
 
 implicit lazy val ( ds , db ) = migrateAndInitDb ( ) 
 
 @ @ - 73 , 18 + 75 , 18 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( 
 implicit val privatePeerManagerRegion = PrivatePeerManager . startRegion ( ) 
 implicit val groupPeerManagerRegion = GroupPeerManager . startRegion ( ) 
 
 + val mediator = DistributedPubSubExtension ( system ) . mediator 
 + 
 implicit val sessionConfig = SessionConfig . fromConfig ( system . settings . config . getConfig ( " session " ) ) 
 - Session . startRegion ( Some ( Session . props ) ) 
 + Session . startRegion ( Some ( Session . props ( mediator ) ) ) 
 implicit val sessionRegion = Session . startRegionProxy ( ) 
 
 - val mediator = DistributedPubSubExtension ( system ) . mediator 
 - 
 val bucketName = " actor - uploads - test " 
 val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) 
 implicit val transferManager = new TransferManager ( awsCredentials ) 
 
 val services = Seq ( 
 - new AuthServiceImpl ( new DummyActivationContext ) , 
 + new AuthServiceImpl ( new DummyActivationContext , mediator ) , 
 new ContactsServiceImpl , 
 MessagingServiceImpl ( mediator ) , 
 new SequenceServiceImpl 
 @ @ - 111 , 69 + 113 , 20 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( 
 val sessionId = 2L 
 val phoneNumber = 75550000000L 
 
 - val smsHash = { 
 - val helloMessageId = 4L 
 - val helloMbBytes = MessageBoxCodec . encode ( MessageBox ( helloMessageId , SessionHello ) ) . require 
 - val helloMtPackage = MTPackage ( authId , sessionId , helloMbBytes ) 
 - client . send ( helloMtPackage ) 
 - expectNewSession ( sessionId , helloMessageId ) 
 - expectMessageAck ( helloMessageId ) 
 - 
 - val messageId = 3L 
 - 
 - val requestBytes = RequestCodec . encode ( Request ( RequestSendAuthCode ( phoneNumber , 1 , " apiKey " ) ) ) . require 
 - val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require 
 - val mtPackage = MTPackage ( authId , sessionId , mbBytes ) 
 - 
 - client . send ( mtPackage ) 
 - 
 - expectMessageAck ( messageId ) 
 - 
 - val result = receiveRpcResult ( messageId ) 
 - result shouldBe an [ RpcOk ] 
 - 
 - result . asInstanceOf [ RpcOk ] . response . asInstanceOf [ ResponseSendAuthCode ] . smsHash 
 - } 
 - 
 - { 
 - val messageId = 4L 
 - 
 - val requestBytes = RequestCodec . encode ( Request ( RequestSignUp ( 
 - phoneNumber = phoneNumber , 
 - smsHash = smsHash , 
 - smsCode = " 0000 " , 
 - name = " Wayne Brain " , 
 - deviceHash = Array ( 4 , 5 , 6 ) , 
 - deviceTitle = " Specs virtual device " , 
 - appId = 1 , 
 - appKey = " appKey " , 
 - isSilent = false 
 - ) ) ) . require 
 - val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require 
 - val mtPackage = MTPackage ( authId , sessionId , mbBytes ) 
 - 
 - client . send ( mtPackage ) 
 + signUp ( authId , sessionId , phoneNumber ) 
 
 - expectMessageAck ( messageId ) 
 - 
 - val result = receiveRpcResult ( messageId ) 
 - result shouldBe an [ RpcOk ] 
 - } 
 - 
 - { 
 - val messageId = 5L 
 + val messageId = Random . nextLong ( ) 
 
 - val requestBytes = RequestCodec . encode ( Request ( RequestGetDifference ( 999 , Array ( ) ) ) ) . require 
 - val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require 
 - val mtPackage = MTPackage ( authId , sessionId , mbBytes ) 
 + val requestBytes = RequestCodec . encode ( Request ( RequestGetDifference ( 999 , Array ( ) ) ) ) . require 
 + val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require 
 + val mtPackage = MTPackage ( authId , sessionId , mbBytes ) 
 
 - client . send ( mtPackage ) 
 + client . send ( mtPackage ) 
 
 - expectMessageAck ( messageId ) 
 + expectMessageAck ( messageId ) 
 
 - val result = receiveRpcResult ( messageId ) 
 - result shouldBe an [ RpcOk ] 
 - } 
 + val result = receiveRpcResult ( messageId ) 
 + result shouldBe an [ RpcOk ] 
 
 client . close ( ) 
 } 
 @ @ - 220 , 6 + 173 , 99 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( 
 expectAuthIdInvalid ( ) 
 } 
 
 + def e5 ( ) = { 
 + val phoneNumber = 75551234567L 
 + 
 + val client1 = MTProtoClient ( ) 
 + client1 . connectAndHandshake ( remote ) 
 + val authId1 = requestAuthId ( ) ( client1 ) 
 + val sessionId1 = Random . nextLong ( ) 
 + 
 + val client2 = MTProtoClient ( ) 
 + client2 . connectAndHandshake ( remote ) 
 + val authId2 = requestAuthId ( ) ( client2 ) 
 + val sessionId2 = Random . nextLong ( ) 
 + 
 + { 
 + implicit val client = client1 
 + signUp ( authId1 , sessionId1 , phoneNumber ) 
 + } 
 + 
 + { 
 + implicit val client = client2 
 + signUp ( authId2 , sessionId2 , phoneNumber ) 
 + val requestBits = RequestCodec . encode ( Request ( RequestTerminateAllSessions ) ) . require 
 + client . send ( MTPackage ( authId2 , Random . nextLong ( ) , MessageBoxCodec . encode ( MessageBox ( Random . nextLong , RpcRequestBox ( requestBits ) ) ) . require ) ) 
 + } 
 + 
 + { 
 + implicit val client = client1 
 + expectAuthIdInvalid ( ) 
 + expectSessionLost ( ) 
 + 
 + client . send ( MTPackage ( authId1 , sessionId1 , MessageBoxCodec . encode ( MessageBox ( Random . nextLong , SessionHello ) ) . require ) ) 
 + expectAuthIdInvalid ( ) 
 + } 
 + } 
 + 
 + private def signUp ( authId : Long , sessionId : Long , phoneNumber : Long ) ( implicit client : MTProtoClient ) : Int = { 
 + require ( phoneNumber . toString . startsWith ( " 7555 " ) ) / / to be able to generate code 
 + require ( phoneNumber . toString . length > = 5 ) 
 + 
 + val smsHash = { 
 + val helloMessageId = Random . nextLong ( ) 
 + val helloMbBytes = MessageBoxCodec . encode ( MessageBox ( helloMessageId , SessionHello ) ) . require 
 + val helloMtPackage = MTPackage ( authId , sessionId , helloMbBytes ) 
 + client . send ( helloMtPackage ) 
 + expectNewSession ( sessionId , helloMessageId ) 
 + expectMessageAck ( helloMessageId ) 
 + 
 + val messageId = Random . nextLong ( ) 
 + 
 + val requestBytes = RequestCodec . encode ( Request ( RequestSendAuthCode ( phoneNumber , 1 , " apiKey " ) ) ) . require 
 + val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require 
 + val mtPackage = MTPackage ( authId , sessionId , mbBytes ) 
 + 
 + client . send ( mtPackage ) 
 + 
 + expectMessageAck ( messageId ) 
 + 
 + val result = receiveRpcResult ( messageId ) 
 + result shouldBe an [ RpcOk ] 
 + 
 + result . asInstanceOf [ RpcOk ] . response . asInstanceOf [ ResponseSendAuthCode ] . smsHash 
 + } 
 + 
 + { 
 + val messageId = Random . nextLong ( ) 
 + 
 + val code = phoneNumber . toString . charAt ( 4 ) . toString * 4 
 + 
 + val requestBytes = RequestCodec . encode ( Request ( RequestSignUp ( 
 + phoneNumber = phoneNumber , 
 + smsHash = smsHash , 
 + smsCode = code , 
 + name = " Wayne Brain " , 
 + deviceHash = Array ( 4 , 5 , 6 ) , 
 + deviceTitle = " Specs virtual device " , 
 + appId = 1 , 
 + appKey = " appKey " , 
 + isSilent = false 
 + ) ) ) . require 
 + val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RpcRequestBox ( requestBytes ) ) ) . require 
 + val mtPackage = MTPackage ( authId , sessionId , mbBytes ) 
 + 
 + client . send ( mtPackage ) 
 + 
 + expectMessageAck ( messageId ) 
 + 
 + val result = receiveRpcResult ( messageId ) 
 + result shouldBe an [ RpcOk ] 
 + 
 + result . asInstanceOf [ RpcOk ] . response . asInstanceOf [ ResponseAuth ] . user . id 
 + } 
 + } 
 + 
 private def requestAuthId ( ) ( implicit client : MTProtoClient ) : Long = { 
 val messageId = Random . nextLong ( ) 
 val mbBytes = MessageBoxCodec . encode ( MessageBox ( messageId , RequestAuthId ) ) . require 
 @ @ - 236 , 6 + 282 , 15 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( 
 mb . body shouldBe an [ AuthIdInvalid ] 
 } 
 
 + private def expectMessageAck ( ) ( implicit client : MTProtoClient ) : MessageAck = { 
 + val mb = receiveMessageBox ( ) 
 + mb . body shouldBe a [ MessageAck ] 
 + 
 + val ack = mb . body . asInstanceOf [ MessageAck ] 
 + 
 + ack 
 + } 
 + 
 private def expectMessageAck ( messageId : Long ) ( implicit client : MTProtoClient ) : MessageAck = { 
 val mb = receiveMessageBox ( ) 
 mb . body shouldBe a [ MessageAck ] 
 @ @ - 280 , 6 + 335 , 14 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( 
 body . asInstanceOf [ MTPackage ] 
 } 
 
 + private def expectNewSession ( ) ( implicit client : MTProtoClient ) : NewSession = { 
 + val mtp = receiveMTPackage ( ) 
 + 
 + val mb = MessageBoxCodec . decode ( mtp . messageBytes ) . require . value 
 + mb . body shouldBe a [ NewSession ] 
 + mb . body . asInstanceOf [ NewSession ] 
 + } 
 + 
 private def expectNewSession ( sessionId : Long , messageId : Long ) ( implicit client : MTProtoClient ) : Unit = { 
 val mtp = receiveMTPackage ( ) 
 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 index aed3614 . . a74ea8c 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 @ @ - 36 , 7 + 36 , 7 @ @ class AuthServiceSpec extends BaseServiceSuite { 
 implicit val sessionRegion = Session . startRegionProxy ( ) 
 implicit val seqUpdManagerRegion = buildSeqUpdManagerRegion ( ) 
 implicit val socialManagerRegion = SocialManager . startRegion ( ) 
 - implicit val service = new auth . AuthServiceImpl ( new DummyActivationContext ) 
 + implicit val service = new auth . AuthServiceImpl ( new DummyActivationContext , mediator ) 
 implicit val rpcApiService = system . actorOf ( RpcApiService . props ( Seq ( service ) ) ) 
 
 implicit val ec = system . dispatcher 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala 
 index 18c9e80 . . d79fe37 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala 
 @ @ - 36 , 6 + 36 , 8 @ @ trait UserStructExtensions { 
 trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { 
 this : Suite ⇒ 
 
 + val mediator : ActorRef 
 + 
 val fairy = Fairy . create ( ) 
 
 def buildPhone ( ) : Long = { 
 @ @ - 121 , 7 + 123 , 7 @ @ trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { 
 flowMaterializer : FlowMaterializer 
 ) = { 
 implicit val sessionConfig = SessionConfig . fromConfig ( system . settings . config . getConfig ( " session " ) ) 
 - Session . startRegion ( Some ( Session . props ) ) 
 + Session . startRegion ( Some ( Session . props ( mediator ) ) ) 
 } 
 
 def buildSessionRegionProxy ( ) ( implicit system : ActorSystem ) = Session . startRegionProxy ( ) 
 @ @ - 133 , 7 + 135 , 7 @ @ trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { 
 socialManagerRegion : SocialManagerRegion , 
 system : ActorSystem , 
 database : Database 
 - ) = new auth . AuthServiceImpl ( new DummyActivationContext ) 
 + ) = new auth . AuthServiceImpl ( new DummyActivationContext , mediator ) 
 
 protected def withoutLogs [ A ] ( f : ⇒ A ) ( implicit system : ActorSystem ) : A = { 
 val logger = org . slf4j . LoggerFactory . getLogger ( org . slf4j . Logger . ROOT _ LOGGER _ NAME ) . asInstanceOf [ ch . qos . logback . classic . Logger ] 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 index 1b43ae2 . . 8396a17 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 package im . actor . server . session 
 
 + import akka . contrib . pattern . DistributedPubSubExtension 
 + 
 import scala . concurrent . { Promise , Future , Await , blocking } 
 import scala . concurrent . duration . _ 
 import scala . util . { Success , Random } 
 @ @ - 42 , 12 + 44 , 14 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { ActorSpecification . creat 
 implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegion ( ) 
 implicit val socialManagerRegion = SocialManager . startRegion ( ) 
 
 + val mediator = DistributedPubSubExtension ( _ system ) . mediator 
 + 
 implicit val sessionConfig = SessionConfig . fromConfig ( system . settings . config . getConfig ( " session " ) ) 
 
 - Session . startRegion ( Some ( Session . props ) ) 
 + Session . startRegion ( Some ( Session . props ( mediator ) ) ) 
 
 implicit val sessionRegion = Session . startRegionProxy ( ) 
 - val authService = new AuthServiceImpl ( new DummyActivationContext ) 
 + val authService = new AuthServiceImpl ( new DummyActivationContext , mediator ) 
 val sequenceService = new SequenceServiceImpl 
 
 system . actorOf ( RpcApiService . props ( Seq ( authService , sequenceService ) ) , " rpcApiService " ) 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala 
 index 10f3498 . . fded7e8 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala 
 @ @ - 71 , 7 + 71 , 7 @ @ class SessionResendLargeSpec extends BaseSessionSpec ( 
 
 val authId = createAuthId ( ) 
 val sessionId = Random . nextLong ( ) 
 - val session = system . actorOf ( Session . props ) 
 + val session = system . actorOf ( Session . props ( mediator ) ) 
 watchProbe watch session 
 
 val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 index 4b329eb . . bbf1b29 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 @ @ - 40 , 7 + 40 , 7 @ @ class SessionSpec extends BaseSessionSpec { 
 def e1 ( ) = { 
 val authId = createAuthId ( ) 
 val sessionId = Random . nextLong ( ) 
 - val session = system . actorOf ( Session . props ) 
 + val session = system . actorOf ( Session . props ( mediator ) ) 
 
 sendEnvelope ( authId , sessionId , session , HandleMessageBox ( BitVector . empty . toByteArray ) ) 
 
 diff - - git a / src / main / scala / im / actor / server / Main . scala b / src / main / scala / im / actor / server / Main . scala 
 index 8a24d34 . . ee661f5 100644 
 - - - a / src / main / scala / im / actor / server / Main . scala 
 + + + b / src / main / scala / im / actor / server / Main . scala 
 @ @ - 85 , 10 + 85 , 12 @ @ class Main extends Bootable with DbInit with FlywayInit { 
 implicit val client = new AmazonS3ScalaClient ( awsCredentials ) 
 implicit val transferManager = new TransferManager ( awsCredentials ) 
 
 + val mediator = DistributedPubSubExtension ( system ) . mediator 
 + 
 val activationContext = SmsActivation . newContext ( smsConfig ) 
 
 Session . startRegion ( 
 - Some ( Session . props ) 
 + Some ( Session . props ( mediator ) ) 
 ) 
 
 implicit val sessionRegion = Session . startRegionProxy ( ) 
 @ @ - 103 , 14 + 105 , 12 @ @ class Main extends Bootable with DbInit with FlywayInit { 
 implicit val uploadManager = new UploadManager ( s3BucketName ) 
 MessageInterceptor . startSingleton ( ilectro , downloadManager , uploadManager ) 
 
 - val mediator = DistributedPubSubExtension ( system ) . mediator 
 - 
 val messagingService = MessagingServiceImpl ( mediator ) 
 
 RichMessageWorker . startWorker ( richMessageConfig , mediator ) 
 
 val services = Seq ( 
 - new AuthServiceImpl ( activationContext ) , 
 + new AuthServiceImpl ( activationContext , mediator ) , 
 new ContactsServiceImpl , 
 messagingService , 
 new GroupsServiceImpl ( s3BucketName , groupInviteConfig ) ,
