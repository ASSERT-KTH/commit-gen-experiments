BLEU SCORE: 0.537284965911771

TEST MSG: Update actor - ratchet . md
GENERATED MSG: Update axolotl - ratchet . md

TEST DIFF (one line): diff - - git a / docs / e2e / actor - ratchet . md b / docs / e2e / actor - ratchet . md < nl > index 36d646c . . bf6a24d 100644 < nl > - - - a / docs / e2e / actor - ratchet . md < nl > + + + b / docs / e2e / actor - ratchet . md < nl > @ @ - 1 , 4 + 1 , 4 @ @ < nl > - # Actor Ratchet ( ex Axolotl Ratchet ) < nl > + # Actor Ratchet ( based on Axolotl Ratchet ) < nl > < nl > Actor Ratchet is based on ideas of Axolotl Ratchet , but imrove it to make it self - healing proto if something goes wrong in implementation or device environment . < nl > < nl > @ @ - 6 , 6 + 6 , 8 @ @ Axolotl also requires to keep RootKey and complex state about encryption . We are < nl > < nl > Instead of Axolotl , Actor Ratchet support multi - device key syncing for better performance and less offline key verification iterations . < nl > < nl > + Actor Ratchet and Axolotl Ratchet are both session protocols , but unlike Axolotl - Actor ' s sessions are short lived . Actor ' s sessions are almost same as Axolotl , but they are supposed to live much shorter and can be easily discharged after 24 hours . < nl > + < nl > There are various sources for describing Axolotl Ratchet and there are different ways to implement this , our specs are based on : < nl > * https : / / whispersystems . org / blog / advanced - ratcheting / < nl > * https : / / github . com / trevp / axolotl / wiki < nl > @ @ - 22 , 30 + 24 , 60 @ @ All this keys are uploaded to Actor Server befor starting communcation . < nl > < nl > # Description < nl > < nl > - Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . < nl > - < nl > - When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . < nl > - < nl > We start with case when Alice wants to send message to Bob for the first time . < nl > < nl > Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs < nl > < nl > Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs < nl > < nl > - # # Computing parameters for first message < nl > + # # Sessions < nl > + < nl > + Each session is identified by * Identity Keys * and * Initial Ephermal Keys * . < nl > + < nl > + Each * * Session * * state contains : < nl > + * Identity Keys - static for a lifetime < nl > + * Initial Ephermal Keys - static for a lifetime < nl > + * Last 10 received ephermal keys - can be safely discharged in an 24 hours < nl > + * Last 10 sent ephermal keys - can be safely discharged in an 24 hours < nl > + < nl > + Even if * * Session * * is lost it could be restored without ephermal keys by just download new identity keys from server . New ephermal keys are healed right after first message exchange . Untill first message sent it is unable to receive any messages from this session . < nl > + < nl > + Each * Chain * state contains : < nl > + * Reference to related * * Session * * < nl > + * Current outgoing ephermal key < nl > + < nl > + # # Starting a new Session < nl > + < nl > + Alice pick own ephermal key pair ( A0 , A0 ' ) and bob ' s ephermal public key ( B0 ) - both of them are stored at server and can be easily downloaded by both parties . < nl > + < nl > + For deterministic key creation you need to assume that AI < BI . If it is not , swap A * and B * in calculation . < nl > < nl > - Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : < nl > + Based on ephermal keys both parties can compute master _ secret : < nl > ` ` ` < nl > master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) < nl > - master _ secret _ extendend = HKDF ( master _ secret , 64 ) < nl > - root _ key = master _ secret _ extendend [ 0 . . 31 ] < nl > - chain _ key = master _ secret _ extendend [ 32 . . 63 ] < nl > + ` ` ` < nl > + < nl > + There can be an issue that both sides creates new session with different ephermal keys . If app receives message from new session if should switch to a new one and discard old one ( * * TO BE DISCUSSED * * ) . Alternative is providing more control from server - side about negotiation of a session . < nl > + < nl > + # # Encryption Chain < nl > + < nl > + After establishing master _ secret client need to prepare encryption chain . For building a new chain client need to have one additional ephermal key from both sides . It can be used one of the public ephermal keys from server key directory or from previously received message . * * This keys are not required to be directly uploaded to key directory . * * < nl > + < nl > + Client ' s * MUST * create new ecnryption chains when they receive new ephermal key from other side or every 24 hours . < nl > + < nl > + Chain is * one - side * entity , that mean that only sender use it * * only * * for encryption and receiver use it * * only * * for decryption . < nl > + < nl > + Let ' s say we pick A1 and B1 keys to our new Chain then we will calculate * root _ chain _ key * : < nl > + ` ` ` < nl > + root _ chain _ key = HKDF ( key = ECDH ( A1 ' , B1 ) , salt = master _ secret , info = " ActorRatchet " . getBytes ( ) ) < nl > ` ` ` < nl > < nl > # # Encryption key for a message < nl > - For each message chain _ key is derived to a message _ key : < nl > + < nl > + Each message have message _ index in current encryption chain starting from zero . < nl > + For each message client need to generate message _ key based on root _ chain _ key , then exend it to 64 bytes with HKDF and split it to cipher _ key and mac _ key : < nl > ` ` ` < nl > - message _ key = HMAC _ SHA256 ( chain _ key , 0x01 ) < nl > + message _ key = HMAC _ SHA256 ( root _ chain _ key , message _ index [ 0 . . 4 ] ) < nl > message _ key _ extendend = HKDF ( message _ key , 64 ) < nl > cipher _ key = message _ key _ extendend [ 0 . . 31 ] < nl > mac _ key = message _ key _ extendend [ 32 . . 63 ]
NEAREST DIFF (one line): diff - - git a / docs / e2e / axolotl - ratchet . md b / docs / e2e / axolotl - ratchet . md < nl > index 90fd441 . . a2c0da5 100644 < nl > - - - a / docs / e2e / axolotl - ratchet . md < nl > + + + b / docs / e2e / axolotl - ratchet . md < nl > @ @ - 1 , 5 + 1 , 12 @ @ < nl > # Axolotl Ratchet < nl > < nl > + There are various sources for describing Axolotl Ratchet and there are different ways to implement this : < nl > + * https : / / whispersystems . org / blog / advanced - ratcheting / < nl > + * https : / / github . com / trevp / axolotl / wiki < nl > + * https : / / github . com / WhisperSystems / Signal - Android / wiki / ProtocolV2 < nl > + < nl > + We are trying to combine everything one one actual documentation and implement it in Actor . < nl > + < nl > # Public Keys < nl > < nl > Each Key Group have Curve25519 public keys : < nl > @ @ - 11 , 28 + 18 , 22 @ @ All this keys are uploaded to Actor Server befor starting communcation . < nl > < nl > # Description < nl > < nl > + Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . < nl > + < nl > + When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . < nl > + < nl > We start with case when Alice wants to send message to Bob for the first time . < nl > < nl > Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs < nl > < nl > Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs < nl > < nl > - # # Building initial initial _ root _ key < nl > - < nl > - Alice compute initial _ root _ key : < nl > - ` ` ` < nl > - initial _ root _ key = SHA256 ( ECDH ( AI ' , BI ) + ECDH ( AI ' , BI ) ) < nl > - ` ` ` < nl > - Bob compute initial _ root _ key : < nl > - ` ` ` < nl > - initial _ root _ key = SHA256 ( ECDH ( A0 , BI ' ) + ECDH ( AI ' , BI ) ) < nl > - ` ` ` < nl > - < nl > # # Computing parameters for first message < nl > < nl > - Alice generates random ephermal key pair ( A1 , A1 ' ) and picks random Bob ' s ephermal key - B1 < nl > - < nl > + Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : < nl > ` ` ` < nl > - master _ secret = SHA256 ( initial _ root _ key + ECDH ( A1 ' , B1 ) ) < nl > + master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) < nl > + master _ secret _ extendend = HKDF ( master _ secret , 64 ) < nl > + root _ key = master _ secret _ extendend [ 0 . . 31 ] < nl > + chain _ key = master _ secret _ extendend [ 32 . . 63 ] < nl > ` ` ` < nl > -

TEST DIFF:
diff - - git a / docs / e2e / actor - ratchet . md b / docs / e2e / actor - ratchet . md 
 index 36d646c . . bf6a24d 100644 
 - - - a / docs / e2e / actor - ratchet . md 
 + + + b / docs / e2e / actor - ratchet . md 
 @ @ - 1 , 4 + 1 , 4 @ @ 
 - # Actor Ratchet ( ex Axolotl Ratchet ) 
 + # Actor Ratchet ( based on Axolotl Ratchet ) 
 
 Actor Ratchet is based on ideas of Axolotl Ratchet , but imrove it to make it self - healing proto if something goes wrong in implementation or device environment . 
 
 @ @ - 6 , 6 + 6 , 8 @ @ Axolotl also requires to keep RootKey and complex state about encryption . We are 
 
 Instead of Axolotl , Actor Ratchet support multi - device key syncing for better performance and less offline key verification iterations . 
 
 + Actor Ratchet and Axolotl Ratchet are both session protocols , but unlike Axolotl - Actor ' s sessions are short lived . Actor ' s sessions are almost same as Axolotl , but they are supposed to live much shorter and can be easily discharged after 24 hours . 
 + 
 There are various sources for describing Axolotl Ratchet and there are different ways to implement this , our specs are based on : 
 * https : / / whispersystems . org / blog / advanced - ratcheting / 
 * https : / / github . com / trevp / axolotl / wiki 
 @ @ - 22 , 30 + 24 , 60 @ @ All this keys are uploaded to Actor Server befor starting communcation . 
 
 # Description 
 
 - Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . 
 - 
 - When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . 
 - 
 We start with case when Alice wants to send message to Bob for the first time . 
 
 Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs 
 
 Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs 
 
 - # # Computing parameters for first message 
 + # # Sessions 
 + 
 + Each session is identified by * Identity Keys * and * Initial Ephermal Keys * . 
 + 
 + Each * * Session * * state contains : 
 + * Identity Keys - static for a lifetime 
 + * Initial Ephermal Keys - static for a lifetime 
 + * Last 10 received ephermal keys - can be safely discharged in an 24 hours 
 + * Last 10 sent ephermal keys - can be safely discharged in an 24 hours 
 + 
 + Even if * * Session * * is lost it could be restored without ephermal keys by just download new identity keys from server . New ephermal keys are healed right after first message exchange . Untill first message sent it is unable to receive any messages from this session . 
 + 
 + Each * Chain * state contains : 
 + * Reference to related * * Session * * 
 + * Current outgoing ephermal key 
 + 
 + # # Starting a new Session 
 + 
 + Alice pick own ephermal key pair ( A0 , A0 ' ) and bob ' s ephermal public key ( B0 ) - both of them are stored at server and can be easily downloaded by both parties . 
 + 
 + For deterministic key creation you need to assume that AI < BI . If it is not , swap A * and B * in calculation . 
 
 - Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : 
 + Based on ephermal keys both parties can compute master _ secret : 
 ` ` ` 
 master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) 
 - master _ secret _ extendend = HKDF ( master _ secret , 64 ) 
 - root _ key = master _ secret _ extendend [ 0 . . 31 ] 
 - chain _ key = master _ secret _ extendend [ 32 . . 63 ] 
 + ` ` ` 
 + 
 + There can be an issue that both sides creates new session with different ephermal keys . If app receives message from new session if should switch to a new one and discard old one ( * * TO BE DISCUSSED * * ) . Alternative is providing more control from server - side about negotiation of a session . 
 + 
 + # # Encryption Chain 
 + 
 + After establishing master _ secret client need to prepare encryption chain . For building a new chain client need to have one additional ephermal key from both sides . It can be used one of the public ephermal keys from server key directory or from previously received message . * * This keys are not required to be directly uploaded to key directory . * * 
 + 
 + Client ' s * MUST * create new ecnryption chains when they receive new ephermal key from other side or every 24 hours . 
 + 
 + Chain is * one - side * entity , that mean that only sender use it * * only * * for encryption and receiver use it * * only * * for decryption . 
 + 
 + Let ' s say we pick A1 and B1 keys to our new Chain then we will calculate * root _ chain _ key * : 
 + ` ` ` 
 + root _ chain _ key = HKDF ( key = ECDH ( A1 ' , B1 ) , salt = master _ secret , info = " ActorRatchet " . getBytes ( ) ) 
 ` ` ` 
 
 # # Encryption key for a message 
 - For each message chain _ key is derived to a message _ key : 
 + 
 + Each message have message _ index in current encryption chain starting from zero . 
 + For each message client need to generate message _ key based on root _ chain _ key , then exend it to 64 bytes with HKDF and split it to cipher _ key and mac _ key : 
 ` ` ` 
 - message _ key = HMAC _ SHA256 ( chain _ key , 0x01 ) 
 + message _ key = HMAC _ SHA256 ( root _ chain _ key , message _ index [ 0 . . 4 ] ) 
 message _ key _ extendend = HKDF ( message _ key , 64 ) 
 cipher _ key = message _ key _ extendend [ 0 . . 31 ] 
 mac _ key = message _ key _ extendend [ 32 . . 63 ]

NEAREST DIFF:
diff - - git a / docs / e2e / axolotl - ratchet . md b / docs / e2e / axolotl - ratchet . md 
 index 90fd441 . . a2c0da5 100644 
 - - - a / docs / e2e / axolotl - ratchet . md 
 + + + b / docs / e2e / axolotl - ratchet . md 
 @ @ - 1 , 5 + 1 , 12 @ @ 
 # Axolotl Ratchet 
 
 + There are various sources for describing Axolotl Ratchet and there are different ways to implement this : 
 + * https : / / whispersystems . org / blog / advanced - ratcheting / 
 + * https : / / github . com / trevp / axolotl / wiki 
 + * https : / / github . com / WhisperSystems / Signal - Android / wiki / ProtocolV2 
 + 
 + We are trying to combine everything one one actual documentation and implement it in Actor . 
 + 
 # Public Keys 
 
 Each Key Group have Curve25519 public keys : 
 @ @ - 11 , 28 + 18 , 22 @ @ All this keys are uploaded to Actor Server befor starting communcation . 
 
 # Description 
 
 + Axolotl Ratchet is a session protocol . When session is established you there are no need to abort it . Axolotl is a stateful protocol that means that you need to keep state for each session . Sessions are established between each device . 
 + 
 + When session is simulatenously created from both sides , then application need to use any of them , but keep state for each one . We recommend to pick something with lower id of each session . 
 + 
 We start with case when Alice wants to send message to Bob for the first time . 
 
 Alice keys : ( AI , AI ' ) - identity key paris , ( A1 , A1 ' ) . . ( AN , AN ' ) - ephermal key pairs 
 
 Bob keys : ( BI , BI ' ) - identity key paris , ( B1 , AB ' ) . . ( BN , BN ' ) - ephermal key pairs 
 
 - # # Building initial initial _ root _ key 
 - 
 - Alice compute initial _ root _ key : 
 - ` ` ` 
 - initial _ root _ key = SHA256 ( ECDH ( AI ' , BI ) + ECDH ( AI ' , BI ) ) 
 - ` ` ` 
 - Bob compute initial _ root _ key : 
 - ` ` ` 
 - initial _ root _ key = SHA256 ( ECDH ( A0 , BI ' ) + ECDH ( AI ' , BI ) ) 
 - ` ` ` 
 - 
 # # Computing parameters for first message 
 
 - Alice generates random ephermal key pair ( A1 , A1 ' ) and picks random Bob ' s ephermal key - B1 
 - 
 + Alice generates random ephermal key pair ( A0 , A0 ' ) and picks random Bob ' s ephermal key - B0 . Then generates master _ secret , then stretch key to 64 bytes and get RootKey and ChainKey : 
 ` ` ` 
 - master _ secret = SHA256 ( initial _ root _ key + ECDH ( A1 ' , B1 ) ) 
 + master _ secret = SHA256 ( ECDH ( AI ' , B0 ) + ECDH ( A0 ' , BI ) + ECDH ( A0 ' , B0 ) ) 
 + master _ secret _ extendend = HKDF ( master _ secret , 64 ) 
 + root _ key = master _ secret _ extendend [ 0 . . 31 ] 
 + chain _ key = master _ secret _ extendend [ 32 . . 63 ] 
 ` ` ` 
 -
