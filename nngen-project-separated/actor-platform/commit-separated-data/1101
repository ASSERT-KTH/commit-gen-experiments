BLEU SCORE: 0.033864985683445356

TEST MSG: refactor ( server ) : replace some system . log by log
GENERATED MSG: Merge branch ' server / master '

TEST DIFF (one line): diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala < nl > index 45b5b9c . . 0c9fe7f 100644 < nl > - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala < nl > + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . server . activation . gate < nl > < nl > import akka . actor . ActorSystem < nl > + import akka . event . Logging < nl > import im . actor . server . activation . Activation . Code < nl > import im . actor . server . activation . _ < nl > import im . actor . server . persist < nl > @ @ - 19 , 13 + 20 , 15 @ @ import scalaz . { - \ / , \ / , \ / - } < nl > class GateCodeActivation ( config : GateConfig ) ( implicit system : ActorSystem ) extends CodeActivation with JsonFormatters with PlayJsonSupport { < nl > import system . dispatcher < nl > < nl > + private val log = Logging ( system , getClass ) < nl > + < nl > val pipeline : HttpRequest ⇒ Future [ HttpResponse ] = addHeader ( " X - Auth - Token " , config . authToken ) ~ > sendReceive < nl > < nl > override def send ( optTransactionHash : Option [ String ] , code : Code ) : DBIO [ CodeFailure \ / Unit ] = { < nl > val codeResponse : Future [ CodeResponse ] = for { < nl > entity ← marshalToEntity ( code ) < nl > request = HttpRequest ( method = POST , uri = s " $ { config . uri } / v1 / codes / send " , entity = entity ) < nl > - _ = system . log . debug ( " Requesting code send with { } " , request ) < nl > + _ = log . debug ( " Requesting code send with { } " , request ) < nl > resp ← pipeline ( request ) < nl > codeResp ← unmarshal [ CodeResponse ] ( resp ) < nl > } yield codeResp < nl > @ @ - 49 , 7 + 52 , 7 @ @ class GateCodeActivation ( config : GateConfig ) ( implicit system : ActorSystem ) exten < nl > validationResponse ← DBIO . from ( optCodeHash map { codeHash ⇒ < nl > val validationUri = Uri ( s " $ { config . uri } / v1 / codes / validate / $ { codeHash . codeHash } " ) . withQuery ( " code " → code ) < nl > val request = HttpRequest ( GET , validationUri ) < nl > - system . log . debug ( " Requesting code validation with { } " , request ) < nl > + log . debug ( " Requesting code validation with { } " , request ) < nl > < nl > for { < nl > response ← pipeline ( request ) < nl > @ @ - 64 , 7 + 67 , 7 @ @ class GateCodeActivation ( config : GateConfig ) ( implicit system : ActorSystem ) exten < nl > private def marshalToEntity [ T : ClassTag ] ( value : T ) ( implicit marshaller : Marshaller [ T ] ) : Future [ HttpEntity ] = < nl > marshal [ T ] ( value ) match { < nl > case Left ( e ) ⇒ < nl > - system . log . warning ( " Failed to marshal value : { } " , e ) < nl > + log . warning ( " Failed to marshal value : { } " , e ) < nl > Future . failed ( e ) < nl > case Right ( entity ) ⇒ Future . successful ( entity ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 034621c . . 7983e40 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 207 , 18 + 207 , 18 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > case Seq ( ) ⇒ < nl > - system . log . debug ( " No delivery extensions , using default one " ) < nl > + log . debug ( " No delivery extensions , using default one " ) < nl > new ActorDelivery ( ) < nl > case ext + : tail ⇒ < nl > - system . log . debug ( " Got extensions : { } " , extensions ) < nl > + log . debug ( " Got extensions : { } " , extensions ) < nl > val idToName = InternalExtensions . extensions ( InternalDialogExtensions ) < nl > idToName . get ( ext . id ) flatMap { className ⇒ < nl > val extension = InternalExtensions . extensionOf [ DeliveryExtension ] ( className , system , ext . data ) . toOption < nl > - system . log . debug ( " Created delivery extension : { } " , extension ) < nl > + log . debug ( " Created delivery extension : { } " , extension ) < nl > extension < nl > } getOrElse { < nl > val err = s " Dialog extension with id : $ { ext . id } was not found " < nl > - system . log . error ( err ) < nl > + log . error ( err ) < nl > throw new Exception ( err ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala < nl > index 3f21b2c . . 3eaf83a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala < nl > @ @ - 2 , 23 + 2 , 28 @ @ package im . actor . server . group < nl > < nl > import akka . actor . { ActorRef , ActorSystem , Props } < nl > import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } < nl > + import akka . event . Logging < nl > import im . actor . server . dialog . DialogCommands . Envelope < nl > import im . actor . server . model . { Peer , PeerType } < nl > < nl > object GroupProcessorRegion { < nl > private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { < nl > - case c : GroupCommand ⇒ ( c . groupId . toString , c ) < nl > - case q : GroupQuery ⇒ ( q . groupId . toString , q ) < nl > - case e @ Envelope ( peer , payload ) ⇒ peer match { < nl > - case Peer ( PeerType . Group , groupId ) ⇒ < nl > - e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { < nl > - case Some ( any ) ⇒ ( groupId . toString , any ) < nl > - case None ⇒ < nl > - val error = new RuntimeException ( s " Payload not found for $ e " ) < nl > - system . log . error ( error , error . getMessage ) < nl > - throw error < nl > - } < nl > - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in GroupProcessor " ) < nl > + val log = Logging ( system , getClass ) < nl > + < nl > + { < nl > + case c : GroupCommand ⇒ ( c . groupId . toString , c ) < nl > + case q : GroupQuery ⇒ ( q . groupId . toString , q ) < nl > + case e @ Envelope ( peer , payload ) ⇒ peer match { < nl > + case Peer ( PeerType . Group , groupId ) ⇒ < nl > + e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { < nl > + case Some ( any ) ⇒ ( groupId . toString , any ) < nl > + case None ⇒ < nl > + val error = new RuntimeException ( s " Payload not found for $ e " ) < nl > + log . error ( error , error . getMessage ) < nl > + throw error < nl > + } < nl > + case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in GroupProcessor " ) < nl > + } < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushManager . scala < nl > index ddf1c63 . . 133e35c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushManager . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushManager . scala < nl > @ @ - 85 , 13 + 85 , 14 @ @ private class LoggingRejectedNotificationListener ( _ system : ActorSystem ) extends < nl > private implicit val system : ActorSystem = _ system < nl > private implicit val ec : ExecutionContext = _ system . dispatcher < nl > private lazy val seqUpdExt = SeqUpdatesExtension ( system ) < nl > + private val log = Logging ( system , getClass ) < nl > < nl > override def handleRejectedNotification ( pushManager : PushManager [ _ < : SimpleApnsPushNotification ] , notification : SimpleApnsPushNotification , rejectionReason : RejectedNotificationReason ) : Unit = { < nl > - system . log . warning ( " APNS rejected notification with reason : { } " , rejectionReason ) < nl > + log . warning ( " APNS rejected notification with reason : { } " , rejectionReason ) < nl > < nl > if ( rejectionReason . getErrorCode = = RejectedNotificationReason . INVALID _ TOKEN . getErrorCode ) { < nl > - system . log . warning ( " Deleting token " ) < nl > - system . log . error ( " Implement push token deletion " ) < nl > + log . warning ( " Deleting token " ) < nl > + log . error ( " Implement push token deletion " ) < nl > seqUpdExt . deleteApplePushCredentials ( notification . getToken ) < nl > } < nl > } < nl > @ @ - 99 , 6 + 100 , 7 @ @ private class LoggingRejectedNotificationListener ( _ system : ActorSystem ) extends < nl > < nl > private class CleanExpiredTokenListener ( _ system : ActorSystem ) extends ExpiredTokenListener [ SimpleApnsPushNotification ] { < nl > private implicit val system : ActorSystem = _ system < nl > + private val log = Logging ( system , getClass ) < nl > implicit val db : Database = DbExtension ( system ) . db < nl > < nl > override def handleExpiredTokens ( < nl > @ @ - 106 , 7 + 108 , 7 @ @ private class CleanExpiredTokenListener ( _ system : ActorSystem ) extends ExpiredTok < nl > expiredTokens : util . Collection [ ExpiredToken ] < nl > ) : Unit = { < nl > expiredTokens foreach { t ⇒ < nl > - system . log . warning ( " APNS reported expired token " ) < nl > + log . warning ( " APNS reported expired token " ) < nl > / / UserExtension ( system ) . logoutByAppleToken ( t . getToken ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesManagerRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesManagerRegion . scala < nl > index fb1d59a . . 6fbc993 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesManagerRegion . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesManagerRegion . scala < nl > @ @ - 2 , 6 + 2 , 7 @ @ package im . actor . server . sequence < nl > < nl > import akka . actor . { ActorRef , ActorSystem , Props } < nl > import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } < nl > + import akka . event . Logging < nl > < nl > final case class SeqUpdatesManagerRegion ( ref : ActorRef ) < nl > < nl > @ @ - 10 , 13 + 11 , 17 @ @ object SeqUpdatesManagerRegion { < nl > import UserSequenceCommands . _ < nl > < nl > private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { < nl > - case e @ Envelope ( userId , payload ) ⇒ ( userId . toString , e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { < nl > - case Some ( any ) ⇒ any < nl > - case None ⇒ < nl > - val error = new RuntimeException ( s " Payload not found for $ e " ) < nl > - system . log . error ( error , error . getMessage ) < nl > - throw error < nl > - } ) < nl > + val log = Logging ( system , getClass ) < nl > + < nl > + { < nl > + case e @ Envelope ( userId , payload ) ⇒ ( userId . toString , e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { < nl > + case Some ( any ) ⇒ any < nl > + case None ⇒ < nl > + val error = new RuntimeException ( s " Payload not found for $ e " ) < nl > + log . error ( error , error . getMessage ) < nl > + throw error < nl > + } ) < nl > + } < nl > } < nl > < nl > private val extractShardId : ShardRegion . ExtractShardId = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala < nl > index 6d1dd74 . . a4685c9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . server . stickers < nl > < nl > import akka . actor . _ < nl > + import akka . event . Logging < nl > import cats . data . Xor < nl > import im . actor . api . rpc . stickers . { ApiStickerCollection , UpdateOwnStickersChanged , UpdateStickerCollectionsChanged } < nl > import im . actor . concurrent . { FutureExt , FutureResultCats } < nl > @ @ - 46 , 6 + 47 , 7 @ @ final class StickersExtensionImpl ( _ system : ActorSystem ) < nl > implicit val system : ActorSystem = _ system < nl > import system . dispatcher < nl > < nl > + private val log = Logging ( system , getClass ) < nl > private val db = DbExtension ( system ) . db < nl > private val userExt = UserExtension ( system ) < nl > private val seqExt = SeqUpdatesExtension ( system ) < nl > @ @ - 137 , 10 + 139 , 10 @ @ final class StickersExtensionImpl ( _ system : ActorSystem ) < nl > private def toggleDefault ( userId : Int , packId : Int , toggleTo : Boolean ) : Future [ StickerError Xor Unit ] = < nl > ( for { < nl > isAdmin ← fromFuture ( userExt . isAdmin ( userId ) ) < nl > - _ = system . log . debug ( " user : { } is admin : { } " , userId , isAdmin ) < nl > + _ = log . debug ( " user : { } is admin : { } " , userId , isAdmin ) < nl > _ ← fromBoolean ( NotAdmin ) ( isAdmin ) < nl > pack ← fromFutureOption ( NotFound ) ( db . run ( StickerPackRepo . find ( packId ) ) ) < nl > - _ = system . log . debug ( " sticker pack : { } " , pack ) < nl > + _ = log . debug ( " sticker pack : { } " , pack ) < nl > _ ← fromBoolean ( isDefaultError ( toggleTo ) ) ( pack . isDefault ! = toggleTo ) < nl > _ ← fromFuture ( db . run ( StickerPackRepo . setDefault ( packId , isDefault = toggleTo ) ) ) < nl > _ = broadcastOwnStickersChanged ( ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala < nl > index f9ddc39 . . 1be6a52 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . server . user < nl > < nl > import akka . actor . _ < nl > + import akka . event . Logging < nl > import akka . util . Timeout < nl > import im . actor . hook . _ < nl > import im . actor . server . sequence . SeqUpdatesExtension < nl > @ @ - 21 , 6 + 22 , 7 @ @ final class UserExtensionImpl ( actorSystem : ActorSystem ) extends UserExtension wi < nl > implicit val system = actorSystem < nl > < nl > import system . dispatcher < nl > + val log = Logging ( system , getClass ) < nl > < nl > lazy val processorRegion : UserProcessorRegion = UserProcessorRegion . start ( ) ( system ) < nl > lazy val viewRegion : UserViewRegion = UserViewRegion ( processorRegion . ref ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > index ee91cac . . 554a6e2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > @ @ - 2 , 6 + 2 , 7 @ @ package im . actor . server . user < nl > < nl > import akka . actor . { ActorRef , ActorSystem } < nl > import akka . cluster . pubsub . DistributedPubSub < nl > + import akka . event . { LoggingAdapter , Logging } < nl > import akka . pattern . ask < nl > import akka . util . Timeout < nl > import com . google . protobuf . ByteString < nl > @ @ - 230 , 6 + 231 , 7 @ @ private [ user ] sealed trait Queries { < nl > val viewRegion : UserViewRegion < nl > implicit val system : ActorSystem < nl > import system . dispatcher < nl > + val log : LoggingAdapter < nl > < nl > implicit val timeout : Timeout < nl > < nl > @ @ - 307 , 7 + 309 , 7 @ @ private [ user ] sealed trait AuthCommands { < nl > } < nl > < nl > def logout ( session : model . AuthSession ) ( implicit db : Database ) : Future [ Unit ] = { < nl > - system . log . warning ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) < nl > + log . warning ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) < nl > for { < nl > _ ← removeAuth ( session . userId , session . authId ) < nl > _ ← SeqUpdatesExtension ( system ) . deletePushCredentials ( session . authId ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > index 841b357 . . 361d14b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > @ @ - 1 , 6 + 1 , 6 @ @ < nl > package im . actor . server . user < nl > < nl > - import akka . actor . { Actor , ActorRef , Props } < nl > + import akka . actor . { ActorLogging , Actor , ActorRef , Props } < nl > import im . actor . api . rpc . PeersImplicits < nl > import im . actor . api . rpc . misc . ApiExtension < nl > import im . actor . server . dialog . { DirectDialogCommand , DialogProcessor , DialogCommand } < nl > @ @ - 10 , 7 + 10 , 7 @ @ private [ user ] object UserPeer { < nl > def props ( userId : Int , extensions : Seq [ ApiExtension ] ) = Props ( classOf [ UserPeer ] , userId , extensions ) < nl > } < nl > < nl > - private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Actor with PeersImplicits { < nl > + private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Actor with ActorLogging with PeersImplicits { < nl > < nl > private val selfPeer = Peer . privat ( userId ) < nl > < nl > @ @ - 19 , 7 + 19 , 7 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e < nl > case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc < nl > / / Forward to a dest user dialog < nl > case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc < nl > - case other ⇒ context . system . log . debug ( " Unmatched message : { } " , other ) < nl > + case other ⇒ log . debug ( " Unmatched message : { } " , other ) < nl > } < nl > < nl > private def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala < nl > index f2db461 . . 8e7593e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala < nl > @ @ - 2 , 23 + 2 , 28 @ @ package im . actor . server . user < nl > < nl > import akka . actor . { ActorRef , ActorSystem , Props } < nl > import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } < nl > + import akka . event . Logging < nl > import im . actor . server . dialog . DialogCommands . Envelope < nl > import im . actor . server . model . { Peer , PeerType } < nl > < nl > object UserProcessorRegion { < nl > private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { < nl > - case c : UserCommand ⇒ ( c . userId . toString , c ) < nl > - case q : UserQuery ⇒ ( q . userId . toString , q ) < nl > - case e @ Envelope ( peer , payload ) ⇒ peer match { < nl > - case Peer ( PeerType . Private , userId ) ⇒ < nl > - e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { < nl > - case Some ( any ) ⇒ ( userId . toString , any ) < nl > - case None ⇒ < nl > - val error = new RuntimeException ( s " Payload not found for $ e " ) < nl > - system . log . error ( error , error . getMessage ) < nl > - throw error < nl > - } < nl > - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) < nl > + val log = Logging ( system , getClass ) < nl > + < nl > + { < nl > + case c : UserCommand ⇒ ( c . userId . toString , c ) < nl > + case q : UserQuery ⇒ ( q . userId . toString , q ) < nl > + case e @ Envelope ( peer , payload ) ⇒ peer match { < nl > + case Peer ( PeerType . Private , userId ) ⇒ < nl > + e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { < nl > + case Some ( any ) ⇒ ( userId . toString , any ) < nl > + case None ⇒ < nl > + val error = new RuntimeException ( s " Payload not found for $ e " ) < nl > + log . error ( error , error . getMessage ) < nl > + throw error < nl > + } < nl > + case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) < nl > + } < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / IngoingHooks . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / IngoingHooks . scala < nl > index a0230f0 . . 441447c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / IngoingHooks . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / IngoingHooks . scala < nl > @ @ - 31 , 7 + 31 , 7 @ @ trait IngoingHooks extends ContentUnmarshaller with PlayJsonSupport { < nl > case Right ( _ ) ⇒ complete ( OK → Status ( " Ok " ) ) < nl > } < nl > case Failure ( e ) ⇒ < nl > - system . log . error ( e , " Failed to handle ingoing hook " ) < nl > + log . error ( e , " Failed to handle ingoing hook " ) < nl > complete ( InternalServerError ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / WebhooksHttpHandler . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / WebhooksHttpHandler . scala < nl > index aa3f573 . . 87ff2a6 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / WebhooksHttpHandler . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / WebhooksHttpHandler . scala < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . server . webhooks . http . routes < nl > < nl > import akka . actor . ActorSystem < nl > + import akka . event . Logging < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . Route < nl > import akka . stream . { ActorMaterializer , Materializer } < nl > @ @ - 23 , 6 + 24 , 7 @ @ final class WebhooksHttpHandler ( ) ( implicit val system : ActorSystem ) < nl > < nl > implicit val timeout : Timeout = Timeout ( 5 . seconds ) < nl > < nl > + protected val log = Logging ( system , getClass ) < nl > protected val integrationTokensKv = ShardakkaExtension ( system ) . simpleKeyValue [ Int ] ( KeyValueMappings . IntegrationTokens , IntCodec ) < nl > < nl > override def routes : Route =
NEAREST DIFF (one line): diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / IlectroUser . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / IlectroUser . scala < nl > deleted file mode 100644 < nl > index 189d99e . . 0000000 < nl > - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / IlectroUser . scala < nl > + + + / dev / null < nl > @ @ - 1 , 5 + 0 , 0 @ @ < nl > - package im . actor . server . models . llectro < nl > - < nl > - import java . util . UUID < nl > - < nl > - case class LlectroUser ( userId : Int , uuid : UUID , name : String ) < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / Interest . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / Interest . scala < nl > deleted file mode 100644 < nl > index d5e361a . . 0000000 < nl > - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / Interest . scala < nl > + + + / dev / null < nl > @ @ - 1 , 3 + 0 , 0 @ @ < nl > - package im . actor . server . models . llectro < nl > - < nl > - case class Interest ( id : Int , name : String , parentId : Int , fullPath : String , level : Int ) < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / LlectroDevice . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / LlectroDevice . scala < nl > deleted file mode 100644 < nl > index 268056a . . 0000000 < nl > - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / LlectroDevice . scala < nl > + + + / dev / null < nl > @ @ - 1 , 3 + 0 , 0 @ @ < nl > - package im . actor . server . models . llectro < nl > - < nl > - case class LlectroDevice ( authId : Long , screenWidth : Int , screenHeight : Int ) < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / UserInterest . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / UserInterest . scala < nl > deleted file mode 100644 < nl > index 963e5df . . 0000000 < nl > - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / UserInterest . scala < nl > + + + / dev / null < nl > @ @ - 1 , 3 + 0 , 0 @ @ < nl > - package im . actor . server . models . llectro < nl > - < nl > - case class UserInterest ( userId : Int , interestId : Int ) < nl > \ No newline at end of file < nl > diff - - git a / actor - server / bin / merge - to - master b / actor - server / bin / merge - to - master < nl > new file mode 100755 < nl > index 0000000 . . 57bea44 < nl > - - - / dev / null < nl > + + + b / actor - server / bin / merge - to - master < nl > @ @ - 0 , 0 + 1 , 15 @ @ < nl > + # ! / usr / bin / env bash < nl > + < nl > + set - eu < nl > + < nl > + git diff - index - - quiet - - cached HEAD < nl > + < nl > + if [ $ ? - eq 0 ] < nl > + then < nl > + git checkout master < nl > + git pull - - rebase origin master < nl > + git merge server / master < nl > + git push origin master < nl > + else < nl > + echo " Branch is dirty " < nl > + fi < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 0ae9ff5 . . 1d00c84 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 38 , 7 + 38 , 6 @ @ object Dependencies { < nl > < nl > val concmap = " com . googlecode . concurrentlinkedhashmap " % " concurrentlinkedhashmap - lru " % " 1 . 4 . 2 " < nl > val caffeine = " com . github . ben - manes . caffeine " % " caffeine " % " 1 . 2 . 0 " < nl > - val eaioUuid = " com . eaio . uuid " % " uuid " % " 3 . 4 " < nl > < nl > val cats = " org . spire - math " % % " cats " % V . cats < nl > < nl > @ @ - 166 , 7 + 165 , 7 @ @ object Dependencies { < nl > < nl > val codecs = shared + + Seq ( scalazCore , scodecBits , scodecCore ) < nl > < nl > - val models = shared + + Seq ( eaioUuid , scodecBits , scodecCore , jodaTime , jodaConvert , slickPg ) < nl > + val models = shared + + Seq ( scodecBits , scodecCore , jodaTime , jodaConvert , slickPg ) < nl > < nl > val frontend = shared + + Seq ( < nl > akkaSlf4j , akkaActor , akkaStream ,

TEST DIFF:
diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala 
 index 45b5b9c . . 0c9fe7f 100644 
 - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala 
 + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . server . activation . gate 
 
 import akka . actor . ActorSystem 
 + import akka . event . Logging 
 import im . actor . server . activation . Activation . Code 
 import im . actor . server . activation . _ 
 import im . actor . server . persist 
 @ @ - 19 , 13 + 20 , 15 @ @ import scalaz . { - \ / , \ / , \ / - } 
 class GateCodeActivation ( config : GateConfig ) ( implicit system : ActorSystem ) extends CodeActivation with JsonFormatters with PlayJsonSupport { 
 import system . dispatcher 
 
 + private val log = Logging ( system , getClass ) 
 + 
 val pipeline : HttpRequest ⇒ Future [ HttpResponse ] = addHeader ( " X - Auth - Token " , config . authToken ) ~ > sendReceive 
 
 override def send ( optTransactionHash : Option [ String ] , code : Code ) : DBIO [ CodeFailure \ / Unit ] = { 
 val codeResponse : Future [ CodeResponse ] = for { 
 entity ← marshalToEntity ( code ) 
 request = HttpRequest ( method = POST , uri = s " $ { config . uri } / v1 / codes / send " , entity = entity ) 
 - _ = system . log . debug ( " Requesting code send with { } " , request ) 
 + _ = log . debug ( " Requesting code send with { } " , request ) 
 resp ← pipeline ( request ) 
 codeResp ← unmarshal [ CodeResponse ] ( resp ) 
 } yield codeResp 
 @ @ - 49 , 7 + 52 , 7 @ @ class GateCodeActivation ( config : GateConfig ) ( implicit system : ActorSystem ) exten 
 validationResponse ← DBIO . from ( optCodeHash map { codeHash ⇒ 
 val validationUri = Uri ( s " $ { config . uri } / v1 / codes / validate / $ { codeHash . codeHash } " ) . withQuery ( " code " → code ) 
 val request = HttpRequest ( GET , validationUri ) 
 - system . log . debug ( " Requesting code validation with { } " , request ) 
 + log . debug ( " Requesting code validation with { } " , request ) 
 
 for { 
 response ← pipeline ( request ) 
 @ @ - 64 , 7 + 67 , 7 @ @ class GateCodeActivation ( config : GateConfig ) ( implicit system : ActorSystem ) exten 
 private def marshalToEntity [ T : ClassTag ] ( value : T ) ( implicit marshaller : Marshaller [ T ] ) : Future [ HttpEntity ] = 
 marshal [ T ] ( value ) match { 
 case Left ( e ) ⇒ 
 - system . log . warning ( " Failed to marshal value : { } " , e ) 
 + log . warning ( " Failed to marshal value : { } " , e ) 
 Future . failed ( e ) 
 case Right ( entity ) ⇒ Future . successful ( entity ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 034621c . . 7983e40 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 207 , 18 + 207 , 18 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 case Seq ( ) ⇒ 
 - system . log . debug ( " No delivery extensions , using default one " ) 
 + log . debug ( " No delivery extensions , using default one " ) 
 new ActorDelivery ( ) 
 case ext + : tail ⇒ 
 - system . log . debug ( " Got extensions : { } " , extensions ) 
 + log . debug ( " Got extensions : { } " , extensions ) 
 val idToName = InternalExtensions . extensions ( InternalDialogExtensions ) 
 idToName . get ( ext . id ) flatMap { className ⇒ 
 val extension = InternalExtensions . extensionOf [ DeliveryExtension ] ( className , system , ext . data ) . toOption 
 - system . log . debug ( " Created delivery extension : { } " , extension ) 
 + log . debug ( " Created delivery extension : { } " , extension ) 
 extension 
 } getOrElse { 
 val err = s " Dialog extension with id : $ { ext . id } was not found " 
 - system . log . error ( err ) 
 + log . error ( err ) 
 throw new Exception ( err ) 
 } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala 
 index 3f21b2c . . 3eaf83a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessorRegion . scala 
 @ @ - 2 , 23 + 2 , 28 @ @ package im . actor . server . group 
 
 import akka . actor . { ActorRef , ActorSystem , Props } 
 import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } 
 + import akka . event . Logging 
 import im . actor . server . dialog . DialogCommands . Envelope 
 import im . actor . server . model . { Peer , PeerType } 
 
 object GroupProcessorRegion { 
 private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { 
 - case c : GroupCommand ⇒ ( c . groupId . toString , c ) 
 - case q : GroupQuery ⇒ ( q . groupId . toString , q ) 
 - case e @ Envelope ( peer , payload ) ⇒ peer match { 
 - case Peer ( PeerType . Group , groupId ) ⇒ 
 - e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { 
 - case Some ( any ) ⇒ ( groupId . toString , any ) 
 - case None ⇒ 
 - val error = new RuntimeException ( s " Payload not found for $ e " ) 
 - system . log . error ( error , error . getMessage ) 
 - throw error 
 - } 
 - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in GroupProcessor " ) 
 + val log = Logging ( system , getClass ) 
 + 
 + { 
 + case c : GroupCommand ⇒ ( c . groupId . toString , c ) 
 + case q : GroupQuery ⇒ ( q . groupId . toString , q ) 
 + case e @ Envelope ( peer , payload ) ⇒ peer match { 
 + case Peer ( PeerType . Group , groupId ) ⇒ 
 + e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { 
 + case Some ( any ) ⇒ ( groupId . toString , any ) 
 + case None ⇒ 
 + val error = new RuntimeException ( s " Payload not found for $ e " ) 
 + log . error ( error , error . getMessage ) 
 + throw error 
 + } 
 + case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in GroupProcessor " ) 
 + } 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushManager . scala 
 index ddf1c63 . . 133e35c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushManager . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushManager . scala 
 @ @ - 85 , 13 + 85 , 14 @ @ private class LoggingRejectedNotificationListener ( _ system : ActorSystem ) extends 
 private implicit val system : ActorSystem = _ system 
 private implicit val ec : ExecutionContext = _ system . dispatcher 
 private lazy val seqUpdExt = SeqUpdatesExtension ( system ) 
 + private val log = Logging ( system , getClass ) 
 
 override def handleRejectedNotification ( pushManager : PushManager [ _ < : SimpleApnsPushNotification ] , notification : SimpleApnsPushNotification , rejectionReason : RejectedNotificationReason ) : Unit = { 
 - system . log . warning ( " APNS rejected notification with reason : { } " , rejectionReason ) 
 + log . warning ( " APNS rejected notification with reason : { } " , rejectionReason ) 
 
 if ( rejectionReason . getErrorCode = = RejectedNotificationReason . INVALID _ TOKEN . getErrorCode ) { 
 - system . log . warning ( " Deleting token " ) 
 - system . log . error ( " Implement push token deletion " ) 
 + log . warning ( " Deleting token " ) 
 + log . error ( " Implement push token deletion " ) 
 seqUpdExt . deleteApplePushCredentials ( notification . getToken ) 
 } 
 } 
 @ @ - 99 , 6 + 100 , 7 @ @ private class LoggingRejectedNotificationListener ( _ system : ActorSystem ) extends 
 
 private class CleanExpiredTokenListener ( _ system : ActorSystem ) extends ExpiredTokenListener [ SimpleApnsPushNotification ] { 
 private implicit val system : ActorSystem = _ system 
 + private val log = Logging ( system , getClass ) 
 implicit val db : Database = DbExtension ( system ) . db 
 
 override def handleExpiredTokens ( 
 @ @ - 106 , 7 + 108 , 7 @ @ private class CleanExpiredTokenListener ( _ system : ActorSystem ) extends ExpiredTok 
 expiredTokens : util . Collection [ ExpiredToken ] 
 ) : Unit = { 
 expiredTokens foreach { t ⇒ 
 - system . log . warning ( " APNS reported expired token " ) 
 + log . warning ( " APNS reported expired token " ) 
 / / UserExtension ( system ) . logoutByAppleToken ( t . getToken ) 
 } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesManagerRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesManagerRegion . scala 
 index fb1d59a . . 6fbc993 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesManagerRegion . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesManagerRegion . scala 
 @ @ - 2 , 6 + 2 , 7 @ @ package im . actor . server . sequence 
 
 import akka . actor . { ActorRef , ActorSystem , Props } 
 import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } 
 + import akka . event . Logging 
 
 final case class SeqUpdatesManagerRegion ( ref : ActorRef ) 
 
 @ @ - 10 , 13 + 11 , 17 @ @ object SeqUpdatesManagerRegion { 
 import UserSequenceCommands . _ 
 
 private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { 
 - case e @ Envelope ( userId , payload ) ⇒ ( userId . toString , e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { 
 - case Some ( any ) ⇒ any 
 - case None ⇒ 
 - val error = new RuntimeException ( s " Payload not found for $ e " ) 
 - system . log . error ( error , error . getMessage ) 
 - throw error 
 - } ) 
 + val log = Logging ( system , getClass ) 
 + 
 + { 
 + case e @ Envelope ( userId , payload ) ⇒ ( userId . toString , e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { 
 + case Some ( any ) ⇒ any 
 + case None ⇒ 
 + val error = new RuntimeException ( s " Payload not found for $ e " ) 
 + log . error ( error , error . getMessage ) 
 + throw error 
 + } ) 
 + } 
 } 
 
 private val extractShardId : ShardRegion . ExtractShardId = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala 
 index 6d1dd74 . . a4685c9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . server . stickers 
 
 import akka . actor . _ 
 + import akka . event . Logging 
 import cats . data . Xor 
 import im . actor . api . rpc . stickers . { ApiStickerCollection , UpdateOwnStickersChanged , UpdateStickerCollectionsChanged } 
 import im . actor . concurrent . { FutureExt , FutureResultCats } 
 @ @ - 46 , 6 + 47 , 7 @ @ final class StickersExtensionImpl ( _ system : ActorSystem ) 
 implicit val system : ActorSystem = _ system 
 import system . dispatcher 
 
 + private val log = Logging ( system , getClass ) 
 private val db = DbExtension ( system ) . db 
 private val userExt = UserExtension ( system ) 
 private val seqExt = SeqUpdatesExtension ( system ) 
 @ @ - 137 , 10 + 139 , 10 @ @ final class StickersExtensionImpl ( _ system : ActorSystem ) 
 private def toggleDefault ( userId : Int , packId : Int , toggleTo : Boolean ) : Future [ StickerError Xor Unit ] = 
 ( for { 
 isAdmin ← fromFuture ( userExt . isAdmin ( userId ) ) 
 - _ = system . log . debug ( " user : { } is admin : { } " , userId , isAdmin ) 
 + _ = log . debug ( " user : { } is admin : { } " , userId , isAdmin ) 
 _ ← fromBoolean ( NotAdmin ) ( isAdmin ) 
 pack ← fromFutureOption ( NotFound ) ( db . run ( StickerPackRepo . find ( packId ) ) ) 
 - _ = system . log . debug ( " sticker pack : { } " , pack ) 
 + _ = log . debug ( " sticker pack : { } " , pack ) 
 _ ← fromBoolean ( isDefaultError ( toggleTo ) ) ( pack . isDefault ! = toggleTo ) 
 _ ← fromFuture ( db . run ( StickerPackRepo . setDefault ( packId , isDefault = toggleTo ) ) ) 
 _ = broadcastOwnStickersChanged ( ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala 
 index f9ddc39 . . 1be6a52 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . server . user 
 
 import akka . actor . _ 
 + import akka . event . Logging 
 import akka . util . Timeout 
 import im . actor . hook . _ 
 import im . actor . server . sequence . SeqUpdatesExtension 
 @ @ - 21 , 6 + 22 , 7 @ @ final class UserExtensionImpl ( actorSystem : ActorSystem ) extends UserExtension wi 
 implicit val system = actorSystem 
 
 import system . dispatcher 
 + val log = Logging ( system , getClass ) 
 
 lazy val processorRegion : UserProcessorRegion = UserProcessorRegion . start ( ) ( system ) 
 lazy val viewRegion : UserViewRegion = UserViewRegion ( processorRegion . ref ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 index ee91cac . . 554a6e2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 @ @ - 2 , 6 + 2 , 7 @ @ package im . actor . server . user 
 
 import akka . actor . { ActorRef , ActorSystem } 
 import akka . cluster . pubsub . DistributedPubSub 
 + import akka . event . { LoggingAdapter , Logging } 
 import akka . pattern . ask 
 import akka . util . Timeout 
 import com . google . protobuf . ByteString 
 @ @ - 230 , 6 + 231 , 7 @ @ private [ user ] sealed trait Queries { 
 val viewRegion : UserViewRegion 
 implicit val system : ActorSystem 
 import system . dispatcher 
 + val log : LoggingAdapter 
 
 implicit val timeout : Timeout 
 
 @ @ - 307 , 7 + 309 , 7 @ @ private [ user ] sealed trait AuthCommands { 
 } 
 
 def logout ( session : model . AuthSession ) ( implicit db : Database ) : Future [ Unit ] = { 
 - system . log . warning ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) 
 + log . warning ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) 
 for { 
 _ ← removeAuth ( session . userId , session . authId ) 
 _ ← SeqUpdatesExtension ( system ) . deletePushCredentials ( session . authId ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 index 841b357 . . 361d14b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 package im . actor . server . user 
 
 - import akka . actor . { Actor , ActorRef , Props } 
 + import akka . actor . { ActorLogging , Actor , ActorRef , Props } 
 import im . actor . api . rpc . PeersImplicits 
 import im . actor . api . rpc . misc . ApiExtension 
 import im . actor . server . dialog . { DirectDialogCommand , DialogProcessor , DialogCommand } 
 @ @ - 10 , 7 + 10 , 7 @ @ private [ user ] object UserPeer { 
 def props ( userId : Int , extensions : Seq [ ApiExtension ] ) = Props ( classOf [ UserPeer ] , userId , extensions ) 
 } 
 
 - private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Actor with PeersImplicits { 
 + private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Actor with ActorLogging with PeersImplicits { 
 
 private val selfPeer = Peer . privat ( userId ) 
 
 @ @ - 19 , 7 + 19 , 7 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e 
 case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc 
 / / Forward to a dest user dialog 
 case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc 
 - case other ⇒ context . system . log . debug ( " Unmatched message : { } " , other ) 
 + case other ⇒ log . debug ( " Unmatched message : { } " , other ) 
 } 
 
 private def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala 
 index f2db461 . . 8e7593e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala 
 @ @ - 2 , 23 + 2 , 28 @ @ package im . actor . server . user 
 
 import akka . actor . { ActorRef , ActorSystem , Props } 
 import akka . cluster . sharding . { ClusterSharding , ClusterShardingSettings , ShardRegion } 
 + import akka . event . Logging 
 import im . actor . server . dialog . DialogCommands . Envelope 
 import im . actor . server . model . { Peer , PeerType } 
 
 object UserProcessorRegion { 
 private def extractEntityId ( system : ActorSystem ) : ShardRegion . ExtractEntityId = { 
 - case c : UserCommand ⇒ ( c . userId . toString , c ) 
 - case q : UserQuery ⇒ ( q . userId . toString , q ) 
 - case e @ Envelope ( peer , payload ) ⇒ peer match { 
 - case Peer ( PeerType . Private , userId ) ⇒ 
 - e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { 
 - case Some ( any ) ⇒ ( userId . toString , any ) 
 - case None ⇒ 
 - val error = new RuntimeException ( s " Payload not found for $ e " ) 
 - system . log . error ( error , error . getMessage ) 
 - throw error 
 - } 
 - case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) 
 + val log = Logging ( system , getClass ) 
 + 
 + { 
 + case c : UserCommand ⇒ ( c . userId . toString , c ) 
 + case q : UserQuery ⇒ ( q . userId . toString , q ) 
 + case e @ Envelope ( peer , payload ) ⇒ peer match { 
 + case Peer ( PeerType . Private , userId ) ⇒ 
 + e . getField ( Envelope . descriptor . findFieldByNumber ( payload . number ) ) match { 
 + case Some ( any ) ⇒ ( userId . toString , any ) 
 + case None ⇒ 
 + val error = new RuntimeException ( s " Payload not found for $ e " ) 
 + log . error ( error , error . getMessage ) 
 + throw error 
 + } 
 + case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) 
 + } 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / IngoingHooks . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / IngoingHooks . scala 
 index a0230f0 . . 441447c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / IngoingHooks . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / IngoingHooks . scala 
 @ @ - 31 , 7 + 31 , 7 @ @ trait IngoingHooks extends ContentUnmarshaller with PlayJsonSupport { 
 case Right ( _ ) ⇒ complete ( OK → Status ( " Ok " ) ) 
 } 
 case Failure ( e ) ⇒ 
 - system . log . error ( e , " Failed to handle ingoing hook " ) 
 + log . error ( e , " Failed to handle ingoing hook " ) 
 complete ( InternalServerError ) 
 } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / WebhooksHttpHandler . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / WebhooksHttpHandler . scala 
 index aa3f573 . . 87ff2a6 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / WebhooksHttpHandler . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / WebhooksHttpHandler . scala 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . server . webhooks . http . routes 
 
 import akka . actor . ActorSystem 
 + import akka . event . Logging 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . Route 
 import akka . stream . { ActorMaterializer , Materializer } 
 @ @ - 23 , 6 + 24 , 7 @ @ final class WebhooksHttpHandler ( ) ( implicit val system : ActorSystem ) 
 
 implicit val timeout : Timeout = Timeout ( 5 . seconds ) 
 
 + protected val log = Logging ( system , getClass ) 
 protected val integrationTokensKv = ShardakkaExtension ( system ) . simpleKeyValue [ Int ] ( KeyValueMappings . IntegrationTokens , IntCodec ) 
 
 override def routes : Route =

NEAREST DIFF:
diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / IlectroUser . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / IlectroUser . scala 
 deleted file mode 100644 
 index 189d99e . . 0000000 
 - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / IlectroUser . scala 
 + + + / dev / null 
 @ @ - 1 , 5 + 0 , 0 @ @ 
 - package im . actor . server . models . llectro 
 - 
 - import java . util . UUID 
 - 
 - case class LlectroUser ( userId : Int , uuid : UUID , name : String ) 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / Interest . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / Interest . scala 
 deleted file mode 100644 
 index d5e361a . . 0000000 
 - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / Interest . scala 
 + + + / dev / null 
 @ @ - 1 , 3 + 0 , 0 @ @ 
 - package im . actor . server . models . llectro 
 - 
 - case class Interest ( id : Int , name : String , parentId : Int , fullPath : String , level : Int ) 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / LlectroDevice . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / LlectroDevice . scala 
 deleted file mode 100644 
 index 268056a . . 0000000 
 - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / LlectroDevice . scala 
 + + + / dev / null 
 @ @ - 1 , 3 + 0 , 0 @ @ 
 - package im . actor . server . models . llectro 
 - 
 - case class LlectroDevice ( authId : Long , screenWidth : Int , screenHeight : Int ) 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / UserInterest . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / UserInterest . scala 
 deleted file mode 100644 
 index 963e5df . . 0000000 
 - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / llectro / UserInterest . scala 
 + + + / dev / null 
 @ @ - 1 , 3 + 0 , 0 @ @ 
 - package im . actor . server . models . llectro 
 - 
 - case class UserInterest ( userId : Int , interestId : Int ) 
 \ No newline at end of file 
 diff - - git a / actor - server / bin / merge - to - master b / actor - server / bin / merge - to - master 
 new file mode 100755 
 index 0000000 . . 57bea44 
 - - - / dev / null 
 + + + b / actor - server / bin / merge - to - master 
 @ @ - 0 , 0 + 1 , 15 @ @ 
 + # ! / usr / bin / env bash 
 + 
 + set - eu 
 + 
 + git diff - index - - quiet - - cached HEAD 
 + 
 + if [ $ ? - eq 0 ] 
 + then 
 + git checkout master 
 + git pull - - rebase origin master 
 + git merge server / master 
 + git push origin master 
 + else 
 + echo " Branch is dirty " 
 + fi 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 0ae9ff5 . . 1d00c84 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 38 , 7 + 38 , 6 @ @ object Dependencies { 
 
 val concmap = " com . googlecode . concurrentlinkedhashmap " % " concurrentlinkedhashmap - lru " % " 1 . 4 . 2 " 
 val caffeine = " com . github . ben - manes . caffeine " % " caffeine " % " 1 . 2 . 0 " 
 - val eaioUuid = " com . eaio . uuid " % " uuid " % " 3 . 4 " 
 
 val cats = " org . spire - math " % % " cats " % V . cats 
 
 @ @ - 166 , 7 + 165 , 7 @ @ object Dependencies { 
 
 val codecs = shared + + Seq ( scalazCore , scodecBits , scodecCore ) 
 
 - val models = shared + + Seq ( eaioUuid , scodecBits , scodecCore , jodaTime , jodaConvert , slickPg ) 
 + val models = shared + + Seq ( scodecBits , scodecCore , jodaTime , jodaConvert , slickPg ) 
 
 val frontend = shared + + Seq ( 
 akkaSlf4j , akkaActor , akkaStream ,
