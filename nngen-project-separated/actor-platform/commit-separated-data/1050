BLEU SCORE: 0.1431712315455507

TEST MSG: feat ( core ) : Keys signature validation , handling key groups update , key short hashes
GENERATED MSG: wip ( core ) : Working on decryption of ratchet messages

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index b56a212 . . fa328b1 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 56 , 6 + 56 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserKeyGroups ( uid ) , new AskCallback ( ) { < nl > @ Override < nl > public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " Groups loaded . . . " ) ; < nl > KeyManagerActor . FetchUserKeyGroupsResponse response = ( KeyManagerActor . FetchUserKeyGroupsResponse ) obj ; < nl > userKeys = response . getUserKeys ( ) ; < nl > onGroupsReady ( ) ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index fbd44b6 . . 2d749be 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 7 , 6 + 7 , 7 @ @ import java . util . HashMap ; < nl > import im . actor . core . api . ApiEncryptionKey ; < nl > import im . actor . core . api . ApiEncryptionKeyGroup ; < nl > import im . actor . core . api . ApiEncryptionKeySignature ; < nl > + import im . actor . core . api . ApiEncryptionPublicKeyGroup ; < nl > import im . actor . core . api . ApiUserOutPeer ; < nl > import im . actor . core . api . rpc . RequestCreateNewKeyGroup ; < nl > import im . actor . core . api . rpc . RequestLoadPublicKeyGroups ; < nl > @ @ - 31 , 8 + 32 , 12 @ @ import im . actor . runtime . Log ; < nl > import im . actor . runtime . Storage ; < nl > import im . actor . runtime . actors . Future ; < nl > import im . actor . runtime . actors . ask . AskRequest ; < nl > + import im . actor . runtime . bser . BserWriter ; < nl > + import im . actor . runtime . bser . DataOutput ; < nl > import im . actor . runtime . crypto . Curve25519 ; < nl > + import im . actor . runtime . crypto . primitives . digest . SHA256 ; < nl > import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetKeySignature ; < nl > import im . actor . runtime . storage . KeyValueStorage ; < nl > < nl > public class KeyManagerActor extends ModuleActor { < nl > @ @ - 99 , 16 + 104 , 15 @ @ public class KeyManagerActor extends ModuleActor { < nl > ArrayList < ApiEncryptionKeySignature > keySignatures = new ArrayList < ApiEncryptionKeySignature > ( ) ; < nl > for ( OwnPrivateKey key : ownKeys . getKeys ( ) ) { < nl > byte [ ] publicKey2 = Curve25519 . keyGenPublic ( privateKey . getKey ( ) ) ; < nl > - ApiEncryptionKey apiKey = < nl > - new ApiEncryptionKey ( < nl > - key . getKeyId ( ) , < nl > - key . getKeyAlg ( ) , < nl > - publicKey2 , < nl > - null ) ; < nl > - keys . add ( apiKey ) ; < nl > - < nl > - < nl > - byte [ ] signature = Curve25519 . calculateSignature ( Crypto . randomBytes ( 64 ) , privateKey . getKey ( ) , apiKey . toByteArray ( ) ) ; < nl > + keys . add ( new ApiEncryptionKey ( < nl > + key . getKeyId ( ) , < nl > + key . getKeyAlg ( ) , < nl > + publicKey2 , < nl > + null ) ) ; < nl > + < nl > + byte [ ] signature = Curve25519 . calculateSignature ( Crypto . randomBytes ( 64 ) , privateKey . getKey ( ) , < nl > + RatchetKeySignature . hashForSignature ( key . getKeyId ( ) , < nl > + key . getKeyAlg ( ) , publicKey2 ) ) ; < nl > keySignatures . add ( < nl > new ApiEncryptionKeySignature ( < nl > key . getKeyId ( ) , < nl > @ @ - 210 , 10 + 214 , 8 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > < nl > private void onAllKeysReady ( ) { < nl > - Log . d ( TAG , " Ephemeral Keys are ready " ) ; < nl > - < nl > - / / Now we can start receiving encrypted messages < nl > - < nl > + Log . d ( TAG , " All Keys are ready " ) ; < nl > + / / Now we can start receiving or sending encrypted messages < nl > isReady = true ; < nl > unstashAll ( ) ; < nl > } < nl > @ @ - 229 , 7 + 231 , 6 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > < nl > private void fetchEphemeralKey ( byte [ ] publicKey , Future future ) { < nl > - Log . d ( TAG , " fetchEphemeralKey " ) ; < nl > for ( OwnPrivateKey k : ownKeys . getEphemeralKeys ( ) ) { < nl > if ( ByteStrings . isEquals ( Curve25519 . keyGenPublic ( k . getKey ( ) ) , publicKey ) ) { < nl > future . onResult ( new FetchEphemeralPrivateKeyRes ( k . getKey ( ) ) ) ; < nl > @ @ - 240 , 7 + 241 , 6 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > < nl > private void fetchEphemeralKey ( long keyId , Future future ) { < nl > - Log . d ( TAG , " fetchEphemeralKey " ) ; < nl > for ( OwnPrivateKey k : ownKeys . getEphemeralKeys ( ) ) { < nl > if ( k . getKeyId ( ) = = keyId ) { < nl > future . onResult ( new FetchEphemeralPrivateKeyRes ( k . getKey ( ) ) ) ; < nl > @ @ - 252 , 68 + 252 , 158 @ @ public class KeyManagerActor extends ModuleActor { < nl > < nl > private void fetchUserGroups ( final int uid , final Future future ) { < nl > Log . d ( TAG , " fetchUserGroups " ) ; < nl > - UserKeys userKeys = null ; / / cachedUserKeys . get ( uid ) ; < nl > - / / if ( userKeys = = null ) { < nl > - / / byte [ ] cached = encryptionKeysStorage . loadItem ( uid ) ; < nl > - / / if ( cached ! = null ) { < nl > - / / try { < nl > - / / userKeys = new UserKeys ( cached ) ; < nl > - / / } catch ( IOException e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / if ( userKeys ! = null ) { < nl > - / / Log . d ( TAG , " onResult : fast " ) ; < nl > - / / future . onResult ( new FetchUserKeyGroupsResponse ( userKeys ) ) ; < nl > - / / return ; < nl > - / / } < nl > - < nl > - Log . d ( TAG , " Requesting " ) ; < nl > + final UserKeys userKeys = getCachedUserKeys ( uid ) ; < nl > + if ( userKeys ! = null ) { < nl > + Log . d ( TAG , " fetchUserGroups : cached " ) ; < nl > + future . onResult ( new FetchUserKeyGroupsResponse ( userKeys ) ) ; < nl > + return ; < nl > + } < nl > + Log . d ( TAG , " fetchUserGroups : loading " ) ; < nl > User user = users ( ) . getValue ( uid ) ; < nl > request ( new RequestLoadPublicKeyGroups ( new ApiUserOutPeer ( uid , user . getAccessHash ( ) ) ) , new RpcCallback < ResponsePublicKeyGroups > ( ) { < nl > @ Override < nl > public void onResult ( ResponsePublicKeyGroups response ) { < nl > - Log . d ( TAG , " onResult " ) ; < nl > - UserKeysGroup [ ] groups = new UserKeysGroup [ response . getPublicKeyGroups ( ) . size ( ) ] ; < nl > - for ( int i = 0 ; i < groups . length ; i + + ) { < nl > - ApiEncryptionKeyGroup encryptionKey = response . getPublicKeyGroups ( ) . get ( i ) ; < nl > - < nl > - / / TODO : Validate signatures < nl > - < nl > - UserPublicKey identity = new UserPublicKey ( < nl > - encryptionKey . getIdentityKey ( ) . getKeyId ( ) , < nl > - encryptionKey . getIdentityKey ( ) . getKeyAlg ( ) , < nl > - encryptionKey . getIdentityKey ( ) . getKeyMaterial ( ) ) ; < nl > - UserPublicKey [ ] keys = new UserPublicKey [ encryptionKey . getKeys ( ) . size ( ) ] ; < nl > - for ( int j = 0 ; j < keys . length ; j + + ) { < nl > - keys [ j ] = new UserPublicKey ( < nl > - encryptionKey . getKeys ( ) . get ( j ) . getKeyId ( ) , < nl > - encryptionKey . getKeys ( ) . get ( j ) . getKeyAlg ( ) , < nl > - encryptionKey . getKeys ( ) . get ( j ) . getKeyMaterial ( ) ) ; < nl > + ArrayList < UserKeysGroup > keysGroups = new ArrayList < UserKeysGroup > ( ) ; < nl > + for ( ApiEncryptionKeyGroup keyGroup : response . getPublicKeyGroups ( ) ) { < nl > + UserKeysGroup validatedKeysGroup = validateUserKeysGroup ( uid , keyGroup ) ; < nl > + if ( validatedKeysGroup ! = null ) { < nl > + keysGroups . add ( validatedKeysGroup ) ; < nl > } < nl > - groups [ i ] = new UserKeysGroup ( encryptionKey . getKeyGroupId ( ) , identity , keys , new UserPublicKey [ 0 ] ) ; < nl > } < nl > - UserKeys userKeys1 = new UserKeys ( uid , groups ) ; < nl > - encryptionKeysStorage . addOrUpdateItem ( uid , userKeys1 . toByteArray ( ) ) ; < nl > - future . onResult ( new FetchUserKeyGroupsResponse ( userKeys1 ) ) ; < nl > + if ( keysGroups . size ( ) ! = 0 ) { < nl > + UserKeys userKeys1 = new UserKeys ( uid , keysGroups . toArray ( new UserKeysGroup [ keysGroups . size ( ) ] ) ) ; < nl > + cacheUserKeys ( userKeys1 ) ; < nl > + future . onResult ( new FetchUserKeyGroupsResponse ( userKeys1 ) ) ; < nl > + } else { < nl > + Log . w ( TAG , " ( uid : " + uid + " ) No valid key groups found " ) ; < nl > + future . onError ( new RuntimeException ( " No key groups found " ) ) ; < nl > + } < nl > } < nl > < nl > @ Override < nl > public void onError ( RpcException e ) { < nl > - Log . d ( TAG , " onError " ) ; < nl > future . onError ( e ) ; < nl > } < nl > } ) ; < nl > } < nl > < nl > + private void onPublicKeysGroupAdded ( int uid , ApiEncryptionKeyGroup keyGroup ) { < nl > + UserKeys userKeys = getCachedUserKeys ( uid ) ; < nl > + if ( userKeys = = null ) { < nl > + return ; < nl > + } < nl > + UserKeysGroup validatedKeysGroup = validateUserKeysGroup ( uid , keyGroup ) ; < nl > + if ( validatedKeysGroup ! = null ) { < nl > + cacheUserKeys ( userKeys . addUserKeyGroup ( validatedKeysGroup ) ) ; < nl > + } < nl > + } < nl > + < nl > + private void onPublicKeysGroupRemoved ( int uid , int keyGroupId ) { < nl > + UserKeys userKeys = getCachedUserKeys ( uid ) ; < nl > + if ( userKeys = = null ) { < nl > + return ; < nl > + } < nl > + cacheUserKeys ( userKeys . removeUserKeyGroup ( keyGroupId ) ) ; < nl > + } < nl > + < nl > + private UserKeysGroup validateUserKeysGroup ( int uid , ApiEncryptionKeyGroup keyGroup ) { < nl > + if ( ! " curve25519 " . equals ( keyGroup . getIdentityKey ( ) . getKeyAlg ( ) ) ) { < nl > + / / Anything other than curve25519 is not supported < nl > + Log . w ( TAG , " ( uid : " + uid + " ) Unsupported identity key alg " + keyGroup . getIdentityKey ( ) . getKeyAlg ( ) ) ; < nl > + return null ; < nl > + } < nl > + < nl > + UserPublicKey identity = new UserPublicKey ( < nl > + keyGroup . getIdentityKey ( ) . getKeyId ( ) , < nl > + keyGroup . getIdentityKey ( ) . getKeyAlg ( ) , < nl > + keyGroup . getIdentityKey ( ) . getKeyMaterial ( ) ) ; < nl > + < nl > + ArrayList < UserPublicKey > keys = new ArrayList < UserPublicKey > ( ) ; < nl > + < nl > + key _ loop : < nl > + for ( ApiEncryptionKey key : keyGroup . getKeys ( ) ) { < nl > + < nl > + / / < nl > + / / Validating signatures < nl > + / / < nl > + for ( ApiEncryptionKeySignature sig : keyGroup . getSignatures ( ) ) { < nl > + if ( ! sig . getSignatureAlg ( ) . equals ( " Ed25519 " ) ) { < nl > + / / Anything other than Ed25519 is not supported < nl > + Log . w ( TAG , " ( uid : " + uid + " ) Unsupported signature algorithm " + sig . getSignatureAlg ( ) ) ; < nl > + continue ; < nl > + } < nl > + if ( sig . getKeyId ( ) ! = key . getKeyId ( ) ) { < nl > + continue ; < nl > + } < nl > + < nl > + byte [ ] keyForSign = RatchetKeySignature . hashForSignature ( < nl > + key . getKeyId ( ) , < nl > + key . getKeyAlg ( ) , < nl > + key . getKeyMaterial ( ) ) ; < nl > + < nl > + if ( ! Curve25519 . verifySignature ( identity . getPublicKey ( ) , keyForSign , sig . getSignature ( ) ) ) { < nl > + Log . w ( TAG , " ( uid : " + uid + " ) Unable to verify signature for " + Crypto . keyHash ( key . getKeyMaterial ( ) ) + " key " ) ; < nl > + continue key _ loop ; < nl > + } < nl > + } < nl > + < nl > + / / < nl > + / / Adding key to collection < nl > + / / < nl > + < nl > + keys . add ( new UserPublicKey ( < nl > + key . getKeyId ( ) , < nl > + key . getKeyAlg ( ) , < nl > + key . getKeyMaterial ( ) ) ) ; < nl > + } < nl > + < nl > + if ( keys . size ( ) > 0 ) { < nl > + return new UserKeysGroup ( keyGroup . getKeyGroupId ( ) , identity , keys . toArray ( new UserPublicKey [ keys . size ( ) ] ) , < nl > + new UserPublicKey [ 0 ] ) ; < nl > + } else { < nl > + Log . w ( TAG , " ( uid : " + uid + " ) No valid keys in key group # " + keyGroup . getKeyGroupId ( ) ) ; < nl > + return null ; < nl > + } < nl > + } < nl > + < nl > + private UserKeys getCachedUserKeys ( int uid ) { < nl > + UserKeys userKeys = cachedUserKeys . get ( uid ) ; < nl > + if ( userKeys = = null ) { < nl > + byte [ ] cached = encryptionKeysStorage . loadItem ( uid ) ; < nl > + if ( cached ! = null ) { < nl > + try { < nl > + userKeys = new UserKeys ( cached ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + } < nl > + } < nl > + } < nl > + return userKeys ; < nl > + } < nl > + < nl > + private void cacheUserKeys ( UserKeys userKeys ) { < nl > + encryptionKeysStorage . addOrUpdateItem ( userKeys . getUid ( ) , userKeys . toByteArray ( ) ) ; < nl > + cachedUserKeys . put ( userKeys . getUid ( ) , userKeys ) ; < nl > + } < nl > + < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > - if ( message instanceof AskRequest & & ! isReady ) { < nl > + if ( ! isReady < nl > + & & ( message instanceof AskRequest < nl > + | | message instanceof PublicKeysGroupAdded < nl > + | | message instanceof PublicKeysGroupRemoved ) ) { < nl > stash ( ) ; < nl > return ; < nl > } < nl > - super . onReceive ( message ) ; < nl > + if ( message instanceof PublicKeysGroupAdded ) { < nl > + PublicKeysGroupAdded publicKeysGroupAdded = ( PublicKeysGroupAdded ) message ; < nl > + onPublicKeysGroupAdded ( publicKeysGroupAdded . getUid ( ) , publicKeysGroupAdded . getPublicKeyGroup ( ) ) ; < nl > + } else if ( message instanceof PublicKeysGroupRemoved ) { < nl > + PublicKeysGroupRemoved publicKeysGroupRemoved = ( PublicKeysGroupRemoved ) message ; < nl > + onPublicKeysGroupRemoved ( publicKeysGroupRemoved . getUid ( ) , publicKeysGroupRemoved . getKeyGroupId ( ) ) ; < nl > + } else { < nl > + super . onReceive ( message ) ; < nl > + } < nl > } < nl > < nl > @ Override < nl > @ @ - 438 , 4 + 528 , 41 @ @ public class KeyManagerActor extends ModuleActor { < nl > return userKeys ; < nl > } < nl > } < nl > + < nl > + public static class PublicKeysGroupAdded { < nl > + < nl > + private int uid ; < nl > + private ApiEncryptionKeyGroup publicKeyGroup ; < nl > + < nl > + public PublicKeysGroupAdded ( int uid , ApiEncryptionKeyGroup publicKeyGroup ) { < nl > + this . uid = uid ; < nl > + this . publicKeyGroup = publicKeyGroup ; < nl > + } < nl > + < nl > + public int getUid ( ) { < nl > + return uid ; < nl > + } < nl > + < nl > + public ApiEncryptionKeyGroup getPublicKeyGroup ( ) { < nl > + return publicKeyGroup ; < nl > + } < nl > + } < nl > + < nl > + public static class PublicKeysGroupRemoved { < nl > + private int uid ; < nl > + private int keyGroupId ; < nl > + < nl > + public PublicKeysGroupRemoved ( int uid , int keyGroupId ) { < nl > + this . uid = uid ; < nl > + this . keyGroupId = keyGroupId ; < nl > + } < nl > + < nl > + public int getUid ( ) { < nl > + return uid ; < nl > + } < nl > + < nl > + public int getKeyGroupId ( ) { < nl > + return keyGroupId ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / UserKeys . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / UserKeys . java < nl > index b02bce1 . . a764776 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / UserKeys . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / UserKeys . java < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . core . modules . encryption . entity ; < nl > < nl > import java . io . IOException ; < nl > + import java . util . ArrayList ; < nl > import java . util . List ; < nl > < nl > import im . actor . runtime . bser . BserObject ; < nl > @ @ - 29 , 6 + 30 , 25 @ @ public class UserKeys extends BserObject { < nl > return userKeysGroups ; < nl > } < nl > < nl > + public UserKeys addUserKeyGroup ( UserKeysGroup keysGroup ) { < nl > + ArrayList < UserKeysGroup > userKeysGroups = new ArrayList < UserKeysGroup > ( ) ; < nl > + for ( UserKeysGroup g : userKeysGroups ) { < nl > + userKeysGroups . add ( g ) ; < nl > + } < nl > + userKeysGroups . add ( keysGroup ) ; < nl > + return new UserKeys ( uid , userKeysGroups . toArray ( new UserKeysGroup [ userKeysGroups . size ( ) ] ) ) ; < nl > + } < nl > + < nl > + public UserKeys removeUserKeyGroup ( int keyGroupId ) { < nl > + ArrayList < UserKeysGroup > userKeysGroups = new ArrayList < UserKeysGroup > ( ) ; < nl > + for ( UserKeysGroup g : userKeysGroups ) { < nl > + if ( g . getKeyGroupId ( ) ! = keyGroupId ) { < nl > + userKeysGroups . add ( g ) ; < nl > + } < nl > + } < nl > + return new UserKeys ( uid , userKeysGroups . toArray ( new UserKeysGroup [ userKeysGroups . size ( ) ] ) ) ; < nl > + } < nl > + < nl > @ Override < nl > public void parse ( BserValues values ) throws IOException { < nl > uid = values . getInt ( 1 ) ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / UpdateProcessor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / UpdateProcessor . java < nl > index 6095457 . . e543022 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / UpdateProcessor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / UpdateProcessor . java < nl > @ @ - 42 , 6 + 42 , 8 @ @ import im . actor . core . api . updates . UpdateMessageReceived ; < nl > import im . actor . core . api . updates . UpdateMessageSent ; < nl > import im . actor . core . api . updates . UpdateOwnStickersChanged ; < nl > import im . actor . core . api . updates . UpdateParameterChanged ; < nl > + import im . actor . core . api . updates . UpdatePublicKeyGroupAdded ; < nl > + import im . actor . core . api . updates . UpdatePublicKeyGroupRemoved ; < nl > import im . actor . core . api . updates . UpdateReactionsUpdate ; < nl > import im . actor . core . api . updates . UpdateStickerCollectionsChanged ; < nl > import im . actor . core . api . updates . UpdateTyping ; < nl > @ @ - 53 , 6 + 55 , 7 @ @ import im . actor . core . api . updates . UpdateUserOnline ; < nl > import im . actor . core . entity . Peer ; < nl > import im . actor . core . modules . AbsModule ; < nl > import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . encryption . KeyManagerActor ; < nl > import im . actor . core . modules . internal . contacts . ContactsSyncActor ; < nl > import im . actor . core . modules . internal . messages . OwnReadActor ; < nl > import im . actor . core . modules . updates . internal . ChangeContent ; < nl > @ @ - 346 , 6 + 349 , 16 @ @ public class UpdateProcessor extends AbsModule { < nl > callsProcessor . onSignal ( ( UpdateCallSignal ) update ) ; < nl > } else if ( update instanceof UpdateCallEnded ) { < nl > callsProcessor . onCallEnd ( ( UpdateCallEnded ) update ) ; < nl > + } else if ( update instanceof UpdatePublicKeyGroupAdded ) { < nl > + context ( ) . getEncryption ( ) . getKeyManager ( ) . send ( new KeyManagerActor . PublicKeysGroupAdded ( < nl > + ( ( UpdatePublicKeyGroupAdded ) update ) . getUid ( ) , < nl > + ( ( UpdatePublicKeyGroupAdded ) update ) . getKeyGroup ( ) < nl > + ) ) ; < nl > + } else if ( update instanceof UpdatePublicKeyGroupRemoved ) { < nl > + context ( ) . getEncryption ( ) . getKeyManager ( ) . send ( new KeyManagerActor . PublicKeysGroupRemoved ( < nl > + ( ( UpdatePublicKeyGroupRemoved ) update ) . getUid ( ) , < nl > + ( ( UpdatePublicKeyGroupRemoved ) update ) . getKeyGroupId ( ) < nl > + ) ) ; < nl > } < nl > } < nl > < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / Crypto . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / Crypto . java < nl > index 3d7743a . . c3998f5 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / Crypto . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / Crypto . java < nl > @ @ - 6 , 6 + 6 , 8 @ @ package im . actor . runtime ; < nl > < nl > import java . math . BigInteger ; < nl > < nl > + import im . actor . core . util . Hex ; < nl > + import im . actor . runtime . crypto . primitives . digest . KeyDigest ; < nl > import im . actor . runtime . crypto . primitives . digest . SHA256 ; < nl > < nl > public class Crypto { < nl > @ @ - 19 , 6 + 21 , 14 @ @ public class Crypto { < nl > return provider . MD5 ( data ) ; < nl > } < nl > < nl > + public static String keyHash ( byte [ ] publicKey ) { < nl > + KeyDigest keyDigest = new KeyDigest ( ) ; < nl > + keyDigest . update ( publicKey , 0 , publicKey . length ) ; < nl > + byte [ ] res = new byte [ 8 ] ; < nl > + keyDigest . doFinal ( res , 0 ) ; < nl > + return Hex . toHex ( res ) ; < nl > + } < nl > + < nl > / * * < nl > * Calculating SHA256 < nl > * < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / KeyDigest . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / KeyDigest . java < nl > new file mode 100644 < nl > index 0000000 . . de6f64a < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / KeyDigest . java < nl > @ @ - 0 , 0 + 1 , 33 @ @ < nl > + package im . actor . runtime . crypto . primitives . digest ; < nl > + < nl > + import im . actor . runtime . crypto . primitives . Digest ; < nl > + < nl > + / * * < nl > + * Truncated SHA256 for public keys < nl > + * / < nl > + public class KeyDigest implements Digest { < nl > + < nl > + private SHA256 sha256 = new SHA256 ( ) ; < nl > + < nl > + @ Override < nl > + public void reset ( ) { < nl > + sha256 . reset ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void update ( byte [ ] src , int offset , int length ) { < nl > + sha256 . update ( src , offset , length ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void doFinal ( byte [ ] dest , int destOffset ) { < nl > + byte [ ] res = new byte [ 32 ] ; < nl > + sha256 . doFinal ( res , 0 ) ; < nl > + System . arraycopy ( res , 0 , dest , 0 , 8 ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public int getDigestSize ( ) { < nl > + return 8 ; < nl > + } < nl > + } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / ratchet / RatchetKeySignature . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / ratchet / RatchetKeySignature . java < nl > new file mode 100644 < nl > index 0000000 . . 8464568 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / ratchet / RatchetKeySignature . java < nl > @ @ - 0 , 0 + 1 , 27 @ @ < nl > + package im . actor . runtime . crypto . ratchet ; < nl > + < nl > + import im . actor . runtime . bser . BserWriter ; < nl > + import im . actor . runtime . bser . DataOutput ; < nl > + import im . actor . runtime . crypto . primitives . digest . SHA256 ; < nl > + < nl > + public class RatchetKeySignature { < nl > + public static byte [ ] hashForSignature ( long keyId , String keyAlg , byte [ ] publicKey ) { < nl > + byte [ ] toSign ; < nl > + try { < nl > + DataOutput dataOutput = new DataOutput ( ) ; < nl > + BserWriter writer = new BserWriter ( dataOutput ) ; < nl > + writer . writeLong ( 1 , keyId ) ; < nl > + writer . writeString ( 2 , keyAlg ) ; < nl > + SHA256 sha256 = new SHA256 ( ) ; < nl > + sha256 . update ( publicKey , 0 , publicKey . length ) ; < nl > + byte [ ] hash = new byte [ 32 ] ; < nl > + sha256 . doFinal ( hash , 0 ) ; < nl > + writer . writeBytes ( 3 , hash ) ; < nl > + toSign = dataOutput . toByteArray ( ) ; < nl > + } catch ( Exception e ) { < nl > + / / Never happens < nl > + return new byte [ 0 ] ; < nl > + } < nl > + return toSign ; < nl > + } < nl > + }
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj < nl > index 2f54661 . . c33368d 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj < nl > @ @ - 1550 , 7 + 1550 , 7 @ @ < nl > 	 	 	 	 TargetAttributes = { < nl > 	 	 	 	 	 066A50D11BC4AE63000E606E = { < nl > 	 	 	 	 	 	 CreatedOnToolsVersion = 7 . 0 ; < nl > - 	 	 	 	 	 	 DevelopmentTeam = PR6635TQQ3 ; < nl > + 	 	 	 	 	 	 DevelopmentTeam = HVJR44Y5B6 ; < nl > 	 	 	 	 	 } ; < nl > 	 	 	 	 } ; < nl > 	 	 	 } ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 2d72521 . . 37809ce 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . core . modules . encryption . entity . EncryptedBox ; < nl > import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; < nl > import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > + import im . actor . core . util . Hex ; < nl > import im . actor . core . util . ModuleActor ; < nl > import im . actor . runtime . Crypto ; < nl > import im . actor . runtime . Log ; < nl > @ @ - 25 , 6 + 26 , 7 @ @ import im . actor . runtime . actors . ask . AskRequest ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . box . ActorBox ; < nl > import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > + import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > < nl > public class EncryptedPeerActor extends ModuleActor { < nl > < nl > @ @ - 34 , 6 + 36 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > private ArrayList < ApiEncryptionKeyGroup > keyGroups ; < nl > private HashMap < Integer , ActorRef > sessions = new HashMap < Integer , ActorRef > ( ) ; < nl > private boolean isReady = false ; < nl > + private int ownKeyGroupId ; < nl > < nl > public EncryptedPeerActor ( int uid , ModuleContext context ) { < nl > super ( context ) ; < nl > @ @ - 78 , 14 + 81 , 29 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > } < nl > } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; < nl > } < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKeyGroup ( ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + KeyManagerActor . FetchOwnKeyGroupResult res = ( KeyManagerActor . FetchOwnKeyGroupResult ) obj ; < nl > + ownKeyGroupId = res . getKeyGroupId ( ) ; < nl > + onOwnKeysReady ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + / / Do nothing < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > + private void onOwnKeysReady ( ) { < nl > + Log . w ( TAG , " onOwnKeysReady " ) ; < nl > isReady = true ; < nl > unstashAll ( ) ; < nl > } < nl > < nl > private void doEncrypt ( final byte [ ] data , final Future future ) { < nl > - < nl > Log . d ( TAG , " doEncrypt " ) ; < nl > - < nl > final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > < nl > final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > @ @ - 112 , 19 + 130 , 61 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > Log . d ( TAG , " doEncrypt2 " ) ; < nl > byte [ ] encData ; < nl > try { < nl > - encData = ActorBox . closeBox ( new byte [ 0 ] , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > } catch ( IntegrityException e ) { < nl > e . printStackTrace ( ) ; < nl > future . onError ( e ) ; < nl > return ; < nl > } < nl > < nl > - EncryptedBox encryptedBox = new EncryptedBox ( encryptedKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , encData ) ; < nl > + EncryptedBox encryptedBox = new EncryptedBox ( < nl > + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > + < nl > + Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; < nl > + for ( EncryptedBoxKey k : encryptedKeys ) { < nl > + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + < nl > future . onResult ( encryptedBox ) ; < nl > } < nl > < nl > - private void doDecrypt ( EncryptedBox data , Future future ) { < nl > + private void doDecrypt ( EncryptedBox data , final Future future ) { < nl > + int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; < nl > + byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; < nl > + < nl > + if ( sessions . containsKey ( senderKeyGroup ) ) { < nl > + Log . d ( TAG , " Decryption with key group " ) ; < nl > + byte [ ] encKey = null ; < nl > + for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > + if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { < nl > + encKey = k . getEncryptedKey ( ) ; < nl > + break ; < nl > + } < nl > + } < nl > + < nl > + Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; < nl > + for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + < nl > + ask ( sessions . get ( senderKeyGroup ) , new EncryptionSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " Decryption with key group : onResult " ) ; < nl > + future . onResult ( ) ; < nl > + } < nl > < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . d ( TAG , " Decryption with key group : onError " ) ; < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + } else { < nl > + Log . w ( TAG , " Unable to find appropriate session # " + senderKeyGroup ) ; < nl > + future . onError ( new RuntimeException ( ) ) ; < nl > + } < nl > } < nl > < nl > @ Override < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > index 7f57506 . . 5d65dd8 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > @ @ - 8 , 9 + 8 , 11 @ @ import im . actor . core . api . ApiUserOutPeer ; < nl > import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; < nl > import im . actor . core . api . rpc . ResponsePublicKeys ; < nl > import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; < nl > import im . actor . core . modules . encryption . entity . EncryptionKey ; < nl > import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > + import im . actor . core . util . Hex ; < nl > import im . actor . core . util . ModuleActor ; < nl > import im . actor . core . util . RandomUtils ; < nl > import im . actor . runtime . Crypto ; < nl > @ @ - 101 , 7 + 103 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > return ; < nl > } < nl > < nl > - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( 0 ) ; < nl > + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; < nl > onTheirReady0 ( ) ; < nl > } < nl > @ @ - 169 , 6 + 171 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; < nl > < nl > byte [ ] header = ByteStrings . merge ( < nl > + ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , < nl > ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > currentOwnKey . getPublicKey ( ) , < nl > @ @ - 186 , 9 + 189 , 46 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > < nl > byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; < nl > < nl > + < nl > + int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; < nl > + long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; < nl > + long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; < nl > + byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; < nl > + byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; < nl > + int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; < nl > + < nl > + Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; < nl > + Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; < nl > + < nl > + < nl > + Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; < nl > + Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; < nl > + < nl > future . onResult ( new EncryptedPackageRes ( pkg ) ) ; < nl > } < nl > < nl > + private void onDecrypt ( byte [ ] data , Future future ) { < nl > + int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > + long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > + long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > + byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > + byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > + int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > + < nl > + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > + Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; < nl > + Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; < nl > + < nl > + / / future . onResult ( ) ; < nl > + } < nl > + < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > if ( ! isReady & & message instanceof AskRequest ) { < nl > @ @ - 203 , 6 + 243 , 10 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > if ( message instanceof EncryptPackage ) { < nl > onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; < nl > return false ; < nl > + } else if ( message instanceof DecryptPackage ) { < nl > + DecryptPackage decryptPackage = ( DecryptPackage ) message ; < nl > + onDecrypt ( decryptPackage . getData ( ) , future ) ; < nl > + return false ; < nl > } else { < nl > return super . onAsk ( message , future ) ; < nl > } < nl > @ @ - 232 , 4 + 276 , 17 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > return data ; < nl > } < nl > } < nl > + < nl > + public static class DecryptPackage { < nl > + < nl > + private byte [ ] data ; < nl > + < nl > + public DecryptPackage ( byte [ ] data ) { < nl > + this . data = data ; < nl > + } < nl > + < nl > + public byte [ ] getData ( ) { < nl > + return data ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index f4eb042 . . 58c2383 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 230 , 6 + 230 , 10 @ @ public class KeyManagerActor extends ModuleActor { < nl > future . onResult ( new FetchOwnKeyResult ( privateKeyStorage . getIdentityKey ( ) , ephemeralEncryptionKey . getEncryptionKey ( ) ) ) ; < nl > } < nl > < nl > + private void fetchKeyGroup ( Future future ) { < nl > + future . onResult ( new FetchOwnKeyGroupResult ( privateKeyStorage . getKeyGroupId ( ) ) ) ; < nl > + } < nl > + < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > if ( message instanceof AskRequest & & ! isReady ) { < nl > @ @ - 244 , 6 + 248 , 9 @ @ public class KeyManagerActor extends ModuleActor { < nl > if ( message instanceof FetchOwnKey ) { < nl > fetchOwnKey ( future ) ; < nl > return false ; < nl > + } else if ( message instanceof FetchOwnKeyGroup ) { < nl > + fetchKeyGroup ( future ) ; < nl > + return false ; < nl > } < nl > return super . onAsk ( message , future ) ; < nl > } < nl > @ @ - 270 , 4 + 277 , 20 @ @ public class KeyManagerActor extends ModuleActor { < nl > return ephemeralKey ; < nl > } < nl > } < nl > + < nl > + public static class FetchOwnKeyGroup { < nl > + < nl > + } < nl > + < nl > + public static class FetchOwnKeyGroupResult { < nl > + private int keyGroupId ; < nl > + < nl > + public FetchOwnKeyGroupResult ( int keyGroupId ) { < nl > + this . keyGroupId = keyGroupId ; < nl > + } < nl > + < nl > + public int getKeyGroupId ( ) { < nl > + return keyGroupId ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java < nl > index 815d4ba . . 6d0d54d 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java < nl > @ @ - 48 , 6 + 48 , 29 @ @ public class MessageEncryptionActor extends ModuleActor { < nl > } ) ; < nl > } < nl > < nl > + public void onDecrypt ( int uid , ApiEncryptedMessage message ) { < nl > + Log . d ( TAG , " onDecrypt : " + uid ) ; < nl > + ArrayList < EncryptedBoxKey > encryptedBoxKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > + for ( ApiEncyptedBoxKey key : message . getBox ( ) . getKeys ( ) ) { < nl > + if ( key . getUsersId ( ) = = myUid ( ) ) { < nl > + encryptedBoxKeys . add ( new EncryptedBoxKey ( key . getUsersId ( ) , key . getKeyGroupId ( ) , < nl > + key . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + } < nl > + EncryptedBox encryptedBox = new EncryptedBox ( encryptedBoxKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , message . getBox ( ) . getEncPackage ( ) ) ; < nl > + ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . DecryptPackage ( encryptedBox ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " onDecrypt : onResult " ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . d ( TAG , " onDecrypt : onError " ) ; < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > @ Override < nl > public boolean onAsk ( Object message , Future future ) { < nl > if ( message instanceof EncryptMessage ) { < nl > @ @ - 58 , 6 + 81 , 16 @ @ public class MessageEncryptionActor extends ModuleActor { < nl > return super . onAsk ( message , future ) ; < nl > } < nl > < nl > + @ Override < nl > + public void onReceive ( Object message ) { < nl > + if ( message instanceof InMessage ) { < nl > + InMessage inMessage = ( InMessage ) message ; < nl > + onDecrypt ( inMessage . senderUid , inMessage . encryptedMessage ) ; < nl > + } else { < nl > + super . onReceive ( message ) ; < nl > + } < nl > + } < nl > + < nl > public static class InMessage { < nl > < nl > private Peer peer ; < nl > @ @ - 105 , 4 + 138 , 17 @ @ public class MessageEncryptionActor extends ModuleActor { < nl > return encryptedMessage ; < nl > } < nl > } < nl > + < nl > + public static class DecryptMessage { < nl > + < nl > + private ApiEncryptedMessage encryptedMessage ; < nl > + < nl > + public DecryptMessage ( ApiEncryptedMessage encryptedMessage ) { < nl > + this . encryptedMessage = encryptedMessage ; < nl > + } < nl > + < nl > + public ApiEncryptedMessage getEncryptedMessage ( ) { < nl > + return encryptedMessage ; < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java < nl > index 9da4c36 . . 8a8877a 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java < nl > @ @ - 27 , 6 + 27 , 7 @ @ import im . actor . core . entity . content . AbsContent ; < nl > import im . actor . core . entity . content . ServiceUserRegistered ; < nl > import im . actor . core . modules . AbsModule ; < nl > import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . encryption . MessageEncryptionActor ; < nl > import im . actor . core . modules . internal . messages . ConversationActor ; < nl > import im . actor . core . modules . internal . messages . ConversationHistoryActor ; < nl > import im . actor . core . modules . internal . messages . CursorReceiverActor ; < nl > @ @ - 53 , 11 + 54 , 13 @ @ public class MessagesProcessor extends AbsModule { < nl > long intMessageSortDate = 0 ; < nl > Peer peer = convert ( _ peer ) ; < nl > < nl > - ArrayList < Message > nMesages = new ArrayList < Message > ( ) ; < nl > + ArrayList < Message > nMessages = new ArrayList < Message > ( ) ; < nl > for ( UpdateMessage u : messages ) { < nl > < nl > if ( u . getMessage ( ) instanceof ApiEncryptedMessage ) { < nl > - / / TODO : Decrypt message < nl > + / / TODO : Proper decrypt message < nl > + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , < nl > + u . getDate ( ) , u . getSenderUid ( ) , u . getRid ( ) , ( ApiEncryptedMessage ) u . getMessage ( ) ) ) ; < nl > continue ; < nl > } < nl > < nl > @ @ - 72 , 7 + 75 , 7 @ @ public class MessagesProcessor extends AbsModule { < nl > boolean isOut = myUid ( ) = = u . getSenderUid ( ) ; < nl > < nl > / / Sending message to conversation < nl > - nMesages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , < nl > + nMessages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , < nl > isOut ? MessageState . SENT : MessageState . UNKNOWN , msgContent , < nl > new ArrayList < Reaction > ( ) ) ) ; < nl > < nl > @ @ - 84 , 7 + 87 , 7 @ @ public class MessagesProcessor extends AbsModule { < nl > } < nl > } < nl > < nl > - conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMesages ) ) ; < nl > + conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMessages ) ) ; < nl > < nl > if ( intMessageSortDate > 0 ) { < nl > plainReceiveActor ( ) . send ( new CursorReceiverActor . MarkReceived ( peer , intMessageSortDate ) ) ; < nl > @ @ - 95 , 7 + 98 , 7 @ @ public class MessagesProcessor extends AbsModule { < nl > } < nl > < nl > / / OwnReadActor < nl > - for ( Message m : nMesages ) { < nl > + for ( Message m : nMessages ) { < nl > if ( m . getSenderId ( ) ! = myUid ( ) ) { < nl > ownReadActor ( ) . send ( new OwnReadActor . InMessage ( peer , m ) ) ; < nl > } < nl > @ @ - 107 , 6 + 110 , 13 @ @ public class MessagesProcessor extends AbsModule { < nl > ApiMessage content ) { < nl > < nl > Peer peer = convert ( _ peer ) ; < nl > + < nl > + if ( content instanceof ApiEncryptedMessage ) { < nl > + / / TODO : Proper decrypt message < nl > + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , < nl > + date , senderUid , rid , ( ApiEncryptedMessage ) content ) ) ; < nl > + } < nl > + < nl > AbsContent msgContent ; < nl > try { < nl > msgContent = AbsContent . fromMessage ( content ) ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > index 7ff7e50 . . e4aff27 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > @ @ - 22 , 7 + 22 , 7 @ @ public class ByteStrings { < nl > } < nl > < nl > public static byte [ ] intToBytes ( int v ) { < nl > - byte [ ] data = new byte [ 8 ] ; < nl > + byte [ ] data = new byte [ 4 ] ; < nl > int offset = 0 ; < nl > data [ offset + + ] = ( byte ) ( ( v > > 24 ) & 0xFF ) ; < nl > data [ offset + + ] = ( byte ) ( ( v > > 16 ) & 0xFF ) ;

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index b56a212 . . fa328b1 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 56 , 6 + 56 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { 
 ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserKeyGroups ( uid ) , new AskCallback ( ) { 
 @ Override 
 public void onResult ( Object obj ) { 
 + Log . d ( TAG , " Groups loaded . . . " ) ; 
 KeyManagerActor . FetchUserKeyGroupsResponse response = ( KeyManagerActor . FetchUserKeyGroupsResponse ) obj ; 
 userKeys = response . getUserKeys ( ) ; 
 onGroupsReady ( ) ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index fbd44b6 . . 2d749be 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 7 , 6 + 7 , 7 @ @ import java . util . HashMap ; 
 import im . actor . core . api . ApiEncryptionKey ; 
 import im . actor . core . api . ApiEncryptionKeyGroup ; 
 import im . actor . core . api . ApiEncryptionKeySignature ; 
 + import im . actor . core . api . ApiEncryptionPublicKeyGroup ; 
 import im . actor . core . api . ApiUserOutPeer ; 
 import im . actor . core . api . rpc . RequestCreateNewKeyGroup ; 
 import im . actor . core . api . rpc . RequestLoadPublicKeyGroups ; 
 @ @ - 31 , 8 + 32 , 12 @ @ import im . actor . runtime . Log ; 
 import im . actor . runtime . Storage ; 
 import im . actor . runtime . actors . Future ; 
 import im . actor . runtime . actors . ask . AskRequest ; 
 + import im . actor . runtime . bser . BserWriter ; 
 + import im . actor . runtime . bser . DataOutput ; 
 import im . actor . runtime . crypto . Curve25519 ; 
 + import im . actor . runtime . crypto . primitives . digest . SHA256 ; 
 import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 + import im . actor . runtime . crypto . ratchet . RatchetKeySignature ; 
 import im . actor . runtime . storage . KeyValueStorage ; 
 
 public class KeyManagerActor extends ModuleActor { 
 @ @ - 99 , 16 + 104 , 15 @ @ public class KeyManagerActor extends ModuleActor { 
 ArrayList < ApiEncryptionKeySignature > keySignatures = new ArrayList < ApiEncryptionKeySignature > ( ) ; 
 for ( OwnPrivateKey key : ownKeys . getKeys ( ) ) { 
 byte [ ] publicKey2 = Curve25519 . keyGenPublic ( privateKey . getKey ( ) ) ; 
 - ApiEncryptionKey apiKey = 
 - new ApiEncryptionKey ( 
 - key . getKeyId ( ) , 
 - key . getKeyAlg ( ) , 
 - publicKey2 , 
 - null ) ; 
 - keys . add ( apiKey ) ; 
 - 
 - 
 - byte [ ] signature = Curve25519 . calculateSignature ( Crypto . randomBytes ( 64 ) , privateKey . getKey ( ) , apiKey . toByteArray ( ) ) ; 
 + keys . add ( new ApiEncryptionKey ( 
 + key . getKeyId ( ) , 
 + key . getKeyAlg ( ) , 
 + publicKey2 , 
 + null ) ) ; 
 + 
 + byte [ ] signature = Curve25519 . calculateSignature ( Crypto . randomBytes ( 64 ) , privateKey . getKey ( ) , 
 + RatchetKeySignature . hashForSignature ( key . getKeyId ( ) , 
 + key . getKeyAlg ( ) , publicKey2 ) ) ; 
 keySignatures . add ( 
 new ApiEncryptionKeySignature ( 
 key . getKeyId ( ) , 
 @ @ - 210 , 10 + 214 , 8 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 
 private void onAllKeysReady ( ) { 
 - Log . d ( TAG , " Ephemeral Keys are ready " ) ; 
 - 
 - / / Now we can start receiving encrypted messages 
 - 
 + Log . d ( TAG , " All Keys are ready " ) ; 
 + / / Now we can start receiving or sending encrypted messages 
 isReady = true ; 
 unstashAll ( ) ; 
 } 
 @ @ - 229 , 7 + 231 , 6 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 
 private void fetchEphemeralKey ( byte [ ] publicKey , Future future ) { 
 - Log . d ( TAG , " fetchEphemeralKey " ) ; 
 for ( OwnPrivateKey k : ownKeys . getEphemeralKeys ( ) ) { 
 if ( ByteStrings . isEquals ( Curve25519 . keyGenPublic ( k . getKey ( ) ) , publicKey ) ) { 
 future . onResult ( new FetchEphemeralPrivateKeyRes ( k . getKey ( ) ) ) ; 
 @ @ - 240 , 7 + 241 , 6 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 
 private void fetchEphemeralKey ( long keyId , Future future ) { 
 - Log . d ( TAG , " fetchEphemeralKey " ) ; 
 for ( OwnPrivateKey k : ownKeys . getEphemeralKeys ( ) ) { 
 if ( k . getKeyId ( ) = = keyId ) { 
 future . onResult ( new FetchEphemeralPrivateKeyRes ( k . getKey ( ) ) ) ; 
 @ @ - 252 , 68 + 252 , 158 @ @ public class KeyManagerActor extends ModuleActor { 
 
 private void fetchUserGroups ( final int uid , final Future future ) { 
 Log . d ( TAG , " fetchUserGroups " ) ; 
 - UserKeys userKeys = null ; / / cachedUserKeys . get ( uid ) ; 
 - / / if ( userKeys = = null ) { 
 - / / byte [ ] cached = encryptionKeysStorage . loadItem ( uid ) ; 
 - / / if ( cached ! = null ) { 
 - / / try { 
 - / / userKeys = new UserKeys ( cached ) ; 
 - / / } catch ( IOException e ) { 
 - / / e . printStackTrace ( ) ; 
 - / / } 
 - / / } 
 - / / } 
 - / / if ( userKeys ! = null ) { 
 - / / Log . d ( TAG , " onResult : fast " ) ; 
 - / / future . onResult ( new FetchUserKeyGroupsResponse ( userKeys ) ) ; 
 - / / return ; 
 - / / } 
 - 
 - Log . d ( TAG , " Requesting " ) ; 
 + final UserKeys userKeys = getCachedUserKeys ( uid ) ; 
 + if ( userKeys ! = null ) { 
 + Log . d ( TAG , " fetchUserGroups : cached " ) ; 
 + future . onResult ( new FetchUserKeyGroupsResponse ( userKeys ) ) ; 
 + return ; 
 + } 
 + Log . d ( TAG , " fetchUserGroups : loading " ) ; 
 User user = users ( ) . getValue ( uid ) ; 
 request ( new RequestLoadPublicKeyGroups ( new ApiUserOutPeer ( uid , user . getAccessHash ( ) ) ) , new RpcCallback < ResponsePublicKeyGroups > ( ) { 
 @ Override 
 public void onResult ( ResponsePublicKeyGroups response ) { 
 - Log . d ( TAG , " onResult " ) ; 
 - UserKeysGroup [ ] groups = new UserKeysGroup [ response . getPublicKeyGroups ( ) . size ( ) ] ; 
 - for ( int i = 0 ; i < groups . length ; i + + ) { 
 - ApiEncryptionKeyGroup encryptionKey = response . getPublicKeyGroups ( ) . get ( i ) ; 
 - 
 - / / TODO : Validate signatures 
 - 
 - UserPublicKey identity = new UserPublicKey ( 
 - encryptionKey . getIdentityKey ( ) . getKeyId ( ) , 
 - encryptionKey . getIdentityKey ( ) . getKeyAlg ( ) , 
 - encryptionKey . getIdentityKey ( ) . getKeyMaterial ( ) ) ; 
 - UserPublicKey [ ] keys = new UserPublicKey [ encryptionKey . getKeys ( ) . size ( ) ] ; 
 - for ( int j = 0 ; j < keys . length ; j + + ) { 
 - keys [ j ] = new UserPublicKey ( 
 - encryptionKey . getKeys ( ) . get ( j ) . getKeyId ( ) , 
 - encryptionKey . getKeys ( ) . get ( j ) . getKeyAlg ( ) , 
 - encryptionKey . getKeys ( ) . get ( j ) . getKeyMaterial ( ) ) ; 
 + ArrayList < UserKeysGroup > keysGroups = new ArrayList < UserKeysGroup > ( ) ; 
 + for ( ApiEncryptionKeyGroup keyGroup : response . getPublicKeyGroups ( ) ) { 
 + UserKeysGroup validatedKeysGroup = validateUserKeysGroup ( uid , keyGroup ) ; 
 + if ( validatedKeysGroup ! = null ) { 
 + keysGroups . add ( validatedKeysGroup ) ; 
 } 
 - groups [ i ] = new UserKeysGroup ( encryptionKey . getKeyGroupId ( ) , identity , keys , new UserPublicKey [ 0 ] ) ; 
 } 
 - UserKeys userKeys1 = new UserKeys ( uid , groups ) ; 
 - encryptionKeysStorage . addOrUpdateItem ( uid , userKeys1 . toByteArray ( ) ) ; 
 - future . onResult ( new FetchUserKeyGroupsResponse ( userKeys1 ) ) ; 
 + if ( keysGroups . size ( ) ! = 0 ) { 
 + UserKeys userKeys1 = new UserKeys ( uid , keysGroups . toArray ( new UserKeysGroup [ keysGroups . size ( ) ] ) ) ; 
 + cacheUserKeys ( userKeys1 ) ; 
 + future . onResult ( new FetchUserKeyGroupsResponse ( userKeys1 ) ) ; 
 + } else { 
 + Log . w ( TAG , " ( uid : " + uid + " ) No valid key groups found " ) ; 
 + future . onError ( new RuntimeException ( " No key groups found " ) ) ; 
 + } 
 } 
 
 @ Override 
 public void onError ( RpcException e ) { 
 - Log . d ( TAG , " onError " ) ; 
 future . onError ( e ) ; 
 } 
 } ) ; 
 } 
 
 + private void onPublicKeysGroupAdded ( int uid , ApiEncryptionKeyGroup keyGroup ) { 
 + UserKeys userKeys = getCachedUserKeys ( uid ) ; 
 + if ( userKeys = = null ) { 
 + return ; 
 + } 
 + UserKeysGroup validatedKeysGroup = validateUserKeysGroup ( uid , keyGroup ) ; 
 + if ( validatedKeysGroup ! = null ) { 
 + cacheUserKeys ( userKeys . addUserKeyGroup ( validatedKeysGroup ) ) ; 
 + } 
 + } 
 + 
 + private void onPublicKeysGroupRemoved ( int uid , int keyGroupId ) { 
 + UserKeys userKeys = getCachedUserKeys ( uid ) ; 
 + if ( userKeys = = null ) { 
 + return ; 
 + } 
 + cacheUserKeys ( userKeys . removeUserKeyGroup ( keyGroupId ) ) ; 
 + } 
 + 
 + private UserKeysGroup validateUserKeysGroup ( int uid , ApiEncryptionKeyGroup keyGroup ) { 
 + if ( ! " curve25519 " . equals ( keyGroup . getIdentityKey ( ) . getKeyAlg ( ) ) ) { 
 + / / Anything other than curve25519 is not supported 
 + Log . w ( TAG , " ( uid : " + uid + " ) Unsupported identity key alg " + keyGroup . getIdentityKey ( ) . getKeyAlg ( ) ) ; 
 + return null ; 
 + } 
 + 
 + UserPublicKey identity = new UserPublicKey ( 
 + keyGroup . getIdentityKey ( ) . getKeyId ( ) , 
 + keyGroup . getIdentityKey ( ) . getKeyAlg ( ) , 
 + keyGroup . getIdentityKey ( ) . getKeyMaterial ( ) ) ; 
 + 
 + ArrayList < UserPublicKey > keys = new ArrayList < UserPublicKey > ( ) ; 
 + 
 + key _ loop : 
 + for ( ApiEncryptionKey key : keyGroup . getKeys ( ) ) { 
 + 
 + / / 
 + / / Validating signatures 
 + / / 
 + for ( ApiEncryptionKeySignature sig : keyGroup . getSignatures ( ) ) { 
 + if ( ! sig . getSignatureAlg ( ) . equals ( " Ed25519 " ) ) { 
 + / / Anything other than Ed25519 is not supported 
 + Log . w ( TAG , " ( uid : " + uid + " ) Unsupported signature algorithm " + sig . getSignatureAlg ( ) ) ; 
 + continue ; 
 + } 
 + if ( sig . getKeyId ( ) ! = key . getKeyId ( ) ) { 
 + continue ; 
 + } 
 + 
 + byte [ ] keyForSign = RatchetKeySignature . hashForSignature ( 
 + key . getKeyId ( ) , 
 + key . getKeyAlg ( ) , 
 + key . getKeyMaterial ( ) ) ; 
 + 
 + if ( ! Curve25519 . verifySignature ( identity . getPublicKey ( ) , keyForSign , sig . getSignature ( ) ) ) { 
 + Log . w ( TAG , " ( uid : " + uid + " ) Unable to verify signature for " + Crypto . keyHash ( key . getKeyMaterial ( ) ) + " key " ) ; 
 + continue key _ loop ; 
 + } 
 + } 
 + 
 + / / 
 + / / Adding key to collection 
 + / / 
 + 
 + keys . add ( new UserPublicKey ( 
 + key . getKeyId ( ) , 
 + key . getKeyAlg ( ) , 
 + key . getKeyMaterial ( ) ) ) ; 
 + } 
 + 
 + if ( keys . size ( ) > 0 ) { 
 + return new UserKeysGroup ( keyGroup . getKeyGroupId ( ) , identity , keys . toArray ( new UserPublicKey [ keys . size ( ) ] ) , 
 + new UserPublicKey [ 0 ] ) ; 
 + } else { 
 + Log . w ( TAG , " ( uid : " + uid + " ) No valid keys in key group # " + keyGroup . getKeyGroupId ( ) ) ; 
 + return null ; 
 + } 
 + } 
 + 
 + private UserKeys getCachedUserKeys ( int uid ) { 
 + UserKeys userKeys = cachedUserKeys . get ( uid ) ; 
 + if ( userKeys = = null ) { 
 + byte [ ] cached = encryptionKeysStorage . loadItem ( uid ) ; 
 + if ( cached ! = null ) { 
 + try { 
 + userKeys = new UserKeys ( cached ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + } 
 + return userKeys ; 
 + } 
 + 
 + private void cacheUserKeys ( UserKeys userKeys ) { 
 + encryptionKeysStorage . addOrUpdateItem ( userKeys . getUid ( ) , userKeys . toByteArray ( ) ) ; 
 + cachedUserKeys . put ( userKeys . getUid ( ) , userKeys ) ; 
 + } 
 + 
 @ Override 
 public void onReceive ( Object message ) { 
 - if ( message instanceof AskRequest & & ! isReady ) { 
 + if ( ! isReady 
 + & & ( message instanceof AskRequest 
 + | | message instanceof PublicKeysGroupAdded 
 + | | message instanceof PublicKeysGroupRemoved ) ) { 
 stash ( ) ; 
 return ; 
 } 
 - super . onReceive ( message ) ; 
 + if ( message instanceof PublicKeysGroupAdded ) { 
 + PublicKeysGroupAdded publicKeysGroupAdded = ( PublicKeysGroupAdded ) message ; 
 + onPublicKeysGroupAdded ( publicKeysGroupAdded . getUid ( ) , publicKeysGroupAdded . getPublicKeyGroup ( ) ) ; 
 + } else if ( message instanceof PublicKeysGroupRemoved ) { 
 + PublicKeysGroupRemoved publicKeysGroupRemoved = ( PublicKeysGroupRemoved ) message ; 
 + onPublicKeysGroupRemoved ( publicKeysGroupRemoved . getUid ( ) , publicKeysGroupRemoved . getKeyGroupId ( ) ) ; 
 + } else { 
 + super . onReceive ( message ) ; 
 + } 
 } 
 
 @ Override 
 @ @ - 438 , 4 + 528 , 41 @ @ public class KeyManagerActor extends ModuleActor { 
 return userKeys ; 
 } 
 } 
 + 
 + public static class PublicKeysGroupAdded { 
 + 
 + private int uid ; 
 + private ApiEncryptionKeyGroup publicKeyGroup ; 
 + 
 + public PublicKeysGroupAdded ( int uid , ApiEncryptionKeyGroup publicKeyGroup ) { 
 + this . uid = uid ; 
 + this . publicKeyGroup = publicKeyGroup ; 
 + } 
 + 
 + public int getUid ( ) { 
 + return uid ; 
 + } 
 + 
 + public ApiEncryptionKeyGroup getPublicKeyGroup ( ) { 
 + return publicKeyGroup ; 
 + } 
 + } 
 + 
 + public static class PublicKeysGroupRemoved { 
 + private int uid ; 
 + private int keyGroupId ; 
 + 
 + public PublicKeysGroupRemoved ( int uid , int keyGroupId ) { 
 + this . uid = uid ; 
 + this . keyGroupId = keyGroupId ; 
 + } 
 + 
 + public int getUid ( ) { 
 + return uid ; 
 + } 
 + 
 + public int getKeyGroupId ( ) { 
 + return keyGroupId ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / UserKeys . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / UserKeys . java 
 index b02bce1 . . a764776 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / UserKeys . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / UserKeys . java 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . core . modules . encryption . entity ; 
 
 import java . io . IOException ; 
 + import java . util . ArrayList ; 
 import java . util . List ; 
 
 import im . actor . runtime . bser . BserObject ; 
 @ @ - 29 , 6 + 30 , 25 @ @ public class UserKeys extends BserObject { 
 return userKeysGroups ; 
 } 
 
 + public UserKeys addUserKeyGroup ( UserKeysGroup keysGroup ) { 
 + ArrayList < UserKeysGroup > userKeysGroups = new ArrayList < UserKeysGroup > ( ) ; 
 + for ( UserKeysGroup g : userKeysGroups ) { 
 + userKeysGroups . add ( g ) ; 
 + } 
 + userKeysGroups . add ( keysGroup ) ; 
 + return new UserKeys ( uid , userKeysGroups . toArray ( new UserKeysGroup [ userKeysGroups . size ( ) ] ) ) ; 
 + } 
 + 
 + public UserKeys removeUserKeyGroup ( int keyGroupId ) { 
 + ArrayList < UserKeysGroup > userKeysGroups = new ArrayList < UserKeysGroup > ( ) ; 
 + for ( UserKeysGroup g : userKeysGroups ) { 
 + if ( g . getKeyGroupId ( ) ! = keyGroupId ) { 
 + userKeysGroups . add ( g ) ; 
 + } 
 + } 
 + return new UserKeys ( uid , userKeysGroups . toArray ( new UserKeysGroup [ userKeysGroups . size ( ) ] ) ) ; 
 + } 
 + 
 @ Override 
 public void parse ( BserValues values ) throws IOException { 
 uid = values . getInt ( 1 ) ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / UpdateProcessor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / UpdateProcessor . java 
 index 6095457 . . e543022 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / UpdateProcessor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / UpdateProcessor . java 
 @ @ - 42 , 6 + 42 , 8 @ @ import im . actor . core . api . updates . UpdateMessageReceived ; 
 import im . actor . core . api . updates . UpdateMessageSent ; 
 import im . actor . core . api . updates . UpdateOwnStickersChanged ; 
 import im . actor . core . api . updates . UpdateParameterChanged ; 
 + import im . actor . core . api . updates . UpdatePublicKeyGroupAdded ; 
 + import im . actor . core . api . updates . UpdatePublicKeyGroupRemoved ; 
 import im . actor . core . api . updates . UpdateReactionsUpdate ; 
 import im . actor . core . api . updates . UpdateStickerCollectionsChanged ; 
 import im . actor . core . api . updates . UpdateTyping ; 
 @ @ - 53 , 6 + 55 , 7 @ @ import im . actor . core . api . updates . UpdateUserOnline ; 
 import im . actor . core . entity . Peer ; 
 import im . actor . core . modules . AbsModule ; 
 import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . encryption . KeyManagerActor ; 
 import im . actor . core . modules . internal . contacts . ContactsSyncActor ; 
 import im . actor . core . modules . internal . messages . OwnReadActor ; 
 import im . actor . core . modules . updates . internal . ChangeContent ; 
 @ @ - 346 , 6 + 349 , 16 @ @ public class UpdateProcessor extends AbsModule { 
 callsProcessor . onSignal ( ( UpdateCallSignal ) update ) ; 
 } else if ( update instanceof UpdateCallEnded ) { 
 callsProcessor . onCallEnd ( ( UpdateCallEnded ) update ) ; 
 + } else if ( update instanceof UpdatePublicKeyGroupAdded ) { 
 + context ( ) . getEncryption ( ) . getKeyManager ( ) . send ( new KeyManagerActor . PublicKeysGroupAdded ( 
 + ( ( UpdatePublicKeyGroupAdded ) update ) . getUid ( ) , 
 + ( ( UpdatePublicKeyGroupAdded ) update ) . getKeyGroup ( ) 
 + ) ) ; 
 + } else if ( update instanceof UpdatePublicKeyGroupRemoved ) { 
 + context ( ) . getEncryption ( ) . getKeyManager ( ) . send ( new KeyManagerActor . PublicKeysGroupRemoved ( 
 + ( ( UpdatePublicKeyGroupRemoved ) update ) . getUid ( ) , 
 + ( ( UpdatePublicKeyGroupRemoved ) update ) . getKeyGroupId ( ) 
 + ) ) ; 
 } 
 } 
 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / Crypto . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / Crypto . java 
 index 3d7743a . . c3998f5 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / Crypto . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / Crypto . java 
 @ @ - 6 , 6 + 6 , 8 @ @ package im . actor . runtime ; 
 
 import java . math . BigInteger ; 
 
 + import im . actor . core . util . Hex ; 
 + import im . actor . runtime . crypto . primitives . digest . KeyDigest ; 
 import im . actor . runtime . crypto . primitives . digest . SHA256 ; 
 
 public class Crypto { 
 @ @ - 19 , 6 + 21 , 14 @ @ public class Crypto { 
 return provider . MD5 ( data ) ; 
 } 
 
 + public static String keyHash ( byte [ ] publicKey ) { 
 + KeyDigest keyDigest = new KeyDigest ( ) ; 
 + keyDigest . update ( publicKey , 0 , publicKey . length ) ; 
 + byte [ ] res = new byte [ 8 ] ; 
 + keyDigest . doFinal ( res , 0 ) ; 
 + return Hex . toHex ( res ) ; 
 + } 
 + 
 / * * 
 * Calculating SHA256 
 * 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / KeyDigest . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / KeyDigest . java 
 new file mode 100644 
 index 0000000 . . de6f64a 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / KeyDigest . java 
 @ @ - 0 , 0 + 1 , 33 @ @ 
 + package im . actor . runtime . crypto . primitives . digest ; 
 + 
 + import im . actor . runtime . crypto . primitives . Digest ; 
 + 
 + / * * 
 + * Truncated SHA256 for public keys 
 + * / 
 + public class KeyDigest implements Digest { 
 + 
 + private SHA256 sha256 = new SHA256 ( ) ; 
 + 
 + @ Override 
 + public void reset ( ) { 
 + sha256 . reset ( ) ; 
 + } 
 + 
 + @ Override 
 + public void update ( byte [ ] src , int offset , int length ) { 
 + sha256 . update ( src , offset , length ) ; 
 + } 
 + 
 + @ Override 
 + public void doFinal ( byte [ ] dest , int destOffset ) { 
 + byte [ ] res = new byte [ 32 ] ; 
 + sha256 . doFinal ( res , 0 ) ; 
 + System . arraycopy ( res , 0 , dest , 0 , 8 ) ; 
 + } 
 + 
 + @ Override 
 + public int getDigestSize ( ) { 
 + return 8 ; 
 + } 
 + } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / ratchet / RatchetKeySignature . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / ratchet / RatchetKeySignature . java 
 new file mode 100644 
 index 0000000 . . 8464568 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / ratchet / RatchetKeySignature . java 
 @ @ - 0 , 0 + 1 , 27 @ @ 
 + package im . actor . runtime . crypto . ratchet ; 
 + 
 + import im . actor . runtime . bser . BserWriter ; 
 + import im . actor . runtime . bser . DataOutput ; 
 + import im . actor . runtime . crypto . primitives . digest . SHA256 ; 
 + 
 + public class RatchetKeySignature { 
 + public static byte [ ] hashForSignature ( long keyId , String keyAlg , byte [ ] publicKey ) { 
 + byte [ ] toSign ; 
 + try { 
 + DataOutput dataOutput = new DataOutput ( ) ; 
 + BserWriter writer = new BserWriter ( dataOutput ) ; 
 + writer . writeLong ( 1 , keyId ) ; 
 + writer . writeString ( 2 , keyAlg ) ; 
 + SHA256 sha256 = new SHA256 ( ) ; 
 + sha256 . update ( publicKey , 0 , publicKey . length ) ; 
 + byte [ ] hash = new byte [ 32 ] ; 
 + sha256 . doFinal ( hash , 0 ) ; 
 + writer . writeBytes ( 3 , hash ) ; 
 + toSign = dataOutput . toByteArray ( ) ; 
 + } catch ( Exception e ) { 
 + / / Never happens 
 + return new byte [ 0 ] ; 
 + } 
 + return toSign ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj 
 index 2f54661 . . c33368d 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj 
 @ @ - 1550 , 7 + 1550 , 7 @ @ 
 	 	 	 	 TargetAttributes = { 
 	 	 	 	 	 066A50D11BC4AE63000E606E = { 
 	 	 	 	 	 	 CreatedOnToolsVersion = 7 . 0 ; 
 - 	 	 	 	 	 	 DevelopmentTeam = PR6635TQQ3 ; 
 + 	 	 	 	 	 	 DevelopmentTeam = HVJR44Y5B6 ; 
 	 	 	 	 	 } ; 
 	 	 	 	 } ; 
 	 	 	 } ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 2d72521 . . 37809ce 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . core . modules . encryption . entity . EncryptedBox ; 
 import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; 
 import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 + import im . actor . core . util . Hex ; 
 import im . actor . core . util . ModuleActor ; 
 import im . actor . runtime . Crypto ; 
 import im . actor . runtime . Log ; 
 @ @ - 25 , 6 + 26 , 7 @ @ import im . actor . runtime . actors . ask . AskRequest ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . box . ActorBox ; 
 import im . actor . runtime . crypto . box . ActorBoxKey ; 
 + import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 
 public class EncryptedPeerActor extends ModuleActor { 
 
 @ @ - 34 , 6 + 36 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { 
 private ArrayList < ApiEncryptionKeyGroup > keyGroups ; 
 private HashMap < Integer , ActorRef > sessions = new HashMap < Integer , ActorRef > ( ) ; 
 private boolean isReady = false ; 
 + private int ownKeyGroupId ; 
 
 public EncryptedPeerActor ( int uid , ModuleContext context ) { 
 super ( context ) ; 
 @ @ - 78 , 14 + 81 , 29 @ @ public class EncryptedPeerActor extends ModuleActor { 
 } 
 } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; 
 } 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKeyGroup ( ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + KeyManagerActor . FetchOwnKeyGroupResult res = ( KeyManagerActor . FetchOwnKeyGroupResult ) obj ; 
 + ownKeyGroupId = res . getKeyGroupId ( ) ; 
 + onOwnKeysReady ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + / / Do nothing 
 + } 
 + } ) ; 
 + } 
 + 
 + private void onOwnKeysReady ( ) { 
 + Log . w ( TAG , " onOwnKeysReady " ) ; 
 isReady = true ; 
 unstashAll ( ) ; 
 } 
 
 private void doEncrypt ( final byte [ ] data , final Future future ) { 
 - 
 Log . d ( TAG , " doEncrypt " ) ; 
 - 
 final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 
 final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 @ @ - 112 , 19 + 130 , 61 @ @ public class EncryptedPeerActor extends ModuleActor { 
 Log . d ( TAG , " doEncrypt2 " ) ; 
 byte [ ] encData ; 
 try { 
 - encData = ActorBox . closeBox ( new byte [ 0 ] , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 } catch ( IntegrityException e ) { 
 e . printStackTrace ( ) ; 
 future . onError ( e ) ; 
 return ; 
 } 
 
 - EncryptedBox encryptedBox = new EncryptedBox ( encryptedKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , encData ) ; 
 + EncryptedBox encryptedBox = new EncryptedBox ( 
 + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 + 
 + Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; 
 + for ( EncryptedBoxKey k : encryptedKeys ) { 
 + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 + } 
 + 
 future . onResult ( encryptedBox ) ; 
 } 
 
 - private void doDecrypt ( EncryptedBox data , Future future ) { 
 + private void doDecrypt ( EncryptedBox data , final Future future ) { 
 + int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; 
 + byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; 
 + 
 + if ( sessions . containsKey ( senderKeyGroup ) ) { 
 + Log . d ( TAG , " Decryption with key group " ) ; 
 + byte [ ] encKey = null ; 
 + for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 + if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { 
 + encKey = k . getEncryptedKey ( ) ; 
 + break ; 
 + } 
 + } 
 + 
 + Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; 
 + for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 + } 
 + 
 + ask ( sessions . get ( senderKeyGroup ) , new EncryptionSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + Log . d ( TAG , " Decryption with key group : onResult " ) ; 
 + future . onResult ( ) ; 
 + } 
 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . d ( TAG , " Decryption with key group : onError " ) ; 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + } else { 
 + Log . w ( TAG , " Unable to find appropriate session # " + senderKeyGroup ) ; 
 + future . onError ( new RuntimeException ( ) ) ; 
 + } 
 } 
 
 @ Override 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 index 7f57506 . . 5d65dd8 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 @ @ - 8 , 9 + 8 , 11 @ @ import im . actor . core . api . ApiUserOutPeer ; 
 import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; 
 import im . actor . core . api . rpc . ResponsePublicKeys ; 
 import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; 
 import im . actor . core . modules . encryption . entity . EncryptionKey ; 
 import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 + import im . actor . core . util . Hex ; 
 import im . actor . core . util . ModuleActor ; 
 import im . actor . core . util . RandomUtils ; 
 import im . actor . runtime . Crypto ; 
 @ @ - 101 , 7 + 103 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { 
 return ; 
 } 
 
 - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( 0 ) ; 
 + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; 
 onTheirReady0 ( ) ; 
 } 
 @ @ - 169 , 6 + 171 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { 
 ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; 
 
 byte [ ] header = ByteStrings . merge ( 
 + ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , 
 ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 currentOwnKey . getPublicKey ( ) , 
 @ @ - 186 , 9 + 189 , 46 @ @ public class EncryptionSessionActor extends ModuleActor { 
 
 byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; 
 
 + 
 + int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; 
 + long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; 
 + long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; 
 + byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; 
 + byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; 
 + int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; 
 + 
 + Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; 
 + Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; 
 + 
 + 
 + Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; 
 + Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 + Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 + Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; 
 + 
 future . onResult ( new EncryptedPackageRes ( pkg ) ) ; 
 } 
 
 + private void onDecrypt ( byte [ ] data , Future future ) { 
 + int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 + long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 + long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 + byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 + byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 + int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 + 
 + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 + Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; 
 + Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 + Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 + Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; 
 + 
 + / / future . onResult ( ) ; 
 + } 
 + 
 @ Override 
 public void onReceive ( Object message ) { 
 if ( ! isReady & & message instanceof AskRequest ) { 
 @ @ - 203 , 6 + 243 , 10 @ @ public class EncryptionSessionActor extends ModuleActor { 
 if ( message instanceof EncryptPackage ) { 
 onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; 
 return false ; 
 + } else if ( message instanceof DecryptPackage ) { 
 + DecryptPackage decryptPackage = ( DecryptPackage ) message ; 
 + onDecrypt ( decryptPackage . getData ( ) , future ) ; 
 + return false ; 
 } else { 
 return super . onAsk ( message , future ) ; 
 } 
 @ @ - 232 , 4 + 276 , 17 @ @ public class EncryptionSessionActor extends ModuleActor { 
 return data ; 
 } 
 } 
 + 
 + public static class DecryptPackage { 
 + 
 + private byte [ ] data ; 
 + 
 + public DecryptPackage ( byte [ ] data ) { 
 + this . data = data ; 
 + } 
 + 
 + public byte [ ] getData ( ) { 
 + return data ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index f4eb042 . . 58c2383 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 230 , 6 + 230 , 10 @ @ public class KeyManagerActor extends ModuleActor { 
 future . onResult ( new FetchOwnKeyResult ( privateKeyStorage . getIdentityKey ( ) , ephemeralEncryptionKey . getEncryptionKey ( ) ) ) ; 
 } 
 
 + private void fetchKeyGroup ( Future future ) { 
 + future . onResult ( new FetchOwnKeyGroupResult ( privateKeyStorage . getKeyGroupId ( ) ) ) ; 
 + } 
 + 
 @ Override 
 public void onReceive ( Object message ) { 
 if ( message instanceof AskRequest & & ! isReady ) { 
 @ @ - 244 , 6 + 248 , 9 @ @ public class KeyManagerActor extends ModuleActor { 
 if ( message instanceof FetchOwnKey ) { 
 fetchOwnKey ( future ) ; 
 return false ; 
 + } else if ( message instanceof FetchOwnKeyGroup ) { 
 + fetchKeyGroup ( future ) ; 
 + return false ; 
 } 
 return super . onAsk ( message , future ) ; 
 } 
 @ @ - 270 , 4 + 277 , 20 @ @ public class KeyManagerActor extends ModuleActor { 
 return ephemeralKey ; 
 } 
 } 
 + 
 + public static class FetchOwnKeyGroup { 
 + 
 + } 
 + 
 + public static class FetchOwnKeyGroupResult { 
 + private int keyGroupId ; 
 + 
 + public FetchOwnKeyGroupResult ( int keyGroupId ) { 
 + this . keyGroupId = keyGroupId ; 
 + } 
 + 
 + public int getKeyGroupId ( ) { 
 + return keyGroupId ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java 
 index 815d4ba . . 6d0d54d 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java 
 @ @ - 48 , 6 + 48 , 29 @ @ public class MessageEncryptionActor extends ModuleActor { 
 } ) ; 
 } 
 
 + public void onDecrypt ( int uid , ApiEncryptedMessage message ) { 
 + Log . d ( TAG , " onDecrypt : " + uid ) ; 
 + ArrayList < EncryptedBoxKey > encryptedBoxKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 + for ( ApiEncyptedBoxKey key : message . getBox ( ) . getKeys ( ) ) { 
 + if ( key . getUsersId ( ) = = myUid ( ) ) { 
 + encryptedBoxKeys . add ( new EncryptedBoxKey ( key . getUsersId ( ) , key . getKeyGroupId ( ) , 
 + key . getEncryptedKey ( ) ) ) ; 
 + } 
 + } 
 + EncryptedBox encryptedBox = new EncryptedBox ( encryptedBoxKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , message . getBox ( ) . getEncPackage ( ) ) ; 
 + ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . DecryptPackage ( encryptedBox ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + Log . d ( TAG , " onDecrypt : onResult " ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . d ( TAG , " onDecrypt : onError " ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 @ Override 
 public boolean onAsk ( Object message , Future future ) { 
 if ( message instanceof EncryptMessage ) { 
 @ @ - 58 , 6 + 81 , 16 @ @ public class MessageEncryptionActor extends ModuleActor { 
 return super . onAsk ( message , future ) ; 
 } 
 
 + @ Override 
 + public void onReceive ( Object message ) { 
 + if ( message instanceof InMessage ) { 
 + InMessage inMessage = ( InMessage ) message ; 
 + onDecrypt ( inMessage . senderUid , inMessage . encryptedMessage ) ; 
 + } else { 
 + super . onReceive ( message ) ; 
 + } 
 + } 
 + 
 public static class InMessage { 
 
 private Peer peer ; 
 @ @ - 105 , 4 + 138 , 17 @ @ public class MessageEncryptionActor extends ModuleActor { 
 return encryptedMessage ; 
 } 
 } 
 + 
 + public static class DecryptMessage { 
 + 
 + private ApiEncryptedMessage encryptedMessage ; 
 + 
 + public DecryptMessage ( ApiEncryptedMessage encryptedMessage ) { 
 + this . encryptedMessage = encryptedMessage ; 
 + } 
 + 
 + public ApiEncryptedMessage getEncryptedMessage ( ) { 
 + return encryptedMessage ; 
 + } 
 + } 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java 
 index 9da4c36 . . 8a8877a 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import im . actor . core . entity . content . AbsContent ; 
 import im . actor . core . entity . content . ServiceUserRegistered ; 
 import im . actor . core . modules . AbsModule ; 
 import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . encryption . MessageEncryptionActor ; 
 import im . actor . core . modules . internal . messages . ConversationActor ; 
 import im . actor . core . modules . internal . messages . ConversationHistoryActor ; 
 import im . actor . core . modules . internal . messages . CursorReceiverActor ; 
 @ @ - 53 , 11 + 54 , 13 @ @ public class MessagesProcessor extends AbsModule { 
 long intMessageSortDate = 0 ; 
 Peer peer = convert ( _ peer ) ; 
 
 - ArrayList < Message > nMesages = new ArrayList < Message > ( ) ; 
 + ArrayList < Message > nMessages = new ArrayList < Message > ( ) ; 
 for ( UpdateMessage u : messages ) { 
 
 if ( u . getMessage ( ) instanceof ApiEncryptedMessage ) { 
 - / / TODO : Decrypt message 
 + / / TODO : Proper decrypt message 
 + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , 
 + u . getDate ( ) , u . getSenderUid ( ) , u . getRid ( ) , ( ApiEncryptedMessage ) u . getMessage ( ) ) ) ; 
 continue ; 
 } 
 
 @ @ - 72 , 7 + 75 , 7 @ @ public class MessagesProcessor extends AbsModule { 
 boolean isOut = myUid ( ) = = u . getSenderUid ( ) ; 
 
 / / Sending message to conversation 
 - nMesages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , 
 + nMessages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , 
 isOut ? MessageState . SENT : MessageState . UNKNOWN , msgContent , 
 new ArrayList < Reaction > ( ) ) ) ; 
 
 @ @ - 84 , 7 + 87 , 7 @ @ public class MessagesProcessor extends AbsModule { 
 } 
 } 
 
 - conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMesages ) ) ; 
 + conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMessages ) ) ; 
 
 if ( intMessageSortDate > 0 ) { 
 plainReceiveActor ( ) . send ( new CursorReceiverActor . MarkReceived ( peer , intMessageSortDate ) ) ; 
 @ @ - 95 , 7 + 98 , 7 @ @ public class MessagesProcessor extends AbsModule { 
 } 
 
 / / OwnReadActor 
 - for ( Message m : nMesages ) { 
 + for ( Message m : nMessages ) { 
 if ( m . getSenderId ( ) ! = myUid ( ) ) { 
 ownReadActor ( ) . send ( new OwnReadActor . InMessage ( peer , m ) ) ; 
 } 
 @ @ - 107 , 6 + 110 , 13 @ @ public class MessagesProcessor extends AbsModule { 
 ApiMessage content ) { 
 
 Peer peer = convert ( _ peer ) ; 
 + 
 + if ( content instanceof ApiEncryptedMessage ) { 
 + / / TODO : Proper decrypt message 
 + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , 
 + date , senderUid , rid , ( ApiEncryptedMessage ) content ) ) ; 
 + } 
 + 
 AbsContent msgContent ; 
 try { 
 msgContent = AbsContent . fromMessage ( content ) ; 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 index 7ff7e50 . . e4aff27 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 @ @ - 22 , 7 + 22 , 7 @ @ public class ByteStrings { 
 } 
 
 public static byte [ ] intToBytes ( int v ) { 
 - byte [ ] data = new byte [ 8 ] ; 
 + byte [ ] data = new byte [ 4 ] ; 
 int offset = 0 ; 
 data [ offset + + ] = ( byte ) ( ( v > > 24 ) & 0xFF ) ; 
 data [ offset + + ] = ( byte ) ( ( v > > 16 ) & 0xFF ) ;
