BLEU SCORE: 0.2644967217413845

TEST MSG: feat ( core ) : Restored encryption of messages
GENERATED MSG: wip ( core ) : Working on decryption of ratchet messages

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index f0bbeec . . 0d37db8 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 4 , 22 + 4 , 16 @ @ import java . io . IOException ; < nl > import java . util . ArrayList ; < nl > import java . util . HashMap ; < nl > < nl > - import im . actor . core . api . ApiEncryptionKeyGroup ; < nl > import im . actor . core . api . ApiMessage ; < nl > - import im . actor . core . api . ApiUserOutPeer ; < nl > - import im . actor . core . api . rpc . RequestLoadPublicKeyGroups ; < nl > - import im . actor . core . api . rpc . ResponsePublicKeyGroups ; < nl > - import im . actor . core . entity . User ; < nl > import im . actor . core . modules . ModuleContext ; < nl > import im . actor . core . modules . encryption . entity . EncryptedBox ; < nl > import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; < nl > import im . actor . core . modules . encryption . entity . SessionId ; < nl > import im . actor . core . modules . encryption . entity . UserKeys ; < nl > import im . actor . core . modules . encryption . entity . UserKeysGroup ; < nl > - import im . actor . core . network . RpcCallback ; < nl > - import im . actor . core . network . RpcException ; < nl > import im . actor . core . util . Hex ; < nl > import im . actor . core . util . ModuleActor ; < nl > + import im . actor . core . util . RandomUtils ; < nl > import im . actor . runtime . Crypto ; < nl > import im . actor . runtime . Log ; < nl > import im . actor . runtime . actors . ActorCreator ; < nl > @ @ - 27 , 7 + 21 , 6 @ @ import im . actor . runtime . actors . ActorRef ; < nl > import im . actor . runtime . actors . Future ; < nl > import im . actor . runtime . actors . Props ; < nl > import im . actor . runtime . actors . ask . AskCallback ; < nl > - import im . actor . runtime . actors . ask . AskRequest ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . box . ActorBox ; < nl > import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > @ @ - 72 , 82 + 65 , 124 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > } ) ; < nl > } < nl > < nl > - / / private void onOwnGroupReady ( ) { < nl > - / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserKeyGroups ( uid ) , new AskCallback ( ) { < nl > - / / @ Override < nl > - / / public void onResult ( Object obj ) { < nl > - / / KeyManagerActor . FetchUserKeyGroupsResponse response = ( KeyManagerActor . FetchUserKeyGroupsResponse ) obj ; < nl > - / / userKeys = response . getUserKeys ( ) ; < nl > - / / onOwnKeysReady ( ) ; < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( Exception e ) { < nl > - / / Log . d ( TAG , " Unable to load key groups " ) ; < nl > - / / Log . e ( TAG , e ) ; < nl > - / / halt ( " Unable to load key groups " , e ) ; < nl > - / / } < nl > - / / } ) ; < nl > - / / } < nl > - / / < nl > - / / private void onOwnKeysReady ( ) { < nl > - / / Log . w ( TAG , " onOwnKeysReady " ) ; < nl > - / / < nl > - / / / / for ( final UserKeysGroup g : userKeys . getUserKeysGroups ( ) ) { < nl > - / / / / sessions . put ( g . getKeyGroupId ( ) , system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { < nl > - / / / / @ Override < nl > - / / / / public EncryptedSessionActor create ( ) { < nl > - / / / / return new EncryptedSessionActor ( context ( ) , uid , g ) ; < nl > - / / / / } < nl > - / / / / } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; < nl > - / / / / } < nl > - / / } < nl > - < nl > private void doEncrypt ( final byte [ ] data , final Future future ) { < nl > - / / Log . d ( TAG , " doEncrypt " ) ; < nl > - / / final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > - / / < nl > - / / final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > - / / for ( final Integer keyGroup : sessions . keySet ( ) ) { < nl > - / / ask ( sessions . get ( keyGroup ) , new EncryptedSessionActor . EncryptPackage ( encKey ) , new AskCallback ( ) { < nl > - / / @ Override < nl > - / / public void onResult ( Object obj ) { < nl > - / / EncryptedSessionActor . EncryptedPackageRes res = ( EncryptedSessionActor . EncryptedPackageRes ) obj ; < nl > - / / encryptedKeys . add ( new EncryptedBoxKey ( uid , keyGroup , res . getData ( ) ) ) ; < nl > - / / if ( encryptedKeys . size ( ) = = sessions . size ( ) ) { < nl > - / / doEncrypt ( encKey , data , encryptedKeys , future ) ; < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( Exception e ) { < nl > - / / future . onError ( e ) ; < nl > - / / } < nl > - / / } ) ; < nl > - / / } < nl > + < nl > + Log . d ( TAG , " doEncrypt " ) ; < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserKeyGroups ( uid ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + KeyManagerActor . FetchUserKeyGroupsResponse r = ( KeyManagerActor . FetchUserKeyGroupsResponse ) obj ; < nl > + UserKeysGroup [ ] keysGroups = r . getUserKeys ( ) . getUserKeysGroups ( ) ; < nl > + ArrayList < ActorRef > sessions = new ArrayList < ActorRef > ( ) ; < nl > + outer : < nl > + for ( final UserKeysGroup g : keysGroups ) { < nl > + < nl > + / / < nl > + / / Finding existing sessions < nl > + / / < nl > + for ( SessionId sessionId : activeSessions . keySet ( ) ) { < nl > + if ( sessionId . getTheirKeyGroupId ( ) = = g . getKeyGroupId ( ) ) { < nl > + sessions . add ( activeSessions . get ( sessionId ) ) ; < nl > + continue outer ; < nl > + } < nl > + } < nl > + < nl > + Log . d ( TAG , " doEncrypt : session not found for # " + g . getKeyGroupId ( ) ) ; < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKeyRandom ( uid , < nl > + g . getKeyGroupId ( ) ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + final KeyManagerActor . FetchUserEphemeralKeyResponse r = ( KeyManagerActor . FetchUserEphemeralKeyResponse ) obj ; < nl > + Log . d ( TAG , " doEncrypt : # " + g . getKeyGroupId ( ) + " Their key ok : " + r . getEphemeralKey ( ) . getKeyId ( ) ) ; < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnEphemeralKey ( ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + final KeyManagerActor . FetchOwnEphemeralKeyResult res = ( KeyManagerActor . FetchOwnEphemeralKeyResult ) obj ; < nl > + Log . d ( TAG , " doEncrypt : # " + g . getKeyGroupId ( ) + " Own key ok : " + res . getId ( ) ) ; < nl > + SessionId sessionId = new SessionId ( ownKeyGroupId , res . getId ( ) , < nl > + g . getKeyGroupId ( ) , r . getEphemeralKey ( ) . getKeyId ( ) ) ; < nl > + < nl > + activeSessions . put ( sessionId , system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { < nl > + @ Override < nl > + public EncryptedSessionActor create ( ) { < nl > + return new EncryptedSessionActor ( context ( ) , uid , < nl > + res . getId ( ) , r . getEphemeralKey ( ) . getKeyId ( ) , g . getKeyGroupId ( ) ) ; < nl > + } < nl > + } ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ) ; < nl > + < nl > + doEncrypt ( data , future ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . d ( TAG , " doEncrypt : # " + g . getKeyGroupId ( ) + " Own key error " ) ; < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . d ( TAG , " doEncrypt : # " + g . getKeyGroupId ( ) + " Their key error " ) ; < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + return ; < nl > + } < nl > + < nl > + Log . d ( TAG , " doEncrypt : all sessions created " ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + < nl > + < nl > + final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > + < nl > + final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > + for ( final SessionId sessionId : activeSessions . keySet ( ) ) { < nl > + ask ( activeSessions . get ( sessionId ) , new EncryptedSessionActor . EncryptPackage ( encKey ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + EncryptedSessionActor . EncryptedPackageRes res = ( EncryptedSessionActor . EncryptedPackageRes ) obj ; < nl > + encryptedKeys . add ( new EncryptedBoxKey ( uid , sessionId . getTheirKeyGroupId ( ) , res . getData ( ) ) ) ; < nl > + if ( encryptedKeys . size ( ) = = activeSessions . size ( ) ) { < nl > + doEncrypt ( encKey , data , encryptedKeys , future ) ; < nl > + } < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + } < nl > } < nl > < nl > private void doEncrypt ( byte [ ] encKey , byte [ ] data , ArrayList < EncryptedBoxKey > encryptedKeys , Future future ) { < nl > - / / Log . d ( TAG , " doEncrypt2 " ) ; < nl > - / / byte [ ] encData ; < nl > - / / try { < nl > - / / encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > - / / } catch ( IntegrityException e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - / / future . onError ( e ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / EncryptedBox encryptedBox = new EncryptedBox ( < nl > - / / encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > - / / ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > - / / < nl > - / / Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; < nl > - / / for ( EncryptedBoxKey k : encryptedKeys ) { < nl > - / / Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > - / / } < nl > - / / < nl > - / / future . onResult ( encryptedBox ) ; < nl > + Log . d ( TAG , " doEncrypt2 " ) ; < nl > + byte [ ] encData ; < nl > + try { < nl > + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > + } catch ( IntegrityException e ) { < nl > + e . printStackTrace ( ) ; < nl > + future . onError ( e ) ; < nl > + return ; < nl > + } < nl > + < nl > + EncryptedBox encryptedBox = new EncryptedBox ( < nl > + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > + < nl > + Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; < nl > + for ( EncryptedBoxKey k : encryptedKeys ) { < nl > + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + < nl > + future . onResult ( encryptedBox ) ; < nl > } < nl > < nl > private void doDecrypt ( final EncryptedBox data , final Future future ) { < nl > @ @ - 261 , 60 + 296 , 6 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > future . onError ( e ) ; < nl > } < nl > } ) ; < nl > - < nl > - / / if ( sessions . containsKey ( senderKeyGroup ) ) { < nl > - / / Log . d ( TAG , " Decryption with key group # " + senderKeyGroup ) ; < nl > - / / byte [ ] encKey = null ; < nl > - / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > - / / / / Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; < nl > - / / if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { < nl > - / / encKey = k . getEncryptedKey ( ) ; < nl > - / / break ; < nl > - / / } < nl > - / / } < nl > - / / if ( encKey = = null ) { < nl > - / / Log . d ( TAG , " Unable to find encryption key in key group " ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; < nl > - / / Log . d ( TAG , " EncKey : " + Hex . toHex ( encKey ) ) ; < nl > - / / / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > - / / / / Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > - / / / / } < nl > - / / < nl > - / / ask ( sessions . get ( senderKeyGroup ) , new EncryptedSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { < nl > - / / @ Override < nl > - / / public void onResult ( Object obj ) { < nl > - / / Log . d ( TAG , " Decryption with key group : onResult " ) ; < nl > - / / EncryptedSessionActor . DecryptedPackage decryptedPackage = ( EncryptedSessionActor . DecryptedPackage ) obj ; < nl > - / / < nl > - / / byte [ ] encData ; < nl > - / / try { < nl > - / / encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; < nl > - / / < nl > - / / ApiMessage message = ApiMessage . fromBytes ( encData ) ; < nl > - / / < nl > - / / Log . d ( TAG , " Box open : " + message ) ; < nl > - / / } catch ( IOException e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - / / future . onError ( e ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / future . onResult ( ) ; < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( Exception e ) { < nl > - / / Log . d ( TAG , " Decryption with key group : onError " ) ; < nl > - / / future . onError ( e ) ; < nl > - / / } < nl > - / / } ) ; < nl > - / / } else { < nl > - / / Log . w ( TAG , " Unable to find appropriate session # " + senderKeyGroup ) ; < nl > - / / future . onError ( new RuntimeException ( ) ) ; < nl > - / / } < nl > } < nl > < nl > @ Override < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index e08862e . . 542fd85 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 9 , 19 + 9 , 12 @ @ import im . actor . core . modules . encryption . entity . UserPublicKey ; < nl > import im . actor . core . modules . encryption . session . EncryptedSession ; < nl > import im . actor . core . modules . encryption . session . EncryptedSessionChain ; < nl > import im . actor . core . util . ModuleActor ; < nl > - import im . actor . core . util . RandomUtils ; < nl > import im . actor . runtime . * ; < nl > - import im . actor . runtime . actors . ActorCreator ; < nl > - import im . actor . runtime . actors . ActorRef ; < nl > import im . actor . runtime . actors . Future ; < nl > - import im . actor . runtime . actors . Props ; < nl > import im . actor . runtime . actors . ask . AskCallback ; < nl > import im . actor . runtime . crypto . Curve25519 ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; < nl > < nl > public class EncryptedSessionActor extends ModuleActor { < nl > < nl > @ @ - 138 , 6 + 131 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > } < nl > < nl > private void loadTheirKey0 ( ) { < nl > + Log . w ( TAG , " loadTheirKey0 " ) ; < nl > ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKey ( uid , theirKeyGroup , theirKey0 ) , new AskCallback ( ) { < nl > @ Override < nl > public void onResult ( Object obj ) { < nl > @ @ - 166 , 105 + 160 , 35 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > return ; < nl > } < nl > < nl > - / / if ( theirEphemeralKey = = null ) { < nl > - / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKeyRandom ( uid , theirKeyGroup ) , new AskCallback ( ) { < nl > - / / @ Override < nl > - / / public void onResult ( Object obj ) { < nl > - / / if ( theirEphemeralKey ! = null ) { < nl > - / / KeyManagerActor . FetchUserEphemeralKeyResponse response = ( KeyManagerActor . FetchUserEphemeralKeyResponse ) obj ; < nl > - / / theirEphemeralKey = response . getEphemeralKey ( ) . getPublicKey ( ) ; < nl > - / / } < nl > - / / onEncrypt ( data , future ) ; < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( Exception e ) { < nl > - / / future . onError ( e ) ; < nl > - / / } < nl > - / / } ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / if ( chains . size ( ) = = 0 ) { < nl > - / / spawnChain ( Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 32 ) ) ) ; < nl > - / / } < nl > - / / < nl > - / / chains . get ( 0 ) . getChain ( ) . send ( new EncryptedSessionChainActor . EncryptMessage ( data , < nl > - / / theirEphemeralKey , 0 ) ) ; < nl > - < nl > - / / if ( ! assumeEnabled ( new Runnable ( ) { < nl > - / / @ Override < nl > - / / public void run ( ) { < nl > - / / onEncrypt ( data , future ) ; < nl > - / / } < nl > - / / } ) ) { < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / onEncrypt ( data , < nl > - / / ownEphermalKey0 , < nl > - / / currentOwnKey , < nl > - / / theirEphermalKey0 , < nl > - / / currentTheirKey , < nl > - / / future ) ; < nl > - } < nl > + if ( theirEphemeralKey = = null ) { < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKeyRandom ( uid , theirKeyGroup ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + KeyManagerActor . FetchUserEphemeralKeyResponse response = ( KeyManagerActor . FetchUserEphemeralKeyResponse ) obj ; < nl > + if ( theirEphemeralKey = = null ) { < nl > + theirEphemeralKey = response . getEphemeralKey ( ) . getPublicKey ( ) ; < nl > + } < nl > + onEncrypt ( data , future ) ; < nl > + } < nl > < nl > - private void onEncrypt ( byte [ ] data , < nl > - OwnPrivateKey ownEphermalKey0 , < nl > - OwnPrivateKey ownEphermalKey , < nl > - UserPublicKey theirEphermalKey0 , < nl > - UserPublicKey theirEphermalKey , < nl > - Future future ) { < nl > - < nl > - / / Log . w ( TAG , " Encrypting with : OwnKey0 : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > - / / Log . w ( TAG , " Encrypting with : TheirKey0 : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > - / / < nl > - / / byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( < nl > - / / new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > - / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > - / / new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > - / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; < nl > - / / byte [ ] rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > - / / new RatchetPrivateKey ( ownEphermalKey . getKey ( ) ) , < nl > - / / new RatchetPublicKey ( theirEphermalKey . getPublicKey ( ) ) , < nl > - / / master _ secret ) ; < nl > - / / < nl > - / / int messageIndex = outIndex + + ; < nl > - / / < nl > - / / ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; < nl > - / / < nl > - / / Log . d ( TAG , " MS : " + Hex . toHex ( master _ secret ) ) ; < nl > - / / Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; < nl > - / / Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphermalKey0 . getKey ( ) ) ) ) ; < nl > - / / Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; < nl > - / / Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphermalKey . getPublicKey ( ) ) ) ; < nl > - / / Log . d ( TAG , " RC : " + Hex . toHex ( rootChainKey ) ) ; < nl > - / / Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) ) ) ; < nl > - / / Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphermalKey . getPublicKey ( ) ) ) ; < nl > - / / < nl > - / / Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; < nl > - / / Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; < nl > - / / Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; < nl > - / / Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; < nl > - / / < nl > - / / byte [ ] header = ByteStrings . merge ( < nl > - / / ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , < nl > - / / ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > - / / ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > - / / Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) , < nl > - / / theirEphermalKey . getPublicKey ( ) , < nl > - / / ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / < nl > - / / < nl > - / / byte [ ] encrypted ; < nl > - / / try { < nl > - / / encrypted = ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ; < nl > - / / } catch ( IntegrityException e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - / / future . onError ( e ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / future . onResult ( new EncryptedPackageRes ( ByteStrings . merge ( header , encrypted ) ) ) ; < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + return ; < nl > + } < nl > + < nl > + if ( chains . size ( ) = = 0 ) { < nl > + spawnChain ( Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 32 ) ) , theirEphemeralKey ) ; < nl > + } < nl > + < nl > + try { < nl > + future . onResult ( new EncryptedPackageRes ( chains . get ( 0 ) . encrypt ( data ) ) ) ; < nl > + } catch ( IntegrityException e ) { < nl > + e . printStackTrace ( ) ; < nl > + future . onError ( e ) ; < nl > + } < nl > } < nl > < nl > private void onDecrypt ( final byte [ ] data , final Future future ) { < nl > @ @ - 307 , 28 + 231 , 13 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > } < nl > < nl > try { < nl > - future . onResult ( new DecryptedPackage ( pickedChain . decrypt ( data ) ) ) ; < nl > + byte [ ] decrypted = pickedChain . decrypt ( data ) ; < nl > + theirEphemeralKey = senderEphemeralKey ; < nl > + future . onResult ( new DecryptedPackage ( decrypted ) ) ; < nl > } catch ( IntegrityException e ) { < nl > e . printStackTrace ( ) ; < nl > future . onError ( e ) ; < nl > } < nl > - < nl > - / / ask ( pickedChain . getChain ( ) , new EncryptedSessionChainActor . DecryptMessage ( < nl > - / / ByteStrings . substring ( data , 0 , 88 ) , < nl > - / / ByteStrings . substring ( data , 88 , data . length - 88 ) , < nl > - / / senderEphemeralKey , messageIndex ) , new AskCallback ( ) { < nl > - / / @ Override < nl > - / / public void onResult ( Object obj ) { < nl > - / / / / Updating ephemeral key < nl > - / / theirEphemeralKey = senderEphemeralKey ; < nl > - / / future . onResult ( ) ; < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( Exception e ) { < nl > - / / future . onError ( e ) ; < nl > - / / } < nl > - / / } ) ; < nl > } < nl > < nl > private EncryptedSessionChain spawnChain ( final byte [ ] privateKey , final byte [ ] publicKey ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java < nl > deleted file mode 100644 < nl > index abc6f07 . . 0000000 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java < nl > + + + / dev / null < nl > @ @ - 1 , 26 + 0 , 0 @ @ < nl > - package im . actor . core . modules . encryption ; < nl > - < nl > - public class KeyLocation { < nl > - < nl > - private int uid ; < nl > - private int keyGroup ; < nl > - private long keyId ; < nl > - < nl > - public KeyLocation ( int uid , int keyGroup , long keyId ) { < nl > - this . uid = uid ; < nl > - this . keyGroup = keyGroup ; < nl > - this . keyId = keyId ; < nl > - } < nl > - < nl > - public int getUid ( ) { < nl > - return uid ; < nl > - } < nl > - < nl > - public int getKeyGroup ( ) { < nl > - return keyGroup ; < nl > - } < nl > - < nl > - public long getKeyId ( ) { < nl > - return keyId ; < nl > - } < nl > - } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index 9eb0796 . . 44e8443 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 3 , 12 + 3 , 10 @ @ package im . actor . core . modules . encryption ; < nl > import java . io . IOException ; < nl > import java . util . ArrayList ; < nl > import java . util . HashMap ; < nl > - import java . util . List ; < nl > < nl > import im . actor . core . api . ApiEncryptionKey ; < nl > import im . actor . core . api . ApiEncryptionKeyGroup ; < nl > import im . actor . core . api . ApiEncryptionKeySignature ; < nl > - import im . actor . core . api . ApiEncryptionPublicKeyGroup ; < nl > import im . actor . core . api . ApiUserOutPeer ; < nl > import im . actor . core . api . rpc . RequestCreateNewKeyGroup ; < nl > import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; < nl > @ @ - 36 , 10 + 34 , 7 @ @ import im . actor . runtime . Log ; < nl > import im . actor . runtime . Storage ; < nl > import im . actor . runtime . actors . Future ; < nl > import im . actor . runtime . actors . ask . AskRequest ; < nl > - import im . actor . runtime . bser . BserWriter ; < nl > - import im . actor . runtime . bser . DataOutput ; < nl > import im . actor . runtime . crypto . Curve25519 ; < nl > - import im . actor . runtime . crypto . primitives . digest . SHA256 ; < nl > import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > import im . actor . runtime . crypto . ratchet . RatchetKeySignature ; < nl > import im . actor . runtime . storage . KeyValueStorage ; < nl > @ @ - 245 , 6 + 240 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > < nl > private void fetchEphemeralKey ( long keyId , Future future ) { < nl > + Log . d ( TAG , " fetchEphemeralKey : " + keyId ) ; < nl > for ( OwnPrivateKey k : ownKeys . getEphemeralKeys ( ) ) { < nl > if ( k . getKeyId ( ) = = keyId ) { < nl > future . onResult ( new FetchEphemeralPrivateKeyRes ( k . getKey ( ) ) ) ; < nl > @ @ - 254 , 6 + 250 , 13 @ @ public class KeyManagerActor extends ModuleActor { < nl > future . onError ( new RuntimeException ( " Unable to find ephemeral key " ) ) ; < nl > } < nl > < nl > + private void fetchOwnEphemeralKey ( Future future ) { < nl > + Log . d ( TAG , " fetchOwnEphemeralKey " ) ; < nl > + OwnPrivateKeyUploadable ownEphemeralKey = ownKeys . pickRandomEphemeralKey ( ) ; < nl > + future . onResult ( new FetchOwnEphemeralKeyResult ( ownEphemeralKey . getKeyId ( ) , < nl > + ownEphemeralKey . getKey ( ) ) ) ; < nl > + } < nl > + < nl > private void fetchUserGroups ( final int uid , final Future future ) { < nl > Log . d ( TAG , " fetchUserGroups " ) ; < nl > final UserKeys userKeys = getCachedUserKeys ( uid ) ; < nl > @ @ - 352 , 27 + 355 , 6 @ @ public class KeyManagerActor extends ModuleActor { < nl > future . onError ( e ) ; < nl > } < nl > } ) ; < nl > - < nl > - / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > - / / @ Override < nl > - / / public void onResult ( ResponsePublicKeys response ) { < nl > - / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > - / / Log . w ( TAG , " No ephemeral keys found " ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > - / / theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; < nl > - / / onTheirReady0 ( ) ; < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( RpcException e ) { < nl > - / / / / Nothing to do < nl > - / / Log . w ( TAG , " Their ephemeral error " ) ; < nl > - / / Log . e ( TAG , e ) ; < nl > - / / } < nl > - / / } ) ; < nl > } < nl > < nl > private void fetchUserEphemeralKey ( final int uid , int keyGroupId , final Future future ) { < nl > @ @ - 389 , 10 + 371 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > / / TODO : Verify signature < nl > < nl > UserPublicKey pkey = new UserPublicKey ( key . getKeyId ( ) , key . getKeyAlg ( ) , key . getKeyMaterial ( ) ) ; < nl > - / / UserKeysGroup userKeysGroup = finalKeysGroup . addUserKeyGroup ( pkey ) ; < nl > - / / cacheUserKeys ( keys . removeUserKeyGroup ( userKeysGroup . getKeyGroupId ( ) ) < nl > - / / . addUserKeyGroup ( userKeysGroup ) ) ; < nl > - < nl > + / / Do not store all ephemeral key as it is not required < nl > future . onResult ( new FetchUserEphemeralKeyResponse ( pkey ) ) ; < nl > } < nl > < nl > @ @ - 547 , 6 + 526 , 9 @ @ public class KeyManagerActor extends ModuleActor { < nl > } else if ( message instanceof FetchUserEphemeralKeyRandom ) { < nl > fetchUserEphemeralKey ( ( ( FetchUserEphemeralKeyRandom ) message ) . getUid ( ) , ( ( FetchUserEphemeralKeyRandom ) message ) . getKeyGroup ( ) , future ) ; < nl > return false ; < nl > + } else if ( message instanceof FetchOwnEphemeralKey ) { < nl > + fetchOwnEphemeralKey ( future ) ; < nl > + return false ; < nl > } < nl > return super . onAsk ( message , future ) ; < nl > } < nl > @ @ - 568 , 6 + 550 , 29 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > } < nl > < nl > + public static class FetchOwnEphemeralKey { < nl > + < nl > + } < nl > + < nl > + public static class FetchOwnEphemeralKeyResult { < nl > + < nl > + private long id ; < nl > + private byte [ ] privateKey ; < nl > + < nl > + public FetchOwnEphemeralKeyResult ( long id , byte [ ] privateKey ) { < nl > + this . id = id ; < nl > + this . privateKey = privateKey ; < nl > + } < nl > + < nl > + public long getId ( ) { < nl > + return id ; < nl > + } < nl > + < nl > + public byte [ ] getPrivateKey ( ) { < nl > + return privateKey ; < nl > + } < nl > + } < nl > + < nl > public static class FetchOwnKeyGroup { < nl > < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > index a7167eb . . d625a3d 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > @ @ - 2 , 6 + 2 , 9 @ @ package im . actor . core . modules . encryption . session ; < nl > < nl > import java . util . HashSet ; < nl > < nl > + import im . actor . runtime . Crypto ; < nl > + import im . actor . runtime . Log ; < nl > + import im . actor . runtime . crypto . Curve25519 ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . box . ActorBox ; < nl > import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > @ @ - 90 , 4 + 93 , 22 @ @ public class EncryptedSessionChain { < nl > byte [ ] message = ByteStrings . substring ( data , 88 , data . length - 88 ) ; < nl > return ActorBox . openBox ( header , message , ratchetMessageKey ) ; < nl > } < nl > - } < nl > + < nl > + public byte [ ] encrypt ( byte [ ] data ) throws IntegrityException { < nl > + int messageIndex = sentCounter + + ; < nl > + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; < nl > + < nl > + byte [ ] header = ByteStrings . merge ( < nl > + ByteStrings . intToBytes ( session . getPeerKeyGroupId ( ) ) , < nl > + ByteStrings . longToBytes ( session . getOwnPreKey ( ) . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > + ByteStrings . longToBytes ( session . getTheirPreKey ( ) . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > + Curve25519 . keyGenPublic ( ownPrivateKey ) , < nl > + theirPublicKey , < nl > + ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / < nl > + < nl > + Log . d ( " EncryptedSessionChain " , " Own Pre Key : " + session . getOwnPreKey ( ) . getKeyId ( ) ) ; < nl > + Log . d ( " EncryptedSessionChain " , " Their Pre Key : " + session . getTheirPreKey ( ) . getKeyId ( ) ) ; < nl > + < nl > + return ByteStrings . merge ( header , ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ) ; < nl > + } < nl > + } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj < nl > index 2f54661 . . c33368d 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj < nl > @ @ - 1550 , 7 + 1550 , 7 @ @ < nl > 	 	 	 	 TargetAttributes = { < nl > 	 	 	 	 	 066A50D11BC4AE63000E606E = { < nl > 	 	 	 	 	 	 CreatedOnToolsVersion = 7 . 0 ; < nl > - 	 	 	 	 	 	 DevelopmentTeam = PR6635TQQ3 ; < nl > + 	 	 	 	 	 	 DevelopmentTeam = HVJR44Y5B6 ; < nl > 	 	 	 	 	 } ; < nl > 	 	 	 	 } ; < nl > 	 	 	 } ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 2d72521 . . 37809ce 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . core . modules . encryption . entity . EncryptedBox ; < nl > import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; < nl > import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > + import im . actor . core . util . Hex ; < nl > import im . actor . core . util . ModuleActor ; < nl > import im . actor . runtime . Crypto ; < nl > import im . actor . runtime . Log ; < nl > @ @ - 25 , 6 + 26 , 7 @ @ import im . actor . runtime . actors . ask . AskRequest ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . box . ActorBox ; < nl > import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > + import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > < nl > public class EncryptedPeerActor extends ModuleActor { < nl > < nl > @ @ - 34 , 6 + 36 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > private ArrayList < ApiEncryptionKeyGroup > keyGroups ; < nl > private HashMap < Integer , ActorRef > sessions = new HashMap < Integer , ActorRef > ( ) ; < nl > private boolean isReady = false ; < nl > + private int ownKeyGroupId ; < nl > < nl > public EncryptedPeerActor ( int uid , ModuleContext context ) { < nl > super ( context ) ; < nl > @ @ - 78 , 14 + 81 , 29 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > } < nl > } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; < nl > } < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKeyGroup ( ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + KeyManagerActor . FetchOwnKeyGroupResult res = ( KeyManagerActor . FetchOwnKeyGroupResult ) obj ; < nl > + ownKeyGroupId = res . getKeyGroupId ( ) ; < nl > + onOwnKeysReady ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + / / Do nothing < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > + private void onOwnKeysReady ( ) { < nl > + Log . w ( TAG , " onOwnKeysReady " ) ; < nl > isReady = true ; < nl > unstashAll ( ) ; < nl > } < nl > < nl > private void doEncrypt ( final byte [ ] data , final Future future ) { < nl > - < nl > Log . d ( TAG , " doEncrypt " ) ; < nl > - < nl > final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > < nl > final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > @ @ - 112 , 19 + 130 , 61 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > Log . d ( TAG , " doEncrypt2 " ) ; < nl > byte [ ] encData ; < nl > try { < nl > - encData = ActorBox . closeBox ( new byte [ 0 ] , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > } catch ( IntegrityException e ) { < nl > e . printStackTrace ( ) ; < nl > future . onError ( e ) ; < nl > return ; < nl > } < nl > < nl > - EncryptedBox encryptedBox = new EncryptedBox ( encryptedKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , encData ) ; < nl > + EncryptedBox encryptedBox = new EncryptedBox ( < nl > + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > + < nl > + Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; < nl > + for ( EncryptedBoxKey k : encryptedKeys ) { < nl > + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + < nl > future . onResult ( encryptedBox ) ; < nl > } < nl > < nl > - private void doDecrypt ( EncryptedBox data , Future future ) { < nl > + private void doDecrypt ( EncryptedBox data , final Future future ) { < nl > + int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; < nl > + byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; < nl > + < nl > + if ( sessions . containsKey ( senderKeyGroup ) ) { < nl > + Log . d ( TAG , " Decryption with key group " ) ; < nl > + byte [ ] encKey = null ; < nl > + for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > + if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { < nl > + encKey = k . getEncryptedKey ( ) ; < nl > + break ; < nl > + } < nl > + } < nl > + < nl > + Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; < nl > + for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + < nl > + ask ( sessions . get ( senderKeyGroup ) , new EncryptionSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " Decryption with key group : onResult " ) ; < nl > + future . onResult ( ) ; < nl > + } < nl > < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . d ( TAG , " Decryption with key group : onError " ) ; < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + } else { < nl > + Log . w ( TAG , " Unable to find appropriate session # " + senderKeyGroup ) ; < nl > + future . onError ( new RuntimeException ( ) ) ; < nl > + } < nl > } < nl > < nl > @ Override < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > index 7f57506 . . 5d65dd8 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > @ @ - 8 , 9 + 8 , 11 @ @ import im . actor . core . api . ApiUserOutPeer ; < nl > import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; < nl > import im . actor . core . api . rpc . ResponsePublicKeys ; < nl > import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; < nl > import im . actor . core . modules . encryption . entity . EncryptionKey ; < nl > import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > + import im . actor . core . util . Hex ; < nl > import im . actor . core . util . ModuleActor ; < nl > import im . actor . core . util . RandomUtils ; < nl > import im . actor . runtime . Crypto ; < nl > @ @ - 101 , 7 + 103 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > return ; < nl > } < nl > < nl > - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( 0 ) ; < nl > + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; < nl > onTheirReady0 ( ) ; < nl > } < nl > @ @ - 169 , 6 + 171 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; < nl > < nl > byte [ ] header = ByteStrings . merge ( < nl > + ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , < nl > ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > currentOwnKey . getPublicKey ( ) , < nl > @ @ - 186 , 9 + 189 , 46 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > < nl > byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; < nl > < nl > + < nl > + int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; < nl > + long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; < nl > + long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; < nl > + byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; < nl > + byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; < nl > + int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; < nl > + < nl > + Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; < nl > + Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; < nl > + < nl > + < nl > + Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; < nl > + Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; < nl > + < nl > future . onResult ( new EncryptedPackageRes ( pkg ) ) ; < nl > } < nl > < nl > + private void onDecrypt ( byte [ ] data , Future future ) { < nl > + int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > + long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > + long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > + byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > + byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > + int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > + < nl > + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > + Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; < nl > + Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; < nl > + < nl > + / / future . onResult ( ) ; < nl > + } < nl > + < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > if ( ! isReady & & message instanceof AskRequest ) { < nl > @ @ - 203 , 6 + 243 , 10 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > if ( message instanceof EncryptPackage ) { < nl > onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; < nl > return false ; < nl > + } else if ( message instanceof DecryptPackage ) { < nl > + DecryptPackage decryptPackage = ( DecryptPackage ) message ; < nl > + onDecrypt ( decryptPackage . getData ( ) , future ) ; < nl > + return false ; < nl > } else { < nl > return super . onAsk ( message , future ) ; < nl > } < nl > @ @ - 232 , 4 + 276 , 17 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > return data ; < nl > } < nl > } < nl > + < nl > + public static class DecryptPackage { < nl > + < nl > + private byte [ ] data ; < nl > + < nl > + public DecryptPackage ( byte [ ] data ) { < nl > + this . data = data ; < nl > + } < nl > + < nl > + public byte [ ] getData ( ) { < nl > + return data ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index f4eb042 . . 58c2383 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 230 , 6 + 230 , 10 @ @ public class KeyManagerActor extends ModuleActor { < nl > future . onResult ( new FetchOwnKeyResult ( privateKeyStorage . getIdentityKey ( ) , ephemeralEncryptionKey . getEncryptionKey ( ) ) ) ; < nl > } < nl > < nl > + private void fetchKeyGroup ( Future future ) { < nl > + future . onResult ( new FetchOwnKeyGroupResult ( privateKeyStorage . getKeyGroupId ( ) ) ) ; < nl > + } < nl > + < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > if ( message instanceof AskRequest & & ! isReady ) { < nl > @ @ - 244 , 6 + 248 , 9 @ @ public class KeyManagerActor extends ModuleActor { < nl > if ( message instanceof FetchOwnKey ) { < nl > fetchOwnKey ( future ) ; < nl > return false ; < nl > + } else if ( message instanceof FetchOwnKeyGroup ) { < nl > + fetchKeyGroup ( future ) ; < nl > + return false ; < nl > } < nl > return super . onAsk ( message , future ) ; < nl > } < nl > @ @ - 270 , 4 + 277 , 20 @ @ public class KeyManagerActor extends ModuleActor { < nl > return ephemeralKey ; < nl > } < nl > } < nl > + < nl > + public static class FetchOwnKeyGroup { < nl > + < nl > + } < nl > + < nl > + public static class FetchOwnKeyGroupResult { < nl > + private int keyGroupId ; < nl > + < nl > + public FetchOwnKeyGroupResult ( int keyGroupId ) { < nl > + this . keyGroupId = keyGroupId ; < nl > + } < nl > + < nl > + public int getKeyGroupId ( ) { < nl > + return keyGroupId ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java < nl > index 815d4ba . . 6d0d54d 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java < nl > @ @ - 48 , 6 + 48 , 29 @ @ public class MessageEncryptionActor extends ModuleActor { < nl > } ) ; < nl > } < nl > < nl > + public void onDecrypt ( int uid , ApiEncryptedMessage message ) { < nl > + Log . d ( TAG , " onDecrypt : " + uid ) ; < nl > + ArrayList < EncryptedBoxKey > encryptedBoxKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > + for ( ApiEncyptedBoxKey key : message . getBox ( ) . getKeys ( ) ) { < nl > + if ( key . getUsersId ( ) = = myUid ( ) ) { < nl > + encryptedBoxKeys . add ( new EncryptedBoxKey ( key . getUsersId ( ) , key . getKeyGroupId ( ) , < nl > + key . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + } < nl > + EncryptedBox encryptedBox = new EncryptedBox ( encryptedBoxKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , message . getBox ( ) . getEncPackage ( ) ) ; < nl > + ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . DecryptPackage ( encryptedBox ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " onDecrypt : onResult " ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . d ( TAG , " onDecrypt : onError " ) ; < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > @ Override < nl > public boolean onAsk ( Object message , Future future ) { < nl > if ( message instanceof EncryptMessage ) { < nl > @ @ - 58 , 6 + 81 , 16 @ @ public class MessageEncryptionActor extends ModuleActor { < nl > return super . onAsk ( message , future ) ; < nl > } < nl > < nl > + @ Override < nl > + public void onReceive ( Object message ) { < nl > + if ( message instanceof InMessage ) { < nl > + InMessage inMessage = ( InMessage ) message ; < nl > + onDecrypt ( inMessage . senderUid , inMessage . encryptedMessage ) ; < nl > + } else { < nl > + super . onReceive ( message ) ; < nl > + } < nl > + } < nl > + < nl > public static class InMessage { < nl > < nl > private Peer peer ; < nl > @ @ - 105 , 4 + 138 , 17 @ @ public class MessageEncryptionActor extends ModuleActor { < nl > return encryptedMessage ; < nl > } < nl > } < nl > + < nl > + public static class DecryptMessage { < nl > + < nl > + private ApiEncryptedMessage encryptedMessage ; < nl > + < nl > + public DecryptMessage ( ApiEncryptedMessage encryptedMessage ) { < nl > + this . encryptedMessage = encryptedMessage ; < nl > + } < nl > + < nl > + public ApiEncryptedMessage getEncryptedMessage ( ) { < nl > + return encryptedMessage ; < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java < nl > index 9da4c36 . . 8a8877a 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java < nl > @ @ - 27 , 6 + 27 , 7 @ @ import im . actor . core . entity . content . AbsContent ; < nl > import im . actor . core . entity . content . ServiceUserRegistered ; < nl > import im . actor . core . modules . AbsModule ; < nl > import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . encryption . MessageEncryptionActor ; < nl > import im . actor . core . modules . internal . messages . ConversationActor ; < nl > import im . actor . core . modules . internal . messages . ConversationHistoryActor ; < nl > import im . actor . core . modules . internal . messages . CursorReceiverActor ; < nl > @ @ - 53 , 11 + 54 , 13 @ @ public class MessagesProcessor extends AbsModule { < nl > long intMessageSortDate = 0 ; < nl > Peer peer = convert ( _ peer ) ; < nl > < nl > - ArrayList < Message > nMesages = new ArrayList < Message > ( ) ; < nl > + ArrayList < Message > nMessages = new ArrayList < Message > ( ) ; < nl > for ( UpdateMessage u : messages ) { < nl > < nl > if ( u . getMessage ( ) instanceof ApiEncryptedMessage ) { < nl > - / / TODO : Decrypt message < nl > + / / TODO : Proper decrypt message < nl > + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , < nl > + u . getDate ( ) , u . getSenderUid ( ) , u . getRid ( ) , ( ApiEncryptedMessage ) u . getMessage ( ) ) ) ; < nl > continue ; < nl > } < nl > < nl > @ @ - 72 , 7 + 75 , 7 @ @ public class MessagesProcessor extends AbsModule { < nl > boolean isOut = myUid ( ) = = u . getSenderUid ( ) ; < nl > < nl > / / Sending message to conversation < nl > - nMesages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , < nl > + nMessages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , < nl > isOut ? MessageState . SENT : MessageState . UNKNOWN , msgContent , < nl > new ArrayList < Reaction > ( ) ) ) ; < nl > < nl > @ @ - 84 , 7 + 87 , 7 @ @ public class MessagesProcessor extends AbsModule { < nl > } < nl > } < nl > < nl > - conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMesages ) ) ; < nl > + conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMessages ) ) ; < nl > < nl > if ( intMessageSortDate > 0 ) { < nl > plainReceiveActor ( ) . send ( new CursorReceiverActor . MarkReceived ( peer , intMessageSortDate ) ) ; < nl > @ @ - 95 , 7 + 98 , 7 @ @ public class MessagesProcessor extends AbsModule { < nl > } < nl > < nl > / / OwnReadActor < nl > - for ( Message m : nMesages ) { < nl > + for ( Message m : nMessages ) { < nl > if ( m . getSenderId ( ) ! = myUid ( ) ) { < nl > ownReadActor ( ) . send ( new OwnReadActor . InMessage ( peer , m ) ) ; < nl > } < nl > @ @ - 107 , 6 + 110 , 13 @ @ public class MessagesProcessor extends AbsModule { < nl > ApiMessage content ) { < nl > < nl > Peer peer = convert ( _ peer ) ; < nl > + < nl > + if ( content instanceof ApiEncryptedMessage ) { < nl > + / / TODO : Proper decrypt message < nl > + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , < nl > + date , senderUid , rid , ( ApiEncryptedMessage ) content ) ) ; < nl > + } < nl > + < nl > AbsContent msgContent ; < nl > try { < nl > msgContent = AbsContent . fromMessage ( content ) ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > index 7ff7e50 . . e4aff27 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > @ @ - 22 , 7 + 22 , 7 @ @ public class ByteStrings { < nl > } < nl > < nl > public static byte [ ] intToBytes ( int v ) { < nl > - byte [ ] data = new byte [ 8 ] ; < nl > + byte [ ] data = new byte [ 4 ] ; < nl > int offset = 0 ; < nl > data [ offset + + ] = ( byte ) ( ( v > > 24 ) & 0xFF ) ; < nl > data [ offset + + ] = ( byte ) ( ( v > > 16 ) & 0xFF ) ;

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index f0bbeec . . 0d37db8 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 4 , 22 + 4 , 16 @ @ import java . io . IOException ; 
 import java . util . ArrayList ; 
 import java . util . HashMap ; 
 
 - import im . actor . core . api . ApiEncryptionKeyGroup ; 
 import im . actor . core . api . ApiMessage ; 
 - import im . actor . core . api . ApiUserOutPeer ; 
 - import im . actor . core . api . rpc . RequestLoadPublicKeyGroups ; 
 - import im . actor . core . api . rpc . ResponsePublicKeyGroups ; 
 - import im . actor . core . entity . User ; 
 import im . actor . core . modules . ModuleContext ; 
 import im . actor . core . modules . encryption . entity . EncryptedBox ; 
 import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; 
 import im . actor . core . modules . encryption . entity . SessionId ; 
 import im . actor . core . modules . encryption . entity . UserKeys ; 
 import im . actor . core . modules . encryption . entity . UserKeysGroup ; 
 - import im . actor . core . network . RpcCallback ; 
 - import im . actor . core . network . RpcException ; 
 import im . actor . core . util . Hex ; 
 import im . actor . core . util . ModuleActor ; 
 + import im . actor . core . util . RandomUtils ; 
 import im . actor . runtime . Crypto ; 
 import im . actor . runtime . Log ; 
 import im . actor . runtime . actors . ActorCreator ; 
 @ @ - 27 , 7 + 21 , 6 @ @ import im . actor . runtime . actors . ActorRef ; 
 import im . actor . runtime . actors . Future ; 
 import im . actor . runtime . actors . Props ; 
 import im . actor . runtime . actors . ask . AskCallback ; 
 - import im . actor . runtime . actors . ask . AskRequest ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . box . ActorBox ; 
 import im . actor . runtime . crypto . box . ActorBoxKey ; 
 @ @ - 72 , 82 + 65 , 124 @ @ public class EncryptedPeerActor extends ModuleActor { 
 } ) ; 
 } 
 
 - / / private void onOwnGroupReady ( ) { 
 - / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserKeyGroups ( uid ) , new AskCallback ( ) { 
 - / / @ Override 
 - / / public void onResult ( Object obj ) { 
 - / / KeyManagerActor . FetchUserKeyGroupsResponse response = ( KeyManagerActor . FetchUserKeyGroupsResponse ) obj ; 
 - / / userKeys = response . getUserKeys ( ) ; 
 - / / onOwnKeysReady ( ) ; 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( Exception e ) { 
 - / / Log . d ( TAG , " Unable to load key groups " ) ; 
 - / / Log . e ( TAG , e ) ; 
 - / / halt ( " Unable to load key groups " , e ) ; 
 - / / } 
 - / / } ) ; 
 - / / } 
 - / / 
 - / / private void onOwnKeysReady ( ) { 
 - / / Log . w ( TAG , " onOwnKeysReady " ) ; 
 - / / 
 - / / / / for ( final UserKeysGroup g : userKeys . getUserKeysGroups ( ) ) { 
 - / / / / sessions . put ( g . getKeyGroupId ( ) , system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { 
 - / / / / @ Override 
 - / / / / public EncryptedSessionActor create ( ) { 
 - / / / / return new EncryptedSessionActor ( context ( ) , uid , g ) ; 
 - / / / / } 
 - / / / / } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; 
 - / / / / } 
 - / / } 
 - 
 private void doEncrypt ( final byte [ ] data , final Future future ) { 
 - / / Log . d ( TAG , " doEncrypt " ) ; 
 - / / final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 - / / 
 - / / final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 - / / for ( final Integer keyGroup : sessions . keySet ( ) ) { 
 - / / ask ( sessions . get ( keyGroup ) , new EncryptedSessionActor . EncryptPackage ( encKey ) , new AskCallback ( ) { 
 - / / @ Override 
 - / / public void onResult ( Object obj ) { 
 - / / EncryptedSessionActor . EncryptedPackageRes res = ( EncryptedSessionActor . EncryptedPackageRes ) obj ; 
 - / / encryptedKeys . add ( new EncryptedBoxKey ( uid , keyGroup , res . getData ( ) ) ) ; 
 - / / if ( encryptedKeys . size ( ) = = sessions . size ( ) ) { 
 - / / doEncrypt ( encKey , data , encryptedKeys , future ) ; 
 - / / } 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( Exception e ) { 
 - / / future . onError ( e ) ; 
 - / / } 
 - / / } ) ; 
 - / / } 
 + 
 + Log . d ( TAG , " doEncrypt " ) ; 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserKeyGroups ( uid ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + KeyManagerActor . FetchUserKeyGroupsResponse r = ( KeyManagerActor . FetchUserKeyGroupsResponse ) obj ; 
 + UserKeysGroup [ ] keysGroups = r . getUserKeys ( ) . getUserKeysGroups ( ) ; 
 + ArrayList < ActorRef > sessions = new ArrayList < ActorRef > ( ) ; 
 + outer : 
 + for ( final UserKeysGroup g : keysGroups ) { 
 + 
 + / / 
 + / / Finding existing sessions 
 + / / 
 + for ( SessionId sessionId : activeSessions . keySet ( ) ) { 
 + if ( sessionId . getTheirKeyGroupId ( ) = = g . getKeyGroupId ( ) ) { 
 + sessions . add ( activeSessions . get ( sessionId ) ) ; 
 + continue outer ; 
 + } 
 + } 
 + 
 + Log . d ( TAG , " doEncrypt : session not found for # " + g . getKeyGroupId ( ) ) ; 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKeyRandom ( uid , 
 + g . getKeyGroupId ( ) ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + final KeyManagerActor . FetchUserEphemeralKeyResponse r = ( KeyManagerActor . FetchUserEphemeralKeyResponse ) obj ; 
 + Log . d ( TAG , " doEncrypt : # " + g . getKeyGroupId ( ) + " Their key ok : " + r . getEphemeralKey ( ) . getKeyId ( ) ) ; 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnEphemeralKey ( ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + final KeyManagerActor . FetchOwnEphemeralKeyResult res = ( KeyManagerActor . FetchOwnEphemeralKeyResult ) obj ; 
 + Log . d ( TAG , " doEncrypt : # " + g . getKeyGroupId ( ) + " Own key ok : " + res . getId ( ) ) ; 
 + SessionId sessionId = new SessionId ( ownKeyGroupId , res . getId ( ) , 
 + g . getKeyGroupId ( ) , r . getEphemeralKey ( ) . getKeyId ( ) ) ; 
 + 
 + activeSessions . put ( sessionId , system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { 
 + @ Override 
 + public EncryptedSessionActor create ( ) { 
 + return new EncryptedSessionActor ( context ( ) , uid , 
 + res . getId ( ) , r . getEphemeralKey ( ) . getKeyId ( ) , g . getKeyGroupId ( ) ) ; 
 + } 
 + } ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ) ; 
 + 
 + doEncrypt ( data , future ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . d ( TAG , " doEncrypt : # " + g . getKeyGroupId ( ) + " Own key error " ) ; 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . d ( TAG , " doEncrypt : # " + g . getKeyGroupId ( ) + " Their key error " ) ; 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + return ; 
 + } 
 + 
 + Log . d ( TAG , " doEncrypt : all sessions created " ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + 
 + 
 + final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 + 
 + final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 + for ( final SessionId sessionId : activeSessions . keySet ( ) ) { 
 + ask ( activeSessions . get ( sessionId ) , new EncryptedSessionActor . EncryptPackage ( encKey ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + EncryptedSessionActor . EncryptedPackageRes res = ( EncryptedSessionActor . EncryptedPackageRes ) obj ; 
 + encryptedKeys . add ( new EncryptedBoxKey ( uid , sessionId . getTheirKeyGroupId ( ) , res . getData ( ) ) ) ; 
 + if ( encryptedKeys . size ( ) = = activeSessions . size ( ) ) { 
 + doEncrypt ( encKey , data , encryptedKeys , future ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + } 
 } 
 
 private void doEncrypt ( byte [ ] encKey , byte [ ] data , ArrayList < EncryptedBoxKey > encryptedKeys , Future future ) { 
 - / / Log . d ( TAG , " doEncrypt2 " ) ; 
 - / / byte [ ] encData ; 
 - / / try { 
 - / / encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 - / / } catch ( IntegrityException e ) { 
 - / / e . printStackTrace ( ) ; 
 - / / future . onError ( e ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / EncryptedBox encryptedBox = new EncryptedBox ( 
 - / / encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 - / / ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 - / / 
 - / / Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; 
 - / / for ( EncryptedBoxKey k : encryptedKeys ) { 
 - / / Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 - / / } 
 - / / 
 - / / future . onResult ( encryptedBox ) ; 
 + Log . d ( TAG , " doEncrypt2 " ) ; 
 + byte [ ] encData ; 
 + try { 
 + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 + } catch ( IntegrityException e ) { 
 + e . printStackTrace ( ) ; 
 + future . onError ( e ) ; 
 + return ; 
 + } 
 + 
 + EncryptedBox encryptedBox = new EncryptedBox ( 
 + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 + 
 + Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; 
 + for ( EncryptedBoxKey k : encryptedKeys ) { 
 + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 + } 
 + 
 + future . onResult ( encryptedBox ) ; 
 } 
 
 private void doDecrypt ( final EncryptedBox data , final Future future ) { 
 @ @ - 261 , 60 + 296 , 6 @ @ public class EncryptedPeerActor extends ModuleActor { 
 future . onError ( e ) ; 
 } 
 } ) ; 
 - 
 - / / if ( sessions . containsKey ( senderKeyGroup ) ) { 
 - / / Log . d ( TAG , " Decryption with key group # " + senderKeyGroup ) ; 
 - / / byte [ ] encKey = null ; 
 - / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 - / / / / Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; 
 - / / if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { 
 - / / encKey = k . getEncryptedKey ( ) ; 
 - / / break ; 
 - / / } 
 - / / } 
 - / / if ( encKey = = null ) { 
 - / / Log . d ( TAG , " Unable to find encryption key in key group " ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; 
 - / / Log . d ( TAG , " EncKey : " + Hex . toHex ( encKey ) ) ; 
 - / / / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 - / / / / Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 - / / / / } 
 - / / 
 - / / ask ( sessions . get ( senderKeyGroup ) , new EncryptedSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { 
 - / / @ Override 
 - / / public void onResult ( Object obj ) { 
 - / / Log . d ( TAG , " Decryption with key group : onResult " ) ; 
 - / / EncryptedSessionActor . DecryptedPackage decryptedPackage = ( EncryptedSessionActor . DecryptedPackage ) obj ; 
 - / / 
 - / / byte [ ] encData ; 
 - / / try { 
 - / / encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; 
 - / / 
 - / / ApiMessage message = ApiMessage . fromBytes ( encData ) ; 
 - / / 
 - / / Log . d ( TAG , " Box open : " + message ) ; 
 - / / } catch ( IOException e ) { 
 - / / e . printStackTrace ( ) ; 
 - / / future . onError ( e ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / future . onResult ( ) ; 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( Exception e ) { 
 - / / Log . d ( TAG , " Decryption with key group : onError " ) ; 
 - / / future . onError ( e ) ; 
 - / / } 
 - / / } ) ; 
 - / / } else { 
 - / / Log . w ( TAG , " Unable to find appropriate session # " + senderKeyGroup ) ; 
 - / / future . onError ( new RuntimeException ( ) ) ; 
 - / / } 
 } 
 
 @ Override 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index e08862e . . 542fd85 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 9 , 19 + 9 , 12 @ @ import im . actor . core . modules . encryption . entity . UserPublicKey ; 
 import im . actor . core . modules . encryption . session . EncryptedSession ; 
 import im . actor . core . modules . encryption . session . EncryptedSessionChain ; 
 import im . actor . core . util . ModuleActor ; 
 - import im . actor . core . util . RandomUtils ; 
 import im . actor . runtime . * ; 
 - import im . actor . runtime . actors . ActorCreator ; 
 - import im . actor . runtime . actors . ActorRef ; 
 import im . actor . runtime . actors . Future ; 
 - import im . actor . runtime . actors . Props ; 
 import im . actor . runtime . actors . ask . AskCallback ; 
 import im . actor . runtime . crypto . Curve25519 ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 - import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; 
 - import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; 
 - import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; 
 
 public class EncryptedSessionActor extends ModuleActor { 
 
 @ @ - 138 , 6 + 131 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 } 
 
 private void loadTheirKey0 ( ) { 
 + Log . w ( TAG , " loadTheirKey0 " ) ; 
 ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKey ( uid , theirKeyGroup , theirKey0 ) , new AskCallback ( ) { 
 @ Override 
 public void onResult ( Object obj ) { 
 @ @ - 166 , 105 + 160 , 35 @ @ public class EncryptedSessionActor extends ModuleActor { 
 return ; 
 } 
 
 - / / if ( theirEphemeralKey = = null ) { 
 - / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKeyRandom ( uid , theirKeyGroup ) , new AskCallback ( ) { 
 - / / @ Override 
 - / / public void onResult ( Object obj ) { 
 - / / if ( theirEphemeralKey ! = null ) { 
 - / / KeyManagerActor . FetchUserEphemeralKeyResponse response = ( KeyManagerActor . FetchUserEphemeralKeyResponse ) obj ; 
 - / / theirEphemeralKey = response . getEphemeralKey ( ) . getPublicKey ( ) ; 
 - / / } 
 - / / onEncrypt ( data , future ) ; 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( Exception e ) { 
 - / / future . onError ( e ) ; 
 - / / } 
 - / / } ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / if ( chains . size ( ) = = 0 ) { 
 - / / spawnChain ( Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 32 ) ) ) ; 
 - / / } 
 - / / 
 - / / chains . get ( 0 ) . getChain ( ) . send ( new EncryptedSessionChainActor . EncryptMessage ( data , 
 - / / theirEphemeralKey , 0 ) ) ; 
 - 
 - / / if ( ! assumeEnabled ( new Runnable ( ) { 
 - / / @ Override 
 - / / public void run ( ) { 
 - / / onEncrypt ( data , future ) ; 
 - / / } 
 - / / } ) ) { 
 - / / return ; 
 - / / } 
 - / / 
 - / / onEncrypt ( data , 
 - / / ownEphermalKey0 , 
 - / / currentOwnKey , 
 - / / theirEphermalKey0 , 
 - / / currentTheirKey , 
 - / / future ) ; 
 - } 
 + if ( theirEphemeralKey = = null ) { 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKeyRandom ( uid , theirKeyGroup ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + KeyManagerActor . FetchUserEphemeralKeyResponse response = ( KeyManagerActor . FetchUserEphemeralKeyResponse ) obj ; 
 + if ( theirEphemeralKey = = null ) { 
 + theirEphemeralKey = response . getEphemeralKey ( ) . getPublicKey ( ) ; 
 + } 
 + onEncrypt ( data , future ) ; 
 + } 
 
 - private void onEncrypt ( byte [ ] data , 
 - OwnPrivateKey ownEphermalKey0 , 
 - OwnPrivateKey ownEphermalKey , 
 - UserPublicKey theirEphermalKey0 , 
 - UserPublicKey theirEphermalKey , 
 - Future future ) { 
 - 
 - / / Log . w ( TAG , " Encrypting with : OwnKey0 : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 - / / Log . w ( TAG , " Encrypting with : TheirKey0 : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 - / / 
 - / / byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( 
 - / / new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 - / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 - / / new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 - / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; 
 - / / byte [ ] rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 - / / new RatchetPrivateKey ( ownEphermalKey . getKey ( ) ) , 
 - / / new RatchetPublicKey ( theirEphermalKey . getPublicKey ( ) ) , 
 - / / master _ secret ) ; 
 - / / 
 - / / int messageIndex = outIndex + + ; 
 - / / 
 - / / ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; 
 - / / 
 - / / Log . d ( TAG , " MS : " + Hex . toHex ( master _ secret ) ) ; 
 - / / Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; 
 - / / Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphermalKey0 . getKey ( ) ) ) ) ; 
 - / / Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; 
 - / / Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphermalKey . getPublicKey ( ) ) ) ; 
 - / / Log . d ( TAG , " RC : " + Hex . toHex ( rootChainKey ) ) ; 
 - / / Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) ) ) ; 
 - / / Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphermalKey . getPublicKey ( ) ) ) ; 
 - / / 
 - / / Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; 
 - / / Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; 
 - / / Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; 
 - / / Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; 
 - / / 
 - / / byte [ ] header = ByteStrings . merge ( 
 - / / ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , 
 - / / ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 - / / ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 - / / Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) , 
 - / / theirEphermalKey . getPublicKey ( ) , 
 - / / ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / 
 - / / 
 - / / byte [ ] encrypted ; 
 - / / try { 
 - / / encrypted = ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ; 
 - / / } catch ( IntegrityException e ) { 
 - / / e . printStackTrace ( ) ; 
 - / / future . onError ( e ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / future . onResult ( new EncryptedPackageRes ( ByteStrings . merge ( header , encrypted ) ) ) ; 
 + @ Override 
 + public void onError ( Exception e ) { 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + return ; 
 + } 
 + 
 + if ( chains . size ( ) = = 0 ) { 
 + spawnChain ( Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 32 ) ) , theirEphemeralKey ) ; 
 + } 
 + 
 + try { 
 + future . onResult ( new EncryptedPackageRes ( chains . get ( 0 ) . encrypt ( data ) ) ) ; 
 + } catch ( IntegrityException e ) { 
 + e . printStackTrace ( ) ; 
 + future . onError ( e ) ; 
 + } 
 } 
 
 private void onDecrypt ( final byte [ ] data , final Future future ) { 
 @ @ - 307 , 28 + 231 , 13 @ @ public class EncryptedSessionActor extends ModuleActor { 
 } 
 
 try { 
 - future . onResult ( new DecryptedPackage ( pickedChain . decrypt ( data ) ) ) ; 
 + byte [ ] decrypted = pickedChain . decrypt ( data ) ; 
 + theirEphemeralKey = senderEphemeralKey ; 
 + future . onResult ( new DecryptedPackage ( decrypted ) ) ; 
 } catch ( IntegrityException e ) { 
 e . printStackTrace ( ) ; 
 future . onError ( e ) ; 
 } 
 - 
 - / / ask ( pickedChain . getChain ( ) , new EncryptedSessionChainActor . DecryptMessage ( 
 - / / ByteStrings . substring ( data , 0 , 88 ) , 
 - / / ByteStrings . substring ( data , 88 , data . length - 88 ) , 
 - / / senderEphemeralKey , messageIndex ) , new AskCallback ( ) { 
 - / / @ Override 
 - / / public void onResult ( Object obj ) { 
 - / / / / Updating ephemeral key 
 - / / theirEphemeralKey = senderEphemeralKey ; 
 - / / future . onResult ( ) ; 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( Exception e ) { 
 - / / future . onError ( e ) ; 
 - / / } 
 - / / } ) ; 
 } 
 
 private EncryptedSessionChain spawnChain ( final byte [ ] privateKey , final byte [ ] publicKey ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java 
 deleted file mode 100644 
 index abc6f07 . . 0000000 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java 
 + + + / dev / null 
 @ @ - 1 , 26 + 0 , 0 @ @ 
 - package im . actor . core . modules . encryption ; 
 - 
 - public class KeyLocation { 
 - 
 - private int uid ; 
 - private int keyGroup ; 
 - private long keyId ; 
 - 
 - public KeyLocation ( int uid , int keyGroup , long keyId ) { 
 - this . uid = uid ; 
 - this . keyGroup = keyGroup ; 
 - this . keyId = keyId ; 
 - } 
 - 
 - public int getUid ( ) { 
 - return uid ; 
 - } 
 - 
 - public int getKeyGroup ( ) { 
 - return keyGroup ; 
 - } 
 - 
 - public long getKeyId ( ) { 
 - return keyId ; 
 - } 
 - } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index 9eb0796 . . 44e8443 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 3 , 12 + 3 , 10 @ @ package im . actor . core . modules . encryption ; 
 import java . io . IOException ; 
 import java . util . ArrayList ; 
 import java . util . HashMap ; 
 - import java . util . List ; 
 
 import im . actor . core . api . ApiEncryptionKey ; 
 import im . actor . core . api . ApiEncryptionKeyGroup ; 
 import im . actor . core . api . ApiEncryptionKeySignature ; 
 - import im . actor . core . api . ApiEncryptionPublicKeyGroup ; 
 import im . actor . core . api . ApiUserOutPeer ; 
 import im . actor . core . api . rpc . RequestCreateNewKeyGroup ; 
 import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; 
 @ @ - 36 , 10 + 34 , 7 @ @ import im . actor . runtime . Log ; 
 import im . actor . runtime . Storage ; 
 import im . actor . runtime . actors . Future ; 
 import im . actor . runtime . actors . ask . AskRequest ; 
 - import im . actor . runtime . bser . BserWriter ; 
 - import im . actor . runtime . bser . DataOutput ; 
 import im . actor . runtime . crypto . Curve25519 ; 
 - import im . actor . runtime . crypto . primitives . digest . SHA256 ; 
 import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 import im . actor . runtime . crypto . ratchet . RatchetKeySignature ; 
 import im . actor . runtime . storage . KeyValueStorage ; 
 @ @ - 245 , 6 + 240 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 
 private void fetchEphemeralKey ( long keyId , Future future ) { 
 + Log . d ( TAG , " fetchEphemeralKey : " + keyId ) ; 
 for ( OwnPrivateKey k : ownKeys . getEphemeralKeys ( ) ) { 
 if ( k . getKeyId ( ) = = keyId ) { 
 future . onResult ( new FetchEphemeralPrivateKeyRes ( k . getKey ( ) ) ) ; 
 @ @ - 254 , 6 + 250 , 13 @ @ public class KeyManagerActor extends ModuleActor { 
 future . onError ( new RuntimeException ( " Unable to find ephemeral key " ) ) ; 
 } 
 
 + private void fetchOwnEphemeralKey ( Future future ) { 
 + Log . d ( TAG , " fetchOwnEphemeralKey " ) ; 
 + OwnPrivateKeyUploadable ownEphemeralKey = ownKeys . pickRandomEphemeralKey ( ) ; 
 + future . onResult ( new FetchOwnEphemeralKeyResult ( ownEphemeralKey . getKeyId ( ) , 
 + ownEphemeralKey . getKey ( ) ) ) ; 
 + } 
 + 
 private void fetchUserGroups ( final int uid , final Future future ) { 
 Log . d ( TAG , " fetchUserGroups " ) ; 
 final UserKeys userKeys = getCachedUserKeys ( uid ) ; 
 @ @ - 352 , 27 + 355 , 6 @ @ public class KeyManagerActor extends ModuleActor { 
 future . onError ( e ) ; 
 } 
 } ) ; 
 - 
 - / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 - / / @ Override 
 - / / public void onResult ( ResponsePublicKeys response ) { 
 - / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 - / / Log . w ( TAG , " No ephemeral keys found " ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 - / / theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; 
 - / / onTheirReady0 ( ) ; 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( RpcException e ) { 
 - / / / / Nothing to do 
 - / / Log . w ( TAG , " Their ephemeral error " ) ; 
 - / / Log . e ( TAG , e ) ; 
 - / / } 
 - / / } ) ; 
 } 
 
 private void fetchUserEphemeralKey ( final int uid , int keyGroupId , final Future future ) { 
 @ @ - 389 , 10 + 371 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 / / TODO : Verify signature 
 
 UserPublicKey pkey = new UserPublicKey ( key . getKeyId ( ) , key . getKeyAlg ( ) , key . getKeyMaterial ( ) ) ; 
 - / / UserKeysGroup userKeysGroup = finalKeysGroup . addUserKeyGroup ( pkey ) ; 
 - / / cacheUserKeys ( keys . removeUserKeyGroup ( userKeysGroup . getKeyGroupId ( ) ) 
 - / / . addUserKeyGroup ( userKeysGroup ) ) ; 
 - 
 + / / Do not store all ephemeral key as it is not required 
 future . onResult ( new FetchUserEphemeralKeyResponse ( pkey ) ) ; 
 } 
 
 @ @ - 547 , 6 + 526 , 9 @ @ public class KeyManagerActor extends ModuleActor { 
 } else if ( message instanceof FetchUserEphemeralKeyRandom ) { 
 fetchUserEphemeralKey ( ( ( FetchUserEphemeralKeyRandom ) message ) . getUid ( ) , ( ( FetchUserEphemeralKeyRandom ) message ) . getKeyGroup ( ) , future ) ; 
 return false ; 
 + } else if ( message instanceof FetchOwnEphemeralKey ) { 
 + fetchOwnEphemeralKey ( future ) ; 
 + return false ; 
 } 
 return super . onAsk ( message , future ) ; 
 } 
 @ @ - 568 , 6 + 550 , 29 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 } 
 
 + public static class FetchOwnEphemeralKey { 
 + 
 + } 
 + 
 + public static class FetchOwnEphemeralKeyResult { 
 + 
 + private long id ; 
 + private byte [ ] privateKey ; 
 + 
 + public FetchOwnEphemeralKeyResult ( long id , byte [ ] privateKey ) { 
 + this . id = id ; 
 + this . privateKey = privateKey ; 
 + } 
 + 
 + public long getId ( ) { 
 + return id ; 
 + } 
 + 
 + public byte [ ] getPrivateKey ( ) { 
 + return privateKey ; 
 + } 
 + } 
 + 
 public static class FetchOwnKeyGroup { 
 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 index a7167eb . . d625a3d 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 @ @ - 2 , 6 + 2 , 9 @ @ package im . actor . core . modules . encryption . session ; 
 
 import java . util . HashSet ; 
 
 + import im . actor . runtime . Crypto ; 
 + import im . actor . runtime . Log ; 
 + import im . actor . runtime . crypto . Curve25519 ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . box . ActorBox ; 
 import im . actor . runtime . crypto . box . ActorBoxKey ; 
 @ @ - 90 , 4 + 93 , 22 @ @ public class EncryptedSessionChain { 
 byte [ ] message = ByteStrings . substring ( data , 88 , data . length - 88 ) ; 
 return ActorBox . openBox ( header , message , ratchetMessageKey ) ; 
 } 
 - } 
 + 
 + public byte [ ] encrypt ( byte [ ] data ) throws IntegrityException { 
 + int messageIndex = sentCounter + + ; 
 + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; 
 + 
 + byte [ ] header = ByteStrings . merge ( 
 + ByteStrings . intToBytes ( session . getPeerKeyGroupId ( ) ) , 
 + ByteStrings . longToBytes ( session . getOwnPreKey ( ) . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 + ByteStrings . longToBytes ( session . getTheirPreKey ( ) . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 + Curve25519 . keyGenPublic ( ownPrivateKey ) , 
 + theirPublicKey , 
 + ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / 
 + 
 + Log . d ( " EncryptedSessionChain " , " Own Pre Key : " + session . getOwnPreKey ( ) . getKeyId ( ) ) ; 
 + Log . d ( " EncryptedSessionChain " , " Their Pre Key : " + session . getTheirPreKey ( ) . getKeyId ( ) ) ; 
 + 
 + return ByteStrings . merge ( header , ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ) ; 
 + } 
 + } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj 
 index 2f54661 . . c33368d 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj 
 @ @ - 1550 , 7 + 1550 , 7 @ @ 
 	 	 	 	 TargetAttributes = { 
 	 	 	 	 	 066A50D11BC4AE63000E606E = { 
 	 	 	 	 	 	 CreatedOnToolsVersion = 7 . 0 ; 
 - 	 	 	 	 	 	 DevelopmentTeam = PR6635TQQ3 ; 
 + 	 	 	 	 	 	 DevelopmentTeam = HVJR44Y5B6 ; 
 	 	 	 	 	 } ; 
 	 	 	 	 } ; 
 	 	 	 } ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 2d72521 . . 37809ce 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . core . modules . encryption . entity . EncryptedBox ; 
 import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; 
 import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 + import im . actor . core . util . Hex ; 
 import im . actor . core . util . ModuleActor ; 
 import im . actor . runtime . Crypto ; 
 import im . actor . runtime . Log ; 
 @ @ - 25 , 6 + 26 , 7 @ @ import im . actor . runtime . actors . ask . AskRequest ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . box . ActorBox ; 
 import im . actor . runtime . crypto . box . ActorBoxKey ; 
 + import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 
 public class EncryptedPeerActor extends ModuleActor { 
 
 @ @ - 34 , 6 + 36 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { 
 private ArrayList < ApiEncryptionKeyGroup > keyGroups ; 
 private HashMap < Integer , ActorRef > sessions = new HashMap < Integer , ActorRef > ( ) ; 
 private boolean isReady = false ; 
 + private int ownKeyGroupId ; 
 
 public EncryptedPeerActor ( int uid , ModuleContext context ) { 
 super ( context ) ; 
 @ @ - 78 , 14 + 81 , 29 @ @ public class EncryptedPeerActor extends ModuleActor { 
 } 
 } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; 
 } 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKeyGroup ( ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + KeyManagerActor . FetchOwnKeyGroupResult res = ( KeyManagerActor . FetchOwnKeyGroupResult ) obj ; 
 + ownKeyGroupId = res . getKeyGroupId ( ) ; 
 + onOwnKeysReady ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + / / Do nothing 
 + } 
 + } ) ; 
 + } 
 + 
 + private void onOwnKeysReady ( ) { 
 + Log . w ( TAG , " onOwnKeysReady " ) ; 
 isReady = true ; 
 unstashAll ( ) ; 
 } 
 
 private void doEncrypt ( final byte [ ] data , final Future future ) { 
 - 
 Log . d ( TAG , " doEncrypt " ) ; 
 - 
 final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 
 final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 @ @ - 112 , 19 + 130 , 61 @ @ public class EncryptedPeerActor extends ModuleActor { 
 Log . d ( TAG , " doEncrypt2 " ) ; 
 byte [ ] encData ; 
 try { 
 - encData = ActorBox . closeBox ( new byte [ 0 ] , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 } catch ( IntegrityException e ) { 
 e . printStackTrace ( ) ; 
 future . onError ( e ) ; 
 return ; 
 } 
 
 - EncryptedBox encryptedBox = new EncryptedBox ( encryptedKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , encData ) ; 
 + EncryptedBox encryptedBox = new EncryptedBox ( 
 + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 + 
 + Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; 
 + for ( EncryptedBoxKey k : encryptedKeys ) { 
 + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 + } 
 + 
 future . onResult ( encryptedBox ) ; 
 } 
 
 - private void doDecrypt ( EncryptedBox data , Future future ) { 
 + private void doDecrypt ( EncryptedBox data , final Future future ) { 
 + int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; 
 + byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; 
 + 
 + if ( sessions . containsKey ( senderKeyGroup ) ) { 
 + Log . d ( TAG , " Decryption with key group " ) ; 
 + byte [ ] encKey = null ; 
 + for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 + if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { 
 + encKey = k . getEncryptedKey ( ) ; 
 + break ; 
 + } 
 + } 
 + 
 + Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; 
 + for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 + } 
 + 
 + ask ( sessions . get ( senderKeyGroup ) , new EncryptionSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + Log . d ( TAG , " Decryption with key group : onResult " ) ; 
 + future . onResult ( ) ; 
 + } 
 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . d ( TAG , " Decryption with key group : onError " ) ; 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + } else { 
 + Log . w ( TAG , " Unable to find appropriate session # " + senderKeyGroup ) ; 
 + future . onError ( new RuntimeException ( ) ) ; 
 + } 
 } 
 
 @ Override 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 index 7f57506 . . 5d65dd8 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 @ @ - 8 , 9 + 8 , 11 @ @ import im . actor . core . api . ApiUserOutPeer ; 
 import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; 
 import im . actor . core . api . rpc . ResponsePublicKeys ; 
 import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; 
 import im . actor . core . modules . encryption . entity . EncryptionKey ; 
 import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 + import im . actor . core . util . Hex ; 
 import im . actor . core . util . ModuleActor ; 
 import im . actor . core . util . RandomUtils ; 
 import im . actor . runtime . Crypto ; 
 @ @ - 101 , 7 + 103 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { 
 return ; 
 } 
 
 - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( 0 ) ; 
 + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; 
 onTheirReady0 ( ) ; 
 } 
 @ @ - 169 , 6 + 171 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { 
 ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; 
 
 byte [ ] header = ByteStrings . merge ( 
 + ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , 
 ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 currentOwnKey . getPublicKey ( ) , 
 @ @ - 186 , 9 + 189 , 46 @ @ public class EncryptionSessionActor extends ModuleActor { 
 
 byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; 
 
 + 
 + int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; 
 + long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; 
 + long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; 
 + byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; 
 + byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; 
 + int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; 
 + 
 + Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; 
 + Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; 
 + 
 + 
 + Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; 
 + Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 + Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 + Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; 
 + 
 future . onResult ( new EncryptedPackageRes ( pkg ) ) ; 
 } 
 
 + private void onDecrypt ( byte [ ] data , Future future ) { 
 + int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 + long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 + long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 + byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 + byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 + int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 + 
 + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 + Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; 
 + Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 + Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 + Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; 
 + 
 + / / future . onResult ( ) ; 
 + } 
 + 
 @ Override 
 public void onReceive ( Object message ) { 
 if ( ! isReady & & message instanceof AskRequest ) { 
 @ @ - 203 , 6 + 243 , 10 @ @ public class EncryptionSessionActor extends ModuleActor { 
 if ( message instanceof EncryptPackage ) { 
 onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; 
 return false ; 
 + } else if ( message instanceof DecryptPackage ) { 
 + DecryptPackage decryptPackage = ( DecryptPackage ) message ; 
 + onDecrypt ( decryptPackage . getData ( ) , future ) ; 
 + return false ; 
 } else { 
 return super . onAsk ( message , future ) ; 
 } 
 @ @ - 232 , 4 + 276 , 17 @ @ public class EncryptionSessionActor extends ModuleActor { 
 return data ; 
 } 
 } 
 + 
 + public static class DecryptPackage { 
 + 
 + private byte [ ] data ; 
 + 
 + public DecryptPackage ( byte [ ] data ) { 
 + this . data = data ; 
 + } 
 + 
 + public byte [ ] getData ( ) { 
 + return data ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index f4eb042 . . 58c2383 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 230 , 6 + 230 , 10 @ @ public class KeyManagerActor extends ModuleActor { 
 future . onResult ( new FetchOwnKeyResult ( privateKeyStorage . getIdentityKey ( ) , ephemeralEncryptionKey . getEncryptionKey ( ) ) ) ; 
 } 
 
 + private void fetchKeyGroup ( Future future ) { 
 + future . onResult ( new FetchOwnKeyGroupResult ( privateKeyStorage . getKeyGroupId ( ) ) ) ; 
 + } 
 + 
 @ Override 
 public void onReceive ( Object message ) { 
 if ( message instanceof AskRequest & & ! isReady ) { 
 @ @ - 244 , 6 + 248 , 9 @ @ public class KeyManagerActor extends ModuleActor { 
 if ( message instanceof FetchOwnKey ) { 
 fetchOwnKey ( future ) ; 
 return false ; 
 + } else if ( message instanceof FetchOwnKeyGroup ) { 
 + fetchKeyGroup ( future ) ; 
 + return false ; 
 } 
 return super . onAsk ( message , future ) ; 
 } 
 @ @ - 270 , 4 + 277 , 20 @ @ public class KeyManagerActor extends ModuleActor { 
 return ephemeralKey ; 
 } 
 } 
 + 
 + public static class FetchOwnKeyGroup { 
 + 
 + } 
 + 
 + public static class FetchOwnKeyGroupResult { 
 + private int keyGroupId ; 
 + 
 + public FetchOwnKeyGroupResult ( int keyGroupId ) { 
 + this . keyGroupId = keyGroupId ; 
 + } 
 + 
 + public int getKeyGroupId ( ) { 
 + return keyGroupId ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java 
 index 815d4ba . . 6d0d54d 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java 
 @ @ - 48 , 6 + 48 , 29 @ @ public class MessageEncryptionActor extends ModuleActor { 
 } ) ; 
 } 
 
 + public void onDecrypt ( int uid , ApiEncryptedMessage message ) { 
 + Log . d ( TAG , " onDecrypt : " + uid ) ; 
 + ArrayList < EncryptedBoxKey > encryptedBoxKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 + for ( ApiEncyptedBoxKey key : message . getBox ( ) . getKeys ( ) ) { 
 + if ( key . getUsersId ( ) = = myUid ( ) ) { 
 + encryptedBoxKeys . add ( new EncryptedBoxKey ( key . getUsersId ( ) , key . getKeyGroupId ( ) , 
 + key . getEncryptedKey ( ) ) ) ; 
 + } 
 + } 
 + EncryptedBox encryptedBox = new EncryptedBox ( encryptedBoxKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , message . getBox ( ) . getEncPackage ( ) ) ; 
 + ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . DecryptPackage ( encryptedBox ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + Log . d ( TAG , " onDecrypt : onResult " ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . d ( TAG , " onDecrypt : onError " ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 @ Override 
 public boolean onAsk ( Object message , Future future ) { 
 if ( message instanceof EncryptMessage ) { 
 @ @ - 58 , 6 + 81 , 16 @ @ public class MessageEncryptionActor extends ModuleActor { 
 return super . onAsk ( message , future ) ; 
 } 
 
 + @ Override 
 + public void onReceive ( Object message ) { 
 + if ( message instanceof InMessage ) { 
 + InMessage inMessage = ( InMessage ) message ; 
 + onDecrypt ( inMessage . senderUid , inMessage . encryptedMessage ) ; 
 + } else { 
 + super . onReceive ( message ) ; 
 + } 
 + } 
 + 
 public static class InMessage { 
 
 private Peer peer ; 
 @ @ - 105 , 4 + 138 , 17 @ @ public class MessageEncryptionActor extends ModuleActor { 
 return encryptedMessage ; 
 } 
 } 
 + 
 + public static class DecryptMessage { 
 + 
 + private ApiEncryptedMessage encryptedMessage ; 
 + 
 + public DecryptMessage ( ApiEncryptedMessage encryptedMessage ) { 
 + this . encryptedMessage = encryptedMessage ; 
 + } 
 + 
 + public ApiEncryptedMessage getEncryptedMessage ( ) { 
 + return encryptedMessage ; 
 + } 
 + } 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java 
 index 9da4c36 . . 8a8877a 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import im . actor . core . entity . content . AbsContent ; 
 import im . actor . core . entity . content . ServiceUserRegistered ; 
 import im . actor . core . modules . AbsModule ; 
 import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . encryption . MessageEncryptionActor ; 
 import im . actor . core . modules . internal . messages . ConversationActor ; 
 import im . actor . core . modules . internal . messages . ConversationHistoryActor ; 
 import im . actor . core . modules . internal . messages . CursorReceiverActor ; 
 @ @ - 53 , 11 + 54 , 13 @ @ public class MessagesProcessor extends AbsModule { 
 long intMessageSortDate = 0 ; 
 Peer peer = convert ( _ peer ) ; 
 
 - ArrayList < Message > nMesages = new ArrayList < Message > ( ) ; 
 + ArrayList < Message > nMessages = new ArrayList < Message > ( ) ; 
 for ( UpdateMessage u : messages ) { 
 
 if ( u . getMessage ( ) instanceof ApiEncryptedMessage ) { 
 - / / TODO : Decrypt message 
 + / / TODO : Proper decrypt message 
 + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , 
 + u . getDate ( ) , u . getSenderUid ( ) , u . getRid ( ) , ( ApiEncryptedMessage ) u . getMessage ( ) ) ) ; 
 continue ; 
 } 
 
 @ @ - 72 , 7 + 75 , 7 @ @ public class MessagesProcessor extends AbsModule { 
 boolean isOut = myUid ( ) = = u . getSenderUid ( ) ; 
 
 / / Sending message to conversation 
 - nMesages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , 
 + nMessages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , 
 isOut ? MessageState . SENT : MessageState . UNKNOWN , msgContent , 
 new ArrayList < Reaction > ( ) ) ) ; 
 
 @ @ - 84 , 7 + 87 , 7 @ @ public class MessagesProcessor extends AbsModule { 
 } 
 } 
 
 - conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMesages ) ) ; 
 + conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMessages ) ) ; 
 
 if ( intMessageSortDate > 0 ) { 
 plainReceiveActor ( ) . send ( new CursorReceiverActor . MarkReceived ( peer , intMessageSortDate ) ) ; 
 @ @ - 95 , 7 + 98 , 7 @ @ public class MessagesProcessor extends AbsModule { 
 } 
 
 / / OwnReadActor 
 - for ( Message m : nMesages ) { 
 + for ( Message m : nMessages ) { 
 if ( m . getSenderId ( ) ! = myUid ( ) ) { 
 ownReadActor ( ) . send ( new OwnReadActor . InMessage ( peer , m ) ) ; 
 } 
 @ @ - 107 , 6 + 110 , 13 @ @ public class MessagesProcessor extends AbsModule { 
 ApiMessage content ) { 
 
 Peer peer = convert ( _ peer ) ; 
 + 
 + if ( content instanceof ApiEncryptedMessage ) { 
 + / / TODO : Proper decrypt message 
 + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , 
 + date , senderUid , rid , ( ApiEncryptedMessage ) content ) ) ; 
 + } 
 + 
 AbsContent msgContent ; 
 try { 
 msgContent = AbsContent . fromMessage ( content ) ; 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 index 7ff7e50 . . e4aff27 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 @ @ - 22 , 7 + 22 , 7 @ @ public class ByteStrings { 
 } 
 
 public static byte [ ] intToBytes ( int v ) { 
 - byte [ ] data = new byte [ 8 ] ; 
 + byte [ ] data = new byte [ 4 ] ; 
 int offset = 0 ; 
 data [ offset + + ] = ( byte ) ( ( v > > 24 ) & 0xFF ) ; 
 data [ offset + + ] = ( byte ) ( ( v > > 16 ) & 0xFF ) ;
