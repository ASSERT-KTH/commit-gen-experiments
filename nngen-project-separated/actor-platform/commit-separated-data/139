BLEU SCORE: 0.5169731539571706

TEST MSG: wip ( server ) : channel edit only by admin
GENERATED MSG: wip ( server ) : channel updates

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 6d19375 . . 0a7aa53 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 741 , 9 + 741 , 10 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > } < nl > < nl > - / / TODO : channels , don ' t allow non - admin to change topic < nl > protected def updateAvatar ( cmd : UpdateAvatar ) : Unit = { < nl > - if ( state . nonMember ( cmd . clientUserId ) ) { < nl > + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . clientUserId ) ) { < nl > + sender ( ) ! notAdmin < nl > + } else if ( state . nonMember ( cmd . clientUserId ) ) { < nl > sender ( ) ! notMember < nl > } else { < nl > persist ( AvatarUpdated ( Instant . now , cmd . avatar ) ) { evt ⇒ < nl > @ @ - 790 , 10 + 791 , 11 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > } < nl > < nl > - / / TODO : channels , don ' t allow non - admin to change topic < nl > protected def updateTitle ( cmd : UpdateTitle ) : Unit = { < nl > val title = cmd . title < nl > - if ( state . nonMember ( cmd . clientUserId ) ) { < nl > + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . clientUserId ) ) { < nl > + sender ( ) ! notAdmin < nl > + } else if ( state . nonMember ( cmd . clientUserId ) ) { < nl > sender ( ) ! notMember < nl > } else if ( ! isValidTitle ( title ) ) { < nl > sender ( ) ! Status . Failure ( InvalidTitle ) < nl > @ @ - 859 , 13 + 861 , 14 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > } < nl > < nl > - / / TODO : channels , don ' t allow non - admin to change topic < nl > protected def updateTopic ( cmd : UpdateTopic ) : Unit = { < nl > def isValidTopic ( topic : Option [ String ] ) = topic . forall ( _ . length < 255 ) < nl > < nl > val topic = trimToEmpty ( cmd . topic ) < nl > < nl > - if ( state . nonMember ( cmd . clientUserId ) ) { < nl > + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . clientUserId ) ) { < nl > + sender ( ) ! notAdmin < nl > + } else if ( state . nonMember ( cmd . clientUserId ) ) { < nl > sender ( ) ! notMember < nl > } else if ( ! isValidTopic ( topic ) ) { < nl > sender ( ) ! Status . Failure ( TopicTooLong ) < nl > @ @ - 1041 , 6 + 1044 , 36 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / TODO : remove deprecated < nl > db . run ( GroupUserRepo . makeAdmin ( groupId , cmd . candidateUserId ) ) < nl > < nl > + val adminGROUPUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + userIds = memberIds + cmd . clientUserId , < nl > + updateAdmin < nl > + ) < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > + cmd . clientUserId , < nl > + cmd . clientAuthId , < nl > + memberIds - cmd . clientUserId , < nl > + updateMembers < nl > + ) < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > + < nl > + val adminCHANNELUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push admin changed to all < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + userIds = memberIds + cmd . clientUserId , < nl > + updateAdmin < nl > + ) < nl > + / / push changed members to admins and fresh admin < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > + cmd . clientUserId , < nl > + cmd . clientAuthId , < nl > + ( newState . adminIds - cmd . clientUserId ) + cmd . candidateUserId , < nl > + updateMembers < nl > + ) < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > + < nl > val result : Future [ ( Vector [ ApiMember ] , SeqStateDate ) ] = for { < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > @ @ - 1058 , 17 + 1091 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - userIds = memberIds + cmd . clientUserId , < nl > - updateAdmin < nl > - ) < nl > - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > - cmd . clientUserId , < nl > - cmd . clientAuthId , < nl > - memberIds - cmd . clientUserId , < nl > - updateMembers < nl > - ) < nl > - } yield ( members , SeqStateDate ( seq , state , dateMillis ) ) < nl > + seqStateDate ← if ( state . typ . isChannel ) adminCHANNELUpdates else adminGROUPUpdates < nl > + < nl > + } yield ( members , seqStateDate ) < nl > < nl > result pipeTo sender ( ) < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > index e82dbae . . 5433dd0 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > @ @ - 1 , 11 + 1 , 9 @ @ < nl > package im . actor . server . dialog < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . http . scaladsl . util . FastFuture < nl > import im . actor . api . rpc . PeersImplicits < nl > import im . actor . api . rpc . counters . { ApiAppCounters , UpdateCountersChanged } < nl > import im . actor . api . rpc . messaging . _ < nl > - import im . actor . server . db . DbExtension < nl > import im . actor . server . messaging . PushText < nl > import im . actor . server . model . Peer < nl > import im . actor . server . sequence . { PushData , PushRules , SeqState , SeqUpdatesExtension } < nl > @ @ - 54 , 7 + 52 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > . withCensoredText ( censoredPushText ) < nl > . withPeer ( peer ) < nl > ) , < nl > - deliveryId = deliveryId ( peer , randomId ) , < nl > + deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , < nl > deliveryTag = deliveryTag < nl > ) < nl > } yield ( ) < nl > @ @ - 100 , 7 + 98 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > default = Some ( senderUpdate ) , < nl > custom = senderAuthId map ( authId ⇒ Map ( authId → senderClientUpdate ) ) getOrElse Map . empty , < nl > pushRules = PushRules ( isFat = isFat , excludeAuthIds = senderAuthId . toSeq ) , < nl > - deliveryId = deliveryId ( peer , randomId ) , < nl > + deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , < nl > deliveryTag = deliveryTag < nl > ) < nl > } < nl > @ @ - 134 , 9 + 132 , 6 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > ) < nl > } yield ( ) < nl > < nl > - private def deliveryId ( peer : Peer , randomId : Long ) = < nl > - s " msg _ $ { peer . ` type ` . value } _ $ { peer . id } _ $ { randomId } " < nl > - < nl > private def reduceKey ( prefix : String , peer : Peer ) : String = < nl > s " $ { prefix } _ $ { peer . ` type ` . value } _ $ { peer . id } " < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 85a5734 . . 6d19375 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 8 , 6 + 8 , 7 @ @ import akka . pattern . pipe < nl > import im . actor . api . rpc . Update < nl > import im . actor . api . rpc . files . ApiAvatar < nl > import im . actor . api . rpc . groups . _ < nl > + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessage } < nl > import im . actor . api . rpc . users . ApiSex < nl > import im . actor . concurrent . FutureExt < nl > import im . actor . server . CommonErrors < nl > @ @ - 205 , 7 + 206 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / TODO : remove deprecated < nl > db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) ) < nl > < nl > - def inviteGROUPUpdates : Future [ SeqState ] = < nl > + def inviteGROUPUpdates : Future [ SeqStateDate ] = < nl > for { < nl > / / push updated members list to inviteeUserId , < nl > _ ← seqUpdExt . deliverUserUpdate ( < nl > @ @ - 221 , 17 + 222 , 26 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > < nl > / / push updated members list to all group members except inviteeUserId < nl > - seqState ← seqUpdExt . broadcastClientUpdate ( < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > userId = cmd . inviterUserId , < nl > authId = cmd . inviterAuthId , < nl > bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > update = membersUpdateNew , < nl > deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > ) < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - } yield seqState < nl > < nl > - def inviteCHANNELUpdates : Future [ SeqState ] = < nl > + / / explicitly send service message < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + cmd . inviterUserId , < nl > + cmd . inviterAuthId , < nl > + cmd . randomId , < nl > + serviceMessage , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + } yield SeqStateDate ( seq , state , date ) < nl > + < nl > + def inviteCHANNELUpdates : Future [ SeqStateDate ] = < nl > for { < nl > / / push ` UpdateGroupMembersUpdated ` to invitee only if he is admin . < nl > / / invitee could be admin , if he created this group , and turning back < nl > @ @ - 258 , 9 + 268 , 24 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > ) < nl > < nl > - / / get current SeqState for inviter user < nl > - seqState ← seqUpdExt . getSeqState ( cmd . inviterUserId , cmd . inviterAuthId ) < nl > - } yield seqState < nl > + / / push service message to invitee < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . inviteeUserId , < nl > + authId = 0L , < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > + < nl > + / / push service message to inviter and return seqState < nl > + SeqState ( seq , state ) ← pushUpdateMessage ( < nl > + userId = cmd . inviterUserId , < nl > + authId = cmd . inviterAuthId , < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > < nl > val result : Future [ SeqStateDate ] = for { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > @ @ - 296 , 18 + 321 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - SeqState ( seq , state ) ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates < nl > + seqStateDate ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates < nl > < nl > - / / explicitly send service message < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - cmd . inviterUserId , < nl > - cmd . inviterAuthId , < nl > - cmd . randomId , < nl > - serviceMessage , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > - } yield SeqStateDate ( seq , state , date ) < nl > + } yield seqStateDate < nl > < nl > result pipeTo sender ( ) < nl > } < nl > @ @ - 336 , 6 + 352 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val newState = commit ( evt ) < nl > < nl > val date = evt . ts < nl > + val dateMillis = date . toEpochMilli < nl > val memberIds = newState . memberIds < nl > val members = newState . members . values . map ( _ . asStruct ) . toVector < nl > val randomId = ACLUtils . randomLong ( ) < nl > @ @ - 367 , 7 + 384 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > isAdmin = false < nl > ) ) < nl > < nl > - def joinGROUPUpdates : Future [ SeqState ] = < nl > + def joinGROUPUpdates : Future [ SeqStateDate ] = < nl > for { < nl > / / push all group updates to joiningUserId < nl > _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > @ @ - 376 , 7 + 393 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > / / push updated members list to joining user , < nl > / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > - seqState ← seqUpdExt . deliverClientUpdate ( < nl > + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . joiningUserId , < nl > authId = cmd . joiningUserAuthId , < nl > update = membersUpdateNew , < nl > @ @ - 391 , 9 + 408 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > membersUpdateNew , < nl > deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > ) < nl > - } yield seqState < nl > < nl > - def joinCHANNELUpdates : Future [ SeqState ] = < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + senderUserId = cmd . joiningUserId , < nl > + senderAuthId = cmd . joiningUserAuthId , < nl > + randomId = randomId , < nl > + serviceMessage / / no delivery tag . This updated handled this way in Groups V1 < nl > + ) < nl > + } yield SeqStateDate ( seq , state , date ) < nl > + < nl > + def joinCHANNELUpdates : Future [ SeqStateDate ] = < nl > for { < nl > / / push all group updates to joiningUserId < nl > _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > @ @ - 403 , 7 + 428 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / push ` UpdateGroupMembersUpdated ` to joining user only if he is admin . < nl > / / joining user can be admin , if he created this group , and turning back < nl > / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > - seqState ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { < nl > + SeqState ( seq , state ) ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { < nl > seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . joiningUserId , < nl > authId = cmd . joiningUserAuthId , < nl > @ @ - 421 , 7 + 446 , 16 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > membersUpdateNew , < nl > deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > ) < nl > - } yield seqState < nl > + < nl > + / / push service message to joining user and return seqState < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . joiningUserId , < nl > + authId = cmd . joiningUserAuthId , < nl > + ts = dateMillis , < nl > + randomId = randomId , < nl > + serviceMessage < nl > + ) < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > < nl > val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = < nl > for { < nl > @ @ - 441 , 16 + 475 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - SeqState ( seq , state ) ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates < nl > + seqStateDate ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates < nl > < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - senderUserId = cmd . joiningUserId , < nl > - senderAuthId = cmd . joiningUserAuthId , < nl > - randomId = randomId , < nl > - serviceMessage / / no delivery tag . This updated handled this way in Groups V1 < nl > - ) < nl > - } yield ( SeqStateDate ( seq , state , date ) , memberIds . toVector : + inviterUserId , randomId ) < nl > + } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) < nl > < nl > result pipeTo sender ( ) < nl > } < nl > @ @ - 474 , 11 + 501 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) < nl > < nl > - val leftUserUpdatesNew = List ( < nl > - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > - ) < nl > + val leftUserUpdatesNew = < nl > + if ( state . typ . isChannel ) List ( < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > + ) < nl > + else List ( < nl > + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > + ) < nl > < nl > val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > < nl > @ @ - 492 , 6 + 523 , 67 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } yield ( ) < nl > ) < nl > < nl > + val leaveGROUPUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members list to all group members < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + state . memberIds - cmd . userId , < nl > + membersUpdateNew < nl > + ) < nl > + < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + senderUserId = cmd . userId , < nl > + senderAuthId = cmd . authId , < nl > + randomId = cmd . randomId , < nl > + message = serviceMessage , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + < nl > + / / push left user that he is no longer a member < nl > + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > + userId = cmd . userId , < nl > + authId = cmd . authId , < nl > + update = UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > + ) < nl > + < nl > + / / push left user updates < nl > + / / • with empty group members < nl > + / / • that he can ' t view and invite members < nl > + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > + } < nl > + } yield SeqStateDate ( seq , state , date ) < nl > + < nl > + val leaveCHANNELUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members list to all ADMINS , except userId ( if he was there ) < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + state . adminIds - cmd . userId , < nl > + membersUpdateNew < nl > + ) < nl > + < nl > + / / push service message to left user < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . userId , < nl > + authId = cmd . authId , < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + message = serviceMessage < nl > + ) < nl > + < nl > + / / push left user that he is no longer a member < nl > + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > + userId = cmd . userId , < nl > + authId = cmd . authId , < nl > + update = UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > + ) < nl > + < nl > + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > + } < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > + < nl > / / read this dialog by user that leaves group . don ' t wait for ack < nl > dialogExt . messageRead ( apiGroupPeer , cmd . userId , 0L , dateMillis ) < nl > val result : Future [ SeqStateDate ] = for { < nl > @ @ - 512 , 36 + 604 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - / / push updated members list to all group members < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - state . memberIds - cmd . userId , < nl > - membersUpdateNew < nl > - ) < nl > + seqStateDate ← if ( state . typ . isChannel ) leaveCHANNELUpdates else leaveGROUPUpdates < nl > < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - senderUserId = cmd . userId , < nl > - senderAuthId = cmd . authId , < nl > - randomId = cmd . randomId , < nl > - message = serviceMessage , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > - < nl > - / / push left user that he is no longer a member < nl > - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > - userId = cmd . userId , < nl > - authId = cmd . authId , < nl > - update = UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > - ) < nl > - < nl > - / / push left user updates < nl > - / / • with empty group members < nl > - / / • that he can ' t view and invite members < nl > - _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > - } < nl > - < nl > - } yield SeqStateDate ( seq , state , date ) < nl > + } yield seqStateDate < nl > < nl > result andThen { case _ ⇒ commit ( evt ) } pipeTo sender ( ) < nl > } < nl > @ @ - 549 , 7 + 614 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > < nl > protected def kick ( cmd : Kick ) : Unit = { < nl > - if ( state . nonMember ( cmd . kickerUserId ) | | state . nonMember ( cmd . kickedUserId ) ) { < nl > + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . kickedUserId ) ) { < nl > + sender ( ) ! notAdmin < nl > + } else if ( state . nonMember ( cmd . kickerUserId ) | | state . nonMember ( cmd . kickedUserId ) ) { < nl > sender ( ) ! notMember < nl > } else { < nl > persist ( UserKicked ( Instant . now , cmd . kickedUserId , cmd . kickerUserId ) ) { evt ⇒ < nl > @ @ - 560 , 12 + 627 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val updateObsolete = UpdateGroupUserKickObsolete ( groupId , cmd . kickedUserId , cmd . kickerUserId , dateMillis , cmd . randomId ) < nl > < nl > - val kickedUserUpdatesNew : List [ Update ] = List ( < nl > - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , < nl > - UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > - ) < nl > + val kickedUserUpdatesNew : List [ Update ] = < nl > + if ( state . typ . isChannel ) List ( < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , < nl > + UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > + ) < nl > + else List ( < nl > + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , < nl > + UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > + ) < nl > < nl > val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > < nl > @ @ - 579 , 6 + 651 , 68 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } yield ( ) < nl > ) < nl > < nl > + val kickGROUPUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members list to all group members . Don ' t push to kicked user ! < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > + userId = cmd . kickerUserId , < nl > + authId = cmd . kickerAuthId , < nl > + bcastUserIds = newState . memberIds - cmd . kickerUserId , < nl > + update = membersUpdateNew < nl > + ) < nl > + < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + senderUserId = cmd . kickerUserId , < nl > + senderAuthId = cmd . kickerAuthId , < nl > + randomId = cmd . randomId , < nl > + message = serviceMessage , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + < nl > + / / push kicked user updates < nl > + / / • with empty group members < nl > + / / • that he is no longer a member of group < nl > + / / • that he can ' t view and invite members < nl > + _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) < nl > + } < nl > + } yield SeqStateDate ( seq , state , date ) < nl > + < nl > + val kickCHANNELUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members list to all ADMINS . Don ' t push to kicked user ! < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > + userId = cmd . kickerUserId , < nl > + authId = cmd . kickerAuthId , < nl > + bcastUserIds = newState . adminIds - cmd . kickerUserId , < nl > + update = membersUpdateNew < nl > + ) < nl > + < nl > + / / push service message to kicker user < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . kickerUserId , < nl > + authId = cmd . kickerAuthId , / / ? ? ? what ' s a point ? < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > + < nl > + / / push service message to kicked user < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . kickedUserId , < nl > + authId = 0L , < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > + < nl > + / / push kicked user updates < nl > + _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) < nl > + } < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > + < nl > / / read this dialog by kicked user . don ' t wait for ack < nl > dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) < nl > val result : Future [ SeqStateDate ] = for { < nl > @ @ - 598 , 32 + 732 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - / / push updated members list to all group members . Don ' t push to kicked user ! < nl > - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > - userId = cmd . kickerUserId , < nl > - authId = cmd . kickerAuthId , < nl > - bcastUserIds = newState . memberIds - cmd . kickerUserId , < nl > - update = membersUpdateNew < nl > - ) < nl > - < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - senderUserId = cmd . kickerUserId , < nl > - senderAuthId = cmd . kickerAuthId , < nl > - randomId = cmd . randomId , < nl > - message = serviceMessage , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > + seqStateDate ← if ( state . typ . isChannel ) kickCHANNELUpdates else kickGROUPUpdates < nl > < nl > - / / push kicked user updates < nl > - / / • with empty group members < nl > - / / • that he is no longer a member of group < nl > - / / • that he can ' t view and invite members < nl > - _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) < nl > - } < nl > - < nl > - } yield SeqStateDate ( seq , state , date ) < nl > + } yield seqStateDate < nl > < nl > result pipeTo sender ( ) < nl > } < nl > @ @ - 987 , 6 + 1098 , 26 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > } < nl > < nl > + / / и л и в с е т а к и б у д е т broadcast ? < nl > + private def pushUpdateMessage ( userId : Int , authId : Long , ts : Long , randomId : Long , message : ApiMessage ) : Future [ SeqState ] = { < nl > + val messUpdate = UpdateMessage ( < nl > + peer = apiGroupPeer , < nl > + senderUserId = userId , < nl > + date = ts , < nl > + randomId = randomId , < nl > + message = message , < nl > + attributes = None , < nl > + quotedMessage = None < nl > + ) < nl > + seqUpdExt . deliverClientUpdate ( < nl > + userId = userId , < nl > + authId = authId , < nl > + update = messUpdate , < nl > + deliveryId = seqUpdExt . msgDeliveryId ( apiGroupPeer . asModel , randomId ) , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + } < nl > + < nl > private def trimToEmpty ( s : Option [ String ] ) : Option [ String ] = < nl > s map ( _ . trim ) filter ( _ . nonEmpty ) < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > index 9f0b5ed . . ee7837b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > @ @ - 63 , 6 + 63 , 9 @ @ final class SeqUpdatesExtension ( _ system : ActorSystem ) < nl > optTs . getOrElse ( throw new RuntimeException ( s " No Migration timestamp found for $ { MigrationNameList . MultiSequence } " ) ) < nl > } < nl > < nl > + def msgDeliveryId ( peer : Peer , randomId : Long ) = < nl > + s " msg _ $ { peer . ` type ` . value } _ $ { peer . id } _ $ { randomId } " < nl > + < nl > def getSeqState ( userId : Int , authId : Long ) : Future [ SeqState ] = < nl > ( region . ref ? Envelope ( userId ) . withGetSeqState ( GetSeqState ( authId ) ) ) . mapTo [ SeqState ] < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > index 62a149c . . 80a199b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > @ @ - 21 , 12 + 21 , 13 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ < nl > * Send update to all devices of user and return ` SeqState ` associated with ` authId ` < nl > * / < nl > def deliverClientUpdate ( < nl > - userId : Int , < nl > - authId : Long , < nl > - update : Update , < nl > - pushRules : PushRules = PushRules ( ) , < nl > - reduceKey : Option [ String ] = None , < nl > - deliveryId : String = " " < nl > + userId : Int , < nl > + authId : Long , < nl > + update : Update , < nl > + pushRules : PushRules = PushRules ( ) , < nl > + reduceKey : Option [ String ] = None , < nl > + deliveryId : String = " " , < nl > + deliveryTag : Option [ String ] = None < nl > ) : Future [ SeqState ] = < nl > deliverUpdate ( < nl > userId , < nl > @ @ - 34 , 7 + 35 , 8 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ < nl > UpdateMapping ( default = Some ( serializedUpdate ( update ) ) ) , < nl > pushRules , < nl > reduceKey , < nl > - deliveryId < nl > + deliveryId , < nl > + deliveryTag < nl > ) < nl > < nl > / * * < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index 59786e3 . . f35f67f 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 9 , 7 + 9 , 7 @ @ import com . typesafe . sbt . SbtMultiJvm . MultiJvmKeys . MultiJvm < nl > import com . typesafe . sbt . packager . archetypes . JavaServerAppPackaging < nl > import com . typesafe . sbt . packager . debian . JDebPackaging < nl > < nl > - object Build extends sbt . Build with Versioning with Releasing with Packaging with StartHook { < nl > + object Build extends sbt . Build with Versioning with Releasing with Packaging { < nl > val ScalaVersion = " 2 . 11 . 8 " < nl > val BotKitVersion = getVersion < nl > < nl > @ @ - 89 , 7 + 89 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing with Packaging wit < nl > " actor " , < nl > file ( " . " ) , < nl > settings = < nl > - startUpSettings + + < nl > packagingSettings + + < nl > defaultSettingsServer + + < nl > Revolver . settings + + < nl > diff - - git a / actor - server / project / StartHook . scala b / actor - server / project / StartHook . scala < nl > deleted file mode 100644 < nl > index 62ca90f . . 0000000 < nl > - - - a / actor - server / project / StartHook . scala < nl > + + + / dev / null < nl > @ @ - 1 , 15 + 0 , 0 @ @ < nl > - package im . actor < nl > - < nl > - import sbt . Keys . _ < nl > - import sbt . _ < nl > - < nl > - private [ actor ] trait StartHook { < nl > - lazy val startUpSettings = Seq ( < nl > - onLoad in Global : = { state = > < nl > - < nl > - println ( " = = = = = = = = = = = = = = hello world " ) < nl > - state < nl > - } < nl > - ) < nl > - < nl > - }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 6d19375 . . 0a7aa53 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 741 , 9 + 741 , 10 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 } 
 
 - / / TODO : channels , don ' t allow non - admin to change topic 
 protected def updateAvatar ( cmd : UpdateAvatar ) : Unit = { 
 - if ( state . nonMember ( cmd . clientUserId ) ) { 
 + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . clientUserId ) ) { 
 + sender ( ) ! notAdmin 
 + } else if ( state . nonMember ( cmd . clientUserId ) ) { 
 sender ( ) ! notMember 
 } else { 
 persist ( AvatarUpdated ( Instant . now , cmd . avatar ) ) { evt ⇒ 
 @ @ - 790 , 10 + 791 , 11 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 } 
 
 - / / TODO : channels , don ' t allow non - admin to change topic 
 protected def updateTitle ( cmd : UpdateTitle ) : Unit = { 
 val title = cmd . title 
 - if ( state . nonMember ( cmd . clientUserId ) ) { 
 + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . clientUserId ) ) { 
 + sender ( ) ! notAdmin 
 + } else if ( state . nonMember ( cmd . clientUserId ) ) { 
 sender ( ) ! notMember 
 } else if ( ! isValidTitle ( title ) ) { 
 sender ( ) ! Status . Failure ( InvalidTitle ) 
 @ @ - 859 , 13 + 861 , 14 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 } 
 
 - / / TODO : channels , don ' t allow non - admin to change topic 
 protected def updateTopic ( cmd : UpdateTopic ) : Unit = { 
 def isValidTopic ( topic : Option [ String ] ) = topic . forall ( _ . length < 255 ) 
 
 val topic = trimToEmpty ( cmd . topic ) 
 
 - if ( state . nonMember ( cmd . clientUserId ) ) { 
 + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . clientUserId ) ) { 
 + sender ( ) ! notAdmin 
 + } else if ( state . nonMember ( cmd . clientUserId ) ) { 
 sender ( ) ! notMember 
 } else if ( ! isValidTopic ( topic ) ) { 
 sender ( ) ! Status . Failure ( TopicTooLong ) 
 @ @ - 1041 , 6 + 1044 , 36 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / TODO : remove deprecated 
 db . run ( GroupUserRepo . makeAdmin ( groupId , cmd . candidateUserId ) ) 
 
 + val adminGROUPUpdates : Future [ SeqStateDate ] = 
 + for { 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + userIds = memberIds + cmd . clientUserId , 
 + updateAdmin 
 + ) 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 + cmd . clientUserId , 
 + cmd . clientAuthId , 
 + memberIds - cmd . clientUserId , 
 + updateMembers 
 + ) 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 + 
 + val adminCHANNELUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push admin changed to all 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + userIds = memberIds + cmd . clientUserId , 
 + updateAdmin 
 + ) 
 + / / push changed members to admins and fresh admin 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 + cmd . clientUserId , 
 + cmd . clientAuthId , 
 + ( newState . adminIds - cmd . clientUserId ) + cmd . candidateUserId , 
 + updateMembers 
 + ) 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 + 
 val result : Future [ ( Vector [ ApiMember ] , SeqStateDate ) ] = for { 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 @ @ - 1058 , 17 + 1091 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - userIds = memberIds + cmd . clientUserId , 
 - updateAdmin 
 - ) 
 - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 - cmd . clientUserId , 
 - cmd . clientAuthId , 
 - memberIds - cmd . clientUserId , 
 - updateMembers 
 - ) 
 - } yield ( members , SeqStateDate ( seq , state , dateMillis ) ) 
 + seqStateDate ← if ( state . typ . isChannel ) adminCHANNELUpdates else adminGROUPUpdates 
 + 
 + } yield ( members , seqStateDate ) 
 
 result pipeTo sender ( ) 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 index e82dbae . . 5433dd0 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 @ @ - 1 , 11 + 1 , 9 @ @ 
 package im . actor . server . dialog 
 
 import akka . actor . ActorSystem 
 - import akka . http . scaladsl . util . FastFuture 
 import im . actor . api . rpc . PeersImplicits 
 import im . actor . api . rpc . counters . { ApiAppCounters , UpdateCountersChanged } 
 import im . actor . api . rpc . messaging . _ 
 - import im . actor . server . db . DbExtension 
 import im . actor . server . messaging . PushText 
 import im . actor . server . model . Peer 
 import im . actor . server . sequence . { PushData , PushRules , SeqState , SeqUpdatesExtension } 
 @ @ - 54 , 7 + 52 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 . withCensoredText ( censoredPushText ) 
 . withPeer ( peer ) 
 ) , 
 - deliveryId = deliveryId ( peer , randomId ) , 
 + deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , 
 deliveryTag = deliveryTag 
 ) 
 } yield ( ) 
 @ @ - 100 , 7 + 98 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 default = Some ( senderUpdate ) , 
 custom = senderAuthId map ( authId ⇒ Map ( authId → senderClientUpdate ) ) getOrElse Map . empty , 
 pushRules = PushRules ( isFat = isFat , excludeAuthIds = senderAuthId . toSeq ) , 
 - deliveryId = deliveryId ( peer , randomId ) , 
 + deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , 
 deliveryTag = deliveryTag 
 ) 
 } 
 @ @ - 134 , 9 + 132 , 6 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 ) 
 } yield ( ) 
 
 - private def deliveryId ( peer : Peer , randomId : Long ) = 
 - s " msg _ $ { peer . ` type ` . value } _ $ { peer . id } _ $ { randomId } " 
 - 
 private def reduceKey ( prefix : String , peer : Peer ) : String = 
 s " $ { prefix } _ $ { peer . ` type ` . value } _ $ { peer . id } " 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 85a5734 . . 6d19375 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 8 , 6 + 8 , 7 @ @ import akka . pattern . pipe 
 import im . actor . api . rpc . Update 
 import im . actor . api . rpc . files . ApiAvatar 
 import im . actor . api . rpc . groups . _ 
 + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessage } 
 import im . actor . api . rpc . users . ApiSex 
 import im . actor . concurrent . FutureExt 
 import im . actor . server . CommonErrors 
 @ @ - 205 , 7 + 206 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / TODO : remove deprecated 
 db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) ) 
 
 - def inviteGROUPUpdates : Future [ SeqState ] = 
 + def inviteGROUPUpdates : Future [ SeqStateDate ] = 
 for { 
 / / push updated members list to inviteeUserId , 
 _ ← seqUpdExt . deliverUserUpdate ( 
 @ @ - 221 , 17 + 222 , 26 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 
 / / push updated members list to all group members except inviteeUserId 
 - seqState ← seqUpdExt . broadcastClientUpdate ( 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 userId = cmd . inviterUserId , 
 authId = cmd . inviterAuthId , 
 bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 update = membersUpdateNew , 
 deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 ) 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - } yield seqState 
 
 - def inviteCHANNELUpdates : Future [ SeqState ] = 
 + / / explicitly send service message 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + cmd . inviterUserId , 
 + cmd . inviterAuthId , 
 + cmd . randomId , 
 + serviceMessage , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + } yield SeqStateDate ( seq , state , date ) 
 + 
 + def inviteCHANNELUpdates : Future [ SeqStateDate ] = 
 for { 
 / / push ` UpdateGroupMembersUpdated ` to invitee only if he is admin . 
 / / invitee could be admin , if he created this group , and turning back 
 @ @ - 258 , 9 + 268 , 24 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 ) 
 
 - / / get current SeqState for inviter user 
 - seqState ← seqUpdExt . getSeqState ( cmd . inviterUserId , cmd . inviterAuthId ) 
 - } yield seqState 
 + / / push service message to invitee 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . inviteeUserId , 
 + authId = 0L , 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + serviceMessage 
 + ) 
 + 
 + / / push service message to inviter and return seqState 
 + SeqState ( seq , state ) ← pushUpdateMessage ( 
 + userId = cmd . inviterUserId , 
 + authId = cmd . inviterAuthId , 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + serviceMessage 
 + ) 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 
 val result : Future [ SeqStateDate ] = for { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 @ @ - 296 , 18 + 321 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - SeqState ( seq , state ) ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates 
 + seqStateDate ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates 
 
 - / / explicitly send service message 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - cmd . inviterUserId , 
 - cmd . inviterAuthId , 
 - cmd . randomId , 
 - serviceMessage , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 - } yield SeqStateDate ( seq , state , date ) 
 + } yield seqStateDate 
 
 result pipeTo sender ( ) 
 } 
 @ @ - 336 , 6 + 352 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val newState = commit ( evt ) 
 
 val date = evt . ts 
 + val dateMillis = date . toEpochMilli 
 val memberIds = newState . memberIds 
 val members = newState . members . values . map ( _ . asStruct ) . toVector 
 val randomId = ACLUtils . randomLong ( ) 
 @ @ - 367 , 7 + 384 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 isAdmin = false 
 ) ) 
 
 - def joinGROUPUpdates : Future [ SeqState ] = 
 + def joinGROUPUpdates : Future [ SeqStateDate ] = 
 for { 
 / / push all group updates to joiningUserId 
 _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 @ @ - 376 , 7 + 393 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 / / push updated members list to joining user , 
 / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 - seqState ← seqUpdExt . deliverClientUpdate ( 
 + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 userId = cmd . joiningUserId , 
 authId = cmd . joiningUserAuthId , 
 update = membersUpdateNew , 
 @ @ - 391 , 9 + 408 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 membersUpdateNew , 
 deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 ) 
 - } yield seqState 
 
 - def joinCHANNELUpdates : Future [ SeqState ] = 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + senderUserId = cmd . joiningUserId , 
 + senderAuthId = cmd . joiningUserAuthId , 
 + randomId = randomId , 
 + serviceMessage / / no delivery tag . This updated handled this way in Groups V1 
 + ) 
 + } yield SeqStateDate ( seq , state , date ) 
 + 
 + def joinCHANNELUpdates : Future [ SeqStateDate ] = 
 for { 
 / / push all group updates to joiningUserId 
 _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 @ @ - 403 , 7 + 428 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / push ` UpdateGroupMembersUpdated ` to joining user only if he is admin . 
 / / joining user can be admin , if he created this group , and turning back 
 / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 - seqState ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { 
 + SeqState ( seq , state ) ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { 
 seqUpdExt . deliverClientUpdate ( 
 userId = cmd . joiningUserId , 
 authId = cmd . joiningUserAuthId , 
 @ @ - 421 , 7 + 446 , 16 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 membersUpdateNew , 
 deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 ) 
 - } yield seqState 
 + 
 + / / push service message to joining user and return seqState 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . joiningUserId , 
 + authId = cmd . joiningUserAuthId , 
 + ts = dateMillis , 
 + randomId = randomId , 
 + serviceMessage 
 + ) 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 
 val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = 
 for { 
 @ @ - 441 , 16 + 475 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - SeqState ( seq , state ) ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates 
 + seqStateDate ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates 
 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - senderUserId = cmd . joiningUserId , 
 - senderAuthId = cmd . joiningUserAuthId , 
 - randomId = randomId , 
 - serviceMessage / / no delivery tag . This updated handled this way in Groups V1 
 - ) 
 - } yield ( SeqStateDate ( seq , state , date ) , memberIds . toVector : + inviterUserId , randomId ) 
 + } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) 
 
 result pipeTo sender ( ) 
 } 
 @ @ - 474 , 11 + 501 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) 
 
 - val leftUserUpdatesNew = List ( 
 - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 - ) 
 + val leftUserUpdatesNew = 
 + if ( state . typ . isChannel ) List ( 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 + ) 
 + else List ( 
 + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 + ) 
 
 val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 
 @ @ - 492 , 6 + 523 , 67 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } yield ( ) 
 ) 
 
 + val leaveGROUPUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members list to all group members 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + state . memberIds - cmd . userId , 
 + membersUpdateNew 
 + ) 
 + 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + senderUserId = cmd . userId , 
 + senderAuthId = cmd . authId , 
 + randomId = cmd . randomId , 
 + message = serviceMessage , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + 
 + / / push left user that he is no longer a member 
 + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 + userId = cmd . userId , 
 + authId = cmd . authId , 
 + update = UpdateGroupMemberChanged ( groupId , isMember = false ) 
 + ) 
 + 
 + / / push left user updates 
 + / / • with empty group members 
 + / / • that he can ' t view and invite members 
 + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 + } 
 + } yield SeqStateDate ( seq , state , date ) 
 + 
 + val leaveCHANNELUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members list to all ADMINS , except userId ( if he was there ) 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + state . adminIds - cmd . userId , 
 + membersUpdateNew 
 + ) 
 + 
 + / / push service message to left user 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . userId , 
 + authId = cmd . authId , 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + message = serviceMessage 
 + ) 
 + 
 + / / push left user that he is no longer a member 
 + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 + userId = cmd . userId , 
 + authId = cmd . authId , 
 + update = UpdateGroupMemberChanged ( groupId , isMember = false ) 
 + ) 
 + 
 + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 + } 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 + 
 / / read this dialog by user that leaves group . don ' t wait for ack 
 dialogExt . messageRead ( apiGroupPeer , cmd . userId , 0L , dateMillis ) 
 val result : Future [ SeqStateDate ] = for { 
 @ @ - 512 , 36 + 604 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - / / push updated members list to all group members 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - state . memberIds - cmd . userId , 
 - membersUpdateNew 
 - ) 
 + seqStateDate ← if ( state . typ . isChannel ) leaveCHANNELUpdates else leaveGROUPUpdates 
 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - senderUserId = cmd . userId , 
 - senderAuthId = cmd . authId , 
 - randomId = cmd . randomId , 
 - message = serviceMessage , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 - 
 - / / push left user that he is no longer a member 
 - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 - userId = cmd . userId , 
 - authId = cmd . authId , 
 - update = UpdateGroupMemberChanged ( groupId , isMember = false ) 
 - ) 
 - 
 - / / push left user updates 
 - / / • with empty group members 
 - / / • that he can ' t view and invite members 
 - _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 - } 
 - 
 - } yield SeqStateDate ( seq , state , date ) 
 + } yield seqStateDate 
 
 result andThen { case _ ⇒ commit ( evt ) } pipeTo sender ( ) 
 } 
 @ @ - 549 , 7 + 614 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 
 protected def kick ( cmd : Kick ) : Unit = { 
 - if ( state . nonMember ( cmd . kickerUserId ) | | state . nonMember ( cmd . kickedUserId ) ) { 
 + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . kickedUserId ) ) { 
 + sender ( ) ! notAdmin 
 + } else if ( state . nonMember ( cmd . kickerUserId ) | | state . nonMember ( cmd . kickedUserId ) ) { 
 sender ( ) ! notMember 
 } else { 
 persist ( UserKicked ( Instant . now , cmd . kickedUserId , cmd . kickerUserId ) ) { evt ⇒ 
 @ @ - 560 , 12 + 627 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val updateObsolete = UpdateGroupUserKickObsolete ( groupId , cmd . kickedUserId , cmd . kickerUserId , dateMillis , cmd . randomId ) 
 
 - val kickedUserUpdatesNew : List [ Update ] = List ( 
 - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , 
 - UpdateGroupMemberChanged ( groupId , isMember = false ) 
 - ) 
 + val kickedUserUpdatesNew : List [ Update ] = 
 + if ( state . typ . isChannel ) List ( 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , 
 + UpdateGroupMemberChanged ( groupId , isMember = false ) 
 + ) 
 + else List ( 
 + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , 
 + UpdateGroupMemberChanged ( groupId , isMember = false ) 
 + ) 
 
 val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 
 @ @ - 579 , 6 + 651 , 68 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } yield ( ) 
 ) 
 
 + val kickGROUPUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members list to all group members . Don ' t push to kicked user ! 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 + userId = cmd . kickerUserId , 
 + authId = cmd . kickerAuthId , 
 + bcastUserIds = newState . memberIds - cmd . kickerUserId , 
 + update = membersUpdateNew 
 + ) 
 + 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + senderUserId = cmd . kickerUserId , 
 + senderAuthId = cmd . kickerAuthId , 
 + randomId = cmd . randomId , 
 + message = serviceMessage , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + 
 + / / push kicked user updates 
 + / / • with empty group members 
 + / / • that he is no longer a member of group 
 + / / • that he can ' t view and invite members 
 + _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) 
 + } 
 + } yield SeqStateDate ( seq , state , date ) 
 + 
 + val kickCHANNELUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members list to all ADMINS . Don ' t push to kicked user ! 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 + userId = cmd . kickerUserId , 
 + authId = cmd . kickerAuthId , 
 + bcastUserIds = newState . adminIds - cmd . kickerUserId , 
 + update = membersUpdateNew 
 + ) 
 + 
 + / / push service message to kicker user 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . kickerUserId , 
 + authId = cmd . kickerAuthId , / / ? ? ? what ' s a point ? 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + serviceMessage 
 + ) 
 + 
 + / / push service message to kicked user 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . kickedUserId , 
 + authId = 0L , 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + serviceMessage 
 + ) 
 + 
 + / / push kicked user updates 
 + _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) 
 + } 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 + 
 / / read this dialog by kicked user . don ' t wait for ack 
 dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) 
 val result : Future [ SeqStateDate ] = for { 
 @ @ - 598 , 32 + 732 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - / / push updated members list to all group members . Don ' t push to kicked user ! 
 - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 - userId = cmd . kickerUserId , 
 - authId = cmd . kickerAuthId , 
 - bcastUserIds = newState . memberIds - cmd . kickerUserId , 
 - update = membersUpdateNew 
 - ) 
 - 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - senderUserId = cmd . kickerUserId , 
 - senderAuthId = cmd . kickerAuthId , 
 - randomId = cmd . randomId , 
 - message = serviceMessage , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 + seqStateDate ← if ( state . typ . isChannel ) kickCHANNELUpdates else kickGROUPUpdates 
 
 - / / push kicked user updates 
 - / / • with empty group members 
 - / / • that he is no longer a member of group 
 - / / • that he can ' t view and invite members 
 - _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) 
 - } 
 - 
 - } yield SeqStateDate ( seq , state , date ) 
 + } yield seqStateDate 
 
 result pipeTo sender ( ) 
 } 
 @ @ - 987 , 6 + 1098 , 26 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 } 
 
 + / / и л и в с е т а к и б у д е т broadcast ? 
 + private def pushUpdateMessage ( userId : Int , authId : Long , ts : Long , randomId : Long , message : ApiMessage ) : Future [ SeqState ] = { 
 + val messUpdate = UpdateMessage ( 
 + peer = apiGroupPeer , 
 + senderUserId = userId , 
 + date = ts , 
 + randomId = randomId , 
 + message = message , 
 + attributes = None , 
 + quotedMessage = None 
 + ) 
 + seqUpdExt . deliverClientUpdate ( 
 + userId = userId , 
 + authId = authId , 
 + update = messUpdate , 
 + deliveryId = seqUpdExt . msgDeliveryId ( apiGroupPeer . asModel , randomId ) , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + } 
 + 
 private def trimToEmpty ( s : Option [ String ] ) : Option [ String ] = 
 s map ( _ . trim ) filter ( _ . nonEmpty ) 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 index 9f0b5ed . . ee7837b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 @ @ - 63 , 6 + 63 , 9 @ @ final class SeqUpdatesExtension ( _ system : ActorSystem ) 
 optTs . getOrElse ( throw new RuntimeException ( s " No Migration timestamp found for $ { MigrationNameList . MultiSequence } " ) ) 
 } 
 
 + def msgDeliveryId ( peer : Peer , randomId : Long ) = 
 + s " msg _ $ { peer . ` type ` . value } _ $ { peer . id } _ $ { randomId } " 
 + 
 def getSeqState ( userId : Int , authId : Long ) : Future [ SeqState ] = 
 ( region . ref ? Envelope ( userId ) . withGetSeqState ( GetSeqState ( authId ) ) ) . mapTo [ SeqState ] 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 index 62a149c . . 80a199b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 @ @ - 21 , 12 + 21 , 13 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ 
 * Send update to all devices of user and return ` SeqState ` associated with ` authId ` 
 * / 
 def deliverClientUpdate ( 
 - userId : Int , 
 - authId : Long , 
 - update : Update , 
 - pushRules : PushRules = PushRules ( ) , 
 - reduceKey : Option [ String ] = None , 
 - deliveryId : String = " " 
 + userId : Int , 
 + authId : Long , 
 + update : Update , 
 + pushRules : PushRules = PushRules ( ) , 
 + reduceKey : Option [ String ] = None , 
 + deliveryId : String = " " , 
 + deliveryTag : Option [ String ] = None 
 ) : Future [ SeqState ] = 
 deliverUpdate ( 
 userId , 
 @ @ - 34 , 7 + 35 , 8 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ 
 UpdateMapping ( default = Some ( serializedUpdate ( update ) ) ) , 
 pushRules , 
 reduceKey , 
 - deliveryId 
 + deliveryId , 
 + deliveryTag 
 ) 
 
 / * * 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index 59786e3 . . f35f67f 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 9 , 7 + 9 , 7 @ @ import com . typesafe . sbt . SbtMultiJvm . MultiJvmKeys . MultiJvm 
 import com . typesafe . sbt . packager . archetypes . JavaServerAppPackaging 
 import com . typesafe . sbt . packager . debian . JDebPackaging 
 
 - object Build extends sbt . Build with Versioning with Releasing with Packaging with StartHook { 
 + object Build extends sbt . Build with Versioning with Releasing with Packaging { 
 val ScalaVersion = " 2 . 11 . 8 " 
 val BotKitVersion = getVersion 
 
 @ @ - 89 , 7 + 89 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing with Packaging wit 
 " actor " , 
 file ( " . " ) , 
 settings = 
 - startUpSettings + + 
 packagingSettings + + 
 defaultSettingsServer + + 
 Revolver . settings + + 
 diff - - git a / actor - server / project / StartHook . scala b / actor - server / project / StartHook . scala 
 deleted file mode 100644 
 index 62ca90f . . 0000000 
 - - - a / actor - server / project / StartHook . scala 
 + + + / dev / null 
 @ @ - 1 , 15 + 0 , 0 @ @ 
 - package im . actor 
 - 
 - import sbt . Keys . _ 
 - import sbt . _ 
 - 
 - private [ actor ] trait StartHook { 
 - lazy val startUpSettings = Seq ( 
 - onLoad in Global : = { state = > 
 - 
 - println ( " = = = = = = = = = = = = = = hello world " ) 
 - state 
 - } 
 - ) 
 - 
 - }
