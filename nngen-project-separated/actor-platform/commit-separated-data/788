BLEU SCORE: 0.08737167851715878

TEST MSG: fix ( server : webrtc ) : end call properly if everyone left
GENERATED MSG: refactor ( server ) : moved actor - social to actor - core

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > index 0c2df69 . . 062069f 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > @ @ - 58 , 7 + 58 , 79 @ @ object WebrtcCallActor { < nl > def props = Props ( classOf [ WebrtcCallActor ] ) < nl > } < nl > < nl > - private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > + private trait Members { < nl > + this : ActorLogging ⇒ < nl > + < nl > + private var members = Map . empty [ UserId , Member ] < nl > + < nl > + sealed trait MemberState < nl > + < nl > + object MemberStates { < nl > + object Ringing extends MemberState < nl > + object RingingReached extends MemberState < nl > + object Connecting extends MemberState < nl > + object Connected extends MemberState < nl > + object Ended extends MemberState < nl > + } < nl > + < nl > + case class Member ( userId : UserId , state : MemberState , isJoined : Boolean ) { < nl > + import MemberStates . _ < nl > + < nl > + lazy val apiState = state match { < nl > + case Ringing ⇒ ApiCallMemberState . RINGING < nl > + case RingingReached ⇒ ApiCallMemberState . RINGING _ REACHED < nl > + case Connecting ⇒ ApiCallMemberState . CONNECTING < nl > + case Connected ⇒ ApiCallMemberState . CONNECTED < nl > + case Ended ⇒ ApiCallMemberState . ENDED < nl > + } < nl > + } < nl > + < nl > + def addMember ( userId : UserId , initState : MemberState , isJoined : Boolean = false ) : Unit = { < nl > + members get userId match { < nl > + case Some ( _ ) ⇒ throw new RuntimeException ( " Attempt to add already existing member " ) < nl > + case None ⇒ < nl > + val member = Member ( userId , initState , isJoined ) < nl > + log . debug ( " Adding member : { } " , member ) < nl > + members + = ( userId → member ) < nl > + } < nl > + } < nl > + < nl > + def setMemberJoined ( userId : UserId , isJoined : Boolean = true ) : Unit = < nl > + members get userId match { < nl > + case Some ( member ) if ! member . isJoined ⇒ members + = userId → member . copy ( isJoined = true ) < nl > + case Some ( _ ) ⇒ throw new RuntimeException ( " Attempt to set member joined who is already joined " ) < nl > + case None ⇒ throw new RuntimeException ( " Attempt to set an unexistent member joined " ) < nl > + } < nl > + < nl > + def setMemberState ( userId : UserId , state : MemberState ) : Unit = < nl > + members get userId match { < nl > + case Some ( member ) ⇒ < nl > + log . debug ( " Changing member [ userId : { } ] state from : { } to : { } " , userId , member . state , state ) < nl > + members + = userId → member . copy ( state = state ) < nl > + case None ⇒ throw new RuntimeException ( " Attempt to change an unexistend member state " ) < nl > + } < nl > + < nl > + def getMember ( userId : UserId ) = members get userId < nl > + < nl > + def memberUserIds = members . keySet < nl > + < nl > + def getMembers = members < nl > + < nl > + def everyoneRejected ( callerUserId : Int ) = < nl > + members . values < nl > + . filterNot ( _ . userId = = callerUserId ) < nl > + . filterNot ( _ . state = = MemberStates . Ended ) < nl > + . isEmpty < nl > + < nl > + def everyoneLeft ( callerUserId : Int ) = { < nl > + val ringing = members . values . filter ( _ . state = = MemberStates . Ringing ) < nl > + val joined = members . values . filter ( _ . isJoined ) < nl > + < nl > + joined . isEmpty & & ringing . isEmpty < nl > + } < nl > + } < nl > + < nl > + private final class WebrtcCallActor extends StashingActor with ActorLogging with Members { < nl > import WebrtcCallMessages . _ < nl > import context . dispatcher < nl > < nl > @ @ - 100 , 7 + 172 , 6 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > private var scheduledUpds = Map . empty [ UserId , Cancellable ] < nl > private var devices = Map . empty [ EventBus . DeviceId , Device ] < nl > private var clients = Map . empty [ EventBus . Client , EventBus . DeviceId ] < nl > - private var participants = Map . empty [ UserId , ApiCallMemberState . Value ] < nl > private var sessions = Map . empty [ Pair , SessionId ] < nl > private var isConversationStarted : Boolean = false < nl > private var peer = Peer ( ) < nl > @ @ - 129 , 8 + 200 , 8 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > < nl > advertiseMaster ( eventBusId , callerDeviceId ) < nl > < nl > - callees foreach ( putParticipant ( _ , ApiCallMemberState . RINGING ) ) < nl > - putParticipant ( callerUserId , ApiCallMemberState . CONNECTED ) < nl > + callees foreach ( userId ⇒ addMember ( userId , MemberStates . Ringing ) ) < nl > + addMember ( callerUserId , MemberStates . Connected , isJoined = true ) < nl > broadcastSyncedSet ( ) < nl > < nl > context become callInProgress ( peer , eventBusId , callerDeviceId , System . currentTimeMillis ( ) , callerUserId ) < nl > @ @ - 158 , 7 + 229 , 7 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > else ApiServiceMessage ( " Missed call " , Some ( ApiServiceExPhoneMissed ) ) < nl > < nl > ( for { < nl > - _ ← if ( peer . ` type ` . isPrivate ) FutureExt . ftraverse ( participants . keySet . toSeq ) ( userId ⇒ dialogExt . sendMessage ( < nl > + _ ← if ( peer . ` type ` . isPrivate ) FutureExt . ftraverse ( memberUserIds . toSeq ) ( userId ⇒ dialogExt . sendMessage ( < nl > peer = ApiPeer ( ApiPeerType . Private , callerUserId ) , < nl > senderUserId = callerUserId , < nl > senderAuthId = None , < nl > @ @ - 203 , 6 + 274 , 7 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > } yield device ) match { < nl > case Some ( device ) ⇒ < nl > putDevice ( device . deviceId , client , device . copy ( isJoined = true ) ) < nl > + setMemberJoined ( userId ) < nl > cancelIncomingCallUpdates ( userId ) < nl > < nl > weakUpdExt . broadcastUserWeakUpdate ( userId , UpdateCallHandled ( id ) , excludeAuthIds = Set ( authId ) ) < nl > @ @ - 232 , 7 + 304 , 7 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > this . isConversationStarted = true < nl > < nl > if ( ! isConnected ( userId ) ) { < nl > - putParticipant ( userId , ApiCallMemberState . CONNECTING ) < nl > + setMemberState ( userId , MemberStates . Connecting ) < nl > broadcastSyncedSet ( ) < nl > } < nl > < nl > @ @ - 242 , 6 + 314 , 12 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > } < nl > case RejectCall ( userId , authId ) ⇒ < nl > cancelIncomingCallUpdates ( userId ) < nl > + setMemberState ( userId , MemberStates . Ended ) < nl > + val client = EventBus . ExternalClient ( userId , authId ) < nl > + for ( deviceId ← clients get client ) { < nl > + clients - = client < nl > + devices - = deviceId < nl > + } < nl > weakUpdExt . broadcastUserWeakUpdate ( userId , UpdateCallHandled ( id ) , excludeAuthIds = Set ( authId ) ) < nl > broadcastSyncedSet ( ) < nl > sender ( ) ! RejectCallAck < nl > @ @ - 249 , 11 + 327 , 9 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > if ( / / If caller changed his mind until anyone picked up < nl > ( ! this . isConversationStarted & & userId = = callerUserId ) | | < nl > / / If everyone rejected dialing , there will no any conversation ; ( < nl > - ( ! this . isConversationStarted & & < nl > - devices . size = = 1 & & < nl > - devices . headOption . exists ( _ . _ 2 . deviceId = = callerDeviceId ) ) ) end ( ) < nl > + ( ! this . isConversationStarted & & everyoneRejected ( callerUserId ) ) ) end ( ) < nl > case GetInfo ⇒ < nl > - sender ( ) ! GetInfoAck ( eventBusId , peer , participants . keySet . toSeq ) < nl > + sender ( ) ! GetInfoAck ( eventBusId , peer , memberUserIds . toSeq ) < nl > case EventBus . Joined ( _ , client , deviceId ) ⇒ < nl > if ( client . isExternal ) < nl > advertiseMaster ( eventBusId , deviceId ) < nl > @ @ - 271 , 12 + 347 , 15 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > < nl > for { < nl > userId ← ebMessage . client . externalUserId < nl > - state ← participants . get ( userId ) < nl > - } yield if ( state = = ApiCallMemberState . RINGING ) putParticipant ( userId , ApiCallMemberState . RINGING _ REACHED ) < nl > + member ← getMember ( userId ) < nl > + } yield { < nl > + if ( member . state = = MemberStates . Ringing ) < nl > + setMemberState ( userId , MemberStates . RingingReached ) < nl > + } < nl > } < nl > case msg : ApiNegotinationSuccessful ⇒ < nl > ebMessage . client . externalUserId foreach { userId ⇒ < nl > - putParticipant ( userId , ApiCallMemberState . CONNECTED ) < nl > + setMemberState ( userId , MemberStates . Connected ) < nl > broadcastSyncedSet ( ) < nl > } < nl > case msg : ApiOnRenegotiationNeeded ⇒ < nl > @ @ - 300 , 12 + 379 , 16 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > case EventBus . Disconnected ( _ , client , deviceId ) ⇒ < nl > removeDevice ( deviceId ) < nl > client . externalUserId foreach { userId ⇒ < nl > - putParticipant ( userId , ApiCallMemberState . ENDED ) < nl > - broadcastSyncedSet ( ) < nl > + if ( ! devices . values . exists ( _ . client . externalUserId . contains ( userId ) ) ) { < nl > + setMemberState ( userId , MemberStates . Ended ) < nl > + broadcastSyncedSet ( ) < nl > + } < nl > } < nl > < nl > - if ( ( ! isConversationStarted & & client . externalUserId . contains ( callerUserId ) ) | | < nl > - ( isConversationStarted & & ! devices . exists ( _ . _ 2 . isJoined ) ) ) end ( ) < nl > + if ( / / no one have been reached and caller left < nl > + ( ! isConversationStarted & & client . externalUserId . contains ( callerUserId ) ) | | < nl > + / / there is no one left who can have a conversation < nl > + ( isConversationStarted & & everyoneLeft ( callerUserId ) ) ) end ( ) < nl > case EventBus . Disposed ( _ ) ⇒ < nl > end ( ) < nl > deleteSyncedSet ( ) < nl > @ @ - 326 , 19 + 409 , 6 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > sessions . keySet . exists ( pair ⇒ userDevices . contains ( pair . left ) | | userDevices . contains ( pair . right ) ) < nl > } < nl > < nl > - private def putParticipant ( userId : Int , state : ApiCallMemberState . Value ) : Unit = { < nl > - participants get userId match { < nl > - case Some ( oldState ) ⇒ < nl > - if ( oldState ! = state ) { < nl > - log . debug ( " Changing participant { } state from { } to { } " , userId , oldState , state ) < nl > - participants + = userId → state < nl > - } else log . error ( " Attempt to change participant state to the same value { } " , state ) < nl > - case None ⇒ < nl > - log . debug ( " Adding participant { } with state { } " , userId , state ) < nl > - participants + = userId → state < nl > - } < nl > - } < nl > - < nl > private def putDevice ( deviceId : EventBus . DeviceId , client : EventBus . Client , device : Device ) : Unit = { < nl > devices + = deviceId → device < nl > clients + = client → deviceId < nl > @ @ - 394 , 8 + 464 , 9 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > < nl > private def broadcastSyncedSet ( ) : Unit = { < nl > val activeCall = < nl > - ApiActiveCall ( id , peer . asStruct , participants . toVector map { < nl > - case ( userId , state ) ⇒ < nl > + ApiActiveCall ( id , peer . asStruct , getMembers . toVector map { < nl > + case ( userId , member ) ⇒ < nl > + val state = member . apiState < nl > < nl > ApiCallMember ( userId , ApiCallMemberStateHolder ( < nl > state = state , < nl > @ @ - 406 , 11 + 477 , 11 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { < nl > fallbackIsEnded = Some ( state = = ApiCallMemberState . ENDED ) < nl > ) ) < nl > } ) . toByteArray < nl > - participants . keySet foreach ( valuesExt . syncedSet . put ( _ , Webrtc . SyncedSetName , id , activeCall ) ) < nl > + memberUserIds foreach ( valuesExt . syncedSet . put ( _ , Webrtc . SyncedSetName , id , activeCall ) ) < nl > } < nl > < nl > private def deleteSyncedSet ( ) : Unit = < nl > - participants . keySet foreach { userId ⇒ < nl > + memberUserIds foreach { userId ⇒ < nl > valuesExt . syncedSet . delete ( userId , Webrtc . SyncedSetName , id ) < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / social / SocialManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / social / SocialManager . scala < nl > new file mode 100644 < nl > index 0000000 . . e12ed1d < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / social / SocialManager . scala < nl > @ @ - 0 , 0 + 1 , 155 @ @ < nl > + package im . actor . server . social < nl > + < nl > + import scala . concurrent . Future < nl > + import scala . concurrent . _ < nl > + import scala . concurrent . duration . _ < nl > + import scala . util . { Success , Failure } < nl > + < nl > + import akka . actor . _ < nl > + import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } < nl > + import akka . pattern . { ask , pipe } < nl > + import akka . util . Timeout < nl > + import slick . driver . PostgresDriver . api . _ < nl > + < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . persist < nl > + < nl > + sealed trait SocialExtension extends Extension { < nl > + val region : SocialManagerRegion < nl > + } < nl > + < nl > + final class SocialExtensionImpl ( system : ActorSystem , db : Database ) extends SocialExtension { < nl > + lazy val region : SocialManagerRegion = SocialManager . startRegion ( ) ( system , db ) < nl > + } < nl > + < nl > + object SocialExtension extends ExtensionId [ SocialExtension ] with ExtensionIdProvider { < nl > + override def lookup = SocialExtension < nl > + < nl > + override def createExtension ( system : ExtendedActorSystem ) = new SocialExtensionImpl ( system , DbExtension ( system ) . db ) < nl > + } < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > + case class SocialManagerRegion ( ref : ActorRef ) < nl > + < nl > + object SocialManager { < nl > + private case class Envelope ( userId : Int , payload : Message ) < nl > + < nl > + private sealed trait Message < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > + private case class RelationsNoted ( userIds : Set [ Int ] ) extends Message < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > + private case class RelationNoted ( userId : Int ) extends Message < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > + private case object GetRelations extends Message < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > + private case class Relations ( userIds : Set [ Int ] ) < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > + private case class Initiated ( userIds : Set [ Int ] ) < nl > + < nl > + private val extractEntityId : ShardRegion . ExtractEntityId = { < nl > + case env @ Envelope ( userId , payload ) ⇒ ( userId . toString , env ) < nl > + } < nl > + < nl > + private val extractShardId : ShardRegion . ExtractShardId = msg ⇒ msg match { < nl > + case Envelope ( userId , _ ) ⇒ ( userId % 100 ) . toString / / TODO : configurable < nl > + } < nl > + < nl > + private val typeName = " SocialManager " < nl > + < nl > + private def startRegion ( props : Props ) ( implicit system : ActorSystem ) : SocialManagerRegion = < nl > + SocialManagerRegion ( ClusterSharding ( system ) . start ( < nl > + typeName = typeName , < nl > + entityProps = props , < nl > + settings = ClusterShardingSettings ( system ) , < nl > + extractEntityId = extractEntityId , < nl > + extractShardId = extractShardId < nl > + ) ) < nl > + < nl > + def startRegion ( ) ( implicit system : ActorSystem , db : Database ) : SocialManagerRegion = < nl > + startRegion ( props ) < nl > + < nl > + def startRegionProxy ( ) ( implicit system : ActorSystem ) : SocialManagerRegion = < nl > + SocialManagerRegion ( ClusterSharding ( system ) . startProxy ( < nl > + typeName = typeName , < nl > + role = None , < nl > + extractEntityId = extractEntityId , < nl > + extractShardId = extractShardId < nl > + ) ) < nl > + < nl > + def props ( implicit db : Database ) = Props ( classOf [ SocialManager ] , db ) < nl > + < nl > + def recordRelations ( userId : Int , relatedTo : Set [ Int ] ) ( implicit region : SocialManagerRegion ) : Unit = { < nl > + region . ref ! Envelope ( userId , RelationsNoted ( relatedTo ) ) < nl > + } < nl > + < nl > + def recordRelation ( userId : Int , relatedTo : Int ) ( implicit region : SocialManagerRegion ) : Unit = { < nl > + region . ref ! Envelope ( userId , RelationNoted ( relatedTo ) ) < nl > + } < nl > + < nl > + def getRelations ( userId : Int ) ( < nl > + implicit < nl > + region : SocialManagerRegion , < nl > + timeout : Timeout , < nl > + ec : ExecutionContext < nl > + ) : Future [ Set [ Int ] ] = { < nl > + region . ref . ask ( Envelope ( userId , GetRelations ) ) . mapTo [ Relations ] map ( _ . userIds ) < nl > + } < nl > + } < nl > + < nl > + class SocialManager ( implicit db : Database ) extends Actor with ActorLogging with Stash { < nl > + import SocialManager . _ < nl > + < nl > + implicit val ec : ExecutionContext = context . dispatcher < nl > + < nl > + context . setReceiveTimeout ( 15 . minutes ) / / TODO : configurable < nl > + < nl > + def receive = { < nl > + case env @ Envelope ( userId , _ ) ⇒ < nl > + stash ( ) < nl > + < nl > + db . run ( persist . social . RelationRepo . find ( userId ) ) onComplete { < nl > + case Success ( userIds ) ⇒ < nl > + self ! Initiated ( userIds . toSet ) < nl > + case Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to load realations " ) < nl > + context . stop ( self ) < nl > + } < nl > + < nl > + context . become ( stashing ) < nl > + case msg ⇒ < nl > + stash ( ) < nl > + } < nl > + < nl > + def stashing : Receive = { < nl > + case Initiated ( userIds : Set [ Int ] ) ⇒ < nl > + unstashAll ( ) < nl > + context . become ( working ( userIds ) ) < nl > + case msg ⇒ < nl > + stash ( ) < nl > + } < nl > + < nl > + def working ( userIds : Set [ Int ] ) : Receive = { < nl > + case env @ Envelope ( userId , RelationsNoted ( notedUserIds ) ) ⇒ < nl > + val uniqUserIds = notedUserIds . diff ( userIds ) . filterNot ( _ = = userId ) < nl > + < nl > + if ( uniqUserIds . nonEmpty ) { < nl > + context . become ( working ( userIds + + uniqUserIds ) ) < nl > + db . run ( persist . social . RelationRepo . create ( userId , uniqUserIds ) ) < nl > + } < nl > + case env @ Envelope ( userId , RelationNoted ( notedUserId ) ) ⇒ < nl > + if ( ! userIds . contains ( notedUserId ) & & userId ! = notedUserId ) { < nl > + context . become ( working ( userIds + notedUserId ) ) < nl > + < nl > + db . run ( persist . social . RelationRepo . create ( userId , notedUserId ) ) < nl > + } < nl > + case env @ Envelope ( userId , GetRelations ) ⇒ < nl > + sender ( ) ! Relations ( userIds ) < nl > + case ReceiveTimeout ⇒ < nl > + context . parent ! ShardRegion . Passivate ( stopMessage = PoisonPill ) < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - social / src / main / scala / im / actor / server / social / SocialManager . scala b / actor - server / actor - social / src / main / scala / im / actor / server / social / SocialManager . scala < nl > deleted file mode 100644 < nl > index e12ed1d . . 0000000 < nl > - - - a / actor - server / actor - social / src / main / scala / im / actor / server / social / SocialManager . scala < nl > + + + / dev / null < nl > @ @ - 1 , 155 + 0 , 0 @ @ < nl > - package im . actor . server . social < nl > - < nl > - import scala . concurrent . Future < nl > - import scala . concurrent . _ < nl > - import scala . concurrent . duration . _ < nl > - import scala . util . { Success , Failure } < nl > - < nl > - import akka . actor . _ < nl > - import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } < nl > - import akka . pattern . { ask , pipe } < nl > - import akka . util . Timeout < nl > - import slick . driver . PostgresDriver . api . _ < nl > - < nl > - import im . actor . server . db . DbExtension < nl > - import im . actor . server . persist < nl > - < nl > - sealed trait SocialExtension extends Extension { < nl > - val region : SocialManagerRegion < nl > - } < nl > - < nl > - final class SocialExtensionImpl ( system : ActorSystem , db : Database ) extends SocialExtension { < nl > - lazy val region : SocialManagerRegion = SocialManager . startRegion ( ) ( system , db ) < nl > - } < nl > - < nl > - object SocialExtension extends ExtensionId [ SocialExtension ] with ExtensionIdProvider { < nl > - override def lookup = SocialExtension < nl > - < nl > - override def createExtension ( system : ExtendedActorSystem ) = new SocialExtensionImpl ( system , DbExtension ( system ) . db ) < nl > - } < nl > - < nl > - @ SerialVersionUID ( 1L ) < nl > - case class SocialManagerRegion ( ref : ActorRef ) < nl > - < nl > - object SocialManager { < nl > - private case class Envelope ( userId : Int , payload : Message ) < nl > - < nl > - private sealed trait Message < nl > - < nl > - @ SerialVersionUID ( 1L ) < nl > - private case class RelationsNoted ( userIds : Set [ Int ] ) extends Message < nl > - < nl > - @ SerialVersionUID ( 1L ) < nl > - private case class RelationNoted ( userId : Int ) extends Message < nl > - < nl > - @ SerialVersionUID ( 1L ) < nl > - private case object GetRelations extends Message < nl > - < nl > - @ SerialVersionUID ( 1L ) < nl > - private case class Relations ( userIds : Set [ Int ] ) < nl > - < nl > - @ SerialVersionUID ( 1L ) < nl > - private case class Initiated ( userIds : Set [ Int ] ) < nl > - < nl > - private val extractEntityId : ShardRegion . ExtractEntityId = { < nl > - case env @ Envelope ( userId , payload ) ⇒ ( userId . toString , env ) < nl > - } < nl > - < nl > - private val extractShardId : ShardRegion . ExtractShardId = msg ⇒ msg match { < nl > - case Envelope ( userId , _ ) ⇒ ( userId % 100 ) . toString / / TODO : configurable < nl > - } < nl > - < nl > - private val typeName = " SocialManager " < nl > - < nl > - private def startRegion ( props : Props ) ( implicit system : ActorSystem ) : SocialManagerRegion = < nl > - SocialManagerRegion ( ClusterSharding ( system ) . start ( < nl > - typeName = typeName , < nl > - entityProps = props , < nl > - settings = ClusterShardingSettings ( system ) , < nl > - extractEntityId = extractEntityId , < nl > - extractShardId = extractShardId < nl > - ) ) < nl > - < nl > - def startRegion ( ) ( implicit system : ActorSystem , db : Database ) : SocialManagerRegion = < nl > - startRegion ( props ) < nl > - < nl > - def startRegionProxy ( ) ( implicit system : ActorSystem ) : SocialManagerRegion = < nl > - SocialManagerRegion ( ClusterSharding ( system ) . startProxy ( < nl > - typeName = typeName , < nl > - role = None , < nl > - extractEntityId = extractEntityId , < nl > - extractShardId = extractShardId < nl > - ) ) < nl > - < nl > - def props ( implicit db : Database ) = Props ( classOf [ SocialManager ] , db ) < nl > - < nl > - def recordRelations ( userId : Int , relatedTo : Set [ Int ] ) ( implicit region : SocialManagerRegion ) : Unit = { < nl > - region . ref ! Envelope ( userId , RelationsNoted ( relatedTo ) ) < nl > - } < nl > - < nl > - def recordRelation ( userId : Int , relatedTo : Int ) ( implicit region : SocialManagerRegion ) : Unit = { < nl > - region . ref ! Envelope ( userId , RelationNoted ( relatedTo ) ) < nl > - } < nl > - < nl > - def getRelations ( userId : Int ) ( < nl > - implicit < nl > - region : SocialManagerRegion , < nl > - timeout : Timeout , < nl > - ec : ExecutionContext < nl > - ) : Future [ Set [ Int ] ] = { < nl > - region . ref . ask ( Envelope ( userId , GetRelations ) ) . mapTo [ Relations ] map ( _ . userIds ) < nl > - } < nl > - } < nl > - < nl > - class SocialManager ( implicit db : Database ) extends Actor with ActorLogging with Stash { < nl > - import SocialManager . _ < nl > - < nl > - implicit val ec : ExecutionContext = context . dispatcher < nl > - < nl > - context . setReceiveTimeout ( 15 . minutes ) / / TODO : configurable < nl > - < nl > - def receive = { < nl > - case env @ Envelope ( userId , _ ) ⇒ < nl > - stash ( ) < nl > - < nl > - db . run ( persist . social . RelationRepo . find ( userId ) ) onComplete { < nl > - case Success ( userIds ) ⇒ < nl > - self ! Initiated ( userIds . toSet ) < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to load realations " ) < nl > - context . stop ( self ) < nl > - } < nl > - < nl > - context . become ( stashing ) < nl > - case msg ⇒ < nl > - stash ( ) < nl > - } < nl > - < nl > - def stashing : Receive = { < nl > - case Initiated ( userIds : Set [ Int ] ) ⇒ < nl > - unstashAll ( ) < nl > - context . become ( working ( userIds ) ) < nl > - case msg ⇒ < nl > - stash ( ) < nl > - } < nl > - < nl > - def working ( userIds : Set [ Int ] ) : Receive = { < nl > - case env @ Envelope ( userId , RelationsNoted ( notedUserIds ) ) ⇒ < nl > - val uniqUserIds = notedUserIds . diff ( userIds ) . filterNot ( _ = = userId ) < nl > - < nl > - if ( uniqUserIds . nonEmpty ) { < nl > - context . become ( working ( userIds + + uniqUserIds ) ) < nl > - db . run ( persist . social . RelationRepo . create ( userId , uniqUserIds ) ) < nl > - } < nl > - case env @ Envelope ( userId , RelationNoted ( notedUserId ) ) ⇒ < nl > - if ( ! userIds . contains ( notedUserId ) & & userId ! = notedUserId ) { < nl > - context . become ( working ( userIds + notedUserId ) ) < nl > - < nl > - db . run ( persist . social . RelationRepo . create ( userId , notedUserId ) ) < nl > - } < nl > - case env @ Envelope ( userId , GetRelations ) ⇒ < nl > - sender ( ) ! Relations ( userIds ) < nl > - case ReceiveTimeout ⇒ < nl > - context . parent ! ShardRegion . Passivate ( stopMessage = PoisonPill ) < nl > - } < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index 77d4808 . . 7d96bfd 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 152 , 7 + 152 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { < nl > settings = defaultSettings + + SbtActorApi . settings + + releaseSettings + + Seq ( < nl > libraryDependencies + + = Dependencies . core < nl > ) < nl > - ) . dependsOn ( actorCodecs , actorModels , actorPersist , actorPresences , actorSocial , actorRuntime ) < nl > + ) . dependsOn ( actorCodecs , actorModels , actorPersist , actorPresences , actorRuntime ) < nl > < nl > lazy val actorEmail = Project ( < nl > id = " actor - email " , < nl > @ @ - 223 , 7 + 223 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { < nl > actorPresences , < nl > actorSessionMessages , < nl > actorSms , < nl > - actorSocial , < nl > actorRuntime ) < nl > < nl > lazy val actorSms = Project ( < nl > @ @ - 232 , 14 + 231 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { < nl > settings = defaultSettings + + releaseSettings + + Seq ( libraryDependencies + + = Dependencies . sms ) < nl > ) . dependsOn ( actorRuntime ) < nl > < nl > - lazy val actorSocial = Project ( < nl > - id = " actor - social " , < nl > - base = file ( " actor - social " ) , < nl > - settings = defaultSettings + + releaseSettings + + Seq ( < nl > - libraryDependencies + + = Dependencies . social < nl > - ) < nl > - ) . dependsOn ( actorPersist ) < nl > - < nl > lazy val actorFrontend = Project ( < nl > id = " actor - frontend " , < nl > base = file ( " actor - frontend " ) , < nl > @ @ - 328 , 8 + 319 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { < nl > actorRuntime , < nl > actorSession , < nl > actorSessionMessages , < nl > - actorSms , < nl > - actorSocial < nl > + actorSms < nl > ) < nl > < nl > lazy val actorTests = Project ( < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index dae99d9 . . e59e88a 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 166 , 8 + 166 , 6 @ @ object Dependencies { < nl > < nl > val sms = shared + + Seq ( akkaActor , akkaHttp , dispatch ) < nl > < nl > - val social = shared : + akkaClusterSharding < nl > - < nl > val codecs = shared + + Seq ( scalazCore , scodecBits , scodecCore ) < nl > < nl > val models = shared + + Seq ( scodecBits , scodecCore , jodaTime , jodaConvert , slickPg )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 index 0c2df69 . . 062069f 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 @ @ - 58 , 7 + 58 , 79 @ @ object WebrtcCallActor { 
 def props = Props ( classOf [ WebrtcCallActor ] ) 
 } 
 
 - private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 + private trait Members { 
 + this : ActorLogging ⇒ 
 + 
 + private var members = Map . empty [ UserId , Member ] 
 + 
 + sealed trait MemberState 
 + 
 + object MemberStates { 
 + object Ringing extends MemberState 
 + object RingingReached extends MemberState 
 + object Connecting extends MemberState 
 + object Connected extends MemberState 
 + object Ended extends MemberState 
 + } 
 + 
 + case class Member ( userId : UserId , state : MemberState , isJoined : Boolean ) { 
 + import MemberStates . _ 
 + 
 + lazy val apiState = state match { 
 + case Ringing ⇒ ApiCallMemberState . RINGING 
 + case RingingReached ⇒ ApiCallMemberState . RINGING _ REACHED 
 + case Connecting ⇒ ApiCallMemberState . CONNECTING 
 + case Connected ⇒ ApiCallMemberState . CONNECTED 
 + case Ended ⇒ ApiCallMemberState . ENDED 
 + } 
 + } 
 + 
 + def addMember ( userId : UserId , initState : MemberState , isJoined : Boolean = false ) : Unit = { 
 + members get userId match { 
 + case Some ( _ ) ⇒ throw new RuntimeException ( " Attempt to add already existing member " ) 
 + case None ⇒ 
 + val member = Member ( userId , initState , isJoined ) 
 + log . debug ( " Adding member : { } " , member ) 
 + members + = ( userId → member ) 
 + } 
 + } 
 + 
 + def setMemberJoined ( userId : UserId , isJoined : Boolean = true ) : Unit = 
 + members get userId match { 
 + case Some ( member ) if ! member . isJoined ⇒ members + = userId → member . copy ( isJoined = true ) 
 + case Some ( _ ) ⇒ throw new RuntimeException ( " Attempt to set member joined who is already joined " ) 
 + case None ⇒ throw new RuntimeException ( " Attempt to set an unexistent member joined " ) 
 + } 
 + 
 + def setMemberState ( userId : UserId , state : MemberState ) : Unit = 
 + members get userId match { 
 + case Some ( member ) ⇒ 
 + log . debug ( " Changing member [ userId : { } ] state from : { } to : { } " , userId , member . state , state ) 
 + members + = userId → member . copy ( state = state ) 
 + case None ⇒ throw new RuntimeException ( " Attempt to change an unexistend member state " ) 
 + } 
 + 
 + def getMember ( userId : UserId ) = members get userId 
 + 
 + def memberUserIds = members . keySet 
 + 
 + def getMembers = members 
 + 
 + def everyoneRejected ( callerUserId : Int ) = 
 + members . values 
 + . filterNot ( _ . userId = = callerUserId ) 
 + . filterNot ( _ . state = = MemberStates . Ended ) 
 + . isEmpty 
 + 
 + def everyoneLeft ( callerUserId : Int ) = { 
 + val ringing = members . values . filter ( _ . state = = MemberStates . Ringing ) 
 + val joined = members . values . filter ( _ . isJoined ) 
 + 
 + joined . isEmpty & & ringing . isEmpty 
 + } 
 + } 
 + 
 + private final class WebrtcCallActor extends StashingActor with ActorLogging with Members { 
 import WebrtcCallMessages . _ 
 import context . dispatcher 
 
 @ @ - 100 , 7 + 172 , 6 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 private var scheduledUpds = Map . empty [ UserId , Cancellable ] 
 private var devices = Map . empty [ EventBus . DeviceId , Device ] 
 private var clients = Map . empty [ EventBus . Client , EventBus . DeviceId ] 
 - private var participants = Map . empty [ UserId , ApiCallMemberState . Value ] 
 private var sessions = Map . empty [ Pair , SessionId ] 
 private var isConversationStarted : Boolean = false 
 private var peer = Peer ( ) 
 @ @ - 129 , 8 + 200 , 8 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 
 advertiseMaster ( eventBusId , callerDeviceId ) 
 
 - callees foreach ( putParticipant ( _ , ApiCallMemberState . RINGING ) ) 
 - putParticipant ( callerUserId , ApiCallMemberState . CONNECTED ) 
 + callees foreach ( userId ⇒ addMember ( userId , MemberStates . Ringing ) ) 
 + addMember ( callerUserId , MemberStates . Connected , isJoined = true ) 
 broadcastSyncedSet ( ) 
 
 context become callInProgress ( peer , eventBusId , callerDeviceId , System . currentTimeMillis ( ) , callerUserId ) 
 @ @ - 158 , 7 + 229 , 7 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 else ApiServiceMessage ( " Missed call " , Some ( ApiServiceExPhoneMissed ) ) 
 
 ( for { 
 - _ ← if ( peer . ` type ` . isPrivate ) FutureExt . ftraverse ( participants . keySet . toSeq ) ( userId ⇒ dialogExt . sendMessage ( 
 + _ ← if ( peer . ` type ` . isPrivate ) FutureExt . ftraverse ( memberUserIds . toSeq ) ( userId ⇒ dialogExt . sendMessage ( 
 peer = ApiPeer ( ApiPeerType . Private , callerUserId ) , 
 senderUserId = callerUserId , 
 senderAuthId = None , 
 @ @ - 203 , 6 + 274 , 7 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 } yield device ) match { 
 case Some ( device ) ⇒ 
 putDevice ( device . deviceId , client , device . copy ( isJoined = true ) ) 
 + setMemberJoined ( userId ) 
 cancelIncomingCallUpdates ( userId ) 
 
 weakUpdExt . broadcastUserWeakUpdate ( userId , UpdateCallHandled ( id ) , excludeAuthIds = Set ( authId ) ) 
 @ @ - 232 , 7 + 304 , 7 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 this . isConversationStarted = true 
 
 if ( ! isConnected ( userId ) ) { 
 - putParticipant ( userId , ApiCallMemberState . CONNECTING ) 
 + setMemberState ( userId , MemberStates . Connecting ) 
 broadcastSyncedSet ( ) 
 } 
 
 @ @ - 242 , 6 + 314 , 12 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 } 
 case RejectCall ( userId , authId ) ⇒ 
 cancelIncomingCallUpdates ( userId ) 
 + setMemberState ( userId , MemberStates . Ended ) 
 + val client = EventBus . ExternalClient ( userId , authId ) 
 + for ( deviceId ← clients get client ) { 
 + clients - = client 
 + devices - = deviceId 
 + } 
 weakUpdExt . broadcastUserWeakUpdate ( userId , UpdateCallHandled ( id ) , excludeAuthIds = Set ( authId ) ) 
 broadcastSyncedSet ( ) 
 sender ( ) ! RejectCallAck 
 @ @ - 249 , 11 + 327 , 9 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 if ( / / If caller changed his mind until anyone picked up 
 ( ! this . isConversationStarted & & userId = = callerUserId ) | | 
 / / If everyone rejected dialing , there will no any conversation ; ( 
 - ( ! this . isConversationStarted & & 
 - devices . size = = 1 & & 
 - devices . headOption . exists ( _ . _ 2 . deviceId = = callerDeviceId ) ) ) end ( ) 
 + ( ! this . isConversationStarted & & everyoneRejected ( callerUserId ) ) ) end ( ) 
 case GetInfo ⇒ 
 - sender ( ) ! GetInfoAck ( eventBusId , peer , participants . keySet . toSeq ) 
 + sender ( ) ! GetInfoAck ( eventBusId , peer , memberUserIds . toSeq ) 
 case EventBus . Joined ( _ , client , deviceId ) ⇒ 
 if ( client . isExternal ) 
 advertiseMaster ( eventBusId , deviceId ) 
 @ @ - 271 , 12 + 347 , 15 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 
 for { 
 userId ← ebMessage . client . externalUserId 
 - state ← participants . get ( userId ) 
 - } yield if ( state = = ApiCallMemberState . RINGING ) putParticipant ( userId , ApiCallMemberState . RINGING _ REACHED ) 
 + member ← getMember ( userId ) 
 + } yield { 
 + if ( member . state = = MemberStates . Ringing ) 
 + setMemberState ( userId , MemberStates . RingingReached ) 
 + } 
 } 
 case msg : ApiNegotinationSuccessful ⇒ 
 ebMessage . client . externalUserId foreach { userId ⇒ 
 - putParticipant ( userId , ApiCallMemberState . CONNECTED ) 
 + setMemberState ( userId , MemberStates . Connected ) 
 broadcastSyncedSet ( ) 
 } 
 case msg : ApiOnRenegotiationNeeded ⇒ 
 @ @ - 300 , 12 + 379 , 16 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 case EventBus . Disconnected ( _ , client , deviceId ) ⇒ 
 removeDevice ( deviceId ) 
 client . externalUserId foreach { userId ⇒ 
 - putParticipant ( userId , ApiCallMemberState . ENDED ) 
 - broadcastSyncedSet ( ) 
 + if ( ! devices . values . exists ( _ . client . externalUserId . contains ( userId ) ) ) { 
 + setMemberState ( userId , MemberStates . Ended ) 
 + broadcastSyncedSet ( ) 
 + } 
 } 
 
 - if ( ( ! isConversationStarted & & client . externalUserId . contains ( callerUserId ) ) | | 
 - ( isConversationStarted & & ! devices . exists ( _ . _ 2 . isJoined ) ) ) end ( ) 
 + if ( / / no one have been reached and caller left 
 + ( ! isConversationStarted & & client . externalUserId . contains ( callerUserId ) ) | | 
 + / / there is no one left who can have a conversation 
 + ( isConversationStarted & & everyoneLeft ( callerUserId ) ) ) end ( ) 
 case EventBus . Disposed ( _ ) ⇒ 
 end ( ) 
 deleteSyncedSet ( ) 
 @ @ - 326 , 19 + 409 , 6 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 sessions . keySet . exists ( pair ⇒ userDevices . contains ( pair . left ) | | userDevices . contains ( pair . right ) ) 
 } 
 
 - private def putParticipant ( userId : Int , state : ApiCallMemberState . Value ) : Unit = { 
 - participants get userId match { 
 - case Some ( oldState ) ⇒ 
 - if ( oldState ! = state ) { 
 - log . debug ( " Changing participant { } state from { } to { } " , userId , oldState , state ) 
 - participants + = userId → state 
 - } else log . error ( " Attempt to change participant state to the same value { } " , state ) 
 - case None ⇒ 
 - log . debug ( " Adding participant { } with state { } " , userId , state ) 
 - participants + = userId → state 
 - } 
 - } 
 - 
 private def putDevice ( deviceId : EventBus . DeviceId , client : EventBus . Client , device : Device ) : Unit = { 
 devices + = deviceId → device 
 clients + = client → deviceId 
 @ @ - 394 , 8 + 464 , 9 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 
 private def broadcastSyncedSet ( ) : Unit = { 
 val activeCall = 
 - ApiActiveCall ( id , peer . asStruct , participants . toVector map { 
 - case ( userId , state ) ⇒ 
 + ApiActiveCall ( id , peer . asStruct , getMembers . toVector map { 
 + case ( userId , member ) ⇒ 
 + val state = member . apiState 
 
 ApiCallMember ( userId , ApiCallMemberStateHolder ( 
 state = state , 
 @ @ - 406 , 11 + 477 , 11 @ @ private final class WebrtcCallActor extends StashingActor with ActorLogging { 
 fallbackIsEnded = Some ( state = = ApiCallMemberState . ENDED ) 
 ) ) 
 } ) . toByteArray 
 - participants . keySet foreach ( valuesExt . syncedSet . put ( _ , Webrtc . SyncedSetName , id , activeCall ) ) 
 + memberUserIds foreach ( valuesExt . syncedSet . put ( _ , Webrtc . SyncedSetName , id , activeCall ) ) 
 } 
 
 private def deleteSyncedSet ( ) : Unit = 
 - participants . keySet foreach { userId ⇒ 
 + memberUserIds foreach { userId ⇒ 
 valuesExt . syncedSet . delete ( userId , Webrtc . SyncedSetName , id ) 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / social / SocialManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / social / SocialManager . scala 
 new file mode 100644 
 index 0000000 . . e12ed1d 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / social / SocialManager . scala 
 @ @ - 0 , 0 + 1 , 155 @ @ 
 + package im . actor . server . social 
 + 
 + import scala . concurrent . Future 
 + import scala . concurrent . _ 
 + import scala . concurrent . duration . _ 
 + import scala . util . { Success , Failure } 
 + 
 + import akka . actor . _ 
 + import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } 
 + import akka . pattern . { ask , pipe } 
 + import akka . util . Timeout 
 + import slick . driver . PostgresDriver . api . _ 
 + 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . persist 
 + 
 + sealed trait SocialExtension extends Extension { 
 + val region : SocialManagerRegion 
 + } 
 + 
 + final class SocialExtensionImpl ( system : ActorSystem , db : Database ) extends SocialExtension { 
 + lazy val region : SocialManagerRegion = SocialManager . startRegion ( ) ( system , db ) 
 + } 
 + 
 + object SocialExtension extends ExtensionId [ SocialExtension ] with ExtensionIdProvider { 
 + override def lookup = SocialExtension 
 + 
 + override def createExtension ( system : ExtendedActorSystem ) = new SocialExtensionImpl ( system , DbExtension ( system ) . db ) 
 + } 
 + 
 + @ SerialVersionUID ( 1L ) 
 + case class SocialManagerRegion ( ref : ActorRef ) 
 + 
 + object SocialManager { 
 + private case class Envelope ( userId : Int , payload : Message ) 
 + 
 + private sealed trait Message 
 + 
 + @ SerialVersionUID ( 1L ) 
 + private case class RelationsNoted ( userIds : Set [ Int ] ) extends Message 
 + 
 + @ SerialVersionUID ( 1L ) 
 + private case class RelationNoted ( userId : Int ) extends Message 
 + 
 + @ SerialVersionUID ( 1L ) 
 + private case object GetRelations extends Message 
 + 
 + @ SerialVersionUID ( 1L ) 
 + private case class Relations ( userIds : Set [ Int ] ) 
 + 
 + @ SerialVersionUID ( 1L ) 
 + private case class Initiated ( userIds : Set [ Int ] ) 
 + 
 + private val extractEntityId : ShardRegion . ExtractEntityId = { 
 + case env @ Envelope ( userId , payload ) ⇒ ( userId . toString , env ) 
 + } 
 + 
 + private val extractShardId : ShardRegion . ExtractShardId = msg ⇒ msg match { 
 + case Envelope ( userId , _ ) ⇒ ( userId % 100 ) . toString / / TODO : configurable 
 + } 
 + 
 + private val typeName = " SocialManager " 
 + 
 + private def startRegion ( props : Props ) ( implicit system : ActorSystem ) : SocialManagerRegion = 
 + SocialManagerRegion ( ClusterSharding ( system ) . start ( 
 + typeName = typeName , 
 + entityProps = props , 
 + settings = ClusterShardingSettings ( system ) , 
 + extractEntityId = extractEntityId , 
 + extractShardId = extractShardId 
 + ) ) 
 + 
 + def startRegion ( ) ( implicit system : ActorSystem , db : Database ) : SocialManagerRegion = 
 + startRegion ( props ) 
 + 
 + def startRegionProxy ( ) ( implicit system : ActorSystem ) : SocialManagerRegion = 
 + SocialManagerRegion ( ClusterSharding ( system ) . startProxy ( 
 + typeName = typeName , 
 + role = None , 
 + extractEntityId = extractEntityId , 
 + extractShardId = extractShardId 
 + ) ) 
 + 
 + def props ( implicit db : Database ) = Props ( classOf [ SocialManager ] , db ) 
 + 
 + def recordRelations ( userId : Int , relatedTo : Set [ Int ] ) ( implicit region : SocialManagerRegion ) : Unit = { 
 + region . ref ! Envelope ( userId , RelationsNoted ( relatedTo ) ) 
 + } 
 + 
 + def recordRelation ( userId : Int , relatedTo : Int ) ( implicit region : SocialManagerRegion ) : Unit = { 
 + region . ref ! Envelope ( userId , RelationNoted ( relatedTo ) ) 
 + } 
 + 
 + def getRelations ( userId : Int ) ( 
 + implicit 
 + region : SocialManagerRegion , 
 + timeout : Timeout , 
 + ec : ExecutionContext 
 + ) : Future [ Set [ Int ] ] = { 
 + region . ref . ask ( Envelope ( userId , GetRelations ) ) . mapTo [ Relations ] map ( _ . userIds ) 
 + } 
 + } 
 + 
 + class SocialManager ( implicit db : Database ) extends Actor with ActorLogging with Stash { 
 + import SocialManager . _ 
 + 
 + implicit val ec : ExecutionContext = context . dispatcher 
 + 
 + context . setReceiveTimeout ( 15 . minutes ) / / TODO : configurable 
 + 
 + def receive = { 
 + case env @ Envelope ( userId , _ ) ⇒ 
 + stash ( ) 
 + 
 + db . run ( persist . social . RelationRepo . find ( userId ) ) onComplete { 
 + case Success ( userIds ) ⇒ 
 + self ! Initiated ( userIds . toSet ) 
 + case Failure ( e ) ⇒ 
 + log . error ( e , " Failed to load realations " ) 
 + context . stop ( self ) 
 + } 
 + 
 + context . become ( stashing ) 
 + case msg ⇒ 
 + stash ( ) 
 + } 
 + 
 + def stashing : Receive = { 
 + case Initiated ( userIds : Set [ Int ] ) ⇒ 
 + unstashAll ( ) 
 + context . become ( working ( userIds ) ) 
 + case msg ⇒ 
 + stash ( ) 
 + } 
 + 
 + def working ( userIds : Set [ Int ] ) : Receive = { 
 + case env @ Envelope ( userId , RelationsNoted ( notedUserIds ) ) ⇒ 
 + val uniqUserIds = notedUserIds . diff ( userIds ) . filterNot ( _ = = userId ) 
 + 
 + if ( uniqUserIds . nonEmpty ) { 
 + context . become ( working ( userIds + + uniqUserIds ) ) 
 + db . run ( persist . social . RelationRepo . create ( userId , uniqUserIds ) ) 
 + } 
 + case env @ Envelope ( userId , RelationNoted ( notedUserId ) ) ⇒ 
 + if ( ! userIds . contains ( notedUserId ) & & userId ! = notedUserId ) { 
 + context . become ( working ( userIds + notedUserId ) ) 
 + 
 + db . run ( persist . social . RelationRepo . create ( userId , notedUserId ) ) 
 + } 
 + case env @ Envelope ( userId , GetRelations ) ⇒ 
 + sender ( ) ! Relations ( userIds ) 
 + case ReceiveTimeout ⇒ 
 + context . parent ! ShardRegion . Passivate ( stopMessage = PoisonPill ) 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - social / src / main / scala / im / actor / server / social / SocialManager . scala b / actor - server / actor - social / src / main / scala / im / actor / server / social / SocialManager . scala 
 deleted file mode 100644 
 index e12ed1d . . 0000000 
 - - - a / actor - server / actor - social / src / main / scala / im / actor / server / social / SocialManager . scala 
 + + + / dev / null 
 @ @ - 1 , 155 + 0 , 0 @ @ 
 - package im . actor . server . social 
 - 
 - import scala . concurrent . Future 
 - import scala . concurrent . _ 
 - import scala . concurrent . duration . _ 
 - import scala . util . { Success , Failure } 
 - 
 - import akka . actor . _ 
 - import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } 
 - import akka . pattern . { ask , pipe } 
 - import akka . util . Timeout 
 - import slick . driver . PostgresDriver . api . _ 
 - 
 - import im . actor . server . db . DbExtension 
 - import im . actor . server . persist 
 - 
 - sealed trait SocialExtension extends Extension { 
 - val region : SocialManagerRegion 
 - } 
 - 
 - final class SocialExtensionImpl ( system : ActorSystem , db : Database ) extends SocialExtension { 
 - lazy val region : SocialManagerRegion = SocialManager . startRegion ( ) ( system , db ) 
 - } 
 - 
 - object SocialExtension extends ExtensionId [ SocialExtension ] with ExtensionIdProvider { 
 - override def lookup = SocialExtension 
 - 
 - override def createExtension ( system : ExtendedActorSystem ) = new SocialExtensionImpl ( system , DbExtension ( system ) . db ) 
 - } 
 - 
 - @ SerialVersionUID ( 1L ) 
 - case class SocialManagerRegion ( ref : ActorRef ) 
 - 
 - object SocialManager { 
 - private case class Envelope ( userId : Int , payload : Message ) 
 - 
 - private sealed trait Message 
 - 
 - @ SerialVersionUID ( 1L ) 
 - private case class RelationsNoted ( userIds : Set [ Int ] ) extends Message 
 - 
 - @ SerialVersionUID ( 1L ) 
 - private case class RelationNoted ( userId : Int ) extends Message 
 - 
 - @ SerialVersionUID ( 1L ) 
 - private case object GetRelations extends Message 
 - 
 - @ SerialVersionUID ( 1L ) 
 - private case class Relations ( userIds : Set [ Int ] ) 
 - 
 - @ SerialVersionUID ( 1L ) 
 - private case class Initiated ( userIds : Set [ Int ] ) 
 - 
 - private val extractEntityId : ShardRegion . ExtractEntityId = { 
 - case env @ Envelope ( userId , payload ) ⇒ ( userId . toString , env ) 
 - } 
 - 
 - private val extractShardId : ShardRegion . ExtractShardId = msg ⇒ msg match { 
 - case Envelope ( userId , _ ) ⇒ ( userId % 100 ) . toString / / TODO : configurable 
 - } 
 - 
 - private val typeName = " SocialManager " 
 - 
 - private def startRegion ( props : Props ) ( implicit system : ActorSystem ) : SocialManagerRegion = 
 - SocialManagerRegion ( ClusterSharding ( system ) . start ( 
 - typeName = typeName , 
 - entityProps = props , 
 - settings = ClusterShardingSettings ( system ) , 
 - extractEntityId = extractEntityId , 
 - extractShardId = extractShardId 
 - ) ) 
 - 
 - def startRegion ( ) ( implicit system : ActorSystem , db : Database ) : SocialManagerRegion = 
 - startRegion ( props ) 
 - 
 - def startRegionProxy ( ) ( implicit system : ActorSystem ) : SocialManagerRegion = 
 - SocialManagerRegion ( ClusterSharding ( system ) . startProxy ( 
 - typeName = typeName , 
 - role = None , 
 - extractEntityId = extractEntityId , 
 - extractShardId = extractShardId 
 - ) ) 
 - 
 - def props ( implicit db : Database ) = Props ( classOf [ SocialManager ] , db ) 
 - 
 - def recordRelations ( userId : Int , relatedTo : Set [ Int ] ) ( implicit region : SocialManagerRegion ) : Unit = { 
 - region . ref ! Envelope ( userId , RelationsNoted ( relatedTo ) ) 
 - } 
 - 
 - def recordRelation ( userId : Int , relatedTo : Int ) ( implicit region : SocialManagerRegion ) : Unit = { 
 - region . ref ! Envelope ( userId , RelationNoted ( relatedTo ) ) 
 - } 
 - 
 - def getRelations ( userId : Int ) ( 
 - implicit 
 - region : SocialManagerRegion , 
 - timeout : Timeout , 
 - ec : ExecutionContext 
 - ) : Future [ Set [ Int ] ] = { 
 - region . ref . ask ( Envelope ( userId , GetRelations ) ) . mapTo [ Relations ] map ( _ . userIds ) 
 - } 
 - } 
 - 
 - class SocialManager ( implicit db : Database ) extends Actor with ActorLogging with Stash { 
 - import SocialManager . _ 
 - 
 - implicit val ec : ExecutionContext = context . dispatcher 
 - 
 - context . setReceiveTimeout ( 15 . minutes ) / / TODO : configurable 
 - 
 - def receive = { 
 - case env @ Envelope ( userId , _ ) ⇒ 
 - stash ( ) 
 - 
 - db . run ( persist . social . RelationRepo . find ( userId ) ) onComplete { 
 - case Success ( userIds ) ⇒ 
 - self ! Initiated ( userIds . toSet ) 
 - case Failure ( e ) ⇒ 
 - log . error ( e , " Failed to load realations " ) 
 - context . stop ( self ) 
 - } 
 - 
 - context . become ( stashing ) 
 - case msg ⇒ 
 - stash ( ) 
 - } 
 - 
 - def stashing : Receive = { 
 - case Initiated ( userIds : Set [ Int ] ) ⇒ 
 - unstashAll ( ) 
 - context . become ( working ( userIds ) ) 
 - case msg ⇒ 
 - stash ( ) 
 - } 
 - 
 - def working ( userIds : Set [ Int ] ) : Receive = { 
 - case env @ Envelope ( userId , RelationsNoted ( notedUserIds ) ) ⇒ 
 - val uniqUserIds = notedUserIds . diff ( userIds ) . filterNot ( _ = = userId ) 
 - 
 - if ( uniqUserIds . nonEmpty ) { 
 - context . become ( working ( userIds + + uniqUserIds ) ) 
 - db . run ( persist . social . RelationRepo . create ( userId , uniqUserIds ) ) 
 - } 
 - case env @ Envelope ( userId , RelationNoted ( notedUserId ) ) ⇒ 
 - if ( ! userIds . contains ( notedUserId ) & & userId ! = notedUserId ) { 
 - context . become ( working ( userIds + notedUserId ) ) 
 - 
 - db . run ( persist . social . RelationRepo . create ( userId , notedUserId ) ) 
 - } 
 - case env @ Envelope ( userId , GetRelations ) ⇒ 
 - sender ( ) ! Relations ( userIds ) 
 - case ReceiveTimeout ⇒ 
 - context . parent ! ShardRegion . Passivate ( stopMessage = PoisonPill ) 
 - } 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index 77d4808 . . 7d96bfd 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 152 , 7 + 152 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { 
 settings = defaultSettings + + SbtActorApi . settings + + releaseSettings + + Seq ( 
 libraryDependencies + + = Dependencies . core 
 ) 
 - ) . dependsOn ( actorCodecs , actorModels , actorPersist , actorPresences , actorSocial , actorRuntime ) 
 + ) . dependsOn ( actorCodecs , actorModels , actorPersist , actorPresences , actorRuntime ) 
 
 lazy val actorEmail = Project ( 
 id = " actor - email " , 
 @ @ - 223 , 7 + 223 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { 
 actorPresences , 
 actorSessionMessages , 
 actorSms , 
 - actorSocial , 
 actorRuntime ) 
 
 lazy val actorSms = Project ( 
 @ @ - 232 , 14 + 231 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { 
 settings = defaultSettings + + releaseSettings + + Seq ( libraryDependencies + + = Dependencies . sms ) 
 ) . dependsOn ( actorRuntime ) 
 
 - lazy val actorSocial = Project ( 
 - id = " actor - social " , 
 - base = file ( " actor - social " ) , 
 - settings = defaultSettings + + releaseSettings + + Seq ( 
 - libraryDependencies + + = Dependencies . social 
 - ) 
 - ) . dependsOn ( actorPersist ) 
 - 
 lazy val actorFrontend = Project ( 
 id = " actor - frontend " , 
 base = file ( " actor - frontend " ) , 
 @ @ - 328 , 8 + 319 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { 
 actorRuntime , 
 actorSession , 
 actorSessionMessages , 
 - actorSms , 
 - actorSocial 
 + actorSms 
 ) 
 
 lazy val actorTests = Project ( 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index dae99d9 . . e59e88a 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 166 , 8 + 166 , 6 @ @ object Dependencies { 
 
 val sms = shared + + Seq ( akkaActor , akkaHttp , dispatch ) 
 
 - val social = shared : + akkaClusterSharding 
 - 
 val codecs = shared + + Seq ( scalazCore , scodecBits , scodecCore ) 
 
 val models = shared + + Seq ( scodecBits , scodecCore , jodaTime , jodaConvert , slickPg )
