BLEU SCORE: 0.19640732545025652

TEST MSG: feat ( server : rpc ) : privacy service implementation
GENERATED MSG: feat ( rpc ) : add contact registration for emails

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json < nl > index 02a781c . . fa5d576 100644 < nl > - - - a / actor - server / actor - core / src / main / actor - api / actor . json < nl > + + + b / actor - server / actor - core / src / main / actor - api / actor . json < nl > @ @ - 3188 , 6 + 3188 , 160 @ @ < nl > ] < nl > } , < nl > { < nl > + " title " : " Privacy " , < nl > + " package " : " privacy " , < nl > + " items " : [ < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " BlockUser " , < nl > + " header " : 2636 , < nl > + " response " : { < nl > + " type " : " reference " , < nl > + " name " : " Seq " < nl > + } , < nl > + " doc " : [ < nl > + " Block User " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " peer " , < nl > + " category " : " full " , < nl > + " description " : " Peer for blocking " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " UserOutPeer " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " peer " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " UnblockUser " , < nl > + " header " : 2637 , < nl > + " response " : { < nl > + " type " : " reference " , < nl > + " name " : " Seq " < nl > + } , < nl > + " doc " : [ < nl > + " Unblock User " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " peer " , < nl > + " category " : " full " , < nl > + " description " : " Peer for unblocking " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " UserOutPeer " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " peer " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " LoadBlockedUsers " , < nl > + " header " : 2638 , < nl > + " response " : { < nl > + " type " : " anonymous " , < nl > + " header " : 2639 , < nl > + " doc " : [ < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " userPeers " , < nl > + " category " : " full " , < nl > + " description " : " Blocked user peers " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " UserOutPeer " < nl > + } < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " userPeers " < nl > + } < nl > + ] < nl > + } , < nl > + " doc " : [ < nl > + " Load Blocked Users " < nl > + ] , < nl > + " attributes " : [ ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " update " , < nl > + " content " : { < nl > + " name " : " UserBlocked " , < nl > + " header " : 2629 , < nl > + " doc " : [ < nl > + " Update about User Blocked " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " uid " , < nl > + " category " : " full " , < nl > + " description " : " User Id " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " userId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " uid " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " update " , < nl > + " content " : { < nl > + " name " : " UserUnblocked " , < nl > + " header " : 2630 , < nl > + " doc " : [ < nl > + " Update about User Unblocked " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " uid " , < nl > + " category " : " full " , < nl > + " description " : " User Id " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " userId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " uid " < nl > + } < nl > + ] < nl > + } < nl > + } < nl > + ] < nl > + } , < nl > + { < nl > " title " : " Messaging " , < nl > " package " : " messaging " , < nl > " doc " : [ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index b1d6392 . . 93b3b91 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 18 , 7 + 18 , 7 @ @ import im . actor . server . acl . ACLUtils < nl > import im . actor . server . bots . BotCommand < nl > import im . actor . server . file . { Avatar , ImageUtils } < nl > import im . actor . server . model . { AvatarData , Sex , User } < nl > - import im . actor . server . model . contact . { UserContact , UserEmailContact , UserPhoneContact } < nl > + import im . actor . server . model . contact . { ContactStatus , UserContact , UserEmailContact , UserPhoneContact } < nl > import im . actor . server . office . EntityNotFound < nl > import im . actor . server . persist . contact . _ < nl > import im . actor . server . persist . _ < nl > @ @ - 360 , 12 + 360 , 12 @ @ private [ user ] trait UserCommandHandlers { < nl > ) : Unit = { < nl > val ( idsLocalNames , plains , phones , emails ) = contactsToAdd . view . map { < nl > case UserCommands . ContactToAdd ( contactUserId , localNameOpt , phoneOpt , emailOpt ) ⇒ < nl > - val phone = phoneOpt map ( UserPhoneContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) < nl > - val email = emailOpt map ( UserEmailContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) < nl > + val phone = phoneOpt map ( UserPhoneContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false , status = ContactStatus . Approved ) ) < nl > + val email = emailOpt map ( UserEmailContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false , status = ContactStatus . Approved ) ) < nl > val plain = < nl > if ( phone . isDefined | | email . isDefined ) < nl > None < nl > - else Some ( UserContact ( user . id , contactUserId , localNameOpt , isDeleted = false ) ) < nl > + else Some ( UserContact ( user . id , contactUserId , localNameOpt , isDeleted = false , status = ContactStatus . Approved ) ) < nl > < nl > ( ( contactUserId , localNameOpt ) , plain , phone , email ) < nl > } . foldLeft ( Map . empty [ Int , Option [ String ] ] , Seq . empty [ UserContact ] , Seq . empty [ UserPhoneContact ] , Seq . empty [ UserEmailContact ] ) { < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / ContactStatus . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / ContactStatus . scala < nl > new file mode 100644 < nl > index 0000000 . . 64fdd0e < nl > - - - / dev / null < nl > + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / ContactStatus . scala < nl > @ @ - 0 , 0 + 1 , 13 @ @ < nl > + package im . actor . server . model . contact < nl > + < nl > + / / TODO : future implementation < nl > + / / Pending request < nl > + / / Approved request < nl > + / / Ignored request < nl > + / / Block request < nl > + / / No request < nl > + final case class ContactStatus ( intValue : Int ) < nl > + object ContactStatus { < nl > + val Approved = ContactStatus ( 0 ) < nl > + val Blocked = ContactStatus ( 1 ) < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / UserContact . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / UserContact . scala < nl > index 52bfd47 . . 35621dc 100644 < nl > - - - a / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / UserContact . scala < nl > + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / UserContact . scala < nl > @ @ - 1 , 10 + 1 , 30 @ @ < nl > package im . actor . server . model . contact < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - case class UserContact ( ownerUserId : Int , contactUserId : Int , name : Option [ String ] , isDeleted : Boolean ) < nl > + case class UserContact ( < nl > + ownerUserId : Int , < nl > + contactUserId : Int , < nl > + name : Option [ String ] , < nl > + isDeleted : Boolean , < nl > + status : ContactStatus < nl > + ) < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - case class UserPhoneContact ( phoneNumber : Long , ownerUserId : Int , contactUserId : Int , name : Option [ String ] , isDeleted : Boolean ) < nl > + case class UserPhoneContact ( < nl > + phoneNumber : Long , < nl > + ownerUserId : Int , < nl > + contactUserId : Int , < nl > + name : Option [ String ] , < nl > + isDeleted : Boolean , < nl > + status : ContactStatus < nl > + ) < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - case class UserEmailContact ( email : String , ownerUserId : Int , contactUserId : Int , name : Option [ String ] , isDeleted : Boolean ) < nl > \ No newline at end of file < nl > + case class UserEmailContact ( < nl > + email : String , < nl > + ownerUserId : Int , < nl > + contactUserId : Int , < nl > + name : Option [ String ] , < nl > + isDeleted : Boolean , < nl > + status : ContactStatus < nl > + ) < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20160414195336 _ _ AddUserContactStatus . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20160414195336 _ _ AddUserContactStatus . sql < nl > new file mode 100644 < nl > index 0000000 . . 00b3640 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20160414195336 _ _ AddUserContactStatus . sql < nl > @ @ - 0 , 0 + 1 @ @ < nl > + alter table user _ contacts add column status int not null default 0 ; < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / ContactStatusColumnType . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / ContactStatusColumnType . scala < nl > new file mode 100644 < nl > index 0000000 . . 423d877 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / ContactStatusColumnType . scala < nl > @ @ - 0 , 0 + 1 , 8 @ @ < nl > + package im . actor . server . persist . contact < nl > + < nl > + import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + import im . actor . server . model . contact . ContactStatus < nl > + < nl > + object ContactStatusColumnType { < nl > + implicit val actorColumnType = MappedColumnType . base [ ContactStatus , Int ] ( _ . intValue , ContactStatus . apply ) < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala < nl > index bb03cbc . . 1df2ceb 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala < nl > @ @ - 1 , 32 + 1 , 32 @ @ < nl > package im . actor . server . persist . contact < nl > < nl > - import im . actor . server . model . contact . UserContact < nl > + import im . actor . server . model . contact . { ContactStatus , UserContact } < nl > import slick . dbio . Effect . Write < nl > import im . actor . server . db . ActorPostgresDriver . api . _ < nl > import slick . profile . FixedSqlAction < nl > + import ContactStatusColumnType . _ < nl > < nl > private [ contact ] abstract class UserContactBase [ T ] ( tag : Tag , tname : String ) extends Table [ T ] ( tag , tname ) { < nl > def ownerUserId = column [ Int ] ( " owner _ user _ id " , O . PrimaryKey ) < nl > def contactUserId = column [ Int ] ( " contact _ user _ id " , O . PrimaryKey ) < nl > def name = column [ Option [ String ] ] ( " name " ) < nl > def isDeleted = column [ Boolean ] ( " is _ deleted " , O . Default ( false ) ) < nl > + def status = column [ ContactStatus ] ( " contact _ status " ) < nl > < nl > def idx = index ( " idx _ user _ contacts _ owner _ user _ id _ is _ deleted " , ( ownerUserId , isDeleted ) ) < nl > } < nl > < nl > final class UserContactTable ( tag : Tag ) extends UserContactBase [ UserContact ] ( tag , " user _ contacts " ) { < nl > - def * = ( ownerUserId , contactUserId , name , isDeleted ) < > ( UserContact . tupled , UserContact . unapply ) < nl > + def * = ( ownerUserId , contactUserId , name , isDeleted , status ) < > ( UserContact . tupled , UserContact . unapply ) < nl > } < nl > < nl > object UserContactRepo { < nl > val contacts = TableQuery [ UserContactTable ] < nl > val active = contacts . filter ( _ . isDeleted = = = false ) < nl > - < nl > - def byPK ( ownerUserId : Int , contactUserId : Int ) = < nl > - contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId ) < nl > + val blocked = contacts . filter ( _ . status = = = ContactStatus . Blocked ) < nl > < nl > private def byOwnerUserIdNotDeleted ( ownerUserId : Rep [ Int ] ) = < nl > - contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . isDeleted = = = false ) < nl > + active . filter ( _ . ownerUserId = = = ownerUserId ) < nl > < nl > private val byOwnerUserIdNotDeletedC = Compiled ( byOwnerUserIdNotDeleted _ ) < nl > < nl > @ @ - 36 , 6 + 36 , 7 @ @ object UserContactRepo { < nl > < nl > def byPKNotDeleted ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) = < nl > contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId & & c . isDeleted = = = false ) < nl > + < nl > val nameByPKNotDeletedC = Compiled ( < nl > ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) ⇒ < nl > byPKNotDeleted ( ownerUserId , contactUserId ) map ( _ . name ) < nl > @ @ - 55 , 8 + 56 , 7 @ @ object UserContactRepo { < nl > < nl > def exists ( ownerUserId : Int , contactUserId : Int ) = existsC ( ( ownerUserId , contactUserId ) ) . result < nl > < nl > - / / TODO : check usages - make sure they dont need phone number < nl > - def find ( ownerUserId : Int , contactUserId : Int ) = < nl > + def find ( ownerUserId : Int , contactUserId : Int ) : DBIO [ Option [ UserContact ] ] = < nl > byPKNotDeleted ( ownerUserId , contactUserId ) . result . headOption < nl > < nl > def count ( ownerUserId : Int ) = countC ( ownerUserId ) . result < nl > @ @ - 82 , 9 + 82 , 23 @ @ object UserContactRepo { < nl > contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId ) . map ( _ . name ) . update ( name ) < nl > } < nl > < nl > + private def byOwnerUserIdBlocked ( ownerUserId : Rep [ Int ] ) = < nl > + blocked . filter ( c ⇒ c . ownerUserId = = = ownerUserId ) < nl > + < nl > + private val byOwnerUserIdBlockedC = Compiled ( byOwnerUserIdBlocked _ ) < nl > + < nl > + def findBlockedIds ( ownerUserId : Int ) : DBIO [ Seq [ Int ] ] = < nl > + byOwnerUserIdBlockedC . applied ( ownerUserId ) . map ( _ . contactUserId ) . result < nl > + < nl > def delete ( ownerUserId : Int , contactUserId : Int ) = < nl > byPKNotDeleted ( ownerUserId , contactUserId ) . map ( _ . isDeleted ) . update ( true ) < nl > < nl > + def block ( ownerUserId : Int , contactUserId : Int ) = < nl > + byPKNotDeleted ( ownerUserId , contactUserId ) . map ( _ . status ) . update ( ContactStatus . Blocked ) < nl > + < nl > + def unblock ( ownerUserId : Int , contactUserId : Int ) = < nl > + byPKNotDeleted ( ownerUserId , contactUserId ) . map ( _ . status ) . update ( ContactStatus . Approved ) < nl > + < nl > def insertOrUpdate ( contact : UserContact ) = < nl > contacts . insertOrUpdate ( contact ) < nl > } < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactRepo . scala < nl > index 4ee37b6 . . 89976f3 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactRepo . scala < nl > @ @ - 2 , 12 + 2 , 13 @ @ package im . actor . server . persist . contact < nl > < nl > import im . actor . server . db . ActorPostgresDriver . api . _ < nl > import im . actor . server . model . contact . UserEmailContact < nl > + import ContactStatusColumnType . _ < nl > < nl > final class UserEmailContactTable ( tag : Tag ) extends UserContactBase [ UserEmailContact ] ( tag , " user _ email _ contacts " ) with InheritingTable { < nl > def email = column [ String ] ( " email " ) < nl > val inherited = UserContactRepo . contacts . baseTableRow < nl > < nl > - def * = ( email , ownerUserId , contactUserId , name , isDeleted ) < > ( UserEmailContact . tupled , UserEmailContact . unapply ) < nl > + def * = ( email , ownerUserId , contactUserId , name , isDeleted , status ) < > ( UserEmailContact . tupled , UserEmailContact . unapply ) < nl > } < nl > < nl > object UserEmailContactRepo { < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactRepo . scala < nl > index f8a8bd9 . . 9cee11b 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactRepo . scala < nl > @ @ - 2 , 12 + 2 , 13 @ @ package im . actor . server . persist . contact < nl > < nl > import im . actor . server . db . ActorPostgresDriver . api . _ < nl > import im . actor . server . model . contact . UserPhoneContact < nl > + import ContactStatusColumnType . _ < nl > < nl > final class UserPhoneContactTable ( tag : Tag ) extends UserContactBase [ UserPhoneContact ] ( tag , " user _ phone _ contacts " ) with InheritingTable { < nl > def phoneNumber = column [ Long ] ( " phone _ number " ) < nl > val inherited = UserContactRepo . contacts . baseTableRow < nl > < nl > - def * = ( phoneNumber , ownerUserId , contactUserId , name , isDeleted ) < > ( UserPhoneContact . tupled , UserPhoneContact . unapply ) < nl > + def * = ( phoneNumber , ownerUserId , contactUserId , name , isDeleted , status ) < > ( UserPhoneContact . tupled , UserPhoneContact . unapply ) < nl > } < nl > < nl > object UserPhoneContactRepo { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / privacy / PrivacyServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / privacy / PrivacyServiceImpl . scala < nl > new file mode 100644 < nl > index 0000000 . . 9d69537 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / privacy / PrivacyServiceImpl . scala < nl > @ @ - 0 , 0 + 1 , 60 @ @ < nl > + package im . actor . server . api . rpc . service . privacy < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . ClientData < nl > + import im . actor . api . rpc . misc . ResponseSeq < nl > + import im . actor . api . rpc . peers . ApiUserOutPeer < nl > + import im . actor . api . rpc . privacy . { PrivacyService , ResponseLoadBlockedUsers , UpdateUserBlocked , UpdateUserUnblocked } < nl > + import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . model . contact . ContactStatus < nl > + import im . actor . server . persist . contact . UserContactRepo < nl > + import im . actor . server . sequence . SeqUpdatesExtension < nl > + < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + < nl > + private object PrivacyServiceErrors { < nl > + val UserAlreadyBlocked = RpcError ( 400 , " USER _ ALREADY _ BLOCKED " , " User is already blocked . " , false , None ) < nl > + val UserNotBlocked = RpcError ( 400 , " USER _ NOT _ BLOCKED " , " User is not blocked . " , false , None ) < nl > + val UserNotFound = RpcError ( 404 , " NOT _ FOUND " , " User is not in contacts . " , false , None ) < nl > + } < nl > + < nl > + final class PrivacyServiceImpl ( implicit system : ActorSystem ) extends PrivacyService { < nl > + import FutureResultRpc . _ < nl > + import PrivacyServiceErrors . _ < nl > + < nl > + implicit protected val ec : ExecutionContext = system . dispatcher < nl > + < nl > + private val db = DbExtension ( system ) . db < nl > + private val seqUpdExt = SeqUpdatesExtension ( system ) < nl > + < nl > + protected def doHandleBlockUser ( peer : ApiUserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + ( for { < nl > + contact ← fromFutureOption ( UserNotFound ) ( db . run ( UserContactRepo . find ( client . userId , peer . userId ) ) ) < nl > + _ ← fromBoolean ( UserAlreadyBlocked ) ( contact . status ! = ContactStatus . Blocked ) < nl > + _ ← fromFuture ( db . run ( UserContactRepo . block ( client . userId , peer . userId ) ) ) < nl > + s ← fromFuture ( seqUpdExt . deliverSingleUpdate ( client . userId , UpdateUserBlocked ( peer . userId ) ) ) < nl > + } yield ResponseSeq ( s . seq , s . state . toByteArray ) ) . value < nl > + } < nl > + < nl > + protected def doHandleUnblockUser ( peer : ApiUserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + ( for { < nl > + contact ← fromFutureOption ( UserNotFound ) ( db . run ( UserContactRepo . find ( client . userId , peer . userId ) ) ) < nl > + _ ← fromBoolean ( UserNotBlocked ) ( contact . status = = ContactStatus . Blocked ) < nl > + _ ← fromFuture ( db . run ( UserContactRepo . unblock ( client . userId , peer . userId ) ) ) < nl > + s ← fromFuture ( seqUpdExt . deliverSingleUpdate ( client . userId , UpdateUserUnblocked ( peer . userId ) ) ) < nl > + } yield ResponseSeq ( s . seq , s . state . toByteArray ) ) . value < nl > + } < nl > + < nl > + protected def doHandleLoadBlockedUsers ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadBlockedUsers ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + for { < nl > + ids ← db . run ( UserContactRepo . findBlockedIds ( client . userId ) ) < nl > + outPeers ← Future . sequence ( ids map ( id ⇒ ACLUtils . getUserOutPeer ( id , client . authId ) ) ) < nl > + } yield Ok ( ResponseLoadBlockedUsers ( outPeers . toVector ) ) < nl > + } < nl > + < nl > + } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserEmail . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserEmail . scala < nl > index c546557 . . 25d736d 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserEmail . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserEmail . scala < nl > @ @ - 24 , 6 + 24 , 9 @ @ object UserEmail { < nl > def byEmail ( email : String ) = < nl > emails . filter ( _ . email = = = email ) < nl > < nl > + def findByEmails ( emailSet : Set [ String ] ) = < nl > + emails . filter ( _ . email inSet emailSet ) . result < nl > + < nl > def find ( email : String ) = < nl > byEmail ( email ) . result . headOption < nl > < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UnregisteredEmailContact . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UnregisteredEmailContact . scala < nl > index 264ba56 . . 9a643fc 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UnregisteredEmailContact . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UnregisteredEmailContact . scala < nl > @ @ - 17 , 6 + 17 , 9 @ @ object UnregisteredEmailContact { < nl > def create ( email : String , ownerUserId : Int , name : Option [ String ] ) = < nl > emailContacts + = models . UnregisteredEmailContact ( email , ownerUserId , name ) < nl > < nl > + def create ( contacts : Seq [ models . UnregisteredEmailContact ] ) = < nl > + emailContacts + + = contacts < nl > + < nl > def createIfNotExists ( email : String , ownerUserId : Int , name : Option [ String ] ) = { < nl > create ( email , ownerUserId , name ) . asTry < nl > } < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContact . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContact . scala < nl > new file mode 100644 < nl > index 0000000 . . 7cf9f5d < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContact . scala < nl > @ @ - 0 , 0 + 1 , 24 @ @ < nl > + package im . actor . server . persist . contact < nl > + < nl > + import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + import im . actor . server . models < nl > + < nl > + class UserEmailContactTable ( tag : Tag ) extends UserContactBase [ models . contact . UserEmailContact ] ( tag , " user _ email _ contacts " ) with InheritingTable { < nl > + def email = column [ String ] ( " email " ) < nl > + val inherited = UserContact . contacts . baseTableRow < nl > + < nl > + def * = ( email , ownerUserId , contactUserId , name , accessSalt , isDeleted ) < > ( models . contact . UserEmailContact . tupled , models . contact . UserEmailContact . unapply ) < nl > + } < nl > + < nl > + object UserEmailContact { < nl > + val econtacts = TableQuery [ UserEmailContactTable ] < nl > + < nl > + def createOrRestore ( ownerUserId : Int , contactUserId : Int , email : String , name : Option [ String ] , accessSalt : String ) = { < nl > + val contact = models . contact . UserEmailContact ( email , ownerUserId , contactUserId , name , accessSalt , false ) < nl > + econtacts . insertOrUpdate ( contact ) < nl > + } < nl > + < nl > + def insertOrUpdate ( contact : models . contact . UserEmailContact ) = < nl > + econtacts . insertOrUpdate ( contact ) < nl > + < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactTable . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactTable . scala < nl > deleted file mode 100644 < nl > index 7cf9f5d . . 0000000 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactTable . scala < nl > + + + / dev / null < nl > @ @ - 1 , 24 + 0 , 0 @ @ < nl > - package im . actor . server . persist . contact < nl > - < nl > - import im . actor . server . db . ActorPostgresDriver . api . _ < nl > - import im . actor . server . models < nl > - < nl > - class UserEmailContactTable ( tag : Tag ) extends UserContactBase [ models . contact . UserEmailContact ] ( tag , " user _ email _ contacts " ) with InheritingTable { < nl > - def email = column [ String ] ( " email " ) < nl > - val inherited = UserContact . contacts . baseTableRow < nl > - < nl > - def * = ( email , ownerUserId , contactUserId , name , accessSalt , isDeleted ) < > ( models . contact . UserEmailContact . tupled , models . contact . UserEmailContact . unapply ) < nl > - } < nl > - < nl > - object UserEmailContact { < nl > - val econtacts = TableQuery [ UserEmailContactTable ] < nl > - < nl > - def createOrRestore ( ownerUserId : Int , contactUserId : Int , email : String , name : Option [ String ] , accessSalt : String ) = { < nl > - val contact = models . contact . UserEmailContact ( email , ownerUserId , contactUserId , name , accessSalt , false ) < nl > - econtacts . insertOrUpdate ( contact ) < nl > - } < nl > - < nl > - def insertOrUpdate ( contact : models . contact . UserEmailContact ) = < nl > - econtacts . insertOrUpdate ( contact ) < nl > - < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala < nl > new file mode 100644 < nl > index 0000000 . . 2b6f064 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala < nl > @ @ - 0 , 0 + 1 , 24 @ @ < nl > + package im . actor . server . persist . contact < nl > + < nl > + import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + import im . actor . server . models < nl > + < nl > + class UserPhoneContactTable ( tag : Tag ) extends UserContactBase [ models . contact . UserPhoneContact ] ( tag , " user _ phone _ contacts " ) with InheritingTable { < nl > + def phoneNumber = column [ Long ] ( " phone _ number " ) < nl > + val inherited = UserContact . contacts . baseTableRow < nl > + < nl > + def * = ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , isDeleted ) < > ( models . contact . UserPhoneContact . tupled , models . contact . UserPhoneContact . unapply ) < nl > + } < nl > + < nl > + object UserPhoneContact { < nl > + val pcontacts = TableQuery [ UserPhoneContactTable ] < nl > + < nl > + def createOrRestore ( ownerUserId : Int , contactUserId : Int , phoneNumber : Long , name : Option [ String ] , accessSalt : String ) = { < nl > + val contact = models . contact . UserPhoneContact ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , false ) < nl > + pcontacts . insertOrUpdate ( contact ) < nl > + } < nl > + < nl > + def insertOrUpdate ( contact : models . contact . UserPhoneContact ) = < nl > + pcontacts . insertOrUpdate ( contact ) < nl > + < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactTable . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactTable . scala < nl > deleted file mode 100644 < nl > index 2b6f064 . . 0000000 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactTable . scala < nl > + + + / dev / null < nl > @ @ - 1 , 24 + 0 , 0 @ @ < nl > - package im . actor . server . persist . contact < nl > - < nl > - import im . actor . server . db . ActorPostgresDriver . api . _ < nl > - import im . actor . server . models < nl > - < nl > - class UserPhoneContactTable ( tag : Tag ) extends UserContactBase [ models . contact . UserPhoneContact ] ( tag , " user _ phone _ contacts " ) with InheritingTable { < nl > - def phoneNumber = column [ Long ] ( " phone _ number " ) < nl > - val inherited = UserContact . contacts . baseTableRow < nl > - < nl > - def * = ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , isDeleted ) < > ( models . contact . UserPhoneContact . tupled , models . contact . UserPhoneContact . unapply ) < nl > - } < nl > - < nl > - object UserPhoneContact { < nl > - val pcontacts = TableQuery [ UserPhoneContactTable ] < nl > - < nl > - def createOrRestore ( ownerUserId : Int , contactUserId : Int , phoneNumber : Long , name : Option [ String ] , accessSalt : String ) = { < nl > - val contact = models . contact . UserPhoneContact ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , false ) < nl > - pcontacts . insertOrUpdate ( contact ) < nl > - } < nl > - < nl > - def insertOrUpdate ( contact : models . contact . UserPhoneContact ) = < nl > - pcontacts . insertOrUpdate ( contact ) < nl > - < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala < nl > index 08a9423 . . 22ae244 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala < nl > @ @ - 5 , 24 + 5 , 23 @ @ import java . security . MessageDigest < nl > import scala . collection . immutable < nl > import scala . concurrent . _ < nl > import scala . concurrent . duration . _ < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > < nl > import akka . actor . _ < nl > import akka . util . Timeout < nl > import scodec . bits . BitVector < nl > import slick . dbio < nl > import slick . dbio . DBIO < nl > - import slick . dbio . Effect . { Write , Read } < nl > + import slick . dbio . Effect . { Read , Write } < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > + import im . actor . api . rpc . DBIOResult . _ < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . contacts . _ < nl > import im . actor . api . rpc . misc . _ < nl > import im . actor . api . rpc . users . { UpdateUserLocalNameChanged , User } < nl > - import im . actor . server < nl > import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } < nl > import im . actor . server . social . { SocialManager , SocialManagerRegion } < nl > - import im . actor . server . util . { UserUtils , ContactsUtils , ACLUtils , PhoneNumber } < nl > + import im . actor . server . util . { ACLUtils , ContactsUtils , PhoneNumber , UserUtils } < nl > import im . actor . server . { models , persist } < nl > < nl > class ContactsServiceImpl ( < nl > @ @ - 48 , 6 + 47 , 8 @ @ class ContactsServiceImpl ( < nl > val ContactNotFound = RpcError ( 404 , " CONTACT _ NOT _ FOUND " , " Contact not found . " , false , None ) < nl > } < nl > < nl > + case class EmailNameUser ( email : String , name : Option [ String ] , userId : Int ) < nl > + < nl > private [ service ] def hashIds ( ids : Seq [ Int ] ) : String = { < nl > val md = MessageDigest . getInstance ( " SHA - 256 " ) < nl > val uids = ids . to [ immutable . SortedSet ] . mkString ( " , " ) < nl > @ @ - 55 , 62 + 56 , 26 @ @ class ContactsServiceImpl ( < nl > } < nl > < nl > override def jhandleImportContacts ( phones : Vector [ PhoneToImport ] , emails : Vector [ EmailToImport ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseImportContacts ] ] = { < nl > - val action = requireAuth ( clientData ) . map { implicit client ⇒ < nl > - persist . UserPhone . findByUserId ( client . userId ) . head . flatMap { currentUserPhone ⇒ < nl > - persist . User . find ( client . userId ) . head . flatMap { currentUser ⇒ < nl > - val filteredPhones = phones . view . filterNot ( _ . phoneNumber = = currentUserPhone . number ) < nl > - < nl > - val ( phoneNumbers , phonesMap ) = filteredPhones . foldLeft ( ( Set . empty [ Long ] , Map . empty [ Long , Option [ String ] ] ) ) { < nl > - case ( ( phonesAcc , mapAcc ) , PhoneToImport ( phone , nameOpt ) ) ⇒ < nl > - PhoneNumber . normalizeLong ( phone , currentUser . countryCode ) match { < nl > - case Some ( normPhone ) ⇒ ( ( phonesAcc + normPhone ) , mapAcc + + Seq ( ( phone , nameOpt ) , ( normPhone , nameOpt ) ) ) < nl > - case None ⇒ ( phonesAcc , mapAcc + ( ( phone , nameOpt ) ) ) < nl > - } < nl > - } < nl > - < nl > - val f = for { < nl > - userPhones ← persist . UserPhone . findByNumbers ( phoneNumbers ) < nl > - ignoredContactsIds ← persist . contact . UserContact . findIds _ all ( client . userId ) < nl > - uniquePhones = userPhones . filter ( p ⇒ ! ignoredContactsIds . contains ( p . userId ) ) < nl > - usersPhones ← DBIO . sequence ( uniquePhones map ( p ⇒ persist . User . find ( p . userId ) . headOption map ( _ . map ( ( _ , p . number ) ) ) ) ) map ( _ . flatten ) / / TODO : # perf lots of sql queries < nl > - } yield { < nl > - usersPhones . foldLeft ( ( immutable . Seq . empty [ ( models . User , Long , Option [ String ] ) ] , immutable . Set . empty [ Int ] , immutable . Set . empty [ Long ] ) ) { < nl > - case ( ( usersPhonesNames , newContactIds , registeredPhones ) , ( user , phone ) ) ⇒ < nl > - ( usersPhonesNames : + Tuple3 ( user , phone , phonesMap ( phone ) ) , < nl > - newContactIds + user . id , < nl > - registeredPhones + phone ) < nl > - } < nl > - } < nl > - < nl > - f flatMap { < nl > - case ( usersPhonesNames , newContactIds , registeredPhoneNumbers ) ⇒ < nl > - actorSystem . log . debug ( " Phone numbers : { } , registered : { } " , phoneNumbers , registeredPhoneNumbers ) < nl > - < nl > - / / TODO : # perf do less queries < nl > - val unregInsertActions = ( phoneNumbers & ~ registeredPhoneNumbers ) . toSeq map { phoneNumber ⇒ < nl > - persist . contact . UnregisteredPhoneContact . createIfNotExists ( phoneNumber , client . userId , phonesMap . get ( phoneNumber ) . getOrElse ( None ) ) < nl > - } < nl > - < nl > - DBIO . sequence ( unregInsertActions ) . flatMap { _ ⇒ < nl > - if ( usersPhonesNames . nonEmpty ) { < nl > - for { < nl > - userStructs ← createAllUserContacts ( client . userId , usersPhonesNames ) < nl > - seqstate ← broadcastClientUpdate ( UpdateContactsAdded ( newContactIds . toVector ) , None ) < nl > - } yield { < nl > - newContactIds . toSeq foreach ( id ⇒ recordRelation ( id , client . userId ) ) < nl > - < nl > - Ok ( ResponseImportContacts ( userStructs . toVector , seqstate . _ 1 , seqstate . _ 2 ) ) < nl > - } < nl > - } else { < nl > - DBIO . successful ( Ok ( ResponseImportContacts ( immutable . Vector . empty , 0 , Array . empty ) ) ) < nl > - } < nl > - } < nl > - } < nl > - } < nl > - } < nl > - } < nl > - < nl > - db . run ( toDBIOAction ( action ) ) / / TODO : transactionally < nl > + val action = < nl > + for { < nl > + client ← fromOption ( CommonErrors . UserNotAuthorized ) ( clientData . optUserId . map ( id ⇒ AuthorizedClientData ( clientData . authId , clientData . sessionId , id ) ) ) < nl > + user ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . User . find ( client . userId ) . headOption ) < nl > + optPhone ← fromDBIO ( persist . UserPhone . findByUserId ( client . userId ) . headOption ) < nl > + optEmail ← fromDBIO ( persist . UserEmail . findByUserId ( client . userId ) . headOption ) < nl > + < nl > + phoneUsers ← fromDBIO ( importPhones ( user , optPhone , phones ) ( client ) ) < nl > + ( pUsers , pUserIds ) = phoneUsers < nl > + < nl > + emailUsersAndIds ← fromDBIO ( importEmails ( user , optEmail , emails ) ( client ) ) < nl > + ( eUsers , eUserIds ) = emailUsersAndIds < nl > + < nl > + seqstate ← fromDBIO ( { < nl > + implicit val c = client < nl > + broadcastClientUpdate ( UpdateContactsAdded ( ( pUserIds + + eUserIds ) . toVector ) , None ) < nl > + } ) < nl > + } yield ResponseImportContacts ( ( pUsers + + eUsers ) . toVector , seqstate . _ 1 , seqstate . _ 2 ) < nl > + < nl > + db . run ( action . run . transactionally ) < nl > } < nl > < nl > override def jhandleGetContacts ( contactsHash : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetContacts ] ] = { < nl > @ @ - 219 , 7 + 184 , 78 @ @ class ContactsServiceImpl ( < nl > db . run ( toDBIOAction ( authorizedAction ) ) < nl > } < nl > < nl > - private def createAllUserContacts ( ownerUserId : Int , usersPhonesNames : immutable . Seq [ ( models . User , Long , Option [ String ] ) ] ) ( implicit client : AuthorizedClientData ) : dbio . DBIOAction [ immutable . Seq [ User ] , NoStream , Read with Write with Read with Read with Read with Read ] = { < nl > + private def importEmails ( user : models . User , optOwnEmail : Option [ models . UserEmail ] , emails : Vector [ EmailToImport ] ) ( implicit client : AuthorizedClientData ) : DBIO [ ( Seq [ User ] , Seq [ Sequence ] ) ] = { < nl > + / / filtering out user ' s own email and making ` Map ` from emails to optional name < nl > + val filtered : Map [ String , Option [ String ] ] = optOwnEmail < nl > + . map ( e ⇒ emails . filterNot ( _ . email = = e . email ) ) . getOrElse ( emails ) < nl > + . map ( e ⇒ e . email → e . name ) . toMap < nl > + val filteredEmails = filtered . keySet < nl > + < nl > + for { < nl > + / / finding emails of users that are registered < nl > + / / but don ' t contain in user ' s contact list < nl > + emailModels ← persist . UserEmail . findByEmails ( filteredEmails ) < nl > + userContacts ← persist . contact . UserContact . findIds _ all ( user . id ) < nl > + newEmailContacts = emailModels . filter ( e ⇒ ! userContacts . contains ( e . userId ) ) < nl > + < nl > + / / registering UserEmailContacts < nl > + newEmailContactsM = newEmailContacts . map ( e ⇒ e . email → e . userId ) . toMap < nl > + emailsNamesUsers = newEmailContactsM . keySet . map ( k ⇒ EmailNameUser ( k , filtered ( k ) , newEmailContactsM ( k ) ) ) < nl > + usersAndIds ← createEmailContacts ( user . id , emailsNamesUsers ) < nl > + < nl > + / / creating unregistered contacts < nl > + unregisteredEmails = filteredEmails - - emailModels . map ( _ . email ) < nl > + unregisteredEmailContacts = unregisteredEmails . map { email ⇒ < nl > + models . UnregisteredEmailContact ( email , user . id , filtered ( email ) ) < nl > + } < nl > + _ ← persist . contact . UnregisteredEmailContact . create ( unregisteredEmailContacts . toSeq ) < nl > + } yield usersAndIds . flatten . unzip < nl > + } < nl > + < nl > + private def importPhones ( user : models . User , optPhone : Option [ models . UserPhone ] , phones : Vector [ PhoneToImport ] ) ( client : AuthorizedClientData ) : DBIO [ ( Seq [ User ] , Set [ Int ] ) ] = { < nl > + val filteredPhones = optPhone . map ( p ⇒ phones . filterNot ( _ . phoneNumber = = p . number ) ) . getOrElse ( phones ) < nl > + < nl > + val ( phoneNumbers , phonesMap ) = filteredPhones . foldLeft ( ( Set . empty [ Long ] , Map . empty [ Long , Option [ String ] ] ) ) { < nl > + case ( ( phonesAcc , mapAcc ) , PhoneToImport ( phone , nameOpt ) ) ⇒ < nl > + PhoneNumber . normalizeLong ( phone , user . countryCode ) match { < nl > + case Some ( normPhone ) ⇒ ( ( phonesAcc + normPhone ) , mapAcc + + Seq ( ( phone , nameOpt ) , ( normPhone , nameOpt ) ) ) < nl > + case None ⇒ ( phonesAcc , mapAcc + ( ( phone , nameOpt ) ) ) < nl > + } < nl > + } < nl > + < nl > + val f = for { < nl > + userPhones ← persist . UserPhone . findByNumbers ( phoneNumbers ) < nl > + ignoredContactsIds ← persist . contact . UserContact . findIds _ all ( user . id ) < nl > + uniquePhones = userPhones . filter ( p ⇒ ! ignoredContactsIds . contains ( p . userId ) ) < nl > + usersPhones ← DBIO . sequence ( uniquePhones map ( p ⇒ persist . User . find ( p . userId ) . headOption map ( _ . map ( ( _ , p . number ) ) ) ) ) map ( _ . flatten ) / / TODO : # perf lots of sql queries < nl > + } yield { < nl > + usersPhones . foldLeft ( ( immutable . Seq . empty [ ( models . User , Long , Option [ String ] ) ] , immutable . Set . empty [ Int ] , immutable . Set . empty [ Long ] ) ) { < nl > + case ( ( usersPhonesNames , newContactIds , registeredPhones ) , ( user , phone ) ) ⇒ < nl > + ( usersPhonesNames : + Tuple3 ( user , phone , phonesMap ( phone ) ) , < nl > + newContactIds + user . id , < nl > + registeredPhones + phone ) < nl > + } < nl > + } < nl > + < nl > + f flatMap { < nl > + case ( usersPhonesNames , newContactIds , registeredPhoneNumbers ) ⇒ < nl > + actorSystem . log . debug ( " Phone numbers : { } , registered : { } " , phoneNumbers , registeredPhoneNumbers ) < nl > + < nl > + / / TODO : # perf do less queries < nl > + val unregInsertActions = ( phoneNumbers & ~ registeredPhoneNumbers ) . toSeq map { phoneNumber ⇒ < nl > + persist . contact . UnregisteredPhoneContact . createIfNotExists ( phoneNumber , user . id , phonesMap . get ( phoneNumber ) . getOrElse ( None ) ) < nl > + } < nl > + < nl > + for { < nl > + _ ← DBIO . sequence ( unregInsertActions ) < nl > + _ ← DBIO . successful ( newContactIds . toSeq foreach ( id ⇒ recordRelation ( id , user . id ) ) ) < nl > + userStructs ← if ( usersPhonesNames . nonEmpty ) < nl > + createPhoneContacts ( user . id , usersPhonesNames ) ( client ) else DBIO . successful ( Seq . empty [ User ] ) < nl > + } yield ( userStructs , newContactIds ) < nl > + } < nl > + } < nl > + < nl > + private def createPhoneContacts ( ownerUserId : Int , usersPhonesNames : immutable . Seq [ ( models . User , Long , Option [ String ] ) ] ) ( implicit client : AuthorizedClientData ) : dbio . DBIOAction [ immutable . Seq [ User ] , NoStream , Read with Write with Read with Read with Read with Read ] = { < nl > persist . contact . UserContact . findIds ( ownerUserId , usersPhonesNames . map ( _ . _ 1 . id ) . toSet ) . flatMap { existingContactUserIds ⇒ < nl > val actions = usersPhonesNames map { < nl > case ( user , phone , localName ) ⇒ < nl > @ @ - 243 , 4 + 279 , 26 @ @ class ContactsServiceImpl ( < nl > DBIO . sequence ( actions ) < nl > } < nl > } < nl > + < nl > + private def createEmailContacts ( ownerUserId : Int , contacts : Set [ EmailNameUser ] ) ( implicit client : AuthorizedClientData ) = { < nl > + val actions = contacts . map { contact ⇒ < nl > + val userContact = models . contact . UserEmailContact ( < nl > + ownerUserId = ownerUserId , < nl > + contactUserId = contact . userId , < nl > + email = contact . email , < nl > + name = contact . name , < nl > + accessSalt = " " , < nl > + isDeleted = false < nl > + ) < nl > + for { < nl > + _ ← persist . contact . UserEmailContact . insertOrUpdate ( userContact ) < nl > + optUser ← persist . User . find ( contact . userId ) . headOption < nl > + userStruct ← optUser . map { user ⇒ < nl > + userStruct ( user , contact . name , client . authId ) . map ( Some ( _ ) ) < nl > + } . getOrElse ( DBIO . successful ( None ) ) < nl > + } yield userStruct . map ( _ → contact . userId ) < nl > + } < nl > + DBIO . sequence ( actions . toSeq ) < nl > + } < nl > + < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json 
 index 02a781c . . fa5d576 100644 
 - - - a / actor - server / actor - core / src / main / actor - api / actor . json 
 + + + b / actor - server / actor - core / src / main / actor - api / actor . json 
 @ @ - 3188 , 6 + 3188 , 160 @ @ 
 ] 
 } , 
 { 
 + " title " : " Privacy " , 
 + " package " : " privacy " , 
 + " items " : [ 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " BlockUser " , 
 + " header " : 2636 , 
 + " response " : { 
 + " type " : " reference " , 
 + " name " : " Seq " 
 + } , 
 + " doc " : [ 
 + " Block User " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " peer " , 
 + " category " : " full " , 
 + " description " : " Peer for blocking " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " UserOutPeer " 
 + } , 
 + " id " : 1 , 
 + " name " : " peer " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " UnblockUser " , 
 + " header " : 2637 , 
 + " response " : { 
 + " type " : " reference " , 
 + " name " : " Seq " 
 + } , 
 + " doc " : [ 
 + " Unblock User " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " peer " , 
 + " category " : " full " , 
 + " description " : " Peer for unblocking " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " UserOutPeer " 
 + } , 
 + " id " : 1 , 
 + " name " : " peer " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " LoadBlockedUsers " , 
 + " header " : 2638 , 
 + " response " : { 
 + " type " : " anonymous " , 
 + " header " : 2639 , 
 + " doc " : [ 
 + { 
 + " type " : " reference " , 
 + " argument " : " userPeers " , 
 + " category " : " full " , 
 + " description " : " Blocked user peers " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " UserOutPeer " 
 + } 
 + } , 
 + " id " : 1 , 
 + " name " : " userPeers " 
 + } 
 + ] 
 + } , 
 + " doc " : [ 
 + " Load Blocked Users " 
 + ] , 
 + " attributes " : [ ] 
 + } 
 + } , 
 + { 
 + " type " : " update " , 
 + " content " : { 
 + " name " : " UserBlocked " , 
 + " header " : 2629 , 
 + " doc " : [ 
 + " Update about User Blocked " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " uid " , 
 + " category " : " full " , 
 + " description " : " User Id " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " userId " 
 + } , 
 + " id " : 1 , 
 + " name " : " uid " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " update " , 
 + " content " : { 
 + " name " : " UserUnblocked " , 
 + " header " : 2630 , 
 + " doc " : [ 
 + " Update about User Unblocked " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " uid " , 
 + " category " : " full " , 
 + " description " : " User Id " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " userId " 
 + } , 
 + " id " : 1 , 
 + " name " : " uid " 
 + } 
 + ] 
 + } 
 + } 
 + ] 
 + } , 
 + { 
 " title " : " Messaging " , 
 " package " : " messaging " , 
 " doc " : [ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index b1d6392 . . 93b3b91 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 18 , 7 + 18 , 7 @ @ import im . actor . server . acl . ACLUtils 
 import im . actor . server . bots . BotCommand 
 import im . actor . server . file . { Avatar , ImageUtils } 
 import im . actor . server . model . { AvatarData , Sex , User } 
 - import im . actor . server . model . contact . { UserContact , UserEmailContact , UserPhoneContact } 
 + import im . actor . server . model . contact . { ContactStatus , UserContact , UserEmailContact , UserPhoneContact } 
 import im . actor . server . office . EntityNotFound 
 import im . actor . server . persist . contact . _ 
 import im . actor . server . persist . _ 
 @ @ - 360 , 12 + 360 , 12 @ @ private [ user ] trait UserCommandHandlers { 
 ) : Unit = { 
 val ( idsLocalNames , plains , phones , emails ) = contactsToAdd . view . map { 
 case UserCommands . ContactToAdd ( contactUserId , localNameOpt , phoneOpt , emailOpt ) ⇒ 
 - val phone = phoneOpt map ( UserPhoneContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) 
 - val email = emailOpt map ( UserEmailContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) 
 + val phone = phoneOpt map ( UserPhoneContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false , status = ContactStatus . Approved ) ) 
 + val email = emailOpt map ( UserEmailContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false , status = ContactStatus . Approved ) ) 
 val plain = 
 if ( phone . isDefined | | email . isDefined ) 
 None 
 - else Some ( UserContact ( user . id , contactUserId , localNameOpt , isDeleted = false ) ) 
 + else Some ( UserContact ( user . id , contactUserId , localNameOpt , isDeleted = false , status = ContactStatus . Approved ) ) 
 
 ( ( contactUserId , localNameOpt ) , plain , phone , email ) 
 } . foldLeft ( Map . empty [ Int , Option [ String ] ] , Seq . empty [ UserContact ] , Seq . empty [ UserPhoneContact ] , Seq . empty [ UserEmailContact ] ) { 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / ContactStatus . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / ContactStatus . scala 
 new file mode 100644 
 index 0000000 . . 64fdd0e 
 - - - / dev / null 
 + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / ContactStatus . scala 
 @ @ - 0 , 0 + 1 , 13 @ @ 
 + package im . actor . server . model . contact 
 + 
 + / / TODO : future implementation 
 + / / Pending request 
 + / / Approved request 
 + / / Ignored request 
 + / / Block request 
 + / / No request 
 + final case class ContactStatus ( intValue : Int ) 
 + object ContactStatus { 
 + val Approved = ContactStatus ( 0 ) 
 + val Blocked = ContactStatus ( 1 ) 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / UserContact . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / UserContact . scala 
 index 52bfd47 . . 35621dc 100644 
 - - - a / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / UserContact . scala 
 + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / contact / UserContact . scala 
 @ @ - 1 , 10 + 1 , 30 @ @ 
 package im . actor . server . model . contact 
 
 @ SerialVersionUID ( 1L ) 
 - case class UserContact ( ownerUserId : Int , contactUserId : Int , name : Option [ String ] , isDeleted : Boolean ) 
 + case class UserContact ( 
 + ownerUserId : Int , 
 + contactUserId : Int , 
 + name : Option [ String ] , 
 + isDeleted : Boolean , 
 + status : ContactStatus 
 + ) 
 
 @ SerialVersionUID ( 1L ) 
 - case class UserPhoneContact ( phoneNumber : Long , ownerUserId : Int , contactUserId : Int , name : Option [ String ] , isDeleted : Boolean ) 
 + case class UserPhoneContact ( 
 + phoneNumber : Long , 
 + ownerUserId : Int , 
 + contactUserId : Int , 
 + name : Option [ String ] , 
 + isDeleted : Boolean , 
 + status : ContactStatus 
 + ) 
 
 @ SerialVersionUID ( 1L ) 
 - case class UserEmailContact ( email : String , ownerUserId : Int , contactUserId : Int , name : Option [ String ] , isDeleted : Boolean ) 
 \ No newline at end of file 
 + case class UserEmailContact ( 
 + email : String , 
 + ownerUserId : Int , 
 + contactUserId : Int , 
 + name : Option [ String ] , 
 + isDeleted : Boolean , 
 + status : ContactStatus 
 + ) 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20160414195336 _ _ AddUserContactStatus . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20160414195336 _ _ AddUserContactStatus . sql 
 new file mode 100644 
 index 0000000 . . 00b3640 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20160414195336 _ _ AddUserContactStatus . sql 
 @ @ - 0 , 0 + 1 @ @ 
 + alter table user _ contacts add column status int not null default 0 ; 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / ContactStatusColumnType . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / ContactStatusColumnType . scala 
 new file mode 100644 
 index 0000000 . . 423d877 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / ContactStatusColumnType . scala 
 @ @ - 0 , 0 + 1 , 8 @ @ 
 + package im . actor . server . persist . contact 
 + 
 + import im . actor . server . db . ActorPostgresDriver . api . _ 
 + import im . actor . server . model . contact . ContactStatus 
 + 
 + object ContactStatusColumnType { 
 + implicit val actorColumnType = MappedColumnType . base [ ContactStatus , Int ] ( _ . intValue , ContactStatus . apply ) 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala 
 index bb03cbc . . 1df2ceb 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala 
 @ @ - 1 , 32 + 1 , 32 @ @ 
 package im . actor . server . persist . contact 
 
 - import im . actor . server . model . contact . UserContact 
 + import im . actor . server . model . contact . { ContactStatus , UserContact } 
 import slick . dbio . Effect . Write 
 import im . actor . server . db . ActorPostgresDriver . api . _ 
 import slick . profile . FixedSqlAction 
 + import ContactStatusColumnType . _ 
 
 private [ contact ] abstract class UserContactBase [ T ] ( tag : Tag , tname : String ) extends Table [ T ] ( tag , tname ) { 
 def ownerUserId = column [ Int ] ( " owner _ user _ id " , O . PrimaryKey ) 
 def contactUserId = column [ Int ] ( " contact _ user _ id " , O . PrimaryKey ) 
 def name = column [ Option [ String ] ] ( " name " ) 
 def isDeleted = column [ Boolean ] ( " is _ deleted " , O . Default ( false ) ) 
 + def status = column [ ContactStatus ] ( " contact _ status " ) 
 
 def idx = index ( " idx _ user _ contacts _ owner _ user _ id _ is _ deleted " , ( ownerUserId , isDeleted ) ) 
 } 
 
 final class UserContactTable ( tag : Tag ) extends UserContactBase [ UserContact ] ( tag , " user _ contacts " ) { 
 - def * = ( ownerUserId , contactUserId , name , isDeleted ) < > ( UserContact . tupled , UserContact . unapply ) 
 + def * = ( ownerUserId , contactUserId , name , isDeleted , status ) < > ( UserContact . tupled , UserContact . unapply ) 
 } 
 
 object UserContactRepo { 
 val contacts = TableQuery [ UserContactTable ] 
 val active = contacts . filter ( _ . isDeleted = = = false ) 
 - 
 - def byPK ( ownerUserId : Int , contactUserId : Int ) = 
 - contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId ) 
 + val blocked = contacts . filter ( _ . status = = = ContactStatus . Blocked ) 
 
 private def byOwnerUserIdNotDeleted ( ownerUserId : Rep [ Int ] ) = 
 - contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . isDeleted = = = false ) 
 + active . filter ( _ . ownerUserId = = = ownerUserId ) 
 
 private val byOwnerUserIdNotDeletedC = Compiled ( byOwnerUserIdNotDeleted _ ) 
 
 @ @ - 36 , 6 + 36 , 7 @ @ object UserContactRepo { 
 
 def byPKNotDeleted ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) = 
 contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId & & c . isDeleted = = = false ) 
 + 
 val nameByPKNotDeletedC = Compiled ( 
 ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) ⇒ 
 byPKNotDeleted ( ownerUserId , contactUserId ) map ( _ . name ) 
 @ @ - 55 , 8 + 56 , 7 @ @ object UserContactRepo { 
 
 def exists ( ownerUserId : Int , contactUserId : Int ) = existsC ( ( ownerUserId , contactUserId ) ) . result 
 
 - / / TODO : check usages - make sure they dont need phone number 
 - def find ( ownerUserId : Int , contactUserId : Int ) = 
 + def find ( ownerUserId : Int , contactUserId : Int ) : DBIO [ Option [ UserContact ] ] = 
 byPKNotDeleted ( ownerUserId , contactUserId ) . result . headOption 
 
 def count ( ownerUserId : Int ) = countC ( ownerUserId ) . result 
 @ @ - 82 , 9 + 82 , 23 @ @ object UserContactRepo { 
 contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId ) . map ( _ . name ) . update ( name ) 
 } 
 
 + private def byOwnerUserIdBlocked ( ownerUserId : Rep [ Int ] ) = 
 + blocked . filter ( c ⇒ c . ownerUserId = = = ownerUserId ) 
 + 
 + private val byOwnerUserIdBlockedC = Compiled ( byOwnerUserIdBlocked _ ) 
 + 
 + def findBlockedIds ( ownerUserId : Int ) : DBIO [ Seq [ Int ] ] = 
 + byOwnerUserIdBlockedC . applied ( ownerUserId ) . map ( _ . contactUserId ) . result 
 + 
 def delete ( ownerUserId : Int , contactUserId : Int ) = 
 byPKNotDeleted ( ownerUserId , contactUserId ) . map ( _ . isDeleted ) . update ( true ) 
 
 + def block ( ownerUserId : Int , contactUserId : Int ) = 
 + byPKNotDeleted ( ownerUserId , contactUserId ) . map ( _ . status ) . update ( ContactStatus . Blocked ) 
 + 
 + def unblock ( ownerUserId : Int , contactUserId : Int ) = 
 + byPKNotDeleted ( ownerUserId , contactUserId ) . map ( _ . status ) . update ( ContactStatus . Approved ) 
 + 
 def insertOrUpdate ( contact : UserContact ) = 
 contacts . insertOrUpdate ( contact ) 
 } 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactRepo . scala 
 index 4ee37b6 . . 89976f3 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactRepo . scala 
 @ @ - 2 , 12 + 2 , 13 @ @ package im . actor . server . persist . contact 
 
 import im . actor . server . db . ActorPostgresDriver . api . _ 
 import im . actor . server . model . contact . UserEmailContact 
 + import ContactStatusColumnType . _ 
 
 final class UserEmailContactTable ( tag : Tag ) extends UserContactBase [ UserEmailContact ] ( tag , " user _ email _ contacts " ) with InheritingTable { 
 def email = column [ String ] ( " email " ) 
 val inherited = UserContactRepo . contacts . baseTableRow 
 
 - def * = ( email , ownerUserId , contactUserId , name , isDeleted ) < > ( UserEmailContact . tupled , UserEmailContact . unapply ) 
 + def * = ( email , ownerUserId , contactUserId , name , isDeleted , status ) < > ( UserEmailContact . tupled , UserEmailContact . unapply ) 
 } 
 
 object UserEmailContactRepo { 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactRepo . scala 
 index f8a8bd9 . . 9cee11b 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactRepo . scala 
 @ @ - 2 , 12 + 2 , 13 @ @ package im . actor . server . persist . contact 
 
 import im . actor . server . db . ActorPostgresDriver . api . _ 
 import im . actor . server . model . contact . UserPhoneContact 
 + import ContactStatusColumnType . _ 
 
 final class UserPhoneContactTable ( tag : Tag ) extends UserContactBase [ UserPhoneContact ] ( tag , " user _ phone _ contacts " ) with InheritingTable { 
 def phoneNumber = column [ Long ] ( " phone _ number " ) 
 val inherited = UserContactRepo . contacts . baseTableRow 
 
 - def * = ( phoneNumber , ownerUserId , contactUserId , name , isDeleted ) < > ( UserPhoneContact . tupled , UserPhoneContact . unapply ) 
 + def * = ( phoneNumber , ownerUserId , contactUserId , name , isDeleted , status ) < > ( UserPhoneContact . tupled , UserPhoneContact . unapply ) 
 } 
 
 object UserPhoneContactRepo { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / privacy / PrivacyServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / privacy / PrivacyServiceImpl . scala 
 new file mode 100644 
 index 0000000 . . 9d69537 
 - - - / dev / null 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / privacy / PrivacyServiceImpl . scala 
 @ @ - 0 , 0 + 1 , 60 @ @ 
 + package im . actor . server . api . rpc . service . privacy 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . ClientData 
 + import im . actor . api . rpc . misc . ResponseSeq 
 + import im . actor . api . rpc . peers . ApiUserOutPeer 
 + import im . actor . api . rpc . privacy . { PrivacyService , ResponseLoadBlockedUsers , UpdateUserBlocked , UpdateUserUnblocked } 
 + import im . actor . server . acl . ACLUtils 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . model . contact . ContactStatus 
 + import im . actor . server . persist . contact . UserContactRepo 
 + import im . actor . server . sequence . SeqUpdatesExtension 
 + 
 + import scala . concurrent . { ExecutionContext , Future } 
 + 
 + private object PrivacyServiceErrors { 
 + val UserAlreadyBlocked = RpcError ( 400 , " USER _ ALREADY _ BLOCKED " , " User is already blocked . " , false , None ) 
 + val UserNotBlocked = RpcError ( 400 , " USER _ NOT _ BLOCKED " , " User is not blocked . " , false , None ) 
 + val UserNotFound = RpcError ( 404 , " NOT _ FOUND " , " User is not in contacts . " , false , None ) 
 + } 
 + 
 + final class PrivacyServiceImpl ( implicit system : ActorSystem ) extends PrivacyService { 
 + import FutureResultRpc . _ 
 + import PrivacyServiceErrors . _ 
 + 
 + implicit protected val ec : ExecutionContext = system . dispatcher 
 + 
 + private val db = DbExtension ( system ) . db 
 + private val seqUpdExt = SeqUpdatesExtension ( system ) 
 + 
 + protected def doHandleBlockUser ( peer : ApiUserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + ( for { 
 + contact ← fromFutureOption ( UserNotFound ) ( db . run ( UserContactRepo . find ( client . userId , peer . userId ) ) ) 
 + _ ← fromBoolean ( UserAlreadyBlocked ) ( contact . status ! = ContactStatus . Blocked ) 
 + _ ← fromFuture ( db . run ( UserContactRepo . block ( client . userId , peer . userId ) ) ) 
 + s ← fromFuture ( seqUpdExt . deliverSingleUpdate ( client . userId , UpdateUserBlocked ( peer . userId ) ) ) 
 + } yield ResponseSeq ( s . seq , s . state . toByteArray ) ) . value 
 + } 
 + 
 + protected def doHandleUnblockUser ( peer : ApiUserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + ( for { 
 + contact ← fromFutureOption ( UserNotFound ) ( db . run ( UserContactRepo . find ( client . userId , peer . userId ) ) ) 
 + _ ← fromBoolean ( UserNotBlocked ) ( contact . status = = ContactStatus . Blocked ) 
 + _ ← fromFuture ( db . run ( UserContactRepo . unblock ( client . userId , peer . userId ) ) ) 
 + s ← fromFuture ( seqUpdExt . deliverSingleUpdate ( client . userId , UpdateUserUnblocked ( peer . userId ) ) ) 
 + } yield ResponseSeq ( s . seq , s . state . toByteArray ) ) . value 
 + } 
 + 
 + protected def doHandleLoadBlockedUsers ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadBlockedUsers ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + for { 
 + ids ← db . run ( UserContactRepo . findBlockedIds ( client . userId ) ) 
 + outPeers ← Future . sequence ( ids map ( id ⇒ ACLUtils . getUserOutPeer ( id , client . authId ) ) ) 
 + } yield Ok ( ResponseLoadBlockedUsers ( outPeers . toVector ) ) 
 + } 
 + 
 + } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserEmail . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserEmail . scala 
 index c546557 . . 25d736d 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserEmail . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserEmail . scala 
 @ @ - 24 , 6 + 24 , 9 @ @ object UserEmail { 
 def byEmail ( email : String ) = 
 emails . filter ( _ . email = = = email ) 
 
 + def findByEmails ( emailSet : Set [ String ] ) = 
 + emails . filter ( _ . email inSet emailSet ) . result 
 + 
 def find ( email : String ) = 
 byEmail ( email ) . result . headOption 
 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UnregisteredEmailContact . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UnregisteredEmailContact . scala 
 index 264ba56 . . 9a643fc 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UnregisteredEmailContact . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UnregisteredEmailContact . scala 
 @ @ - 17 , 6 + 17 , 9 @ @ object UnregisteredEmailContact { 
 def create ( email : String , ownerUserId : Int , name : Option [ String ] ) = 
 emailContacts + = models . UnregisteredEmailContact ( email , ownerUserId , name ) 
 
 + def create ( contacts : Seq [ models . UnregisteredEmailContact ] ) = 
 + emailContacts + + = contacts 
 + 
 def createIfNotExists ( email : String , ownerUserId : Int , name : Option [ String ] ) = { 
 create ( email , ownerUserId , name ) . asTry 
 } 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContact . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContact . scala 
 new file mode 100644 
 index 0000000 . . 7cf9f5d 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContact . scala 
 @ @ - 0 , 0 + 1 , 24 @ @ 
 + package im . actor . server . persist . contact 
 + 
 + import im . actor . server . db . ActorPostgresDriver . api . _ 
 + import im . actor . server . models 
 + 
 + class UserEmailContactTable ( tag : Tag ) extends UserContactBase [ models . contact . UserEmailContact ] ( tag , " user _ email _ contacts " ) with InheritingTable { 
 + def email = column [ String ] ( " email " ) 
 + val inherited = UserContact . contacts . baseTableRow 
 + 
 + def * = ( email , ownerUserId , contactUserId , name , accessSalt , isDeleted ) < > ( models . contact . UserEmailContact . tupled , models . contact . UserEmailContact . unapply ) 
 + } 
 + 
 + object UserEmailContact { 
 + val econtacts = TableQuery [ UserEmailContactTable ] 
 + 
 + def createOrRestore ( ownerUserId : Int , contactUserId : Int , email : String , name : Option [ String ] , accessSalt : String ) = { 
 + val contact = models . contact . UserEmailContact ( email , ownerUserId , contactUserId , name , accessSalt , false ) 
 + econtacts . insertOrUpdate ( contact ) 
 + } 
 + 
 + def insertOrUpdate ( contact : models . contact . UserEmailContact ) = 
 + econtacts . insertOrUpdate ( contact ) 
 + 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactTable . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactTable . scala 
 deleted file mode 100644 
 index 7cf9f5d . . 0000000 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserEmailContactTable . scala 
 + + + / dev / null 
 @ @ - 1 , 24 + 0 , 0 @ @ 
 - package im . actor . server . persist . contact 
 - 
 - import im . actor . server . db . ActorPostgresDriver . api . _ 
 - import im . actor . server . models 
 - 
 - class UserEmailContactTable ( tag : Tag ) extends UserContactBase [ models . contact . UserEmailContact ] ( tag , " user _ email _ contacts " ) with InheritingTable { 
 - def email = column [ String ] ( " email " ) 
 - val inherited = UserContact . contacts . baseTableRow 
 - 
 - def * = ( email , ownerUserId , contactUserId , name , accessSalt , isDeleted ) < > ( models . contact . UserEmailContact . tupled , models . contact . UserEmailContact . unapply ) 
 - } 
 - 
 - object UserEmailContact { 
 - val econtacts = TableQuery [ UserEmailContactTable ] 
 - 
 - def createOrRestore ( ownerUserId : Int , contactUserId : Int , email : String , name : Option [ String ] , accessSalt : String ) = { 
 - val contact = models . contact . UserEmailContact ( email , ownerUserId , contactUserId , name , accessSalt , false ) 
 - econtacts . insertOrUpdate ( contact ) 
 - } 
 - 
 - def insertOrUpdate ( contact : models . contact . UserEmailContact ) = 
 - econtacts . insertOrUpdate ( contact ) 
 - 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala 
 new file mode 100644 
 index 0000000 . . 2b6f064 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala 
 @ @ - 0 , 0 + 1 , 24 @ @ 
 + package im . actor . server . persist . contact 
 + 
 + import im . actor . server . db . ActorPostgresDriver . api . _ 
 + import im . actor . server . models 
 + 
 + class UserPhoneContactTable ( tag : Tag ) extends UserContactBase [ models . contact . UserPhoneContact ] ( tag , " user _ phone _ contacts " ) with InheritingTable { 
 + def phoneNumber = column [ Long ] ( " phone _ number " ) 
 + val inherited = UserContact . contacts . baseTableRow 
 + 
 + def * = ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , isDeleted ) < > ( models . contact . UserPhoneContact . tupled , models . contact . UserPhoneContact . unapply ) 
 + } 
 + 
 + object UserPhoneContact { 
 + val pcontacts = TableQuery [ UserPhoneContactTable ] 
 + 
 + def createOrRestore ( ownerUserId : Int , contactUserId : Int , phoneNumber : Long , name : Option [ String ] , accessSalt : String ) = { 
 + val contact = models . contact . UserPhoneContact ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , false ) 
 + pcontacts . insertOrUpdate ( contact ) 
 + } 
 + 
 + def insertOrUpdate ( contact : models . contact . UserPhoneContact ) = 
 + pcontacts . insertOrUpdate ( contact ) 
 + 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactTable . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactTable . scala 
 deleted file mode 100644 
 index 2b6f064 . . 0000000 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContactTable . scala 
 + + + / dev / null 
 @ @ - 1 , 24 + 0 , 0 @ @ 
 - package im . actor . server . persist . contact 
 - 
 - import im . actor . server . db . ActorPostgresDriver . api . _ 
 - import im . actor . server . models 
 - 
 - class UserPhoneContactTable ( tag : Tag ) extends UserContactBase [ models . contact . UserPhoneContact ] ( tag , " user _ phone _ contacts " ) with InheritingTable { 
 - def phoneNumber = column [ Long ] ( " phone _ number " ) 
 - val inherited = UserContact . contacts . baseTableRow 
 - 
 - def * = ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , isDeleted ) < > ( models . contact . UserPhoneContact . tupled , models . contact . UserPhoneContact . unapply ) 
 - } 
 - 
 - object UserPhoneContact { 
 - val pcontacts = TableQuery [ UserPhoneContactTable ] 
 - 
 - def createOrRestore ( ownerUserId : Int , contactUserId : Int , phoneNumber : Long , name : Option [ String ] , accessSalt : String ) = { 
 - val contact = models . contact . UserPhoneContact ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , false ) 
 - pcontacts . insertOrUpdate ( contact ) 
 - } 
 - 
 - def insertOrUpdate ( contact : models . contact . UserPhoneContact ) = 
 - pcontacts . insertOrUpdate ( contact ) 
 - 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala 
 index 08a9423 . . 22ae244 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala 
 @ @ - 5 , 24 + 5 , 23 @ @ import java . security . MessageDigest 
 import scala . collection . immutable 
 import scala . concurrent . _ 
 import scala . concurrent . duration . _ 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 
 import akka . actor . _ 
 import akka . util . Timeout 
 import scodec . bits . BitVector 
 import slick . dbio 
 import slick . dbio . DBIO 
 - import slick . dbio . Effect . { Write , Read } 
 + import slick . dbio . Effect . { Read , Write } 
 import slick . driver . PostgresDriver . api . _ 
 
 + import im . actor . api . rpc . DBIOResult . _ 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . contacts . _ 
 import im . actor . api . rpc . misc . _ 
 import im . actor . api . rpc . users . { UpdateUserLocalNameChanged , User } 
 - import im . actor . server 
 import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } 
 import im . actor . server . social . { SocialManager , SocialManagerRegion } 
 - import im . actor . server . util . { UserUtils , ContactsUtils , ACLUtils , PhoneNumber } 
 + import im . actor . server . util . { ACLUtils , ContactsUtils , PhoneNumber , UserUtils } 
 import im . actor . server . { models , persist } 
 
 class ContactsServiceImpl ( 
 @ @ - 48 , 6 + 47 , 8 @ @ class ContactsServiceImpl ( 
 val ContactNotFound = RpcError ( 404 , " CONTACT _ NOT _ FOUND " , " Contact not found . " , false , None ) 
 } 
 
 + case class EmailNameUser ( email : String , name : Option [ String ] , userId : Int ) 
 + 
 private [ service ] def hashIds ( ids : Seq [ Int ] ) : String = { 
 val md = MessageDigest . getInstance ( " SHA - 256 " ) 
 val uids = ids . to [ immutable . SortedSet ] . mkString ( " , " ) 
 @ @ - 55 , 62 + 56 , 26 @ @ class ContactsServiceImpl ( 
 } 
 
 override def jhandleImportContacts ( phones : Vector [ PhoneToImport ] , emails : Vector [ EmailToImport ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseImportContacts ] ] = { 
 - val action = requireAuth ( clientData ) . map { implicit client ⇒ 
 - persist . UserPhone . findByUserId ( client . userId ) . head . flatMap { currentUserPhone ⇒ 
 - persist . User . find ( client . userId ) . head . flatMap { currentUser ⇒ 
 - val filteredPhones = phones . view . filterNot ( _ . phoneNumber = = currentUserPhone . number ) 
 - 
 - val ( phoneNumbers , phonesMap ) = filteredPhones . foldLeft ( ( Set . empty [ Long ] , Map . empty [ Long , Option [ String ] ] ) ) { 
 - case ( ( phonesAcc , mapAcc ) , PhoneToImport ( phone , nameOpt ) ) ⇒ 
 - PhoneNumber . normalizeLong ( phone , currentUser . countryCode ) match { 
 - case Some ( normPhone ) ⇒ ( ( phonesAcc + normPhone ) , mapAcc + + Seq ( ( phone , nameOpt ) , ( normPhone , nameOpt ) ) ) 
 - case None ⇒ ( phonesAcc , mapAcc + ( ( phone , nameOpt ) ) ) 
 - } 
 - } 
 - 
 - val f = for { 
 - userPhones ← persist . UserPhone . findByNumbers ( phoneNumbers ) 
 - ignoredContactsIds ← persist . contact . UserContact . findIds _ all ( client . userId ) 
 - uniquePhones = userPhones . filter ( p ⇒ ! ignoredContactsIds . contains ( p . userId ) ) 
 - usersPhones ← DBIO . sequence ( uniquePhones map ( p ⇒ persist . User . find ( p . userId ) . headOption map ( _ . map ( ( _ , p . number ) ) ) ) ) map ( _ . flatten ) / / TODO : # perf lots of sql queries 
 - } yield { 
 - usersPhones . foldLeft ( ( immutable . Seq . empty [ ( models . User , Long , Option [ String ] ) ] , immutable . Set . empty [ Int ] , immutable . Set . empty [ Long ] ) ) { 
 - case ( ( usersPhonesNames , newContactIds , registeredPhones ) , ( user , phone ) ) ⇒ 
 - ( usersPhonesNames : + Tuple3 ( user , phone , phonesMap ( phone ) ) , 
 - newContactIds + user . id , 
 - registeredPhones + phone ) 
 - } 
 - } 
 - 
 - f flatMap { 
 - case ( usersPhonesNames , newContactIds , registeredPhoneNumbers ) ⇒ 
 - actorSystem . log . debug ( " Phone numbers : { } , registered : { } " , phoneNumbers , registeredPhoneNumbers ) 
 - 
 - / / TODO : # perf do less queries 
 - val unregInsertActions = ( phoneNumbers & ~ registeredPhoneNumbers ) . toSeq map { phoneNumber ⇒ 
 - persist . contact . UnregisteredPhoneContact . createIfNotExists ( phoneNumber , client . userId , phonesMap . get ( phoneNumber ) . getOrElse ( None ) ) 
 - } 
 - 
 - DBIO . sequence ( unregInsertActions ) . flatMap { _ ⇒ 
 - if ( usersPhonesNames . nonEmpty ) { 
 - for { 
 - userStructs ← createAllUserContacts ( client . userId , usersPhonesNames ) 
 - seqstate ← broadcastClientUpdate ( UpdateContactsAdded ( newContactIds . toVector ) , None ) 
 - } yield { 
 - newContactIds . toSeq foreach ( id ⇒ recordRelation ( id , client . userId ) ) 
 - 
 - Ok ( ResponseImportContacts ( userStructs . toVector , seqstate . _ 1 , seqstate . _ 2 ) ) 
 - } 
 - } else { 
 - DBIO . successful ( Ok ( ResponseImportContacts ( immutable . Vector . empty , 0 , Array . empty ) ) ) 
 - } 
 - } 
 - } 
 - } 
 - } 
 - } 
 - 
 - db . run ( toDBIOAction ( action ) ) / / TODO : transactionally 
 + val action = 
 + for { 
 + client ← fromOption ( CommonErrors . UserNotAuthorized ) ( clientData . optUserId . map ( id ⇒ AuthorizedClientData ( clientData . authId , clientData . sessionId , id ) ) ) 
 + user ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . User . find ( client . userId ) . headOption ) 
 + optPhone ← fromDBIO ( persist . UserPhone . findByUserId ( client . userId ) . headOption ) 
 + optEmail ← fromDBIO ( persist . UserEmail . findByUserId ( client . userId ) . headOption ) 
 + 
 + phoneUsers ← fromDBIO ( importPhones ( user , optPhone , phones ) ( client ) ) 
 + ( pUsers , pUserIds ) = phoneUsers 
 + 
 + emailUsersAndIds ← fromDBIO ( importEmails ( user , optEmail , emails ) ( client ) ) 
 + ( eUsers , eUserIds ) = emailUsersAndIds 
 + 
 + seqstate ← fromDBIO ( { 
 + implicit val c = client 
 + broadcastClientUpdate ( UpdateContactsAdded ( ( pUserIds + + eUserIds ) . toVector ) , None ) 
 + } ) 
 + } yield ResponseImportContacts ( ( pUsers + + eUsers ) . toVector , seqstate . _ 1 , seqstate . _ 2 ) 
 + 
 + db . run ( action . run . transactionally ) 
 } 
 
 override def jhandleGetContacts ( contactsHash : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetContacts ] ] = { 
 @ @ - 219 , 7 + 184 , 78 @ @ class ContactsServiceImpl ( 
 db . run ( toDBIOAction ( authorizedAction ) ) 
 } 
 
 - private def createAllUserContacts ( ownerUserId : Int , usersPhonesNames : immutable . Seq [ ( models . User , Long , Option [ String ] ) ] ) ( implicit client : AuthorizedClientData ) : dbio . DBIOAction [ immutable . Seq [ User ] , NoStream , Read with Write with Read with Read with Read with Read ] = { 
 + private def importEmails ( user : models . User , optOwnEmail : Option [ models . UserEmail ] , emails : Vector [ EmailToImport ] ) ( implicit client : AuthorizedClientData ) : DBIO [ ( Seq [ User ] , Seq [ Sequence ] ) ] = { 
 + / / filtering out user ' s own email and making ` Map ` from emails to optional name 
 + val filtered : Map [ String , Option [ String ] ] = optOwnEmail 
 + . map ( e ⇒ emails . filterNot ( _ . email = = e . email ) ) . getOrElse ( emails ) 
 + . map ( e ⇒ e . email → e . name ) . toMap 
 + val filteredEmails = filtered . keySet 
 + 
 + for { 
 + / / finding emails of users that are registered 
 + / / but don ' t contain in user ' s contact list 
 + emailModels ← persist . UserEmail . findByEmails ( filteredEmails ) 
 + userContacts ← persist . contact . UserContact . findIds _ all ( user . id ) 
 + newEmailContacts = emailModels . filter ( e ⇒ ! userContacts . contains ( e . userId ) ) 
 + 
 + / / registering UserEmailContacts 
 + newEmailContactsM = newEmailContacts . map ( e ⇒ e . email → e . userId ) . toMap 
 + emailsNamesUsers = newEmailContactsM . keySet . map ( k ⇒ EmailNameUser ( k , filtered ( k ) , newEmailContactsM ( k ) ) ) 
 + usersAndIds ← createEmailContacts ( user . id , emailsNamesUsers ) 
 + 
 + / / creating unregistered contacts 
 + unregisteredEmails = filteredEmails - - emailModels . map ( _ . email ) 
 + unregisteredEmailContacts = unregisteredEmails . map { email ⇒ 
 + models . UnregisteredEmailContact ( email , user . id , filtered ( email ) ) 
 + } 
 + _ ← persist . contact . UnregisteredEmailContact . create ( unregisteredEmailContacts . toSeq ) 
 + } yield usersAndIds . flatten . unzip 
 + } 
 + 
 + private def importPhones ( user : models . User , optPhone : Option [ models . UserPhone ] , phones : Vector [ PhoneToImport ] ) ( client : AuthorizedClientData ) : DBIO [ ( Seq [ User ] , Set [ Int ] ) ] = { 
 + val filteredPhones = optPhone . map ( p ⇒ phones . filterNot ( _ . phoneNumber = = p . number ) ) . getOrElse ( phones ) 
 + 
 + val ( phoneNumbers , phonesMap ) = filteredPhones . foldLeft ( ( Set . empty [ Long ] , Map . empty [ Long , Option [ String ] ] ) ) { 
 + case ( ( phonesAcc , mapAcc ) , PhoneToImport ( phone , nameOpt ) ) ⇒ 
 + PhoneNumber . normalizeLong ( phone , user . countryCode ) match { 
 + case Some ( normPhone ) ⇒ ( ( phonesAcc + normPhone ) , mapAcc + + Seq ( ( phone , nameOpt ) , ( normPhone , nameOpt ) ) ) 
 + case None ⇒ ( phonesAcc , mapAcc + ( ( phone , nameOpt ) ) ) 
 + } 
 + } 
 + 
 + val f = for { 
 + userPhones ← persist . UserPhone . findByNumbers ( phoneNumbers ) 
 + ignoredContactsIds ← persist . contact . UserContact . findIds _ all ( user . id ) 
 + uniquePhones = userPhones . filter ( p ⇒ ! ignoredContactsIds . contains ( p . userId ) ) 
 + usersPhones ← DBIO . sequence ( uniquePhones map ( p ⇒ persist . User . find ( p . userId ) . headOption map ( _ . map ( ( _ , p . number ) ) ) ) ) map ( _ . flatten ) / / TODO : # perf lots of sql queries 
 + } yield { 
 + usersPhones . foldLeft ( ( immutable . Seq . empty [ ( models . User , Long , Option [ String ] ) ] , immutable . Set . empty [ Int ] , immutable . Set . empty [ Long ] ) ) { 
 + case ( ( usersPhonesNames , newContactIds , registeredPhones ) , ( user , phone ) ) ⇒ 
 + ( usersPhonesNames : + Tuple3 ( user , phone , phonesMap ( phone ) ) , 
 + newContactIds + user . id , 
 + registeredPhones + phone ) 
 + } 
 + } 
 + 
 + f flatMap { 
 + case ( usersPhonesNames , newContactIds , registeredPhoneNumbers ) ⇒ 
 + actorSystem . log . debug ( " Phone numbers : { } , registered : { } " , phoneNumbers , registeredPhoneNumbers ) 
 + 
 + / / TODO : # perf do less queries 
 + val unregInsertActions = ( phoneNumbers & ~ registeredPhoneNumbers ) . toSeq map { phoneNumber ⇒ 
 + persist . contact . UnregisteredPhoneContact . createIfNotExists ( phoneNumber , user . id , phonesMap . get ( phoneNumber ) . getOrElse ( None ) ) 
 + } 
 + 
 + for { 
 + _ ← DBIO . sequence ( unregInsertActions ) 
 + _ ← DBIO . successful ( newContactIds . toSeq foreach ( id ⇒ recordRelation ( id , user . id ) ) ) 
 + userStructs ← if ( usersPhonesNames . nonEmpty ) 
 + createPhoneContacts ( user . id , usersPhonesNames ) ( client ) else DBIO . successful ( Seq . empty [ User ] ) 
 + } yield ( userStructs , newContactIds ) 
 + } 
 + } 
 + 
 + private def createPhoneContacts ( ownerUserId : Int , usersPhonesNames : immutable . Seq [ ( models . User , Long , Option [ String ] ) ] ) ( implicit client : AuthorizedClientData ) : dbio . DBIOAction [ immutable . Seq [ User ] , NoStream , Read with Write with Read with Read with Read with Read ] = { 
 persist . contact . UserContact . findIds ( ownerUserId , usersPhonesNames . map ( _ . _ 1 . id ) . toSet ) . flatMap { existingContactUserIds ⇒ 
 val actions = usersPhonesNames map { 
 case ( user , phone , localName ) ⇒ 
 @ @ - 243 , 4 + 279 , 26 @ @ class ContactsServiceImpl ( 
 DBIO . sequence ( actions ) 
 } 
 } 
 + 
 + private def createEmailContacts ( ownerUserId : Int , contacts : Set [ EmailNameUser ] ) ( implicit client : AuthorizedClientData ) = { 
 + val actions = contacts . map { contact ⇒ 
 + val userContact = models . contact . UserEmailContact ( 
 + ownerUserId = ownerUserId , 
 + contactUserId = contact . userId , 
 + email = contact . email , 
 + name = contact . name , 
 + accessSalt = " " , 
 + isDeleted = false 
 + ) 
 + for { 
 + _ ← persist . contact . UserEmailContact . insertOrUpdate ( userContact ) 
 + optUser ← persist . User . find ( contact . userId ) . headOption 
 + userStruct ← optUser . map { user ⇒ 
 + userStruct ( user , contact . name , client . authId ) . map ( Some ( _ ) ) 
 + } . getOrElse ( DBIO . successful ( None ) ) 
 + } yield userStruct . map ( _ → contact . userId ) 
 + } 
 + DBIO . sequence ( actions . toSeq ) 
 + } 
 + 
 }
