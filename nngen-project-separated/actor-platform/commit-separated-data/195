BLEU SCORE: 0.1598921499894403

TEST MSG: fix ( server : groups ) : current date in transfer ownership response ; change order of updates
GENERATED MSG: fix ( server : core ) : initialize dialog for all group users on group creation

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 9299be6 . . d11c8c3 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 406 , 8 + 406 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) < nl > < nl > val leftUserUpdatesNew = List ( < nl > - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > ) < nl > < nl > @ @ - 423 , 9 + 423 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } yield ( ) < nl > ) < nl > < nl > + / / read this dialog by user that leaves group . don ' t wait for ack < nl > + dialogExt . messageRead ( apiGroupPeer , cmd . userId , 0L , dateMillis ) < nl > val result : Future [ SeqStateDate ] = for { < nl > - / / read this dialog by user that leaves group < nl > - _ ← dialogExt . messageRead ( apiGroupPeer , cmd . userId , 0L , dateMillis ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > / / old group api updates / / < nl > @ @ - 458 , 13 + 458 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > deliveryTag = Some ( Optimization . GroupV2 ) < nl > ) < nl > < nl > - / / push left user updates < nl > - / / • with empty group members < nl > - / / • that he can ' t view and invite members < nl > - _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > - } < nl > - < nl > / / push left user that he is no longer a member < nl > SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . userId , < nl > @ @ - 472 , 6 + 465 , 13 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > update = UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > ) < nl > < nl > + / / push left user updates < nl > + / / • with empty group members < nl > + / / • that he can ' t view and invite members < nl > + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > + } < nl > + < nl > } yield SeqStateDate ( seq , state , date ) < nl > < nl > result andThen { case _ ⇒ commit ( evt ) } pipeTo sender ( ) < nl > @ @ - 492 , 8 + 492 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val updateObsolete = UpdateGroupUserKickObsolete ( groupId , cmd . kickedUserId , cmd . kickerUserId , dateMillis , cmd . randomId ) < nl > < nl > val kickedUserUpdatesNew : List [ Update ] = List ( < nl > - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , < nl > UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > ) < nl > @ @ - 510 , 9 + 510 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } yield ( ) < nl > ) < nl > < nl > + / / read this dialog by kicked user . don ' t wait for ack < nl > + dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) < nl > val result : Future [ SeqStateDate ] = for { < nl > - _ ← dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) < nl > - < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > / / old group api updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > index 8bff8e9 . . 2256681 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > @ @ - 1 , 5 + 1 , 7 @ @ < nl > package im . actor . server . api . rpc . service . groups < nl > < nl > + import java . time . Instant < nl > + < nl > import akka . actor . ActorSystem < nl > import akka . http . scaladsl . util . FastFuture < nl > import im . actor . api . rpc . PeerHelpers . _ < nl > @ @ - 111 , 7 + 113 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > withGroupOutPeer ( groupPeer ) { < nl > for { < nl > SeqState ( seq , state ) ← groupExt . transferOwnership ( groupPeer . groupId , client . userId , client . authId , newOwner ) < nl > - } yield Ok ( ResponseSeqDate ( seq , state . toByteArray , 0 ) ) < nl > + } yield Ok ( ResponseSeqDate ( seq , state . toByteArray , Instant . now . toEpochMilli ) ) < nl > } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index c26a25e . . 16f87dc 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 105 , 13 + 105 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > message : ApiMessage < nl > ) : Unit = < nl > withCreated ( s ) { _ ⇒ < nl > - val date = new DateTime ( dateMillis ) < nl > - < nl > val result = < nl > if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) < nl > } else { < nl > - db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) < nl > + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) < nl > } < nl > < nl > result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index e928261 . . 302ab28 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 101 , 7 + 101 , 11 @ @ object HistoryUtils { < nl > messageContentData = messageContentData , < nl > deletedAt = None < nl > ) ) < nl > - _ ← DialogRepo . updateLastMessageDatePrivate ( userId , toPeer , date ) < nl > + _ ← toPeer . ` type ` match { < nl > + case PeerType . Private ⇒ DialogRepo . updateLastMessageDatePrivate ( userId , toPeer , date ) < nl > + case PeerType . Group ⇒ DialogRepo . updateLastMessageDateGroup ( toPeer , date ) < nl > + case _ ⇒ throw new RuntimeException ( s " Unknown peer type $ { toPeer . typ } " ) < nl > + } < nl > } yield ( ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index dc8b789 . . 4f95eaf 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 11 , 14 + 11 , 12 @ @ import im . actor . api . rpc . messaging . ApiServiceMessage < nl > import im . actor . api . rpc . misc . ApiExtension < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . api . rpc . users . ApiSex < nl > - import im . actor . concurrent . FutureExt < nl > import im . actor . server . ApiConversions . _ < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . dialog . DialogExtension < nl > import im . actor . server . model . PeerType < nl > - import im . actor . server . persist . dialog < nl > - import im . actor . server . persist . dialog . DialogRepo < nl > - import im . actor . server . { persist ⇒ p , model } < nl > + import im . actor . server . persist . _ < nl > + import im . actor . server . model < nl > import im . actor . server . event . TSEvent < nl > import im . actor . server . file . { ImageUtils , Avatar } < nl > import im . actor . server . group . GroupErrors . _ < nl > @ @ - 57 , 7 + 55 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > < nl > db . run ( for { < nl > _ ← createInDb ( state , rng . nextLong ( ) ) < nl > - _ ← p . GroupUserRepo . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) < nl > + _ ← GroupUserRepo . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) < nl > _ ← DBIO . from ( userExt . broadcastUserUpdate ( creatorUserId , update , pushText = None , isFat = true , reduceKey = None , deliveryId = Some ( s " creategroup _ $ { groupId } _ $ { update . randomId } " ) ) ) < nl > } yield CreateInternalAck ( accessHash ) ) pipeTo sender ( ) onFailure { < nl > case e ⇒ < nl > @ @ - 89 , 7 + 87 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > < nl > db . run ( < nl > for { < nl > - _ ← p . GroupRepo . create ( < nl > + _ ← GroupRepo . create ( < nl > model . Group ( < nl > id = groupId , < nl > creatorUserId = state . creatorUserId , < nl > @ @ - 103 , 8 + 101 , 10 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > randomId , < nl > isHidden = false < nl > ) < nl > - _ ← p . GroupUserRepo . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) < nl > - _ ← DBIO . from ( dialogExt . writeMessage ( ApiPeer ( ApiPeerType . Group , state . id ) , creatorUserId , date , randomId , serviceMessage ) ) < nl > + _ ← GroupUserRepo . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) < nl > + _ ← DBIO . from ( Future . sequence ( ( userIds + creatorUserId ) map { uid ⇒ < nl > + dialogExt . writeMessageSelf ( uid , ApiPeer ( ApiPeerType . Group , state . id ) , creatorUserId , date , randomId , serviceMessage ) < nl > + } ) ) < nl > seqstate ← if ( isBot ( state , creatorUserId ) ) DBIO . successful ( SeqState ( 0 , ByteString . EMPTY ) ) < nl > else DBIO . from ( seqUpdExt . deliverSingleUpdate ( creatorUserId , update , PushRules ( isFat = true ) , reduceKey = None , deliveryId = s " creategroup _ $ { groupId } _ $ randomId " ) ) < nl > } yield CreateAck ( state . accessHash , seqstate , date . getMillis ) < nl > @ @ - 123 , 7 + 123 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > < nl > ( for { < nl > _ ← userExt . create ( botUserId , nextAccessSalt ( ThreadLocalSecureRandom . current ( ) ) , None , " Bot " , " US " , ApiSex . Unknown , isBot = true ) < nl > - _ ← db . run ( p . GroupBotRepo . create ( groupId , botUserId , botToken ) ) < nl > + _ ← db . run ( GroupBotRepo . create ( groupId , botUserId , botToken ) ) < nl > _ ← integrationTokensKv . upsert ( botToken , groupId ) < nl > } yield ( ) ) onFailure { < nl > case e ⇒ < nl > @ @ - 142 , 7 + 142 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > val serviceMessage = GroupServiceMessages . userInvited ( userId ) < nl > < nl > for { < nl > - _ ← db . run ( p . GroupUserRepo . create ( groupId , userId , inviterUserId , date , None , isAdmin = false ) ) < nl > + _ ← db . run ( GroupUserRepo . create ( groupId , userId , inviterUserId , date , None , isAdmin = false ) ) < nl > _ ← userExt . broadcastUserUpdate ( userId , inviteeUpdate , pushText = Some ( PushTexts . Invited ) , isFat = true , reduceKey = None , deliveryId = Some ( s " invite _ $ { groupId } _ $ { randomId } " ) ) < nl > / / TODO : # perf the following broadcasts do update serializing per each user < nl > _ ← Future . sequence ( memberIds . toSeq . filterNot ( _ = = inviterUserId ) . map ( userExt . broadcastUserUpdate ( _ , userAddedUpdate , Some ( PushTexts . Added ) , isFat = true , reduceKey = None , deliveryId = Some ( s " useradded _ $ { groupId } _ $ { randomId } " ) ) ) ) / / use broadcastUsersUpdate maybe ? < nl > @ @ - 175 , 8 + 175 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > val date = new DateTime < nl > val randomId = ThreadLocalSecureRandom . current ( ) . nextLong ( ) < nl > for { < nl > - exists ← p . GroupUserRepo . exists ( groupId , joiningUserId ) < nl > - _ ← if ( exists ) DBIO . successful ( ( ) ) else p . GroupUserRepo . create ( groupId , joiningUserId , invitingUserId , date , Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , isAdmin = false ) < nl > + exists ← GroupUserRepo . exists ( groupId , joiningUserId ) < nl > + _ ← if ( exists ) DBIO . successful ( ( ) ) else GroupUserRepo . create ( groupId , joiningUserId , invitingUserId , date , Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , isAdmin = false ) < nl > seqstatedate ← DBIO . from ( DialogExtension ( system ) . sendMessage ( < nl > peer = ApiPeer ( ApiPeerType . Group , groupId ) , < nl > senderUserId = joiningUserId , < nl > @ @ - 235 , 7 + 235 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > val memberIds = group . members . keySet < nl > < nl > for { < nl > - _ ← db . run ( p . AvatarDataRepo . createOrUpdate ( avatarData ) ) < nl > + _ ← db . run ( AvatarDataRepo . createOrUpdate ( avatarData ) ) < nl > ( seqstate , _ ) ← seqUpdExt . broadcastOwnSingleUpdate ( clientUserId , memberIds , update ) < nl > } yield { < nl > dialogExt . writeMessage ( < nl > @ @ - 254 , 8 + 254 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > protected def makePublic ( group : Group , description : String ) : Unit = { < nl > persistStashingReply ( Vector ( TSEvent ( now ( ) , BecamePublic ( ) ) , TSEvent ( now ( ) , AboutUpdated ( Some ( description ) ) ) ) , group ) { _ ⇒ < nl > db . run ( DBIO . sequence ( Seq ( < nl > - p . GroupRepo . makePublic ( groupId ) , < nl > - p . GroupRepo . updateAbout ( groupId , Some ( description ) ) < nl > + GroupRepo . makePublic ( groupId ) , < nl > + GroupRepo . updateAbout ( groupId , Some ( description ) ) < nl > ) ) ) map ( _ ⇒ MakePublicAck ( ) ) < nl > } < nl > } < nl > @ @ - 270 , 7 + 270 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > val serviceMessage = GroupServiceMessages . changedTitle ( title ) < nl > < nl > for { < nl > - _ ← db . run ( p . GroupRepo . updateTitle ( groupId , title , clientUserId , randomId , date ) ) < nl > + _ ← db . run ( GroupRepo . updateTitle ( groupId , title , clientUserId , randomId , date ) ) < nl > _ ← dialogExt . writeMessage ( < nl > ApiPeer ( ApiPeerType . Group , groupId ) , < nl > clientUserId , < nl > @ @ - 298 , 7 + 298 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > val serviceMessage = GroupServiceMessages . changedTopic ( trimmed ) < nl > val update = UpdateGroupTopicChanged ( groupId = groupId , randomId = randomId , userId = clientUserId , topic = trimmed , date = dateMillis ) < nl > for { < nl > - _ ← db . run ( p . GroupRepo . updateTopic ( groupId , trimmed ) ) < nl > + _ ← db . run ( GroupRepo . updateTopic ( groupId , trimmed ) ) < nl > _ ← dialogExt . writeMessage ( < nl > ApiPeer ( ApiPeerType . Group , groupId ) , < nl > clientUserId , < nl > @ @ - 330 , 7 + 330 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > val update = UpdateGroupAboutChanged ( groupId , trimmed ) < nl > val serviceMessage = GroupServiceMessages . changedAbout ( trimmed ) < nl > db . run ( for { < nl > - _ ← p . GroupRepo . updateAbout ( groupId , trimmed ) < nl > + _ ← GroupRepo . updateAbout ( groupId , trimmed ) < nl > _ ← DBIO . from ( dialogExt . writeMessage ( < nl > ApiPeer ( ApiPeerType . Group , groupId ) , < nl > clientUserId , < nl > @ @ - 363 , 7 + 363 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > val updated = group . members . updated ( candidateId , group . members ( candidateId ) . copy ( isAdmin = true ) ) < nl > val members = updated . values . map ( _ . asStruct ) . toVector < nl > for { < nl > - _ ← db . run ( p . GroupUserRepo . makeAdmin ( groupId , candidateId ) ) < nl > + _ ← db . run ( GroupUserRepo . makeAdmin ( groupId , candidateId ) ) < nl > ( seqState , _ ) ← seqUpdExt . broadcastOwnSingleUpdate ( < nl > clientUserId , < nl > group . members . keySet - clientUserId , < nl > @ @ - 384 , 7 + 384 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > val newToken = accessToken ( ThreadLocalSecureRandom . current ( ) ) < nl > persistStashingReply ( TSEvent ( now ( ) , IntegrationTokenRevoked ( newToken ) ) , group ) { _ ⇒ < nl > for { < nl > - _ ← db . run ( p . GroupBotRepo . updateToken ( groupId , newToken ) ) < nl > + _ ← db . run ( GroupBotRepo . updateToken ( groupId , newToken ) ) < nl > _ ← integrationTokensKv . delete ( oldToken . getOrElse ( " " ) ) < nl > _ ← integrationTokensKv . upsert ( newToken , groupId ) < nl > } yield RevokeIntegrationTokenAck ( newToken ) < nl > @ @ - 395 , 8 + 395 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > private def removeUser ( userId : Int , memberIds : Set [ Int ] , clientAuthSid : Int , serviceMessage : ApiServiceMessage , update : Update , date : DateTime , randomId : Long ) : DBIO [ SeqStateDate ] = { < nl > val groupPeer = model . Peer ( PeerType . Group , groupId ) < nl > for { < nl > - _ ← p . GroupUserRepo . delete ( groupId , userId ) < nl > - _ ← p . GroupInviteTokenRepo . revoke ( groupId , userId ) < nl > + _ ← GroupUserRepo . delete ( groupId , userId ) < nl > + _ ← GroupInviteTokenRepo . revoke ( groupId , userId ) < nl > ( SeqState ( seq , state ) , _ ) ← DBIO . from ( userExt . broadcastClientAndUsersUpdate ( < nl > clientUserId = userId , < nl > clientAuthSid = clientAuthSid , < nl > @ @ - 422 , 7 + 422 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > ThreadLocalSecureRandom . current ( ) . nextLong ( ) < nl > < nl > private def createInDb ( state : Group , randomId : Long ) = < nl > - p . GroupRepo . create ( < nl > + GroupRepo . create ( < nl > model . Group ( < nl > id = groupId , < nl > creatorUserId = state . creatorUserId , < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > index 92e00f3 . . 88efe66 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > @ @ - 149 , 14 + 149 , 12 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > withValidGroupTitle ( title ) { validTitle ⇒ < nl > val groupId = nextIntId ( ThreadLocalSecureRandom . current ( ) ) < nl > val userIds = users . map ( _ . userId ) . toSet < nl > - val groupUserIds = userIds + client . userId < nl > - < nl > val f = for ( res ← groupExt . create ( groupId , title , randomId , userIds ) ) yield { < nl > Ok ( ResponseCreateGroupObsolete ( < nl > groupPeer = ApiGroupOutPeer ( groupId , res . accessHash ) , < nl > seq = res . seqstate . seq , < nl > state = res . seqstate . state . toByteArray , < nl > - users = groupUserIds . toVector , < nl > + users = ( userIds + client . userId ) . toVector , < nl > date = res . date < nl > ) ) < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 9299be6 . . d11c8c3 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 406 , 8 + 406 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) 
 
 val leftUserUpdatesNew = List ( 
 - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 ) 
 
 @ @ - 423 , 9 + 423 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } yield ( ) 
 ) 
 
 + / / read this dialog by user that leaves group . don ' t wait for ack 
 + dialogExt . messageRead ( apiGroupPeer , cmd . userId , 0L , dateMillis ) 
 val result : Future [ SeqStateDate ] = for { 
 - / / read this dialog by user that leaves group 
 - _ ← dialogExt . messageRead ( apiGroupPeer , cmd . userId , 0L , dateMillis ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / old group api updates / / 
 @ @ - 458 , 13 + 458 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 deliveryTag = Some ( Optimization . GroupV2 ) 
 ) 
 
 - / / push left user updates 
 - / / • with empty group members 
 - / / • that he can ' t view and invite members 
 - _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 - } 
 - 
 / / push left user that he is no longer a member 
 SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 userId = cmd . userId , 
 @ @ - 472 , 6 + 465 , 13 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 update = UpdateGroupMemberChanged ( groupId , isMember = false ) 
 ) 
 
 + / / push left user updates 
 + / / • with empty group members 
 + / / • that he can ' t view and invite members 
 + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 + } 
 + 
 } yield SeqStateDate ( seq , state , date ) 
 
 result andThen { case _ ⇒ commit ( evt ) } pipeTo sender ( ) 
 @ @ - 492 , 8 + 492 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val updateObsolete = UpdateGroupUserKickObsolete ( groupId , cmd . kickedUserId , cmd . kickerUserId , dateMillis , cmd . randomId ) 
 
 val kickedUserUpdatesNew : List [ Update ] = List ( 
 - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , 
 UpdateGroupMemberChanged ( groupId , isMember = false ) 
 ) 
 @ @ - 510 , 9 + 510 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } yield ( ) 
 ) 
 
 + / / read this dialog by kicked user . don ' t wait for ack 
 + dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) 
 val result : Future [ SeqStateDate ] = for { 
 - _ ← dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) 
 - 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / old group api updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 index 8bff8e9 . . 2256681 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 package im . actor . server . api . rpc . service . groups 
 
 + import java . time . Instant 
 + 
 import akka . actor . ActorSystem 
 import akka . http . scaladsl . util . FastFuture 
 import im . actor . api . rpc . PeerHelpers . _ 
 @ @ - 111 , 7 + 113 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 withGroupOutPeer ( groupPeer ) { 
 for { 
 SeqState ( seq , state ) ← groupExt . transferOwnership ( groupPeer . groupId , client . userId , client . authId , newOwner ) 
 - } yield Ok ( ResponseSeqDate ( seq , state . toByteArray , 0 ) ) 
 + } yield Ok ( ResponseSeqDate ( seq , state . toByteArray , Instant . now . toEpochMilli ) ) 
 } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index c26a25e . . 16f87dc 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 105 , 13 + 105 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 message : ApiMessage 
 ) : Unit = 
 withCreated ( s ) { _ ⇒ 
 - val date = new DateTime ( dateMillis ) 
 - 
 val result = 
 if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) 
 } else { 
 - db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) 
 + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) 
 } 
 
 result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index e928261 . . 302ab28 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 101 , 7 + 101 , 11 @ @ object HistoryUtils { 
 messageContentData = messageContentData , 
 deletedAt = None 
 ) ) 
 - _ ← DialogRepo . updateLastMessageDatePrivate ( userId , toPeer , date ) 
 + _ ← toPeer . ` type ` match { 
 + case PeerType . Private ⇒ DialogRepo . updateLastMessageDatePrivate ( userId , toPeer , date ) 
 + case PeerType . Group ⇒ DialogRepo . updateLastMessageDateGroup ( toPeer , date ) 
 + case _ ⇒ throw new RuntimeException ( s " Unknown peer type $ { toPeer . typ } " ) 
 + } 
 } yield ( ) 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index dc8b789 . . 4f95eaf 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 11 , 14 + 11 , 12 @ @ import im . actor . api . rpc . messaging . ApiServiceMessage 
 import im . actor . api . rpc . misc . ApiExtension 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . api . rpc . users . ApiSex 
 - import im . actor . concurrent . FutureExt 
 import im . actor . server . ApiConversions . _ 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . dialog . DialogExtension 
 import im . actor . server . model . PeerType 
 - import im . actor . server . persist . dialog 
 - import im . actor . server . persist . dialog . DialogRepo 
 - import im . actor . server . { persist ⇒ p , model } 
 + import im . actor . server . persist . _ 
 + import im . actor . server . model 
 import im . actor . server . event . TSEvent 
 import im . actor . server . file . { ImageUtils , Avatar } 
 import im . actor . server . group . GroupErrors . _ 
 @ @ - 57 , 7 + 55 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 
 db . run ( for { 
 _ ← createInDb ( state , rng . nextLong ( ) ) 
 - _ ← p . GroupUserRepo . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) 
 + _ ← GroupUserRepo . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) 
 _ ← DBIO . from ( userExt . broadcastUserUpdate ( creatorUserId , update , pushText = None , isFat = true , reduceKey = None , deliveryId = Some ( s " creategroup _ $ { groupId } _ $ { update . randomId } " ) ) ) 
 } yield CreateInternalAck ( accessHash ) ) pipeTo sender ( ) onFailure { 
 case e ⇒ 
 @ @ - 89 , 7 + 87 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 
 db . run ( 
 for { 
 - _ ← p . GroupRepo . create ( 
 + _ ← GroupRepo . create ( 
 model . Group ( 
 id = groupId , 
 creatorUserId = state . creatorUserId , 
 @ @ - 103 , 8 + 101 , 10 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 randomId , 
 isHidden = false 
 ) 
 - _ ← p . GroupUserRepo . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) 
 - _ ← DBIO . from ( dialogExt . writeMessage ( ApiPeer ( ApiPeerType . Group , state . id ) , creatorUserId , date , randomId , serviceMessage ) ) 
 + _ ← GroupUserRepo . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) 
 + _ ← DBIO . from ( Future . sequence ( ( userIds + creatorUserId ) map { uid ⇒ 
 + dialogExt . writeMessageSelf ( uid , ApiPeer ( ApiPeerType . Group , state . id ) , creatorUserId , date , randomId , serviceMessage ) 
 + } ) ) 
 seqstate ← if ( isBot ( state , creatorUserId ) ) DBIO . successful ( SeqState ( 0 , ByteString . EMPTY ) ) 
 else DBIO . from ( seqUpdExt . deliverSingleUpdate ( creatorUserId , update , PushRules ( isFat = true ) , reduceKey = None , deliveryId = s " creategroup _ $ { groupId } _ $ randomId " ) ) 
 } yield CreateAck ( state . accessHash , seqstate , date . getMillis ) 
 @ @ - 123 , 7 + 123 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 
 ( for { 
 _ ← userExt . create ( botUserId , nextAccessSalt ( ThreadLocalSecureRandom . current ( ) ) , None , " Bot " , " US " , ApiSex . Unknown , isBot = true ) 
 - _ ← db . run ( p . GroupBotRepo . create ( groupId , botUserId , botToken ) ) 
 + _ ← db . run ( GroupBotRepo . create ( groupId , botUserId , botToken ) ) 
 _ ← integrationTokensKv . upsert ( botToken , groupId ) 
 } yield ( ) ) onFailure { 
 case e ⇒ 
 @ @ - 142 , 7 + 142 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 val serviceMessage = GroupServiceMessages . userInvited ( userId ) 
 
 for { 
 - _ ← db . run ( p . GroupUserRepo . create ( groupId , userId , inviterUserId , date , None , isAdmin = false ) ) 
 + _ ← db . run ( GroupUserRepo . create ( groupId , userId , inviterUserId , date , None , isAdmin = false ) ) 
 _ ← userExt . broadcastUserUpdate ( userId , inviteeUpdate , pushText = Some ( PushTexts . Invited ) , isFat = true , reduceKey = None , deliveryId = Some ( s " invite _ $ { groupId } _ $ { randomId } " ) ) 
 / / TODO : # perf the following broadcasts do update serializing per each user 
 _ ← Future . sequence ( memberIds . toSeq . filterNot ( _ = = inviterUserId ) . map ( userExt . broadcastUserUpdate ( _ , userAddedUpdate , Some ( PushTexts . Added ) , isFat = true , reduceKey = None , deliveryId = Some ( s " useradded _ $ { groupId } _ $ { randomId } " ) ) ) ) / / use broadcastUsersUpdate maybe ? 
 @ @ - 175 , 8 + 175 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 val date = new DateTime 
 val randomId = ThreadLocalSecureRandom . current ( ) . nextLong ( ) 
 for { 
 - exists ← p . GroupUserRepo . exists ( groupId , joiningUserId ) 
 - _ ← if ( exists ) DBIO . successful ( ( ) ) else p . GroupUserRepo . create ( groupId , joiningUserId , invitingUserId , date , Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , isAdmin = false ) 
 + exists ← GroupUserRepo . exists ( groupId , joiningUserId ) 
 + _ ← if ( exists ) DBIO . successful ( ( ) ) else GroupUserRepo . create ( groupId , joiningUserId , invitingUserId , date , Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , isAdmin = false ) 
 seqstatedate ← DBIO . from ( DialogExtension ( system ) . sendMessage ( 
 peer = ApiPeer ( ApiPeerType . Group , groupId ) , 
 senderUserId = joiningUserId , 
 @ @ - 235 , 7 + 235 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 val memberIds = group . members . keySet 
 
 for { 
 - _ ← db . run ( p . AvatarDataRepo . createOrUpdate ( avatarData ) ) 
 + _ ← db . run ( AvatarDataRepo . createOrUpdate ( avatarData ) ) 
 ( seqstate , _ ) ← seqUpdExt . broadcastOwnSingleUpdate ( clientUserId , memberIds , update ) 
 } yield { 
 dialogExt . writeMessage ( 
 @ @ - 254 , 8 + 254 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 protected def makePublic ( group : Group , description : String ) : Unit = { 
 persistStashingReply ( Vector ( TSEvent ( now ( ) , BecamePublic ( ) ) , TSEvent ( now ( ) , AboutUpdated ( Some ( description ) ) ) ) , group ) { _ ⇒ 
 db . run ( DBIO . sequence ( Seq ( 
 - p . GroupRepo . makePublic ( groupId ) , 
 - p . GroupRepo . updateAbout ( groupId , Some ( description ) ) 
 + GroupRepo . makePublic ( groupId ) , 
 + GroupRepo . updateAbout ( groupId , Some ( description ) ) 
 ) ) ) map ( _ ⇒ MakePublicAck ( ) ) 
 } 
 } 
 @ @ - 270 , 7 + 270 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 val serviceMessage = GroupServiceMessages . changedTitle ( title ) 
 
 for { 
 - _ ← db . run ( p . GroupRepo . updateTitle ( groupId , title , clientUserId , randomId , date ) ) 
 + _ ← db . run ( GroupRepo . updateTitle ( groupId , title , clientUserId , randomId , date ) ) 
 _ ← dialogExt . writeMessage ( 
 ApiPeer ( ApiPeerType . Group , groupId ) , 
 clientUserId , 
 @ @ - 298 , 7 + 298 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 val serviceMessage = GroupServiceMessages . changedTopic ( trimmed ) 
 val update = UpdateGroupTopicChanged ( groupId = groupId , randomId = randomId , userId = clientUserId , topic = trimmed , date = dateMillis ) 
 for { 
 - _ ← db . run ( p . GroupRepo . updateTopic ( groupId , trimmed ) ) 
 + _ ← db . run ( GroupRepo . updateTopic ( groupId , trimmed ) ) 
 _ ← dialogExt . writeMessage ( 
 ApiPeer ( ApiPeerType . Group , groupId ) , 
 clientUserId , 
 @ @ - 330 , 7 + 330 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 val update = UpdateGroupAboutChanged ( groupId , trimmed ) 
 val serviceMessage = GroupServiceMessages . changedAbout ( trimmed ) 
 db . run ( for { 
 - _ ← p . GroupRepo . updateAbout ( groupId , trimmed ) 
 + _ ← GroupRepo . updateAbout ( groupId , trimmed ) 
 _ ← DBIO . from ( dialogExt . writeMessage ( 
 ApiPeer ( ApiPeerType . Group , groupId ) , 
 clientUserId , 
 @ @ - 363 , 7 + 363 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 val updated = group . members . updated ( candidateId , group . members ( candidateId ) . copy ( isAdmin = true ) ) 
 val members = updated . values . map ( _ . asStruct ) . toVector 
 for { 
 - _ ← db . run ( p . GroupUserRepo . makeAdmin ( groupId , candidateId ) ) 
 + _ ← db . run ( GroupUserRepo . makeAdmin ( groupId , candidateId ) ) 
 ( seqState , _ ) ← seqUpdExt . broadcastOwnSingleUpdate ( 
 clientUserId , 
 group . members . keySet - clientUserId , 
 @ @ - 384 , 7 + 384 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 val newToken = accessToken ( ThreadLocalSecureRandom . current ( ) ) 
 persistStashingReply ( TSEvent ( now ( ) , IntegrationTokenRevoked ( newToken ) ) , group ) { _ ⇒ 
 for { 
 - _ ← db . run ( p . GroupBotRepo . updateToken ( groupId , newToken ) ) 
 + _ ← db . run ( GroupBotRepo . updateToken ( groupId , newToken ) ) 
 _ ← integrationTokensKv . delete ( oldToken . getOrElse ( " " ) ) 
 _ ← integrationTokensKv . upsert ( newToken , groupId ) 
 } yield RevokeIntegrationTokenAck ( newToken ) 
 @ @ - 395 , 8 + 395 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 private def removeUser ( userId : Int , memberIds : Set [ Int ] , clientAuthSid : Int , serviceMessage : ApiServiceMessage , update : Update , date : DateTime , randomId : Long ) : DBIO [ SeqStateDate ] = { 
 val groupPeer = model . Peer ( PeerType . Group , groupId ) 
 for { 
 - _ ← p . GroupUserRepo . delete ( groupId , userId ) 
 - _ ← p . GroupInviteTokenRepo . revoke ( groupId , userId ) 
 + _ ← GroupUserRepo . delete ( groupId , userId ) 
 + _ ← GroupInviteTokenRepo . revoke ( groupId , userId ) 
 ( SeqState ( seq , state ) , _ ) ← DBIO . from ( userExt . broadcastClientAndUsersUpdate ( 
 clientUserId = userId , 
 clientAuthSid = clientAuthSid , 
 @ @ - 422 , 7 + 422 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 ThreadLocalSecureRandom . current ( ) . nextLong ( ) 
 
 private def createInDb ( state : Group , randomId : Long ) = 
 - p . GroupRepo . create ( 
 + GroupRepo . create ( 
 model . Group ( 
 id = groupId , 
 creatorUserId = state . creatorUserId , 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 index 92e00f3 . . 88efe66 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 @ @ - 149 , 14 + 149 , 12 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 withValidGroupTitle ( title ) { validTitle ⇒ 
 val groupId = nextIntId ( ThreadLocalSecureRandom . current ( ) ) 
 val userIds = users . map ( _ . userId ) . toSet 
 - val groupUserIds = userIds + client . userId 
 - 
 val f = for ( res ← groupExt . create ( groupId , title , randomId , userIds ) ) yield { 
 Ok ( ResponseCreateGroupObsolete ( 
 groupPeer = ApiGroupOutPeer ( groupId , res . accessHash ) , 
 seq = res . seqstate . seq , 
 state = res . seqstate . state . toByteArray , 
 - users = groupUserIds . toVector , 
 + users = ( userIds + client . userId ) . toVector , 
 date = res . date 
 ) ) 
 }
