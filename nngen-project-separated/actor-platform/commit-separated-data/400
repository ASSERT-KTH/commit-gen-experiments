BLEU SCORE: 0.33649324423301513

TEST MSG: fix + perf ( server : messaging ) : DialogProcessors are UserProcessor ' s child
GENERATED MSG: Revert " fix ( server : messaging ) : reorder chat groups on renames "

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index 30507c2 . . 6c0d99c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 78 , 12 + 78 , 9 @ @ private trait DialogRootQueryHandlers { < nl > fetchDialogGroups ( ) map ( GetDialogGroupsResponse ( _ ) ) < nl > < nl > def getCounter ( ) : Future [ GetCounterResponse ] = { < nl > - val refs = state . active . map ( peer ⇒ peer → dialogRef ( peer ) ) . toSeq < nl > - < nl > for { < nl > - counters ← FutureExt . ftraverse ( refs ) { < nl > - case ( peer , ref ) ⇒ < nl > - ( ref ? DialogQueries . GetCounter ( Some ( peer ) ) ) . mapTo [ DialogQueries . GetCounterResponse ] map ( _ . counter ) < nl > + counters ← FutureExt . ftraverse ( state . active . map ( identity ) . toSeq ) { peer ⇒ < nl > + ( context . parent ? DialogQueries . GetCounter ( Some ( peer ) ) ) . mapTo [ DialogQueries . GetCounterResponse ] map ( _ . counter ) < nl > } < nl > } yield GetCounterResponse ( counters . sum ) < nl > } < nl > @ @ - 144 , 29 + 141 , 18 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > persistAllAsync ( events ) ( e ⇒ commit ( e ) ) < nl > < nl > deferAsync ( ( ) ) { _ ⇒ < nl > - handleDialogCommand ( dc ) < nl > + sender ( ) ! ( ( ) ) < nl > < nl > if ( ! isCreated | | ! isShown ) < nl > sendChatGroupsChanged ( ) < nl > } < nl > case None ⇒ < nl > - handleDialogCommand ( dc ) < nl > + sender ( ) ! ( ( ) ) < nl > } < nl > case Archive ( Some ( peer ) , clientAuthSid ) ⇒ archive ( peer , clientAuthSid map ( _ . value ) ) < nl > case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) < nl > case Favourite ( Some ( peer ) , clientAuthSid ) ⇒ favourite ( peer , clientAuthSid map ( _ . value ) ) < nl > case Unfavourite ( Some ( peer ) , clientAuthSid ) ⇒ unfavourite ( peer , clientAuthSid map ( _ . value ) ) < nl > - case dc : DialogCommand ⇒ handleDialogCommand ( dc ) < nl > - case dq : DialogQuery ⇒ handleDialogQuery ( dq ) < nl > - } < nl > - < nl > - def handleDialogCommand : PartialFunction [ DialogCommand , Unit ] = { < nl > - case ddc : DirectDialogCommand ⇒ dialogRef ( ddc ) forward ddc < nl > - case dc : DialogCommand ⇒ dialogRef ( dc . getDest ) forward dc < nl > - } < nl > - < nl > - def handleDialogQuery : PartialFunction [ DialogQuery , Unit ] = { < nl > - case dq : DialogQuery ⇒ dialogRef ( dq . getDest ) forward dq < nl > } < nl > < nl > private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > @ @ - 226 , 23 + 212 , 6 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > < nl > private def isDialogOnTop ( peer : Peer ) : Boolean = state . mobile . headOption . exists ( _ . peer = = peer ) < nl > < nl > - protected def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { < nl > - val peer = dc . getDest match { < nl > - case Peer ( PeerType . Group , _ ) ⇒ dc . getDest < nl > - case Peer ( PeerType . Private , _ ) ⇒ if ( dc . getOrigin = = selfPeer ) dc . getDest else dc . getOrigin < nl > - } < nl > - dialogRef ( peer ) < nl > - } < nl > - < nl > - protected def dialogRef ( peer : Peer ) : ActorRef = < nl > - context . child ( dialogName ( peer ) ) getOrElse context . actorOf ( DialogProcessor . props ( userId , peer , extensions ) , dialogName ( peer ) ) < nl > - < nl > - private def dialogName ( peer : Peer ) : String = peer . typ match { < nl > - case PeerType . Private ⇒ s " Private _ $ { peer . id } " < nl > - case PeerType . Group ⇒ s " Group _ $ { peer . id } " < nl > - case other ⇒ throw new Exception ( s " Unknown peer type : $ other " ) < nl > - } < nl > - < nl > protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { < nl > for { < nl > favInfos ← Future . sequence ( state . active . favourites . toSeq map ( peer ⇒ getInfo ( peer ) map ( _ . getInfo ) ) ) flatMap sortActiveGroup < nl > @ @ - 251 , 7 + 220 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > } yield { < nl > val base = List ( < nl > DialogGroup ( DialogGroupType . Groups , groupInfos ) , < nl > - DialogGroup ( DialogGroupType . DirectMessages , dmInfos . toSeq ) < nl > + DialogGroup ( DialogGroupType . DirectMessages , dmInfos ) < nl > ) < nl > < nl > if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos ) : : base < nl > @ @ - 269 , 7 + 238 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > } < nl > < nl > protected def getInfo ( peer : Peer ) : Future [ DialogQueries . GetInfoResponse ] = < nl > - ( dialogRef ( peer ) ? DialogQueries . GetInfo ( Some ( peer ) ) ) . mapTo [ GetInfoResponse ] < nl > + ( context . parent ? DialogQueries . GetInfo ( Some ( peer ) ) ) . mapTo [ GetInfoResponse ] < nl > < nl > private def sortActiveGroup ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { < nl > for { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > index b2d9fb5 . . 3f928f1 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > @ @ - 72 , 7 + 72 , 7 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture < nl > } < nl > < nl > protected final def working ( state : State ) : Receive = handleCommand ( state ) orElse handleQuery ( state ) orElse { < nl > - case unmatched ⇒ log . warning ( " Unmatched message : { } , sender : { } " , unmatched , sender ( ) ) < nl > + case unmatched ⇒ log . warning ( " Unmatched message : { } , { } , sender : { } " , unmatched . getClass . getName , unmatched , sender ( ) ) < nl > } < nl > < nl > protected final def stashingBehavior : Receive = unstashing orElse { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > index a251bb2 . . e7a8c42 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > @ @ - 12 , 12 + 12 , 13 @ @ import im . actor . server . bots . BotCommand < nl > import im . actor . server . cqrs . TaggedEvent < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . _ < nl > + import im . actor . server . model . { Peer , PeerType } < nl > import im . actor . server . office . { PeerProcessor , StopOffice } < nl > import im . actor . server . sequence . SeqUpdatesExtension < nl > import im . actor . server . social . { SocialExtension , SocialManagerRegion } < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > - import scala . concurrent . ExecutionContext < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > import scala . concurrent . duration . _ < nl > import scala . util . Try < nl > < nl > @ @ - 244 , 10 + 245 , 25 @ @ private [ user ] final class UserProcessor < nl > case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) < nl > case e @ DialogRootEnvelope ( query , command ) ⇒ < nl > val msg = e . getAllFields . values . head < nl > - dialogRoot ( state . internalExtensions ) forward msg < nl > + < nl > + ( dialogRoot ( state . internalExtensions ) ? msg ) pipeTo sender ( ) < nl > case de : DialogEnvelope ⇒ < nl > val msg = de . getAllFields . values . head < nl > - dialogRoot ( state . internalExtensions ) forward msg < nl > + < nl > + ( for { < nl > + result ← msg match { < nl > + case dc : DialogCommand if dc . isInstanceOf [ DialogCommands . SendMessage ] | | dc . isInstanceOf [ DialogCommands . WriteMessageSelf ] ⇒ < nl > + for { < nl > + _ ← dialogRoot ( state . internalExtensions ) ? msg < nl > + result ← handleDialogCommand ( state ) ( dc ) < nl > + } yield result < nl > + case dc : DialogCommand ⇒ handleDialogCommand ( state ) ( dc ) < nl > + case dq : DialogQuery ⇒ handleDialogQuery ( state ) ( dq ) < nl > + } < nl > + } yield result ) pipeTo sender ( ) < nl > + / / messages sent from DialogRoot : < nl > + case dc : DialogCommand ⇒ handleDialogCommand ( state ) ( dc ) pipeTo sender ( ) < nl > + case dq : DialogQuery ⇒ handleDialogQuery ( state ) ( dq ) pipeTo sender ( ) < nl > } < nl > < nl > override protected def handleQuery ( state : UserState ) : Receive = { < nl > @ @ - 262 , 11 + 278 , 6 @ @ private [ user ] final class UserProcessor < nl > case GetName ( _ ) ⇒ getName ( state ) < nl > } < nl > < nl > - private def dialogRoot ( extensions : Seq [ ApiExtension ] ) : ActorRef = { < nl > - val name = " DialogRoot " < nl > - context . child ( name ) . getOrElse ( context . actorOf ( DialogRoot . props ( userId , extensions ) , name ) ) < nl > - } < nl > - < nl > protected [ this ] var userStateMaybe : Option [ UserState ] = None < nl > < nl > override def receiveRecover : Receive = { < nl > @ @ - 285 , 4 + 296 , 38 @ @ private [ user ] final class UserProcessor < nl > log . error ( " Unmatched recovery event { } " , unmatched ) < nl > } < nl > < nl > + private def handleDialogCommand ( state : UserState ) : PartialFunction [ DialogCommand , Future [ Any ] ] = { < nl > + case ddc : DirectDialogCommand ⇒ dialogRef ( state , ddc ) ? ddc < nl > + case dc : DialogCommand ⇒ dialogRef ( state , dc . getDest ) ? dc < nl > + } < nl > + < nl > + private def handleDialogQuery ( state : UserState ) : PartialFunction [ DialogQuery , Future [ Any ] ] = { < nl > + case dq : DialogQuery ⇒ dialogRef ( state , dq . getDest ) ? dq < nl > + } < nl > + < nl > + private def dialogRef ( state : UserState , dc : DirectDialogCommand ) : ActorRef = { < nl > + val peer = dc . getDest match { < nl > + case Peer ( PeerType . Group , _ ) ⇒ dc . getDest < nl > + case Peer ( PeerType . Private , _ ) ⇒ if ( dc . getOrigin . id = = userId ) dc . getDest else dc . getOrigin < nl > + } < nl > + dialogRef ( state , peer ) < nl > + } < nl > + < nl > + private def dialogRef ( state : UserState , peer : Peer ) : ActorRef = < nl > + try { < nl > + context . child ( dialogName ( peer ) ) getOrElse context . actorOf ( DialogProcessor . props ( userId , peer , state . internalExtensions ) , dialogName ( peer ) ) < nl > + } catch { < nl > + case _ : InvalidActorNameException ⇒ dialogRef ( state , peer ) < nl > + } < nl > + < nl > + private def dialogRoot ( extensions : Seq [ ApiExtension ] ) : ActorRef = { < nl > + val name = " DialogRoot " < nl > + context . child ( name ) . getOrElse ( context . actorOf ( DialogRoot . props ( userId , extensions ) , name ) ) < nl > + } < nl > + < nl > + private def dialogName ( peer : Peer ) : String = peer . typ match { < nl > + case PeerType . Private ⇒ s " Private _ $ { peer . id } " < nl > + case PeerType . Group ⇒ s " Group _ $ { peer . id } " < nl > + case other ⇒ throw new Exception ( s " Unknown peer type : $ other " ) < nl > + } < nl > } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index bccf85d . . a6b122f 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 122 , 10 + 122 , 6 @ @ message DialogRootCommands { < nl > < nl > Peer dest = 1 ; < nl > } < nl > - < nl > - message SendChatGroupsChanged { < nl > - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootCommand " ; < nl > - } < nl > } < nl > < nl > message DialogRootQueries { < nl > @ @ - 191 , 7 + 187 , 6 @ @ message DialogRootEnvelope { < nl > DialogRootCommands . Favourite favourite = 7 ; < nl > DialogRootCommands . Unfavourite unfavourite = 8 ; < nl > DialogRootCommands . Delete delete = 9 ; < nl > - DialogRootCommands . SendChatGroupsChanged send _ chat _ groups _ changed = 12 ; < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 33457e8 . . c091d83 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 181 , 11 + 181 , 6 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > . mapTo [ SeqState ] < nl > } < nl > < nl > - def sendChatGroupsChanged ( userId : Int ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? < nl > - UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withSendChatGroupsChanged ( DialogRootCommands . SendChatGroupsChanged ( ) ) ) ) < nl > - . mapTo [ SeqState ] < nl > - < nl > def setReaction ( userId : Int , authSid : Int , peer : Peer , randomId : Long , code : String ) : Future [ SetReactionAck ] = < nl > withValidPeer ( peer , userId ) { < nl > ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withSetReaction ( SetReaction ( < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index f11648d . . 5d4e650 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 144 , 7 + 144 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > handleDialogCommand ( dc ) < nl > < nl > if ( ! isCreated | | ! isShown ) < nl > - deliverChatGroupsChanged ( ) < nl > + sendChatGroupsChanged ( ) < nl > } < nl > case None ⇒ < nl > handleDialogCommand ( dc ) < nl > @ @ - 153 , 7 + 153 , 6 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) < nl > case Favourite ( Some ( peer ) , clientAuthSid ) ⇒ favourite ( peer , clientAuthSid map ( _ . value ) ) < nl > case Unfavourite ( Some ( peer ) , clientAuthSid ) ⇒ unfavourite ( peer , clientAuthSid map ( _ . value ) ) < nl > - case SendChatGroupsChanged ( ) ⇒ sendChatGroupsChanged ( ) < nl > case dc : DialogCommand ⇒ handleDialogCommand ( dc ) < nl > case dq : DialogQuery ⇒ handleDialogQuery ( dq ) < nl > } < nl > @ @ - 168 , 34 + 167 , 34 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > } < nl > < nl > private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - if ( isArchived ( peer ) ) deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > + if ( isArchived ( peer ) ) sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > else persist ( Archived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > + sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > < nl > private def unarchive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - if ( ! isArchived ( peer ) ) deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > + if ( ! isArchived ( peer ) ) sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > else persist ( Unarchived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > + sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > < nl > private def favourite ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - if ( isFavourited ( peer ) ) deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > + if ( isFavourited ( peer ) ) sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > else persist ( Favourited ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > + sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > < nl > private def unfavourite ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - if ( ! isFavourited ( peer ) ) deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > + if ( ! isFavourited ( peer ) ) sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > else persist ( Unfavourited ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > + sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > < nl > @ @ - 214 , 8 + 213 , 6 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > } < nl > } < nl > < nl > - private def sendChatGroupsChanged ( ) = deliverChatGroupsChanged ( ) pipeTo sender ( ) < nl > - < nl > private def isArchived ( peer : Peer ) : Boolean = state . archived . exists ( _ . peer = = peer ) < nl > < nl > private def isFavourited ( peer : Peer ) : Boolean = state . active . favourites . exists ( _ . peer = = peer ) < nl > @ @ - 259 , 7 + 256 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > } < nl > } < nl > < nl > - private def deliverChatGroupsChanged ( ignoreAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = { < nl > + private def sendChatGroupsChanged ( ignoreAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = { < nl > for { < nl > groups ← DialogExtension ( context . system ) . fetchApiGroupedDialogs ( userId ) < nl > update = UpdateChatGroupsChanged ( groups ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 2cb6451 . . eff32f7 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 30 , 7 + 30 , 6 @ @ import org . joda . time . DateTime < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . Future < nl > - import scala . util . Success < nl > < nl > private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupCommandHelpers with UserACL { < nl > this : GroupProcessor ⇒ < nl > @ @ - 308 , 7 + 307 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > val update = UpdateGroupTitleChanged ( groupId = groupId , userId = clientUserId , title = title , date = date . toEpochMilli , randomId = randomId ) < nl > val serviceMessage = GroupServiceMessages . changedTitle ( title ) < nl > < nl > - ( for { < nl > + for { < nl > _ ← db . run ( GroupRepo . updateTitle ( groupId , title , clientUserId , randomId , date ) ) < nl > _ ← dialogExt . writeMessage ( < nl > ApiPeer ( ApiPeerType . Group , groupId ) , < nl > @ @ - 323 , 9 + 322 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > update , < nl > PushRules ( ) . withData ( PushData ( ) . withText ( PushTexts . TitleChanged ) ) < nl > ) < nl > - } yield SeqStateDate ( seqstate . seq , seqstate . state , date . toEpochMilli ) ) andThen { < nl > - case Success ( _ ) ⇒ group . members . map ( _ . _ 1 ) foreach ( dialogExt . sendChatGroupsChanged ( _ ) ) < nl > - } < nl > + } yield SeqStateDate ( seqstate . seq , seqstate . state , date . toEpochMilli ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index efe82d6 . . 7d8f59b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 160 , 10 + 160 , 7 @ @ private [ user ] trait UserCommandHandlers { < nl > relatedUserIds ← getRelations ( userId ) < nl > ( seqstate , _ ) ← seqUpdatesExt . broadcastOwnSingleUpdate ( userId , relatedUserIds , update ) < nl > _ ← db . run ( UserRepo . setName ( userId , name ) ) < nl > - } yield { < nl > - relatedUserIds foreach ( dialogExt . sendChatGroupsChanged ( _ ) ) < nl > - seqstate < nl > - } < nl > + } yield seqstate < nl > } < nl > } else { < nl > replyTo ! Status . Failure ( UserErrors . InvalidName ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > index fc2ea73 . . 431c5e6 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > @ @ - 9 , 13 + 9 , 11 @ @ import akka . util . Timeout < nl > import im . actor . api . rpc . users . UpdateUserLocalNameChanged < nl > import im . actor . server . cqrs . { Event , Processor , ProcessorState } < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . dialog . DialogExtension < nl > import im . actor . server . persist . contact . UserContactRepo < nl > import im . actor . server . sequence . SeqState < nl > import im . actor . server . user . UserCommands . EditLocalName < nl > < nl > import scala . concurrent . Future < nl > - import scala . util . Success < nl > < nl > private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . empty ) extends ProcessorState [ UserContactsState ] { < nl > import UserEvents . _ < nl > @ @ - 44 , 14 + 42 , 11 @ @ private [ user ] final class UserContactsActor ( userId : Int ) extends Processor [ UserC < nl > import UserQueries . _ < nl > import UserEvents . _ < nl > < nl > - import context . dispatcher < nl > - < nl > override def persistenceId : String = s " User _ $ { userId } _ Contacts " < nl > < nl > override def getInitialState : UserContactsState = UserContactsState ( ) < nl > < nl > private val userExt = UserExtension ( context . system ) < nl > - private val dialogExt = DialogExtension ( context . system ) < nl > private val db = DbExtension ( context . system ) . db < nl > < nl > override protected def handleCommand : Receive = { < nl > @ @ - 61 , 9 + 56 , 7 @ @ private [ user ] final class UserContactsActor ( userId : Int ) extends Processor [ UserC < nl > < nl > override protected def handleQuery : QueryHandler = { < nl > case GetLocalName ( _ , contactUserId ) ⇒ < nl > - Future . successful ( GetLocalNameResponse ( state . localNames . get ( contactUserId ) ) ) andThen { < nl > - case Success ( _ ) ⇒ dialogExt . sendChatGroupsChanged ( userId ) < nl > - } < nl > + Future . successful ( GetLocalNameResponse ( state . localNames . get ( contactUserId ) ) ) < nl > } < nl > < nl > private def editLocalName ( contactUserId : Int , nameOpt : Option [ String ] , supressUpdate : Boolean ) : Unit = {

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index 30507c2 . . 6c0d99c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 78 , 12 + 78 , 9 @ @ private trait DialogRootQueryHandlers { 
 fetchDialogGroups ( ) map ( GetDialogGroupsResponse ( _ ) ) 
 
 def getCounter ( ) : Future [ GetCounterResponse ] = { 
 - val refs = state . active . map ( peer ⇒ peer → dialogRef ( peer ) ) . toSeq 
 - 
 for { 
 - counters ← FutureExt . ftraverse ( refs ) { 
 - case ( peer , ref ) ⇒ 
 - ( ref ? DialogQueries . GetCounter ( Some ( peer ) ) ) . mapTo [ DialogQueries . GetCounterResponse ] map ( _ . counter ) 
 + counters ← FutureExt . ftraverse ( state . active . map ( identity ) . toSeq ) { peer ⇒ 
 + ( context . parent ? DialogQueries . GetCounter ( Some ( peer ) ) ) . mapTo [ DialogQueries . GetCounterResponse ] map ( _ . counter ) 
 } 
 } yield GetCounterResponse ( counters . sum ) 
 } 
 @ @ - 144 , 29 + 141 , 18 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 persistAllAsync ( events ) ( e ⇒ commit ( e ) ) 
 
 deferAsync ( ( ) ) { _ ⇒ 
 - handleDialogCommand ( dc ) 
 + sender ( ) ! ( ( ) ) 
 
 if ( ! isCreated | | ! isShown ) 
 sendChatGroupsChanged ( ) 
 } 
 case None ⇒ 
 - handleDialogCommand ( dc ) 
 + sender ( ) ! ( ( ) ) 
 } 
 case Archive ( Some ( peer ) , clientAuthSid ) ⇒ archive ( peer , clientAuthSid map ( _ . value ) ) 
 case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) 
 case Favourite ( Some ( peer ) , clientAuthSid ) ⇒ favourite ( peer , clientAuthSid map ( _ . value ) ) 
 case Unfavourite ( Some ( peer ) , clientAuthSid ) ⇒ unfavourite ( peer , clientAuthSid map ( _ . value ) ) 
 - case dc : DialogCommand ⇒ handleDialogCommand ( dc ) 
 - case dq : DialogQuery ⇒ handleDialogQuery ( dq ) 
 - } 
 - 
 - def handleDialogCommand : PartialFunction [ DialogCommand , Unit ] = { 
 - case ddc : DirectDialogCommand ⇒ dialogRef ( ddc ) forward ddc 
 - case dc : DialogCommand ⇒ dialogRef ( dc . getDest ) forward dc 
 - } 
 - 
 - def handleDialogQuery : PartialFunction [ DialogQuery , Unit ] = { 
 - case dq : DialogQuery ⇒ dialogRef ( dq . getDest ) forward dq 
 } 
 
 private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 @ @ - 226 , 23 + 212 , 6 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 
 private def isDialogOnTop ( peer : Peer ) : Boolean = state . mobile . headOption . exists ( _ . peer = = peer ) 
 
 - protected def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { 
 - val peer = dc . getDest match { 
 - case Peer ( PeerType . Group , _ ) ⇒ dc . getDest 
 - case Peer ( PeerType . Private , _ ) ⇒ if ( dc . getOrigin = = selfPeer ) dc . getDest else dc . getOrigin 
 - } 
 - dialogRef ( peer ) 
 - } 
 - 
 - protected def dialogRef ( peer : Peer ) : ActorRef = 
 - context . child ( dialogName ( peer ) ) getOrElse context . actorOf ( DialogProcessor . props ( userId , peer , extensions ) , dialogName ( peer ) ) 
 - 
 - private def dialogName ( peer : Peer ) : String = peer . typ match { 
 - case PeerType . Private ⇒ s " Private _ $ { peer . id } " 
 - case PeerType . Group ⇒ s " Group _ $ { peer . id } " 
 - case other ⇒ throw new Exception ( s " Unknown peer type : $ other " ) 
 - } 
 - 
 protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { 
 for { 
 favInfos ← Future . sequence ( state . active . favourites . toSeq map ( peer ⇒ getInfo ( peer ) map ( _ . getInfo ) ) ) flatMap sortActiveGroup 
 @ @ - 251 , 7 + 220 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 } yield { 
 val base = List ( 
 DialogGroup ( DialogGroupType . Groups , groupInfos ) , 
 - DialogGroup ( DialogGroupType . DirectMessages , dmInfos . toSeq ) 
 + DialogGroup ( DialogGroupType . DirectMessages , dmInfos ) 
 ) 
 
 if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos ) : : base 
 @ @ - 269 , 7 + 238 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 } 
 
 protected def getInfo ( peer : Peer ) : Future [ DialogQueries . GetInfoResponse ] = 
 - ( dialogRef ( peer ) ? DialogQueries . GetInfo ( Some ( peer ) ) ) . mapTo [ GetInfoResponse ] 
 + ( context . parent ? DialogQueries . GetInfo ( Some ( peer ) ) ) . mapTo [ GetInfoResponse ] 
 
 private def sortActiveGroup ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { 
 for { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 index b2d9fb5 . . 3f928f1 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 @ @ - 72 , 7 + 72 , 7 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture 
 } 
 
 protected final def working ( state : State ) : Receive = handleCommand ( state ) orElse handleQuery ( state ) orElse { 
 - case unmatched ⇒ log . warning ( " Unmatched message : { } , sender : { } " , unmatched , sender ( ) ) 
 + case unmatched ⇒ log . warning ( " Unmatched message : { } , { } , sender : { } " , unmatched . getClass . getName , unmatched , sender ( ) ) 
 } 
 
 protected final def stashingBehavior : Receive = unstashing orElse { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 index a251bb2 . . e7a8c42 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 @ @ - 12 , 12 + 12 , 13 @ @ import im . actor . server . bots . BotCommand 
 import im . actor . server . cqrs . TaggedEvent 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . _ 
 + import im . actor . server . model . { Peer , PeerType } 
 import im . actor . server . office . { PeerProcessor , StopOffice } 
 import im . actor . server . sequence . SeqUpdatesExtension 
 import im . actor . server . social . { SocialExtension , SocialManagerRegion } 
 import slick . driver . PostgresDriver . api . _ 
 
 - import scala . concurrent . ExecutionContext 
 + import scala . concurrent . { ExecutionContext , Future } 
 import scala . concurrent . duration . _ 
 import scala . util . Try 
 
 @ @ - 244 , 10 + 245 , 25 @ @ private [ user ] final class UserProcessor 
 case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) 
 case e @ DialogRootEnvelope ( query , command ) ⇒ 
 val msg = e . getAllFields . values . head 
 - dialogRoot ( state . internalExtensions ) forward msg 
 + 
 + ( dialogRoot ( state . internalExtensions ) ? msg ) pipeTo sender ( ) 
 case de : DialogEnvelope ⇒ 
 val msg = de . getAllFields . values . head 
 - dialogRoot ( state . internalExtensions ) forward msg 
 + 
 + ( for { 
 + result ← msg match { 
 + case dc : DialogCommand if dc . isInstanceOf [ DialogCommands . SendMessage ] | | dc . isInstanceOf [ DialogCommands . WriteMessageSelf ] ⇒ 
 + for { 
 + _ ← dialogRoot ( state . internalExtensions ) ? msg 
 + result ← handleDialogCommand ( state ) ( dc ) 
 + } yield result 
 + case dc : DialogCommand ⇒ handleDialogCommand ( state ) ( dc ) 
 + case dq : DialogQuery ⇒ handleDialogQuery ( state ) ( dq ) 
 + } 
 + } yield result ) pipeTo sender ( ) 
 + / / messages sent from DialogRoot : 
 + case dc : DialogCommand ⇒ handleDialogCommand ( state ) ( dc ) pipeTo sender ( ) 
 + case dq : DialogQuery ⇒ handleDialogQuery ( state ) ( dq ) pipeTo sender ( ) 
 } 
 
 override protected def handleQuery ( state : UserState ) : Receive = { 
 @ @ - 262 , 11 + 278 , 6 @ @ private [ user ] final class UserProcessor 
 case GetName ( _ ) ⇒ getName ( state ) 
 } 
 
 - private def dialogRoot ( extensions : Seq [ ApiExtension ] ) : ActorRef = { 
 - val name = " DialogRoot " 
 - context . child ( name ) . getOrElse ( context . actorOf ( DialogRoot . props ( userId , extensions ) , name ) ) 
 - } 
 - 
 protected [ this ] var userStateMaybe : Option [ UserState ] = None 
 
 override def receiveRecover : Receive = { 
 @ @ - 285 , 4 + 296 , 38 @ @ private [ user ] final class UserProcessor 
 log . error ( " Unmatched recovery event { } " , unmatched ) 
 } 
 
 + private def handleDialogCommand ( state : UserState ) : PartialFunction [ DialogCommand , Future [ Any ] ] = { 
 + case ddc : DirectDialogCommand ⇒ dialogRef ( state , ddc ) ? ddc 
 + case dc : DialogCommand ⇒ dialogRef ( state , dc . getDest ) ? dc 
 + } 
 + 
 + private def handleDialogQuery ( state : UserState ) : PartialFunction [ DialogQuery , Future [ Any ] ] = { 
 + case dq : DialogQuery ⇒ dialogRef ( state , dq . getDest ) ? dq 
 + } 
 + 
 + private def dialogRef ( state : UserState , dc : DirectDialogCommand ) : ActorRef = { 
 + val peer = dc . getDest match { 
 + case Peer ( PeerType . Group , _ ) ⇒ dc . getDest 
 + case Peer ( PeerType . Private , _ ) ⇒ if ( dc . getOrigin . id = = userId ) dc . getDest else dc . getOrigin 
 + } 
 + dialogRef ( state , peer ) 
 + } 
 + 
 + private def dialogRef ( state : UserState , peer : Peer ) : ActorRef = 
 + try { 
 + context . child ( dialogName ( peer ) ) getOrElse context . actorOf ( DialogProcessor . props ( userId , peer , state . internalExtensions ) , dialogName ( peer ) ) 
 + } catch { 
 + case _ : InvalidActorNameException ⇒ dialogRef ( state , peer ) 
 + } 
 + 
 + private def dialogRoot ( extensions : Seq [ ApiExtension ] ) : ActorRef = { 
 + val name = " DialogRoot " 
 + context . child ( name ) . getOrElse ( context . actorOf ( DialogRoot . props ( userId , extensions ) , name ) ) 
 + } 
 + 
 + private def dialogName ( peer : Peer ) : String = peer . typ match { 
 + case PeerType . Private ⇒ s " Private _ $ { peer . id } " 
 + case PeerType . Group ⇒ s " Group _ $ { peer . id } " 
 + case other ⇒ throw new Exception ( s " Unknown peer type : $ other " ) 
 + } 
 } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index bccf85d . . a6b122f 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 122 , 10 + 122 , 6 @ @ message DialogRootCommands { 
 
 Peer dest = 1 ; 
 } 
 - 
 - message SendChatGroupsChanged { 
 - option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootCommand " ; 
 - } 
 } 
 
 message DialogRootQueries { 
 @ @ - 191 , 7 + 187 , 6 @ @ message DialogRootEnvelope { 
 DialogRootCommands . Favourite favourite = 7 ; 
 DialogRootCommands . Unfavourite unfavourite = 8 ; 
 DialogRootCommands . Delete delete = 9 ; 
 - DialogRootCommands . SendChatGroupsChanged send _ chat _ groups _ changed = 12 ; 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 33457e8 . . c091d83 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 181 , 11 + 181 , 6 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 . mapTo [ SeqState ] 
 } 
 
 - def sendChatGroupsChanged ( userId : Int ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? 
 - UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withSendChatGroupsChanged ( DialogRootCommands . SendChatGroupsChanged ( ) ) ) ) 
 - . mapTo [ SeqState ] 
 - 
 def setReaction ( userId : Int , authSid : Int , peer : Peer , randomId : Long , code : String ) : Future [ SetReactionAck ] = 
 withValidPeer ( peer , userId ) { 
 ( userExt . processorRegion . ref ? UserEnvelope ( userId ) . withDialogEnvelope ( DialogEnvelope ( ) . withSetReaction ( SetReaction ( 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index f11648d . . 5d4e650 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 144 , 7 + 144 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 handleDialogCommand ( dc ) 
 
 if ( ! isCreated | | ! isShown ) 
 - deliverChatGroupsChanged ( ) 
 + sendChatGroupsChanged ( ) 
 } 
 case None ⇒ 
 handleDialogCommand ( dc ) 
 @ @ - 153 , 7 + 153 , 6 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) 
 case Favourite ( Some ( peer ) , clientAuthSid ) ⇒ favourite ( peer , clientAuthSid map ( _ . value ) ) 
 case Unfavourite ( Some ( peer ) , clientAuthSid ) ⇒ unfavourite ( peer , clientAuthSid map ( _ . value ) ) 
 - case SendChatGroupsChanged ( ) ⇒ sendChatGroupsChanged ( ) 
 case dc : DialogCommand ⇒ handleDialogCommand ( dc ) 
 case dq : DialogQuery ⇒ handleDialogQuery ( dq ) 
 } 
 @ @ - 168 , 34 + 167 , 34 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 } 
 
 private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - if ( isArchived ( peer ) ) deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 + if ( isArchived ( peer ) ) sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 else persist ( Archived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 + sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 
 private def unarchive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - if ( ! isArchived ( peer ) ) deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 + if ( ! isArchived ( peer ) ) sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 else persist ( Unarchived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 + sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 
 private def favourite ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - if ( isFavourited ( peer ) ) deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 + if ( isFavourited ( peer ) ) sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 else persist ( Favourited ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 + sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 
 private def unfavourite ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - if ( ! isFavourited ( peer ) ) deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 + if ( ! isFavourited ( peer ) ) sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 else persist ( Unfavourited ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - deliverChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 + sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 
 @ @ - 214 , 8 + 213 , 6 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 } 
 } 
 
 - private def sendChatGroupsChanged ( ) = deliverChatGroupsChanged ( ) pipeTo sender ( ) 
 - 
 private def isArchived ( peer : Peer ) : Boolean = state . archived . exists ( _ . peer = = peer ) 
 
 private def isFavourited ( peer : Peer ) : Boolean = state . active . favourites . exists ( _ . peer = = peer ) 
 @ @ - 259 , 7 + 256 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 } 
 } 
 
 - private def deliverChatGroupsChanged ( ignoreAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = { 
 + private def sendChatGroupsChanged ( ignoreAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = { 
 for { 
 groups ← DialogExtension ( context . system ) . fetchApiGroupedDialogs ( userId ) 
 update = UpdateChatGroupsChanged ( groups ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 2cb6451 . . eff32f7 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 30 , 7 + 30 , 6 @ @ import org . joda . time . DateTime 
 import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . Future 
 - import scala . util . Success 
 
 private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupCommandHelpers with UserACL { 
 this : GroupProcessor ⇒ 
 @ @ - 308 , 7 + 307 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 val update = UpdateGroupTitleChanged ( groupId = groupId , userId = clientUserId , title = title , date = date . toEpochMilli , randomId = randomId ) 
 val serviceMessage = GroupServiceMessages . changedTitle ( title ) 
 
 - ( for { 
 + for { 
 _ ← db . run ( GroupRepo . updateTitle ( groupId , title , clientUserId , randomId , date ) ) 
 _ ← dialogExt . writeMessage ( 
 ApiPeer ( ApiPeerType . Group , groupId ) , 
 @ @ - 323 , 9 + 322 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 update , 
 PushRules ( ) . withData ( PushData ( ) . withText ( PushTexts . TitleChanged ) ) 
 ) 
 - } yield SeqStateDate ( seqstate . seq , seqstate . state , date . toEpochMilli ) ) andThen { 
 - case Success ( _ ) ⇒ group . members . map ( _ . _ 1 ) foreach ( dialogExt . sendChatGroupsChanged ( _ ) ) 
 - } 
 + } yield SeqStateDate ( seqstate . seq , seqstate . state , date . toEpochMilli ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index efe82d6 . . 7d8f59b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 160 , 10 + 160 , 7 @ @ private [ user ] trait UserCommandHandlers { 
 relatedUserIds ← getRelations ( userId ) 
 ( seqstate , _ ) ← seqUpdatesExt . broadcastOwnSingleUpdate ( userId , relatedUserIds , update ) 
 _ ← db . run ( UserRepo . setName ( userId , name ) ) 
 - } yield { 
 - relatedUserIds foreach ( dialogExt . sendChatGroupsChanged ( _ ) ) 
 - seqstate 
 - } 
 + } yield seqstate 
 } 
 } else { 
 replyTo ! Status . Failure ( UserErrors . InvalidName ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 index fc2ea73 . . 431c5e6 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 @ @ - 9 , 13 + 9 , 11 @ @ import akka . util . Timeout 
 import im . actor . api . rpc . users . UpdateUserLocalNameChanged 
 import im . actor . server . cqrs . { Event , Processor , ProcessorState } 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . dialog . DialogExtension 
 import im . actor . server . persist . contact . UserContactRepo 
 import im . actor . server . sequence . SeqState 
 import im . actor . server . user . UserCommands . EditLocalName 
 
 import scala . concurrent . Future 
 - import scala . util . Success 
 
 private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . empty ) extends ProcessorState [ UserContactsState ] { 
 import UserEvents . _ 
 @ @ - 44 , 14 + 42 , 11 @ @ private [ user ] final class UserContactsActor ( userId : Int ) extends Processor [ UserC 
 import UserQueries . _ 
 import UserEvents . _ 
 
 - import context . dispatcher 
 - 
 override def persistenceId : String = s " User _ $ { userId } _ Contacts " 
 
 override def getInitialState : UserContactsState = UserContactsState ( ) 
 
 private val userExt = UserExtension ( context . system ) 
 - private val dialogExt = DialogExtension ( context . system ) 
 private val db = DbExtension ( context . system ) . db 
 
 override protected def handleCommand : Receive = { 
 @ @ - 61 , 9 + 56 , 7 @ @ private [ user ] final class UserContactsActor ( userId : Int ) extends Processor [ UserC 
 
 override protected def handleQuery : QueryHandler = { 
 case GetLocalName ( _ , contactUserId ) ⇒ 
 - Future . successful ( GetLocalNameResponse ( state . localNames . get ( contactUserId ) ) ) andThen { 
 - case Success ( _ ) ⇒ dialogExt . sendChatGroupsChanged ( userId ) 
 - } 
 + Future . successful ( GetLocalNameResponse ( state . localNames . get ( contactUserId ) ) ) 
 } 
 
 private def editLocalName ( contactUserId : Int , nameOpt : Option [ String ] , supressUpdate : Boolean ) : Unit = {
