BLEU SCORE: 0.018897852222361986

TEST MSG: fix ( server : session ) : fixed resend buffer size calculation
GENERATED MSG: Merge branch ' master ' of https : / / github . com / actorapp / actor - platform

TEST DIFF (one line): diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > index bff3ef4 . . 6c2c827 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > @ @ - 54 , 19 + 54 , 20 @ @ private [ session ] object ReSender { < nl > private case class ScheduledResend ( messageId : Long , item : ResendableItem ) < nl > < nl > private sealed trait ResendableItem { < nl > - val size : Long < nl > + val bitsSize : Long < nl > + val size = bitsSize / 8 < nl > } < nl > private final case class RpcItem ( result : ApiRpcResult , requestMessageId : Long ) extends ResendableItem { < nl > lazy val body = RpcResultCodec . encode ( result ) . require < nl > - override lazy val size = body . size < nl > + override lazy val bitsSize = body . size < nl > val reduceKeyOpt = None < nl > } < nl > private final case class PushItem ( ub : UpdateBox , reduceKeyOpt : Option [ String ] ) extends ResendableItem { < nl > lazy val body = UpdateBoxCodec . encode ( ub ) . require < nl > - override lazy val size = body . size < nl > + override lazy val bitsSize = body . size < nl > } < nl > private final case class NewSessionItem ( newSession : NewSession ) extends ResendableItem { < nl > - override val size = 0L < nl > + override val bitsSize = 0L < nl > } < nl > < nl > def props ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) = < nl > @ @ - 228 , 13 + 229 , 15 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > private def increaseBufferSize ( item : ResendableItem ) : Unit = { < nl > if ( item . size < = MaxResendSize ) { < nl > this . resendBufferSize + = item . size < nl > - item match { < nl > - case p : PushItem ⇒ < nl > - this . resendPushBufferSize + = item . size < nl > - if ( this . resendPushBufferSize > config . maxPushBufferSize ) < nl > - clearPushBuffer ( ) < nl > - case _ ⇒ < nl > - } < nl > + } < nl > + < nl > + item match { < nl > + case p : PushItem ⇒ < nl > + this . resendPushBufferSize + = item . size < nl > + < nl > + if ( this . resendPushBufferSize > config . maxPushBufferSize ) < nl > + clearPushBuffer ( ) < nl > + case _ ⇒ < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > index 9f9bb60 . . 7265349 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > @ @ - 8 , 7 + 8 , 7 @ @ import im . actor . api . rpc . contacts . { RequestGetContacts , UpdateContactRegistered } < nl > import im . actor . api . rpc . messaging . RequestLoadDialogs < nl > import im . actor . api . rpc . misc . ResponseVoid < nl > import im . actor . api . rpc . peers . ApiUserOutPeer < nl > - import im . actor . api . rpc . sequence . { RequestGetDifference , RequestSubscribeToOnline , RequestGetState } < nl > + import im . actor . api . rpc . sequence . { RequestGetDifference , RequestGetState , RequestSubscribeToOnline , UpdateRawUpdate } < nl > import im . actor . api . rpc . misc . ResponseSeq < nl > import im . actor . api . rpc . weak . UpdateUserOffline < nl > import im . actor . api . rpc . { AuthorizedClientData , Request , RpcOk } < nl > @ @ - 16 , 7 + 16 , 7 @ @ import im . actor . server . api . rpc . service . auth . AuthErrors < nl > import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . mtproto . transport . _ < nl > import im . actor . server . persist . AuthSessionRepo < nl > - import im . actor . server . sequence . { SeqUpdatesExtension , WeakUpdatesExtension } < nl > + import im . actor . server . sequence . { SeqUpdatesExtension , UserSequence , WeakUpdatesExtension } < nl > import im . actor . server . user . UserExtension < nl > import scodec . bits . _ < nl > < nl > @ @ - 36 , 6 + 36 , 7 @ @ final class SessionSpec extends BaseSessionSpec { < nl > it should " subscribe to presences " in sessions ( ) . pres < nl > it should " receive fat updates " in sessions ( ) . fatSeq < nl > it should " react to SessionHello " in sessions ( ) . hello < nl > + it should " send SeqUpdateTooLong " in sessions ( ) . seqUpdateTooLong < nl > < nl > case class sessions ( ) { < nl > < nl > @ @ - 163 , 6 + 164 , 37 @ @ final class SessionSpec extends BaseSessionSpec { < nl > } < nl > } < nl > < nl > + def seqUpdateTooLong ( ) = { < nl > + val ( user , authId , _ , _ ) = createUser ( ) < nl > + val sessionId = Random . nextLong ( ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , SessionHello ) < nl > + ignoreNewSession ( ) < nl > + < nl > + sendRequest ( authId , sessionId , sessionRegion . ref , RequestGetState ( Vector . empty ) ) < nl > + expectMessageAck ( ) < nl > + expectRpcResult ( authId , sessionId ) < nl > + < nl > + val updatesCount = 31 < nl > + < nl > + / / each update is 1024 bytes < nl > + val payload = Array ( List . range ( 0 , 1005 ) . map ( _ . toByte ) : _ * ) < nl > + val update = UpdateRawUpdate ( None , payload ) < nl > + < nl > + for ( _ ← 1 to updatesCount ) { < nl > + whenReady ( seqUpdExt . deliverSingleUpdate ( user . id , update ) ) ( identity ) < nl > + } < nl > + < nl > + / / expect 30Kb of updates to be pushed , then SeqUpdateTooLong ( no ack ) < nl > + for ( _ ← 1 until updatesCount ) { < nl > + expectSeqUpdate ( authId , sessionId , None ) < nl > + } < nl > + < nl > + expectSeqUpdateTooLong ( authId , sessionId ) < nl > + expectSeqUpdate ( authId , sessionId ) < nl > + < nl > + probe . expectNoMsg ( 5 . seconds ) < nl > + } < nl > + < nl > def seq ( ) = { < nl > val authId = createAuthId ( ) < nl > val sessionId = Random . nextLong ( ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > index 0a7b511 . . a2c36b3 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > @ @ - 1 , 11 + 1 , 11 @ @ < nl > package im . actor . server . session < nl > < nl > - import akka . actor . { ActorSystem , ActorRef } < nl > + import akka . actor . { ActorRef , ActorSystem } < nl > import akka . testkit . TestProbe < nl > import com . google . protobuf . ByteString < nl > import im . actor . api . rpc . { Request , RpcRequest , RpcResult } < nl > import im . actor . api . rpc . codecs . _ < nl > - import im . actor . api . rpc . sequence . { WeakUpdate , FatSeqUpdate , SeqUpdate } < nl > + import im . actor . api . rpc . sequence . { FatSeqUpdate , SeqUpdate , SeqUpdateTooLong , WeakUpdate } < nl > import im . actor . server . api . rpc . RpcResultCodec < nl > import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec < nl > import im . actor . server . mtproto . protocol . _ < nl > @ @ - 33 , 6 + 33 , 9 @ @ trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { < nl > protected def expectWeakUpdate ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : WeakUpdate = < nl > expectUpdateBox ( classOf [ WeakUpdate ] , authId , sessionId , None ) < nl > < nl > + protected def expectSeqUpdateTooLong ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : SeqUpdateTooLong = < nl > + expectUpdateBox ( classOf [ SeqUpdateTooLong ] , authId , sessionId , sendAckAt ) < nl > + < nl > protected def expectUpdateBox [ T < : im . actor . api . rpc . UpdateBox ] ( clazz : Class [ T ] , authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] ) ( implicit probe : TestProbe , m : Manifest [ T ] ) : T = { < nl > val mb = expectMessageBox ( )
NEAREST DIFF (one line): diff - - git a / README . MD b / README . MD < nl > index 8c53a78 . . 061c271 100644 < nl > - - - a / README . MD < nl > + + + b / README . MD < nl > @ @ - 9 , 6 + 9 , 13 @ @ Actor Platform is good for improving enterprise communications , building a messa < nl > < nl > This repository contains all source code of platform whereby you can start your server or / and build your iOS , Android , Web , or Desktop applications . < nl > < nl > + # Currently available clients < nl > + * Android 4 . 0 . 3 + < nl > + * iPhone / iPad 7 . 0 + < nl > + * Web < nl > + < nl > + It is very easy to [ implement your own ] ( http : / / actor . readme . io / docs / apps ) . < nl > + < nl > # Installation < nl > < nl > Building mobile messaging application is a bit complex procedure and you need certain amount of preparations : have developer accounts in Google , Apple , have SSL certificates for your servers , integrate server with various services like SMS gate , push systems , etc . . .

TEST DIFF:
diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 index bff3ef4 . . 6c2c827 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 @ @ - 54 , 19 + 54 , 20 @ @ private [ session ] object ReSender { 
 private case class ScheduledResend ( messageId : Long , item : ResendableItem ) 
 
 private sealed trait ResendableItem { 
 - val size : Long 
 + val bitsSize : Long 
 + val size = bitsSize / 8 
 } 
 private final case class RpcItem ( result : ApiRpcResult , requestMessageId : Long ) extends ResendableItem { 
 lazy val body = RpcResultCodec . encode ( result ) . require 
 - override lazy val size = body . size 
 + override lazy val bitsSize = body . size 
 val reduceKeyOpt = None 
 } 
 private final case class PushItem ( ub : UpdateBox , reduceKeyOpt : Option [ String ] ) extends ResendableItem { 
 lazy val body = UpdateBoxCodec . encode ( ub ) . require 
 - override lazy val size = body . size 
 + override lazy val bitsSize = body . size 
 } 
 private final case class NewSessionItem ( newSession : NewSession ) extends ResendableItem { 
 - override val size = 0L 
 + override val bitsSize = 0L 
 } 
 
 def props ( authId : Long , sessionId : Long , firstMessageId : Long ) ( implicit config : ReSenderConfig ) = 
 @ @ - 228 , 13 + 229 , 15 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 private def increaseBufferSize ( item : ResendableItem ) : Unit = { 
 if ( item . size < = MaxResendSize ) { 
 this . resendBufferSize + = item . size 
 - item match { 
 - case p : PushItem ⇒ 
 - this . resendPushBufferSize + = item . size 
 - if ( this . resendPushBufferSize > config . maxPushBufferSize ) 
 - clearPushBuffer ( ) 
 - case _ ⇒ 
 - } 
 + } 
 + 
 + item match { 
 + case p : PushItem ⇒ 
 + this . resendPushBufferSize + = item . size 
 + 
 + if ( this . resendPushBufferSize > config . maxPushBufferSize ) 
 + clearPushBuffer ( ) 
 + case _ ⇒ 
 } 
 } 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 index 9f9bb60 . . 7265349 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 @ @ - 8 , 7 + 8 , 7 @ @ import im . actor . api . rpc . contacts . { RequestGetContacts , UpdateContactRegistered } 
 import im . actor . api . rpc . messaging . RequestLoadDialogs 
 import im . actor . api . rpc . misc . ResponseVoid 
 import im . actor . api . rpc . peers . ApiUserOutPeer 
 - import im . actor . api . rpc . sequence . { RequestGetDifference , RequestSubscribeToOnline , RequestGetState } 
 + import im . actor . api . rpc . sequence . { RequestGetDifference , RequestGetState , RequestSubscribeToOnline , UpdateRawUpdate } 
 import im . actor . api . rpc . misc . ResponseSeq 
 import im . actor . api . rpc . weak . UpdateUserOffline 
 import im . actor . api . rpc . { AuthorizedClientData , Request , RpcOk } 
 @ @ - 16 , 7 + 16 , 7 @ @ import im . actor . server . api . rpc . service . auth . AuthErrors 
 import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . mtproto . transport . _ 
 import im . actor . server . persist . AuthSessionRepo 
 - import im . actor . server . sequence . { SeqUpdatesExtension , WeakUpdatesExtension } 
 + import im . actor . server . sequence . { SeqUpdatesExtension , UserSequence , WeakUpdatesExtension } 
 import im . actor . server . user . UserExtension 
 import scodec . bits . _ 
 
 @ @ - 36 , 6 + 36 , 7 @ @ final class SessionSpec extends BaseSessionSpec { 
 it should " subscribe to presences " in sessions ( ) . pres 
 it should " receive fat updates " in sessions ( ) . fatSeq 
 it should " react to SessionHello " in sessions ( ) . hello 
 + it should " send SeqUpdateTooLong " in sessions ( ) . seqUpdateTooLong 
 
 case class sessions ( ) { 
 
 @ @ - 163 , 6 + 164 , 37 @ @ final class SessionSpec extends BaseSessionSpec { 
 } 
 } 
 
 + def seqUpdateTooLong ( ) = { 
 + val ( user , authId , _ , _ ) = createUser ( ) 
 + val sessionId = Random . nextLong ( ) 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , SessionHello ) 
 + ignoreNewSession ( ) 
 + 
 + sendRequest ( authId , sessionId , sessionRegion . ref , RequestGetState ( Vector . empty ) ) 
 + expectMessageAck ( ) 
 + expectRpcResult ( authId , sessionId ) 
 + 
 + val updatesCount = 31 
 + 
 + / / each update is 1024 bytes 
 + val payload = Array ( List . range ( 0 , 1005 ) . map ( _ . toByte ) : _ * ) 
 + val update = UpdateRawUpdate ( None , payload ) 
 + 
 + for ( _ ← 1 to updatesCount ) { 
 + whenReady ( seqUpdExt . deliverSingleUpdate ( user . id , update ) ) ( identity ) 
 + } 
 + 
 + / / expect 30Kb of updates to be pushed , then SeqUpdateTooLong ( no ack ) 
 + for ( _ ← 1 until updatesCount ) { 
 + expectSeqUpdate ( authId , sessionId , None ) 
 + } 
 + 
 + expectSeqUpdateTooLong ( authId , sessionId ) 
 + expectSeqUpdate ( authId , sessionId ) 
 + 
 + probe . expectNoMsg ( 5 . seconds ) 
 + } 
 + 
 def seq ( ) = { 
 val authId = createAuthId ( ) 
 val sessionId = Random . nextLong ( ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 index 0a7b511 . . a2c36b3 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 @ @ - 1 , 11 + 1 , 11 @ @ 
 package im . actor . server . session 
 
 - import akka . actor . { ActorSystem , ActorRef } 
 + import akka . actor . { ActorRef , ActorSystem } 
 import akka . testkit . TestProbe 
 import com . google . protobuf . ByteString 
 import im . actor . api . rpc . { Request , RpcRequest , RpcResult } 
 import im . actor . api . rpc . codecs . _ 
 - import im . actor . api . rpc . sequence . { WeakUpdate , FatSeqUpdate , SeqUpdate } 
 + import im . actor . api . rpc . sequence . { FatSeqUpdate , SeqUpdate , SeqUpdateTooLong , WeakUpdate } 
 import im . actor . server . api . rpc . RpcResultCodec 
 import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec 
 import im . actor . server . mtproto . protocol . _ 
 @ @ - 33 , 6 + 33 , 9 @ @ trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { 
 protected def expectWeakUpdate ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : WeakUpdate = 
 expectUpdateBox ( classOf [ WeakUpdate ] , authId , sessionId , None ) 
 
 + protected def expectSeqUpdateTooLong ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) ) ( implicit probe : TestProbe ) : SeqUpdateTooLong = 
 + expectUpdateBox ( classOf [ SeqUpdateTooLong ] , authId , sessionId , sendAckAt ) 
 + 
 protected def expectUpdateBox [ T < : im . actor . api . rpc . UpdateBox ] ( clazz : Class [ T ] , authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] ) ( implicit probe : TestProbe , m : Manifest [ T ] ) : T = { 
 val mb = expectMessageBox ( )

NEAREST DIFF:
diff - - git a / README . MD b / README . MD 
 index 8c53a78 . . 061c271 100644 
 - - - a / README . MD 
 + + + b / README . MD 
 @ @ - 9 , 6 + 9 , 13 @ @ Actor Platform is good for improving enterprise communications , building a messa 
 
 This repository contains all source code of platform whereby you can start your server or / and build your iOS , Android , Web , or Desktop applications . 
 
 + # Currently available clients 
 + * Android 4 . 0 . 3 + 
 + * iPhone / iPad 7 . 0 + 
 + * Web 
 + 
 + It is very easy to [ implement your own ] ( http : / / actor . readme . io / docs / apps ) . 
 + 
 # Installation 
 
 Building mobile messaging application is a bit complex procedure and you need certain amount of preparations : have developer accounts in Google , Apple , have SSL certificates for your servers , integrate server with various services like SMS gate , push systems , etc . . .
