BLEU SCORE: 0.02383853510228548

TEST MSG: fix ( server : messaging ) : fixed reads
GENERATED MSG: Merge commit ' 8123e8c970ae311aa02d4c9e0196dbfb802e15a6 '

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 1c70ec7 . . c9aa03f 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 165 , 7 + 165 , 9 @ @ message DialogRootQueries { < nl > message DialogStateSnapshot { < nl > int32 user _ id = 1 ; < nl > int64 last _ message _ date = 2 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + int64 last _ owner _ receive _ date = 7 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > int64 last _ receive _ date = 3 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + int64 last _ owner _ read _ date = 8 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > int64 last _ read _ date = 4 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > int32 counter = 5 ; < nl > map < int64 , int64 > unread _ messages = 6 ; < nl > @ @ - 334 , 6 + 336 , 7 @ @ message DialogEvents { < nl > option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; < nl > < nl > int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + int32 receiver _ user _ id = 2 ; < nl > } < nl > < nl > message MessagesRead { < nl > @ @ - 343 , 8 + 346 , 10 @ @ message DialogEvents { < nl > int32 reader _ user _ id = 8 ; < nl > } < nl > < nl > - message CounterReset { < nl > + message SetCounter { < nl > option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; < nl > + < nl > + int32 count = 1 ; < nl > } < nl > < nl > message Initialized { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index a2b2233 . . 13cb389 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 2 , 7 + 2 , 7 @ @ package im . actor . server . dialog < nl > < nl > import java . time . Instant < nl > < nl > - import akka . actor . { ActorRef , PoisonPill , Status } < nl > + import akka . actor . Status < nl > import akka . http . scaladsl . util . FastFuture < nl > import akka . pattern . pipe < nl > import com . google . protobuf . wrappers . Int64Value < nl > @ @ - 27 , 7 + 27 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > import DialogCommands . _ < nl > import DialogEvents . _ < nl > < nl > - protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > + protected def sendMessage ( sm : SendMessage ) : Unit = { < nl > becomeStashing ( replyTo ⇒ ( { < nl > case seq : SeqStateDate ⇒ < nl > persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ < nl > @ @ - 41 , 7 + 41 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > replyTo forward fail < nl > context . become ( receiveCommand ) < nl > unstashAll ( ) < nl > - } : Receive ) orElse reactions ( state ) , discardOld = true ) < nl > + } : Receive ) orElse reactions , discardOld = true ) < nl > < nl > withValidAccessHash ( sm . getDest , sm . senderAuthId map ( _ . value ) , sm . accessHash map ( _ . value ) ) { < nl > withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > @ @ - 65 , 7 + 65 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > } < nl > } < nl > < nl > - protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > + protected def ackSendMessage ( sm : SendMessage ) : Unit = { < nl > val messageDate = sm . date getOrElse { < nl > throw new RuntimeException ( " No message date found in SendMessage " ) < nl > } < nl > @ @ - 88 , 7 + 88 , 6 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > } < nl > < nl > protected def writeMessageSelf ( < nl > - s : DialogState , < nl > senderUserId : Int , < nl > dateMillis : Long , < nl > randomId : Long , < nl > @ @ - 105 , 7 + 104 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > } < nl > } < nl > < nl > - protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { < nl > + protected def messageReceived ( mr : MessageReceived ) : Unit = { < nl > val mustReceive = mustMakeReceive ( state , mr ) < nl > < nl > if ( mustReceive ) { < nl > @ @ - 127 , 12 + 126 , 15 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > } < nl > } < nl > < nl > - protected def messageRead ( state : DialogState , mr : MessageRead ) : Unit = { < nl > + protected def messageRead ( mr : MessageRead ) : Unit = { < nl > val mustRead = mustMakeRead ( state , mr ) < nl > + log . debug ( s " mustRead is $ { mustRead } " ) < nl > < nl > if ( mustRead ) { < nl > persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . getOrigin . id ) ) { e ⇒ < nl > + log . debug ( s " persisted MessagesRead , origin = $ { mr . getOrigin . id } , date = $ { Instant . ofEpochMilli ( mr . date ) } , counter = $ { state . counter } , unreadMessages = $ { state . unreadMessages } " ) < nl > commit ( e ) < nl > + log . debug ( s " after commit : counter = $ { state . counter } , unreadMessages = $ { state . unreadMessages } " ) < nl > < nl > ( for { < nl > _ ← dialogExt . ackMessageRead ( peer , mr ) < nl > @ @ - 149 , 13 + 151 , 14 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > require ( mr . getOrigin . typ . isPrivate ) < nl > persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . getOrigin . id ) ) { e ⇒ < nl > commit ( e ) < nl > + log . debug ( s " = = = new lastReadDate is $ { state . lastReadDate } " ) < nl > ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { < nl > case Failure ( err ) ⇒ log . error ( err , " Failed to ack MessageRead " ) < nl > } < nl > } < nl > } < nl > < nl > - protected def setReaction ( state : DialogState , sr : SetReaction ) : Unit = { < nl > + protected def setReaction ( sr : SetReaction ) : Unit = { < nl > ( for { < nl > reactions ← db . run { < nl > ReactionEventRepo . create ( DialogId ( peer , userId ) , sr . randomId , sr . code , userId ) < nl > @ @ - 179 , 7 + 182 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > } yield SetReactionAck ( ) ) pipeTo sender ( ) < nl > } < nl > < nl > - protected def removeReaction ( state : DialogState , rr : RemoveReaction ) : Unit = { < nl > + protected def removeReaction ( rr : RemoveReaction ) : Unit = { < nl > ( for { < nl > reactions ← db . run { < nl > ReactionEventRepo . delete ( DialogId ( peer , userId ) , rr . randomId , rr . code , userId ) < nl > @ @ - 232 , 7 + 235 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > * @ return ` true ` if we must process message received request and ` false ` otherwise < nl > * / < nl > private def mustMakeReceive ( state : DialogState , mr : MessageReceived ) : Boolean = < nl > - Instant . ofEpochMilli ( mr . date ) . isAfter ( state . lastReceiveDate ) & & ( mr . date < = mr . now | | state . lastMessageDate . isAfter ( Instant . ofEpochMilli ( mr . date ) ) ) < nl > + Instant . ofEpochMilli ( mr . date ) . isAfter ( state . lastOwnerReceiveDate ) & & ( mr . date < = mr . now | | state . lastMessageDate . isAfter ( Instant . ofEpochMilli ( mr . date ) ) ) < nl > < nl > / * * < nl > * < nl > @ @ - 249 , 7 + 252 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > * @ return ` true ` if we must process message received request and ` false ` otherwise < nl > * / < nl > private def mustMakeRead ( state : DialogState , mr : MessageRead ) : Boolean = < nl > - Instant . ofEpochMilli ( mr . date ) . isAfter ( state . lastReadDate ) & & ( mr . date < = mr . now | | state . lastMessageDate . isAfter ( Instant . ofEpochMilli ( mr . date ) ) ) < nl > + Instant . ofEpochMilli ( mr . date ) . isAfter ( state . lastOwnerReadDate ) & & ( mr . date < = mr . now | | state . lastMessageDate . isAfter ( Instant . ofEpochMilli ( mr . date ) ) ) < nl > < nl > / * * < nl > * check access hash and execute ` f ` , if access hash is valid < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 0874089 . . c868795 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . server . dialog < nl > < nl > import akka . actor . _ < nl > + import akka . event . Logging < nl > import akka . http . scaladsl . util . FastFuture < nl > import akka . util . Timeout < nl > import com . github . benmanes . caffeine . cache . Cache < nl > @ @ - 22 , 12 + 23 , 13 @ @ import scala . concurrent . { ExecutionContext , Future } < nl > < nl > object DialogProcessor { < nl > < nl > - def register ( ) : Unit = { < nl > + private [ dialog ] def register ( ) : Unit = { < nl > ActorSerializer . register ( < nl > 40010 → classOf [ DialogEvents . MessagesRead ] , < nl > 40011 → classOf [ DialogEvents . MessagesReceived ] , < nl > 40012 → classOf [ DialogEvents . NewMessage ] , < nl > - 40013 → classOf [ DialogEvents . CounterReset ] , < nl > + 40013 → classOf [ DialogEvents . SetCounter ] , < nl > + 40015 → classOf [ DialogEvents . Initialized ] , < nl > 40014 → classOf [ DialogStateSnapshot ] < nl > ) < nl > } < nl > @ @ - 93 , 11 + 95 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > } < nl > } < nl > < nl > - override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) < nl > + override protected def handleCommand : Receive = actions orElse reactions < nl > < nl > / / when receiving this messages , dialog reacts on other dialog ' s action < nl > - def reactions ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > + def reactions : Receive = { < nl > + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( sm ) / / User ' s message been sent < nl > case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received < nl > case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) < nl > @ @ - 105 , 13 + 107 , 13 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > } < nl > < nl > / / when receiving this messages , dialog is required to take an action < nl > - def actions ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > - case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) < nl > - case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) < nl > - case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) < nl > + def actions : Receive = { < nl > + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( sm ) / / User sends message < nl > + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( mrv ) / / User received messages < nl > + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( mrd ) / / User reads messages < nl > + case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( sr ) < nl > + case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( rr ) < nl > + case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) < nl > } < nl > < nl > / * * < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala < nl > index 2ae2495 . . d2a82d2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala < nl > @ @ - 48 , 24 + 48 , 15 @ @ trait DialogProcessorMigration extends Processor [ DialogState ] { < nl > log . warning ( " Finding messages " ) < nl > ( for { < nl > historyOwner ← HistoryUtils . getHistoryOwner ( peer , userId ) < nl > - metas ← db . run ( HistoryMessageRepo . findMetaAfter ( historyOwner , peer , d . ownerLastReadAt , Long . MaxValue ) ) < nl > - _ = log . warning ( " Found { } messages " , metas . size ) < nl > - newMessages = metas map { < nl > - case ( randomId , date , senderUserId , header ) ⇒ < nl > - NewMessage ( < nl > - randomId = randomId , < nl > - date = Instant . ofEpochMilli ( date . getMillis ) , < nl > - senderUserId = senderUserId , < nl > - messageHeader = header < nl > - ) < nl > - } < nl > + unreadCount ← db . run ( HistoryMessageRepo . getUnreadCount ( historyOwner , userId , peer , d . ownerLastReadAt ) ) < nl > + _ = log . warning ( " Found { } messages " , unreadCount ) < nl > } yield PersistEvents ( < nl > - Initialized ( ) + : < nl > - ( newMessages . toList + + < nl > - List ( < nl > - MessagesRead ( Instant . ofEpochMilli ( d . ownerLastReadAt . getMillis ) , readerUserId = userId ) , < nl > - MessagesRead ( Instant . ofEpochMilli ( d . lastReadAt . getMillis ) ) < nl > - ) ) < nl > + List ( < nl > + Initialized ( ) , < nl > + SetCounter ( unreadCount ) , < nl > + MessagesRead ( Instant . ofEpochMilli ( d . ownerLastReadAt . getMillis ) , readerUserId = userId ) , < nl > + MessagesRead ( Instant . ofEpochMilli ( d . lastReadAt . getMillis ) ) < nl > + ) < nl > ) ) pipeTo self < nl > case PersistEvents ( events ) ⇒ < nl > log . warning ( " Persisting events " ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index a8bcbd3 . . 0a39e4a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 29 , 6 + 29 , 7 @ @ object DialogRoot { < nl > 45013 → classOf [ DialogRootEvents . Shown ] , < nl > 45014 → classOf [ DialogRootEvents . Unarchived ] , < nl > 45015 → classOf [ DialogRootEvents . Unfavourited ] , < nl > + 45017 → classOf [ DialogRootEvents . Initialized ] , < nl > 45016 → classOf [ DialogRootStateSnapshot ] < nl > ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala < nl > index 10d0881 . . 90cdc4b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala < nl > @ @ - 2 , 9 + 2 , 11 @ @ package im . actor . server . dialog < nl > < nl > import java . time . Instant < nl > < nl > + import akka . event . { Logging , LoggingAdapter } < nl > import akka . persistence . SnapshotMetadata < nl > import im . actor . server . cqrs . { Event , ProcessorState , TaggedEvent } < nl > import im . actor . server . model . Peer < nl > + import org . slf4j . LoggerFactory < nl > < nl > import scala . collection . SortedSet < nl > < nl > @ @ - 34 , 7 + 36 , 9 @ @ private [ dialog ] object DialogState { < nl > def initial ( userId : Int ) = DialogState ( < nl > userId = userId , < nl > lastMessageDate = Instant . ofEpochMilli ( 0 ) , < nl > + lastOwnerReceiveDate = Instant . ofEpochMilli ( 0 ) , < nl > lastReceiveDate = Instant . ofEpochMilli ( 0 ) , < nl > + lastOwnerReadDate = Instant . ofEpochMilli ( 0 ) , < nl > lastReadDate = Instant . ofEpochMilli ( 0 ) , < nl > counter = 0 , < nl > unreadMessages = SortedSet . empty ( UnreadMessage . OrderingAsc ) , < nl > @ @ - 43 , 16 + 47 , 20 @ @ private [ dialog ] object DialogState { < nl > } < nl > < nl > private [ dialog ] final case class DialogState ( < nl > - userId : Int , < nl > - lastMessageDate : Instant , / / we don ' t use it now anywhere . should we remove it ? < nl > - lastReceiveDate : Instant , < nl > - lastReadDate : Instant , < nl > - counter : Int , < nl > - unreadMessages : SortedSet [ UnreadMessage ] , < nl > - unreadMessagesMap : Map [ Long , Long ] < nl > + userId : Int , < nl > + lastMessageDate : Instant , / / we don ' t use it now anywhere . should we remove it ? < nl > + lastOwnerReceiveDate : Instant , < nl > + lastReceiveDate : Instant , < nl > + lastOwnerReadDate : Instant , < nl > + lastReadDate : Instant , < nl > + counter : Int , < nl > + unreadMessages : SortedSet [ UnreadMessage ] , < nl > + unreadMessagesMap : Map [ Long , Long ] < nl > ) extends ProcessorState [ DialogState ] { < nl > import DialogEvents . _ < nl > < nl > + val log = LoggerFactory . getLogger ( s " $ userId / DialogRoot " ) < nl > + < nl > override def updated ( e : Event ) : DialogState = e match { < nl > case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ < nl > if ( senderUserId ! = userId ) { < nl > @ @ - 64 , 24 + 72 , 31 @ @ private [ dialog ] final case class DialogState ( < nl > ) < nl > } else this . copy ( lastMessageDate = date ) < nl > case MessagesRead ( date , readerUserId ) if readerUserId = = userId ⇒ < nl > + log . debug ( s " unreadMessages ( fromState ) $ { unreadMessages } " ) < nl > val readMessages = unreadMessages . takeWhile ( um ⇒ um . date . isBefore ( date ) | | um . date = = date ) . map ( _ . randomId ) < nl > - val newUnreadMessages = unreadMessages . dropWhile ( um ⇒ readMessages . contains ( um . randomId ) ) < nl > + log . debug ( s " readMessages $ { readMessages } " ) < nl > + log . debug ( s " readMessages date $ { unreadMessages . headOption map ( um ⇒ um . date . isBefore ( date ) | | um . date = = date ) } " ) < nl > + val newUnreadMessages = unreadMessages . drop ( readMessages . size ) < nl > val newUnreadMessagesMap = unreadMessagesMap - - readMessages < nl > < nl > this . copy ( < nl > counter = newUnreadMessages . size , < nl > unreadMessages = newUnreadMessages , < nl > - unreadMessagesMap = newUnreadMessagesMap < nl > + unreadMessagesMap = newUnreadMessagesMap , < nl > + lastOwnerReadDate = date < nl > ) < nl > case MessagesRead ( date , readerUserId ) if readerUserId ! = userId ⇒ < nl > - if ( date . isAfter ( lastReadDate ) ) < nl > + if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReadDate ) | | date = = lastReadDate ) ) < nl > this . copy ( lastReadDate = date ) < nl > else this < nl > - case MessagesReceived ( date ) ⇒ < nl > - if ( date . isAfter ( lastReceiveDate ) ) this . copy ( lastReceiveDate = date ) < nl > + case MessagesReceived ( date , receiverUserId ) if receiverUserId = = userId ⇒ < nl > + this . copy ( lastOwnerReceiveDate = date ) < nl > + case MessagesReceived ( date , receiverUserId ) if receiverUserId ! = userId ⇒ < nl > + if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReceiveDate ) | | date = = lastReceiveDate ) ) < nl > + this . copy ( lastReceiveDate = date ) < nl > else this < nl > - case CounterReset ( ) ⇒ < nl > - this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . OrderingAsc ) , unreadMessagesMap = Map . empty ) < nl > + case SetCounter ( newCounter ) ⇒ < nl > + this . copy ( counter = newCounter ) < nl > case Initialized ( ) ⇒ this < nl > } < nl > < nl > @ @ - 90 , 7 + 105 , 9 @ @ private [ dialog ] final case class DialogState ( < nl > copy ( < nl > userId = s . userId , < nl > lastMessageDate = s . lastMessageDate , < nl > + lastOwnerReceiveDate = s . lastOwnerReceiveDate , < nl > lastReceiveDate = s . lastReceiveDate , < nl > + lastOwnerReadDate = s . lastOwnerReadDate , < nl > lastReadDate = s . lastReadDate , < nl > counter = s . counter , < nl > unreadMessages = SortedSet ( < nl > @ @ - 105 , 7 + 122 , 9 @ @ private [ dialog ] final case class DialogState ( < nl > override lazy val snapshot = DialogStateSnapshot ( < nl > userId = userId , < nl > lastMessageDate = lastMessageDate , < nl > + lastOwnerReceiveDate = lastOwnerReceiveDate , < nl > lastReceiveDate = lastReceiveDate , < nl > + lastOwnerReadDate = lastOwnerReadDate , < nl > lastReadDate = lastReadDate , < nl > counter = counter , < nl > unreadMessages = unreadMessagesMap < nl > diff - - git a / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala b / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala < nl > index 3e1257a . . 46b1103 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala < nl > + + + b / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala < nl > @ @ - 5 , 7 + 5 , 7 @ @ import java . time . Instant < nl > import java . util . Base64 < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . persistence . jdbc . serialization . SerializationFacade < nl > + import akka . persistence . jdbc . serialization . { SerializationFacade , Serialized } < nl > import akka . persistence . journal . Tagged < nl > import akka . persistence . { AtomicWrite , PersistentRepr } < nl > import akka . serialization . { Serialization , SerializationExtension } < nl > @ @ - 18 , 7 + 18 , 7 @ @ import im . actor . server . group . { GroupEvent , GroupProcessor } < nl > import im . actor . server . user . { UserEvent , UserProcessor } < nl > import org . flywaydb . core . api . migration . jdbc . JdbcMigration < nl > import org . joda . time . DateTime < nl > - import shardakka . keyvalue . { ValueEvents , ValueQueries , ValueCommands , RootEvents } < nl > + import shardakka . keyvalue . { RootEvents , ValueCommands , ValueEvents , ValueQueries } < nl > < nl > import scala . concurrent . _ < nl > import scala . concurrent . duration . Duration < nl > @ @ - 86 , 7 + 86 , 7 @ @ final class V20160128142000 _ _ AkkaPersistence extends JdbcMigration { < nl > val flowResult = < nl > Source ( events ) < nl > . map ( p ⇒ AtomicWrite ( p . _ 1 ) ) < nl > - . via ( SerializationFacade ( system , " , " ) . serialize ) < nl > + . via ( SerializationFacade ( system , " , " ) . serialize ( serialize = true ) ) < nl > . map ( _ . get ) < nl > . map { iter ⇒ < nl > val ps = connection . prepareStatement ( sql ) < nl > @ @ - 98 , 7 + 98 , 7 @ @ final class V20160128142000 _ _ AkkaPersistence extends JdbcMigration { < nl > ps . setLong ( 2 , ser . sequenceNr ) < nl > ps . setLong ( 3 , ser . created ) < nl > ps . setString ( 4 , ser . tags . orNull ) < nl > - ps . setBytes ( 5 , ser . serialized ) < nl > + ps . setBytes ( 5 , ser . asInstanceOf [ Serialized ] . serialized ) < nl > ps . addBatch ( ) < nl > } < nl > ps . execute ( ) < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > index 74af68c . . 26107e1 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > @ @ - 219 , 6 + 219 , 13 @ @ object HistoryMessageRepo { < nl > . exists < nl > . result < nl > < nl > + def getUnreadCount ( historyOwner : Int , clientUserId : Int , peer : Peer , lastReadAt : DateTime , noServiceMessages : Boolean = false ) : FixedSqlAction [ Int , PostgresDriver . api . NoStream , Read ] = < nl > + ( if ( noServiceMessages ) withoutServiceMessages else notDeletedMessages ) < nl > + . filter ( m ⇒ m . userId = = = historyOwner & & m . peerType = = = peer . typ . value & & m . peerId = = = peer . id ) < nl > + . filter ( m ⇒ m . date > lastReadAt & & m . senderUserId = ! = clientUserId ) < nl > + . length < nl > + . result < nl > + < nl > def deleteAll ( userId : Int , peer : Peer ) : FixedSqlAction [ Int , NoStream , Write ] = < nl > notDeletedMessages < nl > . filter ( m ⇒ m . userId = = = userId & & m . peerType = = = peer . typ . value & & m . peerId = = = peer . id ) < nl > diff - - git a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala < nl > index f355b8a . . 1e6a484 100644 < nl > - - - a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala < nl > + + + b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala < nl > @ @ - 91 , 7 + 91 , 6 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( < nl > CommonSerialization . register ( ) < nl > UserProcessor . register ( ) < nl > GroupProcessor . register ( ) < nl > - DialogProcessor . register ( ) < nl > StickerMessages . register ( ) < nl > < nl > val serverConfig = ActorConfig . load ( defaultConfig ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > index dfba5fe . . 4bbacdf 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > @ @ - 2 , 7 + 2 , 6 @ @ package im . actor . server . dialog < nl > < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > - import im . actor . api . rpc . sequence . { ApiUpdateContainer , ResponseGetDifference } < nl > import im . actor . api . rpc . { AuthData , ClientData , Ok , PeersImplicits } < nl > import im . actor . server . _ < nl > import im . actor . server . acl . ACLUtils < nl > @ @ - 20 , 12 + 19 , 43 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > < nl > behavior of " Dialog Processor " < nl > < nl > + it should " pass reads after read with later date came from another user " in passReads ( ) < nl > + < nl > it should " not allow time out when there are highly frequent messages " in noTimeout ( ) < nl > < nl > it should " not allow duplicated timestamp in messages " in uniqueTimestamp ( ) < nl > < nl > private val messService = MessagingServiceImpl ( ) < nl > < nl > + def passReads ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + < nl > + val alicePeer = ApiPeer ( ApiPeerType . Private , alice . id ) < nl > + val bobPeer = ApiPeer ( ApiPeerType . Private , bob . id ) < nl > + < nl > + def sendMessageToBob ( text : String ) : Future [ SeqStateDate ] = < nl > + dialogExt . sendMessage ( bobPeer , alice . id , aliceAuthSid , Some ( aliceAuthId ) , ACLUtils . randomLong ( ) , textMessage ( text ) ) < nl > + < nl > + def sendMessageToAlice ( text : String ) : Future [ SeqStateDate ] = < nl > + dialogExt . sendMessage ( alicePeer , bob . id , bobAuthSid , Some ( bobAuthId ) , ACLUtils . randomLong ( ) , textMessage ( text ) ) < nl > + < nl > + val dateToAlice = whenReady ( sendMessageToAlice ( " Hi " ) ) ( _ . date ) < nl > + val dateToBob = whenReady ( sendMessageToBob ( " Hi " ) ) ( _ . date ) < nl > + < nl > + whenReady ( dialogExt . messageRead ( alicePeer , bob . id , 0 , dateToBob ) ) ( identity ) < nl > + whenReady ( dialogExt . getDialogInfo ( alice . id , bobPeer . asModel ) ) { info ⇒ < nl > + info . counter should be ( 1 ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + whenReady ( dialogExt . messageRead ( bobPeer , alice . id , 0 , dateToAlice ) ) ( identity ) < nl > + whenReady ( dialogExt . getDialogInfo ( alice . id , bobPeer . asModel ) ) { info ⇒ < nl > + info . counter should be ( 0 ) < nl > + } < nl > + } < nl > + < nl > def noTimeout ( ) = { < nl > val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > @ @ - 42 , 8 + 72 , 12 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > val toAlice = for ( i ← 1 to 50 ) yield sendMessageToAlice ( s " Hello $ i " ) < nl > val toBob = for ( i ← 1 to 50 ) yield sendMessageToBob ( s " Hello you back $ i " ) < nl > < nl > - toAlice foreach { whenReady ( _ ) ( identity ) } < nl > - toBob foreach { whenReady ( _ ) ( identity ) } < nl > + toAlice foreach { < nl > + whenReady ( _ ) ( identity ) < nl > + } < nl > + toBob foreach { < nl > + whenReady ( _ ) ( identity ) < nl > + } < nl > < nl > { < nl > implicit val clientData = ClientData ( bobAuthId , 2 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > @ @ - 84 , 8 + 118 , 12 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > val toAlice = for ( i ← 1 to 50 ) yield sendMessageToAlice ( s " Hello $ i " ) < nl > val toBob = for ( i ← 1 to 50 ) yield sendMessageToBob ( s " Hello you back $ i " ) < nl > < nl > - toAlice foreach { whenReady ( _ ) ( identity ) } < nl > - toBob foreach { whenReady ( _ ) ( identity ) } < nl > + toAlice foreach { < nl > + whenReady ( _ ) ( identity ) < nl > + } < nl > + toBob foreach { < nl > + whenReady ( _ ) ( identity ) < nl > + } < nl > < nl > { < nl > implicit val clientData = ClientData ( bobAuthId , 2 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorStateSpec . scala < nl > deleted file mode 100644 < nl > index fbd81e6 . . 0000000 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorStateSpec . scala < nl > + + + / dev / null < nl > @ @ - 1 , 55 + 0 , 0 @ @ < nl > - package im . actor . server . dialog < nl > - < nl > - import java . time . Instant < nl > - < nl > - import akka . persistence . SnapshotMetadata < nl > - import im . actor . api . rpc . PeersImplicits < nl > - import im . actor . server . ActorSuite < nl > - import im . actor . server . cqrs . ProcessorStateProbe < nl > - import im . actor . server . model . Peer < nl > - < nl > - import scala . util . Random < nl > - < nl > - final class DialogProcessorStateSpec extends ActorSuite with PeersImplicits { < nl > - it should " increase counter on NewMessage and decrease on Read " in counter < nl > - < nl > - import im . actor . server . dialog . DialogEvents . _ < nl > - < nl > - def counter ( ) = { < nl > - val userId = 1 < nl > - implicit val probe = ProcessorStateProbe ( DialogState . initial ( 1 ) ) < nl > - < nl > - val alice = Peer . privat ( 2 ) < nl > - < nl > - val date1 = Instant . now ( ) < nl > - probe . commit ( NewMessage ( Random . nextLong ( ) , date1 , alice . id ) ) < nl > - probe . state . counter should be ( 1 ) < nl > - < nl > - val date2 = date1 . plusMillis ( 1 ) < nl > - probe . commit ( NewMessage ( Random . nextLong ( ) , date2 , alice . id ) ) < nl > - probe . commit ( NewMessage ( Random . nextLong ( ) , date2 , userId ) ) < nl > - probe . state . counter should be ( 2 ) < nl > - < nl > - checkSnapshot ( userId ) < nl > - < nl > - probe . commit ( MessagesRead ( date1 , alice . id ) ) < nl > - probe . state . counter should be ( 2 ) < nl > - < nl > - probe . commit ( MessagesRead ( date1 , userId ) ) < nl > - probe . state . counter should be ( 1 ) < nl > - < nl > - probe . commit ( NewMessage ( Random . nextLong ( ) , Instant . now ( ) , alice . id ) ) < nl > - probe . commit ( NewMessage ( Random . nextLong ( ) , Instant . now ( ) . plusMillis ( 1 ) , alice . id ) ) < nl > - val lastDate = Instant . now ( ) . plusMillis ( 2 ) < nl > - probe . commit ( NewMessage ( Random . nextLong ( ) , lastDate , alice . id ) ) < nl > - probe . state . counter should be ( 4 ) < nl > - < nl > - probe . commit ( MessagesRead ( lastDate , userId ) ) < nl > - probe . state . counter should be ( 0 ) < nl > - < nl > - checkSnapshot ( userId ) < nl > - } < nl > - < nl > - private def checkSnapshot ( userId : Int ) ( implicit probe : ProcessorStateProbe [ DialogState ] ) = < nl > - DialogState . initial ( userId ) . withSnapshot ( SnapshotMetadata ( " " , 0 ) , probe . state . snapshot ) should be ( probe . state ) < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogStateSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 9e8efc2 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogStateSpec . scala < nl > @ @ - 0 , 0 + 1 , 75 @ @ < nl > + package im . actor . server . dialog < nl > + < nl > + import java . time . Instant < nl > + < nl > + import akka . persistence . SnapshotMetadata < nl > + import im . actor . api . rpc . PeersImplicits < nl > + import im . actor . server . ActorSuite < nl > + import im . actor . server . cqrs . ProcessorStateProbe < nl > + import im . actor . server . model . Peer < nl > + < nl > + import scala . util . Random < nl > + < nl > + final class DialogStateSpec extends ActorSuite with PeersImplicits { < nl > + it should " increase counter on NewMessage and decrease on Read " in counter < nl > + < nl > + it should " recalculate counter on read " in recalculate < nl > + < nl > + import im . actor . server . dialog . DialogEvents . _ < nl > + < nl > + def counter ( ) = { < nl > + val userId = 1 < nl > + implicit val probe = ProcessorStateProbe ( DialogState . initial ( 1 ) ) < nl > + < nl > + val alice = Peer . privat ( 2 ) < nl > + < nl > + val date1 = Instant . now ( ) < nl > + probe . commit ( NewMessage ( Random . nextLong ( ) , date1 , alice . id ) ) < nl > + probe . state . counter should be ( 1 ) < nl > + < nl > + val date2 = date1 . plusMillis ( 1 ) < nl > + probe . commit ( NewMessage ( Random . nextLong ( ) , date2 , alice . id ) ) < nl > + probe . commit ( NewMessage ( Random . nextLong ( ) , date2 , userId ) ) < nl > + probe . state . counter should be ( 2 ) < nl > + < nl > + checkSnapshot ( userId ) < nl > + < nl > + probe . commit ( MessagesRead ( date1 , alice . id ) ) < nl > + probe . state . counter should be ( 2 ) < nl > + < nl > + probe . commit ( MessagesRead ( date1 , userId ) ) < nl > + probe . state . counter should be ( 1 ) < nl > + < nl > + probe . commit ( NewMessage ( Random . nextLong ( ) , Instant . now ( ) , alice . id ) ) < nl > + probe . commit ( NewMessage ( Random . nextLong ( ) , Instant . now ( ) . plusMillis ( 1 ) , alice . id ) ) < nl > + val lastDate = Instant . now ( ) . plusMillis ( 2 ) < nl > + probe . commit ( NewMessage ( Random . nextLong ( ) , lastDate , alice . id ) ) < nl > + probe . state . counter should be ( 4 ) < nl > + < nl > + probe . commit ( MessagesRead ( lastDate , userId ) ) < nl > + probe . state . counter should be ( 0 ) < nl > + < nl > + checkSnapshot ( userId ) < nl > + } < nl > + < nl > + def recalculate ( ) = { < nl > + val userId = 1 < nl > + implicit val probe = ProcessorStateProbe ( DialogState . initial ( 1 ) ) < nl > + < nl > + val alice = Peer . privat ( 2 ) < nl > + < nl > + probe . commit ( SetCounter ( 10 ) ) < nl > + < nl > + val date1 = Instant . now ( ) < nl > + probe . commit ( NewMessage ( Random . nextLong ( ) , date1 , alice . id ) ) < nl > + probe . state . counter should be ( 11 ) < nl > + checkSnapshot ( userId ) < nl > + < nl > + probe . commit ( MessagesRead ( date1 , userId ) ) < nl > + probe . state . counter should be ( 0 ) < nl > + checkSnapshot ( userId ) < nl > + } < nl > + < nl > + private def checkSnapshot ( userId : Int ) ( implicit probe : ProcessorStateProbe [ DialogState ] ) = < nl > + DialogState . initial ( userId ) . withSnapshot ( SnapshotMetadata ( " " , 0 ) , probe . state . snapshot ) should be ( probe . state ) < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index d43da37 . . 54e554a 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 6 , 7 + 6 , 7 @ @ object Dependencies { < nl > object V { < nl > val actorCommons = " 0 . 0 . 15 " < nl > val actorBotkit = " 1 . 0 . 88 " < nl > - val akka = " 2 . 4 . 2 " < nl > + val akka = " 2 . 4 . 4 " < nl > val akkaHttpJson = " 1 . 5 . 0 " < nl > val cats = " 0 . 3 . 0 " < nl > val circe = " 0 . 2 . 1 " < nl > @ @ - 41 , 7 + 41 , 7 @ @ object Dependencies { < nl > val sprayClient = " io . spray " % % " spray - client " % " 1 . 3 . 3 " < nl > val sprayWebsocket = " com . wandoulabs . akka " % % " spray - websocket " % " 0 . 1 . 4 " < nl > < nl > - val akkaPersistenceJdbc = " com . github . dnvriend " % % " akka - persistence - jdbc " % " 2 . 2 . 8 " < nl > + val akkaPersistenceJdbc = " com . github . dnvriend " % % " akka - persistence - jdbc " % " 2 . 2 . 18 " < nl > val apacheEmail = " org . apache . commons " % " commons - email " % " 1 . 4 " < nl > < nl > val betterFiles = " com . github . pathikrit " % % " better - files " % " 2 . 13 . 0 "
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > index 641806f . . 71c4080 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > @ @ - 43 , 7 + 43 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > ) < nl > < nl > for { < nl > - senderName ← userExt . getName ( receiverUserId , senderUserId ) < nl > + senderName ← userExt . getName ( senderUserId , receiverUserId ) < nl > pushText ← getPushText ( peer , receiverUserId , senderName , message ) < nl > _ ← seqUpdatesExt . deliverSingleUpdate ( < nl > receiverUserId , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > index 4181a2e . . 3230c26 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . cache . CacheHelpers . _ < nl > + import org . joda . time . DateTime < nl > import slick . dbio . DBIO < nl > < nl > import slick . driver . PostgresDriver . api . Database < nl > @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > dialog ← optDialog match { < nl > case Some ( dialog ) ⇒ DBIO . successful ( dialog ) < nl > case None ⇒ < nl > - val dialog = DialogModel ( userId , peer ) < nl > + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > for { < nl > _ ← DialogRepo . create ( dialog ) < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index b45cc33 . . d2c2ddb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > throw e < nl > } ) pipeTo sender ( ) < nl > sendFuture onSuccess { < nl > - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) < nl > + case SeqStateDate ( _ , _ , date ) ⇒ < nl > + self ! LastOwnMessageDate ( date ) < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > } < nl > } < nl > < nl > @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > deliveryExt < nl > . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > . map ( _ ⇒ SendMessageAck ( ) ) < nl > - . pipeTo ( sender ( ) ) < nl > - < nl > - if ( state . isHidden ) < nl > - self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + . pipeTo ( sender ( ) ) onSuccess { < nl > + case _ ⇒ < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } < nl > < nl > / / onSuccess ( fu ) { _ = > < nl > / / updatePeerMessageDate ( ) < nl > @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > if ( state . isHidden ) < nl > sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) < nl > else { < nl > + < nl > val future = < nl > ( for { < nl > _ ← db . run ( DialogRepo . hide ( userId , peer ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 55230de . . 01a8d62 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > + sealed trait DialogGroup { < nl > + def key : String < nl > + def title : String < nl > + } < nl > + < nl > + object DialogGroups { < nl > + object Privates extends DialogGroup { < nl > + override def key : String = " privates " < nl > + < nl > + override def title : String = " Private " < nl > + } < nl > + < nl > + object Groups extends DialogGroup { < nl > + override def key : String = " groups " < nl > + < nl > + override def title : String = " Groups " < nl > + } < nl > + } < nl > + < nl > sealed trait DialogExtension extends Extension < nl > < nl > final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { < nl > @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > < nl > private val log = Logging ( system , getClass ) < nl > < nl > - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > peer match { < nl > - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ < nl > + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ < nl > log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) < nl > failed < nl > case _ ⇒ f < nl > } < nl > < nl > def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > val date = Instant . now ( ) . toEpochMilli < nl > val sender = Peer . privat ( senderUserId ) < nl > val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) < nl > @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > randomId : Long , < nl > message : ApiMessage < nl > ) : Future [ Unit ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { < nl > val sender = Peer . privat ( senderUserId ) < nl > val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) < nl > ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) < nl > } < nl > < nl > def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val receiver = Peer . privat ( receiverUserId ) < nl > val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) < nl > @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > < nl > def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val reader = Peer . privat ( readerUserId ) < nl > val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) < nl > @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > < nl > def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def isSharedUser ( userId : Int ) : Boolean = userId = = 0 < nl > < nl > def getGroupedDialogs ( userId : Int ) = { < nl > - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { < nl > case ( ( groupModels , privateModels ) , dialog ) ⇒ < nl > if ( dialog . peer . typ = = PeerType . Group ) < nl > @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) < nl > privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) < nl > } yield Vector ( < nl > - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , < nl > - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) < nl > + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , < nl > + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) < nl > ) < nl > } ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index 4219e8c . . d3a6b75 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { < nl > for { < nl > _ ← persist . HistoryMessageRepo . create ( messages ) < nl > _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) < nl > - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > } yield ( ) < nl > } else if ( toPeer . typ = = PeerType . Group ) { < nl > DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > index 9475e63 . . 912092d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > @ @ - 15 , 27 + 15 , 19 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int , applePushManager : A < nl > private val db = DbExtension ( system ) . db < nl > < nl > def deliverInvisible ( seq : Int , creds : ApplePushCredentials ) : Unit = { < nl > - < < < < < < < Updated upstream < nl > - applePushManager . getInstance ( creds . apnsKey ) match { < nl > - case Some ( mgr ) ⇒ < nl > - db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ < nl > - val builder = < nl > - new ApnsPayloadBuilder ( ) < nl > - . addCustomProperty ( " seq " , seq ) < nl > - . setContentAvailable ( true ) < nl > - = = = = = = = < nl > withMgr ( creds . apnsKey ) { mgr ⇒ < nl > log . debug ( " Delivering invisible ( seq : { } ) to apnsKey : { } " , seq , creds . apnsKey ) < nl > - > > > > > > > Stashed changes < nl > - < nl > + db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ < nl > + val builder = < nl > + new ApnsPayloadBuilder ( ) < nl > + . addCustomProperty ( " seq " , seq ) < nl > + . setContentAvailable ( true ) < nl > builder . setBadgeNumber ( unreadTotal ) < nl > < nl > val payload = builder . buildWithDefaultMaximumLength ( ) < nl > < nl > mgr . getQueue . add ( new SimpleApnsPushNotification ( creds . token . toByteArray , payload ) ) < nl > } < nl > - case None ⇒ < nl > - log . warning ( " No apple push configured for apns - key : { } " , creds . apnsKey ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > index 191aa44 . . a59b5b2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { < nl > def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { < nl > phones . headOption match { < nl > case Some ( phone ) ⇒ Some ( phone . number ) < nl > - case None ⇒ Some ( 0L ) < nl > + case None ⇒ Some ( 0L ) < nl > } < nl > } < nl > < nl > def normalizeLocalName ( name : Option [ String ] ) = name match { < nl > - case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > - case _ ⇒ None < nl > + case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > + case _ ⇒ None < nl > } < nl > < nl > def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > index 9bf22b0 . . d215e44 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . api . http . bots < nl > import java . util . Base64 < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . http . scaladsl . model . StatusCode < nl > import akka . http . scaladsl . model . StatusCodes . _ < nl > import akka . http . scaladsl . model . ws . { Message , TextMessage } < nl > + import akka . http . scaladsl . model . { HttpMethod , StatusCode } < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . Route < nl > import akka . stream . Materializer < nl > @ @ - 14 , 20 + 14 , 16 @ @ import akka . util . ByteString < nl > import cats . data . OptionT < nl > import cats . std . future . _ < nl > import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport < nl > - import im . actor . api . rpc . messaging . ApiJsonMessage < nl > - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . api . rpc . sequence . UpdateRawUpdate < nl > import im . actor . server . api . http . RoutesHandler < nl > import im . actor . server . api . http . json . { ContentUnmarshaller , JsValueUnmarshaller , JsonFormatters , Status } < nl > import im . actor . server . bot . { BotExtension , BotServerBlueprint } < nl > - import im . actor . server . dialog . DialogExtension < nl > import im . actor . server . model . AuthSession < nl > import im . actor . server . user . UserExtension < nl > import play . api . libs . json . _ < nl > import upickle . default . _ < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . util . control . NoStackTrace < nl > import scala . util . { Failure , Success } < nl > < nl > @ @ - 42 , 25 + 38 , 42 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > < nl > override def routes : Route = < nl > path ( " bots " / " hooks " / Segment ) { token ⇒ < nl > - post { < nl > - extractRequest { request ⇒ < nl > - val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) < nl > + extractRequest { request ⇒ < nl > + val method = request . method < nl > + val queryString = request . uri . queryString ( ) < nl > + val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) < nl > < nl > - val sendMessageF = for { < nl > - data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) < nl > - res ← sendMessage ( headers , data , token ) < nl > - } yield res < nl > + val sendMessageF = for { < nl > + data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) < nl > + res ← sendMessage ( method , queryString , headers , data , token ) < nl > + } yield res < nl > < nl > - onComplete ( sendMessageF ) { < nl > - case Success ( result ) ⇒ < nl > - result match { < nl > - case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) < nl > - case Right ( _ ) ⇒ complete ( OK → Status ( " ok " ) ) < nl > - } < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to handle bot hook " ) < nl > - complete ( InternalServerError ) < nl > - } < nl > + onComplete ( sendMessageF ) { < nl > + case Success ( result ) ⇒ < nl > + result match { < nl > + case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) < nl > + case Right ( _ ) ⇒ < nl > + val response = < nl > + " " " < nl > + | < html > < nl > + | < head > < nl > + | < title > Please , return to the app < / title > < nl > + | < style > < nl > + | . element { < nl > + | position : relative ; < nl > + | top : 50 % ; < nl > + | transform : translateY ( - 50 % ) ; < nl > + | } < nl > + | < / style > < nl > + | < / head > < nl > + | < body > < center id = " message " > < h3 > Please , return to the app . < / h1 > < / center > < / body > < nl > + | < / html > < nl > + " " " . stripMargin < nl > + complete ( OK → Status ( response ) ) < nl > + } < nl > + case Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to handle bot hook " ) < nl > + complete ( InternalServerError ) < nl > } < nl > } < nl > } ~ path ( " bots " / Segment ) { token ⇒ < nl > @ @ - 84 , 7 + 97 , 7 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > } < nl > } < nl > < nl > - private def sendMessage ( headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { < nl > + private def sendMessage ( method : HttpMethod , queryString : Option [ String ] , headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { < nl > ( for { < nl > hook ← OptionT ( botExt . findWebHook ( token ) ) < nl > _ ← OptionT . pure ( userExt . broadcastUserUpdate ( < nl > @ @ - 95 , 6 + 108 , 8 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > " dataType " → JsString ( " HookData " ) , < nl > " data " → JsObject ( Map ( < nl > " name " → JsString ( hook . name ) , < nl > + " method " → JsString ( method . name ) , < nl > + " queryString " → ( queryString map JsString getOrElse JsNull ) , < nl > " headers " → JsObject ( headers map { case ( name , value ) ⇒ name → JsString ( value ) } ) , < nl > " body " → JsString ( Base64 . getEncoder . encodeToString ( data . toArray ) ) < nl > ) ) < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > index f7b0742 . . f9c82b0 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { < nl > def findLastReadBefore ( date : DateTime , userId : Int ) = < nl > dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result < nl > < nl > - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) < nl > + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > < nl > def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > index 14c35dd . . 66d4ebf 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { < nl > | " com . trueaccord . scalapb . GeneratedMessage " = actor < nl > | } < nl > | } < nl > + | < nl > + | cluster . sharding . state - store - mode = " ddata " < nl > | } < nl > " " " . stripMargin < nl > ) ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > index 3d25a02 . . 72dc6c1 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > @ @ - 1 , 27 + 1 , 52 @ @ < nl > package im . actor . server < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . util . Timeout < nl > import im . actor . api . rpc . ClientData < nl > - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } < nl > + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . api . rpc . users . ApiUser < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . dialog . DialogGroup < nl > + import org . scalatest . concurrent . ScalaFutures < nl > < nl > - import scala . concurrent . Await < nl > + import scala . language . postfixOps < nl > import scala . util . Random < nl > < nl > - trait MessagingSpecHelpers { < nl > - val timeout : Timeout < nl > + trait MessagingSpecHelpers extends ScalaFutures { < nl > + implicit val system : ActorSystem < nl > < nl > def sendMessageToUser ( userId : Int , message : ApiMessage ) ( < nl > implicit < nl > clientData : ClientData , < nl > - msgService : MessagingService , < nl > - system : ActorSystem < nl > + msgService : MessagingService < nl > ) : Unit = { < nl > - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) < nl > - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) < nl > + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ < nl > + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) < nl > + } < nl > } < nl > < nl > def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) < nl > + < nl > + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { < nl > + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ < nl > + resp . toOption . get . dialogs map { < nl > + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs < nl > + } toMap < nl > + } < nl > + } < nl > + < nl > + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { < nl > + val dgs = getDialogGroups ( ) < nl > + dgs get group . key match { < nl > + case Some ( ds ) ⇒ ds < nl > + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) < nl > + } < nl > + } < nl > + < nl > + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { < nl > + users foreach { user ⇒ < nl > + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) < nl > + Thread . sleep ( 1 ) < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > index 85ba87d . . fe02129 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } < nl > - import org . scalatest . Inside . _ < nl > + import im . actor . server . _ < nl > + import im . actor . server . dialog . DialogGroups < nl > < nl > import scala . concurrent . { Await , Future } < nl > import scala . concurrent . duration . _ < nl > @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec < nl > extends BaseAppSuite < nl > with ImplicitAuthService < nl > with ImplicitSessionRegion < nl > - with GroupsServiceHelpers { < nl > + with GroupsServiceHelpers < nl > + with MessagingSpecHelpers { < nl > " LoadGroupedDialogs " should " load groups and privates " in loadGrouped < nl > < nl > - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > - private val service = MessagingServiceImpl ( ) < nl > + " Dialogs " should " appear in top on new incoming message " in incomingGoTop < nl > + it should " appear in top on new outgoing message " in outgoingGoTop < nl > + < nl > + " Hidden dialogs " should " appear on new message " in appearHidden < nl > + it should " appear on show " in appearShown < nl > + < nl > + import DialogGroups . _ < nl > + < nl > + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > + private implicit lazy val service = MessagingServiceImpl ( ) < nl > < nl > def loadGrouped ( ) = { < nl > val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) < nl > @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec < nl > } < nl > } < nl > } < nl > + < nl > + def incomingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) < nl > + < nl > + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = bobClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val dgs = getDialogGroups ( ) < nl > + val privates = dgs ( Privates . key ) < nl > + privates . size should equal ( 2 ) < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + privates . last . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val privates = getDialogGroups ( Privates ) < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + } < nl > + < nl > + def outgoingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + val ( eve , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + < nl > + prepareDialogs ( bob , eve ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + } < nl > + } < nl > + < nl > + def appearHidden ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > + < nl > + def appearShown ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 1c70ec7 . . c9aa03f 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 165 , 7 + 165 , 9 @ @ message DialogRootQueries { 
 message DialogStateSnapshot { 
 int32 user _ id = 1 ; 
 int64 last _ message _ date = 2 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + int64 last _ owner _ receive _ date = 7 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 int64 last _ receive _ date = 3 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + int64 last _ owner _ read _ date = 8 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 int64 last _ read _ date = 4 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 int32 counter = 5 ; 
 map < int64 , int64 > unread _ messages = 6 ; 
 @ @ - 334 , 6 + 336 , 7 @ @ message DialogEvents { 
 option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; 
 
 int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + int32 receiver _ user _ id = 2 ; 
 } 
 
 message MessagesRead { 
 @ @ - 343 , 8 + 346 , 10 @ @ message DialogEvents { 
 int32 reader _ user _ id = 8 ; 
 } 
 
 - message CounterReset { 
 + message SetCounter { 
 option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; 
 + 
 + int32 count = 1 ; 
 } 
 
 message Initialized { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index a2b2233 . . 13cb389 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 2 , 7 + 2 , 7 @ @ package im . actor . server . dialog 
 
 import java . time . Instant 
 
 - import akka . actor . { ActorRef , PoisonPill , Status } 
 + import akka . actor . Status 
 import akka . http . scaladsl . util . FastFuture 
 import akka . pattern . pipe 
 import com . google . protobuf . wrappers . Int64Value 
 @ @ - 27 , 7 + 27 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 import DialogCommands . _ 
 import DialogEvents . _ 
 
 - protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 + protected def sendMessage ( sm : SendMessage ) : Unit = { 
 becomeStashing ( replyTo ⇒ ( { 
 case seq : SeqStateDate ⇒ 
 persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ 
 @ @ - 41 , 7 + 41 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 replyTo forward fail 
 context . become ( receiveCommand ) 
 unstashAll ( ) 
 - } : Receive ) orElse reactions ( state ) , discardOld = true ) 
 + } : Receive ) orElse reactions , discardOld = true ) 
 
 withValidAccessHash ( sm . getDest , sm . senderAuthId map ( _ . value ) , sm . accessHash map ( _ . value ) ) { 
 withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 @ @ - 65 , 7 + 65 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 } 
 } 
 
 - protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 + protected def ackSendMessage ( sm : SendMessage ) : Unit = { 
 val messageDate = sm . date getOrElse { 
 throw new RuntimeException ( " No message date found in SendMessage " ) 
 } 
 @ @ - 88 , 7 + 88 , 6 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 } 
 
 protected def writeMessageSelf ( 
 - s : DialogState , 
 senderUserId : Int , 
 dateMillis : Long , 
 randomId : Long , 
 @ @ - 105 , 7 + 104 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 } 
 } 
 
 - protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { 
 + protected def messageReceived ( mr : MessageReceived ) : Unit = { 
 val mustReceive = mustMakeReceive ( state , mr ) 
 
 if ( mustReceive ) { 
 @ @ - 127 , 12 + 126 , 15 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 } 
 } 
 
 - protected def messageRead ( state : DialogState , mr : MessageRead ) : Unit = { 
 + protected def messageRead ( mr : MessageRead ) : Unit = { 
 val mustRead = mustMakeRead ( state , mr ) 
 + log . debug ( s " mustRead is $ { mustRead } " ) 
 
 if ( mustRead ) { 
 persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . getOrigin . id ) ) { e ⇒ 
 + log . debug ( s " persisted MessagesRead , origin = $ { mr . getOrigin . id } , date = $ { Instant . ofEpochMilli ( mr . date ) } , counter = $ { state . counter } , unreadMessages = $ { state . unreadMessages } " ) 
 commit ( e ) 
 + log . debug ( s " after commit : counter = $ { state . counter } , unreadMessages = $ { state . unreadMessages } " ) 
 
 ( for { 
 _ ← dialogExt . ackMessageRead ( peer , mr ) 
 @ @ - 149 , 13 + 151 , 14 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 require ( mr . getOrigin . typ . isPrivate ) 
 persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . getOrigin . id ) ) { e ⇒ 
 commit ( e ) 
 + log . debug ( s " = = = new lastReadDate is $ { state . lastReadDate } " ) 
 ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { 
 case Failure ( err ) ⇒ log . error ( err , " Failed to ack MessageRead " ) 
 } 
 } 
 } 
 
 - protected def setReaction ( state : DialogState , sr : SetReaction ) : Unit = { 
 + protected def setReaction ( sr : SetReaction ) : Unit = { 
 ( for { 
 reactions ← db . run { 
 ReactionEventRepo . create ( DialogId ( peer , userId ) , sr . randomId , sr . code , userId ) 
 @ @ - 179 , 7 + 182 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 } yield SetReactionAck ( ) ) pipeTo sender ( ) 
 } 
 
 - protected def removeReaction ( state : DialogState , rr : RemoveReaction ) : Unit = { 
 + protected def removeReaction ( rr : RemoveReaction ) : Unit = { 
 ( for { 
 reactions ← db . run { 
 ReactionEventRepo . delete ( DialogId ( peer , userId ) , rr . randomId , rr . code , userId ) 
 @ @ - 232 , 7 + 235 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 * @ return ` true ` if we must process message received request and ` false ` otherwise 
 * / 
 private def mustMakeReceive ( state : DialogState , mr : MessageReceived ) : Boolean = 
 - Instant . ofEpochMilli ( mr . date ) . isAfter ( state . lastReceiveDate ) & & ( mr . date < = mr . now | | state . lastMessageDate . isAfter ( Instant . ofEpochMilli ( mr . date ) ) ) 
 + Instant . ofEpochMilli ( mr . date ) . isAfter ( state . lastOwnerReceiveDate ) & & ( mr . date < = mr . now | | state . lastMessageDate . isAfter ( Instant . ofEpochMilli ( mr . date ) ) ) 
 
 / * * 
 * 
 @ @ - 249 , 7 + 252 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 * @ return ` true ` if we must process message received request and ` false ` otherwise 
 * / 
 private def mustMakeRead ( state : DialogState , mr : MessageRead ) : Boolean = 
 - Instant . ofEpochMilli ( mr . date ) . isAfter ( state . lastReadDate ) & & ( mr . date < = mr . now | | state . lastMessageDate . isAfter ( Instant . ofEpochMilli ( mr . date ) ) ) 
 + Instant . ofEpochMilli ( mr . date ) . isAfter ( state . lastOwnerReadDate ) & & ( mr . date < = mr . now | | state . lastMessageDate . isAfter ( Instant . ofEpochMilli ( mr . date ) ) ) 
 
 / * * 
 * check access hash and execute ` f ` , if access hash is valid 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 0874089 . . c868795 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . server . dialog 
 
 import akka . actor . _ 
 + import akka . event . Logging 
 import akka . http . scaladsl . util . FastFuture 
 import akka . util . Timeout 
 import com . github . benmanes . caffeine . cache . Cache 
 @ @ - 22 , 12 + 23 , 13 @ @ import scala . concurrent . { ExecutionContext , Future } 
 
 object DialogProcessor { 
 
 - def register ( ) : Unit = { 
 + private [ dialog ] def register ( ) : Unit = { 
 ActorSerializer . register ( 
 40010 → classOf [ DialogEvents . MessagesRead ] , 
 40011 → classOf [ DialogEvents . MessagesReceived ] , 
 40012 → classOf [ DialogEvents . NewMessage ] , 
 - 40013 → classOf [ DialogEvents . CounterReset ] , 
 + 40013 → classOf [ DialogEvents . SetCounter ] , 
 + 40015 → classOf [ DialogEvents . Initialized ] , 
 40014 → classOf [ DialogStateSnapshot ] 
 ) 
 } 
 @ @ - 93 , 11 + 95 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 } 
 } 
 
 - override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) 
 + override protected def handleCommand : Receive = actions orElse reactions 
 
 / / when receiving this messages , dialog reacts on other dialog ' s action 
 - def reactions ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 + def reactions : Receive = { 
 + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( sm ) / / User ' s message been sent 
 case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received 
 case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) 
 @ @ - 105 , 13 + 107 , 13 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 } 
 
 / / when receiving this messages , dialog is required to take an action 
 - def actions ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 - case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) 
 - case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) 
 - case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) 
 + def actions : Receive = { 
 + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( sm ) / / User sends message 
 + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( mrv ) / / User received messages 
 + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( mrd ) / / User reads messages 
 + case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( sr ) 
 + case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( rr ) 
 + case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) 
 } 
 
 / * * 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala 
 index 2ae2495 . . d2a82d2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala 
 @ @ - 48 , 24 + 48 , 15 @ @ trait DialogProcessorMigration extends Processor [ DialogState ] { 
 log . warning ( " Finding messages " ) 
 ( for { 
 historyOwner ← HistoryUtils . getHistoryOwner ( peer , userId ) 
 - metas ← db . run ( HistoryMessageRepo . findMetaAfter ( historyOwner , peer , d . ownerLastReadAt , Long . MaxValue ) ) 
 - _ = log . warning ( " Found { } messages " , metas . size ) 
 - newMessages = metas map { 
 - case ( randomId , date , senderUserId , header ) ⇒ 
 - NewMessage ( 
 - randomId = randomId , 
 - date = Instant . ofEpochMilli ( date . getMillis ) , 
 - senderUserId = senderUserId , 
 - messageHeader = header 
 - ) 
 - } 
 + unreadCount ← db . run ( HistoryMessageRepo . getUnreadCount ( historyOwner , userId , peer , d . ownerLastReadAt ) ) 
 + _ = log . warning ( " Found { } messages " , unreadCount ) 
 } yield PersistEvents ( 
 - Initialized ( ) + : 
 - ( newMessages . toList + + 
 - List ( 
 - MessagesRead ( Instant . ofEpochMilli ( d . ownerLastReadAt . getMillis ) , readerUserId = userId ) , 
 - MessagesRead ( Instant . ofEpochMilli ( d . lastReadAt . getMillis ) ) 
 - ) ) 
 + List ( 
 + Initialized ( ) , 
 + SetCounter ( unreadCount ) , 
 + MessagesRead ( Instant . ofEpochMilli ( d . ownerLastReadAt . getMillis ) , readerUserId = userId ) , 
 + MessagesRead ( Instant . ofEpochMilli ( d . lastReadAt . getMillis ) ) 
 + ) 
 ) ) pipeTo self 
 case PersistEvents ( events ) ⇒ 
 log . warning ( " Persisting events " ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index a8bcbd3 . . 0a39e4a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 29 , 6 + 29 , 7 @ @ object DialogRoot { 
 45013 → classOf [ DialogRootEvents . Shown ] , 
 45014 → classOf [ DialogRootEvents . Unarchived ] , 
 45015 → classOf [ DialogRootEvents . Unfavourited ] , 
 + 45017 → classOf [ DialogRootEvents . Initialized ] , 
 45016 → classOf [ DialogRootStateSnapshot ] 
 ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala 
 index 10d0881 . . 90cdc4b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala 
 @ @ - 2 , 9 + 2 , 11 @ @ package im . actor . server . dialog 
 
 import java . time . Instant 
 
 + import akka . event . { Logging , LoggingAdapter } 
 import akka . persistence . SnapshotMetadata 
 import im . actor . server . cqrs . { Event , ProcessorState , TaggedEvent } 
 import im . actor . server . model . Peer 
 + import org . slf4j . LoggerFactory 
 
 import scala . collection . SortedSet 
 
 @ @ - 34 , 7 + 36 , 9 @ @ private [ dialog ] object DialogState { 
 def initial ( userId : Int ) = DialogState ( 
 userId = userId , 
 lastMessageDate = Instant . ofEpochMilli ( 0 ) , 
 + lastOwnerReceiveDate = Instant . ofEpochMilli ( 0 ) , 
 lastReceiveDate = Instant . ofEpochMilli ( 0 ) , 
 + lastOwnerReadDate = Instant . ofEpochMilli ( 0 ) , 
 lastReadDate = Instant . ofEpochMilli ( 0 ) , 
 counter = 0 , 
 unreadMessages = SortedSet . empty ( UnreadMessage . OrderingAsc ) , 
 @ @ - 43 , 16 + 47 , 20 @ @ private [ dialog ] object DialogState { 
 } 
 
 private [ dialog ] final case class DialogState ( 
 - userId : Int , 
 - lastMessageDate : Instant , / / we don ' t use it now anywhere . should we remove it ? 
 - lastReceiveDate : Instant , 
 - lastReadDate : Instant , 
 - counter : Int , 
 - unreadMessages : SortedSet [ UnreadMessage ] , 
 - unreadMessagesMap : Map [ Long , Long ] 
 + userId : Int , 
 + lastMessageDate : Instant , / / we don ' t use it now anywhere . should we remove it ? 
 + lastOwnerReceiveDate : Instant , 
 + lastReceiveDate : Instant , 
 + lastOwnerReadDate : Instant , 
 + lastReadDate : Instant , 
 + counter : Int , 
 + unreadMessages : SortedSet [ UnreadMessage ] , 
 + unreadMessagesMap : Map [ Long , Long ] 
 ) extends ProcessorState [ DialogState ] { 
 import DialogEvents . _ 
 
 + val log = LoggerFactory . getLogger ( s " $ userId / DialogRoot " ) 
 + 
 override def updated ( e : Event ) : DialogState = e match { 
 case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ 
 if ( senderUserId ! = userId ) { 
 @ @ - 64 , 24 + 72 , 31 @ @ private [ dialog ] final case class DialogState ( 
 ) 
 } else this . copy ( lastMessageDate = date ) 
 case MessagesRead ( date , readerUserId ) if readerUserId = = userId ⇒ 
 + log . debug ( s " unreadMessages ( fromState ) $ { unreadMessages } " ) 
 val readMessages = unreadMessages . takeWhile ( um ⇒ um . date . isBefore ( date ) | | um . date = = date ) . map ( _ . randomId ) 
 - val newUnreadMessages = unreadMessages . dropWhile ( um ⇒ readMessages . contains ( um . randomId ) ) 
 + log . debug ( s " readMessages $ { readMessages } " ) 
 + log . debug ( s " readMessages date $ { unreadMessages . headOption map ( um ⇒ um . date . isBefore ( date ) | | um . date = = date ) } " ) 
 + val newUnreadMessages = unreadMessages . drop ( readMessages . size ) 
 val newUnreadMessagesMap = unreadMessagesMap - - readMessages 
 
 this . copy ( 
 counter = newUnreadMessages . size , 
 unreadMessages = newUnreadMessages , 
 - unreadMessagesMap = newUnreadMessagesMap 
 + unreadMessagesMap = newUnreadMessagesMap , 
 + lastOwnerReadDate = date 
 ) 
 case MessagesRead ( date , readerUserId ) if readerUserId ! = userId ⇒ 
 - if ( date . isAfter ( lastReadDate ) ) 
 + if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReadDate ) | | date = = lastReadDate ) ) 
 this . copy ( lastReadDate = date ) 
 else this 
 - case MessagesReceived ( date ) ⇒ 
 - if ( date . isAfter ( lastReceiveDate ) ) this . copy ( lastReceiveDate = date ) 
 + case MessagesReceived ( date , receiverUserId ) if receiverUserId = = userId ⇒ 
 + this . copy ( lastOwnerReceiveDate = date ) 
 + case MessagesReceived ( date , receiverUserId ) if receiverUserId ! = userId ⇒ 
 + if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReceiveDate ) | | date = = lastReceiveDate ) ) 
 + this . copy ( lastReceiveDate = date ) 
 else this 
 - case CounterReset ( ) ⇒ 
 - this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . OrderingAsc ) , unreadMessagesMap = Map . empty ) 
 + case SetCounter ( newCounter ) ⇒ 
 + this . copy ( counter = newCounter ) 
 case Initialized ( ) ⇒ this 
 } 
 
 @ @ - 90 , 7 + 105 , 9 @ @ private [ dialog ] final case class DialogState ( 
 copy ( 
 userId = s . userId , 
 lastMessageDate = s . lastMessageDate , 
 + lastOwnerReceiveDate = s . lastOwnerReceiveDate , 
 lastReceiveDate = s . lastReceiveDate , 
 + lastOwnerReadDate = s . lastOwnerReadDate , 
 lastReadDate = s . lastReadDate , 
 counter = s . counter , 
 unreadMessages = SortedSet ( 
 @ @ - 105 , 7 + 122 , 9 @ @ private [ dialog ] final case class DialogState ( 
 override lazy val snapshot = DialogStateSnapshot ( 
 userId = userId , 
 lastMessageDate = lastMessageDate , 
 + lastOwnerReceiveDate = lastOwnerReceiveDate , 
 lastReceiveDate = lastReceiveDate , 
 + lastOwnerReadDate = lastOwnerReadDate , 
 lastReadDate = lastReadDate , 
 counter = counter , 
 unreadMessages = unreadMessagesMap 
 diff - - git a / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala b / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala 
 index 3e1257a . . 46b1103 100644 
 - - - a / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala 
 + + + b / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala 
 @ @ - 5 , 7 + 5 , 7 @ @ import java . time . Instant 
 import java . util . Base64 
 
 import akka . actor . ActorSystem 
 - import akka . persistence . jdbc . serialization . SerializationFacade 
 + import akka . persistence . jdbc . serialization . { SerializationFacade , Serialized } 
 import akka . persistence . journal . Tagged 
 import akka . persistence . { AtomicWrite , PersistentRepr } 
 import akka . serialization . { Serialization , SerializationExtension } 
 @ @ - 18 , 7 + 18 , 7 @ @ import im . actor . server . group . { GroupEvent , GroupProcessor } 
 import im . actor . server . user . { UserEvent , UserProcessor } 
 import org . flywaydb . core . api . migration . jdbc . JdbcMigration 
 import org . joda . time . DateTime 
 - import shardakka . keyvalue . { ValueEvents , ValueQueries , ValueCommands , RootEvents } 
 + import shardakka . keyvalue . { RootEvents , ValueCommands , ValueEvents , ValueQueries } 
 
 import scala . concurrent . _ 
 import scala . concurrent . duration . Duration 
 @ @ - 86 , 7 + 86 , 7 @ @ final class V20160128142000 _ _ AkkaPersistence extends JdbcMigration { 
 val flowResult = 
 Source ( events ) 
 . map ( p ⇒ AtomicWrite ( p . _ 1 ) ) 
 - . via ( SerializationFacade ( system , " , " ) . serialize ) 
 + . via ( SerializationFacade ( system , " , " ) . serialize ( serialize = true ) ) 
 . map ( _ . get ) 
 . map { iter ⇒ 
 val ps = connection . prepareStatement ( sql ) 
 @ @ - 98 , 7 + 98 , 7 @ @ final class V20160128142000 _ _ AkkaPersistence extends JdbcMigration { 
 ps . setLong ( 2 , ser . sequenceNr ) 
 ps . setLong ( 3 , ser . created ) 
 ps . setString ( 4 , ser . tags . orNull ) 
 - ps . setBytes ( 5 , ser . serialized ) 
 + ps . setBytes ( 5 , ser . asInstanceOf [ Serialized ] . serialized ) 
 ps . addBatch ( ) 
 } 
 ps . execute ( ) 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 index 74af68c . . 26107e1 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 @ @ - 219 , 6 + 219 , 13 @ @ object HistoryMessageRepo { 
 . exists 
 . result 
 
 + def getUnreadCount ( historyOwner : Int , clientUserId : Int , peer : Peer , lastReadAt : DateTime , noServiceMessages : Boolean = false ) : FixedSqlAction [ Int , PostgresDriver . api . NoStream , Read ] = 
 + ( if ( noServiceMessages ) withoutServiceMessages else notDeletedMessages ) 
 + . filter ( m ⇒ m . userId = = = historyOwner & & m . peerType = = = peer . typ . value & & m . peerId = = = peer . id ) 
 + . filter ( m ⇒ m . date > lastReadAt & & m . senderUserId = ! = clientUserId ) 
 + . length 
 + . result 
 + 
 def deleteAll ( userId : Int , peer : Peer ) : FixedSqlAction [ Int , NoStream , Write ] = 
 notDeletedMessages 
 . filter ( m ⇒ m . userId = = = userId & & m . peerType = = = peer . typ . value & & m . peerId = = = peer . id ) 
 diff - - git a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala 
 index f355b8a . . 1e6a484 100644 
 - - - a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala 
 + + + b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala 
 @ @ - 91 , 7 + 91 , 6 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( 
 CommonSerialization . register ( ) 
 UserProcessor . register ( ) 
 GroupProcessor . register ( ) 
 - DialogProcessor . register ( ) 
 StickerMessages . register ( ) 
 
 val serverConfig = ActorConfig . load ( defaultConfig ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 index dfba5fe . . 4bbacdf 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 @ @ - 2 , 7 + 2 , 6 @ @ package im . actor . server . dialog 
 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 - import im . actor . api . rpc . sequence . { ApiUpdateContainer , ResponseGetDifference } 
 import im . actor . api . rpc . { AuthData , ClientData , Ok , PeersImplicits } 
 import im . actor . server . _ 
 import im . actor . server . acl . ACLUtils 
 @ @ - 20 , 12 + 19 , 43 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 
 behavior of " Dialog Processor " 
 
 + it should " pass reads after read with later date came from another user " in passReads ( ) 
 + 
 it should " not allow time out when there are highly frequent messages " in noTimeout ( ) 
 
 it should " not allow duplicated timestamp in messages " in uniqueTimestamp ( ) 
 
 private val messService = MessagingServiceImpl ( ) 
 
 + def passReads ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + 
 + val alicePeer = ApiPeer ( ApiPeerType . Private , alice . id ) 
 + val bobPeer = ApiPeer ( ApiPeerType . Private , bob . id ) 
 + 
 + def sendMessageToBob ( text : String ) : Future [ SeqStateDate ] = 
 + dialogExt . sendMessage ( bobPeer , alice . id , aliceAuthSid , Some ( aliceAuthId ) , ACLUtils . randomLong ( ) , textMessage ( text ) ) 
 + 
 + def sendMessageToAlice ( text : String ) : Future [ SeqStateDate ] = 
 + dialogExt . sendMessage ( alicePeer , bob . id , bobAuthSid , Some ( bobAuthId ) , ACLUtils . randomLong ( ) , textMessage ( text ) ) 
 + 
 + val dateToAlice = whenReady ( sendMessageToAlice ( " Hi " ) ) ( _ . date ) 
 + val dateToBob = whenReady ( sendMessageToBob ( " Hi " ) ) ( _ . date ) 
 + 
 + whenReady ( dialogExt . messageRead ( alicePeer , bob . id , 0 , dateToBob ) ) ( identity ) 
 + whenReady ( dialogExt . getDialogInfo ( alice . id , bobPeer . asModel ) ) { info ⇒ 
 + info . counter should be ( 1 ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + whenReady ( dialogExt . messageRead ( bobPeer , alice . id , 0 , dateToAlice ) ) ( identity ) 
 + whenReady ( dialogExt . getDialogInfo ( alice . id , bobPeer . asModel ) ) { info ⇒ 
 + info . counter should be ( 0 ) 
 + } 
 + } 
 + 
 def noTimeout ( ) = { 
 val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 @ @ - 42 , 8 + 72 , 12 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 val toAlice = for ( i ← 1 to 50 ) yield sendMessageToAlice ( s " Hello $ i " ) 
 val toBob = for ( i ← 1 to 50 ) yield sendMessageToBob ( s " Hello you back $ i " ) 
 
 - toAlice foreach { whenReady ( _ ) ( identity ) } 
 - toBob foreach { whenReady ( _ ) ( identity ) } 
 + toAlice foreach { 
 + whenReady ( _ ) ( identity ) 
 + } 
 + toBob foreach { 
 + whenReady ( _ ) ( identity ) 
 + } 
 
 { 
 implicit val clientData = ClientData ( bobAuthId , 2 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 @ @ - 84 , 8 + 118 , 12 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 val toAlice = for ( i ← 1 to 50 ) yield sendMessageToAlice ( s " Hello $ i " ) 
 val toBob = for ( i ← 1 to 50 ) yield sendMessageToBob ( s " Hello you back $ i " ) 
 
 - toAlice foreach { whenReady ( _ ) ( identity ) } 
 - toBob foreach { whenReady ( _ ) ( identity ) } 
 + toAlice foreach { 
 + whenReady ( _ ) ( identity ) 
 + } 
 + toBob foreach { 
 + whenReady ( _ ) ( identity ) 
 + } 
 
 { 
 implicit val clientData = ClientData ( bobAuthId , 2 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorStateSpec . scala 
 deleted file mode 100644 
 index fbd81e6 . . 0000000 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorStateSpec . scala 
 + + + / dev / null 
 @ @ - 1 , 55 + 0 , 0 @ @ 
 - package im . actor . server . dialog 
 - 
 - import java . time . Instant 
 - 
 - import akka . persistence . SnapshotMetadata 
 - import im . actor . api . rpc . PeersImplicits 
 - import im . actor . server . ActorSuite 
 - import im . actor . server . cqrs . ProcessorStateProbe 
 - import im . actor . server . model . Peer 
 - 
 - import scala . util . Random 
 - 
 - final class DialogProcessorStateSpec extends ActorSuite with PeersImplicits { 
 - it should " increase counter on NewMessage and decrease on Read " in counter 
 - 
 - import im . actor . server . dialog . DialogEvents . _ 
 - 
 - def counter ( ) = { 
 - val userId = 1 
 - implicit val probe = ProcessorStateProbe ( DialogState . initial ( 1 ) ) 
 - 
 - val alice = Peer . privat ( 2 ) 
 - 
 - val date1 = Instant . now ( ) 
 - probe . commit ( NewMessage ( Random . nextLong ( ) , date1 , alice . id ) ) 
 - probe . state . counter should be ( 1 ) 
 - 
 - val date2 = date1 . plusMillis ( 1 ) 
 - probe . commit ( NewMessage ( Random . nextLong ( ) , date2 , alice . id ) ) 
 - probe . commit ( NewMessage ( Random . nextLong ( ) , date2 , userId ) ) 
 - probe . state . counter should be ( 2 ) 
 - 
 - checkSnapshot ( userId ) 
 - 
 - probe . commit ( MessagesRead ( date1 , alice . id ) ) 
 - probe . state . counter should be ( 2 ) 
 - 
 - probe . commit ( MessagesRead ( date1 , userId ) ) 
 - probe . state . counter should be ( 1 ) 
 - 
 - probe . commit ( NewMessage ( Random . nextLong ( ) , Instant . now ( ) , alice . id ) ) 
 - probe . commit ( NewMessage ( Random . nextLong ( ) , Instant . now ( ) . plusMillis ( 1 ) , alice . id ) ) 
 - val lastDate = Instant . now ( ) . plusMillis ( 2 ) 
 - probe . commit ( NewMessage ( Random . nextLong ( ) , lastDate , alice . id ) ) 
 - probe . state . counter should be ( 4 ) 
 - 
 - probe . commit ( MessagesRead ( lastDate , userId ) ) 
 - probe . state . counter should be ( 0 ) 
 - 
 - checkSnapshot ( userId ) 
 - } 
 - 
 - private def checkSnapshot ( userId : Int ) ( implicit probe : ProcessorStateProbe [ DialogState ] ) = 
 - DialogState . initial ( userId ) . withSnapshot ( SnapshotMetadata ( " " , 0 ) , probe . state . snapshot ) should be ( probe . state ) 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogStateSpec . scala 
 new file mode 100644 
 index 0000000 . . 9e8efc2 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogStateSpec . scala 
 @ @ - 0 , 0 + 1 , 75 @ @ 
 + package im . actor . server . dialog 
 + 
 + import java . time . Instant 
 + 
 + import akka . persistence . SnapshotMetadata 
 + import im . actor . api . rpc . PeersImplicits 
 + import im . actor . server . ActorSuite 
 + import im . actor . server . cqrs . ProcessorStateProbe 
 + import im . actor . server . model . Peer 
 + 
 + import scala . util . Random 
 + 
 + final class DialogStateSpec extends ActorSuite with PeersImplicits { 
 + it should " increase counter on NewMessage and decrease on Read " in counter 
 + 
 + it should " recalculate counter on read " in recalculate 
 + 
 + import im . actor . server . dialog . DialogEvents . _ 
 + 
 + def counter ( ) = { 
 + val userId = 1 
 + implicit val probe = ProcessorStateProbe ( DialogState . initial ( 1 ) ) 
 + 
 + val alice = Peer . privat ( 2 ) 
 + 
 + val date1 = Instant . now ( ) 
 + probe . commit ( NewMessage ( Random . nextLong ( ) , date1 , alice . id ) ) 
 + probe . state . counter should be ( 1 ) 
 + 
 + val date2 = date1 . plusMillis ( 1 ) 
 + probe . commit ( NewMessage ( Random . nextLong ( ) , date2 , alice . id ) ) 
 + probe . commit ( NewMessage ( Random . nextLong ( ) , date2 , userId ) ) 
 + probe . state . counter should be ( 2 ) 
 + 
 + checkSnapshot ( userId ) 
 + 
 + probe . commit ( MessagesRead ( date1 , alice . id ) ) 
 + probe . state . counter should be ( 2 ) 
 + 
 + probe . commit ( MessagesRead ( date1 , userId ) ) 
 + probe . state . counter should be ( 1 ) 
 + 
 + probe . commit ( NewMessage ( Random . nextLong ( ) , Instant . now ( ) , alice . id ) ) 
 + probe . commit ( NewMessage ( Random . nextLong ( ) , Instant . now ( ) . plusMillis ( 1 ) , alice . id ) ) 
 + val lastDate = Instant . now ( ) . plusMillis ( 2 ) 
 + probe . commit ( NewMessage ( Random . nextLong ( ) , lastDate , alice . id ) ) 
 + probe . state . counter should be ( 4 ) 
 + 
 + probe . commit ( MessagesRead ( lastDate , userId ) ) 
 + probe . state . counter should be ( 0 ) 
 + 
 + checkSnapshot ( userId ) 
 + } 
 + 
 + def recalculate ( ) = { 
 + val userId = 1 
 + implicit val probe = ProcessorStateProbe ( DialogState . initial ( 1 ) ) 
 + 
 + val alice = Peer . privat ( 2 ) 
 + 
 + probe . commit ( SetCounter ( 10 ) ) 
 + 
 + val date1 = Instant . now ( ) 
 + probe . commit ( NewMessage ( Random . nextLong ( ) , date1 , alice . id ) ) 
 + probe . state . counter should be ( 11 ) 
 + checkSnapshot ( userId ) 
 + 
 + probe . commit ( MessagesRead ( date1 , userId ) ) 
 + probe . state . counter should be ( 0 ) 
 + checkSnapshot ( userId ) 
 + } 
 + 
 + private def checkSnapshot ( userId : Int ) ( implicit probe : ProcessorStateProbe [ DialogState ] ) = 
 + DialogState . initial ( userId ) . withSnapshot ( SnapshotMetadata ( " " , 0 ) , probe . state . snapshot ) should be ( probe . state ) 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index d43da37 . . 54e554a 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 6 , 7 + 6 , 7 @ @ object Dependencies { 
 object V { 
 val actorCommons = " 0 . 0 . 15 " 
 val actorBotkit = " 1 . 0 . 88 " 
 - val akka = " 2 . 4 . 2 " 
 + val akka = " 2 . 4 . 4 " 
 val akkaHttpJson = " 1 . 5 . 0 " 
 val cats = " 0 . 3 . 0 " 
 val circe = " 0 . 2 . 1 " 
 @ @ - 41 , 7 + 41 , 7 @ @ object Dependencies { 
 val sprayClient = " io . spray " % % " spray - client " % " 1 . 3 . 3 " 
 val sprayWebsocket = " com . wandoulabs . akka " % % " spray - websocket " % " 0 . 1 . 4 " 
 
 - val akkaPersistenceJdbc = " com . github . dnvriend " % % " akka - persistence - jdbc " % " 2 . 2 . 8 " 
 + val akkaPersistenceJdbc = " com . github . dnvriend " % % " akka - persistence - jdbc " % " 2 . 2 . 18 " 
 val apacheEmail = " org . apache . commons " % " commons - email " % " 1 . 4 " 
 
 val betterFiles = " com . github . pathikrit " % % " better - files " % " 2 . 13 . 0 "

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 index 641806f . . 71c4080 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 @ @ - 43 , 7 + 43 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 ) 
 
 for { 
 - senderName ← userExt . getName ( receiverUserId , senderUserId ) 
 + senderName ← userExt . getName ( senderUserId , receiverUserId ) 
 pushText ← getPushText ( peer , receiverUserId , senderName , message ) 
 _ ← seqUpdatesExt . deliverSingleUpdate ( 
 receiverUserId , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 index 4181a2e . . 3230c26 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 import im . actor . util . cache . CacheHelpers . _ 
 + import org . joda . time . DateTime 
 import slick . dbio . DBIO 
 
 import slick . driver . PostgresDriver . api . Database 
 @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 dialog ← optDialog match { 
 case Some ( dialog ) ⇒ DBIO . successful ( dialog ) 
 case None ⇒ 
 - val dialog = DialogModel ( userId , peer ) 
 + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 for { 
 _ ← DialogRepo . create ( dialog ) 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index b45cc33 . . d2c2ddb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 throw e 
 } ) pipeTo sender ( ) 
 sendFuture onSuccess { 
 - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) 
 + case SeqStateDate ( _ , _ , date ) ⇒ 
 + self ! LastOwnMessageDate ( date ) 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 } 
 } 
 
 @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 deliveryExt 
 . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 . map ( _ ⇒ SendMessageAck ( ) ) 
 - . pipeTo ( sender ( ) ) 
 - 
 - if ( state . isHidden ) 
 - self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + . pipeTo ( sender ( ) ) onSuccess { 
 + case _ ⇒ 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } 
 
 / / onSuccess ( fu ) { _ = > 
 / / updatePeerMessageDate ( ) 
 @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 if ( state . isHidden ) 
 sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) 
 else { 
 + 
 val future = 
 ( for { 
 _ ← db . run ( DialogRepo . hide ( userId , peer ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 55230de . . 01a8d62 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 
 + sealed trait DialogGroup { 
 + def key : String 
 + def title : String 
 + } 
 + 
 + object DialogGroups { 
 + object Privates extends DialogGroup { 
 + override def key : String = " privates " 
 + 
 + override def title : String = " Private " 
 + } 
 + 
 + object Groups extends DialogGroup { 
 + override def key : String = " groups " 
 + 
 + override def title : String = " Groups " 
 + } 
 + } 
 + 
 sealed trait DialogExtension extends Extension 
 
 final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { 
 @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 
 private val log = Logging ( system , getClass ) 
 
 - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 peer match { 
 - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ 
 + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ 
 log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) 
 failed 
 case _ ⇒ f 
 } 
 
 def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 val date = Instant . now ( ) . toEpochMilli 
 val sender = Peer . privat ( senderUserId ) 
 val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) 
 @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 randomId : Long , 
 message : ApiMessage 
 ) : Future [ Unit ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { 
 val sender = Peer . privat ( senderUserId ) 
 val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) 
 ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) 
 } 
 
 def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val receiver = Peer . privat ( receiverUserId ) 
 val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) 
 @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 
 def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val reader = Peer . privat ( readerUserId ) 
 val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) 
 @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 
 def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def isSharedUser ( userId : Int ) : Boolean = userId = = 0 
 
 def getGroupedDialogs ( userId : Int ) = { 
 - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { 
 case ( ( groupModels , privateModels ) , dialog ) ⇒ 
 if ( dialog . peer . typ = = PeerType . Group ) 
 @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) 
 privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) 
 } yield Vector ( 
 - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , 
 - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) 
 + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , 
 + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) 
 ) 
 } ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index 4219e8c . . d3a6b75 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { 
 for { 
 _ ← persist . HistoryMessageRepo . create ( messages ) 
 _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) 
 - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 } yield ( ) 
 } else if ( toPeer . typ = = PeerType . Group ) { 
 DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 index 9475e63 . . 912092d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 @ @ - 15 , 27 + 15 , 19 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int , applePushManager : A 
 private val db = DbExtension ( system ) . db 
 
 def deliverInvisible ( seq : Int , creds : ApplePushCredentials ) : Unit = { 
 - < < < < < < < Updated upstream 
 - applePushManager . getInstance ( creds . apnsKey ) match { 
 - case Some ( mgr ) ⇒ 
 - db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ 
 - val builder = 
 - new ApnsPayloadBuilder ( ) 
 - . addCustomProperty ( " seq " , seq ) 
 - . setContentAvailable ( true ) 
 - = = = = = = = 
 withMgr ( creds . apnsKey ) { mgr ⇒ 
 log . debug ( " Delivering invisible ( seq : { } ) to apnsKey : { } " , seq , creds . apnsKey ) 
 - > > > > > > > Stashed changes 
 - 
 + db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ 
 + val builder = 
 + new ApnsPayloadBuilder ( ) 
 + . addCustomProperty ( " seq " , seq ) 
 + . setContentAvailable ( true ) 
 builder . setBadgeNumber ( unreadTotal ) 
 
 val payload = builder . buildWithDefaultMaximumLength ( ) 
 
 mgr . getQueue . add ( new SimpleApnsPushNotification ( creds . token . toByteArray , payload ) ) 
 } 
 - case None ⇒ 
 - log . warning ( " No apple push configured for apns - key : { } " , creds . apnsKey ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 index 191aa44 . . a59b5b2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { 
 def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { 
 phones . headOption match { 
 case Some ( phone ) ⇒ Some ( phone . number ) 
 - case None ⇒ Some ( 0L ) 
 + case None ⇒ Some ( 0L ) 
 } 
 } 
 
 def normalizeLocalName ( name : Option [ String ] ) = name match { 
 - case n @ Some ( name ) if name . nonEmpty ⇒ n 
 - case _ ⇒ None 
 + case n @ Some ( name ) if name . nonEmpty ⇒ n 
 + case _ ⇒ None 
 } 
 
 def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 index 9bf22b0 . . d215e44 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . api . http . bots 
 import java . util . Base64 
 
 import akka . actor . ActorSystem 
 - import akka . http . scaladsl . model . StatusCode 
 import akka . http . scaladsl . model . StatusCodes . _ 
 import akka . http . scaladsl . model . ws . { Message , TextMessage } 
 + import akka . http . scaladsl . model . { HttpMethod , StatusCode } 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . Route 
 import akka . stream . Materializer 
 @ @ - 14 , 20 + 14 , 16 @ @ import akka . util . ByteString 
 import cats . data . OptionT 
 import cats . std . future . _ 
 import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport 
 - import im . actor . api . rpc . messaging . ApiJsonMessage 
 - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . api . rpc . sequence . UpdateRawUpdate 
 import im . actor . server . api . http . RoutesHandler 
 import im . actor . server . api . http . json . { ContentUnmarshaller , JsValueUnmarshaller , JsonFormatters , Status } 
 import im . actor . server . bot . { BotExtension , BotServerBlueprint } 
 - import im . actor . server . dialog . DialogExtension 
 import im . actor . server . model . AuthSession 
 import im . actor . server . user . UserExtension 
 import play . api . libs . json . _ 
 import upickle . default . _ 
 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . util . control . NoStackTrace 
 import scala . util . { Failure , Success } 
 
 @ @ - 42 , 25 + 38 , 42 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 
 override def routes : Route = 
 path ( " bots " / " hooks " / Segment ) { token ⇒ 
 - post { 
 - extractRequest { request ⇒ 
 - val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) 
 + extractRequest { request ⇒ 
 + val method = request . method 
 + val queryString = request . uri . queryString ( ) 
 + val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) 
 
 - val sendMessageF = for { 
 - data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) 
 - res ← sendMessage ( headers , data , token ) 
 - } yield res 
 + val sendMessageF = for { 
 + data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) 
 + res ← sendMessage ( method , queryString , headers , data , token ) 
 + } yield res 
 
 - onComplete ( sendMessageF ) { 
 - case Success ( result ) ⇒ 
 - result match { 
 - case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) 
 - case Right ( _ ) ⇒ complete ( OK → Status ( " ok " ) ) 
 - } 
 - case Failure ( e ) ⇒ 
 - log . error ( e , " Failed to handle bot hook " ) 
 - complete ( InternalServerError ) 
 - } 
 + onComplete ( sendMessageF ) { 
 + case Success ( result ) ⇒ 
 + result match { 
 + case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) 
 + case Right ( _ ) ⇒ 
 + val response = 
 + " " " 
 + | < html > 
 + | < head > 
 + | < title > Please , return to the app < / title > 
 + | < style > 
 + | . element { 
 + | position : relative ; 
 + | top : 50 % ; 
 + | transform : translateY ( - 50 % ) ; 
 + | } 
 + | < / style > 
 + | < / head > 
 + | < body > < center id = " message " > < h3 > Please , return to the app . < / h1 > < / center > < / body > 
 + | < / html > 
 + " " " . stripMargin 
 + complete ( OK → Status ( response ) ) 
 + } 
 + case Failure ( e ) ⇒ 
 + log . error ( e , " Failed to handle bot hook " ) 
 + complete ( InternalServerError ) 
 } 
 } 
 } ~ path ( " bots " / Segment ) { token ⇒ 
 @ @ - 84 , 7 + 97 , 7 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 } 
 } 
 
 - private def sendMessage ( headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { 
 + private def sendMessage ( method : HttpMethod , queryString : Option [ String ] , headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { 
 ( for { 
 hook ← OptionT ( botExt . findWebHook ( token ) ) 
 _ ← OptionT . pure ( userExt . broadcastUserUpdate ( 
 @ @ - 95 , 6 + 108 , 8 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 " dataType " → JsString ( " HookData " ) , 
 " data " → JsObject ( Map ( 
 " name " → JsString ( hook . name ) , 
 + " method " → JsString ( method . name ) , 
 + " queryString " → ( queryString map JsString getOrElse JsNull ) , 
 " headers " → JsObject ( headers map { case ( name , value ) ⇒ name → JsString ( value ) } ) , 
 " body " → JsString ( Base64 . getEncoder . encodeToString ( data . toArray ) ) 
 ) ) 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 index f7b0742 . . f9c82b0 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { 
 def findLastReadBefore ( date : DateTime , userId : Int ) = 
 dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result 
 
 - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) 
 + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 
 def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 index 14c35dd . . 66d4ebf 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { 
 | " com . trueaccord . scalapb . GeneratedMessage " = actor 
 | } 
 | } 
 + | 
 + | cluster . sharding . state - store - mode = " ddata " 
 | } 
 " " " . stripMargin 
 ) ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 index 3d25a02 . . 72dc6c1 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 @ @ - 1 , 27 + 1 , 52 @ @ 
 package im . actor . server 
 
 import akka . actor . ActorSystem 
 - import akka . util . Timeout 
 import im . actor . api . rpc . ClientData 
 - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } 
 + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . api . rpc . users . ApiUser 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . dialog . DialogGroup 
 + import org . scalatest . concurrent . ScalaFutures 
 
 - import scala . concurrent . Await 
 + import scala . language . postfixOps 
 import scala . util . Random 
 
 - trait MessagingSpecHelpers { 
 - val timeout : Timeout 
 + trait MessagingSpecHelpers extends ScalaFutures { 
 + implicit val system : ActorSystem 
 
 def sendMessageToUser ( userId : Int , message : ApiMessage ) ( 
 implicit 
 clientData : ClientData , 
 - msgService : MessagingService , 
 - system : ActorSystem 
 + msgService : MessagingService 
 ) : Unit = { 
 - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) 
 - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) 
 + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ 
 + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) 
 + } 
 } 
 
 def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) 
 + 
 + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { 
 + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ 
 + resp . toOption . get . dialogs map { 
 + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs 
 + } toMap 
 + } 
 + } 
 + 
 + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { 
 + val dgs = getDialogGroups ( ) 
 + dgs get group . key match { 
 + case Some ( ds ) ⇒ ds 
 + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) 
 + } 
 + } 
 + 
 + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { 
 + users foreach { user ⇒ 
 + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) 
 + Thread . sleep ( 1 ) 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 index 85ba87d . . fe02129 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } 
 - import org . scalatest . Inside . _ 
 + import im . actor . server . _ 
 + import im . actor . server . dialog . DialogGroups 
 
 import scala . concurrent . { Await , Future } 
 import scala . concurrent . duration . _ 
 @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec 
 extends BaseAppSuite 
 with ImplicitAuthService 
 with ImplicitSessionRegion 
 - with GroupsServiceHelpers { 
 + with GroupsServiceHelpers 
 + with MessagingSpecHelpers { 
 " LoadGroupedDialogs " should " load groups and privates " in loadGrouped 
 
 - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 - private val service = MessagingServiceImpl ( ) 
 + " Dialogs " should " appear in top on new incoming message " in incomingGoTop 
 + it should " appear in top on new outgoing message " in outgoingGoTop 
 + 
 + " Hidden dialogs " should " appear on new message " in appearHidden 
 + it should " appear on show " in appearShown 
 + 
 + import DialogGroups . _ 
 + 
 + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 + private implicit lazy val service = MessagingServiceImpl ( ) 
 
 def loadGrouped ( ) = { 
 val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) 
 @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec 
 } 
 } 
 } 
 + 
 + def incomingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) 
 + 
 + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = bobClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val dgs = getDialogGroups ( ) 
 + val privates = dgs ( Privates . key ) 
 + privates . size should equal ( 2 ) 
 + privates . head . peer . id should equal ( bob . id ) 
 + privates . last . peer . id should equal ( eve . id ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val privates = getDialogGroups ( Privates ) 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + } 
 + 
 + def outgoingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + val ( eve , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + 
 + prepareDialogs ( bob , eve ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( bob . id ) 
 + } 
 + } 
 + 
 + def appearHidden ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 + 
 + def appearShown ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 } 
 \ No newline at end of file
