BLEU SCORE: 0.16590387014219712

TEST MSG: test ( server : session ) : fixed session resend specs
GENERATED MSG: feat ( session ) : kill session on resend buffer overflow

TEST DIFF (one line): diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala < nl > deleted file mode 100644 < nl > index 77417f2 . . 0000000 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala < nl > + + + / dev / null < nl > @ @ - 1 , 100 + 0 , 0 @ @ < nl > - package im . actor . server . session < nl > - < nl > - import akka . testkit . TestProbe < nl > - import com . typesafe . config . ConfigFactory < nl > - import im . actor . api . rpc . _ < nl > - import im . actor . api . rpc . auth . { RequestStartPhoneAuth , ResponseStartPhoneAuth } < nl > - import im . actor . api . rpc . codecs . RequestCodec < nl > - import im . actor . server . ActorSpecification < nl > - import im . actor . server . mtproto . protocol . _ < nl > - < nl > - import scala . concurrent . duration . _ < nl > - import scala . util . Random < nl > - < nl > - final class SessionResendLargeSpec extends BaseSessionSpec ( < nl > - ActorSpecification . createSystem ( ConfigFactory . parseString ( < nl > - " " " < nl > - | session { < nl > - | resend { < nl > - | ack - timeout = 5 seconds < nl > - | max - resend - size = 1 KiB < nl > - | max - buffer - size = 1 KiB < nl > - | } < nl > - | } < nl > - " " " . stripMargin < nl > - ) ) < nl > - ) { < nl > - behavior of " Session ' s ReSender with max - resend - size set to 0 KiB " < nl > - < nl > - it should " resend UnsentResponse instead of the full response " in Sessions ( ) . e1 < nl > - it should " kill session on resend buffer overflow " in Sessions ( ) . e2 < nl > - < nl > - case class Sessions ( ) { < nl > - def e1 ( ) = { < nl > - implicit val probe = TestProbe ( ) < nl > - < nl > - val authId = createAuthId ( ) < nl > - val sessionId = Random . nextLong ( ) < nl > - val requestMessageId = Random . nextLong ( ) < nl > - < nl > - val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( < nl > - phoneNumber = 75553333333L , < nl > - appId = 1 , < nl > - apiKey = " apiKey " , < nl > - deviceHash = Random . nextLong . toBinaryString . getBytes , < nl > - deviceTitle = " Specs Has You " , < nl > - timeZone = None , < nl > - preferredLanguages = Vector . empty < nl > - ) ) ) . require < nl > - sendMessageBox ( authId , sessionId , sessionRegion . ref , requestMessageId , ProtoRpcRequest ( encodedRequest ) ) < nl > - < nl > - expectNewSession ( authId , sessionId , requestMessageId ) < nl > - < nl > - expectRpcResult ( authId , sessionId , sendAckAt = None ) should matchPattern { < nl > - case RpcOk ( _ : ResponseStartPhoneAuth ) ⇒ < nl > - } < nl > - < nl > - / / We didn ' t send Ack < nl > - Thread . sleep ( 5000 ) < nl > - < nl > - val messageBox = expectMessageBox ( ) < nl > - messageBox . body should matchPattern { < nl > - case UnsentResponse ( _ , rqMessageId , length ) if rqMessageId = = requestMessageId & & length > 0 ⇒ < nl > - } < nl > - < nl > - val msgId = Random . nextLong ( ) < nl > - sendMessageBox ( authId , sessionId , sessionRegion . ref , msgId , RequestResend ( messageBox . body . asInstanceOf [ UnsentResponse ] . messageId ) ) < nl > - < nl > - expectRpcResult ( authId , sessionId , sendAckAt = None , expectAckFor = Set ( msgId ) ) should matchPattern { < nl > - case RpcOk ( _ : ResponseStartPhoneAuth ) ⇒ < nl > - } < nl > - < nl > - expectNoMsg ( 6 . seconds ) < nl > - } < nl > - < nl > - def e2 ( ) = { < nl > - val watchProbe = TestProbe ( ) < nl > - < nl > - val authId = createAuthId ( ) < nl > - val sessionId = Random . nextLong ( ) < nl > - val session = system . actorOf ( Session . props , s " $ { authId } _ $ sessionId " ) < nl > - watchProbe watch session < nl > - < nl > - val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( < nl > - phoneNumber = 75553333333L , < nl > - appId = 1 , < nl > - apiKey = " apiKey " , < nl > - deviceHash = Random . nextLong . toBinaryString . getBytes , < nl > - deviceTitle = " Specs Has You " , < nl > - timeZone = None , < nl > - preferredLanguages = Vector . empty < nl > - ) ) ) . require < nl > - < nl > - for ( _ ← 1 to 100 ) < nl > - TestProbe ( ) . send ( session , handleMessageBox ( Random . nextLong ( ) , ProtoRpcRequest ( encodedRequest ) ) ) < nl > - < nl > - watchProbe . expectTerminated ( session ) < nl > - } < nl > - } < nl > - < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendOverflowSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendOverflowSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 569e4cf < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendOverflowSpec . scala < nl > @ @ - 0 , 0 + 1 , 55 @ @ < nl > + package im . actor . server . session < nl > + < nl > + import akka . testkit . TestProbe < nl > + import com . typesafe . config . ConfigFactory < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . auth . { RequestStartPhoneAuth , ResponseStartPhoneAuth } < nl > + import im . actor . api . rpc . codecs . RequestCodec < nl > + import im . actor . server . ActorSpecification < nl > + import im . actor . server . mtproto . protocol . _ < nl > + < nl > + import scala . concurrent . duration . _ < nl > + import scala . util . Random < nl > + < nl > + final class SessionResendOverflowSpec extends BaseSessionSpec ( < nl > + ActorSpecification . createSystem ( ConfigFactory . parseString ( < nl > + " " " < nl > + | session { < nl > + | resend { < nl > + | max - buffer - size = 100 < nl > + | } < nl > + | } < nl > + " " " . stripMargin < nl > + ) ) < nl > + ) { < nl > + behavior of " Session ' s ReSender with max - buffer - size set to 100 KiB " < nl > + < nl > + it should " kill session on resend buffer overflow " in Sessions ( ) . e1 < nl > + < nl > + case class Sessions ( ) { < nl > + def e1 ( ) = { < nl > + val watchProbe = TestProbe ( ) < nl > + < nl > + val authId = createAuthId ( ) < nl > + val sessionId = Random . nextLong ( ) < nl > + val session = system . actorOf ( Session . props , s " $ { authId } _ $ sessionId " ) < nl > + watchProbe watch session < nl > + < nl > + val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( < nl > + phoneNumber = 75553333333L , < nl > + appId = 1 , < nl > + apiKey = " apiKey " , < nl > + deviceHash = Random . nextLong . toBinaryString . getBytes , < nl > + deviceTitle = " Spec Has You " , < nl > + timeZone = None , < nl > + preferredLanguages = Vector . empty < nl > + ) ) ) . require < nl > + < nl > + TestProbe ( ) . send ( session , handleMessageBox ( Random . nextLong ( ) , ProtoRpcRequest ( encodedRequest ) ) ) < nl > + TestProbe ( ) . send ( session , handleMessageBox ( Random . nextLong ( ) , ProtoRpcRequest ( encodedRequest ) ) ) < nl > + < nl > + watchProbe . expectTerminated ( session ) < nl > + } < nl > + } < nl > + < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionUnsentSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionUnsentSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 5ac8ff1 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionUnsentSpec . scala < nl > @ @ - 0 , 0 + 1 , 98 @ @ < nl > + package im . actor . server . session < nl > + < nl > + import akka . testkit . TestProbe < nl > + import com . typesafe . config . ConfigFactory < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . auth . { RequestStartPhoneAuth , ResponseStartPhoneAuth } < nl > + import im . actor . api . rpc . codecs . RequestCodec < nl > + import im . actor . server . ActorSpecification < nl > + import im . actor . server . mtproto . protocol . _ < nl > + < nl > + import scala . concurrent . duration . _ < nl > + import scala . util . Random < nl > + < nl > + final class SessionUnsentSpec extends BaseSessionSpec ( < nl > + ActorSpecification . createSystem ( ConfigFactory . parseString ( < nl > + " " " < nl > + | session { < nl > + | resend { < nl > + | ack - timeout = 5 seconds < nl > + | max - resend - size = 0 < nl > + | } < nl > + | } < nl > + " " " . stripMargin < nl > + ) ) < nl > + ) { < nl > + behavior of " Session ' s ReSender with max - resend - size set to 0 KiB " < nl > + < nl > + it should " resend UnsentResponse instead of the full response " in Sessions ( ) . e1 < nl > + < nl > + case class Sessions ( ) { < nl > + def e1 ( ) = { < nl > + implicit val probe = TestProbe ( ) < nl > + < nl > + val authId = createAuthId ( ) < nl > + val sessionId = Random . nextLong ( ) < nl > + val requestMessageId = Random . nextLong ( ) < nl > + < nl > + val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( < nl > + phoneNumber = 75553333333L , < nl > + appId = 1 , < nl > + apiKey = " apiKey " , < nl > + deviceHash = Random . nextLong . toBinaryString . getBytes , < nl > + deviceTitle = " Spec Has You " , < nl > + timeZone = None , < nl > + preferredLanguages = Vector . empty < nl > + ) ) ) . require < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , requestMessageId , ProtoRpcRequest ( encodedRequest ) ) < nl > + < nl > + expectNewSession ( authId , sessionId , requestMessageId ) < nl > + < nl > + expectRpcResult ( authId , sessionId , sendAckAt = None ) should matchPattern { < nl > + case RpcOk ( _ : ResponseStartPhoneAuth ) ⇒ < nl > + } < nl > + < nl > + / / We didn ' t send Ack < nl > + Thread . sleep ( 5000 ) < nl > + < nl > + val messageBox = expectMessageBox ( ) < nl > + messageBox . body should matchPattern { < nl > + case UnsentResponse ( _ , rqMessageId , length ) if rqMessageId = = requestMessageId & & length > 0 ⇒ < nl > + } < nl > + < nl > + val msgId = Random . nextLong ( ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , msgId , RequestResend ( messageBox . body . asInstanceOf [ UnsentResponse ] . messageId ) ) < nl > + < nl > + expectRpcResult ( authId , sessionId , sendAckAt = None , expectAckFor = Set ( msgId ) ) should matchPattern { < nl > + case RpcOk ( _ : ResponseStartPhoneAuth ) ⇒ < nl > + } < nl > + < nl > + expectNoMsg ( 6 . seconds ) < nl > + } < nl > + < nl > + def e2 ( ) = { < nl > + val watchProbe = TestProbe ( ) < nl > + < nl > + val authId = createAuthId ( ) < nl > + val sessionId = Random . nextLong ( ) < nl > + val session = system . actorOf ( Session . props , s " $ { authId } _ $ sessionId " ) < nl > + watchProbe watch session < nl > + < nl > + val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( < nl > + phoneNumber = 75553333333L , < nl > + appId = 1 , < nl > + apiKey = " apiKey " , < nl > + deviceHash = Random . nextLong . toBinaryString . getBytes , < nl > + deviceTitle = " Specs Has You " , < nl > + timeZone = None , < nl > + preferredLanguages = Vector . empty < nl > + ) ) ) . require < nl > + < nl > + for ( _ ← 1 to 100 ) < nl > + TestProbe ( ) . send ( session , handleMessageBox ( Random . nextLong ( ) , ProtoRpcRequest ( encodedRequest ) ) ) < nl > + < nl > + watchProbe . expectTerminated ( session ) < nl > + } < nl > + } < nl > + < nl > + } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - models / src / main / scala / im / actor / server / mtproto / protocol / ProtoMessage . scala b / actor - models / src / main / scala / im / actor / server / mtproto / protocol / ProtoMessage . scala < nl > index 16e414c . . 52dec71 100644 < nl > - - - a / actor - models / src / main / scala / im / actor / server / mtproto / protocol / ProtoMessage . scala < nl > + + + b / actor - models / src / main / scala / im / actor / server / mtproto / protocol / ProtoMessage . scala < nl > @ @ - 16 , 6 + 16 , 10 @ @ sealed trait IncomingProtoMessage < nl > < nl > sealed trait OutgoingProtoMessage < nl > < nl > + sealed trait ResendableProtoMessage { < nl > + def bodySize : Int < nl > + } < nl > + < nl > @ SerialVersionUID ( 1L ) < nl > case class MessageAck ( messageIds : Vector [ Long ] ) extends ProtoMessage { < nl > val header = MessageAck . header < nl > @ @ - 41 , 8 + 45 , 10 @ @ object Container { < nl > } < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - case class NewSession ( sessionId : Long , messageId : Long ) extends ProtoMessage with OutgoingProtoMessage { < nl > + case class NewSession ( sessionId : Long , messageId : Long ) extends ProtoMessage with OutgoingProtoMessage with ResendableProtoMessage { < nl > val header = NewSession . header < nl > + < nl > + override def bodySize = 0 < nl > } < nl > < nl > object NewSession { < nl > @ @ - 86 , 8 + 92 , 10 @ @ object RpcRequestBox { < nl > } < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - case class RpcResponseBox ( messageId : Long , bodyBytes : BitVector ) extends ProtoMessage with OutgoingProtoMessage { < nl > + case class RpcResponseBox ( messageId : Long , bodyBytes : BitVector ) extends ProtoMessage with OutgoingProtoMessage with ResendableProtoMessage { < nl > val header = RpcResponseBox . header < nl > + < nl > + override val bodySize = bodyBytes . bytes . size < nl > } < nl > < nl > object RpcResponseBox { < nl > @ @ - 113 , 8 + 121 , 10 @ @ object UnsentResponse { < nl > } < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - case class UpdateBox ( bodyBytes : BitVector ) extends ProtoMessage with OutgoingProtoMessage { < nl > + case class UpdateBox ( bodyBytes : BitVector ) extends ProtoMessage with OutgoingProtoMessage with ResendableProtoMessage { < nl > val header = UpdateBox . header < nl > + < nl > + override val bodySize = bodyBytes . bytes . size < nl > } < nl > < nl > object UpdateBox { < nl > diff - - git a / actor - session / src / main / resources / reference . conf b / actor - session / src / main / resources / reference . conf < nl > index 8b094ee . . b821051 100644 < nl > - - - a / actor - session / src / main / resources / reference . conf < nl > + + + b / actor - session / src / main / resources / reference . conf < nl > @ @ - 4 , 7 + 4 , 8 @ @ actor - server { < nl > < nl > resend { < nl > ack - timeout = 1 minute < nl > - max - size = 1 MiB < nl > + max - resend - size = 1 KiB < nl > + max - buffer - size = 1 MiB < nl > } < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > index beaa82e . . f120fe4 100644 < nl > - - - a / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > + + + b / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > @ @ - 21 , 12 + 21 , 13 @ @ object ReSenderMessage { < nl > case class NewClient ( client : ActorRef ) extends ReSenderMessage < nl > } < nl > < nl > - case class ReSenderConfig ( ackTimeout : FiniteDuration , maxSize : Long ) < nl > + case class ReSenderConfig ( ackTimeout : FiniteDuration , maxResendSize : Long , maxBufferSize : Long ) < nl > object ReSenderConfig { < nl > def fromConfig ( config : Config ) : ReSenderConfig = { < nl > ReSenderConfig ( < nl > ackTimeout = config . getDuration ( " ack - timeout " , TimeUnit . SECONDS ) . seconds , < nl > - maxSize = config . getBytes ( " max - size " ) < nl > + maxResendSize = config . getBytes ( " max - resend - size " ) , < nl > + maxBufferSize = config . getBytes ( " max - buffer - size " ) < nl > ) < nl > } < nl > } < nl > @ @ - 45 , 7 + 46 , 8 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long ) ( implicit config : < nl > < nl > / / TODO : configurable < nl > private val AckTimeout = config . ackTimeout < nl > - private val MaxResendSize = config . maxSize < nl > + private val MaxBufferSize = config . maxBufferSize < nl > + private val MaxResendSize = config . maxResendSize < nl > < nl > implicit val ec : ExecutionContext = context . dispatcher < nl > < nl > @ @ - 71 , 16 + 73 , 16 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long ) ( implicit config : < nl > log . error ( " Unmatched msg { } " , unmatched ) < nl > } < nl > < nl > - private [ this ] var resendBuffer = immutable . Map . empty [ Long , ( ProtoMessage , Cancellable ) ] < nl > + private [ this ] var resendBufferSize = 0L < nl > + private [ this ] var resendBuffer = immutable . Map . empty [ Long , ( ProtoMessage with ResendableProtoMessage , Cancellable ) ] < nl > < nl > / / Subscriber - related < nl > < nl > def subscriber : Receive = { < nl > case OnNext ( msg : MessageAck with IncomingProtoMessage ) ⇒ < nl > resendBuffer - - = msg . messageIds < nl > - case OnNext ( msg : NewSession ) ⇒ enqueueProtoMessage ( msg ) < nl > - case OnNext ( msg : MessageAck with OutgoingProtoMessage ) ⇒ enqueueProtoMessage ( msg ) < nl > - case OnNext ( msg : ProtoMessage with OutgoingProtoMessage ) ⇒ enqueueProtoMessageWithResend ( nextMessageId ( ) , msg ) < nl > + case OnNext ( msg : ProtoMessage with OutgoingProtoMessage with ResendableProtoMessage ) ⇒ enqueueProtoMessageWithResend ( msg ) < nl > + case OnNext ( msg : ProtoMessage with OutgoingProtoMessage ) ⇒ enqueueProtoMessage ( msg ) < nl > case OnNext ( RequestResend ( messageId ) ) ⇒ < nl > resendBuffer . get ( messageId ) map { < nl > case ( msg , scheduledResend ) ⇒ < nl > @ @ - 93 , 26 + 95 , 26 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long ) ( implicit config : < nl > resendBuffer . get ( messageId ) map { < nl > case ( msg , _ ) ⇒ < nl > msg match { < nl > - case RpcResponseBox ( requestMessageId , bodyBytes ) ⇒ < nl > + case rspBox @ RpcResponseBox ( requestMessageId , bodyBytes ) ⇒ < nl > val bodySize = bodyBytes . bytes . size < nl > < nl > if ( bodySize < = MaxResendSize ) { < nl > - enqueueProtoMessageWithResend ( messageId , msg ) < nl > + enqueueProtoMessageWithResend ( messageId , rspBox ) < nl > } else { < nl > - scheduleResend ( messageId , msg ) < nl > + scheduleResend ( messageId , rspBox ) < nl > enqueueProtoMessage ( nextMessageId ( ) , UnsentResponse ( messageId , requestMessageId , bodySize ) ) < nl > } < nl > - case UpdateBox ( bodyBytes ) ⇒ < nl > + case ub @ UpdateBox ( bodyBytes ) ⇒ < nl > val bodySize = bodyBytes . bytes . size < nl > < nl > if ( bodySize < = MaxResendSize ) { < nl > - enqueueProtoMessageWithResend ( messageId , msg ) < nl > + enqueueProtoMessageWithResend ( messageId , ub ) < nl > } else { < nl > - scheduleResend ( messageId , msg ) < nl > + scheduleResend ( messageId , ub ) < nl > enqueueProtoMessage ( nextMessageId ( ) , UnsentMessage ( messageId , bodySize ) ) < nl > } < nl > - case wrong ⇒ / / should never happen because we don ' t resend other message types < nl > - log . error ( " Scheduled wrong message resend : { } " , wrong ) < nl > + case msg ⇒ < nl > + enqueueProtoMessageWithResend ( messageId , msg ) < nl > } < nl > } < nl > } < nl > @ @ - 132 , 15 + 134 , 28 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long ) ( implicit config : < nl > context . stop ( self ) < nl > } < nl > < nl > - private def enqueueProtoMessageWithResend ( messageId : Long , message : ProtoMessage ) : Unit = { < nl > + private def enqueueProtoMessageWithResend ( message : ProtoMessage with ResendableProtoMessage ) : Unit = { < nl > + enqueueProtoMessageWithResend ( nextMessageId ( ) , message ) < nl > + } < nl > + < nl > + private def enqueueProtoMessageWithResend ( messageId : Long , message : ProtoMessage with ResendableProtoMessage ) : Unit = { < nl > scheduleResend ( messageId , message ) < nl > enqueueProtoMessage ( messageId , message ) < nl > } < nl > < nl > - private def scheduleResend ( messageId : Long , message : ProtoMessage ) : Unit = { < nl > + private def scheduleResend ( messageId : Long , message : ProtoMessage with ResendableProtoMessage ) : Unit = { < nl > log . debug ( " Scheduling resend of messageId : { } , timeout : { } " , messageId , AckTimeout ) < nl > - val scheduledResend = context . system . scheduler . scheduleOnce ( AckTimeout , self , ScheduledResend ( messageId ) ) < nl > - resendBuffer = resendBuffer . updated ( messageId , ( message , scheduledResend ) ) < nl > + < nl > + resendBufferSize + = message . bodySize < nl > + < nl > + if ( resendBufferSize < = MaxBufferSize ) { < nl > + val scheduledResend = context . system . scheduler . scheduleOnce ( AckTimeout , self , ScheduledResend ( messageId ) ) < nl > + resendBuffer = resendBuffer . updated ( messageId , ( message , scheduledResend ) ) < nl > + } else { < nl > + val msg = " Completing stream due to maximum buffer size reached " < nl > + log . warning ( msg ) < nl > + onErrorThenStop ( new Exception ( msg ) ) < nl > + } < nl > } < nl > < nl > private def enqueueProtoMessage ( message : ProtoMessage ) : ( MTPackage , Long ) = < nl > diff - - git a / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > index 9dbc3e0 . . 765f2e2 100644 < nl > - - - a / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > + + + b / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > @ @ - 27 , 6 + 27 , 7 @ @ import im . actor . server . push . { SeqUpdatesManagerRegion , WeakUpdatesManagerRegion < nl > import im . actor . server . { models , persist } < nl > < nl > case class SessionConfig ( idleTimeout : Duration , reSendConfig : ReSenderConfig ) < nl > + < nl > object SessionConfig { < nl > def fromConfig ( config : Config ) : SessionConfig = { < nl > SessionConfig ( < nl > @ @ - 160 , 9 + 161 , 15 @ @ class Session ( rpcApiService : ActorRef ) ( < nl > < nl > val source = b . add ( Source ( ActorPublisher [ SessionStreamMessage ] ( sessionMessagePublisher ) ) ) < nl > val sink = b . add ( Sink . foreach [ MTPackage ] ( m ⇒ clients foreach ( _ ! m ) ) ) < nl > + val bcast = b . add ( Broadcast [ MTPackage ] ( 2 ) ) < nl > + < nl > + / / format : OFF < nl > + < nl > + source ~ > g . inlet < nl > + g . outlet ~ > bcast ~ > sink < nl > + bcast ~ > Sink . onComplete { _ ⇒ log . warning ( " Dying due to stream completion " ) ; self ! PoisonPill } < nl > < nl > - source ~ > g . inlet < nl > - g . outlet ~ > sink < nl > + / / format : ON < nl > } < nl > < nl > flow . run ( ) < nl > diff - - git a / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala b / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala < nl > index 072aee3 . . 5530ea8 100644 < nl > - - - a / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala < nl > + + + b / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala < nl > @ @ - 14 , 6 + 14 , 7 @ @ class SessionMessageDiscriminatorShape ( _ init : Init [ SessionStreamMessage ] = Name [ < nl > val outProtoMessage = newOutlet [ ProtoMessage ] ( " outProtoMessage " ) < nl > val outRpc = newOutlet [ HandleRpcRequest ] ( " outRpc " ) < nl > val outSubscribe = newOutlet [ SubscribeCommand ] ( " outSubscribe " ) < nl > + val outRequestResend = newOutlet [ ProtoMessage ] ( " outRequestResend " ) < nl > val outIncomingAck = newOutlet [ ProtoMessage ] ( " outIncomingAck " ) < nl > val outUnmatched = newOutlet [ SessionStreamMessage ] ( " outUnmatched " ) < nl > < nl > @ @ - 44 , 6 + 45 , 8 @ @ class SessionMessageDiscriminator extends FlexiRoute [ SessionStreamMessage , Sessi < nl > ctx . emit ( p . outRpc ) ( HandleRpcRequest ( messageId , bodyBytes , clientData ) ) < nl > case HandleMessageBox ( MessageBox ( messageId , m : MessageAck ) , clientData ) ⇒ < nl > ctx . emit ( p . outIncomingAck ) ( MessageAck . incoming ( m . messageIds ) ) < nl > + case HandleMessageBox ( MessageBox ( messageId , m : RequestResend ) , _ ) ⇒ < nl > + ctx . emit ( p . outRequestResend ) ( m ) < nl > case SendProtoMessage ( message ) ⇒ < nl > ctx . emit ( p . outProtoMessage ) ( message ) < nl > case msg @ HandleSubscribe ( command ) ⇒ < nl > diff - - git a / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > index 50eafd8 . . a865760 100644 < nl > - - - a / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > + + + b / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > @ @ - 49 , 8 + 49 , 9 @ @ private [ session ] object SessionStream { < nl > val rpc = discr . outRpc . buffer ( 100 , OverflowStrategy . backpressure ) < nl > val subscribe = discr . outSubscribe . buffer ( 100 , OverflowStrategy . backpressure ) < nl > val incomingAck = discr . outIncomingAck . buffer ( 100 , OverflowStrategy . backpressure ) < nl > - val unmatched = discr . outUnmatched . buffer ( 100 , OverflowStrategy . backpressure ) < nl > val outProtoMessages = discr . outProtoMessage . buffer ( 100 , OverflowStrategy . backpressure ) < nl > + val outRequestResend = discr . outRequestResend . buffer ( 100 , OverflowStrategy . backpressure ) < nl > + val unmatched = discr . outUnmatched . buffer ( 100 , OverflowStrategy . backpressure ) < nl > < nl > val rpcRequestSubscriber = builder . add ( Sink ( ActorSubscriber [ HandleRpcRequest ] ( rpcHandler ) ) ) < nl > val rpcResponsePublisher = builder . add ( Source ( ActorPublisher [ ProtoMessage ] ( rpcHandler ) ) ) < nl > @ @ - 61 , 7 + 62 , 7 @ @ private [ session ] object SessionStream { < nl > val reSendSubscriber = builder . add ( Sink ( ActorSubscriber [ ProtoMessage ] ( reSender ) ) ) < nl > val reSendPublisher = builder . add ( Source ( ActorPublisher [ MTPackage ] ( reSender ) ) ) < nl > < nl > - val mergeProto = builder . add ( MergePreferred [ ProtoMessage ] ( 3 ) ) < nl > + val mergeProto = builder . add ( MergePreferred [ ProtoMessage ] ( 4 ) ) < nl > < nl > val logging = akka . event . Logging ( context . system , s " SessionStream - $ { authId } - $ { sessionId } " ) < nl > < nl > @ @ - 70 , 8 + 71 , 9 @ @ private [ session ] object SessionStream { < nl > / / @ format : OFF < nl > < nl > outProtoMessages ~ > mergeProto . preferred < nl > + outRequestResend ~ > mergeProto ~ > reSendSubscriber < nl > rpc ~ > rpcRequestSubscriber < nl > - rpcResponsePublisher ~ > mergeProto ~ > reSendSubscriber < nl > + rpcResponsePublisher ~ > mergeProto < nl > subscribe ~ > updatesSubscriber < nl > updatesPublisher ~ > mergeProto < nl > incomingAck ~ > mergeProto < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > index bdf6cdc . . cc1c8d7 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > @ @ - 91 , 6 + 91 , 14 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { ActorSpecification . creat < nl > } < nl > } < nl > < nl > + protected def expectMessageAck ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : MessageAck = { < nl > + val mb = expectMessageBox ( authId , sessionId ) < nl > + mb . body shouldBe a [ MessageAck ] < nl > + < nl > + val ack = mb . body . asInstanceOf [ MessageAck ] < nl > + ack < nl > + } < nl > + < nl > protected def expectMessageAck ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe ) : MessageAck = { < nl > val mb = expectMessageBox ( authId , sessionId ) < nl > mb . body shouldBe a [ MessageAck ] < nl > @ @ - 100 , 8 + 108 , 10 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { ActorSpecification . creat < nl > ack < nl > } < nl > < nl > - protected def expectNewSession ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe ) : NewSession = { < nl > + protected def expectNewSession ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : NewSession = { < nl > val mb = expectMessageBox ( authId , sessionId ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , MessageAck ( Vector ( mb . messageId ) ) ) < nl > + < nl > mb . body shouldBe a [ NewSession ] < nl > < nl > val ns = mb . body . asInstanceOf [ NewSession ] < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . acdadfe < nl > - - - / dev / null < nl > + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala < nl > @ @ - 0 , 0 + 1 , 87 @ @ < nl > + package im . actor . server . session < nl > + < nl > + import scala . concurrent . duration . _ < nl > + import scala . util . Random < nl > + < nl > + import akka . testkit . TestProbe < nl > + import com . typesafe . config . ConfigFactory < nl > + < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . auth . { RequestSendAuthCode , ResponseSendAuthCode } < nl > + import im . actor . api . rpc . codecs . RequestCodec < nl > + import im . actor . server . mtproto . protocol . { RequestResend , UnsentResponse , RpcRequestBox } < nl > + import im . actor . util . testing . ActorSpecification < nl > + < nl > + class SessionResendLargeSpec extends BaseSessionSpec ( < nl > + ActorSpecification . createSystem ( ConfigFactory . parseString ( < nl > + " " " < nl > + | session { < nl > + | resend { < nl > + | ack - timeout = 5 seconds < nl > + | max - resend - size = 0 KiB < nl > + | max - buffer - size = 1 KiB < nl > + | } < nl > + | } < nl > + " " " . stripMargin < nl > + ) ) < nl > + ) { < nl > + behavior of " Session ' s ReSender with max - resend - size set to 0 KiB " < nl > + < nl > + it should " resend UnsentResponse instead of the full response " in Sessions ( ) . e1 < nl > + it should " kill session on resend buffer overflow " in Sessions ( ) . e2 < nl > + < nl > + case class Sessions ( ) { < nl > + def e1 ( ) = { < nl > + implicit val probe = TestProbe ( ) < nl > + < nl > + val authId = createAuthId ( ) < nl > + val sessionId = Random . nextLong ( ) < nl > + val requestMessageId = Random . nextLong ( ) < nl > + < nl > + val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , requestMessageId , RpcRequestBox ( encodedRequest ) ) < nl > + < nl > + expectNewSession ( authId , sessionId , requestMessageId ) < nl > + expectMessageAck ( authId , sessionId , requestMessageId ) < nl > + < nl > + expectRpcResult ( sendAckAt = None ) should matchPattern { < nl > + case RpcOk ( ResponseSendAuthCode ( _ , _ ) ) ⇒ < nl > + } < nl > + < nl > + / / We didn ' t send Ack < nl > + Thread . sleep ( 5000 ) < nl > + < nl > + val messageBox = expectMessageBox ( authId , sessionId ) < nl > + messageBox . body should matchPattern { < nl > + case UnsentResponse ( _ , rqMessageId , length ) if rqMessageId = = requestMessageId & & length > 0 ⇒ < nl > + } < nl > + < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , RequestResend ( messageBox . body . asInstanceOf [ UnsentResponse ] . messageId ) ) < nl > + < nl > + expectMessageAck ( authId , sessionId ) < nl > + expectRpcResult ( sendAckAt = None ) should matchPattern { < nl > + case RpcOk ( ResponseSendAuthCode ( _ , _ ) ) ⇒ < nl > + } < nl > + < nl > + expectNoMsg ( 6 . seconds ) < nl > + } < nl > + < nl > + def e2 ( ) = { < nl > + val watchProbe = TestProbe ( ) < nl > + < nl > + val authId = createAuthId ( ) < nl > + val sessionId = Random . nextLong ( ) < nl > + val session = system . actorOf ( Session . props ( rpcApiService ) ) < nl > + watchProbe watch session < nl > + < nl > + val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require < nl > + < nl > + for ( _ ← 1 to 100 ) { < nl > + implicit val sendProbe = TestProbe ( ) < nl > + sendMessageBox ( authId , sessionId , session , Random . nextLong ( ) , RpcRequestBox ( encodedRequest ) ) < nl > + } < nl > + < nl > + watchProbe . expectTerminated ( session ) < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala < nl > index d097a60 . . e727f60 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala < nl > @ @ - 50 , 6 + 50 , 13 @ @ class SessionResendSpec extends BaseSessionSpec ( < nl > / / We didn ' t send Ack < nl > Thread . sleep ( 5000 ) < nl > < nl > + expectRpcResult ( sendAckAt = None ) should matchPattern { < nl > + case RpcOk ( ResponseSendAuthCode ( _ , _ ) ) ⇒ < nl > + } < nl > + < nl > + / / Still no ack < nl > + Thread . sleep ( 5000 ) < nl > + < nl > expectRpcResult ( ) should matchPattern { < nl > case RpcOk ( ResponseSendAuthCode ( _ , _ ) ) ⇒ < nl > } < nl > diff - - git a / project / Build . scala b / project / Build . scala < nl > index 59ff6c0 . . f1b2ce5 100644 < nl > - - - a / project / Build . scala < nl > + + + b / project / Build . scala < nl > @ @ - 29 , 6 + 29 , 19 @ @ object Build extends sbt . Build { < nl > " - Ywarn - unused - import " < nl > ) < nl > < nl > + lazy val defaultScalacOptions = Seq ( < nl > + " - target : jvm - 1 . 8 " , < nl > + " - encoding " , < nl > + " UTF - 8 " , < nl > + " - deprecation " , < nl > + " - unchecked " , < nl > + " - feature " , < nl > + " - language : higherKinds " , < nl > + " - Xfatal - warnings " , < nl > + " - Xlint " , < nl > + " - Xfuture " < nl > + ) + + compilerWarnings < nl > + < nl > lazy val defaultSettings = < nl > buildSettings + + Formatting . formatSettings + + < nl > Seq ( < nl > @ @ - 37 , 18 + 50 , 8 @ @ object Build extends sbt . Build { < nl > sys . error ( " Java 8 is required for this project . " ) < nl > } , < nl > resolvers + + = Resolvers . seq , < nl > - scalacOptions in Compile + + = Seq ( < nl > - " - target : jvm - 1 . 8 " , < nl > - " - encoding " , < nl > - " UTF - 8 " , < nl > - " - deprecation " , < nl > - " - unchecked " , < nl > - " - feature " , < nl > - " - language : higherKinds " , < nl > - " - Xfatal - warnings " , < nl > - " - Xlint " , < nl > - " - Xfuture " < nl > - ) + + compilerWarnings , < nl > + scalacOptions in Compile + + = defaultScalacOptions , < nl > + scalacOptions in ( Compile , console ) ~ = ( _ . filterNot ( _ = = " - Ywarn - unused - import " ) . filterNot ( _ = = " - Yfatal - warnings " ) ) , < nl > javaOptions + + = Seq ( " - Dfile . encoding = UTF - 8 " , " - Dscalac . patmat . analysisBudget = off " ) , < nl > javacOptions + + = Seq ( " - source " , " 1 . 8 " , " - target " , " 1 . 8 " , " - Xlint : unchecked " , " - Xlint : deprecation " ) < nl > ) < nl > @ @ - 73 , 7 + 76 , 7 @ @ object Build extends sbt . Build { < nl > " - groups " , < nl > " - implicits " , < nl > " - diagrams " < nl > - ) + + compilerWarnings < nl > + ) < nl > ) < nl > ) . settings ( net . virtualvoid . sbt . graph . Plugin . graphSettings : _ * ) < nl > . dependsOn ( actorFrontend )

TEST DIFF:
diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala 
 deleted file mode 100644 
 index 77417f2 . . 0000000 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala 
 + + + / dev / null 
 @ @ - 1 , 100 + 0 , 0 @ @ 
 - package im . actor . server . session 
 - 
 - import akka . testkit . TestProbe 
 - import com . typesafe . config . ConfigFactory 
 - import im . actor . api . rpc . _ 
 - import im . actor . api . rpc . auth . { RequestStartPhoneAuth , ResponseStartPhoneAuth } 
 - import im . actor . api . rpc . codecs . RequestCodec 
 - import im . actor . server . ActorSpecification 
 - import im . actor . server . mtproto . protocol . _ 
 - 
 - import scala . concurrent . duration . _ 
 - import scala . util . Random 
 - 
 - final class SessionResendLargeSpec extends BaseSessionSpec ( 
 - ActorSpecification . createSystem ( ConfigFactory . parseString ( 
 - " " " 
 - | session { 
 - | resend { 
 - | ack - timeout = 5 seconds 
 - | max - resend - size = 1 KiB 
 - | max - buffer - size = 1 KiB 
 - | } 
 - | } 
 - " " " . stripMargin 
 - ) ) 
 - ) { 
 - behavior of " Session ' s ReSender with max - resend - size set to 0 KiB " 
 - 
 - it should " resend UnsentResponse instead of the full response " in Sessions ( ) . e1 
 - it should " kill session on resend buffer overflow " in Sessions ( ) . e2 
 - 
 - case class Sessions ( ) { 
 - def e1 ( ) = { 
 - implicit val probe = TestProbe ( ) 
 - 
 - val authId = createAuthId ( ) 
 - val sessionId = Random . nextLong ( ) 
 - val requestMessageId = Random . nextLong ( ) 
 - 
 - val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( 
 - phoneNumber = 75553333333L , 
 - appId = 1 , 
 - apiKey = " apiKey " , 
 - deviceHash = Random . nextLong . toBinaryString . getBytes , 
 - deviceTitle = " Specs Has You " , 
 - timeZone = None , 
 - preferredLanguages = Vector . empty 
 - ) ) ) . require 
 - sendMessageBox ( authId , sessionId , sessionRegion . ref , requestMessageId , ProtoRpcRequest ( encodedRequest ) ) 
 - 
 - expectNewSession ( authId , sessionId , requestMessageId ) 
 - 
 - expectRpcResult ( authId , sessionId , sendAckAt = None ) should matchPattern { 
 - case RpcOk ( _ : ResponseStartPhoneAuth ) ⇒ 
 - } 
 - 
 - / / We didn ' t send Ack 
 - Thread . sleep ( 5000 ) 
 - 
 - val messageBox = expectMessageBox ( ) 
 - messageBox . body should matchPattern { 
 - case UnsentResponse ( _ , rqMessageId , length ) if rqMessageId = = requestMessageId & & length > 0 ⇒ 
 - } 
 - 
 - val msgId = Random . nextLong ( ) 
 - sendMessageBox ( authId , sessionId , sessionRegion . ref , msgId , RequestResend ( messageBox . body . asInstanceOf [ UnsentResponse ] . messageId ) ) 
 - 
 - expectRpcResult ( authId , sessionId , sendAckAt = None , expectAckFor = Set ( msgId ) ) should matchPattern { 
 - case RpcOk ( _ : ResponseStartPhoneAuth ) ⇒ 
 - } 
 - 
 - expectNoMsg ( 6 . seconds ) 
 - } 
 - 
 - def e2 ( ) = { 
 - val watchProbe = TestProbe ( ) 
 - 
 - val authId = createAuthId ( ) 
 - val sessionId = Random . nextLong ( ) 
 - val session = system . actorOf ( Session . props , s " $ { authId } _ $ sessionId " ) 
 - watchProbe watch session 
 - 
 - val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( 
 - phoneNumber = 75553333333L , 
 - appId = 1 , 
 - apiKey = " apiKey " , 
 - deviceHash = Random . nextLong . toBinaryString . getBytes , 
 - deviceTitle = " Specs Has You " , 
 - timeZone = None , 
 - preferredLanguages = Vector . empty 
 - ) ) ) . require 
 - 
 - for ( _ ← 1 to 100 ) 
 - TestProbe ( ) . send ( session , handleMessageBox ( Random . nextLong ( ) , ProtoRpcRequest ( encodedRequest ) ) ) 
 - 
 - watchProbe . expectTerminated ( session ) 
 - } 
 - } 
 - 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendOverflowSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendOverflowSpec . scala 
 new file mode 100644 
 index 0000000 . . 569e4cf 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendOverflowSpec . scala 
 @ @ - 0 , 0 + 1 , 55 @ @ 
 + package im . actor . server . session 
 + 
 + import akka . testkit . TestProbe 
 + import com . typesafe . config . ConfigFactory 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . auth . { RequestStartPhoneAuth , ResponseStartPhoneAuth } 
 + import im . actor . api . rpc . codecs . RequestCodec 
 + import im . actor . server . ActorSpecification 
 + import im . actor . server . mtproto . protocol . _ 
 + 
 + import scala . concurrent . duration . _ 
 + import scala . util . Random 
 + 
 + final class SessionResendOverflowSpec extends BaseSessionSpec ( 
 + ActorSpecification . createSystem ( ConfigFactory . parseString ( 
 + " " " 
 + | session { 
 + | resend { 
 + | max - buffer - size = 100 
 + | } 
 + | } 
 + " " " . stripMargin 
 + ) ) 
 + ) { 
 + behavior of " Session ' s ReSender with max - buffer - size set to 100 KiB " 
 + 
 + it should " kill session on resend buffer overflow " in Sessions ( ) . e1 
 + 
 + case class Sessions ( ) { 
 + def e1 ( ) = { 
 + val watchProbe = TestProbe ( ) 
 + 
 + val authId = createAuthId ( ) 
 + val sessionId = Random . nextLong ( ) 
 + val session = system . actorOf ( Session . props , s " $ { authId } _ $ sessionId " ) 
 + watchProbe watch session 
 + 
 + val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( 
 + phoneNumber = 75553333333L , 
 + appId = 1 , 
 + apiKey = " apiKey " , 
 + deviceHash = Random . nextLong . toBinaryString . getBytes , 
 + deviceTitle = " Spec Has You " , 
 + timeZone = None , 
 + preferredLanguages = Vector . empty 
 + ) ) ) . require 
 + 
 + TestProbe ( ) . send ( session , handleMessageBox ( Random . nextLong ( ) , ProtoRpcRequest ( encodedRequest ) ) ) 
 + TestProbe ( ) . send ( session , handleMessageBox ( Random . nextLong ( ) , ProtoRpcRequest ( encodedRequest ) ) ) 
 + 
 + watchProbe . expectTerminated ( session ) 
 + } 
 + } 
 + 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionUnsentSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionUnsentSpec . scala 
 new file mode 100644 
 index 0000000 . . 5ac8ff1 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionUnsentSpec . scala 
 @ @ - 0 , 0 + 1 , 98 @ @ 
 + package im . actor . server . session 
 + 
 + import akka . testkit . TestProbe 
 + import com . typesafe . config . ConfigFactory 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . auth . { RequestStartPhoneAuth , ResponseStartPhoneAuth } 
 + import im . actor . api . rpc . codecs . RequestCodec 
 + import im . actor . server . ActorSpecification 
 + import im . actor . server . mtproto . protocol . _ 
 + 
 + import scala . concurrent . duration . _ 
 + import scala . util . Random 
 + 
 + final class SessionUnsentSpec extends BaseSessionSpec ( 
 + ActorSpecification . createSystem ( ConfigFactory . parseString ( 
 + " " " 
 + | session { 
 + | resend { 
 + | ack - timeout = 5 seconds 
 + | max - resend - size = 0 
 + | } 
 + | } 
 + " " " . stripMargin 
 + ) ) 
 + ) { 
 + behavior of " Session ' s ReSender with max - resend - size set to 0 KiB " 
 + 
 + it should " resend UnsentResponse instead of the full response " in Sessions ( ) . e1 
 + 
 + case class Sessions ( ) { 
 + def e1 ( ) = { 
 + implicit val probe = TestProbe ( ) 
 + 
 + val authId = createAuthId ( ) 
 + val sessionId = Random . nextLong ( ) 
 + val requestMessageId = Random . nextLong ( ) 
 + 
 + val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( 
 + phoneNumber = 75553333333L , 
 + appId = 1 , 
 + apiKey = " apiKey " , 
 + deviceHash = Random . nextLong . toBinaryString . getBytes , 
 + deviceTitle = " Spec Has You " , 
 + timeZone = None , 
 + preferredLanguages = Vector . empty 
 + ) ) ) . require 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , requestMessageId , ProtoRpcRequest ( encodedRequest ) ) 
 + 
 + expectNewSession ( authId , sessionId , requestMessageId ) 
 + 
 + expectRpcResult ( authId , sessionId , sendAckAt = None ) should matchPattern { 
 + case RpcOk ( _ : ResponseStartPhoneAuth ) ⇒ 
 + } 
 + 
 + / / We didn ' t send Ack 
 + Thread . sleep ( 5000 ) 
 + 
 + val messageBox = expectMessageBox ( ) 
 + messageBox . body should matchPattern { 
 + case UnsentResponse ( _ , rqMessageId , length ) if rqMessageId = = requestMessageId & & length > 0 ⇒ 
 + } 
 + 
 + val msgId = Random . nextLong ( ) 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , msgId , RequestResend ( messageBox . body . asInstanceOf [ UnsentResponse ] . messageId ) ) 
 + 
 + expectRpcResult ( authId , sessionId , sendAckAt = None , expectAckFor = Set ( msgId ) ) should matchPattern { 
 + case RpcOk ( _ : ResponseStartPhoneAuth ) ⇒ 
 + } 
 + 
 + expectNoMsg ( 6 . seconds ) 
 + } 
 + 
 + def e2 ( ) = { 
 + val watchProbe = TestProbe ( ) 
 + 
 + val authId = createAuthId ( ) 
 + val sessionId = Random . nextLong ( ) 
 + val session = system . actorOf ( Session . props , s " $ { authId } _ $ sessionId " ) 
 + watchProbe watch session 
 + 
 + val encodedRequest = RequestCodec . encode ( Request ( RequestStartPhoneAuth ( 
 + phoneNumber = 75553333333L , 
 + appId = 1 , 
 + apiKey = " apiKey " , 
 + deviceHash = Random . nextLong . toBinaryString . getBytes , 
 + deviceTitle = " Specs Has You " , 
 + timeZone = None , 
 + preferredLanguages = Vector . empty 
 + ) ) ) . require 
 + 
 + for ( _ ← 1 to 100 ) 
 + TestProbe ( ) . send ( session , handleMessageBox ( Random . nextLong ( ) , ProtoRpcRequest ( encodedRequest ) ) ) 
 + 
 + watchProbe . expectTerminated ( session ) 
 + } 
 + } 
 + 
 + } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - models / src / main / scala / im / actor / server / mtproto / protocol / ProtoMessage . scala b / actor - models / src / main / scala / im / actor / server / mtproto / protocol / ProtoMessage . scala 
 index 16e414c . . 52dec71 100644 
 - - - a / actor - models / src / main / scala / im / actor / server / mtproto / protocol / ProtoMessage . scala 
 + + + b / actor - models / src / main / scala / im / actor / server / mtproto / protocol / ProtoMessage . scala 
 @ @ - 16 , 6 + 16 , 10 @ @ sealed trait IncomingProtoMessage 
 
 sealed trait OutgoingProtoMessage 
 
 + sealed trait ResendableProtoMessage { 
 + def bodySize : Int 
 + } 
 + 
 @ SerialVersionUID ( 1L ) 
 case class MessageAck ( messageIds : Vector [ Long ] ) extends ProtoMessage { 
 val header = MessageAck . header 
 @ @ - 41 , 8 + 45 , 10 @ @ object Container { 
 } 
 
 @ SerialVersionUID ( 1L ) 
 - case class NewSession ( sessionId : Long , messageId : Long ) extends ProtoMessage with OutgoingProtoMessage { 
 + case class NewSession ( sessionId : Long , messageId : Long ) extends ProtoMessage with OutgoingProtoMessage with ResendableProtoMessage { 
 val header = NewSession . header 
 + 
 + override def bodySize = 0 
 } 
 
 object NewSession { 
 @ @ - 86 , 8 + 92 , 10 @ @ object RpcRequestBox { 
 } 
 
 @ SerialVersionUID ( 1L ) 
 - case class RpcResponseBox ( messageId : Long , bodyBytes : BitVector ) extends ProtoMessage with OutgoingProtoMessage { 
 + case class RpcResponseBox ( messageId : Long , bodyBytes : BitVector ) extends ProtoMessage with OutgoingProtoMessage with ResendableProtoMessage { 
 val header = RpcResponseBox . header 
 + 
 + override val bodySize = bodyBytes . bytes . size 
 } 
 
 object RpcResponseBox { 
 @ @ - 113 , 8 + 121 , 10 @ @ object UnsentResponse { 
 } 
 
 @ SerialVersionUID ( 1L ) 
 - case class UpdateBox ( bodyBytes : BitVector ) extends ProtoMessage with OutgoingProtoMessage { 
 + case class UpdateBox ( bodyBytes : BitVector ) extends ProtoMessage with OutgoingProtoMessage with ResendableProtoMessage { 
 val header = UpdateBox . header 
 + 
 + override val bodySize = bodyBytes . bytes . size 
 } 
 
 object UpdateBox { 
 diff - - git a / actor - session / src / main / resources / reference . conf b / actor - session / src / main / resources / reference . conf 
 index 8b094ee . . b821051 100644 
 - - - a / actor - session / src / main / resources / reference . conf 
 + + + b / actor - session / src / main / resources / reference . conf 
 @ @ - 4 , 7 + 4 , 8 @ @ actor - server { 
 
 resend { 
 ack - timeout = 1 minute 
 - max - size = 1 MiB 
 + max - resend - size = 1 KiB 
 + max - buffer - size = 1 MiB 
 } 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 index beaa82e . . f120fe4 100644 
 - - - a / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 + + + b / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 @ @ - 21 , 12 + 21 , 13 @ @ object ReSenderMessage { 
 case class NewClient ( client : ActorRef ) extends ReSenderMessage 
 } 
 
 - case class ReSenderConfig ( ackTimeout : FiniteDuration , maxSize : Long ) 
 + case class ReSenderConfig ( ackTimeout : FiniteDuration , maxResendSize : Long , maxBufferSize : Long ) 
 object ReSenderConfig { 
 def fromConfig ( config : Config ) : ReSenderConfig = { 
 ReSenderConfig ( 
 ackTimeout = config . getDuration ( " ack - timeout " , TimeUnit . SECONDS ) . seconds , 
 - maxSize = config . getBytes ( " max - size " ) 
 + maxResendSize = config . getBytes ( " max - resend - size " ) , 
 + maxBufferSize = config . getBytes ( " max - buffer - size " ) 
 ) 
 } 
 } 
 @ @ - 45 , 7 + 46 , 8 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long ) ( implicit config : 
 
 / / TODO : configurable 
 private val AckTimeout = config . ackTimeout 
 - private val MaxResendSize = config . maxSize 
 + private val MaxBufferSize = config . maxBufferSize 
 + private val MaxResendSize = config . maxResendSize 
 
 implicit val ec : ExecutionContext = context . dispatcher 
 
 @ @ - 71 , 16 + 73 , 16 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long ) ( implicit config : 
 log . error ( " Unmatched msg { } " , unmatched ) 
 } 
 
 - private [ this ] var resendBuffer = immutable . Map . empty [ Long , ( ProtoMessage , Cancellable ) ] 
 + private [ this ] var resendBufferSize = 0L 
 + private [ this ] var resendBuffer = immutable . Map . empty [ Long , ( ProtoMessage with ResendableProtoMessage , Cancellable ) ] 
 
 / / Subscriber - related 
 
 def subscriber : Receive = { 
 case OnNext ( msg : MessageAck with IncomingProtoMessage ) ⇒ 
 resendBuffer - - = msg . messageIds 
 - case OnNext ( msg : NewSession ) ⇒ enqueueProtoMessage ( msg ) 
 - case OnNext ( msg : MessageAck with OutgoingProtoMessage ) ⇒ enqueueProtoMessage ( msg ) 
 - case OnNext ( msg : ProtoMessage with OutgoingProtoMessage ) ⇒ enqueueProtoMessageWithResend ( nextMessageId ( ) , msg ) 
 + case OnNext ( msg : ProtoMessage with OutgoingProtoMessage with ResendableProtoMessage ) ⇒ enqueueProtoMessageWithResend ( msg ) 
 + case OnNext ( msg : ProtoMessage with OutgoingProtoMessage ) ⇒ enqueueProtoMessage ( msg ) 
 case OnNext ( RequestResend ( messageId ) ) ⇒ 
 resendBuffer . get ( messageId ) map { 
 case ( msg , scheduledResend ) ⇒ 
 @ @ - 93 , 26 + 95 , 26 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long ) ( implicit config : 
 resendBuffer . get ( messageId ) map { 
 case ( msg , _ ) ⇒ 
 msg match { 
 - case RpcResponseBox ( requestMessageId , bodyBytes ) ⇒ 
 + case rspBox @ RpcResponseBox ( requestMessageId , bodyBytes ) ⇒ 
 val bodySize = bodyBytes . bytes . size 
 
 if ( bodySize < = MaxResendSize ) { 
 - enqueueProtoMessageWithResend ( messageId , msg ) 
 + enqueueProtoMessageWithResend ( messageId , rspBox ) 
 } else { 
 - scheduleResend ( messageId , msg ) 
 + scheduleResend ( messageId , rspBox ) 
 enqueueProtoMessage ( nextMessageId ( ) , UnsentResponse ( messageId , requestMessageId , bodySize ) ) 
 } 
 - case UpdateBox ( bodyBytes ) ⇒ 
 + case ub @ UpdateBox ( bodyBytes ) ⇒ 
 val bodySize = bodyBytes . bytes . size 
 
 if ( bodySize < = MaxResendSize ) { 
 - enqueueProtoMessageWithResend ( messageId , msg ) 
 + enqueueProtoMessageWithResend ( messageId , ub ) 
 } else { 
 - scheduleResend ( messageId , msg ) 
 + scheduleResend ( messageId , ub ) 
 enqueueProtoMessage ( nextMessageId ( ) , UnsentMessage ( messageId , bodySize ) ) 
 } 
 - case wrong ⇒ / / should never happen because we don ' t resend other message types 
 - log . error ( " Scheduled wrong message resend : { } " , wrong ) 
 + case msg ⇒ 
 + enqueueProtoMessageWithResend ( messageId , msg ) 
 } 
 } 
 } 
 @ @ - 132 , 15 + 134 , 28 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long ) ( implicit config : 
 context . stop ( self ) 
 } 
 
 - private def enqueueProtoMessageWithResend ( messageId : Long , message : ProtoMessage ) : Unit = { 
 + private def enqueueProtoMessageWithResend ( message : ProtoMessage with ResendableProtoMessage ) : Unit = { 
 + enqueueProtoMessageWithResend ( nextMessageId ( ) , message ) 
 + } 
 + 
 + private def enqueueProtoMessageWithResend ( messageId : Long , message : ProtoMessage with ResendableProtoMessage ) : Unit = { 
 scheduleResend ( messageId , message ) 
 enqueueProtoMessage ( messageId , message ) 
 } 
 
 - private def scheduleResend ( messageId : Long , message : ProtoMessage ) : Unit = { 
 + private def scheduleResend ( messageId : Long , message : ProtoMessage with ResendableProtoMessage ) : Unit = { 
 log . debug ( " Scheduling resend of messageId : { } , timeout : { } " , messageId , AckTimeout ) 
 - val scheduledResend = context . system . scheduler . scheduleOnce ( AckTimeout , self , ScheduledResend ( messageId ) ) 
 - resendBuffer = resendBuffer . updated ( messageId , ( message , scheduledResend ) ) 
 + 
 + resendBufferSize + = message . bodySize 
 + 
 + if ( resendBufferSize < = MaxBufferSize ) { 
 + val scheduledResend = context . system . scheduler . scheduleOnce ( AckTimeout , self , ScheduledResend ( messageId ) ) 
 + resendBuffer = resendBuffer . updated ( messageId , ( message , scheduledResend ) ) 
 + } else { 
 + val msg = " Completing stream due to maximum buffer size reached " 
 + log . warning ( msg ) 
 + onErrorThenStop ( new Exception ( msg ) ) 
 + } 
 } 
 
 private def enqueueProtoMessage ( message : ProtoMessage ) : ( MTPackage , Long ) = 
 diff - - git a / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 index 9dbc3e0 . . 765f2e2 100644 
 - - - a / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 + + + b / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 @ @ - 27 , 6 + 27 , 7 @ @ import im . actor . server . push . { SeqUpdatesManagerRegion , WeakUpdatesManagerRegion 
 import im . actor . server . { models , persist } 
 
 case class SessionConfig ( idleTimeout : Duration , reSendConfig : ReSenderConfig ) 
 + 
 object SessionConfig { 
 def fromConfig ( config : Config ) : SessionConfig = { 
 SessionConfig ( 
 @ @ - 160 , 9 + 161 , 15 @ @ class Session ( rpcApiService : ActorRef ) ( 
 
 val source = b . add ( Source ( ActorPublisher [ SessionStreamMessage ] ( sessionMessagePublisher ) ) ) 
 val sink = b . add ( Sink . foreach [ MTPackage ] ( m ⇒ clients foreach ( _ ! m ) ) ) 
 + val bcast = b . add ( Broadcast [ MTPackage ] ( 2 ) ) 
 + 
 + / / format : OFF 
 + 
 + source ~ > g . inlet 
 + g . outlet ~ > bcast ~ > sink 
 + bcast ~ > Sink . onComplete { _ ⇒ log . warning ( " Dying due to stream completion " ) ; self ! PoisonPill } 
 
 - source ~ > g . inlet 
 - g . outlet ~ > sink 
 + / / format : ON 
 } 
 
 flow . run ( ) 
 diff - - git a / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala b / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala 
 index 072aee3 . . 5530ea8 100644 
 - - - a / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala 
 + + + b / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala 
 @ @ - 14 , 6 + 14 , 7 @ @ class SessionMessageDiscriminatorShape ( _ init : Init [ SessionStreamMessage ] = Name [ 
 val outProtoMessage = newOutlet [ ProtoMessage ] ( " outProtoMessage " ) 
 val outRpc = newOutlet [ HandleRpcRequest ] ( " outRpc " ) 
 val outSubscribe = newOutlet [ SubscribeCommand ] ( " outSubscribe " ) 
 + val outRequestResend = newOutlet [ ProtoMessage ] ( " outRequestResend " ) 
 val outIncomingAck = newOutlet [ ProtoMessage ] ( " outIncomingAck " ) 
 val outUnmatched = newOutlet [ SessionStreamMessage ] ( " outUnmatched " ) 
 
 @ @ - 44 , 6 + 45 , 8 @ @ class SessionMessageDiscriminator extends FlexiRoute [ SessionStreamMessage , Sessi 
 ctx . emit ( p . outRpc ) ( HandleRpcRequest ( messageId , bodyBytes , clientData ) ) 
 case HandleMessageBox ( MessageBox ( messageId , m : MessageAck ) , clientData ) ⇒ 
 ctx . emit ( p . outIncomingAck ) ( MessageAck . incoming ( m . messageIds ) ) 
 + case HandleMessageBox ( MessageBox ( messageId , m : RequestResend ) , _ ) ⇒ 
 + ctx . emit ( p . outRequestResend ) ( m ) 
 case SendProtoMessage ( message ) ⇒ 
 ctx . emit ( p . outProtoMessage ) ( message ) 
 case msg @ HandleSubscribe ( command ) ⇒ 
 diff - - git a / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 index 50eafd8 . . a865760 100644 
 - - - a / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 + + + b / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 @ @ - 49 , 8 + 49 , 9 @ @ private [ session ] object SessionStream { 
 val rpc = discr . outRpc . buffer ( 100 , OverflowStrategy . backpressure ) 
 val subscribe = discr . outSubscribe . buffer ( 100 , OverflowStrategy . backpressure ) 
 val incomingAck = discr . outIncomingAck . buffer ( 100 , OverflowStrategy . backpressure ) 
 - val unmatched = discr . outUnmatched . buffer ( 100 , OverflowStrategy . backpressure ) 
 val outProtoMessages = discr . outProtoMessage . buffer ( 100 , OverflowStrategy . backpressure ) 
 + val outRequestResend = discr . outRequestResend . buffer ( 100 , OverflowStrategy . backpressure ) 
 + val unmatched = discr . outUnmatched . buffer ( 100 , OverflowStrategy . backpressure ) 
 
 val rpcRequestSubscriber = builder . add ( Sink ( ActorSubscriber [ HandleRpcRequest ] ( rpcHandler ) ) ) 
 val rpcResponsePublisher = builder . add ( Source ( ActorPublisher [ ProtoMessage ] ( rpcHandler ) ) ) 
 @ @ - 61 , 7 + 62 , 7 @ @ private [ session ] object SessionStream { 
 val reSendSubscriber = builder . add ( Sink ( ActorSubscriber [ ProtoMessage ] ( reSender ) ) ) 
 val reSendPublisher = builder . add ( Source ( ActorPublisher [ MTPackage ] ( reSender ) ) ) 
 
 - val mergeProto = builder . add ( MergePreferred [ ProtoMessage ] ( 3 ) ) 
 + val mergeProto = builder . add ( MergePreferred [ ProtoMessage ] ( 4 ) ) 
 
 val logging = akka . event . Logging ( context . system , s " SessionStream - $ { authId } - $ { sessionId } " ) 
 
 @ @ - 70 , 8 + 71 , 9 @ @ private [ session ] object SessionStream { 
 / / @ format : OFF 
 
 outProtoMessages ~ > mergeProto . preferred 
 + outRequestResend ~ > mergeProto ~ > reSendSubscriber 
 rpc ~ > rpcRequestSubscriber 
 - rpcResponsePublisher ~ > mergeProto ~ > reSendSubscriber 
 + rpcResponsePublisher ~ > mergeProto 
 subscribe ~ > updatesSubscriber 
 updatesPublisher ~ > mergeProto 
 incomingAck ~ > mergeProto 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 index bdf6cdc . . cc1c8d7 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 @ @ - 91 , 6 + 91 , 14 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { ActorSpecification . creat 
 } 
 } 
 
 + protected def expectMessageAck ( authId : Long , sessionId : Long ) ( implicit probe : TestProbe ) : MessageAck = { 
 + val mb = expectMessageBox ( authId , sessionId ) 
 + mb . body shouldBe a [ MessageAck ] 
 + 
 + val ack = mb . body . asInstanceOf [ MessageAck ] 
 + ack 
 + } 
 + 
 protected def expectMessageAck ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe ) : MessageAck = { 
 val mb = expectMessageBox ( authId , sessionId ) 
 mb . body shouldBe a [ MessageAck ] 
 @ @ - 100 , 8 + 108 , 10 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { ActorSpecification . creat 
 ack 
 } 
 
 - protected def expectNewSession ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe ) : NewSession = { 
 + protected def expectNewSession ( authId : Long , sessionId : Long , messageId : Long ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : NewSession = { 
 val mb = expectMessageBox ( authId , sessionId ) 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , MessageAck ( Vector ( mb . messageId ) ) ) 
 + 
 mb . body shouldBe a [ NewSession ] 
 
 val ns = mb . body . asInstanceOf [ NewSession ] 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala 
 new file mode 100644 
 index 0000000 . . acdadfe 
 - - - / dev / null 
 + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionResendLargeSpec . scala 
 @ @ - 0 , 0 + 1 , 87 @ @ 
 + package im . actor . server . session 
 + 
 + import scala . concurrent . duration . _ 
 + import scala . util . Random 
 + 
 + import akka . testkit . TestProbe 
 + import com . typesafe . config . ConfigFactory 
 + 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . auth . { RequestSendAuthCode , ResponseSendAuthCode } 
 + import im . actor . api . rpc . codecs . RequestCodec 
 + import im . actor . server . mtproto . protocol . { RequestResend , UnsentResponse , RpcRequestBox } 
 + import im . actor . util . testing . ActorSpecification 
 + 
 + class SessionResendLargeSpec extends BaseSessionSpec ( 
 + ActorSpecification . createSystem ( ConfigFactory . parseString ( 
 + " " " 
 + | session { 
 + | resend { 
 + | ack - timeout = 5 seconds 
 + | max - resend - size = 0 KiB 
 + | max - buffer - size = 1 KiB 
 + | } 
 + | } 
 + " " " . stripMargin 
 + ) ) 
 + ) { 
 + behavior of " Session ' s ReSender with max - resend - size set to 0 KiB " 
 + 
 + it should " resend UnsentResponse instead of the full response " in Sessions ( ) . e1 
 + it should " kill session on resend buffer overflow " in Sessions ( ) . e2 
 + 
 + case class Sessions ( ) { 
 + def e1 ( ) = { 
 + implicit val probe = TestProbe ( ) 
 + 
 + val authId = createAuthId ( ) 
 + val sessionId = Random . nextLong ( ) 
 + val requestMessageId = Random . nextLong ( ) 
 + 
 + val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , requestMessageId , RpcRequestBox ( encodedRequest ) ) 
 + 
 + expectNewSession ( authId , sessionId , requestMessageId ) 
 + expectMessageAck ( authId , sessionId , requestMessageId ) 
 + 
 + expectRpcResult ( sendAckAt = None ) should matchPattern { 
 + case RpcOk ( ResponseSendAuthCode ( _ , _ ) ) ⇒ 
 + } 
 + 
 + / / We didn ' t send Ack 
 + Thread . sleep ( 5000 ) 
 + 
 + val messageBox = expectMessageBox ( authId , sessionId ) 
 + messageBox . body should matchPattern { 
 + case UnsentResponse ( _ , rqMessageId , length ) if rqMessageId = = requestMessageId & & length > 0 ⇒ 
 + } 
 + 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , Random . nextLong ( ) , RequestResend ( messageBox . body . asInstanceOf [ UnsentResponse ] . messageId ) ) 
 + 
 + expectMessageAck ( authId , sessionId ) 
 + expectRpcResult ( sendAckAt = None ) should matchPattern { 
 + case RpcOk ( ResponseSendAuthCode ( _ , _ ) ) ⇒ 
 + } 
 + 
 + expectNoMsg ( 6 . seconds ) 
 + } 
 + 
 + def e2 ( ) = { 
 + val watchProbe = TestProbe ( ) 
 + 
 + val authId = createAuthId ( ) 
 + val sessionId = Random . nextLong ( ) 
 + val session = system . actorOf ( Session . props ( rpcApiService ) ) 
 + watchProbe watch session 
 + 
 + val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require 
 + 
 + for ( _ ← 1 to 100 ) { 
 + implicit val sendProbe = TestProbe ( ) 
 + sendMessageBox ( authId , sessionId , session , Random . nextLong ( ) , RpcRequestBox ( encodedRequest ) ) 
 + } 
 + 
 + watchProbe . expectTerminated ( session ) 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala 
 index d097a60 . . e727f60 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala 
 @ @ - 50 , 6 + 50 , 13 @ @ class SessionResendSpec extends BaseSessionSpec ( 
 / / We didn ' t send Ack 
 Thread . sleep ( 5000 ) 
 
 + expectRpcResult ( sendAckAt = None ) should matchPattern { 
 + case RpcOk ( ResponseSendAuthCode ( _ , _ ) ) ⇒ 
 + } 
 + 
 + / / Still no ack 
 + Thread . sleep ( 5000 ) 
 + 
 expectRpcResult ( ) should matchPattern { 
 case RpcOk ( ResponseSendAuthCode ( _ , _ ) ) ⇒ 
 } 
 diff - - git a / project / Build . scala b / project / Build . scala 
 index 59ff6c0 . . f1b2ce5 100644 
 - - - a / project / Build . scala 
 + + + b / project / Build . scala 
 @ @ - 29 , 6 + 29 , 19 @ @ object Build extends sbt . Build { 
 " - Ywarn - unused - import " 
 ) 
 
 + lazy val defaultScalacOptions = Seq ( 
 + " - target : jvm - 1 . 8 " , 
 + " - encoding " , 
 + " UTF - 8 " , 
 + " - deprecation " , 
 + " - unchecked " , 
 + " - feature " , 
 + " - language : higherKinds " , 
 + " - Xfatal - warnings " , 
 + " - Xlint " , 
 + " - Xfuture " 
 + ) + + compilerWarnings 
 + 
 lazy val defaultSettings = 
 buildSettings + + Formatting . formatSettings + + 
 Seq ( 
 @ @ - 37 , 18 + 50 , 8 @ @ object Build extends sbt . Build { 
 sys . error ( " Java 8 is required for this project . " ) 
 } , 
 resolvers + + = Resolvers . seq , 
 - scalacOptions in Compile + + = Seq ( 
 - " - target : jvm - 1 . 8 " , 
 - " - encoding " , 
 - " UTF - 8 " , 
 - " - deprecation " , 
 - " - unchecked " , 
 - " - feature " , 
 - " - language : higherKinds " , 
 - " - Xfatal - warnings " , 
 - " - Xlint " , 
 - " - Xfuture " 
 - ) + + compilerWarnings , 
 + scalacOptions in Compile + + = defaultScalacOptions , 
 + scalacOptions in ( Compile , console ) ~ = ( _ . filterNot ( _ = = " - Ywarn - unused - import " ) . filterNot ( _ = = " - Yfatal - warnings " ) ) , 
 javaOptions + + = Seq ( " - Dfile . encoding = UTF - 8 " , " - Dscalac . patmat . analysisBudget = off " ) , 
 javacOptions + + = Seq ( " - source " , " 1 . 8 " , " - target " , " 1 . 8 " , " - Xlint : unchecked " , " - Xlint : deprecation " ) 
 ) 
 @ @ - 73 , 7 + 76 , 7 @ @ object Build extends sbt . Build { 
 " - groups " , 
 " - implicits " , 
 " - diagrams " 
 - ) + + compilerWarnings 
 + ) 
 ) 
 ) . settings ( net . virtualvoid . sbt . graph . Plugin . graphSettings : _ * ) 
 . dependsOn ( actorFrontend )
