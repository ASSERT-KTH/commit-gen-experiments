BLEU SCORE: 0.3636227046500071

TEST MSG: fix ( server : messaging ) : persist Read and Receive events in ack
GENERATED MSG: refactor ( server : messaging ) : more logging in dialogs

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index c80fbf0 . . e49974d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 113 , 50 + 113 , 46 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > < nl > protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { < nl > val mustReceive = mustMakeReceive ( state , mr ) < nl > - if ( mustReceive ) { < nl > - persist ( MessagesReceived ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ < nl > - commit ( e ) < nl > < nl > - ( for { < nl > - _ ← dialogExt . ackMessageReceived ( peer , mr ) < nl > - _ ← db . run ( markMessagesReceived ( selfPeer , peer , new DateTime ( mr . date ) ) ) < nl > - } yield MessageReceivedAck ( ) ) pipeTo sender ( ) < nl > - } < nl > + if ( mustReceive ) { < nl > + ( for { < nl > + _ ← dialogExt . ackMessageReceived ( peer , mr ) < nl > + } yield MessageReceivedAck ( ) ) pipeTo sender ( ) < nl > } else { < nl > sender ( ) ! MessageReceivedAck ( ) < nl > } < nl > } < nl > < nl > protected def ackMessageReceived ( mr : MessageReceived ) : Unit = { < nl > - ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) andThen { < nl > - case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageReceived " ) < nl > + persist ( MessagesReceived ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ < nl > + commit ( e ) < nl > + < nl > + ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) andThen { < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageReceived " ) < nl > + } < nl > } < nl > } < nl > < nl > protected def messageRead ( state : DialogState , mr : MessageRead ) : Unit = { < nl > val mustRead = mustMakeRead ( state , mr ) < nl > - val readDate = new DateTime ( mr . date ) < nl > < nl > if ( mustRead ) { < nl > - persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ < nl > - commit ( e ) < nl > - < nl > - ( for { < nl > - _ ← dialogExt . ackMessageRead ( peer , mr ) < nl > - _ ← db . run ( markMessagesRead ( selfPeer , peer , new DateTime ( mr . date ) ) ) < nl > - _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , Some ( state . counter ) ) < nl > - _ ← deliveryExt . sendCountersUpdate ( userId ) < nl > - } yield MessageReadAck ( ) ) pipeTo sender ( ) < nl > - } < nl > - < nl > + ( for { < nl > + _ ← dialogExt . ackMessageRead ( peer , mr ) < nl > + _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , Some ( state . counter ) ) < nl > + _ ← deliveryExt . sendCountersUpdate ( userId ) < nl > + } yield MessageReadAck ( ) ) pipeTo sender ( ) < nl > } else { < nl > sender ( ) ! MessageReadAck ( ) < nl > } < nl > } < nl > < nl > protected def ackMessageRead ( mr : MessageRead ) : Unit = < nl > - ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { < nl > - case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) < nl > + persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ < nl > + commit ( e ) < nl > + ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) < nl > + } < nl > } < nl > < nl > protected def setReaction ( state : DialogState , sr : SetReaction ) : Unit = { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index 02d93f1 . . 61f74aa 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 165 , 6 + 165 , 7 @ @ trait HistoryHandlers { < nl > for { < nl > historyOwner ← DBIO . from ( getHistoryOwner ( modelPeer , client . userId ) ) < nl > ( lastReceivedAt , lastReadAt ) ← getLastReceiveReadDates ( modelPeer ) < nl > + _ = println ( s " = = = $ { client . userId } lastReceivedAt $ { lastReceivedAt } lastReadAt $ { lastReadAt } " ) < nl > messageModels ← mode match { < nl > case Some ( ApiListLoadMode . Forward ) ⇒ HistoryMessageRepo . findAfter ( historyOwner , modelPeer , dateTimeFrom ( date ) , limit . toLong ) < nl > case Some ( ApiListLoadMode . Backward ) ⇒ HistoryMessageRepo . findBefore ( historyOwner , modelPeer , dateTimeFrom ( date ) , limit . toLong ) < nl > @ @ - 228 , 7 + 229 , 6 @ @ trait HistoryHandlers { < nl > db . run ( action ) < nl > } < nl > < nl > - private val ZeroDate = new DateTime ( 0 ) < nl > private val MaxDateTime = new DateTime ( 294276 , 1 , 1 , 0 , 0 ) < nl > private val MaxDate = MaxDateTime . getMillis
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 0a34a19 . . 218c286 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 104 , 7 + 104 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } yield MessageReceivedAck ( ) < nl > } else { < nl > Future . successful ( MessageReceivedAck ( ) ) < nl > - } ) pipeTo sender ( ) < nl > + } ) pipeTo sender ( ) andThen { < nl > + case Failure ( e ) = > log . error ( e , " Failed to process MessageReceived " ) < nl > + } < nl > + < nl > if ( mustReceive ) { < nl > onSuccess ( receiveFuture ) { _ ⇒ < nl > updateOwnReceiveDate ( state , mr . date ) < nl > @ @ - 113 , 7 + 116 , 12 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } < nl > < nl > protected def ackMessageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { < nl > - val notifyFuture = ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) < nl > + val notifyFuture = < nl > + ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) andThen { < nl > + case Failure ( e ) = > log . error ( e , " Failed to ack MessageReceived " ) < nl > + } < nl > + < nl > + < nl > onSuccess ( notifyFuture ) { _ ⇒ < nl > updatePeerReceiveDate ( state , mr . date ) < nl > } < nl > @ @ - 131 , 7 + 139 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } else { < nl > Future . successful ( MessageReadAck ( ) ) < nl > } ) pipeTo sender ( ) andThen { < nl > - case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to process MessageRead " ) < nl > } < nl > < nl > if ( mustRead ) {

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index c80fbf0 . . e49974d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 113 , 50 + 113 , 46 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 
 protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { 
 val mustReceive = mustMakeReceive ( state , mr ) 
 - if ( mustReceive ) { 
 - persist ( MessagesReceived ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ 
 - commit ( e ) 
 
 - ( for { 
 - _ ← dialogExt . ackMessageReceived ( peer , mr ) 
 - _ ← db . run ( markMessagesReceived ( selfPeer , peer , new DateTime ( mr . date ) ) ) 
 - } yield MessageReceivedAck ( ) ) pipeTo sender ( ) 
 - } 
 + if ( mustReceive ) { 
 + ( for { 
 + _ ← dialogExt . ackMessageReceived ( peer , mr ) 
 + } yield MessageReceivedAck ( ) ) pipeTo sender ( ) 
 } else { 
 sender ( ) ! MessageReceivedAck ( ) 
 } 
 } 
 
 protected def ackMessageReceived ( mr : MessageReceived ) : Unit = { 
 - ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) andThen { 
 - case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageReceived " ) 
 + persist ( MessagesReceived ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ 
 + commit ( e ) 
 + 
 + ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) andThen { 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageReceived " ) 
 + } 
 } 
 } 
 
 protected def messageRead ( state : DialogState , mr : MessageRead ) : Unit = { 
 val mustRead = mustMakeRead ( state , mr ) 
 - val readDate = new DateTime ( mr . date ) 
 
 if ( mustRead ) { 
 - persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ 
 - commit ( e ) 
 - 
 - ( for { 
 - _ ← dialogExt . ackMessageRead ( peer , mr ) 
 - _ ← db . run ( markMessagesRead ( selfPeer , peer , new DateTime ( mr . date ) ) ) 
 - _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , Some ( state . counter ) ) 
 - _ ← deliveryExt . sendCountersUpdate ( userId ) 
 - } yield MessageReadAck ( ) ) pipeTo sender ( ) 
 - } 
 - 
 + ( for { 
 + _ ← dialogExt . ackMessageRead ( peer , mr ) 
 + _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , Some ( state . counter ) ) 
 + _ ← deliveryExt . sendCountersUpdate ( userId ) 
 + } yield MessageReadAck ( ) ) pipeTo sender ( ) 
 } else { 
 sender ( ) ! MessageReadAck ( ) 
 } 
 } 
 
 protected def ackMessageRead ( mr : MessageRead ) : Unit = 
 - ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { 
 - case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) 
 + persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) ) ) { e ⇒ 
 + commit ( e ) 
 + ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) 
 + } 
 } 
 
 protected def setReaction ( state : DialogState , sr : SetReaction ) : Unit = { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index 02d93f1 . . 61f74aa 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 165 , 6 + 165 , 7 @ @ trait HistoryHandlers { 
 for { 
 historyOwner ← DBIO . from ( getHistoryOwner ( modelPeer , client . userId ) ) 
 ( lastReceivedAt , lastReadAt ) ← getLastReceiveReadDates ( modelPeer ) 
 + _ = println ( s " = = = $ { client . userId } lastReceivedAt $ { lastReceivedAt } lastReadAt $ { lastReadAt } " ) 
 messageModels ← mode match { 
 case Some ( ApiListLoadMode . Forward ) ⇒ HistoryMessageRepo . findAfter ( historyOwner , modelPeer , dateTimeFrom ( date ) , limit . toLong ) 
 case Some ( ApiListLoadMode . Backward ) ⇒ HistoryMessageRepo . findBefore ( historyOwner , modelPeer , dateTimeFrom ( date ) , limit . toLong ) 
 @ @ - 228 , 7 + 229 , 6 @ @ trait HistoryHandlers { 
 db . run ( action ) 
 } 
 
 - private val ZeroDate = new DateTime ( 0 ) 
 private val MaxDateTime = new DateTime ( 294276 , 1 , 1 , 0 , 0 ) 
 private val MaxDate = MaxDateTime . getMillis

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 0a34a19 . . 218c286 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 104 , 7 + 104 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } yield MessageReceivedAck ( ) 
 } else { 
 Future . successful ( MessageReceivedAck ( ) ) 
 - } ) pipeTo sender ( ) 
 + } ) pipeTo sender ( ) andThen { 
 + case Failure ( e ) = > log . error ( e , " Failed to process MessageReceived " ) 
 + } 
 + 
 if ( mustReceive ) { 
 onSuccess ( receiveFuture ) { _ ⇒ 
 updateOwnReceiveDate ( state , mr . date ) 
 @ @ - 113 , 7 + 116 , 12 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } 
 
 protected def ackMessageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { 
 - val notifyFuture = ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) 
 + val notifyFuture = 
 + ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) andThen { 
 + case Failure ( e ) = > log . error ( e , " Failed to ack MessageReceived " ) 
 + } 
 + 
 + 
 onSuccess ( notifyFuture ) { _ ⇒ 
 updatePeerReceiveDate ( state , mr . date ) 
 } 
 @ @ - 131 , 7 + 139 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } else { 
 Future . successful ( MessageReadAck ( ) ) 
 } ) pipeTo sender ( ) andThen { 
 - case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to process MessageRead " ) 
 } 
 
 if ( mustRead ) {
