BLEU SCORE: 0.12858902882463452

TEST MSG: fix ( server : core ) : fix counters ; fix reads ; dont allow kicked user to send messages in group
GENERATED MSG: fix ( server : messaging ) : fixes for hidden dialogs

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index b8abc2c . . b2d8049 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 28 , 6 + 28 , 7 @ @ message DialogCommands { < nl > WriteMessageSelf write _ message _ self = 11 ; < nl > Favourite favourite = 12 ; < nl > Unfavourite unfavourite = 13 ; < nl > + UpdateCounters update _ counters = 14 ; < nl > } < nl > } < nl > < nl > @ @ - 151 , 4 + 152 , 13 @ @ message DialogCommands { < nl > required SeqState seqstate = 1 ; < nl > repeated MessageReaction reactions = 2 ; < nl > } < nl > + < nl > + message UpdateCounters { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; < nl > + < nl > + required Peer origin = 1 ; < nl > + required Peer dest = 2 ; < nl > + } < nl > + < nl > + message UpdateCountersAck { } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > index b4688fd . . 580ddfc 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > @ @ - 56 , 11 + 56 , 16 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > ) , < nl > deliveryId = s " msg _ $ { peer . toString } _ $ randomId " < nl > ) < nl > - counterUpdate ← db . run ( getUpdateCountersChanged ( receiverUserId ) ) < nl > - _ ← seqUpdatesExt . deliverSingleUpdate ( receiverUserId , counterUpdate , deliveryId = s " counter _ $ randomId " ) < nl > } yield ( ) < nl > } < nl > < nl > + override def sendCountersUpdate ( userId : Int ) : Future [ Unit ] = < nl > + for { < nl > + counterUpdate ← db . run ( getUpdateCountersChanged ( userId ) ) < nl > + _ ← seqUpdatesExt . deliverSingleUpdate ( userId , counterUpdate ) < nl > + < nl > + } yield ( ) < nl > + < nl > override def senderDelivery ( < nl > senderUserId : Int , < nl > senderAuthSid : Int , < nl > @ @ - 103 , 22 + 108 , 13 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > ) map ( _ ⇒ ( ) ) < nl > } < nl > < nl > - override def read ( readerUserId : Int , readerAuthSid : Int , peer : Peer , date : Long ) : Future [ Unit ] = { < nl > - val update = UpdateMessageReadByMe ( peer . asStruct , date ) < nl > - val pushRules = PushRules ( ) < nl > + override def read ( readerUserId : Int , readerAuthSid : Int , peer : Peer , date : Long ) : Future [ Unit ] = < nl > for { < nl > - counterUpdate ← db . run ( getUpdateCountersChanged ( readerUserId ) ) < nl > _ ← seqUpdatesExt . deliverSingleUpdate ( < nl > userId = readerUserId , < nl > - update = update , < nl > - pushRules = pushRules < nl > - ) < nl > - _ ← seqUpdatesExt . deliverSingleUpdate ( < nl > - userId = readerUserId , < nl > - update = counterUpdate , < nl > - pushRules = pushRules < nl > + update = UpdateMessageReadByMe ( peer . asStruct , date ) , < nl > + pushRules = PushRules ( ) < nl > ) < nl > } yield ( ) < nl > - } < nl > < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DeliveryExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DeliveryExtension . scala < nl > index 55c9661 . . ec99d18 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DeliveryExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DeliveryExtension . scala < nl > @ @ - 28 , 6 + 28 , 8 @ @ trait DeliveryExtension { < nl > isFat : Boolean < nl > ) : Future [ SeqState ] < nl > < nl > + def sendCountersUpdate ( userId : Int ) : Future [ Unit ] < nl > + < nl > def notifyReceive ( authorUserId : Int , peer : Peer , date : Long , now : Long ) : Future [ Unit ] < nl > < nl > def notifyRead ( userId : Int , peer : Peer , date : Long , now : Long ) : Future [ Unit ] < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 00ad1ee . . 838c001 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 28 , 10 + 28 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { < nl > ( withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > for { < nl > - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > + _ ← dialogExt . ackSendMessage ( peer , sm ) < nl > message = sm . message < nl > _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) < nl > - _ ← dialogExt . ackSendMessage ( peer , sm ) < nl > + _ ← dialogExt . updateCounters ( peer , userId ) < nl > + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) < nl > } yield SeqStateDate ( seq , state , sm . date ) < nl > } recover { < nl > case e ⇒ < nl > @ @ - 45 , 6 + 46 , 12 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > updateMessageDate ( state , sm . date , checkOpen = true ) < nl > } < nl > < nl > + protected def updateCountersChanged ( ) : Unit = { < nl > + deliveryExt . sendCountersUpdate ( userId ) < nl > + . map ( _ ⇒ SendMessageAck ( ) ) < nl > + . pipeTo ( sender ( ) ) < nl > + } < nl > + < nl > protected def ackSendMessage ( state : DialogState , sm : SendMessage ) : Unit = { < nl > if ( peer . typ = = PeerType . Private ) { < nl > SocialManager . recordRelation ( sm . origin . id , userId ) < nl > @ @ - 123 , 15 + 130 , 13 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > protected def messageRead ( state : DialogState , mr : MessageRead ) : Unit = { < nl > val mustRead = mustMakeRead ( state , mr ) & & state . isOpen < nl > < nl > - val readerUpd = for { < nl > - _ ← db . run ( markMessagesRead ( selfPeer , peer , new DateTime ( mr . date ) ) ) < nl > - _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date ) < nl > - } yield ( ) < nl > - < nl > + val readerUpd = deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date ) < nl > ( if ( mustRead ) { < nl > for { < nl > _ ← readerUpd < nl > _ ← dialogExt . ackMessageRead ( peer , mr ) < nl > + _ ← db . run ( markMessagesRead ( selfPeer , peer , new DateTime ( mr . date ) ) ) < nl > + _ ← deliveryExt . sendCountersUpdate ( userId ) < nl > } yield MessageReadAck ( ) < nl > } else { < nl > Future . successful ( MessageReadAck ( ) ) < nl > @ @ - 284 , 13 + 289 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > < nl > private def mustMakeReceive ( state : DialogState , mr : MessageReceived ) : Boolean = < nl > ( mr . date > state . lastReceiveDate ) & & / / receive date is later than last receive date < nl > - ( mr . date < = mr . now ) & & / / and receive date is not in future < nl > - ( state . lastMessageDate = = 0L | | mr . date > state . lastMessageDate ) / / and receive date if after date of last message sent by this user < nl > + ( mr . date < = mr . now ) / / and receive date is not in future < nl > < nl > private def mustMakeRead ( state : DialogState , mr : MessageRead ) : Boolean = < nl > ( mr . date > state . lastReadDate ) & & / / read date is later than last read date < nl > - ( mr . date < = mr . now ) & & / / and read date is not in future < nl > - ( state . lastMessageDate = = 0L | | mr . date > state . lastMessageDate ) / / and read date if after date of last message sent by this user < nl > + ( mr . date < = mr . now ) / / and read date is not in future < nl > < nl > / / if checkOpen is true , open dialog if it ' s not open already < nl > protected def updateMessageDate ( state : DialogState , date : Long , checkOpen : Boolean ) : Unit = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index ff62d3f . . 034621c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 195 , 6 + 195 , 15 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def ackRemoveReaction ( peer : Peer , rr : RemoveReaction ) : Future [ Unit ] = < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withRemoveReaction ( rr ) ) map ( _ ⇒ ( ) ) < nl > < nl > + def updateCounters ( peer : Peer , userId : Int ) : Future [ Unit ] = < nl > + ( processorRegion ( peer ) ? Envelope ( peer ) . withUpdateCounters ( UpdateCounters ( < nl > + origin = Peer . privat ( userId ) , < nl > + dest = peer < nl > + ) ) ) map ( _ ⇒ ( ) ) < nl > + < nl > + def ackUpdateCounters ( peer : Peer , uc : UpdateCounters ) : Future [ Unit ] = < nl > + ( processorRegion ( peer ) ? Envelope ( peer ) . withUpdateCounters ( uc ) ) map ( _ ⇒ ( ) ) < nl > + < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > case Seq ( ) ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 8238406 . . ab31e34 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 68 , 7 + 68 , 7 @ @ private [ dialog ] object DialogState { < nl > } < nl > < nl > private [ dialog ] final case class DialogState ( < nl > - lastMessageDate : Long , < nl > + lastMessageDate : Long , / / we don ' t use it now anywhere . should we remove it ? < nl > lastReceiveDate : Long , < nl > lastReadDate : Long , < nl > isHidden : Boolean , < nl > @ @ - 85 , 7 + 85 , 7 @ @ private [ dialog ] final case class DialogState ( < nl > case Favourited ⇒ this . copy ( isFavourite = true ) < nl > case Unfavourited ⇒ this . copy ( isFavourite = false ) < nl > case Open ⇒ this . copy ( isOpen = true ) < nl > - case unm ⇒ this < nl > + case _ ⇒ this < nl > } < nl > } < nl > < nl > @ @ - 169 , 6 + 169 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case Favourite ( _ ) ⇒ favourite ( state ) < nl > case Unfavourite ( _ ) ⇒ unfavourite ( state ) < nl > case Delete ( _ ) ⇒ delete ( state ) < nl > + case uc : UpdateCounters ⇒ updateCountersChanged ( ) < nl > } < nl > < nl > / * * < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > index 56ffa76 . . 5958f4f 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > @ @ - 59 , 6 + 59 , 7 @ @ private [ group ] final class GroupPeer ( val groupId : Int ) < nl > case sr : SetReaction ⇒ setReaction ( state , sr ) < nl > case rr : RemoveReaction ⇒ removeReaction ( state , rr ) < nl > case sc : LastSenderIdChanged ⇒ context become initialized ( state . updated ( sc ) ) < nl > + case uc : UpdateCounters ⇒ updateCountersChanged ( uc ) < nl > } < nl > < nl > override def receive : Receive = initialized ( GroupPeerState . empty ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala < nl > index 0395fcc . . 6094d9a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala < nl > @ @ - 34 , 6 + 34 , 18 @ @ trait GroupPeerCommandHandlers extends PeersImplicits { < nl > } ) pipeTo sender ( ) < nl > } < nl > < nl > + protected def updateCountersChanged ( uc : UpdateCounters ) = { < nl > + ( withMemberIds ( groupId ) { ( memberIds , _ , _ ) ⇒ < nl > + Future . traverse ( memberIds - uc . origin . id ) { userId ⇒ < nl > + dialogExt . ackUpdateCounters ( Peer . privat ( userId ) , uc ) < nl > + } map ( _ ⇒ UpdateCountersAck ( ) ) < nl > + } recover { < nl > + case e ⇒ < nl > + log . error ( e , " Failed to send update counters changed " ) < nl > + throw e < nl > + } ) pipeTo sender ( ) < nl > + } < nl > + < nl > protected def messageReceived ( state : GroupPeerState , mr : MessageReceived ) = { < nl > val receiverUserId = mr . origin . id < nl > val canReceive = canMakeReceive ( state , mr ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > index 3bc9acf . . d9f950d 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > @ @ - 1 , 18 + 1 , 24 @ @ < nl > package im . actor . server < nl > < nl > import akka . actor . ActorSystem < nl > - import im . actor . api . rpc . ClientData < nl > + import com . google . protobuf . ByteString < nl > + import im . actor . api . rpc . { PeersImplicits , ClientData } < nl > import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . api . rpc . users . ApiUser < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . DialogGroup < nl > + import im . actor . server . model . Dialog < nl > + import im . actor . server . persist . DialogRepo < nl > + import im . actor . server . sequence . SeqStateDate < nl > + import org . scalatest . Matchers < nl > import org . scalatest . concurrent . ScalaFutures < nl > < nl > import scala . language . postfixOps < nl > import scala . util . Random < nl > < nl > - trait MessagingSpecHelpers extends ScalaFutures { < nl > + trait MessagingSpecHelpers extends ScalaFutures with PeersImplicits with Matchers { < nl > implicit val system : ActorSystem < nl > < nl > def sendMessageToUser ( userId : Int , message : ApiMessage ) ( < nl > @ @ - 27 , 6 + 33 , 32 @ @ trait MessagingSpecHelpers extends ScalaFutures { < nl > randomId < nl > } < nl > < nl > + / / the only difference with previous method - this one returns SeqStateDate < nl > + def sendPrivateMessage ( userId : Int , message : ApiMessage ) ( < nl > + implicit < nl > + clientData : ClientData , < nl > + msgService : MessagingService < nl > + ) : SeqStateDate = { < nl > + val randomId = Random . nextLong < nl > + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ < nl > + whenReady ( msgService . handleSendMessage ( peer , randomId , message ) ) { resp ⇒ < nl > + val respSeqDate = resp . toOption . get < nl > + SeqStateDate ( respSeqDate . seq , ByteString . copyFrom ( respSeqDate . state ) , respSeqDate . date ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + def findPrivateDialog ( withUserId : Int ) ( implicit clientData : ClientData ) : Dialog = { < nl > + clientData . authData shouldBe defined < nl > + val clientUserId = clientData . authData . get . userId < nl > + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , withUserId ) , clientData . authId ) ) { peer ⇒ < nl > + whenReady ( DbExtension ( system ) . db . run ( DialogRepo . find ( clientUserId , peer . asModel ) ) ) { resp ⇒ < nl > + resp shouldBe defined < nl > + resp . get < nl > + } < nl > + } < nl > + } < nl > + < nl > def sendMessageToGroup ( groupId : Int , message : ApiMessage ) ( < nl > implicit < nl > clientData : ClientData , < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > index 702ab18 . . d45b646 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > @ @ - 11 , 7 + 11 , 7 @ @ import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupRpcErrors , GroupsServiceImpl } < nl > import im . actor . server . group . GroupServiceMessages < nl > import im . actor . server . model . PeerType < nl > - import org . scalatest . Inside . _ < nl > + import im . actor . server . persist . HistoryMessageRepo < nl > import slick . dbio . DBIO < nl > < nl > import scala . util . Random < nl > @ @ - 81 , 9 + 81 , 11 @ @ final class GroupsServiceSpec < nl > < nl > " Kick user " should " mark messages read in public group " in markReadOnKickInPublic < nl > < nl > + " Kicked user " should " not be able to write to group " in e27 < nl > + < nl > val groupInviteConfig = GroupInviteConfig ( " http : / / actor . im " ) < nl > < nl > - val messagingService = messaging . MessagingServiceImpl ( ) < nl > + implicit val messagingService = messaging . MessagingServiceImpl ( ) < nl > implicit val service = new GroupsServiceImpl ( groupInviteConfig ) < nl > < nl > def sendInvitesOnCreate ( ) = { < nl > @ @ - 987 , 4 + 989 , 65 @ @ final class GroupsServiceSpec < nl > < nl > } < nl > < nl > + def e27 ( ) = { < nl > + val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) < nl > + val ( user2 , authId2 , authSid2 , _ ) = createUser ( ) < nl > + < nl > + val sessionId = createSessionId ( ) < nl > + < nl > + val clientData1 = ClientData ( authId1 , sessionId , Some ( AuthData ( user1 . id , authSid1 ) ) ) < nl > + val clientData2 = ClientData ( authId2 , sessionId , Some ( AuthData ( user2 . id , authSid2 ) ) ) < nl > + < nl > + val user2Model = getUserModel ( user2 . id ) < nl > + val user2AccessHash = ACLUtils . userAccessHash ( authId1 , user2 . id , user2Model . accessSalt ) < nl > + val user2OutPeer = ApiUserOutPeer ( user2 . id , user2AccessHash ) < nl > + < nl > + val groupOutPeer = { < nl > + implicit val clientData = clientData1 < nl > + createGroup ( " Fun group " , Set ( user2 . id ) ) . groupPeer < nl > + } < nl > + val outPeer = ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) < nl > + < nl > + for ( _ ← 1 to 6 ) { < nl > + implicit val clientData = clientData2 < nl > + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " hello " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = clientData1 < nl > + whenReady ( service . handleKickUser ( groupOutPeer , Random . nextLong ( ) , user2OutPeer ) ) { resp ⇒ < nl > + resp should matchPattern { case Ok ( _ ) ⇒ } < nl > + } < nl > + } < nl > + < nl > + val user1Seq = whenReady ( sequenceService . jhandleGetState ( clientData1 ) ) ( _ . toOption . get . seq ) < nl > + val user2Seq = whenReady ( sequenceService . jhandleGetState ( clientData2 ) ) ( _ . toOption . get . seq ) < nl > + < nl > + { < nl > + implicit val clientData = clientData2 < nl > + < nl > + val randomId = Random . nextLong ( ) < nl > + whenReady ( messagingService . handleSendMessage ( outPeer , randomId , ApiTextMessage ( " WTF ? am i kicked ? ! ! ? ! ? ! ? ! ? ! ? ! ? ! ? ! ? ? ! ? ! ? ! " , Vector . empty , None ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( err ) ⇒ err . code shouldEqual 403 < nl > + } < nl > + < nl > + expectNoUpdate ( user2Seq , classOf [ UpdateMessageSent ] ) < nl > + < nl > + whenReady ( db . run ( HistoryMessageRepo . find ( user2 . id , outPeer . asModel , Set ( randomId ) ) ) ) { ms ⇒ < nl > + ms shouldBe empty < nl > + } < nl > + whenReady ( db . run ( HistoryMessageRepo . find ( user1 . id , outPeer . asModel , Set ( randomId ) ) ) ) { ms ⇒ < nl > + ms shouldBe empty < nl > + } < nl > + < nl > + } < nl > + } < nl > + { < nl > + implicit val clientData = clientData1 < nl > + < nl > + expectNoUpdate ( user1Seq , classOf [ UpdateMessage ] ) < nl > + expectNoUpdate ( user1Seq , classOf [ UpdateCountersChanged ] ) < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 6de5a4a < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala < nl > @ @ - 0 , 0 + 1 , 155 @ @ < nl > + package im . actor . server . api . rpc . service < nl > + < nl > + import im . actor . api . rpc . counters . UpdateCountersChanged < nl > + import im . actor . api . rpc . messaging . { UpdateMessageReadByMe , UpdateMessage , ApiTextMessage } < nl > + import im . actor . api . rpc . peers . { ApiPeerType , ApiOutPeer } < nl > + import im . actor . api . rpc . { AuthData , ClientData , PeersImplicits } < nl > + import im . actor . server . _ < nl > + import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . sequence . SeqStateDate < nl > + import org . joda . time . DateTime < nl > + < nl > + class MessagingReadsSpec < nl > + extends BaseAppSuite < nl > + with ImplicitSequenceService < nl > + with ImplicitAuthService < nl > + with ImplicitSessionRegion < nl > + with SeqUpdateMatchers < nl > + with PeersImplicits { < nl > + < nl > + behavior of " Reads in messaging " < nl > + < nl > + it should " receive updates and update dialog data in database " in e1 ( ) < nl > + < nl > + it should " make read when user send read on his own message " in e2 ( ) < nl > + < nl > + implicit val service = messaging . MessagingServiceImpl ( ) < nl > + < nl > + def e1 ( ) : Unit = { < nl > + val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) < nl > + val ( user2 , authId2 , authSid2 , _ ) = createUser ( ) < nl > + < nl > + val sessionId = createSessionId ( ) < nl > + val client1 = ClientData ( authId1 , sessionId , Some ( AuthData ( user1 . id , authSid1 ) ) ) < nl > + val client2 = ClientData ( authId2 , sessionId , Some ( AuthData ( user2 . id , authSid2 ) ) ) < nl > + < nl > + val user2AccessHash = ACLUtils . userAccessHash ( client1 . authId , user2 . id , getUserModel ( user2 . id ) . accessSalt ) < nl > + val user2OutPeer = ApiOutPeer ( ApiPeerType . Private , user2 . id , user2AccessHash ) < nl > + < nl > + val user1AccessHash = ACLUtils . userAccessHash ( client2 . authId , user1 . id , getUserModel ( user1 . id ) . accessSalt ) < nl > + val user1OutPeer = ApiOutPeer ( ApiPeerType . Private , user1 . id , user1AccessHash ) < nl > + < nl > + { < nl > + implicit val client = client2 < nl > + < nl > + sendPrivateMessage ( user1 . id , ApiTextMessage ( s " This is hack to initialize dialog and set isOpen to ` true ` " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + val states _ 1 _ 3 = { < nl > + implicit val client = client1 < nl > + ( 1 to 3 ) map { i ⇒ < nl > + sendPrivateMessage ( user2 . id , ApiTextMessage ( s " Hello $ i " , Vector . empty , None ) ) < nl > + } < nl > + } < nl > + < nl > + { < nl > + implicit val client = client2 < nl > + < nl > + val lastDate = states _ 1 _ 3 . last . date < nl > + < nl > + expectUpdates ( classOf [ UpdateMessage ] ) { < nl > + case Seq ( _ : UpdateMessage , _ : UpdateMessage , _ : UpdateMessage ) ⇒ < nl > + case _ ⇒ fail ( " Unmatched UpdateMessage updates " ) < nl > + } < nl > + < nl > + expectUpdates ( classOf [ UpdateCountersChanged ] ) { < nl > + case counters @ Seq ( c1 : UpdateCountersChanged , c2 : UpdateCountersChanged , c3 : UpdateCountersChanged ) ⇒ < nl > + val cs = List ( c1 , c2 , c3 ) flatMap ( _ . counters . globalCounter ) < nl > + cs should contain theSameElementsAs List ( 1 , 2 , 3 ) < nl > + case _ ⇒ fail ( " Unmatched UpdateCountersChanged updates " ) < nl > + } < nl > + < nl > + val dialog = findPrivateDialog ( user1 . id ) < nl > + < nl > + dialog . lastMessageDate shouldEqual new DateTime ( lastDate ) < nl > + dialog . lastReadAt shouldEqual new DateTime ( 0 ) < nl > + dialog . ownerLastReadAt shouldEqual new DateTime ( 0 ) < nl > + < nl > + val seq = whenReady ( sequenceService . handleGetState ( ) ) { < nl > + _ . toOption . get . seq < nl > + } < nl > + < nl > + / / read dialog < nl > + whenReady ( service . handleMessageRead ( user1OutPeer , lastDate ) ) ( identity ) < nl > + < nl > + expectUpdate ( seq , classOf [ UpdateMessageReadByMe ] ) ( identity ) < nl > + expectUpdate ( seq , classOf [ UpdateCountersChanged ] ) { upd ⇒ < nl > + upd . counters . globalCounter shouldBe defined < nl > + val counter = upd . counters . globalCounter . get < nl > + counter shouldEqual 0 < nl > + } < nl > + < nl > + val dialogAfter = findPrivateDialog ( user1 . id ) < nl > + < nl > + dialogAfter . lastMessageDate shouldEqual new DateTime ( lastDate ) < nl > + / / dialog . lastReadAt shouldEqual new DateTime ( lastDate ) / / why not ? < nl > + dialogAfter . ownerLastReadAt shouldEqual new DateTime ( lastDate ) < nl > + } < nl > + } < nl > + < nl > + def e2 ( ) = { < nl > + val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) < nl > + val ( user2 , authId2 , authSid2 , _ ) = createUser ( ) < nl > + < nl > + val sessionId = createSessionId ( ) < nl > + val client1 = ClientData ( authId1 , sessionId , Some ( AuthData ( user1 . id , authSid1 ) ) ) < nl > + val client2 = ClientData ( authId2 , sessionId , Some ( AuthData ( user2 . id , authSid2 ) ) ) < nl > + < nl > + val user2AccessHash = ACLUtils . userAccessHash ( client1 . authId , user2 . id , getUserModel ( user2 . id ) . accessSalt ) < nl > + val user2OutPeer = ApiOutPeer ( ApiPeerType . Private , user2 . id , user2AccessHash ) < nl > + < nl > + val user1AccessHash = ACLUtils . userAccessHash ( client2 . authId , user1 . id , getUserModel ( user1 . id ) . accessSalt ) < nl > + val user1OutPeer = ApiOutPeer ( ApiPeerType . Private , user1 . id , user1AccessHash ) < nl > + < nl > + { < nl > + implicit val client = client1 < nl > + sendPrivateMessage ( user2 . id , ApiTextMessage ( " User 1 sends message " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val client = client2 < nl > + sendPrivateMessage ( user1 . id , ApiTextMessage ( " User replies to this message " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val client = client1 < nl > + sendPrivateMessage ( user2 . id , ApiTextMessage ( " And user 1 sends two more messages . This one " , Vector . empty , None ) ) < nl > + val SeqStateDate ( _ , _ , messageDate ) = < nl > + sendPrivateMessage ( user2 . id , ApiTextMessage ( " And this one . His client will send read on this message " , Vector . empty , None ) ) < nl > + < nl > + val dialog = findPrivateDialog ( user2 . id ) < nl > + < nl > + dialog . lastMessageDate shouldEqual new DateTime ( messageDate ) < nl > + dialog . lastReadAt shouldEqual new DateTime ( 0 ) < nl > + dialog . ownerLastReadAt shouldEqual new DateTime ( 0 ) < nl > + < nl > + val currentSeq = whenReady ( sequenceService . handleGetState ( ) ) { _ . toOption . get . seq } < nl > + < nl > + whenReady ( service . handleMessageRead ( user2OutPeer , messageDate ) ) ( identity ) < nl > + < nl > + expectUpdate ( currentSeq , classOf [ UpdateMessageReadByMe ] ) ( identity ) < nl > + expectUpdate ( currentSeq , classOf [ UpdateCountersChanged ] ) { upd ⇒ < nl > + upd . counters . globalCounter shouldBe defined < nl > + val counter = upd . counters . globalCounter . get < nl > + counter shouldEqual 0 < nl > + } < nl > + < nl > + val dialogAfter = findPrivateDialog ( user2 . id ) < nl > + < nl > + dialogAfter . lastMessageDate shouldEqual new DateTime ( messageDate ) < nl > + / / dialog . lastReadAt shouldEqual new DateTime ( lastDate ) / / why not ? < nl > + dialogAfter . ownerLastReadAt shouldEqual new DateTime ( messageDate ) < nl > + } < nl > + } < nl > + < nl > + }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > index 4181a2e . . 3230c26 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . cache . CacheHelpers . _ < nl > + import org . joda . time . DateTime < nl > import slick . dbio . DBIO < nl > < nl > import slick . driver . PostgresDriver . api . Database < nl > @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > dialog ← optDialog match { < nl > case Some ( dialog ) ⇒ DBIO . successful ( dialog ) < nl > case None ⇒ < nl > - val dialog = DialogModel ( userId , peer ) < nl > + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > for { < nl > _ ← DialogRepo . create ( dialog ) < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index b45cc33 . . d2c2ddb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > throw e < nl > } ) pipeTo sender ( ) < nl > sendFuture onSuccess { < nl > - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) < nl > + case SeqStateDate ( _ , _ , date ) ⇒ < nl > + self ! LastOwnMessageDate ( date ) < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > } < nl > } < nl > < nl > @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > deliveryExt < nl > . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > . map ( _ ⇒ SendMessageAck ( ) ) < nl > - . pipeTo ( sender ( ) ) < nl > - < nl > - if ( state . isHidden ) < nl > - self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + . pipeTo ( sender ( ) ) onSuccess { < nl > + case _ ⇒ < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } < nl > < nl > / / onSuccess ( fu ) { _ = > < nl > / / updatePeerMessageDate ( ) < nl > @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > if ( state . isHidden ) < nl > sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) < nl > else { < nl > + < nl > val future = < nl > ( for { < nl > _ ← db . run ( DialogRepo . hide ( userId , peer ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 55230de . . 01a8d62 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > + sealed trait DialogGroup { < nl > + def key : String < nl > + def title : String < nl > + } < nl > + < nl > + object DialogGroups { < nl > + object Privates extends DialogGroup { < nl > + override def key : String = " privates " < nl > + < nl > + override def title : String = " Private " < nl > + } < nl > + < nl > + object Groups extends DialogGroup { < nl > + override def key : String = " groups " < nl > + < nl > + override def title : String = " Groups " < nl > + } < nl > + } < nl > + < nl > sealed trait DialogExtension extends Extension < nl > < nl > final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { < nl > @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > < nl > private val log = Logging ( system , getClass ) < nl > < nl > - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > peer match { < nl > - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ < nl > + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ < nl > log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) < nl > failed < nl > case _ ⇒ f < nl > } < nl > < nl > def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > val date = Instant . now ( ) . toEpochMilli < nl > val sender = Peer . privat ( senderUserId ) < nl > val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) < nl > @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > randomId : Long , < nl > message : ApiMessage < nl > ) : Future [ Unit ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { < nl > val sender = Peer . privat ( senderUserId ) < nl > val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) < nl > ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) < nl > } < nl > < nl > def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val receiver = Peer . privat ( receiverUserId ) < nl > val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) < nl > @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > < nl > def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val reader = Peer . privat ( readerUserId ) < nl > val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) < nl > @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > < nl > def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def isSharedUser ( userId : Int ) : Boolean = userId = = 0 < nl > < nl > def getGroupedDialogs ( userId : Int ) = { < nl > - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { < nl > case ( ( groupModels , privateModels ) , dialog ) ⇒ < nl > if ( dialog . peer . typ = = PeerType . Group ) < nl > @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) < nl > privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) < nl > } yield Vector ( < nl > - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , < nl > - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) < nl > + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , < nl > + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) < nl > ) < nl > } ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index 4219e8c . . d3a6b75 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { < nl > for { < nl > _ ← persist . HistoryMessageRepo . create ( messages ) < nl > _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) < nl > - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > } yield ( ) < nl > } else if ( toPeer . typ = = PeerType . Group ) { < nl > DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > index 191aa44 . . a59b5b2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { < nl > def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { < nl > phones . headOption match { < nl > case Some ( phone ) ⇒ Some ( phone . number ) < nl > - case None ⇒ Some ( 0L ) < nl > + case None ⇒ Some ( 0L ) < nl > } < nl > } < nl > < nl > def normalizeLocalName ( name : Option [ String ] ) = name match { < nl > - case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > - case _ ⇒ None < nl > + case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > + case _ ⇒ None < nl > } < nl > < nl > def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > index f7b0742 . . f9c82b0 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { < nl > def findLastReadBefore ( date : DateTime , userId : Int ) = < nl > dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result < nl > < nl > - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) < nl > + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > < nl > def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > index 14c35dd . . 66d4ebf 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { < nl > | " com . trueaccord . scalapb . GeneratedMessage " = actor < nl > | } < nl > | } < nl > + | < nl > + | cluster . sharding . state - store - mode = " ddata " < nl > | } < nl > " " " . stripMargin < nl > ) ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > index 3d25a02 . . 72dc6c1 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > @ @ - 1 , 27 + 1 , 52 @ @ < nl > package im . actor . server < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . util . Timeout < nl > import im . actor . api . rpc . ClientData < nl > - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } < nl > + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . api . rpc . users . ApiUser < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . dialog . DialogGroup < nl > + import org . scalatest . concurrent . ScalaFutures < nl > < nl > - import scala . concurrent . Await < nl > + import scala . language . postfixOps < nl > import scala . util . Random < nl > < nl > - trait MessagingSpecHelpers { < nl > - val timeout : Timeout < nl > + trait MessagingSpecHelpers extends ScalaFutures { < nl > + implicit val system : ActorSystem < nl > < nl > def sendMessageToUser ( userId : Int , message : ApiMessage ) ( < nl > implicit < nl > clientData : ClientData , < nl > - msgService : MessagingService , < nl > - system : ActorSystem < nl > + msgService : MessagingService < nl > ) : Unit = { < nl > - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) < nl > - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) < nl > + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ < nl > + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) < nl > + } < nl > } < nl > < nl > def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) < nl > + < nl > + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { < nl > + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ < nl > + resp . toOption . get . dialogs map { < nl > + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs < nl > + } toMap < nl > + } < nl > + } < nl > + < nl > + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { < nl > + val dgs = getDialogGroups ( ) < nl > + dgs get group . key match { < nl > + case Some ( ds ) ⇒ ds < nl > + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) < nl > + } < nl > + } < nl > + < nl > + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { < nl > + users foreach { user ⇒ < nl > + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) < nl > + Thread . sleep ( 1 ) < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > index 85ba87d . . fe02129 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } < nl > - import org . scalatest . Inside . _ < nl > + import im . actor . server . _ < nl > + import im . actor . server . dialog . DialogGroups < nl > < nl > import scala . concurrent . { Await , Future } < nl > import scala . concurrent . duration . _ < nl > @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec < nl > extends BaseAppSuite < nl > with ImplicitAuthService < nl > with ImplicitSessionRegion < nl > - with GroupsServiceHelpers { < nl > + with GroupsServiceHelpers < nl > + with MessagingSpecHelpers { < nl > " LoadGroupedDialogs " should " load groups and privates " in loadGrouped < nl > < nl > - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > - private val service = MessagingServiceImpl ( ) < nl > + " Dialogs " should " appear in top on new incoming message " in incomingGoTop < nl > + it should " appear in top on new outgoing message " in outgoingGoTop < nl > + < nl > + " Hidden dialogs " should " appear on new message " in appearHidden < nl > + it should " appear on show " in appearShown < nl > + < nl > + import DialogGroups . _ < nl > + < nl > + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > + private implicit lazy val service = MessagingServiceImpl ( ) < nl > < nl > def loadGrouped ( ) = { < nl > val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) < nl > @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec < nl > } < nl > } < nl > } < nl > + < nl > + def incomingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) < nl > + < nl > + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = bobClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val dgs = getDialogGroups ( ) < nl > + val privates = dgs ( Privates . key ) < nl > + privates . size should equal ( 2 ) < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + privates . last . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val privates = getDialogGroups ( Privates ) < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + } < nl > + < nl > + def outgoingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + val ( eve , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + < nl > + prepareDialogs ( bob , eve ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + } < nl > + } < nl > + < nl > + def appearHidden ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > + < nl > + def appearShown ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index b8abc2c . . b2d8049 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 28 , 6 + 28 , 7 @ @ message DialogCommands { 
 WriteMessageSelf write _ message _ self = 11 ; 
 Favourite favourite = 12 ; 
 Unfavourite unfavourite = 13 ; 
 + UpdateCounters update _ counters = 14 ; 
 } 
 } 
 
 @ @ - 151 , 4 + 152 , 13 @ @ message DialogCommands { 
 required SeqState seqstate = 1 ; 
 repeated MessageReaction reactions = 2 ; 
 } 
 + 
 + message UpdateCounters { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; 
 + 
 + required Peer origin = 1 ; 
 + required Peer dest = 2 ; 
 + } 
 + 
 + message UpdateCountersAck { } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 index b4688fd . . 580ddfc 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 @ @ - 56 , 11 + 56 , 16 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 ) , 
 deliveryId = s " msg _ $ { peer . toString } _ $ randomId " 
 ) 
 - counterUpdate ← db . run ( getUpdateCountersChanged ( receiverUserId ) ) 
 - _ ← seqUpdatesExt . deliverSingleUpdate ( receiverUserId , counterUpdate , deliveryId = s " counter _ $ randomId " ) 
 } yield ( ) 
 } 
 
 + override def sendCountersUpdate ( userId : Int ) : Future [ Unit ] = 
 + for { 
 + counterUpdate ← db . run ( getUpdateCountersChanged ( userId ) ) 
 + _ ← seqUpdatesExt . deliverSingleUpdate ( userId , counterUpdate ) 
 + 
 + } yield ( ) 
 + 
 override def senderDelivery ( 
 senderUserId : Int , 
 senderAuthSid : Int , 
 @ @ - 103 , 22 + 108 , 13 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 ) map ( _ ⇒ ( ) ) 
 } 
 
 - override def read ( readerUserId : Int , readerAuthSid : Int , peer : Peer , date : Long ) : Future [ Unit ] = { 
 - val update = UpdateMessageReadByMe ( peer . asStruct , date ) 
 - val pushRules = PushRules ( ) 
 + override def read ( readerUserId : Int , readerAuthSid : Int , peer : Peer , date : Long ) : Future [ Unit ] = 
 for { 
 - counterUpdate ← db . run ( getUpdateCountersChanged ( readerUserId ) ) 
 _ ← seqUpdatesExt . deliverSingleUpdate ( 
 userId = readerUserId , 
 - update = update , 
 - pushRules = pushRules 
 - ) 
 - _ ← seqUpdatesExt . deliverSingleUpdate ( 
 - userId = readerUserId , 
 - update = counterUpdate , 
 - pushRules = pushRules 
 + update = UpdateMessageReadByMe ( peer . asStruct , date ) , 
 + pushRules = PushRules ( ) 
 ) 
 } yield ( ) 
 - } 
 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DeliveryExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DeliveryExtension . scala 
 index 55c9661 . . ec99d18 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DeliveryExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DeliveryExtension . scala 
 @ @ - 28 , 6 + 28 , 8 @ @ trait DeliveryExtension { 
 isFat : Boolean 
 ) : Future [ SeqState ] 
 
 + def sendCountersUpdate ( userId : Int ) : Future [ Unit ] 
 + 
 def notifyReceive ( authorUserId : Int , peer : Peer , date : Long , now : Long ) : Future [ Unit ] 
 
 def notifyRead ( userId : Int , peer : Peer , date : Long , now : Long ) : Future [ Unit ] 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 00ad1ee . . 838c001 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 28 , 10 + 28 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { 
 ( withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 for { 
 - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 + _ ← dialogExt . ackSendMessage ( peer , sm ) 
 message = sm . message 
 _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) 
 - _ ← dialogExt . ackSendMessage ( peer , sm ) 
 + _ ← dialogExt . updateCounters ( peer , userId ) 
 + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) 
 } yield SeqStateDate ( seq , state , sm . date ) 
 } recover { 
 case e ⇒ 
 @ @ - 45 , 6 + 46 , 12 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 updateMessageDate ( state , sm . date , checkOpen = true ) 
 } 
 
 + protected def updateCountersChanged ( ) : Unit = { 
 + deliveryExt . sendCountersUpdate ( userId ) 
 + . map ( _ ⇒ SendMessageAck ( ) ) 
 + . pipeTo ( sender ( ) ) 
 + } 
 + 
 protected def ackSendMessage ( state : DialogState , sm : SendMessage ) : Unit = { 
 if ( peer . typ = = PeerType . Private ) { 
 SocialManager . recordRelation ( sm . origin . id , userId ) 
 @ @ - 123 , 15 + 130 , 13 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 protected def messageRead ( state : DialogState , mr : MessageRead ) : Unit = { 
 val mustRead = mustMakeRead ( state , mr ) & & state . isOpen 
 
 - val readerUpd = for { 
 - _ ← db . run ( markMessagesRead ( selfPeer , peer , new DateTime ( mr . date ) ) ) 
 - _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date ) 
 - } yield ( ) 
 - 
 + val readerUpd = deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date ) 
 ( if ( mustRead ) { 
 for { 
 _ ← readerUpd 
 _ ← dialogExt . ackMessageRead ( peer , mr ) 
 + _ ← db . run ( markMessagesRead ( selfPeer , peer , new DateTime ( mr . date ) ) ) 
 + _ ← deliveryExt . sendCountersUpdate ( userId ) 
 } yield MessageReadAck ( ) 
 } else { 
 Future . successful ( MessageReadAck ( ) ) 
 @ @ - 284 , 13 + 289 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 
 private def mustMakeReceive ( state : DialogState , mr : MessageReceived ) : Boolean = 
 ( mr . date > state . lastReceiveDate ) & & / / receive date is later than last receive date 
 - ( mr . date < = mr . now ) & & / / and receive date is not in future 
 - ( state . lastMessageDate = = 0L | | mr . date > state . lastMessageDate ) / / and receive date if after date of last message sent by this user 
 + ( mr . date < = mr . now ) / / and receive date is not in future 
 
 private def mustMakeRead ( state : DialogState , mr : MessageRead ) : Boolean = 
 ( mr . date > state . lastReadDate ) & & / / read date is later than last read date 
 - ( mr . date < = mr . now ) & & / / and read date is not in future 
 - ( state . lastMessageDate = = 0L | | mr . date > state . lastMessageDate ) / / and read date if after date of last message sent by this user 
 + ( mr . date < = mr . now ) / / and read date is not in future 
 
 / / if checkOpen is true , open dialog if it ' s not open already 
 protected def updateMessageDate ( state : DialogState , date : Long , checkOpen : Boolean ) : Unit = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index ff62d3f . . 034621c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 195 , 6 + 195 , 15 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def ackRemoveReaction ( peer : Peer , rr : RemoveReaction ) : Future [ Unit ] = 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withRemoveReaction ( rr ) ) map ( _ ⇒ ( ) ) 
 
 + def updateCounters ( peer : Peer , userId : Int ) : Future [ Unit ] = 
 + ( processorRegion ( peer ) ? Envelope ( peer ) . withUpdateCounters ( UpdateCounters ( 
 + origin = Peer . privat ( userId ) , 
 + dest = peer 
 + ) ) ) map ( _ ⇒ ( ) ) 
 + 
 + def ackUpdateCounters ( peer : Peer , uc : UpdateCounters ) : Future [ Unit ] = 
 + ( processorRegion ( peer ) ? Envelope ( peer ) . withUpdateCounters ( uc ) ) map ( _ ⇒ ( ) ) 
 + 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 case Seq ( ) ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 8238406 . . ab31e34 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 68 , 7 + 68 , 7 @ @ private [ dialog ] object DialogState { 
 } 
 
 private [ dialog ] final case class DialogState ( 
 - lastMessageDate : Long , 
 + lastMessageDate : Long , / / we don ' t use it now anywhere . should we remove it ? 
 lastReceiveDate : Long , 
 lastReadDate : Long , 
 isHidden : Boolean , 
 @ @ - 85 , 7 + 85 , 7 @ @ private [ dialog ] final case class DialogState ( 
 case Favourited ⇒ this . copy ( isFavourite = true ) 
 case Unfavourited ⇒ this . copy ( isFavourite = false ) 
 case Open ⇒ this . copy ( isOpen = true ) 
 - case unm ⇒ this 
 + case _ ⇒ this 
 } 
 } 
 
 @ @ - 169 , 6 + 169 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case Favourite ( _ ) ⇒ favourite ( state ) 
 case Unfavourite ( _ ) ⇒ unfavourite ( state ) 
 case Delete ( _ ) ⇒ delete ( state ) 
 + case uc : UpdateCounters ⇒ updateCountersChanged ( ) 
 } 
 
 / * * 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 index 56ffa76 . . 5958f4f 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 @ @ - 59 , 6 + 59 , 7 @ @ private [ group ] final class GroupPeer ( val groupId : Int ) 
 case sr : SetReaction ⇒ setReaction ( state , sr ) 
 case rr : RemoveReaction ⇒ removeReaction ( state , rr ) 
 case sc : LastSenderIdChanged ⇒ context become initialized ( state . updated ( sc ) ) 
 + case uc : UpdateCounters ⇒ updateCountersChanged ( uc ) 
 } 
 
 override def receive : Receive = initialized ( GroupPeerState . empty ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala 
 index 0395fcc . . 6094d9a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala 
 @ @ - 34 , 6 + 34 , 18 @ @ trait GroupPeerCommandHandlers extends PeersImplicits { 
 } ) pipeTo sender ( ) 
 } 
 
 + protected def updateCountersChanged ( uc : UpdateCounters ) = { 
 + ( withMemberIds ( groupId ) { ( memberIds , _ , _ ) ⇒ 
 + Future . traverse ( memberIds - uc . origin . id ) { userId ⇒ 
 + dialogExt . ackUpdateCounters ( Peer . privat ( userId ) , uc ) 
 + } map ( _ ⇒ UpdateCountersAck ( ) ) 
 + } recover { 
 + case e ⇒ 
 + log . error ( e , " Failed to send update counters changed " ) 
 + throw e 
 + } ) pipeTo sender ( ) 
 + } 
 + 
 protected def messageReceived ( state : GroupPeerState , mr : MessageReceived ) = { 
 val receiverUserId = mr . origin . id 
 val canReceive = canMakeReceive ( state , mr ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 index 3bc9acf . . d9f950d 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 @ @ - 1 , 18 + 1 , 24 @ @ 
 package im . actor . server 
 
 import akka . actor . ActorSystem 
 - import im . actor . api . rpc . ClientData 
 + import com . google . protobuf . ByteString 
 + import im . actor . api . rpc . { PeersImplicits , ClientData } 
 import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . api . rpc . users . ApiUser 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . DialogGroup 
 + import im . actor . server . model . Dialog 
 + import im . actor . server . persist . DialogRepo 
 + import im . actor . server . sequence . SeqStateDate 
 + import org . scalatest . Matchers 
 import org . scalatest . concurrent . ScalaFutures 
 
 import scala . language . postfixOps 
 import scala . util . Random 
 
 - trait MessagingSpecHelpers extends ScalaFutures { 
 + trait MessagingSpecHelpers extends ScalaFutures with PeersImplicits with Matchers { 
 implicit val system : ActorSystem 
 
 def sendMessageToUser ( userId : Int , message : ApiMessage ) ( 
 @ @ - 27 , 6 + 33 , 32 @ @ trait MessagingSpecHelpers extends ScalaFutures { 
 randomId 
 } 
 
 + / / the only difference with previous method - this one returns SeqStateDate 
 + def sendPrivateMessage ( userId : Int , message : ApiMessage ) ( 
 + implicit 
 + clientData : ClientData , 
 + msgService : MessagingService 
 + ) : SeqStateDate = { 
 + val randomId = Random . nextLong 
 + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ 
 + whenReady ( msgService . handleSendMessage ( peer , randomId , message ) ) { resp ⇒ 
 + val respSeqDate = resp . toOption . get 
 + SeqStateDate ( respSeqDate . seq , ByteString . copyFrom ( respSeqDate . state ) , respSeqDate . date ) 
 + } 
 + } 
 + } 
 + 
 + def findPrivateDialog ( withUserId : Int ) ( implicit clientData : ClientData ) : Dialog = { 
 + clientData . authData shouldBe defined 
 + val clientUserId = clientData . authData . get . userId 
 + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , withUserId ) , clientData . authId ) ) { peer ⇒ 
 + whenReady ( DbExtension ( system ) . db . run ( DialogRepo . find ( clientUserId , peer . asModel ) ) ) { resp ⇒ 
 + resp shouldBe defined 
 + resp . get 
 + } 
 + } 
 + } 
 + 
 def sendMessageToGroup ( groupId : Int , message : ApiMessage ) ( 
 implicit 
 clientData : ClientData , 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 index 702ab18 . . d45b646 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 @ @ - 11 , 7 + 11 , 7 @ @ import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupRpcErrors , GroupsServiceImpl } 
 import im . actor . server . group . GroupServiceMessages 
 import im . actor . server . model . PeerType 
 - import org . scalatest . Inside . _ 
 + import im . actor . server . persist . HistoryMessageRepo 
 import slick . dbio . DBIO 
 
 import scala . util . Random 
 @ @ - 81 , 9 + 81 , 11 @ @ final class GroupsServiceSpec 
 
 " Kick user " should " mark messages read in public group " in markReadOnKickInPublic 
 
 + " Kicked user " should " not be able to write to group " in e27 
 + 
 val groupInviteConfig = GroupInviteConfig ( " http : / / actor . im " ) 
 
 - val messagingService = messaging . MessagingServiceImpl ( ) 
 + implicit val messagingService = messaging . MessagingServiceImpl ( ) 
 implicit val service = new GroupsServiceImpl ( groupInviteConfig ) 
 
 def sendInvitesOnCreate ( ) = { 
 @ @ - 987 , 4 + 989 , 65 @ @ final class GroupsServiceSpec 
 
 } 
 
 + def e27 ( ) = { 
 + val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) 
 + val ( user2 , authId2 , authSid2 , _ ) = createUser ( ) 
 + 
 + val sessionId = createSessionId ( ) 
 + 
 + val clientData1 = ClientData ( authId1 , sessionId , Some ( AuthData ( user1 . id , authSid1 ) ) ) 
 + val clientData2 = ClientData ( authId2 , sessionId , Some ( AuthData ( user2 . id , authSid2 ) ) ) 
 + 
 + val user2Model = getUserModel ( user2 . id ) 
 + val user2AccessHash = ACLUtils . userAccessHash ( authId1 , user2 . id , user2Model . accessSalt ) 
 + val user2OutPeer = ApiUserOutPeer ( user2 . id , user2AccessHash ) 
 + 
 + val groupOutPeer = { 
 + implicit val clientData = clientData1 
 + createGroup ( " Fun group " , Set ( user2 . id ) ) . groupPeer 
 + } 
 + val outPeer = ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) 
 + 
 + for ( _ ← 1 to 6 ) { 
 + implicit val clientData = clientData2 
 + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " hello " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = clientData1 
 + whenReady ( service . handleKickUser ( groupOutPeer , Random . nextLong ( ) , user2OutPeer ) ) { resp ⇒ 
 + resp should matchPattern { case Ok ( _ ) ⇒ } 
 + } 
 + } 
 + 
 + val user1Seq = whenReady ( sequenceService . jhandleGetState ( clientData1 ) ) ( _ . toOption . get . seq ) 
 + val user2Seq = whenReady ( sequenceService . jhandleGetState ( clientData2 ) ) ( _ . toOption . get . seq ) 
 + 
 + { 
 + implicit val clientData = clientData2 
 + 
 + val randomId = Random . nextLong ( ) 
 + whenReady ( messagingService . handleSendMessage ( outPeer , randomId , ApiTextMessage ( " WTF ? am i kicked ? ! ! ? ! ? ! ? ! ? ! ? ! ? ! ? ! ? ? ! ? ! ? ! " , Vector . empty , None ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( err ) ⇒ err . code shouldEqual 403 
 + } 
 + 
 + expectNoUpdate ( user2Seq , classOf [ UpdateMessageSent ] ) 
 + 
 + whenReady ( db . run ( HistoryMessageRepo . find ( user2 . id , outPeer . asModel , Set ( randomId ) ) ) ) { ms ⇒ 
 + ms shouldBe empty 
 + } 
 + whenReady ( db . run ( HistoryMessageRepo . find ( user1 . id , outPeer . asModel , Set ( randomId ) ) ) ) { ms ⇒ 
 + ms shouldBe empty 
 + } 
 + 
 + } 
 + } 
 + { 
 + implicit val clientData = clientData1 
 + 
 + expectNoUpdate ( user1Seq , classOf [ UpdateMessage ] ) 
 + expectNoUpdate ( user1Seq , classOf [ UpdateCountersChanged ] ) 
 + } 
 + } 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala 
 new file mode 100644 
 index 0000000 . . 6de5a4a 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala 
 @ @ - 0 , 0 + 1 , 155 @ @ 
 + package im . actor . server . api . rpc . service 
 + 
 + import im . actor . api . rpc . counters . UpdateCountersChanged 
 + import im . actor . api . rpc . messaging . { UpdateMessageReadByMe , UpdateMessage , ApiTextMessage } 
 + import im . actor . api . rpc . peers . { ApiPeerType , ApiOutPeer } 
 + import im . actor . api . rpc . { AuthData , ClientData , PeersImplicits } 
 + import im . actor . server . _ 
 + import im . actor . server . acl . ACLUtils 
 + import im . actor . server . sequence . SeqStateDate 
 + import org . joda . time . DateTime 
 + 
 + class MessagingReadsSpec 
 + extends BaseAppSuite 
 + with ImplicitSequenceService 
 + with ImplicitAuthService 
 + with ImplicitSessionRegion 
 + with SeqUpdateMatchers 
 + with PeersImplicits { 
 + 
 + behavior of " Reads in messaging " 
 + 
 + it should " receive updates and update dialog data in database " in e1 ( ) 
 + 
 + it should " make read when user send read on his own message " in e2 ( ) 
 + 
 + implicit val service = messaging . MessagingServiceImpl ( ) 
 + 
 + def e1 ( ) : Unit = { 
 + val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) 
 + val ( user2 , authId2 , authSid2 , _ ) = createUser ( ) 
 + 
 + val sessionId = createSessionId ( ) 
 + val client1 = ClientData ( authId1 , sessionId , Some ( AuthData ( user1 . id , authSid1 ) ) ) 
 + val client2 = ClientData ( authId2 , sessionId , Some ( AuthData ( user2 . id , authSid2 ) ) ) 
 + 
 + val user2AccessHash = ACLUtils . userAccessHash ( client1 . authId , user2 . id , getUserModel ( user2 . id ) . accessSalt ) 
 + val user2OutPeer = ApiOutPeer ( ApiPeerType . Private , user2 . id , user2AccessHash ) 
 + 
 + val user1AccessHash = ACLUtils . userAccessHash ( client2 . authId , user1 . id , getUserModel ( user1 . id ) . accessSalt ) 
 + val user1OutPeer = ApiOutPeer ( ApiPeerType . Private , user1 . id , user1AccessHash ) 
 + 
 + { 
 + implicit val client = client2 
 + 
 + sendPrivateMessage ( user1 . id , ApiTextMessage ( s " This is hack to initialize dialog and set isOpen to ` true ` " , Vector . empty , None ) ) 
 + } 
 + 
 + val states _ 1 _ 3 = { 
 + implicit val client = client1 
 + ( 1 to 3 ) map { i ⇒ 
 + sendPrivateMessage ( user2 . id , ApiTextMessage ( s " Hello $ i " , Vector . empty , None ) ) 
 + } 
 + } 
 + 
 + { 
 + implicit val client = client2 
 + 
 + val lastDate = states _ 1 _ 3 . last . date 
 + 
 + expectUpdates ( classOf [ UpdateMessage ] ) { 
 + case Seq ( _ : UpdateMessage , _ : UpdateMessage , _ : UpdateMessage ) ⇒ 
 + case _ ⇒ fail ( " Unmatched UpdateMessage updates " ) 
 + } 
 + 
 + expectUpdates ( classOf [ UpdateCountersChanged ] ) { 
 + case counters @ Seq ( c1 : UpdateCountersChanged , c2 : UpdateCountersChanged , c3 : UpdateCountersChanged ) ⇒ 
 + val cs = List ( c1 , c2 , c3 ) flatMap ( _ . counters . globalCounter ) 
 + cs should contain theSameElementsAs List ( 1 , 2 , 3 ) 
 + case _ ⇒ fail ( " Unmatched UpdateCountersChanged updates " ) 
 + } 
 + 
 + val dialog = findPrivateDialog ( user1 . id ) 
 + 
 + dialog . lastMessageDate shouldEqual new DateTime ( lastDate ) 
 + dialog . lastReadAt shouldEqual new DateTime ( 0 ) 
 + dialog . ownerLastReadAt shouldEqual new DateTime ( 0 ) 
 + 
 + val seq = whenReady ( sequenceService . handleGetState ( ) ) { 
 + _ . toOption . get . seq 
 + } 
 + 
 + / / read dialog 
 + whenReady ( service . handleMessageRead ( user1OutPeer , lastDate ) ) ( identity ) 
 + 
 + expectUpdate ( seq , classOf [ UpdateMessageReadByMe ] ) ( identity ) 
 + expectUpdate ( seq , classOf [ UpdateCountersChanged ] ) { upd ⇒ 
 + upd . counters . globalCounter shouldBe defined 
 + val counter = upd . counters . globalCounter . get 
 + counter shouldEqual 0 
 + } 
 + 
 + val dialogAfter = findPrivateDialog ( user1 . id ) 
 + 
 + dialogAfter . lastMessageDate shouldEqual new DateTime ( lastDate ) 
 + / / dialog . lastReadAt shouldEqual new DateTime ( lastDate ) / / why not ? 
 + dialogAfter . ownerLastReadAt shouldEqual new DateTime ( lastDate ) 
 + } 
 + } 
 + 
 + def e2 ( ) = { 
 + val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) 
 + val ( user2 , authId2 , authSid2 , _ ) = createUser ( ) 
 + 
 + val sessionId = createSessionId ( ) 
 + val client1 = ClientData ( authId1 , sessionId , Some ( AuthData ( user1 . id , authSid1 ) ) ) 
 + val client2 = ClientData ( authId2 , sessionId , Some ( AuthData ( user2 . id , authSid2 ) ) ) 
 + 
 + val user2AccessHash = ACLUtils . userAccessHash ( client1 . authId , user2 . id , getUserModel ( user2 . id ) . accessSalt ) 
 + val user2OutPeer = ApiOutPeer ( ApiPeerType . Private , user2 . id , user2AccessHash ) 
 + 
 + val user1AccessHash = ACLUtils . userAccessHash ( client2 . authId , user1 . id , getUserModel ( user1 . id ) . accessSalt ) 
 + val user1OutPeer = ApiOutPeer ( ApiPeerType . Private , user1 . id , user1AccessHash ) 
 + 
 + { 
 + implicit val client = client1 
 + sendPrivateMessage ( user2 . id , ApiTextMessage ( " User 1 sends message " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val client = client2 
 + sendPrivateMessage ( user1 . id , ApiTextMessage ( " User replies to this message " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val client = client1 
 + sendPrivateMessage ( user2 . id , ApiTextMessage ( " And user 1 sends two more messages . This one " , Vector . empty , None ) ) 
 + val SeqStateDate ( _ , _ , messageDate ) = 
 + sendPrivateMessage ( user2 . id , ApiTextMessage ( " And this one . His client will send read on this message " , Vector . empty , None ) ) 
 + 
 + val dialog = findPrivateDialog ( user2 . id ) 
 + 
 + dialog . lastMessageDate shouldEqual new DateTime ( messageDate ) 
 + dialog . lastReadAt shouldEqual new DateTime ( 0 ) 
 + dialog . ownerLastReadAt shouldEqual new DateTime ( 0 ) 
 + 
 + val currentSeq = whenReady ( sequenceService . handleGetState ( ) ) { _ . toOption . get . seq } 
 + 
 + whenReady ( service . handleMessageRead ( user2OutPeer , messageDate ) ) ( identity ) 
 + 
 + expectUpdate ( currentSeq , classOf [ UpdateMessageReadByMe ] ) ( identity ) 
 + expectUpdate ( currentSeq , classOf [ UpdateCountersChanged ] ) { upd ⇒ 
 + upd . counters . globalCounter shouldBe defined 
 + val counter = upd . counters . globalCounter . get 
 + counter shouldEqual 0 
 + } 
 + 
 + val dialogAfter = findPrivateDialog ( user2 . id ) 
 + 
 + dialogAfter . lastMessageDate shouldEqual new DateTime ( messageDate ) 
 + / / dialog . lastReadAt shouldEqual new DateTime ( lastDate ) / / why not ? 
 + dialogAfter . ownerLastReadAt shouldEqual new DateTime ( messageDate ) 
 + } 
 + } 
 + 
 + }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 index 4181a2e . . 3230c26 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 import im . actor . util . cache . CacheHelpers . _ 
 + import org . joda . time . DateTime 
 import slick . dbio . DBIO 
 
 import slick . driver . PostgresDriver . api . Database 
 @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 dialog ← optDialog match { 
 case Some ( dialog ) ⇒ DBIO . successful ( dialog ) 
 case None ⇒ 
 - val dialog = DialogModel ( userId , peer ) 
 + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 for { 
 _ ← DialogRepo . create ( dialog ) 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index b45cc33 . . d2c2ddb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 throw e 
 } ) pipeTo sender ( ) 
 sendFuture onSuccess { 
 - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) 
 + case SeqStateDate ( _ , _ , date ) ⇒ 
 + self ! LastOwnMessageDate ( date ) 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 } 
 } 
 
 @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 deliveryExt 
 . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 . map ( _ ⇒ SendMessageAck ( ) ) 
 - . pipeTo ( sender ( ) ) 
 - 
 - if ( state . isHidden ) 
 - self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + . pipeTo ( sender ( ) ) onSuccess { 
 + case _ ⇒ 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } 
 
 / / onSuccess ( fu ) { _ = > 
 / / updatePeerMessageDate ( ) 
 @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 if ( state . isHidden ) 
 sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) 
 else { 
 + 
 val future = 
 ( for { 
 _ ← db . run ( DialogRepo . hide ( userId , peer ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 55230de . . 01a8d62 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 
 + sealed trait DialogGroup { 
 + def key : String 
 + def title : String 
 + } 
 + 
 + object DialogGroups { 
 + object Privates extends DialogGroup { 
 + override def key : String = " privates " 
 + 
 + override def title : String = " Private " 
 + } 
 + 
 + object Groups extends DialogGroup { 
 + override def key : String = " groups " 
 + 
 + override def title : String = " Groups " 
 + } 
 + } 
 + 
 sealed trait DialogExtension extends Extension 
 
 final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { 
 @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 
 private val log = Logging ( system , getClass ) 
 
 - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 peer match { 
 - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ 
 + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ 
 log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) 
 failed 
 case _ ⇒ f 
 } 
 
 def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 val date = Instant . now ( ) . toEpochMilli 
 val sender = Peer . privat ( senderUserId ) 
 val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) 
 @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 randomId : Long , 
 message : ApiMessage 
 ) : Future [ Unit ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { 
 val sender = Peer . privat ( senderUserId ) 
 val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) 
 ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) 
 } 
 
 def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val receiver = Peer . privat ( receiverUserId ) 
 val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) 
 @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 
 def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val reader = Peer . privat ( readerUserId ) 
 val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) 
 @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 
 def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def isSharedUser ( userId : Int ) : Boolean = userId = = 0 
 
 def getGroupedDialogs ( userId : Int ) = { 
 - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { 
 case ( ( groupModels , privateModels ) , dialog ) ⇒ 
 if ( dialog . peer . typ = = PeerType . Group ) 
 @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) 
 privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) 
 } yield Vector ( 
 - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , 
 - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) 
 + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , 
 + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) 
 ) 
 } ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index 4219e8c . . d3a6b75 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { 
 for { 
 _ ← persist . HistoryMessageRepo . create ( messages ) 
 _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) 
 - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 } yield ( ) 
 } else if ( toPeer . typ = = PeerType . Group ) { 
 DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 index 191aa44 . . a59b5b2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { 
 def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { 
 phones . headOption match { 
 case Some ( phone ) ⇒ Some ( phone . number ) 
 - case None ⇒ Some ( 0L ) 
 + case None ⇒ Some ( 0L ) 
 } 
 } 
 
 def normalizeLocalName ( name : Option [ String ] ) = name match { 
 - case n @ Some ( name ) if name . nonEmpty ⇒ n 
 - case _ ⇒ None 
 + case n @ Some ( name ) if name . nonEmpty ⇒ n 
 + case _ ⇒ None 
 } 
 
 def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 index f7b0742 . . f9c82b0 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { 
 def findLastReadBefore ( date : DateTime , userId : Int ) = 
 dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result 
 
 - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) 
 + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 
 def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 index 14c35dd . . 66d4ebf 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { 
 | " com . trueaccord . scalapb . GeneratedMessage " = actor 
 | } 
 | } 
 + | 
 + | cluster . sharding . state - store - mode = " ddata " 
 | } 
 " " " . stripMargin 
 ) ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 index 3d25a02 . . 72dc6c1 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 @ @ - 1 , 27 + 1 , 52 @ @ 
 package im . actor . server 
 
 import akka . actor . ActorSystem 
 - import akka . util . Timeout 
 import im . actor . api . rpc . ClientData 
 - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } 
 + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . api . rpc . users . ApiUser 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . dialog . DialogGroup 
 + import org . scalatest . concurrent . ScalaFutures 
 
 - import scala . concurrent . Await 
 + import scala . language . postfixOps 
 import scala . util . Random 
 
 - trait MessagingSpecHelpers { 
 - val timeout : Timeout 
 + trait MessagingSpecHelpers extends ScalaFutures { 
 + implicit val system : ActorSystem 
 
 def sendMessageToUser ( userId : Int , message : ApiMessage ) ( 
 implicit 
 clientData : ClientData , 
 - msgService : MessagingService , 
 - system : ActorSystem 
 + msgService : MessagingService 
 ) : Unit = { 
 - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) 
 - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) 
 + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ 
 + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) 
 + } 
 } 
 
 def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) 
 + 
 + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { 
 + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ 
 + resp . toOption . get . dialogs map { 
 + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs 
 + } toMap 
 + } 
 + } 
 + 
 + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { 
 + val dgs = getDialogGroups ( ) 
 + dgs get group . key match { 
 + case Some ( ds ) ⇒ ds 
 + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) 
 + } 
 + } 
 + 
 + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { 
 + users foreach { user ⇒ 
 + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) 
 + Thread . sleep ( 1 ) 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 index 85ba87d . . fe02129 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } 
 - import org . scalatest . Inside . _ 
 + import im . actor . server . _ 
 + import im . actor . server . dialog . DialogGroups 
 
 import scala . concurrent . { Await , Future } 
 import scala . concurrent . duration . _ 
 @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec 
 extends BaseAppSuite 
 with ImplicitAuthService 
 with ImplicitSessionRegion 
 - with GroupsServiceHelpers { 
 + with GroupsServiceHelpers 
 + with MessagingSpecHelpers { 
 " LoadGroupedDialogs " should " load groups and privates " in loadGrouped 
 
 - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 - private val service = MessagingServiceImpl ( ) 
 + " Dialogs " should " appear in top on new incoming message " in incomingGoTop 
 + it should " appear in top on new outgoing message " in outgoingGoTop 
 + 
 + " Hidden dialogs " should " appear on new message " in appearHidden 
 + it should " appear on show " in appearShown 
 + 
 + import DialogGroups . _ 
 + 
 + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 + private implicit lazy val service = MessagingServiceImpl ( ) 
 
 def loadGrouped ( ) = { 
 val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) 
 @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec 
 } 
 } 
 } 
 + 
 + def incomingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) 
 + 
 + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = bobClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val dgs = getDialogGroups ( ) 
 + val privates = dgs ( Privates . key ) 
 + privates . size should equal ( 2 ) 
 + privates . head . peer . id should equal ( bob . id ) 
 + privates . last . peer . id should equal ( eve . id ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val privates = getDialogGroups ( Privates ) 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + } 
 + 
 + def outgoingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + val ( eve , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + 
 + prepareDialogs ( bob , eve ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( bob . id ) 
 + } 
 + } 
 + 
 + def appearHidden ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 + 
 + def appearShown ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 } 
 \ No newline at end of file
