BLEU SCORE: 0.19561803044642365

TEST MSG: fix ( iOS ) : Fixing actor core and string extensions
GENERATED MSG: feat ( iOS ) : Updated Text Parser , restored support to links

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift < nl > index 8e52a80 . . 227689b 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift < nl > @ @ - 271 , 19 + 271 , 6 @ @ class AAFileCallback : NSObject , ACFileCallback { < nl > / / Markdown < nl > / / < nl > < nl > - / / public class ARMDFormattedText { < nl > - / / < nl > - / / public let isTrivial : Bool < nl > - / / public let attributedText : NSAttributedString < nl > - / / public let code : [ String ] < nl > - / / < nl > - / / public init ( attributedText : NSAttributedString , isTrivial : Bool , code : [ String ] ) { < nl > - / / self . attributedText = attributedText < nl > - / / self . code = code < nl > - / / self . isTrivial = isTrivial < nl > - / / } < nl > - / / } < nl > - < nl > open class TextParser { < nl > < nl > open let textColor : UIColor < nl > @ @ - 316 , 7 + 303 , 7 @ @ open class TextParser { < nl > var isFirst = true < nl > for s in sections { < nl > if ! isFirst { < nl > - / / nAttrText . append ( NSAttributedString ( string : " \ n " ) ) < nl > + nAttrText . append ( NSAttributedString ( string : " \ n " ) ) < nl > } < nl > isFirst = false < nl > < nl > @ @ - 331 , 13 + 318 , 13 @ @ open class TextParser { < nl > str . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > str . yy _ setColor ( linkColor , range : range ) < nl > < nl > - / / nAttrText . append ( str ) < nl > + nAttrText . append ( str ) < nl > < nl > sources . append ( s . getCode ( ) . getCode ( ) ) < nl > } else if s . getType ( ) = = ARMDSection _ TYPE _ TEXT { < nl > let child : [ ARMDText ] = s . getText ( ) . toSwiftArray ( ) < nl > for c in child { < nl > - / / nAttrText . append ( buildText ( c , fontSize : fontSize ) ) < nl > + nAttrText . append ( buildText ( c , fontSize : fontSize ) ) < nl > } < nl > } else { < nl > fatalError ( " Unsupported section type " ) < nl > @ @ - 363 , 7 + 350 , 7 @ @ open class TextParser { < nl > / / Processing child texts < nl > let child : [ ARMDText ] = span . getChild ( ) . toSwiftArray ( ) < nl > for c in child { < nl > - / / res . append ( buildText ( c , fontSize : fontSize ) ) < nl > + res . append ( buildText ( c , fontSize : fontSize ) ) < nl > } < nl > < nl > / / Setting span elements < nl > @ @ - 418 , 116 + 405 , 7 @ @ open class ParsedText { < nl > self . isTrivial = isTrivial < nl > } < nl > } < nl > - / / < nl > - / / public extension ARMarkdownParser { < nl > - / / < nl > - / / public func parse ( text : String , textColor : UIColor , fontSize : CGFloat ) - > ARMDFormattedText { < nl > - / / < nl > - / / let doc = self . processDocumentWithNSString ( text ) < nl > - / / if doc . isTrivial ( ) { < nl > - / / let nAttrText = NSMutableAttributedString ( string : text ) < nl > - / / let range = NSRange ( location : 0 , length : nAttrText . length ) < nl > - / / nAttrText . yy _ setColor ( textColor , range : range ) < nl > - / / nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > - / / return ARMDFormattedText ( attributedText : nAttrText , isTrivial : true , code : [ ] ) < nl > - / / } < nl > - / / < nl > - / / var sources = [ String ] ( ) < nl > - / / < nl > - / / let sections : [ ARMDSection ] = doc . getSections ( ) . toSwiftArray ( ) < nl > - / / let nAttrText = NSMutableAttributedString ( ) < nl > - / / var isFirst = true < nl > - / / for s in sections { < nl > - / / if ! isFirst { < nl > - / / nAttrText . appendAttributedString ( NSAttributedString ( string : " \ n " ) ) < nl > - / / } < nl > - / / isFirst = false < nl > - / / < nl > - / / if s . getType ( ) = = ARMDSection _ TYPE _ CODE { < nl > - / / let attributes = [ NSLinkAttributeName : NSURL ( string : " source : / / / \ ( sources . count ) " ) as ! AnyObject , < nl > - / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] < nl > - / / nAttrText . appendAttributedString ( NSAttributedString ( string : " Open Code " , attributes : attributes ) ) < nl > - / / sources . append ( s . getCode ( ) . getCode ( ) ) < nl > - / / } else if s . getType ( ) = = ARMDSection _ TYPE _ TEXT { < nl > - / / let child : [ ARMDText ] = s . getText ( ) . toSwiftArray ( ) < nl > - / / for c in child { < nl > - / / nAttrText . appendAttributedString ( buildText ( c , fontSize : fontSize ) ) < nl > - / / } < nl > - / / } else { < nl > - / / fatalError ( " Unsupported section type " ) < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / / / let range = NSRange ( location : 0 , length : nAttrText . length ) < nl > - / / < nl > - / / / / nAttrText . yy _ setColor ( textColor , range : range ) < nl > - / / / / nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > - / / < nl > - / / / / nAttrText . enumerateAttributesInRange ( range , options : NSAttributedStringEnumerationOptions . LongestEffectiveRangeNotRequired ) { ( attrs , range , objBool ) - > Void in < nl > - / / / / var attributeDictionary = NSDictionary ( dictionary : attrs ) < nl > - / / / / < nl > - / / / / for k in attributeDictionary . allKeys { < nl > - / / / / let v = attributeDictionary . objectForKey ( k ) < nl > - / / / / < nl > - / / / / print ( " attr : \ ( k ) - > \ ( v ) at \ ( range ) " ) < nl > - / / / / } < nl > - / / / / } < nl > - / / / / < nl > - / / return ARMDFormattedText ( attributedText : nAttrText , isTrivial : false , code : sources ) < nl > - / / } < nl > - / / < nl > - / / private func buildText ( text : ARMDText , fontSize : CGFloat ) - > NSAttributedString { < nl > - / / if let raw = text as ? ARMDRawText { < nl > - / / / / let res = NSMutableAttributedString ( string : raw . getRawText ( ) ) < nl > - / / / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : NSRange ( location : 0 , length : raw . getRawText ( ) . length ) ) < nl > - / / / / return res < nl > - / / return NSAttributedString ( string : raw . getRawText ( ) , font : UIFont . textFontOfSize ( fontSize ) ) < nl > - / / } else if let span = text as ? ARMDSpan { < nl > - / / let res = NSMutableAttributedString ( ) < nl > - / / res . beginEditing ( ) < nl > - / / < nl > - / / / / Processing child texts < nl > - / / let child : [ ARMDText ] = span . getChild ( ) . toSwiftArray ( ) < nl > - / / for c in child { < nl > - / / res . appendAttributedString ( buildText ( c , fontSize : fontSize ) ) < nl > - / / } < nl > - / / < nl > - / / / / Setting span elements < nl > - / / if span . getSpanType ( ) = = ARMDSpan _ TYPE _ BOLD { < nl > - / / res . appendFont ( UIFont . boldSystemFontOfSize ( fontSize ) ) < nl > - / / } else if span . getSpanType ( ) = = ARMDSpan _ TYPE _ ITALIC { < nl > - / / res . appendFont ( UIFont . italicSystemFontOfSize ( fontSize ) ) < nl > - / / } else { < nl > - / / fatalError ( " Unsupported span type " ) < nl > - / / } < nl > - / / < nl > - / / res . endEditing ( ) < nl > - / / return res < nl > - / / } else if let url = text as ? ARMDUrl { < nl > - / / < nl > - / / / / Parsing url element < nl > - / / let nsUrl = NSURL ( string : url . getUrl ( ) ) < nl > - / / if nsUrl ! = nil { < nl > - / / let res = NSMutableAttributedString ( string : url . getUrlTitle ( ) ) < nl > - / / let range = NSRange ( location : 0 , length : res . length ) < nl > - / / let highlight = YYTextHighlight ( ) < nl > - / / / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > - / / / / res . yy _ setTextHighlightRange ( range , color : UIColor . redColor ( ) , backgroundColor : nil , tapAction : nil ) < nl > - / / / / res . yy _ setColor ( UIColor . greenColor ( ) , range : range ) < nl > - / / return res < nl > - / / / / let attributes = [ NSLinkAttributeName : nsUrl as ! AnyObject , < nl > - / / / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] < nl > - / / / / return NSAttributedString ( string : url . getUrlTitle ( ) , attributes : attributes ) < nl > - / / } else { < nl > - / / / / Unable to parse : show as text < nl > - / / return NSAttributedString ( string : url . getUrlTitle ( ) , font : UIFont . textFontOfSize ( fontSize ) ) < nl > - / / } < nl > - / / } else { < nl > - / / fatalError ( " Unsupported text type " ) < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / < nl > + < nl > / / < nl > / / Promises < nl > / / < nl > diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / SwiftExtensions / Strings . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / SwiftExtensions / Strings . swift < nl > index 65a8c2e . . bc70feb 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / SwiftExtensions / Strings . swift < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / SwiftExtensions / Strings . swift < nl > @ @ - 97 , 17 + 97 , 17 @ @ public extension String { < nl > public func rangesOfString ( _ text : String ) - > [ Range < String . Index > ] { < nl > var res = [ Range < String . Index > ] ( ) < nl > < nl > - / / var searchRange = ( self . characters . indices ) < nl > - / / while true { < nl > - / / let found = self . range ( of : text , options : NSString . CompareOptions . caseInsensitive , range : searchRange , locale : nil ) < nl > - / / if found ! = nil { < nl > - / / res . append ( found ! ) < nl > - / / searchRange = ( found ! . upperBound . . < self . endIndex ) < nl > - / / } else { < nl > - / / break < nl > - / / } < nl > - / / } < nl > - / / < nl > + var searchRange = ( self . startIndex . . < self . endIndex ) < nl > + while true { < nl > + let found = self . range ( of : text , options : String . CompareOptions . caseInsensitive , range : searchRange , locale : nil ) < nl > + if found ! = nil { < nl > + res . append ( found ! ) < nl > + searchRange = ( found ! . upperBound . . < self . endIndex ) < nl > + } else { < nl > + break < nl > + } < nl > + } < nl > + < nl > return res < nl > } < nl > < nl > @ @ - 141 , 15 + 141 , 15 @ @ public extension String { < nl > < nl > public extension NSAttributedString { < nl > < nl > - public func append ( _ text : NSAttributedString ) - > NSAttributedString { < nl > + public func appendMutate ( _ text : NSAttributedString ) - > NSAttributedString { < nl > let res = NSMutableAttributedString ( ) < nl > - / / res . append ( self ) < nl > - / / res . append ( text ) < nl > + res . append ( self ) < nl > + res . append ( text ) < nl > return res < nl > } < nl > < nl > - public func append ( _ text : String , font : UIFont ) - > NSAttributedString { < nl > - return append ( NSAttributedString ( string : text , attributes : [ NSFontAttributeName : font ] ) ) < nl > + public func appendMutate ( _ text : String , font : UIFont ) - > NSAttributedString { < nl > + return self . appendMutate ( NSAttributedString ( string : text , attributes : [ NSFontAttributeName : font ] ) ) < nl > } < nl > < nl > public convenience init ( string : String , font : UIFont ) {
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift < nl > index 4f6f126 . . 3015679 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift < nl > @ @ - 4 , 6 + 4 , 7 @ @ < nl > < nl > import Foundation < nl > import AVFoundation < nl > + import YYText < nl > < nl > public var Actor : ACCocoaMessenger { < nl > get { < nl > @ @ - 268 , 30 + 269 , 42 @ @ class AAFileCallback : NSObject , ACFileCallback { < nl > / / Markdown < nl > / / < nl > < nl > - public class ARMDFormattedText { < nl > + / / public class ARMDFormattedText { < nl > + / / < nl > + / / public let isTrivial : Bool < nl > + / / public let attributedText : NSAttributedString < nl > + / / public let code : [ String ] < nl > + / / < nl > + / / public init ( attributedText : NSAttributedString , isTrivial : Bool , code : [ String ] ) { < nl > + / / self . attributedText = attributedText < nl > + / / self . code = code < nl > + / / self . isTrivial = isTrivial < nl > + / / } < nl > + / / } < nl > + < nl > + public class TextParser { < nl > < nl > - public let isTrivial : Bool < nl > - public let attributedText : NSAttributedString < nl > - public let code : [ String ] < nl > + public let textColor : UIColor < nl > + public let linkColor : UIColor < nl > + public let fontSize : CGFloat < nl > < nl > - public init ( attributedText : NSAttributedString , isTrivial : Bool , code : [ String ] ) { < nl > - self . attributedText = attributedText < nl > - self . code = code < nl > - self . isTrivial = isTrivial < nl > + private let markdownParser = ARMarkdownParser ( int : ARMarkdownParser _ MODE _ FULL ) < nl > + < nl > + public init ( textColor : UIColor , linkColor : UIColor , fontSize : CGFloat ) { < nl > + self . textColor = textColor < nl > + self . linkColor = linkColor < nl > + self . fontSize = fontSize < nl > } < nl > - } < nl > - < nl > - public extension ARMarkdownParser { < nl > < nl > - public func parse ( text : String , textColor : UIColor , fontSize : CGFloat ) - > ARMDFormattedText { < nl > + public func parse ( text : String ) - > ParsedText { < nl > + let doc = markdownParser . processDocumentWithNSString ( text ) < nl > < nl > - let doc = self . processDocumentWithNSString ( text ) < nl > if doc . isTrivial ( ) { < nl > let nAttrText = NSMutableAttributedString ( string : text ) < nl > let range = NSRange ( location : 0 , length : nAttrText . length ) < nl > nAttrText . yy _ setColor ( textColor , range : range ) < nl > nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > - return ARMDFormattedText ( attributedText : nAttrText , isTrivial : true , code : [ ] ) < nl > + return ParsedText ( attributedText : nAttrText , isTrivial : true , code : [ ] ) < nl > } < nl > < nl > var sources = [ String ] ( ) < nl > @ @ - 320 , 19 + 333 , 18 @ @ public extension ARMarkdownParser { < nl > } < nl > } < nl > < nl > - let range = NSRange ( location : 0 , length : nAttrText . length ) < nl > - nAttrText . yy _ setColor ( textColor , range : range ) < nl > - nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > - < nl > - return ARMDFormattedText ( attributedText : nAttrText , isTrivial : false , code : sources ) < nl > + return ParsedText ( attributedText : nAttrText , isTrivial : false , code : sources ) < nl > } < nl > < nl > private func buildText ( text : ARMDText , fontSize : CGFloat ) - > NSAttributedString { < nl > if let raw = text as ? ARMDRawText { < nl > - / / let res = NSMutableAttributedString ( string : raw . getRawText ( ) ) < nl > - / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : NSRange ( location : 0 , length : raw . getRawText ( ) . length ) ) < nl > - / / return res < nl > - return NSAttributedString ( string : raw . getRawText ( ) , font : UIFont . textFontOfSize ( fontSize ) ) < nl > + let res = NSMutableAttributedString ( string : raw . getRawText ( ) ) < nl > + let range = NSRange ( location : 0 , length : res . length ) < nl > + res . beginEditing ( ) < nl > + res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > + res . yy _ setColor ( textColor , range : range ) < nl > + res . endEditing ( ) < nl > + return res < nl > } else if let span = text as ? ARMDSpan { < nl > let res = NSMutableAttributedString ( ) < nl > res . beginEditing ( ) < nl > @ @ - 361 , 15 + 373 , 21 @ @ public extension ARMarkdownParser { < nl > if nsUrl ! = nil { < nl > let res = NSMutableAttributedString ( string : url . getUrlTitle ( ) ) < nl > let range = NSRange ( location : 0 , length : res . length ) < nl > - res . yy _ setTextHighlightRange ( range , color : UIColor . redColor ( ) , backgroundColor : nil , tapAction : nil ) < nl > + let highlight = YYTextHighlight ( ) < nl > + highlight . userInfo = [ " url " : url . getUrl ( ) ] < nl > + res . yy _ setTextHighlight ( highlight , range : range ) < nl > res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > + res . yy _ setColor ( linkColor , range : range ) < nl > return res < nl > - / / let attributes = [ NSLinkAttributeName : nsUrl as ! AnyObject , < nl > - / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] < nl > - / / return NSAttributedString ( string : url . getUrlTitle ( ) , attributes : attributes ) < nl > } else { < nl > / / Unable to parse : show as text < nl > - return NSAttributedString ( string : url . getUrlTitle ( ) , font : UIFont . textFontOfSize ( fontSize ) ) < nl > + let res = NSMutableAttributedString ( string : url . getUrlTitle ( ) ) < nl > + let range = NSRange ( location : 0 , length : res . length ) < nl > + res . beginEditing ( ) < nl > + res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > + res . yy _ setColor ( textColor , range : range ) < nl > + res . endEditing ( ) < nl > + return res < nl > } < nl > } else { < nl > fatalError ( " Unsupported text type " ) < nl > @ @ - 377 , 6 + 395 , 128 @ @ public extension ARMarkdownParser { < nl > } < nl > } < nl > < nl > + public class ParsedText { < nl > + < nl > + public let isTrivial : Bool < nl > + public let attributedText : NSAttributedString < nl > + public let code : [ String ] < nl > + < nl > + public init ( attributedText : NSAttributedString , isTrivial : Bool , code : [ String ] ) { < nl > + self . attributedText = attributedText < nl > + self . code = code < nl > + self . isTrivial = isTrivial < nl > + } < nl > + } < nl > + / / < nl > + / / public extension ARMarkdownParser { < nl > + / / < nl > + / / public func parse ( text : String , textColor : UIColor , fontSize : CGFloat ) - > ARMDFormattedText { < nl > + / / < nl > + / / let doc = self . processDocumentWithNSString ( text ) < nl > + / / if doc . isTrivial ( ) { < nl > + / / let nAttrText = NSMutableAttributedString ( string : text ) < nl > + / / let range = NSRange ( location : 0 , length : nAttrText . length ) < nl > + / / nAttrText . yy _ setColor ( textColor , range : range ) < nl > + / / nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > + / / return ARMDFormattedText ( attributedText : nAttrText , isTrivial : true , code : [ ] ) < nl > + / / } < nl > + / / < nl > + / / var sources = [ String ] ( ) < nl > + / / < nl > + / / let sections : [ ARMDSection ] = doc . getSections ( ) . toSwiftArray ( ) < nl > + / / let nAttrText = NSMutableAttributedString ( ) < nl > + / / var isFirst = true < nl > + / / for s in sections { < nl > + / / if ! isFirst { < nl > + / / nAttrText . appendAttributedString ( NSAttributedString ( string : " \ n " ) ) < nl > + / / } < nl > + / / isFirst = false < nl > + / / < nl > + / / if s . getType ( ) = = ARMDSection _ TYPE _ CODE { < nl > + / / let attributes = [ NSLinkAttributeName : NSURL ( string : " source : / / / \ ( sources . count ) " ) as ! AnyObject , < nl > + / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] < nl > + / / nAttrText . appendAttributedString ( NSAttributedString ( string : " Open Code " , attributes : attributes ) ) < nl > + / / sources . append ( s . getCode ( ) . getCode ( ) ) < nl > + / / } else if s . getType ( ) = = ARMDSection _ TYPE _ TEXT { < nl > + / / let child : [ ARMDText ] = s . getText ( ) . toSwiftArray ( ) < nl > + / / for c in child { < nl > + / / nAttrText . appendAttributedString ( buildText ( c , fontSize : fontSize ) ) < nl > + / / } < nl > + / / } else { < nl > + / / fatalError ( " Unsupported section type " ) < nl > + / / } < nl > + / / } < nl > + / / < nl > + / / / / let range = NSRange ( location : 0 , length : nAttrText . length ) < nl > + / / < nl > + / / / / nAttrText . yy _ setColor ( textColor , range : range ) < nl > + / / / / nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > + / / < nl > + / / / / nAttrText . enumerateAttributesInRange ( range , options : NSAttributedStringEnumerationOptions . LongestEffectiveRangeNotRequired ) { ( attrs , range , objBool ) - > Void in < nl > + / / / / var attributeDictionary = NSDictionary ( dictionary : attrs ) < nl > + / / / / < nl > + / / / / for k in attributeDictionary . allKeys { < nl > + / / / / let v = attributeDictionary . objectForKey ( k ) < nl > + / / / / < nl > + / / / / print ( " attr : \ ( k ) - > \ ( v ) at \ ( range ) " ) < nl > + / / / / } < nl > + / / / / } < nl > + / / / / < nl > + / / return ARMDFormattedText ( attributedText : nAttrText , isTrivial : false , code : sources ) < nl > + / / } < nl > + / / < nl > + / / private func buildText ( text : ARMDText , fontSize : CGFloat ) - > NSAttributedString { < nl > + / / if let raw = text as ? ARMDRawText { < nl > + / / / / let res = NSMutableAttributedString ( string : raw . getRawText ( ) ) < nl > + / / / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : NSRange ( location : 0 , length : raw . getRawText ( ) . length ) ) < nl > + / / / / return res < nl > + / / return NSAttributedString ( string : raw . getRawText ( ) , font : UIFont . textFontOfSize ( fontSize ) ) < nl > + / / } else if let span = text as ? ARMDSpan { < nl > + / / let res = NSMutableAttributedString ( ) < nl > + / / res . beginEditing ( ) < nl > + / / < nl > + / / / / Processing child texts < nl > + / / let child : [ ARMDText ] = span . getChild ( ) . toSwiftArray ( ) < nl > + / / for c in child { < nl > + / / res . appendAttributedString ( buildText ( c , fontSize : fontSize ) ) < nl > + / / } < nl > + / / < nl > + / / / / Setting span elements < nl > + / / if span . getSpanType ( ) = = ARMDSpan _ TYPE _ BOLD { < nl > + / / res . appendFont ( UIFont . boldSystemFontOfSize ( fontSize ) ) < nl > + / / } else if span . getSpanType ( ) = = ARMDSpan _ TYPE _ ITALIC { < nl > + / / res . appendFont ( UIFont . italicSystemFontOfSize ( fontSize ) ) < nl > + / / } else { < nl > + / / fatalError ( " Unsupported span type " ) < nl > + / / } < nl > + / / < nl > + / / res . endEditing ( ) < nl > + / / return res < nl > + / / } else if let url = text as ? ARMDUrl { < nl > + / / < nl > + / / / / Parsing url element < nl > + / / let nsUrl = NSURL ( string : url . getUrl ( ) ) < nl > + / / if nsUrl ! = nil { < nl > + / / let res = NSMutableAttributedString ( string : url . getUrlTitle ( ) ) < nl > + / / let range = NSRange ( location : 0 , length : res . length ) < nl > + / / let highlight = YYTextHighlight ( ) < nl > + / / / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) < nl > + / / / / res . yy _ setTextHighlightRange ( range , color : UIColor . redColor ( ) , backgroundColor : nil , tapAction : nil ) < nl > + / / / / res . yy _ setColor ( UIColor . greenColor ( ) , range : range ) < nl > + / / return res < nl > + / / / / let attributes = [ NSLinkAttributeName : nsUrl as ! AnyObject , < nl > + / / / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] < nl > + / / / / return NSAttributedString ( string : url . getUrlTitle ( ) , attributes : attributes ) < nl > + / / } else { < nl > + / / / / Unable to parse : show as text < nl > + / / return NSAttributedString ( string : url . getUrlTitle ( ) , font : UIFont . textFontOfSize ( fontSize ) ) < nl > + / / } < nl > + / / } else { < nl > + / / fatalError ( " Unsupported text type " ) < nl > + / / } < nl > + / / } < nl > + / / } < nl > + / / < nl > / / < nl > / / Promises < nl > / / < nl > diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorSDK . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorSDK . swift < nl > index 4ea5860 . . bbcd2e5 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorSDK . swift < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorSDK . swift < nl > @ @ - 5 , 6 + 5 , 8 @ @ < nl > import Foundation < nl > import JDStatusBarNotification < nl > import PushKit < nl > + import SafariServices < nl > + import DZNWebViewController < nl > < nl > @ objc public class ActorSDK : NSObject , PKPushRegistryDelegate { < nl > < nl > @ @ - 517 , 7 + 519 , 29 @ @ import PushKit < nl > return < nl > } < nl > < nl > - UIApplication . sharedApplication ( ) . openURL ( u ) < nl > + if let bindedController = bindedToWindow ? . rootViewController { < nl > + / / Dismiss Old Presented Controller to show new one < nl > + if let presented = bindedController . presentedViewController { < nl > + presented . dismissViewControllerAnimated ( true , completion : nil ) < nl > + } < nl > + < nl > + / / Building Controller for Web preview < nl > + let controller : UIViewController < nl > + if # available ( iOS 9 . 0 , * ) { < nl > + controller = SFSafariViewController ( URL : u ) < nl > + } else { < nl > + controller = AANavigationController ( rootViewController : DZNWebViewController ( URL : u ) ) < nl > + } < nl > + if AADevice . isiPad { < nl > + controller . modalPresentationStyle = . FullScreen < nl > + } < nl > + < nl > + / / Presenting controller < nl > + bindedController . presentViewController ( controller , animated : true , completion : nil ) < nl > + } else { < nl > + / / Just Fallback . Might never happend < nl > + UIApplication . sharedApplication ( ) . openURL ( u ) < nl > + } < nl > } < nl > } < nl > < nl > diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Content / Conversation / Cell / AABubbleTextCell . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Content / Conversation / Cell / AABubbleTextCell . swift < nl > index 79a48d9 . . b831ee8 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Content / Conversation / Cell / AABubbleTextCell . swift < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Content / Conversation / Cell / AABubbleTextCell . swift < nl > @ @ - 41 , 6 + 41 , 14 @ @ public class AABubbleTextCell : AABubbleCell { < nl > < nl > messageText . displaysAsynchronously = true < nl > messageText . ignoreCommonProperties = true < nl > + messageText . highlightTapAction = { ( containerView : UIView , text : NSAttributedString , range : NSRange , rect : CGRect ) - > ( ) in < nl > + let attributes = text . attributesAtIndex ( range . location , effectiveRange : nil ) < nl > + if let attrs = attributes [ " YYTextHighlight " ] as ? YYTextHighlight { < nl > + if let url = attrs . userInfo ! [ " url " ] as ? String { < nl > + self . openUrl ( NSURL ( string : url ) ! ) < nl > + } < nl > + } < nl > + } < nl > < nl > senderNameLabel . displaysAsynchronously = true < nl > senderNameLabel . ignoreCommonProperties = true < nl > @ @ - 49 , 7 + 57 , 6 @ @ public class AABubbleTextCell : AABubbleCell { < nl > dateText . displaysAsynchronously = true < nl > dateText . lineBreakMode = . ByClipping < nl > dateText . numberOfLines = 1 < nl > - / / dateText . contentMode = . TopLeft < nl > dateText . textAlignment = . Right < nl > < nl > statusView . contentMode = UIViewContentMode . Center < nl > @ @ - 194 , 16 + 201 , 18 @ @ public class AABubbleTextCell : AABubbleCell { < nl > / / openUrl ( url ) < nl > / / } < nl > / / < nl > - / / public func openUrl ( url : NSURL ) { < nl > - / / if url . scheme = = " source " { < nl > - / / let path = url . path ! < nl > - / / let index = Int ( path . substringFromIndex ( path . startIndex . advancedBy ( 1 ) ) ) ! < nl > - / / let code = self . cellLayout . sources [ index ] < nl > - / / self . controller . navigateNext ( AACodePreviewController ( code : code ) , removeCurrent : false ) < nl > - / / } else { < nl > - / / ActorSDK . sharedActor ( ) . openUrl ( url . absoluteString ) < nl > - / / } < nl > - / / } < nl > + public func openUrl ( url : NSURL ) { < nl > + if url . scheme = = " source " { < nl > + let path = url . path ! < nl > + let index = Int ( path . substringFromIndex ( path . startIndex . advancedBy ( 1 ) ) ) ! < nl > + let code = self . cellLayout . sources [ index ] < nl > + self . controller . navigateNext ( AACodePreviewController ( code : code ) , removeCurrent : false ) < nl > + } else if url . scheme = = " send " { < nl > + Actor . sendMessageWithPeer ( self . peer , withText : url . path ! ) < nl > + } else { < nl > + ActorSDK . sharedActor ( ) . openUrl ( url . absoluteString ) < nl > + } < nl > + } < nl > < nl > / / Layouting < nl > < nl > @ @ - 395 , 7 + 404 , 8 @ @ public class TextCellLayout : AACellLayout { < nl > public convenience init ( senderId : Int , formattedText : String , textColor : UIColor , date : Int64 , isOut : Bool , peer : ACPeer , layoutKey : String = TextCellLayout . textKey ) { < nl > < nl > / / Parsing markdown formatted text < nl > - let text = TextCellLayout . parser . parse ( formattedText , textColor : textColor , fontSize : AABubbleTextCell . fontSize ) < nl > + let parser = TextParser ( textColor : textColor , linkColor : ActorSDK . sharedActor ( ) . style . chatUrlColor , fontSize : AABubbleTextCell . fontSize ) < nl > + let text = parser . parse ( formattedText ) < nl > < nl > / / Creating attributed text layout < nl > self . init ( senderId : senderId , text : formattedText , attributedText : text . attributedText , date : date , isOut : isOut , peer : peer , layoutKey : layoutKey )

TEST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift 
 index 8e52a80 . . 227689b 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift 
 @ @ - 271 , 19 + 271 , 6 @ @ class AAFileCallback : NSObject , ACFileCallback { 
 / / Markdown 
 / / 
 
 - / / public class ARMDFormattedText { 
 - / / 
 - / / public let isTrivial : Bool 
 - / / public let attributedText : NSAttributedString 
 - / / public let code : [ String ] 
 - / / 
 - / / public init ( attributedText : NSAttributedString , isTrivial : Bool , code : [ String ] ) { 
 - / / self . attributedText = attributedText 
 - / / self . code = code 
 - / / self . isTrivial = isTrivial 
 - / / } 
 - / / } 
 - 
 open class TextParser { 
 
 open let textColor : UIColor 
 @ @ - 316 , 7 + 303 , 7 @ @ open class TextParser { 
 var isFirst = true 
 for s in sections { 
 if ! isFirst { 
 - / / nAttrText . append ( NSAttributedString ( string : " \ n " ) ) 
 + nAttrText . append ( NSAttributedString ( string : " \ n " ) ) 
 } 
 isFirst = false 
 
 @ @ - 331 , 13 + 318 , 13 @ @ open class TextParser { 
 str . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 str . yy _ setColor ( linkColor , range : range ) 
 
 - / / nAttrText . append ( str ) 
 + nAttrText . append ( str ) 
 
 sources . append ( s . getCode ( ) . getCode ( ) ) 
 } else if s . getType ( ) = = ARMDSection _ TYPE _ TEXT { 
 let child : [ ARMDText ] = s . getText ( ) . toSwiftArray ( ) 
 for c in child { 
 - / / nAttrText . append ( buildText ( c , fontSize : fontSize ) ) 
 + nAttrText . append ( buildText ( c , fontSize : fontSize ) ) 
 } 
 } else { 
 fatalError ( " Unsupported section type " ) 
 @ @ - 363 , 7 + 350 , 7 @ @ open class TextParser { 
 / / Processing child texts 
 let child : [ ARMDText ] = span . getChild ( ) . toSwiftArray ( ) 
 for c in child { 
 - / / res . append ( buildText ( c , fontSize : fontSize ) ) 
 + res . append ( buildText ( c , fontSize : fontSize ) ) 
 } 
 
 / / Setting span elements 
 @ @ - 418 , 116 + 405 , 7 @ @ open class ParsedText { 
 self . isTrivial = isTrivial 
 } 
 } 
 - / / 
 - / / public extension ARMarkdownParser { 
 - / / 
 - / / public func parse ( text : String , textColor : UIColor , fontSize : CGFloat ) - > ARMDFormattedText { 
 - / / 
 - / / let doc = self . processDocumentWithNSString ( text ) 
 - / / if doc . isTrivial ( ) { 
 - / / let nAttrText = NSMutableAttributedString ( string : text ) 
 - / / let range = NSRange ( location : 0 , length : nAttrText . length ) 
 - / / nAttrText . yy _ setColor ( textColor , range : range ) 
 - / / nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 - / / return ARMDFormattedText ( attributedText : nAttrText , isTrivial : true , code : [ ] ) 
 - / / } 
 - / / 
 - / / var sources = [ String ] ( ) 
 - / / 
 - / / let sections : [ ARMDSection ] = doc . getSections ( ) . toSwiftArray ( ) 
 - / / let nAttrText = NSMutableAttributedString ( ) 
 - / / var isFirst = true 
 - / / for s in sections { 
 - / / if ! isFirst { 
 - / / nAttrText . appendAttributedString ( NSAttributedString ( string : " \ n " ) ) 
 - / / } 
 - / / isFirst = false 
 - / / 
 - / / if s . getType ( ) = = ARMDSection _ TYPE _ CODE { 
 - / / let attributes = [ NSLinkAttributeName : NSURL ( string : " source : / / / \ ( sources . count ) " ) as ! AnyObject , 
 - / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] 
 - / / nAttrText . appendAttributedString ( NSAttributedString ( string : " Open Code " , attributes : attributes ) ) 
 - / / sources . append ( s . getCode ( ) . getCode ( ) ) 
 - / / } else if s . getType ( ) = = ARMDSection _ TYPE _ TEXT { 
 - / / let child : [ ARMDText ] = s . getText ( ) . toSwiftArray ( ) 
 - / / for c in child { 
 - / / nAttrText . appendAttributedString ( buildText ( c , fontSize : fontSize ) ) 
 - / / } 
 - / / } else { 
 - / / fatalError ( " Unsupported section type " ) 
 - / / } 
 - / / } 
 - / / 
 - / / / / let range = NSRange ( location : 0 , length : nAttrText . length ) 
 - / / 
 - / / / / nAttrText . yy _ setColor ( textColor , range : range ) 
 - / / / / nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 - / / 
 - / / / / nAttrText . enumerateAttributesInRange ( range , options : NSAttributedStringEnumerationOptions . LongestEffectiveRangeNotRequired ) { ( attrs , range , objBool ) - > Void in 
 - / / / / var attributeDictionary = NSDictionary ( dictionary : attrs ) 
 - / / / / 
 - / / / / for k in attributeDictionary . allKeys { 
 - / / / / let v = attributeDictionary . objectForKey ( k ) 
 - / / / / 
 - / / / / print ( " attr : \ ( k ) - > \ ( v ) at \ ( range ) " ) 
 - / / / / } 
 - / / / / } 
 - / / / / 
 - / / return ARMDFormattedText ( attributedText : nAttrText , isTrivial : false , code : sources ) 
 - / / } 
 - / / 
 - / / private func buildText ( text : ARMDText , fontSize : CGFloat ) - > NSAttributedString { 
 - / / if let raw = text as ? ARMDRawText { 
 - / / / / let res = NSMutableAttributedString ( string : raw . getRawText ( ) ) 
 - / / / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : NSRange ( location : 0 , length : raw . getRawText ( ) . length ) ) 
 - / / / / return res 
 - / / return NSAttributedString ( string : raw . getRawText ( ) , font : UIFont . textFontOfSize ( fontSize ) ) 
 - / / } else if let span = text as ? ARMDSpan { 
 - / / let res = NSMutableAttributedString ( ) 
 - / / res . beginEditing ( ) 
 - / / 
 - / / / / Processing child texts 
 - / / let child : [ ARMDText ] = span . getChild ( ) . toSwiftArray ( ) 
 - / / for c in child { 
 - / / res . appendAttributedString ( buildText ( c , fontSize : fontSize ) ) 
 - / / } 
 - / / 
 - / / / / Setting span elements 
 - / / if span . getSpanType ( ) = = ARMDSpan _ TYPE _ BOLD { 
 - / / res . appendFont ( UIFont . boldSystemFontOfSize ( fontSize ) ) 
 - / / } else if span . getSpanType ( ) = = ARMDSpan _ TYPE _ ITALIC { 
 - / / res . appendFont ( UIFont . italicSystemFontOfSize ( fontSize ) ) 
 - / / } else { 
 - / / fatalError ( " Unsupported span type " ) 
 - / / } 
 - / / 
 - / / res . endEditing ( ) 
 - / / return res 
 - / / } else if let url = text as ? ARMDUrl { 
 - / / 
 - / / / / Parsing url element 
 - / / let nsUrl = NSURL ( string : url . getUrl ( ) ) 
 - / / if nsUrl ! = nil { 
 - / / let res = NSMutableAttributedString ( string : url . getUrlTitle ( ) ) 
 - / / let range = NSRange ( location : 0 , length : res . length ) 
 - / / let highlight = YYTextHighlight ( ) 
 - / / / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 - / / / / res . yy _ setTextHighlightRange ( range , color : UIColor . redColor ( ) , backgroundColor : nil , tapAction : nil ) 
 - / / / / res . yy _ setColor ( UIColor . greenColor ( ) , range : range ) 
 - / / return res 
 - / / / / let attributes = [ NSLinkAttributeName : nsUrl as ! AnyObject , 
 - / / / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] 
 - / / / / return NSAttributedString ( string : url . getUrlTitle ( ) , attributes : attributes ) 
 - / / } else { 
 - / / / / Unable to parse : show as text 
 - / / return NSAttributedString ( string : url . getUrlTitle ( ) , font : UIFont . textFontOfSize ( fontSize ) ) 
 - / / } 
 - / / } else { 
 - / / fatalError ( " Unsupported text type " ) 
 - / / } 
 - / / } 
 - / / } 
 - / / 
 + 
 / / 
 / / Promises 
 / / 
 diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / SwiftExtensions / Strings . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / SwiftExtensions / Strings . swift 
 index 65a8c2e . . bc70feb 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / SwiftExtensions / Strings . swift 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / SwiftExtensions / Strings . swift 
 @ @ - 97 , 17 + 97 , 17 @ @ public extension String { 
 public func rangesOfString ( _ text : String ) - > [ Range < String . Index > ] { 
 var res = [ Range < String . Index > ] ( ) 
 
 - / / var searchRange = ( self . characters . indices ) 
 - / / while true { 
 - / / let found = self . range ( of : text , options : NSString . CompareOptions . caseInsensitive , range : searchRange , locale : nil ) 
 - / / if found ! = nil { 
 - / / res . append ( found ! ) 
 - / / searchRange = ( found ! . upperBound . . < self . endIndex ) 
 - / / } else { 
 - / / break 
 - / / } 
 - / / } 
 - / / 
 + var searchRange = ( self . startIndex . . < self . endIndex ) 
 + while true { 
 + let found = self . range ( of : text , options : String . CompareOptions . caseInsensitive , range : searchRange , locale : nil ) 
 + if found ! = nil { 
 + res . append ( found ! ) 
 + searchRange = ( found ! . upperBound . . < self . endIndex ) 
 + } else { 
 + break 
 + } 
 + } 
 + 
 return res 
 } 
 
 @ @ - 141 , 15 + 141 , 15 @ @ public extension String { 
 
 public extension NSAttributedString { 
 
 - public func append ( _ text : NSAttributedString ) - > NSAttributedString { 
 + public func appendMutate ( _ text : NSAttributedString ) - > NSAttributedString { 
 let res = NSMutableAttributedString ( ) 
 - / / res . append ( self ) 
 - / / res . append ( text ) 
 + res . append ( self ) 
 + res . append ( text ) 
 return res 
 } 
 
 - public func append ( _ text : String , font : UIFont ) - > NSAttributedString { 
 - return append ( NSAttributedString ( string : text , attributes : [ NSFontAttributeName : font ] ) ) 
 + public func appendMutate ( _ text : String , font : UIFont ) - > NSAttributedString { 
 + return self . appendMutate ( NSAttributedString ( string : text , attributes : [ NSFontAttributeName : font ] ) ) 
 } 
 
 public convenience init ( string : String , font : UIFont ) {

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift 
 index 4f6f126 . . 3015679 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / ActorCoreExt . swift 
 @ @ - 4 , 6 + 4 , 7 @ @ 
 
 import Foundation 
 import AVFoundation 
 + import YYText 
 
 public var Actor : ACCocoaMessenger { 
 get { 
 @ @ - 268 , 30 + 269 , 42 @ @ class AAFileCallback : NSObject , ACFileCallback { 
 / / Markdown 
 / / 
 
 - public class ARMDFormattedText { 
 + / / public class ARMDFormattedText { 
 + / / 
 + / / public let isTrivial : Bool 
 + / / public let attributedText : NSAttributedString 
 + / / public let code : [ String ] 
 + / / 
 + / / public init ( attributedText : NSAttributedString , isTrivial : Bool , code : [ String ] ) { 
 + / / self . attributedText = attributedText 
 + / / self . code = code 
 + / / self . isTrivial = isTrivial 
 + / / } 
 + / / } 
 + 
 + public class TextParser { 
 
 - public let isTrivial : Bool 
 - public let attributedText : NSAttributedString 
 - public let code : [ String ] 
 + public let textColor : UIColor 
 + public let linkColor : UIColor 
 + public let fontSize : CGFloat 
 
 - public init ( attributedText : NSAttributedString , isTrivial : Bool , code : [ String ] ) { 
 - self . attributedText = attributedText 
 - self . code = code 
 - self . isTrivial = isTrivial 
 + private let markdownParser = ARMarkdownParser ( int : ARMarkdownParser _ MODE _ FULL ) 
 + 
 + public init ( textColor : UIColor , linkColor : UIColor , fontSize : CGFloat ) { 
 + self . textColor = textColor 
 + self . linkColor = linkColor 
 + self . fontSize = fontSize 
 } 
 - } 
 - 
 - public extension ARMarkdownParser { 
 
 - public func parse ( text : String , textColor : UIColor , fontSize : CGFloat ) - > ARMDFormattedText { 
 + public func parse ( text : String ) - > ParsedText { 
 + let doc = markdownParser . processDocumentWithNSString ( text ) 
 
 - let doc = self . processDocumentWithNSString ( text ) 
 if doc . isTrivial ( ) { 
 let nAttrText = NSMutableAttributedString ( string : text ) 
 let range = NSRange ( location : 0 , length : nAttrText . length ) 
 nAttrText . yy _ setColor ( textColor , range : range ) 
 nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 - return ARMDFormattedText ( attributedText : nAttrText , isTrivial : true , code : [ ] ) 
 + return ParsedText ( attributedText : nAttrText , isTrivial : true , code : [ ] ) 
 } 
 
 var sources = [ String ] ( ) 
 @ @ - 320 , 19 + 333 , 18 @ @ public extension ARMarkdownParser { 
 } 
 } 
 
 - let range = NSRange ( location : 0 , length : nAttrText . length ) 
 - nAttrText . yy _ setColor ( textColor , range : range ) 
 - nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 - 
 - return ARMDFormattedText ( attributedText : nAttrText , isTrivial : false , code : sources ) 
 + return ParsedText ( attributedText : nAttrText , isTrivial : false , code : sources ) 
 } 
 
 private func buildText ( text : ARMDText , fontSize : CGFloat ) - > NSAttributedString { 
 if let raw = text as ? ARMDRawText { 
 - / / let res = NSMutableAttributedString ( string : raw . getRawText ( ) ) 
 - / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : NSRange ( location : 0 , length : raw . getRawText ( ) . length ) ) 
 - / / return res 
 - return NSAttributedString ( string : raw . getRawText ( ) , font : UIFont . textFontOfSize ( fontSize ) ) 
 + let res = NSMutableAttributedString ( string : raw . getRawText ( ) ) 
 + let range = NSRange ( location : 0 , length : res . length ) 
 + res . beginEditing ( ) 
 + res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 + res . yy _ setColor ( textColor , range : range ) 
 + res . endEditing ( ) 
 + return res 
 } else if let span = text as ? ARMDSpan { 
 let res = NSMutableAttributedString ( ) 
 res . beginEditing ( ) 
 @ @ - 361 , 15 + 373 , 21 @ @ public extension ARMarkdownParser { 
 if nsUrl ! = nil { 
 let res = NSMutableAttributedString ( string : url . getUrlTitle ( ) ) 
 let range = NSRange ( location : 0 , length : res . length ) 
 - res . yy _ setTextHighlightRange ( range , color : UIColor . redColor ( ) , backgroundColor : nil , tapAction : nil ) 
 + let highlight = YYTextHighlight ( ) 
 + highlight . userInfo = [ " url " : url . getUrl ( ) ] 
 + res . yy _ setTextHighlight ( highlight , range : range ) 
 res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 + res . yy _ setColor ( linkColor , range : range ) 
 return res 
 - / / let attributes = [ NSLinkAttributeName : nsUrl as ! AnyObject , 
 - / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] 
 - / / return NSAttributedString ( string : url . getUrlTitle ( ) , attributes : attributes ) 
 } else { 
 / / Unable to parse : show as text 
 - return NSAttributedString ( string : url . getUrlTitle ( ) , font : UIFont . textFontOfSize ( fontSize ) ) 
 + let res = NSMutableAttributedString ( string : url . getUrlTitle ( ) ) 
 + let range = NSRange ( location : 0 , length : res . length ) 
 + res . beginEditing ( ) 
 + res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 + res . yy _ setColor ( textColor , range : range ) 
 + res . endEditing ( ) 
 + return res 
 } 
 } else { 
 fatalError ( " Unsupported text type " ) 
 @ @ - 377 , 6 + 395 , 128 @ @ public extension ARMarkdownParser { 
 } 
 } 
 
 + public class ParsedText { 
 + 
 + public let isTrivial : Bool 
 + public let attributedText : NSAttributedString 
 + public let code : [ String ] 
 + 
 + public init ( attributedText : NSAttributedString , isTrivial : Bool , code : [ String ] ) { 
 + self . attributedText = attributedText 
 + self . code = code 
 + self . isTrivial = isTrivial 
 + } 
 + } 
 + / / 
 + / / public extension ARMarkdownParser { 
 + / / 
 + / / public func parse ( text : String , textColor : UIColor , fontSize : CGFloat ) - > ARMDFormattedText { 
 + / / 
 + / / let doc = self . processDocumentWithNSString ( text ) 
 + / / if doc . isTrivial ( ) { 
 + / / let nAttrText = NSMutableAttributedString ( string : text ) 
 + / / let range = NSRange ( location : 0 , length : nAttrText . length ) 
 + / / nAttrText . yy _ setColor ( textColor , range : range ) 
 + / / nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 + / / return ARMDFormattedText ( attributedText : nAttrText , isTrivial : true , code : [ ] ) 
 + / / } 
 + / / 
 + / / var sources = [ String ] ( ) 
 + / / 
 + / / let sections : [ ARMDSection ] = doc . getSections ( ) . toSwiftArray ( ) 
 + / / let nAttrText = NSMutableAttributedString ( ) 
 + / / var isFirst = true 
 + / / for s in sections { 
 + / / if ! isFirst { 
 + / / nAttrText . appendAttributedString ( NSAttributedString ( string : " \ n " ) ) 
 + / / } 
 + / / isFirst = false 
 + / / 
 + / / if s . getType ( ) = = ARMDSection _ TYPE _ CODE { 
 + / / let attributes = [ NSLinkAttributeName : NSURL ( string : " source : / / / \ ( sources . count ) " ) as ! AnyObject , 
 + / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] 
 + / / nAttrText . appendAttributedString ( NSAttributedString ( string : " Open Code " , attributes : attributes ) ) 
 + / / sources . append ( s . getCode ( ) . getCode ( ) ) 
 + / / } else if s . getType ( ) = = ARMDSection _ TYPE _ TEXT { 
 + / / let child : [ ARMDText ] = s . getText ( ) . toSwiftArray ( ) 
 + / / for c in child { 
 + / / nAttrText . appendAttributedString ( buildText ( c , fontSize : fontSize ) ) 
 + / / } 
 + / / } else { 
 + / / fatalError ( " Unsupported section type " ) 
 + / / } 
 + / / } 
 + / / 
 + / / / / let range = NSRange ( location : 0 , length : nAttrText . length ) 
 + / / 
 + / / / / nAttrText . yy _ setColor ( textColor , range : range ) 
 + / / / / nAttrText . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 + / / 
 + / / / / nAttrText . enumerateAttributesInRange ( range , options : NSAttributedStringEnumerationOptions . LongestEffectiveRangeNotRequired ) { ( attrs , range , objBool ) - > Void in 
 + / / / / var attributeDictionary = NSDictionary ( dictionary : attrs ) 
 + / / / / 
 + / / / / for k in attributeDictionary . allKeys { 
 + / / / / let v = attributeDictionary . objectForKey ( k ) 
 + / / / / 
 + / / / / print ( " attr : \ ( k ) - > \ ( v ) at \ ( range ) " ) 
 + / / / / } 
 + / / / / } 
 + / / / / 
 + / / return ARMDFormattedText ( attributedText : nAttrText , isTrivial : false , code : sources ) 
 + / / } 
 + / / 
 + / / private func buildText ( text : ARMDText , fontSize : CGFloat ) - > NSAttributedString { 
 + / / if let raw = text as ? ARMDRawText { 
 + / / / / let res = NSMutableAttributedString ( string : raw . getRawText ( ) ) 
 + / / / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : NSRange ( location : 0 , length : raw . getRawText ( ) . length ) ) 
 + / / / / return res 
 + / / return NSAttributedString ( string : raw . getRawText ( ) , font : UIFont . textFontOfSize ( fontSize ) ) 
 + / / } else if let span = text as ? ARMDSpan { 
 + / / let res = NSMutableAttributedString ( ) 
 + / / res . beginEditing ( ) 
 + / / 
 + / / / / Processing child texts 
 + / / let child : [ ARMDText ] = span . getChild ( ) . toSwiftArray ( ) 
 + / / for c in child { 
 + / / res . appendAttributedString ( buildText ( c , fontSize : fontSize ) ) 
 + / / } 
 + / / 
 + / / / / Setting span elements 
 + / / if span . getSpanType ( ) = = ARMDSpan _ TYPE _ BOLD { 
 + / / res . appendFont ( UIFont . boldSystemFontOfSize ( fontSize ) ) 
 + / / } else if span . getSpanType ( ) = = ARMDSpan _ TYPE _ ITALIC { 
 + / / res . appendFont ( UIFont . italicSystemFontOfSize ( fontSize ) ) 
 + / / } else { 
 + / / fatalError ( " Unsupported span type " ) 
 + / / } 
 + / / 
 + / / res . endEditing ( ) 
 + / / return res 
 + / / } else if let url = text as ? ARMDUrl { 
 + / / 
 + / / / / Parsing url element 
 + / / let nsUrl = NSURL ( string : url . getUrl ( ) ) 
 + / / if nsUrl ! = nil { 
 + / / let res = NSMutableAttributedString ( string : url . getUrlTitle ( ) ) 
 + / / let range = NSRange ( location : 0 , length : res . length ) 
 + / / let highlight = YYTextHighlight ( ) 
 + / / / / res . yy _ setFont ( UIFont . textFontOfSize ( fontSize ) , range : range ) 
 + / / / / res . yy _ setTextHighlightRange ( range , color : UIColor . redColor ( ) , backgroundColor : nil , tapAction : nil ) 
 + / / / / res . yy _ setColor ( UIColor . greenColor ( ) , range : range ) 
 + / / return res 
 + / / / / let attributes = [ NSLinkAttributeName : nsUrl as ! AnyObject , 
 + / / / / NSFontAttributeName : UIFont . textFontOfSize ( fontSize ) ] 
 + / / / / return NSAttributedString ( string : url . getUrlTitle ( ) , attributes : attributes ) 
 + / / } else { 
 + / / / / Unable to parse : show as text 
 + / / return NSAttributedString ( string : url . getUrlTitle ( ) , font : UIFont . textFontOfSize ( fontSize ) ) 
 + / / } 
 + / / } else { 
 + / / fatalError ( " Unsupported text type " ) 
 + / / } 
 + / / } 
 + / / } 
 + / / 
 / / 
 / / Promises 
 / / 
 diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorSDK . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorSDK . swift 
 index 4ea5860 . . bbcd2e5 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorSDK . swift 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorSDK . swift 
 @ @ - 5 , 6 + 5 , 8 @ @ 
 import Foundation 
 import JDStatusBarNotification 
 import PushKit 
 + import SafariServices 
 + import DZNWebViewController 
 
 @ objc public class ActorSDK : NSObject , PKPushRegistryDelegate { 
 
 @ @ - 517 , 7 + 519 , 29 @ @ import PushKit 
 return 
 } 
 
 - UIApplication . sharedApplication ( ) . openURL ( u ) 
 + if let bindedController = bindedToWindow ? . rootViewController { 
 + / / Dismiss Old Presented Controller to show new one 
 + if let presented = bindedController . presentedViewController { 
 + presented . dismissViewControllerAnimated ( true , completion : nil ) 
 + } 
 + 
 + / / Building Controller for Web preview 
 + let controller : UIViewController 
 + if # available ( iOS 9 . 0 , * ) { 
 + controller = SFSafariViewController ( URL : u ) 
 + } else { 
 + controller = AANavigationController ( rootViewController : DZNWebViewController ( URL : u ) ) 
 + } 
 + if AADevice . isiPad { 
 + controller . modalPresentationStyle = . FullScreen 
 + } 
 + 
 + / / Presenting controller 
 + bindedController . presentViewController ( controller , animated : true , completion : nil ) 
 + } else { 
 + / / Just Fallback . Might never happend 
 + UIApplication . sharedApplication ( ) . openURL ( u ) 
 + } 
 } 
 } 
 
 diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Content / Conversation / Cell / AABubbleTextCell . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Content / Conversation / Cell / AABubbleTextCell . swift 
 index 79a48d9 . . b831ee8 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Content / Conversation / Cell / AABubbleTextCell . swift 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Content / Conversation / Cell / AABubbleTextCell . swift 
 @ @ - 41 , 6 + 41 , 14 @ @ public class AABubbleTextCell : AABubbleCell { 
 
 messageText . displaysAsynchronously = true 
 messageText . ignoreCommonProperties = true 
 + messageText . highlightTapAction = { ( containerView : UIView , text : NSAttributedString , range : NSRange , rect : CGRect ) - > ( ) in 
 + let attributes = text . attributesAtIndex ( range . location , effectiveRange : nil ) 
 + if let attrs = attributes [ " YYTextHighlight " ] as ? YYTextHighlight { 
 + if let url = attrs . userInfo ! [ " url " ] as ? String { 
 + self . openUrl ( NSURL ( string : url ) ! ) 
 + } 
 + } 
 + } 
 
 senderNameLabel . displaysAsynchronously = true 
 senderNameLabel . ignoreCommonProperties = true 
 @ @ - 49 , 7 + 57 , 6 @ @ public class AABubbleTextCell : AABubbleCell { 
 dateText . displaysAsynchronously = true 
 dateText . lineBreakMode = . ByClipping 
 dateText . numberOfLines = 1 
 - / / dateText . contentMode = . TopLeft 
 dateText . textAlignment = . Right 
 
 statusView . contentMode = UIViewContentMode . Center 
 @ @ - 194 , 16 + 201 , 18 @ @ public class AABubbleTextCell : AABubbleCell { 
 / / openUrl ( url ) 
 / / } 
 / / 
 - / / public func openUrl ( url : NSURL ) { 
 - / / if url . scheme = = " source " { 
 - / / let path = url . path ! 
 - / / let index = Int ( path . substringFromIndex ( path . startIndex . advancedBy ( 1 ) ) ) ! 
 - / / let code = self . cellLayout . sources [ index ] 
 - / / self . controller . navigateNext ( AACodePreviewController ( code : code ) , removeCurrent : false ) 
 - / / } else { 
 - / / ActorSDK . sharedActor ( ) . openUrl ( url . absoluteString ) 
 - / / } 
 - / / } 
 + public func openUrl ( url : NSURL ) { 
 + if url . scheme = = " source " { 
 + let path = url . path ! 
 + let index = Int ( path . substringFromIndex ( path . startIndex . advancedBy ( 1 ) ) ) ! 
 + let code = self . cellLayout . sources [ index ] 
 + self . controller . navigateNext ( AACodePreviewController ( code : code ) , removeCurrent : false ) 
 + } else if url . scheme = = " send " { 
 + Actor . sendMessageWithPeer ( self . peer , withText : url . path ! ) 
 + } else { 
 + ActorSDK . sharedActor ( ) . openUrl ( url . absoluteString ) 
 + } 
 + } 
 
 / / Layouting 
 
 @ @ - 395 , 7 + 404 , 8 @ @ public class TextCellLayout : AACellLayout { 
 public convenience init ( senderId : Int , formattedText : String , textColor : UIColor , date : Int64 , isOut : Bool , peer : ACPeer , layoutKey : String = TextCellLayout . textKey ) { 
 
 / / Parsing markdown formatted text 
 - let text = TextCellLayout . parser . parse ( formattedText , textColor : textColor , fontSize : AABubbleTextCell . fontSize ) 
 + let parser = TextParser ( textColor : textColor , linkColor : ActorSDK . sharedActor ( ) . style . chatUrlColor , fontSize : AABubbleTextCell . fontSize ) 
 + let text = parser . parse ( formattedText ) 
 
 / / Creating attributed text layout 
 self . init ( senderId : senderId , text : formattedText , attributedText : text . attributedText , date : date , isOut : isOut , peer : peer , layoutKey : layoutKey )
