BLEU SCORE: 0.0734705312597788

TEST MSG: fix ( server ) : wrap google push send into blocking { }
GENERATED MSG: refactor ( push ) : GooglePusher and ApplePusher

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > index b9d3132 . . be10f97 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > @ @ - 5 , 20 + 5 , 22 @ @ import akka . event . Logging < nl > import com . google . android . gcm . server . { Sender , Message } < nl > import im . actor . server . model . push . GooglePushCredentials < nl > < nl > + import scala . concurrent . { Future , blocking } < nl > + < nl > private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : GooglePushManager , system : ActorSystem ) extends PushProvider { < nl > private val Retries = 3 < nl > < nl > private val log = Logging ( system , getClass ) < nl > < nl > def deliverInvisible ( seq : Int , creds : GooglePushCredentials ) : Unit = { < nl > - withMgr ( creds . projectId ) { mgr ⇒ < nl > + withMgr ( creds . projectId ) { implicit mgr ⇒ < nl > val message = < nl > new Message . Builder ( ) < nl > . collapseKey ( s " seq - invisible - $ { userId . toString } " ) < nl > . addData ( " seq " , seq . toString ) < nl > . build ( ) < nl > < nl > - mgr . send ( message , creds . regId , Retries ) < nl > + send ( message , creds . regId , Retries ) < nl > } < nl > } < nl > < nl > @ @ - 30 , 7 + 32 , 7 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : < nl > isSoundEnabled : Boolean , < nl > isVibrationEnabled : Boolean < nl > ) : Unit = { < nl > - withMgr ( creds . projectId ) { mgr ⇒ < nl > + withMgr ( creds . projectId ) { implicit mgr ⇒ < nl > val builder = new Message . Builder ( ) < nl > . collapseKey ( s " seq - visible - $ { userId . toString } " ) < nl > . addData ( " seq " , seq . toString ) < nl > @ @ - 44 , 7 + 46 , 7 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : < nl > case _ ⇒ builder . build ( ) < nl > } < nl > < nl > - mgr . send ( message , creds . regId , Retries ) < nl > + send ( message , creds . regId , Retries ) < nl > } < nl > } < nl > < nl > @ @ - 53 , 4 + 55 , 10 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : < nl > case Some ( mgr ) ⇒ f ( mgr ) < nl > case None ⇒ log . warning ( " No google push configured for project - id : { } " , projectId ) < nl > } < nl > + < nl > + private def send ( message : Message , regId : String , retries : Int ) ( implicit mgr : Sender ) : Unit = Future { < nl > + blocking { < nl > + mgr . send ( message , regId , Retries ) < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - models / src / main / scala / im / actor / server / models / AuthSession . scala b / actor - models / src / main / scala / im / actor / server / models / AuthSession . scala < nl > index 6f08e34 . . ee5e508 100644 < nl > - - - a / actor - models / src / main / scala / im / actor / server / models / AuthSession . scala < nl > + + + b / actor - models / src / main / scala / im / actor / server / models / AuthSession . scala < nl > @ @ - 17 , 17 + 17 , 10 @ @ object AuthSession { < nl > case 42 ⇒ " Tests " < nl > case _ ⇒ " Unknown " < nl > } < nl > + < nl > + def appCategory ( appId : Int ) = appId match { < nl > + case 0 | 1 | 2 ⇒ " mobile " < nl > + case 3 ⇒ " desktop " < nl > + case _ ⇒ " generic " < nl > + } < nl > } < nl > - / / def build ( < nl > - / / id : Int , appId : Int , deviceTitle : String , authTime : DateTime , < nl > - / / authLocation : String , latitude : Option [ Double ] , longitude : Option [ Double ] , < nl > - / / authId : Long , publicKeyHash : Long , deviceHash : BitVector < nl > - / / ) : AuthSession = { < nl > - / / val appTitle = appTitleOf ( appId ) < nl > - / / AuthSession ( < nl > - / / id = id , appId = appId , appTitle = appTitle , deviceTitle = deviceTitle , authTime = authTime , < nl > - / / authLocation = authLocation , latitude = latitude , longitude = longitude , < nl > - / / authId = authId , publicKeyHash = publicKeyHash , deviceHash = deviceHash < nl > - / / ) < nl > - / / } < nl > - / / } < nl > diff - - git a / actor - push / src / main / scala / im / actor / server / push / ApplePusher . scala b / actor - push / src / main / scala / im / actor / server / push / ApplePusher . scala < nl > new file mode 100644 < nl > index 0000000 . . 5aa8446 < nl > - - - / dev / null < nl > + + + b / actor - push / src / main / scala / im / actor / server / push / ApplePusher . scala < nl > @ @ - 0 , 0 + 1 , 80 @ @ < nl > + package im . actor . server . push < nl > + < nl > + import scala . concurrent . ExecutionContext < nl > + < nl > + import akka . actor . ActorSystem < nl > + import com . relayrides . pushy . apns . util . { ApnsPayloadBuilder , SimpleApnsPushNotification } < nl > + import slick . driver . PostgresDriver . api . _ < nl > + < nl > + import im . actor . api . rpc . peers . { Peer , PeerType } < nl > + import im . actor . server . { models , persist } < nl > + < nl > + private [ push ] class ApplePusher ( pushManager : ApplePushManager , db : Database ) ( implicit system : ActorSystem ) extends VendorPush { < nl > + private implicit val ec : ExecutionContext = system . dispatcher < nl > + < nl > + def deliverApplePush ( creds : models . push . ApplePushCredentials , authId : Long , seq : Int , textOpt : Option [ String ] , originPeerOpt : Option [ Peer ] ) : Unit = { < nl > + val paramBase = " category . mobile . notification " < nl > + < nl > + system . log . debug ( " Delivering apple push , authId : { } , seq : { } , text : { } , originPeer : { } " , authId , seq , textOpt , originPeerOpt ) < nl > + < nl > + val builder = new ApnsPayloadBuilder < nl > + < nl > + val action = ( textOpt , originPeerOpt ) match { < nl > + case ( Some ( text ) , Some ( originPeer ) ) ⇒ < nl > + persist . AuthId . findUserId ( authId ) flatMap { < nl > + case Some ( userId ) ⇒ < nl > + val peerStr = originPeer . ` type ` match { < nl > + case PeerType . Private ⇒ s " PRIVATE _ $ { originPeer . id } " < nl > + case PeerType . Group ⇒ s " GROUP _ $ { originPeer . id } " < nl > + } < nl > + < nl > + system . log . debug ( s " Loading params $ { paramBase } " ) < nl > + < nl > + persist . configs . Parameter . findValue ( userId , s " $ { paramBase } . chat . $ { peerStr } . enabled " ) flatMap { < nl > + case Some ( " false " ) ⇒ < nl > + system . log . debug ( " Notifications disabled " ) < nl > + DBIO . successful ( builder ) < nl > + case _ ⇒ < nl > + system . log . debug ( " Notifications enabled " ) < nl > + for { < nl > + soundEnabled ← persist . configs . Parameter . findValue ( userId , s " $ { paramBase } . sound . enabled " ) map ( _ . getOrElse ( " true " ) ) < nl > + vibrationEnabled ← persist . configs . Parameter . findValue ( userId , s " $ { paramBase } . vibration . enabled " ) map ( _ . getOrElse ( " true " ) ) < nl > + showText ← persist . configs . Parameter . findValue ( userId , s " $ { paramBase } . show _ text " ) map ( _ . getOrElse ( " true " ) ) < nl > + } yield { < nl > + if ( soundEnabled = = " true " ) { < nl > + system . log . debug ( " Sound enabled " ) < nl > + builder . setSoundFileName ( " iapetus . caf " ) < nl > + } else if ( vibrationEnabled = = " true " ) { < nl > + system . log . debug ( " Sound disabled , vibration enabled " ) < nl > + builder . setSoundFileName ( " silence . caf " ) < nl > + } < nl > + < nl > + if ( showText = = " true " ) { < nl > + system . log . debug ( " Text enabled " ) < nl > + builder . setAlertBody ( text ) < nl > + } < nl > + < nl > + builder < nl > + } < nl > + } < nl > + case None ⇒ DBIO . successful ( builder ) / / TODO : fail ? < nl > + } < nl > + case ( Some ( text ) , None ) ⇒ < nl > + builder . setAlertBody ( text ) < nl > + DBIO . successful ( builder ) < nl > + case _ ⇒ DBIO . successful ( builder ) < nl > + } < nl > + < nl > + db . run ( action ) foreach { b ⇒ < nl > + builder . addCustomProperty ( " seq " , seq ) < nl > + builder . setContentAvailable ( true ) < nl > + < nl > + val payload = builder . buildWithDefaultMaximumLength ( ) < nl > + < nl > + pushManager . getInstance ( creds . apnsKey ) foreach { mgr ⇒ < nl > + mgr . getQueue . put ( new SimpleApnsPushNotification ( creds . token , payload ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - push / src / main / scala / im / actor / server / push / GooglePusher . scala b / actor - push / src / main / scala / im / actor / server / push / GooglePusher . scala < nl > new file mode 100644 < nl > index 0000000 . . e73bc3d < nl > - - - / dev / null < nl > + + + b / actor - push / src / main / scala / im / actor / server / push / GooglePusher . scala < nl > @ @ - 0 , 0 + 1 , 32 @ @ < nl > + package im . actor . server . push < nl > + < nl > + import akka . actor . ActorSystem < nl > + import com . google . android . gcm . server . { Message , Sender } < nl > + import slick . driver . PostgresDriver . api . _ < nl > + < nl > + import scala . concurrent . _ < nl > + < nl > + import im . actor . server . models < nl > + < nl > + / / FIXME : # perf pinned dispatcher < nl > + private [ push ] class GooglePusher ( gcmSender : Sender , db : Database ) ( implicit system : ActorSystem ) extends VendorPush { < nl > + implicit val ec : ExecutionContext = system . dispatcher < nl > + < nl > + def deliverGooglePush ( creds : models . push . GooglePushCredentials , authId : Long , seq : Int ) : Unit = { < nl > + system . log . debug ( " Delivering google push , authId : { } , seq : { } " , authId , seq ) < nl > + < nl > + val builder = ( new Message . Builder ) < nl > + . collapseKey ( authId . toString ) < nl > + . addData ( " seq " , seq . toString ) < nl > + < nl > + val message = builder . build ( ) < nl > + < nl > + val resultFuture = Future { blocking { gcmSender . send ( message , creds . regId , 3 ) } } < nl > + < nl > + resultFuture . map { result ⇒ < nl > + system . log . debug ( " Google push result messageId : { } , error : { } " , result . getMessageId , result . getErrorCodeName ) < nl > + } . onFailure { < nl > + case e ⇒ system . log . error ( e , " Failed to deliver google push " ) < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala b / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > index 9e7a5fd . . e53fc57 100644 < nl > - - - a / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > + + + b / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > @ @ - 3 , 8 + 3 , 6 @ @ package im . actor . server . push < nl > import java . nio . ByteBuffer < nl > import java . util . concurrent . TimeUnit < nl > < nl > - import im . actor . api . rpc . UpdateBox < nl > - < nl > import scala . annotation . meta . field < nl > import scala . concurrent . _ < nl > import scala . concurrent . duration . _ < nl > @ @ - 15 , 22 + 13 , 22 @ @ import akka . contrib . pattern . { ClusterSharding , ShardRegion } < nl > import akka . pattern . { ask , pipe } < nl > import akka . persistence . _ < nl > import akka . util . Timeout < nl > + import com . google . android . gcm . server . { Sender ⇒ GCMSender } < nl > import com . esotericsoftware . kryo . serializers . TaggedFieldSerializer . { Tag ⇒ KryoTag } < nl > - import com . google . android . gcm . server . { Message ⇒ GCMMessage , Sender ⇒ GCMSender } < nl > - import com . relayrides . pushy . apns . util . { ApnsPayloadBuilder , SimpleApnsPushNotification } < nl > import slick . dbio < nl > import slick . dbio . DBIO < nl > import slick . dbio . Effect . Read < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > + import im . actor . api . rpc . UpdateBox < nl > import im . actor . api . rpc . messaging . { UpdateMessage , UpdateMessageSent } < nl > - import im . actor . api . rpc . peers . { PeerType , Peer } < nl > + import im . actor . api . rpc . peers . Peer < nl > import im . actor . api . rpc . sequence . { FatSeqUpdate , SeqUpdate } < nl > import im . actor . api . { rpc ⇒ api } < nl > import im . actor . server . commons . serialization . KryoSerializable < nl > import im . actor . server . models . sequence < nl > + import im . actor . server . util . { GroupUtils , UserUtils } < nl > import im . actor . server . { models , persist ⇒ p } < nl > - import im . actor . server . util . { UserUtils , GroupUtils } < nl > < nl > case class SeqUpdatesManagerRegion ( ref : ActorRef ) < nl > < nl > @ @ - 470 , 7 + 468 , 7 @ @ class SeqUpdatesManager ( < nl > gcmSender : GCMSender , < nl > applePushManager : ApplePushManager , < nl > db : Database < nl > - ) extends PersistentActor with Stash with ActorLogging { < nl > + ) extends PersistentActor with Stash with ActorLogging with VendorPush { < nl > < nl > import ShardRegion . Passivate < nl > < nl > @ @ - 478 , 11 + 476 , 10 @ @ class SeqUpdatesManager ( < nl > < nl > override def persistenceId : String = self . path . parent . name + " - " + self . path . name < nl > < nl > - implicit val ec : ExecutionContext = context . dispatcher < nl > - implicit val system : ActorSystem = context . system < nl > + implicit private val system : ActorSystem = context . system < nl > < nl > / / FIXME : move to props < nl > - val receiveTimeout = context . system . settings . config . getDuration ( " push . seq - updates - manager . receive - timeout " , TimeUnit . SECONDS ) . seconds < nl > + private val receiveTimeout = context . system . settings . config . getDuration ( " push . seq - updates - manager . receive - timeout " , TimeUnit . SECONDS ) . seconds < nl > context . setReceiveTimeout ( receiveTimeout ) < nl > < nl > private [ this ] val IncrementOnStart : Int = 1000 < nl > @ @ - 496 , 6 + 493 , 9 @ @ class SeqUpdatesManager ( < nl > private [ this ] var googleCredsOpt : Option [ models . push . GooglePushCredentials ] = None < nl > private [ this ] var appleCredsOpt : Option [ models . push . ApplePushCredentials ] = None < nl > < nl > + private [ this ] val applePusher = new ApplePusher ( applePushManager , db ) < nl > + private [ this ] val googlePusher = new GooglePusher ( gcmSender , db ) < nl > + < nl > def receiveInitialized : Receive = { < nl > case Envelope ( _ , GetSequenceState ) ⇒ < nl > sender ( ) ! sequenceState ( seq , timestampToBytes ( lastTimestamp ) ) < nl > @ @ - 671 , 12 + 671 , 12 @ @ class SeqUpdatesManager ( < nl > < nl > googleCredsOpt foreach { creds ⇒ < nl > if ( header = = UpdateMessage . header ) { < nl > - deliverGooglePush ( creds , authId , seqUpdate . seq ) < nl > + googlePusher . deliverGooglePush ( creds , authId , seqUpdate . seq ) < nl > } < nl > } < nl > < nl > appleCredsOpt foreach { creds ⇒ < nl > - deliverApplePush ( creds , authId , seqUpdate . seq , pushText , originPeer ) < nl > + applePusher . deliverApplePush ( creds , authId , seqUpdate . seq , pushText , originPeer ) < nl > } < nl > } < nl > < nl > @ @ - 719 , 90 + 719 , 4 @ @ class SeqUpdatesManager ( < nl > < nl > private def sequenceState ( sequence : Int , state : Array [ Byte ] ) : SequenceState = < nl > ( sequence , state ) < nl > - < nl > - private def deliverGooglePush ( creds : models . push . GooglePushCredentials , authId : Long , seq : Int ) : Unit = { < nl > - log . debug ( " Delivering google push , authId : { } , seq : { } " , authId , seq ) < nl > - < nl > - val message = ( new GCMMessage . Builder ) < nl > - . collapseKey ( authId . toString ) < nl > - . addData ( " seq " , seq . toString ) < nl > - . build ( ) < nl > - < nl > - / / TODO : configurable retries < nl > - / / TODO : # perf pinned dispatcher < nl > - implicit val ec = context . dispatcher < nl > - < nl > - val resultFuture = Future { blocking { gcmSender . send ( message , creds . regId , 3 ) } } < nl > - < nl > - resultFuture . map { result ⇒ < nl > - log . debug ( " Google push result messageId : { } , error : { } " , result . getMessageId , result . getErrorCodeName ) < nl > - } . onFailure { < nl > - case e ⇒ log . error ( e , " Failed to deliver google push " ) < nl > - } < nl > - } < nl > - < nl > - private def deliverApplePush ( creds : models . push . ApplePushCredentials , authId : Long , seq : Int , textOpt : Option [ String ] , originPeerOpt : Option [ Peer ] ) : Unit = { < nl > - val paramBase = " category . mobile . notification " < nl > - < nl > - log . debug ( " Delivering apple push , authId : { } , seq : { } , text : { } , originPeer : { } " , authId , seq , textOpt , originPeerOpt ) < nl > - < nl > - val builder = new ApnsPayloadBuilder < nl > - < nl > - val action = ( textOpt , originPeerOpt ) match { < nl > - case ( Some ( text ) , Some ( originPeer ) ) ⇒ < nl > - p . AuthId . findUserId ( authId ) flatMap { < nl > - case Some ( userId ) ⇒ < nl > - val peerStr = originPeer . ` type ` match { < nl > - case PeerType . Private ⇒ s " PRIVATE _ $ { originPeer . id } " < nl > - case PeerType . Group ⇒ s " GROUP _ $ { originPeer . id } " < nl > - } < nl > - < nl > - log . debug ( s " Loading params $ { paramBase } " ) < nl > - < nl > - p . configs . Parameter . findValue ( userId , s " $ { paramBase } . chat . $ { peerStr } . enabled " ) flatMap { < nl > - case Some ( " false " ) ⇒ < nl > - log . debug ( " Notifications disabled " ) < nl > - DBIO . successful ( builder ) < nl > - case _ ⇒ < nl > - log . debug ( " Notifications enabled " ) < nl > - for { < nl > - soundEnabled ← p . configs . Parameter . findValue ( userId , s " $ { paramBase } . sound . enabled " ) map ( _ . getOrElse ( " true " ) ) < nl > - vibrationEnabled ← p . configs . Parameter . findValue ( userId , s " $ { paramBase } . vibration . enabled " ) map ( _ . getOrElse ( " true " ) ) < nl > - showText ← p . configs . Parameter . findValue ( userId , s " $ { paramBase } . show _ text " ) map ( _ . getOrElse ( " true " ) ) < nl > - } yield { < nl > - if ( soundEnabled = = " true " ) { < nl > - log . debug ( " Sound enabled " ) < nl > - builder . setSoundFileName ( " iapetus . caf " ) < nl > - } else if ( vibrationEnabled = = " true " ) { < nl > - log . debug ( " Sound disabled , vibration enabled " ) < nl > - builder . setSoundFileName ( " silence . caf " ) < nl > - } < nl > - < nl > - if ( showText = = " true " ) { < nl > - log . debug ( " Text enabled " ) < nl > - builder . setAlertBody ( text ) < nl > - } < nl > - < nl > - builder < nl > - } < nl > - } < nl > - case None ⇒ DBIO . successful ( builder ) / / TODO : fail ? < nl > - } < nl > - case ( Some ( text ) , None ) ⇒ < nl > - builder . setAlertBody ( text ) < nl > - DBIO . successful ( builder ) < nl > - case _ ⇒ DBIO . successful ( builder ) < nl > - } < nl > - < nl > - db . run ( action ) foreach { b ⇒ < nl > - builder . addCustomProperty ( " seq " , seq ) < nl > - builder . setContentAvailable ( true ) < nl > - < nl > - val payload = builder . buildWithDefaultMaximumLength ( ) < nl > - < nl > - applePushManager . getInstance ( creds . apnsKey ) map { mgr ⇒ < nl > - mgr . getQueue . put ( new SimpleApnsPushNotification ( creds . token , payload ) ) < nl > - } < nl > - } < nl > - } < nl > } < nl > diff - - git a / actor - push / src / main / scala / im / actor / server / push / VendorPush . scala b / actor - push / src / main / scala / im / actor / server / push / VendorPush . scala < nl > new file mode 100644 < nl > index 0000000 . . 65026cc < nl > - - - / dev / null < nl > + + + b / actor - push / src / main / scala / im / actor / server / push / VendorPush . scala < nl > @ @ - 0 , 0 + 1 , 3 @ @ < nl > + package im . actor . server . push < nl > + < nl > + private [ push ] trait VendorPush < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 index b9d3132 . . be10f97 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 @ @ - 5 , 20 + 5 , 22 @ @ import akka . event . Logging 
 import com . google . android . gcm . server . { Sender , Message } 
 import im . actor . server . model . push . GooglePushCredentials 
 
 + import scala . concurrent . { Future , blocking } 
 + 
 private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : GooglePushManager , system : ActorSystem ) extends PushProvider { 
 private val Retries = 3 
 
 private val log = Logging ( system , getClass ) 
 
 def deliverInvisible ( seq : Int , creds : GooglePushCredentials ) : Unit = { 
 - withMgr ( creds . projectId ) { mgr ⇒ 
 + withMgr ( creds . projectId ) { implicit mgr ⇒ 
 val message = 
 new Message . Builder ( ) 
 . collapseKey ( s " seq - invisible - $ { userId . toString } " ) 
 . addData ( " seq " , seq . toString ) 
 . build ( ) 
 
 - mgr . send ( message , creds . regId , Retries ) 
 + send ( message , creds . regId , Retries ) 
 } 
 } 
 
 @ @ - 30 , 7 + 32 , 7 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : 
 isSoundEnabled : Boolean , 
 isVibrationEnabled : Boolean 
 ) : Unit = { 
 - withMgr ( creds . projectId ) { mgr ⇒ 
 + withMgr ( creds . projectId ) { implicit mgr ⇒ 
 val builder = new Message . Builder ( ) 
 . collapseKey ( s " seq - visible - $ { userId . toString } " ) 
 . addData ( " seq " , seq . toString ) 
 @ @ - 44 , 7 + 46 , 7 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : 
 case _ ⇒ builder . build ( ) 
 } 
 
 - mgr . send ( message , creds . regId , Retries ) 
 + send ( message , creds . regId , Retries ) 
 } 
 } 
 
 @ @ - 53 , 4 + 55 , 10 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : 
 case Some ( mgr ) ⇒ f ( mgr ) 
 case None ⇒ log . warning ( " No google push configured for project - id : { } " , projectId ) 
 } 
 + 
 + private def send ( message : Message , regId : String , retries : Int ) ( implicit mgr : Sender ) : Unit = Future { 
 + blocking { 
 + mgr . send ( message , regId , Retries ) 
 + } 
 + } 
 } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - models / src / main / scala / im / actor / server / models / AuthSession . scala b / actor - models / src / main / scala / im / actor / server / models / AuthSession . scala 
 index 6f08e34 . . ee5e508 100644 
 - - - a / actor - models / src / main / scala / im / actor / server / models / AuthSession . scala 
 + + + b / actor - models / src / main / scala / im / actor / server / models / AuthSession . scala 
 @ @ - 17 , 17 + 17 , 10 @ @ object AuthSession { 
 case 42 ⇒ " Tests " 
 case _ ⇒ " Unknown " 
 } 
 + 
 + def appCategory ( appId : Int ) = appId match { 
 + case 0 | 1 | 2 ⇒ " mobile " 
 + case 3 ⇒ " desktop " 
 + case _ ⇒ " generic " 
 + } 
 } 
 - / / def build ( 
 - / / id : Int , appId : Int , deviceTitle : String , authTime : DateTime , 
 - / / authLocation : String , latitude : Option [ Double ] , longitude : Option [ Double ] , 
 - / / authId : Long , publicKeyHash : Long , deviceHash : BitVector 
 - / / ) : AuthSession = { 
 - / / val appTitle = appTitleOf ( appId ) 
 - / / AuthSession ( 
 - / / id = id , appId = appId , appTitle = appTitle , deviceTitle = deviceTitle , authTime = authTime , 
 - / / authLocation = authLocation , latitude = latitude , longitude = longitude , 
 - / / authId = authId , publicKeyHash = publicKeyHash , deviceHash = deviceHash 
 - / / ) 
 - / / } 
 - / / } 
 diff - - git a / actor - push / src / main / scala / im / actor / server / push / ApplePusher . scala b / actor - push / src / main / scala / im / actor / server / push / ApplePusher . scala 
 new file mode 100644 
 index 0000000 . . 5aa8446 
 - - - / dev / null 
 + + + b / actor - push / src / main / scala / im / actor / server / push / ApplePusher . scala 
 @ @ - 0 , 0 + 1 , 80 @ @ 
 + package im . actor . server . push 
 + 
 + import scala . concurrent . ExecutionContext 
 + 
 + import akka . actor . ActorSystem 
 + import com . relayrides . pushy . apns . util . { ApnsPayloadBuilder , SimpleApnsPushNotification } 
 + import slick . driver . PostgresDriver . api . _ 
 + 
 + import im . actor . api . rpc . peers . { Peer , PeerType } 
 + import im . actor . server . { models , persist } 
 + 
 + private [ push ] class ApplePusher ( pushManager : ApplePushManager , db : Database ) ( implicit system : ActorSystem ) extends VendorPush { 
 + private implicit val ec : ExecutionContext = system . dispatcher 
 + 
 + def deliverApplePush ( creds : models . push . ApplePushCredentials , authId : Long , seq : Int , textOpt : Option [ String ] , originPeerOpt : Option [ Peer ] ) : Unit = { 
 + val paramBase = " category . mobile . notification " 
 + 
 + system . log . debug ( " Delivering apple push , authId : { } , seq : { } , text : { } , originPeer : { } " , authId , seq , textOpt , originPeerOpt ) 
 + 
 + val builder = new ApnsPayloadBuilder 
 + 
 + val action = ( textOpt , originPeerOpt ) match { 
 + case ( Some ( text ) , Some ( originPeer ) ) ⇒ 
 + persist . AuthId . findUserId ( authId ) flatMap { 
 + case Some ( userId ) ⇒ 
 + val peerStr = originPeer . ` type ` match { 
 + case PeerType . Private ⇒ s " PRIVATE _ $ { originPeer . id } " 
 + case PeerType . Group ⇒ s " GROUP _ $ { originPeer . id } " 
 + } 
 + 
 + system . log . debug ( s " Loading params $ { paramBase } " ) 
 + 
 + persist . configs . Parameter . findValue ( userId , s " $ { paramBase } . chat . $ { peerStr } . enabled " ) flatMap { 
 + case Some ( " false " ) ⇒ 
 + system . log . debug ( " Notifications disabled " ) 
 + DBIO . successful ( builder ) 
 + case _ ⇒ 
 + system . log . debug ( " Notifications enabled " ) 
 + for { 
 + soundEnabled ← persist . configs . Parameter . findValue ( userId , s " $ { paramBase } . sound . enabled " ) map ( _ . getOrElse ( " true " ) ) 
 + vibrationEnabled ← persist . configs . Parameter . findValue ( userId , s " $ { paramBase } . vibration . enabled " ) map ( _ . getOrElse ( " true " ) ) 
 + showText ← persist . configs . Parameter . findValue ( userId , s " $ { paramBase } . show _ text " ) map ( _ . getOrElse ( " true " ) ) 
 + } yield { 
 + if ( soundEnabled = = " true " ) { 
 + system . log . debug ( " Sound enabled " ) 
 + builder . setSoundFileName ( " iapetus . caf " ) 
 + } else if ( vibrationEnabled = = " true " ) { 
 + system . log . debug ( " Sound disabled , vibration enabled " ) 
 + builder . setSoundFileName ( " silence . caf " ) 
 + } 
 + 
 + if ( showText = = " true " ) { 
 + system . log . debug ( " Text enabled " ) 
 + builder . setAlertBody ( text ) 
 + } 
 + 
 + builder 
 + } 
 + } 
 + case None ⇒ DBIO . successful ( builder ) / / TODO : fail ? 
 + } 
 + case ( Some ( text ) , None ) ⇒ 
 + builder . setAlertBody ( text ) 
 + DBIO . successful ( builder ) 
 + case _ ⇒ DBIO . successful ( builder ) 
 + } 
 + 
 + db . run ( action ) foreach { b ⇒ 
 + builder . addCustomProperty ( " seq " , seq ) 
 + builder . setContentAvailable ( true ) 
 + 
 + val payload = builder . buildWithDefaultMaximumLength ( ) 
 + 
 + pushManager . getInstance ( creds . apnsKey ) foreach { mgr ⇒ 
 + mgr . getQueue . put ( new SimpleApnsPushNotification ( creds . token , payload ) ) 
 + } 
 + } 
 + } 
 + 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - push / src / main / scala / im / actor / server / push / GooglePusher . scala b / actor - push / src / main / scala / im / actor / server / push / GooglePusher . scala 
 new file mode 100644 
 index 0000000 . . e73bc3d 
 - - - / dev / null 
 + + + b / actor - push / src / main / scala / im / actor / server / push / GooglePusher . scala 
 @ @ - 0 , 0 + 1 , 32 @ @ 
 + package im . actor . server . push 
 + 
 + import akka . actor . ActorSystem 
 + import com . google . android . gcm . server . { Message , Sender } 
 + import slick . driver . PostgresDriver . api . _ 
 + 
 + import scala . concurrent . _ 
 + 
 + import im . actor . server . models 
 + 
 + / / FIXME : # perf pinned dispatcher 
 + private [ push ] class GooglePusher ( gcmSender : Sender , db : Database ) ( implicit system : ActorSystem ) extends VendorPush { 
 + implicit val ec : ExecutionContext = system . dispatcher 
 + 
 + def deliverGooglePush ( creds : models . push . GooglePushCredentials , authId : Long , seq : Int ) : Unit = { 
 + system . log . debug ( " Delivering google push , authId : { } , seq : { } " , authId , seq ) 
 + 
 + val builder = ( new Message . Builder ) 
 + . collapseKey ( authId . toString ) 
 + . addData ( " seq " , seq . toString ) 
 + 
 + val message = builder . build ( ) 
 + 
 + val resultFuture = Future { blocking { gcmSender . send ( message , creds . regId , 3 ) } } 
 + 
 + resultFuture . map { result ⇒ 
 + system . log . debug ( " Google push result messageId : { } , error : { } " , result . getMessageId , result . getErrorCodeName ) 
 + } . onFailure { 
 + case e ⇒ system . log . error ( e , " Failed to deliver google push " ) 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala b / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 index 9e7a5fd . . e53fc57 100644 
 - - - a / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 + + + b / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 @ @ - 3 , 8 + 3 , 6 @ @ package im . actor . server . push 
 import java . nio . ByteBuffer 
 import java . util . concurrent . TimeUnit 
 
 - import im . actor . api . rpc . UpdateBox 
 - 
 import scala . annotation . meta . field 
 import scala . concurrent . _ 
 import scala . concurrent . duration . _ 
 @ @ - 15 , 22 + 13 , 22 @ @ import akka . contrib . pattern . { ClusterSharding , ShardRegion } 
 import akka . pattern . { ask , pipe } 
 import akka . persistence . _ 
 import akka . util . Timeout 
 + import com . google . android . gcm . server . { Sender ⇒ GCMSender } 
 import com . esotericsoftware . kryo . serializers . TaggedFieldSerializer . { Tag ⇒ KryoTag } 
 - import com . google . android . gcm . server . { Message ⇒ GCMMessage , Sender ⇒ GCMSender } 
 - import com . relayrides . pushy . apns . util . { ApnsPayloadBuilder , SimpleApnsPushNotification } 
 import slick . dbio 
 import slick . dbio . DBIO 
 import slick . dbio . Effect . Read 
 import slick . driver . PostgresDriver . api . _ 
 
 + import im . actor . api . rpc . UpdateBox 
 import im . actor . api . rpc . messaging . { UpdateMessage , UpdateMessageSent } 
 - import im . actor . api . rpc . peers . { PeerType , Peer } 
 + import im . actor . api . rpc . peers . Peer 
 import im . actor . api . rpc . sequence . { FatSeqUpdate , SeqUpdate } 
 import im . actor . api . { rpc ⇒ api } 
 import im . actor . server . commons . serialization . KryoSerializable 
 import im . actor . server . models . sequence 
 + import im . actor . server . util . { GroupUtils , UserUtils } 
 import im . actor . server . { models , persist ⇒ p } 
 - import im . actor . server . util . { UserUtils , GroupUtils } 
 
 case class SeqUpdatesManagerRegion ( ref : ActorRef ) 
 
 @ @ - 470 , 7 + 468 , 7 @ @ class SeqUpdatesManager ( 
 gcmSender : GCMSender , 
 applePushManager : ApplePushManager , 
 db : Database 
 - ) extends PersistentActor with Stash with ActorLogging { 
 + ) extends PersistentActor with Stash with ActorLogging with VendorPush { 
 
 import ShardRegion . Passivate 
 
 @ @ - 478 , 11 + 476 , 10 @ @ class SeqUpdatesManager ( 
 
 override def persistenceId : String = self . path . parent . name + " - " + self . path . name 
 
 - implicit val ec : ExecutionContext = context . dispatcher 
 - implicit val system : ActorSystem = context . system 
 + implicit private val system : ActorSystem = context . system 
 
 / / FIXME : move to props 
 - val receiveTimeout = context . system . settings . config . getDuration ( " push . seq - updates - manager . receive - timeout " , TimeUnit . SECONDS ) . seconds 
 + private val receiveTimeout = context . system . settings . config . getDuration ( " push . seq - updates - manager . receive - timeout " , TimeUnit . SECONDS ) . seconds 
 context . setReceiveTimeout ( receiveTimeout ) 
 
 private [ this ] val IncrementOnStart : Int = 1000 
 @ @ - 496 , 6 + 493 , 9 @ @ class SeqUpdatesManager ( 
 private [ this ] var googleCredsOpt : Option [ models . push . GooglePushCredentials ] = None 
 private [ this ] var appleCredsOpt : Option [ models . push . ApplePushCredentials ] = None 
 
 + private [ this ] val applePusher = new ApplePusher ( applePushManager , db ) 
 + private [ this ] val googlePusher = new GooglePusher ( gcmSender , db ) 
 + 
 def receiveInitialized : Receive = { 
 case Envelope ( _ , GetSequenceState ) ⇒ 
 sender ( ) ! sequenceState ( seq , timestampToBytes ( lastTimestamp ) ) 
 @ @ - 671 , 12 + 671 , 12 @ @ class SeqUpdatesManager ( 
 
 googleCredsOpt foreach { creds ⇒ 
 if ( header = = UpdateMessage . header ) { 
 - deliverGooglePush ( creds , authId , seqUpdate . seq ) 
 + googlePusher . deliverGooglePush ( creds , authId , seqUpdate . seq ) 
 } 
 } 
 
 appleCredsOpt foreach { creds ⇒ 
 - deliverApplePush ( creds , authId , seqUpdate . seq , pushText , originPeer ) 
 + applePusher . deliverApplePush ( creds , authId , seqUpdate . seq , pushText , originPeer ) 
 } 
 } 
 
 @ @ - 719 , 90 + 719 , 4 @ @ class SeqUpdatesManager ( 
 
 private def sequenceState ( sequence : Int , state : Array [ Byte ] ) : SequenceState = 
 ( sequence , state ) 
 - 
 - private def deliverGooglePush ( creds : models . push . GooglePushCredentials , authId : Long , seq : Int ) : Unit = { 
 - log . debug ( " Delivering google push , authId : { } , seq : { } " , authId , seq ) 
 - 
 - val message = ( new GCMMessage . Builder ) 
 - . collapseKey ( authId . toString ) 
 - . addData ( " seq " , seq . toString ) 
 - . build ( ) 
 - 
 - / / TODO : configurable retries 
 - / / TODO : # perf pinned dispatcher 
 - implicit val ec = context . dispatcher 
 - 
 - val resultFuture = Future { blocking { gcmSender . send ( message , creds . regId , 3 ) } } 
 - 
 - resultFuture . map { result ⇒ 
 - log . debug ( " Google push result messageId : { } , error : { } " , result . getMessageId , result . getErrorCodeName ) 
 - } . onFailure { 
 - case e ⇒ log . error ( e , " Failed to deliver google push " ) 
 - } 
 - } 
 - 
 - private def deliverApplePush ( creds : models . push . ApplePushCredentials , authId : Long , seq : Int , textOpt : Option [ String ] , originPeerOpt : Option [ Peer ] ) : Unit = { 
 - val paramBase = " category . mobile . notification " 
 - 
 - log . debug ( " Delivering apple push , authId : { } , seq : { } , text : { } , originPeer : { } " , authId , seq , textOpt , originPeerOpt ) 
 - 
 - val builder = new ApnsPayloadBuilder 
 - 
 - val action = ( textOpt , originPeerOpt ) match { 
 - case ( Some ( text ) , Some ( originPeer ) ) ⇒ 
 - p . AuthId . findUserId ( authId ) flatMap { 
 - case Some ( userId ) ⇒ 
 - val peerStr = originPeer . ` type ` match { 
 - case PeerType . Private ⇒ s " PRIVATE _ $ { originPeer . id } " 
 - case PeerType . Group ⇒ s " GROUP _ $ { originPeer . id } " 
 - } 
 - 
 - log . debug ( s " Loading params $ { paramBase } " ) 
 - 
 - p . configs . Parameter . findValue ( userId , s " $ { paramBase } . chat . $ { peerStr } . enabled " ) flatMap { 
 - case Some ( " false " ) ⇒ 
 - log . debug ( " Notifications disabled " ) 
 - DBIO . successful ( builder ) 
 - case _ ⇒ 
 - log . debug ( " Notifications enabled " ) 
 - for { 
 - soundEnabled ← p . configs . Parameter . findValue ( userId , s " $ { paramBase } . sound . enabled " ) map ( _ . getOrElse ( " true " ) ) 
 - vibrationEnabled ← p . configs . Parameter . findValue ( userId , s " $ { paramBase } . vibration . enabled " ) map ( _ . getOrElse ( " true " ) ) 
 - showText ← p . configs . Parameter . findValue ( userId , s " $ { paramBase } . show _ text " ) map ( _ . getOrElse ( " true " ) ) 
 - } yield { 
 - if ( soundEnabled = = " true " ) { 
 - log . debug ( " Sound enabled " ) 
 - builder . setSoundFileName ( " iapetus . caf " ) 
 - } else if ( vibrationEnabled = = " true " ) { 
 - log . debug ( " Sound disabled , vibration enabled " ) 
 - builder . setSoundFileName ( " silence . caf " ) 
 - } 
 - 
 - if ( showText = = " true " ) { 
 - log . debug ( " Text enabled " ) 
 - builder . setAlertBody ( text ) 
 - } 
 - 
 - builder 
 - } 
 - } 
 - case None ⇒ DBIO . successful ( builder ) / / TODO : fail ? 
 - } 
 - case ( Some ( text ) , None ) ⇒ 
 - builder . setAlertBody ( text ) 
 - DBIO . successful ( builder ) 
 - case _ ⇒ DBIO . successful ( builder ) 
 - } 
 - 
 - db . run ( action ) foreach { b ⇒ 
 - builder . addCustomProperty ( " seq " , seq ) 
 - builder . setContentAvailable ( true ) 
 - 
 - val payload = builder . buildWithDefaultMaximumLength ( ) 
 - 
 - applePushManager . getInstance ( creds . apnsKey ) map { mgr ⇒ 
 - mgr . getQueue . put ( new SimpleApnsPushNotification ( creds . token , payload ) ) 
 - } 
 - } 
 - } 
 } 
 diff - - git a / actor - push / src / main / scala / im / actor / server / push / VendorPush . scala b / actor - push / src / main / scala / im / actor / server / push / VendorPush . scala 
 new file mode 100644 
 index 0000000 . . 65026cc 
 - - - / dev / null 
 + + + b / actor - push / src / main / scala / im / actor / server / push / VendorPush . scala 
 @ @ - 0 , 0 + 1 , 3 @ @ 
 + package im . actor . server . push 
 + 
 + private [ push ] trait VendorPush 
 \ No newline at end of file
