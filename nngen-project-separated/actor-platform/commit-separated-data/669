BLEU SCORE: 0.27901593935858265

TEST MSG: feat ( server : files ) : file url builder implementation
GENERATED MSG: feat ( server : bots ) : bots api

TEST DIFF (one line): diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / FilesBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / FilesBotService . scala < nl > index 858d2bf . . 0250f0d 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / FilesBotService . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / FilesBotService . scala < nl > @ @ - 7 , 7 + 7 , 7 @ @ import im . actor . server . acl . ACLUtils < nl > import im . actor . server . bot . { ApiToBotConversions , BotServiceBase } < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . file . { FileStorageExtension , UnsafeFileName } < nl > - import im . actor . server . persist . FileRepo < nl > + import im . actor . server . persist . files . FileRepo < nl > < nl > private [ bot ] object FilesBotErrors { < nl > val LocationInvalid = BotError ( 400 , " LOCATION _ INVALID " ) < nl > diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json < nl > index c3ad553 . . fa26d3b 100644 < nl > - - - a / actor - server / actor - core / src / main / actor - api / actor . json < nl > + + + b / actor - server / actor - core / src / main / actor - api / actor . json < nl > @ @ - 11584 , 6 + 11584 , 87 @ @ < nl > { < nl > " type " : " rpc " , < nl > " content " : { < nl > + " name " : " GetFileUrlBuilder " , < nl > + " header " : 2579 , < nl > + " response " : { < nl > + " type " : " anonymous " , < nl > + " header " : 2580 , < nl > + " doc " : [ < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " baseUrl " , < nl > + " category " : " full " , < nl > + " description " : " Base Url for files " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " algo " , < nl > + " category " : " full " , < nl > + " description " : " Signature algorithm " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " signatureSecret " , < nl > + " category " : " full " , < nl > + " description " : " Signature Secret " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " timeout " , < nl > + " category " : " full " , < nl > + " description " : " Timeout of url builder " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : " string " , < nl > + " id " : 1 , < nl > + " name " : " baseUrl " < nl > + } , < nl > + { < nl > + " type " : " string " , < nl > + " id " : 2 , < nl > + " name " : " algo " < nl > + } , < nl > + { < nl > + " type " : " bytes " , < nl > + " id " : 3 , < nl > + " name " : " signatureSecret " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " sec " < nl > + } , < nl > + " id " : 4 , < nl > + " name " : " timeout " < nl > + } < nl > + ] < nl > + } , < nl > + " doc " : [ < nl > + " Get File URL Builder that allows to build file urls from client side " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " supportedSignatureAlgorithms " , < nl > + " category " : " hidden " , < nl > + " description " : " Supported signature algorithms by client " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : " string " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " supportedSignatureAlgorithms " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > " name " : " GetFileUploadUrl " , < nl > " header " : 97 , < nl > " response " : { < nl > @ @ - 18034 , 4 + 18115 , 4 @ @ < nl > ] < nl > } < nl > ] < nl > - } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala < nl > index e0403fd . . 86e2f67 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala < nl > @ @ - 3 , 17 + 3 , 17 @ @ package im . actor . server . file < nl > import java . io . ByteArrayOutputStream < nl > < nl > import akka . actor . ActorSystem < nl > - import com . sksamuel . scrimage . nio . { JpegWriter , ImageWriter , PngWriter } < nl > + import com . sksamuel . scrimage . nio . { ImageWriter , JpegWriter , PngWriter } < nl > import com . sksamuel . scrimage . { Image , ParImage , Position } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . model . AvatarData < nl > - import im . actor . server . persist . FileRepo < nl > + import im . actor . server . persist . files . FileRepo < nl > import im . actor . util . ThreadLocalSecureRandom < nl > import slick . dbio . DBIO < nl > < nl > import scala . concurrent . { ExecutionContext , Future } < nl > - import scala . util . { Try , Failure , Success } < nl > + import scala . util . { Failure , Success , Try } < nl > < nl > object ImageUtils { < nl > val AvatarSizeLimit = 1024L * 1024 / / TODO : configurable < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / http / GroupsHttpHandler . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / http / GroupsHttpHandler . scala < nl > index 0f43f1b . . d217925 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / http / GroupsHttpHandler . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / http / GroupsHttpHandler . scala < nl > @ @ - 12 , 6 + 12 , 7 @ @ import im . actor . server . file . ImageUtils . getAvatar < nl > import im . actor . server . file . { FileLocation , FileStorageExtension } < nl > import im . actor . server . model . AvatarData < nl > import im . actor . server . persist . _ < nl > + import im . actor . server . persist . files . FileRepo < nl > import play . api . libs . json . Json < nl > import slick . driver . PostgresDriver . api . _ < nl > import scala . concurrent . Future < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileStorageExtension . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileStorageExtension . scala < nl > index 06adcc1 . . c09b727 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileStorageExtension . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileStorageExtension . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import akka . actor . _ < nl > import im . actor . acl . ACLFiles < nl > import im . actor . config . ActorConfig < nl > import im . actor . serialization . ActorSerializer < nl > + import im . actor . server . api . http . HttpApi < nl > import im . actor . server . file . local . LocalUploadKey < nl > import im . actor . server . file . s3 . S3UploadKey < nl > < nl > @ @ - 31 , 8 + 32 , 12 @ @ class FileStorageExtensionImpl ( system : ActorSystem ) extends FileStorageExtension < nl > _ = system . log . debug ( " File adapter is : { } " , fqcn ) < nl > clazz ← Try ( Class . forName ( fqcn ) . asSubclass ( classOf [ FileStorageAdapter ] ) ) < nl > } yield clazz . getDeclaredConstructor ( classOf [ ActorSystem ] ) . newInstance ( system ) ) match { < nl > - case Success ( adapter ) ⇒ adapter < nl > - case Failure ( e ) ⇒ throw new RuntimeException ( " Failed to initialize FileStorageAdapter " , e ) < nl > + case Success ( adapter ) ⇒ < nl > + HttpApi ( system ) . registerHook ( " fileurlbuilder " ) { implicit system ⇒ < nl > + new FileUrlBuilderHttpHandler ( adapter ) . routes < nl > + } < nl > + adapter < nl > + case Failure ( e ) ⇒ throw new RuntimeException ( " Failed to initialize FileStorageAdapter " , e ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileUrlBuilderHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileUrlBuilderHttpHandler . scala < nl > new file mode 100644 < nl > index 0000000 . . b56cf76 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileUrlBuilderHttpHandler . scala < nl > @ @ - 0 , 0 + 1 , 87 @ @ < nl > + package im . actor . server . file < nl > + < nl > + import java . time . Instant < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . event . Logging < nl > + import akka . http . scaladsl . model . StatusCodes < nl > + import akka . http . scaladsl . server . Directives . _ < nl > + import akka . http . scaladsl . server . _ < nl > + import im . actor . acl . ACLFiles < nl > + import im . actor . server . api . http . HttpHandler < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . model . { File ⇒ FileModel } < nl > + import im . actor . server . persist . files . FileRepo < nl > + import im . actor . util . log . AnyRefLogSource < nl > + import org . apache . commons . codec . digest . HmacUtils < nl > + import scodec . bits . BitVector < nl > + < nl > + object FileUrlBuilderRejections { < nl > + case object SecretExpiredRejection extends Rejection < nl > + case object FileNotFoundRejection extends Rejection < nl > + case object IncorrectSignatureRejection extends Rejection < nl > + } < nl > + < nl > + private [ file ] final class FileUrlBuilderHttpHandler ( fsAdapter : FileStorageAdapter ) ( implicit system : ActorSystem ) extends HttpHandler with AnyRefLogSource { < nl > + import FileUrlBuilderRejections . _ < nl > + < nl > + private val db = DbExtension ( system ) . db < nl > + private val log = Logging ( system , this ) < nl > + < nl > + private val myRejectionHandler : RejectionHandler = < nl > + RejectionHandler . newBuilder ( ) < nl > + . handle { < nl > + case SecretExpiredRejection ⇒ < nl > + complete ( StatusCodes . Gone → " FileUrlBuilder expired ; request new builder ! " ) < nl > + } < nl > + . handle { < nl > + case FileNotFoundRejection ⇒ < nl > + complete ( StatusCodes . NotFound → " File not found " ) < nl > + } < nl > + . handle { < nl > + case IncorrectSignatureRejection ⇒ < nl > + complete ( StatusCodes . Forbidden → " Incorrect file signature " ) < nl > + } < nl > + . result ( ) < nl > + < nl > + / / format : OFF < nl > + def routes : Route = < nl > + handleRejections ( myRejectionHandler ) { < nl > + defaultVersion { < nl > + pathPrefix ( " fileUrlBuilder " ) { < nl > + parameter ( " fileId " . as [ Long ] ) { fileId = > < nl > + get { < nl > + validateBuilderRequest ( fileId ) { case ( fileModel , accessHash ) = > < nl > + onSuccess ( fsAdapter . getFileDownloadUrl ( fileModel , accessHash ) ) { < nl > + case Some ( url ) = > redirect ( url , StatusCodes . Found ) < nl > + case None = > complete ( StatusCodes . NotFound - > " File not found " ) < nl > + } < nl > + } < nl > + } < nl > + } < nl > + } < nl > + } < nl > + } < nl > + / / format : ON < nl > + < nl > + def validateBuilderRequest ( fileId : Long ) : Directive1 [ ( FileModel , Long ) ] = < nl > + parameters ( ( " seed " , " expire " . as [ Long ] , " signature " , " accessHash " . as [ Long ] ) ) tflatMap { < nl > + case ( seed , expire , signature , accessHash ) ⇒ < nl > + val secret = BitVector . fromLong ( ACLFiles . fileUrlBuilderSecret ( seed , expire ) ) . toByteArray < nl > + if ( signature = = HmacUtils . hmacSha256Hex ( secret , s " $ fileId $ accessHash " . getBytes ) ) { < nl > + if ( isExpired ( expire ) ) { < nl > + reject ( SecretExpiredRejection ) < nl > + } else { < nl > + onSuccess ( db . run ( FileRepo . find ( fileId ) ) ) flatMap { < nl > + case Some ( file ) ⇒ provide ( ( file , accessHash ) ) < nl > + case None ⇒ reject ( FileNotFoundRejection ) < nl > + } < nl > + } < nl > + } else { < nl > + reject ( IncorrectSignatureRejection ) < nl > + } < nl > + } < nl > + < nl > + def isExpired ( expire : Long ) : Boolean = Instant . ofEpochSecond ( expire ) . isAfter ( Instant . now ) < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / FileStorageOperations . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / FileStorageOperations . scala < nl > index 80cf1e5 . . d93866a 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / FileStorageOperations . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / FileStorageOperations . scala < nl > @ @ - 6 , 11 + 6 , 11 @ @ import akka . actor . ActorSystem < nl > import akka . event . Logging < nl > import akka . http . scaladsl . util . FastFuture < nl > import akka . stream . Materializer < nl > - import akka . stream . scaladsl . { Source , FileIO } < nl > + import akka . stream . scaladsl . { FileIO , Source } < nl > import akka . util . ByteString < nl > import better . files . { File , _ } < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . persist . FileRepo < nl > + import im . actor . server . persist . files . FileRepo < nl > < nl > import scala . concurrent . { ExecutionContext , Future , blocking } < nl > import scala . util . { Failure , Success } < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala < nl > index 8e36b83 . . 44208f2 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala < nl > @ @ - 6 , 7 + 6 , 7 @ @ import java . time . { Duration , Instant } < nl > < nl > import akka . actor . ActorSystem < nl > import akka . http . scaladsl . model . { HttpMethods , Uri } < nl > - import akka . stream . { Materializer , ActorMaterializer } < nl > + import akka . stream . { ActorMaterializer , Materializer } < nl > import better . files . _ < nl > import im . actor . acl . ACLFiles < nl > import im . actor . server . api . http . { HttpApi , HttpApiConfig } < nl > @ @ - 15 , 7 + 15 , 7 @ @ import im . actor . server . db . DbExtension < nl > import im . actor . server . file . _ < nl > import im . actor . server . model . { File ⇒ FileModel } < nl > import im . actor . server . file . local . http . FilesHttpHandler < nl > - import im . actor . server . persist . FileRepo < nl > + import im . actor . server . persist . files . FileRepo < nl > import im . actor . util . ThreadLocalSecureRandom < nl > < nl > import scala . concurrent . { ExecutionContext , Future } < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > index bd6ab46 . . e1edfdc 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > @ @ - 1 , 7 + 1 , 6 @ @ < nl > package im . actor . server . file . local . http < nl > < nl > import java . time . { Duration , Instant } < nl > - import java . util . concurrent . Executors < nl > < nl > import akka . actor . ActorSystem < nl > import akka . event . Logging < nl > @ @ - 32 , 12 + 31 , 6 @ @ private [ local ] final class FilesHttpHandler ( storageConfig : LocalFileStorageConfi < nl > < nl > private val log = Logging ( system , this ) < nl > < nl > - val SignedLongNumber : PathMatcher1 [ Long ] = < nl > - PathMatcher ( " " " [ + - ] ? \ d + " " " . r ) flatMap { string ⇒ < nl > - try Some ( java . lang . Long . parseLong ( string ) ) < nl > - catch { case _ : NumberFormatException ⇒ None } < nl > - } < nl > - < nl > / / format : OFF < nl > def routes : Route = < nl > extractRequest { request = > < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala < nl > index b8a8fec . . d1a792e 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala < nl > @ @ - 19 , 7 + 19 , 7 @ @ import im . actor . server . db . DbExtension < nl > import im . actor . server . file . FileUtils . _ < nl > import im . actor . server . file . _ < nl > import im . actor . server . model . { File ⇒ FileModel } < nl > - import im . actor . server . persist . FileRepo < nl > + import im . actor . server . persist . files . FileRepo < nl > import im . actor . util . ThreadLocalSecureRandom < nl > < nl > import scala . concurrent . duration . _ < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiHelpers . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiHelpers . scala < nl > index 43b9349 . . 907758b 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiHelpers . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiHelpers . scala < nl > @ @ - 2 , 7 + 2 , 7 @ @ package im . actor . server . api . http < nl > < nl > import akka . http . scaladsl . model . _ < nl > import akka . http . scaladsl . server . Directives . _ < nl > - import akka . http . scaladsl . server . Route < nl > + import akka . http . scaladsl . server . { PathMatcher , _ } < nl > < nl > object HttpApiHelpers extends HttpApiHelpers < nl > < nl > @ @ - 21 , 4 + 21 , 10 @ @ trait HttpApiHelpers { < nl > } < nl > } < nl > < nl > + val SignedLongNumber : PathMatcher1 [ Long ] = < nl > + PathMatcher ( " " " [ + - ] ? \ d + " " " . r ) flatMap { string ⇒ < nl > + try Some ( java . lang . Long . parseLong ( string ) ) < nl > + catch { case _ : NumberFormatException ⇒ None } < nl > + } < nl > + < nl > } < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FilePartRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FilePartRepo . scala < nl > deleted file mode 100644 < nl > index 840313e . . 0000000 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FilePartRepo . scala < nl > + + + / dev / null < nl > @ @ - 1 , 28 + 0 , 0 @ @ < nl > - package im . actor . server . persist < nl > - < nl > - import im . actor . server . model . FilePart < nl > - import slick . dbio . Effect . { Read , Write } < nl > - import slick . driver . PostgresDriver . api . _ < nl > - import slick . profile . { FixedSqlStreamingAction , FixedSqlAction } < nl > - < nl > - final class FilePartTable ( tag : Tag ) extends Table [ FilePart ] ( tag , " file _ parts " ) { < nl > - def fileId = column [ Long ] ( " file _ id " , O . PrimaryKey ) < nl > - < nl > - def number = column [ Int ] ( " number " , O . PrimaryKey ) < nl > - < nl > - def size = column [ Int ] ( " size " ) < nl > - < nl > - def uploadKey = column [ String ] ( " upload _ key " ) < nl > - < nl > - def * = ( fileId , number , size , uploadKey ) < > ( FilePart . tupled , FilePart . unapply ) < nl > - } < nl > - < nl > - object FilePartRepo { < nl > - val parts = TableQuery [ FilePartTable ] < nl > - < nl > - def createOrUpdate ( fileId : Long , number : Int , size : Int , uploadKey : String ) : FixedSqlAction [ Int , NoStream , Write ] = < nl > - parts . insertOrUpdate ( FilePart ( fileId , number , size , uploadKey ) ) < nl > - < nl > - def findByFileId ( fileId : Long ) : FixedSqlStreamingAction [ Seq [ FilePart ] , FilePart , Read ] = < nl > - parts . filter ( _ . fileId = = = fileId ) . sortBy ( _ . number ) . result < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FileRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FileRepo . scala < nl > deleted file mode 100644 < nl > index 161a2de . . 0000000 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FileRepo . scala < nl > + + + / dev / null < nl > @ @ - 1 , 41 + 0 , 0 @ @ < nl > - package im . actor . server . persist < nl > - < nl > - import im . actor . server . model . File < nl > - import slick . dbio . Effect . { Read , Write } < nl > - import slick . driver . PostgresDriver . api . _ < nl > - import slick . profile . { SqlAction , FixedSqlAction } < nl > - < nl > - final class FileTable ( tag : Tag ) extends Table [ File ] ( tag , " files " ) { < nl > - def id = column [ Long ] ( " id " , O . PrimaryKey ) < nl > - < nl > - def accessSalt = column [ String ] ( " access _ salt " ) < nl > - < nl > - def uploadKey = column [ String ] ( " upload _ key " ) < nl > - < nl > - def isUploaded = column [ Boolean ] ( " is _ uploaded " ) < nl > - < nl > - def size = column [ Long ] ( " size " ) < nl > - < nl > - def name = column [ String ] ( " name " ) < nl > - < nl > - def * = ( id , accessSalt , uploadKey , isUploaded , size , name ) < > ( File . tupled , File . unapply ) < nl > - } < nl > - < nl > - object FileRepo { < nl > - val files = TableQuery [ FileTable ] < nl > - < nl > - def create ( id : Long , expectedSize : Long , accessSalt : String , uploadKey : String ) : FixedSqlAction [ Int , NoStream , Write ] = < nl > - files + = File ( id , accessSalt , uploadKey , isUploaded = false , size = expectedSize , name = " " ) < nl > - < nl > - def find ( id : Long ) : SqlAction [ Option [ File ] , NoStream , Read ] = < nl > - files . filter ( _ . id = = = id ) . result . headOption < nl > - < nl > - def fetch ( ids : Set [ Long ] ) = < nl > - files . filter ( _ . id inSetBind ids ) . result < nl > - < nl > - def findByKey ( key : String ) = < nl > - files . filter ( _ . uploadKey = = = key ) . result . headOption < nl > - < nl > - def setUploaded ( id : Long , name : String ) = < nl > - files . filter ( _ . id = = = id ) . map ( f ⇒ ( f . isUploaded , f . name ) ) . update ( ( true , name ) ) < nl > - } < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FilePartRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FilePartRepo . scala < nl > new file mode 100644 < nl > index 0000000 . . 7bf4c7c < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FilePartRepo . scala < nl > @ @ - 0 , 0 + 1 , 25 @ @ < nl > + package im . actor . server . persist . files < nl > + < nl > + import im . actor . server . model . FilePart < nl > + import slick . dbio . Effect . { Read , Write } < nl > + import slick . driver . PostgresDriver . api . _ < nl > + import slick . profile . { FixedSqlAction , FixedSqlStreamingAction } < nl > + < nl > + final class FilePartTable ( tag : Tag ) extends Table [ FilePart ] ( tag , " file _ parts " ) { < nl > + def fileId = column [ Long ] ( " file _ id " , O . PrimaryKey ) < nl > + def number = column [ Int ] ( " number " , O . PrimaryKey ) < nl > + def size = column [ Int ] ( " size " ) < nl > + def uploadKey = column [ String ] ( " upload _ key " ) < nl > + < nl > + def * = ( fileId , number , size , uploadKey ) < > ( FilePart . tupled , FilePart . unapply ) < nl > + } < nl > + < nl > + object FilePartRepo { < nl > + val parts = TableQuery [ FilePartTable ] < nl > + < nl > + def createOrUpdate ( fileId : Long , number : Int , size : Int , uploadKey : String ) : FixedSqlAction [ Int , NoStream , Write ] = < nl > + parts . insertOrUpdate ( FilePart ( fileId , number , size , uploadKey ) ) < nl > + < nl > + def findByFileId ( fileId : Long ) : FixedSqlStreamingAction [ Seq [ FilePart ] , FilePart , Read ] = < nl > + parts . filter ( _ . fileId = = = fileId ) . sortBy ( _ . number ) . result < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FileRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FileRepo . scala < nl > new file mode 100644 < nl > index 0000000 . . cce27e8 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FileRepo . scala < nl > @ @ - 0 , 0 + 1 , 36 @ @ < nl > + package im . actor . server . persist . files < nl > + < nl > + import im . actor . server . model . File < nl > + import slick . dbio . Effect . { Read , Write } < nl > + import slick . driver . PostgresDriver . api . _ < nl > + import slick . profile . { FixedSqlAction , SqlAction } < nl > + < nl > + final class FileTable ( tag : Tag ) extends Table [ File ] ( tag , " files " ) { < nl > + def id = column [ Long ] ( " id " , O . PrimaryKey ) < nl > + def accessSalt = column [ String ] ( " access _ salt " ) < nl > + def uploadKey = column [ String ] ( " upload _ key " ) < nl > + def isUploaded = column [ Boolean ] ( " is _ uploaded " ) < nl > + def size = column [ Long ] ( " size " ) < nl > + def name = column [ String ] ( " name " ) < nl > + < nl > + def * = ( id , accessSalt , uploadKey , isUploaded , size , name ) < > ( File . tupled , File . unapply ) < nl > + } < nl > + < nl > + object FileRepo { < nl > + val files = TableQuery [ FileTable ] < nl > + < nl > + def create ( id : Long , expectedSize : Long , accessSalt : String , uploadKey : String ) : FixedSqlAction [ Int , NoStream , Write ] = < nl > + files + = File ( id , accessSalt , uploadKey , isUploaded = false , size = expectedSize , name = " " ) < nl > + < nl > + def find ( id : Long ) : SqlAction [ Option [ File ] , NoStream , Read ] = < nl > + files . filter ( _ . id = = = id ) . result . headOption < nl > + < nl > + def fetch ( ids : Set [ Long ] ) = < nl > + files . filter ( _ . id inSetBind ids ) . result < nl > + < nl > + def findByKey ( key : String ) = < nl > + files . filter ( _ . uploadKey = = = key ) . result . headOption < nl > + < nl > + def setUploaded ( id : Long , name : String ) = < nl > + files . filter ( _ . id = = = id ) . map ( f ⇒ ( f . isUploaded , f . name ) ) . update ( ( true , name ) ) < nl > + } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / FileHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / FileHelpers . scala < nl > index 069476c . . aedc68d 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / FileHelpers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / FileHelpers . scala < nl > @ @ - 2 , 19 + 2 , 18 @ @ package im . actor . api . rpc < nl > < nl > import cats . data . Xor < nl > import im . actor . server . acl . ACLUtils < nl > - import im . actor . server . persist . FileRepo < nl > < nl > import scala . concurrent . ExecutionContext < nl > - < nl > import akka . actor . ActorSystem < nl > import slick . dbio . DBIO < nl > - < nl > import im . actor . api . rpc . files . ApiFileLocation < nl > + import im . actor . server . persist . files . FileRepo < nl > < nl > object FileRpcErrors { < nl > val FileNotFound = RpcError ( 404 , " FILE _ NOT _ FOUND " , " File not found . " , false , None ) < nl > val FileTooLarge = RpcError ( 400 , " FILE _ TOO _ LARGE " , " File is too large . " , false , None ) < nl > val LocationInvalid = RpcError ( 400 , " LOCATION _ INVALID " , " " , false , None ) < nl > + val UnsupportedSignatureAlgorithm = RpcError ( 400 , " SIGNATURE _ ALGO _ NOT _ SUPPORTED " , " " , false , None ) < nl > } < nl > < nl > object FileHelpers { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / files / FilesServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / files / FilesServiceImpl . scala < nl > index 190b913 . . ebf8668 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / files / FilesServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / files / FilesServiceImpl . scala < nl > @ @ - 1 , 17 + 1 , 27 @ @ < nl > package im . actor . server . api . rpc . service . files < nl > < nl > + import java . nio . ByteBuffer < nl > + import java . time . temporal . ChronoUnit < nl > + import java . time . Instant < nl > + < nl > import akka . actor . _ < nl > + import akka . http . scaladsl . model . Uri < nl > + import akka . http . scaladsl . util . FastFuture < nl > import cats . data . Xor < nl > - import im . actor . api . rpc . files . _ < nl > + import im . actor . api . rpc . FileRpcErrors . UnsupportedSignatureAlgorithm < nl > import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . files . _ < nl > import im . actor . concurrent . FutureExt < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . api . http . HttpApiConfig < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . file . _ < nl > - import im . actor . server . persist . { FilePartRepo , FileRepo } < nl > + import im . actor . server . persist . files . { FilePartRepo , FileRepo } < nl > + import scodec . bits . BitVector < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . concurrent . duration . _ < nl > < nl > class FilesServiceImpl ( implicit actorSystem : ActorSystem ) extends FilesService { < nl > < nl > @ @ - 21 , 6 + 31 , 8 @ @ class FilesServiceImpl ( implicit actorSystem : ActorSystem ) extends FilesService { < nl > < nl > private implicit val db : Database = DbExtension ( actorSystem ) . db < nl > private val fsAdapter : FileStorageAdapter = FileStorageExtension ( actorSystem ) . fsAdapter < nl > + private val httpConfig = HttpApiConfig . load . get < nl > + private val urlBuilderTimeout : Int = 1 . hour . toMillis . toInt < nl > < nl > override def doHandleGetFileUrl ( location : ApiFileLocation , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetFileUrl ] ] = < nl > authorized ( clientData ) { client ⇒ < nl > @ @ - 78 , 4 + 90 , 25 @ @ class FilesServiceImpl ( implicit actorSystem : ActorSystem ) extends FilesService { < nl > _ ← fromFuture ( fsAdapter . completeFileUpload ( file . id , file . size , UnsafeFileName ( fileName ) , partNames ) ) < nl > } yield ResponseCommitFileUpload ( ApiFileLocation ( file . id , ACLUtils . fileAccessHash ( file . id , file . accessSalt ) ) ) ) . value < nl > } < nl > + < nl > + protected def doHandleGetFileUrlBuilder ( supportedSignatureAlgorithms : IndexedSeq [ String ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetFileUrlBuilder ] ] = < nl > + authorized ( clientData ) { _ ⇒ < nl > + val result = if ( supportedSignatureAlgorithms . contains ( " HMAC _ SHA256 " ) ) { < nl > + val seed = ACLUtils . randomString ( ) < nl > + val expire = Instant . now . plus ( 1 , ChronoUnit . HOURS ) . getEpochSecond < nl > + val secret = ACLUtils . fileUrlBuilderSecret ( seed , expire ) < nl > + val baseUrl = Uri ( httpConfig . baseUri ) < nl > + . withPath ( Uri . Path ( " / v1 / fileUrlBuilder " ) ) < nl > + . withQuery ( Uri . Query ( " seed " → seed , " expire " → expire . toString ) ) < nl > + Ok ( < nl > + ResponseGetFileUrlBuilder ( < nl > + baseUrl = baseUrl . toString ( ) , < nl > + algo = " HMAC _ SHA256 " , < nl > + signatureSecret = BitVector . fromLong ( secret ) . toByteArray , < nl > + timeout = urlBuilderTimeout < nl > + ) < nl > + ) < nl > + } else Error ( UnsupportedSignatureAlgorithm ) < nl > + FastFuture . successful ( result ) < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala < nl > index 88b2093 . . b53ef1f 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala < nl > @ @ - 11 , 7 + 11 , 7 @ @ trait ACLBase { < nl > < nl > def getMDInstance ( ) = ThreadLocalMD5 . current ( ) < nl > < nl > - def secretKey ( ) ( implicit s : ActorSystem ) = < nl > + def secretKey ( ) ( implicit s : ActorSystem ) : String = < nl > s . settings . config . getString ( " secret " ) < nl > < nl > def hash ( s : String , md : MessageDigest = getMDInstance ( ) ) : Long = < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLFiles . scala b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLFiles . scala < nl > index 5cc7f2b . . e401799 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLFiles . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLFiles . scala < nl > @ @ - 7 , 4 + 7 , 8 @ @ object ACLFiles extends ACLFiles < nl > trait ACLFiles extends ACLBase { < nl > def fileAccessHash ( fileId : Long , accessSalt : String ) ( implicit s : ActorSystem ) : Long = < nl > hash ( s " $ fileId : $ accessSalt : $ { secretKey ( ) } " ) < nl > + < nl > + def fileUrlBuilderSecret ( seed : String , expire : Long ) ( implicit s : ActorSystem ) : Long = < nl > + hash ( s " $ seed : $ expire : $ { secretKey ( ) } " ) < nl > + < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala < nl > new file mode 100644 < nl > index 0000000 . . 9b8e44a < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala < nl > @ @ - 0 , 0 + 1 , 33 @ @ < nl > + package im . actor . bot < nl > + < nl > + import derive . key < nl > + < nl > + sealed trait BotMessage < nl > + < nl > + final object BotMessages { < nl > + final object OutPeer { < nl > + def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) < nl > + def group ( id : Int , accessHash : Long ) = OutPeer ( 2 , id , accessHash ) < nl > + } < nl > + final case class OutPeer ( ` type ` : Int , id : Int , accessHash : Long ) < nl > + final case class Peer ( ` type ` : Int , id : Int ) < nl > + < nl > + sealed trait RequestBody < nl > + < nl > + final case class BotRequest ( id : Long , body : RequestBody ) extends BotMessage < nl > + < nl > + @ key ( " SendMessage " ) < nl > + final case class SendTextMessage ( peer : OutPeer , randomId : Long , message : String ) extends RequestBody < nl > + < nl > + sealed trait ResponseBody < nl > + < nl > + final case class BotResponse ( id : Long , body : ResponseBody ) extends BotMessage < nl > + < nl > + @ key ( " MessageSent " ) < nl > + final case class MessageSent ( date : Long ) extends ResponseBody < nl > + < nl > + sealed trait BotUpdate extends BotMessage < nl > + < nl > + @ key ( " TextMessage " ) < nl > + final case class TextMessage ( peer : Peer , senderUserId : Int , date : Long , randomId : Long , message : String ) extends BotUpdate < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala < nl > new file mode 100644 < nl > index 0000000 . . f2d446e < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala < nl > @ @ - 0 , 0 + 1 , 98 @ @ < nl > + package im . actor . server . bot < nl > + < nl > + import akka . actor . { ExtendedActorSystem , ExtensionId , ActorSystem , Extension } < nl > + import akka . util . Timeout < nl > + import im . actor . api . rpc . users . ApiSex < nl > + import im . actor . config . ActorConfig < nl > + import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . user . UserExtension < nl > + import im . actor . server . persist < nl > + import im . actor . util . misc . IdUtils < nl > + import shardakka . ShardakkaExtension < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + object BotExtension extends ExtensionId [ BotExtension ] { < nl > + private [ bot ] val tokensKV = " BotsTokens " < nl > + < nl > + override def createExtension ( system : ExtendedActorSystem ) : BotExtension = new BotExtensionImpl ( system ) < nl > + } < nl > + < nl > + trait BotExtension extends Extension { < nl > + type Token = String < nl > + type UserId = Int < nl > + type AuthId = Long < nl > + < nl > + / * * < nl > + * Creates a bot user < nl > + * < nl > + * @ return token future < nl > + * / < nl > + def create ( name : String ) : Future [ Token ] < nl > + < nl > + / * * < nl > + * Gets userId associated with token < nl > + * < nl > + * @ param token < nl > + * @ return user id < nl > + * / < nl > + def getUserId ( token : String ) : Future [ Option [ UserId ] ] < nl > + < nl > + / * * < nl > + * Gets or creates bot auth id < nl > + * @ param token < nl > + * @ return auth id < nl > + * / < nl > + def getAuthId ( token : String ) : Future [ Option [ AuthId ] ] < nl > + } < nl > + < nl > + private [ bot ] final class BotExtensionImpl ( _ system : ActorSystem ) extends BotExtension { < nl > + import _ system . _ < nl > + < nl > + private implicit val system = _ system < nl > + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) < nl > + < nl > + private lazy val userExt = UserExtension ( system ) < nl > + private lazy val tokensKV = ShardakkaExtension ( system ) . simpleKeyValue ( BotExtension . tokensKV ) < nl > + private lazy val db = DbExtension ( system ) . db < nl > + < nl > + override def create ( name : String ) : Future [ Token ] = { < nl > + val userId = IdUtils . nextIntId ( ) < nl > + val token = ACLUtils . randomHash ( ) < nl > + < nl > + for { < nl > + user ← userExt . create ( < nl > + userId = userId , < nl > + accessSalt = ACLUtils . nextAccessSalt ( ) , < nl > + name = name , < nl > + countryCode = " US " , < nl > + sex = ApiSex . Unknown , < nl > + isBot = true < nl > + ) < nl > + _ ← tokensKV . upsert ( token , s " $ userId " ) < nl > + } yield token < nl > + } < nl > + < nl > + override def getUserId ( token : String ) : Future [ Option [ UserId ] ] = { < nl > + for { < nl > + tokOpt ← tokensKV . get ( token ) < nl > + } yield tokOpt map ( _ . toInt ) < nl > + } < nl > + < nl > + override def getAuthId ( token : String ) : Future [ Option [ AuthId ] ] = { < nl > + getUserId ( token ) flatMap { < nl > + case Some ( userId ) ⇒ getOrCreateAuthId ( userId ) map ( Some ( _ ) ) < nl > + case None ⇒ Future . successful ( None ) < nl > + } < nl > + } < nl > + < nl > + private def getOrCreateAuthId ( userId : Int ) : Future [ AuthId ] = { < nl > + db . run ( persist . AuthId . findFirstIdByUserId ( userId ) ) flatMap { < nl > + case Some ( authId ) ⇒ Future . successful ( authId ) < nl > + case None ⇒ < nl > + val authId = ACLUtils . randomLong ( ) < nl > + db . run ( persist . AuthId . create ( authId , Some ( userId ) , None ) ) map ( _ ⇒ authId ) < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > index ba37e90 . . 734f1f9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > @ @ - 46 , 7 + 46 , 18 @ @ object ACLUtils { < nl > def authTransactionHash ( accessSalt : String ) ( implicit s : ActorSystem ) : String = < nl > DigestUtils . sha1Hex ( s " $ accessSalt : $ { secretKey ( ) } " ) < nl > < nl > - def nextAccessSalt ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString < nl > + def randomHash ( ) ( implicit s : ActorSystem ) : String = < nl > + DigestUtils . sha1Hex ( s " $ { randomString ( ) } : $ { secretKey ( ) } " ) < nl > + < nl > + def randomLong ( ) : Long = randomLong ( ThreadLocalRandom . current ( ) ) < nl > + < nl > + def randomLong ( rng : ThreadLocalRandom ) : Long = rng . nextLong ( ) < nl > + < nl > + def randomString ( ) : String = randomString ( ThreadLocalRandom . current ( ) ) < nl > + < nl > + def randomString ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString < nl > + < nl > + def nextAccessSalt ( rng : ThreadLocalRandom ) : String = randomString ( rng ) < nl > < nl > def nextAccessSalt ( ) : String = { < nl > nextAccessSalt ( ThreadLocalRandom . current ( ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index bd3b59c . . 79e425b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 5 , 6 + 5 , 7 @ @ import akka . pattern . ask < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . messaging . ApiMessage < nl > import im . actor . api . rpc . misc . ApiExtension < nl > + import im . actor . api . rpc . peers . ApiPeer < nl > import im . actor . api . rpc . peers . ApiPeerType . _ < nl > import im . actor . api . rpc . peers . ApiPeerType . ApiPeerType < nl > import im . actor . extension . InternalExtensions < nl > @ @ - 28 , 7 + 29 , 17 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { < nl > < nl > implicit val s : ActorSystem = system < nl > implicit val ec : ExecutionContext = system . dispatcher < nl > - implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable < nl > + implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable < nl > + < nl > + def sendMessage ( < nl > + peer : ApiPeer , < nl > + senderUserId : Int , < nl > + senderAuthId : Long , < nl > + randomId : Long , < nl > + message : ApiMessage , < nl > + isFat : Boolean < nl > + ) : Future [ SeqStateDate ] = < nl > + sendMessage ( peer . ` type ` , peer . id , senderUserId , senderAuthId , randomId , message , isFat ) < nl > < nl > def sendMessage ( peerType : ApiPeerType , peerId : Int , senderUserId : Int , senderAuthId : Long , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = { < nl > ( peerType match { < nl > @ @ - 83 , 4 + 94 , 4 @ @ object DialogExtension extends ExtensionId [ DialogExtensionImpl ] with ExtensionId < nl > override def lookup = DialogExtension < nl > < nl > override def createExtension ( system : ExtendedActorSystem ) = new DialogExtensionImpl ( system ) < nl > - } < nl > \ No newline at end of file < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > index 9552f85 . . 56fd62a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > @ @ - 8 , 7 + 8 , 7 @ @ import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { Future , Promise } < nl > - import scala . util . { Failure , Success , Try } < nl > + import scala . util . Try < nl > < nl > sealed trait SeqUpdatesExtension extends Extension { < nl > val region : SeqUpdatesManagerRegion < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > index cd328be . . 2a6c005 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > @ @ - 10 , 11 + 10 , 11 @ @ import im . actor . api . rpc . users . ApiUser < nl > import im . actor . api . rpc . weak . { UpdateGroupOnline , UpdateUserLastSeen , UpdateUserOffline , UpdateUserOnline } < nl > import im . actor . api . rpc . { Update , UpdateBox ⇒ ProtoUpdateBox } < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . group . { GroupExtension , GroupOffice , GroupViewRegion } < nl > + import im . actor . server . group . GroupExtension < nl > import im . actor . server . mtproto . protocol . UpdateBox < nl > import im . actor . server . persist < nl > import im . actor . server . presences . _ < nl > - import im . actor . server . user . { UserExtension , UserOffice , UserViewRegion } < nl > + import im . actor . server . user . UserExtension < nl > import org . joda . time . DateTime < nl > < nl > import scala . concurrent . _ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > index b06a574 . . 533795b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > @ @ - 33 , 9 + 33 , 17 @ @ private [ user ] sealed trait Commands extends AuthCommands { < nl > < nl > implicit val timeout : Timeout < nl > < nl > - def create ( userId : Int , accessSalt : String , name : String , countryCode : String , sex : ApiSex . ApiSex , isBot : Boolean , extensions : Seq [ ApiExtension ] , external : Option [ String ] ) : Future [ CreateAck ] = { < nl > + def create ( < nl > + userId : Int , < nl > + accessSalt : String , < nl > + name : String , < nl > + countryCode : String , < nl > + sex : ApiSex . ApiSex , < nl > + isBot : Boolean , < nl > + extensions : Seq [ ApiExtension ] = Seq . empty , < nl > + external : Option [ String ] = None < nl > + ) : Future [ CreateAck ] = < nl > ( processorRegion . ref ? Create ( userId , accessSalt , name , countryCode , sex , isBot , extensions , external ) ) . mapTo [ CreateAck ] < nl > - } < nl > < nl > def addPhone ( userId : Int , phone : Long ) : Future [ Unit ] = { < nl > ( processorRegion . ref ? AddPhone ( userId , phone ) ) . mapTo [ AddPhoneAck ] map ( _ ⇒ ( ) ) < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala < nl > new file mode 100644 < nl > index 0000000 . . 940b6dd < nl > - - - / dev / null < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala < nl > @ @ - 0 , 0 + 1 , 68 @ @ < nl > + package im . actor . server . api . http . bots < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . stream . scaladsl . { Flow , Merge , Source } < nl > + import im . actor . api . rpc . messaging . ApiTextMessage < nl > + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . bot . BotMessages < nl > + import im . actor . server . dialog . DialogExtension < nl > + import im . actor . server . sequence . SeqStateDate < nl > + import upickle . default . _ < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + final class BotBlueprint ( botUserId : Int , botAuthId : Long , system : ActorSystem ) { < nl > + < nl > + import BotMessages . _ < nl > + import akka . stream . scaladsl . FlowGraph . Implicits . _ < nl > + import system . _ < nl > + < nl > + private lazy val dialogExt = DialogExtension ( system ) < nl > + < nl > + val flow : Flow [ String , String , Unit ] = { < nl > + val updSource = < nl > + Source . actorPublisher [ BotUpdate ] ( UpdatesSource . props ( botAuthId ) ) < nl > + . map ( write [ BotUpdate ] ) < nl > + < nl > + val rqrspFlow = Flow [ String ] < nl > + . map ( parseMessage ) < nl > + . mapAsync ( 1 ) ( r ⇒ handleRequest ( r . id , r . body ) ) < nl > + . map ( write [ BotResponse ] ) < nl > + < nl > + Flow ( ) { implicit b ⇒ < nl > + val upd = b . add ( updSource ) < nl > + val rqrsp = b . add ( rqrspFlow ) < nl > + val merge = b . add ( Merge [ String ] ( 2 ) ) < nl > + < nl > + upd ~ > merge < nl > + rqrsp ~ > merge < nl > + < nl > + ( rqrsp . inlet , merge . out ) < nl > + } < nl > + } < nl > + < nl > + private def parseMessage ( source : String ) : BotRequest = read [ BotRequest ] ( source ) < nl > + < nl > + private def handleRequest ( id : Long , body : RequestBody ) : Future [ BotResponse ] = < nl > + for { < nl > + response ← handleRequestBody ( body ) < nl > + } yield BotResponse ( id , response ) < nl > + < nl > + private def handleRequestBody ( body : RequestBody ) : Future [ ResponseBody ] = body match { < nl > + case SendTextMessage ( peer , randomId , message ) ⇒ sendTextMessage ( peer , randomId , message ) < nl > + } < nl > + < nl > + private def sendTextMessage ( peer : OutPeer , randomId : Long , message : String ) : Future [ ResponseBody ] = { < nl > + / / FIXME : check access hash < nl > + for { < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( < nl > + peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , < nl > + senderUserId = botUserId , < nl > + senderAuthId = 0L , < nl > + randomId = randomId , < nl > + message = ApiTextMessage ( message , Vector . empty , None ) , < nl > + isFat = false < nl > + ) < nl > + } yield MessageSent ( date ) < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > new file mode 100644 < nl > index 0000000 . . efa0994 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > @ @ - 0 , 0 + 1 , 46 @ @ < nl > + package im . actor . server . api . http . bots < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . http . scaladsl . model . ws . { Message , TextMessage } < nl > + import akka . http . scaladsl . server . Directives . _ < nl > + import akka . http . scaladsl . server . Route < nl > + import akka . stream . scaladsl . Flow < nl > + import cats . data . OptionT < nl > + import cats . std . future . _ < nl > + import im . actor . server . api . http . RoutesHandler < nl > + import im . actor . server . bot . BotExtension < nl > + < nl > + import scala . util . control . NoStackTrace < nl > + < nl > + private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler { < nl > + < nl > + import system . _ < nl > + < nl > + private val botExt = BotExtension ( system ) < nl > + < nl > + override def routes : Route = path ( " bots " / Segment ) { token ⇒ < nl > + val flowFuture = ( for { < nl > + userId ← OptionT ( botExt . getUserId ( token ) ) < nl > + authId ← OptionT ( botExt . getAuthId ( token ) ) < nl > + } yield flow ( userId , authId ) ) . value map { < nl > + case Some ( r ) ⇒ r < nl > + case None ⇒ throw new RuntimeException ( " Wrong token " ) with NoStackTrace < nl > + } < nl > + < nl > + onSuccess ( flowFuture ) { < nl > + case flow ⇒ handleWebsocketMessages ( flow ) < nl > + } < nl > + } < nl > + < nl > + private def flow ( botUserId : Int , botAuthId : Long ) = { < nl > + val bp = new BotBlueprint ( botUserId , botAuthId , system ) < nl > + < nl > + Flow [ Message ] < nl > + . collect { < nl > + case TextMessage . Strict ( text ) ⇒ text < nl > + case tm : TextMessage ⇒ throw new RuntimeException ( " Streamed text message is not supported " ) with NoStackTrace < nl > + } < nl > + . via ( bp . flow ) < nl > + . map ( TextMessage . Strict ( _ ) . asInstanceOf [ Message ] ) < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala < nl > new file mode 100644 < nl > index 0000000 . . 40f3804 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala < nl > @ @ - 0 , 0 + 1 , 95 @ @ < nl > + package im . actor . server . api . http . bots < nl > + < nl > + import akka . actor . { ActorLogging , Props } < nl > + import akka . stream . actor . ActorPublisher < nl > + import im . actor . api . rpc . codecs . _ < nl > + import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateMessage } < nl > + import im . actor . api . rpc . sequence . SeqUpdate < nl > + import im . actor . bot . BotMessages < nl > + import im . actor . server . mtproto . protocol . UpdateBox < nl > + import im . actor . server . presences . { GroupPresenceManager , PresenceManager } < nl > + import im . actor . server . sequence . { UpdatesConsumer , WeakUpdatesManager } < nl > + < nl > + import scala . annotation . tailrec < nl > + < nl > + private [ bots ] object UpdatesSource { < nl > + def props ( authId : Long ) = Props ( classOf [ UpdatesSource ] , authId ) < nl > + } < nl > + < nl > + private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotMessages . BotUpdate ] with ActorLogging { < nl > + < nl > + import BotMessages . { Peer , TextMessage } < nl > + import akka . stream . actor . ActorPublisherMessage . _ < nl > + import context . _ < nl > + import im . actor . server . sequence . NewUpdate < nl > + < nl > + private implicit val weakUpdatesManagerRegion = WeakUpdatesManager . startRegionProxy ( ) < nl > + private implicit val presenceManagerRegion = PresenceManager . startRegionProxy ( ) < nl > + private implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegionProxy ( ) < nl > + < nl > + context . actorOf ( UpdatesConsumer . props ( authId , self ) , " updatesConsumer " ) < nl > + < nl > + private var buf = Vector . empty [ BotMessages . BotUpdate ] < nl > + < nl > + def receive = { < nl > + case NewUpdate ( UpdateBox ( bodyBytes ) , _ ) ⇒ < nl > + UpdateBoxCodec . decode ( bodyBytes ) . require . value match { < nl > + case SeqUpdate ( _ , _ , header , body ) ⇒ < nl > + < nl > + header match { < nl > + case UpdateMessage . header ⇒ < nl > + UpdateMessage . parseFrom ( body ) match { < nl > + case Right ( upd ) ⇒ < nl > + upd . message match { < nl > + case ApiTextMessage ( message , _ , _ ) ⇒ < nl > + log . debug ( " Received ApiTextMessage " ) < nl > + enqueue ( TextMessage ( < nl > + peer = Peer ( upd . peer . ` type ` . id , upd . peer . id ) , < nl > + senderUserId = upd . senderUserId , < nl > + date = upd . date , < nl > + randomId = upd . randomId , < nl > + message = message < nl > + ) ) < nl > + case _ ⇒ < nl > + log . debug ( " Received non - text message , ignoring " ) < nl > + } < nl > + < nl > + case Left ( e ) ⇒ < nl > + log . error ( e , " Failed to parse UpdateMessage " ) < nl > + } < nl > + case _ ⇒ < nl > + log . debug ( " Received SeqUpdate with header : { } , ignoring " , header ) < nl > + } < nl > + case _ ⇒ < nl > + } < nl > + case Request ( _ ) ⇒ < nl > + deliverBuf ( ) < nl > + case Cancel ⇒ < nl > + context . stop ( self ) < nl > + } < nl > + < nl > + private def enqueue ( upd : BotMessages . BotUpdate ) : Unit = { < nl > + log . debug ( " Enqueuing { } " , upd ) < nl > + < nl > + if ( buf . isEmpty & & totalDemand > 0 ) { < nl > + onNext ( upd ) < nl > + } else { < nl > + buf : + = upd < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + < nl > + @ tailrec final def deliverBuf ( ) : Unit = < nl > + if ( totalDemand > 0 ) { < nl > + if ( totalDemand < = Int . MaxValue ) { < nl > + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) < nl > + buf = keep < nl > + use foreach onNext < nl > + } else { < nl > + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) < nl > + buf = keep < nl > + use foreach onNext < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala < nl > index 8e12f6e . . aa01de9 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala < nl > @ @ - 43 , 6 + 43 , 7 @ @ object AuthId { < nl > < nl > val activeByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) ) < nl > val activeIdByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) map ( _ . id ) ) < nl > + val firstActiveIdByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) map ( _ . id ) take ( 1 ) ) < nl > < nl > def activeIdByUserIds ( userIds : Set [ Int ] ) = activeAuthIds . filter ( _ . userId inSetBind userIds ) . map ( _ . id ) < nl > < nl > @ @ - 61 , 6 + 62 , 9 @ @ object AuthId { < nl > def findIdByUserId ( userId : Int ) = < nl > activeIdByUserIdCompiled ( userId ) . result < nl > < nl > + def findFirstIdByUserId ( userId : Int ) = < nl > + firstActiveIdByUserIdCompiled ( userId ) . result . headOption < nl > + < nl > def findIdByUserIds ( userIds : Set [ Int ] ) = < nl > activeIdByUserIds ( userIds ) . result < nl > < nl > diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > index c55ec26 . . 5ce2887 100644 < nl > - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > @ @ - 113 , 7 + 113 , 7 @ @ object Main extends App { < nl > new EmailSender ( emailConfig ) < nl > ) < nl > case " actor - activation " ⇒ new GateCodeActivation ( gateConfig ) < nl > - case _ ⇒ throw new Exception ( " " " Invalid activation . default - service value provided : valid options : " internal " , actor - activation " " " ) < nl > + case _ ⇒ throw new Exception ( " " " Invalid activation . default - service value provided : valid options : " internal " , actor - activation " " " ) < nl > } < nl > < nl > implicit val sessionRegion = Session . startRegion ( < nl > @ @ - 146 , 10 + 146 , 10 @ @ object Main extends App { < nl > Frontend . start ( serverConfig ) < nl > HttpApiFrontend . start ( serverConfig ) < nl > } catch { < nl > - case e : ConfigException = > < nl > + case e : ConfigException ⇒ < nl > system . log . error ( e , " Failed to load server configuration " ) < nl > throw e < nl > - case e : Throwable = > < nl > + case e : Throwable ⇒ < nl > system . log . error ( e , " Server failed to start up " ) < nl > throw e < nl > } < nl > diff - - git a / actor - server / actor - runtime / src / main / resources / reference . conf b / actor - server / actor - runtime / src / main / resources / reference . conf < nl > index 281b729 . . 1402287 100644 < nl > - - - a / actor - server / actor - runtime / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - runtime / src / main / resources / reference . conf < nl > @ @ - 19 , 6 + 19 , 10 @ @ tls { < nl > } < nl > } < nl > < nl > + common { < nl > + default - timeout : 20 seconds < nl > + } < nl > + < nl > akka { < nl > extensions = $ { akka . extensions } [ < nl > " akka . contrib . pattern . DistributedPubSubExtension " , < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > index badb833 . . 0cef7d5 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > @ @ - 1 , 5 + 1 , 8 @ @ < nl > package im . actor . config < nl > < nl > + import scala . concurrent . duration . _ < nl > + import java . util . concurrent . TimeUnit < nl > + < nl > import com . typesafe . config . { Config , ConfigFactory } < nl > < nl > object ActorConfig { < nl > @ @ - 31 , 4 + 34 , 6 @ @ object ActorConfig { < nl > ) ) < nl > . resolve ( ) < nl > } < nl > + < nl > + val defaultTimeout : FiniteDuration = ActorConfig . load ( ) . getDuration ( " common . default - timeout " , TimeUnit . MILLISECONDS ) . millis < nl > } < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > index 2d4d434 . . 980b06d 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > @ @ - 24 , 8 + 24 , 6 @ @ object SessionStreamMessage { < nl > < nl > @ SerialVersionUID ( 1L ) < nl > case class SendProtoMessage ( message : ProtoMessage with OutgoingProtoMessage ) extends SessionStreamMessage < nl > - < nl > - case class EnqueuedProtoMessage ( message : ProtoMessage , reduceKey : Option [ String ] ) extends SessionStreamMessage < nl > } < nl > < nl > private [ session ] object SessionStream { < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala < nl > index 5656c80 . . fa15f5e 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala < nl > @ @ - 2 , 10 + 2 , 9 @ @ package im . actor . server . session < nl > < nl > import akka . actor . { ActorLogging , Props } < nl > import akka . stream . actor . _ < nl > - import im . actor . server . mtproto . protocol . ProtoMessage < nl > + import im . actor . server . mtproto . protocol . UpdateBox < nl > import im . actor . server . presences . { GroupPresenceManagerRegion , PresenceManagerRegion } < nl > import im . actor . server . sequence . _ < nl > - import im . actor . server . session . SessionStreamMessage . EnqueuedProtoMessage < nl > < nl > import scala . annotation . tailrec < nl > import scala . collection . immutable < nl > @ @ - 26 , 7 + 25 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( < nl > weakUpdManagerRegion : WeakUpdatesManagerRegion , < nl > presenceManagerRegion : PresenceManagerRegion , < nl > groupPresenceManagerRegion : GroupPresenceManagerRegion < nl > - ) extends ActorSubscriber with ActorPublisher [ ( ProtoMessage , Option [ String ] ) ] with ActorLogging { < nl > + ) extends ActorSubscriber with ActorPublisher [ ( UpdateBox , Option [ String ] ) ] with ActorLogging { < nl > < nl > import ActorPublisherMessage . _ < nl > import ActorSubscriberMessage . _ < nl > @ @ - 62 , 7 + 61 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( < nl > override val requestStrategy = WatermarkRequestStrategy ( 10 ) / / TODO : configurable < nl > < nl > / / Publisher - related < nl > - private [ this ] var messageQueue = immutable . Queue . empty [ ( ProtoMessage , Option [ String ] ) ] < nl > + private [ this ] var messageQueue = immutable . Queue . empty [ ( UpdateBox , Option [ String ] ) ] < nl > < nl > def publisher : Receive = { < nl > case NewUpdate ( ub , reduceKey ) ⇒ enqueueProtoMessage ( ub , reduceKey ) < nl > @ @ - 70 , 7 + 69 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( < nl > case Cancel ⇒ context . stop ( self ) < nl > } < nl > < nl > - private def enqueueProtoMessage ( message : ProtoMessage , reduceKey : Option [ String ] ) : Unit = { < nl > + private def enqueueProtoMessage ( message : UpdateBox , reduceKey : Option [ String ] ) : Unit = { < nl > if ( messageQueue . isEmpty & & totalDemand > 0 ) { < nl > onNext ( message → reduceKey ) < nl > } else { < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index 5fb9a44 . . b96b492 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 114 , 6 + 114 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > settings = defaultSettings < nl > ) . dependsOn ( < nl > actorActivation , < nl > + actorBot , < nl > actorEnrich , < nl > actorEmail , < nl > actorFrontend , < nl > @ @ - 133 , 6 + 134 , 24 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > ) < nl > ) . dependsOn ( actorEmail , actorSms , actorPersist ) < nl > < nl > + lazy val actorBot = Project ( < nl > + id = " actor - bot " , < nl > + base = file ( " actor - bot " ) , < nl > + settings = defaultSettings + + < nl > + Seq ( < nl > + libraryDependencies + + = Dependencies . bot < nl > + ) < nl > + ) . dependsOn ( actorBotMessages , shardakka , actorCore ) < nl > + < nl > + lazy val actorBotMessages = Project ( < nl > + id = " actor - bot - messages " , < nl > + base = file ( " actor - bot - messages " ) , < nl > + settings = defaultSettings + + < nl > + Seq ( < nl > + libraryDependencies + + = Dependencies . botMessages < nl > + ) < nl > + ) < nl > + < nl > lazy val actorCore = Project ( < nl > id = " actor - core " , < nl > base = file ( " actor - core " ) , < nl > @ @ - 164 , 7 + 183 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > settings = defaultSettings + + Seq ( < nl > libraryDependencies + + = Dependencies . httpApi < nl > ) < nl > - ) . dependsOn ( actorCore , actorPersist , actorRuntime ) < nl > + ) . dependsOn ( actorBot , actorCore , actorPersist , actorRuntime ) < nl > < nl > lazy val actorOAuth = Project ( < nl > id = " actor - oauth " , < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index ce84317 . . 428af06 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 9 , 7 + 9 , 7 @ @ object Dependencies { < nl > val scalaz = " 7 . 1 . 1 " < nl > val slick = " 3 . 0 . 3 " < nl > val scalatest = " 2 . 2 . 4 " < nl > - val catsVersion = " 0 . 1 . 2 " < nl > + val catsVersion = " 0 . 2 . 0 " < nl > < nl > } < nl > < nl > @ @ - 30 , 8 + 30 , 7 @ @ object Dependencies { < nl > val caffeine = " com . github . ben - manes . caffeine " % " caffeine " % " 1 . 2 . 0 " < nl > val eaioUuid = " com . eaio . uuid " % " uuid " % " 3 . 4 " < nl > < nl > - val cats = " org . spire - math " % % " cats - core " % V . catsVersion < nl > - val catsStd = " org . spire - math " % % " cats - std " % V . catsVersion < nl > + val cats = " org . spire - math " % % " cats " % V . catsVersion < nl > < nl > val configs = " com . github . kxbmap " % % " configs " % " 0 . 2 . 4 " < nl > < nl > @ @ - 39 , 6 + 38 , 7 @ @ object Dependencies { < nl > val javaCompat = " org . scala - lang . modules " % % " scala - java8 - compat " % " 0 . 5 . 0 " < nl > < nl > val playJson = " com . typesafe . play " % % " play - json " % " 2 . 4 . 2 " < nl > + val upickle = " com . lihaoyi " % % " upickle " % " 0 . 3 . 6 " < nl > < nl > val postgresJdbc = " org . postgresql " % " postgresql " % " 9 . 4 - 1201 - jdbc41 " exclude ( " org . slf4j " , " slf4j - simple " ) < nl > val slick = " com . typesafe . slick " % % " slick " % V . slick < nl > @ @ - 102 , 6 + 102 , 10 @ @ object Dependencies { < nl > < nl > val activation = shared + + Seq ( akkaActor , akkaHttp , playJson ) < nl > < nl > + val bot = shared + + Seq ( upickle ) < nl > + < nl > + val botMessages = Seq ( upickle ) < nl > + < nl > val core = shared + + Seq ( akkaActor , akkaContrib , amazonaws , awsWrap , caffeine , gcmServer , pushy , jodaTime , postgresJdbc , slick , scrImageCore ) < nl > < nl > val enrich = shared + + Seq ( akkaActor , akkaHttp ) < nl > @ @ - 146 , 7 + 150 , 7 @ @ object Dependencies { < nl > < nl > val notifications = shared + + Seq ( akkaContrib , slick ) < nl > < nl > - val runtime = shared + + Seq ( akkaActor , akkaHttp , akkaStream , akkaPersistenceJdbc , caffeine , cats , catsStd , concmap , jodaConvert , jodaTime , libPhoneNumber , scalazCore , akkaTestkit % " test " , scalatest % " test " ) < nl > + val runtime = shared + + Seq ( akkaActor , akkaHttp , akkaStream , akkaPersistenceJdbc , caffeine , cats , concmap , jodaConvert , jodaTime , libPhoneNumber , scalazCore , akkaTestkit % " test " , scalatest % " test " ) < nl > < nl > val voximplant = shared + + Seq ( akkaActor , dispatch , playJson )

TEST DIFF:
diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / FilesBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / FilesBotService . scala 
 index 858d2bf . . 0250f0d 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / FilesBotService . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / FilesBotService . scala 
 @ @ - 7 , 7 + 7 , 7 @ @ import im . actor . server . acl . ACLUtils 
 import im . actor . server . bot . { ApiToBotConversions , BotServiceBase } 
 import im . actor . server . db . DbExtension 
 import im . actor . server . file . { FileStorageExtension , UnsafeFileName } 
 - import im . actor . server . persist . FileRepo 
 + import im . actor . server . persist . files . FileRepo 
 
 private [ bot ] object FilesBotErrors { 
 val LocationInvalid = BotError ( 400 , " LOCATION _ INVALID " ) 
 diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json 
 index c3ad553 . . fa26d3b 100644 
 - - - a / actor - server / actor - core / src / main / actor - api / actor . json 
 + + + b / actor - server / actor - core / src / main / actor - api / actor . json 
 @ @ - 11584 , 6 + 11584 , 87 @ @ 
 { 
 " type " : " rpc " , 
 " content " : { 
 + " name " : " GetFileUrlBuilder " , 
 + " header " : 2579 , 
 + " response " : { 
 + " type " : " anonymous " , 
 + " header " : 2580 , 
 + " doc " : [ 
 + { 
 + " type " : " reference " , 
 + " argument " : " baseUrl " , 
 + " category " : " full " , 
 + " description " : " Base Url for files " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " algo " , 
 + " category " : " full " , 
 + " description " : " Signature algorithm " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " signatureSecret " , 
 + " category " : " full " , 
 + " description " : " Signature Secret " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " timeout " , 
 + " category " : " full " , 
 + " description " : " Timeout of url builder " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : " string " , 
 + " id " : 1 , 
 + " name " : " baseUrl " 
 + } , 
 + { 
 + " type " : " string " , 
 + " id " : 2 , 
 + " name " : " algo " 
 + } , 
 + { 
 + " type " : " bytes " , 
 + " id " : 3 , 
 + " name " : " signatureSecret " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " sec " 
 + } , 
 + " id " : 4 , 
 + " name " : " timeout " 
 + } 
 + ] 
 + } , 
 + " doc " : [ 
 + " Get File URL Builder that allows to build file urls from client side " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " supportedSignatureAlgorithms " , 
 + " category " : " hidden " , 
 + " description " : " Supported signature algorithms by client " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : " string " 
 + } , 
 + " id " : 1 , 
 + " name " : " supportedSignatureAlgorithms " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 " name " : " GetFileUploadUrl " , 
 " header " : 97 , 
 " response " : { 
 @ @ - 18034 , 4 + 18115 , 4 @ @ 
 ] 
 } 
 ] 
 - } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala 
 index e0403fd . . 86e2f67 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala 
 @ @ - 3 , 17 + 3 , 17 @ @ package im . actor . server . file 
 import java . io . ByteArrayOutputStream 
 
 import akka . actor . ActorSystem 
 - import com . sksamuel . scrimage . nio . { JpegWriter , ImageWriter , PngWriter } 
 + import com . sksamuel . scrimage . nio . { ImageWriter , JpegWriter , PngWriter } 
 import com . sksamuel . scrimage . { Image , ParImage , Position } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . db . DbExtension 
 import im . actor . server . model . AvatarData 
 - import im . actor . server . persist . FileRepo 
 + import im . actor . server . persist . files . FileRepo 
 import im . actor . util . ThreadLocalSecureRandom 
 import slick . dbio . DBIO 
 
 import scala . concurrent . { ExecutionContext , Future } 
 - import scala . util . { Try , Failure , Success } 
 + import scala . util . { Failure , Success , Try } 
 
 object ImageUtils { 
 val AvatarSizeLimit = 1024L * 1024 / / TODO : configurable 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / http / GroupsHttpHandler . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / http / GroupsHttpHandler . scala 
 index 0f43f1b . . d217925 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / http / GroupsHttpHandler . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / http / GroupsHttpHandler . scala 
 @ @ - 12 , 6 + 12 , 7 @ @ import im . actor . server . file . ImageUtils . getAvatar 
 import im . actor . server . file . { FileLocation , FileStorageExtension } 
 import im . actor . server . model . AvatarData 
 import im . actor . server . persist . _ 
 + import im . actor . server . persist . files . FileRepo 
 import play . api . libs . json . Json 
 import slick . driver . PostgresDriver . api . _ 
 import scala . concurrent . Future 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileStorageExtension . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileStorageExtension . scala 
 index 06adcc1 . . c09b727 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileStorageExtension . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileStorageExtension . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import akka . actor . _ 
 import im . actor . acl . ACLFiles 
 import im . actor . config . ActorConfig 
 import im . actor . serialization . ActorSerializer 
 + import im . actor . server . api . http . HttpApi 
 import im . actor . server . file . local . LocalUploadKey 
 import im . actor . server . file . s3 . S3UploadKey 
 
 @ @ - 31 , 8 + 32 , 12 @ @ class FileStorageExtensionImpl ( system : ActorSystem ) extends FileStorageExtension 
 _ = system . log . debug ( " File adapter is : { } " , fqcn ) 
 clazz ← Try ( Class . forName ( fqcn ) . asSubclass ( classOf [ FileStorageAdapter ] ) ) 
 } yield clazz . getDeclaredConstructor ( classOf [ ActorSystem ] ) . newInstance ( system ) ) match { 
 - case Success ( adapter ) ⇒ adapter 
 - case Failure ( e ) ⇒ throw new RuntimeException ( " Failed to initialize FileStorageAdapter " , e ) 
 + case Success ( adapter ) ⇒ 
 + HttpApi ( system ) . registerHook ( " fileurlbuilder " ) { implicit system ⇒ 
 + new FileUrlBuilderHttpHandler ( adapter ) . routes 
 + } 
 + adapter 
 + case Failure ( e ) ⇒ throw new RuntimeException ( " Failed to initialize FileStorageAdapter " , e ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileUrlBuilderHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileUrlBuilderHttpHandler . scala 
 new file mode 100644 
 index 0000000 . . b56cf76 
 - - - / dev / null 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / FileUrlBuilderHttpHandler . scala 
 @ @ - 0 , 0 + 1 , 87 @ @ 
 + package im . actor . server . file 
 + 
 + import java . time . Instant 
 + 
 + import akka . actor . ActorSystem 
 + import akka . event . Logging 
 + import akka . http . scaladsl . model . StatusCodes 
 + import akka . http . scaladsl . server . Directives . _ 
 + import akka . http . scaladsl . server . _ 
 + import im . actor . acl . ACLFiles 
 + import im . actor . server . api . http . HttpHandler 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . model . { File ⇒ FileModel } 
 + import im . actor . server . persist . files . FileRepo 
 + import im . actor . util . log . AnyRefLogSource 
 + import org . apache . commons . codec . digest . HmacUtils 
 + import scodec . bits . BitVector 
 + 
 + object FileUrlBuilderRejections { 
 + case object SecretExpiredRejection extends Rejection 
 + case object FileNotFoundRejection extends Rejection 
 + case object IncorrectSignatureRejection extends Rejection 
 + } 
 + 
 + private [ file ] final class FileUrlBuilderHttpHandler ( fsAdapter : FileStorageAdapter ) ( implicit system : ActorSystem ) extends HttpHandler with AnyRefLogSource { 
 + import FileUrlBuilderRejections . _ 
 + 
 + private val db = DbExtension ( system ) . db 
 + private val log = Logging ( system , this ) 
 + 
 + private val myRejectionHandler : RejectionHandler = 
 + RejectionHandler . newBuilder ( ) 
 + . handle { 
 + case SecretExpiredRejection ⇒ 
 + complete ( StatusCodes . Gone → " FileUrlBuilder expired ; request new builder ! " ) 
 + } 
 + . handle { 
 + case FileNotFoundRejection ⇒ 
 + complete ( StatusCodes . NotFound → " File not found " ) 
 + } 
 + . handle { 
 + case IncorrectSignatureRejection ⇒ 
 + complete ( StatusCodes . Forbidden → " Incorrect file signature " ) 
 + } 
 + . result ( ) 
 + 
 + / / format : OFF 
 + def routes : Route = 
 + handleRejections ( myRejectionHandler ) { 
 + defaultVersion { 
 + pathPrefix ( " fileUrlBuilder " ) { 
 + parameter ( " fileId " . as [ Long ] ) { fileId = > 
 + get { 
 + validateBuilderRequest ( fileId ) { case ( fileModel , accessHash ) = > 
 + onSuccess ( fsAdapter . getFileDownloadUrl ( fileModel , accessHash ) ) { 
 + case Some ( url ) = > redirect ( url , StatusCodes . Found ) 
 + case None = > complete ( StatusCodes . NotFound - > " File not found " ) 
 + } 
 + } 
 + } 
 + } 
 + } 
 + } 
 + } 
 + / / format : ON 
 + 
 + def validateBuilderRequest ( fileId : Long ) : Directive1 [ ( FileModel , Long ) ] = 
 + parameters ( ( " seed " , " expire " . as [ Long ] , " signature " , " accessHash " . as [ Long ] ) ) tflatMap { 
 + case ( seed , expire , signature , accessHash ) ⇒ 
 + val secret = BitVector . fromLong ( ACLFiles . fileUrlBuilderSecret ( seed , expire ) ) . toByteArray 
 + if ( signature = = HmacUtils . hmacSha256Hex ( secret , s " $ fileId $ accessHash " . getBytes ) ) { 
 + if ( isExpired ( expire ) ) { 
 + reject ( SecretExpiredRejection ) 
 + } else { 
 + onSuccess ( db . run ( FileRepo . find ( fileId ) ) ) flatMap { 
 + case Some ( file ) ⇒ provide ( ( file , accessHash ) ) 
 + case None ⇒ reject ( FileNotFoundRejection ) 
 + } 
 + } 
 + } else { 
 + reject ( IncorrectSignatureRejection ) 
 + } 
 + } 
 + 
 + def isExpired ( expire : Long ) : Boolean = Instant . ofEpochSecond ( expire ) . isAfter ( Instant . now ) 
 + 
 + } 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / FileStorageOperations . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / FileStorageOperations . scala 
 index 80cf1e5 . . d93866a 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / FileStorageOperations . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / FileStorageOperations . scala 
 @ @ - 6 , 11 + 6 , 11 @ @ import akka . actor . ActorSystem 
 import akka . event . Logging 
 import akka . http . scaladsl . util . FastFuture 
 import akka . stream . Materializer 
 - import akka . stream . scaladsl . { Source , FileIO } 
 + import akka . stream . scaladsl . { FileIO , Source } 
 import akka . util . ByteString 
 import better . files . { File , _ } 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . persist . FileRepo 
 + import im . actor . server . persist . files . FileRepo 
 
 import scala . concurrent . { ExecutionContext , Future , blocking } 
 import scala . util . { Failure , Success } 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala 
 index 8e36b83 . . 44208f2 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala 
 @ @ - 6 , 7 + 6 , 7 @ @ import java . time . { Duration , Instant } 
 
 import akka . actor . ActorSystem 
 import akka . http . scaladsl . model . { HttpMethods , Uri } 
 - import akka . stream . { Materializer , ActorMaterializer } 
 + import akka . stream . { ActorMaterializer , Materializer } 
 import better . files . _ 
 import im . actor . acl . ACLFiles 
 import im . actor . server . api . http . { HttpApi , HttpApiConfig } 
 @ @ - 15 , 7 + 15 , 7 @ @ import im . actor . server . db . DbExtension 
 import im . actor . server . file . _ 
 import im . actor . server . model . { File ⇒ FileModel } 
 import im . actor . server . file . local . http . FilesHttpHandler 
 - import im . actor . server . persist . FileRepo 
 + import im . actor . server . persist . files . FileRepo 
 import im . actor . util . ThreadLocalSecureRandom 
 
 import scala . concurrent . { ExecutionContext , Future } 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 index bd6ab46 . . e1edfdc 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 @ @ - 1 , 7 + 1 , 6 @ @ 
 package im . actor . server . file . local . http 
 
 import java . time . { Duration , Instant } 
 - import java . util . concurrent . Executors 
 
 import akka . actor . ActorSystem 
 import akka . event . Logging 
 @ @ - 32 , 12 + 31 , 6 @ @ private [ local ] final class FilesHttpHandler ( storageConfig : LocalFileStorageConfi 
 
 private val log = Logging ( system , this ) 
 
 - val SignedLongNumber : PathMatcher1 [ Long ] = 
 - PathMatcher ( " " " [ + - ] ? \ d + " " " . r ) flatMap { string ⇒ 
 - try Some ( java . lang . Long . parseLong ( string ) ) 
 - catch { case _ : NumberFormatException ⇒ None } 
 - } 
 - 
 / / format : OFF 
 def routes : Route = 
 extractRequest { request = > 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala 
 index b8a8fec . . d1a792e 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala 
 @ @ - 19 , 7 + 19 , 7 @ @ import im . actor . server . db . DbExtension 
 import im . actor . server . file . FileUtils . _ 
 import im . actor . server . file . _ 
 import im . actor . server . model . { File ⇒ FileModel } 
 - import im . actor . server . persist . FileRepo 
 + import im . actor . server . persist . files . FileRepo 
 import im . actor . util . ThreadLocalSecureRandom 
 
 import scala . concurrent . duration . _ 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiHelpers . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiHelpers . scala 
 index 43b9349 . . 907758b 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiHelpers . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiHelpers . scala 
 @ @ - 2 , 7 + 2 , 7 @ @ package im . actor . server . api . http 
 
 import akka . http . scaladsl . model . _ 
 import akka . http . scaladsl . server . Directives . _ 
 - import akka . http . scaladsl . server . Route 
 + import akka . http . scaladsl . server . { PathMatcher , _ } 
 
 object HttpApiHelpers extends HttpApiHelpers 
 
 @ @ - 21 , 4 + 21 , 10 @ @ trait HttpApiHelpers { 
 } 
 } 
 
 + val SignedLongNumber : PathMatcher1 [ Long ] = 
 + PathMatcher ( " " " [ + - ] ? \ d + " " " . r ) flatMap { string ⇒ 
 + try Some ( java . lang . Long . parseLong ( string ) ) 
 + catch { case _ : NumberFormatException ⇒ None } 
 + } 
 + 
 } 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FilePartRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FilePartRepo . scala 
 deleted file mode 100644 
 index 840313e . . 0000000 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FilePartRepo . scala 
 + + + / dev / null 
 @ @ - 1 , 28 + 0 , 0 @ @ 
 - package im . actor . server . persist 
 - 
 - import im . actor . server . model . FilePart 
 - import slick . dbio . Effect . { Read , Write } 
 - import slick . driver . PostgresDriver . api . _ 
 - import slick . profile . { FixedSqlStreamingAction , FixedSqlAction } 
 - 
 - final class FilePartTable ( tag : Tag ) extends Table [ FilePart ] ( tag , " file _ parts " ) { 
 - def fileId = column [ Long ] ( " file _ id " , O . PrimaryKey ) 
 - 
 - def number = column [ Int ] ( " number " , O . PrimaryKey ) 
 - 
 - def size = column [ Int ] ( " size " ) 
 - 
 - def uploadKey = column [ String ] ( " upload _ key " ) 
 - 
 - def * = ( fileId , number , size , uploadKey ) < > ( FilePart . tupled , FilePart . unapply ) 
 - } 
 - 
 - object FilePartRepo { 
 - val parts = TableQuery [ FilePartTable ] 
 - 
 - def createOrUpdate ( fileId : Long , number : Int , size : Int , uploadKey : String ) : FixedSqlAction [ Int , NoStream , Write ] = 
 - parts . insertOrUpdate ( FilePart ( fileId , number , size , uploadKey ) ) 
 - 
 - def findByFileId ( fileId : Long ) : FixedSqlStreamingAction [ Seq [ FilePart ] , FilePart , Read ] = 
 - parts . filter ( _ . fileId = = = fileId ) . sortBy ( _ . number ) . result 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FileRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FileRepo . scala 
 deleted file mode 100644 
 index 161a2de . . 0000000 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / FileRepo . scala 
 + + + / dev / null 
 @ @ - 1 , 41 + 0 , 0 @ @ 
 - package im . actor . server . persist 
 - 
 - import im . actor . server . model . File 
 - import slick . dbio . Effect . { Read , Write } 
 - import slick . driver . PostgresDriver . api . _ 
 - import slick . profile . { SqlAction , FixedSqlAction } 
 - 
 - final class FileTable ( tag : Tag ) extends Table [ File ] ( tag , " files " ) { 
 - def id = column [ Long ] ( " id " , O . PrimaryKey ) 
 - 
 - def accessSalt = column [ String ] ( " access _ salt " ) 
 - 
 - def uploadKey = column [ String ] ( " upload _ key " ) 
 - 
 - def isUploaded = column [ Boolean ] ( " is _ uploaded " ) 
 - 
 - def size = column [ Long ] ( " size " ) 
 - 
 - def name = column [ String ] ( " name " ) 
 - 
 - def * = ( id , accessSalt , uploadKey , isUploaded , size , name ) < > ( File . tupled , File . unapply ) 
 - } 
 - 
 - object FileRepo { 
 - val files = TableQuery [ FileTable ] 
 - 
 - def create ( id : Long , expectedSize : Long , accessSalt : String , uploadKey : String ) : FixedSqlAction [ Int , NoStream , Write ] = 
 - files + = File ( id , accessSalt , uploadKey , isUploaded = false , size = expectedSize , name = " " ) 
 - 
 - def find ( id : Long ) : SqlAction [ Option [ File ] , NoStream , Read ] = 
 - files . filter ( _ . id = = = id ) . result . headOption 
 - 
 - def fetch ( ids : Set [ Long ] ) = 
 - files . filter ( _ . id inSetBind ids ) . result 
 - 
 - def findByKey ( key : String ) = 
 - files . filter ( _ . uploadKey = = = key ) . result . headOption 
 - 
 - def setUploaded ( id : Long , name : String ) = 
 - files . filter ( _ . id = = = id ) . map ( f ⇒ ( f . isUploaded , f . name ) ) . update ( ( true , name ) ) 
 - } 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FilePartRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FilePartRepo . scala 
 new file mode 100644 
 index 0000000 . . 7bf4c7c 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FilePartRepo . scala 
 @ @ - 0 , 0 + 1 , 25 @ @ 
 + package im . actor . server . persist . files 
 + 
 + import im . actor . server . model . FilePart 
 + import slick . dbio . Effect . { Read , Write } 
 + import slick . driver . PostgresDriver . api . _ 
 + import slick . profile . { FixedSqlAction , FixedSqlStreamingAction } 
 + 
 + final class FilePartTable ( tag : Tag ) extends Table [ FilePart ] ( tag , " file _ parts " ) { 
 + def fileId = column [ Long ] ( " file _ id " , O . PrimaryKey ) 
 + def number = column [ Int ] ( " number " , O . PrimaryKey ) 
 + def size = column [ Int ] ( " size " ) 
 + def uploadKey = column [ String ] ( " upload _ key " ) 
 + 
 + def * = ( fileId , number , size , uploadKey ) < > ( FilePart . tupled , FilePart . unapply ) 
 + } 
 + 
 + object FilePartRepo { 
 + val parts = TableQuery [ FilePartTable ] 
 + 
 + def createOrUpdate ( fileId : Long , number : Int , size : Int , uploadKey : String ) : FixedSqlAction [ Int , NoStream , Write ] = 
 + parts . insertOrUpdate ( FilePart ( fileId , number , size , uploadKey ) ) 
 + 
 + def findByFileId ( fileId : Long ) : FixedSqlStreamingAction [ Seq [ FilePart ] , FilePart , Read ] = 
 + parts . filter ( _ . fileId = = = fileId ) . sortBy ( _ . number ) . result 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FileRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FileRepo . scala 
 new file mode 100644 
 index 0000000 . . cce27e8 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / files / FileRepo . scala 
 @ @ - 0 , 0 + 1 , 36 @ @ 
 + package im . actor . server . persist . files 
 + 
 + import im . actor . server . model . File 
 + import slick . dbio . Effect . { Read , Write } 
 + import slick . driver . PostgresDriver . api . _ 
 + import slick . profile . { FixedSqlAction , SqlAction } 
 + 
 + final class FileTable ( tag : Tag ) extends Table [ File ] ( tag , " files " ) { 
 + def id = column [ Long ] ( " id " , O . PrimaryKey ) 
 + def accessSalt = column [ String ] ( " access _ salt " ) 
 + def uploadKey = column [ String ] ( " upload _ key " ) 
 + def isUploaded = column [ Boolean ] ( " is _ uploaded " ) 
 + def size = column [ Long ] ( " size " ) 
 + def name = column [ String ] ( " name " ) 
 + 
 + def * = ( id , accessSalt , uploadKey , isUploaded , size , name ) < > ( File . tupled , File . unapply ) 
 + } 
 + 
 + object FileRepo { 
 + val files = TableQuery [ FileTable ] 
 + 
 + def create ( id : Long , expectedSize : Long , accessSalt : String , uploadKey : String ) : FixedSqlAction [ Int , NoStream , Write ] = 
 + files + = File ( id , accessSalt , uploadKey , isUploaded = false , size = expectedSize , name = " " ) 
 + 
 + def find ( id : Long ) : SqlAction [ Option [ File ] , NoStream , Read ] = 
 + files . filter ( _ . id = = = id ) . result . headOption 
 + 
 + def fetch ( ids : Set [ Long ] ) = 
 + files . filter ( _ . id inSetBind ids ) . result 
 + 
 + def findByKey ( key : String ) = 
 + files . filter ( _ . uploadKey = = = key ) . result . headOption 
 + 
 + def setUploaded ( id : Long , name : String ) = 
 + files . filter ( _ . id = = = id ) . map ( f ⇒ ( f . isUploaded , f . name ) ) . update ( ( true , name ) ) 
 + } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / FileHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / FileHelpers . scala 
 index 069476c . . aedc68d 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / FileHelpers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / FileHelpers . scala 
 @ @ - 2 , 19 + 2 , 18 @ @ package im . actor . api . rpc 
 
 import cats . data . Xor 
 import im . actor . server . acl . ACLUtils 
 - import im . actor . server . persist . FileRepo 
 
 import scala . concurrent . ExecutionContext 
 - 
 import akka . actor . ActorSystem 
 import slick . dbio . DBIO 
 - 
 import im . actor . api . rpc . files . ApiFileLocation 
 + import im . actor . server . persist . files . FileRepo 
 
 object FileRpcErrors { 
 val FileNotFound = RpcError ( 404 , " FILE _ NOT _ FOUND " , " File not found . " , false , None ) 
 val FileTooLarge = RpcError ( 400 , " FILE _ TOO _ LARGE " , " File is too large . " , false , None ) 
 val LocationInvalid = RpcError ( 400 , " LOCATION _ INVALID " , " " , false , None ) 
 + val UnsupportedSignatureAlgorithm = RpcError ( 400 , " SIGNATURE _ ALGO _ NOT _ SUPPORTED " , " " , false , None ) 
 } 
 
 object FileHelpers { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / files / FilesServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / files / FilesServiceImpl . scala 
 index 190b913 . . ebf8668 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / files / FilesServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / files / FilesServiceImpl . scala 
 @ @ - 1 , 17 + 1 , 27 @ @ 
 package im . actor . server . api . rpc . service . files 
 
 + import java . nio . ByteBuffer 
 + import java . time . temporal . ChronoUnit 
 + import java . time . Instant 
 + 
 import akka . actor . _ 
 + import akka . http . scaladsl . model . Uri 
 + import akka . http . scaladsl . util . FastFuture 
 import cats . data . Xor 
 - import im . actor . api . rpc . files . _ 
 + import im . actor . api . rpc . FileRpcErrors . UnsupportedSignatureAlgorithm 
 import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . files . _ 
 import im . actor . concurrent . FutureExt 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . api . http . HttpApiConfig 
 import im . actor . server . db . DbExtension 
 import im . actor . server . file . _ 
 - import im . actor . server . persist . { FilePartRepo , FileRepo } 
 + import im . actor . server . persist . files . { FilePartRepo , FileRepo } 
 + import scodec . bits . BitVector 
 import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . { ExecutionContext , Future } 
 + import scala . concurrent . duration . _ 
 
 class FilesServiceImpl ( implicit actorSystem : ActorSystem ) extends FilesService { 
 
 @ @ - 21 , 6 + 31 , 8 @ @ class FilesServiceImpl ( implicit actorSystem : ActorSystem ) extends FilesService { 
 
 private implicit val db : Database = DbExtension ( actorSystem ) . db 
 private val fsAdapter : FileStorageAdapter = FileStorageExtension ( actorSystem ) . fsAdapter 
 + private val httpConfig = HttpApiConfig . load . get 
 + private val urlBuilderTimeout : Int = 1 . hour . toMillis . toInt 
 
 override def doHandleGetFileUrl ( location : ApiFileLocation , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetFileUrl ] ] = 
 authorized ( clientData ) { client ⇒ 
 @ @ - 78 , 4 + 90 , 25 @ @ class FilesServiceImpl ( implicit actorSystem : ActorSystem ) extends FilesService { 
 _ ← fromFuture ( fsAdapter . completeFileUpload ( file . id , file . size , UnsafeFileName ( fileName ) , partNames ) ) 
 } yield ResponseCommitFileUpload ( ApiFileLocation ( file . id , ACLUtils . fileAccessHash ( file . id , file . accessSalt ) ) ) ) . value 
 } 
 + 
 + protected def doHandleGetFileUrlBuilder ( supportedSignatureAlgorithms : IndexedSeq [ String ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetFileUrlBuilder ] ] = 
 + authorized ( clientData ) { _ ⇒ 
 + val result = if ( supportedSignatureAlgorithms . contains ( " HMAC _ SHA256 " ) ) { 
 + val seed = ACLUtils . randomString ( ) 
 + val expire = Instant . now . plus ( 1 , ChronoUnit . HOURS ) . getEpochSecond 
 + val secret = ACLUtils . fileUrlBuilderSecret ( seed , expire ) 
 + val baseUrl = Uri ( httpConfig . baseUri ) 
 + . withPath ( Uri . Path ( " / v1 / fileUrlBuilder " ) ) 
 + . withQuery ( Uri . Query ( " seed " → seed , " expire " → expire . toString ) ) 
 + Ok ( 
 + ResponseGetFileUrlBuilder ( 
 + baseUrl = baseUrl . toString ( ) , 
 + algo = " HMAC _ SHA256 " , 
 + signatureSecret = BitVector . fromLong ( secret ) . toByteArray , 
 + timeout = urlBuilderTimeout 
 + ) 
 + ) 
 + } else Error ( UnsupportedSignatureAlgorithm ) 
 + FastFuture . successful ( result ) 
 + } 
 } 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala 
 index 88b2093 . . b53ef1f 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala 
 @ @ - 11 , 7 + 11 , 7 @ @ trait ACLBase { 
 
 def getMDInstance ( ) = ThreadLocalMD5 . current ( ) 
 
 - def secretKey ( ) ( implicit s : ActorSystem ) = 
 + def secretKey ( ) ( implicit s : ActorSystem ) : String = 
 s . settings . config . getString ( " secret " ) 
 
 def hash ( s : String , md : MessageDigest = getMDInstance ( ) ) : Long = 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLFiles . scala b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLFiles . scala 
 index 5cc7f2b . . e401799 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLFiles . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLFiles . scala 
 @ @ - 7 , 4 + 7 , 8 @ @ object ACLFiles extends ACLFiles 
 trait ACLFiles extends ACLBase { 
 def fileAccessHash ( fileId : Long , accessSalt : String ) ( implicit s : ActorSystem ) : Long = 
 hash ( s " $ fileId : $ accessSalt : $ { secretKey ( ) } " ) 
 + 
 + def fileUrlBuilderSecret ( seed : String , expire : Long ) ( implicit s : ActorSystem ) : Long = 
 + hash ( s " $ seed : $ expire : $ { secretKey ( ) } " ) 
 + 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala 
 new file mode 100644 
 index 0000000 . . 9b8e44a 
 - - - / dev / null 
 + + + b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala 
 @ @ - 0 , 0 + 1 , 33 @ @ 
 + package im . actor . bot 
 + 
 + import derive . key 
 + 
 + sealed trait BotMessage 
 + 
 + final object BotMessages { 
 + final object OutPeer { 
 + def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) 
 + def group ( id : Int , accessHash : Long ) = OutPeer ( 2 , id , accessHash ) 
 + } 
 + final case class OutPeer ( ` type ` : Int , id : Int , accessHash : Long ) 
 + final case class Peer ( ` type ` : Int , id : Int ) 
 + 
 + sealed trait RequestBody 
 + 
 + final case class BotRequest ( id : Long , body : RequestBody ) extends BotMessage 
 + 
 + @ key ( " SendMessage " ) 
 + final case class SendTextMessage ( peer : OutPeer , randomId : Long , message : String ) extends RequestBody 
 + 
 + sealed trait ResponseBody 
 + 
 + final case class BotResponse ( id : Long , body : ResponseBody ) extends BotMessage 
 + 
 + @ key ( " MessageSent " ) 
 + final case class MessageSent ( date : Long ) extends ResponseBody 
 + 
 + sealed trait BotUpdate extends BotMessage 
 + 
 + @ key ( " TextMessage " ) 
 + final case class TextMessage ( peer : Peer , senderUserId : Int , date : Long , randomId : Long , message : String ) extends BotUpdate 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala 
 new file mode 100644 
 index 0000000 . . f2d446e 
 - - - / dev / null 
 + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala 
 @ @ - 0 , 0 + 1 , 98 @ @ 
 + package im . actor . server . bot 
 + 
 + import akka . actor . { ExtendedActorSystem , ExtensionId , ActorSystem , Extension } 
 + import akka . util . Timeout 
 + import im . actor . api . rpc . users . ApiSex 
 + import im . actor . config . ActorConfig 
 + import im . actor . server . acl . ACLUtils 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . user . UserExtension 
 + import im . actor . server . persist 
 + import im . actor . util . misc . IdUtils 
 + import shardakka . ShardakkaExtension 
 + 
 + import scala . concurrent . Future 
 + 
 + object BotExtension extends ExtensionId [ BotExtension ] { 
 + private [ bot ] val tokensKV = " BotsTokens " 
 + 
 + override def createExtension ( system : ExtendedActorSystem ) : BotExtension = new BotExtensionImpl ( system ) 
 + } 
 + 
 + trait BotExtension extends Extension { 
 + type Token = String 
 + type UserId = Int 
 + type AuthId = Long 
 + 
 + / * * 
 + * Creates a bot user 
 + * 
 + * @ return token future 
 + * / 
 + def create ( name : String ) : Future [ Token ] 
 + 
 + / * * 
 + * Gets userId associated with token 
 + * 
 + * @ param token 
 + * @ return user id 
 + * / 
 + def getUserId ( token : String ) : Future [ Option [ UserId ] ] 
 + 
 + / * * 
 + * Gets or creates bot auth id 
 + * @ param token 
 + * @ return auth id 
 + * / 
 + def getAuthId ( token : String ) : Future [ Option [ AuthId ] ] 
 + } 
 + 
 + private [ bot ] final class BotExtensionImpl ( _ system : ActorSystem ) extends BotExtension { 
 + import _ system . _ 
 + 
 + private implicit val system = _ system 
 + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) 
 + 
 + private lazy val userExt = UserExtension ( system ) 
 + private lazy val tokensKV = ShardakkaExtension ( system ) . simpleKeyValue ( BotExtension . tokensKV ) 
 + private lazy val db = DbExtension ( system ) . db 
 + 
 + override def create ( name : String ) : Future [ Token ] = { 
 + val userId = IdUtils . nextIntId ( ) 
 + val token = ACLUtils . randomHash ( ) 
 + 
 + for { 
 + user ← userExt . create ( 
 + userId = userId , 
 + accessSalt = ACLUtils . nextAccessSalt ( ) , 
 + name = name , 
 + countryCode = " US " , 
 + sex = ApiSex . Unknown , 
 + isBot = true 
 + ) 
 + _ ← tokensKV . upsert ( token , s " $ userId " ) 
 + } yield token 
 + } 
 + 
 + override def getUserId ( token : String ) : Future [ Option [ UserId ] ] = { 
 + for { 
 + tokOpt ← tokensKV . get ( token ) 
 + } yield tokOpt map ( _ . toInt ) 
 + } 
 + 
 + override def getAuthId ( token : String ) : Future [ Option [ AuthId ] ] = { 
 + getUserId ( token ) flatMap { 
 + case Some ( userId ) ⇒ getOrCreateAuthId ( userId ) map ( Some ( _ ) ) 
 + case None ⇒ Future . successful ( None ) 
 + } 
 + } 
 + 
 + private def getOrCreateAuthId ( userId : Int ) : Future [ AuthId ] = { 
 + db . run ( persist . AuthId . findFirstIdByUserId ( userId ) ) flatMap { 
 + case Some ( authId ) ⇒ Future . successful ( authId ) 
 + case None ⇒ 
 + val authId = ACLUtils . randomLong ( ) 
 + db . run ( persist . AuthId . create ( authId , Some ( userId ) , None ) ) map ( _ ⇒ authId ) 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 index ba37e90 . . 734f1f9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 @ @ - 46 , 7 + 46 , 18 @ @ object ACLUtils { 
 def authTransactionHash ( accessSalt : String ) ( implicit s : ActorSystem ) : String = 
 DigestUtils . sha1Hex ( s " $ accessSalt : $ { secretKey ( ) } " ) 
 
 - def nextAccessSalt ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString 
 + def randomHash ( ) ( implicit s : ActorSystem ) : String = 
 + DigestUtils . sha1Hex ( s " $ { randomString ( ) } : $ { secretKey ( ) } " ) 
 + 
 + def randomLong ( ) : Long = randomLong ( ThreadLocalRandom . current ( ) ) 
 + 
 + def randomLong ( rng : ThreadLocalRandom ) : Long = rng . nextLong ( ) 
 + 
 + def randomString ( ) : String = randomString ( ThreadLocalRandom . current ( ) ) 
 + 
 + def randomString ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString 
 + 
 + def nextAccessSalt ( rng : ThreadLocalRandom ) : String = randomString ( rng ) 
 
 def nextAccessSalt ( ) : String = { 
 nextAccessSalt ( ThreadLocalRandom . current ( ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index bd3b59c . . 79e425b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 5 , 6 + 5 , 7 @ @ import akka . pattern . ask 
 import akka . util . Timeout 
 import im . actor . api . rpc . messaging . ApiMessage 
 import im . actor . api . rpc . misc . ApiExtension 
 + import im . actor . api . rpc . peers . ApiPeer 
 import im . actor . api . rpc . peers . ApiPeerType . _ 
 import im . actor . api . rpc . peers . ApiPeerType . ApiPeerType 
 import im . actor . extension . InternalExtensions 
 @ @ - 28 , 7 + 29 , 17 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { 
 
 implicit val s : ActorSystem = system 
 implicit val ec : ExecutionContext = system . dispatcher 
 - implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable 
 + implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable 
 + 
 + def sendMessage ( 
 + peer : ApiPeer , 
 + senderUserId : Int , 
 + senderAuthId : Long , 
 + randomId : Long , 
 + message : ApiMessage , 
 + isFat : Boolean 
 + ) : Future [ SeqStateDate ] = 
 + sendMessage ( peer . ` type ` , peer . id , senderUserId , senderAuthId , randomId , message , isFat ) 
 
 def sendMessage ( peerType : ApiPeerType , peerId : Int , senderUserId : Int , senderAuthId : Long , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = { 
 ( peerType match { 
 @ @ - 83 , 4 + 94 , 4 @ @ object DialogExtension extends ExtensionId [ DialogExtensionImpl ] with ExtensionId 
 override def lookup = DialogExtension 
 
 override def createExtension ( system : ExtendedActorSystem ) = new DialogExtensionImpl ( system ) 
 - } 
 \ No newline at end of file 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 index 9552f85 . . 56fd62a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 @ @ - 8 , 7 + 8 , 7 @ @ import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { Future , Promise } 
 - import scala . util . { Failure , Success , Try } 
 + import scala . util . Try 
 
 sealed trait SeqUpdatesExtension extends Extension { 
 val region : SeqUpdatesManagerRegion 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 index cd328be . . 2a6c005 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 @ @ - 10 , 11 + 10 , 11 @ @ import im . actor . api . rpc . users . ApiUser 
 import im . actor . api . rpc . weak . { UpdateGroupOnline , UpdateUserLastSeen , UpdateUserOffline , UpdateUserOnline } 
 import im . actor . api . rpc . { Update , UpdateBox ⇒ ProtoUpdateBox } 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . group . { GroupExtension , GroupOffice , GroupViewRegion } 
 + import im . actor . server . group . GroupExtension 
 import im . actor . server . mtproto . protocol . UpdateBox 
 import im . actor . server . persist 
 import im . actor . server . presences . _ 
 - import im . actor . server . user . { UserExtension , UserOffice , UserViewRegion } 
 + import im . actor . server . user . UserExtension 
 import org . joda . time . DateTime 
 
 import scala . concurrent . _ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 index b06a574 . . 533795b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 @ @ - 33 , 9 + 33 , 17 @ @ private [ user ] sealed trait Commands extends AuthCommands { 
 
 implicit val timeout : Timeout 
 
 - def create ( userId : Int , accessSalt : String , name : String , countryCode : String , sex : ApiSex . ApiSex , isBot : Boolean , extensions : Seq [ ApiExtension ] , external : Option [ String ] ) : Future [ CreateAck ] = { 
 + def create ( 
 + userId : Int , 
 + accessSalt : String , 
 + name : String , 
 + countryCode : String , 
 + sex : ApiSex . ApiSex , 
 + isBot : Boolean , 
 + extensions : Seq [ ApiExtension ] = Seq . empty , 
 + external : Option [ String ] = None 
 + ) : Future [ CreateAck ] = 
 ( processorRegion . ref ? Create ( userId , accessSalt , name , countryCode , sex , isBot , extensions , external ) ) . mapTo [ CreateAck ] 
 - } 
 
 def addPhone ( userId : Int , phone : Long ) : Future [ Unit ] = { 
 ( processorRegion . ref ? AddPhone ( userId , phone ) ) . mapTo [ AddPhoneAck ] map ( _ ⇒ ( ) ) 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala 
 new file mode 100644 
 index 0000000 . . 940b6dd 
 - - - / dev / null 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala 
 @ @ - 0 , 0 + 1 , 68 @ @ 
 + package im . actor . server . api . http . bots 
 + 
 + import akka . actor . ActorSystem 
 + import akka . stream . scaladsl . { Flow , Merge , Source } 
 + import im . actor . api . rpc . messaging . ApiTextMessage 
 + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . bot . BotMessages 
 + import im . actor . server . dialog . DialogExtension 
 + import im . actor . server . sequence . SeqStateDate 
 + import upickle . default . _ 
 + 
 + import scala . concurrent . Future 
 + 
 + final class BotBlueprint ( botUserId : Int , botAuthId : Long , system : ActorSystem ) { 
 + 
 + import BotMessages . _ 
 + import akka . stream . scaladsl . FlowGraph . Implicits . _ 
 + import system . _ 
 + 
 + private lazy val dialogExt = DialogExtension ( system ) 
 + 
 + val flow : Flow [ String , String , Unit ] = { 
 + val updSource = 
 + Source . actorPublisher [ BotUpdate ] ( UpdatesSource . props ( botAuthId ) ) 
 + . map ( write [ BotUpdate ] ) 
 + 
 + val rqrspFlow = Flow [ String ] 
 + . map ( parseMessage ) 
 + . mapAsync ( 1 ) ( r ⇒ handleRequest ( r . id , r . body ) ) 
 + . map ( write [ BotResponse ] ) 
 + 
 + Flow ( ) { implicit b ⇒ 
 + val upd = b . add ( updSource ) 
 + val rqrsp = b . add ( rqrspFlow ) 
 + val merge = b . add ( Merge [ String ] ( 2 ) ) 
 + 
 + upd ~ > merge 
 + rqrsp ~ > merge 
 + 
 + ( rqrsp . inlet , merge . out ) 
 + } 
 + } 
 + 
 + private def parseMessage ( source : String ) : BotRequest = read [ BotRequest ] ( source ) 
 + 
 + private def handleRequest ( id : Long , body : RequestBody ) : Future [ BotResponse ] = 
 + for { 
 + response ← handleRequestBody ( body ) 
 + } yield BotResponse ( id , response ) 
 + 
 + private def handleRequestBody ( body : RequestBody ) : Future [ ResponseBody ] = body match { 
 + case SendTextMessage ( peer , randomId , message ) ⇒ sendTextMessage ( peer , randomId , message ) 
 + } 
 + 
 + private def sendTextMessage ( peer : OutPeer , randomId : Long , message : String ) : Future [ ResponseBody ] = { 
 + / / FIXME : check access hash 
 + for { 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( 
 + peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , 
 + senderUserId = botUserId , 
 + senderAuthId = 0L , 
 + randomId = randomId , 
 + message = ApiTextMessage ( message , Vector . empty , None ) , 
 + isFat = false 
 + ) 
 + } yield MessageSent ( date ) 
 + } 
 + } 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 new file mode 100644 
 index 0000000 . . efa0994 
 - - - / dev / null 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 @ @ - 0 , 0 + 1 , 46 @ @ 
 + package im . actor . server . api . http . bots 
 + 
 + import akka . actor . ActorSystem 
 + import akka . http . scaladsl . model . ws . { Message , TextMessage } 
 + import akka . http . scaladsl . server . Directives . _ 
 + import akka . http . scaladsl . server . Route 
 + import akka . stream . scaladsl . Flow 
 + import cats . data . OptionT 
 + import cats . std . future . _ 
 + import im . actor . server . api . http . RoutesHandler 
 + import im . actor . server . bot . BotExtension 
 + 
 + import scala . util . control . NoStackTrace 
 + 
 + private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler { 
 + 
 + import system . _ 
 + 
 + private val botExt = BotExtension ( system ) 
 + 
 + override def routes : Route = path ( " bots " / Segment ) { token ⇒ 
 + val flowFuture = ( for { 
 + userId ← OptionT ( botExt . getUserId ( token ) ) 
 + authId ← OptionT ( botExt . getAuthId ( token ) ) 
 + } yield flow ( userId , authId ) ) . value map { 
 + case Some ( r ) ⇒ r 
 + case None ⇒ throw new RuntimeException ( " Wrong token " ) with NoStackTrace 
 + } 
 + 
 + onSuccess ( flowFuture ) { 
 + case flow ⇒ handleWebsocketMessages ( flow ) 
 + } 
 + } 
 + 
 + private def flow ( botUserId : Int , botAuthId : Long ) = { 
 + val bp = new BotBlueprint ( botUserId , botAuthId , system ) 
 + 
 + Flow [ Message ] 
 + . collect { 
 + case TextMessage . Strict ( text ) ⇒ text 
 + case tm : TextMessage ⇒ throw new RuntimeException ( " Streamed text message is not supported " ) with NoStackTrace 
 + } 
 + . via ( bp . flow ) 
 + . map ( TextMessage . Strict ( _ ) . asInstanceOf [ Message ] ) 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala 
 new file mode 100644 
 index 0000000 . . 40f3804 
 - - - / dev / null 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala 
 @ @ - 0 , 0 + 1 , 95 @ @ 
 + package im . actor . server . api . http . bots 
 + 
 + import akka . actor . { ActorLogging , Props } 
 + import akka . stream . actor . ActorPublisher 
 + import im . actor . api . rpc . codecs . _ 
 + import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateMessage } 
 + import im . actor . api . rpc . sequence . SeqUpdate 
 + import im . actor . bot . BotMessages 
 + import im . actor . server . mtproto . protocol . UpdateBox 
 + import im . actor . server . presences . { GroupPresenceManager , PresenceManager } 
 + import im . actor . server . sequence . { UpdatesConsumer , WeakUpdatesManager } 
 + 
 + import scala . annotation . tailrec 
 + 
 + private [ bots ] object UpdatesSource { 
 + def props ( authId : Long ) = Props ( classOf [ UpdatesSource ] , authId ) 
 + } 
 + 
 + private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotMessages . BotUpdate ] with ActorLogging { 
 + 
 + import BotMessages . { Peer , TextMessage } 
 + import akka . stream . actor . ActorPublisherMessage . _ 
 + import context . _ 
 + import im . actor . server . sequence . NewUpdate 
 + 
 + private implicit val weakUpdatesManagerRegion = WeakUpdatesManager . startRegionProxy ( ) 
 + private implicit val presenceManagerRegion = PresenceManager . startRegionProxy ( ) 
 + private implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegionProxy ( ) 
 + 
 + context . actorOf ( UpdatesConsumer . props ( authId , self ) , " updatesConsumer " ) 
 + 
 + private var buf = Vector . empty [ BotMessages . BotUpdate ] 
 + 
 + def receive = { 
 + case NewUpdate ( UpdateBox ( bodyBytes ) , _ ) ⇒ 
 + UpdateBoxCodec . decode ( bodyBytes ) . require . value match { 
 + case SeqUpdate ( _ , _ , header , body ) ⇒ 
 + 
 + header match { 
 + case UpdateMessage . header ⇒ 
 + UpdateMessage . parseFrom ( body ) match { 
 + case Right ( upd ) ⇒ 
 + upd . message match { 
 + case ApiTextMessage ( message , _ , _ ) ⇒ 
 + log . debug ( " Received ApiTextMessage " ) 
 + enqueue ( TextMessage ( 
 + peer = Peer ( upd . peer . ` type ` . id , upd . peer . id ) , 
 + senderUserId = upd . senderUserId , 
 + date = upd . date , 
 + randomId = upd . randomId , 
 + message = message 
 + ) ) 
 + case _ ⇒ 
 + log . debug ( " Received non - text message , ignoring " ) 
 + } 
 + 
 + case Left ( e ) ⇒ 
 + log . error ( e , " Failed to parse UpdateMessage " ) 
 + } 
 + case _ ⇒ 
 + log . debug ( " Received SeqUpdate with header : { } , ignoring " , header ) 
 + } 
 + case _ ⇒ 
 + } 
 + case Request ( _ ) ⇒ 
 + deliverBuf ( ) 
 + case Cancel ⇒ 
 + context . stop ( self ) 
 + } 
 + 
 + private def enqueue ( upd : BotMessages . BotUpdate ) : Unit = { 
 + log . debug ( " Enqueuing { } " , upd ) 
 + 
 + if ( buf . isEmpty & & totalDemand > 0 ) { 
 + onNext ( upd ) 
 + } else { 
 + buf : + = upd 
 + deliverBuf ( ) 
 + } 
 + } 
 + 
 + @ tailrec final def deliverBuf ( ) : Unit = 
 + if ( totalDemand > 0 ) { 
 + if ( totalDemand < = Int . MaxValue ) { 
 + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) 
 + buf = keep 
 + use foreach onNext 
 + } else { 
 + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) 
 + buf = keep 
 + use foreach onNext 
 + deliverBuf ( ) 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala 
 index 8e12f6e . . aa01de9 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala 
 @ @ - 43 , 6 + 43 , 7 @ @ object AuthId { 
 
 val activeByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) ) 
 val activeIdByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) map ( _ . id ) ) 
 + val firstActiveIdByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) map ( _ . id ) take ( 1 ) ) 
 
 def activeIdByUserIds ( userIds : Set [ Int ] ) = activeAuthIds . filter ( _ . userId inSetBind userIds ) . map ( _ . id ) 
 
 @ @ - 61 , 6 + 62 , 9 @ @ object AuthId { 
 def findIdByUserId ( userId : Int ) = 
 activeIdByUserIdCompiled ( userId ) . result 
 
 + def findFirstIdByUserId ( userId : Int ) = 
 + firstActiveIdByUserIdCompiled ( userId ) . result . headOption 
 + 
 def findIdByUserIds ( userIds : Set [ Int ] ) = 
 activeIdByUserIds ( userIds ) . result 
 
 diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 index c55ec26 . . 5ce2887 100644 
 - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 @ @ - 113 , 7 + 113 , 7 @ @ object Main extends App { 
 new EmailSender ( emailConfig ) 
 ) 
 case " actor - activation " ⇒ new GateCodeActivation ( gateConfig ) 
 - case _ ⇒ throw new Exception ( " " " Invalid activation . default - service value provided : valid options : " internal " , actor - activation " " " ) 
 + case _ ⇒ throw new Exception ( " " " Invalid activation . default - service value provided : valid options : " internal " , actor - activation " " " ) 
 } 
 
 implicit val sessionRegion = Session . startRegion ( 
 @ @ - 146 , 10 + 146 , 10 @ @ object Main extends App { 
 Frontend . start ( serverConfig ) 
 HttpApiFrontend . start ( serverConfig ) 
 } catch { 
 - case e : ConfigException = > 
 + case e : ConfigException ⇒ 
 system . log . error ( e , " Failed to load server configuration " ) 
 throw e 
 - case e : Throwable = > 
 + case e : Throwable ⇒ 
 system . log . error ( e , " Server failed to start up " ) 
 throw e 
 } 
 diff - - git a / actor - server / actor - runtime / src / main / resources / reference . conf b / actor - server / actor - runtime / src / main / resources / reference . conf 
 index 281b729 . . 1402287 100644 
 - - - a / actor - server / actor - runtime / src / main / resources / reference . conf 
 + + + b / actor - server / actor - runtime / src / main / resources / reference . conf 
 @ @ - 19 , 6 + 19 , 10 @ @ tls { 
 } 
 } 
 
 + common { 
 + default - timeout : 20 seconds 
 + } 
 + 
 akka { 
 extensions = $ { akka . extensions } [ 
 " akka . contrib . pattern . DistributedPubSubExtension " , 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 index badb833 . . 0cef7d5 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 @ @ - 1 , 5 + 1 , 8 @ @ 
 package im . actor . config 
 
 + import scala . concurrent . duration . _ 
 + import java . util . concurrent . TimeUnit 
 + 
 import com . typesafe . config . { Config , ConfigFactory } 
 
 object ActorConfig { 
 @ @ - 31 , 4 + 34 , 6 @ @ object ActorConfig { 
 ) ) 
 . resolve ( ) 
 } 
 + 
 + val defaultTimeout : FiniteDuration = ActorConfig . load ( ) . getDuration ( " common . default - timeout " , TimeUnit . MILLISECONDS ) . millis 
 } 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 index 2d4d434 . . 980b06d 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 @ @ - 24 , 8 + 24 , 6 @ @ object SessionStreamMessage { 
 
 @ SerialVersionUID ( 1L ) 
 case class SendProtoMessage ( message : ProtoMessage with OutgoingProtoMessage ) extends SessionStreamMessage 
 - 
 - case class EnqueuedProtoMessage ( message : ProtoMessage , reduceKey : Option [ String ] ) extends SessionStreamMessage 
 } 
 
 private [ session ] object SessionStream { 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala 
 index 5656c80 . . fa15f5e 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala 
 @ @ - 2 , 10 + 2 , 9 @ @ package im . actor . server . session 
 
 import akka . actor . { ActorLogging , Props } 
 import akka . stream . actor . _ 
 - import im . actor . server . mtproto . protocol . ProtoMessage 
 + import im . actor . server . mtproto . protocol . UpdateBox 
 import im . actor . server . presences . { GroupPresenceManagerRegion , PresenceManagerRegion } 
 import im . actor . server . sequence . _ 
 - import im . actor . server . session . SessionStreamMessage . EnqueuedProtoMessage 
 
 import scala . annotation . tailrec 
 import scala . collection . immutable 
 @ @ - 26 , 7 + 25 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( 
 weakUpdManagerRegion : WeakUpdatesManagerRegion , 
 presenceManagerRegion : PresenceManagerRegion , 
 groupPresenceManagerRegion : GroupPresenceManagerRegion 
 - ) extends ActorSubscriber with ActorPublisher [ ( ProtoMessage , Option [ String ] ) ] with ActorLogging { 
 + ) extends ActorSubscriber with ActorPublisher [ ( UpdateBox , Option [ String ] ) ] with ActorLogging { 
 
 import ActorPublisherMessage . _ 
 import ActorSubscriberMessage . _ 
 @ @ - 62 , 7 + 61 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( 
 override val requestStrategy = WatermarkRequestStrategy ( 10 ) / / TODO : configurable 
 
 / / Publisher - related 
 - private [ this ] var messageQueue = immutable . Queue . empty [ ( ProtoMessage , Option [ String ] ) ] 
 + private [ this ] var messageQueue = immutable . Queue . empty [ ( UpdateBox , Option [ String ] ) ] 
 
 def publisher : Receive = { 
 case NewUpdate ( ub , reduceKey ) ⇒ enqueueProtoMessage ( ub , reduceKey ) 
 @ @ - 70 , 7 + 69 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( 
 case Cancel ⇒ context . stop ( self ) 
 } 
 
 - private def enqueueProtoMessage ( message : ProtoMessage , reduceKey : Option [ String ] ) : Unit = { 
 + private def enqueueProtoMessage ( message : UpdateBox , reduceKey : Option [ String ] ) : Unit = { 
 if ( messageQueue . isEmpty & & totalDemand > 0 ) { 
 onNext ( message → reduceKey ) 
 } else { 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index 5fb9a44 . . b96b492 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 114 , 6 + 114 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 settings = defaultSettings 
 ) . dependsOn ( 
 actorActivation , 
 + actorBot , 
 actorEnrich , 
 actorEmail , 
 actorFrontend , 
 @ @ - 133 , 6 + 134 , 24 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 ) 
 ) . dependsOn ( actorEmail , actorSms , actorPersist ) 
 
 + lazy val actorBot = Project ( 
 + id = " actor - bot " , 
 + base = file ( " actor - bot " ) , 
 + settings = defaultSettings + + 
 + Seq ( 
 + libraryDependencies + + = Dependencies . bot 
 + ) 
 + ) . dependsOn ( actorBotMessages , shardakka , actorCore ) 
 + 
 + lazy val actorBotMessages = Project ( 
 + id = " actor - bot - messages " , 
 + base = file ( " actor - bot - messages " ) , 
 + settings = defaultSettings + + 
 + Seq ( 
 + libraryDependencies + + = Dependencies . botMessages 
 + ) 
 + ) 
 + 
 lazy val actorCore = Project ( 
 id = " actor - core " , 
 base = file ( " actor - core " ) , 
 @ @ - 164 , 7 + 183 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 settings = defaultSettings + + Seq ( 
 libraryDependencies + + = Dependencies . httpApi 
 ) 
 - ) . dependsOn ( actorCore , actorPersist , actorRuntime ) 
 + ) . dependsOn ( actorBot , actorCore , actorPersist , actorRuntime ) 
 
 lazy val actorOAuth = Project ( 
 id = " actor - oauth " , 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index ce84317 . . 428af06 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 9 , 7 + 9 , 7 @ @ object Dependencies { 
 val scalaz = " 7 . 1 . 1 " 
 val slick = " 3 . 0 . 3 " 
 val scalatest = " 2 . 2 . 4 " 
 - val catsVersion = " 0 . 1 . 2 " 
 + val catsVersion = " 0 . 2 . 0 " 
 
 } 
 
 @ @ - 30 , 8 + 30 , 7 @ @ object Dependencies { 
 val caffeine = " com . github . ben - manes . caffeine " % " caffeine " % " 1 . 2 . 0 " 
 val eaioUuid = " com . eaio . uuid " % " uuid " % " 3 . 4 " 
 
 - val cats = " org . spire - math " % % " cats - core " % V . catsVersion 
 - val catsStd = " org . spire - math " % % " cats - std " % V . catsVersion 
 + val cats = " org . spire - math " % % " cats " % V . catsVersion 
 
 val configs = " com . github . kxbmap " % % " configs " % " 0 . 2 . 4 " 
 
 @ @ - 39 , 6 + 38 , 7 @ @ object Dependencies { 
 val javaCompat = " org . scala - lang . modules " % % " scala - java8 - compat " % " 0 . 5 . 0 " 
 
 val playJson = " com . typesafe . play " % % " play - json " % " 2 . 4 . 2 " 
 + val upickle = " com . lihaoyi " % % " upickle " % " 0 . 3 . 6 " 
 
 val postgresJdbc = " org . postgresql " % " postgresql " % " 9 . 4 - 1201 - jdbc41 " exclude ( " org . slf4j " , " slf4j - simple " ) 
 val slick = " com . typesafe . slick " % % " slick " % V . slick 
 @ @ - 102 , 6 + 102 , 10 @ @ object Dependencies { 
 
 val activation = shared + + Seq ( akkaActor , akkaHttp , playJson ) 
 
 + val bot = shared + + Seq ( upickle ) 
 + 
 + val botMessages = Seq ( upickle ) 
 + 
 val core = shared + + Seq ( akkaActor , akkaContrib , amazonaws , awsWrap , caffeine , gcmServer , pushy , jodaTime , postgresJdbc , slick , scrImageCore ) 
 
 val enrich = shared + + Seq ( akkaActor , akkaHttp ) 
 @ @ - 146 , 7 + 150 , 7 @ @ object Dependencies { 
 
 val notifications = shared + + Seq ( akkaContrib , slick ) 
 
 - val runtime = shared + + Seq ( akkaActor , akkaHttp , akkaStream , akkaPersistenceJdbc , caffeine , cats , catsStd , concmap , jodaConvert , jodaTime , libPhoneNumber , scalazCore , akkaTestkit % " test " , scalatest % " test " ) 
 + val runtime = shared + + Seq ( akkaActor , akkaHttp , akkaStream , akkaPersistenceJdbc , caffeine , cats , concmap , jodaConvert , jodaTime , libPhoneNumber , scalazCore , akkaTestkit % " test " , scalatest % " test " ) 
 
 val voximplant = shared + + Seq ( akkaActor , dispatch , playJson )
