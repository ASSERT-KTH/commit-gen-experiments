BLEU SCORE: 0.08295193507109855

TEST MSG: feat ( core ) : Non - actor based chain encryption
GENERATED MSG: wip ( sdk ) : Grouped active dialogs list

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index faeabe9 . . e08862e 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 6 , 46 + 6 , 54 @ @ import im . actor . core . modules . ModuleContext ; < nl > import im . actor . core . modules . encryption . entity . OwnPrivateKey ; < nl > import im . actor . core . modules . encryption . entity . UserKeysGroup ; < nl > import im . actor . core . modules . encryption . entity . UserPublicKey ; < nl > - import im . actor . core . util . Hex ; < nl > + import im . actor . core . modules . encryption . session . EncryptedSession ; < nl > + import im . actor . core . modules . encryption . session . EncryptedSessionChain ; < nl > import im . actor . core . util . ModuleActor ; < nl > + import im . actor . core . util . RandomUtils ; < nl > import im . actor . runtime . * ; < nl > + import im . actor . runtime . actors . ActorCreator ; < nl > + import im . actor . runtime . actors . ActorRef ; < nl > import im . actor . runtime . actors . Future ; < nl > + import im . actor . runtime . actors . Props ; < nl > import im . actor . runtime . actors . ask . AskCallback ; < nl > + import im . actor . runtime . crypto . Curve25519 ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > - import im . actor . runtime . crypto . box . ActorBox ; < nl > - import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; < nl > import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; < nl > import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; < nl > < nl > public class EncryptedSessionActor extends ModuleActor { < nl > < nl > private final String TAG ; < nl > < nl > - private final int uid ; < nl > + / / < nl > + / / Key References < nl > + / / < nl > < nl > private final long ownKey0 ; < nl > + private final int uid ; < nl > private final long theirKey0 ; < nl > private final int theirKeyGroup ; < nl > < nl > + / / < nl > + / / Loaded Keys < nl > + / / < nl > + < nl > private OwnPrivateKey ownIdentityKey ; < nl > private OwnPrivateKey ownPreKey ; < nl > private UserPublicKey theirIdentityKey ; < nl > private UserPublicKey theirPreKey ; < nl > + private EncryptedSession session ; < nl > + / / True if it is unable to load key < nl > + private boolean isUnavailable = false ; < nl > < nl > - private byte [ ] masterKey ; < nl > - < nl > - private byte [ ] prevOwnKey ; < nl > - private OwnPrivateKey currentOwnKey ; < nl > - private UserPublicKey currentTheirKey ; < nl > - < nl > - private int outIndex = 0 ; < nl > - private int inIndex = 0 ; < nl > + / / < nl > + / / Temp encryption chains < nl > + / / < nl > < nl > - private boolean isUnavailable = false ; < nl > + private byte [ ] theirEphemeralKey ; < nl > + private ArrayList < EncryptedSessionChain > chains = new ArrayList < EncryptedSessionChain > ( ) ; < nl > < nl > public EncryptedSessionActor ( ModuleContext context , int uid , long ownKey0 , long theirKey0 , < nl > int theirKeyGroup ) { < nl > @ @ - 148 , 14 + 156 , 41 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > } < nl > < nl > private void loadMasterKey ( ) { < nl > - masterKey = RatchetMasterSecret . calculateMasterSecret ( < nl > - new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > - new RatchetPrivateKey ( ownPreKey . getKey ( ) ) , < nl > - new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > - new RatchetPublicKey ( theirPreKey . getPublicKey ( ) ) ) ; < nl > + session = new EncryptedSession ( ownIdentityKey , ownPreKey , < nl > + theirIdentityKey , theirPreKey , theirKeyGroup ) ; < nl > } < nl > < nl > private void onEncrypt ( final byte [ ] data , final Future future ) { < nl > + if ( isUnavailable ) { < nl > + future . onError ( new RuntimeException ( " Encryption session is unavailable " ) ) ; < nl > + return ; < nl > + } < nl > + < nl > + / / if ( theirEphemeralKey = = null ) { < nl > + / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKeyRandom ( uid , theirKeyGroup ) , new AskCallback ( ) { < nl > + / / @ Override < nl > + / / public void onResult ( Object obj ) { < nl > + / / if ( theirEphemeralKey ! = null ) { < nl > + / / KeyManagerActor . FetchUserEphemeralKeyResponse response = ( KeyManagerActor . FetchUserEphemeralKeyResponse ) obj ; < nl > + / / theirEphemeralKey = response . getEphemeralKey ( ) . getPublicKey ( ) ; < nl > + / / } < nl > + / / onEncrypt ( data , future ) ; < nl > + / / } < nl > + / / < nl > + / / @ Override < nl > + / / public void onError ( Exception e ) { < nl > + / / future . onError ( e ) ; < nl > + / / } < nl > + / / } ) ; < nl > + / / return ; < nl > + / / } < nl > + / / < nl > + / / if ( chains . size ( ) = = 0 ) { < nl > + / / spawnChain ( Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 32 ) ) ) ; < nl > + / / } < nl > + / / < nl > + / / chains . get ( 0 ) . getChain ( ) . send ( new EncryptedSessionChainActor . EncryptMessage ( data , < nl > + / / theirEphemeralKey , 0 ) ) ; < nl > < nl > / / if ( ! assumeEnabled ( new Runnable ( ) { < nl > / / @ Override < nl > @ @ - 233 , 217 + 268 , 75 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > } < nl > < nl > private void onDecrypt ( final byte [ ] data , final Future future ) { < nl > + if ( isUnavailable ) { < nl > + future . onError ( new RuntimeException ( " Encryption session is unavailable " ) ) ; < nl > + return ; < nl > + } < nl > < nl > - final long start = im . actor . runtime . Runtime . getActorTime ( ) ; < nl > - < nl > - Log . d ( TAG , " onDecrypt " ) ; < nl > - Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > - < nl > - final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > - final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > - final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > - final byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > - final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > + / / final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > + / / final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > + / / final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > + final byte [ ] senderEphemeralKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > + final byte [ ] receiverEphemeralKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > < nl > - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( theirEphermalKey ) , new AskCallback ( ) { < nl > - @ Override < nl > - public void onResult ( Object obj ) { < nl > - final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; < nl > - Log . d ( TAG , " Before plain text in " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; < nl > - < nl > - byte [ ] rc = RatchetRootChainKey . makeRootChainKey ( < nl > - new RatchetPrivateKey ( theirEphermalKey . getPrivateKey ( ) ) , < nl > - new RatchetPublicKey ( ownEphermalKey ) , < nl > - masterKey ) ; < nl > - < nl > - Log . d ( TAG , " Before plain text 2 in " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; < nl > - < nl > - ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , messageIndex ) ; < nl > + EncryptedSessionChain pickedChain = null ; < nl > + for ( EncryptedSessionChain c : chains ) { < nl > + if ( ByteStrings . isEquals ( Curve25519 . keyGenPublic ( c . getOwnPrivateKey ( ) ) , receiverEphemeralKey ) ) { < nl > + pickedChain = c ; < nl > + break ; < nl > + } < nl > + } < nl > < nl > - Log . d ( TAG , " Before plain text 3 in " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; < nl > + if ( pickedChain = = null ) { < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( receiverEphemeralKey ) , new AskCallback ( ) { < nl > < nl > - byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; < nl > - byte [ ] pkg = ByteStrings . substring ( data , 88 , data . length - 88 ) ; < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; < nl > + spawnChain ( theirEphermalKey . getPrivateKey ( ) , senderEphemeralKey ) ; < nl > + onDecrypt ( data , future ) ; < nl > + } < nl > < nl > - byte [ ] plainText ; < nl > - try { < nl > - plainText = ActorBox . openBox ( header , pkg , ratchetMessageKey ) ; < nl > - Log . d ( TAG , " Plain Text in " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; < nl > - } catch ( IntegrityException e ) { < nl > - Log . d ( TAG , " Plain Text error " ) ; < nl > - e . printStackTrace ( ) ; < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > future . onError ( e ) ; < nl > - return ; < nl > } < nl > + } ) ; < nl > + return ; < nl > + } < nl > < nl > - future . onResult ( new DecryptedPackage ( plainText ) ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void onError ( Exception e ) { < nl > - Log . d ( TAG , " onDecrypt : onResultEphermal : onError " ) ; < nl > - future . onError ( e ) ; < nl > - } < nl > - } ) ; < nl > - < nl > - < nl > - / / ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , index ) ; < nl > - / / < nl > - / / Log . d ( TAG , " MS : " + Hex . toHex ( ms ) ) ; < nl > - / / Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; < nl > - / / Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey0 ) ) ) ; < nl > - / / Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; < nl > - / / Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphemeralKey0 ) ) ; < nl > - / / < nl > - / / Log . d ( TAG , " RC : " + Hex . toHex ( rc ) ) ; < nl > - / / Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey ) ) ) ; < nl > - / / Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphemeralKey ) ) ; < nl > - / / < nl > - / / Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; < nl > - / / Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; < nl > - / / Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; < nl > - / / Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; < nl > - / / < nl > - / / byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; < nl > - / / byte [ ] pkg = ByteStrings . substring ( data , 88 , data . length - 88 ) ; < nl > - / / < nl > - / / byte [ ] plainText ; < nl > - / / try { < nl > - / / plainText = ActorBox . openBox ( header , pkg , ratchetMessageKey ) ; < nl > - / / Log . d ( TAG , " Plain Text " ) ; < nl > - / / } catch ( IntegrityException e ) { < nl > - / / Log . d ( TAG , " Plain Text error " ) ; < nl > - / / e . printStackTrace ( ) ; < nl > - / / future . onError ( e ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / future . onResult ( new DecryptedPackage ( plainText ) ) ; < nl > - < nl > + try { < nl > + future . onResult ( new DecryptedPackage ( pickedChain . decrypt ( data ) ) ) ; < nl > + } catch ( IntegrityException e ) { < nl > + e . printStackTrace ( ) ; < nl > + future . onError ( e ) ; < nl > + } < nl > < nl > - / / < nl > - / / / / Log . d ( TAG , " onDecrypt : Own " + Hex . toHex ( ownEphermalKey ) ) ; < nl > - / / / / Log . d ( TAG , " onDecrypt : Their " + Hex . toHex ( theirEphermalKey ) ) ; < nl > - / / < nl > - / / Log . d ( TAG , " ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > - / / Log . d ( TAG , " theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > - / / < nl > - / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( theirEphermalKey ) , new AskCallback ( ) { < nl > + / / ask ( pickedChain . getChain ( ) , new EncryptedSessionChainActor . DecryptMessage ( < nl > + / / ByteStrings . substring ( data , 0 , 88 ) , < nl > + / / ByteStrings . substring ( data , 88 , data . length - 88 ) , < nl > + / / senderEphemeralKey , messageIndex ) , new AskCallback ( ) { < nl > / / @ Override < nl > / / public void onResult ( Object obj ) { < nl > - / / final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; < nl > - / / < nl > - / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKeyById ( theirEphermalKey0Id ) , < nl > - / / new AskCallback ( ) { < nl > - / / @ Override < nl > - / / public void onResult ( Object obj ) { < nl > - / / < nl > - / / final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey0 < nl > - / / = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; < nl > - / / < nl > - / / Log . d ( TAG , " theirEphermalKey0 : " + Hex . toHex ( Curve25519 . keyGenPublic ( theirEphermalKey0 . getPrivateKey ( ) ) ) ) ; < nl > - / / < nl > - / / ArrayList < Long > keys = new ArrayList < Long > ( ) ; < nl > - / / keys . add ( ownEphermalKey0Id ) ; < nl > - / / request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > - / / @ Override < nl > - / / public void onResult ( ResponsePublicKeys response ) { < nl > - / / byte [ ] ownEphermalKey0 = response . getPublicKey ( ) . get ( 0 ) . getKeyMaterial ( ) ; < nl > - / / Log . d ( TAG , " ownEphermalKey0 : " + Hex . toHex ( ownEphermalKey0 ) ) ; < nl > - / / onDecrypt ( data , < nl > - / / ownEphermalKey0 , < nl > - / / ownEphermalKey , < nl > - / / theirEphermalKey0 . getPrivateKey ( ) , < nl > - / / theirEphermalKey . getPrivateKey ( ) , < nl > - / / messageIndex , < nl > - / / future ) ; < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( RpcException e ) { < nl > - / / Log . d ( TAG , " onDecrypt : RequestLoadPublicKey : onError " ) ; < nl > - / / future . onError ( e ) ; < nl > - / / } < nl > - / / } ) ; < nl > - / / < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( Exception e ) { < nl > - / / Log . d ( TAG , " onDecrypt : onResultPrivate : onError " ) ; < nl > - / / future . onError ( e ) ; < nl > - / / } < nl > - / / } ) ; < nl > + / / / / Updating ephemeral key < nl > + / / theirEphemeralKey = senderEphemeralKey ; < nl > + / / future . onResult ( ) ; < nl > / / } < nl > / / < nl > / / @ Override < nl > / / public void onError ( Exception e ) { < nl > - / / Log . d ( TAG , " onDecrypt : onResultEphermal : onError " ) ; < nl > / / future . onError ( e ) ; < nl > / / } < nl > / / } ) ; < nl > - < nl > - / / future . onResult ( ) ; < nl > } < nl > < nl > - private void onDecrypt ( byte [ ] data , < nl > - byte [ ] theirEphemeralKey0 , < nl > - byte [ ] theirEphemeralKey , < nl > - byte [ ] ownEphemeralPrivateKey0 , < nl > - byte [ ] ownEphemeralPrivateKey , < nl > - int index , < nl > - Future future ) { < nl > - < nl > - Log . d ( TAG , " onDecrypt2 " ) ; < nl > - < nl > - / / byte [ ] ms = RatchetMasterSecret . calculateMasterSecret ( < nl > - / / new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > - / / new RatchetPrivateKey ( ownEphemeralPrivateKey0 ) , < nl > - / / new RatchetPublicKey ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) , < nl > - / / new RatchetPublicKey ( theirEphemeralKey0 ) ) ; < nl > - / / < nl > - / / byte [ ] rc = RatchetRootChainKey . makeRootChainKey ( < nl > - / / new RatchetPrivateKey ( ownEphemeralPrivateKey ) , < nl > - / / new RatchetPublicKey ( theirEphemeralKey ) , < nl > - / / ms ) ; < nl > - / / < nl > - / / ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , index ) ; < nl > - / / < nl > - / / Log . d ( TAG , " MS : " + Hex . toHex ( ms ) ) ; < nl > - / / Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; < nl > - / / Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey0 ) ) ) ; < nl > - / / Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; < nl > - / / Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphemeralKey0 ) ) ; < nl > - / / < nl > - / / Log . d ( TAG , " RC : " + Hex . toHex ( rc ) ) ; < nl > - / / Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey ) ) ) ; < nl > - / / Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphemeralKey ) ) ; < nl > - / / < nl > - / / Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; < nl > - / / Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; < nl > - / / Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; < nl > - / / Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; < nl > - / / < nl > - / / byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; < nl > - / / byte [ ] pkg = ByteStrings . substring ( data , 88 , data . length - 88 ) ; < nl > - / / < nl > - / / byte [ ] plainText ; < nl > - / / try { < nl > - / / plainText = ActorBox . openBox ( header , pkg , ratchetMessageKey ) ; < nl > - / / Log . d ( TAG , " Plain Text " ) ; < nl > - / / } catch ( IntegrityException e ) { < nl > - / / Log . d ( TAG , " Plain Text error " ) ; < nl > - / / e . printStackTrace ( ) ; < nl > - / / future . onError ( e ) ; < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / future . onResult ( new DecryptedPackage ( plainText ) ) ; < nl > + private EncryptedSessionChain spawnChain ( final byte [ ] privateKey , final byte [ ] publicKey ) { < nl > + EncryptedSessionChain chain = new EncryptedSessionChain ( session , privateKey , publicKey ) ; < nl > + chains . add ( 0 , chain ) ; < nl > + return chain ; < nl > } < nl > < nl > - < nl > - < nl > @ Override < nl > public boolean onAsk ( Object message , Future future ) { < nl > Log . d ( TAG , " onAsk " ) ; < nl > @ @ - 509 , 4 + 402 , 5 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > return data ; < nl > } < nl > } < nl > + < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionChainActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionChainActor . java < nl > deleted file mode 100644 < nl > index ba382ab . . 0000000 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionChainActor . java < nl > + + + / dev / null < nl > @ @ - 1 , 95 + 0 , 0 @ @ < nl > - package im . actor . core . modules . encryption ; < nl > - < nl > - import im . actor . core . modules . ModuleContext ; < nl > - import im . actor . core . modules . encryption . entity . OwnPrivateKey ; < nl > - import im . actor . core . util . ModuleActor ; < nl > - import im . actor . runtime . Log ; < nl > - import im . actor . runtime . actors . Future ; < nl > - import im . actor . runtime . crypto . IntegrityException ; < nl > - import im . actor . runtime . crypto . box . ActorBox ; < nl > - import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; < nl > - < nl > - public class EncryptedSessionChainActor extends ModuleActor { < nl > - < nl > - private static final String TAG = " EncryptedSessionChainActor " ; < nl > - < nl > - private byte [ ] masterKey ; < nl > - private OwnPrivateKey chainOwnPrivateKey ; < nl > - < nl > - public EncryptedSessionChainActor ( byte [ ] masterKey , < nl > - OwnPrivateKey chainOwnPrivateKey , < nl > - ModuleContext context ) { < nl > - super ( context ) ; < nl > - < nl > - this . masterKey = masterKey ; < nl > - this . chainOwnPrivateKey = chainOwnPrivateKey ; < nl > - } < nl > - < nl > - private void onDecrypt ( byte [ ] header , byte [ ] cipherText , byte [ ] senderPublicKey , int messageIndex , < nl > - Future future ) { < nl > - < nl > - byte [ ] rc = RatchetRootChainKey . makeRootChainKey ( < nl > - new RatchetPrivateKey ( chainOwnPrivateKey . getKey ( ) ) , < nl > - new RatchetPublicKey ( senderPublicKey ) , < nl > - masterKey ) ; < nl > - < nl > - ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , messageIndex ) ; < nl > - < nl > - byte [ ] plainText ; < nl > - try { < nl > - plainText = ActorBox . openBox ( header , cipherText , ratchetMessageKey ) ; < nl > - Log . d ( TAG , " Plain Text " ) ; < nl > - } catch ( IntegrityException e ) { < nl > - Log . d ( TAG , " Plain Text error " ) ; < nl > - e . printStackTrace ( ) ; < nl > - future . onError ( e ) ; < nl > - return ; < nl > - } < nl > - } < nl > - < nl > - @ Override < nl > - public boolean onAsk ( Object message , Future future ) { < nl > - if ( message instanceof DecryptMessage ) { < nl > - DecryptMessage decryptMessage = ( DecryptMessage ) message ; < nl > - onDecrypt ( decryptMessage . getHeader ( ) , decryptMessage . getCipherText ( ) , < nl > - decryptMessage . getSenderPublicKey ( ) , decryptMessage . getMessageIndex ( ) , future ) ; < nl > - return false ; < nl > - } < nl > - return super . onAsk ( message , future ) ; < nl > - } < nl > - < nl > - public static class DecryptMessage { < nl > - < nl > - private byte [ ] header ; < nl > - private byte [ ] cipherText ; < nl > - private byte [ ] senderPublicKey ; < nl > - private int messageIndex ; < nl > - < nl > - public DecryptMessage ( byte [ ] header , byte [ ] cipherText , byte [ ] senderPublicKey , int messageIndex ) { < nl > - this . header = header ; < nl > - this . cipherText = cipherText ; < nl > - this . senderPublicKey = senderPublicKey ; < nl > - this . messageIndex = messageIndex ; < nl > - } < nl > - < nl > - public byte [ ] getHeader ( ) { < nl > - return header ; < nl > - } < nl > - < nl > - public byte [ ] getCipherText ( ) { < nl > - return cipherText ; < nl > - } < nl > - < nl > - public byte [ ] getSenderPublicKey ( ) { < nl > - return senderPublicKey ; < nl > - } < nl > - < nl > - public int getMessageIndex ( ) { < nl > - return messageIndex ; < nl > - } < nl > - } < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java < nl > new file mode 100644 < nl > index 0000000 . . abc6f07 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java < nl > @ @ - 0 , 0 + 1 , 26 @ @ < nl > + package im . actor . core . modules . encryption ; < nl > + < nl > + public class KeyLocation { < nl > + < nl > + private int uid ; < nl > + private int keyGroup ; < nl > + private long keyId ; < nl > + < nl > + public KeyLocation ( int uid , int keyGroup , long keyId ) { < nl > + this . uid = uid ; < nl > + this . keyGroup = keyGroup ; < nl > + this . keyId = keyId ; < nl > + } < nl > + < nl > + public int getUid ( ) { < nl > + return uid ; < nl > + } < nl > + < nl > + public int getKeyGroup ( ) { < nl > + return keyGroup ; < nl > + } < nl > + < nl > + public long getKeyId ( ) { < nl > + return keyId ; < nl > + } < nl > + } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index 3fcd062 . . 9eb0796 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 375 , 6 + 375 , 36 @ @ public class KeyManagerActor extends ModuleActor { < nl > / / } ) ; < nl > } < nl > < nl > + private void fetchUserEphemeralKey ( final int uid , int keyGroupId , final Future future ) { < nl > + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , keyGroupId ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + @ Override < nl > + public void onResult ( ResponsePublicKeys response ) { < nl > + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > + Log . w ( TAG , " Public key error " ) ; < nl > + future . onError ( new RuntimeException ( ) ) ; < nl > + return ; < nl > + } < nl > + ApiEncryptionKey key = response . getPublicKey ( ) . get ( 0 ) ; < nl > + < nl > + / / TODO : Verify signature < nl > + < nl > + UserPublicKey pkey = new UserPublicKey ( key . getKeyId ( ) , key . getKeyAlg ( ) , key . getKeyMaterial ( ) ) ; < nl > + / / UserKeysGroup userKeysGroup = finalKeysGroup . addUserKeyGroup ( pkey ) ; < nl > + / / cacheUserKeys ( keys . removeUserKeyGroup ( userKeysGroup . getKeyGroupId ( ) ) < nl > + / / . addUserKeyGroup ( userKeysGroup ) ) ; < nl > + < nl > + future . onResult ( new FetchUserEphemeralKeyResponse ( pkey ) ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( RpcException e ) { < nl > + Log . w ( TAG , " Public key error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > private void onPublicKeysGroupAdded ( int uid , ApiEncryptionKeyGroup keyGroup ) { < nl > UserKeys userKeys = getCachedUserKeys ( uid ) ; < nl > if ( userKeys = = null ) { < nl > @ @ - 514 , 6 + 544 , 9 @ @ public class KeyManagerActor extends ModuleActor { < nl > } else if ( message instanceof FetchUserEphemeralKey ) { < nl > fetchUserEphemeralKey ( ( ( FetchUserEphemeralKey ) message ) . getUid ( ) , ( ( FetchUserEphemeralKey ) message ) . getKeyGroup ( ) , ( ( FetchUserEphemeralKey ) message ) . getKeyId ( ) , future ) ; < nl > return false ; < nl > + } else if ( message instanceof FetchUserEphemeralKeyRandom ) { < nl > + fetchUserEphemeralKey ( ( ( FetchUserEphemeralKeyRandom ) message ) . getUid ( ) , ( ( FetchUserEphemeralKeyRandom ) message ) . getKeyGroup ( ) , future ) ; < nl > + return false ; < nl > } < nl > return super . onAsk ( message , future ) ; < nl > } < nl > @ @ - 639 , 6 + 672 , 25 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > } < nl > < nl > + public static class FetchUserEphemeralKeyRandom { < nl > + < nl > + private int uid ; < nl > + private int keyGroup ; < nl > + < nl > + public FetchUserEphemeralKeyRandom ( int uid , int keyGroup ) { < nl > + this . keyGroup = keyGroup ; < nl > + this . uid = uid ; < nl > + } < nl > + < nl > + public int getUid ( ) { < nl > + return uid ; < nl > + } < nl > + < nl > + public int getKeyGroup ( ) { < nl > + return keyGroup ; < nl > + } < nl > + } < nl > + < nl > public static class FetchUserEphemeralKeyResponse { < nl > private UserPublicKey ephemeralKey ; < nl > < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSession . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSession . java < nl > new file mode 100644 < nl > index 0000000 . . 73e85f9 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSession . java < nl > @ @ - 0 , 0 + 1 , 53 @ @ < nl > + package im . actor . core . modules . encryption . session ; < nl > + < nl > + import im . actor . core . modules . encryption . entity . OwnPrivateKey ; < nl > + import im . actor . core . modules . encryption . entity . UserPublicKey ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; < nl > + < nl > + public class EncryptedSession { < nl > + private OwnPrivateKey ownIdentityKey ; < nl > + private OwnPrivateKey ownPreKey ; < nl > + private UserPublicKey theirIdentityKey ; < nl > + private UserPublicKey theirPreKey ; < nl > + private int peerKeyGroupId ; < nl > + private byte [ ] masterKey ; < nl > + < nl > + public EncryptedSession ( OwnPrivateKey ownIdentityKey , OwnPrivateKey ownPreKey , UserPublicKey theirIdentityKey , UserPublicKey theirPreKey , int peerKeyGroupId ) { < nl > + this . ownIdentityKey = ownIdentityKey ; < nl > + this . ownPreKey = ownPreKey ; < nl > + this . theirIdentityKey = theirIdentityKey ; < nl > + this . theirPreKey = theirPreKey ; < nl > + this . peerKeyGroupId = peerKeyGroupId ; < nl > + this . masterKey = RatchetMasterSecret . calculateMasterSecret ( < nl > + new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > + new RatchetPrivateKey ( ownPreKey . getKey ( ) ) , < nl > + new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > + new RatchetPublicKey ( theirPreKey . getPublicKey ( ) ) ) ; < nl > + } < nl > + < nl > + public OwnPrivateKey getOwnIdentityKey ( ) { < nl > + return ownIdentityKey ; < nl > + } < nl > + < nl > + public OwnPrivateKey getOwnPreKey ( ) { < nl > + return ownPreKey ; < nl > + } < nl > + < nl > + public UserPublicKey getTheirIdentityKey ( ) { < nl > + return theirIdentityKey ; < nl > + } < nl > + < nl > + public UserPublicKey getTheirPreKey ( ) { < nl > + return theirPreKey ; < nl > + } < nl > + < nl > + public int getPeerKeyGroupId ( ) { < nl > + return peerKeyGroupId ; < nl > + } < nl > + < nl > + public byte [ ] getMasterKey ( ) { < nl > + return masterKey ; < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > new file mode 100644 < nl > index 0000000 . . a7167eb < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > @ @ - 0 , 0 + 1 , 93 @ @ < nl > + package im . actor . core . modules . encryption . session ; < nl > + < nl > + import java . util . HashSet ; < nl > + < nl > + import im . actor . runtime . crypto . IntegrityException ; < nl > + import im . actor . runtime . crypto . box . ActorBox ; < nl > + import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > + import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; < nl > + < nl > + public class EncryptedSessionChain { < nl > + < nl > + private EncryptedSession session ; < nl > + private byte [ ] ownPrivateKey ; < nl > + private byte [ ] theirPublicKey ; < nl > + private HashSet < Integer > receivedCounters ; < nl > + private int sentCounter ; < nl > + private byte [ ] rootChainKey ; < nl > + < nl > + public EncryptedSessionChain ( EncryptedSession session , byte [ ] ownPrivateKey , byte [ ] theirPublicKey ) { < nl > + this . session = session ; < nl > + this . ownPrivateKey = ownPrivateKey ; < nl > + this . theirPublicKey = theirPublicKey ; < nl > + this . receivedCounters = new HashSet < Integer > ( ) ; < nl > + this . sentCounter = 0 ; < nl > + this . rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > + new RatchetPrivateKey ( ownPrivateKey ) , < nl > + new RatchetPublicKey ( theirPublicKey ) , < nl > + session . getMasterKey ( ) ) ; < nl > + } < nl > + < nl > + public EncryptedSession getSession ( ) { < nl > + return session ; < nl > + } < nl > + < nl > + public byte [ ] getOwnPrivateKey ( ) { < nl > + return ownPrivateKey ; < nl > + } < nl > + < nl > + public byte [ ] getTheirPublicKey ( ) { < nl > + return theirPublicKey ; < nl > + } < nl > + < nl > + public byte [ ] decrypt ( byte [ ] data ) throws IntegrityException { < nl > + < nl > + if ( data . length < 88 ) { < nl > + throw new IntegrityException ( " Data length is too small " ) ; < nl > + } < nl > + < nl > + / / < nl > + / / Parsing message header < nl > + / / < nl > + < nl > + final int senderKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > + final long senderEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > + final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > + final byte [ ] senderEphemeralKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > + final byte [ ] receiverEphemeralKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > + final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > + < nl > + / / < nl > + / / Validating header < nl > + / / < nl > + < nl > + / / if ( senderKeyGroupId ! = session . getPeerKeyGroupId ( ) ) { < nl > + / / throw new IntegrityException ( " Incorrect sender key group id " ) ; < nl > + / / } < nl > + / / if ( senderEphermalKey0Id ! = session . getTheirPreKey ( ) . getKeyId ( ) ) { < nl > + / / throw new IntegrityException ( " Incorrect sender pre key id " ) ; < nl > + / / } < nl > + / / if ( receiverEphermalKey0Id ! = session . getOwnPreKey ( ) . getKeyId ( ) ) { < nl > + / / throw new IntegrityException ( " Incorrect receiver pre key id " ) ; < nl > + / / } < nl > + / / if ( ByteStrings . isEquals ( senderEphemeralKey , theirPublicKey ) ) { < nl > + / / throw new IntegrityException ( " Incorrect sender ephemeral key " ) ; < nl > + / / } < nl > + / / if ( ByteStrings . isEquals ( receiverEphemeralKey , ownPrivateKey ) ) { < nl > + / / throw new IntegrityException ( " Incorrect receiver ephemeral key " ) ; < nl > + / / } < nl > + < nl > + / / < nl > + / / Decryption < nl > + / / < nl > + < nl > + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; < nl > + byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; < nl > + byte [ ] message = ByteStrings . substring ( data , 88 , data . length - 88 ) ; < nl > + return ActorBox . openBox ( header , message , ratchetMessageKey ) ; < nl > + } < nl > + } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionStorage . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionStorage . java < nl > new file mode 100644 < nl > index 0000000 . . 0d805dd < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionStorage . java < nl > @ @ - 0 , 0 + 1 , 5 @ @ < nl > + package im . actor . core . modules . encryption . session ; < nl > + < nl > + public class EncryptedSessionStorage { < nl > + < nl > + } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / entity / DialogDesc . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / entity / DialogDesc . java < nl > new file mode 100644 < nl > index 0000000 . . bb8078b < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / entity / DialogDesc . java < nl > @ @ - 0 , 0 + 1 , 80 @ @ < nl > + package im . actor . core . entity ; < nl > + < nl > + import com . google . j2objc . annotations . Property ; < nl > + < nl > + import java . io . IOException ; < nl > + < nl > + import im . actor . runtime . bser . BserObject ; < nl > + import im . actor . runtime . bser . BserValues ; < nl > + import im . actor . runtime . bser . BserWriter ; < nl > + import im . actor . runtime . storage . KeyValueItem ; < nl > + < nl > + public class DialogDesc extends BserObject implements KeyValueItem { < nl > + < nl > + @ Property ( " readonly , nonatomic " ) < nl > + private Peer peer ; < nl > + @ Property ( " readonly , nonatomic " ) < nl > + private String title ; < nl > + @ Property ( " readonly , nonatomic " ) < nl > + private Avatar avatar ; < nl > + @ Property ( " readonly , nonatomic " ) < nl > + private boolean isUnread ; < nl > + @ Property ( " readonly , nonatomic " ) < nl > + private int counter ; < nl > + < nl > + public DialogDesc ( Peer peer , String title , Avatar avatar , boolean isUnread , int counter ) { < nl > + this . peer = peer ; < nl > + this . title = title ; < nl > + this . avatar = avatar ; < nl > + this . isUnread = isUnread ; < nl > + this . counter = counter ; < nl > + } < nl > + < nl > + public Peer getPeer ( ) { < nl > + return peer ; < nl > + } < nl > + < nl > + public String getTitle ( ) { < nl > + return title ; < nl > + } < nl > + < nl > + public Avatar getAvatar ( ) { < nl > + return avatar ; < nl > + } < nl > + < nl > + public int getCounter ( ) { < nl > + return counter ; < nl > + } < nl > + < nl > + public boolean isUnread ( ) { < nl > + return isUnread ; < nl > + } < nl > + < nl > + @ Override < nl > + public void parse ( BserValues values ) throws IOException { < nl > + peer = Peer . fromBytes ( values . getBytes ( 1 ) ) ; < nl > + title = values . getString ( 2 ) ; < nl > + byte [ ] av = values . getBytes ( 3 ) ; < nl > + if ( av ! = null ) { < nl > + avatar = new Avatar ( av ) ; < nl > + } < nl > + counter = values . getInt ( 4 ) ; < nl > + isUnread = values . getBool ( 5 ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void serialize ( BserWriter writer ) throws IOException { < nl > + writer . writeObject ( 1 , peer ) ; < nl > + writer . writeString ( 2 , title ) ; < nl > + if ( avatar ! = null ) { < nl > + writer . writeObject ( 3 , avatar ) ; < nl > + } < nl > + writer . writeInt ( 4 , counter ) ; < nl > + writer . writeBool ( 5 , isUnread ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public long getEngineId ( ) { < nl > + return peer . getUnuqueId ( ) ; < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / MessagesModule . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / MessagesModule . java < nl > index 85714e6 . . 30e0d85 100644 < nl > - - - a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / MessagesModule . java < nl > + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / MessagesModule . java < nl > @ @ - 35 , 6 + 35 , 7 @ @ import im . actor . core . modules . internal . messages . CursorReaderActor ; < nl > import im . actor . core . modules . internal . messages . CursorReceiverActor ; < nl > import im . actor . core . modules . internal . messages . DialogsActor ; < nl > import im . actor . core . modules . internal . messages . DialogsHistoryActor ; < nl > + import im . actor . core . modules . internal . messages . GroupedDialogsActor ; < nl > import im . actor . core . modules . internal . messages . MessageDeleteActor ; < nl > import im . actor . core . modules . internal . messages . MessageShownActor ; < nl > import im . actor . core . modules . internal . messages . MessageShownFilter ; < nl > @ @ - 46 , 6 + 47 , 7 @ @ import im . actor . core . network . RpcException ; < nl > import im . actor . core . network . RpcInternalException ; < nl > import im . actor . core . viewmodel . Command ; < nl > import im . actor . core . viewmodel . CommandCallback ; < nl > + import im . actor . core . viewmodel . DialogGroupsVM ; < nl > import im . actor . runtime . Storage ; < nl > import im . actor . runtime . actors . ActorCreator ; < nl > import im . actor . runtime . actors . ActorRef ; < nl > @ @ - 62 , 8 + 64 , 10 @ @ import static im . actor . runtime . actors . ActorSystem . system ; < nl > public class MessagesModule extends AbsModule implements BusSubscriber { < nl > < nl > private ListEngine < Dialog > dialogs ; < nl > + < nl > private ActorRef dialogsActor ; < nl > private ActorRef dialogsHistoryActor ; < nl > + private ActorRef dialogsGroupedActor ; < nl > private ActorRef ownReadActor ; < nl > private ActorRef plainReadActor ; < nl > private ActorRef plainReceiverActor ; < nl > @ @ - 79 , 6 + 83 , 8 @ @ public class MessagesModule extends AbsModule implements BusSubscriber { < nl > < nl > private final SyncKeyValue cursorStorage ; < nl > < nl > + private final DialogGroupsVM dialogGroups = new DialogGroupsVM ( ) ; < nl > + < nl > public MessagesModule ( final ModuleContext context ) { < nl > super ( context ) ; < nl > < nl > @ @ - 99 , 6 + 105 , 14 @ @ public class MessagesModule extends AbsModule implements BusSubscriber { < nl > return new DialogsHistoryActor ( context ( ) ) ; < nl > } < nl > } ) , " actor / dialogs / history " ) ; < nl > + < nl > + this . dialogsGroupedActor = system ( ) . actorOf ( Props . create ( GroupedDialogsActor . class , new ActorCreator < GroupedDialogsActor > ( ) { < nl > + @ Override < nl > + public GroupedDialogsActor create ( ) { < nl > + return new GroupedDialogsActor ( context ( ) ) ; < nl > + } < nl > + } ) , " actor / dialogs / grouped " ) ; < nl > + < nl > this . ownReadActor = system ( ) . actorOf ( Props . create ( OwnReadActor . class , new ActorCreator < OwnReadActor > ( ) { < nl > @ Override < nl > public OwnReadActor create ( ) { < nl > @ @ - 139 , 6 + 153 , 10 @ @ public class MessagesModule extends AbsModule implements BusSubscriber { < nl > context ( ) . getEvents ( ) . subscribe ( this , PeerChatOpened . EVENT ) ; < nl > } < nl > < nl > + public DialogGroupsVM getDialogGroupsVM ( ) { < nl > + return dialogGroups ; < nl > + } < nl > + < nl > public ActorRef getSendMessageActor ( ) { < nl > return sendMessageActor ; < nl > } < nl > @ @ - 221 , 6 + 239 , 10 @ @ public class MessagesModule extends AbsModule implements BusSubscriber { < nl > return dialogsHistoryActor ; < nl > } < nl > < nl > + public ActorRef getDialogsGroupedActor ( ) { < nl > + return dialogsGroupedActor ; < nl > + } < nl > + < nl > public ListEngine < Dialog > getDialogsEngine ( ) { < nl > return dialogs ; < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / ConversationActor . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / ConversationActor . java < nl > index 6641ed9 . . 8bf76dc 100644 < nl > - - - a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / ConversationActor . java < nl > + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / ConversationActor . java < nl > @ @ - 44 , 6 + 44 , 7 @ @ public class ConversationActor extends ModuleActor { < nl > private IndexStorage outPendingIndex ; < nl > private IndexStorage inPendingIndex ; < nl > private ActorRef dialogsActor ; < nl > + private ActorRef dialogsGroupedActor ; < nl > private long inReadState ; < nl > private long outReadState ; < nl > private long outReceiveState ; < nl > @ @ - 62 , 6 + 63 , 7 @ @ public class ConversationActor extends ModuleActor { < nl > docs = context ( ) . getMessagesModule ( ) . getConversationDocsEngine ( peer ) ; < nl > < nl > dialogsActor = context ( ) . getMessagesModule ( ) . getDialogsActor ( ) ; < nl > + dialogsGroupedActor = context ( ) . getMessagesModule ( ) . getDialogsGroupedActor ( ) ; < nl > outPendingIndex = Storage . createIndex ( " out _ pending _ " + peer . getPeerType ( ) + " _ " + peer . getPeerId ( ) ) ; < nl > inPendingIndex = Storage . createIndex ( " in _ pending _ " + peer . getPeerType ( ) + " _ " + peer . getPeerId ( ) ) ; < nl > < nl > @ @ - 135 , 6 + 137 , 8 @ @ public class ConversationActor extends ModuleActor { < nl > / / Update dialogs < nl > if ( topMessage ! = null ) { < nl > if ( ! isHiddenPeer ) { < nl > + dialogsGroupedActor . send ( new GroupedDialogsActor . NewMessage ( peer , inPendingIndex . getCount ( ) , < nl > + topMessage . getSortDate ( ) ) ) ; < nl > dialogsActor . send ( new DialogsActor . InMessage ( peer , topMessage , inPendingIndex . getCount ( ) ) ) ; < nl > } < nl > } < nl > @ @ - 185 , 6 + 189 , 8 @ @ public class ConversationActor extends ModuleActor { < nl > < nl > if ( ! isHiddenPeer ) { < nl > dialogsActor . send ( new DialogsActor . InMessage ( peer , message , inPendingIndex . getCount ( ) ) ) ; < nl > + dialogsGroupedActor . send ( new GroupedDialogsActor . NewMessage ( peer , inPendingIndex . getCount ( ) , < nl > + message . getSortDate ( ) ) ) ; < nl > } < nl > } < nl > } < nl > @ @ - 239 , 6 + 245 , 8 @ @ public class ConversationActor extends ModuleActor { < nl > if ( ! isHiddenPeer ) { < nl > / / Updating dialog < nl > dialogsActor . send ( new DialogsActor . InMessage ( peer , updatedMsg , inPendingIndex . getCount ( ) ) ) ; < nl > + dialogsGroupedActor . send ( new GroupedDialogsActor . NewMessage ( peer , inPendingIndex . getCount ( ) , < nl > + updatedMsg . getSortDate ( ) ) ) ; < nl > } < nl > < nl > / / Updating pending index < nl > @ @ - 361 , 6 + 369 , 7 @ @ public class ConversationActor extends ModuleActor { < nl > < nl > if ( ! isHiddenPeer ) { < nl > dialogsActor . send ( new DialogsActor . CounterChanged ( peer , inPendingIndex . getCount ( ) ) ) ; < nl > + / / TODO : Implement for grouped < nl > } < nl > } < nl > < nl > @ @ - 402 , 6 + 411 , 7 @ @ public class ConversationActor extends ModuleActor { < nl > inPendingIndex . clear ( ) ; < nl > outPendingIndex . clear ( ) ; < nl > dialogsActor . send ( new DialogsActor . ChatDelete ( peer ) ) ; < nl > + / / TODO : Implement for grouped < nl > } < nl > < nl > / / History < nl > diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / DialogsActor . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / DialogsActor . java < nl > index 311de19 . . b77ac37 100644 < nl > - - - a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / DialogsActor . java < nl > + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / DialogsActor . java < nl > @ @ - 50 , 7 + 50 , 7 @ @ public class DialogsActor extends ModuleActor { < nl > long start = im . actor . runtime . Runtime . getCurrentTime ( ) ; < nl > PeerDesc peerDesc = buildPeerDesc ( peer ) ; < nl > if ( peerDesc = = null ) { < nl > - Log . d ( " DialogsActor " , " unknown peer desk " ) ; < nl > + Log . d ( " DialogsActor " , " unknown peer desc " ) ; < nl > return ; < nl > } < nl > < nl > @ @ - 75 , 8 + 75 , 11 @ @ public class DialogsActor extends ModuleActor { < nl > . setText ( contentDescription . getText ( ) ) < nl > . setRelatedUid ( contentDescription . getRelatedUser ( ) ) < nl > . setStatus ( message . getMessageState ( ) ) < nl > - . setSenderId ( message . getSenderId ( ) ) < nl > - . setUnreadCount ( counter ) ; < nl > + . setSenderId ( message . getSenderId ( ) ) ; < nl > + < nl > + if ( counter > = 0 ) { < nl > + builder . setUnreadCount ( counter ) ; < nl > + } < nl > < nl > boolean forceUpdate = false ; < nl > < nl > diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / GroupedDialogsActor . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / GroupedDialogsActor . java < nl > new file mode 100644 < nl > index 0000000 . . f0fdf00 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / GroupedDialogsActor . java < nl > @ @ - 0 , 0 + 1 , 184 @ @ < nl > + package im . actor . core . modules . internal . messages ; < nl > + < nl > + import java . util . ArrayList ; < nl > + import java . util . HashMap ; < nl > + < nl > + import im . actor . core . entity . Avatar ; < nl > + import im . actor . core . entity . DialogDesc ; < nl > + import im . actor . core . entity . Peer ; < nl > + import im . actor . core . entity . PeerType ; < nl > + import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . utils . ModuleActor ; < nl > + import im . actor . core . viewmodel . DialogGroup ; < nl > + < nl > + public class GroupedDialogsActor extends ModuleActor { < nl > + < nl > + private PeerGroup groups = new PeerGroup ( " groups " , " Groups " ) ; < nl > + private PeerGroup privates = new PeerGroup ( " private " , " Private " ) ; < nl > + < nl > + public GroupedDialogsActor ( ModuleContext context ) { < nl > + super ( context ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void preStart ( ) { < nl > + super . preStart ( ) ; < nl > + } < nl > + < nl > + private void onPeerInfoChanged ( Peer peer , String title , Avatar avatar ) { < nl > + < nl > + } < nl > + < nl > + private void onNewMessage ( Peer peer , long sortDate , int counter ) { < nl > + < nl > + PeerGroup peerGroup ; < nl > + if ( peer . getPeerType ( ) = = PeerType . GROUP ) { < nl > + peerGroup = groups ; < nl > + } else if ( peer . getPeerType ( ) = = PeerType . PRIVATE ) { < nl > + peerGroup = privates ; < nl > + } else { < nl > + return ; < nl > + } < nl > + < nl > + boolean found = false ; < nl > + for ( PeerDesc d : peerGroup . getPeers ( ) ) { < nl > + if ( d . getPeer ( ) . equals ( peer ) ) { < nl > + d . setCounter ( counter ) ; < nl > + found = true ; < nl > + } < nl > + } < nl > + < nl > + if ( ! found ) { < nl > + peerGroup . getPeers ( ) . add ( new PeerDesc ( peer , counter ) ) ; < nl > + } < nl > + < nl > + ArrayList < DialogGroup > groups = new ArrayList < DialogGroup > ( ) ; < nl > + ArrayList < DialogDesc > groupDescs = new ArrayList < DialogDesc > ( ) ; < nl > + for ( PeerDesc d : peerGroup . getPeers ( ) ) { < nl > + groupDescs . add ( new DialogDesc ( d . getPeer ( ) , " GRPOUP # " + d . getPeer ( ) . getPeerId ( ) , < nl > + null , false , d . counter ) ) ; < nl > + } < nl > + groups . add ( new DialogGroup ( " Groups " , " group " , groupDescs ) ) ; < nl > + < nl > + context ( ) . getMessagesModule ( ) . getDialogGroupsVM ( ) . getGroupsValueModel ( ) . change ( groups ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onReceive ( Object message ) { < nl > + if ( message instanceof PeerInformationChanged ) { < nl > + PeerInformationChanged informationChanged = ( PeerInformationChanged ) message ; < nl > + onPeerInfoChanged ( informationChanged . getPeer ( ) , < nl > + informationChanged . getTitle ( ) , < nl > + informationChanged . getAvatar ( ) ) ; < nl > + } else if ( message instanceof NewMessage ) { < nl > + NewMessage newMessage = ( NewMessage ) message ; < nl > + onNewMessage ( newMessage . peer , newMessage . sortDate , newMessage . counter ) ; < nl > + } else { < nl > + super . onReceive ( message ) ; < nl > + } < nl > + } < nl > + < nl > + public static class PeerInformationChanged { < nl > + < nl > + private Peer peer ; < nl > + private String title ; < nl > + private Avatar avatar ; < nl > + < nl > + public PeerInformationChanged ( Peer peer , String title , Avatar avatar ) { < nl > + this . peer = peer ; < nl > + this . title = title ; < nl > + this . avatar = avatar ; < nl > + } < nl > + < nl > + public Peer getPeer ( ) { < nl > + return peer ; < nl > + } < nl > + < nl > + public String getTitle ( ) { < nl > + return title ; < nl > + } < nl > + < nl > + public Avatar getAvatar ( ) { < nl > + return avatar ; < nl > + } < nl > + } < nl > + < nl > + public static class CounterChanged { < nl > + private Peer peer ; < nl > + private int counter ; < nl > + < nl > + public CounterChanged ( Peer peer , int counter ) { < nl > + this . peer = peer ; < nl > + this . counter = counter ; < nl > + } < nl > + < nl > + public Peer getPeer ( ) { < nl > + return peer ; < nl > + } < nl > + < nl > + public int getCounter ( ) { < nl > + return counter ; < nl > + } < nl > + } < nl > + < nl > + public static class NewMessage { < nl > + < nl > + private Peer peer ; < nl > + private int counter ; < nl > + private long sortDate ; < nl > + < nl > + public NewMessage ( Peer peer , int counter , long sortDate ) { < nl > + this . peer = peer ; < nl > + this . counter = counter ; < nl > + this . sortDate = sortDate ; < nl > + } < nl > + } < nl > + < nl > + private class PeerGroup { < nl > + < nl > + private String key ; < nl > + private String title ; < nl > + private ArrayList < PeerDesc > peers ; < nl > + < nl > + public PeerGroup ( String key , String title ) { < nl > + this . key = key ; < nl > + this . title = title ; < nl > + this . peers = new ArrayList < PeerDesc > ( ) ; < nl > + } < nl > + < nl > + public String getKey ( ) { < nl > + return key ; < nl > + } < nl > + < nl > + public String getTitle ( ) { < nl > + return title ; < nl > + } < nl > + < nl > + public ArrayList < PeerDesc > getPeers ( ) { < nl > + return peers ; < nl > + } < nl > + } < nl > + < nl > + private class PeerDesc { < nl > + < nl > + private Peer peer ; < nl > + private int counter ; < nl > + < nl > + public PeerDesc ( Peer peer , int counter ) { < nl > + this . peer = peer ; < nl > + this . counter = counter ; < nl > + } < nl > + < nl > + public Peer getPeer ( ) { < nl > + return peer ; < nl > + } < nl > + < nl > + public int getCounter ( ) { < nl > + return counter ; < nl > + } < nl > + < nl > + public void setCounter ( int counter ) { < nl > + this . counter = counter ; < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroup . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroup . java < nl > new file mode 100644 < nl > index 0000000 . . ae47f02 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroup . java < nl > @ @ - 0 , 0 + 1 , 30 @ @ < nl > + package im . actor . core . viewmodel ; < nl > + < nl > + import java . util . ArrayList ; < nl > + < nl > + import im . actor . core . entity . DialogDesc ; < nl > + < nl > + public class DialogGroup { < nl > + < nl > + private String title ; < nl > + private String key ; < nl > + private ArrayList < DialogDesc > dialogs ; < nl > + < nl > + public DialogGroup ( String title , String key , ArrayList < DialogDesc > dialogs ) { < nl > + this . title = title ; < nl > + this . key = key ; < nl > + this . dialogs = dialogs ; < nl > + } < nl > + < nl > + public String getTitle ( ) { < nl > + return title ; < nl > + } < nl > + < nl > + public String getKey ( ) { < nl > + return key ; < nl > + } < nl > + < nl > + public ArrayList < DialogDesc > getDialogs ( ) { < nl > + return dialogs ; < nl > + } < nl > + } < nl > diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroupsVM . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroupsVM . java < nl > new file mode 100644 < nl > index 0000000 . . 0a374ba < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroupsVM . java < nl > @ @ - 0 , 0 + 1 , 18 @ @ < nl > + package im . actor . core . viewmodel ; < nl > + < nl > + import java . util . ArrayList ; < nl > + < nl > + import im . actor . runtime . mvvm . ValueModel ; < nl > + < nl > + public class DialogGroupsVM { < nl > + < nl > + private ValueModel < ArrayList < DialogGroup > > groupsValueModel ; < nl > + < nl > + public DialogGroupsVM ( ) { < nl > + groupsValueModel = new ValueModel < ArrayList < DialogGroup > > ( " groups . model " , null ) ; < nl > + } < nl > + < nl > + public ValueModel < ArrayList < DialogGroup > > getGroupsValueModel ( ) { < nl > + return groupsValueModel ; < nl > + } < nl > + } < nl > diff - - git a / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteKeyValue . java b / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteKeyValue . java < nl > index 530cb4b . . 31e2f0e 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteKeyValue . java < nl > + + + b / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteKeyValue . java < nl > @ @ - 119 , 21 + 119 , 9 @ @ public class SQLiteKeyValue implements KeyValueStorage { < nl > } < nl > < nl > @ Override < nl > - public void clear ( ) { < nl > - checkSqlite ( ) ; < nl > - db . beginTransaction ( ) ; < nl > - try { < nl > - db . execSQL ( " DELETE FROM \ " " + name + " \ " " ) ; < nl > - db . setTransactionSuccessful ( ) ; < nl > - } finally { < nl > - db . endTransaction ( ) ; < nl > - } < nl > - } < nl > - < nl > - @ Override < nl > - public byte [ ] getValue ( long id ) { < nl > + public byte [ ] loadItem ( long key ) { < nl > checkSqlite ( ) ; < nl > - Cursor cursor = db . query ( " \ " " + name + " \ " " , new String [ ] { " \ " BYTES \ " " } , " \ " ID \ " = ? " , new String [ ] { " " + id } , null , null , null ) ; < nl > + Cursor cursor = db . query ( " \ " " + name + " \ " " , new String [ ] { " \ " BYTES \ " " } , " \ " ID \ " = ? " , new String [ ] { " " + key } , null , null , null ) ; < nl > if ( cursor = = null ) { < nl > return null ; < nl > } < nl > @ @ - 146 , 4 + 134 , 26 @ @ public class SQLiteKeyValue implements KeyValueStorage { < nl > } < nl > return null ; < nl > } < nl > + < nl > + @ Override < nl > + public List < KeyValueRecord > loadItems ( long [ ] keys ) { < nl > + return null ; < nl > + } < nl > + < nl > + @ Override < nl > + public List < KeyValueRecord > loadAllItems ( ) { < nl > + return null ; < nl > + } < nl > + < nl > + @ Override < nl > + public void clear ( ) { < nl > + checkSqlite ( ) ; < nl > + db . beginTransaction ( ) ; < nl > + try { < nl > + db . execSQL ( " DELETE FROM \ " " + name + " \ " " ) ; < nl > + db . setTransactionSuccessful ( ) ; < nl > + } finally { < nl > + db . endTransaction ( ) ; < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteList . java b / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteList . java < nl > index b153387 . . 25b59e1 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteList . java < nl > + + + b / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteList . java < nl > @ @ - 124 , 6 + 124 , 11 @ @ public class SQLiteList implements ListStorageDisplayEx { < nl > return null ; < nl > } < nl > < nl > + @ Override < nl > + public List < ListEngineRecord > loadAllItems ( ) { < nl > + return null ; < nl > + } < nl > + < nl > < nl > public ListEngineRecord loadItemBySortKey ( long key ) { < nl > checkTable ( ) ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / shared / src / main / java / im / actor / runtime / storage / KeyValueEngine . java b / actor - sdk / sdk - core / runtime / shared / src / main / java / im / actor / runtime / storage / KeyValueEngine . java < nl > index 60239e4 . . c7dd481 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / shared / src / main / java / im / actor / runtime / storage / KeyValueEngine . java < nl > + + + b / actor - sdk / sdk - core / runtime / shared / src / main / java / im / actor / runtime / storage / KeyValueEngine . java < nl > @ @ - 9 , 6 + 9 , 7 @ @ import com . google . j2objc . annotations . ObjectiveCName ; < nl > import java . util . List ; < nl > < nl > public interface KeyValueEngine < V extends KeyValueItem > { < nl > + < nl > @ ObjectiveCName ( " addOrUpdateItem : " ) < nl > void addOrUpdateItem ( V item ) ; < nl > < nl > diff - - git a / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBKeyValue . swift b / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBKeyValue . swift < nl > index fb65f46 . . c22c65a 100644 < nl > - - - a / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBKeyValue . swift < nl > + + + b / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBKeyValue . swift < nl > @ @ - 5 , 18 + 5 , 21 @ @ < nl > import Foundation < nl > < nl > @ objc class FMDBKeyValue : NSObject , ARKeyValueStorage { < nl > - var db : FMDatabase ? ; < nl > + < nl > + var db : FMDatabase ! < nl > < nl > - let databasePath : String ; < nl > - let tableName : String ; < nl > + let databasePath : String < nl > + let tableName : String < nl > < nl > - let queryCreate : String ; < nl > - let queryItem : String ; < nl > - let queryAdd : String ; < nl > - let queryDelete : String ; < nl > - let queryDeleteAll : String ; < nl > + let queryCreate : String < nl > + let queryItem : String < nl > + let queryItems : String < nl > + let queryAll : String < nl > + let queryAdd : String < nl > + let queryDelete : String < nl > + let queryDeleteAll : String < nl > < nl > - var isTableChecked : Bool = false ; < nl > + var isTableChecked : Bool = false < nl > < nl > init ( databasePath : String , tableName : String ) { < nl > self . databasePath = databasePath < nl > @ @ - 26 , 11 + 29 , 13 @ @ import Foundation < nl > self . queryCreate = " CREATE TABLE IF NOT EXISTS " + tableName + " ( " + < nl > " \ " ID \ " INTEGER NOT NULL , " + < nl > " \ " BYTES \ " BLOB NOT NULL , " + < nl > - " PRIMARY KEY ( \ " ID \ " ) ) ; " ; < nl > - self . queryItem = " SELECT \ " BYTES \ " FROM " + tableName + " WHERE \ " ID \ " = ? ; " ; < nl > - self . queryAdd = " REPLACE INTO " + tableName + " ( \ " ID \ " , \ " BYTES \ " ) VALUES ( ? , ? ) ; " ; < nl > - self . queryDelete = " DELETE FROM " + tableName + " WHERE \ " ID \ " = ? ; " ; < nl > - self . queryDeleteAll = " DELETE FROM " + tableName + " ; " ; < nl > + " PRIMARY KEY ( \ " ID \ " ) ) ; " < nl > + self . queryItem = " SELECT \ " BYTES \ " FROM " + tableName + " WHERE \ " ID \ " = ? ; " < nl > + self . queryItems = " SELECT ( \ " ID \ " , \ " BYTES \ " ) FROM " + tableName + " WHERE \ " ID \ " in ? ; " < nl > + self . queryAll = " SELECT ( \ " ID \ " , \ " BYTES \ " ) FROM " + tableName + " ; " < nl > + self . queryAdd = " REPLACE INTO " + tableName + " ( \ " ID \ " , \ " BYTES \ " ) VALUES ( ? , ? ) ; " < nl > + self . queryDelete = " DELETE FROM " + tableName + " WHERE \ " ID \ " = ? ; " < nl > + self . queryDeleteAll = " DELETE FROM " + tableName + " ; " < nl > < nl > super . init ( ) < nl > } < nl > @ @ - 39 , 68 + 44 , 103 @ @ import Foundation < nl > if ( isTableChecked ) { < nl > return < nl > } < nl > - isTableChecked = true ; < nl > + isTableChecked = true < nl > < nl > self . db = FMDatabase ( path : databasePath ) < nl > - self . db ! . open ( ) < nl > - if ( ! db ! . tableExists ( tableName ) ) { < nl > - db ! . executeUpdate ( queryCreate ) < nl > + self . db . open ( ) < nl > + if ( ! db . tableExists ( tableName ) ) { < nl > + db . executeUpdate ( queryCreate ) < nl > } < nl > } < nl > < nl > func addOrUpdateItems ( values : JavaUtilList ! ) { < nl > - checkTable ( ) ; < nl > + checkTable ( ) < nl > < nl > - db ! . beginTransaction ( ) < nl > + db . beginTransaction ( ) < nl > for i in 0 . . < values . size ( ) { < nl > - let record = values . getWithInt ( i ) as ! ARKeyValueRecord ; < nl > - db ! . executeUpdate ( queryAdd , record . getId ( ) . toNSNumber ( ) , record . getData ( ) ! . toNSData ( ) ) < nl > + let record = values . getWithInt ( i ) as ! ARKeyValueRecord < nl > + db . executeUpdate ( queryAdd , record . getId ( ) . toNSNumber ( ) , record . getData ( ) ! . toNSData ( ) ) < nl > } < nl > - db ! . commit ( ) < nl > + db . commit ( ) < nl > } < nl > < nl > func addOrUpdateItemWithKey ( key : jlong , withData data : IOSByteArray ! ) { < nl > - checkTable ( ) ; < nl > + checkTable ( ) < nl > < nl > - db ! . beginTransaction ( ) < nl > - db ! . executeUpdate ( queryAdd , key . toNSNumber ( ) , data ! . toNSData ( ) ) < nl > - db ! . commit ( ) < nl > + db . beginTransaction ( ) < nl > + db . executeUpdate ( queryAdd , key . toNSNumber ( ) , data ! . toNSData ( ) ) < nl > + db . commit ( ) < nl > } < nl > < nl > func removeItemsWithKeys ( keys : IOSLongArray ! ) { < nl > - checkTable ( ) ; < nl > + checkTable ( ) < nl > < nl > - db ! . beginTransaction ( ) < nl > + db . beginTransaction ( ) < nl > for i in 0 . . < keys . length ( ) { < nl > let key = keys . longAtIndex ( UInt ( i ) ) ; < nl > - db ! . executeUpdate ( queryDelete , key . toNSNumber ( ) ) < nl > + db . executeUpdate ( queryDelete , key . toNSNumber ( ) ) < nl > } < nl > - db ! . commit ( ) < nl > + db . commit ( ) < nl > } < nl > < nl > func removeItemWithKey ( key : jlong ) { < nl > - checkTable ( ) ; < nl > + checkTable ( ) < nl > < nl > - db ! . beginTransaction ( ) < nl > - db ! . executeUpdate ( queryDelete , key . toNSNumber ( ) ) < nl > - db ! . commit ( ) < nl > + db . beginTransaction ( ) < nl > + db . executeUpdate ( queryDelete , key . toNSNumber ( ) ) < nl > + db . commit ( ) < nl > } < nl > < nl > - func getValueWithKey ( key : jlong ) - > IOSByteArray ! { < nl > - checkTable ( ) ; < nl > + func loadItemWithKey ( key : jlong ) - > IOSByteArray ! { < nl > + checkTable ( ) < nl > < nl > - let result = db ! . dataForQuery ( queryItem , key . toNSNumber ( ) ) ; < nl > + let result = db . dataForQuery ( queryItem , key . toNSNumber ( ) ) < nl > if ( result = = nil ) { < nl > - return nil ; < nl > + return nil < nl > + } < nl > + return result . toJavaBytes ( ) < nl > + } < nl > + < nl > + func loadAllItems ( ) - > JavaUtilList ! { < nl > + checkTable ( ) < nl > + < nl > + let res = JavaUtilArrayList ( ) < nl > + < nl > + if let result = db . executeQuery ( queryAll ) { < nl > + while ( result . next ( ) ) { < nl > + res . addWithId ( ARKeyValueRecord ( key : jlong ( result . longLongIntForColumn ( " ID " ) ) , withData : result . dataForColumn ( " BYTES " ) . toJavaBytes ( ) ) ) < nl > + } < nl > + } < nl > + < nl > + return res < nl > + } < nl > + < nl > + func loadItems ( keys : IOSLongArray ! ) - > JavaUtilList ! { < nl > + checkTable ( ) < nl > + < nl > + / / Converting to NSNumbers < nl > + var ids = [ NSNumber ] ( ) < nl > + for i in 0 . . < keys . length ( ) { < nl > + ids . append ( keys . longAtIndex ( UInt ( i ) ) . toNSNumber ( ) ) < nl > } < nl > - return result . toJavaBytes ( ) ; < nl > + < nl > + let res = JavaUtilArrayList ( ) < nl > + < nl > + if let result = db . executeQuery ( queryItems , ids ) { < nl > + while ( result . next ( ) ) { < nl > + / / TODO : Optimize lookup < nl > + res . addWithId ( ARKeyValueRecord ( key : jlong ( result . longLongIntForColumn ( " ID " ) ) , withData : result . dataForColumn ( " BYTES " ) . toJavaBytes ( ) ) ) < nl > + } < nl > + } < nl > + < nl > + return res < nl > } < nl > < nl > func clear ( ) { < nl > - checkTable ( ) ; < nl > + checkTable ( ) < nl > < nl > - db ! . beginTransaction ( ) < nl > - db ! . executeUpdate ( queryDeleteAll ) ; < nl > - db ! . commit ( ) < nl > + db . beginTransaction ( ) < nl > + db . executeUpdate ( queryDeleteAll ) < nl > + db . commit ( ) < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBList . swift b / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBList . swift < nl > index 27ac7e7 . . 209a6e3 100644 < nl > - - - a / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBList . swift < nl > + + + b / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBList . swift < nl > @ @ - 199 , 6 + 199 , 12 @ @ class FMDBList : NSObject , ARListStorageDisplayEx { < nl > } < nl > } < nl > < nl > + func loadAllItems ( ) - > JavaUtilList ! { < nl > + let res = JavaUtilArrayList ( ) < nl > + / / TODO : Implement < nl > + return res < nl > + } < nl > + < nl > func loadForwardWithSortKey ( sortingKey : JavaLangLong ! , withLimit limit : jint ) - > JavaUtilList ! { < nl > checkTable ( ) ; < nl > var result : FMResultSet ? = nil ;

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index faeabe9 . . e08862e 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 6 , 46 + 6 , 54 @ @ import im . actor . core . modules . ModuleContext ; 
 import im . actor . core . modules . encryption . entity . OwnPrivateKey ; 
 import im . actor . core . modules . encryption . entity . UserKeysGroup ; 
 import im . actor . core . modules . encryption . entity . UserPublicKey ; 
 - import im . actor . core . util . Hex ; 
 + import im . actor . core . modules . encryption . session . EncryptedSession ; 
 + import im . actor . core . modules . encryption . session . EncryptedSessionChain ; 
 import im . actor . core . util . ModuleActor ; 
 + import im . actor . core . util . RandomUtils ; 
 import im . actor . runtime . * ; 
 + import im . actor . runtime . actors . ActorCreator ; 
 + import im . actor . runtime . actors . ActorRef ; 
 import im . actor . runtime . actors . Future ; 
 + import im . actor . runtime . actors . Props ; 
 import im . actor . runtime . actors . ask . AskCallback ; 
 + import im . actor . runtime . crypto . Curve25519 ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 - import im . actor . runtime . crypto . box . ActorBox ; 
 - import im . actor . runtime . crypto . box . ActorBoxKey ; 
 import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; 
 - import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; 
 import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; 
 import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; 
 - import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; 
 
 public class EncryptedSessionActor extends ModuleActor { 
 
 private final String TAG ; 
 
 - private final int uid ; 
 + / / 
 + / / Key References 
 + / / 
 
 private final long ownKey0 ; 
 + private final int uid ; 
 private final long theirKey0 ; 
 private final int theirKeyGroup ; 
 
 + / / 
 + / / Loaded Keys 
 + / / 
 + 
 private OwnPrivateKey ownIdentityKey ; 
 private OwnPrivateKey ownPreKey ; 
 private UserPublicKey theirIdentityKey ; 
 private UserPublicKey theirPreKey ; 
 + private EncryptedSession session ; 
 + / / True if it is unable to load key 
 + private boolean isUnavailable = false ; 
 
 - private byte [ ] masterKey ; 
 - 
 - private byte [ ] prevOwnKey ; 
 - private OwnPrivateKey currentOwnKey ; 
 - private UserPublicKey currentTheirKey ; 
 - 
 - private int outIndex = 0 ; 
 - private int inIndex = 0 ; 
 + / / 
 + / / Temp encryption chains 
 + / / 
 
 - private boolean isUnavailable = false ; 
 + private byte [ ] theirEphemeralKey ; 
 + private ArrayList < EncryptedSessionChain > chains = new ArrayList < EncryptedSessionChain > ( ) ; 
 
 public EncryptedSessionActor ( ModuleContext context , int uid , long ownKey0 , long theirKey0 , 
 int theirKeyGroup ) { 
 @ @ - 148 , 14 + 156 , 41 @ @ public class EncryptedSessionActor extends ModuleActor { 
 } 
 
 private void loadMasterKey ( ) { 
 - masterKey = RatchetMasterSecret . calculateMasterSecret ( 
 - new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 - new RatchetPrivateKey ( ownPreKey . getKey ( ) ) , 
 - new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 - new RatchetPublicKey ( theirPreKey . getPublicKey ( ) ) ) ; 
 + session = new EncryptedSession ( ownIdentityKey , ownPreKey , 
 + theirIdentityKey , theirPreKey , theirKeyGroup ) ; 
 } 
 
 private void onEncrypt ( final byte [ ] data , final Future future ) { 
 + if ( isUnavailable ) { 
 + future . onError ( new RuntimeException ( " Encryption session is unavailable " ) ) ; 
 + return ; 
 + } 
 + 
 + / / if ( theirEphemeralKey = = null ) { 
 + / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchUserEphemeralKeyRandom ( uid , theirKeyGroup ) , new AskCallback ( ) { 
 + / / @ Override 
 + / / public void onResult ( Object obj ) { 
 + / / if ( theirEphemeralKey ! = null ) { 
 + / / KeyManagerActor . FetchUserEphemeralKeyResponse response = ( KeyManagerActor . FetchUserEphemeralKeyResponse ) obj ; 
 + / / theirEphemeralKey = response . getEphemeralKey ( ) . getPublicKey ( ) ; 
 + / / } 
 + / / onEncrypt ( data , future ) ; 
 + / / } 
 + / / 
 + / / @ Override 
 + / / public void onError ( Exception e ) { 
 + / / future . onError ( e ) ; 
 + / / } 
 + / / } ) ; 
 + / / return ; 
 + / / } 
 + / / 
 + / / if ( chains . size ( ) = = 0 ) { 
 + / / spawnChain ( Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 32 ) ) ) ; 
 + / / } 
 + / / 
 + / / chains . get ( 0 ) . getChain ( ) . send ( new EncryptedSessionChainActor . EncryptMessage ( data , 
 + / / theirEphemeralKey , 0 ) ) ; 
 
 / / if ( ! assumeEnabled ( new Runnable ( ) { 
 / / @ Override 
 @ @ - 233 , 217 + 268 , 75 @ @ public class EncryptedSessionActor extends ModuleActor { 
 } 
 
 private void onDecrypt ( final byte [ ] data , final Future future ) { 
 + if ( isUnavailable ) { 
 + future . onError ( new RuntimeException ( " Encryption session is unavailable " ) ) ; 
 + return ; 
 + } 
 
 - final long start = im . actor . runtime . Runtime . getActorTime ( ) ; 
 - 
 - Log . d ( TAG , " onDecrypt " ) ; 
 - Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 - 
 - final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 - final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 - final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 - final byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 - final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 + / / final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 + / / final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 + / / final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 + final byte [ ] senderEphemeralKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 + final byte [ ] receiverEphemeralKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 
 - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( theirEphermalKey ) , new AskCallback ( ) { 
 - @ Override 
 - public void onResult ( Object obj ) { 
 - final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; 
 - Log . d ( TAG , " Before plain text in " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; 
 - 
 - byte [ ] rc = RatchetRootChainKey . makeRootChainKey ( 
 - new RatchetPrivateKey ( theirEphermalKey . getPrivateKey ( ) ) , 
 - new RatchetPublicKey ( ownEphermalKey ) , 
 - masterKey ) ; 
 - 
 - Log . d ( TAG , " Before plain text 2 in " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; 
 - 
 - ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , messageIndex ) ; 
 + EncryptedSessionChain pickedChain = null ; 
 + for ( EncryptedSessionChain c : chains ) { 
 + if ( ByteStrings . isEquals ( Curve25519 . keyGenPublic ( c . getOwnPrivateKey ( ) ) , receiverEphemeralKey ) ) { 
 + pickedChain = c ; 
 + break ; 
 + } 
 + } 
 
 - Log . d ( TAG , " Before plain text 3 in " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; 
 + if ( pickedChain = = null ) { 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( receiverEphemeralKey ) , new AskCallback ( ) { 
 
 - byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; 
 - byte [ ] pkg = ByteStrings . substring ( data , 88 , data . length - 88 ) ; 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; 
 + spawnChain ( theirEphermalKey . getPrivateKey ( ) , senderEphemeralKey ) ; 
 + onDecrypt ( data , future ) ; 
 + } 
 
 - byte [ ] plainText ; 
 - try { 
 - plainText = ActorBox . openBox ( header , pkg , ratchetMessageKey ) ; 
 - Log . d ( TAG , " Plain Text in " + ( im . actor . runtime . Runtime . getActorTime ( ) - start ) + " ms " ) ; 
 - } catch ( IntegrityException e ) { 
 - Log . d ( TAG , " Plain Text error " ) ; 
 - e . printStackTrace ( ) ; 
 + @ Override 
 + public void onError ( Exception e ) { 
 future . onError ( e ) ; 
 - return ; 
 } 
 + } ) ; 
 + return ; 
 + } 
 
 - future . onResult ( new DecryptedPackage ( plainText ) ) ; 
 - } 
 - 
 - @ Override 
 - public void onError ( Exception e ) { 
 - Log . d ( TAG , " onDecrypt : onResultEphermal : onError " ) ; 
 - future . onError ( e ) ; 
 - } 
 - } ) ; 
 - 
 - 
 - / / ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , index ) ; 
 - / / 
 - / / Log . d ( TAG , " MS : " + Hex . toHex ( ms ) ) ; 
 - / / Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; 
 - / / Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey0 ) ) ) ; 
 - / / Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; 
 - / / Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphemeralKey0 ) ) ; 
 - / / 
 - / / Log . d ( TAG , " RC : " + Hex . toHex ( rc ) ) ; 
 - / / Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey ) ) ) ; 
 - / / Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphemeralKey ) ) ; 
 - / / 
 - / / Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; 
 - / / Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; 
 - / / Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; 
 - / / Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; 
 - / / 
 - / / byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; 
 - / / byte [ ] pkg = ByteStrings . substring ( data , 88 , data . length - 88 ) ; 
 - / / 
 - / / byte [ ] plainText ; 
 - / / try { 
 - / / plainText = ActorBox . openBox ( header , pkg , ratchetMessageKey ) ; 
 - / / Log . d ( TAG , " Plain Text " ) ; 
 - / / } catch ( IntegrityException e ) { 
 - / / Log . d ( TAG , " Plain Text error " ) ; 
 - / / e . printStackTrace ( ) ; 
 - / / future . onError ( e ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / future . onResult ( new DecryptedPackage ( plainText ) ) ; 
 - 
 + try { 
 + future . onResult ( new DecryptedPackage ( pickedChain . decrypt ( data ) ) ) ; 
 + } catch ( IntegrityException e ) { 
 + e . printStackTrace ( ) ; 
 + future . onError ( e ) ; 
 + } 
 
 - / / 
 - / / / / Log . d ( TAG , " onDecrypt : Own " + Hex . toHex ( ownEphermalKey ) ) ; 
 - / / / / Log . d ( TAG , " onDecrypt : Their " + Hex . toHex ( theirEphermalKey ) ) ; 
 - / / 
 - / / Log . d ( TAG , " ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 - / / Log . d ( TAG , " theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 - / / 
 - / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( theirEphermalKey ) , new AskCallback ( ) { 
 + / / ask ( pickedChain . getChain ( ) , new EncryptedSessionChainActor . DecryptMessage ( 
 + / / ByteStrings . substring ( data , 0 , 88 ) , 
 + / / ByteStrings . substring ( data , 88 , data . length - 88 ) , 
 + / / senderEphemeralKey , messageIndex ) , new AskCallback ( ) { 
 / / @ Override 
 / / public void onResult ( Object obj ) { 
 - / / final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; 
 - / / 
 - / / ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKeyById ( theirEphermalKey0Id ) , 
 - / / new AskCallback ( ) { 
 - / / @ Override 
 - / / public void onResult ( Object obj ) { 
 - / / 
 - / / final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey0 
 - / / = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; 
 - / / 
 - / / Log . d ( TAG , " theirEphermalKey0 : " + Hex . toHex ( Curve25519 . keyGenPublic ( theirEphermalKey0 . getPrivateKey ( ) ) ) ) ; 
 - / / 
 - / / ArrayList < Long > keys = new ArrayList < Long > ( ) ; 
 - / / keys . add ( ownEphermalKey0Id ) ; 
 - / / request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 - / / @ Override 
 - / / public void onResult ( ResponsePublicKeys response ) { 
 - / / byte [ ] ownEphermalKey0 = response . getPublicKey ( ) . get ( 0 ) . getKeyMaterial ( ) ; 
 - / / Log . d ( TAG , " ownEphermalKey0 : " + Hex . toHex ( ownEphermalKey0 ) ) ; 
 - / / onDecrypt ( data , 
 - / / ownEphermalKey0 , 
 - / / ownEphermalKey , 
 - / / theirEphermalKey0 . getPrivateKey ( ) , 
 - / / theirEphermalKey . getPrivateKey ( ) , 
 - / / messageIndex , 
 - / / future ) ; 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( RpcException e ) { 
 - / / Log . d ( TAG , " onDecrypt : RequestLoadPublicKey : onError " ) ; 
 - / / future . onError ( e ) ; 
 - / / } 
 - / / } ) ; 
 - / / 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( Exception e ) { 
 - / / Log . d ( TAG , " onDecrypt : onResultPrivate : onError " ) ; 
 - / / future . onError ( e ) ; 
 - / / } 
 - / / } ) ; 
 + / / / / Updating ephemeral key 
 + / / theirEphemeralKey = senderEphemeralKey ; 
 + / / future . onResult ( ) ; 
 / / } 
 / / 
 / / @ Override 
 / / public void onError ( Exception e ) { 
 - / / Log . d ( TAG , " onDecrypt : onResultEphermal : onError " ) ; 
 / / future . onError ( e ) ; 
 / / } 
 / / } ) ; 
 - 
 - / / future . onResult ( ) ; 
 } 
 
 - private void onDecrypt ( byte [ ] data , 
 - byte [ ] theirEphemeralKey0 , 
 - byte [ ] theirEphemeralKey , 
 - byte [ ] ownEphemeralPrivateKey0 , 
 - byte [ ] ownEphemeralPrivateKey , 
 - int index , 
 - Future future ) { 
 - 
 - Log . d ( TAG , " onDecrypt2 " ) ; 
 - 
 - / / byte [ ] ms = RatchetMasterSecret . calculateMasterSecret ( 
 - / / new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 - / / new RatchetPrivateKey ( ownEphemeralPrivateKey0 ) , 
 - / / new RatchetPublicKey ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) , 
 - / / new RatchetPublicKey ( theirEphemeralKey0 ) ) ; 
 - / / 
 - / / byte [ ] rc = RatchetRootChainKey . makeRootChainKey ( 
 - / / new RatchetPrivateKey ( ownEphemeralPrivateKey ) , 
 - / / new RatchetPublicKey ( theirEphemeralKey ) , 
 - / / ms ) ; 
 - / / 
 - / / ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , index ) ; 
 - / / 
 - / / Log . d ( TAG , " MS : " + Hex . toHex ( ms ) ) ; 
 - / / Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; 
 - / / Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey0 ) ) ) ; 
 - / / Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; 
 - / / Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphemeralKey0 ) ) ; 
 - / / 
 - / / Log . d ( TAG , " RC : " + Hex . toHex ( rc ) ) ; 
 - / / Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey ) ) ) ; 
 - / / Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphemeralKey ) ) ; 
 - / / 
 - / / Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; 
 - / / Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; 
 - / / Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; 
 - / / Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; 
 - / / 
 - / / byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; 
 - / / byte [ ] pkg = ByteStrings . substring ( data , 88 , data . length - 88 ) ; 
 - / / 
 - / / byte [ ] plainText ; 
 - / / try { 
 - / / plainText = ActorBox . openBox ( header , pkg , ratchetMessageKey ) ; 
 - / / Log . d ( TAG , " Plain Text " ) ; 
 - / / } catch ( IntegrityException e ) { 
 - / / Log . d ( TAG , " Plain Text error " ) ; 
 - / / e . printStackTrace ( ) ; 
 - / / future . onError ( e ) ; 
 - / / return ; 
 - / / } 
 - / / 
 - / / future . onResult ( new DecryptedPackage ( plainText ) ) ; 
 + private EncryptedSessionChain spawnChain ( final byte [ ] privateKey , final byte [ ] publicKey ) { 
 + EncryptedSessionChain chain = new EncryptedSessionChain ( session , privateKey , publicKey ) ; 
 + chains . add ( 0 , chain ) ; 
 + return chain ; 
 } 
 
 - 
 - 
 @ Override 
 public boolean onAsk ( Object message , Future future ) { 
 Log . d ( TAG , " onAsk " ) ; 
 @ @ - 509 , 4 + 402 , 5 @ @ public class EncryptedSessionActor extends ModuleActor { 
 return data ; 
 } 
 } 
 + 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionChainActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionChainActor . java 
 deleted file mode 100644 
 index ba382ab . . 0000000 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionChainActor . java 
 + + + / dev / null 
 @ @ - 1 , 95 + 0 , 0 @ @ 
 - package im . actor . core . modules . encryption ; 
 - 
 - import im . actor . core . modules . ModuleContext ; 
 - import im . actor . core . modules . encryption . entity . OwnPrivateKey ; 
 - import im . actor . core . util . ModuleActor ; 
 - import im . actor . runtime . Log ; 
 - import im . actor . runtime . actors . Future ; 
 - import im . actor . runtime . crypto . IntegrityException ; 
 - import im . actor . runtime . crypto . box . ActorBox ; 
 - import im . actor . runtime . crypto . box . ActorBoxKey ; 
 - import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; 
 - import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; 
 - import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; 
 - import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; 
 - 
 - public class EncryptedSessionChainActor extends ModuleActor { 
 - 
 - private static final String TAG = " EncryptedSessionChainActor " ; 
 - 
 - private byte [ ] masterKey ; 
 - private OwnPrivateKey chainOwnPrivateKey ; 
 - 
 - public EncryptedSessionChainActor ( byte [ ] masterKey , 
 - OwnPrivateKey chainOwnPrivateKey , 
 - ModuleContext context ) { 
 - super ( context ) ; 
 - 
 - this . masterKey = masterKey ; 
 - this . chainOwnPrivateKey = chainOwnPrivateKey ; 
 - } 
 - 
 - private void onDecrypt ( byte [ ] header , byte [ ] cipherText , byte [ ] senderPublicKey , int messageIndex , 
 - Future future ) { 
 - 
 - byte [ ] rc = RatchetRootChainKey . makeRootChainKey ( 
 - new RatchetPrivateKey ( chainOwnPrivateKey . getKey ( ) ) , 
 - new RatchetPublicKey ( senderPublicKey ) , 
 - masterKey ) ; 
 - 
 - ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , messageIndex ) ; 
 - 
 - byte [ ] plainText ; 
 - try { 
 - plainText = ActorBox . openBox ( header , cipherText , ratchetMessageKey ) ; 
 - Log . d ( TAG , " Plain Text " ) ; 
 - } catch ( IntegrityException e ) { 
 - Log . d ( TAG , " Plain Text error " ) ; 
 - e . printStackTrace ( ) ; 
 - future . onError ( e ) ; 
 - return ; 
 - } 
 - } 
 - 
 - @ Override 
 - public boolean onAsk ( Object message , Future future ) { 
 - if ( message instanceof DecryptMessage ) { 
 - DecryptMessage decryptMessage = ( DecryptMessage ) message ; 
 - onDecrypt ( decryptMessage . getHeader ( ) , decryptMessage . getCipherText ( ) , 
 - decryptMessage . getSenderPublicKey ( ) , decryptMessage . getMessageIndex ( ) , future ) ; 
 - return false ; 
 - } 
 - return super . onAsk ( message , future ) ; 
 - } 
 - 
 - public static class DecryptMessage { 
 - 
 - private byte [ ] header ; 
 - private byte [ ] cipherText ; 
 - private byte [ ] senderPublicKey ; 
 - private int messageIndex ; 
 - 
 - public DecryptMessage ( byte [ ] header , byte [ ] cipherText , byte [ ] senderPublicKey , int messageIndex ) { 
 - this . header = header ; 
 - this . cipherText = cipherText ; 
 - this . senderPublicKey = senderPublicKey ; 
 - this . messageIndex = messageIndex ; 
 - } 
 - 
 - public byte [ ] getHeader ( ) { 
 - return header ; 
 - } 
 - 
 - public byte [ ] getCipherText ( ) { 
 - return cipherText ; 
 - } 
 - 
 - public byte [ ] getSenderPublicKey ( ) { 
 - return senderPublicKey ; 
 - } 
 - 
 - public int getMessageIndex ( ) { 
 - return messageIndex ; 
 - } 
 - } 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java 
 new file mode 100644 
 index 0000000 . . abc6f07 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyLocation . java 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + package im . actor . core . modules . encryption ; 
 + 
 + public class KeyLocation { 
 + 
 + private int uid ; 
 + private int keyGroup ; 
 + private long keyId ; 
 + 
 + public KeyLocation ( int uid , int keyGroup , long keyId ) { 
 + this . uid = uid ; 
 + this . keyGroup = keyGroup ; 
 + this . keyId = keyId ; 
 + } 
 + 
 + public int getUid ( ) { 
 + return uid ; 
 + } 
 + 
 + public int getKeyGroup ( ) { 
 + return keyGroup ; 
 + } 
 + 
 + public long getKeyId ( ) { 
 + return keyId ; 
 + } 
 + } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index 3fcd062 . . 9eb0796 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 375 , 6 + 375 , 36 @ @ public class KeyManagerActor extends ModuleActor { 
 / / } ) ; 
 } 
 
 + private void fetchUserEphemeralKey ( final int uid , int keyGroupId , final Future future ) { 
 + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , keyGroupId ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + @ Override 
 + public void onResult ( ResponsePublicKeys response ) { 
 + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 + Log . w ( TAG , " Public key error " ) ; 
 + future . onError ( new RuntimeException ( ) ) ; 
 + return ; 
 + } 
 + ApiEncryptionKey key = response . getPublicKey ( ) . get ( 0 ) ; 
 + 
 + / / TODO : Verify signature 
 + 
 + UserPublicKey pkey = new UserPublicKey ( key . getKeyId ( ) , key . getKeyAlg ( ) , key . getKeyMaterial ( ) ) ; 
 + / / UserKeysGroup userKeysGroup = finalKeysGroup . addUserKeyGroup ( pkey ) ; 
 + / / cacheUserKeys ( keys . removeUserKeyGroup ( userKeysGroup . getKeyGroupId ( ) ) 
 + / / . addUserKeyGroup ( userKeysGroup ) ) ; 
 + 
 + future . onResult ( new FetchUserEphemeralKeyResponse ( pkey ) ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( RpcException e ) { 
 + Log . w ( TAG , " Public key error " ) ; 
 + Log . e ( TAG , e ) ; 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 private void onPublicKeysGroupAdded ( int uid , ApiEncryptionKeyGroup keyGroup ) { 
 UserKeys userKeys = getCachedUserKeys ( uid ) ; 
 if ( userKeys = = null ) { 
 @ @ - 514 , 6 + 544 , 9 @ @ public class KeyManagerActor extends ModuleActor { 
 } else if ( message instanceof FetchUserEphemeralKey ) { 
 fetchUserEphemeralKey ( ( ( FetchUserEphemeralKey ) message ) . getUid ( ) , ( ( FetchUserEphemeralKey ) message ) . getKeyGroup ( ) , ( ( FetchUserEphemeralKey ) message ) . getKeyId ( ) , future ) ; 
 return false ; 
 + } else if ( message instanceof FetchUserEphemeralKeyRandom ) { 
 + fetchUserEphemeralKey ( ( ( FetchUserEphemeralKeyRandom ) message ) . getUid ( ) , ( ( FetchUserEphemeralKeyRandom ) message ) . getKeyGroup ( ) , future ) ; 
 + return false ; 
 } 
 return super . onAsk ( message , future ) ; 
 } 
 @ @ - 639 , 6 + 672 , 25 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 } 
 
 + public static class FetchUserEphemeralKeyRandom { 
 + 
 + private int uid ; 
 + private int keyGroup ; 
 + 
 + public FetchUserEphemeralKeyRandom ( int uid , int keyGroup ) { 
 + this . keyGroup = keyGroup ; 
 + this . uid = uid ; 
 + } 
 + 
 + public int getUid ( ) { 
 + return uid ; 
 + } 
 + 
 + public int getKeyGroup ( ) { 
 + return keyGroup ; 
 + } 
 + } 
 + 
 public static class FetchUserEphemeralKeyResponse { 
 private UserPublicKey ephemeralKey ; 
 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSession . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSession . java 
 new file mode 100644 
 index 0000000 . . 73e85f9 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSession . java 
 @ @ - 0 , 0 + 1 , 53 @ @ 
 + package im . actor . core . modules . encryption . session ; 
 + 
 + import im . actor . core . modules . encryption . entity . OwnPrivateKey ; 
 + import im . actor . core . modules . encryption . entity . UserPublicKey ; 
 + import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; 
 + import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; 
 + import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; 
 + 
 + public class EncryptedSession { 
 + private OwnPrivateKey ownIdentityKey ; 
 + private OwnPrivateKey ownPreKey ; 
 + private UserPublicKey theirIdentityKey ; 
 + private UserPublicKey theirPreKey ; 
 + private int peerKeyGroupId ; 
 + private byte [ ] masterKey ; 
 + 
 + public EncryptedSession ( OwnPrivateKey ownIdentityKey , OwnPrivateKey ownPreKey , UserPublicKey theirIdentityKey , UserPublicKey theirPreKey , int peerKeyGroupId ) { 
 + this . ownIdentityKey = ownIdentityKey ; 
 + this . ownPreKey = ownPreKey ; 
 + this . theirIdentityKey = theirIdentityKey ; 
 + this . theirPreKey = theirPreKey ; 
 + this . peerKeyGroupId = peerKeyGroupId ; 
 + this . masterKey = RatchetMasterSecret . calculateMasterSecret ( 
 + new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 + new RatchetPrivateKey ( ownPreKey . getKey ( ) ) , 
 + new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 + new RatchetPublicKey ( theirPreKey . getPublicKey ( ) ) ) ; 
 + } 
 + 
 + public OwnPrivateKey getOwnIdentityKey ( ) { 
 + return ownIdentityKey ; 
 + } 
 + 
 + public OwnPrivateKey getOwnPreKey ( ) { 
 + return ownPreKey ; 
 + } 
 + 
 + public UserPublicKey getTheirIdentityKey ( ) { 
 + return theirIdentityKey ; 
 + } 
 + 
 + public UserPublicKey getTheirPreKey ( ) { 
 + return theirPreKey ; 
 + } 
 + 
 + public int getPeerKeyGroupId ( ) { 
 + return peerKeyGroupId ; 
 + } 
 + 
 + public byte [ ] getMasterKey ( ) { 
 + return masterKey ; 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 new file mode 100644 
 index 0000000 . . a7167eb 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 @ @ - 0 , 0 + 1 , 93 @ @ 
 + package im . actor . core . modules . encryption . session ; 
 + 
 + import java . util . HashSet ; 
 + 
 + import im . actor . runtime . crypto . IntegrityException ; 
 + import im . actor . runtime . crypto . box . ActorBox ; 
 + import im . actor . runtime . crypto . box . ActorBoxKey ; 
 + import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 + import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; 
 + import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; 
 + import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; 
 + import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; 
 + 
 + public class EncryptedSessionChain { 
 + 
 + private EncryptedSession session ; 
 + private byte [ ] ownPrivateKey ; 
 + private byte [ ] theirPublicKey ; 
 + private HashSet < Integer > receivedCounters ; 
 + private int sentCounter ; 
 + private byte [ ] rootChainKey ; 
 + 
 + public EncryptedSessionChain ( EncryptedSession session , byte [ ] ownPrivateKey , byte [ ] theirPublicKey ) { 
 + this . session = session ; 
 + this . ownPrivateKey = ownPrivateKey ; 
 + this . theirPublicKey = theirPublicKey ; 
 + this . receivedCounters = new HashSet < Integer > ( ) ; 
 + this . sentCounter = 0 ; 
 + this . rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 + new RatchetPrivateKey ( ownPrivateKey ) , 
 + new RatchetPublicKey ( theirPublicKey ) , 
 + session . getMasterKey ( ) ) ; 
 + } 
 + 
 + public EncryptedSession getSession ( ) { 
 + return session ; 
 + } 
 + 
 + public byte [ ] getOwnPrivateKey ( ) { 
 + return ownPrivateKey ; 
 + } 
 + 
 + public byte [ ] getTheirPublicKey ( ) { 
 + return theirPublicKey ; 
 + } 
 + 
 + public byte [ ] decrypt ( byte [ ] data ) throws IntegrityException { 
 + 
 + if ( data . length < 88 ) { 
 + throw new IntegrityException ( " Data length is too small " ) ; 
 + } 
 + 
 + / / 
 + / / Parsing message header 
 + / / 
 + 
 + final int senderKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 + final long senderEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 + final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 + final byte [ ] senderEphemeralKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 + final byte [ ] receiverEphemeralKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 + final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 + 
 + / / 
 + / / Validating header 
 + / / 
 + 
 + / / if ( senderKeyGroupId ! = session . getPeerKeyGroupId ( ) ) { 
 + / / throw new IntegrityException ( " Incorrect sender key group id " ) ; 
 + / / } 
 + / / if ( senderEphermalKey0Id ! = session . getTheirPreKey ( ) . getKeyId ( ) ) { 
 + / / throw new IntegrityException ( " Incorrect sender pre key id " ) ; 
 + / / } 
 + / / if ( receiverEphermalKey0Id ! = session . getOwnPreKey ( ) . getKeyId ( ) ) { 
 + / / throw new IntegrityException ( " Incorrect receiver pre key id " ) ; 
 + / / } 
 + / / if ( ByteStrings . isEquals ( senderEphemeralKey , theirPublicKey ) ) { 
 + / / throw new IntegrityException ( " Incorrect sender ephemeral key " ) ; 
 + / / } 
 + / / if ( ByteStrings . isEquals ( receiverEphemeralKey , ownPrivateKey ) ) { 
 + / / throw new IntegrityException ( " Incorrect receiver ephemeral key " ) ; 
 + / / } 
 + 
 + / / 
 + / / Decryption 
 + / / 
 + 
 + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; 
 + byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; 
 + byte [ ] message = ByteStrings . substring ( data , 88 , data . length - 88 ) ; 
 + return ActorBox . openBox ( header , message , ratchetMessageKey ) ; 
 + } 
 + } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionStorage . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionStorage . java 
 new file mode 100644 
 index 0000000 . . 0d805dd 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionStorage . java 
 @ @ - 0 , 0 + 1 , 5 @ @ 
 + package im . actor . core . modules . encryption . session ; 
 + 
 + public class EncryptedSessionStorage { 
 + 
 + } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / entity / DialogDesc . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / entity / DialogDesc . java 
 new file mode 100644 
 index 0000000 . . bb8078b 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / entity / DialogDesc . java 
 @ @ - 0 , 0 + 1 , 80 @ @ 
 + package im . actor . core . entity ; 
 + 
 + import com . google . j2objc . annotations . Property ; 
 + 
 + import java . io . IOException ; 
 + 
 + import im . actor . runtime . bser . BserObject ; 
 + import im . actor . runtime . bser . BserValues ; 
 + import im . actor . runtime . bser . BserWriter ; 
 + import im . actor . runtime . storage . KeyValueItem ; 
 + 
 + public class DialogDesc extends BserObject implements KeyValueItem { 
 + 
 + @ Property ( " readonly , nonatomic " ) 
 + private Peer peer ; 
 + @ Property ( " readonly , nonatomic " ) 
 + private String title ; 
 + @ Property ( " readonly , nonatomic " ) 
 + private Avatar avatar ; 
 + @ Property ( " readonly , nonatomic " ) 
 + private boolean isUnread ; 
 + @ Property ( " readonly , nonatomic " ) 
 + private int counter ; 
 + 
 + public DialogDesc ( Peer peer , String title , Avatar avatar , boolean isUnread , int counter ) { 
 + this . peer = peer ; 
 + this . title = title ; 
 + this . avatar = avatar ; 
 + this . isUnread = isUnread ; 
 + this . counter = counter ; 
 + } 
 + 
 + public Peer getPeer ( ) { 
 + return peer ; 
 + } 
 + 
 + public String getTitle ( ) { 
 + return title ; 
 + } 
 + 
 + public Avatar getAvatar ( ) { 
 + return avatar ; 
 + } 
 + 
 + public int getCounter ( ) { 
 + return counter ; 
 + } 
 + 
 + public boolean isUnread ( ) { 
 + return isUnread ; 
 + } 
 + 
 + @ Override 
 + public void parse ( BserValues values ) throws IOException { 
 + peer = Peer . fromBytes ( values . getBytes ( 1 ) ) ; 
 + title = values . getString ( 2 ) ; 
 + byte [ ] av = values . getBytes ( 3 ) ; 
 + if ( av ! = null ) { 
 + avatar = new Avatar ( av ) ; 
 + } 
 + counter = values . getInt ( 4 ) ; 
 + isUnread = values . getBool ( 5 ) ; 
 + } 
 + 
 + @ Override 
 + public void serialize ( BserWriter writer ) throws IOException { 
 + writer . writeObject ( 1 , peer ) ; 
 + writer . writeString ( 2 , title ) ; 
 + if ( avatar ! = null ) { 
 + writer . writeObject ( 3 , avatar ) ; 
 + } 
 + writer . writeInt ( 4 , counter ) ; 
 + writer . writeBool ( 5 , isUnread ) ; 
 + } 
 + 
 + @ Override 
 + public long getEngineId ( ) { 
 + return peer . getUnuqueId ( ) ; 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / MessagesModule . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / MessagesModule . java 
 index 85714e6 . . 30e0d85 100644 
 - - - a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / MessagesModule . java 
 + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / MessagesModule . java 
 @ @ - 35 , 6 + 35 , 7 @ @ import im . actor . core . modules . internal . messages . CursorReaderActor ; 
 import im . actor . core . modules . internal . messages . CursorReceiverActor ; 
 import im . actor . core . modules . internal . messages . DialogsActor ; 
 import im . actor . core . modules . internal . messages . DialogsHistoryActor ; 
 + import im . actor . core . modules . internal . messages . GroupedDialogsActor ; 
 import im . actor . core . modules . internal . messages . MessageDeleteActor ; 
 import im . actor . core . modules . internal . messages . MessageShownActor ; 
 import im . actor . core . modules . internal . messages . MessageShownFilter ; 
 @ @ - 46 , 6 + 47 , 7 @ @ import im . actor . core . network . RpcException ; 
 import im . actor . core . network . RpcInternalException ; 
 import im . actor . core . viewmodel . Command ; 
 import im . actor . core . viewmodel . CommandCallback ; 
 + import im . actor . core . viewmodel . DialogGroupsVM ; 
 import im . actor . runtime . Storage ; 
 import im . actor . runtime . actors . ActorCreator ; 
 import im . actor . runtime . actors . ActorRef ; 
 @ @ - 62 , 8 + 64 , 10 @ @ import static im . actor . runtime . actors . ActorSystem . system ; 
 public class MessagesModule extends AbsModule implements BusSubscriber { 
 
 private ListEngine < Dialog > dialogs ; 
 + 
 private ActorRef dialogsActor ; 
 private ActorRef dialogsHistoryActor ; 
 + private ActorRef dialogsGroupedActor ; 
 private ActorRef ownReadActor ; 
 private ActorRef plainReadActor ; 
 private ActorRef plainReceiverActor ; 
 @ @ - 79 , 6 + 83 , 8 @ @ public class MessagesModule extends AbsModule implements BusSubscriber { 
 
 private final SyncKeyValue cursorStorage ; 
 
 + private final DialogGroupsVM dialogGroups = new DialogGroupsVM ( ) ; 
 + 
 public MessagesModule ( final ModuleContext context ) { 
 super ( context ) ; 
 
 @ @ - 99 , 6 + 105 , 14 @ @ public class MessagesModule extends AbsModule implements BusSubscriber { 
 return new DialogsHistoryActor ( context ( ) ) ; 
 } 
 } ) , " actor / dialogs / history " ) ; 
 + 
 + this . dialogsGroupedActor = system ( ) . actorOf ( Props . create ( GroupedDialogsActor . class , new ActorCreator < GroupedDialogsActor > ( ) { 
 + @ Override 
 + public GroupedDialogsActor create ( ) { 
 + return new GroupedDialogsActor ( context ( ) ) ; 
 + } 
 + } ) , " actor / dialogs / grouped " ) ; 
 + 
 this . ownReadActor = system ( ) . actorOf ( Props . create ( OwnReadActor . class , new ActorCreator < OwnReadActor > ( ) { 
 @ Override 
 public OwnReadActor create ( ) { 
 @ @ - 139 , 6 + 153 , 10 @ @ public class MessagesModule extends AbsModule implements BusSubscriber { 
 context ( ) . getEvents ( ) . subscribe ( this , PeerChatOpened . EVENT ) ; 
 } 
 
 + public DialogGroupsVM getDialogGroupsVM ( ) { 
 + return dialogGroups ; 
 + } 
 + 
 public ActorRef getSendMessageActor ( ) { 
 return sendMessageActor ; 
 } 
 @ @ - 221 , 6 + 239 , 10 @ @ public class MessagesModule extends AbsModule implements BusSubscriber { 
 return dialogsHistoryActor ; 
 } 
 
 + public ActorRef getDialogsGroupedActor ( ) { 
 + return dialogsGroupedActor ; 
 + } 
 + 
 public ListEngine < Dialog > getDialogsEngine ( ) { 
 return dialogs ; 
 } 
 diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / ConversationActor . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / ConversationActor . java 
 index 6641ed9 . . 8bf76dc 100644 
 - - - a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / ConversationActor . java 
 + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / ConversationActor . java 
 @ @ - 44 , 6 + 44 , 7 @ @ public class ConversationActor extends ModuleActor { 
 private IndexStorage outPendingIndex ; 
 private IndexStorage inPendingIndex ; 
 private ActorRef dialogsActor ; 
 + private ActorRef dialogsGroupedActor ; 
 private long inReadState ; 
 private long outReadState ; 
 private long outReceiveState ; 
 @ @ - 62 , 6 + 63 , 7 @ @ public class ConversationActor extends ModuleActor { 
 docs = context ( ) . getMessagesModule ( ) . getConversationDocsEngine ( peer ) ; 
 
 dialogsActor = context ( ) . getMessagesModule ( ) . getDialogsActor ( ) ; 
 + dialogsGroupedActor = context ( ) . getMessagesModule ( ) . getDialogsGroupedActor ( ) ; 
 outPendingIndex = Storage . createIndex ( " out _ pending _ " + peer . getPeerType ( ) + " _ " + peer . getPeerId ( ) ) ; 
 inPendingIndex = Storage . createIndex ( " in _ pending _ " + peer . getPeerType ( ) + " _ " + peer . getPeerId ( ) ) ; 
 
 @ @ - 135 , 6 + 137 , 8 @ @ public class ConversationActor extends ModuleActor { 
 / / Update dialogs 
 if ( topMessage ! = null ) { 
 if ( ! isHiddenPeer ) { 
 + dialogsGroupedActor . send ( new GroupedDialogsActor . NewMessage ( peer , inPendingIndex . getCount ( ) , 
 + topMessage . getSortDate ( ) ) ) ; 
 dialogsActor . send ( new DialogsActor . InMessage ( peer , topMessage , inPendingIndex . getCount ( ) ) ) ; 
 } 
 } 
 @ @ - 185 , 6 + 189 , 8 @ @ public class ConversationActor extends ModuleActor { 
 
 if ( ! isHiddenPeer ) { 
 dialogsActor . send ( new DialogsActor . InMessage ( peer , message , inPendingIndex . getCount ( ) ) ) ; 
 + dialogsGroupedActor . send ( new GroupedDialogsActor . NewMessage ( peer , inPendingIndex . getCount ( ) , 
 + message . getSortDate ( ) ) ) ; 
 } 
 } 
 } 
 @ @ - 239 , 6 + 245 , 8 @ @ public class ConversationActor extends ModuleActor { 
 if ( ! isHiddenPeer ) { 
 / / Updating dialog 
 dialogsActor . send ( new DialogsActor . InMessage ( peer , updatedMsg , inPendingIndex . getCount ( ) ) ) ; 
 + dialogsGroupedActor . send ( new GroupedDialogsActor . NewMessage ( peer , inPendingIndex . getCount ( ) , 
 + updatedMsg . getSortDate ( ) ) ) ; 
 } 
 
 / / Updating pending index 
 @ @ - 361 , 6 + 369 , 7 @ @ public class ConversationActor extends ModuleActor { 
 
 if ( ! isHiddenPeer ) { 
 dialogsActor . send ( new DialogsActor . CounterChanged ( peer , inPendingIndex . getCount ( ) ) ) ; 
 + / / TODO : Implement for grouped 
 } 
 } 
 
 @ @ - 402 , 6 + 411 , 7 @ @ public class ConversationActor extends ModuleActor { 
 inPendingIndex . clear ( ) ; 
 outPendingIndex . clear ( ) ; 
 dialogsActor . send ( new DialogsActor . ChatDelete ( peer ) ) ; 
 + / / TODO : Implement for grouped 
 } 
 
 / / History 
 diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / DialogsActor . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / DialogsActor . java 
 index 311de19 . . b77ac37 100644 
 - - - a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / DialogsActor . java 
 + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / DialogsActor . java 
 @ @ - 50 , 7 + 50 , 7 @ @ public class DialogsActor extends ModuleActor { 
 long start = im . actor . runtime . Runtime . getCurrentTime ( ) ; 
 PeerDesc peerDesc = buildPeerDesc ( peer ) ; 
 if ( peerDesc = = null ) { 
 - Log . d ( " DialogsActor " , " unknown peer desk " ) ; 
 + Log . d ( " DialogsActor " , " unknown peer desc " ) ; 
 return ; 
 } 
 
 @ @ - 75 , 8 + 75 , 11 @ @ public class DialogsActor extends ModuleActor { 
 . setText ( contentDescription . getText ( ) ) 
 . setRelatedUid ( contentDescription . getRelatedUser ( ) ) 
 . setStatus ( message . getMessageState ( ) ) 
 - . setSenderId ( message . getSenderId ( ) ) 
 - . setUnreadCount ( counter ) ; 
 + . setSenderId ( message . getSenderId ( ) ) ; 
 + 
 + if ( counter > = 0 ) { 
 + builder . setUnreadCount ( counter ) ; 
 + } 
 
 boolean forceUpdate = false ; 
 
 diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / GroupedDialogsActor . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / GroupedDialogsActor . java 
 new file mode 100644 
 index 0000000 . . f0fdf00 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / modules / internal / messages / GroupedDialogsActor . java 
 @ @ - 0 , 0 + 1 , 184 @ @ 
 + package im . actor . core . modules . internal . messages ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . HashMap ; 
 + 
 + import im . actor . core . entity . Avatar ; 
 + import im . actor . core . entity . DialogDesc ; 
 + import im . actor . core . entity . Peer ; 
 + import im . actor . core . entity . PeerType ; 
 + import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . utils . ModuleActor ; 
 + import im . actor . core . viewmodel . DialogGroup ; 
 + 
 + public class GroupedDialogsActor extends ModuleActor { 
 + 
 + private PeerGroup groups = new PeerGroup ( " groups " , " Groups " ) ; 
 + private PeerGroup privates = new PeerGroup ( " private " , " Private " ) ; 
 + 
 + public GroupedDialogsActor ( ModuleContext context ) { 
 + super ( context ) ; 
 + } 
 + 
 + @ Override 
 + public void preStart ( ) { 
 + super . preStart ( ) ; 
 + } 
 + 
 + private void onPeerInfoChanged ( Peer peer , String title , Avatar avatar ) { 
 + 
 + } 
 + 
 + private void onNewMessage ( Peer peer , long sortDate , int counter ) { 
 + 
 + PeerGroup peerGroup ; 
 + if ( peer . getPeerType ( ) = = PeerType . GROUP ) { 
 + peerGroup = groups ; 
 + } else if ( peer . getPeerType ( ) = = PeerType . PRIVATE ) { 
 + peerGroup = privates ; 
 + } else { 
 + return ; 
 + } 
 + 
 + boolean found = false ; 
 + for ( PeerDesc d : peerGroup . getPeers ( ) ) { 
 + if ( d . getPeer ( ) . equals ( peer ) ) { 
 + d . setCounter ( counter ) ; 
 + found = true ; 
 + } 
 + } 
 + 
 + if ( ! found ) { 
 + peerGroup . getPeers ( ) . add ( new PeerDesc ( peer , counter ) ) ; 
 + } 
 + 
 + ArrayList < DialogGroup > groups = new ArrayList < DialogGroup > ( ) ; 
 + ArrayList < DialogDesc > groupDescs = new ArrayList < DialogDesc > ( ) ; 
 + for ( PeerDesc d : peerGroup . getPeers ( ) ) { 
 + groupDescs . add ( new DialogDesc ( d . getPeer ( ) , " GRPOUP # " + d . getPeer ( ) . getPeerId ( ) , 
 + null , false , d . counter ) ) ; 
 + } 
 + groups . add ( new DialogGroup ( " Groups " , " group " , groupDescs ) ) ; 
 + 
 + context ( ) . getMessagesModule ( ) . getDialogGroupsVM ( ) . getGroupsValueModel ( ) . change ( groups ) ; 
 + } 
 + 
 + @ Override 
 + public void onReceive ( Object message ) { 
 + if ( message instanceof PeerInformationChanged ) { 
 + PeerInformationChanged informationChanged = ( PeerInformationChanged ) message ; 
 + onPeerInfoChanged ( informationChanged . getPeer ( ) , 
 + informationChanged . getTitle ( ) , 
 + informationChanged . getAvatar ( ) ) ; 
 + } else if ( message instanceof NewMessage ) { 
 + NewMessage newMessage = ( NewMessage ) message ; 
 + onNewMessage ( newMessage . peer , newMessage . sortDate , newMessage . counter ) ; 
 + } else { 
 + super . onReceive ( message ) ; 
 + } 
 + } 
 + 
 + public static class PeerInformationChanged { 
 + 
 + private Peer peer ; 
 + private String title ; 
 + private Avatar avatar ; 
 + 
 + public PeerInformationChanged ( Peer peer , String title , Avatar avatar ) { 
 + this . peer = peer ; 
 + this . title = title ; 
 + this . avatar = avatar ; 
 + } 
 + 
 + public Peer getPeer ( ) { 
 + return peer ; 
 + } 
 + 
 + public String getTitle ( ) { 
 + return title ; 
 + } 
 + 
 + public Avatar getAvatar ( ) { 
 + return avatar ; 
 + } 
 + } 
 + 
 + public static class CounterChanged { 
 + private Peer peer ; 
 + private int counter ; 
 + 
 + public CounterChanged ( Peer peer , int counter ) { 
 + this . peer = peer ; 
 + this . counter = counter ; 
 + } 
 + 
 + public Peer getPeer ( ) { 
 + return peer ; 
 + } 
 + 
 + public int getCounter ( ) { 
 + return counter ; 
 + } 
 + } 
 + 
 + public static class NewMessage { 
 + 
 + private Peer peer ; 
 + private int counter ; 
 + private long sortDate ; 
 + 
 + public NewMessage ( Peer peer , int counter , long sortDate ) { 
 + this . peer = peer ; 
 + this . counter = counter ; 
 + this . sortDate = sortDate ; 
 + } 
 + } 
 + 
 + private class PeerGroup { 
 + 
 + private String key ; 
 + private String title ; 
 + private ArrayList < PeerDesc > peers ; 
 + 
 + public PeerGroup ( String key , String title ) { 
 + this . key = key ; 
 + this . title = title ; 
 + this . peers = new ArrayList < PeerDesc > ( ) ; 
 + } 
 + 
 + public String getKey ( ) { 
 + return key ; 
 + } 
 + 
 + public String getTitle ( ) { 
 + return title ; 
 + } 
 + 
 + public ArrayList < PeerDesc > getPeers ( ) { 
 + return peers ; 
 + } 
 + } 
 + 
 + private class PeerDesc { 
 + 
 + private Peer peer ; 
 + private int counter ; 
 + 
 + public PeerDesc ( Peer peer , int counter ) { 
 + this . peer = peer ; 
 + this . counter = counter ; 
 + } 
 + 
 + public Peer getPeer ( ) { 
 + return peer ; 
 + } 
 + 
 + public int getCounter ( ) { 
 + return counter ; 
 + } 
 + 
 + public void setCounter ( int counter ) { 
 + this . counter = counter ; 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroup . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroup . java 
 new file mode 100644 
 index 0000000 . . ae47f02 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroup . java 
 @ @ - 0 , 0 + 1 , 30 @ @ 
 + package im . actor . core . viewmodel ; 
 + 
 + import java . util . ArrayList ; 
 + 
 + import im . actor . core . entity . DialogDesc ; 
 + 
 + public class DialogGroup { 
 + 
 + private String title ; 
 + private String key ; 
 + private ArrayList < DialogDesc > dialogs ; 
 + 
 + public DialogGroup ( String title , String key , ArrayList < DialogDesc > dialogs ) { 
 + this . title = title ; 
 + this . key = key ; 
 + this . dialogs = dialogs ; 
 + } 
 + 
 + public String getTitle ( ) { 
 + return title ; 
 + } 
 + 
 + public String getKey ( ) { 
 + return key ; 
 + } 
 + 
 + public ArrayList < DialogDesc > getDialogs ( ) { 
 + return dialogs ; 
 + } 
 + } 
 diff - - git a / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroupsVM . java b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroupsVM . java 
 new file mode 100644 
 index 0000000 . . 0a374ba 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / shared / src / main / java / im / actor / core / viewmodel / DialogGroupsVM . java 
 @ @ - 0 , 0 + 1 , 18 @ @ 
 + package im . actor . core . viewmodel ; 
 + 
 + import java . util . ArrayList ; 
 + 
 + import im . actor . runtime . mvvm . ValueModel ; 
 + 
 + public class DialogGroupsVM { 
 + 
 + private ValueModel < ArrayList < DialogGroup > > groupsValueModel ; 
 + 
 + public DialogGroupsVM ( ) { 
 + groupsValueModel = new ValueModel < ArrayList < DialogGroup > > ( " groups . model " , null ) ; 
 + } 
 + 
 + public ValueModel < ArrayList < DialogGroup > > getGroupsValueModel ( ) { 
 + return groupsValueModel ; 
 + } 
 + } 
 diff - - git a / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteKeyValue . java b / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteKeyValue . java 
 index 530cb4b . . 31e2f0e 100644 
 - - - a / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteKeyValue . java 
 + + + b / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteKeyValue . java 
 @ @ - 119 , 21 + 119 , 9 @ @ public class SQLiteKeyValue implements KeyValueStorage { 
 } 
 
 @ Override 
 - public void clear ( ) { 
 - checkSqlite ( ) ; 
 - db . beginTransaction ( ) ; 
 - try { 
 - db . execSQL ( " DELETE FROM \ " " + name + " \ " " ) ; 
 - db . setTransactionSuccessful ( ) ; 
 - } finally { 
 - db . endTransaction ( ) ; 
 - } 
 - } 
 - 
 - @ Override 
 - public byte [ ] getValue ( long id ) { 
 + public byte [ ] loadItem ( long key ) { 
 checkSqlite ( ) ; 
 - Cursor cursor = db . query ( " \ " " + name + " \ " " , new String [ ] { " \ " BYTES \ " " } , " \ " ID \ " = ? " , new String [ ] { " " + id } , null , null , null ) ; 
 + Cursor cursor = db . query ( " \ " " + name + " \ " " , new String [ ] { " \ " BYTES \ " " } , " \ " ID \ " = ? " , new String [ ] { " " + key } , null , null , null ) ; 
 if ( cursor = = null ) { 
 return null ; 
 } 
 @ @ - 146 , 4 + 134 , 26 @ @ public class SQLiteKeyValue implements KeyValueStorage { 
 } 
 return null ; 
 } 
 + 
 + @ Override 
 + public List < KeyValueRecord > loadItems ( long [ ] keys ) { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public List < KeyValueRecord > loadAllItems ( ) { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public void clear ( ) { 
 + checkSqlite ( ) ; 
 + db . beginTransaction ( ) ; 
 + try { 
 + db . execSQL ( " DELETE FROM \ " " + name + " \ " " ) ; 
 + db . setTransactionSuccessful ( ) ; 
 + } finally { 
 + db . endTransaction ( ) ; 
 + } 
 + } 
 } 
 diff - - git a / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteList . java b / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteList . java 
 index b153387 . . 25b59e1 100644 
 - - - a / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteList . java 
 + + + b / actor - sdk / sdk - core / runtime / android / src / main / java / im / actor / runtime / android / storage / SQLiteList . java 
 @ @ - 124 , 6 + 124 , 11 @ @ public class SQLiteList implements ListStorageDisplayEx { 
 return null ; 
 } 
 
 + @ Override 
 + public List < ListEngineRecord > loadAllItems ( ) { 
 + return null ; 
 + } 
 + 
 
 public ListEngineRecord loadItemBySortKey ( long key ) { 
 checkTable ( ) ; 
 diff - - git a / actor - sdk / sdk - core / runtime / shared / src / main / java / im / actor / runtime / storage / KeyValueEngine . java b / actor - sdk / sdk - core / runtime / shared / src / main / java / im / actor / runtime / storage / KeyValueEngine . java 
 index 60239e4 . . c7dd481 100644 
 - - - a / actor - sdk / sdk - core / runtime / shared / src / main / java / im / actor / runtime / storage / KeyValueEngine . java 
 + + + b / actor - sdk / sdk - core / runtime / shared / src / main / java / im / actor / runtime / storage / KeyValueEngine . java 
 @ @ - 9 , 6 + 9 , 7 @ @ import com . google . j2objc . annotations . ObjectiveCName ; 
 import java . util . List ; 
 
 public interface KeyValueEngine < V extends KeyValueItem > { 
 + 
 @ ObjectiveCName ( " addOrUpdateItem : " ) 
 void addOrUpdateItem ( V item ) ; 
 
 diff - - git a / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBKeyValue . swift b / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBKeyValue . swift 
 index fb65f46 . . c22c65a 100644 
 - - - a / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBKeyValue . swift 
 + + + b / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBKeyValue . swift 
 @ @ - 5 , 18 + 5 , 21 @ @ 
 import Foundation 
 
 @ objc class FMDBKeyValue : NSObject , ARKeyValueStorage { 
 - var db : FMDatabase ? ; 
 + 
 + var db : FMDatabase ! 
 
 - let databasePath : String ; 
 - let tableName : String ; 
 + let databasePath : String 
 + let tableName : String 
 
 - let queryCreate : String ; 
 - let queryItem : String ; 
 - let queryAdd : String ; 
 - let queryDelete : String ; 
 - let queryDeleteAll : String ; 
 + let queryCreate : String 
 + let queryItem : String 
 + let queryItems : String 
 + let queryAll : String 
 + let queryAdd : String 
 + let queryDelete : String 
 + let queryDeleteAll : String 
 
 - var isTableChecked : Bool = false ; 
 + var isTableChecked : Bool = false 
 
 init ( databasePath : String , tableName : String ) { 
 self . databasePath = databasePath 
 @ @ - 26 , 11 + 29 , 13 @ @ import Foundation 
 self . queryCreate = " CREATE TABLE IF NOT EXISTS " + tableName + " ( " + 
 " \ " ID \ " INTEGER NOT NULL , " + 
 " \ " BYTES \ " BLOB NOT NULL , " + 
 - " PRIMARY KEY ( \ " ID \ " ) ) ; " ; 
 - self . queryItem = " SELECT \ " BYTES \ " FROM " + tableName + " WHERE \ " ID \ " = ? ; " ; 
 - self . queryAdd = " REPLACE INTO " + tableName + " ( \ " ID \ " , \ " BYTES \ " ) VALUES ( ? , ? ) ; " ; 
 - self . queryDelete = " DELETE FROM " + tableName + " WHERE \ " ID \ " = ? ; " ; 
 - self . queryDeleteAll = " DELETE FROM " + tableName + " ; " ; 
 + " PRIMARY KEY ( \ " ID \ " ) ) ; " 
 + self . queryItem = " SELECT \ " BYTES \ " FROM " + tableName + " WHERE \ " ID \ " = ? ; " 
 + self . queryItems = " SELECT ( \ " ID \ " , \ " BYTES \ " ) FROM " + tableName + " WHERE \ " ID \ " in ? ; " 
 + self . queryAll = " SELECT ( \ " ID \ " , \ " BYTES \ " ) FROM " + tableName + " ; " 
 + self . queryAdd = " REPLACE INTO " + tableName + " ( \ " ID \ " , \ " BYTES \ " ) VALUES ( ? , ? ) ; " 
 + self . queryDelete = " DELETE FROM " + tableName + " WHERE \ " ID \ " = ? ; " 
 + self . queryDeleteAll = " DELETE FROM " + tableName + " ; " 
 
 super . init ( ) 
 } 
 @ @ - 39 , 68 + 44 , 103 @ @ import Foundation 
 if ( isTableChecked ) { 
 return 
 } 
 - isTableChecked = true ; 
 + isTableChecked = true 
 
 self . db = FMDatabase ( path : databasePath ) 
 - self . db ! . open ( ) 
 - if ( ! db ! . tableExists ( tableName ) ) { 
 - db ! . executeUpdate ( queryCreate ) 
 + self . db . open ( ) 
 + if ( ! db . tableExists ( tableName ) ) { 
 + db . executeUpdate ( queryCreate ) 
 } 
 } 
 
 func addOrUpdateItems ( values : JavaUtilList ! ) { 
 - checkTable ( ) ; 
 + checkTable ( ) 
 
 - db ! . beginTransaction ( ) 
 + db . beginTransaction ( ) 
 for i in 0 . . < values . size ( ) { 
 - let record = values . getWithInt ( i ) as ! ARKeyValueRecord ; 
 - db ! . executeUpdate ( queryAdd , record . getId ( ) . toNSNumber ( ) , record . getData ( ) ! . toNSData ( ) ) 
 + let record = values . getWithInt ( i ) as ! ARKeyValueRecord 
 + db . executeUpdate ( queryAdd , record . getId ( ) . toNSNumber ( ) , record . getData ( ) ! . toNSData ( ) ) 
 } 
 - db ! . commit ( ) 
 + db . commit ( ) 
 } 
 
 func addOrUpdateItemWithKey ( key : jlong , withData data : IOSByteArray ! ) { 
 - checkTable ( ) ; 
 + checkTable ( ) 
 
 - db ! . beginTransaction ( ) 
 - db ! . executeUpdate ( queryAdd , key . toNSNumber ( ) , data ! . toNSData ( ) ) 
 - db ! . commit ( ) 
 + db . beginTransaction ( ) 
 + db . executeUpdate ( queryAdd , key . toNSNumber ( ) , data ! . toNSData ( ) ) 
 + db . commit ( ) 
 } 
 
 func removeItemsWithKeys ( keys : IOSLongArray ! ) { 
 - checkTable ( ) ; 
 + checkTable ( ) 
 
 - db ! . beginTransaction ( ) 
 + db . beginTransaction ( ) 
 for i in 0 . . < keys . length ( ) { 
 let key = keys . longAtIndex ( UInt ( i ) ) ; 
 - db ! . executeUpdate ( queryDelete , key . toNSNumber ( ) ) 
 + db . executeUpdate ( queryDelete , key . toNSNumber ( ) ) 
 } 
 - db ! . commit ( ) 
 + db . commit ( ) 
 } 
 
 func removeItemWithKey ( key : jlong ) { 
 - checkTable ( ) ; 
 + checkTable ( ) 
 
 - db ! . beginTransaction ( ) 
 - db ! . executeUpdate ( queryDelete , key . toNSNumber ( ) ) 
 - db ! . commit ( ) 
 + db . beginTransaction ( ) 
 + db . executeUpdate ( queryDelete , key . toNSNumber ( ) ) 
 + db . commit ( ) 
 } 
 
 - func getValueWithKey ( key : jlong ) - > IOSByteArray ! { 
 - checkTable ( ) ; 
 + func loadItemWithKey ( key : jlong ) - > IOSByteArray ! { 
 + checkTable ( ) 
 
 - let result = db ! . dataForQuery ( queryItem , key . toNSNumber ( ) ) ; 
 + let result = db . dataForQuery ( queryItem , key . toNSNumber ( ) ) 
 if ( result = = nil ) { 
 - return nil ; 
 + return nil 
 + } 
 + return result . toJavaBytes ( ) 
 + } 
 + 
 + func loadAllItems ( ) - > JavaUtilList ! { 
 + checkTable ( ) 
 + 
 + let res = JavaUtilArrayList ( ) 
 + 
 + if let result = db . executeQuery ( queryAll ) { 
 + while ( result . next ( ) ) { 
 + res . addWithId ( ARKeyValueRecord ( key : jlong ( result . longLongIntForColumn ( " ID " ) ) , withData : result . dataForColumn ( " BYTES " ) . toJavaBytes ( ) ) ) 
 + } 
 + } 
 + 
 + return res 
 + } 
 + 
 + func loadItems ( keys : IOSLongArray ! ) - > JavaUtilList ! { 
 + checkTable ( ) 
 + 
 + / / Converting to NSNumbers 
 + var ids = [ NSNumber ] ( ) 
 + for i in 0 . . < keys . length ( ) { 
 + ids . append ( keys . longAtIndex ( UInt ( i ) ) . toNSNumber ( ) ) 
 } 
 - return result . toJavaBytes ( ) ; 
 + 
 + let res = JavaUtilArrayList ( ) 
 + 
 + if let result = db . executeQuery ( queryItems , ids ) { 
 + while ( result . next ( ) ) { 
 + / / TODO : Optimize lookup 
 + res . addWithId ( ARKeyValueRecord ( key : jlong ( result . longLongIntForColumn ( " ID " ) ) , withData : result . dataForColumn ( " BYTES " ) . toJavaBytes ( ) ) ) 
 + } 
 + } 
 + 
 + return res 
 } 
 
 func clear ( ) { 
 - checkTable ( ) ; 
 + checkTable ( ) 
 
 - db ! . beginTransaction ( ) 
 - db ! . executeUpdate ( queryDeleteAll ) ; 
 - db ! . commit ( ) 
 + db . beginTransaction ( ) 
 + db . executeUpdate ( queryDeleteAll ) 
 + db . commit ( ) 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBList . swift b / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBList . swift 
 index 27ac7e7 . . 209a6e3 100644 
 - - - a / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBList . swift 
 + + + b / actor - sdk / sdk - ios / ActorSDK / Sources / ActorCore / Providers / Storage / FMDBList . swift 
 @ @ - 199 , 6 + 199 , 12 @ @ class FMDBList : NSObject , ARListStorageDisplayEx { 
 } 
 } 
 
 + func loadAllItems ( ) - > JavaUtilList ! { 
 + let res = JavaUtilArrayList ( ) 
 + / / TODO : Implement 
 + return res 
 + } 
 + 
 func loadForwardWithSortKey ( sortingKey : JavaLangLong ! , withLimit limit : jint ) - > JavaUtilList ! { 
 checkTable ( ) ; 
 var result : FMResultSet ? = nil ;
