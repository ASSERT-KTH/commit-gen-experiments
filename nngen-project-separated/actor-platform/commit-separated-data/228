BLEU SCORE: 0.08606119900909884

TEST MSG: fix ( server : test ) : http api frontend spec
GENERATED MSG: feat ( http - api ) : route for serving static files

TEST DIFF (one line): diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala < nl > index 633dfd0 . . 2356c42 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala < nl > @ @ - 2 , 15 + 2 , 6 @ @ package im . actor . server . api . http < nl > < nl > import java . nio . file . { Files , Paths } < nl > < nl > - import akka . http . scaladsl . Http < nl > - import akka . http . scaladsl . model . HttpMethods . { DELETE , GET , POST } < nl > - import akka . http . scaladsl . model . StatusCodes . _ < nl > - import akka . http . scaladsl . model . _ < nl > - import akka . http . scaladsl . unmarshalling . PredefinedFromEntityUnmarshallers . _ < nl > - import akka . http . scaladsl . unmarshalling . _ < nl > - import akka . stream . scaladsl . Sink < nl > - import akka . util . ByteString < nl > - import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport < nl > import im . actor . api . rpc . { AuthData , ClientData } < nl > import im . actor . server . _ < nl > import im . actor . server . acl . ACLUtils < nl > @ @ - 18 , 11 + 9 , 17 @ @ import im . actor . server . api . http . json . JsonFormatters . _ < nl > import im . actor . server . api . http . json . { AvatarUrls , _ } < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . api . rpc . service . messaging < nl > - import im . actor . server . file . { UnsafeFileName , FileStorageExtension , ImageUtils } < nl > + import im . actor . server . file . { FileStorageExtension , ImageUtils , UnsafeFileName } < nl > import im . actor . server . webhooks . WebhooksExtension < nl > import im . actor . server . webhooks . http . routes . OutgoingHooksErrors < nl > import im . actor . util . ThreadLocalSecureRandom < nl > import play . api . libs . json . _ < nl > + import spray . client . pipelining . _ < nl > + import spray . http . HttpMethods . { DELETE , GET , POST } < nl > + import spray . http . StatusCodes . _ < nl > + import spray . http . { HttpRequest , StatusCodes } < nl > + import spray . httpx . PlayJsonSupport < nl > + import spray . httpx . unmarshalling . _ < nl > < nl > final class HttpApiFrontendSpec < nl > extends BaseAppSuite < nl > @ @ - 81 , 19 + 78 , 7 @ @ final class HttpApiFrontendSpec < nl > < nl > WebhooksExtension ( system ) / / initialize webhooks routes < nl > < nl > - implicit val reverseHookResponseUnmarshaller : FromEntityUnmarshaller [ ReverseHookResponse ] = Unmarshaller { implicit ec ⇒ entity ⇒ < nl > - Unmarshal ( entity ) . to [ String ] . map { body ⇒ < nl > - Json . parse ( body ) . as [ ReverseHookResponse ] < nl > - } < nl > - } < nl > - < nl > - implicit val statusUnmarshaller : FromEntityUnmarshaller [ Status ] = Unmarshaller { implicit ec ⇒ entity ⇒ < nl > - Unmarshal ( entity ) . to [ String ] . map { body ⇒ < nl > - Json . parse ( body ) . as [ Status ] < nl > - } < nl > - } < nl > - < nl > - val s3BucketName = " actor - uploads - test " < nl > + val singleRequest = sendReceive < nl > < nl > object t { < nl > val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) < nl > @ @ - 106 , 11 + 91 , 10 @ @ final class HttpApiFrontendSpec < nl > val publicGroup = createPubGroup ( " public group " , " PG " , Set ( user2 . id ) ) . groupPeer < nl > < nl > val resourcesPath = Paths . get ( getClass . getResource ( " / files " ) . toURI ) . toFile . getCanonicalPath < nl > - val config = HttpApiConfig ( " 127 . 0 . 0 . 1 " , 9090 , " http : / / localhost : 9090 " , resourcesPath , None ) < nl > + val port = scala . util . Random . nextInt ( 10000 ) + 1000 < nl > + val config = HttpApiConfig ( " 127 . 0 . 0 . 1 " , port , s " http : / / localhost : $ port " , resourcesPath , None ) < nl > HttpApiFrontend . start ( config ) < nl > < nl > - val http = Http ( ) < nl > - < nl > def textMessage ( ) = { < nl > val token = extractToken ( groupOutPeer . groupId ) < nl > val request = HttpRequest ( < nl > @ @ - 118 , 7 + 102 , 7 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , < nl > entity = " " " { " text " : " Good morning everyone ! " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual OK < nl > } < nl > } < nl > @ @ - 130 , 7 + 114 , 7 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , < nl > entity = " " " { " text " : " FLOOD FLOOD FLOOD " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual StatusCodes . Forbidden < nl > } < nl > } < nl > @ @ - 142 , 8 + 126 , 8 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ wrongToken " , < nl > entity = " " " { " text " : " Bla bla bla " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > - resp . status shouldEqual StatusCodes . BadRequest < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > + resp . status shouldEqual BadRequest < nl > } < nl > < nl > } < nl > @ @ - 155 , 7 + 139 , 7 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , < nl > entity = " " " { " document _ url " : " http : / / www . scala - lang . org / docu / files / ScalaReference . pdf " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual OK < nl > } < nl > } < nl > @ @ - 167 , 7 + 151 , 7 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , < nl > entity = " " " { " image _ url " : " http : / / www . scala - lang . org / resources / img / smooth - spiral . png " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual OK < nl > } < nl > } < nl > @ @ - 179 , 10 + 163 , 10 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " , < nl > entity = " " " { " url " : " This is wrong url " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual BadRequest < nl > - whenReady ( Unmarshal ( resp . entity ) . to [ Errors ] ) { errors ⇒ < nl > - errors . message shouldEqual OutgoingHooksErrors . MalformedUri < nl > + inside ( resp . as [ Errors ] ) { < nl > + case Right ( errors ) ⇒ errors . message shouldEqual OutgoingHooksErrors . MalformedUri < nl > } < nl > } < nl > } < nl > @ @ - 194 , 10 + 178 , 10 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ wrongToken / reverse " , < nl > entity = " " " { " url " : " http : / / zapier . com / 11 " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual NotFound < nl > - whenReady ( Unmarshal ( resp . entity ) . to [ Errors ] ) { errors ⇒ < nl > - errors . message shouldEqual OutgoingHooksErrors . WrongIntegrationToken < nl > + inside ( resp . as [ Errors ] ) { < nl > + case Right ( errors ) ⇒ errors . message shouldEqual OutgoingHooksErrors . WrongIntegrationToken < nl > } < nl > } < nl > } < nl > @ @ - 210 , 11 + 194 , 12 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " , < nl > entity = s " " " { " target _ url " : " $ hookUrl " , " other _ url " : " http : / / foo . bar " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual Created < nl > - whenReady ( Unmarshal ( resp . entity ) . to [ ReverseHookResponse ] ) { response ⇒ < nl > - response . id > 0 shouldBe true < nl > - response . url shouldEqual None < nl > + inside ( resp . as [ ReverseHookResponse ] ) { < nl > + case Right ( response ) ⇒ < nl > + response . id > 0 shouldBe true < nl > + response . url shouldEqual None < nl > } < nl > } < nl > } < nl > @ @ - 227 , 10 + 212 , 10 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " , < nl > entity = s " " " { " url " : " $ duplicatedUrl " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual Conflict < nl > - whenReady ( Unmarshal ( resp . entity ) . to [ Errors ] ) { errors ⇒ < nl > - errors . message shouldEqual OutgoingHooksErrors . AlreadyRegistered < nl > + inside ( resp . as [ Errors ] ) { < nl > + case Right ( errors ) ⇒ errors . message shouldEqual OutgoingHooksErrors . AlreadyRegistered < nl > } < nl > } < nl > } < nl > @ @ - 240 , 9 + 225 , 8 @ @ final class HttpApiFrontendSpec < nl > val httpApiUrl = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " < nl > < nl > for ( i ← 1 to 5 ) { < nl > - whenReady ( http . singleRequest ( HttpRequest ( POST , httpApiUrl , entity = s " " " { " url " : " https : / / zapier . com / $ i " } " " " ) ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( HttpRequest ( POST , httpApiUrl , entity = s " " " { " url " : " https : / / zapier . com / $ i " } " " " ) ) ) { resp ⇒ < nl > resp . status shouldEqual Created < nl > - resp . entity . dataBytes . runWith ( Sink . ignore ) < nl > } < nl > } < nl > } < nl > @ @ - 253 , 12 + 237 , 13 @ @ final class HttpApiFrontendSpec < nl > method = GET , < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual OK < nl > - whenReady ( Unmarshal ( resp . entity ) . to [ List [ ReverseHookResponse ] ] ) { hooks ⇒ < nl > - val expected = 0 to 5 map ( i ⇒ s " https : / / zapier . com / $ i " ) < nl > - hooks . map ( _ . url ) . flatten should contain theSameElementsAs expected < nl > - hooks . map ( _ . id ) foreach ( _ > 0 shouldBe true ) < nl > + inside ( resp . as [ List [ ReverseHookResponse ] ] ) { < nl > + case Right ( hooks ) ⇒ < nl > + val expected = 0 to 5 map ( i ⇒ s " https : / / zapier . com / $ i " ) < nl > + hooks . map ( _ . url ) . flatten should contain theSameElementsAs expected < nl > + hooks . map ( _ . id ) foreach ( _ > 0 shouldBe true ) < nl > } < nl > } < nl > } < nl > @ @ - 269 , 30 + 254 , 30 @ @ final class HttpApiFrontendSpec < nl > val baseUri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " < nl > val request = HttpRequest ( POST , baseUri , entity = s " " " { " url " : " $ hookUrl " } " " " ) < nl > < nl > - val hookId = whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + val hookId = whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual Created < nl > - whenReady ( Unmarshal ( resp . entity ) . to [ ReverseHookResponse ] ) ( _ . id ) < nl > + resp . as [ ReverseHookResponse ] . right . toOption . get . id < nl > } < nl > < nl > val hookUri = s " $ baseUri / $ hookId " < nl > - whenReady ( http . singleRequest ( HttpRequest ( GET , hookUri ) ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( HttpRequest ( GET , hookUri ) ) ) { resp ⇒ < nl > resp . status shouldEqual OK < nl > - whenReady ( Unmarshal ( resp . entity ) . to [ Status ] ) { status ⇒ < nl > - status . status shouldEqual " Ok " < nl > + inside ( resp . as [ Status ] ) { < nl > + case Right ( status ) ⇒ status . status shouldEqual " Ok " < nl > } < nl > } < nl > < nl > - whenReady ( http . singleRequest ( HttpRequest ( DELETE , hookUri ) ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( HttpRequest ( DELETE , hookUri ) ) ) { resp ⇒ < nl > resp . status shouldEqual StatusCodes . Accepted < nl > - whenReady ( Unmarshal ( resp . entity ) . to [ Status ] ) { status ⇒ < nl > - status . status shouldEqual " Ok " < nl > + inside ( resp . as [ Status ] ) { < nl > + case Right ( status ) ⇒ status . status shouldEqual " Ok " < nl > } < nl > } < nl > < nl > - whenReady ( http . singleRequest ( HttpRequest ( GET , hookUri ) ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( HttpRequest ( GET , hookUri ) ) ) { resp ⇒ < nl > resp . status shouldEqual Gone < nl > - whenReady ( Unmarshal ( resp . entity ) . to [ Status ] ) { status ⇒ < nl > - status . status shouldEqual OutgoingHooksErrors . WebhookGone < nl > + inside ( resp . as [ Status ] ) { < nl > + case Right ( status ) ⇒ status . status shouldEqual OutgoingHooksErrors . WebhookGone < nl > } < nl > } < nl > } < nl > @ @ - 304 , 7 + 289 , 7 @ @ final class HttpApiFrontendSpec < nl > uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , < nl > entity = " " " { " WRONG " : " Should not be parsed " } " " " < nl > ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual BadRequest < nl > } < nl > } < nl > @ @ - 314 , 16 + 299 , 15 @ @ final class HttpApiFrontendSpec < nl > val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ < nl > val request = HttpRequest ( < nl > - method = HttpMethods . GET , < nl > + method = GET , < nl > uri = s " $ { config . baseUri } / v1 / groups / invites / $ token " < nl > ) < nl > - val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > + val resp = whenReady ( singleRequest ( request ) ) ( identity ) < nl > resp . status shouldEqual OK < nl > - whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ < nl > - val response = Json . parse ( body ) < nl > - ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName < nl > - ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name < nl > - } < nl > + val body = resp . entity . asString < nl > + val response = Json . parse ( body ) < nl > + ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName < nl > + ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name < nl > } < nl > } < nl > < nl > @ @ - 342 , 28 + 326 , 26 @ @ final class HttpApiFrontendSpec < nl > < nl > whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ < nl > val request = HttpRequest ( < nl > - method = HttpMethods . GET , < nl > + method = GET , < nl > uri = s " $ { config . baseUri } / v1 / groups / invites / $ token " < nl > ) < nl > < nl > - val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > + val resp = whenReady ( singleRequest ( request ) ) ( identity ) < nl > resp . status shouldEqual OK < nl > < nl > - whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ < nl > - import JsonFormatters . avatarUrlsFormat < nl > - < nl > - val response = Json . parse ( body ) < nl > - ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName < nl > - ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name < nl > - < nl > - val avatarUrls = ( response \ " group " \ " avatars " ) . as [ AvatarUrls ] < nl > - inside ( avatarUrls ) { < nl > - case AvatarUrls ( Some ( small ) , Some ( large ) , Some ( full ) ) ⇒ < nl > - List ( small , large , full ) foreach ( _ should startWith ( " http : / / " ) ) < nl > - } < nl > - ( response \ " inviter " \ " avatars " ) . as [ AvatarUrls ] should matchPattern { < nl > - case AvatarUrls ( None , None , None ) ⇒ < nl > - } < nl > + val body = resp . entity . asString < nl > + < nl > + val response = Json . parse ( body ) < nl > + ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName < nl > + ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name < nl > + < nl > + val avatarUrls = ( response \ " group " \ " avatars " ) . as [ AvatarUrls ] < nl > + inside ( avatarUrls ) { < nl > + case AvatarUrls ( Some ( small ) , Some ( large ) , Some ( full ) ) ⇒ < nl > + List ( small , large , full ) foreach ( _ should startWith ( " http : / / " ) ) < nl > + } < nl > + ( response \ " inviter " \ " avatars " ) . as [ AvatarUrls ] should matchPattern { < nl > + case AvatarUrls ( None , None , None ) ⇒ < nl > } < nl > } < nl > } < nl > @ @ - 383 , 25 + 365 , 22 @ @ final class HttpApiFrontendSpec < nl > val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ < nl > val request = HttpRequest ( < nl > - method = HttpMethods . GET , < nl > + method = GET , < nl > uri = s " $ { config . baseUri } / v1 / groups / invites / $ token " < nl > ) < nl > - val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > + val resp = whenReady ( singleRequest ( request ) ) ( identity ) < nl > resp . status shouldEqual OK < nl > - whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ < nl > - import JsonFormatters . avatarUrlsFormat < nl > - < nl > - val response = Json . parse ( body ) < nl > - ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName < nl > - ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name < nl > - val avatarUrls = ( response \ " group " \ " avatars " ) . as [ AvatarUrls ] < nl > - inside ( avatarUrls ) { < nl > - case AvatarUrls ( None , Some ( large ) , Some ( full ) ) ⇒ < nl > - List ( large , full ) foreach ( _ should startWith ( " http : / / " ) ) < nl > - } < nl > - ( response \ " inviter " \ " avatars " ) . as [ AvatarUrls ] should matchPattern { < nl > - case AvatarUrls ( None , None , None ) ⇒ < nl > - } < nl > + val body = resp . entity . asString < nl > + val response = Json . parse ( body ) < nl > + ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName < nl > + ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name < nl > + val avatarUrls = ( response \ " group " \ " avatars " ) . as [ AvatarUrls ] < nl > + inside ( avatarUrls ) { < nl > + case AvatarUrls ( None , Some ( large ) , Some ( full ) ) ⇒ < nl > + List ( large , full ) foreach ( _ should startWith ( " http : / / " ) ) < nl > + } < nl > + ( response \ " inviter " \ " avatars " ) . as [ AvatarUrls ] should matchPattern { < nl > + case AvatarUrls ( None , None , None ) ⇒ < nl > } < nl > } < nl > } < nl > @ @ - 409 , 59 + 388 , 50 @ @ final class HttpApiFrontendSpec < nl > def groupInvitesInvalid ( ) = { < nl > val invalidToken = " Dkajsdljasdlkjaskdj329u90u32jdjlksRandom _ stuff " < nl > val request = HttpRequest ( < nl > - method = HttpMethods . GET , < nl > + method = GET , < nl > uri = s " $ { config . baseUri } / v1 / groups / invites / $ invalidToken " < nl > ) < nl > - val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > + val resp = whenReady ( singleRequest ( request ) ) ( identity ) < nl > resp . status shouldEqual NotAcceptable < nl > - resp . entity . dataBytes . runWith ( Sink . ignore ) < nl > } < nl > < nl > def notFound ( ) = { < nl > val request = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / neverExisted . txt " ) < nl > - whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( request ) ) { resp ⇒ < nl > resp . status shouldEqual NotFound < nl > - / / todo : remove when this https : / / github . com / akka / akka / issues / 17403 solved < nl > - resp . entity . dataBytes . runWith ( Sink . ignore ) < nl > } < nl > } < nl > < nl > def pathTraversal ( ) = { < nl > val attack1 = " % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2fetc % 2Fpasswd " < nl > val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / $ attack1 " ) < nl > - whenReady ( http . singleRequest ( r1 ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( r1 ) ) { resp ⇒ < nl > resp . status shouldEqual NotFound < nl > - resp . entity . dataBytes . runWith ( Sink . ignore ) < nl > } < nl > val attack2 = " . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2Fetc % 2Fpasswd " < nl > val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / $ attack2 " ) < nl > - whenReady ( http . singleRequest ( r2 ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( r2 ) ) { resp ⇒ < nl > resp . status shouldEqual NotFound < nl > - resp . entity . dataBytes . runWith ( Sink . ignore ) < nl > } < nl > val attack3 = " . . / . . / . . / . . / . . / . . / . . / . . / etc / passwd " < nl > val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / $ attack3 " ) < nl > - whenReady ( http . singleRequest ( r3 ) ) { resp ⇒ < nl > + whenReady ( singleRequest ( r3 ) ) { resp ⇒ < nl > resp . status shouldEqual NotFound < nl > - resp . entity . dataBytes . runWith ( Sink . ignore ) < nl > } < nl > } < nl > < nl > def filesCorrect ( ) = { < nl > - val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / index . html " , entity = HttpEntity . empty ( ContentTypes . ` text / plain ( UTF - 8 ) ` ) ) < nl > - whenReady ( http . singleRequest ( r1 ) ) { resp ⇒ < nl > + val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / index . html " ) < nl > + whenReady ( singleRequest ( r1 ) ) { resp ⇒ < nl > resp . status shouldEqual OK < nl > - resp . entity . dataBytes . runWith ( Sink . ignore ) < nl > } < nl > - val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / test . conf " , entity = HttpEntity . empty ( ContentTypes . ` text / plain ( UTF - 8 ) ` ) ) < nl > - whenReady ( http . singleRequest ( r2 ) ) { resp ⇒ < nl > + val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / test . conf " ) < nl > + whenReady ( singleRequest ( r2 ) ) { resp ⇒ < nl > resp . status shouldEqual OK < nl > - resp . entity . dataBytes . runWith ( Sink . ignore ) < nl > } < nl > - val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / scripts / test . js " , entity = HttpEntity . empty ( ContentTypes . ` text / plain ( UTF - 8 ) ` ) ) < nl > - whenReady ( http . singleRequest ( r3 ) ) { resp ⇒ < nl > + val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / scripts / test . js " ) < nl > + whenReady ( singleRequest ( r3 ) ) { resp ⇒ < nl > resp . status shouldEqual OK < nl > - resp . entity . dataBytes . runWith ( Sink . ignore ) < nl > } < nl > } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - http - api / src / main / resources / reference . conf b / actor - server / actor - http - api / src / main / resources / reference . conf < nl > index e3716f7 . . 0257ca3 100644 < nl > - - - a / actor - server / actor - http - api / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - http - api / src / main / resources / reference . conf < nl > @ @ - 4 , 6 + 4 , 7 @ @ actor - server { < nl > base - uri = " https : / / api . actor . im " < nl > interface = " 0 . 0 . 0 . 0 " < nl > port = 9000 < nl > + static - files - directory : " / home / user / actor - files / " < nl > } < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiConfig . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiConfig . scala < nl > index ac8f5a7 . . 15a10a2 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiConfig . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiConfig . scala < nl > @ @ - 2 , 13 + 2 , 14 @ @ package im . actor . server . api . http < nl > < nl > import com . typesafe . config . Config < nl > < nl > - case class HttpApiConfig ( baseUrl : String , interface : String , port : Int ) < nl > + case class HttpApiConfig ( baseUrl : String , interface : String , port : Int , staticFilesDirectory : String ) < nl > < nl > object HttpApiConfig { < nl > def fromConfig ( config : Config ) : HttpApiConfig = < nl > HttpApiConfig ( < nl > config . getString ( " base - uri " ) , < nl > config . getString ( " interface " ) , < nl > - config . getInt ( " port " ) < nl > + config . getInt ( " port " ) , < nl > + config . getString ( " static - files - directory " ) < nl > ) < nl > } < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala < nl > index 4463d47 . . e20f009 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala < nl > @ @ - 4 , 15 + 4 , 15 @ @ import scala . concurrent . ExecutionContext < nl > < nl > import akka . actor . ActorSystem < nl > import akka . http . scaladsl . Http < nl > - import akka . http . scaladsl . _ < nl > - import akka . http . scaladsl . model . headers . _ < nl > import akka . http . scaladsl . model . HttpMethods . _ < nl > + import akka . http . scaladsl . model . headers . _ < nl > import akka . http . scaladsl . server . Directives . _ < nl > - import akka . http . scaladsl . server . { RouteResult , Route } < nl > + import akka . http . scaladsl . server . Route < nl > import akka . stream . Materializer < nl > import com . github . dwhjames . awswrap . s3 . AmazonS3ScalaClient < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > + import im . actor . server . api . http . files . FilesHandler < nl > import im . actor . server . api . http . groups . GroupsHandler < nl > import im . actor . server . api . http . status . StatusHandler < nl > import im . actor . server . api . http . webhooks . WebhooksHandler < nl > @ @ - 20 , 6 + 20 , 13 @ @ import im . actor . server . peermanagers . GroupPeerManagerRegion < nl > < nl > object HttpApiFrontend { < nl > < nl > + val corsHeaders = List ( < nl > + ` Access - Control - Allow - Origin ` . ` * ` , < nl > + ` Access - Control - Allow - Methods ` ( GET , POST ) , < nl > + ` Access - Control - Allow - Headers ` ( " * " ) , < nl > + ` Access - Control - Allow - Credentials ` ( true ) < nl > + ) < nl > + < nl > def start ( config : HttpApiConfig , s3BucketName : String ) ( < nl > implicit < nl > system : ActorSystem , < nl > @ @ - 34 , 19 + 41 , 14 @ @ object HttpApiFrontend { < nl > val webhooks = new WebhooksHandler < nl > val groups = new GroupsHandler ( s3BucketName ) < nl > val status = new StatusHandler < nl > + val files = new FilesHandler ( config . staticFilesDirectory ) < nl > < nl > def routes : Route = pathPrefix ( " v1 " ) { < nl > - status . routes ~ groups . routes ~ webhooks . routes < nl > - } . andThen { r ⇒ < nl > - r . map { < nl > - case RouteResult . Complete ( res ) ⇒ < nl > - RouteResult . Complete ( res . withHeaders ( res . headers + + Seq ( < nl > - ` Access - Control - Allow - Origin ` . ` * ` , < nl > - ` Access - Control - Allow - Methods ` ( GET , POST ) , < nl > - ` Access - Control - Allow - Headers ` ( " * " ) , < nl > - ` Access - Control - Allow - Credentials ` ( true ) < nl > - ) ) ) < nl > - case m ⇒ m < nl > + respondWithDefaultHeaders ( corsHeaders ) { < nl > + status . routes ~ < nl > + groups . routes ~ < nl > + webhooks . routes ~ < nl > + files . routes < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / RoutesHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / RoutesHandler . scala < nl > new file mode 100644 < nl > index 0000000 . . 4d880d1 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / RoutesHandler . scala < nl > @ @ - 0 , 0 + 1 , 7 @ @ < nl > + package im . actor . server . api . http < nl > + < nl > + import akka . http . scaladsl . server . Route < nl > + < nl > + trait RoutesHandler { < nl > + def routes : Route < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / files / FilesHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / files / FilesHandler . scala < nl > new file mode 100644 < nl > index 0000000 . . bbb010a < nl > - - - / dev / null < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / files / FilesHandler . scala < nl > @ @ - 0 , 0 + 1 , 47 @ @ < nl > + package im . actor . server . api . http . files < nl > + < nl > + import java . io . File < nl > + import java . nio . file . Paths < nl > + < nl > + import scala . concurrent . ExecutionContext < nl > + < nl > + import akka . http . scaladsl . model . StatusCodes . { BadRequest , NotFound } < nl > + import akka . http . scaladsl . model . { ContentTypes , HttpResponse } < nl > + import akka . http . scaladsl . server . Directives . _ < nl > + import akka . http . scaladsl . server . _ < nl > + < nl > + import im . actor . server . api . http . RoutesHandler < nl > + < nl > + class FilesHandler ( staticFilesDirectory : String ) ( implicit ec : ExecutionContext ) extends RoutesHandler { < nl > + val rejection = RejectionHandler . newBuilder ( ) < nl > + . handle { < nl > + case AuthorizationFailedRejection ⇒ complete ( HttpResponse ( BadRequest , entity = " You are not allowed to perform this action " ) ) < nl > + } < nl > + . handleNotFound ( complete ( HttpResponse ( NotFound , entity = " File not found " ) ) ) < nl > + . result ( ) < nl > + < nl > + val base = Paths . get ( staticFilesDirectory ) . toFile < nl > + < nl > + override def routes : Route = path ( " files " / Segment ) { fileName ⇒ < nl > + get { < nl > + handleRejections ( rejection ) { < nl > + mapResponseEntity ( _ . withContentType ( ContentTypes . ` application / octet - stream ` ) ) { < nl > + validateFilePath ( fileName ) { file ⇒ < nl > + getFromFile ( file ) < nl > + } < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + def validateFilePath ( path : String ) : Directive1 [ File ] = { < nl > + Directive { fileCompl ⇒ < nl > + val file = new File ( base , path ) < nl > + if ( file . getCanonicalPath . startsWith ( base . getCanonicalPath ) ) < nl > + fileCompl ( Tuple1 ( file ) ) < nl > + else < nl > + reject ( AuthorizationFailedRejection ) < nl > + } < nl > + < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / groups / GroupsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / groups / GroupsHandler . scala < nl > index 71e221e . . 0925235 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / groups / GroupsHandler . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / groups / GroupsHandler . scala < nl > @ @ - 14 , 6 + 14 , 7 @ @ import play . api . libs . json . Json < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . api . rpc . files . FileLocation < nl > + import im . actor . server . api . http . RoutesHandler < nl > import im . actor . server . api . http . json . JsonImplicits . { errorsFormat , groupInviteInfoFormat } < nl > import im . actor . server . api . http . json . { Group , User , AvatarUrls , Errors , GroupInviteInfo } < nl > import im . actor . server . util . FileUtils . getFileUrl < nl > @ @ - 26 , 9 + 27 , 9 @ @ class GroupsHandler ( s3BucketName : String ) ( < nl > system : ActorSystem , < nl > ec : ExecutionContext , < nl > client : AmazonS3ScalaClient < nl > - ) { < nl > + ) extends RoutesHandler { < nl > < nl > - def routes : Route = path ( " groups " / " invites " / Segment ) { token ⇒ < nl > + override def routes : Route = path ( " groups " / " invites " / Segment ) { token ⇒ < nl > get { < nl > onComplete ( retrieve ( token ) ) { < nl > case Success ( Right ( result ) ) ⇒ < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / status / StatusHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / status / StatusHandler . scala < nl > index d7c52d8 . . 1ecfdde 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / status / StatusHandler . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / status / StatusHandler . scala < nl > @ @ - 3 , 8 + 3 , 10 @ @ package im . actor . server . api . http . status < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . Route < nl > < nl > - class StatusHandler { < nl > - def routes : Route = path ( " status " ) { < nl > + import im . actor . server . api . http . RoutesHandler < nl > + < nl > + class StatusHandler extends RoutesHandler { < nl > + override def routes : Route = path ( " status " ) { < nl > get { < nl > complete ( " " ) < nl > } < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / webhooks / WebhooksHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / webhooks / WebhooksHandler . scala < nl > index 366a44d . . 82f321c 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / webhooks / WebhooksHandler . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / webhooks / WebhooksHandler . scala < nl > @ @ - 8 , 6 + 8 , 7 @ @ import scala . util . { Failure , Success } < nl > import akka . http . scaladsl . model . HttpResponse < nl > import akka . http . scaladsl . model . StatusCodes . _ < nl > import akka . http . scaladsl . server . Directives . _ < nl > + import akka . http . scaladsl . server . Route < nl > import akka . stream . Materializer < nl > import akka . util . Timeout < nl > import org . joda . time . DateTime < nl > @ @ - 15 , 6 + 16 , 7 @ @ import slick . dbio . DBIO < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . api . rpc . messaging . { Message , TextMessage } < nl > + import im . actor . server . api . http . RoutesHandler < nl > import im . actor . server . api . http . json . _ < nl > import im . actor . server . peermanagers . { GroupPeerManager , GroupPeerManagerRegion } < nl > import im . actor . server . persist < nl > @ @ - 25 , 11 + 27 , 11 @ @ class WebhooksHandler ( ) ( < nl > ec : ExecutionContext , < nl > groupPeerManagerRegion : GroupPeerManagerRegion , < nl > val materializer : Materializer < nl > - ) extends ContentUnmarshaler { < nl > + ) extends RoutesHandler with ContentUnmarshaler { < nl > < nl > implicit val timeout : Timeout = Timeout ( 5 . seconds ) < nl > < nl > - def routes = path ( " webhooks " / Segment ) { token ⇒ < nl > + override def routes : Route = path ( " webhooks " / Segment ) { token ⇒ < nl > post { < nl > entity ( as [ Content ] ) { content ⇒ < nl > onComplete ( send ( content , token ) ) { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala < nl > index 2b7c787 . . 6693118 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala < nl > @ @ - 54 , 7 + 54 , 7 @ @ class IntegrationsServiceSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > implicit val authSmsConfig = AuthSmsConfig . fromConfig ( system . settings . config . getConfig ( " auth " ) ) < nl > implicit val authService = buildAuthService ( ) < nl > < nl > - private val config = HttpApiConfig ( " https : / / actor . im " , " localhost " , 9000 ) < nl > + private val config = HttpApiConfig ( " https : / / actor . im " , " localhost " , 9000 , " " ) < nl > val service = new IntegrationsServiceImpl ( config ) < nl > < nl > val ( user1 , user1AuthId1 , _ ) = createUser ( ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala < nl > index 7173dda . . 51a8b1a 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala < nl > @ @ - 4 , 6 + 4 , 8 @ @ import java . nio . file . Paths < nl > < nl > import scala . concurrent . forkjoin . ThreadLocalRandom < nl > < nl > + import akka . http . scaladsl . model . HttpMethods . GET < nl > + import akka . http . scaladsl . model . StatusCodes . { OK , BadRequest , NotFound } < nl > import org . scalatest . Inside . _ < nl > import akka . http . scaladsl . Http < nl > import akka . http . scaladsl . model . { HttpMethods , HttpRequest , StatusCodes } < nl > @ @ - 11 , 6 + 13 , 7 @ @ import akka . util . ByteString < nl > import com . amazonaws . auth . EnvironmentVariableCredentialsProvider < nl > import com . amazonaws . services . s3 . transfer . TransferManager < nl > import com . github . dwhjames . awswrap . s3 . AmazonS3ScalaClient < nl > + import org . specs2 . execute . PendingUntilFixed < nl > import play . api . libs . json . _ < nl > < nl > import im . actor . api . rpc . ClientData < nl > @ @ - 26 , 16 + 29 , 16 @ @ import im . actor . server . social . SocialManager < nl > import im . actor . server . util . { ImageUtils , FileUtils , ACLUtils } < nl > import im . actor . server . { BaseAppSuite , models , persist } < nl > < nl > - class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > + class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers with PendingUntilFixed { < nl > behavior of " HttpApiFrontend " < nl > < nl > - it should " respond with OK to webhooks text message " in t . textMessage ( ) < nl > + " Webhooks handler " should " respond with OK to webhooks text message " in t . textMessage ( ) < nl > < nl > / / it should " respond with OK to webhooks document message " in t . documentMessage ( ) / / TODO : not implemented yet < nl > < nl > / / it should " respond with OK to webhooks image message " in t . imageMessage ( ) / / TODO : not implemented yet < nl > < nl > - it should " respond with JSON message to group invite info with correct invite token " in t . groupInvitesOk ( ) < nl > + " Groups handler " should " respond with JSON message to group invite info with correct invite token " in t . groupInvitesOk ( ) < nl > < nl > it should " respond with JSON message with avatar full links to group invite info with correct invite token " in t . groupInvitesAvatars1 ( ) < nl > < nl > @ @ - 43 , 7 + 46 , 13 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > < nl > it should " respond with Not Acceptable to group invite info with invalid invite token " in t . groupInvitesInvalid ( ) < nl > < nl > - it should " respond BadRequest " in t . malformedMessage ( ) < nl > + it should " respond BadRequest to unknown message format " in t . malformedMessage ( ) < nl > + < nl > + " Files handler " should " serve correct file path " in pendingUntilFixed ( t . filesCorrect ( ) ) < nl > + < nl > + it should " respond with not found to non existing file " in pendingUntilFixed ( t . notFound ( ) ) < nl > + < nl > + it should " not allow path traversal " in pendingUntilFixed ( t . pathTraversal ( ) ) < nl > < nl > implicit val sessionRegion = buildSessionRegionProxy ( ) < nl > implicit val seqUpdManagerRegion = buildSeqUpdManagerRegion ( ) < nl > @ @ - 75 , 7 + 84 , 8 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > val groupName = " Test group " < nl > val groupOutPeer = createGroup ( groupName , Set ( user2 . id ) ) . groupPeer < nl > < nl > - val config = HttpApiConfig ( " https : / / api . actor . im " , " localhost " , 9000 ) < nl > + val resourcesPath = Paths . get ( getClass . getResource ( " / " ) . toURI ) . toFile . getCanonicalPath < nl > + val config = HttpApiConfig ( " https : / / api . actor . im " , " localhost " , 9000 , resourcesPath ) < nl > HttpApiFrontend . start ( config , " actor - uploads - test " ) < nl > < nl > val http = Http ( ) < nl > @ @ - 90 , 7 + 100 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > entity = " " " { " text " : " Good morning everyone ! " } " " " < nl > ) < nl > whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > - resp . status shouldEqual StatusCodes . OK < nl > + resp . status shouldEqual OK < nl > } < nl > } < nl > } < nl > @ @ - 105 , 7 + 115 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > entity = " " " { " document _ url " : " http : / / www . scala - lang . org / docu / files / ScalaReference . pdf " } " " " < nl > ) < nl > whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > - resp . status shouldEqual StatusCodes . OK < nl > + resp . status shouldEqual OK < nl > } < nl > } < nl > } < nl > @ @ - 120 , 7 + 130 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > entity = " " " { " image _ url " : " http : / / www . scala - lang . org / resources / img / smooth - spiral . png " } " " " < nl > ) < nl > whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > - resp . status shouldEqual StatusCodes . OK < nl > + resp . status shouldEqual OK < nl > } < nl > } < nl > } < nl > @ @ - 135 , 7 + 145 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > entity = " " " { " WRONG " : " Should not be parsed " } " " " < nl > ) < nl > whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > - resp . status shouldEqual StatusCodes . BadRequest < nl > + resp . status shouldEqual BadRequest < nl > } < nl > } < nl > } < nl > @ @ - 145 , 11 + 155 , 11 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > val inviteToken = models . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ < nl > val request = HttpRequest ( < nl > - method = HttpMethods . GET , < nl > + method = GET , < nl > uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " < nl > ) < nl > val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > - resp . status shouldEqual StatusCodes . OK < nl > + resp . status shouldEqual OK < nl > whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ < nl > val response = Json . parse ( body ) < nl > ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName < nl > @ @ - 173 , 12 + 183 , 12 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > < nl > whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ < nl > val request = HttpRequest ( < nl > - method = HttpMethods . GET , < nl > + method = GET , < nl > uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " < nl > ) < nl > < nl > val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > - resp . status shouldEqual StatusCodes . OK < nl > + resp . status shouldEqual OK < nl > < nl > whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ < nl > import JsonImplicits . avatarUrlsFormat < nl > @ @ - 214 , 11 + 224 , 11 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > val inviteToken = models . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ < nl > val request = HttpRequest ( < nl > - method = HttpMethods . GET , < nl > + method = GET , < nl > uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " < nl > ) < nl > val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > - resp . status shouldEqual StatusCodes . OK < nl > + resp . status shouldEqual OK < nl > whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ < nl > import JsonImplicits . avatarUrlsFormat < nl > < nl > @ @ - 240 , 13 + 250 , 56 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > def groupInvitesInvalid ( ) = { < nl > val invalidToken = " Dkajsdljasdlkjaskdj329u90u32jdjlksRandom _ stuff " < nl > val request = HttpRequest ( < nl > - method = HttpMethods . GET , < nl > + method = GET , < nl > uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ invalidToken " < nl > ) < nl > val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > resp . status shouldEqual StatusCodes . NotAcceptable < nl > } < nl > < nl > + def notFound ( ) = { < nl > + val request = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / neverExisted . txt " ) < nl > + whenReady ( http . singleRequest ( request ) ) { resp ⇒ < nl > + resp . status shouldEqual NotFound < nl > + } < nl > + } < nl > + < nl > + def pathTraversal ( ) = { < nl > + val attack1 = " % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2fetc % 2Fpasswd " < nl > + val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / $ attack1 " ) < nl > + whenReady ( http . singleRequest ( r1 ) ) { resp ⇒ < nl > + resp . status shouldEqual BadRequest < nl > + } < nl > + val attack2 = " . . % 2F . . % 2F . . % 2Fetc % 2Fpasswd " < nl > + val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / $ attack2 " ) < nl > + whenReady ( http . singleRequest ( r2 ) ) { resp ⇒ < nl > + resp . status shouldEqual BadRequest < nl > + } < nl > + val attack3 = " . . / . . / . . / etc / passwd " < nl > + val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / $ attack3 " ) < nl > + whenReady ( http . singleRequest ( r3 ) ) { resp ⇒ < nl > + resp . status shouldEqual NotFound < nl > + } < nl > + } < nl > + < nl > + def filesCorrect ( ) = { < nl > + val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / reference . conf " ) < nl > + whenReady ( http . singleRequest ( r1 ) ) { resp ⇒ < nl > + resp . status shouldEqual OK < nl > + } < nl > + val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / logback . xml " ) < nl > + whenReady ( http . singleRequest ( r2 ) ) { resp ⇒ < nl > + resp . status shouldEqual OK < nl > + } < nl > + val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / valid - avatar . jpg " ) < nl > + whenReady ( http . singleRequest ( r3 ) ) { resp ⇒ < nl > + resp . status shouldEqual OK < nl > + } < nl > + val r4 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / application . conf . example " ) < nl > + whenReady ( http . singleRequest ( r4 ) ) { resp ⇒ < nl > + resp . status shouldEqual OK < nl > + } < nl > + } < nl > } < nl > < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / src / main / resources / application . conf . example b / actor - server / src / main / resources / application . conf . example < nl > index bc9d1e1 . . 6bb7e98 100644 < nl > - - - a / actor - server / src / main / resources / application . conf . example < nl > + + + b / actor - server / src / main / resources / application . conf . example < nl > @ @ - 1 , 6 + 1 , 6 @ @ < nl > # Example configuration for Actor Platform < nl > - # This file use HOCON syntax ( https : / / github . com / typesafehub / config / blob / master / HOCON . md ) < nl > - # For starting server you need : < nl > + # This file uses HOCON syntax ( https : / / github . com / typesafehub / config / blob / master / HOCON . md ) < nl > + # To start server you need : < nl > # * Configure PostgreSQL service < nl > # * Configure one of supported SMS gateway service ( Telesign , Clickatel , Twilio ) < nl > # or < nl > @ @ - 73 , 11 + 73 , 12 @ @ network { < nl > < nl > # HTTP Api used in simple REST API < nl > http - api { < nl > - # Please , change for actual API Uri < nl > + # Please , replace with actual API Uri < nl > base - uri : " https : / / localhost / api " < nl > host : " 0 . 0 . 0 . 0 " < nl > port : 443 < nl > keystore : main < nl > + static - files - directory : " / home / user / actor - files " < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala 
 index 633dfd0 . . 2356c42 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala 
 @ @ - 2 , 15 + 2 , 6 @ @ package im . actor . server . api . http 
 
 import java . nio . file . { Files , Paths } 
 
 - import akka . http . scaladsl . Http 
 - import akka . http . scaladsl . model . HttpMethods . { DELETE , GET , POST } 
 - import akka . http . scaladsl . model . StatusCodes . _ 
 - import akka . http . scaladsl . model . _ 
 - import akka . http . scaladsl . unmarshalling . PredefinedFromEntityUnmarshallers . _ 
 - import akka . http . scaladsl . unmarshalling . _ 
 - import akka . stream . scaladsl . Sink 
 - import akka . util . ByteString 
 - import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport 
 import im . actor . api . rpc . { AuthData , ClientData } 
 import im . actor . server . _ 
 import im . actor . server . acl . ACLUtils 
 @ @ - 18 , 11 + 9 , 17 @ @ import im . actor . server . api . http . json . JsonFormatters . _ 
 import im . actor . server . api . http . json . { AvatarUrls , _ } 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . api . rpc . service . messaging 
 - import im . actor . server . file . { UnsafeFileName , FileStorageExtension , ImageUtils } 
 + import im . actor . server . file . { FileStorageExtension , ImageUtils , UnsafeFileName } 
 import im . actor . server . webhooks . WebhooksExtension 
 import im . actor . server . webhooks . http . routes . OutgoingHooksErrors 
 import im . actor . util . ThreadLocalSecureRandom 
 import play . api . libs . json . _ 
 + import spray . client . pipelining . _ 
 + import spray . http . HttpMethods . { DELETE , GET , POST } 
 + import spray . http . StatusCodes . _ 
 + import spray . http . { HttpRequest , StatusCodes } 
 + import spray . httpx . PlayJsonSupport 
 + import spray . httpx . unmarshalling . _ 
 
 final class HttpApiFrontendSpec 
 extends BaseAppSuite 
 @ @ - 81 , 19 + 78 , 7 @ @ final class HttpApiFrontendSpec 
 
 WebhooksExtension ( system ) / / initialize webhooks routes 
 
 - implicit val reverseHookResponseUnmarshaller : FromEntityUnmarshaller [ ReverseHookResponse ] = Unmarshaller { implicit ec ⇒ entity ⇒ 
 - Unmarshal ( entity ) . to [ String ] . map { body ⇒ 
 - Json . parse ( body ) . as [ ReverseHookResponse ] 
 - } 
 - } 
 - 
 - implicit val statusUnmarshaller : FromEntityUnmarshaller [ Status ] = Unmarshaller { implicit ec ⇒ entity ⇒ 
 - Unmarshal ( entity ) . to [ String ] . map { body ⇒ 
 - Json . parse ( body ) . as [ Status ] 
 - } 
 - } 
 - 
 - val s3BucketName = " actor - uploads - test " 
 + val singleRequest = sendReceive 
 
 object t { 
 val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) 
 @ @ - 106 , 11 + 91 , 10 @ @ final class HttpApiFrontendSpec 
 val publicGroup = createPubGroup ( " public group " , " PG " , Set ( user2 . id ) ) . groupPeer 
 
 val resourcesPath = Paths . get ( getClass . getResource ( " / files " ) . toURI ) . toFile . getCanonicalPath 
 - val config = HttpApiConfig ( " 127 . 0 . 0 . 1 " , 9090 , " http : / / localhost : 9090 " , resourcesPath , None ) 
 + val port = scala . util . Random . nextInt ( 10000 ) + 1000 
 + val config = HttpApiConfig ( " 127 . 0 . 0 . 1 " , port , s " http : / / localhost : $ port " , resourcesPath , None ) 
 HttpApiFrontend . start ( config ) 
 
 - val http = Http ( ) 
 - 
 def textMessage ( ) = { 
 val token = extractToken ( groupOutPeer . groupId ) 
 val request = HttpRequest ( 
 @ @ - 118 , 7 + 102 , 7 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , 
 entity = " " " { " text " : " Good morning everyone ! " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual OK 
 } 
 } 
 @ @ - 130 , 7 + 114 , 7 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , 
 entity = " " " { " text " : " FLOOD FLOOD FLOOD " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual StatusCodes . Forbidden 
 } 
 } 
 @ @ - 142 , 8 + 126 , 8 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ wrongToken " , 
 entity = " " " { " text " : " Bla bla bla " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 - resp . status shouldEqual StatusCodes . BadRequest 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 + resp . status shouldEqual BadRequest 
 } 
 
 } 
 @ @ - 155 , 7 + 139 , 7 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , 
 entity = " " " { " document _ url " : " http : / / www . scala - lang . org / docu / files / ScalaReference . pdf " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual OK 
 } 
 } 
 @ @ - 167 , 7 + 151 , 7 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , 
 entity = " " " { " image _ url " : " http : / / www . scala - lang . org / resources / img / smooth - spiral . png " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual OK 
 } 
 } 
 @ @ - 179 , 10 + 163 , 10 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " , 
 entity = " " " { " url " : " This is wrong url " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual BadRequest 
 - whenReady ( Unmarshal ( resp . entity ) . to [ Errors ] ) { errors ⇒ 
 - errors . message shouldEqual OutgoingHooksErrors . MalformedUri 
 + inside ( resp . as [ Errors ] ) { 
 + case Right ( errors ) ⇒ errors . message shouldEqual OutgoingHooksErrors . MalformedUri 
 } 
 } 
 } 
 @ @ - 194 , 10 + 178 , 10 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ wrongToken / reverse " , 
 entity = " " " { " url " : " http : / / zapier . com / 11 " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual NotFound 
 - whenReady ( Unmarshal ( resp . entity ) . to [ Errors ] ) { errors ⇒ 
 - errors . message shouldEqual OutgoingHooksErrors . WrongIntegrationToken 
 + inside ( resp . as [ Errors ] ) { 
 + case Right ( errors ) ⇒ errors . message shouldEqual OutgoingHooksErrors . WrongIntegrationToken 
 } 
 } 
 } 
 @ @ - 210 , 11 + 194 , 12 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " , 
 entity = s " " " { " target _ url " : " $ hookUrl " , " other _ url " : " http : / / foo . bar " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual Created 
 - whenReady ( Unmarshal ( resp . entity ) . to [ ReverseHookResponse ] ) { response ⇒ 
 - response . id > 0 shouldBe true 
 - response . url shouldEqual None 
 + inside ( resp . as [ ReverseHookResponse ] ) { 
 + case Right ( response ) ⇒ 
 + response . id > 0 shouldBe true 
 + response . url shouldEqual None 
 } 
 } 
 } 
 @ @ - 227 , 10 + 212 , 10 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " , 
 entity = s " " " { " url " : " $ duplicatedUrl " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual Conflict 
 - whenReady ( Unmarshal ( resp . entity ) . to [ Errors ] ) { errors ⇒ 
 - errors . message shouldEqual OutgoingHooksErrors . AlreadyRegistered 
 + inside ( resp . as [ Errors ] ) { 
 + case Right ( errors ) ⇒ errors . message shouldEqual OutgoingHooksErrors . AlreadyRegistered 
 } 
 } 
 } 
 @ @ - 240 , 9 + 225 , 8 @ @ final class HttpApiFrontendSpec 
 val httpApiUrl = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " 
 
 for ( i ← 1 to 5 ) { 
 - whenReady ( http . singleRequest ( HttpRequest ( POST , httpApiUrl , entity = s " " " { " url " : " https : / / zapier . com / $ i " } " " " ) ) ) { resp ⇒ 
 + whenReady ( singleRequest ( HttpRequest ( POST , httpApiUrl , entity = s " " " { " url " : " https : / / zapier . com / $ i " } " " " ) ) ) { resp ⇒ 
 resp . status shouldEqual Created 
 - resp . entity . dataBytes . runWith ( Sink . ignore ) 
 } 
 } 
 } 
 @ @ - 253 , 12 + 237 , 13 @ @ final class HttpApiFrontendSpec 
 method = GET , 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual OK 
 - whenReady ( Unmarshal ( resp . entity ) . to [ List [ ReverseHookResponse ] ] ) { hooks ⇒ 
 - val expected = 0 to 5 map ( i ⇒ s " https : / / zapier . com / $ i " ) 
 - hooks . map ( _ . url ) . flatten should contain theSameElementsAs expected 
 - hooks . map ( _ . id ) foreach ( _ > 0 shouldBe true ) 
 + inside ( resp . as [ List [ ReverseHookResponse ] ] ) { 
 + case Right ( hooks ) ⇒ 
 + val expected = 0 to 5 map ( i ⇒ s " https : / / zapier . com / $ i " ) 
 + hooks . map ( _ . url ) . flatten should contain theSameElementsAs expected 
 + hooks . map ( _ . id ) foreach ( _ > 0 shouldBe true ) 
 } 
 } 
 } 
 @ @ - 269 , 30 + 254 , 30 @ @ final class HttpApiFrontendSpec 
 val baseUri = s " $ { config . baseUri } / v1 / webhooks / $ token / reverse " 
 val request = HttpRequest ( POST , baseUri , entity = s " " " { " url " : " $ hookUrl " } " " " ) 
 
 - val hookId = whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + val hookId = whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual Created 
 - whenReady ( Unmarshal ( resp . entity ) . to [ ReverseHookResponse ] ) ( _ . id ) 
 + resp . as [ ReverseHookResponse ] . right . toOption . get . id 
 } 
 
 val hookUri = s " $ baseUri / $ hookId " 
 - whenReady ( http . singleRequest ( HttpRequest ( GET , hookUri ) ) ) { resp ⇒ 
 + whenReady ( singleRequest ( HttpRequest ( GET , hookUri ) ) ) { resp ⇒ 
 resp . status shouldEqual OK 
 - whenReady ( Unmarshal ( resp . entity ) . to [ Status ] ) { status ⇒ 
 - status . status shouldEqual " Ok " 
 + inside ( resp . as [ Status ] ) { 
 + case Right ( status ) ⇒ status . status shouldEqual " Ok " 
 } 
 } 
 
 - whenReady ( http . singleRequest ( HttpRequest ( DELETE , hookUri ) ) ) { resp ⇒ 
 + whenReady ( singleRequest ( HttpRequest ( DELETE , hookUri ) ) ) { resp ⇒ 
 resp . status shouldEqual StatusCodes . Accepted 
 - whenReady ( Unmarshal ( resp . entity ) . to [ Status ] ) { status ⇒ 
 - status . status shouldEqual " Ok " 
 + inside ( resp . as [ Status ] ) { 
 + case Right ( status ) ⇒ status . status shouldEqual " Ok " 
 } 
 } 
 
 - whenReady ( http . singleRequest ( HttpRequest ( GET , hookUri ) ) ) { resp ⇒ 
 + whenReady ( singleRequest ( HttpRequest ( GET , hookUri ) ) ) { resp ⇒ 
 resp . status shouldEqual Gone 
 - whenReady ( Unmarshal ( resp . entity ) . to [ Status ] ) { status ⇒ 
 - status . status shouldEqual OutgoingHooksErrors . WebhookGone 
 + inside ( resp . as [ Status ] ) { 
 + case Right ( status ) ⇒ status . status shouldEqual OutgoingHooksErrors . WebhookGone 
 } 
 } 
 } 
 @ @ - 304 , 7 + 289 , 7 @ @ final class HttpApiFrontendSpec 
 uri = s " $ { config . baseUri } / v1 / webhooks / $ token " , 
 entity = " " " { " WRONG " : " Should not be parsed " } " " " 
 ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual BadRequest 
 } 
 } 
 @ @ - 314 , 16 + 299 , 15 @ @ final class HttpApiFrontendSpec 
 val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ 
 val request = HttpRequest ( 
 - method = HttpMethods . GET , 
 + method = GET , 
 uri = s " $ { config . baseUri } / v1 / groups / invites / $ token " 
 ) 
 - val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 + val resp = whenReady ( singleRequest ( request ) ) ( identity ) 
 resp . status shouldEqual OK 
 - whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ 
 - val response = Json . parse ( body ) 
 - ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName 
 - ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name 
 - } 
 + val body = resp . entity . asString 
 + val response = Json . parse ( body ) 
 + ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName 
 + ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name 
 } 
 } 
 
 @ @ - 342 , 28 + 326 , 26 @ @ final class HttpApiFrontendSpec 
 
 whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ 
 val request = HttpRequest ( 
 - method = HttpMethods . GET , 
 + method = GET , 
 uri = s " $ { config . baseUri } / v1 / groups / invites / $ token " 
 ) 
 
 - val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 + val resp = whenReady ( singleRequest ( request ) ) ( identity ) 
 resp . status shouldEqual OK 
 
 - whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ 
 - import JsonFormatters . avatarUrlsFormat 
 - 
 - val response = Json . parse ( body ) 
 - ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName 
 - ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name 
 - 
 - val avatarUrls = ( response \ " group " \ " avatars " ) . as [ AvatarUrls ] 
 - inside ( avatarUrls ) { 
 - case AvatarUrls ( Some ( small ) , Some ( large ) , Some ( full ) ) ⇒ 
 - List ( small , large , full ) foreach ( _ should startWith ( " http : / / " ) ) 
 - } 
 - ( response \ " inviter " \ " avatars " ) . as [ AvatarUrls ] should matchPattern { 
 - case AvatarUrls ( None , None , None ) ⇒ 
 - } 
 + val body = resp . entity . asString 
 + 
 + val response = Json . parse ( body ) 
 + ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName 
 + ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name 
 + 
 + val avatarUrls = ( response \ " group " \ " avatars " ) . as [ AvatarUrls ] 
 + inside ( avatarUrls ) { 
 + case AvatarUrls ( Some ( small ) , Some ( large ) , Some ( full ) ) ⇒ 
 + List ( small , large , full ) foreach ( _ should startWith ( " http : / / " ) ) 
 + } 
 + ( response \ " inviter " \ " avatars " ) . as [ AvatarUrls ] should matchPattern { 
 + case AvatarUrls ( None , None , None ) ⇒ 
 } 
 } 
 } 
 @ @ - 383 , 25 + 365 , 22 @ @ final class HttpApiFrontendSpec 
 val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ 
 val request = HttpRequest ( 
 - method = HttpMethods . GET , 
 + method = GET , 
 uri = s " $ { config . baseUri } / v1 / groups / invites / $ token " 
 ) 
 - val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 + val resp = whenReady ( singleRequest ( request ) ) ( identity ) 
 resp . status shouldEqual OK 
 - whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ 
 - import JsonFormatters . avatarUrlsFormat 
 - 
 - val response = Json . parse ( body ) 
 - ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName 
 - ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name 
 - val avatarUrls = ( response \ " group " \ " avatars " ) . as [ AvatarUrls ] 
 - inside ( avatarUrls ) { 
 - case AvatarUrls ( None , Some ( large ) , Some ( full ) ) ⇒ 
 - List ( large , full ) foreach ( _ should startWith ( " http : / / " ) ) 
 - } 
 - ( response \ " inviter " \ " avatars " ) . as [ AvatarUrls ] should matchPattern { 
 - case AvatarUrls ( None , None , None ) ⇒ 
 - } 
 + val body = resp . entity . asString 
 + val response = Json . parse ( body ) 
 + ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName 
 + ( response \ " inviter " \ " name " ) . as [ String ] shouldEqual user1 . name 
 + val avatarUrls = ( response \ " group " \ " avatars " ) . as [ AvatarUrls ] 
 + inside ( avatarUrls ) { 
 + case AvatarUrls ( None , Some ( large ) , Some ( full ) ) ⇒ 
 + List ( large , full ) foreach ( _ should startWith ( " http : / / " ) ) 
 + } 
 + ( response \ " inviter " \ " avatars " ) . as [ AvatarUrls ] should matchPattern { 
 + case AvatarUrls ( None , None , None ) ⇒ 
 } 
 } 
 } 
 @ @ - 409 , 59 + 388 , 50 @ @ final class HttpApiFrontendSpec 
 def groupInvitesInvalid ( ) = { 
 val invalidToken = " Dkajsdljasdlkjaskdj329u90u32jdjlksRandom _ stuff " 
 val request = HttpRequest ( 
 - method = HttpMethods . GET , 
 + method = GET , 
 uri = s " $ { config . baseUri } / v1 / groups / invites / $ invalidToken " 
 ) 
 - val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 + val resp = whenReady ( singleRequest ( request ) ) ( identity ) 
 resp . status shouldEqual NotAcceptable 
 - resp . entity . dataBytes . runWith ( Sink . ignore ) 
 } 
 
 def notFound ( ) = { 
 val request = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / neverExisted . txt " ) 
 - whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + whenReady ( singleRequest ( request ) ) { resp ⇒ 
 resp . status shouldEqual NotFound 
 - / / todo : remove when this https : / / github . com / akka / akka / issues / 17403 solved 
 - resp . entity . dataBytes . runWith ( Sink . ignore ) 
 } 
 } 
 
 def pathTraversal ( ) = { 
 val attack1 = " % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2fetc % 2Fpasswd " 
 val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / $ attack1 " ) 
 - whenReady ( http . singleRequest ( r1 ) ) { resp ⇒ 
 + whenReady ( singleRequest ( r1 ) ) { resp ⇒ 
 resp . status shouldEqual NotFound 
 - resp . entity . dataBytes . runWith ( Sink . ignore ) 
 } 
 val attack2 = " . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2F . . % 2Fetc % 2Fpasswd " 
 val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / $ attack2 " ) 
 - whenReady ( http . singleRequest ( r2 ) ) { resp ⇒ 
 + whenReady ( singleRequest ( r2 ) ) { resp ⇒ 
 resp . status shouldEqual NotFound 
 - resp . entity . dataBytes . runWith ( Sink . ignore ) 
 } 
 val attack3 = " . . / . . / . . / . . / . . / . . / . . / . . / etc / passwd " 
 val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / $ attack3 " ) 
 - whenReady ( http . singleRequest ( r3 ) ) { resp ⇒ 
 + whenReady ( singleRequest ( r3 ) ) { resp ⇒ 
 resp . status shouldEqual NotFound 
 - resp . entity . dataBytes . runWith ( Sink . ignore ) 
 } 
 } 
 
 def filesCorrect ( ) = { 
 - val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / index . html " , entity = HttpEntity . empty ( ContentTypes . ` text / plain ( UTF - 8 ) ` ) ) 
 - whenReady ( http . singleRequest ( r1 ) ) { resp ⇒ 
 + val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / index . html " ) 
 + whenReady ( singleRequest ( r1 ) ) { resp ⇒ 
 resp . status shouldEqual OK 
 - resp . entity . dataBytes . runWith ( Sink . ignore ) 
 } 
 - val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / test . conf " , entity = HttpEntity . empty ( ContentTypes . ` text / plain ( UTF - 8 ) ` ) ) 
 - whenReady ( http . singleRequest ( r2 ) ) { resp ⇒ 
 + val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / test . conf " ) 
 + whenReady ( singleRequest ( r2 ) ) { resp ⇒ 
 resp . status shouldEqual OK 
 - resp . entity . dataBytes . runWith ( Sink . ignore ) 
 } 
 - val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / scripts / test . js " , entity = HttpEntity . empty ( ContentTypes . ` text / plain ( UTF - 8 ) ` ) ) 
 - whenReady ( http . singleRequest ( r3 ) ) { resp ⇒ 
 + val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / app / scripts / test . js " ) 
 + whenReady ( singleRequest ( r3 ) ) { resp ⇒ 
 resp . status shouldEqual OK 
 - resp . entity . dataBytes . runWith ( Sink . ignore ) 
 } 
 } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - http - api / src / main / resources / reference . conf b / actor - server / actor - http - api / src / main / resources / reference . conf 
 index e3716f7 . . 0257ca3 100644 
 - - - a / actor - server / actor - http - api / src / main / resources / reference . conf 
 + + + b / actor - server / actor - http - api / src / main / resources / reference . conf 
 @ @ - 4 , 6 + 4 , 7 @ @ actor - server { 
 base - uri = " https : / / api . actor . im " 
 interface = " 0 . 0 . 0 . 0 " 
 port = 9000 
 + static - files - directory : " / home / user / actor - files / " 
 } 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiConfig . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiConfig . scala 
 index ac8f5a7 . . 15a10a2 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiConfig . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiConfig . scala 
 @ @ - 2 , 13 + 2 , 14 @ @ package im . actor . server . api . http 
 
 import com . typesafe . config . Config 
 
 - case class HttpApiConfig ( baseUrl : String , interface : String , port : Int ) 
 + case class HttpApiConfig ( baseUrl : String , interface : String , port : Int , staticFilesDirectory : String ) 
 
 object HttpApiConfig { 
 def fromConfig ( config : Config ) : HttpApiConfig = 
 HttpApiConfig ( 
 config . getString ( " base - uri " ) , 
 config . getString ( " interface " ) , 
 - config . getInt ( " port " ) 
 + config . getInt ( " port " ) , 
 + config . getString ( " static - files - directory " ) 
 ) 
 } 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala 
 index 4463d47 . . e20f009 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala 
 @ @ - 4 , 15 + 4 , 15 @ @ import scala . concurrent . ExecutionContext 
 
 import akka . actor . ActorSystem 
 import akka . http . scaladsl . Http 
 - import akka . http . scaladsl . _ 
 - import akka . http . scaladsl . model . headers . _ 
 import akka . http . scaladsl . model . HttpMethods . _ 
 + import akka . http . scaladsl . model . headers . _ 
 import akka . http . scaladsl . server . Directives . _ 
 - import akka . http . scaladsl . server . { RouteResult , Route } 
 + import akka . http . scaladsl . server . Route 
 import akka . stream . Materializer 
 import com . github . dwhjames . awswrap . s3 . AmazonS3ScalaClient 
 import slick . driver . PostgresDriver . api . _ 
 
 + import im . actor . server . api . http . files . FilesHandler 
 import im . actor . server . api . http . groups . GroupsHandler 
 import im . actor . server . api . http . status . StatusHandler 
 import im . actor . server . api . http . webhooks . WebhooksHandler 
 @ @ - 20 , 6 + 20 , 13 @ @ import im . actor . server . peermanagers . GroupPeerManagerRegion 
 
 object HttpApiFrontend { 
 
 + val corsHeaders = List ( 
 + ` Access - Control - Allow - Origin ` . ` * ` , 
 + ` Access - Control - Allow - Methods ` ( GET , POST ) , 
 + ` Access - Control - Allow - Headers ` ( " * " ) , 
 + ` Access - Control - Allow - Credentials ` ( true ) 
 + ) 
 + 
 def start ( config : HttpApiConfig , s3BucketName : String ) ( 
 implicit 
 system : ActorSystem , 
 @ @ - 34 , 19 + 41 , 14 @ @ object HttpApiFrontend { 
 val webhooks = new WebhooksHandler 
 val groups = new GroupsHandler ( s3BucketName ) 
 val status = new StatusHandler 
 + val files = new FilesHandler ( config . staticFilesDirectory ) 
 
 def routes : Route = pathPrefix ( " v1 " ) { 
 - status . routes ~ groups . routes ~ webhooks . routes 
 - } . andThen { r ⇒ 
 - r . map { 
 - case RouteResult . Complete ( res ) ⇒ 
 - RouteResult . Complete ( res . withHeaders ( res . headers + + Seq ( 
 - ` Access - Control - Allow - Origin ` . ` * ` , 
 - ` Access - Control - Allow - Methods ` ( GET , POST ) , 
 - ` Access - Control - Allow - Headers ` ( " * " ) , 
 - ` Access - Control - Allow - Credentials ` ( true ) 
 - ) ) ) 
 - case m ⇒ m 
 + respondWithDefaultHeaders ( corsHeaders ) { 
 + status . routes ~ 
 + groups . routes ~ 
 + webhooks . routes ~ 
 + files . routes 
 } 
 } 
 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / RoutesHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / RoutesHandler . scala 
 new file mode 100644 
 index 0000000 . . 4d880d1 
 - - - / dev / null 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / RoutesHandler . scala 
 @ @ - 0 , 0 + 1 , 7 @ @ 
 + package im . actor . server . api . http 
 + 
 + import akka . http . scaladsl . server . Route 
 + 
 + trait RoutesHandler { 
 + def routes : Route 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / files / FilesHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / files / FilesHandler . scala 
 new file mode 100644 
 index 0000000 . . bbb010a 
 - - - / dev / null 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / files / FilesHandler . scala 
 @ @ - 0 , 0 + 1 , 47 @ @ 
 + package im . actor . server . api . http . files 
 + 
 + import java . io . File 
 + import java . nio . file . Paths 
 + 
 + import scala . concurrent . ExecutionContext 
 + 
 + import akka . http . scaladsl . model . StatusCodes . { BadRequest , NotFound } 
 + import akka . http . scaladsl . model . { ContentTypes , HttpResponse } 
 + import akka . http . scaladsl . server . Directives . _ 
 + import akka . http . scaladsl . server . _ 
 + 
 + import im . actor . server . api . http . RoutesHandler 
 + 
 + class FilesHandler ( staticFilesDirectory : String ) ( implicit ec : ExecutionContext ) extends RoutesHandler { 
 + val rejection = RejectionHandler . newBuilder ( ) 
 + . handle { 
 + case AuthorizationFailedRejection ⇒ complete ( HttpResponse ( BadRequest , entity = " You are not allowed to perform this action " ) ) 
 + } 
 + . handleNotFound ( complete ( HttpResponse ( NotFound , entity = " File not found " ) ) ) 
 + . result ( ) 
 + 
 + val base = Paths . get ( staticFilesDirectory ) . toFile 
 + 
 + override def routes : Route = path ( " files " / Segment ) { fileName ⇒ 
 + get { 
 + handleRejections ( rejection ) { 
 + mapResponseEntity ( _ . withContentType ( ContentTypes . ` application / octet - stream ` ) ) { 
 + validateFilePath ( fileName ) { file ⇒ 
 + getFromFile ( file ) 
 + } 
 + } 
 + } 
 + } 
 + } 
 + 
 + def validateFilePath ( path : String ) : Directive1 [ File ] = { 
 + Directive { fileCompl ⇒ 
 + val file = new File ( base , path ) 
 + if ( file . getCanonicalPath . startsWith ( base . getCanonicalPath ) ) 
 + fileCompl ( Tuple1 ( file ) ) 
 + else 
 + reject ( AuthorizationFailedRejection ) 
 + } 
 + 
 + } 
 + } 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / groups / GroupsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / groups / GroupsHandler . scala 
 index 71e221e . . 0925235 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / groups / GroupsHandler . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / groups / GroupsHandler . scala 
 @ @ - 14 , 6 + 14 , 7 @ @ import play . api . libs . json . Json 
 import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . api . rpc . files . FileLocation 
 + import im . actor . server . api . http . RoutesHandler 
 import im . actor . server . api . http . json . JsonImplicits . { errorsFormat , groupInviteInfoFormat } 
 import im . actor . server . api . http . json . { Group , User , AvatarUrls , Errors , GroupInviteInfo } 
 import im . actor . server . util . FileUtils . getFileUrl 
 @ @ - 26 , 9 + 27 , 9 @ @ class GroupsHandler ( s3BucketName : String ) ( 
 system : ActorSystem , 
 ec : ExecutionContext , 
 client : AmazonS3ScalaClient 
 - ) { 
 + ) extends RoutesHandler { 
 
 - def routes : Route = path ( " groups " / " invites " / Segment ) { token ⇒ 
 + override def routes : Route = path ( " groups " / " invites " / Segment ) { token ⇒ 
 get { 
 onComplete ( retrieve ( token ) ) { 
 case Success ( Right ( result ) ) ⇒ 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / status / StatusHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / status / StatusHandler . scala 
 index d7c52d8 . . 1ecfdde 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / status / StatusHandler . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / status / StatusHandler . scala 
 @ @ - 3 , 8 + 3 , 10 @ @ package im . actor . server . api . http . status 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . Route 
 
 - class StatusHandler { 
 - def routes : Route = path ( " status " ) { 
 + import im . actor . server . api . http . RoutesHandler 
 + 
 + class StatusHandler extends RoutesHandler { 
 + override def routes : Route = path ( " status " ) { 
 get { 
 complete ( " " ) 
 } 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / webhooks / WebhooksHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / webhooks / WebhooksHandler . scala 
 index 366a44d . . 82f321c 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / webhooks / WebhooksHandler . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / webhooks / WebhooksHandler . scala 
 @ @ - 8 , 6 + 8 , 7 @ @ import scala . util . { Failure , Success } 
 import akka . http . scaladsl . model . HttpResponse 
 import akka . http . scaladsl . model . StatusCodes . _ 
 import akka . http . scaladsl . server . Directives . _ 
 + import akka . http . scaladsl . server . Route 
 import akka . stream . Materializer 
 import akka . util . Timeout 
 import org . joda . time . DateTime 
 @ @ - 15 , 6 + 16 , 7 @ @ import slick . dbio . DBIO 
 import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . api . rpc . messaging . { Message , TextMessage } 
 + import im . actor . server . api . http . RoutesHandler 
 import im . actor . server . api . http . json . _ 
 import im . actor . server . peermanagers . { GroupPeerManager , GroupPeerManagerRegion } 
 import im . actor . server . persist 
 @ @ - 25 , 11 + 27 , 11 @ @ class WebhooksHandler ( ) ( 
 ec : ExecutionContext , 
 groupPeerManagerRegion : GroupPeerManagerRegion , 
 val materializer : Materializer 
 - ) extends ContentUnmarshaler { 
 + ) extends RoutesHandler with ContentUnmarshaler { 
 
 implicit val timeout : Timeout = Timeout ( 5 . seconds ) 
 
 - def routes = path ( " webhooks " / Segment ) { token ⇒ 
 + override def routes : Route = path ( " webhooks " / Segment ) { token ⇒ 
 post { 
 entity ( as [ Content ] ) { content ⇒ 
 onComplete ( send ( content , token ) ) { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala 
 index 2b7c787 . . 6693118 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala 
 @ @ - 54 , 7 + 54 , 7 @ @ class IntegrationsServiceSpec extends BaseAppSuite with GroupsServiceHelpers { 
 implicit val authSmsConfig = AuthSmsConfig . fromConfig ( system . settings . config . getConfig ( " auth " ) ) 
 implicit val authService = buildAuthService ( ) 
 
 - private val config = HttpApiConfig ( " https : / / actor . im " , " localhost " , 9000 ) 
 + private val config = HttpApiConfig ( " https : / / actor . im " , " localhost " , 9000 , " " ) 
 val service = new IntegrationsServiceImpl ( config ) 
 
 val ( user1 , user1AuthId1 , _ ) = createUser ( ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala 
 index 7173dda . . 51a8b1a 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala 
 @ @ - 4 , 6 + 4 , 8 @ @ import java . nio . file . Paths 
 
 import scala . concurrent . forkjoin . ThreadLocalRandom 
 
 + import akka . http . scaladsl . model . HttpMethods . GET 
 + import akka . http . scaladsl . model . StatusCodes . { OK , BadRequest , NotFound } 
 import org . scalatest . Inside . _ 
 import akka . http . scaladsl . Http 
 import akka . http . scaladsl . model . { HttpMethods , HttpRequest , StatusCodes } 
 @ @ - 11 , 6 + 13 , 7 @ @ import akka . util . ByteString 
 import com . amazonaws . auth . EnvironmentVariableCredentialsProvider 
 import com . amazonaws . services . s3 . transfer . TransferManager 
 import com . github . dwhjames . awswrap . s3 . AmazonS3ScalaClient 
 + import org . specs2 . execute . PendingUntilFixed 
 import play . api . libs . json . _ 
 
 import im . actor . api . rpc . ClientData 
 @ @ - 26 , 16 + 29 , 16 @ @ import im . actor . server . social . SocialManager 
 import im . actor . server . util . { ImageUtils , FileUtils , ACLUtils } 
 import im . actor . server . { BaseAppSuite , models , persist } 
 
 - class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 + class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers with PendingUntilFixed { 
 behavior of " HttpApiFrontend " 
 
 - it should " respond with OK to webhooks text message " in t . textMessage ( ) 
 + " Webhooks handler " should " respond with OK to webhooks text message " in t . textMessage ( ) 
 
 / / it should " respond with OK to webhooks document message " in t . documentMessage ( ) / / TODO : not implemented yet 
 
 / / it should " respond with OK to webhooks image message " in t . imageMessage ( ) / / TODO : not implemented yet 
 
 - it should " respond with JSON message to group invite info with correct invite token " in t . groupInvitesOk ( ) 
 + " Groups handler " should " respond with JSON message to group invite info with correct invite token " in t . groupInvitesOk ( ) 
 
 it should " respond with JSON message with avatar full links to group invite info with correct invite token " in t . groupInvitesAvatars1 ( ) 
 
 @ @ - 43 , 7 + 46 , 13 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 
 it should " respond with Not Acceptable to group invite info with invalid invite token " in t . groupInvitesInvalid ( ) 
 
 - it should " respond BadRequest " in t . malformedMessage ( ) 
 + it should " respond BadRequest to unknown message format " in t . malformedMessage ( ) 
 + 
 + " Files handler " should " serve correct file path " in pendingUntilFixed ( t . filesCorrect ( ) ) 
 + 
 + it should " respond with not found to non existing file " in pendingUntilFixed ( t . notFound ( ) ) 
 + 
 + it should " not allow path traversal " in pendingUntilFixed ( t . pathTraversal ( ) ) 
 
 implicit val sessionRegion = buildSessionRegionProxy ( ) 
 implicit val seqUpdManagerRegion = buildSeqUpdManagerRegion ( ) 
 @ @ - 75 , 7 + 84 , 8 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 val groupName = " Test group " 
 val groupOutPeer = createGroup ( groupName , Set ( user2 . id ) ) . groupPeer 
 
 - val config = HttpApiConfig ( " https : / / api . actor . im " , " localhost " , 9000 ) 
 + val resourcesPath = Paths . get ( getClass . getResource ( " / " ) . toURI ) . toFile . getCanonicalPath 
 + val config = HttpApiConfig ( " https : / / api . actor . im " , " localhost " , 9000 , resourcesPath ) 
 HttpApiFrontend . start ( config , " actor - uploads - test " ) 
 
 val http = Http ( ) 
 @ @ - 90 , 7 + 100 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 entity = " " " { " text " : " Good morning everyone ! " } " " " 
 ) 
 whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 - resp . status shouldEqual StatusCodes . OK 
 + resp . status shouldEqual OK 
 } 
 } 
 } 
 @ @ - 105 , 7 + 115 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 entity = " " " { " document _ url " : " http : / / www . scala - lang . org / docu / files / ScalaReference . pdf " } " " " 
 ) 
 whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 - resp . status shouldEqual StatusCodes . OK 
 + resp . status shouldEqual OK 
 } 
 } 
 } 
 @ @ - 120 , 7 + 130 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 entity = " " " { " image _ url " : " http : / / www . scala - lang . org / resources / img / smooth - spiral . png " } " " " 
 ) 
 whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 - resp . status shouldEqual StatusCodes . OK 
 + resp . status shouldEqual OK 
 } 
 } 
 } 
 @ @ - 135 , 7 + 145 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 entity = " " " { " WRONG " : " Should not be parsed " } " " " 
 ) 
 whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 - resp . status shouldEqual StatusCodes . BadRequest 
 + resp . status shouldEqual BadRequest 
 } 
 } 
 } 
 @ @ - 145 , 11 + 155 , 11 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 val inviteToken = models . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ 
 val request = HttpRequest ( 
 - method = HttpMethods . GET , 
 + method = GET , 
 uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " 
 ) 
 val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 - resp . status shouldEqual StatusCodes . OK 
 + resp . status shouldEqual OK 
 whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ 
 val response = Json . parse ( body ) 
 ( response \ " group " \ " title " ) . as [ String ] shouldEqual groupName 
 @ @ - 173 , 12 + 183 , 12 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 
 whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ 
 val request = HttpRequest ( 
 - method = HttpMethods . GET , 
 + method = GET , 
 uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " 
 ) 
 
 val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 - resp . status shouldEqual StatusCodes . OK 
 + resp . status shouldEqual OK 
 
 whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ 
 import JsonImplicits . avatarUrlsFormat 
 @ @ - 214 , 11 + 224 , 11 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 val inviteToken = models . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ 
 val request = HttpRequest ( 
 - method = HttpMethods . GET , 
 + method = GET , 
 uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " 
 ) 
 val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 - resp . status shouldEqual StatusCodes . OK 
 + resp . status shouldEqual OK 
 whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ 
 import JsonImplicits . avatarUrlsFormat 
 
 @ @ - 240 , 13 + 250 , 56 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 def groupInvitesInvalid ( ) = { 
 val invalidToken = " Dkajsdljasdlkjaskdj329u90u32jdjlksRandom _ stuff " 
 val request = HttpRequest ( 
 - method = HttpMethods . GET , 
 + method = GET , 
 uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ invalidToken " 
 ) 
 val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 resp . status shouldEqual StatusCodes . NotAcceptable 
 } 
 
 + def notFound ( ) = { 
 + val request = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / neverExisted . txt " ) 
 + whenReady ( http . singleRequest ( request ) ) { resp ⇒ 
 + resp . status shouldEqual NotFound 
 + } 
 + } 
 + 
 + def pathTraversal ( ) = { 
 + val attack1 = " % 2e % 2e % 2f % 2e % 2e % 2f % 2e % 2e % 2fetc % 2Fpasswd " 
 + val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / $ attack1 " ) 
 + whenReady ( http . singleRequest ( r1 ) ) { resp ⇒ 
 + resp . status shouldEqual BadRequest 
 + } 
 + val attack2 = " . . % 2F . . % 2F . . % 2Fetc % 2Fpasswd " 
 + val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / $ attack2 " ) 
 + whenReady ( http . singleRequest ( r2 ) ) { resp ⇒ 
 + resp . status shouldEqual BadRequest 
 + } 
 + val attack3 = " . . / . . / . . / etc / passwd " 
 + val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / $ attack3 " ) 
 + whenReady ( http . singleRequest ( r3 ) ) { resp ⇒ 
 + resp . status shouldEqual NotFound 
 + } 
 + } 
 + 
 + def filesCorrect ( ) = { 
 + val r1 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / reference . conf " ) 
 + whenReady ( http . singleRequest ( r1 ) ) { resp ⇒ 
 + resp . status shouldEqual OK 
 + } 
 + val r2 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / logback . xml " ) 
 + whenReady ( http . singleRequest ( r2 ) ) { resp ⇒ 
 + resp . status shouldEqual OK 
 + } 
 + val r3 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / valid - avatar . jpg " ) 
 + whenReady ( http . singleRequest ( r3 ) ) { resp ⇒ 
 + resp . status shouldEqual OK 
 + } 
 + val r4 = HttpRequest ( GET , s " http : / / $ { config . interface } : $ { config . port } / v1 / files / application . conf . example " ) 
 + whenReady ( http . singleRequest ( r4 ) ) { resp ⇒ 
 + resp . status shouldEqual OK 
 + } 
 + } 
 } 
 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / src / main / resources / application . conf . example b / actor - server / src / main / resources / application . conf . example 
 index bc9d1e1 . . 6bb7e98 100644 
 - - - a / actor - server / src / main / resources / application . conf . example 
 + + + b / actor - server / src / main / resources / application . conf . example 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 # Example configuration for Actor Platform 
 - # This file use HOCON syntax ( https : / / github . com / typesafehub / config / blob / master / HOCON . md ) 
 - # For starting server you need : 
 + # This file uses HOCON syntax ( https : / / github . com / typesafehub / config / blob / master / HOCON . md ) 
 + # To start server you need : 
 # * Configure PostgreSQL service 
 # * Configure one of supported SMS gateway service ( Telesign , Clickatel , Twilio ) 
 # or 
 @ @ - 73 , 11 + 73 , 12 @ @ network { 
 
 # HTTP Api used in simple REST API 
 http - api { 
 - # Please , change for actual API Uri 
 + # Please , replace with actual API Uri 
 base - uri : " https : / / localhost / api " 
 host : " 0 . 0 . 0 . 0 " 
 port : 443 
 keystore : main 
 + static - files - directory : " / home / user / actor - files " 
 } 
 }
