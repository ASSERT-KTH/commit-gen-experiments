BLEU SCORE: 0.18168644632623684

TEST MSG: feat ( server ) : favourite dialogs
GENERATED MSG: feat ( server : messaging ) : show / hide dialogs

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 473391e . . b8abc2c 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 26 , 6 + 26 , 8 @ @ message DialogCommands { < nl > SetReaction set _ reaction = 9 ; < nl > RemoveReaction remove _ reaction = 10 ; < nl > WriteMessageSelf write _ message _ self = 11 ; < nl > + Favourite favourite = 12 ; < nl > + Unfavourite unfavourite = 13 ; < nl > } < nl > } < nl > < nl > @ @ - 102 , 6 + 104 , 18 @ @ message DialogCommands { < nl > required Peer dest = 1 ; < nl > } < nl > < nl > + message Favourite { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + < nl > + required Peer dest = 1 ; < nl > + } < nl > + < nl > + message Unfavourite { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + < nl > + required Peer dest = 1 ; < nl > + } < nl > + < nl > message Delete { < nl > option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index bc739cb . . 00ad1ee 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 170 , 7 + 170 , 6 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > if ( state . isHidden ) < nl > sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) < nl > else { < nl > - < nl > val future = < nl > ( for { < nl > _ ← db . run ( for { < nl > @ @ - 186 , 6 + 185 , 38 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } < nl > } < nl > < nl > + protected def favourite ( state : DialogState ) : Unit = { < nl > + if ( state . isFavourite ) < nl > + sender ! Status . Failure ( DialogErrors . DialogAlreadyFavourited ( peer ) ) < nl > + else { < nl > + val future = < nl > + ( for { < nl > + _ ← db . run ( DialogRepo . favourite ( userId , peer ) ) < nl > + seqstate ← userExt . notifyDialogsChanged ( userId ) < nl > + } yield seqstate ) pipeTo sender ( ) < nl > + < nl > + onSuccess ( future ) { _ ⇒ < nl > + updateFavourited ( state ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + protected def unfavourite ( state : DialogState ) : Unit = { < nl > + if ( ! state . isFavourite ) < nl > + sender ! Status . Failure ( DialogErrors . DialogAlreadyUnfavourited ( peer ) ) < nl > + else { < nl > + val future = < nl > + ( for { < nl > + _ ← db . run ( DialogRepo . unfavourite ( userId , peer ) ) < nl > + seqstate ← userExt . notifyDialogsChanged ( userId ) < nl > + } yield seqstate ) pipeTo sender ( ) < nl > + < nl > + onSuccess ( future ) { _ ⇒ < nl > + updateUnfavourited ( state ) < nl > + } < nl > + } < nl > + } < nl > + < nl > protected def delete ( state : DialogState ) : Unit = { < nl > val update = UpdateChatDelete ( peer . asStruct ) < nl > < nl > @ @ - 283 , 4 + 314 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > < nl > private def updateHidden ( state : DialogState ) : Unit = < nl > context become initialized ( state . updated ( Hidden ) ) < nl > + < nl > + private def updateFavourited ( state : DialogState ) : Unit = < nl > + context become initialized ( state . updated ( Favourited ) ) < nl > + < nl > + private def updateUnfavourited ( state : DialogState ) : Unit = < nl > + context become initialized ( state . updated ( Unfavourited ) ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala < nl > index 81f95c2 . . 4ccfc2f 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala < nl > @ @ - 9 , 6 + 9 , 8 @ @ abstract class DialogError ( msg : String ) extends RuntimeException ( msg ) with NoSta < nl > object DialogErrors { < nl > object MessageToSelf extends DialogError ( " Private dialog with self is not allowed " ) < nl > < nl > - final case class DialogAlreadyShown ( peer : Peer ) extends DialogError ( s " Dialog $ { peer } is already shown " ) < nl > - final case class DialogAlreadyHidden ( peer : Peer ) extends DialogError ( s " Dialog $ { peer } is already hidden " ) < nl > + final case class DialogAlreadyShown ( peer : Peer ) extends DialogError ( s " Dialog $ peer is already shown " ) < nl > + final case class DialogAlreadyHidden ( peer : Peer ) extends DialogError ( s " Dialog $ peer is already hidden " ) < nl > + final case class DialogAlreadyFavourited ( peer : Peer ) extends DialogError ( s " Dialog $ peer is already favourited " ) < nl > + final case class DialogAlreadyUnfavourited ( peer : Peer ) extends DialogError ( s " Dialog $ peer is already unfavourited " ) < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 122c465 . . 247eba9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 31 , 6 + 31 , 12 @ @ sealed trait DialogGroup { < nl > } < nl > < nl > object DialogGroups { < nl > + object Favourites extends DialogGroup { < nl > + override def key : String = " favourites " < nl > + < nl > + override def title : String = " Favourites " < nl > + } < nl > + < nl > object Privates extends DialogGroup { < nl > override def key : String = " privates " < nl > < nl > @ @ - 144 , 6 + 150 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > } < nl > < nl > + def favourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withFavourite ( Favourite ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > + < nl > + def unfavourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withUnfavourite ( Unfavourite ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > + < nl > def delete ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > withValidPeer ( peer , userId ) { < nl > ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withDelete ( Delete ( peer ) ) ) . mapTo [ SeqState ] < nl > @ @ - 211 , 23 + 227 , 39 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def isSharedUser ( userId : Int ) : Boolean = userId = = 0 < nl > < nl > def getGroupedDialogs ( userId : Int ) = { < nl > - db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) map ( _ filterNot ( dialogWithSelf ( userId , _ ) ) ) flatMap { Dialogs ⇒ < nl > - val ( groupModels , privateModels ) = Dialogs . foldLeft ( ( Vector . empty [ Dialog ] , Vector . empty [ Dialog ] ) ) { < nl > - case ( ( groupModels , privateModels ) , dialog ) ⇒ < nl > - if ( dialog . peer . typ = = PeerType . Group ) < nl > - ( groupModels : + dialog , privateModels ) < nl > - else < nl > - ( groupModels , privateModels : + dialog ) < nl > - } < nl > - < nl > - for { < nl > - groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) < nl > - privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) < nl > - } yield Vector ( < nl > - ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , < nl > - ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) < nl > - ) < nl > - } ) < nl > + db . run { < nl > + DialogRepo < nl > + . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) < nl > + . map ( _ filterNot ( dialogWithSelf ( userId , _ ) ) ) < nl > + . flatMap { Dialogs ⇒ < nl > + val ( groupModels , privateModels , favouriteModels ) = < nl > + Dialogs . foldLeft ( ( Vector . empty [ Dialog ] , Vector . empty [ Dialog ] , Vector . empty [ Dialog ] ) ) { < nl > + case ( ( groupModels , privateModels , favouriteModels ) , dialog ) ⇒ < nl > + if ( dialog . isFavourite ) < nl > + ( groupModels , privateModels , favouriteModels : + dialog ) < nl > + else if ( dialog . peer . typ = = PeerType . Group ) < nl > + ( groupModels : + dialog , privateModels , favouriteModels ) < nl > + else if ( dialog . peer . typ = = PeerType . Private ) < nl > + ( groupModels , privateModels : + dialog , favouriteModels ) < nl > + else throw new RuntimeException ( " Unknown dialog type " ) < nl > + } < nl > + < nl > + for { < nl > + groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) < nl > + privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) < nl > + favouriteDialogs ← DBIO . sequence ( favouriteModels map getDialogShort ) < nl > + } yield { < nl > + val default = Vector ( < nl > + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , < nl > + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) < nl > + ) < nl > + < nl > + if ( favouriteDialogs . nonEmpty ) < nl > + ApiDialogGroup ( DialogGroups . Favourites . title , DialogGroups . Favourites . key , favouriteDialogs ) + : default < nl > + else default < nl > + } < nl > + } < nl > + } < nl > } < nl > < nl > def dialogWithSelf ( userId : Int , dialog : Dialog ) : Boolean = < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index d21c9b4 . . a6a0bf0 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 34 , 6 + 34 , 7 @ @ object DialogEvents { < nl > lastReceiveDate : Long , < nl > lastReadDate : Long , < nl > isHidden : Boolean , < nl > + isFavourite : Boolean , < nl > isOpen : Boolean < nl > ) extends DialogEvent < nl > < nl > @ @ - 46 , 6 + 47 , 9 @ @ object DialogEvents { < nl > private [ dialog ] case object Shown extends DialogEvent < nl > private [ dialog ] case object Hidden extends DialogEvent < nl > < nl > + private [ dialog ] case object Favourited extends DialogEvent < nl > + private [ dialog ] case object Unfavourited extends DialogEvent < nl > + < nl > / / Event which means there was a message sent to all dialog participant < nl > / / Closed dialog means dialog with only ServiceMessage like ContactRegistered < nl > private [ dialog ] case object Open extends DialogEvent < nl > @ @ - 58 , 8 + 62 , 9 @ @ private [ dialog ] object DialogState { < nl > lastReceiveDate : Long , < nl > lastReadDate : Long , < nl > isHidden : Boolean , < nl > + isFavourite : Boolean , < nl > isOpen : Boolean < nl > - ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isOpen ) < nl > + ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isOpen ) < nl > } < nl > < nl > private [ dialog ] final case class DialogState ( < nl > @ @ - 67 , 6 + 72 , 7 @ @ private [ dialog ] final case class DialogState ( < nl > lastReceiveDate : Long , < nl > lastReadDate : Long , < nl > isHidden : Boolean , < nl > + isFavourite : Boolean , < nl > isOpen : Boolean < nl > ) extends ProcessorState [ DialogState ] { < nl > import DialogEvents . _ < nl > @ @ - 76 , 6 + 82 , 8 @ @ private [ dialog ] final case class DialogState ( < nl > case LastReadDate ( date ) if date > this . lastReadDate ⇒ this . copy ( lastReadDate = date ) < nl > case Shown ⇒ this . copy ( isHidden = false ) < nl > case Hidden ⇒ this . copy ( isHidden = true ) < nl > + case Favourited ⇒ this . copy ( isFavourite = true ) < nl > + case Unfavourited ⇒ this . copy ( isFavourite = false ) < nl > case Open ⇒ this . copy ( isOpen = true ) < nl > case unm ⇒ this < nl > } < nl > @ @ - 135 , 8 + 143 , 8 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > override def receive : Receive = initializing < nl > < nl > def initializing : Receive = receiveStashing ( replyTo ⇒ { < nl > - case Initialized ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isOpen ) ⇒ < nl > - context become initialized ( DialogState . init ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isOpen ) ) < nl > + case Initialized ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isOpen ) ⇒ < nl > + context become initialized ( DialogState . init ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isOpen ) ) < nl > unstashAll ( ) < nl > case Status . Failure ( e ) ⇒ < nl > log . error ( e , " Failed to init dialog " ) < nl > @ @ - 158 , 6 + 166 , 8 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) < nl > case Show ( _ ) ⇒ show ( state ) < nl > case Hide ( _ ) ⇒ hide ( state ) < nl > + case Favourite ( _ ) ⇒ favourite ( state ) < nl > + case Unfavourite ( _ ) ⇒ unfavourite ( state ) < nl > case Delete ( _ ) ⇒ delete ( state ) < nl > } < nl > < nl > @ @ - 206 , 6 + 216 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > dialog . ownerLastReceivedAt . getMillis , < nl > dialog . ownerLastReadAt . getMillis , < nl > dialog . shownAt . isEmpty , < nl > + dialog . isFavourite , < nl > isOpen < nl > ) ) pipeTo self < nl > < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / Dialog . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / Dialog . scala < nl > index 1c44a26 . . 191b303 100644 < nl > - - - a / actor - server / actor - models / src / main / scala / im / actor / server / model / Dialog . scala < nl > + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / Dialog . scala < nl > @ @ - 4 , 22 + 4 , 22 @ @ import org . joda . time . DateTime < nl > < nl > object Dialog { < nl > def apply ( userId : Int , peer : Peer ) : Dialog = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) < nl > < nl > def withLastMessageDate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) = < nl > - Dialog ( userId , peer , lastMessageDate , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) < nl > + Dialog ( userId , peer , lastMessageDate , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) < nl > < nl > def withLastReceivedAt ( userId : Int , peer : Peer , lastReceivedAt : DateTime ) = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , lastReceivedAt , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , lastReceivedAt , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) < nl > < nl > def withOwnerLastReceivedAt ( userId : Int , peer : Peer , ownerLastReceivedAt : DateTime ) = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReceivedAt , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReceivedAt , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) < nl > < nl > def withLastReadAt ( userId : Int , peer : Peer , lastReadAt : DateTime ) = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , lastReadAt , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , lastReadAt , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) < nl > < nl > def withOwnerLastReadAt ( userId : Int , peer : Peer , ownerLastReadAt : DateTime ) = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReadAt , Some ( new DateTime ) , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReadAt , Some ( new DateTime ) , false , false , new DateTime ) < nl > } < nl > < nl > @ SerialVersionUID ( 1L ) < nl > @ @ - 32 , 6 + 32 , 7 @ @ case class Dialog ( < nl > ownerLastReceivedAt : DateTime , < nl > ownerLastReadAt : DateTime , < nl > shownAt : Option [ DateTime ] , < nl > + isFavourite : Boolean , < nl > isArchived : Boolean , < nl > createdAt : DateTime < nl > ) < nl > diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20151221164145 _ _ AddIsFavouriteToDialogs . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20151221164145 _ _ AddIsFavouriteToDialogs . sql < nl > new file mode 100644 < nl > index 0000000 . . a8caa76 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20151221164145 _ _ AddIsFavouriteToDialogs . sql < nl > @ @ - 0 , 0 + 1 @ @ < nl > + ALTER TABLE dialogs ADD COLUMN is _ favourite BOOLEAN NOT NULL DEFAULT FALSE < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > index 5c3156a . . 0d93aae 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > @ @ - 31 , 6 + 31 , 8 @ @ final class DialogTable ( tag : Tag ) extends Table [ Dialog ] ( tag , " dialogs " ) { < nl > < nl > def shownAt = column [ Option [ DateTime ] ] ( " shown _ at " ) < nl > < nl > + def isFavourite = column [ Boolean ] ( " is _ favourite " ) < nl > + < nl > def isArchived = column [ Boolean ] ( " is _ archived " ) < nl > < nl > def createdAt = column [ DateTime ] ( " created _ at " ) < nl > @ @ - 45 , 11 + 47 , 12 @ @ final class DialogTable ( tag : Tag ) extends Table [ Dialog ] ( tag , " dialogs " ) { < nl > ownerLastReceivedAt , < nl > ownerLastReadAt , < nl > shownAt , < nl > + isFavourite , < nl > isArchived , < nl > createdAt < nl > ) < > ( applyDialog . tupled , unapplyDialog ) < nl > < nl > - def applyDialog : ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Option [ DateTime ] , Boolean , DateTime ) ⇒ Dialog = { < nl > + def applyDialog : ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Option [ DateTime ] , Boolean , Boolean , DateTime ) ⇒ Dialog = { < nl > case ( < nl > userId , < nl > peerType , < nl > @ @ - 59 , 7 + 62 , 8 @ @ final class DialogTable ( tag : Tag ) extends Table [ Dialog ] ( tag , " dialogs " ) { < nl > lastReadAt , < nl > ownerLastReceivedAt , < nl > ownerLastReadAt , < nl > - isHidden , < nl > + shownAt , < nl > + isFavourite , < nl > isArchived , < nl > createdAt ) ⇒ < nl > Dialog ( < nl > @ @ - 70 , 16 + 74 , 17 @ @ final class DialogTable ( tag : Tag ) extends Table [ Dialog ] ( tag , " dialogs " ) { < nl > lastReadAt = lastReadAt , < nl > ownerLastReceivedAt = ownerLastReceivedAt , < nl > ownerLastReadAt = ownerLastReadAt , < nl > - shownAt = isHidden , < nl > + shownAt = shownAt , < nl > + isFavourite = isFavourite , < nl > isArchived = isArchived , < nl > createdAt = createdAt < nl > ) < nl > } < nl > < nl > - def unapplyDialog : Dialog ⇒ Option [ ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Option [ DateTime ] , Boolean , DateTime ) ] = { dialog ⇒ < nl > + def unapplyDialog : Dialog ⇒ Option [ ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Option [ DateTime ] , Boolean , Boolean , DateTime ) ] = { dialog ⇒ < nl > Dialog . unapply ( dialog ) . map { < nl > - case ( userId , peer , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isHidden , isArchived , createdAt ) ⇒ < nl > - ( userId , peer . typ . value , peer . id , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isHidden , isArchived , createdAt ) < nl > + case ( userId , peer , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , shownAt , isFavourite , isArchived , createdAt ) ⇒ < nl > + ( userId , peer . typ . value , peer . id , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , shownAt , isFavourite , isArchived , createdAt ) < nl > } < nl > } < nl > } < nl > @ @ - 184 , 6 + 189 , 12 @ @ object DialogRepo { < nl > def show ( userId : Int , peer : Peer ) = < nl > byPKC . applied ( ( userId , peer . typ . value , peer . id ) ) . map ( _ . shownAt ) . update ( Some ( new DateTime ) ) < nl > < nl > + def favourite ( userId : Int , peer : Peer ) = < nl > + byPKC . applied ( ( userId , peer . typ . value , peer . id ) ) . map ( _ . isFavourite ) . update ( true ) < nl > + < nl > + def unfavourite ( userId : Int , peer : Peer ) = < nl > + byPKC . applied ( ( userId , peer . typ . value , peer . id ) ) . map ( _ . isFavourite ) . update ( false ) < nl > + < nl > def updateLastMessageDate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = < nl > byPKC . applied ( ( userId , peer . typ . value , peer . id ) ) . map ( _ . lastMessageDate ) . update ( lastMessageDate ) < nl > < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala < nl > index 95e4968 . . 97fac9f 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala < nl > @ @ - 1 , 18 + 1 , 28 @ @ < nl > package im . actor . server . api . rpc . service . messaging < nl > < nl > import im . actor . api . rpc . messaging . ResponseDialogsOrder < nl > - import im . actor . api . rpc . ClientData < nl > + import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . peers . ApiOutPeer < nl > + import im . actor . server . sequence . SeqState < nl > < nl > import scala . concurrent . Future < nl > < nl > - trait FavouritesHandlers { < nl > + trait FavouritesHandlers extends PeersImplicits { < nl > this : MessagingServiceImpl ⇒ < nl > < nl > override def jhandleFavouriteDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = < nl > - throw new RuntimeException ( " Not implemented " ) < nl > + authorized ( clientData ) { client ⇒ < nl > + for { < nl > + SeqState ( seq , state ) ← dialogExt . favourite ( client . userId , peer . asModel ) < nl > + groups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > + } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups ) ) < nl > + } < nl > < nl > override def jhandleUnfavouriteDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = < nl > - throw new RuntimeException ( " Not implemented " ) < nl > - < nl > + authorized ( clientData ) { client ⇒ < nl > + for { < nl > + SeqState ( seq , state ) ← dialogExt . unfavourite ( client . userId , peer . asModel ) < nl > + groups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > + } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups ) ) < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index ed8255e . . 71a2cbd 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 88 , 11 + 88 , 10 @ @ trait HistoryHandlers { < nl > db . run ( toDBIOAction ( authorizedAction ) ) < nl > } < nl > < nl > - override def jhandleLoadGroupedDialogs ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadGroupedDialogs ] ] = { < nl > - / / TODO : # perf meh , not optimal < nl > - val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ < nl > + override def jhandleLoadGroupedDialogs ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadGroupedDialogs ] ] = < nl > + authorized ( clientData ) { implicit client ⇒ < nl > for { < nl > - dialogGroups ← DBIO . from ( dialogExt . getGroupedDialogs ( client . userId ) ) < nl > + dialogGroups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > ( userIds , groupIds ) = dialogGroups . view . flatMap ( _ . dialogs ) . foldLeft ( ( Seq . empty [ Int ] , Seq . empty [ Int ] ) ) { < nl > case ( ( uids , gids ) , dialog ) ⇒ < nl > dialog . peer . ` type ` match { < nl > @ @ - 100 , 14 + 99 , 11 @ @ trait HistoryHandlers { < nl > case ApiPeerType . Private ⇒ ( uids : + dialog . peer . id , gids ) < nl > } < nl > } < nl > - ( groups , users ) ← DBIO . from ( GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) ) < nl > + ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) < nl > } yield Ok ( ResponseLoadGroupedDialogs ( dialogGroups , users . toVector , groups . toVector ) ) < nl > } < nl > < nl > - db . run ( toDBIOAction ( authorizedAction ) ) < nl > - } < nl > - < nl > - override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = { < nl > + override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > ( for { < nl > seqstate ← dialogExt . hide ( client . userId , peer . asModel ) < nl > @ @ - 117 , 9 + 113 , 8 @ @ trait HistoryHandlers { < nl > Error ( RpcError ( 406 , " DIALOG _ ALREADY _ HIDDEN " , " Dialog is already hidden . " , canTryAgain = false , None ) ) < nl > } < nl > } < nl > - } < nl > < nl > - override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = { < nl > + override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > ( for { < nl > seqstate ← dialogExt . show ( client . userId , peer . asModel ) < nl > @ @ - 129 , 7 + 124 , 6 @ @ trait HistoryHandlers { < nl > Error ( RpcError ( 406 , " DIALOG _ ALREADY _ SHOWN " , " Dialog is already shown . " , canTryAgain = false , None ) ) < nl > } < nl > } < nl > - } < nl > < nl > override def jhandleLoadHistory ( peer : ApiOutPeer , endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadHistory ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > index 980c431 . . dfa62ff 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > @ @ - 27 , 6 + 27 , 8 @ @ final class GroupedDialogsSpec < nl > " Hidden dialogs " should " appear on new message " in appearHidden < nl > it should " appear on show " in appearShown < nl > < nl > + " Favourited dialogs " should " appear on favourite " in appearFavourite < nl > + < nl > import DialogGroups . _ < nl > < nl > private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > @ @ - 187 , 4 + 189 , 19 @ @ final class GroupedDialogsSpec < nl > d2 . peer . id should equal ( bob . id ) < nl > } < nl > } < nl > + < nl > + def appearFavourite ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleFavouriteDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Favourites ) ) { < nl > + case Vector ( d ) ⇒ d . peer . id should equal ( bob . id ) < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / user . proto b / actor - server / actor - core / src / main / protobuf / user . proto < nl > index b78a1be . . 593fb88 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / user . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / user . proto < nl > @ @ - 216 , 8 + 216 , 6 @ @ message UserCommands { < nl > < nl > required int32 user _ id = 1 ; < nl > } < nl > - < nl > - message NotifyDialogsChangedAck { } < nl > } < nl > < nl > message UserQueries { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index ba500ee . . 0716208 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 268 , 8 + 268 , 8 @ @ private [ user ] trait UserCommandHandlers { < nl > protected def notifyDialogsChanged ( user : User ) : Unit = { < nl > ( for { < nl > shortDialogs ← dialogExt . getGroupedDialogs ( user . id ) < nl > - _ ← userExt . broadcastUserUpdate ( user . id , UpdateChatGroupsChanged ( shortDialogs ) , pushText = None , isFat = false , deliveryId = None ) < nl > - } yield NotifyDialogsChangedAck ( ) ) pipeTo sender ( ) < nl > + seqstate ← userExt . broadcastUserUpdate ( user . id , UpdateChatGroupsChanged ( shortDialogs ) , pushText = None , isFat = false , deliveryId = None ) < nl > + } yield seqstate ) pipeTo sender ( ) < nl > } < nl > < nl > protected def addContacts ( < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > index ea7b5f6 . . 655c886 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > @ @ - 102 , 8 + 102 , 8 @ @ private [ user ] sealed trait Commands extends AuthCommands { < nl > else < nl > SeqUpdatesManager . getSeqState ( clientAuthId ) < nl > < nl > - def notifyDialogsChanged ( userId : Int ) : Future [ Unit ] = < nl > - ( processorRegion . ref ? NotifyDialogsChanged ( userId ) ) map ( _ ⇒ ( ) ) < nl > + def notifyDialogsChanged ( userId : Int ) : Future [ SeqState ] = < nl > + ( processorRegion . ref ? NotifyDialogsChanged ( userId ) ) . mapTo [ SeqState ] < nl > < nl > def broadcastUserUpdate ( < nl > userId : Int , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > index 903658f . . 3c13a25 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > @ @ - 80 , 7 + 80 , 6 @ @ object UserProcessor { < nl > 10031 → classOf [ UserCommands . UpdateIsAdmin ] , < nl > 10032 → classOf [ UserCommands . UpdateIsAdminAck ] , < nl > 10033 → classOf [ UserCommands . NotifyDialogsChanged ] , < nl > - 10034 → classOf [ UserCommands . NotifyDialogsChangedAck ] , < nl > 10035 → classOf [ UserCommands . ChangePreferredLanguages ] , < nl > 10036 → classOf [ UserCommands . ChangeTimeZone ] , < nl > < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / Dialog . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / Dialog . scala < nl > index bbef0ac . . 714fa38 100644 < nl > - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / Dialog . scala < nl > + + + b / actor - server / actor - models / src / main / scala / im / actor / server / models / Dialog . scala < nl > @ @ - 4 , 22 + 4 , 22 @ @ import org . joda . time . DateTime < nl > < nl > object Dialog { < nl > def apply ( userId : Int , peer : Peer ) : Dialog = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , false , new DateTime ) < nl > < nl > def withLastMessageDate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) = < nl > - Dialog ( userId , peer , lastMessageDate , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , new DateTime ) < nl > + Dialog ( userId , peer , lastMessageDate , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , false , new DateTime ) < nl > < nl > def withLastReceivedAt ( userId : Int , peer : Peer , lastReceivedAt : DateTime ) = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , lastReceivedAt , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , lastReceivedAt , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , false , new DateTime ) < nl > < nl > def withOwnerLastReceivedAt ( userId : Int , peer : Peer , ownerLastReceivedAt : DateTime ) = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReceivedAt , new DateTime ( 0 ) , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReceivedAt , new DateTime ( 0 ) , false , false , new DateTime ) < nl > < nl > def withLastReadAt ( userId : Int , peer : Peer , lastReadAt : DateTime ) = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , lastReadAt , new DateTime ( 0 ) , new DateTime ( 0 ) , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , lastReadAt , new DateTime ( 0 ) , new DateTime ( 0 ) , false , false , new DateTime ) < nl > < nl > def withOwnerLastReadAt ( userId : Int , peer : Peer , ownerLastReadAt : DateTime ) = < nl > - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReadAt , false , new DateTime ) < nl > + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReadAt , false , false , new DateTime ) < nl > } < nl > < nl > @ SerialVersionUID ( 1L ) < nl > @ @ - 31 , 6 + 31 , 7 @ @ case class Dialog ( < nl > lastReadAt : DateTime , < nl > ownerLastReceivedAt : DateTime , < nl > ownerLastReadAt : DateTime , < nl > + isHidden : Boolean , < nl > isArchived : Boolean , < nl > createdAt : DateTime < nl > ) < nl > diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20151030195855 _ _ AddIsHiddenToDialogs . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20151030195855 _ _ AddIsHiddenToDialogs . sql < nl > new file mode 100644 < nl > index 0000000 . . 19e4fe2 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20151030195855 _ _ AddIsHiddenToDialogs . sql < nl > @ @ - 0 , 0 + 1 , 2 @ @ < nl > + ALTER TABLE dialogs ADD COLUMN is _ hidden BOOLEAN default false ; < nl > + CREATE INDEX on dialogs ( is _ hidden ) ; < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > index c65efdb . . e1e12bc 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > @ @ - 31 , 14 + 31 , 39 @ @ final class DialogTable ( tag : Tag ) extends Table [ models . Dialog ] ( tag , " dialogs " ) { < nl > < nl > def ownerLastReadAt = column [ DateTime ] ( " owner _ last _ read _ at " ) < nl > < nl > + def isHidden = column [ Boolean ] ( " is _ hidden " ) < nl > + < nl > def isArchived = column [ Boolean ] ( " is _ archived " ) < nl > < nl > def createdAt = column [ DateTime ] ( " created _ at " ) < nl > < nl > - def * = ( userId , peerType , peerId , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isArchived , createdAt ) < > ( applyDialog . tupled , unapplyDialog ) < nl > - < nl > - def applyDialog : ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Boolean , DateTime ) ⇒ models . Dialog = { < nl > - case ( userId , peerType , peerId , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isArchived , createdAt ) ⇒ < nl > + def * = ( < nl > + userId , < nl > + peerType , < nl > + peerId , < nl > + lastMessageDate , < nl > + lastReceivedAt , < nl > + lastReadAt , < nl > + ownerLastReceivedAt , < nl > + ownerLastReadAt , < nl > + isHidden , < nl > + isArchived , < nl > + createdAt < nl > + ) < > ( applyDialog . tupled , unapplyDialog ) < nl > + < nl > + def applyDialog : ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Boolean , Boolean , DateTime ) ⇒ models . Dialog = { < nl > + case ( < nl > + userId , < nl > + peerType , < nl > + peerId , < nl > + lastMessageDate , < nl > + lastReceivedAt , < nl > + lastReadAt , < nl > + ownerLastReceivedAt , < nl > + ownerLastReadAt , < nl > + isHidden , < nl > + isArchived , < nl > + createdAt ) ⇒ < nl > models . Dialog ( < nl > userId = userId , < nl > peer = models . Peer ( models . PeerType . fromInt ( peerType ) , peerId ) , < nl > @ @ - 47 , 15 + 72 , 16 @ @ final class DialogTable ( tag : Tag ) extends Table [ models . Dialog ] ( tag , " dialogs " ) { < nl > lastReadAt = lastReadAt , < nl > ownerLastReceivedAt = ownerLastReceivedAt , < nl > ownerLastReadAt = ownerLastReadAt , < nl > + isHidden = isHidden , < nl > isArchived = isArchived , < nl > createdAt = createdAt < nl > ) < nl > } < nl > < nl > - def unapplyDialog : models . Dialog ⇒ Option [ ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Boolean , DateTime ) ] = { dialog ⇒ < nl > + def unapplyDialog : models . Dialog ⇒ Option [ ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Boolean , Boolean , DateTime ) ] = { dialog ⇒ < nl > models . Dialog . unapply ( dialog ) . map { < nl > - case ( userId , peer , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isArchived , createdAt ) ⇒ < nl > - ( userId , peer . typ . toInt , peer . id , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isArchived , createdAt ) < nl > + case ( userId , peer , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isHidden , isArchived , createdAt ) ⇒ < nl > + ( userId , peer . typ . toInt , peer . id , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isHidden , isArchived , createdAt ) < nl > } < nl > } < nl > } < nl > @ @ - 87 , 10 + 113 , 12 @ @ object DialogRepo { < nl > val byPeerTypeC = Compiled ( byPeerType _ ) < nl > val idByPeerTypeC = Compiled ( idByPeerType _ ) < nl > < nl > - val notHiddenDialogs = DialogRepo . dialogs joinLeft GroupRepo . groups on ( _ . peerId = = = _ . id ) filter { < nl > + val notArchived = DialogRepo . dialogs joinLeft GroupRepo . groups on ( _ . peerId = = = _ . id ) filter { < nl > case ( dialog , groupOpt ) ⇒ dialog . isArchived = = = false & & groupOpt . map ( ! _ . isHidden ) . getOrElse ( true ) < nl > } map ( _ . _ 1 ) < nl > < nl > + val notHiddenNotArchived = notArchived filter ( _ . isHidden = = = false ) < nl > + < nl > def create ( dialog : models . Dialog ) = < nl > dialogsC + = dialog < nl > < nl > @ @ - 122 , 14 + 150 , 14 @ @ object DialogRepo { < nl > def findLastReadBefore ( date : DateTime , userId : Int ) = < nl > dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result < nl > < nl > - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = < nl > - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc ) < nl > + def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = < nl > + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) < nl > < nl > - def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = < nl > - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc ) < nl > + def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = < nl > + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > < nl > - def findNotArchived [ A ] ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , sortBy : DialogTable ⇒ ColumnOrdered [ A ] ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = { < nl > - val baseQuery = notHiddenDialogs < nl > + def findNotArchived [ A ] ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , sortBy : DialogTable ⇒ ColumnOrdered [ A ] , fetchHidden : Boolean ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = { < nl > + val baseQuery = ( if ( fetchHidden ) notArchived else notHiddenNotArchived ) < nl > . filter ( d ⇒ d . userId = = = userId ) < nl > . sortBy ( sortBy ) < nl > < nl > @ @ - 152 , 6 + 180 , 12 @ @ object DialogRepo { < nl > } yield result < nl > } < nl > < nl > + def hide ( userId : Int , peer : models . Peer ) = < nl > + byPKC . applied ( ( userId , peer . typ . toInt , peer . id ) ) . map ( _ . isHidden ) . update ( false ) < nl > + < nl > + def show ( userId : Int , peer : models . Peer ) = < nl > + byPKC . applied ( ( userId , peer . typ . toInt , peer . id ) ) . map ( _ . isHidden ) . update ( true ) < nl > + < nl > def updateLastMessageDate ( userId : Int , peer : models . Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = < nl > byPKC . applied ( ( userId , peer . typ . toInt , peer . id ) ) . map ( _ . lastMessageDate ) . update ( lastMessageDate ) < nl > < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala < nl > index 8391b50 . . b004284 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala < nl > @ @ - 120 , 7 + 120 , 7 @ @ object HistoryMessage { < nl > / / в о з м о ж н о т у т н е у ч и т ы в а ю т с я < nl > private def unreadTotal ( userId : Rep [ Int ] ) = < nl > ( for { < nl > - d ← DialogRepo . notHiddenDialogs . filter ( _ . userId = = = userId ) < nl > + d ← DialogRepo . notHiddenNotArchived . filter ( _ . userId = = = userId ) < nl > m ← notDeletedMessages . filter ( _ . senderUserId = ! = userId ) < nl > if m . userId = = = d . userId & & m . peerType = = = d . peerType & & m . peerId = = = d . peerId & & m . date > d . ownerLastReadAt < nl > } yield m . date ) . length < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index 6e3198a . . 283c237 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 3 , 14 + 3 , 13 @ @ package im . actor . server . api . rpc . service . messaging < nl > import im . actor . api . rpc . DBIOResult . _ < nl > import im . actor . api . rpc . PeerHelpers . _ < nl > import im . actor . api . rpc . _ < nl > - import im . actor . api . rpc . Implicits . _ < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . misc . { ResponseSeq , ResponseVoid } < nl > - import im . actor . api . rpc . peers . { ApiPeer , ApiOutPeer , ApiPeerType } < nl > - import im . actor . concurrent . FutureExt < nl > - import im . actor . server . dialog . { HistoryUtils , ReadFailed , ReceiveFailed } < nl > + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType } < nl > + import im . actor . server . dialog . HistoryUtils < nl > import im . actor . server . group . GroupUtils < nl > - import im . actor . server . sequence . { SeqState , SeqUpdatesManager } < nl > + import im . actor . server . persist . DialogRepo < nl > + import im . actor . server . sequence . SeqState < nl > import im . actor . server . user . UserUtils < nl > import im . actor . server . { models , persist } < nl > import org . joda . time . DateTime < nl > @ @ - 27 , 23 + 26 , 15 @ @ trait HistoryHandlers { < nl > import im . actor . api . rpc . Implicits . _ < nl > < nl > override def jhandleMessageReceived ( peer : ApiOutPeer , date : Long , clientData : im . actor . api . rpc . ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > - val action = requireAuth ( clientData ) . map { implicit client ⇒ < nl > - DBIO . from { < nl > - dialogExt . messageReceived ( peer . asPeer , client . userId , date ) map ( _ ⇒ Ok ( ResponseVoid ) ) < nl > - } < nl > + authorized ( clientData ) { client ⇒ < nl > + dialogExt . messageReceived ( peer . asPeer , client . userId , date ) map ( _ ⇒ Ok ( ResponseVoid ) ) < nl > } < nl > - < nl > - db . run ( toDBIOAction ( action ) ) < nl > } < nl > < nl > override def jhandleMessageRead ( peer : ApiOutPeer , date : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > - val action = requireAuth ( clientData ) . map { implicit client ⇒ < nl > - DBIO . from { < nl > - dialogExt . messageRead ( peer . asPeer , client . userId , client . authId , date ) map ( _ ⇒ Ok ( ResponseVoid ) ) < nl > - } < nl > + authorized ( clientData ) { client ⇒ < nl > + dialogExt . messageRead ( peer . asPeer , client . userId , client . authId , date ) map ( _ ⇒ Ok ( ResponseVoid ) ) < nl > } < nl > - < nl > - db . run ( toDBIOAction ( action ) ) < nl > } < nl > < nl > override def jhandleClearChat ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { < nl > @ @ - 82 , 7 + 73 , 7 @ @ trait HistoryHandlers { < nl > < nl > override def jhandleLoadDialogs ( endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > - persist . DialogRepo . findNotArchived ( client . userId , endDateTimeFrom ( endDate ) , limit ) flatMap { dialogModels ⇒ < nl > + persist . DialogRepo . findNotArchived ( client . userId , endDateTimeFrom ( endDate ) , limit , fetchHidden = true ) flatMap { dialogModels ⇒ < nl > for { < nl > dialogs ← DBIO . sequence ( dialogModels map getDialogStruct ) < nl > ( users , groups ) ← getDialogsUsersGroups ( dialogs ) < nl > @ @ - 118 , 9 + 109 , 23 @ @ trait HistoryHandlers { < nl > db . run ( toDBIOAction ( authorizedAction ) ) < nl > } < nl > < nl > - override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = Future . failed ( new RuntimeException ( " Not implemented " ) ) < nl > + override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { < nl > + authorized ( clientData ) { implicit client ⇒ < nl > + for { < nl > + _ ← db . run ( DialogRepo . hide ( client . userId , peer . asModel ) ) < nl > + SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) < nl > + } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) < nl > + } < nl > + } < nl > < nl > - override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = Future . failed ( new RuntimeException ( " Not implemented " ) ) < nl > + override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { < nl > + authorized ( clientData ) { implicit client ⇒ < nl > + for { < nl > + _ ← db . run ( DialogRepo . show ( client . userId , peer . asModel ) ) < nl > + SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) < nl > + } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) < nl > + } < nl > + } < nl > < nl > override def jhandleLoadHistory ( peer : ApiOutPeer , endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadHistory ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > @ @ - 128 , 8 + 133 , 8 @ @ trait HistoryHandlers { < nl > withHistoryOwner ( peer . asModel , client . userId ) { historyOwner ⇒ < nl > persist . DialogRepo . find ( client . userId , peer . asModel ) flatMap { dialogOpt ⇒ < nl > persist . HistoryMessage . find ( historyOwner , peer . asModel , endDateTimeFrom ( endDate ) , limit ) flatMap { messageModels ⇒ < nl > - val lastReceivedAt = dialogOpt map ( _ . lastReceivedAt ) getOrElse ( new DateTime ( 0 ) ) < nl > - val lastReadAt = dialogOpt map ( _ . lastReadAt ) getOrElse ( new DateTime ( 0 ) ) < nl > + val lastReceivedAt = dialogOpt map ( _ . lastReceivedAt ) getOrElse new DateTime ( 0 ) < nl > + val lastReadAt = dialogOpt map ( _ . lastReadAt ) getOrElse new DateTime ( 0 ) < nl > < nl > val ( messages , userIds ) = messageModels . view < nl > . map ( _ . ofUser ( client . userId ) ) < nl > @ @ - 234 , 19 + 239 , 6 @ @ trait HistoryHandlers { < nl > } < nl > } < nl > < nl > - private def getDialogShort ( dialogModel : models . Dialog ) ( implicit client : AuthorizedClientData ) : dbio . DBIO [ ApiDialogShort ] = { < nl > - withHistoryOwner ( dialogModel . peer , client . userId ) { historyOwner ⇒ < nl > - for { < nl > - messageOpt ← persist . HistoryMessage . findNewest ( historyOwner , dialogModel . peer ) map ( _ . map ( _ . ofUser ( client . userId ) ) ) < nl > - unreadCount ← dialogExt . getUnreadCount ( client . userId , historyOwner , dialogModel . peer , dialogModel . ownerLastReadAt ) < nl > - } yield ApiDialogShort ( < nl > - peer = ApiPeer ( ApiPeerType ( dialogModel . peer . typ . toInt ) , dialogModel . peer . id ) , < nl > - counter = unreadCount , < nl > - date = messageOpt . map ( _ . date . getMillis ) . getOrElse ( 0 ) < nl > - ) < nl > - } < nl > - } < nl > - < nl > private def getDialogsUsersGroups ( dialogs : Seq [ ApiDialog ] ) ( implicit client : AuthorizedClientData ) = { < nl > val ( userIds , groupIds ) = dialogs . foldLeft ( ( Set . empty [ Int ] , Set . empty [ Int ] ) ) { < nl > case ( ( uacc , gacc ) , dialog ) ⇒ < nl > @ @ - 259 , 14 + 251 , 14 @ @ trait HistoryHandlers { < nl > < nl > for { < nl > groups ← DBIO . from ( Future . sequence ( groupIds map ( groupExt . getApiStruct ( _ , client . userId ) ) ) ) < nl > - groupUserIds = groups . map ( g ⇒ g . members . map ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) . flatten : + g . creatorUserId ) . flatten < nl > + groupUserIds = groups . flatMap ( g ⇒ g . members . flatMap ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) : + g . creatorUserId ) < nl > users ← DBIO . from ( Future . sequence ( ( userIds + + groupUserIds ) . filterNot ( _ = = 0 ) map ( UserUtils . safeGetUser ( _ , client . userId , client . authId ) ) ) ) map ( _ . flatten ) < nl > } yield ( users , groups ) < nl > } < nl > < nl > private def relatedUsers ( message : ApiMessage ) : Set [ Int ] = { < nl > message match { < nl > - case ApiServiceMessage ( _ , extOpt ) ⇒ extOpt map ( relatedUsers ) getOrElse ( Set . empty ) < nl > + case ApiServiceMessage ( _ , extOpt ) ⇒ extOpt map relatedUsers getOrElse Set . empty < nl > case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . toSet < nl > case ApiJsonMessage ( _ ) ⇒ Set . empty < nl > case _ : ApiDocumentMessage ⇒ Set . empty

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 473391e . . b8abc2c 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 26 , 6 + 26 , 8 @ @ message DialogCommands { 
 SetReaction set _ reaction = 9 ; 
 RemoveReaction remove _ reaction = 10 ; 
 WriteMessageSelf write _ message _ self = 11 ; 
 + Favourite favourite = 12 ; 
 + Unfavourite unfavourite = 13 ; 
 } 
 } 
 
 @ @ - 102 , 6 + 104 , 18 @ @ message DialogCommands { 
 required Peer dest = 1 ; 
 } 
 
 + message Favourite { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + 
 + required Peer dest = 1 ; 
 + } 
 + 
 + message Unfavourite { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + 
 + required Peer dest = 1 ; 
 + } 
 + 
 message Delete { 
 option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index bc739cb . . 00ad1ee 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 170 , 7 + 170 , 6 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 if ( state . isHidden ) 
 sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) 
 else { 
 - 
 val future = 
 ( for { 
 _ ← db . run ( for { 
 @ @ - 186 , 6 + 185 , 38 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } 
 } 
 
 + protected def favourite ( state : DialogState ) : Unit = { 
 + if ( state . isFavourite ) 
 + sender ! Status . Failure ( DialogErrors . DialogAlreadyFavourited ( peer ) ) 
 + else { 
 + val future = 
 + ( for { 
 + _ ← db . run ( DialogRepo . favourite ( userId , peer ) ) 
 + seqstate ← userExt . notifyDialogsChanged ( userId ) 
 + } yield seqstate ) pipeTo sender ( ) 
 + 
 + onSuccess ( future ) { _ ⇒ 
 + updateFavourited ( state ) 
 + } 
 + } 
 + } 
 + 
 + protected def unfavourite ( state : DialogState ) : Unit = { 
 + if ( ! state . isFavourite ) 
 + sender ! Status . Failure ( DialogErrors . DialogAlreadyUnfavourited ( peer ) ) 
 + else { 
 + val future = 
 + ( for { 
 + _ ← db . run ( DialogRepo . unfavourite ( userId , peer ) ) 
 + seqstate ← userExt . notifyDialogsChanged ( userId ) 
 + } yield seqstate ) pipeTo sender ( ) 
 + 
 + onSuccess ( future ) { _ ⇒ 
 + updateUnfavourited ( state ) 
 + } 
 + } 
 + } 
 + 
 protected def delete ( state : DialogState ) : Unit = { 
 val update = UpdateChatDelete ( peer . asStruct ) 
 
 @ @ - 283 , 4 + 314 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 
 private def updateHidden ( state : DialogState ) : Unit = 
 context become initialized ( state . updated ( Hidden ) ) 
 + 
 + private def updateFavourited ( state : DialogState ) : Unit = 
 + context become initialized ( state . updated ( Favourited ) ) 
 + 
 + private def updateUnfavourited ( state : DialogState ) : Unit = 
 + context become initialized ( state . updated ( Unfavourited ) ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala 
 index 81f95c2 . . 4ccfc2f 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogErrors . scala 
 @ @ - 9 , 6 + 9 , 8 @ @ abstract class DialogError ( msg : String ) extends RuntimeException ( msg ) with NoSta 
 object DialogErrors { 
 object MessageToSelf extends DialogError ( " Private dialog with self is not allowed " ) 
 
 - final case class DialogAlreadyShown ( peer : Peer ) extends DialogError ( s " Dialog $ { peer } is already shown " ) 
 - final case class DialogAlreadyHidden ( peer : Peer ) extends DialogError ( s " Dialog $ { peer } is already hidden " ) 
 + final case class DialogAlreadyShown ( peer : Peer ) extends DialogError ( s " Dialog $ peer is already shown " ) 
 + final case class DialogAlreadyHidden ( peer : Peer ) extends DialogError ( s " Dialog $ peer is already hidden " ) 
 + final case class DialogAlreadyFavourited ( peer : Peer ) extends DialogError ( s " Dialog $ peer is already favourited " ) 
 + final case class DialogAlreadyUnfavourited ( peer : Peer ) extends DialogError ( s " Dialog $ peer is already unfavourited " ) 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 122c465 . . 247eba9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 31 , 6 + 31 , 12 @ @ sealed trait DialogGroup { 
 } 
 
 object DialogGroups { 
 + object Favourites extends DialogGroup { 
 + override def key : String = " favourites " 
 + 
 + override def title : String = " Favourites " 
 + } 
 + 
 object Privates extends DialogGroup { 
 override def key : String = " privates " 
 
 @ @ - 144 , 6 + 150 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 } 
 
 + def favourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withFavourite ( Favourite ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 + 
 + def unfavourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withUnfavourite ( Unfavourite ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 + 
 def delete ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 withValidPeer ( peer , userId ) { 
 ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withDelete ( Delete ( peer ) ) ) . mapTo [ SeqState ] 
 @ @ - 211 , 23 + 227 , 39 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def isSharedUser ( userId : Int ) : Boolean = userId = = 0 
 
 def getGroupedDialogs ( userId : Int ) = { 
 - db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) map ( _ filterNot ( dialogWithSelf ( userId , _ ) ) ) flatMap { Dialogs ⇒ 
 - val ( groupModels , privateModels ) = Dialogs . foldLeft ( ( Vector . empty [ Dialog ] , Vector . empty [ Dialog ] ) ) { 
 - case ( ( groupModels , privateModels ) , dialog ) ⇒ 
 - if ( dialog . peer . typ = = PeerType . Group ) 
 - ( groupModels : + dialog , privateModels ) 
 - else 
 - ( groupModels , privateModels : + dialog ) 
 - } 
 - 
 - for { 
 - groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) 
 - privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) 
 - } yield Vector ( 
 - ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , 
 - ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) 
 - ) 
 - } ) 
 + db . run { 
 + DialogRepo 
 + . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) 
 + . map ( _ filterNot ( dialogWithSelf ( userId , _ ) ) ) 
 + . flatMap { Dialogs ⇒ 
 + val ( groupModels , privateModels , favouriteModels ) = 
 + Dialogs . foldLeft ( ( Vector . empty [ Dialog ] , Vector . empty [ Dialog ] , Vector . empty [ Dialog ] ) ) { 
 + case ( ( groupModels , privateModels , favouriteModels ) , dialog ) ⇒ 
 + if ( dialog . isFavourite ) 
 + ( groupModels , privateModels , favouriteModels : + dialog ) 
 + else if ( dialog . peer . typ = = PeerType . Group ) 
 + ( groupModels : + dialog , privateModels , favouriteModels ) 
 + else if ( dialog . peer . typ = = PeerType . Private ) 
 + ( groupModels , privateModels : + dialog , favouriteModels ) 
 + else throw new RuntimeException ( " Unknown dialog type " ) 
 + } 
 + 
 + for { 
 + groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) 
 + privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) 
 + favouriteDialogs ← DBIO . sequence ( favouriteModels map getDialogShort ) 
 + } yield { 
 + val default = Vector ( 
 + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , 
 + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) 
 + ) 
 + 
 + if ( favouriteDialogs . nonEmpty ) 
 + ApiDialogGroup ( DialogGroups . Favourites . title , DialogGroups . Favourites . key , favouriteDialogs ) + : default 
 + else default 
 + } 
 + } 
 + } 
 } 
 
 def dialogWithSelf ( userId : Int , dialog : Dialog ) : Boolean = 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index d21c9b4 . . a6a0bf0 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 34 , 6 + 34 , 7 @ @ object DialogEvents { 
 lastReceiveDate : Long , 
 lastReadDate : Long , 
 isHidden : Boolean , 
 + isFavourite : Boolean , 
 isOpen : Boolean 
 ) extends DialogEvent 
 
 @ @ - 46 , 6 + 47 , 9 @ @ object DialogEvents { 
 private [ dialog ] case object Shown extends DialogEvent 
 private [ dialog ] case object Hidden extends DialogEvent 
 
 + private [ dialog ] case object Favourited extends DialogEvent 
 + private [ dialog ] case object Unfavourited extends DialogEvent 
 + 
 / / Event which means there was a message sent to all dialog participant 
 / / Closed dialog means dialog with only ServiceMessage like ContactRegistered 
 private [ dialog ] case object Open extends DialogEvent 
 @ @ - 58 , 8 + 62 , 9 @ @ private [ dialog ] object DialogState { 
 lastReceiveDate : Long , 
 lastReadDate : Long , 
 isHidden : Boolean , 
 + isFavourite : Boolean , 
 isOpen : Boolean 
 - ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isOpen ) 
 + ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isOpen ) 
 } 
 
 private [ dialog ] final case class DialogState ( 
 @ @ - 67 , 6 + 72 , 7 @ @ private [ dialog ] final case class DialogState ( 
 lastReceiveDate : Long , 
 lastReadDate : Long , 
 isHidden : Boolean , 
 + isFavourite : Boolean , 
 isOpen : Boolean 
 ) extends ProcessorState [ DialogState ] { 
 import DialogEvents . _ 
 @ @ - 76 , 6 + 82 , 8 @ @ private [ dialog ] final case class DialogState ( 
 case LastReadDate ( date ) if date > this . lastReadDate ⇒ this . copy ( lastReadDate = date ) 
 case Shown ⇒ this . copy ( isHidden = false ) 
 case Hidden ⇒ this . copy ( isHidden = true ) 
 + case Favourited ⇒ this . copy ( isFavourite = true ) 
 + case Unfavourited ⇒ this . copy ( isFavourite = false ) 
 case Open ⇒ this . copy ( isOpen = true ) 
 case unm ⇒ this 
 } 
 @ @ - 135 , 8 + 143 , 8 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 override def receive : Receive = initializing 
 
 def initializing : Receive = receiveStashing ( replyTo ⇒ { 
 - case Initialized ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isOpen ) ⇒ 
 - context become initialized ( DialogState . init ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isOpen ) ) 
 + case Initialized ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isOpen ) ⇒ 
 + context become initialized ( DialogState . init ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isOpen ) ) 
 unstashAll ( ) 
 case Status . Failure ( e ) ⇒ 
 log . error ( e , " Failed to init dialog " ) 
 @ @ - 158 , 6 + 166 , 8 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) 
 case Show ( _ ) ⇒ show ( state ) 
 case Hide ( _ ) ⇒ hide ( state ) 
 + case Favourite ( _ ) ⇒ favourite ( state ) 
 + case Unfavourite ( _ ) ⇒ unfavourite ( state ) 
 case Delete ( _ ) ⇒ delete ( state ) 
 } 
 
 @ @ - 206 , 6 + 216 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 dialog . ownerLastReceivedAt . getMillis , 
 dialog . ownerLastReadAt . getMillis , 
 dialog . shownAt . isEmpty , 
 + dialog . isFavourite , 
 isOpen 
 ) ) pipeTo self 
 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / Dialog . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / Dialog . scala 
 index 1c44a26 . . 191b303 100644 
 - - - a / actor - server / actor - models / src / main / scala / im / actor / server / model / Dialog . scala 
 + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / Dialog . scala 
 @ @ - 4 , 22 + 4 , 22 @ @ import org . joda . time . DateTime 
 
 object Dialog { 
 def apply ( userId : Int , peer : Peer ) : Dialog = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) 
 
 def withLastMessageDate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) = 
 - Dialog ( userId , peer , lastMessageDate , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) 
 + Dialog ( userId , peer , lastMessageDate , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) 
 
 def withLastReceivedAt ( userId : Int , peer : Peer , lastReceivedAt : DateTime ) = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , lastReceivedAt , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , lastReceivedAt , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) 
 
 def withOwnerLastReceivedAt ( userId : Int , peer : Peer , ownerLastReceivedAt : DateTime ) = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReceivedAt , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReceivedAt , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) 
 
 def withLastReadAt ( userId : Int , peer : Peer , lastReadAt : DateTime ) = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , lastReadAt , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , lastReadAt , new DateTime ( 0 ) , new DateTime ( 0 ) , Some ( new DateTime ) , false , false , new DateTime ) 
 
 def withOwnerLastReadAt ( userId : Int , peer : Peer , ownerLastReadAt : DateTime ) = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReadAt , Some ( new DateTime ) , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReadAt , Some ( new DateTime ) , false , false , new DateTime ) 
 } 
 
 @ SerialVersionUID ( 1L ) 
 @ @ - 32 , 6 + 32 , 7 @ @ case class Dialog ( 
 ownerLastReceivedAt : DateTime , 
 ownerLastReadAt : DateTime , 
 shownAt : Option [ DateTime ] , 
 + isFavourite : Boolean , 
 isArchived : Boolean , 
 createdAt : DateTime 
 ) 
 diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20151221164145 _ _ AddIsFavouriteToDialogs . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20151221164145 _ _ AddIsFavouriteToDialogs . sql 
 new file mode 100644 
 index 0000000 . . a8caa76 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20151221164145 _ _ AddIsFavouriteToDialogs . sql 
 @ @ - 0 , 0 + 1 @ @ 
 + ALTER TABLE dialogs ADD COLUMN is _ favourite BOOLEAN NOT NULL DEFAULT FALSE 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 index 5c3156a . . 0d93aae 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 @ @ - 31 , 6 + 31 , 8 @ @ final class DialogTable ( tag : Tag ) extends Table [ Dialog ] ( tag , " dialogs " ) { 
 
 def shownAt = column [ Option [ DateTime ] ] ( " shown _ at " ) 
 
 + def isFavourite = column [ Boolean ] ( " is _ favourite " ) 
 + 
 def isArchived = column [ Boolean ] ( " is _ archived " ) 
 
 def createdAt = column [ DateTime ] ( " created _ at " ) 
 @ @ - 45 , 11 + 47 , 12 @ @ final class DialogTable ( tag : Tag ) extends Table [ Dialog ] ( tag , " dialogs " ) { 
 ownerLastReceivedAt , 
 ownerLastReadAt , 
 shownAt , 
 + isFavourite , 
 isArchived , 
 createdAt 
 ) < > ( applyDialog . tupled , unapplyDialog ) 
 
 - def applyDialog : ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Option [ DateTime ] , Boolean , DateTime ) ⇒ Dialog = { 
 + def applyDialog : ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Option [ DateTime ] , Boolean , Boolean , DateTime ) ⇒ Dialog = { 
 case ( 
 userId , 
 peerType , 
 @ @ - 59 , 7 + 62 , 8 @ @ final class DialogTable ( tag : Tag ) extends Table [ Dialog ] ( tag , " dialogs " ) { 
 lastReadAt , 
 ownerLastReceivedAt , 
 ownerLastReadAt , 
 - isHidden , 
 + shownAt , 
 + isFavourite , 
 isArchived , 
 createdAt ) ⇒ 
 Dialog ( 
 @ @ - 70 , 16 + 74 , 17 @ @ final class DialogTable ( tag : Tag ) extends Table [ Dialog ] ( tag , " dialogs " ) { 
 lastReadAt = lastReadAt , 
 ownerLastReceivedAt = ownerLastReceivedAt , 
 ownerLastReadAt = ownerLastReadAt , 
 - shownAt = isHidden , 
 + shownAt = shownAt , 
 + isFavourite = isFavourite , 
 isArchived = isArchived , 
 createdAt = createdAt 
 ) 
 } 
 
 - def unapplyDialog : Dialog ⇒ Option [ ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Option [ DateTime ] , Boolean , DateTime ) ] = { dialog ⇒ 
 + def unapplyDialog : Dialog ⇒ Option [ ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Option [ DateTime ] , Boolean , Boolean , DateTime ) ] = { dialog ⇒ 
 Dialog . unapply ( dialog ) . map { 
 - case ( userId , peer , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isHidden , isArchived , createdAt ) ⇒ 
 - ( userId , peer . typ . value , peer . id , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isHidden , isArchived , createdAt ) 
 + case ( userId , peer , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , shownAt , isFavourite , isArchived , createdAt ) ⇒ 
 + ( userId , peer . typ . value , peer . id , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , shownAt , isFavourite , isArchived , createdAt ) 
 } 
 } 
 } 
 @ @ - 184 , 6 + 189 , 12 @ @ object DialogRepo { 
 def show ( userId : Int , peer : Peer ) = 
 byPKC . applied ( ( userId , peer . typ . value , peer . id ) ) . map ( _ . shownAt ) . update ( Some ( new DateTime ) ) 
 
 + def favourite ( userId : Int , peer : Peer ) = 
 + byPKC . applied ( ( userId , peer . typ . value , peer . id ) ) . map ( _ . isFavourite ) . update ( true ) 
 + 
 + def unfavourite ( userId : Int , peer : Peer ) = 
 + byPKC . applied ( ( userId , peer . typ . value , peer . id ) ) . map ( _ . isFavourite ) . update ( false ) 
 + 
 def updateLastMessageDate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = 
 byPKC . applied ( ( userId , peer . typ . value , peer . id ) ) . map ( _ . lastMessageDate ) . update ( lastMessageDate ) 
 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala 
 index 95e4968 . . 97fac9f 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala 
 @ @ - 1 , 18 + 1 , 28 @ @ 
 package im . actor . server . api . rpc . service . messaging 
 
 import im . actor . api . rpc . messaging . ResponseDialogsOrder 
 - import im . actor . api . rpc . ClientData 
 + import im . actor . api . rpc . _ 
 import im . actor . api . rpc . peers . ApiOutPeer 
 + import im . actor . server . sequence . SeqState 
 
 import scala . concurrent . Future 
 
 - trait FavouritesHandlers { 
 + trait FavouritesHandlers extends PeersImplicits { 
 this : MessagingServiceImpl ⇒ 
 
 override def jhandleFavouriteDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = 
 - throw new RuntimeException ( " Not implemented " ) 
 + authorized ( clientData ) { client ⇒ 
 + for { 
 + SeqState ( seq , state ) ← dialogExt . favourite ( client . userId , peer . asModel ) 
 + groups ← dialogExt . getGroupedDialogs ( client . userId ) 
 + } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups ) ) 
 + } 
 
 override def jhandleUnfavouriteDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = 
 - throw new RuntimeException ( " Not implemented " ) 
 - 
 + authorized ( clientData ) { client ⇒ 
 + for { 
 + SeqState ( seq , state ) ← dialogExt . unfavourite ( client . userId , peer . asModel ) 
 + groups ← dialogExt . getGroupedDialogs ( client . userId ) 
 + } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups ) ) 
 + } 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index ed8255e . . 71a2cbd 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 88 , 11 + 88 , 10 @ @ trait HistoryHandlers { 
 db . run ( toDBIOAction ( authorizedAction ) ) 
 } 
 
 - override def jhandleLoadGroupedDialogs ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadGroupedDialogs ] ] = { 
 - / / TODO : # perf meh , not optimal 
 - val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ 
 + override def jhandleLoadGroupedDialogs ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadGroupedDialogs ] ] = 
 + authorized ( clientData ) { implicit client ⇒ 
 for { 
 - dialogGroups ← DBIO . from ( dialogExt . getGroupedDialogs ( client . userId ) ) 
 + dialogGroups ← dialogExt . getGroupedDialogs ( client . userId ) 
 ( userIds , groupIds ) = dialogGroups . view . flatMap ( _ . dialogs ) . foldLeft ( ( Seq . empty [ Int ] , Seq . empty [ Int ] ) ) { 
 case ( ( uids , gids ) , dialog ) ⇒ 
 dialog . peer . ` type ` match { 
 @ @ - 100 , 14 + 99 , 11 @ @ trait HistoryHandlers { 
 case ApiPeerType . Private ⇒ ( uids : + dialog . peer . id , gids ) 
 } 
 } 
 - ( groups , users ) ← DBIO . from ( GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) ) 
 + ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) 
 } yield Ok ( ResponseLoadGroupedDialogs ( dialogGroups , users . toVector , groups . toVector ) ) 
 } 
 
 - db . run ( toDBIOAction ( authorizedAction ) ) 
 - } 
 - 
 - override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = { 
 + override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 ( for { 
 seqstate ← dialogExt . hide ( client . userId , peer . asModel ) 
 @ @ - 117 , 9 + 113 , 8 @ @ trait HistoryHandlers { 
 Error ( RpcError ( 406 , " DIALOG _ ALREADY _ HIDDEN " , " Dialog is already hidden . " , canTryAgain = false , None ) ) 
 } 
 } 
 - } 
 
 - override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = { 
 + override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 ( for { 
 seqstate ← dialogExt . show ( client . userId , peer . asModel ) 
 @ @ - 129 , 7 + 124 , 6 @ @ trait HistoryHandlers { 
 Error ( RpcError ( 406 , " DIALOG _ ALREADY _ SHOWN " , " Dialog is already shown . " , canTryAgain = false , None ) ) 
 } 
 } 
 - } 
 
 override def jhandleLoadHistory ( peer : ApiOutPeer , endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadHistory ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 index 980c431 . . dfa62ff 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 @ @ - 27 , 6 + 27 , 8 @ @ final class GroupedDialogsSpec 
 " Hidden dialogs " should " appear on new message " in appearHidden 
 it should " appear on show " in appearShown 
 
 + " Favourited dialogs " should " appear on favourite " in appearFavourite 
 + 
 import DialogGroups . _ 
 
 private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 @ @ - 187 , 4 + 189 , 19 @ @ final class GroupedDialogsSpec 
 d2 . peer . id should equal ( bob . id ) 
 } 
 } 
 + 
 + def appearFavourite ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleFavouriteDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Favourites ) ) { 
 + case Vector ( d ) ⇒ d . peer . id should equal ( bob . id ) 
 + } 
 + } 
 } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / user . proto b / actor - server / actor - core / src / main / protobuf / user . proto 
 index b78a1be . . 593fb88 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / user . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / user . proto 
 @ @ - 216 , 8 + 216 , 6 @ @ message UserCommands { 
 
 required int32 user _ id = 1 ; 
 } 
 - 
 - message NotifyDialogsChangedAck { } 
 } 
 
 message UserQueries { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index ba500ee . . 0716208 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 268 , 8 + 268 , 8 @ @ private [ user ] trait UserCommandHandlers { 
 protected def notifyDialogsChanged ( user : User ) : Unit = { 
 ( for { 
 shortDialogs ← dialogExt . getGroupedDialogs ( user . id ) 
 - _ ← userExt . broadcastUserUpdate ( user . id , UpdateChatGroupsChanged ( shortDialogs ) , pushText = None , isFat = false , deliveryId = None ) 
 - } yield NotifyDialogsChangedAck ( ) ) pipeTo sender ( ) 
 + seqstate ← userExt . broadcastUserUpdate ( user . id , UpdateChatGroupsChanged ( shortDialogs ) , pushText = None , isFat = false , deliveryId = None ) 
 + } yield seqstate ) pipeTo sender ( ) 
 } 
 
 protected def addContacts ( 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 index ea7b5f6 . . 655c886 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 @ @ - 102 , 8 + 102 , 8 @ @ private [ user ] sealed trait Commands extends AuthCommands { 
 else 
 SeqUpdatesManager . getSeqState ( clientAuthId ) 
 
 - def notifyDialogsChanged ( userId : Int ) : Future [ Unit ] = 
 - ( processorRegion . ref ? NotifyDialogsChanged ( userId ) ) map ( _ ⇒ ( ) ) 
 + def notifyDialogsChanged ( userId : Int ) : Future [ SeqState ] = 
 + ( processorRegion . ref ? NotifyDialogsChanged ( userId ) ) . mapTo [ SeqState ] 
 
 def broadcastUserUpdate ( 
 userId : Int , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 index 903658f . . 3c13a25 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 @ @ - 80 , 7 + 80 , 6 @ @ object UserProcessor { 
 10031 → classOf [ UserCommands . UpdateIsAdmin ] , 
 10032 → classOf [ UserCommands . UpdateIsAdminAck ] , 
 10033 → classOf [ UserCommands . NotifyDialogsChanged ] , 
 - 10034 → classOf [ UserCommands . NotifyDialogsChangedAck ] , 
 10035 → classOf [ UserCommands . ChangePreferredLanguages ] , 
 10036 → classOf [ UserCommands . ChangeTimeZone ] , 
 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / models / Dialog . scala b / actor - server / actor - models / src / main / scala / im / actor / server / models / Dialog . scala 
 index bbef0ac . . 714fa38 100644 
 - - - a / actor - server / actor - models / src / main / scala / im / actor / server / models / Dialog . scala 
 + + + b / actor - server / actor - models / src / main / scala / im / actor / server / models / Dialog . scala 
 @ @ - 4 , 22 + 4 , 22 @ @ import org . joda . time . DateTime 
 
 object Dialog { 
 def apply ( userId : Int , peer : Peer ) : Dialog = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , false , new DateTime ) 
 
 def withLastMessageDate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) = 
 - Dialog ( userId , peer , lastMessageDate , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , new DateTime ) 
 + Dialog ( userId , peer , lastMessageDate , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , false , new DateTime ) 
 
 def withLastReceivedAt ( userId : Int , peer : Peer , lastReceivedAt : DateTime ) = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , lastReceivedAt , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , lastReceivedAt , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , false , false , new DateTime ) 
 
 def withOwnerLastReceivedAt ( userId : Int , peer : Peer , ownerLastReceivedAt : DateTime ) = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReceivedAt , new DateTime ( 0 ) , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReceivedAt , new DateTime ( 0 ) , false , false , new DateTime ) 
 
 def withLastReadAt ( userId : Int , peer : Peer , lastReadAt : DateTime ) = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , lastReadAt , new DateTime ( 0 ) , new DateTime ( 0 ) , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , lastReadAt , new DateTime ( 0 ) , new DateTime ( 0 ) , false , false , new DateTime ) 
 
 def withOwnerLastReadAt ( userId : Int , peer : Peer , ownerLastReadAt : DateTime ) = 
 - Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReadAt , false , new DateTime ) 
 + Dialog ( userId , peer , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , new DateTime ( 0 ) , ownerLastReadAt , false , false , new DateTime ) 
 } 
 
 @ SerialVersionUID ( 1L ) 
 @ @ - 31 , 6 + 31 , 7 @ @ case class Dialog ( 
 lastReadAt : DateTime , 
 ownerLastReceivedAt : DateTime , 
 ownerLastReadAt : DateTime , 
 + isHidden : Boolean , 
 isArchived : Boolean , 
 createdAt : DateTime 
 ) 
 diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20151030195855 _ _ AddIsHiddenToDialogs . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20151030195855 _ _ AddIsHiddenToDialogs . sql 
 new file mode 100644 
 index 0000000 . . 19e4fe2 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20151030195855 _ _ AddIsHiddenToDialogs . sql 
 @ @ - 0 , 0 + 1 , 2 @ @ 
 + ALTER TABLE dialogs ADD COLUMN is _ hidden BOOLEAN default false ; 
 + CREATE INDEX on dialogs ( is _ hidden ) ; 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 index c65efdb . . e1e12bc 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 @ @ - 31 , 14 + 31 , 39 @ @ final class DialogTable ( tag : Tag ) extends Table [ models . Dialog ] ( tag , " dialogs " ) { 
 
 def ownerLastReadAt = column [ DateTime ] ( " owner _ last _ read _ at " ) 
 
 + def isHidden = column [ Boolean ] ( " is _ hidden " ) 
 + 
 def isArchived = column [ Boolean ] ( " is _ archived " ) 
 
 def createdAt = column [ DateTime ] ( " created _ at " ) 
 
 - def * = ( userId , peerType , peerId , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isArchived , createdAt ) < > ( applyDialog . tupled , unapplyDialog ) 
 - 
 - def applyDialog : ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Boolean , DateTime ) ⇒ models . Dialog = { 
 - case ( userId , peerType , peerId , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isArchived , createdAt ) ⇒ 
 + def * = ( 
 + userId , 
 + peerType , 
 + peerId , 
 + lastMessageDate , 
 + lastReceivedAt , 
 + lastReadAt , 
 + ownerLastReceivedAt , 
 + ownerLastReadAt , 
 + isHidden , 
 + isArchived , 
 + createdAt 
 + ) < > ( applyDialog . tupled , unapplyDialog ) 
 + 
 + def applyDialog : ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Boolean , Boolean , DateTime ) ⇒ models . Dialog = { 
 + case ( 
 + userId , 
 + peerType , 
 + peerId , 
 + lastMessageDate , 
 + lastReceivedAt , 
 + lastReadAt , 
 + ownerLastReceivedAt , 
 + ownerLastReadAt , 
 + isHidden , 
 + isArchived , 
 + createdAt ) ⇒ 
 models . Dialog ( 
 userId = userId , 
 peer = models . Peer ( models . PeerType . fromInt ( peerType ) , peerId ) , 
 @ @ - 47 , 15 + 72 , 16 @ @ final class DialogTable ( tag : Tag ) extends Table [ models . Dialog ] ( tag , " dialogs " ) { 
 lastReadAt = lastReadAt , 
 ownerLastReceivedAt = ownerLastReceivedAt , 
 ownerLastReadAt = ownerLastReadAt , 
 + isHidden = isHidden , 
 isArchived = isArchived , 
 createdAt = createdAt 
 ) 
 } 
 
 - def unapplyDialog : models . Dialog ⇒ Option [ ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Boolean , DateTime ) ] = { dialog ⇒ 
 + def unapplyDialog : models . Dialog ⇒ Option [ ( Int , Int , Int , DateTime , DateTime , DateTime , DateTime , DateTime , Boolean , Boolean , DateTime ) ] = { dialog ⇒ 
 models . Dialog . unapply ( dialog ) . map { 
 - case ( userId , peer , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isArchived , createdAt ) ⇒ 
 - ( userId , peer . typ . toInt , peer . id , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isArchived , createdAt ) 
 + case ( userId , peer , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isHidden , isArchived , createdAt ) ⇒ 
 + ( userId , peer . typ . toInt , peer . id , lastMessageDate , lastReceivedAt , lastReadAt , ownerLastReceivedAt , ownerLastReadAt , isHidden , isArchived , createdAt ) 
 } 
 } 
 } 
 @ @ - 87 , 10 + 113 , 12 @ @ object DialogRepo { 
 val byPeerTypeC = Compiled ( byPeerType _ ) 
 val idByPeerTypeC = Compiled ( idByPeerType _ ) 
 
 - val notHiddenDialogs = DialogRepo . dialogs joinLeft GroupRepo . groups on ( _ . peerId = = = _ . id ) filter { 
 + val notArchived = DialogRepo . dialogs joinLeft GroupRepo . groups on ( _ . peerId = = = _ . id ) filter { 
 case ( dialog , groupOpt ) ⇒ dialog . isArchived = = = false & & groupOpt . map ( ! _ . isHidden ) . getOrElse ( true ) 
 } map ( _ . _ 1 ) 
 
 + val notHiddenNotArchived = notArchived filter ( _ . isHidden = = = false ) 
 + 
 def create ( dialog : models . Dialog ) = 
 dialogsC + = dialog 
 
 @ @ - 122 , 14 + 150 , 14 @ @ object DialogRepo { 
 def findLastReadBefore ( date : DateTime , userId : Int ) = 
 dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result 
 
 - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = 
 - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc ) 
 + def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = 
 + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) 
 
 - def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = 
 - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc ) 
 + def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = 
 + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 
 - def findNotArchived [ A ] ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , sortBy : DialogTable ⇒ ColumnOrdered [ A ] ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = { 
 - val baseQuery = notHiddenDialogs 
 + def findNotArchived [ A ] ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , sortBy : DialogTable ⇒ ColumnOrdered [ A ] , fetchHidden : Boolean ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ models . Dialog ] ] = { 
 + val baseQuery = ( if ( fetchHidden ) notArchived else notHiddenNotArchived ) 
 . filter ( d ⇒ d . userId = = = userId ) 
 . sortBy ( sortBy ) 
 
 @ @ - 152 , 6 + 180 , 12 @ @ object DialogRepo { 
 } yield result 
 } 
 
 + def hide ( userId : Int , peer : models . Peer ) = 
 + byPKC . applied ( ( userId , peer . typ . toInt , peer . id ) ) . map ( _ . isHidden ) . update ( false ) 
 + 
 + def show ( userId : Int , peer : models . Peer ) = 
 + byPKC . applied ( ( userId , peer . typ . toInt , peer . id ) ) . map ( _ . isHidden ) . update ( true ) 
 + 
 def updateLastMessageDate ( userId : Int , peer : models . Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = 
 byPKC . applied ( ( userId , peer . typ . toInt , peer . id ) ) . map ( _ . lastMessageDate ) . update ( lastMessageDate ) 
 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala 
 index 8391b50 . . b004284 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala 
 @ @ - 120 , 7 + 120 , 7 @ @ object HistoryMessage { 
 / / в о з м о ж н о т у т н е у ч и т ы в а ю т с я 
 private def unreadTotal ( userId : Rep [ Int ] ) = 
 ( for { 
 - d ← DialogRepo . notHiddenDialogs . filter ( _ . userId = = = userId ) 
 + d ← DialogRepo . notHiddenNotArchived . filter ( _ . userId = = = userId ) 
 m ← notDeletedMessages . filter ( _ . senderUserId = ! = userId ) 
 if m . userId = = = d . userId & & m . peerType = = = d . peerType & & m . peerId = = = d . peerId & & m . date > d . ownerLastReadAt 
 } yield m . date ) . length 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index 6e3198a . . 283c237 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 3 , 14 + 3 , 13 @ @ package im . actor . server . api . rpc . service . messaging 
 import im . actor . api . rpc . DBIOResult . _ 
 import im . actor . api . rpc . PeerHelpers . _ 
 import im . actor . api . rpc . _ 
 - import im . actor . api . rpc . Implicits . _ 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . misc . { ResponseSeq , ResponseVoid } 
 - import im . actor . api . rpc . peers . { ApiPeer , ApiOutPeer , ApiPeerType } 
 - import im . actor . concurrent . FutureExt 
 - import im . actor . server . dialog . { HistoryUtils , ReadFailed , ReceiveFailed } 
 + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType } 
 + import im . actor . server . dialog . HistoryUtils 
 import im . actor . server . group . GroupUtils 
 - import im . actor . server . sequence . { SeqState , SeqUpdatesManager } 
 + import im . actor . server . persist . DialogRepo 
 + import im . actor . server . sequence . SeqState 
 import im . actor . server . user . UserUtils 
 import im . actor . server . { models , persist } 
 import org . joda . time . DateTime 
 @ @ - 27 , 23 + 26 , 15 @ @ trait HistoryHandlers { 
 import im . actor . api . rpc . Implicits . _ 
 
 override def jhandleMessageReceived ( peer : ApiOutPeer , date : Long , clientData : im . actor . api . rpc . ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 - val action = requireAuth ( clientData ) . map { implicit client ⇒ 
 - DBIO . from { 
 - dialogExt . messageReceived ( peer . asPeer , client . userId , date ) map ( _ ⇒ Ok ( ResponseVoid ) ) 
 - } 
 + authorized ( clientData ) { client ⇒ 
 + dialogExt . messageReceived ( peer . asPeer , client . userId , date ) map ( _ ⇒ Ok ( ResponseVoid ) ) 
 } 
 - 
 - db . run ( toDBIOAction ( action ) ) 
 } 
 
 override def jhandleMessageRead ( peer : ApiOutPeer , date : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 - val action = requireAuth ( clientData ) . map { implicit client ⇒ 
 - DBIO . from { 
 - dialogExt . messageRead ( peer . asPeer , client . userId , client . authId , date ) map ( _ ⇒ Ok ( ResponseVoid ) ) 
 - } 
 + authorized ( clientData ) { client ⇒ 
 + dialogExt . messageRead ( peer . asPeer , client . userId , client . authId , date ) map ( _ ⇒ Ok ( ResponseVoid ) ) 
 } 
 - 
 - db . run ( toDBIOAction ( action ) ) 
 } 
 
 override def jhandleClearChat ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { 
 @ @ - 82 , 7 + 73 , 7 @ @ trait HistoryHandlers { 
 
 override def jhandleLoadDialogs ( endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 - persist . DialogRepo . findNotArchived ( client . userId , endDateTimeFrom ( endDate ) , limit ) flatMap { dialogModels ⇒ 
 + persist . DialogRepo . findNotArchived ( client . userId , endDateTimeFrom ( endDate ) , limit , fetchHidden = true ) flatMap { dialogModels ⇒ 
 for { 
 dialogs ← DBIO . sequence ( dialogModels map getDialogStruct ) 
 ( users , groups ) ← getDialogsUsersGroups ( dialogs ) 
 @ @ - 118 , 9 + 109 , 23 @ @ trait HistoryHandlers { 
 db . run ( toDBIOAction ( authorizedAction ) ) 
 } 
 
 - override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = Future . failed ( new RuntimeException ( " Not implemented " ) ) 
 + override def jhandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { 
 + authorized ( clientData ) { implicit client ⇒ 
 + for { 
 + _ ← db . run ( DialogRepo . hide ( client . userId , peer . asModel ) ) 
 + SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) 
 + } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) 
 + } 
 + } 
 
 - override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = Future . failed ( new RuntimeException ( " Not implemented " ) ) 
 + override def jhandleShowDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { 
 + authorized ( clientData ) { implicit client ⇒ 
 + for { 
 + _ ← db . run ( DialogRepo . show ( client . userId , peer . asModel ) ) 
 + SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) 
 + } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) 
 + } 
 + } 
 
 override def jhandleLoadHistory ( peer : ApiOutPeer , endDate : Long , limit : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadHistory ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 @ @ - 128 , 8 + 133 , 8 @ @ trait HistoryHandlers { 
 withHistoryOwner ( peer . asModel , client . userId ) { historyOwner ⇒ 
 persist . DialogRepo . find ( client . userId , peer . asModel ) flatMap { dialogOpt ⇒ 
 persist . HistoryMessage . find ( historyOwner , peer . asModel , endDateTimeFrom ( endDate ) , limit ) flatMap { messageModels ⇒ 
 - val lastReceivedAt = dialogOpt map ( _ . lastReceivedAt ) getOrElse ( new DateTime ( 0 ) ) 
 - val lastReadAt = dialogOpt map ( _ . lastReadAt ) getOrElse ( new DateTime ( 0 ) ) 
 + val lastReceivedAt = dialogOpt map ( _ . lastReceivedAt ) getOrElse new DateTime ( 0 ) 
 + val lastReadAt = dialogOpt map ( _ . lastReadAt ) getOrElse new DateTime ( 0 ) 
 
 val ( messages , userIds ) = messageModels . view 
 . map ( _ . ofUser ( client . userId ) ) 
 @ @ - 234 , 19 + 239 , 6 @ @ trait HistoryHandlers { 
 } 
 } 
 
 - private def getDialogShort ( dialogModel : models . Dialog ) ( implicit client : AuthorizedClientData ) : dbio . DBIO [ ApiDialogShort ] = { 
 - withHistoryOwner ( dialogModel . peer , client . userId ) { historyOwner ⇒ 
 - for { 
 - messageOpt ← persist . HistoryMessage . findNewest ( historyOwner , dialogModel . peer ) map ( _ . map ( _ . ofUser ( client . userId ) ) ) 
 - unreadCount ← dialogExt . getUnreadCount ( client . userId , historyOwner , dialogModel . peer , dialogModel . ownerLastReadAt ) 
 - } yield ApiDialogShort ( 
 - peer = ApiPeer ( ApiPeerType ( dialogModel . peer . typ . toInt ) , dialogModel . peer . id ) , 
 - counter = unreadCount , 
 - date = messageOpt . map ( _ . date . getMillis ) . getOrElse ( 0 ) 
 - ) 
 - } 
 - } 
 - 
 private def getDialogsUsersGroups ( dialogs : Seq [ ApiDialog ] ) ( implicit client : AuthorizedClientData ) = { 
 val ( userIds , groupIds ) = dialogs . foldLeft ( ( Set . empty [ Int ] , Set . empty [ Int ] ) ) { 
 case ( ( uacc , gacc ) , dialog ) ⇒ 
 @ @ - 259 , 14 + 251 , 14 @ @ trait HistoryHandlers { 
 
 for { 
 groups ← DBIO . from ( Future . sequence ( groupIds map ( groupExt . getApiStruct ( _ , client . userId ) ) ) ) 
 - groupUserIds = groups . map ( g ⇒ g . members . map ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) . flatten : + g . creatorUserId ) . flatten 
 + groupUserIds = groups . flatMap ( g ⇒ g . members . flatMap ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) : + g . creatorUserId ) 
 users ← DBIO . from ( Future . sequence ( ( userIds + + groupUserIds ) . filterNot ( _ = = 0 ) map ( UserUtils . safeGetUser ( _ , client . userId , client . authId ) ) ) ) map ( _ . flatten ) 
 } yield ( users , groups ) 
 } 
 
 private def relatedUsers ( message : ApiMessage ) : Set [ Int ] = { 
 message match { 
 - case ApiServiceMessage ( _ , extOpt ) ⇒ extOpt map ( relatedUsers ) getOrElse ( Set . empty ) 
 + case ApiServiceMessage ( _ , extOpt ) ⇒ extOpt map relatedUsers getOrElse Set . empty 
 case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . toSet 
 case ApiJsonMessage ( _ ) ⇒ Set . empty 
 case _ : ApiDocumentMessage ⇒ Set . empty
