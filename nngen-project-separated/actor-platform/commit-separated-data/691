BLEU SCORE: 0.017060130096854434

TEST MSG: fix ( server : session ) : fixed caching logic
GENERATED MSG: Merge branch ' master ' of https : / / github . com / actorapp / actor - platform

TEST DIFF (one line): diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > index f449d25 . . cddb549 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala < nl > @ @ - 224 , 9 + 224 , 10 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L < nl > / / we are trying to deliver this response already , < nl > / / so we cancel previous scheduled resend as client already requested a resend by doubling RPC request < nl > case Some ( responseMessageId ) ⇒ < nl > - for { < nl > - isResendCancelled ← responseBuffer . get ( responseMessageId ) map ( _ . _ 2 . cancel ( ) ) < nl > - } if ( isResendCancelled ) enqueueRpc ( item , responseMessageId ) < nl > + responseBuffer . get ( responseMessageId ) map ( _ . _ 2 . cancel ( ) ) match { < nl > + case Some ( false ) ⇒ < nl > + case _ ⇒ enqueueRpc ( item , responseMessageId ) < nl > + } < nl > / / it ' s a new rpc response < nl > case None ⇒ < nl > val responseMessageId = nextMessageId ( ) < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala < nl > index 1d36cb3 . . 510d89f 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala < nl > @ @ - 153 , 7 + 153 , 7 @ @ private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber wit < nl > case _ ⇒ 0 < nl > } < nl > < nl > - size > config . maxCachedResultSize . value < nl > + size < config . maxCachedResultSize . value < nl > } < nl > < nl > private def enqueueAck ( requestMessageId : Long ) : Unit = enqueue ( None , requestMessageId ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala < nl > index 6f0dca5 . . 8d00b0f 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala < nl > @ @ - 94 , 9 + 94 , 7 @ @ class RawServiceSpec < nl > whenReady ( service . handleRawRequest ( " echo " , " makeEcho " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " query " , ApiStringValue ( " Hello " ) ) ) ) ) ) ) { resp ⇒ < nl > inside ( resp ) { < nl > case Xor . Right ( rawValue ) ⇒ inside ( rawValue . result ) { < nl > - case ApiMapValue ( items ) ⇒ < nl > - items should have length 1 < nl > - items . head shouldEqual ApiMapValueItem ( " echo " , ApiStringValue ( " Hello you back ! " ) ) < nl > + case ApiMapValue ( Vector ( ApiMapValueItem ( " query " , ApiStringValue ( " Hello " ) ) ) ) ⇒ < nl > } < nl > } < nl > } < nl > @ @ - 190 , 18 + 188 , 11 @ @ class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) { < nl > < nl > def echo ( params : Option [ ApiRawValue ] ) : Future [ Response ] = { < nl > onEcho ( ) < nl > - val resp = extractStringFromMap ( params , " query " ) map { q ⇒ < nl > - Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) < nl > - } getOrElse Xor . left ( InvalidParams ) < nl > + val resp = < nl > + params map ( Xor . right ( _ ) ) getOrElse ( Xor . left ( InvalidParams ) ) < nl > Future . successful ( resp ) < nl > } < nl > < nl > - private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = < nl > - optParams flatMap { < nl > - case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( _ , ApiStringValue ( str ) ) ⇒ str } < nl > - case _ ⇒ None < nl > - } < nl > - < nl > def onEcho ( ) : Unit = { } < nl > } < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > index 94ffd56 . . 29c6c7f 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > @ @ - 43 , 7 + 43 , 7 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { < nl > it should " react to SessionHello " in sessions ( ) . hello < nl > it should " send SeqUpdateTooLong " in sessions ( ) . seqUpdateTooLong < nl > it should " cache small results " in sessions ( ) . cacheSmallResults < nl > - it should " not cache big requests " in sessions ( ) . notCacheBigRequests < nl > + it should " not cache big results " in sessions ( ) . notCacheBigResults < nl > < nl > @ volatile var count = 0 < nl > < nl > @ @ - 399 , 7 + 399 , 7 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { < nl > val messageId = Random . nextLong ( ) < nl > count = 0 < nl > < nl > - for ( _ ← 1 to 3 ) < nl > + for ( _ ← 1 to 3 ) { < nl > sendRequest ( < nl > authId , < nl > sessionId , < nl > @ @ - 407 , 14 + 407 , 13 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { < nl > messageId , < nl > RequestRawRequest ( " echo " , " makeEcho " , Some ( ApiStringValue ( " . . . " ) ) ) < nl > ) < nl > - < nl > - for ( _ ← 1 to 3 ) < nl > expectRpcResult ( authId , sessionId , ignoreAcks = true ) < nl > + } < nl > < nl > count shouldBe 1 < nl > } < nl > < nl > - def notCacheBigRequests ( ) : Unit = { < nl > + def notCacheBigResults ( ) : Unit = { < nl > implicit val probe = TestProbe ( ) < nl > < nl > val authId = createAuthId ( ) < nl > @ @ - 430 , 7 + 429 , 7 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { < nl > val messageId = Random . nextLong ( ) < nl > count = 0 < nl > < nl > - for ( _ ← 1 to 3 ) < nl > + for ( _ ← 1 to 3 ) { < nl > sendRequest ( < nl > authId , < nl > sessionId , < nl > @ @ - 438 , 9 + 437 , 8 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { < nl > messageId , < nl > RequestRawRequest ( " echo " , " makeEcho " , Some ( ApiStringValue ( longString ) ) ) < nl > ) < nl > - < nl > - for ( _ ← 1 to 3 ) < nl > expectRpcResult ( authId , sessionId , ignoreAcks = true ) < nl > + } < nl > < nl > count shouldBe 3 < nl > }
NEAREST DIFF (one line): diff - - git a / README . MD b / README . MD < nl > index 8c53a78 . . 061c271 100644 < nl > - - - a / README . MD < nl > + + + b / README . MD < nl > @ @ - 9 , 6 + 9 , 13 @ @ Actor Platform is good for improving enterprise communications , building a messa < nl > < nl > This repository contains all source code of platform whereby you can start your server or / and build your iOS , Android , Web , or Desktop applications . < nl > < nl > + # Currently available clients < nl > + * Android 4 . 0 . 3 + < nl > + * iPhone / iPad 7 . 0 + < nl > + * Web < nl > + < nl > + It is very easy to [ implement your own ] ( http : / / actor . readme . io / docs / apps ) . < nl > + < nl > # Installation < nl > < nl > Building mobile messaging application is a bit complex procedure and you need certain amount of preparations : have developer accounts in Google , Apple , have SSL certificates for your servers , integrate server with various services like SMS gate , push systems , etc . . .

TEST DIFF:
diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 index f449d25 . . cddb549 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Resender . scala 
 @ @ - 224 , 9 + 224 , 10 @ @ private [ session ] class ReSender ( authId : Long , sessionId : Long , firstMessageId : L 
 / / we are trying to deliver this response already , 
 / / so we cancel previous scheduled resend as client already requested a resend by doubling RPC request 
 case Some ( responseMessageId ) ⇒ 
 - for { 
 - isResendCancelled ← responseBuffer . get ( responseMessageId ) map ( _ . _ 2 . cancel ( ) ) 
 - } if ( isResendCancelled ) enqueueRpc ( item , responseMessageId ) 
 + responseBuffer . get ( responseMessageId ) map ( _ . _ 2 . cancel ( ) ) match { 
 + case Some ( false ) ⇒ 
 + case _ ⇒ enqueueRpc ( item , responseMessageId ) 
 + } 
 / / it ' s a new rpc response 
 case None ⇒ 
 val responseMessageId = nextMessageId ( ) 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala 
 index 1d36cb3 . . 510d89f 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala 
 @ @ - 153 , 7 + 153 , 7 @ @ private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber wit 
 case _ ⇒ 0 
 } 
 
 - size > config . maxCachedResultSize . value 
 + size < config . maxCachedResultSize . value 
 } 
 
 private def enqueueAck ( requestMessageId : Long ) : Unit = enqueue ( None , requestMessageId ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala 
 index 6f0dca5 . . 8d00b0f 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala 
 @ @ - 94 , 9 + 94 , 7 @ @ class RawServiceSpec 
 whenReady ( service . handleRawRequest ( " echo " , " makeEcho " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " query " , ApiStringValue ( " Hello " ) ) ) ) ) ) ) { resp ⇒ 
 inside ( resp ) { 
 case Xor . Right ( rawValue ) ⇒ inside ( rawValue . result ) { 
 - case ApiMapValue ( items ) ⇒ 
 - items should have length 1 
 - items . head shouldEqual ApiMapValueItem ( " echo " , ApiStringValue ( " Hello you back ! " ) ) 
 + case ApiMapValue ( Vector ( ApiMapValueItem ( " query " , ApiStringValue ( " Hello " ) ) ) ) ⇒ 
 } 
 } 
 } 
 @ @ - 190 , 18 + 188 , 11 @ @ class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) { 
 
 def echo ( params : Option [ ApiRawValue ] ) : Future [ Response ] = { 
 onEcho ( ) 
 - val resp = extractStringFromMap ( params , " query " ) map { q ⇒ 
 - Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) 
 - } getOrElse Xor . left ( InvalidParams ) 
 + val resp = 
 + params map ( Xor . right ( _ ) ) getOrElse ( Xor . left ( InvalidParams ) ) 
 Future . successful ( resp ) 
 } 
 
 - private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = 
 - optParams flatMap { 
 - case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( _ , ApiStringValue ( str ) ) ⇒ str } 
 - case _ ⇒ None 
 - } 
 - 
 def onEcho ( ) : Unit = { } 
 } 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 index 94ffd56 . . 29c6c7f 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 @ @ - 43 , 7 + 43 , 7 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { 
 it should " react to SessionHello " in sessions ( ) . hello 
 it should " send SeqUpdateTooLong " in sessions ( ) . seqUpdateTooLong 
 it should " cache small results " in sessions ( ) . cacheSmallResults 
 - it should " not cache big requests " in sessions ( ) . notCacheBigRequests 
 + it should " not cache big results " in sessions ( ) . notCacheBigResults 
 
 @ volatile var count = 0 
 
 @ @ - 399 , 7 + 399 , 7 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { 
 val messageId = Random . nextLong ( ) 
 count = 0 
 
 - for ( _ ← 1 to 3 ) 
 + for ( _ ← 1 to 3 ) { 
 sendRequest ( 
 authId , 
 sessionId , 
 @ @ - 407 , 14 + 407 , 13 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { 
 messageId , 
 RequestRawRequest ( " echo " , " makeEcho " , Some ( ApiStringValue ( " . . . " ) ) ) 
 ) 
 - 
 - for ( _ ← 1 to 3 ) 
 expectRpcResult ( authId , sessionId , ignoreAcks = true ) 
 + } 
 
 count shouldBe 1 
 } 
 
 - def notCacheBigRequests ( ) : Unit = { 
 + def notCacheBigResults ( ) : Unit = { 
 implicit val probe = TestProbe ( ) 
 
 val authId = createAuthId ( ) 
 @ @ - 430 , 7 + 429 , 7 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { 
 val messageId = Random . nextLong ( ) 
 count = 0 
 
 - for ( _ ← 1 to 3 ) 
 + for ( _ ← 1 to 3 ) { 
 sendRequest ( 
 authId , 
 sessionId , 
 @ @ - 438 , 9 + 437 , 8 @ @ final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { 
 messageId , 
 RequestRawRequest ( " echo " , " makeEcho " , Some ( ApiStringValue ( longString ) ) ) 
 ) 
 - 
 - for ( _ ← 1 to 3 ) 
 expectRpcResult ( authId , sessionId , ignoreAcks = true ) 
 + } 
 
 count shouldBe 3 
 }

NEAREST DIFF:
diff - - git a / README . MD b / README . MD 
 index 8c53a78 . . 061c271 100644 
 - - - a / README . MD 
 + + + b / README . MD 
 @ @ - 9 , 6 + 9 , 13 @ @ Actor Platform is good for improving enterprise communications , building a messa 
 
 This repository contains all source code of platform whereby you can start your server or / and build your iOS , Android , Web , or Desktop applications . 
 
 + # Currently available clients 
 + * Android 4 . 0 . 3 + 
 + * iPhone / iPad 7 . 0 + 
 + * Web 
 + 
 + It is very easy to [ implement your own ] ( http : / / actor . readme . io / docs / apps ) . 
 + 
 # Installation 
 
 Building mobile messaging application is a bit complex procedure and you need certain amount of preparations : have developer accounts in Google , Apple , have SSL certificates for your servers , integrate server with various services like SMS gate , push systems , etc . . .
