BLEU SCORE: 0.2984745896009823

TEST MSG: wip ( core ) : Playing with default methods
GENERATED MSG: feat ( core ) : Enable Java 8 .

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile < nl > index 11474a8 . . 2a64644 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile < nl > @ @ - 28 , 7 + 28 , 7 @ @ space : = $ { null } $ { null } < nl > J2OBJC _ DISTRIBUTION = $ ( PODS _ ROOT ) / J2ObjC - Framework / Distributive < nl > J2OBJC = $ ( J2OBJC _ DISTRIBUTION ) / j2objc < nl > J2OBJCC = $ ( J2OBJC _ DISTRIBUTION ) / j2objcc < nl > - J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods - source 8 - Xforce - incomplete - java8 < nl > + J2OBJC _ ARGS = - - swift - friendly - use - arc - - generate - deprecated - - doc - comments - g - source 8 - Xforce - incomplete - java8 - - nullability - - strip - reflection < nl > J2OBJCC _ ARGS = - ObjC - fobjc - arc - fembed - bitcode - marker - Wobjc - designated - initializers - g $ ( ARCHFLAGS ) $ ( SDKFLAGS ) - I $ ( J2OBJC _ DISTRIBUTION ) / include < nl > < nl > LIBRARY _ NAME = libactor . so < nl > @ @ - 40 , 9 + 40 , 11 @ @ SOURCE _ ROOTS = \ < nl > 	 $ ( SDK _ ROOT ) / sdk - core / core / core - shared / src / main / java \ < nl > 	 $ ( SDK _ ROOT ) / sdk - core / core / core - cocoa / src / main / java < nl > < nl > - EXCLUDED _ CLASSES = \ < nl > - 	 com . google . j2objc . annotations . ObjectiveCName \ < nl > - com . google . j2objc . annotations . Propery < nl > + EXCLUDED _ CLASSES = < nl > + < nl > + # EXCLUDED _ CLASSES = \ < nl > + # 	 com . google . j2objc . annotations . ObjectiveCName \ < nl > + # com . google . j2objc . annotations . Propery < nl > < nl > PREFIXES = \ < nl > - - prefixes $ ( SDK _ ROOT ) / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties \ < nl > diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Compose / AAGroupMembersController . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Compose / AAGroupMembersController . swift < nl > index 1b87a4f . . 008a40e 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Compose / AAGroupMembersController . swift < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Compose / AAGroupMembersController . swift < nl > @ @ - 76 , 7 + 76 , 7 @ @ public class GroupMembersController : AAContactsListContentController , AAContacts < nl > res . replaceIntAtIndex ( UInt ( i ) , withInt : selected [ i ] . contact . uid ) < nl > } < nl > < nl > - executeSafeOnlySuccess ( Actor . createGroupCommandWithTitle ( groupTitle , withAvatar : nil , withUids : res ) ) { ( val ) - > Void in < nl > + executeSafeOnlySuccess ( Actor . createGroupCommandWithTitle ( groupTitle , withAvatar : nil , withUids : res ) ! ) { ( val ) - > Void in < nl > let gid = ( val as ! JavaLangInteger ) . intValue < nl > if self . groupImage ! = nil { < nl > Actor . changeGroupAvatar ( gid , image : self . groupImage ! ) < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index ca8c14b . . 23d9631 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 8 , 12 + 8 , 10 @ @ import im . actor . core . api . ApiMessage ; < nl > import im . actor . core . modules . ModuleContext ; < nl > import im . actor . core . modules . encryption . entity . EncryptedBox ; < nl > import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; < nl > - import im . actor . core . modules . encryption . entity . OwnPrivateKey ; < nl > import im . actor . core . modules . encryption . entity . SessionId ; < nl > import im . actor . core . modules . encryption . entity . UserKeys ; < nl > import im . actor . core . modules . encryption . entity . UserKeysGroup ; < nl > import im . actor . core . modules . encryption . entity . UserPublicKey ; < nl > - import im . actor . core . util . Hex ; < nl > import im . actor . core . util . ModuleActor ; < nl > import im . actor . core . util . RandomUtils ; < nl > import im . actor . runtime . Crypto ; < nl > @ @ - 24 , 8 + 22 , 9 @ @ import im . actor . runtime . actors . Props ; < nl > import im . actor . runtime . actors . ask . AskCallback ; < nl > import im . actor . runtime . actors . ask . AskMessage ; < nl > import im . actor . runtime . actors . ask . AskResult ; < nl > - import im . actor . runtime . function . ArrayFunction ; < nl > - import im . actor . runtime . function . Map ; < nl > + import im . actor . runtime . function . BiConsumer ; < nl > + import im . actor . runtime . function . Consumer ; < nl > + import im . actor . runtime . function . Function ; < nl > import im . actor . runtime . promise . Promise ; < nl > import im . actor . runtime . promise . PromiseResolver ; < nl > import im . actor . runtime . promise . Promises ; < nl > @ @ - 33 , 11 + 32 , 11 @ @ import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . box . ActorBox ; < nl > import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > - import im . actor . runtime . function . Supplier ; < nl > import im . actor . core . modules . encryption . KeyManagerActor . * ; < nl > import im . actor . core . modules . encryption . EncryptedSessionActor . * ; < nl > < nl > import static im . actor . runtime . promise . Promises . * ; < nl > + import static im . actor . runtime . streams . Streams . * ; < nl > < nl > public class EncryptedPeerActor extends ModuleActor { < nl > < nl > @ @ - 84 , 67 + 83 , 120 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > < nl > private void doEncrypt ( final byte [ ] data , final PromiseResolver < EncryptBoxResponse > future ) { < nl > Log . d ( TAG , " doEncrypt " ) ; < nl > - sequence ( map ( theirKeys . getUserKeysGroups ( ) , src - > { < nl > - Log . d ( TAG , " doEncrypt : map " ) ; < nl > - for ( SessionId sessionId : activeSessions . keySet ( ) ) { < nl > - if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { < nl > - return success ( activeSessions . get ( sessionId ) ) ; < nl > - } < nl > - } < nl > < nl > - Log . d ( TAG , " doEncrypt : not _ found " ) ; < nl > - final UserKeysGroup srcFinal = src ; < nl > - return zip ( sequence ( < nl > - ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , < nl > - ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) < nl > - ) , t - > { < nl > - < nl > - Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; < nl > - < nl > - final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; < nl > - final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; < nl > - < nl > - SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , < nl > - src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; < nl > - ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , < nl > - ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; < nl > - activeSessions . put ( sessionId , res ) ; < nl > - return res ; < nl > - } ) ; < nl > - } ) ) . then ( actorRefs - > { < nl > - < nl > - Log . d ( TAG , " doEncrypt : enc " ) ; < nl > - < nl > - final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > - < nl > - sequence ( Promises . map ( actorRefs , src - > { < nl > - return ask ( src , new EncryptPackage ( encKey ) ) ; < nl > - } ) ) . then ( encryptedPackageRes - > { < nl > - ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < > ( ) ; < nl > - for ( EncryptedPackageRes r : encryptedPackageRes ) { < nl > - encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; < nl > - } < nl > + final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > < nl > - byte [ ] encData ; < nl > - try { < nl > - encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > - } catch ( IntegrityException e ) { < nl > - e . printStackTrace ( ) ; < nl > - future . error ( e ) ; < nl > - return ; < nl > - } < nl > - < nl > - EncryptedBox encryptedBox = new EncryptedBox ( < nl > - encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > - ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > - < nl > - future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; < nl > - } ) . failure ( e - > { < nl > - Log . d ( TAG , " Unable to encrypt all receivers " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - future . error ( e ) ; < nl > - } ) . done ( self ( ) ) ; < nl > - } ) . done ( self ( ) ) ; < nl > + toStream ( theirKeys . getUserKeysGroups ( ) ) < nl > + . map ( new Function < UserKeysGroup , Promise < ActorRef > > ( ) { < nl > + @ Override < nl > + public Promise < ActorRef > apply ( UserKeysGroup keysGroup ) { < nl > + < nl > + Log . d ( TAG , " doEncrypt : map " ) ; < nl > + for ( SessionId sessionId : activeSessions . keySet ( ) ) { < nl > + if ( sessionId . getTheirKeyGroupId ( ) = = keysGroup . getKeyGroupId ( ) ) { < nl > + return success ( activeSessions . get ( sessionId ) ) ; < nl > + } < nl > + } < nl > + < nl > + Log . d ( TAG , " doEncrypt : not _ found " ) ; < nl > + final UserKeysGroup srcFinal = keysGroup ; < nl > + return zip ( sequence ( < nl > + ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , keysGroup . getKeyGroupId ( ) ) ) . cast ( ) , < nl > + ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) < nl > + ) , t - > { < nl > + Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; < nl > + < nl > + final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; < nl > + final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; < nl > + < nl > + SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , < nl > + keysGroup . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; < nl > + ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , < nl > + ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; < nl > + activeSessions . put ( sessionId , res ) ; < nl > + return res ; < nl > + } ) ; < nl > + } < nl > + } ) < nl > + . mapAsync ( new BiConsumer < Promise < ActorRef > , Consumer < ActorRef > > ( ) { < nl > + @ Override < nl > + public void accept ( Promise < ActorRef > actorRefPromise , Consumer < ActorRef > objectConsumer ) { < nl > + actorRefPromise . then ( objectConsumer : : apply ) ; < nl > + } < nl > + } ) ; < nl > + / / . mapAsync ( new BiConsumer < Object , Consumer < EncryptedPackageRes > > ( ) { < nl > + / / @ Override < nl > + / / public void accept ( Object actorRef , Consumer < EncryptedPackageRes > objectConsumer ) { < nl > + / / ask ( ( ActorRef ) actorRef , new EncryptPackage ( encKey ) ) < nl > + / / . then ( encryptedPackageRes - > objectConsumer . apply ( encryptedPackageRes ) ) < nl > + / / . failure ( e - > { < nl > + / / / / TODO : How to handle ? < nl > + / / } ) ; < nl > + / / } < nl > + / / } ) < nl > + / / . toArray ( ) ; < nl > + < nl > + / / sequence ( map ( theirKeys . getUserKeysGroups ( ) , src - > { < nl > + / / Log . d ( TAG , " doEncrypt : map " ) ; < nl > + / / for ( SessionId sessionId : activeSessions . keySet ( ) ) { < nl > + / / if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { < nl > + / / return success ( activeSessions . get ( sessionId ) ) ; < nl > + / / } < nl > + / / } < nl > + / / < nl > + / / Log . d ( TAG , " doEncrypt : not _ found " ) ; < nl > + / / final UserKeysGroup srcFinal = src ; < nl > + / / return zip ( sequence ( < nl > + / / ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , < nl > + / / ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) < nl > + / / ) , t - > { < nl > + / / < nl > + / / Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; < nl > + / / < nl > + / / final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; < nl > + / / final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; < nl > + / / < nl > + / / SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , < nl > + / / src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; < nl > + / / ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , < nl > + / / ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; < nl > + / / activeSessions . put ( sessionId , res ) ; < nl > + / / return res ; < nl > + / / } ) ; < nl > + / / } ) ) . then ( actorRefs - > { < nl > + / / < nl > + / / Log . d ( TAG , " doEncrypt : enc " ) ; < nl > + / / < nl > + / / final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > + / / < nl > + / / sequence ( Promises . map ( actorRefs , src - > { < nl > + / / return ask ( src , new EncryptPackage ( encKey ) ) ; < nl > + / / } ) ) . then ( encryptedPackageRes - > { < nl > + / / ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < > ( ) ; < nl > + / / for ( EncryptedPackageRes r : encryptedPackageRes ) { < nl > + / / encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; < nl > + / / } < nl > + / / < nl > + / / byte [ ] encData ; < nl > + / / try { < nl > + / / encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > + / / } catch ( IntegrityException e ) { < nl > + / / e . printStackTrace ( ) ; < nl > + / / future . error ( e ) ; < nl > + / / return ; < nl > + / / } < nl > + / / < nl > + / / EncryptedBox encryptedBox = new EncryptedBox ( < nl > + / / encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > + / / ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > + / / < nl > + / / future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; < nl > + / / } ) . failure ( e - > { < nl > + / / Log . d ( TAG , " Unable to encrypt all receivers " ) ; < nl > + / / Log . e ( TAG , e ) ; < nl > + / / future . error ( e ) ; < nl > + / / } ) . done ( self ( ) ) ; < nl > + / / } ) . done ( self ( ) ) ; < nl > } < nl > < nl > private void doDecrypt ( final EncryptedBox data , final PromiseResolver < DecryptBoxResponse > future ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index f5481e2 . . 8f8eaaa 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 21 , 7 + 21 , 7 @ @ import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > import im . actor . core . modules . encryption . KeyManagerActor . * ; < nl > import im . actor . runtime . function . ArrayFunction ; < nl > - import im . actor . runtime . function . Supplier ; < nl > + import im . actor . runtime . function . Consumer ; < nl > < nl > public class EncryptedSessionActor extends ModuleActor { < nl > < nl > @ @ - 92 , 13 + 92 , 13 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > return new EncryptedSession ( ownIdentityKey , ownPreKey , theirIdentityKey , theirPreKey , theirKeyGroup ) ; < nl > } < nl > - } ) . then ( new Supplier < EncryptedSession > ( ) { < nl > + } ) . then ( new Consumer < EncryptedSession > ( ) { < nl > @ Override < nl > public void apply ( EncryptedSession encryptedSession ) { < nl > EncryptedSessionActor . this . session = encryptedSession ; < nl > unstashAll ( ) ; < nl > } < nl > - } ) . failure ( new Supplier < Exception > ( ) { < nl > + } ) . failure ( new Consumer < Exception > ( ) { < nl > @ Override < nl > public void apply ( Exception e ) { < nl > Log . w ( TAG , " Session load error " ) ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index c380c33 . . 69ccd59 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 39 , 7 + 39 , 7 @ @ import im . actor . runtime . promise . PromiseResolver ; < nl > import im . actor . runtime . crypto . Curve25519 ; < nl > import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > import im . actor . runtime . crypto . ratchet . RatchetKeySignature ; < nl > - import im . actor . runtime . function . Supplier ; < nl > + import im . actor . runtime . function . Consumer ; < nl > import im . actor . runtime . storage . KeyValueStorage ; < nl > < nl > public class KeyManagerActor extends ModuleActor { < nl > @ @ - 122 , 14 + 122 , 14 @ @ public class KeyManagerActor extends ModuleActor { < nl > signature ) ) ; < nl > } < nl > < nl > - api ( new RequestCreateNewKeyGroup ( apiEncryptionKey , encryption , keys , keySignatures ) ) . then ( new Supplier < ResponseCreateNewKeyGroup > ( ) { < nl > + api ( new RequestCreateNewKeyGroup ( apiEncryptionKey , encryption , keys , keySignatures ) ) . then ( new Consumer < ResponseCreateNewKeyGroup > ( ) { < nl > @ Override < nl > public void apply ( ResponseCreateNewKeyGroup response ) { < nl > ownKeys = ownKeys . setGroupId ( response . getKeyGroupId ( ) ) ; < nl > encryptionKeysStorage . addOrUpdateItem ( 0 , ownKeys . toByteArray ( ) ) ; < nl > onMainKeysReady ( ) ; < nl > } < nl > - } ) . failure ( new Supplier < Exception > ( ) { < nl > + } ) . failure ( new Consumer < Exception > ( ) { < nl > @ Override < nl > public void apply ( Exception e ) { < nl > Log . w ( TAG , " Keys upload error " ) ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties b / actor - sdk / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties < nl > index 9965b75 . . aab82d6 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties < nl > @ @ - 11 , 6 + 11 , 10 @ @ im . actor . runtime . bser : AR < nl > < nl > im . actor . runtime . collections : AR < nl > < nl > + im . actor . runtime . function : AR < nl > + < nl > + im . actor . runtime . promises : AR < nl > + < nl > im . actor . runtime . crypto : AR < nl > im . actor . runtime . crypto . asn1 : AR < nl > im . actor . runtime . crypto . bouncycastle : AR < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java < nl > index 063d466 . . 4736740 100755 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java < nl > @ @ - 19 , 7 + 19 , 7 @ @ import im . actor . runtime . actors . mailbox . Mailbox ; < nl > import im . actor . runtime . actors . messages . DeadLetter ; < nl > import im . actor . runtime . promise . Promise ; < nl > import im . actor . runtime . promise . PromiseResolver ; < nl > - import im . actor . runtime . function . Supplier ; < nl > + import im . actor . runtime . function . Consumer ; < nl > < nl > / * * < nl > * Actor object < nl > @ @ - 285 , 12 + 285 , 12 @ @ public class Actor { < nl > } ) ; < nl > dest . send ( new AskIntRequest ( message , executor ) ) ; < nl > } < nl > - } . then ( new Supplier < Object > ( ) { < nl > + } . then ( new Consumer < Object > ( ) { < nl > @ Override < nl > public void apply ( Object o ) { < nl > self ( ) . send ( new AskIntResult ( id , o ) ) ; < nl > } < nl > - } ) . failure ( new Supplier < Exception > ( ) { < nl > + } ) . failure ( new Consumer < Exception > ( ) { < nl > @ Override < nl > public void apply ( Exception e ) { < nl > self ( ) . send ( new AskIntError ( id , e ) ) ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / bser / BserValues . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / bser / BserValues . java < nl > index 2b1940d . . 6f91821 100755 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / bser / BserValues . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / bser / BserValues . java < nl > @ @ - 126 , 7 + 126 , 7 @ @ public class BserValues { < nl > } < nl > < nl > @ NotNull < nl > - public byte [ ] getBytes ( int id , @ NotNull byte [ ] defValue ) throws IOException { < nl > + public byte [ ] getBytes ( int id , @ Nullable byte [ ] defValue ) throws IOException { < nl > / / TODO : Check defValue = = null ? < nl > if ( fields . containsKey ( id ) ) { < nl > touched . put ( id , true ) ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / BiConsumer . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / BiConsumer . java < nl > new file mode 100644 < nl > index 0000000 . . e8c59e4 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / BiConsumer . java < nl > @ @ - 0 , 0 + 1 , 5 @ @ < nl > + package im . actor . runtime . function ; < nl > + < nl > + public interface BiConsumer < T , U > { < nl > + void accept ( T t , U u ) ; < nl > + } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Consumer . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Consumer . java < nl > new file mode 100644 < nl > index 0000000 . . 91d44ea < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Consumer . java < nl > @ @ - 0 , 0 + 1 , 5 @ @ < nl > + package im . actor . runtime . function ; < nl > + < nl > + public interface Consumer < T > { < nl > + void apply ( T t ) ; < nl > + } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java < nl > index f16e918 . . 985efa4 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java < nl > @ @ - 1 , 9 + 1 , 7 @ @ < nl > package im . actor . runtime . function ; < nl > < nl > + import com . google . j2objc . annotations . ObjectiveCName ; < nl > + < nl > public interface Function < T , R > { < nl > R apply ( T t ) ; < nl > - < nl > - default R apply2 ( T t ) { < nl > - return apply ( t ) ; < nl > - } < nl > } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Supplier . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Supplier . java < nl > deleted file mode 100644 < nl > index 76171c4 . . 0000000 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Supplier . java < nl > + + + / dev / null < nl > @ @ - 1 , 5 + 0 , 0 @ @ < nl > - package im . actor . runtime . function ; < nl > - < nl > - public interface Supplier < T > { < nl > - void apply ( T t ) ; < nl > - } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > index 7a376aa . . f86775f 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > @ @ - 5 , 9 + 5 , 8 @ @ import org . jetbrains . annotations . Nullable ; < nl > < nl > import java . util . ArrayList ; < nl > < nl > - import im . actor . runtime . actors . Actor ; < nl > import im . actor . runtime . actors . ActorRef ; < nl > - import im . actor . runtime . function . Supplier ; < nl > + import im . actor . runtime . function . Consumer ; < nl > < nl > / * * < nl > * Promise support implementations . It is much more like js promises than traditional < nl > @ @ - 38 , 7 + 37 , 7 @ @ public abstract class Promise < T > { < nl > * @ param then supplier for result < nl > * @ return this < nl > * / < nl > - public synchronized Promise < T > then ( final Supplier < T > then ) { < nl > + public synchronized Promise < T > then ( final Consumer < T > then ) { < nl > if ( isFinished ) { < nl > if ( exception = = null ) { < nl > dispatchActor . send ( new Runnable ( ) { < nl > @ @ - 70 , 7 + 69 , 7 @ @ public abstract class Promise < T > { < nl > * @ param failure supplier for exception < nl > * @ return this < nl > * / < nl > - public synchronized Promise < T > failure ( final Supplier < Exception > failure ) { < nl > + public synchronized Promise < T > failure ( final Consumer < Exception > failure ) { < nl > if ( isFinished ) { < nl > if ( exception ! = null ) { < nl > dispatchActor . send ( new Runnable ( ) { < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > index b071798 . . 9f79a96 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > @ @ - 7 , 7 + 7 , 7 @ @ import java . util . Collection ; < nl > < nl > import im . actor . runtime . function . ArrayFunction ; < nl > import im . actor . runtime . function . Map ; < nl > - import im . actor . runtime . function . Supplier ; < nl > + import im . actor . runtime . function . Consumer ; < nl > < nl > public class Promises { < nl > < nl > @ @ - 77 , 7 + 77 , 7 @ @ public class Promises { < nl > final Promise self = this ; < nl > for ( int i = 0 ; i < res . length ; i + + ) { < nl > final int finalI = i ; < nl > - promises [ i ] . then ( new Supplier < T > ( ) { < nl > + promises [ i ] . then ( new Consumer < T > ( ) { < nl > @ Override < nl > public void apply ( T t ) { < nl > if ( self . isFinished ( ) ) { < nl > @ @ - 94 , 7 + 94 , 7 @ @ public class Promises { < nl > < nl > executor . result ( res ) ; < nl > } < nl > - } ) . failure ( new Supplier < Exception > ( ) { < nl > + } ) . failure ( new Consumer < Exception > ( ) { < nl > @ Override < nl > public void apply ( Exception e ) { < nl > if ( self . isFinished ( ) ) { < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Stream . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Stream . java < nl > new file mode 100644 < nl > index 0000000 . . d2c4ab1 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Stream . java < nl > @ @ - 0 , 0 + 1 , 53 @ @ < nl > + package im . actor . runtime . streams ; < nl > + < nl > + import java . util . ArrayList ; < nl > + < nl > + import im . actor . runtime . function . BiConsumer ; < nl > + import im . actor . runtime . function . BiFunction ; < nl > + import im . actor . runtime . function . Consumer ; < nl > + import im . actor . runtime . function . Function ; < nl > + < nl > + public interface Stream < T > { < nl > + < nl > + void forEach ( Consumer < T > consumer ) ; < nl > + < nl > + default void forEachRemaining ( Consumer < T > consumer ) { < nl > + forEach ( consumer ) ; < nl > + } < nl > + < nl > + default < R > Stream < R > map ( Function < T , R > fun ) { < nl > + return consumer1 - > Stream . this . forEach ( t - > consumer1 . apply ( fun . apply ( t ) ) ) ; < nl > + } < nl > + < nl > + default < R > Stream < R > mapAsync ( BiConsumer < T , Consumer < R > > fun ) { < nl > + return consumer - > Stream . this . forEach ( t - > fun . accept ( t , consumer ) ) ; < nl > + } < nl > + < nl > + default Stream < T > concat ( Stream < T > next ) { < nl > + return consumer - > { < nl > + Stream . this . forEachRemaining ( consumer ) ; < nl > + next . forEachRemaining ( consumer ) ; < nl > + } ; < nl > + } < nl > + < nl > + default < R > R reduce ( R init , BiFunction < T , R , R > fun ) { < nl > + final Object [ ] res = { init } ; < nl > + forEachRemaining ( new Consumer < T > ( ) { < nl > + @ Override < nl > + public void apply ( T t ) { < nl > + res [ 0 ] = fun . apply ( t , ( R ) res [ 0 ] ) ; < nl > + } < nl > + } ) ; < nl > + return ( R ) res [ 0 ] ; < nl > + } < nl > + < nl > + default ArrayList < T > toList ( ) { < nl > + ArrayList < T > res = new ArrayList < T > ( ) ; < nl > + forEachRemaining ( t - > res . add ( t ) ) ; < nl > + return res ; < nl > + } < nl > + < nl > + default T [ ] toArray ( ) { < nl > + return ( T [ ] ) toList ( ) . toArray ( ) ; < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Streams . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Streams . java < nl > new file mode 100644 < nl > index 0000000 . . 92d5705 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Streams . java < nl > @ @ - 0 , 0 + 1 , 22 @ @ < nl > + package im . actor . runtime . streams ; < nl > + < nl > + import java . util . Collection ; < nl > + < nl > + public class Streams { < nl > + < nl > + public static < T > Stream < T > toStream ( T [ ] array ) { < nl > + return consumer - > { < nl > + for ( T t : array ) { < nl > + consumer . apply ( t ) ; < nl > + } < nl > + } ; < nl > + } < nl > + < nl > + public static < T > Stream < T > toStream ( Collection < T > collection ) { < nl > + return consumer - > { < nl > + for ( T t : collection ) { < nl > + consumer . apply ( t ) ; < nl > + } < nl > + } ; < nl > + } < nl > + }
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile < nl > index a6a37f9 . . 11474a8 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile < nl > @ @ - 28 , 7 + 28 , 7 @ @ space : = $ { null } $ { null } < nl > J2OBJC _ DISTRIBUTION = $ ( PODS _ ROOT ) / J2ObjC - Framework / Distributive < nl > J2OBJC = $ ( J2OBJC _ DISTRIBUTION ) / j2objc < nl > J2OBJCC = $ ( J2OBJC _ DISTRIBUTION ) / j2objcc < nl > - J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods < nl > + J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods - source 8 - Xforce - incomplete - java8 < nl > J2OBJCC _ ARGS = - ObjC - fobjc - arc - fembed - bitcode - marker - Wobjc - designated - initializers - g $ ( ARCHFLAGS ) $ ( SDKFLAGS ) - I $ ( J2OBJC _ DISTRIBUTION ) / include < nl > < nl > LIBRARY _ NAME = libactor . so < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / build . gradle b / actor - sdk / sdk - core / core / core - shared / build . gradle < nl > index e7791f8 . . c994383 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / build . gradle < nl > + + + b / actor - sdk / sdk - core / core / core - shared / build . gradle < nl > @ @ - 1 , 7 + 1 , 7 @ @ < nl > apply plugin : ' java ' < nl > < nl > compileJava { < nl > - sourceCompatibility = 1 . 6 < nl > + sourceCompatibility = 1 . 8 < nl > targetCompatibility = 1 . 6 < nl > } < nl > < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 6ab8482 . . ca8c14b 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 71 , 109 + 71 , 80 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > sequence ( < nl > ask ( keyManager , new FetchOwnKeyGroup ( ) ) . cast ( ) , < nl > ask ( keyManager , new FetchUserKeyGroups ( uid ) ) . cast ( ) < nl > - ) . then ( new Supplier < Object [ ] > ( ) { < nl > - @ Override < nl > - public void apply ( Object [ ] objects ) { < nl > - ownKeyGroupId = ( ( FetchOwnKeyGroupResult ) objects [ 0 ] ) . getKeyGroupId ( ) ; < nl > - theirKeys = ( ( FetchUserKeyGroupsResponse ) objects [ 1 ] ) . getUserKeys ( ) ; < nl > - isReady = true ; < nl > - unstashAll ( ) ; < nl > - } < nl > - } ) . failure ( new Supplier < Exception > ( ) { < nl > - @ Override < nl > - public void apply ( Exception e ) { < nl > - Log . w ( TAG , " Unable to fetch initial parameters " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - } < nl > - } ) . dispatch ( self ( ) ) . done ( ) ; < nl > + ) . then ( objects - > { < nl > + ownKeyGroupId = ( ( FetchOwnKeyGroupResult ) objects [ 0 ] ) . getKeyGroupId ( ) ; < nl > + theirKeys = ( ( FetchUserKeyGroupsResponse ) objects [ 1 ] ) . getUserKeys ( ) ; < nl > + isReady = true ; < nl > + unstashAll ( ) ; < nl > + } ) . failure ( e - > { < nl > + Log . w ( TAG , " Unable to fetch initial parameters " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + } ) . done ( self ( ) ) ; < nl > } < nl > < nl > private void doEncrypt ( final byte [ ] data , final PromiseResolver < EncryptBoxResponse > future ) { < nl > Log . d ( TAG , " doEncrypt " ) ; < nl > - sequence ( map ( theirKeys . getUserKeysGroups ( ) , new Map < UserKeysGroup , Promise < ActorRef > > ( ) { < nl > - @ Override < nl > - public Promise < ActorRef > map ( final UserKeysGroup src ) { < nl > - Log . d ( TAG , " doEncrypt : map " ) ; < nl > - for ( SessionId sessionId : activeSessions . keySet ( ) ) { < nl > - if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { < nl > - return success ( activeSessions . get ( sessionId ) ) ; < nl > - } < nl > + sequence ( map ( theirKeys . getUserKeysGroups ( ) , src - > { < nl > + Log . d ( TAG , " doEncrypt : map " ) ; < nl > + for ( SessionId sessionId : activeSessions . keySet ( ) ) { < nl > + if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { < nl > + return success ( activeSessions . get ( sessionId ) ) ; < nl > } < nl > - < nl > - Log . d ( TAG , " doEncrypt : not _ found " ) ; < nl > - < nl > - return zip ( sequence ( < nl > - ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , < nl > - ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) < nl > - ) , new ArrayFunction < Object , ActorRef > ( ) { < nl > - @ Override < nl > - public ActorRef apply ( Object [ ] t ) { < nl > - < nl > - Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; < nl > - < nl > - final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; < nl > - final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; < nl > - < nl > - SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , < nl > - src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; < nl > - ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { < nl > - @ Override < nl > - public EncryptedSessionActor create ( ) { < nl > - return new EncryptedSessionActor ( context ( ) , uid , < nl > - ownEphemeral , theirEphemeral . getKeyId ( ) , src . getKeyGroupId ( ) ) ; < nl > - } < nl > - } ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; < nl > - activeSessions . put ( sessionId , res ) ; < nl > - return res ; < nl > - } < nl > - } ) . dispatch ( self ( ) ) ; < nl > } < nl > - } ) ) . then ( new Supplier < ActorRef [ ] > ( ) { < nl > - @ Override < nl > - public void apply ( ActorRef [ ] actorRefs ) { < nl > < nl > - Log . d ( TAG , " doEncrypt : enc " ) ; < nl > + Log . d ( TAG , " doEncrypt : not _ found " ) ; < nl > + final UserKeysGroup srcFinal = src ; < nl > + return zip ( sequence ( < nl > + ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , < nl > + ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) < nl > + ) , t - > { < nl > + < nl > + Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; < nl > + < nl > + final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; < nl > + final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; < nl > + < nl > + SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , < nl > + src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; < nl > + ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , < nl > + ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; < nl > + activeSessions . put ( sessionId , res ) ; < nl > + return res ; < nl > + } ) ; < nl > + } ) ) . then ( actorRefs - > { < nl > + < nl > + Log . d ( TAG , " doEncrypt : enc " ) ; < nl > + < nl > + final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > + < nl > + sequence ( Promises . map ( actorRefs , src - > { < nl > + return ask ( src , new EncryptPackage ( encKey ) ) ; < nl > + } ) ) . then ( encryptedPackageRes - > { < nl > + ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < > ( ) ; < nl > + for ( EncryptedPackageRes r : encryptedPackageRes ) { < nl > + encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; < nl > + } < nl > < nl > - final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > + byte [ ] encData ; < nl > + try { < nl > + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > + } catch ( IntegrityException e ) { < nl > + e . printStackTrace ( ) ; < nl > + future . error ( e ) ; < nl > + return ; < nl > + } < nl > < nl > - sequence ( Promises . map ( actorRefs , new Map < ActorRef , Promise < EncryptedPackageRes > > ( ) { < nl > - @ Override < nl > - public Promise < EncryptedPackageRes > map ( ActorRef src ) { < nl > - return ask ( src , new EncryptPackage ( encKey ) ) ; < nl > - } < nl > - } ) ) . then ( new Supplier < EncryptedPackageRes [ ] > ( ) { < nl > - @ Override < nl > - public void apply ( EncryptedPackageRes [ ] encryptedPackageRes ) { < nl > - ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > - for ( EncryptedPackageRes r : encryptedPackageRes ) { < nl > - encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; < nl > - } < nl > - < nl > - byte [ ] encData ; < nl > - try { < nl > - encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > - } catch ( IntegrityException e ) { < nl > - e . printStackTrace ( ) ; < nl > - future . error ( e ) ; < nl > - return ; < nl > - } < nl > - < nl > - EncryptedBox encryptedBox = new EncryptedBox ( < nl > - encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > - ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > - < nl > - future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; < nl > - } < nl > - } ) . failure ( new Supplier < Exception > ( ) { < nl > - @ Override < nl > - public void apply ( Exception e ) { < nl > - Log . d ( TAG , " Unable to encrypt all receivers " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - future . error ( e ) ; < nl > - } < nl > - } ) . dispatch ( self ( ) ) . done ( ) ; < nl > - } < nl > - } ) . dispatch ( self ( ) ) . done ( ) ; < nl > + EncryptedBox encryptedBox = new EncryptedBox ( < nl > + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > + < nl > + future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; < nl > + } ) . failure ( e - > { < nl > + Log . d ( TAG , " Unable to encrypt all receivers " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + future . error ( e ) ; < nl > + } ) . done ( self ( ) ) ; < nl > + } ) . done ( self ( ) ) ; < nl > } < nl > < nl > private void doDecrypt ( final EncryptedBox data , final PromiseResolver < DecryptBoxResponse > future ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index 6cea4f7 . . f5481e2 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 92 , 7 + 92 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > return new EncryptedSession ( ownIdentityKey , ownPreKey , theirIdentityKey , theirPreKey , theirKeyGroup ) ; < nl > } < nl > - } ) . dispatch ( self ( ) ) . then ( new Supplier < EncryptedSession > ( ) { < nl > + } ) . then ( new Supplier < EncryptedSession > ( ) { < nl > @ Override < nl > public void apply ( EncryptedSession encryptedSession ) { < nl > EncryptedSessionActor . this . session = encryptedSession ; < nl > @ @ - 104 , 7 + 104 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > Log . w ( TAG , " Session load error " ) ; < nl > Log . e ( TAG , e ) ; < nl > } < nl > - } ) . dispatch ( self ( ) ) . done ( ) ; < nl > + } ) . done ( self ( ) ) ; < nl > } < nl > < nl > private void onEncrypt ( final byte [ ] data , final PromiseResolver < EncryptedPackageRes > future ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java < nl > index ee0cc28 . . 723ae25 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java < nl > @ @ - 198 , 7 + 198 , 7 @ @ public class ModuleActor extends AskcableActor implements BusSubscriber { < nl > } < nl > } ) ; < nl > } < nl > - } . dispatch ( self ( ) ) ; < nl > + } . done ( self ( ) ) ; < nl > } < nl > < nl > public void cancelRequest ( long rid ) { < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java < nl > index 6ad3121 . . 063d466 100755 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java < nl > @ @ - 221 , 7 + 221 , 7 @ @ public class Actor { < nl > protected void exec ( @ NotNull PromiseResolver < T > executor ) { < nl > dest . send ( new AskIntRequest ( msg , executor ) ) ; < nl > } < nl > - } . dispatch ( self ( ) ) ; < nl > + } ; < nl > } < nl > < nl > public void ask ( ActorRef dest , Object message ) { < nl > @ @ - 295 , 6 + 295 , 6 @ @ public class Actor { < nl > public void apply ( Exception e ) { < nl > self ( ) . send ( new AskIntError ( id , e ) ) ; < nl > } < nl > - } ) . done ( ) ; < nl > + } ) . done ( self ( ) ) ; < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java < nl > index 2f5e64c . . f16e918 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java < nl > @ @ - 2 , 4 + 2 , 8 @ @ package im . actor . runtime . function ; < nl > < nl > public interface Function < T , R > { < nl > R apply ( T t ) ; < nl > + < nl > + default R apply2 ( T t ) { < nl > + return apply ( t ) ; < nl > + } < nl > } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > index 89e8a6f . . 7a376aa 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > @ @ - 5 , 6 + 5 , 7 @ @ import org . jetbrains . annotations . Nullable ; < nl > < nl > import java . util . ArrayList ; < nl > < nl > + import im . actor . runtime . actors . Actor ; < nl > import im . actor . runtime . actors . ActorRef ; < nl > import im . actor . runtime . function . Supplier ; < nl > < nl > @ @ - 18 , 7 + 19 , 7 @ @ public abstract class Promise < T > { < nl > < nl > private final ArrayList < PromiseCallback < T > > callbacks = new ArrayList < PromiseCallback < T > > ( ) ; < nl > < nl > - private PromiseDispatcher dispatcher = PromiseDispatcher . DEFAULT ; < nl > + private ActorRef dispatchActor ; < nl > private volatile T result ; < nl > private volatile Exception exception ; < nl > private volatile boolean isFinished ; < nl > @ @ - 40 , 7 + 41 , 7 @ @ public abstract class Promise < T > { < nl > public synchronized Promise < T > then ( final Supplier < T > then ) { < nl > if ( isFinished ) { < nl > if ( exception = = null ) { < nl > - dispatcher . dispatch ( new Runnable ( ) { < nl > + dispatchActor . send ( new Runnable ( ) { < nl > @ Override < nl > public void run ( ) { < nl > then . apply ( result ) ; < nl > @ @ - 72 , 7 + 73 , 7 @ @ public abstract class Promise < T > { < nl > public synchronized Promise < T > failure ( final Supplier < Exception > failure ) { < nl > if ( isFinished ) { < nl > if ( exception ! = null ) { < nl > - dispatcher . dispatch ( new Runnable ( ) { < nl > + dispatchActor . send ( new Runnable ( ) { < nl > @ Override < nl > public void run ( ) { < nl > failure . apply ( exception ) ; < nl > @ @ - 104 , 7 + 105 , 7 @ @ public abstract class Promise < T > { < nl > public synchronized Promise < T > complete ( final PromiseCallback < T > callback ) { < nl > if ( isFinished ) { < nl > < nl > - dispatcher . dispatch ( new Runnable ( ) { < nl > + dispatchActor . send ( new Runnable ( ) { < nl > @ Override < nl > public void run ( ) { < nl > if ( exception ! = null ) { < nl > @ @ - 120 , 25 + 121 , 26 @ @ public abstract class Promise < T > { < nl > return this ; < nl > } < nl > < nl > - / * * < nl > - * Binding result dispatching to actor < nl > - * < nl > - * @ param ref dest actor < nl > - * @ return this < nl > - * / < nl > - public Promise < T > dispatch ( ActorRef ref ) { < nl > - dispatcher = PromiseDispatcher . forActor ( ref ) ; < nl > - return this ; < nl > - } < nl > + / / / * * < nl > + / / * Binding result dispatching to actor < nl > + / / * < nl > + / / * @ param ref dest actor < nl > + / / * @ return this < nl > + / / * / < nl > + / / public Promise < T > dispatch ( ActorRef ref ) { < nl > + / / dispatcher = PromiseDispatcher . forActor ( ref ) ; < nl > + / / return this ; < nl > + / / } < nl > < nl > / * * < nl > * Call this method to start promise execution < nl > * / < nl > - public Promise < T > done ( ) { < nl > + public Promise < T > done ( ActorRef ref ) { < nl > if ( isStarted ) { < nl > throw new RuntimeException ( " Promise already started " ) ; < nl > } < nl > isStarted = true ; < nl > + dispatchActor = ref ; < nl > exec ( new PromiseResolver < T > ( this ) ) ; < nl > return this ; < nl > } < nl > @ @ - 147 , 18 + 149 , 22 @ @ public abstract class Promise < T > { < nl > return ( Promise < R > ) this ; < nl > } < nl > < nl > - / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { < nl > + public ActorRef getDispatchActor ( ) { < nl > + return dispatchActor ; < nl > + } < nl > + < nl > + / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { < nl > / / return Promises . zip ( ( Promise < T [ ] > ) this , zip ) ; < nl > / / } < nl > < nl > - / * * < nl > - * Getting current dispatcher for promise < nl > - * < nl > - * @ return current dispatcher < nl > - * / < nl > - public PromiseDispatcher getDispatcher ( ) { < nl > - return dispatcher ; < nl > - } < nl > + / / / * * < nl > + / / * Getting current dispatcher for promise < nl > + / / * < nl > + / / * @ return current dispatcher < nl > + / / * / < nl > + / / public PromiseDispatcher getDispatcher ( ) { < nl > + / / return dispatcher ; < nl > + / / } < nl > < nl > public boolean isFinished ( ) { < nl > return isFinished ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > index 4614511 . . b071798 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > @ @ - 52 , 7 + 52 , 7 @ @ public class Promises { < nl > executor . error ( e ) ; < nl > } < nl > } ) ; < nl > - promises . done ( ) ; < nl > + promises . done ( promises . getDispatchActor ( ) ) ; < nl > } < nl > } ; < nl > } < nl > @ @ - 106 , 7 + 106 , 7 @ @ public class Promises { < nl > } ) ; < nl > } < nl > for ( Promise < T > p : promises ) { < nl > - p . done ( ) ; < nl > + p . done ( self . getDispatchActor ( ) ) ; < nl > } < nl > } < nl > } ;

TEST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile 
 index 11474a8 . . 2a64644 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile 
 @ @ - 28 , 7 + 28 , 7 @ @ space : = $ { null } $ { null } 
 J2OBJC _ DISTRIBUTION = $ ( PODS _ ROOT ) / J2ObjC - Framework / Distributive 
 J2OBJC = $ ( J2OBJC _ DISTRIBUTION ) / j2objc 
 J2OBJCC = $ ( J2OBJC _ DISTRIBUTION ) / j2objcc 
 - J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods - source 8 - Xforce - incomplete - java8 
 + J2OBJC _ ARGS = - - swift - friendly - use - arc - - generate - deprecated - - doc - comments - g - source 8 - Xforce - incomplete - java8 - - nullability - - strip - reflection 
 J2OBJCC _ ARGS = - ObjC - fobjc - arc - fembed - bitcode - marker - Wobjc - designated - initializers - g $ ( ARCHFLAGS ) $ ( SDKFLAGS ) - I $ ( J2OBJC _ DISTRIBUTION ) / include 
 
 LIBRARY _ NAME = libactor . so 
 @ @ - 40 , 9 + 40 , 11 @ @ SOURCE _ ROOTS = \ 
 	 $ ( SDK _ ROOT ) / sdk - core / core / core - shared / src / main / java \ 
 	 $ ( SDK _ ROOT ) / sdk - core / core / core - cocoa / src / main / java 
 
 - EXCLUDED _ CLASSES = \ 
 - 	 com . google . j2objc . annotations . ObjectiveCName \ 
 - com . google . j2objc . annotations . Propery 
 + EXCLUDED _ CLASSES = 
 + 
 + # EXCLUDED _ CLASSES = \ 
 + # 	 com . google . j2objc . annotations . ObjectiveCName \ 
 + # com . google . j2objc . annotations . Propery 
 
 PREFIXES = \ 
 - - prefixes $ ( SDK _ ROOT ) / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties \ 
 diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Compose / AAGroupMembersController . swift b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Compose / AAGroupMembersController . swift 
 index 1b87a4f . . 008a40e 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Compose / AAGroupMembersController . swift 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / Controllers / Compose / AAGroupMembersController . swift 
 @ @ - 76 , 7 + 76 , 7 @ @ public class GroupMembersController : AAContactsListContentController , AAContacts 
 res . replaceIntAtIndex ( UInt ( i ) , withInt : selected [ i ] . contact . uid ) 
 } 
 
 - executeSafeOnlySuccess ( Actor . createGroupCommandWithTitle ( groupTitle , withAvatar : nil , withUids : res ) ) { ( val ) - > Void in 
 + executeSafeOnlySuccess ( Actor . createGroupCommandWithTitle ( groupTitle , withAvatar : nil , withUids : res ) ! ) { ( val ) - > Void in 
 let gid = ( val as ! JavaLangInteger ) . intValue 
 if self . groupImage ! = nil { 
 Actor . changeGroupAvatar ( gid , image : self . groupImage ! ) 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index ca8c14b . . 23d9631 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 8 , 12 + 8 , 10 @ @ import im . actor . core . api . ApiMessage ; 
 import im . actor . core . modules . ModuleContext ; 
 import im . actor . core . modules . encryption . entity . EncryptedBox ; 
 import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; 
 - import im . actor . core . modules . encryption . entity . OwnPrivateKey ; 
 import im . actor . core . modules . encryption . entity . SessionId ; 
 import im . actor . core . modules . encryption . entity . UserKeys ; 
 import im . actor . core . modules . encryption . entity . UserKeysGroup ; 
 import im . actor . core . modules . encryption . entity . UserPublicKey ; 
 - import im . actor . core . util . Hex ; 
 import im . actor . core . util . ModuleActor ; 
 import im . actor . core . util . RandomUtils ; 
 import im . actor . runtime . Crypto ; 
 @ @ - 24 , 8 + 22 , 9 @ @ import im . actor . runtime . actors . Props ; 
 import im . actor . runtime . actors . ask . AskCallback ; 
 import im . actor . runtime . actors . ask . AskMessage ; 
 import im . actor . runtime . actors . ask . AskResult ; 
 - import im . actor . runtime . function . ArrayFunction ; 
 - import im . actor . runtime . function . Map ; 
 + import im . actor . runtime . function . BiConsumer ; 
 + import im . actor . runtime . function . Consumer ; 
 + import im . actor . runtime . function . Function ; 
 import im . actor . runtime . promise . Promise ; 
 import im . actor . runtime . promise . PromiseResolver ; 
 import im . actor . runtime . promise . Promises ; 
 @ @ - 33 , 11 + 32 , 11 @ @ import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . box . ActorBox ; 
 import im . actor . runtime . crypto . box . ActorBoxKey ; 
 import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 - import im . actor . runtime . function . Supplier ; 
 import im . actor . core . modules . encryption . KeyManagerActor . * ; 
 import im . actor . core . modules . encryption . EncryptedSessionActor . * ; 
 
 import static im . actor . runtime . promise . Promises . * ; 
 + import static im . actor . runtime . streams . Streams . * ; 
 
 public class EncryptedPeerActor extends ModuleActor { 
 
 @ @ - 84 , 67 + 83 , 120 @ @ public class EncryptedPeerActor extends ModuleActor { 
 
 private void doEncrypt ( final byte [ ] data , final PromiseResolver < EncryptBoxResponse > future ) { 
 Log . d ( TAG , " doEncrypt " ) ; 
 - sequence ( map ( theirKeys . getUserKeysGroups ( ) , src - > { 
 - Log . d ( TAG , " doEncrypt : map " ) ; 
 - for ( SessionId sessionId : activeSessions . keySet ( ) ) { 
 - if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { 
 - return success ( activeSessions . get ( sessionId ) ) ; 
 - } 
 - } 
 
 - Log . d ( TAG , " doEncrypt : not _ found " ) ; 
 - final UserKeysGroup srcFinal = src ; 
 - return zip ( sequence ( 
 - ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , 
 - ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) 
 - ) , t - > { 
 - 
 - Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; 
 - 
 - final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; 
 - final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; 
 - 
 - SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , 
 - src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; 
 - ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , 
 - ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; 
 - activeSessions . put ( sessionId , res ) ; 
 - return res ; 
 - } ) ; 
 - } ) ) . then ( actorRefs - > { 
 - 
 - Log . d ( TAG , " doEncrypt : enc " ) ; 
 - 
 - final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 - 
 - sequence ( Promises . map ( actorRefs , src - > { 
 - return ask ( src , new EncryptPackage ( encKey ) ) ; 
 - } ) ) . then ( encryptedPackageRes - > { 
 - ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < > ( ) ; 
 - for ( EncryptedPackageRes r : encryptedPackageRes ) { 
 - encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; 
 - } 
 + final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 
 - byte [ ] encData ; 
 - try { 
 - encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 - } catch ( IntegrityException e ) { 
 - e . printStackTrace ( ) ; 
 - future . error ( e ) ; 
 - return ; 
 - } 
 - 
 - EncryptedBox encryptedBox = new EncryptedBox ( 
 - encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 - ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 - 
 - future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; 
 - } ) . failure ( e - > { 
 - Log . d ( TAG , " Unable to encrypt all receivers " ) ; 
 - Log . e ( TAG , e ) ; 
 - future . error ( e ) ; 
 - } ) . done ( self ( ) ) ; 
 - } ) . done ( self ( ) ) ; 
 + toStream ( theirKeys . getUserKeysGroups ( ) ) 
 + . map ( new Function < UserKeysGroup , Promise < ActorRef > > ( ) { 
 + @ Override 
 + public Promise < ActorRef > apply ( UserKeysGroup keysGroup ) { 
 + 
 + Log . d ( TAG , " doEncrypt : map " ) ; 
 + for ( SessionId sessionId : activeSessions . keySet ( ) ) { 
 + if ( sessionId . getTheirKeyGroupId ( ) = = keysGroup . getKeyGroupId ( ) ) { 
 + return success ( activeSessions . get ( sessionId ) ) ; 
 + } 
 + } 
 + 
 + Log . d ( TAG , " doEncrypt : not _ found " ) ; 
 + final UserKeysGroup srcFinal = keysGroup ; 
 + return zip ( sequence ( 
 + ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , keysGroup . getKeyGroupId ( ) ) ) . cast ( ) , 
 + ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) 
 + ) , t - > { 
 + Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; 
 + 
 + final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; 
 + final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; 
 + 
 + SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , 
 + keysGroup . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; 
 + ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , 
 + ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; 
 + activeSessions . put ( sessionId , res ) ; 
 + return res ; 
 + } ) ; 
 + } 
 + } ) 
 + . mapAsync ( new BiConsumer < Promise < ActorRef > , Consumer < ActorRef > > ( ) { 
 + @ Override 
 + public void accept ( Promise < ActorRef > actorRefPromise , Consumer < ActorRef > objectConsumer ) { 
 + actorRefPromise . then ( objectConsumer : : apply ) ; 
 + } 
 + } ) ; 
 + / / . mapAsync ( new BiConsumer < Object , Consumer < EncryptedPackageRes > > ( ) { 
 + / / @ Override 
 + / / public void accept ( Object actorRef , Consumer < EncryptedPackageRes > objectConsumer ) { 
 + / / ask ( ( ActorRef ) actorRef , new EncryptPackage ( encKey ) ) 
 + / / . then ( encryptedPackageRes - > objectConsumer . apply ( encryptedPackageRes ) ) 
 + / / . failure ( e - > { 
 + / / / / TODO : How to handle ? 
 + / / } ) ; 
 + / / } 
 + / / } ) 
 + / / . toArray ( ) ; 
 + 
 + / / sequence ( map ( theirKeys . getUserKeysGroups ( ) , src - > { 
 + / / Log . d ( TAG , " doEncrypt : map " ) ; 
 + / / for ( SessionId sessionId : activeSessions . keySet ( ) ) { 
 + / / if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { 
 + / / return success ( activeSessions . get ( sessionId ) ) ; 
 + / / } 
 + / / } 
 + / / 
 + / / Log . d ( TAG , " doEncrypt : not _ found " ) ; 
 + / / final UserKeysGroup srcFinal = src ; 
 + / / return zip ( sequence ( 
 + / / ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , 
 + / / ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) 
 + / / ) , t - > { 
 + / / 
 + / / Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; 
 + / / 
 + / / final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; 
 + / / final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; 
 + / / 
 + / / SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , 
 + / / src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; 
 + / / ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , 
 + / / ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; 
 + / / activeSessions . put ( sessionId , res ) ; 
 + / / return res ; 
 + / / } ) ; 
 + / / } ) ) . then ( actorRefs - > { 
 + / / 
 + / / Log . d ( TAG , " doEncrypt : enc " ) ; 
 + / / 
 + / / final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 + / / 
 + / / sequence ( Promises . map ( actorRefs , src - > { 
 + / / return ask ( src , new EncryptPackage ( encKey ) ) ; 
 + / / } ) ) . then ( encryptedPackageRes - > { 
 + / / ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < > ( ) ; 
 + / / for ( EncryptedPackageRes r : encryptedPackageRes ) { 
 + / / encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; 
 + / / } 
 + / / 
 + / / byte [ ] encData ; 
 + / / try { 
 + / / encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 + / / } catch ( IntegrityException e ) { 
 + / / e . printStackTrace ( ) ; 
 + / / future . error ( e ) ; 
 + / / return ; 
 + / / } 
 + / / 
 + / / EncryptedBox encryptedBox = new EncryptedBox ( 
 + / / encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 + / / ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 + / / 
 + / / future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; 
 + / / } ) . failure ( e - > { 
 + / / Log . d ( TAG , " Unable to encrypt all receivers " ) ; 
 + / / Log . e ( TAG , e ) ; 
 + / / future . error ( e ) ; 
 + / / } ) . done ( self ( ) ) ; 
 + / / } ) . done ( self ( ) ) ; 
 } 
 
 private void doDecrypt ( final EncryptedBox data , final PromiseResolver < DecryptBoxResponse > future ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index f5481e2 . . 8f8eaaa 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 21 , 7 + 21 , 7 @ @ import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 import im . actor . core . modules . encryption . KeyManagerActor . * ; 
 import im . actor . runtime . function . ArrayFunction ; 
 - import im . actor . runtime . function . Supplier ; 
 + import im . actor . runtime . function . Consumer ; 
 
 public class EncryptedSessionActor extends ModuleActor { 
 
 @ @ - 92 , 13 + 92 , 13 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 return new EncryptedSession ( ownIdentityKey , ownPreKey , theirIdentityKey , theirPreKey , theirKeyGroup ) ; 
 } 
 - } ) . then ( new Supplier < EncryptedSession > ( ) { 
 + } ) . then ( new Consumer < EncryptedSession > ( ) { 
 @ Override 
 public void apply ( EncryptedSession encryptedSession ) { 
 EncryptedSessionActor . this . session = encryptedSession ; 
 unstashAll ( ) ; 
 } 
 - } ) . failure ( new Supplier < Exception > ( ) { 
 + } ) . failure ( new Consumer < Exception > ( ) { 
 @ Override 
 public void apply ( Exception e ) { 
 Log . w ( TAG , " Session load error " ) ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index c380c33 . . 69ccd59 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 39 , 7 + 39 , 7 @ @ import im . actor . runtime . promise . PromiseResolver ; 
 import im . actor . runtime . crypto . Curve25519 ; 
 import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 import im . actor . runtime . crypto . ratchet . RatchetKeySignature ; 
 - import im . actor . runtime . function . Supplier ; 
 + import im . actor . runtime . function . Consumer ; 
 import im . actor . runtime . storage . KeyValueStorage ; 
 
 public class KeyManagerActor extends ModuleActor { 
 @ @ - 122 , 14 + 122 , 14 @ @ public class KeyManagerActor extends ModuleActor { 
 signature ) ) ; 
 } 
 
 - api ( new RequestCreateNewKeyGroup ( apiEncryptionKey , encryption , keys , keySignatures ) ) . then ( new Supplier < ResponseCreateNewKeyGroup > ( ) { 
 + api ( new RequestCreateNewKeyGroup ( apiEncryptionKey , encryption , keys , keySignatures ) ) . then ( new Consumer < ResponseCreateNewKeyGroup > ( ) { 
 @ Override 
 public void apply ( ResponseCreateNewKeyGroup response ) { 
 ownKeys = ownKeys . setGroupId ( response . getKeyGroupId ( ) ) ; 
 encryptionKeysStorage . addOrUpdateItem ( 0 , ownKeys . toByteArray ( ) ) ; 
 onMainKeysReady ( ) ; 
 } 
 - } ) . failure ( new Supplier < Exception > ( ) { 
 + } ) . failure ( new Consumer < Exception > ( ) { 
 @ Override 
 public void apply ( Exception e ) { 
 Log . w ( TAG , " Keys upload error " ) ; 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties b / actor - sdk / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties 
 index 9965b75 . . aab82d6 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties 
 + + + b / actor - sdk / sdk - core / runtime / runtime - cocoa / src / main / prefixes . properties 
 @ @ - 11 , 6 + 11 , 10 @ @ im . actor . runtime . bser : AR 
 
 im . actor . runtime . collections : AR 
 
 + im . actor . runtime . function : AR 
 + 
 + im . actor . runtime . promises : AR 
 + 
 im . actor . runtime . crypto : AR 
 im . actor . runtime . crypto . asn1 : AR 
 im . actor . runtime . crypto . bouncycastle : AR 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java 
 index 063d466 . . 4736740 100755 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java 
 @ @ - 19 , 7 + 19 , 7 @ @ import im . actor . runtime . actors . mailbox . Mailbox ; 
 import im . actor . runtime . actors . messages . DeadLetter ; 
 import im . actor . runtime . promise . Promise ; 
 import im . actor . runtime . promise . PromiseResolver ; 
 - import im . actor . runtime . function . Supplier ; 
 + import im . actor . runtime . function . Consumer ; 
 
 / * * 
 * Actor object 
 @ @ - 285 , 12 + 285 , 12 @ @ public class Actor { 
 } ) ; 
 dest . send ( new AskIntRequest ( message , executor ) ) ; 
 } 
 - } . then ( new Supplier < Object > ( ) { 
 + } . then ( new Consumer < Object > ( ) { 
 @ Override 
 public void apply ( Object o ) { 
 self ( ) . send ( new AskIntResult ( id , o ) ) ; 
 } 
 - } ) . failure ( new Supplier < Exception > ( ) { 
 + } ) . failure ( new Consumer < Exception > ( ) { 
 @ Override 
 public void apply ( Exception e ) { 
 self ( ) . send ( new AskIntError ( id , e ) ) ; 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / bser / BserValues . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / bser / BserValues . java 
 index 2b1940d . . 6f91821 100755 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / bser / BserValues . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / bser / BserValues . java 
 @ @ - 126 , 7 + 126 , 7 @ @ public class BserValues { 
 } 
 
 @ NotNull 
 - public byte [ ] getBytes ( int id , @ NotNull byte [ ] defValue ) throws IOException { 
 + public byte [ ] getBytes ( int id , @ Nullable byte [ ] defValue ) throws IOException { 
 / / TODO : Check defValue = = null ? 
 if ( fields . containsKey ( id ) ) { 
 touched . put ( id , true ) ; 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / BiConsumer . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / BiConsumer . java 
 new file mode 100644 
 index 0000000 . . e8c59e4 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / BiConsumer . java 
 @ @ - 0 , 0 + 1 , 5 @ @ 
 + package im . actor . runtime . function ; 
 + 
 + public interface BiConsumer < T , U > { 
 + void accept ( T t , U u ) ; 
 + } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Consumer . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Consumer . java 
 new file mode 100644 
 index 0000000 . . 91d44ea 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Consumer . java 
 @ @ - 0 , 0 + 1 , 5 @ @ 
 + package im . actor . runtime . function ; 
 + 
 + public interface Consumer < T > { 
 + void apply ( T t ) ; 
 + } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java 
 index f16e918 . . 985efa4 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java 
 @ @ - 1 , 9 + 1 , 7 @ @ 
 package im . actor . runtime . function ; 
 
 + import com . google . j2objc . annotations . ObjectiveCName ; 
 + 
 public interface Function < T , R > { 
 R apply ( T t ) ; 
 - 
 - default R apply2 ( T t ) { 
 - return apply ( t ) ; 
 - } 
 } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Supplier . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Supplier . java 
 deleted file mode 100644 
 index 76171c4 . . 0000000 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Supplier . java 
 + + + / dev / null 
 @ @ - 1 , 5 + 0 , 0 @ @ 
 - package im . actor . runtime . function ; 
 - 
 - public interface Supplier < T > { 
 - void apply ( T t ) ; 
 - } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 index 7a376aa . . f86775f 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 @ @ - 5 , 9 + 5 , 8 @ @ import org . jetbrains . annotations . Nullable ; 
 
 import java . util . ArrayList ; 
 
 - import im . actor . runtime . actors . Actor ; 
 import im . actor . runtime . actors . ActorRef ; 
 - import im . actor . runtime . function . Supplier ; 
 + import im . actor . runtime . function . Consumer ; 
 
 / * * 
 * Promise support implementations . It is much more like js promises than traditional 
 @ @ - 38 , 7 + 37 , 7 @ @ public abstract class Promise < T > { 
 * @ param then supplier for result 
 * @ return this 
 * / 
 - public synchronized Promise < T > then ( final Supplier < T > then ) { 
 + public synchronized Promise < T > then ( final Consumer < T > then ) { 
 if ( isFinished ) { 
 if ( exception = = null ) { 
 dispatchActor . send ( new Runnable ( ) { 
 @ @ - 70 , 7 + 69 , 7 @ @ public abstract class Promise < T > { 
 * @ param failure supplier for exception 
 * @ return this 
 * / 
 - public synchronized Promise < T > failure ( final Supplier < Exception > failure ) { 
 + public synchronized Promise < T > failure ( final Consumer < Exception > failure ) { 
 if ( isFinished ) { 
 if ( exception ! = null ) { 
 dispatchActor . send ( new Runnable ( ) { 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 index b071798 . . 9f79a96 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 @ @ - 7 , 7 + 7 , 7 @ @ import java . util . Collection ; 
 
 import im . actor . runtime . function . ArrayFunction ; 
 import im . actor . runtime . function . Map ; 
 - import im . actor . runtime . function . Supplier ; 
 + import im . actor . runtime . function . Consumer ; 
 
 public class Promises { 
 
 @ @ - 77 , 7 + 77 , 7 @ @ public class Promises { 
 final Promise self = this ; 
 for ( int i = 0 ; i < res . length ; i + + ) { 
 final int finalI = i ; 
 - promises [ i ] . then ( new Supplier < T > ( ) { 
 + promises [ i ] . then ( new Consumer < T > ( ) { 
 @ Override 
 public void apply ( T t ) { 
 if ( self . isFinished ( ) ) { 
 @ @ - 94 , 7 + 94 , 7 @ @ public class Promises { 
 
 executor . result ( res ) ; 
 } 
 - } ) . failure ( new Supplier < Exception > ( ) { 
 + } ) . failure ( new Consumer < Exception > ( ) { 
 @ Override 
 public void apply ( Exception e ) { 
 if ( self . isFinished ( ) ) { 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Stream . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Stream . java 
 new file mode 100644 
 index 0000000 . . d2c4ab1 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Stream . java 
 @ @ - 0 , 0 + 1 , 53 @ @ 
 + package im . actor . runtime . streams ; 
 + 
 + import java . util . ArrayList ; 
 + 
 + import im . actor . runtime . function . BiConsumer ; 
 + import im . actor . runtime . function . BiFunction ; 
 + import im . actor . runtime . function . Consumer ; 
 + import im . actor . runtime . function . Function ; 
 + 
 + public interface Stream < T > { 
 + 
 + void forEach ( Consumer < T > consumer ) ; 
 + 
 + default void forEachRemaining ( Consumer < T > consumer ) { 
 + forEach ( consumer ) ; 
 + } 
 + 
 + default < R > Stream < R > map ( Function < T , R > fun ) { 
 + return consumer1 - > Stream . this . forEach ( t - > consumer1 . apply ( fun . apply ( t ) ) ) ; 
 + } 
 + 
 + default < R > Stream < R > mapAsync ( BiConsumer < T , Consumer < R > > fun ) { 
 + return consumer - > Stream . this . forEach ( t - > fun . accept ( t , consumer ) ) ; 
 + } 
 + 
 + default Stream < T > concat ( Stream < T > next ) { 
 + return consumer - > { 
 + Stream . this . forEachRemaining ( consumer ) ; 
 + next . forEachRemaining ( consumer ) ; 
 + } ; 
 + } 
 + 
 + default < R > R reduce ( R init , BiFunction < T , R , R > fun ) { 
 + final Object [ ] res = { init } ; 
 + forEachRemaining ( new Consumer < T > ( ) { 
 + @ Override 
 + public void apply ( T t ) { 
 + res [ 0 ] = fun . apply ( t , ( R ) res [ 0 ] ) ; 
 + } 
 + } ) ; 
 + return ( R ) res [ 0 ] ; 
 + } 
 + 
 + default ArrayList < T > toList ( ) { 
 + ArrayList < T > res = new ArrayList < T > ( ) ; 
 + forEachRemaining ( t - > res . add ( t ) ) ; 
 + return res ; 
 + } 
 + 
 + default T [ ] toArray ( ) { 
 + return ( T [ ] ) toList ( ) . toArray ( ) ; 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Streams . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Streams . java 
 new file mode 100644 
 index 0000000 . . 92d5705 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / streams / Streams . java 
 @ @ - 0 , 0 + 1 , 22 @ @ 
 + package im . actor . runtime . streams ; 
 + 
 + import java . util . Collection ; 
 + 
 + public class Streams { 
 + 
 + public static < T > Stream < T > toStream ( T [ ] array ) { 
 + return consumer - > { 
 + for ( T t : array ) { 
 + consumer . apply ( t ) ; 
 + } 
 + } ; 
 + } 
 + 
 + public static < T > Stream < T > toStream ( Collection < T > collection ) { 
 + return consumer - > { 
 + for ( T t : collection ) { 
 + consumer . apply ( t ) ; 
 + } 
 + } ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile 
 index a6a37f9 . . 11474a8 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile 
 @ @ - 28 , 7 + 28 , 7 @ @ space : = $ { null } $ { null } 
 J2OBJC _ DISTRIBUTION = $ ( PODS _ ROOT ) / J2ObjC - Framework / Distributive 
 J2OBJC = $ ( J2OBJC _ DISTRIBUTION ) / j2objc 
 J2OBJCC = $ ( J2OBJC _ DISTRIBUTION ) / j2objcc 
 - J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods 
 + J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods - source 8 - Xforce - incomplete - java8 
 J2OBJCC _ ARGS = - ObjC - fobjc - arc - fembed - bitcode - marker - Wobjc - designated - initializers - g $ ( ARCHFLAGS ) $ ( SDKFLAGS ) - I $ ( J2OBJC _ DISTRIBUTION ) / include 
 
 LIBRARY _ NAME = libactor . so 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / build . gradle b / actor - sdk / sdk - core / core / core - shared / build . gradle 
 index e7791f8 . . c994383 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / build . gradle 
 + + + b / actor - sdk / sdk - core / core / core - shared / build . gradle 
 @ @ - 1 , 7 + 1 , 7 @ @ 
 apply plugin : ' java ' 
 
 compileJava { 
 - sourceCompatibility = 1 . 6 
 + sourceCompatibility = 1 . 8 
 targetCompatibility = 1 . 6 
 } 
 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 6ab8482 . . ca8c14b 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 71 , 109 + 71 , 80 @ @ public class EncryptedPeerActor extends ModuleActor { 
 sequence ( 
 ask ( keyManager , new FetchOwnKeyGroup ( ) ) . cast ( ) , 
 ask ( keyManager , new FetchUserKeyGroups ( uid ) ) . cast ( ) 
 - ) . then ( new Supplier < Object [ ] > ( ) { 
 - @ Override 
 - public void apply ( Object [ ] objects ) { 
 - ownKeyGroupId = ( ( FetchOwnKeyGroupResult ) objects [ 0 ] ) . getKeyGroupId ( ) ; 
 - theirKeys = ( ( FetchUserKeyGroupsResponse ) objects [ 1 ] ) . getUserKeys ( ) ; 
 - isReady = true ; 
 - unstashAll ( ) ; 
 - } 
 - } ) . failure ( new Supplier < Exception > ( ) { 
 - @ Override 
 - public void apply ( Exception e ) { 
 - Log . w ( TAG , " Unable to fetch initial parameters " ) ; 
 - Log . e ( TAG , e ) ; 
 - } 
 - } ) . dispatch ( self ( ) ) . done ( ) ; 
 + ) . then ( objects - > { 
 + ownKeyGroupId = ( ( FetchOwnKeyGroupResult ) objects [ 0 ] ) . getKeyGroupId ( ) ; 
 + theirKeys = ( ( FetchUserKeyGroupsResponse ) objects [ 1 ] ) . getUserKeys ( ) ; 
 + isReady = true ; 
 + unstashAll ( ) ; 
 + } ) . failure ( e - > { 
 + Log . w ( TAG , " Unable to fetch initial parameters " ) ; 
 + Log . e ( TAG , e ) ; 
 + } ) . done ( self ( ) ) ; 
 } 
 
 private void doEncrypt ( final byte [ ] data , final PromiseResolver < EncryptBoxResponse > future ) { 
 Log . d ( TAG , " doEncrypt " ) ; 
 - sequence ( map ( theirKeys . getUserKeysGroups ( ) , new Map < UserKeysGroup , Promise < ActorRef > > ( ) { 
 - @ Override 
 - public Promise < ActorRef > map ( final UserKeysGroup src ) { 
 - Log . d ( TAG , " doEncrypt : map " ) ; 
 - for ( SessionId sessionId : activeSessions . keySet ( ) ) { 
 - if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { 
 - return success ( activeSessions . get ( sessionId ) ) ; 
 - } 
 + sequence ( map ( theirKeys . getUserKeysGroups ( ) , src - > { 
 + Log . d ( TAG , " doEncrypt : map " ) ; 
 + for ( SessionId sessionId : activeSessions . keySet ( ) ) { 
 + if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { 
 + return success ( activeSessions . get ( sessionId ) ) ; 
 } 
 - 
 - Log . d ( TAG , " doEncrypt : not _ found " ) ; 
 - 
 - return zip ( sequence ( 
 - ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , 
 - ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) 
 - ) , new ArrayFunction < Object , ActorRef > ( ) { 
 - @ Override 
 - public ActorRef apply ( Object [ ] t ) { 
 - 
 - Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; 
 - 
 - final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; 
 - final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; 
 - 
 - SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , 
 - src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; 
 - ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { 
 - @ Override 
 - public EncryptedSessionActor create ( ) { 
 - return new EncryptedSessionActor ( context ( ) , uid , 
 - ownEphemeral , theirEphemeral . getKeyId ( ) , src . getKeyGroupId ( ) ) ; 
 - } 
 - } ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; 
 - activeSessions . put ( sessionId , res ) ; 
 - return res ; 
 - } 
 - } ) . dispatch ( self ( ) ) ; 
 } 
 - } ) ) . then ( new Supplier < ActorRef [ ] > ( ) { 
 - @ Override 
 - public void apply ( ActorRef [ ] actorRefs ) { 
 
 - Log . d ( TAG , " doEncrypt : enc " ) ; 
 + Log . d ( TAG , " doEncrypt : not _ found " ) ; 
 + final UserKeysGroup srcFinal = src ; 
 + return zip ( sequence ( 
 + ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , 
 + ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) 
 + ) , t - > { 
 + 
 + Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; 
 + 
 + final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; 
 + final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; 
 + 
 + SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , 
 + src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; 
 + ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , 
 + ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; 
 + activeSessions . put ( sessionId , res ) ; 
 + return res ; 
 + } ) ; 
 + } ) ) . then ( actorRefs - > { 
 + 
 + Log . d ( TAG , " doEncrypt : enc " ) ; 
 + 
 + final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 + 
 + sequence ( Promises . map ( actorRefs , src - > { 
 + return ask ( src , new EncryptPackage ( encKey ) ) ; 
 + } ) ) . then ( encryptedPackageRes - > { 
 + ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < > ( ) ; 
 + for ( EncryptedPackageRes r : encryptedPackageRes ) { 
 + encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; 
 + } 
 
 - final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 + byte [ ] encData ; 
 + try { 
 + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 + } catch ( IntegrityException e ) { 
 + e . printStackTrace ( ) ; 
 + future . error ( e ) ; 
 + return ; 
 + } 
 
 - sequence ( Promises . map ( actorRefs , new Map < ActorRef , Promise < EncryptedPackageRes > > ( ) { 
 - @ Override 
 - public Promise < EncryptedPackageRes > map ( ActorRef src ) { 
 - return ask ( src , new EncryptPackage ( encKey ) ) ; 
 - } 
 - } ) ) . then ( new Supplier < EncryptedPackageRes [ ] > ( ) { 
 - @ Override 
 - public void apply ( EncryptedPackageRes [ ] encryptedPackageRes ) { 
 - ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 - for ( EncryptedPackageRes r : encryptedPackageRes ) { 
 - encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; 
 - } 
 - 
 - byte [ ] encData ; 
 - try { 
 - encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 - } catch ( IntegrityException e ) { 
 - e . printStackTrace ( ) ; 
 - future . error ( e ) ; 
 - return ; 
 - } 
 - 
 - EncryptedBox encryptedBox = new EncryptedBox ( 
 - encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 - ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 - 
 - future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; 
 - } 
 - } ) . failure ( new Supplier < Exception > ( ) { 
 - @ Override 
 - public void apply ( Exception e ) { 
 - Log . d ( TAG , " Unable to encrypt all receivers " ) ; 
 - Log . e ( TAG , e ) ; 
 - future . error ( e ) ; 
 - } 
 - } ) . dispatch ( self ( ) ) . done ( ) ; 
 - } 
 - } ) . dispatch ( self ( ) ) . done ( ) ; 
 + EncryptedBox encryptedBox = new EncryptedBox ( 
 + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 + 
 + future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; 
 + } ) . failure ( e - > { 
 + Log . d ( TAG , " Unable to encrypt all receivers " ) ; 
 + Log . e ( TAG , e ) ; 
 + future . error ( e ) ; 
 + } ) . done ( self ( ) ) ; 
 + } ) . done ( self ( ) ) ; 
 } 
 
 private void doDecrypt ( final EncryptedBox data , final PromiseResolver < DecryptBoxResponse > future ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index 6cea4f7 . . f5481e2 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 92 , 7 + 92 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 return new EncryptedSession ( ownIdentityKey , ownPreKey , theirIdentityKey , theirPreKey , theirKeyGroup ) ; 
 } 
 - } ) . dispatch ( self ( ) ) . then ( new Supplier < EncryptedSession > ( ) { 
 + } ) . then ( new Supplier < EncryptedSession > ( ) { 
 @ Override 
 public void apply ( EncryptedSession encryptedSession ) { 
 EncryptedSessionActor . this . session = encryptedSession ; 
 @ @ - 104 , 7 + 104 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 Log . w ( TAG , " Session load error " ) ; 
 Log . e ( TAG , e ) ; 
 } 
 - } ) . dispatch ( self ( ) ) . done ( ) ; 
 + } ) . done ( self ( ) ) ; 
 } 
 
 private void onEncrypt ( final byte [ ] data , final PromiseResolver < EncryptedPackageRes > future ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java 
 index ee0cc28 . . 723ae25 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java 
 @ @ - 198 , 7 + 198 , 7 @ @ public class ModuleActor extends AskcableActor implements BusSubscriber { 
 } 
 } ) ; 
 } 
 - } . dispatch ( self ( ) ) ; 
 + } . done ( self ( ) ) ; 
 } 
 
 public void cancelRequest ( long rid ) { 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java 
 index 6ad3121 . . 063d466 100755 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java 
 @ @ - 221 , 7 + 221 , 7 @ @ public class Actor { 
 protected void exec ( @ NotNull PromiseResolver < T > executor ) { 
 dest . send ( new AskIntRequest ( msg , executor ) ) ; 
 } 
 - } . dispatch ( self ( ) ) ; 
 + } ; 
 } 
 
 public void ask ( ActorRef dest , Object message ) { 
 @ @ - 295 , 6 + 295 , 6 @ @ public class Actor { 
 public void apply ( Exception e ) { 
 self ( ) . send ( new AskIntError ( id , e ) ) ; 
 } 
 - } ) . done ( ) ; 
 + } ) . done ( self ( ) ) ; 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java 
 index 2f5e64c . . f16e918 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java 
 @ @ - 2 , 4 + 2 , 8 @ @ package im . actor . runtime . function ; 
 
 public interface Function < T , R > { 
 R apply ( T t ) ; 
 + 
 + default R apply2 ( T t ) { 
 + return apply ( t ) ; 
 + } 
 } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 index 89e8a6f . . 7a376aa 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 @ @ - 5 , 6 + 5 , 7 @ @ import org . jetbrains . annotations . Nullable ; 
 
 import java . util . ArrayList ; 
 
 + import im . actor . runtime . actors . Actor ; 
 import im . actor . runtime . actors . ActorRef ; 
 import im . actor . runtime . function . Supplier ; 
 
 @ @ - 18 , 7 + 19 , 7 @ @ public abstract class Promise < T > { 
 
 private final ArrayList < PromiseCallback < T > > callbacks = new ArrayList < PromiseCallback < T > > ( ) ; 
 
 - private PromiseDispatcher dispatcher = PromiseDispatcher . DEFAULT ; 
 + private ActorRef dispatchActor ; 
 private volatile T result ; 
 private volatile Exception exception ; 
 private volatile boolean isFinished ; 
 @ @ - 40 , 7 + 41 , 7 @ @ public abstract class Promise < T > { 
 public synchronized Promise < T > then ( final Supplier < T > then ) { 
 if ( isFinished ) { 
 if ( exception = = null ) { 
 - dispatcher . dispatch ( new Runnable ( ) { 
 + dispatchActor . send ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 then . apply ( result ) ; 
 @ @ - 72 , 7 + 73 , 7 @ @ public abstract class Promise < T > { 
 public synchronized Promise < T > failure ( final Supplier < Exception > failure ) { 
 if ( isFinished ) { 
 if ( exception ! = null ) { 
 - dispatcher . dispatch ( new Runnable ( ) { 
 + dispatchActor . send ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 failure . apply ( exception ) ; 
 @ @ - 104 , 7 + 105 , 7 @ @ public abstract class Promise < T > { 
 public synchronized Promise < T > complete ( final PromiseCallback < T > callback ) { 
 if ( isFinished ) { 
 
 - dispatcher . dispatch ( new Runnable ( ) { 
 + dispatchActor . send ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 if ( exception ! = null ) { 
 @ @ - 120 , 25 + 121 , 26 @ @ public abstract class Promise < T > { 
 return this ; 
 } 
 
 - / * * 
 - * Binding result dispatching to actor 
 - * 
 - * @ param ref dest actor 
 - * @ return this 
 - * / 
 - public Promise < T > dispatch ( ActorRef ref ) { 
 - dispatcher = PromiseDispatcher . forActor ( ref ) ; 
 - return this ; 
 - } 
 + / / / * * 
 + / / * Binding result dispatching to actor 
 + / / * 
 + / / * @ param ref dest actor 
 + / / * @ return this 
 + / / * / 
 + / / public Promise < T > dispatch ( ActorRef ref ) { 
 + / / dispatcher = PromiseDispatcher . forActor ( ref ) ; 
 + / / return this ; 
 + / / } 
 
 / * * 
 * Call this method to start promise execution 
 * / 
 - public Promise < T > done ( ) { 
 + public Promise < T > done ( ActorRef ref ) { 
 if ( isStarted ) { 
 throw new RuntimeException ( " Promise already started " ) ; 
 } 
 isStarted = true ; 
 + dispatchActor = ref ; 
 exec ( new PromiseResolver < T > ( this ) ) ; 
 return this ; 
 } 
 @ @ - 147 , 18 + 149 , 22 @ @ public abstract class Promise < T > { 
 return ( Promise < R > ) this ; 
 } 
 
 - / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { 
 + public ActorRef getDispatchActor ( ) { 
 + return dispatchActor ; 
 + } 
 + 
 + / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { 
 / / return Promises . zip ( ( Promise < T [ ] > ) this , zip ) ; 
 / / } 
 
 - / * * 
 - * Getting current dispatcher for promise 
 - * 
 - * @ return current dispatcher 
 - * / 
 - public PromiseDispatcher getDispatcher ( ) { 
 - return dispatcher ; 
 - } 
 + / / / * * 
 + / / * Getting current dispatcher for promise 
 + / / * 
 + / / * @ return current dispatcher 
 + / / * / 
 + / / public PromiseDispatcher getDispatcher ( ) { 
 + / / return dispatcher ; 
 + / / } 
 
 public boolean isFinished ( ) { 
 return isFinished ; 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 index 4614511 . . b071798 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 @ @ - 52 , 7 + 52 , 7 @ @ public class Promises { 
 executor . error ( e ) ; 
 } 
 } ) ; 
 - promises . done ( ) ; 
 + promises . done ( promises . getDispatchActor ( ) ) ; 
 } 
 } ; 
 } 
 @ @ - 106 , 7 + 106 , 7 @ @ public class Promises { 
 } ) ; 
 } 
 for ( Promise < T > p : promises ) { 
 - p . done ( ) ; 
 + p . done ( self . getDispatchActor ( ) ) ; 
 } 
 } 
 } ;
