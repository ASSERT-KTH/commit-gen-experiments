BLEU SCORE: 0.2557665697125104

TEST MSG: fix ( server : core ) : fix isOpen behavior
GENERATED MSG: fix ( server : messaging ) : fail - tolerant dialog init

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 5903fd3 . . f7db996 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 62 , 8 + 62 , 8 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > . map ( _ ⇒ SendMessageAck ( ) ) < nl > . pipeTo ( sender ( ) ) onSuccess { < nl > case _ ⇒ < nl > - if ( state . isHidden ) < nl > - self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } < nl > + updateOpen ( state ) < nl > } < nl > } < nl > < nl > @ @ - 305 , 6 + 305 , 9 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > context become initialized ( newState ) < nl > } < nl > < nl > + protected def updateOpen ( state : DialogState ) : Unit = < nl > + if ( ! state . isOpen ) { context become initialized ( state . updated ( Open ) ) } < nl > + < nl > private def updateReceiveDate ( state : DialogState , date : Long ) : Unit = < nl > context become initialized ( state . updated ( LastReceiveDate ( date ) ) ) < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index ab31e34 . . 02de752 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 216 , 20 + 216 , 18 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > } yield dialog < nl > } < nl > - isOpen ← restoreIsOpen ( ) < nl > } yield Initialized ( < nl > dialog . lastMessageDate . getMillis , < nl > dialog . ownerLastReceivedAt . getMillis , < nl > dialog . ownerLastReadAt . getMillis , < nl > dialog . shownAt . isEmpty , < nl > dialog . isFavourite , < nl > - isOpen < nl > + isOpen = isOpen ( peer ) < nl > ) ) pipeTo self < nl > < nl > - private def restoreIsOpen ( ) : DBIO [ Boolean ] = < nl > + private def isOpen ( peer : Peer ) : Boolean = < nl > peer . typ match { < nl > - case PeerType . Private ⇒ < nl > - HistoryMessageRepo . findNewest ( peer . id , Peer . privat ( userId ) ) map ( _ . isDefined ) < nl > - case _ ⇒ DBIO . successful ( true ) < nl > + case PeerType . Private ⇒ false < nl > + case _ ⇒ true < nl > } < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala < nl > index 6de5a4a . . f52553c 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala < nl > @ @ - 39 , 12 + 39 , 6 @ @ class MessagingReadsSpec < nl > val user1AccessHash = ACLUtils . userAccessHash ( client2 . authId , user1 . id , getUserModel ( user1 . id ) . accessSalt ) < nl > val user1OutPeer = ApiOutPeer ( ApiPeerType . Private , user1 . id , user1AccessHash ) < nl > < nl > - { < nl > - implicit val client = client2 < nl > - < nl > - sendPrivateMessage ( user1 . id , ApiTextMessage ( s " This is hack to initialize dialog and set isOpen to ` true ` " , Vector . empty , None ) ) < nl > - } < nl > - < nl > val states _ 1 _ 3 = { < nl > implicit val client = client1 < nl > ( 1 to 3 ) map { i ⇒
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > index dd3f950 . . b7a71be 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > @ @ - 2 , 7 + 2 , 8 @ @ package im . actor . server . dialog < nl > < nl > import java . time . Instant < nl > < nl > - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } < nl > + import akka . actor . _ < nl > + import akka . pattern . pipe < nl > import akka . util . Timeout < nl > import com . github . benmanes . caffeine . cache . Cache < nl > import im . actor . api . rpc . misc . ApiExtension < nl > @ @ - 118 , 14 + 119 , 17 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = < nl > createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) < nl > < nl > - createDialogIfNeeded ( ) < nl > + init ( ) < nl > < nl > - override def receive : Receive = init < nl > + override def receive : Receive = initializing < nl > < nl > - def init : Receive = receiveStashing ( replyTo ⇒ { < nl > + def initializing : Receive = receiveStashing ( replyTo ⇒ { < nl > case Initialized ( isHidden ) ⇒ < nl > context become initialized ( DialogState ( isHidden = isHidden ) ) < nl > unstashAll ( ) < nl > + case Status . Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to init dialog " ) < nl > + self ! Kill < nl > } ) < nl > < nl > def initialized ( state : DialogState ) : Receive = { < nl > @ @ - 165 , 7 + 169 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > * / < nl > def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) < nl > < nl > - private [ this ] def createDialogIfNeeded ( ) : Future [ Unit ] = < nl > + private [ this ] def init ( ) : Unit = < nl > db . run ( for { < nl > optDialog ← DialogRepo . find ( userId , peer ) < nl > dialog ← optDialog match { < nl > @ @ - 177 , 6 + 181 , 6 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > } yield dialog < nl > } < nl > - } yield { self ! Initialized ( dialog . shownAt . isEmpty ) } ) < nl > + } yield Initialized ( dialog . shownAt . isEmpty ) ) pipeTo self < nl > < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 61849ba . . 0a34a19 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 131 , 7 + 131 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } else { < nl > Future . successful ( MessageReadAck ( ) ) < nl > } ) pipeTo sender ( ) andThen { < nl > - case Failure ( e ) = > log . error ( e , " Failed to ack MessageRead " ) < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) < nl > } < nl > < nl > if ( mustRead ) { < nl > @ @ - 143 , 9 + 143 , 9 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > < nl > protected def ackMessageRead ( state : DialogState , mr : MessageRead ) : Unit = { < nl > val notifyFuture = ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { < nl > - case Failure ( e ) = > log . error ( e , " Failed to ack MessageRead " ) < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) < nl > } < nl > - < nl > + < nl > onSuccess ( notifyFuture ) { _ ⇒ < nl > updatePeerReadDate ( state , mr . date ) < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 5903fd3 . . f7db996 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 62 , 8 + 62 , 8 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 . map ( _ ⇒ SendMessageAck ( ) ) 
 . pipeTo ( sender ( ) ) onSuccess { 
 case _ ⇒ 
 - if ( state . isHidden ) 
 - self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } 
 + updateOpen ( state ) 
 } 
 } 
 
 @ @ - 305 , 6 + 305 , 9 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 context become initialized ( newState ) 
 } 
 
 + protected def updateOpen ( state : DialogState ) : Unit = 
 + if ( ! state . isOpen ) { context become initialized ( state . updated ( Open ) ) } 
 + 
 private def updateReceiveDate ( state : DialogState , date : Long ) : Unit = 
 context become initialized ( state . updated ( LastReceiveDate ( date ) ) ) 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index ab31e34 . . 02de752 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 216 , 20 + 216 , 18 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 } yield dialog 
 } 
 - isOpen ← restoreIsOpen ( ) 
 } yield Initialized ( 
 dialog . lastMessageDate . getMillis , 
 dialog . ownerLastReceivedAt . getMillis , 
 dialog . ownerLastReadAt . getMillis , 
 dialog . shownAt . isEmpty , 
 dialog . isFavourite , 
 - isOpen 
 + isOpen = isOpen ( peer ) 
 ) ) pipeTo self 
 
 - private def restoreIsOpen ( ) : DBIO [ Boolean ] = 
 + private def isOpen ( peer : Peer ) : Boolean = 
 peer . typ match { 
 - case PeerType . Private ⇒ 
 - HistoryMessageRepo . findNewest ( peer . id , Peer . privat ( userId ) ) map ( _ . isDefined ) 
 - case _ ⇒ DBIO . successful ( true ) 
 + case PeerType . Private ⇒ false 
 + case _ ⇒ true 
 } 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala 
 index 6de5a4a . . f52553c 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingReadsSpec . scala 
 @ @ - 39 , 12 + 39 , 6 @ @ class MessagingReadsSpec 
 val user1AccessHash = ACLUtils . userAccessHash ( client2 . authId , user1 . id , getUserModel ( user1 . id ) . accessSalt ) 
 val user1OutPeer = ApiOutPeer ( ApiPeerType . Private , user1 . id , user1AccessHash ) 
 
 - { 
 - implicit val client = client2 
 - 
 - sendPrivateMessage ( user1 . id , ApiTextMessage ( s " This is hack to initialize dialog and set isOpen to ` true ` " , Vector . empty , None ) ) 
 - } 
 - 
 val states _ 1 _ 3 = { 
 implicit val client = client1 
 ( 1 to 3 ) map { i ⇒

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 index dd3f950 . . b7a71be 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 @ @ - 2 , 7 + 2 , 8 @ @ package im . actor . server . dialog 
 
 import java . time . Instant 
 
 - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } 
 + import akka . actor . _ 
 + import akka . pattern . pipe 
 import akka . util . Timeout 
 import com . github . benmanes . caffeine . cache . Cache 
 import im . actor . api . rpc . misc . ApiExtension 
 @ @ - 118 , 14 + 119 , 17 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = 
 createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) 
 
 - createDialogIfNeeded ( ) 
 + init ( ) 
 
 - override def receive : Receive = init 
 + override def receive : Receive = initializing 
 
 - def init : Receive = receiveStashing ( replyTo ⇒ { 
 + def initializing : Receive = receiveStashing ( replyTo ⇒ { 
 case Initialized ( isHidden ) ⇒ 
 context become initialized ( DialogState ( isHidden = isHidden ) ) 
 unstashAll ( ) 
 + case Status . Failure ( e ) ⇒ 
 + log . error ( e , " Failed to init dialog " ) 
 + self ! Kill 
 } ) 
 
 def initialized ( state : DialogState ) : Receive = { 
 @ @ - 165 , 7 + 169 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 * / 
 def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) 
 
 - private [ this ] def createDialogIfNeeded ( ) : Future [ Unit ] = 
 + private [ this ] def init ( ) : Unit = 
 db . run ( for { 
 optDialog ← DialogRepo . find ( userId , peer ) 
 dialog ← optDialog match { 
 @ @ - 177 , 6 + 181 , 6 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 } yield dialog 
 } 
 - } yield { self ! Initialized ( dialog . shownAt . isEmpty ) } ) 
 + } yield Initialized ( dialog . shownAt . isEmpty ) ) pipeTo self 
 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 61849ba . . 0a34a19 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 131 , 7 + 131 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } else { 
 Future . successful ( MessageReadAck ( ) ) 
 } ) pipeTo sender ( ) andThen { 
 - case Failure ( e ) = > log . error ( e , " Failed to ack MessageRead " ) 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) 
 } 
 
 if ( mustRead ) { 
 @ @ - 143 , 9 + 143 , 9 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 
 protected def ackMessageRead ( state : DialogState , mr : MessageRead ) : Unit = { 
 val notifyFuture = ( deliveryExt . notifyRead ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReadAck ( ) } ) pipeTo sender ( ) andThen { 
 - case Failure ( e ) = > log . error ( e , " Failed to ack MessageRead " ) 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageRead " ) 
 } 
 - 
 + 
 onSuccess ( notifyFuture ) { _ ⇒ 
 updatePeerReadDate ( state , mr . date ) 
 }
