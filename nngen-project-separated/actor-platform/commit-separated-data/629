BLEU SCORE: 0.44632361378533286

TEST MSG: test ( server ) : add bot command spec
GENERATED MSG: test ( server ) : EchoBotSpec

TEST DIFF (one line): diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / user / BotCommandsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / user / BotCommandsSpec . scala < nl > index 7b8971f . . 80f3120 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / user / BotCommandsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / user / BotCommandsSpec . scala < nl > @ @ - 1 , 9 + 1 , 18 @ @ < nl > package im . actor . server . user < nl > < nl > + import im . actor . api . rpc . messaging . ApiTextMessage < nl > + import im . actor . api . rpc . users . UpdateUserBotCommandsChanged < nl > + import im . actor . api . rpc . { AuthData , ClientData } < nl > import im . actor . server . bots . BotCommand < nl > - import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } < nl > + import im . actor . server . _ < nl > + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > + import im . actor . server . sequence . { SeqState , SeqUpdatesExtension } < nl > < nl > - class BotCommandsSpec extends BaseAppSuite with ImplicitAuthService with ImplicitSessionRegion { < nl > + class BotCommandsSpec extends BaseAppSuite < nl > + with ImplicitAuthService < nl > + with ImplicitSessionRegion < nl > + with MessagingSpecHelpers < nl > + with SeqUpdateMatchers { < nl > < nl > behavior of " User ' s bot commands " < nl > < nl > @ @ - 11 , 7 + 20 , 10 @ @ class BotCommandsSpec extends BaseAppSuite with ImplicitAuthService with Implici < nl > < nl > it should " add and remove " in addAndRemove ( ) < nl > < nl > + it should " send updates to related users , when commands change " in changeCommands ( ) < nl > + < nl > val userExt = UserExtension ( system ) < nl > + implicit val msgService = new MessagingServiceImpl ( ) < nl > < nl > def dontAddWrong ( ) = { < nl > val ( botUser , _ , _ , _ ) = createUser ( ) < nl > @ @ - 62 , 8 + 74 , 8 @ @ class BotCommandsSpec extends BaseAppSuite with ImplicitAuthService with Implici < nl > } < nl > < nl > / / respond with success when trying to remove same command multiple times < nl > - whenReady ( userExt . removeBotCommand ( botUser . id , fireCommand . slashCommand ) ) ( identity ) < nl > - whenReady ( userExt . removeBotCommand ( botUser . id , fireCommand . slashCommand ) ) ( identity ) < nl > + whenReady ( removeCommand ( botUser . id , fireCommand . slashCommand ) ) ( identity ) < nl > + whenReady ( removeCommand ( botUser . id , fireCommand . slashCommand ) ) ( identity ) < nl > < nl > whenReady ( userExt . getApiStruct ( botUser . id , 0 , 0L ) ) { resp ⇒ < nl > resp . botCommands should have size 1 < nl > @ @ - 72 , 7 + 84 , 52 @ @ class BotCommandsSpec extends BaseAppSuite with ImplicitAuthService with Implici < nl > } < nl > } < nl > < nl > + def changeCommands ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val sessionId = createSessionId ( ) < nl > + val clientData = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + < nl > + val ( botUser , _ , _ , _ ) = createUser ( ) < nl > + < nl > + { < nl > + / / send message to note relation < nl > + implicit val cd = clientData < nl > + sendPrivateMessage ( botUser . id , ApiTextMessage ( " text " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + val runCommand = BotCommand ( " run " , " Run away as fast as you can " , Some ( " run " ) ) < nl > + < nl > + whenReady ( addCommand ( botUser . id , runCommand ) ) ( identity ) < nl > + < nl > + { < nl > + implicit val cd = clientData < nl > + expectUpdate ( classOf [ UpdateUserBotCommandsChanged ] ) { upd ⇒ < nl > + upd . userId shouldEqual botUser . id < nl > + upd . commands should have size 1 < nl > + val run = upd . commands . head < nl > + run . slashCommand shouldEqual runCommand . slashCommand < nl > + run . description shouldEqual runCommand . description < nl > + run . locKey shouldEqual runCommand . locKey < nl > + } < nl > + } < nl > + < nl > + val SeqState ( seq , _ ) = whenReady ( SeqUpdatesExtension ( system ) . getSeqState ( alice . id ) ) ( identity ) < nl > + < nl > + whenReady ( removeCommand ( botUser . id , runCommand . slashCommand ) ) ( identity ) < nl > + < nl > + { < nl > + implicit val cd = clientData < nl > + expectUpdate ( seq , classOf [ UpdateUserBotCommandsChanged ] ) { upd ⇒ < nl > + upd . userId shouldEqual botUser . id < nl > + upd . commands shouldBe empty < nl > + } < nl > + } < nl > + } < nl > + < nl > private def addCommand ( userId : Int , commmand : BotCommand ) = < nl > userExt . addBotCommand ( userId , commmand ) < nl > < nl > + private def removeCommand ( userId : Int , slashCommand : String ) = < nl > + userExt . removeBotCommand ( userId , slashCommand ) < nl > + < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > index 99cc45c . . b9c0468 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > @ @ - 19 , 7 + 19 , 6 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer < nl > private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( < nl > ( botUserId : BotUserId , botAuthId : BotAuthId ) ⇒ { < nl > / / FIXME : check access hash < nl > - < nl > for { < nl > SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( < nl > peer = peer , < nl > diff - - git a / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala b / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 1cfae41 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala < nl > @ @ - 0 , 0 + 1 , 109 @ @ < nl > + package im . actor . server . bot < nl > + < nl > + import akka . actor . { Props , ActorSystem } < nl > + import im . actor . api . rpc . ClientData < nl > + import im . actor . api . rpc . messaging . { ResponseLoadHistory , ApiTextMessage } < nl > + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType , ApiPeer } < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > + import im . actor . server . dialog . DialogExtension < nl > + import im . actor . server . _ < nl > + import org . scalatest . Inside . _ < nl > + < nl > + import scala . util . Random < nl > + < nl > + object EchoBot { < nl > + val UserId = 100 < nl > + < nl > + def start ( ) ( implicit system : ActorSystem ) = system . actorOf ( props , " EchoBot " ) < nl > + < nl > + private def props = Props ( classOf [ EchoBot ] ) < nl > + } < nl > + < nl > + final class EchoBot extends InternalBot ( EchoBot . UserId , " echo " , " Echo Bot " , isAdmin = false ) { < nl > + import im . actor . bots . BotMessages . _ < nl > + < nl > + override def onMessage ( m : Message ) : Unit = { < nl > + m . message match { < nl > + case TextMessage ( text ) ⇒ < nl > + requestSendMessage ( m . peer , nextRandomId ( ) , TextMessage ( text ) ) < nl > + case _ ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + final class EchoBotSpec < nl > + extends BaseAppSuite < nl > + with ServiceSpecHelpers < nl > + with GroupsServiceHelpers < nl > + with ImplicitAuthService < nl > + with ImplicitSessionRegionProxy { < nl > + it should " reply with the same message ( private ) " in replyPrivate < nl > + it should " reply with the same message ( group ) " in replyGroup < nl > + < nl > + private lazy val dialogExt = DialogExtension ( system ) < nl > + private lazy val msgService = MessagingServiceImpl ( ) < nl > + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > + < nl > + def replyPrivate ( ) = { < nl > + val ( user , authId , _ ) = createUser ( ) < nl > + < nl > + Thread . sleep ( 1000 ) < nl > + < nl > + whenReady ( dialogExt . sendMessage ( < nl > + peer = ApiPeer ( ApiPeerType . Private , EchoBot . UserId ) , < nl > + senderUserId = user . id , < nl > + senderAuthId = authId , < nl > + randomId = Random . nextLong ( ) , < nl > + message = ApiTextMessage ( " Hello " , Vector . empty , None ) , < nl > + isFat = false < nl > + ) ) ( identity ) < nl > + < nl > + Thread . sleep ( 2000 ) < nl > + < nl > + implicit val clientData = ClientData ( authId , Random . nextLong ( ) , Some ( user . id ) ) < nl > + < nl > + val botOutPeer = getOutPeer ( EchoBot . UserId , authId ) < nl > + < nl > + whenReady ( msgService . handleLoadHistory ( botOutPeer , 0 , 100 ) ) { rsp ⇒ < nl > + inside ( rsp ) { < nl > + case Ok ( ResponseLoadHistory ( history , _ ) ) ⇒ < nl > + history . length shouldBe ( 2 ) < nl > + val tm = history . last . message . asInstanceOf [ ApiTextMessage ] < nl > + tm . text shouldBe " Hello " < nl > + } < nl > + } < nl > + } < nl > + < nl > + def replyGroup ( ) = { < nl > + val ( user , authId , _ ) = createUser ( ) < nl > + implicit val clientData = ClientData ( authId , 1 , Some ( user . id ) ) < nl > + val groupPeer = createGroup ( " Echo group " , Set ( EchoBot . UserId ) ) . groupPeer < nl > + val outPeer = ApiOutPeer ( ApiPeerType . Group , groupPeer . groupId , groupPeer . accessHash ) < nl > + < nl > + whenReady ( dialogExt . sendMessage ( < nl > + peer = ApiPeer ( ApiPeerType . Group , groupPeer . groupId ) , < nl > + senderUserId = user . id , < nl > + senderAuthId = authId , < nl > + randomId = Random . nextLong ( ) , < nl > + message = ApiTextMessage ( " Hello " , Vector . empty , None ) , < nl > + isFat = false < nl > + ) ) ( identity ) < nl > + < nl > + Thread . sleep ( 2000 ) < nl > + < nl > + whenReady ( msgService . handleLoadHistory ( outPeer , 0 , 100 ) ) { rsp ⇒ < nl > + inside ( rsp ) { < nl > + case Ok ( ResponseLoadHistory ( history , _ ) ) ⇒ < nl > + history . length shouldBe 4 < nl > + val tm = history . last . message . asInstanceOf [ ApiTextMessage ] < nl > + tm . text shouldBe " Hello " < nl > + } < nl > + } < nl > + } < nl > + < nl > + override def beforeAll = { < nl > + EchoBot . start ( ) < nl > + } < nl > + } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / user / BotCommandsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / user / BotCommandsSpec . scala 
 index 7b8971f . . 80f3120 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / user / BotCommandsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / user / BotCommandsSpec . scala 
 @ @ - 1 , 9 + 1 , 18 @ @ 
 package im . actor . server . user 
 
 + import im . actor . api . rpc . messaging . ApiTextMessage 
 + import im . actor . api . rpc . users . UpdateUserBotCommandsChanged 
 + import im . actor . api . rpc . { AuthData , ClientData } 
 import im . actor . server . bots . BotCommand 
 - import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } 
 + import im . actor . server . _ 
 + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 + import im . actor . server . sequence . { SeqState , SeqUpdatesExtension } 
 
 - class BotCommandsSpec extends BaseAppSuite with ImplicitAuthService with ImplicitSessionRegion { 
 + class BotCommandsSpec extends BaseAppSuite 
 + with ImplicitAuthService 
 + with ImplicitSessionRegion 
 + with MessagingSpecHelpers 
 + with SeqUpdateMatchers { 
 
 behavior of " User ' s bot commands " 
 
 @ @ - 11 , 7 + 20 , 10 @ @ class BotCommandsSpec extends BaseAppSuite with ImplicitAuthService with Implici 
 
 it should " add and remove " in addAndRemove ( ) 
 
 + it should " send updates to related users , when commands change " in changeCommands ( ) 
 + 
 val userExt = UserExtension ( system ) 
 + implicit val msgService = new MessagingServiceImpl ( ) 
 
 def dontAddWrong ( ) = { 
 val ( botUser , _ , _ , _ ) = createUser ( ) 
 @ @ - 62 , 8 + 74 , 8 @ @ class BotCommandsSpec extends BaseAppSuite with ImplicitAuthService with Implici 
 } 
 
 / / respond with success when trying to remove same command multiple times 
 - whenReady ( userExt . removeBotCommand ( botUser . id , fireCommand . slashCommand ) ) ( identity ) 
 - whenReady ( userExt . removeBotCommand ( botUser . id , fireCommand . slashCommand ) ) ( identity ) 
 + whenReady ( removeCommand ( botUser . id , fireCommand . slashCommand ) ) ( identity ) 
 + whenReady ( removeCommand ( botUser . id , fireCommand . slashCommand ) ) ( identity ) 
 
 whenReady ( userExt . getApiStruct ( botUser . id , 0 , 0L ) ) { resp ⇒ 
 resp . botCommands should have size 1 
 @ @ - 72 , 7 + 84 , 52 @ @ class BotCommandsSpec extends BaseAppSuite with ImplicitAuthService with Implici 
 } 
 } 
 
 + def changeCommands ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val sessionId = createSessionId ( ) 
 + val clientData = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + 
 + val ( botUser , _ , _ , _ ) = createUser ( ) 
 + 
 + { 
 + / / send message to note relation 
 + implicit val cd = clientData 
 + sendPrivateMessage ( botUser . id , ApiTextMessage ( " text " , Vector . empty , None ) ) 
 + } 
 + 
 + val runCommand = BotCommand ( " run " , " Run away as fast as you can " , Some ( " run " ) ) 
 + 
 + whenReady ( addCommand ( botUser . id , runCommand ) ) ( identity ) 
 + 
 + { 
 + implicit val cd = clientData 
 + expectUpdate ( classOf [ UpdateUserBotCommandsChanged ] ) { upd ⇒ 
 + upd . userId shouldEqual botUser . id 
 + upd . commands should have size 1 
 + val run = upd . commands . head 
 + run . slashCommand shouldEqual runCommand . slashCommand 
 + run . description shouldEqual runCommand . description 
 + run . locKey shouldEqual runCommand . locKey 
 + } 
 + } 
 + 
 + val SeqState ( seq , _ ) = whenReady ( SeqUpdatesExtension ( system ) . getSeqState ( alice . id ) ) ( identity ) 
 + 
 + whenReady ( removeCommand ( botUser . id , runCommand . slashCommand ) ) ( identity ) 
 + 
 + { 
 + implicit val cd = clientData 
 + expectUpdate ( seq , classOf [ UpdateUserBotCommandsChanged ] ) { upd ⇒ 
 + upd . userId shouldEqual botUser . id 
 + upd . commands shouldBe empty 
 + } 
 + } 
 + } 
 + 
 private def addCommand ( userId : Int , commmand : BotCommand ) = 
 userExt . addBotCommand ( userId , commmand ) 
 
 + private def removeCommand ( userId : Int , slashCommand : String ) = 
 + userExt . removeBotCommand ( userId , slashCommand ) 
 + 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 index 99cc45c . . b9c0468 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 @ @ - 19 , 7 + 19 , 6 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer 
 private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( 
 ( botUserId : BotUserId , botAuthId : BotAuthId ) ⇒ { 
 / / FIXME : check access hash 
 - 
 for { 
 SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( 
 peer = peer , 
 diff - - git a / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala b / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala 
 new file mode 100644 
 index 0000000 . . 1cfae41 
 - - - / dev / null 
 + + + b / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala 
 @ @ - 0 , 0 + 1 , 109 @ @ 
 + package im . actor . server . bot 
 + 
 + import akka . actor . { Props , ActorSystem } 
 + import im . actor . api . rpc . ClientData 
 + import im . actor . api . rpc . messaging . { ResponseLoadHistory , ApiTextMessage } 
 + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType , ApiPeer } 
 + import im . actor . api . rpc . _ 
 + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 + import im . actor . server . dialog . DialogExtension 
 + import im . actor . server . _ 
 + import org . scalatest . Inside . _ 
 + 
 + import scala . util . Random 
 + 
 + object EchoBot { 
 + val UserId = 100 
 + 
 + def start ( ) ( implicit system : ActorSystem ) = system . actorOf ( props , " EchoBot " ) 
 + 
 + private def props = Props ( classOf [ EchoBot ] ) 
 + } 
 + 
 + final class EchoBot extends InternalBot ( EchoBot . UserId , " echo " , " Echo Bot " , isAdmin = false ) { 
 + import im . actor . bots . BotMessages . _ 
 + 
 + override def onMessage ( m : Message ) : Unit = { 
 + m . message match { 
 + case TextMessage ( text ) ⇒ 
 + requestSendMessage ( m . peer , nextRandomId ( ) , TextMessage ( text ) ) 
 + case _ ⇒ 
 + } 
 + } 
 + } 
 + 
 + final class EchoBotSpec 
 + extends BaseAppSuite 
 + with ServiceSpecHelpers 
 + with GroupsServiceHelpers 
 + with ImplicitAuthService 
 + with ImplicitSessionRegionProxy { 
 + it should " reply with the same message ( private ) " in replyPrivate 
 + it should " reply with the same message ( group ) " in replyGroup 
 + 
 + private lazy val dialogExt = DialogExtension ( system ) 
 + private lazy val msgService = MessagingServiceImpl ( ) 
 + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 + 
 + def replyPrivate ( ) = { 
 + val ( user , authId , _ ) = createUser ( ) 
 + 
 + Thread . sleep ( 1000 ) 
 + 
 + whenReady ( dialogExt . sendMessage ( 
 + peer = ApiPeer ( ApiPeerType . Private , EchoBot . UserId ) , 
 + senderUserId = user . id , 
 + senderAuthId = authId , 
 + randomId = Random . nextLong ( ) , 
 + message = ApiTextMessage ( " Hello " , Vector . empty , None ) , 
 + isFat = false 
 + ) ) ( identity ) 
 + 
 + Thread . sleep ( 2000 ) 
 + 
 + implicit val clientData = ClientData ( authId , Random . nextLong ( ) , Some ( user . id ) ) 
 + 
 + val botOutPeer = getOutPeer ( EchoBot . UserId , authId ) 
 + 
 + whenReady ( msgService . handleLoadHistory ( botOutPeer , 0 , 100 ) ) { rsp ⇒ 
 + inside ( rsp ) { 
 + case Ok ( ResponseLoadHistory ( history , _ ) ) ⇒ 
 + history . length shouldBe ( 2 ) 
 + val tm = history . last . message . asInstanceOf [ ApiTextMessage ] 
 + tm . text shouldBe " Hello " 
 + } 
 + } 
 + } 
 + 
 + def replyGroup ( ) = { 
 + val ( user , authId , _ ) = createUser ( ) 
 + implicit val clientData = ClientData ( authId , 1 , Some ( user . id ) ) 
 + val groupPeer = createGroup ( " Echo group " , Set ( EchoBot . UserId ) ) . groupPeer 
 + val outPeer = ApiOutPeer ( ApiPeerType . Group , groupPeer . groupId , groupPeer . accessHash ) 
 + 
 + whenReady ( dialogExt . sendMessage ( 
 + peer = ApiPeer ( ApiPeerType . Group , groupPeer . groupId ) , 
 + senderUserId = user . id , 
 + senderAuthId = authId , 
 + randomId = Random . nextLong ( ) , 
 + message = ApiTextMessage ( " Hello " , Vector . empty , None ) , 
 + isFat = false 
 + ) ) ( identity ) 
 + 
 + Thread . sleep ( 2000 ) 
 + 
 + whenReady ( msgService . handleLoadHistory ( outPeer , 0 , 100 ) ) { rsp ⇒ 
 + inside ( rsp ) { 
 + case Ok ( ResponseLoadHistory ( history , _ ) ) ⇒ 
 + history . length shouldBe 4 
 + val tm = history . last . message . asInstanceOf [ ApiTextMessage ] 
 + tm . text shouldBe " Hello " 
 + } 
 + } 
 + } 
 + 
 + override def beforeAll = { 
 + EchoBot . start ( ) 
 + } 
 + } 
 \ No newline at end of file
