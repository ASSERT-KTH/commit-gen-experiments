BLEU SCORE: 0.15415064977510756

TEST MSG: feat ( server : groups , search ) : isDeleted and update in groups ; search users and groups by global name prefix
GENERATED MSG: feat ( server : search ) : peer search

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala < nl > index 50fb910 . . 0dbd166 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala < nl > @ @ - 367 , 7 + 367 , 8 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { < nl > if ( newState . groupType . isChannel ) < nl > UpdateGroupMembersCountChanged ( groupId , membersCount = 0 ) < nl > else < nl > - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) < nl > + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > + UpdateGroupDeleted ( groupId ) < nl > ) < nl > < nl > / / TODO : remove deprecated . GroupInviteTokenRepo don ' t have replacement yet . < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > index b6527fb . . cfde4c1 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > @ @ - 108 , 7 + 108 , 8 @ @ trait GroupQueryHandlers { < nl > case Channel ⇒ ApiGroupType . CHANNEL < nl > case General | Unrecognized ( _ ) ⇒ ApiGroupType . GROUP < nl > } ) , < nl > - canSendMessage = Some ( state . permissions . canSendMessage ( clientUserId ) ) < nl > + canSendMessage = Some ( state . permissions . canSendMessage ( clientUserId ) ) , < nl > + isDeleted = Some ( state . isDeleted ) < nl > ) < nl > ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala < nl > index d6cae1b . . dc766a5 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala < nl > @ @ - 34 , 6 + 34 , 41 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { < nl > case GlobalNameOwner ( OwnerType . User , userId ) ⇒ userId < nl > } ) < nl > < nl > + / * * < nl > + * Search groups ( id - > global name ) by global name prefix < nl > + * Looks only in GlobalNamesStorage < nl > + * / < nl > + def groupIdsByPrefix ( namePrefix : String ) : Future [ IndexedSeq [ ( Int , String ) ] ] = { < nl > + conn . run ( GlobalNamesStorage . getByPrefix ( namePrefix ) ) map { searchResults ⇒ < nl > + searchResults flatMap { < nl > + case ( fullName , bytes ) ⇒ < nl > + Some ( GlobalNameOwner . parseFrom ( bytes ) ) filter ( _ . ownerType . isGroup ) map ( o ⇒ o . ownerId → fullName ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + / * * < nl > + * Search users ( id - > global name ) by global name prefix < nl > + * Looks in both GlobalNamesStorage and UserRepo ( compatibility mode ) < nl > + * / < nl > + def userIdsByPrefix ( namePrefix : String ) : Future [ IndexedSeq [ ( Int , String ) ] ] = { < nl > + val kvSearch = conn . run ( GlobalNamesStorage . getByPrefix ( namePrefix ) ) map { searchResults ⇒ < nl > + searchResults flatMap { < nl > + case ( fullName , bytes ) ⇒ < nl > + Some ( GlobalNameOwner . parseFrom ( bytes ) ) filter ( _ . ownerType . isUser ) map ( o ⇒ o . ownerId → fullName ) < nl > + } < nl > + } < nl > + val compatSearch = db . run ( UserRepo . findByNicknamePrefix ( namePrefix ) ) map { users ⇒ < nl > + users flatMap { user ⇒ < nl > + user . nickname map ( user . id → _ ) < nl > + } < nl > + } < nl > + for { < nl > + kv ← kvSearch < nl > + compat ← compatSearch < nl > + } yield kv + + compat < nl > + } < nl > + < nl > def getGroupId ( name : String ) : Future [ Option [ Int ] ] = < nl > getOwner ( name ) map ( _ . collect { < nl > case GlobalNameOwner ( OwnerType . Group , groupId ) ⇒ groupId < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > index a8ca2f0 . . 56cd6bb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > @ @ - 11 , 6 + 11 , 7 @ @ import im . actor . server . auth . DeviceInfo < nl > import im . actor . server . bots . BotCommand < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . file . Avatar < nl > + import im . actor . server . names . GlobalNamesStorageKeyValueStorage < nl > import im . actor . server . persist . UserRepo < nl > import im . actor . server . pubsub . PubSubExtension < nl > import im . actor . server . sequence . { SeqState , SeqUpdatesExtension } < nl > @ @ - 144 , 6 + 145 , 7 @ @ private [ user ] sealed trait Queries { < nl > implicit val system : ActorSystem < nl > import system . dispatcher < nl > val log : LoggingAdapter < nl > + private lazy val globalNamesStorage = new GlobalNamesStorageKeyValueStorage < nl > < nl > implicit val timeout : Timeout < nl > < nl > @ @ - 192 , 7 + 194 , 11 @ @ private [ user ] sealed trait Queries { < nl > def isAdmin ( userId : Int ) : Future [ Boolean ] = < nl > ( viewRegion . ref ? IsAdmin ( userId ) ) . mapTo [ IsAdminResponse ] . map ( _ . isAdmin ) < nl > < nl > - def findUserIds ( query : String ) : Future [ Seq [ Int ] ] = DbExtension ( system ) . db . run ( UserRepo . findIds ( query ) ) < nl > + def findUserIds ( query : String ) : Future [ Seq [ Int ] ] = < nl > + for { < nl > + byPhoneAndEmail ← DbExtension ( system ) . db . run ( UserRepo . findIds ( query ) ) < nl > + byNickname ← globalNamesStorage . getUserId ( query ) < nl > + } yield byPhoneAndEmail + + byNickname < nl > } < nl > < nl > private [ user ] sealed trait AuthCommands { < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala < nl > index efea1aa . . 35391e0 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala < nl > @ @ - 40 , 11 + 40 , 13 @ @ object UserRepo { < nl > val byIdC = Compiled ( byId _ ) < nl > val nameByIdC = Compiled ( nameById _ ) < nl > < nl > - private def byNickname ( nickname : Rep [ String ] ) = users filter ( _ . nickname . toLowerCase = = = nickname . toLowerCase ) < nl > - private def idsByNickname ( nickname : Rep [ String ] ) = byNickname ( nickname ) . map ( _ . id ) < nl > + private def byNickname ( nickname : Rep [ String ] ) = < nl > + users filter ( _ . nickname . toLowerCase = = = nickname . toLowerCase ) < nl > + private def byNicknamePrefix ( nickPrefix : Rep [ String ] ) = < nl > + users filter ( _ . nickname . toLowerCase . like ( nickPrefix . toLowerCase ) ) < nl > < nl > private val byNicknameC = Compiled ( byNickname _ ) < nl > - private val idsByNicknameC = Compiled ( idsByNickname _ ) < nl > + private val byNicknamePrefixC = Compiled ( byNicknamePrefix _ ) < nl > < nl > def byPhone ( phone : Rep [ Long ] ) = ( for { < nl > phones ← UserPhoneRepo . phones . filter ( _ . number = = = phone ) < nl > @ @ - 107 , 24 + 109 , 30 @ @ object UserRepo { < nl > users . filter ( _ . id inSet ids ) . map ( u ⇒ ( u . id , u . accessSalt ) ) . result < nl > < nl > @ deprecated ( " user GlobalNamesStorageKeyValueStorage instead " , " 2016 - 07 - 17 " ) < nl > - def findByNickname ( query : String ) = { < nl > + def findByNickname ( query : String ) : DBIO [ Option [ User ] ] = { < nl > val nickname = < nl > if ( query . startsWith ( " @ " ) ) query . drop ( 1 ) else query < nl > byNicknameC ( nickname ) . result . headOption < nl > } < nl > < nl > + @ deprecated ( " user GlobalNamesStorageKeyValueStorage instead " , " 2016 - 07 - 17 " ) < nl > + def findByNicknamePrefix ( query : String ) : DBIO [ Seq [ User ] ] = { < nl > + val nickname : String = < nl > + if ( query . startsWith ( " @ " ) ) query . drop ( 1 ) else query < nl > + byNicknamePrefixC ( nickname ) . result < nl > + } < nl > + < nl > def findIdsByEmail ( email : String ) = < nl > idsByEmailC ( email ) . result . headOption < nl > < nl > def findIds ( query : String ) ( implicit ec : ExecutionContext ) = < nl > for { < nl > e ← idsByEmailC ( query ) . result < nl > - n ← idsByNicknameC ( query ) . result < nl > p ← PhoneNumberUtils . normalizeStr ( query ) < nl > . headOption < nl > . map ( idByPhoneC ( _ ) . result ) < nl > . getOrElse ( DBIO . successful ( Nil ) ) < nl > - } yield e + + n + + p < nl > + } yield e + + p < nl > < nl > @ deprecated ( " user GlobalNamesStorageKeyValueStorage instead " , " 2016 - 07 - 17 " ) < nl > def setNickname ( userId : Int , nickname : Option [ String ] ) = < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > index 82c3f34 . . 1bff78b 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > @ @ - 12 , 8 + 12 , 8 @ @ import im . actor . concurrent . FutureExt < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . DialogExtension < nl > import im . actor . server . group . { GroupExtension , GroupUtils } < nl > + import im . actor . server . names . GlobalNamesStorageKeyValueStorage < nl > import im . actor . server . persist . contact . UserContactRepo < nl > - import im . actor . server . persist . GroupRepo < nl > import im . actor . server . user . UserExtension < nl > < nl > import scala . concurrent . { ExecutionContext , Future } < nl > @ @ - 21 , 9 + 21 , 12 @ @ import scala . concurrent . { ExecutionContext , Future } < nl > class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > override implicit protected val ec : ExecutionContext = system . dispatcher < nl > < nl > - protected val db = DbExtension ( system ) . db < nl > - protected val userExt = UserExtension ( system ) < nl > - protected val groupExt = GroupExtension ( system ) < nl > + private val db = DbExtension ( system ) . db < nl > + private val userExt = UserExtension ( system ) < nl > + private val groupExt = GroupExtension ( system ) < nl > + private val globalNamesStorage = new GlobalNamesStorageKeyValueStorage < nl > + < nl > + private val EmptySearch = ResponsePeerSearch ( Vector . empty , Vector . empty , Vector . empty , Vector . empty , Vector . empty ) < nl > < nl > override def doHandlePeerSearch ( < nl > query : IndexedSeq [ ApiSearchCondition ] , < nl > @ @ - 38 , 9 + 41 , 16 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > } < nl > < nl > texts . toList match { < nl > - case text : : Nil ⇒ searchResult ( peerTypes . toVector , Some ( text ) , optimizations ) < nl > - case Nil ⇒ searchResult ( peerTypes . toVector , None , optimizations ) < nl > - case _ ⇒ FastFuture . successful ( Error ( RpcError ( 400 , " INVALID _ QUERY " , " Invalid query . " , canTryAgain = false , None ) ) ) < nl > + case text : : Nil if text . length < 3 ⇒ < nl > + FastFuture . successful ( Ok ( EmptySearch ) ) < nl > + case text : : Nil ⇒ < nl > + val tps = if ( peerTypes . isEmpty ) < nl > + Set ( ApiSearchPeerType . Public , ApiSearchPeerType . Contacts , ApiSearchPeerType . Groups ) < nl > + else < nl > + peerTypes < nl > + searchResult ( tps . toVector , Some ( text ) , optimizations ) < nl > + case Nil ⇒ searchResult ( peerTypes . toVector , None , optimizations ) < nl > + case _ ⇒ FastFuture . successful ( Error ( RpcError ( 400 , " INVALID _ QUERY " , " Invalid query . " , canTryAgain = false , None ) ) ) < nl > } < nl > } < nl > } < nl > @ @ - 73 , 6 + 83 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > case ApiPeerType . Group ⇒ ( gids : + pid , uids ) < nl > } < nl > } < nl > + / / TODO : make like here : im . actor . server . api . rpc . service . groups . GroupsServiceImpl . usersOrPeers < nl > ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) < nl > } yield { < nl > val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > @ @ - 86 , 6 + 97 , 8 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > } < nl > } < nl > < nl > + type PeerAndMatchString = ( ApiPeer , String ) < nl > + < nl > private def search ( pt : ApiSearchPeerType . Value , text : Option [ String ] ) ( implicit clientData : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeerSearchResult ] ] = { < nl > pt match { < nl > case ApiSearchPeerType . Contacts ⇒ < nl > @ @ - 94 , 39 + 107 , 85 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > } yield users map result < nl > case ApiSearchPeerType . Groups ⇒ < nl > for { < nl > - groups ← searchGroups ( text ) < nl > - } yield groups map ( result ( _ , isPublic = false ) ) < nl > + groups ← searchLocalGroups ( text ) < nl > + } yield groups map result < nl > + / / global search < nl > case ApiSearchPeerType . Public ⇒ < nl > + val usersFull = searchGlobalUsers ( text ) < nl > + val usersPrefix = searchGlobalUsersPrefix ( text ) < nl > + val groupsPrefix = searchGlobalGroupsPrefix ( text ) < nl > for { < nl > - groups ← searchPublic ( text ) < nl > - } yield groups map ( result ( _ , isPublic = true ) ) < nl > + uf ← usersFull < nl > + up ← usersPrefix < nl > + gp ← groupsPrefix < nl > + } yield ( uf map result ) + + ( up map result ) + + ( gp map result ) < nl > } < nl > } < nl > < nl > + / / from contacts < nl > private def result ( apiUser : ApiUser ) : ApiPeerSearchResult = < nl > ApiPeerSearchResult ( < nl > peer = ApiPeer ( ApiPeerType . Private , apiUser . id ) , < nl > - title = apiUser . localName . getOrElse ( apiUser . name ) , < nl > - description = None , < nl > - membersCount = None , < nl > - dateCreated = None , < nl > - creator = None , < nl > - isPublic = None , < nl > - isJoined = None < nl > + optMatchString = None < nl > ) < nl > < nl > - private def result ( apiGroup : ApiGroup , isPublic : Boolean ) : ApiPeerSearchResult = < nl > + / / from local groups < nl > + private def result ( apiGroup : ApiGroup ) : ApiPeerSearchResult = < nl > ApiPeerSearchResult ( < nl > peer = ApiPeer ( ApiPeerType . Group , apiGroup . id ) , < nl > - title = apiGroup . title , < nl > - description = apiGroup . about , < nl > - membersCount = Some ( apiGroup . members . size ) , < nl > - dateCreated = Some ( apiGroup . createDate ) , < nl > - creator = Some ( apiGroup . creatorUserId ) , < nl > - isPublic = Some ( isPublic ) , < nl > - isJoined = apiGroup . isMember < nl > + optMatchString = None < nl > + ) < nl > + < nl > + / / from global peer < nl > + private def result ( peer : ApiPeer ) : ApiPeerSearchResult = < nl > + ApiPeerSearchResult ( < nl > + peer = peer , < nl > + optMatchString = None < nl > + ) < nl > + < nl > + / / from global peer with nickname match < nl > + private def result ( peerAndMatch : PeerAndMatchString ) : ApiPeerSearchResult = < nl > + ApiPeerSearchResult ( < nl > + peer = peerAndMatch . _ 1 , < nl > + optMatchString = Some ( peerAndMatch . _ 2 ) < nl > ) < nl > < nl > + private def userPeersWithoutSelf ( userIds : Seq [ Int ] ) ( implicit client : AuthorizedClientData ) : Vector [ ApiPeer ] = < nl > + ( userIds collect { < nl > + case userId if userId ! = client . userId ⇒ ApiPeer ( ApiPeerType . Private , userId ) < nl > + } ) . toVector < nl > + < nl > + / / search users by full phone number , email or nickname < nl > + private def searchGlobalUsers ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeer ] ] = { < nl > + text map { query ⇒ < nl > + userExt . findUserIds ( query ) map userPeersWithoutSelf < nl > + } getOrElse FastFuture . successful ( Vector . empty ) < nl > + } < nl > + < nl > + / / search users by nickname prefix < nl > + private def searchGlobalUsersPrefix ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ PeerAndMatchString ] ] = { < nl > + text map { query ⇒ < nl > + globalNamesStorage . userIdsByPrefix ( query ) map { results ⇒ < nl > + results collect { < nl > + case ( userId , nickName ) if userId ! = client . userId ⇒ < nl > + ApiPeer ( ApiPeerType . Private , userId ) → nickName < nl > + } < nl > + } < nl > + } getOrElse FastFuture . successful ( Vector . empty ) < nl > + } < nl > + < nl > + / / find groups by global name prefix < nl > + private def searchGlobalGroupsPrefix ( text : Option [ String ] ) : Future [ IndexedSeq [ PeerAndMatchString ] ] = { < nl > + text map { query ⇒ < nl > + globalNamesStorage . groupIdsByPrefix ( query ) map { results ⇒ < nl > + results map { < nl > + case ( groupId , globalName ) ⇒ < nl > + ApiPeer ( ApiPeerType . Group , groupId ) → globalName < nl > + } < nl > + } < nl > + } getOrElse FastFuture . successful ( Vector . empty ) < nl > + } < nl > + < nl > private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiUser ] ] = { < nl > for { < nl > userIds ← db . run ( UserContactRepo . findContactIdsActive ( client . userId ) ) < nl > @ @ - 146 , 7 + 205 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > } < nl > < nl > / / TODO : rewrite it using async < nl > - private def searchGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { < nl > + private def searchLocalGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { < nl > for { < nl > ids ← DialogExtension ( system ) . fetchGroupedDialogs ( client . userId ) map ( _ . filter ( _ . typ . isGroups ) . flatMap ( _ . dialogs . map ( _ . getPeer . id ) ) ) < nl > groups ← FutureExt . ftraverse ( ids ) { id ⇒ < nl > @ @ - 155 , 13 + 214 , 6 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > } yield filterGroups ( groups . toVector , text ) < nl > } < nl > < nl > - private def searchPublic ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { < nl > - for { < nl > - groups ← db . run ( GroupRepo . findPublic ) / / FIXME : isPublic flag is deprecated and will not appear for new groups < nl > - groups ← FutureExt . ftraverse ( groups ) ( g ⇒ groupExt . getApiStruct ( g . id , client . userId ) ) < nl > - } yield filterGroups ( groups . toVector , text ) < nl > - } < nl > - < nl > private def filterGroups ( groups : IndexedSeq [ ApiGroup ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiGroup ] = { < nl > textOpt match { < nl > case Some ( text ) ⇒
NEAREST DIFF (one line): diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > new file mode 100644 < nl > index 0000000 . . de19382 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > @ @ - 0 , 0 + 1 , 145 @ @ < nl > + package im . actor . server . api . rpc . service < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . { ClientData , _ } < nl > + import im . actor . api . rpc . groups . ApiGroup < nl > + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . api . rpc . search . _ < nl > + import im . actor . api . rpc . users . ApiUser < nl > + import im . actor . concurrent . FutureExt < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . group . { GroupExtension , GroupUtils } < nl > + import im . actor . server . persist . contact . UserContactRepo < nl > + import im . actor . server . persist . { DialogRepo , GroupRepo } < nl > + import im . actor . server . user . UserExtension < nl > + < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + < nl > + final class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > + override implicit protected val ec : ExecutionContext = system . dispatcher < nl > + < nl > + private val db = DbExtension ( system ) . db < nl > + private val userExt = UserExtension ( system ) < nl > + private val groupExt = GroupExtension ( system ) < nl > + < nl > + override def jhandlePeerSearch ( query : IndexedSeq [ ApiSearchCondition ] , clientData : ClientData ) : Future [ HandlerResult [ ResponsePeerSearch ] ] = { < nl > + authorized ( clientData ) { implicit client ⇒ < nl > + val ( peerTypes , texts ) = query . foldLeft ( Set . empty [ ApiSearchPeerType . Value ] , Set . empty [ String ] ) { < nl > + case ( ( pts , txts ) , ApiSearchPieceText ( t ) ) ⇒ ( pts , txts + t ) < nl > + case ( ( pts , txts ) , ApiSearchPeerTypeCondition ( pt ) ) ⇒ ( pts + pt , txts ) < nl > + } < nl > + < nl > + texts . toList match { < nl > + case text : : Nil ⇒ searchResult ( peerTypes . toVector , Some ( text ) ) < nl > + case Nil ⇒ searchResult ( peerTypes . toVector , None ) < nl > + case _ ⇒ Future . successful ( Error ( RpcError ( 400 , " INVALID _ QUERY " , " Invalid query . " , canTryAgain = false , None ) ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + private def searchResult ( pts : IndexedSeq [ ApiSearchPeerType . Value ] , text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ HandlerResult [ ResponsePeerSearch ] ] = { < nl > + for { < nl > + results ← FutureExt . ftraverse ( pts ) ( search ( _ , text ) ) . map ( _ . reduce ( _ + + _ ) ) < nl > + ( groupIds , userIds ) = results . view . map ( _ . peer ) . foldLeft ( Vector . empty [ Int ] , Vector . empty [ Int ] ) { < nl > + case ( ( gids , uids ) , ApiPeer ( pt , pid ) ) ⇒ < nl > + pt match { < nl > + case ApiPeerType . Private ⇒ ( gids , uids : + pid ) < nl > + case ApiPeerType . Group ⇒ ( gids : + pid , uids ) < nl > + } < nl > + } < nl > + ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) < nl > + } yield Ok ( ResponsePeerSearch ( results , users . toVector , groups . toVector ) ) < nl > + } < nl > + < nl > + private def search ( pt : ApiSearchPeerType . Value , text : Option [ String ] ) ( implicit clientData : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeerSearchResult ] ] = { < nl > + pt match { < nl > + case ApiSearchPeerType . Contacts ⇒ < nl > + for { < nl > + users ← searchContacts ( text ) < nl > + } yield users map result < nl > + case ApiSearchPeerType . Groups ⇒ < nl > + for { < nl > + groups ← searchGroups ( text ) < nl > + } yield groups map ( result ( _ , isPublic = false ) ) < nl > + case ApiSearchPeerType . Public ⇒ < nl > + for { < nl > + groups ← searchGroups ( text ) < nl > + } yield groups map ( result ( _ , isPublic = true ) ) < nl > + } < nl > + } < nl > + < nl > + private def result ( apiUser : ApiUser ) : ApiPeerSearchResult = < nl > + ApiPeerSearchResult ( < nl > + peer = ApiPeer ( ApiPeerType . Private , apiUser . id ) , < nl > + title = apiUser . localName . getOrElse ( apiUser . name ) , < nl > + description = None , < nl > + membersCount = None , < nl > + dateCreated = None , < nl > + creator = None , < nl > + isPublic = None , < nl > + isJoined = None < nl > + ) < nl > + < nl > + private def result ( apiGroup : ApiGroup , isPublic : Boolean ) : ApiPeerSearchResult = < nl > + ApiPeerSearchResult ( < nl > + peer = ApiPeer ( ApiPeerType . Group , apiGroup . id ) , < nl > + title = apiGroup . title , < nl > + description = apiGroup . about , < nl > + membersCount = Some ( apiGroup . members . size ) , < nl > + dateCreated = Some ( apiGroup . createDate ) , < nl > + creator = Some ( apiGroup . creatorUserId ) , < nl > + isPublic = Some ( isPublic ) , < nl > + isJoined = Some ( apiGroup . isMember ) < nl > + ) < nl > + < nl > + private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiUser ] ] = { < nl > + for { < nl > + userIds ← db . run ( UserContactRepo . findContactIdsActive ( client . userId ) ) < nl > + users ← FutureExt . ftraverse ( userIds ) ( userExt . getApiStruct ( _ , client . userId , client . authId ) ) < nl > + } yield filterUsers ( users . toVector , text ) < nl > + } < nl > + < nl > + private def filterUsers ( users : IndexedSeq [ ApiUser ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiUser ] = < nl > + textOpt match { < nl > + case Some ( text ) ⇒ < nl > + val lotext = text . toLowerCase < nl > + users filter { user ⇒ < nl > + user . name . toLowerCase . contains ( lotext ) | | < nl > + user . localName . exists ( _ . toLowerCase . contains ( lotext ) ) < nl > + } < nl > + case None ⇒ users < nl > + } < nl > + < nl > + / / TODO : rewrite it using async < nl > + private def searchGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { < nl > + for { < nl > + ids ← db . run ( DialogRepo . findGroupIds ( client . userId ) ) < nl > + groupOpts ← FutureExt . ftraverse ( ids ) { id ⇒ < nl > + groupExt . isPublic ( id ) flatMap { isPublic ⇒ < nl > + if ( isPublic ) Future . successful ( None ) < nl > + else groupExt . getApiStruct ( id , client . userId ) . map ( Some ( _ ) ) < nl > + } < nl > + } < nl > + } yield filterGroups ( groupOpts . flatten . toVector , text ) < nl > + } < nl > + < nl > + private def searchPublic ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { < nl > + for { < nl > + groups ← db . run ( GroupRepo . findPublic ) < nl > + groups ← FutureExt . ftraverse ( groups ) ( g ⇒ groupExt . getApiStruct ( g . id , client . userId ) ) < nl > + } yield filterGroups ( groups . toVector , text ) < nl > + } < nl > + < nl > + private def filterGroups ( groups : IndexedSeq [ ApiGroup ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiGroup ] = { < nl > + textOpt match { < nl > + case Some ( text ) ⇒ < nl > + groups . view . filter { group ⇒ < nl > + val lotext = text . toLowerCase < nl > + group . title . toLowerCase . contains ( lotext ) | | < nl > + group . about . exists ( _ . toLowerCase . contains ( lotext ) ) | | < nl > + group . theme . exists ( _ . toLowerCase . contains ( lotext ) ) < nl > + } . force < nl > + case None ⇒ groups < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > index 81b7142 . . fb26898 100644 < nl > - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > @ @ - 12 , 6 + 12 , 7 @ @ import im . actor . server . activation . internal . { ActivationConfig , InternalCodeActiv < nl > import im . actor . server . api . frontend . Frontend < nl > import im . actor . server . api . http . { HttpApiConfig , HttpApiFrontend } < nl > import im . actor . server . api . rpc . RpcApiService < nl > + import im . actor . server . api . rpc . service . SearchServiceImpl < nl > import im . actor . server . api . rpc . service . auth . AuthServiceImpl < nl > import im . actor . server . api . rpc . service . configs . ConfigsServiceImpl < nl > import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl < nl > @ @ - 140 , 7 + 141 , 8 @ @ object Main extends App { < nl > new ProfileServiceImpl , < nl > new IntegrationsServiceImpl ( s " $ { webappConfig . scheme } : / / $ { webappConfig . host } " ) , < nl > new WebactionsServiceImpl , < nl > - new DeviceServiceImpl < nl > + new DeviceServiceImpl , < nl > + new SearchServiceImpl < nl > ) < nl > < nl > system . log . warning ( " Starting ActorBot " ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala < nl > index 2c75fdd . . 4351753 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import akka . actor . ActorSystem < nl > import akka . stream . ActorMaterializer < nl > import org . scalatest . concurrent . ScalaFutures < nl > import org . scalatest . time . { Seconds , Span } < nl > - import org . scalatest . { FlatSpecLike , Matchers } < nl > + import org . scalatest . { Inside , FlatSpecLike , Matchers } < nl > import slick . driver . PostgresDriver < nl > < nl > import scala . concurrent . ExecutionContext < nl > @ @ - 18 , 6 + 18 , 7 @ @ abstract class BaseAppSuite ( _ system : ActorSystem = { < nl > with FlatSpecLike < nl > with ScalaFutures < nl > with Matchers < nl > + with Inside < nl > with ServiceSpecMatchers < nl > with ServiceSpecHelpers < nl > with ActorSerializerPrepare { < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ContactsSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ContactsSpecHelpers . scala < nl > new file mode 100644 < nl > index 0000000 . . 709da3f < nl > - - - / dev / null < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ContactsSpecHelpers . scala < nl > @ @ - 0 , 0 + 1 , 22 @ @ < nl > + package im . actor . server < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . util . Timeout < nl > + import im . actor . api . rpc . ClientData < nl > + import im . actor . api . rpc . contacts . ContactsService < nl > + import im . actor . server . user . UserExtension < nl > + < nl > + import scala . concurrent . Await < nl > + < nl > + trait ContactsSpecHelpers { < nl > + val contactsService : ContactsService < nl > + val timeout : Timeout < nl > + val system : ActorSystem < nl > + < nl > + private val userExt = UserExtension ( system ) < nl > + < nl > + def addContact ( userId : Int ) ( implicit client : ClientData ) : Unit = { < nl > + val accessHash = Await . result ( userExt . getAccessHash ( userId , client . authId ) , timeout . duration ) < nl > + Await . result ( contactsService . handleAddContact ( userId , accessHash ) , timeout . duration ) < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > new file mode 100644 < nl > index 0000000 . . 3d25a02 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > @ @ - 0 , 0 + 1 , 27 @ @ < nl > + package im . actor . server < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . util . Timeout < nl > + import im . actor . api . rpc . ClientData < nl > + import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } < nl > + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . server . acl . ACLUtils < nl > + < nl > + import scala . concurrent . Await < nl > + import scala . util . Random < nl > + < nl > + trait MessagingSpecHelpers { < nl > + val timeout : Timeout < nl > + < nl > + def sendMessageToUser ( userId : Int , message : ApiMessage ) ( < nl > + implicit < nl > + clientData : ClientData , < nl > + msgService : MessagingService , < nl > + system : ActorSystem < nl > + ) : Unit = { < nl > + val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) < nl > + Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) < nl > + } < nl > + < nl > + def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala < nl > index 046453e . . df29648 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala < nl > @ @ - 20 , 7 + 20 , 7 @ @ import scala . concurrent . duration . _ < nl > import scalaz . { - \ / , \ / - } < nl > < nl > trait PersistenceHelpers { < nl > - protected implicit val timeout = Timeout ( 5 . seconds ) < nl > + implicit val timeout = Timeout ( 5 . seconds ) < nl > < nl > def getUserModel ( userId : Int ) ( implicit db : Database ) = Await . result ( db . run ( persist . UserRepo . find ( userId ) . head ) , timeout . duration ) < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SearchServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SearchServiceSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 7e974f1 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SearchServiceSpec . scala < nl > @ @ - 0 , 0 + 1 , 86 @ @ < nl > + package im . actor . server . api . rpc . service < nl > + < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . search . _ < nl > + import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl < nl > + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > + import im . actor . server . _ < nl > + < nl > + final class SearchServiceSpec < nl > + extends BaseAppSuite < nl > + with ServiceSpecHelpers < nl > + with MessagingSpecHelpers < nl > + with ContactsSpecHelpers < nl > + with GroupsServiceHelpers < nl > + with ImplicitAuthService < nl > + with ImplicitSessionRegionProxy { < nl > + behavior of " PeerSearch " < nl > + it should " search private peers " in privat < nl > + it should " search groups " in groups < nl > + < nl > + implicit val msgService = MessagingServiceImpl ( ) < nl > + implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > + override val contactsService = new ContactsServiceImpl < nl > + val searchService = new SearchServiceImpl < nl > + < nl > + def privat ( ) = { < nl > + val ( user1 , authId1 , _ ) = createUser ( ) < nl > + val ( user2 , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( authId1 , 1 , Some ( user1 . id ) ) < nl > + addContact ( user2 . id ) < nl > + < nl > + whenReady ( searchService . handlePeerSearch ( Vector ( < nl > + ApiSearchPeerTypeCondition ( ApiSearchPeerType . Contacts ) < nl > + ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponsePeerSearch ( results , users , groups ) ) ⇒ < nl > + groups shouldBe empty < nl > + users . map ( _ . id ) shouldBe Seq ( user2 . id ) < nl > + results . length shouldBe 1 < nl > + val result = results . head < nl > + < nl > + result . title shouldBe user2 . name < nl > + } < nl > + } < nl > + } < nl > + < nl > + def groups ( ) = { < nl > + val ( user1 , authId1 , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( authId1 , 1 , Some ( user1 . id ) ) < nl > + createGroup ( " Hell yeah " , Set . empty ) < nl > + < nl > + whenReady ( searchService . handlePeerSearch ( Vector ( < nl > + ApiSearchPeerTypeCondition ( ApiSearchPeerType . Groups ) < nl > + ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponsePeerSearch ( result , users , groups ) ) ⇒ < nl > + groups . length shouldBe 1 < nl > + val group = groups . head < nl > + group . title shouldBe " Hell yeah " < nl > + } < nl > + } < nl > + < nl > + whenReady ( searchService . handlePeerSearch ( Vector ( < nl > + ApiSearchPeerTypeCondition ( ApiSearchPeerType . Groups ) , < nl > + ApiSearchPieceText ( " zz " ) < nl > + ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponsePeerSearch ( result , users , groups ) ) ⇒ < nl > + groups shouldBe empty < nl > + } < nl > + } < nl > + < nl > + whenReady ( searchService . handlePeerSearch ( Vector ( < nl > + ApiSearchPeerTypeCondition ( ApiSearchPeerType . Groups ) , < nl > + ApiSearchPieceText ( " ell " ) < nl > + ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponsePeerSearch ( result , users , groups ) ) ⇒ < nl > + groups should not be empty < nl > + } < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala 
 index 50fb910 . . 0dbd166 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala 
 @ @ - 367 , 7 + 367 , 8 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { 
 if ( newState . groupType . isChannel ) 
 UpdateGroupMembersCountChanged ( groupId , membersCount = 0 ) 
 else 
 - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) 
 + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 + UpdateGroupDeleted ( groupId ) 
 ) 
 
 / / TODO : remove deprecated . GroupInviteTokenRepo don ' t have replacement yet . 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 index b6527fb . . cfde4c1 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 @ @ - 108 , 7 + 108 , 8 @ @ trait GroupQueryHandlers { 
 case Channel ⇒ ApiGroupType . CHANNEL 
 case General | Unrecognized ( _ ) ⇒ ApiGroupType . GROUP 
 } ) , 
 - canSendMessage = Some ( state . permissions . canSendMessage ( clientUserId ) ) 
 + canSendMessage = Some ( state . permissions . canSendMessage ( clientUserId ) ) , 
 + isDeleted = Some ( state . isDeleted ) 
 ) 
 ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala 
 index d6cae1b . . dc766a5 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala 
 @ @ - 34 , 6 + 34 , 41 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { 
 case GlobalNameOwner ( OwnerType . User , userId ) ⇒ userId 
 } ) 
 
 + / * * 
 + * Search groups ( id - > global name ) by global name prefix 
 + * Looks only in GlobalNamesStorage 
 + * / 
 + def groupIdsByPrefix ( namePrefix : String ) : Future [ IndexedSeq [ ( Int , String ) ] ] = { 
 + conn . run ( GlobalNamesStorage . getByPrefix ( namePrefix ) ) map { searchResults ⇒ 
 + searchResults flatMap { 
 + case ( fullName , bytes ) ⇒ 
 + Some ( GlobalNameOwner . parseFrom ( bytes ) ) filter ( _ . ownerType . isGroup ) map ( o ⇒ o . ownerId → fullName ) 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Search users ( id - > global name ) by global name prefix 
 + * Looks in both GlobalNamesStorage and UserRepo ( compatibility mode ) 
 + * / 
 + def userIdsByPrefix ( namePrefix : String ) : Future [ IndexedSeq [ ( Int , String ) ] ] = { 
 + val kvSearch = conn . run ( GlobalNamesStorage . getByPrefix ( namePrefix ) ) map { searchResults ⇒ 
 + searchResults flatMap { 
 + case ( fullName , bytes ) ⇒ 
 + Some ( GlobalNameOwner . parseFrom ( bytes ) ) filter ( _ . ownerType . isUser ) map ( o ⇒ o . ownerId → fullName ) 
 + } 
 + } 
 + val compatSearch = db . run ( UserRepo . findByNicknamePrefix ( namePrefix ) ) map { users ⇒ 
 + users flatMap { user ⇒ 
 + user . nickname map ( user . id → _ ) 
 + } 
 + } 
 + for { 
 + kv ← kvSearch 
 + compat ← compatSearch 
 + } yield kv + + compat 
 + } 
 + 
 def getGroupId ( name : String ) : Future [ Option [ Int ] ] = 
 getOwner ( name ) map ( _ . collect { 
 case GlobalNameOwner ( OwnerType . Group , groupId ) ⇒ groupId 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 index a8ca2f0 . . 56cd6bb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 @ @ - 11 , 6 + 11 , 7 @ @ import im . actor . server . auth . DeviceInfo 
 import im . actor . server . bots . BotCommand 
 import im . actor . server . db . DbExtension 
 import im . actor . server . file . Avatar 
 + import im . actor . server . names . GlobalNamesStorageKeyValueStorage 
 import im . actor . server . persist . UserRepo 
 import im . actor . server . pubsub . PubSubExtension 
 import im . actor . server . sequence . { SeqState , SeqUpdatesExtension } 
 @ @ - 144 , 6 + 145 , 7 @ @ private [ user ] sealed trait Queries { 
 implicit val system : ActorSystem 
 import system . dispatcher 
 val log : LoggingAdapter 
 + private lazy val globalNamesStorage = new GlobalNamesStorageKeyValueStorage 
 
 implicit val timeout : Timeout 
 
 @ @ - 192 , 7 + 194 , 11 @ @ private [ user ] sealed trait Queries { 
 def isAdmin ( userId : Int ) : Future [ Boolean ] = 
 ( viewRegion . ref ? IsAdmin ( userId ) ) . mapTo [ IsAdminResponse ] . map ( _ . isAdmin ) 
 
 - def findUserIds ( query : String ) : Future [ Seq [ Int ] ] = DbExtension ( system ) . db . run ( UserRepo . findIds ( query ) ) 
 + def findUserIds ( query : String ) : Future [ Seq [ Int ] ] = 
 + for { 
 + byPhoneAndEmail ← DbExtension ( system ) . db . run ( UserRepo . findIds ( query ) ) 
 + byNickname ← globalNamesStorage . getUserId ( query ) 
 + } yield byPhoneAndEmail + + byNickname 
 } 
 
 private [ user ] sealed trait AuthCommands { 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala 
 index efea1aa . . 35391e0 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala 
 @ @ - 40 , 11 + 40 , 13 @ @ object UserRepo { 
 val byIdC = Compiled ( byId _ ) 
 val nameByIdC = Compiled ( nameById _ ) 
 
 - private def byNickname ( nickname : Rep [ String ] ) = users filter ( _ . nickname . toLowerCase = = = nickname . toLowerCase ) 
 - private def idsByNickname ( nickname : Rep [ String ] ) = byNickname ( nickname ) . map ( _ . id ) 
 + private def byNickname ( nickname : Rep [ String ] ) = 
 + users filter ( _ . nickname . toLowerCase = = = nickname . toLowerCase ) 
 + private def byNicknamePrefix ( nickPrefix : Rep [ String ] ) = 
 + users filter ( _ . nickname . toLowerCase . like ( nickPrefix . toLowerCase ) ) 
 
 private val byNicknameC = Compiled ( byNickname _ ) 
 - private val idsByNicknameC = Compiled ( idsByNickname _ ) 
 + private val byNicknamePrefixC = Compiled ( byNicknamePrefix _ ) 
 
 def byPhone ( phone : Rep [ Long ] ) = ( for { 
 phones ← UserPhoneRepo . phones . filter ( _ . number = = = phone ) 
 @ @ - 107 , 24 + 109 , 30 @ @ object UserRepo { 
 users . filter ( _ . id inSet ids ) . map ( u ⇒ ( u . id , u . accessSalt ) ) . result 
 
 @ deprecated ( " user GlobalNamesStorageKeyValueStorage instead " , " 2016 - 07 - 17 " ) 
 - def findByNickname ( query : String ) = { 
 + def findByNickname ( query : String ) : DBIO [ Option [ User ] ] = { 
 val nickname = 
 if ( query . startsWith ( " @ " ) ) query . drop ( 1 ) else query 
 byNicknameC ( nickname ) . result . headOption 
 } 
 
 + @ deprecated ( " user GlobalNamesStorageKeyValueStorage instead " , " 2016 - 07 - 17 " ) 
 + def findByNicknamePrefix ( query : String ) : DBIO [ Seq [ User ] ] = { 
 + val nickname : String = 
 + if ( query . startsWith ( " @ " ) ) query . drop ( 1 ) else query 
 + byNicknamePrefixC ( nickname ) . result 
 + } 
 + 
 def findIdsByEmail ( email : String ) = 
 idsByEmailC ( email ) . result . headOption 
 
 def findIds ( query : String ) ( implicit ec : ExecutionContext ) = 
 for { 
 e ← idsByEmailC ( query ) . result 
 - n ← idsByNicknameC ( query ) . result 
 p ← PhoneNumberUtils . normalizeStr ( query ) 
 . headOption 
 . map ( idByPhoneC ( _ ) . result ) 
 . getOrElse ( DBIO . successful ( Nil ) ) 
 - } yield e + + n + + p 
 + } yield e + + p 
 
 @ deprecated ( " user GlobalNamesStorageKeyValueStorage instead " , " 2016 - 07 - 17 " ) 
 def setNickname ( userId : Int , nickname : Option [ String ] ) = 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 index 82c3f34 . . 1bff78b 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 @ @ - 12 , 8 + 12 , 8 @ @ import im . actor . concurrent . FutureExt 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . DialogExtension 
 import im . actor . server . group . { GroupExtension , GroupUtils } 
 + import im . actor . server . names . GlobalNamesStorageKeyValueStorage 
 import im . actor . server . persist . contact . UserContactRepo 
 - import im . actor . server . persist . GroupRepo 
 import im . actor . server . user . UserExtension 
 
 import scala . concurrent . { ExecutionContext , Future } 
 @ @ - 21 , 9 + 21 , 12 @ @ import scala . concurrent . { ExecutionContext , Future } 
 class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 override implicit protected val ec : ExecutionContext = system . dispatcher 
 
 - protected val db = DbExtension ( system ) . db 
 - protected val userExt = UserExtension ( system ) 
 - protected val groupExt = GroupExtension ( system ) 
 + private val db = DbExtension ( system ) . db 
 + private val userExt = UserExtension ( system ) 
 + private val groupExt = GroupExtension ( system ) 
 + private val globalNamesStorage = new GlobalNamesStorageKeyValueStorage 
 + 
 + private val EmptySearch = ResponsePeerSearch ( Vector . empty , Vector . empty , Vector . empty , Vector . empty , Vector . empty ) 
 
 override def doHandlePeerSearch ( 
 query : IndexedSeq [ ApiSearchCondition ] , 
 @ @ - 38 , 9 + 41 , 16 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 } 
 
 texts . toList match { 
 - case text : : Nil ⇒ searchResult ( peerTypes . toVector , Some ( text ) , optimizations ) 
 - case Nil ⇒ searchResult ( peerTypes . toVector , None , optimizations ) 
 - case _ ⇒ FastFuture . successful ( Error ( RpcError ( 400 , " INVALID _ QUERY " , " Invalid query . " , canTryAgain = false , None ) ) ) 
 + case text : : Nil if text . length < 3 ⇒ 
 + FastFuture . successful ( Ok ( EmptySearch ) ) 
 + case text : : Nil ⇒ 
 + val tps = if ( peerTypes . isEmpty ) 
 + Set ( ApiSearchPeerType . Public , ApiSearchPeerType . Contacts , ApiSearchPeerType . Groups ) 
 + else 
 + peerTypes 
 + searchResult ( tps . toVector , Some ( text ) , optimizations ) 
 + case Nil ⇒ searchResult ( peerTypes . toVector , None , optimizations ) 
 + case _ ⇒ FastFuture . successful ( Error ( RpcError ( 400 , " INVALID _ QUERY " , " Invalid query . " , canTryAgain = false , None ) ) ) 
 } 
 } 
 } 
 @ @ - 73 , 6 + 83 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 case ApiPeerType . Group ⇒ ( gids : + pid , uids ) 
 } 
 } 
 + / / TODO : make like here : im . actor . server . api . rpc . service . groups . GroupsServiceImpl . usersOrPeers 
 ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) 
 } yield { 
 val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 @ @ - 86 , 6 + 97 , 8 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 } 
 } 
 
 + type PeerAndMatchString = ( ApiPeer , String ) 
 + 
 private def search ( pt : ApiSearchPeerType . Value , text : Option [ String ] ) ( implicit clientData : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeerSearchResult ] ] = { 
 pt match { 
 case ApiSearchPeerType . Contacts ⇒ 
 @ @ - 94 , 39 + 107 , 85 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 } yield users map result 
 case ApiSearchPeerType . Groups ⇒ 
 for { 
 - groups ← searchGroups ( text ) 
 - } yield groups map ( result ( _ , isPublic = false ) ) 
 + groups ← searchLocalGroups ( text ) 
 + } yield groups map result 
 + / / global search 
 case ApiSearchPeerType . Public ⇒ 
 + val usersFull = searchGlobalUsers ( text ) 
 + val usersPrefix = searchGlobalUsersPrefix ( text ) 
 + val groupsPrefix = searchGlobalGroupsPrefix ( text ) 
 for { 
 - groups ← searchPublic ( text ) 
 - } yield groups map ( result ( _ , isPublic = true ) ) 
 + uf ← usersFull 
 + up ← usersPrefix 
 + gp ← groupsPrefix 
 + } yield ( uf map result ) + + ( up map result ) + + ( gp map result ) 
 } 
 } 
 
 + / / from contacts 
 private def result ( apiUser : ApiUser ) : ApiPeerSearchResult = 
 ApiPeerSearchResult ( 
 peer = ApiPeer ( ApiPeerType . Private , apiUser . id ) , 
 - title = apiUser . localName . getOrElse ( apiUser . name ) , 
 - description = None , 
 - membersCount = None , 
 - dateCreated = None , 
 - creator = None , 
 - isPublic = None , 
 - isJoined = None 
 + optMatchString = None 
 ) 
 
 - private def result ( apiGroup : ApiGroup , isPublic : Boolean ) : ApiPeerSearchResult = 
 + / / from local groups 
 + private def result ( apiGroup : ApiGroup ) : ApiPeerSearchResult = 
 ApiPeerSearchResult ( 
 peer = ApiPeer ( ApiPeerType . Group , apiGroup . id ) , 
 - title = apiGroup . title , 
 - description = apiGroup . about , 
 - membersCount = Some ( apiGroup . members . size ) , 
 - dateCreated = Some ( apiGroup . createDate ) , 
 - creator = Some ( apiGroup . creatorUserId ) , 
 - isPublic = Some ( isPublic ) , 
 - isJoined = apiGroup . isMember 
 + optMatchString = None 
 + ) 
 + 
 + / / from global peer 
 + private def result ( peer : ApiPeer ) : ApiPeerSearchResult = 
 + ApiPeerSearchResult ( 
 + peer = peer , 
 + optMatchString = None 
 + ) 
 + 
 + / / from global peer with nickname match 
 + private def result ( peerAndMatch : PeerAndMatchString ) : ApiPeerSearchResult = 
 + ApiPeerSearchResult ( 
 + peer = peerAndMatch . _ 1 , 
 + optMatchString = Some ( peerAndMatch . _ 2 ) 
 ) 
 
 + private def userPeersWithoutSelf ( userIds : Seq [ Int ] ) ( implicit client : AuthorizedClientData ) : Vector [ ApiPeer ] = 
 + ( userIds collect { 
 + case userId if userId ! = client . userId ⇒ ApiPeer ( ApiPeerType . Private , userId ) 
 + } ) . toVector 
 + 
 + / / search users by full phone number , email or nickname 
 + private def searchGlobalUsers ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeer ] ] = { 
 + text map { query ⇒ 
 + userExt . findUserIds ( query ) map userPeersWithoutSelf 
 + } getOrElse FastFuture . successful ( Vector . empty ) 
 + } 
 + 
 + / / search users by nickname prefix 
 + private def searchGlobalUsersPrefix ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ PeerAndMatchString ] ] = { 
 + text map { query ⇒ 
 + globalNamesStorage . userIdsByPrefix ( query ) map { results ⇒ 
 + results collect { 
 + case ( userId , nickName ) if userId ! = client . userId ⇒ 
 + ApiPeer ( ApiPeerType . Private , userId ) → nickName 
 + } 
 + } 
 + } getOrElse FastFuture . successful ( Vector . empty ) 
 + } 
 + 
 + / / find groups by global name prefix 
 + private def searchGlobalGroupsPrefix ( text : Option [ String ] ) : Future [ IndexedSeq [ PeerAndMatchString ] ] = { 
 + text map { query ⇒ 
 + globalNamesStorage . groupIdsByPrefix ( query ) map { results ⇒ 
 + results map { 
 + case ( groupId , globalName ) ⇒ 
 + ApiPeer ( ApiPeerType . Group , groupId ) → globalName 
 + } 
 + } 
 + } getOrElse FastFuture . successful ( Vector . empty ) 
 + } 
 + 
 private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiUser ] ] = { 
 for { 
 userIds ← db . run ( UserContactRepo . findContactIdsActive ( client . userId ) ) 
 @ @ - 146 , 7 + 205 , 7 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 } 
 
 / / TODO : rewrite it using async 
 - private def searchGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { 
 + private def searchLocalGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { 
 for { 
 ids ← DialogExtension ( system ) . fetchGroupedDialogs ( client . userId ) map ( _ . filter ( _ . typ . isGroups ) . flatMap ( _ . dialogs . map ( _ . getPeer . id ) ) ) 
 groups ← FutureExt . ftraverse ( ids ) { id ⇒ 
 @ @ - 155 , 13 + 214 , 6 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 } yield filterGroups ( groups . toVector , text ) 
 } 
 
 - private def searchPublic ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { 
 - for { 
 - groups ← db . run ( GroupRepo . findPublic ) / / FIXME : isPublic flag is deprecated and will not appear for new groups 
 - groups ← FutureExt . ftraverse ( groups ) ( g ⇒ groupExt . getApiStruct ( g . id , client . userId ) ) 
 - } yield filterGroups ( groups . toVector , text ) 
 - } 
 - 
 private def filterGroups ( groups : IndexedSeq [ ApiGroup ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiGroup ] = { 
 textOpt match { 
 case Some ( text ) ⇒

NEAREST DIFF:
diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 new file mode 100644 
 index 0000000 . . de19382 
 - - - / dev / null 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 @ @ - 0 , 0 + 1 , 145 @ @ 
 + package im . actor . server . api . rpc . service 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . { ClientData , _ } 
 + import im . actor . api . rpc . groups . ApiGroup 
 + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . api . rpc . search . _ 
 + import im . actor . api . rpc . users . ApiUser 
 + import im . actor . concurrent . FutureExt 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . group . { GroupExtension , GroupUtils } 
 + import im . actor . server . persist . contact . UserContactRepo 
 + import im . actor . server . persist . { DialogRepo , GroupRepo } 
 + import im . actor . server . user . UserExtension 
 + 
 + import scala . concurrent . { ExecutionContext , Future } 
 + 
 + final class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 + override implicit protected val ec : ExecutionContext = system . dispatcher 
 + 
 + private val db = DbExtension ( system ) . db 
 + private val userExt = UserExtension ( system ) 
 + private val groupExt = GroupExtension ( system ) 
 + 
 + override def jhandlePeerSearch ( query : IndexedSeq [ ApiSearchCondition ] , clientData : ClientData ) : Future [ HandlerResult [ ResponsePeerSearch ] ] = { 
 + authorized ( clientData ) { implicit client ⇒ 
 + val ( peerTypes , texts ) = query . foldLeft ( Set . empty [ ApiSearchPeerType . Value ] , Set . empty [ String ] ) { 
 + case ( ( pts , txts ) , ApiSearchPieceText ( t ) ) ⇒ ( pts , txts + t ) 
 + case ( ( pts , txts ) , ApiSearchPeerTypeCondition ( pt ) ) ⇒ ( pts + pt , txts ) 
 + } 
 + 
 + texts . toList match { 
 + case text : : Nil ⇒ searchResult ( peerTypes . toVector , Some ( text ) ) 
 + case Nil ⇒ searchResult ( peerTypes . toVector , None ) 
 + case _ ⇒ Future . successful ( Error ( RpcError ( 400 , " INVALID _ QUERY " , " Invalid query . " , canTryAgain = false , None ) ) ) 
 + } 
 + } 
 + } 
 + 
 + private def searchResult ( pts : IndexedSeq [ ApiSearchPeerType . Value ] , text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ HandlerResult [ ResponsePeerSearch ] ] = { 
 + for { 
 + results ← FutureExt . ftraverse ( pts ) ( search ( _ , text ) ) . map ( _ . reduce ( _ + + _ ) ) 
 + ( groupIds , userIds ) = results . view . map ( _ . peer ) . foldLeft ( Vector . empty [ Int ] , Vector . empty [ Int ] ) { 
 + case ( ( gids , uids ) , ApiPeer ( pt , pid ) ) ⇒ 
 + pt match { 
 + case ApiPeerType . Private ⇒ ( gids , uids : + pid ) 
 + case ApiPeerType . Group ⇒ ( gids : + pid , uids ) 
 + } 
 + } 
 + ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) 
 + } yield Ok ( ResponsePeerSearch ( results , users . toVector , groups . toVector ) ) 
 + } 
 + 
 + private def search ( pt : ApiSearchPeerType . Value , text : Option [ String ] ) ( implicit clientData : AuthorizedClientData ) : Future [ IndexedSeq [ ApiPeerSearchResult ] ] = { 
 + pt match { 
 + case ApiSearchPeerType . Contacts ⇒ 
 + for { 
 + users ← searchContacts ( text ) 
 + } yield users map result 
 + case ApiSearchPeerType . Groups ⇒ 
 + for { 
 + groups ← searchGroups ( text ) 
 + } yield groups map ( result ( _ , isPublic = false ) ) 
 + case ApiSearchPeerType . Public ⇒ 
 + for { 
 + groups ← searchGroups ( text ) 
 + } yield groups map ( result ( _ , isPublic = true ) ) 
 + } 
 + } 
 + 
 + private def result ( apiUser : ApiUser ) : ApiPeerSearchResult = 
 + ApiPeerSearchResult ( 
 + peer = ApiPeer ( ApiPeerType . Private , apiUser . id ) , 
 + title = apiUser . localName . getOrElse ( apiUser . name ) , 
 + description = None , 
 + membersCount = None , 
 + dateCreated = None , 
 + creator = None , 
 + isPublic = None , 
 + isJoined = None 
 + ) 
 + 
 + private def result ( apiGroup : ApiGroup , isPublic : Boolean ) : ApiPeerSearchResult = 
 + ApiPeerSearchResult ( 
 + peer = ApiPeer ( ApiPeerType . Group , apiGroup . id ) , 
 + title = apiGroup . title , 
 + description = apiGroup . about , 
 + membersCount = Some ( apiGroup . members . size ) , 
 + dateCreated = Some ( apiGroup . createDate ) , 
 + creator = Some ( apiGroup . creatorUserId ) , 
 + isPublic = Some ( isPublic ) , 
 + isJoined = Some ( apiGroup . isMember ) 
 + ) 
 + 
 + private def searchContacts ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiUser ] ] = { 
 + for { 
 + userIds ← db . run ( UserContactRepo . findContactIdsActive ( client . userId ) ) 
 + users ← FutureExt . ftraverse ( userIds ) ( userExt . getApiStruct ( _ , client . userId , client . authId ) ) 
 + } yield filterUsers ( users . toVector , text ) 
 + } 
 + 
 + private def filterUsers ( users : IndexedSeq [ ApiUser ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiUser ] = 
 + textOpt match { 
 + case Some ( text ) ⇒ 
 + val lotext = text . toLowerCase 
 + users filter { user ⇒ 
 + user . name . toLowerCase . contains ( lotext ) | | 
 + user . localName . exists ( _ . toLowerCase . contains ( lotext ) ) 
 + } 
 + case None ⇒ users 
 + } 
 + 
 + / / TODO : rewrite it using async 
 + private def searchGroups ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { 
 + for { 
 + ids ← db . run ( DialogRepo . findGroupIds ( client . userId ) ) 
 + groupOpts ← FutureExt . ftraverse ( ids ) { id ⇒ 
 + groupExt . isPublic ( id ) flatMap { isPublic ⇒ 
 + if ( isPublic ) Future . successful ( None ) 
 + else groupExt . getApiStruct ( id , client . userId ) . map ( Some ( _ ) ) 
 + } 
 + } 
 + } yield filterGroups ( groupOpts . flatten . toVector , text ) 
 + } 
 + 
 + private def searchPublic ( text : Option [ String ] ) ( implicit client : AuthorizedClientData ) : Future [ IndexedSeq [ ApiGroup ] ] = { 
 + for { 
 + groups ← db . run ( GroupRepo . findPublic ) 
 + groups ← FutureExt . ftraverse ( groups ) ( g ⇒ groupExt . getApiStruct ( g . id , client . userId ) ) 
 + } yield filterGroups ( groups . toVector , text ) 
 + } 
 + 
 + private def filterGroups ( groups : IndexedSeq [ ApiGroup ] , textOpt : Option [ String ] ) : IndexedSeq [ ApiGroup ] = { 
 + textOpt match { 
 + case Some ( text ) ⇒ 
 + groups . view . filter { group ⇒ 
 + val lotext = text . toLowerCase 
 + group . title . toLowerCase . contains ( lotext ) | | 
 + group . about . exists ( _ . toLowerCase . contains ( lotext ) ) | | 
 + group . theme . exists ( _ . toLowerCase . contains ( lotext ) ) 
 + } . force 
 + case None ⇒ groups 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 index 81b7142 . . fb26898 100644 
 - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 @ @ - 12 , 6 + 12 , 7 @ @ import im . actor . server . activation . internal . { ActivationConfig , InternalCodeActiv 
 import im . actor . server . api . frontend . Frontend 
 import im . actor . server . api . http . { HttpApiConfig , HttpApiFrontend } 
 import im . actor . server . api . rpc . RpcApiService 
 + import im . actor . server . api . rpc . service . SearchServiceImpl 
 import im . actor . server . api . rpc . service . auth . AuthServiceImpl 
 import im . actor . server . api . rpc . service . configs . ConfigsServiceImpl 
 import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl 
 @ @ - 140 , 7 + 141 , 8 @ @ object Main extends App { 
 new ProfileServiceImpl , 
 new IntegrationsServiceImpl ( s " $ { webappConfig . scheme } : / / $ { webappConfig . host } " ) , 
 new WebactionsServiceImpl , 
 - new DeviceServiceImpl 
 + new DeviceServiceImpl , 
 + new SearchServiceImpl 
 ) 
 
 system . log . warning ( " Starting ActorBot " ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala 
 index 2c75fdd . . 4351753 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / BaseAppSuite . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import akka . actor . ActorSystem 
 import akka . stream . ActorMaterializer 
 import org . scalatest . concurrent . ScalaFutures 
 import org . scalatest . time . { Seconds , Span } 
 - import org . scalatest . { FlatSpecLike , Matchers } 
 + import org . scalatest . { Inside , FlatSpecLike , Matchers } 
 import slick . driver . PostgresDriver 
 
 import scala . concurrent . ExecutionContext 
 @ @ - 18 , 6 + 18 , 7 @ @ abstract class BaseAppSuite ( _ system : ActorSystem = { 
 with FlatSpecLike 
 with ScalaFutures 
 with Matchers 
 + with Inside 
 with ServiceSpecMatchers 
 with ServiceSpecHelpers 
 with ActorSerializerPrepare { 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ContactsSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ContactsSpecHelpers . scala 
 new file mode 100644 
 index 0000000 . . 709da3f 
 - - - / dev / null 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ContactsSpecHelpers . scala 
 @ @ - 0 , 0 + 1 , 22 @ @ 
 + package im . actor . server 
 + 
 + import akka . actor . ActorSystem 
 + import akka . util . Timeout 
 + import im . actor . api . rpc . ClientData 
 + import im . actor . api . rpc . contacts . ContactsService 
 + import im . actor . server . user . UserExtension 
 + 
 + import scala . concurrent . Await 
 + 
 + trait ContactsSpecHelpers { 
 + val contactsService : ContactsService 
 + val timeout : Timeout 
 + val system : ActorSystem 
 + 
 + private val userExt = UserExtension ( system ) 
 + 
 + def addContact ( userId : Int ) ( implicit client : ClientData ) : Unit = { 
 + val accessHash = Await . result ( userExt . getAccessHash ( userId , client . authId ) , timeout . duration ) 
 + Await . result ( contactsService . handleAddContact ( userId , accessHash ) , timeout . duration ) 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 new file mode 100644 
 index 0000000 . . 3d25a02 
 - - - / dev / null 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 @ @ - 0 , 0 + 1 , 27 @ @ 
 + package im . actor . server 
 + 
 + import akka . actor . ActorSystem 
 + import akka . util . Timeout 
 + import im . actor . api . rpc . ClientData 
 + import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } 
 + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . server . acl . ACLUtils 
 + 
 + import scala . concurrent . Await 
 + import scala . util . Random 
 + 
 + trait MessagingSpecHelpers { 
 + val timeout : Timeout 
 + 
 + def sendMessageToUser ( userId : Int , message : ApiMessage ) ( 
 + implicit 
 + clientData : ClientData , 
 + msgService : MessagingService , 
 + system : ActorSystem 
 + ) : Unit = { 
 + val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) 
 + Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) 
 + } 
 + 
 + def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala 
 index 046453e . . df29648 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala 
 @ @ - 20 , 7 + 20 , 7 @ @ import scala . concurrent . duration . _ 
 import scalaz . { - \ / , \ / - } 
 
 trait PersistenceHelpers { 
 - protected implicit val timeout = Timeout ( 5 . seconds ) 
 + implicit val timeout = Timeout ( 5 . seconds ) 
 
 def getUserModel ( userId : Int ) ( implicit db : Database ) = Await . result ( db . run ( persist . UserRepo . find ( userId ) . head ) , timeout . duration ) 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SearchServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SearchServiceSpec . scala 
 new file mode 100644 
 index 0000000 . . 7e974f1 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SearchServiceSpec . scala 
 @ @ - 0 , 0 + 1 , 86 @ @ 
 + package im . actor . server . api . rpc . service 
 + 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . search . _ 
 + import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl 
 + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 + import im . actor . server . _ 
 + 
 + final class SearchServiceSpec 
 + extends BaseAppSuite 
 + with ServiceSpecHelpers 
 + with MessagingSpecHelpers 
 + with ContactsSpecHelpers 
 + with GroupsServiceHelpers 
 + with ImplicitAuthService 
 + with ImplicitSessionRegionProxy { 
 + behavior of " PeerSearch " 
 + it should " search private peers " in privat 
 + it should " search groups " in groups 
 + 
 + implicit val msgService = MessagingServiceImpl ( ) 
 + implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 + override val contactsService = new ContactsServiceImpl 
 + val searchService = new SearchServiceImpl 
 + 
 + def privat ( ) = { 
 + val ( user1 , authId1 , _ ) = createUser ( ) 
 + val ( user2 , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( authId1 , 1 , Some ( user1 . id ) ) 
 + addContact ( user2 . id ) 
 + 
 + whenReady ( searchService . handlePeerSearch ( Vector ( 
 + ApiSearchPeerTypeCondition ( ApiSearchPeerType . Contacts ) 
 + ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponsePeerSearch ( results , users , groups ) ) ⇒ 
 + groups shouldBe empty 
 + users . map ( _ . id ) shouldBe Seq ( user2 . id ) 
 + results . length shouldBe 1 
 + val result = results . head 
 + 
 + result . title shouldBe user2 . name 
 + } 
 + } 
 + } 
 + 
 + def groups ( ) = { 
 + val ( user1 , authId1 , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( authId1 , 1 , Some ( user1 . id ) ) 
 + createGroup ( " Hell yeah " , Set . empty ) 
 + 
 + whenReady ( searchService . handlePeerSearch ( Vector ( 
 + ApiSearchPeerTypeCondition ( ApiSearchPeerType . Groups ) 
 + ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponsePeerSearch ( result , users , groups ) ) ⇒ 
 + groups . length shouldBe 1 
 + val group = groups . head 
 + group . title shouldBe " Hell yeah " 
 + } 
 + } 
 + 
 + whenReady ( searchService . handlePeerSearch ( Vector ( 
 + ApiSearchPeerTypeCondition ( ApiSearchPeerType . Groups ) , 
 + ApiSearchPieceText ( " zz " ) 
 + ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponsePeerSearch ( result , users , groups ) ) ⇒ 
 + groups shouldBe empty 
 + } 
 + } 
 + 
 + whenReady ( searchService . handlePeerSearch ( Vector ( 
 + ApiSearchPeerTypeCondition ( ApiSearchPeerType . Groups ) , 
 + ApiSearchPieceText ( " ell " ) 
 + ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponsePeerSearch ( result , users , groups ) ) ⇒ 
 + groups should not be empty 
 + } 
 + } 
 + } 
 + } 
 \ No newline at end of file
