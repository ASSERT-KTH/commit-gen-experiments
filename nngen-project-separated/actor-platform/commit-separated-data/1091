BLEU SCORE: 0.24808415001701817

TEST MSG: feat ( core ) : Loading all required keys for decryption
GENERATED MSG: wip ( core ) : Working on decryption of ratchet messages

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 37809ce . . 7796c91 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 74 , 10 + 74 , 10 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > Log . w ( TAG , " Groups ready # " + keyGroups . size ( ) ) ; < nl > < nl > for ( final ApiEncryptionKeyGroup g : keyGroups ) { < nl > - sessions . put ( g . getKeyGroupId ( ) , system ( ) . actorOf ( Props . create ( EncryptionSessionActor . class , new ActorCreator < EncryptionSessionActor > ( ) { < nl > + sessions . put ( g . getKeyGroupId ( ) , system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { < nl > @ Override < nl > - public EncryptionSessionActor create ( ) { < nl > - return new EncryptionSessionActor ( context ( ) , uid , g ) ; < nl > + public EncryptedSessionActor create ( ) { < nl > + return new EncryptedSessionActor ( context ( ) , uid , g ) ; < nl > } < nl > } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; < nl > } < nl > @ @ - 108 , 10 + 108 , 10 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > < nl > final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > for ( final Integer keyGroup : sessions . keySet ( ) ) { < nl > - ask ( sessions . get ( keyGroup ) , new EncryptionSessionActor . EncryptPackage ( encKey ) , new AskCallback ( ) { < nl > + ask ( sessions . get ( keyGroup ) , new EncryptedSessionActor . EncryptPackage ( encKey ) , new AskCallback ( ) { < nl > @ Override < nl > public void onResult ( Object obj ) { < nl > - EncryptionSessionActor . EncryptedPackageRes res = ( EncryptionSessionActor . EncryptedPackageRes ) obj ; < nl > + EncryptedSessionActor . EncryptedPackageRes res = ( EncryptedSessionActor . EncryptedPackageRes ) obj ; < nl > encryptedKeys . add ( new EncryptedBoxKey ( uid , keyGroup , res . getData ( ) ) ) ; < nl > if ( encryptedKeys . size ( ) = = sessions . size ( ) ) { < nl > doEncrypt ( encKey , data , encryptedKeys , future ) ; < nl > @ @ - 168 , 7 + 168 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > } < nl > < nl > - ask ( sessions . get ( senderKeyGroup ) , new EncryptionSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { < nl > + ask ( sessions . get ( senderKeyGroup ) , new EncryptedSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { < nl > @ Override < nl > public void onResult ( Object obj ) { < nl > Log . d ( TAG , " Decryption with key group : onResult " ) ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > new file mode 100644 < nl > index 0000000 . . e68d85d < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 0 , 0 + 1 , 365 @ @ < nl > + package im . actor . core . modules . encryption ; < nl > + < nl > + import java . util . ArrayList ; < nl > + < nl > + import im . actor . core . api . ApiEncryptionKey ; < nl > + import im . actor . core . api . ApiEncryptionKeyGroup ; < nl > + import im . actor . core . api . ApiUserOutPeer ; < nl > + import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; < nl > + import im . actor . core . api . rpc . RequestLoadPublicKey ; < nl > + import im . actor . core . api . rpc . ResponsePublicKeys ; < nl > + import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . encryption . entity . EncryptionKey ; < nl > + import im . actor . core . network . RpcCallback ; < nl > + import im . actor . core . network . RpcException ; < nl > + import im . actor . core . util . Hex ; < nl > + import im . actor . core . util . ModuleActor ; < nl > + import im . actor . core . util . RandomUtils ; < nl > + import im . actor . runtime . Crypto ; < nl > + import im . actor . runtime . Log ; < nl > + import im . actor . runtime . actors . Future ; < nl > + import im . actor . runtime . actors . ask . AskCallback ; < nl > + import im . actor . runtime . actors . ask . AskRequest ; < nl > + import im . actor . runtime . crypto . Curve25519 ; < nl > + import im . actor . runtime . crypto . IntegrityException ; < nl > + import im . actor . runtime . crypto . box . ActorBox ; < nl > + import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > + import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; < nl > + import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; < nl > + < nl > + public class EncryptedSessionActor extends ModuleActor { < nl > + < nl > + private final String TAG ; < nl > + < nl > + private final int uid ; < nl > + private final ApiEncryptionKeyGroup encryptionKeyGroup ; < nl > + < nl > + private EncryptionKey ownIdentityKey ; < nl > + private EncryptionKey theirIdentityKey ; < nl > + private EncryptionKey ownEphermalKey0 ; < nl > + private EncryptionKey theirEphermalKey0 ; < nl > + < nl > + private EncryptionKey prevOwnKey ; < nl > + private EncryptionKey currentOwnKey ; < nl > + private EncryptionKey currentTheirKey ; < nl > + < nl > + private byte [ ] rootChainKey ; < nl > + < nl > + private int outIndex = 0 ; < nl > + private int inIndex = 0 ; < nl > + < nl > + private boolean isReady = false ; < nl > + < nl > + public EncryptedSessionActor ( ModuleContext context , int uid , ApiEncryptionKeyGroup encryptionKeyGroup ) { < nl > + super ( context ) ; < nl > + this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; < nl > + this . uid = uid ; < nl > + this . encryptionKeyGroup = encryptionKeyGroup ; < nl > + this . theirIdentityKey = new EncryptionKey ( encryptionKeyGroup . getIdentityKey ( ) . getKeyId ( ) , encryptionKeyGroup . getIdentityKey ( ) . getKeyAlg ( ) , encryptionKeyGroup . getIdentityKey ( ) . getKeyMaterial ( ) , null ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void preStart ( ) { < nl > + if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { < nl > + Log . d ( TAG , " Loading own keys for conversation " ) ; < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " Own keys loaded " ) ; < nl > + KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; < nl > + ownIdentityKey = res . getIdentityKey ( ) ; < nl > + ownEphermalKey0 = res . getEphemeralKey ( ) ; < nl > + currentOwnKey = new EncryptionKey ( RandomUtils . nextRid ( ) , Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; < nl > + onOwnReady ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + / / Nothing to do < nl > + Log . w ( TAG , " Own keys error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + < nl > + } < nl > + } ) ; < nl > + } else { < nl > + onOwnReady ( ) ; < nl > + } < nl > + } < nl > + < nl > + private void onOwnReady ( ) { < nl > + Log . w ( TAG , " Own keys ready " ) ; < nl > + < nl > + if ( theirEphermalKey0 = = null ) { < nl > + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + @ Override < nl > + public void onResult ( ResponsePublicKeys response ) { < nl > + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > + Log . w ( TAG , " No ephemeral keys found " ) ; < nl > + return ; < nl > + } < nl > + < nl > + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > + theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; < nl > + onTheirReady0 ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( RpcException e ) { < nl > + / / Nothing to do < nl > + Log . w ( TAG , " Their ephemeral error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + } < nl > + } ) ; < nl > + } else { < nl > + onTheirReady0 ( ) ; < nl > + } < nl > + } < nl > + < nl > + private void onTheirReady0 ( ) { < nl > + Log . w ( TAG , " Their identity ephemeral keys ready " ) ; < nl > + < nl > + if ( currentTheirKey = = null ) { < nl > + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + @ Override < nl > + public void onResult ( ResponsePublicKeys response ) { < nl > + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > + Log . w ( TAG , " No ephemeral keys found " ) ; < nl > + return ; < nl > + } < nl > + < nl > + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > + currentTheirKey = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; < nl > + allSet ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( RpcException e ) { < nl > + / / Nothing to do < nl > + Log . w ( TAG , " Their ephemeral error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + } < nl > + } ) ; < nl > + } else { < nl > + onTheirReady0 ( ) ; < nl > + } < nl > + } < nl > + < nl > + private void allSet ( ) { < nl > + Log . d ( TAG , " All keys are ready " ) ; < nl > + isReady = true ; < nl > + < nl > + byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( < nl > + new RatchetPrivateKey ( ownIdentityKey . getPrivateKey ( ) ) , < nl > + new RatchetPrivateKey ( ownEphermalKey0 . getPrivateKey ( ) ) , < nl > + new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > + new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; < nl > + rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > + new RatchetPrivateKey ( ownEphermalKey0 . getPrivateKey ( ) ) , < nl > + new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , < nl > + master _ secret ) ; < nl > + < nl > + unstashAll ( ) ; < nl > + } < nl > + < nl > + private void onEncrypt ( byte [ ] data , Future future ) { < nl > + < nl > + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; < nl > + < nl > + byte [ ] header = ByteStrings . merge ( < nl > + ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , < nl > + ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > + ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > + currentOwnKey . getPublicKey ( ) , < nl > + currentTheirKey . getPublicKey ( ) , < nl > + ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / < nl > + < nl > + byte [ ] encrypted ; < nl > + try { < nl > + encrypted = ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ; < nl > + } catch ( IntegrityException e ) { < nl > + e . printStackTrace ( ) ; < nl > + future . onError ( e ) ; < nl > + return ; < nl > + } < nl > + < nl > + byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; < nl > + < nl > + < nl > + int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; < nl > + long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; < nl > + long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; < nl > + byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; < nl > + byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; < nl > + int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; < nl > + < nl > + Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; < nl > + Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; < nl > + < nl > + < nl > + Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; < nl > + Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; < nl > + < nl > + future . onResult ( new EncryptedPackageRes ( pkg ) ) ; < nl > + } < nl > + < nl > + private void onDecrypt ( final byte [ ] data , final Future future ) { < nl > + final int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > + final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > + final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > + final byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > + final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > + final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > + < nl > + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > + Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; < nl > + Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; < nl > + < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( ownEphermalKey ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + < nl > + final KeyManagerActor . FetchEphemeralPrivateKeyRes ownEphermalKey < nl > + = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; < nl > + < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKeyById ( ownEphermalKey0Id ) , < nl > + new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + final KeyManagerActor . FetchEphemeralPrivateKeyRes ownEphermalKey0 < nl > + = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; < nl > + < nl > + ArrayList < Long > keys = new ArrayList < Long > ( ) ; < nl > + keys . add ( theirEphermalKey0Id ) ; < nl > + < nl > + request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , keyGroupId , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + @ Override < nl > + public void onResult ( ResponsePublicKeys response ) { < nl > + onDecrypt ( data , ownEphermalKey0 . getPrivateKey ( ) , < nl > + ownEphermalKey . getPrivateKey ( ) , < nl > + theirEphermalKey , < nl > + response . getPublicKey ( ) . get ( 0 ) . getKeyMaterial ( ) , < nl > + messageIndex , < nl > + future ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( RpcException e ) { < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + < nl > + / / future . onResult ( ) ; < nl > + } < nl > + < nl > + private void onDecrypt ( byte [ ] data , < nl > + byte [ ] ownEphemeralPrivateKey0 , < nl > + byte [ ] ownEphemeralPrivateKey , < nl > + byte [ ] theirEphemeralKey0 , < nl > + byte [ ] theirEphemeralKey , < nl > + int index , < nl > + Future future ) { < nl > + < nl > + byte [ ] ms = RatchetMasterSecret . calculateMasterSecret ( < nl > + new RatchetPrivateKey ( ownIdentityKey . getPrivateKey ( ) ) , < nl > + new RatchetPrivateKey ( ownEphemeralPrivateKey0 ) , < nl > + new RatchetPublicKey ( encryptionKeyGroup . getIdentityKey ( ) . getKeyMaterial ( ) ) , < nl > + new RatchetPublicKey ( theirEphemeralKey0 ) ) ; < nl > + < nl > + byte [ ] rc = RatchetRootChainKey . makeRootChainKey ( < nl > + new RatchetPrivateKey ( ownEphemeralPrivateKey ) , < nl > + new RatchetPublicKey ( theirEphemeralKey ) , < nl > + ms ) ; < nl > + < nl > + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , index ) ; < nl > + < nl > + < nl > + future . onResult ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onReceive ( Object message ) { < nl > + if ( ! isReady & & message instanceof AskRequest ) { < nl > + stash ( ) ; < nl > + return ; < nl > + } < nl > + super . onReceive ( message ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public boolean onAsk ( Object message , Future future ) { < nl > + if ( message instanceof EncryptPackage ) { < nl > + onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; < nl > + return false ; < nl > + } else if ( message instanceof DecryptPackage ) { < nl > + DecryptPackage decryptPackage = ( DecryptPackage ) message ; < nl > + onDecrypt ( decryptPackage . getData ( ) , future ) ; < nl > + return false ; < nl > + } else { < nl > + return super . onAsk ( message , future ) ; < nl > + } < nl > + } < nl > + < nl > + public static class EncryptPackage { < nl > + private byte [ ] data ; < nl > + < nl > + public EncryptPackage ( byte [ ] data ) { < nl > + this . data = data ; < nl > + } < nl > + < nl > + public byte [ ] getData ( ) { < nl > + return data ; < nl > + } < nl > + } < nl > + < nl > + public static class EncryptedPackageRes { < nl > + < nl > + private byte [ ] data ; < nl > + < nl > + public EncryptedPackageRes ( byte [ ] data ) { < nl > + this . data = data ; < nl > + } < nl > + < nl > + public byte [ ] getData ( ) { < nl > + return data ; < nl > + } < nl > + } < nl > + < nl > + public static class DecryptPackage { < nl > + < nl > + private byte [ ] data ; < nl > + < nl > + public DecryptPackage ( byte [ ] data ) { < nl > + this . data = data ; < nl > + } < nl > + < nl > + public byte [ ] getData ( ) { < nl > + return data ; < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > deleted file mode 100644 < nl > index 5d65dd8 . . 0000000 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > + + + / dev / null < nl > @ @ - 1 , 292 + 0 , 0 @ @ < nl > - package im . actor . core . modules . encryption ; < nl > - < nl > - import java . util . ArrayList ; < nl > - < nl > - import im . actor . core . api . ApiEncryptionKey ; < nl > - import im . actor . core . api . ApiEncryptionKeyGroup ; < nl > - import im . actor . core . api . ApiUserOutPeer ; < nl > - import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; < nl > - import im . actor . core . api . rpc . ResponsePublicKeys ; < nl > - import im . actor . core . modules . ModuleContext ; < nl > - import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; < nl > - import im . actor . core . modules . encryption . entity . EncryptionKey ; < nl > - import im . actor . core . network . RpcCallback ; < nl > - import im . actor . core . network . RpcException ; < nl > - import im . actor . core . util . Hex ; < nl > - import im . actor . core . util . ModuleActor ; < nl > - import im . actor . core . util . RandomUtils ; < nl > - import im . actor . runtime . Crypto ; < nl > - import im . actor . runtime . Log ; < nl > - import im . actor . runtime . actors . Future ; < nl > - import im . actor . runtime . actors . ask . AskCallback ; < nl > - import im . actor . runtime . actors . ask . AskRequest ; < nl > - import im . actor . runtime . crypto . Curve25519 ; < nl > - import im . actor . runtime . crypto . IntegrityException ; < nl > - import im . actor . runtime . crypto . box . ActorBox ; < nl > - import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > - import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; < nl > - import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; < nl > - < nl > - public class EncryptionSessionActor extends ModuleActor { < nl > - < nl > - private final String TAG ; < nl > - < nl > - private final int uid ; < nl > - private final ApiEncryptionKeyGroup encryptionKeyGroup ; < nl > - < nl > - private EncryptionKey ownIdentityKey ; < nl > - private EncryptionKey theirIdentityKey ; < nl > - private EncryptionKey ownEphermalKey0 ; < nl > - private EncryptionKey theirEphermalKey0 ; < nl > - < nl > - private ArrayList < EncryptionKey > prevOwnKeys = new ArrayList < EncryptionKey > ( ) ; < nl > - private ArrayList < EncryptionKey > prevTheirKeys = new ArrayList < EncryptionKey > ( ) ; < nl > - < nl > - private EncryptionKey currentOwnKey ; < nl > - private EncryptionKey currentTheirKey ; < nl > - < nl > - private byte [ ] rootChainKey ; < nl > - < nl > - private int outIndex = 0 ; < nl > - < nl > - private boolean isReady = false ; < nl > - < nl > - public EncryptionSessionActor ( ModuleContext context , int uid , ApiEncryptionKeyGroup encryptionKeyGroup ) { < nl > - super ( context ) ; < nl > - this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; < nl > - this . uid = uid ; < nl > - this . encryptionKeyGroup = encryptionKeyGroup ; < nl > - this . theirIdentityKey = new EncryptionKey ( encryptionKeyGroup . getIdentityKey ( ) . getKeyId ( ) , encryptionKeyGroup . getIdentityKey ( ) . getKeyAlg ( ) , encryptionKeyGroup . getIdentityKey ( ) . getKeyMaterial ( ) , null ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void preStart ( ) { < nl > - if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { < nl > - Log . d ( TAG , " Loading own keys for conversation " ) ; < nl > - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { < nl > - @ Override < nl > - public void onResult ( Object obj ) { < nl > - Log . d ( TAG , " Own keys loaded " ) ; < nl > - KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; < nl > - ownIdentityKey = res . getIdentityKey ( ) ; < nl > - ownEphermalKey0 = res . getEphemeralKey ( ) ; < nl > - currentOwnKey = new EncryptionKey ( RandomUtils . nextRid ( ) , Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; < nl > - onOwnReady ( ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void onError ( Exception e ) { < nl > - / / Nothing to do < nl > - Log . w ( TAG , " Own keys error " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - < nl > - } < nl > - } ) ; < nl > - } else { < nl > - onOwnReady ( ) ; < nl > - } < nl > - } < nl > - < nl > - private void onOwnReady ( ) { < nl > - Log . w ( TAG , " Own keys ready " ) ; < nl > - < nl > - if ( theirEphermalKey0 = = null ) { < nl > - request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > - @ Override < nl > - public void onResult ( ResponsePublicKeys response ) { < nl > - if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > - Log . w ( TAG , " No ephemeral keys found " ) ; < nl > - return ; < nl > - } < nl > - < nl > - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > - theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; < nl > - onTheirReady0 ( ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void onError ( RpcException e ) { < nl > - / / Nothing to do < nl > - Log . w ( TAG , " Their ephemeral error " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - } < nl > - } ) ; < nl > - } else { < nl > - onTheirReady0 ( ) ; < nl > - } < nl > - } < nl > - < nl > - private void onTheirReady0 ( ) { < nl > - Log . w ( TAG , " Their identity ephemeral keys ready " ) ; < nl > - < nl > - if ( currentTheirKey = = null ) { < nl > - request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > - @ Override < nl > - public void onResult ( ResponsePublicKeys response ) { < nl > - if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > - Log . w ( TAG , " No ephemeral keys found " ) ; < nl > - return ; < nl > - } < nl > - < nl > - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > - currentTheirKey = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; < nl > - allSet ( ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void onError ( RpcException e ) { < nl > - / / Nothing to do < nl > - Log . w ( TAG , " Their ephemeral error " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - } < nl > - } ) ; < nl > - } else { < nl > - onTheirReady0 ( ) ; < nl > - } < nl > - } < nl > - < nl > - private void allSet ( ) { < nl > - Log . d ( TAG , " All keys are ready " ) ; < nl > - isReady = true ; < nl > - < nl > - byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( < nl > - new RatchetPrivateKey ( ownIdentityKey . getPrivateKey ( ) ) , < nl > - new RatchetPrivateKey ( ownEphermalKey0 . getPrivateKey ( ) ) , < nl > - new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > - new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; < nl > - rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > - new RatchetPrivateKey ( ownEphermalKey0 . getPrivateKey ( ) ) , < nl > - new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , < nl > - master _ secret ) ; < nl > - < nl > - unstashAll ( ) ; < nl > - } < nl > - < nl > - private void onEncrypt ( byte [ ] data , Future future ) { < nl > - < nl > - ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; < nl > - < nl > - byte [ ] header = ByteStrings . merge ( < nl > - ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , < nl > - ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > - ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > - currentOwnKey . getPublicKey ( ) , < nl > - currentTheirKey . getPublicKey ( ) , < nl > - ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / < nl > - < nl > - byte [ ] encrypted ; < nl > - try { < nl > - encrypted = ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ; < nl > - } catch ( IntegrityException e ) { < nl > - e . printStackTrace ( ) ; < nl > - future . onError ( e ) ; < nl > - return ; < nl > - } < nl > - < nl > - byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; < nl > - < nl > - < nl > - int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; < nl > - long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; < nl > - long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; < nl > - byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; < nl > - byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; < nl > - int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; < nl > - < nl > - Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; < nl > - Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; < nl > - Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > - Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > - Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; < nl > - < nl > - < nl > - Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; < nl > - Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; < nl > - < nl > - future . onResult ( new EncryptedPackageRes ( pkg ) ) ; < nl > - } < nl > - < nl > - private void onDecrypt ( byte [ ] data , Future future ) { < nl > - int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > - long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > - long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > - byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > - byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > - int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > - < nl > - Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > - Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; < nl > - Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; < nl > - < nl > - / / future . onResult ( ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void onReceive ( Object message ) { < nl > - if ( ! isReady & & message instanceof AskRequest ) { < nl > - stash ( ) ; < nl > - return ; < nl > - } < nl > - super . onReceive ( message ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public boolean onAsk ( Object message , Future future ) { < nl > - if ( message instanceof EncryptPackage ) { < nl > - onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; < nl > - return false ; < nl > - } else if ( message instanceof DecryptPackage ) { < nl > - DecryptPackage decryptPackage = ( DecryptPackage ) message ; < nl > - onDecrypt ( decryptPackage . getData ( ) , future ) ; < nl > - return false ; < nl > - } else { < nl > - return super . onAsk ( message , future ) ; < nl > - } < nl > - } < nl > - < nl > - public static class EncryptPackage { < nl > - private byte [ ] data ; < nl > - < nl > - public EncryptPackage ( byte [ ] data ) { < nl > - this . data = data ; < nl > - } < nl > - < nl > - public byte [ ] getData ( ) { < nl > - return data ; < nl > - } < nl > - } < nl > - < nl > - public static class EncryptedPackageRes { < nl > - < nl > - private byte [ ] data ; < nl > - < nl > - public EncryptedPackageRes ( byte [ ] data ) { < nl > - this . data = data ; < nl > - } < nl > - < nl > - public byte [ ] getData ( ) { < nl > - return data ; < nl > - } < nl > - } < nl > - < nl > - public static class DecryptPackage { < nl > - < nl > - private byte [ ] data ; < nl > - < nl > - public DecryptPackage ( byte [ ] data ) { < nl > - this . data = data ; < nl > - } < nl > - < nl > - public byte [ ] getData ( ) { < nl > - return data ; < nl > - } < nl > - } < nl > - } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj < nl > index 2f54661 . . c33368d 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj < nl > @ @ - 1550 , 7 + 1550 , 7 @ @ < nl > 	 	 	 	 TargetAttributes = { < nl > 	 	 	 	 	 066A50D11BC4AE63000E606E = { < nl > 	 	 	 	 	 	 CreatedOnToolsVersion = 7 . 0 ; < nl > - 	 	 	 	 	 	 DevelopmentTeam = PR6635TQQ3 ; < nl > + 	 	 	 	 	 	 DevelopmentTeam = HVJR44Y5B6 ; < nl > 	 	 	 	 	 } ; < nl > 	 	 	 	 } ; < nl > 	 	 	 } ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 2d72521 . . 37809ce 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . core . modules . encryption . entity . EncryptedBox ; < nl > import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; < nl > import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > + import im . actor . core . util . Hex ; < nl > import im . actor . core . util . ModuleActor ; < nl > import im . actor . runtime . Crypto ; < nl > import im . actor . runtime . Log ; < nl > @ @ - 25 , 6 + 26 , 7 @ @ import im . actor . runtime . actors . ask . AskRequest ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . box . ActorBox ; < nl > import im . actor . runtime . crypto . box . ActorBoxKey ; < nl > + import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > < nl > public class EncryptedPeerActor extends ModuleActor { < nl > < nl > @ @ - 34 , 6 + 36 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > private ArrayList < ApiEncryptionKeyGroup > keyGroups ; < nl > private HashMap < Integer , ActorRef > sessions = new HashMap < Integer , ActorRef > ( ) ; < nl > private boolean isReady = false ; < nl > + private int ownKeyGroupId ; < nl > < nl > public EncryptedPeerActor ( int uid , ModuleContext context ) { < nl > super ( context ) ; < nl > @ @ - 78 , 14 + 81 , 29 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > } < nl > } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; < nl > } < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKeyGroup ( ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + KeyManagerActor . FetchOwnKeyGroupResult res = ( KeyManagerActor . FetchOwnKeyGroupResult ) obj ; < nl > + ownKeyGroupId = res . getKeyGroupId ( ) ; < nl > + onOwnKeysReady ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + / / Do nothing < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > + private void onOwnKeysReady ( ) { < nl > + Log . w ( TAG , " onOwnKeysReady " ) ; < nl > isReady = true ; < nl > unstashAll ( ) ; < nl > } < nl > < nl > private void doEncrypt ( final byte [ ] data , final Future future ) { < nl > - < nl > Log . d ( TAG , " doEncrypt " ) ; < nl > - < nl > final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > < nl > final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > @ @ - 112 , 19 + 130 , 61 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > Log . d ( TAG , " doEncrypt2 " ) ; < nl > byte [ ] encData ; < nl > try { < nl > - encData = ActorBox . closeBox ( new byte [ 0 ] , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > } catch ( IntegrityException e ) { < nl > e . printStackTrace ( ) ; < nl > future . onError ( e ) ; < nl > return ; < nl > } < nl > < nl > - EncryptedBox encryptedBox = new EncryptedBox ( encryptedKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , encData ) ; < nl > + EncryptedBox encryptedBox = new EncryptedBox ( < nl > + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > + < nl > + Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; < nl > + for ( EncryptedBoxKey k : encryptedKeys ) { < nl > + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + < nl > future . onResult ( encryptedBox ) ; < nl > } < nl > < nl > - private void doDecrypt ( EncryptedBox data , Future future ) { < nl > + private void doDecrypt ( EncryptedBox data , final Future future ) { < nl > + int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; < nl > + byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; < nl > + < nl > + if ( sessions . containsKey ( senderKeyGroup ) ) { < nl > + Log . d ( TAG , " Decryption with key group " ) ; < nl > + byte [ ] encKey = null ; < nl > + for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > + if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { < nl > + encKey = k . getEncryptedKey ( ) ; < nl > + break ; < nl > + } < nl > + } < nl > + < nl > + Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; < nl > + for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + < nl > + ask ( sessions . get ( senderKeyGroup ) , new EncryptionSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " Decryption with key group : onResult " ) ; < nl > + future . onResult ( ) ; < nl > + } < nl > < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . d ( TAG , " Decryption with key group : onError " ) ; < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + } else { < nl > + Log . w ( TAG , " Unable to find appropriate session # " + senderKeyGroup ) ; < nl > + future . onError ( new RuntimeException ( ) ) ; < nl > + } < nl > } < nl > < nl > @ Override < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > index 7f57506 . . 5d65dd8 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java < nl > @ @ - 8 , 9 + 8 , 11 @ @ import im . actor . core . api . ApiUserOutPeer ; < nl > import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; < nl > import im . actor . core . api . rpc . ResponsePublicKeys ; < nl > import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; < nl > import im . actor . core . modules . encryption . entity . EncryptionKey ; < nl > import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > + import im . actor . core . util . Hex ; < nl > import im . actor . core . util . ModuleActor ; < nl > import im . actor . core . util . RandomUtils ; < nl > import im . actor . runtime . Crypto ; < nl > @ @ - 101 , 7 + 103 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > return ; < nl > } < nl > < nl > - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( 0 ) ; < nl > + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; < nl > onTheirReady0 ( ) ; < nl > } < nl > @ @ - 169 , 6 + 171 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; < nl > < nl > byte [ ] header = ByteStrings . merge ( < nl > + ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , < nl > ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > currentOwnKey . getPublicKey ( ) , < nl > @ @ - 186 , 9 + 189 , 46 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > < nl > byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; < nl > < nl > + < nl > + int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; < nl > + long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; < nl > + long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; < nl > + byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; < nl > + byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; < nl > + int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; < nl > + < nl > + Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; < nl > + Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; < nl > + < nl > + < nl > + Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; < nl > + Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; < nl > + < nl > future . onResult ( new EncryptedPackageRes ( pkg ) ) ; < nl > } < nl > < nl > + private void onDecrypt ( byte [ ] data , Future future ) { < nl > + int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > + long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > + long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > + byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > + byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > + int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > + < nl > + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > + Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; < nl > + Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > + Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; < nl > + < nl > + / / future . onResult ( ) ; < nl > + } < nl > + < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > if ( ! isReady & & message instanceof AskRequest ) { < nl > @ @ - 203 , 6 + 243 , 10 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > if ( message instanceof EncryptPackage ) { < nl > onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; < nl > return false ; < nl > + } else if ( message instanceof DecryptPackage ) { < nl > + DecryptPackage decryptPackage = ( DecryptPackage ) message ; < nl > + onDecrypt ( decryptPackage . getData ( ) , future ) ; < nl > + return false ; < nl > } else { < nl > return super . onAsk ( message , future ) ; < nl > } < nl > @ @ - 232 , 4 + 276 , 17 @ @ public class EncryptionSessionActor extends ModuleActor { < nl > return data ; < nl > } < nl > } < nl > + < nl > + public static class DecryptPackage { < nl > + < nl > + private byte [ ] data ; < nl > + < nl > + public DecryptPackage ( byte [ ] data ) { < nl > + this . data = data ; < nl > + } < nl > + < nl > + public byte [ ] getData ( ) { < nl > + return data ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index f4eb042 . . 58c2383 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 230 , 6 + 230 , 10 @ @ public class KeyManagerActor extends ModuleActor { < nl > future . onResult ( new FetchOwnKeyResult ( privateKeyStorage . getIdentityKey ( ) , ephemeralEncryptionKey . getEncryptionKey ( ) ) ) ; < nl > } < nl > < nl > + private void fetchKeyGroup ( Future future ) { < nl > + future . onResult ( new FetchOwnKeyGroupResult ( privateKeyStorage . getKeyGroupId ( ) ) ) ; < nl > + } < nl > + < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > if ( message instanceof AskRequest & & ! isReady ) { < nl > @ @ - 244 , 6 + 248 , 9 @ @ public class KeyManagerActor extends ModuleActor { < nl > if ( message instanceof FetchOwnKey ) { < nl > fetchOwnKey ( future ) ; < nl > return false ; < nl > + } else if ( message instanceof FetchOwnKeyGroup ) { < nl > + fetchKeyGroup ( future ) ; < nl > + return false ; < nl > } < nl > return super . onAsk ( message , future ) ; < nl > } < nl > @ @ - 270 , 4 + 277 , 20 @ @ public class KeyManagerActor extends ModuleActor { < nl > return ephemeralKey ; < nl > } < nl > } < nl > + < nl > + public static class FetchOwnKeyGroup { < nl > + < nl > + } < nl > + < nl > + public static class FetchOwnKeyGroupResult { < nl > + private int keyGroupId ; < nl > + < nl > + public FetchOwnKeyGroupResult ( int keyGroupId ) { < nl > + this . keyGroupId = keyGroupId ; < nl > + } < nl > + < nl > + public int getKeyGroupId ( ) { < nl > + return keyGroupId ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java < nl > index 815d4ba . . 6d0d54d 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java < nl > @ @ - 48 , 6 + 48 , 29 @ @ public class MessageEncryptionActor extends ModuleActor { < nl > } ) ; < nl > } < nl > < nl > + public void onDecrypt ( int uid , ApiEncryptedMessage message ) { < nl > + Log . d ( TAG , " onDecrypt : " + uid ) ; < nl > + ArrayList < EncryptedBoxKey > encryptedBoxKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > + for ( ApiEncyptedBoxKey key : message . getBox ( ) . getKeys ( ) ) { < nl > + if ( key . getUsersId ( ) = = myUid ( ) ) { < nl > + encryptedBoxKeys . add ( new EncryptedBoxKey ( key . getUsersId ( ) , key . getKeyGroupId ( ) , < nl > + key . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + } < nl > + EncryptedBox encryptedBox = new EncryptedBox ( encryptedBoxKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , message . getBox ( ) . getEncPackage ( ) ) ; < nl > + ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . DecryptPackage ( encryptedBox ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " onDecrypt : onResult " ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . d ( TAG , " onDecrypt : onError " ) ; < nl > + } < nl > + } ) ; < nl > + } < nl > + < nl > @ Override < nl > public boolean onAsk ( Object message , Future future ) { < nl > if ( message instanceof EncryptMessage ) { < nl > @ @ - 58 , 6 + 81 , 16 @ @ public class MessageEncryptionActor extends ModuleActor { < nl > return super . onAsk ( message , future ) ; < nl > } < nl > < nl > + @ Override < nl > + public void onReceive ( Object message ) { < nl > + if ( message instanceof InMessage ) { < nl > + InMessage inMessage = ( InMessage ) message ; < nl > + onDecrypt ( inMessage . senderUid , inMessage . encryptedMessage ) ; < nl > + } else { < nl > + super . onReceive ( message ) ; < nl > + } < nl > + } < nl > + < nl > public static class InMessage { < nl > < nl > private Peer peer ; < nl > @ @ - 105 , 4 + 138 , 17 @ @ public class MessageEncryptionActor extends ModuleActor { < nl > return encryptedMessage ; < nl > } < nl > } < nl > + < nl > + public static class DecryptMessage { < nl > + < nl > + private ApiEncryptedMessage encryptedMessage ; < nl > + < nl > + public DecryptMessage ( ApiEncryptedMessage encryptedMessage ) { < nl > + this . encryptedMessage = encryptedMessage ; < nl > + } < nl > + < nl > + public ApiEncryptedMessage getEncryptedMessage ( ) { < nl > + return encryptedMessage ; < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java < nl > index 9da4c36 . . 8a8877a 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java < nl > @ @ - 27 , 6 + 27 , 7 @ @ import im . actor . core . entity . content . AbsContent ; < nl > import im . actor . core . entity . content . ServiceUserRegistered ; < nl > import im . actor . core . modules . AbsModule ; < nl > import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . encryption . MessageEncryptionActor ; < nl > import im . actor . core . modules . internal . messages . ConversationActor ; < nl > import im . actor . core . modules . internal . messages . ConversationHistoryActor ; < nl > import im . actor . core . modules . internal . messages . CursorReceiverActor ; < nl > @ @ - 53 , 11 + 54 , 13 @ @ public class MessagesProcessor extends AbsModule { < nl > long intMessageSortDate = 0 ; < nl > Peer peer = convert ( _ peer ) ; < nl > < nl > - ArrayList < Message > nMesages = new ArrayList < Message > ( ) ; < nl > + ArrayList < Message > nMessages = new ArrayList < Message > ( ) ; < nl > for ( UpdateMessage u : messages ) { < nl > < nl > if ( u . getMessage ( ) instanceof ApiEncryptedMessage ) { < nl > - / / TODO : Decrypt message < nl > + / / TODO : Proper decrypt message < nl > + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , < nl > + u . getDate ( ) , u . getSenderUid ( ) , u . getRid ( ) , ( ApiEncryptedMessage ) u . getMessage ( ) ) ) ; < nl > continue ; < nl > } < nl > < nl > @ @ - 72 , 7 + 75 , 7 @ @ public class MessagesProcessor extends AbsModule { < nl > boolean isOut = myUid ( ) = = u . getSenderUid ( ) ; < nl > < nl > / / Sending message to conversation < nl > - nMesages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , < nl > + nMessages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , < nl > isOut ? MessageState . SENT : MessageState . UNKNOWN , msgContent , < nl > new ArrayList < Reaction > ( ) ) ) ; < nl > < nl > @ @ - 84 , 7 + 87 , 7 @ @ public class MessagesProcessor extends AbsModule { < nl > } < nl > } < nl > < nl > - conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMesages ) ) ; < nl > + conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMessages ) ) ; < nl > < nl > if ( intMessageSortDate > 0 ) { < nl > plainReceiveActor ( ) . send ( new CursorReceiverActor . MarkReceived ( peer , intMessageSortDate ) ) ; < nl > @ @ - 95 , 7 + 98 , 7 @ @ public class MessagesProcessor extends AbsModule { < nl > } < nl > < nl > / / OwnReadActor < nl > - for ( Message m : nMesages ) { < nl > + for ( Message m : nMessages ) { < nl > if ( m . getSenderId ( ) ! = myUid ( ) ) { < nl > ownReadActor ( ) . send ( new OwnReadActor . InMessage ( peer , m ) ) ; < nl > } < nl > @ @ - 107 , 6 + 110 , 13 @ @ public class MessagesProcessor extends AbsModule { < nl > ApiMessage content ) { < nl > < nl > Peer peer = convert ( _ peer ) ; < nl > + < nl > + if ( content instanceof ApiEncryptedMessage ) { < nl > + / / TODO : Proper decrypt message < nl > + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , < nl > + date , senderUid , rid , ( ApiEncryptedMessage ) content ) ) ; < nl > + } < nl > + < nl > AbsContent msgContent ; < nl > try { < nl > msgContent = AbsContent . fromMessage ( content ) ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > index 7ff7e50 . . e4aff27 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > @ @ - 22 , 7 + 22 , 7 @ @ public class ByteStrings { < nl > } < nl > < nl > public static byte [ ] intToBytes ( int v ) { < nl > - byte [ ] data = new byte [ 8 ] ; < nl > + byte [ ] data = new byte [ 4 ] ; < nl > int offset = 0 ; < nl > data [ offset + + ] = ( byte ) ( ( v > > 24 ) & 0xFF ) ; < nl > data [ offset + + ] = ( byte ) ( ( v > > 16 ) & 0xFF ) ;

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 37809ce . . 7796c91 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 74 , 10 + 74 , 10 @ @ public class EncryptedPeerActor extends ModuleActor { 
 Log . w ( TAG , " Groups ready # " + keyGroups . size ( ) ) ; 
 
 for ( final ApiEncryptionKeyGroup g : keyGroups ) { 
 - sessions . put ( g . getKeyGroupId ( ) , system ( ) . actorOf ( Props . create ( EncryptionSessionActor . class , new ActorCreator < EncryptionSessionActor > ( ) { 
 + sessions . put ( g . getKeyGroupId ( ) , system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { 
 @ Override 
 - public EncryptionSessionActor create ( ) { 
 - return new EncryptionSessionActor ( context ( ) , uid , g ) ; 
 + public EncryptedSessionActor create ( ) { 
 + return new EncryptedSessionActor ( context ( ) , uid , g ) ; 
 } 
 } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; 
 } 
 @ @ - 108 , 10 + 108 , 10 @ @ public class EncryptedPeerActor extends ModuleActor { 
 
 final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 for ( final Integer keyGroup : sessions . keySet ( ) ) { 
 - ask ( sessions . get ( keyGroup ) , new EncryptionSessionActor . EncryptPackage ( encKey ) , new AskCallback ( ) { 
 + ask ( sessions . get ( keyGroup ) , new EncryptedSessionActor . EncryptPackage ( encKey ) , new AskCallback ( ) { 
 @ Override 
 public void onResult ( Object obj ) { 
 - EncryptionSessionActor . EncryptedPackageRes res = ( EncryptionSessionActor . EncryptedPackageRes ) obj ; 
 + EncryptedSessionActor . EncryptedPackageRes res = ( EncryptedSessionActor . EncryptedPackageRes ) obj ; 
 encryptedKeys . add ( new EncryptedBoxKey ( uid , keyGroup , res . getData ( ) ) ) ; 
 if ( encryptedKeys . size ( ) = = sessions . size ( ) ) { 
 doEncrypt ( encKey , data , encryptedKeys , future ) ; 
 @ @ - 168 , 7 + 168 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { 
 Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 } 
 
 - ask ( sessions . get ( senderKeyGroup ) , new EncryptionSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { 
 + ask ( sessions . get ( senderKeyGroup ) , new EncryptedSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { 
 @ Override 
 public void onResult ( Object obj ) { 
 Log . d ( TAG , " Decryption with key group : onResult " ) ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 new file mode 100644 
 index 0000000 . . e68d85d 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 0 , 0 + 1 , 365 @ @ 
 + package im . actor . core . modules . encryption ; 
 + 
 + import java . util . ArrayList ; 
 + 
 + import im . actor . core . api . ApiEncryptionKey ; 
 + import im . actor . core . api . ApiEncryptionKeyGroup ; 
 + import im . actor . core . api . ApiUserOutPeer ; 
 + import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; 
 + import im . actor . core . api . rpc . RequestLoadPublicKey ; 
 + import im . actor . core . api . rpc . ResponsePublicKeys ; 
 + import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . encryption . entity . EncryptionKey ; 
 + import im . actor . core . network . RpcCallback ; 
 + import im . actor . core . network . RpcException ; 
 + import im . actor . core . util . Hex ; 
 + import im . actor . core . util . ModuleActor ; 
 + import im . actor . core . util . RandomUtils ; 
 + import im . actor . runtime . Crypto ; 
 + import im . actor . runtime . Log ; 
 + import im . actor . runtime . actors . Future ; 
 + import im . actor . runtime . actors . ask . AskCallback ; 
 + import im . actor . runtime . actors . ask . AskRequest ; 
 + import im . actor . runtime . crypto . Curve25519 ; 
 + import im . actor . runtime . crypto . IntegrityException ; 
 + import im . actor . runtime . crypto . box . ActorBox ; 
 + import im . actor . runtime . crypto . box . ActorBoxKey ; 
 + import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 + import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; 
 + import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; 
 + import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; 
 + import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; 
 + import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; 
 + 
 + public class EncryptedSessionActor extends ModuleActor { 
 + 
 + private final String TAG ; 
 + 
 + private final int uid ; 
 + private final ApiEncryptionKeyGroup encryptionKeyGroup ; 
 + 
 + private EncryptionKey ownIdentityKey ; 
 + private EncryptionKey theirIdentityKey ; 
 + private EncryptionKey ownEphermalKey0 ; 
 + private EncryptionKey theirEphermalKey0 ; 
 + 
 + private EncryptionKey prevOwnKey ; 
 + private EncryptionKey currentOwnKey ; 
 + private EncryptionKey currentTheirKey ; 
 + 
 + private byte [ ] rootChainKey ; 
 + 
 + private int outIndex = 0 ; 
 + private int inIndex = 0 ; 
 + 
 + private boolean isReady = false ; 
 + 
 + public EncryptedSessionActor ( ModuleContext context , int uid , ApiEncryptionKeyGroup encryptionKeyGroup ) { 
 + super ( context ) ; 
 + this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; 
 + this . uid = uid ; 
 + this . encryptionKeyGroup = encryptionKeyGroup ; 
 + this . theirIdentityKey = new EncryptionKey ( encryptionKeyGroup . getIdentityKey ( ) . getKeyId ( ) , encryptionKeyGroup . getIdentityKey ( ) . getKeyAlg ( ) , encryptionKeyGroup . getIdentityKey ( ) . getKeyMaterial ( ) , null ) ; 
 + } 
 + 
 + @ Override 
 + public void preStart ( ) { 
 + if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { 
 + Log . d ( TAG , " Loading own keys for conversation " ) ; 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + Log . d ( TAG , " Own keys loaded " ) ; 
 + KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; 
 + ownIdentityKey = res . getIdentityKey ( ) ; 
 + ownEphermalKey0 = res . getEphemeralKey ( ) ; 
 + currentOwnKey = new EncryptionKey ( RandomUtils . nextRid ( ) , Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; 
 + onOwnReady ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + / / Nothing to do 
 + Log . w ( TAG , " Own keys error " ) ; 
 + Log . e ( TAG , e ) ; 
 + 
 + } 
 + } ) ; 
 + } else { 
 + onOwnReady ( ) ; 
 + } 
 + } 
 + 
 + private void onOwnReady ( ) { 
 + Log . w ( TAG , " Own keys ready " ) ; 
 + 
 + if ( theirEphermalKey0 = = null ) { 
 + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + @ Override 
 + public void onResult ( ResponsePublicKeys response ) { 
 + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 + Log . w ( TAG , " No ephemeral keys found " ) ; 
 + return ; 
 + } 
 + 
 + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 + theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; 
 + onTheirReady0 ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( RpcException e ) { 
 + / / Nothing to do 
 + Log . w ( TAG , " Their ephemeral error " ) ; 
 + Log . e ( TAG , e ) ; 
 + } 
 + } ) ; 
 + } else { 
 + onTheirReady0 ( ) ; 
 + } 
 + } 
 + 
 + private void onTheirReady0 ( ) { 
 + Log . w ( TAG , " Their identity ephemeral keys ready " ) ; 
 + 
 + if ( currentTheirKey = = null ) { 
 + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + @ Override 
 + public void onResult ( ResponsePublicKeys response ) { 
 + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 + Log . w ( TAG , " No ephemeral keys found " ) ; 
 + return ; 
 + } 
 + 
 + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 + currentTheirKey = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; 
 + allSet ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( RpcException e ) { 
 + / / Nothing to do 
 + Log . w ( TAG , " Their ephemeral error " ) ; 
 + Log . e ( TAG , e ) ; 
 + } 
 + } ) ; 
 + } else { 
 + onTheirReady0 ( ) ; 
 + } 
 + } 
 + 
 + private void allSet ( ) { 
 + Log . d ( TAG , " All keys are ready " ) ; 
 + isReady = true ; 
 + 
 + byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( 
 + new RatchetPrivateKey ( ownIdentityKey . getPrivateKey ( ) ) , 
 + new RatchetPrivateKey ( ownEphermalKey0 . getPrivateKey ( ) ) , 
 + new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 + new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; 
 + rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 + new RatchetPrivateKey ( ownEphermalKey0 . getPrivateKey ( ) ) , 
 + new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , 
 + master _ secret ) ; 
 + 
 + unstashAll ( ) ; 
 + } 
 + 
 + private void onEncrypt ( byte [ ] data , Future future ) { 
 + 
 + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; 
 + 
 + byte [ ] header = ByteStrings . merge ( 
 + ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , 
 + ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 + ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 + currentOwnKey . getPublicKey ( ) , 
 + currentTheirKey . getPublicKey ( ) , 
 + ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / 
 + 
 + byte [ ] encrypted ; 
 + try { 
 + encrypted = ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ; 
 + } catch ( IntegrityException e ) { 
 + e . printStackTrace ( ) ; 
 + future . onError ( e ) ; 
 + return ; 
 + } 
 + 
 + byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; 
 + 
 + 
 + int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; 
 + long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; 
 + long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; 
 + byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; 
 + byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; 
 + int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; 
 + 
 + Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; 
 + Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; 
 + 
 + 
 + Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; 
 + Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 + Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 + Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; 
 + 
 + future . onResult ( new EncryptedPackageRes ( pkg ) ) ; 
 + } 
 + 
 + private void onDecrypt ( final byte [ ] data , final Future future ) { 
 + final int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 + final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 + final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 + final byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 + final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 + final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 + 
 + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 + Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; 
 + Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 + Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 + Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; 
 + 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( ownEphermalKey ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + 
 + final KeyManagerActor . FetchEphemeralPrivateKeyRes ownEphermalKey 
 + = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; 
 + 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKeyById ( ownEphermalKey0Id ) , 
 + new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + final KeyManagerActor . FetchEphemeralPrivateKeyRes ownEphermalKey0 
 + = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; 
 + 
 + ArrayList < Long > keys = new ArrayList < Long > ( ) ; 
 + keys . add ( theirEphermalKey0Id ) ; 
 + 
 + request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , keyGroupId , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + @ Override 
 + public void onResult ( ResponsePublicKeys response ) { 
 + onDecrypt ( data , ownEphermalKey0 . getPrivateKey ( ) , 
 + ownEphermalKey . getPrivateKey ( ) , 
 + theirEphermalKey , 
 + response . getPublicKey ( ) . get ( 0 ) . getKeyMaterial ( ) , 
 + messageIndex , 
 + future ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( RpcException e ) { 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + 
 + / / future . onResult ( ) ; 
 + } 
 + 
 + private void onDecrypt ( byte [ ] data , 
 + byte [ ] ownEphemeralPrivateKey0 , 
 + byte [ ] ownEphemeralPrivateKey , 
 + byte [ ] theirEphemeralKey0 , 
 + byte [ ] theirEphemeralKey , 
 + int index , 
 + Future future ) { 
 + 
 + byte [ ] ms = RatchetMasterSecret . calculateMasterSecret ( 
 + new RatchetPrivateKey ( ownIdentityKey . getPrivateKey ( ) ) , 
 + new RatchetPrivateKey ( ownEphemeralPrivateKey0 ) , 
 + new RatchetPublicKey ( encryptionKeyGroup . getIdentityKey ( ) . getKeyMaterial ( ) ) , 
 + new RatchetPublicKey ( theirEphemeralKey0 ) ) ; 
 + 
 + byte [ ] rc = RatchetRootChainKey . makeRootChainKey ( 
 + new RatchetPrivateKey ( ownEphemeralPrivateKey ) , 
 + new RatchetPublicKey ( theirEphemeralKey ) , 
 + ms ) ; 
 + 
 + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , index ) ; 
 + 
 + 
 + future . onResult ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onReceive ( Object message ) { 
 + if ( ! isReady & & message instanceof AskRequest ) { 
 + stash ( ) ; 
 + return ; 
 + } 
 + super . onReceive ( message ) ; 
 + } 
 + 
 + @ Override 
 + public boolean onAsk ( Object message , Future future ) { 
 + if ( message instanceof EncryptPackage ) { 
 + onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; 
 + return false ; 
 + } else if ( message instanceof DecryptPackage ) { 
 + DecryptPackage decryptPackage = ( DecryptPackage ) message ; 
 + onDecrypt ( decryptPackage . getData ( ) , future ) ; 
 + return false ; 
 + } else { 
 + return super . onAsk ( message , future ) ; 
 + } 
 + } 
 + 
 + public static class EncryptPackage { 
 + private byte [ ] data ; 
 + 
 + public EncryptPackage ( byte [ ] data ) { 
 + this . data = data ; 
 + } 
 + 
 + public byte [ ] getData ( ) { 
 + return data ; 
 + } 
 + } 
 + 
 + public static class EncryptedPackageRes { 
 + 
 + private byte [ ] data ; 
 + 
 + public EncryptedPackageRes ( byte [ ] data ) { 
 + this . data = data ; 
 + } 
 + 
 + public byte [ ] getData ( ) { 
 + return data ; 
 + } 
 + } 
 + 
 + public static class DecryptPackage { 
 + 
 + private byte [ ] data ; 
 + 
 + public DecryptPackage ( byte [ ] data ) { 
 + this . data = data ; 
 + } 
 + 
 + public byte [ ] getData ( ) { 
 + return data ; 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 deleted file mode 100644 
 index 5d65dd8 . . 0000000 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 + + + / dev / null 
 @ @ - 1 , 292 + 0 , 0 @ @ 
 - package im . actor . core . modules . encryption ; 
 - 
 - import java . util . ArrayList ; 
 - 
 - import im . actor . core . api . ApiEncryptionKey ; 
 - import im . actor . core . api . ApiEncryptionKeyGroup ; 
 - import im . actor . core . api . ApiUserOutPeer ; 
 - import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; 
 - import im . actor . core . api . rpc . ResponsePublicKeys ; 
 - import im . actor . core . modules . ModuleContext ; 
 - import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; 
 - import im . actor . core . modules . encryption . entity . EncryptionKey ; 
 - import im . actor . core . network . RpcCallback ; 
 - import im . actor . core . network . RpcException ; 
 - import im . actor . core . util . Hex ; 
 - import im . actor . core . util . ModuleActor ; 
 - import im . actor . core . util . RandomUtils ; 
 - import im . actor . runtime . Crypto ; 
 - import im . actor . runtime . Log ; 
 - import im . actor . runtime . actors . Future ; 
 - import im . actor . runtime . actors . ask . AskCallback ; 
 - import im . actor . runtime . actors . ask . AskRequest ; 
 - import im . actor . runtime . crypto . Curve25519 ; 
 - import im . actor . runtime . crypto . IntegrityException ; 
 - import im . actor . runtime . crypto . box . ActorBox ; 
 - import im . actor . runtime . crypto . box . ActorBoxKey ; 
 - import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 - import im . actor . runtime . crypto . ratchet . RatchetMasterSecret ; 
 - import im . actor . runtime . crypto . ratchet . RatchetMessageKey ; 
 - import im . actor . runtime . crypto . ratchet . RatchetPrivateKey ; 
 - import im . actor . runtime . crypto . ratchet . RatchetPublicKey ; 
 - import im . actor . runtime . crypto . ratchet . RatchetRootChainKey ; 
 - 
 - public class EncryptionSessionActor extends ModuleActor { 
 - 
 - private final String TAG ; 
 - 
 - private final int uid ; 
 - private final ApiEncryptionKeyGroup encryptionKeyGroup ; 
 - 
 - private EncryptionKey ownIdentityKey ; 
 - private EncryptionKey theirIdentityKey ; 
 - private EncryptionKey ownEphermalKey0 ; 
 - private EncryptionKey theirEphermalKey0 ; 
 - 
 - private ArrayList < EncryptionKey > prevOwnKeys = new ArrayList < EncryptionKey > ( ) ; 
 - private ArrayList < EncryptionKey > prevTheirKeys = new ArrayList < EncryptionKey > ( ) ; 
 - 
 - private EncryptionKey currentOwnKey ; 
 - private EncryptionKey currentTheirKey ; 
 - 
 - private byte [ ] rootChainKey ; 
 - 
 - private int outIndex = 0 ; 
 - 
 - private boolean isReady = false ; 
 - 
 - public EncryptionSessionActor ( ModuleContext context , int uid , ApiEncryptionKeyGroup encryptionKeyGroup ) { 
 - super ( context ) ; 
 - this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; 
 - this . uid = uid ; 
 - this . encryptionKeyGroup = encryptionKeyGroup ; 
 - this . theirIdentityKey = new EncryptionKey ( encryptionKeyGroup . getIdentityKey ( ) . getKeyId ( ) , encryptionKeyGroup . getIdentityKey ( ) . getKeyAlg ( ) , encryptionKeyGroup . getIdentityKey ( ) . getKeyMaterial ( ) , null ) ; 
 - } 
 - 
 - @ Override 
 - public void preStart ( ) { 
 - if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { 
 - Log . d ( TAG , " Loading own keys for conversation " ) ; 
 - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { 
 - @ Override 
 - public void onResult ( Object obj ) { 
 - Log . d ( TAG , " Own keys loaded " ) ; 
 - KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; 
 - ownIdentityKey = res . getIdentityKey ( ) ; 
 - ownEphermalKey0 = res . getEphemeralKey ( ) ; 
 - currentOwnKey = new EncryptionKey ( RandomUtils . nextRid ( ) , Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; 
 - onOwnReady ( ) ; 
 - } 
 - 
 - @ Override 
 - public void onError ( Exception e ) { 
 - / / Nothing to do 
 - Log . w ( TAG , " Own keys error " ) ; 
 - Log . e ( TAG , e ) ; 
 - 
 - } 
 - } ) ; 
 - } else { 
 - onOwnReady ( ) ; 
 - } 
 - } 
 - 
 - private void onOwnReady ( ) { 
 - Log . w ( TAG , " Own keys ready " ) ; 
 - 
 - if ( theirEphermalKey0 = = null ) { 
 - request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 - @ Override 
 - public void onResult ( ResponsePublicKeys response ) { 
 - if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 - Log . w ( TAG , " No ephemeral keys found " ) ; 
 - return ; 
 - } 
 - 
 - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 - theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; 
 - onTheirReady0 ( ) ; 
 - } 
 - 
 - @ Override 
 - public void onError ( RpcException e ) { 
 - / / Nothing to do 
 - Log . w ( TAG , " Their ephemeral error " ) ; 
 - Log . e ( TAG , e ) ; 
 - } 
 - } ) ; 
 - } else { 
 - onTheirReady0 ( ) ; 
 - } 
 - } 
 - 
 - private void onTheirReady0 ( ) { 
 - Log . w ( TAG , " Their identity ephemeral keys ready " ) ; 
 - 
 - if ( currentTheirKey = = null ) { 
 - request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 - @ Override 
 - public void onResult ( ResponsePublicKeys response ) { 
 - if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 - Log . w ( TAG , " No ephemeral keys found " ) ; 
 - return ; 
 - } 
 - 
 - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 - currentTheirKey = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; 
 - allSet ( ) ; 
 - } 
 - 
 - @ Override 
 - public void onError ( RpcException e ) { 
 - / / Nothing to do 
 - Log . w ( TAG , " Their ephemeral error " ) ; 
 - Log . e ( TAG , e ) ; 
 - } 
 - } ) ; 
 - } else { 
 - onTheirReady0 ( ) ; 
 - } 
 - } 
 - 
 - private void allSet ( ) { 
 - Log . d ( TAG , " All keys are ready " ) ; 
 - isReady = true ; 
 - 
 - byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( 
 - new RatchetPrivateKey ( ownIdentityKey . getPrivateKey ( ) ) , 
 - new RatchetPrivateKey ( ownEphermalKey0 . getPrivateKey ( ) ) , 
 - new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 - new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; 
 - rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 - new RatchetPrivateKey ( ownEphermalKey0 . getPrivateKey ( ) ) , 
 - new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , 
 - master _ secret ) ; 
 - 
 - unstashAll ( ) ; 
 - } 
 - 
 - private void onEncrypt ( byte [ ] data , Future future ) { 
 - 
 - ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; 
 - 
 - byte [ ] header = ByteStrings . merge ( 
 - ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , 
 - ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 - ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 - currentOwnKey . getPublicKey ( ) , 
 - currentTheirKey . getPublicKey ( ) , 
 - ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / 
 - 
 - byte [ ] encrypted ; 
 - try { 
 - encrypted = ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ; 
 - } catch ( IntegrityException e ) { 
 - e . printStackTrace ( ) ; 
 - future . onError ( e ) ; 
 - return ; 
 - } 
 - 
 - byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; 
 - 
 - 
 - int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; 
 - long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; 
 - long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; 
 - byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; 
 - byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; 
 - int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; 
 - 
 - Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; 
 - Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; 
 - Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 - Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 - Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; 
 - 
 - 
 - Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; 
 - Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 - Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 - Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; 
 - 
 - future . onResult ( new EncryptedPackageRes ( pkg ) ) ; 
 - } 
 - 
 - private void onDecrypt ( byte [ ] data , Future future ) { 
 - int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 - long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 - long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 - byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 - byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 - int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 - 
 - Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 - Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; 
 - Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 - Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 - Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; 
 - 
 - / / future . onResult ( ) ; 
 - } 
 - 
 - @ Override 
 - public void onReceive ( Object message ) { 
 - if ( ! isReady & & message instanceof AskRequest ) { 
 - stash ( ) ; 
 - return ; 
 - } 
 - super . onReceive ( message ) ; 
 - } 
 - 
 - @ Override 
 - public boolean onAsk ( Object message , Future future ) { 
 - if ( message instanceof EncryptPackage ) { 
 - onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; 
 - return false ; 
 - } else if ( message instanceof DecryptPackage ) { 
 - DecryptPackage decryptPackage = ( DecryptPackage ) message ; 
 - onDecrypt ( decryptPackage . getData ( ) , future ) ; 
 - return false ; 
 - } else { 
 - return super . onAsk ( message , future ) ; 
 - } 
 - } 
 - 
 - public static class EncryptPackage { 
 - private byte [ ] data ; 
 - 
 - public EncryptPackage ( byte [ ] data ) { 
 - this . data = data ; 
 - } 
 - 
 - public byte [ ] getData ( ) { 
 - return data ; 
 - } 
 - } 
 - 
 - public static class EncryptedPackageRes { 
 - 
 - private byte [ ] data ; 
 - 
 - public EncryptedPackageRes ( byte [ ] data ) { 
 - this . data = data ; 
 - } 
 - 
 - public byte [ ] getData ( ) { 
 - return data ; 
 - } 
 - } 
 - 
 - public static class DecryptPackage { 
 - 
 - private byte [ ] data ; 
 - 
 - public DecryptPackage ( byte [ ] data ) { 
 - this . data = data ; 
 - } 
 - 
 - public byte [ ] getData ( ) { 
 - return data ; 
 - } 
 - } 
 - } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj 
 index 2f54661 . . c33368d 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK . xcodeproj / project . pbxproj 
 @ @ - 1550 , 7 + 1550 , 7 @ @ 
 	 	 	 	 TargetAttributes = { 
 	 	 	 	 	 066A50D11BC4AE63000E606E = { 
 	 	 	 	 	 	 CreatedOnToolsVersion = 7 . 0 ; 
 - 	 	 	 	 	 	 DevelopmentTeam = PR6635TQQ3 ; 
 + 	 	 	 	 	 	 DevelopmentTeam = HVJR44Y5B6 ; 
 	 	 	 	 	 } ; 
 	 	 	 	 } ; 
 	 	 	 } ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 2d72521 . . 37809ce 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . core . modules . encryption . entity . EncryptedBox ; 
 import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; 
 import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 + import im . actor . core . util . Hex ; 
 import im . actor . core . util . ModuleActor ; 
 import im . actor . runtime . Crypto ; 
 import im . actor . runtime . Log ; 
 @ @ - 25 , 6 + 26 , 7 @ @ import im . actor . runtime . actors . ask . AskRequest ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . box . ActorBox ; 
 import im . actor . runtime . crypto . box . ActorBoxKey ; 
 + import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 
 public class EncryptedPeerActor extends ModuleActor { 
 
 @ @ - 34 , 6 + 36 , 7 @ @ public class EncryptedPeerActor extends ModuleActor { 
 private ArrayList < ApiEncryptionKeyGroup > keyGroups ; 
 private HashMap < Integer , ActorRef > sessions = new HashMap < Integer , ActorRef > ( ) ; 
 private boolean isReady = false ; 
 + private int ownKeyGroupId ; 
 
 public EncryptedPeerActor ( int uid , ModuleContext context ) { 
 super ( context ) ; 
 @ @ - 78 , 14 + 81 , 29 @ @ public class EncryptedPeerActor extends ModuleActor { 
 } 
 } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; 
 } 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKeyGroup ( ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + KeyManagerActor . FetchOwnKeyGroupResult res = ( KeyManagerActor . FetchOwnKeyGroupResult ) obj ; 
 + ownKeyGroupId = res . getKeyGroupId ( ) ; 
 + onOwnKeysReady ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + / / Do nothing 
 + } 
 + } ) ; 
 + } 
 + 
 + private void onOwnKeysReady ( ) { 
 + Log . w ( TAG , " onOwnKeysReady " ) ; 
 isReady = true ; 
 unstashAll ( ) ; 
 } 
 
 private void doEncrypt ( final byte [ ] data , final Future future ) { 
 - 
 Log . d ( TAG , " doEncrypt " ) ; 
 - 
 final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 
 final ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 @ @ - 112 , 19 + 130 , 61 @ @ public class EncryptedPeerActor extends ModuleActor { 
 Log . d ( TAG , " doEncrypt2 " ) ; 
 byte [ ] encData ; 
 try { 
 - encData = ActorBox . closeBox ( new byte [ 0 ] , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 } catch ( IntegrityException e ) { 
 e . printStackTrace ( ) ; 
 future . onError ( e ) ; 
 return ; 
 } 
 
 - EncryptedBox encryptedBox = new EncryptedBox ( encryptedKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , encData ) ; 
 + EncryptedBox encryptedBox = new EncryptedBox ( 
 + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 + 
 + Log . d ( TAG , " doEncrypt : EncPackage : " + Hex . toHex ( encData ) ) ; 
 + for ( EncryptedBoxKey k : encryptedKeys ) { 
 + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 + } 
 + 
 future . onResult ( encryptedBox ) ; 
 } 
 
 - private void doDecrypt ( EncryptedBox data , Future future ) { 
 + private void doDecrypt ( EncryptedBox data , final Future future ) { 
 + int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; 
 + byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; 
 + 
 + if ( sessions . containsKey ( senderKeyGroup ) ) { 
 + Log . d ( TAG , " Decryption with key group " ) ; 
 + byte [ ] encKey = null ; 
 + for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 + if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { 
 + encKey = k . getEncryptedKey ( ) ; 
 + break ; 
 + } 
 + } 
 + 
 + Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; 
 + for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 + Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 + } 
 + 
 + ask ( sessions . get ( senderKeyGroup ) , new EncryptionSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + Log . d ( TAG , " Decryption with key group : onResult " ) ; 
 + future . onResult ( ) ; 
 + } 
 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . d ( TAG , " Decryption with key group : onError " ) ; 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + } else { 
 + Log . w ( TAG , " Unable to find appropriate session # " + senderKeyGroup ) ; 
 + future . onError ( new RuntimeException ( ) ) ; 
 + } 
 } 
 
 @ Override 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 index 7f57506 . . 5d65dd8 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptionSessionActor . java 
 @ @ - 8 , 9 + 8 , 11 @ @ import im . actor . core . api . ApiUserOutPeer ; 
 import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; 
 import im . actor . core . api . rpc . ResponsePublicKeys ; 
 import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . encryption . entity . EncryptedBoxKey ; 
 import im . actor . core . modules . encryption . entity . EncryptionKey ; 
 import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 + import im . actor . core . util . Hex ; 
 import im . actor . core . util . ModuleActor ; 
 import im . actor . core . util . RandomUtils ; 
 import im . actor . runtime . Crypto ; 
 @ @ - 101 , 7 + 103 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { 
 return ; 
 } 
 
 - ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( 0 ) ; 
 + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; 
 onTheirReady0 ( ) ; 
 } 
 @ @ - 169 , 6 + 171 , 7 @ @ public class EncryptionSessionActor extends ModuleActor { 
 ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; 
 
 byte [ ] header = ByteStrings . merge ( 
 + ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , 
 ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 currentOwnKey . getPublicKey ( ) , 
 @ @ - 186 , 9 + 189 , 46 @ @ public class EncryptionSessionActor extends ModuleActor { 
 
 byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; 
 
 + 
 + int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; 
 + long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; 
 + long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; 
 + byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; 
 + byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; 
 + int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; 
 + 
 + Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; 
 + Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 + Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; 
 + 
 + 
 + Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; 
 + Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 + Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 + Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; 
 + 
 future . onResult ( new EncryptedPackageRes ( pkg ) ) ; 
 } 
 
 + private void onDecrypt ( byte [ ] data , Future future ) { 
 + int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 + long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 + long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 + byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 + byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 + int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 + 
 + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 + Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; 
 + Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 + Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 + Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; 
 + 
 + / / future . onResult ( ) ; 
 + } 
 + 
 @ Override 
 public void onReceive ( Object message ) { 
 if ( ! isReady & & message instanceof AskRequest ) { 
 @ @ - 203 , 6 + 243 , 10 @ @ public class EncryptionSessionActor extends ModuleActor { 
 if ( message instanceof EncryptPackage ) { 
 onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; 
 return false ; 
 + } else if ( message instanceof DecryptPackage ) { 
 + DecryptPackage decryptPackage = ( DecryptPackage ) message ; 
 + onDecrypt ( decryptPackage . getData ( ) , future ) ; 
 + return false ; 
 } else { 
 return super . onAsk ( message , future ) ; 
 } 
 @ @ - 232 , 4 + 276 , 17 @ @ public class EncryptionSessionActor extends ModuleActor { 
 return data ; 
 } 
 } 
 + 
 + public static class DecryptPackage { 
 + 
 + private byte [ ] data ; 
 + 
 + public DecryptPackage ( byte [ ] data ) { 
 + this . data = data ; 
 + } 
 + 
 + public byte [ ] getData ( ) { 
 + return data ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index f4eb042 . . 58c2383 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 230 , 6 + 230 , 10 @ @ public class KeyManagerActor extends ModuleActor { 
 future . onResult ( new FetchOwnKeyResult ( privateKeyStorage . getIdentityKey ( ) , ephemeralEncryptionKey . getEncryptionKey ( ) ) ) ; 
 } 
 
 + private void fetchKeyGroup ( Future future ) { 
 + future . onResult ( new FetchOwnKeyGroupResult ( privateKeyStorage . getKeyGroupId ( ) ) ) ; 
 + } 
 + 
 @ Override 
 public void onReceive ( Object message ) { 
 if ( message instanceof AskRequest & & ! isReady ) { 
 @ @ - 244 , 6 + 248 , 9 @ @ public class KeyManagerActor extends ModuleActor { 
 if ( message instanceof FetchOwnKey ) { 
 fetchOwnKey ( future ) ; 
 return false ; 
 + } else if ( message instanceof FetchOwnKeyGroup ) { 
 + fetchKeyGroup ( future ) ; 
 + return false ; 
 } 
 return super . onAsk ( message , future ) ; 
 } 
 @ @ - 270 , 4 + 277 , 20 @ @ public class KeyManagerActor extends ModuleActor { 
 return ephemeralKey ; 
 } 
 } 
 + 
 + public static class FetchOwnKeyGroup { 
 + 
 + } 
 + 
 + public static class FetchOwnKeyGroupResult { 
 + private int keyGroupId ; 
 + 
 + public FetchOwnKeyGroupResult ( int keyGroupId ) { 
 + this . keyGroupId = keyGroupId ; 
 + } 
 + 
 + public int getKeyGroupId ( ) { 
 + return keyGroupId ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java 
 index 815d4ba . . 6d0d54d 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / MessageEncryptionActor . java 
 @ @ - 48 , 6 + 48 , 29 @ @ public class MessageEncryptionActor extends ModuleActor { 
 } ) ; 
 } 
 
 + public void onDecrypt ( int uid , ApiEncryptedMessage message ) { 
 + Log . d ( TAG , " onDecrypt : " + uid ) ; 
 + ArrayList < EncryptedBoxKey > encryptedBoxKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 + for ( ApiEncyptedBoxKey key : message . getBox ( ) . getKeys ( ) ) { 
 + if ( key . getUsersId ( ) = = myUid ( ) ) { 
 + encryptedBoxKeys . add ( new EncryptedBoxKey ( key . getUsersId ( ) , key . getKeyGroupId ( ) , 
 + key . getEncryptedKey ( ) ) ) ; 
 + } 
 + } 
 + EncryptedBox encryptedBox = new EncryptedBox ( encryptedBoxKeys . toArray ( new EncryptedBoxKey [ 0 ] ) , message . getBox ( ) . getEncPackage ( ) ) ; 
 + ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . DecryptPackage ( encryptedBox ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + Log . d ( TAG , " onDecrypt : onResult " ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . d ( TAG , " onDecrypt : onError " ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 @ Override 
 public boolean onAsk ( Object message , Future future ) { 
 if ( message instanceof EncryptMessage ) { 
 @ @ - 58 , 6 + 81 , 16 @ @ public class MessageEncryptionActor extends ModuleActor { 
 return super . onAsk ( message , future ) ; 
 } 
 
 + @ Override 
 + public void onReceive ( Object message ) { 
 + if ( message instanceof InMessage ) { 
 + InMessage inMessage = ( InMessage ) message ; 
 + onDecrypt ( inMessage . senderUid , inMessage . encryptedMessage ) ; 
 + } else { 
 + super . onReceive ( message ) ; 
 + } 
 + } 
 + 
 public static class InMessage { 
 
 private Peer peer ; 
 @ @ - 105 , 4 + 138 , 17 @ @ public class MessageEncryptionActor extends ModuleActor { 
 return encryptedMessage ; 
 } 
 } 
 + 
 + public static class DecryptMessage { 
 + 
 + private ApiEncryptedMessage encryptedMessage ; 
 + 
 + public DecryptMessage ( ApiEncryptedMessage encryptedMessage ) { 
 + this . encryptedMessage = encryptedMessage ; 
 + } 
 + 
 + public ApiEncryptedMessage getEncryptedMessage ( ) { 
 + return encryptedMessage ; 
 + } 
 + } 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java 
 index 9da4c36 . . 8a8877a 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / updates / MessagesProcessor . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import im . actor . core . entity . content . AbsContent ; 
 import im . actor . core . entity . content . ServiceUserRegistered ; 
 import im . actor . core . modules . AbsModule ; 
 import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . encryption . MessageEncryptionActor ; 
 import im . actor . core . modules . internal . messages . ConversationActor ; 
 import im . actor . core . modules . internal . messages . ConversationHistoryActor ; 
 import im . actor . core . modules . internal . messages . CursorReceiverActor ; 
 @ @ - 53 , 11 + 54 , 13 @ @ public class MessagesProcessor extends AbsModule { 
 long intMessageSortDate = 0 ; 
 Peer peer = convert ( _ peer ) ; 
 
 - ArrayList < Message > nMesages = new ArrayList < Message > ( ) ; 
 + ArrayList < Message > nMessages = new ArrayList < Message > ( ) ; 
 for ( UpdateMessage u : messages ) { 
 
 if ( u . getMessage ( ) instanceof ApiEncryptedMessage ) { 
 - / / TODO : Decrypt message 
 + / / TODO : Proper decrypt message 
 + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , 
 + u . getDate ( ) , u . getSenderUid ( ) , u . getRid ( ) , ( ApiEncryptedMessage ) u . getMessage ( ) ) ) ; 
 continue ; 
 } 
 
 @ @ - 72 , 7 + 75 , 7 @ @ public class MessagesProcessor extends AbsModule { 
 boolean isOut = myUid ( ) = = u . getSenderUid ( ) ; 
 
 / / Sending message to conversation 
 - nMesages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , 
 + nMessages . add ( new Message ( u . getRid ( ) , u . getDate ( ) , u . getDate ( ) , u . getSenderUid ( ) , 
 isOut ? MessageState . SENT : MessageState . UNKNOWN , msgContent , 
 new ArrayList < Reaction > ( ) ) ) ; 
 
 @ @ - 84 , 7 + 87 , 7 @ @ public class MessagesProcessor extends AbsModule { 
 } 
 } 
 
 - conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMesages ) ) ; 
 + conversationActor ( peer ) . send ( new ConversationActor . Messages ( nMessages ) ) ; 
 
 if ( intMessageSortDate > 0 ) { 
 plainReceiveActor ( ) . send ( new CursorReceiverActor . MarkReceived ( peer , intMessageSortDate ) ) ; 
 @ @ - 95 , 7 + 98 , 7 @ @ public class MessagesProcessor extends AbsModule { 
 } 
 
 / / OwnReadActor 
 - for ( Message m : nMesages ) { 
 + for ( Message m : nMessages ) { 
 if ( m . getSenderId ( ) ! = myUid ( ) ) { 
 ownReadActor ( ) . send ( new OwnReadActor . InMessage ( peer , m ) ) ; 
 } 
 @ @ - 107 , 6 + 110 , 13 @ @ public class MessagesProcessor extends AbsModule { 
 ApiMessage content ) { 
 
 Peer peer = convert ( _ peer ) ; 
 + 
 + if ( content instanceof ApiEncryptedMessage ) { 
 + / / TODO : Proper decrypt message 
 + context ( ) . getEncryption ( ) . getMessageEncryptor ( ) . send ( new MessageEncryptionActor . InMessage ( peer , 
 + date , senderUid , rid , ( ApiEncryptedMessage ) content ) ) ; 
 + } 
 + 
 AbsContent msgContent ; 
 try { 
 msgContent = AbsContent . fromMessage ( content ) ; 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 index 7ff7e50 . . e4aff27 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 @ @ - 22 , 7 + 22 , 7 @ @ public class ByteStrings { 
 } 
 
 public static byte [ ] intToBytes ( int v ) { 
 - byte [ ] data = new byte [ 8 ] ; 
 + byte [ ] data = new byte [ 4 ] ; 
 int offset = 0 ; 
 data [ offset + + ] = ( byte ) ( ( v > > 24 ) & 0xFF ) ; 
 data [ offset + + ] = ( byte ) ( ( v > > 16 ) & 0xFF ) ;
