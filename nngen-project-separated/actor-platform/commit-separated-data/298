BLEU SCORE: 0.09614956805006118

TEST MSG: tests ( server ) : reads tests
GENERATED MSG: fix ( server : core ) : kinda stress test fo reads

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index c091d83 . . e9aeb05 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 67 , 7 + 67 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > isFat : Boolean = false , < nl > forUserId : Option [ UserId ] = None < nl > ) : Future [ SeqStateDate ] = < nl > - withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , failed = FastFuture . successful ( SeqStateDate ( ) ) ) { < nl > / / we don ' t set date here , cause actual date set inside dialog processor < nl > val sendMessage = SendMessage ( < nl > origin = Some ( Peer . privat ( senderUserId ) ) , < nl > @ @ - 94 , 7 + 94 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > randomId : Long , < nl > message : ApiMessage < nl > ) : Future [ Unit ] = < nl > - withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , failed = FastFuture . successful ( ( ) ) ) { < nl > for { < nl > memberIds ← fetchMemberIds ( DialogId ( peer . asModel , senderUserId ) ) < nl > _ ← Future . sequence ( memberIds map ( writeMessageSelf ( _ , peer , senderUserId , new DateTime ( date . toEpochMilli ) , randomId , message ) ) ) < nl > @ @ - 109 , 7 + 109 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > randomId : Long , < nl > message : ApiMessage < nl > ) : Future [ Unit ] = < nl > - withValidPeer ( Peer . privat ( userId ) , peer . id , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( Peer . privat ( userId ) , peer . id , failed = FastFuture . successful ( ( ) ) ) { < nl > ( userExt . processorRegion . ref ? < nl > envelope ( Peer . privat ( userId ) , DialogEnvelope ( ) . withWriteMessageSelf ( WriteMessageSelf ( < nl > dest = Some ( peer . asModel ) , < nl > @ @ - 121 , 7 + 121 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > } < nl > < nl > def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , receiverUserId , failed = FastFuture . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val receiver = Peer . privat ( receiverUserId ) < nl > val messageReceived = MessageReceived ( Some ( receiver ) , Some ( peer . asModel ) , date , now ) < nl > @ @ - 134 , 7 + 134 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > < nl > def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , readerUserId , failed = FastFuture . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val reader = Peer . privat ( readerUserId ) < nl > val messageRead = MessageRead ( Some ( reader ) , Some ( peer . asModel ) , readerAuthSid , date , now ) < nl > @ @ - 147 , 28 + 147 , 28 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > < nl > def unarchive ( userId : Int , peer : Peer , clientAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = < nl > - withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + withValidPeer ( peer , userId , failed = Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > ( userExt . processorRegion . ref ? < nl > UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withUnarchive ( DialogRootCommands . Unarchive ( Some ( peer ) , clientAuthSid map ( Int32Value ( _ ) ) ) ) ) ) < nl > . mapTo [ SeqState ] < nl > } < nl > < nl > def archive ( userId : Int , peer : Peer , clientAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = < nl > - withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + withValidPeer ( peer , userId , failed = Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > ( userExt . processorRegion . ref ? < nl > UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withArchive ( DialogRootCommands . Archive ( Some ( peer ) , clientAuthSid map ( Int32Value ( _ ) ) ) ) ) ) < nl > . mapTo [ SeqState ] < nl > } < nl > < nl > def favourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + withValidPeer ( peer , userId , failed = Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > ( userExt . processorRegion . ref ? < nl > UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withFavourite ( DialogRootCommands . Favourite ( Some ( peer ) ) ) ) ) < nl > . mapTo [ SeqState ] < nl > } < nl > < nl > def unfavourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + withValidPeer ( peer , userId , failed = Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > ( userExt . processorRegion . ref ? < nl > UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withUnfavourite ( DialogRootCommands . Unfavourite ( Some ( peer ) ) ) ) ) < nl > . mapTo [ SeqState ] < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > index e09722c . . 717d43b 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > @ @ - 30 , 7 + 30 , 9 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > < nl > it should " not allow time out when there are highly frequent messages " in noTimeout ( ) < nl > < nl > - it should " keep UpdateReadByMe in right order in difference " in readsProduceGoodSequence ( ) < nl > + it should " keep UpdateReadByMe in right order in difference , single reads " in readsProduceGoodSequence ( ) < nl > + < nl > + it should " keep UpdateReadByMe in right order in difference , double reads " in doubleReadsProduceGoodSequence ( ) < nl > < nl > it should " not allow duplicated timestamp in messages " in uniqueTimestamp ( ) < nl > < nl > @ @ - 116 , 7 + 118 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > def readsProduceGoodSequence ( ) = { < nl > val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > - val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) < nl > + val ( eve , _ , _ , _ ) = createUser ( ) < nl > < nl > val aliceCd = ClientData ( aliceAuthId , 3L , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) < nl > val bobCd = ClientData ( bobAuthId , 3L , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > @ @ - 141 , 20 + 143 , 19 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > } < nl > < nl > / / Bob reads 100 messages in random order , repeats requests , etc < nl > - < nl > val ( reads , expectedSize ) = { < nl > implicit val cd = bobCd < nl > < nl > - / / 20 messages - read in original order < nl > + / / 25 messages - read in original order < nl > val dates1 = dates . slice ( 0 , 25 ) < nl > val bobReads1 = dates1 map { date ⇒ < nl > / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) < nl > messService . handleMessageRead ( groupOutPeer , date ) < nl > } < nl > - / / these reads should produce 20 UpdateReadByMe < nl > + / / these reads should produce 25 UpdateReadByMe < nl > val expectedUpdatesCount1 = dates1 . length < nl > < nl > - / / 20 messages - read in random order < nl > + / / 25 messages - read in random order < nl > val dates2 = Random . shuffle ( dates . slice ( 25 , 50 ) ) < nl > val bobReads2 = dates2 map { date ⇒ < nl > / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) < nl > @ @ - 167 , 7 + 168 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > case ( _ , acc ) ⇒ acc < nl > } . length < nl > < nl > - / / 20 messages - read in reverse order < nl > + / / 25 messages - read in reverse order < nl > val bobReads3 = dates . slice ( 50 , 75 ) . reverse map { date ⇒ < nl > / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) < nl > messService . handleMessageRead ( groupOutPeer , date ) < nl > @ @ - 175 , 7 + 176 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > / / these reads should produce only one UpdateReadByMe , cause dates are descending < nl > val expectedUpdatesCount3 = 1 < nl > < nl > - / / 20 messages - read in original order , repeat each read multiple times < nl > + / / 25 messages - read in original order , repeat each read multiple times < nl > val dates4 = dates . slice ( 75 , 100 ) < nl > val bobReads4 = dates4 flatMap { date ⇒ < nl > val upperBound = Random . nextInt ( 10 ) + 1 < nl > @ @ - 184 , 7 + 185 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) < nl > } < nl > } < nl > - / / these reads should not repeat UpdateReadByMe with same startDate , thus - 20 updates < nl > + / / these reads should not repeat UpdateReadByMe with same startDate , thus - 25 updates < nl > val expectedUpdatesCount4 = dates4 . length < nl > < nl > ( < nl > @ @ - 197 , 12 + 198 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > < nl > / / this is not how we get exact difference , this is how we store it in database < nl > whenReady ( db . run ( UserSequenceRepo . fetchAfterSeq ( bob . id , 0 , Long . MaxValue ) ) ) { updates ⇒ < nl > - val readsByMe = updates flatMap { seq ⇒ < nl > - val upd = seq . getMapping . getDefault < nl > - if ( upd . header = = UpdateMessageReadByMe . header ) { < nl > - Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption map ( upd ⇒ ( seq . seq , seq . timestamp , upd ) ) < nl > - } else None < nl > - } < nl > + val readsByMe = extractUpdateMessageReadByMe ( updates ) < nl > < nl > readsByMe should have length expectedSize . toLong < nl > < nl > @ @ - 231 , 6 + 227 , 173 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > } < nl > } < nl > < nl > + def doubleReadsProduceGoodSequence ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) < nl > + < nl > + val aliceCd = ClientData ( aliceAuthId , 3L , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) < nl > + val bobCd = ClientData ( bobAuthId , 3L , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > + val eveCd = ClientData ( eveAuthId , 3L , Some ( AuthData ( eve . id , eveAuthSid , 42 ) ) ) < nl > + < nl > + / / Alice creates group < nl > + val groupOutPeer = { < nl > + implicit val cd = aliceCd < nl > + val g = createGroup ( " Group to test differnece " , Set ( bob . id , eve . id ) ) . groupPeer < nl > + ApiOutPeer ( ApiPeerType . Group , g . groupId , g . accessHash ) < nl > + } < nl > + val groupPeer = ApiPeer ( ApiPeerType . Group , groupOutPeer . id ) < nl > + < nl > + / / Alice sends 100 messages < nl > + val aliceRids = ( 1 to 100 ) map { i ⇒ < nl > + implicit val cd = aliceCd < nl > + val rid = ACLUtils . randomLong ( ) < nl > + dialogExt . sendMessage ( groupPeer , alice . id , aliceAuthSid , Some ( aliceAuthId ) , rid , textMessage ( s " Hello from Alice # $ i " ) ) map ( _ ⇒ rid ) < nl > + } map ( e ⇒ whenReady ( e ) ( identity ) ) < nl > + < nl > + val messageDates = whenReady ( db . run ( HistoryMessageRepo . find ( alice . id , groupPeer . asModel , aliceRids . toSet ) ) ) { messages ⇒ < nl > + ( messages map ( _ . date . getMillis ) ) . sorted < nl > + } < nl > + < nl > + val ( reads , bobsUpdatesCount , evesUpdatesCount ) = { < nl > + < nl > + / / Eve reads 50 messages in random order < nl > + val ( reads1 , eveUpdatesCount1 ) = { < nl > + implicit val cd = eveCd < nl > + < nl > + val dates = Random . shuffle ( messageDates . slice ( 0 , 50 ) ) < nl > + val reads = dates map { date ⇒ < nl > + messService . handleMessageRead ( groupOutPeer , date ) < nl > + } < nl > + / / these reads should produce UpdateReadByMe only with ascending dates < nl > + val count = ( dates . reverse foldRight List . empty [ Long ] ) { < nl > + case ( el , Nil ) ⇒ List ( el ) < nl > + case ( el , acc @ h : : t ) if h < el ⇒ el : : acc < nl > + case ( _ , acc ) ⇒ acc < nl > + } . length < nl > + reads → count < nl > + } < nl > + < nl > + / / Bob reads 50 messages in original order < nl > + val ( reads2 , bobUpdatesCount1 ) = { < nl > + implicit val cd = bobCd < nl > + < nl > + val dates = messageDates . slice ( 0 , 50 ) < nl > + val reads = dates map { date ⇒ < nl > + messService . handleMessageRead ( groupOutPeer , date ) < nl > + } < nl > + / / these reads should produce 50 UpdateReadByMe < nl > + val count = dates . length < nl > + reads → count < nl > + } < nl > + < nl > + / / Eve reads 50 messages in reverse order < nl > + val ( reads3 , eveUpdatesCount2 ) = { < nl > + implicit val cd = eveCd < nl > + < nl > + val reads = messageDates . slice ( 50 , 100 ) . reverse map { date ⇒ < nl > + messService . handleMessageRead ( groupOutPeer , date ) < nl > + } < nl > + / / these reads should produce only one UpdateReadByMe , cause dates are descending < nl > + val count = 1 < nl > + reads → count < nl > + } < nl > + < nl > + / / Bob reads 50 messages in original order , repeat each read multiple times < nl > + val ( reads4 , bobUpdatesCount2 ) = { < nl > + implicit val cd = bobCd < nl > + < nl > + val dates = messageDates . slice ( 50 , 100 ) < nl > + val reads = dates flatMap { date ⇒ < nl > + val upperBound = Random . nextInt ( 10 ) + 1 < nl > + 1 to upperBound map { _ ⇒ < nl > + messService . handleMessageRead ( groupOutPeer , date ) < nl > + } < nl > + } < nl > + / / these reads should not repeat UpdateReadByMe with same startDate , thus - 25 updates < nl > + val count = dates . length < nl > + reads → count < nl > + } < nl > + < nl > + ( < nl > + reads1 + + reads2 + + reads3 + + reads4 , < nl > + bobUpdatesCount1 + bobUpdatesCount2 , < nl > + eveUpdatesCount1 + eveUpdatesCount2 < nl > + ) < nl > + } < nl > + < nl > + reads foreach { whenReady ( _ ) ( identity ) } < nl > + < nl > + / / Checking Bob ' s difference < nl > + / / this is not how we get exact difference , this is how we store it in database < nl > + whenReady ( db . run ( UserSequenceRepo . fetchAfterSeq ( bob . id , 0 , Long . MaxValue ) ) ) { updates ⇒ < nl > + val readsByMe = extractUpdateMessageReadByMe ( updates ) < nl > + < nl > + readsByMe should have length bobsUpdatesCount . toLong < nl > + < nl > + readsByMe foreach { e ⇒ println ( s " = = = = = = = = = = = = : $ { e } " ) } < nl > + < nl > + readsByMe . zip ( readsByMe . tail ) foreach { < nl > + case ( ( fSeq , fTs , fUpd ) , ( sSeq , sTs , sUpd ) ) ⇒ < nl > + assert ( fUpd . startDate < sUpd . startDate , " Update start dates are not ascending " ) < nl > + assert ( fSeq < sSeq , " Seqs are not ascending " ) < nl > + assert ( fTs < = sTs , " Seq update timestamps are not ascending " ) < nl > + assert ( fUpd . unreadCounter . get > sUpd . unreadCounter . get , " Counters are not descending " ) < nl > + } < nl > + } < nl > + < nl > + / / UpdateMessageReadByMe should be reduces in final difference < nl > + whenReady ( seqExt . getDifference ( bob . id , 0 , bobAuthSid , Long . MaxValue ) ) { < nl > + case ( diff , _ ) ⇒ < nl > + val readsByMe = diff flatMap { seq ⇒ < nl > + val upd = seq . getMapping . getDefault < nl > + if ( upd . header = = UpdateMessageReadByMe . header ) { < nl > + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption < nl > + } else None < nl > + } < nl > + readsByMe should have length 1L < nl > + readsByMe . head shouldEqual UpdateMessageReadByMe ( groupPeer , messageDates . last , Some ( 0 ) ) < nl > + } < nl > + < nl > + / / Checking Eve ' s difference < nl > + / / this is not how we get exact difference , this is how we store it in database < nl > + whenReady ( db . run ( UserSequenceRepo . fetchAfterSeq ( eve . id , 0 , Long . MaxValue ) ) ) { updates ⇒ < nl > + val readsByMe = extractUpdateMessageReadByMe ( updates ) < nl > + < nl > + readsByMe should have length evesUpdatesCount . toLong < nl > + < nl > + readsByMe . zip ( readsByMe . tail ) foreach { < nl > + case ( ( fSeq , fTs , fUpd ) , ( sSeq , sTs , sUpd ) ) ⇒ < nl > + assert ( fUpd . startDate < sUpd . startDate , " Update start dates are not ascending " ) < nl > + assert ( fSeq < sSeq , " Seqs are not ascending " ) < nl > + assert ( fTs < = sTs , " Seq update timestamps are not ascending " ) < nl > + assert ( fUpd . unreadCounter . get > sUpd . unreadCounter . get , " Counters are not descending " ) < nl > + } < nl > + } < nl > + < nl > + / / UpdateMessageReadByMe should be reduces in final difference < nl > + whenReady ( seqExt . getDifference ( eve . id , 0 , eveAuthSid , Long . MaxValue ) ) { < nl > + case ( diff , _ ) ⇒ < nl > + val readsByMe = diff flatMap { seq ⇒ < nl > + val upd = seq . getMapping . getDefault < nl > + if ( upd . header = = UpdateMessageReadByMe . header ) { < nl > + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption < nl > + } else None < nl > + } < nl > + readsByMe should have length 1L < nl > + readsByMe . head shouldEqual UpdateMessageReadByMe ( groupPeer , messageDates . last , Some ( 0 ) ) < nl > + } < nl > + < nl > + } < nl > + < nl > + private def extractUpdateMessageReadByMe ( updates : Seq [ SeqUpdate ] ) : Seq [ ( Int , Long , UpdateMessageReadByMe ) ] = < nl > + updates flatMap { seq ⇒ < nl > + val upd = seq . getMapping . getDefault < nl > + if ( upd . header = = UpdateMessageReadByMe . header ) { < nl > + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption map ( upd ⇒ ( seq . seq , seq . timestamp , upd ) ) < nl > + } else None < nl > + } < nl > + < nl > def uniqueTimestamp ( ) = { < nl > val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( )
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 8c6fabd . . 9464470 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 139 , 14 + 139 , 16 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { < nl > log . debug ( s " mustRead is $ { mustRead } " ) < nl > < nl > if ( mustRead ) { < nl > - persistAsync ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . getOrigin . id ) ) { e ⇒ < nl > + / / can ' t use persistAsync here , cause more reads can occur , < nl > + / / and state will be inconsistent by the time handler is excuted . < nl > + persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . getOrigin . id ) ) { e ⇒ < nl > log . debug ( s " persisted MessagesRead , origin = $ { mr . getOrigin . id } , date = $ { Instant . ofEpochMilli ( mr . date ) } , counter = $ { state . counter } , unreadMessages = $ { state . unreadMessages } " ) < nl > - commit ( e ) < nl > - log . debug ( s " after commit : counter = $ { state . counter } , unreadMessages = $ { state . unreadMessages } " ) < nl > + val newState = commit ( e ) < nl > + log . debug ( s " after commit : counter = $ { newState . counter } , unreadMessages = $ { newState . unreadMessages } " ) < nl > < nl > ( for { < nl > _ ← dialogExt . ackMessageRead ( peer , mr ) < nl > - _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , state . counter ) < nl > + _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , newState . counter ) < nl > _ = deliveryExt . sendCountersUpdate ( userId ) < nl > } yield MessageReadAck ( ) ) pipeTo sender ( ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala < nl > index 89ca08f . . 0b95c88 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala < nl > @ @ - 47 , 7 + 47 , 7 @ @ private [ dialog ] object DialogState { < nl > < nl > private [ dialog ] final case class DialogState ( < nl > userId : Int , < nl > - lastMessageDate : Instant , / / we don ' t use it now anywhere . should we remove it ? < nl > + lastMessageDate : Instant , < nl > lastOwnerReceiveDate : Instant , < nl > lastReceiveDate : Instant , < nl > lastOwnerReadDate : Instant , < nl > @ @ - 85 , 13 + 85 , 13 @ @ private [ dialog ] final case class DialogState ( < nl > lastOwnerReadDate = date < nl > ) < nl > case MessagesRead ( date , readerUserId ) if readerUserId ! = userId ⇒ < nl > - if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReadDate ) | | date = = lastReadDate ) ) < nl > + if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReadDate ) | | date = = lastReadDate ) ) / / what ' s a point of creating state with same lastReadDate ( last condition ) < nl > this . copy ( lastReadDate = date ) < nl > else this < nl > case MessagesReceived ( date , receiverUserId ) if receiverUserId = = userId ⇒ < nl > this . copy ( lastOwnerReceiveDate = date ) < nl > case MessagesReceived ( date , receiverUserId ) if receiverUserId ! = userId ⇒ < nl > - if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReceiveDate ) | | date = = lastReceiveDate ) ) < nl > + if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReceiveDate ) | | date = = lastReceiveDate ) ) / / what ' s a point of creating state with same lastReadDate ( last condition ) < nl > this . copy ( lastReceiveDate = date ) < nl > else this < nl > case SetCounter ( newCounter ) ⇒ < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala < nl > index 2d0e325 . . 07c49a8 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala < nl > @ @ - 33 , 9 + 33 , 7 @ @ final class IntegrationsServiceSpec < nl > < nl > implicit val ec = system . dispatcher < nl > < nl > - val groupInviteConfig = GroupInviteConfig ( " https : / / actor . im " ) < nl > - < nl > - implicit val groupsService = new GroupsServiceImpl ( groupInviteConfig ) < nl > + implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " https : / / actor . im " ) ) < nl > < nl > private val config = HttpApiConfig ( " localhost " , 9000 , " http : / / actor . im " , " / dev / null " , None ) < nl > val service = new IntegrationsServiceImpl ( config . baseUri ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > index 08ff9ff . . e09722c 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > @ @ - 1 , 21 + 1 , 28 @ @ < nl > package im . actor . server . dialog < nl > < nl > + import cats . data . Xor < nl > import im . actor . api . rpc . messaging . _ < nl > - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeer , ApiPeerType } < nl > import im . actor . api . rpc . { AuthData , ClientData , Ok , PeersImplicits } < nl > import im . actor . server . _ < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > - import im . actor . server . sequence . SeqStateDate < nl > + import im . actor . server . model . SeqUpdate < nl > + import im . actor . server . persist . HistoryMessageRepo < nl > + import im . actor . server . persist . sequence . UserSequenceRepo < nl > + import im . actor . server . sequence . { SeqStateDate , SeqUpdatesExtension } < nl > < nl > import scala . concurrent . Future < nl > import scala . language . postfixOps < nl > + import scala . util . Random < nl > < nl > final class DialogProcessorSpec extends BaseAppSuite < nl > with ImplicitAuthService < nl > with ImplicitSessionRegion < nl > with PeersImplicits < nl > - with MessageParsing { < nl > + with MessageParsing < nl > + with GroupsServiceHelpers { < nl > < nl > behavior of " Dialog Processor " < nl > < nl > @ @ - 23 , 9 + 30 , 13 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > < nl > it should " not allow time out when there are highly frequent messages " in noTimeout ( ) < nl > < nl > + it should " keep UpdateReadByMe in right order in difference " in readsProduceGoodSequence ( ) < nl > + < nl > it should " not allow duplicated timestamp in messages " in uniqueTimestamp ( ) < nl > < nl > - private val messService = MessagingServiceImpl ( ) < nl > + private implicit val messService = MessagingServiceImpl ( ) < nl > + private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " https : / / actor . im " ) ) < nl > + private val seqExt = SeqUpdatesExtension ( system ) < nl > < nl > def passReads ( ) = { < nl > val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > @ @ - 102 , 6 + 113 , 124 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > < nl > } < nl > < nl > + def readsProduceGoodSequence ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) < nl > + < nl > + val aliceCd = ClientData ( aliceAuthId , 3L , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) < nl > + val bobCd = ClientData ( bobAuthId , 3L , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > + < nl > + / / Alice creates group < nl > + val groupOutPeer = { < nl > + implicit val cd = aliceCd < nl > + val g = createGroup ( " Group to test differnece " , Set ( bob . id , eve . id ) ) . groupPeer < nl > + ApiOutPeer ( ApiPeerType . Group , g . groupId , g . accessHash ) < nl > + } < nl > + val groupPeer = ApiPeer ( ApiPeerType . Group , groupOutPeer . id ) < nl > + < nl > + / / Alice sends 100 messages < nl > + val aliceRids = ( 1 to 100 ) map { i ⇒ < nl > + implicit val cd = aliceCd < nl > + val rid = ACLUtils . randomLong ( ) < nl > + dialogExt . sendMessage ( groupPeer , alice . id , aliceAuthSid , Some ( aliceAuthId ) , rid , textMessage ( s " Hello from Alice # $ i " ) ) map ( _ ⇒ rid ) < nl > + } map ( e ⇒ whenReady ( e ) ( identity ) ) < nl > + < nl > + val dates = whenReady ( db . run ( HistoryMessageRepo . find ( alice . id , groupPeer . asModel , aliceRids . toSet ) ) ) { messages ⇒ < nl > + ( messages map ( _ . date . getMillis ) ) . sorted < nl > + } < nl > + < nl > + / / Bob reads 100 messages in random order , repeats requests , etc < nl > + < nl > + val ( reads , expectedSize ) = { < nl > + implicit val cd = bobCd < nl > + < nl > + / / 20 messages - read in original order < nl > + val dates1 = dates . slice ( 0 , 25 ) < nl > + val bobReads1 = dates1 map { date ⇒ < nl > + / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) < nl > + messService . handleMessageRead ( groupOutPeer , date ) < nl > + } < nl > + / / these reads should produce 20 UpdateReadByMe < nl > + val expectedUpdatesCount1 = dates1 . length < nl > + < nl > + / / 20 messages - read in random order < nl > + val dates2 = Random . shuffle ( dates . slice ( 25 , 50 ) ) < nl > + val bobReads2 = dates2 map { date ⇒ < nl > + / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) < nl > + messService . handleMessageRead ( groupOutPeer , date ) < nl > + } < nl > + / / these reads should produce UpdateReadByMe only with ascending dates < nl > + val expectedUpdatesCount2 = ( dates2 . reverse foldRight List . empty [ Long ] ) { < nl > + case ( el , Nil ) ⇒ List ( el ) < nl > + case ( el , acc @ h : : t ) if h < el ⇒ el : : acc < nl > + case ( _ , acc ) ⇒ acc < nl > + } . length < nl > + < nl > + / / 20 messages - read in reverse order < nl > + val bobReads3 = dates . slice ( 50 , 75 ) . reverse map { date ⇒ < nl > + / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) < nl > + messService . handleMessageRead ( groupOutPeer , date ) < nl > + } < nl > + / / these reads should produce only one UpdateReadByMe , cause dates are descending < nl > + val expectedUpdatesCount3 = 1 < nl > + < nl > + / / 20 messages - read in original order , repeat each read multiple times < nl > + val dates4 = dates . slice ( 75 , 100 ) < nl > + val bobReads4 = dates4 flatMap { date ⇒ < nl > + val upperBound = Random . nextInt ( 10 ) + 1 < nl > + 1 to upperBound map { _ ⇒ < nl > + messService . handleMessageRead ( groupOutPeer , date ) < nl > + / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) < nl > + } < nl > + } < nl > + / / these reads should not repeat UpdateReadByMe with same startDate , thus - 20 updates < nl > + val expectedUpdatesCount4 = dates4 . length < nl > + < nl > + ( < nl > + bobReads1 + + bobReads2 + + bobReads3 + + bobReads4 , < nl > + expectedUpdatesCount1 + expectedUpdatesCount2 + expectedUpdatesCount3 + expectedUpdatesCount4 < nl > + ) < nl > + } < nl > + < nl > + reads foreach { whenReady ( _ ) ( identity ) } < nl > + < nl > + / / this is not how we get exact difference , this is how we store it in database < nl > + whenReady ( db . run ( UserSequenceRepo . fetchAfterSeq ( bob . id , 0 , Long . MaxValue ) ) ) { updates ⇒ < nl > + val readsByMe = updates flatMap { seq ⇒ < nl > + val upd = seq . getMapping . getDefault < nl > + if ( upd . header = = UpdateMessageReadByMe . header ) { < nl > + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption map ( upd ⇒ ( seq . seq , seq . timestamp , upd ) ) < nl > + } else None < nl > + } < nl > + < nl > + readsByMe should have length expectedSize . toLong < nl > + < nl > + readsByMe . zip ( readsByMe . tail ) foreach { < nl > + case ( ( fSeq , fTs , fUpd ) , ( sSeq , sTs , sUpd ) ) ⇒ < nl > + assert ( fUpd . startDate < sUpd . startDate , " Update start dates are not ascending " ) < nl > + assert ( fSeq < sSeq , " Seqs are not ascending " ) < nl > + assert ( fTs < = sTs , " Seq update timestamps are not ascending " ) < nl > + assert ( fUpd . unreadCounter . get > sUpd . unreadCounter . get , " Counters are not descending " ) < nl > + } < nl > + readsByMe . head . _ 3 . unreadCounter . get shouldEqual 99 < nl > + readsByMe . last . _ 3 . unreadCounter . get shouldEqual 0 < nl > + } < nl > + < nl > + / / UpdateMessageReadByMe should be reduces in final difference < nl > + whenReady ( seqExt . getDifference ( bob . id , 0 , bobAuthSid , Long . MaxValue ) ) { < nl > + case ( diff , _ ) ⇒ < nl > + val readsByMe = diff flatMap { seq ⇒ < nl > + val upd = seq . getMapping . getDefault < nl > + if ( upd . header = = UpdateMessageReadByMe . header ) { < nl > + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption < nl > + } else None < nl > + } < nl > + readsByMe should have length 1L < nl > + readsByMe . head shouldEqual UpdateMessageReadByMe ( groupPeer , dates . last , Some ( 0 ) ) < nl > + } < nl > + } < nl > + < nl > def uniqueTimestamp ( ) = { < nl > val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index c091d83 . . e9aeb05 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 67 , 7 + 67 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 isFat : Boolean = false , 
 forUserId : Option [ UserId ] = None 
 ) : Future [ SeqStateDate ] = 
 - withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , failed = FastFuture . successful ( SeqStateDate ( ) ) ) { 
 / / we don ' t set date here , cause actual date set inside dialog processor 
 val sendMessage = SendMessage ( 
 origin = Some ( Peer . privat ( senderUserId ) ) , 
 @ @ - 94 , 7 + 94 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 randomId : Long , 
 message : ApiMessage 
 ) : Future [ Unit ] = 
 - withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , failed = FastFuture . successful ( ( ) ) ) { 
 for { 
 memberIds ← fetchMemberIds ( DialogId ( peer . asModel , senderUserId ) ) 
 _ ← Future . sequence ( memberIds map ( writeMessageSelf ( _ , peer , senderUserId , new DateTime ( date . toEpochMilli ) , randomId , message ) ) ) 
 @ @ - 109 , 7 + 109 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 randomId : Long , 
 message : ApiMessage 
 ) : Future [ Unit ] = 
 - withValidPeer ( Peer . privat ( userId ) , peer . id , Future . successful ( ( ) ) ) { 
 + withValidPeer ( Peer . privat ( userId ) , peer . id , failed = FastFuture . successful ( ( ) ) ) { 
 ( userExt . processorRegion . ref ? 
 envelope ( Peer . privat ( userId ) , DialogEnvelope ( ) . withWriteMessageSelf ( WriteMessageSelf ( 
 dest = Some ( peer . asModel ) , 
 @ @ - 121 , 7 + 121 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 } 
 
 def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , receiverUserId , failed = FastFuture . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val receiver = Peer . privat ( receiverUserId ) 
 val messageReceived = MessageReceived ( Some ( receiver ) , Some ( peer . asModel ) , date , now ) 
 @ @ - 134 , 7 + 134 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 
 def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , readerUserId , failed = FastFuture . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val reader = Peer . privat ( readerUserId ) 
 val messageRead = MessageRead ( Some ( reader ) , Some ( peer . asModel ) , readerAuthSid , date , now ) 
 @ @ - 147 , 28 + 147 , 28 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 
 def unarchive ( userId : Int , peer : Peer , clientAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = 
 - withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + withValidPeer ( peer , userId , failed = Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 ( userExt . processorRegion . ref ? 
 UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withUnarchive ( DialogRootCommands . Unarchive ( Some ( peer ) , clientAuthSid map ( Int32Value ( _ ) ) ) ) ) ) 
 . mapTo [ SeqState ] 
 } 
 
 def archive ( userId : Int , peer : Peer , clientAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = 
 - withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + withValidPeer ( peer , userId , failed = Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 ( userExt . processorRegion . ref ? 
 UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withArchive ( DialogRootCommands . Archive ( Some ( peer ) , clientAuthSid map ( Int32Value ( _ ) ) ) ) ) ) 
 . mapTo [ SeqState ] 
 } 
 
 def favourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + withValidPeer ( peer , userId , failed = Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 ( userExt . processorRegion . ref ? 
 UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withFavourite ( DialogRootCommands . Favourite ( Some ( peer ) ) ) ) ) 
 . mapTo [ SeqState ] 
 } 
 
 def unfavourite ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + withValidPeer ( peer , userId , failed = Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 ( userExt . processorRegion . ref ? 
 UserEnvelope ( userId ) . withDialogRootEnvelope ( DialogRootEnvelope ( ) . withUnfavourite ( DialogRootCommands . Unfavourite ( Some ( peer ) ) ) ) ) 
 . mapTo [ SeqState ] 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 index e09722c . . 717d43b 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 @ @ - 30 , 7 + 30 , 9 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 
 it should " not allow time out when there are highly frequent messages " in noTimeout ( ) 
 
 - it should " keep UpdateReadByMe in right order in difference " in readsProduceGoodSequence ( ) 
 + it should " keep UpdateReadByMe in right order in difference , single reads " in readsProduceGoodSequence ( ) 
 + 
 + it should " keep UpdateReadByMe in right order in difference , double reads " in doubleReadsProduceGoodSequence ( ) 
 
 it should " not allow duplicated timestamp in messages " in uniqueTimestamp ( ) 
 
 @ @ - 116 , 7 + 118 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 def readsProduceGoodSequence ( ) = { 
 val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 - val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) 
 + val ( eve , _ , _ , _ ) = createUser ( ) 
 
 val aliceCd = ClientData ( aliceAuthId , 3L , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) 
 val bobCd = ClientData ( bobAuthId , 3L , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 @ @ - 141 , 20 + 143 , 19 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 } 
 
 / / Bob reads 100 messages in random order , repeats requests , etc 
 - 
 val ( reads , expectedSize ) = { 
 implicit val cd = bobCd 
 
 - / / 20 messages - read in original order 
 + / / 25 messages - read in original order 
 val dates1 = dates . slice ( 0 , 25 ) 
 val bobReads1 = dates1 map { date ⇒ 
 / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) 
 messService . handleMessageRead ( groupOutPeer , date ) 
 } 
 - / / these reads should produce 20 UpdateReadByMe 
 + / / these reads should produce 25 UpdateReadByMe 
 val expectedUpdatesCount1 = dates1 . length 
 
 - / / 20 messages - read in random order 
 + / / 25 messages - read in random order 
 val dates2 = Random . shuffle ( dates . slice ( 25 , 50 ) ) 
 val bobReads2 = dates2 map { date ⇒ 
 / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) 
 @ @ - 167 , 7 + 168 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 case ( _ , acc ) ⇒ acc 
 } . length 
 
 - / / 20 messages - read in reverse order 
 + / / 25 messages - read in reverse order 
 val bobReads3 = dates . slice ( 50 , 75 ) . reverse map { date ⇒ 
 / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) 
 messService . handleMessageRead ( groupOutPeer , date ) 
 @ @ - 175 , 7 + 176 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 / / these reads should produce only one UpdateReadByMe , cause dates are descending 
 val expectedUpdatesCount3 = 1 
 
 - / / 20 messages - read in original order , repeat each read multiple times 
 + / / 25 messages - read in original order , repeat each read multiple times 
 val dates4 = dates . slice ( 75 , 100 ) 
 val bobReads4 = dates4 flatMap { date ⇒ 
 val upperBound = Random . nextInt ( 10 ) + 1 
 @ @ - 184 , 7 + 185 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) 
 } 
 } 
 - / / these reads should not repeat UpdateReadByMe with same startDate , thus - 20 updates 
 + / / these reads should not repeat UpdateReadByMe with same startDate , thus - 25 updates 
 val expectedUpdatesCount4 = dates4 . length 
 
 ( 
 @ @ - 197 , 12 + 198 , 7 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 
 / / this is not how we get exact difference , this is how we store it in database 
 whenReady ( db . run ( UserSequenceRepo . fetchAfterSeq ( bob . id , 0 , Long . MaxValue ) ) ) { updates ⇒ 
 - val readsByMe = updates flatMap { seq ⇒ 
 - val upd = seq . getMapping . getDefault 
 - if ( upd . header = = UpdateMessageReadByMe . header ) { 
 - Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption map ( upd ⇒ ( seq . seq , seq . timestamp , upd ) ) 
 - } else None 
 - } 
 + val readsByMe = extractUpdateMessageReadByMe ( updates ) 
 
 readsByMe should have length expectedSize . toLong 
 
 @ @ - 231 , 6 + 227 , 173 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 } 
 } 
 
 + def doubleReadsProduceGoodSequence ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) 
 + 
 + val aliceCd = ClientData ( aliceAuthId , 3L , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) 
 + val bobCd = ClientData ( bobAuthId , 3L , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 + val eveCd = ClientData ( eveAuthId , 3L , Some ( AuthData ( eve . id , eveAuthSid , 42 ) ) ) 
 + 
 + / / Alice creates group 
 + val groupOutPeer = { 
 + implicit val cd = aliceCd 
 + val g = createGroup ( " Group to test differnece " , Set ( bob . id , eve . id ) ) . groupPeer 
 + ApiOutPeer ( ApiPeerType . Group , g . groupId , g . accessHash ) 
 + } 
 + val groupPeer = ApiPeer ( ApiPeerType . Group , groupOutPeer . id ) 
 + 
 + / / Alice sends 100 messages 
 + val aliceRids = ( 1 to 100 ) map { i ⇒ 
 + implicit val cd = aliceCd 
 + val rid = ACLUtils . randomLong ( ) 
 + dialogExt . sendMessage ( groupPeer , alice . id , aliceAuthSid , Some ( aliceAuthId ) , rid , textMessage ( s " Hello from Alice # $ i " ) ) map ( _ ⇒ rid ) 
 + } map ( e ⇒ whenReady ( e ) ( identity ) ) 
 + 
 + val messageDates = whenReady ( db . run ( HistoryMessageRepo . find ( alice . id , groupPeer . asModel , aliceRids . toSet ) ) ) { messages ⇒ 
 + ( messages map ( _ . date . getMillis ) ) . sorted 
 + } 
 + 
 + val ( reads , bobsUpdatesCount , evesUpdatesCount ) = { 
 + 
 + / / Eve reads 50 messages in random order 
 + val ( reads1 , eveUpdatesCount1 ) = { 
 + implicit val cd = eveCd 
 + 
 + val dates = Random . shuffle ( messageDates . slice ( 0 , 50 ) ) 
 + val reads = dates map { date ⇒ 
 + messService . handleMessageRead ( groupOutPeer , date ) 
 + } 
 + / / these reads should produce UpdateReadByMe only with ascending dates 
 + val count = ( dates . reverse foldRight List . empty [ Long ] ) { 
 + case ( el , Nil ) ⇒ List ( el ) 
 + case ( el , acc @ h : : t ) if h < el ⇒ el : : acc 
 + case ( _ , acc ) ⇒ acc 
 + } . length 
 + reads → count 
 + } 
 + 
 + / / Bob reads 50 messages in original order 
 + val ( reads2 , bobUpdatesCount1 ) = { 
 + implicit val cd = bobCd 
 + 
 + val dates = messageDates . slice ( 0 , 50 ) 
 + val reads = dates map { date ⇒ 
 + messService . handleMessageRead ( groupOutPeer , date ) 
 + } 
 + / / these reads should produce 50 UpdateReadByMe 
 + val count = dates . length 
 + reads → count 
 + } 
 + 
 + / / Eve reads 50 messages in reverse order 
 + val ( reads3 , eveUpdatesCount2 ) = { 
 + implicit val cd = eveCd 
 + 
 + val reads = messageDates . slice ( 50 , 100 ) . reverse map { date ⇒ 
 + messService . handleMessageRead ( groupOutPeer , date ) 
 + } 
 + / / these reads should produce only one UpdateReadByMe , cause dates are descending 
 + val count = 1 
 + reads → count 
 + } 
 + 
 + / / Bob reads 50 messages in original order , repeat each read multiple times 
 + val ( reads4 , bobUpdatesCount2 ) = { 
 + implicit val cd = bobCd 
 + 
 + val dates = messageDates . slice ( 50 , 100 ) 
 + val reads = dates flatMap { date ⇒ 
 + val upperBound = Random . nextInt ( 10 ) + 1 
 + 1 to upperBound map { _ ⇒ 
 + messService . handleMessageRead ( groupOutPeer , date ) 
 + } 
 + } 
 + / / these reads should not repeat UpdateReadByMe with same startDate , thus - 25 updates 
 + val count = dates . length 
 + reads → count 
 + } 
 + 
 + ( 
 + reads1 + + reads2 + + reads3 + + reads4 , 
 + bobUpdatesCount1 + bobUpdatesCount2 , 
 + eveUpdatesCount1 + eveUpdatesCount2 
 + ) 
 + } 
 + 
 + reads foreach { whenReady ( _ ) ( identity ) } 
 + 
 + / / Checking Bob ' s difference 
 + / / this is not how we get exact difference , this is how we store it in database 
 + whenReady ( db . run ( UserSequenceRepo . fetchAfterSeq ( bob . id , 0 , Long . MaxValue ) ) ) { updates ⇒ 
 + val readsByMe = extractUpdateMessageReadByMe ( updates ) 
 + 
 + readsByMe should have length bobsUpdatesCount . toLong 
 + 
 + readsByMe foreach { e ⇒ println ( s " = = = = = = = = = = = = : $ { e } " ) } 
 + 
 + readsByMe . zip ( readsByMe . tail ) foreach { 
 + case ( ( fSeq , fTs , fUpd ) , ( sSeq , sTs , sUpd ) ) ⇒ 
 + assert ( fUpd . startDate < sUpd . startDate , " Update start dates are not ascending " ) 
 + assert ( fSeq < sSeq , " Seqs are not ascending " ) 
 + assert ( fTs < = sTs , " Seq update timestamps are not ascending " ) 
 + assert ( fUpd . unreadCounter . get > sUpd . unreadCounter . get , " Counters are not descending " ) 
 + } 
 + } 
 + 
 + / / UpdateMessageReadByMe should be reduces in final difference 
 + whenReady ( seqExt . getDifference ( bob . id , 0 , bobAuthSid , Long . MaxValue ) ) { 
 + case ( diff , _ ) ⇒ 
 + val readsByMe = diff flatMap { seq ⇒ 
 + val upd = seq . getMapping . getDefault 
 + if ( upd . header = = UpdateMessageReadByMe . header ) { 
 + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption 
 + } else None 
 + } 
 + readsByMe should have length 1L 
 + readsByMe . head shouldEqual UpdateMessageReadByMe ( groupPeer , messageDates . last , Some ( 0 ) ) 
 + } 
 + 
 + / / Checking Eve ' s difference 
 + / / this is not how we get exact difference , this is how we store it in database 
 + whenReady ( db . run ( UserSequenceRepo . fetchAfterSeq ( eve . id , 0 , Long . MaxValue ) ) ) { updates ⇒ 
 + val readsByMe = extractUpdateMessageReadByMe ( updates ) 
 + 
 + readsByMe should have length evesUpdatesCount . toLong 
 + 
 + readsByMe . zip ( readsByMe . tail ) foreach { 
 + case ( ( fSeq , fTs , fUpd ) , ( sSeq , sTs , sUpd ) ) ⇒ 
 + assert ( fUpd . startDate < sUpd . startDate , " Update start dates are not ascending " ) 
 + assert ( fSeq < sSeq , " Seqs are not ascending " ) 
 + assert ( fTs < = sTs , " Seq update timestamps are not ascending " ) 
 + assert ( fUpd . unreadCounter . get > sUpd . unreadCounter . get , " Counters are not descending " ) 
 + } 
 + } 
 + 
 + / / UpdateMessageReadByMe should be reduces in final difference 
 + whenReady ( seqExt . getDifference ( eve . id , 0 , eveAuthSid , Long . MaxValue ) ) { 
 + case ( diff , _ ) ⇒ 
 + val readsByMe = diff flatMap { seq ⇒ 
 + val upd = seq . getMapping . getDefault 
 + if ( upd . header = = UpdateMessageReadByMe . header ) { 
 + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption 
 + } else None 
 + } 
 + readsByMe should have length 1L 
 + readsByMe . head shouldEqual UpdateMessageReadByMe ( groupPeer , messageDates . last , Some ( 0 ) ) 
 + } 
 + 
 + } 
 + 
 + private def extractUpdateMessageReadByMe ( updates : Seq [ SeqUpdate ] ) : Seq [ ( Int , Long , UpdateMessageReadByMe ) ] = 
 + updates flatMap { seq ⇒ 
 + val upd = seq . getMapping . getDefault 
 + if ( upd . header = = UpdateMessageReadByMe . header ) { 
 + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption map ( upd ⇒ ( seq . seq , seq . timestamp , upd ) ) 
 + } else None 
 + } 
 + 
 def uniqueTimestamp ( ) = { 
 val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( )

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 8c6fabd . . 9464470 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 139 , 14 + 139 , 16 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { 
 log . debug ( s " mustRead is $ { mustRead } " ) 
 
 if ( mustRead ) { 
 - persistAsync ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . getOrigin . id ) ) { e ⇒ 
 + / / can ' t use persistAsync here , cause more reads can occur , 
 + / / and state will be inconsistent by the time handler is excuted . 
 + persist ( MessagesRead ( Instant . ofEpochMilli ( mr . date ) , mr . getOrigin . id ) ) { e ⇒ 
 log . debug ( s " persisted MessagesRead , origin = $ { mr . getOrigin . id } , date = $ { Instant . ofEpochMilli ( mr . date ) } , counter = $ { state . counter } , unreadMessages = $ { state . unreadMessages } " ) 
 - commit ( e ) 
 - log . debug ( s " after commit : counter = $ { state . counter } , unreadMessages = $ { state . unreadMessages } " ) 
 + val newState = commit ( e ) 
 + log . debug ( s " after commit : counter = $ { newState . counter } , unreadMessages = $ { newState . unreadMessages } " ) 
 
 ( for { 
 _ ← dialogExt . ackMessageRead ( peer , mr ) 
 - _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , state . counter ) 
 + _ ← deliveryExt . read ( userId , mr . readerAuthSid , peer , mr . date , newState . counter ) 
 _ = deliveryExt . sendCountersUpdate ( userId ) 
 } yield MessageReadAck ( ) ) pipeTo sender ( ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala 
 index 89ca08f . . 0b95c88 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala 
 @ @ - 47 , 7 + 47 , 7 @ @ private [ dialog ] object DialogState { 
 
 private [ dialog ] final case class DialogState ( 
 userId : Int , 
 - lastMessageDate : Instant , / / we don ' t use it now anywhere . should we remove it ? 
 + lastMessageDate : Instant , 
 lastOwnerReceiveDate : Instant , 
 lastReceiveDate : Instant , 
 lastOwnerReadDate : Instant , 
 @ @ - 85 , 13 + 85 , 13 @ @ private [ dialog ] final case class DialogState ( 
 lastOwnerReadDate = date 
 ) 
 case MessagesRead ( date , readerUserId ) if readerUserId ! = userId ⇒ 
 - if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReadDate ) | | date = = lastReadDate ) ) 
 + if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReadDate ) | | date = = lastReadDate ) ) / / what ' s a point of creating state with same lastReadDate ( last condition ) 
 this . copy ( lastReadDate = date ) 
 else this 
 case MessagesReceived ( date , receiverUserId ) if receiverUserId = = userId ⇒ 
 this . copy ( lastOwnerReceiveDate = date ) 
 case MessagesReceived ( date , receiverUserId ) if receiverUserId ! = userId ⇒ 
 - if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReceiveDate ) | | date = = lastReceiveDate ) ) 
 + if ( date . isBefore ( Instant . now ( ) . plusMillis ( 1 ) ) & & ( date . isAfter ( lastReceiveDate ) | | date = = lastReceiveDate ) ) / / what ' s a point of creating state with same lastReadDate ( last condition ) 
 this . copy ( lastReceiveDate = date ) 
 else this 
 case SetCounter ( newCounter ) ⇒ 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala 
 index 2d0e325 . . 07c49a8 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / IntegrationsServiceSpec . scala 
 @ @ - 33 , 9 + 33 , 7 @ @ final class IntegrationsServiceSpec 
 
 implicit val ec = system . dispatcher 
 
 - val groupInviteConfig = GroupInviteConfig ( " https : / / actor . im " ) 
 - 
 - implicit val groupsService = new GroupsServiceImpl ( groupInviteConfig ) 
 + implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " https : / / actor . im " ) ) 
 
 private val config = HttpApiConfig ( " localhost " , 9000 , " http : / / actor . im " , " / dev / null " , None ) 
 val service = new IntegrationsServiceImpl ( config . baseUri ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 index 08ff9ff . . e09722c 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 @ @ - 1 , 21 + 1 , 28 @ @ 
 package im . actor . server . dialog 
 
 + import cats . data . Xor 
 import im . actor . api . rpc . messaging . _ 
 - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeer , ApiPeerType } 
 import im . actor . api . rpc . { AuthData , ClientData , Ok , PeersImplicits } 
 import im . actor . server . _ 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 - import im . actor . server . sequence . SeqStateDate 
 + import im . actor . server . model . SeqUpdate 
 + import im . actor . server . persist . HistoryMessageRepo 
 + import im . actor . server . persist . sequence . UserSequenceRepo 
 + import im . actor . server . sequence . { SeqStateDate , SeqUpdatesExtension } 
 
 import scala . concurrent . Future 
 import scala . language . postfixOps 
 + import scala . util . Random 
 
 final class DialogProcessorSpec extends BaseAppSuite 
 with ImplicitAuthService 
 with ImplicitSessionRegion 
 with PeersImplicits 
 - with MessageParsing { 
 + with MessageParsing 
 + with GroupsServiceHelpers { 
 
 behavior of " Dialog Processor " 
 
 @ @ - 23 , 9 + 30 , 13 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 
 it should " not allow time out when there are highly frequent messages " in noTimeout ( ) 
 
 + it should " keep UpdateReadByMe in right order in difference " in readsProduceGoodSequence ( ) 
 + 
 it should " not allow duplicated timestamp in messages " in uniqueTimestamp ( ) 
 
 - private val messService = MessagingServiceImpl ( ) 
 + private implicit val messService = MessagingServiceImpl ( ) 
 + private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " https : / / actor . im " ) ) 
 + private val seqExt = SeqUpdatesExtension ( system ) 
 
 def passReads ( ) = { 
 val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 @ @ - 102 , 6 + 113 , 124 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 
 } 
 
 + def readsProduceGoodSequence ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) 
 + 
 + val aliceCd = ClientData ( aliceAuthId , 3L , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) 
 + val bobCd = ClientData ( bobAuthId , 3L , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 + 
 + / / Alice creates group 
 + val groupOutPeer = { 
 + implicit val cd = aliceCd 
 + val g = createGroup ( " Group to test differnece " , Set ( bob . id , eve . id ) ) . groupPeer 
 + ApiOutPeer ( ApiPeerType . Group , g . groupId , g . accessHash ) 
 + } 
 + val groupPeer = ApiPeer ( ApiPeerType . Group , groupOutPeer . id ) 
 + 
 + / / Alice sends 100 messages 
 + val aliceRids = ( 1 to 100 ) map { i ⇒ 
 + implicit val cd = aliceCd 
 + val rid = ACLUtils . randomLong ( ) 
 + dialogExt . sendMessage ( groupPeer , alice . id , aliceAuthSid , Some ( aliceAuthId ) , rid , textMessage ( s " Hello from Alice # $ i " ) ) map ( _ ⇒ rid ) 
 + } map ( e ⇒ whenReady ( e ) ( identity ) ) 
 + 
 + val dates = whenReady ( db . run ( HistoryMessageRepo . find ( alice . id , groupPeer . asModel , aliceRids . toSet ) ) ) { messages ⇒ 
 + ( messages map ( _ . date . getMillis ) ) . sorted 
 + } 
 + 
 + / / Bob reads 100 messages in random order , repeats requests , etc 
 + 
 + val ( reads , expectedSize ) = { 
 + implicit val cd = bobCd 
 + 
 + / / 20 messages - read in original order 
 + val dates1 = dates . slice ( 0 , 25 ) 
 + val bobReads1 = dates1 map { date ⇒ 
 + / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) 
 + messService . handleMessageRead ( groupOutPeer , date ) 
 + } 
 + / / these reads should produce 20 UpdateReadByMe 
 + val expectedUpdatesCount1 = dates1 . length 
 + 
 + / / 20 messages - read in random order 
 + val dates2 = Random . shuffle ( dates . slice ( 25 , 50 ) ) 
 + val bobReads2 = dates2 map { date ⇒ 
 + / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) 
 + messService . handleMessageRead ( groupOutPeer , date ) 
 + } 
 + / / these reads should produce UpdateReadByMe only with ascending dates 
 + val expectedUpdatesCount2 = ( dates2 . reverse foldRight List . empty [ Long ] ) { 
 + case ( el , Nil ) ⇒ List ( el ) 
 + case ( el , acc @ h : : t ) if h < el ⇒ el : : acc 
 + case ( _ , acc ) ⇒ acc 
 + } . length 
 + 
 + / / 20 messages - read in reverse order 
 + val bobReads3 = dates . slice ( 50 , 75 ) . reverse map { date ⇒ 
 + / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) 
 + messService . handleMessageRead ( groupOutPeer , date ) 
 + } 
 + / / these reads should produce only one UpdateReadByMe , cause dates are descending 
 + val expectedUpdatesCount3 = 1 
 + 
 + / / 20 messages - read in original order , repeat each read multiple times 
 + val dates4 = dates . slice ( 75 , 100 ) 
 + val bobReads4 = dates4 flatMap { date ⇒ 
 + val upperBound = Random . nextInt ( 10 ) + 1 
 + 1 to upperBound map { _ ⇒ 
 + messService . handleMessageRead ( groupOutPeer , date ) 
 + / / dialogExt . messageRead ( groupOutPeer . asPeer , bob . id , bobAuthSid , date ) 
 + } 
 + } 
 + / / these reads should not repeat UpdateReadByMe with same startDate , thus - 20 updates 
 + val expectedUpdatesCount4 = dates4 . length 
 + 
 + ( 
 + bobReads1 + + bobReads2 + + bobReads3 + + bobReads4 , 
 + expectedUpdatesCount1 + expectedUpdatesCount2 + expectedUpdatesCount3 + expectedUpdatesCount4 
 + ) 
 + } 
 + 
 + reads foreach { whenReady ( _ ) ( identity ) } 
 + 
 + / / this is not how we get exact difference , this is how we store it in database 
 + whenReady ( db . run ( UserSequenceRepo . fetchAfterSeq ( bob . id , 0 , Long . MaxValue ) ) ) { updates ⇒ 
 + val readsByMe = updates flatMap { seq ⇒ 
 + val upd = seq . getMapping . getDefault 
 + if ( upd . header = = UpdateMessageReadByMe . header ) { 
 + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption map ( upd ⇒ ( seq . seq , seq . timestamp , upd ) ) 
 + } else None 
 + } 
 + 
 + readsByMe should have length expectedSize . toLong 
 + 
 + readsByMe . zip ( readsByMe . tail ) foreach { 
 + case ( ( fSeq , fTs , fUpd ) , ( sSeq , sTs , sUpd ) ) ⇒ 
 + assert ( fUpd . startDate < sUpd . startDate , " Update start dates are not ascending " ) 
 + assert ( fSeq < sSeq , " Seqs are not ascending " ) 
 + assert ( fTs < = sTs , " Seq update timestamps are not ascending " ) 
 + assert ( fUpd . unreadCounter . get > sUpd . unreadCounter . get , " Counters are not descending " ) 
 + } 
 + readsByMe . head . _ 3 . unreadCounter . get shouldEqual 99 
 + readsByMe . last . _ 3 . unreadCounter . get shouldEqual 0 
 + } 
 + 
 + / / UpdateMessageReadByMe should be reduces in final difference 
 + whenReady ( seqExt . getDifference ( bob . id , 0 , bobAuthSid , Long . MaxValue ) ) { 
 + case ( diff , _ ) ⇒ 
 + val readsByMe = diff flatMap { seq ⇒ 
 + val upd = seq . getMapping . getDefault 
 + if ( upd . header = = UpdateMessageReadByMe . header ) { 
 + Xor . fromEither ( UpdateMessageReadByMe . parseFrom ( upd . body ) ) . toOption 
 + } else None 
 + } 
 + readsByMe should have length 1L 
 + readsByMe . head shouldEqual UpdateMessageReadByMe ( groupPeer , dates . last , Some ( 0 ) ) 
 + } 
 + } 
 + 
 def uniqueTimestamp ( ) = { 
 val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( )
