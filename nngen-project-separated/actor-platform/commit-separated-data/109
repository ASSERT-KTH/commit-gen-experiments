BLEU SCORE: 0.11868405219520975

TEST MSG: feat ( server : groups ) : group async members
GENERATED MSG: fix ( server ) : fix service messages in channels

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / group . proto b / actor - server / actor - core / src / main / protobuf / group . proto < nl > index 654125b . . b0fa464 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / group . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / group . proto < nl > @ @ - 156 , 6 + 156 , 12 @ @ message GroupEvents { < nl > required int32 executor _ user _ id = 2 ; < nl > } < nl > < nl > + message MembersBecameAsync { < nl > + option ( scalapb . message ) . extends = " im . actor . server . group . GroupEvent " ; < nl > + < nl > + required int64 ts = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + } < nl > + < nl > message GroupDeleted { < nl > option ( scalapb . message ) . extends = " im . actor . server . group . GroupEvent " ; < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 6ccef21 . . 0b0b37a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 172 , 4 + 172 , 22 @ @ private [ group ] trait GroupCommandHandlers < nl > < nl > protected def isValidTitle ( title : String ) = title . nonEmpty & & title . length < 255 < nl > < nl > + protected def updateCanCall ( currState : GroupState ) : Unit = { < nl > + currState . memberIds foreach { userId ⇒ < nl > + permissionsUpdates ( userId , currState ) foreach { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId , update ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + protected def makeMembersAsync ( ) : Unit = { < nl > + persist ( MembersBecameAsync ( Instant . now ) ) { evt ⇒ < nl > + val newState = commit ( evt ) < nl > + < nl > + seqUpdExt . broadcastPeopleUpdate ( < nl > + userIds = newState . memberIds , < nl > + update = UpdateGroupMembersBecameAsync ( groupId ) < nl > + ) < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > index 3c7488b . . 4a5856c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > @ @ - 93 , 7 + 93 , 8 @ @ object GroupProcessor { < nl > 22019 → classOf [ GroupEvents . AdminSettingsUpdated ] , < nl > 22020 → classOf [ GroupEvents . AdminStatusChanged ] , < nl > 22021 → classOf [ GroupEvents . HistoryBecameShared ] , < nl > - 22022 → classOf [ GroupEvents . GroupDeleted ] < nl > + 22022 → classOf [ GroupEvents . GroupDeleted ] , < nl > + 22023 → classOf [ GroupEvents . MembersBecameAsync ] < nl > ) < nl > < nl > def persistenceIdFor ( groupId : Int ) : String = s " Group - $ { groupId } " < nl > @ @ - 187 , 18 + 188 , 13 @ @ private [ group ] final class GroupProcessor < nl > override def afterCommit ( e : Event ) = { < nl > super . afterCommit ( e ) < nl > if ( recoveryFinished ) { < nl > + / / can ' t make calls in group with more than 25 members < nl > if ( state . membersCount > 25 ) { < nl > updateCanCall ( state ) < nl > } < nl > - / / TODO : add async members < nl > - / / if ( state . membersCount > 50 ) { updateMembersAsync ( state ) } < nl > - } < nl > - } < nl > - < nl > - private def updateCanCall ( state : GroupState ) : Unit = { < nl > - state . memberIds foreach { userId ⇒ < nl > - permissionsUpdates ( userId , state ) foreach { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId , update ) < nl > + / / from 50 + members we make group with async members < nl > + if ( state . membersCount > = 50 ) { < nl > + makeMembersAsync ( ) < nl > } < nl > } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > index b600c77 . . 2cd8548 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > @ @ - 83 , 6 + 83 , 7 @ @ private [ group ] object GroupState { < nl > groupType = GroupType . General , < nl > isHidden = false , < nl > isHistoryShared = false , < nl > + isAsyncMembers = false , < nl > members = Map . empty , < nl > invitedUserIds = Set . empty , < nl > accessHash = 0L , < nl > @ @ - 112 , 6 + 113 , 7 @ @ private [ group ] final case class GroupState ( < nl > groupType : GroupType , < nl > isHidden : Boolean , < nl > isHistoryShared : Boolean , < nl > + isAsyncMembers : Boolean , < nl > < nl > / / members info < nl > members : Map [ Int , Member ] , < nl > @ @ - 152 , 13 + 154 , 6 @ @ private [ group ] final case class GroupState ( < nl > < nl > val isDeleted = deletedAt . nonEmpty < nl > < nl > - / / TODO : add on commit ( not during recovery ! ) hook to make group with async members , when more than 100 < nl > - def isAsyncMembers = < nl > - groupType match { < nl > - case General ⇒ members . size > 100 < nl > - case Channel ⇒ true < nl > - } < nl > - < nl > def getShowableOwner ( clientUserId : Int ) : Option [ Int ] = < nl > groupType match { < nl > case General ⇒ Some ( creatorUserId ) < nl > @ @ - 168 , 6 + 163 , 7 @ @ private [ group ] final case class GroupState ( < nl > override def updated ( e : Event ) : GroupState = e match { < nl > case evt : Created ⇒ < nl > val typeOfGroup = evt . typ . getOrElse ( GroupType . General ) < nl > + val isMemberAsync = typeOfGroup . isChannel < nl > this . copy ( < nl > id = evt . groupId , < nl > createdAt = Some ( evt . ts ) , < nl > @ @ - 181 , 6 + 177 , 7 @ @ private [ group ] final case class GroupState ( < nl > groupType = typeOfGroup , < nl > isHidden = evt . isHidden getOrElse false , < nl > isHistoryShared = evt . isHistoryShared getOrElse false , < nl > + isAsyncMembers = isMemberAsync , < nl > members = ( < nl > evt . userIds map { userId ⇒ < nl > userId → < nl > @ @ - 267 , 6 + 264 , 8 @ @ private [ group ] final case class GroupState ( < nl > this . copy ( adminSettings = AdminSettings . fromBitMask ( bitMask ) ) < nl > case HistoryBecameShared ( _ , _ ) ⇒ < nl > this . copy ( isHistoryShared = true ) < nl > + case MembersBecameAsync ( _ ) ⇒ < nl > + this . copy ( isAsyncMembers = true ) < nl > case GroupDeleted ( ts , _ ) ⇒ < nl > / / FIXME : don ' t implement snapshots , before figure out deleted groups behavior < nl > this . copy ( < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala < nl > index 06b19c0 . . 37cce14 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala < nl > @ @ - 37 , 7 + 37 , 6 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > < nl > val dateMillis = evt . ts . toEpochMilli < nl > val memberIds = newState . memberIds < nl > - val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > < nl > / / if user ever been in this group - we should push these updates < nl > / / TODO : unify isHistoryShared usage < nl > @ @ - 46 , 11 + 45 , 26 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > optDrop + + : refreshGroupUpdates ( newState , cmd . inviteeUserId ) < nl > } < nl > < nl > - val membersUpdateNew : Update = < nl > - if ( newState . groupType . isChannel ) / / if channel , or group is big enough < nl > - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > - else < nl > - UpdateGroupMembersUpdated ( groupId , apiMembers ) < nl > + / / For groups with not async members we should push Diff for members , and all Members for invitee < nl > + / / For groups with async members we should push UpdateGroupMembersCountChanged for both invitee and members < nl > + val ( inviteeUpdateNew , membersUpdateNew ) : ( Update , Update ) = < nl > + if ( newState . isAsyncMembers ) { < nl > + val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > + ( u , u ) < nl > + } else { < nl > + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > + val inviteeMember = apiMembers . find ( _ . userId = = cmd . inviteeUserId ) < nl > + < nl > + ( < nl > + UpdateGroupMembersUpdated ( groupId , apiMembers ) , < nl > + UpdateGroupMemberDiff ( < nl > + groupId , < nl > + addedMembers = inviteeMember . toVector , < nl > + membersCount = newState . membersCount , < nl > + removedUsers = Vector . empty < nl > + ) < nl > + ) < nl > + } < nl > < nl > val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( < nl > groupId , < nl > @ @ - 73 , 11 + 87 , 11 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > < nl > def inviteGROUPUpdates : Future [ SeqStateDate ] = < nl > for { < nl > - / / push updated members list to inviteeUserId , < nl > + / / push updated members list / count to inviteeUserId , < nl > / / make it ` FatSeqUpdate ` if this user invited to group for first time . < nl > _ ← seqUpdExt . deliverUserUpdate ( < nl > userId = cmd . inviteeUserId , < nl > - membersUpdateNew , < nl > + update = inviteeUpdateNew , < nl > pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , < nl > deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > ) < nl > @ @ - 87 , 7 + 101 , 7 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > } < nl > < nl > - / / push updated members list to all group members except inviteeUserId < nl > + / / push updated members difference to all group members except inviteeUserId < nl > SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > userId = cmd . inviterUserId , < nl > authId = cmd . inviterAuthId , < nl > @ @ - 112 , 7 + 126 , 7 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > / / push updated members count to inviteeUserId < nl > _ ← seqUpdExt . deliverUserUpdate ( < nl > userId = cmd . inviteeUserId , < nl > - membersUpdateNew , < nl > + update = inviteeUpdateNew , < nl > pushRules = seqUpdExt . pushRules ( isFat = false , Some ( PushTexts . Invited ) ) , < nl > deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > ) < nl > @ @ - 230 , 11 + 244 , 35 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > optDrop + + : ( if ( wasInvited ) Vector . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) ) < nl > } < nl > < nl > - val membersUpdateNew : Update = < nl > - if ( newState . groupType . isChannel ) / / if channel , or group is big enough < nl > - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > - else < nl > - UpdateGroupMembersUpdated ( groupId , apiMembers ) / / will update date when member got into group < nl > + / / For groups with not async members we should push : < nl > + / / • Diff for members ; < nl > + / / • Diff for joining user if he was previously invited ; < nl > + / / • Members for joining user if he wasn ' t previously invited . < nl > + / / < nl > + / / For groups with async members we should push : < nl > + / / • UpdateGroupMembersCountChanged for both joining user and members < nl > + val ( joiningUpdateNew , membersUpdateNew ) : ( Update , Update ) = < nl > + if ( newState . isAsyncMembers ) { < nl > + val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > + ( u , u ) < nl > + } else { < nl > + val joiningMember = apiMembers . find ( _ . userId = = cmd . joiningUserId ) < nl > + val diff = UpdateGroupMemberDiff ( < nl > + groupId , < nl > + addedMembers = joiningMember . toVector , < nl > + membersCount = newState . membersCount , < nl > + removedUsers = Vector . empty < nl > + ) < nl > + < nl > + if ( wasInvited ) { < nl > + ( diff , diff ) < nl > + } else { < nl > + ( < nl > + UpdateGroupMembersUpdated ( groupId , apiMembers ) , < nl > + diff < nl > + ) < nl > + } < nl > + } < nl > < nl > / / TODO : not sure how it should be in old API < nl > val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , apiMembers ) < nl > @ @ - 258 , 19 + 296 , 19 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) < nl > } < nl > < nl > - / / push updated members list to joining user , < nl > + / / push updated members list / count / difference to joining user , < nl > / / make it ` FatSeqUpdate ` if this user invited to group for first time . < nl > / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . joiningUserId , < nl > authId = cmd . joiningUserAuthId , < nl > - update = membersUpdateNew , < nl > + update = joiningUpdateNew , < nl > pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here < nl > deliveryId = s " join _ $ { groupId } _ $ { randomId } " < nl > < nl > ) < nl > < nl > - / / push updated members list to all group members except joiningUserId < nl > + / / push updated members list / count to all group members except joiningUserId < nl > _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > memberIds - cmd . joiningUserId , < nl > membersUpdateNew , < nl > @ @ - 297 , 7 + 335 , 7 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . joiningUserId , < nl > authId = cmd . joiningUserAuthId , < nl > - update = membersUpdateNew , < nl > + update = joiningUpdateNew , < nl > deliveryId = s " join _ $ { groupId } _ $ { randomId } " < nl > ) < nl > < nl > @ @ - 358 , 15 + 396 , 17 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > val updatePermissions = permissionsUpdates ( cmd . userId , currState = state . updated ( leftEvent ) ) < nl > < nl > val membersUpdateNew = < nl > - if ( state . groupType . isChannel ) { / / if channel , or group is big enough < nl > + if ( state . isAsyncMembers ) { < nl > UpdateGroupMembersCountChanged ( < nl > groupId , < nl > membersCount = state . membersCount - 1 < nl > ) < nl > } else { < nl > - UpdateGroupMembersUpdated ( < nl > + UpdateGroupMemberDiff ( < nl > groupId , < nl > - members = state . members . filterNot ( _ . _ 1 = = cmd . userId ) . values . map ( _ . asStruct ) . toVector < nl > + removedUsers = Vector ( cmd . userId ) , < nl > + addedMembers = Vector . empty , < nl > + membersCount = state . membersCount - 1 < nl > ) < nl > } < nl > < nl > @ @ - 487 , 15 + 527 , 17 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > val updatePermissions = permissionsUpdates ( cmd . kickedUserId , newState ) < nl > < nl > val membersUpdateNew : Update = < nl > - if ( newState . groupType . isChannel ) { / / if channel , or group is big enough < nl > + if ( newState . isAsyncMembers ) { < nl > UpdateGroupMembersCountChanged ( < nl > groupId , < nl > membersCount = newState . membersCount < nl > ) < nl > } else { < nl > - UpdateGroupMembersUpdated ( < nl > + UpdateGroupMemberDiff ( < nl > groupId , < nl > - members = newState . members . values . map ( _ . asStruct ) . toVector < nl > + removedUsers = Vector ( cmd . kickedUserId ) , < nl > + addedMembers = Vector . empty , < nl > + membersCount = newState . membersCount < nl > ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / Optimization . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / Optimization . scala < nl > index 5e6df96 . . 01f6e81 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / Optimization . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / Optimization . scala < nl > @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . server . sequence < nl > import com . google . protobuf . ByteString < nl > import im . actor . api . rpc . counters . UpdateCountersChanged < nl > import im . actor . api . rpc . groups . _ < nl > + import im . actor . api . rpc . messaging . UpdateChatDropCache < nl > import im . actor . api . rpc . sequence . { ApiUpdateOptimization , UpdateEmptyUpdate } < nl > import im . actor . server . messaging . MessageParsing < nl > import im . actor . server . model . SerializedUpdate < nl > @ @ - 44 , 7 + 45 , 8 @ @ object Optimization extends MessageParsing { < nl > UpdateGroupMemberAdminChanged . header , < nl > UpdateGroupShortNameChanged . header , < nl > UpdateGroupFullPermissionsChanged . header , < nl > - UpdateGroupPermissionsChanged . header < nl > + UpdateGroupPermissionsChanged . header , < nl > + UpdateChatDropCache . header < nl > ) < nl > if ( deliveryTag = = GroupV2 ) < nl > emptyUpdate
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index c3fe238 . . 9794afa 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 8 , 7 + 8 , 7 @ @ import akka . pattern . pipe < nl > import im . actor . api . rpc . Update < nl > import im . actor . api . rpc . files . ApiAvatar < nl > import im . actor . api . rpc . groups . _ < nl > - import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessage } < nl > + import im . actor . api . rpc . messaging . { ApiMessage , ApiServiceMessage , UpdateMessage } < nl > import im . actor . api . rpc . users . ApiSex < nl > import im . actor . concurrent . FutureExt < nl > import im . actor . server . CommonErrors < nl > @ @ - 274 , 22 + 274 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > ) < nl > < nl > - / / push service message to invitee < nl > - _ ← pushUpdateMessage ( < nl > - userId = cmd . inviteeUserId , < nl > - authId = 0L , < nl > - ts = dateMillis , < nl > - randomId = cmd . randomId , < nl > - serviceMessage < nl > - ) < nl > - < nl > - / / push service message to inviter and return seqState < nl > - SeqState ( seq , state ) ← pushUpdateMessage ( < nl > + / / push service message to invitee and inviter < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > userId = cmd . inviterUserId , < nl > authId = cmd . inviterAuthId , < nl > - ts = dateMillis , < nl > - randomId = cmd . randomId , < nl > - serviceMessage < nl > + Set ( cmd . inviteeUserId ) , < nl > + update = serviceMessageUpdate ( < nl > + cmd . inviterUserId , < nl > + dateMillis , < nl > + cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > ) < nl > } yield SeqStateDate ( seq , state , dateMillis ) < nl > < nl > @ @ - 349 , 6 + 344 , 11 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / user was invited in group by other group user < nl > val wasInvited = state . isInvited ( cmd . joiningUserId ) < nl > < nl > + / / trying to figure out who invited joining user . < nl > + / / Descdending priority : < nl > + / / • inviter defined in ` Join ` command ( when invited via token ) < nl > + / / • inviter from members list ( when invited by other user ) < nl > + / / • group creator ( safe fallback ) < nl > val optMember = state . members . get ( cmd . joiningUserId ) < nl > val inviterUserId = cmd . invitingUserId < nl > . orElse ( optMember . map ( _ . inviterUserId ) ) < nl > @ @ - 459 , 13 + 459 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > ) < nl > < nl > - / / push service message to joining user and return seqState < nl > - _ ← pushUpdateMessage ( < nl > - userId = cmd . joiningUserId , < nl > - authId = cmd . joiningUserAuthId , < nl > - ts = dateMillis , < nl > - randomId = randomId , < nl > - serviceMessage < nl > + / / push service message only to inviter < nl > + _ ← seqUpdExt . deliverUserUpdate ( < nl > + userId = inviterUserId , < nl > + update = serviceMessageUpdate ( < nl > + cmd . joiningUserId , < nl > + dateMillis , < nl > + randomId , < nl > + serviceMessage < nl > + ) < nl > ) < nl > } yield SeqStateDate ( seq , state , dateMillis ) < nl > < nl > @ @ - 581 , 14 + 583 , 19 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > UpdateGroupMembersCountChanged ( groupId , state . membersCount - 1 ) < nl > ) < nl > < nl > - / / push service message to left user < nl > - _ ← pushUpdateMessage ( < nl > - userId = cmd . userId , < nl > - authId = cmd . authId , < nl > - ts = dateMillis , < nl > - randomId = cmd . randomId , < nl > - message = serviceMessage < nl > - ) < nl > + / / push service message to user , who invited leaving user < nl > + optInviter = state . members . get ( cmd . userId ) map ( _ . inviterUserId ) < nl > + _ ← optInviter map { inviter ⇒ < nl > + seqUpdExt . deliverUserUpdate ( < nl > + userId = cmd . userId , < nl > + update = serviceMessageUpdate ( < nl > + cmd . userId , < nl > + dateMillis , < nl > + cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > + ) < nl > + } getOrElse FastFuture . successful ( ( ) ) < nl > < nl > / / push left user that he is no longer a member < nl > SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > @ @ - 713 , 22 + 720 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > ) < nl > < nl > - / / push service message to kicker user < nl > - _ ← pushUpdateMessage ( < nl > - userId = cmd . kickerUserId , < nl > - authId = cmd . kickerAuthId , / / ? ? ? what ' s a point ? < nl > - ts = dateMillis , < nl > - randomId = cmd . randomId , < nl > - serviceMessage < nl > - ) < nl > - < nl > - / / push service message to kicked user < nl > - _ ← pushUpdateMessage ( < nl > - userId = cmd . kickedUserId , < nl > - authId = 0L , < nl > - ts = dateMillis , < nl > - randomId = cmd . randomId , < nl > - serviceMessage < nl > + / / push service message to kicker and kicked users . < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + userIds = Set ( cmd . kickedUserId , cmd . kickerUserId ) , < nl > + update = serviceMessageUpdate ( < nl > + cmd . kickerUserId , < nl > + dateMillis , < nl > + cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > ) < nl > < nl > / / push kicked user updates < nl > @ @ - 1147 , 25 + 1147 , 16 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > } < nl > < nl > - / / и л и в с е т а к и б у д е т broadcast ? < nl > - private def pushUpdateMessage ( userId : Int , authId : Long , ts : Long , randomId : Long , message : ApiMessage ) : Future [ SeqState ] = { < nl > - val messUpdate = UpdateMessage ( < nl > + private def serviceMessageUpdate ( senderUserId : Int , date : Long , randomId : Long , message : ApiServiceMessage ) = < nl > + UpdateMessage ( < nl > peer = apiGroupPeer , < nl > - senderUserId = userId , < nl > - date = ts , < nl > + senderUserId = senderUserId , < nl > + date = date , < nl > randomId = randomId , < nl > message = message , < nl > attributes = None , < nl > quotedMessage = None < nl > ) < nl > - seqUpdExt . deliverClientUpdate ( < nl > - userId = userId , < nl > - authId = authId , < nl > - update = messUpdate , < nl > - deliveryId = seqUpdExt . msgDeliveryId ( apiGroupPeer . asModel , randomId ) , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > - } < nl > < nl > private def trimToEmpty ( s : Option [ String ] ) : Option [ String ] = < nl > s map ( _ . trim ) filter ( _ . nonEmpty ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > index b599ef8 . . adcfb28 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > @ @ - 46 , 8 + 46 , 7 @ @ private [ group ] sealed trait Commands extends UserAcl { < nl > def joinGroup ( groupId : Int , joiningUserId : Int , joiningUserAuthId : Long , invitingUserId : Option [ Int ] ) : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = < nl > ( processorRegion . ref ? < nl > GroupEnvelope ( groupId ) < nl > - . withJoin ( Join ( joiningUserId , joiningUserAuthId , invitingUserId = None ) ) / / None ? < nl > - ) . mapTo [ ( SeqStateDate , Vector [ Int ] , Long ) ] < nl > + . withJoin ( Join ( joiningUserId , joiningUserAuthId , invitingUserId = invitingUserId ) ) ) . mapTo [ ( SeqStateDate , Vector [ Int ] , Long ) ] < nl > < nl > def inviteToGroup ( groupId : Int , inviteeUserId : Int , randomId : Long ) ( implicit client : AuthorizedClientData ) : Future [ SeqStateDate ] = < nl > inviteToGroup ( client . userId , client . authId , groupId , inviteeUserId , randomId ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > index 1500067 . . 2e390f8 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > @ @ - 122 , 7 + 122 , 7 @ @ trait GroupQueryHandlers { < nl > canViewMembers = Some ( state . canViewMembers ( clientUserId ) ) , < nl > canInvitePeople = Some ( state . canInvitePeople ( clientUserId ) ) , < nl > isSharedHistory = Some ( state . isHistoryShared ) , < nl > - isAsyncMembers = Some ( state . members . size > 100 ) , < nl > + isAsyncMembers = Some ( state . isAsyncMembers ) , < nl > members = membersAndCount ( state , clientUserId ) . _ 1 < nl > ) < nl > ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > index 5844d86 . . 77ed12f 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > @ @ - 116 , 6 + 116 , 12 @ @ private [ group ] final case class GroupState ( < nl > < nl > def isCreated = createdAt . nonEmpty / / TODO : Maybe val . immutable anyway < nl > < nl > + def isAsyncMembers = < nl > + typ match { < nl > + case General | Public ⇒ members . size > 100 < nl > + case Channel ⇒ true < nl > + } < nl > + < nl > override def updated ( e : Event ) : GroupState = e match { < nl > case evt : Created ⇒ < nl > this . copy (

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / group . proto b / actor - server / actor - core / src / main / protobuf / group . proto 
 index 654125b . . b0fa464 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / group . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / group . proto 
 @ @ - 156 , 6 + 156 , 12 @ @ message GroupEvents { 
 required int32 executor _ user _ id = 2 ; 
 } 
 
 + message MembersBecameAsync { 
 + option ( scalapb . message ) . extends = " im . actor . server . group . GroupEvent " ; 
 + 
 + required int64 ts = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + } 
 + 
 message GroupDeleted { 
 option ( scalapb . message ) . extends = " im . actor . server . group . GroupEvent " ; 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 6ccef21 . . 0b0b37a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 172 , 4 + 172 , 22 @ @ private [ group ] trait GroupCommandHandlers 
 
 protected def isValidTitle ( title : String ) = title . nonEmpty & & title . length < 255 
 
 + protected def updateCanCall ( currState : GroupState ) : Unit = { 
 + currState . memberIds foreach { userId ⇒ 
 + permissionsUpdates ( userId , currState ) foreach { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId , update ) 
 + } 
 + } 
 + } 
 + 
 + protected def makeMembersAsync ( ) : Unit = { 
 + persist ( MembersBecameAsync ( Instant . now ) ) { evt ⇒ 
 + val newState = commit ( evt ) 
 + 
 + seqUpdExt . broadcastPeopleUpdate ( 
 + userIds = newState . memberIds , 
 + update = UpdateGroupMembersBecameAsync ( groupId ) 
 + ) 
 + } 
 + } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 index 3c7488b . . 4a5856c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 @ @ - 93 , 7 + 93 , 8 @ @ object GroupProcessor { 
 22019 → classOf [ GroupEvents . AdminSettingsUpdated ] , 
 22020 → classOf [ GroupEvents . AdminStatusChanged ] , 
 22021 → classOf [ GroupEvents . HistoryBecameShared ] , 
 - 22022 → classOf [ GroupEvents . GroupDeleted ] 
 + 22022 → classOf [ GroupEvents . GroupDeleted ] , 
 + 22023 → classOf [ GroupEvents . MembersBecameAsync ] 
 ) 
 
 def persistenceIdFor ( groupId : Int ) : String = s " Group - $ { groupId } " 
 @ @ - 187 , 18 + 188 , 13 @ @ private [ group ] final class GroupProcessor 
 override def afterCommit ( e : Event ) = { 
 super . afterCommit ( e ) 
 if ( recoveryFinished ) { 
 + / / can ' t make calls in group with more than 25 members 
 if ( state . membersCount > 25 ) { 
 updateCanCall ( state ) 
 } 
 - / / TODO : add async members 
 - / / if ( state . membersCount > 50 ) { updateMembersAsync ( state ) } 
 - } 
 - } 
 - 
 - private def updateCanCall ( state : GroupState ) : Unit = { 
 - state . memberIds foreach { userId ⇒ 
 - permissionsUpdates ( userId , state ) foreach { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId , update ) 
 + / / from 50 + members we make group with async members 
 + if ( state . membersCount > = 50 ) { 
 + makeMembersAsync ( ) 
 } 
 } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 index b600c77 . . 2cd8548 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 @ @ - 83 , 6 + 83 , 7 @ @ private [ group ] object GroupState { 
 groupType = GroupType . General , 
 isHidden = false , 
 isHistoryShared = false , 
 + isAsyncMembers = false , 
 members = Map . empty , 
 invitedUserIds = Set . empty , 
 accessHash = 0L , 
 @ @ - 112 , 6 + 113 , 7 @ @ private [ group ] final case class GroupState ( 
 groupType : GroupType , 
 isHidden : Boolean , 
 isHistoryShared : Boolean , 
 + isAsyncMembers : Boolean , 
 
 / / members info 
 members : Map [ Int , Member ] , 
 @ @ - 152 , 13 + 154 , 6 @ @ private [ group ] final case class GroupState ( 
 
 val isDeleted = deletedAt . nonEmpty 
 
 - / / TODO : add on commit ( not during recovery ! ) hook to make group with async members , when more than 100 
 - def isAsyncMembers = 
 - groupType match { 
 - case General ⇒ members . size > 100 
 - case Channel ⇒ true 
 - } 
 - 
 def getShowableOwner ( clientUserId : Int ) : Option [ Int ] = 
 groupType match { 
 case General ⇒ Some ( creatorUserId ) 
 @ @ - 168 , 6 + 163 , 7 @ @ private [ group ] final case class GroupState ( 
 override def updated ( e : Event ) : GroupState = e match { 
 case evt : Created ⇒ 
 val typeOfGroup = evt . typ . getOrElse ( GroupType . General ) 
 + val isMemberAsync = typeOfGroup . isChannel 
 this . copy ( 
 id = evt . groupId , 
 createdAt = Some ( evt . ts ) , 
 @ @ - 181 , 6 + 177 , 7 @ @ private [ group ] final case class GroupState ( 
 groupType = typeOfGroup , 
 isHidden = evt . isHidden getOrElse false , 
 isHistoryShared = evt . isHistoryShared getOrElse false , 
 + isAsyncMembers = isMemberAsync , 
 members = ( 
 evt . userIds map { userId ⇒ 
 userId → 
 @ @ - 267 , 6 + 264 , 8 @ @ private [ group ] final case class GroupState ( 
 this . copy ( adminSettings = AdminSettings . fromBitMask ( bitMask ) ) 
 case HistoryBecameShared ( _ , _ ) ⇒ 
 this . copy ( isHistoryShared = true ) 
 + case MembersBecameAsync ( _ ) ⇒ 
 + this . copy ( isAsyncMembers = true ) 
 case GroupDeleted ( ts , _ ) ⇒ 
 / / FIXME : don ' t implement snapshots , before figure out deleted groups behavior 
 this . copy ( 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala 
 index 06b19c0 . . 37cce14 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala 
 @ @ - 37 , 7 + 37 , 6 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 
 val dateMillis = evt . ts . toEpochMilli 
 val memberIds = newState . memberIds 
 - val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 
 / / if user ever been in this group - we should push these updates 
 / / TODO : unify isHistoryShared usage 
 @ @ - 46 , 11 + 45 , 26 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 optDrop + + : refreshGroupUpdates ( newState , cmd . inviteeUserId ) 
 } 
 
 - val membersUpdateNew : Update = 
 - if ( newState . groupType . isChannel ) / / if channel , or group is big enough 
 - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 - else 
 - UpdateGroupMembersUpdated ( groupId , apiMembers ) 
 + / / For groups with not async members we should push Diff for members , and all Members for invitee 
 + / / For groups with async members we should push UpdateGroupMembersCountChanged for both invitee and members 
 + val ( inviteeUpdateNew , membersUpdateNew ) : ( Update , Update ) = 
 + if ( newState . isAsyncMembers ) { 
 + val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 + ( u , u ) 
 + } else { 
 + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 + val inviteeMember = apiMembers . find ( _ . userId = = cmd . inviteeUserId ) 
 + 
 + ( 
 + UpdateGroupMembersUpdated ( groupId , apiMembers ) , 
 + UpdateGroupMemberDiff ( 
 + groupId , 
 + addedMembers = inviteeMember . toVector , 
 + membersCount = newState . membersCount , 
 + removedUsers = Vector . empty 
 + ) 
 + ) 
 + } 
 
 val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( 
 groupId , 
 @ @ - 73 , 11 + 87 , 11 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 
 def inviteGROUPUpdates : Future [ SeqStateDate ] = 
 for { 
 - / / push updated members list to inviteeUserId , 
 + / / push updated members list / count to inviteeUserId , 
 / / make it ` FatSeqUpdate ` if this user invited to group for first time . 
 _ ← seqUpdExt . deliverUserUpdate ( 
 userId = cmd . inviteeUserId , 
 - membersUpdateNew , 
 + update = inviteeUpdateNew , 
 pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , 
 deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 ) 
 @ @ - 87 , 7 + 101 , 7 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 } 
 
 - / / push updated members list to all group members except inviteeUserId 
 + / / push updated members difference to all group members except inviteeUserId 
 SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 userId = cmd . inviterUserId , 
 authId = cmd . inviterAuthId , 
 @ @ - 112 , 7 + 126 , 7 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 / / push updated members count to inviteeUserId 
 _ ← seqUpdExt . deliverUserUpdate ( 
 userId = cmd . inviteeUserId , 
 - membersUpdateNew , 
 + update = inviteeUpdateNew , 
 pushRules = seqUpdExt . pushRules ( isFat = false , Some ( PushTexts . Invited ) ) , 
 deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 ) 
 @ @ - 230 , 11 + 244 , 35 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 optDrop + + : ( if ( wasInvited ) Vector . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) ) 
 } 
 
 - val membersUpdateNew : Update = 
 - if ( newState . groupType . isChannel ) / / if channel , or group is big enough 
 - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 - else 
 - UpdateGroupMembersUpdated ( groupId , apiMembers ) / / will update date when member got into group 
 + / / For groups with not async members we should push : 
 + / / • Diff for members ; 
 + / / • Diff for joining user if he was previously invited ; 
 + / / • Members for joining user if he wasn ' t previously invited . 
 + / / 
 + / / For groups with async members we should push : 
 + / / • UpdateGroupMembersCountChanged for both joining user and members 
 + val ( joiningUpdateNew , membersUpdateNew ) : ( Update , Update ) = 
 + if ( newState . isAsyncMembers ) { 
 + val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 + ( u , u ) 
 + } else { 
 + val joiningMember = apiMembers . find ( _ . userId = = cmd . joiningUserId ) 
 + val diff = UpdateGroupMemberDiff ( 
 + groupId , 
 + addedMembers = joiningMember . toVector , 
 + membersCount = newState . membersCount , 
 + removedUsers = Vector . empty 
 + ) 
 + 
 + if ( wasInvited ) { 
 + ( diff , diff ) 
 + } else { 
 + ( 
 + UpdateGroupMembersUpdated ( groupId , apiMembers ) , 
 + diff 
 + ) 
 + } 
 + } 
 
 / / TODO : not sure how it should be in old API 
 val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , apiMembers ) 
 @ @ - 258 , 19 + 296 , 19 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) 
 } 
 
 - / / push updated members list to joining user , 
 + / / push updated members list / count / difference to joining user , 
 / / make it ` FatSeqUpdate ` if this user invited to group for first time . 
 / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 userId = cmd . joiningUserId , 
 authId = cmd . joiningUserAuthId , 
 - update = membersUpdateNew , 
 + update = joiningUpdateNew , 
 pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here 
 deliveryId = s " join _ $ { groupId } _ $ { randomId } " 
 
 ) 
 
 - / / push updated members list to all group members except joiningUserId 
 + / / push updated members list / count to all group members except joiningUserId 
 _ ← seqUpdExt . broadcastPeopleUpdate ( 
 memberIds - cmd . joiningUserId , 
 membersUpdateNew , 
 @ @ - 297 , 7 + 335 , 7 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 userId = cmd . joiningUserId , 
 authId = cmd . joiningUserAuthId , 
 - update = membersUpdateNew , 
 + update = joiningUpdateNew , 
 deliveryId = s " join _ $ { groupId } _ $ { randomId } " 
 ) 
 
 @ @ - 358 , 15 + 396 , 17 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 val updatePermissions = permissionsUpdates ( cmd . userId , currState = state . updated ( leftEvent ) ) 
 
 val membersUpdateNew = 
 - if ( state . groupType . isChannel ) { / / if channel , or group is big enough 
 + if ( state . isAsyncMembers ) { 
 UpdateGroupMembersCountChanged ( 
 groupId , 
 membersCount = state . membersCount - 1 
 ) 
 } else { 
 - UpdateGroupMembersUpdated ( 
 + UpdateGroupMemberDiff ( 
 groupId , 
 - members = state . members . filterNot ( _ . _ 1 = = cmd . userId ) . values . map ( _ . asStruct ) . toVector 
 + removedUsers = Vector ( cmd . userId ) , 
 + addedMembers = Vector . empty , 
 + membersCount = state . membersCount - 1 
 ) 
 } 
 
 @ @ - 487 , 15 + 527 , 17 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 val updatePermissions = permissionsUpdates ( cmd . kickedUserId , newState ) 
 
 val membersUpdateNew : Update = 
 - if ( newState . groupType . isChannel ) { / / if channel , or group is big enough 
 + if ( newState . isAsyncMembers ) { 
 UpdateGroupMembersCountChanged ( 
 groupId , 
 membersCount = newState . membersCount 
 ) 
 } else { 
 - UpdateGroupMembersUpdated ( 
 + UpdateGroupMemberDiff ( 
 groupId , 
 - members = newState . members . values . map ( _ . asStruct ) . toVector 
 + removedUsers = Vector ( cmd . kickedUserId ) , 
 + addedMembers = Vector . empty , 
 + membersCount = newState . membersCount 
 ) 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / Optimization . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / Optimization . scala 
 index 5e6df96 . . 01f6e81 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / Optimization . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / Optimization . scala 
 @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . server . sequence 
 import com . google . protobuf . ByteString 
 import im . actor . api . rpc . counters . UpdateCountersChanged 
 import im . actor . api . rpc . groups . _ 
 + import im . actor . api . rpc . messaging . UpdateChatDropCache 
 import im . actor . api . rpc . sequence . { ApiUpdateOptimization , UpdateEmptyUpdate } 
 import im . actor . server . messaging . MessageParsing 
 import im . actor . server . model . SerializedUpdate 
 @ @ - 44 , 7 + 45 , 8 @ @ object Optimization extends MessageParsing { 
 UpdateGroupMemberAdminChanged . header , 
 UpdateGroupShortNameChanged . header , 
 UpdateGroupFullPermissionsChanged . header , 
 - UpdateGroupPermissionsChanged . header 
 + UpdateGroupPermissionsChanged . header , 
 + UpdateChatDropCache . header 
 ) 
 if ( deliveryTag = = GroupV2 ) 
 emptyUpdate

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index c3fe238 . . 9794afa 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 8 , 7 + 8 , 7 @ @ import akka . pattern . pipe 
 import im . actor . api . rpc . Update 
 import im . actor . api . rpc . files . ApiAvatar 
 import im . actor . api . rpc . groups . _ 
 - import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessage } 
 + import im . actor . api . rpc . messaging . { ApiMessage , ApiServiceMessage , UpdateMessage } 
 import im . actor . api . rpc . users . ApiSex 
 import im . actor . concurrent . FutureExt 
 import im . actor . server . CommonErrors 
 @ @ - 274 , 22 + 274 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 ) 
 
 - / / push service message to invitee 
 - _ ← pushUpdateMessage ( 
 - userId = cmd . inviteeUserId , 
 - authId = 0L , 
 - ts = dateMillis , 
 - randomId = cmd . randomId , 
 - serviceMessage 
 - ) 
 - 
 - / / push service message to inviter and return seqState 
 - SeqState ( seq , state ) ← pushUpdateMessage ( 
 + / / push service message to invitee and inviter 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 userId = cmd . inviterUserId , 
 authId = cmd . inviterAuthId , 
 - ts = dateMillis , 
 - randomId = cmd . randomId , 
 - serviceMessage 
 + Set ( cmd . inviteeUserId ) , 
 + update = serviceMessageUpdate ( 
 + cmd . inviterUserId , 
 + dateMillis , 
 + cmd . randomId , 
 + serviceMessage 
 + ) 
 ) 
 } yield SeqStateDate ( seq , state , dateMillis ) 
 
 @ @ - 349 , 6 + 344 , 11 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / user was invited in group by other group user 
 val wasInvited = state . isInvited ( cmd . joiningUserId ) 
 
 + / / trying to figure out who invited joining user . 
 + / / Descdending priority : 
 + / / • inviter defined in ` Join ` command ( when invited via token ) 
 + / / • inviter from members list ( when invited by other user ) 
 + / / • group creator ( safe fallback ) 
 val optMember = state . members . get ( cmd . joiningUserId ) 
 val inviterUserId = cmd . invitingUserId 
 . orElse ( optMember . map ( _ . inviterUserId ) ) 
 @ @ - 459 , 13 + 459 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 ) 
 
 - / / push service message to joining user and return seqState 
 - _ ← pushUpdateMessage ( 
 - userId = cmd . joiningUserId , 
 - authId = cmd . joiningUserAuthId , 
 - ts = dateMillis , 
 - randomId = randomId , 
 - serviceMessage 
 + / / push service message only to inviter 
 + _ ← seqUpdExt . deliverUserUpdate ( 
 + userId = inviterUserId , 
 + update = serviceMessageUpdate ( 
 + cmd . joiningUserId , 
 + dateMillis , 
 + randomId , 
 + serviceMessage 
 + ) 
 ) 
 } yield SeqStateDate ( seq , state , dateMillis ) 
 
 @ @ - 581 , 14 + 583 , 19 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 UpdateGroupMembersCountChanged ( groupId , state . membersCount - 1 ) 
 ) 
 
 - / / push service message to left user 
 - _ ← pushUpdateMessage ( 
 - userId = cmd . userId , 
 - authId = cmd . authId , 
 - ts = dateMillis , 
 - randomId = cmd . randomId , 
 - message = serviceMessage 
 - ) 
 + / / push service message to user , who invited leaving user 
 + optInviter = state . members . get ( cmd . userId ) map ( _ . inviterUserId ) 
 + _ ← optInviter map { inviter ⇒ 
 + seqUpdExt . deliverUserUpdate ( 
 + userId = cmd . userId , 
 + update = serviceMessageUpdate ( 
 + cmd . userId , 
 + dateMillis , 
 + cmd . randomId , 
 + serviceMessage 
 + ) 
 + ) 
 + } getOrElse FastFuture . successful ( ( ) ) 
 
 / / push left user that he is no longer a member 
 SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 @ @ - 713 , 22 + 720 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 ) 
 
 - / / push service message to kicker user 
 - _ ← pushUpdateMessage ( 
 - userId = cmd . kickerUserId , 
 - authId = cmd . kickerAuthId , / / ? ? ? what ' s a point ? 
 - ts = dateMillis , 
 - randomId = cmd . randomId , 
 - serviceMessage 
 - ) 
 - 
 - / / push service message to kicked user 
 - _ ← pushUpdateMessage ( 
 - userId = cmd . kickedUserId , 
 - authId = 0L , 
 - ts = dateMillis , 
 - randomId = cmd . randomId , 
 - serviceMessage 
 + / / push service message to kicker and kicked users . 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + userIds = Set ( cmd . kickedUserId , cmd . kickerUserId ) , 
 + update = serviceMessageUpdate ( 
 + cmd . kickerUserId , 
 + dateMillis , 
 + cmd . randomId , 
 + serviceMessage 
 + ) 
 ) 
 
 / / push kicked user updates 
 @ @ - 1147 , 25 + 1147 , 16 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 } 
 
 - / / и л и в с е т а к и б у д е т broadcast ? 
 - private def pushUpdateMessage ( userId : Int , authId : Long , ts : Long , randomId : Long , message : ApiMessage ) : Future [ SeqState ] = { 
 - val messUpdate = UpdateMessage ( 
 + private def serviceMessageUpdate ( senderUserId : Int , date : Long , randomId : Long , message : ApiServiceMessage ) = 
 + UpdateMessage ( 
 peer = apiGroupPeer , 
 - senderUserId = userId , 
 - date = ts , 
 + senderUserId = senderUserId , 
 + date = date , 
 randomId = randomId , 
 message = message , 
 attributes = None , 
 quotedMessage = None 
 ) 
 - seqUpdExt . deliverClientUpdate ( 
 - userId = userId , 
 - authId = authId , 
 - update = messUpdate , 
 - deliveryId = seqUpdExt . msgDeliveryId ( apiGroupPeer . asModel , randomId ) , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 - } 
 
 private def trimToEmpty ( s : Option [ String ] ) : Option [ String ] = 
 s map ( _ . trim ) filter ( _ . nonEmpty ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 index b599ef8 . . adcfb28 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 @ @ - 46 , 8 + 46 , 7 @ @ private [ group ] sealed trait Commands extends UserAcl { 
 def joinGroup ( groupId : Int , joiningUserId : Int , joiningUserAuthId : Long , invitingUserId : Option [ Int ] ) : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = 
 ( processorRegion . ref ? 
 GroupEnvelope ( groupId ) 
 - . withJoin ( Join ( joiningUserId , joiningUserAuthId , invitingUserId = None ) ) / / None ? 
 - ) . mapTo [ ( SeqStateDate , Vector [ Int ] , Long ) ] 
 + . withJoin ( Join ( joiningUserId , joiningUserAuthId , invitingUserId = invitingUserId ) ) ) . mapTo [ ( SeqStateDate , Vector [ Int ] , Long ) ] 
 
 def inviteToGroup ( groupId : Int , inviteeUserId : Int , randomId : Long ) ( implicit client : AuthorizedClientData ) : Future [ SeqStateDate ] = 
 inviteToGroup ( client . userId , client . authId , groupId , inviteeUserId , randomId ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 index 1500067 . . 2e390f8 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 @ @ - 122 , 7 + 122 , 7 @ @ trait GroupQueryHandlers { 
 canViewMembers = Some ( state . canViewMembers ( clientUserId ) ) , 
 canInvitePeople = Some ( state . canInvitePeople ( clientUserId ) ) , 
 isSharedHistory = Some ( state . isHistoryShared ) , 
 - isAsyncMembers = Some ( state . members . size > 100 ) , 
 + isAsyncMembers = Some ( state . isAsyncMembers ) , 
 members = membersAndCount ( state , clientUserId ) . _ 1 
 ) 
 ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 index 5844d86 . . 77ed12f 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 @ @ - 116 , 6 + 116 , 12 @ @ private [ group ] final case class GroupState ( 
 
 def isCreated = createdAt . nonEmpty / / TODO : Maybe val . immutable anyway 
 
 + def isAsyncMembers = 
 + typ match { 
 + case General | Public ⇒ members . size > 100 
 + case Channel ⇒ true 
 + } 
 + 
 override def updated ( e : Event ) : GroupState = e match { 
 case evt : Created ⇒ 
 this . copy (
