BLEU SCORE: 0.054129891865452646

TEST MSG: fix ( server : bots ) : allow to use streaming text message in bot requests
GENERATED MSG: feat ( http - api ) : CORS headers

TEST DIFF (one line): diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > index 7f8fb24 . . 6a121e5 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > @ @ - 3 , 9 + 3 , 8 @ @ package im . actor . server . api . http . bots < nl > import java . util . Base64 < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . event . Logging < nl > import akka . http . scaladsl . model . StatusCodes . _ < nl > - import akka . http . scaladsl . model . ws . { Message , TextMessage } < nl > + import akka . http . scaladsl . model . ws . { BinaryMessage , TextMessage , Message } < nl > import akka . http . scaladsl . model . { HttpMethod , StatusCode } < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . Route < nl > @ @ - 134 , 13 + 133 , 14 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > val bp = new BotServerBlueprint ( botUserId , botAuthId , botAuthSid , system ) < nl > < nl > Flow [ Message ] < nl > - . collect { < nl > - case TextMessage . Strict ( text ) ⇒ < nl > - log . debug ( " < < { } " , text ) < nl > - val rq = read [ BotRequest ] ( text ) < nl > + . mapAsync ( 1 ) { < nl > + case tm : TextMessage ⇒ tm . textStream . runFold ( " " ) ( _ + + _ ) map { fullContent ⇒ < nl > + log . debug ( " < < { } " , fullContent ) < nl > + val rq = read [ BotRequest ] ( fullContent ) < nl > log . debug ( " Bot request : { } , userId : { } " , rq , botUserId ) < nl > rq < nl > - case tm : TextMessage ⇒ throw new RuntimeException ( " Streamed text message is not supported " ) with NoStackTrace < nl > + } < nl > + case bm : BinaryMessage ⇒ throw new RuntimeException ( " Binary message is not supported " ) with NoStackTrace < nl > } < nl > . via ( bp . flow ) < nl > . map {
NEAREST DIFF (one line): diff - - git a / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala b / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala < nl > index 894595a . . 95297cf 100644 < nl > - - - a / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala < nl > + + + b / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala < nl > @ @ - 4 , 8 + 4 , 11 @ @ import scala . concurrent . ExecutionContext < nl > < nl > import akka . actor . ActorSystem < nl > import akka . http . scaladsl . Http < nl > + import akka . http . scaladsl . _ < nl > + import akka . http . scaladsl . model . headers . _ < nl > + import akka . http . scaladsl . model . HttpMethods . _ < nl > import akka . http . scaladsl . server . Directives . _ < nl > - import akka . http . scaladsl . server . Route < nl > + import akka . http . scaladsl . server . { RouteResult , Route } < nl > import akka . stream . FlowMaterializer < nl > import com . github . dwhjames . awswrap . s3 . AmazonS3ScalaClient < nl > import slick . driver . PostgresDriver . api . _ < nl > @ @ - 34 , 6 + 37 , 17 @ @ object HttpApiFrontend { < nl > < nl > def routes : Route = pathPrefix ( " v1 " ) { < nl > status . routes ~ groups . routes ~ webhooks . routes < nl > + } . andThen { r ⇒ < nl > + r . map { < nl > + case RouteResult . Complete ( res ) ⇒ < nl > + RouteResult . Complete ( res . withHeaders ( res . headers + + Seq ( < nl > + ` Access - Control - Allow - Origin ` . ` * ` , < nl > + ` Access - Control - Allow - Methods ` ( GET , POST ) , < nl > + ` Access - Control - Allow - Headers ` ( " * " ) , < nl > + ` Access - Control - Allow - Credentials ` ( true ) < nl > + ) ) ) < nl > + case m ⇒ m < nl > + } < nl > } < nl > < nl > Http ( ) . bind ( config . interface , config . port ) . runForeach { connection ⇒

TEST DIFF:
diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 index 7f8fb24 . . 6a121e5 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 @ @ - 3 , 9 + 3 , 8 @ @ package im . actor . server . api . http . bots 
 import java . util . Base64 
 
 import akka . actor . ActorSystem 
 - import akka . event . Logging 
 import akka . http . scaladsl . model . StatusCodes . _ 
 - import akka . http . scaladsl . model . ws . { Message , TextMessage } 
 + import akka . http . scaladsl . model . ws . { BinaryMessage , TextMessage , Message } 
 import akka . http . scaladsl . model . { HttpMethod , StatusCode } 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . Route 
 @ @ - 134 , 13 + 133 , 14 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 val bp = new BotServerBlueprint ( botUserId , botAuthId , botAuthSid , system ) 
 
 Flow [ Message ] 
 - . collect { 
 - case TextMessage . Strict ( text ) ⇒ 
 - log . debug ( " < < { } " , text ) 
 - val rq = read [ BotRequest ] ( text ) 
 + . mapAsync ( 1 ) { 
 + case tm : TextMessage ⇒ tm . textStream . runFold ( " " ) ( _ + + _ ) map { fullContent ⇒ 
 + log . debug ( " < < { } " , fullContent ) 
 + val rq = read [ BotRequest ] ( fullContent ) 
 log . debug ( " Bot request : { } , userId : { } " , rq , botUserId ) 
 rq 
 - case tm : TextMessage ⇒ throw new RuntimeException ( " Streamed text message is not supported " ) with NoStackTrace 
 + } 
 + case bm : BinaryMessage ⇒ throw new RuntimeException ( " Binary message is not supported " ) with NoStackTrace 
 } 
 . via ( bp . flow ) 
 . map {

NEAREST DIFF:
diff - - git a / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala b / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala 
 index 894595a . . 95297cf 100644 
 - - - a / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala 
 + + + b / actor - http - api / src / main / scala / im / actor / server / api / http / HttpApiFrontend . scala 
 @ @ - 4 , 8 + 4 , 11 @ @ import scala . concurrent . ExecutionContext 
 
 import akka . actor . ActorSystem 
 import akka . http . scaladsl . Http 
 + import akka . http . scaladsl . _ 
 + import akka . http . scaladsl . model . headers . _ 
 + import akka . http . scaladsl . model . HttpMethods . _ 
 import akka . http . scaladsl . server . Directives . _ 
 - import akka . http . scaladsl . server . Route 
 + import akka . http . scaladsl . server . { RouteResult , Route } 
 import akka . stream . FlowMaterializer 
 import com . github . dwhjames . awswrap . s3 . AmazonS3ScalaClient 
 import slick . driver . PostgresDriver . api . _ 
 @ @ - 34 , 6 + 37 , 17 @ @ object HttpApiFrontend { 
 
 def routes : Route = pathPrefix ( " v1 " ) { 
 status . routes ~ groups . routes ~ webhooks . routes 
 + } . andThen { r ⇒ 
 + r . map { 
 + case RouteResult . Complete ( res ) ⇒ 
 + RouteResult . Complete ( res . withHeaders ( res . headers + + Seq ( 
 + ` Access - Control - Allow - Origin ` . ` * ` , 
 + ` Access - Control - Allow - Methods ` ( GET , POST ) , 
 + ` Access - Control - Allow - Headers ` ( " * " ) , 
 + ` Access - Control - Allow - Credentials ` ( true ) 
 + ) ) ) 
 + case m ⇒ m 
 + } 
 } 
 
 Http ( ) . bind ( config . interface , config . port ) . runForeach { connection ⇒
