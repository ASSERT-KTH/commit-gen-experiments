BLEU SCORE: 0.09578464408619825

TEST MSG: feat ( server : bots ) : add update message content capability
GENERATED MSG: test ( server ) : EchoBotSpec

TEST DIFF (one line): diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > index 6a28636 . . 2488aae 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > @ @ - 1 , 19 + 1 , 39 @ @ < nl > package im . actor . server . bot . services < nl > < nl > import akka . actor . ActorSystem < nl > - import im . actor . server . bot . { BotToApiConversions , BotServiceBase } < nl > + import im . actor . api . rpc . PeersImplicits < nl > + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } < nl > + import im . actor . bots . BotMessages . BotError < nl > + import im . actor . concurrent . FutureResultCats < nl > + import im . actor . server . bot . { BotServiceBase , BotToApiConversions } < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . DialogExtension < nl > + import im . actor . server . group . GroupExtension < nl > + import im . actor . server . model . { Peer ⇒ ModelPeer , PeerType } < nl > + import im . actor . server . persist . HistoryMessageRepo < nl > import im . actor . server . sequence . SeqStateDate < nl > < nl > - private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) with BotToApiConversions { < nl > + import scala . concurrent . Future < nl > < nl > + private [ bot ] object MessagingBotErrors { < nl > + val Forbidden = BotError ( 403 , " FORBIDDEN " ) < nl > + } < nl > + < nl > + private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) < nl > + with FutureResultCats [ BotError ] < nl > + with BotToApiConversions < nl > + with PeersImplicits { < nl > + < nl > + import MessagingBotErrors . _ < nl > import im . actor . bots . BotMessages . _ < nl > import system . dispatcher < nl > < nl > private lazy val dialogExt = DialogExtension ( system ) < nl > + private lazy val db = DbExtension ( system ) . db < nl > < nl > override val handlers : PartialFunction [ RequestBody , WeakRequestHandler ] = { < nl > - case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak < nl > + case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak < nl > + case UpdateMessageContent ( peer , randomId , message ) ⇒ updateMessageContent ( peer , randomId , message ) . toWeak < nl > } < nl > < nl > private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( < nl > @ @ - 32 , 4 + 52 , 66 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer < nl > } yield Right ( MessageSent ( date ) ) < nl > } < nl > ) < nl > + < nl > + / / allow bot to update only it ' s messages . Bot won ' t not be able to modify user ' s messages < nl > + private def updateMessageContent ( peer : OutPeer , randomId : Long , updatedMessage : MessageBody ) = RequestHandler [ UpdateMessageContent , UpdateMessageContent # Response ] ( < nl > + ( botUserId : BotUserId , botAuthId : BotAuthId , botAuthSid : BotAuthSid ) ⇒ { < nl > + val peerModel = toPeer ( peer ) . asModel < nl > + val botPeer = ModelPeer . privat ( botUserId ) < nl > + ( for { < nl > + _ ← fromFutureBoolean ( Forbidden ) ( db . run ( HistoryMessageRepo . findBySender ( botUserId , peerModel , randomId ) . headOption map ( _ . nonEmpty ) ) ) < nl > + _ ← fromFuture ( peer match { < nl > + case UserOutPeer ( userId , _ ) ⇒ updateContentPrivate ( peerModel . id , botPeer , randomId , updatedMessage ) < nl > + case GroupOutPeer ( groupId , _ ) ⇒ updateContentGroup ( botUserId , peerModel , randomId , updatedMessage ) < nl > + } ) < nl > + } yield MessageContentUpdated ) . value < nl > + } < nl > + ) < nl > + < nl > + private def updateContentPrivate ( userId : Int , botPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { < nl > + val upd = UpdateMessageContentChanged ( botPeer . asStruct , randomId , updatedMessage ) < nl > + for { < nl > + _ ← userExt . broadcastUserUpdate ( < nl > + userId = userId , < nl > + update = upd , < nl > + pushText = None , < nl > + isFat = false , < nl > + reduceKey = None , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > + userIds = Set ( userId , botPeer . id ) , < nl > + randomId = randomId , < nl > + peerType = PeerType . Private , < nl > + peerIds = Set ( userId , botPeer . id ) , < nl > + messageContentHeader = updatedMessage . header , < nl > + messageContentData = updatedMessage . toByteArray < nl > + ) ) < nl > + } yield ( ) < nl > + } < nl > + < nl > + private def updateContentGroup ( botUserId : Int , groupPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { < nl > + / / no need to send update to bot itself < nl > + val upd = UpdateMessageContentChanged ( groupPeer . asStruct , randomId , updatedMessage ) < nl > + for { < nl > + ( memberIds , _ , _ ) ← GroupExtension ( system ) . getMemberIds ( groupPeer . id ) < nl > + membersSet = memberIds . toSet < nl > + _ ← userExt . broadcastUsersUpdate ( < nl > + userIds = membersSet , < nl > + update = upd , < nl > + pushText = None , < nl > + isFat = false , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > + userIds = membersSet + botUserId , < nl > + randomId = randomId , < nl > + peerType = PeerType . Group , < nl > + peerIds = Set ( groupPeer . id ) , < nl > + messageContentHeader = updatedMessage . header , < nl > + messageContentData = updatedMessage . toByteArray < nl > + ) ) < nl > + } yield ( ) < nl > + } < nl > + < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 0eceef8 . . 2907ae8 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 5 , 7 + 5 , 7 @ @ import sbt . _ < nl > object Dependencies { < nl > object V { < nl > val actorCommons = " 0 . 0 . 13 " < nl > - val actorBotkit = " 1 . 0 . 72 " < nl > + val actorBotkit = " 1 . 0 . 75 " < nl > val akka = " 2 . 4 . 2 - RC2 " < nl > val akkaHttpJson = " 1 . 5 . 0 " < nl > val cats = " 0 . 3 . 0 "
NEAREST DIFF (one line): diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > index 99cc45c . . b9c0468 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > @ @ - 19 , 7 + 19 , 6 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer < nl > private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( < nl > ( botUserId : BotUserId , botAuthId : BotAuthId ) ⇒ { < nl > / / FIXME : check access hash < nl > - < nl > for { < nl > SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( < nl > peer = peer , < nl > diff - - git a / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala b / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 1cfae41 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala < nl > @ @ - 0 , 0 + 1 , 109 @ @ < nl > + package im . actor . server . bot < nl > + < nl > + import akka . actor . { Props , ActorSystem } < nl > + import im . actor . api . rpc . ClientData < nl > + import im . actor . api . rpc . messaging . { ResponseLoadHistory , ApiTextMessage } < nl > + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType , ApiPeer } < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > + import im . actor . server . dialog . DialogExtension < nl > + import im . actor . server . _ < nl > + import org . scalatest . Inside . _ < nl > + < nl > + import scala . util . Random < nl > + < nl > + object EchoBot { < nl > + val UserId = 100 < nl > + < nl > + def start ( ) ( implicit system : ActorSystem ) = system . actorOf ( props , " EchoBot " ) < nl > + < nl > + private def props = Props ( classOf [ EchoBot ] ) < nl > + } < nl > + < nl > + final class EchoBot extends InternalBot ( EchoBot . UserId , " echo " , " Echo Bot " , isAdmin = false ) { < nl > + import im . actor . bots . BotMessages . _ < nl > + < nl > + override def onMessage ( m : Message ) : Unit = { < nl > + m . message match { < nl > + case TextMessage ( text ) ⇒ < nl > + requestSendMessage ( m . peer , nextRandomId ( ) , TextMessage ( text ) ) < nl > + case _ ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + final class EchoBotSpec < nl > + extends BaseAppSuite < nl > + with ServiceSpecHelpers < nl > + with GroupsServiceHelpers < nl > + with ImplicitAuthService < nl > + with ImplicitSessionRegionProxy { < nl > + it should " reply with the same message ( private ) " in replyPrivate < nl > + it should " reply with the same message ( group ) " in replyGroup < nl > + < nl > + private lazy val dialogExt = DialogExtension ( system ) < nl > + private lazy val msgService = MessagingServiceImpl ( ) < nl > + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > + < nl > + def replyPrivate ( ) = { < nl > + val ( user , authId , _ ) = createUser ( ) < nl > + < nl > + Thread . sleep ( 1000 ) < nl > + < nl > + whenReady ( dialogExt . sendMessage ( < nl > + peer = ApiPeer ( ApiPeerType . Private , EchoBot . UserId ) , < nl > + senderUserId = user . id , < nl > + senderAuthId = authId , < nl > + randomId = Random . nextLong ( ) , < nl > + message = ApiTextMessage ( " Hello " , Vector . empty , None ) , < nl > + isFat = false < nl > + ) ) ( identity ) < nl > + < nl > + Thread . sleep ( 2000 ) < nl > + < nl > + implicit val clientData = ClientData ( authId , Random . nextLong ( ) , Some ( user . id ) ) < nl > + < nl > + val botOutPeer = getOutPeer ( EchoBot . UserId , authId ) < nl > + < nl > + whenReady ( msgService . handleLoadHistory ( botOutPeer , 0 , 100 ) ) { rsp ⇒ < nl > + inside ( rsp ) { < nl > + case Ok ( ResponseLoadHistory ( history , _ ) ) ⇒ < nl > + history . length shouldBe ( 2 ) < nl > + val tm = history . last . message . asInstanceOf [ ApiTextMessage ] < nl > + tm . text shouldBe " Hello " < nl > + } < nl > + } < nl > + } < nl > + < nl > + def replyGroup ( ) = { < nl > + val ( user , authId , _ ) = createUser ( ) < nl > + implicit val clientData = ClientData ( authId , 1 , Some ( user . id ) ) < nl > + val groupPeer = createGroup ( " Echo group " , Set ( EchoBot . UserId ) ) . groupPeer < nl > + val outPeer = ApiOutPeer ( ApiPeerType . Group , groupPeer . groupId , groupPeer . accessHash ) < nl > + < nl > + whenReady ( dialogExt . sendMessage ( < nl > + peer = ApiPeer ( ApiPeerType . Group , groupPeer . groupId ) , < nl > + senderUserId = user . id , < nl > + senderAuthId = authId , < nl > + randomId = Random . nextLong ( ) , < nl > + message = ApiTextMessage ( " Hello " , Vector . empty , None ) , < nl > + isFat = false < nl > + ) ) ( identity ) < nl > + < nl > + Thread . sleep ( 2000 ) < nl > + < nl > + whenReady ( msgService . handleLoadHistory ( outPeer , 0 , 100 ) ) { rsp ⇒ < nl > + inside ( rsp ) { < nl > + case Ok ( ResponseLoadHistory ( history , _ ) ) ⇒ < nl > + history . length shouldBe 4 < nl > + val tm = history . last . message . asInstanceOf [ ApiTextMessage ] < nl > + tm . text shouldBe " Hello " < nl > + } < nl > + } < nl > + } < nl > + < nl > + override def beforeAll = { < nl > + EchoBot . start ( ) < nl > + } < nl > + } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 index 6a28636 . . 2488aae 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 @ @ - 1 , 19 + 1 , 39 @ @ 
 package im . actor . server . bot . services 
 
 import akka . actor . ActorSystem 
 - import im . actor . server . bot . { BotToApiConversions , BotServiceBase } 
 + import im . actor . api . rpc . PeersImplicits 
 + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } 
 + import im . actor . bots . BotMessages . BotError 
 + import im . actor . concurrent . FutureResultCats 
 + import im . actor . server . bot . { BotServiceBase , BotToApiConversions } 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . DialogExtension 
 + import im . actor . server . group . GroupExtension 
 + import im . actor . server . model . { Peer ⇒ ModelPeer , PeerType } 
 + import im . actor . server . persist . HistoryMessageRepo 
 import im . actor . server . sequence . SeqStateDate 
 
 - private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) with BotToApiConversions { 
 + import scala . concurrent . Future 
 
 + private [ bot ] object MessagingBotErrors { 
 + val Forbidden = BotError ( 403 , " FORBIDDEN " ) 
 + } 
 + 
 + private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) 
 + with FutureResultCats [ BotError ] 
 + with BotToApiConversions 
 + with PeersImplicits { 
 + 
 + import MessagingBotErrors . _ 
 import im . actor . bots . BotMessages . _ 
 import system . dispatcher 
 
 private lazy val dialogExt = DialogExtension ( system ) 
 + private lazy val db = DbExtension ( system ) . db 
 
 override val handlers : PartialFunction [ RequestBody , WeakRequestHandler ] = { 
 - case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak 
 + case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak 
 + case UpdateMessageContent ( peer , randomId , message ) ⇒ updateMessageContent ( peer , randomId , message ) . toWeak 
 } 
 
 private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( 
 @ @ - 32 , 4 + 52 , 66 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer 
 } yield Right ( MessageSent ( date ) ) 
 } 
 ) 
 + 
 + / / allow bot to update only it ' s messages . Bot won ' t not be able to modify user ' s messages 
 + private def updateMessageContent ( peer : OutPeer , randomId : Long , updatedMessage : MessageBody ) = RequestHandler [ UpdateMessageContent , UpdateMessageContent # Response ] ( 
 + ( botUserId : BotUserId , botAuthId : BotAuthId , botAuthSid : BotAuthSid ) ⇒ { 
 + val peerModel = toPeer ( peer ) . asModel 
 + val botPeer = ModelPeer . privat ( botUserId ) 
 + ( for { 
 + _ ← fromFutureBoolean ( Forbidden ) ( db . run ( HistoryMessageRepo . findBySender ( botUserId , peerModel , randomId ) . headOption map ( _ . nonEmpty ) ) ) 
 + _ ← fromFuture ( peer match { 
 + case UserOutPeer ( userId , _ ) ⇒ updateContentPrivate ( peerModel . id , botPeer , randomId , updatedMessage ) 
 + case GroupOutPeer ( groupId , _ ) ⇒ updateContentGroup ( botUserId , peerModel , randomId , updatedMessage ) 
 + } ) 
 + } yield MessageContentUpdated ) . value 
 + } 
 + ) 
 + 
 + private def updateContentPrivate ( userId : Int , botPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { 
 + val upd = UpdateMessageContentChanged ( botPeer . asStruct , randomId , updatedMessage ) 
 + for { 
 + _ ← userExt . broadcastUserUpdate ( 
 + userId = userId , 
 + update = upd , 
 + pushText = None , 
 + isFat = false , 
 + reduceKey = None , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 + userIds = Set ( userId , botPeer . id ) , 
 + randomId = randomId , 
 + peerType = PeerType . Private , 
 + peerIds = Set ( userId , botPeer . id ) , 
 + messageContentHeader = updatedMessage . header , 
 + messageContentData = updatedMessage . toByteArray 
 + ) ) 
 + } yield ( ) 
 + } 
 + 
 + private def updateContentGroup ( botUserId : Int , groupPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { 
 + / / no need to send update to bot itself 
 + val upd = UpdateMessageContentChanged ( groupPeer . asStruct , randomId , updatedMessage ) 
 + for { 
 + ( memberIds , _ , _ ) ← GroupExtension ( system ) . getMemberIds ( groupPeer . id ) 
 + membersSet = memberIds . toSet 
 + _ ← userExt . broadcastUsersUpdate ( 
 + userIds = membersSet , 
 + update = upd , 
 + pushText = None , 
 + isFat = false , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 + userIds = membersSet + botUserId , 
 + randomId = randomId , 
 + peerType = PeerType . Group , 
 + peerIds = Set ( groupPeer . id ) , 
 + messageContentHeader = updatedMessage . header , 
 + messageContentData = updatedMessage . toByteArray 
 + ) ) 
 + } yield ( ) 
 + } 
 + 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 0eceef8 . . 2907ae8 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 5 , 7 + 5 , 7 @ @ import sbt . _ 
 object Dependencies { 
 object V { 
 val actorCommons = " 0 . 0 . 13 " 
 - val actorBotkit = " 1 . 0 . 72 " 
 + val actorBotkit = " 1 . 0 . 75 " 
 val akka = " 2 . 4 . 2 - RC2 " 
 val akkaHttpJson = " 1 . 5 . 0 " 
 val cats = " 0 . 3 . 0 "

NEAREST DIFF:
diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 index 99cc45c . . b9c0468 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 @ @ - 19 , 7 + 19 , 6 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer 
 private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( 
 ( botUserId : BotUserId , botAuthId : BotAuthId ) ⇒ { 
 / / FIXME : check access hash 
 - 
 for { 
 SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( 
 peer = peer , 
 diff - - git a / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala b / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala 
 new file mode 100644 
 index 0000000 . . 1cfae41 
 - - - / dev / null 
 + + + b / actor - server / actor - bots / src / test / scala / im / actor / server / bot / EchoBotSpec . scala 
 @ @ - 0 , 0 + 1 , 109 @ @ 
 + package im . actor . server . bot 
 + 
 + import akka . actor . { Props , ActorSystem } 
 + import im . actor . api . rpc . ClientData 
 + import im . actor . api . rpc . messaging . { ResponseLoadHistory , ApiTextMessage } 
 + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType , ApiPeer } 
 + import im . actor . api . rpc . _ 
 + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 + import im . actor . server . dialog . DialogExtension 
 + import im . actor . server . _ 
 + import org . scalatest . Inside . _ 
 + 
 + import scala . util . Random 
 + 
 + object EchoBot { 
 + val UserId = 100 
 + 
 + def start ( ) ( implicit system : ActorSystem ) = system . actorOf ( props , " EchoBot " ) 
 + 
 + private def props = Props ( classOf [ EchoBot ] ) 
 + } 
 + 
 + final class EchoBot extends InternalBot ( EchoBot . UserId , " echo " , " Echo Bot " , isAdmin = false ) { 
 + import im . actor . bots . BotMessages . _ 
 + 
 + override def onMessage ( m : Message ) : Unit = { 
 + m . message match { 
 + case TextMessage ( text ) ⇒ 
 + requestSendMessage ( m . peer , nextRandomId ( ) , TextMessage ( text ) ) 
 + case _ ⇒ 
 + } 
 + } 
 + } 
 + 
 + final class EchoBotSpec 
 + extends BaseAppSuite 
 + with ServiceSpecHelpers 
 + with GroupsServiceHelpers 
 + with ImplicitAuthService 
 + with ImplicitSessionRegionProxy { 
 + it should " reply with the same message ( private ) " in replyPrivate 
 + it should " reply with the same message ( group ) " in replyGroup 
 + 
 + private lazy val dialogExt = DialogExtension ( system ) 
 + private lazy val msgService = MessagingServiceImpl ( ) 
 + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 + 
 + def replyPrivate ( ) = { 
 + val ( user , authId , _ ) = createUser ( ) 
 + 
 + Thread . sleep ( 1000 ) 
 + 
 + whenReady ( dialogExt . sendMessage ( 
 + peer = ApiPeer ( ApiPeerType . Private , EchoBot . UserId ) , 
 + senderUserId = user . id , 
 + senderAuthId = authId , 
 + randomId = Random . nextLong ( ) , 
 + message = ApiTextMessage ( " Hello " , Vector . empty , None ) , 
 + isFat = false 
 + ) ) ( identity ) 
 + 
 + Thread . sleep ( 2000 ) 
 + 
 + implicit val clientData = ClientData ( authId , Random . nextLong ( ) , Some ( user . id ) ) 
 + 
 + val botOutPeer = getOutPeer ( EchoBot . UserId , authId ) 
 + 
 + whenReady ( msgService . handleLoadHistory ( botOutPeer , 0 , 100 ) ) { rsp ⇒ 
 + inside ( rsp ) { 
 + case Ok ( ResponseLoadHistory ( history , _ ) ) ⇒ 
 + history . length shouldBe ( 2 ) 
 + val tm = history . last . message . asInstanceOf [ ApiTextMessage ] 
 + tm . text shouldBe " Hello " 
 + } 
 + } 
 + } 
 + 
 + def replyGroup ( ) = { 
 + val ( user , authId , _ ) = createUser ( ) 
 + implicit val clientData = ClientData ( authId , 1 , Some ( user . id ) ) 
 + val groupPeer = createGroup ( " Echo group " , Set ( EchoBot . UserId ) ) . groupPeer 
 + val outPeer = ApiOutPeer ( ApiPeerType . Group , groupPeer . groupId , groupPeer . accessHash ) 
 + 
 + whenReady ( dialogExt . sendMessage ( 
 + peer = ApiPeer ( ApiPeerType . Group , groupPeer . groupId ) , 
 + senderUserId = user . id , 
 + senderAuthId = authId , 
 + randomId = Random . nextLong ( ) , 
 + message = ApiTextMessage ( " Hello " , Vector . empty , None ) , 
 + isFat = false 
 + ) ) ( identity ) 
 + 
 + Thread . sleep ( 2000 ) 
 + 
 + whenReady ( msgService . handleLoadHistory ( outPeer , 0 , 100 ) ) { rsp ⇒ 
 + inside ( rsp ) { 
 + case Ok ( ResponseLoadHistory ( history , _ ) ) ⇒ 
 + history . length shouldBe 4 
 + val tm = history . last . message . asInstanceOf [ ApiTextMessage ] 
 + tm . text shouldBe " Hello " 
 + } 
 + } 
 + } 
 + 
 + override def beforeAll = { 
 + EchoBot . start ( ) 
 + } 
 + } 
 \ No newline at end of file
