BLEU SCORE: 0.016932492841722675

TEST MSG: perf ( server : messaging ) : discrete auto - archiving process
GENERATED MSG: Merge commit ' f00ab49f9c9dafbfbb8bb1bbde9a175419cb5650 '

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 56319de . . f0eb159 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 246 , 12 + 246 , 12 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > < nl > def isSharedUser ( userId : Int ) : Boolean = userId = = 0 < nl > < nl > - def getGroupedDialogs ( userId : Int ) = { < nl > + def fetchGroupedDialogs ( userId : Int ) : Future [ Map [ DialogGroup , Vector [ Dialog ] ] ] = < nl > db . run { < nl > DialogRepo < nl > . fetchSortByLastMessageData ( userId , None , Int . MaxValue ) < nl > . map ( _ filterNot ( dialogWithSelf ( userId , _ ) ) ) < nl > - . flatMap { dialogs ⇒ < nl > + . map { dialogs ⇒ < nl > val ( groupModels , privateModels , favouriteModels ) = < nl > dialogs . foldLeft ( ( Vector . empty [ Dialog ] , Vector . empty [ Dialog ] , Vector . empty [ Dialog ] ) ) { < nl > case ( ( groupModels , privateModels , favouriteModels ) , dialog ) ⇒ < nl > @ @ - 264 , 22 + 264 , 37 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > else throw new RuntimeException ( " Unknown dialog type " ) < nl > } < nl > < nl > - for { < nl > - groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) < nl > - privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) < nl > - favouriteDialogs ← DBIO . sequence ( favouriteModels map getDialogShort ) < nl > - } yield { < nl > - val default = Vector ( < nl > - ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , < nl > - ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) < nl > - ) < nl > - < nl > - if ( favouriteDialogs . nonEmpty ) < nl > - ApiDialogGroup ( DialogGroups . Favourites . title , DialogGroups . Favourites . key , favouriteDialogs ) + : default < nl > - else default < nl > - } < nl > + Map ( < nl > + DialogGroups . Favourites → favouriteModels , < nl > + DialogGroups . Privates → privateModels , < nl > + DialogGroups . Groups → groupModels < nl > + ) < nl > } < nl > } < nl > + < nl > + def fetchGroupedDialogShorts ( userId : Int ) : Future [ Vector [ ApiDialogGroup ] ] = { < nl > + fetchGroupedDialogs ( userId ) flatMap { dialogsMap ⇒ < nl > + db . run { < nl > + val groupModels = dialogsMap . getOrElse ( DialogGroups . Groups , Vector . empty ) < nl > + val privateModels = dialogsMap . getOrElse ( DialogGroups . Privates , Vector . empty ) < nl > + val favouriteModels = dialogsMap . getOrElse ( DialogGroups . Favourites , Vector . empty ) < nl > + < nl > + for { < nl > + groupDialogs ← DBIO . sequence ( groupModels map getDialogShortDBIO ) < nl > + privateDialogs ← DBIO . sequence ( privateModels map getDialogShortDBIO ) < nl > + favouriteDialogs ← DBIO . sequence ( favouriteModels map getDialogShortDBIO ) < nl > + } yield { < nl > + val default = Vector ( < nl > + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , < nl > + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs ) < nl > + ) < nl > + < nl > + if ( favouriteDialogs . nonEmpty ) < nl > + ApiDialogGroup ( DialogGroups . Favourites . title , DialogGroups . Favourites . key , favouriteDialogs ) + : default < nl > + else default < nl > + } < nl > + } < nl > + } < nl > } < nl > < nl > def dialogWithSelf ( userId : Int , dialog : Dialog ) : Boolean = < nl > @ @ - 299 , 7 + 314 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > } ) . toSeq < nl > } < nl > < nl > - private def getDialogShort ( dialog : Dialog ) ( implicit ec : ExecutionContext ) : DBIO [ ApiDialogShort ] = < nl > + def getDialogShortDBIO ( dialog : Dialog ) ( implicit ec : ExecutionContext ) : DBIO [ ApiDialogShort ] = < nl > for { < nl > historyOwner ← DBIO . from ( HistoryUtils . getHistoryOwner ( dialog . peer , dialog . userId ) ) < nl > messageOpt ← HistoryMessageRepo . findNewest ( historyOwner , dialog . peer ) map ( _ . map ( _ . ofUser ( dialog . userId ) ) ) < nl > @ @ - 310 , 6 + 325 , 9 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > date = messageOpt . map ( _ . date . getMillis ) . getOrElse ( 0 ) < nl > ) < nl > < nl > + def getDialogShort ( dialog : Dialog ) ( implicit ec : ExecutionContext ) : Future [ ApiDialogShort ] = < nl > + db . run ( getDialogShortDBIO ( dialog ) ) < nl > + < nl > private def processorRegion ( peer : Peer ) : ActorRef = peer . typ match { < nl > case PeerType . Private ⇒ < nl > userExt . processorRegion . ref / / to user peer < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 818cbe7 . . 6a931fd 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 304 , 7 + 304 , 7 @ @ private [ user ] trait UserCommandHandlers { < nl > < nl > protected def notifyDialogsChanged ( user : UserState ) : Unit = { < nl > ( for { < nl > - shortDialogs ← dialogExt . getGroupedDialogs ( user . id ) < nl > + shortDialogs ← dialogExt . fetchGroupedDialogShorts ( user . id ) < nl > seqstate ← seqUpdatesExt . deliverSingleUpdate ( user . id , UpdateChatGroupsChanged ( shortDialogs ) , reduceKey = Some ( " chat _ groups _ changed " ) ) < nl > } yield seqstate ) pipeTo sender ( ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > index 2400693 . . 30f2c8b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > @ @ - 5 , 16 + 5 , 18 @ @ import java . time . { Instant , Period } < nl > import akka . actor . { ActorRef , Props } < nl > import im . actor . api . rpc . PeersImplicits < nl > import im . actor . api . rpc . misc . ApiExtension < nl > - import im . actor . concurrent . AlertingActor < nl > + import im . actor . concurrent . { AlertingActor , FutureExt } < nl > import im . actor . server . dialog . _ < nl > - import im . actor . server . model . { Peer , PeerType } < nl > + import im . actor . server . model . { Dialog , Peer , PeerType } < nl > < nl > import scala . concurrent . duration . _ < nl > < nl > private [ user ] object UserPeer { < nl > def props ( userId : Int , extensions : Seq [ ApiExtension ] ) = Props ( classOf [ UserPeer ] , userId , extensions ) < nl > < nl > - private case object Archive < nl > + private case object StartArchiving < nl > + private case class ArchiveIfExpired ( dialogs : Seq [ Dialog ] ) < nl > + private case class Archive ( peer : Peer ) < nl > } < nl > < nl > private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) extends AlertingActor with PeersImplicits { < nl > @ @ - 24 , 7 + 26 , 7 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e < nl > private val selfPeer = Peer . privat ( userId ) < nl > < nl > private val dialogExt = DialogExtension ( context . system ) < nl > - private val archiveInterval = context . system . scheduler . schedule ( 0 . seconds , 1 . hour , self , Archive ) < nl > + private val archiveInterval = context . system . scheduler . schedule ( 0 . seconds , 1 . hour , self , StartArchiving ) < nl > < nl > override def postStop ( ) : Unit = { < nl > super . postStop ( ) < nl > @ @ - 33 , 10 + 35 , 12 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e < nl > < nl > def receive : Receive = { < nl > / / Forward to a group or a corresponding user dialog < nl > - case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc < nl > + case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc < nl > / / Forward to a dest user dialog < nl > - case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc < nl > - case Archive ⇒ archive ( ) < nl > + case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc < nl > + case StartArchiving ⇒ startArchiving ( ) < nl > + case ArchiveIfExpired ( dialogs ) ⇒ archiveIfExpired ( dialogs ) < nl > + case Archive ( peer ) ⇒ archive ( peer ) < nl > } < nl > < nl > private def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { < nl > @ @ - 56 , 17 + 60 , 25 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e < nl > case other ⇒ throw new Exception ( s " Unknown peer type : $ other " ) < nl > } < nl > < nl > - private def archive ( ) : Unit = { < nl > + private def startArchiving ( ) : Unit = { < nl > for { < nl > - dialogs ← dialogExt . getGroupedDialogs ( userId ) map ( _ filterNot ( _ . key = = DialogGroups . Favourites . key ) flatMap ( _ . dialogs ) ) < nl > - } yield { < nl > - val toArchive = dialogs filter ( d ⇒ d . counter = = 0 & & d . date < = Instant . now ( ) . minus ( Period . ofDays ( 5 ) ) . toEpochMilli ) < nl > - for ( dialog ← toArchive ) { < nl > - log . debug ( " Archiving dialog { } due to inactivity " , dialog . peer ) < nl > - val command = DialogCommands . Archive ( dialog . peer . asModel ) < nl > - dialogRef ( command . dest ) ! command < nl > + dialogs ← dialogExt . fetchGroupedDialogs ( userId ) map ( _ filterNot ( _ . _ 1 = = DialogGroups . Favourites ) flatMap ( _ . _ 2 ) ) < nl > + } self ! ArchiveIfExpired ( dialogs . toList ) < nl > + } < nl > + < nl > + private def archiveIfExpired ( dialogs : Seq [ Dialog ] ) : Unit = { < nl > + FutureExt . ftraverse ( dialogs ) { dialog ⇒ < nl > + for ( short ← dialogExt . getDialogShort ( dialog ) ) yield { < nl > + if ( short . counter = = 0 & & short . date < = Instant . now ( ) . minus ( Period . ofDays ( 5 ) ) . toEpochMilli ) { < nl > + Some ( short . peer . asModel ) < nl > + } else None < nl > } < nl > - } < nl > + } foreach ( _ . flatten foreach ( self ! Archive ( _ ) ) ) < nl > + } < nl > + < nl > + private def archive ( peer : Peer ) : Unit = { < nl > + log . debug ( " Archiving dialog { } due to inactivity " , peer ) < nl > + dialogRef ( peer ) ! DialogCommands . Archive ( peer ) < nl > } < nl > < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala < nl > index 36bd74c . . 1263f7b 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala < nl > @ @ - 14 , 7 + 14 , 7 @ @ trait FavouritesHandlers extends PeersImplicits { < nl > authorized ( clientData ) { client ⇒ < nl > for { < nl > SeqState ( seq , state ) ← dialogExt . favourite ( client . userId , peer . asModel ) < nl > - groups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > + groups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) < nl > } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups ) ) < nl > } < nl > < nl > @ @ - 22 , 7 + 22 , 7 @ @ trait FavouritesHandlers extends PeersImplicits { < nl > authorized ( clientData ) { client ⇒ < nl > for { < nl > SeqState ( seq , state ) ← dialogExt . unfavourite ( client . userId , peer . asModel ) < nl > - groups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > + groups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) < nl > } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups ) ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index 0ee7500 . . 5235f3f 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 105 , 7 + 105 , 7 @ @ trait HistoryHandlers { < nl > override def doHandleLoadGroupedDialogs ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadGroupedDialogs ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > for { < nl > - dialogGroups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > + dialogGroups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) < nl > ( userIds , groupIds ) = dialogGroups . view . flatMap ( _ . dialogs ) . foldLeft ( ( Seq . empty [ Int ] , Seq . empty [ Int ] ) ) { < nl > case ( ( uids , gids ) , dialog ) ⇒ < nl > dialog . peer . ` type ` match { < nl > @ @ - 129 , 7 + 129 , 7 @ @ trait HistoryHandlers { < nl > authorized ( clientData ) { implicit client ⇒ < nl > for { < nl > seqstate ← dialogExt . archive ( client . userId , peer . asModel ) < nl > - groups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > + groups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) < nl > } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . state . toByteArray , groups = groups ) ) < nl > } < nl > < nl > @ @ - 137 , 7 + 137 , 7 @ @ trait HistoryHandlers { < nl > authorized ( clientData ) { implicit client ⇒ < nl > for { < nl > seqstate ← dialogExt . show ( client . userId , peer . asModel ) < nl > - groups ← dialogExt . getGroupedDialogs ( client . userId ) < nl > + groups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) < nl > } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . toByteArray , groups = groups ) ) < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / user . proto b / actor - server / actor - core / src / main / protobuf / user . proto < nl > index 593fb88 . . 0fe2bca 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / user . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / user . proto < nl > @ @ - 215 , 6 + 215 , 7 @ @ message UserCommands { < nl > option ( scalapb . message ) . extends = " im . actor . server . user . UserCommand " ; < nl > < nl > required int32 user _ id = 1 ; < nl > + required int64 client _ auth _ id = 2 ; < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index c2bbf1b . . d804ae9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . server . dialog < nl > < nl > import akka . actor . _ < nl > + import akka . event . Logging < nl > import akka . pattern . ask < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage } < nl > @ @ - 39 , 14 + 40 , 25 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { < nl > private implicit val ec : ExecutionContext = system . dispatcher < nl > private implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable < nl > < nl > - def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthId : Long , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = { < nl > - ( peer . ` type ` match { < nl > - case Private ⇒ < nl > - privateRegion . ref ? SendMessage ( privatDialogId ( senderUserId , peer . id ) , senderUserId , senderAuthId , randomId , message , isFat ) < nl > - case Group ⇒ < nl > - groupRegion . ref ? SendMessage ( groupDialogId ( peer . id ) , senderUserId , senderAuthId , randomId , message , isFat ) < nl > - } ) . mapTo [ SeqStateDate ] < nl > - } < nl > + private val log = Logging ( system , getClass ) < nl > + < nl > + private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > + peer match { < nl > + case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ < nl > + log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) < nl > + failed < nl > + case _ ⇒ f < nl > + } < nl > + < nl > + def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthId : Long , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = < nl > + withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > + ( peer . ` type ` match { < nl > + case Private ⇒ < nl > + privateRegion . ref ? SendMessage ( privatDialogId ( senderUserId , peer . id ) , senderUserId , senderAuthId , randomId , message , isFat ) < nl > + case Group ⇒ < nl > + groupRegion . ref ? SendMessage ( groupDialogId ( peer . id ) , senderUserId , senderAuthId , randomId , message , isFat ) < nl > + } ) . mapTo [ SeqStateDate ] < nl > + } < nl > < nl > def writeMessage ( < nl > peer : ApiPeer , < nl > @ @ - 55 , 27 + 67 , 31 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { < nl > randomId : Long , < nl > message : ApiMessage < nl > ) : Future [ Unit ] = < nl > - ( peer . ` type ` match { < nl > - case Private ⇒ < nl > - privateRegion . ref ? WriteMessage ( privatDialogId ( senderUserId , peer . id ) , senderUserId , date . getMillis , randomId , message ) < nl > - case Group ⇒ < nl > - groupRegion . ref ? WriteMessage ( groupDialogId ( peer . id ) , senderUserId , date . getMillis , randomId , message ) < nl > - } ) map ( _ ⇒ ( ) ) < nl > - < nl > - def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = { < nl > - ( peer . ` type ` match { < nl > - case Private ⇒ privateRegion . ref ? MessageReceived ( privatDialogId ( peer . id , receiverUserId ) , receiverUserId , date ) < nl > - case Group ⇒ groupRegion . ref ? MessageReceived ( groupDialogId ( peer . id ) , receiverUserId , date ) < nl > - < nl > - } ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > - } < nl > + withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { < nl > + ( peer . ` type ` match { < nl > + case Private ⇒ < nl > + privateRegion . ref ? WriteMessage ( privatDialogId ( senderUserId , peer . id ) , senderUserId , date . getMillis , randomId , message ) < nl > + case Group ⇒ < nl > + groupRegion . ref ? WriteMessage ( groupDialogId ( peer . id ) , senderUserId , date . getMillis , randomId , message ) < nl > + } ) map ( _ ⇒ ( ) ) < nl > + } < nl > < nl > - def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthId : Long , date : Long ) : Future [ Unit ] = { < nl > - ( peer . ` type ` match { < nl > - case Private ⇒ privateRegion . ref ? MessageRead ( privatDialogId ( peer . id , readerUserId ) , readerUserId , readerAuthId , date ) < nl > - case Group ⇒ groupRegion . ref ? MessageRead ( groupDialogId ( peer . id ) , readerUserId , readerAuthId , date ) < nl > - } ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > - } < nl > + def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = < nl > + withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { < nl > + ( peer . ` type ` match { < nl > + case Private ⇒ privateRegion . ref ? MessageReceived ( privatDialogId ( peer . id , receiverUserId ) , receiverUserId , date ) < nl > + case Group ⇒ groupRegion . ref ? MessageReceived ( groupDialogId ( peer . id ) , receiverUserId , date ) < nl > + < nl > + } ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > + } < nl > + < nl > + def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthId : Long , date : Long ) : Future [ Unit ] = < nl > + withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { < nl > + ( peer . ` type ` match { < nl > + case Private ⇒ privateRegion . ref ? MessageRead ( privatDialogId ( peer . id , readerUserId ) , readerUserId , readerAuthId , date ) < nl > + case Group ⇒ groupRegion . ref ? MessageRead ( groupDialogId ( peer . id ) , readerUserId , readerAuthId , date ) < nl > + } ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > + } < nl > < nl > def createGroupDialog ( groupId : Int , userId : Int ) : Future [ Unit ] = < nl > ( groupRegion . ref ? CreateForUser ( groupDialogId ( groupId ) , userId ) ) map ( _ ⇒ ( ) ) < nl > @ @ - 114 , 7 + 130 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { < nl > def isSharedUser ( userId : Int ) : Boolean = userId = = 0 < nl > < nl > def getGroupedDialogs ( userId : Int ) = { < nl > - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) ) flatMap { dialogModels ⇒ < nl > + db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ Dialog ] , Vector . empty [ Dialog ] ) ) { < nl > case ( ( groupModels , privateModels ) , dialog ) ⇒ < nl > if ( dialog . peer . typ = = PeerType . Group ) < nl > @ @ - 124 , 15 + 140 , 13 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { < nl > } < nl > < nl > for { < nl > - groupDialogs ← db . run ( DBIO . sequence ( groupModels map getDialogShort ) ) < nl > - privateDialogs ← FutureExt . ftraverse ( privateModels ) ( d ⇒ db . run ( getDialogShort ( d ) ) ) < nl > - } yield { < nl > - Vector ( < nl > - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , < nl > - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) < nl > - ) < nl > - } < nl > - } < nl > + groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) < nl > + privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) < nl > + } yield Vector ( < nl > + ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , < nl > + ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) < nl > + ) < nl > + } ) < nl > } < nl > < nl > private def getDialogShort ( dialogModel : Dialog ) ( implicit ec : ExecutionContext ) : DBIO [ ApiDialogShort ] = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / group / GroupDialogHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / group / GroupDialogHandlers . scala < nl > index ba4cdc1 . . 19877d3 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / group / GroupDialogHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / group / GroupDialogHandlers . scala < nl > @ @ - 108 , 7 + 108 , 7 @ @ trait GroupDialogHandlers extends UpdateCounters { < nl > def doCreate ( ) : Unit = { < nl > ( for { < nl > created ← db . run ( DialogRepo . createIfNotExists ( Dialog ( userId , Peer ( PeerType . Group , groupId ) ) ) ) < nl > - _ ← if ( created ) userExt . notifyDialogsChanged ( userId ) else Future . successful ( ( ) ) < nl > + _ ← if ( created ) userExt . notifyDialogsChanged ( userId , 0 ) else Future . successful ( ( ) ) < nl > } yield ( ) ) pipeTo self < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialog . scala < nl > index 885c779 . . 957e0ca 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialog . scala < nl > @ @ - 134 , 6 + 134 , 12 @ @ private [ privat ] final class PrivateDialog extends DialogProcessor [ PrivateDialogS < nl > } < nl > < nl > private def init ( ) : Unit = { < nl > + if ( left = = right ) { < nl > + val error = new RuntimeException ( s " Attempt to create dialog with yourself : $ { left } " ) < nl > + log . error ( error , " Failed to init dialog " ) < nl > + throw error < nl > + } < nl > + < nl > val rightPeer = Peer ( PeerType . Private , right ) < nl > val leftPeer = Peer ( PeerType . Private , left ) < nl > < nl > @ @ - 145 , 7 + 151 , 7 @ @ private [ privat ] final class PrivateDialog extends DialogProcessor [ PrivateDialogS < nl > case None ⇒ < nl > for { < nl > _ ← DialogRepo . create ( Dialog ( left , rightPeer ) ) < nl > - _ ← DBIO . from ( userExt . notifyDialogsChanged ( left ) ) < nl > + _ ← DBIO . from ( userExt . notifyDialogsChanged ( left , 0 ) ) < nl > } yield ( ) < nl > } < nl > _ ← rightDialogOpt match { < nl > @ @ - 153 , 7 + 159 , 7 @ @ private [ privat ] final class PrivateDialog extends DialogProcessor [ PrivateDialogS < nl > case None ⇒ < nl > for { < nl > _ ← DialogRepo . create ( Dialog ( right , leftPeer ) ) < nl > - _ ← DBIO . from ( userExt . notifyDialogsChanged ( right ) ) < nl > + _ ← DBIO . from ( userExt . notifyDialogsChanged ( right , 0 ) ) < nl > } yield ( ) < nl > } < nl > } yield ( ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialogHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialogHandlers . scala < nl > index 954d8aa . . aeab7ec 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialogHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialogHandlers . scala < nl > @ @ - 1 , 12 + 1 , 13 @ @ < nl > package im . actor . server . dialog . privat < nl > < nl > import akka . pattern . pipe < nl > - import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageReceived } < nl > + import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . server . dialog . _ < nl > import im . actor . server . event . TSEvent < nl > import im . actor . server . misc . UpdateCounters < nl > import im . actor . server . models < nl > + import im . actor . server . persist . HistoryMessage < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > import im . actor . server . social . SocialManager . _ < nl > import HistoryUtils . _ < nl > @ @ - 58 , 14 + 59 , 33 @ @ trait PrivateDialogHandlers extends UpdateCounters { < nl > val date = new DateTime ( dateMillis ) < nl > val userState = dialogState ( senderUserId ) < nl > < nl > - db . run ( writeHistoryMessage ( < nl > - models . Peer . privat ( senderUserId ) , < nl > - models . Peer . privat ( userState . peerId ) , < nl > - date , < nl > - randomId , < nl > - message . header , < nl > - message . toByteArray < nl > - ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > + val fut = < nl > + message match { < nl > + case ApiServiceMessage ( _ , Some ( ApiServiceExContactRegistered ( userId ) ) ) ⇒ < nl > + db . run ( HistoryMessage . create ( < nl > + models . HistoryMessage ( < nl > + userId = userState . peerId , < nl > + peer = models . Peer . privat ( userId ) , < nl > + date = date , < nl > + senderUserId = userId , < nl > + randomId = randomId , < nl > + messageContentHeader = message . header , < nl > + messageContentData = message . toByteArray , < nl > + deletedAt = None < nl > + ) < nl > + ) ) < nl > + case _ ⇒ < nl > + db . run ( writeHistoryMessage ( < nl > + models . Peer . privat ( senderUserId ) , < nl > + models . Peer . privat ( userState . peerId ) , < nl > + date , < nl > + randomId , < nl > + message . header , < nl > + message . toByteArray < nl > + ) ) < nl > + } < nl > + < nl > + fut map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > } < nl > < nl > protected def messageReceived ( state : PrivateDialogState , receiverUserId : Int , date : Long ) : Unit = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 0716208 . . b812b52 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 265 , 10 + 265 , 10 @ @ private [ user ] trait UserCommandHandlers { < nl > } < nl > } < nl > < nl > - protected def notifyDialogsChanged ( user : User ) : Unit = { < nl > + protected def notifyDialogsChanged ( user : User , clientAuthId : Long ) : Unit = { < nl > ( for { < nl > shortDialogs ← dialogExt . getGroupedDialogs ( user . id ) < nl > - seqstate ← userExt . broadcastUserUpdate ( user . id , UpdateChatGroupsChanged ( shortDialogs ) , pushText = None , isFat = false , deliveryId = None ) < nl > + seqstate ← userExt . broadcastClientUpdate ( user . id , clientAuthId , UpdateChatGroupsChanged ( shortDialogs ) , pushText = None , isFat = false , deliveryId = None ) < nl > } yield seqstate ) pipeTo sender ( ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > index 655c886 . . 009e130 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > @ @ - 102 , 8 + 102 , 8 @ @ private [ user ] sealed trait Commands extends AuthCommands { < nl > else < nl > SeqUpdatesManager . getSeqState ( clientAuthId ) < nl > < nl > - def notifyDialogsChanged ( userId : Int ) : Future [ SeqState ] = < nl > - ( processorRegion . ref ? NotifyDialogsChanged ( userId ) ) . mapTo [ SeqState ] < nl > + def notifyDialogsChanged ( userId : Int , clientAuthId : Long ) : Future [ SeqState ] = < nl > + ( processorRegion . ref ? NotifyDialogsChanged ( userId , clientAuthId ) ) . mapTo [ SeqState ] < nl > < nl > def broadcastUserUpdate ( < nl > userId : Int , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > index 3c13a25 . . 65c2de8 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > @ @ - 196 , 7 + 196 , 7 @ @ private [ user ] final class UserProcessor < nl > case UpdateAvatar ( _ , clientAuthId , avatarOpt ) ⇒ updateAvatar ( state , clientAuthId , avatarOpt ) < nl > case AddContacts ( _ , clientAuthId , contactsToAdd ) ⇒ addContacts ( state , clientAuthId , contactsToAdd ) < nl > case UpdateIsAdmin ( _ , isAdmin ) ⇒ updateIsAdmin ( state , isAdmin ) < nl > - case NotifyDialogsChanged ( _ ) ⇒ notifyDialogsChanged ( state ) < nl > + case NotifyDialogsChanged ( _ , clientAuthId ) ⇒ notifyDialogsChanged ( state , clientAuthId ) < nl > case ChangeTimeZone ( _ , authId , timeZone ) ⇒ changeTimeZone ( state , authId , timeZone ) < nl > case ChangePreferredLanguages ( _ , authId , preferredLanguages ) ⇒ changePreferredLanguages ( state , authId , preferredLanguages ) < nl > case StopOffice ⇒ context stop self < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index 283c237 . . c3b15ee 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 113 , 7 + 113 , 7 @ @ trait HistoryHandlers { < nl > authorized ( clientData ) { implicit client ⇒ < nl > for { < nl > _ ← db . run ( DialogRepo . hide ( client . userId , peer . asModel ) ) < nl > - SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) < nl > + SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId , client . authId ) < nl > } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) < nl > } < nl > } < nl > @ @ - 122 , 7 + 122 , 7 @ @ trait HistoryHandlers { < nl > authorized ( clientData ) { implicit client ⇒ < nl > for { < nl > _ ← db . run ( DialogRepo . show ( client . userId , peer . asModel ) ) < nl > - SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) < nl > + SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId , client . authId ) < nl > } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 56319de . . f0eb159 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 246 , 12 + 246 , 12 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 
 def isSharedUser ( userId : Int ) : Boolean = userId = = 0 
 
 - def getGroupedDialogs ( userId : Int ) = { 
 + def fetchGroupedDialogs ( userId : Int ) : Future [ Map [ DialogGroup , Vector [ Dialog ] ] ] = 
 db . run { 
 DialogRepo 
 . fetchSortByLastMessageData ( userId , None , Int . MaxValue ) 
 . map ( _ filterNot ( dialogWithSelf ( userId , _ ) ) ) 
 - . flatMap { dialogs ⇒ 
 + . map { dialogs ⇒ 
 val ( groupModels , privateModels , favouriteModels ) = 
 dialogs . foldLeft ( ( Vector . empty [ Dialog ] , Vector . empty [ Dialog ] , Vector . empty [ Dialog ] ) ) { 
 case ( ( groupModels , privateModels , favouriteModels ) , dialog ) ⇒ 
 @ @ - 264 , 22 + 264 , 37 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 else throw new RuntimeException ( " Unknown dialog type " ) 
 } 
 
 - for { 
 - groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) 
 - privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) 
 - favouriteDialogs ← DBIO . sequence ( favouriteModels map getDialogShort ) 
 - } yield { 
 - val default = Vector ( 
 - ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , 
 - ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) 
 - ) 
 - 
 - if ( favouriteDialogs . nonEmpty ) 
 - ApiDialogGroup ( DialogGroups . Favourites . title , DialogGroups . Favourites . key , favouriteDialogs ) + : default 
 - else default 
 - } 
 + Map ( 
 + DialogGroups . Favourites → favouriteModels , 
 + DialogGroups . Privates → privateModels , 
 + DialogGroups . Groups → groupModels 
 + ) 
 } 
 } 
 + 
 + def fetchGroupedDialogShorts ( userId : Int ) : Future [ Vector [ ApiDialogGroup ] ] = { 
 + fetchGroupedDialogs ( userId ) flatMap { dialogsMap ⇒ 
 + db . run { 
 + val groupModels = dialogsMap . getOrElse ( DialogGroups . Groups , Vector . empty ) 
 + val privateModels = dialogsMap . getOrElse ( DialogGroups . Privates , Vector . empty ) 
 + val favouriteModels = dialogsMap . getOrElse ( DialogGroups . Favourites , Vector . empty ) 
 + 
 + for { 
 + groupDialogs ← DBIO . sequence ( groupModels map getDialogShortDBIO ) 
 + privateDialogs ← DBIO . sequence ( privateModels map getDialogShortDBIO ) 
 + favouriteDialogs ← DBIO . sequence ( favouriteModels map getDialogShortDBIO ) 
 + } yield { 
 + val default = Vector ( 
 + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , 
 + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs ) 
 + ) 
 + 
 + if ( favouriteDialogs . nonEmpty ) 
 + ApiDialogGroup ( DialogGroups . Favourites . title , DialogGroups . Favourites . key , favouriteDialogs ) + : default 
 + else default 
 + } 
 + } 
 + } 
 } 
 
 def dialogWithSelf ( userId : Int , dialog : Dialog ) : Boolean = 
 @ @ - 299 , 7 + 314 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 } ) . toSeq 
 } 
 
 - private def getDialogShort ( dialog : Dialog ) ( implicit ec : ExecutionContext ) : DBIO [ ApiDialogShort ] = 
 + def getDialogShortDBIO ( dialog : Dialog ) ( implicit ec : ExecutionContext ) : DBIO [ ApiDialogShort ] = 
 for { 
 historyOwner ← DBIO . from ( HistoryUtils . getHistoryOwner ( dialog . peer , dialog . userId ) ) 
 messageOpt ← HistoryMessageRepo . findNewest ( historyOwner , dialog . peer ) map ( _ . map ( _ . ofUser ( dialog . userId ) ) ) 
 @ @ - 310 , 6 + 325 , 9 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 date = messageOpt . map ( _ . date . getMillis ) . getOrElse ( 0 ) 
 ) 
 
 + def getDialogShort ( dialog : Dialog ) ( implicit ec : ExecutionContext ) : Future [ ApiDialogShort ] = 
 + db . run ( getDialogShortDBIO ( dialog ) ) 
 + 
 private def processorRegion ( peer : Peer ) : ActorRef = peer . typ match { 
 case PeerType . Private ⇒ 
 userExt . processorRegion . ref / / to user peer 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 818cbe7 . . 6a931fd 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 304 , 7 + 304 , 7 @ @ private [ user ] trait UserCommandHandlers { 
 
 protected def notifyDialogsChanged ( user : UserState ) : Unit = { 
 ( for { 
 - shortDialogs ← dialogExt . getGroupedDialogs ( user . id ) 
 + shortDialogs ← dialogExt . fetchGroupedDialogShorts ( user . id ) 
 seqstate ← seqUpdatesExt . deliverSingleUpdate ( user . id , UpdateChatGroupsChanged ( shortDialogs ) , reduceKey = Some ( " chat _ groups _ changed " ) ) 
 } yield seqstate ) pipeTo sender ( ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 index 2400693 . . 30f2c8b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 @ @ - 5 , 16 + 5 , 18 @ @ import java . time . { Instant , Period } 
 import akka . actor . { ActorRef , Props } 
 import im . actor . api . rpc . PeersImplicits 
 import im . actor . api . rpc . misc . ApiExtension 
 - import im . actor . concurrent . AlertingActor 
 + import im . actor . concurrent . { AlertingActor , FutureExt } 
 import im . actor . server . dialog . _ 
 - import im . actor . server . model . { Peer , PeerType } 
 + import im . actor . server . model . { Dialog , Peer , PeerType } 
 
 import scala . concurrent . duration . _ 
 
 private [ user ] object UserPeer { 
 def props ( userId : Int , extensions : Seq [ ApiExtension ] ) = Props ( classOf [ UserPeer ] , userId , extensions ) 
 
 - private case object Archive 
 + private case object StartArchiving 
 + private case class ArchiveIfExpired ( dialogs : Seq [ Dialog ] ) 
 + private case class Archive ( peer : Peer ) 
 } 
 
 private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) extends AlertingActor with PeersImplicits { 
 @ @ - 24 , 7 + 26 , 7 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e 
 private val selfPeer = Peer . privat ( userId ) 
 
 private val dialogExt = DialogExtension ( context . system ) 
 - private val archiveInterval = context . system . scheduler . schedule ( 0 . seconds , 1 . hour , self , Archive ) 
 + private val archiveInterval = context . system . scheduler . schedule ( 0 . seconds , 1 . hour , self , StartArchiving ) 
 
 override def postStop ( ) : Unit = { 
 super . postStop ( ) 
 @ @ - 33 , 10 + 35 , 12 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e 
 
 def receive : Receive = { 
 / / Forward to a group or a corresponding user dialog 
 - case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc 
 + case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc 
 / / Forward to a dest user dialog 
 - case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc 
 - case Archive ⇒ archive ( ) 
 + case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc 
 + case StartArchiving ⇒ startArchiving ( ) 
 + case ArchiveIfExpired ( dialogs ) ⇒ archiveIfExpired ( dialogs ) 
 + case Archive ( peer ) ⇒ archive ( peer ) 
 } 
 
 private def dialogRef ( dc : DirectDialogCommand ) : ActorRef = { 
 @ @ - 56 , 17 + 60 , 25 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e 
 case other ⇒ throw new Exception ( s " Unknown peer type : $ other " ) 
 } 
 
 - private def archive ( ) : Unit = { 
 + private def startArchiving ( ) : Unit = { 
 for { 
 - dialogs ← dialogExt . getGroupedDialogs ( userId ) map ( _ filterNot ( _ . key = = DialogGroups . Favourites . key ) flatMap ( _ . dialogs ) ) 
 - } yield { 
 - val toArchive = dialogs filter ( d ⇒ d . counter = = 0 & & d . date < = Instant . now ( ) . minus ( Period . ofDays ( 5 ) ) . toEpochMilli ) 
 - for ( dialog ← toArchive ) { 
 - log . debug ( " Archiving dialog { } due to inactivity " , dialog . peer ) 
 - val command = DialogCommands . Archive ( dialog . peer . asModel ) 
 - dialogRef ( command . dest ) ! command 
 + dialogs ← dialogExt . fetchGroupedDialogs ( userId ) map ( _ filterNot ( _ . _ 1 = = DialogGroups . Favourites ) flatMap ( _ . _ 2 ) ) 
 + } self ! ArchiveIfExpired ( dialogs . toList ) 
 + } 
 + 
 + private def archiveIfExpired ( dialogs : Seq [ Dialog ] ) : Unit = { 
 + FutureExt . ftraverse ( dialogs ) { dialog ⇒ 
 + for ( short ← dialogExt . getDialogShort ( dialog ) ) yield { 
 + if ( short . counter = = 0 & & short . date < = Instant . now ( ) . minus ( Period . ofDays ( 5 ) ) . toEpochMilli ) { 
 + Some ( short . peer . asModel ) 
 + } else None 
 } 
 - } 
 + } foreach ( _ . flatten foreach ( self ! Archive ( _ ) ) ) 
 + } 
 + 
 + private def archive ( peer : Peer ) : Unit = { 
 + log . debug ( " Archiving dialog { } due to inactivity " , peer ) 
 + dialogRef ( peer ) ! DialogCommands . Archive ( peer ) 
 } 
 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala 
 index 36bd74c . . 1263f7b 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / FavouritesHandlers . scala 
 @ @ - 14 , 7 + 14 , 7 @ @ trait FavouritesHandlers extends PeersImplicits { 
 authorized ( clientData ) { client ⇒ 
 for { 
 SeqState ( seq , state ) ← dialogExt . favourite ( client . userId , peer . asModel ) 
 - groups ← dialogExt . getGroupedDialogs ( client . userId ) 
 + groups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) 
 } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups ) ) 
 } 
 
 @ @ - 22 , 7 + 22 , 7 @ @ trait FavouritesHandlers extends PeersImplicits { 
 authorized ( clientData ) { client ⇒ 
 for { 
 SeqState ( seq , state ) ← dialogExt . unfavourite ( client . userId , peer . asModel ) 
 - groups ← dialogExt . getGroupedDialogs ( client . userId ) 
 + groups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) 
 } yield Ok ( ResponseDialogsOrder ( seq , state . toByteArray , groups ) ) 
 } 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index 0ee7500 . . 5235f3f 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 105 , 7 + 105 , 7 @ @ trait HistoryHandlers { 
 override def doHandleLoadGroupedDialogs ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadGroupedDialogs ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 for { 
 - dialogGroups ← dialogExt . getGroupedDialogs ( client . userId ) 
 + dialogGroups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) 
 ( userIds , groupIds ) = dialogGroups . view . flatMap ( _ . dialogs ) . foldLeft ( ( Seq . empty [ Int ] , Seq . empty [ Int ] ) ) { 
 case ( ( uids , gids ) , dialog ) ⇒ 
 dialog . peer . ` type ` match { 
 @ @ - 129 , 7 + 129 , 7 @ @ trait HistoryHandlers { 
 authorized ( clientData ) { implicit client ⇒ 
 for { 
 seqstate ← dialogExt . archive ( client . userId , peer . asModel ) 
 - groups ← dialogExt . getGroupedDialogs ( client . userId ) 
 + groups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) 
 } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . state . toByteArray , groups = groups ) ) 
 } 
 
 @ @ - 137 , 7 + 137 , 7 @ @ trait HistoryHandlers { 
 authorized ( clientData ) { implicit client ⇒ 
 for { 
 seqstate ← dialogExt . show ( client . userId , peer . asModel ) 
 - groups ← dialogExt . getGroupedDialogs ( client . userId ) 
 + groups ← dialogExt . fetchGroupedDialogShorts ( client . userId ) 
 } yield Ok ( ResponseDialogsOrder ( seqstate . seq , seqstate . toByteArray , groups = groups ) ) 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / user . proto b / actor - server / actor - core / src / main / protobuf / user . proto 
 index 593fb88 . . 0fe2bca 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / user . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / user . proto 
 @ @ - 215 , 6 + 215 , 7 @ @ message UserCommands { 
 option ( scalapb . message ) . extends = " im . actor . server . user . UserCommand " ; 
 
 required int32 user _ id = 1 ; 
 + required int64 client _ auth _ id = 2 ; 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index c2bbf1b . . d804ae9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . server . dialog 
 
 import akka . actor . _ 
 + import akka . event . Logging 
 import akka . pattern . ask 
 import akka . util . Timeout 
 import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage } 
 @ @ - 39 , 14 + 40 , 25 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { 
 private implicit val ec : ExecutionContext = system . dispatcher 
 private implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable 
 
 - def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthId : Long , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = { 
 - ( peer . ` type ` match { 
 - case Private ⇒ 
 - privateRegion . ref ? SendMessage ( privatDialogId ( senderUserId , peer . id ) , senderUserId , senderAuthId , randomId , message , isFat ) 
 - case Group ⇒ 
 - groupRegion . ref ? SendMessage ( groupDialogId ( peer . id ) , senderUserId , senderAuthId , randomId , message , isFat ) 
 - } ) . mapTo [ SeqStateDate ] 
 - } 
 + private val log = Logging ( system , getClass ) 
 + 
 + private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 + peer match { 
 + case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ 
 + log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) 
 + failed 
 + case _ ⇒ f 
 + } 
 + 
 + def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthId : Long , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = 
 + withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 + ( peer . ` type ` match { 
 + case Private ⇒ 
 + privateRegion . ref ? SendMessage ( privatDialogId ( senderUserId , peer . id ) , senderUserId , senderAuthId , randomId , message , isFat ) 
 + case Group ⇒ 
 + groupRegion . ref ? SendMessage ( groupDialogId ( peer . id ) , senderUserId , senderAuthId , randomId , message , isFat ) 
 + } ) . mapTo [ SeqStateDate ] 
 + } 
 
 def writeMessage ( 
 peer : ApiPeer , 
 @ @ - 55 , 27 + 67 , 31 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { 
 randomId : Long , 
 message : ApiMessage 
 ) : Future [ Unit ] = 
 - ( peer . ` type ` match { 
 - case Private ⇒ 
 - privateRegion . ref ? WriteMessage ( privatDialogId ( senderUserId , peer . id ) , senderUserId , date . getMillis , randomId , message ) 
 - case Group ⇒ 
 - groupRegion . ref ? WriteMessage ( groupDialogId ( peer . id ) , senderUserId , date . getMillis , randomId , message ) 
 - } ) map ( _ ⇒ ( ) ) 
 - 
 - def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = { 
 - ( peer . ` type ` match { 
 - case Private ⇒ privateRegion . ref ? MessageReceived ( privatDialogId ( peer . id , receiverUserId ) , receiverUserId , date ) 
 - case Group ⇒ groupRegion . ref ? MessageReceived ( groupDialogId ( peer . id ) , receiverUserId , date ) 
 - 
 - } ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 - } 
 + withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { 
 + ( peer . ` type ` match { 
 + case Private ⇒ 
 + privateRegion . ref ? WriteMessage ( privatDialogId ( senderUserId , peer . id ) , senderUserId , date . getMillis , randomId , message ) 
 + case Group ⇒ 
 + groupRegion . ref ? WriteMessage ( groupDialogId ( peer . id ) , senderUserId , date . getMillis , randomId , message ) 
 + } ) map ( _ ⇒ ( ) ) 
 + } 
 
 - def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthId : Long , date : Long ) : Future [ Unit ] = { 
 - ( peer . ` type ` match { 
 - case Private ⇒ privateRegion . ref ? MessageRead ( privatDialogId ( peer . id , readerUserId ) , readerUserId , readerAuthId , date ) 
 - case Group ⇒ groupRegion . ref ? MessageRead ( groupDialogId ( peer . id ) , readerUserId , readerAuthId , date ) 
 - } ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 - } 
 + def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = 
 + withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { 
 + ( peer . ` type ` match { 
 + case Private ⇒ privateRegion . ref ? MessageReceived ( privatDialogId ( peer . id , receiverUserId ) , receiverUserId , date ) 
 + case Group ⇒ groupRegion . ref ? MessageReceived ( groupDialogId ( peer . id ) , receiverUserId , date ) 
 + 
 + } ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 + } 
 + 
 + def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthId : Long , date : Long ) : Future [ Unit ] = 
 + withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { 
 + ( peer . ` type ` match { 
 + case Private ⇒ privateRegion . ref ? MessageRead ( privatDialogId ( peer . id , readerUserId ) , readerUserId , readerAuthId , date ) 
 + case Group ⇒ groupRegion . ref ? MessageRead ( groupDialogId ( peer . id ) , readerUserId , readerAuthId , date ) 
 + } ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 + } 
 
 def createGroupDialog ( groupId : Int , userId : Int ) : Future [ Unit ] = 
 ( groupRegion . ref ? CreateForUser ( groupDialogId ( groupId ) , userId ) ) map ( _ ⇒ ( ) ) 
 @ @ - 114 , 7 + 130 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { 
 def isSharedUser ( userId : Int ) : Boolean = userId = = 0 
 
 def getGroupedDialogs ( userId : Int ) = { 
 - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) ) flatMap { dialogModels ⇒ 
 + db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ Dialog ] , Vector . empty [ Dialog ] ) ) { 
 case ( ( groupModels , privateModels ) , dialog ) ⇒ 
 if ( dialog . peer . typ = = PeerType . Group ) 
 @ @ - 124 , 15 + 140 , 13 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { 
 } 
 
 for { 
 - groupDialogs ← db . run ( DBIO . sequence ( groupModels map getDialogShort ) ) 
 - privateDialogs ← FutureExt . ftraverse ( privateModels ) ( d ⇒ db . run ( getDialogShort ( d ) ) ) 
 - } yield { 
 - Vector ( 
 - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , 
 - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) 
 - ) 
 - } 
 - } 
 + groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) 
 + privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) 
 + } yield Vector ( 
 + ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , 
 + ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) 
 + ) 
 + } ) 
 } 
 
 private def getDialogShort ( dialogModel : Dialog ) ( implicit ec : ExecutionContext ) : DBIO [ ApiDialogShort ] = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / group / GroupDialogHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / group / GroupDialogHandlers . scala 
 index ba4cdc1 . . 19877d3 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / group / GroupDialogHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / group / GroupDialogHandlers . scala 
 @ @ - 108 , 7 + 108 , 7 @ @ trait GroupDialogHandlers extends UpdateCounters { 
 def doCreate ( ) : Unit = { 
 ( for { 
 created ← db . run ( DialogRepo . createIfNotExists ( Dialog ( userId , Peer ( PeerType . Group , groupId ) ) ) ) 
 - _ ← if ( created ) userExt . notifyDialogsChanged ( userId ) else Future . successful ( ( ) ) 
 + _ ← if ( created ) userExt . notifyDialogsChanged ( userId , 0 ) else Future . successful ( ( ) ) 
 } yield ( ) ) pipeTo self 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialog . scala 
 index 885c779 . . 957e0ca 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialog . scala 
 @ @ - 134 , 6 + 134 , 12 @ @ private [ privat ] final class PrivateDialog extends DialogProcessor [ PrivateDialogS 
 } 
 
 private def init ( ) : Unit = { 
 + if ( left = = right ) { 
 + val error = new RuntimeException ( s " Attempt to create dialog with yourself : $ { left } " ) 
 + log . error ( error , " Failed to init dialog " ) 
 + throw error 
 + } 
 + 
 val rightPeer = Peer ( PeerType . Private , right ) 
 val leftPeer = Peer ( PeerType . Private , left ) 
 
 @ @ - 145 , 7 + 151 , 7 @ @ private [ privat ] final class PrivateDialog extends DialogProcessor [ PrivateDialogS 
 case None ⇒ 
 for { 
 _ ← DialogRepo . create ( Dialog ( left , rightPeer ) ) 
 - _ ← DBIO . from ( userExt . notifyDialogsChanged ( left ) ) 
 + _ ← DBIO . from ( userExt . notifyDialogsChanged ( left , 0 ) ) 
 } yield ( ) 
 } 
 _ ← rightDialogOpt match { 
 @ @ - 153 , 7 + 159 , 7 @ @ private [ privat ] final class PrivateDialog extends DialogProcessor [ PrivateDialogS 
 case None ⇒ 
 for { 
 _ ← DialogRepo . create ( Dialog ( right , leftPeer ) ) 
 - _ ← DBIO . from ( userExt . notifyDialogsChanged ( right ) ) 
 + _ ← DBIO . from ( userExt . notifyDialogsChanged ( right , 0 ) ) 
 } yield ( ) 
 } 
 } yield ( ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialogHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialogHandlers . scala 
 index 954d8aa . . aeab7ec 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialogHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / privat / PrivateDialogHandlers . scala 
 @ @ - 1 , 12 + 1 , 13 @ @ 
 package im . actor . server . dialog . privat 
 
 import akka . pattern . pipe 
 - import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageReceived } 
 + import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . server . dialog . _ 
 import im . actor . server . event . TSEvent 
 import im . actor . server . misc . UpdateCounters 
 import im . actor . server . models 
 + import im . actor . server . persist . HistoryMessage 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 import im . actor . server . social . SocialManager . _ 
 import HistoryUtils . _ 
 @ @ - 58 , 14 + 59 , 33 @ @ trait PrivateDialogHandlers extends UpdateCounters { 
 val date = new DateTime ( dateMillis ) 
 val userState = dialogState ( senderUserId ) 
 
 - db . run ( writeHistoryMessage ( 
 - models . Peer . privat ( senderUserId ) , 
 - models . Peer . privat ( userState . peerId ) , 
 - date , 
 - randomId , 
 - message . header , 
 - message . toByteArray 
 - ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 + val fut = 
 + message match { 
 + case ApiServiceMessage ( _ , Some ( ApiServiceExContactRegistered ( userId ) ) ) ⇒ 
 + db . run ( HistoryMessage . create ( 
 + models . HistoryMessage ( 
 + userId = userState . peerId , 
 + peer = models . Peer . privat ( userId ) , 
 + date = date , 
 + senderUserId = userId , 
 + randomId = randomId , 
 + messageContentHeader = message . header , 
 + messageContentData = message . toByteArray , 
 + deletedAt = None 
 + ) 
 + ) ) 
 + case _ ⇒ 
 + db . run ( writeHistoryMessage ( 
 + models . Peer . privat ( senderUserId ) , 
 + models . Peer . privat ( userState . peerId ) , 
 + date , 
 + randomId , 
 + message . header , 
 + message . toByteArray 
 + ) ) 
 + } 
 + 
 + fut map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 } 
 
 protected def messageReceived ( state : PrivateDialogState , receiverUserId : Int , date : Long ) : Unit = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 0716208 . . b812b52 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 265 , 10 + 265 , 10 @ @ private [ user ] trait UserCommandHandlers { 
 } 
 } 
 
 - protected def notifyDialogsChanged ( user : User ) : Unit = { 
 + protected def notifyDialogsChanged ( user : User , clientAuthId : Long ) : Unit = { 
 ( for { 
 shortDialogs ← dialogExt . getGroupedDialogs ( user . id ) 
 - seqstate ← userExt . broadcastUserUpdate ( user . id , UpdateChatGroupsChanged ( shortDialogs ) , pushText = None , isFat = false , deliveryId = None ) 
 + seqstate ← userExt . broadcastClientUpdate ( user . id , clientAuthId , UpdateChatGroupsChanged ( shortDialogs ) , pushText = None , isFat = false , deliveryId = None ) 
 } yield seqstate ) pipeTo sender ( ) 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 index 655c886 . . 009e130 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 @ @ - 102 , 8 + 102 , 8 @ @ private [ user ] sealed trait Commands extends AuthCommands { 
 else 
 SeqUpdatesManager . getSeqState ( clientAuthId ) 
 
 - def notifyDialogsChanged ( userId : Int ) : Future [ SeqState ] = 
 - ( processorRegion . ref ? NotifyDialogsChanged ( userId ) ) . mapTo [ SeqState ] 
 + def notifyDialogsChanged ( userId : Int , clientAuthId : Long ) : Future [ SeqState ] = 
 + ( processorRegion . ref ? NotifyDialogsChanged ( userId , clientAuthId ) ) . mapTo [ SeqState ] 
 
 def broadcastUserUpdate ( 
 userId : Int , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 index 3c13a25 . . 65c2de8 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 @ @ - 196 , 7 + 196 , 7 @ @ private [ user ] final class UserProcessor 
 case UpdateAvatar ( _ , clientAuthId , avatarOpt ) ⇒ updateAvatar ( state , clientAuthId , avatarOpt ) 
 case AddContacts ( _ , clientAuthId , contactsToAdd ) ⇒ addContacts ( state , clientAuthId , contactsToAdd ) 
 case UpdateIsAdmin ( _ , isAdmin ) ⇒ updateIsAdmin ( state , isAdmin ) 
 - case NotifyDialogsChanged ( _ ) ⇒ notifyDialogsChanged ( state ) 
 + case NotifyDialogsChanged ( _ , clientAuthId ) ⇒ notifyDialogsChanged ( state , clientAuthId ) 
 case ChangeTimeZone ( _ , authId , timeZone ) ⇒ changeTimeZone ( state , authId , timeZone ) 
 case ChangePreferredLanguages ( _ , authId , preferredLanguages ) ⇒ changePreferredLanguages ( state , authId , preferredLanguages ) 
 case StopOffice ⇒ context stop self 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index 283c237 . . c3b15ee 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 113 , 7 + 113 , 7 @ @ trait HistoryHandlers { 
 authorized ( clientData ) { implicit client ⇒ 
 for { 
 _ ← db . run ( DialogRepo . hide ( client . userId , peer . asModel ) ) 
 - SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) 
 + SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId , client . authId ) 
 } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) 
 } 
 } 
 @ @ - 122 , 7 + 122 , 7 @ @ trait HistoryHandlers { 
 authorized ( clientData ) { implicit client ⇒ 
 for { 
 _ ← db . run ( DialogRepo . show ( client . userId , peer . asModel ) ) 
 - SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId ) 
 + SeqState ( seq , state ) ← userExt . notifyDialogsChanged ( client . userId , client . authId ) 
 } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) 
 } 
 }
