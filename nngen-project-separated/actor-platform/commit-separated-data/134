BLEU SCORE: 0.09063023185560713

TEST MSG: fix ( server : groups ) : rename typ - > groupType in GroupState
GENERATED MSG: fix ( server ) : don ' t write about change service message ; push only members count in channels

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 5f7531b . . 6b8e259 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 65 , 7 + 65 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > / / Group creation < nl > val groupType = GroupType . fromValue ( cmd . typ ) / / FIXME : make it normal enum < nl > - val isHistoryShared = groupType . isChannel < nl > + val isHistoryShared = groupType . isChannel | | groupType . isPublic < nl > < nl > persist ( Created ( < nl > ts = createdAt , < nl > @ @ - 101 , 7 + 101 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > creatorUserId = newState . creatorUserId , < nl > accessHash = newState . accessHash , < nl > title = newState . title , < nl > - isPublic = newState . typ = = GroupType . Public , < nl > + isPublic = isHistoryShared , < nl > createdAt = evt . ts , < nl > about = None , < nl > topic = None < nl > @ @ - 190 , 7 + 190 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val inviteeUpdatesNew : List [ Update ] = refreshGroupUpdates ( newState , cmd . inviteeUserId ) < nl > < nl > val membersUpdateNew : Update = < nl > - if ( newState . typ . isChannel ) / / if history shared < nl > + if ( newState . groupType . isChannel ) / / if channel , or group is big enough < nl > UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > else < nl > UpdateGroupMembersUpdated ( groupId , apiMembers ) < nl > @ @ - 321 , 7 + 321 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - seqStateDate ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates < nl > + seqStateDate ← if ( newState . groupType . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates < nl > < nl > } yield seqStateDate < nl > < nl > @ @ - 371 , 7 + 371 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) < nl > < nl > val membersUpdateNew : Update = < nl > - if ( newState . typ . isChannel ) / / if history is shared < nl > + if ( newState . groupType . isChannel ) / / if channel , or group is big enough < nl > UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > else < nl > UpdateGroupMembersUpdated ( groupId , apiMembers ) / / will update date when member got into group < nl > @ @ - 466 , 7 + 466 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - seqStateDate ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates < nl > + seqStateDate ← if ( newState . groupType . isChannel ) joinCHANNELUpdates else joinGROUPUpdates < nl > < nl > } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) < nl > < nl > @ @ - 493 , 7 + 493 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > / / TODO : merge , they are almost identical < nl > val leftUserUpdatesNew = < nl > - if ( state . typ . isChannel ) List ( < nl > + if ( state . groupType . isChannel ) List ( < nl > UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > UpdateGroupCanEditInfoChanged ( groupId , canEditGroup = false ) , < nl > UpdateGroupCanEditUsernameChanged ( groupId , canEditUsername = false ) , < nl > @ @ - 514 , 7 + 514 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > val membersUpdateNew = < nl > - if ( state . typ . isChannel ) { / / if history is shared < nl > + if ( state . groupType . isChannel ) { / / if channel , or group is big enough < nl > UpdateGroupMembersCountChanged ( < nl > groupId , < nl > membersCount = state . membersCount - 1 < nl > @ @ - 610 , 7 + 610 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - seqStateDate ← if ( state . typ . isChannel ) leaveCHANNELUpdates else leaveGROUPUpdates < nl > + seqStateDate ← if ( state . groupType . isChannel ) leaveCHANNELUpdates else leaveGROUPUpdates < nl > < nl > } yield seqStateDate < nl > < nl > @ @ - 634 , 7 + 634 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > / / TODO : merge , they are almost identical < nl > val kickedUserUpdatesNew : List [ Update ] = < nl > - if ( state . typ . isChannel ) List ( < nl > + if ( state . groupType . isChannel ) List ( < nl > UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > UpdateGroupCanEditInfoChanged ( groupId , canEditGroup = false ) , < nl > UpdateGroupCanEditUsernameChanged ( groupId , canEditUsername = false ) , < nl > @ @ - 657 , 7 + 657 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > val membersUpdateNew : Update = < nl > - if ( newState . typ . isChannel ) { / / if history is shared < nl > + if ( newState . groupType . isChannel ) { / / if channel , or group is big enough < nl > UpdateGroupMembersCountChanged ( < nl > groupId , < nl > membersCount = newState . membersCount < nl > @ @ - 754 , 7 + 754 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - seqStateDate ← if ( state . typ . isChannel ) kickCHANNELUpdates else kickGROUPUpdates < nl > + seqStateDate ← if ( state . groupType . isChannel ) kickCHANNELUpdates else kickGROUPUpdates < nl > < nl > } yield seqStateDate < nl > < nl > @ @ - 1156 , 7 + 1156 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > userId = cmd . candidateUserId , < nl > update = updateCanEdit < nl > ) < nl > - seqStateDate ← if ( state . typ . isChannel ) adminCHANNELUpdates else adminGROUPUpdates < nl > + seqStateDate ← if ( state . groupType . isChannel ) adminCHANNELUpdates else adminGROUPUpdates < nl > < nl > } yield ( members , seqStateDate ) < nl > < nl > @ @ - 1242 , 7 + 1242 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > userId = cmd . targetUserId , < nl > update = updateCanEdit < nl > ) < nl > - seqState ← if ( state . typ . isChannel ) adminCHANNELUpdates else adminGROUPUpdates < nl > + seqState ← if ( state . groupType . isChannel ) adminCHANNELUpdates else adminGROUPUpdates < nl > < nl > } yield seqState < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > index 0f13f36 . . 78cf3df 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > @ @ - 62 , 7 + 62 , 7 @ @ trait GroupQueryHandlers { < nl > ) < nl > } < nl > < nl > - state . typ match { < nl > + state . groupType match { < nl > case General | Public ⇒ load < nl > case Channel ⇒ < nl > if ( state . isAdmin ( clientUserId ) ) load < nl > @ @ - 71 , 7 + 71 , 7 @ @ trait GroupQueryHandlers { < nl > } < nl > < nl > protected def isPublic = < nl > - FastFuture . successful ( IsPublicResponse ( isPublic = state . typ = = GroupType . Public ) ) < nl > + FastFuture . successful ( IsPublicResponse ( isPublic = state . groupType = = GroupType . Public ) ) < nl > < nl > protected def isHistoryShared = < nl > FastFuture . successful ( IsHistorySharedResponse ( state . isHistoryShared ) ) < nl > @ @ - 99 , 7 + 99 , 7 @ @ trait GroupQueryHandlers { < nl > isHidden = Some ( state . isHidden ) , < nl > ext = None , < nl > membersCount = Some ( count ) , < nl > - groupType = Some ( state . typ match { < nl > + groupType = Some ( state . groupType match { < nl > case GroupType . Channel ⇒ ApiGroupType . CHANNEL < nl > case GroupType . General | GroupType . Public | GroupType . Unrecognized ( _ ) ⇒ ApiGroupType . GROUP < nl > } ) , < nl > @ @ - 141 , 14 + 141 , 14 @ @ trait GroupQueryHandlers { < nl > protected def canSendMessage ( clientUserId : Int ) : Future [ CanSendMessageResponse ] = < nl > FastFuture . successful { < nl > val canSend = state . bot . exists ( _ . userId = = clientUserId ) | | { < nl > - state . typ match { < nl > + state . groupType match { < nl > case General | Public ⇒ state . isMember ( clientUserId ) < nl > case Channel ⇒ state . isAdmin ( clientUserId ) < nl > } < nl > } < nl > CanSendMessageResponse ( < nl > canSend = canSend , < nl > - isChannel = state . typ . isChannel , < nl > + isChannel = state . groupType . isChannel , < nl > memberIds = state . memberIds . toSeq , < nl > botId = state . bot . map ( _ . userId ) < nl > ) < nl > @ @ - 187 , 7 + 187 , 7 @ @ trait GroupQueryHandlers { < nl > } < nl > < nl > if ( state . isMember ( clientUserId ) ) { < nl > - state . typ match { < nl > + state . groupType match { < nl > case General | Public ⇒ < nl > apiMembers → group . membersCount < nl > case Channel ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > index a14cdf8 . . 094895c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > @ @ - 73 , 7 + 73 , 7 @ @ private [ group ] object GroupState { < nl > avatar = None , < nl > topic = None , < nl > shortName = None , < nl > - typ = GroupType . General , < nl > + groupType = GroupType . General , < nl > isHidden = false , < nl > isHistoryShared = false , < nl > members = Map . empty , < nl > @ @ - 101 , 7 + 101 , 7 @ @ private [ group ] final case class GroupState ( < nl > avatar : Option [ Avatar ] , < nl > topic : Option [ String ] , < nl > shortName : Option [ String ] , < nl > - typ : GroupType , / / TODO : rename to groupType < nl > + groupType : GroupType , / / TODO : rename to groupType < nl > isHidden : Boolean , < nl > isHistoryShared : Boolean , < nl > < nl > @ @ - 142 , 13 + 142 , 13 @ @ private [ group ] final case class GroupState ( < nl > val isCreated = createdAt . nonEmpty < nl > < nl > def isAsyncMembers = < nl > - typ match { < nl > + groupType match { < nl > case General | Public ⇒ members . size > 100 < nl > case Channel ⇒ true < nl > } < nl > < nl > def getShowableOwner ( clientUserId : Int ) : Option [ Int ] = < nl > - typ match { < nl > + groupType match { < nl > case General | Public ⇒ Some ( creatorUserId ) < nl > case Channel ⇒ if ( isAdmin ( clientUserId ) ) Some ( creatorUserId ) else None < nl > } < nl > @ @ - 164 , 7 + 164 , 7 @ @ private [ group ] final case class GroupState ( < nl > about = None , < nl > avatar = None , < nl > topic = None , < nl > - typ = evt . typ . getOrElse ( GroupType . General ) , < nl > + groupType = evt . typ . getOrElse ( GroupType . General ) , < nl > isHidden = evt . isHidden getOrElse false , < nl > isHistoryShared = evt . isHistoryShared getOrElse false , < nl > members = ( < nl > @ @ - 232 , 7 + 232 , 7 @ @ private [ group ] final case class GroupState ( < nl > this . copy ( title = newTitle ) < nl > case BecamePublic ( _ ) ⇒ < nl > this . copy ( < nl > - typ = GroupType . Public , < nl > + groupType = GroupType . Public , < nl > isHistoryShared = true < nl > ) < nl > case AboutUpdated ( _ , newAbout ) ⇒ < nl > @ @ - 273 , 7 + 273 , 7 @ @ private [ group ] final case class GroupState ( < nl > * / < nl > def canSendMessage ( clientUserId : Int ) = < nl > { < nl > - typ match { < nl > + groupType match { < nl > case General | Public ⇒ isMember ( clientUserId ) < nl > case Channel ⇒ isAdmin ( clientUserId ) | | isOwner ( clientUserId ) < nl > } < nl > @ @ - 284 , 7 + 284 , 7 @ @ private [ group ] final case class GroupState ( < nl > * in channels , owner and admins can view members < nl > * / < nl > def canViewMembers ( clientUserId : Int ) = < nl > - typ match { < nl > + groupType match { < nl > case General | Public ⇒ isMember ( clientUserId ) < nl > case Channel ⇒ isAdmin ( clientUserId ) | | isOwner ( clientUserId ) < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > index 97ec86e . . 4739346 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > @ @ - 65 , 6 + 65 , 7 @ @ trait ProcessorStateControl [ S < : ProcessorState [ S ] ] { < nl > < nl > protected def getInitialState : S < nl > < nl > + / / TODO : rename to processorState < nl > final def state : S = _ state < nl > < nl > def setState ( state : S ) = this . _ state = state < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 548cd03 . . e5c093a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 62 , 7 + 62 , 6 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { < nl > finalPeer = updatedSender getOrElse selfPeer < nl > _ ← db . run ( writeHistoryMessage ( finalPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > / / _ = dialogExt . updateCounters ( peer , userId ) < nl > - / / not sure about sender user id . It could be wrong when we have updatedSender ! < nl > SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , optClientAuthId , peer , sm . randomId , sendDate , message , sm . isFat , sm . deliveryTag ) < nl > } yield SeqStateDate ( seq , state , sendDate ) , < nl > failed = for { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index ab0dc2d . . 0c94fea 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 8 , 7 + 8 , 7 @ @ import akka . pattern . pipe < nl > import im . actor . api . rpc . Update < nl > import im . actor . api . rpc . files . ApiAvatar < nl > import im . actor . api . rpc . groups . _ < nl > - import im . actor . api . rpc . messaging . { ApiMessage , ApiServiceMessage , UpdateMessage } < nl > + import im . actor . api . rpc . messaging . { ApiServiceMessage , UpdateMessage } < nl > import im . actor . api . rpc . users . ApiSex < nl > import im . actor . concurrent . FutureExt < nl > import im . actor . server . CommonErrors < nl > @ @ - 113 , 7 + 113 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val result : Future [ CreateAck ] = for { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > _ ← seqUpdExt . deliverUserUpdate ( < nl > @ @ - 183 , 12 + 183 , 13 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > < nl > / / if user ever been in this group - we should push these updates , < nl > - / / but don ' t push them if user is first time in group . in this case we should push FatSeqUpdate < nl > val inviteeUpdatesNew : List [ Update ] = refreshGroupUpdates ( newState , cmd . inviteeUserId ) < nl > < nl > - / / send everyone in group , including invitee . < nl > - / / send ` FatSeqUpdate ` if this user invited to group for first time . < nl > - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , apiMembers ) < nl > + val membersUpdateNew : Update = < nl > + if ( newState . typ . isChannel ) / / if history shared < nl > + UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > + else < nl > + UpdateGroupMembersUpdated ( groupId , apiMembers ) < nl > < nl > val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( < nl > groupId , < nl > @ @ - 212 , 6 + 213 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > def inviteGROUPUpdates : Future [ SeqStateDate ] = < nl > for { < nl > / / push updated members list to inviteeUserId , < nl > + / / make it ` FatSeqUpdate ` if this user invited to group for first time . < nl > _ ← seqUpdExt . deliverUserUpdate ( < nl > userId = cmd . inviteeUserId , < nl > membersUpdateNew , < nl > @ @ - 246 , 54 + 248 , 44 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > def inviteCHANNELUpdates : Future [ SeqStateDate ] = < nl > for { < nl > - / / push ` UpdateGroupMembersUpdated ` to invitee only if he is admin . < nl > - / / invitee could be admin , if he created this group , and turning back < nl > - _ ← if ( newState . isAdmin ( cmd . inviteeUserId ) ) { < nl > - seqUpdExt . deliverUserUpdate ( < nl > - userId = cmd . inviteeUserId , < nl > - membersUpdateNew , < nl > - pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , < nl > - deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > - ) < nl > - } else { < nl > - FastFuture . successful ( ( ) ) < nl > - } < nl > + / / push updated members count to inviteeUserId < nl > + _ ← seqUpdExt . deliverUserUpdate ( < nl > + userId = cmd . inviteeUserId , < nl > + membersUpdateNew , < nl > + pushRules = seqUpdExt . pushRules ( isFat = false , Some ( PushTexts . Invited ) ) , < nl > + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > < nl > / / push all " refresh group " updates to inviteeUserId < nl > _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > } < nl > < nl > - / / push updated members list to all ADMINS < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - userIds = newState . adminIds , < nl > + / / push updated members count to all group members < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > + userId = cmd . inviterUserId , < nl > + authId = cmd . inviterAuthId , < nl > + bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > update = membersUpdateNew , < nl > deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > ) < nl > < nl > - / / push UpdateGroupMembersCountChanged to all group members < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - newState . memberIds , < nl > - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > - ) < nl > - < nl > / / push service message to invitee and inviter < nl > - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > - userId = cmd . inviterUserId , < nl > - authId = cmd . inviterAuthId , < nl > - Set ( cmd . inviteeUserId ) , < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + userIds = Set ( cmd . inviterUserId , cmd . inviteeUserId ) , < nl > update = serviceMessageUpdate ( < nl > cmd . inviterUserId , < nl > dateMillis , < nl > cmd . randomId , < nl > serviceMessage < nl > - ) < nl > + ) , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > ) < nl > } yield SeqStateDate ( seq , state , dateMillis ) < nl > < nl > val result : Future [ SeqStateDate ] = for { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > / / push " Invited " to invitee < nl > @ @ - 363 , 7 + 355 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val date = evt . ts < nl > val dateMillis = date . toEpochMilli < nl > val memberIds = newState . memberIds < nl > - val members = newState . members . values . map ( _ . asStruct ) . toVector < nl > + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > val randomId = ACLUtils . randomLong ( ) < nl > < nl > / / If user was never invited to group - he don ' t have group on devices , < nl > @ @ - 374 , 12 + 366 , 13 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val joiningUserUpdatesNew : List [ Update ] = < nl > if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) < nl > < nl > - / / push to everyone , including joining user . < nl > - / / if joining user wasn ' t invited - send update as FatSeqUpdate < nl > - / / update date when member got into group < nl > - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > + val membersUpdateNew : Update = < nl > + if ( newState . typ . isChannel ) / / if history is shared < nl > + UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > + else < nl > + UpdateGroupMembersUpdated ( groupId , apiMembers ) / / will update date when member got into group < nl > < nl > - val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , members ) < nl > + val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , apiMembers ) < nl > < nl > val serviceMessage = GroupServiceMessages . userJoined < nl > < nl > @ @ - 401 , 6 + 394 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > < nl > / / push updated members list to joining user , < nl > + / / make it ` FatSeqUpdate ` if this user invited to group for first time . < nl > / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . joiningUserId , < nl > @ @ - 434 , 34 + 428 , 21 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) < nl > } < nl > < nl > - / / push ` UpdateGroupMembersUpdated ` to joining user only if he is admin . < nl > - / / joining user can be admin , if he created this group , and turning back < nl > - / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > - SeqState ( seq , state ) ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { < nl > - seqUpdExt . deliverClientUpdate ( < nl > - userId = cmd . joiningUserId , < nl > - authId = cmd . joiningUserAuthId , < nl > - update = membersUpdateNew , < nl > - pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here < nl > - deliveryId = s " join _ $ { groupId } _ $ { randomId } " < nl > - ) < nl > - } else { < nl > - seqUpdExt . getSeqState ( cmd . joiningUserId , cmd . joiningUserAuthId ) < nl > - } < nl > + / / push updated members count to joining user < nl > + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > + userId = cmd . joiningUserId , < nl > + authId = cmd . joiningUserAuthId , < nl > + update = membersUpdateNew , < nl > + deliveryId = s " join _ $ { groupId } _ $ { randomId } " < nl > + ) < nl > < nl > - / / push updated members list to all ADMINS < nl > + / / push updated members count to all group members except joining user < nl > _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - newState . adminIds - cmd . joiningUserId , < nl > + memberIds - cmd . joiningUserId , < nl > membersUpdateNew , < nl > deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > ) < nl > < nl > - / / push UpdateGroupMembersCountChanged to all group members < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - newState . memberIds , < nl > - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > - ) < nl > - < nl > / / push service message only to inviter < nl > _ ← seqUpdExt . deliverUserUpdate ( < nl > userId = inviterUserId , < nl > @ @ - 470 , 14 + 451 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > dateMillis , < nl > randomId , < nl > serviceMessage < nl > - ) < nl > + ) , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > ) < nl > } yield SeqStateDate ( seq , state , dateMillis ) < nl > < nl > val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = < nl > for { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > / / push update about members to all users , except joining user < nl > @ @ - 514 , 7 + 496 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / no commit here . it will be after service message sent < nl > < nl > val dateMillis = evt . ts . toEpochMilli < nl > - val members = state . members . filterNot ( _ . _ 1 = = cmd . userId ) . values . map ( _ . asStruct ) . toVector < nl > < nl > val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) < nl > < nl > @ @ - 528 , 7 + 509 , 18 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > ) < nl > < nl > - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > + val membersUpdateNew = < nl > + if ( state . typ . isChannel ) { / / if history is shared < nl > + UpdateGroupMembersCountChanged ( < nl > + groupId , < nl > + membersCount = state . membersCount - 1 < nl > + ) < nl > + } else { < nl > + UpdateGroupMembersUpdated ( < nl > + groupId , < nl > + members = state . members . filterNot ( _ . _ 1 = = cmd . userId ) . values . map ( _ . asStruct ) . toVector < nl > + ) < nl > + } < nl > < nl > val serviceMessage = GroupServiceMessages . userLeft < nl > < nl > @ @ - 548 , 6 + 540 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > membersUpdateNew < nl > ) < nl > < nl > + / / send service message < nl > SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > apiGroupPeer , < nl > senderUserId = cmd . userId , < nl > @ @ - 574 , 16 + 567 , 10 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val leaveCHANNELUpdates : Future [ SeqStateDate ] = < nl > for { < nl > - / / push updated members list to all ADMINS , except userId ( if he was there ) < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - state . adminIds - cmd . userId , < nl > - membersUpdateNew < nl > - ) < nl > - < nl > - / / push UpdateGroupMembersCountChanged to all group members < nl > + / / push updated members count to all group members < nl > _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > state . memberIds - cmd . userId , < nl > - UpdateGroupMembersCountChanged ( groupId , state . membersCount - 1 ) < nl > + membersUpdateNew < nl > ) < nl > < nl > / / push service message to user , who invited leaving user < nl > @ @ - 596 , 7 + 583 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > dateMillis , < nl > cmd . randomId , < nl > serviceMessage < nl > - ) < nl > + ) , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > ) < nl > } getOrElse FastFuture . successful ( ( ) ) < nl > < nl > @ @ - 607 , 6 + 595 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > update = UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > ) < nl > < nl > + / / push left user updates that he has no group rights < nl > _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > } < nl > @ @ - 617 , 7 + 606 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val result : Future [ SeqStateDate ] = for { < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > _ ← seqUpdExt . broadcastClientUpdate ( < nl > @ @ - 651 , 7 + 640 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val newState = commit ( evt ) < nl > < nl > val dateMillis = evt . ts . toEpochMilli < nl > - val members = newState . members . values . map ( _ . asStruct ) . toVector < nl > < nl > val updateObsolete = UpdateGroupUserKickObsolete ( groupId , cmd . kickedUserId , cmd . kickerUserId , dateMillis , cmd . randomId ) < nl > < nl > @ @ - 667 , 7 + 655 , 18 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > ) < nl > < nl > - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > + val membersUpdateNew : Update = < nl > + if ( newState . typ . isChannel ) { / / if history is shared < nl > + UpdateGroupMembersCountChanged ( < nl > + groupId , < nl > + membersCount = newState . membersCount < nl > + ) < nl > + } else { < nl > + UpdateGroupMembersUpdated ( < nl > + groupId , < nl > + members = newState . members . values . map ( _ . asStruct ) . toVector < nl > + ) < nl > + } < nl > < nl > val serviceMessage = GroupServiceMessages . userKicked ( cmd . kickedUserId ) < nl > < nl > @ @ - 709 , 20 + 708 , 14 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val kickCHANNELUpdates : Future [ SeqStateDate ] = < nl > for { < nl > - / / push updated members list to all ADMINS . Don ' t push to kicked user ! < nl > + / / push updated members count to all group members . Don ' t push to kicked user ! < nl > SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > userId = cmd . kickerUserId , < nl > authId = cmd . kickerAuthId , < nl > - bcastUserIds = newState . adminIds - cmd . kickerUserId , < nl > + bcastUserIds = newState . memberIds - cmd . kickerUserId , < nl > update = membersUpdateNew < nl > ) < nl > < nl > - / / push UpdateGroupMembersCountChanged to all group members < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - newState . memberIds , < nl > - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > - ) < nl > - < nl > / / push service message to kicker and kicked users . < nl > _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > userIds = Set ( cmd . kickedUserId , cmd . kickerUserId ) , < nl > @ @ - 731 , 10 + 724 , 11 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > dateMillis , < nl > cmd . randomId , < nl > serviceMessage < nl > - ) < nl > + ) , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > ) < nl > < nl > - / / push kicked user updates < nl > + / / push kicked user updates that he has no group rights < nl > _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ < nl > seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) < nl > } < nl > @ @ - 744 , 7 + 738 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) < nl > val result : Future [ SeqStateDate ] = for { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > _ ← seqUpdExt . broadcastClientUpdate ( < nl > @ @ - 788 , 7 + 782 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > db . run ( AvatarDataRepo . createOrUpdate ( getAvatarData ( cmd . avatar ) ) ) < nl > val result : Future [ UpdateAvatarAck ] = for { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > _ ← seqUpdExt . broadcastClientUpdate ( cmd . clientUserId , cmd . clientAuthId , memberIds , updateObsolete ) < nl > @ @ - 850 , 7 + 844 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val result : Future [ SeqStateDate ] = for { < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > _ ← seqUpdExt . broadcastClientUpdate ( < nl > @ @ - 923 , 7 + 917 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val result : Future [ SeqStateDate ] = for { < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > _ ← seqUpdExt . broadcastClientUpdate ( < nl > @ @ - 987 , 7 + 981 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val result : Future [ SeqStateDate ] = for { < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > _ ← seqUpdExt . broadcastClientUpdate ( < nl > @ @ - 1009 , 15 + 1003 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > update = updateNew , < nl > pushRules = pushRules < nl > ) < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - senderUserId = cmd . clientUserId , < nl > - senderAuthId = cmd . clientAuthId , < nl > - randomId = cmd . randomId , < nl > - message = serviceMessage , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > - } yield SeqStateDate ( seq , state , date ) < nl > + } yield SeqStateDate ( seq , state , evt . ts . toEpochMilli ) < nl > < nl > result pipeTo sender ( ) < nl > } < nl > @ @ - 1104 , 7 + 1090 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val result : Future [ ( Vector [ ApiMember ] , SeqStateDate ) ] = for { < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > + / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > _ ← seqUpdExt . broadcastClientUpdate ( < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > index 77ed12f . . 8251037 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > @ @ - 70 , 14 + 70 , 14 @ @ private [ group ] final case class GroupState ( < nl > / / security and etc . < nl > accessHash : Long , < nl > bot : Option [ Bot ] , < nl > - extensions : Map [ Int , Array [ Byte ] ] / / or should it be sequence ? ? ? < nl > + extensions : Map [ Int , Array [ Byte ] ] < nl > ) extends ProcessorState [ GroupState ] { < nl > < nl > - def memberIds = members . keySet / / TODO : Maybe lazy val . immutable anyway < nl > + lazy val memberIds = members . keySet < nl > < nl > - def adminIds = ( members filter ( _ . _ 2 . isAdmin = = true ) ) . keySet / / TODO : Maybe lazy val . immutable anyway < nl > + lazy val adminIds = ( members filter ( _ . _ 2 . isAdmin = = true ) ) . keySet < nl > < nl > - def membersCount = members . size / / TODO : Maybe lazy val . immutable anyway < nl > + lazy val membersCount = members . size < nl > < nl > def isMember ( userId : Int ) : Boolean = members . contains ( userId ) < nl > < nl > @ @ - 112 , 9 + 112 , 9 @ @ private [ group ] final case class GroupState ( < nl > } < nl > } | | bot . exists ( _ . userId = = clientUserId ) < nl > < nl > - def isNotCreated = createdAt . isEmpty / / TODO : Maybe val . immutable anyway < nl > + val isNotCreated = createdAt . isEmpty < nl > < nl > - def isCreated = createdAt . nonEmpty / / TODO : Maybe val . immutable anyway < nl > + val isCreated = createdAt . nonEmpty < nl > < nl > def isAsyncMembers = < nl > typ match { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / PushTexts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / PushTexts . scala < nl > index 95603ff . . a270327 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / PushTexts . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / PushTexts . scala < nl > @ @ - 1 , 5 + 1 , 6 @ @ < nl > package im . actor . server . office < nl > < nl > + / / TODO : make up to date with channels < nl > object PushTexts { < nl > val Added = " User added " < nl > val Invited = " You are invited to a group " < nl > @ @ - 8 , 4 + 9 , 4 @ @ object PushTexts { < nl > val TitleChanged = " Group title changed " < nl > val TopicChanged = " Group topic changed " < nl > val AboutChanged = " Group about changed " < nl > - } < nl > \ No newline at end of file < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > index 80a199b . . 38c7c21 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > @ @ - 95 , 14 + 95 , 15 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ < nl > * Send update to all devices of users from ` userIds ` set and return ` Unit ` < nl > * / < nl > def broadcastPeopleUpdate ( < nl > - userIds : Set [ Int ] , < nl > - update : Update , < nl > - pushRules : PushRules = PushRules ( ) , < nl > - reduceKey : Option [ String ] = None , < nl > - deliveryId : String = " " < nl > + userIds : Set [ Int ] , < nl > + update : Update , < nl > + pushRules : PushRules = PushRules ( ) , < nl > + reduceKey : Option [ String ] = None , < nl > + deliveryId : String = " " , < nl > + deliveryTag : Option [ String ] = None < nl > ) : Future [ Unit ] = { < nl > val mapping = UpdateMapping ( default = Some ( serializedUpdate ( update ) ) ) < nl > - val deliver = buildDeliver ( 0L , mapping , pushRules , reduceKey , deliveryId , deliveryTag = None ) / / TODO : add deliveryTag when needed < nl > + val deliver = buildDeliver ( 0L , mapping , pushRules , reduceKey , deliveryId , deliveryTag ) < nl > broadcastUpdate ( userIds , deliver ) < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 5f7531b . . 6b8e259 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 65 , 7 + 65 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 / / Group creation 
 val groupType = GroupType . fromValue ( cmd . typ ) / / FIXME : make it normal enum 
 - val isHistoryShared = groupType . isChannel 
 + val isHistoryShared = groupType . isChannel | | groupType . isPublic 
 
 persist ( Created ( 
 ts = createdAt , 
 @ @ - 101 , 7 + 101 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 creatorUserId = newState . creatorUserId , 
 accessHash = newState . accessHash , 
 title = newState . title , 
 - isPublic = newState . typ = = GroupType . Public , 
 + isPublic = isHistoryShared , 
 createdAt = evt . ts , 
 about = None , 
 topic = None 
 @ @ - 190 , 7 + 190 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val inviteeUpdatesNew : List [ Update ] = refreshGroupUpdates ( newState , cmd . inviteeUserId ) 
 
 val membersUpdateNew : Update = 
 - if ( newState . typ . isChannel ) / / if history shared 
 + if ( newState . groupType . isChannel ) / / if channel , or group is big enough 
 UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 else 
 UpdateGroupMembersUpdated ( groupId , apiMembers ) 
 @ @ - 321 , 7 + 321 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - seqStateDate ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates 
 + seqStateDate ← if ( newState . groupType . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates 
 
 } yield seqStateDate 
 
 @ @ - 371 , 7 + 371 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) 
 
 val membersUpdateNew : Update = 
 - if ( newState . typ . isChannel ) / / if history is shared 
 + if ( newState . groupType . isChannel ) / / if channel , or group is big enough 
 UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 else 
 UpdateGroupMembersUpdated ( groupId , apiMembers ) / / will update date when member got into group 
 @ @ - 466 , 7 + 466 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - seqStateDate ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates 
 + seqStateDate ← if ( newState . groupType . isChannel ) joinCHANNELUpdates else joinGROUPUpdates 
 
 } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) 
 
 @ @ - 493 , 7 + 493 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 / / TODO : merge , they are almost identical 
 val leftUserUpdatesNew = 
 - if ( state . typ . isChannel ) List ( 
 + if ( state . groupType . isChannel ) List ( 
 UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 UpdateGroupCanEditInfoChanged ( groupId , canEditGroup = false ) , 
 UpdateGroupCanEditUsernameChanged ( groupId , canEditUsername = false ) , 
 @ @ - 514 , 7 + 514 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 val membersUpdateNew = 
 - if ( state . typ . isChannel ) { / / if history is shared 
 + if ( state . groupType . isChannel ) { / / if channel , or group is big enough 
 UpdateGroupMembersCountChanged ( 
 groupId , 
 membersCount = state . membersCount - 1 
 @ @ - 610 , 7 + 610 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - seqStateDate ← if ( state . typ . isChannel ) leaveCHANNELUpdates else leaveGROUPUpdates 
 + seqStateDate ← if ( state . groupType . isChannel ) leaveCHANNELUpdates else leaveGROUPUpdates 
 
 } yield seqStateDate 
 
 @ @ - 634 , 7 + 634 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 / / TODO : merge , they are almost identical 
 val kickedUserUpdatesNew : List [ Update ] = 
 - if ( state . typ . isChannel ) List ( 
 + if ( state . groupType . isChannel ) List ( 
 UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 UpdateGroupCanEditInfoChanged ( groupId , canEditGroup = false ) , 
 UpdateGroupCanEditUsernameChanged ( groupId , canEditUsername = false ) , 
 @ @ - 657 , 7 + 657 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 val membersUpdateNew : Update = 
 - if ( newState . typ . isChannel ) { / / if history is shared 
 + if ( newState . groupType . isChannel ) { / / if channel , or group is big enough 
 UpdateGroupMembersCountChanged ( 
 groupId , 
 membersCount = newState . membersCount 
 @ @ - 754 , 7 + 754 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - seqStateDate ← if ( state . typ . isChannel ) kickCHANNELUpdates else kickGROUPUpdates 
 + seqStateDate ← if ( state . groupType . isChannel ) kickCHANNELUpdates else kickGROUPUpdates 
 
 } yield seqStateDate 
 
 @ @ - 1156 , 7 + 1156 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 userId = cmd . candidateUserId , 
 update = updateCanEdit 
 ) 
 - seqStateDate ← if ( state . typ . isChannel ) adminCHANNELUpdates else adminGROUPUpdates 
 + seqStateDate ← if ( state . groupType . isChannel ) adminCHANNELUpdates else adminGROUPUpdates 
 
 } yield ( members , seqStateDate ) 
 
 @ @ - 1242 , 7 + 1242 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 userId = cmd . targetUserId , 
 update = updateCanEdit 
 ) 
 - seqState ← if ( state . typ . isChannel ) adminCHANNELUpdates else adminGROUPUpdates 
 + seqState ← if ( state . groupType . isChannel ) adminCHANNELUpdates else adminGROUPUpdates 
 
 } yield seqState 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 index 0f13f36 . . 78cf3df 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 @ @ - 62 , 7 + 62 , 7 @ @ trait GroupQueryHandlers { 
 ) 
 } 
 
 - state . typ match { 
 + state . groupType match { 
 case General | Public ⇒ load 
 case Channel ⇒ 
 if ( state . isAdmin ( clientUserId ) ) load 
 @ @ - 71 , 7 + 71 , 7 @ @ trait GroupQueryHandlers { 
 } 
 
 protected def isPublic = 
 - FastFuture . successful ( IsPublicResponse ( isPublic = state . typ = = GroupType . Public ) ) 
 + FastFuture . successful ( IsPublicResponse ( isPublic = state . groupType = = GroupType . Public ) ) 
 
 protected def isHistoryShared = 
 FastFuture . successful ( IsHistorySharedResponse ( state . isHistoryShared ) ) 
 @ @ - 99 , 7 + 99 , 7 @ @ trait GroupQueryHandlers { 
 isHidden = Some ( state . isHidden ) , 
 ext = None , 
 membersCount = Some ( count ) , 
 - groupType = Some ( state . typ match { 
 + groupType = Some ( state . groupType match { 
 case GroupType . Channel ⇒ ApiGroupType . CHANNEL 
 case GroupType . General | GroupType . Public | GroupType . Unrecognized ( _ ) ⇒ ApiGroupType . GROUP 
 } ) , 
 @ @ - 141 , 14 + 141 , 14 @ @ trait GroupQueryHandlers { 
 protected def canSendMessage ( clientUserId : Int ) : Future [ CanSendMessageResponse ] = 
 FastFuture . successful { 
 val canSend = state . bot . exists ( _ . userId = = clientUserId ) | | { 
 - state . typ match { 
 + state . groupType match { 
 case General | Public ⇒ state . isMember ( clientUserId ) 
 case Channel ⇒ state . isAdmin ( clientUserId ) 
 } 
 } 
 CanSendMessageResponse ( 
 canSend = canSend , 
 - isChannel = state . typ . isChannel , 
 + isChannel = state . groupType . isChannel , 
 memberIds = state . memberIds . toSeq , 
 botId = state . bot . map ( _ . userId ) 
 ) 
 @ @ - 187 , 7 + 187 , 7 @ @ trait GroupQueryHandlers { 
 } 
 
 if ( state . isMember ( clientUserId ) ) { 
 - state . typ match { 
 + state . groupType match { 
 case General | Public ⇒ 
 apiMembers → group . membersCount 
 case Channel ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 index a14cdf8 . . 094895c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 @ @ - 73 , 7 + 73 , 7 @ @ private [ group ] object GroupState { 
 avatar = None , 
 topic = None , 
 shortName = None , 
 - typ = GroupType . General , 
 + groupType = GroupType . General , 
 isHidden = false , 
 isHistoryShared = false , 
 members = Map . empty , 
 @ @ - 101 , 7 + 101 , 7 @ @ private [ group ] final case class GroupState ( 
 avatar : Option [ Avatar ] , 
 topic : Option [ String ] , 
 shortName : Option [ String ] , 
 - typ : GroupType , / / TODO : rename to groupType 
 + groupType : GroupType , / / TODO : rename to groupType 
 isHidden : Boolean , 
 isHistoryShared : Boolean , 
 
 @ @ - 142 , 13 + 142 , 13 @ @ private [ group ] final case class GroupState ( 
 val isCreated = createdAt . nonEmpty 
 
 def isAsyncMembers = 
 - typ match { 
 + groupType match { 
 case General | Public ⇒ members . size > 100 
 case Channel ⇒ true 
 } 
 
 def getShowableOwner ( clientUserId : Int ) : Option [ Int ] = 
 - typ match { 
 + groupType match { 
 case General | Public ⇒ Some ( creatorUserId ) 
 case Channel ⇒ if ( isAdmin ( clientUserId ) ) Some ( creatorUserId ) else None 
 } 
 @ @ - 164 , 7 + 164 , 7 @ @ private [ group ] final case class GroupState ( 
 about = None , 
 avatar = None , 
 topic = None , 
 - typ = evt . typ . getOrElse ( GroupType . General ) , 
 + groupType = evt . typ . getOrElse ( GroupType . General ) , 
 isHidden = evt . isHidden getOrElse false , 
 isHistoryShared = evt . isHistoryShared getOrElse false , 
 members = ( 
 @ @ - 232 , 7 + 232 , 7 @ @ private [ group ] final case class GroupState ( 
 this . copy ( title = newTitle ) 
 case BecamePublic ( _ ) ⇒ 
 this . copy ( 
 - typ = GroupType . Public , 
 + groupType = GroupType . Public , 
 isHistoryShared = true 
 ) 
 case AboutUpdated ( _ , newAbout ) ⇒ 
 @ @ - 273 , 7 + 273 , 7 @ @ private [ group ] final case class GroupState ( 
 * / 
 def canSendMessage ( clientUserId : Int ) = 
 { 
 - typ match { 
 + groupType match { 
 case General | Public ⇒ isMember ( clientUserId ) 
 case Channel ⇒ isAdmin ( clientUserId ) | | isOwner ( clientUserId ) 
 } 
 @ @ - 284 , 7 + 284 , 7 @ @ private [ group ] final case class GroupState ( 
 * in channels , owner and admins can view members 
 * / 
 def canViewMembers ( clientUserId : Int ) = 
 - typ match { 
 + groupType match { 
 case General | Public ⇒ isMember ( clientUserId ) 
 case Channel ⇒ isAdmin ( clientUserId ) | | isOwner ( clientUserId ) 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 index 97ec86e . . 4739346 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 @ @ - 65 , 6 + 65 , 7 @ @ trait ProcessorStateControl [ S < : ProcessorState [ S ] ] { 
 
 protected def getInitialState : S 
 
 + / / TODO : rename to processorState 
 final def state : S = _ state 
 
 def setState ( state : S ) = this . _ state = state 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 548cd03 . . e5c093a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 62 , 7 + 62 , 6 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { 
 finalPeer = updatedSender getOrElse selfPeer 
 _ ← db . run ( writeHistoryMessage ( finalPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 / / _ = dialogExt . updateCounters ( peer , userId ) 
 - / / not sure about sender user id . It could be wrong when we have updatedSender ! 
 SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , optClientAuthId , peer , sm . randomId , sendDate , message , sm . isFat , sm . deliveryTag ) 
 } yield SeqStateDate ( seq , state , sendDate ) , 
 failed = for { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index ab0dc2d . . 0c94fea 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 8 , 7 + 8 , 7 @ @ import akka . pattern . pipe 
 import im . actor . api . rpc . Update 
 import im . actor . api . rpc . files . ApiAvatar 
 import im . actor . api . rpc . groups . _ 
 - import im . actor . api . rpc . messaging . { ApiMessage , ApiServiceMessage , UpdateMessage } 
 + import im . actor . api . rpc . messaging . { ApiServiceMessage , UpdateMessage } 
 import im . actor . api . rpc . users . ApiSex 
 import im . actor . concurrent . FutureExt 
 import im . actor . server . CommonErrors 
 @ @ - 113 , 7 + 113 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val result : Future [ CreateAck ] = for { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 _ ← seqUpdExt . deliverUserUpdate ( 
 @ @ - 183 , 12 + 183 , 13 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 
 / / if user ever been in this group - we should push these updates , 
 - / / but don ' t push them if user is first time in group . in this case we should push FatSeqUpdate 
 val inviteeUpdatesNew : List [ Update ] = refreshGroupUpdates ( newState , cmd . inviteeUserId ) 
 
 - / / send everyone in group , including invitee . 
 - / / send ` FatSeqUpdate ` if this user invited to group for first time . 
 - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , apiMembers ) 
 + val membersUpdateNew : Update = 
 + if ( newState . typ . isChannel ) / / if history shared 
 + UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 + else 
 + UpdateGroupMembersUpdated ( groupId , apiMembers ) 
 
 val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( 
 groupId , 
 @ @ - 212 , 6 + 213 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 def inviteGROUPUpdates : Future [ SeqStateDate ] = 
 for { 
 / / push updated members list to inviteeUserId , 
 + / / make it ` FatSeqUpdate ` if this user invited to group for first time . 
 _ ← seqUpdExt . deliverUserUpdate ( 
 userId = cmd . inviteeUserId , 
 membersUpdateNew , 
 @ @ - 246 , 54 + 248 , 44 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 def inviteCHANNELUpdates : Future [ SeqStateDate ] = 
 for { 
 - / / push ` UpdateGroupMembersUpdated ` to invitee only if he is admin . 
 - / / invitee could be admin , if he created this group , and turning back 
 - _ ← if ( newState . isAdmin ( cmd . inviteeUserId ) ) { 
 - seqUpdExt . deliverUserUpdate ( 
 - userId = cmd . inviteeUserId , 
 - membersUpdateNew , 
 - pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , 
 - deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 - ) 
 - } else { 
 - FastFuture . successful ( ( ) ) 
 - } 
 + / / push updated members count to inviteeUserId 
 + _ ← seqUpdExt . deliverUserUpdate ( 
 + userId = cmd . inviteeUserId , 
 + membersUpdateNew , 
 + pushRules = seqUpdExt . pushRules ( isFat = false , Some ( PushTexts . Invited ) ) , 
 + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 
 / / push all " refresh group " updates to inviteeUserId 
 _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 } 
 
 - / / push updated members list to all ADMINS 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - userIds = newState . adminIds , 
 + / / push updated members count to all group members 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 + userId = cmd . inviterUserId , 
 + authId = cmd . inviterAuthId , 
 + bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 update = membersUpdateNew , 
 deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 ) 
 
 - / / push UpdateGroupMembersCountChanged to all group members 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - newState . memberIds , 
 - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 - ) 
 - 
 / / push service message to invitee and inviter 
 - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 - userId = cmd . inviterUserId , 
 - authId = cmd . inviterAuthId , 
 - Set ( cmd . inviteeUserId ) , 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + userIds = Set ( cmd . inviterUserId , cmd . inviteeUserId ) , 
 update = serviceMessageUpdate ( 
 cmd . inviterUserId , 
 dateMillis , 
 cmd . randomId , 
 serviceMessage 
 - ) 
 + ) , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 ) 
 } yield SeqStateDate ( seq , state , dateMillis ) 
 
 val result : Future [ SeqStateDate ] = for { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 / / push " Invited " to invitee 
 @ @ - 363 , 7 + 355 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val date = evt . ts 
 val dateMillis = date . toEpochMilli 
 val memberIds = newState . memberIds 
 - val members = newState . members . values . map ( _ . asStruct ) . toVector 
 + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 val randomId = ACLUtils . randomLong ( ) 
 
 / / If user was never invited to group - he don ' t have group on devices , 
 @ @ - 374 , 12 + 366 , 13 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val joiningUserUpdatesNew : List [ Update ] = 
 if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) 
 
 - / / push to everyone , including joining user . 
 - / / if joining user wasn ' t invited - send update as FatSeqUpdate 
 - / / update date when member got into group 
 - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 + val membersUpdateNew : Update = 
 + if ( newState . typ . isChannel ) / / if history is shared 
 + UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 + else 
 + UpdateGroupMembersUpdated ( groupId , apiMembers ) / / will update date when member got into group 
 
 - val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , members ) 
 + val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , apiMembers ) 
 
 val serviceMessage = GroupServiceMessages . userJoined 
 
 @ @ - 401 , 6 + 394 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 
 / / push updated members list to joining user , 
 + / / make it ` FatSeqUpdate ` if this user invited to group for first time . 
 / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 userId = cmd . joiningUserId , 
 @ @ - 434 , 34 + 428 , 21 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) 
 } 
 
 - / / push ` UpdateGroupMembersUpdated ` to joining user only if he is admin . 
 - / / joining user can be admin , if he created this group , and turning back 
 - / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 - SeqState ( seq , state ) ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { 
 - seqUpdExt . deliverClientUpdate ( 
 - userId = cmd . joiningUserId , 
 - authId = cmd . joiningUserAuthId , 
 - update = membersUpdateNew , 
 - pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here 
 - deliveryId = s " join _ $ { groupId } _ $ { randomId } " 
 - ) 
 - } else { 
 - seqUpdExt . getSeqState ( cmd . joiningUserId , cmd . joiningUserAuthId ) 
 - } 
 + / / push updated members count to joining user 
 + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 + userId = cmd . joiningUserId , 
 + authId = cmd . joiningUserAuthId , 
 + update = membersUpdateNew , 
 + deliveryId = s " join _ $ { groupId } _ $ { randomId } " 
 + ) 
 
 - / / push updated members list to all ADMINS 
 + / / push updated members count to all group members except joining user 
 _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - newState . adminIds - cmd . joiningUserId , 
 + memberIds - cmd . joiningUserId , 
 membersUpdateNew , 
 deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 ) 
 
 - / / push UpdateGroupMembersCountChanged to all group members 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - newState . memberIds , 
 - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 - ) 
 - 
 / / push service message only to inviter 
 _ ← seqUpdExt . deliverUserUpdate ( 
 userId = inviterUserId , 
 @ @ - 470 , 14 + 451 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 dateMillis , 
 randomId , 
 serviceMessage 
 - ) 
 + ) , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 ) 
 } yield SeqStateDate ( seq , state , dateMillis ) 
 
 val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = 
 for { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 / / push update about members to all users , except joining user 
 @ @ - 514 , 7 + 496 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / no commit here . it will be after service message sent 
 
 val dateMillis = evt . ts . toEpochMilli 
 - val members = state . members . filterNot ( _ . _ 1 = = cmd . userId ) . values . map ( _ . asStruct ) . toVector 
 
 val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) 
 
 @ @ - 528 , 7 + 509 , 18 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 ) 
 
 - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 + val membersUpdateNew = 
 + if ( state . typ . isChannel ) { / / if history is shared 
 + UpdateGroupMembersCountChanged ( 
 + groupId , 
 + membersCount = state . membersCount - 1 
 + ) 
 + } else { 
 + UpdateGroupMembersUpdated ( 
 + groupId , 
 + members = state . members . filterNot ( _ . _ 1 = = cmd . userId ) . values . map ( _ . asStruct ) . toVector 
 + ) 
 + } 
 
 val serviceMessage = GroupServiceMessages . userLeft 
 
 @ @ - 548 , 6 + 540 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 membersUpdateNew 
 ) 
 
 + / / send service message 
 SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 apiGroupPeer , 
 senderUserId = cmd . userId , 
 @ @ - 574 , 16 + 567 , 10 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val leaveCHANNELUpdates : Future [ SeqStateDate ] = 
 for { 
 - / / push updated members list to all ADMINS , except userId ( if he was there ) 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - state . adminIds - cmd . userId , 
 - membersUpdateNew 
 - ) 
 - 
 - / / push UpdateGroupMembersCountChanged to all group members 
 + / / push updated members count to all group members 
 _ ← seqUpdExt . broadcastPeopleUpdate ( 
 state . memberIds - cmd . userId , 
 - UpdateGroupMembersCountChanged ( groupId , state . membersCount - 1 ) 
 + membersUpdateNew 
 ) 
 
 / / push service message to user , who invited leaving user 
 @ @ - 596 , 7 + 583 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 dateMillis , 
 cmd . randomId , 
 serviceMessage 
 - ) 
 + ) , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 ) 
 } getOrElse FastFuture . successful ( ( ) ) 
 
 @ @ - 607 , 6 + 595 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 update = UpdateGroupMemberChanged ( groupId , isMember = false ) 
 ) 
 
 + / / push left user updates that he has no group rights 
 _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 } 
 @ @ - 617 , 7 + 606 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val result : Future [ SeqStateDate ] = for { 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 _ ← seqUpdExt . broadcastClientUpdate ( 
 @ @ - 651 , 7 + 640 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val newState = commit ( evt ) 
 
 val dateMillis = evt . ts . toEpochMilli 
 - val members = newState . members . values . map ( _ . asStruct ) . toVector 
 
 val updateObsolete = UpdateGroupUserKickObsolete ( groupId , cmd . kickedUserId , cmd . kickerUserId , dateMillis , cmd . randomId ) 
 
 @ @ - 667 , 7 + 655 , 18 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 UpdateGroupMemberChanged ( groupId , isMember = false ) 
 ) 
 
 - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 + val membersUpdateNew : Update = 
 + if ( newState . typ . isChannel ) { / / if history is shared 
 + UpdateGroupMembersCountChanged ( 
 + groupId , 
 + membersCount = newState . membersCount 
 + ) 
 + } else { 
 + UpdateGroupMembersUpdated ( 
 + groupId , 
 + members = newState . members . values . map ( _ . asStruct ) . toVector 
 + ) 
 + } 
 
 val serviceMessage = GroupServiceMessages . userKicked ( cmd . kickedUserId ) 
 
 @ @ - 709 , 20 + 708 , 14 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val kickCHANNELUpdates : Future [ SeqStateDate ] = 
 for { 
 - / / push updated members list to all ADMINS . Don ' t push to kicked user ! 
 + / / push updated members count to all group members . Don ' t push to kicked user ! 
 SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 userId = cmd . kickerUserId , 
 authId = cmd . kickerAuthId , 
 - bcastUserIds = newState . adminIds - cmd . kickerUserId , 
 + bcastUserIds = newState . memberIds - cmd . kickerUserId , 
 update = membersUpdateNew 
 ) 
 
 - / / push UpdateGroupMembersCountChanged to all group members 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - newState . memberIds , 
 - UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 - ) 
 - 
 / / push service message to kicker and kicked users . 
 _ ← seqUpdExt . broadcastPeopleUpdate ( 
 userIds = Set ( cmd . kickedUserId , cmd . kickerUserId ) , 
 @ @ - 731 , 10 + 724 , 11 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 dateMillis , 
 cmd . randomId , 
 serviceMessage 
 - ) 
 + ) , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 ) 
 
 - / / push kicked user updates 
 + / / push kicked user updates that he has no group rights 
 _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ 
 seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) 
 } 
 @ @ - 744 , 7 + 738 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) 
 val result : Future [ SeqStateDate ] = for { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 _ ← seqUpdExt . broadcastClientUpdate ( 
 @ @ - 788 , 7 + 782 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 db . run ( AvatarDataRepo . createOrUpdate ( getAvatarData ( cmd . avatar ) ) ) 
 val result : Future [ UpdateAvatarAck ] = for { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 _ ← seqUpdExt . broadcastClientUpdate ( cmd . clientUserId , cmd . clientAuthId , memberIds , updateObsolete ) 
 @ @ - 850 , 7 + 844 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val result : Future [ SeqStateDate ] = for { 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 _ ← seqUpdExt . broadcastClientUpdate ( 
 @ @ - 923 , 7 + 917 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val result : Future [ SeqStateDate ] = for { 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 _ ← seqUpdExt . broadcastClientUpdate ( 
 @ @ - 987 , 7 + 981 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val result : Future [ SeqStateDate ] = for { 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 _ ← seqUpdExt . broadcastClientUpdate ( 
 @ @ - 1009 , 15 + 1003 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 update = updateNew , 
 pushRules = pushRules 
 ) 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - senderUserId = cmd . clientUserId , 
 - senderAuthId = cmd . clientAuthId , 
 - randomId = cmd . randomId , 
 - message = serviceMessage , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 - } yield SeqStateDate ( seq , state , date ) 
 + } yield SeqStateDate ( seq , state , evt . ts . toEpochMilli ) 
 
 result pipeTo sender ( ) 
 } 
 @ @ - 1104 , 7 + 1090 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val result : Future [ ( Vector [ ApiMember ] , SeqStateDate ) ] = for { 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 + / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 _ ← seqUpdExt . broadcastClientUpdate ( 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 index 77ed12f . . 8251037 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 @ @ - 70 , 14 + 70 , 14 @ @ private [ group ] final case class GroupState ( 
 / / security and etc . 
 accessHash : Long , 
 bot : Option [ Bot ] , 
 - extensions : Map [ Int , Array [ Byte ] ] / / or should it be sequence ? ? ? 
 + extensions : Map [ Int , Array [ Byte ] ] 
 ) extends ProcessorState [ GroupState ] { 
 
 - def memberIds = members . keySet / / TODO : Maybe lazy val . immutable anyway 
 + lazy val memberIds = members . keySet 
 
 - def adminIds = ( members filter ( _ . _ 2 . isAdmin = = true ) ) . keySet / / TODO : Maybe lazy val . immutable anyway 
 + lazy val adminIds = ( members filter ( _ . _ 2 . isAdmin = = true ) ) . keySet 
 
 - def membersCount = members . size / / TODO : Maybe lazy val . immutable anyway 
 + lazy val membersCount = members . size 
 
 def isMember ( userId : Int ) : Boolean = members . contains ( userId ) 
 
 @ @ - 112 , 9 + 112 , 9 @ @ private [ group ] final case class GroupState ( 
 } 
 } | | bot . exists ( _ . userId = = clientUserId ) 
 
 - def isNotCreated = createdAt . isEmpty / / TODO : Maybe val . immutable anyway 
 + val isNotCreated = createdAt . isEmpty 
 
 - def isCreated = createdAt . nonEmpty / / TODO : Maybe val . immutable anyway 
 + val isCreated = createdAt . nonEmpty 
 
 def isAsyncMembers = 
 typ match { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / PushTexts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / PushTexts . scala 
 index 95603ff . . a270327 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / PushTexts . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / PushTexts . scala 
 @ @ - 1 , 5 + 1 , 6 @ @ 
 package im . actor . server . office 
 
 + / / TODO : make up to date with channels 
 object PushTexts { 
 val Added = " User added " 
 val Invited = " You are invited to a group " 
 @ @ - 8 , 4 + 9 , 4 @ @ object PushTexts { 
 val TitleChanged = " Group title changed " 
 val TopicChanged = " Group topic changed " 
 val AboutChanged = " Group about changed " 
 - } 
 \ No newline at end of file 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 index 80a199b . . 38c7c21 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 @ @ - 95 , 14 + 95 , 15 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ 
 * Send update to all devices of users from ` userIds ` set and return ` Unit ` 
 * / 
 def broadcastPeopleUpdate ( 
 - userIds : Set [ Int ] , 
 - update : Update , 
 - pushRules : PushRules = PushRules ( ) , 
 - reduceKey : Option [ String ] = None , 
 - deliveryId : String = " " 
 + userIds : Set [ Int ] , 
 + update : Update , 
 + pushRules : PushRules = PushRules ( ) , 
 + reduceKey : Option [ String ] = None , 
 + deliveryId : String = " " , 
 + deliveryTag : Option [ String ] = None 
 ) : Future [ Unit ] = { 
 val mapping = UpdateMapping ( default = Some ( serializedUpdate ( update ) ) ) 
 - val deliver = buildDeliver ( 0L , mapping , pushRules , reduceKey , deliveryId , deliveryTag = None ) / / TODO : add deliveryTag when needed 
 + val deliver = buildDeliver ( 0L , mapping , pushRules , reduceKey , deliveryId , deliveryTag ) 
 broadcastUpdate ( userIds , deliver ) 
 }
