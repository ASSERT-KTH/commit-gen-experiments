BLEU SCORE: 0.17694975149532557

TEST MSG: fix ( server : rpc , core ) : don ' t allow to add self in contacts
GENERATED MSG: fix ( server : auth ) : dont allow deleted users to log in

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 773c0f3 . . e1c0af4 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 370 , 25 + 370 , 29 @ @ private [ user ] trait UserCommandHandlers { < nl > user : UserState , < nl > contactsToAdd : Seq [ UserCommands . ContactToAdd ] < nl > ) : Unit = { < nl > - val ( idsLocalNames , plains , phones , emails ) = contactsToAdd . view . map { < nl > - case UserCommands . ContactToAdd ( contactUserId , localNameOpt , phoneOpt , emailOpt ) ⇒ < nl > - val phone = phoneOpt map ( UserPhoneContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) < nl > - val email = emailOpt map ( UserEmailContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) < nl > - val plain = < nl > - if ( phone . isDefined | | email . isDefined ) < nl > - None < nl > - else Some ( UserContact ( user . id , contactUserId , localNameOpt , isDeleted = false ) ) < nl > - < nl > - ( ( contactUserId , localNameOpt ) , plain , phone , email ) < nl > - } . foldLeft ( Map . empty [ Int , Option [ String ] ] , Seq . empty [ UserContact ] , Seq . empty [ UserPhoneContact ] , Seq . empty [ UserEmailContact ] ) { < nl > - case ( ( idsLocalNames , plains , phones , emails ) , ( idLocalName , plain , phone , email ) ) ⇒ < nl > - ( < nl > - idsLocalNames + idLocalName , < nl > - plain . map ( plains : + _ ) . getOrElse ( plains ) , < nl > - phone . map ( phones : + _ ) . getOrElse ( phones ) , < nl > - email . map ( emails : + _ ) . getOrElse ( emails ) < nl > - ) < nl > - } < nl > + val ( idsLocalNames , plains , phones , emails ) = < nl > + contactsToAdd . view < nl > + . filterNot ( _ . contactUserId = = user . id ) < nl > + . map { < nl > + case UserCommands . ContactToAdd ( contactUserId , localNameOpt , phoneOpt , emailOpt ) ⇒ < nl > + val phone = phoneOpt map ( UserPhoneContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) < nl > + val email = emailOpt map ( UserEmailContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) < nl > + val plain = < nl > + if ( phone . isDefined | | email . isDefined ) < nl > + None < nl > + else Some ( UserContact ( user . id , contactUserId , localNameOpt , isDeleted = false ) ) < nl > + < nl > + ( ( contactUserId , localNameOpt ) , plain , phone , email ) < nl > + } < nl > + . foldLeft ( Map . empty [ Int , Option [ String ] ] , Seq . empty [ UserContact ] , Seq . empty [ UserPhoneContact ] , Seq . empty [ UserEmailContact ] ) { < nl > + case ( ( idsLocalNames , plains , phones , emails ) , ( idLocalName , plain , phone , email ) ) ⇒ < nl > + ( < nl > + idsLocalNames + idLocalName , < nl > + plain . map ( plains : + _ ) . getOrElse ( plains ) , < nl > + phone . map ( phones : + _ ) . getOrElse ( phones ) , < nl > + email . map ( emails : + _ ) . getOrElse ( emails ) < nl > + ) < nl > + } < nl > < nl > ( for { < nl > _ ← FutureExt . ftraverse ( plains ) ( c ⇒ db . run ( UserContactRepo . insertOrUpdate ( c ) ) ) < nl > diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20160524140118 _ _ RemoveSelvesFromContacts . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20160524140118 _ _ RemoveSelvesFromContacts . sql < nl > new file mode 100644 < nl > index 0000000 . . 7dee88e < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20160524140118 _ _ RemoveSelvesFromContacts . sql < nl > @ @ - 0 , 0 + 1 , 2 @ @ < nl > + delete from user _ contacts where contact _ user _ id = owner _ user _ id ; < nl > + delete from social _ relations where user _ id = related _ to ; < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala < nl > index 9711f1b . . f9bfb68 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala < nl > @ @ - 45 , 7 + 45 , 7 @ @ object UserContactRepo { < nl > def byPKDeleted ( ownerUserId : Int , contactUserId : Int ) = < nl > contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId & & c . isDeleted = = = true ) < nl > < nl > - def existsC = Compiled { ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) ⇒ < nl > + private def existsC = Compiled { ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) ⇒ < nl > byPKNotDeleted ( ownerUserId , contactUserId ) . exists < nl > } < nl > < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala < nl > index 4a77936 . . 0fb7f53 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala < nl > @ @ - 29 , 6 + 29 , 12 @ @ import im . actor . server . social . { SocialExtension , SocialManager , SocialManagerReg < nl > import im . actor . server . user . _ < nl > import im . actor . util . misc . PhoneNumberUtils < nl > < nl > + object ContactsRpcErrors { < nl > + val CantAddSelf = RpcError ( 401 , " OWN _ USER _ ID " , " User id cannot be equal to self . " , false , None ) < nl > + val ContactAlreadyExists = RpcError ( 400 , " CONTACT _ ALREADY _ EXISTS " , " Contact already exists . " , false , None ) < nl > + val ContactNotFound = RpcError ( 404 , " CONTACT _ NOT _ FOUND " , " Contact not found . " , false , None ) < nl > + } < nl > + < nl > class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) < nl > extends ContactsService { < nl > < nl > @ @ - 44 , 12 + 50 , 6 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) < nl > private implicit val seqUpdExt : SeqUpdatesExtension = SeqUpdatesExtension ( actorSystem ) < nl > private implicit val socialRegion : SocialManagerRegion = SocialExtension ( actorSystem ) . region < nl > < nl > - object ContactsRpcErrors { < nl > - val CantAddSelf = RpcError ( 401 , " OWN _ USER _ ID " , " User id cannot be equal to self . " , false , None ) < nl > - val ContactAlreadyExists = RpcError ( 400 , " CONTACT _ ALREADY _ EXISTS " , " Contact already exists . " , false , None ) < nl > - val ContactNotFound = RpcError ( 404 , " CONTACT _ NOT _ FOUND " , " Contact not found . " , false , None ) < nl > - } < nl > - < nl > case class EmailNameUser ( email : String , name : Option [ String ] , userId : Int ) < nl > < nl > private [ service ] def hashIds ( ids : Seq [ Int ] ) : String = { < nl > @ @ - 127 , 27 + 127 , 23 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) < nl > < nl > override def doHandleAddContact ( userId : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > - val action = ( for { < nl > - optUser ← UserRepo . find ( userId ) < nl > - optNumber ← optUser . map ( user ⇒ UserPhoneRepo . findByUserId ( user . id ) . headOption ) . getOrElse ( DBIO . successful ( None ) ) < nl > - } yield { < nl > - ( optUser , optNumber map ( _ . number ) ) < nl > - } ) flatMap { < nl > - case ( Some ( user ) , optPhoneNumber ) ⇒ < nl > - if ( accessHash = = ACLUtils . userAccessHash ( clientData . authId , user . id , user . accessSalt ) ) { < nl > - UserContactRepo . find ( ownerUserId = client . userId , contactUserId = userId ) . flatMap { < nl > - case None ⇒ < nl > - for { < nl > - seqstate ← DBIO . from ( userExt . addContact ( client . userId , user . id , None , optPhoneNumber , None ) ) < nl > - } yield Ok ( ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) ) < nl > - case Some ( contact ) ⇒ < nl > - DBIO . successful ( Error ( ContactsRpcErrors . ContactAlreadyExists ) ) < nl > - } < nl > - } else DBIO . successful ( Error ( CommonRpcErrors . InvalidAccessHash ) ) < nl > - case ( None , _ ) ⇒ DBIO . successful ( Error ( CommonRpcErrors . UserNotFound ) ) < nl > - case ( _ , None ) ⇒ DBIO . successful ( Error ( CommonRpcErrors . UserPhoneNotFound ) ) < nl > - } < nl > - db . run ( action ) < nl > + val action = for { < nl > + user ← fromDBIOOption ( CommonRpcErrors . UserNotFound ) ( UserRepo . find ( userId ) ) < nl > + _ ← fromBoolean ( ContactsRpcErrors . CantAddSelf ) ( userId ! = client . userId ) < nl > + _ ← fromBoolean ( CommonRpcErrors . InvalidAccessHash ) ( accessHash = = ACLUtils . userAccessHash ( clientData . authId , user . id , user . accessSalt ) ) < nl > + exists ← fromDBIO ( UserContactRepo . exists ( ownerUserId = client . userId , contactUserId = userId ) ) < nl > + _ ← fromBoolean ( ContactsRpcErrors . ContactAlreadyExists ) ( ! exists ) < nl > + optPhone ← fromDBIO ( UserPhoneRepo . findByUserId ( user . id ) . headOption ) < nl > + optEmail ← fromDBIO ( UserEmailRepo . findByUserId ( user . id ) . headOption ) < nl > + seqstate ← fromFuture ( userExt . addContact ( < nl > + userId = client . userId , < nl > + contactUserId = user . id , < nl > + localName = None , < nl > + phone = optPhone map ( _ . number ) , < nl > + email = optEmail map ( _ . email ) < nl > + ) ) < nl > + } yield ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) < nl > + db . run ( action . value ) < nl > } < nl > < nl > override def doHandleSearchContacts ( query : String , optimizations : IndexedSeq [ ApiUpdateOptimization . Value ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseSearchContacts ] ] = < nl > @ @ - 157 , 7 + 153 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) < nl > emailUsers ← findByEmail ( query , client ) < nl > phoneUsers ← findByNumber ( query , client ) < nl > } yield { < nl > - val users = nicknameUsers + + phoneUsers + + emailUsers < nl > + val users = ( nicknameUsers + + phoneUsers + + emailUsers ) filterNot ( _ . id = = client . userId ) < nl > users foreach ( u ⇒ recordRelation ( u . id , client . userId ) ) < nl > ResponseSearchContacts ( < nl > users = if ( optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) ) Vector . empty else users , < nl > @ @ - 264 , 7 + 260 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) < nl > actorSystem . log . debug ( " Phone numbers : { } , registered : { } " , phoneNumbers , registeredPhoneNumbers ) < nl > < nl > / / TODO : # perf do less queries < nl > - val unregInsertActions = ( phoneNumbers & ~ registeredPhoneNumbers ) . toSeq map { phoneNumber ⇒ < nl > + val unregInsertActions = ( phoneNumbers diff registeredPhoneNumbers ) . toSeq map { phoneNumber ⇒ < nl > UnregisteredPhoneContactRepo . createIfNotExists ( phoneNumber , user . id , phonesMap . getOrElse ( phoneNumber , None ) ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala < nl > index 706adc4 . . e5b9e6e 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala < nl > @ @ - 10 , 7 + 10 , 7 @ @ import im . actor . api . rpc . peers . ApiUserOutPeer < nl > import im . actor . api . rpc . users . { ResponseLoadFullUsers , UsersService } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . persist . UserRepo < nl > + import im . actor . server . persist . { UserEmailRepo , UserPhoneRepo , UserRepo } < nl > import im . actor . server . persist . contact . UserContactRepo < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . misc . StringUtils < nl > @ @ - 42 , 9 + 42 , 18 @ @ final class UsersServiceImpl ( implicit actorSystem : ActorSystem ) extends UsersSer < nl > case Some ( contact ) ⇒ < nl > userExt . editLocalName ( client . userId , userId , Some ( validName ) ) < nl > case None ⇒ < nl > - userExt . addContact ( client . userId , userId , Some ( validName ) , None , None ) < nl > + for { < nl > + optPhone ← db . run ( UserPhoneRepo . findByUserId ( userId ) . headOption ) < nl > + optEmail ← db . run ( UserEmailRepo . findByUserId ( userId ) . headOption ) < nl > + seqstate ← userExt . addContact ( < nl > + userId = client . userId , < nl > + contactUserId = userId , < nl > + localName = Some ( validName ) , < nl > + phone = optPhone map ( _ . number ) , < nl > + email = optEmail map ( _ . email ) < nl > + ) < nl > + } yield seqstate < nl > } < nl > - < nl > for { < nl > seqstate ← seqstateF < nl > } yield Ok ( ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala < nl > index 6629686 . . 2afeb65 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala < nl > @ @ - 2 , 10 + 2 , 12 @ @ package im . actor . server . api . rpc . service < nl > < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . contacts . ApiPhoneToImport < nl > + import im . actor . api . rpc . misc . ResponseSeq < nl > import im . actor . api . rpc . users . ApiSex < nl > import im . actor . api . { rpc ⇒ api } < nl > import im . actor . server . _ < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . api . rpc . service . contacts . ContactsRpcErrors < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . misc . IdUtils < nl > < nl > @ @ - 27 , 6 + 29 , 8 @ @ final class ContactsServiceSpec < nl > < nl > " AddContact handler " should " add contact " in s . addremove . add ( ) < nl > < nl > + it should " not add self to contacts " in s . addremove . cantAddSelf ( ) < nl > + < nl > " RemoveContact handler " should " remove contact " in s . addremove . remove < nl > < nl > " AddContact handler " should " add contact after remove " in s . addremove . addAfterRemove < nl > @ @ - 102 , 26 + 106 , 39 @ @ final class ContactsServiceSpec < nl > val ( user , authSid ) = createUser ( authId , phoneNumber ) < nl > < nl > val ( user2 , _ , _ , _ ) = createUser ( ) < nl > - val user2Model = getUserModel ( user2 . id ) < nl > - val user2AccessHash = ACLUtils . userAccessHash ( authId , user2 . id , user2Model . accessSalt ) < nl > + val user2AccessHash = ACLUtils . userAccessHash ( authId , user2 . id , getUserModel ( user2 . id ) . accessSalt ) < nl > < nl > implicit val clientData = api . ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid , 42 ) ) ) < nl > < nl > def add ( firstRun : Boolean = true , expectedUpdSeq : Int = 1 ) = { < nl > whenReady ( service . handleAddContact ( user2 . id , user2AccessHash ) ) { resp ⇒ < nl > resp should matchPattern { < nl > - case Ok ( api . misc . ResponseSeq ( seq , state ) ) if seq = = expectedUpdSeq ⇒ < nl > + case Ok ( ResponseSeq ( seq , state ) ) if seq = = expectedUpdSeq ⇒ < nl > } < nl > } < nl > < nl > - val expectedUsers = Vector ( Await . result ( < nl > + val ExpectedUsers = Vector ( Await . result ( < nl > UserExtension ( system ) . getApiStruct ( user2 . id , user . id , authId ) , < nl > 3 . seconds < nl > ) ) < nl > < nl > whenReady ( service . handleGetContacts ( service . hashIds ( Seq . empty ) , Vector . empty ) ) { resp ⇒ < nl > resp should matchPattern { < nl > - case Ok ( api . contacts . ResponseGetContacts ( expectedUsers , false , _ ) ) ⇒ < nl > + case Ok ( api . contacts . ResponseGetContacts ( ExpectedUsers , false , _ ) ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + def cantAddSelf ( ) = { < nl > + val userAccessHash = ACLUtils . userAccessHash ( authId , user . id , getUserModel ( user . id ) . accessSalt ) < nl > + whenReady ( service . handleAddContact ( user . id , userAccessHash ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( ContactsRpcErrors . CantAddSelf ) ⇒ < nl > + } < nl > + } < nl > + whenReady ( service . handleGetContacts ( service . hashIds ( Seq . empty ) , Vector . empty ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( api . contacts . ResponseGetContacts ( users , false , _ ) ) ⇒ users should not contain user < nl > } < nl > } < nl > } < nl > @ @ - 132 , 7 + 149 , 7 @ @ final class ContactsServiceSpec < nl > whenReady ( userExt . getAccessHash ( userId , clientData . authId ) ) { accessSalt ⇒ < nl > whenReady ( service . handleAddContact ( userId , accessSalt ) ) { rsp ⇒ < nl > inside ( rsp ) { < nl > - case Ok ( api . misc . ResponseSeq ( _ , _ ) ) ⇒ < nl > + case Ok ( ResponseSeq ( _ , _ ) ) ⇒ < nl > } < nl > } < nl > } < nl > @ @ - 141 , 7 + 158 , 7 @ @ final class ContactsServiceSpec < nl > def remove ( ) = { < nl > whenReady ( service . handleRemoveContact ( user2 . id , user2AccessHash ) ) { resp ⇒ < nl > resp should matchPattern { < nl > - case Ok ( api . misc . ResponseSeq ( 3 , state ) ) ⇒ < nl > + case Ok ( ResponseSeq ( 3 , state ) ) ⇒ < nl > } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala < nl > index 995274d . . 803f78e 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala < nl > @ @ - 144 , 4 + 144 , 7 @ @ object UserRepo { < nl > drop ( offset ) . < nl > take ( size ) < nl > } < nl > + < nl > + def isDeleted ( userId : Int ) : DBIO [ Boolean ] = < nl > + byIdC . applied ( userId ) . filter ( _ . deletedAt . nonEmpty ) . exists . result < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala < nl > index 4f49962 . . 87fff0b 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala < nl > @ @ - 1 , 6 + 1 , 6 @ @ < nl > package im . actor . server . api . rpc . service . auth < nl > < nl > - import im . actor . api . rpc . RpcError < nl > + import im . actor . api . rpc . { CommonErrors , RpcError } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . activation . { BadRequest , SendFailure , CodeFailure } < nl > < nl > @ @ - 26 , 6 + 26 , 7 @ @ object AuthErrors { < nl > val ActivationServiceError = RpcError ( 500 , " ACTIVATION _ SERVICE _ ERROR " , " Error occured in activation service . Try again later . " , true , None ) < nl > val InvalidAuthCodeHash = RpcError ( 400 , " CODE _ HASH _ INVALID " , " " , false , None ) < nl > val PasswordInvalid = RpcError ( 400 , " PASSWORD _ INVALID " , s " Password have to be more than $ { ACLUtils . PasswordMinLength } and less than $ { ACLUtils . PasswordMaxLength } " , false , None ) < nl > + val UserDeleted = CommonErrors . forbidden ( " Unable to log in , your account is deleted " ) < nl > < nl > def activationFailure ( failure : CodeFailure ) = failure match { < nl > case SendFailure ( message ) ⇒ RpcError ( 500 , " GATE _ ERROR " , message , true , None ) < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > index e38d226 . . 4f4549f 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > @ @ - 11 , 7 + 11 , 6 @ @ import im . actor . api . rpc . users . ApiUser < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . activation . Activation . { CallCode , EmailCode , SmsCode } < nl > import im . actor . server . activation . _ < nl > - import im . actor . server . api . rpc . service . profile . ProfileErrors < nl > import im . actor . server . auth . DeviceInfo < nl > import im . actor . server . model . _ < nl > import im . actor . server . persist . UserRepo < nl > @ @ - 292 , 6 + 291 , 9 @ @ trait AuthHelpers extends Helpers { < nl > point ( user ) < nl > } < nl > < nl > + protected def forbidDeletedUser ( userId : Int ) : Result [ Unit ] = < nl > + fromDBIOBoolean ( AuthErrors . UserDeleted ) ( UserRepo . isDeleted ( userId ) . map ( ! _ ) ) < nl > + < nl > private def cleanupAndError ( transactionHash : String , error : RpcError ) : Result [ Unit ] = { < nl > for { < nl > _ ← fromDBIO ( persist . auth . AuthTransactionRepo . delete ( transactionHash ) ) < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > index 1cce886 . . 975d3a0 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > @ @ - 22 , 7 + 22 , 7 @ @ import im . actor . server . db . DbExtension < nl > import im . actor . server . email . { EmailConfig , SmtpEmailSender } < nl > import im . actor . server . model . { AuthAnonymousTransaction , AuthUsernameTransaction } < nl > import im . actor . server . oauth . GoogleProvider < nl > - import im . actor . server . persist . { UserPasswordRepo , UserRepo } < nl > + import im . actor . server . persist . _ < nl > import im . actor . server . persist . auth . { AuthUsernameTransactionRepo , AuthTransactionRepo } < nl > import im . actor . server . session . _ < nl > import im . actor . server . social . { SocialExtension , SocialManagerRegion } < nl > @ @ - 84 , 7 + 84 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > override def jhandleGetAuthSessions ( clientData : ClientData ) : Future [ HandlerResult [ ResponseGetAuthSessions ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { client ⇒ < nl > for { < nl > - sessionModels ← persist . AuthSessionRepo . findByUserId ( client . userId ) < nl > + sessionModels ← AuthSessionRepo . findByUserId ( client . userId ) < nl > } yield { < nl > val sessionStructs = sessionModels map { sessionModel ⇒ < nl > val authHolder = < nl > @ @ - 174 , 6 + 174 , 8 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > ) : Future [ HandlerResult [ ResponseStartPhoneAuth ] ] = { < nl > val action = for { < nl > normalizedPhone ← fromOption ( AuthErrors . PhoneNumberInvalid ) ( normalizeLong ( phoneNumber ) . headOption ) < nl > + optPhone ← fromDBIO ( persist . UserPhoneRepo . findByPhoneNumber ( normalizedPhone ) . headOption ) < nl > + _ ← optPhone map ( p ⇒ forbidDeletedUser ( p . userId ) ) getOrElse point ( ( ) ) < nl > optAuthTransaction ← fromDBIO ( persist . auth . AuthPhoneTransactionRepo . findByPhoneAndDeviceHash ( normalizedPhone , deviceHash ) ) < nl > transactionHash ← optAuthTransaction match { < nl > case Some ( transaction ) ⇒ point ( transaction . transactionHash ) < nl > @ @ - 195 , 7 + 197 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > } yield transactionHash < nl > } < nl > _ ← fromDBIOEither [ Unit , CodeFailure ] ( AuthErrors . activationFailure ) ( sendSmsCode ( normalizedPhone , genSmsCode ( normalizedPhone ) , Some ( transactionHash ) ) ) < nl > - isRegistered ← fromDBIO ( persist . UserPhoneRepo . exists ( normalizedPhone ) ) < nl > + isRegistered = optPhone . isDefined < nl > } yield ResponseStartPhoneAuth ( transactionHash , isRegistered , Some ( ApiPhoneActivationType . CODE ) ) < nl > db . run ( action . run ) < nl > } < nl > @ @ - 214 , 6 + 216 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > for { < nl > normUsername ← fromOption ( ProfileErrors . NicknameInvalid ) ( StringUtils . normalizeUsername ( username ) ) < nl > optUser ← fromDBIO ( UserRepo . findByNickname ( username ) ) < nl > + _ ← optUser map ( u ⇒ forbidDeletedUser ( u . id ) ) getOrElse point ( ( ) ) < nl > optAuthTransaction ← fromDBIO ( AuthUsernameTransactionRepo . find ( username , deviceHash ) ) < nl > transactionHash ← optAuthTransaction match { < nl > case Some ( transaction ) ⇒ point ( transaction . transactionHash ) < nl > @ @ - 254 , 7 + 257 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > normUsername ← fromOption ( ProfileErrors . NicknameInvalid ) ( StringUtils . normalizeUsername ( username ) ) < nl > accessSalt = ACLUtils . nextAccessSalt ( ) < nl > nicknameExists ← fromDBIO ( UserRepo . nicknameExists ( normUsername ) ) < nl > - optUser ← fromBoolean ( ProfileErrors . NicknameBusy ) ( ! nicknameExists ) < nl > + _ ← fromBoolean ( ProfileErrors . NicknameBusy ) ( ! nicknameExists ) < nl > transactionHash = ACLUtils . authTransactionHash ( accessSalt ) < nl > transaction = AuthAnonymousTransaction ( < nl > normUsername , < nl > @ @ - 333 , 10 + 336 , 12 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > ) : Future [ HandlerResult [ ResponseStartEmailAuth ] ] = { < nl > val action = for { < nl > validEmail ← fromEither ( validEmail ( email ) . leftMap ( validationFailed ( " EMAIL _ INVALID " , _ ) ) ) < nl > + optEmail ← fromDBIO ( persist . UserEmailRepo . find ( validEmail ) ) < nl > + _ ← optEmail map ( e ⇒ forbidDeletedUser ( e . userId ) ) getOrElse point ( ( ) ) < nl > / / OAUTH activation is temporary disabled < nl > / / activationType = if ( OAuth2ProvidersDomains . supportsOAuth2 ( validEmail ) ) OAUTH2 else CODE < nl > activationType = CODE < nl > - isRegistered ← fromDBIO ( persist . UserEmailRepo . exists ( validEmail ) ) < nl > + isRegistered = optEmail . isDefined < nl > optTransaction ← fromDBIO ( persist . auth . AuthEmailTransactionRepo . findByEmailAndDeviceHash ( validEmail , deviceHash ) ) < nl > transactionHash ← optTransaction match { < nl > case Some ( trans ) ⇒ < nl > @ @ - 412 , 7 + 417 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > < nl > override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > val action = requireAuth ( clientData ) map { implicit client ⇒ < nl > - persist . AuthSessionRepo . findByAuthId ( client . authId ) flatMap { < nl > + AuthSessionRepo . findByAuthId ( client . authId ) flatMap { < nl > case Some ( session ) ⇒ < nl > for ( _ ← DBIO . from ( userExt . logout ( session ) ) ) yield Ok ( misc . ResponseVoid ) < nl > case None ⇒ throw new Exception ( s " Cannot find AuthSession for authId : $ { client . authId } " ) < nl > @ @ - 425 , 7 + 430 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > override def jhandleTerminateAllSessions ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { client ⇒ < nl > for { < nl > - sessions ← persist . AuthSessionRepo . findByUserId ( client . userId ) map ( _ . filterNot ( _ . authId = = client . authId ) ) < nl > + sessions ← AuthSessionRepo . findByUserId ( client . userId ) map ( _ . filterNot ( _ . authId = = client . authId ) ) < nl > _ ← DBIO . from ( Future . sequence ( sessions map userExt . logout ) ) < nl > } yield { < nl > Ok ( ResponseVoid ) < nl > @ @ - 437 , 7 + 442 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > < nl > override def jhandleTerminateSession ( id : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { client ⇒ < nl > - persist . AuthSessionRepo . find ( client . userId , id ) . headOption flatMap { < nl > + AuthSessionRepo . find ( client . userId , id ) . headOption flatMap { < nl > case Some ( session ) ⇒ < nl > if ( session . authId ! = clientData . authId ) { < nl > for ( _ ← DBIO . from ( userExt . logout ( session ) ) ) yield Ok ( ResponseVoid ) < nl > @ @ - 480 , 14 + 485 , 22 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > case None ⇒ < nl > Future . successful ( Error ( AuthErrors . PhoneNumberInvalid ) ) < nl > case Some ( normPhoneNumber ) ⇒ < nl > - val action = persist . AuthSmsCodeObsoleteRepo . findByPhoneNumber ( normPhoneNumber ) . headOption . flatMap { < nl > + val isDeletedAction = for { < nl > + optPhone ← UserPhoneRepo . findByPhoneNumber ( normPhoneNumber ) . headOption < nl > + isDeleted ← optPhone match { < nl > + case Some ( phone ) ⇒ UserRepo . isDeleted ( phone . userId ) < nl > + case None ⇒ DBIO . successful ( false ) < nl > + } < nl > + } yield isDeleted < nl > + < nl > + val sendCodeAction = AuthSmsCodeObsoleteRepo . findByPhoneNumber ( normPhoneNumber ) . headOption . flatMap { < nl > case Some ( model . AuthSmsCodeObsolete ( _ , _ , smsHash , smsCode , _ ) ) ⇒ < nl > DBIO . successful ( normPhoneNumber : : smsHash : : smsCode : : HNil ) < nl > case None ⇒ < nl > val smsHash = genSmsHash ( ) < nl > val smsCode = genSmsCode ( normPhoneNumber ) < nl > for ( < nl > - _ ← persist . AuthSmsCodeObsoleteRepo . create ( < nl > + _ ← AuthSmsCodeObsoleteRepo . create ( < nl > id = ThreadLocalSecureRandom . current ( ) . nextLong ( ) , < nl > phoneNumber = normPhoneNumber , < nl > smsHash = smsHash , < nl > @ @ - 495 , 13 + 508 , 16 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > ) < nl > ) yield normPhoneNumber : : smsHash : : smsCode : : HNil < nl > } . flatMap { res ⇒ < nl > - persist . UserPhoneRepo . exists ( normPhoneNumber ) map ( res : + _ ) < nl > + UserPhoneRepo . exists ( normPhoneNumber ) map ( res : + _ ) < nl > } . map { < nl > case number : : smsHash : : smsCode : : isRegistered : : HNil ⇒ < nl > sendSmsCode ( number , smsCode , None ) < nl > Ok ( ResponseSendAuthCodeObsolete ( smsHash , isRegistered ) ) < nl > } < nl > - db . run ( action ) < nl > + db . run ( for { < nl > + isDeleted ← isDeletedAction < nl > + result ← if ( isDeleted ) DBIO . successful ( Error ( AuthErrors . UserDeleted ) ) else sendCodeAction < nl > + } yield result ) < nl > } < nl > } < nl > < nl > @ @ - 561 , 8 + 577 , 8 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > else { < nl > val action = < nl > ( for { < nl > - optCode ← persist . AuthSmsCodeObsoleteRepo . findByPhoneNumber ( normPhoneNumber ) . headOption < nl > - optPhone ← persist . UserPhoneRepo . findByPhoneNumber ( normPhoneNumber ) . headOption < nl > + optCode ← AuthSmsCodeObsoleteRepo . findByPhoneNumber ( normPhoneNumber ) . headOption < nl > + optPhone ← UserPhoneRepo . findByPhoneNumber ( normPhoneNumber ) . headOption < nl > } yield optCode : : optPhone : : HNil ) . flatMap { < nl > case None : : _ : : HNil ⇒ DBIO . successful ( Error ( AuthErrors . PhoneCodeExpired ) ) < nl > case Some ( smsCodeModel ) : : _ : : HNil if smsCodeModel . smsHash ! = smsHash ⇒ < nl > @ @ - 572 , 7 + 588 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > case Some ( _ ) : : optPhone : : HNil ⇒ < nl > signType match { < nl > case Up ( rawName , isSilent ) ⇒ < nl > - persist . AuthSmsCodeObsoleteRepo . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( < nl > + AuthSmsCodeObsoleteRepo . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( < nl > optPhone match { < nl > / / Phone does not exist , register the user < nl > case None ⇒ withValidName ( rawName ) { name ⇒ < nl > @ @ - 593 , 7 + 609 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > _ ← DBIO . from ( userExt . create ( user . id , user . accessSalt , None , user . name , user . countryCode , im . actor . api . rpc . users . ApiSex ( user . sex . toInt ) , isBot = false ) ) < nl > _ ← DBIO . from ( userExt . auth ( userId , clientData . authId ) ) < nl > _ ← DBIO . from ( userExt . addPhone ( user . id , normPhoneNumber ) ) < nl > - _ ← persist . AvatarDataRepo . create ( model . AvatarData . empty ( model . AvatarData . OfUser , user . id . toLong ) ) < nl > + _ ← AvatarDataRepo . create ( model . AvatarData . empty ( model . AvatarData . OfUser , user . id . toLong ) ) < nl > } yield { < nl > \ / - ( user : : HNil ) < nl > } < nl > @ @ - 607 , 7 + 623 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > optPhone match { < nl > case None ⇒ DBIO . successful ( Error ( AuthErrors . PhoneNumberUnoccupied ) ) < nl > case Some ( phone ) ⇒ < nl > - persist . AuthSmsCodeObsoleteRepo . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( < nl > + AuthSmsCodeObsoleteRepo . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( < nl > signIn ( clientData . authId , phone . userId , countryCode , clientData ) < nl > ) < nl > } < nl > @ @ - 629 , 9 + 645 , 9 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > ) < nl > < nl > for { < nl > - prevSessions ← persist . AuthSessionRepo . findByDeviceHash ( deviceHash ) < nl > + prevSessions ← AuthSessionRepo . findByDeviceHash ( deviceHash ) < nl > _ ← DBIO . from ( Future . sequence ( prevSessions map userExt . logout ) ) < nl > - _ ← persist . AuthSessionRepo . create ( authSession ) < nl > + _ ← AuthSessionRepo . create ( authSession ) < nl > userStruct ← DBIO . from ( userExt . getApiStruct ( user . id , user . id , clientData . authId ) ) < nl > } yield { < nl > sessionRegion . ref ! SessionEnvelope ( clientData . authId , clientData . sessionId ) . withAuthorizeUser ( AuthorizeUser ( userStruct . id , authSession . id ) ) < nl > @ @ - 652 , 7 + 668 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > } < nl > < nl > private def signIn ( authId : Long , userId : Int , countryCode : String , clientData : ClientData ) = { < nl > - persist . UserRepo . find ( userId ) . flatMap { < nl > + UserRepo . find ( userId ) . flatMap { < nl > case None ⇒ throw new Exception ( " Failed to retrieve user " ) < nl > case Some ( user ) ⇒ < nl > for { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceObsoleteSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceObsoleteSpec . scala < nl > index c3259f7 . . 6598d19 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceObsoleteSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceObsoleteSpec . scala < nl > @ @ - 7 , 6 + 7 , 7 @ @ import im . actor . server . _ < nl > import im . actor . server . api . rpc . RpcApiService < nl > import im . actor . server . api . rpc . service . auth < nl > import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } < nl > + import im . actor . server . user . UserExtension < nl > < nl > import scala . concurrent . Await < nl > import scala . concurrent . duration . _ < nl > @ @ - 19 , 6 + 20 , 8 @ @ final class AuthServiceObsoleteSpec extends BaseAppSuite with SeqUpdateMatchers < nl > < nl > it should " not fail if number already exists " in ( s . sendAuthCode . e1 ) < nl > < nl > + it should " not allow deleted user to log in " in s . sendAuthCode . phoneDeletedUser < nl > + < nl > " SignUp handler " should " respond ok to a valid request " in ( s . signUp ( ) . e1 ) < nl > < nl > it should " send ContactRegistered updates " in ( s . signUp ( ) . e2 ) < nl > @ @ - 51 , 6 + 54 , 21 @ @ final class AuthServiceObsoleteSpec extends BaseAppSuite with SeqUpdateMatchers < nl > } < nl > } < nl > } < nl > + < nl > + def phoneDeletedUser ( ) = { < nl > + val ( user , authId , authSid , phoneNumber ) = createUser ( ) < nl > + < nl > + val sessionId = createSessionId ( ) < nl > + implicit val clientData = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid ) ) ) < nl > + < nl > + whenReady ( UserExtension ( system ) . delete ( user . id ) ) ( identity ) < nl > + < nl > + whenReady ( service . handleSendAuthCodeObsolete ( phoneNumber , 1 , " apiKey " ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( AuthErrors . UserDeleted ) ⇒ < nl > + } < nl > + } < nl > + } < nl > } < nl > < nl > case class signUp ( ) { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceSpec . scala < nl > index d2af3f4 . . b1c4765 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceSpec . scala < nl > @ @ - 21 , 6 + 21 , 7 @ @ import im . actor . server . mtproto . protocol . { MessageBox , SessionHello } < nl > import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } < nl > import im . actor . server . persist . auth . AuthTransactionRepo < nl > import im . actor . server . session . { HandleMessageBox , Session , SessionConfig , SessionEnvelope } < nl > + import im . actor . server . user . UserExtension < nl > < nl > import scala . concurrent . { ExecutionContext , Future } < nl > import scala . util . Random < nl > @ @ - 44 , 6 + 45 , 8 @ @ final class AuthServiceSpec < nl > < nl > it should " associate authorizations from two different devices with different auth transactions " in s . e34 < nl > < nl > + it should " not allow deleted user to log in " in s . phoneDeletedUser < nl > + < nl > " ValidateCode handler " should " respond with error to invalid transactionHash " in s . e4 < nl > < nl > it should " respond with error to wrong sms auth code " in s . e5 < nl > @ @ - 79 , 6 + 82 , 8 @ @ final class AuthServiceSpec < nl > < nl > it should " associate authorizations from two different devices with different auth transactions " in s . e155 < nl > < nl > + it should " not allow deleted user to log in " in s . emailDeletedUser < nl > + < nl > " GetOAuth2Params handler " should " respond with error when malformed url is passed " in pendingUntilFixed ( s . e16 ) < nl > < nl > it should " respond with error when wrong transactionHash is passed " in pendingUntilFixed ( s . e17 ) < nl > @ @ - 220 , 6 + 225 , 21 @ @ final class AuthServiceSpec < nl > transactionHash1 should not equal transactionHash2 < nl > } < nl > < nl > + def phoneDeletedUser ( ) = { < nl > + val ( user , authId , authSid , phoneNumber ) = createUser ( ) < nl > + < nl > + val sessionId = createSessionId ( ) < nl > + implicit val clientData = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid ) ) ) < nl > + < nl > + whenReady ( UserExtension ( system ) . delete ( user . id ) ) ( identity ) < nl > + < nl > + whenReady ( startPhoneAuth ( phoneNumber ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( AuthErrors . UserDeleted ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > def e4 ( ) = { < nl > val phoneNumber = buildPhone ( ) < nl > implicit val clientData = ClientData ( createAuthId ( ) , createSessionId ( ) , None ) < nl > @ @ - 676 , 6 + 696 , 23 @ @ final class AuthServiceSpec < nl > transactionHash1 should not equal transactionHash2 < nl > } < nl > < nl > + def emailDeletedUser ( ) = { < nl > + val ( user , authId , authSid , _ ) = createUser ( ) < nl > + val email = buildEmail ( gmail ) < nl > + < nl > + val sessionId = createSessionId ( ) < nl > + implicit val clientData = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid ) ) ) < nl > + < nl > + whenReady ( UserExtension ( system ) . addEmail ( user . id , email ) ) ( identity ) < nl > + whenReady ( UserExtension ( system ) . delete ( user . id ) ) ( identity ) < nl > + < nl > + whenReady ( startEmailAuth ( email ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( AuthErrors . UserDeleted ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > def e16 ( ) = { < nl > val email = buildEmail ( gmail ) < nl > implicit val clientData = ClientData ( createAuthId ( ) , createSessionId ( ) , None ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceSpec . scala < nl > index e8ed483 . . 54b3452 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceSpec . scala < nl > @ @ - 98 , 7 + 98 , 7 @ @ final class EncryptionServiceSpec extends BaseAppSuite with ImplicitAuthService < nl > signatures = signatures < nl > ) ) ( _ . toOption . get . keyGroupId ) < nl > < nl > - whenReady ( service . handleUploadEphermalKey ( < nl > + whenReady ( service . handleUploadPreKey ( < nl > keyGroupId , < nl > ephKeys , < nl > ephSignatures < nl > @ @ - 110 , 7 + 110 , 7 @ @ final class EncryptionServiceSpec extends BaseAppSuite with ImplicitAuthService < nl > { < nl > implicit val clientData = bobClientData < nl > < nl > - whenReady ( service . handleLoadEphermalPublicKeys ( < nl > + whenReady ( service . handleLoadPrePublicKeys ( < nl > getUserOutPeer ( alice . id , bobAuthId ) , < nl > keyGroupId < nl > ) ) { resp ⇒

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 773c0f3 . . e1c0af4 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 370 , 25 + 370 , 29 @ @ private [ user ] trait UserCommandHandlers { 
 user : UserState , 
 contactsToAdd : Seq [ UserCommands . ContactToAdd ] 
 ) : Unit = { 
 - val ( idsLocalNames , plains , phones , emails ) = contactsToAdd . view . map { 
 - case UserCommands . ContactToAdd ( contactUserId , localNameOpt , phoneOpt , emailOpt ) ⇒ 
 - val phone = phoneOpt map ( UserPhoneContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) 
 - val email = emailOpt map ( UserEmailContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) 
 - val plain = 
 - if ( phone . isDefined | | email . isDefined ) 
 - None 
 - else Some ( UserContact ( user . id , contactUserId , localNameOpt , isDeleted = false ) ) 
 - 
 - ( ( contactUserId , localNameOpt ) , plain , phone , email ) 
 - } . foldLeft ( Map . empty [ Int , Option [ String ] ] , Seq . empty [ UserContact ] , Seq . empty [ UserPhoneContact ] , Seq . empty [ UserEmailContact ] ) { 
 - case ( ( idsLocalNames , plains , phones , emails ) , ( idLocalName , plain , phone , email ) ) ⇒ 
 - ( 
 - idsLocalNames + idLocalName , 
 - plain . map ( plains : + _ ) . getOrElse ( plains ) , 
 - phone . map ( phones : + _ ) . getOrElse ( phones ) , 
 - email . map ( emails : + _ ) . getOrElse ( emails ) 
 - ) 
 - } 
 + val ( idsLocalNames , plains , phones , emails ) = 
 + contactsToAdd . view 
 + . filterNot ( _ . contactUserId = = user . id ) 
 + . map { 
 + case UserCommands . ContactToAdd ( contactUserId , localNameOpt , phoneOpt , emailOpt ) ⇒ 
 + val phone = phoneOpt map ( UserPhoneContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) 
 + val email = emailOpt map ( UserEmailContact ( _ , user . id , contactUserId , localNameOpt , isDeleted = false ) ) 
 + val plain = 
 + if ( phone . isDefined | | email . isDefined ) 
 + None 
 + else Some ( UserContact ( user . id , contactUserId , localNameOpt , isDeleted = false ) ) 
 + 
 + ( ( contactUserId , localNameOpt ) , plain , phone , email ) 
 + } 
 + . foldLeft ( Map . empty [ Int , Option [ String ] ] , Seq . empty [ UserContact ] , Seq . empty [ UserPhoneContact ] , Seq . empty [ UserEmailContact ] ) { 
 + case ( ( idsLocalNames , plains , phones , emails ) , ( idLocalName , plain , phone , email ) ) ⇒ 
 + ( 
 + idsLocalNames + idLocalName , 
 + plain . map ( plains : + _ ) . getOrElse ( plains ) , 
 + phone . map ( phones : + _ ) . getOrElse ( phones ) , 
 + email . map ( emails : + _ ) . getOrElse ( emails ) 
 + ) 
 + } 
 
 ( for { 
 _ ← FutureExt . ftraverse ( plains ) ( c ⇒ db . run ( UserContactRepo . insertOrUpdate ( c ) ) ) 
 diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20160524140118 _ _ RemoveSelvesFromContacts . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20160524140118 _ _ RemoveSelvesFromContacts . sql 
 new file mode 100644 
 index 0000000 . . 7dee88e 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20160524140118 _ _ RemoveSelvesFromContacts . sql 
 @ @ - 0 , 0 + 1 , 2 @ @ 
 + delete from user _ contacts where contact _ user _ id = owner _ user _ id ; 
 + delete from social _ relations where user _ id = related _ to ; 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala 
 index 9711f1b . . f9bfb68 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala 
 @ @ - 45 , 7 + 45 , 7 @ @ object UserContactRepo { 
 def byPKDeleted ( ownerUserId : Int , contactUserId : Int ) = 
 contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId & & c . isDeleted = = = true ) 
 
 - def existsC = Compiled { ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) ⇒ 
 + private def existsC = Compiled { ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) ⇒ 
 byPKNotDeleted ( ownerUserId , contactUserId ) . exists 
 } 
 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala 
 index 4a77936 . . 0fb7f53 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala 
 @ @ - 29 , 6 + 29 , 12 @ @ import im . actor . server . social . { SocialExtension , SocialManager , SocialManagerReg 
 import im . actor . server . user . _ 
 import im . actor . util . misc . PhoneNumberUtils 
 
 + object ContactsRpcErrors { 
 + val CantAddSelf = RpcError ( 401 , " OWN _ USER _ ID " , " User id cannot be equal to self . " , false , None ) 
 + val ContactAlreadyExists = RpcError ( 400 , " CONTACT _ ALREADY _ EXISTS " , " Contact already exists . " , false , None ) 
 + val ContactNotFound = RpcError ( 404 , " CONTACT _ NOT _ FOUND " , " Contact not found . " , false , None ) 
 + } 
 + 
 class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) 
 extends ContactsService { 
 
 @ @ - 44 , 12 + 50 , 6 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) 
 private implicit val seqUpdExt : SeqUpdatesExtension = SeqUpdatesExtension ( actorSystem ) 
 private implicit val socialRegion : SocialManagerRegion = SocialExtension ( actorSystem ) . region 
 
 - object ContactsRpcErrors { 
 - val CantAddSelf = RpcError ( 401 , " OWN _ USER _ ID " , " User id cannot be equal to self . " , false , None ) 
 - val ContactAlreadyExists = RpcError ( 400 , " CONTACT _ ALREADY _ EXISTS " , " Contact already exists . " , false , None ) 
 - val ContactNotFound = RpcError ( 404 , " CONTACT _ NOT _ FOUND " , " Contact not found . " , false , None ) 
 - } 
 - 
 case class EmailNameUser ( email : String , name : Option [ String ] , userId : Int ) 
 
 private [ service ] def hashIds ( ids : Seq [ Int ] ) : String = { 
 @ @ - 127 , 27 + 127 , 23 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) 
 
 override def doHandleAddContact ( userId : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 - val action = ( for { 
 - optUser ← UserRepo . find ( userId ) 
 - optNumber ← optUser . map ( user ⇒ UserPhoneRepo . findByUserId ( user . id ) . headOption ) . getOrElse ( DBIO . successful ( None ) ) 
 - } yield { 
 - ( optUser , optNumber map ( _ . number ) ) 
 - } ) flatMap { 
 - case ( Some ( user ) , optPhoneNumber ) ⇒ 
 - if ( accessHash = = ACLUtils . userAccessHash ( clientData . authId , user . id , user . accessSalt ) ) { 
 - UserContactRepo . find ( ownerUserId = client . userId , contactUserId = userId ) . flatMap { 
 - case None ⇒ 
 - for { 
 - seqstate ← DBIO . from ( userExt . addContact ( client . userId , user . id , None , optPhoneNumber , None ) ) 
 - } yield Ok ( ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) ) 
 - case Some ( contact ) ⇒ 
 - DBIO . successful ( Error ( ContactsRpcErrors . ContactAlreadyExists ) ) 
 - } 
 - } else DBIO . successful ( Error ( CommonRpcErrors . InvalidAccessHash ) ) 
 - case ( None , _ ) ⇒ DBIO . successful ( Error ( CommonRpcErrors . UserNotFound ) ) 
 - case ( _ , None ) ⇒ DBIO . successful ( Error ( CommonRpcErrors . UserPhoneNotFound ) ) 
 - } 
 - db . run ( action ) 
 + val action = for { 
 + user ← fromDBIOOption ( CommonRpcErrors . UserNotFound ) ( UserRepo . find ( userId ) ) 
 + _ ← fromBoolean ( ContactsRpcErrors . CantAddSelf ) ( userId ! = client . userId ) 
 + _ ← fromBoolean ( CommonRpcErrors . InvalidAccessHash ) ( accessHash = = ACLUtils . userAccessHash ( clientData . authId , user . id , user . accessSalt ) ) 
 + exists ← fromDBIO ( UserContactRepo . exists ( ownerUserId = client . userId , contactUserId = userId ) ) 
 + _ ← fromBoolean ( ContactsRpcErrors . ContactAlreadyExists ) ( ! exists ) 
 + optPhone ← fromDBIO ( UserPhoneRepo . findByUserId ( user . id ) . headOption ) 
 + optEmail ← fromDBIO ( UserEmailRepo . findByUserId ( user . id ) . headOption ) 
 + seqstate ← fromFuture ( userExt . addContact ( 
 + userId = client . userId , 
 + contactUserId = user . id , 
 + localName = None , 
 + phone = optPhone map ( _ . number ) , 
 + email = optEmail map ( _ . email ) 
 + ) ) 
 + } yield ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) 
 + db . run ( action . value ) 
 } 
 
 override def doHandleSearchContacts ( query : String , optimizations : IndexedSeq [ ApiUpdateOptimization . Value ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseSearchContacts ] ] = 
 @ @ - 157 , 7 + 153 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) 
 emailUsers ← findByEmail ( query , client ) 
 phoneUsers ← findByNumber ( query , client ) 
 } yield { 
 - val users = nicknameUsers + + phoneUsers + + emailUsers 
 + val users = ( nicknameUsers + + phoneUsers + + emailUsers ) filterNot ( _ . id = = client . userId ) 
 users foreach ( u ⇒ recordRelation ( u . id , client . userId ) ) 
 ResponseSearchContacts ( 
 users = if ( optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) ) Vector . empty else users , 
 @ @ - 264 , 7 + 260 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) 
 actorSystem . log . debug ( " Phone numbers : { } , registered : { } " , phoneNumbers , registeredPhoneNumbers ) 
 
 / / TODO : # perf do less queries 
 - val unregInsertActions = ( phoneNumbers & ~ registeredPhoneNumbers ) . toSeq map { phoneNumber ⇒ 
 + val unregInsertActions = ( phoneNumbers diff registeredPhoneNumbers ) . toSeq map { phoneNumber ⇒ 
 UnregisteredPhoneContactRepo . createIfNotExists ( phoneNumber , user . id , phonesMap . getOrElse ( phoneNumber , None ) ) 
 } 
 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala 
 index 706adc4 . . e5b9e6e 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala 
 @ @ - 10 , 7 + 10 , 7 @ @ import im . actor . api . rpc . peers . ApiUserOutPeer 
 import im . actor . api . rpc . users . { ResponseLoadFullUsers , UsersService } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . persist . UserRepo 
 + import im . actor . server . persist . { UserEmailRepo , UserPhoneRepo , UserRepo } 
 import im . actor . server . persist . contact . UserContactRepo 
 import im . actor . server . user . UserExtension 
 import im . actor . util . misc . StringUtils 
 @ @ - 42 , 9 + 42 , 18 @ @ final class UsersServiceImpl ( implicit actorSystem : ActorSystem ) extends UsersSer 
 case Some ( contact ) ⇒ 
 userExt . editLocalName ( client . userId , userId , Some ( validName ) ) 
 case None ⇒ 
 - userExt . addContact ( client . userId , userId , Some ( validName ) , None , None ) 
 + for { 
 + optPhone ← db . run ( UserPhoneRepo . findByUserId ( userId ) . headOption ) 
 + optEmail ← db . run ( UserEmailRepo . findByUserId ( userId ) . headOption ) 
 + seqstate ← userExt . addContact ( 
 + userId = client . userId , 
 + contactUserId = userId , 
 + localName = Some ( validName ) , 
 + phone = optPhone map ( _ . number ) , 
 + email = optEmail map ( _ . email ) 
 + ) 
 + } yield seqstate 
 } 
 - 
 for { 
 seqstate ← seqstateF 
 } yield Ok ( ResponseSeq ( seqstate . seq , seqstate . state . toByteArray ) ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala 
 index 6629686 . . 2afeb65 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala 
 @ @ - 2 , 10 + 2 , 12 @ @ package im . actor . server . api . rpc . service 
 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . contacts . ApiPhoneToImport 
 + import im . actor . api . rpc . misc . ResponseSeq 
 import im . actor . api . rpc . users . ApiSex 
 import im . actor . api . { rpc ⇒ api } 
 import im . actor . server . _ 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . api . rpc . service . contacts . ContactsRpcErrors 
 import im . actor . server . user . UserExtension 
 import im . actor . util . misc . IdUtils 
 
 @ @ - 27 , 6 + 29 , 8 @ @ final class ContactsServiceSpec 
 
 " AddContact handler " should " add contact " in s . addremove . add ( ) 
 
 + it should " not add self to contacts " in s . addremove . cantAddSelf ( ) 
 + 
 " RemoveContact handler " should " remove contact " in s . addremove . remove 
 
 " AddContact handler " should " add contact after remove " in s . addremove . addAfterRemove 
 @ @ - 102 , 26 + 106 , 39 @ @ final class ContactsServiceSpec 
 val ( user , authSid ) = createUser ( authId , phoneNumber ) 
 
 val ( user2 , _ , _ , _ ) = createUser ( ) 
 - val user2Model = getUserModel ( user2 . id ) 
 - val user2AccessHash = ACLUtils . userAccessHash ( authId , user2 . id , user2Model . accessSalt ) 
 + val user2AccessHash = ACLUtils . userAccessHash ( authId , user2 . id , getUserModel ( user2 . id ) . accessSalt ) 
 
 implicit val clientData = api . ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid , 42 ) ) ) 
 
 def add ( firstRun : Boolean = true , expectedUpdSeq : Int = 1 ) = { 
 whenReady ( service . handleAddContact ( user2 . id , user2AccessHash ) ) { resp ⇒ 
 resp should matchPattern { 
 - case Ok ( api . misc . ResponseSeq ( seq , state ) ) if seq = = expectedUpdSeq ⇒ 
 + case Ok ( ResponseSeq ( seq , state ) ) if seq = = expectedUpdSeq ⇒ 
 } 
 } 
 
 - val expectedUsers = Vector ( Await . result ( 
 + val ExpectedUsers = Vector ( Await . result ( 
 UserExtension ( system ) . getApiStruct ( user2 . id , user . id , authId ) , 
 3 . seconds 
 ) ) 
 
 whenReady ( service . handleGetContacts ( service . hashIds ( Seq . empty ) , Vector . empty ) ) { resp ⇒ 
 resp should matchPattern { 
 - case Ok ( api . contacts . ResponseGetContacts ( expectedUsers , false , _ ) ) ⇒ 
 + case Ok ( api . contacts . ResponseGetContacts ( ExpectedUsers , false , _ ) ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + def cantAddSelf ( ) = { 
 + val userAccessHash = ACLUtils . userAccessHash ( authId , user . id , getUserModel ( user . id ) . accessSalt ) 
 + whenReady ( service . handleAddContact ( user . id , userAccessHash ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( ContactsRpcErrors . CantAddSelf ) ⇒ 
 + } 
 + } 
 + whenReady ( service . handleGetContacts ( service . hashIds ( Seq . empty ) , Vector . empty ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( api . contacts . ResponseGetContacts ( users , false , _ ) ) ⇒ users should not contain user 
 } 
 } 
 } 
 @ @ - 132 , 7 + 149 , 7 @ @ final class ContactsServiceSpec 
 whenReady ( userExt . getAccessHash ( userId , clientData . authId ) ) { accessSalt ⇒ 
 whenReady ( service . handleAddContact ( userId , accessSalt ) ) { rsp ⇒ 
 inside ( rsp ) { 
 - case Ok ( api . misc . ResponseSeq ( _ , _ ) ) ⇒ 
 + case Ok ( ResponseSeq ( _ , _ ) ) ⇒ 
 } 
 } 
 } 
 @ @ - 141 , 7 + 158 , 7 @ @ final class ContactsServiceSpec 
 def remove ( ) = { 
 whenReady ( service . handleRemoveContact ( user2 . id , user2AccessHash ) ) { resp ⇒ 
 resp should matchPattern { 
 - case Ok ( api . misc . ResponseSeq ( 3 , state ) ) ⇒ 
 + case Ok ( ResponseSeq ( 3 , state ) ) ⇒ 
 } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala 
 index 995274d . . 803f78e 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala 
 @ @ - 144 , 4 + 144 , 7 @ @ object UserRepo { 
 drop ( offset ) . 
 take ( size ) 
 } 
 + 
 + def isDeleted ( userId : Int ) : DBIO [ Boolean ] = 
 + byIdC . applied ( userId ) . filter ( _ . deletedAt . nonEmpty ) . exists . result 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala 
 index 4f49962 . . 87fff0b 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 package im . actor . server . api . rpc . service . auth 
 
 - import im . actor . api . rpc . RpcError 
 + import im . actor . api . rpc . { CommonErrors , RpcError } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . activation . { BadRequest , SendFailure , CodeFailure } 
 
 @ @ - 26 , 6 + 26 , 7 @ @ object AuthErrors { 
 val ActivationServiceError = RpcError ( 500 , " ACTIVATION _ SERVICE _ ERROR " , " Error occured in activation service . Try again later . " , true , None ) 
 val InvalidAuthCodeHash = RpcError ( 400 , " CODE _ HASH _ INVALID " , " " , false , None ) 
 val PasswordInvalid = RpcError ( 400 , " PASSWORD _ INVALID " , s " Password have to be more than $ { ACLUtils . PasswordMinLength } and less than $ { ACLUtils . PasswordMaxLength } " , false , None ) 
 + val UserDeleted = CommonErrors . forbidden ( " Unable to log in , your account is deleted " ) 
 
 def activationFailure ( failure : CodeFailure ) = failure match { 
 case SendFailure ( message ) ⇒ RpcError ( 500 , " GATE _ ERROR " , message , true , None ) 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 index e38d226 . . 4f4549f 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 @ @ - 11 , 7 + 11 , 6 @ @ import im . actor . api . rpc . users . ApiUser 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . activation . Activation . { CallCode , EmailCode , SmsCode } 
 import im . actor . server . activation . _ 
 - import im . actor . server . api . rpc . service . profile . ProfileErrors 
 import im . actor . server . auth . DeviceInfo 
 import im . actor . server . model . _ 
 import im . actor . server . persist . UserRepo 
 @ @ - 292 , 6 + 291 , 9 @ @ trait AuthHelpers extends Helpers { 
 point ( user ) 
 } 
 
 + protected def forbidDeletedUser ( userId : Int ) : Result [ Unit ] = 
 + fromDBIOBoolean ( AuthErrors . UserDeleted ) ( UserRepo . isDeleted ( userId ) . map ( ! _ ) ) 
 + 
 private def cleanupAndError ( transactionHash : String , error : RpcError ) : Result [ Unit ] = { 
 for { 
 _ ← fromDBIO ( persist . auth . AuthTransactionRepo . delete ( transactionHash ) ) 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 index 1cce886 . . 975d3a0 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 @ @ - 22 , 7 + 22 , 7 @ @ import im . actor . server . db . DbExtension 
 import im . actor . server . email . { EmailConfig , SmtpEmailSender } 
 import im . actor . server . model . { AuthAnonymousTransaction , AuthUsernameTransaction } 
 import im . actor . server . oauth . GoogleProvider 
 - import im . actor . server . persist . { UserPasswordRepo , UserRepo } 
 + import im . actor . server . persist . _ 
 import im . actor . server . persist . auth . { AuthUsernameTransactionRepo , AuthTransactionRepo } 
 import im . actor . server . session . _ 
 import im . actor . server . social . { SocialExtension , SocialManagerRegion } 
 @ @ - 84 , 7 + 84 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 override def jhandleGetAuthSessions ( clientData : ClientData ) : Future [ HandlerResult [ ResponseGetAuthSessions ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { client ⇒ 
 for { 
 - sessionModels ← persist . AuthSessionRepo . findByUserId ( client . userId ) 
 + sessionModels ← AuthSessionRepo . findByUserId ( client . userId ) 
 } yield { 
 val sessionStructs = sessionModels map { sessionModel ⇒ 
 val authHolder = 
 @ @ - 174 , 6 + 174 , 8 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 ) : Future [ HandlerResult [ ResponseStartPhoneAuth ] ] = { 
 val action = for { 
 normalizedPhone ← fromOption ( AuthErrors . PhoneNumberInvalid ) ( normalizeLong ( phoneNumber ) . headOption ) 
 + optPhone ← fromDBIO ( persist . UserPhoneRepo . findByPhoneNumber ( normalizedPhone ) . headOption ) 
 + _ ← optPhone map ( p ⇒ forbidDeletedUser ( p . userId ) ) getOrElse point ( ( ) ) 
 optAuthTransaction ← fromDBIO ( persist . auth . AuthPhoneTransactionRepo . findByPhoneAndDeviceHash ( normalizedPhone , deviceHash ) ) 
 transactionHash ← optAuthTransaction match { 
 case Some ( transaction ) ⇒ point ( transaction . transactionHash ) 
 @ @ - 195 , 7 + 197 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 } yield transactionHash 
 } 
 _ ← fromDBIOEither [ Unit , CodeFailure ] ( AuthErrors . activationFailure ) ( sendSmsCode ( normalizedPhone , genSmsCode ( normalizedPhone ) , Some ( transactionHash ) ) ) 
 - isRegistered ← fromDBIO ( persist . UserPhoneRepo . exists ( normalizedPhone ) ) 
 + isRegistered = optPhone . isDefined 
 } yield ResponseStartPhoneAuth ( transactionHash , isRegistered , Some ( ApiPhoneActivationType . CODE ) ) 
 db . run ( action . run ) 
 } 
 @ @ - 214 , 6 + 216 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 for { 
 normUsername ← fromOption ( ProfileErrors . NicknameInvalid ) ( StringUtils . normalizeUsername ( username ) ) 
 optUser ← fromDBIO ( UserRepo . findByNickname ( username ) ) 
 + _ ← optUser map ( u ⇒ forbidDeletedUser ( u . id ) ) getOrElse point ( ( ) ) 
 optAuthTransaction ← fromDBIO ( AuthUsernameTransactionRepo . find ( username , deviceHash ) ) 
 transactionHash ← optAuthTransaction match { 
 case Some ( transaction ) ⇒ point ( transaction . transactionHash ) 
 @ @ - 254 , 7 + 257 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 normUsername ← fromOption ( ProfileErrors . NicknameInvalid ) ( StringUtils . normalizeUsername ( username ) ) 
 accessSalt = ACLUtils . nextAccessSalt ( ) 
 nicknameExists ← fromDBIO ( UserRepo . nicknameExists ( normUsername ) ) 
 - optUser ← fromBoolean ( ProfileErrors . NicknameBusy ) ( ! nicknameExists ) 
 + _ ← fromBoolean ( ProfileErrors . NicknameBusy ) ( ! nicknameExists ) 
 transactionHash = ACLUtils . authTransactionHash ( accessSalt ) 
 transaction = AuthAnonymousTransaction ( 
 normUsername , 
 @ @ - 333 , 10 + 336 , 12 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 ) : Future [ HandlerResult [ ResponseStartEmailAuth ] ] = { 
 val action = for { 
 validEmail ← fromEither ( validEmail ( email ) . leftMap ( validationFailed ( " EMAIL _ INVALID " , _ ) ) ) 
 + optEmail ← fromDBIO ( persist . UserEmailRepo . find ( validEmail ) ) 
 + _ ← optEmail map ( e ⇒ forbidDeletedUser ( e . userId ) ) getOrElse point ( ( ) ) 
 / / OAUTH activation is temporary disabled 
 / / activationType = if ( OAuth2ProvidersDomains . supportsOAuth2 ( validEmail ) ) OAUTH2 else CODE 
 activationType = CODE 
 - isRegistered ← fromDBIO ( persist . UserEmailRepo . exists ( validEmail ) ) 
 + isRegistered = optEmail . isDefined 
 optTransaction ← fromDBIO ( persist . auth . AuthEmailTransactionRepo . findByEmailAndDeviceHash ( validEmail , deviceHash ) ) 
 transactionHash ← optTransaction match { 
 case Some ( trans ) ⇒ 
 @ @ - 412 , 7 + 417 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 
 override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 val action = requireAuth ( clientData ) map { implicit client ⇒ 
 - persist . AuthSessionRepo . findByAuthId ( client . authId ) flatMap { 
 + AuthSessionRepo . findByAuthId ( client . authId ) flatMap { 
 case Some ( session ) ⇒ 
 for ( _ ← DBIO . from ( userExt . logout ( session ) ) ) yield Ok ( misc . ResponseVoid ) 
 case None ⇒ throw new Exception ( s " Cannot find AuthSession for authId : $ { client . authId } " ) 
 @ @ - 425 , 7 + 430 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 override def jhandleTerminateAllSessions ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { client ⇒ 
 for { 
 - sessions ← persist . AuthSessionRepo . findByUserId ( client . userId ) map ( _ . filterNot ( _ . authId = = client . authId ) ) 
 + sessions ← AuthSessionRepo . findByUserId ( client . userId ) map ( _ . filterNot ( _ . authId = = client . authId ) ) 
 _ ← DBIO . from ( Future . sequence ( sessions map userExt . logout ) ) 
 } yield { 
 Ok ( ResponseVoid ) 
 @ @ - 437 , 7 + 442 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 
 override def jhandleTerminateSession ( id : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { client ⇒ 
 - persist . AuthSessionRepo . find ( client . userId , id ) . headOption flatMap { 
 + AuthSessionRepo . find ( client . userId , id ) . headOption flatMap { 
 case Some ( session ) ⇒ 
 if ( session . authId ! = clientData . authId ) { 
 for ( _ ← DBIO . from ( userExt . logout ( session ) ) ) yield Ok ( ResponseVoid ) 
 @ @ - 480 , 14 + 485 , 22 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 case None ⇒ 
 Future . successful ( Error ( AuthErrors . PhoneNumberInvalid ) ) 
 case Some ( normPhoneNumber ) ⇒ 
 - val action = persist . AuthSmsCodeObsoleteRepo . findByPhoneNumber ( normPhoneNumber ) . headOption . flatMap { 
 + val isDeletedAction = for { 
 + optPhone ← UserPhoneRepo . findByPhoneNumber ( normPhoneNumber ) . headOption 
 + isDeleted ← optPhone match { 
 + case Some ( phone ) ⇒ UserRepo . isDeleted ( phone . userId ) 
 + case None ⇒ DBIO . successful ( false ) 
 + } 
 + } yield isDeleted 
 + 
 + val sendCodeAction = AuthSmsCodeObsoleteRepo . findByPhoneNumber ( normPhoneNumber ) . headOption . flatMap { 
 case Some ( model . AuthSmsCodeObsolete ( _ , _ , smsHash , smsCode , _ ) ) ⇒ 
 DBIO . successful ( normPhoneNumber : : smsHash : : smsCode : : HNil ) 
 case None ⇒ 
 val smsHash = genSmsHash ( ) 
 val smsCode = genSmsCode ( normPhoneNumber ) 
 for ( 
 - _ ← persist . AuthSmsCodeObsoleteRepo . create ( 
 + _ ← AuthSmsCodeObsoleteRepo . create ( 
 id = ThreadLocalSecureRandom . current ( ) . nextLong ( ) , 
 phoneNumber = normPhoneNumber , 
 smsHash = smsHash , 
 @ @ - 495 , 13 + 508 , 16 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 ) 
 ) yield normPhoneNumber : : smsHash : : smsCode : : HNil 
 } . flatMap { res ⇒ 
 - persist . UserPhoneRepo . exists ( normPhoneNumber ) map ( res : + _ ) 
 + UserPhoneRepo . exists ( normPhoneNumber ) map ( res : + _ ) 
 } . map { 
 case number : : smsHash : : smsCode : : isRegistered : : HNil ⇒ 
 sendSmsCode ( number , smsCode , None ) 
 Ok ( ResponseSendAuthCodeObsolete ( smsHash , isRegistered ) ) 
 } 
 - db . run ( action ) 
 + db . run ( for { 
 + isDeleted ← isDeletedAction 
 + result ← if ( isDeleted ) DBIO . successful ( Error ( AuthErrors . UserDeleted ) ) else sendCodeAction 
 + } yield result ) 
 } 
 } 
 
 @ @ - 561 , 8 + 577 , 8 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 else { 
 val action = 
 ( for { 
 - optCode ← persist . AuthSmsCodeObsoleteRepo . findByPhoneNumber ( normPhoneNumber ) . headOption 
 - optPhone ← persist . UserPhoneRepo . findByPhoneNumber ( normPhoneNumber ) . headOption 
 + optCode ← AuthSmsCodeObsoleteRepo . findByPhoneNumber ( normPhoneNumber ) . headOption 
 + optPhone ← UserPhoneRepo . findByPhoneNumber ( normPhoneNumber ) . headOption 
 } yield optCode : : optPhone : : HNil ) . flatMap { 
 case None : : _ : : HNil ⇒ DBIO . successful ( Error ( AuthErrors . PhoneCodeExpired ) ) 
 case Some ( smsCodeModel ) : : _ : : HNil if smsCodeModel . smsHash ! = smsHash ⇒ 
 @ @ - 572 , 7 + 588 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 case Some ( _ ) : : optPhone : : HNil ⇒ 
 signType match { 
 case Up ( rawName , isSilent ) ⇒ 
 - persist . AuthSmsCodeObsoleteRepo . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( 
 + AuthSmsCodeObsoleteRepo . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( 
 optPhone match { 
 / / Phone does not exist , register the user 
 case None ⇒ withValidName ( rawName ) { name ⇒ 
 @ @ - 593 , 7 + 609 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 _ ← DBIO . from ( userExt . create ( user . id , user . accessSalt , None , user . name , user . countryCode , im . actor . api . rpc . users . ApiSex ( user . sex . toInt ) , isBot = false ) ) 
 _ ← DBIO . from ( userExt . auth ( userId , clientData . authId ) ) 
 _ ← DBIO . from ( userExt . addPhone ( user . id , normPhoneNumber ) ) 
 - _ ← persist . AvatarDataRepo . create ( model . AvatarData . empty ( model . AvatarData . OfUser , user . id . toLong ) ) 
 + _ ← AvatarDataRepo . create ( model . AvatarData . empty ( model . AvatarData . OfUser , user . id . toLong ) ) 
 } yield { 
 \ / - ( user : : HNil ) 
 } 
 @ @ - 607 , 7 + 623 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 optPhone match { 
 case None ⇒ DBIO . successful ( Error ( AuthErrors . PhoneNumberUnoccupied ) ) 
 case Some ( phone ) ⇒ 
 - persist . AuthSmsCodeObsoleteRepo . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( 
 + AuthSmsCodeObsoleteRepo . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( 
 signIn ( clientData . authId , phone . userId , countryCode , clientData ) 
 ) 
 } 
 @ @ - 629 , 9 + 645 , 9 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 ) 
 
 for { 
 - prevSessions ← persist . AuthSessionRepo . findByDeviceHash ( deviceHash ) 
 + prevSessions ← AuthSessionRepo . findByDeviceHash ( deviceHash ) 
 _ ← DBIO . from ( Future . sequence ( prevSessions map userExt . logout ) ) 
 - _ ← persist . AuthSessionRepo . create ( authSession ) 
 + _ ← AuthSessionRepo . create ( authSession ) 
 userStruct ← DBIO . from ( userExt . getApiStruct ( user . id , user . id , clientData . authId ) ) 
 } yield { 
 sessionRegion . ref ! SessionEnvelope ( clientData . authId , clientData . sessionId ) . withAuthorizeUser ( AuthorizeUser ( userStruct . id , authSession . id ) ) 
 @ @ - 652 , 7 + 668 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 } 
 
 private def signIn ( authId : Long , userId : Int , countryCode : String , clientData : ClientData ) = { 
 - persist . UserRepo . find ( userId ) . flatMap { 
 + UserRepo . find ( userId ) . flatMap { 
 case None ⇒ throw new Exception ( " Failed to retrieve user " ) 
 case Some ( user ) ⇒ 
 for { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceObsoleteSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceObsoleteSpec . scala 
 index c3259f7 . . 6598d19 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceObsoleteSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceObsoleteSpec . scala 
 @ @ - 7 , 6 + 7 , 7 @ @ import im . actor . server . _ 
 import im . actor . server . api . rpc . RpcApiService 
 import im . actor . server . api . rpc . service . auth 
 import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } 
 + import im . actor . server . user . UserExtension 
 
 import scala . concurrent . Await 
 import scala . concurrent . duration . _ 
 @ @ - 19 , 6 + 20 , 8 @ @ final class AuthServiceObsoleteSpec extends BaseAppSuite with SeqUpdateMatchers 
 
 it should " not fail if number already exists " in ( s . sendAuthCode . e1 ) 
 
 + it should " not allow deleted user to log in " in s . sendAuthCode . phoneDeletedUser 
 + 
 " SignUp handler " should " respond ok to a valid request " in ( s . signUp ( ) . e1 ) 
 
 it should " send ContactRegistered updates " in ( s . signUp ( ) . e2 ) 
 @ @ - 51 , 6 + 54 , 21 @ @ final class AuthServiceObsoleteSpec extends BaseAppSuite with SeqUpdateMatchers 
 } 
 } 
 } 
 + 
 + def phoneDeletedUser ( ) = { 
 + val ( user , authId , authSid , phoneNumber ) = createUser ( ) 
 + 
 + val sessionId = createSessionId ( ) 
 + implicit val clientData = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid ) ) ) 
 + 
 + whenReady ( UserExtension ( system ) . delete ( user . id ) ) ( identity ) 
 + 
 + whenReady ( service . handleSendAuthCodeObsolete ( phoneNumber , 1 , " apiKey " ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( AuthErrors . UserDeleted ) ⇒ 
 + } 
 + } 
 + } 
 } 
 
 case class signUp ( ) { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceSpec . scala 
 index d2af3f4 . . b1c4765 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / auth / AuthServiceSpec . scala 
 @ @ - 21 , 6 + 21 , 7 @ @ import im . actor . server . mtproto . protocol . { MessageBox , SessionHello } 
 import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } 
 import im . actor . server . persist . auth . AuthTransactionRepo 
 import im . actor . server . session . { HandleMessageBox , Session , SessionConfig , SessionEnvelope } 
 + import im . actor . server . user . UserExtension 
 
 import scala . concurrent . { ExecutionContext , Future } 
 import scala . util . Random 
 @ @ - 44 , 6 + 45 , 8 @ @ final class AuthServiceSpec 
 
 it should " associate authorizations from two different devices with different auth transactions " in s . e34 
 
 + it should " not allow deleted user to log in " in s . phoneDeletedUser 
 + 
 " ValidateCode handler " should " respond with error to invalid transactionHash " in s . e4 
 
 it should " respond with error to wrong sms auth code " in s . e5 
 @ @ - 79 , 6 + 82 , 8 @ @ final class AuthServiceSpec 
 
 it should " associate authorizations from two different devices with different auth transactions " in s . e155 
 
 + it should " not allow deleted user to log in " in s . emailDeletedUser 
 + 
 " GetOAuth2Params handler " should " respond with error when malformed url is passed " in pendingUntilFixed ( s . e16 ) 
 
 it should " respond with error when wrong transactionHash is passed " in pendingUntilFixed ( s . e17 ) 
 @ @ - 220 , 6 + 225 , 21 @ @ final class AuthServiceSpec 
 transactionHash1 should not equal transactionHash2 
 } 
 
 + def phoneDeletedUser ( ) = { 
 + val ( user , authId , authSid , phoneNumber ) = createUser ( ) 
 + 
 + val sessionId = createSessionId ( ) 
 + implicit val clientData = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid ) ) ) 
 + 
 + whenReady ( UserExtension ( system ) . delete ( user . id ) ) ( identity ) 
 + 
 + whenReady ( startPhoneAuth ( phoneNumber ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( AuthErrors . UserDeleted ) ⇒ 
 + } 
 + } 
 + } 
 + 
 def e4 ( ) = { 
 val phoneNumber = buildPhone ( ) 
 implicit val clientData = ClientData ( createAuthId ( ) , createSessionId ( ) , None ) 
 @ @ - 676 , 6 + 696 , 23 @ @ final class AuthServiceSpec 
 transactionHash1 should not equal transactionHash2 
 } 
 
 + def emailDeletedUser ( ) = { 
 + val ( user , authId , authSid , _ ) = createUser ( ) 
 + val email = buildEmail ( gmail ) 
 + 
 + val sessionId = createSessionId ( ) 
 + implicit val clientData = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid ) ) ) 
 + 
 + whenReady ( UserExtension ( system ) . addEmail ( user . id , email ) ) ( identity ) 
 + whenReady ( UserExtension ( system ) . delete ( user . id ) ) ( identity ) 
 + 
 + whenReady ( startEmailAuth ( email ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( AuthErrors . UserDeleted ) ⇒ 
 + } 
 + } 
 + } 
 + 
 def e16 ( ) = { 
 val email = buildEmail ( gmail ) 
 implicit val clientData = ClientData ( createAuthId ( ) , createSessionId ( ) , None ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceSpec . scala 
 index e8ed483 . . 54b3452 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceSpec . scala 
 @ @ - 98 , 7 + 98 , 7 @ @ final class EncryptionServiceSpec extends BaseAppSuite with ImplicitAuthService 
 signatures = signatures 
 ) ) ( _ . toOption . get . keyGroupId ) 
 
 - whenReady ( service . handleUploadEphermalKey ( 
 + whenReady ( service . handleUploadPreKey ( 
 keyGroupId , 
 ephKeys , 
 ephSignatures 
 @ @ - 110 , 7 + 110 , 7 @ @ final class EncryptionServiceSpec extends BaseAppSuite with ImplicitAuthService 
 { 
 implicit val clientData = bobClientData 
 
 - whenReady ( service . handleLoadEphermalPublicKeys ( 
 + whenReady ( service . handleLoadPrePublicKeys ( 
 getUserOutPeer ( alice . id , bobAuthId ) , 
 keyGroupId 
 ) ) { resp ⇒
