BLEU SCORE: 0.2626909894424158

TEST MSG: refactor ( server ) : move DistributedPubSub mediator to PubSubExtension
GENERATED MSG: feat ( server ) : logout on expired apple push

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 247eba9 . . ff62d3f 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 17 , 6 + 17 , 7 @ @ import im . actor . server . group . GroupExtension < nl > import im . actor . server . model . _ < nl > import im . actor . server . persist . messaging . ReactionEventRepo < nl > import im . actor . server . persist . { DialogRepo , HistoryMessageRepo } < nl > + import im . actor . server . pubsub . { PeerMessage , PubSubExtension } < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > import im . actor . server . user . UserExtension < nl > import org . joda . time . DateTime < nl > @ @ - 80 , 6 + 81 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > val date = Instant . now ( ) . toEpochMilli < nl > val sender = Peer . privat ( senderUserId ) < nl > val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) < nl > + PubSubExtension ( system ) . publish ( PeerMessage ( Peer . privat ( senderUserId ) , peer . asModel , randomId , date , message ) ) < nl > ( userExt . processorRegion . ref ? Envelope ( sender ) . withSendMessage ( sendMessage ) ) . mapTo [ SeqStateDate ] < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / pubsub / PubSubExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / pubsub / PubSubExtension . scala < nl > new file mode 100644 < nl > index 0000000 . . 04b3014 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / pubsub / PubSubExtension . scala < nl > @ @ - 0 , 0 + 1 , 63 @ @ < nl > + package im . actor . server . pubsub < nl > + < nl > + import akka . actor . _ < nl > + import akka . cluster . pubsub . DistributedPubSubMediator . { Publish , Subscribe } < nl > + import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } < nl > + import im . actor . api . rpc . PeersImplicits < nl > + import im . actor . api . rpc . messaging . ApiMessage < nl > + import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } < nl > + import im . actor . server . model < nl > + < nl > + sealed trait PubSubExtension extends Extension < nl > + < nl > + final case class PeerMessage ( fromPeer : model . Peer , toPeer : model . Peer , randomId : Long , date : Long , message : ApiMessage ) < nl > + < nl > + final class PubSubExtensionImpl ( system : ActorSystem ) extends PubSubExtension with PeersImplicits { < nl > + < nl > + val privateMessagesTopic : String = " messaging . messages . private " < nl > + val groupMessagesTopic : String = " messaging . messages . group " < nl > + < nl > + private val mediator = DistributedPubSub ( system ) . mediator < nl > + < nl > + def messagesTopic ( peer : model . Peer ) : String = { < nl > + val strType = peer . typ match { < nl > + case model . PeerType . Private ⇒ " private " < nl > + case model . PeerType . Group ⇒ " group " < nl > + case _ ⇒ throw new RuntimeException ( s " Unknown peer type $ { peer . typ } " ) < nl > + } < nl > + < nl > + s " messaging . messages . $ strType . $ { peer . id } " < nl > + } < nl > + < nl > + def messagesTopic ( peer : ApiPeer ) : String = < nl > + messagesTopic ( peer . asModel ) < nl > + < nl > + / / need to pass SubscribeAck back to subscribing actor ( which is ` context . self ` ) < nl > + def subscribe ( subscribe : Subscribe ) ( implicit context : ActorContext ) : Unit = mediator . tell ( subscribe , context . self ) < nl > + < nl > + def publish ( publish : Publish ) : Unit = mediator ! publish < nl > + < nl > + def publish ( message : PeerMessage ) : Unit = { < nl > + message . toPeer . typ match { < nl > + case model . PeerType . Private ⇒ < nl > + val senderTopic = messagesTopic ( ApiPeer ( ApiPeerType . Private , message . fromPeer . id ) ) < nl > + val receiverTopic = messagesTopic ( message . toPeer ) < nl > + < nl > + mediator ! DistributedPubSubMediator . Publish ( privateMessagesTopic , message , sendOneMessageToEachGroup = true ) < nl > + mediator ! DistributedPubSubMediator . Publish ( senderTopic , message , sendOneMessageToEachGroup = true ) < nl > + mediator ! DistributedPubSubMediator . Publish ( receiverTopic , message , sendOneMessageToEachGroup = true ) < nl > + case model . PeerType . Group ⇒ < nl > + val topic = messagesTopic ( message . toPeer ) < nl > + < nl > + mediator ! DistributedPubSubMediator . Publish ( groupMessagesTopic , message , sendOneMessageToEachGroup = false ) < nl > + mediator ! DistributedPubSubMediator . Publish ( topic , message , sendOneMessageToEachGroup = false ) < nl > + case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + object PubSubExtension extends ExtensionId [ PubSubExtensionImpl ] with ExtensionIdProvider { < nl > + override def lookup = PubSubExtension < nl > + < nl > + override def createExtension ( system : ExtendedActorSystem ) = new PubSubExtensionImpl ( system ) < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UserSequence . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UserSequence . scala < nl > index fb5aecf . . eaca44f 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UserSequence . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UserSequence . scala < nl > @ @ - 1 , 13 + 1 , 13 @ @ < nl > package im . actor . server . sequence < nl > < nl > import akka . actor . _ < nl > - import akka . cluster . pubsub . DistributedPubSub < nl > import akka . pattern . pipe < nl > import com . github . benmanes . caffeine . cache . Caffeine < nl > import com . google . protobuf . ByteString < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . model . { SeqUpdate , UpdateMapping } < nl > import im . actor . server . persist . sequence . UserSequenceRepo < nl > + import im . actor . server . pubsub . PubSubExtension < nl > < nl > import scala . concurrent . Future < nl > import scala . language . postfixOps < nl > @ @ - 51 , 11 + 51 , 10 @ @ private [ sequence ] final class UserSequence ( < nl > < nl > private val db = DbExtension ( context . system ) . db < nl > private val seqUpdExt = SeqUpdatesExtension ( context . system ) < nl > + private val pubSubExt = PubSubExtension ( context . system ) < nl > < nl > val userId = self . path . name . toInt < nl > < nl > - private val mediator = DistributedPubSub ( context . system ) . mediator < nl > - < nl > private val deliveryCache = Caffeine . newBuilder ( ) . maximumSize ( 100 ) . executor ( context . dispatcher ) . build [ String , SeqState ] ( ) < nl > < nl > private lazy val vendorPush = context . actorOf ( VendorPush . props ( userId , googlePushManager , applePushManager ) , " vendor - push " ) < nl > @ @ - 103 , 7 + 102 , 7 @ @ private [ sequence ] final class UserSequence ( < nl > < nl > writeToDb ( seqUpdate ) map ( _ ⇒ SeqState ( seq ) ) andThen { < nl > case Success ( _ ) ⇒ < nl > - mediator ! Publish ( topic ( userId ) , UserSequenceEvents . NewUpdate ( Some ( seqUpdate ) , pushRules , ByteString . EMPTY ) ) < nl > + pubSubExt . publish ( Publish ( topic ( userId ) , UserSequenceEvents . NewUpdate ( Some ( seqUpdate ) , pushRules , ByteString . EMPTY ) ) ) < nl > vendorPush ! DeliverPush ( seq , pushRules ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > index 5c6d83d . . ee91cac 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . server . db . DbExtension < nl > import im . actor . server . file . Avatar < nl > import im . actor . server . model . { SerializedUpdate , UpdateMapping , Peer } < nl > import im . actor . server . persist . UserRepo < nl > + import im . actor . server . pubsub . PubSubExtension < nl > import im . actor . server . sequence . { PushData , PushRules , SeqUpdatesExtension , SeqState } < nl > import im . actor . server . { model , persist ⇒ p } < nl > import im . actor . util . misc . IdUtils < nl > @ @ - 307 , 19 + 308 , 13 @ @ private [ user ] sealed trait AuthCommands { < nl > < nl > def logout ( session : model . AuthSession ) ( implicit db : Database ) : Future [ Unit ] = { < nl > system . log . warning ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) < nl > - < nl > - implicit val seqExt = SeqUpdatesExtension ( system ) < nl > - val mediator = DistributedPubSub ( system ) . mediator < nl > - < nl > for { < nl > _ ← removeAuth ( session . userId , session . authId ) < nl > - _ ← seqExt . deletePushCredentials ( session . authId ) < nl > + _ ← SeqUpdatesExtension ( system ) . deletePushCredentials ( session . authId ) < nl > _ ← db . run ( p . AuthSessionRepo . delete ( session . userId , session . id ) ) < nl > - } yield { < nl > - publishAuthIdInvalidated ( mediator , session . authId ) < nl > - } < nl > + } yield publishAuthIdInvalidated ( session . authId ) < nl > } < nl > < nl > - private def publishAuthIdInvalidated ( mediator : ActorRef , authId : Long ) : Unit = < nl > - mediator ! Publish ( authIdTopic ( authId ) , AuthEvents . AuthIdInvalidated ) < nl > + private def publishAuthIdInvalidated ( authId : Long ) : Unit = < nl > + PubSubExtension ( system ) . publish ( Publish ( authIdTopic ( authId ) , AuthEvents . AuthIdInvalidated ) ) < nl > } < nl > diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala < nl > index 3d63ee4 . . 01fff6a 100644 < nl > - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala < nl > + + + b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala < nl > @ @ - 1 , 28 + 1 , 25 @ @ < nl > package im . actor . server . enrich < nl > < nl > - import im . actor . server . db . DbExtension < nl > - import im . actor . server . file . { FileStorageExtension , FileUtils , FileStorageAdapter , ImageUtils } < nl > - import im . actor . util . log . AnyRefLogSource < nl > - < nl > - import scala . concurrent . ExecutionContextExecutor < nl > - import scala . concurrent . duration . _ < nl > - import scala . util . { Failure , Success , Try } < nl > - < nl > import akka . actor . _ < nl > - import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } < nl > + import akka . cluster . pubsub . DistributedPubSubMediator . { Subscribe , SubscribeAck } < nl > import akka . event . Logging < nl > import akka . http . scaladsl . model . Uri < nl > import akka . stream . Materializer < nl > import akka . util . Timeout < nl > + import com . sksamuel . scrimage . Image < nl > import com . sksamuel . scrimage . nio . JpegWriter < nl > - import com . sksamuel . scrimage . { Image , ParImage , Format } < nl > + import im . actor . api . rpc . files . ApiFastThumb < nl > + import im . actor . api . rpc . messaging . _ < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . file . { FileStorageAdapter , FileStorageExtension , FileUtils , ImageUtils } < nl > + import im . actor . server . pubsub . { PeerMessage , PubSubExtension } < nl > + import im . actor . util . log . AnyRefLogSource < nl > import org . joda . time . DateTime < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > - import im . actor . api . rpc . files . ApiFastThumb < nl > - import im . actor . api . rpc . messaging . _ < nl > - import im . actor . server . api . rpc . service . messaging . Events < nl > - import im . actor . server . api . rpc . service . messaging . MessagingService . _ < nl > + import scala . concurrent . ExecutionContextExecutor < nl > + import scala . concurrent . duration . _ < nl > + import scala . util . { Failure , Success , Try } < nl > < nl > object RichMessageWorker { < nl > val groupId = Some ( " RichMessageWorker " ) < nl > @ @ - 31 , 13 + 28 , 11 @ @ object RichMessageWorker { < nl > implicit < nl > system : ActorSystem , < nl > materializer : Materializer < nl > - ) : ActorRef = system . actorOf ( Props ( classOf [ RichMessageWorker ] , config , materializer ) ) < nl > + ) : ActorRef = system . actorOf ( Props ( classOf [ RichMessageWorker ] , config , materializer ) , " rich - message - worker " ) < nl > } < nl > < nl > final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : Materializer ) extends Actor with ActorLogging { < nl > < nl > - import DistributedPubSubMediator . SubscribeAck < nl > - < nl > import AnyRefLogSource . _ < nl > import PreviewMaker . _ < nl > import RichMessageWorker . _ < nl > @ @ - 47 , 28 + 42 , 29 @ @ final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : < nl > private implicit val timeout : Timeout = Timeout ( 10 . seconds ) < nl > < nl > private val db = DbExtension ( system ) . db < nl > - private val mediator = DistributedPubSub ( context . system ) . mediator < nl > + private val pubSubExt = PubSubExtension ( system ) < nl > < nl > - private implicit val fsAdapter : FileStorageAdapter = FileStorageExtension ( context . system ) . fsAdapter < nl > + private val fsAdapter : FileStorageAdapter = FileStorageExtension ( context . system ) . fsAdapter < nl > < nl > override val log = Logging ( system , this ) < nl > < nl > val previewMaker = PreviewMaker ( config , " previewMaker " ) < nl > < nl > - import DistributedPubSubMediator . Subscribe < nl > + private val privateSubscribe = Subscribe ( pubSubExt . privateMessagesTopic , groupId , self ) < nl > + private val publicSubscribe = Subscribe ( pubSubExt . groupMessagesTopic , None , self ) < nl > < nl > - mediator ! Subscribe ( privateMessagesTopic , groupId , self ) < nl > - mediator ! Subscribe ( groupMessagesTopic , None , self ) < nl > + pubSubExt . subscribe ( privateSubscribe ) < nl > + pubSubExt . subscribe ( publicSubscribe ) < nl > < nl > def receive : Receive = subscribing ( privateAckReceived = false , groupAckReceived = false ) < nl > < nl > def subscribing ( privateAckReceived : Boolean , groupAckReceived : Boolean ) : Receive = { < nl > - case SubscribeAck ( Subscribe ( ` privateMessagesTopic ` , ` groupId ` , ` self ` ) ) ⇒ < nl > + case SubscribeAck ( ` privateSubscribe ` ) ⇒ < nl > if ( groupAckReceived ) < nl > context . become ( ready ) < nl > else < nl > context . become ( subscribing ( true , groupAckReceived ) ) < nl > - case SubscribeAck ( Subscribe ( ` groupMessagesTopic ` , _ , ` self ` ) ) ⇒ < nl > + case SubscribeAck ( ` publicSubscribe ` ) ⇒ < nl > if ( privateAckReceived ) < nl > context . become ( ready ) < nl > else < nl > @ @ - 76 , 7 + 72 , 7 @ @ final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : < nl > } < nl > < nl > def ready : Receive = { < nl > - case Events . PeerMessage ( fromPeer , toPeer , randomId , _ , message ) ⇒ < nl > + case PeerMessage ( fromPeer , toPeer , randomId , _ , message ) ⇒ < nl > message match { < nl > case ApiTextMessage ( text , _ , _ ) ⇒ < nl > Try ( Uri ( text . trim ) ) match { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > index 869d296 . . 42a9912 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > @ @ - 14 , 14 + 14 , 14 @ @ import im . actor . server . sequence . SeqStateDate < nl > import scala . concurrent . _ < nl > < nl > private [ messaging ] trait MessagingHandlers { < nl > - self : MessagingServiceImpl ⇒ < nl > + this : MessagingServiceImpl ⇒ < nl > < nl > import im . actor . api . rpc . Implicits . _ < nl > < nl > override implicit val ec : ExecutionContext = actorSystem . dispatcher < nl > private implicit val timeout : Timeout = ActorConfig . defaultTimeout < nl > < nl > - override def jhandleSendMessage ( outPeer : ApiOutPeer , randomId : Long , message : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = { < nl > + override def jhandleSendMessage ( outPeer : ApiOutPeer , randomId : Long , message : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > val accessHashCheck = outPeer . ` type ` match { < nl > case ApiPeerType . Private ⇒ userExt . checkAccessHash ( outPeer . id , client . authId , outPeer . accessHash ) < nl > @ @ - 39 , 15 + 39 , 10 @ @ private [ messaging ] trait MessagingHandlers { < nl > ) ) < nl > } yield result < nl > < nl > - ( for ( SeqStateDate ( seq , state , date ) ← seqstateAction ) yield { < nl > - val fromPeer = ApiPeer ( ApiPeerType . Private , client . userId ) < nl > - val toPeer = outPeer . asPeer < nl > - onMessage ( Events . PeerMessage ( fromPeer . asModel , toPeer . asModel , randomId , date , message ) ) < nl > - ResponseSeqDate ( seq , state . toByteArray , date ) < nl > - } ) . run recover { < nl > + ( for ( SeqStateDate ( seq , state , date ) ← seqstateAction ) < nl > + yield ResponseSeqDate ( seq , state . toByteArray , date ) ) . run recover { < nl > case GroupErrors . NotAMember ⇒ Error ( CommonErrors . forbidden ( " You are not a group member . " ) ) < nl > case DialogErrors . MessageToSelf ⇒ Error ( CommonErrors . forbidden ( " Sending messages to self is not allowed . " ) ) < nl > } < nl > } < nl > - } < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala < nl > index 8be018a . . 2ab93a7 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala < nl > @ @ - 1 , 79 + 1 , 24 @ @ < nl > package im . actor . server . api . rpc . service . messaging < nl > < nl > import akka . actor . _ < nl > - import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } < nl > - import im . actor . api . rpc . Implicits . _ < nl > import im . actor . api . rpc . messaging . _ < nl > - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . DialogExtension < nl > import im . actor . server . group . GroupExtension < nl > - import im . actor . server . model < nl > import im . actor . server . social . { SocialExtension , SocialManagerRegion } < nl > import im . actor . server . user . UserExtension < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > - sealed trait Event < nl > - < nl > - object Events { < nl > - < nl > - final case class PeerMessage ( fromPeer : model . Peer , toPeer : model . Peer , randomId : Long , date : Long , message : ApiMessage ) extends Event < nl > - < nl > - } < nl > - < nl > - object MessagingService { < nl > - val privateMessagesTopic : String = " messaging . messages . private " < nl > - val groupMessagesTopic : String = " messaging . messages . group " < nl > - < nl > - def messagesTopic ( peer : model . Peer ) : String = { < nl > - val strType = peer . typ match { < nl > - case model . PeerType . Private ⇒ " private " < nl > - case model . PeerType . Group ⇒ " group " < nl > - case _ ⇒ throw new RuntimeException ( s " Unknown peer type $ { peer . typ } " ) < nl > - } < nl > - < nl > - s " messaging . messages . $ strType . $ { peer . id } " < nl > - } < nl > - < nl > - def messagesTopic ( peer : ApiPeer ) : String = < nl > - messagesTopic ( peer . asModel ) < nl > - < nl > - def publish ( mediator : ActorRef , message : Events . PeerMessage ) : Unit = { < nl > - message . toPeer . typ match { < nl > - case model . PeerType . Private ⇒ < nl > - val senderTopic = MessagingService . messagesTopic ( ApiPeer ( ApiPeerType . Private , message . fromPeer . id ) ) < nl > - val receiverTopic = messagesTopic ( message . toPeer ) < nl > - < nl > - mediator ! DistributedPubSubMediator . Publish ( privateMessagesTopic , message , sendOneMessageToEachGroup = true ) < nl > - mediator ! DistributedPubSubMediator . Publish ( senderTopic , message , sendOneMessageToEachGroup = true ) < nl > - mediator ! DistributedPubSubMediator . Publish ( receiverTopic , message , sendOneMessageToEachGroup = true ) < nl > - case model . PeerType . Group ⇒ < nl > - val topic = messagesTopic ( message . toPeer ) < nl > - < nl > - mediator ! DistributedPubSubMediator . Publish ( groupMessagesTopic , message , sendOneMessageToEachGroup = false ) < nl > - mediator ! DistributedPubSubMediator . Publish ( topic , message , sendOneMessageToEachGroup = false ) < nl > - case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) < nl > - } < nl > - } < nl > - } < nl > - < nl > object MessagingServiceImpl { < nl > - def apply ( ) ( < nl > - implicit < nl > - actorSystem : ActorSystem < nl > - ) : MessagingServiceImpl = { < nl > - val onMessage = ( MessagingService . publish _ ) . curried ( DistributedPubSub ( actorSystem ) . mediator ) < nl > - < nl > - new MessagingServiceImpl ( onMessage ) < nl > - } < nl > + def apply ( ) ( implicit actorSystem : ActorSystem ) : MessagingServiceImpl = new MessagingServiceImpl < nl > } < nl > < nl > - final class MessagingServiceImpl ( < nl > - protected val onMessage : Events . PeerMessage ⇒ Unit < nl > - ) ( < nl > - implicit < nl > - protected val actorSystem : ActorSystem < nl > - ) extends MessagingService with MessagingHandlers with HistoryHandlers with ReactionsHandlers with FavouritesHandlers { < nl > + final class MessagingServiceImpl ( implicit protected val actorSystem : ActorSystem ) < nl > + extends MessagingService < nl > + with MessagingHandlers < nl > + with HistoryHandlers < nl > + with ReactionsHandlers < nl > + with FavouritesHandlers { < nl > protected val db : Database = DbExtension ( actorSystem ) . db < nl > protected val userExt = UserExtension ( actorSystem ) < nl > protected val groupExt = GroupExtension ( actorSystem ) < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksListener . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksListener . scala < nl > index 84ef6bb . . be4812c 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksListener . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksListener . scala < nl > @ @ - 41 , 8 + 41 , 6 @ @ private [ messaging ] final class ReverseHooksListener extends Actor with ActorLogg < nl > private implicit val system : ActorSystem = context . system < nl > import system . dispatcher < nl > < nl > - private val mediator = DistributedPubSub ( context . system ) . mediator < nl > - < nl > private val scheduledFetch = context . system . scheduler . schedule ( Duration . Zero , 1 . minute , self , RefetchGroups ) < nl > private val db = DbExtension ( system ) . db < nl > < nl > @ @ - 84 , 7 + 82 , 7 @ @ private [ messaging ] final class ReverseHooksListener extends Actor with ActorLogg < nl > } yield { < nl > optToken . map { token ⇒ < nl > context . actorOf ( < nl > - ReverseHooksWorker . props ( groupId , token , mediator ) , < nl > + ReverseHooksWorker . props ( groupId , token ) , < nl > interceptorGroupId ( groupId ) < nl > ) < nl > ( ) < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksWorker . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksWorker . scala < nl > index c93b007 . . 26b9225 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksWorker . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksWorker . scala < nl > @ @ - 13 , 10 + 13 , 10 @ @ import com . google . protobuf . CodedInputStream < nl > import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport < nl > import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage } < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > - import im . actor . server . office . EntityNotFound < nl > - import im . actor . server . { KeyValueMappings , model } < nl > import im . actor . server . model . PeerType . { Group , Private } < nl > - import im . actor . server . user . { UserExtension , UserOffice , UserViewRegion } < nl > + import im . actor . server . pubsub . { PeerMessage , PubSubExtension } < nl > + import im . actor . server . user . UserExtension < nl > + import im . actor . server . { KeyValueMappings , model } < nl > import im . actor . util . log . AnyRefLogSource < nl > import play . api . libs . json . { Format , Json } < nl > import shardakka . ShardakkaExtension < nl > @ @ - 28 , 7 + 28 , 7 @ @ import scala . util . { Failure , Success } < nl > object ReverseHooksWorker { < nl > private [ messaging ] case object Resubscribe < nl > < nl > - def props ( groupId : Int , token : String , mediator : ActorRef ) = Props ( classOf [ ReverseHooksWorker ] , groupId , token , mediator ) < nl > + def props ( groupId : Int , token : String ) = Props ( classOf [ ReverseHooksWorker ] , groupId , token ) < nl > < nl > private [ messaging ] def interceptorGroupId ( groupId : Int ) : String = s " group - $ groupId " < nl > < nl > @ @ - 37 , 7 + 37 , 7 @ @ object ReverseHooksWorker { < nl > implicit val format : Format [ MessageToWebhook ] = Json . format [ MessageToWebhook ] < nl > } < nl > < nl > - private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String , mediator : ActorRef ) < nl > + private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String ) < nl > extends Actor < nl > with ActorLogging < nl > with AnyRefLogSource < nl > @ @ - 54 , 6 + 54 , 7 @ @ private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String , m < nl > private [ this ] val scheduledResubscribe = system . scheduler . schedule ( Duration . Zero , 1 . minute , self , Resubscribe ) < nl > private [ this ] val reverseHooksKv = ShardakkaExtension ( system ) . simpleKeyValue ( KeyValueMappings . ReverseHooks + " _ " + token ) < nl > private [ this ] val http : HttpExt = Http ( ) < nl > + private [ this ] val pubSubExt = PubSubExtension ( system ) < nl > < nl > override val log = Logging ( system , this ) < nl > < nl > @ @ - 61 , 7 + 62 , 7 @ @ private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String , m < nl > < nl > def init : Receive = { < nl > case Resubscribe ⇒ < nl > - mediator ! Subscribe ( MessagingService . messagesTopic ( ApiPeer ( ApiPeerType . Group , groupId ) ) , None , self ) < nl > + pubSubExt . subscribe ( Subscribe ( pubSubExt . messagesTopic ( ApiPeer ( ApiPeerType . Group , groupId ) ) , None , self ) ) < nl > case SubscribeAck ( Subscribe ( topic , _ , _ ) ) ⇒ < nl > log . debug ( " Watching for group ' s { } reverse hooks " , groupId ) < nl > scheduledResubscribe . cancel ( ) < nl > @ @ - 69 , 7 + 70 , 7 @ @ private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String , m < nl > } < nl > < nl > def working : Receive = { < nl > - case Events . PeerMessage ( from , _ , _ , _ , message ) ⇒ < nl > + case PeerMessage ( from , _ , _ , _ , message ) ⇒ < nl > log . debug ( " Got message from group { } , peer { } to forward to webhook " , groupId , from ) < nl > val parsed = ApiMessage . parseFrom ( CodedInputStream . newInstance ( message . toByteArray ) ) < nl > < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > index 936a6e0 . . 9003172 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . session < nl > import java . util . concurrent . TimeUnit < nl > < nl > import akka . actor . _ < nl > + import akka . cluster . pubsub . DistributedPubSubMediator . { SubscribeAck , Subscribe } < nl > import akka . cluster . sharding . ShardRegion . Passivate < nl > import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } < nl > - import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } < nl > import akka . pattern . pipe < nl > import akka . stream . { ClosedShape , Materializer } < nl > import akka . stream . actor . _ < nl > @ @ - 17 , 6 + 17 , 7 @ @ import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec < nl > import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . mtproto . transport . { Drop , MTPackage } < nl > import im . actor . server . persist . { AuthSessionRepo , AuthIdRepo } < nl > + import im . actor . server . pubsub . PubSubExtension < nl > import im . actor . server . user . { AuthEvents , UserExtension } < nl > import scodec . DecodeResult < nl > import scodec . bits . BitVector < nl > @ @ - 84 , 7 + 85 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > < nl > implicit val ec : ExecutionContext = context . dispatcher < nl > < nl > - private val mediator : ActorRef = DistributedPubSub ( context . system ) . mediator < nl > + private val pubSubExt = PubSubExtension ( context . system ) < nl > private val db : Database = DbExtension ( context . system ) . db < nl > < nl > private [ this ] var authData : Option [ AuthData ] = None < nl > @ @ - 126 , 11 + 127 , 12 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > < nl > unstashAll ( ) < nl > < nl > - val subscribe = DistributedPubSubMediator . Subscribe ( UserExtension ( context . system ) . authIdTopic ( authId ) , self ) < nl > - mediator ! subscribe < nl > + val subscribe = Subscribe ( UserExtension ( context . system ) . authIdTopic ( authId ) , self ) < nl > + < nl > + pubSubExt . subscribe ( subscribe ) < nl > < nl > val waiting : Receive = { < nl > - case msg if msg = = DistributedPubSubMediator . SubscribeAck ( subscribe ) ⇒ < nl > + case SubscribeAck ( ` subscribe ` ) ⇒ < nl > unstashAll ( ) < nl > context . become ( anonymous ) < nl > case msg ⇒ < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > index 348955b . . 4a394d6 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > @ @ - 12 , 7 + 12 , 7 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiUserOutPeer } < nl > import im . actor . server . _ < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > - import im . actor . server . api . rpc . service . messaging . Events < nl > + import im . actor . server . pubsub . PeerMessage < nl > < nl > import scala . concurrent . Future < nl > import scala . util . Random < nl > @ @ - 305 , 8 + 305 , 8 @ @ class MessagingServiceSpec < nl > } < nl > < nl > whenReady ( service . handleSendMessage ( user2Peer , Random . nextLong ( ) , ApiTextMessage ( " Hi PubSub " , Vector . empty , None ) ) ) { resp ⇒ < nl > - probe . expectMsgClass ( classOf [ Events . PeerMessage ] ) < nl > - probe . expectMsgClass ( classOf [ Events . PeerMessage ] ) < nl > + probe . expectMsgClass ( classOf [ PeerMessage ] ) < nl > + probe . expectMsgClass ( classOf [ PeerMessage ] ) < nl > } < nl > } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - cqrs / src / main / protobuf / user . proto b / actor - server / actor - cqrs / src / main / protobuf / user . proto < nl > index b80d0d7 . . b080172 100644 < nl > - - - a / actor - server / actor - cqrs / src / main / protobuf / user . proto < nl > + + + b / actor - server / actor - cqrs / src / main / protobuf / user . proto < nl > @ @ - 308 , 5 + 308 , 4 @ @ message UserEvents { < nl > < nl > optional Avatar avatar = 1 ; < nl > } < nl > - } < nl > - < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / ApplePushManager . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / ApplePushManager . scala < nl > index b6e0328 . . 9e60253 100644 < nl > - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / ApplePushManager . scala < nl > + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / ApplePushManager . scala < nl > @ @ - 1 , 11 + 1 , 20 @ @ < nl > package im . actor . server . push < nl > < nl > + import java . util < nl > + < nl > import scala . collection . JavaConversions . _ < nl > + import scala . concurrent . ExecutionContext < nl > + import scala . concurrent . duration . _ < nl > < nl > import akka . actor . ActorSystem < nl > + import akka . util . Timeout < nl > import com . relayrides . pushy . apns . _ < nl > import com . relayrides . pushy . apns . util . { SSLContextUtil , SimpleApnsPushNotification } < nl > import com . typesafe . config . Config < nl > + import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . user . { UserProcessorRegion , UserExtension , UserOffice } < nl > < nl > case class ApplePushManagerConfig ( certs : List [ ApnsCert ] , isSandbox : Boolean ) < nl > < nl > @ @ - 27 , 7 + 36 , 9 @ @ object ApnsCert { < nl > } < nl > } < nl > < nl > - class ApplePushManager ( config : ApplePushManagerConfig , actorSystem : ActorSystem ) { < nl > + class ApplePushManager ( config : ApplePushManagerConfig , system : ActorSystem ) { < nl > + private implicit val ec : ExecutionContext = system . dispatcher < nl > + < nl > private val managers : Map [ Int , PushManager [ SimpleApnsPushNotification ] ] = < nl > config . certs . map { cert ⇒ < nl > val env = config . isSandbox match { < nl > @ @ - 44 , 7 + 55 , 12 @ @ class ApplePushManager ( config : ApplePushManagerConfig , actorSystem : ActorSystem ) < nl > new PushManagerConfiguration ( ) , < nl > s " ActorPushManager - $ { cert . key } " < nl > ) < nl > - mgr . registerRejectedNotificationListener ( new LoggingRejectedNotificationListener ( actorSystem ) ) < nl > + mgr . registerRejectedNotificationListener ( new LoggingRejectedNotificationListener ( system ) ) < nl > + mgr . registerExpiredTokenListener ( new CleanExpiredTokenListener ( system ) ) < nl > + < nl > + system . scheduler . schedule ( 0 . seconds , 1 . hour ) { < nl > + mgr . requestExpiredTokens ( ) < nl > + } < nl > < nl > mgr . start ( ) < nl > < nl > @ @ - 55 , 8 + 71 , 36 @ @ class ApplePushManager ( config : ApplePushManagerConfig , actorSystem : ActorSystem ) < nl > managers . get ( key ) < nl > } < nl > < nl > - private class LoggingRejectedNotificationListener ( actorSystem : ActorSystem ) extends RejectedNotificationListener [ SimpleApnsPushNotification ] { < nl > + private class LoggingRejectedNotificationListener ( _ system : ActorSystem ) extends RejectedNotificationListener [ SimpleApnsPushNotification ] { < nl > + private implicit val system : ActorSystem = _ system < nl > + private implicit val ec : ExecutionContext = _ system . dispatcher < nl > + < nl > override def handleRejectedNotification ( pushManager : PushManager [ _ < : SimpleApnsPushNotification ] , notification : SimpleApnsPushNotification , rejectionReason : RejectedNotificationReason ) : Unit = { < nl > - actorSystem . log . warning ( " { } was rejected with rejection reason { } " , notification , rejectionReason ) < nl > + system . log . warning ( " APNS rejected notification with reason : { } " , rejectionReason ) < nl > + < nl > + if ( rejectionReason . getErrorCode = = RejectedNotificationReason . INVALID _ TOKEN . getErrorCode ) { < nl > + system . log . warning ( " Deleting token " ) < nl > + SeqUpdatesManager . deleteApplePushToken ( notification . getToken ) < nl > + } < nl > } < nl > } < nl > + < nl > + private class CleanExpiredTokenListener ( _ system : ActorSystem ) extends ExpiredTokenListener [ SimpleApnsPushNotification ] { < nl > + private implicit val system : ActorSystem = _ system < nl > + private implicit val ec : ExecutionContext = _ system . dispatcher < nl > + private implicit val timeout : Timeout = Timeout ( 20 . seconds ) < nl > + private implicit val db : Database = DbExtension ( _ system ) . db < nl > + private implicit val userProcessorRegion : UserProcessorRegion = UserExtension ( _ system ) . processorRegion < nl > + < nl > + override def handleExpiredTokens ( < nl > + pushManager : PushManager [ _ < : SimpleApnsPushNotification ] , < nl > + expiredTokens : util . Collection [ ExpiredToken ] < nl > + ) : Unit = { < nl > + expiredTokens foreach { t ⇒ < nl > + system . log . warning ( " APNS reported expired token , loggint out " ) < nl > + UserOffice . logoutByAppleToken ( t . getToken ) < nl > + } < nl > + < nl > + } < nl > + < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > index 9db2df3 . . 954ce48 100644 < nl > - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > @ @ - 14 , 6 + 14 , 7 @ @ import slick . dbio . DBIO < nl > import im . actor . api . rpc . messaging . UpdateMessage < nl > import im . actor . api . rpc . peers . Peer < nl > import im . actor . api . { rpc ⇒ api } < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . models . sequence < nl > import im . actor . server . sequence . SeqState < nl > import im . actor . server . user . { UserOffice , UserViewRegion } < nl > @ @ - 306 , 6 + 307 , 16 @ @ object SeqUpdatesManager { < nl > ext . region . ref ! Envelope ( authId , PushCredentialsUpdated ( None ) ) < nl > } < nl > < nl > + def deleteApplePushToken ( token : Array [ Byte ] ) ( implicit ec : ExecutionContext , system : ActorSystem ) : Unit = { < nl > + val seqRegion = SeqUpdatesExtension ( system ) . region < nl > + < nl > + DbExtension ( system ) . db . run ( p . push . ApplePushCredentials . findByToken ( token ) ) foreach { creds ⇒ < nl > + creds foreach { c ⇒ < nl > + seqRegion . ref ! Envelope ( c . authId , DeletePushCredentials ( Some ( c ) ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > def getDifference ( authId : Long , timestamp : Long , maxSizeInBytes : Long ) ( implicit ec : ExecutionContext ) : DBIO [ ( Vector [ models . sequence . SeqUpdate ] , Boolean ) ] = { < nl > def run ( state : Long , acc : Vector [ models . sequence . SeqUpdate ] , currentSize : Long ) : DBIO [ ( Vector [ models . sequence . SeqUpdate ] , Boolean ) ] = { < nl > p . sequence . SeqUpdate . findAfter ( authId , state ) . flatMap { updates ⇒ < nl > diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala < nl > index 24abc6d . . 21f04d6 100644 < nl > - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala < nl > + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala < nl > @ @ - 1 , 9 + 1 , 7 @ @ < nl > package im . actor . server . push < nl > < nl > - import java . nio . ByteBuffer < nl > import java . util . concurrent . TimeUnit < nl > < nl > - import scala . concurrent . { Future , ExecutionContext } < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > import scala . util . { Failure , Success } < nl > @ @ - 11 , 7 + 9 , 6 @ @ import scala . util . { Failure , Success } < nl > import akka . actor . _ < nl > import akka . contrib . pattern . ShardRegion < nl > import akka . pattern . pipe < nl > - import com . github . tototoshi . slick . PostgresJodaSupport . _ < nl > import com . google . protobuf . ByteString < nl > < nl > import im . actor . api . rpc . UpdateBox < nl > @ @ - 69 , 6 + 66 , 9 @ @ object SeqUpdatesManagerMessages { < nl > case class PushCredentialsUpdated ( credsOpt : Option [ models . push . PushCredentials ] ) extends Message < nl > < nl > @ SerialVersionUID ( 1L ) < nl > + case class DeletePushCredentials ( credsOpt : Option [ models . push . PushCredentials ] ) extends Message < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > case class UpdateReceived ( update : UpdateBox ) < nl > } < nl > < nl > @ @ - 158 , 6 + 158 , 19 @ @ private final class SeqUpdatesManagerActor ( < nl > appleCredsOpt = None < nl > db . run ( deletePushCredentials ( authId ) ) < nl > } < nl > + case DeletePushCredentials ( credsOpt ) ⇒ < nl > + credsOpt match { < nl > + case c @ Some ( _ ) if c = = appleCredsOpt ⇒ < nl > + log . warning ( " Deleting apple push creds " ) < nl > + appleCredsOpt = None < nl > + db . run ( deletePushCredentials ( authId ) ) < nl > + case c @ Some ( _ ) if c = = googleCredsOpt ⇒ < nl > + log . warning ( " Deleting google push creds " ) < nl > + googleCredsOpt = None < nl > + db . run ( deletePushCredentials ( authId ) ) < nl > + case None ⇒ < nl > + / / ignoring , already deleted < nl > + } < nl > case ReceiveTimeout ⇒ < nl > if ( consumers . isEmpty ) { < nl > context . parent ! Passivate ( stopMessage = PoisonPill ) < nl > diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / AuthCommands . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / AuthCommands . scala < nl > new file mode 100644 < nl > index 0000000 . . bf3fb95 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / AuthCommands . scala < nl > @ @ - 0 , 0 + 1 , 78 @ @ < nl > + package im . actor . server . user < nl > + < nl > + import scala . concurrent . { Future , ExecutionContext } < nl > + < nl > + import akka . actor . { ActorRef , ActorSystem } < nl > + import akka . contrib . pattern . DistributedPubSubExtension < nl > + import akka . pattern . ask < nl > + import akka . util . Timeout < nl > + < nl > + import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . push . { SeqUpdatesExtension , SeqUpdatesManager } < nl > + import im . actor . server . { models , persist ⇒ p } < nl > + < nl > + trait AuthEvent < nl > + < nl > + object AuthEvents { < nl > + case object AuthIdInvalidated < nl > + } < nl > + < nl > + trait AuthCommands { < nl > + self : Queries ⇒ < nl > + < nl > + import UserCommands . _ < nl > + import akka . contrib . pattern . DistributedPubSubMediator . _ < nl > + < nl > + def authIdTopic ( authId : Long ) : String = s " auth . events . $ { authId } " < nl > + < nl > + def auth ( userId : Int , authId : Long ) ( < nl > + implicit < nl > + userOfficeRegion : UserProcessorRegion , < nl > + timeout : Timeout , < nl > + ec : ExecutionContext < nl > + ) : Future [ NewAuthAck ] = { < nl > + ( userOfficeRegion . ref ? NewAuth ( userId , authId ) ) . mapTo [ NewAuthAck ] < nl > + } < nl > + < nl > + def removeAuth ( userId : Int , authId : Long ) ( < nl > + implicit < nl > + userOfficeRegion : UserProcessorRegion , < nl > + timeout : Timeout , < nl > + ec : ExecutionContext < nl > + < nl > + ) : Future [ RemoveAuthAck ] = ( userOfficeRegion . ref ? RemoveAuth ( userId , authId ) ) . mapTo [ RemoveAuthAck ] < nl > + < nl > + def logoutByAppleToken ( token : Array [ Byte ] ) ( implicit ec : ExecutionContext , system : ActorSystem , timeout : Timeout , db : Database , userProcessorRegion : UserProcessorRegion ) : Future [ Unit ] = { < nl > + db . run ( p . push . ApplePushCredentials . findByToken ( token ) ) flatMap { creds ⇒ < nl > + Future . sequence ( creds map ( c ⇒ logout ( c . authId ) ) ) map ( _ ⇒ ( ) ) < nl > + } < nl > + } < nl > + < nl > + def logout ( authId : Long ) ( implicit ec : ExecutionContext , system : ActorSystem , timeout : Timeout , db : Database , userProcessorRegion : UserProcessorRegion ) : Future [ Unit ] = { < nl > + db . run ( p . AuthSession . findByAuthId ( authId ) ) flatMap { < nl > + case Some ( session ) ⇒ logout ( session ) < nl > + case None ⇒ throw new Exception ( " Can ' t find auth session to logout " ) < nl > + } < nl > + } < nl > + < nl > + def logout ( session : models . AuthSession ) ( implicit ec : ExecutionContext , system : ActorSystem , timeout : Timeout , db : Database , userProcessorRegion : UserProcessorRegion ) : Future [ Unit ] = { < nl > + system . log . debug ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) < nl > + < nl > + implicit val seqExt = SeqUpdatesExtension ( system ) < nl > + val mediator = DistributedPubSubExtension ( system ) . mediator < nl > + < nl > + for { < nl > + _ ← removeAuth ( session . userId , session . authId ) < nl > + _ ← db . run ( p . AuthSession . delete ( session . userId , session . id ) ) < nl > + _ = SeqUpdatesManager . deletePushCredentials ( session . authId ) < nl > + } yield { < nl > + publishAuthIdInvalidated ( mediator , session . authId ) < nl > + } < nl > + } < nl > + < nl > + private def publishAuthIdInvalidated ( mediator : ActorRef , authId : Long ) : Unit = { < nl > + mediator ! Publish ( authIdTopic ( authId ) , AuthEvents . AuthIdInvalidated ) < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserOffice . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserOffice . scala < nl > index 8c0e2a4 . . f92420b 100644 < nl > - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserOffice . scala < nl > + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserOffice . scala < nl > @ @ - 15 , 7 + 15 , 9 @ @ import im . actor . api . rpc . messaging . { Message ⇒ ApiMessage } < nl > import im . actor . api . rpc . peers . Peer < nl > import im . actor . api . rpc . users . { User ⇒ ApiUser } < nl > import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . file . Avatar < nl > + import im . actor . server . { models , persist } < nl > import im . actor . server . push . SeqUpdatesManagerMessages . { FatMetaData , FatData } < nl > import im . actor . server . push . { SeqUpdatesExtension , SeqUpdatesManager , SeqUpdatesManagerRegion } < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > @ @ - 28 , 8 + 30 , 8 @ @ object UserOffice extends Commands with Queries { < nl > def persistenceIdFor ( userId : Int ) : String = s " User - $ { userId } " < nl > } < nl > < nl > - private [ user ] sealed trait Commands { < nl > - this : Queries ⇒ < nl > + private [ user ] sealed trait Commands extends AuthCommands { < nl > + self : Queries ⇒ < nl > < nl > import UserCommands . _ < nl > < nl > @ @ - 87 , 23 + 89 , 6 @ @ private [ user ] sealed trait Commands { < nl > ( userOfficeRegion . ref ? ChangeName ( userId , name ) ) . mapTo [ SeqState ] < nl > } < nl > < nl > - def auth ( userId : Int , authId : Long ) ( < nl > - implicit < nl > - userOfficeRegion : UserProcessorRegion , < nl > - timeout : Timeout , < nl > - ec : ExecutionContext < nl > - ) : Future [ NewAuthAck ] = { < nl > - ( userOfficeRegion . ref ? NewAuth ( userId , authId ) ) . mapTo [ NewAuthAck ] < nl > - } < nl > - < nl > - def removeAuth ( userId : Int , authId : Long ) ( < nl > - implicit < nl > - userOfficeRegion : UserProcessorRegion , < nl > - timeout : Timeout , < nl > - ec : ExecutionContext < nl > - < nl > - ) : Future [ RemoveAuthAck ] = ( userOfficeRegion . ref ? RemoveAuth ( userId , authId ) ) . mapTo [ RemoveAuthAck ] < nl > - < nl > def sendMessage ( userId : Int , senderUserId : Int , senderAuthId : Long , accessHash : Long , randomId : Long , message : ApiMessage ) ( < nl > implicit < nl > peerManagerRegion : UserProcessorRegion , < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / push / ApplePushCredentials . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / push / ApplePushCredentials . scala < nl > index 6dd674a . . bb45119 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / push / ApplePushCredentials . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / push / ApplePushCredentials . scala < nl > @ @ - 19 , 6 + 19 , 8 @ @ class ApplePushCredentialsTable ( tag : Tag ) extends Table [ models . push . ApplePushCre < nl > object ApplePushCredentials { < nl > val creds = TableQuery [ ApplePushCredentialsTable ] < nl > < nl > + def byToken ( token : Array [ Byte ] ) = creds . filter ( _ . token = = = token ) < nl > + < nl > def createOrUpdate ( authId : Long , apnsKey : Int , token : Array [ Byte ] ) ( implicit ec : ExecutionContext ) = { < nl > for { < nl > _ ← creds . filterNot ( _ . authId = = = authId ) . filter ( c ⇒ c . apnsKey = = = apnsKey & & c . token = = = token ) . delete < nl > @ @ - 38 , 6 + 40 , 9 @ @ object ApplePushCredentials { < nl > def delete ( authId : Long ) = < nl > creds . filter ( _ . authId = = = authId ) . delete < nl > < nl > + def findByToken ( token : Array [ Byte ] ) = < nl > + byToken ( token ) . result < nl > + < nl > def deleteByToken ( token : Array [ Byte ] ) = < nl > - creds . filter ( _ . token = = = token ) . delete < nl > + byToken ( token ) . delete < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > index 8b088c1 . . e2da841 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > @ @ - 3 , 31 + 3 , 25 @ @ package im . actor . server . api . rpc . service . auth < nl > import java . time . { LocalDateTime , ZoneOffset } < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . duration . _ < nl > import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scalaz . { - \ / , \ / , \ / - } < nl > < nl > import akka . actor . ActorSystem < nl > import akka . pattern . ask < nl > - import akka . util . Timeout < nl > - import org . joda . time . DateTime < nl > import slick . dbio < nl > import slick . dbio . Effect . Write < nl > import slick . dbio . _ < nl > < nl > import im . actor . api . rpc . DBIOResult . _ < nl > import im . actor . api . rpc . _ < nl > - import im . actor . api . rpc . contacts . UpdateContactRegistered < nl > import im . actor . api . rpc . users . Sex . _ < nl > import im . actor . server . activation . Activation . { EmailCode , SmsCode } < nl > import im . actor . server . activation . _ < nl > import im . actor . server . models . { AuthEmailTransaction , AuthPhoneTransaction , User } < nl > import im . actor . server . persist . auth . AuthTransaction < nl > import im . actor . server . push . SeqUpdatesManager . _ < nl > - import im . actor . server . push . SeqUpdatesManagerRegion < nl > import im . actor . server . session . _ < nl > - import im . actor . server . social . SocialManager . _ < nl > - import im . actor . server . user . { UserProcessorRegion , UserOffice } < nl > + import im . actor . server . user . UserOffice < nl > import im . actor . server . util . IdUtils . _ < nl > import im . actor . server . util . PhoneNumberUtils . _ < nl > import im . actor . server . util . StringUtils . validName < nl > @ @ - 137 , 7 + 131 , 7 @ @ trait AuthHelpers extends Helpers { < nl > protected def refreshAuthSession ( deviceHash : Array [ Byte ] , newSession : models . AuthSession ) : DBIO [ Unit ] = < nl > for { < nl > prevSessions ← persist . AuthSession . findByDeviceHash ( deviceHash ) < nl > - _ ← DBIO . sequence ( prevSessions map logout ) < nl > + _ ← DBIO . from ( Future . sequence ( prevSessions map UserOffice . logout ) ) < nl > _ ← persist . AuthSession . create ( newSession ) < nl > } yield ( ) < nl > < nl > @ @ - 162 , 18 + 156 , 6 @ @ trait AuthHelpers extends Helpers { < nl > } yield user < nl > } < nl > < nl > - protected def logout ( session : models . AuthSession ) ( implicit system : ActorSystem , m : PubSubMediator ) : dbio . DBIOAction [ Unit , NoStream , Write with Write ] = { < nl > - system . log . debug ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) < nl > - < nl > - for { < nl > - _ ← DBIO . from ( UserOffice . removeAuth ( session . userId , session . authId ) ) < nl > - _ ← persist . AuthSession . delete ( session . userId , session . id ) < nl > - _ = deletePushCredentials ( session . authId ) < nl > - } yield { < nl > - AuthService . publishAuthIdInvalidated ( m . mediator , session . authId ) < nl > - } < nl > - } < nl > - < nl > protected def sendSmsCode ( phoneNumber : Long , code : String , transactionHash : Option [ String ] ) ( implicit system : ActorSystem ) : DBIO [ String \ / Unit ] = { < nl > log . info ( " Sending code { } to { } " , code , phoneNumber ) < nl > activationContext . send ( transactionHash , SmsCode ( phoneNumber , code ) ) < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > index d10eaab . . 123f990 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > @ @ - 33 , 25 + 33 , 6 @ @ import im . actor . server . user . { UserViewRegion , UserExtension , UserOffice , UserPro < nl > import im . actor . server . util . _ < nl > import im . actor . server . { persist , models } < nl > < nl > - sealed trait AuthEvent < nl > - < nl > - object AuthEvents { < nl > - case object AuthIdInvalidated extends AuthEvent < nl > - } < nl > - < nl > - object AuthService { < nl > - < nl > - import akka . contrib . pattern . DistributedPubSubMediator . _ < nl > - < nl > - import AuthEvents . _ < nl > - < nl > - def authIdTopic ( authId : Long ) : String = s " auth . events . $ { authId } " < nl > - < nl > - private [ auth ] def publishAuthIdInvalidated ( mediator : ActorRef , authId : Long ) : Unit = { < nl > - mediator ! Publish ( authIdTopic ( authId ) , AuthIdInvalidated ) < nl > - } < nl > - } < nl > - < nl > case class PubSubMediator ( mediator : ActorRef ) < nl > < nl > class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) ( < nl > @ @ - 290 , 7 + 271 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) < nl > val action = requireAuth ( clientData ) map { implicit client ⇒ < nl > persist . AuthSession . findByAuthId ( client . authId ) flatMap { < nl > case Some ( session ) ⇒ < nl > - for ( _ ← logout ( session ) ) yield Ok ( misc . ResponseVoid ) < nl > + for ( _ ← DBIO . from ( UserOffice . logout ( session ) ) ) yield Ok ( misc . ResponseVoid ) < nl > case None ⇒ throw new Exception ( s " Cannot find AuthSession for authId : $ { client . authId } " ) < nl > } < nl > } < nl > @ @ - 302 , 7 + 283 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) < nl > val authorizedAction = requireAuth ( clientData ) . map { client ⇒ < nl > for { < nl > sessions ← persist . AuthSession . findByUserId ( client . userId ) map ( _ . filterNot ( _ . authId = = client . authId ) ) < nl > - _ ← DBIO . sequence ( sessions map logout ) < nl > + _ ← DBIO . from ( Future . sequence ( sessions map UserOffice . logout ) ) < nl > } yield { < nl > Ok ( ResponseVoid ) < nl > } < nl > @ @ - 315 , 7 + 296 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) < nl > val authorizedAction = requireAuth ( clientData ) . map { client ⇒ < nl > persist . AuthSession . find ( client . userId , id ) . headOption flatMap { < nl > case Some ( session ) ⇒ < nl > - for ( _ ← logout ( session ) ) yield Ok ( ResponseVoid ) < nl > + for ( _ ← DBIO . from ( UserOffice . logout ( session ) ) ) yield Ok ( ResponseVoid ) < nl > case None ⇒ < nl > DBIO . successful ( Error ( AuthErrors . AuthSessionNotFound ) ) < nl > } < nl > @ @ - 490 , 7 + 471 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) < nl > < nl > for { < nl > prevSessions ← persist . AuthSession . findByDeviceHash ( deviceHash ) < nl > - _ ← DBIO . sequence ( prevSessions map logout ) < nl > + _ ← DBIO . from ( Future . sequence ( prevSessions map UserOffice . logout ) ) < nl > _ ← persist . AuthSession . create ( authSession ) < nl > userStruct ← DBIO . from ( UserOffice . getApiStruct ( user . id , user . id , clientData . authId ) ) < nl > } yield { < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > index 5d1b0b9 . . 5910bb9 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > @ @ - 19 , 13 + 19 , 13 @ @ import scodec . bits . BitVector < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . api . rpc . ClientData < nl > - import im . actor . server . api . rpc . service . auth . { AuthEvents , AuthService } < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec < nl > import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . mtproto . transport . { Drop , MTPackage } < nl > import im . actor . server . presences . { GroupPresenceManagerRegion , PresenceManagerRegion } < nl > - import im . actor . server . push . { SeqUpdatesExtension , SeqUpdatesManagerRegion , WeakUpdatesManagerRegion } < nl > + import im . actor . server . push . { SeqUpdatesExtension , WeakUpdatesManagerRegion } < nl > + import im . actor . server . user . { UserOffice , AuthEvents } < nl > import im . actor . server . { models , persist } < nl > < nl > case class SessionConfig ( idleTimeout : Duration , reSendConfig : ReSenderConfig ) < nl > @ @ - 117 , 7 + 117 , 7 @ @ class Session ( mediator : ActorRef ) ( < nl > val replyTo = sender ( ) < nl > stash ( ) < nl > < nl > - val subscribe = DistributedPubSubMediator . Subscribe ( AuthService . authIdTopic ( authId ) , self ) < nl > + val subscribe = DistributedPubSubMediator . Subscribe ( UserOffice . authIdTopic ( authId ) , self ) < nl > mediator ! subscribe < nl > < nl > context . become ( waitingForSessionInfo ( authId , sessionId , subscribe ) ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > index 4676b00 . . d2b5007 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > @ @ - 138 , 7 + 138 , 7 @ @ class MessagingServiceSpec < nl > resps foreach ( _ should matchPattern { case Ok ( ResponseSeqDate ( 1000 , _ , _ ) ) ⇒ } ) < nl > } < nl > < nl > - expectUpdate [ UpdateMessageSent ] ( 0 , Array . empty , UpdateMessageSent . header , Some ( 1 ) ) ( identity ) < nl > + expectUpdate [ UpdateMessageSent ] ( 0 , Array . empty , UpdateMessageSent . header , Some ( 1 ) ) ( identity ) < nl > } < nl > < nl > { < nl > @ @ - 275 , 7 + 275 , 7 @ @ class MessagingServiceSpec < nl > resps foreach ( _ should matchPattern { case Ok ( ResponseSeqDate ( 1002 , _ , _ ) ) ⇒ } ) < nl > } < nl > < nl > - expectUpdate [ UpdateMessageSent ] ( 0 , Array . empty , UpdateMessageSent . header ) ( identity ) < nl > + expectUpdate [ UpdateMessageSent ] ( 0 , Array . empty , UpdateMessageSent . header ) ( identity ) < nl > } < nl > < nl > { < nl > diff - - git a / actor - server / actor - utils / src / main / scala / im / actor / server / util / UserUtils . scala b / actor - server / actor - utils / src / main / scala / im / actor / server / util / UserUtils . scala < nl > index c5a3c0b . . 4459dd1 100644 < nl > - - - a / actor - server / actor - utils / src / main / scala / im / actor / server / util / UserUtils . scala < nl > + + + b / actor - server / actor - utils / src / main / scala / im / actor / server / util / UserUtils . scala < nl > @ @ - 11 , 6 + 11 , 7 @ @ import slick . profile . SqlAction < nl > < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . users . _ < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . models . UserPhone < nl > import im . actor . server . { models , persist }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 247eba9 . . ff62d3f 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 17 , 6 + 17 , 7 @ @ import im . actor . server . group . GroupExtension 
 import im . actor . server . model . _ 
 import im . actor . server . persist . messaging . ReactionEventRepo 
 import im . actor . server . persist . { DialogRepo , HistoryMessageRepo } 
 + import im . actor . server . pubsub . { PeerMessage , PubSubExtension } 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 import im . actor . server . user . UserExtension 
 import org . joda . time . DateTime 
 @ @ - 80 , 6 + 81 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 val date = Instant . now ( ) . toEpochMilli 
 val sender = Peer . privat ( senderUserId ) 
 val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) 
 + PubSubExtension ( system ) . publish ( PeerMessage ( Peer . privat ( senderUserId ) , peer . asModel , randomId , date , message ) ) 
 ( userExt . processorRegion . ref ? Envelope ( sender ) . withSendMessage ( sendMessage ) ) . mapTo [ SeqStateDate ] 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / pubsub / PubSubExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / pubsub / PubSubExtension . scala 
 new file mode 100644 
 index 0000000 . . 04b3014 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / pubsub / PubSubExtension . scala 
 @ @ - 0 , 0 + 1 , 63 @ @ 
 + package im . actor . server . pubsub 
 + 
 + import akka . actor . _ 
 + import akka . cluster . pubsub . DistributedPubSubMediator . { Publish , Subscribe } 
 + import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } 
 + import im . actor . api . rpc . PeersImplicits 
 + import im . actor . api . rpc . messaging . ApiMessage 
 + import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } 
 + import im . actor . server . model 
 + 
 + sealed trait PubSubExtension extends Extension 
 + 
 + final case class PeerMessage ( fromPeer : model . Peer , toPeer : model . Peer , randomId : Long , date : Long , message : ApiMessage ) 
 + 
 + final class PubSubExtensionImpl ( system : ActorSystem ) extends PubSubExtension with PeersImplicits { 
 + 
 + val privateMessagesTopic : String = " messaging . messages . private " 
 + val groupMessagesTopic : String = " messaging . messages . group " 
 + 
 + private val mediator = DistributedPubSub ( system ) . mediator 
 + 
 + def messagesTopic ( peer : model . Peer ) : String = { 
 + val strType = peer . typ match { 
 + case model . PeerType . Private ⇒ " private " 
 + case model . PeerType . Group ⇒ " group " 
 + case _ ⇒ throw new RuntimeException ( s " Unknown peer type $ { peer . typ } " ) 
 + } 
 + 
 + s " messaging . messages . $ strType . $ { peer . id } " 
 + } 
 + 
 + def messagesTopic ( peer : ApiPeer ) : String = 
 + messagesTopic ( peer . asModel ) 
 + 
 + / / need to pass SubscribeAck back to subscribing actor ( which is ` context . self ` ) 
 + def subscribe ( subscribe : Subscribe ) ( implicit context : ActorContext ) : Unit = mediator . tell ( subscribe , context . self ) 
 + 
 + def publish ( publish : Publish ) : Unit = mediator ! publish 
 + 
 + def publish ( message : PeerMessage ) : Unit = { 
 + message . toPeer . typ match { 
 + case model . PeerType . Private ⇒ 
 + val senderTopic = messagesTopic ( ApiPeer ( ApiPeerType . Private , message . fromPeer . id ) ) 
 + val receiverTopic = messagesTopic ( message . toPeer ) 
 + 
 + mediator ! DistributedPubSubMediator . Publish ( privateMessagesTopic , message , sendOneMessageToEachGroup = true ) 
 + mediator ! DistributedPubSubMediator . Publish ( senderTopic , message , sendOneMessageToEachGroup = true ) 
 + mediator ! DistributedPubSubMediator . Publish ( receiverTopic , message , sendOneMessageToEachGroup = true ) 
 + case model . PeerType . Group ⇒ 
 + val topic = messagesTopic ( message . toPeer ) 
 + 
 + mediator ! DistributedPubSubMediator . Publish ( groupMessagesTopic , message , sendOneMessageToEachGroup = false ) 
 + mediator ! DistributedPubSubMediator . Publish ( topic , message , sendOneMessageToEachGroup = false ) 
 + case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) 
 + } 
 + } 
 + } 
 + 
 + object PubSubExtension extends ExtensionId [ PubSubExtensionImpl ] with ExtensionIdProvider { 
 + override def lookup = PubSubExtension 
 + 
 + override def createExtension ( system : ExtendedActorSystem ) = new PubSubExtensionImpl ( system ) 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UserSequence . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UserSequence . scala 
 index fb5aecf . . eaca44f 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UserSequence . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UserSequence . scala 
 @ @ - 1 , 13 + 1 , 13 @ @ 
 package im . actor . server . sequence 
 
 import akka . actor . _ 
 - import akka . cluster . pubsub . DistributedPubSub 
 import akka . pattern . pipe 
 import com . github . benmanes . caffeine . cache . Caffeine 
 import com . google . protobuf . ByteString 
 import im . actor . server . db . DbExtension 
 import im . actor . server . model . { SeqUpdate , UpdateMapping } 
 import im . actor . server . persist . sequence . UserSequenceRepo 
 + import im . actor . server . pubsub . PubSubExtension 
 
 import scala . concurrent . Future 
 import scala . language . postfixOps 
 @ @ - 51 , 11 + 51 , 10 @ @ private [ sequence ] final class UserSequence ( 
 
 private val db = DbExtension ( context . system ) . db 
 private val seqUpdExt = SeqUpdatesExtension ( context . system ) 
 + private val pubSubExt = PubSubExtension ( context . system ) 
 
 val userId = self . path . name . toInt 
 
 - private val mediator = DistributedPubSub ( context . system ) . mediator 
 - 
 private val deliveryCache = Caffeine . newBuilder ( ) . maximumSize ( 100 ) . executor ( context . dispatcher ) . build [ String , SeqState ] ( ) 
 
 private lazy val vendorPush = context . actorOf ( VendorPush . props ( userId , googlePushManager , applePushManager ) , " vendor - push " ) 
 @ @ - 103 , 7 + 102 , 7 @ @ private [ sequence ] final class UserSequence ( 
 
 writeToDb ( seqUpdate ) map ( _ ⇒ SeqState ( seq ) ) andThen { 
 case Success ( _ ) ⇒ 
 - mediator ! Publish ( topic ( userId ) , UserSequenceEvents . NewUpdate ( Some ( seqUpdate ) , pushRules , ByteString . EMPTY ) ) 
 + pubSubExt . publish ( Publish ( topic ( userId ) , UserSequenceEvents . NewUpdate ( Some ( seqUpdate ) , pushRules , ByteString . EMPTY ) ) ) 
 vendorPush ! DeliverPush ( seq , pushRules ) 
 } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 index 5c6d83d . . ee91cac 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . server . db . DbExtension 
 import im . actor . server . file . Avatar 
 import im . actor . server . model . { SerializedUpdate , UpdateMapping , Peer } 
 import im . actor . server . persist . UserRepo 
 + import im . actor . server . pubsub . PubSubExtension 
 import im . actor . server . sequence . { PushData , PushRules , SeqUpdatesExtension , SeqState } 
 import im . actor . server . { model , persist ⇒ p } 
 import im . actor . util . misc . IdUtils 
 @ @ - 307 , 19 + 308 , 13 @ @ private [ user ] sealed trait AuthCommands { 
 
 def logout ( session : model . AuthSession ) ( implicit db : Database ) : Future [ Unit ] = { 
 system . log . warning ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) 
 - 
 - implicit val seqExt = SeqUpdatesExtension ( system ) 
 - val mediator = DistributedPubSub ( system ) . mediator 
 - 
 for { 
 _ ← removeAuth ( session . userId , session . authId ) 
 - _ ← seqExt . deletePushCredentials ( session . authId ) 
 + _ ← SeqUpdatesExtension ( system ) . deletePushCredentials ( session . authId ) 
 _ ← db . run ( p . AuthSessionRepo . delete ( session . userId , session . id ) ) 
 - } yield { 
 - publishAuthIdInvalidated ( mediator , session . authId ) 
 - } 
 + } yield publishAuthIdInvalidated ( session . authId ) 
 } 
 
 - private def publishAuthIdInvalidated ( mediator : ActorRef , authId : Long ) : Unit = 
 - mediator ! Publish ( authIdTopic ( authId ) , AuthEvents . AuthIdInvalidated ) 
 + private def publishAuthIdInvalidated ( authId : Long ) : Unit = 
 + PubSubExtension ( system ) . publish ( Publish ( authIdTopic ( authId ) , AuthEvents . AuthIdInvalidated ) ) 
 } 
 diff - - git a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala 
 index 3d63ee4 . . 01fff6a 100644 
 - - - a / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala 
 + + + b / actor - server / actor - enrich / src / main / scala / im / actor / server / enrich / RichMessageWorker . scala 
 @ @ - 1 , 28 + 1 , 25 @ @ 
 package im . actor . server . enrich 
 
 - import im . actor . server . db . DbExtension 
 - import im . actor . server . file . { FileStorageExtension , FileUtils , FileStorageAdapter , ImageUtils } 
 - import im . actor . util . log . AnyRefLogSource 
 - 
 - import scala . concurrent . ExecutionContextExecutor 
 - import scala . concurrent . duration . _ 
 - import scala . util . { Failure , Success , Try } 
 - 
 import akka . actor . _ 
 - import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } 
 + import akka . cluster . pubsub . DistributedPubSubMediator . { Subscribe , SubscribeAck } 
 import akka . event . Logging 
 import akka . http . scaladsl . model . Uri 
 import akka . stream . Materializer 
 import akka . util . Timeout 
 + import com . sksamuel . scrimage . Image 
 import com . sksamuel . scrimage . nio . JpegWriter 
 - import com . sksamuel . scrimage . { Image , ParImage , Format } 
 + import im . actor . api . rpc . files . ApiFastThumb 
 + import im . actor . api . rpc . messaging . _ 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . file . { FileStorageAdapter , FileStorageExtension , FileUtils , ImageUtils } 
 + import im . actor . server . pubsub . { PeerMessage , PubSubExtension } 
 + import im . actor . util . log . AnyRefLogSource 
 import org . joda . time . DateTime 
 import slick . driver . PostgresDriver . api . _ 
 
 - import im . actor . api . rpc . files . ApiFastThumb 
 - import im . actor . api . rpc . messaging . _ 
 - import im . actor . server . api . rpc . service . messaging . Events 
 - import im . actor . server . api . rpc . service . messaging . MessagingService . _ 
 + import scala . concurrent . ExecutionContextExecutor 
 + import scala . concurrent . duration . _ 
 + import scala . util . { Failure , Success , Try } 
 
 object RichMessageWorker { 
 val groupId = Some ( " RichMessageWorker " ) 
 @ @ - 31 , 13 + 28 , 11 @ @ object RichMessageWorker { 
 implicit 
 system : ActorSystem , 
 materializer : Materializer 
 - ) : ActorRef = system . actorOf ( Props ( classOf [ RichMessageWorker ] , config , materializer ) ) 
 + ) : ActorRef = system . actorOf ( Props ( classOf [ RichMessageWorker ] , config , materializer ) , " rich - message - worker " ) 
 } 
 
 final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : Materializer ) extends Actor with ActorLogging { 
 
 - import DistributedPubSubMediator . SubscribeAck 
 - 
 import AnyRefLogSource . _ 
 import PreviewMaker . _ 
 import RichMessageWorker . _ 
 @ @ - 47 , 28 + 42 , 29 @ @ final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : 
 private implicit val timeout : Timeout = Timeout ( 10 . seconds ) 
 
 private val db = DbExtension ( system ) . db 
 - private val mediator = DistributedPubSub ( context . system ) . mediator 
 + private val pubSubExt = PubSubExtension ( system ) 
 
 - private implicit val fsAdapter : FileStorageAdapter = FileStorageExtension ( context . system ) . fsAdapter 
 + private val fsAdapter : FileStorageAdapter = FileStorageExtension ( context . system ) . fsAdapter 
 
 override val log = Logging ( system , this ) 
 
 val previewMaker = PreviewMaker ( config , " previewMaker " ) 
 
 - import DistributedPubSubMediator . Subscribe 
 + private val privateSubscribe = Subscribe ( pubSubExt . privateMessagesTopic , groupId , self ) 
 + private val publicSubscribe = Subscribe ( pubSubExt . groupMessagesTopic , None , self ) 
 
 - mediator ! Subscribe ( privateMessagesTopic , groupId , self ) 
 - mediator ! Subscribe ( groupMessagesTopic , None , self ) 
 + pubSubExt . subscribe ( privateSubscribe ) 
 + pubSubExt . subscribe ( publicSubscribe ) 
 
 def receive : Receive = subscribing ( privateAckReceived = false , groupAckReceived = false ) 
 
 def subscribing ( privateAckReceived : Boolean , groupAckReceived : Boolean ) : Receive = { 
 - case SubscribeAck ( Subscribe ( ` privateMessagesTopic ` , ` groupId ` , ` self ` ) ) ⇒ 
 + case SubscribeAck ( ` privateSubscribe ` ) ⇒ 
 if ( groupAckReceived ) 
 context . become ( ready ) 
 else 
 context . become ( subscribing ( true , groupAckReceived ) ) 
 - case SubscribeAck ( Subscribe ( ` groupMessagesTopic ` , _ , ` self ` ) ) ⇒ 
 + case SubscribeAck ( ` publicSubscribe ` ) ⇒ 
 if ( privateAckReceived ) 
 context . become ( ready ) 
 else 
 @ @ - 76 , 7 + 72 , 7 @ @ final class RichMessageWorker ( config : RichMessageConfig ) ( implicit materializer : 
 } 
 
 def ready : Receive = { 
 - case Events . PeerMessage ( fromPeer , toPeer , randomId , _ , message ) ⇒ 
 + case PeerMessage ( fromPeer , toPeer , randomId , _ , message ) ⇒ 
 message match { 
 case ApiTextMessage ( text , _ , _ ) ⇒ 
 Try ( Uri ( text . trim ) ) match { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 index 869d296 . . 42a9912 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 @ @ - 14 , 14 + 14 , 14 @ @ import im . actor . server . sequence . SeqStateDate 
 import scala . concurrent . _ 
 
 private [ messaging ] trait MessagingHandlers { 
 - self : MessagingServiceImpl ⇒ 
 + this : MessagingServiceImpl ⇒ 
 
 import im . actor . api . rpc . Implicits . _ 
 
 override implicit val ec : ExecutionContext = actorSystem . dispatcher 
 private implicit val timeout : Timeout = ActorConfig . defaultTimeout 
 
 - override def jhandleSendMessage ( outPeer : ApiOutPeer , randomId : Long , message : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = { 
 + override def jhandleSendMessage ( outPeer : ApiOutPeer , randomId : Long , message : ApiMessage , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 val accessHashCheck = outPeer . ` type ` match { 
 case ApiPeerType . Private ⇒ userExt . checkAccessHash ( outPeer . id , client . authId , outPeer . accessHash ) 
 @ @ - 39 , 15 + 39 , 10 @ @ private [ messaging ] trait MessagingHandlers { 
 ) ) 
 } yield result 
 
 - ( for ( SeqStateDate ( seq , state , date ) ← seqstateAction ) yield { 
 - val fromPeer = ApiPeer ( ApiPeerType . Private , client . userId ) 
 - val toPeer = outPeer . asPeer 
 - onMessage ( Events . PeerMessage ( fromPeer . asModel , toPeer . asModel , randomId , date , message ) ) 
 - ResponseSeqDate ( seq , state . toByteArray , date ) 
 - } ) . run recover { 
 + ( for ( SeqStateDate ( seq , state , date ) ← seqstateAction ) 
 + yield ResponseSeqDate ( seq , state . toByteArray , date ) ) . run recover { 
 case GroupErrors . NotAMember ⇒ Error ( CommonErrors . forbidden ( " You are not a group member . " ) ) 
 case DialogErrors . MessageToSelf ⇒ Error ( CommonErrors . forbidden ( " Sending messages to self is not allowed . " ) ) 
 } 
 } 
 - } 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala 
 index 8be018a . . 2ab93a7 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala 
 @ @ - 1 , 79 + 1 , 24 @ @ 
 package im . actor . server . api . rpc . service . messaging 
 
 import akka . actor . _ 
 - import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } 
 - import im . actor . api . rpc . Implicits . _ 
 import im . actor . api . rpc . messaging . _ 
 - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . DialogExtension 
 import im . actor . server . group . GroupExtension 
 - import im . actor . server . model 
 import im . actor . server . social . { SocialExtension , SocialManagerRegion } 
 import im . actor . server . user . UserExtension 
 import slick . driver . PostgresDriver . api . _ 
 
 - sealed trait Event 
 - 
 - object Events { 
 - 
 - final case class PeerMessage ( fromPeer : model . Peer , toPeer : model . Peer , randomId : Long , date : Long , message : ApiMessage ) extends Event 
 - 
 - } 
 - 
 - object MessagingService { 
 - val privateMessagesTopic : String = " messaging . messages . private " 
 - val groupMessagesTopic : String = " messaging . messages . group " 
 - 
 - def messagesTopic ( peer : model . Peer ) : String = { 
 - val strType = peer . typ match { 
 - case model . PeerType . Private ⇒ " private " 
 - case model . PeerType . Group ⇒ " group " 
 - case _ ⇒ throw new RuntimeException ( s " Unknown peer type $ { peer . typ } " ) 
 - } 
 - 
 - s " messaging . messages . $ strType . $ { peer . id } " 
 - } 
 - 
 - def messagesTopic ( peer : ApiPeer ) : String = 
 - messagesTopic ( peer . asModel ) 
 - 
 - def publish ( mediator : ActorRef , message : Events . PeerMessage ) : Unit = { 
 - message . toPeer . typ match { 
 - case model . PeerType . Private ⇒ 
 - val senderTopic = MessagingService . messagesTopic ( ApiPeer ( ApiPeerType . Private , message . fromPeer . id ) ) 
 - val receiverTopic = messagesTopic ( message . toPeer ) 
 - 
 - mediator ! DistributedPubSubMediator . Publish ( privateMessagesTopic , message , sendOneMessageToEachGroup = true ) 
 - mediator ! DistributedPubSubMediator . Publish ( senderTopic , message , sendOneMessageToEachGroup = true ) 
 - mediator ! DistributedPubSubMediator . Publish ( receiverTopic , message , sendOneMessageToEachGroup = true ) 
 - case model . PeerType . Group ⇒ 
 - val topic = messagesTopic ( message . toPeer ) 
 - 
 - mediator ! DistributedPubSubMediator . Publish ( groupMessagesTopic , message , sendOneMessageToEachGroup = false ) 
 - mediator ! DistributedPubSubMediator . Publish ( topic , message , sendOneMessageToEachGroup = false ) 
 - case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) 
 - } 
 - } 
 - } 
 - 
 object MessagingServiceImpl { 
 - def apply ( ) ( 
 - implicit 
 - actorSystem : ActorSystem 
 - ) : MessagingServiceImpl = { 
 - val onMessage = ( MessagingService . publish _ ) . curried ( DistributedPubSub ( actorSystem ) . mediator ) 
 - 
 - new MessagingServiceImpl ( onMessage ) 
 - } 
 + def apply ( ) ( implicit actorSystem : ActorSystem ) : MessagingServiceImpl = new MessagingServiceImpl 
 } 
 
 - final class MessagingServiceImpl ( 
 - protected val onMessage : Events . PeerMessage ⇒ Unit 
 - ) ( 
 - implicit 
 - protected val actorSystem : ActorSystem 
 - ) extends MessagingService with MessagingHandlers with HistoryHandlers with ReactionsHandlers with FavouritesHandlers { 
 + final class MessagingServiceImpl ( implicit protected val actorSystem : ActorSystem ) 
 + extends MessagingService 
 + with MessagingHandlers 
 + with HistoryHandlers 
 + with ReactionsHandlers 
 + with FavouritesHandlers { 
 protected val db : Database = DbExtension ( actorSystem ) . db 
 protected val userExt = UserExtension ( actorSystem ) 
 protected val groupExt = GroupExtension ( actorSystem ) 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksListener . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksListener . scala 
 index 84ef6bb . . be4812c 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksListener . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksListener . scala 
 @ @ - 41 , 8 + 41 , 6 @ @ private [ messaging ] final class ReverseHooksListener extends Actor with ActorLogg 
 private implicit val system : ActorSystem = context . system 
 import system . dispatcher 
 
 - private val mediator = DistributedPubSub ( context . system ) . mediator 
 - 
 private val scheduledFetch = context . system . scheduler . schedule ( Duration . Zero , 1 . minute , self , RefetchGroups ) 
 private val db = DbExtension ( system ) . db 
 
 @ @ - 84 , 7 + 82 , 7 @ @ private [ messaging ] final class ReverseHooksListener extends Actor with ActorLogg 
 } yield { 
 optToken . map { token ⇒ 
 context . actorOf ( 
 - ReverseHooksWorker . props ( groupId , token , mediator ) , 
 + ReverseHooksWorker . props ( groupId , token ) , 
 interceptorGroupId ( groupId ) 
 ) 
 ( ) 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksWorker . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksWorker . scala 
 index c93b007 . . 26b9225 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksWorker . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / ReverseHooksWorker . scala 
 @ @ - 13 , 10 + 13 , 10 @ @ import com . google . protobuf . CodedInputStream 
 import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport 
 import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage } 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 - import im . actor . server . office . EntityNotFound 
 - import im . actor . server . { KeyValueMappings , model } 
 import im . actor . server . model . PeerType . { Group , Private } 
 - import im . actor . server . user . { UserExtension , UserOffice , UserViewRegion } 
 + import im . actor . server . pubsub . { PeerMessage , PubSubExtension } 
 + import im . actor . server . user . UserExtension 
 + import im . actor . server . { KeyValueMappings , model } 
 import im . actor . util . log . AnyRefLogSource 
 import play . api . libs . json . { Format , Json } 
 import shardakka . ShardakkaExtension 
 @ @ - 28 , 7 + 28 , 7 @ @ import scala . util . { Failure , Success } 
 object ReverseHooksWorker { 
 private [ messaging ] case object Resubscribe 
 
 - def props ( groupId : Int , token : String , mediator : ActorRef ) = Props ( classOf [ ReverseHooksWorker ] , groupId , token , mediator ) 
 + def props ( groupId : Int , token : String ) = Props ( classOf [ ReverseHooksWorker ] , groupId , token ) 
 
 private [ messaging ] def interceptorGroupId ( groupId : Int ) : String = s " group - $ groupId " 
 
 @ @ - 37 , 7 + 37 , 7 @ @ object ReverseHooksWorker { 
 implicit val format : Format [ MessageToWebhook ] = Json . format [ MessageToWebhook ] 
 } 
 
 - private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String , mediator : ActorRef ) 
 + private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String ) 
 extends Actor 
 with ActorLogging 
 with AnyRefLogSource 
 @ @ - 54 , 6 + 54 , 7 @ @ private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String , m 
 private [ this ] val scheduledResubscribe = system . scheduler . schedule ( Duration . Zero , 1 . minute , self , Resubscribe ) 
 private [ this ] val reverseHooksKv = ShardakkaExtension ( system ) . simpleKeyValue ( KeyValueMappings . ReverseHooks + " _ " + token ) 
 private [ this ] val http : HttpExt = Http ( ) 
 + private [ this ] val pubSubExt = PubSubExtension ( system ) 
 
 override val log = Logging ( system , this ) 
 
 @ @ - 61 , 7 + 62 , 7 @ @ private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String , m 
 
 def init : Receive = { 
 case Resubscribe ⇒ 
 - mediator ! Subscribe ( MessagingService . messagesTopic ( ApiPeer ( ApiPeerType . Group , groupId ) ) , None , self ) 
 + pubSubExt . subscribe ( Subscribe ( pubSubExt . messagesTopic ( ApiPeer ( ApiPeerType . Group , groupId ) ) , None , self ) ) 
 case SubscribeAck ( Subscribe ( topic , _ , _ ) ) ⇒ 
 log . debug ( " Watching for group ' s { } reverse hooks " , groupId ) 
 scheduledResubscribe . cancel ( ) 
 @ @ - 69 , 7 + 70 , 7 @ @ private [ messaging ] final class ReverseHooksWorker ( groupId : Int , token : String , m 
 } 
 
 def working : Receive = { 
 - case Events . PeerMessage ( from , _ , _ , _ , message ) ⇒ 
 + case PeerMessage ( from , _ , _ , _ , message ) ⇒ 
 log . debug ( " Got message from group { } , peer { } to forward to webhook " , groupId , from ) 
 val parsed = ApiMessage . parseFrom ( CodedInputStream . newInstance ( message . toByteArray ) ) 
 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 index 936a6e0 . . 9003172 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . session 
 import java . util . concurrent . TimeUnit 
 
 import akka . actor . _ 
 + import akka . cluster . pubsub . DistributedPubSubMediator . { SubscribeAck , Subscribe } 
 import akka . cluster . sharding . ShardRegion . Passivate 
 import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } 
 - import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } 
 import akka . pattern . pipe 
 import akka . stream . { ClosedShape , Materializer } 
 import akka . stream . actor . _ 
 @ @ - 17 , 6 + 17 , 7 @ @ import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec 
 import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . mtproto . transport . { Drop , MTPackage } 
 import im . actor . server . persist . { AuthSessionRepo , AuthIdRepo } 
 + import im . actor . server . pubsub . PubSubExtension 
 import im . actor . server . user . { AuthEvents , UserExtension } 
 import scodec . DecodeResult 
 import scodec . bits . BitVector 
 @ @ - 84 , 7 + 85 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 
 implicit val ec : ExecutionContext = context . dispatcher 
 
 - private val mediator : ActorRef = DistributedPubSub ( context . system ) . mediator 
 + private val pubSubExt = PubSubExtension ( context . system ) 
 private val db : Database = DbExtension ( context . system ) . db 
 
 private [ this ] var authData : Option [ AuthData ] = None 
 @ @ - 126 , 11 + 127 , 12 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 
 unstashAll ( ) 
 
 - val subscribe = DistributedPubSubMediator . Subscribe ( UserExtension ( context . system ) . authIdTopic ( authId ) , self ) 
 - mediator ! subscribe 
 + val subscribe = Subscribe ( UserExtension ( context . system ) . authIdTopic ( authId ) , self ) 
 + 
 + pubSubExt . subscribe ( subscribe ) 
 
 val waiting : Receive = { 
 - case msg if msg = = DistributedPubSubMediator . SubscribeAck ( subscribe ) ⇒ 
 + case SubscribeAck ( ` subscribe ` ) ⇒ 
 unstashAll ( ) 
 context . become ( anonymous ) 
 case msg ⇒ 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 index 348955b . . 4a394d6 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 @ @ - 12 , 7 + 12 , 7 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiUserOutPeer } 
 import im . actor . server . _ 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 - import im . actor . server . api . rpc . service . messaging . Events 
 + import im . actor . server . pubsub . PeerMessage 
 
 import scala . concurrent . Future 
 import scala . util . Random 
 @ @ - 305 , 8 + 305 , 8 @ @ class MessagingServiceSpec 
 } 
 
 whenReady ( service . handleSendMessage ( user2Peer , Random . nextLong ( ) , ApiTextMessage ( " Hi PubSub " , Vector . empty , None ) ) ) { resp ⇒ 
 - probe . expectMsgClass ( classOf [ Events . PeerMessage ] ) 
 - probe . expectMsgClass ( classOf [ Events . PeerMessage ] ) 
 + probe . expectMsgClass ( classOf [ PeerMessage ] ) 
 + probe . expectMsgClass ( classOf [ PeerMessage ] ) 
 } 
 } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - cqrs / src / main / protobuf / user . proto b / actor - server / actor - cqrs / src / main / protobuf / user . proto 
 index b80d0d7 . . b080172 100644 
 - - - a / actor - server / actor - cqrs / src / main / protobuf / user . proto 
 + + + b / actor - server / actor - cqrs / src / main / protobuf / user . proto 
 @ @ - 308 , 5 + 308 , 4 @ @ message UserEvents { 
 
 optional Avatar avatar = 1 ; 
 } 
 - } 
 - 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / ApplePushManager . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / ApplePushManager . scala 
 index b6e0328 . . 9e60253 100644 
 - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / ApplePushManager . scala 
 + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / ApplePushManager . scala 
 @ @ - 1 , 11 + 1 , 20 @ @ 
 package im . actor . server . push 
 
 + import java . util 
 + 
 import scala . collection . JavaConversions . _ 
 + import scala . concurrent . ExecutionContext 
 + import scala . concurrent . duration . _ 
 
 import akka . actor . ActorSystem 
 + import akka . util . Timeout 
 import com . relayrides . pushy . apns . _ 
 import com . relayrides . pushy . apns . util . { SSLContextUtil , SimpleApnsPushNotification } 
 import com . typesafe . config . Config 
 + import im . actor . server . db . ActorPostgresDriver . api . _ 
 + 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . user . { UserProcessorRegion , UserExtension , UserOffice } 
 
 case class ApplePushManagerConfig ( certs : List [ ApnsCert ] , isSandbox : Boolean ) 
 
 @ @ - 27 , 7 + 36 , 9 @ @ object ApnsCert { 
 } 
 } 
 
 - class ApplePushManager ( config : ApplePushManagerConfig , actorSystem : ActorSystem ) { 
 + class ApplePushManager ( config : ApplePushManagerConfig , system : ActorSystem ) { 
 + private implicit val ec : ExecutionContext = system . dispatcher 
 + 
 private val managers : Map [ Int , PushManager [ SimpleApnsPushNotification ] ] = 
 config . certs . map { cert ⇒ 
 val env = config . isSandbox match { 
 @ @ - 44 , 7 + 55 , 12 @ @ class ApplePushManager ( config : ApplePushManagerConfig , actorSystem : ActorSystem ) 
 new PushManagerConfiguration ( ) , 
 s " ActorPushManager - $ { cert . key } " 
 ) 
 - mgr . registerRejectedNotificationListener ( new LoggingRejectedNotificationListener ( actorSystem ) ) 
 + mgr . registerRejectedNotificationListener ( new LoggingRejectedNotificationListener ( system ) ) 
 + mgr . registerExpiredTokenListener ( new CleanExpiredTokenListener ( system ) ) 
 + 
 + system . scheduler . schedule ( 0 . seconds , 1 . hour ) { 
 + mgr . requestExpiredTokens ( ) 
 + } 
 
 mgr . start ( ) 
 
 @ @ - 55 , 8 + 71 , 36 @ @ class ApplePushManager ( config : ApplePushManagerConfig , actorSystem : ActorSystem ) 
 managers . get ( key ) 
 } 
 
 - private class LoggingRejectedNotificationListener ( actorSystem : ActorSystem ) extends RejectedNotificationListener [ SimpleApnsPushNotification ] { 
 + private class LoggingRejectedNotificationListener ( _ system : ActorSystem ) extends RejectedNotificationListener [ SimpleApnsPushNotification ] { 
 + private implicit val system : ActorSystem = _ system 
 + private implicit val ec : ExecutionContext = _ system . dispatcher 
 + 
 override def handleRejectedNotification ( pushManager : PushManager [ _ < : SimpleApnsPushNotification ] , notification : SimpleApnsPushNotification , rejectionReason : RejectedNotificationReason ) : Unit = { 
 - actorSystem . log . warning ( " { } was rejected with rejection reason { } " , notification , rejectionReason ) 
 + system . log . warning ( " APNS rejected notification with reason : { } " , rejectionReason ) 
 + 
 + if ( rejectionReason . getErrorCode = = RejectedNotificationReason . INVALID _ TOKEN . getErrorCode ) { 
 + system . log . warning ( " Deleting token " ) 
 + SeqUpdatesManager . deleteApplePushToken ( notification . getToken ) 
 + } 
 } 
 } 
 + 
 + private class CleanExpiredTokenListener ( _ system : ActorSystem ) extends ExpiredTokenListener [ SimpleApnsPushNotification ] { 
 + private implicit val system : ActorSystem = _ system 
 + private implicit val ec : ExecutionContext = _ system . dispatcher 
 + private implicit val timeout : Timeout = Timeout ( 20 . seconds ) 
 + private implicit val db : Database = DbExtension ( _ system ) . db 
 + private implicit val userProcessorRegion : UserProcessorRegion = UserExtension ( _ system ) . processorRegion 
 + 
 + override def handleExpiredTokens ( 
 + pushManager : PushManager [ _ < : SimpleApnsPushNotification ] , 
 + expiredTokens : util . Collection [ ExpiredToken ] 
 + ) : Unit = { 
 + expiredTokens foreach { t ⇒ 
 + system . log . warning ( " APNS reported expired token , loggint out " ) 
 + UserOffice . logoutByAppleToken ( t . getToken ) 
 + } 
 + 
 + } 
 + 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 index 9db2df3 . . 954ce48 100644 
 - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 @ @ - 14 , 6 + 14 , 7 @ @ import slick . dbio . DBIO 
 import im . actor . api . rpc . messaging . UpdateMessage 
 import im . actor . api . rpc . peers . Peer 
 import im . actor . api . { rpc ⇒ api } 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . models . sequence 
 import im . actor . server . sequence . SeqState 
 import im . actor . server . user . { UserOffice , UserViewRegion } 
 @ @ - 306 , 6 + 307 , 16 @ @ object SeqUpdatesManager { 
 ext . region . ref ! Envelope ( authId , PushCredentialsUpdated ( None ) ) 
 } 
 
 + def deleteApplePushToken ( token : Array [ Byte ] ) ( implicit ec : ExecutionContext , system : ActorSystem ) : Unit = { 
 + val seqRegion = SeqUpdatesExtension ( system ) . region 
 + 
 + DbExtension ( system ) . db . run ( p . push . ApplePushCredentials . findByToken ( token ) ) foreach { creds ⇒ 
 + creds foreach { c ⇒ 
 + seqRegion . ref ! Envelope ( c . authId , DeletePushCredentials ( Some ( c ) ) ) 
 + } 
 + } 
 + } 
 + 
 def getDifference ( authId : Long , timestamp : Long , maxSizeInBytes : Long ) ( implicit ec : ExecutionContext ) : DBIO [ ( Vector [ models . sequence . SeqUpdate ] , Boolean ) ] = { 
 def run ( state : Long , acc : Vector [ models . sequence . SeqUpdate ] , currentSize : Long ) : DBIO [ ( Vector [ models . sequence . SeqUpdate ] , Boolean ) ] = { 
 p . sequence . SeqUpdate . findAfter ( authId , state ) . flatMap { updates ⇒ 
 diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala 
 index 24abc6d . . 21f04d6 100644 
 - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala 
 + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala 
 @ @ - 1 , 9 + 1 , 7 @ @ 
 package im . actor . server . push 
 
 - import java . nio . ByteBuffer 
 import java . util . concurrent . TimeUnit 
 
 - import scala . concurrent . { Future , ExecutionContext } 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 import scala . util . { Failure , Success } 
 @ @ - 11 , 7 + 9 , 6 @ @ import scala . util . { Failure , Success } 
 import akka . actor . _ 
 import akka . contrib . pattern . ShardRegion 
 import akka . pattern . pipe 
 - import com . github . tototoshi . slick . PostgresJodaSupport . _ 
 import com . google . protobuf . ByteString 
 
 import im . actor . api . rpc . UpdateBox 
 @ @ - 69 , 6 + 66 , 9 @ @ object SeqUpdatesManagerMessages { 
 case class PushCredentialsUpdated ( credsOpt : Option [ models . push . PushCredentials ] ) extends Message 
 
 @ SerialVersionUID ( 1L ) 
 + case class DeletePushCredentials ( credsOpt : Option [ models . push . PushCredentials ] ) extends Message 
 + 
 + @ SerialVersionUID ( 1L ) 
 case class UpdateReceived ( update : UpdateBox ) 
 } 
 
 @ @ - 158 , 6 + 158 , 19 @ @ private final class SeqUpdatesManagerActor ( 
 appleCredsOpt = None 
 db . run ( deletePushCredentials ( authId ) ) 
 } 
 + case DeletePushCredentials ( credsOpt ) ⇒ 
 + credsOpt match { 
 + case c @ Some ( _ ) if c = = appleCredsOpt ⇒ 
 + log . warning ( " Deleting apple push creds " ) 
 + appleCredsOpt = None 
 + db . run ( deletePushCredentials ( authId ) ) 
 + case c @ Some ( _ ) if c = = googleCredsOpt ⇒ 
 + log . warning ( " Deleting google push creds " ) 
 + googleCredsOpt = None 
 + db . run ( deletePushCredentials ( authId ) ) 
 + case None ⇒ 
 + / / ignoring , already deleted 
 + } 
 case ReceiveTimeout ⇒ 
 if ( consumers . isEmpty ) { 
 context . parent ! Passivate ( stopMessage = PoisonPill ) 
 diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / AuthCommands . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / AuthCommands . scala 
 new file mode 100644 
 index 0000000 . . bf3fb95 
 - - - / dev / null 
 + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / AuthCommands . scala 
 @ @ - 0 , 0 + 1 , 78 @ @ 
 + package im . actor . server . user 
 + 
 + import scala . concurrent . { Future , ExecutionContext } 
 + 
 + import akka . actor . { ActorRef , ActorSystem } 
 + import akka . contrib . pattern . DistributedPubSubExtension 
 + import akka . pattern . ask 
 + import akka . util . Timeout 
 + 
 + import im . actor . server . db . ActorPostgresDriver . api . _ 
 + 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . push . { SeqUpdatesExtension , SeqUpdatesManager } 
 + import im . actor . server . { models , persist ⇒ p } 
 + 
 + trait AuthEvent 
 + 
 + object AuthEvents { 
 + case object AuthIdInvalidated 
 + } 
 + 
 + trait AuthCommands { 
 + self : Queries ⇒ 
 + 
 + import UserCommands . _ 
 + import akka . contrib . pattern . DistributedPubSubMediator . _ 
 + 
 + def authIdTopic ( authId : Long ) : String = s " auth . events . $ { authId } " 
 + 
 + def auth ( userId : Int , authId : Long ) ( 
 + implicit 
 + userOfficeRegion : UserProcessorRegion , 
 + timeout : Timeout , 
 + ec : ExecutionContext 
 + ) : Future [ NewAuthAck ] = { 
 + ( userOfficeRegion . ref ? NewAuth ( userId , authId ) ) . mapTo [ NewAuthAck ] 
 + } 
 + 
 + def removeAuth ( userId : Int , authId : Long ) ( 
 + implicit 
 + userOfficeRegion : UserProcessorRegion , 
 + timeout : Timeout , 
 + ec : ExecutionContext 
 + 
 + ) : Future [ RemoveAuthAck ] = ( userOfficeRegion . ref ? RemoveAuth ( userId , authId ) ) . mapTo [ RemoveAuthAck ] 
 + 
 + def logoutByAppleToken ( token : Array [ Byte ] ) ( implicit ec : ExecutionContext , system : ActorSystem , timeout : Timeout , db : Database , userProcessorRegion : UserProcessorRegion ) : Future [ Unit ] = { 
 + db . run ( p . push . ApplePushCredentials . findByToken ( token ) ) flatMap { creds ⇒ 
 + Future . sequence ( creds map ( c ⇒ logout ( c . authId ) ) ) map ( _ ⇒ ( ) ) 
 + } 
 + } 
 + 
 + def logout ( authId : Long ) ( implicit ec : ExecutionContext , system : ActorSystem , timeout : Timeout , db : Database , userProcessorRegion : UserProcessorRegion ) : Future [ Unit ] = { 
 + db . run ( p . AuthSession . findByAuthId ( authId ) ) flatMap { 
 + case Some ( session ) ⇒ logout ( session ) 
 + case None ⇒ throw new Exception ( " Can ' t find auth session to logout " ) 
 + } 
 + } 
 + 
 + def logout ( session : models . AuthSession ) ( implicit ec : ExecutionContext , system : ActorSystem , timeout : Timeout , db : Database , userProcessorRegion : UserProcessorRegion ) : Future [ Unit ] = { 
 + system . log . debug ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) 
 + 
 + implicit val seqExt = SeqUpdatesExtension ( system ) 
 + val mediator = DistributedPubSubExtension ( system ) . mediator 
 + 
 + for { 
 + _ ← removeAuth ( session . userId , session . authId ) 
 + _ ← db . run ( p . AuthSession . delete ( session . userId , session . id ) ) 
 + _ = SeqUpdatesManager . deletePushCredentials ( session . authId ) 
 + } yield { 
 + publishAuthIdInvalidated ( mediator , session . authId ) 
 + } 
 + } 
 + 
 + private def publishAuthIdInvalidated ( mediator : ActorRef , authId : Long ) : Unit = { 
 + mediator ! Publish ( authIdTopic ( authId ) , AuthEvents . AuthIdInvalidated ) 
 + } 
 + } 
 diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserOffice . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserOffice . scala 
 index 8c0e2a4 . . f92420b 100644 
 - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserOffice . scala 
 + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserOffice . scala 
 @ @ - 15 , 7 + 15 , 9 @ @ import im . actor . api . rpc . messaging . { Message ⇒ ApiMessage } 
 import im . actor . api . rpc . peers . Peer 
 import im . actor . api . rpc . users . { User ⇒ ApiUser } 
 import im . actor . server . db . ActorPostgresDriver . api . _ 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . file . Avatar 
 + import im . actor . server . { models , persist } 
 import im . actor . server . push . SeqUpdatesManagerMessages . { FatMetaData , FatData } 
 import im . actor . server . push . { SeqUpdatesExtension , SeqUpdatesManager , SeqUpdatesManagerRegion } 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 @ @ - 28 , 8 + 30 , 8 @ @ object UserOffice extends Commands with Queries { 
 def persistenceIdFor ( userId : Int ) : String = s " User - $ { userId } " 
 } 
 
 - private [ user ] sealed trait Commands { 
 - this : Queries ⇒ 
 + private [ user ] sealed trait Commands extends AuthCommands { 
 + self : Queries ⇒ 
 
 import UserCommands . _ 
 
 @ @ - 87 , 23 + 89 , 6 @ @ private [ user ] sealed trait Commands { 
 ( userOfficeRegion . ref ? ChangeName ( userId , name ) ) . mapTo [ SeqState ] 
 } 
 
 - def auth ( userId : Int , authId : Long ) ( 
 - implicit 
 - userOfficeRegion : UserProcessorRegion , 
 - timeout : Timeout , 
 - ec : ExecutionContext 
 - ) : Future [ NewAuthAck ] = { 
 - ( userOfficeRegion . ref ? NewAuth ( userId , authId ) ) . mapTo [ NewAuthAck ] 
 - } 
 - 
 - def removeAuth ( userId : Int , authId : Long ) ( 
 - implicit 
 - userOfficeRegion : UserProcessorRegion , 
 - timeout : Timeout , 
 - ec : ExecutionContext 
 - 
 - ) : Future [ RemoveAuthAck ] = ( userOfficeRegion . ref ? RemoveAuth ( userId , authId ) ) . mapTo [ RemoveAuthAck ] 
 - 
 def sendMessage ( userId : Int , senderUserId : Int , senderAuthId : Long , accessHash : Long , randomId : Long , message : ApiMessage ) ( 
 implicit 
 peerManagerRegion : UserProcessorRegion , 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / push / ApplePushCredentials . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / push / ApplePushCredentials . scala 
 index 6dd674a . . bb45119 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / push / ApplePushCredentials . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / push / ApplePushCredentials . scala 
 @ @ - 19 , 6 + 19 , 8 @ @ class ApplePushCredentialsTable ( tag : Tag ) extends Table [ models . push . ApplePushCre 
 object ApplePushCredentials { 
 val creds = TableQuery [ ApplePushCredentialsTable ] 
 
 + def byToken ( token : Array [ Byte ] ) = creds . filter ( _ . token = = = token ) 
 + 
 def createOrUpdate ( authId : Long , apnsKey : Int , token : Array [ Byte ] ) ( implicit ec : ExecutionContext ) = { 
 for { 
 _ ← creds . filterNot ( _ . authId = = = authId ) . filter ( c ⇒ c . apnsKey = = = apnsKey & & c . token = = = token ) . delete 
 @ @ - 38 , 6 + 40 , 9 @ @ object ApplePushCredentials { 
 def delete ( authId : Long ) = 
 creds . filter ( _ . authId = = = authId ) . delete 
 
 + def findByToken ( token : Array [ Byte ] ) = 
 + byToken ( token ) . result 
 + 
 def deleteByToken ( token : Array [ Byte ] ) = 
 - creds . filter ( _ . token = = = token ) . delete 
 + byToken ( token ) . delete 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 index 8b088c1 . . e2da841 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 @ @ - 3 , 31 + 3 , 25 @ @ package im . actor . server . api . rpc . service . auth 
 import java . time . { LocalDateTime , ZoneOffset } 
 
 import scala . concurrent . Future 
 - import scala . concurrent . duration . _ 
 import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scalaz . { - \ / , \ / , \ / - } 
 
 import akka . actor . ActorSystem 
 import akka . pattern . ask 
 - import akka . util . Timeout 
 - import org . joda . time . DateTime 
 import slick . dbio 
 import slick . dbio . Effect . Write 
 import slick . dbio . _ 
 
 import im . actor . api . rpc . DBIOResult . _ 
 import im . actor . api . rpc . _ 
 - import im . actor . api . rpc . contacts . UpdateContactRegistered 
 import im . actor . api . rpc . users . Sex . _ 
 import im . actor . server . activation . Activation . { EmailCode , SmsCode } 
 import im . actor . server . activation . _ 
 import im . actor . server . models . { AuthEmailTransaction , AuthPhoneTransaction , User } 
 import im . actor . server . persist . auth . AuthTransaction 
 import im . actor . server . push . SeqUpdatesManager . _ 
 - import im . actor . server . push . SeqUpdatesManagerRegion 
 import im . actor . server . session . _ 
 - import im . actor . server . social . SocialManager . _ 
 - import im . actor . server . user . { UserProcessorRegion , UserOffice } 
 + import im . actor . server . user . UserOffice 
 import im . actor . server . util . IdUtils . _ 
 import im . actor . server . util . PhoneNumberUtils . _ 
 import im . actor . server . util . StringUtils . validName 
 @ @ - 137 , 7 + 131 , 7 @ @ trait AuthHelpers extends Helpers { 
 protected def refreshAuthSession ( deviceHash : Array [ Byte ] , newSession : models . AuthSession ) : DBIO [ Unit ] = 
 for { 
 prevSessions ← persist . AuthSession . findByDeviceHash ( deviceHash ) 
 - _ ← DBIO . sequence ( prevSessions map logout ) 
 + _ ← DBIO . from ( Future . sequence ( prevSessions map UserOffice . logout ) ) 
 _ ← persist . AuthSession . create ( newSession ) 
 } yield ( ) 
 
 @ @ - 162 , 18 + 156 , 6 @ @ trait AuthHelpers extends Helpers { 
 } yield user 
 } 
 
 - protected def logout ( session : models . AuthSession ) ( implicit system : ActorSystem , m : PubSubMediator ) : dbio . DBIOAction [ Unit , NoStream , Write with Write ] = { 
 - system . log . debug ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) 
 - 
 - for { 
 - _ ← DBIO . from ( UserOffice . removeAuth ( session . userId , session . authId ) ) 
 - _ ← persist . AuthSession . delete ( session . userId , session . id ) 
 - _ = deletePushCredentials ( session . authId ) 
 - } yield { 
 - AuthService . publishAuthIdInvalidated ( m . mediator , session . authId ) 
 - } 
 - } 
 - 
 protected def sendSmsCode ( phoneNumber : Long , code : String , transactionHash : Option [ String ] ) ( implicit system : ActorSystem ) : DBIO [ String \ / Unit ] = { 
 log . info ( " Sending code { } to { } " , code , phoneNumber ) 
 activationContext . send ( transactionHash , SmsCode ( phoneNumber , code ) ) 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 index d10eaab . . 123f990 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 @ @ - 33 , 25 + 33 , 6 @ @ import im . actor . server . user . { UserViewRegion , UserExtension , UserOffice , UserPro 
 import im . actor . server . util . _ 
 import im . actor . server . { persist , models } 
 
 - sealed trait AuthEvent 
 - 
 - object AuthEvents { 
 - case object AuthIdInvalidated extends AuthEvent 
 - } 
 - 
 - object AuthService { 
 - 
 - import akka . contrib . pattern . DistributedPubSubMediator . _ 
 - 
 - import AuthEvents . _ 
 - 
 - def authIdTopic ( authId : Long ) : String = s " auth . events . $ { authId } " 
 - 
 - private [ auth ] def publishAuthIdInvalidated ( mediator : ActorRef , authId : Long ) : Unit = { 
 - mediator ! Publish ( authIdTopic ( authId ) , AuthIdInvalidated ) 
 - } 
 - } 
 - 
 case class PubSubMediator ( mediator : ActorRef ) 
 
 class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) ( 
 @ @ - 290 , 7 + 271 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) 
 val action = requireAuth ( clientData ) map { implicit client ⇒ 
 persist . AuthSession . findByAuthId ( client . authId ) flatMap { 
 case Some ( session ) ⇒ 
 - for ( _ ← logout ( session ) ) yield Ok ( misc . ResponseVoid ) 
 + for ( _ ← DBIO . from ( UserOffice . logout ( session ) ) ) yield Ok ( misc . ResponseVoid ) 
 case None ⇒ throw new Exception ( s " Cannot find AuthSession for authId : $ { client . authId } " ) 
 } 
 } 
 @ @ - 302 , 7 + 283 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) 
 val authorizedAction = requireAuth ( clientData ) . map { client ⇒ 
 for { 
 sessions ← persist . AuthSession . findByUserId ( client . userId ) map ( _ . filterNot ( _ . authId = = client . authId ) ) 
 - _ ← DBIO . sequence ( sessions map logout ) 
 + _ ← DBIO . from ( Future . sequence ( sessions map UserOffice . logout ) ) 
 } yield { 
 Ok ( ResponseVoid ) 
 } 
 @ @ - 315 , 7 + 296 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) 
 val authorizedAction = requireAuth ( clientData ) . map { client ⇒ 
 persist . AuthSession . find ( client . userId , id ) . headOption flatMap { 
 case Some ( session ) ⇒ 
 - for ( _ ← logout ( session ) ) yield Ok ( ResponseVoid ) 
 + for ( _ ← DBIO . from ( UserOffice . logout ( session ) ) ) yield Ok ( ResponseVoid ) 
 case None ⇒ 
 DBIO . successful ( Error ( AuthErrors . AuthSessionNotFound ) ) 
 } 
 @ @ - 490 , 7 + 471 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) 
 
 for { 
 prevSessions ← persist . AuthSession . findByDeviceHash ( deviceHash ) 
 - _ ← DBIO . sequence ( prevSessions map logout ) 
 + _ ← DBIO . from ( Future . sequence ( prevSessions map UserOffice . logout ) ) 
 _ ← persist . AuthSession . create ( authSession ) 
 userStruct ← DBIO . from ( UserOffice . getApiStruct ( user . id , user . id , clientData . authId ) ) 
 } yield { 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 index 5d1b0b9 . . 5910bb9 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 @ @ - 19 , 13 + 19 , 13 @ @ import scodec . bits . BitVector 
 import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . api . rpc . ClientData 
 - import im . actor . server . api . rpc . service . auth . { AuthEvents , AuthService } 
 import im . actor . server . db . DbExtension 
 import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec 
 import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . mtproto . transport . { Drop , MTPackage } 
 import im . actor . server . presences . { GroupPresenceManagerRegion , PresenceManagerRegion } 
 - import im . actor . server . push . { SeqUpdatesExtension , SeqUpdatesManagerRegion , WeakUpdatesManagerRegion } 
 + import im . actor . server . push . { SeqUpdatesExtension , WeakUpdatesManagerRegion } 
 + import im . actor . server . user . { UserOffice , AuthEvents } 
 import im . actor . server . { models , persist } 
 
 case class SessionConfig ( idleTimeout : Duration , reSendConfig : ReSenderConfig ) 
 @ @ - 117 , 7 + 117 , 7 @ @ class Session ( mediator : ActorRef ) ( 
 val replyTo = sender ( ) 
 stash ( ) 
 
 - val subscribe = DistributedPubSubMediator . Subscribe ( AuthService . authIdTopic ( authId ) , self ) 
 + val subscribe = DistributedPubSubMediator . Subscribe ( UserOffice . authIdTopic ( authId ) , self ) 
 mediator ! subscribe 
 
 context . become ( waitingForSessionInfo ( authId , sessionId , subscribe ) ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 index 4676b00 . . d2b5007 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 @ @ - 138 , 7 + 138 , 7 @ @ class MessagingServiceSpec 
 resps foreach ( _ should matchPattern { case Ok ( ResponseSeqDate ( 1000 , _ , _ ) ) ⇒ } ) 
 } 
 
 - expectUpdate [ UpdateMessageSent ] ( 0 , Array . empty , UpdateMessageSent . header , Some ( 1 ) ) ( identity ) 
 + expectUpdate [ UpdateMessageSent ] ( 0 , Array . empty , UpdateMessageSent . header , Some ( 1 ) ) ( identity ) 
 } 
 
 { 
 @ @ - 275 , 7 + 275 , 7 @ @ class MessagingServiceSpec 
 resps foreach ( _ should matchPattern { case Ok ( ResponseSeqDate ( 1002 , _ , _ ) ) ⇒ } ) 
 } 
 
 - expectUpdate [ UpdateMessageSent ] ( 0 , Array . empty , UpdateMessageSent . header ) ( identity ) 
 + expectUpdate [ UpdateMessageSent ] ( 0 , Array . empty , UpdateMessageSent . header ) ( identity ) 
 } 
 
 { 
 diff - - git a / actor - server / actor - utils / src / main / scala / im / actor / server / util / UserUtils . scala b / actor - server / actor - utils / src / main / scala / im / actor / server / util / UserUtils . scala 
 index c5a3c0b . . 4459dd1 100644 
 - - - a / actor - server / actor - utils / src / main / scala / im / actor / server / util / UserUtils . scala 
 + + + b / actor - server / actor - utils / src / main / scala / im / actor / server / util / UserUtils . scala 
 @ @ - 11 , 6 + 11 , 7 @ @ import slick . profile . SqlAction 
 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . users . _ 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . models . UserPhone 
 import im . actor . server . { models , persist }
