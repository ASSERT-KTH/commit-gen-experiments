BLEU SCORE: 0.17542198478193427

TEST MSG: fix ( server : session ) : fixed idle session killing
GENERATED MSG: fix ( server ) : adoption to the new streams api

TEST DIFF (one line): diff - - git a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / TcpFrontend . scala b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / TcpFrontend . scala < nl > index 3513e93 . . 59a1968 100644 < nl > - - - a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / TcpFrontend . scala < nl > + + + b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / TcpFrontend . scala < nl > @ @ - 29 , 6 + 29 , 5 @ @ object TcpFrontend extends Frontend ( " tcp " ) { < nl > ( tlsContext map ( Tls . connection ( _ , flow ) ) getOrElse flow ) . joinMat ( mtProto ) ( Keep . right ) . run ( ) < nl > } ) < nl > . run ( ) < nl > - < nl > } < nl > } < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / IdleControl . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / IdleControl . scala < nl > new file mode 100644 < nl > index 0000000 . . a92fa79 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / IdleControl . scala < nl > @ @ - 0 , 0 + 1 , 30 @ @ < nl > + package im . actor . server . session < nl > + < nl > + import akka . actor . _ < nl > + < nl > + import scala . concurrent . duration . Duration < nl > + < nl > + object IdleControl { < nl > + case object KeepAlive < nl > + < nl > + def apply ( timeout : Duration ) ( implicit factory : ActorRefFactory ) = < nl > + new IdleControl ( factory . actorOf ( props ( timeout ) , " idle - control " ) ) < nl > + < nl > + private def props ( timeout : Duration ) = Props ( classOf [ IdleControlActor ] , timeout ) < nl > + } < nl > + < nl > + final case class IdleControl ( val ref : ActorRef ) { < nl > + def keepAlive ( ) : Unit = ref ! IdleControl . KeepAlive < nl > + } < nl > + < nl > + private final class IdleControlActor ( timeout : Duration ) extends Actor { < nl > + import IdleControl . _ < nl > + < nl > + context . setReceiveTimeout ( timeout ) < nl > + < nl > + def receive = { < nl > + case KeepAlive ⇒ < nl > + case ReceiveTimeout ⇒ < nl > + context . parent ! ReceiveTimeout < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > index 373271c . . 875c823 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > @ @ - 82 , 13 + 82 , 19 @ @ object Session { < nl > private case object AuthIdInvalid < nl > } < nl > < nl > - final private class Session ( implicit config : SessionConfig , materializer : Materializer ) extends Actor with ActorLogging with MessageIdHelper with Stash { < nl > + final private class Session ( implicit config : SessionConfig , materializer : Materializer ) < nl > + extends Actor < nl > + with ActorLogging < nl > + with MessageIdHelper < nl > + with Stash { < nl > < nl > implicit val ec : ExecutionContext = context . dispatcher < nl > < nl > private val pubSubExt = PubSubExtension ( context . system ) < nl > private val db : Database = DbExtension ( context . system ) . db < nl > < nl > + private val idleControl = IdleControl ( config . idleTimeout ) < nl > + < nl > private [ this ] var authData : Option [ AuthData ] = None < nl > private [ this ] var clients = immutable . Set . empty [ ActorRef ] < nl > < nl > @ @ - 100 , 8 + 106 , 6 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > throw e < nl > } < nl > < nl > - context . setReceiveTimeout ( config . idleTimeout ) < nl > - < nl > db . run ( AuthIdRepo . find ( authId ) flatMap { < nl > case Some ( _ ) ⇒ < nl > AuthSessionRepo . findByAuthId ( authId ) map { < nl > @ @ - 159 , 6 + 163 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > < nl > def anonymous : Receive = { < nl > case HandleMessageBox ( messageBoxBytes ) ⇒ < nl > + idleControl . keepAlive ( ) < nl > recordClient ( sender ( ) ) < nl > < nl > withValidMessageBox ( messageBoxBytes . toByteArray ) { mb ⇒ < nl > @ @ - 199 , 12 + 204 , 14 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > < nl > def resolved ( publisher : ActorRef , reSender : ActorRef ) : Receive = { < nl > case HandleMessageBox ( messageBoxBytes ) ⇒ < nl > + idleControl . keepAlive ( ) < nl > recordClient ( sender ( ) ) < nl > < nl > withValidMessageBox ( messageBoxBytes . toByteArray ) { mb ⇒ < nl > publisher ! Tuple2 ( mb , ClientData ( authId , sessionId , authData ) ) < nl > } < nl > case cmd : SubscribeCommand ⇒ < nl > + idleControl . keepAlive ( ) < nl > publisher ! cmd < nl > case AuthorizeUser ( userId , authSid ) ⇒ authorize ( userId , authSid , Some ( sender ( ) ) ) < nl > case internal ⇒ handleInternal ( internal , stashUnmatched = false ) < nl > @ @ - 283 , 5 + 290 , 4 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > < nl > log . error ( reason , " Session failed " ) < nl > } < nl > - < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala < nl > index 433d752 . . e4d48cb 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala < nl > @ @ - 28 , 7 + 28 , 7 @ @ import kamon . Kamon < nl > import scala . concurrent . ExecutionContext < nl > import scala . util . Random < nl > < nl > - class SimpleServerE2eSpec extends ActorSuite ( < nl > + final class SimpleServerE2eSpec extends ActorSuite ( < nl > ActorSpecification . createSystem ( ConfigFactory . parseString ( < nl > " " " < nl > | session { < nl > @ @ - 45 , 7 + 45 , 7 @ @ class SimpleServerE2eSpec extends ActorSuite ( < nl > < nl > it should " respond to big RPC requests " in Server . bigRequests < nl > < nl > - it should " notify about lost session " in Server . e3 < nl > + it should " notify about lost session " in Server . sessionLost < nl > < nl > it should " throw AuthIdInvalid if sending wrong AuthId " in Server . authIdInvalid < nl > < nl > @ @ - 60 , 7 + 60 , 7 @ @ class SimpleServerE2eSpec extends ActorSuite ( < nl > val serverConfig = system . settings . config < nl > < nl > val oauthGoogleConfig = OAuth2GoogleConfig . load ( system . settings . config . getConfig ( " services . google . oauth " ) ) < nl > - val sequenceConfig = SequenceServiceConfig . load . toOption . get < nl > + val sequenceConfig = SequenceServiceConfig . load ( ) . toOption . get < nl > < nl > implicit val sessionConfig = SessionConfig . load ( system . settings . config . getConfig ( " session " ) ) < nl > Session . startRegion ( Session . props ) < nl > @ @ - 145 , 7 + 145 , 7 @ @ class SimpleServerE2eSpec extends ActorSuite ( < nl > client . close ( ) < nl > } < nl > < nl > - def e3 ( ) = { < nl > + def sessionLost ( ) = { < nl > implicit val client = MTProtoClient ( ) < nl > < nl > client . connectAndHandshake ( remote ) < nl > @ @ - 162 , 7 + 162 , 7 @ @ class SimpleServerE2eSpec extends ActorSuite ( < nl > expectMessageAck ( helloMessageId ) < nl > } < nl > < nl > - Thread . sleep ( 3000 ) < nl > + Thread . sleep ( 5000 ) < nl > expectSessionLost ( ) < nl > < nl > {
NEAREST DIFF (one line): diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotExtension . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotExtension . scala < nl > index 72caaa2 . . d81c031 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotExtension . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotExtension . scala < nl > @ @ - 49 , 7 + 49 , 7 @ @ private [ bot ] final class BotExtension ( _ system : ActorSystem ) extends Extension { < nl > < nl > lazy val tokensKV = shardakka . simpleKeyValue ( BotExtension . tokensKV , IntCodec ) < nl > < nl > - private val globalHooksKV : SimpleKeyValue [ BotWebHook ] = shardakka . simpleKeyValue ( BotExtension . whTokensKV , BotWebHookCodec ) < nl > + private lazy val globalHooksKV : SimpleKeyValue [ BotWebHook ] = shardakka . simpleKeyValue ( BotExtension . whTokensKV , BotWebHookCodec ) < nl > < nl > private def hooksKV ( userId : UserId ) : SimpleKeyValue [ String ] = < nl > shardakka . simpleKeyValue ( BotExtension . whUserTokensKV ( userId ) ) < nl > diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala < nl > index 4e7d28a . . d3921d8 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala < nl > @ @ - 2 , 7 + 2 , 8 @ @ package im . actor . server . bot < nl > < nl > import akka . actor . ActorSystem < nl > import akka . event . Logging < nl > - import akka . stream . scaladsl . { Flow , Merge , Source } < nl > + import akka . stream . FlowShape < nl > + import akka . stream . scaladsl . _ < nl > import im . actor . api . rpc . Update < nl > import im . actor . bots . BotMessages < nl > import im . actor . server . bot . services . _ < nl > @ @ - 14 , 7 + 15 , 7 @ @ import scala . util . { Success , Failure } < nl > final class BotServerBlueprint ( botUserId : Int , botAuthId : Long , botAuthSid : Int , system : ActorSystem ) { < nl > < nl > import BotMessages . _ < nl > - import akka . stream . scaladsl . FlowGraph . Implicits . _ < nl > + < nl > import system . dispatcher < nl > < nl > private lazy val updBuilder = new BotUpdateBuilder ( botUserId , botAuthId , system ) < nl > @ @ - 42 , 16 + 43 , 20 @ @ final class BotServerBlueprint ( botUserId : Int , botAuthId : Long , botAuthSid : Int , < nl > } < nl > . map ( _ . asInstanceOf [ BotMessageOut ] ) < nl > < nl > - Flow ( ) { implicit b ⇒ < nl > - val upd = b . add ( updSource ) < nl > - val rqrsp = b . add ( rqrspFlow ) < nl > - val merge = b . add ( Merge [ BotMessageOut ] ( 2 ) ) < nl > + Flow . fromGraph ( < nl > + FlowGraph . create ( ) { implicit b ⇒ < nl > + import akka . stream . scaladsl . FlowGraph . Implicits . _ < nl > + < nl > + val upd = b . add ( updSource ) < nl > + val rqrsp = b . add ( rqrspFlow ) < nl > + val merge = b . add ( Merge [ BotMessageOut ] ( 2 ) ) < nl > < nl > - upd ~ > merge < nl > - rqrsp ~ > merge < nl > + upd ~ > merge < nl > + rqrsp ~ > merge < nl > < nl > - ( rqrsp . inlet , merge . out ) < nl > - } < nl > + FlowShape ( rqrsp . inlet , merge . out ) < nl > + } < nl > + ) < nl > } < nl > < nl > private def handleRequest ( id : Long , service : String , body : RequestBody ) : Future [ BotResponse ] = { < nl > diff - - git a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / MTProtoBlueprint . scala b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / MTProtoBlueprint . scala < nl > index 0bac5ac . . f31ebf4 100644 < nl > - - - a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / MTProtoBlueprint . scala < nl > + + + b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / MTProtoBlueprint . scala < nl > @ @ - 1 , 5 + 1 , 7 @ @ < nl > package im . actor . server . frontend < nl > < nl > + import akka . stream . FlowShape < nl > + < nl > import scala . util . { Failure , Success } < nl > < nl > import akka . actor . _ < nl > @ @ - 46 , 7 + 48 , 7 @ @ object MTProtoBlueprint { < nl > sessionClient ! PoisonPill < nl > } < nl > < nl > - Flow ( ) { implicit builder ⇒ < nl > + Flow . fromGraph ( FlowGraph . create ( ) { implicit builder ⇒ < nl > import FlowGraph . Implicits . _ < nl > < nl > val bcast = builder . add ( Broadcast [ ByteString ] ( 2 ) ) < nl > @ @ - 67 , 8 + 69 , 8 @ @ object MTProtoBlueprint { < nl > < nl > / / format : ON < nl > < nl > - ( bcast . in , mapResp . outlet ) < nl > - } < nl > + FlowShape ( bcast . in , mapResp . outlet ) < nl > + } ) < nl > } < nl > < nl > def mapResponse ( system : ActorSystem ) = new PushStage [ MTProto , ByteString ] { < nl > diff - - git a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / WsFrontend . scala b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / WsFrontend . scala < nl > index 84ba185 . . d8f7df8 100644 < nl > - - - a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / WsFrontend . scala < nl > + + + b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / WsFrontend . scala < nl > @ @ - 62 , 8 + 62 , 7 @ @ object WsFrontend extends Frontend { < nl > . collect { < nl > case msg : BinaryMessage ⇒ msg < nl > } < nl > - . map ( _ . dataStream ) < nl > - . flatten ( FlattenStrategy . concat ) < nl > + . flatMapConcat ( _ . dataStream ) < nl > . via ( mtProtoFlow ) < nl > . map { < nl > case bs ⇒ < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > index 1c7c78b . . 936a6e0 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > @ @ - 7 , 7 + 7 , 7 @ @ import akka . cluster . sharding . ShardRegion . Passivate < nl > import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } < nl > import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } < nl > import akka . pattern . pipe < nl > - import akka . stream . Materializer < nl > + import akka . stream . { ClosedShape , Materializer } < nl > import akka . stream . actor . _ < nl > import akka . stream . scaladsl . _ < nl > import com . typesafe . config . Config < nl > @ @ - 161 , 7 + 161 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > withValidMessageBox ( messageBoxBytes . toByteArray ) { mb ⇒ < nl > val graph = SessionStream . graph ( authId , sessionId , rpcHandler , updatesHandler , reSender ) < nl > < nl > - val flow = FlowGraph . closed ( graph ) { implicit b ⇒ g ⇒ < nl > + RunnableGraph . fromGraph ( FlowGraph . create ( ) { implicit b ⇒ < nl > import FlowGraph . Implicits . _ < nl > < nl > val source = b . add ( Source ( ActorPublisher [ SessionStreamMessage ] ( sessionMessagePublisher ) ) ) < nl > @ @ - 170 , 7 + 170 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > < nl > / / format : OFF < nl > < nl > - source ~ > g ~ > bcast ~ > sink < nl > + source ~ > graph ~ > bcast ~ > sink < nl > bcast ~ > Sink . onComplete { c ⇒ < nl > c . failed foreach { e = > < nl > log . error ( e , " Dying due to stream error " ) ; < nl > @ @ - 179 , 9 + 179 , 9 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > } < nl > < nl > / / format : ON < nl > - } < nl > < nl > - flow . run ( ) < nl > + ClosedShape < nl > + } ) . run ( ) < nl > < nl > sessionMessagePublisher ! SessionStreamMessage . SendProtoMessage ( NewSession ( sessionId , mb . messageId ) ) < nl > sessionMessagePublisher ! Tuple2 ( mb , ClientData ( authId , sessionId , authData ) ) < nl > @ @ - 279 , 4 + 279 , 5 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi < nl > < nl > log . error ( reason , " Session failed " ) < nl > } < nl > + < nl > } < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala < nl > index e9766df . . bf303a1 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala < nl > @ @ - 1 , 61 + 1 , 80 @ @ < nl > package im . actor . server . session < nl > < nl > - import akka . stream . FanOutShape . _ < nl > - import akka . stream . scaladsl . _ < nl > - import akka . stream . { FanOutShape , Attributes } < nl > - < nl > + import akka . stream . _ < nl > + import akka . stream . stage . { OutHandler , GraphStage , GraphStageLogic , InHandler } < nl > import im . actor . server . mtproto . protocol . _ < nl > - import im . actor . server . session . ReSenderMessage . IncomingAck < nl > - < nl > - private final class SessionMessageDiscriminatorShape ( _ init : Init [ SessionStreamMessage ] = Name [ SessionStreamMessage ] ( " SessionMessageDiscriminator " ) ) < nl > - extends FanOutShape [ SessionStreamMessage ] ( _ init ) { < nl > - import SessionStreamMessage . _ < nl > - < nl > - val outProtoMessage = newOutlet [ ProtoMessage ] ( " outProtoMessage " ) < nl > - val outRpc = newOutlet [ HandleRpcRequest ] ( " outRpc " ) < nl > - val outSubscribe = newOutlet [ SubscribeCommand ] ( " outSubscribe " ) < nl > - val outRequestResend = newOutlet [ RequestResend ] ( " outRequestResend " ) < nl > - val outIncomingAck = newOutlet [ MessageAck ] ( " outIncomingAck " ) < nl > - val outUnmatched = newOutlet [ SessionStreamMessage ] ( " outUnmatched " ) < nl > + import im . actor . server . session . SessionStreamMessage . _ < nl > < nl > - protected override def construct ( i : Init [ SessionStreamMessage ] ) = new SessionMessageDiscriminatorShape ( i ) < nl > + object SessionMessageDiscriminator { < nl > + type Shape = FanOutShape6 [ SessionStreamMessage , ProtoMessage , HandleRpcRequest , SubscribeCommand , RequestResend , MessageAck , SessionStreamMessage ] < nl > } < nl > < nl > - private [ session ] final class SessionMessageDiscriminator extends FlexiRoute [ SessionStreamMessage , SessionMessageDiscriminatorShape ] ( < nl > - new SessionMessageDiscriminatorShape , Attributes . name ( " SessionMessageDiscriminator " ) < nl > - ) { < nl > + private [ session ] final class SessionMessageDiscriminator extends GraphStage [ SessionMessageDiscriminator . Shape ] { < nl > + val in = Inlet [ SessionStreamMessage ] ( " sessionStreamMessage " ) < nl > + val outProtoMessage = Outlet [ ProtoMessage ] ( " protoMessage " ) < nl > + val outRpc = Outlet [ HandleRpcRequest ] ( " rpc " ) < nl > + val outSubscribe = Outlet [ SubscribeCommand ] ( " subscribe " ) < nl > + val outRequestResend = Outlet [ RequestResend ] ( " requestResend " ) < nl > + val outIncomingAck = Outlet [ MessageAck ] ( " incomingAck " ) < nl > + val outUnmatched = Outlet [ SessionStreamMessage ] ( " unmatched " ) < nl > < nl > - import FlexiRoute . _ < nl > + override def shape : Shape = new FanOutShape6 [ SessionStreamMessage , ProtoMessage , HandleRpcRequest , SubscribeCommand , RequestResend , MessageAck , SessionStreamMessage ] ( < nl > + in , < nl > + outProtoMessage , < nl > + outRpc , < nl > + outSubscribe , < nl > + outRequestResend , < nl > + outIncomingAck , < nl > + outUnmatched < nl > + ) < nl > < nl > - import SessionStreamMessage . _ < nl > + override def createLogic ( inheritedAttributes : Attributes ) : GraphStageLogic = new GraphStageLogic ( shape ) { < nl > + private var pendingCount = 0 < nl > + private var inPulled = false < nl > < nl > - override def createRouteLogic ( p : PortT ) = new RouteLogic [ SessionStreamMessage ] { < nl > - override def initialState = State [ Any ] ( DemandFromAll ( p . outlets ) ) { < nl > - ( ctx , _ , element ) ⇒ < nl > - handleElement ( ctx , element ) < nl > - < nl > - SameState < nl > + val pullIn = ( ) ⇒ { < nl > + inPulled = true < nl > + pull ( in ) < nl > } < nl > < nl > - override def initialCompletionHandling = eagerClose < nl > - < nl > - private def handleElement ( ctx : RouteLogicContext , element : SessionStreamMessage ) : Unit = { < nl > - element match { < nl > - case HandleMessageBox ( MessageBox ( messageId , RpcRequestBox ( bodyBytes ) ) , clientData ) ⇒ < nl > - ctx . emit ( p . outRpc ) ( HandleRpcRequest ( messageId , bodyBytes , clientData ) ) < nl > - case HandleMessageBox ( MessageBox ( messageId , m : MessageAck ) , clientData ) ⇒ < nl > - ctx . emit ( p . outIncomingAck ) ( m ) < nl > - case HandleMessageBox ( MessageBox ( messageId , m : RequestResend ) , _ ) ⇒ < nl > - ctx . emit ( p . outRequestResend ) ( m ) < nl > - case HandleMessageBox ( MessageBox ( messageId , m : SessionHello ) , _ ) ⇒ < nl > - / / ignore < nl > - case SendProtoMessage ( message ) ⇒ < nl > - ctx . emit ( p . outProtoMessage ) ( message ) < nl > - case msg @ HandleSubscribe ( command ) ⇒ < nl > - ctx . emit ( p . outSubscribe ) ( command ) < nl > - case unmatched ⇒ < nl > - ctx . emit ( p . outUnmatched ) ( unmatched ) < nl > + setHandler ( in , new InHandler { < nl > + override def onPush ( ) : Unit = { < nl > + val msg = grab ( in ) < nl > + inPulled = false < nl > + < nl > + msg match { < nl > + case SessionStreamMessage . HandleMessageBox ( MessageBox ( messageId , RpcRequestBox ( bodyBytes ) ) , clientData ) ⇒ < nl > + emit ( outRpc , HandleRpcRequest ( messageId , bodyBytes , clientData ) , pullIn ) < nl > + case SessionStreamMessage . HandleMessageBox ( MessageBox ( messageId , m : MessageAck ) , clientData ) ⇒ < nl > + emit ( outIncomingAck , m , pullIn ) < nl > + case SessionStreamMessage . HandleMessageBox ( MessageBox ( messageId , m : RequestResend ) , _ ) ⇒ < nl > + emit ( outRequestResend , m , pullIn ) < nl > + case SessionStreamMessage . HandleMessageBox ( MessageBox ( messageId , m : SessionHello ) , _ ) ⇒ < nl > + pullIn ( ) < nl > + case SessionStreamMessage . SendProtoMessage ( message ) ⇒ < nl > + emit ( outProtoMessage , message , pullIn ) < nl > + case msg @ SessionStreamMessage . HandleSubscribe ( command ) ⇒ < nl > + emit ( outSubscribe , command , pullIn ) < nl > + case unmatched ⇒ < nl > + emit ( outUnmatched , unmatched , pullIn ) < nl > + } < nl > + } < nl > + } ) < nl > + < nl > + val pullIt = new OutHandler { < nl > + override def onPull ( ) : Unit = { < nl > + if ( ! inPulled ) < nl > + pullIn ( ) < nl > } < nl > } < nl > + < nl > + setHandler ( outProtoMessage , pullIt ) < nl > + setHandler ( outRpc , pullIt ) < nl > + setHandler ( outSubscribe , pullIt ) < nl > + setHandler ( outRequestResend , pullIt ) < nl > + setHandler ( outIncomingAck , pullIt ) < nl > + setHandler ( outUnmatched , pullIt ) < nl > + < nl > + override def preStart ( ) : Unit = pullIn ( ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > index 980b06d . . 802b5a1 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > @ @ - 38 , 7 + 38 , 7 @ @ private [ session ] object SessionStream { < nl > updatesHandler : ActorRef , < nl > reSender : ActorRef < nl > ) ( implicit context : ActorContext ) = { < nl > - FlowGraph . partial ( ) { implicit builder ⇒ < nl > + FlowGraph . create ( ) { implicit builder ⇒ < nl > import FlowGraph . Implicits . _ < nl > < nl > import SessionStreamMessage . _ < nl > @ @ - 46 , 18 + 46 , 18 @ @ private [ session ] object SessionStream { < nl > val discr = builder . add ( new SessionMessageDiscriminator ) < nl > < nl > / / TODO : think about buffer sizes and overflow strategies < nl > - val rpc = discr . outRpc . buffer ( 100 , OverflowStrategy . backpressure ) < nl > - val subscribe = discr . outSubscribe . buffer ( 100 , OverflowStrategy . backpressure ) < nl > - val incomingAck = discr . outIncomingAck . buffer ( 100 , OverflowStrategy . backpressure ) . map ( in ) < nl > - val outProtoMessages = discr . outProtoMessage . buffer ( 100 , OverflowStrategy . backpressure ) . map ( out ) < nl > - val outRequestResend = discr . outRequestResend . buffer ( 100 , OverflowStrategy . backpressure ) . map ( in ) < nl > - val unmatched = discr . outUnmatched . buffer ( 100 , OverflowStrategy . backpressure ) < nl > + val rpc = discr . out1 . buffer ( 100 , OverflowStrategy . backpressure ) < nl > + val subscribe = discr . out2 . buffer ( 100 , OverflowStrategy . backpressure ) < nl > + val incomingAck = discr . out4 . buffer ( 100 , OverflowStrategy . backpressure ) . map ( in ) < nl > + val outProtoMessages = discr . out0 . buffer ( 100 , OverflowStrategy . backpressure ) . map ( out ) < nl > + val outRequestResend = discr . out3 . buffer ( 100 , OverflowStrategy . backpressure ) . map ( in ) < nl > + val unmatched = discr . out5 . buffer ( 100 , OverflowStrategy . backpressure ) < nl > < nl > val rpcRequestSubscriber = builder . add ( Sink ( ActorSubscriber [ HandleRpcRequest ] ( rpcHandler ) ) ) < nl > val rpcResponsePublisher = builder . add ( Source ( ActorPublisher [ ProtoMessage ] ( rpcHandler ) ) . map ( out ) ) < nl > < nl > val updatesSubscriber = builder . add ( Sink ( ActorSubscriber [ SubscribeCommand ] ( updatesHandler ) ) ) < nl > - val updatesPublisher = builder . add ( Source ( ActorPublisher [ OutProtoMessage ] ( updatesHandler ) ) ) . map ( out ) < nl > + val updatesPublisher = builder . add ( Source ( ActorPublisher [ OutProtoMessage ] ( updatesHandler ) ) . map ( out ) ) < nl > < nl > val reSendSubscriber = builder . add ( Sink ( ActorSubscriber [ ReSenderMessage ] ( reSender ) ) ) < nl > val reSendPublisher = builder . add ( Source ( ActorPublisher [ MTPackage ] ( reSender ) ) ) < nl > @ @ - 65 , 7 + 65 , 7 @ @ private [ session ] object SessionStream { < nl > val mergeProto = builder . add ( MergePreferred [ ReSenderMessage ] ( 3 ) ) < nl > val mergeProtoPriority = builder . add ( MergePreferred [ ReSenderMessage ] ( 1 ) ) < nl > < nl > - val logging = akka . event . Logging ( context . system , s " SessionStream - $ { authId } - $ { sessionId } " ) < nl > + val logging = akka . event . Logging ( context . system , s " SessionStream - $ authId - $ sessionId " ) < nl > < nl > val log = Sink . foreach [ SessionStreamMessage ] ( logging . warning ( " Unmatched { } " , _ ) ) < nl > < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 02a6748 . . 8ed2df3 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 156 , 7 + 156 , 7 @ @ object Dependencies { < nl > < nl > val sessionMessages = Seq ( akkaActor ) < nl > < nl > - val persist = shared + + Seq ( akkaActor , apacheCommonsCodec , postgresJdbc , slick , slickJoda , slickPg , slickTestkit , flywayCore , hikariCP , jodaTime , jodaConvert ) < nl > + val persist = shared + + Seq ( akkaActor , akkaStream , apacheCommonsCodec , postgresJdbc , slick , slickJoda , slickPg , slickTestkit , flywayCore , hikariCP , jodaTime , jodaConvert ) < nl > < nl > val presences = shared : + akkaClusterSharding

TEST DIFF:
diff - - git a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / TcpFrontend . scala b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / TcpFrontend . scala 
 index 3513e93 . . 59a1968 100644 
 - - - a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / TcpFrontend . scala 
 + + + b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / TcpFrontend . scala 
 @ @ - 29 , 6 + 29 , 5 @ @ object TcpFrontend extends Frontend ( " tcp " ) { 
 ( tlsContext map ( Tls . connection ( _ , flow ) ) getOrElse flow ) . joinMat ( mtProto ) ( Keep . right ) . run ( ) 
 } ) 
 . run ( ) 
 - 
 } 
 } 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / IdleControl . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / IdleControl . scala 
 new file mode 100644 
 index 0000000 . . a92fa79 
 - - - / dev / null 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / IdleControl . scala 
 @ @ - 0 , 0 + 1 , 30 @ @ 
 + package im . actor . server . session 
 + 
 + import akka . actor . _ 
 + 
 + import scala . concurrent . duration . Duration 
 + 
 + object IdleControl { 
 + case object KeepAlive 
 + 
 + def apply ( timeout : Duration ) ( implicit factory : ActorRefFactory ) = 
 + new IdleControl ( factory . actorOf ( props ( timeout ) , " idle - control " ) ) 
 + 
 + private def props ( timeout : Duration ) = Props ( classOf [ IdleControlActor ] , timeout ) 
 + } 
 + 
 + final case class IdleControl ( val ref : ActorRef ) { 
 + def keepAlive ( ) : Unit = ref ! IdleControl . KeepAlive 
 + } 
 + 
 + private final class IdleControlActor ( timeout : Duration ) extends Actor { 
 + import IdleControl . _ 
 + 
 + context . setReceiveTimeout ( timeout ) 
 + 
 + def receive = { 
 + case KeepAlive ⇒ 
 + case ReceiveTimeout ⇒ 
 + context . parent ! ReceiveTimeout 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 index 373271c . . 875c823 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 @ @ - 82 , 13 + 82 , 19 @ @ object Session { 
 private case object AuthIdInvalid 
 } 
 
 - final private class Session ( implicit config : SessionConfig , materializer : Materializer ) extends Actor with ActorLogging with MessageIdHelper with Stash { 
 + final private class Session ( implicit config : SessionConfig , materializer : Materializer ) 
 + extends Actor 
 + with ActorLogging 
 + with MessageIdHelper 
 + with Stash { 
 
 implicit val ec : ExecutionContext = context . dispatcher 
 
 private val pubSubExt = PubSubExtension ( context . system ) 
 private val db : Database = DbExtension ( context . system ) . db 
 
 + private val idleControl = IdleControl ( config . idleTimeout ) 
 + 
 private [ this ] var authData : Option [ AuthData ] = None 
 private [ this ] var clients = immutable . Set . empty [ ActorRef ] 
 
 @ @ - 100 , 8 + 106 , 6 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 throw e 
 } 
 
 - context . setReceiveTimeout ( config . idleTimeout ) 
 - 
 db . run ( AuthIdRepo . find ( authId ) flatMap { 
 case Some ( _ ) ⇒ 
 AuthSessionRepo . findByAuthId ( authId ) map { 
 @ @ - 159 , 6 + 163 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 
 def anonymous : Receive = { 
 case HandleMessageBox ( messageBoxBytes ) ⇒ 
 + idleControl . keepAlive ( ) 
 recordClient ( sender ( ) ) 
 
 withValidMessageBox ( messageBoxBytes . toByteArray ) { mb ⇒ 
 @ @ - 199 , 12 + 204 , 14 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 
 def resolved ( publisher : ActorRef , reSender : ActorRef ) : Receive = { 
 case HandleMessageBox ( messageBoxBytes ) ⇒ 
 + idleControl . keepAlive ( ) 
 recordClient ( sender ( ) ) 
 
 withValidMessageBox ( messageBoxBytes . toByteArray ) { mb ⇒ 
 publisher ! Tuple2 ( mb , ClientData ( authId , sessionId , authData ) ) 
 } 
 case cmd : SubscribeCommand ⇒ 
 + idleControl . keepAlive ( ) 
 publisher ! cmd 
 case AuthorizeUser ( userId , authSid ) ⇒ authorize ( userId , authSid , Some ( sender ( ) ) ) 
 case internal ⇒ handleInternal ( internal , stashUnmatched = false ) 
 @ @ - 283 , 5 + 290 , 4 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 
 log . error ( reason , " Session failed " ) 
 } 
 - 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala 
 index 433d752 . . e4d48cb 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala 
 @ @ - 28 , 7 + 28 , 7 @ @ import kamon . Kamon 
 import scala . concurrent . ExecutionContext 
 import scala . util . Random 
 
 - class SimpleServerE2eSpec extends ActorSuite ( 
 + final class SimpleServerE2eSpec extends ActorSuite ( 
 ActorSpecification . createSystem ( ConfigFactory . parseString ( 
 " " " 
 | session { 
 @ @ - 45 , 7 + 45 , 7 @ @ class SimpleServerE2eSpec extends ActorSuite ( 
 
 it should " respond to big RPC requests " in Server . bigRequests 
 
 - it should " notify about lost session " in Server . e3 
 + it should " notify about lost session " in Server . sessionLost 
 
 it should " throw AuthIdInvalid if sending wrong AuthId " in Server . authIdInvalid 
 
 @ @ - 60 , 7 + 60 , 7 @ @ class SimpleServerE2eSpec extends ActorSuite ( 
 val serverConfig = system . settings . config 
 
 val oauthGoogleConfig = OAuth2GoogleConfig . load ( system . settings . config . getConfig ( " services . google . oauth " ) ) 
 - val sequenceConfig = SequenceServiceConfig . load . toOption . get 
 + val sequenceConfig = SequenceServiceConfig . load ( ) . toOption . get 
 
 implicit val sessionConfig = SessionConfig . load ( system . settings . config . getConfig ( " session " ) ) 
 Session . startRegion ( Session . props ) 
 @ @ - 145 , 7 + 145 , 7 @ @ class SimpleServerE2eSpec extends ActorSuite ( 
 client . close ( ) 
 } 
 
 - def e3 ( ) = { 
 + def sessionLost ( ) = { 
 implicit val client = MTProtoClient ( ) 
 
 client . connectAndHandshake ( remote ) 
 @ @ - 162 , 7 + 162 , 7 @ @ class SimpleServerE2eSpec extends ActorSuite ( 
 expectMessageAck ( helloMessageId ) 
 } 
 
 - Thread . sleep ( 3000 ) 
 + Thread . sleep ( 5000 ) 
 expectSessionLost ( ) 
 
 {

NEAREST DIFF:
diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotExtension . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotExtension . scala 
 index 72caaa2 . . d81c031 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotExtension . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotExtension . scala 
 @ @ - 49 , 7 + 49 , 7 @ @ private [ bot ] final class BotExtension ( _ system : ActorSystem ) extends Extension { 
 
 lazy val tokensKV = shardakka . simpleKeyValue ( BotExtension . tokensKV , IntCodec ) 
 
 - private val globalHooksKV : SimpleKeyValue [ BotWebHook ] = shardakka . simpleKeyValue ( BotExtension . whTokensKV , BotWebHookCodec ) 
 + private lazy val globalHooksKV : SimpleKeyValue [ BotWebHook ] = shardakka . simpleKeyValue ( BotExtension . whTokensKV , BotWebHookCodec ) 
 
 private def hooksKV ( userId : UserId ) : SimpleKeyValue [ String ] = 
 shardakka . simpleKeyValue ( BotExtension . whUserTokensKV ( userId ) ) 
 diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala 
 index 4e7d28a . . d3921d8 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotServerBlueprint . scala 
 @ @ - 2 , 7 + 2 , 8 @ @ package im . actor . server . bot 
 
 import akka . actor . ActorSystem 
 import akka . event . Logging 
 - import akka . stream . scaladsl . { Flow , Merge , Source } 
 + import akka . stream . FlowShape 
 + import akka . stream . scaladsl . _ 
 import im . actor . api . rpc . Update 
 import im . actor . bots . BotMessages 
 import im . actor . server . bot . services . _ 
 @ @ - 14 , 7 + 15 , 7 @ @ import scala . util . { Success , Failure } 
 final class BotServerBlueprint ( botUserId : Int , botAuthId : Long , botAuthSid : Int , system : ActorSystem ) { 
 
 import BotMessages . _ 
 - import akka . stream . scaladsl . FlowGraph . Implicits . _ 
 + 
 import system . dispatcher 
 
 private lazy val updBuilder = new BotUpdateBuilder ( botUserId , botAuthId , system ) 
 @ @ - 42 , 16 + 43 , 20 @ @ final class BotServerBlueprint ( botUserId : Int , botAuthId : Long , botAuthSid : Int , 
 } 
 . map ( _ . asInstanceOf [ BotMessageOut ] ) 
 
 - Flow ( ) { implicit b ⇒ 
 - val upd = b . add ( updSource ) 
 - val rqrsp = b . add ( rqrspFlow ) 
 - val merge = b . add ( Merge [ BotMessageOut ] ( 2 ) ) 
 + Flow . fromGraph ( 
 + FlowGraph . create ( ) { implicit b ⇒ 
 + import akka . stream . scaladsl . FlowGraph . Implicits . _ 
 + 
 + val upd = b . add ( updSource ) 
 + val rqrsp = b . add ( rqrspFlow ) 
 + val merge = b . add ( Merge [ BotMessageOut ] ( 2 ) ) 
 
 - upd ~ > merge 
 - rqrsp ~ > merge 
 + upd ~ > merge 
 + rqrsp ~ > merge 
 
 - ( rqrsp . inlet , merge . out ) 
 - } 
 + FlowShape ( rqrsp . inlet , merge . out ) 
 + } 
 + ) 
 } 
 
 private def handleRequest ( id : Long , service : String , body : RequestBody ) : Future [ BotResponse ] = { 
 diff - - git a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / MTProtoBlueprint . scala b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / MTProtoBlueprint . scala 
 index 0bac5ac . . f31ebf4 100644 
 - - - a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / MTProtoBlueprint . scala 
 + + + b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / MTProtoBlueprint . scala 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 package im . actor . server . frontend 
 
 + import akka . stream . FlowShape 
 + 
 import scala . util . { Failure , Success } 
 
 import akka . actor . _ 
 @ @ - 46 , 7 + 48 , 7 @ @ object MTProtoBlueprint { 
 sessionClient ! PoisonPill 
 } 
 
 - Flow ( ) { implicit builder ⇒ 
 + Flow . fromGraph ( FlowGraph . create ( ) { implicit builder ⇒ 
 import FlowGraph . Implicits . _ 
 
 val bcast = builder . add ( Broadcast [ ByteString ] ( 2 ) ) 
 @ @ - 67 , 8 + 69 , 8 @ @ object MTProtoBlueprint { 
 
 / / format : ON 
 
 - ( bcast . in , mapResp . outlet ) 
 - } 
 + FlowShape ( bcast . in , mapResp . outlet ) 
 + } ) 
 } 
 
 def mapResponse ( system : ActorSystem ) = new PushStage [ MTProto , ByteString ] { 
 diff - - git a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / WsFrontend . scala b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / WsFrontend . scala 
 index 84ba185 . . d8f7df8 100644 
 - - - a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / WsFrontend . scala 
 + + + b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / WsFrontend . scala 
 @ @ - 62 , 8 + 62 , 7 @ @ object WsFrontend extends Frontend { 
 . collect { 
 case msg : BinaryMessage ⇒ msg 
 } 
 - . map ( _ . dataStream ) 
 - . flatten ( FlattenStrategy . concat ) 
 + . flatMapConcat ( _ . dataStream ) 
 . via ( mtProtoFlow ) 
 . map { 
 case bs ⇒ 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 index 1c7c78b . . 936a6e0 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 @ @ - 7 , 7 + 7 , 7 @ @ import akka . cluster . sharding . ShardRegion . Passivate 
 import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding , ShardRegion } 
 import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } 
 import akka . pattern . pipe 
 - import akka . stream . Materializer 
 + import akka . stream . { ClosedShape , Materializer } 
 import akka . stream . actor . _ 
 import akka . stream . scaladsl . _ 
 import com . typesafe . config . Config 
 @ @ - 161 , 7 + 161 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 withValidMessageBox ( messageBoxBytes . toByteArray ) { mb ⇒ 
 val graph = SessionStream . graph ( authId , sessionId , rpcHandler , updatesHandler , reSender ) 
 
 - val flow = FlowGraph . closed ( graph ) { implicit b ⇒ g ⇒ 
 + RunnableGraph . fromGraph ( FlowGraph . create ( ) { implicit b ⇒ 
 import FlowGraph . Implicits . _ 
 
 val source = b . add ( Source ( ActorPublisher [ SessionStreamMessage ] ( sessionMessagePublisher ) ) ) 
 @ @ - 170 , 7 + 170 , 7 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 
 / / format : OFF 
 
 - source ~ > g ~ > bcast ~ > sink 
 + source ~ > graph ~ > bcast ~ > sink 
 bcast ~ > Sink . onComplete { c ⇒ 
 c . failed foreach { e = > 
 log . error ( e , " Dying due to stream error " ) ; 
 @ @ - 179 , 9 + 179 , 9 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 } 
 
 / / format : ON 
 - } 
 
 - flow . run ( ) 
 + ClosedShape 
 + } ) . run ( ) 
 
 sessionMessagePublisher ! SessionStreamMessage . SendProtoMessage ( NewSession ( sessionId , mb . messageId ) ) 
 sessionMessagePublisher ! Tuple2 ( mb , ClientData ( authId , sessionId , authData ) ) 
 @ @ - 279 , 4 + 279 , 5 @ @ final private class Session ( implicit config : SessionConfig , materializer : Materi 
 
 log . error ( reason , " Session failed " ) 
 } 
 + 
 } 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala 
 index e9766df . . bf303a1 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionMessageDiscriminator . scala 
 @ @ - 1 , 61 + 1 , 80 @ @ 
 package im . actor . server . session 
 
 - import akka . stream . FanOutShape . _ 
 - import akka . stream . scaladsl . _ 
 - import akka . stream . { FanOutShape , Attributes } 
 - 
 + import akka . stream . _ 
 + import akka . stream . stage . { OutHandler , GraphStage , GraphStageLogic , InHandler } 
 import im . actor . server . mtproto . protocol . _ 
 - import im . actor . server . session . ReSenderMessage . IncomingAck 
 - 
 - private final class SessionMessageDiscriminatorShape ( _ init : Init [ SessionStreamMessage ] = Name [ SessionStreamMessage ] ( " SessionMessageDiscriminator " ) ) 
 - extends FanOutShape [ SessionStreamMessage ] ( _ init ) { 
 - import SessionStreamMessage . _ 
 - 
 - val outProtoMessage = newOutlet [ ProtoMessage ] ( " outProtoMessage " ) 
 - val outRpc = newOutlet [ HandleRpcRequest ] ( " outRpc " ) 
 - val outSubscribe = newOutlet [ SubscribeCommand ] ( " outSubscribe " ) 
 - val outRequestResend = newOutlet [ RequestResend ] ( " outRequestResend " ) 
 - val outIncomingAck = newOutlet [ MessageAck ] ( " outIncomingAck " ) 
 - val outUnmatched = newOutlet [ SessionStreamMessage ] ( " outUnmatched " ) 
 + import im . actor . server . session . SessionStreamMessage . _ 
 
 - protected override def construct ( i : Init [ SessionStreamMessage ] ) = new SessionMessageDiscriminatorShape ( i ) 
 + object SessionMessageDiscriminator { 
 + type Shape = FanOutShape6 [ SessionStreamMessage , ProtoMessage , HandleRpcRequest , SubscribeCommand , RequestResend , MessageAck , SessionStreamMessage ] 
 } 
 
 - private [ session ] final class SessionMessageDiscriminator extends FlexiRoute [ SessionStreamMessage , SessionMessageDiscriminatorShape ] ( 
 - new SessionMessageDiscriminatorShape , Attributes . name ( " SessionMessageDiscriminator " ) 
 - ) { 
 + private [ session ] final class SessionMessageDiscriminator extends GraphStage [ SessionMessageDiscriminator . Shape ] { 
 + val in = Inlet [ SessionStreamMessage ] ( " sessionStreamMessage " ) 
 + val outProtoMessage = Outlet [ ProtoMessage ] ( " protoMessage " ) 
 + val outRpc = Outlet [ HandleRpcRequest ] ( " rpc " ) 
 + val outSubscribe = Outlet [ SubscribeCommand ] ( " subscribe " ) 
 + val outRequestResend = Outlet [ RequestResend ] ( " requestResend " ) 
 + val outIncomingAck = Outlet [ MessageAck ] ( " incomingAck " ) 
 + val outUnmatched = Outlet [ SessionStreamMessage ] ( " unmatched " ) 
 
 - import FlexiRoute . _ 
 + override def shape : Shape = new FanOutShape6 [ SessionStreamMessage , ProtoMessage , HandleRpcRequest , SubscribeCommand , RequestResend , MessageAck , SessionStreamMessage ] ( 
 + in , 
 + outProtoMessage , 
 + outRpc , 
 + outSubscribe , 
 + outRequestResend , 
 + outIncomingAck , 
 + outUnmatched 
 + ) 
 
 - import SessionStreamMessage . _ 
 + override def createLogic ( inheritedAttributes : Attributes ) : GraphStageLogic = new GraphStageLogic ( shape ) { 
 + private var pendingCount = 0 
 + private var inPulled = false 
 
 - override def createRouteLogic ( p : PortT ) = new RouteLogic [ SessionStreamMessage ] { 
 - override def initialState = State [ Any ] ( DemandFromAll ( p . outlets ) ) { 
 - ( ctx , _ , element ) ⇒ 
 - handleElement ( ctx , element ) 
 - 
 - SameState 
 + val pullIn = ( ) ⇒ { 
 + inPulled = true 
 + pull ( in ) 
 } 
 
 - override def initialCompletionHandling = eagerClose 
 - 
 - private def handleElement ( ctx : RouteLogicContext , element : SessionStreamMessage ) : Unit = { 
 - element match { 
 - case HandleMessageBox ( MessageBox ( messageId , RpcRequestBox ( bodyBytes ) ) , clientData ) ⇒ 
 - ctx . emit ( p . outRpc ) ( HandleRpcRequest ( messageId , bodyBytes , clientData ) ) 
 - case HandleMessageBox ( MessageBox ( messageId , m : MessageAck ) , clientData ) ⇒ 
 - ctx . emit ( p . outIncomingAck ) ( m ) 
 - case HandleMessageBox ( MessageBox ( messageId , m : RequestResend ) , _ ) ⇒ 
 - ctx . emit ( p . outRequestResend ) ( m ) 
 - case HandleMessageBox ( MessageBox ( messageId , m : SessionHello ) , _ ) ⇒ 
 - / / ignore 
 - case SendProtoMessage ( message ) ⇒ 
 - ctx . emit ( p . outProtoMessage ) ( message ) 
 - case msg @ HandleSubscribe ( command ) ⇒ 
 - ctx . emit ( p . outSubscribe ) ( command ) 
 - case unmatched ⇒ 
 - ctx . emit ( p . outUnmatched ) ( unmatched ) 
 + setHandler ( in , new InHandler { 
 + override def onPush ( ) : Unit = { 
 + val msg = grab ( in ) 
 + inPulled = false 
 + 
 + msg match { 
 + case SessionStreamMessage . HandleMessageBox ( MessageBox ( messageId , RpcRequestBox ( bodyBytes ) ) , clientData ) ⇒ 
 + emit ( outRpc , HandleRpcRequest ( messageId , bodyBytes , clientData ) , pullIn ) 
 + case SessionStreamMessage . HandleMessageBox ( MessageBox ( messageId , m : MessageAck ) , clientData ) ⇒ 
 + emit ( outIncomingAck , m , pullIn ) 
 + case SessionStreamMessage . HandleMessageBox ( MessageBox ( messageId , m : RequestResend ) , _ ) ⇒ 
 + emit ( outRequestResend , m , pullIn ) 
 + case SessionStreamMessage . HandleMessageBox ( MessageBox ( messageId , m : SessionHello ) , _ ) ⇒ 
 + pullIn ( ) 
 + case SessionStreamMessage . SendProtoMessage ( message ) ⇒ 
 + emit ( outProtoMessage , message , pullIn ) 
 + case msg @ SessionStreamMessage . HandleSubscribe ( command ) ⇒ 
 + emit ( outSubscribe , command , pullIn ) 
 + case unmatched ⇒ 
 + emit ( outUnmatched , unmatched , pullIn ) 
 + } 
 + } 
 + } ) 
 + 
 + val pullIt = new OutHandler { 
 + override def onPull ( ) : Unit = { 
 + if ( ! inPulled ) 
 + pullIn ( ) 
 } 
 } 
 + 
 + setHandler ( outProtoMessage , pullIt ) 
 + setHandler ( outRpc , pullIt ) 
 + setHandler ( outSubscribe , pullIt ) 
 + setHandler ( outRequestResend , pullIt ) 
 + setHandler ( outIncomingAck , pullIt ) 
 + setHandler ( outUnmatched , pullIt ) 
 + 
 + override def preStart ( ) : Unit = pullIn ( ) 
 } 
 } 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 index 980b06d . . 802b5a1 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 @ @ - 38 , 7 + 38 , 7 @ @ private [ session ] object SessionStream { 
 updatesHandler : ActorRef , 
 reSender : ActorRef 
 ) ( implicit context : ActorContext ) = { 
 - FlowGraph . partial ( ) { implicit builder ⇒ 
 + FlowGraph . create ( ) { implicit builder ⇒ 
 import FlowGraph . Implicits . _ 
 
 import SessionStreamMessage . _ 
 @ @ - 46 , 18 + 46 , 18 @ @ private [ session ] object SessionStream { 
 val discr = builder . add ( new SessionMessageDiscriminator ) 
 
 / / TODO : think about buffer sizes and overflow strategies 
 - val rpc = discr . outRpc . buffer ( 100 , OverflowStrategy . backpressure ) 
 - val subscribe = discr . outSubscribe . buffer ( 100 , OverflowStrategy . backpressure ) 
 - val incomingAck = discr . outIncomingAck . buffer ( 100 , OverflowStrategy . backpressure ) . map ( in ) 
 - val outProtoMessages = discr . outProtoMessage . buffer ( 100 , OverflowStrategy . backpressure ) . map ( out ) 
 - val outRequestResend = discr . outRequestResend . buffer ( 100 , OverflowStrategy . backpressure ) . map ( in ) 
 - val unmatched = discr . outUnmatched . buffer ( 100 , OverflowStrategy . backpressure ) 
 + val rpc = discr . out1 . buffer ( 100 , OverflowStrategy . backpressure ) 
 + val subscribe = discr . out2 . buffer ( 100 , OverflowStrategy . backpressure ) 
 + val incomingAck = discr . out4 . buffer ( 100 , OverflowStrategy . backpressure ) . map ( in ) 
 + val outProtoMessages = discr . out0 . buffer ( 100 , OverflowStrategy . backpressure ) . map ( out ) 
 + val outRequestResend = discr . out3 . buffer ( 100 , OverflowStrategy . backpressure ) . map ( in ) 
 + val unmatched = discr . out5 . buffer ( 100 , OverflowStrategy . backpressure ) 
 
 val rpcRequestSubscriber = builder . add ( Sink ( ActorSubscriber [ HandleRpcRequest ] ( rpcHandler ) ) ) 
 val rpcResponsePublisher = builder . add ( Source ( ActorPublisher [ ProtoMessage ] ( rpcHandler ) ) . map ( out ) ) 
 
 val updatesSubscriber = builder . add ( Sink ( ActorSubscriber [ SubscribeCommand ] ( updatesHandler ) ) ) 
 - val updatesPublisher = builder . add ( Source ( ActorPublisher [ OutProtoMessage ] ( updatesHandler ) ) ) . map ( out ) 
 + val updatesPublisher = builder . add ( Source ( ActorPublisher [ OutProtoMessage ] ( updatesHandler ) ) . map ( out ) ) 
 
 val reSendSubscriber = builder . add ( Sink ( ActorSubscriber [ ReSenderMessage ] ( reSender ) ) ) 
 val reSendPublisher = builder . add ( Source ( ActorPublisher [ MTPackage ] ( reSender ) ) ) 
 @ @ - 65 , 7 + 65 , 7 @ @ private [ session ] object SessionStream { 
 val mergeProto = builder . add ( MergePreferred [ ReSenderMessage ] ( 3 ) ) 
 val mergeProtoPriority = builder . add ( MergePreferred [ ReSenderMessage ] ( 1 ) ) 
 
 - val logging = akka . event . Logging ( context . system , s " SessionStream - $ { authId } - $ { sessionId } " ) 
 + val logging = akka . event . Logging ( context . system , s " SessionStream - $ authId - $ sessionId " ) 
 
 val log = Sink . foreach [ SessionStreamMessage ] ( logging . warning ( " Unmatched { } " , _ ) ) 
 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 02a6748 . . 8ed2df3 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 156 , 7 + 156 , 7 @ @ object Dependencies { 
 
 val sessionMessages = Seq ( akkaActor ) 
 
 - val persist = shared + + Seq ( akkaActor , apacheCommonsCodec , postgresJdbc , slick , slickJoda , slickPg , slickTestkit , flywayCore , hikariCP , jodaTime , jodaConvert ) 
 + val persist = shared + + Seq ( akkaActor , akkaStream , apacheCommonsCodec , postgresJdbc , slick , slickJoda , slickPg , slickTestkit , flywayCore , hikariCP , jodaTime , jodaConvert ) 
 
 val presences = shared : + akkaClusterSharding
