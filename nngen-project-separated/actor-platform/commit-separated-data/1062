BLEU SCORE: 0.05061867434834411

TEST MSG: chore ( server ) : moved cats dbio to actor - commons , added actor - util
GENERATED MSG: feat ( groups ) : CreateGroup handler

TEST DIFF (one line): diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / cats / DBIO . scala b / actor - server / actor - persist / src / main / scala / im / actor / cats / DBIO . scala < nl > deleted file mode 100644 < nl > index e9aa6bc . . 0000000 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / cats / DBIO . scala < nl > + + + / dev / null < nl > @ @ - 1 , 92 + 0 , 0 @ @ < nl > - package im . actor . cats < nl > - < nl > - import cats . _ < nl > - import cats . data . Xor < nl > - import cats . data . Xor . _ < nl > - import cats . syntax . all . _ < nl > - import slick . dbio . { DBIO , FailureAction , SuccessAction } < nl > - < nl > - import scala . concurrent . ExecutionContext < nl > - import scala . reflect . ClassTag < nl > - < nl > - object dbio extends DBIOInstances < nl > - < nl > - trait DBIOInstances extends DBIOInstances1 { < nl > - < nl > - implicit def DBIOInstance ( implicit ec : ExecutionContext ) : MonadError [ DBIO , Throwable ] with CoflatMap [ DBIO ] = < nl > - new DBIOCoflatMap with MonadError [ DBIO , Throwable ] { < nl > - def pure [ A ] ( x : A ) : DBIO [ A ] = DBIO . successful ( x ) < nl > - < nl > - override def pureEval [ A ] ( x : Eval [ A ] ) : DBIO [ A ] = DBIO . successful ( x . value ) < nl > - < nl > - def flatMap [ A , B ] ( fa : DBIO [ A ] ) ( f : A ⇒ DBIO [ B ] ) : DBIO [ B ] = fa . flatMap ( f ) < nl > - < nl > - def handleErrorWith [ A ] ( fea : DBIO [ A ] ) ( f : Throwable ⇒ DBIO [ A ] ) : DBIO [ A ] = < nl > - fea flatMap { < nl > - case succ : SuccessAction [ _ ] ⇒ succ . asInstanceOf [ SuccessAction [ A ] ] < nl > - case FailureAction ( t ) ⇒ f ( t ) < nl > - } < nl > - < nl > - def raiseError [ A ] ( e : Throwable ) : DBIO [ A ] = DBIO . failed ( e ) < nl > - override def handleError [ A ] ( fea : DBIO [ A ] ) ( f : Throwable ⇒ A ) : DBIO [ A ] = < nl > - fea map { < nl > - case SuccessAction ( res ) ⇒ res . asInstanceOf [ A ] < nl > - case FailureAction ( t ) ⇒ f ( t ) < nl > - } < nl > - < nl > - override def attempt [ A ] ( fa : DBIO [ A ] ) : DBIO [ Throwable Xor A ] = < nl > - fa map { < nl > - case SuccessAction ( res ) ⇒ right ( res . asInstanceOf [ A ] ) < nl > - case FailureAction ( t ) ⇒ left ( t ) < nl > - } < nl > - < nl > - override def recover [ A ] ( fa : DBIO [ A ] ) ( pf : PartialFunction [ Throwable , A ] ) : DBIO [ A ] = < nl > - fa map { < nl > - case succ : SuccessAction [ _ ] ⇒ succ . asInstanceOf [ A ] < nl > - case FailureAction ( t ) ⇒ pf ( t ) < nl > - } < nl > - < nl > - override def recoverWith [ A ] ( fa : DBIO [ A ] ) ( pf : PartialFunction [ Throwable , DBIO [ A ] ] ) : DBIO [ A ] = < nl > - fa flatMap { < nl > - case succ : SuccessAction [ _ ] ⇒ succ . asInstanceOf [ SuccessAction [ A ] ] < nl > - case FailureAction ( t ) ⇒ pf ( t ) < nl > - } < nl > - < nl > - override def map [ A , B ] ( fa : DBIO [ A ] ) ( f : A ⇒ B ) : DBIO [ B ] = fa . map ( f ) < nl > - } < nl > - < nl > - implicit def DBIOGroup [ A : Group ] ( implicit ec : ExecutionContext ) : Group [ DBIO [ A ] ] = < nl > - new DBIOGroup [ A ] < nl > - } < nl > - < nl > - private [ cats ] sealed trait DBIOInstances1 extends DBIOInstances2 { < nl > - implicit def DBIOMonoid [ A : Monoid ] ( implicit ec : ExecutionContext ) : Monoid [ DBIO [ A ] ] = < nl > - new DBIOMonoid [ A ] < nl > - } < nl > - < nl > - private [ cats ] sealed trait DBIOInstances2 { < nl > - implicit def DBIOSemigroup [ A : Semigroup ] ( implicit ec : ExecutionContext ) : Semigroup [ DBIO [ A ] ] = < nl > - new DBIOSemigroup [ A ] < nl > - } < nl > - < nl > - private [ cats ] abstract class DBIOCoflatMap ( implicit ec : ExecutionContext ) extends CoflatMap [ DBIO ] { < nl > - def map [ A , B ] ( fa : DBIO [ A ] ) ( f : A ⇒ B ) : DBIO [ B ] = fa . map ( f ) < nl > - def coflatMap [ A , B ] ( fa : DBIO [ A ] ) ( f : DBIO [ A ] ⇒ B ) : DBIO [ B ] = DBIO . successful ( f ( fa ) ) < nl > - } < nl > - < nl > - private [ cats ] class DBIOSemigroup [ A : Semigroup ] ( implicit ec : ExecutionContext ) extends Semigroup [ DBIO [ A ] ] { < nl > - def combine ( fx : DBIO [ A ] , fy : DBIO [ A ] ) : DBIO [ A ] = < nl > - ( fx zip fy ) . map { case ( x , y ) ⇒ x | + | y } < nl > - } < nl > - < nl > - private [ cats ] class DBIOMonoid [ A ] ( implicit A : Monoid [ A ] , ec : ExecutionContext ) extends DBIOSemigroup [ A ] with Monoid [ DBIO [ A ] ] { < nl > - def empty : DBIO [ A ] = < nl > - DBIO . successful ( A . empty ) < nl > - } < nl > - < nl > - private [ cats ] class DBIOGroup [ A ] ( implicit A : Group [ A ] , ec : ExecutionContext ) extends DBIOMonoid [ A ] with Group [ DBIO [ A ] ] { < nl > - def inverse ( fx : DBIO [ A ] ) : DBIO [ A ] = < nl > - fx . map ( _ . inverse ) < nl > - override def remove ( fx : DBIO [ A ] , fy : DBIO [ A ] ) : DBIO [ A ] = < nl > - ( fx zip fy ) . map { case ( x , y ) ⇒ x | - | y } < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index fbd130e . . 9dd0ae7 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import sbt . _ < nl > < nl > object Dependencies { < nl > object V { < nl > - val actorCommons = " 0 . 0 . 9 " < nl > + val actorCommons = " 0 . 0 . 11 " < nl > val actorBotkit = " 1 . 0 . 66 " < nl > val akka = " 2 . 4 . 0 " < nl > val akkaExperimental = " 2 . 0 . 2 " < nl > @ @ - 22 , 6 + 22 , 7 @ @ object Dependencies { < nl > < nl > object Compile { < nl > val actorConcurrent = " im . actor " % % " actor - concurrent " % V . actorCommons < nl > + val actorUtil = " im . actor " % % " actor - util " % V . actorCommons < nl > val actorBotkit = " im . actor " % " actor - botkit " % V . actorBotkit < nl > val shardakka = " im . actor " % % " shardakka " % V . shardakka < nl > val scalapbSer = " im . actor " % % " akka - scalapb - serialization " % V . scalapbSer < nl > @ @ - 133 , 6 + 134 , 7 @ @ object Dependencies { < nl > < nl > val shared = Seq ( < nl > configs , < nl > + actorUtil , < nl > javaCompat , < nl > logbackClassic , < nl > scalaLogging ,
NEAREST DIFF (one line): diff - - git a / actor - models / src / main / scala / im / actor / server / models / GroupUser . scala b / actor - models / src / main / scala / im / actor / server / models / GroupUser . scala < nl > new file mode 100644 < nl > index 0000000 . . f9bd06e < nl > - - - / dev / null < nl > + + + b / actor - models / src / main / scala / im / actor / server / models / GroupUser . scala < nl > @ @ - 0 , 0 + 1 , 5 @ @ < nl > + package im . actor . server . models < nl > + < nl > + import org . joda . time . DateTime < nl > + < nl > + case class GroupUser ( groupId : Int , userId : Int , inviterUserId : Int , invitedAt : DateTime ) < nl > diff - - git a / actor - persist / src / main / scala / im / actor / server / persist / Group . scala b / actor - persist / src / main / scala / im / actor / server / persist / Group . scala < nl > new file mode 100644 < nl > index 0000000 . . c276eaa < nl > - - - / dev / null < nl > + + + b / actor - persist / src / main / scala / im / actor / server / persist / Group . scala < nl > @ @ - 0 , 0 + 1 , 75 @ @ < nl > + package im . actor . server . persist < nl > + < nl > + import com . github . tototoshi . slick . PostgresJodaSupport . _ < nl > + import org . joda . time . DateTime < nl > + import slick . driver . PostgresDriver . api . _ < nl > + < nl > + import im . actor . server . models < nl > + < nl > + private [ persist ] case class FullGroupData ( id : Int , < nl > + creatorUserId : Int , < nl > + accessHash : Long , < nl > + title : String , < nl > + createdAt : DateTime , < nl > + titleChangerUserId : Int , < nl > + titleChangedAt : DateTime , < nl > + titleChangeRandomId : Long , < nl > + avatarChangerUserId : Int , < nl > + avatarChangedAt : DateTime , < nl > + avatarChangeRandomId : Long ) < nl > + < nl > + class GroupTable ( tag : Tag ) extends Table [ FullGroupData ] ( tag , " groups " ) { < nl > + def id = column [ Int ] ( " id " , O . PrimaryKey ) < nl > + < nl > + def creatorUserId = column [ Int ] ( " creator _ user _ id " ) < nl > + < nl > + def accessHash = column [ Long ] ( " access _ hash " ) < nl > + < nl > + def title = column [ String ] ( " title " ) < nl > + < nl > + def createdAt = column [ DateTime ] ( " created _ at " ) < nl > + < nl > + def titleChangerUserId = column [ Int ] ( " title _ changer _ user _ id " ) < nl > + < nl > + def titleChangedAt = column [ DateTime ] ( " title _ changed _ at " ) < nl > + < nl > + def titleChangeRandomId = column [ Long ] ( " title _ change _ random _ id " ) < nl > + < nl > + def avatarChangerUserId = column [ Int ] ( " avatar _ changer _ user _ id " ) < nl > + < nl > + def avatarChangedAt = column [ DateTime ] ( " avatar _ changed _ at " ) < nl > + < nl > + def avatarChangeRandomId = column [ Long ] ( " avatar _ change _ random _ id " ) < nl > + < nl > + def * = < nl > + ( id , < nl > + creatorUserId , < nl > + accessHash , < nl > + title , < nl > + createdAt , < nl > + titleChangerUserId , < nl > + titleChangedAt , < nl > + titleChangeRandomId , < nl > + avatarChangerUserId , < nl > + avatarChangedAt , < nl > + avatarChangeRandomId ) < > ( FullGroupData . tupled , FullGroupData . unapply ) < nl > + } < nl > + < nl > + object Group { < nl > + val groups = TableQuery [ GroupTable ] < nl > + < nl > + def create ( group : models . Group , randomId : Long ) = { < nl > + groups + = FullGroupData ( < nl > + id = group . id , < nl > + creatorUserId = group . creatorUserId , < nl > + accessHash = group . accessHash , < nl > + title = group . title , < nl > + createdAt = group . createdAt , < nl > + titleChangerUserId = group . creatorUserId , < nl > + titleChangedAt = group . createdAt , < nl > + titleChangeRandomId = randomId , < nl > + avatarChangerUserId = group . creatorUserId , < nl > + avatarChangedAt = group . createdAt , < nl > + avatarChangeRandomId = randomId ) < nl > + } < nl > + } < nl > diff - - git a / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala b / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala < nl > new file mode 100644 < nl > index 0000000 . . f5b95c4 < nl > - - - / dev / null < nl > + + + b / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala < nl > @ @ - 0 , 0 + 1 , 29 @ @ < nl > + package im . actor . server . persist < nl > + < nl > + import com . github . tototoshi . slick . PostgresJodaSupport . _ < nl > + import org . joda . time . DateTime < nl > + import slick . driver . PostgresDriver . api . _ < nl > + < nl > + import im . actor . server . models < nl > + < nl > + class GroupUsersTable ( tag : Tag ) extends Table [ models . GroupUser ] ( tag , " group _ users " ) { < nl > + def groupId = column [ Int ] ( " group _ id " , O . PrimaryKey ) < nl > + < nl > + def userId = column [ Int ] ( " user _ id " , O . PrimaryKey ) < nl > + < nl > + def inviterUserId = column [ Int ] ( " inviter _ user _ id " ) < nl > + < nl > + def invitedAt = column [ DateTime ] ( " invited _ at " ) < nl > + < nl > + def * = ( groupId , userId , inviterUserId , invitedAt ) < > ( models . GroupUser . tupled , models . GroupUser . unapply ) < nl > + } < nl > + < nl > + object GroupUser { < nl > + val groupUsers = TableQuery [ GroupUsersTable ] < nl > + < nl > + def create ( groupId : Int , userId : Int , inviterUserId : Int , invitedAt : DateTime ) = < nl > + groupUsers + = models . GroupUser ( groupId , userId , inviterUserId , invitedAt ) < nl > + < nl > + def create ( groupId : Int , userIds : Set [ Int ] , inviterUserId : Int , invitedAt : DateTime ) = < nl > + groupUsers + + = userIds . map ( models . GroupUser ( groupId , _ , inviterUserId , invitedAt ) ) < nl > + } < nl > diff - - git a / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala b / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > index b88fca6 . . 93371e1 100644 < nl > - - - a / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > + + + b / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > @ @ - 110 , 6 + 110 , 21 @ @ object SeqUpdatesManager { < nl > } yield ownseqstate < nl > } < nl > < nl > + def notifyClientUpdate ( region : ActorRef , < nl > + update : api . Update ) < nl > + ( implicit < nl > + client : api . AuthorizedClientData , < nl > + ec : ExecutionContext ) : DBIO [ Seq [ SequenceState ] ] = { < nl > + val header = update . header < nl > + val serializedData = update . toByteArray < nl > + val ( userIds , groupIds ) = updateRefs ( update ) < nl > + < nl > + for { < nl > + otherAuthIds < - p . AuthId . findIdByUserId ( client . userId ) . map ( _ . view . filter ( _ ! = client . authId ) ) < nl > + seqstates < - DBIO . sequence ( otherAuthIds map ( authId = > persistAndPushUpdate ( region , authId , header , serializedData , userIds , groupIds ) ) ) < nl > + } yield seqstates < nl > + } < nl > + < nl > def getDifference ( authId : Long , state : Array [ Byte ] ) ( implicit ec : ExecutionContext ) = { < nl > val timestamp = bytesToTimestamp ( state ) < nl > for ( updates < - p . sequence . SeqUpdate . findAfter ( authId , timestamp , MaxDifferenceUpdates + 1 ) ) < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > new file mode 100644 < nl > index 0000000 . . 057cb0d < nl > - - - / dev / null < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > @ @ - 0 , 0 + 1 , 73 @ @ < nl > + package im . actor . server . api . rpc . service . groups < nl > + < nl > + import scala . concurrent . forkjoin . ThreadLocalRandom < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + < nl > + import akka . actor . { ActorRef , ActorSystem } < nl > + import org . joda . time . DateTime < nl > + import slick . driver . PostgresDriver . api . _ < nl > + < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . files . FileLocation < nl > + import im . actor . api . rpc . groups . { GroupsService , ResponseCreateGroup , ResponseEditGroupAvatar , UpdateGroupInvite } < nl > + import im . actor . api . rpc . misc . ResponseSeqDate < nl > + import im . actor . api . rpc . peers . { GroupOutPeer , UserOutPeer } < nl > + import im . actor . server . api . util . PeerUtils . _ < nl > + import im . actor . server . push . SeqUpdatesManager . _ < nl > + import im . actor . server . { models , persist } < nl > + < nl > + class GroupsServiceImpl ( seqUpdManagerRegion : ActorRef ) ( < nl > + implicit val db : Database , val actorSystem : ActorSystem < nl > + ) extends GroupsService { < nl > + override implicit val ec : ExecutionContext = actorSystem . dispatcher < nl > + < nl > + override def jhandleEditGroupAvatar ( groupPeer : GroupOutPeer , randomId : Long , fileLocation : FileLocation , clientData : ClientData ) : Future [ HandlerResult [ ResponseEditGroupAvatar ] ] = ? ? ? < nl > + < nl > + override def jhandleKickUser ( groupPeer : GroupOutPeer , randomId : Long , user : UserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? < nl > + < nl > + override def jhandleLeaveGroup ( groupPeer : GroupOutPeer , randomId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? < nl > + < nl > + override def jhandleCreateGroup ( randomId : Long , title : String , users : Vector [ UserOutPeer ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseCreateGroup ] ] = { < nl > + val authorizedAction = requireAuth ( clientData ) . map { implicit client = > < nl > + withUserOutPeers ( users ) { < nl > + val dateTime = new DateTime ( ) < nl > + val rnd = ThreadLocalRandom . current ( ) < nl > + < nl > + val group = models . Group ( < nl > + id = rnd . nextInt ( ) , < nl > + creatorUserId = client . userId , < nl > + accessHash = rnd . nextLong ( ) , < nl > + title = title , < nl > + createdAt = dateTime ) < nl > + < nl > + val userIds = users . map ( _ . userId ) . toSet < nl > + val groupUserIds = userIds + client . userId < nl > + < nl > + val update = UpdateGroupInvite ( groupId = group . id , inviteUserId = client . userId , date = dateTime . getMillis , randomId = randomId ) < nl > + < nl > + for { < nl > + _ < - persist . Group . create ( group , randomId ) < nl > + _ < - persist . GroupUser . create ( group . id , userIds , client . userId , dateTime ) < nl > + / / TODO : write service message groupCreated < nl > + _ < - DBIO . sequence ( userIds . map ( userId = > broadcastUserUpdate ( seqUpdManagerRegion , userId , update ) ) . toSeq ) < nl > + seqstate < - broadcastClientUpdate ( seqUpdManagerRegion , update ) < nl > + } yield { < nl > + Ok ( ResponseCreateGroup ( < nl > + groupPeer = GroupOutPeer ( group . id , group . accessHash ) , < nl > + seq = seqstate . _ 1 , < nl > + state = seqstate . _ 2 , < nl > + users = groupUserIds . toVector , < nl > + date = dateTime . getMillis ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + db . run ( toDBIOAction ( authorizedAction map ( _ . transactionally ) ) ) < nl > + } < nl > + < nl > + override def jhandleRemoveGroupAvatar ( groupPeer : GroupOutPeer , randomId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? < nl > + < nl > + override def jhandleInviteUser ( groupPeer : GroupOutPeer , randomId : Long , user : UserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? < nl > + < nl > + override def jhandleEditGroupTitle ( groupPeer : GroupOutPeer , randomId : Long , title : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? < nl > + } < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > index d822fbf . . 15e330c 100644 < nl > - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala < nl > @ @ - 6 , 8 + 6 , 9 @ @ import org . joda . time . DateTime < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . api . rpc . _ , im . actor . api . rpc . messaging . _ , im . actor . api . rpc . misc . _ , im . actor . api . rpc . peers . _ , Implicits . _ < nl > + import im . actor . server . api . util . PeerUtils . _ < nl > < nl > - private [ messaging ] trait MessagingHandlers extends PeerHelpers { < nl > + private [ messaging ] trait MessagingHandlers { < nl > self : MessagingServiceImpl = > < nl > < nl > import im . actor . server . push . SeqUpdatesManager . _ < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / PeerHelpers . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / PeerHelpers . scala < nl > deleted file mode 100644 < nl > index 60a6f61 . . 0000000 < nl > - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / PeerHelpers . scala < nl > + + + / dev / null < nl > @ @ - 1 , 50 + 0 , 0 @ @ < nl > - package im . actor . server . api . rpc . service . messaging < nl > - < nl > - import scala . concurrent . ExecutionContext < nl > - < nl > - import akka . actor . _ < nl > - import scalaz . _ , std . either . _ < nl > - import slick . dbio . { DBIO , DBIOAction , Effect } < nl > - import slick . driver . PostgresDriver . api . _ < nl > - < nl > - import im . actor . api . rpc . _ , peers . _ < nl > - import im . actor . server . api . util < nl > - import im . actor . server . models < nl > - import im . actor . server . persist < nl > - < nl > - trait PeerHelpers { < nl > - protected def withOutPeer [ R < : RpcResponse , E < : Effect ] ( < nl > - clientUserId : Int , < nl > - outPeer : OutPeer < nl > - ) ( < nl > - f : = > DBIO [ RpcError \ / R ] < nl > - ) ( implicit client : AuthorizedClientData , ec : ExecutionContext , s : ActorSystem ) : DBIO [ RpcError \ / R ] = { < nl > - outPeer . ` type ` match { < nl > - case PeerType . Private = > < nl > - ( for { < nl > - optUser < - persist . User . find ( outPeer . id ) . headOption < nl > - usererrOrUser < - validUser ( optUser ) < nl > - hasherrOrUser < - DBIO . successful ( usererrOrUser . map ( validUserAccessHash ( outPeer . accessHash , _ ) ) ) < nl > - } yield hasherrOrUser ) . flatMap { < nl > - case Error ( err ) = > DBIO . successful ( Error ( err ) ) < nl > - case _ = > f < nl > - } < nl > - } < nl > - } < nl > - < nl > - private def validUser ( optUser : Option [ models . User ] ) ( implicit s : ActorSystem ) = { < nl > - optUser match { < nl > - case Some ( user ) = > < nl > - DBIO . successful ( \ / - ( user ) ) < nl > - case None = > DBIO . successful ( Error ( CommonErrors . UserNotFound ) ) < nl > - } < nl > - } < nl > - < nl > - private def validUserAccessHash ( accessHash : Long , user : models . User ) ( implicit client : BaseClientData , s : ActorSystem ) = { < nl > - if ( accessHash = = util . ACL . userAccessHash ( client . authId , user ) ) { < nl > - \ / - ( user ) < nl > - } else { < nl > - Error ( CommonErrors . InvalidAccessHash ) < nl > - } < nl > - } < nl > - } < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / util / PeerUtils . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / util / PeerUtils . scala < nl > new file mode 100644 < nl > index 0000000 . . 95f6f7f < nl > - - - / dev / null < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / util / PeerUtils . scala < nl > @ @ - 0 , 0 + 1 , 97 @ @ < nl > + package im . actor . server . api . util < nl > + < nl > + import scala . concurrent . ExecutionContext < nl > + import scala . collection . immutable < nl > + import scalaz . _ < nl > + < nl > + import akka . actor . _ < nl > + import slick . dbio . { DBIO , Effect } < nl > + < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . peers . _ < nl > + import im . actor . server . api . util < nl > + import im . actor . server . { models , persist } < nl > + < nl > + object PeerUtils { < nl > + def withOutPeer [ R < : RpcResponse ] ( < nl > + clientUserId : Int , < nl > + outPeer : OutPeer < nl > + ) ( < nl > + f : = > DBIO [ RpcError \ / R ] < nl > + ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : DBIO [ RpcError \ / R ] = { < nl > + outPeer . ` type ` match { < nl > + case PeerType . Private = > < nl > + ( for { < nl > + optUser < - persist . User . find ( outPeer . id ) . headOption < nl > + usererrOrUser < - validUser ( optUser ) < nl > + hasherrOrUser < - DBIO . successful ( usererrOrUser . map ( validUserAccessHash ( outPeer . accessHash , _ ) ) ) < nl > + } yield hasherrOrUser ) . flatMap { < nl > + case Error ( err ) = > DBIO . successful ( Error ( err ) ) < nl > + case _ = > f < nl > + } < nl > + } < nl > + } < nl > + < nl > + def withUserOutPeers [ R < : RpcResponse ] ( userOutPeers : immutable . Seq [ UserOutPeer ] ) < nl > + ( f : = > DBIO [ RpcError \ / R ] ) < nl > + ( implicit < nl > + client : AuthorizedClientData , < nl > + actorSystem : ActorSystem , < nl > + ec : ExecutionContext ) : DBIO [ RpcError \ / R ] = { < nl > + val checkOptsFutures = userOutPeers map { < nl > + case UserOutPeer ( userId , accessHash ) = > < nl > + checkUserPeer ( userId , accessHash ) < nl > + } < nl > + < nl > + renderCheckResult ( checkOptsFutures , f ) < nl > + } < nl > + < nl > + private def checkUserPeer ( userId : Int , accessHash : Long ) < nl > + ( implicit < nl > + client : AuthorizedClientData , < nl > + actorSystem : ActorSystem , < nl > + ec : ExecutionContext ) : DBIO [ Option [ Boolean ] ] = { < nl > + for { < nl > + userOpt < - persist . User . find ( userId ) . headOption < nl > + } yield { < nl > + userOpt map ( u = > ACL . userAccessHash ( client . authId , u . id , u . accessSalt ) = = accessHash ) < nl > + } < nl > + } < nl > + / * < nl > + private def checkGroupPeer ( groupId : Int , accessHash : Long ) : DBIO [ Option [ Boolean ] ] = { < nl > + for { < nl > + groupOpt < - persist . Group . find ( groupId ) < nl > + } yield { < nl > + groupOpt map ( _ . accessHash = = accessHash ) < nl > + } < nl > + } * / < nl > + < nl > + private def validUser ( optUser : Option [ models . User ] ) = { < nl > + optUser match { < nl > + case Some ( user ) = > < nl > + DBIO . successful ( \ / - ( user ) ) < nl > + case None = > DBIO . successful ( Error ( CommonErrors . UserNotFound ) ) < nl > + } < nl > + } < nl > + < nl > + private def validUserAccessHash ( accessHash : Long , user : models . User ) ( implicit client : BaseClientData , actorSystem : ActorSystem ) = { < nl > + if ( accessHash = = util . ACL . userAccessHash ( client . authId , user ) ) { < nl > + \ / - ( user ) < nl > + } else { < nl > + Error ( CommonErrors . InvalidAccessHash ) < nl > + } < nl > + } < nl > + < nl > + private def renderCheckResult [ R < : RpcResponse ] ( checkOptsActions : Seq [ DBIO [ Option [ Boolean ] ] ] , f : = > DBIO [ RpcError \ / R ] ) < nl > + ( implicit ec : ExecutionContext ) : DBIO [ RpcError \ / R ] = { < nl > + DBIO . sequence ( checkOptsActions ) flatMap { checkOpts = > < nl > + if ( checkOpts . contains ( None ) ) { < nl > + DBIO . successful ( Error ( RpcError ( 404 , " PEER _ NOT _ FOUND " , " Peer not found . " , false , None ) ) ) < nl > + } else if ( checkOpts . flatten . contains ( false ) ) { < nl > + DBIO . successful ( Error ( RpcError ( 401 , " ACCESS _ HASH _ INVALID " , " Invalid access hash . " , false , None ) ) ) < nl > + } else { < nl > + f < nl > + } < nl > + } < nl > + } < nl > + } < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 63d779e < nl > - - - / dev / null < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > @ @ - 0 , 0 + 1 , 49 @ @ < nl > + package im . actor . server . api . rpc . service < nl > + < nl > + import scala . concurrent . Await < nl > + import scala . concurrent . duration . _ < nl > + import scala . util . Random < nl > + < nl > + import im . actor . api . rpc . ClientData < nl > + import im . actor . api . rpc . groups . { ResponseCreateGroup , UpdateGroupInvite } < nl > + import im . actor . api . rpc . peers . UserOutPeer < nl > + import im . actor . server . api . rpc . service . groups . GroupsServiceImpl < nl > + import im . actor . server . api . util . ACL < nl > + import im . actor . server . persist < nl > + import im . actor . server . push . SeqUpdatesManager < nl > + < nl > + class GroupsServiceSpec extends BaseServiceSuite { < nl > + behavior of " GroupsService " < nl > + < nl > + it should " send invites on group creation " in e1 < nl > + < nl > + val seqUpdManagerRegion = SeqUpdatesManager . startRegion ( ) < nl > + val rpcApiService = buildRpcApiService ( ) < nl > + val sessionRegion = buildSessionRegion ( rpcApiService , seqUpdManagerRegion ) < nl > + < nl > + implicit val service = new GroupsServiceImpl ( seqUpdManagerRegion ) < nl > + implicit val authService = buildAuthService ( sessionRegion ) < nl > + implicit val ec = system . dispatcher < nl > + < nl > + def e1 ( ) = { < nl > + val ( user1 , authId1 , _ ) = createUser ( ) < nl > + val ( user2 , authId2 , _ ) = createUser ( ) < nl > + < nl > + val sessionId = createSessionId ( ) < nl > + < nl > + implicit val clientData = ClientData ( authId1 , sessionId , Some ( user1 . id ) ) < nl > + < nl > + createGroup ( " Fun group " , Set ( user2 . id ) ) < nl > + < nl > + whenReady ( db . run ( persist . sequence . SeqUpdate . find ( authId2 ) . head ) ) { s = > < nl > + s . header should = = = ( UpdateGroupInvite . header ) < nl > + } < nl > + } < nl > + < nl > + private def createGroup ( title : String , userIds : Set [ Int ] ) ( implicit clientData : ClientData ) : ResponseCreateGroup = { < nl > + val users = Await . result ( db . run ( persist . User . findByIds ( userIds ) ) , 5 . seconds ) < nl > + val userPeers = users . map ( user = > UserOutPeer ( user . id , ACL . userAccessHash ( clientData . authId , user ) ) ) < nl > + val result = Await . result ( service . handleCreateGroup ( Random . nextLong ( ) , title , userPeers . toVector ) , 5 . seconds ) < nl > + result . toOption . get < nl > + } < nl > + }

TEST DIFF:
diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / cats / DBIO . scala b / actor - server / actor - persist / src / main / scala / im / actor / cats / DBIO . scala 
 deleted file mode 100644 
 index e9aa6bc . . 0000000 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / cats / DBIO . scala 
 + + + / dev / null 
 @ @ - 1 , 92 + 0 , 0 @ @ 
 - package im . actor . cats 
 - 
 - import cats . _ 
 - import cats . data . Xor 
 - import cats . data . Xor . _ 
 - import cats . syntax . all . _ 
 - import slick . dbio . { DBIO , FailureAction , SuccessAction } 
 - 
 - import scala . concurrent . ExecutionContext 
 - import scala . reflect . ClassTag 
 - 
 - object dbio extends DBIOInstances 
 - 
 - trait DBIOInstances extends DBIOInstances1 { 
 - 
 - implicit def DBIOInstance ( implicit ec : ExecutionContext ) : MonadError [ DBIO , Throwable ] with CoflatMap [ DBIO ] = 
 - new DBIOCoflatMap with MonadError [ DBIO , Throwable ] { 
 - def pure [ A ] ( x : A ) : DBIO [ A ] = DBIO . successful ( x ) 
 - 
 - override def pureEval [ A ] ( x : Eval [ A ] ) : DBIO [ A ] = DBIO . successful ( x . value ) 
 - 
 - def flatMap [ A , B ] ( fa : DBIO [ A ] ) ( f : A ⇒ DBIO [ B ] ) : DBIO [ B ] = fa . flatMap ( f ) 
 - 
 - def handleErrorWith [ A ] ( fea : DBIO [ A ] ) ( f : Throwable ⇒ DBIO [ A ] ) : DBIO [ A ] = 
 - fea flatMap { 
 - case succ : SuccessAction [ _ ] ⇒ succ . asInstanceOf [ SuccessAction [ A ] ] 
 - case FailureAction ( t ) ⇒ f ( t ) 
 - } 
 - 
 - def raiseError [ A ] ( e : Throwable ) : DBIO [ A ] = DBIO . failed ( e ) 
 - override def handleError [ A ] ( fea : DBIO [ A ] ) ( f : Throwable ⇒ A ) : DBIO [ A ] = 
 - fea map { 
 - case SuccessAction ( res ) ⇒ res . asInstanceOf [ A ] 
 - case FailureAction ( t ) ⇒ f ( t ) 
 - } 
 - 
 - override def attempt [ A ] ( fa : DBIO [ A ] ) : DBIO [ Throwable Xor A ] = 
 - fa map { 
 - case SuccessAction ( res ) ⇒ right ( res . asInstanceOf [ A ] ) 
 - case FailureAction ( t ) ⇒ left ( t ) 
 - } 
 - 
 - override def recover [ A ] ( fa : DBIO [ A ] ) ( pf : PartialFunction [ Throwable , A ] ) : DBIO [ A ] = 
 - fa map { 
 - case succ : SuccessAction [ _ ] ⇒ succ . asInstanceOf [ A ] 
 - case FailureAction ( t ) ⇒ pf ( t ) 
 - } 
 - 
 - override def recoverWith [ A ] ( fa : DBIO [ A ] ) ( pf : PartialFunction [ Throwable , DBIO [ A ] ] ) : DBIO [ A ] = 
 - fa flatMap { 
 - case succ : SuccessAction [ _ ] ⇒ succ . asInstanceOf [ SuccessAction [ A ] ] 
 - case FailureAction ( t ) ⇒ pf ( t ) 
 - } 
 - 
 - override def map [ A , B ] ( fa : DBIO [ A ] ) ( f : A ⇒ B ) : DBIO [ B ] = fa . map ( f ) 
 - } 
 - 
 - implicit def DBIOGroup [ A : Group ] ( implicit ec : ExecutionContext ) : Group [ DBIO [ A ] ] = 
 - new DBIOGroup [ A ] 
 - } 
 - 
 - private [ cats ] sealed trait DBIOInstances1 extends DBIOInstances2 { 
 - implicit def DBIOMonoid [ A : Monoid ] ( implicit ec : ExecutionContext ) : Monoid [ DBIO [ A ] ] = 
 - new DBIOMonoid [ A ] 
 - } 
 - 
 - private [ cats ] sealed trait DBIOInstances2 { 
 - implicit def DBIOSemigroup [ A : Semigroup ] ( implicit ec : ExecutionContext ) : Semigroup [ DBIO [ A ] ] = 
 - new DBIOSemigroup [ A ] 
 - } 
 - 
 - private [ cats ] abstract class DBIOCoflatMap ( implicit ec : ExecutionContext ) extends CoflatMap [ DBIO ] { 
 - def map [ A , B ] ( fa : DBIO [ A ] ) ( f : A ⇒ B ) : DBIO [ B ] = fa . map ( f ) 
 - def coflatMap [ A , B ] ( fa : DBIO [ A ] ) ( f : DBIO [ A ] ⇒ B ) : DBIO [ B ] = DBIO . successful ( f ( fa ) ) 
 - } 
 - 
 - private [ cats ] class DBIOSemigroup [ A : Semigroup ] ( implicit ec : ExecutionContext ) extends Semigroup [ DBIO [ A ] ] { 
 - def combine ( fx : DBIO [ A ] , fy : DBIO [ A ] ) : DBIO [ A ] = 
 - ( fx zip fy ) . map { case ( x , y ) ⇒ x | + | y } 
 - } 
 - 
 - private [ cats ] class DBIOMonoid [ A ] ( implicit A : Monoid [ A ] , ec : ExecutionContext ) extends DBIOSemigroup [ A ] with Monoid [ DBIO [ A ] ] { 
 - def empty : DBIO [ A ] = 
 - DBIO . successful ( A . empty ) 
 - } 
 - 
 - private [ cats ] class DBIOGroup [ A ] ( implicit A : Group [ A ] , ec : ExecutionContext ) extends DBIOMonoid [ A ] with Group [ DBIO [ A ] ] { 
 - def inverse ( fx : DBIO [ A ] ) : DBIO [ A ] = 
 - fx . map ( _ . inverse ) 
 - override def remove ( fx : DBIO [ A ] , fy : DBIO [ A ] ) : DBIO [ A ] = 
 - ( fx zip fy ) . map { case ( x , y ) ⇒ x | - | y } 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index fbd130e . . 9dd0ae7 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import sbt . _ 
 
 object Dependencies { 
 object V { 
 - val actorCommons = " 0 . 0 . 9 " 
 + val actorCommons = " 0 . 0 . 11 " 
 val actorBotkit = " 1 . 0 . 66 " 
 val akka = " 2 . 4 . 0 " 
 val akkaExperimental = " 2 . 0 . 2 " 
 @ @ - 22 , 6 + 22 , 7 @ @ object Dependencies { 
 
 object Compile { 
 val actorConcurrent = " im . actor " % % " actor - concurrent " % V . actorCommons 
 + val actorUtil = " im . actor " % % " actor - util " % V . actorCommons 
 val actorBotkit = " im . actor " % " actor - botkit " % V . actorBotkit 
 val shardakka = " im . actor " % % " shardakka " % V . shardakka 
 val scalapbSer = " im . actor " % % " akka - scalapb - serialization " % V . scalapbSer 
 @ @ - 133 , 6 + 134 , 7 @ @ object Dependencies { 
 
 val shared = Seq ( 
 configs , 
 + actorUtil , 
 javaCompat , 
 logbackClassic , 
 scalaLogging ,

NEAREST DIFF:
diff - - git a / actor - models / src / main / scala / im / actor / server / models / GroupUser . scala b / actor - models / src / main / scala / im / actor / server / models / GroupUser . scala 
 new file mode 100644 
 index 0000000 . . f9bd06e 
 - - - / dev / null 
 + + + b / actor - models / src / main / scala / im / actor / server / models / GroupUser . scala 
 @ @ - 0 , 0 + 1 , 5 @ @ 
 + package im . actor . server . models 
 + 
 + import org . joda . time . DateTime 
 + 
 + case class GroupUser ( groupId : Int , userId : Int , inviterUserId : Int , invitedAt : DateTime ) 
 diff - - git a / actor - persist / src / main / scala / im / actor / server / persist / Group . scala b / actor - persist / src / main / scala / im / actor / server / persist / Group . scala 
 new file mode 100644 
 index 0000000 . . c276eaa 
 - - - / dev / null 
 + + + b / actor - persist / src / main / scala / im / actor / server / persist / Group . scala 
 @ @ - 0 , 0 + 1 , 75 @ @ 
 + package im . actor . server . persist 
 + 
 + import com . github . tototoshi . slick . PostgresJodaSupport . _ 
 + import org . joda . time . DateTime 
 + import slick . driver . PostgresDriver . api . _ 
 + 
 + import im . actor . server . models 
 + 
 + private [ persist ] case class FullGroupData ( id : Int , 
 + creatorUserId : Int , 
 + accessHash : Long , 
 + title : String , 
 + createdAt : DateTime , 
 + titleChangerUserId : Int , 
 + titleChangedAt : DateTime , 
 + titleChangeRandomId : Long , 
 + avatarChangerUserId : Int , 
 + avatarChangedAt : DateTime , 
 + avatarChangeRandomId : Long ) 
 + 
 + class GroupTable ( tag : Tag ) extends Table [ FullGroupData ] ( tag , " groups " ) { 
 + def id = column [ Int ] ( " id " , O . PrimaryKey ) 
 + 
 + def creatorUserId = column [ Int ] ( " creator _ user _ id " ) 
 + 
 + def accessHash = column [ Long ] ( " access _ hash " ) 
 + 
 + def title = column [ String ] ( " title " ) 
 + 
 + def createdAt = column [ DateTime ] ( " created _ at " ) 
 + 
 + def titleChangerUserId = column [ Int ] ( " title _ changer _ user _ id " ) 
 + 
 + def titleChangedAt = column [ DateTime ] ( " title _ changed _ at " ) 
 + 
 + def titleChangeRandomId = column [ Long ] ( " title _ change _ random _ id " ) 
 + 
 + def avatarChangerUserId = column [ Int ] ( " avatar _ changer _ user _ id " ) 
 + 
 + def avatarChangedAt = column [ DateTime ] ( " avatar _ changed _ at " ) 
 + 
 + def avatarChangeRandomId = column [ Long ] ( " avatar _ change _ random _ id " ) 
 + 
 + def * = 
 + ( id , 
 + creatorUserId , 
 + accessHash , 
 + title , 
 + createdAt , 
 + titleChangerUserId , 
 + titleChangedAt , 
 + titleChangeRandomId , 
 + avatarChangerUserId , 
 + avatarChangedAt , 
 + avatarChangeRandomId ) < > ( FullGroupData . tupled , FullGroupData . unapply ) 
 + } 
 + 
 + object Group { 
 + val groups = TableQuery [ GroupTable ] 
 + 
 + def create ( group : models . Group , randomId : Long ) = { 
 + groups + = FullGroupData ( 
 + id = group . id , 
 + creatorUserId = group . creatorUserId , 
 + accessHash = group . accessHash , 
 + title = group . title , 
 + createdAt = group . createdAt , 
 + titleChangerUserId = group . creatorUserId , 
 + titleChangedAt = group . createdAt , 
 + titleChangeRandomId = randomId , 
 + avatarChangerUserId = group . creatorUserId , 
 + avatarChangedAt = group . createdAt , 
 + avatarChangeRandomId = randomId ) 
 + } 
 + } 
 diff - - git a / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala b / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala 
 new file mode 100644 
 index 0000000 . . f5b95c4 
 - - - / dev / null 
 + + + b / actor - persist / src / main / scala / im / actor / server / persist / GroupUser . scala 
 @ @ - 0 , 0 + 1 , 29 @ @ 
 + package im . actor . server . persist 
 + 
 + import com . github . tototoshi . slick . PostgresJodaSupport . _ 
 + import org . joda . time . DateTime 
 + import slick . driver . PostgresDriver . api . _ 
 + 
 + import im . actor . server . models 
 + 
 + class GroupUsersTable ( tag : Tag ) extends Table [ models . GroupUser ] ( tag , " group _ users " ) { 
 + def groupId = column [ Int ] ( " group _ id " , O . PrimaryKey ) 
 + 
 + def userId = column [ Int ] ( " user _ id " , O . PrimaryKey ) 
 + 
 + def inviterUserId = column [ Int ] ( " inviter _ user _ id " ) 
 + 
 + def invitedAt = column [ DateTime ] ( " invited _ at " ) 
 + 
 + def * = ( groupId , userId , inviterUserId , invitedAt ) < > ( models . GroupUser . tupled , models . GroupUser . unapply ) 
 + } 
 + 
 + object GroupUser { 
 + val groupUsers = TableQuery [ GroupUsersTable ] 
 + 
 + def create ( groupId : Int , userId : Int , inviterUserId : Int , invitedAt : DateTime ) = 
 + groupUsers + = models . GroupUser ( groupId , userId , inviterUserId , invitedAt ) 
 + 
 + def create ( groupId : Int , userIds : Set [ Int ] , inviterUserId : Int , invitedAt : DateTime ) = 
 + groupUsers + + = userIds . map ( models . GroupUser ( groupId , _ , inviterUserId , invitedAt ) ) 
 + } 
 diff - - git a / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala b / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 index b88fca6 . . 93371e1 100644 
 - - - a / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 + + + b / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 @ @ - 110 , 6 + 110 , 21 @ @ object SeqUpdatesManager { 
 } yield ownseqstate 
 } 
 
 + def notifyClientUpdate ( region : ActorRef , 
 + update : api . Update ) 
 + ( implicit 
 + client : api . AuthorizedClientData , 
 + ec : ExecutionContext ) : DBIO [ Seq [ SequenceState ] ] = { 
 + val header = update . header 
 + val serializedData = update . toByteArray 
 + val ( userIds , groupIds ) = updateRefs ( update ) 
 + 
 + for { 
 + otherAuthIds < - p . AuthId . findIdByUserId ( client . userId ) . map ( _ . view . filter ( _ ! = client . authId ) ) 
 + seqstates < - DBIO . sequence ( otherAuthIds map ( authId = > persistAndPushUpdate ( region , authId , header , serializedData , userIds , groupIds ) ) ) 
 + } yield seqstates 
 + } 
 + 
 def getDifference ( authId : Long , state : Array [ Byte ] ) ( implicit ec : ExecutionContext ) = { 
 val timestamp = bytesToTimestamp ( state ) 
 for ( updates < - p . sequence . SeqUpdate . findAfter ( authId , timestamp , MaxDifferenceUpdates + 1 ) ) 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 new file mode 100644 
 index 0000000 . . 057cb0d 
 - - - / dev / null 
 + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 @ @ - 0 , 0 + 1 , 73 @ @ 
 + package im . actor . server . api . rpc . service . groups 
 + 
 + import scala . concurrent . forkjoin . ThreadLocalRandom 
 + import scala . concurrent . { ExecutionContext , Future } 
 + 
 + import akka . actor . { ActorRef , ActorSystem } 
 + import org . joda . time . DateTime 
 + import slick . driver . PostgresDriver . api . _ 
 + 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . files . FileLocation 
 + import im . actor . api . rpc . groups . { GroupsService , ResponseCreateGroup , ResponseEditGroupAvatar , UpdateGroupInvite } 
 + import im . actor . api . rpc . misc . ResponseSeqDate 
 + import im . actor . api . rpc . peers . { GroupOutPeer , UserOutPeer } 
 + import im . actor . server . api . util . PeerUtils . _ 
 + import im . actor . server . push . SeqUpdatesManager . _ 
 + import im . actor . server . { models , persist } 
 + 
 + class GroupsServiceImpl ( seqUpdManagerRegion : ActorRef ) ( 
 + implicit val db : Database , val actorSystem : ActorSystem 
 + ) extends GroupsService { 
 + override implicit val ec : ExecutionContext = actorSystem . dispatcher 
 + 
 + override def jhandleEditGroupAvatar ( groupPeer : GroupOutPeer , randomId : Long , fileLocation : FileLocation , clientData : ClientData ) : Future [ HandlerResult [ ResponseEditGroupAvatar ] ] = ? ? ? 
 + 
 + override def jhandleKickUser ( groupPeer : GroupOutPeer , randomId : Long , user : UserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? 
 + 
 + override def jhandleLeaveGroup ( groupPeer : GroupOutPeer , randomId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? 
 + 
 + override def jhandleCreateGroup ( randomId : Long , title : String , users : Vector [ UserOutPeer ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseCreateGroup ] ] = { 
 + val authorizedAction = requireAuth ( clientData ) . map { implicit client = > 
 + withUserOutPeers ( users ) { 
 + val dateTime = new DateTime ( ) 
 + val rnd = ThreadLocalRandom . current ( ) 
 + 
 + val group = models . Group ( 
 + id = rnd . nextInt ( ) , 
 + creatorUserId = client . userId , 
 + accessHash = rnd . nextLong ( ) , 
 + title = title , 
 + createdAt = dateTime ) 
 + 
 + val userIds = users . map ( _ . userId ) . toSet 
 + val groupUserIds = userIds + client . userId 
 + 
 + val update = UpdateGroupInvite ( groupId = group . id , inviteUserId = client . userId , date = dateTime . getMillis , randomId = randomId ) 
 + 
 + for { 
 + _ < - persist . Group . create ( group , randomId ) 
 + _ < - persist . GroupUser . create ( group . id , userIds , client . userId , dateTime ) 
 + / / TODO : write service message groupCreated 
 + _ < - DBIO . sequence ( userIds . map ( userId = > broadcastUserUpdate ( seqUpdManagerRegion , userId , update ) ) . toSeq ) 
 + seqstate < - broadcastClientUpdate ( seqUpdManagerRegion , update ) 
 + } yield { 
 + Ok ( ResponseCreateGroup ( 
 + groupPeer = GroupOutPeer ( group . id , group . accessHash ) , 
 + seq = seqstate . _ 1 , 
 + state = seqstate . _ 2 , 
 + users = groupUserIds . toVector , 
 + date = dateTime . getMillis ) ) 
 + } 
 + } 
 + } 
 + 
 + db . run ( toDBIOAction ( authorizedAction map ( _ . transactionally ) ) ) 
 + } 
 + 
 + override def jhandleRemoveGroupAvatar ( groupPeer : GroupOutPeer , randomId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? 
 + 
 + override def jhandleInviteUser ( groupPeer : GroupOutPeer , randomId : Long , user : UserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? 
 + 
 + override def jhandleEditGroupTitle ( groupPeer : GroupOutPeer , randomId : Long , title : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = ? ? ? 
 + } 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 index d822fbf . . 15e330c 100644 
 - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingHandlers . scala 
 @ @ - 6 , 8 + 6 , 9 @ @ import org . joda . time . DateTime 
 import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . api . rpc . _ , im . actor . api . rpc . messaging . _ , im . actor . api . rpc . misc . _ , im . actor . api . rpc . peers . _ , Implicits . _ 
 + import im . actor . server . api . util . PeerUtils . _ 
 
 - private [ messaging ] trait MessagingHandlers extends PeerHelpers { 
 + private [ messaging ] trait MessagingHandlers { 
 self : MessagingServiceImpl = > 
 
 import im . actor . server . push . SeqUpdatesManager . _ 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / PeerHelpers . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / PeerHelpers . scala 
 deleted file mode 100644 
 index 60a6f61 . . 0000000 
 - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / PeerHelpers . scala 
 + + + / dev / null 
 @ @ - 1 , 50 + 0 , 0 @ @ 
 - package im . actor . server . api . rpc . service . messaging 
 - 
 - import scala . concurrent . ExecutionContext 
 - 
 - import akka . actor . _ 
 - import scalaz . _ , std . either . _ 
 - import slick . dbio . { DBIO , DBIOAction , Effect } 
 - import slick . driver . PostgresDriver . api . _ 
 - 
 - import im . actor . api . rpc . _ , peers . _ 
 - import im . actor . server . api . util 
 - import im . actor . server . models 
 - import im . actor . server . persist 
 - 
 - trait PeerHelpers { 
 - protected def withOutPeer [ R < : RpcResponse , E < : Effect ] ( 
 - clientUserId : Int , 
 - outPeer : OutPeer 
 - ) ( 
 - f : = > DBIO [ RpcError \ / R ] 
 - ) ( implicit client : AuthorizedClientData , ec : ExecutionContext , s : ActorSystem ) : DBIO [ RpcError \ / R ] = { 
 - outPeer . ` type ` match { 
 - case PeerType . Private = > 
 - ( for { 
 - optUser < - persist . User . find ( outPeer . id ) . headOption 
 - usererrOrUser < - validUser ( optUser ) 
 - hasherrOrUser < - DBIO . successful ( usererrOrUser . map ( validUserAccessHash ( outPeer . accessHash , _ ) ) ) 
 - } yield hasherrOrUser ) . flatMap { 
 - case Error ( err ) = > DBIO . successful ( Error ( err ) ) 
 - case _ = > f 
 - } 
 - } 
 - } 
 - 
 - private def validUser ( optUser : Option [ models . User ] ) ( implicit s : ActorSystem ) = { 
 - optUser match { 
 - case Some ( user ) = > 
 - DBIO . successful ( \ / - ( user ) ) 
 - case None = > DBIO . successful ( Error ( CommonErrors . UserNotFound ) ) 
 - } 
 - } 
 - 
 - private def validUserAccessHash ( accessHash : Long , user : models . User ) ( implicit client : BaseClientData , s : ActorSystem ) = { 
 - if ( accessHash = = util . ACL . userAccessHash ( client . authId , user ) ) { 
 - \ / - ( user ) 
 - } else { 
 - Error ( CommonErrors . InvalidAccessHash ) 
 - } 
 - } 
 - } 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / util / PeerUtils . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / util / PeerUtils . scala 
 new file mode 100644 
 index 0000000 . . 95f6f7f 
 - - - / dev / null 
 + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / util / PeerUtils . scala 
 @ @ - 0 , 0 + 1 , 97 @ @ 
 + package im . actor . server . api . util 
 + 
 + import scala . concurrent . ExecutionContext 
 + import scala . collection . immutable 
 + import scalaz . _ 
 + 
 + import akka . actor . _ 
 + import slick . dbio . { DBIO , Effect } 
 + 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . peers . _ 
 + import im . actor . server . api . util 
 + import im . actor . server . { models , persist } 
 + 
 + object PeerUtils { 
 + def withOutPeer [ R < : RpcResponse ] ( 
 + clientUserId : Int , 
 + outPeer : OutPeer 
 + ) ( 
 + f : = > DBIO [ RpcError \ / R ] 
 + ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : DBIO [ RpcError \ / R ] = { 
 + outPeer . ` type ` match { 
 + case PeerType . Private = > 
 + ( for { 
 + optUser < - persist . User . find ( outPeer . id ) . headOption 
 + usererrOrUser < - validUser ( optUser ) 
 + hasherrOrUser < - DBIO . successful ( usererrOrUser . map ( validUserAccessHash ( outPeer . accessHash , _ ) ) ) 
 + } yield hasherrOrUser ) . flatMap { 
 + case Error ( err ) = > DBIO . successful ( Error ( err ) ) 
 + case _ = > f 
 + } 
 + } 
 + } 
 + 
 + def withUserOutPeers [ R < : RpcResponse ] ( userOutPeers : immutable . Seq [ UserOutPeer ] ) 
 + ( f : = > DBIO [ RpcError \ / R ] ) 
 + ( implicit 
 + client : AuthorizedClientData , 
 + actorSystem : ActorSystem , 
 + ec : ExecutionContext ) : DBIO [ RpcError \ / R ] = { 
 + val checkOptsFutures = userOutPeers map { 
 + case UserOutPeer ( userId , accessHash ) = > 
 + checkUserPeer ( userId , accessHash ) 
 + } 
 + 
 + renderCheckResult ( checkOptsFutures , f ) 
 + } 
 + 
 + private def checkUserPeer ( userId : Int , accessHash : Long ) 
 + ( implicit 
 + client : AuthorizedClientData , 
 + actorSystem : ActorSystem , 
 + ec : ExecutionContext ) : DBIO [ Option [ Boolean ] ] = { 
 + for { 
 + userOpt < - persist . User . find ( userId ) . headOption 
 + } yield { 
 + userOpt map ( u = > ACL . userAccessHash ( client . authId , u . id , u . accessSalt ) = = accessHash ) 
 + } 
 + } 
 + / * 
 + private def checkGroupPeer ( groupId : Int , accessHash : Long ) : DBIO [ Option [ Boolean ] ] = { 
 + for { 
 + groupOpt < - persist . Group . find ( groupId ) 
 + } yield { 
 + groupOpt map ( _ . accessHash = = accessHash ) 
 + } 
 + } * / 
 + 
 + private def validUser ( optUser : Option [ models . User ] ) = { 
 + optUser match { 
 + case Some ( user ) = > 
 + DBIO . successful ( \ / - ( user ) ) 
 + case None = > DBIO . successful ( Error ( CommonErrors . UserNotFound ) ) 
 + } 
 + } 
 + 
 + private def validUserAccessHash ( accessHash : Long , user : models . User ) ( implicit client : BaseClientData , actorSystem : ActorSystem ) = { 
 + if ( accessHash = = util . ACL . userAccessHash ( client . authId , user ) ) { 
 + \ / - ( user ) 
 + } else { 
 + Error ( CommonErrors . InvalidAccessHash ) 
 + } 
 + } 
 + 
 + private def renderCheckResult [ R < : RpcResponse ] ( checkOptsActions : Seq [ DBIO [ Option [ Boolean ] ] ] , f : = > DBIO [ RpcError \ / R ] ) 
 + ( implicit ec : ExecutionContext ) : DBIO [ RpcError \ / R ] = { 
 + DBIO . sequence ( checkOptsActions ) flatMap { checkOpts = > 
 + if ( checkOpts . contains ( None ) ) { 
 + DBIO . successful ( Error ( RpcError ( 404 , " PEER _ NOT _ FOUND " , " Peer not found . " , false , None ) ) ) 
 + } else if ( checkOpts . flatten . contains ( false ) ) { 
 + DBIO . successful ( Error ( RpcError ( 401 , " ACCESS _ HASH _ INVALID " , " Invalid access hash . " , false , None ) ) ) 
 + } else { 
 + f 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 new file mode 100644 
 index 0000000 . . 63d779e 
 - - - / dev / null 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 @ @ - 0 , 0 + 1 , 49 @ @ 
 + package im . actor . server . api . rpc . service 
 + 
 + import scala . concurrent . Await 
 + import scala . concurrent . duration . _ 
 + import scala . util . Random 
 + 
 + import im . actor . api . rpc . ClientData 
 + import im . actor . api . rpc . groups . { ResponseCreateGroup , UpdateGroupInvite } 
 + import im . actor . api . rpc . peers . UserOutPeer 
 + import im . actor . server . api . rpc . service . groups . GroupsServiceImpl 
 + import im . actor . server . api . util . ACL 
 + import im . actor . server . persist 
 + import im . actor . server . push . SeqUpdatesManager 
 + 
 + class GroupsServiceSpec extends BaseServiceSuite { 
 + behavior of " GroupsService " 
 + 
 + it should " send invites on group creation " in e1 
 + 
 + val seqUpdManagerRegion = SeqUpdatesManager . startRegion ( ) 
 + val rpcApiService = buildRpcApiService ( ) 
 + val sessionRegion = buildSessionRegion ( rpcApiService , seqUpdManagerRegion ) 
 + 
 + implicit val service = new GroupsServiceImpl ( seqUpdManagerRegion ) 
 + implicit val authService = buildAuthService ( sessionRegion ) 
 + implicit val ec = system . dispatcher 
 + 
 + def e1 ( ) = { 
 + val ( user1 , authId1 , _ ) = createUser ( ) 
 + val ( user2 , authId2 , _ ) = createUser ( ) 
 + 
 + val sessionId = createSessionId ( ) 
 + 
 + implicit val clientData = ClientData ( authId1 , sessionId , Some ( user1 . id ) ) 
 + 
 + createGroup ( " Fun group " , Set ( user2 . id ) ) 
 + 
 + whenReady ( db . run ( persist . sequence . SeqUpdate . find ( authId2 ) . head ) ) { s = > 
 + s . header should = = = ( UpdateGroupInvite . header ) 
 + } 
 + } 
 + 
 + private def createGroup ( title : String , userIds : Set [ Int ] ) ( implicit clientData : ClientData ) : ResponseCreateGroup = { 
 + val users = Await . result ( db . run ( persist . User . findByIds ( userIds ) ) , 5 . seconds ) 
 + val userPeers = users . map ( user = > UserOutPeer ( user . id , ACL . userAccessHash ( clientData . authId , user ) ) ) 
 + val result = Await . result ( service . handleCreateGroup ( Random . nextLong ( ) , title , userPeers . toVector ) , 5 . seconds ) 
 + result . toOption . get 
 + } 
 + }
