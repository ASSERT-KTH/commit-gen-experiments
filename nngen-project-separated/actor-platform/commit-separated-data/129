BLEU SCORE: 0.15851165692617147

TEST MSG: fix ( server : persist ) : ignore case for nickname storage
GENERATED MSG: feat ( server : shardakka ) : store all kvs map

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala < nl > index 261cf44 . . a24cc6b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala < nl > @ @ - 10 , 9 + 10 , 9 @ @ import slick . dbio . _ < nl > import scala . concurrent . Future < nl > < nl > / * * < nl > - * Stores mapping " Global name " - > " Global name owner ( group / user ) " < nl > - * global name : String < nl > - * global name owner : GlobalNameOwner < nl > + * Stores mapping " Normalized global name " - > " Global name owner ( group / user ) " < nl > + * normalized global name : String < nl > + * global name owner : im . actor . server . names . GlobalNameOwner < nl > * / < nl > private object GlobalNamesStorage extends SimpleStorage ( " global _ names " ) < nl > < nl > @ @ - 43 , 7 + 43 , 7 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { < nl > * Compatible with storing nicknames in ` im . actor . server . persist . UserRepo ` < nl > * / < nl > def exists ( name : String ) : Future [ Boolean ] = { < nl > - val existsInKV = conn . run ( GlobalNamesStorage . get ( name ) ) map ( _ . isDefined ) < nl > + val existsInKV = conn . run ( GlobalNamesStorage . get ( normalized ( name ) ) ) map ( _ . isDefined ) < nl > < nl > existsInKV flatMap { < nl > case true ⇒ FastFuture . successful ( true ) < nl > @ @ - 70 , 10 + 70 , 9 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { < nl > * / < nl > private def getOwner ( name : String ) : Future [ Option [ GlobalNameOwner ] ] = { < nl > val optOwner = conn . run ( < nl > - GlobalNamesStorage . get ( name ) < nl > - ) map { optBytes ⇒ < nl > - optBytes map GlobalNameOwner . parseFrom < nl > - } < nl > + GlobalNamesStorage . get ( normalized ( name ) ) < nl > + ) map { _ map GlobalNameOwner . parseFrom } < nl > + < nl > optOwner flatMap { < nl > case o @ Some ( _ ) ⇒ FastFuture . successful ( o ) < nl > case None ⇒ db . run ( UserRepo . findByNickname ( name ) ) map ( _ . map ( u ⇒ GlobalNameOwner ( OwnerType . User , u . id ) ) ) < nl > @ @ - 82 , 17 + 81 , 17 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { < nl > < nl > private def upsert ( name : String , owner : GlobalNameOwner ) : Future [ Unit ] = < nl > conn . run ( < nl > - GlobalNamesStorage . upsert ( name , owner . toByteArray ) < nl > + GlobalNamesStorage . upsert ( normalized ( name ) , owner . toByteArray ) < nl > ) map ( _ ⇒ ( ) ) < nl > < nl > / * * < nl > * Compatible with storing nicknames in ` im . actor . server . persist . UserRepo ` < nl > * / < nl > private def delete ( name : String ) : Future [ Unit ] = { < nl > - val kvDelete = conn . run ( GlobalNamesStorage . delete ( name ) ) < nl > + val kvDelete = conn . run ( GlobalNamesStorage . delete ( normalized ( name ) ) ) < nl > < nl > kvDelete flatMap { count ⇒ < nl > - if ( count > 0 ) { < nl > + if ( count = = 0 ) { < nl > db . run { < nl > for { < nl > optUser ← UserRepo . findByNickname ( name ) < nl > @ @ - 107 , 4 + 106 , 7 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { < nl > } < nl > } < nl > } < nl > + < nl > + private def normalized ( name : String ) = name . toLowerCase < nl > + < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala < nl > index 962b4c1 . . a8d6dfc 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala < nl > + + + b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala < nl > @ @ - 7 , 6 + 7 , 7 @ @ import akka . util . Timeout < nl > import im . actor . server . commons . serialization . ActorSerializer < nl > import shardakka . { StringCodec , Codec , ShardakkaExtension } < nl > < nl > + import scala . collection . immutable < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > private case object End < nl > @ @ - 29 , 7 + 30 , 7 @ @ case class SimpleKeyValue [ A ] ( < nl > def getKeys ( ) ( implicit ec : ExecutionContext , timeout : Timeout ) : Future [ Seq [ String ] ] = < nl > ( proxy ? RootQueries . GetKeys ( ) ) . mapTo [ RootQueries . GetKeysResponse ] map ( _ . keys ) < nl > < nl > - def shutdown ( ) : Unit = { < nl > + private [ keyvalue ] def shutdown ( ) : Unit = { < nl > proxy ! End < nl > root ! PoisonPill < nl > proxy ! PoisonPill < nl > @ @ - 56 , 25 + 57 , 39 @ @ trait SimpleKeyValueExtension { < nl > ActorSerializer . register ( 15001 , classOf [ ValueEvents . ValueUpdated ] ) < nl > ActorSerializer . register ( 15002 , classOf [ ValueEvents . ValueDeleted ] ) < nl > < nl > - def startKeyValue [ A ] ( name : String , codec : Codec [ A ] ) ( implicit system : ActorSystem ) : SimpleKeyValue [ A ] = { < nl > - val manager = system . actorOf ( < nl > - ClusterSingletonManager . props ( < nl > - singletonProps = SimpleKeyValueRoot . props ( name ) , < nl > - singletonName = name , < nl > - terminationMessage = End , < nl > - role = None < nl > - ) , name = s " SimpleKeyValueRoot - $ name " < nl > - ) < nl > - < nl > - val proxy = system . actorOf ( < nl > - ClusterSingletonProxy . props ( singletonPath = s " / user / SimpleKeyValueRoot - $ name / $ name " , role = None ) , < nl > - name = s " SimpleKeyValueRoot - $ name - Proxy " < nl > - ) < nl > - < nl > - SimpleKeyValue ( name , manager , proxy , codec ) < nl > + @ volatile < nl > + private var kvs = immutable . Map . empty [ String , SimpleKeyValue [ _ ] ] < nl > + < nl > + def simpleKeyValue [ A ] ( name : String , codec : Codec [ A ] ) ( implicit system : ActorSystem ) : SimpleKeyValue [ A ] = { < nl > + kvs . get ( name ) match { < nl > + case Some ( kv ) ⇒ kv . asInstanceOf [ SimpleKeyValue [ A ] ] < nl > + case None ⇒ < nl > + val manager = system . actorOf ( < nl > + ClusterSingletonManager . props ( < nl > + singletonProps = SimpleKeyValueRoot . props ( name ) , < nl > + singletonName = name , < nl > + terminationMessage = End , < nl > + role = None < nl > + ) , name = s " SimpleKeyValueRoot - $ name " < nl > + ) < nl > + < nl > + val proxy = system . actorOf ( < nl > + ClusterSingletonProxy . props ( singletonPath = s " / user / SimpleKeyValueRoot - $ name / $ name " , role = None ) , < nl > + name = s " SimpleKeyValueRoot - $ name - Proxy " < nl > + ) < nl > + < nl > + val kv = SimpleKeyValue ( name , manager , proxy , codec ) < nl > + kvs + = ( name → kv ) < nl > + kv < nl > + } < nl > } < nl > < nl > - def startKeyValueString ( name : String ) ( implicit system : ActorSystem ) : SimpleKeyValue [ String ] = < nl > - startKeyValue ( name , StringCodec ) < nl > + def simpleKeyValue ( name : String ) ( implicit system : ActorSystem ) : SimpleKeyValue [ String ] = < nl > + simpleKeyValue ( name , StringCodec ) < nl > + < nl > + def shutdownKeyValue ( name : String ) = kvs . get ( name ) foreach { kv ⇒ < nl > + kv . shutdown ( ) < nl > + kvs - = name < nl > + } < nl > } < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala b / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala < nl > index d2e5c52 . . e6eddd9 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala < nl > @ @ - 32 , 7 + 32 , 7 @ @ final class KeyValueSpec extends ActorSuite ( ActorSpecification . createSystem ( ) ) < nl > val ext = ShardakkaExtension ( system ) < nl > < nl > def setAndGet ( ) = { < nl > - val keyValue = ext . startKeyValueString ( " setAndGet " ) < nl > + val keyValue = ext . simpleKeyValue ( " setAndGet " ) < nl > < nl > whenReady ( keyValue . get ( " key1 " ) ) { resp ⇒ < nl > resp shouldBe empty < nl > @ @ - 46 , 7 + 46 , 7 @ @ final class KeyValueSpec extends ActorSuite ( ActorSpecification . createSystem ( ) ) < nl > } < nl > < nl > def keysList ( ) = { < nl > - val keyValue = ext . startKeyValueString ( " keysList " ) < nl > + val keyValue = ext . simpleKeyValue ( " keysList " ) < nl > < nl > whenReady ( Future . sequence ( Seq ( < nl > keyValue . upsert ( " key1 " , " value " ) , < nl > @ @ - 55 , 21 + 55 , 21 @ @ final class KeyValueSpec extends ActorSuite ( ActorSpecification . createSystem ( ) ) < nl > ) ) ) ( identity ) < nl > < nl > whenReady ( keyValue . getKeys ( ) ) { keys ⇒ < nl > - keys shouldBe Seq ( " key1 " , " key2 " , " key3 " ) < nl > + keys . toSet shouldBe Set ( " key1 " , " key2 " , " key3 " ) < nl > } < nl > } < nl > < nl > def restoreState ( ) = { < nl > val kvName = " restoreState " < nl > < nl > - val keyValue = ext . startKeyValueString ( kvName ) < nl > + val keyValue = ext . simpleKeyValue ( kvName ) < nl > < nl > whenReady ( keyValue . upsert ( " key1 " , " value " ) ) ( identity ) < nl > < nl > - keyValue . shutdown ( ) < nl > + ext . shutdownKeyValue ( kvName ) < nl > Thread . sleep ( 200 ) < nl > < nl > - val keyValueNew = ext . startKeyValueString ( kvName ) < nl > + val keyValueNew = ext . simpleKeyValue ( kvName ) < nl > < nl > whenReady ( keyValueNew . get ( " key1 " ) ) { resp ⇒ < nl > resp shouldBe Some ( " value " )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala 
 index 261cf44 . . a24cc6b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala 
 @ @ - 10 , 9 + 10 , 9 @ @ import slick . dbio . _ 
 import scala . concurrent . Future 
 
 / * * 
 - * Stores mapping " Global name " - > " Global name owner ( group / user ) " 
 - * global name : String 
 - * global name owner : GlobalNameOwner 
 + * Stores mapping " Normalized global name " - > " Global name owner ( group / user ) " 
 + * normalized global name : String 
 + * global name owner : im . actor . server . names . GlobalNameOwner 
 * / 
 private object GlobalNamesStorage extends SimpleStorage ( " global _ names " ) 
 
 @ @ - 43 , 7 + 43 , 7 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { 
 * Compatible with storing nicknames in ` im . actor . server . persist . UserRepo ` 
 * / 
 def exists ( name : String ) : Future [ Boolean ] = { 
 - val existsInKV = conn . run ( GlobalNamesStorage . get ( name ) ) map ( _ . isDefined ) 
 + val existsInKV = conn . run ( GlobalNamesStorage . get ( normalized ( name ) ) ) map ( _ . isDefined ) 
 
 existsInKV flatMap { 
 case true ⇒ FastFuture . successful ( true ) 
 @ @ - 70 , 10 + 70 , 9 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { 
 * / 
 private def getOwner ( name : String ) : Future [ Option [ GlobalNameOwner ] ] = { 
 val optOwner = conn . run ( 
 - GlobalNamesStorage . get ( name ) 
 - ) map { optBytes ⇒ 
 - optBytes map GlobalNameOwner . parseFrom 
 - } 
 + GlobalNamesStorage . get ( normalized ( name ) ) 
 + ) map { _ map GlobalNameOwner . parseFrom } 
 + 
 optOwner flatMap { 
 case o @ Some ( _ ) ⇒ FastFuture . successful ( o ) 
 case None ⇒ db . run ( UserRepo . findByNickname ( name ) ) map ( _ . map ( u ⇒ GlobalNameOwner ( OwnerType . User , u . id ) ) ) 
 @ @ - 82 , 17 + 81 , 17 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { 
 
 private def upsert ( name : String , owner : GlobalNameOwner ) : Future [ Unit ] = 
 conn . run ( 
 - GlobalNamesStorage . upsert ( name , owner . toByteArray ) 
 + GlobalNamesStorage . upsert ( normalized ( name ) , owner . toByteArray ) 
 ) map ( _ ⇒ ( ) ) 
 
 / * * 
 * Compatible with storing nicknames in ` im . actor . server . persist . UserRepo ` 
 * / 
 private def delete ( name : String ) : Future [ Unit ] = { 
 - val kvDelete = conn . run ( GlobalNamesStorage . delete ( name ) ) 
 + val kvDelete = conn . run ( GlobalNamesStorage . delete ( normalized ( name ) ) ) 
 
 kvDelete flatMap { count ⇒ 
 - if ( count > 0 ) { 
 + if ( count = = 0 ) { 
 db . run { 
 for { 
 optUser ← UserRepo . findByNickname ( name ) 
 @ @ - 107 , 4 + 106 , 7 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { 
 } 
 } 
 } 
 + 
 + private def normalized ( name : String ) = name . toLowerCase 
 + 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala 
 index 962b4c1 . . a8d6dfc 100644 
 - - - a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala 
 + + + b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala 
 @ @ - 7 , 6 + 7 , 7 @ @ import akka . util . Timeout 
 import im . actor . server . commons . serialization . ActorSerializer 
 import shardakka . { StringCodec , Codec , ShardakkaExtension } 
 
 + import scala . collection . immutable 
 import scala . concurrent . { ExecutionContext , Future } 
 
 private case object End 
 @ @ - 29 , 7 + 30 , 7 @ @ case class SimpleKeyValue [ A ] ( 
 def getKeys ( ) ( implicit ec : ExecutionContext , timeout : Timeout ) : Future [ Seq [ String ] ] = 
 ( proxy ? RootQueries . GetKeys ( ) ) . mapTo [ RootQueries . GetKeysResponse ] map ( _ . keys ) 
 
 - def shutdown ( ) : Unit = { 
 + private [ keyvalue ] def shutdown ( ) : Unit = { 
 proxy ! End 
 root ! PoisonPill 
 proxy ! PoisonPill 
 @ @ - 56 , 25 + 57 , 39 @ @ trait SimpleKeyValueExtension { 
 ActorSerializer . register ( 15001 , classOf [ ValueEvents . ValueUpdated ] ) 
 ActorSerializer . register ( 15002 , classOf [ ValueEvents . ValueDeleted ] ) 
 
 - def startKeyValue [ A ] ( name : String , codec : Codec [ A ] ) ( implicit system : ActorSystem ) : SimpleKeyValue [ A ] = { 
 - val manager = system . actorOf ( 
 - ClusterSingletonManager . props ( 
 - singletonProps = SimpleKeyValueRoot . props ( name ) , 
 - singletonName = name , 
 - terminationMessage = End , 
 - role = None 
 - ) , name = s " SimpleKeyValueRoot - $ name " 
 - ) 
 - 
 - val proxy = system . actorOf ( 
 - ClusterSingletonProxy . props ( singletonPath = s " / user / SimpleKeyValueRoot - $ name / $ name " , role = None ) , 
 - name = s " SimpleKeyValueRoot - $ name - Proxy " 
 - ) 
 - 
 - SimpleKeyValue ( name , manager , proxy , codec ) 
 + @ volatile 
 + private var kvs = immutable . Map . empty [ String , SimpleKeyValue [ _ ] ] 
 + 
 + def simpleKeyValue [ A ] ( name : String , codec : Codec [ A ] ) ( implicit system : ActorSystem ) : SimpleKeyValue [ A ] = { 
 + kvs . get ( name ) match { 
 + case Some ( kv ) ⇒ kv . asInstanceOf [ SimpleKeyValue [ A ] ] 
 + case None ⇒ 
 + val manager = system . actorOf ( 
 + ClusterSingletonManager . props ( 
 + singletonProps = SimpleKeyValueRoot . props ( name ) , 
 + singletonName = name , 
 + terminationMessage = End , 
 + role = None 
 + ) , name = s " SimpleKeyValueRoot - $ name " 
 + ) 
 + 
 + val proxy = system . actorOf ( 
 + ClusterSingletonProxy . props ( singletonPath = s " / user / SimpleKeyValueRoot - $ name / $ name " , role = None ) , 
 + name = s " SimpleKeyValueRoot - $ name - Proxy " 
 + ) 
 + 
 + val kv = SimpleKeyValue ( name , manager , proxy , codec ) 
 + kvs + = ( name → kv ) 
 + kv 
 + } 
 } 
 
 - def startKeyValueString ( name : String ) ( implicit system : ActorSystem ) : SimpleKeyValue [ String ] = 
 - startKeyValue ( name , StringCodec ) 
 + def simpleKeyValue ( name : String ) ( implicit system : ActorSystem ) : SimpleKeyValue [ String ] = 
 + simpleKeyValue ( name , StringCodec ) 
 + 
 + def shutdownKeyValue ( name : String ) = kvs . get ( name ) foreach { kv ⇒ 
 + kv . shutdown ( ) 
 + kvs - = name 
 + } 
 } 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala b / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala 
 index d2e5c52 . . e6eddd9 100644 
 - - - a / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala 
 @ @ - 32 , 7 + 32 , 7 @ @ final class KeyValueSpec extends ActorSuite ( ActorSpecification . createSystem ( ) ) 
 val ext = ShardakkaExtension ( system ) 
 
 def setAndGet ( ) = { 
 - val keyValue = ext . startKeyValueString ( " setAndGet " ) 
 + val keyValue = ext . simpleKeyValue ( " setAndGet " ) 
 
 whenReady ( keyValue . get ( " key1 " ) ) { resp ⇒ 
 resp shouldBe empty 
 @ @ - 46 , 7 + 46 , 7 @ @ final class KeyValueSpec extends ActorSuite ( ActorSpecification . createSystem ( ) ) 
 } 
 
 def keysList ( ) = { 
 - val keyValue = ext . startKeyValueString ( " keysList " ) 
 + val keyValue = ext . simpleKeyValue ( " keysList " ) 
 
 whenReady ( Future . sequence ( Seq ( 
 keyValue . upsert ( " key1 " , " value " ) , 
 @ @ - 55 , 21 + 55 , 21 @ @ final class KeyValueSpec extends ActorSuite ( ActorSpecification . createSystem ( ) ) 
 ) ) ) ( identity ) 
 
 whenReady ( keyValue . getKeys ( ) ) { keys ⇒ 
 - keys shouldBe Seq ( " key1 " , " key2 " , " key3 " ) 
 + keys . toSet shouldBe Set ( " key1 " , " key2 " , " key3 " ) 
 } 
 } 
 
 def restoreState ( ) = { 
 val kvName = " restoreState " 
 
 - val keyValue = ext . startKeyValueString ( kvName ) 
 + val keyValue = ext . simpleKeyValue ( kvName ) 
 
 whenReady ( keyValue . upsert ( " key1 " , " value " ) ) ( identity ) 
 
 - keyValue . shutdown ( ) 
 + ext . shutdownKeyValue ( kvName ) 
 Thread . sleep ( 200 ) 
 
 - val keyValueNew = ext . startKeyValueString ( kvName ) 
 + val keyValueNew = ext . simpleKeyValue ( kvName ) 
 
 whenReady ( keyValueNew . get ( " key1 " ) ) { resp ⇒ 
 resp shouldBe Some ( " value " )
